{"sha": "c11207d345f8d678d440a3ff0f335b2ed25513e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzExMjA3ZDM0NWY4ZDY3OGQ0NDBhM2ZmMGYzMzViMmVkMjU1MTNlNw==", "commit": {"author": {"name": "Piotr Trojanek", "email": "trojanek@adacore.com", "date": "2021-01-08T18:53:41Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-05-05T08:18:59Z"}, "message": "[Ada] Speed up enumeration'Value with perfect hash function\n\ngcc/ada/\n\n\t* Makefile.rtl (GNATRTL_NONTASKING_OBJS): Add s-imagen, s-imen16,\n\ts-imen32, s-imenu8, s-pehage, s-valuen, s-vaen16, s-vaen32 and\n\ts-vaenu8.  Remove s-imenne, s-imgenu and s-valenu.\n\t* debug.adb (d_h): Document new usage.\n\t* einfo.ads (Lit_Hash): New attribute for enumeration types.\n\t(Set_Lit_Hash): Declare.\n\t* einfo.adb (Lit_Hash): New function.\n\t(Set_Lit_Hash): New procedure.\n\t(Write_Field21_Name): Print Lit_Hash for Enumeration_Kind.\n\t* exp_imgv.ads (Build_Enumeration_Image_Tables): Fix description\n\tand document the hash function and its tables.\n\t* exp_imgv.adb: Add with/use clauses for Debug.  Add with clause\n\tfor System.Perfect_Hash_Generators.\n\t(Append_Table_To): New helper routine.\n\t(Build_Enumeration_Image_Tables): Call it to build the tables.\n\tIn the main unit, register the literals with the hash generator.\n\tIf they are sufficiently many and -gnatd_h is not passed, generate\n\ta perfect hash function and its tables; otherwise, generate a dummy\n\thash function.  For the other units, generate only the declaration.\n\tIn all cases, set Lit_Hash to the entity of the function, if any.\n\t(Expand_Value_Attribute): Pass the 'Unrestricted_Access of Lit_Hash,\n\tif any, as third argument to the Value_Enumeration_NN function.\n\t* gnat1drv.adb (Adjust_Global_Switches): force simpler implementation\n\tof 'Value in CodePeer_Mode.\n\t* lib.ads (Synchronize_Serial_Number): Add SN parameter.\n\t* lib.adb (Synchronize_Serial_Number): Assert that it is larger than\n\tthe serial number of the current unit and set the latter to it only\n\tin this case.\n\t* rtsfind.ads (RTU_Id): Add System_Img_Enum_8, System_Img_Enum_16,\n\tSystem_Img_Enum_32, System_Val_Enum_8, System_Val_Enum_16 and\n\tSystem_Val_Enum_32.  Remove System_Img_Enum, System_Img_Enum_New\n\tand System_Val_Enum.\n\t* sem_attr.adb (Analyze_Access_Attribute): Do not flag a compiler\n\tgenerated Unrestricted_Access attribute as illegal in a declare\n\texpression.\n\t(RE_Unit_Table): Adjust to above changes.\n\t* libgnat/g-heasor.ads: Add pragma Compiler_Unit_Warning.\n\t* libgnat/g-table.ads: Likewise.\n\t* libgnat/g-pehage.ads: Add with clause and local renaming for\n\tSystem.Perfect_Hash_Generators.\n\t(Optimization): Turn into derived type.\n\t(Verbose): Turn into renaming.\n\t(Too_Many_Tries): Likewise.\n\t(Table_Name): Move to System.Perfect_Hash_Generators.\n\t(Define): Likewise.\n\t(Value): Likewise.\n\t* libgnat/g-pehage.adb: Remove with clause for Ada.Directories,\n\tGNAT.Heap_Sort_G and GNAT.Table.  Move bulk of implementation\n\tto System.Perfect_Hash_Generators, only keep the output part.\n\t* libgnat/s-imagen.ads: New generic unit.\n\t* libgnat/s-imagen.adb: New body.\n\t* libgnat/s-imen16.ads: New unit.\n\t* libgnat/s-imen32.ads: Likewise.\n\t* libgnat/s-imenu8.ads: Likewise.\n\t* libgnat/s-imenne.ads: Adjust description.\n\t* libgnat/s-imgenu.ads: Delete.\n\t* libgnat/s-imgenu.adb: Likewise.\n\t* libgnat/s-pehage.ads: New unit from GNAT.Perfect_Hash_Generators.\n\t* libgnat/s-pehage.adb: New body from GNAT.Perfect_Hash_Generators.\n\t* libgnat/s-valuen.ads: New generic unit.\n\t* libgnat/s-valuen.adb: New body.\n\t* libgnat/s-vaen16.ads: New unit.\n\t* libgnat/s-vaen32.ads: Likewise.\n\t* libgnat/s-vaenu8.ads: Likewise.\n\t* libgnat/s-valenu.ads: Delete.\n\t* libgnat/s-valenu.adb: Likewise.\n\t* gcc-interface/Make-lang.in (GNAT_ADA_OBJS): Add s-pehage.o.\n\t(GNATBIND_OBJS): Remove s-imgenu.o.", "tree": {"sha": "b49c478537d5a81054f25fe4d1a93aa44be4153a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b49c478537d5a81054f25fe4d1a93aa44be4153a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c11207d345f8d678d440a3ff0f335b2ed25513e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c11207d345f8d678d440a3ff0f335b2ed25513e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c11207d345f8d678d440a3ff0f335b2ed25513e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c11207d345f8d678d440a3ff0f335b2ed25513e7/comments", "author": {"login": "ptroja", "id": 161602, "node_id": "MDQ6VXNlcjE2MTYwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/161602?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ptroja", "html_url": "https://github.com/ptroja", "followers_url": "https://api.github.com/users/ptroja/followers", "following_url": "https://api.github.com/users/ptroja/following{/other_user}", "gists_url": "https://api.github.com/users/ptroja/gists{/gist_id}", "starred_url": "https://api.github.com/users/ptroja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ptroja/subscriptions", "organizations_url": "https://api.github.com/users/ptroja/orgs", "repos_url": "https://api.github.com/users/ptroja/repos", "events_url": "https://api.github.com/users/ptroja/events{/privacy}", "received_events_url": "https://api.github.com/users/ptroja/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78a4cb56a0f6fd46d469e6835fac6216ff91e29d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78a4cb56a0f6fd46d469e6835fac6216ff91e29d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78a4cb56a0f6fd46d469e6835fac6216ff91e29d"}], "stats": {"total": 5925, "additions": 3580, "deletions": 2345}, "files": [{"sha": "32081c972a8dac0226dfef3258548f2d7ac4407c", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=c11207d345f8d678d440a3ff0f335b2ed25513e7", "patch": "@@ -619,18 +619,20 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-imaged$(objext) \\\n   s-imagef$(objext) \\\n   s-imagei$(objext) \\\n+  s-imagen$(objext) \\\n   s-imager$(objext) \\\n   s-imageu$(objext) \\\n   s-imagew$(objext) \\\n   s-imde32$(objext) \\\n   s-imde64$(objext) \\\n-  s-imenne$(objext) \\\n+  s-imen16$(objext) \\\n+  s-imen32$(objext) \\\n+  s-imenu8$(objext) \\\n   s-imfi32$(objext) \\\n   s-imfi64$(objext) \\\n   s-imgbiu$(objext) \\\n   s-imgboo$(objext) \\\n   s-imgcha$(objext) \\\n-  s-imgenu$(objext) \\\n   s-imgflt$(objext) \\\n   s-imgint$(objext) \\\n   s-imglfl$(objext) \\\n@@ -714,6 +716,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-pack63$(objext) \\\n   s-parame$(objext) \\\n   s-parint$(objext) \\\n+  s-pehage$(objext) \\\n   s-pooglo$(objext) \\\n   s-pooloc$(objext) \\\n   s-poosiz$(objext) \\\n@@ -759,9 +762,11 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-valcha$(objext) \\\n   s-vade32$(objext) \\\n   s-vade64$(objext) \\\n+  s-vaen16$(objext) \\\n+  s-vaen32$(objext) \\\n+  s-vaenu8$(objext) \\\n   s-vafi32$(objext) \\\n   s-vafi64$(objext) \\\n-  s-valenu$(objext) \\\n   s-valflt$(objext) \\\n   s-valint$(objext) \\\n   s-vallfl$(objext) \\\n@@ -772,6 +777,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-valued$(objext) \\\n   s-valuef$(objext) \\\n   s-valuei$(objext) \\\n+  s-valuen$(objext) \\\n   s-valuer$(objext) \\\n   s-valueu$(objext) \\\n   s-valuns$(objext) \\"}, {"sha": "784c7e0d4b0626972a143c8d9e7b4b09179bdf75", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=c11207d345f8d678d440a3ff0f335b2ed25513e7", "patch": "@@ -146,7 +146,7 @@ package body Debug is\n    --  d_e  Ignore entry calls and requeue statements for elaboration\n    --  d_f  Issue info messages related to GNATprove usage\n    --  d_g\n-   --  d_h\n+   --  d_h  Disable the use of (perfect) hash functions for enumeration Value\n    --  d_i  Ignore activations and calls to instances for elaboration\n    --  d_j  Read JSON files and populate Repinfo tables (opposite of -gnatRjs)\n    --  d_k\n@@ -971,6 +971,9 @@ package body Debug is\n    --       beginners find them confusing. Set automatically by GNATprove when\n    --       switch --info is used.\n \n+   --  d_h  The compiler does not make use of (perfect) hash functions in the\n+   --       implementation of the Value attribute for enumeration types.\n+\n    --  d_i  The compiler ignores calls and task activations when they target a\n    --       subprogram or task type defined in an external instance for both\n    --       the static and dynamic elaboration models."}, {"sha": "2da6f4465f974e3a45afba8911c4b953e1dd925b", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=c11207d345f8d678d440a3ff0f335b2ed25513e7", "patch": "@@ -180,6 +180,7 @@ package body Einfo is\n    --    Corresponding_Record_Component  Node21\n    --    Default_Expr_Function           Node21\n    --    Discriminant_Constraint         Elist21\n+   --    Lit_Hash                        Node21\n    --    Interface_Name                  Node21\n    --    Original_Array_Type             Node21\n    --    Small_Value                     Ureal21\n@@ -2836,6 +2837,12 @@ package body Einfo is\n       return Node33 (Id);\n    end Linker_Section_Pragma;\n \n+   function Lit_Hash (Id : E) return E is\n+   begin\n+      pragma Assert (Is_Enumeration_Type (Id));\n+      return Node21 (Id);\n+   end Lit_Hash;\n+\n    function Lit_Indexes (Id : E) return E is\n    begin\n       pragma Assert (Is_Enumeration_Type (Id));\n@@ -6103,6 +6110,12 @@ package body Einfo is\n       Set_Node33 (Id, V);\n    end Set_Linker_Section_Pragma;\n \n+   procedure Set_Lit_Hash (Id : E; V : E) is\n+   begin\n+      pragma Assert (Is_Enumeration_Type (Id) and then Root_Type (Id) = Id);\n+      Set_Node21 (Id, V);\n+   end Set_Lit_Hash;\n+\n    procedure Set_Lit_Indexes (Id : E; V : E) is\n    begin\n       pragma Assert (Is_Enumeration_Type (Id) and then Root_Type (Id) = Id);\n@@ -10884,6 +10897,9 @@ package body Einfo is\n          =>\n             Write_Str (\"Interface_Name\");\n \n+         when Enumeration_Kind =>\n+            Write_Str (\"Lit_Hash\");\n+\n          when Array_Kind\n             | Modular_Integer_Kind\n          =>"}, {"sha": "a88f1fd2d875768acc39b84c5ed31dbc8ab52267", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=c11207d345f8d678d440a3ff0f335b2ed25513e7", "patch": "@@ -3498,6 +3498,13 @@ package Einfo is\n --       field may be set as a result of a linker section pragma applied to the\n --       type of the object.\n \n+--    Lit_Hash (Node21)\n+--       Defined in enumeration types and subtypes. Non-empty only for the\n+--       case of an enumeration root type, where it contains the entity for\n+--       the generated hash function. See unit Exp_Imgv for full details of\n+--       the nature and use of this entity for implementing the Value\n+--       attribute for the enumeration type in question.\n+\n --    Lit_Indexes (Node18)\n --       Defined in enumeration types and subtypes. Non-empty only for the\n --       case of an enumeration root type, where it contains the entity for\n@@ -6150,6 +6157,7 @@ package Einfo is\n    --    Lit_Indexes                         (Node18)   (root type only)\n    --    Default_Aspect_Value                (Node19)   (base type only)\n    --    Scalar_Range                        (Node20)\n+   --    Lit_Hash                            (Node21)   (root type only)\n    --    Enum_Pos_To_Rep                     (Node23)   (type only)\n    --    Static_Discrete_Predicate           (List25)\n    --    Has_Biased_Representation           (Flag139)\n@@ -7469,6 +7477,7 @@ package Einfo is\n    function Last_Entity                         (Id : E) return E;\n    function Limited_View                        (Id : E) return E;\n    function Linker_Section_Pragma               (Id : E) return N;\n+   function Lit_Hash                            (Id : E) return E;\n    function Lit_Indexes                         (Id : E) return E;\n    function Lit_Strings                         (Id : E) return E;\n    function Low_Bound_Tested                    (Id : E) return B;\n@@ -8191,6 +8200,7 @@ package Einfo is\n    procedure Set_Last_Entity                     (Id : E; V : E);\n    procedure Set_Limited_View                    (Id : E; V : E);\n    procedure Set_Linker_Section_Pragma           (Id : E; V : N);\n+   procedure Set_Lit_Hash                        (Id : E; V : E);\n    procedure Set_Lit_Indexes                     (Id : E; V : E);\n    procedure Set_Lit_Strings                     (Id : E; V : E);\n    procedure Set_Low_Bound_Tested                (Id : E; V : B := True);\n@@ -9073,6 +9083,7 @@ package Einfo is\n    pragma Inline (Limited_View);\n    pragma Inline (Link_Entities);\n    pragma Inline (Linker_Section_Pragma);\n+   pragma Inline (Lit_Hash);\n    pragma Inline (Lit_Indexes);\n    pragma Inline (Lit_Strings);\n    pragma Inline (Low_Bound_Tested);\n@@ -9643,6 +9654,7 @@ package Einfo is\n    pragma Inline (Set_Last_Entity);\n    pragma Inline (Set_Limited_View);\n    pragma Inline (Set_Linker_Section_Pragma);\n+   pragma Inline (Set_Lit_Hash);\n    pragma Inline (Set_Lit_Indexes);\n    pragma Inline (Set_Lit_Strings);\n    pragma Inline (Set_Low_Bound_Tested);"}, {"sha": "b060af405618e41b5cb8074a475b4b3b3758d44e", "filename": "gcc/ada/exp_imgv.adb", "status": "modified", "additions": 508, "deletions": 30, "changes": 538, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Fexp_imgv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Fexp_imgv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_imgv.adb?ref=c11207d345f8d678d440a3ff0f335b2ed25513e7", "patch": "@@ -26,6 +26,7 @@\n with Atree;    use Atree;\n with Casing;   use Casing;\n with Checks;   use Checks;\n+with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Exp_Put_Image;\n with Exp_Util; use Exp_Util;\n@@ -47,6 +48,8 @@ with Ttypes;   use Ttypes;\n with Uintp;    use Uintp;\n with Urealp;   use Urealp;\n \n+with System.Perfect_Hash_Generators;\n+\n package body Exp_Imgv is\n \n    procedure Rewrite_Object_Image\n@@ -65,21 +68,88 @@ package body Exp_Imgv is\n    ------------------------------------\n \n    procedure Build_Enumeration_Image_Tables (E : Entity_Id; N : Node_Id) is\n-      Loc : constant Source_Ptr := Sloc (E);\n+      Loc          : constant Source_Ptr := Sloc (E);\n+      In_Main_Unit : constant Boolean    := In_Extended_Main_Code_Unit (Loc);\n \n+      Act  : List_Id;\n       Eind : Entity_Id;\n       Estr : Entity_Id;\n+      H_Id : Entity_Id;\n+      H_OK : Boolean;\n+      H_Sp : Node_Id;\n       Ind  : List_Id;\n       Ityp : Node_Id;\n       Len  : Nat;\n       Lit  : Entity_Id;\n       Nlit : Nat;\n+      S_Id : Entity_Id;\n+      S_N  : Nat;\n       Str  : String_Id;\n \n+      package SPHG renames System.Perfect_Hash_Generators;\n+\n       Saved_SSO : constant Character := Opt.Default_SSO;\n       --  Used to save the current scalar storage order during the generation\n       --  of the literal lookup table.\n \n+      Serial_Number_Budget : constant := 50;\n+      --  We may want to compute a perfect hash function for use by the Value\n+      --  attribute. However computing this function is costly and, therefore,\n+      --  cannot be done when compiling every unit where the enumeration type\n+      --  is referenced, so we do it only when compiling the unit where it is\n+      --  declared. This means that we may need to control the internal serial\n+      --  numbers of this unit, or else we would risk generating public symbols\n+      --  with mismatched names later on. The strategy for this is to allocate\n+      --  a fixed budget of serial numbers to be spent from a specified point\n+      --  until the end of the processing and to make sure that it is always\n+      --  exactly spent on all possible paths from this point.\n+\n+      Threshold : constant := 3;\n+      --  Threshold above which we want to generate the hash function in the\n+      --  default case.\n+\n+      Threshold_For_Size : constant := 9;\n+      --  But the function and its tables take a bit of space so the threshold\n+      --  is raised when compiling for size.\n+\n+      procedure Append_Table_To\n+        (L    : List_Id;\n+         E    : Entity_Id;\n+         UB   : Nat;\n+         Ctyp : Entity_Id;\n+         V    : List_Id);\n+      --  Append to L the declaration of E as a constant array of range 0 .. UB\n+      --  and component type Ctyp with initial value V.\n+\n+      ---------------------\n+      -- Append_Table_To --\n+      ---------------------\n+\n+      procedure Append_Table_To\n+        (L    : List_Id;\n+         E    : Entity_Id;\n+         UB   : Nat;\n+         Ctyp : Entity_Id;\n+         V    : List_Id)\n+      is\n+      begin\n+         Append_To (L,\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => E,\n+             Constant_Present    => True,\n+             Object_Definition   =>\n+               Make_Constrained_Array_Definition (Loc,\n+                 Discrete_Subtype_Definitions => New_List (\n+                   Make_Range (Loc,\n+                     Low_Bound  => Make_Integer_Literal (Loc, 0),\n+                     High_Bound => Make_Integer_Literal (Loc, UB))),\n+                 Component_Definition =>\n+                   Make_Component_Definition (Loc,\n+                     Aliased_Present    => False,\n+                     Subtype_Indication => New_Occurrence_Of (Ctyp, Loc))),\n+             Expression          => Make_Aggregate (Loc, Expressions => V)));\n+      end Append_Table_To;\n+\n    begin\n       --  Nothing to do for types other than a root enumeration type\n \n@@ -99,10 +169,10 @@ package body Exp_Imgv is\n       Lit := First_Literal (E);\n       Len := 1;\n       Nlit := 0;\n+      H_OK := False;\n \n       loop\n-         Append_To (Ind,\n-           Make_Integer_Literal (Loc, UI_From_Int (Len)));\n+         Append_To (Ind, Make_Integer_Literal (Loc, UI_From_Int (Len)));\n \n          exit when No (Lit);\n          Nlit := Nlit + 1;\n@@ -114,6 +184,9 @@ package body Exp_Imgv is\n          end if;\n \n          Store_String_Chars (Name_Buffer (1 .. Name_Len));\n+         if In_Main_Unit then\n+            SPHG.Insert (Name_Buffer (1 .. Name_Len));\n+         end if;\n          Len := Len + Int (Name_Len);\n          Next_Literal (Lit);\n       end loop;\n@@ -148,7 +221,7 @@ package body Exp_Imgv is\n \n       --  Generate literal table\n \n-      Insert_Actions (N,\n+      Act :=\n         New_List (\n           Make_Object_Declaration (Loc,\n             Defining_Identifier => Estr,\n@@ -157,27 +230,420 @@ package body Exp_Imgv is\n               New_Occurrence_Of (Standard_String, Loc),\n             Expression          =>\n               Make_String_Literal (Loc,\n-                Strval => Str)),\n+                Strval => Str)));\n \n-          Make_Object_Declaration (Loc,\n-            Defining_Identifier => Eind,\n-            Constant_Present    => True,\n+      --  Generate index table\n \n-            Object_Definition =>\n-              Make_Constrained_Array_Definition (Loc,\n-                Discrete_Subtype_Definitions => New_List (\n-                  Make_Range (Loc,\n-                    Low_Bound  => Make_Integer_Literal (Loc, 0),\n-                    High_Bound => Make_Integer_Literal (Loc, Nlit))),\n-                Component_Definition =>\n-                  Make_Component_Definition (Loc,\n-                    Aliased_Present    => False,\n-                    Subtype_Indication => New_Occurrence_Of (Ityp, Loc))),\n+      Append_Table_To (Act, Eind, Nlit, Ityp, Ind);\n \n-            Expression          =>\n-              Make_Aggregate (Loc,\n-                Expressions => Ind))),\n-        Suppress => All_Checks);\n+      --  If the number of literals is at most 3, then we are done. Otherwise\n+      --  we compute a (perfect) hash function for use by the Value attribute.\n+\n+      if Nlit > Threshold then\n+         --  We start to count serial numbers from here\n+\n+         S_N := Increment_Serial_Number;\n+\n+         --  Generate specification of hash function\n+\n+         H_Id :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => New_External_Name (Chars (E), 'H'));\n+         Set_Ekind       (H_Id, E_Function);\n+         Set_Is_Internal (H_Id);\n+\n+         if not Debug_Generated_Code then\n+            Set_Debug_Info_Off (H_Id);\n+         end if;\n+\n+         Set_Lit_Hash (E, H_Id);\n+\n+         S_Id := Make_Temporary (Loc, 'S');\n+\n+         H_Sp := Make_Function_Specification (Loc,\n+           Defining_Unit_Name       => H_Id,\n+           Parameter_Specifications => New_List (\n+             Make_Parameter_Specification (Loc,\n+               Defining_Identifier => S_Id,\n+               Parameter_Type      =>\n+                 New_Occurrence_Of (Standard_String, Loc))),\n+           Result_Definition       =>\n+             New_Occurrence_Of (Standard_Natural, Loc));\n+\n+         --  If the unit where the type is declared is the main unit, and the\n+         --  number of literals is greater than Threshold_For_Size when we are\n+         --  optimizing for size, and -gnatd_h is not specified, try to compute\n+         --  the hash function.\n+\n+         if In_Main_Unit\n+           and then (Optimize_Size = 0 or else Nlit > Threshold_For_Size)\n+           and then not Debug_Flag_Underscore_H\n+         then\n+            declare\n+               LB : constant Positive := 2 * Positive (Nlit) + 1;\n+               UB : constant Positive := LB + 24;\n+\n+            begin\n+               --  Try at most 25 * 4 times to compute the hash function before\n+               --  giving up and using a linear search for the Value attribute.\n+\n+               for V in LB .. UB loop\n+                  begin\n+                     SPHG.Initialize (4321, V, SPHG.Memory_Space, Tries => 4);\n+                     SPHG.Compute (\"\");\n+                     H_OK := True;\n+                     exit;\n+                  exception\n+                     when SPHG.Too_Many_Tries => null;\n+                  end;\n+               end loop;\n+            end;\n+         end if;\n+\n+         --  If the hash function has been successfully computed, 4 more tables\n+         --  named P, T1, T2 and G are needed. The hash function is of the form\n+\n+         --     function Hash (S : String) return Natural is\n+         --        F    : constant Natural := S'First - 1;\n+         --        L    : constant Natural := S'Length;\n+         --        A, B : Natural := 0;\n+         --        J    : Natural;\n+\n+         --     begin\n+         --        for K in P'Range loop\n+         --           exit when L < P (K);\n+         --           J := Character'Pos (S (P (K) + F));\n+         --           A := (A + Natural (T1 (K) * J)) mod N;\n+         --           B := (B + Natural (T2 (K) * J)) mod N;\n+         --        end loop;\n+\n+         --        return (Natural (G (A)) + Natural (G (B))) mod M;\n+         --     end Hash;\n+\n+         --  where N is the length of G and M the number of literals.\n+\n+         if H_OK then\n+            declare\n+               Siz, L1, L2 : Natural;\n+               I           : Int;\n+\n+               Pos,  T1,  T2,  G  : List_Id;\n+               EPos, ET1, ET2, EG : Entity_Id;\n+\n+               F, L, A, B, J, K : Entity_Id;\n+               Body_Decls       : List_Id;\n+               Body_Stmts       : List_Id;\n+               Loop_Stmts       : List_Id;\n+\n+            begin\n+               --  Generate position table\n+\n+               SPHG.Define (SPHG.Character_Position, Siz, L1, L2);\n+               Pos := New_List;\n+               for J in 0 .. L1 - 1 loop\n+                  I := Int (SPHG.Value (SPHG.Character_Position, J));\n+                  Append_To (Pos, Make_Integer_Literal (Loc, UI_From_Int (I)));\n+               end loop;\n+\n+               EPos :=\n+                 Make_Defining_Identifier (Loc,\n+                   Chars => New_External_Name (Chars (E), 'P'));\n+\n+               Append_Table_To\n+                 (Act, EPos, Nat (L1 - 1), Standard_Natural, Pos);\n+\n+               --  Generate function table 1\n+\n+               SPHG.Define (SPHG.Function_Table_1, Siz, L1, L2);\n+               T1 := New_List;\n+               for J in 0 .. L1 - 1 loop\n+                  I := Int (SPHG.Value (SPHG.Function_Table_1, J));\n+                  Append_To (T1, Make_Integer_Literal (Loc, UI_From_Int (I)));\n+               end loop;\n+\n+               ET1 :=\n+                 Make_Defining_Identifier (Loc,\n+                   Chars => New_External_Name (Chars (E), \"T1\"));\n+\n+               Ityp :=\n+                 Small_Integer_Type_For (UI_From_Int (Int (Siz)), Uns => True);\n+               Append_Table_To (Act, ET1, Nat (L1 - 1), Ityp, T1);\n+\n+               --  Generate function table 2\n+\n+               SPHG.Define (SPHG.Function_Table_2, Siz, L1, L2);\n+               T2 := New_List;\n+               for J in 0 .. L1 - 1 loop\n+                  I := Int (SPHG.Value (SPHG.Function_Table_2, J));\n+                  Append_To (T2, Make_Integer_Literal (Loc, UI_From_Int (I)));\n+               end loop;\n+\n+               ET2 :=\n+                 Make_Defining_Identifier (Loc,\n+                   Chars => New_External_Name (Chars (E), \"T2\"));\n+\n+               Ityp :=\n+                 Small_Integer_Type_For (UI_From_Int (Int (Siz)), Uns => True);\n+               Append_Table_To (Act, ET2, Nat (L1 - 1), Ityp, T2);\n+\n+               --  Generate graph table\n+\n+               SPHG.Define (SPHG.Graph_Table, Siz, L1, L2);\n+               G := New_List;\n+               for J in 0 .. L1 - 1 loop\n+                  I := Int (SPHG.Value (SPHG.Graph_Table, J));\n+                  Append_To (G, Make_Integer_Literal (Loc, UI_From_Int (I)));\n+               end loop;\n+\n+               EG :=\n+                 Make_Defining_Identifier (Loc,\n+                   Chars => New_External_Name (Chars (E), 'G'));\n+\n+               Ityp :=\n+                 Small_Integer_Type_For (UI_From_Int (Int (Siz)), Uns => True);\n+               Append_Table_To (Act, EG, Nat (L1 - 1), Ityp, G);\n+\n+               --  Generate body of hash function\n+\n+               F := Make_Temporary (Loc, 'F');\n+\n+               Body_Decls := New_List (\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => F,\n+                   Object_Definition   =>\n+                     New_Occurrence_Of (Standard_Natural, Loc),\n+                   Expression          =>\n+                     Make_Op_Subtract (Loc,\n+                       Left_Opnd  =>\n+                         Make_Attribute_Reference (Loc,\n+                           Prefix => New_Occurrence_Of (S_Id, Loc),\n+                           Attribute_Name => Name_First),\n+                       Right_Opnd =>\n+                         Make_Integer_Literal (Loc, 1))));\n+\n+               L := Make_Temporary (Loc, 'L');\n+\n+               Append_To (Body_Decls,\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => L,\n+                   Object_Definition   =>\n+                     New_Occurrence_Of (Standard_Natural, Loc),\n+                   Expression          =>\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix         => New_Occurrence_Of (S_Id, Loc),\n+                       Attribute_Name => Name_Length)));\n+\n+               A := Make_Temporary (Loc, 'A');\n+\n+               Append_To (Body_Decls,\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => A,\n+                   Object_Definition   =>\n+                     New_Occurrence_Of (Standard_Natural, Loc),\n+                   Expression          => Make_Integer_Literal (Loc, 0)));\n+\n+               B := Make_Temporary (Loc, 'B');\n+\n+               Append_To (Body_Decls,\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => B,\n+                   Object_Definition   =>\n+                     New_Occurrence_Of (Standard_Natural, Loc),\n+                   Expression          => Make_Integer_Literal (Loc, 0)));\n+\n+               J := Make_Temporary (Loc, 'J');\n+\n+               Append_To (Body_Decls,\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => J,\n+                   Object_Definition   =>\n+                     New_Occurrence_Of (Standard_Natural, Loc)));\n+\n+               K := Make_Temporary (Loc, 'K');\n+\n+               --  Generate exit when L < P (K);\n+\n+               Loop_Stmts := New_List (\n+                 Make_Exit_Statement (Loc,\n+                   Condition =>\n+                     Make_Op_Lt (Loc,\n+                       Left_Opnd  => New_Occurrence_Of (L, Loc),\n+                       Right_Opnd =>\n+                         Make_Indexed_Component (Loc,\n+                           Prefix      => New_Occurrence_Of (EPos, Loc),\n+                           Expressions => New_List (\n+                             New_Occurrence_Of (K, Loc))))));\n+\n+               --  Generate J := Character'Pos (S (P (K) + F));\n+\n+               Append_To (Loop_Stmts,\n+                 Make_Assignment_Statement (Loc,\n+                   Name       => New_Occurrence_Of (J, Loc),\n+                   Expression =>\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix         =>\n+                         New_Occurrence_Of (Standard_Character, Loc),\n+                       Attribute_Name => Name_Pos,\n+                       Expressions    => New_List (\n+                         Make_Indexed_Component (Loc,\n+                           Prefix      => New_Occurrence_Of (S_Id, Loc),\n+                           Expressions => New_List (\n+                              Make_Op_Add (Loc,\n+                                Left_Opnd  =>\n+                                  Make_Indexed_Component (Loc,\n+                                    Prefix      =>\n+                                      New_Occurrence_Of (EPos, Loc),\n+                                  Expressions => New_List (\n+                                    New_Occurrence_Of (K, Loc))),\n+                                Right_Opnd =>\n+                                  New_Occurrence_Of (F, Loc))))))));\n+\n+               --  Generate A := (A + Natural (T1 (K) * J)) mod N;\n+\n+               Append_To (Loop_Stmts,\n+                 Make_Assignment_Statement (Loc,\n+                   Name       => New_Occurrence_Of (A, Loc),\n+                   Expression =>\n+                     Make_Op_Mod (Loc,\n+                       Left_Opnd  =>\n+                          Make_Op_Add (Loc,\n+                            Left_Opnd  => New_Occurrence_Of (A, Loc),\n+                            Right_Opnd =>\n+                              Make_Op_Multiply (Loc,\n+                                Left_Opnd  =>\n+                                  Convert_To (Standard_Natural,\n+                                     Make_Indexed_Component (Loc,\n+                                       Prefix      =>\n+                                         New_Occurrence_Of (ET1, Loc),\n+                                       Expressions => New_List (\n+                                         New_Occurrence_Of (K, Loc)))),\n+                                Right_Opnd => New_Occurrence_Of (J, Loc))),\n+                       Right_Opnd => Make_Integer_Literal (Loc, Int (L1)))));\n+\n+               --  Generate B := (B + Natural (T2 (K) * J)) mod N;\n+\n+               Append_To (Loop_Stmts,\n+                 Make_Assignment_Statement (Loc,\n+                   Name       => New_Occurrence_Of (B, Loc),\n+                   Expression =>\n+                     Make_Op_Mod (Loc,\n+                       Left_Opnd  =>\n+                          Make_Op_Add (Loc,\n+                            Left_Opnd  => New_Occurrence_Of (B, Loc),\n+                            Right_Opnd =>\n+                              Make_Op_Multiply (Loc,\n+                                Left_Opnd  =>\n+                                  Convert_To (Standard_Natural,\n+                                     Make_Indexed_Component (Loc,\n+                                       Prefix      =>\n+                                         New_Occurrence_Of (ET2, Loc),\n+                                       Expressions => New_List (\n+                                         New_Occurrence_Of (K, Loc)))),\n+                                Right_Opnd => New_Occurrence_Of (J, Loc))),\n+                       Right_Opnd => Make_Integer_Literal (Loc, Int (L1)))));\n+\n+            --  Generate loop\n+\n+               Body_Stmts := New_List (\n+                 Make_Implicit_Loop_Statement (N,\n+                   Iteration_Scheme =>\n+                     Make_Iteration_Scheme (Loc,\n+                       Loop_Parameter_Specification =>\n+                         Make_Loop_Parameter_Specification (Loc,\n+                           Defining_Identifier         => K,\n+                           Discrete_Subtype_Definition =>\n+                             Make_Attribute_Reference (Loc,\n+                               Prefix         =>\n+                                 New_Occurrence_Of (EPos, Loc),\n+                               Attribute_Name => Name_Range))),\n+                   Statements       => Loop_Stmts));\n+\n+               --  Generate return (Natural (G (A)) + Natural (G (B))) mod M;\n+\n+               Append_To (Body_Stmts,\n+                 Make_Simple_Return_Statement (Loc,\n+                   Expression =>\n+                     Make_Op_Mod (Loc,\n+                       Left_Opnd  =>\n+                         Make_Op_Add (Loc,\n+                           Left_Opnd  =>\n+                             Convert_To (Standard_Natural,\n+                               Make_Indexed_Component (Loc,\n+                                 Prefix      =>\n+                                   New_Occurrence_Of (EG, Loc),\n+                                 Expressions => New_List (\n+                                   New_Occurrence_Of (A, Loc)))),\n+                           Right_Opnd =>\n+                             Convert_To (Standard_Natural,\n+                               Make_Indexed_Component (Loc,\n+                                 Prefix      =>\n+                                   New_Occurrence_Of (EG, Loc),\n+                                 Expressions => New_List (\n+                                   New_Occurrence_Of (B, Loc))))),\n+                       Right_Opnd => Make_Integer_Literal (Loc, Nlit))));\n+\n+               --  Generate final body\n+\n+               Append_To (Act,\n+                 Make_Subprogram_Body (Loc,\n+                   Specification => H_Sp,\n+                   Declarations => Body_Decls,\n+                   Handled_Statement_Sequence =>\n+                     Make_Handled_Sequence_Of_Statements (Loc, Body_Stmts)));\n+            end;\n+\n+         --  If we chose not to or did not manage to compute the hash function,\n+         --  we need to build a dummy function always returning Natural'Last\n+         --  because other units reference it if they use the Value attribute.\n+\n+         elsif In_Main_Unit then\n+            declare\n+               Body_Stmts : List_Id;\n+\n+            begin\n+               --  Generate return Natural'Last\n+\n+               Body_Stmts := New_List (\n+                 Make_Simple_Return_Statement (Loc,\n+                   Expression =>\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix         =>\n+                         New_Occurrence_Of (Standard_Natural, Loc),\n+                       Attribute_Name => Name_Last)));\n+\n+               --  Generate body\n+\n+               Append_To (Act,\n+                 Make_Subprogram_Body (Loc,\n+                   Specification => H_Sp,\n+                   Declarations => Empty_List,\n+                   Handled_Statement_Sequence =>\n+                     Make_Handled_Sequence_Of_Statements (Loc, Body_Stmts)));\n+            end;\n+\n+         --  For the other units, just declare the function\n+\n+         else\n+            Append_To (Act,\n+              Make_Subprogram_Declaration (Loc, Specification => H_Sp));\n+         end if;\n+\n+      else\n+         Set_Lit_Hash (E, Empty);\n+      end if;\n+\n+      if In_Main_Unit then\n+         System.Perfect_Hash_Generators.Finalize;\n+      end if;\n+\n+      Insert_Actions (N, Act, Suppress => All_Checks);\n+\n+      --  This is where we check that our budget of serial numbers has been\n+      --  entirely spent, see the declaration of Serial_Number_Budget above.\n+\n+      if Nlit > Threshold then\n+         Synchronize_Serial_Number (S_N + Serial_Number_Budget);\n+      end if;\n \n       --  Reset the scalar storage order to the saved value\n \n@@ -916,15 +1382,17 @@ package body Exp_Imgv is\n    --  For enumeration types other than those derived from types Boolean,\n    --  Character, Wide_[Wide_]Character in Standard, typ'Value (X) expands to:\n \n-   --    Enum'Val (Value_Enumeration_NN (typS, typI'Address, Num, X))\n+   --    Enum'Val\n+   --      (Value_Enumeration_NN\n+   --        (typS, typN'Address, typH'Unrestricted_Access, Num, X))\n \n-   --  where typS and typI and the Lit_Strings and Lit_Indexes entities\n-   --  from T's root type entity, and Num is Enum'Pos (Enum'Last). The\n-   --  Value_Enumeration_NN function will search the tables looking for\n+   --  where typS, typN and typH are the Lit_Strings, Lit_Indexes and Lit_Hash\n+   --  entities from T's root type entity, and Num is Enum'Pos (Enum'Last).\n+   --  The Value_Enumeration_NN function will search the tables looking for\n    --  X and return the position number in the table if found which is\n    --  used to provide the result of 'Value (using Enum'Val). If the\n    --  value is not found Constraint_Error is raised. The suffix _NN\n-   --  depends on the element type of typI.\n+   --  depends on the element type of typN.\n \n    procedure Expand_Value_Attribute (N : Node_Id) is\n       Loc   : constant Source_Ptr := Sloc (N);\n@@ -1083,10 +1551,11 @@ package body Exp_Imgv is\n \n             Analyze_And_Resolve (N, Btyp);\n \n-         --  Here for normal case where we have enumeration tables, this\n-         --  is where we build\n+         --  Normal case where we have enumeration tables, build\n \n-         --    T'Val (Value_Enumeration_NN (typS, typI'Address, Num, X))\n+         --   T'Val\n+         --     (Value_Enumeration_NN\n+         --       (typS, typN'Address, typH'Unrestricted_Access, Num, X))\n \n          else\n             Ttyp := Component_Type (Etype (Lit_Indexes (Rtyp)));\n@@ -1108,6 +1577,15 @@ package body Exp_Imgv is\n                     Prefix => New_Occurrence_Of (Rtyp, Loc),\n                     Attribute_Name => Name_Last))));\n \n+            if Present (Lit_Hash (Rtyp)) then\n+               Prepend_To (Args,\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix => New_Occurrence_Of (Lit_Hash (Rtyp), Loc),\n+                   Attribute_Name => Name_Unrestricted_Access));\n+            else\n+               Prepend_To (Args, Make_Null (Loc));\n+            end if;\n+\n             Prepend_To (Args,\n               Make_Attribute_Reference (Loc,\n                 Prefix => New_Occurrence_Of (Lit_Indexes (Rtyp), Loc),"}, {"sha": "76e1ca62217668760fbd9f8d2f32aee49efaad9c", "filename": "gcc/ada/exp_imgv.ads", "status": "modified", "additions": 34, "deletions": 24, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Fexp_imgv.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Fexp_imgv.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_imgv.ads?ref=c11207d345f8d678d440a3ff0f335b2ed25513e7", "patch": "@@ -35,39 +35,49 @@ package Exp_Imgv is\n    --  base type. The node N is the point in the tree where the resulting\n    --  declarations are to be inserted.\n    --\n-   --    The form of the tables generated is as follows:\n+   --  The form of the tables generated is as follows:\n    --\n-   --      xxxS : string := \"chars\";\n-   --      xxxI : array (0 .. N) of Natural_8/16/32 := (1, n, .., n);\n+   --    xxxS : constant string (1 .. M) := \"chars\";\n+   --    xxxN : constant array (0 .. N) of Index_Type := (i1, i2, .., iN, j);\n    --\n-   --    Here xxxS is a string obtained by concatenating all the names\n-   --    of the enumeration literals in sequence, representing any wide\n-   --    characters according to the current wide character encoding\n-   --    method, and with all letters forced to upper case.\n+   --  Here xxxS is a string obtained by concatenating all the names of the\n+   --  enumeration literals in sequence, representing any wide characters\n+   --  according to the current wide character encoding method, and with all\n+   --  letters forced to upper case.\n    --\n-   --    The array xxxI is an array of ones origin indexes to the start\n-   --    of each name, with one extra entry at the end, which is the index\n-   --    to the character just past the end of the last literal, i.e. it is\n-   --    the length of xxxS + 1. The element type is the shortest of the\n-   --    possible types that will hold all the values.\n+   --  The array xxxN is an array of indexes into xxxS pointing to the start\n+   --  of each name, with one extra entry at the end, which is the index to\n+   --  the character just past the end of the last literal, i.e. it is the\n+   --  length of xxxS + 1. The element type is the shortest of the possible\n+   --  types that will hold all the values.\n    --\n-   --      For example, for the type\n+   --  For example, for the type\n    --\n-   --         type x is (hello,'!',goodbye);\n+   --     type x is (hello,'!',goodbye);\n    --\n-   --      the generated tables would consist of\n+   --  the generated tables would consist of\n    --\n-   --          xxxS : String := \"hello'!'goodbye\";\n-   --          xxxI : array (0 .. 3) of Natural_8 := (1, 6, 9, 16);\n+   --      xxxS : constant string (1 .. 15) := \"hello'!'goodbye\";\n+   --      xxxN : constant array (0 .. 3) of Integer_8 := (1, 6, 9, 16);\n    --\n-   --      Here Natural_8 is used since 16 < 2**(8-1)\n+   --  Here Integer_8 is used since 16 < 2**(8-1).\n    --\n-   --    If the entity E needs the tables constructing, the necessary\n-   --    declarations are constructed, and the fields Lit_Strings and\n-   --    Lit_Indexes of E are set to point to the corresponding entities.\n-   --    If no tables are needed (E is not a user defined enumeration\n-   --    root type, or pragma Discard_Names is in effect, then the\n-   --    declarations are not constructed, and the fields remain Empty.\n+   --  If the entity E needs the tables, the necessary declarations are built\n+   --  and the fields Lit_Strings and Lit_Indexes of E are set to point to the\n+   --  corresponding entities. If no tables are needed (E is not a user defined\n+   --  enumeration root type, or pragma Discard_Names is in effect), then the\n+   --  declarations are not constructed and the fields remain Empty.\n+   --\n+   --  If the number of enumeration literals is large enough, a (perfect) hash\n+   --  function mapping the literals to their position number is also built and\n+   --  requires in turn to build four additional tables:\n+   --\n+   --    xxxP  : constant array (0 .. X - 1) of Natural = (p1, p2, ..., pX);\n+   --    xxxT1 : constant array (0 .. Y - 1) of Index_Type = (q1, ..., qY);\n+   --    xxxT2 : constant array (0 .. Y - 1) of Index_Type = (r1, ..., rY);\n+   --    xxxG  : constant array (0 .. Z - 1) of Index_Type = (s1, ..., sZ);\n+   --\n+   --  See the System.Perfect_Hash_Generators unit for a complete description.\n \n    procedure Expand_Image_Attribute (N : Node_Id);\n    --  This procedure is called from Exp_Attr to expand an occurrence of the"}, {"sha": "6e873e25f0d60ad48b9e7fecf7fc5913f6b3eaaa", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=c11207d345f8d678d440a3ff0f335b2ed25513e7", "patch": "@@ -390,6 +390,7 @@ GNAT_ADA_OBJS =\t\\\n  ada/libgnat/s-memory.o\t\\\n  ada/libgnat/s-os_lib.o\t\\\n  ada/libgnat/s-parame.o\t\\\n+ ada/libgnat/s-pehage.o\t\\\n  ada/libgnat/s-purexc.o\t\\\n  ada/libgnat/s-restri.o\t\\\n  ada/libgnat/s-secsta.o\t\\\n@@ -585,7 +586,6 @@ GNATBIND_OBJS = \\\n  ada/libgnat/s-exctab.o   \\\n  ada/libgnat/s-htable.o   \\\n  ada/libgnat/s-imenne.o   \\\n- ada/libgnat/s-imgenu.o   \\\n  ada/libgnat/s-imgint.o   \\\n  ada/libgnat/s-mastop.o   \\\n  ada/libgnat/s-memory.o   \\"}, {"sha": "448a64066689026a3be78b4bb89bab1ba9975009", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=c11207d345f8d678d440a3ff0f335b2ed25513e7", "patch": "@@ -423,6 +423,12 @@ procedure Gnat1drv is\n          if Warning_Mode = Suppress then\n             Debug_Flag_MM := True;\n          end if;\n+\n+         --  The implementation of 'Value that uses a perfect hash function\n+         --  is significantly more complex and harder to initialize than the\n+         --  old implementation. Deactivate it for CodePeer.\n+\n+         Debug_Flag_Underscore_H := True;\n       end if;\n \n       --  Enable some individual switches that are implied by relaxed RM"}, {"sha": "f347b8cae2d525d96de34db88cbd7a7ec4b555f7", "filename": "gcc/ada/lib.adb", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.adb?ref=c11207d345f8d678d440a3ff0f335b2ed25513e7", "patch": "@@ -1266,10 +1266,16 @@ package body Lib is\n    -- Synchronize_Serial_Number --\n    -------------------------------\n \n-   procedure Synchronize_Serial_Number is\n+   procedure Synchronize_Serial_Number (SN : Nat) is\n       TSN : Int renames Units.Table (Current_Sem_Unit).Serial_Number;\n    begin\n-      TSN := TSN + 1;\n+      --  We should not be trying to synchronize downward\n+\n+      pragma Assert (TSN <= SN);\n+\n+      if TSN < SN then\n+         TSN := SN;\n+      end if;\n    end Synchronize_Serial_Number;\n \n    --------------------"}, {"sha": "1450124c99efa2e4c2d5dba03ef7c59f774e5362", "filename": "gcc/ada/lib.ads", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.ads?ref=c11207d345f8d678d440a3ff0f335b2ed25513e7", "patch": "@@ -741,13 +741,13 @@ package Lib is\n    --  This procedure is called to register a pragma N for which a notes\n    --  entry is required.\n \n-   procedure Synchronize_Serial_Number;\n+   procedure Synchronize_Serial_Number (SN : Nat);\n    --  This function increments the Serial_Number field for the current unit\n-   --  but does not return the incremented value. This is used when there\n-   --  is a situation where one path of control increments a serial number\n-   --  (using Increment_Serial_Number), and the other path does not and it is\n-   --  important to keep the serial numbers synchronized in the two cases (e.g.\n-   --  when the references in a package and a client must be kept consistent).\n+   --  up to SN if it is initially lower and does nothing otherwise. This is\n+   --  used in situations where one path of control increments serial numbers\n+   --  and the other path does not and it is important to keep serial numbers\n+   --  synchronized in the two cases (e.g. when the references in a package\n+   --  and a client must be kept consistent).\n \n    procedure Unlock;\n    --  Unlock internal tables, in cases where the back end needs to modify them"}, {"sha": "6bc026f3db8e16d7b7247700d686e75806293a24", "filename": "gcc/ada/libgnat/g-heasor.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fg-heasor.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fg-heasor.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-heasor.ads?ref=c11207d345f8d678d440a3ff0f335b2ed25513e7", "patch": "@@ -46,6 +46,8 @@\n --  Note: GNAT.Heap_Sort replaces and obsoletes GNAT.Heap_Sort_A, which is\n --  retained in the GNAT library for backwards compatibility.\n \n+pragma Compiler_Unit_Warning;\n+\n package GNAT.Heap_Sort is\n    pragma Pure;\n "}, {"sha": "606656b1fdda6f9ec15f4865d657fc8cf95f8945", "filename": "gcc/ada/libgnat/g-pehage.adb", "status": "modified", "additions": 85, "deletions": 1935, "changes": 2020, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fg-pehage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fg-pehage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-pehage.adb?ref=c11207d345f8d678d440a3ff0f335b2ed25513e7", "patch": "@@ -31,131 +31,31 @@\n \n with Ada.IO_Exceptions;       use Ada.IO_Exceptions;\n with Ada.Characters.Handling; use Ada.Characters.Handling;\n-with Ada.Directories;\n \n-with GNAT.Heap_Sort_G;\n-with GNAT.OS_Lib;      use GNAT.OS_Lib;\n-with GNAT.Table;\n+with GNAT.OS_Lib;             use GNAT.OS_Lib;\n \n package body GNAT.Perfect_Hash_Generators is\n \n-   --  We are using the algorithm of J. Czech as described in Zbigniew J.\n-   --  Czech, George Havas, and Bohdan S. Majewski ``An Optimal Algorithm for\n-   --  Generating Minimal Perfect Hash Functions'', Information Processing\n-   --  Letters, 43(1992) pp.257-264, Oct.1992\n-\n-   --  This minimal perfect hash function generator is based on random graphs\n-   --  and produces a hash function of the form:\n-\n-   --             h (w) = (g (f1 (w)) + g (f2 (w))) mod m\n-\n-   --  where f1 and f2 are functions that map strings into integers, and g is\n-   --  a function that maps integers into [0, m-1]. h can be order preserving.\n-   --  For instance, let W = {w_0, ..., w_i, ..., w_m-1}, h can be defined\n-   --  such that h (w_i) = i.\n-\n-   --  This algorithm defines two possible constructions of f1 and f2. Method\n-   --  b) stores the hash function in less memory space at the expense of\n-   --  greater CPU time.\n-\n-   --  a) fk (w) = sum (for i in 1 .. length (w)) (Tk (i, w (i))) mod n\n-\n-   --     size (Tk) = max (for w in W) (length (w)) * size (used char set)\n-\n-   --  b) fk (w) = sum (for i in 1 .. length (w)) (Tk (i) * w (i)) mod n\n-\n-   --     size (Tk) = max (for w in W) (length (w)) but the table lookups are\n-   --     replaced by multiplications.\n-\n-   --  where Tk values are randomly generated. n is defined later on but the\n-   --  algorithm recommends to use a value a little bit greater than 2m. Note\n-   --  that for large values of m, the main memory space requirements comes\n-   --  from the memory space for storing function g (>= 2m entries).\n-\n-   --  Random graphs are frequently used to solve difficult problems that do\n-   --  not have polynomial solutions. This algorithm is based on a weighted\n-   --  undirected graph. It comprises two steps: mapping and assignment.\n-\n-   --  In the mapping step, a graph G = (V, E) is constructed, where = {0, 1,\n-   --  ..., n-1} and E = {(for w in W) (f1 (w), f2 (w))}. In order for the\n-   --  assignment step to be successful, G has to be acyclic. To have a high\n-   --  probability of generating an acyclic graph, n >= 2m. If it is not\n-   --  acyclic, Tk have to be regenerated.\n-\n-   --  In the assignment step, the algorithm builds function g. As G is\n-   --  acyclic, there is a vertex v1 with only one neighbor v2. Let w_i be\n-   --  the word such that v1 = f1 (w_i) and v2 = f2 (w_i). Let g (v1) = 0 by\n-   --  construction and g (v2) = (i - g (v1)) mod n (or h (i) - g (v1) mod n).\n-   --  If word w_j is such that v2 = f1 (w_j) and v3 = f2 (w_j), g (v3) = (j -\n-   --  g (v2)) mod (or to be general, (h (j) - g (v2)) mod n). If w_i has no\n-   --  neighbor, then another vertex is selected. The algorithm traverses G to\n-   --  assign values to all the vertices. It cannot assign a value to an\n-   --  already assigned vertex as G is acyclic.\n-\n-   subtype Word_Id   is Integer;\n-   subtype Key_Id    is Integer;\n-   subtype Vertex_Id is Integer;\n-   subtype Edge_Id   is Integer;\n-   subtype Table_Id  is Integer;\n-\n-   No_Vertex : constant Vertex_Id := -1;\n-   No_Edge   : constant Edge_Id   := -1;\n-   No_Table  : constant Table_Id  := -1;\n-\n-   type Word_Type is new String_Access;\n-   procedure Free_Word (W : in out Word_Type) renames Free;\n-   function New_Word (S : String) return Word_Type;\n-\n-   procedure Resize_Word (W : in out Word_Type; Len : Natural);\n-   --  Resize string W to have a length Len\n-\n-   type Key_Type is record\n-      Edge : Edge_Id;\n-   end record;\n-   --  A key corresponds to an edge in the algorithm graph\n-\n-   type Vertex_Type is record\n-      First : Edge_Id;\n-      Last  : Edge_Id;\n-   end record;\n-   --  A vertex can be involved in several edges. First and Last are the bounds\n-   --  of an array of edges stored in a global edge table.\n-\n-   type Edge_Type is record\n-      X   : Vertex_Id;\n-      Y   : Vertex_Id;\n-      Key : Key_Id;\n-   end record;\n-   --  An edge is a peer of vertices. In the algorithm, a key is associated to\n-   --  an edge.\n-\n-   package WT is new GNAT.Table (Word_Type, Word_Id, 0, 32, 32);\n-   package IT is new GNAT.Table (Integer, Integer, 0, 32, 32);\n-   --  The two main tables. WT is used to store the words in their initial\n-   --  version and in their reduced version (that is words reduced to their\n-   --  significant characters). As an instance of GNAT.Table, WT does not\n-   --  initialize string pointers to null. This initialization has to be done\n-   --  manually when the table is allocated. IT is used to store several\n-   --  tables of components containing only integers.\n+   use SPHG;\n \n    function Image (Int : Integer; W : Natural := 0) return String;\n    function Image (Str : String;  W : Natural := 0) return String;\n    --  Return a string which includes string Str or integer Int preceded by\n    --  leading spaces if required by width W.\n \n-   function Trim_Trailing_Nuls (Str : String) return String;\n-   --  Return Str with trailing NUL characters removed\n-\n-   Output : File_Descriptor renames GNAT.OS_Lib.Standout;\n-   --  Shortcuts\n-\n    EOL : constant Character := ASCII.LF;\n \n    Max  : constant := 78;\n    Last : Natural  := 0;\n    Line : String (1 .. Max);\n    --  Use this line to provide buffered IO\n \n+   NK : Natural  := 0;\n+   --  NK : Number of Keys\n+\n+   Opt : Optimization;\n+   --  Optimization mode (memory vs CPU)\n+\n    procedure Add (C : Character);\n    procedure Add (S : String);\n    --  Add a character or a string in Line and update Last\n@@ -185,324 +85,21 @@ package body GNAT.Perfect_Hash_Generators is\n    procedure Put (File : File_Descriptor; Str : String);\n    --  Simulate Ada.Text_IO.Put with GNAT.OS_Lib\n \n-   procedure Put_Used_Char_Set (File : File_Descriptor; Title : String);\n-   --  Output a title and a used character set\n-\n-   procedure Put_Int_Vector\n-     (File   : File_Descriptor;\n-      Title  : String;\n-      Vector : Integer;\n-      Length : Natural);\n-   --  Output a title and a vector\n-\n    procedure Put_Int_Matrix\n      (File  : File_Descriptor;\n       Title : String;\n-      Table : Table_Id;\n+      Table : Table_Name;\n       Len_1 : Natural;\n       Len_2 : Natural);\n    --  Output a title and a matrix. When the matrix has only one non-empty\n    --  dimension (Len_2 = 0), output a vector.\n \n-   procedure Put_Edges (File : File_Descriptor; Title : String);\n-   --  Output a title and an edge table\n-\n-   procedure Put_Initial_Keys (File : File_Descriptor; Title : String);\n-   --  Output a title and a key table\n-\n-   procedure Put_Reduced_Keys (File : File_Descriptor; Title : String);\n-   --  Output a title and a key table\n-\n-   procedure Put_Vertex_Table (File : File_Descriptor; Title : String);\n-   --  Output a title and a vertex table\n-\n    function Ada_File_Base_Name (Pkg_Name : String) return String;\n    --  Return the base file name (i.e. without .ads/.adb extension) for an\n    --  Ada source file containing the named package, using the standard GNAT\n    --  file-naming convention. For example, if Pkg_Name is \"Parent.Child\", we\n    --  return \"parent-child\".\n \n-   ----------------------------------\n-   -- Character Position Selection --\n-   ----------------------------------\n-\n-   --  We reduce the maximum key size by selecting representative positions\n-   --  in these keys. We build a matrix with one word per line. We fill the\n-   --  remaining space of a line with ASCII.NUL. The heuristic selects the\n-   --  position that induces the minimum number of collisions. If there are\n-   --  collisions, select another position on the reduced key set responsible\n-   --  of the collisions. Apply the heuristic until there is no more collision.\n-\n-   procedure Apply_Position_Selection;\n-   --  Apply Position selection and build the reduced key table\n-\n-   procedure Parse_Position_Selection (Argument : String);\n-   --  Parse Argument and compute the position set. Argument is list of\n-   --  substrings separated by commas. Each substring represents a position\n-   --  or a range of positions (like x-y).\n-\n-   procedure Select_Character_Set;\n-   --  Define an optimized used character set like Character'Pos in order not\n-   --  to allocate tables of 256 entries.\n-\n-   procedure Select_Char_Position;\n-   --  Find a min char position set in order to reduce the max key length. The\n-   --  heuristic selects the position that induces the minimum number of\n-   --  collisions. If there are collisions, select another position on the\n-   --  reduced key set responsible of the collisions. Apply the heuristic until\n-   --  there is no collision.\n-\n-   -----------------------------\n-   -- Random Graph Generation --\n-   -----------------------------\n-\n-   procedure Random (Seed : in out Natural);\n-   --  Simulate Ada.Discrete_Numerics.Random\n-\n-   procedure Generate_Mapping_Table\n-     (Tab  : Table_Id;\n-      L1   : Natural;\n-      L2   : Natural;\n-      Seed : in out Natural);\n-   --  Random generation of the tables below. T is already allocated\n-\n-   procedure Generate_Mapping_Tables\n-     (Opt  : Optimization;\n-      Seed : in out Natural);\n-   --  Generate the mapping tables T1 and T2. They are used to define fk (w) =\n-   --  sum (for i in 1 .. length (w)) (Tk (i, w (i))) mod n. Keys, NK and Chars\n-   --  are used to compute the matrix size.\n-\n-   ---------------------------\n-   -- Algorithm Computation --\n-   ---------------------------\n-\n-   procedure Compute_Edges_And_Vertices (Opt : Optimization);\n-   --  Compute the edge and vertex tables. These are empty when a self loop is\n-   --  detected (f1 (w) = f2 (w)). The edge table is sorted by X value and then\n-   --  Y value. Keys is the key table and NK the number of keys. Chars is the\n-   --  set of characters really used in Keys. NV is the number of vertices\n-   --  recommended by the algorithm. T1 and T2 are the mapping tables needed to\n-   --  compute f1 (w) and f2 (w).\n-\n-   function Acyclic return Boolean;\n-   --  Return True when the graph is acyclic. Vertices is the current vertex\n-   --  table and Edges the current edge table.\n-\n-   procedure Assign_Values_To_Vertices;\n-   --  Execute the assignment step of the algorithm. Keys is the current key\n-   --  table. Vertices and Edges represent the random graph. G is the result of\n-   --  the assignment step such that:\n-   --    h (w) = (g (f1 (w)) + g (f2 (w))) mod m\n-\n-   function Sum\n-     (Word  : Word_Type;\n-      Table : Table_Id;\n-      Opt   : Optimization) return Natural;\n-   --  For an optimization of CPU_Time return\n-   --    fk (w) = sum (for i in 1 .. length (w)) (Tk (i, w (i))) mod n\n-   --  For an optimization of Memory_Space return\n-   --    fk (w) = sum (for i in 1 .. length (w)) (Tk (i) * w (i)) mod n\n-   --  Here NV = n\n-\n-   -------------------------------\n-   -- Internal Table Management --\n-   -------------------------------\n-\n-   function Allocate (N : Natural; S : Natural := 1) return Table_Id;\n-   --  Allocate N * S ints from IT table\n-\n-   ----------\n-   -- Keys --\n-   ----------\n-\n-   Keys : Table_Id := No_Table;\n-   NK   : Natural  := 0;\n-   --  NK : Number of Keys\n-\n-   function Initial (K : Key_Id) return Word_Id;\n-   pragma Inline (Initial);\n-\n-   function Reduced (K : Key_Id) return Word_Id;\n-   pragma Inline (Reduced);\n-\n-   function  Get_Key (N : Key_Id) return Key_Type;\n-   procedure Set_Key (N : Key_Id; Item : Key_Type);\n-   --  Get or Set Nth element of Keys table\n-\n-   ------------------\n-   -- Char_Pos_Set --\n-   ------------------\n-\n-   Char_Pos_Set     : Table_Id := No_Table;\n-   Char_Pos_Set_Len : Natural;\n-   --  Character Selected Position Set\n-\n-   function  Get_Char_Pos (P : Natural) return Natural;\n-   procedure Set_Char_Pos (P : Natural; Item : Natural);\n-   --  Get or Set the string position of the Pth selected character\n-\n-   -------------------\n-   -- Used_Char_Set --\n-   -------------------\n-\n-   Used_Char_Set     : Table_Id := No_Table;\n-   Used_Char_Set_Len : Natural;\n-   --  Used Character Set : Define a new character mapping. When all the\n-   --  characters are not present in the keys, in order to reduce the size\n-   --  of some tables, we redefine the character mapping.\n-\n-   function  Get_Used_Char (C : Character) return Natural;\n-   procedure Set_Used_Char (C : Character; Item : Natural);\n-\n-   ------------\n-   -- Tables --\n-   ------------\n-\n-   T1     : Table_Id := No_Table;\n-   T2     : Table_Id := No_Table;\n-   T1_Len : Natural;\n-   T2_Len : Natural;\n-   --  T1  : Values table to compute F1\n-   --  T2  : Values table to compute F2\n-\n-   function  Get_Table (T : Integer; X, Y : Natural) return Natural;\n-   procedure Set_Table (T : Integer; X, Y : Natural; Item : Natural);\n-\n-   -----------\n-   -- Graph --\n-   -----------\n-\n-   G     : Table_Id := No_Table;\n-   G_Len : Natural;\n-   --  Values table to compute G\n-\n-   NT : Natural := Default_Tries;\n-   --  Number of tries running the algorithm before raising an error\n-\n-   function  Get_Graph (N : Natural) return Integer;\n-   procedure Set_Graph (N : Natural; Item : Integer);\n-   --  Get or Set Nth element of graph\n-\n-   -----------\n-   -- Edges --\n-   -----------\n-\n-   Edge_Size : constant := 3;\n-   Edges     : Table_Id := No_Table;\n-   Edges_Len : Natural;\n-   --  Edges  : Edge table of the random graph G\n-\n-   function  Get_Edges (F : Natural) return Edge_Type;\n-   procedure Set_Edges (F : Natural; Item : Edge_Type);\n-\n-   --------------\n-   -- Vertices --\n-   --------------\n-\n-   Vertex_Size : constant := 2;\n-\n-   Vertices : Table_Id := No_Table;\n-   --  Vertex table of the random graph G\n-\n-   NV : Natural;\n-   --  Number of Vertices\n-\n-   function  Get_Vertices (F : Natural) return Vertex_Type;\n-   procedure Set_Vertices (F : Natural; Item : Vertex_Type);\n-   --  Comments needed ???\n-\n-   K2V : Float;\n-   --  Ratio between Keys and Vertices (parameter of Czech's algorithm)\n-\n-   Opt : Optimization;\n-   --  Optimization mode (memory vs CPU)\n-\n-   Max_Key_Len : Natural := 0;\n-   Min_Key_Len : Natural := 0;\n-   --  Maximum and minimum of all the word length\n-\n-   S : Natural;\n-   --  Seed\n-\n-   function Type_Size (L : Natural) return Natural;\n-   --  Given the last L of an unsigned integer type T, return its size\n-\n-   -------------\n-   -- Acyclic --\n-   -------------\n-\n-   function Acyclic return Boolean is\n-      Marks : array (0 .. NV - 1) of Vertex_Id := (others => No_Vertex);\n-\n-      function Traverse (Edge : Edge_Id; Mark : Vertex_Id) return Boolean;\n-      --  Propagate Mark from X to Y. X is already marked. Mark Y and propagate\n-      --  it to the edges of Y except the one representing the same key. Return\n-      --  False when Y is marked with Mark.\n-\n-      --------------\n-      -- Traverse --\n-      --------------\n-\n-      function Traverse (Edge : Edge_Id; Mark : Vertex_Id) return Boolean is\n-         E : constant Edge_Type := Get_Edges (Edge);\n-         K : constant Key_Id    := E.Key;\n-         Y : constant Vertex_Id := E.Y;\n-         M : constant Vertex_Id := Marks (E.Y);\n-         V : Vertex_Type;\n-\n-      begin\n-         if M = Mark then\n-            return False;\n-\n-         elsif M = No_Vertex then\n-            Marks (Y) := Mark;\n-            V := Get_Vertices (Y);\n-\n-            for J in V.First .. V.Last loop\n-\n-               --  Do not propagate to the edge representing the same key\n-\n-               if Get_Edges (J).Key /= K\n-                 and then not Traverse (J, Mark)\n-               then\n-                  return False;\n-               end if;\n-            end loop;\n-         end if;\n-\n-         return True;\n-      end Traverse;\n-\n-      Edge  : Edge_Type;\n-\n-   --  Start of processing for Acyclic\n-\n-   begin\n-      --  Edges valid range is\n-\n-      for J in 1 .. Edges_Len - 1 loop\n-\n-         Edge := Get_Edges (J);\n-\n-         --  Mark X of E when it has not been already done\n-\n-         if Marks (Edge.X) = No_Vertex then\n-            Marks (Edge.X) := Edge.X;\n-         end if;\n-\n-         --  Traverse E when this has not already been done\n-\n-         if Marks (Edge.Y) = No_Vertex\n-           and then not Traverse (J, Edge.X)\n-         then\n-            return False;\n-         end if;\n-      end loop;\n-\n-      return True;\n-   end Acyclic;\n-\n    ------------------------\n    -- Ada_File_Base_Name --\n    ------------------------\n@@ -547,559 +144,25 @@ package body GNAT.Perfect_Hash_Generators is\n       Last := Last + Len;\n    end Add;\n \n-   --------------\n-   -- Allocate --\n-   --------------\n-\n-   function Allocate (N : Natural; S : Natural := 1) return Table_Id is\n-      L : constant Integer := IT.Last;\n-   begin\n-      IT.Set_Last (L + N * S);\n-\n-      --  Initialize, so debugging printouts don't trip over uninitialized\n-      --  components.\n-\n-      for J in L + 1 .. IT.Last loop\n-         IT.Table (J) := -1;\n-      end loop;\n-\n-      return L + 1;\n-   end Allocate;\n-\n-   ------------------------------\n-   -- Apply_Position_Selection --\n-   ------------------------------\n-\n-   procedure Apply_Position_Selection is\n-   begin\n-      for J in 0 .. NK - 1 loop\n-         declare\n-            IW : constant String := WT.Table (Initial (J)).all;\n-            RW : String (1 .. IW'Length) := (others => ASCII.NUL);\n-            N  : Natural := IW'First - 1;\n-\n-         begin\n-            --  Select the characters of Word included in the position\n-            --  selection.\n-\n-            for C in 0 .. Char_Pos_Set_Len - 1 loop\n-               exit when IW (Get_Char_Pos (C)) = ASCII.NUL;\n-               N := N + 1;\n-               RW (N) := IW (Get_Char_Pos (C));\n-            end loop;\n-\n-            --  Build the new table with the reduced word. Be careful\n-            --  to deallocate the old version to avoid memory leaks.\n-\n-            Free_Word (WT.Table (Reduced (J)));\n-            WT.Table (Reduced (J)) := New_Word (RW);\n-            Set_Key (J, (Edge => No_Edge));\n-         end;\n-      end loop;\n-   end Apply_Position_Selection;\n-\n-   -------------------------------\n-   -- Assign_Values_To_Vertices --\n-   -------------------------------\n-\n-   procedure Assign_Values_To_Vertices is\n-      X : Vertex_Id;\n-\n-      procedure Assign (X : Vertex_Id);\n-      --  Execute assignment on X's neighbors except the vertex that we are\n-      --  coming from which is already assigned.\n-\n-      ------------\n-      -- Assign --\n-      ------------\n-\n-      procedure Assign (X : Vertex_Id) is\n-         E : Edge_Type;\n-         V : constant Vertex_Type := Get_Vertices (X);\n-\n-      begin\n-         for J in V.First .. V.Last loop\n-            E := Get_Edges (J);\n-\n-            if Get_Graph (E.Y) = -1 then\n-               pragma Assert (NK /= 0);\n-               Set_Graph (E.Y, (E.Key - Get_Graph (X)) mod NK);\n-               Assign (E.Y);\n-            end if;\n-         end loop;\n-      end Assign;\n-\n-   --  Start of processing for Assign_Values_To_Vertices\n-\n-   begin\n-      --  Value -1 denotes an uninitialized value as it is supposed to\n-      --  be in the range 0 .. NK.\n-\n-      if G = No_Table then\n-         G_Len := NV;\n-         G := Allocate (G_Len, 1);\n-      end if;\n-\n-      for J in 0 .. G_Len - 1 loop\n-         Set_Graph (J, -1);\n-      end loop;\n-\n-      for K in 0 .. NK - 1 loop\n-         X := Get_Edges (Get_Key (K).Edge).X;\n-\n-         if Get_Graph (X) = -1 then\n-            Set_Graph (X, 0);\n-            Assign (X);\n-         end if;\n-      end loop;\n-\n-      for J in 0 .. G_Len - 1 loop\n-         if Get_Graph (J) = -1 then\n-            Set_Graph (J, 0);\n-         end if;\n-      end loop;\n-\n-      if Verbose then\n-         Put_Int_Vector (Output, \"Assign Values To Vertices\", G, G_Len);\n-      end if;\n-   end Assign_Values_To_Vertices;\n-\n    -------------\n    -- Compute --\n    -------------\n \n    procedure Compute (Position : String := Default_Position) is\n-      Success : Boolean := False;\n-\n    begin\n-      if NK = 0 then\n-         raise Program_Error with \"keywords set cannot be empty\";\n-      end if;\n-\n-      if Verbose then\n-         Put_Initial_Keys (Output, \"Initial Key Table\");\n-      end if;\n-\n-      if Position'Length /= 0 then\n-         Parse_Position_Selection (Position);\n-      else\n-         Select_Char_Position;\n-      end if;\n-\n-      if Verbose then\n-         Put_Int_Vector\n-           (Output, \"Char Position Set\", Char_Pos_Set, Char_Pos_Set_Len);\n-      end if;\n-\n-      Apply_Position_Selection;\n-\n-      if Verbose then\n-         Put_Reduced_Keys (Output, \"Reduced Keys Table\");\n-      end if;\n-\n-      Select_Character_Set;\n-\n-      if Verbose then\n-         Put_Used_Char_Set (Output, \"Character Position Table\");\n-      end if;\n-\n-      --  Perform Czech's algorithm\n-\n-      for J in 1 .. NT loop\n-         Generate_Mapping_Tables (Opt, S);\n-         Compute_Edges_And_Vertices (Opt);\n-\n-         --  When graph is not empty (no self-loop from previous operation) and\n-         --  not acyclic.\n-\n-         if 0 < Edges_Len and then Acyclic then\n-            Success := True;\n-            exit;\n-         end if;\n-      end loop;\n-\n-      if not Success then\n-         raise Too_Many_Tries;\n-      end if;\n-\n-      Assign_Values_To_Vertices;\n+      SPHG.Compute (Position);\n    end Compute;\n \n-   --------------------------------\n-   -- Compute_Edges_And_Vertices --\n-   --------------------------------\n-\n-   procedure Compute_Edges_And_Vertices (Opt : Optimization) is\n-      X           : Natural;\n-      Y           : Natural;\n-      Key         : Key_Type;\n-      Edge        : Edge_Type;\n-      Vertex      : Vertex_Type;\n-      Not_Acyclic : Boolean := False;\n-\n-      procedure Move (From : Natural; To : Natural);\n-      function Lt (L, R : Natural) return Boolean;\n-      --  Subprograms needed for GNAT.Heap_Sort_G\n-\n-      --------\n-      -- Lt --\n-      --------\n-\n-      function Lt (L, R : Natural) return Boolean is\n-         EL : constant Edge_Type := Get_Edges (L);\n-         ER : constant Edge_Type := Get_Edges (R);\n-      begin\n-         return EL.X < ER.X or else (EL.X = ER.X and then EL.Y < ER.Y);\n-      end Lt;\n-\n-      ----------\n-      -- Move --\n-      ----------\n-\n-      procedure Move (From : Natural; To : Natural) is\n-      begin\n-         Set_Edges (To, Get_Edges (From));\n-      end Move;\n-\n-      package Sorting is new GNAT.Heap_Sort_G (Move, Lt);\n-\n-   --  Start of processing for Compute_Edges_And_Vertices\n-\n-   begin\n-      --  We store edges from 1 to 2 * NK and leave zero alone in order to use\n-      --  GNAT.Heap_Sort_G.\n-\n-      Edges_Len := 2 * NK + 1;\n-\n-      if Edges = No_Table then\n-         Edges := Allocate (Edges_Len, Edge_Size);\n-      end if;\n-\n-      if Vertices = No_Table then\n-         Vertices := Allocate (NV, Vertex_Size);\n-      end if;\n-\n-      for J in 0 .. NV - 1 loop\n-         Set_Vertices (J, (No_Vertex, No_Vertex - 1));\n-      end loop;\n-\n-      --  For each w, X = f1 (w) and Y = f2 (w)\n-\n-      for J in 0 .. NK - 1 loop\n-         Key := Get_Key (J);\n-         Key.Edge := No_Edge;\n-         Set_Key (J, Key);\n-\n-         X := Sum (WT.Table (Reduced (J)), T1, Opt);\n-         Y := Sum (WT.Table (Reduced (J)), T2, Opt);\n-\n-         --  Discard T1 and T2 as soon as we discover a self loop\n-\n-         if X = Y then\n-            Not_Acyclic := True;\n-            exit;\n-         end if;\n-\n-         --  We store (X, Y) and (Y, X) to ease assignment step\n-\n-         Set_Edges (2 * J + 1, (X, Y, J));\n-         Set_Edges (2 * J + 2, (Y, X, J));\n-      end loop;\n-\n-      --  Return an empty graph when self loop detected\n-\n-      if Not_Acyclic then\n-         Edges_Len := 0;\n-\n-      else\n-         if Verbose then\n-            Put_Edges      (Output, \"Unsorted Edge Table\");\n-            Put_Int_Matrix (Output, \"Function Table 1\", T1,\n-                            T1_Len, T2_Len);\n-            Put_Int_Matrix (Output, \"Function Table 2\", T2,\n-                            T1_Len, T2_Len);\n-         end if;\n-\n-         --  Enforce consistency between edges and keys. Construct Vertices and\n-         --  compute the list of neighbors of a vertex First .. Last as Edges\n-         --  is sorted by X and then Y. To compute the neighbor list, sort the\n-         --  edges.\n-\n-         Sorting.Sort (Edges_Len - 1);\n-\n-         if Verbose then\n-            Put_Edges      (Output, \"Sorted Edge Table\");\n-            Put_Int_Matrix (Output, \"Function Table 1\", T1,\n-                            T1_Len, T2_Len);\n-            Put_Int_Matrix (Output, \"Function Table 2\", T2,\n-                            T1_Len, T2_Len);\n-         end if;\n-\n-         --  Edges valid range is 1 .. 2 * NK\n-\n-         for E in 1 .. Edges_Len - 1 loop\n-            Edge := Get_Edges (E);\n-            Key  := Get_Key (Edge.Key);\n-\n-            if Key.Edge = No_Edge then\n-               Key.Edge := E;\n-               Set_Key (Edge.Key, Key);\n-            end if;\n-\n-            Vertex := Get_Vertices (Edge.X);\n-\n-            if Vertex.First = No_Edge then\n-               Vertex.First := E;\n-            end if;\n-\n-            Vertex.Last := E;\n-            Set_Vertices (Edge.X, Vertex);\n-         end loop;\n-\n-         if Verbose then\n-            Put_Reduced_Keys (Output, \"Key Table\");\n-            Put_Edges        (Output, \"Edge Table\");\n-            Put_Vertex_Table (Output, \"Vertex Table\");\n-         end if;\n-      end if;\n-   end Compute_Edges_And_Vertices;\n-\n-   ------------\n-   -- Define --\n-   ------------\n-\n-   procedure Define\n-     (Name      : Table_Name;\n-      Item_Size : out Natural;\n-      Length_1  : out Natural;\n-      Length_2  : out Natural)\n-   is\n-   begin\n-      case Name is\n-         when Character_Position =>\n-            Item_Size := 8;\n-            Length_1  := Char_Pos_Set_Len;\n-            Length_2  := 0;\n-\n-         when Used_Character_Set =>\n-            Item_Size := 8;\n-            Length_1  := 256;\n-            Length_2  := 0;\n-\n-         when Function_Table_1\n-            | Function_Table_2\n-         =>\n-            Item_Size := Type_Size (NV);\n-            Length_1  := T1_Len;\n-            Length_2  := T2_Len;\n-\n-         when Graph_Table =>\n-            Item_Size := Type_Size (NK);\n-            Length_1  := NV;\n-            Length_2  := 0;\n-      end case;\n-   end Define;\n-\n    --------------\n    -- Finalize --\n    --------------\n \n    procedure Finalize is\n    begin\n-      if Verbose then\n-         Put (Output, \"Finalize\");\n-         New_Line (Output);\n-      end if;\n-\n-      --  Deallocate all the WT components (both initial and reduced ones) to\n-      --  avoid memory leaks.\n-\n-      for W in 0 .. WT.Last loop\n-\n-         --  Note: WT.Table (NK) is a temporary variable, do not free it since\n-         --  this would cause a double free.\n-\n-         if W /= NK then\n-            Free_Word (WT.Table (W));\n-         end if;\n-      end loop;\n-\n-      WT.Release;\n-      IT.Release;\n-\n-      --  Reset all variables for next usage\n-\n-      Keys := No_Table;\n-\n-      Char_Pos_Set     := No_Table;\n-      Char_Pos_Set_Len := 0;\n-\n-      Used_Char_Set     := No_Table;\n-      Used_Char_Set_Len := 0;\n-\n-      T1 := No_Table;\n-      T2 := No_Table;\n-\n-      T1_Len := 0;\n-      T2_Len := 0;\n-\n-      G     := No_Table;\n-      G_Len := 0;\n-\n-      Edges     := No_Table;\n-      Edges_Len := 0;\n-\n-      Vertices := No_Table;\n-      NV       := 0;\n-\n       NK := 0;\n-      Max_Key_Len := 0;\n-      Min_Key_Len := 0;\n+      SPHG.Finalize;\n    end Finalize;\n \n-   ----------------------------\n-   -- Generate_Mapping_Table --\n-   ----------------------------\n-\n-   procedure Generate_Mapping_Table\n-     (Tab  : Integer;\n-      L1   : Natural;\n-      L2   : Natural;\n-      Seed : in out Natural)\n-   is\n-   begin\n-      for J in 0 .. L1 - 1 loop\n-         for K in 0 .. L2 - 1 loop\n-            Random (Seed);\n-            Set_Table (Tab, J, K, Seed mod NV);\n-         end loop;\n-      end loop;\n-   end Generate_Mapping_Table;\n-\n-   -----------------------------\n-   -- Generate_Mapping_Tables --\n-   -----------------------------\n-\n-   procedure Generate_Mapping_Tables\n-     (Opt  : Optimization;\n-      Seed : in out Natural)\n-   is\n-   begin\n-      --  If T1 and T2 are already allocated no need to do it twice. Reuse them\n-      --  as their size has not changed.\n-\n-      if T1 = No_Table and then T2 = No_Table then\n-         declare\n-            Used_Char_Last : Natural := 0;\n-            Used_Char      : Natural;\n-\n-         begin\n-            if Opt = CPU_Time then\n-               for P in reverse Character'Range loop\n-                  Used_Char := Get_Used_Char (P);\n-                  if Used_Char /= 0 then\n-                     Used_Char_Last := Used_Char;\n-                     exit;\n-                  end if;\n-               end loop;\n-            end if;\n-\n-            T1_Len := Char_Pos_Set_Len;\n-            T2_Len := Used_Char_Last + 1;\n-            T1 := Allocate (T1_Len * T2_Len);\n-            T2 := Allocate (T1_Len * T2_Len);\n-         end;\n-      end if;\n-\n-      Generate_Mapping_Table (T1, T1_Len, T2_Len, Seed);\n-      Generate_Mapping_Table (T2, T1_Len, T2_Len, Seed);\n-\n-      if Verbose then\n-         Put_Used_Char_Set (Output, \"Used Character Set\");\n-         Put_Int_Matrix (Output, \"Function Table 1\", T1,\n-                        T1_Len, T2_Len);\n-         Put_Int_Matrix (Output, \"Function Table 2\", T2,\n-                        T1_Len, T2_Len);\n-      end if;\n-   end Generate_Mapping_Tables;\n-\n-   ------------------\n-   -- Get_Char_Pos --\n-   ------------------\n-\n-   function Get_Char_Pos (P : Natural) return Natural is\n-      N : constant Natural := Char_Pos_Set + P;\n-   begin\n-      return IT.Table (N);\n-   end Get_Char_Pos;\n-\n-   ---------------\n-   -- Get_Edges --\n-   ---------------\n-\n-   function Get_Edges (F : Natural) return Edge_Type is\n-      N : constant Natural := Edges + (F * Edge_Size);\n-      E : Edge_Type;\n-   begin\n-      E.X   := IT.Table (N);\n-      E.Y   := IT.Table (N + 1);\n-      E.Key := IT.Table (N + 2);\n-      return E;\n-   end Get_Edges;\n-\n-   ---------------\n-   -- Get_Graph --\n-   ---------------\n-\n-   function Get_Graph (N : Natural) return Integer is\n-   begin\n-      return IT.Table (G + N);\n-   end Get_Graph;\n-\n-   -------------\n-   -- Get_Key --\n-   -------------\n-\n-   function Get_Key (N : Key_Id) return Key_Type is\n-      K : Key_Type;\n-   begin\n-      K.Edge := IT.Table (Keys + N);\n-      return K;\n-   end Get_Key;\n-\n-   ---------------\n-   -- Get_Table --\n-   ---------------\n-\n-   function Get_Table (T : Integer; X, Y : Natural) return Natural is\n-      N : constant Natural := T + (Y * T1_Len) + X;\n-   begin\n-      return IT.Table (N);\n-   end Get_Table;\n-\n-   -------------------\n-   -- Get_Used_Char --\n-   -------------------\n-\n-   function Get_Used_Char (C : Character) return Natural is\n-      N : constant Natural := Used_Char_Set + Character'Pos (C);\n-   begin\n-      return IT.Table (N);\n-   end Get_Used_Char;\n-\n-   ------------------\n-   -- Get_Vertices --\n-   ------------------\n-\n-   function Get_Vertices (F : Natural) return Vertex_Type is\n-      N : constant Natural := Vertices + (F * Vertex_Size);\n-      V : Vertex_Type;\n-   begin\n-      V.First := IT.Table (N);\n-      V.Last  := IT.Table (N + 1);\n-      return V;\n-   end Get_Vertices;\n-\n    -----------\n    -- Image --\n    -----------\n@@ -1164,15 +227,6 @@ package body GNAT.Perfect_Hash_Generators is\n       end;\n    end Image;\n \n-   -------------\n-   -- Initial --\n-   -------------\n-\n-   function Initial (K : Key_Id) return Word_Id is\n-   begin\n-      return K;\n-   end Initial;\n-\n    ----------------\n    -- Initialize --\n    ----------------\n@@ -1183,250 +237,33 @@ package body GNAT.Perfect_Hash_Generators is\n       Optim  : Optimization := Memory_Space;\n       Tries  : Positive     := Default_Tries)\n    is\n-   begin\n-      if Verbose then\n-         Put (Output, \"Initialize\");\n-         New_Line (Output);\n-      end if;\n-\n-      --  Deallocate the part of the table concerning the reduced words.\n-      --  Initial words are already present in the table. We may have reduced\n-      --  words already there because a previous computation failed. We are\n-      --  currently retrying and the reduced words have to be deallocated.\n-\n-      for W in Reduced (0) .. WT.Last loop\n-         Free_Word (WT.Table (W));\n-      end loop;\n-\n-      IT.Init;\n-\n-      --  Initialize of computation variables\n-\n-      Keys := No_Table;\n+      V : constant Positive := Positive (Float (NK) * K_To_V);\n \n-      Char_Pos_Set     := No_Table;\n-      Char_Pos_Set_Len := 0;\n-\n-      Used_Char_Set     := No_Table;\n-      Used_Char_Set_Len := 0;\n-\n-      T1 := No_Table;\n-      T2 := No_Table;\n-\n-      T1_Len := 0;\n-      T2_Len := 0;\n-\n-      G     := No_Table;\n-      G_Len := 0;\n-\n-      Edges     := No_Table;\n-      Edges_Len := 0;\n-\n-      Vertices := No_Table;\n-      NV       := 0;\n-\n-      S    := Seed;\n-      K2V  := K_To_V;\n-      Opt  := Optim;\n-      NT   := Tries;\n-\n-      if K2V <= 2.0 then\n-         raise Program_Error with \"K to V ratio cannot be lower than 2.0\";\n-      end if;\n-\n-      --  Do not accept a value of K2V too close to 2.0 such that once\n-      --  rounded up, NV = 2 * NK because the algorithm would not converge.\n-\n-      NV := Natural (Float (NK) * K2V);\n-      if NV <= 2 * NK then\n-         NV := 2 * NK + 1;\n-      end if;\n-\n-      Keys := Allocate (NK);\n-\n-      --  Resize initial words to have all of them at the same size\n-      --  (so the size of the largest one).\n-\n-      for K in 0 .. NK - 1 loop\n-         Resize_Word (WT.Table (Initial (K)), Max_Key_Len);\n-      end loop;\n-\n-      --  Allocated the table to store the reduced words. As WT is a\n-      --  GNAT.Table (using C memory management), pointers have to be\n-      --  explicitly initialized to null.\n-\n-      WT.Set_Last (Reduced (NK - 1));\n-\n-      --  Note: Reduced (0) = NK + 1\n-\n-      WT.Table (NK) := null;\n-\n-      for W in 0 .. NK - 1 loop\n-         WT.Table (Reduced (W)) := null;\n-      end loop;\n+   begin\n+      Opt := Optim;\n+      SPHG.Initialize (Seed, V, SPHG.Optimization (Optim), Tries);\n    end Initialize;\n \n    ------------\n    -- Insert --\n    ------------\n \n    procedure Insert (Value : String) is\n-      Len  : constant Natural := Value'Length;\n-\n-   begin\n-      if Verbose then\n-         Put (Output, \"Inserting \"\"\" & Value & \"\"\"\");\n-         New_Line (Output);\n-      end if;\n-\n-      for J in Value'Range loop\n-         pragma Assert (Value (J) /= ASCII.NUL);\n-         null;\n-      end loop;\n-\n-      WT.Set_Last (NK);\n-      WT.Table (NK) := New_Word (Value);\n-      NK := NK + 1;\n-\n-      if Max_Key_Len < Len then\n-         Max_Key_Len := Len;\n-      end if;\n-\n-      if Min_Key_Len = 0 or else Len < Min_Key_Len then\n-         Min_Key_Len := Len;\n-      end if;\n-   end Insert;\n-\n-   --------------\n-   -- New_Line --\n-   --------------\n-\n-   procedure New_Line (File : File_Descriptor) is\n-   begin\n-      if Write (File, EOL'Address, 1) /= 1 then\n-         raise Program_Error;\n-      end if;\n-   end New_Line;\n-\n-   --------------\n-   -- New_Word --\n-   --------------\n-\n-   function New_Word (S : String) return Word_Type is\n-   begin\n-      return new String'(S);\n-   end New_Word;\n-\n-   ------------------------------\n-   -- Parse_Position_Selection --\n-   ------------------------------\n-\n-   procedure Parse_Position_Selection (Argument : String) is\n-      N : Natural          := Argument'First;\n-      L : constant Natural := Argument'Last;\n-      M : constant Natural := Max_Key_Len;\n-\n-      T : array (1 .. M) of Boolean := (others => False);\n-\n-      function Parse_Index return Natural;\n-      --  Parse argument starting at index N to find an index\n-\n-      -----------------\n-      -- Parse_Index --\n-      -----------------\n-\n-      function Parse_Index return Natural is\n-         C : Character := Argument (N);\n-         V : Natural   := 0;\n-\n-      begin\n-         if C = '$' then\n-            N := N + 1;\n-            return M;\n-         end if;\n-\n-         if C not in '0' .. '9' then\n-            raise Program_Error with \"cannot read position argument\";\n-         end if;\n-\n-         while C in '0' .. '9' loop\n-            V := V * 10 + (Character'Pos (C) - Character'Pos ('0'));\n-            N := N + 1;\n-            exit when L < N;\n-            C := Argument (N);\n-         end loop;\n-\n-         return V;\n-      end Parse_Index;\n-\n-   --  Start of processing for Parse_Position_Selection\n-\n-   begin\n-      --  Empty specification means all the positions\n-\n-      if L < N then\n-         Char_Pos_Set_Len := M;\n-         Char_Pos_Set := Allocate (Char_Pos_Set_Len);\n-\n-         for C in 0 .. Char_Pos_Set_Len - 1 loop\n-            Set_Char_Pos (C, C + 1);\n-         end loop;\n-\n-      else\n-         loop\n-            declare\n-               First, Last : Natural;\n-\n-            begin\n-               First := Parse_Index;\n-               Last  := First;\n-\n-               --  Detect a range\n-\n-               if N <= L and then Argument (N) = '-' then\n-                  N := N + 1;\n-                  Last := Parse_Index;\n-               end if;\n-\n-               --  Include the positions in the selection\n-\n-               for J in First .. Last loop\n-                  T (J) := True;\n-               end loop;\n-            end;\n-\n-            exit when L < N;\n-\n-            if Argument (N) /= ',' then\n-               raise Program_Error with \"cannot read position argument\";\n-            end if;\n-\n-            N := N + 1;\n-         end loop;\n-\n-         --  Compute position selection length\n-\n-         N := 0;\n-         for J in T'Range loop\n-            if T (J) then\n-               N := N + 1;\n-            end if;\n-         end loop;\n-\n-         --  Fill position selection\n+   begin\n+      NK := NK + 1;\n+      SPHG.Insert (Value);\n+   end Insert;\n \n-         Char_Pos_Set_Len := N;\n-         Char_Pos_Set := Allocate (Char_Pos_Set_Len);\n+   --------------\n+   -- New_Line --\n+   --------------\n \n-         N := 0;\n-         for J in T'Range loop\n-            if T (J) then\n-               Set_Char_Pos (N, J);\n-               N := N + 1;\n-            end if;\n-         end loop;\n+   procedure New_Line (File : File_Descriptor) is\n+   begin\n+      if Write (File, EOL'Address, 1) /= 1 then\n+         raise Program_Error;\n       end if;\n-   end Parse_Position_Selection;\n+   end New_Line;\n \n    -------------\n    -- Produce --\n@@ -1438,6 +275,9 @@ package body GNAT.Perfect_Hash_Generators is\n    is\n       File : File_Descriptor := Standout;\n \n+      Siz, L1, L2 : Natural;\n+      --  For calls to Define\n+\n       Status : Boolean;\n       --  For call to Close\n \n@@ -1447,8 +287,8 @@ package body GNAT.Perfect_Hash_Generators is\n       function Range_Img (F, L : Natural; T : String := \"\") return String;\n       --  Return string \"[T range ]F .. L\"\n \n-      function Type_Img (L : Natural) return String;\n-      --  Return the larger unsigned type T such that T'Last < L\n+      function Type_Img (Siz : Positive) return String;\n+      --  Return the name of the unsigned type of size S\n \n       ---------------\n       -- Array_Img --\n@@ -1510,8 +350,8 @@ package body GNAT.Perfect_Hash_Generators is\n       -- Type_Img --\n       --------------\n \n-      function Type_Img (L : Natural) return String is\n-         S : constant String := Image (Type_Size (L));\n+      function Type_Img (Siz : Positive) return String is\n+         S : constant String := Image (Siz);\n          U : String  := \"Unsigned_  \";\n          N : Natural := 9;\n \n@@ -1524,8 +364,6 @@ package body GNAT.Perfect_Hash_Generators is\n          return U (1 .. N);\n       end Type_Img;\n \n-      F : Natural;\n-      L : Natural;\n       P : Natural;\n \n       FName : String := Ada_File_Base_Name (Pkg_Name) & \".ads\";\n@@ -1535,13 +373,6 @@ package body GNAT.Perfect_Hash_Generators is\n    --  Start of processing for Produce\n \n    begin\n-\n-      if Verbose and then not Use_Stdout then\n-         Put (Output,\n-              \"Producing \" & Ada.Directories.Current_Directory & \"/\" & FName);\n-         New_Line (Output);\n-      end if;\n-\n       if not Use_Stdout then\n          File := Create_File (FName, Binary);\n \n@@ -1592,75 +423,89 @@ package body GNAT.Perfect_Hash_Generators is\n       New_Line (File);\n \n       if Opt = CPU_Time then\n-         Put      (File, Array_Img (\"C\", Type_Img (256), \"Character\"));\n-         New_Line (File);\n+         --  The format of this table is fixed\n \n-         F := Character'Pos (Character'First);\n-         L := Character'Pos (Character'Last);\n+         Define (Used_Character_Set, Siz, L1, L2);\n+         pragma Assert (L1 = 256 and then L2 = 0);\n+\n+         Put      (File, Array_Img (\"C\", Type_Img (Siz), \"Character\"));\n+         New_Line (File);\n \n-         for J in Character'Range loop\n-            P := Get_Used_Char (J);\n-            Put (File, Image (P), 1, 0, 1, F, L, Character'Pos (J));\n+         for J in 0 .. 255 loop\n+            P := Value (Used_Character_Set, J);\n+            Put (File, Image (P), 1, 0, 1, 0, 255, J);\n          end loop;\n \n          New_Line (File);\n       end if;\n \n-      F := 0;\n-      L := Char_Pos_Set_Len - 1;\n+      Define (Character_Position, Siz, L1, L2);\n+      pragma Assert (Siz = 31 and then L2 = 0);\n \n-      Put      (File, Array_Img (\"P\", \"Natural\", Range_Img (F, L)));\n+      Put      (File, Array_Img (\"P\", \"Natural\", Range_Img (0, L1 - 1)));\n       New_Line (File);\n \n-      for J in F .. L loop\n-         Put (File, Image (Get_Char_Pos (J)), 1, 0, 1, F, L, J);\n+      for J in 0 .. L1 - 1 loop\n+         P := Value (Character_Position, J);\n+         Put (File, Image (P), 1, 0, 1, 0, L1 - 1, J);\n       end loop;\n \n       New_Line (File);\n \n+      Define (Function_Table_1, Siz, L1, L2);\n+\n       case Opt is\n          when CPU_Time =>\n             Put_Int_Matrix\n               (File,\n-               Array_Img (\"T1\", Type_Img (NV),\n-                          Range_Img (0, T1_Len - 1),\n-                          Range_Img (0, T2_Len - 1, Type_Img (256))),\n-               T1, T1_Len, T2_Len);\n+               Array_Img (\"T1\", Type_Img (Siz),\n+                          Range_Img (0, L1 - 1),\n+                          Range_Img (0, L2 - 1, Type_Img (8))),\n+               Function_Table_1, L1, L2);\n \n          when Memory_Space =>\n             Put_Int_Matrix\n               (File,\n-               Array_Img (\"T1\", Type_Img (NV),\n-                          Range_Img (0, T1_Len - 1)),\n-               T1, T1_Len, 0);\n+               Array_Img (\"T1\", Type_Img (Siz),\n+                          Range_Img (0, L1 - 1)),\n+               Function_Table_1, L1, 0);\n       end case;\n \n       New_Line (File);\n \n+      Define (Function_Table_2, Siz, L1, L2);\n+\n       case Opt is\n          when CPU_Time =>\n             Put_Int_Matrix\n               (File,\n-               Array_Img (\"T2\", Type_Img (NV),\n-                          Range_Img (0, T1_Len - 1),\n-                          Range_Img (0, T2_Len - 1, Type_Img (256))),\n-               T2, T1_Len, T2_Len);\n+               Array_Img (\"T2\", Type_Img (Siz),\n+                          Range_Img (0, L1 - 1),\n+                          Range_Img (0, L2 - 1, Type_Img (8))),\n+               Function_Table_2, L1, L2);\n \n          when Memory_Space =>\n             Put_Int_Matrix\n               (File,\n-               Array_Img (\"T2\", Type_Img (NV),\n-                          Range_Img (0, T1_Len - 1)),\n-               T2, T1_Len, 0);\n+               Array_Img (\"T2\", Type_Img (Siz),\n+                          Range_Img (0, L1 - 1)),\n+               Function_Table_2, L1, 0);\n       end case;\n \n       New_Line (File);\n \n-      Put_Int_Vector\n-        (File,\n-         Array_Img (\"G\", Type_Img (NK),\n-                    Range_Img (0, G_Len - 1)),\n-         G, G_Len);\n+      Define (Graph_Table, Siz, L1, L2);\n+      pragma Assert (L2 = 0);\n+\n+      Put (File, Array_Img (\"G\", Type_Img (Siz),\n+                    Range_Img (0, L1 - 1)));\n+      New_Line (File);\n+\n+      for J in 0 .. L1 - 1 loop\n+         P := Value (Graph_Table, J);\n+         Put (File, Image (P), 1, 0, 1, 0, L1 - 1, J);\n+      end loop;\n+\n       New_Line (File);\n \n       Put      (File, \"   function Hash (S : String) return Natural is\");\n@@ -1676,7 +521,7 @@ package body GNAT.Perfect_Hash_Generators is\n \n       case Opt is\n          when CPU_Time =>\n-            Put (File, Type_Img (256));\n+            Put (File, Type_Img (8));\n \n          when Memory_Space =>\n             Put (File, \"Natural\");\n@@ -1717,7 +562,7 @@ package body GNAT.Perfect_Hash_Generators is\n       end if;\n \n       Put      (File, \") mod \");\n-      Put      (File, Image (NV));\n+      Put      (File, Image (L1));\n       Put      (File, \";\");\n       New_Line (File);\n \n@@ -1734,7 +579,7 @@ package body GNAT.Perfect_Hash_Generators is\n       end if;\n \n       Put      (File, \") mod \");\n-      Put      (File, Image (NV));\n+      Put      (File, Image (L1));\n       Put      (File, \";\");\n       New_Line (File);\n \n@@ -1874,62 +719,14 @@ package body GNAT.Perfect_Hash_Generators is\n       end if;\n    end Put;\n \n-   ---------------\n-   -- Put_Edges --\n-   ---------------\n-\n-   procedure Put_Edges (File  : File_Descriptor; Title : String) is\n-      E  : Edge_Type;\n-      F1 : constant Natural := 1;\n-      L1 : constant Natural := Edges_Len - 1;\n-      M  : constant Natural := Max / 5;\n-\n-   begin\n-      Put (File, Title);\n-      New_Line (File);\n-\n-      --  Edges valid range is 1 .. Edge_Len - 1\n-\n-      for J in F1 .. L1 loop\n-         E := Get_Edges (J);\n-         Put (File, Image (J, M),     F1, L1, J, 1, 4, 1);\n-         Put (File, Image (E.X, M),   F1, L1, J, 1, 4, 2);\n-         Put (File, Image (E.Y, M),   F1, L1, J, 1, 4, 3);\n-         Put (File, Image (E.Key, M), F1, L1, J, 1, 4, 4);\n-      end loop;\n-   end Put_Edges;\n-\n-   ----------------------\n-   -- Put_Initial_Keys --\n-   ----------------------\n-\n-   procedure Put_Initial_Keys (File : File_Descriptor; Title : String) is\n-      F1 : constant Natural := 0;\n-      L1 : constant Natural := NK - 1;\n-      M  : constant Natural := Max / 5;\n-      K  : Key_Type;\n-\n-   begin\n-      Put (File, Title);\n-      New_Line (File);\n-\n-      for J in F1 .. L1 loop\n-         K := Get_Key (J);\n-         Put (File, Image (J, M),           F1, L1, J, 1, 3, 1);\n-         Put (File, Image (K.Edge, M),      F1, L1, J, 1, 3, 2);\n-         Put (File, Trim_Trailing_Nuls (WT.Table (Initial (J)).all),\n-                    F1, L1, J, 1, 3, 3);\n-      end loop;\n-   end Put_Initial_Keys;\n-\n    --------------------\n    -- Put_Int_Matrix --\n    --------------------\n \n    procedure Put_Int_Matrix\n      (File   : File_Descriptor;\n       Title  : String;\n-      Table  : Integer;\n+      Table  : Table_Name;\n       Len_1  : Natural;\n       Len_2  : Natural)\n    is\n@@ -1945,665 +742,18 @@ package body GNAT.Perfect_Hash_Generators is\n \n       if Len_2 = 0 then\n          for J in F1 .. L1 loop\n-            Ix := IT.Table (Table + J);\n+            Ix := Value (Table, J, 0);\n             Put (File, Image (Ix), 1, 0, 1, F1, L1, J);\n          end loop;\n \n       else\n          for J in F1 .. L1 loop\n             for K in F2 .. L2 loop\n-               Ix := IT.Table (Table + J + K * Len_1);\n+               Ix := Value (Table, J, K);\n                Put (File, Image (Ix), F1, L1, J, F2, L2, K);\n             end loop;\n          end loop;\n       end if;\n    end Put_Int_Matrix;\n \n-   --------------------\n-   -- Put_Int_Vector --\n-   --------------------\n-\n-   procedure Put_Int_Vector\n-     (File   : File_Descriptor;\n-      Title  : String;\n-      Vector : Integer;\n-      Length : Natural)\n-   is\n-      F2 : constant Natural := 0;\n-      L2 : constant Natural := Length - 1;\n-\n-   begin\n-      Put (File, Title);\n-      New_Line (File);\n-\n-      for J in F2 .. L2 loop\n-         Put (File, Image (IT.Table (Vector + J)), 1, 0, 1, F2, L2, J);\n-      end loop;\n-   end Put_Int_Vector;\n-\n-   ----------------------\n-   -- Put_Reduced_Keys --\n-   ----------------------\n-\n-   procedure Put_Reduced_Keys (File : File_Descriptor; Title : String) is\n-      F1 : constant Natural := 0;\n-      L1 : constant Natural := NK - 1;\n-      M  : constant Natural := Max / 5;\n-      K  : Key_Type;\n-\n-   begin\n-      Put (File, Title);\n-      New_Line (File);\n-\n-      for J in F1 .. L1 loop\n-         K := Get_Key (J);\n-         Put (File, Image (J, M),           F1, L1, J, 1, 3, 1);\n-         Put (File, Image (K.Edge, M),      F1, L1, J, 1, 3, 2);\n-         Put (File, Trim_Trailing_Nuls (WT.Table (Reduced (J)).all),\n-                    F1, L1, J, 1, 3, 3);\n-      end loop;\n-   end Put_Reduced_Keys;\n-\n-   -----------------------\n-   -- Put_Used_Char_Set --\n-   -----------------------\n-\n-   procedure Put_Used_Char_Set (File : File_Descriptor; Title : String) is\n-      F : constant Natural := Character'Pos (Character'First);\n-      L : constant Natural := Character'Pos (Character'Last);\n-\n-   begin\n-      Put (File, Title);\n-      New_Line (File);\n-\n-      for J in Character'Range loop\n-         Put\n-           (File, Image (Get_Used_Char (J)), 1, 0, 1, F, L, Character'Pos (J));\n-      end loop;\n-   end Put_Used_Char_Set;\n-\n-   ----------------------\n-   -- Put_Vertex_Table --\n-   ----------------------\n-\n-   procedure Put_Vertex_Table (File : File_Descriptor; Title : String) is\n-      F1 : constant Natural := 0;\n-      L1 : constant Natural := NV - 1;\n-      M  : constant Natural := Max / 4;\n-      V  : Vertex_Type;\n-\n-   begin\n-      Put (File, Title);\n-      New_Line (File);\n-\n-      for J in F1 .. L1 loop\n-         V := Get_Vertices (J);\n-         Put (File, Image (J, M),       F1, L1, J, 1, 3, 1);\n-         Put (File, Image (V.First, M), F1, L1, J, 1, 3, 2);\n-         Put (File, Image (V.Last, M),  F1, L1, J, 1, 3, 3);\n-      end loop;\n-   end Put_Vertex_Table;\n-\n-   ------------\n-   -- Random --\n-   ------------\n-\n-   procedure Random (Seed : in out Natural) is\n-\n-      --  Park & Miller Standard Minimal using Schrage's algorithm to avoid\n-      --  overflow: Xn+1 = 16807 * Xn mod (2 ** 31 - 1)\n-\n-      R : Natural;\n-      Q : Natural;\n-      X : Integer;\n-\n-   begin\n-      R := Seed mod 127773;\n-      Q := Seed / 127773;\n-      X := 16807 * R - 2836 * Q;\n-\n-      Seed := (if X < 0 then X + 2147483647 else X);\n-   end Random;\n-\n-   -------------\n-   -- Reduced --\n-   -------------\n-\n-   function Reduced (K : Key_Id) return Word_Id is\n-   begin\n-      return K + NK + 1;\n-   end Reduced;\n-\n-   -----------------\n-   -- Resize_Word --\n-   -----------------\n-\n-   procedure Resize_Word (W : in out Word_Type; Len : Natural) is\n-      S1 : constant String := W.all;\n-      S2 : String (1 .. Len) := (others => ASCII.NUL);\n-      L  : constant Natural := S1'Length;\n-   begin\n-      if L /= Len then\n-         Free_Word (W);\n-         S2 (1 .. L) := S1;\n-         W := New_Word (S2);\n-      end if;\n-   end Resize_Word;\n-\n-   --------------------------\n-   -- Select_Char_Position --\n-   --------------------------\n-\n-   procedure Select_Char_Position is\n-\n-      type Vertex_Table_Type is array (Natural range <>) of Vertex_Type;\n-\n-      procedure Build_Identical_Keys_Sets\n-        (Table : in out Vertex_Table_Type;\n-         Last  : in out Natural;\n-         Pos   : Natural);\n-      --  Build a list of keys subsets that are identical with the current\n-      --  position selection plus Pos. Once this routine is called, reduced\n-      --  words are sorted by subsets and each item (First, Last) in Sets\n-      --  defines the range of identical keys.\n-      --  Need comment saying exactly what Last is ???\n-\n-      function Count_Different_Keys\n-        (Table : Vertex_Table_Type;\n-         Last  : Natural;\n-         Pos   : Natural) return Natural;\n-      --  For each subset in Sets, count the number of different keys if we add\n-      --  Pos to the current position selection.\n-\n-      Sel_Position : IT.Table_Type (1 .. Max_Key_Len);\n-      Last_Sel_Pos : Natural := 0;\n-      Max_Sel_Pos  : Natural := 0;\n-\n-      -------------------------------\n-      -- Build_Identical_Keys_Sets --\n-      -------------------------------\n-\n-      procedure Build_Identical_Keys_Sets\n-        (Table : in out Vertex_Table_Type;\n-         Last  : in out Natural;\n-         Pos   : Natural)\n-      is\n-         S : constant Vertex_Table_Type := Table (Table'First .. Last);\n-         C : constant Natural           := Pos;\n-         --  Shortcuts (why are these not renames ???)\n-\n-         F : Integer;\n-         L : Integer;\n-         --  First and last words of a subset\n-\n-         Offset : Natural;\n-         --  GNAT.Heap_Sort assumes that the first array index is 1. Offset\n-         --  defines the translation to operate.\n-\n-         function Lt (L, R : Natural) return Boolean;\n-         procedure Move (From : Natural; To : Natural);\n-         --  Subprograms needed by GNAT.Heap_Sort_G\n-\n-         --------\n-         -- Lt --\n-         --------\n-\n-         function Lt (L, R : Natural) return Boolean is\n-            C     : constant Natural := Pos;\n-            Left  : Natural;\n-            Right : Natural;\n-\n-         begin\n-            if L = 0 then\n-               Left  := NK;\n-               Right := Offset + R;\n-            elsif R = 0 then\n-               Left  := Offset + L;\n-               Right := NK;\n-            else\n-               Left  := Offset + L;\n-               Right := Offset + R;\n-            end if;\n-\n-            return WT.Table (Left)(C) < WT.Table (Right)(C);\n-         end Lt;\n-\n-         ----------\n-         -- Move --\n-         ----------\n-\n-         procedure Move (From : Natural; To : Natural) is\n-            Target, Source : Natural;\n-\n-         begin\n-            if From = 0 then\n-               Source := NK;\n-               Target := Offset + To;\n-            elsif To = 0 then\n-               Source := Offset + From;\n-               Target := NK;\n-            else\n-               Source := Offset + From;\n-               Target := Offset + To;\n-            end if;\n-\n-            WT.Table (Target) := WT.Table (Source);\n-            WT.Table (Source) := null;\n-         end Move;\n-\n-         package Sorting is new GNAT.Heap_Sort_G (Move, Lt);\n-\n-      --  Start of processing for Build_Identical_Key_Sets\n-\n-      begin\n-         Last := 0;\n-\n-         --  For each subset in S, extract the new subsets we have by adding C\n-         --  in the position selection.\n-\n-         for J in S'Range loop\n-            pragma Annotate (CodePeer, Modified, S (J));\n-\n-            if S (J).First = S (J).Last then\n-               F := S (J).First;\n-               L := S (J).Last;\n-               Last := Last + 1;\n-               Table (Last) := (F, L);\n-\n-            else\n-               Offset := Reduced (S (J).First) - 1;\n-               Sorting.Sort (S (J).Last - S (J).First + 1);\n-\n-               F := S (J).First;\n-               L := F;\n-               for N in S (J).First .. S (J).Last loop\n-\n-                  --  For the last item, close the last subset\n-\n-                  if N = S (J).Last then\n-                     Last := Last + 1;\n-                     Table (Last) := (F, N);\n-\n-                  --  Two contiguous words are identical when they have the\n-                  --  same Cth character.\n-\n-                  elsif WT.Table (Reduced (N))(C) =\n-                        WT.Table (Reduced (N + 1))(C)\n-                  then\n-                     L := N + 1;\n-\n-                  --  Find a new subset of identical keys. Store the current\n-                  --  one and create a new subset.\n-\n-                  else\n-                     Last := Last + 1;\n-                     Table (Last) := (F, L);\n-                     F := N + 1;\n-                     L := F;\n-                  end if;\n-               end loop;\n-            end if;\n-         end loop;\n-      end Build_Identical_Keys_Sets;\n-\n-      --------------------------\n-      -- Count_Different_Keys --\n-      --------------------------\n-\n-      function Count_Different_Keys\n-        (Table : Vertex_Table_Type;\n-         Last  : Natural;\n-         Pos   : Natural) return Natural\n-      is\n-         N : array (Character) of Natural;\n-         C : Character;\n-         T : Natural := 0;\n-\n-      begin\n-         --  For each subset, count the number of words that are still\n-         --  different when we include Pos in the position selection. Only\n-         --  focus on this position as the other positions already produce\n-         --  identical keys.\n-\n-         for S in 1 .. Last loop\n-\n-            --  Count the occurrences of the different characters\n-\n-            N := (others => 0);\n-            for K in Table (S).First .. Table (S).Last loop\n-               C := WT.Table (Reduced (K))(Pos);\n-               N (C) := N (C) + 1;\n-            end loop;\n-\n-            --  Update the number of different keys. Each character used\n-            --  denotes a different key.\n-\n-            for J in N'Range loop\n-               if N (J) > 0 then\n-                  T := T + 1;\n-               end if;\n-            end loop;\n-         end loop;\n-\n-         return T;\n-      end Count_Different_Keys;\n-\n-   --  Start of processing for Select_Char_Position\n-\n-   begin\n-      --  Initialize the reduced words set\n-\n-      for K in 0 .. NK - 1 loop\n-         WT.Table (Reduced (K)) := New_Word (WT.Table (Initial (K)).all);\n-      end loop;\n-\n-      declare\n-         Differences          : Natural;\n-         Max_Differences      : Natural := 0;\n-         Old_Differences      : Natural;\n-         Max_Diff_Sel_Pos     : Natural := 0; -- init to kill warning\n-         Max_Diff_Sel_Pos_Idx : Natural := 0; -- init to kill warning\n-         Same_Keys_Sets_Table : Vertex_Table_Type (1 .. NK);\n-         Same_Keys_Sets_Last  : Natural := 1;\n-\n-      begin\n-         for C in Sel_Position'Range loop\n-            Sel_Position (C) := C;\n-         end loop;\n-\n-         Same_Keys_Sets_Table (1) := (0, NK - 1);\n-\n-         loop\n-            --  Preserve maximum number of different keys and check later on\n-            --  that this value is strictly incrementing. Otherwise, it means\n-            --  that two keys are strictly identical.\n-\n-            Old_Differences := Max_Differences;\n-\n-            --  The first position should not exceed the minimum key length.\n-            --  Otherwise, we may end up with an empty word once reduced.\n-\n-            Max_Sel_Pos :=\n-              (if Last_Sel_Pos = 0 then Min_Key_Len else Max_Key_Len);\n-\n-            --  Find which position increases more the number of differences\n-\n-            for J in Last_Sel_Pos + 1 .. Max_Sel_Pos loop\n-               Differences := Count_Different_Keys\n-                 (Same_Keys_Sets_Table,\n-                  Same_Keys_Sets_Last,\n-                  Sel_Position (J));\n-\n-               if Verbose then\n-                  Put (Output,\n-                       \"Selecting position\" & Sel_Position (J)'Img &\n-                         \" results in\" & Differences'Img &\n-                         \" differences\");\n-                  New_Line (Output);\n-               end if;\n-\n-               if Differences > Max_Differences then\n-                  Max_Differences      := Differences;\n-                  Max_Diff_Sel_Pos     := Sel_Position (J);\n-                  Max_Diff_Sel_Pos_Idx := J;\n-               end if;\n-            end loop;\n-\n-            if Old_Differences = Max_Differences then\n-               raise Program_Error with \"some keys are identical\";\n-            end if;\n-\n-            --  Insert selected position and sort Sel_Position table\n-\n-            Last_Sel_Pos := Last_Sel_Pos + 1;\n-            Sel_Position (Last_Sel_Pos + 1 .. Max_Diff_Sel_Pos_Idx) :=\n-              Sel_Position (Last_Sel_Pos .. Max_Diff_Sel_Pos_Idx - 1);\n-            Sel_Position (Last_Sel_Pos) := Max_Diff_Sel_Pos;\n-\n-            for P in 1 .. Last_Sel_Pos - 1 loop\n-               if Max_Diff_Sel_Pos < Sel_Position (P) then\n-                  pragma Annotate\n-                    (CodePeer, False_Positive,\n-                     \"test always false\", \"false positive?\");\n-\n-                  Sel_Position (P + 1 .. Last_Sel_Pos) :=\n-                    Sel_Position (P .. Last_Sel_Pos - 1);\n-                  Sel_Position (P) := Max_Diff_Sel_Pos;\n-                  exit;\n-               end if;\n-            end loop;\n-\n-            exit when Max_Differences = NK;\n-\n-            Build_Identical_Keys_Sets\n-              (Same_Keys_Sets_Table,\n-               Same_Keys_Sets_Last,\n-               Max_Diff_Sel_Pos);\n-\n-            if Verbose then\n-               Put (Output,\n-                    \"Selecting position\" & Max_Diff_Sel_Pos'Img &\n-                      \" results in\" & Max_Differences'Img &\n-                      \" differences\");\n-               New_Line (Output);\n-               Put (Output, \"--\");\n-               New_Line (Output);\n-               for J in 1 .. Same_Keys_Sets_Last loop\n-                  for K in\n-                    Same_Keys_Sets_Table (J).First ..\n-                    Same_Keys_Sets_Table (J).Last\n-                  loop\n-                     Put (Output,\n-                          Trim_Trailing_Nuls (WT.Table (Reduced (K)).all));\n-                     New_Line (Output);\n-                  end loop;\n-                  Put (Output, \"--\");\n-                  New_Line (Output);\n-               end loop;\n-            end if;\n-         end loop;\n-      end;\n-\n-      Char_Pos_Set_Len := Last_Sel_Pos;\n-      Char_Pos_Set := Allocate (Char_Pos_Set_Len);\n-\n-      for C in 1 .. Last_Sel_Pos loop\n-         Set_Char_Pos (C - 1, Sel_Position (C));\n-      end loop;\n-   end Select_Char_Position;\n-\n-   --------------------------\n-   -- Select_Character_Set --\n-   --------------------------\n-\n-   procedure Select_Character_Set is\n-      Last : Natural := 0;\n-      Used : array (Character) of Boolean := (others => False);\n-      Char : Character;\n-\n-   begin\n-      for J in 0 .. NK - 1 loop\n-         for K in 0 .. Char_Pos_Set_Len - 1 loop\n-            Char := WT.Table (Initial (J))(Get_Char_Pos (K));\n-            exit when Char = ASCII.NUL;\n-            Used (Char) := True;\n-         end loop;\n-      end loop;\n-\n-      Used_Char_Set_Len := 256;\n-      Used_Char_Set := Allocate (Used_Char_Set_Len);\n-\n-      for J in Used'Range loop\n-         if Used (J) then\n-            Set_Used_Char (J, Last);\n-            Last := Last + 1;\n-         else\n-            Set_Used_Char (J, 0);\n-         end if;\n-      end loop;\n-   end Select_Character_Set;\n-\n-   ------------------\n-   -- Set_Char_Pos --\n-   ------------------\n-\n-   procedure Set_Char_Pos (P : Natural; Item : Natural) is\n-      N : constant Natural := Char_Pos_Set + P;\n-   begin\n-      IT.Table (N) := Item;\n-   end Set_Char_Pos;\n-\n-   ---------------\n-   -- Set_Edges --\n-   ---------------\n-\n-   procedure Set_Edges (F : Natural; Item : Edge_Type) is\n-      N : constant Natural := Edges + (F * Edge_Size);\n-   begin\n-      IT.Table (N)     := Item.X;\n-      IT.Table (N + 1) := Item.Y;\n-      IT.Table (N + 2) := Item.Key;\n-   end Set_Edges;\n-\n-   ---------------\n-   -- Set_Graph --\n-   ---------------\n-\n-   procedure Set_Graph (N : Natural; Item : Integer) is\n-   begin\n-      IT.Table (G + N) := Item;\n-   end Set_Graph;\n-\n-   -------------\n-   -- Set_Key --\n-   -------------\n-\n-   procedure Set_Key (N : Key_Id; Item : Key_Type) is\n-   begin\n-      IT.Table (Keys + N) := Item.Edge;\n-   end Set_Key;\n-\n-   ---------------\n-   -- Set_Table --\n-   ---------------\n-\n-   procedure Set_Table (T : Integer; X, Y : Natural; Item : Natural) is\n-      N : constant Natural := T + ((Y * T1_Len) + X);\n-   begin\n-      IT.Table (N) := Item;\n-   end Set_Table;\n-\n-   -------------------\n-   -- Set_Used_Char --\n-   -------------------\n-\n-   procedure Set_Used_Char (C : Character; Item : Natural) is\n-      N : constant Natural := Used_Char_Set + Character'Pos (C);\n-   begin\n-      IT.Table (N) := Item;\n-   end Set_Used_Char;\n-\n-   ------------------\n-   -- Set_Vertices --\n-   ------------------\n-\n-   procedure Set_Vertices (F : Natural; Item : Vertex_Type) is\n-      N : constant Natural := Vertices + (F * Vertex_Size);\n-   begin\n-      IT.Table (N)     := Item.First;\n-      IT.Table (N + 1) := Item.Last;\n-   end Set_Vertices;\n-\n-   ---------\n-   -- Sum --\n-   ---------\n-\n-   function Sum\n-     (Word  : Word_Type;\n-      Table : Table_Id;\n-      Opt   : Optimization) return Natural\n-   is\n-      S : Natural := 0;\n-      R : Natural;\n-\n-   begin\n-      case Opt is\n-         when CPU_Time =>\n-            for J in 0 .. T1_Len - 1 loop\n-               exit when Word (J + 1) = ASCII.NUL;\n-               R := Get_Table (Table, J, Get_Used_Char (Word (J + 1)));\n-               pragma Assert (NV /= 0);\n-               S := (S + R) mod NV;\n-            end loop;\n-\n-         when Memory_Space =>\n-            for J in 0 .. T1_Len - 1 loop\n-               exit when Word (J + 1) = ASCII.NUL;\n-               R := Get_Table (Table, J, 0);\n-               pragma Assert (NV /= 0);\n-               S := (S + R * Character'Pos (Word (J + 1))) mod NV;\n-            end loop;\n-      end case;\n-\n-      return S;\n-   end Sum;\n-\n-   ------------------------\n-   -- Trim_Trailing_Nuls --\n-   ------------------------\n-\n-   function Trim_Trailing_Nuls (Str : String) return String is\n-   begin\n-      for J in reverse Str'Range loop\n-         if Str (J) /= ASCII.NUL then\n-            return Str (Str'First .. J);\n-         end if;\n-      end loop;\n-\n-      return Str;\n-   end Trim_Trailing_Nuls;\n-\n-   ---------------\n-   -- Type_Size --\n-   ---------------\n-\n-   function Type_Size (L : Natural) return Natural is\n-   begin\n-      if L <= 2 ** 8 then\n-         return 8;\n-      elsif L <= 2 ** 16 then\n-         return 16;\n-      else\n-         return 32;\n-      end if;\n-   end Type_Size;\n-\n-   -----------\n-   -- Value --\n-   -----------\n-\n-   function Value\n-     (Name : Table_Name;\n-      J    : Natural;\n-      K    : Natural := 0) return Natural\n-   is\n-   begin\n-      case Name is\n-         when Character_Position =>\n-            return Get_Char_Pos (J);\n-\n-         when Used_Character_Set =>\n-            return Get_Used_Char (Character'Val (J));\n-\n-         when Function_Table_1 =>\n-            return Get_Table (T1, J, K);\n-\n-         when Function_Table_2 =>\n-            return Get_Table (T2, J, K);\n-\n-         when Graph_Table =>\n-            return Get_Graph (J);\n-      end case;\n-   end Value;\n-\n end GNAT.Perfect_Hash_Generators;"}, {"sha": "41913cbc97f5673d16c2c45ad187fa63375db99f", "filename": "gcc/ada/libgnat/g-pehage.ads", "status": "modified", "additions": 11, "deletions": 104, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fg-pehage.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fg-pehage.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-pehage.ads?ref=c11207d345f8d678d440a3ff0f335b2ed25513e7", "patch": "@@ -64,8 +64,12 @@\n --  < h (w2). These hashing functions are convenient for use with realtime\n --  applications.\n \n+with System.Perfect_Hash_Generators;\n+\n package GNAT.Perfect_Hash_Generators is\n \n+   package SPHG renames System.Perfect_Hash_Generators;\n+\n    Default_K_To_V : constant Float  := 2.05;\n    --  Default ratio for the algorithm. When K is the number of keys, V =\n    --  (K_To_V) * K is the size of the main table of the hash function. To\n@@ -83,12 +87,12 @@ package GNAT.Perfect_Hash_Generators is\n    --  try and may have to iterate a number of times. This constant bounds the\n    --  number of tries.\n \n-   type Optimization is (Memory_Space, CPU_Time);\n+   type Optimization is new SPHG.Optimization;\n    --  Optimize either the memory space or the execution time. Note: in\n    --  practice, the optimization mode has little effect on speed. The tables\n    --  are somewhat smaller with Memory_Space.\n \n-   Verbose : Boolean := False;\n+   Verbose : Boolean renames SPHG.Verbose;\n    --  Output the status of the algorithm. For instance, the tables, the random\n    --  graph (edges, vertices) and selected char positions are output between\n    --  two iterations.\n@@ -106,18 +110,18 @@ package GNAT.Perfect_Hash_Generators is\n    --  the same words.\n    --\n    --  A classical way of doing is to Insert all the words and then to invoke\n-   --  Initialize and Compute. If Compute fails to find a perfect hash\n-   --  function, invoke Initialize another time with other configuration\n-   --  parameters (probably with a greater K_To_V ratio). Once successful,\n-   --  invoke Produce and Finalize.\n+   --  Initialize and Compute. If this fails to find a perfect hash function,\n+   --  invoke Initialize again with other configuration parameters (probably\n+   --  with a greater K_To_V ratio). Once successful, invoke Produce and then\n+   --  Finalize.\n \n    procedure Finalize;\n    --  Deallocate the internal structures and the words table\n \n    procedure Insert (Value : String);\n    --  Insert a new word into the table. ASCII.NUL characters are not allowed.\n \n-   Too_Many_Tries : exception;\n+   Too_Many_Tries : exception renames SPHG.Too_Many_Tries;\n    --  Raised after Tries unsuccessful runs\n \n    procedure Compute (Position : String := Default_Position);\n@@ -138,101 +142,4 @@ package GNAT.Perfect_Hash_Generators is\n    --  GNAT file name for a package named Pkg_Name. If Use_Stdout is True, the\n    --  output goes to standard output, and no files are written.\n \n-   ----------------------------------------------------------------\n-\n-   --  The routines and structures defined below allow producing the hash\n-   --  function using a different way from the procedure above. The procedure\n-   --  Define returns the lengths of an internal table and its item type size.\n-   --  The function Value returns the value of each item in the table.\n-\n-   --  The hash function has the following form:\n-\n-   --             h (w) = (g (f1 (w)) + g (f2 (w))) mod m\n-\n-   --  G is a function based on a graph table [0,n-1] -> [0,m-1]. m is the\n-   --  number of keys. n is an internally computed value and it can be obtained\n-   --  as the length of vector G.\n-\n-   --  F1 and F2 are two functions based on two function tables T1 and T2.\n-   --  Their definition depends on the chosen optimization mode.\n-\n-   --  Only some character positions are used in the words because they are\n-   --  significant. They are listed in a character position table (P in the\n-   --  pseudo-code below). For instance, in {\"jan\", \"feb\", \"mar\", \"apr\", \"jun\",\n-   --  \"jul\", \"aug\", \"sep\", \"oct\", \"nov\", \"dec\"}, only positions 2 and 3 are\n-   --  significant (the first character can be ignored). In this example, P =\n-   --  {2, 3}\n-\n-   --  When Optimization is CPU_Time, the first dimension of T1 and T2\n-   --  corresponds to the character position in the word and the second to the\n-   --  character set. As all the character set is not used, we define a used\n-   --  character table which associates a distinct index to each used character\n-   --  (unused characters are mapped to zero). In this case, the second\n-   --  dimension of T1 and T2 is reduced to the used character set (C in the\n-   --  pseudo-code below). Therefore, the hash function has the following:\n-\n-   --    function Hash (S : String) return Natural is\n-   --       F      : constant Natural := S'First - 1;\n-   --       L      : constant Natural := S'Length;\n-   --       F1, F2 : Natural := 0;\n-   --       J      : <t>;\n-\n-   --    begin\n-   --       for K in P'Range loop\n-   --          exit when L < P (K);\n-   --          J  := C (S (P (K) + F));\n-   --          F1 := (F1 + Natural (T1 (K, J))) mod <n>;\n-   --          F2 := (F2 + Natural (T2 (K, J))) mod <n>;\n-   --       end loop;\n-\n-   --       return (Natural (G (F1)) + Natural (G (F2))) mod <m>;\n-   --    end Hash;\n-\n-   --  When Optimization is Memory_Space, the first dimension of T1 and T2\n-   --  corresponds to the character position in the word and the second\n-   --  dimension is ignored. T1 and T2 are no longer matrices but vectors.\n-   --  Therefore, the used character table is not available. The hash function\n-   --  has the following form:\n-\n-   --     function Hash (S : String) return Natural is\n-   --        F      : constant Natural := S'First - 1;\n-   --        L      : constant Natural := S'Length;\n-   --        F1, F2 : Natural := 0;\n-   --        J      : <t>;\n-\n-   --     begin\n-   --        for K in P'Range loop\n-   --           exit when L < P (K);\n-   --           J  := Character'Pos (S (P (K) + F));\n-   --           F1 := (F1 + Natural (T1 (K) * J)) mod <n>;\n-   --           F2 := (F2 + Natural (T2 (K) * J)) mod <n>;\n-   --        end loop;\n-\n-   --        return (Natural (G (F1)) + Natural (G (F2))) mod <m>;\n-   --     end Hash;\n-\n-   type Table_Name is\n-     (Character_Position,\n-      Used_Character_Set,\n-      Function_Table_1,\n-      Function_Table_2,\n-      Graph_Table);\n-\n-   procedure Define\n-     (Name      : Table_Name;\n-      Item_Size : out Natural;\n-      Length_1  : out Natural;\n-      Length_2  : out Natural);\n-   --  Return the definition of the table Name. This includes the length of\n-   --  dimensions 1 and 2 and the size of an unsigned integer item. When\n-   --  Length_2 is zero, the table has only one dimension. All the ranges\n-   --  start from zero.\n-\n-   function Value\n-     (Name : Table_Name;\n-      J    : Natural;\n-      K    : Natural := 0) return Natural;\n-   --  Return the value of the component (I, J) of the table Name. When the\n-   --  table has only one dimension, J is ignored.\n-\n end GNAT.Perfect_Hash_Generators;"}, {"sha": "7d3ef58713fcc1d6ec571a10974a47e97c964b14", "filename": "gcc/ada/libgnat/g-table.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fg-table.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fg-table.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-table.ads?ref=c11207d345f8d678d440a3ff0f335b2ed25513e7", "patch": "@@ -41,6 +41,8 @@\n --     GNAT.Table\n --     Table (the compiler unit)\n \n+pragma Compiler_Unit_Warning;\n+\n with GNAT.Dynamic_Tables;\n \n generic"}, {"sha": "48c2e9fc30d766719c02701ce04fb94bbfb9fbea", "filename": "gcc/ada/libgnat/s-imagen.adb", "status": "renamed", "additions": 27, "deletions": 76, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fs-imagen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fs-imagen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imagen.adb?ref=c11207d345f8d678d440a3ff0f335b2ed25513e7", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT RUN-TIME COMPONENTS                         --\n --                                                                          --\n---                      S Y S T E M . I M G _ E N U M                       --\n+--                       S Y S T E M . I M A G E _ N                        --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2000-2021, Free Software Foundation, Inc.         --\n+--             Copyright (C) 2021, Free Software Foundation, Inc.           --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,100 +29,51 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-pragma Compiler_Unit_Warning;\n-\n with Ada.Unchecked_Conversion;\n \n-package body System.Img_Enum is\n+package body System.Image_N is\n \n-   -------------------------\n-   -- Image_Enumeration_8 --\n-   -------------------------\n+   -----------------------\n+   -- Image_Enumeration --\n+   -----------------------\n \n-   function Image_Enumeration_8\n+   procedure Image_Enumeration\n      (Pos     : Natural;\n+      S       : in out String;\n+      P       : out Natural;\n       Names   : String;\n       Indexes : System.Address)\n-      return    String\n    is\n-      type Natural_8 is range 0 .. 2 ** 7 - 1;\n-      type Index_Table is array (Natural) of Natural_8;\n-      type Index_Table_Ptr is access Index_Table;\n-\n-      function To_Index_Table_Ptr is\n-        new Ada.Unchecked_Conversion (System.Address, Index_Table_Ptr);\n-\n-      IndexesT : constant Index_Table_Ptr := To_Index_Table_Ptr (Indexes);\n-\n-      Start : constant Natural := Natural (IndexesT (Pos));\n-      Next  : constant Natural := Natural (IndexesT (Pos + 1));\n-\n-      subtype Result_Type is String (1 .. Next - Start);\n-      --  We need this result type to force the result to have the\n-      --  required lower bound of 1, rather than the slice bounds.\n-\n-   begin\n-      return Result_Type (Names (Start .. Next - 1));\n-   end Image_Enumeration_8;\n-\n-   --------------------------\n-   -- Image_Enumeration_16 --\n-   --------------------------\n+      pragma Assert (S'First = 1);\n \n-   function Image_Enumeration_16\n-     (Pos     : Natural;\n-      Names   : String;\n-      Indexes : System.Address)\n-      return    String\n-   is\n-      type Natural_16 is range 0 .. 2 ** 15 - 1;\n-      type Index_Table is array (Natural) of Natural_16;\n+      subtype Names_Index is\n+        Index_Type range Index_Type (Names'First)\n+                          .. Index_Type (Names'Last) + 1;\n+      subtype Index is Natural range Natural'First .. Names'Length;\n+      type Index_Table is array (Index) of Names_Index;\n       type Index_Table_Ptr is access Index_Table;\n \n       function To_Index_Table_Ptr is\n         new Ada.Unchecked_Conversion (System.Address, Index_Table_Ptr);\n \n       IndexesT : constant Index_Table_Ptr := To_Index_Table_Ptr (Indexes);\n \n-      Start : constant Natural := Natural (IndexesT (Pos));\n-      Next  : constant Natural := Natural (IndexesT (Pos + 1));\n-\n-      subtype Result_Type is String (1 .. Next - Start);\n-      --  We need this result type to force the result to have the\n-      --  required lower bound of 1, rather than the slice bounds.\n-\n-   begin\n-      return Result_Type (Names (Start .. Next - 1));\n-   end Image_Enumeration_16;\n-\n-   --------------------------\n-   -- Image_Enumeration_32 --\n-   --------------------------\n-\n-   function Image_Enumeration_32\n-     (Pos     : Natural;\n-      Names   : String;\n-      Indexes : System.Address)\n-      return    String\n-   is\n-      type Natural_32 is range 0 .. 2 ** 31 - 1;\n-      type Index_Table is array (Natural) of Natural_32;\n-      type Index_Table_Ptr is access Index_Table;\n-\n-      function To_Index_Table_Ptr is\n-        new Ada.Unchecked_Conversion (System.Address, Index_Table_Ptr);\n-\n-      IndexesT : constant Index_Table_Ptr := To_Index_Table_Ptr (Indexes);\n+      pragma Assert (Pos in IndexesT'Range);\n+      pragma Assert (Pos + 1 in IndexesT'Range);\n \n       Start : constant Natural := Natural (IndexesT (Pos));\n       Next  : constant Natural := Natural (IndexesT (Pos + 1));\n \n-      subtype Result_Type is String (1 .. Next - Start);\n-      --  We need this result type to force the result to have the\n-      --  required lower bound of 1, rather than the slice bounds.\n+      pragma Assert (Next - 1 >= Start);\n+      pragma Assert (Start >= Names'First);\n+      pragma Assert (Next - 1 <= Names'Last);\n \n+      pragma Assert (Next - Start <= S'Last);\n+      --  The caller should guarantee that S is large enough to contain the\n+      --  enumeration image.\n    begin\n-      return Result_Type (Names (Start .. Next - 1));\n-   end Image_Enumeration_32;\n+      S (1 .. Next - Start) := Names (Start .. Next - 1);\n+      P := Next - Start;\n+   end Image_Enumeration;\n \n-end System.Img_Enum;\n+end System.Image_N;", "previous_filename": "gcc/ada/libgnat/s-imgenu.adb"}, {"sha": "6598be90b8ab66c8b52a12b24c1b608d0ef060e0", "filename": "gcc/ada/libgnat/s-imagen.ads", "status": "renamed", "additions": 17, "deletions": 32, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fs-imagen.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fs-imagen.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imagen.ads?ref=c11207d345f8d678d440a3ff0f335b2ed25513e7", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT RUN-TIME COMPONENTS                         --\n --                                                                          --\n---                      S Y S T E M . I M G _ E N U M                       --\n+--                       S Y S T E M . I M A G E _ N                        --\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2000-2021, Free Software Foundation, Inc.         --\n+--             Copyright (C) 2021, Free Software Foundation, Inc.           --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,45 +34,30 @@\n --  package System (where it is too early to start building image tables).\n --  Special routines exist for the enumeration types in these packages.\n \n---  Note: this is an obsolete package, replaced by System.Img_Enum_New, which\n---  provides procedures instead of functions for these enumeration image calls.\n---  The reason we maintain this package is that when bootstrapping with old\n---  compilers, the old compiler will search for this unit, expecting to find\n---  these functions. The new compiler will search for procedures in the new\n---  version of the unit.\n+generic\n \n-pragma Compiler_Unit_Warning;\n+   type Index_Type is range <>;\n \n-package System.Img_Enum is\n+package System.Image_N is\n    pragma Pure;\n \n-   function Image_Enumeration_8\n+   procedure Image_Enumeration\n      (Pos     : Natural;\n+      S       : in out String;\n+      P       : out Natural;\n       Names   : String;\n-      Indexes : System.Address) return String;\n+      Indexes : System.Address);\n    --  Used to compute Enum'Image (Str) where Enum is some enumeration type\n-   --  other than those defined in package Standard. Names is a string with a\n-   --  lower bound of 1 containing the characters of all the enumeration\n-   --  literals concatenated together in sequence. Indexes is the address of an\n-   --  array of type array (0 .. N) of Natural_8, where N is the number of\n+   --  other than those defined in package Standard. Names is a string with\n+   --  a lower bound of 1 containing the characters of all the enumeration\n+   --  literals concatenated together in sequence. Indexes is the address of\n+   --  an array of type array (0 .. N) of Index_Type, where N is the number of\n    --  enumeration literals in the type. The Indexes values are the starting\n    --  subscript of each enumeration literal, indexed by Pos values, with an\n    --  extra entry at the end containing Names'Length + 1. The reason that\n    --  Indexes is passed by address is that the actual type is created on the\n-   --  fly by the expander. The value returned is the desired 'Image value.\n+   --  fly by the expander. The desired 'Image value is stored in S (1 .. P)\n+   --  and P is set on return. The caller guarantees that S is long enough to\n+   --  hold the result and that the lower bound is 1.\n \n-   function Image_Enumeration_16\n-     (Pos     : Natural;\n-      Names   : String;\n-      Indexes : System.Address) return String;\n-   --  Identical to Image_Enumeration_8 except that it handles types\n-   --  using array (0 .. Num) of Natural_16 for the Indexes table.\n-\n-   function Image_Enumeration_32\n-     (Pos     : Natural;\n-      Names   : String;\n-      Indexes : System.Address) return String;\n-   --  Identical to Image_Enumeration_8 except that it handles types\n-   --  using array (0 .. Num) of Natural_32 for the Indexes table.\n-\n-end System.Img_Enum;\n+end System.Image_N;", "previous_filename": "gcc/ada/libgnat/s-imgenu.ads"}, {"sha": "755549eff0673cc4252aa8509e1236bdaa3ed5ec", "filename": "gcc/ada/libgnat/s-imen16.ads", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fs-imen16.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fs-imen16.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imen16.ads?ref=c11207d345f8d678d440a3ff0f335b2ed25513e7", "patch": "@@ -0,0 +1,51 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                   S Y S T E M . I M G _ E N U M _ 1 6                    --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2021, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Instantiation of System.Image_N for enumeration types whose names table\n+--  has a length that fits in a 16-bit but not a 8-bit integer.\n+\n+with Interfaces;\n+with System.Image_N;\n+\n+package System.Img_Enum_16 is\n+   pragma Pure;\n+\n+   package Impl is new Image_N (Interfaces.Integer_16);\n+\n+   procedure Image_Enumeration_16\n+     (Pos     : Natural;\n+      S       : in out String;\n+      P       : out Natural;\n+      Names   : String;\n+      Indexes : System.Address)\n+     renames Impl.Image_Enumeration;\n+\n+end System.Img_Enum_16;"}, {"sha": "3cb88d8ea7e7d1793b4002037d4aca7196b451bd", "filename": "gcc/ada/libgnat/s-imen32.ads", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fs-imen32.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fs-imen32.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imen32.ads?ref=c11207d345f8d678d440a3ff0f335b2ed25513e7", "patch": "@@ -0,0 +1,51 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                   S Y S T E M . I M G _ E N U M _ 3 2                    --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2021, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Instantiation of System.Image_N for enumeration types whose names table\n+--  has a length that fits in a 32-bit but not a 16-bit integer.\n+\n+with Interfaces;\n+with System.Image_N;\n+\n+package System.Img_Enum_32 is\n+   pragma Pure;\n+\n+   package Impl is new Image_N (Interfaces.Integer_32);\n+\n+   procedure Image_Enumeration_32\n+     (Pos     : Natural;\n+      S       : in out String;\n+      P       : out Natural;\n+      Names   : String;\n+      Indexes : System.Address)\n+     renames Impl.Image_Enumeration;\n+\n+end System.Img_Enum_32;"}, {"sha": "eba31c2b09d5d770abd6f5939dc7696ca6bed356", "filename": "gcc/ada/libgnat/s-imenne.ads", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fs-imenne.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fs-imenne.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imenne.ads?ref=c11207d345f8d678d440a3ff0f335b2ed25513e7", "patch": "@@ -34,11 +34,11 @@\n --  package System (where it is too early to start building image tables).\n --  Special routines exist for the enumeration types in these packages.\n \n---  This is the new version of the package, for use by compilers built after\n---  Nov 21st, 2007, which provides procedures that avoid using the secondary\n---  stack. The original package System.Img_Enum is maintained in the sources\n---  for bootstrapping with older versions of the compiler which expect to find\n---  functions in this package.\n+--  Note: this is an obsolete package replaced by instantiations of the generic\n+--  package System.Image_N. The reason we maintain this package is that when\n+--  bootstrapping with an old compiler, the old compiler will search for this\n+--  unit, expecting to find these functions. The new compiler will search for\n+--  procedures in the instances of System.Image_N instead.\n \n pragma Compiler_Unit_Warning;\n "}, {"sha": "8c5a64d9d4d8c0de238769d4caf1a87761002308", "filename": "gcc/ada/libgnat/s-imenu8.ads", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fs-imenu8.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fs-imenu8.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imenu8.ads?ref=c11207d345f8d678d440a3ff0f335b2ed25513e7", "patch": "@@ -0,0 +1,51 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                    S Y S T E M . I M G _ E N U M _ 8                     --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2021, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Instantiation of System.Image_N for enumeration types whose names table\n+--  has a length that fits in a 8-bit integer.\n+\n+with Interfaces;\n+with System.Image_N;\n+\n+package System.Img_Enum_8 is\n+   pragma Pure;\n+\n+   package Impl is new Image_N (Interfaces.Integer_8);\n+\n+   procedure Image_Enumeration_8\n+     (Pos     : Natural;\n+      S       : in out String;\n+      P       : out Natural;\n+      Names   : String;\n+      Indexes : System.Address)\n+     renames Impl.Image_Enumeration;\n+\n+end System.Img_Enum_8;"}, {"sha": "218c1cbc891ea5973c42483732c47dd90adfe4b0", "filename": "gcc/ada/libgnat/s-pehage.adb", "status": "added", "additions": 2235, "deletions": 0, "changes": 2235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fs-pehage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fs-pehage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pehage.adb?ref=c11207d345f8d678d440a3ff0f335b2ed25513e7", "patch": "@@ -0,0 +1,2235 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--        S Y S T E M . P E R F E C T _ H A S H _ G E N E R A T O R S       --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                     Copyright (C) 2002-2021, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with GNAT.Heap_Sort_G;\n+with GNAT.Table;\n+\n+with System.OS_Lib; use System.OS_Lib;\n+\n+package body System.Perfect_Hash_Generators is\n+\n+   --  We are using the algorithm of J. Czech as described in Zbigniew J.\n+   --  Czech, George Havas, and Bohdan S. Majewski ``An Optimal Algorithm for\n+   --  Generating Minimal Perfect Hash Functions'', Information Processing\n+   --  Letters, 43(1992) pp.257-264, Oct.1992\n+\n+   --  This minimal perfect hash function generator is based on random graphs\n+   --  and produces a hash function of the form:\n+\n+   --             h (w) = (g (f1 (w)) + g (f2 (w))) mod m\n+\n+   --  where f1 and f2 are functions that map strings into integers, and g is\n+   --  a function that maps integers into [0, m-1]. h can be order preserving.\n+   --  For instance, let W = {w_0, ..., w_i, ..., w_m-1}, h can be defined\n+   --  such that h (w_i) = i.\n+\n+   --  This algorithm defines two possible constructions of f1 and f2. Method\n+   --  b) stores the hash function in less memory space at the expense of\n+   --  greater CPU time.\n+\n+   --  a) fk (w) = sum (for i in 1 .. length (w)) (Tk (i, w (i))) mod n\n+\n+   --     size (Tk) = max (for w in W) (length (w)) * size (used char set)\n+\n+   --  b) fk (w) = sum (for i in 1 .. length (w)) (Tk (i) * w (i)) mod n\n+\n+   --     size (Tk) = max (for w in W) (length (w)) but the table lookups are\n+   --     replaced by multiplications.\n+\n+   --  where Tk values are randomly generated. n is defined later on but the\n+   --  algorithm recommends to use a value a little bit greater than 2m. Note\n+   --  that for large values of m, the main memory space requirements comes\n+   --  from the memory space for storing function g (>= 2m entries).\n+\n+   --  Random graphs are frequently used to solve difficult problems that do\n+   --  not have polynomial solutions. This algorithm is based on a weighted\n+   --  undirected graph. It comprises two steps: mapping and assignment.\n+\n+   --  In the mapping step, a graph G = (V, E) is constructed, where = {0, 1,\n+   --  ..., n-1} and E = {(for w in W) (f1 (w), f2 (w))}. In order for the\n+   --  assignment step to be successful, G has to be acyclic. To have a high\n+   --  probability of generating an acyclic graph, n >= 2m. If it is not\n+   --  acyclic, Tk have to be regenerated.\n+\n+   --  In the assignment step, the algorithm builds function g. As G is\n+   --  acyclic, there is a vertex v1 with only one neighbor v2. Let w_i be\n+   --  the word such that v1 = f1 (w_i) and v2 = f2 (w_i). Let g (v1) = 0 by\n+   --  construction and g (v2) = (i - g (v1)) mod n (or h (i) - g (v1) mod n).\n+   --  If word w_j is such that v2 = f1 (w_j) and v3 = f2 (w_j), g (v3) = (j -\n+   --  g (v2)) mod (or to be general, (h (j) - g (v2)) mod n). If w_i has no\n+   --  neighbor, then another vertex is selected. The algorithm traverses G to\n+   --  assign values to all the vertices. It cannot assign a value to an\n+   --  already assigned vertex as G is acyclic.\n+\n+   subtype Word_Id   is Integer;\n+   subtype Key_Id    is Integer;\n+   subtype Vertex_Id is Integer;\n+   subtype Edge_Id   is Integer;\n+   subtype Table_Id  is Integer;\n+\n+   No_Vertex : constant Vertex_Id := -1;\n+   No_Edge   : constant Edge_Id   := -1;\n+   No_Table  : constant Table_Id  := -1;\n+\n+   type Word_Type is new String_Access;\n+   procedure Free_Word (W : in out Word_Type) renames Free;\n+   function New_Word (S : String) return Word_Type;\n+\n+   procedure Resize_Word (W : in out Word_Type; Len : Natural);\n+   --  Resize string W to have a length Len\n+\n+   type Key_Type is record\n+      Edge : Edge_Id;\n+   end record;\n+   --  A key corresponds to an edge in the algorithm graph\n+\n+   type Vertex_Type is record\n+      First : Edge_Id;\n+      Last  : Edge_Id;\n+   end record;\n+   --  A vertex can be involved in several edges. First and Last are the bounds\n+   --  of an array of edges stored in a global edge table.\n+\n+   type Edge_Type is record\n+      X   : Vertex_Id;\n+      Y   : Vertex_Id;\n+      Key : Key_Id;\n+   end record;\n+   --  An edge is a peer of vertices. In the algorithm, a key is associated to\n+   --  an edge.\n+\n+   package WT is new GNAT.Table (Word_Type, Word_Id, 0, 32, 32);\n+   package IT is new GNAT.Table (Integer, Integer, 0, 32, 32);\n+   --  The two main tables. WT is used to store the words in their initial\n+   --  version and in their reduced version (that is words reduced to their\n+   --  significant characters). As an instance of GNAT.Table, WT does not\n+   --  initialize string pointers to null. This initialization has to be done\n+   --  manually when the table is allocated. IT is used to store several\n+   --  tables of components containing only integers.\n+\n+   function Image (Int : Integer; W : Natural := 0) return String;\n+   function Image (Str : String;  W : Natural := 0) return String;\n+   --  Return a string which includes string Str or integer Int preceded by\n+   --  leading spaces if required by width W.\n+\n+   function Trim_Trailing_Nuls (Str : String) return String;\n+   --  Return Str with trailing NUL characters removed\n+\n+   Output : File_Descriptor renames System.OS_Lib.Standout;\n+   --  Shortcuts\n+\n+   EOL : constant Character := ASCII.LF;\n+\n+   Max  : constant := 78;\n+   Last : Natural  := 0;\n+   Line : String (1 .. Max);\n+   --  Use this line to provide buffered IO\n+\n+   procedure Add (C : Character);\n+   procedure Add (S : String);\n+   --  Add a character or a string in Line and update Last\n+\n+   procedure Put\n+     (F  : File_Descriptor;\n+      S  : String;\n+      F1 : Natural;\n+      L1 : Natural;\n+      C1 : Natural;\n+      F2 : Natural;\n+      L2 : Natural;\n+      C2 : Natural);\n+   --  Write string S into file F as a element of an array of one or two\n+   --  dimensions. Fk (resp. Lk and Ck) indicates the first (resp last and\n+   --  current) index in the k-th dimension. If F1 = L1 the array is considered\n+   --  as a one dimension array. This dimension is described by F2 and L2. This\n+   --  routine takes care of all the parenthesis, spaces and commas needed to\n+   --  format correctly the array. Moreover, the array is well indented and is\n+   --  wrapped to fit in a 80 col line. When the line is full, the routine\n+   --  writes it into file F. When the array is completed, the routine adds\n+   --  semi-colon and writes the line into file F.\n+\n+   procedure New_Line (File : File_Descriptor);\n+   --  Simulate Ada.Text_IO.New_Line with GNAT.OS_Lib\n+\n+   procedure Put (File : File_Descriptor; Str : String);\n+   --  Simulate Ada.Text_IO.Put with GNAT.OS_Lib\n+\n+   procedure Put_Used_Char_Set (File : File_Descriptor; Title : String);\n+   --  Output a title and a used character set\n+\n+   procedure Put_Int_Vector\n+     (File   : File_Descriptor;\n+      Title  : String;\n+      Vector : Integer;\n+      Length : Natural);\n+   --  Output a title and a vector\n+\n+   procedure Put_Int_Matrix\n+     (File  : File_Descriptor;\n+      Title : String;\n+      Table : Table_Id;\n+      Len_1 : Natural;\n+      Len_2 : Natural);\n+   --  Output a title and a matrix. When the matrix has only one non-empty\n+   --  dimension (Len_2 = 0), output a vector.\n+\n+   procedure Put_Edges (File : File_Descriptor; Title : String);\n+   --  Output a title and an edge table\n+\n+   procedure Put_Initial_Keys (File : File_Descriptor; Title : String);\n+   --  Output a title and a key table\n+\n+   procedure Put_Reduced_Keys (File : File_Descriptor; Title : String);\n+   --  Output a title and a key table\n+\n+   procedure Put_Vertex_Table (File : File_Descriptor; Title : String);\n+   --  Output a title and a vertex table\n+\n+   ----------------------------------\n+   -- Character Position Selection --\n+   ----------------------------------\n+\n+   --  We reduce the maximum key size by selecting representative positions\n+   --  in these keys. We build a matrix with one word per line. We fill the\n+   --  remaining space of a line with ASCII.NUL. The heuristic selects the\n+   --  position that induces the minimum number of collisions. If there are\n+   --  collisions, select another position on the reduced key set responsible\n+   --  of the collisions. Apply the heuristic until there is no more collision.\n+\n+   procedure Apply_Position_Selection;\n+   --  Apply Position selection and build the reduced key table\n+\n+   procedure Parse_Position_Selection (Argument : String);\n+   --  Parse Argument and compute the position set. Argument is list of\n+   --  substrings separated by commas. Each substring represents a position\n+   --  or a range of positions (like x-y).\n+\n+   procedure Select_Character_Set;\n+   --  Define an optimized used character set like Character'Pos in order not\n+   --  to allocate tables of 256 entries.\n+\n+   procedure Select_Char_Position;\n+   --  Find a min char position set in order to reduce the max key length. The\n+   --  heuristic selects the position that induces the minimum number of\n+   --  collisions. If there are collisions, select another position on the\n+   --  reduced key set responsible of the collisions. Apply the heuristic until\n+   --  there is no collision.\n+\n+   -----------------------------\n+   -- Random Graph Generation --\n+   -----------------------------\n+\n+   procedure Random (Seed : in out Natural);\n+   --  Simulate Ada.Discrete_Numerics.Random\n+\n+   procedure Generate_Mapping_Table\n+     (Tab  : Table_Id;\n+      L1   : Natural;\n+      L2   : Natural;\n+      Seed : in out Natural);\n+   --  Random generation of the tables below. T is already allocated\n+\n+   procedure Generate_Mapping_Tables\n+     (Opt  : Optimization;\n+      Seed : in out Natural);\n+   --  Generate the mapping tables T1 and T2. They are used to define fk (w) =\n+   --  sum (for i in 1 .. length (w)) (Tk (i, w (i))) mod n. Keys, NK and Chars\n+   --  are used to compute the matrix size.\n+\n+   ---------------------------\n+   -- Algorithm Computation --\n+   ---------------------------\n+\n+   procedure Compute_Edges_And_Vertices (Opt : Optimization);\n+   --  Compute the edge and vertex tables. These are empty when a self loop is\n+   --  detected (f1 (w) = f2 (w)). The edge table is sorted by X value and then\n+   --  Y value. Keys is the key table and NK the number of keys. Chars is the\n+   --  set of characters really used in Keys. NV is the number of vertices\n+   --  recommended by the algorithm. T1 and T2 are the mapping tables needed to\n+   --  compute f1 (w) and f2 (w).\n+\n+   function Acyclic return Boolean;\n+   --  Return True when the graph is acyclic. Vertices is the current vertex\n+   --  table and Edges the current edge table.\n+\n+   procedure Assign_Values_To_Vertices;\n+   --  Execute the assignment step of the algorithm. Keys is the current key\n+   --  table. Vertices and Edges represent the random graph. G is the result of\n+   --  the assignment step such that:\n+   --    h (w) = (g (f1 (w)) + g (f2 (w))) mod m\n+\n+   function Sum\n+     (Word  : Word_Type;\n+      Table : Table_Id;\n+      Opt   : Optimization) return Natural;\n+   --  For an optimization of CPU_Time return\n+   --    fk (w) = sum (for i in 1 .. length (w)) (Tk (i, w (i))) mod n\n+   --  For an optimization of Memory_Space return\n+   --    fk (w) = sum (for i in 1 .. length (w)) (Tk (i) * w (i)) mod n\n+   --  Here NV = n\n+\n+   -------------------------------\n+   -- Internal Table Management --\n+   -------------------------------\n+\n+   function Allocate (N : Natural; S : Natural := 1) return Table_Id;\n+   --  Allocate N * S ints from IT table\n+\n+   ----------\n+   -- Keys --\n+   ----------\n+\n+   Keys : Table_Id := No_Table;\n+   NK   : Natural  := 0;\n+   --  NK : Number of Keys\n+\n+   function Initial (K : Key_Id) return Word_Id;\n+   pragma Inline (Initial);\n+\n+   function Reduced (K : Key_Id) return Word_Id;\n+   pragma Inline (Reduced);\n+\n+   function  Get_Key (N : Key_Id) return Key_Type;\n+   procedure Set_Key (N : Key_Id; Item : Key_Type);\n+   --  Get or Set Nth element of Keys table\n+\n+   ------------------\n+   -- Char_Pos_Set --\n+   ------------------\n+\n+   Char_Pos_Set     : Table_Id := No_Table;\n+   Char_Pos_Set_Len : Natural;\n+   --  Character Selected Position Set\n+\n+   function  Get_Char_Pos (P : Natural) return Natural;\n+   procedure Set_Char_Pos (P : Natural; Item : Natural);\n+   --  Get or Set the string position of the Pth selected character\n+\n+   -------------------\n+   -- Used_Char_Set --\n+   -------------------\n+\n+   Used_Char_Set     : Table_Id := No_Table;\n+   Used_Char_Set_Len : Natural;\n+   --  Used Character Set : Define a new character mapping. When all the\n+   --  characters are not present in the keys, in order to reduce the size\n+   --  of some tables, we redefine the character mapping.\n+\n+   function  Get_Used_Char (C : Character) return Natural;\n+   procedure Set_Used_Char (C : Character; Item : Natural);\n+\n+   ------------\n+   -- Tables --\n+   ------------\n+\n+   T1     : Table_Id := No_Table;\n+   T2     : Table_Id := No_Table;\n+   T1_Len : Natural;\n+   T2_Len : Natural;\n+   --  T1  : Values table to compute F1\n+   --  T2  : Values table to compute F2\n+\n+   function  Get_Table (T : Integer; X, Y : Natural) return Natural;\n+   procedure Set_Table (T : Integer; X, Y : Natural; Item : Natural);\n+\n+   -----------\n+   -- Graph --\n+   -----------\n+\n+   G     : Table_Id := No_Table;\n+   G_Len : Natural;\n+   --  Values table to compute G\n+\n+   NT : Natural;\n+   --  Number of tries running the algorithm before raising an error\n+\n+   function  Get_Graph (N : Natural) return Integer;\n+   procedure Set_Graph (N : Natural; Item : Integer);\n+   --  Get or Set Nth element of graph\n+\n+   -----------\n+   -- Edges --\n+   -----------\n+\n+   Edge_Size : constant := 3;\n+   Edges     : Table_Id := No_Table;\n+   Edges_Len : Natural;\n+   --  Edges  : Edge table of the random graph G\n+\n+   function  Get_Edges (F : Natural) return Edge_Type;\n+   procedure Set_Edges (F : Natural; Item : Edge_Type);\n+\n+   --------------\n+   -- Vertices --\n+   --------------\n+\n+   Vertex_Size : constant := 2;\n+\n+   Vertices : Table_Id := No_Table;\n+   --  Vertex table of the random graph G\n+\n+   NV : Natural;\n+   --  Number of Vertices\n+\n+   function  Get_Vertices (F : Natural) return Vertex_Type;\n+   procedure Set_Vertices (F : Natural; Item : Vertex_Type);\n+   --  Comments needed ???\n+\n+   Opt : Optimization;\n+   --  Optimization mode (memory vs CPU)\n+\n+   Max_Key_Len : Natural := 0;\n+   Min_Key_Len : Natural := 0;\n+   --  Maximum and minimum of all the word length\n+\n+   S : Natural;\n+   --  Seed\n+\n+   function Type_Size (L : Natural) return Natural;\n+   --  Given the last L of an unsigned integer type T, return its size\n+\n+   -------------\n+   -- Acyclic --\n+   -------------\n+\n+   function Acyclic return Boolean is\n+      Marks : array (0 .. NV - 1) of Vertex_Id := (others => No_Vertex);\n+\n+      function Traverse (Edge : Edge_Id; Mark : Vertex_Id) return Boolean;\n+      --  Propagate Mark from X to Y. X is already marked. Mark Y and propagate\n+      --  it to the edges of Y except the one representing the same key. Return\n+      --  False when Y is marked with Mark.\n+\n+      --------------\n+      -- Traverse --\n+      --------------\n+\n+      function Traverse (Edge : Edge_Id; Mark : Vertex_Id) return Boolean is\n+         E : constant Edge_Type := Get_Edges (Edge);\n+         K : constant Key_Id    := E.Key;\n+         Y : constant Vertex_Id := E.Y;\n+         M : constant Vertex_Id := Marks (E.Y);\n+         V : Vertex_Type;\n+\n+      begin\n+         if M = Mark then\n+            return False;\n+\n+         elsif M = No_Vertex then\n+            Marks (Y) := Mark;\n+            V := Get_Vertices (Y);\n+\n+            for J in V.First .. V.Last loop\n+\n+               --  Do not propagate to the edge representing the same key\n+\n+               if Get_Edges (J).Key /= K\n+                 and then not Traverse (J, Mark)\n+               then\n+                  return False;\n+               end if;\n+            end loop;\n+         end if;\n+\n+         return True;\n+      end Traverse;\n+\n+      Edge  : Edge_Type;\n+\n+   --  Start of processing for Acyclic\n+\n+   begin\n+      --  Edges valid range is\n+\n+      for J in 1 .. Edges_Len - 1 loop\n+\n+         Edge := Get_Edges (J);\n+\n+         --  Mark X of E when it has not been already done\n+\n+         if Marks (Edge.X) = No_Vertex then\n+            Marks (Edge.X) := Edge.X;\n+         end if;\n+\n+         --  Traverse E when this has not already been done\n+\n+         if Marks (Edge.Y) = No_Vertex\n+           and then not Traverse (J, Edge.X)\n+         then\n+            return False;\n+         end if;\n+      end loop;\n+\n+      return True;\n+   end Acyclic;\n+\n+   ---------\n+   -- Add --\n+   ---------\n+\n+   procedure Add (C : Character) is\n+      pragma Assert (C /= ASCII.NUL);\n+   begin\n+      Line (Last + 1) := C;\n+      Last := Last + 1;\n+   end Add;\n+\n+   ---------\n+   -- Add --\n+   ---------\n+\n+   procedure Add (S : String) is\n+      Len : constant Natural := S'Length;\n+   begin\n+      for J in S'Range loop\n+         pragma Assert (S (J) /= ASCII.NUL);\n+         null;\n+      end loop;\n+\n+      Line (Last + 1 .. Last + Len) := S;\n+      Last := Last + Len;\n+   end Add;\n+\n+   --------------\n+   -- Allocate --\n+   --------------\n+\n+   function Allocate (N : Natural; S : Natural := 1) return Table_Id is\n+      L : constant Integer := IT.Last;\n+   begin\n+      IT.Set_Last (L + N * S);\n+\n+      --  Initialize, so debugging printouts don't trip over uninitialized\n+      --  components.\n+\n+      for J in L + 1 .. IT.Last loop\n+         IT.Table (J) := -1;\n+      end loop;\n+\n+      return L + 1;\n+   end Allocate;\n+\n+   ------------------------------\n+   -- Apply_Position_Selection --\n+   ------------------------------\n+\n+   procedure Apply_Position_Selection is\n+   begin\n+      for J in 0 .. NK - 1 loop\n+         declare\n+            IW : constant String := WT.Table (Initial (J)).all;\n+            RW : String (1 .. IW'Length) := (others => ASCII.NUL);\n+            N  : Natural := IW'First - 1;\n+\n+         begin\n+            --  Select the characters of Word included in the position\n+            --  selection.\n+\n+            for C in 0 .. Char_Pos_Set_Len - 1 loop\n+               exit when IW (Get_Char_Pos (C)) = ASCII.NUL;\n+               N := N + 1;\n+               RW (N) := IW (Get_Char_Pos (C));\n+            end loop;\n+\n+            --  Build the new table with the reduced word. Be careful\n+            --  to deallocate the old version to avoid memory leaks.\n+\n+            Free_Word (WT.Table (Reduced (J)));\n+            WT.Table (Reduced (J)) := New_Word (RW);\n+            Set_Key (J, (Edge => No_Edge));\n+         end;\n+      end loop;\n+   end Apply_Position_Selection;\n+\n+   -------------------------------\n+   -- Assign_Values_To_Vertices --\n+   -------------------------------\n+\n+   procedure Assign_Values_To_Vertices is\n+      X : Vertex_Id;\n+\n+      procedure Assign (X : Vertex_Id);\n+      --  Execute assignment on X's neighbors except the vertex that we are\n+      --  coming from which is already assigned.\n+\n+      ------------\n+      -- Assign --\n+      ------------\n+\n+      procedure Assign (X : Vertex_Id) is\n+         E : Edge_Type;\n+         V : constant Vertex_Type := Get_Vertices (X);\n+\n+      begin\n+         for J in V.First .. V.Last loop\n+            E := Get_Edges (J);\n+\n+            if Get_Graph (E.Y) = -1 then\n+               pragma Assert (NK /= 0);\n+               Set_Graph (E.Y, (E.Key - Get_Graph (X)) mod NK);\n+               Assign (E.Y);\n+            end if;\n+         end loop;\n+      end Assign;\n+\n+   --  Start of processing for Assign_Values_To_Vertices\n+\n+   begin\n+      --  Value -1 denotes an uninitialized value as it is supposed to\n+      --  be in the range 0 .. NK.\n+\n+      if G = No_Table then\n+         G_Len := NV;\n+         G := Allocate (G_Len, 1);\n+      end if;\n+\n+      for J in 0 .. G_Len - 1 loop\n+         Set_Graph (J, -1);\n+      end loop;\n+\n+      for K in 0 .. NK - 1 loop\n+         X := Get_Edges (Get_Key (K).Edge).X;\n+\n+         if Get_Graph (X) = -1 then\n+            Set_Graph (X, 0);\n+            Assign (X);\n+         end if;\n+      end loop;\n+\n+      for J in 0 .. G_Len - 1 loop\n+         if Get_Graph (J) = -1 then\n+            Set_Graph (J, 0);\n+         end if;\n+      end loop;\n+\n+      if Verbose then\n+         Put_Int_Vector (Output, \"Assign Values To Vertices\", G, G_Len);\n+      end if;\n+   end Assign_Values_To_Vertices;\n+\n+   -------------\n+   -- Compute --\n+   -------------\n+\n+   procedure Compute (Position : String) is\n+      Success : Boolean := False;\n+\n+   begin\n+      if NK = 0 then\n+         raise Program_Error with \"keywords set cannot be empty\";\n+      end if;\n+\n+      if Verbose then\n+         Put_Initial_Keys (Output, \"Initial Key Table\");\n+      end if;\n+\n+      if Position'Length /= 0 then\n+         Parse_Position_Selection (Position);\n+      else\n+         Select_Char_Position;\n+      end if;\n+\n+      if Verbose then\n+         Put_Int_Vector\n+           (Output, \"Char Position Set\", Char_Pos_Set, Char_Pos_Set_Len);\n+      end if;\n+\n+      Apply_Position_Selection;\n+\n+      if Verbose then\n+         Put_Reduced_Keys (Output, \"Reduced Keys Table\");\n+      end if;\n+\n+      Select_Character_Set;\n+\n+      if Verbose then\n+         Put_Used_Char_Set (Output, \"Character Position Table\");\n+      end if;\n+\n+      --  Perform Czech's algorithm\n+\n+      for J in 1 .. NT loop\n+         Generate_Mapping_Tables (Opt, S);\n+         Compute_Edges_And_Vertices (Opt);\n+\n+         --  When graph is not empty (no self-loop from previous operation) and\n+         --  not acyclic.\n+\n+         if 0 < Edges_Len and then Acyclic then\n+            Success := True;\n+            exit;\n+         end if;\n+      end loop;\n+\n+      if not Success then\n+         raise Too_Many_Tries;\n+      end if;\n+\n+      Assign_Values_To_Vertices;\n+   end Compute;\n+\n+   --------------------------------\n+   -- Compute_Edges_And_Vertices --\n+   --------------------------------\n+\n+   procedure Compute_Edges_And_Vertices (Opt : Optimization) is\n+      X           : Natural;\n+      Y           : Natural;\n+      Key         : Key_Type;\n+      Edge        : Edge_Type;\n+      Vertex      : Vertex_Type;\n+      Not_Acyclic : Boolean := False;\n+\n+      procedure Move (From : Natural; To : Natural);\n+      function Lt (L, R : Natural) return Boolean;\n+      --  Subprograms needed for GNAT.Heap_Sort_G\n+\n+      --------\n+      -- Lt --\n+      --------\n+\n+      function Lt (L, R : Natural) return Boolean is\n+         EL : constant Edge_Type := Get_Edges (L);\n+         ER : constant Edge_Type := Get_Edges (R);\n+      begin\n+         return EL.X < ER.X or else (EL.X = ER.X and then EL.Y < ER.Y);\n+      end Lt;\n+\n+      ----------\n+      -- Move --\n+      ----------\n+\n+      procedure Move (From : Natural; To : Natural) is\n+      begin\n+         Set_Edges (To, Get_Edges (From));\n+      end Move;\n+\n+      package Sorting is new GNAT.Heap_Sort_G (Move, Lt);\n+\n+   --  Start of processing for Compute_Edges_And_Vertices\n+\n+   begin\n+      --  We store edges from 1 to 2 * NK and leave zero alone in order to use\n+      --  GNAT.Heap_Sort_G.\n+\n+      Edges_Len := 2 * NK + 1;\n+\n+      if Edges = No_Table then\n+         Edges := Allocate (Edges_Len, Edge_Size);\n+      end if;\n+\n+      if Vertices = No_Table then\n+         Vertices := Allocate (NV, Vertex_Size);\n+      end if;\n+\n+      for J in 0 .. NV - 1 loop\n+         Set_Vertices (J, (No_Vertex, No_Vertex - 1));\n+      end loop;\n+\n+      --  For each w, X = f1 (w) and Y = f2 (w)\n+\n+      for J in 0 .. NK - 1 loop\n+         Key := Get_Key (J);\n+         Key.Edge := No_Edge;\n+         Set_Key (J, Key);\n+\n+         X := Sum (WT.Table (Reduced (J)), T1, Opt);\n+         Y := Sum (WT.Table (Reduced (J)), T2, Opt);\n+\n+         --  Discard T1 and T2 as soon as we discover a self loop\n+\n+         if X = Y then\n+            Not_Acyclic := True;\n+            exit;\n+         end if;\n+\n+         --  We store (X, Y) and (Y, X) to ease assignment step\n+\n+         Set_Edges (2 * J + 1, (X, Y, J));\n+         Set_Edges (2 * J + 2, (Y, X, J));\n+      end loop;\n+\n+      --  Return an empty graph when self loop detected\n+\n+      if Not_Acyclic then\n+         Edges_Len := 0;\n+\n+      else\n+         if Verbose then\n+            Put_Edges      (Output, \"Unsorted Edge Table\");\n+            Put_Int_Matrix (Output, \"Function Table 1\", T1,\n+                            T1_Len, T2_Len);\n+            Put_Int_Matrix (Output, \"Function Table 2\", T2,\n+                            T1_Len, T2_Len);\n+         end if;\n+\n+         --  Enforce consistency between edges and keys. Construct Vertices and\n+         --  compute the list of neighbors of a vertex First .. Last as Edges\n+         --  is sorted by X and then Y. To compute the neighbor list, sort the\n+         --  edges.\n+\n+         Sorting.Sort (Edges_Len - 1);\n+\n+         if Verbose then\n+            Put_Edges      (Output, \"Sorted Edge Table\");\n+            Put_Int_Matrix (Output, \"Function Table 1\", T1,\n+                            T1_Len, T2_Len);\n+            Put_Int_Matrix (Output, \"Function Table 2\", T2,\n+                            T1_Len, T2_Len);\n+         end if;\n+\n+         --  Edges valid range is 1 .. 2 * NK\n+\n+         for E in 1 .. Edges_Len - 1 loop\n+            Edge := Get_Edges (E);\n+            Key  := Get_Key (Edge.Key);\n+\n+            if Key.Edge = No_Edge then\n+               Key.Edge := E;\n+               Set_Key (Edge.Key, Key);\n+            end if;\n+\n+            Vertex := Get_Vertices (Edge.X);\n+\n+            if Vertex.First = No_Edge then\n+               Vertex.First := E;\n+            end if;\n+\n+            Vertex.Last := E;\n+            Set_Vertices (Edge.X, Vertex);\n+         end loop;\n+\n+         if Verbose then\n+            Put_Reduced_Keys (Output, \"Key Table\");\n+            Put_Edges        (Output, \"Edge Table\");\n+            Put_Vertex_Table (Output, \"Vertex Table\");\n+         end if;\n+      end if;\n+   end Compute_Edges_And_Vertices;\n+\n+   ------------\n+   -- Define --\n+   ------------\n+\n+   procedure Define\n+     (Name      : Table_Name;\n+      Item_Size : out Natural;\n+      Length_1  : out Natural;\n+      Length_2  : out Natural)\n+   is\n+   begin\n+      case Name is\n+         when Character_Position =>\n+            Item_Size := 31;\n+            Length_1  := Char_Pos_Set_Len;\n+            Length_2  := 0;\n+\n+         when Used_Character_Set =>\n+            Item_Size := 8;\n+            Length_1  := 256;\n+            Length_2  := 0;\n+\n+         when Function_Table_1\n+            | Function_Table_2\n+         =>\n+            Item_Size := Type_Size (NV);\n+            Length_1  := T1_Len;\n+            Length_2  := T2_Len;\n+\n+         when Graph_Table =>\n+            Item_Size := Type_Size (NK);\n+            Length_1  := NV;\n+            Length_2  := 0;\n+      end case;\n+   end Define;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize is\n+   begin\n+      if Verbose then\n+         Put (Output, \"Finalize\");\n+         New_Line (Output);\n+      end if;\n+\n+      --  Deallocate all the WT components (both initial and reduced ones) to\n+      --  avoid memory leaks.\n+\n+      for W in 0 .. WT.Last loop\n+\n+         --  Note: WT.Table (NK) is a temporary variable, do not free it since\n+         --  this would cause a double free.\n+\n+         if W /= NK then\n+            Free_Word (WT.Table (W));\n+         end if;\n+      end loop;\n+\n+      WT.Release;\n+      IT.Release;\n+\n+      --  Reset all variables for next usage\n+\n+      Keys := No_Table;\n+\n+      Char_Pos_Set     := No_Table;\n+      Char_Pos_Set_Len := 0;\n+\n+      Used_Char_Set     := No_Table;\n+      Used_Char_Set_Len := 0;\n+\n+      T1 := No_Table;\n+      T2 := No_Table;\n+\n+      T1_Len := 0;\n+      T2_Len := 0;\n+\n+      G     := No_Table;\n+      G_Len := 0;\n+\n+      Edges     := No_Table;\n+      Edges_Len := 0;\n+\n+      Vertices := No_Table;\n+      NV       := 0;\n+\n+      NK := 0;\n+      Max_Key_Len := 0;\n+      Min_Key_Len := 0;\n+   end Finalize;\n+\n+   ----------------------------\n+   -- Generate_Mapping_Table --\n+   ----------------------------\n+\n+   procedure Generate_Mapping_Table\n+     (Tab  : Integer;\n+      L1   : Natural;\n+      L2   : Natural;\n+      Seed : in out Natural)\n+   is\n+   begin\n+      for J in 0 .. L1 - 1 loop\n+         for K in 0 .. L2 - 1 loop\n+            Random (Seed);\n+            Set_Table (Tab, J, K, Seed mod NV);\n+         end loop;\n+      end loop;\n+   end Generate_Mapping_Table;\n+\n+   -----------------------------\n+   -- Generate_Mapping_Tables --\n+   -----------------------------\n+\n+   procedure Generate_Mapping_Tables\n+     (Opt  : Optimization;\n+      Seed : in out Natural)\n+   is\n+   begin\n+      --  If T1 and T2 are already allocated no need to do it twice. Reuse them\n+      --  as their size has not changed.\n+\n+      if T1 = No_Table and then T2 = No_Table then\n+         declare\n+            Used_Char_Last : Natural := 0;\n+            Used_Char      : Natural;\n+\n+         begin\n+            if Opt = CPU_Time then\n+               for P in reverse Character'Range loop\n+                  Used_Char := Get_Used_Char (P);\n+                  if Used_Char /= 0 then\n+                     Used_Char_Last := Used_Char;\n+                     exit;\n+                  end if;\n+               end loop;\n+            end if;\n+\n+            T1_Len := Char_Pos_Set_Len;\n+            T2_Len := Used_Char_Last + 1;\n+            T1 := Allocate (T1_Len * T2_Len);\n+            T2 := Allocate (T1_Len * T2_Len);\n+         end;\n+      end if;\n+\n+      Generate_Mapping_Table (T1, T1_Len, T2_Len, Seed);\n+      Generate_Mapping_Table (T2, T1_Len, T2_Len, Seed);\n+\n+      if Verbose then\n+         Put_Used_Char_Set (Output, \"Used Character Set\");\n+         Put_Int_Matrix (Output, \"Function Table 1\", T1,\n+                        T1_Len, T2_Len);\n+         Put_Int_Matrix (Output, \"Function Table 2\", T2,\n+                        T1_Len, T2_Len);\n+      end if;\n+   end Generate_Mapping_Tables;\n+\n+   ------------------\n+   -- Get_Char_Pos --\n+   ------------------\n+\n+   function Get_Char_Pos (P : Natural) return Natural is\n+      N : constant Natural := Char_Pos_Set + P;\n+   begin\n+      return IT.Table (N);\n+   end Get_Char_Pos;\n+\n+   ---------------\n+   -- Get_Edges --\n+   ---------------\n+\n+   function Get_Edges (F : Natural) return Edge_Type is\n+      N : constant Natural := Edges + (F * Edge_Size);\n+      E : Edge_Type;\n+   begin\n+      E.X   := IT.Table (N);\n+      E.Y   := IT.Table (N + 1);\n+      E.Key := IT.Table (N + 2);\n+      return E;\n+   end Get_Edges;\n+\n+   ---------------\n+   -- Get_Graph --\n+   ---------------\n+\n+   function Get_Graph (N : Natural) return Integer is\n+   begin\n+      return IT.Table (G + N);\n+   end Get_Graph;\n+\n+   -------------\n+   -- Get_Key --\n+   -------------\n+\n+   function Get_Key (N : Key_Id) return Key_Type is\n+      K : Key_Type;\n+   begin\n+      K.Edge := IT.Table (Keys + N);\n+      return K;\n+   end Get_Key;\n+\n+   ---------------\n+   -- Get_Table --\n+   ---------------\n+\n+   function Get_Table (T : Integer; X, Y : Natural) return Natural is\n+      N : constant Natural := T + (Y * T1_Len) + X;\n+   begin\n+      return IT.Table (N);\n+   end Get_Table;\n+\n+   -------------------\n+   -- Get_Used_Char --\n+   -------------------\n+\n+   function Get_Used_Char (C : Character) return Natural is\n+      N : constant Natural := Used_Char_Set + Character'Pos (C);\n+   begin\n+      return IT.Table (N);\n+   end Get_Used_Char;\n+\n+   ------------------\n+   -- Get_Vertices --\n+   ------------------\n+\n+   function Get_Vertices (F : Natural) return Vertex_Type is\n+      N : constant Natural := Vertices + (F * Vertex_Size);\n+      V : Vertex_Type;\n+   begin\n+      V.First := IT.Table (N);\n+      V.Last  := IT.Table (N + 1);\n+      return V;\n+   end Get_Vertices;\n+\n+   -----------\n+   -- Image --\n+   -----------\n+\n+   function Image (Int : Integer; W : Natural := 0) return String is\n+      B : String (1 .. 32);\n+      L : Natural := 0;\n+\n+      procedure Img (V : Natural);\n+      --  Compute image of V into B, starting at B (L), incrementing L\n+\n+      ---------\n+      -- Img --\n+      ---------\n+\n+      procedure Img (V : Natural) is\n+      begin\n+         if V > 9 then\n+            Img (V / 10);\n+         end if;\n+\n+         L := L + 1;\n+         B (L) := Character'Val ((V mod 10) + Character'Pos ('0'));\n+      end Img;\n+\n+   --  Start of processing for Image\n+\n+   begin\n+      if Int < 0 then\n+         L := L + 1;\n+         B (L) := '-';\n+         Img (-Int);\n+      else\n+         Img (Int);\n+      end if;\n+\n+      return Image (B (1 .. L), W);\n+   end Image;\n+\n+   -----------\n+   -- Image --\n+   -----------\n+\n+   function Image (Str : String; W : Natural := 0) return String is\n+      Len : constant Natural := Str'Length;\n+      Max : Natural := Len;\n+\n+   begin\n+      if Max < W then\n+         Max := W;\n+      end if;\n+\n+      declare\n+         Buf : String (1 .. Max) := (1 .. Max => ' ');\n+\n+      begin\n+         for J in 0 .. Len - 1 loop\n+            Buf (Max - Len + 1 + J) := Str (Str'First + J);\n+         end loop;\n+\n+         return Buf;\n+      end;\n+   end Image;\n+\n+   -------------\n+   -- Initial --\n+   -------------\n+\n+   function Initial (K : Key_Id) return Word_Id is\n+   begin\n+      return K;\n+   end Initial;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize\n+     (Seed  : Natural;\n+      V     : Positive;\n+      Optim : Optimization;\n+      Tries : Positive)\n+   is\n+   begin\n+      if Verbose then\n+         Put (Output, \"Initialize\");\n+         New_Line (Output);\n+      end if;\n+\n+      --  Deallocate the part of the table concerning the reduced words.\n+      --  Initial words are already present in the table. We may have reduced\n+      --  words already there because a previous computation failed. We are\n+      --  currently retrying and the reduced words have to be deallocated.\n+\n+      for W in Reduced (0) .. WT.Last loop\n+         Free_Word (WT.Table (W));\n+      end loop;\n+\n+      IT.Init;\n+\n+      --  Initialize of computation variables\n+\n+      Keys := No_Table;\n+\n+      Char_Pos_Set     := No_Table;\n+      Char_Pos_Set_Len := 0;\n+\n+      Used_Char_Set     := No_Table;\n+      Used_Char_Set_Len := 0;\n+\n+      T1 := No_Table;\n+      T2 := No_Table;\n+\n+      T1_Len := 0;\n+      T2_Len := 0;\n+\n+      G     := No_Table;\n+      G_Len := 0;\n+\n+      Edges     := No_Table;\n+      Edges_Len := 0;\n+\n+      if V <= 2 * NK then\n+         raise Program_Error with \"K to V ratio cannot be lower than 2\";\n+      end if;\n+\n+      Vertices := No_Table;\n+      NV       := V;\n+\n+      S    := Seed;\n+      Opt  := Optim;\n+      NT   := Tries;\n+\n+      Keys := Allocate (NK);\n+\n+      --  Resize initial words to have all of them at the same size\n+      --  (so the size of the largest one).\n+\n+      for K in 0 .. NK - 1 loop\n+         Resize_Word (WT.Table (Initial (K)), Max_Key_Len);\n+      end loop;\n+\n+      --  Allocated the table to store the reduced words. As WT is a\n+      --  GNAT.Table (using C memory management), pointers have to be\n+      --  explicitly initialized to null.\n+\n+      WT.Set_Last (Reduced (NK - 1));\n+\n+      --  Note: Reduced (0) = NK + 1\n+\n+      WT.Table (NK) := null;\n+\n+      for W in 0 .. NK - 1 loop\n+         WT.Table (Reduced (W)) := null;\n+      end loop;\n+   end Initialize;\n+\n+   ------------\n+   -- Insert --\n+   ------------\n+\n+   procedure Insert (Value : String) is\n+      Len  : constant Natural := Value'Length;\n+\n+   begin\n+      if Verbose then\n+         Put (Output, \"Inserting \"\"\" & Value & \"\"\"\");\n+         New_Line (Output);\n+      end if;\n+\n+      for J in Value'Range loop\n+         pragma Assert (Value (J) /= ASCII.NUL);\n+         null;\n+      end loop;\n+\n+      WT.Set_Last (NK);\n+      WT.Table (NK) := New_Word (Value);\n+      NK := NK + 1;\n+\n+      if Max_Key_Len < Len then\n+         Max_Key_Len := Len;\n+      end if;\n+\n+      if Min_Key_Len = 0 or else Len < Min_Key_Len then\n+         Min_Key_Len := Len;\n+      end if;\n+   end Insert;\n+\n+   --------------\n+   -- New_Line --\n+   --------------\n+\n+   procedure New_Line (File : File_Descriptor) is\n+   begin\n+      if Write (File, EOL'Address, 1) /= 1 then\n+         raise Program_Error;\n+      end if;\n+   end New_Line;\n+\n+   --------------\n+   -- New_Word --\n+   --------------\n+\n+   function New_Word (S : String) return Word_Type is\n+   begin\n+      return new String'(S);\n+   end New_Word;\n+\n+   ------------------------------\n+   -- Parse_Position_Selection --\n+   ------------------------------\n+\n+   procedure Parse_Position_Selection (Argument : String) is\n+      N : Natural          := Argument'First;\n+      L : constant Natural := Argument'Last;\n+      M : constant Natural := Max_Key_Len;\n+\n+      T : array (1 .. M) of Boolean := (others => False);\n+\n+      function Parse_Index return Natural;\n+      --  Parse argument starting at index N to find an index\n+\n+      -----------------\n+      -- Parse_Index --\n+      -----------------\n+\n+      function Parse_Index return Natural is\n+         C : Character := Argument (N);\n+         V : Natural   := 0;\n+\n+      begin\n+         if C = '$' then\n+            N := N + 1;\n+            return M;\n+         end if;\n+\n+         if C not in '0' .. '9' then\n+            raise Program_Error with \"cannot read position argument\";\n+         end if;\n+\n+         while C in '0' .. '9' loop\n+            V := V * 10 + (Character'Pos (C) - Character'Pos ('0'));\n+            N := N + 1;\n+            exit when L < N;\n+            C := Argument (N);\n+         end loop;\n+\n+         return V;\n+      end Parse_Index;\n+\n+   --  Start of processing for Parse_Position_Selection\n+\n+   begin\n+      --  Empty specification means all the positions\n+\n+      if L < N then\n+         Char_Pos_Set_Len := M;\n+         Char_Pos_Set := Allocate (Char_Pos_Set_Len);\n+\n+         for C in 0 .. Char_Pos_Set_Len - 1 loop\n+            Set_Char_Pos (C, C + 1);\n+         end loop;\n+\n+      else\n+         loop\n+            declare\n+               First, Last : Natural;\n+\n+            begin\n+               First := Parse_Index;\n+               Last  := First;\n+\n+               --  Detect a range\n+\n+               if N <= L and then Argument (N) = '-' then\n+                  N := N + 1;\n+                  Last := Parse_Index;\n+               end if;\n+\n+               --  Include the positions in the selection\n+\n+               for J in First .. Last loop\n+                  T (J) := True;\n+               end loop;\n+            end;\n+\n+            exit when L < N;\n+\n+            if Argument (N) /= ',' then\n+               raise Program_Error with \"cannot read position argument\";\n+            end if;\n+\n+            N := N + 1;\n+         end loop;\n+\n+         --  Compute position selection length\n+\n+         N := 0;\n+         for J in T'Range loop\n+            if T (J) then\n+               N := N + 1;\n+            end if;\n+         end loop;\n+\n+         --  Fill position selection\n+\n+         Char_Pos_Set_Len := N;\n+         Char_Pos_Set := Allocate (Char_Pos_Set_Len);\n+\n+         N := 0;\n+         for J in T'Range loop\n+            if T (J) then\n+               Set_Char_Pos (N, J);\n+               N := N + 1;\n+            end if;\n+         end loop;\n+      end if;\n+   end Parse_Position_Selection;\n+\n+   ---------\n+   -- Put --\n+   ---------\n+\n+   procedure Put (File : File_Descriptor; Str : String) is\n+      Len : constant Natural := Str'Length;\n+   begin\n+      for J in Str'Range loop\n+         pragma Assert (Str (J) /= ASCII.NUL);\n+         null;\n+      end loop;\n+\n+      if Write (File, Str'Address, Len) /= Len then\n+         raise Program_Error;\n+      end if;\n+   end Put;\n+\n+   ---------\n+   -- Put --\n+   ---------\n+\n+   procedure Put\n+     (F  : File_Descriptor;\n+      S  : String;\n+      F1 : Natural;\n+      L1 : Natural;\n+      C1 : Natural;\n+      F2 : Natural;\n+      L2 : Natural;\n+      C2 : Natural)\n+   is\n+      Len : constant Natural := S'Length;\n+\n+      procedure Flush;\n+      --  Write current line, followed by LF\n+\n+      -----------\n+      -- Flush --\n+      -----------\n+\n+      procedure Flush is\n+      begin\n+         Put (F, Line (1 .. Last));\n+         New_Line (F);\n+         Last := 0;\n+      end Flush;\n+\n+   --  Start of processing for Put\n+\n+   begin\n+      if C1 = F1 and then C2 = F2 then\n+         Last := 0;\n+      end if;\n+\n+      if Last + Len + 3 >= Max then\n+         Flush;\n+      end if;\n+\n+      if Last = 0 then\n+         Add (\"     \");\n+\n+         if F1 <= L1 then\n+            if C1 = F1 and then C2 = F2 then\n+               Add ('(');\n+\n+               if F1 = L1 then\n+                  Add (\"0 .. 0 => \");\n+               end if;\n+\n+            else\n+               Add (' ');\n+            end if;\n+         end if;\n+      end if;\n+\n+      if C2 = F2 then\n+         Add ('(');\n+\n+         if F2 = L2 then\n+            Add (\"0 .. 0 => \");\n+         end if;\n+\n+      else\n+         Add (' ');\n+      end if;\n+\n+      Add (S);\n+\n+      if C2 = L2 then\n+         Add (')');\n+\n+         if F1 > L1 then\n+            Add (';');\n+            Flush;\n+\n+         elsif C1 /= L1 then\n+            Add (',');\n+            Flush;\n+\n+         else\n+            Add (')');\n+            Add (';');\n+            Flush;\n+         end if;\n+\n+      else\n+         Add (',');\n+      end if;\n+   end Put;\n+\n+   ---------------\n+   -- Put_Edges --\n+   ---------------\n+\n+   procedure Put_Edges (File  : File_Descriptor; Title : String) is\n+      E  : Edge_Type;\n+      F1 : constant Natural := 1;\n+      L1 : constant Natural := Edges_Len - 1;\n+      M  : constant Natural := Max / 5;\n+\n+   begin\n+      Put (File, Title);\n+      New_Line (File);\n+\n+      --  Edges valid range is 1 .. Edge_Len - 1\n+\n+      for J in F1 .. L1 loop\n+         E := Get_Edges (J);\n+         Put (File, Image (J, M),     F1, L1, J, 1, 4, 1);\n+         Put (File, Image (E.X, M),   F1, L1, J, 1, 4, 2);\n+         Put (File, Image (E.Y, M),   F1, L1, J, 1, 4, 3);\n+         Put (File, Image (E.Key, M), F1, L1, J, 1, 4, 4);\n+      end loop;\n+   end Put_Edges;\n+\n+   ----------------------\n+   -- Put_Initial_Keys --\n+   ----------------------\n+\n+   procedure Put_Initial_Keys (File : File_Descriptor; Title : String) is\n+      F1 : constant Natural := 0;\n+      L1 : constant Natural := NK - 1;\n+      M  : constant Natural := Max / 5;\n+      K  : Key_Type;\n+\n+   begin\n+      Put (File, Title);\n+      New_Line (File);\n+\n+      for J in F1 .. L1 loop\n+         K := Get_Key (J);\n+         Put (File, Image (J, M),           F1, L1, J, 1, 3, 1);\n+         Put (File, Image (K.Edge, M),      F1, L1, J, 1, 3, 2);\n+         Put (File, Trim_Trailing_Nuls (WT.Table (Initial (J)).all),\n+                    F1, L1, J, 1, 3, 3);\n+      end loop;\n+   end Put_Initial_Keys;\n+\n+   --------------------\n+   -- Put_Int_Matrix --\n+   --------------------\n+\n+   procedure Put_Int_Matrix\n+     (File   : File_Descriptor;\n+      Title  : String;\n+      Table  : Integer;\n+      Len_1  : Natural;\n+      Len_2  : Natural)\n+   is\n+      F1 : constant Integer := 0;\n+      L1 : constant Integer := Len_1 - 1;\n+      F2 : constant Integer := 0;\n+      L2 : constant Integer := Len_2 - 1;\n+      Ix : Natural;\n+\n+   begin\n+      Put (File, Title);\n+      New_Line (File);\n+\n+      if Len_2 = 0 then\n+         for J in F1 .. L1 loop\n+            Ix := IT.Table (Table + J);\n+            Put (File, Image (Ix), 1, 0, 1, F1, L1, J);\n+         end loop;\n+\n+      else\n+         for J in F1 .. L1 loop\n+            for K in F2 .. L2 loop\n+               Ix := IT.Table (Table + J + K * Len_1);\n+               Put (File, Image (Ix), F1, L1, J, F2, L2, K);\n+            end loop;\n+         end loop;\n+      end if;\n+   end Put_Int_Matrix;\n+\n+   --------------------\n+   -- Put_Int_Vector --\n+   --------------------\n+\n+   procedure Put_Int_Vector\n+     (File   : File_Descriptor;\n+      Title  : String;\n+      Vector : Integer;\n+      Length : Natural)\n+   is\n+      F2 : constant Natural := 0;\n+      L2 : constant Natural := Length - 1;\n+\n+   begin\n+      Put (File, Title);\n+      New_Line (File);\n+\n+      for J in F2 .. L2 loop\n+         Put (File, Image (IT.Table (Vector + J)), 1, 0, 1, F2, L2, J);\n+      end loop;\n+   end Put_Int_Vector;\n+\n+   ----------------------\n+   -- Put_Reduced_Keys --\n+   ----------------------\n+\n+   procedure Put_Reduced_Keys (File : File_Descriptor; Title : String) is\n+      F1 : constant Natural := 0;\n+      L1 : constant Natural := NK - 1;\n+      M  : constant Natural := Max / 5;\n+      K  : Key_Type;\n+\n+   begin\n+      Put (File, Title);\n+      New_Line (File);\n+\n+      for J in F1 .. L1 loop\n+         K := Get_Key (J);\n+         Put (File, Image (J, M),           F1, L1, J, 1, 3, 1);\n+         Put (File, Image (K.Edge, M),      F1, L1, J, 1, 3, 2);\n+         Put (File, Trim_Trailing_Nuls (WT.Table (Reduced (J)).all),\n+                    F1, L1, J, 1, 3, 3);\n+      end loop;\n+   end Put_Reduced_Keys;\n+\n+   -----------------------\n+   -- Put_Used_Char_Set --\n+   -----------------------\n+\n+   procedure Put_Used_Char_Set (File : File_Descriptor; Title : String) is\n+      F : constant Natural := Character'Pos (Character'First);\n+      L : constant Natural := Character'Pos (Character'Last);\n+\n+   begin\n+      Put (File, Title);\n+      New_Line (File);\n+\n+      for J in Character'Range loop\n+         Put\n+           (File, Image (Get_Used_Char (J)), 1, 0, 1, F, L, Character'Pos (J));\n+      end loop;\n+   end Put_Used_Char_Set;\n+\n+   ----------------------\n+   -- Put_Vertex_Table --\n+   ----------------------\n+\n+   procedure Put_Vertex_Table (File : File_Descriptor; Title : String) is\n+      F1 : constant Natural := 0;\n+      L1 : constant Natural := NV - 1;\n+      M  : constant Natural := Max / 4;\n+      V  : Vertex_Type;\n+\n+   begin\n+      Put (File, Title);\n+      New_Line (File);\n+\n+      for J in F1 .. L1 loop\n+         V := Get_Vertices (J);\n+         Put (File, Image (J, M),       F1, L1, J, 1, 3, 1);\n+         Put (File, Image (V.First, M), F1, L1, J, 1, 3, 2);\n+         Put (File, Image (V.Last, M),  F1, L1, J, 1, 3, 3);\n+      end loop;\n+   end Put_Vertex_Table;\n+\n+   ------------\n+   -- Random --\n+   ------------\n+\n+   procedure Random (Seed : in out Natural) is\n+\n+      --  Park & Miller Standard Minimal using Schrage's algorithm to avoid\n+      --  overflow: Xn+1 = 16807 * Xn mod (2 ** 31 - 1)\n+\n+      R : Natural;\n+      Q : Natural;\n+      X : Integer;\n+\n+   begin\n+      R := Seed mod 127773;\n+      Q := Seed / 127773;\n+      X := 16807 * R - 2836 * Q;\n+\n+      Seed := (if X < 0 then X + 2147483647 else X);\n+   end Random;\n+\n+   -------------\n+   -- Reduced --\n+   -------------\n+\n+   function Reduced (K : Key_Id) return Word_Id is\n+   begin\n+      return K + NK + 1;\n+   end Reduced;\n+\n+   -----------------\n+   -- Resize_Word --\n+   -----------------\n+\n+   procedure Resize_Word (W : in out Word_Type; Len : Natural) is\n+      S1 : constant String := W.all;\n+      S2 : String (1 .. Len) := (others => ASCII.NUL);\n+      L  : constant Natural := S1'Length;\n+   begin\n+      if L /= Len then\n+         Free_Word (W);\n+         S2 (1 .. L) := S1;\n+         W := New_Word (S2);\n+      end if;\n+   end Resize_Word;\n+\n+   --------------------------\n+   -- Select_Char_Position --\n+   --------------------------\n+\n+   procedure Select_Char_Position is\n+\n+      type Vertex_Table_Type is array (Natural range <>) of Vertex_Type;\n+\n+      procedure Build_Identical_Keys_Sets\n+        (Table : in out Vertex_Table_Type;\n+         Last  : in out Natural;\n+         Pos   : Natural);\n+      --  Build a list of keys subsets that are identical with the current\n+      --  position selection plus Pos. Once this routine is called, reduced\n+      --  words are sorted by subsets and each item (First, Last) in Sets\n+      --  defines the range of identical keys.\n+      --  Need comment saying exactly what Last is ???\n+\n+      function Count_Different_Keys\n+        (Table : Vertex_Table_Type;\n+         Last  : Natural;\n+         Pos   : Natural) return Natural;\n+      --  For each subset in Sets, count the number of different keys if we add\n+      --  Pos to the current position selection.\n+\n+      Sel_Position : IT.Table_Type (1 .. Max_Key_Len);\n+      Last_Sel_Pos : Natural := 0;\n+      Max_Sel_Pos  : Natural := 0;\n+\n+      -------------------------------\n+      -- Build_Identical_Keys_Sets --\n+      -------------------------------\n+\n+      procedure Build_Identical_Keys_Sets\n+        (Table : in out Vertex_Table_Type;\n+         Last  : in out Natural;\n+         Pos   : Natural)\n+      is\n+         S : constant Vertex_Table_Type := Table (Table'First .. Last);\n+         C : constant Natural           := Pos;\n+         --  Shortcuts (why are these not renames ???)\n+\n+         F : Integer;\n+         L : Integer;\n+         --  First and last words of a subset\n+\n+         Offset : Natural;\n+         --  GNAT.Heap_Sort assumes that the first array index is 1. Offset\n+         --  defines the translation to operate.\n+\n+         function Lt (L, R : Natural) return Boolean;\n+         procedure Move (From : Natural; To : Natural);\n+         --  Subprograms needed by GNAT.Heap_Sort_G\n+\n+         --------\n+         -- Lt --\n+         --------\n+\n+         function Lt (L, R : Natural) return Boolean is\n+            C     : constant Natural := Pos;\n+            Left  : Natural;\n+            Right : Natural;\n+\n+         begin\n+            if L = 0 then\n+               Left  := NK;\n+               Right := Offset + R;\n+            elsif R = 0 then\n+               Left  := Offset + L;\n+               Right := NK;\n+            else\n+               Left  := Offset + L;\n+               Right := Offset + R;\n+            end if;\n+\n+            return WT.Table (Left)(C) < WT.Table (Right)(C);\n+         end Lt;\n+\n+         ----------\n+         -- Move --\n+         ----------\n+\n+         procedure Move (From : Natural; To : Natural) is\n+            Target, Source : Natural;\n+\n+         begin\n+            if From = 0 then\n+               Source := NK;\n+               Target := Offset + To;\n+            elsif To = 0 then\n+               Source := Offset + From;\n+               Target := NK;\n+            else\n+               Source := Offset + From;\n+               Target := Offset + To;\n+            end if;\n+\n+            WT.Table (Target) := WT.Table (Source);\n+            WT.Table (Source) := null;\n+         end Move;\n+\n+         package Sorting is new GNAT.Heap_Sort_G (Move, Lt);\n+\n+      --  Start of processing for Build_Identical_Key_Sets\n+\n+      begin\n+         Last := 0;\n+\n+         --  For each subset in S, extract the new subsets we have by adding C\n+         --  in the position selection.\n+\n+         for J in S'Range loop\n+            pragma Annotate (CodePeer, Modified, S (J));\n+\n+            if S (J).First = S (J).Last then\n+               F := S (J).First;\n+               L := S (J).Last;\n+               Last := Last + 1;\n+               Table (Last) := (F, L);\n+\n+            else\n+               Offset := Reduced (S (J).First) - 1;\n+               Sorting.Sort (S (J).Last - S (J).First + 1);\n+\n+               F := S (J).First;\n+               L := F;\n+               for N in S (J).First .. S (J).Last loop\n+\n+                  --  For the last item, close the last subset\n+\n+                  if N = S (J).Last then\n+                     Last := Last + 1;\n+                     Table (Last) := (F, N);\n+\n+                  --  Two contiguous words are identical when they have the\n+                  --  same Cth character.\n+\n+                  elsif WT.Table (Reduced (N))(C) =\n+                        WT.Table (Reduced (N + 1))(C)\n+                  then\n+                     L := N + 1;\n+\n+                  --  Find a new subset of identical keys. Store the current\n+                  --  one and create a new subset.\n+\n+                  else\n+                     Last := Last + 1;\n+                     Table (Last) := (F, L);\n+                     F := N + 1;\n+                     L := F;\n+                  end if;\n+               end loop;\n+            end if;\n+         end loop;\n+      end Build_Identical_Keys_Sets;\n+\n+      --------------------------\n+      -- Count_Different_Keys --\n+      --------------------------\n+\n+      function Count_Different_Keys\n+        (Table : Vertex_Table_Type;\n+         Last  : Natural;\n+         Pos   : Natural) return Natural\n+      is\n+         N : array (Character) of Natural;\n+         C : Character;\n+         T : Natural := 0;\n+\n+      begin\n+         --  For each subset, count the number of words that are still\n+         --  different when we include Pos in the position selection. Only\n+         --  focus on this position as the other positions already produce\n+         --  identical keys.\n+\n+         for S in 1 .. Last loop\n+\n+            --  Count the occurrences of the different characters\n+\n+            N := (others => 0);\n+            for K in Table (S).First .. Table (S).Last loop\n+               C := WT.Table (Reduced (K))(Pos);\n+               N (C) := N (C) + 1;\n+            end loop;\n+\n+            --  Update the number of different keys. Each character used\n+            --  denotes a different key.\n+\n+            for J in N'Range loop\n+               if N (J) > 0 then\n+                  T := T + 1;\n+               end if;\n+            end loop;\n+         end loop;\n+\n+         return T;\n+      end Count_Different_Keys;\n+\n+   --  Start of processing for Select_Char_Position\n+\n+   begin\n+      --  Initialize the reduced words set\n+\n+      for K in 0 .. NK - 1 loop\n+         WT.Table (Reduced (K)) := New_Word (WT.Table (Initial (K)).all);\n+      end loop;\n+\n+      declare\n+         Differences          : Natural;\n+         Max_Differences      : Natural := 0;\n+         Old_Differences      : Natural;\n+         Max_Diff_Sel_Pos     : Natural := 0; -- init to kill warning\n+         Max_Diff_Sel_Pos_Idx : Natural := 0; -- init to kill warning\n+         Same_Keys_Sets_Table : Vertex_Table_Type (1 .. NK);\n+         Same_Keys_Sets_Last  : Natural := 1;\n+\n+      begin\n+         for C in Sel_Position'Range loop\n+            Sel_Position (C) := C;\n+         end loop;\n+\n+         Same_Keys_Sets_Table (1) := (0, NK - 1);\n+\n+         loop\n+            --  Preserve maximum number of different keys and check later on\n+            --  that this value is strictly incrementing. Otherwise, it means\n+            --  that two keys are strictly identical.\n+\n+            Old_Differences := Max_Differences;\n+\n+            --  The first position should not exceed the minimum key length.\n+            --  Otherwise, we may end up with an empty word once reduced.\n+\n+            Max_Sel_Pos :=\n+              (if Last_Sel_Pos = 0 then Min_Key_Len else Max_Key_Len);\n+\n+            --  Find which position increases more the number of differences\n+\n+            for J in Last_Sel_Pos + 1 .. Max_Sel_Pos loop\n+               Differences := Count_Different_Keys\n+                 (Same_Keys_Sets_Table,\n+                  Same_Keys_Sets_Last,\n+                  Sel_Position (J));\n+\n+               if Verbose then\n+                  Put (Output,\n+                       \"Selecting position\" & Sel_Position (J)'Img &\n+                         \" results in\" & Differences'Img &\n+                         \" differences\");\n+                  New_Line (Output);\n+               end if;\n+\n+               if Differences > Max_Differences then\n+                  Max_Differences      := Differences;\n+                  Max_Diff_Sel_Pos     := Sel_Position (J);\n+                  Max_Diff_Sel_Pos_Idx := J;\n+               end if;\n+            end loop;\n+\n+            if Old_Differences = Max_Differences then\n+               raise Program_Error with \"some keys are identical\";\n+            end if;\n+\n+            --  Insert selected position and sort Sel_Position table\n+\n+            Last_Sel_Pos := Last_Sel_Pos + 1;\n+            Sel_Position (Last_Sel_Pos + 1 .. Max_Diff_Sel_Pos_Idx) :=\n+              Sel_Position (Last_Sel_Pos .. Max_Diff_Sel_Pos_Idx - 1);\n+            Sel_Position (Last_Sel_Pos) := Max_Diff_Sel_Pos;\n+\n+            for P in 1 .. Last_Sel_Pos - 1 loop\n+               if Max_Diff_Sel_Pos < Sel_Position (P) then\n+                  pragma Annotate\n+                    (CodePeer, False_Positive,\n+                     \"test always false\", \"false positive?\");\n+\n+                  Sel_Position (P + 1 .. Last_Sel_Pos) :=\n+                    Sel_Position (P .. Last_Sel_Pos - 1);\n+                  Sel_Position (P) := Max_Diff_Sel_Pos;\n+                  exit;\n+               end if;\n+            end loop;\n+\n+            exit when Max_Differences = NK;\n+\n+            Build_Identical_Keys_Sets\n+              (Same_Keys_Sets_Table,\n+               Same_Keys_Sets_Last,\n+               Max_Diff_Sel_Pos);\n+\n+            if Verbose then\n+               Put (Output,\n+                    \"Selecting position\" & Max_Diff_Sel_Pos'Img &\n+                      \" results in\" & Max_Differences'Img &\n+                      \" differences\");\n+               New_Line (Output);\n+               Put (Output, \"--\");\n+               New_Line (Output);\n+               for J in 1 .. Same_Keys_Sets_Last loop\n+                  for K in\n+                    Same_Keys_Sets_Table (J).First ..\n+                    Same_Keys_Sets_Table (J).Last\n+                  loop\n+                     Put (Output,\n+                          Trim_Trailing_Nuls (WT.Table (Reduced (K)).all));\n+                     New_Line (Output);\n+                  end loop;\n+                  Put (Output, \"--\");\n+                  New_Line (Output);\n+               end loop;\n+            end if;\n+         end loop;\n+      end;\n+\n+      Char_Pos_Set_Len := Last_Sel_Pos;\n+      Char_Pos_Set := Allocate (Char_Pos_Set_Len);\n+\n+      for C in 1 .. Last_Sel_Pos loop\n+         Set_Char_Pos (C - 1, Sel_Position (C));\n+      end loop;\n+   end Select_Char_Position;\n+\n+   --------------------------\n+   -- Select_Character_Set --\n+   --------------------------\n+\n+   procedure Select_Character_Set is\n+      Last : Natural := 0;\n+      Used : array (Character) of Boolean := (others => False);\n+      Char : Character;\n+\n+   begin\n+      for J in 0 .. NK - 1 loop\n+         for K in 0 .. Char_Pos_Set_Len - 1 loop\n+            Char := WT.Table (Initial (J))(Get_Char_Pos (K));\n+            exit when Char = ASCII.NUL;\n+            Used (Char) := True;\n+         end loop;\n+      end loop;\n+\n+      Used_Char_Set_Len := 256;\n+      Used_Char_Set := Allocate (Used_Char_Set_Len);\n+\n+      for J in Used'Range loop\n+         if Used (J) then\n+            Set_Used_Char (J, Last);\n+            Last := Last + 1;\n+         else\n+            Set_Used_Char (J, 0);\n+         end if;\n+      end loop;\n+   end Select_Character_Set;\n+\n+   ------------------\n+   -- Set_Char_Pos --\n+   ------------------\n+\n+   procedure Set_Char_Pos (P : Natural; Item : Natural) is\n+      N : constant Natural := Char_Pos_Set + P;\n+   begin\n+      IT.Table (N) := Item;\n+   end Set_Char_Pos;\n+\n+   ---------------\n+   -- Set_Edges --\n+   ---------------\n+\n+   procedure Set_Edges (F : Natural; Item : Edge_Type) is\n+      N : constant Natural := Edges + (F * Edge_Size);\n+   begin\n+      IT.Table (N)     := Item.X;\n+      IT.Table (N + 1) := Item.Y;\n+      IT.Table (N + 2) := Item.Key;\n+   end Set_Edges;\n+\n+   ---------------\n+   -- Set_Graph --\n+   ---------------\n+\n+   procedure Set_Graph (N : Natural; Item : Integer) is\n+   begin\n+      IT.Table (G + N) := Item;\n+   end Set_Graph;\n+\n+   -------------\n+   -- Set_Key --\n+   -------------\n+\n+   procedure Set_Key (N : Key_Id; Item : Key_Type) is\n+   begin\n+      IT.Table (Keys + N) := Item.Edge;\n+   end Set_Key;\n+\n+   ---------------\n+   -- Set_Table --\n+   ---------------\n+\n+   procedure Set_Table (T : Integer; X, Y : Natural; Item : Natural) is\n+      N : constant Natural := T + ((Y * T1_Len) + X);\n+   begin\n+      IT.Table (N) := Item;\n+   end Set_Table;\n+\n+   -------------------\n+   -- Set_Used_Char --\n+   -------------------\n+\n+   procedure Set_Used_Char (C : Character; Item : Natural) is\n+      N : constant Natural := Used_Char_Set + Character'Pos (C);\n+   begin\n+      IT.Table (N) := Item;\n+   end Set_Used_Char;\n+\n+   ------------------\n+   -- Set_Vertices --\n+   ------------------\n+\n+   procedure Set_Vertices (F : Natural; Item : Vertex_Type) is\n+      N : constant Natural := Vertices + (F * Vertex_Size);\n+   begin\n+      IT.Table (N)     := Item.First;\n+      IT.Table (N + 1) := Item.Last;\n+   end Set_Vertices;\n+\n+   ---------\n+   -- Sum --\n+   ---------\n+\n+   function Sum\n+     (Word  : Word_Type;\n+      Table : Table_Id;\n+      Opt   : Optimization) return Natural\n+   is\n+      S : Natural := 0;\n+      R : Natural;\n+\n+   begin\n+      case Opt is\n+         when CPU_Time =>\n+            for J in 0 .. T1_Len - 1 loop\n+               exit when Word (J + 1) = ASCII.NUL;\n+               R := Get_Table (Table, J, Get_Used_Char (Word (J + 1)));\n+               pragma Assert (NV /= 0);\n+               S := (S + R) mod NV;\n+            end loop;\n+\n+         when Memory_Space =>\n+            for J in 0 .. T1_Len - 1 loop\n+               exit when Word (J + 1) = ASCII.NUL;\n+               R := Get_Table (Table, J, 0);\n+               pragma Assert (NV /= 0);\n+               S := (S + R * Character'Pos (Word (J + 1))) mod NV;\n+            end loop;\n+      end case;\n+\n+      return S;\n+   end Sum;\n+\n+   ------------------------\n+   -- Trim_Trailing_Nuls --\n+   ------------------------\n+\n+   function Trim_Trailing_Nuls (Str : String) return String is\n+   begin\n+      for J in reverse Str'Range loop\n+         if Str (J) /= ASCII.NUL then\n+            return Str (Str'First .. J);\n+         end if;\n+      end loop;\n+\n+      return Str;\n+   end Trim_Trailing_Nuls;\n+\n+   ---------------\n+   -- Type_Size --\n+   ---------------\n+\n+   function Type_Size (L : Natural) return Natural is\n+   begin\n+      if L <= 2 ** 8 then\n+         return 8;\n+      elsif L <= 2 ** 16 then\n+         return 16;\n+      else\n+         return 32;\n+      end if;\n+   end Type_Size;\n+\n+   -----------\n+   -- Value --\n+   -----------\n+\n+   function Value\n+     (Name : Table_Name;\n+      J    : Natural;\n+      K    : Natural := 0) return Natural\n+   is\n+   begin\n+      case Name is\n+         when Character_Position =>\n+            return Get_Char_Pos (J);\n+\n+         when Used_Character_Set =>\n+            return Get_Used_Char (Character'Val (J));\n+\n+         when Function_Table_1 =>\n+            return Get_Table (T1, J, K);\n+\n+         when Function_Table_2 =>\n+            return Get_Table (T2, J, K);\n+\n+         when Graph_Table =>\n+            return Get_Graph (J);\n+      end case;\n+   end Value;\n+\n+end System.Perfect_Hash_Generators;"}, {"sha": "f8b8129fb210eb972a6812ebe5c2e9d385ed21c6", "filename": "gcc/ada/libgnat/s-pehage.ads", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fs-pehage.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fs-pehage.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-pehage.ads?ref=c11207d345f8d678d440a3ff0f335b2ed25513e7", "patch": "@@ -0,0 +1,212 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--        S Y S T E M . P E R F E C T _ H A S H _ G E N E R A T O R S       --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                     Copyright (C) 2002-2021, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides a generator of static minimal perfect hash functions.\n+--  To understand what a perfect hash function is, we define several notions.\n+--  These definitions are inspired from the following paper:\n+\n+--    Zbigniew J. Czech, George Havas, and Bohdan S. Majewski ``An Optimal\n+--    Algorithm for Generating Minimal Perfect Hash Functions'', Information\n+--    Processing Letters, 43(1992) pp.257-264, Oct.1992\n+\n+--  Let W be a set of m words. A hash function h is a function that maps the\n+--  set of words W into some given interval I of integers [0, k-1], where k is\n+--  an integer, usually k >= m. h (w) where w is a word in W computes an\n+--  address or an integer from I for the storage or the retrieval of that\n+--  item. The storage area used to store items is known as a hash table. Words\n+--  for which the same address is computed are called synonyms. Due to the\n+--  existence of synonyms a situation called collision may arise in which two\n+--  items w1 and w2 have the same address. Several schemes for resolving\n+--  collisions are known. A perfect hash function is an injection from the word\n+--  set W to the integer interval I with k >= m.  If k = m, then h is a minimal\n+--  perfect hash function. A hash function is order preserving if it puts\n+--  entries into the hash table in a prespecified order.\n+\n+--  A minimal perfect hash function is defined by two properties:\n+\n+--    Since no collisions occur each item can be retrieved from the table in\n+--    *one* probe. This represents the \"perfect\" property.\n+\n+--    The hash table size corresponds to the exact size of W and *no larger*.\n+--    This represents the \"minimal\" property.\n+\n+--  The functions generated by this package require the words to be known in\n+--  advance (they are \"static\" hash functions). The hash functions are also\n+--  order preserving. If w2 is inserted after w1 in the generator, then h (w1)\n+--  < h (w2). These hashing functions are convenient for use with realtime\n+--  applications.\n+\n+pragma Compiler_Unit_Warning;\n+\n+package System.Perfect_Hash_Generators is\n+\n+   type Optimization is (Memory_Space, CPU_Time);\n+   --  Optimize either the memory space or the execution time. Note: in\n+   --  practice, the optimization mode has little effect on speed. The tables\n+   --  are somewhat smaller with Memory_Space.\n+\n+   Verbose : Boolean := False;\n+   --  Output the status of the algorithm. For instance, the tables, the random\n+   --  graph (edges, vertices) and selected char positions are output between\n+   --  two iterations.\n+\n+   procedure Initialize\n+     (Seed  : Natural;\n+      V     : Positive;\n+      Optim : Optimization;\n+      Tries : Positive);\n+   --  Initialize the generator and its internal structures. Set the number of\n+   --  vertices in the random graphs. This value has to be greater than twice\n+   --  the number of keys in order for the algorithm to succeed. The word set\n+   --  is not modified (in particular when it is already set). For instance, it\n+   --  is possible to run several times the generator with different settings\n+   --  on the same words.\n+   --\n+   --  A classical way of doing is to Insert all the words and then to invoke\n+   --  Initialize and Compute. If this fails to find a perfect hash function,\n+   --  invoke Initialize again with other configuration parameters (probably\n+   --  with a greater number of vertices). Once successful, invoke Define and\n+   --  Value, and then Finalize.\n+\n+   procedure Finalize;\n+   --  Deallocate the internal structures and the words table\n+\n+   procedure Insert (Value : String);\n+   --  Insert a new word into the table. ASCII.NUL characters are not allowed.\n+\n+   Too_Many_Tries : exception;\n+   --  Raised after Tries unsuccessful runs\n+\n+   procedure Compute (Position : String);\n+   --  Compute the hash function. Position allows the definition of selection\n+   --  of character positions used in the word hash function. Positions can be\n+   --  separated by commas and ranges like x-y may be used. Character '$'\n+   --  represents the final character of a word. With an empty position, the\n+   --  generator automatically produces positions to reduce the memory usage.\n+   --  Raise Too_Many_Tries if the algorithm does not succeed within Tries\n+   --  attempts (see Initialize).\n+\n+   --  The procedure Define returns the lengths of an internal table and its\n+   --  item type size. The function Value returns the value of each item in\n+   --  the table. Together they can be used to retrieve the parameters of the\n+   --  hash function which has been computed by a call to Compute.\n+\n+   --  The hash function has the following form:\n+\n+   --             h (w) = (g (f1 (w)) + g (f2 (w))) mod m\n+\n+   --  G is a function based on a graph table [0,n-1] -> [0,m-1]. m is the\n+   --  number of keys. n is an internally computed value and it can be obtained\n+   --  as the length of vector G.\n+\n+   --  F1 and F2 are two functions based on two function tables T1 and T2.\n+   --  Their definition depends on the chosen optimization mode.\n+\n+   --  Only some character positions are used in the words because they are\n+   --  significant. They are listed in a character position table (P in the\n+   --  pseudo-code below). For instance, in {\"jan\", \"feb\", \"mar\", \"apr\", \"jun\",\n+   --  \"jul\", \"aug\", \"sep\", \"oct\", \"nov\", \"dec\"}, only positions 2 and 3 are\n+   --  significant (the first character can be ignored). In this example, P =\n+   --  {2, 3}\n+\n+   --  When Optimization is CPU_Time, the first dimension of T1 and T2\n+   --  corresponds to the character position in the word and the second to the\n+   --  character set. As all the character set is not used, we define a used\n+   --  character table which associates a distinct index to each used character\n+   --  (unused characters are mapped to zero). In this case, the second\n+   --  dimension of T1 and T2 is reduced to the used character set (C in the\n+   --  pseudo-code below). Therefore, the hash function has the following:\n+\n+   --    function Hash (S : String) return Natural is\n+   --       F      : constant Natural := S'First - 1;\n+   --       L      : constant Natural := S'Length;\n+   --       F1, F2 : Natural := 0;\n+   --       J      : <t>;\n+\n+   --    begin\n+   --       for K in P'Range loop\n+   --          exit when L < P (K);\n+   --          J  := C (S (P (K) + F));\n+   --          F1 := (F1 + Natural (T1 (K, J))) mod <n>;\n+   --          F2 := (F2 + Natural (T2 (K, J))) mod <n>;\n+   --       end loop;\n+\n+   --       return (Natural (G (F1)) + Natural (G (F2))) mod <m>;\n+   --    end Hash;\n+\n+   --  When Optimization is Memory_Space, the first dimension of T1 and T2\n+   --  corresponds to the character position in the word and the second\n+   --  dimension is ignored. T1 and T2 are no longer matrices but vectors.\n+   --  Therefore, the used character table is not available. The hash function\n+   --  has the following form:\n+\n+   --     function Hash (S : String) return Natural is\n+   --        F      : constant Natural := S'First - 1;\n+   --        L      : constant Natural := S'Length;\n+   --        F1, F2 : Natural := 0;\n+   --        J      : <t>;\n+\n+   --     begin\n+   --        for K in P'Range loop\n+   --           exit when L < P (K);\n+   --           J  := Character'Pos (S (P (K) + F));\n+   --           F1 := (F1 + Natural (T1 (K) * J)) mod <n>;\n+   --           F2 := (F2 + Natural (T2 (K) * J)) mod <n>;\n+   --        end loop;\n+\n+   --        return (Natural (G (F1)) + Natural (G (F2))) mod <m>;\n+   --     end Hash;\n+\n+   type Table_Name is\n+     (Character_Position,\n+      Used_Character_Set,\n+      Function_Table_1,\n+      Function_Table_2,\n+      Graph_Table);\n+\n+   procedure Define\n+     (Name      : Table_Name;\n+      Item_Size : out Natural;\n+      Length_1  : out Natural;\n+      Length_2  : out Natural);\n+   --  Return the definition of the table Name. This includes the length of\n+   --  dimensions 1 and 2 and the size of an unsigned integer item. When\n+   --  Length_2 is zero, the table has only one dimension. All the ranges\n+   --  start from zero.\n+\n+   function Value\n+     (Name : Table_Name;\n+      J    : Natural;\n+      K    : Natural := 0) return Natural;\n+   --  Return the value of the component (J, K) of the table Name. When the\n+   --  table has only one dimension, K is ignored.\n+\n+end System.Perfect_Hash_Generators;"}, {"sha": "f1197786dcee200b778fefb88c7e426b3f3672be", "filename": "gcc/ada/libgnat/s-vaen16.ads", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fs-vaen16.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fs-vaen16.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-vaen16.ads?ref=c11207d345f8d678d440a3ff0f335b2ed25513e7", "patch": "@@ -0,0 +1,52 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                   S Y S T E M . V A L _ E N U M _ 1 6                    --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2021, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Instantiation of System.Value_N for enumeration types whose names table\n+--  has a length that fits in a 16-bit but not a 8-bit integer.\n+\n+with Interfaces;\n+with System.Value_N;\n+\n+package System.Val_Enum_16 is\n+   pragma Preelaborate;\n+\n+   package Impl is new Value_N (Interfaces.Integer_16);\n+\n+   function Value_Enumeration_16\n+     (Names   : String;\n+      Indexes : System.Address;\n+      Hash    : Impl.Hash_Function_Ptr;\n+      Num     : Natural;\n+      Str     : String)\n+      return    Natural\n+     renames Impl.Value_Enumeration;\n+\n+end System.Val_Enum_16;"}, {"sha": "ba24af316c63080928ada9c8a5506f9e54e73520", "filename": "gcc/ada/libgnat/s-vaen32.ads", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fs-vaen32.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fs-vaen32.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-vaen32.ads?ref=c11207d345f8d678d440a3ff0f335b2ed25513e7", "patch": "@@ -0,0 +1,52 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                   S Y S T E M . V A L _ E N U M _ 3 2                    --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2021, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Instantiation of System.Value_N for enumeration types whose names table\n+--  has a length that fits in a 32-bit but not a 16-bit integer.\n+\n+with Interfaces;\n+with System.Value_N;\n+\n+package System.Val_Enum_32 is\n+   pragma Preelaborate;\n+\n+   package Impl is new Value_N (Interfaces.Integer_32);\n+\n+   function Value_Enumeration_32\n+     (Names   : String;\n+      Indexes : System.Address;\n+      Hash    : Impl.Hash_Function_Ptr;\n+      Num     : Natural;\n+      Str     : String)\n+      return    Natural\n+     renames Impl.Value_Enumeration;\n+\n+end System.Val_Enum_32;"}, {"sha": "4de9b0e2e407eccb2516f6c4cd2a8915509ada5e", "filename": "gcc/ada/libgnat/s-vaenu8.ads", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fs-vaenu8.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fs-vaenu8.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-vaenu8.ads?ref=c11207d345f8d678d440a3ff0f335b2ed25513e7", "patch": "@@ -0,0 +1,52 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                    S Y S T E M . V A L _ E N U M _ 8                     --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2021, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Instantiation of System.Value_N for enumeration types whose names table\n+--  has a length that fits in a 8-bit integer.\n+\n+with Interfaces;\n+with System.Value_N;\n+\n+package System.Val_Enum_8 is\n+   pragma Preelaborate;\n+\n+   package Impl is new Value_N (Interfaces.Integer_8);\n+\n+   function Value_Enumeration_8\n+     (Names   : String;\n+      Indexes : System.Address;\n+      Hash    : Impl.Hash_Function_Ptr;\n+      Num     : Natural;\n+      Str     : String)\n+      return    Natural\n+     renames Impl.Value_Enumeration;\n+\n+end System.Val_Enum_8;"}, {"sha": "08d1a7388f462c84b7b5f35795292ea93b78b7c8", "filename": "gcc/ada/libgnat/s-valuen.adb", "status": "renamed", "additions": 35, "deletions": 90, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fs-valuen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fs-valuen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuen.adb?ref=c11207d345f8d678d440a3ff0f335b2ed25513e7", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT COMPILER COMPONENTS                         --\n --                                                                          --\n---                      S Y S T E M . V A L _ E N U M                       --\n+--                       S Y S T E M . V A L U E _ N                        --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2021, Free Software Foundation, Inc.         --\n+--             Copyright (C) 2021, Free Software Foundation, Inc.           --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,123 +33,68 @@ with Ada.Unchecked_Conversion;\n \n with System.Val_Util; use System.Val_Util;\n \n-package body System.Val_Enum is\n+package body System.Value_N is\n \n-   -------------------------\n-   -- Value_Enumeration_8 --\n-   -------------------------\n+   -----------------------\n+   -- Value_Enumeration --\n+   -----------------------\n \n-   function Value_Enumeration_8\n+   function Value_Enumeration\n      (Names   : String;\n       Indexes : System.Address;\n+      Hash    : Hash_Function_Ptr;\n       Num     : Natural;\n       Str     : String)\n       return    Natural\n    is\n       F : Natural;\n       L : Natural;\n+      H : Natural;\n       S : String (Str'Range) := Str;\n \n-      type Natural_8 is range 0 .. 2 ** 7 - 1;\n-      type Index_Table is array (Natural) of Natural_8;\n+      subtype Names_Index is\n+        Index_Type range Index_Type (Names'First)\n+                          .. Index_Type (Names'Last) + 1;\n+      subtype Index is Natural range Natural'First .. Names'Length;\n+      type Index_Table is array (Index) of Names_Index;\n       type Index_Table_Ptr is access Index_Table;\n \n       function To_Index_Table_Ptr is\n         new Ada.Unchecked_Conversion (System.Address, Index_Table_Ptr);\n \n       IndexesT : constant Index_Table_Ptr := To_Index_Table_Ptr (Indexes);\n \n+      pragma Assert (Num + 1 in IndexesT'Range);\n+\n    begin\n       Normalize_String (S, F, L);\n \n-      for J in 0 .. Num loop\n-         if Names\n-           (Natural (IndexesT (J)) ..\n-            Natural (IndexesT (J + 1)) - 1) = S (F .. L)\n-         then\n-            return J;\n-         end if;\n-      end loop;\n-\n-      Bad_Value (Str);\n-   end Value_Enumeration_8;\n-\n-   --------------------------\n-   -- Value_Enumeration_16 --\n-   --------------------------\n-\n-   function Value_Enumeration_16\n-     (Names   : String;\n-      Indexes : System.Address;\n-      Num     : Natural;\n-      Str     : String)\n-      return    Natural\n-   is\n-      F : Natural;\n-      L : Natural;\n-      S : String (Str'Range) := Str;\n-\n-      type Natural_16 is range 0 .. 2 ** 15 - 1;\n-      type Index_Table is array (Natural) of Natural_16;\n-      type Index_Table_Ptr is access Index_Table;\n+      --  If we have a valid hash value, do a single lookup\n \n-      function To_Index_Table_Ptr is\n-        new Ada.Unchecked_Conversion (System.Address, Index_Table_Ptr);\n-\n-      IndexesT : constant Index_Table_Ptr := To_Index_Table_Ptr (Indexes);\n-\n-   begin\n-      Normalize_String (S, F, L);\n+      H := (if Hash /= null then Hash.all (S (F .. L)) else Natural'Last);\n \n-      for J in 0 .. Num loop\n+      if H /= Natural'Last then\n          if Names\n-           (Natural (IndexesT (J)) ..\n-            Natural (IndexesT (J + 1)) - 1) = S (F .. L)\n+           (Natural (IndexesT (H)) ..\n+            Natural (IndexesT (H + 1)) - 1) = S (F .. L)\n          then\n-            return J;\n+            return H;\n          end if;\n-      end loop;\n \n-      Bad_Value (Str);\n-   end Value_Enumeration_16;\n-\n-   --------------------------\n-   -- Value_Enumeration_32 --\n-   --------------------------\n+      --  Otherwise do a linear search\n \n-   function Value_Enumeration_32\n-     (Names   : String;\n-      Indexes : System.Address;\n-      Num     : Natural;\n-      Str     : String)\n-      return    Natural\n-   is\n-      F : Natural;\n-      L : Natural;\n-      S : String (Str'Range) := Str;\n-\n-      type Natural_32 is range 0 .. 2 ** 31 - 1;\n-      type Index_Table is array (Natural) of Natural_32;\n-      type Index_Table_Ptr is access Index_Table;\n-\n-      function To_Index_Table_Ptr is\n-        new Ada.Unchecked_Conversion (System.Address, Index_Table_Ptr);\n-\n-      IndexesT : constant Index_Table_Ptr := To_Index_Table_Ptr (Indexes);\n-\n-   begin\n-      Normalize_String (S, F, L);\n-\n-      for J in 0 .. Num loop\n-         if Names\n-           (Natural (IndexesT (J)) ..\n-            Natural (IndexesT (J + 1)) - 1) = S (F .. L)\n-         then\n-            return J;\n-         end if;\n-      end loop;\n+      else\n+         for J in 0 .. Num loop\n+            if Names\n+              (Natural (IndexesT (J)) ..\n+               Natural (IndexesT (J + 1)) - 1) = S (F .. L)\n+            then\n+               return J;\n+            end if;\n+         end loop;\n+      end if;\n \n       Bad_Value (Str);\n-   end Value_Enumeration_32;\n+   end Value_Enumeration;\n \n-end System.Val_Enum;\n+end System.Value_N;", "previous_filename": "gcc/ada/libgnat/s-valenu.adb"}, {"sha": "dafa45164c1a87e3f757442935a8133ae0d75cf4", "filename": "gcc/ada/libgnat/s-valuen.ads", "status": "renamed", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fs-valuen.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Flibgnat%2Fs-valuen.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuen.ads?ref=c11207d345f8d678d440a3ff0f335b2ed25513e7", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT COMPILER COMPONENTS                         --\n --                                                                          --\n---                      S Y S T E M . V A L _ E N U M                       --\n+--                       S Y S T E M . V A L U E _ N                        --\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2021, Free Software Foundation, Inc.         --\n+--             Copyright (C) 2021, Free Software Foundation, Inc.           --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,23 +33,31 @@\n --  other than those in packages Standard and System. See unit Exp_Imgv for\n --  details of the format of constructed image tables.\n \n-package System.Val_Enum is\n+generic\n+\n+   type Index_Type is range <>;\n+\n+package System.Value_N is\n    pragma Preelaborate;\n \n-   function Value_Enumeration_8\n+   type Hash_Function_Ptr is access function (S : String) return Natural;\n+\n+   function Value_Enumeration\n      (Names   : String;\n       Indexes : System.Address;\n+      Hash    : Hash_Function_Ptr;\n       Num     : Natural;\n       Str     : String)\n       return    Natural;\n    --  Used to compute Enum'Value (Str) where Enum is some enumeration type\n    --  other than those defined in package Standard. Names is a string with\n    --  a lower bound of 1 containing the characters of all the enumeration\n    --  literals concatenated together in sequence. Indexes is the address\n-   --  of an array of type array (0 .. N) of Natural_8, where N is the\n+   --  of an array of type array (0 .. N) of Index_Type, where N is the\n    --  number of enumeration literals in the type. The Indexes values are\n    --  the starting subscript of each enumeration literal, indexed by Pos\n    --  values, with an extra entry at the end containing Names'Length + 1.\n+   --  The parameter Hash is a (perfect) hash function for Names and Indexes.\n    --  The parameter Num is the value N - 1 (i.e. Enum'Pos (Enum'Last)).\n    --  The reason that Indexes is passed by address is that the actual type\n    --  is created on the fly by the expander.\n@@ -59,22 +67,4 @@ package System.Val_Enum is\n    --  If the image is found in Names, then the corresponding Pos value is\n    --  returned. If not, Constraint_Error is raised.\n \n-   function Value_Enumeration_16\n-     (Names   : String;\n-      Indexes : System.Address;\n-      Num     : Natural;\n-      Str     : String)\n-      return    Natural;\n-   --  Identical to Value_Enumeration_8 except that it handles types\n-   --  using array (0 .. Num) of Natural_16 for the Indexes table.\n-\n-   function Value_Enumeration_32\n-     (Names   : String;\n-      Indexes : System.Address;\n-      Num     : Natural;\n-      Str     : String)\n-      return    Natural;\n-   --  Identical to Value_Enumeration_8 except that it handles types\n-   --  using array (0 .. Num) of Natural_32 for the Indexes table.\n-\n-end System.Val_Enum;\n+end System.Value_N;", "previous_filename": "gcc/ada/libgnat/s-valenu.ads"}, {"sha": "09d6b45bacb4a1d9943746f4d75fbaf5892d14ee", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=c11207d345f8d678d440a3ff0f335b2ed25513e7", "patch": "@@ -259,8 +259,9 @@ package Rtsfind is\n       System_Img_Decimal_32,\n       System_Img_Decimal_64,\n       System_Img_Decimal_128,\n-      System_Img_Enum,\n-      System_Img_Enum_New,\n+      System_Img_Enum_8,\n+      System_Img_Enum_16,\n+      System_Img_Enum_32,\n       System_Img_Fixed_32,\n       System_Img_Fixed_64,\n       System_Img_Fixed_128,\n@@ -430,7 +431,9 @@ package Rtsfind is\n       System_Val_Decimal_32,\n       System_Val_Decimal_64,\n       System_Val_Decimal_128,\n-      System_Val_Enum,\n+      System_Val_Enum_8,\n+      System_Val_Enum_16,\n+      System_Val_Enum_32,\n       System_Val_Fixed_32,\n       System_Val_Fixed_64,\n       System_Val_Fixed_128,\n@@ -2663,9 +2666,11 @@ package Rtsfind is\n \n      RE_Image_Decimal128                 => System_Img_Decimal_128,\n \n-     RE_Image_Enumeration_8              => System_Img_Enum_New,\n-     RE_Image_Enumeration_16             => System_Img_Enum_New,\n-     RE_Image_Enumeration_32             => System_Img_Enum_New,\n+     RE_Image_Enumeration_8              => System_Img_Enum_8,\n+\n+     RE_Image_Enumeration_16             => System_Img_Enum_16,\n+\n+     RE_Image_Enumeration_32             => System_Img_Enum_32,\n \n      RE_Image_Float                      => System_Img_Flt,\n \n@@ -3720,9 +3725,11 @@ package Rtsfind is\n \n      RE_Value_Decimal128                 => System_Val_Decimal_128,\n \n-     RE_Value_Enumeration_8              => System_Val_Enum,\n-     RE_Value_Enumeration_16             => System_Val_Enum,\n-     RE_Value_Enumeration_32             => System_Val_Enum,\n+     RE_Value_Enumeration_8              => System_Val_Enum_8,\n+\n+     RE_Value_Enumeration_16             => System_Val_Enum_16,\n+\n+     RE_Value_Enumeration_32             => System_Val_Enum_32,\n \n      RE_Value_Fixed32                    => System_Val_Fixed_32,\n "}, {"sha": "d198bdca01013f5ae719b23c9237c395b1d46ff6", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11207d345f8d678d440a3ff0f335b2ed25513e7/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=c11207d345f8d678d440a3ff0f335b2ed25513e7", "patch": "@@ -834,10 +834,13 @@ package body Sem_Attr is\n \n       begin\n          --  Access and Unchecked_Access are illegal in declare_expressions,\n-         --  according to the RM. We also make the GNAT-specific\n-         --  Unrestricted_Access attribute illegal.\n+         --  according to the RM. We also make the GNAT Unrestricted_Access\n+         --  attribute illegal if it comes from source.\n \n-         if In_Declare_Expr > 0 then\n+         if In_Declare_Expr > 0\n+           and then (Attr_Id /= Attribute_Unrestricted_Access\n+                      or else Comes_From_Source (N))\n+         then\n             Error_Attr (\"% attribute cannot occur in a declare_expression\", N);\n          end if;\n "}]}