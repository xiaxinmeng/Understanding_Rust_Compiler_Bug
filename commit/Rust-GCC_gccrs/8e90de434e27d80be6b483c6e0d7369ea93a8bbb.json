{"sha": "8e90de434e27d80be6b483c6e0d7369ea93a8bbb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU5MGRlNDM0ZTI3ZDgwYmU2YjQ4M2M2ZTBkNzM2OWVhOTNhOGJiYg==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2013-05-25T10:31:43Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2013-05-25T10:31:43Z"}, "message": "sched-int.h (ds_t, dw_t): Make unsigned int.\n\n\n\t* sched-int.h (ds_t, dw_t): Make unsigned int.\n\tFix documentation that describes how all the ds_t bits are used.\n\tReserve the last bit for delayed-branch scheduling.\n\t(BITS_PER_DEP_STATUS): Move to ds_t typedef.\n\t(BITS_PER_DEP_WEAK): Fix definition and documentation.\n\t(gen_dep_weak_1): Remove prototype.\n\t* sched-deps.c (get_dep_weak_1): Make static.\n\t* target.def (speculate_insn, needs_block_p, gen_spec_check,\n\tget_insn_spec_ds, get_insn_checked_ds): Adjust hook prototypes.\n\t* doc/tm.texi: Regenerate.\n\t* config/ia64/ia64.c (ia64_needs_block_p): Update prototype.\n\nFrom-SVN: r199325", "tree": {"sha": "c8ab9fbf060c20d9e04751197d11b9393d752bd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8ab9fbf060c20d9e04751197d11b9393d752bd0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e90de434e27d80be6b483c6e0d7369ea93a8bbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e90de434e27d80be6b483c6e0d7369ea93a8bbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e90de434e27d80be6b483c6e0d7369ea93a8bbb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e90de434e27d80be6b483c6e0d7369ea93a8bbb/comments", "author": null, "committer": null, "parents": [{"sha": "a544998ee31436a079b74ff6e29c5d4ade7b6ba7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a544998ee31436a079b74ff6e29c5d4ade7b6ba7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a544998ee31436a079b74ff6e29c5d4ade7b6ba7"}], "stats": {"total": 151, "additions": 99, "deletions": 52}, "files": [{"sha": "b6f5899ebdfde47a72e5057bd4337bdd2843ff40", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e90de434e27d80be6b483c6e0d7369ea93a8bbb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e90de434e27d80be6b483c6e0d7369ea93a8bbb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e90de434e27d80be6b483c6e0d7369ea93a8bbb", "patch": "@@ -1,3 +1,17 @@\n+2013-05-25  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* sched-int.h (ds_t, dw_t): Make unsigned int.\n+\tFix documentation that describes how all the ds_t bits are used.\n+\tReserve the last bit for delayed-branch scheduling.\n+\t(BITS_PER_DEP_STATUS): Move to ds_t typedef.\n+\t(BITS_PER_DEP_WEAK): Fix definition and documentation.\n+\t(gen_dep_weak_1): Remove prototype.\n+\t* sched-deps.c (get_dep_weak_1): Make static.\n+\t* target.def (speculate_insn, needs_block_p, gen_spec_check,\n+\tget_insn_spec_ds, get_insn_checked_ds): Adjust hook prototypes.\n+\t* doc/tm.texi: Regenerate.\n+\t* config/ia64/ia64.c (ia64_needs_block_p): Update prototype.\n+\n 2013-05-24  Steven Bosscher  <steven@gcc.gnu.org>\n \n \tPR debug/56950"}, {"sha": "ee8ee5be3df8a68cbe86447f4285d9580484e620", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e90de434e27d80be6b483c6e0d7369ea93a8bbb/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e90de434e27d80be6b483c6e0d7369ea93a8bbb/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=8e90de434e27d80be6b483c6e0d7369ea93a8bbb", "patch": "@@ -170,7 +170,7 @@ static ds_t ia64_get_insn_spec_ds (rtx);\n static ds_t ia64_get_insn_checked_ds (rtx);\n static bool ia64_skip_rtx_p (const_rtx);\n static int ia64_speculate_insn (rtx, ds_t, rtx *);\n-static bool ia64_needs_block_p (int);\n+static bool ia64_needs_block_p (ds_t);\n static rtx ia64_gen_spec_check (rtx, rtx, ds_t);\n static int ia64_spec_check_p (rtx);\n static int ia64_spec_check_src_p (rtx);\n@@ -8341,9 +8341,7 @@ ia64_needs_block_p (ds_t ts)\n   return !(mflag_sched_spec_control_ldc && mflag_sched_spec_ldc);\n }\n \n-/* Generate (or regenerate, if (MUTATE_P)) recovery check for INSN.\n-   If (LABEL != 0 || MUTATE_P), generate branchy recovery check.\n-   Otherwise, generate a simple check.  */\n+/* Generate (or regenerate) a recovery check for INSN.  */\n static rtx\n ia64_gen_spec_check (rtx insn, rtx label, ds_t ds)\n {"}, {"sha": "cfde14af8acda8d4a348e90f1b19f542c34c87ad", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e90de434e27d80be6b483c6e0d7369ea93a8bbb/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e90de434e27d80be6b483c6e0d7369ea93a8bbb/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=8e90de434e27d80be6b483c6e0d7369ea93a8bbb", "patch": "@@ -6765,7 +6765,7 @@ Deallocate internal data in target scheduling context pointed to by @var{tc}.\n Deallocate a store for target scheduling context pointed to by @var{tc}.\n @end deftypefn\n \n-@deftypefn {Target Hook} int TARGET_SCHED_SPECULATE_INSN (rtx @var{insn}, int @var{request}, rtx *@var{new_pat})\n+@deftypefn {Target Hook} int TARGET_SCHED_SPECULATE_INSN (rtx @var{insn}, unsigned int @var{dep_status}, rtx *@var{new_pat})\n This hook is called by the insn scheduler when @var{insn} has only\n speculative dependencies and therefore can be scheduled speculatively.\n The hook is used to check if the pattern of @var{insn} has a speculative\n@@ -6776,13 +6776,13 @@ speculation.  If the return value equals 1 then @var{new_pat} is assigned\n the generated speculative pattern.\n @end deftypefn\n \n-@deftypefn {Target Hook} bool TARGET_SCHED_NEEDS_BLOCK_P (int @var{dep_status})\n+@deftypefn {Target Hook} bool TARGET_SCHED_NEEDS_BLOCK_P (unsigned int @var{dep_status})\n This hook is called by the insn scheduler during generation of recovery code\n for @var{insn}.  It should return @code{true}, if the corresponding check\n instruction should branch to recovery code, or @code{false} otherwise.\n @end deftypefn\n \n-@deftypefn {Target Hook} rtx TARGET_SCHED_GEN_SPEC_CHECK (rtx @var{insn}, rtx @var{label}, int @var{mutate_p})\n+@deftypefn {Target Hook} rtx TARGET_SCHED_GEN_SPEC_CHECK (rtx @var{insn}, rtx @var{label}, unsigned int @var{ds})\n This hook is called by the insn scheduler to generate a pattern for recovery\n check instruction.  If @var{mutate_p} is zero, then @var{insn} is a\n speculative instruction for which the check should be generated."}, {"sha": "c7ef1d8e67e977729d402a1b22844cedb1fb17f4", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e90de434e27d80be6b483c6e0d7369ea93a8bbb/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e90de434e27d80be6b483c6e0d7369ea93a8bbb/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=8e90de434e27d80be6b483c6e0d7369ea93a8bbb", "patch": "@@ -4170,8 +4170,9 @@ add_dependence_1 (rtx insn, rtx elem, enum reg_note dep_type)\n     cur_insn = NULL;\n }\n \n-/* Return weakness of speculative type TYPE in the dep_status DS.  */\n-dw_t\n+/* Return weakness of speculative type TYPE in the dep_status DS,\n+   without checking to prevent ICEs on malformed input.  */\n+static dw_t\n get_dep_weak_1 (ds_t ds, ds_t type)\n {\n   ds = ds & type;\n@@ -4188,6 +4189,7 @@ get_dep_weak_1 (ds_t ds, ds_t type)\n   return (dw_t) ds;\n }\n \n+/* Return weakness of speculative type TYPE in the dep_status DS.  */\n dw_t\n get_dep_weak (ds_t ds, ds_t type)\n {"}, {"sha": "90d5b05c75e4b19fdfa27f74639e33bc98715179", "filename": "gcc/sched-int.h", "status": "modified", "additions": 68, "deletions": 34, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e90de434e27d80be6b483c6e0d7369ea93a8bbb/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e90de434e27d80be6b483c6e0d7369ea93a8bbb/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=8e90de434e27d80be6b483c6e0d7369ea93a8bbb", "patch": "@@ -193,10 +193,11 @@ extern void sched_create_recovery_edges (basic_block, basic_block,\n extern state_t curr_state;\n \n /* Type to represent status of a dependence.  */\n-typedef int ds_t;\n+typedef unsigned int ds_t;\n+#define BITS_PER_DEP_STATUS HOST_BITS_PER_INT\n \n /* Type to represent weakness of speculative dependence.  */\n-typedef int dw_t;\n+typedef unsigned int dw_t;\n \n extern enum reg_note ds_to_dk (ds_t);\n extern ds_t dk_to_ds (enum reg_note);\n@@ -743,6 +744,7 @@ struct _haifa_deps_insn_data\n   unsigned int cant_move : 1;\n };\n \n+\f\n /* Bits used for storing values of the fields in the following\n    structure.  */\n #define INCREASE_BITS 8\n@@ -952,33 +954,53 @@ extern vec<haifa_deps_insn_data_def> h_d_i_d;\n #define IS_SPECULATION_BRANCHY_CHECK_P(INSN) \\\n   (RECOVERY_BLOCK (INSN) != NULL && RECOVERY_BLOCK (INSN) != EXIT_BLOCK_PTR)\n \n-/* Dep status (aka ds_t) of the link encapsulates information, that is needed\n-   for speculative scheduling.  Namely, it is 4 integers in the range\n-   [0, MAX_DEP_WEAK] and 3 bits.\n-   The integers correspond to the probability of the dependence to *not*\n-   exist, it is the probability, that overcoming of this dependence will\n-   not be followed by execution of the recovery code.  Nevertheless,\n-   whatever high the probability of success is, recovery code should still\n-   be generated to preserve semantics of the program.  To find a way to\n-   get/set these integers, please refer to the {get, set}_dep_weak ()\n-   functions in sched-deps.c .\n-   The 3 bits in the DEP_STATUS correspond to 3 dependence types: true-,\n-   output- and anti- dependence.  It is not enough for speculative scheduling\n-   to know just the major type of all the dependence between two instructions,\n-   as only true dependence can be overcome.\n-   There also is the 4-th bit in the DEP_STATUS (HARD_DEP), that is reserved\n-   for using to describe instruction's status.  It is set whenever instruction\n-   has at least one dependence, that cannot be overcame.\n-   See also: check_dep_status () in sched-deps.c .  */\n+\f\n+/* Dep status (aka ds_t) of the link encapsulates all information for a given\n+   dependency, including everything that is needed for speculative scheduling.\n+\n+   The lay-out of a ds_t is as follows:\n+\n+   1. Integers corresponding to the probability of the dependence to *not*\n+      exist.  This is the probability that overcoming this dependence will\n+      not be followed by execution of the recovery code.  Note that however\n+      high this probability is, the recovery code should still always be\n+      generated to preserve semantics of the program.\n+\n+      The probability values can be set or retrieved using the functions\n+      the set_dep_weak() and get_dep_weak() in sched-deps.c.  The values\n+      are always in the range [0, MAX_DEP_WEAK].\n+\n+\tBEGIN_DATA\t: BITS_PER_DEP_WEAK\n+\tBE_IN_DATA\t: BITS_PER_DEP_WEAK\n+\tBEGIN_CONTROL\t: BITS_PER_DEP_WEAK\n+\tBE_IN_CONTROL\t: BITS_PER_DEP_WEAK\n+\n+      The basic type of DS_T is a host int.  For a 32-bits int, the values\n+      will each take 6 bits.\n \n-/* We exclude sign bit.  */\n-#define BITS_PER_DEP_STATUS (HOST_BITS_PER_INT - 1)\n+   2. The type of dependence.  This supercedes the old-style REG_NOTE_KIND\n+      values.  TODO: Use this field instead of DEP_TYPE, or make DEP_TYPE\n+      extract the dependence type from here.\n \n-/* First '6' stands for 4 dep type bits and the HARD_DEP and DEP_CANCELLED\n-   bits.\n-   Second '4' stands for BEGIN_{DATA, CONTROL}, BE_IN_{DATA, CONTROL}\n-   dep weakness.  */\n-#define BITS_PER_DEP_WEAK ((BITS_PER_DEP_STATUS - 6) / 4)\n+\tdep_type\t:  4 => DEP_{TRUE|OUTPUT|ANTI|CONTROL}\n+\n+   3. Various flags:\n+\n+\tHARD_DEP\t:  1 =>\tSet if an instruction has a non-speculative\n+\t\t\t\tdependence.  This is an instruction property\n+\t\t\t\tso this bit can only appear in the TODO_SPEC\n+\t\t\t\tfield of an instruction.\n+\tDEP_POSTPONED\t:  1 =>\tLike HARD_DEP, but the hard dependence may\n+\t\t\t\tstill be broken by adjusting the instruction.\n+\tDEP_CANCELLED\t:  1 =>\tSet if a dependency has been broken using\n+\t\t\t\tsome form of speculation.\n+\tRESERVED\t:  1 => Reserved for use in the delay slot scheduler.\n+\n+   See also: check_dep_status () in sched-deps.c .  */\n+\n+/* The number of bits per weakness probability.  There are 4 weakness types\n+   and we need 8 bits for other data in a DS_T.  */\n+#define BITS_PER_DEP_WEAK ((BITS_PER_DEP_STATUS - 8) / 4)\n \n /* Mask of speculative weakness in dep_status.  */\n #define DEP_WEAK_MASK ((1 << BITS_PER_DEP_WEAK) - 1)\n@@ -996,7 +1018,9 @@ extern vec<haifa_deps_insn_data_def> h_d_i_d;\n #define MIN_DEP_WEAK 1\n \n /* This constant represents 100% probability.\n-   E.g. it is used to represent weakness of dependence, that doesn't exist.  */\n+   E.g. it is used to represent weakness of dependence, that doesn't exist.\n+   This value never appears in a ds_t, it is only used for computing the\n+   weakness of a dependence.  */\n #define NO_DEP_WEAK (MAX_DEP_WEAK + MIN_DEP_WEAK)\n \n /* Default weakness of speculative dependence.  Used when we can't say\n@@ -1011,8 +1035,10 @@ enum SPEC_TYPES_OFFSETS {\n   BE_IN_CONTROL_BITS_OFFSET = BEGIN_CONTROL_BITS_OFFSET + BITS_PER_DEP_WEAK\n };\n \n-/* The following defines provide numerous constants used to distinguish between\n-   different types of speculative dependencies.  */\n+/* The following defines provide numerous constants used to distinguish\n+   between different types of speculative dependencies.  They are also\n+   used as masks to clear/preserve the bits corresponding to the type\n+   of dependency weakness.  */\n \n /* Dependence can be overcome with generation of new data speculative\n    instruction.  */\n@@ -1058,15 +1084,24 @@ enum SPEC_TYPES_OFFSETS {\n \n /* Instruction has non-speculative dependence.  This bit represents the\n    property of an instruction - not the one of a dependence.\n-   Therefore, it can appear only in TODO_SPEC field of an instruction.  */\n+   Therefore, it can appear only in the TODO_SPEC field of an instruction.  */\n #define HARD_DEP (DEP_CONTROL << 1)\n \n-/* Set in the TODO_SPEC field of an instruction for which new_ready\n-   has decided not to schedule it speculatively.  */\n+/* Like HARD_DEP, but dependencies can perhaps be broken by modifying\n+   the instructions.  This is used for example to change:\n+\n+   rn++\t\t=>\trm=[rn + 4]\n+   rm=[rn]\t\trn++\n+\n+   For instructions that have this bit set, one of the dependencies of\n+   the instructions will have a non-NULL REPLACE field in its DEP_T.\n+   Just like HARD_DEP, this bit is only ever set in TODO_SPEC.  */\n #define DEP_POSTPONED (HARD_DEP << 1)\n \n+/* Set if a dependency is cancelled via speculation.  */\n #define DEP_CANCELLED (DEP_POSTPONED << 1)\n \n+\f\n /* This represents the results of calling sched-deps.c functions,\n    which modify dependencies.  */\n enum DEPS_ADJUST_RESULT {\n@@ -1268,7 +1303,6 @@ extern void deps_analyze_insn (struct deps_desc *, rtx);\n extern void remove_from_deps (struct deps_desc *, rtx);\n extern void init_insn_reg_pressure_info (rtx);\n \n-extern dw_t get_dep_weak_1 (ds_t, ds_t);\n extern dw_t get_dep_weak (ds_t, ds_t);\n extern ds_t set_dep_weak (ds_t, ds_t, dw_t);\n extern dw_t estimate_dep_weak (rtx, rtx);"}, {"sha": "f4776a8df3773f637751b8baef5d7cd6e94ba036", "filename": "gcc/target.def", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e90de434e27d80be6b483c6e0d7369ea93a8bbb/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e90de434e27d80be6b483c6e0d7369ea93a8bbb/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=8e90de434e27d80be6b483c6e0d7369ea93a8bbb", "patch": "@@ -780,7 +780,7 @@ DEFHOOK_UNDOC\n  \"Given the current cost, @var{cost}, of an insn, @var{insn}, calculate and\\\n  return a new cost based on its relationship to @var{dep_insn} through the\\\n  dependence of weakness @var{dw}.  The default is to make no adjustment.\",\n- int, (rtx insn, int dep_type1, rtx dep_insn, int cost, int dw), NULL)\n+ int, (rtx insn, int dep_type1, rtx dep_insn, int cost, unsigned int dw), NULL)\n \n /* The following member value is a pointer to a function called\n    by the insn scheduler. This hook is called to notify the backend\n@@ -835,28 +835,27 @@ DEFHOOK\n DEFHOOK\n (speculate_insn,\n  \"\",\n- int, (rtx insn, int request, rtx *new_pat), NULL)\n+ int, (rtx insn, unsigned int dep_status, rtx *new_pat), NULL)\n \n /* The following member value is a pointer to a function called\n    by the insn scheduler.  It should return true if the check instruction\n    passed as the parameter needs a recovery block.  */\n DEFHOOK\n (needs_block_p,\n  \"\",\n- bool, (int dep_status), NULL)\n+ bool, (unsigned int dep_status), NULL)\n \n /* The following member value is a pointer to a function called\n    by the insn scheduler.  It should return a pattern for the check\n    instruction.\n    The first parameter is a speculative instruction, the second parameter\n    is the label of the corresponding recovery block (or null, if it is a\n-   simple check).  If the mutation of the check is requested (e.g. from\n-   ld.c to chk.a), the third parameter is true - in this case the first\n-   parameter is the previous check.  */\n+   simple check).  The third parameter is the kind of speculation that\n+   is being performed.  */\n DEFHOOK\n (gen_spec_check,\n  \"\",\n- rtx, (rtx insn, rtx label, int mutate_p), NULL)\n+ rtx, (rtx insn, rtx label, unsigned int ds), NULL)\n \n /* The following member value is a pointer to a function controlling\n    what insns from the ready insn queue will be considered for the\n@@ -880,12 +879,12 @@ DEFHOOK\n DEFHOOK_UNDOC\n (get_insn_spec_ds,\n  \"Return speculation types of instruction @var{insn}.\",\n- int, (rtx insn), NULL)\n+ unsigned int, (rtx insn), NULL)\n \n DEFHOOK_UNDOC\n (get_insn_checked_ds,\n  \"Return speculation types that are checked for instruction @var{insn}\",\n- int, (rtx insn), NULL)\n+ unsigned int, (rtx insn), NULL)\n \n DEFHOOK_UNDOC\n (skip_rtx_p,"}]}