{"sha": "dab66575b48e837d71b2d2363c1b8aea1eb268a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGFiNjY1NzViNDhlODM3ZDcxYjJkMjM2M2MxYjhhZWExZWIyNjhhMQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-07-03T12:34:09Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-07-03T12:34:09Z"}, "message": "m32r.c: Fix comment typos.\n\n\t* config/m32r/m32r.c: Fix comment typos.\n\t* config/m68hc11/m68hc11.c: Likewise.\n\t* config/m68hc11/m68hc11.h: Likewise.\n\t* config/m68k/m68k.c: Likewise.\n\t* config/mcore/mcore.c: Likewise.\n\t* config/mcore/mcore.h: Likewise.\n\t* config/mcore/mcore.md: Likewise.\n\t* config/mips/mips.c: Likewise.\n\t* config/mips/mips.h: Likewise.\n\t* config/mips/mips.md: Likewise.\n\t* config/mips/netbsd.h: Likewise.\n\t* config/mn10300/mn10300.c: Likewise.\n\nFrom-SVN: r68876", "tree": {"sha": "1cd930fd71049c140cd57c9136427f478a715d30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1cd930fd71049c140cd57c9136427f478a715d30"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dab66575b48e837d71b2d2363c1b8aea1eb268a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dab66575b48e837d71b2d2363c1b8aea1eb268a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dab66575b48e837d71b2d2363c1b8aea1eb268a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dab66575b48e837d71b2d2363c1b8aea1eb268a1/comments", "author": null, "committer": null, "parents": [{"sha": "8837d828e78c9f8237f463bd7893e754da76a2fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8837d828e78c9f8237f463bd7893e754da76a2fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8837d828e78c9f8237f463bd7893e754da76a2fe"}], "stats": {"total": 81, "additions": 48, "deletions": 33}, "files": [{"sha": "61c2e01a3fcc2618996b388205cc5708251792a9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dab66575b48e837d71b2d2363c1b8aea1eb268a1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dab66575b48e837d71b2d2363c1b8aea1eb268a1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dab66575b48e837d71b2d2363c1b8aea1eb268a1", "patch": "@@ -1,3 +1,18 @@\n+2003-07-03  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/m32r/m32r.c: Fix comment typos.\n+\t* config/m68hc11/m68hc11.c: Likewise.\n+\t* config/m68hc11/m68hc11.h: Likewise.\n+\t* config/m68k/m68k.c: Likewise.\n+\t* config/mcore/mcore.c: Likewise.\n+\t* config/mcore/mcore.h: Likewise.\n+\t* config/mcore/mcore.md: Likewise.\n+\t* config/mips/mips.c: Likewise.\n+\t* config/mips/mips.h: Likewise.\n+\t* config/mips/mips.md: Likewise.\n+\t* config/mips/netbsd.h: Likewise.\n+\t* config/mn10300/mn10300.c: Likewise.\n+\n 2003-07-03  Andreas Schwab  <schwab@suse.de>\n \n \t* dbxout.c (pending_bincls): Move decl down inside"}, {"sha": "e1dbce4bcadea7a63c0dd3b5a6ea33a4e588af19", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dab66575b48e837d71b2d2363c1b8aea1eb268a1/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dab66575b48e837d71b2d2363c1b8aea1eb268a1/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=dab66575b48e837d71b2d2363c1b8aea1eb268a1", "patch": "@@ -1028,7 +1028,7 @@ m32r_pass_by_reference (type)\n /* X and Y are two things to compare using CODE.  Emit the compare insn and\n    return the rtx for compare [arg0 of the if_then_else].\n    If need_compare is true then the comparison insn must be generated, rather\n-   than being susummed into the following branch instruction.  */\n+   than being subsumed into the following branch instruction.  */\n \n rtx\n gen_compare (code, x, y, need_compare)\n@@ -1307,7 +1307,7 @@ gen_split_move_double (operands)\n \t\tld r1,r3+; ld r2,r3\n \n \t     if r3 were not used subsequently.  However, the REG_NOTES aren't\n-\t     propigated correctly by the reload phase, and it can cause bad\n+\t     propagated correctly by the reload phase, and it can cause bad\n \t     code to be generated.  We could still try:\n \n \t\tld r1,r3+; ld r2,r3; addi r3,-4\n@@ -1334,7 +1334,7 @@ gen_split_move_double (operands)\n \tst r1,r3; st r2,+r3\n \n      if r3 were not used subsequently.  However, the REG_NOTES aren't\n-     propigated correctly by the reload phase, and it can cause bad\n+     propagated correctly by the reload phase, and it can cause bad\n      code to be generated.  We could still try:\n \n \tst r1,r3; st r2,+r3; addi r3,-4\n@@ -1579,7 +1579,7 @@ m32r_sched_reorder (stream, verbose, ready, n_readyp, clock)\n       rtx * new_tail = new_head + (n_ready - 1);\n       int   i;\n \n-      /* Loop through the instructions, classifing them as short/long.  Try\n+      /* Loop through the instructions, classifying them as short/long.  Try\n \t to keep 2 short together and/or 1 long.  Note, the ready list is\n \t actually ordered backwards, so keep it in that manner.  */\n       for (i = n_ready-1; i >= 0; i--)\n@@ -2586,7 +2586,7 @@ conditional_move_operand (operand, mode)\n   if (mode != SImode && mode != HImode && mode != QImode)\n     return FALSE;\n \n-  /* At the moment we can hanndle moving registers and loading constants.  */\n+  /* At the moment we can handle moving registers and loading constants.  */\n   /* To be added: Addition/subtraction/bitops/multiplication of registers.  */\n \n   switch (GET_CODE (operand))\n@@ -2728,7 +2728,7 @@ block_move_call (dest_reg, src_reg, bytes_rtx)\n \n /* The maximum number of bytes to copy using pairs of load/store instructions.\n    If a block is larger than this then a loop will be generated to copy\n-   MAX_MOVE_BYTES chunks at a time.  The value of 32 is a semi-arbitary choice.\n+   MAX_MOVE_BYTES chunks at a time.  The value of 32 is a semi-arbitrary choice.\n    A customer uses Dhrystome as their benchmark, and Dhrystone has a 31 byte\n    string copy in it.  */\n #define MAX_MOVE_BYTES 32\n@@ -2788,7 +2788,7 @@ m32r_expand_block_move (operands)\n       /* If we are going to have to perform this loop more than\n \t once, then generate a label and compute the address the\n \t source register will contain upon completion of the final\n-\t itteration.  */\n+\t iteration.  */\n       if (bytes > MAX_MOVE_BYTES)\n \t{\n \t  final_src = gen_reg_rtx (Pmode);"}, {"sha": "61e88de5b96cf8be492f69fdde4c5398b83e6966", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dab66575b48e837d71b2d2363c1b8aea1eb268a1/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dab66575b48e837d71b2d2363c1b8aea1eb268a1/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=dab66575b48e837d71b2d2363c1b8aea1eb268a1", "patch": "@@ -2366,7 +2366,7 @@ print_operand (file, op, letter)\n }\n \n /* Returns true if the operand 'op' must be printed with parenthesis\n-   arround it.  This must be done only if there is a symbol whose name\n+   around it.  This must be done only if there is a symbol whose name\n    is a processor register.  */\n static int\n must_parenthesize (op)\n@@ -4881,7 +4881,7 @@ m68hc11_find_z_replacement (insn, info)\n /* The insn uses the Z register.  Find a replacement register for it\n    (either X or Y) and replace it in the insn and the next ones until\n    the flow changes or the replacement register is used.  Instructions\n-   are emited before and after the Z-block to preserve the value of\n+   are emitted before and after the Z-block to preserve the value of\n    Z and of the replacement register.  */\n \n static void"}, {"sha": "476c0d0f2c3861c6e8271d42a5c8373d03a933df", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dab66575b48e837d71b2d2363c1b8aea1eb268a1/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dab66575b48e837d71b2d2363c1b8aea1eb268a1/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=dab66575b48e837d71b2d2363c1b8aea1eb268a1", "patch": "@@ -1617,7 +1617,7 @@ do {                                                                    \\\n \f\n /* Assembler Commands for Exception Regions.  */\n \n-/* Default values provided by GCC should be ok. Assumming that DWARF-2\n+/* Default values provided by GCC should be ok. Assuming that DWARF-2\n    frame unwind info is ok for this platform.  */\n \n #undef PREFERRED_DEBUGGING_TYPE"}, {"sha": "40d141cb6f7f62b3bfc540c3a26eaeeab88de341", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dab66575b48e837d71b2d2363c1b8aea1eb268a1/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dab66575b48e837d71b2d2363c1b8aea1eb268a1/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=dab66575b48e837d71b2d2363c1b8aea1eb268a1", "patch": "@@ -3388,7 +3388,7 @@ const_sint32_operand (op, mode)\n \n /* Operand predicates for implementing asymmetric pc-relative addressing\n    on m68k.  The m68k supports pc-relative addressing (mode 7, register 2)\n-   when used as a source operand, but not as a destintation operand.\n+   when used as a source operand, but not as a destination operand.\n \n    We model this by restricting the meaning of the basic predicates\n    (general_operand, memory_operand, etc) to forbid the use of this"}, {"sha": "d88307aed2300133a40e4e9bd13cf0748f2601b3", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dab66575b48e837d71b2d2363c1b8aea1eb268a1/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dab66575b48e837d71b2d2363c1b8aea1eb268a1/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=dab66575b48e837d71b2d2363c1b8aea1eb268a1", "patch": "@@ -2370,7 +2370,7 @@ mcore_setup_incoming_varargs (args_so_far, mode, type, ptr_pretend_size)\n      registers during the prologue.  */\n   number_of_regs_before_varargs = args_so_far + mcore_num_arg_regs (mode, type);\n   \n-  /* There is a bug somwehere in the arg handling code.\n+  /* There is a bug somewhere in the arg handling code.\n      Until I can find it this workaround always pushes the\n      last named argument onto the stack.  */\n   number_of_regs_before_varargs = args_so_far;\n@@ -2586,7 +2586,7 @@ mcore_expand_epilog ()\n     }\n \n   /* Give back anything else.  */\n-  /* XXX: Should accumuate total and then give it back.  */\n+  /* XXX: Should accumulate total and then give it back.  */\n   while (growth >= 0)\n     output_stack_adjust ( 1, fi.growth[growth--]);\n }\n@@ -3147,7 +3147,7 @@ mcore_must_pass_on_stack (mode, type)\n   if (type == NULL)\n     return 0;\n \n-  /* If the argugment can have its address taken, it must\n+  /* If the argument can have its address taken, it must\n      be placed on the stack.  */\n   if (TREE_ADDRESSABLE (type))\n     return 1;\n@@ -3280,7 +3280,7 @@ mcore_function_arg (cum, mode, type, named)\n /* Implements the FUNCTION_ARG_PARTIAL_NREGS macro.\n    Returns the number of argument registers required to hold *part* of\n    a parameter of machine mode MODE and type TYPE (which may be NULL if\n-   the type is not known).  If the argument fits entirly in the argument\n+   the type is not known).  If the argument fits entirely in the argument\n    registers, or entirely on the stack, then 0 is returned.  CUM is the\n    number of argument registers already used by earlier parameters to\n    the function.  */"}, {"sha": "dddd5c1523264d4eeb8ca570923c83e75ca26488", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dab66575b48e837d71b2d2363c1b8aea1eb268a1/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dab66575b48e837d71b2d2363c1b8aea1eb268a1/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=dab66575b48e837d71b2d2363c1b8aea1eb268a1", "patch": "@@ -258,7 +258,7 @@ extern const char * mcore_stack_increment_string;\n /* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n #define PARM_BOUNDARY  \t32\n \n-/* Doubles must be alogned to an 8 byte boundary.  */\n+/* Doubles must be aligned to an 8 byte boundary.  */\n #define FUNCTION_ARG_BOUNDARY(MODE, TYPE) \\\n   ((MODE != BLKmode && (GET_MODE_SIZE (MODE) == 8)) \\\n    ? BIGGEST_ALIGNMENT : PARM_BOUNDARY)\n@@ -790,7 +790,7 @@ extern const enum reg_class reg_class_from_letter[];\n /* Output assembler code for a block containing the constant parts\n    of a trampoline, leaving space for the variable parts.\n \n-   On the MCore, the trapoline looks like:\n+   On the MCore, the trampoline looks like:\n    \tlrw\tr1,  function\n      \tlrw\tr13, area\n    \tjmp\tr13\n@@ -1195,7 +1195,7 @@ extern long mcore_current_compilation_timestamp;\n    games. This is because when we use this, we get a marked \n    reference through the call to assemble_name and this forces C++\n    inlined member functions (or any inlined function) to be instantiated\n-   regardless of whether any callsites remain.\n+   regardless of whether any call sites remain.\n    This makes this aspect of the compiler non-ABI compliant.  */\n \n /* Similar, but for libcall. FUN is an rtx.  */"}, {"sha": "bfdd844c21a3c83bd38054e2294fdae0806645cd", "filename": "gcc/config/mcore/mcore.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dab66575b48e837d71b2d2363c1b8aea1eb268a1/gcc%2Fconfig%2Fmcore%2Fmcore.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dab66575b48e837d71b2d2363c1b8aea1eb268a1/gcc%2Fconfig%2Fmcore%2Fmcore.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.md?ref=dab66575b48e837d71b2d2363c1b8aea1eb268a1", "patch": "@@ -691,7 +691,7 @@\n ;;\n ;; Other sizes may be handy for indexing. \n ;; the tradeoffs to consider when adding these are\n-;;\tcodesize, execution time [vs. mul it is easy to win],\n+;;\tcode size, execution time [vs. mul it is easy to win],\n ;;\tand register pressure -- these patterns don't use an extra\n ;;\tregister to build the offset from the base\n ;;\tand whether the compiler will not come up with some other idiom."}, {"sha": "c4cbbc56570e0a8e9de9f7b8050c24c33aae59b7", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dab66575b48e837d71b2d2363c1b8aea1eb268a1/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dab66575b48e837d71b2d2363c1b8aea1eb268a1/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=dab66575b48e837d71b2d2363c1b8aea1eb268a1", "patch": "@@ -1141,7 +1141,7 @@ mips_classify_address (info, x, mode, strict, lea_p)\n       return ADDRESS_INVALID;\n \n     case CONST_INT:\n-      /* Small-integer addressses don't occur very often, but they\n+      /* Small-integer addresses don't occur very often, but they\n \t are legitimate if $0 is a valid base register.  */\n       if (!TARGET_MIPS16 && SMALL_INT (x))\n \treturn ADDRESS_CONST_INT;\n@@ -1591,7 +1591,7 @@ cmp_op (op, mode)\n }\n \n /* Return nonzero if the code is a relational operation suitable for a\n-   conditional trap instructuion (only EQ, NE, LT, LTU, GE, GEU).\n+   conditional trap instruction (only EQ, NE, LT, LTU, GE, GEU).\n    We need this in the insn that expands `trap_if' in order to prevent\n    combine from erroneously altering the condition.  */\n \n@@ -3927,7 +3927,7 @@ mips_arg_info (cum, mode, type, named, info)\n \t\t\t|| TREE_CODE (type) == QUAL_UNION_TYPE));\n \n   /* Decide whether this argument should go in a floating-point register,\n-     assuming one is free.  Later code checks for availablity.  */\n+     assuming one is free.  Later code checks for availability.  */\n \n   info->fpr_p = false;\n   if (GET_MODE_CLASS (mode) == MODE_FLOAT\n@@ -7808,7 +7808,7 @@ mips_select_rtx_section (mode, x, align)\n     {\n       /* For hosted applications, always put constants in small data if\n \t possible, as this gives the best performance.  */\n-      /* ??? Consider using mergable small data sections.  */\n+      /* ??? Consider using mergeable small data sections.  */\n \n       if (GET_MODE_SIZE (mode) <= (unsigned) mips_section_threshold\n \t  && mips_section_threshold > 0)\n@@ -7985,18 +7985,18 @@ mips_encode_section_info (decl, rtl, first)\n          There are three cases to consider:\n \n             - o32 PIC (either with or without explicit relocs)\n-            - n32/n64 PIC without explict relocs\n+            - n32/n64 PIC without explicit relocs\n             - n32/n64 PIC with explicit relocs\n \n          In the first case, both local and global accesses will use an\n          R_MIPS_GOT16 relocation.  We must correctly predict which of\n          the two semantics (local or global) the assembler and linker\n          will apply.  The choice doesn't depend on the symbol's\n-         visibility, so we deliberately ignore decl_visiblity and\n+         visibility, so we deliberately ignore decl_visibility and\n          binds_local_p here.\n \n          In the second case, the assembler will not use R_MIPS_GOT16\n-         relocations, but it chooses between local and global accessees\n+         relocations, but it chooses between local and global accesses\n          in the same way as for o32 PIC.\n \n          In the third case we have more freedom since both forms of\n@@ -8519,7 +8519,7 @@ mips16_fp_args (file, fp_code, from_fp_p)\n }\n \n /* Build a mips16 function stub.  This is used for functions which\n-   take aruments in the floating point registers.  It is 32 bit code\n+   take arguments in the floating point registers.  It is 32 bit code\n    that moves the floating point args into the general registers, and\n    then jumps to the 16 bit code.  */\n "}, {"sha": "cf249b8e30ab6c9ae2b886d41f3024926b558a11", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dab66575b48e837d71b2d2363c1b8aea1eb268a1/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dab66575b48e837d71b2d2363c1b8aea1eb268a1/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=dab66575b48e837d71b2d2363c1b8aea1eb268a1", "patch": "@@ -1622,7 +1622,7 @@ do {\t\t\t\t\t\t\t\\\n    done, NIL if none.\n \n    When in 64 bit mode, mips_move_1word will sign extend SImode and CCmode\n-   moves.  All other referces are zero extended.  */\n+   moves.  All other references are zero extended.  */\n #define LOAD_EXTEND_OP(MODE) \\\n   (TARGET_64BIT && ((MODE) == SImode || (MODE) == CCmode) \\\n    ? SIGN_EXTEND : ZERO_EXTEND)\n@@ -1732,7 +1732,7 @@ do {\t\t\t\t\t\t\t\\\n    all the FIXED_REGISTERS.  Until this problem has been\n    resolved this macro can be used to overcome this situation.\n    In particular, block_propagate() requires this list\n-   be acurate, or we can remove registers which should be live.\n+   be accurate, or we can remove registers which should be live.\n    This macro is used in regs_invalidated_by_call.  */\n \n \n@@ -2382,7 +2382,7 @@ extern enum reg_class mips_char_to_class[256];\n /* The return address for the current frame is in r31 if this is a leaf\n    function.  Otherwise, it is on the stack.  It is at a variable offset\n    from sp/fp/ap, so we define a fake hard register rap which is a\n-   poiner to the return address on the stack.  This always gets eliminated\n+   pointer to the return address on the stack.  This always gets eliminated\n    during reload to be either the frame pointer or the stack pointer plus\n    an offset.  */\n "}, {"sha": "0be11733250f48493905360bc0bf744ae9241ecb", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dab66575b48e837d71b2d2363c1b8aea1eb268a1/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dab66575b48e837d71b2d2363c1b8aea1eb268a1/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=dab66575b48e837d71b2d2363c1b8aea1eb268a1", "patch": "@@ -8819,7 +8819,7 @@ ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2%/\"\n \n ;; call_insn_operand will only accepts constant addresses if a direct\n ;; jump is acceptable.  Since the 'S' constraint is defined in terms of\n-;; call_insn_operand, the same is true of the contraints.\n+;; call_insn_operand, the same is true of the constraints.\n \n ;; When we use an indirect jump, we need a register that will be\n ;; preserved by the epilogue.  Since TARGET_ABICALLS forces us to"}, {"sha": "3e6d2a7f45927ea3833ffabfc71e0fddb1a8e6fd", "filename": "gcc/config/mips/netbsd.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dab66575b48e837d71b2d2363c1b8aea1eb268a1/gcc%2Fconfig%2Fmips%2Fnetbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dab66575b48e837d71b2d2363c1b8aea1eb268a1/gcc%2Fconfig%2Fmips%2Fnetbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fnetbsd.h?ref=dab66575b48e837d71b2d2363c1b8aea1eb268a1", "patch": "@@ -58,7 +58,7 @@ Boston, MA 02111-1307, USA.  */\n    them here.  Note this is structured for easy comparison to the version\n    in mips.h.\n \n-   FIXME: This probably isn't the best solution.  But in the absense\n+   FIXME: This probably isn't the best solution.  But in the absence\n    of something better, it will have to do, for now.  */\n \n #undef TARGET_CPU_CPP_BUILTINS"}, {"sha": "df5d35fb7701069134a012ef1098b965569c235c", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dab66575b48e837d71b2d2363c1b8aea1eb268a1/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dab66575b48e837d71b2d2363c1b8aea1eb268a1/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=dab66575b48e837d71b2d2363c1b8aea1eb268a1", "patch": "@@ -581,7 +581,7 @@ expand_epilogue ()\n      Else leave it alone, it will be cut back as part of the\n      ret/retf instruction, or there wasn't any stack to begin with.\n \n-     Under no circumstanes should the register save area be\n+     Under no circumstances should the register save area be\n      deallocated here, that would leave a window where an interrupt\n      could occur and trash the register save area.  */\n   if (frame_pointer_needed)"}]}