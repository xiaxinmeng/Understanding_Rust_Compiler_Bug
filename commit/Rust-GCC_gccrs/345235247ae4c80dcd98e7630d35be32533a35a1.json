{"sha": "345235247ae4c80dcd98e7630d35be32533a35a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ1MjM1MjQ3YWU0YzgwZGNkOThlNzYzMGQzNWJlMzI1MzNhMzVhMQ==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2008-06-02T20:03:03Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2008-06-02T20:03:03Z"}, "message": "gfortran.h: New statement-type ST_FINAL for FINAL declarations.\n\n2008-06-02  Daniel Kraft  <d@domob.eu>\n\n        * gfortran.h:  New statement-type ST_FINAL for FINAL declarations.\n        (struct gfc_symbol):  New member f2k_derived.\n        (struct gfc_namespace):  New member finalizers, for use in the above\n        mentioned f2k_derived namespace.\n        (struct gfc_finalizer):  New type defined for finalizers linked list.\n        * match.h (gfc_match_final_decl):  New function header.\n        * decl.c (gfc_match_derived_decl):  Create f2k_derived namespace\n        on constructed symbol node.\n        (gfc_match_final_decl):  New function to match a FINAL declaration line.\n        * parse.c (decode_statement):  match-call for keyword FINAL.\n        (parse_derived):  Parse CONTAINS section and accept FINAL statements.\n        * resolve.c (gfc_resolve_finalizers):  New function to resolve\n        (that is in this case, check) a list of finalizer procedures.\n        (resolve_fl_derived):  Call gfc_resolve_finalizers here.\n        * symbol.c (gfc_get_namespace):  Initialize new finalizers to NULL.\n        (gfc_free_namespace):  Free finalizers list.\n        (gfc_new_symbol):  Initialize new f2k_derived to NULL.\n        (gfc_free_symbol):  Free f2k_derived namespace.\n        (gfc_free_finalizer):  New function to free a single gfc_finalizer node.\n        (gfc_free_finalizer_list):  New function to free a linked list of\n        gfc_finalizer nodes.\n\n2008-06-02  Daniel Kraft  <d@domob.eu>\n\n        * finalize_1.f08:  New test.\n        * finalize_2.f03:  New test.\n        * finalize_3.f03:  New test.\n        * finalize_4.f03:  New test.\n        * finalize_5.f03:  New test.\n        * finalize_6.f90:  New test.\n        * finalize_7.f03:  New test.\n        * finalize_8.f03:  New test.\n\nFrom-SVN: r136293", "tree": {"sha": "f807af3263648b3c930fb63529f59d6393a35f3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f807af3263648b3c930fb63529f59d6393a35f3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/345235247ae4c80dcd98e7630d35be32533a35a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/345235247ae4c80dcd98e7630d35be32533a35a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/345235247ae4c80dcd98e7630d35be32533a35a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/345235247ae4c80dcd98e7630d35be32533a35a1/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "236ec2d7eeb645497c80e1e67cde4c490cce44a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/236ec2d7eeb645497c80e1e67cde4c490cce44a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/236ec2d7eeb645497c80e1e67cde4c490cce44a1"}], "stats": {"total": 780, "additions": 778, "deletions": 2}, "files": [{"sha": "1a3d2dac94aab6f3653233b40965e18d02a118b5", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=345235247ae4c80dcd98e7630d35be32533a35a1", "patch": "@@ -1,3 +1,27 @@\n+2008-06-02  Daniel Kraft  <d@domob.eu>\n+\n+\t* gfortran.h:  New statement-type ST_FINAL for FINAL declarations.\n+\t(struct gfc_symbol):  New member f2k_derived.\n+\t(struct gfc_namespace):  New member finalizers, for use in the above\n+\tmentioned f2k_derived namespace.\n+\t(struct gfc_finalizer):  New type defined for finalizers linked list.\n+\t* match.h (gfc_match_final_decl):  New function header.\n+\t* decl.c (gfc_match_derived_decl):  Create f2k_derived namespace on\n+\tconstructed symbol node.\n+\t(gfc_match_final_decl):  New function to match a FINAL declaration line.\n+\t* parse.c (decode_statement):  match-call for keyword FINAL.\n+\t(parse_derived):  Parse CONTAINS section and accept FINAL statements.\n+\t* resolve.c (gfc_resolve_finalizers):  New function to resolve (that is\n+\tin this case, check) a list of finalizer procedures.\n+\t(resolve_fl_derived):  Call gfc_resolve_finalizers here.\n+\t* symbol.c (gfc_get_namespace):  Initialize new finalizers to NULL.\n+\t(gfc_free_namespace):  Free finalizers list.\n+\t(gfc_new_symbol):  Initialize new f2k_derived to NULL.\n+\t(gfc_free_symbol):  Free f2k_derived namespace.\n+\t(gfc_free_finalizer):  New function to free a single gfc_finalizer node.\n+\t(gfc_free_finalizer_list):  New function to free a linked list of\n+\tgfc_finalizer nodes.\n+\n 2008-06-02  Daniel Franke  <franke.daniel@gmail.com>\n \n \tPR fortran/36375"}, {"sha": "f6884f2505ad1276c9575d69f6c9f86a041e67f7", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=345235247ae4c80dcd98e7630d35be32533a35a1", "patch": "@@ -6270,6 +6270,10 @@ gfc_match_derived_decl (void)\n   if (attr.is_bind_c != 0)\n     sym->attr.is_bind_c = attr.is_bind_c;\n \n+  /* Construct the f2k_derived namespace if it is not yet there.  */\n+  if (!sym->f2k_derived)\n+    sym->f2k_derived = gfc_get_namespace (NULL, 0);\n+\n   gfc_new_block = sym;\n \n   return MATCH_YES;\n@@ -6480,3 +6484,105 @@ gfc_match_enumerator_def (void)\n \n }\n \n+/* Match a FINAL declaration inside a derived type.  */\n+\n+match\n+gfc_match_final_decl (void)\n+{\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n+  gfc_symbol* sym;\n+  match m;\n+  gfc_namespace* module_ns;\n+  bool first, last;\n+\n+  if (gfc_state_stack->state != COMP_DERIVED)\n+    {\n+      gfc_error (\"FINAL declaration at %C must be inside a derived type \"\n+\t\t \"definition!\");\n+      return MATCH_ERROR;\n+    }\n+\n+  gcc_assert (gfc_current_block ());\n+\n+  if (!gfc_state_stack->previous\n+      || gfc_state_stack->previous->state != COMP_MODULE)\n+    {\n+      gfc_error (\"Derived type declaration with FINAL at %C must be in the\"\n+\t\t \" specification part of a MODULE\");\n+      return MATCH_ERROR;\n+    }\n+\n+  module_ns = gfc_current_ns;\n+  gcc_assert (module_ns);\n+  gcc_assert (module_ns->proc_name->attr.flavor == FL_MODULE);\n+\n+  /* Match optional ::, don't care about MATCH_YES or MATCH_NO.  */\n+  if (gfc_match (\" ::\") == MATCH_ERROR)\n+    return MATCH_ERROR;\n+\n+  /* Match the sequence of procedure names.  */\n+  first = true;\n+  last = false;\n+  do\n+    {\n+      gfc_finalizer* f;\n+\n+      if (first && gfc_match_eos () == MATCH_YES)\n+\t{\n+\t  gfc_error (\"Empty FINAL at %C\");\n+\t  return MATCH_ERROR;\n+\t}\n+\n+      m = gfc_match_name (name);\n+      if (m == MATCH_NO)\n+\t{\n+\t  gfc_error (\"Expected module procedure name at %C\");\n+\t  return MATCH_ERROR;\n+\t}\n+      else if (m != MATCH_YES)\n+\treturn MATCH_ERROR;\n+\n+      if (gfc_match_eos () == MATCH_YES)\n+\tlast = true;\n+      if (!last && gfc_match_char (',') != MATCH_YES)\n+\t{\n+\t  gfc_error (\"Expected ',' at %C\");\n+\t  return MATCH_ERROR;\n+\t}\n+\n+      if (gfc_get_symbol (name, module_ns, &sym))\n+\t{\n+\t  gfc_error (\"Unknown procedure name \\\"%s\\\" at %C\", name);\n+\t  return MATCH_ERROR;\n+\t}\n+\n+      /* Mark the symbol as module procedure.  */\n+      if (sym->attr.proc != PROC_MODULE\n+\t  && gfc_add_procedure (&sym->attr, PROC_MODULE,\n+\t\t\t\tsym->name, NULL) == FAILURE)\n+\treturn MATCH_ERROR;\n+\n+      /* Check if we already have this symbol in the list, this is an error.  */\n+      for (f = gfc_current_block ()->f2k_derived->finalizers; f; f = f->next)\n+\tif (f->procedure == sym)\n+\t  {\n+\t    gfc_error (\"'%s' at %C is already defined as FINAL procedure!\",\n+\t\t       name);\n+\t    return MATCH_ERROR;\n+\t  }\n+\n+      /* Add this symbol to the list of finalizers.  */\n+      gcc_assert (gfc_current_block ()->f2k_derived);\n+      ++sym->refs;\n+      f = gfc_getmem (sizeof (gfc_finalizer));     \n+      f->procedure = sym;\n+      f->where = gfc_current_locus;\n+      f->next = gfc_current_block ()->f2k_derived->finalizers;\n+      gfc_current_block ()->f2k_derived->finalizers = f;\n+\n+      first = false;\n+    }\n+  while (!last);\n+\n+  return MATCH_YES;\n+}"}, {"sha": "d4f9771e610e3d5737a1a3ecd43b2aa450d69d2c", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=345235247ae4c80dcd98e7630d35be32533a35a1", "patch": "@@ -210,7 +210,7 @@ typedef enum\n   ST_CALL, ST_CASE, ST_CLOSE, ST_COMMON, ST_CONTINUE, ST_CONTAINS, ST_CYCLE,\n   ST_DATA, ST_DATA_DECL, ST_DEALLOCATE, ST_DO, ST_ELSE, ST_ELSEIF,\n   ST_ELSEWHERE, ST_END_BLOCK_DATA, ST_ENDDO, ST_IMPLIED_ENDDO,\n-  ST_END_FILE, ST_FLUSH, ST_END_FORALL, ST_END_FUNCTION, ST_ENDIF,\n+  ST_END_FILE, ST_FINAL, ST_FLUSH, ST_END_FORALL, ST_END_FUNCTION, ST_ENDIF,\n   ST_END_INTERFACE, ST_END_MODULE, ST_END_PROGRAM, ST_END_SELECT,\n   ST_END_SUBROUTINE, ST_END_WHERE, ST_END_TYPE, ST_ENTRY, ST_EQUIVALENCE,\n   ST_EXIT, ST_FORALL, ST_FORALL_BLOCK, ST_FORMAT, ST_FUNCTION, ST_GOTO,\n@@ -1014,6 +1014,10 @@ typedef struct gfc_symbol\n   gfc_formal_arglist *formal;\n   struct gfc_namespace *formal_ns;\n \n+  /* The namespace containing type-associated procedure symbols.  */\n+  /* TODO: Make this union with formal?  */\n+  struct gfc_namespace *f2k_derived;\n+\n   struct gfc_expr *value;\t/* Parameter/Initializer value */\n   gfc_array_spec *as;\n   struct gfc_symbol *result;\t/* function result symbol */\n@@ -1151,6 +1155,8 @@ typedef struct gfc_namespace\n   gfc_symtree *uop_root;\n   /* Tree containing all the common blocks.  */\n   gfc_symtree *common_root;\n+  /* Linked list of finalizer procedures.  */\n+  struct gfc_finalizer *finalizers;\n \n   /* If set_flag[letter] is set, an implicit type has been set for letter.  */\n   int set_flag[GFC_LETTERS];\n@@ -1942,6 +1948,17 @@ typedef struct iterator_stack\n iterator_stack;\n extern iterator_stack *iter_stack;\n \n+\n+/* Node in the linked list used for storing finalizer procedures.  */\n+\n+typedef struct gfc_finalizer\n+{\n+  struct gfc_finalizer* next;\n+  gfc_symbol* procedure;\n+  locus where; /* Where the FINAL declaration occured.  */\n+}\n+gfc_finalizer;\n+\n /************************ Function prototypes *************************/\n \n /* decl.c */\n@@ -2210,6 +2227,8 @@ gfc_gsymbol *gfc_find_gsymbol (gfc_gsymbol *, const char *);\n \n void copy_formal_args (gfc_symbol *dest, gfc_symbol *src);\n \n+void gfc_free_finalizer (gfc_finalizer *el); /* Needed in resolve.c, too  */\n+\n /* intrinsic.c */\n extern int gfc_init_expr;\n "}, {"sha": "3f8d31074e835854442212f5ede280cdb8c88480", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=345235247ae4c80dcd98e7630d35be32533a35a1", "patch": "@@ -140,6 +140,7 @@ match gfc_match_function_decl (void);\n match gfc_match_entry (void);\n match gfc_match_subroutine (void);\n match gfc_match_derived_decl (void);\n+match gfc_match_final_decl (void);\n \n match gfc_match_implicit_none (void);\n match gfc_match_implicit (void);"}, {"sha": "dc1a62b1a080980464080caa8f5f2e7db2d9f73f", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=345235247ae4c80dcd98e7630d35be32533a35a1", "patch": "@@ -366,6 +366,7 @@ decode_statement (void)\n       break;\n \n     case 'f':\n+      match (\"final\", gfc_match_final_decl, ST_FINAL);\n       match (\"flush\", gfc_match_flush, ST_FLUSH);\n       match (\"format\", gfc_match_format, ST_FORMAT);\n       break;\n@@ -1682,6 +1683,7 @@ static void\n parse_derived (void)\n {\n   int compiling_type, seen_private, seen_sequence, seen_component, error_flag;\n+  int seen_contains, seen_contains_comp;\n   gfc_statement st;\n   gfc_state_data s;\n   gfc_symbol *derived_sym = NULL;\n@@ -1697,6 +1699,8 @@ parse_derived (void)\n   seen_private = 0;\n   seen_sequence = 0;\n   seen_component = 0;\n+  seen_contains = 0;\n+  seen_contains_comp = 0;\n \n   compiling_type = 1;\n \n@@ -1710,23 +1714,57 @@ parse_derived (void)\n \n \tcase ST_DATA_DECL:\n \tcase ST_PROCEDURE:\n+\t  if (seen_contains)\n+\t    {\n+\t      gfc_error (\"Components in TYPE at %C must precede CONTAINS\");\n+\t      error_flag = 1;\n+\t    }\n+\n \t  accept_statement (st);\n \t  seen_component = 1;\n \t  break;\n \n+\tcase ST_FINAL:\n+\t  if (!seen_contains)\n+\t    {\n+\t      gfc_error (\"FINAL declaration at %C must be inside CONTAINS\");\n+\t      error_flag = 1;\n+\t    }\n+\n+\t  if (gfc_notify_std (GFC_STD_F2003,\n+\t\t\t      \"Fortran 2003:  FINAL procedure declaration\"\n+\t\t\t      \" at %C\") == FAILURE)\n+\t    error_flag = 1;\n+\n+\t  accept_statement (ST_FINAL);\n+\t  seen_contains_comp = 1;\n+\t  break;\n+\n \tcase ST_END_TYPE:\n \t  compiling_type = 0;\n \n \t  if (!seen_component\n \t      && (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: Derived type \"\n-\t\t\t         \"definition at %C without components\")\n+\t\t\t\t \"definition at %C without components\")\n \t\t  == FAILURE))\n \t    error_flag = 1;\n \n+\t  if (seen_contains && !seen_contains_comp\n+\t      && (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: Derived type \"\n+\t\t\t\t \"definition at %C with empty CONTAINS \"\n+\t\t\t\t \"section\") == FAILURE))\n+\t    error_flag = 1;\n+\n \t  accept_statement (ST_END_TYPE);\n \t  break;\n \n \tcase ST_PRIVATE:\n+\t  if (seen_contains)\n+\t    {\n+\t      gfc_error (\"PRIVATE statement at %C must precede CONTAINS\");\n+\t      error_flag = 1;\n+\t    }\n+\n \t  if (gfc_find_state (COMP_MODULE) == FAILURE)\n \t    {\n \t      gfc_error (\"PRIVATE statement in TYPE at %C must be inside \"\n@@ -1755,6 +1793,12 @@ parse_derived (void)\n \t  break;\n \n \tcase ST_SEQUENCE:\n+\t  if (seen_contains)\n+\t    {\n+\t      gfc_error (\"SEQUENCE statement at %C must precede CONTAINS\");\n+\t      error_flag = 1;\n+\t    }\n+\n \t  if (seen_component)\n \t    {\n \t      gfc_error (\"SEQUENCE statement at %C must precede \"\n@@ -1778,6 +1822,22 @@ parse_derived (void)\n \t\t\t    gfc_current_block ()->name, NULL);\n \t  break;\n \n+\tcase ST_CONTAINS:\n+\t  if (gfc_notify_std (GFC_STD_F2003,\n+\t\t\t      \"Fortran 2003:  CONTAINS block in derived type\"\n+\t\t\t      \" definition at %C\") == FAILURE)\n+\t    error_flag = 1;\n+\n+\t  if (seen_contains)\n+\t    {\n+\t      gfc_error (\"Already inside a CONTAINS block at %C\");\n+\t      error_flag = 1;\n+\t    }\n+\n+\t  seen_contains = 1;\n+\t  accept_statement (ST_CONTAINS);\n+\t  break;\n+\n \tdefault:\n \t  unexpected_statement (st);\n \t  break;"}, {"sha": "c9809351c9455272d19821f5b2b5d1536a4499bc", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=345235247ae4c80dcd98e7630d35be32533a35a1", "patch": "@@ -7439,6 +7439,146 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n }\n \n \n+/* Resolve a list of finalizer procedures.  That is, after they have hopefully\n+   been defined and we now know their defined arguments, check that they fulfill\n+   the requirements of the standard for procedures used as finalizers.  */\n+\n+static try\n+gfc_resolve_finalizers (gfc_symbol* derived)\n+{\n+  gfc_finalizer* list;\n+  gfc_finalizer** prev_link; /* For removing wrong entries from the list.  */\n+  try result = SUCCESS;\n+  bool seen_scalar = false;\n+\n+  if (!derived->f2k_derived || !derived->f2k_derived->finalizers)\n+    return SUCCESS;\n+\n+  /* Walk over the list of finalizer-procedures, check them, and if any one\n+     does not fit in with the standard's definition, print an error and remove\n+     it from the list.  */\n+  prev_link = &derived->f2k_derived->finalizers;\n+  for (list = derived->f2k_derived->finalizers; list; list = *prev_link)\n+    {\n+      gfc_symbol* arg;\n+      gfc_finalizer* i;\n+      int my_rank;\n+\n+      /* Check this exists and is a SUBROUTINE.  */\n+      if (!list->procedure->attr.subroutine)\n+\t{\n+\t  gfc_error (\"FINAL procedure '%s' at %L is not a SUBROUTINE\",\n+\t\t     list->procedure->name, &list->where);\n+\t  goto error;\n+\t}\n+\n+      /* We should have exactly one argument.  */\n+      if (!list->procedure->formal || list->procedure->formal->next)\n+\t{\n+\t  gfc_error (\"FINAL procedure at %L must have exactly one argument\",\n+\t\t     &list->where);\n+\t  goto error;\n+\t}\n+      arg = list->procedure->formal->sym;\n+\n+      /* This argument must be of our type.  */\n+      if (arg->ts.type != BT_DERIVED || arg->ts.derived != derived)\n+\t{\n+\t  gfc_error (\"Argument of FINAL procedure at %L must be of type '%s'\",\n+\t\t     &arg->declared_at, derived->name);\n+\t  goto error;\n+\t}\n+\n+      /* It must neither be a pointer nor allocatable nor optional.  */\n+      if (arg->attr.pointer)\n+\t{\n+\t  gfc_error (\"Argument of FINAL procedure at %L must not be a POINTER\",\n+\t\t     &arg->declared_at);\n+\t  goto error;\n+\t}\n+      if (arg->attr.allocatable)\n+\t{\n+\t  gfc_error (\"Argument of FINAL procedure at %L must not be\"\n+\t\t     \" ALLOCATABLE\", &arg->declared_at);\n+\t  goto error;\n+\t}\n+      if (arg->attr.optional)\n+\t{\n+\t  gfc_error (\"Argument of FINAL procedure at %L must not be OPTIONAL\",\n+\t\t     &arg->declared_at);\n+\t  goto error;\n+\t}\n+\n+      /* It must not be INTENT(OUT).  */\n+      if (arg->attr.intent == INTENT_OUT)\n+\t{\n+\t  gfc_error (\"Argument of FINAL procedure at %L must not be\"\n+\t\t     \" INTENT(OUT)\", &arg->declared_at);\n+\t  goto error;\n+\t}\n+\n+      /* Warn if the procedure is non-scalar and not assumed shape.  */\n+      if (gfc_option.warn_surprising && arg->as && arg->as->rank > 0\n+\t  && arg->as->type != AS_ASSUMED_SHAPE)\n+\tgfc_warning (\"Non-scalar FINAL procedure at %L should have assumed\"\n+\t\t     \" shape argument\", &arg->declared_at);\n+\n+      /* Check that it does not match in kind and rank with a FINAL procedure\n+\t defined earlier.  To really loop over the *earlier* declarations,\n+\t we need to walk the tail of the list as new ones were pushed at the\n+\t front.  */\n+      /* TODO: Handle kind parameters once they are implemented.  */\n+      my_rank = (arg->as ? arg->as->rank : 0);\n+      for (i = list->next; i; i = i->next)\n+\t{\n+\t  /* Argument list might be empty; that is an error signalled earlier,\n+\t     but we nevertheless continued resolving.  */\n+\t  if (i->procedure->formal)\n+\t    {\n+\t      gfc_symbol* i_arg = i->procedure->formal->sym;\n+\t      const int i_rank = (i_arg->as ? i_arg->as->rank : 0);\n+\t      if (i_rank == my_rank)\n+\t\t{\n+\t\t  gfc_error (\"FINAL procedure '%s' declared at %L has the same\"\n+\t\t\t     \" rank (%d) as '%s'\",\n+\t\t\t     list->procedure->name, &list->where, my_rank, \n+\t\t\t     i->procedure->name);\n+\t\t  goto error;\n+\t\t}\n+\t    }\n+\t}\n+\n+\t/* Is this the/a scalar finalizer procedure?  */\n+\tif (!arg->as || arg->as->rank == 0)\n+\t  seen_scalar = true;\n+\n+\tprev_link = &list->next;\n+\tcontinue;\n+\n+\t/* Remove wrong nodes immediatelly from the list so we don't risk any\n+\t   troubles in the future when they might fail later expectations.  */\n+error:\n+\tresult = FAILURE;\n+\ti = list;\n+\t*prev_link = list->next;\n+\tgfc_free_finalizer (i);\n+    }\n+\n+  /* Warn if we haven't seen a scalar finalizer procedure (but we know there\n+     were nodes in the list, must have been for arrays.  It is surely a good\n+     idea to have a scalar version there if there's something to finalize.  */\n+  if (gfc_option.warn_surprising && result == SUCCESS && !seen_scalar)\n+    gfc_warning (\"Only array FINAL procedures declared for derived type '%s'\"\n+\t\t \" defined at %L, suggest also scalar one\",\n+\t\t derived->name, &derived->declared_at);\n+\n+  /* TODO:  Remove this error when finalization is finished.  */\n+  gfc_error (\"Finalization at %L is not yet implemented\", &derived->declared_at);\n+\n+  return result;\n+}\n+\n+\n /* Resolve the components of a derived type.  */\n \n static try\n@@ -7517,6 +7657,10 @@ resolve_fl_derived (gfc_symbol *sym)\n \t}\n     }\n \n+  /* Resolve the finalizer procedures.  */\n+  if (gfc_resolve_finalizers (sym) == FAILURE)\n+    return FAILURE;\n+\n   /* Add derived type to the derived type list.  */\n   for (dt_list = gfc_derived_types; dt_list; dt_list = dt_list->next)\n     if (sym == dt_list->derived)"}, {"sha": "78561aac47dc226c2a73d522dade88abe6e43458", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=345235247ae4c80dcd98e7630d35be32533a35a1", "patch": "@@ -2096,6 +2096,7 @@ gfc_get_namespace (gfc_namespace *parent, int parent_types)\n   ns = gfc_getmem (sizeof (gfc_namespace));\n   ns->sym_root = NULL;\n   ns->uop_root = NULL;\n+  ns->finalizers = NULL;\n   ns->default_access = ACCESS_UNKNOWN;\n   ns->parent = parent;\n \n@@ -2284,6 +2285,8 @@ gfc_free_symbol (gfc_symbol *sym)\n \n   gfc_free_formal_arglist (sym->formal);\n \n+  gfc_free_namespace (sym->f2k_derived);\n+\n   gfc_free (sym);\n }\n \n@@ -2316,6 +2319,7 @@ gfc_new_symbol (const char *name, gfc_namespace *ns)\n \n   /* Clear the ptrs we may need.  */\n   p->common_block = NULL;\n+  p->f2k_derived = NULL;\n   \n   return p;\n }\n@@ -2884,6 +2888,33 @@ gfc_free_equiv_lists (gfc_equiv_list *l)\n }\n \n \n+/* Free a finalizer procedure list.  */\n+\n+void\n+gfc_free_finalizer (gfc_finalizer* el)\n+{\n+  if (el)\n+    {\n+      --el->procedure->refs;\n+      if (!el->procedure->refs)\n+\tgfc_free_symbol (el->procedure);\n+\n+      gfc_free (el);\n+    }\n+}\n+\n+static void\n+gfc_free_finalizer_list (gfc_finalizer* list)\n+{\n+  while (list)\n+    {\n+      gfc_finalizer* current = list;\n+      list = list->next;\n+      gfc_free_finalizer (current);\n+    }\n+}\n+\n+\n /* Free a namespace structure and everything below it.  Interface\n    lists associated with intrinsic operators are not freed.  These are\n    taken care of when a specific name is freed.  */\n@@ -2908,6 +2939,7 @@ gfc_free_namespace (gfc_namespace *ns)\n   free_sym_tree (ns->sym_root);\n   free_uop_tree (ns->uop_root);\n   free_common_tree (ns->common_root);\n+  gfc_free_finalizer_list (ns->finalizers);\n \n   for (cl = ns->cl_list; cl; cl = cl2)\n     {"}, {"sha": "6cacd32cdb57a22b032bc7af71e6ccc0dd4b37c8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=345235247ae4c80dcd98e7630d35be32533a35a1", "patch": "@@ -1,3 +1,14 @@\n+2008-06-02  Daniel Kraft  <d@domob.eu>\n+\n+\t* finalize_1.f08:  New test.\n+\t* finalize_2.f03:  New test.\n+\t* finalize_3.f03:  New test.\n+\t* finalize_4.f03:  New test.\n+\t* finalize_5.f03:  New test.\n+\t* finalize_6.f90:  New test.\n+\t* finalize_7.f03:  New test.\n+\t* finalize_8.f03:  New test.\n+\n 2008-06-01  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* gcc.c-torture/execute/ieee/ieee.exp: Load c-torture.exp."}, {"sha": "e1501ef66b82e47dea284e7adfd103dada8cd638", "filename": "gcc/testsuite/gfortran.dg/finalize_1.f08", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_1.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_1.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_1.f08?ref=345235247ae4c80dcd98e7630d35be32533a35a1", "patch": "@@ -0,0 +1,31 @@\n+! { dg-do compile }\n+\n+! Parsing of finalizer procedure definitions.\n+! Check that CONTAINS is allowed in TYPE definition; but empty only for F2008\n+\n+MODULE final_type\n+  IMPLICIT NONE\n+\n+  TYPE :: mytype\n+    INTEGER, ALLOCATABLE :: fooarr(:)\n+    REAL :: foobar\n+  CONTAINS\n+  END TYPE mytype\n+\n+CONTAINS\n+  \n+  SUBROUTINE bar\n+    TYPE :: t\n+    CONTAINS ! This is ok\n+    END TYPE t\n+    ! Nothing\n+  END SUBROUTINE bar\n+\n+END MODULE final_type\n+\n+PROGRAM finalizer\n+  IMPLICIT NONE\n+  ! Do nothing here\n+END PROGRAM finalizer\n+\n+! { dg-final { cleanup-modules \"final_type\" } }"}, {"sha": "b91bedff81f31fb35fe8e60bc017e92e644ca126", "filename": "gcc/testsuite/gfortran.dg/finalize_2.f03", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_2.f03?ref=345235247ae4c80dcd98e7630d35be32533a35a1", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2003\" }\n+\n+! Parsing of finalizer procedure definitions.\n+! Check empty CONTAINS errors out for F2003.\n+\n+MODULE final_type\n+  IMPLICIT NONE\n+\n+  TYPE :: mytype\n+    INTEGER, ALLOCATABLE :: fooarr(:)\n+    REAL :: foobar\n+  CONTAINS\n+  END TYPE mytype ! { dg-error \"Fortran 2008\" }\n+\n+END MODULE final_type\n+\n+PROGRAM finalizer\n+  IMPLICIT NONE\n+  ! Do nothing here\n+END PROGRAM finalizer\n+\n+! { dg-final { cleanup-modules \"final_type\" } }"}, {"sha": "edc493bfca514e41f0737b56bcad4b00ab58cc8f", "filename": "gcc/testsuite/gfortran.dg/finalize_3.f03", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_3.f03?ref=345235247ae4c80dcd98e7630d35be32533a35a1", "patch": "@@ -0,0 +1,25 @@\n+! { dg-do compile }\n+\n+! Parsing of finalizer procedure definitions.\n+! Check that CONTAINS disallows further components and no double CONTAINS\n+! is allowed.\n+\n+MODULE final_type\n+  IMPLICIT NONE\n+\n+  TYPE :: mytype\n+    INTEGER, ALLOCATABLE :: fooarr(:)\n+    REAL :: foobar\n+  CONTAINS\n+  CONTAINS ! { dg-error \"Already inside a CONTAINS block\" }\n+    INTEGER :: x ! { dg-error \"must precede CONTAINS\" }\n+  END TYPE mytype\n+\n+END MODULE final_type\n+\n+PROGRAM finalizer\n+  IMPLICIT NONE\n+  ! Do nothing here\n+END PROGRAM finalizer\n+\n+! { dg-final { cleanup-modules \"final_type\" } }"}, {"sha": "6e99256c252443eff6abd86187c87c49e647535f", "filename": "gcc/testsuite/gfortran.dg/finalize_4.f03", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_4.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_4.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_4.f03?ref=345235247ae4c80dcd98e7630d35be32533a35a1", "patch": "@@ -0,0 +1,55 @@\n+! { dg-do compile }\n+\n+! Parsing of finalizer procedure definitions.\n+! Check parsing of valid finalizer definitions.\n+\n+MODULE final_type\n+  IMPLICIT NONE\n+\n+  TYPE :: mytype\n+    INTEGER, ALLOCATABLE :: fooarr(:)\n+    REAL :: foobar\n+  CONTAINS\n+    FINAL :: finalize_single\n+    FINAL finalize_vector, finalize_matrix\n+    ! TODO:  Test with different kind type parameters once they are implemented.\n+  END TYPE mytype\n+\n+CONTAINS\n+\n+  ELEMENTAL SUBROUTINE finalize_single (el)\n+    IMPLICIT NONE\n+    TYPE(mytype), INTENT(IN) :: el\n+    ! Do nothing in this test\n+  END SUBROUTINE finalize_single\n+\n+  SUBROUTINE finalize_vector (el)\n+    IMPLICIT NONE\n+    TYPE(mytype), INTENT(INOUT) :: el(:)\n+    ! Do nothing in this test\n+  END SUBROUTINE finalize_vector\n+\n+  SUBROUTINE finalize_matrix (el)\n+    IMPLICIT NONE\n+    TYPE(mytype) :: el(:, :)\n+    ! Do nothing in this test\n+  END SUBROUTINE finalize_matrix\n+\n+END MODULE final_type\n+\n+PROGRAM finalizer\n+  USE final_type, ONLY: mytype\n+  IMPLICIT NONE\n+\n+  TYPE(mytype) :: el, vec(42)\n+  TYPE(mytype), ALLOCATABLE :: mat(:, :)\n+\n+  ALLOCATE(mat(2, 3))\n+  DEALLOCATE(mat)\n+\n+END PROGRAM finalizer\n+\n+! TODO: Remove this once finalization is implemented.\n+! { dg-excess-errors \"not yet implemented\" }\n+\n+! { dg-final { cleanup-modules \"final_type\" } }"}, {"sha": "9f5dc1784d0fba4b121fb39b493996d4b0812760", "filename": "gcc/testsuite/gfortran.dg/finalize_5.f03", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_5.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_5.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_5.f03?ref=345235247ae4c80dcd98e7630d35be32533a35a1", "patch": "@@ -0,0 +1,114 @@\n+! { dg-do compile }\n+\n+! Parsing of finalizer procedure definitions.\n+! Check for appropriate errors on invalid final procedures.\n+\n+MODULE final_type\n+  IMPLICIT NONE\n+\n+  TYPE :: mytype\n+    INTEGER, ALLOCATABLE :: fooarr(:)\n+    REAL :: foobar\n+    FINAL :: finalize_matrix ! { dg-error \"must be inside CONTAINS\" }\n+  CONTAINS\n+    FINAL :: ! { dg-error \"Empty FINAL\" }\n+    FINAL ! { dg-error \"Empty FINAL\" }\n+    FINAL :: + ! { dg-error \"Expected module procedure name\" }\n+    FINAL :: iamnot ! { dg-error \"is not a SUBROUTINE\" }\n+    FINAL :: finalize_single finalize_vector ! { dg-error \"Expected ','\" }\n+    FINAL :: finalize_single, finalize_vector\n+    FINAL :: finalize_single ! { dg-error \"is already defined\" }\n+    FINAL :: finalize_vector_2 ! { dg-error \"has the same rank\" }\n+    FINAL :: finalize_single_2 ! { dg-error \"has the same rank\" }\n+    FINAL :: bad_function ! { dg-error \"is not a SUBROUTINE\" }\n+    FINAL bad_num_args_1 ! { dg-error \"must have exactly one argument\" }\n+    FINAL bad_num_args_2 ! { dg-error \"must have exactly one argument\" }\n+    FINAL bad_arg_type\n+    FINAL :: bad_pointer\n+    FINAL :: bad_alloc\n+    FINAL :: bad_optional\n+    FINAL :: bad_intent_out\n+\n+    ! TODO:  Test for polymorphism, kind parameters once those are implemented.\n+  END TYPE mytype\n+\n+CONTAINS\n+\n+  SUBROUTINE finalize_single (el)\n+    IMPLICIT NONE\n+    TYPE(mytype) :: el\n+  END SUBROUTINE finalize_single\n+\n+  ELEMENTAL SUBROUTINE finalize_single_2 (el)\n+    IMPLICIT NONE\n+    TYPE(mytype), INTENT(IN) :: el\n+  END SUBROUTINE finalize_single_2\n+\n+  SUBROUTINE finalize_vector (el)\n+    IMPLICIT NONE\n+    TYPE(mytype), INTENT(INOUT) :: el(:)\n+  END SUBROUTINE finalize_vector\n+\n+  SUBROUTINE finalize_vector_2 (el)\n+    IMPLICIT NONE\n+    TYPE(mytype), INTENT(IN) :: el(:)\n+  END SUBROUTINE finalize_vector_2\n+  \n+  SUBROUTINE finalize_matrix (el)\n+    IMPLICIT NONE\n+    TYPE(mytype) :: el(:, :)\n+  END SUBROUTINE finalize_matrix\n+\n+  INTEGER FUNCTION bad_function (el)\n+    IMPLICIT NONE\n+    TYPE(mytype) :: el\n+\n+    bad_function = 42\n+  END FUNCTION bad_function\n+\n+  SUBROUTINE bad_num_args_1 ()\n+    IMPLICIT NONE\n+  END SUBROUTINE bad_num_args_1\n+\n+  SUBROUTINE bad_num_args_2 (el, x)\n+    IMPLICIT NONE\n+    TYPE(mytype) :: el\n+    COMPLEX :: x\n+  END SUBROUTINE bad_num_args_2\n+\n+  SUBROUTINE bad_arg_type (el) ! { dg-error \"must be of type 'mytype'\" }\n+    IMPLICIT NONE\n+    REAL :: el\n+  END SUBROUTINE bad_arg_type\n+\n+  SUBROUTINE bad_pointer (el) ! { dg-error \"must not be a POINTER\" }\n+    IMPLICIT NONE\n+    TYPE(mytype), POINTER :: el\n+  END SUBROUTINE bad_pointer\n+\n+  SUBROUTINE bad_alloc (el) ! { dg-error \"must not be ALLOCATABLE\" }\n+    IMPLICIT NONE\n+    TYPE(mytype), ALLOCATABLE :: el(:)\n+  END SUBROUTINE bad_alloc\n+\n+  SUBROUTINE bad_optional (el) ! { dg-error \"must not be OPTIONAL\" }\n+    IMPLICIT NONE\n+    TYPE(mytype), OPTIONAL :: el\n+  END SUBROUTINE bad_optional\n+\n+  SUBROUTINE bad_intent_out (el) ! { dg-error \"must not be INTENT\\\\(OUT\\\\)\" }\n+    IMPLICIT NONE\n+    TYPE(mytype), INTENT(OUT) :: el\n+  END SUBROUTINE bad_intent_out\n+\n+END MODULE final_type\n+\n+PROGRAM finalizer\n+  IMPLICIT NONE\n+  ! Nothing here, errors above\n+END PROGRAM finalizer\n+\n+! TODO: Remove this once finalization is implemented.\n+! { dg-excess-errors \"not yet implemented\" }\n+\n+! { dg-final { cleanup-modules \"final_type\" } }"}, {"sha": "e790f4efb1056eff621e980c5c1e31c2885b7208", "filename": "gcc/testsuite/gfortran.dg/finalize_6.f90", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_6.f90?ref=345235247ae4c80dcd98e7630d35be32533a35a1", "patch": "@@ -0,0 +1,35 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f95\" }\n+\n+! Parsing of finalizer procedure definitions.\n+! Check that CONTAINS/FINAL in derived types is rejected for F95.\n+\n+MODULE final_type\n+  IMPLICIT NONE\n+\n+  TYPE :: mytype\n+    INTEGER :: fooarr(42)\n+    REAL :: foobar\n+  CONTAINS ! { dg-error \"Fortran 2003\" }\n+    FINAL :: finalize_single ! { dg-error \"Fortran 2003\" }\n+  END TYPE mytype\n+\n+CONTAINS\n+\n+  SUBROUTINE finalize_single (el)\n+    IMPLICIT NONE\n+    TYPE(mytype) :: el\n+    ! Do nothing in this test\n+  END SUBROUTINE finalize_single\n+\n+END MODULE final_type\n+\n+PROGRAM finalizer\n+  IMPLICIT NONE\n+  ! Do nothing\n+END PROGRAM finalizer\n+\n+! TODO: Remove this once finalization is implemented.\n+! { dg-excess-errors \"not yet implemented\" }\n+\n+! { dg-final { cleanup-modules \"final_type\" } }"}, {"sha": "db6b4bea948a8f867c14347f680a10915a730da4", "filename": "gcc/testsuite/gfortran.dg/finalize_7.f03", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_7.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_7.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_7.f03?ref=345235247ae4c80dcd98e7630d35be32533a35a1", "patch": "@@ -0,0 +1,59 @@\n+! { dg-do compile }\n+! { dg-options \"-Wsurprising\" }\n+\n+! Implementation of finalizer procedures.\n+! Check for expected warnings on dubious FINAL constructs.\n+\n+MODULE final_type\n+  IMPLICIT NONE\n+\n+  TYPE :: type_1\n+    INTEGER, ALLOCATABLE :: fooarr(:)\n+    REAL :: foobar\n+  CONTAINS\n+    ! Non-scalar procedures should be assumed shape\n+    FINAL :: fin1_scalar\n+    FINAL :: fin1_shape_1\n+    FINAL :: fin1_shape_2\n+  END TYPE type_1\n+\n+  TYPE :: type_2 ! { dg-warning \"Only array FINAL procedures\" }\n+    REAL :: x\n+  CONTAINS\n+    ! No scalar finalizer, only array ones\n+    FINAL :: fin2_vector\n+  END TYPE type_2\n+\n+CONTAINS\n+\n+  SUBROUTINE fin1_scalar (el)\n+    IMPLICIT NONE\n+    TYPE(type_1) :: el\n+  END SUBROUTINE fin1_scalar\n+\n+  SUBROUTINE fin1_shape_1 (v) ! { dg-warning \"assumed shape\" }\n+    IMPLICIT NONE\n+    TYPE(type_1) :: v(*)\n+  END SUBROUTINE fin1_shape_1\n+\n+  SUBROUTINE fin1_shape_2 (v) ! { dg-warning \"assumed shape\" }\n+    IMPLICIT NONE\n+    TYPE(type_1) :: v(42, 5)\n+  END SUBROUTINE fin1_shape_2\n+\n+  SUBROUTINE fin2_vector (v)\n+    IMPLICIT NONE\n+    TYPE(type_2) :: v(:)\n+  END SUBROUTINE fin2_vector\n+\n+END MODULE final_type\n+\n+PROGRAM finalizer\n+  IMPLICIT NONE\n+  ! Nothing here\n+END PROGRAM finalizer\n+\n+! TODO: Remove this once finalization is implemented.\n+! { dg-excess-errors \"not yet implemented\" }\n+\n+! { dg-final { cleanup-modules \"final_type\" } }"}, {"sha": "6a4a135e0da02076c38fd08fadda7157fddb52a7", "filename": "gcc/testsuite/gfortran.dg/finalize_8.f03", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_8.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345235247ae4c80dcd98e7630d35be32533a35a1/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_8.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_8.f03?ref=345235247ae4c80dcd98e7630d35be32533a35a1", "patch": "@@ -0,0 +1,37 @@\n+! { dg-do compile }\n+\n+! Parsing of finalizer procedure definitions.\n+! Check that FINAL-declarations are only allowed on types defined in the\n+! specification part of a module.\n+\n+MODULE final_type\n+  IMPLICIT NONE\n+\n+CONTAINS\n+\n+  SUBROUTINE bar\n+    IMPLICIT NONE\n+\n+    TYPE :: mytype\n+      INTEGER, ALLOCATABLE :: fooarr(:)\n+      REAL :: foobar\n+    CONTAINS\n+      FINAL :: myfinal ! { dg-error \"in the specification part of a MODULE\" }\n+    END TYPE mytype\n+\n+  CONTAINS\n+\n+    SUBROUTINE myfinal (el)\n+      TYPE(mytype) :: el\n+    END SUBROUTINE myfinal\n+\n+  END SUBROUTINE bar\n+\n+END MODULE final_type\n+\n+PROGRAM finalizer\n+  IMPLICIT NONE\n+  ! Do nothing here\n+END PROGRAM finalizer\n+\n+! { dg-final { cleanup-modules \"final_type\" } }"}]}