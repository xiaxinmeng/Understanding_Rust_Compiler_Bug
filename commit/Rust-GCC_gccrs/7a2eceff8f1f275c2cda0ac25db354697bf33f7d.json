{"sha": "7a2eceff8f1f275c2cda0ac25db354697bf33f7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2EyZWNlZmY4ZjFmMjc1YzJjZGEwYWMyNWRiMzU0Njk3YmYzM2Y3ZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2010-06-25T12:10:42Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-06-25T12:10:42Z"}, "message": "re PR middle-end/43866 (wrong code with -fbounds-check -funswitch-loops)\n\n\tPR middle-end/43866\n\t* tree-ssa-loop-unswitch.c (tree_may_unswitch_on): If stmt is always\n\ttrue or always false, return NULL_TREE.\n\t(tree_unswitch_single_loop): Optimize conditions even when reaching\n\tmax-unswitch-level parameter.  If num > 0, optimize first all conditions\n\tusing entry checks, then do still reachable block discovery and consider\n\tonly conditions in still reachable basic blocks in the loop.\n\n\t* gfortran.dg/pr43866.f90: New test.\n\nFrom-SVN: r161375", "tree": {"sha": "bd100b068858852eebf09bf62958875ba731f839", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd100b068858852eebf09bf62958875ba731f839"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a2eceff8f1f275c2cda0ac25db354697bf33f7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a2eceff8f1f275c2cda0ac25db354697bf33f7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a2eceff8f1f275c2cda0ac25db354697bf33f7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a2eceff8f1f275c2cda0ac25db354697bf33f7d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8ba0479ece9a852e7a1029268a33a3d52277a7f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ba0479ece9a852e7a1029268a33a3d52277a7f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ba0479ece9a852e7a1029268a33a3d52277a7f8"}], "stats": {"total": 185, "additions": 165, "deletions": 20}, "files": [{"sha": "5a63014727df3317c817e4e42814f1debb5dfc9e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a2eceff8f1f275c2cda0ac25db354697bf33f7d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a2eceff8f1f275c2cda0ac25db354697bf33f7d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7a2eceff8f1f275c2cda0ac25db354697bf33f7d", "patch": "@@ -1,5 +1,13 @@\n 2010-06-25  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR middle-end/43866\n+\t* tree-ssa-loop-unswitch.c (tree_may_unswitch_on): If stmt is always\n+\ttrue or always false, return NULL_TREE.\n+\t(tree_unswitch_single_loop): Optimize conditions even when reaching\n+\tmax-unswitch-level parameter.  If num > 0, optimize first all conditions\n+\tusing entry checks, then do still reachable block discovery and consider\n+\tonly conditions in still reachable basic blocks in the loop.\n+\n \tPR tree-optimization/44539\n \t* tree-cfgcleanup.c (fixup_noreturn_call): Call update_stmt even when\n \tthe call doesn't have LHS, but has VDEF."}, {"sha": "7f20137df96e3755630fd9a26756f64d43610dd3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a2eceff8f1f275c2cda0ac25db354697bf33f7d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a2eceff8f1f275c2cda0ac25db354697bf33f7d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7a2eceff8f1f275c2cda0ac25db354697bf33f7d", "patch": "@@ -1,5 +1,8 @@\n 2010-06-25  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR middle-end/43866\n+\t* gfortran.dg/pr43866.f90: New test.\n+\n \tPR tree-optimization/44539\n \t* gcc.dg/pr44539.c: New test.\n "}, {"sha": "abfdaa1557f1ae49d1909a598d823d3f210142eb", "filename": "gcc/testsuite/gfortran.dg/pr43866.f90", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a2eceff8f1f275c2cda0ac25db354697bf33f7d/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr43866.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a2eceff8f1f275c2cda0ac25db354697bf33f7d/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr43866.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr43866.f90?ref=7a2eceff8f1f275c2cda0ac25db354697bf33f7d", "patch": "@@ -0,0 +1,44 @@\n+! PR middle-end/43866\n+! { dg-do run }\n+! { dg-options \"-funswitch-loops -fbounds-check\" }\n+\n+MODULE PR43866\n+  IMPLICIT NONE\n+  TYPE TT\n+    REAL(KIND=4), DIMENSION(:,:), POINTER :: A\n+    REAL(KIND=8), DIMENSION(:,:), POINTER :: B\n+  END TYPE\n+CONTAINS\n+  SUBROUTINE FOO(M,X,Y,T)\n+    TYPE(TT), POINTER :: M\n+    INTEGER, INTENT(IN) :: Y, X\n+    INTEGER :: C, D\n+    LOGICAL :: T\n+    REAL(KIND = 4), DIMENSION(:,:), POINTER :: P\n+    REAL(KIND = 8), DIMENSION(:,:), POINTER :: Q\n+\n+    Q => M%B\n+    P => M%A\n+    DO C=1,X\n+      DO D=C+1,Y\n+        IF (T) THEN\n+          P(D,C)=P(C,D)\n+        ELSE\n+          Q(D,C)=Q(C,D)\n+        ENDIF\n+      ENDDO\n+    ENDDO\n+  END SUBROUTINE FOO\n+END MODULE PR43866\n+\n+  USE PR43866\n+  TYPE(TT), POINTER :: Q\n+  INTEGER, PARAMETER :: N=17\n+  ALLOCATE (Q)\n+  NULLIFY (Q%A)\n+  ALLOCATE (Q%B(N,N))\n+  Q%B=0\n+  CALL FOO (Q,N,N,.FALSE.)\n+END\n+\n+! { dg-final { cleanup-modules \"pr43866\" } }"}, {"sha": "b6b32dcd99a636bd4f468e4552f1ae125e5d4b68", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 110, "deletions": 20, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a2eceff8f1f275c2cda0ac25db354697bf33f7d/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a2eceff8f1f275c2cda0ac25db354697bf33f7d/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=7a2eceff8f1f275c2cda0ac25db354697bf33f7d", "patch": "@@ -1,5 +1,5 @@\n /* Loop unswitching.\n-   Copyright (C) 2004, 2005, 2007, 2008 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2007, 2008, 2010 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -129,6 +129,12 @@ tree_may_unswitch_on (basic_block bb, struct loop *loop)\n   if (!stmt || gimple_code (stmt) != GIMPLE_COND)\n     return NULL_TREE;\n \n+  /* To keep the things simple, we do not directly remove the conditions,\n+     but just replace tests with 0 != 0 resp. 1 != 0.  Prevent the infinite\n+     loop where we would unswitch again on such a condition.  */\n+  if (gimple_cond_true_p (stmt) || gimple_cond_false_p (stmt))\n+    return NULL_TREE;\n+\n   /* Condition must be invariant.  */\n   FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n     {\n@@ -142,12 +148,6 @@ tree_may_unswitch_on (basic_block bb, struct loop *loop)\n   cond = build2 (gimple_cond_code (stmt), boolean_type_node,\n \t\t gimple_cond_lhs (stmt), gimple_cond_rhs (stmt));\n \n-  /* To keep the things simple, we do not directly remove the conditions,\n-     but just replace tests with 0/1.  Prevent the infinite loop where we\n-     would unswitch again on such a condition.  */\n-  if (integer_zerop (cond) || integer_nonzerop (cond))\n-    return NULL_TREE;\n-\n   return cond;\n }\n \n@@ -193,21 +193,14 @@ tree_unswitch_single_loop (struct loop *loop, int num)\n {\n   basic_block *bbs;\n   struct loop *nloop;\n-  unsigned i;\n+  unsigned i, found;\n   tree cond = NULL_TREE;\n   gimple stmt;\n   bool changed = false;\n \n-  /* Do not unswitch too much.  */\n-  if (num > PARAM_VALUE (PARAM_MAX_UNSWITCH_LEVEL))\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \";; Not unswitching anymore, hit max level\\n\");\n-      return false;\n-    }\n-\n   i = 0;\n   bbs = get_loop_body (loop);\n+  found = loop->num_nodes;\n \n   while (1)\n     {\n@@ -218,8 +211,17 @@ tree_unswitch_single_loop (struct loop *loop, int num)\n \n       if (i == loop->num_nodes)\n \t{\n-\t  free (bbs);\n-\t  return changed;\n+\t  if (dump_file\n+\t      && num > PARAM_VALUE (PARAM_MAX_UNSWITCH_LEVEL)\n+\t      && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \";; Not unswitching anymore, hit max level\\n\");\n+\n+\t  if (found == loop->num_nodes)\n+\t    {\n+\t      free (bbs);\n+\t      return changed;\n+\t    }\n+\t  break;\n \t}\n \n       cond = simplify_using_entry_checks (loop, cond);\n@@ -236,19 +238,107 @@ tree_unswitch_single_loop (struct loop *loop, int num)\n \t  gimple_cond_set_condition_from_tree (stmt, boolean_false_node);\n \t  changed = true;\n \t}\n+      /* Do not unswitch too much.  */\n+      else if (num > PARAM_VALUE (PARAM_MAX_UNSWITCH_LEVEL))\n+\t{\n+\t  i++;\n+\t  continue;\n+\t}\n+      /* In nested tree_unswitch_single_loop first optimize all conditions\n+\t using entry checks, then discover still reachable blocks in the\n+\t loop and find the condition only among those still reachable bbs.  */\n+      else if (num != 0)\n+\t{\n+\t  if (found == loop->num_nodes)\n+\t    found = i;\n+\t  i++;\n+\t  continue;\n+\t}\n       else\n-\tbreak;\n+\t{\n+\t  found = i;\n+\t  break;\n+\t}\n \n       update_stmt (stmt);\n       i++;\n     }\n \n+  if (num != 0)\n+    {\n+      basic_block *tos, *worklist;\n+\n+      /* When called recursively, first do a quick discovery\n+\t of reachable bbs after the above changes and only\n+\t consider conditions in still reachable bbs.  */\n+      tos = worklist = XNEWVEC (basic_block, loop->num_nodes);\n+\n+      for (i = 0; i < loop->num_nodes; i++)\n+\tbbs[i]->flags &= ~BB_REACHABLE;\n+\n+      /* Start with marking header.  */\n+      *tos++ = bbs[0];\n+      bbs[0]->flags |= BB_REACHABLE;\n+\n+      /* Iterate: find everything reachable from what we've already seen\n+\t within the same innermost loop.  Don't look through false edges\n+\t if condition is always true or true edges if condition is\n+\t always false.  */\n+      while (tos != worklist)\n+\t{\n+\t  basic_block b = *--tos;\n+\t  edge e;\n+\t  edge_iterator ei;\n+\t  int flags = 0;\n+\n+\t  if (EDGE_COUNT (b->succs) == 2)\n+\t    {\n+\t      gimple stmt = last_stmt (b);\n+\t      if (stmt\n+\t\t  && gimple_code (stmt) == GIMPLE_COND)\n+\t\t{\n+\t\t  if (gimple_cond_true_p (stmt))\n+\t\t    flags = EDGE_FALSE_VALUE;\n+\t\t  else if (gimple_cond_false_p (stmt))\n+\t\t    flags = EDGE_TRUE_VALUE;\n+\t\t}\n+\t    }\n+\n+\t  FOR_EACH_EDGE (e, ei, b->succs)\n+\t    {\n+\t      basic_block dest = e->dest;\n+\n+\t      if (dest->loop_father == loop\n+\t\t  && !(dest->flags & BB_REACHABLE)\n+\t\t  && !(e->flags & flags))\n+\t\t{\n+\t\t  *tos++ = dest;\n+\t\t  dest->flags |= BB_REACHABLE;\n+\t\t}\n+\t    }\n+\t}\n+\n+      free (worklist);\n+\n+      /* Find a bb to unswitch on.  */\n+      for (; found < loop->num_nodes; found++)\n+\tif ((bbs[found]->flags & BB_REACHABLE)\n+\t    && (cond = tree_may_unswitch_on (bbs[found], loop)))\n+\t  break;\n+\n+      if (found == loop->num_nodes)\n+\t{\n+\t  free (bbs);\n+\t  return changed;\n+\t}\n+    }\n+\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \";; Unswitching loop\\n\");\n \n   initialize_original_copy_tables ();\n   /* Unswitch the loop on this condition.  */\n-  nloop = tree_unswitch_loop (loop, bbs[i], cond);\n+  nloop = tree_unswitch_loop (loop, bbs[found], cond);\n   if (!nloop)\n     {\n       free_original_copy_tables ();"}]}