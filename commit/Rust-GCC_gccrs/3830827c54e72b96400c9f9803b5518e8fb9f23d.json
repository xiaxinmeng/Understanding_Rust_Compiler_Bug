{"sha": "3830827c54e72b96400c9f9803b5518e8fb9f23d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzgzMDgyN2M1NGU3MmI5NjQwMGM5Zjk4MDNiNTUxOGU4ZmI5ZjIzZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-03-02T11:20:29Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-03-02T11:20:29Z"}, "message": "[multiple changes]\n\n2015-03-02  Robert Dewar  <dewar@adacore.com>\n\n\t* atree.ads, atree.adb (Uint24): New function\n\t(Set_Uint24): New procedure.\n\t* atree.h (Uint24): New macro for field access.\n\t* back_end.adb (Call_Back_End): For now, don't call back end\n\tif unnesting subprogs.\n\t* einfo.adb (Activation_Record_Component): New field\n\t(Subps_Index): New field.\n\t* einfo.ads (Activation_Record_Component): New field\n\t(Subps_Index): New field Minor reordering of comments into alpha order.\n\t* exp_unst.ads, exp_unst.adb: Continued development.\n\n2015-03-02  Gary Dismukes  <dismukes@adacore.com>\n\n\t* exp_disp.ads: Minor reformatting.\n\n2015-03-02  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch8.adb (Chain_Use_Clause): Do not chain use clause from\n\tancestor to list of use clauses active in descendant unit if we\n\tare within the private part of an intervening parent, to prevent\n\tcircularities in use clause list.\n\nFrom-SVN: r221114", "tree": {"sha": "a95495c02cb514ca0b3c56effe563a65532db7f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a95495c02cb514ca0b3c56effe563a65532db7f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3830827c54e72b96400c9f9803b5518e8fb9f23d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3830827c54e72b96400c9f9803b5518e8fb9f23d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3830827c54e72b96400c9f9803b5518e8fb9f23d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3830827c54e72b96400c9f9803b5518e8fb9f23d/comments", "author": null, "committer": null, "parents": [{"sha": "024d33d837c172088236be33fd52b7a6ac8e4e9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/024d33d837c172088236be33fd52b7a6ac8e4e9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/024d33d837c172088236be33fd52b7a6ac8e4e9d"}], "stats": {"total": 803, "additions": 633, "deletions": 170}, "files": [{"sha": "d96dd9b83b95219f175f86147e85c6a5788295b2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3830827c54e72b96400c9f9803b5518e8fb9f23d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3830827c54e72b96400c9f9803b5518e8fb9f23d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3830827c54e72b96400c9f9803b5518e8fb9f23d", "patch": "@@ -1,3 +1,27 @@\n+2015-03-02  Robert Dewar  <dewar@adacore.com>\n+\n+\t* atree.ads, atree.adb (Uint24): New function\n+\t(Set_Uint24): New procedure.\n+\t* atree.h (Uint24): New macro for field access.\n+\t* back_end.adb (Call_Back_End): For now, don't call back end\n+\tif unnesting subprogs.\n+\t* einfo.adb (Activation_Record_Component): New field\n+\t(Subps_Index): New field.\n+\t* einfo.ads (Activation_Record_Component): New field\n+\t(Subps_Index): New field Minor reordering of comments into alpha order.\n+\t* exp_unst.ads, exp_unst.adb: Continued development.\n+\n+2015-03-02  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* exp_disp.ads: Minor reformatting.\n+\n+2015-03-02  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch8.adb (Chain_Use_Clause): Do not chain use clause from\n+\tancestor to list of use clauses active in descendant unit if we\n+\tare within the private part of an intervening parent, to prevent\n+\tcircularities in use clause list.\n+\n 2015-03-02  Javier Miranda  <miranda@adacore.com>\n \n \t* exp_ch9.adb (Build_Corresponding_Record): Propagate type"}, {"sha": "036aee3b51a05c39b5787880316e77b5eae0c9c3", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3830827c54e72b96400c9f9803b5518e8fb9f23d/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3830827c54e72b96400c9f9803b5518e8fb9f23d/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=3830827c54e72b96400c9f9803b5518e8fb9f23d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -3181,6 +3181,17 @@ package body Atree is\n          end if;\n       end Uint22;\n \n+      function Uint24 (N : Node_Id) return Uint is\n+         pragma Assert (Nkind (N) in N_Entity);\n+         U : constant Union_Id := Nodes.Table (N + 4).Field6;\n+      begin\n+         if U = 0 then\n+            return Uint_0;\n+         else\n+            return From_Union (U);\n+         end if;\n+      end Uint24;\n+\n       function Ureal3 (N : Node_Id) return Ureal is\n       begin\n          pragma Assert (N <= Nodes.Last);\n@@ -5786,6 +5797,12 @@ package body Atree is\n          Nodes.Table (N + 3).Field9 := To_Union (Val);\n       end Set_Uint22;\n \n+      procedure Set_Uint24 (N : Node_Id; Val : Uint) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 4).Field6 := To_Union (Val);\n+      end Set_Uint24;\n+\n       procedure Set_Ureal3 (N : Node_Id; Val : Ureal) is\n       begin\n          pragma Assert (N <= Nodes.Last);"}, {"sha": "1be32662c253519f6a59ddf480345c4fcfd7ce39", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3830827c54e72b96400c9f9803b5518e8fb9f23d/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3830827c54e72b96400c9f9803b5518e8fb9f23d/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=3830827c54e72b96400c9f9803b5518e8fb9f23d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1424,6 +1424,9 @@ package Atree is\n       function Uint22 (N : Node_Id) return Uint;\n       pragma Inline (Uint22);\n \n+      function Uint24 (N : Node_Id) return Uint;\n+      pragma Inline (Uint24);\n+\n       function Ureal3 (N : Node_Id) return Ureal;\n       pragma Inline (Ureal3);\n \n@@ -2731,6 +2734,9 @@ package Atree is\n       procedure Set_Uint22 (N : Node_Id; Val : Uint);\n       pragma Inline (Set_Uint22);\n \n+      procedure Set_Uint24 (N : Node_Id; Val : Uint);\n+      pragma Inline (Set_Uint24);\n+\n       procedure Set_Ureal3 (N : Node_Id; Val : Ureal);\n       pragma Inline (Set_Ureal3);\n "}, {"sha": "170bd959a6441fc82b3e2e42c351cf878e68217b", "filename": "gcc/ada/atree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3830827c54e72b96400c9f9803b5518e8fb9f23d/gcc%2Fada%2Fatree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3830827c54e72b96400c9f9803b5518e8fb9f23d/gcc%2Fada%2Fatree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.h?ref=3830827c54e72b96400c9f9803b5518e8fb9f23d", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2013, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2015, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -535,6 +535,7 @@ extern Node_Id Current_Error_Node;\n #define Uint16(N)     ((Field16 (N) == 0) ? Uint_0 : Field16 (N))\n #define Uint17(N)     ((Field17 (N) == 0) ? Uint_0 : Field17 (N))\n #define Uint22(N)     ((Field22 (N) == 0) ? Uint_0 : Field22 (N))\n+#define Uint24(N)     ((Field24 (N) == 0) ? Uint_0 : Field24 (N))\n \n #define Ureal3(N)     Field3  (N)\n #define Ureal18(N)    Field18 (N)"}, {"sha": "e7176d25d5575d35414588429f4a973434ec200e", "filename": "gcc/ada/back_end.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3830827c54e72b96400c9f9803b5518e8fb9f23d/gcc%2Fada%2Fback_end.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3830827c54e72b96400c9f9803b5518e8fb9f23d/gcc%2Fada%2Fback_end.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fback_end.adb?ref=3830827c54e72b96400c9f9803b5518e8fb9f23d", "patch": "@@ -118,6 +118,12 @@ package body Back_End is\n          return;\n       end if;\n \n+      --  Skip call if unnesting subprograms (temp for now ???)\n+\n+      if Opt.Unnest_Subprogram_Mode then\n+         return;\n+      end if;\n+\n       --  The back end needs to know the maximum line number that can appear\n       --  in a Sloc, in other words the maximum logical line number.\n "}, {"sha": "9ad146c37abba7adb65e0a99f8356963dc1f3a4d", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3830827c54e72b96400c9f9803b5518e8fb9f23d/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3830827c54e72b96400c9f9803b5518e8fb9f23d/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=3830827c54e72b96400c9f9803b5518e8fb9f23d", "patch": "@@ -214,6 +214,7 @@ package body Einfo is\n \n    --    Related_Expression              Node24\n    --    Uplevel_References              Elist24\n+   --    Subps_Index                     Uint24\n \n    --    Interface_Alias                 Node25\n    --    Interfaces                      Elist25\n@@ -251,6 +252,7 @@ package body Einfo is\n \n    --    Derived_Type_Link               Node31\n    --    Thunk_Entity                    Node31\n+   --    Activation_Record_Component     Node31\n \n    --    SPARK_Pragma                    Node32\n    --    No_Tagged_Streams_Pragma        Node32\n@@ -689,6 +691,17 @@ package body Einfo is\n       return Elist16 (Implementation_Base_Type (Id));\n    end Access_Disp_Table;\n \n+   function Activation_Record_Component (Id : E) return E is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Constant,\n+                                   E_In_Parameter,\n+                                   E_In_Out_Parameter,\n+                                   E_Loop_Parameter,\n+                                   E_Out_Parameter,\n+                                   E_Variable));\n+      return Node31 (Id);\n+   end Activation_Record_Component;\n+\n    function Actual_Subtype (Id : E) return E is\n    begin\n       pragma Assert\n@@ -3139,6 +3152,12 @@ package body Einfo is\n       return Node29 (Id);\n    end Subprograms_For_Type;\n \n+   function Subps_Index (Id : E) return U is\n+   begin\n+      pragma Assert (Is_Subprogram (Id));\n+      return Uint24 (Id);\n+   end Subps_Index;\n+\n    function Suppress_Elaboration_Warnings (Id : E) return B is\n    begin\n       return Flag148 (Id);\n@@ -3533,6 +3552,17 @@ package body Einfo is\n       Set_Node22 (Id, V);\n    end Set_Associated_Storage_Pool;\n \n+   procedure Set_Activation_Record_Component (Id : E; V : E) is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Constant,\n+                                   E_In_Parameter,\n+                                   E_In_Out_Parameter,\n+                                   E_Loop_Parameter,\n+                                   E_Out_Parameter,\n+                                   E_Variable));\n+      Set_Node31 (Id, V);\n+   end Set_Activation_Record_Component;\n+\n    procedure Set_Actual_Subtype (Id : E; V : E) is\n    begin\n       pragma Assert\n@@ -6091,6 +6121,12 @@ package body Einfo is\n       Set_Node29 (Id, V);\n    end Set_Subprograms_For_Type;\n \n+   procedure Set_Subps_Index (Id : E; V : U) is\n+   begin\n+      pragma Assert (Is_Subprogram (Id));\n+      Set_Uint24 (Id, V);\n+   end Set_Subps_Index;\n+\n    procedure Set_Suppress_Elaboration_Warnings (Id : E; V : B := True) is\n    begin\n       Set_Flag148 (Id, V);\n@@ -9689,7 +9725,11 @@ package body Einfo is\n          when E_Function                                   |\n               E_Operator                                   |\n               E_Procedure                                  =>\n-            Write_Str (\"Uplevel_References\");\n+            if Field24 (Id) in Uint_Range then\n+               Write_Str (\"Subps_Index\");\n+            else\n+               Write_Str (\"Uplevel_References\");\n+            end if;\n \n          when others                                       =>\n             Write_Str (\"Field24???\");\n@@ -9899,6 +9939,14 @@ package body Einfo is\n          when Type_Kind                                    =>\n             Write_Str (\"Derived_Type_Link\");\n \n+         when E_Constant                                   |\n+              E_In_Parameter                               |\n+              E_In_Out_Parameter                           |\n+              E_Loop_Parameter                             |\n+              E_Out_Parameter                              |\n+              E_Variable                                   =>\n+            Write_Str (\"Activation_Record_Component\");\n+\n          when others                                       =>\n             Write_Str (\"Field31??\");\n       end case;"}, {"sha": "5ac7f3268d1abbf13bae924da99432b0748c4904", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 49, "deletions": 20, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3830827c54e72b96400c9f9803b5518e8fb9f23d/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3830827c54e72b96400c9f9803b5518e8fb9f23d/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=3830827c54e72b96400c9f9803b5518e8fb9f23d", "patch": "@@ -353,6 +353,13 @@ package Einfo is\n --       used to expand dispatching calls through the primary dispatch table.\n --       For an untagged record, contains No_Elist.\n \n+--    Activation_Record_Component (Node31)\n+--       Defined in E_Variable, E_Constant, E_Loop_Parameter, E_In_Parameter,\n+--       E_Out_Parameter, E_In_Out_Parameter nodes. Used only if we are in\n+--       Opt.Unnest_Subprogram_Mode, in which case for the case of an uplevel\n+--       referenced entity, this field contains the entity for the component\n+--       in the generated ARECnT activation record (Exp_Unst for details).\n+\n --    Actual_Subtype (Node17)\n --       Defined in variables, constants, and formal parameters. This is the\n --       subtype imposed by the value of the object, as opposed to its nominal\n@@ -1163,24 +1170,6 @@ package Einfo is\n --       Note one obscure case: for pragma Default_Storage_Pool (null), the\n --       Etype of the N_Null node is Empty.\n \n---    Extra_Formal (Node15)\n---       Defined in formal parameters in the non-generic case. Certain\n---       parameters require extra implicit information to be passed (e.g. the\n---       flag indicating if an unconstrained variant record argument is\n---       constrained, and the accessibility level for access parameters. See\n---       description of Extra_Constrained, Extra_Accessibility fields for\n---       further details. Extra formal parameters are constructed to represent\n---       these values, and chained to the end of the list of formals using the\n---       Extra_Formal field (i.e. the Extra_Formal field of the last \"real\"\n---       formal points to the first extra formal, and the Extra_Formal field of\n---       each extra formal points to the next one, with Empty indicating the\n---       end of the list of extra formals.\n-\n---    Extra_Formals (Node28)\n---       Applies to subprograms and subprogram types, and also in entries\n---       and entry families. Returns first extra formal of the subprogram\n---       or entry. Returns Empty if there are no extra formals.\n-\n --    Extra_Accessibility (Node13)\n --       Defined in formal parameters in the non-generic case. Normally Empty,\n --       but if expansion is active, and a parameter is one for which a\n@@ -1214,6 +1203,24 @@ package Einfo is\n --       must be retrieved through the entity designed by this field instead of\n --       being computed.\n \n+--    Extra_Formal (Node15)\n+--       Defined in formal parameters in the non-generic case. Certain\n+--       parameters require extra implicit information to be passed (e.g. the\n+--       flag indicating if an unconstrained variant record argument is\n+--       constrained, and the accessibility level for access parameters). See\n+--       description of Extra_Constrained, Extra_Accessibility fields for\n+--       further details. Extra formal parameters are constructed to represent\n+--       these values, and chained to the end of the list of formals using the\n+--       Extra_Formal field (i.e. the Extra_Formal field of the last \"real\"\n+--       formal points to the first extra formal, and the Extra_Formal field of\n+--       each extra formal points to the next one, with Empty indicating the\n+--       end of the list of extra formals).\n+\n+--    Extra_Formals (Node28)\n+--       Applies to subprograms and subprogram types, and also in entries\n+--       and entry families. Returns first extra formal of the subprogram\n+--       or entry. Returns Empty if there are no extra formals.\n+\n --    Finalization_Master (Node23) [root type only]\n --       Defined in access-to-controlled or access-to-class-wide types. The\n --       field contains the entity of the finalization master which handles\n@@ -1261,7 +1268,7 @@ package Einfo is\n --       N_Exit_Statement node with Empty marking the end of the list.\n \n --    First_Formal (synthesized)\n---       Applies to subprograms and subprogram types, and also in entries\n+--       Applies to subprograms and subprogram types, and also to entries\n --       and entry families. Returns first formal of the subprogram or entry.\n --       The formals are the first entities declared in a subprogram or in\n --       a subprogram type (the designated type of an Access_To_Subprogram\n@@ -4121,6 +4128,12 @@ package Einfo is\n --       for Predicate_Function, and clients will always use the latter two\n --       names to access entries in this list.\n \n+--    Subps_Index (Uint24)\n+--       Used during Exp_Inst.Unnest_Subprogram to hold the index in the Subps\n+--       table for a subprogram. See processing in this procedure for details.\n+--       Note that this overlaps Uplevel_References, it is only set after the\n+--       latter field has been acquired.\n+\n --    Suppress_Elaboration_Warnings (Flag148)\n --       Defined in all entities, can be set only for subprogram entities and\n --       for variables. If this flag is set then Sem_Elab will not generate\n@@ -4263,7 +4276,9 @@ package Einfo is\n --       Defined in subprogram entities. Set only if Has_Uplevel_Reference is\n --       set and if we are Unnest_Subprogram_Mode, otherwise undefined. Points\n --       to a list of explicit uplevel references to entities declared in\n---       the subprogram which need rewriting. See spec of Exp_Unst for details.\n+--       the subprogram which need rewriting. Each entry uses two elements of\n+--       the list, the first is the node that is the actual reference, the\n+--       second is the entity of the enclosing subprogram for the reference.\n \n --    Used_As_Generic_Actual (Flag222)\n --       Defined in all entities, set if the entity is used as an argument to\n@@ -5578,6 +5593,7 @@ package Einfo is\n    --    Initialization_Statements           (Node28)\n    --    BIP_Initialization_Call             (Node29)\n    --    Last_Aggregate_Assignment           (Node30)\n+   --    Activation_Record_Component         (Node31)\n    --    Linker_Section_Pragma               (Node33)\n    --    Has_Alignment_Clause                (Flag46)\n    --    Has_Atomic_Components               (Flag86)\n@@ -5755,6 +5771,7 @@ package Einfo is\n    --    Inner_Instances                     (Elist23)  (generic case only)\n    --    Protection_Object                   (Node23)   (for concurrent kind)\n    --    Uplevel_References                  (Elist24)  (non-generic case only)\n+   --    Subps_Index                         (Uint24)   (non-generic case only)\n    --    Interface_Alias                     (Node25)\n    --    Overridden_Operation                (Node26)\n    --    Wrapped_Entity                      (Node27)   (non-generic case only)\n@@ -5868,6 +5885,7 @@ package Einfo is\n    --    Protected_Formal                    (Node22)\n    --    Extra_Constrained                   (Node23)\n    --    Last_Assignment                     (Node26)   (OUT, IN-OUT only)\n+   --    Activation_Record_Component         (Node31)\n    --    Has_Initial_Value                   (Flag219)\n    --    Is_Controlling_Formal               (Flag97)\n    --    Is_Only_Out_Parameter               (Flag226)\n@@ -5926,6 +5944,7 @@ package Einfo is\n    --    Last_Entity                         (Node20)\n    --    Has_Nested_Subprogram               (Flag282)\n    --    Uplevel_References                  (Elist24)\n+   --    Subps_Index                         (Uint24)\n    --    Overridden_Operation                (Node26)\n    --    Subprograms_For_Type                (Node29)\n    --    Linker_Section_Pragma               (Node33)\n@@ -6058,6 +6077,7 @@ package Einfo is\n    --    Inner_Instances                     (Elist23)  (generic case only)\n    --    Protection_Object                   (Node23)   (for concurrent kind)\n    --    Uplevel_References                  (Elist24)  (non-generic case only)\n+   --    Subps_Index                         (Uint24)   (non-generic case only)\n    --    Interface_Alias                     (Node25)\n    --    Overridden_Operation                (Node26)   (never for init proc)\n    --    Wrapped_Entity                      (Node27)   (non-generic case only)\n@@ -6303,6 +6323,7 @@ package Einfo is\n    --    Initialization_Statements           (Node28)\n    --    BIP_Initialization_Call             (Node29)\n    --    Last_Aggregate_Assignment           (Node30)\n+   --    Activation_Record_Component         (Node31)\n    --    Linker_Section_Pragma               (Node33)\n    --    Contract                            (Node34)\n    --    Has_Alignment_Clause                (Flag46)\n@@ -6568,6 +6589,7 @@ package Einfo is\n    function Abstract_States                     (Id : E) return L;\n    function Accept_Address                      (Id : E) return L;\n    function Access_Disp_Table                   (Id : E) return L;\n+   function Activation_Record_Component         (Id : E) return E;\n    function Actual_Subtype                      (Id : E) return E;\n    function Address_Taken                       (Id : E) return B;\n    function Alias                               (Id : E) return E;\n@@ -6987,6 +7009,7 @@ package Einfo is\n    function String_Literal_Length               (Id : E) return U;\n    function String_Literal_Low_Bound            (Id : E) return N;\n    function Subprograms_For_Type                (Id : E) return E;\n+   function Subps_Index                         (Id : E) return U;\n    function Suppress_Elaboration_Warnings       (Id : E) return B;\n    function Suppress_Initialization             (Id : E) return B;\n    function Suppress_Style_Checks               (Id : E) return B;\n@@ -7216,6 +7239,7 @@ package Einfo is\n    procedure Set_Abstract_States                 (Id : E; V : L);\n    procedure Set_Accept_Address                  (Id : E; V : L);\n    procedure Set_Access_Disp_Table               (Id : E; V : L);\n+   procedure Set_Activation_Record_Component     (Id : E; V : E);\n    procedure Set_Actual_Subtype                  (Id : E; V : E);\n    procedure Set_Address_Taken                   (Id : E; V : B := True);\n    procedure Set_Alias                           (Id : E; V : E);\n@@ -7639,6 +7663,7 @@ package Einfo is\n    procedure Set_String_Literal_Length           (Id : E; V : U);\n    procedure Set_String_Literal_Low_Bound        (Id : E; V : N);\n    procedure Set_Subprograms_For_Type            (Id : E; V : E);\n+   procedure Set_Subps_Index                     (Id : E; V : U);\n    procedure Set_Suppress_Elaboration_Warnings   (Id : E; V : B := True);\n    procedure Set_Suppress_Initialization         (Id : E; V : B := True);\n    procedure Set_Suppress_Style_Checks           (Id : E; V : B := True);\n@@ -7980,6 +8005,7 @@ package Einfo is\n    pragma Inline (Abstract_States);\n    pragma Inline (Accept_Address);\n    pragma Inline (Access_Disp_Table);\n+   pragma Inline (Activation_Record_Component);\n    pragma Inline (Actual_Subtype);\n    pragma Inline (Address_Taken);\n    pragma Inline (Alias);\n@@ -8443,6 +8469,7 @@ package Einfo is\n    pragma Inline (String_Literal_Length);\n    pragma Inline (String_Literal_Low_Bound);\n    pragma Inline (Subprograms_For_Type);\n+   pragma Inline (Subps_Index);\n    pragma Inline (Suppress_Elaboration_Warnings);\n    pragma Inline (Suppress_Initialization);\n    pragma Inline (Suppress_Style_Checks);\n@@ -8476,6 +8503,7 @@ package Einfo is\n    pragma Inline (Set_Abstract_States);\n    pragma Inline (Set_Accept_Address);\n    pragma Inline (Set_Access_Disp_Table);\n+   pragma Inline (Set_Activation_Record_Component);\n    pragma Inline (Set_Actual_Subtype);\n    pragma Inline (Set_Address_Taken);\n    pragma Inline (Set_Alias);\n@@ -8894,6 +8922,7 @@ package Einfo is\n    pragma Inline (Set_String_Literal_Length);\n    pragma Inline (Set_String_Literal_Low_Bound);\n    pragma Inline (Set_Subprograms_For_Type);\n+   pragma Inline (Set_Subps_Index);\n    pragma Inline (Set_Suppress_Elaboration_Warnings);\n    pragma Inline (Set_Suppress_Initialization);\n    pragma Inline (Set_Suppress_Style_Checks);"}, {"sha": "a1cc11068ebbe4ddf9046cc5c478dc6ffdb1fe1c", "filename": "gcc/ada/exp_disp.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3830827c54e72b96400c9f9803b5518e8fb9f23d/gcc%2Fada%2Fexp_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3830827c54e72b96400c9f9803b5518e8fb9f23d/gcc%2Fada%2Fexp_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.ads?ref=3830827c54e72b96400c9f9803b5518e8fb9f23d", "patch": "@@ -386,7 +386,7 @@ package Exp_Disp is\n \n    procedure Set_DTC_Entity_Value (Tagged_Type : Entity_Id; Prim : Entity_Id);\n    --  Set the definite value of the DTC_Entity value associated with a given\n-   --  primitive of a tagged type. For subprogram wrappers propagat the value\n+   --  primitive of a tagged type. For subprogram wrappers, propagate the value\n    --  to the wrapped subprogram.\n \n    procedure Write_DT (Typ : Entity_Id);"}, {"sha": "f5022b95929e24133d510069517d3027906a5c1e", "filename": "gcc/ada/exp_unst.adb", "status": "modified", "additions": 442, "deletions": 119, "changes": 561, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3830827c54e72b96400c9f9803b5518e8fb9f23d/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3830827c54e72b96400c9f9803b5518e8fb9f23d/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=3830827c54e72b96400c9f9803b5518e8fb9f23d", "patch": "@@ -26,6 +26,7 @@\n with Atree;    use Atree;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n+with Exp_Util; use Exp_Util;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n@@ -36,9 +37,84 @@ with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with Table;\n with Tbuild;   use Tbuild;\n+with Uintp;    use Uintp;\n \n package body Exp_Unst is\n \n+   --  Tables used by Unnest_Subprogram\n+\n+   type Subp_Entry is record\n+      Ent : Entity_Id;\n+      --  Entity of the subprogram\n+\n+      Bod : Node_Id;\n+      --  Subprogram_Body node for this subprogram\n+\n+      Lev : Nat;\n+      --  Subprogram level (1 = outer subprogram (Subp argument), 2 = nested\n+      --  immediately within this outer subprogram etc.)\n+\n+      Urefs : Elist_Id;\n+      --  This is a copy of the Uplevel_References field from the entity for\n+      --  the subprogram. Copy this to reuse the field for Subps_Index.\n+\n+      ARECnF : Entity_Id;\n+      --  This entity is defined for all subprograms with uplevel references\n+      --  except for the top-level subprogram (Subp itself). It is the entity\n+      --  for the formal which is added to the parameter list to pass the\n+      --  pointer to the activation record. Note that for this entity, n is\n+      --  one less than the current level.\n+\n+      ARECn   : Entity_Id;\n+      ARECnT  : Entity_Id;\n+      ARECnPT : Entity_Id;\n+      ARECnP  : Entity_Id;\n+      --  These AREC entities are defined only for subprograms for which we\n+      --  generate an activation record declaration, i.e. for subprograms\n+      --  with at least one nested subprogram that have uplevel referennces.\n+      --  They are set to Empty for all other cases.\n+\n+      ARECnU : Entity_Id;\n+      --  This AREC entity is the uplink component. It is other than Empty only\n+      --  for nested subprograms that themselves have nested subprograms and\n+      --  have uplevel references. Note that the n here is one less than the\n+      --  level of the subprogram defining the activation record.\n+\n+   end record;\n+\n+   subtype SI_Type is Nat;\n+\n+   package Subps is new Table.Table (\n+     Table_Component_Type => Subp_Entry,\n+     Table_Index_Type     => SI_Type,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 100,\n+     Table_Increment      => 200,\n+     Table_Name           => \"Subps\");\n+   --  Records the subprograms in the nest whose outer subprogram is Subp\n+\n+   type Call_Entry is record\n+      N   : Node_Id;\n+      --  The actual call\n+\n+      From : Entity_Id;\n+      --  Entity of the subprogram containing the call\n+\n+      To : Entity_Id;\n+      --  Entity of the subprogram called\n+   end record;\n+\n+   package Calls is new Table.Table (\n+     Table_Component_Type => Call_Entry,\n+     Table_Index_Type     => Nat,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 100,\n+     Table_Increment      => 200,\n+     Table_Name           => \"Calls\");\n+   --  Records each call within the outer subprogram and all nested subprograms\n+   --  that are to other subprograms nested within the outer subprogram. These\n+   --  are the calls that may need an additional parameter.\n+\n    -------------------------------------\n    -- Check_Uplevel_Reference_To_Type --\n    -------------------------------------\n@@ -194,71 +270,44 @@ package body Exp_Unst is\n          Set_Uplevel_References (Subp, New_Elmt_List);\n       end if;\n \n-      --  Add new element to Uplevel_References\n+      --  Add new entry to Uplevel_References. Each entry is two elements of\n+      --  the list. The first is the actual reference, the second is the\n+      --  enclosing subprogram at the point of reference\n+\n+      Append_Elmt\n+        (N, Uplevel_References (Subp));\n+\n+      if Is_Subprogram (Current_Scope) then\n+         Append_Elmt (Current_Scope, Uplevel_References (Subp));\n+      else\n+         Append_Elmt\n+           (Enclosing_Subprogram (Current_Scope), Uplevel_References (Subp));\n+      end if;\n \n-      Append_Elmt (N, Uplevel_References (Subp));\n       Set_Has_Uplevel_Reference (Entity (N));\n    end Note_Uplevel_Reference;\n \n    -----------------------\n    -- Unnest_Subprogram --\n    -----------------------\n \n-   --  Tables used by Unnest_Subprogram\n-\n-   type Subp_Entry is record\n-      Ent : Entity_Id;\n-      --  Entity of the subprogram\n-\n-      Bod : Node_Id;\n-      --  Subprogram_Body node for this subprogram\n-\n-      Lev : Nat;\n-      --  Subprogram level (1 = outer subprogram (Subp argument), 2 = nested\n-      --  immediately within this outer subprogram etc.)\n-   end record;\n-\n-   package Subps is new Table.Table (\n-     Table_Component_Type => Subp_Entry,\n-     Table_Index_Type     => Nat,\n-     Table_Low_Bound      => 1,\n-     Table_Initial        => 100,\n-     Table_Increment      => 200,\n-     Table_Name           => \"Subps\");\n-   --  Records the subprograms in the nest whose outer subprogram is Subp\n-\n-   type Call_Entry is record\n-      N   : Node_Id;\n-      --  The actual call\n-\n-      From : Entity_Id;\n-      --  Entity of the subprogram containing the call\n-\n-      To : Entity_Id;\n-      --  Entity of the subprogram called\n-   end record;\n-\n-   package Calls is new Table.Table (\n-     Table_Component_Type => Call_Entry,\n-     Table_Index_Type     => Nat,\n-     Table_Low_Bound      => 1,\n-     Table_Initial        => 100,\n-     Table_Increment      => 200,\n-     Table_Name           => \"Calls\");\n-   --  Records each call within the outer subprogram and all nested subprograms\n-   --  that are to other subprograms nested within the outer subprogram. These\n-   --  are the calls that may need an additional parameter.\n-\n    procedure Unnest_Subprogram (Subp : Entity_Id; Subp_Body : Node_Id) is\n-\n       function Get_AREC_String (Lev : Pos) return String;\n       --  Given a level value, 1, 2, ... returns the string AREC, AREC2, ...\n \n+      function Get_Enclosing_Subp (Subp : SI_Type) return SI_Type;\n+      --  Subp is the index of a subprogram which has a Lev greater than 1.\n+      --  This function returns the index of the enclosing subprogram which\n+      --  will have a Lev value one less than this.\n+\n       function Get_Level (Sub : Entity_Id) return Nat;\n       --  Sub is either Subp itself, or a subprogram nested within Subp. This\n       --  function returns the level of nesting (Subp = 1, subprograms that\n       --  are immediately nested within Subp = 2, etc).\n \n+      function Subp_Index (Sub : Entity_Id) return SI_Type;\n+      --  Given the entity for a subprogram, return corresponding Subps index\n+\n       ---------------------\n       -- Get_AREC_String --\n       ---------------------\n@@ -274,6 +323,20 @@ package body Exp_Unst is\n          end if;\n       end Get_AREC_String;\n \n+      ------------------------\n+      -- Get_Enclosing_Subp --\n+      ------------------------\n+\n+      function Get_Enclosing_Subp (Subp : SI_Type) return SI_Type is\n+         STJ : Subp_Entry renames Subps.Table (Subp);\n+         Ret : constant SI_Type :=\n+                 UI_To_Int (Subps_Index (Enclosing_Subprogram (STJ.Ent)));\n+      begin\n+         pragma Assert (STJ.Lev > 1);\n+         pragma Assert (Subps.Table (Ret).Lev = STJ.Lev - 1);\n+         return Ret;\n+      end Get_Enclosing_Subp;\n+\n       ---------------\n       -- Get_Level --\n       ---------------\n@@ -294,6 +357,16 @@ package body Exp_Unst is\n          end loop;\n       end Get_Level;\n \n+      ----------------\n+      -- Subp_Index --\n+      ----------------\n+\n+      function Subp_Index (Sub : Entity_Id) return SI_Type is\n+      begin\n+         pragma Assert (Is_Subprogram (Sub));\n+         return SI_Type (UI_To_Int (Subps_Index (Sub)));\n+      end Subp_Index;\n+\n    --  Start of processing for Unnest_Subprogram\n \n    begin\n@@ -309,7 +382,7 @@ package body Exp_Unst is\n       --  subprogram has a call to a subprogram requiring a static link, then\n       --  the calling subprogram requires a static link.\n \n-      --  First step, populate the above tables\n+      --  First populate the above tables\n \n       Subps.Init;\n       Calls.Init;\n@@ -353,26 +426,43 @@ package body Exp_Unst is\n          --  Start of processing for Visit_Node\n \n          begin\n+            --  Record a call\n+\n             if Nkind_In (N, N_Procedure_Call_Statement, N_Function_Call) then\n                Ent := Entity (Name (N));\n \n                if not Is_Library_Level_Entity (Ent) then\n                   Calls.Append ((N, Find_Current_Subprogram, Ent));\n                end if;\n \n-            elsif Nkind (N) = N_Subprogram_Body and then Acts_As_Spec (N) then\n-               Ent := Defining_Unit_Name (Specification (N));\n-               Subps.Append\n-                 ((Ent => Ent,\n-                   Bod => N,\n-                   Lev => Get_Level (Ent)));\n-\n-            elsif Nkind (N) = N_Subprogram_Declaration then\n-               Ent := Defining_Unit_Name (Specification (N));\n-               Subps.Append\n-                 ((Ent => Ent,\n-                   Bod => Corresponding_Body (N),\n-                   Lev => Get_Level (Ent)));\n+            --  Record a subprogram\n+\n+            elsif (Nkind (N) = N_Subprogram_Body and then Acts_As_Spec (N))\n+              or else Nkind (N) = N_Subprogram_Declaration\n+            then\n+               Subps.Increment_Last;\n+\n+               declare\n+                  STJ : Subp_Entry renames Subps.Table (Subps.Last);\n+\n+               begin\n+                  --  Set fields of Subp_Entry for new subprogram\n+\n+                  STJ.Ent := Defining_Unit_Name (Specification (N));\n+                  STJ.Lev := Get_Level (STJ.Ent);\n+\n+                  if Nkind (N) = N_Subprogram_Body then\n+                     STJ.Bod := N;\n+                  else\n+                     STJ.Bod := Corresponding_Body (N);\n+                  end if;\n+\n+                  --  Capture Uplevel_References, and then set (uses the same\n+                  --  field), the Subps_Index value for this subprogram.\n+\n+                  STJ.Urefs := Uplevel_References (STJ.Ent);\n+                  Set_Subps_Index (STJ.Ent, UI_From_Int (Int (Subps.Last)));\n+               end;\n             end if;\n \n             return OK;\n@@ -423,11 +513,71 @@ package body Exp_Unst is\n          end loop Outer;\n       end Closure;\n \n-      --  Next step, process each subprogram in turn, inserting necessary\n-      --  declarations for ARECxx types and variables for any subprogram\n-      --  that has nested subprograms, and is uplevel referenced.\n+      --  Next step, create the entities for code we will insert. We do this\n+      --  at the start so that all the entities are defined, regardless of the\n+      --  order in which we do the code insertions.\n+\n+      for J in Subps.First .. Subps.Last loop\n+         declare\n+            STJ : Subp_Entry renames Subps.Table (J);\n+            Loc : constant Source_Ptr := Sloc (STJ.Bod);\n+            ARS : constant String     := Get_AREC_String (STJ.Lev);\n \n-      Arec_Decls : declare\n+         begin\n+            if STJ.Ent = Subp then\n+               STJ.ARECnF := Empty;\n+            else\n+               STJ.ARECnF :=\n+                 Make_Defining_Identifier (Loc,\n+                   Chars =>\n+                     Name_Find_Str (Get_AREC_String (STJ.Lev - 1) & \"F\"));\n+            end if;\n+\n+            if Has_Nested_Subprogram (STJ.Ent)\n+              and then Has_Uplevel_Reference (STJ.Ent)\n+            then\n+               STJ.ARECn   :=\n+                 Make_Defining_Identifier (Loc, Name_Find_Str (ARS));\n+               STJ.ARECnT  :=\n+                 Make_Defining_Identifier (Loc, Name_Find_Str (ARS & \"T\"));\n+               STJ.ARECnPT :=\n+                 Make_Defining_Identifier (Loc, Name_Find_Str (ARS & \"PT\"));\n+               STJ.ARECnP  :=\n+                 Make_Defining_Identifier (Loc, Name_Find_Str (ARS & \"P\"));\n+\n+            else\n+               STJ.ARECn   := Empty;\n+               STJ.ARECnT  := Empty;\n+               STJ.ARECnPT := Empty;\n+               STJ.ARECnP  := Empty;\n+               STJ.ARECnU  := Empty;\n+            end if;\n+\n+            --  Define uplink component entity if inner nesting case and also\n+            --  the extra formal entity.\n+\n+            if Has_Uplevel_Reference (STJ.Ent) and then STJ.Lev > 1 then\n+               declare\n+                  ARS1 : constant String := Get_AREC_String (STJ.Lev - 1);\n+               begin\n+                  STJ.ARECnU :=\n+                    Make_Defining_Identifier (Loc,\n+                      Chars => Name_Find_Str (ARS1 & \"U\"));\n+                  STJ.ARECnF :=\n+                    Make_Defining_Identifier (Loc,\n+                      Chars => Name_Find_Str (ARS1 & \"F\"));\n+               end;\n+\n+            else\n+               STJ.ARECnU := Empty;\n+               STJ.ARECnF := Empty;\n+            end if;\n+         end;\n+      end loop;\n+\n+      --  Loop through subprograms\n+\n+      Subp_Loop : declare\n          Addr : constant Entity_Id := RTE (RE_Address);\n \n       begin\n@@ -436,23 +586,30 @@ package body Exp_Unst is\n                STJ : Subp_Entry renames Subps.Table (J);\n \n             begin\n-               --  We add AREC declarations for any subprogram that has at\n-               --  least one nested subprogram, and has uplevel references.\n+               --  First add the extra formal if needed. This applies to all\n+               --  nested subprograms that have uplevel references.\n+\n+               if STJ.Lev > 1 and then Has_Uplevel_Reference (STJ.Ent) then\n+                  null; -- TBD???\n+               end if;\n+\n+               --  Processing for subprograms that have at least one nested\n+               --  subprogram, and have uplevel references.\n \n                if Has_Nested_Subprogram (STJ.Ent)\n                  and then Has_Uplevel_Reference (STJ.Ent)\n                then\n-                  Add_AREC_Declarations : declare\n+                  --  Local declarations for one such subprogram\n+\n+                  declare\n                      Loc   : constant Source_Ptr := Sloc (STJ.Bod);\n-                     ARS   : constant String     := Get_AREC_String (STJ.Lev);\n-                     Urefs : constant Elist_Id   :=\n-                               Uplevel_References (STJ.Ent);\n                      Elmt  : Elmt_Id;\n                      Ent   : Entity_Id;\n                      Clist : List_Id;\n+                     Comp  : Entity_Id;\n \n                      Uplevel_Entities :\n-                       array (1 .. List_Length (Urefs)) of Entity_Id;\n+                       array (1 .. List_Length (STJ.Urefs)) of Entity_Id;\n                      Num_Uplevel_Entities : Nat;\n                      --  Uplevel_Entities (1 .. Num_Uplevel_Entities) contains\n                      --  a list (with no duplicates) of the entities for this\n@@ -465,7 +622,7 @@ package body Exp_Unst is\n                      --  Uplevel_Reference_Noted to avoid duplicates.\n \n                      Num_Uplevel_Entities := 0;\n-                     Elmt := First_Elmt (Urefs);\n+                     Elmt := First_Elmt (STJ.Urefs);\n                      while Present (Elmt) loop\n                         Ent := Entity (Node (Elmt));\n \n@@ -476,38 +633,48 @@ package body Exp_Unst is\n                         end if;\n \n                         Next_Elmt (Elmt);\n+                        Next_Elmt (Elmt);\n                      end loop;\n \n                      --  Build list of component declarations for ARECnT\n \n                      Clist := Empty_List;\n \n-                     --  If not top level, include ARECn : ARECnPT := ARECnP\n+                     --  If not top level, include ARECnU : ARECnPT := ARECnF\n+                     --  where n is one less than the current level and the\n+                     --  entity ARECnPT comes from the enclosing subprogram.\n \n                      if STJ.Lev > 1 then\n-                        Append_To (Clist,\n-                          Make_Component_Declaration (Loc,\n-                            Defining_Identifier =>\n-                              Make_Defining_Identifier (Loc,\n-                                Chars => Name_Find_Str (ARS)),\n-                            Component_Definition =>\n-                              Make_Component_Definition (Loc,\n-                                Subtype_Indication =>\n-                                  Make_Identifier (Loc,\n-                                    Chars => Name_Find_Str (ARS & \"PT\"))),\n-                            Expression =>\n-                              Make_Identifier (Loc,\n-                                Chars => Name_Find_Str (ARS & \"P\"))));\n+                        declare\n+                           STJE : Subp_Entry\n+                             renames Subps.Table (Get_Enclosing_Subp (J));\n+\n+                        begin\n+                           Append_To (Clist,\n+                             Make_Component_Declaration (Loc,\n+                               Defining_Identifier  => STJ.ARECnU,\n+                               Component_Definition =>\n+                                 Make_Component_Definition (Loc,\n+                                   Subtype_Indication =>\n+                                     New_Occurrence_Of (STJE.ARECnPT, Loc)),\n+                               Expression           =>\n+                                 New_Occurrence_Of (STJ.ARECnF, Loc)));\n+                        end;\n                      end if;\n \n                      --  Add components for uplevel referenced entities\n \n                      for J in 1 .. Num_Uplevel_Entities loop\n+                        Comp :=\n+                          Make_Defining_Identifier (Loc,\n+                            Chars => Chars (Uplevel_Entities (J)));\n+\n+                        Set_Activation_Record_Component\n+                            (Uplevel_Entities (J), Comp);\n+\n                         Append_To (Clist,\n                           Make_Component_Declaration (Loc,\n-                            Defining_Identifier =>\n-                              Make_Defining_Identifier (Loc,\n-                                Chars => Chars (Uplevel_Entities (J))),\n+                            Defining_Identifier  => Comp,\n                             Component_Definition =>\n                               Make_Component_Definition (Loc,\n                                 Subtype_Indication =>\n@@ -519,54 +686,210 @@ package body Exp_Unst is\n                      Prepend_List_To (Declarations (STJ.Bod),\n                        New_List (\n \n-                         --  type ARECT is record .. end record;\n+                         --  type ARECnT is record .. end record;\n \n                          Make_Full_Type_Declaration (Loc,\n-                           Defining_Identifier =>\n-                             Make_Defining_Identifier (Loc,\n-                               Chars => Name_Find_Str (ARS & \"T\")),\n+                           Defining_Identifier => STJ.ARECnT,\n                            Type_Definition     =>\n                              Make_Record_Definition (Loc,\n                                Component_List =>\n                                  Make_Component_List (Loc,\n                                    Component_Items => Clist))),\n \n-                         --  type ARECPT is access all ARECT;\n+                         --  ARECn : aliased ARECnT;\n+\n+                         Make_Object_Declaration (Loc,\n+                           Defining_Identifier => STJ.ARECn,\n+                             Aliased_Present   => True,\n+                             Object_Definition =>\n+                               New_Occurrence_Of (STJ.ARECnT, Loc)),\n+\n+                         --  type ARECnPT is access all ARECnT;\n \n                          Make_Full_Type_Declaration (Loc,\n-                           Defining_Identifier =>\n-                             Make_Defining_Identifier (Loc,\n-                               Chars => Name_Find_Str (ARS & \"PT\")),\n-                             Type_Definition   =>\n-                                Make_Access_To_Object_Definition (Loc,\n-                                  All_Present        => True,\n-                                  Subtype_Indication =>\n-                                    Make_Identifier (Loc,\n-                                      Chars => Name_Find_Str (ARS & \"T\")))),\n-\n-                        --  ARECP : constant ARECPT := AREC'Access;\n+                           Defining_Identifier => STJ.ARECnPT,\n+                           Type_Definition     =>\n+                             Make_Access_To_Object_Definition (Loc,\n+                               All_Present        => True,\n+                               Subtype_Indication =>\n+                                 New_Occurrence_Of (STJ.ARECnT, Loc))),\n+\n+                        --  ARECnP : constant ARECnPT := ARECn'Access;\n \n                         Make_Object_Declaration (Loc,\n-                          Defining_Identifier =>\n-                            Make_Defining_Identifier (Loc,\n-                              Chars => Name_Find_Str (ARS & \"P\")),\n+                          Defining_Identifier => STJ.ARECnP,\n                           Constant_Present    => True,\n                           Object_Definition   =>\n-                            Make_Identifier (Loc, Name_Find_Str (ARS & \"PT\")),\n+                            New_Occurrence_Of (STJ.ARECnPT, Loc),\n                           Expression          =>\n                             Make_Attribute_Reference (Loc,\n-                              Prefix         =>\n-                                Make_Identifier (Loc, Name_Find_Str (ARS)),\n-                                  Attribute_Name => Name_Access))));\n-                  end Add_AREC_Declarations;\n+                              Prefix           =>\n+                                New_Occurrence_Of (STJ.ARECn, Loc),\n+                              Attribute_Name => Name_Access))));\n+\n+                     --  Next step, for each uplevel referenced entity, add\n+                     --  assignment operations to set the comoponent in the\n+                     --  activation record.\n+\n+                     for J in 1 .. Num_Uplevel_Entities loop\n+                        declare\n+                           Ent : constant Entity_Id  := Uplevel_Entities (J);\n+                           Loc : constant Source_Ptr := Sloc (Ent);\n+                           Dec : constant Node_Id    := Declaration_Node (Ent);\n+\n+                        begin\n+                           Set_Aliased_Present (Dec);\n+\n+                           Insert_After (Dec,\n+                             Make_Assignment_Statement (Loc,\n+                               Name       =>\n+                                 Make_Selected_Component (Loc,\n+                                   Prefix        =>\n+                                     New_Occurrence_Of (STJ.ARECn, Loc),\n+                                   Selector_Name =>\n+                                     Make_Identifier (Loc, Chars (Ent))),\n+\n+                               Expression =>\n+                                 Make_Attribute_Reference (Loc,\n+                                   Prefix         =>\n+                                     New_Occurrence_Of (Ent, Loc),\n+                                   Attribute_Name => Name_Address)));\n+                        end;\n+                     end loop;\n+\n+                     --  Next step, process uplevel references\n+\n+                     Uplev_Refs : declare\n+                        Elmt : Elmt_Id;\n+\n+                     begin\n+                        --  Loop through uplevel references\n+\n+                        Elmt := First_Elmt (STJ.Urefs);\n+                        while Present (Elmt) loop\n+                           declare\n+                              Ref : constant Node_Id := Node (Elmt);\n+                              --  The uplevel reference itself\n+\n+                              Loc : constant Source_Ptr := Sloc (Ref);\n+                              --  Source location for the reference\n+\n+                              Ent : constant Entity_Id := Entity (Ref);\n+                              --  The referenced entity\n+\n+                              Typ : constant Entity_Id := Etype (Ent);\n+                              --  The type of the referenced entity\n+\n+                              Rsub : constant Entity_Id :=\n+                                       Node (Next_Elmt (Elmt));\n+                              --  The enclosing subprogram for the reference\n+\n+                              RSX : constant SI_Type := Subp_Index (Rsub);\n+                              --  Subp_Index for enclosing subprogram for ref\n+\n+                              STJR : Subp_Entry renames Subps.Table (RSX);\n+                              --  Subp_Entry for enclosing subprogram for ref\n+\n+                              Tnn : constant Entity_Id :=\n+                                      Make_Temporary\n+                                        (Loc, 'T', Related_Node => Ref);\n+                              --  Local pointer type for reference\n+\n+                              Pfx  : Node_Id;\n+                              Comp : Entity_Id;\n+                              SI   : SI_Type;\n+\n+                           begin\n+                              --  First insert declaration for pointer type\n+\n+                              --    type Tnn is access all typ;\n+\n+                              Insert_Action (Ref,\n+                                Make_Full_Type_Declaration (Loc,\n+                                  Defining_Identifier => Tnn,\n+                                  Type_Definition     =>\n+                                    Make_Access_To_Object_Definition (Loc,\n+                                      All_Present        => True,\n+                                      Subtype_Indication =>\n+                                        New_Occurrence_Of (Typ, Loc))));\n+\n+                              --  Now we need to rewrite the reference. The\n+                              --  reference is from level STJE.Lev to level\n+                              --  STJ.Lev. The general form of the rewritten\n+                              --  reference for entity X is:\n+\n+                              --    Tnn!(ARECaF.ARECbU.ARECcU.ARECdU\n+                              --            ....ARECm.X).all\n+\n+                              --  where a,b,c,d .. m =\n+                              --        STJR.Lev - 1,  STJ.Lev - 2, .. STJ.Lev\n+\n+                              pragma Assert (STJR.Lev > STJ.Lev);\n+\n+                              --  Compute the prefix of X. Here are examples\n+                              --  to make things clear (with parens to show\n+                              --  groupings, the prefix is everything except\n+                              --  the .X at the end).\n+\n+                              --   level 2 to level 1\n+\n+                              --     AREC1F.X\n+\n+                              --   level 3 to level 1\n+\n+                              --     (AREC2F.AREC1U).X\n+\n+                              --   level 4 to level 1\n+\n+                              --     ((AREC3F.AREC2U).AREC1U).X\n+\n+                              --   level 6 to level 2\n+\n+                              --     (((AREC5F.AREC4U).AREC3U).AREC2U).X\n+\n+                              Pfx := New_Occurrence_Of (STJR.ARECnF, Loc);\n+                              SI := RSX;\n+                              for L in STJ.Lev .. STJR.Lev - 2 loop\n+                                 SI := Get_Enclosing_Subp (SI);\n+                                 Pfx :=\n+                                   Make_Selected_Component (Loc,\n+                                     Prefix        => Pfx,\n+                                     Selector_Name =>\n+                                       New_Occurrence_Of\n+                                         (Subps.Table (SI).ARECnU, Loc));\n+                              end loop;\n+\n+                              --  Get activation record component (must exist)\n+\n+                              Comp := Activation_Record_Component (Ent);\n+                              pragma Assert (Present (Comp));\n+\n+                              --  Do the replacement\n+\n+                              Rewrite (Ref,\n+                                Make_Explicit_Dereference (Loc,\n+                                  Prefix =>\n+                                    Unchecked_Convert_To (Tnn,\n+                                      Make_Selected_Component (Loc,\n+                                        Prefix        => Pfx,\n+                                        Selector_Name =>\n+                                          New_Occurrence_Of (Comp, Loc)))));\n+\n+                              Next_Elmt (Elmt);\n+                              Next_Elmt (Elmt);\n+                           end;\n+                        end loop;\n+                     end Uplev_Refs;\n+                  end;\n                end if;\n             end;\n          end loop;\n-      end Arec_Decls;\n+      end Subp_Loop;\n+\n+      --  Finally, loop through all calls adding extra actual for the\n+      --  activation record where it is required.\n \n-      --  Next step, for each uplevel referenced entity, add assignment\n-      --  operations to set the corresponding AREC fields, and define\n-      --  the PTR types.\n+      --  TBD ???\n \n       return;\n    end Unnest_Subprogram;"}, {"sha": "32b2eb82824d63911d0ba62fa926aa3de44e1153", "filename": "gcc/ada/exp_unst.ads", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3830827c54e72b96400c9f9803b5518e8fb9f23d/gcc%2Fada%2Fexp_unst.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3830827c54e72b96400c9f9803b5518e8fb9f23d/gcc%2Fada%2Fexp_unst.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.ads?ref=3830827c54e72b96400c9f9803b5518e8fb9f23d", "patch": "@@ -165,9 +165,6 @@ package Exp_Unst is\n    --    since they will be accessed indirectly via an activation record as\n    --    described below.\n \n-   --    For each such entity xxx we create an access type xxxPTR (forced to\n-   --    single length in the unconstrained case).\n-\n    --    An activation record is created containing system address values\n    --    for each uplevel referenced entity in a given scope. In the example\n    --    given before, we would have:\n@@ -177,8 +174,11 @@ package Exp_Unst is\n    --         x  : Address;\n    --         rv : Address;\n    --      end record;\n-   --      type AREC1P is access all AREC1T;\n-   --      AREC1 : AREC1T;\n+\n+   --      AREC1 : aliased AREC1T;\n+\n+   --      type AREC1PT is access all AREC1T;\n+   --      AREC1P : constant AREC1PT := AREC1'Access;\n \n    --   The fields of AREC1 are set at the point the corresponding entity\n    --   is declared (immediately for parameters).\n@@ -188,8 +188,8 @@ package Exp_Unst is\n    --   will use AREC2, AREC3, ...\n \n    --   For all subprograms nested immediately within the corresponding scope,\n-   --   a parameter AREC1P is passed, and all calls to these routines have\n-   --   AREC1 added as an additional formal.\n+   --   a parameter AREC1F is passed, and all calls to these routines have\n+   --   AREC1P added as an additional formal.\n \n    --   Now within the nested procedures, any reference to an uplevel entity\n    --   xxx is replaced by Tnn!(AREC1.xxx).all (where ! represents a call\n@@ -216,11 +216,11 @@ package Exp_Unst is\n    --\n    --          AREC1.b := b'Address;\n    --\n-   --          procedure inner (bb : integer; AREC1P : AREC1PT);\n+   --          procedure inner (bb : integer; AREC1F : AREC1PT);\n    --\n-   --          procedure inner2 (AREC1P : AREC1PT) is\n+   --          procedure inner2 (AREC1F : AREC1PT) is\n    --          begin\n-   --            inner(5, AREC1P);\n+   --            inner(5, AREC1F);\n    --          end;\n    --\n    --          x  : aliased integer := 77;\n@@ -231,13 +231,13 @@ package Exp_Unst is\n    --          rv : aliased Integer;\n    --          AREC1.rv := rv'Address;\n    --\n-   --          procedure inner (bb : integer; AREC1P : AREC1PT) is\n+   --          procedure inner (bb : integer; AREC1F : AREC1PT) is\n    --          begin\n    --             type Tnn1 is access all Integer;\n    --             type Tnn2 is access all Integer;\n    --             type Tnn3 is access all Integer;\n-   --             Tnn1!(AREC1P.x).all :=\n-   --               Tnn2!(AREC1P.rv).all + y + b + Tnn3!(AREC1P.b).all;\n+   --             Tnn1!(AREC1F.x).all :=\n+   --               Tnn2!(AREC1F.rv).all + y + b + Tnn3!(AREC1F.b).all;\n    --          end;\n    --\n    --       begin\n@@ -386,10 +386,10 @@ package Exp_Unst is\n    --          end record;\n    --          darecv : darec;\n    --\n-   --          function inner (b : integer; AREC1P : AREC1PT) return boolean is\n+   --          function inner (b : integer; AREC1F : AREC1PT) return boolean is\n    --          begin\n    --             type Tnn is access all Integer\n-   --             return b in x .. Tnn!(AREC1P.dynam_LAST).all\n+   --             return b in x .. Tnn!(AREC1F.dynam_LAST).all\n    --               and then darecv.b in 42 .. 73;\n    --          end inner;\n    --\n@@ -414,9 +414,9 @@ package Exp_Unst is\n    --  approach described above for case 2, except that we need an activation\n    --  record at each nested level. Basically the rule is that any procedure\n    --  that has nested procedures needs an activation record. When we do this,\n-   --  the inner activation records have a pointer to the immediately enclosing\n-   --  activation record, the normal arrangement of static links. The following\n-   --  shows the full translation of this fourth case.\n+   --  the inner activation records have a pointer (uplink) to the immediately\n+   --  enclosing activation record, the normal arrangement of static links. The\n+   --  following shows the full translation of this fourth case.\n \n    --     function case4x (x : integer) return integer is\n    --        type AREC1T is record\n@@ -430,33 +430,33 @@ package Exp_Unst is\n    --        v1 : integer := x;\n    --        AREC1.v1 := v1'Address;\n    --\n-   --        function inner1 (y : integer; AREC1P : ARECPT) return integer is\n+   --        function inner1 (y : integer; AREC1F : AREC1PT) return integer is\n    --           type AREC2T is record\n-   --              AREC1 : AREC1PT := AREC1P;\n-   --              v2    : Address;\n+   --              AREC1U : AREC1PT := AREC1F;\n+   --              v2     : Address;\n    --           end record;\n    --\n    --           AREC2 : aliased AREC2T;\n    --           type AREC2PT is access all AREC2T;\n    --           AREC2P : constant AREC2PT := AREC2'Access;\n    --\n    --           type Tnn1 is access all Integer;\n-   --           v2 : integer := Tnn1!(AREC1P.v1).all {+} 1;\n+   --           v2 : integer := Tnn1!(AREC1F.v1).all {+} 1;\n    --           AREC2.v2 := v2'Address;\n    --\n    --           function inner2\n-   --              (z : integer; AREC2P : AREC2PT) return integer\n+   --              (z : integer; AREC2F : AREC2PT) return integer\n    --           is\n    --           begin\n    --              type Tnn1 is access all Integer;\n    --              type Tnn2 is access all Integer;\n    --              return integer(z {+}\n-   --                             Tnn1!(AREC2P.AREC1.v1).all {+}\n-   --                             Tnn2!(AREC2P.v2).all);\n+   --                             Tnn1!(AREC2F.AREC1U.v1).all {+}\n+   --                             Tnn2!(AREC2F.v2).all);\n    --           end inner2;\n    --        begin\n    --           type Tnn is access all Integer;\n-   --           return integer(y {+} inner2 (Tnn!(AREC1P.v1).all, AREC2P));\n+   --           return integer(y {+} inner2 (Tnn!(AREC1F.v1).all, AREC2P));\n    --        end inner1;\n    --     begin\n    --        return inner1 (x, AREC1P);"}, {"sha": "ab9ee00dc68a301353a841d73f852ed36bbb9a93", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3830827c54e72b96400c9f9803b5518e8fb9f23d/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3830827c54e72b96400c9f9803b5518e8fb9f23d/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=3830827c54e72b96400c9f9803b5518e8fb9f23d", "patch": "@@ -4026,6 +4026,15 @@ package body Sem_Ch8 is\n          if not In_Open_Scopes (Pack) then\n             null;  --  default as well\n \n+         --  If the use clause appears in an ancestor and we are in the\n+         --  private part of the immediate parent, the use clauses are\n+         --  already installed.\n+\n+         elsif Pack /= Scope (Current_Scope)\n+           and then In_Private_Part (Scope (Current_Scope))\n+         then\n+            null;\n+\n          else\n             --  Find entry for parent unit in scope stack\n "}]}