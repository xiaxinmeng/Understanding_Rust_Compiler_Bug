{"sha": "bc99c54de5a262ffc5f7801e16d919d335a53a8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM5OWM1NGRlNWEyNjJmZmM1Zjc4MDFlMTZkOTE5ZDMzNWE1M2E4Yg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-01-25T22:02:57Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-04-29T18:41:45Z"}, "message": "c++: Use empty field in constexpr eval.\n\nIn discussion of PR98463, Jakub noted that cxx_fold_indirect_ref_1 was\nbailing out early for empty bases even when we do have fields for them (in\nC++17 mode or later).  This corrects that.\n\ngcc/cp/ChangeLog:\n\n\t* constexpr.c (cxx_fold_indirect_ref_1): Only set *empty_base if we\n\tdon't find a field.", "tree": {"sha": "2feef056d55d6a95faa2e9ee5437e03e64448f3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2feef056d55d6a95faa2e9ee5437e03e64448f3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc99c54de5a262ffc5f7801e16d919d335a53a8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc99c54de5a262ffc5f7801e16d919d335a53a8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc99c54de5a262ffc5f7801e16d919d335a53a8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc99c54de5a262ffc5f7801e16d919d335a53a8b/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0fdff3cf33f72848d3f894272431a5d49fe6a16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0fdff3cf33f72848d3f894272431a5d49fe6a16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0fdff3cf33f72848d3f894272431a5d49fe6a16"}], "stats": {"total": 36, "additions": 17, "deletions": 19}, "files": [{"sha": "9481a5bfd3c21cbd2690b2938a32abb8c58474d9", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc99c54de5a262ffc5f7801e16d919d335a53a8b/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc99c54de5a262ffc5f7801e16d919d335a53a8b/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=bc99c54de5a262ffc5f7801e16d919d335a53a8b", "patch": "@@ -4734,28 +4734,17 @@ cxx_fold_indirect_ref_1 (const constexpr_ctx *ctx, location_t loc, tree type,\n {\n   tree optype = TREE_TYPE (op);\n   unsigned HOST_WIDE_INT const_nunits;\n-  if (off == 0)\n+  if (off == 0 && similar_type_p (optype, type))\n+    return op;\n+  else if (TREE_CODE (optype) == COMPLEX_TYPE\n+\t   && similar_type_p (type, TREE_TYPE (optype)))\n     {\n-      if (similar_type_p (optype, type))\n-\treturn op;\n-      /* Also handle conversion to an empty base class, which\n-\t is represented with a NOP_EXPR.  */\n       /* *(foo *)&complexfoo => __real__ complexfoo */\n-      else if (TREE_CODE (optype) == COMPLEX_TYPE\n-\t       && similar_type_p (type, TREE_TYPE (optype)))\n+      if (off == 0)\n \treturn build1_loc (loc, REALPART_EXPR, type, op);\n-    }\n-  /* ((foo*)&complexfoo)[1] => __imag__ complexfoo */\n-  else if (TREE_CODE (optype) == COMPLEX_TYPE\n-\t   && similar_type_p (type, TREE_TYPE (optype))\n-\t   && tree_to_uhwi (TYPE_SIZE_UNIT (type)) == off)\n-    return build1_loc (loc, IMAGPART_EXPR, type, op);\n-  if (is_empty_class (type)\n-      && CLASS_TYPE_P (optype)\n-      && DERIVED_FROM_P (type, optype))\n-    {\n-      *empty_base = true;\n-      return op;\n+      /* ((foo*)&complexfoo)[1] => __imag__ complexfoo */\n+      else if (tree_to_uhwi (TYPE_SIZE_UNIT (type)) == off)\n+\treturn build1_loc (loc, IMAGPART_EXPR, type, op);\n     }\n   /* ((foo*)&vectorfoo)[x] => BIT_FIELD_REF<vectorfoo,...> */\n   else if (VECTOR_TYPE_P (optype)\n@@ -4834,6 +4823,15 @@ cxx_fold_indirect_ref_1 (const constexpr_ctx *ctx, location_t loc, tree type,\n \t\t  return ret;\n \t      }\n \t  }\n+      /* Also handle conversion to an empty base class, which\n+\t is represented with a NOP_EXPR.  */\n+      if (is_empty_class (type)\n+\t  && CLASS_TYPE_P (optype)\n+\t  && DERIVED_FROM_P (type, optype))\n+\t{\n+\t  *empty_base = true;\n+\t  return op;\n+\t}\n     }\n \n   return NULL_TREE;"}]}