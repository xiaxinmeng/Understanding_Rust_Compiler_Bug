{"sha": "cc7220fd0e78ebe5c963157b1272729540b62c9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2M3MjIwZmQwZTc4ZWJlNWM5NjMxNTdiMTI3MjcyOTU0MGI2MmM5YQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2005-04-25T17:24:28Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2005-04-25T17:24:28Z"}, "message": "tree-cfg.c (tree_duplicate_bb): Duplicate EH region too.\n\n\n\n\t* tree-cfg.c (tree_duplicate_bb): Duplicate EH region too.\n\n\t* except.c: Include diagnostic.h\n\t(dump_eh_tree, verify_eh_tree): New functions.\n\t* except.h (verify_eh_tree, dump_eh_tree, verify_eh_edges): Declare.\n\t* tree-cfg.c (tree_verify_flow_info): verify eh edges.\n\t(dump_function_to_file): dump eh tree.\n\t* tree-eh.c (mark_eh_edge): New function.\n\t(mark_eh_edge_found_error): New static variable.\n\t(verify_eh_edges): New function.\n\nFrom-SVN: r98724", "tree": {"sha": "3e4dfc8934383c983170f17940177f54350abc6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e4dfc8934383c983170f17940177f54350abc6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc7220fd0e78ebe5c963157b1272729540b62c9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc7220fd0e78ebe5c963157b1272729540b62c9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc7220fd0e78ebe5c963157b1272729540b62c9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc7220fd0e78ebe5c963157b1272729540b62c9a/comments", "author": null, "committer": null, "parents": [{"sha": "2845f02a6f36e198848fc90a266dd75c9842bcc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2845f02a6f36e198848fc90a266dd75c9842bcc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2845f02a6f36e198848fc90a266dd75c9842bcc0"}], "stats": {"total": 250, "additions": 250, "deletions": 0}, "files": [{"sha": "461598964d0f95a2690ca584af2a7a83c3182681", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc7220fd0e78ebe5c963157b1272729540b62c9a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc7220fd0e78ebe5c963157b1272729540b62c9a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc7220fd0e78ebe5c963157b1272729540b62c9a", "patch": "@@ -1,3 +1,16 @@\n+2005-04-25  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-cfg.c (tree_duplicate_bb): Duplicate EH region too.\n+\n+\t* except.c: Include diagnostic.h\n+\t(dump_eh_tree, verify_eh_tree): New functions.\n+\t* except.h (verify_eh_tree, dump_eh_tree, verify_eh_edges): Declare.\n+\t* tree-cfg.c (tree_verify_flow_info): verify eh edges.\n+\t(dump_function_to_file): dump eh tree.\n+\t* tree-eh.c (mark_eh_edge): New function.\n+\t(mark_eh_edge_found_error): New static variable.\n+\t(verify_eh_edges): New function.\n+\n 2005-04-25  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* tree-ssa-alias.c (fieldoff_t): Remove."}, {"sha": "2b5ec64757865769421f096265605f227d312296", "filename": "gcc/except.c", "status": "modified", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc7220fd0e78ebe5c963157b1272729540b62c9a/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc7220fd0e78ebe5c963157b1272729540b62c9a/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=cc7220fd0e78ebe5c963157b1272729540b62c9a", "patch": "@@ -74,6 +74,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"target.h\"\n #include \"langhooks.h\"\n #include \"cgraph.h\"\n+#include \"diagnostic.h\"\n \n /* Provide defaults for stuff that may not be defined when using\n    sjlj exceptions.  */\n@@ -3435,4 +3436,136 @@ output_function_exception_table (void)\n   current_function_section (current_function_decl);\n }\n \n+/* Dump EH information to OUT.  */\n+void \n+dump_eh_tree (FILE *out, struct function *fun)\n+{\n+  struct eh_region *i;\n+  int depth = 0;\n+  static const char * const type_name[] = {\"unknown\", \"cleanup\", \"try\", \"catch\",\n+\t\t\t\t\t   \"allowed_exceptions\", \"must_not_throw\",\n+\t\t\t\t\t   \"throw\", \"fixup\"};\n+\n+  i = fun->eh->region_tree;\n+  if (! i)\n+    return;\n+\n+  fprintf (out, \"Eh tree:\\n\");\n+  while (1)\n+    {\n+      fprintf (out, \"  %*s %i %s\", depth * 2, \"\",\n+\t       i->region_number, type_name [(int)i->type]);\n+      if (i->tree_label)\n+\t{\n+          fprintf (out, \" tree_label:\");\n+\t  print_generic_expr (out, i->tree_label, 0);\n+\t}\n+      fprintf (out, \"\\n\");\n+      /* If there are sub-regions, process them.  */\n+      if (i->inner)\n+\ti = i->inner, depth++;\n+      /* If there are peers, process them.  */\n+      else if (i->next_peer)\n+\ti = i->next_peer;\n+      /* Otherwise, step back up the tree to the next peer.  */\n+      else\n+\t{\n+\t  do {\n+\t    i = i->outer;\n+\t    depth--;\n+\t    if (i == NULL)\n+\t      return;\n+\t  } while (i->next_peer == NULL);\n+\t  i = i->next_peer;\n+\t}\n+    }\n+}\n+\n+/* Verify some basic invariants on EH datastructures.  Could be extended to\n+   catch more.  */\n+void \n+verify_eh_tree (struct function *fun)\n+{\n+  struct eh_region *i, *outer = NULL;\n+  bool err = false;\n+  int nvisited = 0;\n+  int count = 0;\n+  int j;\n+  int depth = 0;\n+\n+  i = fun->eh->region_tree;\n+  if (! i)\n+    return;\n+  for (j = fun->eh->last_region_number; j > 0; --j)\n+    if (fun->eh->region_array[j])\n+      {\n+\tcount++;\n+\tif (fun->eh->region_array[j]->region_number != j)\n+\t  {\n+\t    error (\"region_array is corrupted for region %i\", i->region_number);\n+\t    err = true;\n+\t  }\n+      }\n+\n+  while (1)\n+    {\n+      if (fun->eh->region_array[i->region_number] != i)\n+\t{\n+\t  error (\"region_array is corrupted for region %i\", i->region_number);\n+\t  err = true;\n+\t}\n+      if (i->outer != outer)\n+\t{\n+\t  error (\"outer block of region %i is wrong\", i->region_number);\n+\t  err = true;\n+\t}\n+      if (i->may_contain_throw && outer && !outer->may_contain_throw)\n+\t{\n+\t  error (\"region %i may contain throw and is contained in region that may not\",\n+\t\t i->region_number);\n+\t  err = true;\n+\t}\n+      if (depth < 0)\n+\t{\n+\t  error (\"negative nesting depth of region %i\", i->region_number);\n+\t  err = true;\n+\t}\n+      nvisited ++;\n+      /* If there are sub-regions, process them.  */\n+      if (i->inner)\n+\touter = i, i = i->inner, depth++;\n+      /* If there are peers, process them.  */\n+      else if (i->next_peer)\n+\ti = i->next_peer;\n+      /* Otherwise, step back up the tree to the next peer.  */\n+      else\n+\t{\n+\t  do {\n+\t    i = i->outer;\n+\t    depth--;\n+\t    if (i == NULL)\n+\t      {\n+\t\tif (depth != -1)\n+\t\t  {\n+\t\t    error (\"Tree list ends on depth %i\", depth + 1);\n+\t\t    err = true;\n+\t\t  }\n+\t\tif (count != nvisited)\n+\t\t  {\n+\t\t    error (\"array does not match the region tree\");\n+\t\t    err = true;\n+\t\t  }\n+\t\tif (err)\n+\t\t  {\n+\t\t    dump_eh_tree (stderr, fun);\n+\t\t    internal_error (\"verify_eh_tree failed.\");\n+\t\t  }\n+\t        return;\n+\t      }\n+\t    outer = i->outer;\n+\t  } while (i->next_peer == NULL);\n+\t  i = i->next_peer;\n+\t}\n+    }\n+}\n #include \"gt-except.h\""}, {"sha": "06fb78d558882c24bb850013ace9929578654aa5", "filename": "gcc/except.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc7220fd0e78ebe5c963157b1272729540b62c9a/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc7220fd0e78ebe5c963157b1272729540b62c9a/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=cc7220fd0e78ebe5c963157b1272729540b62c9a", "patch": "@@ -101,9 +101,12 @@ extern void foreach_reachable_handler (int, bool,\n \n extern void collect_eh_region_array (void);\n extern void expand_resx_expr (tree);\n+extern void verify_eh_tree (struct function *);\n+extern void dump_eh_tree (FILE *, struct function *);\n \n /* tree-eh.c */\n extern int lookup_stmt_eh_region (tree);\n+extern bool verify_eh_edges (tree);\n \n /* If non-NULL, this is a function that returns an expression to be\n    executed if an unhandled exception is propagated out of a cleanup"}, {"sha": "a9098cdc465b2731e43e9e28c9fbd64546a73645", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc7220fd0e78ebe5c963157b1272729540b62c9a/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc7220fd0e78ebe5c963157b1272729540b62c9a/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=cc7220fd0e78ebe5c963157b1272729540b62c9a", "patch": "@@ -554,6 +554,8 @@ make_exit_edges (basic_block bb)\n   gcc_assert (last);\n   switch (TREE_CODE (last))\n     {\n+    case RESX_EXPR:\n+      break;\n     case CALL_EXPR:\n       /* If this function receives a nonlocal goto, then we need to\n \t make edges from this call site to all the nonlocal goto\n@@ -3761,6 +3763,8 @@ tree_verify_flow_info (void)\n \n       stmt = bsi_stmt (bsi);\n \n+      err |= verify_eh_edges (stmt);\n+\n       if (is_ctrl_stmt (stmt))\n \t{\n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n@@ -4729,6 +4733,7 @@ tree_duplicate_bb (basic_block bb)\n       def_operand_p def_p;\n       ssa_op_iter op_iter;\n       tree stmt, copy;\n+      int region;\n \n       stmt = bsi_stmt (bsi);\n       if (TREE_CODE (stmt) == LABEL_EXPR)\n@@ -4739,6 +4744,9 @@ tree_duplicate_bb (basic_block bb)\n       copy = unshare_expr (stmt);\n       bsi_insert_after (&bsi_tgt, copy, BSI_NEW_STMT);\n       copy_virtual_operands (copy, stmt);\n+      region = lookup_stmt_eh_region (stmt);\n+      if (region >= 0)\n+\tadd_stmt_to_eh_region (copy, region);\n \n       /* Create new names for all the definitions created by COPY and\n \t add replacement mappings for each new name.  */\n@@ -4947,6 +4955,8 @@ dump_function_to_file (tree fn, FILE *file, int flags)\n     }\n   fprintf (file, \")\\n\");\n \n+  if (flags & TDF_DETAILS)\n+    dump_eh_tree (file, DECL_STRUCT_FUNCTION (fn));\n   if (flags & TDF_RAW)\n     {\n       dump_node (fn, TDF_SLIM | flags, file);"}, {"sha": "e21b5c51a5b026a2f75fe6515c0eca6233ddab1d", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc7220fd0e78ebe5c963157b1272729540b62c9a/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc7220fd0e78ebe5c963157b1272729540b62c9a/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=cc7220fd0e78ebe5c963157b1272729540b62c9a", "patch": "@@ -1746,6 +1746,97 @@ make_eh_edges (tree stmt)\n   foreach_reachable_handler (region_nr, is_resx, make_eh_edge, stmt);\n }\n \n+static bool mark_eh_edge_found_error;\n+\n+/* Mark edge make_eh_edge would create for given region by setting it aux\n+   field, output error if something goes wrong.  */\n+static void\n+mark_eh_edge (struct eh_region *region, void *data)\n+{\n+  tree stmt, lab;\n+  basic_block src, dst;\n+  edge e;\n+\n+  stmt = data;\n+  lab = get_eh_region_tree_label (region);\n+\n+  src = bb_for_stmt (stmt);\n+  dst = label_to_block (lab);\n+\n+  e = find_edge (src, dst);\n+  if (!e)\n+    {\n+      error (\"EH edge %i->%i is missing %i %i.\", src->index, dst->index, src, dst);\n+      mark_eh_edge_found_error = true;\n+    }\n+  else if (!(e->flags & EDGE_EH))\n+    {\n+      error (\"EH edge %i->%i miss EH flag.\", src->index, dst->index);\n+      mark_eh_edge_found_error = true;\n+    }\n+  else if (e->aux)\n+    {\n+      /* ??? might not be mistake.  */\n+      error (\"EH edge %i->%i has duplicated regions.\", src->index, dst->index);\n+      mark_eh_edge_found_error = true;\n+    }\n+  else\n+    e->aux = (void *)1;\n+}\n+\n+/* Verify that BB containing stmt as last stmt has precisely the edges\n+   make_eh_edges would create.  */\n+bool\n+verify_eh_edges (tree stmt)\n+{\n+  int region_nr;\n+  bool is_resx;\n+  basic_block bb = bb_for_stmt (stmt);\n+  edge_iterator ei;\n+  edge e;\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    gcc_assert (!e->aux);\n+  mark_eh_edge_found_error = false;\n+  if (TREE_CODE (stmt) == RESX_EXPR)\n+    {\n+      region_nr = TREE_INT_CST_LOW (TREE_OPERAND (stmt, 0));\n+      is_resx = true;\n+    }\n+  else\n+    {\n+      region_nr = lookup_stmt_eh_region (stmt);\n+      if (region_nr < 0)\n+\t{\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n+\t    if (e->flags & EDGE_EH)\n+\t      {\n+\t\terror (\"BB %i can not throw but has EH edges\", bb->index);\n+\t\treturn true;\n+\t      }\n+\t   return false;\n+\t}\n+      if (!tree_could_throw_p (stmt))\n+\t{\n+\t  error (\"BB %i last statement has incorrectly set region\", bb->index);\n+\t  return true;\n+\t}\n+      is_resx = false;\n+    }\n+\n+  foreach_reachable_handler (region_nr, is_resx, mark_eh_edge, stmt);\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    {\n+      if ((e->flags & EDGE_EH) && !e->aux)\n+\t{\n+\t  error (\"Unnecesary EH edge %i->%i\", bb->index, e->dest->index);\n+\t  mark_eh_edge_found_error = true;\n+\t  return true;\n+\t}\n+      e->aux = NULL;\n+    }\n+  return mark_eh_edge_found_error;\n+}\n \n \f\n /* Return true if the expr can trap, as in dereferencing an invalid pointer"}]}