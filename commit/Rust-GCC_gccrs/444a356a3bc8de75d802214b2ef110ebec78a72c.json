{"sha": "444a356a3bc8de75d802214b2ef110ebec78a72c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQ0YTM1NmEzYmM4ZGU3NWQ4MDIyMTRiMmVmMTEwZWJlYzc4YTcyYw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2007-11-02T20:38:11Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2007-11-02T20:38:11Z"}, "message": "ia64.c (struct reg_write_state): Change into unsigned short bitfields rather than unsigned int...\n\n\t* config/ia64/ia64.c (struct reg_write_state): Change into\n\tunsigned short bitfields rather than unsigned int, decrease\n\tfirst_pred to just 10 bits.\n\t(rws_insn): Change into a bitmap or if not ENABLE_CHECKING\n\tinto two char array.\n\t(rws_insn_set, rws_insn_test): New functions.\n\t(in_safe_group_barrier): New variable.\n\t(rws_update): Remove first argument, always set rws_sum array.\n\t(rws_access_regno): Use rws_insn_set macro.  Only call rws_update\n\tor update rws_sum if !in_safe_group_barrier, adjust rws_update\n\targs.\n\t(rtx_needs_barrier): Use rws_insn_test macro.\n\t(safe_group_barrier_needed): Don't save/restore rws_sum array,\n\tinstead set/clear in_safe_group_barrier flag.\n\nFrom-SVN: r129861", "tree": {"sha": "9cb08fa7ebf021f07a343dbee0dd920495b48f32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9cb08fa7ebf021f07a343dbee0dd920495b48f32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/444a356a3bc8de75d802214b2ef110ebec78a72c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/444a356a3bc8de75d802214b2ef110ebec78a72c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/444a356a3bc8de75d802214b2ef110ebec78a72c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/444a356a3bc8de75d802214b2ef110ebec78a72c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7c4b32bcdc8455d77f73eb56e8fec9ca74fe6be2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c4b32bcdc8455d77f73eb56e8fec9ca74fe6be2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c4b32bcdc8455d77f73eb56e8fec9ca74fe6be2"}], "stats": {"total": 122, "additions": 91, "deletions": 31}, "files": [{"sha": "6a6f682cbfb8ba27574bea2e2d0eb5fb30ca2c14", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/444a356a3bc8de75d802214b2ef110ebec78a72c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/444a356a3bc8de75d802214b2ef110ebec78a72c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=444a356a3bc8de75d802214b2ef110ebec78a72c", "patch": "@@ -1,3 +1,20 @@\n+2007-11-02  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* config/ia64/ia64.c (struct reg_write_state): Change into\n+\tunsigned short bitfields rather than unsigned int, decrease\n+\tfirst_pred to just 10 bits.\n+\t(rws_insn): Change into a bitmap or if not ENABLE_CHECKING\n+\tinto two char array.\n+\t(rws_insn_set, rws_insn_test): New functions.\n+\t(in_safe_group_barrier): New variable.\n+\t(rws_update): Remove first argument, always set rws_sum array.\n+\t(rws_access_regno): Use rws_insn_set macro.  Only call rws_update\n+\tor update rws_sum if !in_safe_group_barrier, adjust rws_update\n+\targs.\n+\t(rtx_needs_barrier): Use rws_insn_test macro.\n+\t(safe_group_barrier_needed): Don't save/restore rws_sum array,\n+\tinstead set/clear in_safe_group_barrier flag.\n+\n 2007-11-02  Bob Wilson  <bob.wilson@acm.org>\n \n \t* config/xtensa/xtensa.c (xtensa_expand_prologue): Put a"}, {"sha": "a75e68eb1f97a148a277f6f562259726100263c8", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 74, "deletions": 31, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/444a356a3bc8de75d802214b2ef110ebec78a72c/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/444a356a3bc8de75d802214b2ef110ebec78a72c/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=444a356a3bc8de75d802214b2ef110ebec78a72c", "patch": "@@ -5308,20 +5308,62 @@ ia64_safe_type (rtx insn)\n    If a predicate register is written by an AND.ORCM we set WRITTEN_BY_AND\n    to true; if it was written by an OR.ANDCM we set WRITTEN_BY_OR to true.  */\n \n+#if GCC_VERSION >= 4000\n+#define RWS_FIELD_TYPE __extension__ unsigned short\n+#else\n+#define RWS_FIELD_TYPE unsigned int\n+#endif\n struct reg_write_state\n {\n-  unsigned int write_count : 2;\n-  unsigned int first_pred : 16;\n-  unsigned int written_by_fp : 1;\n-  unsigned int written_by_and : 1;\n-  unsigned int written_by_or : 1;\n+  RWS_FIELD_TYPE write_count : 2;\n+  RWS_FIELD_TYPE first_pred : 10;\n+  RWS_FIELD_TYPE written_by_fp : 1;\n+  RWS_FIELD_TYPE written_by_and : 1;\n+  RWS_FIELD_TYPE written_by_or : 1;\n };\n \n /* Cumulative info for the current instruction group.  */\n struct reg_write_state rws_sum[NUM_REGS];\n-/* Info for the current instruction.  This gets copied to rws_sum after a\n-   stop bit is emitted.  */\n-struct reg_write_state rws_insn[NUM_REGS];\n+#ifdef ENABLE_CHECKING\n+/* Bitmap whether a register has been written in the current insn.  */\n+HARD_REG_ELT_TYPE rws_insn[(NUM_REGS + HOST_BITS_PER_WIDEST_FAST_INT - 1)\n+\t\t\t   / HOST_BITS_PER_WIDEST_FAST_INT];\n+\n+static inline void\n+rws_insn_set (int regno)\n+{\n+  gcc_assert (!TEST_HARD_REG_BIT (rws_insn, regno));\n+  SET_HARD_REG_BIT (rws_insn, regno);\n+}\n+\n+static inline int\n+rws_insn_test (int regno)\n+{\n+  return TEST_HARD_REG_BIT (rws_insn, regno);\n+}\n+#else\n+/* When not checking, track just REG_AR_CFM and REG_VOLATILE.  */\n+unsigned char rws_insn[2];\n+\n+static inline void\n+rws_insn_set (int regno)\n+{\n+  if (regno == REG_AR_CFM)\n+    rws_insn[0] = 1;\n+  else if (regno == REG_VOLATILE)\n+    rws_insn[1] = 1;\n+}\n+\n+static inline int\n+rws_insn_test (int regno)\n+{\n+  if (regno == REG_AR_CFM)\n+    return rws_insn[0];\n+  if (regno == REG_VOLATILE)\n+    return rws_insn[1];\n+  return 0;\n+}\n+#endif\n \n /* Indicates whether this is the first instruction after a stop bit,\n    in which case we don't need another stop bit.  Without this,\n@@ -5340,7 +5382,7 @@ struct reg_flags\n   unsigned int is_sibcall : 1;\t/* Is this a sibling or normal call?  */\n };\n \n-static void rws_update (struct reg_write_state *, int, struct reg_flags, int);\n+static void rws_update (int, struct reg_flags, int);\n static int rws_access_regno (int, struct reg_flags, int);\n static int rws_access_reg (rtx, struct reg_flags, int);\n static void update_set_flags (rtx, struct reg_flags *);\n@@ -5349,26 +5391,27 @@ static int rtx_needs_barrier (rtx, struct reg_flags, int);\n static void init_insn_group_barriers (void);\n static int group_barrier_needed (rtx);\n static int safe_group_barrier_needed (rtx);\n+static int in_safe_group_barrier;\n \n /* Update *RWS for REGNO, which is being written by the current instruction,\n    with predicate PRED, and associated register flags in FLAGS.  */\n \n static void\n-rws_update (struct reg_write_state *rws, int regno, struct reg_flags flags, int pred)\n+rws_update (int regno, struct reg_flags flags, int pred)\n {\n   if (pred)\n-    rws[regno].write_count++;\n+    rws_sum[regno].write_count++;\n   else\n-    rws[regno].write_count = 2;\n-  rws[regno].written_by_fp |= flags.is_fp;\n+    rws_sum[regno].write_count = 2;\n+  rws_sum[regno].written_by_fp |= flags.is_fp;\n   /* ??? Not tracking and/or across differing predicates.  */\n-  rws[regno].written_by_and = flags.is_and;\n-  rws[regno].written_by_or = flags.is_or;\n-  rws[regno].first_pred = pred;\n+  rws_sum[regno].written_by_and = flags.is_and;\n+  rws_sum[regno].written_by_or = flags.is_or;\n+  rws_sum[regno].first_pred = pred;\n }\n \n /* Handle an access to register REGNO of type FLAGS using predicate register\n-   PRED.  Update rws_insn and rws_sum arrays.  Return 1 if this access creates\n+   PRED.  Update rws_sum array.  Return 1 if this access creates\n    a dependency with an earlier instruction in the same group.  */\n \n static int\n@@ -5385,18 +5428,15 @@ rws_access_regno (int regno, struct reg_flags flags, int pred)\n     {\n       int write_count;\n \n-      /* One insn writes same reg multiple times?  */\n-      gcc_assert (!rws_insn[regno].write_count);\n-\n-      /* Update info for current instruction.  */\n-      rws_update (rws_insn, regno, flags, pred);\n+      rws_insn_set (regno);\n       write_count = rws_sum[regno].write_count;\n \n       switch (write_count)\n \t{\n \tcase 0:\n \t  /* The register has not been written yet.  */\n-\t  rws_update (rws_sum, regno, flags, pred);\n+\t  if (!in_safe_group_barrier)\n+\t    rws_update (regno, flags, pred);\n \t  break;\n \n \tcase 1:\n@@ -5410,7 +5450,8 @@ rws_access_regno (int regno, struct reg_flags flags, int pred)\n \t    ;\n \t  else if ((rws_sum[regno].first_pred ^ 1) != pred)\n \t    need_barrier = 1;\n-\t  rws_update (rws_sum, regno, flags, pred);\n+\t  if (!in_safe_group_barrier)\n+\t    rws_update (regno, flags, pred);\n \t  break;\n \n \tcase 2:\n@@ -5422,8 +5463,11 @@ rws_access_regno (int regno, struct reg_flags flags, int pred)\n \t    ;\n \t  else\n \t    need_barrier = 1;\n-\t  rws_sum[regno].written_by_and = flags.is_and;\n-\t  rws_sum[regno].written_by_or = flags.is_or;\n+\t  if (!in_safe_group_barrier)\n+\t    {\n+\t      rws_sum[regno].written_by_and = flags.is_and;\n+\t      rws_sum[regno].written_by_or = flags.is_or;\n+\t    }\n \t  break;\n \n \tdefault:\n@@ -5635,7 +5679,7 @@ rtx_needs_barrier (rtx x, struct reg_flags flags, int pred)\n \n       /* Avoid multiple register writes, in case this is a pattern with\n \t multiple CALL rtx.  This avoids a failure in rws_access_reg.  */\n-      if (! flags.is_sibcall && ! rws_insn[REG_AR_CFM].write_count)\n+      if (! flags.is_sibcall && ! rws_insn_test (REG_AR_CFM))\n \t{\n \t  new_flags.is_write = 1;\n \t  need_barrier |= rws_access_regno (REG_RP, new_flags, pred);\n@@ -5677,7 +5721,7 @@ rtx_needs_barrier (rtx x, struct reg_flags flags, int pred)\n \t{\n \t  /* Avoid writing the register multiple times if we have multiple\n \t     asm outputs.  This avoids a failure in rws_access_reg.  */\n-\t  if (! rws_insn[REG_VOLATILE].write_count)\n+\t  if (! rws_insn_test (REG_VOLATILE))\n \t    {\n \t      new_flags.is_write = 1;\n \t      rws_access_regno (REG_VOLATILE, new_flags, pred);\n@@ -6071,17 +6115,16 @@ group_barrier_needed (rtx insn)\n static int\n safe_group_barrier_needed (rtx insn)\n {\n-  struct reg_write_state rws_saved[NUM_REGS];\n   int saved_first_instruction;\n   int t;\n \n-  memcpy (rws_saved, rws_sum, NUM_REGS * sizeof *rws_saved);\n   saved_first_instruction = first_instruction;\n+  in_safe_group_barrier = 1;\n \n   t = group_barrier_needed (insn);\n \n-  memcpy (rws_sum, rws_saved, NUM_REGS * sizeof *rws_saved);\n   first_instruction = saved_first_instruction;\n+  in_safe_group_barrier = 0;\n \n   return t;\n }"}]}