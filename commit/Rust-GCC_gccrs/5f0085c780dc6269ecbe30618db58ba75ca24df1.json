{"sha": "5f0085c780dc6269ecbe30618db58ba75ca24df1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWYwMDg1Yzc4MGRjNjI2OWVjYmUzMDYxOGRiNThiYTc1Y2EyNGRmMQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2008-08-22T12:11:31Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-08-22T12:11:31Z"}, "message": "init.c (__gnat_adjust_context_for_raise): Delete for AIX, HP-UX, Solaris, FreeBSD, VxWorks and PowerPC/Linux.\n\n2008-08-22  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* init.c (__gnat_adjust_context_for_raise): Delete for AIX, HP-UX,\n\tSolaris, FreeBSD, VxWorks and PowerPC/Linux.  For x86{-64}/Linux,\n\tdo not adjust the PC anymore.\n\t(__gnat_error_handler): Do not call __gnat_adjust_context_for_raise\n\ton AIX, HP-UX, Solaris, FreeBSD and VxWorks.\n\n\t* raise-gcc.c (get_call_site_action_for): Use _Unwind_GetIPInfo\n\tinstead of _Unwind_GetIP.\n\nFrom-SVN: r139441", "tree": {"sha": "fbd9f674bab0ef77174a0ce48ac4abf522f4f729", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbd9f674bab0ef77174a0ce48ac4abf522f4f729"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f0085c780dc6269ecbe30618db58ba75ca24df1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f0085c780dc6269ecbe30618db58ba75ca24df1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f0085c780dc6269ecbe30618db58ba75ca24df1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f0085c780dc6269ecbe30618db58ba75ca24df1/comments", "author": null, "committer": null, "parents": [{"sha": "f934798c1c97999b8c6ac33469ebd06b60a6a7a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f934798c1c97999b8c6ac33469ebd06b60a6a7a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f934798c1c97999b8c6ac33469ebd06b60a6a7a5"}], "stats": {"total": 175, "additions": 37, "deletions": 138}, "files": [{"sha": "fcf3af7dc4f635a649da0fa7f3e5887b28b79cf7", "filename": "gcc/ada/init.c", "status": "modified", "additions": 13, "deletions": 126, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0085c780dc6269ecbe30618db58ba75ca24df1/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0085c780dc6269ecbe30618db58ba75ca24df1/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=5f0085c780dc6269ecbe30618db58ba75ca24df1", "patch": "@@ -217,22 +217,6 @@ nanosleep (struct timestruc_t *Rqtp, struct timestruc_t *Rmtp)\n \n static void __gnat_error_handler (int sig, siginfo_t * si, void * uc);\n \n-/* __gnat_adjust_context_for_raise - see comments along with the default\n-   version later in this file.  */\n-\n-void\n-__gnat_adjust_context_for_raise (int signo ATTRIBUTE_UNUSED, void *ucontext)\n-{\n-  /* We need to adjust the \"Instruction Address Register\" value, part of a\n-     'struct mstsave' wrapped as a jumpbuf in the mcontext field designated by\n-     the signal data pointer we get.  See sys/context.h + sys/mstsave.h  */\n-\n-  mcontext_t *mcontext = &((ucontext_t *) ucontext)->uc_mcontext;\n-  mcontext->jmp_context.iar++;\n-}\n-\n-#define HAVE_GNAT_ADJUST_CONTEXT_FOR_RAISE\n-\n static void\n __gnat_error_handler (int sig, siginfo_t * si, void * uc)\n {\n@@ -262,7 +246,6 @@ __gnat_error_handler (int sig, siginfo_t * si, void * uc)\n       msg = \"unhandled signal\";\n     }\n \n-  __gnat_adjust_context_for_raise (sig, uc);\n   Raise_From_Signal_Handler (exception, msg);\n }\n \n@@ -464,26 +447,6 @@ __gnat_machine_state_length (void)\n static void\n __gnat_error_handler (int sig, siginfo_t *siginfo, void *ucontext);\n \n-#if defined (__hppa__)\n-\n-/* __gnat_adjust_context_for_raise - see comments along with the default\n-   version later in this file.  */\n-\n-#define HAVE_GNAT_ADJUST_CONTEXT_FOR_RAISE\n-\n-void\n-__gnat_adjust_context_for_raise (int signo ATTRIBUTE_UNUSED, void *ucontext)\n-{\n-  mcontext_t *mcontext = &((ucontext_t *) ucontext)->uc_mcontext;\n-\n-  if (UseWideRegs (mcontext))\n-    mcontext->ss_wide.ss_32.ss_pcoq_head_lo ++;\n-  else\n-    mcontext->ss_narrow.ss_pcoq_head ++;\n-}\n-\n-#endif\n-\n static void\n __gnat_error_handler\n   (int sig, siginfo_t *siginfo ATTRIBUTE_UNUSED, void *ucontext)\n@@ -514,8 +477,6 @@ __gnat_error_handler\n       msg = \"unhandled signal\";\n     }\n \n-  __gnat_adjust_context_for_raise (sig, ucontext);\n-\n   Raise_From_Signal_Handler (exception, msg);\n }\n \n@@ -617,17 +578,14 @@ void fake_linux_sigemptyset (sigset_t *set) {\n \n static void __gnat_error_handler (int, siginfo_t *siginfo, void *ucontext);\n \n-/* __gnat_adjust_context_for_raise - see comments along with the default\n-   version later in this file.  */\n+#if defined (i386) || defined (__x86_64__) || defined (__ia64__)\n \n #define HAVE_GNAT_ADJUST_CONTEXT_FOR_RAISE\n \n void\n __gnat_adjust_context_for_raise (int signo ATTRIBUTE_UNUSED, void *ucontext)\n {\n-#ifndef __powerpc__\n   mcontext_t *mcontext = &((ucontext_t *) ucontext)->uc_mcontext;\n-#endif\n \n   /* On the i386 and x86-64 architectures, stack checking is performed by\n      means of probes with moving stack pointer, that is to say the probed\n@@ -651,20 +609,19 @@ __gnat_adjust_context_for_raise (int signo ATTRIBUTE_UNUSED, void *ucontext)\n   /* The pattern is \"orl $0x0,(%esp)\" for a probe in 32-bit mode.  */\n   if (signo == SIGSEGV && pattern == 0x00240c83)\n     mcontext->gregs[REG_ESP] += 4096;\n-  mcontext->gregs[REG_EIP]++;\n #elif defined (__x86_64__)\n   unsigned long pattern = *(unsigned long *)mcontext->gregs[REG_RIP];\n   /* The pattern is \"orq $0x0,(%rsp)\" for a probe in 64-bit mode.  */\n   if (signo == SIGSEGV && (pattern & 0xffffffffff) == 0x00240c8348)\n     mcontext->gregs[REG_RSP] += 4096;\n-  mcontext->gregs[REG_RIP]++;\n #elif defined (__ia64__)\n+  /* ??? The IA-64 unwinder doesn't compensate for signals.  */\n   mcontext->sc_ip++;\n-#elif defined (__powerpc__)\n-  ((ucontext_t *) ucontext)->uc_mcontext.regs->nip++;\n #endif\n }\n \n+#endif\n+\n static void\n __gnat_error_handler (int sig,\n                       siginfo_t *siginfo ATTRIBUTE_UNUSED,\n@@ -731,11 +688,10 @@ __gnat_error_handler (int sig,\n     }\n   recurse = 0;\n \n-  /* We adjust the interrupted context here (and not in the\n-     MD_FALLBACK_FRAME_STATE_FOR macro) because recent versions of the Native\n-     POSIX Thread Library (NPTL) are compiled with DWARF-2 unwind information,\n-     and hence the later macro is never executed for signal frames.  */\n-\n+  /* We adjust the interrupted context here (and not in the fallback\n+     unwinding routine) because recent versions of the Native POSIX\n+     Thread Library (NPTL) are compiled with unwind information, so\n+     the fallback routine is never executed for signal frames.  */\n   __gnat_adjust_context_for_raise (sig, ucontext);\n \n   Raise_From_Signal_Handler (exception, msg);\n@@ -1052,30 +1008,13 @@ __gnat_install_handler(void)\n \n static void __gnat_error_handler (int, siginfo_t *, ucontext_t *);\n \n-/* __gnat_adjust_context_for_raise - see comments along with the default\n-   version later in this file.  */\n-\n-#define HAVE_GNAT_ADJUST_CONTEXT_FOR_RAISE\n-\n-void\n-__gnat_adjust_context_for_raise (int signo ATTRIBUTE_UNUSED,\n-\t\t\t\t void * ucontext)\n-{\n-  mcontext_t *mcontext = & ((ucontext_t *)ucontext)->uc_mcontext;\n-  mcontext->gregs[REG_PC] += (1 - RETURN_ADDR_OFFSET);\n-}\n-\n static void\n __gnat_error_handler (int sig, siginfo_t *sip, ucontext_t *uctx)\n {\n   struct Exception_Data *exception;\n   static int recurse = 0;\n   const char *msg;\n \n-  /* Adjusting is required for every fault context, so adjust for this one\n-     now, before we possibly trigger a recursive fault below.  */\n-  __gnat_adjust_context_for_raise (sig, (void *)uctx);\n-\n   /* If this was an explicit signal from a \"kill\", just resignal it.  */\n   if (SI_FROMUSER (sip))\n     {\n@@ -1691,19 +1630,6 @@ __gnat_adjust_context_for_raise (int signo ATTRIBUTE_UNUSED, void *ucontext)\n #include <unistd.h>\n \n static void __gnat_error_handler (int, siginfo_t *, ucontext_t *);\n-void __gnat_adjust_context_for_raise (int, void*);\n-\n-/* __gnat_adjust_context_for_raise - see comments along with the default\n-   version later in this file.  */\n-\n-#define HAVE_GNAT_ADJUST_CONTEXT_FOR_RAISE\n-\n-void\n-__gnat_adjust_context_for_raise (int signo ATTRIBUTE_UNUSED, void *ucontext)\n-{\n-  mcontext_t *mcontext = &((ucontext_t *) ucontext)->uc_mcontext;\n-  mcontext->mc_eip++;\n-}\n \n static void\n __gnat_error_handler (int sig, siginfo_t *info __attribute__ ((unused)),\n@@ -1739,7 +1665,6 @@ __gnat_error_handler (int sig, siginfo_t *info __attribute__ ((unused)),\n       msg = \"unhandled signal\";\n     }\n \n-  __gnat_adjust_context_for_raise (sig, ucontext);\n   Raise_From_Signal_Handler (exception, msg);\n }\n \n@@ -1825,34 +1750,6 @@ __gnat_clear_exception_count (void)\n #endif\n }\n \n-\n-/* VxWorks context adjustment for targets that need/support it.  */\n-\n-void __gnat_adjust_context_for_raise (int, void*);\n-\n-#if defined (_ARCH_PPC) && !defined (VTHREADS) && !defined (__RTP__)\n-\n-#define HAVE_GNAT_ADJUST_CONTEXT_FOR_RAISE\n-\n-/* We need the constant and structure definitions describing the machine\n-   state.  Part of this is normally retrieved from the VxWorks \"regs.h\" but\n-   #including it here gets the GCC internals instance of this file instead.\n-   We need to #include the version we need directly here, and prevent the\n-   possibly indirect inclusion of the GCC one, as its contents is useless to\n-   us and it depends on several other headers that we don't have at hand.  */\n-#include <arch/ppc/regsPpc.h>\n-#define GCC_REGS_H\n-#include <sigLib.h>\n-\n-void\n-__gnat_adjust_context_for_raise (int signo ATTRIBUTE_UNUSED, void *sigcontext)\n-{\n-  REG_SET * mcontext = ((struct sigcontext *) sigcontext)->sc_pregs;\n-  mcontext->pc++;\n-}\n-\n-#endif\n-\n /* Handle different SIGnal to exception mappings in different VxWorks\n    versions.   */\n static void\n@@ -1935,7 +1832,6 @@ __gnat_error_handler (int sig, void * si ATTRIBUTE_UNUSED,\n   sigdelset (&mask, sig);\n   sigprocmask (SIG_SETMASK, &mask, NULL);\n \n-  __gnat_adjust_context_for_raise (sig, (void *)sc);\n   __gnat_map_signal (sig);\n }\n \n@@ -2206,12 +2102,11 @@ void\n __gnat_adjust_context_for_raise (int signo ATTRIBUTE_UNUSED,\n \t\t\t\t void *ucontext ATTRIBUTE_UNUSED)\n {\n-  /* Adjustments are currently required for the GCC ZCX propagation scheme\n-     only.  These adjustments (described below) are harmless for the other\n-     schemes, so may be applied unconditionally.  */\n+  /* We used to compensate here for the raised from call vs raised from signal\n+     exception discrepancy with the GCC ZCX scheme, but this is now dealt with\n+     generically (except for Alpha and IA-64), see PR other/26208.\n \n-  /* Adjustments required for a GCC ZCX propagation scheme:\n-     ------------------------------------------------------\n+     *** Call vs signal exception discrepancy with GCC ZCX scheme ***\n \n      The GCC unwinder expects to be dealing with call return addresses, since\n      this is the \"nominal\" case of what we retrieve while unwinding a regular\n@@ -2239,15 +2134,7 @@ __gnat_adjust_context_for_raise (int signo ATTRIBUTE_UNUSED,\n \n      signo is passed because on some targets for some signals the PC in\n      context points to the instruction after the faulting one, in which case\n-     the unwinder adjustment is still desired.\n-\n-     We used to perform the compensation in the GCC unwinding fallback macro.\n-     The thread at http://gcc.gnu.org/ml/gcc-patches/2004-05/msg00343.html\n-     describes a couple of issues with this approach.  First, on some targets\n-     the adjustment to apply depends on the triggering signal, which is not\n-     easily accessible from the macro.  Besides, other languages, e.g. Java,\n-     deal with this by performing the adjustment in the signal handler before\n-     the raise, so fallback adjustments just break those front-ends.  */\n+     the unwinder adjustment is still desired.  */\n }\n \n #endif"}, {"sha": "8b3433b3a89fe991d0e953a4e8d30c4d700d7057", "filename": "gcc/ada/raise-gcc.c", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f0085c780dc6269ecbe30618db58ba75ca24df1/gcc%2Fada%2Fraise-gcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f0085c780dc6269ecbe30618db58ba75ca24df1/gcc%2Fada%2Fraise-gcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise-gcc.c?ref=5f0085c780dc6269ecbe30618db58ba75ca24df1", "patch": "@@ -671,6 +671,14 @@ db_action_for (action_descriptor *action, _Unwind_Context *uw_context)\n    There are two variants of this routine, depending on the underlying\n    mechanism (DWARF/SJLJ), which account for differences in the tables.  */\n \n+#ifdef __APPLE__\n+/* On MacOS X, versions older than 10.5 don't export _Unwind_GetIPInfo.  */\n+#undef HAVE_GETIPINFO\n+#if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1050\n+#define HAVE_GETIPINFO 1\n+#endif\n+#endif\n+\n #ifdef __USING_SJLJ_EXCEPTIONS__\n \n #define __builtin_eh_return_data_regno(x) x\n@@ -680,8 +688,14 @@ get_call_site_action_for (_Unwind_Context *uw_context,\n                           region_descriptor *region,\n                           action_descriptor *action)\n {\n-  /* Subtract 1 because GetIP returns the actual call_site value + 1.  */\n-  _Unwind_Ptr call_site = _Unwind_GetIP (uw_context) - 1;\n+  int ip_before_insn = 0;\n+#ifdef HAVE_GETIPINFO\n+  _Unwind_Ptr call_site = _Unwind_GetIPInfo (uw_context, &ip_before_insn);\n+#else\n+  _Unwind_Ptr call_site = _Unwind_GetIP (uw_context);\n+#endif\n+  if (!ip_before_insn)\n+    call_site--;\n \n   /* call_site is a direct index into the call-site table, with two special\n      values : -1 for no-action and 0 for \"terminate\".  The latter should never\n@@ -737,17 +751,15 @@ get_call_site_action_for (_Unwind_Context *uw_context,\n                           region_descriptor *region,\n                           action_descriptor *action)\n {\n-  /* Subtract 1 because GetIP yields a call return address while we are\n-     interested in information for the call point.  This does not always\n-     yield the exact call instruction address but always brings the IP back\n-     within the corresponding region.\n-\n-     ??? When unwinding up from a signal handler triggered by a trap on some\n-     instruction, we usually have the faulting instruction address here and\n-     subtracting 1 might get us into the wrong region.  */\n-  _Unwind_Ptr ip = _Unwind_GetIP (uw_context) - 1;\n-\n   const unsigned char *p = region->call_site_table;\n+  int ip_before_insn = 0;\n+#ifdef HAVE_GETIPINFO\n+  _Unwind_Ptr ip = _Unwind_GetIPInfo (uw_context, &ip_before_insn);\n+#else\n+  _Unwind_Ptr ip = _Unwind_GetIP (uw_context);\n+#endif\n+  if (!ip_before_insn)\n+    ip--;\n \n   /* Unless we are able to determine otherwise...  */\n   action->kind = nothing;"}]}