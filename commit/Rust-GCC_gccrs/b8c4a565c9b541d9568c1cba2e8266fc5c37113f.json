{"sha": "b8c4a565c9b541d9568c1cba2e8266fc5c37113f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhjNGE1NjVjOWI1NDFkOTU2OGMxY2JhMmU4MjY2ZmM1YzM3MTEzZg==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2005-03-16T09:01:20Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2005-03-16T09:01:20Z"}, "message": "tree-inline.c (walk_type_fields, [...]): Move from here...\n\n        * tree-inline.c (walk_type_fields, walk_tree,\n        walk_tree_without_duplicates): Move from here...\n        * tree.c: ...to here.\n\nFrom-SVN: r96550", "tree": {"sha": "7d0846344b21a0fe0edc3c81ec37ab803a4731fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d0846344b21a0fe0edc3c81ec37ab803a4731fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8c4a565c9b541d9568c1cba2e8266fc5c37113f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8c4a565c9b541d9568c1cba2e8266fc5c37113f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8c4a565c9b541d9568c1cba2e8266fc5c37113f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8c4a565c9b541d9568c1cba2e8266fc5c37113f/comments", "author": null, "committer": null, "parents": [{"sha": "a1286ef574be4a388b14de74a406dc60391a8b91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1286ef574be4a388b14de74a406dc60391a8b91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1286ef574be4a388b14de74a406dc60391a8b91"}], "stats": {"total": 709, "additions": 358, "deletions": 351}, "files": [{"sha": "b84cbb568b5824cc6e14ef735adcdfee587027d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8c4a565c9b541d9568c1cba2e8266fc5c37113f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8c4a565c9b541d9568c1cba2e8266fc5c37113f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b8c4a565c9b541d9568c1cba2e8266fc5c37113f", "patch": "@@ -1,3 +1,9 @@\n+2005-03-16  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* tree-inline.c (walk_type_fields, walk_tree,\n+\twalk_tree_without_duplicates): Move from here...\n+\t* tree.c: ...to here.\n+\n 2005-03-15  Zack Weinberg  <zack@codesourcery.com>\n \n \t* BASE-VER, DATESTAMP, DEV-PHASE: New files."}, {"sha": "c20c0744c70831492d781d2a6c2d2f7d7d52291e", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 0, "deletions": 351, "changes": 351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8c4a565c9b541d9568c1cba2e8266fc5c37113f/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8c4a565c9b541d9568c1cba2e8266fc5c37113f/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=b8c4a565c9b541d9568c1cba2e8266fc5c37113f", "patch": "@@ -35,7 +35,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"integrate.h\"\n #include \"varray.h\"\n #include \"hashtab.h\"\n-#include \"pointer-set.h\"\n #include \"splay-tree.h\"\n #include \"langhooks.h\"\n #include \"cgraph.h\"\n@@ -1921,356 +1920,6 @@ save_body (tree fn, tree *arg_copy, tree *sc_copy)\n   return body;\n }\n \n-#define WALK_SUBTREE(NODE)\t\t\t\t\\\n-  do\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      result = walk_tree (&(NODE), func, data, pset);\t\\\n-      if (result)\t\t\t\t\t\\\n-\treturn result;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* This is a subroutine of walk_tree that walks field of TYPE that are to\n-   be walked whenever a type is seen in the tree.  Rest of operands and return\n-   value are as for walk_tree.  */\n-\n-static tree\n-walk_type_fields (tree type, walk_tree_fn func, void *data,\n-\t\t  struct pointer_set_t *pset)\n-{\n-  tree result = NULL_TREE;\n-\n-  switch (TREE_CODE (type))\n-    {\n-    case POINTER_TYPE:\n-    case REFERENCE_TYPE:\n-      /* We have to worry about mutually recursive pointers.  These can't\n-\t be written in C.  They can in Ada.  It's pathological, but\n-\t there's an ACATS test (c38102a) that checks it.  Deal with this\n-\t by checking if we're pointing to another pointer, that one\n-\t points to another pointer, that one does too, and we have no htab.\n-\t If so, get a hash table.  We check three levels deep to avoid\n-\t the cost of the hash table if we don't need one.  */\n-      if (POINTER_TYPE_P (TREE_TYPE (type))\n-\t  && POINTER_TYPE_P (TREE_TYPE (TREE_TYPE (type)))\n-\t  && POINTER_TYPE_P (TREE_TYPE (TREE_TYPE (TREE_TYPE (type))))\n-\t  && !pset)\n-\t{\n-\t  result = walk_tree_without_duplicates (&TREE_TYPE (type),\n-\t\t\t\t\t\t func, data);\n-\t  if (result)\n-\t    return result;\n-\n-\t  break;\n-\t}\n-\n-      /* ... fall through ... */\n-\n-    case COMPLEX_TYPE:\n-      WALK_SUBTREE (TREE_TYPE (type));\n-      break;\n-\n-    case METHOD_TYPE:\n-      WALK_SUBTREE (TYPE_METHOD_BASETYPE (type));\n-\n-      /* Fall through.  */\n-\n-    case FUNCTION_TYPE:\n-      WALK_SUBTREE (TREE_TYPE (type));\n-      {\n-\ttree arg;\n-\n-\t/* We never want to walk into default arguments.  */\n-\tfor (arg = TYPE_ARG_TYPES (type); arg; arg = TREE_CHAIN (arg))\n-\t  WALK_SUBTREE (TREE_VALUE (arg));\n-      }\n-      break;\n-\n-    case ARRAY_TYPE:\n-      /* Don't follow this nodes's type if a pointer for fear that we'll\n-\t have infinite recursion.  Those types are uninteresting anyway.  */\n-      if (!POINTER_TYPE_P (TREE_TYPE (type))\n-\t  && TREE_CODE (TREE_TYPE (type)) != OFFSET_TYPE)\n-\tWALK_SUBTREE (TREE_TYPE (type));\n-      WALK_SUBTREE (TYPE_DOMAIN (type));\n-      break;\n-\n-    case BOOLEAN_TYPE:\n-    case ENUMERAL_TYPE:\n-    case INTEGER_TYPE:\n-    case CHAR_TYPE:\n-    case REAL_TYPE:\n-      WALK_SUBTREE (TYPE_MIN_VALUE (type));\n-      WALK_SUBTREE (TYPE_MAX_VALUE (type));\n-      break;\n-\n-    case OFFSET_TYPE:\n-      WALK_SUBTREE (TREE_TYPE (type));\n-      WALK_SUBTREE (TYPE_OFFSET_BASETYPE (type));\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Apply FUNC to all the sub-trees of TP in a pre-order traversal.  FUNC is\n-   called with the DATA and the address of each sub-tree.  If FUNC returns a\n-   non-NULL value, the traversal is aborted, and the value returned by FUNC\n-   is returned.  If PSET is non-NULL it is used to record the nodes visited,\n-   and to avoid visiting a node more than once.  */\n-\n-tree\n-walk_tree (tree *tp, walk_tree_fn func, void *data, struct pointer_set_t *pset)\n-{\n-  enum tree_code code;\n-  int walk_subtrees;\n-  tree result;\n-\n-#define WALK_SUBTREE_TAIL(NODE)\t\t\t\t\\\n-  do\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-       tp = & (NODE);\t\t\t\t\t\\\n-       goto tail_recurse;\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  while (0)\n-\n- tail_recurse:\n-  /* Skip empty subtrees.  */\n-  if (!*tp)\n-    return NULL_TREE;\n-\n-  /* Don't walk the same tree twice, if the user has requested\n-     that we avoid doing so.  */\n-  if (pset && pointer_set_insert (pset, *tp))\n-    return NULL_TREE;\n-\n-  /* Call the function.  */\n-  walk_subtrees = 1;\n-  result = (*func) (tp, &walk_subtrees, data);\n-\n-  /* If we found something, return it.  */\n-  if (result)\n-    return result;\n-\n-  code = TREE_CODE (*tp);\n-\n-  /* Even if we didn't, FUNC may have decided that there was nothing\n-     interesting below this point in the tree.  */\n-  if (!walk_subtrees)\n-    {\n-      if (code == TREE_LIST)\n-\t/* But we still need to check our siblings.  */\n-\tWALK_SUBTREE_TAIL (TREE_CHAIN (*tp));\n-      else\n-\treturn NULL_TREE;\n-    }\n-\n-  result = lang_hooks.tree_inlining.walk_subtrees (tp, &walk_subtrees, func,\n-\t\t\t\t\t\t   data, pset);\n-  if (result || ! walk_subtrees)\n-    return result;\n-\n-  /* If this is a DECL_EXPR, walk into various fields of the type that it's\n-     defining.  We only want to walk into these fields of a type in this\n-     case.  Note that decls get walked as part of the processing of a\n-     BIND_EXPR.\n-\n-     ??? Precisely which fields of types that we are supposed to walk in\n-     this case vs. the normal case aren't well defined.  */\n-  if (code == DECL_EXPR\n-      && TREE_CODE (DECL_EXPR_DECL (*tp)) == TYPE_DECL\n-      && TREE_CODE (TREE_TYPE (DECL_EXPR_DECL (*tp))) != ERROR_MARK)\n-    {\n-      tree *type_p = &TREE_TYPE (DECL_EXPR_DECL (*tp));\n-\n-      /* Call the function for the type.  See if it returns anything or\n-\t doesn't want us to continue.  If we are to continue, walk both\n-\t the normal fields and those for the declaration case.  */\n-      result = (*func) (type_p, &walk_subtrees, data);\n-      if (result || !walk_subtrees)\n-\treturn NULL_TREE;\n-\n-      result = walk_type_fields (*type_p, func, data, pset);\n-      if (result)\n-\treturn result;\n-\n-      WALK_SUBTREE (TYPE_SIZE (*type_p));\n-      WALK_SUBTREE (TYPE_SIZE_UNIT (*type_p));\n-\n-      /* If this is a record type, also walk the fields.  */\n-      if (TREE_CODE (*type_p) == RECORD_TYPE\n-\t  || TREE_CODE (*type_p) == UNION_TYPE\n-\t  || TREE_CODE (*type_p) == QUAL_UNION_TYPE)\n-\t{\n-\t  tree field;\n-\n-\t  for (field = TYPE_FIELDS (*type_p); field;\n-\t       field = TREE_CHAIN (field))\n-\t    {\n-\t      /* We'd like to look at the type of the field, but we can easily\n-\t\t get infinite recursion.  So assume it's pointed to elsewhere\n-\t\t in the tree.  Also, ignore things that aren't fields.  */\n-\t      if (TREE_CODE (field) != FIELD_DECL)\n-\t\tcontinue;\n-\n-\t      WALK_SUBTREE (DECL_FIELD_OFFSET (field));\n-\t      WALK_SUBTREE (DECL_SIZE (field));\n-\t      WALK_SUBTREE (DECL_SIZE_UNIT (field));\n-\t      if (TREE_CODE (*type_p) == QUAL_UNION_TYPE)\n-\t\tWALK_SUBTREE (DECL_QUALIFIER (field));\n-\t    }\n-\t}\n-    }\n-\n-  else if (code != SAVE_EXPR\n-\t   && code != BIND_EXPR\n-\t   && IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code)))\n-    {\n-      int i, len;\n-\n-      /* Walk over all the sub-trees of this operand.  */\n-      len = TREE_CODE_LENGTH (code);\n-      /* TARGET_EXPRs are peculiar: operands 1 and 3 can be the same.\n-\t But, we only want to walk once.  */\n-      if (code == TARGET_EXPR\n-\t  && TREE_OPERAND (*tp, 3) == TREE_OPERAND (*tp, 1))\n-\t--len;\n-\n-      /* Go through the subtrees.  We need to do this in forward order so\n-         that the scope of a FOR_EXPR is handled properly.  */\n-#ifdef DEBUG_WALK_TREE\n-      for (i = 0; i < len; ++i)\n-\tWALK_SUBTREE (TREE_OPERAND (*tp, i));\n-#else\n-      for (i = 0; i < len - 1; ++i)\n-\tWALK_SUBTREE (TREE_OPERAND (*tp, i));\n-\n-      if (len)\n-\t{\n-\t  /* The common case is that we may tail recurse here.  */\n-\t  if (code != BIND_EXPR\n-\t      && !TREE_CHAIN (*tp))\n-\t    WALK_SUBTREE_TAIL (TREE_OPERAND (*tp, len - 1));\n-\t  else\n-\t    WALK_SUBTREE (TREE_OPERAND (*tp, len - 1));\n-\t}\n-#endif\n-    }\n-\n-  /* If this is a type, walk the needed fields in the type.  */\n-  else if (TYPE_P (*tp))\n-    {\n-      result = walk_type_fields (*tp, func, data, pset);\n-      if (result)\n-\treturn result;\n-    }\n-  else\n-    {\n-      /* Not one of the easy cases.  We must explicitly go through the\n-\t children.  */\n-      switch (code)\n-\t{\n-\tcase ERROR_MARK:\n-\tcase IDENTIFIER_NODE:\n-\tcase INTEGER_CST:\n-\tcase REAL_CST:\n-\tcase VECTOR_CST:\n-\tcase STRING_CST:\n-\tcase BLOCK:\n-\tcase PLACEHOLDER_EXPR:\n-\tcase SSA_NAME:\n-\tcase FIELD_DECL:\n-\tcase RESULT_DECL:\n-\t  /* None of thse have subtrees other than those already walked\n-\t     above.  */\n-\t  break;\n-\n-\tcase TREE_LIST:\n-\t  WALK_SUBTREE (TREE_VALUE (*tp));\n-\t  WALK_SUBTREE_TAIL (TREE_CHAIN (*tp));\n-\t  break;\n-\n-\tcase TREE_VEC:\n-\t  {\n-\t    int len = TREE_VEC_LENGTH (*tp);\n-\n-\t    if (len == 0)\n-\t      break;\n-\n-\t    /* Walk all elements but the first.  */\n-\t    while (--len)\n-\t      WALK_SUBTREE (TREE_VEC_ELT (*tp, len));\n-\n-\t    /* Now walk the first one as a tail call.  */\n-\t    WALK_SUBTREE_TAIL (TREE_VEC_ELT (*tp, 0));\n-\t  }\n-\n-\tcase COMPLEX_CST:\n-\t  WALK_SUBTREE (TREE_REALPART (*tp));\n-\t  WALK_SUBTREE_TAIL (TREE_IMAGPART (*tp));\n-\n-\tcase CONSTRUCTOR:\n-\t  WALK_SUBTREE_TAIL (CONSTRUCTOR_ELTS (*tp));\n-\n-\tcase SAVE_EXPR:\n-\t  WALK_SUBTREE_TAIL (TREE_OPERAND (*tp, 0));\n-\n-\tcase BIND_EXPR:\n-\t  {\n-\t    tree decl;\n-\t    for (decl = BIND_EXPR_VARS (*tp); decl; decl = TREE_CHAIN (decl))\n-\t      {\n-\t\t/* Walk the DECL_INITIAL and DECL_SIZE.  We don't want to walk\n-\t\t   into declarations that are just mentioned, rather than\n-\t\t   declared; they don't really belong to this part of the tree.\n-\t\t   And, we can see cycles: the initializer for a declaration\n-\t\t   can refer to the declaration itself.  */\n-\t\tWALK_SUBTREE (DECL_INITIAL (decl));\n-\t\tWALK_SUBTREE (DECL_SIZE (decl));\n-\t\tWALK_SUBTREE (DECL_SIZE_UNIT (decl));\n-\t      }\n-\t    WALK_SUBTREE_TAIL (BIND_EXPR_BODY (*tp));\n-\t  }\n-\n-\tcase STATEMENT_LIST:\n-\t  {\n-\t    tree_stmt_iterator i;\n-\t    for (i = tsi_start (*tp); !tsi_end_p (i); tsi_next (&i))\n-\t      WALK_SUBTREE (*tsi_stmt_ptr (i));\n-\t  }\n-\t  break;\n-\n-\tdefault:\n-\t  /* ??? This could be a language-defined node.  We really should make\n-\t     a hook for it, but right now just ignore it.  */\n-\t  break;\n-\t}\n-    }\n-\n-  /* We didn't find what we were looking for.  */\n-  return NULL_TREE;\n-\n-#undef WALK_SUBTREE\n-#undef WALK_SUBTREE_TAIL\n-}\n-\n-/* Like walk_tree, but does not walk duplicate nodes more than once.  */\n-\n-tree\n-walk_tree_without_duplicates (tree *tp, walk_tree_fn func, void *data)\n-{\n-  tree result;\n-  struct pointer_set_t *pset;\n-\n-  pset = pointer_set_create ();\n-  result = walk_tree (tp, func, data, pset);\n-  pointer_set_destroy (pset);\n-  return result;\n-}\n-\n /* Passed to walk_tree.  Copies the node pointed to, if appropriate.  */\n \n tree"}, {"sha": "1500349ded1c081f440194f67f126364ef224135", "filename": "gcc/tree.c", "status": "modified", "additions": 352, "deletions": 0, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8c4a565c9b541d9568c1cba2e8266fc5c37113f/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8c4a565c9b541d9568c1cba2e8266fc5c37113f/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=b8c4a565c9b541d9568c1cba2e8266fc5c37113f", "patch": "@@ -49,6 +49,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"basic-block.h\"\n #include \"tree-flow.h\"\n #include \"params.h\"\n+#include \"pointer-set.h\"\n \n /* Each tree code class has an associated string representation.\n    These must correspond to the tree_code_class entries.  */\n@@ -6406,4 +6407,355 @@ num_ending_zeros (tree x)\n   return build_int_cst_type (type, num);\n }\n \n+\n+#define WALK_SUBTREE(NODE)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      result = walk_tree (&(NODE), func, data, pset);\t\\\n+      if (result)\t\t\t\t\t\\\n+\treturn result;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* This is a subroutine of walk_tree that walks field of TYPE that are to\n+   be walked whenever a type is seen in the tree.  Rest of operands and return\n+   value are as for walk_tree.  */\n+\n+static tree\n+walk_type_fields (tree type, walk_tree_fn func, void *data,\n+\t\t  struct pointer_set_t *pset)\n+{\n+  tree result = NULL_TREE;\n+\n+  switch (TREE_CODE (type))\n+    {\n+    case POINTER_TYPE:\n+    case REFERENCE_TYPE:\n+      /* We have to worry about mutually recursive pointers.  These can't\n+\t be written in C.  They can in Ada.  It's pathological, but\n+\t there's an ACATS test (c38102a) that checks it.  Deal with this\n+\t by checking if we're pointing to another pointer, that one\n+\t points to another pointer, that one does too, and we have no htab.\n+\t If so, get a hash table.  We check three levels deep to avoid\n+\t the cost of the hash table if we don't need one.  */\n+      if (POINTER_TYPE_P (TREE_TYPE (type))\n+\t  && POINTER_TYPE_P (TREE_TYPE (TREE_TYPE (type)))\n+\t  && POINTER_TYPE_P (TREE_TYPE (TREE_TYPE (TREE_TYPE (type))))\n+\t  && !pset)\n+\t{\n+\t  result = walk_tree_without_duplicates (&TREE_TYPE (type),\n+\t\t\t\t\t\t func, data);\n+\t  if (result)\n+\t    return result;\n+\n+\t  break;\n+\t}\n+\n+      /* ... fall through ... */\n+\n+    case COMPLEX_TYPE:\n+      WALK_SUBTREE (TREE_TYPE (type));\n+      break;\n+\n+    case METHOD_TYPE:\n+      WALK_SUBTREE (TYPE_METHOD_BASETYPE (type));\n+\n+      /* Fall through.  */\n+\n+    case FUNCTION_TYPE:\n+      WALK_SUBTREE (TREE_TYPE (type));\n+      {\n+\ttree arg;\n+\n+\t/* We never want to walk into default arguments.  */\n+\tfor (arg = TYPE_ARG_TYPES (type); arg; arg = TREE_CHAIN (arg))\n+\t  WALK_SUBTREE (TREE_VALUE (arg));\n+      }\n+      break;\n+\n+    case ARRAY_TYPE:\n+      /* Don't follow this nodes's type if a pointer for fear that we'll\n+\t have infinite recursion.  Those types are uninteresting anyway.  */\n+      if (!POINTER_TYPE_P (TREE_TYPE (type))\n+\t  && TREE_CODE (TREE_TYPE (type)) != OFFSET_TYPE)\n+\tWALK_SUBTREE (TREE_TYPE (type));\n+      WALK_SUBTREE (TYPE_DOMAIN (type));\n+      break;\n+\n+    case BOOLEAN_TYPE:\n+    case ENUMERAL_TYPE:\n+    case INTEGER_TYPE:\n+    case CHAR_TYPE:\n+    case REAL_TYPE:\n+      WALK_SUBTREE (TYPE_MIN_VALUE (type));\n+      WALK_SUBTREE (TYPE_MAX_VALUE (type));\n+      break;\n+\n+    case OFFSET_TYPE:\n+      WALK_SUBTREE (TREE_TYPE (type));\n+      WALK_SUBTREE (TYPE_OFFSET_BASETYPE (type));\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Apply FUNC to all the sub-trees of TP in a pre-order traversal.  FUNC is\n+   called with the DATA and the address of each sub-tree.  If FUNC returns a\n+   non-NULL value, the traversal is aborted, and the value returned by FUNC\n+   is returned.  If PSET is non-NULL it is used to record the nodes visited,\n+   and to avoid visiting a node more than once.  */\n+\n+tree\n+walk_tree (tree *tp, walk_tree_fn func, void *data, struct pointer_set_t *pset)\n+{\n+  enum tree_code code;\n+  int walk_subtrees;\n+  tree result;\n+\n+#define WALK_SUBTREE_TAIL(NODE)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+       tp = & (NODE);\t\t\t\t\t\\\n+       goto tail_recurse;\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+ tail_recurse:\n+  /* Skip empty subtrees.  */\n+  if (!*tp)\n+    return NULL_TREE;\n+\n+  /* Don't walk the same tree twice, if the user has requested\n+     that we avoid doing so.  */\n+  if (pset && pointer_set_insert (pset, *tp))\n+    return NULL_TREE;\n+\n+  /* Call the function.  */\n+  walk_subtrees = 1;\n+  result = (*func) (tp, &walk_subtrees, data);\n+\n+  /* If we found something, return it.  */\n+  if (result)\n+    return result;\n+\n+  code = TREE_CODE (*tp);\n+\n+  /* Even if we didn't, FUNC may have decided that there was nothing\n+     interesting below this point in the tree.  */\n+  if (!walk_subtrees)\n+    {\n+      if (code == TREE_LIST)\n+\t/* But we still need to check our siblings.  */\n+\tWALK_SUBTREE_TAIL (TREE_CHAIN (*tp));\n+      else\n+\treturn NULL_TREE;\n+    }\n+\n+  result = lang_hooks.tree_inlining.walk_subtrees (tp, &walk_subtrees, func,\n+\t\t\t\t\t\t   data, pset);\n+  if (result || ! walk_subtrees)\n+    return result;\n+\n+  /* If this is a DECL_EXPR, walk into various fields of the type that it's\n+     defining.  We only want to walk into these fields of a type in this\n+     case.  Note that decls get walked as part of the processing of a\n+     BIND_EXPR.\n+\n+     ??? Precisely which fields of types that we are supposed to walk in\n+     this case vs. the normal case aren't well defined.  */\n+  if (code == DECL_EXPR\n+      && TREE_CODE (DECL_EXPR_DECL (*tp)) == TYPE_DECL\n+      && TREE_CODE (TREE_TYPE (DECL_EXPR_DECL (*tp))) != ERROR_MARK)\n+    {\n+      tree *type_p = &TREE_TYPE (DECL_EXPR_DECL (*tp));\n+\n+      /* Call the function for the type.  See if it returns anything or\n+\t doesn't want us to continue.  If we are to continue, walk both\n+\t the normal fields and those for the declaration case.  */\n+      result = (*func) (type_p, &walk_subtrees, data);\n+      if (result || !walk_subtrees)\n+\treturn NULL_TREE;\n+\n+      result = walk_type_fields (*type_p, func, data, pset);\n+      if (result)\n+\treturn result;\n+\n+      WALK_SUBTREE (TYPE_SIZE (*type_p));\n+      WALK_SUBTREE (TYPE_SIZE_UNIT (*type_p));\n+\n+      /* If this is a record type, also walk the fields.  */\n+      if (TREE_CODE (*type_p) == RECORD_TYPE\n+\t  || TREE_CODE (*type_p) == UNION_TYPE\n+\t  || TREE_CODE (*type_p) == QUAL_UNION_TYPE)\n+\t{\n+\t  tree field;\n+\n+\t  for (field = TYPE_FIELDS (*type_p); field;\n+\t       field = TREE_CHAIN (field))\n+\t    {\n+\t      /* We'd like to look at the type of the field, but we can easily\n+\t\t get infinite recursion.  So assume it's pointed to elsewhere\n+\t\t in the tree.  Also, ignore things that aren't fields.  */\n+\t      if (TREE_CODE (field) != FIELD_DECL)\n+\t\tcontinue;\n+\n+\t      WALK_SUBTREE (DECL_FIELD_OFFSET (field));\n+\t      WALK_SUBTREE (DECL_SIZE (field));\n+\t      WALK_SUBTREE (DECL_SIZE_UNIT (field));\n+\t      if (TREE_CODE (*type_p) == QUAL_UNION_TYPE)\n+\t\tWALK_SUBTREE (DECL_QUALIFIER (field));\n+\t    }\n+\t}\n+    }\n+\n+  else if (code != SAVE_EXPR\n+\t   && code != BIND_EXPR\n+\t   && IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code)))\n+    {\n+      int i, len;\n+\n+      /* Walk over all the sub-trees of this operand.  */\n+      len = TREE_CODE_LENGTH (code);\n+      /* TARGET_EXPRs are peculiar: operands 1 and 3 can be the same.\n+\t But, we only want to walk once.  */\n+      if (code == TARGET_EXPR\n+\t  && TREE_OPERAND (*tp, 3) == TREE_OPERAND (*tp, 1))\n+\t--len;\n+\n+      /* Go through the subtrees.  We need to do this in forward order so\n+         that the scope of a FOR_EXPR is handled properly.  */\n+#ifdef DEBUG_WALK_TREE\n+      for (i = 0; i < len; ++i)\n+\tWALK_SUBTREE (TREE_OPERAND (*tp, i));\n+#else\n+      for (i = 0; i < len - 1; ++i)\n+\tWALK_SUBTREE (TREE_OPERAND (*tp, i));\n+\n+      if (len)\n+\t{\n+\t  /* The common case is that we may tail recurse here.  */\n+\t  if (code != BIND_EXPR\n+\t      && !TREE_CHAIN (*tp))\n+\t    WALK_SUBTREE_TAIL (TREE_OPERAND (*tp, len - 1));\n+\t  else\n+\t    WALK_SUBTREE (TREE_OPERAND (*tp, len - 1));\n+\t}\n+#endif\n+    }\n+\n+  /* If this is a type, walk the needed fields in the type.  */\n+  else if (TYPE_P (*tp))\n+    {\n+      result = walk_type_fields (*tp, func, data, pset);\n+      if (result)\n+\treturn result;\n+    }\n+  else\n+    {\n+      /* Not one of the easy cases.  We must explicitly go through the\n+\t children.  */\n+      switch (code)\n+\t{\n+\tcase ERROR_MARK:\n+\tcase IDENTIFIER_NODE:\n+\tcase INTEGER_CST:\n+\tcase REAL_CST:\n+\tcase VECTOR_CST:\n+\tcase STRING_CST:\n+\tcase BLOCK:\n+\tcase PLACEHOLDER_EXPR:\n+\tcase SSA_NAME:\n+\tcase FIELD_DECL:\n+\tcase RESULT_DECL:\n+\t  /* None of thse have subtrees other than those already walked\n+\t     above.  */\n+\t  break;\n+\n+\tcase TREE_LIST:\n+\t  WALK_SUBTREE (TREE_VALUE (*tp));\n+\t  WALK_SUBTREE_TAIL (TREE_CHAIN (*tp));\n+\t  break;\n+\n+\tcase TREE_VEC:\n+\t  {\n+\t    int len = TREE_VEC_LENGTH (*tp);\n+\n+\t    if (len == 0)\n+\t      break;\n+\n+\t    /* Walk all elements but the first.  */\n+\t    while (--len)\n+\t      WALK_SUBTREE (TREE_VEC_ELT (*tp, len));\n+\n+\t    /* Now walk the first one as a tail call.  */\n+\t    WALK_SUBTREE_TAIL (TREE_VEC_ELT (*tp, 0));\n+\t  }\n+\n+\tcase COMPLEX_CST:\n+\t  WALK_SUBTREE (TREE_REALPART (*tp));\n+\t  WALK_SUBTREE_TAIL (TREE_IMAGPART (*tp));\n+\n+\tcase CONSTRUCTOR:\n+\t  WALK_SUBTREE_TAIL (CONSTRUCTOR_ELTS (*tp));\n+\n+\tcase SAVE_EXPR:\n+\t  WALK_SUBTREE_TAIL (TREE_OPERAND (*tp, 0));\n+\n+\tcase BIND_EXPR:\n+\t  {\n+\t    tree decl;\n+\t    for (decl = BIND_EXPR_VARS (*tp); decl; decl = TREE_CHAIN (decl))\n+\t      {\n+\t\t/* Walk the DECL_INITIAL and DECL_SIZE.  We don't want to walk\n+\t\t   into declarations that are just mentioned, rather than\n+\t\t   declared; they don't really belong to this part of the tree.\n+\t\t   And, we can see cycles: the initializer for a declaration\n+\t\t   can refer to the declaration itself.  */\n+\t\tWALK_SUBTREE (DECL_INITIAL (decl));\n+\t\tWALK_SUBTREE (DECL_SIZE (decl));\n+\t\tWALK_SUBTREE (DECL_SIZE_UNIT (decl));\n+\t      }\n+\t    WALK_SUBTREE_TAIL (BIND_EXPR_BODY (*tp));\n+\t  }\n+\n+\tcase STATEMENT_LIST:\n+\t  {\n+\t    tree_stmt_iterator i;\n+\t    for (i = tsi_start (*tp); !tsi_end_p (i); tsi_next (&i))\n+\t      WALK_SUBTREE (*tsi_stmt_ptr (i));\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  /* ??? This could be a language-defined node.  We really should make\n+\t     a hook for it, but right now just ignore it.  */\n+\t  break;\n+\t}\n+    }\n+\n+  /* We didn't find what we were looking for.  */\n+  return NULL_TREE;\n+\n+#undef WALK_SUBTREE_TAIL\n+}\n+#undef WALK_SUBTREE\n+\n+/* Like walk_tree, but does not walk duplicate nodes more than once.  */\n+\n+tree\n+walk_tree_without_duplicates (tree *tp, walk_tree_fn func, void *data)\n+{\n+  tree result;\n+  struct pointer_set_t *pset;\n+\n+  pset = pointer_set_create ();\n+  result = walk_tree (tp, func, data, pset);\n+  pointer_set_destroy (pset);\n+  return result;\n+}\n+\n #include \"gt-tree.h\""}]}