{"sha": "650a59ef78e60584d88905c266ddd4faf7ca4679", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjUwYTU5ZWY3OGU2MDU4NGQ4ODkwNWMyNjZkZGQ0ZmFmN2NhNDY3OQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@st.com", "date": "2006-09-05T21:41:23Z"}, "committer": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2006-09-05T21:41:23Z"}, "message": "re PR target/28764 (libjava build failure on sh4)\n\n\tPR target/28764\n\t* mode-switching.c (optimize_mode_switching): Make the destination\n\tblock of an abnormal edge have no anticipatable mode.  Don't\n\tinsert mode switching code at the end of the source block of\n\tan abnormal edge.\n\n\nCo-Authored-By: Kaz Kojima <kkojima@gcc.gnu.org>\n\nFrom-SVN: r116703", "tree": {"sha": "609974c074f0c5de52b68f305975f08af487b385", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/609974c074f0c5de52b68f305975f08af487b385"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/650a59ef78e60584d88905c266ddd4faf7ca4679", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/650a59ef78e60584d88905c266ddd4faf7ca4679", "html_url": "https://github.com/Rust-GCC/gccrs/commit/650a59ef78e60584d88905c266ddd4faf7ca4679", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/650a59ef78e60584d88905c266ddd4faf7ca4679/comments", "author": null, "committer": null, "parents": [{"sha": "ec1ee65573108066a357ff00027a5c3a6b9a6031", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec1ee65573108066a357ff00027a5c3a6b9a6031", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec1ee65573108066a357ff00027a5c3a6b9a6031"}], "stats": {"total": 52, "additions": 19, "deletions": 33}, "files": [{"sha": "06c987fc5a69899065471718669076872a723306", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/650a59ef78e60584d88905c266ddd4faf7ca4679/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/650a59ef78e60584d88905c266ddd4faf7ca4679/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=650a59ef78e60584d88905c266ddd4faf7ca4679", "patch": "@@ -1,3 +1,12 @@\n+2006-09-05  J\"orn Rennecke  <joern.rennecke@st.com>\n+\t    Kaz Kojima  <kkojima@gcc.gnu.org>\n+\n+\tPR target/28764\n+\t* mode-switching.c (optimize_mode_switching): Make the destination\n+\tblock of an abnormal edge have no anticipatable mode.  Don't\n+\tinsert mode switching code at the end of the source block of\n+\tan abnormal edge.\n+\n 2006-09-05  Paolo Bonzini  <bonzini@gnu.org>\n \n \tPR rtl-optimization/26847"}, {"sha": "407ae76a8c6b2f3ee843c08a1de1f30d9cf79429", "filename": "gcc/mode-switching.c", "status": "modified", "additions": 10, "deletions": 33, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/650a59ef78e60584d88905c266ddd4faf7ca4679/gcc%2Fmode-switching.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/650a59ef78e60584d88905c266ddd4faf7ca4679/gcc%2Fmode-switching.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-switching.c?ref=650a59ef78e60584d88905c266ddd4faf7ca4679", "patch": "@@ -465,7 +465,11 @@ optimize_mode_switching (void)\n \t      if (e->flags & EDGE_COMPLEX)\n \t\tbreak;\n \t    if (e)\n-\t      RESET_BIT (transp[bb->index], j);\n+\t      {\n+\t\tptr = new_seginfo (no_mode, BB_HEAD (bb), bb->index, live_now);\n+\t\tadd_seginfo (info + bb->index, ptr);\n+\t\tRESET_BIT (transp[bb->index], j);\n+\t      }\n \t  }\n \n \t  for (insn = BB_HEAD (bb);\n@@ -608,38 +612,11 @@ optimize_mode_switching (void)\n \t      if (mode_set == NULL_RTX)\n \t\tcontinue;\n \n-\t      /* If this is an abnormal edge, we'll insert at the end\n-\t\t of the previous block.  */\n-\t      if (eg->flags & EDGE_ABNORMAL)\n-\t\t{\n-\t\t  emited = true;\n-\t\t  if (JUMP_P (BB_END (src_bb)))\n-\t\t    emit_insn_before (mode_set, BB_END (src_bb));\n-\t\t  else\n-\t\t    {\n-\t\t      /* It doesn't make sense to switch to normal\n-\t\t         mode after a CALL_INSN.  The cases in which a\n-\t\t         CALL_INSN may have an abnormal edge are\n-\t\t         sibcalls and EH edges.  In the case of\n-\t\t         sibcalls, the dest basic-block is the\n-\t\t         EXIT_BLOCK, that runs in normal mode; it is\n-\t\t         assumed that a sibcall insn requires normal\n-\t\t         mode itself, so no mode switch would be\n-\t\t         required after the call (it wouldn't make\n-\t\t         sense, anyway).  In the case of EH edges, EH\n-\t\t         entry points also start in normal mode, so a\n-\t\t         similar reasoning applies.  */\n-\t\t      gcc_assert (NONJUMP_INSN_P (BB_END (src_bb)));\n-\t\t      emit_insn_after (mode_set, BB_END (src_bb));\n-\t\t    }\n-\t\t  bb_info[j][src_bb->index].computing = mode;\n-\t\t  RESET_BIT (transp[src_bb->index], j);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  need_commit = 1;\n-\t\t  insert_insn_on_edge (mode_set, eg);\n-\t\t}\n+\t      /* We should not get an abnormal edge here.  */\n+\t      gcc_assert (! (eg->flags & EDGE_ABNORMAL));\n+\n+\t      need_commit = 1;\n+\t      insert_insn_on_edge (mode_set, eg);\n \t    }\n \n \t  FOR_EACH_BB_REVERSE (bb)"}]}