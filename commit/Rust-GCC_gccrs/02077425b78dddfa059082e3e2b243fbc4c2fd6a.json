{"sha": "02077425b78dddfa059082e3e2b243fbc4c2fd6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDIwNzc0MjViNzhkZGRmYTA1OTA4MmUzZTJiMjQzZmJjNGMyZmQ2YQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-11-27T05:59:39Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-11-27T05:59:39Z"}, "message": "verify.cc (pop_init_ref): New method.\n\n\t* verify.cc (pop_init_ref): New method.\n\t(verify_instructions_0) [op_iaload, op_laload, op_faload,\n\top_daload, op_aaload, op_baload, op_caload, op_saload, op_iastore,\n\top_lastore, op_fastore, op_dastore, op_aastore, op_bastore,\n\top_castore, op_sastore, op_areturn, op_arraylength, op_checkcast,\n\top_instanceof, op_monitorenter, op_monitorexit]: Use it.\n\t(verify_instructions_0) [op_invokevirtual, op_invokespecial,\n\top_invokestatic, op_invokeinterface]:  Use pop_init_ref.  Don't\n\tlet `this' argument be uninitialized.  Don't let `null' be passed\n\tas `this' to construtor.\n\nFrom-SVN: r59558", "tree": {"sha": "65812679d8884a0f8361c1a263cbd245aa783ec6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65812679d8884a0f8361c1a263cbd245aa783ec6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02077425b78dddfa059082e3e2b243fbc4c2fd6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02077425b78dddfa059082e3e2b243fbc4c2fd6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02077425b78dddfa059082e3e2b243fbc4c2fd6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02077425b78dddfa059082e3e2b243fbc4c2fd6a/comments", "author": null, "committer": null, "parents": [{"sha": "920e86b8da49ad52352bb27c7abde2993a551a9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/920e86b8da49ad52352bb27c7abde2993a551a9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/920e86b8da49ad52352bb27c7abde2993a551a9b"}], "stats": {"total": 87, "additions": 61, "deletions": 26}, "files": [{"sha": "f8beb18ba927ea8c4c964b57dbbba32868345c40", "filename": "libjava/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02077425b78dddfa059082e3e2b243fbc4c2fd6a/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02077425b78dddfa059082e3e2b243fbc4c2fd6a/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=02077425b78dddfa059082e3e2b243fbc4c2fd6a", "patch": "@@ -1,3 +1,16 @@\n+2002-11-26  Tom Tromey  <tromey@redhat.com>\n+\n+\t* verify.cc (pop_init_ref): New method.\n+\t(verify_instructions_0) [op_iaload, op_laload, op_faload,\n+\top_daload, op_aaload, op_baload, op_caload, op_saload, op_iastore,\n+\top_lastore, op_fastore, op_dastore, op_aastore, op_bastore,\n+\top_castore, op_sastore, op_areturn, op_arraylength, op_checkcast,\n+\top_instanceof, op_monitorenter, op_monitorexit]: Use it.\n+\t(verify_instructions_0) [op_invokevirtual, op_invokespecial,\n+\top_invokestatic, op_invokeinterface]:  Use pop_init_ref.  Don't\n+\tlet `this' argument be uninitialized.  Don't let `null' be passed\n+\tas `this' to construtor.\n+\n 2002-11-26  Mark Wielaard  <mark@klomp.org>\n \n \t* javax/transaction/HeuristicCommitException.java: Classpath merge."}, {"sha": "dc88944e7577754d9bb5a472e8b05d31873e5219", "filename": "libjava/verify.cc", "status": "modified", "additions": 48, "deletions": 26, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02077425b78dddfa059082e3e2b243fbc4c2fd6a/libjava%2Fverify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02077425b78dddfa059082e3e2b243fbc4c2fd6a/libjava%2Fverify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fverify.cc?ref=02077425b78dddfa059082e3e2b243fbc4c2fd6a", "patch": "@@ -458,7 +458,8 @@ class _Jv_BytecodeVerifier\n       if (key < reference_type || k.key < reference_type)\n \treturn key == k.key;\n \n-      // The `null' type is convertible to any reference type.\n+      // The `null' type is convertible to any initialized reference\n+      // type.\n       if (key == null_type || k.key == null_type)\n \treturn true;\n \n@@ -1137,6 +1138,19 @@ class _Jv_BytecodeVerifier\n     return t;\n   }\n \n+  // Pop a reference which is guaranteed to be initialized.  MATCH\n+  // doesn't have to be a reference type; in this case this acts like\n+  // pop_type.\n+  type pop_init_ref (type match)\n+  {\n+    type t = pop_raw ();\n+    if (t.isreference () && ! t.isinitialized ())\n+      verify_fail (\"initialized reference required\");\n+    else if (! match.compatible (t, this))\n+      verify_fail (\"incompatible type on stack\");\n+    return t;\n+  }\n+\n   // Pop a reference type or a return address.\n   type pop_ref_or_return ()\n   {\n@@ -2300,42 +2314,42 @@ class _Jv_BytecodeVerifier\n \t    break;\n \t  case op_iaload:\n \t    pop_type (int_type);\n-\t    push_type (require_array_type (pop_type (reference_type),\n+\t    push_type (require_array_type (pop_init_ref (reference_type),\n \t\t\t\t\t   int_type));\n \t    break;\n \t  case op_laload:\n \t    pop_type (int_type);\n-\t    push_type (require_array_type (pop_type (reference_type),\n+\t    push_type (require_array_type (pop_init_ref (reference_type),\n \t\t\t\t\t   long_type));\n \t    break;\n \t  case op_faload:\n \t    pop_type (int_type);\n-\t    push_type (require_array_type (pop_type (reference_type),\n+\t    push_type (require_array_type (pop_init_ref (reference_type),\n \t\t\t\t\t   float_type));\n \t    break;\n \t  case op_daload:\n \t    pop_type (int_type);\n-\t    push_type (require_array_type (pop_type (reference_type),\n+\t    push_type (require_array_type (pop_init_ref (reference_type),\n \t\t\t\t\t   double_type));\n \t    break;\n \t  case op_aaload:\n \t    pop_type (int_type);\n-\t    push_type (require_array_type (pop_type (reference_type),\n+\t    push_type (require_array_type (pop_init_ref (reference_type),\n \t\t\t\t\t   reference_type));\n \t    break;\n \t  case op_baload:\n \t    pop_type (int_type);\n-\t    require_array_type (pop_type (reference_type), byte_type);\n+\t    require_array_type (pop_init_ref (reference_type), byte_type);\n \t    push_type (int_type);\n \t    break;\n \t  case op_caload:\n \t    pop_type (int_type);\n-\t    require_array_type (pop_type (reference_type), char_type);\n+\t    require_array_type (pop_init_ref (reference_type), char_type);\n \t    push_type (int_type);\n \t    break;\n \t  case op_saload:\n \t    pop_type (int_type);\n-\t    require_array_type (pop_type (reference_type), short_type);\n+\t    require_array_type (pop_init_ref (reference_type), short_type);\n \t    push_type (int_type);\n \t    break;\n \t  case op_istore:\n@@ -2386,42 +2400,42 @@ class _Jv_BytecodeVerifier\n \t  case op_iastore:\n \t    pop_type (int_type);\n \t    pop_type (int_type);\n-\t    require_array_type (pop_type (reference_type), int_type);\n+\t    require_array_type (pop_init_ref (reference_type), int_type);\n \t    break;\n \t  case op_lastore:\n \t    pop_type (long_type);\n \t    pop_type (int_type);\n-\t    require_array_type (pop_type (reference_type), long_type);\n+\t    require_array_type (pop_init_ref (reference_type), long_type);\n \t    break;\n \t  case op_fastore:\n \t    pop_type (float_type);\n \t    pop_type (int_type);\n-\t    require_array_type (pop_type (reference_type), float_type);\n+\t    require_array_type (pop_init_ref (reference_type), float_type);\n \t    break;\n \t  case op_dastore:\n \t    pop_type (double_type);\n \t    pop_type (int_type);\n-\t    require_array_type (pop_type (reference_type), double_type);\n+\t    require_array_type (pop_init_ref (reference_type), double_type);\n \t    break;\n \t  case op_aastore:\n \t    pop_type (reference_type);\n \t    pop_type (int_type);\n-\t    require_array_type (pop_type (reference_type), reference_type);\n+\t    require_array_type (pop_init_ref (reference_type), reference_type);\n \t    break;\n \t  case op_bastore:\n \t    pop_type (int_type);\n \t    pop_type (int_type);\n-\t    require_array_type (pop_type (reference_type), byte_type);\n+\t    require_array_type (pop_init_ref (reference_type), byte_type);\n \t    break;\n \t  case op_castore:\n \t    pop_type (int_type);\n \t    pop_type (int_type);\n-\t    require_array_type (pop_type (reference_type), char_type);\n+\t    require_array_type (pop_init_ref (reference_type), char_type);\n \t    break;\n \t  case op_sastore:\n \t    pop_type (int_type);\n \t    pop_type (int_type);\n-\t    require_array_type (pop_type (reference_type), short_type);\n+\t    require_array_type (pop_init_ref (reference_type), short_type);\n \t    break;\n \t  case op_pop:\n \t    pop32 ();\n@@ -2759,7 +2773,7 @@ class _Jv_BytecodeVerifier\n \t    invalidate_pc ();\n \t    break;\n \t  case op_areturn:\n-\t    check_return_type (pop_type (reference_type));\n+\t    check_return_type (pop_init_ref (reference_type));\n \t    invalidate_pc ();\n \t    break;\n \t  case op_return:\n@@ -2841,7 +2855,7 @@ class _Jv_BytecodeVerifier\n \t\t  // This is only used for verifying the byte for\n \t\t  // invokeinterface.\n \t\t  nargs -= arg_types[i].depth ();\n-\t\t  pop_type (arg_types[i]);\n+\t\t  pop_init_ref (arg_types[i]);\n \t\t}\n \n \t      if (opcode == op_invokeinterface\n@@ -2858,7 +2872,15 @@ class _Jv_BytecodeVerifier\n \t\t    }\n \t\t  type raw = pop_raw ();\n \t\t  bool ok = false;\n-\t\t  if (t.compatible (raw, this))\n+\t\t  if (! is_init && ! raw.isinitialized ())\n+\t\t    {\n+\t\t      // This is a failure.\n+\t\t    }\n+\t\t  else if (is_init && raw.isnull ())\n+\t\t    {\n+\t\t      // Another failure.\n+\t\t    }\n+\t\t  else if (t.compatible (raw, this))\n \t\t    {\n \t\t      ok = true;\n \t\t    }\n@@ -2914,7 +2936,7 @@ class _Jv_BytecodeVerifier\n \t    break;\n \t  case op_arraylength:\n \t    {\n-\t      type t = pop_type (reference_type);\n+\t      type t = pop_init_ref (reference_type);\n \t      if (! t.isarray () && ! t.isnull ())\n \t\tverify_fail (\"array type expected\");\n \t      push_type (int_type);\n@@ -2925,19 +2947,19 @@ class _Jv_BytecodeVerifier\n \t    invalidate_pc ();\n \t    break;\n \t  case op_checkcast:\n-\t    pop_type (reference_type);\n+\t    pop_init_ref (reference_type);\n \t    push_type (check_class_constant (get_ushort ()));\n \t    break;\n \t  case op_instanceof:\n-\t    pop_type (reference_type);\n+\t    pop_init_ref (reference_type);\n \t    check_class_constant (get_ushort ());\n \t    push_type (int_type);\n \t    break;\n \t  case op_monitorenter:\n-\t    pop_type (reference_type);\n+\t    pop_init_ref (reference_type);\n \t    break;\n \t  case op_monitorexit:\n-\t    pop_type (reference_type);\n+\t    pop_init_ref (reference_type);\n \t    break;\n \t  case op_wide:\n \t    {\n@@ -2971,7 +2993,7 @@ class _Jv_BytecodeVerifier\n \t\t  set_variable (get_ushort (), pop_type (double_type));\n \t\t  break;\n \t\tcase op_astore:\n-\t\t  set_variable (get_ushort (), pop_type (reference_type));\n+\t\t  set_variable (get_ushort (), pop_init_ref (reference_type));\n \t\t  break;\n \t\tcase op_ret:\n \t\t  handle_ret_insn (get_short ());"}]}