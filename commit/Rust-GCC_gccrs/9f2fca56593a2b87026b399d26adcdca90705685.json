{"sha": "9f2fca56593a2b87026b399d26adcdca90705685", "node_id": "C_kwDOANBUbNoAKDlmMmZjYTU2NTkzYTJiODcwMjZiMzk5ZDI2YWRjZGNhOTA3MDU2ODU", "commit": {"author": {"name": "Marcel Vollweiler", "email": "marcel@codesourcery.com", "date": "2022-09-08T17:01:33Z"}, "committer": {"name": "Marcel Vollweiler", "email": "marcel@codesourcery.com", "date": "2022-09-08T17:19:37Z"}, "message": "OpenMP, libgomp: Environment variable syntax extension\n\nThis patch considers the environment variable syntax extension for\ndevice-specific variants of environment variables from OpenMP 5.1 (see\nOpenMP 5.1 specification, p. 75 and p. 639).  An environment variable (e.g.\nOMP_NUM_TEAMS) can have different suffixes:\n\n_DEV (e.g. OMP_NUM_TEAMS_DEV): affects all devices but not the host.\n_DEV_<device> (e.g. OMP_NUM_TEAMS_DEV_42): affects only device with\nnumber <device>.\nno suffix (e.g. OMP_NUM_TEAMS): affects only the host.\n\nIn future OpenMP versions also suffix _ALL will be introduced (see discussion\nhttps://github.com/OpenMP/spec/issues/3179). This is also considered in this\npatch:\n\n_ALL (e.g. OMP_NUM_TEAMS_ALL): affects all devices and the host.\n\nThe precedence is as follows (descending). For the host:\n\n\t1. no suffix\n\t2. _ALL\n\nFor devices:\n\n\t1. _DEV_<device>\n\t2. _DEV\n\t3. _ALL\n\nThat means, _DEV_<device> is used whenever available. Otherwise _DEV is used if\navailable, and at last _ALL.  If there is no value for any of the variable\nvariants, default values are used as already implemented before.\n\nThis patch concerns parsing (a), storing (b), output (c) and transmission to the\ndevice (d):\n\n(a) The actual number of devices and the numbering are not known when parsing\nthe environment variables.  Thus all environment variables are iterated and\nsearched for device-specific ones.\n(b) Only configured device-specific variables are stored.  Thus, a linked list\nis used.\n(c) The output is done in omp_display_env (see specification p. 468f).  Global\nICVs are tagged with [all], see https://github.com/OpenMP/spec/issues/3179.\nICVs which are not global but aren't handled device-specific yet are tagged\nwith [host].  omp_display_env outputs the initial values of the ICVs.  That is\nwhy a dedicated data structure is introduced for the inital values only\n(gomp_initial_icv_list).\n(d) Device-specific ICVs are transmitted to the device via GOMP_ADDITIONAL_ICVS.\n\nlibgomp/ChangeLog:\n\n\t* config/gcn/icv-device.c (omp_get_default_device): Return device-\n\tspecific ICV.\n\t(omp_get_max_teams): Added for GCN devices.\n\t(omp_set_num_teams): Likewise.\n\t(ialias): Likewise.\n\t* config/nvptx/icv-device.c (omp_get_default_device): Return device-\n\tspecific ICV.\n\t(omp_get_max_teams): Added for NVPTX devices.\n\t(omp_set_num_teams): Likewise.\n\t(ialias): Likewise.\n\t* env.c (struct gomp_icv_list): New struct to store entries of initial\n\tICV values.\n\t(struct gomp_offload_icv_list): New struct to store entries of device-\n\tspecific ICV values that are copied to the device and back.\n\t(struct gomp_default_icv_values): New struct to store default values of\n\tICVs according to the OpenMP standard.\n\t(parse_schedule): Generalized for different variants of OMP_SCHEDULE.\n\t(print_env_var_error): Function that prints an error for invalid values\n\tfor ICVs.\n\t(parse_unsigned_long_1): Removed getenv.  Generalized.\n\t(parse_unsigned_long): Likewise.\n\t(parse_int_1): Likewise.\n\t(parse_int): Likewise.\n\t(parse_int_secure): Likewise.\n\t(parse_unsigned_long_list): Likewise.\n\t(parse_target_offload): Likewise.\n\t(parse_bind_var): Likewise.\n\t(parse_stacksize): Likewise.\n\t(parse_boolean): Likewise.\n\t(parse_wait_policy): Likewise.\n\t(parse_allocator): Likewise.\n\t(omp_display_env): Extended to output different variants of environment\n\tvariables.\n\t(print_schedule): New helper function for omp_display_env which prints\n\tthe values of run_sched_var.\n\t(print_proc_bind): New helper function for omp_display_env which prints\n\tthe values of proc_bind_var.\n\t(enum gomp_parse_type): Collection of types used for parsing environment\n\tvariables.\n\t(ENTRY): Preprocess string lengths of environment variables.\n\t(OMP_VAR_CNT): Preprocess table size.\n\t(OMP_HOST_VAR_CNT): Likewise.\n\t(INT_MAX_STR_LEN): Constant for the maximal number of digits of a device\n\tnumber.\n\t(gomp_get_icv_flag): Returns if a flag for a particular ICV is set.\n\t(gomp_set_icv_flag): Sets a flag for a particular ICV.\n\t(print_device_specific_icvs): New helper function for omp_display_env to\n\tprint device specific ICV values.\n\t(get_device_num): New helper function for parse_device_specific.\n\tExtracts the device number from an environment variable name.\n\t(get_icv_member_addr): Gets the memory address for a particular member\n\tof an ICV struct.\n\t(gomp_get_initial_icv_item): Get a list item of gomp_initial_icv_list.\n\t(initialize_icvs): New function to initialize a gomp_initial_icvs\n\tstruct.\n\t(add_initial_icv_to_list): Adds an ICV struct to gomp_initial_icv_list.\n\t(startswith): Checks if a string starts with a given prefix.\n\t(initialize_env): Extended to parse the new syntax of environment\n\tvariables.\n\t* icv-device.c (omp_get_max_teams): Added.\n\t(ialias): Likewise.\n\t(omp_set_num_teams): Likewise.\n\t* icv.c (omp_set_num_teams): Moved to icv-device.c.\n\t(omp_get_max_teams): Likewise.\n\t(ialias): Likewise.\n\t* libgomp-plugin.h (GOMP_DEVICE_NUM_VAR): Removed.\n\t(GOMP_ADDITIONAL_ICVS): New target-side struct that\n\tholds the designated ICVs of the target device.\n\t* libgomp.h (enum gomp_icvs): Collection of ICVs.\n\t(enum gomp_device_num): Definition of device numbers for _ALL, _DEV, and\n\tno suffix.\n\t(enum gomp_env_suffix): Collection of possible suffixes of environment\n\tvariables.\n\t(struct gomp_initial_icvs): Contains all ICVs for which we need to store\n\tinitial values.\n\t(struct gomp_default_icv):New struct to hold ICVs for which we need\n\tto store initial values.\n\t(struct gomp_icv_list): Definition of a linked list that is used for\n\tstoring ICVs for the devices and also for _DEV, _ALL, and without\n\tsuffix.\n\t(struct gomp_offload_icvs): New struct to hold ICVs that are copied to\n\ta device.\n\t(struct gomp_offload_icv_list): Definition of a linked list that holds\n\tdevice-specific ICVs that are copied to devices.\n\t(gomp_get_initial_icv_item): Get a list item of gomp_initial_icv_list.\n\t(gomp_get_icv_flag): Returns if a flag for a particular ICV is set.\n\t* libgomp.texi: Updated.\n\t* plugin/plugin-gcn.c (GOMP_OFFLOAD_load_image): Extended to read\n\tfurther ICVs from the offload image.\n\t* plugin/plugin-nvptx.c (GOMP_OFFLOAD_load_image): Likewise.\n\t* target.c (gomp_get_offload_icv_item): Get a list item of\n\tgomp_offload_icv_list.\n\t(get_gomp_offload_icvs): New. Returns the ICV values\n\tdepending on the device num and the variable hierarchy.\n\t(gomp_load_image_to_device): Extended to copy further ICVs to a device.\n\t* testsuite/libgomp.c-c++-common/icv-5.c: New test.\n\t* testsuite/libgomp.c-c++-common/icv-6.c: New test.\n\t* testsuite/libgomp.c-c++-common/icv-7.c: New test.\n\t* testsuite/libgomp.c-c++-common/icv-8.c: New test.\n\t* testsuite/libgomp.c-c++-common/omp-display-env-1.c: New test.\n\t* testsuite/libgomp.c-c++-common/omp-display-env-2.c: New test.", "tree": {"sha": "33fcfac4b0da2fd40ac628d809834461f01d986a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33fcfac4b0da2fd40ac628d809834461f01d986a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f2fca56593a2b87026b399d26adcdca90705685", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f2fca56593a2b87026b399d26adcdca90705685", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f2fca56593a2b87026b399d26adcdca90705685", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f2fca56593a2b87026b399d26adcdca90705685/comments", "author": null, "committer": null, "parents": [{"sha": "338a5b0d7da84ef1f6c01dd96abf2c6bc830f403", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/338a5b0d7da84ef1f6c01dd96abf2c6bc830f403", "html_url": "https://github.com/Rust-GCC/gccrs/commit/338a5b0d7da84ef1f6c01dd96abf2c6bc830f403"}], "stats": {"total": 1964, "additions": 1582, "deletions": 382}, "files": [{"sha": "bf757ba7808169af92f9d53bfb0fb4849e25c574", "filename": "libgomp/config/gcn/icv-device.c", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Fconfig%2Fgcn%2Ficv-device.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Fconfig%2Fgcn%2Ficv-device.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fgcn%2Ficv-device.c?ref=9f2fca56593a2b87026b399d26adcdca90705685", "patch": "@@ -28,6 +28,10 @@\n \n #include \"libgomp.h\"\n \n+/* This is set to the ICV values of current GPU during device initialization,\n+   when the offload image containing this libgomp portion is loaded.  */\n+volatile struct gomp_offload_icvs GOMP_ADDITIONAL_ICVS;\n+\n void\n omp_set_default_device (int device_num __attribute__((unused)))\n {\n@@ -36,7 +40,7 @@ omp_set_default_device (int device_num __attribute__((unused)))\n int\n omp_get_default_device (void)\n {\n-  return 0;\n+  return GOMP_ADDITIONAL_ICVS.default_device;\n }\n \n int\n@@ -58,14 +62,23 @@ omp_is_initial_device (void)\n   return 0;\n }\n \n-/* This is set to the device number of current GPU during device initialization,\n-   when the offload image containing this libgomp portion is loaded.  */\n-volatile int GOMP_DEVICE_NUM_VAR;\n-\n int\n omp_get_device_num (void)\n {\n-  return GOMP_DEVICE_NUM_VAR;\n+  return GOMP_ADDITIONAL_ICVS.device_num;\n+}\n+\n+int\n+omp_get_max_teams (void)\n+{\n+  return GOMP_ADDITIONAL_ICVS.nteams;\n+}\n+\n+void\n+omp_set_num_teams (int num_teams)\n+{\n+  if (num_teams >= 0)\n+    GOMP_ADDITIONAL_ICVS.nteams = num_teams;\n }\n \n ialias (omp_set_default_device)\n@@ -74,3 +87,5 @@ ialias (omp_get_initial_device)\n ialias (omp_get_num_devices)\n ialias (omp_is_initial_device)\n ialias (omp_get_device_num)\n+ialias (omp_get_max_teams)\n+ialias (omp_set_num_teams)"}, {"sha": "6f869beadce514a94d30231308bb649c92f8d1de", "filename": "libgomp/config/nvptx/icv-device.c", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Fconfig%2Fnvptx%2Ficv-device.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Fconfig%2Fnvptx%2Ficv-device.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Ficv-device.c?ref=9f2fca56593a2b87026b399d26adcdca90705685", "patch": "@@ -28,6 +28,10 @@\n \n #include \"libgomp.h\"\n \n+/* This is set to the ICV values of current GPU during device initialization,\n+   when the offload image containing this libgomp portion is loaded.  */\n+static volatile struct gomp_offload_icvs GOMP_ADDITIONAL_ICVS;\n+\n void\n omp_set_default_device (int device_num __attribute__((unused)))\n {\n@@ -36,7 +40,7 @@ omp_set_default_device (int device_num __attribute__((unused)))\n int\n omp_get_default_device (void)\n {\n-  return 0;\n+  return GOMP_ADDITIONAL_ICVS.default_device;\n }\n \n int\n@@ -58,14 +62,23 @@ omp_is_initial_device (void)\n   return 0;\n }\n \n-/* This is set to the device number of current GPU during device initialization,\n-   when the offload image containing this libgomp portion is loaded.  */\n-static volatile int GOMP_DEVICE_NUM_VAR;\n-\n int\n omp_get_device_num (void)\n {\n-  return GOMP_DEVICE_NUM_VAR;\n+  return GOMP_ADDITIONAL_ICVS.device_num;\n+}\n+\n+int\n+omp_get_max_teams (void)\n+{\n+  return GOMP_ADDITIONAL_ICVS.nteams;\n+}\n+\n+void\n+omp_set_num_teams (int num_teams)\n+{\n+  if (num_teams >= 0)\n+    GOMP_ADDITIONAL_ICVS.nteams = num_teams;\n }\n \n ialias (omp_set_default_device)\n@@ -74,3 +87,5 @@ ialias (omp_get_initial_device)\n ialias (omp_get_num_devices)\n ialias (omp_is_initial_device)\n ialias (omp_get_device_num)\n+ialias (omp_get_max_teams)\n+ialias (omp_set_num_teams)"}, {"sha": "82e22ac789f3a2072cfaa27aadaaf267a3c4d5e6", "filename": "libgomp/env.c", "status": "modified", "additions": 1019, "deletions": 301, "changes": 1320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Fenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Fenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fenv.c?ref=9f2fca56593a2b87026b399d26adcdca90705685", "patch": "@@ -61,18 +61,40 @@\n \n #include \"secure_getenv.h\"\n \n-struct gomp_task_icv gomp_global_icv = {\n+/* Default values of ICVs according to the OpenMP standard.  */\n+const struct gomp_default_icv gomp_default_icv_values = {\n   .nthreads_var = 1,\n   .thread_limit_var = UINT_MAX,\n   .run_sched_var = GFS_DYNAMIC,\n   .run_sched_chunk_size = 1,\n   .default_device_var = 0,\n-  .dyn_var = false,\n   .max_active_levels_var = 1,\n   .bind_var = omp_proc_bind_false,\n+  .nteams_var = 0,\n+  .teams_thread_limit_var = 0,\n+  .dyn_var = false\n+};\n+\n+struct gomp_task_icv gomp_global_icv = {\n+  .nthreads_var = gomp_default_icv_values.nthreads_var,\n+  .thread_limit_var = gomp_default_icv_values.thread_limit_var,\n+  .run_sched_var = gomp_default_icv_values.run_sched_var,\n+  .run_sched_chunk_size = gomp_default_icv_values.run_sched_chunk_size,\n+  .default_device_var = gomp_default_icv_values.default_device_var,\n+  .dyn_var = gomp_default_icv_values.dyn_var,\n+  .max_active_levels_var = gomp_default_icv_values.max_active_levels_var,\n+  .bind_var = gomp_default_icv_values.bind_var,\n   .target_data = NULL\n };\n \n+/* List for initial \"_DEV\", \"_ALL\", and \"_DEV_X\" ICVs like OMP_NUM_TEAMS_DEV,\n+   OMP_NUM_TEAMS_ALL, or OMP_NUM_TEAMS_DEV_42.  */\n+struct gomp_icv_list *gomp_initial_icv_list = NULL;\n+\n+/* List for \"_DEV_X\" ICVs like OMP_NUM_TEAMS_DEV_42.  This list contains all\n+   device-specific ICVs that are copied from host to device and back.  */\n+struct gomp_offload_icv_list *gomp_offload_icv_list = NULL;\n+\n bool gomp_cancel_var = false;\n enum gomp_target_offload_t gomp_target_offload_var\n   = GOMP_TARGET_OFFLOAD_DEFAULT;\n@@ -104,86 +126,92 @@ int goacc_default_dims[GOMP_DIM_MAX];\n static int wait_policy;\n static unsigned long stacksize = GOMP_DEFAULT_STACKSIZE;\n \n-/* Parse the OMP_SCHEDULE environment variable.  */\n-\n static void\n-parse_schedule (void)\n+print_env_var_error (const char *env, const char *val)\n {\n-  char *env, *end;\n+  gomp_error (\"Invalid value for environment variable %.*s: %s\",\n+\t      (int) (val - env - 1), env, val);\n+}\n+\n+/* Parse the OMP_SCHEDULE environment variable.  */\n+static bool\n+parse_schedule (const char *env, const char *val, void *const params[])\n+{\n+  enum gomp_schedule_type *schedule = (enum gomp_schedule_type *) params[0];\n+  int *chunk_size = (int *) params[1];\n+  char *end;\n   unsigned long value;\n   int monotonic = 0;\n \n-  env = getenv (\"OMP_SCHEDULE\");\n-  if (env == NULL)\n-    return;\n+  if (val == NULL)\n+    return false;\n \n-  while (isspace ((unsigned char) *env))\n-    ++env;\n-  if (strncasecmp (env, \"monotonic\", 9) == 0)\n+  while (isspace ((unsigned char) *val))\n+    ++val;\n+  if (strncasecmp (val, \"monotonic\", 9) == 0)\n     {\n       monotonic = 1;\n-      env += 9;\n+      val += 9;\n     }\n-  else if (strncasecmp (env, \"nonmonotonic\", 12) == 0)\n+  else if (strncasecmp (val, \"nonmonotonic\", 12) == 0)\n     {\n       monotonic = -1;\n-      env += 12;\n+      val += 12;\n     }\n   if (monotonic)\n     {\n-      while (isspace ((unsigned char) *env))\n-\t++env;\n-      if (*env != ':')\n+      while (isspace ((unsigned char) *val))\n+\t++val;\n+      if (*val != ':')\n \tgoto unknown;\n-      ++env;\n-      while (isspace ((unsigned char) *env))\n-\t++env;\n+      ++val;\n+      while (isspace ((unsigned char) *val))\n+\t++val;\n     }\n-  if (strncasecmp (env, \"static\", 6) == 0)\n+  if (strncasecmp (val, \"static\", 6) == 0)\n     {\n-      gomp_global_icv.run_sched_var = GFS_STATIC;\n-      env += 6;\n+      *schedule = GFS_STATIC;\n+      val += 6;\n     }\n-  else if (strncasecmp (env, \"dynamic\", 7) == 0)\n+  else if (strncasecmp (val, \"dynamic\", 7) == 0)\n     {\n-      gomp_global_icv.run_sched_var = GFS_DYNAMIC;\n-      env += 7;\n+      *schedule = GFS_DYNAMIC;\n+      val += 7;\n     }\n-  else if (strncasecmp (env, \"guided\", 6) == 0)\n+  else if (strncasecmp (val, \"guided\", 6) == 0)\n     {\n-      gomp_global_icv.run_sched_var = GFS_GUIDED;\n-      env += 6;\n+      *schedule = GFS_GUIDED;\n+      val += 6;\n     }\n-  else if (strncasecmp (env, \"auto\", 4) == 0)\n+  else if (strncasecmp (val, \"auto\", 4) == 0)\n     {\n-      gomp_global_icv.run_sched_var = GFS_AUTO;\n-      env += 4;\n+      *schedule = GFS_AUTO;\n+      val += 4;\n     }\n   else\n     goto unknown;\n \n   if (monotonic == 1\n-      || (monotonic == 0 && gomp_global_icv.run_sched_var == GFS_STATIC))\n-    gomp_global_icv.run_sched_var |= GFS_MONOTONIC;\n+      || (monotonic == 0 && *schedule == GFS_STATIC))\n+    *schedule |= GFS_MONOTONIC;\n \n-  while (isspace ((unsigned char) *env))\n-    ++env;\n-  if (*env == '\\0')\n+  while (isspace ((unsigned char) *val))\n+    ++val;\n+  if (*val == '\\0')\n     {\n-      gomp_global_icv.run_sched_chunk_size\n-\t= (gomp_global_icv.run_sched_var & ~GFS_MONOTONIC) != GFS_STATIC;\n-      return;\n+      *chunk_size = (*schedule & ~GFS_MONOTONIC) != GFS_STATIC;\n+      return true;\n     }\n-  if (*env++ != ',')\n+  if (*val++ != ',')\n     goto unknown;\n-  while (isspace ((unsigned char) *env))\n-    ++env;\n-  if (*env == '\\0')\n+  while (isspace ((unsigned char) *val))\n+    ++val;\n+  if (*val == '\\0')\n     goto invalid;\n \n   errno = 0;\n-  value = strtoul (env, &end, 10);\n-  if (errno || end == env)\n+  value = strtoul (val, &end, 10);\n+  if (errno || end == val)\n     goto invalid;\n \n   while (isspace ((unsigned char) *end))\n@@ -194,45 +222,46 @@ parse_schedule (void)\n   if ((int)value != value)\n     goto invalid;\n \n-  if (value == 0\n-      && (gomp_global_icv.run_sched_var & ~GFS_MONOTONIC) != GFS_STATIC)\n+  if (value == 0 && (*schedule & ~GFS_MONOTONIC) != GFS_STATIC)\n     value = 1;\n-  gomp_global_icv.run_sched_chunk_size = value;\n-  return;\n+  *chunk_size = value;\n+  return true;\n \n  unknown:\n-  gomp_error (\"Unknown value for environment variable OMP_SCHEDULE\");\n-  return;\n+  print_env_var_error (env, val);\n+  return false;\n \n  invalid:\n+  char name[val - env];\n+  memcpy (name, env, val - env - 1);\n+  name[val - env - 1] = '\\0';\n   gomp_error (\"Invalid value for chunk size in \"\n-\t      \"environment variable OMP_SCHEDULE\");\n-  return;\n+\t      \"environment variable %s: %s\", name, val);\n+  return false;\n }\n \n /* Parse an unsigned long environment variable.  Return true if one was\n    present and it was successfully parsed.  If SECURE, use secure_getenv to the\n    environment variable.  */\n \n static bool\n-parse_unsigned_long_1 (const char *name, unsigned long *pvalue, bool allow_zero,\n-\t\t       bool secure)\n+parse_unsigned_long_1 (const char *env, const char *val, unsigned long *pvalue,\n+\t\t       bool allow_zero)\n {\n-  char *env, *end;\n+  char *end;\n   unsigned long value;\n \n-  env = (secure ? secure_getenv (name) : getenv (name));\n-  if (env == NULL)\n+  if (val == NULL)\n     return false;\n \n-  while (isspace ((unsigned char) *env))\n-    ++env;\n-  if (*env == '\\0')\n+  while (isspace ((unsigned char) *val))\n+    ++val;\n+  if (*val == '\\0')\n     goto invalid;\n \n   errno = 0;\n-  value = strtoul (env, &end, 10);\n-  if (errno || end == env || (long) value <= 0 - allow_zero)\n+  value = strtoul (val, &end, 10);\n+  if (errno || end == val || (long) value <= 0 - allow_zero)\n     goto invalid;\n \n   while (isspace ((unsigned char) *end))\n@@ -244,75 +273,94 @@ parse_unsigned_long_1 (const char *name, unsigned long *pvalue, bool allow_zero,\n   return true;\n \n  invalid:\n-  gomp_error (\"Invalid value for environment variable %s\", name);\n+  print_env_var_error (env, val);\n   return false;\n }\n \n /* As parse_unsigned_long_1, but always use getenv.  */\n \n static bool\n-parse_unsigned_long (const char *name, unsigned long *pvalue, bool allow_zero)\n+parse_unsigned_long (const char *env, const char *val, void *const params[])\n {\n-  return parse_unsigned_long_1 (name, pvalue, allow_zero, false);\n+  unsigned upper = (unsigned long) params[2];\n+  unsigned long pvalue = 0;\n+  bool ret = parse_unsigned_long_1 (env, val, &pvalue, (bool) params[1]);\n+  if (!ret)\n+    return false;\n+\n+  if (upper == 0)\n+    *(unsigned long *) params[0] = pvalue;\n+  else\n+    {\n+      if (pvalue > upper)\n+\tpvalue = upper;\n+      if (upper <= UCHAR_MAX)\n+\t*(unsigned char *) params[0] = pvalue;\n+      else if (upper <= UINT_MAX)\n+\t*(unsigned int *) params[0] = pvalue;\n+      else\n+\t*(unsigned long *) params[0] = pvalue;\n+    }\n+\n+  return ret;\n }\n \n /* Parse a positive int environment variable.  Return true if one was\n    present and it was successfully parsed.  If SECURE, use secure_getenv to the\n    environment variable.  */\n \n static bool\n-parse_int_1 (const char *name, int *pvalue, bool allow_zero, bool secure)\n+parse_int_1 (const char *env, const char *val, int *pvalue, bool allow_zero)\n {\n   unsigned long value;\n-  if (!parse_unsigned_long_1 (name, &value, allow_zero, secure))\n+  if (!parse_unsigned_long_1 (env, val, &value, allow_zero))\n     return false;\n   if (value > INT_MAX)\n     {\n-      gomp_error (\"Invalid value for environment variable %s\", name);\n+      print_env_var_error (env, val);\n       return false;\n     }\n   *pvalue = (int) value;\n   return true;\n }\n \n-/* As parse_int_1, but use getenv.  */\n-\n static bool\n-parse_int (const char *name, int *pvalue, bool allow_zero)\n+parse_int (const char *env, const char *val, void *const params[])\n {\n-  return parse_int_1 (name, pvalue, allow_zero, false);\n+  return parse_int_1 (env, val, (int *) params[0], (bool) params[1]);\n }\n \n /* As parse_int_1, but use getenv_secure.  */\n \n static bool\n-parse_int_secure (const char *name, int *pvalue, bool allow_zero)\n+parse_int_secure (const char *env, int *pvalue, bool allow_zero)\n {\n-  return parse_int_1 (name, pvalue, allow_zero, true);\n+  return parse_int_1 (env, secure_getenv (env), pvalue, allow_zero);\n }\n \n /* Parse an unsigned long list environment variable.  Return true if one was\n    present and it was successfully parsed.  */\n \n static bool\n-parse_unsigned_long_list (const char *name, unsigned long *p1stvalue,\n-\t\t\t  unsigned long **pvalues,\n-\t\t\t  unsigned long *pnvalues)\n+parse_unsigned_long_list (const char *env, const char *val,\n+\t\t\t  void *const params[])\n {\n-  char *env, *end;\n+  unsigned long *p1stvalue = (unsigned long *) params[0];\n+  unsigned long **pvalues = (unsigned long **) params[1];\n+  unsigned long *pnvalues = (unsigned long *) params[2];\n+  char *end;\n   unsigned long value, *values = NULL;\n \n-  env = getenv (name);\n-  if (env == NULL)\n+  if (val == NULL)\n     return false;\n \n-  while (isspace ((unsigned char) *env))\n-    ++env;\n-  if (*env == '\\0')\n+  while (isspace ((unsigned char) *val))\n+    ++val;\n+  if (*val == '\\0')\n     goto invalid;\n \n   errno = 0;\n-  value = strtoul (env, &end, 10);\n+  value = strtoul (val, &end, 10);\n   if (errno || (long) value <= 0)\n     goto invalid;\n \n@@ -326,7 +374,7 @@ parse_unsigned_long_list (const char *name, unsigned long *p1stvalue,\n \n \t  do\n \t    {\n-\t      env = end + 1;\n+\t      val = end + 1;\n \t      if (nvalues == nalloced)\n \t\t{\n \t\t  unsigned long *n;\n@@ -335,6 +383,9 @@ parse_unsigned_long_list (const char *name, unsigned long *p1stvalue,\n \t\t  if (n == NULL)\n \t\t    {\n \t\t      free (values);\n+\t\t      char name[val - env];\n+\t\t      memcpy (name, env, val - env - 1);\n+\t\t      name[val - env - 1] = '\\0';\n \t\t      gomp_error (\"Out of memory while trying to parse\"\n \t\t\t\t  \" environment variable %s\", name);\n \t\t      return false;\n@@ -344,13 +395,13 @@ parse_unsigned_long_list (const char *name, unsigned long *p1stvalue,\n \t\t    values[nvalues++] = value;\n \t\t}\n \n-\t      while (isspace ((unsigned char) *env))\n-\t\t++env;\n-\t      if (*env == '\\0')\n+\t      while (isspace ((unsigned char) *val))\n+\t\t++val;\n+\t      if (*val == '\\0')\n \t\tgoto invalid;\n \n \t      errno = 0;\n-\t      value = strtoul (env, &end, 10);\n+\t      value = strtoul (val, &end, 10);\n \t      if (errno || (long) value <= 0)\n \t\tgoto invalid;\n \n@@ -370,63 +421,68 @@ parse_unsigned_long_list (const char *name, unsigned long *p1stvalue,\n \t}\n       goto invalid;\n     }\n+  else\n+    {\n+      *pnvalues = 0;\n+      *pvalues = NULL;\n+    }\n \n   *p1stvalue = value;\n   return true;\n \n  invalid:\n   free (values);\n-  gomp_error (\"Invalid value for environment variable %s\", name);\n+  print_env_var_error (env, val);\n   return false;\n }\n \n-static void\n-parse_target_offload (const char *name, enum gomp_target_offload_t *offload)\n+static bool\n+parse_target_offload (const char *env, const char *val, void *const params[])\n {\n-  const char *env;\n   int new_offload = -1;\n \n-  env = getenv (name);\n-  if (env == NULL)\n-    return;\n+  if (val == NULL)\n+    return false;\n \n-  while (isspace ((unsigned char) *env))\n-    ++env;\n-  if (strncasecmp (env, \"default\", 7) == 0)\n+  while (isspace ((unsigned char) *val))\n+    ++val;\n+  if (strncasecmp (val, \"default\", 7) == 0)\n     {\n-      env += 7;\n+      val += 7;\n       new_offload = GOMP_TARGET_OFFLOAD_DEFAULT;\n     }\n-  else if (strncasecmp (env, \"mandatory\", 9) == 0)\n+  else if (strncasecmp (val, \"mandatory\", 9) == 0)\n     {\n-      env += 9;\n+      val += 9;\n       new_offload = GOMP_TARGET_OFFLOAD_MANDATORY;\n     }\n-  else if (strncasecmp (env, \"disabled\", 8) == 0)\n+  else if (strncasecmp (val, \"disabled\", 8) == 0)\n     {\n-      env += 8;\n+      val += 8;\n       new_offload = GOMP_TARGET_OFFLOAD_DISABLED;\n     }\n-  while (isspace ((unsigned char) *env))\n-    ++env;\n-  if (new_offload != -1 && *env == '\\0')\n+  while (isspace ((unsigned char) *val))\n+    ++val;\n+  if (new_offload != -1 && *val == '\\0')\n     {\n-      *offload = new_offload;\n-      return;\n+      *(enum gomp_target_offload_t *) params[0] = new_offload;\n+      return true;\n     }\n \n-  gomp_error (\"Invalid value for environment variable OMP_TARGET_OFFLOAD\");\n+  print_env_var_error (env, val);\n+  return false;\n }\n \n /* Parse environment variable set to a boolean or list of omp_proc_bind_t\n    enum values.  Return true if one was present and it was successfully\n    parsed.  */\n \n static bool\n-parse_bind_var (const char *name, char *p1stvalue,\n-\t\tchar **pvalues, unsigned long *pnvalues)\n+parse_bind_var (const char *env, const char *val, void *const params[])\n {\n-  char *env;\n+  char *p1stvalue = (char *) params[0];\n+  char **pvalues = (char **) params[1];\n+  unsigned long *pnvalues = (unsigned long *) params[2];\n   char value = omp_proc_bind_false, *values = NULL;\n   int i;\n   static struct proc_bind_kinds\n@@ -444,30 +500,29 @@ parse_bind_var (const char *name, char *p1stvalue,\n     { \"spread\", 6, omp_proc_bind_spread }\n   };\n \n-  env = getenv (name);\n-  if (env == NULL)\n+  if (val == NULL)\n     return false;\n \n-  while (isspace ((unsigned char) *env))\n-    ++env;\n-  if (*env == '\\0')\n+  while (isspace ((unsigned char) *val))\n+    ++val;\n+  if (*val == '\\0')\n     goto invalid;\n \n   for (i = 0; i < 6; i++)\n-    if (strncasecmp (env, kinds[i].name, kinds[i].len) == 0)\n+    if (strncasecmp (val, kinds[i].name, kinds[i].len) == 0)\n       {\n \tvalue = kinds[i].kind;\n-\tenv += kinds[i].len;\n+\tval += kinds[i].len;\n \tbreak;\n       }\n   if (i == 6)\n     goto invalid;\n \n-  while (isspace ((unsigned char) *env))\n-    ++env;\n-  if (*env != '\\0')\n+  while (isspace ((unsigned char) *val))\n+    ++val;\n+  if (*val != '\\0')\n     {\n-      if (*env == ',')\n+      if (*val == ',')\n \t{\n \t  unsigned long nvalues = 0, nalloced = 0;\n \n@@ -477,7 +532,7 @@ parse_bind_var (const char *name, char *p1stvalue,\n \n \t  do\n \t    {\n-\t      env++;\n+\t      val++;\n \t      if (nvalues == nalloced)\n \t\t{\n \t\t  char *n;\n@@ -486,6 +541,9 @@ parse_bind_var (const char *name, char *p1stvalue,\n \t\t  if (n == NULL)\n \t\t    {\n \t\t      free (values);\n+\t\t      char name[val - env];\n+\t\t      memcpy (name, env, val - env - 1);\n+\t\t      name[val - env - 1] = '\\0';\n \t\t      gomp_error (\"Out of memory while trying to parse\"\n \t\t\t\t  \" environment variable %s\", name);\n \t\t      return false;\n@@ -495,27 +553,27 @@ parse_bind_var (const char *name, char *p1stvalue,\n \t\t    values[nvalues++] = value;\n \t\t}\n \n-\t      while (isspace ((unsigned char) *env))\n-\t\t++env;\n-\t      if (*env == '\\0')\n+\t      while (isspace ((unsigned char) *val))\n+\t\t++val;\n+\t      if (*val == '\\0')\n \t\tgoto invalid;\n \n \t      for (i = 2; i < 6; i++)\n-\t\tif (strncasecmp (env, kinds[i].name, kinds[i].len) == 0)\n+\t\tif (strncasecmp (val, kinds[i].name, kinds[i].len) == 0)\n \t\t  {\n \t\t    value = kinds[i].kind;\n-\t\t    env += kinds[i].len;\n+\t\t    val += kinds[i].len;\n \t\t    break;\n \t\t  }\n \t      if (i == 6)\n \t\tgoto invalid;\n \n \t      values[nvalues++] = value;\n-\t      while (isspace ((unsigned char) *env))\n-\t\t++env;\n-\t      if (*env == '\\0')\n+\t      while (isspace ((unsigned char) *val))\n+\t\t++val;\n+\t      if (*val == '\\0')\n \t\tbreak;\n-\t      if (*env != ',')\n+\t      if (*val != ',')\n \t\tgoto invalid;\n \t    }\n \t  while (1);\n@@ -532,7 +590,7 @@ parse_bind_var (const char *name, char *p1stvalue,\n \n  invalid:\n   free (values);\n-  gomp_error (\"Invalid value for environment variable %s\", name);\n+  print_env_var_error (env, val);\n   return false;\n }\n \n@@ -865,23 +923,22 @@ parse_places_var (const char *name, bool ignore)\n    present and it was successfully parsed.  */\n \n static bool\n-parse_stacksize (const char *name, unsigned long *pvalue)\n+parse_stacksize (const char *env, const char *val, void *const params[])\n {\n-  char *env, *end;\n+  char *end;\n   unsigned long value, shift = 10;\n \n-  env = getenv (name);\n-  if (env == NULL)\n+  if (val == NULL)\n     return false;\n \n-  while (isspace ((unsigned char) *env))\n-    ++env;\n-  if (*env == '\\0')\n+  while (isspace ((unsigned char) *val))\n+    ++val;\n+  if (*val == '\\0')\n     goto invalid;\n \n   errno = 0;\n-  value = strtoul (env, &end, 10);\n-  if (errno || end == env)\n+  value = strtoul (val, &end, 10);\n+  if (errno || end == val)\n     goto invalid;\n \n   while (isspace ((unsigned char) *end))\n@@ -914,11 +971,11 @@ parse_stacksize (const char *name, unsigned long *pvalue)\n   if (((value << shift) >> shift) != value)\n     goto invalid;\n \n-  *pvalue = value << shift;\n+  *(unsigned long *) params[0] = value << shift;\n   return true;\n \n  invalid:\n-  gomp_error (\"Invalid value for environment variable %s\", name);\n+  print_env_var_error (env, val);\n   return false;\n }\n \n@@ -998,72 +1055,76 @@ parse_spincount (const char *name, unsigned long long *pvalue)\n /* Parse a boolean value for environment variable NAME and store the\n    result in VALUE.  Return true if one was present and it was\n    successfully parsed.  */\n-\n static bool\n-parse_boolean (const char *name, bool *value)\n+parse_boolean (const char *env, const char *val, void *const params[])\n {\n-  const char *env;\n+  bool *value = (bool *) params[0];\n \n-  env = getenv (name);\n-  if (env == NULL)\n+  if (val == NULL)\n     return false;\n \n-  while (isspace ((unsigned char) *env))\n-    ++env;\n-  if (strncasecmp (env, \"true\", 4) == 0)\n+  while (isspace ((unsigned char) *val))\n+    ++val;\n+  if (strncasecmp (val, \"true\", 4) == 0)\n     {\n       *value = true;\n-      env += 4;\n+      val += 4;\n     }\n-  else if (strncasecmp (env, \"false\", 5) == 0)\n+  else if (strncasecmp (val, \"false\", 5) == 0)\n     {\n       *value = false;\n-      env += 5;\n+      val += 5;\n     }\n   else\n-    env = \"X\";\n-  while (isspace ((unsigned char) *env))\n-    ++env;\n-  if (*env != '\\0')\n+    val = \"X\";\n+  while (isspace ((unsigned char) *val))\n+    ++val;\n+  if (*val != '\\0')\n     {\n-      gomp_error (\"Invalid value for environment variable %s\", name);\n+      print_env_var_error (env, val);\n       return false;\n     }\n   return true;\n }\n \n /* Parse the OMP_WAIT_POLICY environment variable and return the value.  */\n \n-static int\n-parse_wait_policy (void)\n+static bool\n+parse_wait_policy (const char *env, const char *val, void *const params[])\n {\n-  const char *env;\n+  int *pvalue = (int *) params[0];\n   int ret = -1;\n \n-  env = getenv (\"OMP_WAIT_POLICY\");\n-  if (env == NULL)\n-    return -1;\n+  if (val == NULL)\n+  {\n+    *pvalue = -1;\n+    return false;\n+  }\n \n-  while (isspace ((unsigned char) *env))\n-    ++env;\n-  if (strncasecmp (env, \"active\", 6) == 0)\n+  while (isspace ((unsigned char) *val))\n+    ++val;\n+  if (strncasecmp (val, \"active\", 6) == 0)\n     {\n       ret = 1;\n-      env += 6;\n+      val += 6;\n     }\n-  else if (strncasecmp (env, \"passive\", 7) == 0)\n+  else if (strncasecmp (val, \"passive\", 7) == 0)\n     {\n       ret = 0;\n-      env += 7;\n+      val += 7;\n     }\n   else\n-    env = \"X\";\n-  while (isspace ((unsigned char) *env))\n-    ++env;\n-  if (*env == '\\0')\n-    return ret;\n-  gomp_error (\"Invalid value for environment variable OMP_WAIT_POLICY\");\n-  return -1;\n+    val = \"X\";\n+  while (isspace ((unsigned char) *val))\n+    ++val;\n+  if (*val == '\\0')\n+    {\n+      *pvalue = ret;\n+      return true;\n+    }\n+  print_env_var_error (env, val);\n+  *pvalue = -1;\n+  return false;\n }\n \n /* Parse the GOMP_CPU_AFFINITY environment varible.  Return true if one was\n@@ -1167,26 +1228,24 @@ parse_affinity (bool ignore)\n }\n \n /* Parse the OMP_ALLOCATOR environment variable and return the value.  */\n-\n-static uintptr_t\n-parse_allocator (void)\n+static bool\n+parse_allocator (const char *env, const char *val, void *const params[])\n {\n-  const char *env;\n-  uintptr_t ret = omp_default_mem_alloc;\n+  uintptr_t *ret = (uintptr_t *) params[0];\n+  *ret = omp_default_mem_alloc;\n \n-  env = getenv (\"OMP_ALLOCATOR\");\n-  if (env == NULL)\n-    return ret;\n+  if (val == NULL)\n+    return false;\n \n-  while (isspace ((unsigned char) *env))\n-    ++env;\n+  while (isspace ((unsigned char) *val))\n+    ++val;\n   if (0)\n     ;\n #define C(v) \\\n-  else if (strncasecmp (env, #v, sizeof (#v) - 1) == 0)\t\\\n+  else if (strncasecmp (val, #v, sizeof (#v) - 1) == 0)\t\\\n     {\t\t\t\t\t\t\t\\\n-      ret = v;\t\t\t\t\t\t\\\n-      env += sizeof (#v) - 1;\t\t\t\t\\\n+      *ret = v;\t\t\t\t\t\t\\\n+      val += sizeof (#v) - 1;\t\t\t\t\\\n     }\n   C (omp_default_mem_alloc)\n   C (omp_large_cap_mem_alloc)\n@@ -1198,13 +1257,14 @@ parse_allocator (void)\n   C (omp_thread_mem_alloc)\n #undef C\n   else\n-    env = \"X\";\n-  while (isspace ((unsigned char) *env))\n-    ++env;\n-  if (*env == '\\0')\n-    return ret;\n-  gomp_error (\"Invalid value for environment variable OMP_ALLOCATOR\");\n-  return omp_default_mem_alloc;\n+    val = \"X\";\n+  while (isspace ((unsigned char) *val))\n+    ++val;\n+  if (*val == '\\0')\n+    return true;\n+  print_env_var_error (env, val);\n+  *ret = omp_default_mem_alloc;\n+  return false;\n }\n \n static void\n@@ -1251,62 +1311,59 @@ parse_gomp_openacc_dim (void)\n     }\n }\n \n-void\n-omp_display_env (int verbose)\n-{\n-  int i;\n-\n-  fputs (\"\\nOPENMP DISPLAY ENVIRONMENT BEGIN\\n\", stderr);\n+/* Helper function for omp_display_env which prints the values of run_sched_var.\n+   'device' can be 'host', 'dev', 'all' or a particular device number.  */\n \n-  fputs (\"  _OPENMP = '201511'\\n\", stderr);\n-  fprintf (stderr, \"  OMP_DYNAMIC = '%s'\\n\",\n-\t   gomp_global_icv.dyn_var ? \"TRUE\" : \"FALSE\");\n-  fprintf (stderr, \"  OMP_NESTED = '%s'\\n\",\n-\t   gomp_global_icv.max_active_levels_var > 1 ? \"TRUE\" : \"FALSE\");\n-\n-  fprintf (stderr, \"  OMP_NUM_THREADS = '%lu\", gomp_global_icv.nthreads_var);\n-  for (i = 1; i < gomp_nthreads_var_list_len; i++)\n-    fprintf (stderr, \",%lu\", gomp_nthreads_var_list[i]);\n-  fputs (\"'\\n\", stderr);\n-\n-  fprintf (stderr, \"  OMP_SCHEDULE = '\");\n-  if ((gomp_global_icv.run_sched_var & GFS_MONOTONIC))\n+static void\n+print_schedule (enum gomp_schedule_type run_sched_var, int run_sched_chunk_size,\n+\t\tconst char *device)\n+{\n+  fprintf (stderr, \"  [%s] OMP_SCHEDULE = '\", device);\n+  if ((run_sched_var & GFS_MONOTONIC))\n     {\n-      if (gomp_global_icv.run_sched_var != (GFS_MONOTONIC | GFS_STATIC))\n+      if (run_sched_var != (GFS_MONOTONIC | GFS_STATIC))\n \tfputs (\"MONOTONIC:\", stderr);\n     }\n-  else if (gomp_global_icv.run_sched_var == GFS_STATIC)\n+  else if (run_sched_var == GFS_STATIC)\n     fputs (\"NONMONOTONIC:\", stderr);\n-  switch (gomp_global_icv.run_sched_var & ~GFS_MONOTONIC)\n+  switch (run_sched_var & ~GFS_MONOTONIC)\n     {\n     case GFS_RUNTIME:\n       fputs (\"RUNTIME\", stderr);\n-      if (gomp_global_icv.run_sched_chunk_size != 1)\n-\tfprintf (stderr, \",%d\", gomp_global_icv.run_sched_chunk_size);\n+      if (run_sched_chunk_size != 1)\n+\tfprintf (stderr, \",%d\", run_sched_chunk_size);\n       break;\n     case GFS_STATIC:\n       fputs (\"STATIC\", stderr);\n-      if (gomp_global_icv.run_sched_chunk_size != 0)\n-\tfprintf (stderr, \",%d\", gomp_global_icv.run_sched_chunk_size);\n+      if (run_sched_chunk_size != 0)\n+\tfprintf (stderr, \",%d\", run_sched_chunk_size);\n       break;\n     case GFS_DYNAMIC:\n       fputs (\"DYNAMIC\", stderr);\n-      if (gomp_global_icv.run_sched_chunk_size != 1)\n-\tfprintf (stderr, \",%d\", gomp_global_icv.run_sched_chunk_size);\n+      if (run_sched_chunk_size != 1)\n+\tfprintf (stderr, \",%d\", run_sched_chunk_size);\n       break;\n     case GFS_GUIDED:\n       fputs (\"GUIDED\", stderr);\n-      if (gomp_global_icv.run_sched_chunk_size != 1)\n-\tfprintf (stderr, \",%d\", gomp_global_icv.run_sched_chunk_size);\n+      if (run_sched_chunk_size != 1)\n+\tfprintf (stderr, \",%d\", run_sched_chunk_size);\n       break;\n     case GFS_AUTO:\n       fputs (\"AUTO\", stderr);\n       break;\n     }\n   fputs (\"'\\n\", stderr);\n+}\n+\n+/* Helper function for omp_display_env which prints the values of proc_bind_var.\n+   'device' can be 'host', 'dev', 'all', or a particular device number.  */\n \n-  fputs (\"  OMP_PROC_BIND = '\", stderr);\n-  switch (gomp_global_icv.bind_var)\n+static void\n+print_proc_bind (char proc_bind_var, unsigned long len, char **list,\n+\t\t const char *device)\n+{\n+  fprintf (stderr, \"  [%s] OMP_PROC_BIND = '\", device);\n+  switch (proc_bind_var)\n     {\n     case omp_proc_bind_false:\n       fputs (\"FALSE\", stderr);\n@@ -1324,8 +1381,8 @@ omp_display_env (int verbose)\n       fputs (\"SPREAD\", stderr);\n       break;\n     }\n-  for (i = 1; i < gomp_bind_var_list_len; i++)\n-    switch (gomp_bind_var_list[i])\n+  for (int i = 1; i < len; i++)\n+    switch ((*list)[i])\n       {\n       case omp_proc_bind_master:\n \tfputs (\",MASTER\", stderr); /* TODO: Change to PRIMARY for OpenMP 5.1. */\n@@ -1338,7 +1395,290 @@ omp_display_env (int verbose)\n \tbreak;\n       }\n   fputs (\"'\\n\", stderr);\n-  fputs (\"  OMP_PLACES = '\", stderr);\n+}\n+\n+enum gomp_parse_type\n+{\n+  PARSE_INT = 1,\n+  PARSE_BOOL = 2,\n+  PARSE_UINT = 3,\n+  PARSE_ULONG = 4,\n+  PARSE_UCHAR = 5,\n+  PARSE_SCHEDULE =6,\n+  PARSE_BIND = 7\n+};\n+\n+/* The following table contains items that help parsing environment variables\n+   and fill corresponding ICVs with values.  FLAG_VARS contain all ICVS which\n+   are affected by the environment variable.  FLAGS determine what variant of\n+   environment variable is allowed.  */\n+\n+#define ENTRY(NAME) NAME, sizeof (NAME) - 1\n+static const struct envvar\n+{\n+  const char *name;\n+  int name_len;\n+  uint8_t flag_vars[3];\n+  uint8_t flag;\n+  bool (*parse_func) (const char *, const char *, void *const[]);\n+} envvars[] = {\n+  { ENTRY (\"SCHEDULE\"),\n+    { GOMP_ICV_SCHEDULE, GOMP_ICV_SCHEDULE_CHUNK_SIZE },\n+    GOMP_ENV_SUFFIX_DEV | GOMP_ENV_SUFFIX_ALL | GOMP_ENV_SUFFIX_DEV_X,\n+    &parse_schedule },\n+  { ENTRY (\"NUM_TEAMS\"),\n+    { GOMP_ICV_NTEAMS },\n+    GOMP_ENV_SUFFIX_DEV | GOMP_ENV_SUFFIX_ALL | GOMP_ENV_SUFFIX_DEV_X,\n+    &parse_int },\n+  { ENTRY (\"DYNAMIC\"),\n+    { GOMP_ICV_DYNAMIC },\n+    GOMP_ENV_SUFFIX_DEV | GOMP_ENV_SUFFIX_ALL | GOMP_ENV_SUFFIX_DEV_X,\n+    &parse_boolean },\n+  { ENTRY (\"TEAMS_THREAD_LIMIT\"),\n+    { GOMP_ICV_TEAMS_THREAD_LIMIT },\n+    GOMP_ENV_SUFFIX_DEV | GOMP_ENV_SUFFIX_ALL | GOMP_ENV_SUFFIX_DEV_X,\n+    &parse_int },\n+  { ENTRY (\"THREAD_LIMIT\"),\n+    { GOMP_ICV_THREAD_LIMIT },\n+    GOMP_ENV_SUFFIX_DEV | GOMP_ENV_SUFFIX_ALL | GOMP_ENV_SUFFIX_DEV_X,\n+    &parse_unsigned_long },\n+  { ENTRY (\"NUM_THREADS\"),\n+    { GOMP_ICV_NTHREADS, GOMP_ICV_NTHREADS_LIST, GOMP_ICV_NTHREADS_LIST_LEN },\n+    GOMP_ENV_SUFFIX_DEV | GOMP_ENV_SUFFIX_ALL | GOMP_ENV_SUFFIX_DEV_X,\n+    &parse_unsigned_long_list },\n+  { ENTRY (\"PROC_BIND\"),\n+    { GOMP_ICV_BIND, GOMP_ICV_BIND_LIST, GOMP_ICV_BIND_LIST_LEN },\n+    GOMP_ENV_SUFFIX_DEV | GOMP_ENV_SUFFIX_ALL | GOMP_ENV_SUFFIX_DEV_X,\n+    &parse_bind_var },\n+  { ENTRY (\"MAX_ACTIVE_LEVELS\"),\n+    { GOMP_ICV_MAX_ACTIVE_LEVELS },\n+    GOMP_ENV_SUFFIX_DEV | GOMP_ENV_SUFFIX_ALL | GOMP_ENV_SUFFIX_DEV_X,\n+    &parse_unsigned_long },\n+  { ENTRY (\"WAIT_POLICY\"),\n+    { GOMP_ICV_WAIT_POLICY },\n+    GOMP_ENV_SUFFIX_DEV | GOMP_ENV_SUFFIX_ALL | GOMP_ENV_SUFFIX_DEV_X,\n+    &parse_wait_policy },\n+  { ENTRY (\"STACKSIZE\"),\n+    { GOMP_ICV_STACKSIZE },\n+    GOMP_ENV_SUFFIX_DEV | GOMP_ENV_SUFFIX_ALL | GOMP_ENV_SUFFIX_DEV_X,\n+    &parse_stacksize },\n+  { ENTRY (\"CANCELLATION\"), { GOMP_ICV_CANCELLATION }, 0, &parse_boolean },\n+  { ENTRY (\"DISPLAY_AFFINITY\"), { GOMP_ICV_DISPLAY_AFFINITY }, 0,\n+    &parse_boolean },\n+  { ENTRY (\"TARGET_OFFLOAD\"), { GOMP_ICV_TARGET_OFFLOAD }, 0,\n+    &parse_target_offload },\n+  { ENTRY (\"MAX_TASK_PRIORITY\"), { GOMP_ICV_MAX_TASK_PRIORITY }, 0,\n+    &parse_int },\n+  { ENTRY (\"ALLOCATOR\"), { GOMP_ICV_ALLOCATOR }, 0, &parse_allocator },\n+  { ENTRY (\"DEFAULT_DEVICE\"), { GOMP_ICV_DEFAULT_DEVICE },\n+    GOMP_ENV_SUFFIX_DEV | GOMP_ENV_SUFFIX_ALL | GOMP_ENV_SUFFIX_DEV_X,\n+    &parse_int }\n+};\n+#undef ENTRY\n+#define OMP_VAR_CNT (sizeof (envvars) / sizeof (envvars[0]))\n+\n+/* The following table is used to apply the hierarchy of ICV variants for host\n+   variables, e.g. nteams_var is set to OMP_NUM_TEAMS_ALL if OMP_NUM_TEAMS is\n+   undefined.  */\n+\n+static const struct host_envvar\n+{\n+  unsigned char flag_var;\n+  void *dest[3];\n+  int type_code;\n+} host_envvars[] = {\n+  { GOMP_ICV_NTEAMS, { &gomp_nteams_var }, PARSE_INT },\n+  { GOMP_ICV_DYNAMIC, { &gomp_global_icv.dyn_var }, PARSE_BOOL },\n+  { GOMP_ICV_DEFAULT_DEVICE, { &gomp_global_icv.default_device_var },\n+    PARSE_INT },\n+  { GOMP_ICV_TEAMS_THREAD_LIMIT, { &gomp_teams_thread_limit_var }, PARSE_INT },\n+  { GOMP_ICV_SCHEDULE,\n+    { &gomp_global_icv.run_sched_var, &gomp_global_icv.run_sched_chunk_size },\n+    PARSE_SCHEDULE },\n+  { GOMP_ICV_THREAD_LIMIT, { &gomp_global_icv.thread_limit_var }, PARSE_UINT },\n+  { GOMP_ICV_NTHREADS,\n+    { &gomp_global_icv.nthreads_var, &gomp_nthreads_var_list,\n+      &gomp_nthreads_var_list_len }, PARSE_ULONG },\n+  { GOMP_ICV_BIND,\n+    { &gomp_global_icv.bind_var, &gomp_bind_var_list, &gomp_bind_var_list_len },\n+    PARSE_BIND },\n+  { GOMP_ICV_MAX_ACTIVE_LEVELS, { &gomp_global_icv.max_active_levels_var },\n+    PARSE_UCHAR },\n+};\n+#define OMP_HOST_VAR_CNT (sizeof (host_envvars) / sizeof (host_envvars[0]))\n+\n+#define INT_MAX_STR_LEN 10\n+\n+bool\n+gomp_get_icv_flag (uint32_t value, enum gomp_icvs icv)\n+{\n+  return value & (1 << (icv - 1));\n+}\n+\n+static void\n+gomp_set_icv_flag (uint32_t *value, enum gomp_icvs icv)\n+{\n+  *value |= 1 << (icv - 1);\n+}\n+\n+static void\n+print_device_specific_icvs (int icv_code)\n+{\n+  struct gomp_icv_list *list = gomp_initial_icv_list;\n+  int i;\n+  char dev_num[INT_MAX_STR_LEN + 1];\n+\n+  while (list != NULL)\n+    {\n+      if (list->device_num < 0)\n+\t{\n+\t  list = list->next;\n+\t  continue;\n+\t}\n+\n+      switch (icv_code)\n+\t{\n+\tcase GOMP_ICV_NTEAMS:\n+\t  if (gomp_get_icv_flag (list->flags, GOMP_ICV_NTEAMS))\n+\t    fprintf (stderr, \"  [%d] OMP_NUM_TEAMS = '%d'\\n\",\n+\t\t     list->device_num, list->icvs.nteams_var);\n+\t  break;\n+\tcase GOMP_ICV_DYNAMIC:\n+\t  if (gomp_get_icv_flag (list->flags, GOMP_ICV_DYNAMIC))\n+\t    fprintf (stderr, \"  [%d] OMP_DYNAMIC = '%s'\\n\",\n+\t\t     list->device_num, list->icvs.dyn_var ? \"TRUE\" : \"FALSE\");\n+\t  break;\n+\tcase GOMP_ICV_TEAMS_THREAD_LIMIT:\n+\t  if (gomp_get_icv_flag (list->flags, GOMP_ICV_TEAMS_THREAD_LIMIT))\n+\t    fprintf (stderr, \"  [%d] OMP_TEAMS_THREAD_LIMIT = '%u'\\n\",\n+\t\t     list->device_num, list->icvs.teams_thread_limit_var);\n+\t  break;\n+\tcase GOMP_ICV_SCHEDULE:\n+\t  if (!(gomp_get_icv_flag (list->flags, GOMP_ICV_SCHEDULE)))\n+\t    break;\n+\t  sprintf (dev_num, \"%d\", list->device_num);\n+\t  print_schedule (list->icvs.run_sched_var,\n+\t\t\t  list->icvs.run_sched_chunk_size,\n+\t\t\t  dev_num);\n+\t  break;\n+\tcase GOMP_ICV_THREAD_LIMIT:\n+\t  if (gomp_get_icv_flag (list->flags, GOMP_ICV_THREAD_LIMIT))\n+\t    fprintf (stderr, \"  [%d] OMP_THREAD_LIMIT = '%d'\\n\",\n+\t\t     list->device_num, list->icvs.thread_limit_var);\n+\t  break;\n+\tcase GOMP_ICV_NTHREADS:\n+\t  if (!(gomp_get_icv_flag (list->flags, GOMP_ICV_NTHREADS)))\n+\t    break;\n+\t  fprintf (stderr, \"  [%d] OMP_NUM_THREADS = '%lu\", list->device_num,\n+\t\t   list->icvs.nthreads_var);\n+\t  for (i = 1; i < list->icvs.nthreads_var_list_len; i++)\n+\t    fprintf (stderr, \",%lu\", list->icvs.nthreads_var_list[i]);\n+\t  fputs (\"'\\n\", stderr);\n+\t  break;\n+\tcase GOMP_ICV_MAX_ACTIVE_LEVELS:\n+\t  fprintf (stderr, \"  [%d] OMP_MAX_ACTIVE_LEVELS = '%u'\\n\",\n+\t\t   list->device_num, list->icvs.max_active_levels_var);\n+\t  break;\n+\tcase GOMP_ICV_BIND:\n+\t  if (!(gomp_get_icv_flag (list->flags, GOMP_ICV_BIND)))\n+\t    break;\n+\t  sprintf (dev_num, \"%d\", list->device_num);\n+\t  print_proc_bind (list->icvs.bind_var, list->icvs.bind_var_list_len,\n+\t\t\t   &list->icvs.bind_var_list, dev_num);\n+\t  break;\n+\tcase GOMP_ICV_WAIT_POLICY:\n+\t  if (gomp_get_icv_flag (list->flags, GOMP_ICV_WAIT_POLICY))\n+\t    fprintf (stderr, \"  [%d] OMP_WAIT_POLICY = '%s'\\n\",\n+\t\t     list->device_num,\n+\t\t     list->icvs.wait_policy > 0 ? \"ACTIVE\" : \"PASSIVE\");\n+\t  break;\n+\tcase GOMP_ICV_STACKSIZE:\n+\t  if (gomp_get_icv_flag (list->flags, GOMP_ICV_STACKSIZE))\n+\t    fprintf (stderr, \"  [%d] OMP_STACKSIZE = '%lu'\\n\",\n+\t\t     list->device_num, list->icvs.stacksize);\n+\t  break;\n+\t}\n+      list = list->next;\n+    }\n+}\n+\n+void\n+omp_display_env (int verbose)\n+{\n+  int i;\n+  struct gomp_icv_list *dev\n+    = gomp_get_initial_icv_item (GOMP_DEVICE_NUM_FOR_DEV);\n+  struct gomp_icv_list *all\n+    = gomp_get_initial_icv_item (GOMP_DEVICE_NUM_FOR_ALL);\n+  struct gomp_icv_list *none\n+    = gomp_get_initial_icv_item (GOMP_DEVICE_NUM_FOR_NO_SUFFIX);\n+\n+  fputs (\"\\nOPENMP DISPLAY ENVIRONMENT BEGIN\\n\", stderr);\n+\n+  fputs (\"  _OPENMP = '201511'\\n\", stderr);\n+\n+  fprintf (stderr, \"  [host] OMP_DYNAMIC = '%s'\\n\",\n+\t   none->icvs.dyn_var ? \"TRUE\" : \"FALSE\");\n+  if (all != NULL && gomp_get_icv_flag (all->flags, GOMP_ICV_DYNAMIC))\n+    fprintf (stderr, \"  [all] OMP_DYNAMIC = '%s'\\n\",\n+\t     all->icvs.dyn_var ? \"TRUE\" : \"FALSE\");\n+  if (dev != NULL && gomp_get_icv_flag (dev->flags, GOMP_ICV_DYNAMIC))\n+    fprintf (stderr, \"  [device] OMP_DYNAMIC = '%s'\\n\",\n+\t     dev->icvs.dyn_var ? \"TRUE\" : \"FALSE\");\n+  print_device_specific_icvs (GOMP_ICV_DYNAMIC);\n+\n+  /* The OMP_NESTED environment variable has been deprecated.  */\n+  fprintf (stderr, \"  [host] OMP_NESTED = '%s'\\n\",\n+\t   none->icvs.max_active_levels_var > 1 ? \"TRUE\" : \"FALSE\");\n+\n+  fprintf (stderr, \"  [host] OMP_NUM_THREADS = '%lu\",\n+\t   none->icvs.nthreads_var);\n+  for (i = 1; i < none->icvs.nthreads_var_list_len; i++)\n+    fprintf (stderr, \",%lu\", none->icvs.nthreads_var_list[i]);\n+  fputs (\"'\\n\", stderr);\n+  if (all != NULL && gomp_get_icv_flag (all->flags, GOMP_ICV_NTHREADS))\n+    {\n+      fprintf (stderr, \"  [all] OMP_NUM_THREADS = '%lu\",\n+\t       all->icvs.nthreads_var);\n+      for (i = 1; i < all->icvs.nthreads_var_list_len; i++)\n+\tfprintf (stderr, \",%lu\", all->icvs.nthreads_var_list[i]);\n+      fputs (\"'\\n\", stderr);\n+    }\n+  if (dev != NULL && gomp_get_icv_flag (dev->flags, GOMP_ICV_NTHREADS))\n+    {\n+      fprintf (stderr, \"  [device] OMP_NUM_THREADS = '%lu\",\n+\t       dev->icvs.nthreads_var);\n+      for (i = 1; i < dev->icvs.nthreads_var_list_len; i++)\n+\tfprintf (stderr, \",%lu\", dev->icvs.nthreads_var_list[i]);\n+      fputs (\"'\\n\", stderr);\n+    }\n+  print_device_specific_icvs (GOMP_ICV_NTHREADS);\n+\n+\n+  print_schedule (none->icvs.run_sched_var,\n+\t\t  none->icvs.run_sched_chunk_size, \"host\");\n+  if (all != NULL && gomp_get_icv_flag (all->flags, GOMP_ICV_SCHEDULE))\n+    print_schedule (all->icvs.run_sched_var,\n+\t\t    all->icvs.run_sched_chunk_size, \"all\");\n+  if (dev != NULL && gomp_get_icv_flag (dev->flags, GOMP_ICV_SCHEDULE))\n+    print_schedule (dev->icvs.run_sched_var,\n+\t\t    dev->icvs.run_sched_chunk_size, \"device\");\n+  print_device_specific_icvs (GOMP_ICV_SCHEDULE);\n+\n+  print_proc_bind (none->icvs.bind_var,\n+\t\t   none->icvs.bind_var_list_len,\n+\t\t   &none->icvs.bind_var_list, \"host\");\n+  if (all != NULL && gomp_get_icv_flag (all->flags, GOMP_ICV_BIND))\n+    print_proc_bind (all->icvs.bind_var,\n+\t\t     all->icvs.bind_var_list_len,\n+\t\t     &all->icvs.bind_var_list, \"all\");\n+  if (dev != NULL && gomp_get_icv_flag (dev->flags, GOMP_ICV_BIND))\n+    print_proc_bind (dev->icvs.bind_var,\n+\t\t     dev->icvs.bind_var_list_len,\n+\t\t     &dev->icvs.bind_var_list, \"device\");\n+  print_device_specific_icvs (GOMP_ICV_BIND);\n+\n+  fputs (\"  [host] OMP_PLACES = '\", stderr);\n   for (i = 0; i < gomp_places_list_len; i++)\n     {\n       fputs (\"{\", stderr);\n@@ -1347,30 +1687,85 @@ omp_display_env (int verbose)\n     }\n   fputs (\"'\\n\", stderr);\n \n-  fprintf (stderr, \"  OMP_STACKSIZE = '%lu'\\n\", stacksize);\n+  fprintf (stderr, \"  [host] OMP_STACKSIZE = '%lu'\\n\",\n+\t   none->icvs.stacksize);\n+  if (all != NULL && gomp_get_icv_flag (all->flags, GOMP_ICV_STACKSIZE))\n+    fprintf (stderr, \"  [all] OMP_STACKSIZE = '%lu'\\n\",\n+\t     all->icvs.stacksize);\n+  if (dev != NULL && gomp_get_icv_flag (dev->flags, GOMP_ICV_STACKSIZE))\n+    fprintf (stderr, \"  [device] OMP_STACKSIZE = '%lu'\\n\",\n+\t     dev->icvs.stacksize);\n+  print_device_specific_icvs (GOMP_ICV_STACKSIZE);\n \n   /* GOMP's default value is actually neither active nor passive.  */\n-  fprintf (stderr, \"  OMP_WAIT_POLICY = '%s'\\n\",\n-\t   wait_policy > 0 ? \"ACTIVE\" : \"PASSIVE\");\n-  fprintf (stderr, \"  OMP_THREAD_LIMIT = '%u'\\n\",\n-\t   gomp_global_icv.thread_limit_var);\n-  fprintf (stderr, \"  OMP_MAX_ACTIVE_LEVELS = '%u'\\n\",\n-\t   gomp_global_icv.max_active_levels_var);\n-  fprintf (stderr, \"  OMP_NUM_TEAMS = '%u'\\n\", gomp_nteams_var);\n-  fprintf (stderr, \"  OMP_TEAMS_THREAD_LIMIT = '%u'\\n\",\n-\t   gomp_teams_thread_limit_var);\n-\n-  fprintf (stderr, \"  OMP_CANCELLATION = '%s'\\n\",\n+  fprintf (stderr, \"  [host] OMP_WAIT_POLICY = '%s'\\n\",\n+\t   none->icvs.wait_policy > 0 ? \"ACTIVE\" : \"PASSIVE\");\n+  if (all != NULL && gomp_get_icv_flag (all->flags, GOMP_ICV_WAIT_POLICY))\n+    fprintf (stderr, \"  [all] OMP_WAIT_POLICY = '%s'\\n\",\n+\t     all->icvs.wait_policy > 0 ? \"ACTIVE\" : \"PASSIVE\");\n+  if (dev != NULL && gomp_get_icv_flag (dev->flags, GOMP_ICV_WAIT_POLICY))\n+    fprintf (stderr, \"  [device] OMP_WAIT_POLICY = '%s'\\n\",\n+\t     dev->icvs.wait_policy > 0 ? \"ACTIVE\" : \"PASSIVE\");\n+  print_device_specific_icvs (GOMP_ICV_WAIT_POLICY);\n+\n+  fprintf (stderr, \"  [host] OMP_THREAD_LIMIT = '%u'\\n\",\n+\t   none->icvs.thread_limit_var);\n+  if (all != NULL && gomp_get_icv_flag (all->flags, GOMP_ICV_THREAD_LIMIT))\n+    fprintf (stderr, \"  [all] OMP_THREAD_LIMIT = '%d'\\n\",\n+\t     all->icvs.thread_limit_var);\n+  if (dev != NULL && gomp_get_icv_flag (dev->flags, GOMP_ICV_THREAD_LIMIT))\n+    fprintf (stderr, \"  [device] OMP_THREAD_LIMIT = '%d'\\n\",\n+\t     dev->icvs.thread_limit_var);\n+  print_device_specific_icvs (GOMP_ICV_THREAD_LIMIT);\n+\n+  fprintf (stderr, \"  [host] OMP_MAX_ACTIVE_LEVELS = '%u'\\n\",\n+\t   none->icvs.max_active_levels_var);\n+  if (all != NULL && gomp_get_icv_flag (all->flags,\n+\t\t\t GOMP_ICV_MAX_ACTIVE_LEVELS))\n+    fprintf (stderr, \"  [all] OMP_MAX_ACTIVE_LEVELS = '%u'\\n\",\n+\t     all->icvs.max_active_levels_var);\n+  if (dev != NULL && gomp_get_icv_flag (dev->flags,\n+\t\t\t GOMP_ICV_MAX_ACTIVE_LEVELS))\n+    fprintf (stderr, \"  [device] OMP_MAX_ACTIVE_LEVELS = '%u'\\n\",\n+\t     dev->icvs.max_active_levels_var);\n+  print_device_specific_icvs (GOMP_ICV_MAX_ACTIVE_LEVELS);\n+\n+\n+  fprintf (stderr, \"  [host] OMP_NUM_TEAMS = '%d'\\n\",\n+\t   none->icvs.nteams_var);\n+  if (all != NULL && gomp_get_icv_flag (all->flags, GOMP_ICV_NTEAMS))\n+    fprintf (stderr, \"  [all] OMP_NUM_TEAMS = '%d'\\n\",\n+\t     all->icvs.nteams_var);\n+  if (dev != NULL && gomp_get_icv_flag (dev->flags, GOMP_ICV_NTEAMS))\n+    fprintf (stderr, \"  [device] OMP_NUM_TEAMS = '%d'\\n\",\n+\t     dev->icvs.nteams_var);\n+  print_device_specific_icvs (GOMP_ICV_NTEAMS);\n+\n+  fprintf (stderr, \"  [host] OMP_TEAMS_THREAD_LIMIT = '%u'\\n\",\n+\t   none->icvs.teams_thread_limit_var);\n+  if (all != NULL && gomp_get_icv_flag (all->flags,\n+\t\t\t GOMP_ICV_TEAMS_THREAD_LIMIT))\n+    fprintf (stderr, \"  [all] OMP_TEAMS_THREAD_LIMIT = '%u'\\n\",\n+\t     all->icvs.teams_thread_limit_var);\n+  if (dev != NULL && gomp_get_icv_flag (dev->flags,\n+\t\t\t GOMP_ICV_TEAMS_THREAD_LIMIT))\n+    fprintf (stderr, \"  [device] OMP_TEAMS_THREAD_LIMIT = '%u'\\n\",\n+\t     dev->icvs.teams_thread_limit_var);\n+  print_device_specific_icvs (GOMP_ICV_TEAMS_THREAD_LIMIT);\n+\n+  fprintf (stderr, \"  [all] OMP_CANCELLATION = '%s'\\n\",\n \t   gomp_cancel_var ? \"TRUE\" : \"FALSE\");\n-  fprintf (stderr, \"  OMP_DEFAULT_DEVICE = '%d'\\n\",\n-\t   gomp_global_icv.default_device_var);\n-  fprintf (stderr, \"  OMP_MAX_TASK_PRIORITY = '%d'\\n\",\n+\n+  fprintf (stderr, \"  [all] OMP_DEFAULT_DEVICE = '%d'\\n\",\n+\t   none->icvs.default_device_var);\n+\n+  fprintf (stderr, \"  [all] OMP_MAX_TASK_PRIORITY = '%d'\\n\",\n \t   gomp_max_task_priority_var);\n-  fprintf (stderr, \"  OMP_DISPLAY_AFFINITY = '%s'\\n\",\n+  fprintf (stderr, \"  [all] OMP_DISPLAY_AFFINITY = '%s'\\n\",\n \t   gomp_display_affinity_var ? \"TRUE\" : \"FALSE\");\n-  fprintf (stderr, \"  OMP_AFFINITY_FORMAT = '%s'\\n\",\n+  fprintf (stderr, \"  [host] OMP_AFFINITY_FORMAT = '%s'\\n\",\n \t   gomp_affinity_format_var);\n-  fprintf (stderr, \"  OMP_ALLOCATOR = '\");\n+  fprintf (stderr, \"  [host] OMP_ALLOCATOR = '\");\n   switch (gomp_def_allocator)\n     {\n #define C(v) case v: fputs (#v, stderr); break;\n@@ -1387,7 +1782,7 @@ omp_display_env (int verbose)\n     }\n   fputs (\"'\\n\", stderr);\n \n-  fputs (\"  OMP_TARGET_OFFLOAD = '\", stderr);\n+  fputs (\"  [all] OMP_TARGET_OFFLOAD = '\", stderr);\n   switch (gomp_target_offload_var)\n     {\n     case GOMP_TARGET_OFFLOAD_DEFAULT:\n@@ -1404,13 +1799,13 @@ omp_display_env (int verbose)\n \n   if (verbose)\n     {\n-      fputs (\"  GOMP_CPU_AFFINITY = ''\\n\", stderr);\n-      fprintf (stderr, \"  GOMP_STACKSIZE = '%lu'\\n\", stacksize);\n+      fputs (\"  [host] GOMP_CPU_AFFINITY = ''\\n\", stderr);\n+      fprintf (stderr, \"  [host] GOMP_STACKSIZE = '%lu'\\n\", stacksize);\n #ifdef HAVE_INTTYPES_H\n-      fprintf (stderr, \"  GOMP_SPINCOUNT = '%\"PRIu64\"'\\n\",\n+      fprintf (stderr, \"  [host] GOMP_SPINCOUNT = '%\"PRIu64\"'\\n\",\n \t       (uint64_t) gomp_spin_count_var);\n #else\n-      fprintf (stderr, \"  GOMP_SPINCOUNT = '%lu'\\n\",\n+      fprintf (stderr, \"  [host] GOMP_SPINCOUNT = '%lu'\\n\",\n \t       (unsigned long) gomp_spin_count_var);\n #endif\n     }\n@@ -1459,65 +1854,370 @@ handle_omp_display_env (void)\n     ialias_call (omp_display_env) (verbose);\n }\n \n+/* Helper function for initialize_env.  Extracts the device number from\n+   an environment variable name.  ENV is the complete environment variable.\n+   DEV_NUM_PTR points to the start of the device number in the environment\n+   variable string.  DEV_NUM_LEN is the returned length of the device num\n+   string.  */\n+\n+static bool\n+get_device_num (char *env, char *dev_num_ptr, int *dev_num, int *dev_num_len)\n+{\n+  char *end;\n+  unsigned long val = strtoul (dev_num_ptr, &end, 10);\n+  if (val > INT_MAX\n+      || *end != '='\n+      || (dev_num_ptr[0] == '0' && end != dev_num_ptr + 1)\n+      || (dev_num_ptr[0] < '0' || dev_num_ptr[0] > '9'))\n+    {\n+      gomp_error (\"Invalid device number in %s\", env);\n+      return false;\n+    }\n+  *dev_num = val;\n+  *dev_num_len = end - dev_num_ptr;\n+  return true;\n+}\n+\n+static void\n+get_icv_member_addr (struct gomp_initial_icvs *icvs, int icv_code,\n+\t\t     void *icv_addr[3])\n+{\n+  if (icv_code == 0 || icv_addr == NULL)\n+    return;\n+\n+  icv_addr[0] = icv_addr[1] = icv_addr[2] = NULL;\n+\n+  switch (icv_code)\n+    {\n+    case GOMP_ICV_NTEAMS:\n+      icv_addr[0] = &icvs->nteams_var;\n+      icv_addr[1] = false;\n+      break;\n+    case GOMP_ICV_DYNAMIC:\n+      icv_addr[0] = &(*icvs).dyn_var;\n+      break;\n+    case GOMP_ICV_TEAMS_THREAD_LIMIT:\n+      icv_addr[0] = &icvs->teams_thread_limit_var;\n+      icv_addr[1] = false;\n+      break;\n+    case GOMP_ICV_SCHEDULE:\n+      icv_addr[0] = &icvs->run_sched_var;\n+      icv_addr[1] = &icvs->run_sched_chunk_size;\n+      break;\n+    case GOMP_ICV_THREAD_LIMIT:\n+      icv_addr[0] = &icvs->thread_limit_var;\n+      icv_addr[1] = false;\n+      icv_addr[2] = (void *) UINT_MAX;\n+      break;\n+    case GOMP_ICV_NTHREADS:\n+      icv_addr[0] = &icvs->nthreads_var;\n+      icv_addr[1] = &icvs->nthreads_var_list;\n+      icv_addr[2] = &icvs->nthreads_var_list_len;\n+      break;\n+    case GOMP_ICV_MAX_ACTIVE_LEVELS:\n+      icv_addr[0] = &icvs->max_active_levels_var;\n+      icv_addr[1] = (void *) true;\n+      icv_addr[2] = (void *) gomp_supported_active_levels;\n+      break;\n+    case GOMP_ICV_BIND:\n+      icv_addr[0] = &icvs->bind_var;\n+      icv_addr[1] = &icvs->bind_var_list;\n+      icv_addr[2] = &icvs->bind_var_list_len;\n+      break;\n+    case GOMP_ICV_WAIT_POLICY:\n+      icv_addr[0] = &icvs->wait_policy;\n+      break;\n+    case GOMP_ICV_STACKSIZE:\n+      icv_addr[0] = &icvs->stacksize;\n+      break;\n+    case GOMP_ICV_CANCELLATION:\n+      icv_addr[0] = &gomp_cancel_var;\n+      break;\n+    case GOMP_ICV_DISPLAY_AFFINITY:\n+      icv_addr[0] = &gomp_display_affinity_var;\n+      break;\n+    case GOMP_ICV_TARGET_OFFLOAD:\n+      icv_addr[0] = &gomp_target_offload_var;\n+      break;\n+    case GOMP_ICV_MAX_TASK_PRIORITY:\n+      icv_addr[0] = &gomp_max_task_priority_var;\n+      break;\n+    case GOMP_ICV_ALLOCATOR:\n+      icv_addr[0] = &gomp_def_allocator;\n+      break;\n+    case GOMP_ICV_DEFAULT_DEVICE:\n+      icv_addr[0] = &icvs->default_device_var;\n+      icv_addr[1] = (void *) true;\n+      break;\n+    }\n+}\n+\n+struct gomp_icv_list *\n+gomp_get_initial_icv_item (int dev_num)\n+{\n+  struct gomp_icv_list *l = gomp_initial_icv_list;\n+  while (l != NULL && l->device_num != dev_num)\n+    l = l->next;\n+\n+  return l;\n+}\n+\n+static void\n+initialize_icvs (struct gomp_initial_icvs *icvs)\n+{\n+  icvs->nthreads_var_list = NULL;\n+  icvs->bind_var_list = NULL;\n+  icvs->nthreads_var = gomp_default_icv_values.nthreads_var;\n+  icvs->nthreads_var_list_len = 0;\n+  icvs->bind_var_list_len = 0;\n+  icvs->stacksize = 0;\n+  icvs->thread_limit_var = gomp_default_icv_values.thread_limit_var;\n+  icvs->run_sched_var = gomp_default_icv_values.run_sched_var;\n+  icvs->run_sched_chunk_size = gomp_default_icv_values.run_sched_chunk_size;\n+  icvs->default_device_var = gomp_default_icv_values.default_device_var;\n+  icvs->dyn_var = gomp_default_icv_values.dyn_var;\n+  icvs->max_active_levels_var = gomp_default_icv_values.max_active_levels_var;\n+  icvs->bind_var = gomp_default_icv_values.bind_var;\n+  icvs->nteams_var = gomp_default_icv_values.nteams_var;\n+  icvs->teams_thread_limit_var = gomp_default_icv_values.teams_thread_limit_var;\n+  icvs->wait_policy = 0;\n+}\n+\n+/* Helper function for initialize_env to add a device specific ICV value\n+   to gomp_initial_icv_list.  */\n+\n+static uint32_t *\n+add_initial_icv_to_list (int dev_num, int icv_code, void *icv_addr[3])\n+{\n+  struct gomp_icv_list *last = NULL, *l = gomp_initial_icv_list;\n+  while (l != NULL && l->device_num != dev_num)\n+    {\n+      last = l;\n+      l = l->next;\n+    }\n+\n+  if (l == NULL)\n+    {\n+      l = ((struct gomp_icv_list *)\n+\t   gomp_malloc_cleared (sizeof (struct gomp_icv_list)));\n+      l->device_num = dev_num;\n+      initialize_icvs (&l->icvs);\n+      if (dev_num < 0)\n+\t{\n+\t  l->next = gomp_initial_icv_list;\n+\t  gomp_initial_icv_list = l;\n+\t}\n+      else\n+\t{\n+\t  l->next = NULL;\n+\t  if (last == NULL)\n+\t    gomp_initial_icv_list = l;\n+\t  else\n+\t    last->next = l;\n+\t}\n+    }\n+\n+  get_icv_member_addr (&l->icvs, icv_code, icv_addr);\n+\n+  return &l->flags;\n+}\n+\n+/* Return true if STR string starts with PREFIX.  */\n+\n+static inline bool\n+startswith (const char *str, const char *prefix)\n+{\n+  return strncmp (str, prefix, strlen (prefix)) == 0;\n+}\n \n static void __attribute__((constructor))\n initialize_env (void)\n {\n-  unsigned long thread_limit_var;\n-  unsigned long max_active_levels_var;\n+  extern char **environ;\n+  char **env;\n+  int omp_var, dev_num = 0, dev_num_len = 0, i;\n+  bool ignore = false;\n+  char *env_val;\n+  void *params[3];\n+  uint32_t *flag_var_addr = NULL;\n+  unsigned pos;\n+  struct gomp_icv_list *all, *none;\n \n   /* Do a compile time check that mkomp_h.pl did good job.  */\n   omp_check_defines ();\n \n-  parse_schedule ();\n-  parse_boolean (\"OMP_DYNAMIC\", &gomp_global_icv.dyn_var);\n-  parse_boolean (\"OMP_CANCELLATION\", &gomp_cancel_var);\n-  parse_boolean (\"OMP_DISPLAY_AFFINITY\", &gomp_display_affinity_var);\n-  parse_int (\"OMP_DEFAULT_DEVICE\", &gomp_global_icv.default_device_var, true);\n-  parse_target_offload (\"OMP_TARGET_OFFLOAD\", &gomp_target_offload_var);\n-  parse_int (\"OMP_MAX_TASK_PRIORITY\", &gomp_max_task_priority_var, true);\n-  gomp_def_allocator = parse_allocator ();\n-  if (parse_unsigned_long (\"OMP_THREAD_LIMIT\", &thread_limit_var, false))\n-    {\n-      gomp_global_icv.thread_limit_var\n-\t= thread_limit_var > INT_MAX ? UINT_MAX : thread_limit_var;\n-    }\n-  parse_int_secure (\"GOMP_DEBUG\", &gomp_debug_var, true);\n #ifndef HAVE_SYNC_BUILTINS\n   gomp_mutex_init (&gomp_managed_threads_lock);\n #endif\n   gomp_init_num_threads ();\n   gomp_available_cpus = gomp_global_icv.nthreads_var;\n-  if (!parse_unsigned_long_list (\"OMP_NUM_THREADS\",\n-\t\t\t\t &gomp_global_icv.nthreads_var,\n-\t\t\t\t &gomp_nthreads_var_list,\n-\t\t\t\t &gomp_nthreads_var_list_len))\n-    gomp_global_icv.nthreads_var = gomp_available_cpus;\n-  parse_int (\"OMP_NUM_TEAMS\", &gomp_nteams_var, false);\n-  parse_int (\"OMP_TEAMS_THREAD_LIMIT\", &gomp_teams_thread_limit_var, false);\n-  bool ignore = false;\n-  if (parse_bind_var (\"OMP_PROC_BIND\",\n-\t\t      &gomp_global_icv.bind_var,\n-\t\t      &gomp_bind_var_list,\n-\t\t      &gomp_bind_var_list_len)\n+\n+  /* Initial values for host environment variables should always exist even if\n+     there is no explicitly set host environment variable.  Moreover, they are\n+     set to the initial global values.  */\n+  add_initial_icv_to_list (GOMP_DEVICE_NUM_FOR_NO_SUFFIX, 0, NULL);\n+  none = gomp_get_initial_icv_item (GOMP_DEVICE_NUM_FOR_NO_SUFFIX);\n+  initialize_icvs (&none->icvs);\n+\n+  for (env = environ; *env != 0; env++)\n+    {\n+      if (!startswith (*env, \"OMP_\"))\n+\tcontinue;\n+\n+     /* Name of the environment variable without suffix \"OMP_\".  */\n+     char *name = *env + sizeof (\"OMP_\") - 1;\n+     for (omp_var = 0; omp_var < OMP_VAR_CNT; omp_var++)\n+\t{\n+\t  if (startswith (name, envvars[omp_var].name))\n+\t    {\n+\t      pos = envvars[omp_var].name_len;\n+\t      if (name[pos] == '=')\n+\t\t{\n+\t\t  pos++;\n+\t\t  flag_var_addr\n+\t\t    = add_initial_icv_to_list (GOMP_DEVICE_NUM_FOR_NO_SUFFIX,\n+\t\t\t\t\t       envvars[omp_var].flag_vars[0],\n+\t\t\t\t\t       params);\n+\t\t}\n+\t      else if (startswith (&name[pos], \"_DEV=\")\n+\t\t       && envvars[omp_var].flag & GOMP_ENV_SUFFIX_DEV)\n+\t\t{\n+\t\t  pos += 5;\n+\t\t  flag_var_addr\n+\t\t    = add_initial_icv_to_list (GOMP_DEVICE_NUM_FOR_DEV,\n+\t\t\t\t\t       envvars[omp_var].flag_vars[0],\n+\t\t\t\t\t       params);\n+\t\t}\n+\t      else if (startswith (&name[pos], \"_ALL=\")\n+\t\t       && envvars[omp_var].flag & GOMP_ENV_SUFFIX_ALL)\n+\t\t{\n+\t\t  pos += 5;\n+\t\t  flag_var_addr\n+\t\t    = add_initial_icv_to_list (GOMP_DEVICE_NUM_FOR_ALL,\n+\t\t\t\t\t       envvars[omp_var].flag_vars[0],\n+\t\t\t\t\t       params);\n+\t\t}\n+\t      else if (startswith (&name[pos], \"_DEV_\")\n+\t\t       && envvars[omp_var].flag & GOMP_ENV_SUFFIX_DEV_X)\n+\t\t{\n+\t\t  pos += 5;\n+\t\t  if (!get_device_num (*env, &name[pos], &dev_num,\n+\t\t\t\t       &dev_num_len))\n+\t\t    break;\n+\n+\t\t  pos += dev_num_len + 1;\n+\t\t  flag_var_addr\n+\t\t    = add_initial_icv_to_list (dev_num,\n+\t\t\t\t\t       envvars[omp_var].flag_vars[0],\n+\t\t\t\t\t       params);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  gomp_error (\"Invalid environment variable in %s\", *env);\n+\t\t  break;\n+\t\t}\n+\t      env_val = &name[pos];\n+\n+\t      if (envvars[omp_var].parse_func (*env, env_val, params))\n+\t\t{\n+\t\t  for (i = 0; i < 3; ++i)\n+\t\t    if (envvars[omp_var].flag_vars[i])\n+\t\t      gomp_set_icv_flag (flag_var_addr,\n+\t\t\t\t\t envvars[omp_var].flag_vars[i]);\n+\t\t    else\n+\t\t      break;\n+\t\t}\n+\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+    all = gomp_get_initial_icv_item (GOMP_DEVICE_NUM_FOR_ALL);\n+    for (omp_var = 0; omp_var < OMP_HOST_VAR_CNT; omp_var++)\n+      {\n+\tif (none != NULL\n+\t    && gomp_get_icv_flag (none->flags, host_envvars[omp_var].flag_var))\n+\t  get_icv_member_addr (&none->icvs,\n+\t\t\t       host_envvars[omp_var].flag_var, params);\n+\telse if (all != NULL\n+\t\t && gomp_get_icv_flag (all->flags,\n+\t\t\t\t       host_envvars[omp_var].flag_var))\n+\t  get_icv_member_addr (&all->icvs, host_envvars[omp_var].flag_var,\n+\t\t\t       params);\n+\telse\n+\t  continue;\n+\n+\tswitch (host_envvars[omp_var].type_code)\n+\t  {\n+\t  case PARSE_INT:\n+\t    for (i = 0; i < 3; ++i)\n+\t      if (host_envvars[omp_var].dest[i] != NULL && params[i] != NULL)\n+\t\t*(int *) (host_envvars[omp_var].dest[i]) = *(int *) params[i];\n+\t    break;\n+\t  case PARSE_BOOL:\n+\t    for (i = 0; i < 3; ++i)\n+\t      if (host_envvars[omp_var].dest[i] != NULL && params[i] != NULL)\n+\t\t*(bool *) (host_envvars[omp_var].dest[i]) = *(bool *) params[i];\n+\t    break;\n+\t  case PARSE_UINT:\n+\t    for (i = 0; i < 3; ++i)\n+\t      if (host_envvars[omp_var].dest[i] != NULL && params[i] != NULL)\n+\t\t*(unsigned int *) (host_envvars[omp_var].dest[i])\n+\t\t  = *(unsigned int *) params[i];\n+\t    break;\n+\t  case PARSE_ULONG:\n+\t    for (i = 0; i < 3; ++i)\n+\t      if (host_envvars[omp_var].dest[i] != NULL && params[i] != NULL)\n+\t\t*(unsigned long *) (host_envvars[omp_var].dest[i])\n+\t\t  = *(unsigned long *) params[i];\n+\t    break;\n+\t  case PARSE_UCHAR:\n+\t    for (i = 0; i < 3; ++i)\n+\t      if (host_envvars[omp_var].dest[i] != NULL && params[i] != NULL)\n+\t\t*(unsigned char *) (host_envvars[omp_var].dest[i])\n+\t\t  = *(unsigned char *) params[i];\n+\t    break;\n+\t  case PARSE_SCHEDULE:\n+\t    *(enum gomp_schedule_type *) (host_envvars[omp_var].dest[0])\n+\t      = *(enum gomp_schedule_type *) params[0];\n+\t    *(int *) (host_envvars[omp_var].dest[1]) = *(int *) params[1];\n+\t    break;\n+\t  case PARSE_BIND:\n+\t    *(char *) (host_envvars[omp_var].dest[0])\n+\t\t  = *(char *) params[0];\n+\t    *(char *) (host_envvars[omp_var].dest[1])\n+\t\t  = *(char *) params[1];\n+\t    *(unsigned long *) (host_envvars[omp_var].dest[2])\n+\t\t  = *(unsigned long *) params[2];\n+\t    break;\n+\t  }\n+      }\n+\n+  if (((none != NULL && gomp_get_icv_flag (none->flags, GOMP_ICV_BIND))\n+       || (all != NULL && gomp_get_icv_flag (all->flags, GOMP_ICV_BIND)))\n       && gomp_global_icv.bind_var == omp_proc_bind_false)\n     ignore = true;\n-  if (parse_unsigned_long (\"OMP_MAX_ACTIVE_LEVELS\",\n-\t\t\t   &max_active_levels_var, true))\n-    gomp_global_icv.max_active_levels_var\n-      = (max_active_levels_var > gomp_supported_active_levels)\n-\t? gomp_supported_active_levels : max_active_levels_var;\n-  else\n+\n+  if (!((none != NULL\n+\t && gomp_get_icv_flag (none->flags, GOMP_ICV_MAX_ACTIVE_LEVELS))\n+       || (all != NULL\n+\t   && gomp_get_icv_flag (all->flags, GOMP_ICV_MAX_ACTIVE_LEVELS))))\n     {\n       bool nested = true;\n+      const char *env = getenv (\"OMP_NESTED\");\n \n       /* OMP_NESTED is deprecated in OpenMP 5.0.  */\n-      if (parse_boolean (\"OMP_NESTED\", &nested))\n+      if (parse_boolean (\"OMP_NESTED\", env, (void *[]) {&nested}))\n \tgomp_global_icv.max_active_levels_var\n \t  = nested ? gomp_supported_active_levels : 1;\n       else if (gomp_nthreads_var_list_len > 1 || gomp_bind_var_list_len > 1)\n \tgomp_global_icv.max_active_levels_var = gomp_supported_active_levels;\n     }\n+\n+  /* Process GOMP_* variables and dependencies between parsed ICVs.  */\n+  parse_int_secure (\"GOMP_DEBUG\", &gomp_debug_var, true);\n+\n   /* Make sure OMP_PLACES and GOMP_CPU_AFFINITY env vars are always\n      parsed if present in the environment.  If OMP_PROC_BIND was set\n      explicitly to false, don't populate places list though.  If places\n@@ -1547,7 +2247,11 @@ initialize_env (void)\n       gomp_set_affinity_format (env, strlen (env));\n   }\n \n-  wait_policy = parse_wait_policy ();\n+  if (none != NULL && gomp_get_icv_flag (none->flags, GOMP_ICV_WAIT_POLICY))\n+    wait_policy = none->icvs.wait_policy;\n+  else if (all != NULL && gomp_get_icv_flag (all->flags, GOMP_ICV_WAIT_POLICY))\n+    wait_policy = all->icvs.wait_policy;\n+\n   if (!parse_spincount (\"GOMP_SPINCOUNT\", &gomp_spin_count_var))\n     {\n       /* Using a rough estimation of 100000 spins per msec,\n@@ -1573,8 +2277,21 @@ initialize_env (void)\n   /* Not strictly environment related, but ordering constructors is tricky.  */\n   pthread_attr_init (&gomp_thread_attr);\n \n-  if (parse_stacksize (\"OMP_STACKSIZE\", &stacksize)\n-      || parse_stacksize (\"GOMP_STACKSIZE\", &stacksize)\n+  if (!(none != NULL && gomp_get_icv_flag (none->flags, GOMP_ICV_STACKSIZE)))\n+    {\n+      const char *env = getenv (\"GOMP_STACKSIZE\");\n+      if (env != NULL\n+\t  && parse_stacksize (\"GOMP_STACKSIZE\", env,\n+\t\t\t      (void *[3]) {&none->icvs.stacksize}))\n+\tgomp_set_icv_flag (&none->flags, GOMP_ICV_STACKSIZE);\n+    }\n+  if (none != NULL && gomp_get_icv_flag (none->flags, GOMP_ICV_STACKSIZE))\n+    stacksize = none->icvs.stacksize;\n+  else if (all != NULL && gomp_get_icv_flag (all->flags, GOMP_ICV_STACKSIZE))\n+    stacksize = all->icvs.stacksize;\n+\n+  if ((none != NULL && gomp_get_icv_flag (none->flags, GOMP_ICV_STACKSIZE))\n+      || (all != NULL && gomp_get_icv_flag (all->flags, GOMP_ICV_STACKSIZE))\n       || GOMP_DEFAULT_STACKSIZE)\n     {\n       int err;\n@@ -1601,7 +2318,8 @@ initialize_env (void)\n \n   /* OpenACC.  */\n \n-  if (!parse_int (\"ACC_DEVICE_NUM\", &goacc_device_num, true))\n+  if (!parse_int (\"ACC_DEVICE_NUM\", getenv (\"ACC_DEVICE_NUM\"),\n+\t\t  (void *[]) {&goacc_device_num, (void *) true}))\n     goacc_device_num = 0;\n \n   parse_acc_device_type ();"}, {"sha": "d8acf0e5444864b46a277e4318bc4af937cc599a", "filename": "libgomp/icv-device.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Ficv-device.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Ficv-device.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ficv-device.c?ref=9f2fca56593a2b87026b399d26adcdca90705685", "patch": "@@ -80,3 +80,20 @@ omp_get_device_num (void)\n }\n \n ialias (omp_get_device_num)\n+\n+int\n+omp_get_max_teams (void)\n+{\n+  return gomp_nteams_var;\n+}\n+\n+ialias (omp_get_max_teams)\n+\n+void\n+omp_set_num_teams (int num_teams)\n+{\n+  if (num_teams >= 0)\n+    gomp_nteams_var = num_teams;\n+}\n+\n+ialias (omp_set_num_teams)"}, {"sha": "df423c0651041b62b40fa152e1ab86765f514a5c", "filename": "libgomp/icv.c", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Ficv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Ficv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ficv.c?ref=9f2fca56593a2b87026b399d26adcdca90705685", "patch": "@@ -148,19 +148,6 @@ omp_get_supported_active_levels (void)\n   return gomp_supported_active_levels;\n }\n \n-void\n-omp_set_num_teams (int num_teams)\n-{\n-  if (num_teams >= 0)\n-    gomp_nteams_var = num_teams;\n-}\n-\n-int\n-omp_get_max_teams (void)\n-{\n-  return gomp_nteams_var;\n-}\n-\n void\n omp_set_teams_thread_limit (int thread_limit)\n {\n@@ -274,8 +261,6 @@ ialias (omp_get_thread_limit)\n ialias (omp_set_max_active_levels)\n ialias (omp_get_max_active_levels)\n ialias (omp_get_supported_active_levels)\n-ialias (omp_set_num_teams)\n-ialias (omp_get_max_teams)\n ialias (omp_set_teams_thread_limit)\n ialias (omp_get_teams_thread_limit)\n ialias (omp_get_cancellation)"}, {"sha": "71a307f47eb082bffafa70dd0e59d1be73a78117", "filename": "libgomp/libgomp-plugin.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Flibgomp-plugin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Flibgomp-plugin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp-plugin.h?ref=9f2fca56593a2b87026b399d26adcdca90705685", "patch": "@@ -102,11 +102,11 @@ struct addr_pair\n   uintptr_t end;\n };\n \n-/* This symbol is to name a target side variable that holds the designated\n-   'device number' of the target device. The symbol needs to be available to\n-   libgomp code and the offload plugin (which in the latter case must be\n-   stringified).  */\n-#define GOMP_DEVICE_NUM_VAR __gomp_device_num\n+/* This following symbol is used to name the target side variable struct that\n+   holds the designated ICVs of the target device. The symbol needs to be\n+   available to libgomp code and the offload plugin (which in the latter case\n+   must be stringified).  */\n+#define GOMP_ADDITIONAL_ICVS __gomp_additional_icvs\n \n /* Miscellaneous functions.  */\n extern void *GOMP_PLUGIN_malloc (size_t) __attribute__ ((malloc));"}, {"sha": "75192749dc7ca6c7a80396233cd755d5eb37627a", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=9f2fca56593a2b87026b399d26adcdca90705685", "patch": "@@ -453,6 +453,38 @@ struct gomp_team_state\n \n struct target_mem_desc;\n \n+enum gomp_icvs\n+{\n+   GOMP_ICV_NTEAMS = 1,\n+   GOMP_ICV_SCHEDULE = 2,\n+   GOMP_ICV_SCHEDULE_CHUNK_SIZE = 3,\n+   GOMP_ICV_DYNAMIC = 4,\n+   GOMP_ICV_TEAMS_THREAD_LIMIT = 5,\n+   GOMP_ICV_THREAD_LIMIT = 6,\n+   GOMP_ICV_NTHREADS = 7,\n+   GOMP_ICV_NTHREADS_LIST = 8,\n+   GOMP_ICV_NTHREADS_LIST_LEN = 9,\n+   GOMP_ICV_BIND = 10,\n+   GOMP_ICV_BIND_LIST = 11,\n+   GOMP_ICV_BIND_LIST_LEN = 12,\n+   GOMP_ICV_MAX_ACTIVE_LEVELS = 13,\n+   GOMP_ICV_WAIT_POLICY = 14,\n+   GOMP_ICV_STACKSIZE = 15,\n+   GOMP_ICV_DEFAULT_DEVICE = 16,\n+   GOMP_ICV_CANCELLATION = 17,\n+   GOMP_ICV_DISPLAY_AFFINITY = 18,\n+   GOMP_ICV_TARGET_OFFLOAD = 19,\n+   GOMP_ICV_MAX_TASK_PRIORITY = 20,\n+   GOMP_ICV_ALLOCATOR = 21\n+};\n+\n+enum gomp_device_num\n+{\n+  GOMP_DEVICE_NUM_FOR_DEV = -1,\n+  GOMP_DEVICE_NUM_FOR_ALL = -2,\n+  GOMP_DEVICE_NUM_FOR_NO_SUFFIX = -3\n+};\n+\n /* These are the OpenMP 4.0 Internal Control Variables described in\n    section 2.3.1.  Those described as having one copy per task are\n    stored within the structure; those described as having one copy\n@@ -472,6 +504,80 @@ struct gomp_task_icv\n   struct target_mem_desc *target_data;\n };\n \n+enum gomp_env_suffix\n+{\n+  GOMP_ENV_SUFFIX_UNKNOWN = 0,\n+  GOMP_ENV_SUFFIX_NONE = 1,\n+  GOMP_ENV_SUFFIX_DEV = 2,\n+  GOMP_ENV_SUFFIX_ALL = 4,\n+  GOMP_ENV_SUFFIX_DEV_X = 8\n+};\n+\n+/* Struct that contains all ICVs for which we need to store initial values.\n+   Keeping the initial values is needed for omp_display_env.  Moreover initial\n+   _DEV and _ALL variants of environment variables are also used to determine\n+   actually used values for devices and for the host.  */\n+struct gomp_initial_icvs\n+{\n+  unsigned long *nthreads_var_list;\n+  char *bind_var_list;\n+  unsigned long nthreads_var;\n+  unsigned long nthreads_var_list_len;\n+  unsigned long bind_var_list_len;\n+  unsigned long stacksize;\n+  int run_sched_chunk_size;\n+  int default_device_var;\n+  int nteams_var;\n+  int teams_thread_limit_var;\n+  int wait_policy;\n+  unsigned int thread_limit_var;\n+  enum gomp_schedule_type run_sched_var;\n+  bool dyn_var;\n+  unsigned char max_active_levels_var;\n+  char bind_var;\n+};\n+\n+struct gomp_default_icv\n+{\n+  unsigned long nthreads_var;\n+  enum gomp_schedule_type run_sched_var;\n+  int run_sched_chunk_size;\n+  int default_device_var;\n+  unsigned int thread_limit_var;\n+  int nteams_var;\n+  int teams_thread_limit_var;\n+  bool dyn_var;\n+  unsigned char max_active_levels_var;\n+  char bind_var;\n+};\n+\n+/*  DEVICE_NUM \"-1\" is reserved for \"_DEV\" icvs.\n+    DEVICE_NUM \"-2\" is reserved for \"_ALL\" icvs.\n+    DEVICE_NUM \"-3\" is reserved for ICVs without suffix.\n+    Non-negative DEVICE_NUM is for \"_DEV_X\" icvs.  */\n+struct gomp_icv_list\n+{\n+  int device_num;\n+  uint32_t flags;\n+  struct gomp_initial_icvs icvs;\n+  struct gomp_icv_list *next;\n+};\n+\n+struct gomp_offload_icvs\n+{\n+  int device_num;\n+  int default_device;\n+  int nteams;\n+  int teams_thread_limit;\n+};\n+\n+struct gomp_offload_icv_list\n+{\n+  int device_num;\n+  struct gomp_offload_icvs icvs;\n+  struct gomp_offload_icv_list *next;\n+};\n+\n enum gomp_target_offload_t\n {\n   GOMP_TARGET_OFFLOAD_DEFAULT,\n@@ -503,6 +609,9 @@ extern bool gomp_display_affinity_var;\n extern char *gomp_affinity_format_var;\n extern size_t gomp_affinity_format_len;\n extern uintptr_t gomp_def_allocator;\n+extern const struct gomp_default_icv gomp_default_icv_values;\n+extern struct gomp_icv_list *gomp_initial_icv_list;\n+extern struct gomp_offload_icv_list *gomp_offload_icv_list;\n extern int goacc_device_num;\n extern char *goacc_device_type;\n extern int goacc_default_dims[GOMP_DIM_MAX];\n@@ -927,6 +1036,11 @@ extern void gomp_display_affinity_thread (gomp_thread_handle,\n \t\t\t\t\t  struct gomp_team_state *,\n \t\t\t\t\t  unsigned int) __attribute__((cold));\n \n+/* env.c */\n+\n+extern struct gomp_icv_list *gomp_get_initial_icv_item (int dev_num);\n+extern bool gomp_get_icv_flag (uint32_t value, enum gomp_icvs icv);\n+\n /* iter.c */\n \n extern int gomp_iter_static_next (long *, long *);"}, {"sha": "31ca088e33af0f87740acf909e6bc36e5ed1c699", "filename": "libgomp/libgomp.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Flibgomp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Flibgomp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.texi?ref=9f2fca56593a2b87026b399d26adcdca90705685", "patch": "@@ -284,7 +284,7 @@ The OpenMP 4.5 specification is fully supported.\n @item @code{declare variant}: new clauses @code{adjust_args} and\n       @code{append_args} @tab N @tab\n @item @code{dispatch} construct @tab N @tab\n-@item device-specific ICV settings the environment variables @tab N @tab\n+@item device-specific ICV settings with environment variables @tab Y @tab\n @item @code{assume} directive @tab N @tab\n @item @code{nothing} directive @tab Y @tab\n @item @code{error} directive @tab Y @tab"}, {"sha": "957455a3891978b5ff41ca3e84b77f3525aef596", "filename": "libgomp/plugin/plugin-gcn.c", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Fplugin%2Fplugin-gcn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Fplugin%2Fplugin-gcn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-gcn.c?ref=9f2fca56593a2b87026b399d26adcdca90705685", "patch": "@@ -3367,6 +3367,7 @@ GOMP_OFFLOAD_load_image (int ord, unsigned version, const void *target_data,\n   struct kernel_info *kernel;\n   int kernel_count = image_desc->kernel_count;\n   unsigned var_count = image_desc->global_variable_count;\n+  /* Currently, \"others\" is a struct of ICVS.  */\n   int other_count = 1;\n \n   agent = get_agent_info (ord);\n@@ -3464,36 +3465,40 @@ GOMP_OFFLOAD_load_image (int ord, unsigned version, const void *target_data,\n \t}\n     }\n \n-  GCN_DEBUG (\"Looking for variable %s\\n\", XSTRING (GOMP_DEVICE_NUM_VAR));\n+  GCN_DEBUG (\"Looking for variable %s\\n\", XSTRING (GOMP_ADDITIONAL_ICVS));\n \n   hsa_status_t status;\n   hsa_executable_symbol_t var_symbol;\n   status = hsa_fns.hsa_executable_get_symbol_fn (agent->executable, NULL,\n-\t\t\t\t\t\t XSTRING (GOMP_DEVICE_NUM_VAR),\n+\t\t\t\t\t\t XSTRING (GOMP_ADDITIONAL_ICVS),\n \t\t\t\t\t\t agent->id, 0, &var_symbol);\n   if (status == HSA_STATUS_SUCCESS)\n     {\n-      uint64_t device_num_varptr;\n-      uint32_t device_num_varsize;\n+      uint64_t varptr;\n+      uint32_t varsize;\n \n       status = hsa_fns.hsa_executable_symbol_get_info_fn\n \t(var_symbol, HSA_EXECUTABLE_SYMBOL_INFO_VARIABLE_ADDRESS,\n-\t &device_num_varptr);\n+\t &varptr);\n       if (status != HSA_STATUS_SUCCESS)\n \thsa_fatal (\"Could not extract a variable from its symbol\", status);\n       status = hsa_fns.hsa_executable_symbol_get_info_fn\n \t(var_symbol, HSA_EXECUTABLE_SYMBOL_INFO_VARIABLE_SIZE,\n-\t &device_num_varsize);\n+\t &varsize);\n       if (status != HSA_STATUS_SUCCESS)\n-\thsa_fatal (\"Could not extract a variable size from its symbol\", status);\n+\thsa_fatal (\"Could not extract a variable size from its symbol\",\n+\t\t   status);\n \n-      pair->start = device_num_varptr;\n-      pair->end = device_num_varptr + device_num_varsize;\n+      pair->start = varptr;\n+      pair->end = varptr + varsize;\n     }\n   else\n-    /* The 'GOMP_DEVICE_NUM_VAR' variable was not in this image.  */\n-    pair->start = pair->end = 0;\n-  pair++;\n+    {\n+      /* The variable was not in this image.  */\n+      GCN_DEBUG (\"Variable not found in image: %s\\n\",\n+\t\t XSTRING (GOMP_ADDITIONAL_ICVS));\n+      pair->start = pair->end = 0;\n+    }\n \n   /* Ensure that constructors are run first.  */\n   struct GOMP_kernel_launch_attributes kla ="}, {"sha": "a12f1ac075a25b561f35d4639c896c6edf694de7", "filename": "libgomp/plugin/plugin-nvptx.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Fplugin%2Fplugin-nvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Fplugin%2Fplugin-nvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-nvptx.c?ref=9f2fca56593a2b87026b399d26adcdca90705685", "patch": "@@ -1305,7 +1305,7 @@ GOMP_OFFLOAD_load_image (int ord, unsigned version, const void *target_data,\n   fn_entries = img_header->fn_num;\n   fn_descs = img_header->fn_descs;\n \n-  /* Currently, the only other entry kind is 'device number'.  */\n+  /* Currently, other_entries contains only the struct of ICVs.  */\n   other_entries = 1;\n \n   targ_tbl = GOMP_PLUGIN_malloc (sizeof (struct addr_pair)\n@@ -1358,20 +1358,19 @@ GOMP_OFFLOAD_load_image (int ord, unsigned version, const void *target_data,\n       targ_tbl->end = targ_tbl->start + bytes;\n     }\n \n-  CUdeviceptr device_num_varptr;\n-  size_t device_num_varsize;\n-  CUresult r = CUDA_CALL_NOCHECK (cuModuleGetGlobal, &device_num_varptr,\n-\t\t\t\t  &device_num_varsize, module,\n-\t\t\t\t  XSTRING (GOMP_DEVICE_NUM_VAR));\n+  CUdeviceptr varptr;\n+  size_t varsize;\n+  CUresult r = CUDA_CALL_NOCHECK (cuModuleGetGlobal, &varptr, &varsize,\n+\t\t\t\t  module, XSTRING (GOMP_ADDITIONAL_ICVS));\n+\n   if (r == CUDA_SUCCESS)\n     {\n-      targ_tbl->start = (uintptr_t) device_num_varptr;\n-      targ_tbl->end = (uintptr_t) (device_num_varptr + device_num_varsize);\n+      targ_tbl->start = (uintptr_t) varptr;\n+      targ_tbl->end = (uintptr_t) (varptr + varsize);\n     }\n   else\n-    /* The 'GOMP_DEVICE_NUM_VAR' variable was not in this image.  */\n+    /* The variable was not in this image.  */\n     targ_tbl->start = targ_tbl->end = 0;\n-  targ_tbl++;\n \n   nvptx_set_clocktick (module, dev);\n "}, {"sha": "fbc2827d0381d2eebb87e157c854294993f0c056", "filename": "libgomp/target.c", "status": "modified", "additions": 95, "deletions": 26, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=9f2fca56593a2b87026b399d26adcdca90705685", "patch": "@@ -2108,6 +2108,68 @@ gomp_update (struct gomp_device_descr *devicep, size_t mapnum, void **hostaddrs,\n   gomp_mutex_unlock (&devicep->lock);\n }\n \n+static struct gomp_offload_icv_list *\n+gomp_get_offload_icv_item (int dev_num)\n+{\n+  struct gomp_offload_icv_list *l = gomp_offload_icv_list;\n+  while (l != NULL && l->device_num != dev_num)\n+    l = l->next;\n+\n+  return l;\n+}\n+\n+/* Helper function for 'gomp_load_image_to_device'.  Returns the ICV values\n+   depending on the device num and the variable hierarchy\n+   (_DEV_42, _DEV, _ALL).  If no ICV was initially configured for the given\n+   device and thus no item with that device number is contained in\n+   gomp_offload_icv_list, then a new item is created and added to the list.  */\n+\n+static struct gomp_offload_icvs *\n+get_gomp_offload_icvs (int dev_num)\n+{\n+  struct gomp_icv_list *dev\n+    = gomp_get_initial_icv_item (GOMP_DEVICE_NUM_FOR_DEV);\n+  struct gomp_icv_list *all\n+    = gomp_get_initial_icv_item (GOMP_DEVICE_NUM_FOR_ALL);\n+  struct gomp_icv_list *dev_x = gomp_get_initial_icv_item (dev_num);\n+  struct gomp_offload_icv_list *offload_icvs\n+    = gomp_get_offload_icv_item (dev_num);\n+\n+  if (offload_icvs != NULL)\n+    return &offload_icvs->icvs;\n+\n+  struct gomp_offload_icv_list *new\n+    = (struct gomp_offload_icv_list *) gomp_malloc (sizeof (struct gomp_offload_icv_list));\n+\n+  new->device_num = dev_num;\n+  new->icvs.device_num = dev_num;\n+  new->next = gomp_offload_icv_list;\n+\n+  if (dev_x != NULL && gomp_get_icv_flag (dev_x->flags, GOMP_ICV_NTEAMS))\n+    new->icvs.nteams = dev_x->icvs.nteams_var;\n+  else if (dev != NULL && gomp_get_icv_flag (dev->flags, GOMP_ICV_NTEAMS))\n+    new->icvs.nteams = dev->icvs.nteams_var;\n+  else if (all != NULL && gomp_get_icv_flag (all->flags, GOMP_ICV_NTEAMS))\n+    new->icvs.nteams = all->icvs.nteams_var;\n+  else\n+    new->icvs.nteams = gomp_default_icv_values.nteams_var;\n+\n+  if (dev_x != NULL\n+      && gomp_get_icv_flag (dev_x->flags, GOMP_ICV_DEFAULT_DEVICE))\n+    new->icvs.default_device = dev_x->icvs.default_device_var;\n+  else if (dev != NULL\n+\t   && gomp_get_icv_flag (dev->flags, GOMP_ICV_DEFAULT_DEVICE))\n+    new->icvs.default_device = dev->icvs.default_device_var;\n+  else if (all != NULL\n+\t   && gomp_get_icv_flag (all->flags, GOMP_ICV_DEFAULT_DEVICE))\n+    new->icvs.default_device = all->icvs.default_device_var;\n+  else\n+    new->icvs.default_device = gomp_default_icv_values.default_device_var;\n+\n+  gomp_offload_icv_list = new;\n+  return &new->icvs;\n+}\n+\n /* Load image pointed by TARGET_DATA to the device, specified by DEVICEP.\n    And insert to splay tree the mapping between addresses from HOST_TABLE and\n    from loaded target image.  We rely in the host and device compiler\n@@ -2128,9 +2190,6 @@ gomp_load_image_to_device (struct gomp_device_descr *devicep, unsigned version,\n   int num_funcs = host_funcs_end - host_func_table;\n   int num_vars  = (host_vars_end - host_var_table) / 2;\n \n-  /* Others currently is only 'device_num' */\n-  int num_others = 1;\n-\n   /* Load image to device and get target addresses for the image.  */\n   struct addr_pair *target_table = NULL;\n   int i, num_target_entries;\n@@ -2140,8 +2199,8 @@ gomp_load_image_to_device (struct gomp_device_descr *devicep, unsigned version,\n \t\t\t\ttarget_data, &target_table);\n \n   if (num_target_entries != num_funcs + num_vars\n-      /* Others (device_num) are included as trailing entries in pair list.  */\n-      && num_target_entries != num_funcs + num_vars + num_others)\n+      /* \"+1\" due to the additional ICV struct.  */\n+      && num_target_entries != num_funcs + num_vars + 1)\n     {\n       gomp_mutex_unlock (&devicep->lock);\n       if (is_register_lock)\n@@ -2153,7 +2212,9 @@ gomp_load_image_to_device (struct gomp_device_descr *devicep, unsigned version,\n \n   /* Insert host-target address mapping into splay tree.  */\n   struct target_mem_desc *tgt = gomp_malloc (sizeof (*tgt));\n-  tgt->array = gomp_malloc ((num_funcs + num_vars) * sizeof (*tgt->array));\n+  /* \"+1\" due to the additional ICV struct.  */\n+  tgt->array = gomp_malloc ((num_funcs + num_vars + 1)\n+\t\t\t    * sizeof (*tgt->array));\n   tgt->refcount = REFCOUNT_INFINITY;\n   tgt->tgt_start = 0;\n   tgt->tgt_end = 0;\n@@ -2213,32 +2274,40 @@ gomp_load_image_to_device (struct gomp_device_descr *devicep, unsigned version,\n       array++;\n     }\n \n-  /* Last entry is for the on-device 'device_num' variable. Tolerate case\n-     where plugin does not return this entry.  */\n+  /* Last entry is for a ICVs variable.\n+     Tolerate case where plugin does not return those entries.  */\n   if (num_funcs + num_vars < num_target_entries)\n     {\n-      struct addr_pair *device_num_var = &target_table[num_funcs + num_vars];\n-      /* Start address will be non-zero for last entry if GOMP_DEVICE_NUM_VAR\n-\t was found in this image.  */\n-      if (device_num_var->start != 0)\n+      struct addr_pair *var = &target_table[num_funcs + num_vars];\n+\n+      /* Start address will be non-zero for the ICVs variable if\n+\t the variable was found in this image.  */\n+      if (var->start != 0)\n \t{\n \t  /* The index of the devicep within devices[] is regarded as its\n \t     'device number', which is different from the per-device type\n \t     devicep->target_id.  */\n-\t  int device_num_val = (int) (devicep - &devices[0]);\n-\t  if (device_num_var->end - device_num_var->start != sizeof (int))\n-\t    {\n-\t      gomp_mutex_unlock (&devicep->lock);\n-\t      if (is_register_lock)\n-\t\tgomp_mutex_unlock (&register_lock);\n-\t      gomp_fatal (\"offload plugin managed 'device_num' not of expected \"\n-\t\t\t  \"format\");\n-\t    }\n-\n-\t  /* Copy device_num value to place on device memory, hereby actually\n-\t     designating its device number into effect.  */\n-\t  gomp_copy_host2dev (devicep, NULL, (void *) device_num_var->start,\n-\t\t\t      &device_num_val, sizeof (int), false, NULL);\n+\t  int dev_num = (int) (devicep - &devices[0]);\n+\t  struct gomp_offload_icvs *icvs = get_gomp_offload_icvs (dev_num);\n+\t  size_t var_size = var->end - var->start;\n+\n+\t  /* Copy the ICVs variable to place on device memory, hereby\n+\t     actually designating its device number into effect.  */\n+\t  gomp_copy_host2dev (devicep, NULL, (void *) var->start, icvs,\n+\t\t\t      var_size, false, NULL);\n+\t  splay_tree_key k = &array->key;\n+\t  k->host_start = (uintptr_t) icvs;\n+\t  k->host_end =\n+\t    k->host_start + (size_mask & sizeof (struct gomp_offload_icvs));\n+\t  k->tgt = tgt;\n+\t  k->tgt_offset = var->start;\n+\t  k->refcount = REFCOUNT_INFINITY;\n+\t  k->dynamic_refcount = 0;\n+\t  k->aux = NULL;\n+\t  array->left = NULL;\n+\t  array->right = NULL;\n+\t  splay_tree_insert (&devicep->mem_map, array);\n+\t  array++;\n \t}\n     }\n "}, {"sha": "431cfc729eed59b9ffede821eba39efe370edd86", "filename": "libgomp/testsuite/libgomp.c-c++-common/icv-5.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ficv-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ficv-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ficv-5.c?ref=9f2fca56593a2b87026b399d26adcdca90705685", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do run } */\n+/* { dg-set-target-env-var OMP_NUM_TEAMS_DEV_0 \"42\" } */\n+/* { dg-set-target-env-var OMP_NUM_TEAMS_DEV_1 \"43\" } */\n+/* { dg-set-target-env-var OMP_NUM_TEAMS_DEV_2 \"44\" } */\n+/* { dg-set-target-env-var OMP_NUM_TEAMS_ALL \"45\" } */\n+/* { dg-set-target-env-var OMP_NUM_TEAMS_DEV \"46\" } */\n+/* { dg-set-target-env-var OMP_NUM_TEAMS \"47\" } */\n+\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+int\n+main ()\n+{\n+  if (omp_get_max_teams () != 47)\n+    abort ();\n+\n+  int num_devices = omp_get_num_devices () > 3 ? 3 : omp_get_num_devices ();\n+  for (int i=0; i < num_devices; i++)\n+    #pragma omp target device (i)\n+      if (omp_get_max_teams () != 42 + i)\n+\tabort ();\n+\n+  return 0;\n+}"}, {"sha": "7151bd1e2b3cbb4435d66e5e7ebd148daeb70b0c", "filename": "libgomp/testsuite/libgomp.c-c++-common/icv-6.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ficv-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ficv-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ficv-6.c?ref=9f2fca56593a2b87026b399d26adcdca90705685", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do run } */\n+/* { dg-set-target-env-var OMP_NUM_TEAMS_ALL \"42\" } */\n+/* { dg-set-target-env-var OMP_NUM_TEAMS_DEV \"43\" } */\n+/* { dg-set-target-env-var OMP_SCHEDULE_ALL \"guided,4\" } */\n+/* { dg-set-target-env-var OMP_DYNAMIC_ALL \"true\" } */\n+/* { dg-set-target-env-var OMP_TEAMS_THREAD_LIMIT_ALL \"44\" } */\n+/* { dg-set-target-env-var OMP_THREAD_LIMIT_ALL \"45\" } */\n+/* { dg-set-target-env-var OMP_NUM_THREADS_ALL \"46,3,2\" } */\n+/* { dg-set-target-env-var OMP_MAX_ACTIVE_LEVELS_ALL \"47\" } */\n+/* { dg-set-target-env-var OMP_PROC_BIND_ALL \"spread\" } */\n+/* { dg-set-target-env-var OMP_WAIT_POLICY_ALL \"active\" } */\n+\n+/* This tests the hierarchical usage of ICVs on the device, i.e. if\n+   OMP_NUM_TEAMS_DEV_<device_num> is not configured, then the value of\n+   OMP_NUM_TEAMS_DEV should be used.  And if there is no environment variable\n+   without suffix, then the corresponding _ALL variant should be used.  */\n+\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+int\n+main ()\n+{\n+  enum omp_sched_t kind;\n+  int chunk_size;\n+  omp_get_schedule(&kind, &chunk_size);\n+\n+  if (omp_get_max_teams () != 42\n+      || !omp_get_dynamic ()\n+      || kind != 3 || chunk_size != 4\n+      || omp_get_teams_thread_limit () != 44\n+      || omp_get_thread_limit () != 45\n+      || omp_get_max_threads () != 46\n+      || omp_get_proc_bind () != omp_proc_bind_spread\n+      || omp_get_max_active_levels () != 47)\n+    abort ();\n+\n+  int num_devices = omp_get_num_devices () > 3 ? 3 : omp_get_num_devices ();\n+  for (int i=0; i < num_devices; i++)\n+    #pragma omp target device (i)\n+      if (omp_get_max_teams () != 43)\n+\tabort ();\n+\n+  return 0;\n+}"}, {"sha": "70a716d12e3c43572704263873baef2a33a983ae", "filename": "libgomp/testsuite/libgomp.c-c++-common/icv-7.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ficv-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ficv-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ficv-7.c?ref=9f2fca56593a2b87026b399d26adcdca90705685", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do run } */\n+/* { dg-set-target-env-var OMP_NUM_TEAMS_ALL \"42\" } */\n+\n+/* This tests the hierarchical usage of ICVs on the host and on devices, i.e. if\n+   OMP_NUM_TEAMS_DEV_<device_num>, OMP_NUM_TEAMS_DEV, and\n+   OMP_NUM_TEAMS are not configured, then the value of\n+   OMP_NUM_TEAMS_ALL should be used for the host as well as for the\n+   devices.  */\n+\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+int\n+main ()\n+{\n+  if (omp_get_max_teams () != 42)\n+    abort ();\n+\n+  int num_devices = omp_get_num_devices () > 3 ? 3 : omp_get_num_devices ();\n+  for (int i=0; i < num_devices; i++)\n+    #pragma omp target device (i)\n+      if (omp_get_max_teams () != 42)\n+\tabort ();\n+\n+  return 0;\n+}"}, {"sha": "f25ce45a0f2a0a86456b49aab7ed932f038f2440", "filename": "libgomp/testsuite/libgomp.c-c++-common/icv-8.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ficv-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ficv-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ficv-8.c?ref=9f2fca56593a2b87026b399d26adcdca90705685", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do run } */\n+/* { dg-set-target-env-var OMP_NUM_TEAMS_DEV_1234567890 \"42\" } */\n+/* { dg-set-target-env-var OMP_NUM_TEAMS_DEV_ \"43\" } */\n+/* { dg-set-target-env-var OMP_NUM_TEAMS_DEV_01 \"44\" } */\n+/* { dg-set-target-env-var OMP_NUM_TEAMS_DEV_a \"45\" } */\n+/* { dg-set-target-env-var OMP_NUM_TEAMS_DEV_12345678901 \"46\" } */\n+/* { dg-set-target-env-var OMP_NUM_TEAMS_DEV_-1 \"47\" } */\n+/* { dg-set-target-env-var \"OMP_NUM_TEAMS_DEV_ 1\" \"48\" } */\n+/* { dg-set-target-env-var \"OMP_NUM_TEAMS_DEV_00\" \"49\" } */\n+\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+int\n+main ()\n+{\n+  return 0;\n+}\n+\n+/* { dg-output \".*Invalid device number in OMP_NUM_TEAMS_DEV_=43.*\" { target native } } */\n+/* { dg-output \".*Invalid device number in OMP_NUM_TEAMS_DEV_01=44.*\" { target native } } */\n+/* { dg-output \".*Invalid device number in OMP_NUM_TEAMS_DEV_a=45.*\" { target native } } */\n+/* { dg-output \".*Invalid device number in OMP_NUM_TEAMS_DEV_12345678901=46.*\" { target native } } */\n+/* { dg-output \".*Invalid device number in OMP_NUM_TEAMS_DEV_-1=47.*\" { target native } } */\n+/* { dg-output \".*Invalid device number in OMP_NUM_TEAMS_DEV_ 1=48.*\" { target native } } */\n+/* { dg-output \".*Invalid device number in OMP_NUM_TEAMS_DEV_00=49.*\" { target native } } */"}, {"sha": "9ea7adecb580b26415187ccaf06851330c3a050d", "filename": "libgomp/testsuite/libgomp.c-c++-common/omp-display-env-1.c", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fomp-display-env-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fomp-display-env-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fomp-display-env-1.c?ref=9f2fca56593a2b87026b399d26adcdca90705685", "patch": "@@ -0,0 +1,119 @@\n+/* { dg-do run } */\n+/* { dg-set-target-env-var OMP_THREAD_LIMIT_DEV_24 \"42\" } */\n+/* { dg-set-target-env-var OMP_THREAD_LIMIT_ALL \"43\" } */\n+/* { dg-set-target-env-var OMP_THREAD_LIMIT_DEV \"44\" } */\n+/* { dg-set-target-env-var OMP_THREAD_LIMIT \"45\" } */\n+/* { dg-set-target-env-var OMP_DEFAULT_DEVICE \"42\" } */\n+/* { dg-set-target-env-var OMP_SCHEDULE_DEV_24 \"guided,4\" } */\n+/* { dg-set-target-env-var OMP_SCHEDULE_ALL \"dynamic\" } */\n+/* { dg-set-target-env-var OMP_SCHEDULE_DEV \"guided,1\" } */\n+/* { dg-set-target-env-var OMP_SCHEDULE \"guided,2\" } */\n+/* { dg-set-target-env-var OMP_DYNAMIC_DEV_24 \"true\" } */\n+\n+/* { dg-set-target-env-var OMP_DYNAMIC_ALL \"true\" } */\n+/* { dg-set-target-env-var OMP_DYNAMIC_DEV \"true\" } */\n+/* { dg-set-target-env-var OMP_DYNAMIC \"true\" } */\n+/* { dg-set-target-env-var OMP_NUM_THREADS \"4,3,2\" } */\n+/* { dg-set-target-env-var OMP_NUM_THREADS_ALL \"45,46,47\" } */\n+/* { dg-set-target-env-var OMP_NUM_THREADS_DEV \"42,43,44\" } */\n+/* { dg-set-target-env-var OMP_NUM_THREADS_DEV_24 \"14,13,12\" } */\n+/* { dg-set-target-env-var OMP_MAX_ACTIVE_LEVELS \"42\" } */\n+/* { dg-set-target-env-var OMP_MAX_ACTIVE_LEVELS_ALL \"43\" } */\n+/* { dg-set-target-env-var OMP_MAX_ACTIVE_LEVELS_DEV \"44\" } */\n+\n+/* { dg-set-target-env-var OMP_MAX_ACTIVE_LEVELS_DEV_24 \"45\" } */\n+/* { dg-set-target-env-var OMP_NUM_TEAMS \"42\" } */\n+/* { dg-set-target-env-var OMP_NUM_TEAMS_ALL \"43\" } */\n+/* { dg-set-target-env-var OMP_NUM_TEAMS_DEV \"44\" } */\n+/* { dg-set-target-env-var OMP_NUM_TEAMS_DEV_24 \"45\" } */\n+/* { dg-set-target-env-var OMP_PROC_BIND \"spread\" } */\n+/* { dg-set-target-env-var OMP_PROC_BIND_ALL \"close\" } */\n+/* { dg-set-target-env-var OMP_PROC_BIND_DEV \"spread,spread\" } */\n+/* { dg-set-target-env-var OMP_PROC_BIND_DEV_24 \"spread,close\" } */\n+/* { dg-set-target-env-var OMP_STACKSIZE \"42\" } */\n+\n+/* { dg-set-target-env-var OMP_STACKSIZE_ALL \"42 M\" } */\n+/* { dg-set-target-env-var OMP_STACKSIZE_DEV \"43 k\" } */\n+/* { dg-set-target-env-var OMP_STACKSIZE_DEV_24 \"44\" } */\n+/* { dg-set-target-env-var OMP_WAIT_POLICY \"active\" } */\n+/* { dg-set-target-env-var OMP_WAIT_POLICY_ALL \"ACTIVE\" } */\n+/* { dg-set-target-env-var OMP_WAIT_POLICY_DEV \"passive\" } */\n+/* { dg-set-target-env-var OMP_WAIT_POLICY_DEV_24 \"PASSIVE\" } */\n+/* { dg-set-target-env-var OMP_TEAMS_THREAD_LIMIT \"42\" } */\n+/* { dg-set-target-env-var OMP_TEAMS_THREAD_LIMIT_ALL \"43\" } */\n+/* { dg-set-target-env-var OMP_TEAMS_THREAD_LIMIT_DEV \"44\" } */\n+\n+/* { dg-set-target-env-var OMP_TEAMS_THREAD_LIMIT_DEV_24 \"45\" } */\n+/* { dg-set-target-env-var OMP_CANCELLATION \"true\" } */\n+/* { dg-set-target-env-var OMP_DISPLAY_AFFINITY \"true\" } */\n+/* { dg-set-target-env-var OMP_TARGET_OFFLOAD \"mandatory\" } */\n+/* { dg-set-target-env-var OMP_MAX_TASK_PRIORITY \"20\" } */\n+/* { dg-set-target-env-var OMP_ALLOCATOR \"omp_const_mem_alloc\" } */\n+/* { dg-set-target-env-var OMP_NESTED \"false\" } */\n+\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+int\n+main ()\n+{\n+  omp_display_env (1);\n+  return 0;\n+}\n+\n+/* { dg-output \".*\\\\\\[host] OMP_DYNAMIC = 'TRUE'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[all] OMP_DYNAMIC = 'TRUE'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[device] OMP_DYNAMIC = 'TRUE'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[24\\] OMP_DYNAMIC = 'TRUE'.*\" { target native } } */\n+\n+/* { dg-output \".*\\\\\\[host] OMP_NUM_THREADS = '4,3,2'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[all\\] OMP_NUM_THREADS = '45,46,47'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[device\\] OMP_NUM_THREADS = '42,43,44'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[24\\] OMP_NUM_THREADS = '14,13,12'.*\" { target native } } */\n+\n+/* { dg-output \".*\\\\\\[host] OMP_SCHEDULE = 'GUIDED,2'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[all\\] OMP_SCHEDULE = 'DYNAMIC'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[device\\] OMP_SCHEDULE = 'GUIDED'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[24\\] OMP_SCHEDULE = 'GUIDED,4'.*\" { target native } } */\n+\n+/* { dg-output \".*\\\\\\[host] OMP_PROC_BIND = 'SPREAD'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[all\\] OMP_PROC_BIND = 'CLOSE'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[device\\] OMP_PROC_BIND = 'SPREAD,SPREAD'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[24\\] OMP_PROC_BIND = 'SPREAD,CLOSE'.*\" { target native } } */\n+\n+/* { dg-output \".*\\\\\\[host] OMP_STACKSIZE = '43008'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[all\\] OMP_STACKSIZE = '44040192'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[device\\] OMP_STACKSIZE = '44032'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[24\\] OMP_STACKSIZE = '45056'.*\" { target native } } */\n+\n+/* { dg-output \".*\\\\\\[host] OMP_WAIT_POLICY = 'ACTIVE'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[all\\] OMP_WAIT_POLICY = 'ACTIVE'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[device\\] OMP_WAIT_POLICY = 'PASSIVE'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[24\\] OMP_WAIT_POLICY = 'PASSIVE'.*\" { target native } } */\n+\n+/* { dg-output \".*\\\\\\[host] OMP_THREAD_LIMIT = '45'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[all\\] OMP_THREAD_LIMIT = '43'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[device\\] OMP_THREAD_LIMIT = '44'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[24\\] OMP_THREAD_LIMIT = '42'.*\" { target native } } */\n+\n+/* { dg-output \".*\\\\\\[host] OMP_MAX_ACTIVE_LEVELS = '42'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[all\\] OMP_MAX_ACTIVE_LEVELS = '43'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[device\\] OMP_MAX_ACTIVE_LEVELS = '44'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[24\\] OMP_MAX_ACTIVE_LEVELS = '45'.*\" { target native } } */\n+\n+/* { dg-output \".*\\\\\\[host] OMP_NUM_TEAMS = '42'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[all\\] OMP_NUM_TEAMS = '43'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[device\\] OMP_NUM_TEAMS = '44'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[24\\] OMP_NUM_TEAMS = '45'.*\" { target native } } */\n+\n+/* { dg-output \".*\\\\\\[host] OMP_TEAMS_THREAD_LIMIT = '42'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[all\\] OMP_TEAMS_THREAD_LIMIT = '43'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[device\\] OMP_TEAMS_THREAD_LIMIT = '44'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[24\\] OMP_TEAMS_THREAD_LIMIT = '45'.*\" { target native } } */\n+\n+/* { dg-output \".*\\\\\\[all] OMP_CANCELLATION = 'TRUE'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[all] OMP_DEFAULT_DEVICE = '42'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[all] OMP_MAX_TASK_PRIORITY = '20'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[all] OMP_DISPLAY_AFFINITY = 'TRUE'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[host] OMP_ALLOCATOR = 'omp_const_mem_alloc'.*\" { target native } } */\n+/* { dg-output \".*\\\\\\[all] OMP_TARGET_OFFLOAD = 'MANDATORY'.*\" { target native } } */"}, {"sha": "e1beef4154527e257f20819c62c13d778dcebd98", "filename": "libgomp/testsuite/libgomp.c-c++-common/omp-display-env-2.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fomp-display-env-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f2fca56593a2b87026b399d26adcdca90705685/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fomp-display-env-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fomp-display-env-2.c?ref=9f2fca56593a2b87026b399d26adcdca90705685", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do run } */\n+/* { dg-set-target-env-var OMP_NUM_TEAMS \"42\" } */\n+\n+/* This test checks if omp_display_env outputs the initial ICV values although\n+   the value was updated.  */\n+\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+int\n+main ()\n+{\n+  omp_display_env (1);\n+  omp_set_num_teams (24);\n+  if (omp_get_max_teams () != 24)\n+    abort ();\n+  omp_display_env (1);\n+\n+  return 0;\n+}\n+\n+/* { dg-output \".*\\\\\\[host] OMP_NUM_TEAMS = '42'.*\\\\\\[host] OMP_NUM_TEAMS = '42'\" { target native } } */"}]}