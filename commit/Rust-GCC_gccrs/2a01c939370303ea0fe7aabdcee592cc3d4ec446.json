{"sha": "2a01c939370303ea0fe7aabdcee592cc3d4ec446", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmEwMWM5MzkzNzAzMDNlYTBmZTdhYWJkY2VlNTkyY2MzZDRlYzQ0Ng==", "commit": {"author": {"name": "David S. Miller", "email": "davem@pierdol.cobaltmicro.com", "date": "1998-08-11T05:54:17Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "1998-08-11T05:54:17Z"}, "message": "sparc.c (sparc_emit_set_const32): INTVAL is of type HOST_WIDE_INT.\n\n\t* config/sparc/sparc.c (sparc_emit_set_const32): INTVAL is of\n\ttype HOST_WIDE_INT.\n\t(safe_constDI sparc_emit_set_const64_quick1,\n\tsparc_emit_set_const64_quick2, sparc_emit_set_const64_longway,\n\tanalyze_64bit_constant, const64_is_2insns,\n\tcreate_simple_focus_bits): Fix some bugs when compiled on real\n\t64-bit hosts.\n\t(function_arg_record_value_3, function_arg_record_value_2,\n\tfunction_arg_record_value): Add fully prototyped forward decls.\n\t* config/sparc/sparc.md (define_insn cmpsi_insn_sp32): Rename back\n\tto cmpsi_insn and use on both 64 and 32 bit targets.\n\t(define_insn cmpsi_insn_sp64): Remove.\n\t(define_expand zero_extendsidi2): Allow for 32-bit target too.\n\t(define_insn zero_extendsidi2_insn): Rename to\n\tzero_extendsidi2_insn_sp64.\n\t(define_insn zero_extendsidi2_insn_sp32): New pattern and\n\tassosciated forced split for it.\n\nFrom-SVN: r21662", "tree": {"sha": "f3768e925dafc0ff9e16113a1ddf89c28e80311d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3768e925dafc0ff9e16113a1ddf89c28e80311d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a01c939370303ea0fe7aabdcee592cc3d4ec446", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a01c939370303ea0fe7aabdcee592cc3d4ec446", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a01c939370303ea0fe7aabdcee592cc3d4ec446", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a01c939370303ea0fe7aabdcee592cc3d4ec446/comments", "author": null, "committer": null, "parents": [{"sha": "aaa642460c391f38d9b7b649331d0079aebd60cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaa642460c391f38d9b7b649331d0079aebd60cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aaa642460c391f38d9b7b649331d0079aebd60cc"}], "stats": {"total": 164, "additions": 125, "deletions": 39}, "files": [{"sha": "dcd7128de14db9405dd6718e2d8bf4d06799c6af", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a01c939370303ea0fe7aabdcee592cc3d4ec446/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a01c939370303ea0fe7aabdcee592cc3d4ec446/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2a01c939370303ea0fe7aabdcee592cc3d4ec446", "patch": "@@ -1,3 +1,23 @@\n+Tue Aug 11 04:46:01 1998  David S. Miller  <davem@pierdol.cobaltmicro.com>\n+\n+\t* config/sparc/sparc.c (sparc_emit_set_const32): INTVAL is of\n+\ttype HOST_WIDE_INT.\n+\t(safe_constDI sparc_emit_set_const64_quick1,\n+\tsparc_emit_set_const64_quick2, sparc_emit_set_const64_longway,\n+\tanalyze_64bit_constant, const64_is_2insns,\n+\tcreate_simple_focus_bits): Fix some bugs when compiled on real\n+\t64-bit hosts.\n+\t(function_arg_record_value_3, function_arg_record_value_2,\n+\tfunction_arg_record_value): Add fully prototyped forward decls.\n+\t* config/sparc/sparc.md (define_insn cmpsi_insn_sp32): Rename back\n+\tto cmpsi_insn and use on both 64 and 32 bit targets.\n+\t(define_insn cmpsi_insn_sp64): Remove.\n+\t(define_expand zero_extendsidi2): Allow for 32-bit target too.\n+\t(define_insn zero_extendsidi2_insn): Rename to\n+\tzero_extendsidi2_insn_sp64.\n+\t(define_insn zero_extendsidi2_insn_sp32): New pattern and\n+\tassosciated forced split for it.\n+\n Mon Aug 10 22:57:24 1998  John Carr  <jfc@mit.edu>\n \n \t* config/sparc/sparc.md (define_insn jump): Output ba,pt not b,pt"}, {"sha": "187cb7ab79e3eb8bd734a50e6f99e76828b2cc21", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 59, "deletions": 26, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a01c939370303ea0fe7aabdcee592cc3d4ec446/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a01c939370303ea0fe7aabdcee592cc3d4ec446/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=2a01c939370303ea0fe7aabdcee592cc3d4ec446", "patch": "@@ -115,6 +115,7 @@ static void sparc_output_addr_vec PROTO((rtx));\n static void sparc_output_addr_diff_vec PROTO((rtx));\n static void sparc_output_deferred_case_vectors PROTO((void));\n \n+\n #ifdef DWARF2_DEBUGGING_INFO\n extern char *dwarf2out_cfi_label ();\n #endif\n@@ -1040,7 +1041,7 @@ sparc_emit_set_const32 (op0, op1)\n \n   if (GET_CODE (op1) == CONST_INT)\n     {\n-      int value = INTVAL (op1);\n+      HOST_WIDE_INT value = INTVAL (op1);\n \n       if (SPARC_SETHI_P (value)\n \t  || SPARC_SIMM13_P (value))\n@@ -1192,6 +1193,8 @@ sparc_emit_set_symbolic_const64 (op0, op1, temp1)\n }\n \n /* This avoids problems when cross compiling. */\n+static rtx safe_constDI\tPROTO((HOST_WIDE_INT));\n+\n static rtx\n safe_constDI(val)\n      HOST_WIDE_INT val;\n@@ -1211,17 +1214,21 @@ safe_constDI(val)\n    such values are similar to something required later on.\n    Without doing this, the optimizer cannot see such\n    opportunities.  */\n+\n+static void sparc_emit_set_const64_quick1\n+\tPROTO((rtx, rtx, unsigned HOST_WIDE_INT, int));\n+\n static void\n sparc_emit_set_const64_quick1 (op0, temp, low_bits, is_neg)\n   rtx op0;\n   rtx temp;\n-  unsigned int low_bits;\n+  unsigned HOST_WIDE_INT low_bits;\n   int is_neg;\n {\n-  unsigned int high_bits;\n+  unsigned HOST_WIDE_INT high_bits;\n \n   if (is_neg)\n-    high_bits = ~low_bits;\n+    high_bits = (~low_bits) & 0xffffffff;\n   else\n     high_bits = low_bits;\n \n@@ -1242,12 +1249,16 @@ sparc_emit_set_const64_quick1 (op0, temp, low_bits, is_neg)\n     }\n }\n \n+static void sparc_emit_set_const64_quick2\n+\tPROTO((rtx, rtx, unsigned HOST_WIDE_INT,\n+\t       unsigned HOST_WIDE_INT, int));\n+\n static void\n sparc_emit_set_const64_quick2 (op0, temp, high_bits, low_immediate, shift_count)\n   rtx op0;\n   rtx temp;\n-  unsigned int high_bits;\n-  unsigned int low_immediate;\n+  unsigned HOST_WIDE_INT high_bits;\n+  unsigned HOST_WIDE_INT low_immediate;\n   int shift_count;\n {\n   rtx temp2 = op0;\n@@ -1283,14 +1294,17 @@ sparc_emit_set_const64_quick2 (op0, temp, high_bits, low_immediate, shift_count)\n \t\t\t\t\t safe_constDI (low_immediate & 0x3ff))));\n }\n \n+static void sparc_emit_set_const64_longway\n+\tPROTO((rtx, rtx, unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT));\n+\n /* Full 64-bit constant decomposition.  Even though this is the\n    'worst' case, we still optimize a few things away.  */\n static void\n sparc_emit_set_const64_longway (op0, temp, high_bits, low_bits)\n      rtx op0;\n      rtx temp;\n-     unsigned int high_bits;\n-     unsigned int low_bits;\n+     unsigned HOST_WIDE_INT high_bits;\n+     unsigned HOST_WIDE_INT low_bits;\n {\n   rtx sub_temp;\n \n@@ -1356,7 +1370,7 @@ sparc_emit_set_const64_longway (op0, temp, high_bits, low_bits)\n \t{\n \t  emit_insn (gen_rtx_SET (DImode, op0,\n \t\t\t\t  gen_rtx_ASHIFT (DImode, sub_temp,\n-\t\t\t\t\t\t  GEN_INT(to_shift))));\n+\t\t\t\t\t\t  GEN_INT (to_shift))));\n \t  emit_insn (gen_rtx_SET (DImode, op0,\n \t\t\t\t  gen_rtx_IOR (DImode, op0, low1)));\n \t  sub_temp = op0;\n@@ -1391,9 +1405,14 @@ sparc_emit_set_const64_longway (op0, temp, high_bits, low_bits)\n }\n \n /* Analyze a 64-bit constant for certain properties. */\n+static void analyze_64bit_constant\n+\tPROTO((unsigned HOST_WIDE_INT,\n+\t       unsigned HOST_WIDE_INT,\n+\t       int *, int *, int *));\n+\n static void\n analyze_64bit_constant (high_bits, low_bits, hbsp, lbsp, abbasp)\n-     unsigned int high_bits, low_bits;\n+     unsigned HOST_WIDE_INT high_bits, low_bits;\n      int *hbsp, *lbsp, *abbasp;\n {\n   int lowest_bit_set, highest_bit_set, all_bits_between_are_set;\n@@ -1455,14 +1474,17 @@ analyze_64bit_constant (high_bits, low_bits, hbsp, lbsp, abbasp)\n   *abbasp = all_bits_between_are_set;\n }\n \n+static int const64_is_2insns\n+\tPROTO((unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT));\n+\n static int\n const64_is_2insns (high_bits, low_bits)\n-     unsigned int high_bits, low_bits;\n+     unsigned HOST_WIDE_INT high_bits, low_bits;\n {\n   int highest_bit_set, lowest_bit_set, all_bits_between_are_set;\n \n   if (high_bits == 0\n-      || high_bits == -1)\n+      || high_bits == 0xffffffff)\n     return 1;\n \n   analyze_64bit_constant (high_bits, low_bits,\n@@ -1479,12 +1501,16 @@ const64_is_2insns (high_bits, low_bits)\n   return 0;\n }\n \n-static unsigned int\n+static unsigned HOST_WIDE_INT create_simple_focus_bits\n+\tPROTO((unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n+\t       int, int, int));\n+\n+static unsigned HOST_WIDE_INT\n create_simple_focus_bits (high_bits, low_bits, highest_bit_set, lowest_bit_set, shift)\n-     unsigned int high_bits, low_bits;\n+     unsigned HOST_WIDE_INT high_bits, low_bits;\n      int highest_bit_set, lowest_bit_set, shift;\n {\n-  unsigned int hi, lo;\n+  int hi, lo;\n \n   if (lowest_bit_set < 32)\n     {\n@@ -1510,7 +1536,7 @@ sparc_emit_set_const64 (op0, op1)\n      rtx op0;\n      rtx op1;\n {\n-  unsigned int high_bits, low_bits;\n+  unsigned HOST_WIDE_INT high_bits, low_bits;\n   int lowest_bit_set, highest_bit_set;\n   int all_bits_between_are_set;\n   int i;\n@@ -1536,7 +1562,7 @@ sparc_emit_set_const64 (op0, op1)\n   if (GET_CODE (op1) == CONST_DOUBLE)\n     {\n #if HOST_BITS_PER_WIDE_INT == 64\n-      high_bits = CONST_DOUBLE_LOW (op1) >> 32;\n+      high_bits = (CONST_DOUBLE_LOW (op1) >> 32) & 0xffffffff;\n       low_bits  = CONST_DOUBLE_LOW (op1) & 0xffffffff;\n #else\n       high_bits = CONST_DOUBLE_HIGH (op1);\n@@ -1546,7 +1572,7 @@ sparc_emit_set_const64 (op0, op1)\n   else\n     {\n #if HOST_BITS_PER_WIDE_INT == 64\n-      high_bits = (INTVAL (op1) >> 32);\n+      high_bits = ((INTVAL (op1) >> 32) & 0xffffffff);\n       low_bits = (INTVAL (op1) & 0xffffffff);\n #else\n       high_bits = ((INTVAL (op1) < 0) ?\n@@ -1582,7 +1608,7 @@ sparc_emit_set_const64 (op0, op1)\n   if (((highest_bit_set == 63\n \t|| lowest_bit_set == 0)\n        && all_bits_between_are_set != 0)\n-      || ((highest_bit_set - lowest_bit_set) < 13))\n+      || ((highest_bit_set - lowest_bit_set) < 12))\n     {\n       rtx the_const = constm1_rtx;\n       int shift = lowest_bit_set;\n@@ -1629,9 +1655,9 @@ sparc_emit_set_const64 (op0, op1)\n    * 2) sethi\t%hi(focus_bits), %reg\n    *    srlx\t%reg, shift, %reg\n    */\n-  if ((highest_bit_set - lowest_bit_set) < 22)\n+  if ((highest_bit_set - lowest_bit_set) < 21)\n     {\n-      unsigned int focus_bits =\n+      unsigned HOST_WIDE_INT focus_bits =\n \tcreate_simple_focus_bits (high_bits, low_bits,\n \t\t\t\t  highest_bit_set, lowest_bit_set, 10);\n       emit_insn (gen_rtx_SET (DImode,\n@@ -1659,25 +1685,25 @@ sparc_emit_set_const64 (op0, op1)\n    *\txor\t%reg, %lo(-0x400 | (low_bits & 0x3ff)), %reg\n    */\n   if (high_bits == 0\n-      || high_bits == -1)\n+      || high_bits == 0xffffffff)\n     return sparc_emit_set_const64_quick1 (op0, temp, low_bits,\n-\t\t\t\t\t  (high_bits == -1));\n+\t\t\t\t\t  (high_bits == 0xffffffff));\n \n   /* 1) sethi\t%hi(high_bits), %reg\n    *    or\t%reg, %lo(high_bits), %reg\n    *    sllx\t%reg, 32, %reg\n    */\n   if (low_bits == 0\n       || (SPARC_SIMM13_P(low_bits)\n-\t  && ((int)low_bits > 0)))\n+\t  && ((HOST_WIDE_INT)low_bits > 0)))\n     return sparc_emit_set_const64_quick2 (op0, temp, high_bits, low_bits, 32);\n \n   /* Now, try 3-insn sequences.  But first we may be able to do something\n      quick when the constant is negated, so try that.  */\n   if (const64_is_2insns ((~high_bits) & 0xffffffff,\n \t\t\t (~low_bits) & 0xfffffc00))\n     {\n-      unsigned int trailing_bits = (~low_bits) & 0x3ff;\n+      unsigned HOST_WIDE_INT trailing_bits = (~low_bits) & 0x3ff;\n \n       if ((((~high_bits) & 0xffffffff) == 0\n \t   && ((~low_bits) & 0x80000000) == 0)\n@@ -1718,7 +1744,7 @@ sparc_emit_set_const64 (op0, op1)\n    */\n   if ((highest_bit_set - lowest_bit_set) < 32)\n     {\n-      unsigned int hi, lo, focus_bits;\n+      unsigned HOST_WIDE_INT hi, lo, focus_bits;\n \n       /* We can't get here in this state.  */\n       if (highest_bit_set < 32\n@@ -3373,6 +3399,13 @@ struct function_arg_record_value_parms\n   int nregs, intoffset;\n };\n \n+static void function_arg_record_value_3\n+\tPROTO((int, struct function_arg_record_value_parms *));\n+static void function_arg_record_value_2\n+\tPROTO((tree, int, struct function_arg_record_value_parms *));\n+static rtx function_arg_record_value\n+\tPROTO((tree, enum machine_mode, int, int, int));\n+\n static void\n function_arg_record_value_1 (type, startbitpos, parms)\n      tree type;"}, {"sha": "719e697255d5d676334017919fe0f6823a5feaad", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a01c939370303ea0fe7aabdcee592cc3d4ec446/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a01c939370303ea0fe7aabdcee592cc3d4ec446/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=2a01c939370303ea0fe7aabdcee592cc3d4ec446", "patch": "@@ -562,19 +562,11 @@\n \n ;; Now the compare DEFINE_INSNs.\n \n-(define_insn \"*cmpsi_insn_sp32\"\n+(define_insn \"*cmpsi_insn\"\n   [(set (reg:CC 100)\n \t(compare:CC (match_operand:SI 0 \"register_operand\" \"r\")\n \t\t    (match_operand:SI 1 \"arith_operand\" \"rI\")))]\n-  \"TARGET_ARCH32\"\n-  \"cmp\\\\t%0, %1\"\n-  [(set_attr \"type\" \"compare\")])\n-\n-(define_insn \"*cmpsi_insn_sp64\"\n-  [(set (reg:CC 100)\n-\t(compare:CC (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t    (match_operand:SI 1 \"arith_double_operand\" \"rHI\")))]\n-  \"TARGET_ARCH64\"\n+  \"\"\n   \"cmp\\\\t%0, %1\"\n   [(set_attr \"type\" \"compare\")])\n \n@@ -2662,7 +2654,7 @@\n \n   /* Now emit using the real source and destination we found, swapping\n      the order if we detect overlap.  */\n-  if (REGNO(dest1) == REGNO(src2))\n+  if (REGNO (dest1) == REGNO (src2))\n     {\n       emit_insn (gen_movsi (dest2, src2));\n       emit_insn (gen_movsi (dest1, src1));\n@@ -3809,10 +3801,10 @@ movtf_is_ok:\n (define_expand \"zero_extendsidi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(zero_extend:DI (match_operand:SI 1 \"register_operand\" \"\")))]\n-  \"TARGET_ARCH64\"\n+  \"\"\n   \"\")\n \n-(define_insn \"*zero_extendsidi2_insn\"\n+(define_insn \"*zero_extendsidi2_insn_sp64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n \t(zero_extend:DI (match_operand:SI 1 \"input_operand\" \"r,m\")))]\n   \"TARGET_ARCH64 && GET_CODE (operands[1]) != CONST_INT\"\n@@ -3822,6 +3814,47 @@ movtf_is_ok:\n   [(set_attr \"type\" \"unary,load\")\n    (set_attr \"length\" \"1\")])\n \n+(define_insn \"*zero_extendsidi2_insn_sp32\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+        (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"! TARGET_ARCH64\"\n+  \"#\"\n+  [(set_attr \"type\" \"unary\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+        (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"\")))]\n+  \"! TARGET_ARCH64 && reload_completed\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 4) (match_dup 5))]\n+  \"\n+{\n+  rtx dest1, dest2;\n+\n+  if (GET_CODE (operands[0]) == SUBREG)\n+    operands[0] = alter_subreg (operands[0]);\n+\n+  dest1 = gen_highpart (SImode, operands[0]);\n+  dest2 = gen_lowpart (SImode, operands[0]);\n+\n+  /* Swap the order in case of overlap.  */\n+  if (REGNO (dest1) == REGNO (operands[1]))\n+    {\n+      operands[2] = dest2;\n+      operands[3] = operands[1];\n+      operands[4] = dest1;\n+      operands[5] = const0_rtx;\n+    }\n+  else\n+    {\n+      operands[2] = dest1;\n+      operands[3] = const0_rtx;\n+      operands[4] = dest2;\n+      operands[5] = operands[1];\n+    }\n+}\")\n+\n ;; Simplify comparisons of extended values.\n \n (define_insn \"*cmp_zero_extendqisi2\""}]}