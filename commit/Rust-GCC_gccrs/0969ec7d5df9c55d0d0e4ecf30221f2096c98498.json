{"sha": "0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk2OWVjN2Q1ZGY5YzU1ZDBkMGU0ZWNmMzAyMjFmMjA5NmM5ODQ5OA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2015-01-06T08:50:12Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2015-01-06T08:50:12Z"}, "message": "configure.ac: Add Visium support.\n\n\t* configure.ac: Add Visium support.\n\t* configure: Regenerate.\nlibgcc/\n\t* config.host: Add Visium support.\n\t* config/visium: New directory.\ngcc/\n\t* config.gcc: Add Visium support.\n\t* configure.ac: Likewise.\n\t* configure: Regenerate.\n\t* doc/extend.texi (interrupt attribute): Add Visium.\n\t* doc/invoke.texi: Document Visium options.\n\t* doc/install.texi: Document Visium target.\n\t* doc/md.texi: Document Visium constraints.\n\t* common/config/visium: New directory.\n\t* config/visium: Likewise.\ngcc/testsuite/\n\t* lib/target-supports.exp (check_profiling_available): Return 0 for\n\tVisium.\n\t(check_effective_target_tls_runtime): Likewise.\n\t(check_effective_target_logical_op_short_circuit): Return 1 for Visium.\n\t* gcc.dg/20020312-2.c: Adjust for Visium.\n\t* gcc.dg/tls/thr-cse-1.c: Likewise\n\t* gcc.dg/tree-ssa/20040204-1.c: Likewise\n\t* gcc.dg/tree-ssa/loop-1.c: Likewise.\n\t* gcc.dg/weak/typeof-2.c: Likewise.\n\nFrom-SVN: r219219", "tree": {"sha": "0edeb5eefb9376aad7c7391332316f9d2fd7e437", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0edeb5eefb9376aad7c7391332316f9d2fd7e437"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/comments", "author": null, "committer": null, "parents": [{"sha": "9bd59e280ccdce94cf8bcffc753d073e20adf458", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bd59e280ccdce94cf8bcffc753d073e20adf458", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bd59e280ccdce94cf8bcffc753d073e20adf458"}], "stats": {"total": 11843, "additions": 11829, "deletions": 14}, "files": [{"sha": "f5834a66180aff9221ac22244b8952eed5978f4e", "filename": "ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -1,3 +1,8 @@\n+2015-01-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* configure.ac: Add Visium support.\n+\t* configure: Regenerate.\n+\n 2015-01-04  Andreas Schwab  <schwab@linux-m68k.org>\n \n \t* configure.ac: Use OBJCOPY for OBJCOPY_FOR_TARGET."}, {"sha": "a69a64d2486f84633f1022b0687ce280b04c90fc", "filename": "configure", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -3317,6 +3317,10 @@ case \"${target}\" in\n     # for explicit misaligned loads.\n     noconfigdirs=\"$noconfigdirs target-libssp\"\n     ;;\n+  visium-*-*)\n+    # No hosted I/O support.\n+    noconfigdirs=\"$noconfigdirs target-libssp\"\n+    ;;\n esac\n \n # Disable libstdc++-v3 for some systems."}, {"sha": "7c51079aa6adfc8dad5ff7f7b1f6666b75b60691", "filename": "configure.ac", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -667,6 +667,10 @@ case \"${target}\" in\n     # for explicit misaligned loads.\n     noconfigdirs=\"$noconfigdirs target-libssp\"\n     ;;\n+  visium-*-*)\n+    # No hosted I/O support.\n+    noconfigdirs=\"$noconfigdirs target-libssp\"\n+    ;;\n esac\n \n # Disable libstdc++-v3 for some systems."}, {"sha": "812f980938b9fbe6204e8a4d02b9e82848bff0b8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -1,3 +1,15 @@\n+2015-01-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* config.gcc: Add Visium support.\n+\t* configure.ac: Likewise.\n+\t* configure: Regenerate.\n+\t* doc/extend.texi (interrupt attribute): Add Visium.\n+\t* doc/invoke.texi: Document Visium options.\n+\t* doc/install.texi: Document Visium target.\n+\t* doc/md.texi: Document Visium constraints.\n+\t* common/config/visium: New directory.\n+\t* config/visium: Likewise.\n+\n 2015-01-05  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* simplify-rtx.c (simplify_binary_operation_1): Handle more cases"}, {"sha": "ce4541cd321e0fea4379865b4e5164f7926db2ce", "filename": "gcc/common/config/visium/visium-common.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fcommon%2Fconfig%2Fvisium%2Fvisium-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fcommon%2Fconfig%2Fvisium%2Fvisium-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fvisium%2Fvisium-common.c?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -0,0 +1,38 @@\n+/* Common hooks for Visium.\n+   Copyright (C) 2002-2015 Free Software Foundation, Inc.\n+   Contributed by C.Nettleton,J.P.Parkes and P.Garbett.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"common/common-target.h\"\n+#include \"common/common-target-def.h\"\n+\n+/* Set default optimization options.  */\n+static const struct default_options visium_option_optimization_table[] =\n+  {\n+    { OPT_LEVELS_1_PLUS, OPT_fomit_frame_pointer, NULL, 1 },\n+    { OPT_LEVELS_NONE, 0, NULL, 0 }\n+  };\n+\n+#undef TARGET_OPTION_OPTIMIZATION_TABLE\n+#define TARGET_OPTION_OPTIMIZATION_TABLE visium_option_optimization_table\n+\n+struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;"}, {"sha": "857b3b0bc952a8a723d992861d6886b4cff5ef9e", "filename": "gcc/config.gcc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -2888,6 +2888,10 @@ vax-*-openbsd*)\n \textra_options=\"${extra_options} openbsd.opt\"\n \tuse_collect2=yes\n \t;;\n+visium-*-elf*)\n+\ttm_file=\"dbxelf.h elfos.h ${tm_file} visium/elf.h newlib-stdint.h\"\n+\ttmake_file=\"visium/t-visium visium/t-crtstuff\"\n+\t;;\n xstormy16-*-elf)\n \t# For historical reasons, the target files omit the 'x'.\n \ttm_file=\"dbxelf.h elfos.h newlib-stdint.h stormy16/stormy16.h\""}, {"sha": "93900e89c33c71b1ab441f4ef461be4df28af2cf", "filename": "gcc/config/visium/constraints.md", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfig%2Fvisium%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfig%2Fvisium%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fconstraints.md?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -0,0 +1,83 @@\n+;; Constraint definitions for Visium.\n+;; Copyright (C) 2006-2015 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; Register constraints\n+\n+(define_register_constraint \"b\" \"MDB\"\n+  \"EAM register mdb\")\n+\n+(define_register_constraint \"c\" \"MDC\"\n+  \"EAM register mdc\")\n+\n+(define_register_constraint \"f\" \"TARGET_FPU ? FP_REGS : NO_REGS\"\n+  \"Floating point register\")\n+\n+(define_register_constraint \"k\" \"SIBCALL_REGS\"\n+  \"Register for sibcall optimization\")\n+\n+(define_register_constraint \"l\" \"LOW_REGS\"\n+  \"General register, but not r29, r30 and r31\")\n+\n+(define_register_constraint \"t\" \"R1\"\n+  \"Register r1\")\n+\n+(define_register_constraint \"u\" \"R2\"\n+  \"Register r2\")\n+\n+(define_register_constraint \"v\" \"R3\"\n+  \"Register r3\")\n+\n+;; Immediate integer operand constraints\n+\n+(define_constraint \"J\"\n+  \"Integer constant in the range 0 .. 65535 (16-bit immediate)\"\n+  (and (match_code \"const_int\")\n+       (match_test \"0 <= ival && ival <= 65535\")))\n+\n+(define_constraint \"K\"\n+  \"Integer constant in the range 1 .. 31 (5-bit immediate)\"\n+  (and (match_code \"const_int\")\n+       (match_test \"1 <= ival && ival <= 31\")))\n+\n+(define_constraint \"L\"\n+  \"Integer constant in the range -65535 .. -1 (16-bit negative immediate)\"\n+  (and (match_code \"const_int\")\n+       (match_test \"-65535 <= ival && ival <= -1\")))\n+\n+(define_constraint \"M\"\n+  \"Integer constant -1\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == -1\")))\n+\n+(define_constraint \"O\"\n+  \"Integer constant 0\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 0\")))\n+\n+(define_constraint \"P\"\n+  \"Integer constant 32\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 32\")))\n+\n+;; Immediate FP operand constraints\n+\n+(define_constraint \"G\"\n+  \"Floating-point constant 0.0\"\n+  (and (match_code \"const_double\")\n+       (match_test \"op == CONST0_RTX (mode)\")))"}, {"sha": "713773daacc43b3e179e71265516634663b2eb36", "filename": "gcc/config/visium/elf.h", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfig%2Fvisium%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfig%2Fvisium%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Felf.h?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -0,0 +1,25 @@\n+/* ELF-specific defines for Visium.\n+   Copyright (C) 2005-2015 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+\n+/* Turn on DWARF-2 frame unwinding. */\n+#define INCOMING_FRAME_SP_OFFSET 0\n+#define INCOMING_RETURN_ADDR_RTX gen_rtx_REG (Pmode, LINK_REGNUM)\n+#define DWARF_FRAME_REGNUM(REGNO) (REGNO)\n+#define DWARF_FRAME_RETURN_COLUMN DWARF_FRAME_REGNUM (LINK_REGNUM)"}, {"sha": "9880b4d9bebf2f103cf3bc1a070ad14271104a59", "filename": "gcc/config/visium/gr5.md", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfig%2Fvisium%2Fgr5.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfig%2Fvisium%2Fgr5.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fgr5.md?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -0,0 +1,145 @@\n+;; Scheduling description for GR5.\n+;; Copyright (C) 2013-2015 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; GR5 is a single-issue processor.\n+\n+;; CPU execution units:\n+;;\n+;; issue                  Only one instruction can be issued on a given cycle.\n+;;                        There is no need to model the CPU pipeline in any\n+;;                        more detail than this.\n+;;\n+;; mem                    Memory Unit: all accesses to memory.\n+;;\n+;; eam                    Extended Arithmetic Module: multiply, divide and\n+;;                        64-bit shifts.\n+;;\n+;; fp_slot[0|1|2|3]       The 4 FIFO slots of the floating-point unit.  Only\n+;;                        the instruction at slot 0 can execute, but an FP\n+;;                        instruction can issue if any of the slots is free.\n+\n+(define_automaton \"gr5,gr5_fpu\")\n+\n+(define_cpu_unit \"gr5_issue\" \"gr5\")\n+(define_cpu_unit \"gr5_mem\" \"gr5\")\n+(define_cpu_unit \"gr5_eam\" \"gr5\")\n+(define_cpu_unit \"gr5_fp_slot0,gr5_fp_slot1,gr5_fp_slot2,gr5_fp_slot3\" \"gr5_fpu\")\n+\n+;; The CPU instructions which write to general registers and so do not totally\n+;; complete until they reach the store stage of the pipeline.  This is not the\n+;; complete storage register class: mem_reg, eam_reg and fpu_reg are excluded\n+;; since we must keep the reservation sets non-overlapping.\n+(define_insn_reservation \"gr5_storage_register\" 1\n+  (and (eq_attr \"cpu\" \"gr5\")\n+       (eq_attr \"type\" \"imm_reg,arith,arith2,logic,call\"))\n+  \"gr5_issue\")\n+\n+(define_insn_reservation \"gr5_read_mem\" 1\n+  (and (eq_attr \"cpu\" \"gr5\")\n+       (eq_attr \"type\" \"mem_reg\"))\n+  \"gr5_issue + gr5_mem\")\n+\n+;; The latency of 2 and the reservation of gr5_mem on the second cycle ensures\n+;; that no reads will be scheduled on the second cycle, which would otherwise\n+;; stall the pipeline for 1 cycle.\n+(define_insn_reservation \"gr5_write_mem\" 2\n+  (and (eq_attr \"cpu\" \"gr5\")\n+       (eq_attr \"type\" \"reg_mem\"))\n+  \"gr5_issue, gr5_mem\")\n+\n+;; Try to avoid the pipeline hazard of addressing off a register that has\n+;; not yet been stored.\n+(define_bypass 2 \"gr5_storage_register\" \"gr5_read_mem\"   \"gr5_hazard_bypass_p\")\n+(define_bypass 2 \"gr5_storage_register\" \"gr5_write_mem\"  \"gr5_hazard_bypass_p\")\n+(define_bypass 2 \"gr5_read_mem\"         \"gr5_read_mem\"   \"gr5_hazard_bypass_p\")\n+(define_bypass 2 \"gr5_read_mem\"         \"gr5_write_mem\"  \"gr5_hazard_bypass_p\")\n+\n+;; Other CPU instructions complete by the process stage.\n+(define_insn_reservation \"gr5_cpu_other\" 1\n+  (and (eq_attr \"cpu\" \"gr5\")\n+       (eq_attr \"type\" \"abs_branch,branch,cmp,ret,rfi,dsi,nop\"))\n+  \"gr5_issue\")\n+\n+;; EAM instructions.\n+\n+(define_insn_reservation \"gr5_write_eam\" 1\n+  (and (eq_attr \"cpu\" \"gr5\")\n+       (eq_attr \"type\" \"reg_eam\"))\n+  \"gr5_issue\")\n+\n+(define_reservation \"gr5_issue_eam\" \"(gr5_issue + gr5_eam)\")\n+\n+(define_insn_reservation \"gr5_read_eam\" 1\n+  (and (eq_attr \"cpu\" \"gr5\")\n+       (eq_attr \"type\" \"eam_reg\"))\n+  \"gr5_issue_eam\")\n+\n+;; Try to avoid the pipeline hazard of addressing off a register that has\n+;; not yet been stored.\n+(define_bypass 2 \"gr5_read_eam\" \"gr5_read_mem\"  \"gr5_hazard_bypass_p\")\n+(define_bypass 2 \"gr5_read_eam\" \"gr5_write_mem\" \"gr5_hazard_bypass_p\")\n+\n+(define_insn_reservation \"gr5_shiftdi\" 1\n+  (and (eq_attr \"cpu\" \"gr5\")\n+       (eq_attr \"type\" \"shiftdi\"))\n+  \"gr5_issue_eam\")\n+\n+(define_insn_reservation \"gr5_mul\" 3\n+  (and (eq_attr \"cpu\" \"gr5\")\n+       (eq_attr \"type\" \"mul\"))\n+  \"gr5_issue_eam, gr5_eam*2\")\n+\n+(define_insn_reservation \"gr5_div\" 34\n+  (and (eq_attr \"cpu\" \"gr5\")\n+       (eq_attr \"type\" \"div\"))\n+  \"gr5_issue_eam, gr5_eam*33\")\n+\n+(define_insn_reservation \"gr5_divd\" 66\n+  (and (eq_attr \"cpu\" \"gr5\")\n+       (eq_attr \"type\" \"divd\"))\n+  \"gr5_issue_eam, gr5_eam*65\")\n+\n+;; FPU instructions.\n+\n+(define_reservation \"gr5_fp_slotany\" \"(gr5_fp_slot0 | gr5_fp_slot1 | gr5_fp_slot2 | gr5_fp_slot3)\")\n+\n+(define_insn_reservation \"gr5_fp_other\" 1\n+  (and (eq_attr \"cpu\" \"gr5\")\n+       (eq_attr \"type\" \"fp_reg,reg_fp,fcmp\"))\n+  \"gr5_issue\")\n+\n+(define_insn_reservation \"gr5_fp_1cycle\" 2\n+  (and (eq_attr \"cpu\" \"gr5\")\n+       (eq_attr \"type\" \"fmove,ftoi\"))\n+  \"gr5_issue + gr5_fp_slotany, gr5_fp_slot0\")\n+\n+(define_insn_reservation \"gr5_fp_2cycle\" 3\n+  (and (eq_attr \"cpu\" \"gr5\")\n+       (eq_attr \"type\" \"itof\"))\n+  \"gr5_issue + gr5_fp_slotany, gr5_fp_slot0*2\")\n+\n+(define_insn_reservation \"gr5_fp_3cycle\" 4\n+  (and (eq_attr \"cpu\" \"gr5\")\n+       (eq_attr \"type\" \"fp\"))\n+  \"gr5_issue + gr5_fp_slotany, gr5_fp_slot0*3\")\n+\n+(define_insn_reservation \"gr5_fp_30cycle\" 31\n+  (and (eq_attr \"cpu\" \"gr5\")\n+       (eq_attr \"type\" \"fdiv,fsqrt\"))\n+  \"gr5_issue + gr5_fp_slotany, gr5_fp_slot0*30\")"}, {"sha": "3129045af18d5805672f6b05d35ba80c55455379", "filename": "gcc/config/visium/gr6.md", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfig%2Fvisium%2Fgr6.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfig%2Fvisium%2Fgr6.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fgr6.md?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -0,0 +1,186 @@\n+;; Scheduling description for GR6.\n+;; Copyright (C) 2013-2015 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; GR6 is a dual-issue, superscalar, out-of-order processor.\n+;;\n+;; The GR6 pipeline has 3 major components:\n+;;  1. The FETCH/DECODE/DISPATCH stages, an in-order front-end,\n+;;  2. The PROCESS stage, which is the out-of-order core,\n+;;  3. The STORE stage, an in-order register storage stage.\n+;;\n+;; The front-end and the back-end (PROCESS + STORE) are connected through a set\n+;; of reservation stations which, among other things, serve as buffers for the\n+;; decoded instructions.  The reservation stations are attached to a specific\n+;; execution unit of the PROCESS stage and the DISPATCH stage is responsible\n+;; for dispatching the decoded instructions to the appropriate stations.  Most\n+;; execution units have multiple reservation stations, thus making it possible\n+;; to dispatch two instructions per unit on a given cycle, but only one of them\n+;; can be executed on the next cycle.\n+;;\n+;; Since the core executes the instructions out of order, the most important\n+;; consideration for performance tuning is to make sure that enough decoded\n+;; instructions are ready for execution in the PROCESS stage while not stalling\n+;; the front-end, i.e while not trying to dispatch a decoded instruction to an\n+;; execution unit whose reservation stations are full.  Therefore, we do not\n+;; model the reservation stations (which is equivalent to pretending that there\n+;; is only one of them for each execution unit) but only the execution unit,\n+;; thus preserving some margin in case the unit itself stalls unexpectedly.\n+\n+;; CPU execution units:\n+;;\n+;; inst[1|2]             The front-end: 2 instructions can be issued on a given\n+;;                       cycle by the FETCH/DECODE/DISPATCH stages, except for\n+;;                       the Block Move instructions.\n+;;\n+;; mov                   Move Execution Unit: immediate moves into registers.\n+;;\n+;; alu[1|2]              The 2 Arithmetic and Logic Units: other instructions\n+;;                       operating on the registers.\n+;;\n+;; bru                   Branch Resolution Unit: all branches.\n+;;\n+;; mem_wr                Memory Write Unit: all writes to memory.\n+;;\n+;; mem_rd                Memory Read Unit: all reads from memory.\n+;;\n+;; mem_eam               EAM interface: reads and writes from and to the EAM\n+;;                       and reads from the FP registers.\n+;;\n+;; eam                   Extended Arithmetic Module: multiply, divide and\n+;;                       64-bit shifts.\n+;;\n+;; fpcu                  Floating-Point Compare Unit: FP comparisons.\n+;;\n+;; fpu[1|2|3|4]          The 4 Floating-Point Units: all other instructions\n+;;                       operating on the FP registers.\n+\n+(define_automaton \"gr6,gr6_fpu\")\n+\n+(define_cpu_unit \"gr6_inst1, gr6_inst2\" \"gr6\")\n+(define_cpu_unit \"gr6_mov\" \"gr6\")\n+(define_cpu_unit \"gr6_alu1,gr6_alu2\" \"gr6\")\n+(define_cpu_unit \"gr6_bru\" \"gr6\")\n+(define_cpu_unit \"gr6_mem_wr,gr6_mem_rd,gr6_mem_eam\" \"gr6\")\n+(define_cpu_unit \"gr6_eam\" \"gr6\")\n+(define_cpu_unit \"gr6_fpcu\" \"gr6\")\n+(define_cpu_unit \"gr6_fpu1,gr6_fpu2,gr6_fpu3,gr6_fpu4\" \"gr6_fpu\")\n+\n+(define_reservation \"gr6_issue\" \"(gr6_inst1 | gr6_inst2)\")\n+(define_reservation \"gr6_single_issue\" \"gr6_inst1 + gr6_inst2\")\n+\n+(define_insn_reservation \"gr6_immediate\" 1\n+  (and (eq_attr \"cpu\" \"gr6\")\n+       (eq_attr \"type\" \"imm_reg\"))\n+  \"gr6_issue + gr6_mov\")\n+\n+(define_insn_reservation \"gr6_alu\" 1\n+  (and (eq_attr \"cpu\" \"gr6\")\n+       (eq_attr \"type\" \"arith,arith2,logic,cmp\"))\n+  \"gr6_issue + (gr6_alu1 | gr6_alu2)\")\n+\n+(define_insn_reservation \"gr6_branch\" 1\n+  (and (eq_attr \"cpu\" \"gr6\")\n+       (eq_attr \"type\" \"abs_branch,branch,call,ret,rfi\"))\n+  \"gr6_issue + gr6_bru\")\n+\n+(define_insn_reservation \"gr6_block_move\" 16\n+  (and (eq_attr \"cpu\" \"gr6\")\n+       (eq_attr \"type\" \"bmi\"))\n+  \"gr6_single_issue*16\")\n+\n+(define_insn_reservation \"gr6_cpu_other\" 1\n+  (and (eq_attr \"cpu\" \"gr6\")\n+       (eq_attr \"type\" \"dsi,nop\"))\n+  \"gr6_issue\")\n+\n+(define_insn_reservation \"gr6_write_mem\" 1\n+  (and (eq_attr \"cpu\" \"gr6\")\n+       (eq_attr \"type\" \"reg_mem\"))\n+  \"gr6_issue + gr6_mem_wr\")\n+\n+(define_insn_reservation \"gr6_read_mem\" 6\n+  (and (eq_attr \"cpu\" \"gr6\")\n+       (eq_attr \"type\" \"mem_reg\"))\n+  \"gr6_issue + gr6_mem_rd, nothing*5\")\n+\n+;; EAM instructions.\n+\n+(define_insn_reservation \"gr6_write_eam\" 2\n+  (and (eq_attr \"cpu\" \"gr6\")\n+       (eq_attr \"type\" \"reg_eam\"))\n+  \"gr6_issue + gr6_mem_eam, nothing\")\n+\n+(define_reservation \"gr6_issue_eam\" \"gr6_issue + gr6_mem_eam + gr6_eam\")\n+\n+(define_insn_reservation \"gr6_read_eam\" 2\n+  (and (eq_attr \"cpu\" \"gr6\")\n+       (eq_attr \"type\" \"eam_reg\"))\n+  \"gr6_issue_eam, nothing\")\n+\n+(define_insn_reservation \"gr6_shiftdi\" 2\n+  (and (eq_attr \"cpu\" \"gr6\")\n+       (eq_attr \"type\" \"shiftdi\"))\n+  \"gr6_issue_eam, gr6_eam\")\n+\n+(define_insn_reservation \"gr6_mul\" 3\n+  (and (eq_attr \"cpu\" \"gr6\")\n+       (eq_attr \"type\" \"mul\"))\n+  \"gr6_issue_eam, gr6_eam*2\")\n+\n+(define_insn_reservation \"gr6_div\" 34\n+  (and (eq_attr \"cpu\" \"gr6\")\n+       (eq_attr \"type\" \"div\"))\n+  \"gr6_issue_eam, gr6_eam*33\")\n+\n+(define_insn_reservation \"gr6_divd\" 66\n+  (and (eq_attr \"cpu\" \"gr6\")\n+       (eq_attr \"type\" \"divd\"))\n+  \"gr6_issue_eam, gr6_eam*65\")\n+\n+;; FPU instructions.\n+\n+(define_insn_reservation \"gr6_read_fp\" 2\n+  (and (eq_attr \"cpu\" \"gr6\")\n+       (eq_attr \"type\" \"fp_reg\"))\n+  \"gr6_issue + gr6_mem_eam, nothing\")\n+\n+(define_insn_reservation \"gr6_cmp_fp\" 1\n+  (and (eq_attr \"cpu\" \"gr6\")\n+       (eq_attr \"type\" \"fcmp\"))\n+  \"gr6_issue + gr6_fpcu\")\n+\n+(define_insn_reservation \"gr6_fp_1cycle\" 1\n+  (and (eq_attr \"cpu\" \"gr6\")\n+       (eq_attr \"type\" \"fmove,ftoi,itof\"))\n+  \"gr6_issue + gr6_fpu1\")\n+\n+(define_insn_reservation \"gr6_fp_3cycle\" 3\n+  (and (eq_attr \"cpu\" \"gr6\")\n+       (eq_attr \"type\" \"fp\"))\n+  \"gr6_issue + gr6_fpu2, nothing*2\")\n+\n+(define_insn_reservation \"gr6_fp_17cycle\" 17\n+  (and (eq_attr \"cpu\" \"gr6\")\n+       (eq_attr \"type\" \"fdiv,fsqrt\"))\n+  \"gr6_issue + gr6_fpu3, gr6_fpu3*14, nothing*2\")\n+\n+(define_insn_reservation \"gr6_write_fp\" 1\n+  (and (eq_attr \"cpu\" \"gr6\")\n+       (eq_attr \"type\" \"reg_fp\"))\n+  \"gr6_issue + gr6_fpu4\")"}, {"sha": "66d282ea1ceb94438b2a6b68503fad53f749c434", "filename": "gcc/config/visium/predicates.md", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfig%2Fvisium%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfig%2Fvisium%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fpredicates.md?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -0,0 +1,157 @@\n+;; Predicate definitions for Visium.\n+;; Copyright (C) 2005-2015 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; Return true if OP is the constant 0.\n+(define_predicate \"const0_operand\"\n+  (and (match_code \"const_int,const_double\")\n+       (match_test \"op == CONST0_RTX (mode)\")))\n+\n+;; Return true if OP is a constant in the range 1 .. 31.\n+(define_predicate \"const_shift_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"1 <= INTVAL (op) && INTVAL (op) <= 31\")))\n+\n+;; Return true if OP is either a register or the constant 0.\n+(define_predicate \"reg_or_0_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"const0_operand\")))\n+\n+;; Return true if OP is either a register or a constant in the range 1 .. 31.\n+(define_predicate \"reg_or_shift_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"const_shift_operand\")))\n+\n+;; Return true if OP is either a register or the constant 32.\n+(define_predicate \"reg_or_32_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (and (match_code \"const_int\")\n+            (match_test \"INTVAL (op) == 32\"))))\n+\n+;; Return true if OP is a general register.\n+(define_predicate \"gpc_reg_operand\"\n+  (match_operand 0 \"register_operand\")\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    {\n+      op = SUBREG_REG (op);\n+      if (GET_CODE (op) != REG)\n+\treturn 1;\n+    }\n+\n+  unsigned int regno = REGNO (op);\n+  return (regno >= FIRST_PSEUDO_REGISTER\n+\t  || TEST_HARD_REG_BIT (reg_class_contents[GENERAL_REGS], regno));\n+})\n+\n+;; Return true if OP is the MDB register.\n+(define_predicate \"mdb_reg_operand\"\n+  (match_operand 0 \"register_operand\")\n+{\n+  unsigned int regno = reg_or_subreg_regno (op);\n+  return (regno == MDB_REGNUM);\n+})\n+\n+;; Return true if OP is the MDC register.\n+(define_predicate \"mdc_reg_operand\"\n+  (match_operand 0 \"register_operand\")\n+{\n+  unsigned int regno = reg_or_subreg_regno (op);\n+  return (regno == MDC_REGNUM);\n+})\n+\n+;; Return true if OP is an rvalue which is not an EAM register.\n+(define_predicate \"non_eam_src_operand\"\n+  (match_operand 0 \"general_operand\")\n+{\n+  unsigned int regno = reg_or_subreg_regno (op);\n+  return (regno != MDB_REGNUM && regno != MDC_REGNUM);\n+})\n+\n+;; Return true if OP is an lvalue which is not an EAM register.\n+(define_predicate \"non_eam_dst_operand\"\n+  (match_operand 0 \"nonimmediate_operand\")\n+{\n+  unsigned int regno = reg_or_subreg_regno (op);\n+  return (regno != MDB_REGNUM && regno != MDC_REGNUM);\n+})\n+\n+;; Return true if OP is a floating-point register.\n+(define_predicate \"fp_reg_operand\"\n+  (match_code \"reg\")\n+{\n+  unsigned int regno = REGNO (op);\n+  return (regno >= FIRST_PSEUDO_REGISTER || FP_REGISTER_P (regno));\n+})\n+\n+;; Return true if OP is a floating-point register or the constant 0.\n+(define_predicate \"fp_reg_or_0_operand\"\n+  (ior (match_operand 0 \"fp_reg_operand\")\n+       (match_operand 0 \"const0_operand\")))\n+\n+;; Return true if OP can be used as the second operand in a 32-bit or 64-bit\n+;; add or subtract instruction.  Note that adding a negative constant may be\n+;; transformed into subtracting a positive constant, and vice versa.\n+(define_predicate \"add_operand\"\n+  (ior (match_operand 0 \"gpc_reg_operand\")\n+       (and (match_code \"const_int\")\n+            (match_test (\"INTVAL (op) >= -65535 && INTVAL (op) <= 65535\")))))\n+\n+;; Return true if OP is (or could be) outside the range 0 .. 65535, which is\n+;; the range of the immediate operands, but accept -1 for NOT.\n+(define_predicate \"large_immediate_operand\"\n+  (ior (match_code \"const,label_ref,symbol_ref\")\n+       (and (match_code \"const_int\")\n+            (match_test (\"INTVAL (op) < -1 || INTVAL (op) > 65535\")))))\n+\n+;; Return true if OP is a valid FP comparison operator.\n+(define_predicate \"visium_fp_comparison_operator\"\n+  (match_code \"eq,ne,ordered,unordered,unlt,unle,ungt,unge,lt,le,gt,ge\"))\n+\n+;; Return true if OP is a valid comparison operator for CC_BTSTmode.\n+(define_special_predicate \"visium_btst_operator\"\n+  (match_code \"eq,ne\"))\n+\n+;; Return true if OP is a valid comparison operator for CC_NOOVmode.\n+(define_special_predicate \"visium_noov_operator\"\n+  (match_code \"eq,ne,ge,lt\"))\n+\n+;; Return true if OP is a valid comparison operator for a branch.  This allows\n+;; the use of MATCH_OPERATOR to recognize all the branch insns.\n+(define_predicate \"visium_branch_operator\"\n+  (match_operand 0 \"comparison_operator\")\n+{\n+  enum rtx_code code = GET_CODE (op);\n+  /* These 2 comparison codes are not supported.  */\n+  if (code == UNEQ || code == LTGT)\n+    return false;\n+  enum machine_mode cc_mode = GET_MODE (XEXP (op, 0));\n+  if (cc_mode == CC_NOOVmode)\n+    return visium_noov_operator (op, mode);\n+  if (cc_mode == CC_BTSTmode)\n+    return visium_btst_operator (op, mode);\n+  return true;\n+})\n+\n+;; Return true if OP is a valid comparison operator for an integer cstore.\n+(define_predicate \"visium_int_cstore_operator\"\n+  (match_code \"eq,ne,ltu,gtu,leu,geu\"))\n+\n+;; Return true if OP is a valid comparison operator for an FP cstore.\n+(define_predicate \"visium_fp_cstore_operator\"\n+  (match_code \"lt,gt,unge,unle\"))"}, {"sha": "e06141c349bdf6866361b12a58738584fa033998", "filename": "gcc/config/visium/t-visium", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfig%2Fvisium%2Ft-visium", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfig%2Fvisium%2Ft-visium", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Ft-visium?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -0,0 +1,21 @@\n+# Multilibs for Visium.\n+# Copyright (C) 2012-2015 Free Software Foundation, Inc.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+MULTILIB_OPTIONS = mcpu=gr6\n+MULTILIB_DIRNAMES = gr6"}, {"sha": "8aa30d6201e42197ca03d547ebe2e12a1216edc1", "filename": "gcc/config/visium/visium-modes.def", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfig%2Fvisium%2Fvisium-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfig%2Fvisium%2Fvisium-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium-modes.def?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -0,0 +1,37 @@\n+/* Machine description for Visium.\n+   Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Add any extra modes needed to represent the condition code.\n+\n+   On the Visium, we have a \"no-overflow\" mode which is used when arithmetic\n+   instructions set the condition code.  Different branches are used in this\n+   case for some operations.\n+\n+   We also have a \"bit-test\" mode which is used when the bit-test instruction\n+   sets the condition code.\n+\n+   We also have two modes to indicate that the condition code is set by the\n+   the floating-point unit.  One for comparisons which generate an exception\n+   if the result is unordered (CCFPEmode) and one for comparisons which never\n+   generate such an exception (CCFPmode).  */\n+\n+CC_MODE (CC_NOOV);\n+CC_MODE (CC_BTST);\n+CC_MODE (CCFP);\n+CC_MODE (CCFPE);"}, {"sha": "b438d520ab74dcb4948577fcf08d414a2116ef1c", "filename": "gcc/config/visium/visium-opts.h", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfig%2Fvisium%2Fvisium-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfig%2Fvisium%2Fvisium-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium-opts.h?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -0,0 +1,30 @@\n+/* Definitions for option handling for Visium.\n+   Copyright (C) 2005-2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef VISIUM_OPTS_H\n+#define VISIUM_OPTS_H\n+\n+/* Processor type.\n+   These must match the values for the cpu attribute in visium.md.  */\n+enum processor_type {\n+  PROCESSOR_GR5,\n+  PROCESSOR_GR6\n+};\n+\n+#endif"}, {"sha": "5f36f285f31250c9ad7f614d3ea5e646790a08a6", "filename": "gcc/config/visium/visium-protos.h", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfig%2Fvisium%2Fvisium-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfig%2Fvisium%2Fvisium-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium-protos.h?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -0,0 +1,66 @@\n+/* Prototypes of target machine for Visium.\n+   Copyright (C) 2002-2015 Free Software Foundation, Inc.\n+   Contributed by C.Nettleton,J.P.Parkes and P.Garbett.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_VISIUM_PROTOS_H\n+#define GCC_VISIUM_PROTOS_H\n+\n+extern unsigned int visium_data_alignment (tree, unsigned int);\n+extern void visium_init_expanders (void);\n+extern int visium_interrupt_function_p (void);\n+extern bool visium_can_use_return_insn_p (void);\n+extern void visium_expand_prologue (void);\n+extern void visium_expand_epilogue (void);\n+extern int visium_epilogue_uses (int);\n+extern void visium_profile_hook (void);\n+extern int visium_hard_regno_rename_ok (unsigned int, unsigned int);\n+extern int visium_initial_elimination_offset (int from, int to);\n+#ifdef RTX_CODE\n+extern void prepare_move_operands (rtx *, enum machine_mode);\n+extern bool ok_for_simple_move_operands (rtx *, enum machine_mode);\n+extern bool ok_for_simple_move_strict_operands (rtx *, enum machine_mode);\n+extern bool ok_for_simple_arith_logic_operands (rtx *, enum machine_mode);\n+extern void visium_initialize_trampoline (rtx, rtx, rtx);\n+extern int empty_delay_slot (rtx_insn *);\n+extern int gr5_hazard_bypass_p (rtx_insn *, rtx_insn *);\n+extern rtx visium_return_addr_rtx (int, rtx);\n+extern rtx visium_eh_return_handler_rtx (void);\n+extern rtx visium_dynamic_chain_address (rtx);\n+extern rtx visium_legitimize_reload_address (rtx, enum machine_mode, int, int,\n+\t\t\t\t\t     int);\n+extern enum machine_mode visium_select_cc_mode (enum rtx_code, rtx, rtx);\n+extern void visium_split_cbranch (enum rtx_code, rtx, rtx, rtx);\n+extern const char *output_ubranch (rtx, rtx_insn *);\n+extern const char *output_cbranch (rtx, enum rtx_code, enum machine_mode, int,\n+\t\t\t\t   rtx_insn *);\n+extern void notice_update_cc (rtx, rtx);\n+extern void print_operand (FILE *, rtx, int);\n+extern void print_operand_address (FILE *, rtx);\n+extern void split_double_move (rtx *, enum machine_mode);\n+extern void visium_expand_copysign (rtx *, enum machine_mode);\n+extern void visium_expand_int_cstore (rtx *, enum machine_mode);\n+extern void visium_expand_fp_cstore (rtx *, enum machine_mode);\n+extern void visium_split_cstore (enum rtx_code, rtx, rtx,\n+\t\t\t\t enum rtx_code, rtx, rtx);\n+extern int visium_expand_block_move (rtx *);\n+extern int visium_expand_block_set (rtx *);\n+extern unsigned int reg_or_subreg_regno (rtx);\n+#endif /* RTX_CODE */\n+\n+#endif"}, {"sha": "c8efd154286941bdf7f277ce5cf34cdc65fbbe68", "filename": "gcc/config/visium/visium.c", "status": "added", "additions": 4085, "deletions": 0, "changes": 4085, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfig%2Fvisium%2Fvisium.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfig%2Fvisium%2Fvisium.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.c?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498"}, {"sha": "d78e221c998a6c8d90757cceda539d5b99842261", "filename": "gcc/config/visium/visium.h", "status": "added", "additions": 1739, "deletions": 0, "changes": 1739, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfig%2Fvisium%2Fvisium.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfig%2Fvisium%2Fvisium.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.h?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -0,0 +1,1739 @@\n+/* Definitions of target machine for Visium.\n+   Copyright (C) 2002-2015 Free Software Foundation, Inc.\n+   Contributed by C.Nettleton, J.P.Parkes and P.Garbett.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+\n+/* Controlling the Compilation Driver, `gcc'  */\n+\n+/* Pass -mtune=* options to the assembler */\n+#undef ASM_SPEC\n+#define ASM_SPEC \"%{mcpu=gr6:-mtune=gr6; :-mtune=mcm}\"\n+\n+/* Define symbols for the preprocessor.  */\n+#define CPP_SPEC \"%{mcpu=gr6:-D__gr6__; :-D__gr5__}\"\n+\n+/* Targets of a link */\n+#define LIB_SPEC \"\\\n+%{msim   : --start-group -lc -lsim --end-group   ; \\\n+  mdebug : --start-group -lc -ldebug --end-group ; \\\n+         : -lc -lnosys }\"\n+\n+#define ENDFILE_SPEC \"crtend.o%s crtn.o%s\"\n+#define STARTFILE_SPEC \"crti.o%s crtbegin.o%s crt0.o%s\"\n+\n+/* Run-time Target Specification */\n+\n+/* TARGET_CPU_CPP_BUILTINS() This function-like macro expands to a\n+   block of code that defines built-in preprocessor macros and\n+   assertions for the target cpu, using the functions builtin_define,\n+   builtin_define_std and builtin_assert. When the front end calls\n+   this macro it provides a trailing semicolon, and since it has\n+   finished command line option processing your code can use those\n+   results freely.  builtin_assert takes a string in the form you pass\n+   to the command-line option -A, such as cpu=mips, and creates the\n+   assertion. builtin_define takes a string in the form accepted by\n+   option -D and unconditionally defines the macro.\n+\n+   builtin_define_std takes a string representing the name of an\n+   object-like macro. If it doesn't lie in the user's namespace,\n+   builtin_define_std defines it unconditionally. Otherwise, it\n+   defines a version with two leading underscores, and another version\n+   with two leading and trailing underscores, and defines the original\n+   only if an ISO standard was not requested on the command line. For\n+   example, passing unix defines __unix, __unix__ and possibly unix;\n+   passing _mips defines __mips, __mips__ and possibly _mips, and\n+   passing _ABI64 defines only _ABI64.\n+\n+   You can also test for the C dialect being compiled. The variable\n+   c_language is set to one of clk_c, clk_cplusplus or\n+   clk_objective_c. Note that if we are preprocessing assembler, this\n+   variable will be clk_c but the function-like macro\n+   preprocessing_asm_p() will return true, so you might want to check\n+   for that first.  If you need to check for strict ANSI, the variable\n+   flag_iso can be used. The function-like macro\n+   preprocessing_trad_p() can be used to check for traditional\n+   preprocessing.  */\n+#define TARGET_CPU_CPP_BUILTINS()\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      builtin_define (\"__VISIUM__\");\t\t\t\\\n+      if (TARGET_MCM)\t\t\t\t\t\\\n+\tbuiltin_define (\"__VISIUM_ARCH_MCM__\");\t\t\\\n+      if (TARGET_BMI)\t\t\t\t\t\\\n+\tbuiltin_define (\"__VISIUM_ARCH_BMI__\");\t\t\\\n+      if (TARGET_FPU_IEEE)\t\t\t\t\\\n+\tbuiltin_define (\"__VISIUM_ARCH_FPU_IEEE__\");\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* Recast the cpu class to be the cpu attribute.\n+   Every file includes us, but not every file includes insn-attr.h.  */\n+#define visium_cpu_attr ((enum attr_cpu) visium_cpu)\n+\n+/* Defining data structures for per-function information.\n+\n+   If the target needs to store information on a per-function basis,\n+   GCC provides a macro and a couple of variables to allow this. Note,\n+   just using statics to store the information is a bad idea, since\n+   GCC supports nested functions, so you can be halfway through\n+   encoding one function when another one comes along.\n+\n+   GCC defines a data structure called struct function which contains\n+   all of the data specific to an individual function. This structure\n+   contains a field called machine whose type is struct\n+   machine_function *, which can be used by targets to point to their\n+   own specific data.\n+\n+   If a target needs per-function specific data it should define the\n+   type struct machine_function and also the macro\n+   INIT_EXPANDERS. This macro should be used to initialize the\n+   function pointer init_machine_status.  This pointer is explained\n+   below.\n+\n+   One typical use of per-function, target specific data is to create\n+   an RTX to hold the register containing the function's return\n+   address.  This RTX can then be used to implement the\n+   __builtin_return_address function, for level 0.\n+\n+   Note--earlier implementations of GCC used a single data area to\n+   hold all of the per-function information. Thus when processing of a\n+   nested function began the old per-function data had to be pushed\n+   onto a stack, and when the processing was finished, it had to be\n+   popped off the stack.  GCC used to provide function pointers called\n+   save_machine_status and restore_machine_status to handle the saving\n+   and restoring of the target specific information. Since the single\n+   data area approach is no longer used, these pointers are no longer\n+   supported.\n+\n+   The macro and function pointers are described below. \n+\n+   INIT_EXPANDERS:\n+\n+   Macro called to initialize any target specific information. This\n+   macro is called once per function, before generation of any RTL has\n+   begun.  The intention of this macro is to allow the initialization\n+   of the function pointers below.\n+\n+   init_machine_status:\n+   This is a void (*)(struct function *) function pointer. If this\n+   pointer is non-NULL it will be called once per function, before\n+   function compilation starts, in order to allow the target to\n+   perform any target specific initialization of the struct function\n+   structure. It is intended that this would be used to initialize the\n+   machine of that structure.  struct machine_function structures are\n+   expected to be freed by GC.  Generally, any memory that they\n+   reference must be allocated by using ggc_alloc, including the\n+   structure itself. */\n+\n+#define INIT_EXPANDERS visium_init_expanders ()\n+\n+/* Storage Layout\n+\n+   Note that the definitions of the macros in this table which are\n+   sizes or alignments measured in bits do not need to be constant.\n+   They can be C expressions that refer to static variables, such as\n+   the `target_flags'.\n+\n+   `BITS_BIG_ENDIAN'\n+\n+   Define this macro to have the value 1 if the most significant bit\n+   in a byte has the lowest number; otherwise define it to have the\n+   value zero.  This means that bit-field instructions count from the\n+   most significant bit.  If the machine has no bit-field\n+   instructions, then this must still be defined, but it doesn't\n+   matter which value it is defined to.  This macro need not be a\n+   constant.\n+\n+   This macro does not affect the way structure fields are packed into\n+   bytes or words; that is controlled by `BYTES_BIG_ENDIAN'. */\n+#define BITS_BIG_ENDIAN 1\n+\n+/* `BYTES_BIG_ENDIAN'\n+\n+   Define this macro to have the value 1 if the most significant byte\n+   in a word has the lowest number.  This macro need not be a\n+   constant.*/\n+#define BYTES_BIG_ENDIAN 1\n+\n+/* `WORDS_BIG_ENDIAN'\n+\n+   Define this macro to have the value 1 if, in a multiword object,\n+   the most significant word has the lowest number.  This applies to\n+   both memory locations and registers; GNU CC fundamentally assumes\n+   that the order of words in memory is the same as the order in\n+   registers.  This macro need not be a constant.  */\n+#define WORDS_BIG_ENDIAN 1\n+\n+/* `BITS_PER_WORD'\n+\n+   Number of bits in a word; normally 32. */\n+#define BITS_PER_WORD 32\n+\n+/* `UNITS_PER_WORD'\n+\n+   Number of storage units in a word; normally 4. */\n+#define UNITS_PER_WORD 4\n+\n+/* `POINTER_SIZE'\n+\n+   Width of a pointer, in bits.  You must specify a value no wider\n+   than the width of `Pmode'.  If it is not equal to the width of\n+   `Pmode', you must define `POINTERS_EXTEND_UNSIGNED'.  */\n+#define POINTER_SIZE 32\n+\n+/* `PARM_BOUNDARY'\n+\n+   Normal alignment required for function parameters on the stack, in\n+   bits.  All stack parameters receive at least this much alignment\n+   regardless of data type.  On most machines, this is the same as the\n+   size of an integer. */\n+#define PARM_BOUNDARY 32\n+\n+/* `STACK_BOUNDARY'\n+\n+   Define this macro if you wish to preserve a certain alignment for\n+   the stack pointer.  The definition is a C expression for the\n+   desired alignment (measured in bits).\n+\n+   If `PUSH_ROUNDING' is not defined, the stack will always be aligned\n+   to the specified boundary.  If `PUSH_ROUNDING' is defined and\n+   specifies a less strict alignment than `STACK_BOUNDARY', the stack\n+   may be momentarily unaligned while pushing arguments. */\n+#define STACK_BOUNDARY 32\n+\n+#define VISIUM_STACK_ALIGN(LOC) (((LOC) + 3) & ~3)\n+\n+/* `FUNCTION_BOUNDARY'\n+\n+   Alignment required for a function entry point, in bits. */\n+#define FUNCTION_BOUNDARY 32\n+\n+/* `BIGGEST_ALIGNMENT'\n+\n+   Biggest alignment that any data type can require on this machine,\n+   in bits. */\n+#define BIGGEST_ALIGNMENT 32\n+\n+/* `DATA_ALIGNMENT (TYPE, BASIC-ALIGN)`\n+\n+   If defined, a C expression to compute the alignment for a variable\n+   in the static store.  TYPE is the data type, and BASIC-ALIGN is\n+   the alignment that the object would ordinarily have.  The value of\n+   this macro is used instead of that alignment to align the object. */\n+#define DATA_ALIGNMENT(TYPE,ALIGN) visium_data_alignment (TYPE, ALIGN)\n+\n+/* `CONSTANT_ALIGNMENT (CONSTANT, BASIC-ALIGN)`\n+\n+   If defined, a C expression to compute the alignment given to a\n+   constant that is being placed in memory.  CONSTANT is the constant\n+   and BASIC-ALIGN is the alignment that the object would ordinarily\n+   have.  The value of this macro is used instead of that alignment to\n+   align the object. */\n+#define CONSTANT_ALIGNMENT(EXP,ALIGN) \\\n+  visium_data_alignment (TREE_TYPE (EXP), ALIGN)\n+\n+/* `LOCAL_ALIGNMENT (TYPE, BASIC-ALIGN)`\n+\n+   If defined, a C expression to compute the alignment for a variable\n+   in the local store.  TYPE is the data type, and BASIC-ALIGN is the\n+   alignment that the object would ordinarily have.  The value of this\n+   macro is used instead of that alignment to align the object. */\n+#define LOCAL_ALIGNMENT(TYPE,ALIGN) visium_data_alignment (TYPE, ALIGN)\n+\n+/* `EMPTY_FIELD_BOUNDARY'\n+\n+   Alignment in bits to be given to a structure bit field that follows\n+   an empty field such as `int : 0;'.\n+\n+   Note that `PCC_BITFIELD_TYPE_MATTERS' also affects the alignment\n+   that results from an empty field. */\n+#define EMPTY_FIELD_BOUNDARY 32\n+\n+/* `STRICT_ALIGNMENT'\n+\n+   Define this macro to be the value 1 if instructions will fail to\n+   work if given data not on the nominal alignment.  If instructions\n+   will merely go slower in that case, define this macro as 0. */\n+#define STRICT_ALIGNMENT 1\n+\n+/* `TARGET_FLOAT_FORMAT'\n+\n+   A code distinguishing the floating point format of the target\n+   machine.  There are three defined values:\n+\n+   `IEEE_FLOAT_FORMAT'\n+          This code indicates IEEE floating point.  It is the default;\n+          there is no need to define this macro when the format is IEEE.\n+\n+    `VAX_FLOAT_FORMAT'\n+          This code indicates the peculiar format used on the Vax.\n+\n+    `UNKNOWN_FLOAT_FORMAT'\n+          This code indicates any other format.\n+\n+    The value of this macro is compared with `HOST_FLOAT_FORMAT' to\n+    determine whether the target machine has the same format as the\n+    host machine.  If any other formats are actually in use on\n+    supported machines, new codes should be defined for them.\n+\n+    The ordering of the component words of floating point values\n+    stored in memory is controlled by `FLOAT_WORDS_BIG_ENDIAN' for the\n+    target machine and `HOST_FLOAT_WORDS_BIG_ENDIAN' for the host. */\n+#define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n+#define UNITS_PER_HWFPVALUE 4\n+\n+/* Layout of Source Language Data Types\n+\n+   These macros define the sizes and other characteristics of the\n+   standard basic data types used in programs being compiled.  Unlike\n+   the macros in the previous section, these apply to specific\n+   features of C and related languages, rather than to fundamental\n+   aspects of storage layout. */\n+\n+/* `INT_TYPE_SIZE'\n+\n+   A C expression for the size in bits of the type `int' on the target\n+   machine.  If you don't define this, the default is one word. */\n+#define INT_TYPE_SIZE  32\n+\n+/* `SHORT_TYPE_SIZE'\n+\n+   A C expression for the size in bits of the type `short' on the\n+   target machine.  If you don't define this, the default is half a\n+   word.  (If this would be less than one storage unit, it is rounded\n+   up to one unit.) */\n+#define SHORT_TYPE_SIZE 16\n+\n+/* `LONG_TYPE_SIZE'\n+\n+   A C expression for the size in bits of the type `long' on the\n+   target machine.  If you don't define this, the default is one word. */\n+#define LONG_TYPE_SIZE  32\n+\n+/* `LONG_LONG_TYPE_SIZE'\n+\n+   A C expression for the size in bits of the type `long long' on the\n+   target machine.  If you don't define this, the default is two\n+   words.  If you want to support GNU Ada on your machine, the value\n+   of macro must be at least 64. */\n+#define LONG_LONG_TYPE_SIZE  64\n+\n+/* `CHAR_TYPE_SIZE'\n+\n+   A C expression for the size in bits of the type `char' on the\n+   target machine.  If you don't define this, the default is one\n+   quarter of a word.  (If this would be less than one storage unit,\n+   it is rounded up to one unit.) */\n+#define CHAR_TYPE_SIZE  8\n+\n+/* `FLOAT_TYPE_SIZE'\n+\n+   A C expression for the size in bits of the type `float' on the\n+   target machine.  If you don't define this, the default is one word. */\n+#define FLOAT_TYPE_SIZE  32\n+\n+/* `DOUBLE_TYPE_SIZE'\n+\n+   A C expression for the size in bits of the type `double' on the\n+   target machine.  If you don't define this, the default is two\n+   words. */\n+#define DOUBLE_TYPE_SIZE  64\n+\n+/* `LONG_DOUBLE_TYPE_SIZE'\n+\n+   A C expression for the size in bits of the type `long double' on\n+   the target machine.  If you don't define this, the default is two\n+   words. */\n+#define LONG_DOUBLE_TYPE_SIZE   DOUBLE_TYPE_SIZE\n+\n+/* `WIDEST_HARDWARE_FP_SIZE'\n+\n+   A C expression for the size in bits of the widest floating-point\n+   format supported by the hardware.  If you define this macro, you\n+   must specify a value less than or equal to the value of\n+   `LONG_DOUBLE_TYPE_SIZE'.  If you do not define this macro, the\n+   value of `LONG_DOUBLE_TYPE_SIZE' is the default. */\n+\n+/* `DEFAULT_SIGNED_CHAR'\n+\n+   An expression whose value is 1 or 0, according to whether the type\n+   `char' should be signed or unsigned by default.  The user can\n+   always override this default with the options `-fsigned-char' and\n+   `-funsigned-char'. */\n+#define DEFAULT_SIGNED_CHAR 0\n+\n+/* `SIZE_TYPE'\n+\n+   A C expression for a string describing the name of the data type to\n+   use for size values.  The typedef name `size_t' is defined using\n+   the contents of the string.\n+\n+   The string can contain more than one keyword.  If so, separate them\n+   with spaces, and write first any length keyword, then `unsigned' if\n+   appropriate, and finally `int'.  The string must exactly match one\n+   of the data type names defined in the function\n+   `init_decl_processing' in the file `c-decl.c'.  You may not omit\n+   `int' or change the order--that would cause the compiler to crash\n+   on startup.\n+\n+   If you don't define this macro, the default is `\"long unsigned\n+   int\"'. */\n+#define SIZE_TYPE \"unsigned int\"\n+\n+/* `PTRDIFF_TYPE'\n+\n+   A C expression for a string describing the name of the data type to\n+   use for the result of subtracting two pointers.  The typedef name\n+   `ptrdiff_t' is defined using the contents of the string.  See\n+   `SIZE_TYPE' above for more information.\n+\n+   If you don't define this macro, the default is `\"long int\"'. */\n+#define PTRDIFF_TYPE \"long int\"\n+\n+/* Newlib uses the unsigned type corresponding to ptrdiff_t for\n+   uintptr_t; this is the same as size_t for most newlib-using\n+   targets, but not for us.  */\n+#define UINTPTR_TYPE \"long unsigned int\"\n+\n+/* `WCHAR_TYPE'\n+\n+   A C expression for a string describing the name of the data type to\n+   use for wide characters.  The typedef name `wchar_t' is defined\n+   using the contents of the string.  See `SIZE_TYPE' above for more\n+   information.\n+\n+   If you don't define this macro, the default is `\"int\"'. */\n+#define WCHAR_TYPE \"short int\"\n+\n+/* `WCHAR_TYPE_SIZE'\n+\n+   A C expression for the size in bits of the data type for wide\n+   characters.  This is used in `cpp', which cannot make use of\n+   `WCHAR_TYPE'. */\n+#define WCHAR_TYPE_SIZE 16\n+\n+/* Register Usage\n+\n+   This section explains how to describe what registers the target\n+   machine has, and how (in general) they can be used.  */\n+\n+/* `FIRST_PSEUDO_REGISTER'\n+\n+   Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.\n+\n+   Register 51 is used as the argument pointer register.\n+   Register 52 is used as the soft frame pointer register.  */\n+#define FIRST_PSEUDO_REGISTER 53\n+\n+#define RETURN_REGNUM        1\n+#define PROLOGUE_TMP_REGNUM  9\n+#define LINK_REGNUM         21\n+#define GP_LAST_REGNUM      31\n+#define GP_REGISTER_P(REGNO) \\\n+  (((unsigned) (REGNO)) <= GP_LAST_REGNUM)\n+\n+#define MDB_REGNUM          32\n+#define MDC_REGNUM          33\n+\n+#define FP_FIRST_REGNUM     34\n+#define FP_LAST_REGNUM      49\n+#define FP_RETURN_REGNUM    (FP_FIRST_REGNUM + 1)\n+#define FP_REGISTER_P(REGNO) \\\n+  (FP_FIRST_REGNUM <= (REGNO) && (REGNO) <= FP_LAST_REGNUM)\n+\n+#define FLAGS_REGNUM        50\n+\n+/* `FIXED_REGISTERS'\n+\n+   An initializer that says which registers are used for fixed\n+   purposes all throughout the compiled code and are therefore not\n+   available for general allocation.  These would include the stack\n+   pointer, the frame pointer (except on machines where that can be\n+   used as a general register when no frame pointer is needed), the\n+   program counter on machines where that is considered one of the\n+   addressable registers, and any other numbered register with a\n+   standard use.\n+\n+   This information is expressed as a sequence of numbers, separated\n+   by commas and surrounded by braces.  The Nth number is 1 if\n+   register N is fixed, 0 otherwise.\n+\n+   The table initialized from this macro, and the table initialized by\n+   the following one, may be overridden at run time either\n+   automatically, by the actions of the macro\n+   `CONDITIONAL_REGISTER_USAGE', or by the user with the command\n+   options `-ffixed-REG', `-fcall-used-REG' and `-fcall-saved-REG'.\n+\n+   r0 and f0 are immutable registers hardwired to 0.\n+   r21 is the link register used for procedure linkage.\n+   r23 is the stack pointer register.\n+   r29 and r30 hold the interrupt context.\n+   mdc is a read-only register because the writemdc instruction\n+   terminates all the operations of the EAM on the GR6.  */\n+#define FIXED_REGISTERS  \\\n+ { 1, 0, 0, 0, 0, 0, 0, 0, /* r0 .. r7 */      \\\n+   0, 0, 0, 0, 0, 0, 0, 0, /* r8 .. r15 */     \\\n+   0, 0, 0, 0, 0, 1, 0, 1, /* r16 .. r23 */    \\\n+   0, 0, 0, 0, 0, 1, 1, 0, /* r24 .. r31 */    \\\n+   0, 1,                   /* mdb, mdc */      \\\n+   1, 0, 0, 0, 0, 0, 0, 0, /* f0 .. f7 */      \\\n+   0, 0, 0, 0, 0, 0, 0, 0, /* f8 .. f15 */     \\\n+   1, 1, 1 }               /* flags, arg, frame */\n+\n+/* `CALL_USED_REGISTERS'\n+\n+   Like `FIXED_REGISTERS' but has 1 for each register that is\n+   clobbered (in general) by function calls as well as for fixed\n+   registers.  This macro therefore identifies the registers that are\n+   not available for general allocation of values that must live\n+   across function calls.\n+\n+   If a register has 0 in `CALL_USED_REGISTERS', the compiler\n+   automatically saves it on function entry and restores it on\n+   function exit, if the register is used within the function.  */\n+#define CALL_USED_REGISTERS \\\n+ { 1, 1, 1, 1, 1, 1, 1, 1, /* r0 .. r7 */      \\\n+   1, 1, 1, 0, 0, 0, 0, 0, /* r8 .. r15 */     \\\n+   0, 0, 0, 0, 1, 1, 0, 1, /* r16 .. r23 */    \\\n+   1, 1, 1, 1, 1, 1, 1, 1, /* r24 .. r31 */    \\\n+   1, 1,                   /* mdb, mdc */      \\\n+   1, 1, 1, 1, 1, 1, 1, 1, /* f0 .. f7 */      \\\n+   1, 0, 0, 0, 0, 0, 0, 0, /* f8 .. f15 */     \\\n+   1, 1, 1 }               /* flags, arg, frame */\n+\n+/* Like `CALL_USED_REGISTERS' except this macro doesn't require that\n+   the entire set of `FIXED_REGISTERS' be included.\n+   (`CALL_USED_REGISTERS' must be a superset of `FIXED_REGISTERS').\n+   This macro is optional.  If not specified, it defaults to the value\n+   of `CALL_USED_REGISTERS'.  */\n+#define CALL_REALLY_USED_REGISTERS  \\\n+ { 0, 1, 1, 1, 1, 1, 1, 1, /* r0 .. r7 */      \\\n+   1, 1, 1, 0, 0, 0, 0, 0, /* r8 .. r15 */     \\\n+   0, 0, 0, 0, 1, 0, 0, 0, /* r16 .. r23 */    \\\n+   1, 1, 1, 1, 1, 0, 0, 1, /* r24 .. r31 */    \\\n+   1, 1,                   /* mdb, mdc */      \\\n+   1, 1, 1, 1, 1, 1, 1, 1, /* f0 .. f7 */      \\\n+   1, 0, 0, 0, 0, 0, 0, 0, /* f8 .. f15 */     \\\n+   1, 0, 0 }               /* flags, arg, frame */\n+\n+/* `REG_ALLOC_ORDER'\n+\n+   If defined, an initializer for a vector of integers, containing the\n+   numbers of hard registers in the order in which GCC should prefer\n+   to use them (from most preferred to least).\n+\n+   If this macro is not defined, registers are used lowest numbered\n+   first (all else being equal).  */\n+#define REG_ALLOC_ORDER \\\n+ { 10, 9, 8, 7, 6, 5, 4, 3, 2, 1,          /* r10 .. r1 */   \\\n+   11, 12, 13, 14, 15, 16, 17, 18, 19, 20, /* r11 .. r20 */  \\\n+   22,                                     /* fp */          \\\n+   24, 25, 26, 27, 28,                     /* r24 .. r28 */  \\\n+   31,                                     /* r31 */         \\\n+   32, 33,                                 /* mdb, mdc */    \\\n+   42, 41, 40, 39, 38, 37, 36, 35,         /* f8 .. f1 */    \\\n+   43, 44, 45, 46, 47, 48, 49,             /* f9 .. f15 */   \\\n+   21, 23,                                 /* lr, sp */      \\\n+   29, 30,                                 /* r29, r30 */    \\\n+   50, 51, 52,                             /* flags, arg, frame */ \\\n+   0, 34 }                                 /* r0, f0 */\n+\n+/* `HARD_REGNO_NREGS (REGNO, MODE)'\n+\n+   A C expression for the number of consecutive hard registers,\n+   starting at register number REGNO, required to hold a value of mode\n+   MODE.  */\n+#define HARD_REGNO_NREGS(REGNO, MODE) \\\n+  ((REGNO) == MDB_REGNUM ?                    \\\n+  ((GET_MODE_SIZE (MODE) + 2 * UNITS_PER_WORD - 1) / (2 * UNITS_PER_WORD)) \\\n+  : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\n+/* `HARD_REGNO_RENAME_OK (OLD_REG, NEW_REG)'\n+\n+   A C expression which is nonzero if hard register NEW_REG can be\n+   considered for use as a rename register for hard register OLD_REG. */\n+#define HARD_REGNO_RENAME_OK(OLD_REG, NEW_REG) \\\n+  visium_hard_regno_rename_ok (OLD_REG, NEW_REG)\n+\n+/*  `HARD_REGNO_MODE_OK (REGNO, MODE)'\n+\n+    A C expression that is nonzero if it is permissible to store a\n+    value of mode MODE in hard register number REGNO (or in several\n+    registers starting with that one). \n+\n+    Modes with sizes which cross from the one register class to the\n+    other cannot be allowed. Only single floats are allowed in the\n+    floating point registers, and only fixed point values in the EAM\n+    registers. */\n+#define HARD_REGNO_MODE_OK(REGNO, MODE)                         \\\n+ (GP_REGISTER_P (REGNO) ?                                       \\\n+     GP_REGISTER_P (REGNO + HARD_REGNO_NREGS (REGNO, MODE) - 1) \\\n+  : FP_REGISTER_P (REGNO) ?                                     \\\n+     (MODE) == SFmode || ((MODE) == SImode && TARGET_FPU_IEEE)  \\\n+  : GET_MODE_CLASS (MODE) == MODE_INT                           \\\n+    && HARD_REGNO_NREGS (REGNO, MODE) == 1)\n+\n+/* `MODES_TIEABLE_P (MODE1, MODE2)'\n+\n+   A C expression that is nonzero if a value of mode MODE1 is\n+   accessible in mode MODE2 without copying.\n+\n+   If `HARD_REGNO_MODE_OK (R, MODE1)' and `HARD_REGNO_MODE_OK (R,\n+   MODE2)' are always the same for any R, then `MODES_TIEABLE_P\n+   (MODE1, MODE2)' should be nonzero.  If they differ for any R, you\n+   should define this macro to return zero unless some other mechanism\n+   ensures the accessibility of the value in a narrower mode.\n+\n+   You should define this macro to return nonzero in as many cases as\n+   possible since doing so will allow GNU CC to perform better\n+   register allocation. */\n+#define MODES_TIEABLE_P(MODE1, MODE2) \\\n+  ((GET_MODE_CLASS (MODE1) == MODE_INT) \\\n+  && (GET_MODE_CLASS (MODE2) == MODE_INT))\n+\n+/* Register Classes\n+\n+   On many machines, the numbered registers are not all equivalent.\n+   For example, certain registers may not be allowed for indexed\n+   addressing; certain registers may not be allowed in some\n+   instructions.  These machine restrictions are described to the\n+   compiler using \"register classes\".\n+\n+   `enum reg_class'\n+\n+   An enumeral type that must be defined with all the register class\n+   names as enumeral values.  `NO_REGS' must be first.  `ALL_REGS'\n+   must be the last register class, followed by one more enumeral\n+   value, `LIM_REG_CLASSES', which is not a register class but rather\n+   tells how many classes there are.\n+\n+   Each register class has a number, which is the value of casting the\n+   class name to type `int'.  The number serves as an index in many of\n+   the tables described below. */\n+\n+enum reg_class\n+{\n+  NO_REGS,\n+  MDB,\n+  MDC,\n+  FP_REGS,\n+  FLAGS,\n+  R1,\n+  R2,\n+  R3,\n+  SIBCALL_REGS,\n+  LOW_REGS,\n+  GENERAL_REGS,\n+  ALL_REGS,\n+  LIM_REG_CLASSES\n+};\n+\n+/* `N_REG_CLASSES'\n+\n+   The number of distinct register classes, defined as follows.  */\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* `REG_CLASS_NAMES'\n+\n+   An initializer containing the names of the register classes as C\n+   string constants.  These names are used in writing some of the\n+   debugging dumps. */\n+#define REG_CLASS_NAMES \\\n+ {\"NO_REGS\", \"MDB\", \"MDC\", \"FP_REGS\", \"FLAGS\", \"R1\", \"R2\", \"R3\", \\\n+  \"SIBCALL_REGS\", \"LOW_REGS\", \"GENERAL_REGS\", \"ALL_REGS\"}\n+\n+/* `REG_CLASS_CONTENTS'\n+\n+   An initializer containing the contents of the register classes, as\n+   integers which are bit masks.  The Nth integer specifies the\n+   contents of class N.  The way the integer MASK is interpreted is\n+   that register R is in the class if `MASK & (1 << R)' is 1.\n+\n+   When the machine has more than 32 registers, an integer does not\n+   suffice.  Then the integers are replaced by sub-initializers,\n+   braced groupings containing several integers.  Each sub-initializer\n+   must be suitable as an initializer for the type `HARD_REG_SET'\n+   which is defined in `hard-reg-set.h'. */\n+#define REG_CLASS_CONTENTS {                     \\\n+    {0x00000000, 0x00000000}, /* NO_REGS */      \\\n+    {0x00000000, 0x00000001}, /* MDB */          \\\n+    {0x00000000, 0x00000002}, /* MDC */          \\\n+    {0x00000000, 0x0003fffc}, /* FP_REGS */      \\\n+    {0x00000000, 0x00040000}, /* FLAGS */        \\\n+    {0x00000002, 0x00000000}, /* R1 */           \\\n+    {0x00000004, 0x00000000}, /* R2 */           \\\n+    {0x00000008, 0x00000000}, /* R3 */           \\\n+    {0x000005ff, 0x00000000}, /* SIBCALL_REGS */ \\\n+    {0x1fffffff, 0x00000000}, /* LOW_REGS */     \\\n+    {0xffffffff, 0x00180000}, /* GENERAL_REGS */ \\\n+    {0xffffffff, 0x001fffff}} /* ALL_REGS */\n+\n+/* `REGNO_REG_CLASS (REGNO)'\n+\n+   A C expression whose value is a register class containing hard\n+   register REGNO.  In general there is more than one such class;\n+   choose a class which is \"minimal\", meaning that no smaller class\n+   also contains the register. */\n+#define REGNO_REG_CLASS(REGNO)                    \\\n+  ((REGNO) == MDB_REGNUM ? MDB :                  \\\n+   (REGNO) == MDC_REGNUM ? MDC :                  \\\n+   FP_REGISTER_P (REGNO) ? FP_REGS :              \\\n+   (REGNO) == FLAGS_REGNUM ? FLAGS :              \\\n+   (REGNO) == 1 ? R1 :                            \\\n+   (REGNO) == 2 ? R2 :                            \\\n+   (REGNO) == 3 ? R3 :                            \\\n+   (REGNO) <= 8 || (REGNO) == 10 ? SIBCALL_REGS : \\\n+   (REGNO) <= 28 ? LOW_REGS :                     \\\n+   GENERAL_REGS)\n+\n+/* `BASE_REG_CLASS'\n+\n+   A macro whose definition is the name of the class to which a valid\n+   base register must belong.  A base register is one used in an\n+   address which is the register value plus a displacement. */\n+#define BASE_REG_CLASS GENERAL_REGS\n+\n+#define BASE_REGISTER_P(REGNO)        \\\n+  (GP_REGISTER_P (REGNO)              \\\n+   || (REGNO) == ARG_POINTER_REGNUM   \\\n+   || (REGNO) == FRAME_POINTER_REGNUM)\n+\n+/* `INDEX_REG_CLASS'\n+\n+   A macro whose definition is the name of the class to which a valid\n+   index register must belong.  An index register is one used in an\n+   address where its value is either multiplied by a scale factor or\n+   added to another register (as well as added to a displacement). */\n+#define INDEX_REG_CLASS NO_REGS\n+\n+/* `REGNO_OK_FOR_BASE_P (NUM)'\n+\n+   A C expression which is nonzero if register number NUM is suitable\n+   for use as a base register in operand addresses.  It may be either\n+   a suitable hard register or a pseudo register that has been\n+   allocated such a hard register. */\n+#define REGNO_OK_FOR_BASE_P(REGNO) \\\n+  (BASE_REGISTER_P (REGNO) || BASE_REGISTER_P ((unsigned)reg_renumber[REGNO]))\n+\n+/* `REGNO_OK_FOR_INDEX_P (NUM)'\n+\n+   A C expression which is nonzero if register number NUM is suitable\n+   for use as an index register in operand addresses.  It may be\n+   either a suitable hard register or a pseudo register that has been\n+   allocated such a hard register.\n+\n+   The difference between an index register and a base register is\n+   that the index register may be scaled.  If an address involves the\n+   sum of two registers, neither one of them scaled, then either one\n+   may be labeled the \"base\" and the other the \"index\"; but whichever\n+   labeling is used must fit the machine's constraints of which\n+   registers may serve in each capacity.  The compiler will try both\n+   labelings, looking for one that is valid, and will reload one or\n+   both registers only if neither labeling works. */\n+#define REGNO_OK_FOR_INDEX_P(REGNO) 0\n+\n+/* `PREFERRED_RELOAD_CLASS (X, CLASS)'\n+\n+   A C expression that places additional restrictions on the register\n+   class to use when it is necessary to copy value X into a register\n+   in class CLASS.  The value is a register class; perhaps CLASS, or\n+   perhaps another, smaller class.\n+\n+   Sometimes returning a more restrictive class makes better code.\n+   For example, on the 68000, when X is an integer constant that is in\n+   range for a `moveq' instruction, the value of this macro is always\n+   `DATA_REGS' as long as CLASS includes the data registers.\n+   Requiring a data register guarantees that a `moveq' will be used.\n+\n+   If X is a `const_double', by returning `NO_REGS' you can force X\n+   into a memory constant.  This is useful on certain machines where\n+   immediate floating values cannot be loaded into certain kinds of\n+   registers. */\n+#define PREFERRED_RELOAD_CLASS(X,CLASS) CLASS\n+\n+/*  `CANNOT_CHANGE_MODE_CLASS (from, to, class)\n+\n+    If defined, a C expression that returns nonzero for a `class' for\n+    which a change from mode `from' to mode `to' is invalid.\n+\n+    It's not obvious from the above that MDB cannot change mode. However\n+    difficulties arise from expressions of the form\n+\n+    (subreg:SI (reg:DI R_MDB) 0)\n+ \n+    There is no way to convert that reference to a single machine\n+    register and, without the following definition, reload will quietly\n+    convert it to\n+ \n+     (reg:SI R_MDB)  */\n+#define CANNOT_CHANGE_MODE_CLASS(FROM,TO,CLASS) \\\n+  (CLASS == MDB ? (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO)) : 0)\n+\n+/* `CLASS_MAX_NREGS (CLASS, MODE)'\n+\n+   A C expression for the maximum number of consecutive registers of\n+   class CLASS needed to hold a value of mode MODE.\n+\n+   This is closely related to the macro `HARD_REGNO_NREGS'.  In fact,\n+   the value of the macro `CLASS_MAX_NREGS (CLASS, MODE)' should be\n+   the maximum value of `HARD_REGNO_NREGS (REGNO, MODE)' for all REGNO\n+   values in the class CLASS.\n+\n+   This macro helps control the handling of multiple-word values in\n+   the reload pass.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE)    \\\n+  ((CLASS) == MDB ?                     \\\n+  ((GET_MODE_SIZE (MODE) + 2 * UNITS_PER_WORD - 1) / (2 * UNITS_PER_WORD)) \\\n+  : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\n+/* Stack Layout and Calling Conventions\n+\n+   Basic Stack Layout\n+\n+   `STACK_GROWS_DOWNWARD'\n+   Define this macro if pushing a word onto the stack moves the stack\n+   pointer to a smaller address.  */\n+#define STACK_GROWS_DOWNWARD 1\n+\n+/* `STARTING_FRAME_OFFSET'\n+\n+   Offset from the frame pointer to the first local variable slot to\n+   be allocated.\n+\n+   If `FRAME_GROWS_DOWNWARD', find the next slot's offset by\n+   subtracting the first slot's length from `STARTING_FRAME_OFFSET'.\n+   Otherwise, it is found by adding the length of the first slot to\n+   the value `STARTING_FRAME_OFFSET'. */\n+#define STARTING_FRAME_OFFSET 0\n+\n+/* `FIRST_PARM_OFFSET (FUNDECL)'\n+\n+   Offset from the argument pointer register to the first argument's\n+   address.  On some machines it may depend on the data type of the\n+   function.\n+\n+   If `ARGS_GROW_DOWNWARD', this is the offset to the location above\n+   the first argument's address. */\n+#define FIRST_PARM_OFFSET(FNDECL) 0\n+\n+/* `DYNAMIC_CHAIN_ADDRESS (FRAMEADDR)'\n+\n+   A C expression whose value is RTL representing the address in a\n+   stack frame where the pointer to the caller's frame is stored.\n+   Assume that FRAMEADDR is an RTL expression for the address of the\n+   stack frame itself.\n+\n+   If you don't define this macro, the default is to return the value\n+   of FRAMEADDR--that is, the stack frame address is also the address\n+   of the stack word that points to the previous frame. */\n+#define DYNAMIC_CHAIN_ADDRESS(FRAMEADDR) \\\n+  visium_dynamic_chain_address (FRAMEADDR)\n+\n+/* `RETURN_ADDR_RTX (COUNT, FRAMEADDR)'\n+\n+   A C expression whose value is RTL representing the value of the\n+   return address for the frame COUNT steps up from the current frame,\n+   after the prologue.  FRAMEADDR is the frame pointer of the COUNT\n+   frame, or the frame pointer of the COUNT - 1 frame if\n+   `RETURN_ADDR_IN_PREVIOUS_FRAME' is defined.\n+\n+   The value of the expression must always be the correct address when\n+   COUNT is zero, but may be `NULL_RTX' if there is not way to\n+   determine the return address of other frames.  */\n+#define RETURN_ADDR_RTX(COUNT,FRAMEADDR) \\\n+  visium_return_addr_rtx (COUNT, FRAMEADDR)\n+\n+/* Exception Handling\n+\n+   `EH_RETURN_DATA_REGNO'\n+\n+   A C expression whose value is the Nth register number used for data\n+   by exception handlers or INVALID_REGNUM if fewer than N registers\n+   are available.\n+\n+   The exception handling library routines communicate with the\n+   exception handlers via a set of agreed upon registers. */\n+#define EH_RETURN_DATA_REGNO(N) ((N) < 4 ? (N) + 11 : INVALID_REGNUM)\n+#define EH_RETURN_STACKADJ_RTX gen_rtx_REG (SImode, 8)\n+#define EH_RETURN_HANDLER_RTX visium_eh_return_handler_rtx ()\n+\n+/* Registers That Address the Stack Frame\n+\n+   This discusses registers that address the stack frame.\n+\n+   `STACK_POINTER_REGNUM'\n+\n+   The register number of the stack pointer register, which must also\n+   be a fixed register according to `FIXED_REGISTERS'.  On most\n+   machines, the hardware determines which register this is. */\n+#define STACK_POINTER_REGNUM 23\n+\n+/* `FRAME_POINTER_REGNUM'\n+\n+   The register number of the frame pointer register, which is used to\n+   access automatic variables in the stack frame.  On some machines,\n+   the hardware determines which register this is.  On other machines,\n+   you can choose any register you wish for this purpose. */\n+#define FRAME_POINTER_REGNUM 52\n+\n+/* `HARD_FRAME_POINTER_REGNUM'\n+\n+   On some machines the offset between the frame pointer and starting\n+   offset of the automatic variables is not known until after register\n+   allocation has been done (for example, because the saved registers\n+   are between these two locations).  On those machines, define\n+   `FRAME_POINTER_REGNUM' the number of a special, fixed register to\n+   be used internally until the offset is known, and define\n+   `HARD_FRAME_POINTER_REGNUM' to be the actual hard register number\n+   used for the frame pointer.  */\n+#define HARD_FRAME_POINTER_REGNUM 22\n+\n+/* `ARG_POINTER_REGNUM'\n+\n+   The register number of the arg pointer register, which is used to\n+   access the function's argument list.  On some machines, this is the\n+   same as the frame pointer register.  On some machines, the hardware\n+   determines which register this is.  On other machines, you can\n+   choose any register you wish for this purpose.  If this is not the\n+   same register as the frame pointer register, then you must mark it\n+   as a fixed register according to `FIXED_REGISTERS', or arrange to\n+   be able to eliminate it (*note Elimination::.).  */\n+#define ARG_POINTER_REGNUM 51\n+\n+/* `STATIC_CHAIN_REGNUM'\n+   `STATIC_CHAIN_INCOMING_REGNUM'\n+\n+   Register numbers used for passing a function's static chain\n+   pointer.  If register windows are used, the register number as seen\n+   by the called function is `STATIC_CHAIN_INCOMING_REGNUM', while the\n+   register number as seen by the calling function is\n+   `STATIC_CHAIN_REGNUM'.  If these registers are the same,\n+   `STATIC_CHAIN_INCOMING_REGNUM' need not be defined.\n+\n+   The static chain register need not be a fixed register.\n+\n+   If the static chain is passed in memory, these macros should not be\n+   defined; instead, the next two macros should be defined. */\n+#define STATIC_CHAIN_REGNUM 20\n+\n+/* `ELIMINABLE_REGS'\n+\n+   If defined, this macro specifies a table of register pairs used to\n+   eliminate unneeded registers that point into the stack frame.  If\n+   it is not defined, the only elimination attempted by the compiler\n+   is to replace references to the frame pointer with references to\n+   the stack pointer.\n+\n+   The definition of this macro is a list of structure\n+   initializations, each of which specifies an original and\n+   replacement register.\n+\n+   On some machines, the position of the argument pointer is not known\n+   until the compilation is completed.  In such a case, a separate\n+   hard register must be used for the argument pointer.  This register\n+   can be eliminated by replacing it with either the frame pointer or\n+   the argument pointer, depending on whether or not the frame pointer\n+   has been eliminated.\n+\n+   Note that the elimination of the argument pointer with the stack\n+   pointer is specified first since that is the preferred elimination.  */\n+#define ELIMINABLE_REGS\t\t\t\t     \\\n+{{ ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t     \\\n+ { ARG_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM},   \\\n+ { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t     \\\n+ { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}\n+\n+/* `INITIAL_ELIMINATION_OFFSET (FROM-REG, TO-REG, OFFSET-VAR)'\n+\n+   This macro is similar to `INITIAL_FRAME_POINTER_OFFSET'.  It\n+   specifies the initial difference between the specified pair of\n+   registers.  This macro must be defined if `ELIMINABLE_REGS' is\n+   defined.  */\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n+  (OFFSET = visium_initial_elimination_offset (FROM, TO))\n+\n+/* Passing Function Arguments on the Stack\n+\n+   The macros in this section control how arguments are passed on the\n+   stack.  See the following section for other macros that control\n+   passing certain arguments in registers.\n+\n+   Passing Arguments in Registers\n+\n+   This section describes the macros which let you control how various\n+   types of arguments are passed in registers or how they are arranged\n+   in the stack.\n+\n+   Define the general purpose, and floating point registers used for\n+   passing arguments */\n+#define MAX_ARGS_IN_GP_REGISTERS 8\n+#define GP_ARG_FIRST 1\n+#define GP_ARG_LAST (GP_ARG_FIRST + MAX_ARGS_IN_GP_REGISTERS - 1)\n+#define MAX_ARGS_IN_FP_REGISTERS 8\n+#define FP_ARG_FIRST (FP_FIRST_REGNUM + 1)\n+#define FP_ARG_LAST (FP_ARG_FIRST + MAX_ARGS_IN_FP_REGISTERS - 1)\n+\n+/* Define a data type for recording info about an argument list during the\n+processing of that argument list. */\n+\n+struct visium_args\n+{\n+  /* The count of general registers used */\n+  int grcount;\n+  /* The count of floating registers used */\n+  int frcount;\n+  /* The number of stack words used by named arguments */\n+  int stack_words;\n+};\n+\n+/* `CUMULATIVE_ARGS'\n+\n+   A C type for declaring a variable that is used as the first\n+   argument of `FUNCTION_ARG' and other related values.  For some\n+   target machines, the type `int' suffices and can hold the number of\n+   bytes of argument so far.\n+\n+   There is no need to record in `CUMULATIVE_ARGS' anything about the\n+   arguments that have been passed on the stack.  The compiler has\n+   other variables to keep track of that.  For target machines on\n+   which all arguments are passed on the stack, there is no need to\n+   store anything in `CUMULATIVE_ARGS'; however, the data structure\n+   must exist and should not be empty, so use `int'. */\n+#define CUMULATIVE_ARGS struct visium_args\n+\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,FNDECL,N_NAMED_ARGS) \\\n+  do {                        \\\n+       (CUM).grcount = 0;     \\\n+       (CUM).frcount = 0;     \\\n+       (CUM).stack_words = 0; \\\n+     } while (0)\n+\n+/* `FUNCTION_ARG_REGNO_P (REGNO)'\n+\n+   A C expression that is nonzero if REGNO is the number of a hard\n+   register in which function arguments are sometimes passed.  This\n+   does *not* include implicit arguments such as the static chain and\n+   the structure-value address.  On many machines, no registers can be\n+   used for this purpose since all function arguments are pushed on\n+   the stack. */\n+#define FUNCTION_ARG_REGNO_P(N)               \t\\\n+  ((GP_ARG_FIRST <= (N) && (N) <= GP_ARG_LAST)\t\\\n+   || (TARGET_FPU && FP_ARG_FIRST <= (N) && (N) <= FP_ARG_LAST))\n+\n+/* `FUNCTION_VALUE_REGNO_P (REGNO)'\n+\n+   A C expression that is nonzero if REGNO is the number of a hard\n+   register in which the values of called function may come back.\n+\n+   A register whose use for returning values is limited to serving as\n+   the second of a pair (for a value of type `double', say) need not\n+   be recognized by this macro. If the machine has register windows,\n+   so that the caller and the called function use different registers\n+   for the return value, this macro should recognize only the caller's\n+   register numbers. */\n+#define FUNCTION_VALUE_REGNO_P(N) \\\n+  ((N) == RETURN_REGNUM || (TARGET_FPU && (N) == FP_RETURN_REGNUM))\n+\n+/* How Large Values Are Returned\n+\n+   When a function value's mode is `BLKmode' (and in some other\n+   cases), the value is not returned according to `FUNCTION_VALUE'.\n+   Instead, the caller passes the address of a block of memory in\n+   which the value should be stored.  This address is called the\n+   \"structure value address\".\n+\n+   This section describes how to control returning structure values in\n+   memory.\n+\n+   `DEFAULT_PCC_STRUCT_RETURN'\n+\n+   Define this macro to be 1 if all structure and union return values\n+   must be in memory.  Since this results in slower code, this should\n+   be defined only if needed for compatibility with other compilers or\n+   with an ABI.  If you define this macro to be 0, then the\n+   conventions used for structure and union return values are decided\n+   by the `RETURN_IN_MEMORY' macro.\n+\n+   If not defined, this defaults to the value 1. */\n+#define DEFAULT_PCC_STRUCT_RETURN 0\n+\n+/* `STRUCT_VALUE'\n+\n+   If the structure value address is not passed in a register, define\n+   `STRUCT_VALUE' as an expression returning an RTX for the place\n+   where the address is passed.  If it returns 0, the address is\n+   passed as an \"invisible\" first argument. */\n+#define STRUCT_VALUE 0\n+\n+/* Caller-Saves Register Allocation\n+\n+   If you enable it, GNU CC can save registers around function calls.\n+   This makes it possible to use call-clobbered registers to hold\n+   variables that must live across calls.\n+\n+   Function Entry and Exit\n+\n+   This section describes the macros that output function entry\n+   (\"prologue\") and exit (\"epilogue\") code.\n+\n+   `EXIT_IGNORE_STACK'\n+\n+   Define this macro as a C expression that is nonzero if the return\n+   instruction or the function epilogue ignores the value of the stack\n+   pointer; in other words, if it is safe to delete an instruction to\n+   adjust the stack pointer before a return from the function.\n+\n+   Note that this macro's value is relevant only for functions for\n+   which frame pointers are maintained.  It is never safe to delete a\n+   final stack adjustment in a function that has no frame pointer, and\n+   the compiler knows this regardless of `EXIT_IGNORE_STACK'. */\n+#define EXIT_IGNORE_STACK 1\n+\n+/* `EPILOGUE_USES (REGNO)'\n+\n+   Define this macro as a C expression that is nonzero for registers\n+   are used by the epilogue or the `return' pattern.  The stack and\n+   frame pointer registers are already be assumed to be used as\n+   needed. */\n+#define EPILOGUE_USES(REGNO) visium_epilogue_uses (REGNO)\n+\n+/* Generating Code for Profiling\n+\n+   These macros will help you generate code for profiling. */\n+\n+#define PROFILE_HOOK(LABEL) visium_profile_hook ()\n+#define FUNCTION_PROFILER(FILE, LABELNO) do {} while (0)\n+#define NO_PROFILE_COUNTERS 1\n+\n+/* Trampolines for Nested Functions\n+\n+   A trampoline is a small piece of code that is created at run time\n+   when the address of a nested function is taken. It normally resides\n+   on the stack, in the stack frame of the containing function. These\n+   macros tell GCC how to generate code to allocate and initialize a\n+   trampoline.\n+\n+   The instructions in the trampoline must do two things: load a\n+   constant address into the static chain register, and jump to the\n+   real address of the nested function. On CISC machines such as the\n+   m68k, this requires two instructions, a move immediate and a\n+   jump. Then the two addresses exist in the trampoline as word-long\n+   immediate operands. On RISC machines, it is often necessary to load\n+   each address into a register in two parts. Then pieces of each\n+   address form separate immediate operands.\n+\n+   The code generated to initialize the trampoline must store the\n+   variable parts--the static chain value and the function\n+   address--into the immediate operands of the instructions. On a CISC\n+   machine, this is simply a matter of copying each address to a\n+   memory reference at the proper offset from the start of the\n+   trampoline. On a RISC machine, it may be necessary to take out\n+   pieces of the address and store them separately.\n+\n+   On the Visium, the trampoline is\n+\n+\tmoviu\tr9,%u FUNCTION\n+\tmovil\tr9,%l FUNCTION\n+\tmoviu\tr20,%u STATIC\n+\tbra\ttr,r9,r0\n+\tmovil\tr20,%l STATIC\n+\n+    A difficulty is setting the correct instruction parity at run time.\n+\n+\n+    TRAMPOLINE_SIZE \n+    A C expression for the size in bytes of the trampoline, as an integer. */\n+#define TRAMPOLINE_SIZE 20\n+\n+/* Implicit calls to library routines\n+\n+   Avoid calling library routines (sqrtf) just to set `errno' to EDOM */\n+#define TARGET_EDOM 33\n+\n+/* Addressing Modes\n+\n+   `MAX_REGS_PER_ADDRESS'\n+\n+   A number, the maximum number of registers that can appear in a\n+   valid memory address.  Note that it is up to you to specify a value\n+   equal to the maximum number that `TARGET_LEGITIMATE_ADDRESS_P' would\n+   ever accept.  */\n+#define MAX_REGS_PER_ADDRESS 1\n+\n+/* `LEGITIMIZE_RELOAD_ADDRESS (X, MODE, OPNUM, TYPE, IND_LEVELS, WIN)'\n+\n+   A C compound statement that attempts to replace X, which is an\n+   address that needs reloading, with a valid memory address for an\n+   operand of mode MODE.  WIN will be a C statement label elsewhere\n+   in the code.  It is not necessary to define this macro, but it\n+   might be useful for performance reasons.  */\n+#define LEGITIMIZE_RELOAD_ADDRESS(AD, MODE, OPNUM, TYPE, IND, WIN) \t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  rtx new_x = visium_legitimize_reload_address ((AD), (MODE), (OPNUM),\t\\\n+\t\t\t\t\t(int) (TYPE), (IND));\t\t\\\n+  if (new_x)\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      (AD) = new_x;\t\t\t\t\t\t\t\\\n+      goto WIN;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* Given a comparison code (EQ, NE, etc.) and the operands of a COMPARE,\n+   return the mode to be used for the comparison.  */\n+#define SELECT_CC_MODE(OP,X,Y) visium_select_cc_mode ((OP), (X), (Y))\n+\n+/* Return nonzero if MODE implies a floating point inequality can be\n+   reversed.  For Visium this is always true because we have a full\n+   compliment of ordered and unordered comparisons, but until generic\n+   code knows how to reverse it correctly we keep the old definition.  */\n+#define REVERSIBLE_CC_MODE(MODE) ((MODE) != CCFPEmode && (MODE) != CCFPmode)\n+\n+/* `BRANCH_COST'\n+\n+   A C expression for the cost of a branch instruction.  A value of 1\n+   is the default; other values are interpreted relative to that.  */\n+#define BRANCH_COST(A,B)  10\n+\n+/* Override BRANCH_COST heuristics for complex logical ops.  */\n+#define LOGICAL_OP_NON_SHORT_CIRCUIT 0\n+\n+/* `SLOW_BYTE_ACCESS'\n+\n+   Define this macro as a C expression which is nonzero if accessing\n+   less than a word of memory (i.e. a `char' or a `short') is no\n+   faster than accessing a word of memory, i.e., if such access\n+   require more than one instruction or if there is no difference in\n+   cost between byte and (aligned) word loads.\n+\n+   When this macro is not defined, the compiler will access a field by\n+   finding the smallest containing object; when it is defined, a\n+   fullword load will be used if alignment permits.  Unless bytes\n+   accesses are faster than word accesses, using word accesses is\n+   preferable since it may eliminate subsequent memory access if\n+   subsequent accesses occur to other fields in the same word of the\n+   structure, but to different bytes. */\n+#define SLOW_BYTE_ACCESS 0\n+\n+/* `MOVE_RATIO (SPEED)`\n+\n+   The threshold of number of scalar memory-to-memory move insns,\n+   _below_ which a sequence of insns should be generated instead of a\n+   string move insn or a library call.  Increasing the value will\n+   always make code faster, but eventually incurs high cost in\n+   increased code size.\n+\n+   Since we have a movmemsi pattern, the default MOVE_RATIO is 2, which\n+   is too low given that movmemsi will invoke a libcall.  */\n+#define MOVE_RATIO(speed) ((speed) ? 9 : 3)\n+\n+/* `CLEAR_RATIO (SPEED)`\n+\n+   The threshold of number of scalar move insns, _below_ which a\n+   sequence of insns should be generated to clear memory instead of a\n+   string clear insn or a library call.  Increasing the value will\n+   always make code faster, but eventually incurs high cost in\n+   increased code size.\n+\n+   Since we have a setmemsi pattern, the default CLEAR_RATIO is 2, which\n+   is too low given that setmemsi will invoke a libcall.  */\n+#define CLEAR_RATIO(speed) ((speed) ? 13 : 5)\n+\n+/* `MOVE_MAX'\n+\n+   The maximum number of bytes that a single instruction can move\n+   quickly between memory and registers or between two memory\n+   locations. */\n+#define MOVE_MAX 4\n+\n+/* `MAX_MOVE_MAX'\n+\n+   The maximum number of bytes that a single instruction can move\n+   quickly between memory and registers or between two memory\n+   locations.  If this is undefined, the default is `MOVE_MAX'.\n+   Otherwise, it is the constant value that is the largest value that\n+   `MOVE_MAX' can have at run-time. */\n+#define MAX_MOVE_MAX 4\n+\n+/* `SHIFT_COUNT_TRUNCATED'\n+\n+   A C expression that is nonzero if on this machine the number of\n+   bits actually used for the count of a shift operation is equal to\n+   the number of bits needed to represent the size of the object being\n+   shifted.  When this macro is non-zero, the compiler will assume\n+   that it is safe to omit a sign-extend, zero-extend, and certain\n+   bitwise `and' instructions that truncates the count of a shift\n+   operation.  On machines that have instructions that act on\n+   bitfields at variable positions, which may include `bit test'\n+   instructions, a nonzero `SHIFT_COUNT_TRUNCATED' also enables\n+   deletion of truncations of the values that serve as arguments to\n+   bitfield instructions. */\n+#define SHIFT_COUNT_TRUNCATED 0\n+\n+/* `TRULY_NOOP_TRUNCATION (OUTPREC, INPREC)'\n+\n+   A C expression which is nonzero if on this machine it is safe to\n+   \"convert\" an integer of INPREC bits to one of OUTPREC bits (where\n+   OUTPREC is smaller than INPREC) by merely operating on it as if it\n+   had only OUTPREC bits.\n+\n+   On many machines, this expression can be 1.\n+\n+   When `TRULY_NOOP_TRUNCATION' returns 1 for a pair of sizes for\n+   modes for which `MODES_TIEABLE_P' is 0, suboptimal code can result.\n+   If this is the case, making `TRULY_NOOP_TRUNCATION' return 0 in\n+   such cases may improve things. */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* `STORE_FLAG_VALUE'\n+\n+   A C expression describing the value returned by a comparison\n+   operator with an integral mode and stored by a store-flag\n+   instruction (`sCOND') when the condition is true.  This description\n+   must apply to *all* the `sCOND' patterns and all the comparison\n+   operators whose results have a `MODE_INT' mode. */\n+#define STORE_FLAG_VALUE 1\n+\n+/* `Pmode'\n+\n+   An alias for the machine mode for pointers.  On most machines,\n+   define this to be the integer mode corresponding to the width of a\n+   hardware pointer; `SImode' on 32-bit machine or `DImode' on 64-bit\n+   machines.  On some machines you must define this to be one of the\n+   partial integer modes, such as `PSImode'.\n+\n+   The width of `Pmode' must be at least as large as the value of\n+   `POINTER_SIZE'.  If it is not equal, you must define the macro\n+   `POINTERS_EXTEND_UNSIGNED' to specify how pointers are extended to\n+   `Pmode'. */\n+#define Pmode SImode\n+\n+/* `FUNCTION_MODE'\n+\n+   An alias for the machine mode used for memory references to\n+   functions being called, in `call' RTL expressions.  On most\n+   machines this should be `QImode'. */\n+#define FUNCTION_MODE SImode\n+\n+/* `NO_IMPLICIT_EXTERN_C'\n+\n+   Define this macro if the system header files support C++ as well as\n+   C.  This macro inhibits the usual method of using system header\n+   files in C++, which is to pretend that the file's contents are\n+   enclosed in `extern \"C\" {...}'. */\n+#define NO_IMPLICIT_EXTERN_C\n+\n+/* Dividing the Output into Sections (Texts, Data, ...)\n+\n+   An object file is divided into sections containing different types\n+   of data.  In the most common case, there are three sections: the\n+   \"text section\", which holds instructions and read-only data; the\n+   \"data section\", which holds initialized writable data; and the \"bss\n+   section\", which holds uninitialized data.  Some systems have other\n+   kinds of sections.\n+\n+   `TEXT_SECTION_ASM_OP'\n+\n+   A C expression whose value is a string containing the assembler\n+   operation that should precede instructions and read-only data.\n+   Normally `\".text\"' is right. */\n+#define TEXT_SECTION_ASM_OP \"\\t.text\"\n+\n+/* `DATA_SECTION_ASM_OP'\n+\n+   A C expression whose value is a string containing the assembler\n+   operation to identify the following data as writable initialized\n+   data.  Normally `\".data\"' is right. */\n+#define DATA_SECTION_ASM_OP \"\\t.data\"\n+\n+/* `BSS_SECTION_ASM_OP'\n+\n+   If defined, a C expression whose value is a string containing the\n+   assembler operation to identify the following data as uninitialized\n+   global data.  If not defined, and neither `ASM_OUTPUT_BSS' nor\n+   `ASM_OUTPUT_ALIGNED_BSS' are defined, uninitialized global data\n+   will be output in the data section if `-fno-common' is passed,\n+   otherwise `ASM_OUTPUT_COMMON' will be used.\n+\n+   `EXTRA_SECTIONS'\n+\n+   A list of names for sections other than the standard two, which are\n+   `in_text' and `in_data'.  You need not define this macro on a\n+   system with no other sections (that GCC needs to use).\n+\n+   `EXTRA_SECTION_FUNCTIONS'\n+\n+   One or more functions to be defined in `varasm.c'.  These functions\n+   should do jobs analogous to those of `text_section' and\n+   `data_section', for your additional sections.  Do not define this\n+   macro if you do not define `EXTRA_SECTIONS'.\n+\n+   `JUMP_TABLES_IN_TEXT_SECTION' Define this macro if jump tables (for\n+   `tablejump' insns) should be output in the text section, along with\n+   the assembler instructions.  Otherwise, the readonly data section\n+   is used.\n+\n+   This macro is irrelevant if there is no separate readonly data\n+   section. */\n+#undef JUMP_TABLES_IN_TEXT_SECTION\n+\n+\n+/* The Overall Framework of an Assembler File\n+\n+   This describes the overall framework of an assembler file.\n+\n+   `ASM_COMMENT_START'\n+\n+   A C string constant describing how to begin a comment in the target\n+   assembler language.  The compiler assumes that the comment will end\n+   at the end of the line. */\n+#define ASM_COMMENT_START \";\"\n+\n+/* `ASM_APP_ON'\n+\n+   A C string constant for text to be output before each `asm'\n+   statement or group of consecutive ones.  Normally this is `\"#APP\"',\n+   which is a comment that has no effect on most assemblers but tells\n+   the GNU assembler that it must check the lines that follow for all\n+   valid assembler constructs. */\n+#define ASM_APP_ON \"#APP\\n\"\n+\n+/* `ASM_APP_OFF'\n+\n+   A C string constant for text to be output after each `asm'\n+   statement or group of consecutive ones.  Normally this is\n+   `\"#NO_APP\"', which tells the GNU assembler to resume making the\n+   time-saving assumptions that are valid for ordinary compiler\n+   output. */\n+#define ASM_APP_OFF \"#NO_APP\\n\"\n+\n+/* Output of Data\n+\n+   This describes data output.\n+\n+   Output and Generation of Labels\n+\n+   This is about outputting labels.\n+\n+   `ASM_OUTPUT_LABEL (STREAM, NAME)'\n+\n+   A C statement (sans semicolon) to output to the stdio stream STREAM\n+   the assembler definition of a label named NAME.  Use the expression\n+   `assemble_name (STREAM, NAME)' to output the name itself; before\n+   and after that, output the additional assembler syntax for defining\n+   the name, and a newline. */\n+#define ASM_OUTPUT_LABEL(STREAM,NAME)     \\\n+  do { assemble_name (STREAM, NAME); fputs (\":\\n\", STREAM); } while (0)\n+\n+/* Globalizing directive for a label */\n+#define GLOBAL_ASM_OP \"\\t.global \"\n+\n+/* `ASM_OUTPUT_LABELREF (STREAM, NAME)'\n+\n+   A C statement (sans semicolon) to output to the stdio stream STREAM\n+   a reference in assembler syntax to a label named NAME.  This should\n+   add `_' to the front of the name, if that is customary on your\n+   operating system, as it is in most Berkeley Unix systems.  This\n+   macro is used in `assemble_name'. */\n+#define ASM_OUTPUT_LABELREF(STREAM,NAME)  \\\n+  asm_fprintf (STREAM, \"%U%s\", NAME)\n+\n+/* Output of Assembler Instructions\n+\n+   This describes assembler instruction output.\n+\n+   `REGISTER_NAMES'\n+\n+   A C initializer containing the assembler's names for the machine\n+   registers, each one as a C string constant.  This is what\n+   translates register numbers in the compiler into assembler\n+   language. */\n+#define REGISTER_NAMES \\\n+ {\"r0\",  \"r1\",  \"r2\",  \"r3\",  \"r4\",  \"r5\",  \"r6\",  \"r7\",  \\\n+  \"r8\",  \"r9\",  \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\", \\\n+  \"r16\", \"r17\", \"r18\", \"r19\", \"r20\", \"r21\", \"fp\",  \"sp\",  \\\n+  \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\", \"r30\", \"r31\", \\\n+  \"mdb\", \"mdc\",                                           \\\n+  \"f0\",  \"f1\",  \"f2\",  \"f3\",  \"f4\",  \"f5\",  \"f6\",  \"f7\",  \\\n+  \"f8\",  \"f9\",  \"f10\", \"f11\", \"f12\", \"f13\", \"f14\", \"f15\", \\\n+  \"flags\",\"argp\",\"sfp\" }\n+\n+/* `ADDITIONAL_REGISTER_NAMES`\n+\n+   If defined, a C initializer for an array of structures containing\n+   a name and a register number.  This macro defines additional names\n+   for hard registers, thus allowing the `asm' option in declarations\n+   to refer to registers using alternate names.  */\n+#define ADDITIONAL_REGISTER_NAMES \\\n+  {{\"r22\", HARD_FRAME_POINTER_REGNUM}, {\"r23\", STACK_POINTER_REGNUM}}\n+\n+/* `PRINT_OPERAND (STREAM, X, CODE)'\n+\n+   A C compound statement to output to stdio stream STREAM the\n+   assembler syntax for an instruction operand X.  X is an RTL\n+   expression.\n+\n+   CODE is a value that can be used to specify one of several ways of\n+   printing the operand.  It is used when identical operands must be\n+   printed differently depending on the context.  CODE comes from the\n+   `%' specification that was used to request printing of the operand.\n+   If the specification was just `%DIGIT' then CODE is 0; if the\n+   specification was `%LTR DIGIT' then CODE is the ASCII code for LTR.\n+\n+   If X is a register, this macro should print the register's name.\n+   The names can be found in an array `reg_names' whose type is `char\n+   *[]'.  `reg_names' is initialized from `REGISTER_NAMES'.\n+\n+   When the machine description has a specification `%PUNCT' (a `%'\n+   followed by a punctuation character), this macro is called with a\n+   null pointer for X and the punctuation character for CODE. */\n+#define PRINT_OPERAND(STREAM, X, CODE) print_operand (STREAM, X, CODE)\n+\n+/* `PRINT_OPERAND_PUNCT_VALID_P (CODE)'\n+\n+   A C expression which evaluates to true if CODE is a valid\n+   punctuation character for use in the `PRINT_OPERAND' macro.  If\n+   `PRINT_OPERAND_PUNCT_VALID_P' is not defined, it means that no\n+   punctuation characters (except for the standard one, `%') are used */\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE) ((CODE) == '#')\n+\n+/* `PRINT_OPERAND_ADDRESS (STREAM, X)'\n+\n+   A C compound statement to output to stdio stream STREAM the\n+   assembler syntax for an instruction operand that is a memory\n+   reference whose address is X.  X is an RTL expression.\n+\n+   On some machines, the syntax for a symbolic address depends on the\n+   section that the address refers to.  On these machines, define the\n+   macro `ENCODE_SECTION_INFO' to store the information into the\n+   `symbol_ref', and then check for it here. */\n+#define PRINT_OPERAND_ADDRESS(STREAM, ADDR) \\\n+  print_operand_address (STREAM, ADDR)\n+\n+/* `REGISTER_PREFIX'\n+   `LOCAL_LABEL_PREFIX'\n+   `USER_LABEL_PREFIX'\n+   `IMMEDIATE_PREFIX'\n+\n+   If defined, C string expressions to be used for the `%R', `%L',\n+   `%U', and `%I' options of `asm_fprintf' (see `final.c').  These are\n+   useful when a single `md' file must support multiple assembler\n+   formats.  In that case, the various `tm.h' files can define these\n+   macros differently. */\n+#define REGISTER_PREFIX \"\"\n+#define LOCAL_LABEL_PREFIX \".\"\n+#define IMMEDIATE_PREFIX \"#\"\n+\n+/* `ASM_OUTPUT_REG_PUSH (STREAM, REGNO)'\n+\n+   A C expression to output to STREAM some assembler code which will\n+   push hard register number REGNO onto the stack.  The code need not\n+   be optimal, since this macro is used only when profiling. */\n+#define ASM_OUTPUT_REG_PUSH(STREAM,REGNO)  \\\n+  asm_fprintf (STREAM, \"\\tsubi    sp,4\\n\\twrite.l (sp),%s\\n\", \\\n+               reg_names[REGNO])\n+\n+/* `ASM_OUTPUT_REG_POP (STREAM, REGNO)'\n+\n+   A C expression to output to STREAM some assembler code which will\n+   pop hard register number REGNO off of the stack.  The code need not\n+   be optimal, since this macro is used only when profiling. */\n+#define ASM_OUTPUT_REG_POP(STREAM,REGNO)  \\\n+  asm_fprintf (STREAM, \"\\tread.l  %s,(sp)\\n\\taddi    sp,4\\n\", \\\n+               reg_names[REGNO])\n+\n+\n+/* Output of Dispatch Tables\n+\n+   This concerns dispatch tables.\n+\n+   `ASM_OUTPUT_ADDR_DIFF_ELT (STREAM, VALUE, REL)'\n+\n+   A C statement to output to the stdio stream STREAM an assembler\n+   pseudo-instruction to generate a difference between two labels.\n+   VALUE and REL are the numbers of two internal labels.  The\n+   definitions of these labels are output using\n+   `ASM_OUTPUT_INTERNAL_LABEL', and they must be printed in the same\n+   way here.\n+\n+   You must provide this macro on machines where the addresses in a\n+   dispatch table are relative to the table's own address.  If\n+   defined, GNU CC will also use this macro on all machines when\n+   producing PIC. */\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM,BODY,VALUE,REL)  \t\t\\\n+  switch (GET_MODE (BODY))\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+    case SImode:\t\t\t\t\t\t\t\\\n+      asm_fprintf ((STREAM), \"\\t.long\\t%LL%d-%LL%d\\n\", (VALUE),(REL));\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    case HImode:\t\t\t\t\t\t\t\\\n+      asm_fprintf ((STREAM), \"\\t.word\\t%LL%d-%LL%d\\n\", (VALUE),(REL));\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    case QImode:\t\t\t\t\t\t\t\\\n+      asm_fprintf ((STREAM), \"\\t.byte\\t%LL%d-%LL%d\\n\", (VALUE),(REL));\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    default:\t\t\t\t\t\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    }\n+\n+/* `ASM_OUTPUT_ADDR_VEC_ELT (STREAM, VALUE)'\n+\n+   This macro should be provided on machines where the addresses in a\n+   dispatch table are absolute.\n+\n+   The definition should be a C statement to output to the stdio\n+   stream STREAM an assembler pseudo-instruction to generate a\n+   reference to a label.  VALUE is the number of an internal label\n+   whose definition is output using `ASM_OUTPUT_INTERNAL_LABEL'. */\n+#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE)  \\\n+  asm_fprintf (STREAM, \"\\t.long   %LL%d\\n\", VALUE)\n+\n+/* `ASM_OUTPUT_CASE_END (STREAM, NUM, TABLE)'\n+\n+   Define this if something special must be output at the end of a\n+   jump-table. The definition should be a C statement to be executed\n+   after the assembler code for the table is written. It should write\n+   the appropriate code to stdio stream STREAM. The argument TABLE is\n+   the jump-table insn, and NUM is the label-number of the preceding\n+   label.\n+\n+   If this macro is not defined, nothing special is output at the end\n+   of a jump table.\n+\n+   Here we output a word of zero so that jump-tables can be seperated\n+   in reverse assembly. */\n+#define ASM_OUTPUT_CASE_END(STREAM, NUM, TABLE) \\\n+  asm_fprintf (STREAM, \"\\t.long   0\\n\");\n+\n+/* Assembler Commands for Alignment\n+\n+   This describes commands for alignment.\n+\n+   `ASM_OUTPUT_ALIGN_CODE (STREAM)'\n+\n+   A C expression to output text to align the location counter in the\n+   way that is desirable at a point in the code that is reached only\n+   by jumping.\n+\n+   This macro need not be defined if you don't want any special\n+   alignment to be done at such a time.  Most machine descriptions do\n+   not currently define the macro. */\n+#undef ASM_OUTPUT_ALIGN_CODE\n+\n+/* `ASM_OUTPUT_LOOP_ALIGN (STREAM)'\n+\n+   A C expression to output text to align the location counter in the\n+   way that is desirable at the beginning of a loop.\n+\n+   This macro need not be defined if you don't want any special\n+   alignment to be done at such a time.  Most machine descriptions do\n+   not currently define the macro. */\n+#undef ASM_OUTPUT_LOOP_ALIGN\n+\n+/* `ASM_OUTPUT_ALIGN (STREAM, POWER)'\n+\n+   A C statement to output to the stdio stream STREAM an assembler\n+   command to advance the location counter to a multiple of 2 to the\n+   POWER bytes.  POWER will be a C expression of type `int'. */\n+#define ASM_OUTPUT_ALIGN(STREAM,LOG)      \\\n+  if ((LOG) != 0)                       \\\n+    fprintf (STREAM, \"\\t.align  %d\\n\", (1<<(LOG)))\n+\n+/* `ASM_OUTPUT_MAX_SKIP_ALIGN (STREAM, POWER, MAX_SKIP)`\n+\n+   A C statement to output to the stdio stream STREAM an assembler\n+   command to advance the location counter to a multiple of 2 to the\n+   POWER bytes, but only if MAX_SKIP or fewer bytes are needed to\n+   satisfy the alignment request.  POWER and MAX_SKIP will be a C\n+   expression of type `int'. */\n+#define ASM_OUTPUT_MAX_SKIP_ALIGN(STREAM,LOG,MAX_SKIP)\t\t\t\\\n+  if ((LOG) != 0) {\t\t\t\t\t\t\t\\\n+    if ((MAX_SKIP) == 0) fprintf ((STREAM), \"\\t.p2align %d\\n\", (LOG));\t\\\n+    else {\t\t\t\t\t\t\t\t\\\n+      fprintf ((STREAM), \"\\t.p2align %d,,%d\\n\", (LOG), (MAX_SKIP));\t\\\n+      /* Make sure that we have at least 8-byte alignment if > 8-byte\t\\\n+\t alignment is preferred.  */\t\t\t\t\t\\\n+      if ((LOG) > 3\t\t\t\t\t\t\t\\\n+\t  && (1 << (LOG)) > ((MAX_SKIP) + 1)\t\t\t\t\\\n+\t  && (MAX_SKIP) >= 7)\t\t\t\t\t\t\\\n+\tfputs (\"\\t.p2align 3\\n\", (STREAM));\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  }\n+\n+/* Controlling Debugging Information Format\n+\n+   This describes how to specify debugging information.\n+\n+    mda is known to GDB, but not to GCC. */\n+#define DBX_REGISTER_NUMBER(REGNO) \\\n+  ((REGNO) > MDB_REGNUM ? (REGNO) + 1 : (REGNO))\n+\n+/* `DEBUGGER_AUTO_OFFSET (X)'\n+\n+   A C expression that returns the integer offset value for an\n+   automatic variable having address X (an RTL expression).  The\n+   default computation assumes that X is based on the frame-pointer\n+   and gives the offset from the frame-pointer.  This is required for\n+   targets that produce debugging output for DBX or COFF-style\n+   debugging output for SDB and allow the frame-pointer to be\n+   eliminated when the `-g' options is used. */\n+#define DEBUGGER_AUTO_OFFSET(X) \\\n+  (GET_CODE (X) == PLUS ? INTVAL (XEXP (X, 1)) : 0)\n+\n+/* Miscellaneous Parameters\n+\n+   `CASE_VECTOR_MODE'\n+\n+   An alias for a machine mode name.  This is the machine mode that\n+   elements of a jump-table should have. */\n+#define CASE_VECTOR_MODE SImode\n+\n+/* `CASE_VECTOR_PC_RELATIVE'\n+   Define this macro if jump-tables should contain relative addresses. */\n+#undef CASE_VECTOR_PC_RELATIVE\n+\n+/* This says how to output assembler code to declare an\n+   unitialised external linkage data object. */\n+#define ASM_OUTPUT_COMMON(STREAM, NAME, SIZE, ROUNDED)      \\\n+( fputs (\"\\n\\t.comm  \", (STREAM)),                        \\\n+  assemble_name ((STREAM), (NAME)),                         \\\n+  fprintf ((STREAM), \",\"HOST_WIDE_INT_PRINT_UNSIGNED\"\\n\", ROUNDED))\n+\n+/* This says how to output assembler code to declare an\n+   unitialised internal linkage data object. */\n+#define ASM_OUTPUT_LOCAL(STREAM, NAME, SIZE, ROUNDED)     \\\n+( fputs (\"\\n\\t.lcomm \", (STREAM)),                      \\\n+  assemble_name ((STREAM), (NAME)),                     \\\n+  fprintf ((STREAM), \",\"HOST_WIDE_INT_PRINT_UNSIGNED\"\\n\", ROUNDED))\n+\n+/* Prettify the assembly.  */\n+extern int visium_indent_opcode;\n+\n+#define ASM_OUTPUT_OPCODE(FILE, PTR)\t\\\n+  do {\t\t\t\t\t\\\n+    if (visium_indent_opcode)\t\t\\\n+      {\t\t\t\t\t\\\n+\tputc (' ', FILE);\t\t\\\n+\tvisium_indent_opcode = 0;\t\\\n+      }\t\t\t\t\t\\\n+  } while (0)"}, {"sha": "969cb887a6c1da274ed5c9d26a472ac92c3855ba", "filename": "gcc/config/visium/visium.md", "status": "added", "additions": 2749, "deletions": 0, "changes": 2749, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfig%2Fvisium%2Fvisium.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfig%2Fvisium%2Fvisium.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.md?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -0,0 +1,2749 @@\n+;; Machine description for Visium.\n+;; Copyright (C) 2002-2015 Free Software Foundation, Inc.\n+;; Contributed by C.Nettleton, J.P.Parkes and P.Garbett.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Extra register constraints are:\n+;;   'b'   EAM register mdb\n+;;   'c'   EAM register mdc\n+;;   'f'   Floating-point register\n+;;   'k'   Register that can be used as the target of a sibcall, i.e. call-used\n+;;         general register not clobbered in the epilogue: r1-r8 and r10\n+;;   'l'   Low general register, i.e. general register accessible in user mode\n+;;         on the GR6 and, consequently, that can be used as the target of a\n+;;         branch with prediction: r1-r28\n+;;   't'   Register r1\n+;;   'u'   Register r2\n+;;   'v'   Register r3\n+;;\n+;; Immediate integer operand constraints are:\n+;;   'J'  0 .. 65535     (16-bit immediate)\n+;;   'K'  1 .. 31        (5-bit immediate)\n+;;   'L'  -1 .. -65535   (16-bit negative immediate)\n+;;   'M'  -1             (minus one)\n+;;   'O'  0              (integer zero)\n+;;   'P'  32             (thirty two)\n+;;\n+;; Immediate FP operand constraints are:\n+;;   'G'  0.0            (floating-point zero)\n+;;\n+;; Operand substitution characters are:\n+;;   %#   delay slot follows, if empty, fill with NOP\n+;;   %b   LS 8 bits of immediate operand\n+;;   %w   LS 16 bits of immediate operand\n+;;   %u   MS 16 bits of immediate operand\n+;;   %r   register or zero (r0)\n+;;   %f   FP register or zero (f0)\n+;;   %d   second register in a pair\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+;; Registers by name.\n+(define_constants [\n+  (R_R1          1)\n+  (R_R2          2)\n+  (R_R3          3)\n+  (R_R4          4)\n+  (R_R5          5)\n+  (R_R6          6)\n+  (R_LINK\t21)\n+  (R_FP\t\t22)\n+  (R_SP\t\t23)\n+  (R_MDB\t32)\n+  (R_MDC\t33)\n+  (R_FLAGS\t50)\n+])\n+\n+;; UNSPEC usage.\n+(define_c_enum \"unspec\" [\n+  UNSPEC_MDBHI\n+  UNSPEC_FLOAD\n+  UNSPEC_FSTORE\n+  UNSPEC_ITOF\n+  UNSPEC_FTOI\n+  UNSPEC_NOP\n+])\n+\n+;; UNSPEC_VOLATILE usage.\n+(define_c_enum \"unspecv\" [\n+  UNSPECV_BLOCKAGE\n+  UNSPECV_DSI\n+])\n+\n+(include \"predicates.md\")\n+(include \"constraints.md\")\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Attributes.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+; Instruction type.\n+;\n+;imm_reg       Move of immediate value to register.\n+;mem_reg       Move from memory to register.\n+;eam_reg       Move from EAM to register.\n+;fp_reg        Move from FPU to register.\n+;reg_mem       Move from register to memory.\n+;reg_eam       Move from register to EAM.\n+;reg_fp        Move from register to FPU.\n+;arith         Arithmetic operation, result in register, sets overflow.\n+;arith2        Two successive arithmetic operations.\n+;logic         Logical operation, result in register, does not set overflow.\n+;abs_branch    Absolute branch.\n+;branch        Branch.\n+;bmi           Block move.\n+;call          Call to subprogram.\n+;ret           Return from subprogram.\n+;rfi           Return from interrupt.\n+;dsi           Disable interrupts.\n+;cmp           Compare or test.\n+;div           EAM 32/32 division.\n+;divd          EAM 64/32 division.\n+;mul           EAM 32 * 32 -> 64 multiplication.\n+;shiftdi       EAM 64 bit shift.\n+;fdiv          Floating point divide.\n+;fsqrt         Floating point square root.\n+;ftoi          Fix float to integer.\n+;itof          Float integer.\n+;fmove         Floating point move w/ or w/o change of sign: fmove, fabs, fneg.\n+;fcmp          Floating point compare or test.\n+;fp            Other floating point operations.\n+;nop           No operation.\n+;multi         Multiple instructions which split.\n+;asm           User asm instructions.\n+\n+(define_attr \"type\"\n+\"imm_reg,mem_reg,eam_reg,fp_reg,reg_mem,reg_eam,reg_fp,arith,arith2,logic,abs_branch,branch,bmi,call,ret,rfi,dsi,cmp,div,divd,mul,shiftdi,fdiv,fsqrt,ftoi,itof,fmove,fcmp,fp,nop,multi,asm\" (const_string \"logic\"))\n+\n+; Those insns that occupy 4 bytes.\n+(define_attr \"single_insn\" \"no,yes\"\n+  (if_then_else (eq_attr \"type\" \"arith2,rfi,multi\")\n+                (const_string \"no\")\n+                (const_string \"yes\")))\n+\n+; True if branch or call will be emitting a nop into its delay slot.\n+(define_attr \"empty_delay_slot\" \"false,true\"\n+  (symbol_ref \"(empty_delay_slot (insn)\n+\t\t? EMPTY_DELAY_SLOT_TRUE : EMPTY_DELAY_SLOT_FALSE)\"))\n+\n+; Length in bytes.\n+; The allowed range for the offset of short branches is [-131072;131068]\n+; and it is counted from the address of the insn so we need to subtract\n+; 8 for forward branches because (pc) points to the next insn for them.\n+(define_attr \"length\" \"\"\n+  (cond [(eq_attr \"type\" \"abs_branch,call,ret\")\n+           (if_then_else (eq_attr \"empty_delay_slot\" \"true\")\n+                         (const_int 8)\n+                         (const_int 4))\n+         (eq_attr \"type\" \"branch\")\n+           (if_then_else (leu (plus (minus (match_dup 0) (pc))\n+                                    (const_int 131060))\n+                              (const_int 262120))\n+                         (if_then_else (eq_attr \"empty_delay_slot\" \"true\")\n+                                       (const_int 8)\n+                                       (const_int 4))\n+                         (const_int 20))\n+         (eq_attr \"single_insn\" \"no\")\n+           (const_int 8)] (const_int 4)))\n+\n+(define_asm_attributes [(set_attr \"type\" \"asm\")])\n+\n+; Delay slots.\n+(define_delay (eq_attr \"type\" \"abs_branch,branch,call,ret\")\n+  [(and (eq_attr \"type\" \"!abs_branch,branch,call,ret,rfi,bmi,mul,div,divd,fdiv,fsqrt,asm\")\n+        (eq_attr \"single_insn\" \"yes\"))\n+    (nil) (nil)])\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Processor pipeline description.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+; Attribute for cpu type.\n+; These must match the values for enum processor_type in visium-opts.h.\n+(define_attr \"cpu\" \"gr5,gr6\" (const (symbol_ref \"visium_cpu_attr\")))\n+\n+(include \"gr5.md\")\n+(include \"gr6.md\")\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Iterators.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_mode_iterator QHI [QI HI])\n+(define_mode_iterator I [QI HI SI])\n+(define_mode_attr s [(QI \".b\") (HI \".w\") (SI \".l\")])\n+\n+; This code iterator allows signed and unsigned widening multiplications\n+; to use the same template.\n+(define_code_iterator any_extend [sign_extend zero_extend])\n+\n+; <u> expands to an empty string when doing a signed operation and\n+; \"u\" when doing an unsigned operation.\n+(define_code_attr u [(sign_extend \"\") (zero_extend \"u\")])\n+\n+; <su> is like <u>, but the signed form expands to \"s\" rather than \"\".\n+(define_code_attr su [(sign_extend \"s\") (zero_extend \"u\")])\n+\n+; This code iterator allows returns and simple returns to use the same template.\n+(define_code_iterator any_return [return simple_return])\n+(define_code_attr return_pred [(return \"visium_can_use_return_insn_p ()\")\n+\t\t\t       (simple_return \"!visium_interrupt_function_p ()\")])\n+(define_code_attr return_str [(return \"\") (simple_return \"simple_\")])\n+\n+; This code iterator allows integer and FP cstores to use the same template.\n+(define_code_iterator any_scc [ltu lt])\n+(define_code_attr scc_str [(ltu \"sltu\") (lt \"slt\")])\n+\n+;This code iterator allows cstore splitters to use the same template.\n+(define_code_iterator any_add [plus minus])\n+(define_code_attr add_op  [(plus \"PLUS\") (minus \"MINUS\")])\n+(define_code_attr add_str [(plus \"plus\") (minus \"minus\")])\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Substitutions.\n+;;\n+;; They are used to define the second instruction of the pairs required by\n+;; the postreload compare elimination pass, with a first variant for the\n+;; logical insns and a second variant for the arithmetic insns.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_subst \"flags_subst_logic\"\n+  [(set (match_operand 0 \"\") (match_operand 1 \"\"))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"\"\n+  [(set (match_dup 0) (match_dup 1))\n+   (set (reg:CC R_FLAGS)\n+\t(compare:CC (match_dup 1) (const_int 0)))])\n+\n+(define_subst_attr \"subst_logic\" \"flags_subst_logic\" \"_flags\" \"_set_flags\")\n+\n+(define_subst \"flags_subst_arith\"\n+  [(set (match_operand 0 \"\") (match_operand 1 \"\"))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"\"\n+  [(set (match_dup 0) (match_dup 1))\n+   (set (reg:CC_NOOV R_FLAGS)\n+\t(compare:CC_NOOV (match_dup 1) (const_int 0)))])\n+\n+(define_subst_attr \"subst_arith\" \"flags_subst_arith\" \"_flags\" \"_set_flags\")\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; QImode moves\n+;;\n+;; For moving among registers we use the move.b instruction.  This is\n+;; actually an OR instruction using an alias.  For moving between register\n+;; and memory we need the address of the memory location in a register.\n+;; However, we can accept an expression (reg + offset) where offset is in\n+;; the range 0 .. 31.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  prepare_move_operands (operands, QImode);\n+})\n+\n+(define_insn \"*movqi_insn\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r, m,?b,?c, r, r,r,r\")\n+        (match_operand:QI 1 \"general_operand\"      \" r,rO, r, r,?b,?c,i,m\"))]\n+  \"ok_for_simple_move_operands (operands, QImode)\"\n+  \"@\n+    #\n+    write.b %0,%r1\n+    writemd %1,r0\t\t;movqi ?b r\n+    writemdc %1\t\t;movqi ?c r\n+    readmda %0\t\t;movqi r ?b\n+    readmdc %0\t\t;movqi r ?c\n+    moviq   %0,%b1\t\t;movqi  r  i\n+    read.b  %0,%1\"\n+  [(set_attr \"type\" \"logic,reg_mem,reg_eam,reg_eam,eam_reg,eam_reg,imm_reg,mem_reg\")])\n+\n+(define_insn \"*movqi_insn<subst_logic>\"\n+  [(set (match_operand:QI 0 \"gpc_reg_operand\" \"=r\")\n+\t(match_operand:QI 1 \"gpc_reg_operand\" \"r\"))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"move.b  %0,%1\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+(define_split\n+  [(set (match_operand:QI 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:QI 1 \"gpc_reg_operand\" \"\"))]\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (match_dup 1))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+  \"\")\n+\n+(define_expand \"movstrictqi\"\n+  [(set (strict_low_part (match_operand:QI 0 \"register_operand\" \"\"))\n+\t(match_operand:QI 1 \"general_operand\"                   \"\"))]\n+  \"\")\n+\n+(define_insn \"*movstrictqi_insn\"\n+  [(set (strict_low_part (match_operand:QI 0 \"register_operand\" \"+r,r\"))\n+\t(match_operand:QI 1 \"general_operand\"                   \"rO,m\"))]\n+  \"ok_for_simple_move_strict_operands (operands, QImode)\"\n+  \"@\n+    #\n+    read.b  %0,%1\"\n+  [(set_attr \"type\" \"logic,mem_reg\")])\n+\n+(define_insn \"*movstrictqi_insn<subst_logic>\"\n+  [(set (strict_low_part (match_operand:QI 0 \"register_operand\" \"+r\"))\n+\t(match_operand:QI 1 \"reg_or_0_operand\"                  \"rO\"))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"move.b  %0,%r1\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+(define_split\n+  [(set (strict_low_part (match_operand:QI 0 \"register_operand\" \"\"))\n+\t(match_operand:QI 1 \"reg_or_0_operand\" \"\"))]\n+  \"reload_completed\"\n+  [(parallel [(set (strict_low_part (match_dup 0)) (match_dup 1))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+  \"\")\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; HImode moves\n+;;\n+;; For moving among registers we use the move.w instruction.  This is\n+;; actually an OR instruction using an alias.  For moving between register\n+;; and memory we need the address of the memory location in a register.\n+;; However, we can accept an expression (reg + offset) where offset is in\n+;; the range 0 .. 62 and is shifted right one place in the assembled \n+;; instruction.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  prepare_move_operands (operands, HImode);\n+})\n+\n+(define_insn \"*movhi_insn\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r, m,?b,?c, r, r,r,r\")\n+        (match_operand:HI 1 \"general_operand\"      \" r,rO, r, r,?b,?c,i,m\"))]\n+  \"ok_for_simple_move_operands (operands, HImode)\"\n+  \"@\n+    #\n+    write.w %0,%r1\n+    writemd %1,r0\t\t;movhi ?b r\n+    writemdc %1\t\t;movhi ?c r\n+    readmda %0\t\t;movhi r ?b\n+    readmdc %0\t\t;movhi r ?c\n+    moviq   %0,%w1\t\t;movhi  r  i\n+    read.w  %0,%1\"\n+  [(set_attr \"type\" \"logic,reg_mem,reg_eam,reg_eam,eam_reg,eam_reg,imm_reg,mem_reg\")])\n+\n+(define_insn \"*movhi_insn<subst_logic>\"\n+  [(set (match_operand:HI 0 \"gpc_reg_operand\" \"=r\")\n+\t(match_operand:HI 1 \"gpc_reg_operand\" \"r\"))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"move.w  %0,%1\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+(define_split\n+  [(set (match_operand:HI 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:HI 1 \"gpc_reg_operand\" \"\"))]\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (match_dup 1))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+  \"\")\n+\n+(define_expand \"movstricthi\"\n+  [(set (strict_low_part (match_operand:HI 0 \"register_operand\" \"\"))\n+\t(match_operand:HI 1 \"general_operand\"                   \"\"))]\n+  \"\")\n+\n+(define_insn \"*movstricthi_insn\"\n+  [(set (strict_low_part (match_operand:HI 0 \"register_operand\" \"+r,r,r\"))\n+\t(match_operand:HI 1 \"general_operand\"                   \" r,i,m\"))]\n+  \"ok_for_simple_move_strict_operands (operands, HImode)\"\n+  \"@\n+    #\n+    movil   %0,%w1\n+    read.w  %0,%1\"\n+  [(set_attr \"type\" \"logic,imm_reg,mem_reg\")])\n+\n+(define_insn \"*movstricthi_insn<subst_logic>\"\n+  [(set (strict_low_part (match_operand:HI 0 \"register_operand\" \"+r\"))\n+\t(match_operand:HI 1 \"register_operand\"                  \"r\"))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"move.w  %0,%1\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+(define_split\n+  [(set (strict_low_part (match_operand:HI 0 \"register_operand\" \"\"))\n+\t(match_operand:HI 1 \"register_operand\" \"\"))]\n+  \"reload_completed\"\n+  [(parallel [(set (strict_low_part (match_dup 0)) (match_dup 1))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+  \"\")\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; SImode moves\n+;;\n+;; For moving among registers we use the move.l instruction.  This is\n+;; actually an OR instruction using an alias.  For moving between register\n+;; and memory we need the address of the memory location in a register.\n+;; However, we can accept an expression (reg + offset) where offset is in\n+;; the range 0 .. 124 and is shifted right two places in the assembled \n+;; instruction.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  prepare_move_operands (operands, SImode);\n+})\n+\n+(define_insn \"*movsi_high\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\") \n+        (high:SI (match_operand:SI 1 \"immediate_operand\" \"n,i\")) )]\n+  \"\"\n+  \"@\n+    moviu   %0,%u1\n+    moviu   %0,%%u %a1\"\n+  [(set_attr \"type\" \"imm_reg\")])\n+\n+; We only care about the lower 16 bits of the constant \n+; being inserted into the upper 16 bits of the register.\n+(define_insn \"*moviu\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"gpc_reg_operand\" \"+r\")\n+                         (const_int 16)\n+                         (const_int 0))\n+        (match_operand:SI 1 \"const_int_operand\" \"n\"))]\n+  \"\"\n+  \"moviu   %0,%w1\"\n+  [(set_attr \"type\" \"imm_reg\")])\n+\n+(define_insn \"*movsi_losum\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\")\n+        (lo_sum:SI (match_operand:SI 1 \"gpc_reg_operand\" \"0,0\")\n+                   (match_operand:SI 2 \"immediate_operand\" \"n,i\")))]\n+  \"\"\n+  \"@\n+    movil   %0,%w2\n+    movil   %0,%%l %a2\"\n+  [(set_attr \"type\" \"imm_reg\")])\n+\n+(define_insn \"*movil\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"gpc_reg_operand\" \"+r\")\n+                         (const_int 16)\n+                         (const_int 16))\n+        (match_operand:SI 1 \"const_int_operand\" \"n\"))]\n+  \"\"\n+  \"movil   %0,%w1\"\n+  [(set_attr \"type\" \"imm_reg\")])\n+\n+(define_insn \"*movsi_insn_no_ieee\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r, m,?b,?c, r, r,r,r,r,r, r,!f\")\n+        (match_operand:SI 1 \"general_operand\"      \" r,rO, r, r,?b,?c,J,M,i,m,!f, r\"))]\n+  \"!TARGET_FPU_IEEE && ok_for_simple_move_operands (operands, SImode)\"\n+  \"@\n+    #\n+    write.l %0,%r1\n+    writemd %1,r0\t\t;movsi  ?b  r\n+    writemdc %1\t\t;movsi  ?c  r\n+    readmda %0\t\t;movsi  r  ?b\n+    readmdc %0\t\t;movsi  r  ?c\n+    moviq   %0,%1\t\t;movsi  r  J\n+    #\n+    #\t\t\t;movsi  r  i\n+    read.l  %0,%1\n+    fstore  %0,%1\n+    fload   %0,%1\"\n+  [(set_attr \"type\" \"logic,reg_mem,reg_eam,reg_eam,eam_reg,eam_reg,imm_reg,logic,multi,mem_reg,fp_reg,reg_fp\")])\n+\n+(define_insn \"*movsi_insn\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r, m,?b,?c, r, r,r,r,r,r, r,?f,f\")\n+        (match_operand:SI 1 \"general_operand\"      \" r,rO, r, r,?b,?c,J,M,i,m,?f, r,f\"))]\n+  \"TARGET_FPU_IEEE && ok_for_simple_move_operands (operands, SImode)\"\n+  \"@\n+    #\n+    write.l %0,%r1\n+    writemd %1,r0\t\t;movsi  ?b  r\n+    writemdc %1\t\t;movsi  ?c  r\n+    readmda %0\t\t;movsi  r  ?b\n+    readmdc %0\t\t;movsi  r  ?c\n+    moviq   %0,%1\t\t;movsi  r  J\n+    #\n+    #\t\t\t;movsi  r  i\n+    read.l  %0,%1\n+    fstore  %0,%1\n+    fload   %0,%1\n+    fmove   %0,%1\"\n+  [(set_attr \"type\" \"logic,reg_mem,reg_eam,reg_eam,eam_reg,eam_reg,imm_reg,logic,multi,mem_reg,fp_reg,reg_fp,fmove\")])\n+\n+(define_insn \"*movsi_insn<subst_logic>\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n+\t(match_operand:SI 1 \"gpc_reg_operand\" \"r\"))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"move.l  %0,%1\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+(define_insn \"*movsi_insn_m1<subst_logic>\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n+\t(const_int -1))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"not.l   %0,r0\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:SI 1 \"gpc_reg_operand\" \"\"))]\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (match_dup 1))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n+\t(const_int -1))]\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (const_int -1))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+  \"\")\n+\n+(define_insn \"*movsi_mdbhi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (unspec:SI [(reg:DI R_MDB)] UNSPEC_MDBHI))]\n+  \"\"\n+  \"readmdb %0\"\n+  [(set_attr \"type\" \"eam_reg\")])\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n+        (match_operand:SI 1 \"large_immediate_operand\" \"\"))]\n+  \"reload_completed\"\n+  [(set (match_dup 0)\n+        (high:SI (match_dup 1)) )\n+   (set (match_dup 0)\n+        (lo_sum:SI (match_dup 0) (match_dup 1)))]\n+  \"\")\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; DImode moves\n+;;\n+;; When the destination is the EAM register MDB, then we use the writemd\n+;; instruction.  In all other cases we split the move into two 32-bit moves.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_expand \"movdi\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:DI 1 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  prepare_move_operands (operands, DImode);\n+})\n+\n+(define_insn \"*movdi_insn\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"= r, m, r,??b\")\n+        (match_operand:DI 1 \"general_operand\"      \"rim,rO,?b,  r\"))]\n+  \"ok_for_simple_move_operands (operands, DImode)\"\n+  \"@\n+    #\n+    #\n+    #\n+    writemd %d1,%1\t\t;movdi  ?b r\"\n+  [(set_attr \"type\" \"multi,multi,multi,reg_eam\")])\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\") (reg:DI R_MDB))]\n+  \"reload_completed\"\n+  [(set (match_dup 1) (unspec:SI [(reg:DI R_MDB)] UNSPEC_MDBHI))\n+   (set (match_dup 2) (reg:SI R_MDB))]\n+{\n+  operands[1] = operand_subword (operands[0], 0, 1, DImode);\n+  operands[2] = operand_subword (operands[0], 1, 1, DImode);\n+})\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"non_eam_dst_operand\" \"\")\n+        (match_operand:DI 1 \"non_eam_src_operand\" \"\"))]\n+  \"reload_completed\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 4) (match_dup 5))]\n+{\n+  split_double_move (operands, DImode);\n+})\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; SFmode moves\n+;;\n+;; Constants are constructed in a GP register and moved to the FP register.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:SF 1 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  prepare_move_operands (operands, SFmode);\n+})\n+\n+(define_insn \"*movsf_insn\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,f,f,r,r, m,r,r,r\")\n+        (match_operand:SF 1 \"general_operand\"      \" f,G,r,f,r,rG,G,F,m\"))]\n+  \"ok_for_simple_move_operands (operands, SFmode)\"\n+  \"@\n+    fmove   %0,%1\n+    fmove   %0,f0\n+    fload   %0,%1\n+    fstore  %0,%1\n+    #\n+    write.l %0,%r1\n+    moviq   %0,0\n+    #\n+    read.l  %0,%1\"\n+  [(set_attr \"type\" \"fmove,fmove,reg_fp,fp_reg,logic,reg_mem,imm_reg,multi,mem_reg\")])\n+\n+(define_insn \"*movsf_insn\"\n+  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=r\")\n+\t(match_operand:SF 1 \"gpc_reg_operand\" \"r\"))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"move.l  %0,%1\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+(define_split\n+  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:SF 1 \"gpc_reg_operand\" \"\"))]\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (match_dup 1))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n+        (match_operand:SF 1 \"const_double_operand\" \"\"))]\n+  \"reload_completed\"\n+  [(set (match_dup 2) (match_dup 3))]\n+{\n+  long l;\n+  REAL_VALUE_TYPE rv;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n+  REAL_VALUE_TO_TARGET_SINGLE (rv, l);\n+\n+  operands[2] = operand_subword (operands[0], 0, 0, SFmode);\n+  operands[3] = GEN_INT (trunc_int_for_mode (l, SImode));\n+})\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; DFmode moves\n+;;\n+;; We always split a DFmode move into two SImode moves.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_expand \"movdf\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:DF 1 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  prepare_move_operands (operands, DFmode);\n+})\n+\n+(define_insn \"*movdf_insn\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"= r, m\")\n+        (match_operand:DF 1 \"general_operand\"      \"rFm,rG\"))]\n+  \"ok_for_simple_move_operands (operands, DFmode)\"\n+  \"#\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:DF 1 \"general_operand\" \"\"))]\n+  \"reload_completed\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 4) (match_dup 5))]\n+{\n+  split_double_move (operands, DFmode);\n+})\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Integer Add\n+;;\n+;; Modes QI, HI, SI and DI are supported directly.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_expand \"add<mode>3\"\n+  [(set (match_operand:QHI 0 \"register_operand\" \"\")\n+\t(plus:QHI (match_operand:QHI 1 \"register_operand\" \"\")\n+\t\t  (match_operand:QHI 2 \"register_operand\" \"\")))]\n+  \"\")\n+\n+(define_insn_and_split \"*add<mode>3_insn\"\n+  [(set (match_operand:QHI 0 \"register_operand\" \"=r\")\n+\t(plus:QHI (match_operand:QHI 1 \"register_operand\" \"%r\")\n+\t\t  (match_operand:QHI 2 \"register_operand\" \"r\")))]\n+  \"ok_for_simple_arith_logic_operands (operands, <MODE>mode)\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (plus:QHI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+  \"\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+(define_insn \"*add<mode>3_insn<subst_arith>\"\n+  [(set (match_operand:QHI 0 \"register_operand\" \"=r\")\n+\t(plus:QHI (match_operand:QHI 1 \"register_operand\" \"%r\")\n+\t\t  (match_operand:QHI 2 \"register_operand\" \"r\")))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"add<s>   %0,%1,%2\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+(define_expand \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t (match_operand:SI 2 \"add_operand\" \"\")))]\n+  \"\")\n+\n+(define_expand \"addsi3_flags\"\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t    (match_operand:SI 2 \"add_operand\" \"\")))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+  \"reload_completed\"\n+  \"\")\n+\n+(define_insn_and_split \"*addsi3_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\"          \"=r,r,r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,r,0\")\n+\t\t (match_operand:SI 2 \"add_operand\"      \" L,r,J\")))]\n+  \"ok_for_simple_arith_logic_operands (operands, SImode)\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (plus:SI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+  \"\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+; Favour the addition of small negative constants, since they are\n+; expensive to load into a register.\n+\n+(define_insn \"*addsi3_insn<subst_arith>\"\n+  [(set (match_operand:SI 0 \"register_operand\"          \"=r,r,r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,r,0\")\n+\t\t (match_operand:SI 2 \"add_operand\"      \" L,r,J\")))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"@\n+    subi    %0,%n2\n+    add.l   %0,%1,%2\n+    addi    %0,%2\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+(define_expand \"adddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t (match_operand:DI 2 \"add_operand\" \"\")))]\n+  \"\")\n+\n+(define_insn_and_split \"*addi3_insn\"\n+  [(set (match_operand:DI 0 \"register_operand\"          \"=r,r,&r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"%0,0, r\")\n+\t\t (match_operand:DI 2 \"add_operand\"      \" J,L, r\")))]\n+  \"ok_for_simple_arith_logic_operands (operands, DImode)\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (plus:DI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+  \"\"\n+  [(set_attr \"type\" \"arith2\")])\n+\n+; Disfavour the use of add.l because of the early clobber.\n+\n+(define_insn \"*adddi3_insn_flags\"\n+  [(set (match_operand:DI 0 \"register_operand\"          \"=r,r,&r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"%0,0, r\")\n+\t\t (match_operand:DI 2 \"add_operand\"      \" J,L, r\")))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"@\n+    addi    %d0,%2\\n\\tadc.l   %0,%0,r0\n+    subi    %d0,%n2\\n\\tsubc.l  %0,%0,r0\n+    add.l   %d0,%d1,%d2\\n\\tadc.l   %0,%1,%2\"\n+  [(set_attr \"type\" \"arith2\")])\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Integer Add with Carry\n+;;\n+;; Only SI mode is supported as slt[u] for the sake of cstore.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_insn \"*<scc_str><subst_arith>\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(any_scc:SI (reg R_FLAGS) (const_int 0)))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"adc.l   %0,r0,r0\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+(define_insn \"*plus_<scc_str><subst_arith>\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t (any_scc:SI (reg R_FLAGS) (const_int 0))))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"adc.l   %0,%1,r0\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Integer Subtract\n+;;\n+;; Modes QI, HI, SI and DI are supported directly.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_expand \"sub<mode>3\"\n+  [(set (match_operand:QHI 0 \"register_operand\" \"\")\n+\t(minus:QHI (match_operand:QHI 1 \"reg_or_0_operand\" \"\")\n+\t\t   (match_operand:QHI 2 \"register_operand\" \"\")))]\n+  \"\")\n+\n+(define_insn_and_split \"*sub<mode>3_insn\"\n+  [(set (match_operand:QHI 0 \"register_operand\" \"=r\")\n+\t(minus:QHI (match_operand:QHI 1 \"reg_or_0_operand\" \"rO\")\n+\t\t   (match_operand:QHI 2 \"register_operand\" \"r\")))]\n+  \"ok_for_simple_arith_logic_operands (operands, <MODE>mode)\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (minus:QHI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+ \"\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+(define_insn \"*sub<mode>3_insn<subst_arith>\"\n+  [(set (match_operand:QHI 0 \"register_operand\" \"=r\")\n+\t(minus:QHI (match_operand:QHI 1 \"reg_or_0_operand\" \"rO\")\n+\t\t   (match_operand:QHI 2 \"register_operand\" \"r\")))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"sub<s>   %0,%r1,%2\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+(define_expand \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(minus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"\")\n+\t\t  (match_operand:SI 2 \"add_operand\" \"\")))]\n+  \"\")\n+\n+(define_expand \"subsi3_flags\"\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (minus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"\")\n+\t\t\t     (match_operand:SI 2 \"add_operand\" \"\")))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+  \"reload_completed\"\n+  \"\")\n+\n+(define_insn_and_split \"*subsi3_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\"           \"=r,r, r\")\n+\t(minus:SI (match_operand:SI 1 \"reg_or_0_operand\" \" 0,rO,0\")\n+\t\t  (match_operand:SI 2 \"add_operand\"      \" L,r, J\")))]\n+  \"ok_for_simple_arith_logic_operands (operands, SImode)\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (minus:SI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+ \"\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+; Favour the subtraction of small negative constants, since they are\n+; expensive to load into a register.\n+\n+(define_insn \"*subsi3_insn<subst_arith>\"\n+  [(set (match_operand:SI 0 \"register_operand\"           \"=r,r, r\")\n+\t(minus:SI (match_operand:SI 1 \"reg_or_0_operand\" \" 0,rO,0\")\n+\t\t  (match_operand:SI 2 \"add_operand\"      \" L,r, J\")))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"@\n+    addi    %0,%n2\n+    sub.l   %0,%r1,%2\n+    subi    %0,%2\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+(define_expand \"subdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(minus:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t  (match_operand:DI 2 \"add_operand\" \"\")))]\n+  \"\")\n+\n+(define_insn_and_split \"*subdi3_insn\"\n+  [(set (match_operand:DI 0 \"register_operand\"           \"=r,r,&r\")\n+\t(minus:DI (match_operand:DI 1 \"register_operand\" \" 0,0, r\")\n+\t\t  (match_operand:DI 2 \"add_operand\"      \" J,L, r\")))]\n+  \"ok_for_simple_arith_logic_operands (operands, DImode)\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (minus:DI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+ \"\"\n+  [(set_attr \"type\" \"arith2\")])\n+\n+; Disfavour the use of the sub.l because of the early clobber.\n+\n+(define_insn \"*subdi3_insn_flags\"\n+  [(set (match_operand:DI 0 \"register_operand\"           \"=r,r,&r\")\n+\t(minus:DI (match_operand:DI 1 \"register_operand\" \" 0,0, r\")\n+\t\t  (match_operand:DI 2 \"add_operand\"      \" J,L, r\")))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"@\n+    subi    %d0,%2\\n\\tsubc.l  %0,%0,r0\n+    addi    %d0,%n2\\n\\tadc.l   %0,%0,r0\n+    sub.l   %d0,%d1,%d2\\n\\tsubc.l  %0,%1,%2\"\n+  [(set_attr \"type\" \"arith2\")])\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Integer Subtract with Carry\n+;;\n+;; Only SI mode is supported as neg<slt[u]> for the sake of cstore.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_insn \"*neg_<scc_str><subst_arith>\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(neg:SI (any_scc:SI (reg R_FLAGS) (const_int 0))))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"subc.l  %0,r0,r0\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+(define_insn \"*minus_<scc_str><subst_arith>\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t  (any_scc:SI (reg R_FLAGS) (const_int 0))))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"subc.l  %0,%1,r0\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Integer Negate\n+;;\n+;; Modes QI, HI, SI and DI are supported directly.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_expand \"neg<mode>2\"\n+  [(set (match_operand:I 0 \"register_operand\" \"\")\n+\t(neg:I (match_operand:I 1 \"register_operand\" \"\")))]\n+  \"\")\n+\n+(define_insn_and_split \"*neg<mode>2_insn\"\n+  [(set (match_operand:I 0 \"register_operand\" \"=r\")\n+\t(neg:I (match_operand:I 1 \"register_operand\" \"r\")))]\n+  \"ok_for_simple_arith_logic_operands (operands, <MODE>mode)\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (neg:I (match_dup 1)))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+  \"\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+(define_insn \"*neg<mode>2_insn<subst_arith>\"\n+  [(set (match_operand:I 0 \"register_operand\" \"=r\")\n+\t(neg:I (match_operand:I 1 \"register_operand\" \"r\")))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"sub<s>   %0,r0,%1\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+(define_expand \"negdi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(neg:DI (match_operand:DI 1 \"register_operand\" \"\")))]\n+  \"\")\n+\n+(define_insn_and_split \"*negdi2_insn\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n+\t(neg:DI (match_operand:DI 1 \"register_operand\" \"r\")))]\n+  \"ok_for_simple_arith_logic_operands (operands, DImode)\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (neg:DI (match_dup 1)))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+  \"\"\n+  [(set_attr \"type\" \"arith2\")])\n+\n+(define_insn \"*negdi2_insn_flags\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n+\t(neg:DI (match_operand:DI 1 \"register_operand\" \"r\")))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"sub.l   %d0,r0,%d1\\n\\tsubc.l  %0,r0,%1\"\n+  [(set_attr \"type\" \"arith2\")])\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Integer Multiply (non-widening and widening, signed and unsigned)\n+;;\n+;; Only SI mode is supported.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+; The mults and multu instructions clear MDC but we only pretend that they\n+; clobber it to keep things relatively simple.\n+\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=b\")\n+         (mult:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+                  (match_operand:SI 2 \"register_operand\" \"r\")))\n+   (clobber (reg:SI R_MDC))]\n+  \"\"\n+  \"mults   %1,%2\"\n+  [(set_attr \"type\" \"mul\")])\n+\n+; The names are mulsidi3 and umulsidi3 here.\n+\n+(define_insn \"<u>mulsidi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=b\")\n+        (mult:DI (any_extend:DI (match_operand:SI 1 \"register_operand\" \"%r\"))\n+                 (any_extend:DI (match_operand:SI 2 \"register_operand\" \"r\"))))\n+   (clobber (reg:SI R_MDC))]\n+  \"\"\n+  \"mult<su>   %1,%2\"\n+  [(set_attr \"type\" \"mul\")])\n+\n+; But they are smulsi3_highpart and umulsi3_highpart here.\n+\n+(define_insn_and_split \"<su>mulsi3_highpart\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (truncate:SI\n+          (ashiftrt:DI\n+            (mult:DI (any_extend:DI (match_operand:SI 1 \"register_operand\" \"%r\"))\n+                     (any_extend:DI (match_operand:SI 2 \"register_operand\" \"r\")))\n+            (const_int 32))))\n+   (clobber (reg:DI R_MDB))\n+   (clobber (reg:SI R_MDC))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (reg:DI R_MDB)\n+                   (mult:DI (any_extend:DI (match_dup 1))\n+                            (any_extend:DI (match_dup 2))))\n+              (clobber (reg:SI R_MDC))])\n+   (set (match_dup 0) (unspec:SI [(reg:DI R_MDB)] UNSPEC_MDBHI))]\n+  \"\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Integer divide and modulus (signed and unsigned)\n+;;\n+;; Only SI mode is supported.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_insn \"*divmodsi4_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=b\")\n+        (div:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+                (match_operand:SI 2 \"register_operand\" \"r\")))\n+   (set (reg:SI R_MDC) (mod:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"divs    %2\"\n+  [(set_attr \"type\" \"div\")])\n+\n+(define_insn_and_split \"divmodsi4\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=b\")\n+        (div:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+                (match_operand:SI 2 \"register_operand\" \"r\")))\n+   (set (match_operand:SI 3 \"register_operand\" \"=r\")\n+        (mod:SI (match_dup 1) (match_dup 2)))\n+   (clobber (reg:SI R_MDC))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (div:SI (match_dup 1) (match_dup 2)))\n+              (set (reg:SI R_MDC) (mod:SI (match_dup 1) (match_dup 2)))])\n+   (set (match_dup 3) (reg:SI R_MDC))]\n+  \"\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn \"*udivmodsi4_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=b\")\n+        (udiv:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+                 (match_operand:SI 2 \"register_operand\" \"r\")))\n+   (set (reg:SI R_MDC) (umod:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"divu    %2\"\n+  [(set_attr \"type\" \"div\")])\n+\n+(define_insn_and_split \"udivmodsi4\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=b\")\n+        (udiv:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+                 (match_operand:SI 2 \"register_operand\" \"r\")))\n+   (set (match_operand:SI 3 \"register_operand\" \"=r\")\n+        (umod:SI (match_dup 1) (match_dup 2)))\n+   (clobber (reg:SI R_MDC))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (udiv:SI (match_dup 1) (match_dup 2)))\n+              (set (reg:SI R_MDC) (umod:SI (match_dup 1) (match_dup 2)))])\n+   (set (match_dup 3) (reg:SI R_MDC))]\n+  \"\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+; FIXME. How do we persuade the compiler to use 64/32 bit divides directly ?\n+\n+(define_insn \"*divds\"\n+  [(set (reg:DI R_MDB)\n+        (div:DI (reg:DI R_MDB) (sign_extend:DI (match_operand:SI 0 \"register_operand\" \"r\"))))\n+   (set (reg:SI R_MDC) (truncate:SI (mod:DI (reg:DI R_MDB) (sign_extend:DI (match_dup 0)))))]\n+  \"\"\n+  \"divds   %0\"\n+  [(set_attr \"type\" \"divd\")])\n+\n+(define_insn \"*divdu\"\n+  [(set (reg:DI R_MDB)\n+        (udiv:DI (reg:DI R_MDB) (zero_extend:DI (match_operand:SI 0 \"register_operand\" \"r\"))))\n+   (set (reg:SI R_MDC) (truncate:SI (umod:DI (reg:DI R_MDB) (zero_extend:DI (match_dup 0)))))]\n+  \"\"\n+  \"divdu   %0\"\n+  [(set_attr \"type\" \"divd\")])\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Bitwise Logical AND\n+;;\n+;; Modes QI, HI and SI are supported directly.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_expand \"and<mode>3\"\n+  [(set (match_operand:I 0 \"register_operand\" \"\")\n+\t(and:I (match_operand:I 1 \"register_operand\" \"\")\n+\t       (match_operand:I 2 \"register_operand\" \"\")))]\n+  \"\")\n+\n+(define_insn_and_split \"*and<mode>3_insn\"\n+  [(set (match_operand:I 0 \"register_operand\" \"=r\")\n+\t(and:I (match_operand:I 1 \"register_operand\" \"%r\")\n+\t       (match_operand:I 2 \"register_operand\" \"r\")))]\n+  \"ok_for_simple_arith_logic_operands (operands, <MODE>mode)\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (and:I (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+  \"\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+(define_insn \"*and<mode>3_insn<subst_logic>\"\n+  [(set (match_operand:I 0 \"register_operand\" \"=r\")\n+\t(and:I (match_operand:I 1 \"register_operand\" \"%r\")\n+\t       (match_operand:I 2 \"register_operand\" \"r\")))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"and<s>   %0,%1,%2\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Bitwise Inclusive Logical OR\n+;;\n+;; Modes QI, HI and SI are supported directly.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_expand \"ior<mode>3\"\n+  [(set (match_operand:I 0 \"register_operand\" \"\")\n+\t(ior:I (match_operand:I 1 \"register_operand\" \"\")\n+\t       (match_operand:I 2 \"register_operand\" \"\")))]\n+  \"\")\n+\n+(define_insn_and_split \"*ior<mode>3_insn\"\n+  [(set (match_operand:I 0 \"register_operand\" \"=r\")\n+\t(ior:I (match_operand:I 1 \"register_operand\" \"%r\")\n+\t       (match_operand:I 2 \"register_operand\" \"r\")))]\n+  \"ok_for_simple_arith_logic_operands (operands, <MODE>mode)\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (ior:I (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+  \"\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+(define_insn \"*ior<mode>3_insn<subst_logic>\"\n+  [(set (match_operand:I 0 \"register_operand\" \"=r\")\n+\t(ior:I (match_operand:I 1 \"register_operand\" \"%r\")\n+\t       (match_operand:I 2 \"register_operand\" \"r\")))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"or<s>    %0,%1,%2\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Bitwise Exclusive Logical OR\n+;;\n+;; Modes QI, HI and SI are supported directly.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_expand \"xor<mode>3\"\n+  [(set (match_operand:I 0 \"register_operand\" \"\")\n+\t(xor:I (match_operand:I 1 \"register_operand\" \"\")\n+\t\t(match_operand:I 2 \"register_operand\" \"\")))]\n+  \"\")\n+\n+(define_insn_and_split \"*xor<mode>3_insn\"\n+  [(set (match_operand:I 0 \"register_operand\" \"=r\")\n+\t(xor:I (match_operand:I 1 \"register_operand\" \"%r\")\n+\t       (match_operand:I 2 \"register_operand\" \"r\")))]\n+  \"ok_for_simple_arith_logic_operands (operands, <MODE>mode)\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (xor:I (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+  \"\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+(define_insn \"*xor<mode>3_insn<subst_logic>\"\n+  [(set (match_operand:I 0 \"register_operand\" \"=r\")\n+\t(xor:I (match_operand:I 1 \"register_operand\" \"%r\")\n+\t       (match_operand:I 2 \"register_operand\" \"r\")))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"xor<s>   %0,%1,%2\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Bitwise Logical NOT\n+;;\n+;; Modes QI, HI and SI are supported directly.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_expand \"one_cmpl<mode>2\"\n+  [(set (match_operand:I 0 \"register_operand\" \"\")\n+\t(not:I (match_operand:I 1 \"reg_or_0_operand\" \"\")))]\n+  \"\")\n+\n+(define_insn_and_split \"*one_cmpl<mode>2_insn\"\n+  [(set (match_operand:I 0 \"register_operand\" \"=r\")\n+\t(not:I (match_operand:I 1 \"reg_or_0_operand\" \"rO\")))]\n+  \"ok_for_simple_arith_logic_operands (operands, <MODE>mode)\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (not:I (match_dup 1)))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+  \"\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+(define_insn \"*one_cmpl<mode>2_insn<subst_logic>\"\n+  [(set (match_operand:I 0 \"register_operand\" \"=r\")\n+\t(not:I (match_operand:I 1 \"reg_or_0_operand\" \"rO\")))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"not<s>   %0,%r1\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Arithmetic Shift Left\n+;;\n+;; Modes QI, HI, SI and DI are supported directly.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_expand \"ashl<mode>3\"\n+  [(set (match_operand:I 0 \"register_operand\" \"\")\n+\t(ashift:I (match_operand:I  1 \"register_operand\"     \"\")\n+\t\t  (match_operand:QI 2 \"reg_or_shift_operand\" \"\")))]\n+  \"\")\n+\n+(define_insn_and_split \"*ashl<mode>3_insn\"\n+  [(set (match_operand:I 0 \"register_operand\" \"=r,r\")\n+\t(ashift:I (match_operand:I  1 \"register_operand\"     \"r,r\")\n+\t\t  (match_operand:QI 2 \"reg_or_shift_operand\" \"r,K\")))]\n+  \"ok_for_simple_arith_logic_operands (operands, <MODE>mode)\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (ashift:I (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+  \"\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+(define_insn \"*ashl<mode>3_insn<subst_arith>\"\n+  [(set (match_operand:I 0 \"register_operand\" \"=r,r\")\n+\t(ashift:I (match_operand:I  1 \"register_operand\"     \"r,r\")\n+\t\t  (match_operand:QI 2 \"reg_or_shift_operand\" \"r,K\")))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"asl<s>   %0,%1,%2\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+(define_insn \"ashldi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=b,r\")\n+        (ashift:DI (match_operand:DI 1 \"register_operand\" \"0,r\")\n+                   (match_operand:QI 2 \"reg_or_32_operand\" \"r,P\")))\n+   (clobber (reg:SI R_MDC))]\n+  \"\"\n+  \"@\n+    asld    %2\n+    #\"\n+  [(set_attr \"type\" \"shiftdi,multi\")])\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+        (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n+                   (const_int 32)))\n+   (clobber (reg:SI R_MDC))]\n+  \"reload_completed\"\n+  [(set (subreg:SI (match_dup 0) 0) (subreg:SI (match_dup 1) 4))\n+   (set (subreg:SI (match_dup 0) 4) (const_int 0))]\n+  \"\")\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Arithmetic Shift Right\n+;;\n+;; Modes QI, HI, SI and DI are supported directly.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_expand \"ashr<mode>3\"\n+  [(set (match_operand:I 0 \"register_operand\" \"\")\n+\t(ashiftrt:I (match_operand:I  1 \"register_operand\"     \"\")\n+\t\t    (match_operand:QI 2 \"reg_or_shift_operand\" \"\")))]\n+  \"\")\n+\n+(define_insn_and_split \"*ashr<mode>3_insn\"\n+  [(set (match_operand:I 0 \"register_operand\" \"=r,r\")\n+\t(ashiftrt:I (match_operand:I  1 \"register_operand\"     \"r,r\")\n+\t\t    (match_operand:QI 2 \"reg_or_shift_operand\" \"r,K\")))]\n+  \"ok_for_simple_arith_logic_operands (operands, <MODE>mode)\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (ashiftrt:I (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+  \"\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+(define_insn \"*ashr<mode>3_insn<subst_logic>\"\n+  [(set (match_operand:I 0 \"register_operand\" \"=r,r\")\n+\t(ashiftrt:I (match_operand:I  1 \"register_operand\"     \"r,r\")\n+\t\t    (match_operand:QI 2 \"reg_or_shift_operand\" \"r,K\")))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"asr<s>   %0,%1,%2\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+(define_insn \"ashrdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=b,r\")\n+        (ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"0,r\")\n+                     (match_operand:QI 2 \"reg_or_32_operand\" \"r,P\")))\n+   (clobber (reg:SI R_MDC))]\n+  \"\"\n+  \"@\n+    asrd    %2\n+    #\"\n+  [(set_attr \"type\" \"shiftdi,multi\")])\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+        (ashiftrt:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n+                     (const_int 32)))\n+   (clobber (reg:SI R_MDC))]\n+  \"reload_completed\"\n+  [(set (subreg:SI (match_dup 0) 4) (subreg:SI (match_dup 1) 0))\n+   (parallel [(set (subreg:SI (match_dup 0) 0)\n+\t\t   (ashiftrt:SI (subreg:SI (match_dup 1) 0) (const_int 31)))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+  \"\")\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Logical Shift Right\n+;;\n+;; Modes QI, HI, SI and DI are supported directly.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_expand \"lshr<mode>3\"\n+  [(set (match_operand:I 0 \"register_operand\" \"\")\n+\t(lshiftrt:I (match_operand:I  1 \"register_operand\"     \"\")\n+\t\t    (match_operand:QI 2 \"reg_or_shift_operand\" \"\")))]\n+  \"\")\n+\n+(define_insn_and_split \"*lshr<mode>3_insn\"\n+  [(set (match_operand:I 0 \"register_operand\" \"=r,r\")\n+\t(lshiftrt:I (match_operand:I  1 \"register_operand\"     \"r,r\")\n+\t\t    (match_operand:QI 2 \"reg_or_shift_operand\" \"r,K\")))]\n+  \"ok_for_simple_arith_logic_operands (operands, <MODE>mode)\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (lshiftrt:I (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+  \"\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+(define_insn \"*lshr<mode>3_insn<subst_logic>\"\n+  [(set (match_operand:I 0 \"register_operand\" \"=r,r\")\n+\t(lshiftrt:I (match_operand:I  1 \"register_operand\"     \"r,r\")\n+\t\t    (match_operand:QI 2 \"reg_or_shift_operand\" \"r,K\")))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"lsr<s>   %0,%1,%2\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+(define_insn \"lshrdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=b,r\")\n+        (lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"0,r\")\n+                     (match_operand:QI 2 \"reg_or_32_operand\" \"r,P\")))\n+   (clobber (reg:SI R_MDC))]\n+  \"\"\n+  \"@\n+    lsrd    %2\n+    #\"\n+  [(set_attr \"type\" \"shiftdi,multi\")])\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+        (lshiftrt:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n+                     (const_int 32)))\n+   (clobber (reg:SI R_MDC))]\n+  \"reload_completed\"\n+  [(set (subreg:SI (match_dup 0) 4) (subreg:SI (match_dup 1) 0))\n+   (set (subreg:SI (match_dup 0) 0) (const_int 0))]\n+  \"\")\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Truncate\n+;;\n+;; Truncations among modes QI, HI, SI and DI are supported directly.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_expand \"trunchiqi2\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t (truncate:QI (match_operand:HI 1 \"register_operand\" \"\")))]\n+  \"\")\n+\n+(define_insn_and_split \"*trunchiqi2_insn\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(truncate:QI (match_operand:HI 1 \"register_operand\" \"r\")))]\n+  \"ok_for_simple_arith_logic_operands (operands, QImode)\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (truncate:QI (match_dup 1)))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+  \"\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+(define_insn \"*trunchiqi2_insn<subst_logic>\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(truncate:QI (match_operand:HI 1 \"register_operand\" \"r\")))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"move.b  %0,%1\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+(define_expand \"truncsihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(truncate:HI (match_operand:SI 1 \"register_operand\" \"\")))]\n+  \"\")\n+\n+(define_insn_and_split \"*truncsihi2_insn\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(truncate:HI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"ok_for_simple_arith_logic_operands (operands, HImode)\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (truncate:HI (match_dup 1)))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+  \"\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+(define_insn \"*truncsihi2_insn<subst_logic>\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(truncate:HI (match_operand:SI 1 \"register_operand\" \"r\")))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"move.w  %0,%1\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+(define_expand \"truncdisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(truncate:SI (match_operand:DI 1 \"register_operand\" \"\")))]\n+  \"\")\n+\n+(define_insn_and_split \"*truncdisi2_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(truncate:SI (match_operand:DI 1 \"register_operand\" \"r\")))]\n+  \"ok_for_simple_arith_logic_operands (operands, SImode)\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (truncate:SI (match_dup 1)))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+  \"\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+(define_insn \"*truncdisi2_insn<subst_logic>\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(truncate:SI (match_operand:DI 1 \"register_operand\" \"r\")))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"move.l  %0,%d1\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Sign-extend\n+;;\n+;; Sign-extensions among modes QI, HI, SI and DI are supported directly.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_expand \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(sign_extend:HI (match_operand:QI 1 \"register_operand\" \"\")))]\n+  \"\")\n+\n+(define_insn_and_split \"*extendqihi2_insn\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:HI (match_operand:QI 1 \"register_operand\" \"r\")))]\n+  \"ok_for_simple_arith_logic_operands (operands, HImode)\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (sign_extend:HI (match_dup 1)))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+  \"\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+(define_insn \"*extendqihi2_insn<subst_logic>\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:HI (match_operand:QI 1 \"register_operand\" \"r\")))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"extb.w  %0,%1\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+(define_expand \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extend:SI (match_operand:QI 1 \"register_operand\" \"\")))]\n+  \"\")\n+\n+(define_insn_and_split \"*extendqisi2_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI (match_operand:QI 1 \"register_operand\" \"r\")))]\n+  \"ok_for_simple_arith_logic_operands (operands, SImode)\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (sign_extend:SI (match_dup 1)))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+  \"\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+(define_insn \"*extendqisi2_insn<subst_logic>\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI (match_operand:QI 1 \"register_operand\" \"r\")))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"extb.l  %0,%1\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+(define_expand \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extend:SI (match_operand:HI 1 \"register_operand\" \"\")))]\n+  \"\")\n+\n+(define_insn_and_split \"*extendhisi2_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI (match_operand:HI 1 \"register_operand\" \"r\")))]\n+  \"ok_for_simple_arith_logic_operands (operands, SImode)\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"\")))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+  \"\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+(define_insn \"*extendhisi2_insn<subst_logic>\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI (match_operand:HI 1 \"register_operand\" \"r\")))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"extw.l  %0,%1\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+(define_expand \"extendsidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+        (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"\")))]\n+  \"\")\n+\n+(define_insn_and_split \"*extendsidi2_insn\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+        (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"ok_for_simple_arith_logic_operands (operands, DImode)\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 3) (match_dup 1))\n+\t      (clobber (reg:CC R_FLAGS))])\n+   (parallel [(set (match_dup 2)\n+\t\t   (ashiftrt:SI (match_dup 1) (const_int 31)))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+{\n+  operands[2] = operand_subword (operands[0], 0, 0, DImode);\n+  operands[3] = operand_subword (operands[0], 1, 0, DImode);\n+}\n+  [(set_attr \"type\" \"multi\")])\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Zero-extend\n+;;\n+;; Zero-extensions among modes QI, HI, SI and DI are supported directly.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+; QI is zero-extended to wider modes by shifting left and then performing\n+; a logical shift right to insert the zeroes. This avoids the need to use\n+; another register.\n+\n+(define_expand \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+        (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"\")))]\n+  \"\")\n+\n+(define_insn_and_split \"*zero_extendqihi2_insn\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+        (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"r\")))]\n+  \"ok_for_simple_arith_logic_operands (operands, HImode)\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (ashift:HI (match_dup 2) (const_int 8)))\n+\t      (clobber (reg:CC R_FLAGS))])\n+   (parallel [(set (match_dup 0)\n+\t\t   (lshiftrt:HI (match_dup 0) (const_int 8)))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+{\n+  operands[2] = gen_rtx_SUBREG (HImode, operands[1], 0);\n+}\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_expand \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+        (zero_extend:SI (match_operand:QI 1 \"register_operand\" \"\")))]\n+  \"\")\n+\n+(define_insn_and_split \"*zero_extendqisi2_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (zero_extend:SI (match_operand:QI 1 \"register_operand\" \"r\")))]\n+  \"ok_for_simple_arith_logic_operands (operands, SImode)\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (ashift:SI (match_dup 2) (const_int 24)))\n+\t      (clobber (reg:CC R_FLAGS))])\n+   (parallel [(set (match_dup 0)\n+\t\t   (lshiftrt:SI (match_dup 0) (const_int 24)))\n+\t      (clobber (reg:CC R_FLAGS))])]\n+{\n+  operands[2] = gen_rtx_SUBREG (SImode, operands[1], 0);\n+}\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"moviu   %0,0\"\n+  [(set_attr \"type\" \"imm_reg\")])\n+\n+(define_expand \"zero_extendsidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+        (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"\")))]\n+  \"\")\n+\n+(define_insn_and_split \"*zero_extendsidi2_insn\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+        (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"ok_for_simple_arith_logic_operands (operands, DImode)\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 3) (match_dup 1))\n+\t      (clobber (reg:CC R_FLAGS))])\n+   (set (match_dup 2) (const_int 0))]\n+{\n+  operands[2] = operand_subword (operands[0], 0, 0, DImode);\n+  operands[3] = operand_subword (operands[0], 1, 0, DImode);\n+}\n+  [(set_attr \"type\" \"multi\")])\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Bit Test\n+;;\n+;; Only SI mode is supported directly.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+; BITS_BIG_ENDIAN is defined to 1 so operand #1 counts from the MSB.\n+\n+(define_insn \"*btst\"\n+  [(set (reg:CC_BTST R_FLAGS)\n+\t(compare:CC_BTST (zero_extract:SI\n+\t\t\t   (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t   (const_int 1)\n+\t\t\t   (match_operand:QI 1 \"const_shift_operand\" \"K\"))\n+\t\t\t (const_int 0)))]\n+  \"reload_completed\"\n+  \"lsr.l   r0,%0,32-%1\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Integer comparisons\n+;;\n+;; Modes QI, HI and SI are supported directly.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_insn \"*cmp<mode>\"\n+  [(set (reg:CC R_FLAGS)\n+\t(compare:CC (match_operand:I 0 \"register_operand\" \"r\")\n+\t\t    (match_operand:I 1 \"reg_or_0_operand\" \"rO\")))]\n+  \"reload_completed\"\n+  \"cmp<s>   %0,%r1\"\n+  [(set_attr \"type\" \"cmp\")])\n+\n+(define_insn \"*cmp<mode>_sne\"\n+  [(set (reg:CC R_FLAGS)\n+\t(compare:CC (not:I (match_operand:I 0 \"register_operand\" \"r\"))\n+\t\t    (const_int -1)))]\n+  \"reload_completed\"\n+  \"cmp<s>   r0,%0\"\n+  [(set_attr \"type\" \"cmp\")])\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Single float operations\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_insn \"addsf3\"\n+  [(set (match_operand:SF 0 \"fp_reg_operand\" \"=f\")\n+        (plus:SF (match_operand:SF 1 \"fp_reg_operand\" \"%f\")\n+                 (match_operand:SF 2 \"fp_reg_operand\" \"f\")))]\n+  \"TARGET_FPU\"\n+  \"fadd    %0,%1,%2\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"subsf3\"\n+  [(set (match_operand:SF 0 \"fp_reg_operand\" \"=f\")\n+        (minus:SF (match_operand:SF 1 \"fp_reg_operand\" \"f\")\n+                  (match_operand:SF 2 \"fp_reg_operand\" \"f\")))]\n+  \"TARGET_FPU\"\n+  \"fsub    %0,%1,%2\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"mulsf3\"\n+  [(set (match_operand:SF 0 \"fp_reg_operand\" \"=f\")\n+        (mult:SF (match_operand:SF 1 \"fp_reg_operand\" \"%f\")\n+                 (match_operand:SF 2 \"fp_reg_operand\" \"f\")))]\n+  \"TARGET_FPU\"\n+  \"fmult   %0,%1,%2\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"divsf3\"\n+  [(set (match_operand:SF 0 \"fp_reg_operand\" \"=f\")\n+        (div:SF (match_operand:SF 1 \"fp_reg_operand\" \"f\")\n+                (match_operand:SF 2 \"fp_reg_operand\" \"f\")))]\n+  \"TARGET_FPU\"\n+  \"fdiv    %0,%1,%2\"\n+  [(set_attr \"type\" \"fdiv\")])\n+\n+(define_insn \"sqrtsf2\"\n+  [(set (match_operand:SF 0 \"fp_reg_operand\" \"=f\")\n+        (sqrt:SF (match_operand:SF 1 \"fp_reg_operand\" \"f\")))]\n+  \"TARGET_FPU\"\n+  \"fsqrt   %0,%1\"\n+  [(set_attr \"type\" \"fsqrt\")])\n+\n+(define_insn \"negsf2\"\n+  [(set (match_operand:SF 0 \"fp_reg_operand\" \"=f\")\n+        (neg:SF (match_operand:SF 1 \"fp_reg_operand\" \"f\")))]\n+  \"TARGET_FPU\"\n+  \"fneg    %0,%1\"\n+  [(set_attr \"type\" \"fmove\")])\n+\n+(define_insn \"abssf2\"\n+  [(set (match_operand:SF 0 \"fp_reg_operand\" \"=f\")\n+        (abs:SF (match_operand:SF 1 \"fp_reg_operand\" \"f\")))]\n+  \"TARGET_FPU\"\n+  \"fabs    %0,%1\"\n+  [(set_attr \"type\" \"fmove\")])\n+\n+(define_expand \"copysignsf3\"\n+  [(match_operand:SF 0 \"register_operand\" \"\")\n+   (match_operand:SF 1 \"nonmemory_operand\" \"\")\n+   (match_operand:SF 2 \"register_operand\" \"\")]\n+  \"TARGET_FPU && !TARGET_FPU_IEEE\"\n+{\n+  visium_expand_copysign (operands, SFmode);\n+  DONE;\n+})\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Single float <-> single integer conversions for !TARGET_FPU_IEEE\n+;;\n+;; An FMOVE instruction converts a signalling NaN (zero high order bit of the\n+;; mantissa) to a quiet NaN (-1). This is acceptable when the data to be\n+;; moved is in fact a floating-point number, but to avoid nasty surprises\n+;; integers must in general be kept out of the floating-point registers.\n+;; HARD_REGNO_MODE_OK thus only allows SFmode in these registers.\n+;; However, since FTOI and ITOF use floating-point registers for both their\n+;; inputs and outputs, to use these instructions integers must transiently\n+;; occupy such registers. To disguise this from the compiler, UNSPECs are\n+;; used for floating-point operations on integers and floating from general\n+;; register to floating-point register and fixing in the reverse direction\n+;; are only split into the individual UNSPEC operations after reload.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_insn \"*fload_no_ieee\"\n+  [(set (match_operand:SF 0 \"fp_reg_operand\" \"=f\")\n+        (unspec:SF [(match_operand:SI 1 \"register_operand\" \"r\")] UNSPEC_FLOAD))]\n+  \"TARGET_FPU && !TARGET_FPU_IEEE\"\n+  \"fload   %0,%1\"\n+  [(set_attr \"type\" \"reg_fp\")])\n+\n+(define_insn \"*itof_no_ieee\"\n+  [(set (match_operand:SF 0 \"fp_reg_operand\" \"=f\")\n+        (unspec:SF [(match_operand:SF 1 \"fp_reg_operand\" \"f\")] UNSPEC_ITOF))]\n+  \"TARGET_FPU && !TARGET_FPU_IEEE\"\n+  \"itof    %0,%1\"\n+  [(set_attr \"type\" \"itof\")])\n+\n+(define_insn_and_split \"*floatsisf2_no_ieee\"\n+  [(set (match_operand:SF 0 \"fp_reg_operand\" \"=f\")\n+        (float:SF (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"TARGET_FPU && !TARGET_FPU_IEEE\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0)\n+        (unspec:SF [(match_dup 1)] UNSPEC_FLOAD))\n+   (set (match_dup 0)\n+        (unspec:SF [(match_dup 0)] UNSPEC_ITOF))]\n+  \"\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn \"*ftoi_no_ieee\"\n+  [(set (match_operand:SF 0 \"fp_reg_operand\" \"=f\")\n+        (unspec:SF [(match_operand:SF 1 \"fp_reg_operand\" \"f\")] UNSPEC_FTOI))]\n+  \"TARGET_FPU && !TARGET_FPU_IEEE\"\n+  \"ftoi    %0,%1\"\n+  [(set_attr \"type\" \"ftoi\")])\n+\n+(define_insn \"*fstore_no_ieee\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (unspec:SI [(match_operand:SF 1 \"fp_reg_operand\" \"f\")] UNSPEC_FSTORE))]\n+  \"TARGET_FPU && !TARGET_FPU_IEEE\"\n+  \"fstore  %0,%1\"\n+  [(set_attr \"type\" \"fp_reg\")])\n+\n+(define_insn_and_split \"fix_truncsfsi2_no_ieee\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(fix:SI (fix:SF (match_operand:SF 1 \"fp_reg_operand\" \"f\"))))\n+   (clobber (match_scratch:SF 2 \"=1\"))]\n+  \"TARGET_FPU && !TARGET_FPU_IEEE\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 1)\n+        (unspec:SF [(match_dup 1)] UNSPEC_FTOI))\n+   (set (match_dup 0)\n+        (unspec:SI [(match_dup 1)] UNSPEC_FSTORE))]\n+  \"\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Single float <-> single integer conversions\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_insn \"*itof\"\n+  [(set (match_operand:SF 0 \"fp_reg_operand\" \"=f\")\n+        (float:SF (match_operand:SI 1 \"register_operand\" \"f\")))]\n+  \"TARGET_FPU_IEEE\"\n+  \"itof    %0,%1\"\n+  [(set_attr \"type\" \"itof\")])\n+\n+(define_expand \"floatsisf2\"\n+  [(set (match_operand:SF 0 \"fp_reg_operand\" \"\")\n+        (float:SF (match_operand:SI 1 \"register_operand\" \"\")))]\n+  \"TARGET_FPU\"\n+  \"\")\n+\n+(define_insn \"*ftoi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=f\")\n+\t(fix:SI (fix:SF (match_operand:SF 1 \"fp_reg_operand\" \"f\"))))]\n+  \"TARGET_FPU_IEEE\"\n+  \"ftoi    %0,%1\"\n+  [(set_attr \"type\" \"ftoi\")])\n+\n+(define_expand \"fix_truncsfsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(fix:SI (fix:SF (match_operand:SF 1 \"fp_reg_operand\" \"\"))))]\n+  \"TARGET_FPU\"\n+{\n+  if (!TARGET_FPU_IEEE)\n+    {\n+      emit_insn (gen_fix_truncsfsi2_no_ieee (operands[0], operands[1]));\n+      DONE;\n+    }\n+})\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Single float comparisons\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_insn \"*cmpsf_fp\"\n+  [(set (reg:CCFP R_FLAGS)\n+\t(compare:CCFP (match_operand:SF 0 \"fp_reg_or_0_operand\" \"fG\")\n+\t\t      (match_operand:SF 1 \"fp_reg_or_0_operand\" \"fG\")))]\n+  \"TARGET_FPU && reload_completed\"\n+  \"fcmp    r0,%f0,%f1\"\n+  [(set_attr \"type\" \"fcmp\")])\n+\n+(define_insn \"*cmpsf_fpe\"\n+  [(set (reg:CCFPE R_FLAGS)\n+\t(compare:CCFPE (match_operand:SF 0 \"fp_reg_or_0_operand\" \"fG\")\n+\t\t       (match_operand:SF 1 \"fp_reg_or_0_operand\" \"fG\")))]\n+  \"TARGET_FPU && reload_completed\"\n+  \"fcmpe   r0,%f0,%f1\"\n+  [(set_attr \"type\" \"fcmp\")])\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Conditional branch instructions\n+;;\n+;; Note - we do not specify the two instructions necessary to perform\n+;; a compare-and-branch in the cbranch<mode>4 pattern because that would\n+;; allow the comparison to be moved away from the jump before the reload\n+;; pass has completed.  That would be problematical because reload can\n+;; generate instructions in between which would clobber the CC register.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_expand \"cbranch<mode>4\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t       [(match_operand:I 1 \"register_operand\")\n+\t\t        (match_operand:I 2 \"reg_or_0_operand\")])\n+\t\t      (label_ref (match_operand 3 \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+)\n+\n+(define_insn_and_split \"*cbranch<mode>4_insn\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t       [(match_operand:I 1 \"register_operand\" \"r\")\n+ \t\t        (match_operand:I 2 \"reg_or_0_operand\" \"rO\")])\n+\t\t      (label_ref (match_operand 3 \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  visium_split_cbranch (GET_CODE (operands[0]), operands[1], operands[2],\n+\t\t\toperands[3]);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"cmp\")])\n+\n+(define_insn_and_split \"*cbranchsi4_btst_insn\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"visium_btst_operator\"\n+\t\t       [(zero_extract:SI\n+\t\t\t   (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t   (const_int 1)\n+\t\t\t   (match_operand:QI 2 \"const_shift_operand\" \"K\"))\n+\t\t        (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  visium_split_cbranch (GET_CODE (operands[0]), XEXP (operands[0], 0),\n+\t\t\tXEXP (operands[0], 1), operands[3]);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"cmp\")])\n+\n+(define_expand \"cbranchsf4\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"visium_fp_comparison_operator\"\n+\t\t       [(match_operand:SF 1 \"fp_reg_operand\")\n+\t\t        (match_operand:SF 2 \"fp_reg_or_0_operand\")])\n+\t\t      (label_ref (match_operand 3 \"\"))\n+\t\t      (pc)))]\n+  \"TARGET_FPU\"\n+)\n+\n+(define_insn_and_split \"*cbranchsf4_insn\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"visium_fp_comparison_operator\"\n+\t\t       [(match_operand:SF 1 \"fp_reg_operand\" \"f\")\n+\t\t        (match_operand:SF 2 \"fp_reg_or_0_operand\" \"fG\")])\n+\t\t      (label_ref (match_operand 3 \"\"))\n+\t\t      (pc)))]\n+  \"TARGET_FPU\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  visium_split_cbranch (GET_CODE (operands[0]), operands[1], operands[2],\n+\t\t\toperands[3]);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"fcmp\")])\n+\n+; Now match both normal and inverted branches.\n+\n+(define_insn \"*normal_branch\"\n+  [(set (pc)\n+        (if_then_else (match_operator 1 \"visium_branch_operator\"\n+                       [(reg R_FLAGS) (const_int 0)])\n+                      (label_ref (match_operand 0 \"\"))\n+                      (pc)))]\n+  \"reload_completed\"\n+{\n+  return output_cbranch (operands[0], GET_CODE (operands[1]),\n+                         GET_MODE (XEXP (operands[1], 0)), 0, insn);\n+}\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"*inverted_branch\"\n+  [(set (pc)\n+        (if_then_else (match_operator 1 \"visium_branch_operator\"\n+                       [(reg R_FLAGS) (const_int 0)])\n+                      (pc)\n+                      (label_ref (match_operand 0 \"\"))))]\n+  \"reload_completed\"\n+{\n+  return output_cbranch (operands[0], GET_CODE (operands[1]),\n+                         GET_MODE (XEXP (operands[1], 0)), 1, insn);\n+}\n+  [(set_attr \"type\" \"branch\")])\n+\n+; And then match both normal and inverted returns.\n+\n+(define_insn \"*cond_<return_str>return\"\n+  [(set (pc)\n+        (if_then_else (match_operator 0 \"visium_branch_operator\"\n+                       [(reg R_FLAGS) (const_int 0)])\n+                      (any_return)\n+                      (pc)))]\n+  \"<return_pred> && reload_completed\"\n+{\n+  return output_cbranch (pc_rtx, GET_CODE (operands[0]),\n+                         GET_MODE (XEXP (operands[0], 0)), 0, insn);\n+}\n+  [(set_attr \"type\" \"ret\")])\n+\n+(define_insn \"*inverted_cond_<return_str>return\"\n+  [(set (pc)\n+        (if_then_else (match_operator 0 \"visium_branch_operator\"\n+                       [(reg R_FLAGS) (const_int 0)])\n+                      (pc)\n+                      (any_return)))]\n+  \"<return_pred> && reload_completed\"\n+{\n+  return output_cbranch (pc_rtx, GET_CODE (operands[0]),\n+                         GET_MODE (XEXP (operands[0], 0)), 1, insn);\n+}\n+  [(set_attr \"type\" \"ret\")])\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Unconditional branch instructions\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_insn \"jump\"\n+  [(set (pc)\n+        (label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+{\n+  return output_ubranch (operands[0], insn);\n+}\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc)\n+        (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"bra     tr,%0,r0%#\t\t;indirect jump\"\n+  [(set_attr \"type\" \"abs_branch\")])\n+\n+(define_insn \"tablejump\"\n+  [(set (pc)\n+        (match_operand:SI 0 \"register_operand\" \"r\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"bra     tr,%0,r0%#\t\t;tablejump\"\n+  [(set_attr \"type\" \"abs_branch\")])\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Subprogram call instructions\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+; Subroutine call instruction returning no value.  Operand 0 is the function\n+; to call; operand 1 is the number of bytes of arguments pushed (in mode\n+; 'SImode', except it is normally a 'const_int'); operand 2 is the number of\n+; registers used as operands.\n+\n+(define_expand \"call\"\n+  [(parallel [(call (match_operand 0 \"\" \"\")\n+\t\t    (match_operand 1 \"\" \"\"))\n+\t      (use (match_operand 2 \"\" \"\"))\n+\t      (clobber (match_dup 3))])]\n+  \"\"\n+{\n+  if (GET_CODE (XEXP (operands[0], 0)) != REG)\n+    XEXP (operands[0], 0) = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));\n+\n+  if (!operands[2])\n+    operands[2] =  const0_rtx;\n+\n+  operands[3] = gen_rtx_REG (Pmode, R_LINK);\n+})\n+\n+(define_insn \"*call_internal\"\n+  [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"l,!r\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (use (match_operand 2 \"\" \"\"))\n+   (clobber (match_operand 3 \"\" \"\"))]\n+  \"!SIBLING_CALL_P (insn)\"\n+  \"bra     tr,%0,%3%#\t\t;call\"\n+  [(set_attr \"type\" \"call\")])\n+\n+; Subroutine call instruction returning a value.  Operand 0 is the hard\n+; register in which the value is returned.  There are three more operands, the\n+; same as the three operands of the 'call' instruction (but with numbers\n+; increased by one).\n+\n+(define_expand \"call_value\"\n+  [(parallel [(set (match_operand 0 \"register_operand\" \"\")\n+\t\t   (call (match_operand 1 \"\" \"\")\n+\t\t\t (match_operand 2 \"\" \"\")))\n+\t      (use (match_operand 3 \"\" \"\"))\n+\t      (clobber (match_dup 4))])]\n+  \"\"\n+{\n+  if (GET_CODE (XEXP (operands[1], 0)) != REG)\n+    XEXP (operands[1], 0) = copy_to_mode_reg (Pmode, XEXP (operands[1], 0));\n+\n+  if (!operands[3])\n+    operands[3] = const0_rtx;\n+\n+  operands[4] = gen_rtx_REG (Pmode, R_LINK);\n+})\n+\n+(define_insn \"*call_value_internal\"\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"l,!r\"))\n+\t      (match_operand 2 \"\" \"\")))\n+\t(use (match_operand 3 \"\" \"\"))\n+\t(clobber (match_operand 4 \"\" \"\"))]\n+  \"!SIBLING_CALL_P (insn)\"\n+  \"bra     tr,%1,%4%#\t\t;call value\"\n+  [(set_attr \"type\" \"call\")])\n+\n+; Tail calls are similar, except that the link register is not used.  But\n+; we don't use r0 as the destination register of the branch because we want\n+; the Branch Pre-decode Logic of the GR6 to use the Address Load Array to\n+; predict the branch target.\n+\n+(define_expand \"sibcall\"\n+  [(parallel [(call (match_operand 0 \"\" \"\")\n+\t\t    (match_operand 1 \"\" \"\"))\n+\t      (use (match_operand 2 \"\" \"\"))\n+\t      (clobber (match_dup 3))])]\n+  \"\"\n+{\n+  if (GET_CODE (XEXP (operands[0], 0)) != REG)\n+    XEXP (operands[0], 0) = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));\n+\n+  if (!operands[2])\n+    operands[2] = const0_rtx;\n+\n+  operands[3] = gen_rtx_SCRATCH (SImode);\n+})\n+\n+(define_insn \"*sibcall_internal\"\n+  [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"k\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (use (match_operand 2 \"\" \"\"))\n+   (clobber (match_scratch:SI 3 \"=0\"))]\n+  \"SIBLING_CALL_P (insn)\"\n+  \"bra     tr,%0,%0%#\t\t;sibcall\"\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_expand \"sibcall_value\"\n+  [(parallel [(set (match_operand 0 \"register_operand\" \"\")\n+\t\t   (call (match_operand 1 \"\" \"\")\n+\t\t\t (match_operand 2 \"\" \"\")))\n+\t      (use (match_operand 3 \"\" \"\"))\n+\t      (clobber (match_dup 4))])]\n+  \"\"\n+{\n+  if (GET_CODE (XEXP (operands[1], 0)) != REG)\n+    XEXP (operands[1], 0) = copy_to_mode_reg (Pmode, XEXP (operands[1], 0));\n+\n+  if (!operands[3])\n+    operands[3] = const0_rtx;\n+\n+  operands[4] = gen_rtx_SCRATCH (SImode);\n+})\n+\n+(define_insn \"*sibcall_value_internal\"\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"k\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (use (match_operand 3 \"\" \"\"))\n+   (clobber (match_scratch:SI 4 \"=1\"))]\n+  \"SIBLING_CALL_P (insn)\"\n+  \"bra     tr,%1,%1%#\t\t;sibcall value\"\n+  [(set_attr \"type\" \"call\")])\n+\n+; Call subroutine returning any type.\n+(define_expand \"untyped_call\"\n+  [(parallel [(call (match_operand 0 \"\" \"\")\n+\t\t    (const_int 0))\n+\t      (match_operand 1 \"\" \"\")\n+\t      (match_operand 2 \"\" \"\")])]\n+  \"\"\n+{\n+  int i;\n+\n+  emit_call_insn (GEN_CALL (operands[0], const0_rtx, NULL, const0_rtx));\n+\n+  for (i = 0; i < XVECLEN (operands[2], 0); i++)\n+    {\n+      rtx set = XVECEXP (operands[2], 0, i);\n+      emit_move_insn (SET_DEST (set), SET_SRC (set));\n+    }\n+\n+  /* The optimizer does not know that the call sets the function value\n+     registers we stored in the result block.  We avoid problems by\n+     claiming that all hard registers are used and clobbered at this\n+     point.  */\n+  emit_insn (gen_blockage ());\n+\n+  DONE;\n+})\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Compare-and-store instructions\n+;;\n+;; Modes QI, HI, SI and SF are supported directly.\n+;;\n+;; Note - we do not specify the two instructions necessary to perform\n+;; a compare-and-store in the cstore<mode>4 pattern because that would\n+;; allow the comparison to be moved away from the store before the reload\n+;; pass has completed.  That would be problematical because reload can\n+;; generate instructions in between which would clobber the CC register.\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_expand \"cstore<mode>4\"\n+  [(set (match_operand:SI 0)\n+\t(match_operator:SI 1 \"visium_int_cstore_operator\"\n+\t [(match_operand:I 2 \"register_operand\")\n+\t  (match_operand:I 3 \"reg_or_0_operand\")]))]\n+  \"\"\n+{\n+  visium_expand_int_cstore (operands, <MODE>mode);\n+  DONE;\n+})\n+\n+(define_insn_and_split \"*cstore<mode>4_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ltu:SI (match_operand:I 1 \"register_operand\" \"r\")\n+\t\t(match_operand:I 2 \"reg_or_0_operand\" \"rO\")))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  visium_split_cstore (SET, operands[0], NULL_RTX,\n+\t\t       LTU, operands[1], operands[2]);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"cmp\")])\n+\n+(define_insn_and_split \"*neg_cstore<mode>4_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(neg:SI (ltu:SI (match_operand:I 1 \"register_operand\" \"r\")\n+\t\t\t(match_operand:I 2 \"reg_or_0_operand\" \"rO\"))))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  visium_split_cstore (NEG, operands[0], NULL_RTX,\n+\t\t       LTU, operands[1], operands[2]);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"cmp\")])\n+\n+(define_insn_and_split \"*<add_str>_cstore<mode>4_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(any_add:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t    (ltu:SI (match_operand:I 2 \"register_operand\" \"r\")\n+\t\t\t    (match_operand:I 3 \"reg_or_0_operand\" \"rO\"))))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  visium_split_cstore (<add_op>, operands[0], operands[1],\n+\t\t       LTU, operands[2], operands[3]);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"cmp\")])\n+\n+(define_insn_and_split \"*cstore<mode>4_sne_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ltu:SI (not:I (match_operand:I 1 \"register_operand\" \"r\"))\n+\t\t(const_int -1)))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  visium_split_cstore (SET, operands[0], NULL_RTX,\n+\t\t       LTU, gen_rtx_NOT (<MODE>mode, operands[1]), constm1_rtx);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"cmp\")])\n+\n+(define_insn_and_split \"*neg_cstore<mode>4_sne_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(neg:SI (ltu:SI (not:I (match_operand:I 1 \"register_operand\" \"r\"))\n+\t\t\t(const_int -1))))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  visium_split_cstore (NEG, operands[0], NULL_RTX,\n+\t\t       LTU, gen_rtx_NOT (<MODE>mode, operands[1]), constm1_rtx);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"cmp\")])\n+\n+(define_insn_and_split \"*<add_str>_cstore<mode>4_sne_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(any_add:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t    (ltu:SI (not:I (match_operand:I 2 \"register_operand\" \"r\"))\n+\t\t\t    (const_int -1))))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  visium_split_cstore (<add_op>, operands[0], operands[1],\n+\t\t       LTU, gen_rtx_NOT (<MODE>mode, operands[2]), constm1_rtx);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"cmp\")])\n+\n+(define_expand \"cstoresf4\"\n+  [(set (match_operand:SI 0)\n+\t(match_operator:SI 1 \"visium_fp_cstore_operator\"\n+\t [(match_operand:SF 2 \"fp_reg_operand\")\n+\t  (match_operand:SF 3 \"fp_reg_or_0_operand\")]))]\n+  \"TARGET_FPU\"\n+{\n+  visium_expand_fp_cstore (operands, SFmode);\n+  DONE;\n+})\n+\n+(define_insn_and_split \"*cstoresf4_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lt:SI (match_operand:SF 1 \"fp_reg_or_0_operand\" \"fG\")\n+\t       (match_operand:SF 2 \"fp_reg_or_0_operand\" \"fG\")))]\n+  \"TARGET_FPU\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  visium_split_cstore (SET, operands [0], NULL_RTX,\n+\t\t       LT, operands[1], operands[2]);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"fcmp\")])\n+\n+(define_insn_and_split \"*neg_cstoresf4_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(neg:SI (lt:SI (match_operand:SF 1 \"fp_reg_or_0_operand\" \"fG\")\n+\t\t       (match_operand:SF 2 \"fp_reg_or_0_operand\" \"fG\"))))]\n+  \"TARGET_FPU\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  visium_split_cstore (NEG, operands [0], NULL_RTX,\n+\t\t       LT, operands[1], operands[2]);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"fcmp\")])\n+\n+(define_insn_and_split \"*<add_str>_cstoresf4_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(any_add:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t    (lt:SI (match_operand:SF 2 \"fp_reg_or_0_operand\" \"fG\")\n+\t\t\t   (match_operand:SF 3 \"fp_reg_or_0_operand\" \"fG\"))))]\n+  \"TARGET_FPU\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  visium_split_cstore (<add_op>, operands [0], operands[1],\n+\t\t       LT, operands[2], operands[3]);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"fcmp\")])\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; RTL pro/epilogue support\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+; Expand prologue in RTL\n+(define_expand \"prologue\"\n+  [(const_int 0)]\n+  \"\"\n+{\n+  visium_expand_prologue ();\n+  DONE;\n+})\n+\n+; Expand epilogue in RTL\n+(define_expand \"epilogue\"\n+  [(return)]\n+  \"\"\n+{\n+  visium_expand_epilogue ();\n+})\n+\n+; Expand epilogue without a final jump in RTL\n+(define_expand \"sibcall_epilogue\"\n+  [(return)]\n+  \"\"\n+{\n+  visium_expand_epilogue ();\n+  DONE;\n+})\n+\n+; The artificial dependency on the link register is to prevent the\n+; frame instruction from being put in a call delay slot, which can\n+; confuse the CFI machinery.\n+\n+(define_insn \"stack_save\"\n+  [(set (reg:SI R_FP) (reg:SI R_SP))\n+   (use (reg:SI R_LINK))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"move.l  fp,sp\t\t;stack_save\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+; The construct (mem:BLK (scratch)) is considered to alias all other\n+; memory accesses.  Thus it can be used as a memory barrier in stack\n+; deallocation patterns.\n+\n+(define_insn \"stack_restore\"\n+  [(set (reg:SI R_SP) (reg:SI R_FP))\n+   (clobber (mem:BLK (scratch)))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"move.l  sp,fp\t\t;stack_restore\"\n+  [(set_attr \"type\" \"logic\")])\n+\n+(define_insn \"stack_pop\"\n+  [(set (reg:SI R_SP)\n+        (plus:SI (reg:SI R_SP) (match_operand:SI 0 \"add_operand\" \"J,r\")))\n+   (clobber (mem:BLK (scratch)))\n+   (clobber (reg:CC R_FLAGS))]\n+  \"reload_completed\"\n+  \"@\n+    addi    sp,%0\t\t;stack pop\n+    add.l   sp,sp,%0\t\t;stack pop\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+(define_expand \"<return_str>return\"\n+  [(any_return)]\n+  \"<return_pred>\"\n+  \"\")\n+\n+(define_insn \"*<return_str>return_internal\"\n+  [(any_return)]\n+  \"!visium_interrupt_function_p ()\"\n+{\n+  return output_ubranch (pc_rtx, insn);\n+}\n+  [(set_attr \"type\" \"ret\")])\n+\n+(define_insn \"*return_internal_interrupt\"\n+  [(return)]\n+  \"visium_interrupt_function_p ()\"\n+  \"rfi\\n\\t nop\t\t\t\t;return from interrupt\"\n+  [(set_attr \"type\" \"rfi\")])\n+\n+(define_insn \"dsi\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_DSI)]\n+  \"\"\n+  \"dsi\"\n+  [(set_attr \"type\" \"dsi\")])\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; NOP (no-op instruction)\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\t\t\t;generated nop\"\n+  [(set_attr \"type\" \"nop\")])\n+\n+(define_insn \"hazard_nop\"\n+  [(unspec_volatile [(const_int 0)] UNSPEC_NOP)]\n+  \"\"\n+  \"nop\t\t\t;hazard avoidance nop\"\n+  [(set_attr \"type\" \"nop\")])\n+\n+(define_insn \"blockage\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_BLOCKAGE)]\n+  \"\"\n+  \"\"\n+  [(set_attr \"type\" \"nop\")])\n+\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; String/block operations\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+\n+;; String/block move insn.\n+;; Argument 0 is the destination\n+;; Argument 1 is the source\n+;; Argument 2 is the length\n+;; Argument 3 is the alignment\n+\n+(define_expand \"movmemsi\"\n+  [(parallel [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+\t\t   (match_operand:BLK 1 \"memory_operand\" \"\"))\n+\t      (use (match_operand:SI  2 \"general_operand\" \"\"))\n+\t      (use (match_operand:SI  3 \"const_int_operand\" \"\"))])]\n+  \"\"\n+{\n+  if (visium_expand_block_move (operands))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n+(define_insn \"*bmd\"\n+  [(set (mem:BLK (reg:SI R_R1))\n+        (mem:BLK (reg:SI R_R2)))\n+   (use (reg:SI R_R3))\n+   (clobber (reg:SI R_R1))\n+   (clobber (reg:SI R_R2))\n+   (clobber (reg:SI R_R3))\n+   (clobber (reg:SI R_R4))\n+   (clobber (reg:SI R_R5))\n+   (clobber (reg:SI R_R6))]\n+  \"TARGET_BMI\"\n+  \"bmd     r1,r2,r3\"\n+  [(set_attr \"type\" \"bmi\")])\n+\n+;; String/block set insn.\n+;; Argument 0 is the destination\n+;; Argument 1 is the length\n+;; Argument 2 is the value\n+;; Argument 3 is the alignment\n+\n+(define_expand \"setmemsi\"\n+  [(parallel [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+\t\t   (match_operand 2 \"nonmemory_operand\" \"\"))\n+\t      (use (match_operand:SI  1 \"general_operand\" \"\"))\n+\t      (use (match_operand:SI  3 \"const_int_operand\" \"\"))])]\n+  \"\"\n+{\n+  if (visium_expand_block_set (operands))\n+    DONE;\n+  else\n+    FAIL;\n+})"}, {"sha": "75c166e77658f5af15c65f658ccbf6a049d76587", "filename": "gcc/config/visium/visium.opt", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfig%2Fvisium%2Fvisium.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfig%2Fvisium%2Fvisium.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.opt?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -0,0 +1,82 @@\n+; Options for Visium.\n+; Copyright (C) 2005-2015 Free Software Foundation, Inc.\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it\n+; under the terms of the GNU General Public License as published\n+; by the Free Software Foundation; either version 3, or (at your\n+; option) any later version.\n+;\n+; GCC is distributed in the hope that it will be useful, but WITHOUT\n+; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+; License for more details.\n+;\n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING3.  If not see\n+; <http://www.gnu.org/licenses/>.  */\n+\n+HeaderInclude\n+config/visium/visium-opts.h\n+\n+mdebug\n+Target RejectNegative\n+Link with libc.a and libdebug.a\n+\n+msim\n+Target RejectNegative\n+Link with libc.a and libsim.a\n+\n+mfpu\n+Target Report Mask(FPU)\n+Use hardware FP (default)\n+\n+mhard-float\n+Target RejectNegative Mask(FPU) MaskExists\n+Use hardware FP\n+\n+msoft-float\n+Target RejectNegative InverseMask(FPU)\n+Do not use hardware FP\n+\n+mcpu=\n+Target RejectNegative Joined Var(visium_cpu_and_features) Enum(visium_processor_type) Init(PROCESSOR_GR5)\n+Use features of and schedule code for given CPU\n+\n+mtune=\n+Target RejectNegative Joined Var(visium_cpu) Enum(visium_processor_type) Init(PROCESSOR_GR5)\n+Schedule code for given CPU\n+\n+Enum\n+Name(visium_processor_type) Type(enum processor_type)\n+\n+EnumValue\n+Enum(visium_processor_type) String(mcm) Value(PROCESSOR_GR5)\n+\n+EnumValue\n+Enum(visium_processor_type) String(gr5) Value(PROCESSOR_GR5)\n+\n+EnumValue\n+Enum(visium_processor_type) String(gr6) Value(PROCESSOR_GR6)\n+\n+msv-mode\n+Target Mask(SV_MODE)\n+Generate code for the supervisor mode (default)\n+\n+muser-mode\n+Target InverseMask(SV_MODE)\n+Generate code for the user mode\n+\n+menable-trampolines\n+Target RejectNegative\n+Only retained for backward compatibility.\n+\n+Mask(MCM)\n+; Generate code for the MCM\n+\n+Mask(BMI)\n+; Generate the Block Move Instructions\n+\n+Mask(FPU_IEEE)\n+; Generate code for an IEEE-compliant FPU"}, {"sha": "8670f730cef07e09a06763a8a11910311e327bc8", "filename": "gcc/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -26502,7 +26502,7 @@ esac\n case \"$cpu_type\" in\n   aarch64 | alpha | arm | avr | bfin | cris | i386 | m32c | m68k | microblaze \\\n   | mips | nios2 | pa | rs6000 | score | sparc | spu | tilegx | tilepro \\\n-  | xstormy16 | xtensa)\n+  | visium | xstormy16 | xtensa)\n     insn=\"nop\"\n     ;;\n   ia64 | s390)"}, {"sha": "d0101415cca94e3c592e07b96ccd1e61902e48bd", "filename": "gcc/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -4442,7 +4442,7 @@ esac\n case \"$cpu_type\" in\n   aarch64 | alpha | arm | avr | bfin | cris | i386 | m32c | m68k | microblaze \\\n   | mips | nios2 | pa | rs6000 | score | sparc | spu | tilegx | tilepro \\\n-  | xstormy16 | xtensa)\n+  | visium | xstormy16 | xtensa)\n     insn=\"nop\"\n     ;;\n   ia64 | s390)"}, {"sha": "25226824043dd404ec030b335880a59268991cf1", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -2935,12 +2935,11 @@ least version 2.20.1), and GNU C library (at least version 2.11.1).\n @item interrupt\n @cindex interrupt handler functions\n Use this attribute on the ARC, ARM, AVR, CR16, Epiphany, M32C, M32R/D,\n-m68k, MeP, MIPS, MSP430, RL78, RX and Xstormy16 ports to indicate that\n-the specified function is an\n-interrupt handler.  The compiler generates function entry and exit\n-sequences suitable for use in an interrupt handler when this attribute\n-is present.  With Epiphany targets it may also generate a special section with\n-code to initialize the interrupt vector table.\n+m68k, MeP, MIPS, MSP430, RL78, RX, Visium and Xstormy16 ports to indicate\n+that the specified function is an interrupt handler.  The compiler generates\n+function entry and exit sequences suitable for use in an interrupt handler\n+when this attribute is present.  With Epiphany targets it may also generate\n+a special section with code to initialize the interrupt vector table.\n \n Note, interrupt handlers for the Blackfin, H8/300, H8/300H, H8S, MicroBlaze,\n and SH processors can be specified via the @code{interrupt_handler} attribute."}, {"sha": "94e039d09a18d6920c294002ec8dcdef9c73d6ef", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -3349,6 +3349,8 @@ information have to.\n @item\n @uref{#tilepro-x-linux,,tilepro-*-linux*}\n @item\n+@uref{#visium-x-elf, visium-*-elf}\n+@item\n @uref{#x-x-vxworks,,*-*-vxworks*}\n @item\n @uref{#x86-64-x-x,,x86_64-*-*, amd64-*-*}\n@@ -4647,6 +4649,14 @@ port requires binutils-2.23 or newer.\n The TILEPro processor running GNU/Linux.  This port requires\n binutils-2.22 or newer.\n \n+@html\n+<hr />\n+@end html\n+@anchor{visium-x-elf}\n+@heading visium-*-elf\n+CDS VISIUMcore processor.\n+This configuration is intended for embedded systems.\n+\n @html\n <hr />\n @end html"}, {"sha": "2e587f5d8423563850c9f0f274895000e036e513", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -1064,6 +1064,10 @@ See RS/6000 and PowerPC Options.\n @emph{VAX Options}\n @gccoptlist{-mg  -mgnu  -munix}\n \n+@emph{Visium Options}\n+@gccoptlist{-mdebug -msim -mfpu -mno-fpu -mhard-float -msoft-float @gol\n+-mcpu=@var{cpu-type} -mtune=@var{cpu-type} -msv-mode -muser-mode}\n+\n @emph{VMS Options}\n @gccoptlist{-mvms-return-codes -mdebug-main=@var{prefix} -mmalloc64 @gol\n -mpointer-size=@var{size}}\n@@ -11936,6 +11940,7 @@ platform.\n * TILEPro Options::\n * V850 Options::\n * VAX Options::\n+* Visium Options::\n * VMS Options::\n * VxWorks Options::\n * x86-64 Options::\n@@ -22606,6 +22611,77 @@ GNU assembler is being used.\n Output code for G-format floating-point numbers instead of D-format.\n @end table\n \n+@node Visium Options\n+@subsection Visium Options\n+@cindex Visium options\n+\n+@table @gcctabopt\n+\n+@item -mdebug\n+@opindex mdebug\n+A program which performs file I/O and is destined to run on an MCM target\n+should be linked with this option.  It causes the libraries libc.a and\n+libdebug.a to be linked.  The program should be run on the target under\n+the control of the GDB remote debugging stub.\n+\n+@item -msim\n+@opindex msim\n+A program which performs file I/O and is destined to run on the simulator\n+should be linked with option.  This causes libraries libc.a and libsim.a to\n+be linked.\n+\n+@item -mfpu\n+@itemx -mhard-float\n+@opindex mfpu\n+@opindex mhard-float\n+Generate code containing floating-point instructions.  This is the\n+default.\n+\n+@item -mno-fpu\n+@itemx -msoft-float\n+@opindex mno-fpu\n+@opindex msoft-float\n+Generate code containing library calls for floating-point.\n+\n+@option{-msoft-float} changes the calling convention in the output file;\n+therefore, it is only useful if you compile @emph{all} of a program with\n+this option.  In particular, you need to compile @file{libgcc.a}, the\n+library that comes with GCC, with @option{-msoft-float} in order for\n+this to work.\n+\n+@item -mcpu=@var{cpu_type}\n+@opindex mcpu\n+Set the instruction set, register set, and instruction scheduling parameters\n+for machine type @var{cpu_type}.  Supported values for @var{cpu_type} are\n+@samp{mcm}, @samp{gr5} and @samp{gr6}.\n+\n+@samp{mcm} is a synonym of @samp{gr5} present for backward compatibility.\n+\n+By default (unless configured otherwise), GCC generates code for the GR5\n+variant of the Visium architecture.  \n+\n+With @option{-mcpu=gr6}, GCC generates code for the GR6 variant of the Visium\n+architecture.  The only difference from GR5 code is that the compiler will\n+generate block move instructions.\n+\n+@item -mtune=@var{cpu_type}\n+@opindex mtune\n+Set the instruction scheduling parameters for machine type @var{cpu_type},\n+but do not set the instruction set or register set that the option\n+@option{-mcpu=@var{cpu_type}} would.\n+\n+@item -msv-mode\n+@opindex msv-mode\n+Generate code for the supervisor mode, where there are no restrictions on\n+the access to general registers.  This is the default.\n+\n+@item -muser-mode\n+@opindex muser-mode\n+Generate code for the user mode, where the access to some general registers\n+is forbidden: on the GR5, registers r24 to r31 cannot be accessed in this\n+mode; on the GR6, only registers r29 to r31 are affected.\n+@end table\n+\n @node VMS Options\n @subsection VMS Options\n "}, {"sha": "934ed236c653af8effdc3efb7ca0e121d2e7b2d1", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -3972,6 +3972,56 @@ A 2-element vector constant with identical elements.\n \n @end table\n \n+@item Visium---@file{config/visium/constraints.md}\n+@table @code\n+@item b\n+EAM register @code{mdb}\n+\n+@item c\n+EAM register @code{mdc}\n+\n+@item f\n+Floating point register\n+\n+@ifset INTERNALS\n+@item k\n+Register for sibcall optimization\n+@end ifset\n+\n+@item l\n+General register, but not @code{r29}, @code{r30} and @code{r31}\n+\n+@item t\n+Register @code{r1}\n+\n+@item u\n+Register @code{r2}\n+\n+@item v\n+Register @code{r3}\n+\n+@item G\n+Floating-point constant 0.0\n+\n+@item J\n+Integer constant in the range 0 .. 65535 (16-bit immediate)\n+\n+@item K\n+Integer constant in the range 1 .. 31 (5-bit immediate)\n+\n+@item L\n+Integer constant in the range @minus{}65535 .. @minus{}1 (16-bit negative immediate)\n+\n+@item M\n+Integer constant @minus{}1\n+\n+@item O\n+Integer constant 0\n+\n+@item P\n+Integer constant 32\n+@end table\n+\n @item Xtensa---@file{config/xtensa/constraints.md}\n @table @code\n @item a"}, {"sha": "cbd491cc49de9bf39bc78526e298f8dcba0fa4db", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -1,3 +1,15 @@\n+2015-01-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* lib/target-supports.exp (check_profiling_available): Return 0 for\n+\tVisium.\n+\t(check_effective_target_tls_runtime): Likewise.\n+\t(check_effective_target_logical_op_short_circuit): Return 1 for Visium.\n+\t* gcc.dg/20020312-2.c: Adjust for Visium.\n+\t* gcc.dg/tls/thr-cse-1.c: Likewise\n+\t* gcc.dg/tree-ssa/20040204-1.c: Likewise\n+\t* gcc.dg/tree-ssa/loop-1.c: Likewise.\n+\t* gcc.dg/weak/typeof-2.c: Likewise.\n+\n 2015-01-05  Radovan Obradovic <radovan.obradovic@imgtec.com>\n \n \tPR rtl-optimization/64287"}, {"sha": "71201fee26bc4b106bce50118130c748b16c9723", "filename": "gcc/testsuite/gcc.dg/20020312-2.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Ftestsuite%2Fgcc.dg%2F20020312-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Ftestsuite%2Fgcc.dg%2F20020312-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20020312-2.c?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -80,6 +80,8 @@ extern void abort (void);\n /* No pic register.  */\n #elif defined(__vax__)\n /* No pic register.  */\n+#elif defined(__VISIUM__)\n+/* No pic register.  */\n #elif defined(__xstormy16__)\n /* No pic register.  */\n #elif defined(__XTENSA__)"}, {"sha": "da2fbff96a97d6c608fd4e1d4fdfe8ce8e4e5668", "filename": "gcc/testsuite/gcc.dg/tls/thr-cse-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fthr-cse-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fthr-cse-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fthr-cse-1.c?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -18,11 +18,11 @@ int foo (int b, int c, int d)\n   return a;\n }\n \n-/* { dg-final { scan-assembler-not \"emutls_get_address.*emutls_get_address.*\" { target { ! { \"*-wrs-vxworks\"  \"*-*-darwin8\"  \"hppa*-*-hpux*\" \"spu-*-*\" \"i?86-*-mingw*\" \"x86_64-*-mingw*\" } } } } } */\n+/* { dg-final { scan-assembler-not \"emutls_get_address.*emutls_get_address.*\" { target { ! { \"*-wrs-vxworks\"  \"*-*-darwin8\"  \"hppa*-*-hpux*\" \"spu-*-*\" \"i?86-*-mingw*\" \"x86_64-*-mingw*\" visium-*-* } } } } } */\n /* { dg-final { scan-assembler-not \"call\\tL___emutls_get_address.stub.*call\\tL___emutls_get_address.stub.*\" { target \"*-*-darwin8\" } } } */\n /* { dg-final { scan-assembler-not \"(b,l|bl) __emutls_get_address.*(b,l|bl) __emutls_get_address.*\" { target \"hppa*-*-hpux*\" } } } */\n /* { dg-final { scan-assembler-not \"(brsl|brasl)\\t__emutls_get_address.*(brsl|brasl)\\t__emutls_get_address.*\" { target spu-*-* } } } */\n /* { dg-final { scan-assembler-not \"tls_lookup.*tls_lookup.*\" { target *-wrs-vxworks } } } */\n /* { dg-final { scan-assembler-not \"call\\t___emutls_get_address.*call\\t___emutls_get_address\" { target \"i?86-*-mingw*\" } } } */\n /* { dg-final { scan-assembler-not \"call\\t__emutls_get_address.*call\\t__emutls_get_address\" { target \"x86_64-*-mingw*\" } } } */\n-\n+/* { dg-final { scan-assembler-not \"%l __emutls_get_address.*%l __emutls_get_address\" { target visium-*-* } } } */"}, {"sha": "42f6a4cc646879891fb3a7605e883d6d0bece06d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20040204-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040204-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040204-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040204-1.c?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -33,5 +33,5 @@ void test55 (int x, int y)\n    that the && should be emitted (based on BRANCH_COST).  Fix this\n    by teaching dom to look through && and register all components\n    as true.  */\n-/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"optimized\" { xfail { ! \"alpha*-*-* arm*-*-* aarch64*-*-* powerpc*-*-* cris-*-* crisv32-*-* hppa*-*-* i?86-*-* mmix-*-* mips*-*-* m68k*-*-* moxie-*-* nds32*-*-* sparc*-*-* spu-*-* x86_64-*-*\" } } } } */\n+/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"optimized\" { xfail { ! \"alpha*-*-* arm*-*-* aarch64*-*-* powerpc*-*-* cris-*-* crisv32-*-* hppa*-*-* i?86-*-* mmix-*-* mips*-*-* m68k*-*-* moxie-*-* nds32*-*-* sparc*-*-* spu-*-* visium-*-* x86_64-*-*\" } } } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "f63c8a7ab6a7925c7bedc5d0f542d69345cf81e3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-1.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-1.c?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -49,11 +49,12 @@ int xxx(void)\n /* CRIS keeps the address in a register.  */\n /* m68k sometimes puts the address in a register, depending on CPU and PIC.  */\n \n-/* { dg-final { scan-assembler-times \"foo\" 5 { xfail hppa*-*-* ia64*-*-* sh*-*-* cris-*-* crisv32-*-* fido-*-* m68k-*-* i?86-*-mingw* i?86-*-cygwin* x86_64-*-mingw* } } } */\n+/* { dg-final { scan-assembler-times \"foo\" 5 { xfail hppa*-*-* ia64*-*-* sh*-*-* cris-*-* crisv32-*-* fido-*-* m68k-*-* i?86-*-mingw* i?86-*-cygwin* x86_64-*-mingw* visium-*-* } } } */\n /* { dg-final { scan-assembler-times \"foo,%r\" 5 { target hppa*-*-* } } } */\n /* { dg-final { scan-assembler-times \"= foo\"  5 { target ia64*-*-* } } } */\n /* { dg-final { scan-assembler-times \"call\\[ \\t\\]*_foo\" 5 { target i?86-*-mingw* i?86-*-cygwin* } } } */\n /* { dg-final { scan-assembler-times \"call\\[ \\t\\]*foo\" 5 { target x86_64-*-mingw* } } } */\n /* { dg-final { scan-assembler-times \"jsr|bsrf|blink\\ttr?,r18\"  5 { target sh*-*-* } } } */\n /* { dg-final { scan-assembler-times \"Jsr \\\\\\$r\" 5 { target cris-*-* } } } */\n /* { dg-final { scan-assembler-times \"\\[jb\\]sr\" 5 { target fido-*-* m68k-*-* } } } */\n+/* { dg-final { scan-assembler-times \"bra *tr,r\\[1-9\\]*,r21\" 5 { target visium-*-* } } } */"}, {"sha": "d4273e361b75365d07ef04f830983fc27af4c92c", "filename": "gcc/testsuite/gcc.dg/weak/typeof-2.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Ftestsuite%2Fgcc.dg%2Fweak%2Ftypeof-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Ftestsuite%2Fgcc.dg%2Fweak%2Ftypeof-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fweak%2Ftypeof-2.c?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -48,4 +48,6 @@ int bar3 (int x)\n // { dg-final { if [string match m68k-*-* $target_triplet ] {return} } }\n // Likewise for moxie targets.\n // { dg-final { if [string match moxie-*-* $target_triplet ] {return} } }\n+// Likewise for Visium targets.\n+// { dg-final { if [string match visium-*-* $target_triplet ] {return} } }\n // { dg-final { scan-assembler \"baz3.*baz3.*baz3.*baz3.*baz3.*baz3\" } }"}, {"sha": "119d2c578d417d32cd7157399c97bd3926e51203", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -538,6 +538,7 @@ proc check_profiling_available { test_what } {\n \t     || [istarget powerpc-*-elf]\n \t     || [istarget rx-*-*]\t\n \t     || [istarget tic6x-*-elf]\n+\t     || [istarget visium-*-*]\n \t     || [istarget xstormy16-*]\n \t     || [istarget xtensa*-*-elf]\n \t     || [istarget *-*-rtems*]\n@@ -707,9 +708,9 @@ proc check_effective_target_tls_emulated {} {\n # Return 1 if TLS executables can run correctly, 0 otherwise.\n \n proc check_effective_target_tls_runtime {} {\n-    # MSP430 runtime does not have TLS support, but just\n+    # The runtime does not have TLS support, but just\n     # running the test below is insufficient to show this.\n-    if { [istarget msp430-*-*] } {\n+    if { [istarget msp430-*-*] || [istarget visium-*-*] } {\n \treturn 0\n     }\n     return [check_runtime tls_runtime {\n@@ -6085,6 +6086,7 @@ proc check_effective_target_logical_op_short_circuit {} {\n \t || [istarget s390*-*-*]\n \t || [istarget powerpc*-*-*]\n \t || [istarget nios2*-*-*]\n+\t || [istarget visium-*-*]\n \t || [check_effective_target_arm_cortex_m] } {\n \treturn 1\n     }"}, {"sha": "241747f9562866472787bb42fe82b5703842b058", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -1,3 +1,8 @@\n+2015-01-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* config.host: Add Visium support.\n+\t* config/visium: New directory.\n+\n 2015-01-05  Jakub Jelinek  <jakub@redhat.com>\n \n \tUpdate copyright years."}, {"sha": "667eb312a66cb81c6450506f6b6215061d7b0aa3", "filename": "libgcc/config.host", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -1235,6 +1235,10 @@ vax-*-netbsdelf*)\n \t;;\n vax-*-openbsd*)\n \t;;\n+visium-*-elf*)\n+        extra_parts=\"$extra_parts crtbegin.o crtend.o crti.o crtn.o\"\n+        tmake_file=\"visium/t-visium t-fdpbit\"\n+        ;;\n xstormy16-*-elf)\n \ttmake_file=\"stormy16/t-stormy16 t-fdpbit\"\n \t;;"}, {"sha": "158ae0f326195b190e698221acd6d74927b26ba0", "filename": "libgcc/config/visium/crti.S", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2Fconfig%2Fvisium%2Fcrti.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2Fconfig%2Fvisium%2Fcrti.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fvisium%2Fcrti.S?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -0,0 +1,46 @@\n+/* crti.S for Visium.\n+   Copyright (C) 2005-2015 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+\t.file   \"crti.o\"\n+\t.ident  \"GNU C crti.o\"\n+\n+\t.section .init\n+\t.globl  __init\n+\t.type   __init,@function\n+__init:\n+\tsubi\tr23,8\n+\tnop\n+\twrite.l\t(r23),r22\n+\twrite.l\t1(r23),r21\n+\tmove.l\tr22,r23\n+\n+\t.section .fini\n+\t.globl  __fini\n+\t.type   __fini,@function\n+__fini:\n+\tsubi\tr23,8\n+\tnop\n+\twrite.l\t(r23),r22\n+\twrite.l\t1(r23),r21\n+\tmove.l\tr22,r23"}, {"sha": "a60f4de021ea977e85637a76fb7d54078cacd206", "filename": "libgcc/config/visium/crtn.S", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2Fconfig%2Fvisium%2Fcrtn.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2Fconfig%2Fvisium%2Fcrtn.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fvisium%2Fcrtn.S?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -0,0 +1,40 @@\n+/* crtn.S for Visium.\n+   Copyright (C) 2005-2015 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+\t.file   \"crtn.o\"\n+\t.ident  \"GNU C crtn.o\"\n+\n+\t.section .init\n+\tmove.l\tr23,r22\n+\tread.l\tr22,(r22)\n+\tread.l\tr21,1(r23)\n+\tbra\ttr,r21,r0\n+\t addi\tr23,8\n+\n+\t.section .fini\n+\tmove.l\tr23,r22\n+\tread.l\tr22,(r22)\n+\tread.l\tr21,1(r23)\n+\tbra\ttr,r21,r0\n+\t addi\tr23,8"}, {"sha": "38b747a9865ddd549c2e7f9d4885dcc3bf7b78ca", "filename": "libgcc/config/visium/divdi3.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2Fconfig%2Fvisium%2Fdivdi3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2Fconfig%2Fvisium%2Fdivdi3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fvisium%2Fdivdi3.c?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -0,0 +1,25 @@\n+/* Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#define L_divdi3\n+#include \"lib2funcs.c\""}, {"sha": "ba720a36d9e616458ed9f1aecc37af7bf3f8e0f7", "filename": "libgcc/config/visium/lib2funcs.c", "status": "added", "additions": 323, "deletions": 0, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2Fconfig%2Fvisium%2Flib2funcs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2Fconfig%2Fvisium%2Flib2funcs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fvisium%2Flib2funcs.c?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -0,0 +1,323 @@\n+/* Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"libgcc_tm.h\"\n+\n+#ifdef HAVE_GAS_HIDDEN\n+#define ATTRIBUTE_HIDDEN  __attribute__ ((__visibility__ (\"hidden\")))\n+#else\n+#define ATTRIBUTE_HIDDEN\n+#endif\n+\n+/* Work out the largest \"word\" size that we can deal with on this target.  */\n+#if MIN_UNITS_PER_WORD > 4\n+# define LIBGCC2_MAX_UNITS_PER_WORD 8\n+#elif (MIN_UNITS_PER_WORD > 2 \\\n+       || (MIN_UNITS_PER_WORD > 1 && __SIZEOF_LONG_LONG__ > 4))\n+# define LIBGCC2_MAX_UNITS_PER_WORD 4\n+#else\n+# define LIBGCC2_MAX_UNITS_PER_WORD MIN_UNITS_PER_WORD\n+#endif\n+\n+/* Work out what word size we are using for this compilation.\n+   The value can be set on the command line.  */\n+#ifndef LIBGCC2_UNITS_PER_WORD\n+#define LIBGCC2_UNITS_PER_WORD LIBGCC2_MAX_UNITS_PER_WORD\n+#endif\n+\n+#if LIBGCC2_UNITS_PER_WORD <= LIBGCC2_MAX_UNITS_PER_WORD\n+\n+#include \"libgcc2.h\"\n+\n+/* umul_ppmm(high_prod, low_prod, multiplier, multiplicand) multiplies two\n+   UWtype integers MULTIPLIER and MULTIPLICAND, and generates a two UWtype\n+   word product in HIGH_PROD and LOW_PROD.  */\n+\n+#undef umul_ppmm\n+#define umul_ppmm(wh, wl, u, v)\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    /* Generate multu instruction.  */\t\t\\\n+    UDWtype __t = (UDWtype)(u) * (UDWtype)(v);\t\\\n+    (wl) = (UWtype)__t;\t\t\t\t\\\n+    (wh) = (UWtype)(__t >> W_TYPE_SIZE);\t\\\n+  } while (0)\n+\n+/* sub_ddmmss(high_difference, low_difference, high_minuend, low_minuend,\n+   high_subtrahend, low_subtrahend) subtracts two two-word UWtype integers,\n+   composed by HIGH_MINUEND_1 and LOW_MINUEND_1, and HIGH_SUBTRAHEND_2 and\n+   LOW_SUBTRAHEND_2 respectively.  The result is placed in HIGH_DIFFERENCE\n+   and LOW_DIFFERENCE.  Overflow (i.e. carry out) is not stored anywhere,\n+   and is lost.  */\n+\n+#undef sub_ddmmss\n+#define sub_ddmmss(sh, sl, ah, al, bh, bl)\t\t\\\n+  __asm__ (\"sub.l   %0,%2,%4\\n\\t\"\t\t\t\\\n+\t   \"subc.l  %1,%3,%5\"\t\t\t\t\\\n+\t   : \"=&r\" (sl), \"=r\" (sh)\t\t\t\\\n+\t   : \"r\" (al), \"r\" (ah), \"r\" (bl), \"r\" (bh))\n+\n+/* udiv_qqrnnd(high_quotient, low_quotient, remainder, high_numerator,\n+   low_numerator, denominator) divides a UDWtype, composed by the UWtype\n+   HIGH_NUMERATOR and LOW_NUMERATOR, by DENOMINATOR and places the quotient\n+   in QUOTIENT and the remainder in REMAINDER.  */\n+\n+#define udiv_qqrnnd(qh, ql, r, nh, nl, d)\t\\\n+  __asm__ (\"writemd %3,%4\\n\\t\"\t\t\t\\\n+\t   \"divdu   %5\\n\\t\"\t\t\t\\\n+\t   \"readmda %0\\n\\t\"\t\t\t\\\n+\t   \"readmdb %1\\n\\t\"\t\t\t\\\n+\t   \"readmdc %2\"\t\t\t\t\\\n+\t   : \"=r\" (ql), \"=r\" (qh), \"=r\" (r)\t\\\n+\t   : \"r\" (nl), \"r\" (nh), \"r\" (d)\t\\\n+\t   : \"mdb\", \"mdc\")\n+\f\n+#if (defined (L_udivdi3) || defined (L_divdi3) || \\\n+     defined (L_umoddi3) || defined (L_moddi3))\n+#define L_udivmoddi4\n+#endif\n+\f\n+#ifdef L_udivmoddi4\n+\n+#if (defined (L_udivdi3) || defined (L_divdi3) || \\\n+     defined (L_umoddi3) || defined (L_moddi3))\n+static inline __attribute__ ((__always_inline__))\n+#endif\n+UDWtype\n+__udivmoddi4 (UDWtype n, UDWtype d, UDWtype *rp)\n+{\n+  const DWunion nn = {.ll = n};\n+  const DWunion dd = {.ll = d};\n+  DWunion rr;\n+  UWtype d0, d1, n0, n1, n2;\n+  UWtype q0, q1;\n+  UWtype b, bm;\n+\n+  d0 = dd.s.low;\n+  d1 = dd.s.high;\n+  n0 = nn.s.low;\n+  n1 = nn.s.high;\n+\n+  if (d1 == 0)\n+    {\n+      /* qq = NN / 0d */\n+\n+      if (d0 == 0)\n+\td0 = 1 / d0;\t/* Divide intentionally by zero.  */\n+\n+      udiv_qqrnnd (q1, q0, n0, n1, n0, d0);\n+\n+      /* Remainder in n0.  */\n+\n+      if (rp != 0)\n+\t{\n+\t  rr.s.low = n0;\n+\t  rr.s.high = 0;\n+\t  *rp = rr.ll;\n+\t}\n+    }\n+\n+  else\n+    {\n+      if (d1 > n1)\n+\t{\n+\t  /* 00 = nn / DD */\n+\n+\t  q0 = 0;\n+\t  q1 = 0;\n+\n+\t  /* Remainder in n1n0.  */\n+\t  if (rp != 0)\n+\t    {\n+\t      rr.s.low = n0;\n+\t      rr.s.high = n1;\n+\t      *rp = rr.ll;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* 0q = NN / dd */\n+\n+\t  count_leading_zeros (bm, d1);\n+\t  if (bm == 0)\n+\t    {\n+\t      /* From (n1 >= d1) /\\ (the most significant bit of d1 is set),\n+\t\t conclude (the most significant bit of n1 is set) /\\ (the\n+\t\t quotient digit q0 = 0 or 1).\n+\n+\t\t This special case is necessary, not an optimization.  */\n+\n+\t      /* The condition on the next line takes advantage of that\n+\t\t n1 >= d1 (true due to program flow).  */\n+\t      if (n1 > d1 || n0 >= d0)\n+\t\t{\n+\t\t  q0 = 1;\n+\t\t  sub_ddmmss (n1, n0, n1, n0, d1, d0);\n+\t\t}\n+\t      else\n+\t\tq0 = 0;\n+\n+\t      q1 = 0;\n+\n+\t      if (rp != 0)\n+\t\t{\n+\t\t  rr.s.low = n0;\n+\t\t  rr.s.high = n1;\n+\t\t  *rp = rr.ll;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      UWtype m1, m0;\n+\t      /* Normalize.  */\n+\n+\t      b = W_TYPE_SIZE - bm;\n+\n+\t      d1 = (d1 << bm) | (d0 >> b);\n+\t      d0 = d0 << bm;\n+\t      n2 = n1 >> b;\n+\t      n1 = (n1 << bm) | (n0 >> b);\n+\t      n0 = n0 << bm;\n+\n+\t      udiv_qqrnnd (q1, q0, n1, n2, n1, d1);\n+\t      umul_ppmm (m1, m0, q0, d0);\n+\n+\t      if (m1 > n1 || (m1 == n1 && m0 > n0))\n+\t\t{\n+\t\t  q0--;\n+\t\t  sub_ddmmss (m1, m0, m1, m0, d1, d0);\n+\t\t}\n+\n+\t      /* Remainder in (n1n0 - m1m0) >> bm.  */\n+\t      if (rp != 0)\n+\t\t{\n+\t\t  sub_ddmmss (n1, n0, n1, n0, m1, m0);\n+\t\t  rr.s.low = (n1 << b) | (n0 >> bm);\n+\t\t  rr.s.high = n1 >> bm;\n+\t\t  *rp = rr.ll;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  const DWunion ww = {{.low = q0, .high = q1}};\n+  return ww.ll;\n+}\n+#endif\n+\n+#ifdef L_divdi3\n+DWtype\n+__divdi3 (DWtype u, DWtype v)\n+{\n+  Wtype c = 0;\n+  DWunion uu = {.ll = u};\n+  DWunion vv = {.ll = v};\n+  DWtype w;\n+\n+  if (uu.s.high < 0)\n+    c = ~c,\n+    uu.ll = -uu.ll;\n+  if (vv.s.high < 0)\n+    c = ~c,\n+    vv.ll = -vv.ll;\n+\n+  w = __udivmoddi4 (uu.ll, vv.ll, (UDWtype *) 0);\n+  if (c)\n+    w = -w;\n+\n+  return w;\n+}\n+#endif\n+\n+#ifdef L_moddi3\n+DWtype\n+__moddi3 (DWtype u, DWtype v)\n+{\n+  Wtype c = 0;\n+  DWunion uu = {.ll = u};\n+  DWunion vv = {.ll = v};\n+  DWtype w;\n+\n+  if (uu.s.high < 0)\n+    c = ~c,\n+    uu.ll = -uu.ll;\n+  if (vv.s.high < 0)\n+    vv.ll = -vv.ll;\n+\n+  (void) __udivmoddi4 (uu.ll, vv.ll, (UDWtype*)&w);\n+  if (c)\n+    w = -w;\n+\n+  return w;\n+}\n+#endif\n+\n+#ifdef L_umoddi3\n+UDWtype\n+__umoddi3 (UDWtype u, UDWtype v)\n+{\n+  UDWtype w;\n+\n+  (void) __udivmoddi4 (u, v, &w);\n+\n+  return w;\n+}\n+#endif\n+\n+#ifdef L_udivdi3\n+UDWtype\n+__udivdi3 (UDWtype n, UDWtype d)\n+{\n+  return __udivmoddi4 (n, d, (UDWtype *) 0);\n+}\n+#endif\n+\f\n+#ifdef L_set_trampoline_parity\n+#undef int\n+extern void __set_trampoline_parity (UWtype *);\n+\n+static inline UWtype\n+parity_bit (UWtype x)\n+{\n+  x ^= x << 16;\n+  x ^= x << 8;\n+  x ^= x << 4;\n+  x ^= x << 2;\n+  x ^= x << 1;\n+  return x & ((UWtype) 1 << (W_TYPE_SIZE - 1));\n+}\n+\n+void\n+__set_trampoline_parity (UWtype *addr)\n+{\n+  int i;\n+\n+  for (i = 0; i < (TRAMPOLINE_SIZE * BITS_PER_UNIT) / W_TYPE_SIZE; i++)\n+    addr[i] |= parity_bit (addr[i]);\n+}\n+#endif\n+\f\n+#endif /* LIBGCC2_UNITS_PER_WORD <= MIN_UNITS_PER_WORD */"}, {"sha": "21efdd0f77ba01c9822f14d2792e5bd7b516ef68", "filename": "libgcc/config/visium/memcpy.c", "status": "added", "additions": 862, "deletions": 0, "changes": 862, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2Fconfig%2Fvisium%2Fmemcpy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2Fconfig%2Fvisium%2Fmemcpy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fvisium%2Fmemcpy.c?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -0,0 +1,862 @@\n+/* Copyright (C) 2012-2015 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file must be kept in sync with newlib/libc/machine/visium/memcpy.c  */\n+\n+#include <stddef.h>\n+#include \"memcpy.h\"\n+\n+#define INST_BARRIER   __asm__ __volatile__ (\"\":::\"memory\");\n+\n+#define MOVE_32_OBJECTS(in,out)\t\\\n+do {\t\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [0];\t\t\t\\\n+  m1 = in [1];\t\t\t\\\n+  m2 = in [2];\t\t\t\\\n+  m3 = in [3];\t\t\t\\\n+  out [0] = m0;\t\t\t\\\n+  out [1] = m1;\t\t\t\\\n+  out [2] = m2;\t\t\t\\\n+  out [3] = m3;\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [4];\t\t\t\\\n+  m1 = in [5];\t\t\t\\\n+  m2 = in [6];\t\t\t\\\n+  m3 = in [7];\t\t\t\\\n+  out [4] = m0;\t\t\t\\\n+  out [5] = m1;\t\t\t\\\n+  out [6] = m2;\t\t\t\\\n+  out [7] = m3;\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [8];\t\t\t\\\n+  m1 = in [9];\t\t\t\\\n+  m2 = in [10];\t\t\t\\\n+  m3 = in [11];\t\t\t\\\n+  out [8] = m0;\t\t\t\\\n+  out [9] = m1;\t\t\t\\\n+  out [10] = m2;\t\t\\\n+  out [11] = m3;\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [12];\t\t\t\\\n+  m1 = in [13];\t\t\t\\\n+  m2 = in [14];\t\t\t\\\n+  m3 = in [15];\t\t\t\\\n+  out [12] = m0;\t\t\\\n+  out [13] = m1;\t\t\\\n+  out [14] = m2;\t\t\\\n+  out [15] = m3;\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [16];\t\t\t\\\n+  m1 = in [17];\t\t\t\\\n+  m2 = in [18];\t\t\t\\\n+  m3 = in [19];\t\t\t\\\n+  out [16] = m0;\t\t\\\n+  out [17] = m1;\t\t\\\n+  out [18] = m2;\t\t\\\n+  out [19] = m3;\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [20];\t\t\t\\\n+  m1 = in [21];\t\t\t\\\n+  m2 = in [22];\t\t\t\\\n+  m3 = in [23];\t\t\t\\\n+  out [20] = m0;\t\t\\\n+  out [21] = m1;\t\t\\\n+  out [22] = m2;\t\t\\\n+  out [23] = m3;\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [24];\t\t\t\\\n+  m1 = in [25];\t\t\t\\\n+  m2 = in [26];\t\t\t\\\n+  m3 = in [27];\t\t\t\\\n+  out [24] = m0;\t\t\\\n+  out [25] = m1;\t\t\\\n+  out [26] = m2;\t\t\\\n+  out [27] = m3;\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 =\tin [28];\t\t\\\n+  m1 = in [29];\t\t\t\\\n+  m2 = in [30];\t\t\t\\\n+  m3 = in [31];\t\t\t\\\n+  out [28] = m0;\t\t\\\n+  out [29] = m1;\t\t\\\n+  out [30] = m2;\t\t\\\n+  out [31] = m3;\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  in += 32;\t\t\t\\\n+  out += 32;\t\t\t\\\n+} while(0)\n+\n+#define MOVE_16_OBJECTS(in,out)\t\\\n+do {\t\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [0];\t\t\t\\\n+  m1 = in [1];\t\t\t\\\n+  m2 = in [2];\t\t\t\\\n+  m3 = in [3];\t\t\t\\\n+  out [0] = m0;\t\t\t\\\n+  out [1] = m1;\t\t\t\\\n+  out [2] = m2;\t\t\t\\\n+  out [3] = m3;\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [4];\t\t\t\\\n+  m1 = in [5];\t\t\t\\\n+  m2 = in [6];\t\t\t\\\n+  m3 = in [7];\t\t\t\\\n+  out [4] = m0;\t\t\t\\\n+  out [5] = m1;\t\t\t\\\n+  out [6] = m2;\t\t\t\\\n+  out [7] = m3;\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [8];\t\t\t\\\n+  m1 = in [9];\t\t\t\\\n+  m2 = in [10];\t\t\t\\\n+  m3 = in [11];\t\t\t\\\n+  out [8] = m0;\t\t\t\\\n+  out [9] = m1;\t\t\t\\\n+  out [10] = m2;\t\t\\\n+  out [11] = m3;\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [12];\t\t\t\\\n+  m1 = in [13];\t\t\t\\\n+  m2 = in [14];\t\t\t\\\n+  m3 = in [15];\t\t\t\\\n+  out [12] = m0;\t\t\\\n+  out [13] = m1;\t\t\\\n+  out [14] = m2;\t\t\\\n+  out [15] = m3;\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  in += 16;\t\t\t\\\n+  out += 16;\t\t\t\\\n+} while(0)\n+\n+#define MOVE_12_OBJECTS(in,out)\t\\\n+do {\t\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [0];\t\t\t\\\n+  m1 = in [1];\t\t\t\\\n+  m2 = in [2];\t\t\t\\\n+  m3 = in [3];\t\t\t\\\n+  out [0] = m0;\t\t\t\\\n+  out [1] = m1;\t\t\t\\\n+  out [2] = m2;\t\t\t\\\n+  out [3] = m3;\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [4];\t\t\t\\\n+  m1 = in [5];\t\t\t\\\n+  m2 = in [6];\t\t\t\\\n+  m3 = in [7];\t\t\t\\\n+  out [4] = m0;\t\t\t\\\n+  out [5] = m1;\t\t\t\\\n+  out [6] = m2;\t\t\t\\\n+  out [7] = m3;\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [8];\t\t\t\\\n+  m1 = in [9];\t\t\t\\\n+  m2 = in [10];\t\t\t\\\n+  m3 = in [11];\t\t\t\\\n+  out [8] = m0;\t\t\t\\\n+  out [9] = m1;\t\t\t\\\n+  out [10] = m2;\t\t\\\n+  out [11] = m3;\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  in += 12;\t\t\t\\\n+  out += 12;\t\t\t\\\n+} while(0)\n+\n+#define MOVE_11_OBJECTS(in,out)\t\\\n+do {\t\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [0];\t\t\t\\\n+  m1 = in [1];\t\t\t\\\n+  m2 = in [2];\t\t\t\\\n+  m3 = in [3];\t\t\t\\\n+  out [0] = m0;\t\t\t\\\n+  out [1] = m1;\t\t\t\\\n+  out [2] = m2;\t\t\t\\\n+  out [3] = m3;\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [4];\t\t\t\\\n+  m1 = in [5];\t\t\t\\\n+  m2 = in [6];\t\t\t\\\n+  m3 = in [7];\t\t\t\\\n+  out [4] = m0;\t\t\t\\\n+  out [5] = m1;\t\t\t\\\n+  out [6] = m2;\t\t\t\\\n+  out [7] = m3;\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [8];\t\t\t\\\n+  m1 = in [9];\t\t\t\\\n+  m2 = in [10];\t\t\t\\\n+  out [8] = m0;\t\t\t\\\n+  out [9] = m1;\t\t\t\\\n+  out [10] = m2;\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  in += 11;\t\t\t\\\n+  out += 11;\t\t\t\\\n+} while(0)\n+\n+#define MOVE_10_OBJECTS(in,out)\t\\\n+do {\t\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [0];\t\t\t\\\n+  m1 = in [1];\t\t\t\\\n+  m2 = in [2];\t\t\t\\\n+  m3 = in [3];\t\t\t\\\n+  out [0] = m0;\t\t\t\\\n+  out [1] = m1;\t\t\t\\\n+  out [2] = m2;\t\t\t\\\n+  out [3] = m3;\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [4];\t\t\t\\\n+  m1 = in [5];\t\t\t\\\n+  m2 = in [6];\t\t\t\\\n+  m3 = in [7];\t\t\t\\\n+  out [4] = m0;\t\t\t\\\n+  m0 = in [8];\t\t\t\\\n+  out [5] = m1;\t\t\t\\\n+  m1 = in [9];\t\t\t\\\n+  out [6] = m2;\t\t\t\\\n+  out [7] = m3;\t\t\t\\\n+  out [8] = m0;\t\t\t\\\n+  out [9] = m1;\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  in += 10;\t\t\t\\\n+  out += 10;\t\t\t\\\n+} while(0)\n+\n+#define MOVE_9_OBJECTS(in,out)\t\\\n+do {\t\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [0];\t\t\t\\\n+  m1 = in [1];\t\t\t\\\n+  m2 = in [2];\t\t\t\\\n+  m3 = in [3];\t\t\t\\\n+  out [0] = m0;\t\t\t\\\n+  out [1] = m1;\t\t\t\\\n+  out [2] = m2;\t\t\t\\\n+  out [3] = m3;\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [4];\t\t\t\\\n+  m1 = in [5];\t\t\t\\\n+  m2 = in [6];\t\t\t\\\n+  m3 = in [7];\t\t\t\\\n+  out [4] = m0;\t\t\t\\\n+  out [5] = m1;\t\t\t\\\n+  out [6] = m2;\t\t\t\\\n+  out [7] = m3;\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [8];\t\t\t\\\n+  out [8] = m0;\t\t\t\\\n+  in += 9;\t\t\t\\\n+  out += 9;\t\t\t\\\n+} while(0)\n+\n+#define MOVE_8_OBJECTS(in,out)\t\\\n+do {\t\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [0];\t\t\t\\\n+  m1 = in [1];\t\t\t\\\n+  m2 = in [2];\t\t\t\\\n+  m3 = in [3];\t\t\t\\\n+  out [0] = m0;\t\t\t\\\n+  out [1] = m1;\t\t\t\\\n+  out [2] = m2;\t\t\t\\\n+  out [3] = m3;\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [4];\t\t\t\\\n+  m1 = in [5];\t\t\t\\\n+  m2 = in [6];\t\t\t\\\n+  m3 = in [7];\t\t\t\\\n+  out [4] = m0;\t\t\t\\\n+  out [5] = m1;\t\t\t\\\n+  out [6] = m2;\t\t\t\\\n+  out [7] = m3;\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  in += 8;\t\t\t\\\n+  out += 8;\t\t\t\\\n+} while(0)\n+\n+#define MOVE_7_OBJECTS(in,out)\t\\\n+do {\t\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [0];\t\t\t\\\n+  m1 = in [1];\t\t\t\\\n+  m2 = in [2];\t\t\t\\\n+  m3 = in [3];\t\t\t\\\n+  out [0] = m0;\t\t\t\\\n+  out [1] = m1;\t\t\t\\\n+  out [2] = m2;\t\t\t\\\n+  out [3] = m3;\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [4];\t\t\t\\\n+  m1 = in [5];\t\t\t\\\n+  m2 = in [6];\t\t\t\\\n+  out [4] = m0;\t\t\t\\\n+  out [5] = m1;\t\t\t\\\n+  out [6] = m2;\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  in += 7;\t\t\t\\\n+  out += 7;\t\t\t\\\n+} while(0)\n+\n+#define MOVE_6_OBJECTS(in,out)\t\\\n+do {\t\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [0];\t\t\t\\\n+  m1 = in [1];\t\t\t\\\n+  m2 = in [2];\t\t\t\\\n+  m3 = in [3];\t\t\t\\\n+  out [0] = m0;\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [4];\t\t\t\\\n+  out [1] = m1;\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m1 = in [5];\t\t\t\\\n+  out [2] = m2;\t\t\t\\\n+  out [3] = m3;\t\t\t\\\n+  out [4] = m0;\t\t\t\\\n+  out [5] = m1;\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  in += 6;\t\t\t\\\n+  out += 6;\t\t\t\\\n+} while(0)\n+\n+#define MOVE_5_OBJECTS(in,out)\t\\\n+do {\t\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [0];\t\t\t\\\n+  m1 = in [1];\t\t\t\\\n+  m2 = in [2];\t\t\t\\\n+  m3 = in [3];\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  out [0] = m0;\t\t\t\\\n+  m0 = in [4];\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  out [1] = m1;\t\t\t\\\n+  out [2] = m2;\t\t\t\\\n+  out [3] = m3;\t\t\t\\\n+  out [4] = m0;\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  in += 5;\t\t\t\\\n+  out += 5;\t\t\t\\\n+} while(0)\n+\n+#define MOVE_4_OBJECTS(in,out)\t\\\n+do {\t\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [0];\t\t\t\\\n+  m1 = in [1];\t\t\t\\\n+  m2 = in [2];\t\t\t\\\n+  m3 = in [3];\t\t\t\\\n+  out [0] = m0;\t\t\t\\\n+  out [1] = m1;\t\t\t\\\n+  out [2] = m2;\t\t\t\\\n+  out [3] = m3;\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  in += 4;\t\t\t\\\n+  out += 4;\t\t\t\\\n+} while(0)\n+\n+#define MOVE_3_OBJECTS(in,out)\t\\\n+do {\t\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [0];\t\t\t\\\n+  m1 = in [1];\t\t\t\\\n+  m2 = in [2];\t\t\t\\\n+  out [0] = m0;\t\t\t\\\n+  out [1] = m1;\t\t\t\\\n+  out [2] = m2;\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  in += 3;\t\t\t\\\n+  out += 3;\t\t\t\\\n+} while(0)\n+\n+#define MOVE_2_OBJECTS(in,out)\t\\\n+do {\t\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [0];\t\t\t\\\n+  m1 = in [1];\t\t\t\\\n+  out [0] = m0;\t\t\t\\\n+  out [1] = m1;\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  in += 2;\t\t\t\\\n+  out += 2;\t\t\t\\\n+} while(0)\n+\n+#define MOVE_1_OBJECT(in,out)\t\\\n+do {\t\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  m0 = in [0];\t\t\t\\\n+  out [0] = m0;\t\t\t\\\n+  INST_BARRIER\t\t\t\\\n+  in += 1;\t\t\t\\\n+  out += 1;\t\t\t\\\n+} while(0)\n+\n+\n+static inline void\n+__int_memcpy (void *__restrict s1, const void *__restrict s2, size_t n) \n+{\n+  int value = n;\n+  int loop_var;\n+  const int *in = s2;\n+  int *out = s1;\n+  int count;\n+  int m0,m1,m2,m3;\n+\n+  /* This code currently give a stall for any value with a 1->2 in the low 5\n+     bits, i.e.  1,2, 33,34 ? not acceptable!  */\n+  switch (value & 0x1f)\n+    {\n+    case 0:\n+      break;\n+    case 1:\n+      MOVE_1_OBJECT (in, out);\n+      break;\n+    case 2:\n+      MOVE_2_OBJECTS (in, out);\n+      break;\n+    case 3:\n+      MOVE_3_OBJECTS (in, out);\n+      break;\n+    case 4:\n+      MOVE_4_OBJECTS (in, out);\n+      break;\n+    case 5:\n+      MOVE_5_OBJECTS (in, out);\n+      break;\n+    case 6:\n+      MOVE_6_OBJECTS (in, out);\n+      break;\n+    case 7:\n+      MOVE_7_OBJECTS (in, out);\n+      break;\n+    case 8:\n+      MOVE_8_OBJECTS (in, out);\n+      break;\n+    case 9:\n+      MOVE_9_OBJECTS (in, out);\n+      break;\n+    case 10:\n+      MOVE_10_OBJECTS (in, out);\n+      break;\n+    case 11:\n+      MOVE_11_OBJECTS (in, out);\n+      break;\n+    case 12:\n+      MOVE_12_OBJECTS (in, out);\n+      break;\n+    case 13:\n+      MOVE_9_OBJECTS (in, out);\n+      MOVE_4_OBJECTS (in, out);\n+      break;\n+    case 14:\n+      MOVE_12_OBJECTS (in, out);\n+      MOVE_2_OBJECTS (in, out);\n+      break;\n+    case 15:\n+      MOVE_11_OBJECTS (in, out);\n+      MOVE_4_OBJECTS (in, out);\n+      break;\n+    case 16:\n+      MOVE_16_OBJECTS (in, out);\n+      break;\n+    case 17:\n+      MOVE_11_OBJECTS (in, out);\n+      MOVE_6_OBJECTS (in, out);\n+      break;\n+    case 18:\n+      MOVE_9_OBJECTS (in, out);\n+      MOVE_9_OBJECTS (in, out);\n+      break;\n+    case 19:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_3_OBJECTS (in, out);\n+      break;\n+    case 20:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_4_OBJECTS (in, out);\n+      break;\n+    case 21:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_5_OBJECTS (in, out);\n+      break;\n+    case 22:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_6_OBJECTS (in, out);\n+      break;\n+    case 23:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_7_OBJECTS (in, out);\n+      break;\n+    case 24:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_8_OBJECTS (in, out);\n+      break;\n+    case 25:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_9_OBJECTS (in, out);\n+      break;\n+    case 26:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_10_OBJECTS (in, out);\n+      break;\n+    case 27:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_11_OBJECTS (in, out);\n+      break;\n+    case 28:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_8_OBJECTS (in, out);\n+      MOVE_4_OBJECTS (in, out);\n+      break;\n+    case 29:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_9_OBJECTS (in, out);\n+      MOVE_4_OBJECTS (in, out);\n+      break;\n+    case 30:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_12_OBJECTS (in, out);\n+      MOVE_2_OBJECTS (in, out);\n+      break;\n+    case 31:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_11_OBJECTS (in, out);\n+      MOVE_4_OBJECTS (in, out);\n+      break;\n+    }\n+\n+  /* This loop governs the asmptoptic behaviour of this algorithm, for long\n+     word copies.  */\n+  count = value >> 5;\n+  for (loop_var = 0; loop_var < count; loop_var++)\n+    MOVE_32_OBJECTS (in, out);\n+}\n+\n+static inline void\n+__shrt_int_memcpy (void *__restrict s1, const void *__restrict s2, size_t n) \n+{\n+  int value = n;\n+  int loop_var;\n+  const short int *in = s2;\n+  int short *out = s1;\n+  int count;\n+  int m0,m1,m2,m3;\n+\n+ /* This code currently give a stall for any value with a 1->2 in the low 5\n+    bits, i.e.  1,2, 33,34 ? not acceptable!  */\n+  switch (value & 0x1f)\n+    {\n+    case 0:\n+      break;\n+    case 1:\n+      MOVE_1_OBJECT (in, out);\n+      break;\n+    case 2:\n+      MOVE_2_OBJECTS (in, out);\n+      break;\n+    case 3:\n+      MOVE_3_OBJECTS (in, out);\n+      break;\n+    case 4:\n+      MOVE_4_OBJECTS (in, out);\n+      break;\n+    case 5:\n+      MOVE_5_OBJECTS (in, out);\n+      break;\n+    case 6:\n+      MOVE_6_OBJECTS (in, out);\n+      break;\n+    case 7:\n+      MOVE_7_OBJECTS (in, out);\n+      break;\n+    case 8:\n+      MOVE_8_OBJECTS (in, out);\n+      break;\n+    case 9:\n+      MOVE_9_OBJECTS (in, out);\n+      break;\n+    case 10:\n+      MOVE_10_OBJECTS (in, out);\n+      break;\n+    case 11:\n+      MOVE_11_OBJECTS (in, out);\n+      break;\n+    case 12:\n+      MOVE_12_OBJECTS (in, out);\n+      break;\n+    case 13:\n+      MOVE_9_OBJECTS (in, out);\n+      MOVE_4_OBJECTS (in, out);\n+      break;\n+    case 14:\n+      MOVE_12_OBJECTS (in, out);\n+      MOVE_2_OBJECTS (in, out);\n+      break;\n+    case 15:\n+      MOVE_11_OBJECTS (in, out);\n+      MOVE_4_OBJECTS (in, out);\n+      break;\n+    case 16:\n+      MOVE_16_OBJECTS (in, out);\n+      break;\n+    case 17:\n+      MOVE_11_OBJECTS (in, out);\n+      MOVE_6_OBJECTS (in, out);\n+      break;\n+    case 18:\n+      MOVE_9_OBJECTS (in, out);\n+      MOVE_9_OBJECTS (in, out);\n+      break;\n+    case 19:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_3_OBJECTS (in, out);\n+      break;\n+    case 20:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_4_OBJECTS (in, out);\n+      break;\n+    case 21:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_5_OBJECTS (in, out);\n+      break;\n+    case 22:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_6_OBJECTS (in, out);\n+      break;\n+    case 23:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_7_OBJECTS (in, out);\n+      break;\n+    case 24:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_8_OBJECTS (in, out);\n+      break;\n+    case 25:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_9_OBJECTS (in, out);\n+      break;\n+    case 26:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_10_OBJECTS (in, out);\n+      break;\n+    case 27:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_11_OBJECTS (in, out);\n+      break;\n+    case 28:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_8_OBJECTS (in, out);\n+      MOVE_4_OBJECTS (in, out);\n+      break;\n+    case 29:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_9_OBJECTS (in, out);\n+      MOVE_4_OBJECTS (in, out);\n+      break;\n+    case 30:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_12_OBJECTS (in, out);\n+      MOVE_2_OBJECTS (in, out);\n+      break;\n+    case 31:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_11_OBJECTS (in, out);\n+      MOVE_4_OBJECTS (in, out);\n+      break;\n+    }\n+\n+  /* This loop governs the asmptoptic behaviour of this algorithm, for long\n+     word copies.  */\n+  count = value >> 5;\n+  for (loop_var = 0; loop_var < count; loop_var++)\n+    MOVE_32_OBJECTS (in, out);\n+}\n+\n+\n+static inline void\n+__byte_memcpy (void *__restrict s1, const void *__restrict s2, size_t n) \n+{\n+  int value = n;\n+  int loop_var;\n+  const char *in = s2;\n+  char *out = s1;\n+  int count;\n+  int m0,m1,m2,m3;\n+\n+ /* This code currently give a stall for any value with a 1->2 in the low 5\n+    bits, i.e.  1,2, 33,34 ? not acceptable!  */\n+  switch (value & 0x1f)\n+    {\n+    case 0:\n+      break;\n+    case 1:\n+      MOVE_1_OBJECT (in, out);\n+      break;\n+    case 2:\n+      MOVE_2_OBJECTS (in, out);\n+      break;\n+    case 3:\n+      MOVE_3_OBJECTS (in, out);\n+      break;\n+    case 4:\n+      MOVE_4_OBJECTS (in, out);\n+      break;\n+    case 5:\n+      MOVE_5_OBJECTS (in, out);\n+      break;\n+    case 6:\n+      MOVE_6_OBJECTS (in, out);\n+      break;\n+    case 7:\n+      MOVE_7_OBJECTS (in, out);\n+      break;\n+    case 8:\n+      MOVE_8_OBJECTS (in, out);\n+      break;\n+    case 9:\n+      MOVE_9_OBJECTS (in, out);\n+      break;\n+    case 10:\n+      MOVE_10_OBJECTS (in, out);\n+      break;\n+    case 11:\n+      MOVE_11_OBJECTS (in, out);\n+      break;\n+    case 12:\n+      MOVE_12_OBJECTS (in, out);\n+      break;\n+    case 13:\n+      MOVE_9_OBJECTS (in, out);\n+      MOVE_4_OBJECTS (in, out);\n+      break;\n+    case 14:\n+      MOVE_12_OBJECTS (in, out);\n+      MOVE_2_OBJECTS (in, out);\n+      break;\n+    case 15:\n+      MOVE_11_OBJECTS (in, out);\n+      MOVE_4_OBJECTS (in, out);\n+      break;\n+    case 16:\n+      MOVE_16_OBJECTS (in, out);\n+      break;\n+    case 17:\n+      MOVE_11_OBJECTS (in, out);\n+      MOVE_6_OBJECTS (in, out);\n+      break;\n+    case 18:\n+      MOVE_9_OBJECTS (in, out);\n+      MOVE_9_OBJECTS (in, out);\n+      break;\n+    case 19:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_3_OBJECTS (in, out);\n+      break;\n+    case 20:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_4_OBJECTS (in, out);\n+      break;\n+    case 21:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_5_OBJECTS (in, out);\n+      break;\n+    case 22:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_6_OBJECTS (in, out);\n+      break;\n+    case 23:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_7_OBJECTS (in, out);\n+      break;\n+    case 24:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_8_OBJECTS (in, out);\n+      break;\n+    case 25:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_9_OBJECTS (in, out);\n+      break;\n+    case 26:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_10_OBJECTS (in, out);\n+      break;\n+    case 27:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_11_OBJECTS (in, out);\n+      break;\n+    case 28:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_8_OBJECTS (in, out);\n+      MOVE_4_OBJECTS (in, out);\n+      break;\n+    case 29:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_9_OBJECTS (in, out);\n+      MOVE_4_OBJECTS (in, out);\n+      break;\n+    case 30:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_12_OBJECTS (in, out);\n+      MOVE_2_OBJECTS (in, out);\n+      break;\n+    case 31:\n+      MOVE_16_OBJECTS (in, out);\n+      MOVE_11_OBJECTS (in, out);\n+      MOVE_4_OBJECTS (in, out);\n+      break;\n+    }\n+\n+  /* This loop governs the asmptoptic behaviour of this algorithm, for long\n+     word copies.  */\n+  count = value >> 5;\n+  for (loop_var = 0; loop_var < count; loop_var++)\n+    MOVE_32_OBJECTS (in, out);\n+}\n+\n+\n+/* Exposed interface.  */\n+\n+#ifndef __VISIUM_ARCH_BMI__\n+\n+void\n+__long_int_memcpy (void *__restrict s1, const void *__restrict s2, size_t n)\n+{\n+  __int_memcpy (s1, s2, n);\n+}\n+\n+#endif /* !__VISIUM_ARCH_BMI__ */\n+\n+void\n+__wrd_memcpy (void *__restrict s1, const void *__restrict s2, size_t n)\n+{\n+  __shrt_int_memcpy (s1, s2, n);\n+}\n+\n+void\n+__byt_memcpy (void *__restrict s1, const void *__restrict s2, size_t n)\n+{\n+  __byte_memcpy (s1, s2, n);\n+}"}, {"sha": "5df81763fb50fc95b7930607eb093ac28cea8644", "filename": "libgcc/config/visium/memcpy.h", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2Fconfig%2Fvisium%2Fmemcpy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2Fconfig%2Fvisium%2Fmemcpy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fvisium%2Fmemcpy.h?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -0,0 +1,33 @@\n+/* Copyright (C) 2012-2015 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Specialized variants of memcpy called directly from compiled code.  */\n+\n+extern void\n+__long_int_memcpy (void *__restrict s1, const void *__restrict s2, size_t n);\n+\n+extern void\n+__wrd_memcpy (void *__restrict s1, const void *__restrict s2, size_t n);\n+\n+extern void\n+__byt_memcpy (void *__restrict s1, const void *__restrict s2, size_t n);"}, {"sha": "5f81679fddcf63305f3b71d2f9ba210e829f9e01", "filename": "libgcc/config/visium/memset.c", "status": "added", "additions": 664, "deletions": 0, "changes": 664, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2Fconfig%2Fvisium%2Fmemset.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2Fconfig%2Fvisium%2Fmemset.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fvisium%2Fmemset.c?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -0,0 +1,664 @@\n+/* Copyright (C) 2012-2015 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file must be kept in sync with newlib/libc/machine/visium/memset.c  */\n+\n+#include <stddef.h>\n+#include \"memset.h\"\n+\n+#define SET_32_OBJECTS(out)\t\\\n+do {\t\t\t\t\\\n+  out [0] = m0;\t\t\t\\\n+  out [1] = m0;\t\t\t\\\n+  out [2] = m0;\t\t\t\\\n+  out [3] = m0;\t\t\t\\\n+  out [4] = m0;\t\t\t\\\n+  out [5] = m0;\t\t\t\\\n+  out [6] = m0;\t\t\t\\\n+  out [7] = m0;\t\t\t\\\n+  out [8] = m0;\t\t\t\\\n+  out [9] = m0;\t\t\t\\\n+  out [10] = m0;\t\t\\\n+  out [11] = m0;\t\t\\\n+  out [12] = m0;\t\t\\\n+  out [13] = m0;\t\t\\\n+  out [14] = m0;\t\t\\\n+  out [15] = m0;\t\t\\\n+  out [16] = m0;\t\t\\\n+  out [17] = m0;\t\t\\\n+  out [18] = m0;\t\t\\\n+  out [19] = m0;\t\t\\\n+  out [20] = m0;\t\t\\\n+  out [21] = m0;\t\t\\\n+  out [22] = m0;\t\t\\\n+  out [23] = m0;\t\t\\\n+  out [24] = m0;\t\t\\\n+  out [25] = m0;\t\t\\\n+  out [26] = m0;\t\t\\\n+  out [27] = m0;\t\t\\\n+  out [28] = m0;\t\t\\\n+  out [29] = m0;\t\t\\\n+  out [30] = m0;\t\t\\\n+  out [31] = m0;\t\t\\\n+  out += 32;\t\t\t\\\n+} while(0)\n+\n+#define SET_16_OBJECTS(out)\t\\\n+do {\t\t\t\t\\\n+  out [0] = m0;\t\t\t\\\n+  out [1] = m0;\t\t\t\\\n+  out [2] = m0;\t\t\t\\\n+  out [3] = m0;\t\t\t\\\n+  out [4] = m0;\t\t\t\\\n+  out [5] = m0;\t\t\t\\\n+  out [6] = m0;\t\t\t\\\n+  out [7] = m0;\t\t\t\\\n+  out [8] = m0;\t\t\t\\\n+  out [9] = m0;\t\t\t\\\n+  out [10] = m0;\t\t\\\n+  out [11] = m0;\t\t\\\n+  out [12] = m0;\t\t\\\n+  out [13] = m0;\t\t\\\n+  out [14] = m0;\t\t\\\n+  out [15] = m0;\t\t\\\n+  out += 16;\t\t\t\\\n+} while(0)\n+\n+#define SET_12_OBJECTS(out)\t\\\n+do {\t\t\t\t\\\n+  out [0] = m0;\t\t\t\\\n+  out [1] = m0;\t\t\t\\\n+  out [2] = m0;\t\t\t\\\n+  out [3] = m0;\t\t\t\\\n+  out [4] = m0;\t\t\t\\\n+  out [5] = m0;\t\t\t\\\n+  out [6] = m0;\t\t\t\\\n+  out [7] = m0;\t\t\t\\\n+  out [8] = m0;\t\t\t\\\n+  out [9] = m0;\t\t\t\\\n+  out [10] = m0;\t\t\\\n+  out [11] = m0;\t\t\\\n+  out += 12;\t\t\t\\\n+} while(0)\n+\n+#define SET_11_OBJECTS(out)\t\\\n+do {\t\t\t\t\\\n+  out [0] = m0;\t\t\t\\\n+  out [1] = m0;\t\t\t\\\n+  out [2] = m0;\t\t\t\\\n+  out [3] = m0;\t\t\t\\\n+  out [4] = m0;\t\t\t\\\n+  out [5] = m0;\t\t\t\\\n+  out [6] = m0;\t\t\t\\\n+  out [7] = m0;\t\t\t\\\n+  out [8] = m0;\t\t\t\\\n+  out [9] = m0;\t\t\t\\\n+  out [10] = m0;\t\t\\\n+  out += 11;\t\t\t\\\n+} while(0)\n+\n+#define SET_10_OBJECTS(out)\t\\\n+do {\t\t\t\t\\\n+  out [0] = m0;\t\t\t\\\n+  out [1] = m0;\t\t\t\\\n+  out [2] = m0;\t\t\t\\\n+  out [3] = m0;\t\t\t\\\n+  out [4] = m0;\t\t\t\\\n+  out [5] = m0;\t\t\t\\\n+  out [6] = m0;\t\t\t\\\n+  out [7] = m0;\t\t\t\\\n+  out [8] = m0;\t\t\t\\\n+  out [9] = m0;\t\t\t\\\n+  out += 10;\t\t\t\\\n+} while(0)\n+\n+#define SET_9_OBJECTS(out)\t\\\n+do {\t\t\t\t\\\n+  out [0] = m0;\t\t\t\\\n+  out [1] = m0;\t\t\t\\\n+  out [2] = m0;\t\t\t\\\n+  out [3] = m0;\t\t\t\\\n+  out [4] = m0;\t\t\t\\\n+  out [5] = m0;\t\t\t\\\n+  out [6] = m0;\t\t\t\\\n+  out [7] = m0;\t\t\t\\\n+  out [8] = m0;\t\t\t\\\n+  out += 9;\t\t\t\\\n+} while(0)\n+\n+#define SET_8_OBJECTS(out)\t\\\n+do {\t\t\t\t\\\n+  out [0] = m0;\t\t\t\\\n+  out [1] = m0;\t\t\t\\\n+  out [2] = m0;\t\t\t\\\n+  out [3] = m0;\t\t\t\\\n+  out [4] = m0;\t\t\t\\\n+  out [5] = m0;\t\t\t\\\n+  out [6] = m0;\t\t\t\\\n+  out [7] = m0;\t\t\t\\\n+  out += 8;\t\t\t\\\n+} while(0)\n+\n+#define SET_7_OBJECTS(out)\t\\\n+do {\t\t\t\t\\\n+  out [0] = m0;\t\t\t\\\n+  out [1] = m0;\t\t\t\\\n+  out [2] = m0;\t\t\t\\\n+  out [3] = m0;\t\t\t\\\n+  out [4] = m0;\t\t\t\\\n+  out [5] = m0;\t\t\t\\\n+  out [6] = m0;\t\t\t\\\n+  out += 7;\t\t\t\\\n+} while(0)\n+\n+#define SET_6_OBJECTS(out)\t\\\n+do {\t\t\t\t\\\n+  out [0] = m0;\t\t\t\\\n+  out [1] = m0;\t\t\t\\\n+  out [2] = m0;\t\t\t\\\n+  out [3] = m0;\t\t\t\\\n+  out [4] = m0;\t\t\t\\\n+  out [5] = m0;\t\t\t\\\n+  out += 6;\t\t\t\\\n+} while(0)\n+\n+#define SET_5_OBJECTS(out)\t\\\n+do {\t\t\t\t\\\n+  out [0] = m0;\t\t\t\\\n+  out [1] = m0;\t\t\t\\\n+  out [2] = m0;\t\t\t\\\n+  out [3] = m0;\t\t\t\\\n+  out [4] = m0;\t\t\t\\\n+  out += 5;\t\t\t\\\n+} while(0)\n+\n+#define SET_4_OBJECTS(out)\t\\\n+do {\t\t\t\t\\\n+  out [0] = m0;\t\t\t\\\n+  out [1] = m0;\t\t\t\\\n+  out [2] = m0;\t\t\t\\\n+  out [3] = m0;\t\t\t\\\n+  out += 4;\t\t\t\\\n+} while(0)\n+\n+#define SET_3_OBJECTS(out)\t\\\n+do {\t\t\t\t\\\n+  out [0] = m0;\t\t\t\\\n+  out [1] = m0;\t\t\t\\\n+  out [2] = m0;\t\t\t\\\n+  out += 3;\t\t\t\\\n+} while(0)\n+\n+#define SET_2_OBJECTS(out)\t\\\n+do {\t\t\t\t\\\n+  out [0] = m0;\t\t\t\\\n+  out [1] = m0;\t\t\t\\\n+  out += 2;\t\t\t\\\n+} while(0)\n+\n+#define SET_1_OBJECT(out)\t\\\n+do {\t\t\t\t\\\n+  out [0] = m0;\t\t\t\\\n+  out += 1;\t\t\t\\\n+} while(0)\n+\n+\n+static inline void\n+__int_memset (void *__restrict s1, int val, size_t n)\n+{\n+  int value = n;\n+  int loop_var;\n+  int *out = s1;\n+  int count;\n+  int m0 = val;\n+\n+  /* This code currently give a stall for any value with a 1->2 in the low 5\n+     bits, i.e.  1,2, 33,34 ? not acceptable!  */\n+  switch (value & 0x1f)\n+    {\n+    case 0:\n+      break;\n+    case 1:\n+      SET_1_OBJECT (out);\n+      break;\n+    case 2:\n+      SET_2_OBJECTS (out);\n+      break;\n+    case 3:\n+      SET_3_OBJECTS (out);\n+      break;\n+    case 4:\n+      SET_4_OBJECTS (out);\n+      break;\n+    case 5:\n+      SET_5_OBJECTS (out);\n+      break;\n+    case 6:\n+      SET_6_OBJECTS (out);\n+      break;\n+    case 7:\n+      SET_7_OBJECTS (out);\n+      break;\n+    case 8:\n+      SET_8_OBJECTS (out);\n+      break;\n+    case 9:\n+      SET_9_OBJECTS (out);\n+      break;\n+    case 10:\n+      SET_10_OBJECTS (out);\n+      break;\n+    case 11:\n+      SET_11_OBJECTS (out);\n+      break;\n+    case 12:\n+      SET_12_OBJECTS (out);\n+      break;\n+    case 13:\n+      SET_9_OBJECTS (out);\n+      SET_4_OBJECTS (out);\n+      break;\n+    case 14:\n+      SET_12_OBJECTS (out);\n+      SET_2_OBJECTS (out);\n+      break;\n+    case 15:\n+      SET_11_OBJECTS (out);\n+      SET_4_OBJECTS (out);\n+      break;\n+    case 16:\n+      SET_16_OBJECTS (out);\n+      break;\n+    case 17:\n+      SET_11_OBJECTS (out);\n+      SET_6_OBJECTS (out);\n+      break;\n+    case 18:\n+      SET_9_OBJECTS (out);\n+      SET_9_OBJECTS (out);\n+      break;\n+    case 19:\n+      SET_16_OBJECTS (out);\n+      SET_3_OBJECTS (out);\n+      break;\n+    case 20:\n+      SET_16_OBJECTS (out);\n+      SET_4_OBJECTS (out);\n+      break;\n+    case 21:\n+      SET_16_OBJECTS (out);\n+      SET_5_OBJECTS (out);\n+      break;\n+    case 22:\n+      SET_16_OBJECTS (out);\n+      SET_6_OBJECTS (out);\n+      break;\n+    case 23:\n+      SET_16_OBJECTS (out);\n+      SET_7_OBJECTS (out);\n+      break;\n+    case 24:\n+      SET_16_OBJECTS (out);\n+      SET_8_OBJECTS (out);\n+      break;\n+    case 25:\n+      SET_16_OBJECTS (out);\n+      SET_9_OBJECTS (out);\n+      break;\n+    case 26:\n+      SET_16_OBJECTS (out);\n+      SET_10_OBJECTS (out);\n+      break;\n+    case 27:\n+      SET_16_OBJECTS (out);\n+      SET_11_OBJECTS (out);\n+      break;\n+    case 28:\n+      SET_16_OBJECTS (out);\n+      SET_8_OBJECTS (out);\n+      SET_4_OBJECTS (out);\n+      break;\n+    case 29:\n+      SET_16_OBJECTS (out);\n+      SET_9_OBJECTS (out);\n+      SET_4_OBJECTS (out);\n+      break;\n+    case 30:\n+      SET_16_OBJECTS (out);\n+      SET_12_OBJECTS (out);\n+      SET_2_OBJECTS (out);\n+      break;\n+    case 31:\n+      SET_16_OBJECTS (out);\n+      SET_11_OBJECTS (out);\n+      SET_4_OBJECTS (out);\n+      break;\n+    }\n+\n+  /* This loop governs the asmptoptic behaviour of this algorithm, for long\n+     word copies.  */\n+  count = value >> 5;\n+  for (loop_var = 0; loop_var < count; loop_var++)\n+    SET_32_OBJECTS (out);\n+}\n+\n+static inline void\n+__short_int_memset (void *__restrict s1, int val, size_t n)\n+{\n+  int value = n;\n+  int loop_var;\n+  int short *out = s1;\n+  int count;\n+  int m0 = val;\n+\n+  /* This code currently give a stall for any value with a 1->2 in the low 5\n+     bits, i.e.  1,2, 33,34 ? not acceptable!  */\n+  switch (value & 0x1f)\n+    {\n+    case 0:\n+      break;\n+    case 1:\n+      SET_1_OBJECT (out);\n+      break;\n+    case 2:\n+      SET_2_OBJECTS (out);\n+      break;\n+    case 3:\n+      SET_3_OBJECTS (out);\n+      break;\n+    case 4:\n+      SET_4_OBJECTS (out);\n+      break;\n+    case 5:\n+      SET_5_OBJECTS (out);\n+      break;\n+    case 6:\n+      SET_6_OBJECTS (out);\n+      break;\n+    case 7:\n+      SET_7_OBJECTS (out);\n+      break;\n+    case 8:\n+      SET_8_OBJECTS (out);\n+      break;\n+    case 9:\n+      SET_9_OBJECTS (out);\n+      break;\n+    case 10:\n+      SET_10_OBJECTS (out);\n+      break;\n+    case 11:\n+      SET_11_OBJECTS (out);\n+      break;\n+    case 12:\n+      SET_12_OBJECTS (out);\n+      break;\n+    case 13:\n+      SET_9_OBJECTS (out);\n+      SET_4_OBJECTS (out);\n+      break;\n+    case 14:\n+      SET_12_OBJECTS (out);\n+      SET_2_OBJECTS (out);\n+      break;\n+    case 15:\n+      SET_11_OBJECTS (out);\n+      SET_4_OBJECTS (out);\n+      break;\n+    case 16:\n+      SET_16_OBJECTS (out);\n+      break;\n+    case 17:\n+      SET_11_OBJECTS (out);\n+      SET_6_OBJECTS (out);\n+      break;\n+    case 18:\n+      SET_9_OBJECTS (out);\n+      SET_9_OBJECTS (out);\n+      break;\n+    case 19:\n+      SET_16_OBJECTS (out);\n+      SET_3_OBJECTS (out);\n+      break;\n+    case 20:\n+      SET_16_OBJECTS (out);\n+      SET_4_OBJECTS (out);\n+      break;\n+    case 21:\n+      SET_16_OBJECTS (out);\n+      SET_5_OBJECTS (out);\n+      break;\n+    case 22:\n+      SET_16_OBJECTS (out);\n+      SET_6_OBJECTS (out);\n+      break;\n+    case 23:\n+      SET_16_OBJECTS (out);\n+      SET_7_OBJECTS (out);\n+      break;\n+    case 24:\n+      SET_16_OBJECTS (out);\n+      SET_8_OBJECTS (out);\n+      break;\n+    case 25:\n+      SET_16_OBJECTS (out);\n+      SET_9_OBJECTS (out);\n+      break;\n+    case 26:\n+      SET_16_OBJECTS (out);\n+      SET_10_OBJECTS (out);\n+      break;\n+    case 27:\n+      SET_16_OBJECTS (out);\n+      SET_11_OBJECTS (out);\n+      break;\n+    case 28:\n+      SET_16_OBJECTS (out);\n+      SET_8_OBJECTS (out);\n+      SET_4_OBJECTS (out);\n+      break;\n+    case 29:\n+      SET_16_OBJECTS (out);\n+      SET_9_OBJECTS (out);\n+      SET_4_OBJECTS (out);\n+      break;\n+    case 30:\n+      SET_16_OBJECTS (out);\n+      SET_12_OBJECTS (out);\n+      SET_2_OBJECTS (out);\n+      break;\n+    case 31:\n+      SET_16_OBJECTS (out);\n+      SET_11_OBJECTS (out);\n+      SET_4_OBJECTS (out);\n+      break;\n+    }\n+\n+  /* This loop governs the asmptoptic behaviour of this algorithm, for long\n+     word copies.  */\n+  count = value >> 5;\n+  for (loop_var = 0; loop_var < count; loop_var++)\n+    SET_32_OBJECTS (out);\n+}\n+\n+static inline void\n+__byte_memset (void *__restrict s1, int val, size_t n)\n+{\n+  int value = n;\n+  int loop_var;\n+  char *out = s1;\n+  int count;\n+  int m0 = val;\n+\n+  /* This code currently give a stall for any value with a 1->2 in the low 5\n+     bits, i.e.  1,2, 33,34 ? not acceptable!  */\n+  switch (value & 0x1f)\n+    {\n+    case 0:\n+      break;\n+    case 1:\n+      SET_1_OBJECT (out);\n+      break;\n+    case 2:\n+      SET_2_OBJECTS (out);\n+      break;\n+    case 3:\n+      SET_3_OBJECTS (out);\n+      break;\n+    case 4:\n+      SET_4_OBJECTS (out);\n+      break;\n+    case 5:\n+      SET_5_OBJECTS (out);\n+      break;\n+    case 6:\n+      SET_6_OBJECTS (out);\n+      break;\n+    case 7:\n+      SET_7_OBJECTS (out);\n+      break;\n+    case 8:\n+      SET_8_OBJECTS (out);\n+      break;\n+    case 9:\n+      SET_9_OBJECTS (out);\n+      break;\n+    case 10:\n+      SET_10_OBJECTS (out);\n+      break;\n+    case 11:\n+      SET_11_OBJECTS (out);\n+      break;\n+    case 12:\n+      SET_12_OBJECTS (out);\n+      break;\n+    case 13:\n+      SET_9_OBJECTS (out);\n+      SET_4_OBJECTS (out);\n+      break;\n+    case 14:\n+      SET_12_OBJECTS (out);\n+      SET_2_OBJECTS (out);\n+      break;\n+    case 15:\n+      SET_11_OBJECTS (out);\n+      SET_4_OBJECTS (out);\n+      break;\n+    case 16:\n+      SET_16_OBJECTS (out);\n+      break;\n+    case 17:\n+      SET_11_OBJECTS (out);\n+      SET_6_OBJECTS (out);\n+      break;\n+    case 18:\n+      SET_9_OBJECTS (out);\n+      SET_9_OBJECTS (out);\n+      break;\n+    case 19:\n+      SET_16_OBJECTS (out);\n+      SET_3_OBJECTS (out);\n+      break;\n+    case 20:\n+      SET_16_OBJECTS (out);\n+      SET_4_OBJECTS (out);\n+      break;\n+    case 21:\n+      SET_16_OBJECTS (out);\n+      SET_5_OBJECTS (out);\n+      break;\n+    case 22:\n+      SET_16_OBJECTS (out);\n+      SET_6_OBJECTS (out);\n+      break;\n+    case 23:\n+      SET_16_OBJECTS (out);\n+      SET_7_OBJECTS (out);\n+      break;\n+    case 24:\n+      SET_16_OBJECTS (out);\n+      SET_8_OBJECTS (out);\n+      break;\n+    case 25:\n+      SET_16_OBJECTS (out);\n+      SET_9_OBJECTS (out);\n+      break;\n+    case 26:\n+      SET_16_OBJECTS (out);\n+      SET_10_OBJECTS (out);\n+      break;\n+    case 27:\n+      SET_16_OBJECTS (out);\n+      SET_11_OBJECTS (out);\n+      break;\n+    case 28:\n+      SET_16_OBJECTS (out);\n+      SET_8_OBJECTS (out);\n+      SET_4_OBJECTS (out);\n+      break;\n+    case 29:\n+      SET_16_OBJECTS (out);\n+      SET_9_OBJECTS (out);\n+      SET_4_OBJECTS (out);\n+      break;\n+    case 30:\n+      SET_16_OBJECTS (out);\n+      SET_12_OBJECTS (out);\n+      SET_2_OBJECTS (out);\n+      break;\n+    case 31:\n+      SET_16_OBJECTS (out);\n+      SET_11_OBJECTS (out);\n+      SET_4_OBJECTS (out);\n+      break;\n+    }\n+\n+  /* This loop governs the asmptoptic behaviour of this algorithm, for long\n+     word copies.  */\n+  count = value >> 5;\n+  for (loop_var = 0; loop_var < count; loop_var++)\n+    SET_32_OBJECTS (out);\n+}\n+\n+\n+/* Exposed interface.  */\n+\n+void\n+__long_int_memset (void *__restrict s, int c, size_t n)\n+{\n+  int ic = (c << 24) + ((char) c << 16) + ((char) c << 8) + (char) c;\n+  __int_memset (s, ic, n);\n+}\n+\n+void\n+__wrd_memset (void *__restrict s, int c, size_t n)\n+{\n+  int sc = ((c << 8) + (char) c);\n+  __short_int_memset (s, sc, n);\n+}\n+\n+void\n+__byt_memset (void *__restrict s, int c, size_t n)\n+{\n+  __byte_memset (s, c, n);\n+}"}, {"sha": "92eb1a3b85993b301495acbf9cea0e550988ccec", "filename": "libgcc/config/visium/memset.h", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2Fconfig%2Fvisium%2Fmemset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2Fconfig%2Fvisium%2Fmemset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fvisium%2Fmemset.h?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -0,0 +1,33 @@\n+/* Copyright (C) 2012-2015 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Specialized variants of memset called directly from compiled code.  */\n+\n+extern void\n+__long_int_memset (void *__restrict s, int c, size_t n);\n+\n+extern void\n+__wrd_memset (void *__restrict s, int c, size_t n);\n+\n+extern void\n+__byt_memset (void *__restrict s, int c, size_t n);"}, {"sha": "bf7a63f3a3a86b70cb695d08b0095ae97e02ae93", "filename": "libgcc/config/visium/moddi3.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2Fconfig%2Fvisium%2Fmoddi3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2Fconfig%2Fvisium%2Fmoddi3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fvisium%2Fmoddi3.c?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -0,0 +1,25 @@\n+/* Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#define L_moddi3\n+#include \"lib2funcs.c\""}, {"sha": "134cf2b7c878fc051e8d14ab6f77fafcf99baa23", "filename": "libgcc/config/visium/set_trampoline_parity.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2Fconfig%2Fvisium%2Fset_trampoline_parity.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2Fconfig%2Fvisium%2Fset_trampoline_parity.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fvisium%2Fset_trampoline_parity.c?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -0,0 +1,25 @@\n+/* Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#define L_set_trampoline_parity\n+#include \"lib2funcs.c\""}, {"sha": "ea5976291c15512b7b4863661f9df62daf4682c3", "filename": "libgcc/config/visium/t-visium", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2Fconfig%2Fvisium%2Ft-visium", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2Fconfig%2Fvisium%2Ft-visium", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fvisium%2Ft-visium?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -0,0 +1,29 @@\n+# Copyright (C) 2003-2015 Free Software Foundation, Inc.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+LIB2FUNCS_EXCLUDE += _divdi3 _moddi3 _udivdi3 _umoddi3 _udivmoddi4\n+\n+LIB2ADD += \\\n+  $(srcdir)/config/visium/divdi3.c \\\n+  $(srcdir)/config/visium/moddi3.c \\\n+  $(srcdir)/config/visium/udivdi3.c \\\n+  $(srcdir)/config/visium/umoddi3.c \\\n+  $(srcdir)/config/visium/udivmoddi4.c \\\n+  $(srcdir)/config/visium/memcpy.c \\\n+  $(srcdir)/config/visium/memset.c \\\n+  $(srcdir)/config/visium/set_trampoline_parity.c"}, {"sha": "c595251971b3fa5e1c2eeb0bacb796e0ec8fce14", "filename": "libgcc/config/visium/udivdi3.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2Fconfig%2Fvisium%2Fudivdi3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2Fconfig%2Fvisium%2Fudivdi3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fvisium%2Fudivdi3.c?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -0,0 +1,25 @@\n+/* Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#define L_udivdi3\n+#include \"lib2funcs.c\""}, {"sha": "bd45a5c7c6fe51474d73050fefa40e1701ba046b", "filename": "libgcc/config/visium/udivmoddi4.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2Fconfig%2Fvisium%2Fudivmoddi4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2Fconfig%2Fvisium%2Fudivmoddi4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fvisium%2Fudivmoddi4.c?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -0,0 +1,25 @@\n+/* Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#define L_udivmoddi4\n+#include \"lib2funcs.c\""}, {"sha": "cd2b23e0d05852eed2c5258346892a7c2e315dee", "filename": "libgcc/config/visium/umoddi3.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2Fconfig%2Fvisium%2Fumoddi3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0969ec7d5df9c55d0d0e4ecf30221f2096c98498/libgcc%2Fconfig%2Fvisium%2Fumoddi3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fvisium%2Fumoddi3.c?ref=0969ec7d5df9c55d0d0e4ecf30221f2096c98498", "patch": "@@ -0,0 +1,25 @@\n+/* Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#define L_umoddi3\n+#include \"lib2funcs.c\""}]}