{"sha": "32ad6a47f78997e7cb032cea8c45ad09d57a5b7a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJhZDZhNDdmNzg5OTdlN2NiMDMyY2VhOGM0NWFkMDlkNTdhNWI3YQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2003-06-09T07:10:47Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2003-06-09T07:10:47Z"}, "message": "mips-protos.h (mips_output_division): Declare.\n\n\t* config/mips/mips-protos.h (mips_output_division): Declare.\n\t* config/mips/mips.h (MASK_CHECK_RANGE_DIV): Remove.\n\t(MASK_BRANCHLIKELY): Use MASK_CHECK_RANGE_DIV's old number.\n\t(TARGET_NO_CHECK_ZERO_DIV, TARGET_CHECK_RANGE_DIV): Remove.\n\t(TARGET_CHECK_ZERO_DIV): New macro.\n\t(TARGET_SWITCHES): Remove -mcheck-range-div & -mno-check-range-div.\n\t* config/mips/mips.c (mips_output_division): New function.\n\t* config/mips/mips.md (length): Take TARGET_CHECK_ZERO_DIV into\n\taccount when calculating the default length of a division.\n\t(divmodsi4, divmoddi4, udivmodsi4, udivmoddi4): Turn into define_insns.\n\tEnable regardless of optimization level.  Use mips_output_division.\n\t(divmodsi4_internal, divmoddi4_internal, udivmodsi4_internal,\n\tudivmoddi4_internal, div_trap, div_trap_normal, div_trap_mips16,\n\tdivsi3, divsi3_internal, divdi3, divdi3_internal, modsi3,\n\tmodsi3_internal, moddi3, moddi3_internal, udivsi3, udivsi3_internal,\n\tudivdi3, udivdi3_internal, umodsi3, umodsi3_internal, umoddi3,\n\tumoddi3_internal): Remove.\n\nFrom-SVN: r67655", "tree": {"sha": "4d243014dd807b969b2e3cb453fdb425ec9ac906", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d243014dd807b969b2e3cb453fdb425ec9ac906"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32ad6a47f78997e7cb032cea8c45ad09d57a5b7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32ad6a47f78997e7cb032cea8c45ad09d57a5b7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32ad6a47f78997e7cb032cea8c45ad09d57a5b7a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32ad6a47f78997e7cb032cea8c45ad09d57a5b7a/comments", "author": null, "committer": null, "parents": [{"sha": "d334c3c18f48af480423dc1926cebf87069c83da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d334c3c18f48af480423dc1926cebf87069c83da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d334c3c18f48af480423dc1926cebf87069c83da"}], "stats": {"total": 573, "additions": 64, "deletions": 509}, "files": [{"sha": "452a23243ee34ee1af84d2ce36f1ccefa0715000", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ad6a47f78997e7cb032cea8c45ad09d57a5b7a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ad6a47f78997e7cb032cea8c45ad09d57a5b7a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=32ad6a47f78997e7cb032cea8c45ad09d57a5b7a", "patch": "@@ -1,3 +1,23 @@\n+2003-06-09  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips-protos.h (mips_output_division): Declare.\n+\t* config/mips/mips.h (MASK_CHECK_RANGE_DIV): Remove.\n+\t(MASK_BRANCHLIKELY): Use MASK_CHECK_RANGE_DIV's old number.\n+\t(TARGET_NO_CHECK_ZERO_DIV, TARGET_CHECK_RANGE_DIV): Remove.\n+\t(TARGET_CHECK_ZERO_DIV): New macro.\n+\t(TARGET_SWITCHES): Remove -mcheck-range-div & -mno-check-range-div.\n+\t* config/mips/mips.c (mips_output_division): New function.\n+\t* config/mips/mips.md (length): Take TARGET_CHECK_ZERO_DIV into\n+\taccount when calculating the default length of a division.\n+\t(divmodsi4, divmoddi4, udivmodsi4, udivmoddi4): Turn into define_insns.\n+\tEnable regardless of optimization level.  Use mips_output_division.\n+\t(divmodsi4_internal, divmoddi4_internal, udivmodsi4_internal,\n+\tudivmoddi4_internal, div_trap, div_trap_normal, div_trap_mips16,\n+\tdivsi3, divsi3_internal, divdi3, divdi3_internal, modsi3,\n+\tmodsi3_internal, moddi3, moddi3_internal, udivsi3, udivsi3_internal,\n+\tudivdi3, udivdi3_internal, umodsi3, umodsi3_internal, umoddi3,\n+\tumoddi3_internal): Remove.\n+\n 2003-06-09  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.c (mips_reg_names): Change hilo entry to \"\"."}, {"sha": "a9480d39840a536003d24053a52f7fef6bd1f76a", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ad6a47f78997e7cb032cea8c45ad09d57a5b7a/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ad6a47f78997e7cb032cea8c45ad09d57a5b7a/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=32ad6a47f78997e7cb032cea8c45ad09d57a5b7a", "patch": "@@ -110,6 +110,7 @@ extern const char\t*mips_output_load_label PARAMS ((void));\n extern const char       *mips_output_conditional_branch PARAMS ((rtx, rtx *,\n \t\t\t\t\t\t\t\t int, int, int,\n \t\t\t\t\t\t\t\t int));\n+extern const char\t*mips_output_division PARAMS ((const char *, rtx *));\n extern int              mips_adjust_insn_length PARAMS ((rtx, int));\n extern enum reg_class\tmips_secondary_reload_class PARAMS ((enum reg_class,\n \t\t\t\t\t\t\t     enum machine_mode,"}, {"sha": "2604d49a02ae2723576c9305855638b54d31ab8a", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ad6a47f78997e7cb032cea8c45ad09d57a5b7a/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ad6a47f78997e7cb032cea8c45ad09d57a5b7a/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=32ad6a47f78997e7cb032cea8c45ad09d57a5b7a", "patch": "@@ -10217,6 +10217,28 @@ mips_output_conditional_branch (insn,\n   return 0;\n }\n \f\n+/* Used to output div or ddiv instruction DIVISION, which has the\n+   operands given by OPERANDS.  If we need a divide-by-zero check,\n+   output the instruction and return an asm string that traps if\n+   operand 2 is zero.  Otherwise just return DIVISION itself.  */\n+\n+const char *\n+mips_output_division (division, operands)\n+     const char *division;\n+     rtx *operands;\n+{\n+  if (TARGET_CHECK_ZERO_DIV)\n+    {\n+      output_asm_insn (division, operands);\n+\n+      if (TARGET_MIPS16)\n+\treturn \"bnez\\t%2,1f\\n\\tbreak\\t7\\n1:\";\n+      else\n+\treturn \"bne\\t%2,%.,1f\\n\\t%#break\\t7\\n1:\";\n+    }\n+  return division;\n+}\n+\f\n /* Return true if GIVEN is the same as CANONICAL, or if it is CANONICAL\n    with a final \"000\" replaced by \"k\".  Ignore case.\n "}, {"sha": "b40abc8245d6ab46718978a5242c03e3ec7ed2ea", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ad6a47f78997e7cb032cea8c45ad09d57a5b7a/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ad6a47f78997e7cb032cea8c45ad09d57a5b7a/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=32ad6a47f78997e7cb032cea8c45ad09d57a5b7a", "patch": "@@ -201,15 +201,13 @@ extern void\t\tsbss_section PARAMS ((void));\n #define MASK_MIPS16\t   0x00100000\t/* Generate mips16 code */\n #define MASK_NO_CHECK_ZERO_DIV \\\n \t\t\t   0x00200000\t/* divide by zero checking */\n-#define MASK_CHECK_RANGE_DIV \\\n-\t\t\t   0x00400000\t/* divide result range checking */\n+#define MASK_BRANCHLIKELY  0x00400000   /* Generate Branch Likely\n+\t\t\t\t\t   instructions.  */\n #define MASK_UNINIT_CONST_IN_RODATA \\\n \t\t\t   0x00800000\t/* Store uninitialized\n \t\t\t\t\t   consts in rodata */\n #define MASK_NO_FUSED_MADD 0x01000000   /* Don't generate floating point\n \t\t\t\t\t   multiply-add operations.  */\n-#define MASK_BRANCHLIKELY  0x02000000   /* Generate Branch Likely\n-\t\t\t\t\t   instructions.  */\n \n \t\t\t\t\t/* Debug switches, not documented */\n #define MASK_DEBUG\t0\t\t/* unused */\n@@ -294,8 +292,7 @@ extern void\t\tsbss_section PARAMS ((void));\n \n #define TARGET_4300_MUL_FIX     (target_flags & MASK_4300_MUL_FIX)\n \n-#define TARGET_NO_CHECK_ZERO_DIV (target_flags & MASK_NO_CHECK_ZERO_DIV)\n-#define TARGET_CHECK_RANGE_DIV  (target_flags & MASK_CHECK_RANGE_DIV)\n+#define TARGET_CHECK_ZERO_DIV   (!(target_flags & MASK_NO_CHECK_ZERO_DIV))\n \n #define TARGET_BRANCHLIKELY\t(target_flags & MASK_BRANCHLIKELY)\n \n@@ -624,10 +621,6 @@ extern void\t\tsbss_section PARAMS ((void));\n      N_(\"Trap on integer divide by zero\")},\t\t\t\t\\\n   {\"no-check-zero-division\", MASK_NO_CHECK_ZERO_DIV,\t\t\t\\\n      N_(\"Don't trap on integer divide by zero\")},\t\t\t\\\n-  {\"check-range-division\",MASK_CHECK_RANGE_DIV,\t\t\t\t\\\n-     N_(\"Trap on integer divide overflow\")},\t\t\t\t\\\n-  {\"no-check-range-division\",-MASK_CHECK_RANGE_DIV,\t\t\t\\\n-     N_(\"Don't trap on integer divide overflow\")},\t\t\t\\\n   { \"branch-likely\",      MASK_BRANCHLIKELY,\t\t\t\t\\\n       N_(\"Use Branch Likely instructions, overriding default for arch\")}, \\\n   { \"no-branch-likely\",  -MASK_BRANCHLIKELY,\t\t\t\t\\"}, {"sha": "85e9b2d1700a7d9ba6a9209c743f339f79b666fd", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 18, "deletions": 499, "changes": 517, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ad6a47f78997e7cb032cea8c45ad09d57a5b7a/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ad6a47f78997e7cb032cea8c45ad09d57a5b7a/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=32ad6a47f78997e7cb032cea8c45ad09d57a5b7a", "patch": "@@ -174,6 +174,11 @@\n \t  (and (eq_attr \"extended_mips16\" \"yes\")\n \t       (ne (symbol_ref \"TARGET_MIPS16\") (const_int 0)))\n \t  (const_int 8)\n+\t  (and (eq_attr \"type\" \"idiv\")\n+\t       (ne (symbol_ref \"TARGET_CHECK_ZERO_DIV\") (const_int 0)))\n+\t  (cond [(ne (symbol_ref \"TARGET_MIPS16\") (const_int 0))\n+\t\t (const_int 12)]\n+\t\t(const_int 16))\n \t  ] (const_int 4)))\n \n ;; Attribute describing the processor.  This attribute must match exactly\n@@ -2833,539 +2838,53 @@\n   [(set_attr \"type\"\t\"fdiv\")\n    (set_attr \"mode\"\t\"SF\")])\n \n-;; If optimizing, prefer the divmod functions over separate div and\n-;; mod functions, since this will allow using one instruction for both\n-;; the quotient and remainder.  At present, the divmod is not moved out\n-;; of loops if it is constant within the loop, so allow -mdebugc to\n-;; use the old method of doing things.\n-\n-;; 64 is the multiply/divide hi register\n-;; 65 is the multiply/divide lo register\n-\n-;; ??? We can't accept constants here, because the MIPS assembler will replace\n-;; a divide by power of 2 with a shift, and then the remainder is no longer\n-;; available.\n-\n-(define_expand \"divmodsi4\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(div:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t(match_operand:SI 2 \"register_operand\" \"\")))\n-   (set (match_operand:SI 3 \"register_operand\" \"\")\n-\t(mod:SI (match_dup 1)\n-\t\t(match_dup 2)))]\n-  \"optimize\"\n-  \"\n-{\n-  emit_insn (gen_divmodsi4_internal (operands[0], operands[1], operands[2],\n-\t     operands[3]));\n-  if (!TARGET_NO_CHECK_ZERO_DIV)\n-    {\n-      emit_insn (gen_div_trap (operands[2],\n-\t\t\t       GEN_INT (0),\n-\t\t\t       GEN_INT (0x7)));\n-    }\n-  if (TARGET_CHECK_RANGE_DIV)\n-    {\n-      emit_insn (gen_div_trap (operands[2],\n-\t\t\t       copy_to_mode_reg (SImode, GEN_INT (-1)),\n-\t\t\t       GEN_INT (0x6)));\n-      emit_insn (gen_div_trap (operands[2],\n-\t\t\t       copy_to_mode_reg (SImode,\n-\t\t\t\t\t\t GEN_INT\n-\t\t\t\t\t\t (trunc_int_for_mode\n-\t\t\t\t\t\t  (BITMASK_HIGH, SImode))),\n-\t\t\t       GEN_INT (0x6)));\n-    }\n-\n-  DONE;\n-}\")\n-\n-(define_insn \"divmodsi4_internal\"\n+(define_insn \"divmodsi4\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n \t(div:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t(match_operand:SI 2 \"register_operand\" \"d\")))\n    (set (match_operand:SI 3 \"register_operand\" \"=h\")\n \t(mod:SI (match_dup 1)\n \t\t(match_dup 2)))]\n-  \"optimize\"\n-  \"div\\\\t$0,%1,%2\"\n+  \"\"\n+  { return mips_output_division (\"div\\\\t$0,%1,%2\", operands); }\n   [(set_attr \"type\"\t\"idiv\")\n    (set_attr \"mode\"\t\"SI\")])\n \n-(define_expand \"divmoddi4\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(div:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t(match_operand:DI 2 \"register_operand\" \"\")))\n-   (set (match_operand:DI 3 \"register_operand\" \"\")\n-\t(mod:DI (match_dup 1)\n-\t\t(match_dup 2)))]\n-  \"TARGET_64BIT && optimize\"\n-  \"\n-{\n-  emit_insn (gen_divmoddi4_internal (operands[0], operands[1], operands[2],\n-             operands[3]));\n-  if (!TARGET_NO_CHECK_ZERO_DIV)\n-    {\n-      emit_insn (gen_div_trap (operands[2],\n-\t\t\t       GEN_INT (0),\n-\t\t\t       GEN_INT (0x7)));\n-    }\n-  if (TARGET_CHECK_RANGE_DIV)\n-    {\n-      emit_insn (gen_div_trap (operands[2],\n-\t\t\t       copy_to_mode_reg (DImode, GEN_INT (-1)),\n-\t\t\t       GEN_INT (0x6)));\n-      emit_insn (gen_div_trap (operands[2],\n-\t\t\t       copy_to_mode_reg (DImode,\n-\t\t\t\t\t\t GEN_INT (BITMASK_HIGH)),\n-\t\t\t       GEN_INT (0x6)));\n-    }\n-\n-  DONE;\n-}\")\n-\n-(define_insn \"divmoddi4_internal\"\n+(define_insn \"divmoddi4\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=l\")\n \t(div:DI (match_operand:DI 1 \"register_operand\" \"d\")\n \t\t(match_operand:DI 2 \"register_operand\" \"d\")))\n    (set (match_operand:DI 3 \"register_operand\" \"=h\")\n \t(mod:DI (match_dup 1)\n \t\t(match_dup 2)))]\n-  \"TARGET_64BIT && optimize\"\n-  \"ddiv\\\\t$0,%1,%2\"\n+  \"TARGET_64BIT\"\n+  { return mips_output_division (\"ddiv\\\\t$0,%1,%2\", operands); }\n   [(set_attr \"type\"\t\"idiv\")\n-   (set_attr \"mode\"\t\"SI\")])\n-\n-(define_expand \"udivmodsi4\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(udiv:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t (match_operand:SI 2 \"register_operand\" \"\")))\n-   (set (match_operand:SI 3 \"register_operand\" \"\")\n-\t(umod:SI (match_dup 1)\n-\t\t (match_dup 2)))]\n-  \"optimize\"\n-  \"\n-{\n-  emit_insn (gen_udivmodsi4_internal (operands[0], operands[1], operands[2],\n-                                      operands[3]));\n-  if (!TARGET_NO_CHECK_ZERO_DIV)\n-    {\n-      emit_insn (gen_div_trap (operands[2],\n-\t\t\t       GEN_INT (0),\n-\t\t\t       GEN_INT (0x7)));\n-    }\n-\n-  DONE;\n-}\")\n+   (set_attr \"mode\"\t\"DI\")])\n \n-(define_insn \"udivmodsi4_internal\"\n+(define_insn \"udivmodsi4\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n \t(udiv:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n    (set (match_operand:SI 3 \"register_operand\" \"=h\")\n \t(umod:SI (match_dup 1)\n \t\t (match_dup 2)))]\n-  \"optimize\"\n-  \"divu\\\\t$0,%1,%2\"\n+  \"\"\n+  { return mips_output_division (\"divu\\\\t$0,%1,%2\", operands); }\n   [(set_attr \"type\"\t\"idiv\")\n    (set_attr \"mode\"\t\"SI\")])\n \n-(define_expand \"udivmoddi4\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(udiv:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t (match_operand:DI 2 \"register_operand\" \"\")))\n-   (set (match_operand:DI 3 \"register_operand\" \"\")\n-\t(umod:DI (match_dup 1)\n-\t\t (match_dup 2)))]\n-  \"TARGET_64BIT && optimize\"\n-  \"\n-{\n-  emit_insn (gen_udivmoddi4_internal (operands[0], operands[1], operands[2],\n-                                      operands[3]));\n-  if (!TARGET_NO_CHECK_ZERO_DIV)\n-    {\n-      emit_insn (gen_div_trap (operands[2],\n-\t\t\t       GEN_INT (0),\n-\t\t\t       GEN_INT (0x7)));\n-    }\n-\n-  DONE;\n-}\")\n-\n-(define_insn \"udivmoddi4_internal\"\n+(define_insn \"udivmoddi4\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=l\")\n \t(udiv:DI (match_operand:DI 1 \"register_operand\" \"d\")\n \t\t (match_operand:DI 2 \"register_operand\" \"d\")))\n    (set (match_operand:DI 3 \"register_operand\" \"=h\")\n \t(umod:DI (match_dup 1)\n \t\t (match_dup 2)))]\n-  \"TARGET_64BIT && optimize\"\n-  \"ddivu\\\\t$0,%1,%2\"\n-  [(set_attr \"type\"\t\"idiv\")\n-   (set_attr \"mode\"\t\"SI\")])\n-\n-;; Division trap\n-\n-(define_expand \"div_trap\"\n-  [(trap_if (eq (match_operand 0 \"register_operand\" \"d\")\n-\t\t(match_operand 1 \"true_reg_or_0_operand\" \"dJ\"))\n-            (match_operand 2 \"immediate_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (TARGET_MIPS16)\n-    emit_insn (gen_div_trap_mips16 (operands[0],operands[1],operands[2]));\n-  else\n-    emit_insn (gen_div_trap_normal (operands[0],operands[1],operands[2]));\n-  DONE;\n-}\")\n-\n-(define_insn \"div_trap_normal\"\n-  [(trap_if (eq (match_operand 0 \"register_operand\" \"d,d\")\n-\t\t(match_operand 1 \"true_reg_or_0_operand\" \"d,J\"))\n-            (match_operand 2 \"immediate_operand\" \"\"))]\n-  \"!TARGET_MIPS16\"\n-  \"*\n-{\n-  rtx link;\n-  int have_dep_anti = 0;\n-\n-  /* For divmod if one division is not needed then we don't need an extra\n-     divide by zero trap, which is anti dependent on previous trap */\n-  for (link = LOG_LINKS (insn); link; link = XEXP (link, 1))\n-\n-    if ((int) REG_DEP_ANTI == (int) REG_NOTE_KIND (link)\n-        && GET_CODE (XEXP (link, 0)) == INSN\n-        && GET_CODE (PATTERN (XEXP (link, 0))) == TRAP_IF\n-\t&& which_alternative == 1)\n-      have_dep_anti = 1;\n-  if (! have_dep_anti)\n-    {\n-      if (GENERATE_BRANCHLIKELY)\n-\t{\n-          if (which_alternative == 1)\n-\t    return \\\"%(beql\\\\t%0,$0,1f\\\\n\\\\tbreak\\\\t%2\\\\n%~1:%)\\\";\n-\t  else\n-\t    return \\\"%(beql\\\\t%0,%1,1f\\\\n\\\\tbreak\\\\t%2\\\\n%~1:%)\\\";\n-\t}\n-      else\n-\t{\n-          if (which_alternative == 1)\n-\t    return \\\"%(bne\\\\t%0,$0,1f\\\\n\\\\tnop\\\\n\\\\tbreak\\\\t%2\\\\n%~1:%)\\\";\n-\t  else\n-\t    return \\\"%(bne\\\\t%0,%1,1f\\\\n\\\\tnop\\\\n\\\\tbreak\\\\t%2\\\\n%~1:%)\\\";\n-\t}\n-    }\n-  return \\\"\\\";\n-}\"\n-  [(set_attr \"type\" \"unknown\")\n-   (set_attr \"length\" \"12\")])\n-\n-\n-;; The mips16 bne insns is a macro which uses reg 24 as an intermediate.\n-\n-(define_insn \"div_trap_mips16\"\n-  [(trap_if (eq (match_operand 0 \"register_operand\" \"d,d\")\n-\t\t(match_operand 1 \"true_reg_or_0_operand\" \"d,J\"))\n-            (match_operand 2 \"immediate_operand\" \"\"))\n-   (clobber (reg:SI 24))]\n-  \"TARGET_MIPS16\"\n-  \"*\n-{\n-  rtx link;\n-  int have_dep_anti = 0;\n-\n-  /* For divmod if one division is not needed then we don't need an extra\n-     divide by zero trap, which is anti dependent on previous trap */\n-  for (link = LOG_LINKS (insn); link; link = XEXP (link, 1))\n-\n-    if ((int) REG_DEP_ANTI == (int) REG_NOTE_KIND (link)\n-        && GET_CODE (XEXP (link, 0)) == INSN\n-        && GET_CODE (PATTERN (XEXP (link, 0))) == TRAP_IF\n-\t&& which_alternative == 1)\n-      have_dep_anti = 1;\n-  if (! have_dep_anti)\n-    {\n-      /* No branch delay slots on mips16.  */\n-      if (which_alternative == 1)\n-        return \\\"%(bnez\\\\t%0,1f\\\\n\\\\tbreak\\\\t%2\\\\n%~1:%)\\\";\n-      else\n-        return \\\"%(bne\\\\t%0,%1,1f\\\\n\\\\tbreak\\\\t%2\\\\n%~1:%)\\\";\n-    }\n-  return \\\"\\\";\n-}\"\n-  [(set_attr \"type\" \"unknown\")\n-   (set_attr \"length\" \"12\")])\n-\n-(define_expand \"divsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(div:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t(match_operand:SI 2 \"register_operand\" \"\")))]\n-  \"!optimize\"\n-  \"\n-{\n-  emit_insn (gen_divsi3_internal (operands[0], operands[1], operands[2]));\n-\n-  if (!TARGET_NO_CHECK_ZERO_DIV)\n-    {\n-      emit_insn (gen_div_trap (operands[2],\n-\t\t\t       GEN_INT (0),\n-\t\t\t       GEN_INT (0x7)));\n-    }\n-  if (TARGET_CHECK_RANGE_DIV)\n-    {\n-      emit_insn (gen_div_trap (operands[2],\n-\t\t\t       copy_to_mode_reg (SImode, GEN_INT (-1)),\n-\t\t\t       GEN_INT (0x6)));\n-      emit_insn (gen_div_trap (operands[2],\n-\t\t\t       copy_to_mode_reg (SImode,\n-\t\t\t\t\t\t GEN_INT\n-\t\t\t\t\t\t (trunc_int_for_mode\n-\t\t\t\t\t\t  (BITMASK_HIGH, SImode))),\n-\t\t\t       GEN_INT (0x6)));\n-    }\n-\n-  DONE;\n-}\")\n-\n-(define_insn \"divsi3_internal\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n-\t(div:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t(match_operand:SI 2 \"register_operand\" \"d\")))\n-   (clobber (match_scratch:SI 3 \"=h\"))]\n-  \"!optimize\"\n-  \"div\\\\t$0,%1,%2\"\n-  [(set_attr \"type\"\t\"idiv\")\n-   (set_attr \"mode\"\t\"SI\")])\n-\n-(define_expand \"divdi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(div:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t(match_operand:DI 2 \"register_operand\" \"\")))]\n-  \"TARGET_64BIT && !optimize\"\n-  \"\n-{\n-  emit_insn (gen_divdi3_internal (operands[0], operands[1], operands[2]));\n-  if (!TARGET_NO_CHECK_ZERO_DIV)\n-    {\n-      emit_insn (gen_div_trap (operands[2],\n-\t\t\t       GEN_INT (0),\n-\t\t\t       GEN_INT (0x7)));\n-    }\n-  if (TARGET_CHECK_RANGE_DIV)\n-    {\n-      emit_insn (gen_div_trap (operands[2],\n-\t\t\t       copy_to_mode_reg (DImode, GEN_INT (-1)),\n-\t\t\t       GEN_INT (0x6)));\n-      emit_insn (gen_div_trap (operands[2],\n-\t\t\t       copy_to_mode_reg (DImode,\n-\t\t\t\t\t\t GEN_INT (BITMASK_HIGH)),\n-\t\t\t       GEN_INT (0x6)));\n-    }\n-\n-  DONE;\n-}\")\n-\n-(define_insn \"divdi3_internal\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=l\")\n-\t(div:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t(match_operand:DI 2 \"register_operand\" \"d\")))\n-   (clobber (match_scratch:SI 3 \"=h\"))]\n-  \"TARGET_64BIT && !optimize\"\n-  \"ddiv\\\\t$0,%1,%2\"\n-  [(set_attr \"type\"\t\"idiv\")\n-   (set_attr \"mode\"\t\"DI\")])\n-\n-(define_expand \"modsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(mod:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t(match_operand:SI 2 \"register_operand\" \"\")))]\n-  \"!optimize\"\n-  \"\n-{\n-  emit_insn (gen_modsi3_internal (operands[0], operands[1], operands[2]));\n-  if (!TARGET_NO_CHECK_ZERO_DIV)\n-    {\n-      emit_insn (gen_div_trap (operands[2],\n-\t\t\t       GEN_INT (0),\n-\t\t\t       GEN_INT (0x7)));\n-    }\n-  if (TARGET_CHECK_RANGE_DIV)\n-    {\n-      emit_insn (gen_div_trap (operands[2],\n-\t\t\t       copy_to_mode_reg (SImode, GEN_INT (-1)),\n-\t\t\t       GEN_INT (0x6)));\n-      emit_insn (gen_div_trap (operands[2],\n-\t\t\t       copy_to_mode_reg (SImode,\n-\t\t\t\t\t\t GEN_INT\n-\t\t\t\t\t\t (trunc_int_for_mode\n-\t\t\t\t\t\t  (BITMASK_HIGH, SImode))),\n-\t\t\t       GEN_INT (0x6)));\n-    }\n-\n-  DONE;\n-}\")\n-\n-(define_insn \"modsi3_internal\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=h\")\n-\t(mod:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t(match_operand:SI 2 \"register_operand\" \"d\")))\n-   (clobber (match_scratch:SI 3 \"=l\"))]\n-  \"!optimize\"\n-  \"div\\\\t$0,%1,%2\"\n-  [(set_attr \"type\"\t\"idiv\")\n-   (set_attr \"mode\"\t\"SI\")])\n-\n-(define_expand \"moddi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(mod:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t(match_operand:DI 2 \"register_operand\" \"\")))]\n-  \"TARGET_64BIT && !optimize\"\n-  \"\n-{\n-  emit_insn (gen_moddi3_internal (operands[0], operands[1], operands[2]));\n-  if (!TARGET_NO_CHECK_ZERO_DIV)\n-    {\n-      emit_insn (gen_div_trap (operands[2],\n-\t\t\t       GEN_INT (0),\n-\t\t\t       GEN_INT (0x7)));\n-    }\n-  if (TARGET_CHECK_RANGE_DIV)\n-    {\n-      emit_insn (gen_div_trap (operands[2],\n-\t\t\t       copy_to_mode_reg (DImode, GEN_INT (-1)),\n-\t\t\t       GEN_INT (0x6)));\n-      emit_insn (gen_div_trap (operands[2],\n-\t\t\t       copy_to_mode_reg (DImode,\n-\t\t\t\t\t\t GEN_INT (BITMASK_HIGH)),\n-\t\t\t       GEN_INT (0x6)));\n-    }\n-\n-  DONE;\n-}\")\n-\n-(define_insn \"moddi3_internal\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=h\")\n-\t(mod:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t(match_operand:DI 2 \"register_operand\" \"d\")))\n-   (clobber (match_scratch:SI 3 \"=l\"))]\n-  \"TARGET_64BIT && !optimize\"\n-  \"ddiv\\\\t$0,%1,%2\"\n-  [(set_attr \"type\"\t\"idiv\")\n-   (set_attr \"mode\"\t\"DI\")])\n-\n-(define_expand \"udivsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(udiv:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t (match_operand:SI 2 \"register_operand\" \"\")))]\n-  \"!optimize\"\n-  \"\n-{\n-  emit_insn (gen_udivsi3_internal (operands[0], operands[1], operands[2]));\n-  if (!TARGET_NO_CHECK_ZERO_DIV)\n-    {\n-      emit_insn (gen_div_trap (operands[2],\n-\t\t\t       GEN_INT (0),\n-\t\t\t       GEN_INT (0x7)));\n-    }\n-\n-  DONE;\n-}\")\n-\n-(define_insn \"udivsi3_internal\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n-\t(udiv:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n-   (clobber (match_scratch:SI 3 \"=h\"))]\n-  \"!optimize\"\n-  \"divu\\\\t$0,%1,%2\"\n-  [(set_attr \"type\"\t\"idiv\")\n-   (set_attr \"mode\"\t\"SI\")])\n-\n-(define_expand \"udivdi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(udiv:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t (match_operand:DI 2 \"register_operand\" \"\")))]\n-  \"TARGET_64BIT && !optimize\"\n-  \"\n-{\n-  emit_insn (gen_udivdi3_internal (operands[0], operands[1], operands[2]));\n-  if (!TARGET_NO_CHECK_ZERO_DIV)\n-    {\n-      emit_insn (gen_div_trap (operands[2],\n-\t\t\t       GEN_INT (0),\n-\t\t\t       GEN_INT (0x7)));\n-    }\n-\n-  DONE;\n-}\")\n-\n-(define_insn \"udivdi3_internal\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=l\")\n-\t(udiv:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t (match_operand:DI 2 \"register_operand\" \"d\")))\n-   (clobber (match_scratch:SI 3 \"=h\"))]\n-  \"TARGET_64BIT && !optimize\"\n-  \"ddivu\\\\t$0,%1,%2\"\n-  [(set_attr \"type\"\t\"idiv\")\n-   (set_attr \"mode\"\t\"DI\")])\n-\n-(define_expand \"umodsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(umod:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t (match_operand:SI 2 \"register_operand\" \"\")))]\n-  \"!optimize\"\n-  \"\n-{\n-  emit_insn (gen_umodsi3_internal (operands[0], operands[1], operands[2]));\n-  if (!TARGET_NO_CHECK_ZERO_DIV)\n-    {\n-      emit_insn (gen_div_trap (operands[2],\n-\t\t\t       GEN_INT (0),\n-\t\t\t       GEN_INT (0x7)));\n-    }\n-\n-  DONE;\n-}\")\n-\n-(define_insn \"umodsi3_internal\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=h\")\n-\t(umod:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n-   (clobber (match_scratch:SI 3 \"=l\"))]\n-  \"!optimize\"\n-  \"divu\\\\t$0,%1,%2\"\n-  [(set_attr \"type\"\t\"idiv\")\n-   (set_attr \"mode\"\t\"SI\")])\n-\n-(define_expand \"umoddi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(umod:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t (match_operand:DI 2 \"register_operand\" \"\")))]\n-  \"TARGET_64BIT && !optimize\"\n-  \"\n-{\n-  emit_insn (gen_umoddi3_internal (operands[0], operands[1], operands[2]));\n-  if (!TARGET_NO_CHECK_ZERO_DIV)\n-    {\n-      emit_insn (gen_div_trap (operands[2],\n-\t\t\t       GEN_INT (0),\n-\t\t\t       GEN_INT (0x7)));\n-    }\n-\n-  DONE;\n-}\")\n-\n-(define_insn \"umoddi3_internal\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=h\")\n-\t(umod:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t (match_operand:DI 2 \"register_operand\" \"d\")))\n-   (clobber (match_scratch:SI 3 \"=l\"))]\n-  \"TARGET_64BIT && !optimize\"\n-  \"ddivu\\\\t$0,%1,%2\"\n+  \"TARGET_64BIT\"\n+  { return mips_output_division (\"ddivu\\\\t$0,%1,%2\", operands); }\n   [(set_attr \"type\"\t\"idiv\")\n    (set_attr \"mode\"\t\"DI\")])\n-\f\n ;;\n ;;  ....................\n ;;"}]}