{"sha": "bc23502b7f6590639be6473b4b8702187cac895d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmMyMzUwMmI3ZjY1OTA2MzliZTY0NzNiNGI4NzAyMTg3Y2FjODk1ZA==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2006-01-11T13:02:18Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2006-01-11T13:02:18Z"}, "message": "re PR tree-optimization/23109 (compiler generates wrong code leading to spurious division by zero with -funsafe-math-optimizations (instead of -ftrapping-math))\n\ngcc:\n2006-01-11  Paolo Bonzini  <bonzini@gnu.org>\n\n\tPR tree-optimization/23109\n\tPR tree-optimization/23948\n\tPR tree-optimization/24123\n\n\t* Makefile.in (tree-ssa-math-opts.o): Adjust dependencies.\n        * tree-cfg.c (single_noncomplex_succ): New.\n        * tree-flow.h (single_noncomplex_succ): Declare it.\n        * tree-ssa-math-opts.c (enum place_reciprocal): Remove.\n        * tree-ssa-math-opts.c (enum place_reciprocal): Remove.\n        (struct occurrence, occ_head, occ_pool, is_divide_by, compute_merit,\n\tinsert_bb, register_division_in, insert_reciprocals,\n\treplace_reciprocal, free_bb): New.\n        (execute_cse_reciprocals_1): Rewritten.\n        (execute_cse_reciprocals): Adjust calls to execute_cse_reciprocals_1.\n        Do not commit any edge insertion.  Always compute dominators and\n        create the allocation pool.\n        * target-def.h (TARGET_MIN_DIVISIONS_FOR_RECIP_MUL): New.\n\t* target.h (struct gcc_target): Add min_divistions_for_recip_mul.\n\t* targhooks.c (default_min_divistions_for_recip_mul): New.\n\t* targhooks.h (default_min_divistions_for_recip_mul): New prototype.\n        * passes.c (init_optimization_passes): Run recip after tree loop\n        optimizations.\n        * doc/tm.texi (Misc): Document TARGET_MIN_DIVISIONS_FOR_RECIP_MUL.\n\ngcc/testsuite:\n2006-01-11  Paolo Bonzini  <bonzini@gnu.org>\n        \n        PR tree-optimization/23109\n        PR tree-optimization/23948\n        PR tree-optimization/24123\n\n        * gcc.dg/tree-ssa/recip-3.c, gcc.dg/tree-ssa/recip-4.c,\n        gcc.dg/tree-ssa/recip-5.c, gcc.dg/tree-ssa/recip-6.c,\n        gcc.dg/tree-ssa/recip-7.c, gcc.dg/tree-ssa/pr23109.c,\n        g++.dg/tree-ssa/pr23948.C: New testcases.\n        * gcc.dg/tree-ssa/recip-2.c, gcc.dg/tree-ssa/pr23234.c: Provide\n\tthree divisions in order to do the optimization.\n\nFrom-SVN: r109578", "tree": {"sha": "727cbd4df49eeb348d4444be887d342d20481475", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/727cbd4df49eeb348d4444be887d342d20481475"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc23502b7f6590639be6473b4b8702187cac895d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc23502b7f6590639be6473b4b8702187cac895d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc23502b7f6590639be6473b4b8702187cac895d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc23502b7f6590639be6473b4b8702187cac895d/comments", "author": null, "committer": null, "parents": [{"sha": "4d779342f00ac9b678043e8a2e474a1ae14b8660", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d779342f00ac9b678043e8a2e474a1ae14b8660", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d779342f00ac9b678043e8a2e474a1ae14b8660"}], "stats": {"total": 832, "additions": 729, "deletions": 103}, "files": [{"sha": "0701660bb13c3abbed290445917a9dc559b9a348", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 13, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc23502b7f6590639be6473b4b8702187cac895d", "patch": "@@ -1,3 +1,29 @@\n+2006-01-11  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\tPR tree-optimization/23109\n+\tPR tree-optimization/23948\n+\tPR tree-optimization/24123\n+\n+\t* Makefile.in (tree-ssa-math-opts.o): Adjust dependencies.\n+        * tree-cfg.c (single_noncomplex_succ): New.\n+        * tree-flow.h (single_noncomplex_succ): Declare it.\n+        * tree-ssa-math-opts.c (enum place_reciprocal): Remove.\n+        * tree-ssa-math-opts.c (enum place_reciprocal): Remove.\n+        (struct occurrence, occ_head, occ_pool, is_divide_by, compute_merit,\n+\tinsert_bb, register_division_in, insert_reciprocals,\n+\treplace_reciprocal, free_bb): New.\n+        (execute_cse_reciprocals_1): Rewritten.\n+        (execute_cse_reciprocals): Adjust calls to execute_cse_reciprocals_1.\n+        Do not commit any edge insertion.  Always compute dominators and\n+        create the allocation pool.\n+        * target-def.h (TARGET_MIN_DIVISIONS_FOR_RECIP_MUL): New.\n+\t* target.h (struct gcc_target): Add min_divistions_for_recip_mul.\n+\t* targhooks.c (default_min_divistions_for_recip_mul): New.\n+\t* targhooks.h (default_min_divistions_for_recip_mul): New prototype.\n+        * passes.c (init_optimization_passes): Run recip after tree loop\n+        optimizations.\n+        * doc/tm.texi (Misc): Document TARGET_MIN_DIVISIONS_FOR_RECIP_MUL.\n+\n 2005-01-11  Danny Berlin <dberlin@dberlin.org>\n             Kenneth Zadeck <zadeck@naturalbridge.com>\n \n@@ -151,31 +177,31 @@\n 2006-01-10  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \tPR target/20754\n-\t* pa.md: Create separate 32 and 64-bit move patterns for SI, DI, SF\n-\tand DF modes.  Add alternatives to copy between general and floating\n-\tpoint registers to the 32-bit patterns.\n-\t* pa-64.h (SECONDARY_MEMORY_NEEDED_RTX): Delete undefine.\n-\t* pa.h (SECONDARY_MEMORY_NEEDED_RTX): Delete define.\n+\t* config/pa/pa.md: Create separate 32 and 64-bit move patterns\n+\tfor SI, DI, SF and DF modes.  Add alternatives to copy between\n+\tgeneral and floating point registers to the 32-bit patterns.\n+\t* config/pa/pa-64.h (SECONDARY_MEMORY_NEEDED_RTX): Delete undefine.\n+\t* config/pa/pa.h (SECONDARY_MEMORY_NEEDED_RTX): Delete define.\n \t(SECONDARY_MEMORY_NEEDED): Secondary memory is only needed when\n \tgenerating 64-bit code.\n-\t* pa.c (output_move_double): Handle copies between general and\n-\tfloating registers.\n+\t* config/pa/pa.c (output_move_double): Handle copies between general\n+\tand floating registers.\n \n 2006-01-10  Stuart Hastings  <stuart@apple.com>\n \n-\t* gcc/config/i386/i386.md (set_got): Update.\n+\t* config/i386/i386.md (set_got): Update.\n \t(set_got_labelled): New.  (UNSPEC_LD_MPIC): New.\n \t(builtin_setjmp_receiver): Mach-O support.\n-\t* gcc/config/i386/darwin.h (TARGET_ASM_FILE_END) Define.\n+\t* config/i386/darwin.h (TARGET_ASM_FILE_END) Define.\n \t(GOT_SYMBOL_NAME): Define.\n \t(FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN): New.\n \t(TARGET_DEEP_BRANCH_PREDICTION): Remove.\n-\t* gcc/config/i386/i386.c (override_options): Revise for Darwin.\n+\t* config/i386/i386.c (override_options): Revise for Darwin.\n \t(USE_HIDDEN_LINKONCE): Enable for Mach-O.  (ix86_file_end): Mach-O\n \tsupport.  (darwin_x86_file_end): New.  (output_set_got): Add label\n \tparameter, revise for Mach-O.  (x86_output_mi_thunk): Likewise.\n-\t* gcc/config/i386/i386-protos.h (output_set_got): Likewise.\n-\t* gcc/config/darwin.c (machopic_legitimize_pic_address): Update\n+\t* config/i386/i386-protos.h (output_set_got): Likewise.\n+\t* config/darwin.c (machopic_legitimize_pic_address): Update\n \tregs_ever_live[].\n \n 2006-01-10  Kaz Kojima  <kkojima@gcc.gnu.org>\n@@ -604,7 +630,7 @@\n \n 2006-01-03  Adrian Straetling  <straetling@de.ibm.com>\n \n-\t* gcc/builtins.c (get_builtin_sync_mem): New function.\n+\t* builtins.c (get_builtin_sync_mem): New function.\n \t(expand_builtin_sync_operation, expand_builtin_compare_and_swap,\n \texpand_builtin_lock_test_and_set, expand_builtin_lock_release):\n \tCall get_builtin_sync_mem to generate mem rtx."}, {"sha": "895532158a158061029a144b4e1cef929a9b7504", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=bc23502b7f6590639be6473b4b8702187cac895d", "patch": "@@ -1970,7 +1970,8 @@ tree-ssa-loop-im.o : tree-ssa-loop-im.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) real.h $(BASIC_BLOCK_H) \\\n    hard-reg-set.h\n tree-ssa-math-opts.o : tree-ssa-math-opts.c $(TREE_FLOW_H) $(CONFIG_H) \\\n-   $(SYSTEM_H) $(TREE_H) $(TIMEVAR_H) tree-pass.h $(TM_H) $(FLAGS_H)\n+   $(SYSTEM_H) $(TREE_H) $(TIMEVAR_H) tree-pass.h $(TM_H) $(FLAGS_H) \\\n+   alloc-pool.h $(BASIC_BLOCK_H) $(TARGET_H)\n tree-ssa-alias.o : tree-ssa-alias.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) tree-inline.h $(FLAGS_H) \\\n    function.h $(TIMEVAR_H) convert.h $(TM_H) coretypes.h langhooks.h \\"}, {"sha": "146b475b96e245ff645131e6715af0f7c6039fd2", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=bc23502b7f6590639be6473b4b8702187cac895d", "patch": "@@ -8893,6 +8893,15 @@ point number to a signed fixed point number also convert validly to an\n unsigned one.\n @end defmac\n \n+@deftypefn {Target Hook} int TARGET_MIN_DIVISIONS_FOR_RECIP_MUL (enum machine_mode @var{mode})\n+When @option{-ffast-math} is in effect, GCC tries to optimize\n+divisions by the same divisor, by turning them into multiplications by\n+the reciprocal.  This target hook specifies the minimum number of divisions\n+that should be there for GCC to perform the optimization for a variable\n+of mode @var{mode}.  The default implementation returns 3 if the machine\n+has an instruction for the division, and 2 if it does not.\n+@end deftypefn\n+\n @defmac MOVE_MAX\n The maximum number of bytes that a single instruction can move quickly\n between memory and registers or between two memory locations."}, {"sha": "7d43bedd84774f13c978a95ec748232a2f134d9a", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=bc23502b7f6590639be6473b4b8702187cac895d", "patch": "@@ -551,12 +551,12 @@ init_optimization_passes (void)\n      we add may_alias right after fold builtins\n      which can create arbitrary GIMPLE.  */\n   NEXT_PASS (pass_may_alias);\n-  NEXT_PASS (pass_cse_reciprocals);\n   NEXT_PASS (pass_split_crit_edges);\n   NEXT_PASS (pass_pre);\n   NEXT_PASS (pass_may_alias);\n   NEXT_PASS (pass_sink_code);\n   NEXT_PASS (pass_tree_loop);\n+  NEXT_PASS (pass_cse_reciprocals);\n   NEXT_PASS (pass_reassoc);\n   NEXT_PASS (pass_dominator);\n "}, {"sha": "642e97010402740cbd61eab6ac94987180c5dad2", "filename": "gcc/target-def.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=bc23502b7f6590639be6473b4b8702187cac895d", "patch": "@@ -336,6 +336,10 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n #define TARGET_SHIFT_TRUNCATION_MASK default_shift_truncation_mask\n #endif\n \n+#ifndef TARGET_MIN_DIVISIONS_FOR_RECIP_MUL\n+#define TARGET_MIN_DIVISIONS_FOR_RECIP_MUL default_min_divisions_for_recip_mul\n+#endif\n+\n #ifndef TARGET_VALID_POINTER_MODE\n #define TARGET_VALID_POINTER_MODE default_valid_pointer_mode\n #endif\n@@ -588,6 +592,7 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n   TARGET_ENCODE_SECTION_INFO,\t\t\t\\\n   TARGET_STRIP_NAME_ENCODING,\t\t\t\\\n   TARGET_SHIFT_TRUNCATION_MASK,\t\t\t\\\n+  TARGET_MIN_DIVISIONS_FOR_RECIP_MUL,\t\t\\\n   TARGET_VALID_POINTER_MODE,                    \\\n   TARGET_SCALAR_MODE_SUPPORTED_P,\t\t\\\n   TARGET_VECTOR_MODE_SUPPORTED_P,               \\"}, {"sha": "b32be8301202b83736c027778609fe36296d0834", "filename": "gcc/target.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=bc23502b7f6590639be6473b4b8702187cac895d", "patch": "@@ -440,6 +440,11 @@ struct gcc_target\n      return the mask that they apply.  Return 0 otherwise.  */\n   unsigned HOST_WIDE_INT (* shift_truncation_mask) (enum machine_mode mode);\n \n+  /* Return the number of divisions in the given MODE that should be present,\n+     so that it is profitable to turn the division into a multiplication by\n+     the reciprocal.  */\n+  unsigned int (* min_divisions_for_recip_mul) (enum machine_mode mode);\n+\n   /* True if MODE is valid for a pointer in __attribute__((mode(\"MODE\"))).  */\n   bool (* valid_pointer_mode) (enum machine_mode mode);\n "}, {"sha": "786b1522afbbf59248c028b49d6eef07b97d7a2e", "filename": "gcc/targhooks.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=bc23502b7f6590639be6473b4b8702187cac895d", "patch": "@@ -148,6 +148,14 @@ default_shift_truncation_mask (enum machine_mode mode)\n   return SHIFT_COUNT_TRUNCATED ? GET_MODE_BITSIZE (mode) - 1 : 0;\n }\n \n+/* The default implementation of TARGET_MIN_DIVISIONS_FOR_RECIP_MUL.  */\n+\n+unsigned int\n+default_min_divisions_for_recip_mul (enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return have_insn_for (DIV, mode) ? 3 : 2;\n+}\n+\n /* Generic hook that takes a CUMULATIVE_ARGS pointer and returns true.  */\n \n bool"}, {"sha": "44396480b7f682a37d909b09081344ddaf7741e4", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=bc23502b7f6590639be6473b4b8702187cac895d", "patch": "@@ -33,6 +33,7 @@ extern bool default_pretend_outgoing_varargs_named (CUMULATIVE_ARGS *);\n extern enum machine_mode default_eh_return_filter_mode (void);\n extern unsigned HOST_WIDE_INT default_shift_truncation_mask\n   (enum machine_mode);\n+extern unsigned int default_min_divisions_for_recip_mul (enum machine_mode);\n \n extern tree default_stack_protect_guard (void);\n extern tree default_external_stack_protect_fail (void);"}, {"sha": "a91cd82c6d1626acaefafac24830b7b698ad274d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bc23502b7f6590639be6473b4b8702187cac895d", "patch": "@@ -1,3 +1,16 @@\n+2006-01-11  Paolo Bonzini  <bonzini@gnu.org>\n+        \n+        PR tree-optimization/23109\n+        PR tree-optimization/23948\n+        PR tree-optimization/24123\n+\n+        * gcc.dg/tree-ssa/recip-3.c, gcc.dg/tree-ssa/recip-4.c,\n+        gcc.dg/tree-ssa/recip-5.c, gcc.dg/tree-ssa/recip-6.c,\n+        gcc.dg/tree-ssa/recip-7.c, gcc.dg/tree-ssa/pr23109.c,\n+        g++.dg/tree-ssa/pr23948.C: New testcases.\n+        * gcc.dg/tree-ssa/recip-2.c, gcc.dg/tree-ssa/pr23234.c: Provide\n+\tthree divisions in order to do the optimization.\n+\n 2005-01-11  Zdenek Dvorak <dvorakz@suse.cz>\n \n \tPR c++/25632"}, {"sha": "c34161409c1c5ece91f37f8f9fec2164994cf52c", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr23948.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr23948.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr23948.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr23948.C?ref=bc23502b7f6590639be6473b4b8702187cac895d", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-options \"-O1 -ffast-math -fdump-tree-recip\" } */\n+/* { dg-do compile } */\n+\n+struct MIOFILE {\n+  ~MIOFILE();\n+};\n+double potentially_runnable_resource_share();\n+void f1(double);\n+int make_scheduler_request(double a, double b)\n+{\n+  MIOFILE mf;\n+  double prrs = potentially_runnable_resource_share();\n+  f1(a/prrs);\n+  f1(1/prrs);\n+  f1(b/prrs);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" / \" 1 \"recip\" } } */\n+/* { dg-final { cleanup-tree-dump \"recip\" } } */"}, {"sha": "e121a5538334cd150c174eb993b56365f6ee3040", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr23109.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr23109.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr23109.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr23109.c?ref=bc23502b7f6590639be6473b4b8702187cac895d", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -funsafe-math-optimizations -fdump-tree-recip -fdump-tree-lim\" } */\n+\n+double F[2] = { 0., 0. }, e = 0.;\n+\n+int main()\n+{\n+\tint i;\n+\tdouble E, W, P, d;\n+\n+        /* make sure the program crashes on FP exception */\n+        unsigned short int Mask;\n+\n+\tW = 1.;\n+\td = 2.*e;\n+\tE = 1. - d;\n+\n+\tfor( i=0; i < 2; i++ )\n+\t\tif( d > 0.01 )\n+\t\t{\n+\t\t\tP = ( W < E ) ? (W - E)/d : (E - W)/d;\n+\t\t\tF[i] += P;\n+\t\t}\n+\n+\treturn 0;\n+}\n+\n+/* LIM only performs the transformation in the no-trapping-math case.  In\n+   the future we will do it for trapping-math as well in recip, check that\n+   this is not wrongly optimized.  */\n+/* { dg-final { scan-tree-dump-not \"reciptmp\" \"lim\" } } */\n+/* { dg-final { scan-tree-dump-not \"reciptmp\" \"recip\" } } */\n+/* { dg-final { cleanup-tree-dump \"recip\" } } */\n+"}, {"sha": "3a3869815c8b6236b5562b3c853232992bde9800", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr23234.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr23234.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr23234.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr23234.c?ref=bc23502b7f6590639be6473b4b8702187cac895d", "patch": "@@ -9,21 +9,24 @@ double\n f1 (double a, double b, double c)\n {\n   double y0;\n+  double y1;\n \n   if (a == 0.0)\n     {\n       y0 = -c / b;\n       return y0;\n     }\n   y0 = c / b;\n-  return y0;\n+  y1 = a / b;\n+  return y0 * y1;\n }\n \n /* Labels may end up in the middle of a block.  Also bad.  */\n double\n f2 (double a, double b, double c)\n {\n   double y0;\n+  double y1;\n \n a_label:\n another_label:\n@@ -33,20 +36,23 @@ f2 (double a, double b, double c)\n       return y0;\n     }\n   y0 = c / b;\n-  return y0;\n+  y1 = a / b;\n+  return y0 * y1;\n }\n \n /* Uses must still be dominated by their defs.  */\n double\n f3 (double a, double b, double c)\n {\n   double y0;\n+  double y1;\n \n   y0 = -c / b;\n   if (a == 0.0)\n     {\n       return y0;\n     }\n   y0 = c / b;\n-  return y0;\n+  y1 = a / b;\n+  return y0 * y1;\n }"}, {"sha": "af628053ad59c18edd0db5c43f38bbd63703a5de", "filename": "gcc/testsuite/gcc.dg/tree-ssa/recip-2.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-2.c?ref=bc23502b7f6590639be6473b4b8702187cac895d", "patch": "@@ -10,14 +10,19 @@ float e(float a, float b, float c, float d, float e, float f)\n     }\n \n   /* The PHI nodes for these divisions should be combined.  */\n+  d = d / a;\n   e = e / a;\n   f = f / a;\n   \n   a = a / c;\n   b = b / c;\n \n-  return a + b + e + f;\n+  /* This should not be left as a multiplication.  */\n+  c = 1 / c;\n+\n+  return a + b + c + d + e + f;\n }\n \n /* { dg-final { scan-tree-dump-times \" / \" 2 \"recip\" } } */\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 5 \"recip\" } } */\n /* { dg-final { cleanup-tree-dump \"recip\" } } */"}, {"sha": "45c8db148ac554736cd7344c829d23480e8a9564", "filename": "gcc/testsuite/gcc.dg/tree-ssa/recip-3.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-3.c?ref=bc23502b7f6590639be6473b4b8702187cac895d", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fno-trapping-math -funsafe-math-optimizations -fdump-tree-recip\" } */\n+\n+double F[2] = { 0.0, 0.0 }, e;\n+\n+/* In this case the optimization is interesting.  */\n+float h ()\n+{\n+\tint i;\n+\tdouble E, W, P, d;\n+\n+\tW = 1.;\n+\td = 2.*e;\n+\tE = 1. - d;\n+\n+\tfor( i=0; i < 2; i++ )\n+\t\tif( d > 0.01 )\n+\t\t{\n+\t\t\tP = ( W < E ) ? (W - E)/d : (E - W)/d;\n+\t\t\tF[i] += P;\n+\t\t}\n+\n+\tF[0] += E / d;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" / \" 1 \"recip\" } } */\n+/* { dg-final { cleanup-tree-dump \"recip\" } } */"}, {"sha": "20d7681d28d57f2a8b18ba5e432714f7467df336", "filename": "gcc/testsuite/gcc.dg/tree-ssa/recip-4.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-4.c?ref=bc23502b7f6590639be6473b4b8702187cac895d", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fno-trapping-math -funsafe-math-optimizations -fdump-tree-recip\" } */\n+\n+/* based on the test case in pr23109 */\n+\n+double F[2] = { 0., 0. }, e = 0.;\n+\n+/* Nope, we cannot prove the optimization is worthwhile in this case.  */\n+void f ()\n+{\n+\tint i;\n+\tdouble E, W, P, d;\n+\n+\tW = 1.;\n+\td = 2.*e;\n+\tE = 1. - d;\n+\n+\tif( d > 0.01 )\n+\t{\n+\t\tP = ( W < E ) ? (W - E)/d : (E - W)/d;\n+\t\tF[i] += P;\n+\t}\n+}\n+\n+/* We also cannot prove the optimization is worthwhile in this case.  */\n+float g ()\n+{\n+\tint i;\n+\tdouble E, W, P, d;\n+\n+\tW = 1.;\n+\td = 2.*e;\n+\tE = 1. - d;\n+\n+\tif( d > 0.01 )\n+\t{\n+\t\tP = ( W < E ) ? (W - E)/d : (E - W)/d;\n+\t\tF[i] += P;\n+\t}\n+\n+\treturn 1.0 / d;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"reciptmp\" \"recip\" } } */\n+/* { dg-final { cleanup-tree-dump \"recip\" } } */"}, {"sha": "bcbd1839cbcb02d973184a6eac7f9044d527cf38", "filename": "gcc/testsuite/gcc.dg/tree-ssa/recip-5.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-5.c?ref=bc23502b7f6590639be6473b4b8702187cac895d", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-options \"-O1 -funsafe-math-optimizations -ftrapping-math -fdump-tree-recip -fdump-tree-optimized\" } */\n+/* { dg-do compile } */\n+\n+/* Test the reciprocal optimizations together with trapping math.  */\n+\n+extern int f2();\n+\n+double f1(double y, double z, double w, double j, double k)\n+{\n+  double b, c, d, e, f, g;\n+\n+  if (f2 ())\n+    /* inserts one division here */\n+    b = 1 / y, c = z / y, d = j / y;\n+  else\n+    /* one division here */\n+    b = 3 / y, c = w / y, d = k / y;\n+\n+  /* and one here, that should be removed afterwards but is not right now */\n+  e = b / y;\n+  f = c / y;\n+  g = d / y;\n+\n+  return e + f + g;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" / \" 3 \"recip\" } } */\n+/* { dg-final { scan-tree-dump-times \" / \" 2 \"optimized\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"recip\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */\n+"}, {"sha": "60fefd01da5ebe25da3b5526754fc6a5ef497b11", "filename": "gcc/testsuite/gcc.dg/tree-ssa/recip-6.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-6.c?ref=bc23502b7f6590639be6473b4b8702187cac895d", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-options \"-O1 -funsafe-math-optimizations -fno-trapping-math -fdump-tree-recip\" } */\n+/* { dg-do compile } */\n+\n+/* Test inserting in a block that does not contain a division.  */\n+\n+extern int f2();\n+\n+double f1(double y, double z, double w)\n+{\n+  double b, c, d, e, f;\n+\n+  if (g ())\n+    b = 1 / y, c = z / y;\n+  else\n+    b = 3 / y, c = w / y;\n+\n+  d = b / y;\n+  e = c / y;\n+  f = 1 / y;\n+\n+  return d + e + f;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" / \" 1 \"recip\" } } */\n+/* { dg-final { cleanup-tree-dump \"recip\" } } */\n+"}, {"sha": "af1bf3c008bba26513f01e8469fba650c728f93f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/recip-7.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-7.c?ref=bc23502b7f6590639be6473b4b8702187cac895d", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-options \"-O1 -funsafe-math-optimizations -fno-trapping-math -fdump-tree-recip\" } */\n+/* { dg-do compile } */\n+\n+/* Test inserting in a block that does not contain a division.  */\n+\n+extern double h();\n+\n+double f(int x, double z, double w)\n+{\n+  double b, c, d, e, f;\n+  double y = h ();\n+\n+  if (x)\n+    b = 1 / y, c = z / y;\n+  else\n+    b = 3 / y, c = w / y;\n+\n+  d = b / y;\n+  e = c / y;\n+  f = 1 / y;\n+\n+  return d + e + f;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" / \" 1 \"recip\" } } */\n+/* { dg-final { cleanup-tree-dump \"recip\" } } */\n+"}, {"sha": "40a29bc7c2e3bf65b1994b8767e8467bb3280801", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=bc23502b7f6590639be6473b4b8702187cac895d", "patch": "@@ -1389,6 +1389,30 @@ tree_merge_blocks (basic_block a, basic_block b)\n }\n \n \n+/* Return the one of two successors of BB that is not reachable by a\n+   reached by a complex edge, if there is one.  Else, return BB.  We use\n+   this in optimizations that use post-dominators for their heuristics,\n+   to catch the cases in C++ where function calls are involved.  */\n+    \n+basic_block\n+single_noncomplex_succ (basic_block bb)  \n+{\n+  edge e0, e1;\n+  if (EDGE_COUNT (bb->succs) != 2)\n+    return bb;\n+   \n+  e0 = EDGE_SUCC (bb, 0);\n+  e1 = EDGE_SUCC (bb, 1);\n+  if (e0->flags & EDGE_COMPLEX)\n+    return e1->dest;\n+  if (e1->flags & EDGE_COMPLEX)\n+    return e0->dest;\n+   \n+  return bb;\n+}       \n+        \n+\n+\n /* Walk the function tree removing unnecessary statements.\n \n      * Empty statement nodes are removed"}, {"sha": "0c685522bd9c601a55e2f57879a5855aac0b510b", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=bc23502b7f6590639be6473b4b8702187cac895d", "patch": "@@ -487,6 +487,7 @@ extern bool is_ctrl_stmt (tree);\n extern bool is_ctrl_altering_stmt (tree);\n extern bool computed_goto_p (tree);\n extern bool simple_goto_p (tree);\n+extern basic_block single_noncomplex_succ (basic_block bb);\n extern void tree_dump_bb (basic_block, FILE *, int);\n extern void debug_tree_bb (basic_block);\n extern basic_block debug_tree_bb_n (int);"}, {"sha": "825c0bdec614fd56b42d2bb6855f71251d1ec4de", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 397, "deletions": 84, "changes": 481, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc23502b7f6590639be6473b4b8702187cac895d/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=bc23502b7f6590639be6473b4b8702187cac895d", "patch": "@@ -35,7 +35,55 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \tz = z * rmodulus;\n \n    We do this for loop invariant divisors, and with this pass whenever\n-   we notice that a division has the same divisor multiple times.  */\n+   we notice that a division has the same divisor multiple times.\n+\n+   Of course, like in PRE, we don't insert a division if a dominator\n+   already has one.  However, this cannot be done as an extension of\n+   PRE for several reasons.\n+\n+   First of all, with some experiments it was found out that the\n+   transformation is not always useful if there are only two divisions\n+   hy the same divisor.  This is probably because modern processors\n+   can pipeline the divisions; on older, in-order processors it should\n+   still be effective to optimize two divisions by the same number.\n+   We make this a param, and it shall be called N in the remainder of\n+   this comment.\n+\n+   Second, if trapping math is active, we have less freedom on where\n+   to insert divisions: we can only do so in basic blocks that already\n+   contain one.  (If divisions don't trap, instead, we can insert\n+   divisions elsewhere, which will be in blocks that are common dominators\n+   of those that have the division).\n+\n+   We really don't want to compute the reciprocal unless a division will\n+   be found.  To do this, we won't insert the division in a basic block\n+   that has less than N divisions *post-dominating* it.\n+\n+   The algorithm constructs a subset of the dominator tree, holding the\n+   blocks containing the divisions and the common dominators to them,\n+   and walk it twice.  The first walk is in post-order, and it annotates\n+   each block with the number of divisions that post-dominate it: this\n+   gives information on where divisions can be inserted profitably.\n+   The second walk is in pre-order, and it inserts divisions as explained\n+   above, and replaces divisions by multiplications.\n+\n+   In the best case, the cost of the pass is O(n_statements).  In the\n+   worst-case, the cost is due to creating the dominator tree subset,\n+   with a cost of O(n_basic_blocks ^ 2); however this can only happen\n+   for n_statements / n_basic_blocks statements.  So, the amortized cost\n+   of creating the dominator tree subset is O(n_basic_blocks) and the\n+   worst-case cost of the pass is O(n_statements * n_basic_blocks).\n+\n+   More practically, the cost will be small because there are few\n+   divisions, and they tend to be in the same basic block, so insert_bb\n+   is called very few times.\n+\n+   If we did this using domwalk.c, an efficient implementation would have\n+   to work on all the variables in a single pass, because we could not\n+   work on just a subset of the dominator tree, as we do now, and the\n+   cost would also be something like O(n_statements * n_basic_blocks).\n+   The data structures would be more complex in order to work on all the\n+   variables in a single pass.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -47,142 +95,407 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"real.h\"\n #include \"timevar.h\"\n #include \"tree-pass.h\"\n+#include \"alloc-pool.h\"\n+#include \"basic-block.h\"\n+#include \"target.h\"\n \n-static bool\n-gate_cse_reciprocals (void)\n+\n+/* This structure represents one basic block that either computes a\n+   division, or is a common dominator for basic block that compute a\n+   division.  */\n+struct occurrence {\n+  /* The basic block represented by this structure.  */\n+  basic_block bb;\n+\n+  /* If non-NULL, the SSA_NAME holding the definition for a reciprocal\n+     inserted in BB.  */\n+  tree recip_def;\n+\n+  /* If non-NULL, the MODIFY_EXPR for a reciprocal computation that\n+     was inserted in BB.  */\n+  tree recip_def_stmt;\n+\n+  /* Pointer to a list of \"struct occurrence\"s for blocks dominated\n+     by BB.  */\n+  struct occurrence *children;\n+\n+  /* Pointer to the next \"struct occurrence\"s in the list of blocks\n+     sharing a common dominator.  */\n+  struct occurrence *next;\n+\n+  /* The number of divisions that are in BB before compute_merit.  The\n+     number of divisions that are in BB or post-dominate it after\n+     compute_merit.  */\n+  int num_divisions;\n+\n+  /* True if the basic block has a division, false if it is a common\n+     dominator for basic blocks that do.  If it is false and trapping\n+     math is active, BB is not a candidate for inserting a reciprocal.  */\n+  bool bb_has_division;\n+};\n+\n+\n+/* The instance of \"struct occurrence\" representing the highest\n+   interesting block in the dominator tree.  */\n+static struct occurrence *occ_head;\n+\n+/* Allocation pool for getting instances of \"struct occurrence\".  */\n+static alloc_pool occ_pool;\n+\n+\n+\n+/* Allocate and return a new struct occurrence for basic block BB, and\n+   whose children list is headed by CHILDREN.  */\n+static struct occurrence *\n+occ_new (basic_block bb, struct occurrence *children)\n {\n-  return optimize && !optimize_size && flag_unsafe_math_optimizations;\n+  struct occurrence *occ;\n+\n+  occ = bb->aux = pool_alloc (occ_pool);\n+  memset (occ, 0, sizeof (struct occurrence));\n+\n+  occ->bb = bb;\n+  occ->children = children;\n+  return occ;\n }\n \n-/* Where to put the statement computing a reciprocal.  */\n-enum place_reciprocal\n+\n+/* Insert NEW_OCC into our subset of the dominator tree.  P_HEAD points to a\n+   list of \"struct occurrence\"s, one per basic block, having IDOM as\n+   their common dominator.\n+\n+   We try to insert NEW_OCC as deep as possible in the tree, and we also\n+   insert any other block that is a common dominator for BB and one\n+   block already in the tree.  */\n+\n+static void\n+insert_bb (struct occurrence *new_occ, basic_block idom,\n+\t   struct occurrence **p_head)\n {\n-  PR_BEFORE_BSI,\t/* Put it using bsi_insert_before.  */\n-  PR_AFTER_BSI,\t\t/* Put it using bsi_insert_after.  */\n-  PR_ON_ENTRY_EDGE\t/* Put it on the edge between the entry\n-\t\t\t   and the first basic block.  */\n-};\n+  struct occurrence *occ, **p_occ;\n \n-/* Check if DEF's uses include more than one floating-point division,\n-   and if so replace them by multiplications with the reciprocal.  Add\n-   the statement computing the reciprocal according to WHERE.\n+  for (p_occ = p_head; (occ = *p_occ) != NULL; )\n+    {\n+      basic_block bb = new_occ->bb, occ_bb = occ->bb;\n+      basic_block dom = nearest_common_dominator (CDI_DOMINATORS, occ_bb, bb);\n+      if (dom == bb)\n+\t{\n+\t  /* BB dominates OCC_BB.  OCC becomes NEW_OCC's child: remove OCC\n+\t     from its list.  */\n+\t  *p_occ = occ->next;\n+\t  occ->next = new_occ->children;\n+\t  new_occ->children = occ;\n+\n+\t  /* Try the next block (it may as well be dominated by BB).  */\n+\t}\n+\n+      else if (dom == occ_bb)\n+\t{\n+\t  /* OCC_BB dominates BB.  Tail recurse to look deeper.  */\n+\t  insert_bb (new_occ, dom, &occ->children);\n+\t  return;\n+\t}\n+\n+      else if (dom != idom)\n+\t{\n+\t  gcc_assert (!dom->aux);\n+\n+\t  /* There is a dominator between IDOM and BB, add it and make\n+\t     two children out of NEW_OCC and OCC.  First, remove OCC from\n+\t     its list.\t*/\n+\t  *p_occ = occ->next;\n+\t  new_occ->next = occ;\n+\t  occ->next = NULL;\n+\n+\t  /* None of the previous blocks has DOM as a dominator: if we tail\n+\t     recursed, we would reexamine them uselessly. Just switch BB with\n+\t     DOM, and go on looking for blocks dominated by DOM.  */\n+          new_occ = occ_new (dom, new_occ);\n+\t}\n+\n+      else\n+\t{\n+\t  /* Nothing special, go on with the next element.  */\n+\t  p_occ = &occ->next;\n+\t}\n+    }\n+\n+  /* No place was found as a child of IDOM.  Make BB a sibling of IDOM.  */\n+  new_occ->next = *p_head;\n+  *p_head = new_occ;\n+}\n+\n+/* Register that we found a division in BB.  */\n+\n+static inline void\n+register_division_in (basic_block bb)\n+{\n+  struct occurrence *occ;\n+\n+  occ = (struct occurrence *) bb->aux;\n+  if (!occ)\n+    {\n+      occ = occ_new (bb, NULL);\n+      insert_bb (occ, ENTRY_BLOCK_PTR, &occ_head);\n+    }\n+\n+  occ->bb_has_division = true;\n+  occ->num_divisions++;\n+}\n+\n+\n+/* Compute the number of divisions that postdominate each block in OCC and\n+   its children.  */\n \n-   Does not check the type of DEF, nor that DEF is a GIMPLE register.\n-   This is done in the caller for speed, because otherwise this routine\n-   would be called for every definition and phi node.  */\n static void\n-execute_cse_reciprocals_1 (block_stmt_iterator *bsi, tree def,\n-\t\t\t   enum place_reciprocal where)\n+compute_merit (struct occurrence *occ)\n {\n-  use_operand_p use_p;\n-  imm_use_iterator use_iter;\n-  tree t, new_stmt, type;\n-  int count = 0;\n-  bool ok = !flag_trapping_math;\n+  struct occurrence *occ_child;\n+  basic_block dom = occ->bb;\n \n-  /* Find uses.  */\n-  FOR_EACH_IMM_USE_FAST (use_p, use_iter, def)\n+  for (occ_child = occ->children; occ_child; occ_child = occ_child->next)\n     {\n-      tree use_stmt = USE_STMT (use_p);\n-      if (TREE_CODE (use_stmt) == MODIFY_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (use_stmt, 1)) == RDIV_EXPR\n-\t  && TREE_OPERAND (TREE_OPERAND (use_stmt, 1), 1) == def)\n+      basic_block bb;\n+      if (occ_child->children)\n+        compute_merit (occ_child);\n+\n+      if (flag_exceptions)\n+\tbb = single_noncomplex_succ (dom);\n+      else\n+\tbb = dom;\n+\n+      if (dominated_by_p (CDI_POST_DOMINATORS, bb, occ_child->bb))\n+        occ->num_divisions += occ_child->num_divisions;\n+    }\n+}\n+\n+\n+/* Return whether USE_STMT is a floating-point division by DEF.  */\n+static inline bool\n+is_division_by (tree use_stmt, tree def)\n+{\n+  return TREE_CODE (use_stmt) == MODIFY_EXPR\n+\t && TREE_CODE (TREE_OPERAND (use_stmt, 1)) == RDIV_EXPR\n+\t && TREE_OPERAND (TREE_OPERAND (use_stmt, 1), 1) == def;\n+}\n+\n+/* Walk the subset of the dominator tree rooted at OCC, setting the\n+   RECIP_DEF field to a definition of 1.0 / DEF that can be used in\n+   the given basic block.  The field may be left NULL, of course,\n+   if it is not possible or profitable to do the optimization.\n+\n+   DEF_BSI is an iterator pointing at the statement defining DEF.\n+   If RECIP_DEF is set, a dominator already has a computation that can\n+   be used.  */\n+\n+static void\n+insert_reciprocals (block_stmt_iterator *def_bsi, struct occurrence *occ,\n+\t\t    tree def, tree recip_def, int threshold)\n+{\n+  tree type, new_stmt;\n+  block_stmt_iterator bsi;\n+  struct occurrence *occ_child;\n+\n+  if (!recip_def\n+      && (occ->bb_has_division || !flag_trapping_math)\n+      && occ->num_divisions >= threshold)\n+    {\n+      /* Make a variable with the replacement and substitute it.  */\n+      type = TREE_TYPE (def);\n+      recip_def = make_rename_temp (type, \"reciptmp\");\n+      new_stmt = build2 (MODIFY_EXPR, void_type_node, recip_def,\n+\t\t         fold_build2 (RDIV_EXPR, type,\n+\t\t\t\t      build_real (type, dconst1), def));\n+  \n+  \n+      if (occ->bb_has_division)\n+        {\n+          /* Case 1: insert before an existing division.  */\n+          bsi = bsi_after_labels (occ->bb);\n+          while (!bsi_end_p (bsi) && !is_division_by (bsi_stmt (bsi), def))\n+\t    bsi_next (&bsi);\n+\n+          bsi_insert_before (&bsi, new_stmt, BSI_SAME_STMT);\n+        }\n+      else if (def_bsi && occ->bb == def_bsi->bb)\n         {\n-          ++count;\n-          /* Check if this use post-dominates the insertion point.  */\n-          if (ok || dominated_by_p (CDI_POST_DOMINATORS, bsi->bb,\n-\t\t\t\t    bb_for_stmt (use_stmt)))\n-\t    ok = true;\n+          /* Case 2: insert right after the definition.  Note that this will\n+\t     never happen if the definition statement can throw, because in\n+\t     that case the sole successor of the statement's basic block will\n+\t     dominate all the uses as well.  */\n+          bsi_insert_after (def_bsi, new_stmt, BSI_NEW_STMT);\n         }\n-      if (count >= 2 && ok)\n-        break;\n+      else\n+        {\n+          /* Case 3: insert in a basic block not containing defs/uses.  */\n+          bsi = bsi_after_labels (occ->bb);\n+          bsi_insert_before (&bsi, new_stmt, BSI_SAME_STMT);\n+        }\n+\n+      occ->recip_def_stmt = new_stmt;\n     }\n \n-  if (count < 2 || !ok)\n-    return;\n-\n-  /* Make a variable with the replacement and substitute it.  */\n-  type = TREE_TYPE (def);\n-  t = make_rename_temp (type, \"reciptmp\");\n-  new_stmt = build2 (MODIFY_EXPR, void_type_node, t,\n-\t\t     fold_build2 (RDIV_EXPR, type, build_real (type, dconst1),\n-\t\t\t\t  def));\n-\n-  if (where == PR_BEFORE_BSI)\n-    bsi_insert_before (bsi, new_stmt, BSI_SAME_STMT);\n-  else if (where == PR_AFTER_BSI)\n-    bsi_insert_after (bsi, new_stmt, BSI_NEW_STMT);\n-  else if (where == PR_ON_ENTRY_EDGE)\n-    bsi_insert_on_edge (single_succ_edge (ENTRY_BLOCK_PTR), new_stmt);\n+  occ->recip_def = recip_def;\n+  for (occ_child = occ->children; occ_child; occ_child = occ_child->next)\n+    insert_reciprocals (def_bsi, occ_child, def, recip_def, threshold);\n+}\n+\n+\n+/* Replace the division at USE_P with a multiplication by the reciprocal, if\n+   possible.  */\n+\n+static inline void\n+replace_reciprocal (use_operand_p use_p)\n+{\n+  tree use_stmt = USE_STMT (use_p);\n+  basic_block bb = bb_for_stmt (use_stmt);\n+  struct occurrence *occ = (struct occurrence *) bb->aux;\n+\n+  if (occ->recip_def && use_stmt != occ->recip_def_stmt)\n+    {\n+      TREE_SET_CODE (TREE_OPERAND (use_stmt, 1), MULT_EXPR);\n+      SET_USE (use_p, occ->recip_def);\n+      fold_stmt_inplace (use_stmt);\n+      update_stmt (use_stmt);\n+    }\n+}\n+\n+\n+/* Free OCC and return one more \"struct occurrence\" to be freed.  */\n+\n+static struct occurrence *\n+free_bb (struct occurrence *occ)\n+{\n+  struct occurrence *child, *next;\n+\n+  /* First get the two pointers hanging off OCC.  */\n+  next = occ->next;\n+  child = occ->children;\n+  occ->bb->aux = NULL;\n+  pool_free (occ_pool, occ);\n+\n+  /* Now ensure that we don't recurse unless it is necessary.  */\n+  if (!child)\n+    return next;\n   else\n-    gcc_unreachable ();\n+    {\n+      while (next)\n+\tnext = free_bb (next);\n+\n+      return child;\n+    }\n+}\n+\n+\n+/* Look for floating-point divisions among DEF's uses, and try to\n+   replace them by multiplications with the reciprocal.  Add\n+   as many statements computing the reciprocal as needed.\n+\n+   DEF must be a GIMPLE register of a floating-point type.  */\n+\n+static void\n+execute_cse_reciprocals_1 (block_stmt_iterator *def_bsi, tree def)\n+{\n+  use_operand_p use_p;\n+  imm_use_iterator use_iter;\n+  struct occurrence *occ;\n+  int count = 0, threshold;\n \n-  FOR_EACH_IMM_USE_SAFE (use_p, use_iter, def)\n+  gcc_assert (FLOAT_TYPE_P (TREE_TYPE (def)) && is_gimple_reg (def));\n+\n+  FOR_EACH_IMM_USE_FAST (use_p, use_iter, def)\n     {\n       tree use_stmt = USE_STMT (use_p);\n-      if (use_stmt != new_stmt\n-\t  && TREE_CODE (use_stmt) == MODIFY_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (use_stmt, 1)) == RDIV_EXPR\n-\t  && TREE_OPERAND (TREE_OPERAND (use_stmt, 1), 1) == def)\n+      if (is_division_by (use_stmt, def))\n \t{\n-\t  TREE_SET_CODE (TREE_OPERAND (use_stmt, 1), MULT_EXPR);\n-\t  SET_USE (use_p, t);\n+\t  register_division_in (bb_for_stmt (use_stmt));\n+\t  count++;\n \t}\n     }\n+  \n+  /* Do the expensive part only if we can hope to optimize something.  */\n+  threshold = targetm.min_divisions_for_recip_mul (TYPE_MODE (TREE_TYPE (def)));\n+  if (count >= threshold)\n+    {\n+      for (occ = occ_head; occ; occ = occ->next)\n+\t{\n+\t  compute_merit (occ);\n+\t  insert_reciprocals (def_bsi, occ, def, NULL, threshold);\n+\t}\n+\n+      FOR_EACH_IMM_USE_SAFE (use_p, use_iter, def)\n+\t{\n+\t  tree use_stmt = USE_STMT (use_p);\n+\t  if (is_division_by (use_stmt, def))\n+\t    replace_reciprocal (use_p);\n+\t}\n+    }\n+\n+  for (occ = occ_head; occ; )\n+    occ = free_bb (occ);\n+\n+  occ_head = NULL;\n }\n \n+\n+static bool\n+gate_cse_reciprocals (void)\n+{\n+  return optimize && !optimize_size && flag_unsafe_math_optimizations;\n+}\n+\n+\n+/* Go through all the floating-point SSA_NAMEs, and call\n+   execute_cse_reciprocals_1 on each of them.  */\n static void\n execute_cse_reciprocals (void)\n {\n   basic_block bb;\n   tree arg;\n \n-  if (flag_trapping_math)\n-    calculate_dominance_info (CDI_POST_DOMINATORS);\n+  occ_pool = create_alloc_pool (\"dominators for recip\",\n+\t\t\t\tsizeof (struct occurrence),\n+\t\t\t\tn_basic_blocks / 3 + 1);\n \n-  if (single_succ_p (ENTRY_BLOCK_PTR))\n-    for (arg = DECL_ARGUMENTS (cfun->decl); arg; arg = TREE_CHAIN (arg))\n-      if (default_def (arg))\n-\t{\n-\t  block_stmt_iterator bsi;\n-\t  bsi = bsi_start (single_succ (ENTRY_BLOCK_PTR));\n-\t  execute_cse_reciprocals_1 (&bsi, default_def (arg),\n-\t\t\t\t     PR_ON_ENTRY_EDGE);\n-\t}\n+  calculate_dominance_info (CDI_DOMINATORS | CDI_POST_DOMINATORS);\n+\n+#ifdef ENABLE_CHECKING\n+  FOR_EACH_BB (bb)\n+    gcc_assert (!bb->aux);\n+#endif\n+\n+  for (arg = DECL_ARGUMENTS (cfun->decl); arg; arg = TREE_CHAIN (arg))\n+    if (default_def (arg)\n+\t&& FLOAT_TYPE_P (TREE_TYPE (arg))\n+\t&& is_gimple_reg (arg))\n+      execute_cse_reciprocals_1 (NULL, default_def (arg));\n \n   FOR_EACH_BB (bb)\n     {\n       block_stmt_iterator bsi;\n       tree phi, def;\n-      for (bsi = bsi_start (bb);\n-\t   !bsi_end_p (bsi) && TREE_CODE (bsi_stmt (bsi)) == LABEL_EXPR;\n-\t   bsi_next (&bsi))\n-        ;\n \n       for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n \t{\n \t  def = PHI_RESULT (phi);\n \t  if (FLOAT_TYPE_P (TREE_TYPE (def))\n \t      && is_gimple_reg (def))\n-\t    execute_cse_reciprocals_1 (&bsi, def, PR_BEFORE_BSI);\n+\t    execute_cse_reciprocals_1 (NULL, def);\n \t}\n \n-      for (; !bsi_end_p (bsi); bsi_next (&bsi))\n+      for (bsi = bsi_after_labels (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n         {\n \t  tree stmt = bsi_stmt (bsi);\n \t  if (TREE_CODE (stmt) == MODIFY_EXPR\n \t      && (def = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_DEF)) != NULL\n \t      && FLOAT_TYPE_P (TREE_TYPE (def))\n \t      && TREE_CODE (def) == SSA_NAME)\n-\t    execute_cse_reciprocals_1 (&bsi, def, PR_AFTER_BSI);\n+\t    execute_cse_reciprocals_1 (&bsi, def);\n \t}\n     }\n \n-  if (flag_trapping_math)\n-    free_dominance_info (CDI_POST_DOMINATORS);\n-  \n-  if (single_succ_p (ENTRY_BLOCK_PTR))\n-    bsi_commit_one_edge_insert (single_succ_edge (ENTRY_BLOCK_PTR), NULL);\n+  free_dominance_info (CDI_DOMINATORS | CDI_POST_DOMINATORS);\n+  free_alloc_pool (occ_pool);\n }\n \n struct tree_opt_pass pass_cse_reciprocals ="}]}