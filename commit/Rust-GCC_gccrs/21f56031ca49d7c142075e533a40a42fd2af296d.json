{"sha": "21f56031ca49d7c142075e533a40a42fd2af296d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjFmNTYwMzFjYTQ5ZDdjMTQyMDc1ZTUzM2E0MGE0MmZkMmFmMjk2ZA==", "commit": {"author": {"name": "Bryce McKinlay", "email": "mckinlay@redhat.com", "date": "2004-07-10T02:14:30Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2004-07-10T02:14:30Z"}, "message": "ResourceBundle.java (bundleCache): Renamed from resourceBundleCache.\n\n2004-07-09  Bryce McKinlay  <mckinlay@redhat.com>\n\n\t* java/util/ResourceBundle.java (bundleCache): Renamed from\n\tresourceBundleCache. Update comments.\n\t(getObject): Don't catch MissingResourceException.\n\t(getBundle(String)): Remove 'final'. Use system classloader if\n\tgetCallingClassLoader returned null.\n\t(getBundle(String, Locale)): Likewise.\n\t(BundleKey): New private class. HashMap key for bundle cache lookup.\n\t(lookupKey): New. Singleton instance of BundleKey.\n\t(nullEntry): New. Cache entry to represent failed lookups.\n\t(getBundle(String, Locale, ClassLoader)): Re-written to use new\n\tcaching strategy, no-allocation lookup, and new tryBundle methods.\n\t(tryBundle(String, ClassLoader)): New. Load a locale-qualified\n\tbundle name using given classloader.\n\t(tryBundle(String, Locale, ClassLoader, boolean): New. Qualify\n\tbaseName for given Locale and attempt to load bundle.\n\nFrom-SVN: r84434", "tree": {"sha": "5bb4aa17ab79240e1aba3df19980bdf9dddc9b78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bb4aa17ab79240e1aba3df19980bdf9dddc9b78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21f56031ca49d7c142075e533a40a42fd2af296d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21f56031ca49d7c142075e533a40a42fd2af296d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21f56031ca49d7c142075e533a40a42fd2af296d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21f56031ca49d7c142075e533a40a42fd2af296d/comments", "author": null, "committer": null, "parents": [{"sha": "17a916d4e61d8a6dac83eddec10b10428ca7b0c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17a916d4e61d8a6dac83eddec10b10428ca7b0c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17a916d4e61d8a6dac83eddec10b10428ca7b0c5"}], "stats": {"total": 371, "additions": 203, "deletions": 168}, "files": [{"sha": "088ef4b2169e198dc2836e057c3f99fcae5a82e8", "filename": "libjava/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21f56031ca49d7c142075e533a40a42fd2af296d/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21f56031ca49d7c142075e533a40a42fd2af296d/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=21f56031ca49d7c142075e533a40a42fd2af296d", "patch": "@@ -1,3 +1,21 @@\n+2004-07-09  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\t* java/util/ResourceBundle.java (bundleCache): Renamed from\n+\tresourceBundleCache. Update comments.\n+\t(getObject): Don't catch MissingResourceException.\n+\t(getBundle(String)): Remove 'final'. Use system classloader if\n+\tgetCallingClassLoader returned null.\n+\t(getBundle(String, Locale)): Likewise.\n+\t(BundleKey): New private class. HashMap key for bundle cache lookup.\n+\t(lookupKey): New. Singleton instance of BundleKey.\n+\t(nullEntry): New. Cache entry to represent failed lookups.\n+\t(getBundle(String, Locale, ClassLoader)): Re-written to use new \n+\tcaching strategy, no-allocation lookup, and new tryBundle methods.\n+\t(tryBundle(String, ClassLoader)): New. Load a locale-qualified bundle \n+\tname using given classloader.\n+\t(tryBundle(String, Locale, ClassLoader, boolean): New. Qualify \n+\tbaseName for given Locale and attempt to load bundle.\n+\n 2004-07-09  Bryce McKinlay  <mckinlay@redhat.com>\n \n \t* javax/swing/plaf/basic/BasicMenuUI.java (mousePressed): Remove "}, {"sha": "12aaa6de310193b95fda0ee220053ae7273b446f", "filename": "libjava/java/util/ResourceBundle.java", "status": "modified", "additions": 185, "deletions": 168, "changes": 353, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21f56031ca49d7c142075e533a40a42fd2af296d/libjava%2Fjava%2Futil%2FResourceBundle.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21f56031ca49d7c142075e533a40a42fd2af296d/libjava%2Fjava%2Futil%2FResourceBundle.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FResourceBundle.java?ref=21f56031ca49d7c142075e533a40a42fd2af296d", "patch": "@@ -105,12 +105,9 @@\n   private static native ClassLoader getCallingClassLoader();\n \n   /**\n-   * The resource bundle cache. This is a two-level hash map: The key\n-   * is the class loader, the value is a new HashMap. The key of this\n-   * second hash map is the localized name, the value is a soft\n-   * references to the resource bundle.\n+   * The resource bundle cache.\n    */\n-  private static Map resourceBundleCache;\n+  private static Map bundleCache;\n \n   /**\n    * The last default Locale we saw. If this ever changes then we have to\n@@ -172,15 +169,11 @@ public final String[] getStringArray(String key)\n   public final Object getObject(String key)\n   {\n     for (ResourceBundle bundle = this; bundle != null; bundle = bundle.parent)\n-      try\n-        {\n-          Object o = bundle.handleGetObject(key);\n-          if (o != null)\n-            return o;\n-        }\n-      catch (MissingResourceException ex)\n-        {\n-        }\n+      {\n+        Object o = bundle.handleGetObject(key);\n+        if (o != null)\n+          return o;\n+      }\n  \n     throw new MissingResourceException(\"Key not found\", getClass().getName(),\n \t\t\t\t       key);\n@@ -220,10 +213,12 @@ protected void setParent(ResourceBundle parent)\n    * @throws MissingResourceException if the resource bundle can't be found\n    * @throws NullPointerException if baseName is null\n    */\n-  public static final ResourceBundle getBundle(String baseName)\n+  public static ResourceBundle getBundle(String baseName)\n   {\n-    return getBundle(baseName, Locale.getDefault(),\n-                     getCallingClassLoader());\n+    ClassLoader cl = getCallingClassLoader();\n+    if (cl == null)\n+      cl = ClassLoader.getSystemClassLoader();\n+    return getBundle(baseName, Locale.getDefault(), cl);\n   }\n \n   /**\n@@ -238,11 +233,74 @@ public static final ResourceBundle getBundle(String baseName)\n    * @throws MissingResourceException if the resource bundle can't be found\n    * @throws NullPointerException if baseName or locale is null\n    */\n-  public static final ResourceBundle getBundle(String baseName,\n-                                               Locale locale)\n+  public static ResourceBundle getBundle(String baseName, Locale locale)\n   {\n-    return getBundle(baseName, locale, getCallingClassLoader());\n+    ClassLoader cl = getCallingClassLoader();\n+    if (cl == null)\n+      cl = ClassLoader.getSystemClassLoader();\n+    return getBundle(baseName, locale, cl);\n+  }\n+\n+  /** Cache key for the ResourceBundle cache.  Resource bundles are keyed\n+      by the combination of bundle name, locale, and class loader. */\n+  private static class BundleKey implements Cloneable\n+  {\n+    String baseName;\n+    Locale locale;\n+    ClassLoader classLoader;\n+    int hashcode;\n+\n+    BundleKey() {}\n+\n+    BundleKey(String s, Locale l, ClassLoader cl)\n+    {\n+      set(s, l, cl);\n+    }\n+    \n+    void set(String s, Locale l, ClassLoader cl)\n+    {\n+      baseName = s;\n+      locale = l;\n+      classLoader = cl;\n+      hashcode = baseName.hashCode() ^ locale.hashCode() ^\n+        classLoader.hashCode();\n+    }\n+    \n+    public int hashCode()\n+    {\n+      return hashcode;\n+    }\n+    \n+    public boolean equals(Object o)\n+    {\n+      if (! (o instanceof BundleKey))\n+        return false;\n+      BundleKey key = (BundleKey) o;\n+      return hashcode == key.hashcode &&\n+\tbaseName.equals(key.baseName) &&\n+        locale.equals(key.locale) &&\n+\tclassLoader.equals(key.classLoader);\n+    }\n+    \n+    public Object clone()\n+    {\n+      Object clone = null;\n+      try\n+      {\n+\tclone = super.clone();\n+      }\n+      catch (CloneNotSupportedException x) {}\n+      \n+      return clone;\n+    }\n   }\n+  \n+  /** A cache lookup key. This avoids having to a new one for every\n+   *  getBundle() call. */\n+  private static BundleKey lookupKey = new BundleKey();\n+  \n+  /** Singleton cache entry to represent previous failed lookups. */\n+  private static Object nullEntry = new Object();\n \n   /**\n    * Get the appropriate ResourceBundle for the given locale. The following\n@@ -320,81 +378,59 @@ public static final ResourceBundle getBundle(String baseName,\n    */\n   // This method is synchronized so that the cache is properly\n   // handled.\n-  public static final synchronized ResourceBundle getBundle\n+  public static synchronized ResourceBundle getBundle\n     (String baseName, Locale locale, ClassLoader classLoader)\n   {\n-    // This implementation searches the bundle in the reverse direction\n-    // and builds the parent chain on the fly.\n+    // If the default locale changed since the last time we were called,\n+    // all cache entries are invalidated.\n     Locale defaultLocale = Locale.getDefault();\n     if (defaultLocale != lastDefaultLocale)\n       {\n-\tresourceBundleCache = new HashMap();\n+\tbundleCache = new HashMap();\n \tlastDefaultLocale = defaultLocale;\n       }\n-    HashMap cache = (HashMap) resourceBundleCache.get(classLoader);\n-    StringBuffer sb = new StringBuffer(60);\n-    sb.append(baseName).append('_').append(locale);\n-    String name = sb.toString();\n \n-    if (cache == null)\n+    // This will throw NullPointerException if any arguments are null.\n+    lookupKey.set(baseName, locale, classLoader);\n+    \n+    Object obj = bundleCache.get(lookupKey);\n+    ResourceBundle rb = null;\n+    if (obj instanceof ResourceBundle)\n       {\n-        cache = new HashMap();\n-        resourceBundleCache.put(classLoader, cache);\n+        return (ResourceBundle) obj;\n       }\n-    else if (cache.containsKey(name))\n+    else if (obj == nullEntry)\n       {\n-\tReference ref = (Reference) cache.get(name);\n-\t// If REF is null, that means that we added a `null' value to\n-\t// the hash map.  That means we failed to find the bundle\n-\t// previously, and we cached that fact.  The JDK does this, so\n-\t// it must be ok.\n-\tif (ref == null)\n-\t  throw new MissingResourceException(\"Bundle \" + baseName\n-\t\t\t\t\t     + \" not found\",\n-\t\t\t\t\t     baseName, \"\");\n-\telse\n-\t  {\n-\t    ResourceBundle rb = (ResourceBundle) ref.get();\n-\t    if (rb != null)\n-\t      {\n-\t\t// RB should already have the right parent, except if\n-\t\t// something very strange happened.\n-\t\treturn rb;\n-\t      }\n-\t    // If RB is null, then we previously found it but it was\n-\t    // collected.  So we try again.\n-\t  }\n+        // Lookup has failed previously. Fall through.\n       }\n-\n-    // It is ok if this returns null.  We aren't required to have the\n-    // base bundle.\n-    ResourceBundle baseBundle = tryBundle(baseName, emptyLocale,\n-                                          classLoader, null, cache);\n-\n-    // Now use our locale, followed by the default locale.  We only\n-    // need to try the default locale if our locale is different, and\n-    // if our locale failed to yield a result other than the base\n-    // bundle.\n-    ResourceBundle bundle = tryLocalBundle(baseName, locale,\n-                                           classLoader, baseBundle, cache);\n-    if (bundle == baseBundle && !locale.equals(defaultLocale))\n+    else\n       {\n-\tbundle = tryLocalBundle(baseName, defaultLocale,\n-\t\t\t\tclassLoader, baseBundle, cache);\n-\t// We need to record that the argument locale maps to the\n-\t// bundle we just found.  If we didn't find a bundle, record\n-\t// that instead.\n-\tif (bundle == null)\n-\t  cache.put(name, null);\n+\t// First, look for a bundle for the specified locale. We don't want\n+\t// the base bundle this time.\n+\tboolean wantBase = locale.equals(defaultLocale);\n+\tResourceBundle bundle = tryBundle(baseName, locale, classLoader, \n+\t\t\t\t\t  wantBase);\n+\n+        // Try the default locale if neccessary.\n+\tif (bundle == null && !locale.equals(defaultLocale))\n+\t  bundle = tryBundle(baseName, defaultLocale, classLoader, true);\n+\n+\tBundleKey key = (BundleKey) lookupKey.clone();\n+        if (bundle == null)\n+\t  {\n+\t    // Cache the fact that this lookup has previously failed.\n+\t    bundleCache.put(key, nullEntry);\n+\t  }\n \telse\n-\t  cache.put(name, new SoftReference(bundle));\n+\t  {\n+            // Cache the result and return it.\n+\t    bundleCache.put(key, bundle);\n+\t    return bundle;\n+\t  }\n       }\n \n-    if (bundle == null)\n-      throw new MissingResourceException(\"Bundle \" + baseName + \" not found\",\n-\t\t\t\t\t baseName, \"\");\n-\n-    return bundle;\n+    throw new MissingResourceException(\"Bundle \" + baseName + \" not found\",\n+\t\t\t\t       baseName, \"\");\n   }\n \n   /**\n@@ -423,93 +459,50 @@ else if (cache.containsKey(name))\n    * Tries to load a class or a property file with the specified name.\n    *\n    * @param localizedName the name\n-   * @param locale the locale, that must be used exactly\n    * @param classloader the classloader\n-   * @param bundle the backup (parent) bundle\n    * @return the resource bundle if it was loaded, otherwise the backup\n    */\n-  private static final ResourceBundle tryBundle(String localizedName,\n-                                                Locale locale,\n-                                                ClassLoader classloader,\n-                                                ResourceBundle bundle,\n-                                                HashMap cache)\n+  private static ResourceBundle tryBundle(String localizedName,\n+                                          ClassLoader classloader)\n   {\n-    // First look into the cache.\n-    if (cache.containsKey(localizedName))\n-      {\n-\tReference ref = (Reference) cache.get(localizedName);\n-\t// If REF is null, that means that we added a `null' value to\n-\t// the hash map.  That means we failed to find the bundle\n-\t// previously, and we cached that fact.  The JDK does this, so\n-\t// it must be ok.\n-\tif (ref == null)\n-\t  return null;\n-\telse\n-\t  {\n-\t    ResourceBundle rb = (ResourceBundle) ref.get();\n-\t    if (rb != null)\n-\t      {\n-\t\t// RB should already have the right parent, except if\n-\t\t// something very strange happened.\n-\t\treturn rb;\n-\t      }\n-\t    // If RB is null, then we previously found it but it was\n-\t    // collected.  So we try again.\n-\t  }\n-      }\n-\n-    // foundBundle holds exact matches for the localizedName resource\n-    // bundle, which may later be cached.\n-    ResourceBundle foundBundle = null;\n+    ResourceBundle bundle = null;\n     try\n       {\n         Class rbClass;\n         if (classloader == null)\n           rbClass = Class.forName(localizedName);\n         else\n           rbClass = classloader.loadClass(localizedName);\n-        foundBundle = (ResourceBundle) rbClass.newInstance();\n-        foundBundle.parent = bundle;\n-        foundBundle.locale = locale;\n-      }\n-    catch (Exception ex)\n-      {\n-        // ignore them all\n-\tfoundBundle = null;\n+        bundle = (ResourceBundle) rbClass.newInstance();\n       }\n-    if (foundBundle == null)\n+    catch (IllegalAccessException ex) {}\n+    catch (InstantiationException ex) {}\n+    catch (ClassNotFoundException ex) {}\n+\n+    if (bundle == null)\n       {\n \ttry\n \t  {\n \t    InputStream is;\n-\t    final String resourceName\n+\t    String resourceName\n \t      = localizedName.replace('.', '/') + \".properties\";\n \t    if (classloader == null)\n \t      is = ClassLoader.getSystemResourceAsStream(resourceName);\n \t    else\n \t      is = classloader.getResourceAsStream(resourceName);\n \t    if (is != null)\n-\t      {\n-\t\tfoundBundle = new PropertyResourceBundle(is);\n-\t\tfoundBundle.parent = bundle;\n-\t\tfoundBundle.locale = locale;\n-\t      }\n+\t      bundle = new PropertyResourceBundle(is);\n \t  }\n \tcatch (IOException ex)\n \t  {\n+\t    MissingResourceException mre = new MissingResourceException\n+\t      (\"Failed to load bundle\", localizedName, \"\");\n+\t    mre.initCause(ex);\n+\t    throw mre;\n \t  }\n       }\n \n-    // Put the result into the hash table.  If we didn't find anything\n-    // here, we record our parent bundle.  If we record `null' that means\n-    // nothing, not even the base, was found.\n-    if (foundBundle == null)\n-      foundBundle = bundle;\n-    if (foundBundle == null)\n-      cache.put(localizedName, null);\n-    else\n-      cache.put(localizedName, new SoftReference(foundBundle));\n-    return foundBundle;\n+    return bundle;\n   }\n \n   /**\n@@ -520,47 +513,71 @@ private static final ResourceBundle tryBundle(String localizedName,\n    * @param locale the locale\n    * @param classloader the classloader\n    * @param bundle the backup (parent) bundle\n+   * @param wantBase whether a resource bundle made only from the base name\n+   *        (with no locale information attached) should be returned.\n    * @return the resource bundle if it was loaded, otherwise the backup\n    */\n-  private static final ResourceBundle tryLocalBundle(String baseName,\n-\t\t\t\t\t\t     Locale locale,\n-                                                     ClassLoader classloader,\n-                                                     ResourceBundle bundle,\n-                                                     HashMap cache)\n+  private static ResourceBundle tryBundle(String baseName, Locale locale,\n+                                          ClassLoader classLoader, \n+\t\t\t\t\t  boolean wantBase)\n   {\n-    final String language = locale.getLanguage();\n-    final String country = locale.getCountry();\n-    final String variant = locale.getVariant();\n+    String language = locale.getLanguage();\n+    String country = locale.getCountry();\n+    String variant = locale.getVariant();\n+    \n+    int baseLen = baseName.length();\n \n-    StringBuffer sb = new StringBuffer(60);\n-    sb.append(baseName);\n-    sb.append('_');\n+    // Build up a StringBuffer containing the complete bundle name, fully\n+    // qualified by locale.\n+    StringBuffer sb = new StringBuffer(baseLen + variant.length() + 7);\n \n+    sb.append(baseName);\n+    \n     if (language.length() > 0)\n       {\n+\tsb.append('_');\n \tsb.append(language);\n-\tbundle = tryBundle(sb.toString(), new Locale(language),\n-\t\t\t   classloader, bundle, cache);\n-      }\n-    // If LANGUAGE was empty, we still need to try the other\n-    // components, and the `_' is required.\n-    sb.append('_');\n-\n-    if (country.length() > 0)\n-      {\n-\tsb.append(country);\n-\tbundle = tryBundle(sb.toString(), new Locale(language, country),\n-\t\t\t   classloader, bundle, cache);\n+\t\n+\tif (country.length() > 0)\n+\t  {\n+\t    sb.append('_');\n+\t    sb.append(country);\n+\t    \n+\t    if (variant.length() > 0)\n+\t      {\n+\t        sb.append('_');\n+\t\tsb.append(variant);\n+\t      }\n+\t  }\n       }\n-    sb.append('_');\n \n-    if (variant.length() > 0)\n+    // Now try to load bundles, starting with the most specialized name.\n+    // Build up the parent chain as we go.\n+    String bundleName = sb.toString();\n+    ResourceBundle first = null; // The most specialized bundle.\n+    ResourceBundle last = null; // The least specialized bundle.\n+    \n+    while (true)\n       {\n-\tsb.append(variant);\n-\tbundle = tryBundle(sb.toString(), locale,\n-\t\t\t   classloader, bundle, cache);\n+        ResourceBundle foundBundle = tryBundle(bundleName, classLoader);\n+\tif (foundBundle != null)\n+\t  {\n+\t    if (first == null)\n+\t      first = foundBundle;\n+\t    if (last != null)\n+\t      last.parent = foundBundle;\n+\t    foundBundle.locale = locale;\n+\t    last = foundBundle;\n+\t  }\n+\tint idx = bundleName.lastIndexOf('_');\n+\t// Try the non-localized base name only if we already have a\n+\t// localized child bundle, or wantBase is true.\n+\tif (idx > baseLen || (idx == baseLen && (first != null || wantBase)))\n+\t  bundleName = bundleName.substring(0, idx);\n+\telse\n+\t  break;\n       }\n-\n-    return bundle;\n+    \n+    return first;\n   }\n }"}]}