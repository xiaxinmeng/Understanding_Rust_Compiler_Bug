{"sha": "d469eabed98420f0bdd2895d47e11829e3bb76d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQ2OWVhYmVkOTg0MjBmMGJkZDI4OTVkNDdlMTE4MjllM2JiNzZkOQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2007-12-13T10:30:41Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-12-13T10:30:41Z"}, "message": "sem_ch4.adb (Analyze_Selected_Component): Include the requeue statement to the list of contexts where a selected...\n\n2007-12-06  Hristian Kirtchev  <kirtchev@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb (Analyze_Selected_Component): Include the requeue\n\tstatement to the list of contexts where a selected component with a\n\tconcurrent tagged type prefix should yield a primitive operation.\n\t(Find_Primitive_Operation): Handle case of class-wide types.\n\t(Analyze_Overloaded_Selected_Component): If type of prefix is\n\tclass-wide, use visible components of base type.\n\t(Resolve_Selected_Component): Ditto.\n\t(Try_Primitive_Operation, Collect_Generic_Type_Ops): If the type is a\n\tformal of a generic subprogram. find candidate interpretations by\n\tscanning the list of generic formal declarations.:\n\t(Process_Implicit_Dereference_Prefix): If the prefix has an incomplete\n\ttype from a limited_with_clause, and the full view is available, use it\n\tfor subsequent semantic checks.\n\t(Check_Misspelled_Selector): Use Namet.Sp.Is_Bad_Spelling_Of function\n\t(Find_Primitive_Operation): New function.\n\t(Analyze_Overloaded_Selected_Component): insert explicit dereference\n\tonly once if several interpretations of the prefix yield an access type.\n\t(Try_Object_Operation): Code and comment cleanup.\n\t(Analyze_Selected_Component): Reorder local variables. Minot comment and\n\tcode reformatting. When the type of the prefix is tagged concurrent, a\n\tcorrect interpretation might be available in the primitive and\n\tclass-wide operations of the type.\n\nFrom-SVN: r130853", "tree": {"sha": "56de5248419355494b4be55b05ae58560c9ac855", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56de5248419355494b4be55b05ae58560c9ac855"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d469eabed98420f0bdd2895d47e11829e3bb76d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d469eabed98420f0bdd2895d47e11829e3bb76d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d469eabed98420f0bdd2895d47e11829e3bb76d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d469eabed98420f0bdd2895d47e11829e3bb76d9/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "01b18343996b7145c23191fb574b3fae3e845d8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01b18343996b7145c23191fb574b3fae3e845d8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01b18343996b7145c23191fb574b3fae3e845d8d"}], "stats": {"total": 588, "additions": 397, "deletions": 191}, "files": [{"sha": "1627072fb028e8938e7129a6e5d70911c595ea69", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 397, "deletions": 191, "changes": 588, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d469eabed98420f0bdd2895d47e11829e3bb76d9/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d469eabed98420f0bdd2895d47e11829e3bb76d9/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=d469eabed98420f0bdd2895d47e11829e3bb76d9", "patch": "@@ -34,6 +34,7 @@ with Itypes;   use Itypes;\n with Lib;      use Lib;\n with Lib.Xref; use Lib.Xref;\n with Namet;    use Namet;\n+with Namet.Sp; use Namet.Sp;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n@@ -43,6 +44,7 @@ with Rident;   use Rident;\n with Sem;      use Sem;\n with Sem_Cat;  use Sem_Cat;\n with Sem_Ch3;  use Sem_Ch3;\n+with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Disp; use Sem_Disp;\n with Sem_Dist; use Sem_Dist;\n@@ -55,8 +57,6 @@ with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with Tbuild;   use Tbuild;\n \n-with GNAT.Spelling_Checker; use GNAT.Spelling_Checker;\n-\n package body Sem_Ch4 is\n \n    -----------------------\n@@ -184,6 +184,10 @@ package body Sem_Ch4 is\n    --  interpretation of the other operand. N can be an operator node, or\n    --  a function call whose name is an operator designator.\n \n+   function Find_Primitive_Operation (N : Node_Id) return Boolean;\n+   --  Find candidate interpretations for the name Obj.Proc when it appears\n+   --  in a subprogram renaming declaration.\n+\n    procedure Find_Unary_Types\n      (R     : Node_Id;\n       Op_Id : Entity_Id;\n@@ -219,14 +223,18 @@ package body Sem_Ch4 is\n    --  type is not directly visible. The routine uses this type to emit a more\n    --  informative message.\n \n-   procedure Process_Implicit_Dereference_Prefix\n+   function Process_Implicit_Dereference_Prefix\n      (E : Entity_Id;\n-      P : Node_Id);\n+      P : Node_Id) return Entity_Id;\n    --  Called when P is the prefix of an implicit dereference, denoting an\n-   --  object E. If in semantics only mode (-gnatc or generic), record that is\n-   --  a reference to E. Normally, such a reference is generated only when the\n-   --  implicit dereference is expanded into an explicit one. E may be empty,\n-   --  in which case this procedure does nothing.\n+   --  object E. The function returns the designated type of the prefix, taking\n+   --  into account that the designated type of an anonymous access type may be\n+   --  a limited view, when the non-limited view is visible.\n+   --  If in semantics only mode (-gnatc or generic), the function also records\n+   --  that the prefix is a reference to E, if any. Normally, such a reference\n+   --  is generated only when the implicit dereference is expanded into an\n+   --  explicit one, but for consistency we must generate the reference when\n+   --  expansion is disabled as well.\n \n    procedure Remove_Abstract_Operations (N : Node_Id);\n    --  Ada 2005: implementation of AI-310. An abstract non-dispatching\n@@ -303,9 +311,7 @@ package body Sem_Ch4 is\n       if Nkind (N) in N_Membership_Test then\n          Error_Msg_N (\"ambiguous operands for membership\",  N);\n \n-      elsif Nkind (N) = N_Op_Eq\n-        or else Nkind (N) = N_Op_Ne\n-      then\n+      elsif Nkind_In (N, N_Op_Eq, N_Op_Ne) then\n          Error_Msg_N (\"ambiguous operands for equality\",  N);\n \n       else\n@@ -349,7 +355,6 @@ package body Sem_Ch4 is\n       Check_Restriction (No_Allocators, N);\n \n       if Nkind (E) = N_Qualified_Expression then\n-\n          Acc_Type := Create_Itype (E_Allocator_Type, N);\n          Set_Etype (Acc_Type, Acc_Type);\n          Init_Size_Align (Acc_Type);\n@@ -461,8 +466,8 @@ package body Sem_Ch4 is\n                       Subtype_Indication  => Relocate_Node (E)));\n \n                   if Sav_Errs /= Serious_Errors_Detected\n-                    and then Nkind (Constraint (E))\n-                      = N_Index_Or_Discriminant_Constraint\n+                    and then Nkind (Constraint (E)) =\n+                               N_Index_Or_Discriminant_Constraint\n                   then\n                      Error_Msg_N\n                        (\"if qualified expression was meant, \" &\n@@ -599,21 +604,18 @@ package body Sem_Ch4 is\n       Analyze_Expression (L);\n       Analyze_Expression (R);\n \n-      --  If the entity is already set, the node is the instantiation of\n-      --  a generic node with a non-local reference, or was manufactured\n-      --  by a call to Make_Op_xxx. In either case the entity is known to\n-      --  be valid, and we do not need to collect interpretations, instead\n-      --  we just get the single possible interpretation.\n+      --  If the entity is already set, the node is the instantiation of a\n+      --  generic node with a non-local reference, or was manufactured by a\n+      --  call to Make_Op_xxx. In either case the entity is known to be valid,\n+      --  and we do not need to collect interpretations, instead we just get\n+      --  the single possible interpretation.\n \n       Op_Id := Entity (N);\n \n       if Present (Op_Id) then\n          if Ekind (Op_Id) = E_Operator then\n \n-            if (Nkind (N) = N_Op_Divide   or else\n-                Nkind (N) = N_Op_Mod      or else\n-                Nkind (N) = N_Op_Multiply or else\n-                Nkind (N) = N_Op_Rem)\n+            if Nkind_In (N, N_Op_Divide, N_Op_Mod, N_Op_Multiply, N_Op_Rem)\n               and then Treat_Fixed_As_Integer (N)\n             then\n                null;\n@@ -753,7 +755,6 @@ package body Sem_Ch4 is\n          --  kinds of call into this form.\n \n          elsif Nkind (Nam) = N_Indexed_Component then\n-\n             if Nkind (Prefix (Nam)) = N_Selected_Component then\n                Nam_Ent := Entity (Selector_Name (Prefix (Nam)));\n             else\n@@ -794,8 +795,8 @@ package body Sem_Ch4 is\n                   --  Check for tasking cases where only an entry call will do\n \n                   elsif not L\n-                    and then (K = N_Entry_Call_Alternative\n-                               or else K = N_Triggering_Alternative)\n+                    and then Nkind_In (K, N_Entry_Call_Alternative,\n+                                          N_Triggering_Alternative)\n                   then\n                      Error_Msg_N (\"entry name expected\", Nam);\n \n@@ -818,7 +819,7 @@ package body Sem_Ch4 is\n          --  the return type of the access_to_subprogram.\n \n          if Success\n-           and then  Nkind (Nam) = N_Explicit_Dereference\n+           and then Nkind (Nam) = N_Explicit_Dereference\n            and then Ekind (Etype (N)) = E_Incomplete_Type\n            and then Present (Full_View (Etype (N)))\n          then\n@@ -871,8 +872,8 @@ package body Sem_Ch4 is\n             if Success then\n                Set_Etype (Nam, It.Typ);\n \n-            elsif Nkind (Name (N)) = N_Selected_Component\n-              or else Nkind (Name (N)) = N_Function_Call\n+            elsif Nkind_In (Name (N), N_Selected_Component,\n+                                      N_Function_Call)\n             then\n                Remove_Interp (X);\n             end if;\n@@ -971,9 +972,9 @@ package body Sem_Ch4 is\n       if Ada_Version >= Ada_05\n         and then not Debug_Flag_Dot_L\n         and then Is_Inherently_Limited_Type (Etype (N))\n-        and then (Nkind (Parent (N)) = N_Selected_Component\n-                   or else Nkind (Parent (N)) = N_Indexed_Component\n-                   or else Nkind (Parent (N)) = N_Slice\n+        and then (Nkind_In (Parent (N), N_Selected_Component,\n+                                        N_Indexed_Component,\n+                                        N_Slice)\n                    or else\n                     (Nkind (Parent (N)) = N_Attribute_Reference\n                        and then Attribute_Name (Parent (N)) /= Name_Class))\n@@ -1550,9 +1551,8 @@ package body Sem_Ch4 is\n             --  account a possible implicit dereference.\n \n             if Is_Access_Type (Array_Type) then\n-               Array_Type := Designated_Type (Array_Type);\n                Error_Msg_NW (Warn_On_Dereference, \"?implicit dereference\", N);\n-               Process_Implicit_Dereference_Prefix (Pent, P);\n+               Array_Type := Process_Implicit_Dereference_Prefix (Pent, P);\n             end if;\n \n             if Is_Array_Type (Array_Type) then\n@@ -1739,9 +1739,9 @@ package body Sem_Ch4 is\n       --  Get name of array, function or type\n \n       Analyze (P);\n-      if Nkind (N) = N_Function_Call\n-        or else Nkind (N) = N_Procedure_Call_Statement\n-      then\n+\n+      if Nkind_In (N, N_Function_Call, N_Procedure_Call_Statement) then\n+\n          --  If P is an explicit dereference whose prefix is of a\n          --  remote access-to-subprogram type, then N has already\n          --  been rewritten as a subprogram call and analyzed.\n@@ -2025,8 +2025,9 @@ package body Sem_Ch4 is\n        Success    : out Boolean;\n        Skip_First : Boolean := False)\n    is\n-      Actuals    : constant List_Id   := Parameter_Associations (N);\n-      Prev_T     : constant Entity_Id := Etype (N);\n+      Actuals : constant List_Id   := Parameter_Associations (N);\n+      Prev_T  : constant Entity_Id := Etype (N);\n+\n       Must_Skip  : constant Boolean := Skip_First\n                      or else Nkind (Original_Node (N)) = N_Selected_Component\n                      or else\n@@ -2496,6 +2497,14 @@ package body Sem_Ch4 is\n          end if;\n \n          if Is_Record_Type (T) then\n+\n+            --  If the prefix is a class-wide type, the visible components are\n+            --  those of the base type.\n+\n+            if Is_Class_Wide_Type (T) then\n+               T := Etype (T);\n+            end if;\n+\n             Comp := First_Entity (T);\n             while Present (Comp) loop\n                if Chars (Comp) = Chars (Sel)\n@@ -2532,9 +2541,12 @@ package body Sem_Ch4 is\n                   Set_Etype (Nam, It.Typ);\n \n                   --  For access type case, introduce explicit deference for\n-                  --  more uniform treatment of entry calls.\n+                  --  more uniform treatment of entry calls. Do this only\n+                  --  once if several interpretations yield an access type.\n \n-                  if Is_Access_Type (Etype (Nam)) then\n+                  if Is_Access_Type (Etype (Nam))\n+                    and then Nkind (Nam) /= N_Explicit_Dereference\n+                  then\n                      Insert_Explicit_Dereference (Nam);\n                      Error_Msg_NW\n                        (Warn_On_Dereference, \"?implicit dereference\", N);\n@@ -2754,20 +2766,64 @@ package body Sem_Ch4 is\n    --  later case, the selector must denote a visible entry.\n \n    procedure Analyze_Selected_Component (N : Node_Id) is\n-      Name        : constant Node_Id := Prefix (N);\n-      Sel         : constant Node_Id := Selector_Name (N);\n-      Comp        : Entity_Id;\n-      Prefix_Type : Entity_Id;\n+      Name          : constant Node_Id := Prefix (N);\n+      Sel           : constant Node_Id := Selector_Name (N);\n+      Act_Decl      : Node_Id;\n+      Comp          : Entity_Id;\n+      Has_Candidate : Boolean := False;\n+      In_Scope      : Boolean;\n+      Parent_N      : Node_Id;\n+      Pent          : Entity_Id := Empty;\n+      Prefix_Type   : Entity_Id;\n \n       Type_To_Use : Entity_Id;\n       --  In most cases this is the Prefix_Type, but if the Prefix_Type is\n       --  a class-wide type, we use its root type, whose components are\n       --  present in the class-wide type.\n \n-      Pent        : Entity_Id := Empty;\n-      Act_Decl    : Node_Id;\n-      In_Scope    : Boolean;\n-      Parent_N    : Node_Id;\n+      function Has_Mode_Conformant_Spec (Comp : Entity_Id) return Boolean;\n+      --  It is known that the parent of N denotes a subprogram call. Comp\n+      --  is an overloadable component of the concurrent type of the prefix.\n+      --  Determine whether all formals of the parent of N and Comp are mode\n+      --  conformant.\n+\n+      ------------------------------\n+      -- Has_Mode_Conformant_Spec --\n+      ------------------------------\n+\n+      function Has_Mode_Conformant_Spec (Comp : Entity_Id) return Boolean is\n+         Comp_Param : Entity_Id;\n+         Param      : Node_Id;\n+         Param_Typ  : Entity_Id;\n+\n+      begin\n+         Comp_Param := First_Formal (Comp);\n+         Param := First (Parameter_Associations (Parent (N)));\n+         while Present (Comp_Param)\n+           and then Present (Param)\n+         loop\n+            Param_Typ := Find_Parameter_Type (Param);\n+\n+            if Present (Param_Typ)\n+              and then\n+                not Conforming_Types\n+                     (Etype (Comp_Param), Param_Typ, Mode_Conformant)\n+            then\n+               return False;\n+            end if;\n+\n+            Next_Formal (Comp_Param);\n+            Next (Param);\n+         end loop;\n+\n+         --  One of the specs has additional formals\n+\n+         if Present (Comp_Param) or else Present (Param) then\n+            return False;\n+         end if;\n+\n+         return True;\n+      end Has_Mode_Conformant_Spec;\n \n    --  Start of processing for Analyze_Selected_Component\n \n@@ -2814,11 +2870,8 @@ package body Sem_Ch4 is\n                Pent := Entity (Selector_Name (Name));\n             end if;\n \n-            Process_Implicit_Dereference_Prefix (Pent, Name);\n+            Prefix_Type := Process_Implicit_Dereference_Prefix (Pent, Name);\n          end if;\n-\n-         Prefix_Type := Designated_Type (Prefix_Type);\n-\n       end if;\n \n       --  (Ada 2005): if the prefix is the limited view of a type, and\n@@ -2966,7 +3019,7 @@ package body Sem_Ch4 is\n                if not Is_Packed (Etype (Comp))\n                  and then\n                    ((Nkind (Parent_N) = N_Indexed_Component\n-                      and then Nkind (Name) /= N_Selected_Component)\n+                       and then Nkind (Name) /= N_Selected_Component)\n                      or else\n                       (Nkind (Parent_N) = N_Attribute_Reference\n                          and then (Attribute_Name (Parent_N) = Name_First\n@@ -3037,13 +3090,29 @@ package body Sem_Ch4 is\n             Next_Entity (Comp);\n          end loop;\n \n-         --  Ada 2005 (AI-252)\n+         --  Ada 2005 (AI-252): The selected component can be interpreted as\n+         --  a prefixed view of a subprogram. Depending on the context, this is\n+         --  either a name that can appear in a renaming declaration, or part\n+         --  of an enclosing call given in prefix form.\n+\n+         --  Ada 2005 (AI05-0030): In the case of dispatching requeue, the\n+         --  selected component should resolve to a name.\n \n          if Ada_Version >= Ada_05\n            and then Is_Tagged_Type (Prefix_Type)\n-           and then Try_Object_Operation (N)\n+           and then not Is_Concurrent_Type (Prefix_Type)\n          then\n-            return;\n+            if Nkind (Parent (N)) = N_Generic_Association\n+              or else Nkind (Parent (N)) = N_Requeue_Statement\n+              or else Nkind (Parent (N)) = N_Subprogram_Renaming_Declaration\n+            then\n+               if Find_Primitive_Operation (N) then\n+                  return;\n+               end if;\n+\n+            elsif Try_Object_Operation (N) then\n+               return;\n+            end if;\n \n             --  If the transformation fails, it will be necessary to redo the\n             --  analysis with all errors enabled, to indicate candidate\n@@ -3052,6 +3121,7 @@ package body Sem_Ch4 is\n          end if;\n \n       elsif Is_Private_Type (Prefix_Type) then\n+\n          --  Allow access only to discriminants of the type. If the type has\n          --  no full view, gigi uses the parent type for the components, so we\n          --  do the same here.\n@@ -3071,8 +3141,7 @@ package body Sem_Ch4 is\n                   Set_Etype (N,   Etype (Comp));\n \n                   if Is_Generic_Type (Prefix_Type)\n-                    or else\n-                     Is_Generic_Type (Root_Type (Prefix_Type))\n+                    or else Is_Generic_Type (Root_Type (Prefix_Type))\n                   then\n                      Set_Original_Discriminant (Sel, Comp);\n                   end if;\n@@ -3102,21 +3171,37 @@ package body Sem_Ch4 is\n \n       elsif Is_Concurrent_Type (Prefix_Type) then\n \n-         --  Prefix is concurrent type. Find visible operation with given name\n-         --  For a task, this can only include entries or discriminants if the\n-         --  task type is not an enclosing scope. If it is an enclosing scope\n-         --  (e.g. in an inner task) then all entities are visible, but the\n-         --  prefix must denote the enclosing scope, i.e. can only be a direct\n-         --  name or an expanded name.\n+         --  Find visible operation with given name. For a protected type,\n+         --  the possible candidates are discriminants, entries or protected\n+         --  procedures. For a task type, the set can only include entries or\n+         --  discriminants if the task type is not an enclosing scope. If it\n+         --  is an enclosing scope (e.g. in an inner task) then all entities\n+         --  are visible, but the prefix must denote the enclosing scope, i.e.\n+         --  can only be a direct name or an expanded name.\n \n-         Set_Etype (Sel,  Any_Type);\n+         Set_Etype (Sel, Any_Type);\n          In_Scope := In_Open_Scopes (Prefix_Type);\n \n          while Present (Comp) loop\n             if Chars (Comp) = Chars (Sel) then\n                if Is_Overloadable (Comp) then\n                   Add_One_Interp (Sel, Comp, Etype (Comp));\n \n+                  --  If the prefix is tagged, the correct interpretation may\n+                  --  lie in the primitive or class-wide operations of the\n+                  --  type. Perform a simple conformance check to determine\n+                  --  whether Try_Object_Operation should be invoked even if\n+                  --  a visible entity is found.\n+\n+                  if Is_Tagged_Type (Prefix_Type)\n+                    and then\n+                      Nkind_In (Parent (N), N_Procedure_Call_Statement,\n+                                            N_Function_Call)\n+                    and then Has_Mode_Conformant_Spec (Comp)\n+                  then\n+                     Has_Candidate := True;\n+                  end if;\n+\n                elsif Ekind (Comp) = E_Discriminant\n                  or else Ekind (Comp) = E_Entry_Family\n                  or else (In_Scope\n@@ -3153,14 +3238,15 @@ package body Sem_Ch4 is\n                    Comp = First_Private_Entity (Base_Type (Prefix_Type));\n          end loop;\n \n-         --  If there is no visible entry with the given name, and the task\n-         --  implements an interface, check whether there is some other\n-         --  primitive operation with that name.\n+         --  If there is no visible entity with the given name or none of the\n+         --  visible entities are plausible interpretations, check whether\n+         --  there is some other primitive operation with that name.\n \n          if Ada_Version >= Ada_05\n            and then Is_Tagged_Type (Prefix_Type)\n          then\n-            if Etype (N) = Any_Type\n+            if (Etype (N) = Any_Type\n+                  or else not Has_Candidate)\n               and then Try_Object_Operation (N)\n             then\n                return;\n@@ -3313,7 +3399,6 @@ package body Sem_Ch4 is\n       Set_Etype (N, Any_Type);\n \n       if not Is_Overloaded (L) then\n-\n          if Root_Type (Etype (L)) = Standard_Boolean\n            and then Has_Compatible_Type (R, Etype (L))\n          then\n@@ -3333,13 +3418,12 @@ package body Sem_Ch4 is\n          end loop;\n       end if;\n \n-      --  Here we have failed to find an interpretation. Clearly we\n-      --  know that it is not the case that both operands can have\n-      --  an interpretation of Boolean, but this is by far the most\n-      --  likely intended interpretation. So we simply resolve both\n-      --  operands as Booleans, and at least one of these resolutions\n-      --  will generate an error message, and we do not need to give\n-      --  a further error message on the short circuit operation itself.\n+      --  Here we have failed to find an interpretation. Clearly we know that\n+      --  it is not the case that both operands can have an interpretation of\n+      --  Boolean, but this is by far the most likely intended interpretation.\n+      --  So we simply resolve both operands as Booleans, and at least one of\n+      --  these resolutions will generate an error message, and we do not need\n+      --  to give another error message on the short circuit operation itself.\n \n       if Etype (N) = Any_Type then\n          Resolve (L, Standard_Boolean);\n@@ -3884,44 +3968,34 @@ package body Sem_Ch4 is\n          return;\n       end if;\n \n-      Get_Name_String (Chars (Sel));\n-\n-      declare\n-         S  : constant String (1 .. Name_Len) := Name_Buffer (1 .. Name_Len);\n-\n-      begin\n-         Comp  := First_Entity (Prefix);\n-         while Nr_Of_Suggestions <= Max_Suggestions\n-            and then Present (Comp)\n-         loop\n-            if Is_Visible_Component (Comp) then\n-               Get_Name_String (Chars (Comp));\n-\n-               if Is_Bad_Spelling_Of (Name_Buffer (1 .. Name_Len), S) then\n-                  Nr_Of_Suggestions := Nr_Of_Suggestions + 1;\n-\n-                  case Nr_Of_Suggestions is\n-                     when 1      => Suggestion_1 := Comp;\n-                     when 2      => Suggestion_2 := Comp;\n-                     when others => exit;\n-                  end case;\n-               end if;\n+      Comp  := First_Entity (Prefix);\n+      while Nr_Of_Suggestions <= Max_Suggestions and then Present (Comp) loop\n+         if Is_Visible_Component (Comp) then\n+            if Is_Bad_Spelling_Of (Chars (Comp), Chars (Sel)) then\n+               Nr_Of_Suggestions := Nr_Of_Suggestions + 1;\n+\n+               case Nr_Of_Suggestions is\n+                  when 1      => Suggestion_1 := Comp;\n+                  when 2      => Suggestion_2 := Comp;\n+                  when others => exit;\n+               end case;\n             end if;\n+         end if;\n \n-            Comp := Next_Entity (Comp);\n-         end loop;\n+         Comp := Next_Entity (Comp);\n+      end loop;\n \n-         --  Report at most two suggestions\n+      --  Report at most two suggestions\n \n-         if Nr_Of_Suggestions = 1 then\n-            Error_Msg_NE (\"\\possible misspelling of&\", Sel, Suggestion_1);\n+      if Nr_Of_Suggestions = 1 then\n+         Error_Msg_NE\n+           (\"\\possible misspelling of&\", Sel, Suggestion_1);\n \n-         elsif Nr_Of_Suggestions = 2 then\n-            Error_Msg_Node_2 := Suggestion_2;\n-            Error_Msg_NE (\"\\possible misspelling of& or&\",\n-              Sel, Suggestion_1);\n-         end if;\n-      end;\n+      elsif Nr_Of_Suggestions = 2 then\n+         Error_Msg_Node_2 := Suggestion_2;\n+         Error_Msg_NE\n+           (\"\\possible misspelling of& or&\", Sel, Suggestion_1);\n+      end if;\n    end Check_Misspelled_Selector;\n \n    ----------------------\n@@ -4548,6 +4622,81 @@ package body Sem_Ch4 is\n       end if;\n    end Find_Negation_Types;\n \n+   ------------------------------\n+   -- Find_Primitive_Operation --\n+   ------------------------------\n+\n+   function Find_Primitive_Operation (N : Node_Id) return Boolean is\n+      Obj : constant Node_Id := Prefix (N);\n+      Op  : constant Node_Id := Selector_Name (N);\n+\n+      Prim  : Elmt_Id;\n+      Prims : Elist_Id;\n+      Typ   : Entity_Id;\n+\n+   begin\n+      Set_Etype (Op, Any_Type);\n+\n+      if Is_Access_Type (Etype (Obj)) then\n+         Typ := Designated_Type (Etype (Obj));\n+      else\n+         Typ := Etype (Obj);\n+      end if;\n+\n+      if Is_Class_Wide_Type (Typ) then\n+         Typ := Root_Type (Typ);\n+      end if;\n+\n+      Prims := Primitive_Operations (Typ);\n+\n+      Prim := First_Elmt (Prims);\n+      while Present (Prim) loop\n+         if Chars (Node (Prim)) = Chars (Op) then\n+            Add_One_Interp (Op, Node (Prim), Etype (Node (Prim)));\n+            Set_Etype (N, Etype (Node (Prim)));\n+         end if;\n+\n+         Next_Elmt (Prim);\n+      end loop;\n+\n+      --  Now look for class-wide operations of the type or any of its\n+      --  ancestors by iterating over the homonyms of the selector.\n+\n+      declare\n+         Cls_Type : constant Entity_Id := Class_Wide_Type (Typ);\n+         Hom      : Entity_Id;\n+\n+      begin\n+         Hom := Current_Entity (Op);\n+         while Present (Hom) loop\n+            if (Ekind (Hom) = E_Procedure\n+                  or else\n+                Ekind (Hom) = E_Function)\n+              and then Scope (Hom) = Scope (Typ)\n+              and then Present (First_Formal (Hom))\n+              and then\n+                (Base_Type (Etype (First_Formal (Hom))) = Cls_Type\n+                  or else\n+                    (Is_Access_Type (Etype (First_Formal (Hom)))\n+                       and then\n+                         Ekind (Etype (First_Formal (Hom))) =\n+                           E_Anonymous_Access_Type\n+                       and then\n+                         Base_Type\n+                           (Designated_Type (Etype (First_Formal (Hom)))) =\n+                                                                Cls_Type))\n+            then\n+               Add_One_Interp (Op, Hom, Etype (Hom));\n+               Set_Etype (N, Etype (Hom));\n+            end if;\n+\n+            Hom := Homonym (Hom);\n+         end loop;\n+      end;\n+\n+      return Etype (Op) /= Any_Type;\n+   end Find_Primitive_Operation;\n+\n    ----------------------\n    -- Find_Unary_Types --\n    ----------------------\n@@ -4744,12 +4893,7 @@ package body Sem_Ch4 is\n             --  pretty much know that the other operand should be Boolean, so\n             --  resolve it that way (generating an error)\n \n-            elsif Nkind (N) = N_Op_And\n-                    or else\n-                  Nkind (N) = N_Op_Or\n-                    or else\n-                  Nkind (N) = N_Op_Xor\n-            then\n+            elsif Nkind_In (N, N_Op_And, N_Op_Or, N_Op_Xor) then\n                if Etype (L) = Standard_Boolean then\n                   Resolve (R, Standard_Boolean);\n                   return;\n@@ -4763,16 +4907,17 @@ package body Sem_Ch4 is\n             --  is not the same numeric type. If it is a non-numeric type,\n             --  then probably it is intended to match the other operand.\n \n-            elsif Nkind (N) = N_Op_Add      or else\n-                  Nkind (N) = N_Op_Divide   or else\n-                  Nkind (N) = N_Op_Ge       or else\n-                  Nkind (N) = N_Op_Gt       or else\n-                  Nkind (N) = N_Op_Le       or else\n-                  Nkind (N) = N_Op_Lt       or else\n-                  Nkind (N) = N_Op_Mod      or else\n-                  Nkind (N) = N_Op_Multiply or else\n-                  Nkind (N) = N_Op_Rem      or else\n-                  Nkind (N) = N_Op_Subtract\n+            elsif Nkind_In (N, N_Op_Add,\n+                               N_Op_Divide,\n+                               N_Op_Ge,\n+                               N_Op_Gt,\n+                               N_Op_Le)\n+              or else\n+                  Nkind_In (N, N_Op_Lt,\n+                               N_Op_Mod,\n+                               N_Op_Multiply,\n+                               N_Op_Rem,\n+                               N_Op_Subtract)\n             then\n                if Is_Numeric_Type (Etype (L))\n                  and then not Is_Numeric_Type (Etype (R))\n@@ -4790,8 +4935,7 @@ package body Sem_Ch4 is\n             --  Comparisons on A'Access are common enough to deserve a\n             --  special message.\n \n-            elsif (Nkind (N) = N_Op_Eq  or else\n-                   Nkind (N) = N_Op_Ne)\n+            elsif Nkind_In (N, N_Op_Eq, N_Op_Ne)\n                and then Ekind (Etype (L)) = E_Access_Attribute_Type\n                and then Ekind (Etype (R)) = E_Access_Attribute_Type\n             then\n@@ -4903,11 +5047,12 @@ package body Sem_Ch4 is\n    -- Process_Implicit_Dereference_Prefix --\n    -----------------------------------------\n \n-   procedure Process_Implicit_Dereference_Prefix\n+   function Process_Implicit_Dereference_Prefix\n      (E : Entity_Id;\n-      P : Entity_Id)\n+      P : Entity_Id) return Entity_Id\n    is\n       Ref : Node_Id;\n+      Typ : constant Entity_Id := Designated_Type (Etype (P));\n \n    begin\n       if Present (E)\n@@ -4922,6 +5067,24 @@ package body Sem_Ch4 is\n          Set_Comes_From_Source (Ref, Comes_From_Source (P));\n          Generate_Reference (E, Ref);\n       end if;\n+\n+      --  An implicit dereference is a legal occurrence of an\n+      --  incomplete type imported through a limited_with clause,\n+      --  if the full view is visible.\n+\n+      if From_With_Type (Typ)\n+        and then not From_With_Type (Scope (Typ))\n+        and then\n+          (Is_Immediately_Visible (Scope (Typ))\n+            or else\n+              (Is_Child_Unit (Scope (Typ))\n+                 and then Is_Visible_Child_Unit (Scope (Typ))))\n+      then\n+         return Available_View (Typ);\n+      else\n+         return Typ;\n+      end if;\n+\n    end Process_Implicit_Dereference_Prefix;\n \n    --------------------------------\n@@ -5290,26 +5453,26 @@ package body Sem_Ch4 is\n \n    function Try_Object_Operation (N : Node_Id) return Boolean is\n       K              : constant Node_Kind  := Nkind (Parent (N));\n+      Is_Subprg_Call : constant Boolean    := Nkind_In\n+                                               (K, N_Procedure_Call_Statement,\n+                                                   N_Function_Call);\n       Loc            : constant Source_Ptr := Sloc (N);\n-      Candidate      : Entity_Id := Empty;\n-      Is_Subprg_Call : constant Boolean    := K = N_Procedure_Call_Statement\n-                                               or else K = N_Function_Call;\n       Obj            : constant Node_Id    := Prefix (N);\n       Subprog        : constant Node_Id    :=\n                          Make_Identifier (Sloc (Selector_Name (N)),\n                            Chars => Chars (Selector_Name (N)));\n       --  Identifier on which possible interpretations will be collected\n \n-      Success        : Boolean := False;\n-\n       Report_Error : Boolean := False;\n       --  If no candidate interpretation matches the context, redo the\n       --  analysis with error enabled to provide additional information.\n \n       Actual          : Node_Id;\n+      Candidate       : Entity_Id := Empty;\n       New_Call_Node   : Node_Id := Empty;\n       Node_To_Replace : Node_Id;\n       Obj_Type        : Entity_Id := Etype (Obj);\n+      Success         : Boolean := False;\n \n       function Valid_Candidate\n         (Success : Boolean;\n@@ -5333,9 +5496,9 @@ package body Sem_Ch4 is\n         (Call_Node       : out Node_Id;\n          Node_To_Replace : out Node_Id);\n       --  Transform Obj.Operation (X, Y,,) into Operation (Obj, X, Y ..)\n-      --  Call_Node is the resulting subprogram call,\n-      --  Node_To_Replace is either N or the parent of N, and Subprog\n-      --  is a reference to the subprogram we are trying to match.\n+      --  Call_Node is the resulting subprogram call, Node_To_Replace is\n+      --  either N or the parent of N, and Subprog is a reference to the\n+      --  subprogram we are trying to match.\n \n       function Try_Class_Wide_Operation\n         (Call_Node       : Node_Id;\n@@ -5376,14 +5539,14 @@ package body Sem_Ch4 is\n             end if;\n          end if;\n \n-         --  If the call may be an indexed call, retrieve component type\n-         --  of resulting expression, and add possible interpretation.\n+         --  If the call may be an indexed call, retrieve component type of\n+         --  resulting expression, and add possible interpretation.\n \n          Comp_Type := Empty;\n \n          if Nkind (Call) = N_Function_Call\n-             and then Nkind (Parent (N)) = N_Indexed_Component\n-             and then Needs_One_Actual (Subp)\n+           and then Nkind (Parent (N)) = N_Indexed_Component\n+           and then Needs_One_Actual (Subp)\n          then\n             if Is_Array_Type (Etype (Subp)) then\n                Comp_Type := Component_Type (Etype (Subp));\n@@ -5396,7 +5559,7 @@ package body Sem_Ch4 is\n          end if;\n \n          if Present (Comp_Type)\n-              and then Etype (Subprog) /= Comp_Type\n+           and then Etype (Subprog) /= Comp_Type\n          then\n             Add_One_Interp (Subprog, Subp, Comp_Type);\n          end if;\n@@ -5472,9 +5635,9 @@ package body Sem_Ch4 is\n                  (\"expect variable in call to&\", Prefix (N), Entity (Subprog));\n             end if;\n \n-         --  Conversely, if the formal is an access parameter and the\n-         --  object is not, replace the actual with a 'Access reference.\n-         --   Its analysis will check that the object is aliased.\n+         --  Conversely, if the formal is an access parameter and the object\n+         --  is not, replace the actual with a 'Access reference. Its analysis\n+         --  will check that the object is aliased.\n \n          elsif Is_Access_Type (Formal_Type)\n            and then not Is_Access_Type (Etype (Obj))\n@@ -5563,22 +5726,21 @@ package body Sem_Ch4 is\n         (Call_Node       : out Node_Id;\n          Node_To_Replace : out Node_Id)\n       is\n-         Parent_Node : constant Node_Id := Parent (N);\n-\n          Dummy : constant Node_Id := New_Copy (Obj);\n          --  Placeholder used as a first parameter in the call, replaced\n          --  eventually by the proper object.\n \n-         Actuals : List_Id;\n+         Parent_Node : constant Node_Id := Parent (N);\n+\n          Actual  : Node_Id;\n+         Actuals : List_Id;\n \n       begin\n          --  Common case covering 1) Call to a procedure and 2) Call to a\n          --  function that has some additional actuals.\n \n-         if (Nkind (Parent_Node) = N_Function_Call\n-               or else\n-             Nkind (Parent_Node) = N_Procedure_Call_Statement)\n+         if Nkind_In (Parent_Node, N_Function_Call,\n+                                   N_Procedure_Call_Statement)\n \n             --  N is a selected component node containing the name of the\n             --  subprogram. If N is not the name of the parent node we must\n@@ -5614,7 +5776,7 @@ package body Sem_Ch4 is\n \n             end if;\n \n-         --  Before analysis, the function call appears as an indexed component\n+         --  Before analysis, a function call appears as an indexed component\n          --  if there are no named associations.\n \n          elsif Nkind (Parent_Node) =  N_Indexed_Component\n@@ -5637,7 +5799,7 @@ package body Sem_Ch4 is\n                  Name => New_Copy (Subprog),\n                  Parameter_Associations => Actuals);\n \n-         --  Parameterless call:  Obj.F is rewritten as F (Obj)\n+         --  Parameterless call: Obj.F is rewritten as F (Obj)\n \n          else\n             Node_To_Replace := N;\n@@ -5666,8 +5828,8 @@ package body Sem_Ch4 is\n             Error    : out Boolean);\n          --  Traverse the homonym chain of the subprogram searching for those\n          --  homonyms whose first formal has the Anc_Type's class-wide type,\n-         --  or an anonymous access type designating the class-wide type. If an\n-         --  ambiguity is detected, then Error is set to True.\n+         --  or an anonymous access type designating the class-wide type. If\n+         --  an ambiguity is detected, then Error is set to True.\n \n          procedure Traverse_Interfaces\n            (Anc_Type : Entity_Id;\n@@ -5770,9 +5932,9 @@ package body Sem_Ch4 is\n            (Anc_Type : Entity_Id;\n             Error    : out Boolean)\n          is\n-            Intface      : Node_Id;\n             Intface_List : constant List_Id :=\n                              Abstract_Interface_List (Anc_Type);\n+            Intface      : Node_Id;\n \n          begin\n             Error := False;\n@@ -5807,10 +5969,10 @@ package body Sem_Ch4 is\n       --  Start of processing for Try_Class_Wide_Operation\n \n       begin\n-         --  Loop through ancestor types (including interfaces), traversing the\n-         --  homonym chain of the subprogram, and trying out those homonyms\n-         --  whose first formal has the class-wide type of the ancestor, or an\n-         --  anonymous access type designating the class-wide type.\n+         --  Loop through ancestor types (including interfaces), traversing\n+         --  the homonym chain of the subprogram, trying out those homonyms\n+         --  whose first formal has the class-wide type of the ancestor, or\n+         --  an anonymous access type designating the class-wide type.\n \n          Anc_Type := Obj_Type;\n          loop\n@@ -5921,6 +6083,10 @@ package body Sem_Ch4 is\n          --  part) because the type itself carries no primitive operations,\n          --  except for formal derived types that inherit the operations of\n          --  the parent and progenitors.\n+         --  If the context is a generic subprogram body, the generic formals\n+         --  are visible by name, but are not in the entity list of the\n+         --  subprogram because that list starts with the subprogram formals.\n+         --  We retrieve the candidate operations from the generic declaration.\n \n          function Valid_First_Argument_Of (Op : Entity_Id) return Boolean;\n          --  Verify that the prefix, dereferenced if need be, is a valid\n@@ -5937,10 +6103,61 @@ package body Sem_Ch4 is\n             Subp       : Entity_Id;\n             Formal     : Entity_Id;\n \n+            procedure Check_Candidate;\n+            --  The operation is a candidate if its first parameter is a\n+            --  controlling operand of the desired type.\n+\n+            -----------------------\n+            --  Check_Candidate; --\n+            -----------------------\n+\n+            procedure Check_Candidate is\n+            begin\n+               Formal := First_Formal (Subp);\n+\n+               if Present (Formal)\n+                 and then Is_Controlling_Formal (Formal)\n+                 and then\n+                   (Base_Type (Etype (Formal)) = Bas\n+                     or else\n+                       (Is_Access_Type (Etype (Formal))\n+                         and then Designated_Type (Etype (Formal)) = Bas))\n+               then\n+                  Append_Elmt (Subp, Candidates);\n+               end if;\n+            end Check_Candidate;\n+\n+         --  Start of processing for Collect_Generic_Type_Ops\n+\n          begin\n             if Is_Derived_Type (T) then\n                return Primitive_Operations (T);\n \n+            elsif Ekind (Scope (T)) = E_Procedure\n+              or else Ekind (Scope (T)) = E_Function\n+            then\n+               --  Scan the list of generic formals to find subprograms\n+               --  that may have a first controlling formal of the type.\n+\n+               declare\n+                  Decl : Node_Id;\n+\n+               begin\n+                  Decl :=\n+                    First (Generic_Formal_Declarations\n+                            (Unit_Declaration_Node (Scope (T))));\n+                  while Present (Decl) loop\n+                     if Nkind (Decl) in N_Formal_Subprogram_Declaration then\n+                        Subp := Defining_Entity (Decl);\n+                        Check_Candidate;\n+                     end if;\n+\n+                     Next (Decl);\n+                  end loop;\n+               end;\n+\n+               return Candidates;\n+\n             else\n                --  Scan the list of entities declared in the same scope as\n                --  the type. In general this will be an open scope, given that\n@@ -5951,18 +6168,7 @@ package body Sem_Ch4 is\n                Subp := First_Entity (Scope (T));\n                while Present (Subp) loop\n                   if Is_Overloadable (Subp) then\n-                     Formal := First_Formal (Subp);\n-\n-                     if Present (Formal)\n-                       and then Is_Controlling_Formal (Formal)\n-                       and then\n-                         (Base_Type (Etype (Formal)) = Bas\n-                           or else\n-                            (Is_Access_Type (Etype (Formal))\n-                              and then Designated_Type (Etype (Formal)) = Bas))\n-                     then\n-                        Append_Elmt (Subp, Candidates);\n-                     end if;\n+                     Check_Candidate;\n                   end if;\n \n                   Next_Entity (Subp);\n@@ -5980,12 +6186,11 @@ package body Sem_Ch4 is\n             Typ : constant Entity_Id := Etype (First_Formal (Op));\n \n          begin\n-            --  Simple case. Object may be a subtype of the tagged type\n-            --  or may be the corresponding record of a synchronized type.\n+            --  Simple case. Object may be a subtype of the tagged type or\n+            --  may be the corresponding record of a synchronized type.\n \n             return Obj_Type = Typ\n-              or else  Base_Type (Obj_Type) = Typ\n-\n+              or else Base_Type (Obj_Type) = Typ\n               or else Corr_Type = Typ\n \n                --  Prefix can be dereferenced\n@@ -6005,11 +6210,11 @@ package body Sem_Ch4 is\n       --  Start of processing for Try_Primitive_Operation\n \n       begin\n-         --  Look for subprograms in the list of primitive operations The name\n+         --  Look for subprograms in the list of primitive operations. The name\n          --  must be identical, and the kind of call indicates the expected\n          --  kind of operation (function or procedure). If the type is a\n-         --  (tagged) synchronized type, the primitive ops are attached to\n-         --  the corresponding record type.\n+         --  (tagged) synchronized type, the primitive ops are attached to the\n+         --  corresponding record type.\n \n          if Is_Concurrent_Type (Obj_Type) then\n             Corr_Type := Corresponding_Record_Type (Obj_Type);\n@@ -6045,9 +6250,9 @@ package body Sem_Ch4 is\n                                              (Alias (Prim_Op)), Corr_Type))\n                  or else\n \n-               --  Do not consider hidden primitives unless the type is\n-               --  in an open scope or we are within an instance, where\n-               --  visibility is known to be correct.\n+               --  Do not consider hidden primitives unless the type is in an\n+               --  open scope or we are within an instance, where visibility\n+               --  is known to be correct.\n \n                   (Is_Hidden (Prim_Op)\n                      and then not Is_Immediately_Visible (Obj_Type)\n@@ -6077,12 +6282,11 @@ package body Sem_Ch4 is\n \n                   Matching_Op := Valid_Candidate (Success, Call_Node, Prim_Op);\n \n-               else\n-\n-                  --  More than one interpretation, collect for subsequent\n-                  --  disambiguation. If this is a procedure call and there\n-                  --  is another match, report ambiguity now.\n+               --  More than one interpretation, collect for subsequent\n+               --  disambiguation. If this is a procedure call and there\n+               --  is another match, report ambiguity now.\n \n+               else\n                   Analyze_One_Call\n                     (N          => Call_Node,\n                      Nam        => Prim_Op,\n@@ -6165,7 +6369,7 @@ package body Sem_Ch4 is\n \n          --  The argument list is not type correct. Re-analyze with error\n          --  reporting enabled, and use one of the possible candidates.\n-         --  In all_errors mode, re-analyze all failed interpretations.\n+         --  In All_Errors_Mode, re-analyze all failed interpretations.\n \n          if All_Errors_Mode then\n             Report_Error := True;\n@@ -6190,7 +6394,9 @@ package body Sem_Ch4 is\n                Skip_First => True);\n          end if;\n \n-         return True;  --  No need for further errors.\n+         --  No need for further errors\n+\n+         return True;\n \n       else\n          --  There was no candidate operation, so report it as an error"}]}