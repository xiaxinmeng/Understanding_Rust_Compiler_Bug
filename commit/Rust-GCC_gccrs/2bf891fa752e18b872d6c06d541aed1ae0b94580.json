{"sha": "2bf891fa752e18b872d6c06d541aed1ae0b94580", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJmODkxZmE3NTJlMThiODcyZDZjMDZkNTQxYWVkMWFlMGI5NDU4MA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-11-10T11:14:56Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-11-30T14:16:19Z"}, "message": "[Ada] Expand integer-only implementation of ordinary fixed-point types\n\ngcc/ada/\n\n\t* doc/gnat_rm/implementation_defined_attributes.rst (Pool_Address):\n\tFix pasto.\n\t(Small_Denominator): New entry.\n\t(Small_Numerator): Likewise.\n\t* doc/gnat_rm/implementation_defined_characteristics.rst (3.5.9):\n\tRelax conditions on 128-bit smalls and integer-only implementation.\n\t* gnat_rm.texi: Regenerate.\n\t* exp_attr.adb (Expand_N_Attribute_Reference) <Attribute_Fore>:\n\tRelax conditions on integer implementation for ordinary fixed-point\n\ttypes and pass a third parameter to the routine.\n\t<Attribute_Small_Denominator>: Raise Program_Error.\n\t<Attribute_Small_Numerator>: Likewise.\n\t* exp_fixd.adb (Expand_Convert_Fixed_To_Fixed): Use a scaled divide\n\tif the numerator and denominator of the small ratio are sufficiently\n\tsmall integers.\n\t(Expand_Convert_Fixed_To_Integer): Use a scaled divide if numerator\n\tand denominator of the small value are sufficiently small integers.\n\t(Expand_Convert_Integer_To_Fixed): Likewise.\n\t* exp_imgv.adb (Expand_Image_Attribute): Relax the conditions on the\n\tinteger implementation for ordinary fixed-point types.\n\t(Expand_Value_Attribute): Likewise.\n\t* freeze.adb (Freeze_Fixed_Point_Type): Relax conditions on 128-bit\n\tsmalls.\n\t* sem_attr.adb (Analyze_Attribute) <Attribute_Small_Denominator>:\n\tCheck no arguments, fixed-point and set type to Universal_Integer.\n\t<Attribute_Small_Numerator>: Likewise.\n\t(Eval_Attribute) <Attribute_Small_Denominator>: Fold statically.\n\t<Attribute_Small_Numerator>: Likewise.\n\t* snames.ads-tmpl (Name_Small_Denominator): New attribute name.\n\t(Name_Small_Numerator): Likewise.\n\t(Attribute_Id): Add Attribute_Small_{Denominator,Numerator}.\n\t* libgnat/a-tifiio.adb (Exact): Delete.\n\t(Need_64): Likewise.\n\t(OK_Get_32): New boolean constant.\n\t(OK_Put_32): Likewise.\n\t(OK_Get_64): Likewise.\n\t(OK_Put_64): Likewise.\n\t(E): Adjust.\n\t(Get procedures): Likewise.\n\t(Put procedures): Likewise.\n\t* libgnat/a-tifiio__128.adb (Exact): Delete.\n\t(Need_64): Likewise.\n\t(Need_128): Likewise.\n\t(OK_Get_32): New boolean constant.\n\t(OK_Put_32): Likewise.\n\t(OK_Get_64): Likewise.\n\t(OK_Put_64): Likewise.\n\t(OK_Get_128): Likewise.\n\t(OK_Put_128): Likewise.\n\t(E): Adjust.\n\t(Get procedures): Likewise.\n\t(Put procedures): Likewise.\n\t* libgnat/a-wtfiio.adb (Exact): Delete.\n\t(Need_64): Likewise.\n\t(OK_Get_32): New boolean constant.\n\t(OK_Put_32): Likewise.\n\t(OK_Get_64): Likewise.\n\t(OK_Put_64): Likewise.\n\t(E): Adjust.\n\t(Get procedures): Likewise.\n\t(Put procedures): Likewise.\n\t* libgnat/a-wtfiio__128.adb (Exact): Delete.\n\t(Need_64): Likewise.\n\t(Need_128): Likewise.\n\t(OK_Get_32): New boolean constant.\n\t(OK_Put_32): Likewise.\n\t(OK_Get_64): Likewise.\n\t(OK_Put_64): Likewise.\n\t(OK_Get_128): Likewise.\n\t(OK_Put_128): Likewise.\n\t(E): Adjust.\n\t(Get procedures): Likewise.\n\t(Put procedures): Likewise.\n\t* libgnat/a-ztfiio.adb (Exact): Delete.\n\t(Need_64): Likewise.\n\t(OK_Get_32): New boolean constant.\n\t(OK_Put_32): Likewise.\n\t(OK_Get_64): Likewise.\n\t(OK_Put_64): Likewise.\n\t(E): Adjust.\n\t(Get procedures): Likewise.\n\t(Put procedures): Likewise.\n\t* libgnat/a-ztfiio__128.adb (Exact): Delete.\n\t(Need_64): Likewise.\n\t(Need_128): Likewise.\n\t(OK_Get_32): New boolean constant.\n\t(OK_Put_32): Likewise.\n\t(OK_Get_64): Likewise.\n\t(OK_Put_64): Likewise.\n\t(OK_Get_128): Likewise.\n\t(OK_Put_128): Likewise.\n\t(E): Adjust.\n\t(Get procedures): Likewise.\n\t(Put procedures): Likewise.\n\t* libgnat/s-fore_f.ads (Fore_Fixed): Adjust signature.\n\t* libgnat/s-fore_f.adb (Fore_Fixed): Reimplement.\n\t* libgnat/s-fofi32.ads (Fore_Fixed32): Adjust signature.\n\t* libgnat/s-fofi64.ads (Fore_Fixed64): Likewise.\n\t* libgnat/s-fofi128.ads (Fore_Fixed128): Likewise.\n\t* libgnat/s-imagef.ads: Adjust description.\n\t* libgnat/s-imagef.adb (Maxdigs): Move around.\n\t(Set_Image_Integer): Remove assertion.\n\t* libgnat/s-valuef.ads: Adjust description.\n\t* libgnat/s-valuef.adb (Integer_To_Fixed): Minor tweak.", "tree": {"sha": "6a8fff173b3bcbfd5f3745318cd7d21dcf321d06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a8fff173b3bcbfd5f3745318cd7d21dcf321d06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2bf891fa752e18b872d6c06d541aed1ae0b94580", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bf891fa752e18b872d6c06d541aed1ae0b94580", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bf891fa752e18b872d6c06d541aed1ae0b94580", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bf891fa752e18b872d6c06d541aed1ae0b94580/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a18d46a4b6cd2b3c6f6506d09a3bd547b20293bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a18d46a4b6cd2b3c6f6506d09a3bd547b20293bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a18d46a4b6cd2b3c6f6506d09a3bd547b20293bf"}], "stats": {"total": 2536, "additions": 1543, "deletions": 993}, "files": [{"sha": "f8d41ea5b8d209355925d08144befc880ef8bcf2", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_attributes.rst", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_attributes.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_attributes.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_attributes.rst?ref=2bf891fa752e18b872d6c06d541aed1ae0b94580", "patch": "@@ -817,8 +817,6 @@ and is static.  For non-scalar types, the result is nonstatic.\n \n Attribute Pool_Address\n ======================\n-.. index:: Parameters, when passed by reference\n-\n .. index:: Pool_Address\n \n ``X'Pool_Address`` for any object ``X`` returns the address\n@@ -1142,6 +1140,26 @@ for compatibility with Ada 83.  See\n the Ada 83 reference manual for an exact description of the semantics of\n this attribute when applied to floating-point types.\n \n+Attribute Small_Denominator\n+===========================\n+.. index:: Small\n+\n+.. index:: Small_Denominator\n+\n+``typ'Small_Denominator`` for any fixed-point subtype `typ` yields the\n+denominator in the representation of ``typ'Small`` as a rational number\n+with coprime factors (i.e. as an irreducible fraction).\n+\n+Attribute Small_Numerator\n+=========================\n+.. index:: Small\n+\n+.. index:: Small_Numerator\n+\n+``typ'Small_Numerator`` for any fixed-point subtype `typ` yields the\n+numerator in the representation of ``typ'Small`` as a rational number\n+with coprime factors (i.e. as an irreducible fraction).\n+\n Attribute Storage_Unit\n ======================\n .. index:: Storage_Unit"}, {"sha": "10fcfc93c1d0330ddd42d6ccfe47b07cf5bad802", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_characteristics.rst", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_characteristics.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_characteristics.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_characteristics.rst?ref=2bf891fa752e18b872d6c06d541aed1ae0b94580", "patch": "@@ -160,15 +160,16 @@ is permitted that does not result in a mantissa larger than 63 bits.\n On 64-bit platforms, the small must lie in 2.0**(-127) .. 2.0**127 and the\n range in -1.0E+76 .. 1.0E+76; any combination is permitted that does not\n result in a mantissa larger than 63 bits, and any combination is permitted\n-that results in a mantissa between 64 and 127 bits if the small is either\n-an integer or the reciprocal of an integer.\n-\n-If the small is either an integer or the reciprocal of an integer, which\n-is the case if no ``small`` clause is provided, then the operations of the\n-fixed point type are entirely implemented by means of integer instructions.\n-In the other cases, some operations, in particular input and output, may be\n-implemented by means of floating-point instructions and may be affected by\n-accuracy issues on architectures other than x86.\n+that results in a mantissa between 64 and 127 bits if the small is the\n+ratio of two integers that lie in 1 .. 2.0**127.\n+\n+If the small is the ratio of two integers with 64-bit magnitude on 32-bit\n+platforms and 128-bit magnitude on 64-bit platforms, which is the case if\n+no ``small`` clause is provided, then the operations of the fixed point\n+type are entirely implemented by means of integer instructions.  In the\n+other cases, some operations, in particular input and output, may be\n+implemented by means of floating-point instructions and may be affected\n+by accuracy issues on architectures other than x86.\n \n For a decimal fixed point type, on 32-bit platforms, the small must lie in\n 1.0E-18 .. 1.0E+18 and the digits in 1 .. 18.  On 64-bit platforms, the"}, {"sha": "251fa1449c4a612669bae86d7d1191b5c650ec67", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=2bf891fa752e18b872d6c06d541aed1ae0b94580", "patch": "@@ -3626,8 +3626,9 @@ package body Exp_Attr is\n       --    For the most common ordinary fixed-point types\n       --      xx   = Fixed{32,64,128}\n       --      ftyp = Integer_{32,64,128}\n-      --      pm   = Typ'Small\n-      --             1.0 / Typ'Small\n+      --      pm   = numerator of Typ'Small\n+      --             denominator of Typ'Small\n+      --             min (scale of Typ'Small, 0)\n \n       --    For other ordinary fixed-point types\n       --      xx   = Real\n@@ -3666,20 +3667,26 @@ package body Exp_Attr is\n \n                begin\n                   if Siz <= 32\n-                    and then Min = Uint_1\n                     and then Max <= Uint_2 ** 31\n+                    and then (Min = Uint_1\n+                               or else Num < Den\n+                               or else Num < Uint_10 ** 8)\n                   then\n                      Fid  := RE_Fore_Fixed32;\n                      Ftyp := RTE (RE_Integer_32);\n                   elsif Siz <= 64\n-                    and then Min = Uint_1\n                     and then Max <= Uint_2 ** 63\n+                    and then (Min = Uint_1\n+                               or else Num < Den\n+                               or else Num < Uint_10 ** 17)\n                   then\n                      Fid  := RE_Fore_Fixed64;\n                      Ftyp := RTE (RE_Integer_64);\n                   elsif System_Max_Integer_Size = 128\n-                    and then Min = Uint_1\n                     and then Max <= Uint_2 ** 127\n+                    and then (Min = Uint_1\n+                               or else Num < Den\n+                               or else Num < Uint_10 ** 37)\n                   then\n                      Fid  := RE_Fore_Fixed128;\n                      Ftyp := RTE (RE_Integer_128);\n@@ -3711,8 +3718,8 @@ package body Exp_Attr is\n                Append_To (Arg_List,\n                  Make_Integer_Literal (Loc, Scale_Value (Ptyp)));\n \n-            --  For ordinary fixed-point types, append Num, Den parameters\n-            --  and also set to do literal conversion\n+            --  For ordinary fixed-point types, append Num, Den and Scale\n+            --  parameters and also set to do literal conversion\n \n             elsif Fid /= RE_Fore_Real then\n                Set_Conversion_OK (First (Arg_List));\n@@ -3723,6 +3730,20 @@ package body Exp_Attr is\n \n                Append_To (Arg_List,\n                  Make_Integer_Literal (Loc, -Norm_Den (Small_Value (Ptyp))));\n+\n+               declare\n+                  Val   : Ureal := Small_Value (Ptyp);\n+                  Scale : Int   := 0;\n+\n+               begin\n+                  while Val >= Ureal_10 loop\n+                     Val := Val / Ureal_10;\n+                     Scale := Scale - 1;\n+                  end loop;\n+\n+                  Append_To (Arg_List,\n+                     Make_Integer_Literal (Loc, UI_From_Int (Scale)));\n+               end;\n             end if;\n \n             Rewrite (N,\n@@ -7813,6 +7834,8 @@ package body Exp_Attr is\n          | Attribute_Scale\n          | Attribute_Signed_Zeros\n          | Attribute_Small\n+         | Attribute_Small_Denominator\n+         | Attribute_Small_Numerator\n          | Attribute_Storage_Unit\n          | Attribute_Stub_Type\n          | Attribute_System_Allocator_Alignment"}, {"sha": "3bb7207bf00cef588a96557cacd180f42f539317", "filename": "gcc/ada/exp_fixd.adb", "status": "modified", "additions": 75, "deletions": 30, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Fexp_fixd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Fexp_fixd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_fixd.adb?ref=2bf891fa752e18b872d6c06d541aed1ae0b94580", "patch": "@@ -1594,6 +1594,10 @@ package body Exp_Fixd is\n    --  If the small ratio is the reciprocal of a sufficiently small integer,\n    --  then the perfect result set is obtained by a single integer division.\n \n+   --  If the numerator and denominator of the small ratio are sufficiently\n+   --  small integers, then the perfect result set is obtained by a scaled\n+   --  divide operation.\n+\n    --  In other cases, we obtain the close result set by calculating the\n    --  result in floating-point.\n \n@@ -1605,7 +1609,8 @@ package body Exp_Fixd is\n       Small_Ratio : Ureal;\n       Ratio_Num   : Uint;\n       Ratio_Den   : Uint;\n-      Lit         : Node_Id;\n+      Lit_Num     : Node_Id;\n+      Lit_Den     : Node_Id;\n \n    begin\n       if Is_OK_Static_Expression (Expr) then\n@@ -1623,26 +1628,36 @@ package body Exp_Fixd is\n             return;\n \n          else\n-            Lit := Integer_Literal (N, Ratio_Num);\n+            Lit_Num := Integer_Literal (N, Ratio_Num);\n \n-            if Present (Lit) then\n-               Set_Result (N, Build_Multiply (N, Expr, Lit));\n+            if Present (Lit_Num) then\n+               Set_Result (N, Build_Multiply (N, Expr, Lit_Num));\n                return;\n             end if;\n          end if;\n \n       elsif Ratio_Num = 1 then\n-         Lit := Integer_Literal (N, Ratio_Den);\n+         Lit_Den := Integer_Literal (N, Ratio_Den);\n \n-         if Present (Lit) then\n-            Set_Result (N, Build_Divide (N, Expr, Lit), Rng_Check);\n+         if Present (Lit_Den) then\n+            Set_Result (N, Build_Divide (N, Expr, Lit_Den), Rng_Check);\n+            return;\n+         end if;\n+\n+      else\n+         Lit_Num := Integer_Literal (N, Ratio_Num);\n+         Lit_Den := Integer_Literal (N, Ratio_Den);\n+\n+         if Present (Lit_Num) and then Present (Lit_Den) then\n+            Set_Result\n+              (N, Build_Scaled_Divide (N, Expr, Lit_Num, Lit_Den), Rng_Check);\n             return;\n          end if;\n       end if;\n \n-      --  Fall through to use floating-point for the close result set case\n-      --  either as a result of the small ratio not being an integer or the\n-      --  reciprocal of an integer, or if the integer is out of range.\n+      --  Fall through to use floating-point for the close result set case,\n+      --  as a result of the numerator or denominator of the small ratio not\n+      --  being a sufficiently small integer.\n \n       Set_Result (N,\n         Build_Multiply (N,\n@@ -1698,6 +1713,10 @@ package body Exp_Fixd is\n    --  If the small value is the reciprocal of a sufficiently small integer,\n    --  then the perfect result set is obtained by a single integer division.\n \n+   --  If the numerator and denominator of the small value are sufficiently\n+   --  small integers, then the perfect result set is obtained by a scaled\n+   --  divide operation.\n+\n    --  In other cases, we obtain the close result set by calculating the\n    --  result in floating-point.\n \n@@ -1708,7 +1727,8 @@ package body Exp_Fixd is\n       Small       : constant Ureal     := Small_Value (Source_Type);\n       Small_Num   : constant Uint      := Norm_Num (Small);\n       Small_Den   : constant Uint      := Norm_Den (Small);\n-      Lit         : Node_Id;\n+      Lit_Num     : Node_Id;\n+      Lit_Den     : Node_Id;\n \n    begin\n       if Is_OK_Static_Expression (Expr) then\n@@ -1717,25 +1737,35 @@ package body Exp_Fixd is\n       end if;\n \n       if Small_Den = 1 then\n-         Lit := Integer_Literal (N, Small_Num);\n+         Lit_Num := Integer_Literal (N, Small_Num);\n \n-         if Present (Lit) then\n-            Set_Result (N, Build_Multiply (N, Expr, Lit), Rng_Check);\n+         if Present (Lit_Num) then\n+            Set_Result (N, Build_Multiply (N, Expr, Lit_Num), Rng_Check);\n             return;\n          end if;\n \n       elsif Small_Num = 1 then\n-         Lit := Integer_Literal (N, Small_Den);\n+         Lit_Den := Integer_Literal (N, Small_Den);\n+\n+         if Present (Lit_Den) then\n+            Set_Result (N, Build_Divide (N, Expr, Lit_Den), Rng_Check);\n+            return;\n+         end if;\n+\n+      else\n+         Lit_Num := Integer_Literal (N, Small_Num);\n+         Lit_Den := Integer_Literal (N, Small_Den);\n \n-         if Present (Lit) then\n-            Set_Result (N, Build_Divide (N, Expr, Lit), Rng_Check);\n+         if Present (Lit_Num) and then Present (Lit_Den) then\n+            Set_Result\n+              (N, Build_Scaled_Divide (N, Expr, Lit_Num, Lit_Den), Rng_Check);\n             return;\n          end if;\n       end if;\n \n-      --  Fall through to use floating-point for the close result set case\n-      --  either as a result of the small value not being an integer or the\n-      --  reciprocal of an integer, or if the integer is out of range.\n+      --  Fall through to use floating-point for the close result set case,\n+      --  as a result of the numerator or denominator of the small value not\n+      --  being a sufficiently small integer.\n \n       Set_Result (N,\n         Build_Multiply (N,\n@@ -1817,6 +1847,10 @@ package body Exp_Fixd is\n    --  If the small value is the reciprocal of a sufficiently small integer,\n    --  the perfect result set is obtained by a single integer multiplication.\n \n+   --  If the numerator and denominator of the small value are sufficiently\n+   --  small integers, then the perfect result set is obtained by a scaled\n+   --  divide operation.\n+\n    --  In other cases, we obtain the close result set by calculating the\n    --  result in floating-point using a multiplication by the reciprocal\n    --  of the Result_Small.\n@@ -1828,29 +1862,40 @@ package body Exp_Fixd is\n       Small       : constant Ureal     := Small_Value (Result_Type);\n       Small_Num   : constant Uint      := Norm_Num (Small);\n       Small_Den   : constant Uint      := Norm_Den (Small);\n-      Lit         : Node_Id;\n+      Lit_Num     : Node_Id;\n+      Lit_Den     : Node_Id;\n \n    begin\n       if Small_Den = 1 then\n-         Lit := Integer_Literal (N, Small_Num);\n+         Lit_Num := Integer_Literal (N, Small_Num);\n \n-         if Present (Lit) then\n-            Set_Result (N, Build_Divide (N, Expr, Lit), Rng_Check);\n+         if Present (Lit_Num) then\n+            Set_Result (N, Build_Divide (N, Expr, Lit_Num), Rng_Check);\n             return;\n          end if;\n \n       elsif Small_Num = 1 then\n-         Lit := Integer_Literal (N, Small_Den);\n+         Lit_Den := Integer_Literal (N, Small_Den);\n+\n+         if Present (Lit_Den) then\n+            Set_Result (N, Build_Multiply (N, Expr, Lit_Den), Rng_Check);\n+            return;\n+         end if;\n+\n+      else\n+         Lit_Num := Integer_Literal (N, Small_Num);\n+         Lit_Den := Integer_Literal (N, Small_Den);\n \n-         if Present (Lit) then\n-            Set_Result (N, Build_Multiply (N, Expr, Lit), Rng_Check);\n+         if Present (Lit_Num) and then Present (Lit_Den) then\n+            Set_Result\n+              (N, Build_Scaled_Divide (N, Expr, Lit_Den, Lit_Num), Rng_Check);\n             return;\n          end if;\n       end if;\n \n-      --  Fall through to use floating-point for the close result set case\n-      --  either as a result of the small value not being an integer or the\n-      --  reciprocal of an integer, or if the integer is out of range.\n+      --  Fall through to use floating-point for the close result set case,\n+      --  as a result of the numerator or denominator of the small value not\n+      --  being a sufficiently small integer.\n \n       Set_Result (N,\n         Build_Multiply (N,"}, {"sha": "b79d30afa5b1d9a790d860e95db0a9b0c0fb8dc5", "filename": "gcc/ada/exp_imgv.adb", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Fexp_imgv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Fexp_imgv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_imgv.adb?ref=2bf891fa752e18b872d6c06d541aed1ae0b94580", "patch": "@@ -244,8 +244,8 @@ package body Exp_Imgv is\n    --    For the most common ordinary fixed-point types\n    --      xx = Fixed{32,64,128}\n    --      tv = Integer_{32,64,128} (Expr) [convert with no scaling]\n-   --      pm = typ'Small (typ = subtype of expression)\n-   --           1.0 / typ'Small\n+   --      pm = numerator of typ'Small (typ = subtype of expression)\n+   --           denominator of typ'Small\n    --           (Integer_{32,64,128} x typ'Small)'Fore\n    --           typ'Aft\n \n@@ -604,21 +604,29 @@ package body Exp_Imgv is\n             Siz : constant Uint := Esize (Rtyp);\n \n          begin\n+            --  Note that we do not use sharp bounds to speed things up\n+\n             if Siz <= 32\n-              and then Min = Uint_1\n               and then Max <= Uint_2 ** 31\n+              and then (Min = Uint_1\n+                         or else (Num < Den and then Den <= Uint_2 ** 27)\n+                         or else (Den < Num and then Num <= Uint_2 ** 25))\n             then\n                Imid := RE_Image_Fixed32;\n                Tent := RTE (RE_Integer_32);\n             elsif Siz <= 64\n-              and then Min = Uint_1\n               and then Max <= Uint_2 ** 63\n+              and then (Min = Uint_1\n+                         or else (Num < Den and then Den <= Uint_2 ** 59)\n+                         or else (Den < Num and then Num <= Uint_2 ** 53))\n             then\n                Imid := RE_Image_Fixed64;\n                Tent := RTE (RE_Integer_64);\n             elsif System_Max_Integer_Size = 128\n-              and then Min = Uint_1\n               and then Max <= Uint_2 ** 127\n+              and then (Min = Uint_1\n+                         or else (Num < Den and then Den <= Uint_2 ** 123)\n+                         or else (Den < Num and then Num <= Uint_2 ** 122))\n             then\n                Imid := RE_Image_Fixed128;\n                Tent := RTE (RE_Integer_128);\n@@ -880,7 +888,7 @@ package body Exp_Imgv is\n \n    --  For the most common ordinary fixed-point types\n \n-   --    btyp?(Value_Fixed{32,64,128} (X, S, 1.0 / S));\n+   --    btyp?(Value_Fixed{32,64,128} (X, numerator of S, denominator of S));\n    --    where S = typ'Small\n \n    --  For Wide_[Wide_]Character types, typ'Value (X) expands into:\n@@ -985,18 +993,18 @@ package body Exp_Imgv is\n \n          begin\n             if Siz <= 32\n-              and then Min = Uint_1\n               and then Max <= Uint_2 ** 31\n+              and then (Min = Uint_1 or else Max <= Uint_2 ** 27)\n             then\n                Vid := RE_Value_Fixed32;\n             elsif Siz <= 64\n-              and then Min = Uint_1\n               and then Max <= Uint_2 ** 63\n+              and then (Min = Uint_1 or else Max <= Uint_2 ** 59)\n             then\n                Vid := RE_Value_Fixed64;\n             elsif System_Max_Integer_Size = 128\n-              and then Min = Uint_1\n               and then Max <= Uint_2 ** 127\n+              and then (Min = Uint_1 or else Max <= Uint_2 ** 123)\n             then\n                Vid := RE_Value_Fixed128;\n             else"}, {"sha": "098b117cf840c27771049521ca85ee2b0414a980", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=2bf891fa752e18b872d6c06d541aed1ae0b94580", "patch": "@@ -8513,12 +8513,13 @@ package body Freeze is\n             end if;\n \n             if Actual_Size > 64\n-              and then Norm_Num (Small) /= Uint_1\n-              and then Norm_Den (Small) /= Uint_1\n+              and then (Norm_Num (Small) > Uint_2 ** 127\n+                         or else Norm_Den (Small) > Uint_2 ** 127)\n+              and then Small /= Ureal_2_M_128\n             then\n                Error_Msg_Name_1 := Name_Small;\n                Error_Msg_N\n-                 (\"`&''%` not an integer or reciprocal of an integer\", Typ);\n+                 (\"`&''%` not the ratio of two 128-bit integers\", Typ);\n             end if;\n \n             if Smaller (Expr_Value_R (Lo), Ureal_M_10_76) then"}, {"sha": "401d625000f810c24abf73cffe6ab046aed064d3", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 487, "deletions": 459, "changes": 946, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=2bf891fa752e18b872d6c06d541aed1ae0b94580"}, {"sha": "93862beb094bf3f899445af3b254a464d011336d", "filename": "gcc/ada/libgnat/a-tifiio.adb", "status": "modified", "additions": 93, "deletions": 59, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Flibgnat%2Fa-tifiio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Flibgnat%2Fa-tifiio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-tifiio.adb?ref=2bf891fa752e18b872d6c06d541aed1ae0b94580", "patch": "@@ -151,38 +151,76 @@ with System.Val_Fixed_64; use System.Val_Fixed_64;\n package body Ada.Text_IO.Fixed_IO is\n \n    --  Note: we still use the floating-point I/O routines for types whose small\n-   --  is not a sufficiently small integer or the reciprocal thereof. This will\n-   --  result in inaccuracies for fixed point types that require more precision\n-   --  than is available in Long_Long_Float.\n+   --  is not the ratio of two sufficiently small integers. This will result in\n+   --  inaccuracies for fixed point types that require more precision than is\n+   --  available in Long_Long_Float.\n \n-   subtype Int32 is Interfaces.Integer_32;\n-   subtype Int64 is Interfaces.Integer_64;\n+   subtype Int32 is Interfaces.Integer_32; use type Int32;\n+   subtype Int64 is Interfaces.Integer_64; use type Int64;\n \n    package Aux32 is new\n      Ada.Text_IO.Fixed_Aux (Int32, Scan_Fixed32, Set_Image_Fixed32);\n \n    package Aux64 is new\n      Ada.Text_IO.Fixed_Aux (Int64, Scan_Fixed64, Set_Image_Fixed64);\n \n-   Exact : constant Boolean :=\n-     (Float'Floor (Num'Small) = Float'Ceiling (Num'Small)\n-       or else Float'Floor (1.0 / Num'Small) = Float'Ceiling (1.0 / Num'Small))\n-     and then Num'Small >= 2.0**(-63)\n-     and then Num'Small <= 2.0**63;\n-   --  True if the exact algorithm implemented in Fixed_Aux can be used. The\n-   --  condition is a Small which is either an integer or the reciprocal of an\n-   --  integer with the appropriate magnitude.\n-\n-   Need_64 : constant Boolean :=\n-     Num'Object_Size > 32\n-       or else Num'Small > 2.0**31\n-       or else Num'Small < 2.0**(-31);\n    --  Throughout this generic body, we distinguish between the case where type\n-   --  Int32 is acceptable and where type Int64 is needed. This Boolean is used\n-   --  to test for these cases and since it is a constant, only code for the\n-   --  relevant case will be included in the instance.\n-\n-   E : constant Natural := 31 + 32 * Boolean'Pos (Need_64);\n+   --  Int32 is OK and where type Int64 is OK. These boolean constants are used\n+   --  to test for this, such that only code for the relevant case is included\n+   --  in the instance; that's why the computation of their value must be fully\n+   --  static (although it is not a static expressions in the RM sense).\n+\n+   OK_Get_32 : constant Boolean :=\n+     Num'Object_Size <= 32\n+       and then\n+         ((Num'Small_Numerator = 1 and then Num'Small_Denominator <= 2**31)\n+           or else\n+          (Num'Small_Denominator = 1 and then Num'Small_Numerator <= 2**31)\n+           or else\n+          (Num'Small_Numerator <= 2**27\n+            and then Num'Small_Denominator <= 2**27));\n+   --  These conditions are derived from the prerequisites of System.Value_F\n+\n+   OK_Put_32 : constant Boolean :=\n+     Num'Object_Size <= 32\n+       and then\n+         ((Num'Small_Numerator = 1 and then Num'Small_Denominator <= 2**31)\n+           or else\n+          (Num'Small_Denominator = 1 and then Num'Small_Numerator <= 2**31)\n+           or else\n+          (Num'Small_Numerator < Num'Small_Denominator\n+            and then Num'Small_Denominator <= 2**27)\n+           or else\n+          (Num'Small_Denominator < Num'Small_Numerator\n+            and then Num'Small_Numerator <= 2**25));\n+   --  These conditions are derived from the prerequisites of System.Image_F\n+\n+   OK_Get_64 : constant Boolean :=\n+     Num'Object_Size <= 64\n+       and then\n+         ((Num'Small_Numerator = 1 and then Num'Small_Denominator <= 2**63)\n+           or else\n+          (Num'Small_Denominator = 1 and then Num'Small_Numerator <= 2**63)\n+           or else\n+          (Num'Small_Numerator <= 2**59\n+            and then Num'Small_Denominator <= 2**59));\n+   --  These conditions are derived from the prerequisites of System.Value_F\n+\n+   OK_Put_64 : constant Boolean :=\n+     Num'Object_Size <= 64\n+       and then\n+         ((Num'Small_Numerator = 1 and then Num'Small_Denominator <= 2**63)\n+           or else\n+          (Num'Small_Denominator = 1 and then Num'Small_Numerator <= 2**63)\n+           or else\n+          (Num'Small_Numerator < Num'Small_Denominator\n+            and then Num'Small_Denominator <= 2**59)\n+           or else\n+          (Num'Small_Denominator < Num'Small_Numerator\n+            and then Num'Small_Numerator <= 2**53));\n+   --  These conditions are derived from the prerequisites of System.Image_F\n+\n+   E : constant Natural := 63 - 32 * Boolean'Pos (OK_Put_32);\n    --  T'Size - 1 for the selected Int{32,64}\n \n    F0 : constant Natural := 0;\n@@ -217,18 +255,18 @@ package body Ada.Text_IO.Fixed_IO is\n       pragma Unsuppress (Range_Check);\n \n    begin\n-      if not Exact then\n-         Float_Aux.Get (File, Long_Long_Float (Item), Width);\n-      elsif Need_64 then\n+      if OK_Get_32 then\n+         Item := Num'Fixed_Value\n+                   (Aux32.Get (File, Width,\n+                               -Num'Small_Numerator,\n+                               -Num'Small_Denominator));\n+      elsif OK_Get_64 then\n          Item := Num'Fixed_Value\n                    (Aux64.Get (File, Width,\n-                               Int64 (-Float'Ceiling (Num'Small)),\n-                               Int64 (-Float'Ceiling (1.0 / Num'Small))));\n+                               -Num'Small_Numerator,\n+                               -Num'Small_Denominator));\n       else\n-         Item := Num'Fixed_Value\n-                   (Aux32.Get (File, Width,\n-                               Int32 (-Float'Ceiling (Num'Small)),\n-                               Int32 (-Float'Ceiling (1.0 / Num'Small))));\n+         Float_Aux.Get (File, Long_Long_Float (Item), Width);\n       end if;\n \n    exception\n@@ -251,18 +289,18 @@ package body Ada.Text_IO.Fixed_IO is\n       pragma Unsuppress (Range_Check);\n \n    begin\n-      if not Exact then\n-         Float_Aux.Gets (From, Long_Long_Float (Item), Last);\n-      elsif Need_64 then\n+      if OK_Get_32 then\n+         Item := Num'Fixed_Value\n+                   (Aux32.Gets (From, Last,\n+                                -Num'Small_Numerator,\n+                                -Num'Small_Denominator));\n+      elsif OK_Get_64 then\n          Item := Num'Fixed_Value\n                    (Aux64.Gets (From, Last,\n-                                Int64 (-Float'Ceiling (Num'Small)),\n-                                Int64 (-Float'Ceiling (1.0 / Num'Small))));\n+                                -Num'Small_Numerator,\n+                                -Num'Small_Denominator));\n       else\n-         Item := Num'Fixed_Value\n-                   (Aux32.Gets (From, Last,\n-                                Int32 (-Float'Ceiling (Num'Small)),\n-                                Int32 (-Float'Ceiling (1.0 / Num'Small))));\n+         Float_Aux.Gets (From, Long_Long_Float (Item), Last);\n       end if;\n \n    exception\n@@ -281,18 +319,16 @@ package body Ada.Text_IO.Fixed_IO is\n       Exp  : Field := Default_Exp)\n    is\n    begin\n-      if not Exact then\n-         Float_Aux.Put (File, Long_Long_Float (Item), Fore, Aft, Exp);\n-      elsif Need_64 then\n+      if OK_Put_32 then\n+         Aux32.Put (File, Int32'Integer_Value (Item), Fore, Aft, Exp,\n+                    -Num'Small_Numerator, -Num'Small_Denominator,\n+                    For0, Num'Aft);\n+      elsif OK_Put_64 then\n          Aux64.Put (File, Int64'Integer_Value (Item), Fore, Aft, Exp,\n-                    Int64 (-Float'Ceiling (Num'Small)),\n-                    Int64 (-Float'Ceiling (1.0 / Num'Small)),\n+                    -Num'Small_Numerator, -Num'Small_Denominator,\n                     For0, Num'Aft);\n       else\n-         Aux32.Put (File, Int32'Integer_Value (Item), Fore, Aft, Exp,\n-                    Int32 (-Float'Ceiling (Num'Small)),\n-                    Int32 (-Float'Ceiling (1.0 / Num'Small)),\n-                    For0, Num'Aft);\n+         Float_Aux.Put (File, Long_Long_Float (Item), Fore, Aft, Exp);\n       end if;\n    end Put;\n \n@@ -313,18 +349,16 @@ package body Ada.Text_IO.Fixed_IO is\n       Exp  : Field := Default_Exp)\n    is\n    begin\n-      if not Exact then\n-         Float_Aux.Puts (To, Long_Long_Float (Item), Aft, Exp);\n-      elsif Need_64 then\n+      if OK_Put_32 then\n+         Aux32.Puts (To, Int32'Integer_Value (Item), Aft, Exp,\n+                     -Num'Small_Numerator, -Num'Small_Denominator,\n+                     For0, Num'Aft);\n+      elsif OK_Put_64 then\n          Aux64.Puts (To, Int64'Integer_Value (Item), Aft, Exp,\n-                     Int64 (-Float'Ceiling (Num'Small)),\n-                     Int64 (-Float'Ceiling (1.0 / Num'Small)),\n+                     -Num'Small_Numerator, -Num'Small_Denominator,\n                      For0, Num'Aft);\n       else\n-         Aux32.Puts (To, Int32'Integer_Value (Item), Aft, Exp,\n-                     Int32 (-Float'Ceiling (Num'Small)),\n-                     Int32 (-Float'Ceiling (1.0 / Num'Small)),\n-                     For0, Num'Aft);\n+         Float_Aux.Puts (To, Long_Long_Float (Item), Aft, Exp);\n       end if;\n    end Put;\n "}, {"sha": "f2dffcffad33b1923a1f7ecfd6154f5f79a3e5ba", "filename": "gcc/ada/libgnat/a-tifiio__128.adb", "status": "modified", "additions": 136, "deletions": 83, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Flibgnat%2Fa-tifiio__128.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Flibgnat%2Fa-tifiio__128.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-tifiio__128.adb?ref=2bf891fa752e18b872d6c06d541aed1ae0b94580", "patch": "@@ -153,13 +153,13 @@ with System.Val_Fixed_128; use System.Val_Fixed_128;\n package body Ada.Text_IO.Fixed_IO is\n \n    --  Note: we still use the floating-point I/O routines for types whose small\n-   --  is not a sufficiently small integer or the reciprocal thereof. This will\n-   --  result in inaccuracies for fixed point types that require more precision\n-   --  than is available in Long_Long_Float.\n+   --  is not the ratio of two sufficiently small integers. This will result in\n+   --  inaccuracies for fixed point types that require more precision than is\n+   --  available in Long_Long_Float.\n \n-   subtype Int32  is Interfaces.Integer_32;\n-   subtype Int64  is Interfaces.Integer_64;\n-   subtype Int128 is Interfaces.Integer_128;\n+   subtype Int32  is Interfaces.Integer_32;  use type Int32;\n+   subtype Int64  is Interfaces.Integer_64;  use type Int64;\n+   subtype Int128 is Interfaces.Integer_128; use type Int128;\n \n    package Aux32 is new\n      Ada.Text_IO.Fixed_Aux (Int32, Scan_Fixed32, Set_Image_Fixed32);\n@@ -170,31 +170,90 @@ package body Ada.Text_IO.Fixed_IO is\n    package Aux128 is new\n      Ada.Text_IO.Fixed_Aux (Int128, Scan_Fixed128, Set_Image_Fixed128);\n \n-   Exact : constant Boolean :=\n-     (Float'Floor (Num'Small) = Float'Ceiling (Num'Small)\n-       or else Float'Floor (1.0 / Num'Small) = Float'Ceiling (1.0 / Num'Small))\n-     and then Num'Small >= 2.0**(-127)\n-     and then Num'Small <= 2.0**127;\n-   --  True if the exact algorithm implemented in Fixed_Aux can be used. The\n-   --  condition is a Small which is either an integer or the reciprocal of an\n-   --  integer with the appropriate magnitude.\n-\n-   Need_64 : constant Boolean :=\n-     Num'Object_Size > 32\n-       or else Num'Small > 2.0**31\n-       or else Num'Small < 2.0**(-31);\n-   Need_128 : constant Boolean :=\n-     Num'Object_Size > 64\n-       or else Num'Small > 2.0**63\n-       or else Num'Small < 2.0**(-63);\n-   --  Throughout this generic body, we distinguish between the cases where\n-   --  type Int32 is acceptable, where type Int64 is acceptable, and where\n-   --  type Int128 is needed. These boolean constants are used to test for\n-   --  these cases and since they are constant, only code for the relevant\n-   --  case will be really included in the instance.\n+   --  Throughout this generic body, we distinguish between the case where type\n+   --  Int32 is OK, where type Int64 is OK and where type Int128 is OK. These\n+   --  boolean constants are used to test for this, such that only code for the\n+   --  relevant case is included in the instance; that's why the computation of\n+   --  their value must be fully static (although it is not a static expression\n+   --  in the RM sense).\n+\n+   OK_Get_32 : constant Boolean :=\n+     Num'Object_Size <= 32\n+       and then\n+         ((Num'Small_Numerator = 1 and then Num'Small_Denominator <= 2**31)\n+           or else\n+          (Num'Small_Denominator = 1 and then Num'Small_Numerator <= 2**31)\n+           or else\n+          (Num'Small_Numerator <= 2**27\n+            and then Num'Small_Denominator <= 2**27));\n+   --  These conditions are derived from the prerequisites of System.Value_F\n+\n+   OK_Put_32 : constant Boolean :=\n+     Num'Object_Size <= 32\n+       and then\n+         ((Num'Small_Numerator = 1 and then Num'Small_Denominator <= 2**31)\n+           or else\n+          (Num'Small_Denominator = 1 and then Num'Small_Numerator <= 2**31)\n+           or else\n+          (Num'Small_Numerator < Num'Small_Denominator\n+            and then Num'Small_Denominator <= 2**27)\n+           or else\n+          (Num'Small_Denominator < Num'Small_Numerator\n+            and then Num'Small_Numerator <= 2**25));\n+   --  These conditions are derived from the prerequisites of System.Image_F\n+\n+   OK_Get_64 : constant Boolean :=\n+     Num'Object_Size <= 64\n+       and then\n+         ((Num'Small_Numerator = 1 and then Num'Small_Denominator <= 2**63)\n+           or else\n+          (Num'Small_Denominator = 1 and then Num'Small_Numerator <= 2**63)\n+           or else\n+          (Num'Small_Numerator <= 2**59\n+            and then Num'Small_Denominator <= 2**59));\n+   --  These conditions are derived from the prerequisites of System.Value_F\n+\n+   OK_Put_64 : constant Boolean :=\n+     Num'Object_Size <= 64\n+       and then\n+         ((Num'Small_Numerator = 1 and then Num'Small_Denominator <= 2**63)\n+           or else\n+          (Num'Small_Denominator = 1 and then Num'Small_Numerator <= 2**63)\n+           or else\n+          (Num'Small_Numerator < Num'Small_Denominator\n+            and then Num'Small_Denominator <= 2**59)\n+           or else\n+          (Num'Small_Denominator < Num'Small_Numerator\n+            and then Num'Small_Numerator <= 2**53));\n+   --  These conditions are derived from the prerequisites of System.Image_F\n+\n+   OK_Get_128 : constant Boolean :=\n+     Num'Object_Size <= 128\n+       and then\n+         ((Num'Small_Numerator = 1 and then Num'Small_Denominator <= 2**127)\n+           or else\n+          (Num'Small_Denominator = 1 and then Num'Small_Numerator <= 2**127)\n+           or else\n+          (Num'Small_Numerator <= 2**123\n+            and then Num'Small_Denominator <= 2**123));\n+   --  These conditions are derived from the prerequisites of System.Value_F\n+\n+   OK_Put_128 : constant Boolean :=\n+     Num'Object_Size <= 128\n+       and then\n+         ((Num'Small_Numerator = 1 and then Num'Small_Denominator <= 2**127)\n+           or else\n+          (Num'Small_Denominator = 1 and then Num'Small_Numerator <= 2**127)\n+           or else\n+          (Num'Small_Numerator < Num'Small_Denominator\n+            and then Num'Small_Denominator <= 2**123)\n+           or else\n+          (Num'Small_Denominator < Num'Small_Numerator\n+            and then Num'Small_Numerator <= 2**122));\n+   --  These conditions are derived from the prerequisites of System.Image_F\n \n    E : constant Natural :=\n-         31 + 32 * Boolean'Pos (Need_64) + 64 * Boolean'Pos (Need_128);\n+         127 - 64 * Boolean'Pos (OK_Put_64) - 32 * Boolean'Pos (OK_Put_32);\n    --  T'Size - 1 for the selected Int{32,64,128}\n \n    F0 : constant Natural := 0;\n@@ -231,23 +290,23 @@ package body Ada.Text_IO.Fixed_IO is\n       pragma Unsuppress (Range_Check);\n \n    begin\n-      if not Exact then\n-         Float_Aux.Get (File, Long_Long_Float (Item), Width);\n-      elsif Need_128 then\n+      if OK_Get_32 then\n          Item := Num'Fixed_Value\n-                   (Aux128.Get (File, Width,\n-                                Int128 (-Float'Ceiling (Num'Small)),\n-                                Int128 (-Float'Ceiling (1.0 / Num'Small))));\n-      elsif Need_64 then\n+                   (Aux32.Get (File, Width,\n+                               -Num'Small_Numerator,\n+                               -Num'Small_Denominator));\n+      elsif OK_Get_64 then\n          Item := Num'Fixed_Value\n                    (Aux64.Get (File, Width,\n-                               Int64 (-Float'Ceiling (Num'Small)),\n-                               Int64 (-Float'Ceiling (1.0 / Num'Small))));\n-      else\n+                               -Num'Small_Numerator,\n+                               -Num'Small_Denominator));\n+      elsif OK_Get_128 then\n          Item := Num'Fixed_Value\n-                   (Aux32.Get (File, Width,\n-                               Int32 (-Float'Ceiling (Num'Small)),\n-                               Int32 (-Float'Ceiling (1.0 / Num'Small))));\n+                   (Aux128.Get (File, Width,\n+                                -Num'Small_Numerator,\n+                                -Num'Small_Denominator));\n+      else\n+         Float_Aux.Get (File, Long_Long_Float (Item), Width);\n       end if;\n \n    exception\n@@ -270,23 +329,23 @@ package body Ada.Text_IO.Fixed_IO is\n       pragma Unsuppress (Range_Check);\n \n    begin\n-      if not Exact then\n-         Float_Aux.Gets (From, Long_Long_Float (Item), Last);\n-      elsif Need_128 then\n+      if OK_Get_32 then\n          Item := Num'Fixed_Value\n-                   (Aux128.Gets (From, Last,\n-                                 Int128 (-Float'Ceiling (Num'Small)),\n-                                 Int128 (-Float'Ceiling (1.0 / Num'Small))));\n-      elsif Need_64 then\n+                   (Aux32.Gets (From, Last,\n+                                -Num'Small_Numerator,\n+                                -Num'Small_Denominator));\n+      elsif OK_Get_64 then\n          Item := Num'Fixed_Value\n                    (Aux64.Gets (From, Last,\n-                                Int64 (-Float'Ceiling (Num'Small)),\n-                                Int64 (-Float'Ceiling (1.0 / Num'Small))));\n-      else\n+                                -Num'Small_Numerator,\n+                                -Num'Small_Denominator));\n+      elsif OK_Get_128 then\n          Item := Num'Fixed_Value\n-                   (Aux32.Gets (From, Last,\n-                                Int32 (-Float'Ceiling (Num'Small)),\n-                                Int32 (-Float'Ceiling (1.0 / Num'Small))));\n+                   (Aux128.Gets (From, Last,\n+                                 -Num'Small_Numerator,\n+                                 -Num'Small_Denominator));\n+      else\n+         Float_Aux.Gets (From, Long_Long_Float (Item), Last);\n       end if;\n \n    exception\n@@ -305,23 +364,20 @@ package body Ada.Text_IO.Fixed_IO is\n       Exp  : Field := Default_Exp)\n    is\n    begin\n-      if not Exact then\n-         Float_Aux.Put (File, Long_Long_Float (Item), Fore, Aft, Exp);\n-      elsif Need_128 then\n-         Aux128.Put (File, Int128'Integer_Value (Item), Fore, Aft, Exp,\n-                     Int128 (-Float'Ceiling (Num'Small)),\n-                     Int128 (-Float'Ceiling (1.0 / Num'Small)),\n-                     For0, Num'Aft);\n-      elsif Need_64 then\n+      if OK_Put_32 then\n+         Aux32.Put (File, Int32'Integer_Value (Item), Fore, Aft, Exp,\n+                    -Num'Small_Numerator, -Num'Small_Denominator,\n+                    For0, Num'Aft);\n+      elsif OK_Put_64 then\n          Aux64.Put (File, Int64'Integer_Value (Item), Fore, Aft, Exp,\n-                    Int64 (-Float'Ceiling (Num'Small)),\n-                    Int64 (-Float'Ceiling (1.0 / Num'Small)),\n+                    -Num'Small_Numerator, -Num'Small_Denominator,\n                     For0, Num'Aft);\n+      elsif OK_Put_128 then\n+         Aux128.Put (File, Int128'Integer_Value (Item), Fore, Aft, Exp,\n+                     -Num'Small_Numerator, -Num'Small_Denominator,\n+                     For0, Num'Aft);\n       else\n-         Aux32.Put (File, Int32'Integer_Value (Item), Fore, Aft, Exp,\n-                    Int32 (-Float'Ceiling (Num'Small)),\n-                    Int32 (-Float'Ceiling (1.0 / Num'Small)),\n-                    For0, Num'Aft);\n+         Float_Aux.Put (File, Long_Long_Float (Item), Fore, Aft, Exp);\n       end if;\n    end Put;\n \n@@ -342,23 +398,20 @@ package body Ada.Text_IO.Fixed_IO is\n       Exp  : Field := Default_Exp)\n    is\n    begin\n-      if not Exact then\n-         Float_Aux.Puts (To, Long_Long_Float (Item), Aft, Exp);\n-      elsif Need_128 then\n-         Aux128.Puts (To, Int128'Integer_Value (Item), Aft, Exp,\n-                      Int128 (-Float'Ceiling (Num'Small)),\n-                      Int128 (-Float'Ceiling (1.0 / Num'Small)),\n-                      For0, Num'Aft);\n-      elsif Need_64 then\n+      if OK_Put_32 then\n+         Aux32.Puts (To, Int32'Integer_Value (Item), Aft, Exp,\n+                     -Num'Small_Numerator, -Num'Small_Denominator,\n+                     For0, Num'Aft);\n+      elsif OK_Put_64 then\n          Aux64.Puts (To, Int64'Integer_Value (Item), Aft, Exp,\n-                     Int64 (-Float'Ceiling (Num'Small)),\n-                     Int64 (-Float'Ceiling (1.0 / Num'Small)),\n+                     -Num'Small_Numerator, -Num'Small_Denominator,\n                      For0, Num'Aft);\n+      elsif OK_Put_128 then\n+         Aux128.Puts (To, Int128'Integer_Value (Item), Aft, Exp,\n+                      -Num'Small_Numerator, -Num'Small_Denominator,\n+                      For0, Num'Aft);\n       else\n-         Aux32.Puts (To, Int32'Integer_Value (Item), Aft, Exp,\n-                     Int32 (-Float'Ceiling (Num'Small)),\n-                     Int32 (-Float'Ceiling (1.0 / Num'Small)),\n-                     For0, Num'Aft);\n+         Float_Aux.Puts (To, Long_Long_Float (Item), Aft, Exp);\n       end if;\n    end Put;\n "}, {"sha": "142a445e555d8e04eeedeef03cf24a44d86ef79b", "filename": "gcc/ada/libgnat/a-wtfiio.adb", "status": "modified", "additions": 92, "deletions": 58, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Flibgnat%2Fa-wtfiio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Flibgnat%2Fa-wtfiio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-wtfiio.adb?ref=2bf891fa752e18b872d6c06d541aed1ae0b94580", "patch": "@@ -42,38 +42,76 @@ with System.WCh_WtS;      use System.WCh_WtS;\n package body Ada.Wide_Text_IO.Fixed_IO is\n \n    --  Note: we still use the floating-point I/O routines for types whose small\n-   --  is not a sufficiently small integer or the reciprocal thereof. This will\n-   --  result in inaccuracies for fixed point types that require more precision\n-   --  than is available in Long_Long_Float.\n+   --  is not the ratio of two sufficiently small integers. This will result in\n+   --  inaccuracies for fixed point types that require more precision than is\n+   --  available in Long_Long_Float.\n \n-   subtype Int32 is Interfaces.Integer_32;\n-   subtype Int64 is Interfaces.Integer_64;\n+   subtype Int32 is Interfaces.Integer_32; use type Int32;\n+   subtype Int64 is Interfaces.Integer_64; use type Int64;\n \n    package Aux32 is new\n      Ada.Wide_Text_IO.Fixed_Aux (Int32, Scan_Fixed32, Set_Image_Fixed32);\n \n    package Aux64 is new\n      Ada.Wide_Text_IO.Fixed_Aux (Int64, Scan_Fixed64, Set_Image_Fixed64);\n \n-   Exact : constant Boolean :=\n-     (Float'Floor (Num'Small) = Float'Ceiling (Num'Small)\n-       or else Float'Floor (1.0 / Num'Small) = Float'Ceiling (1.0 / Num'Small))\n-     and then Num'Small >= 2.0**(-63)\n-     and then Num'Small <= 2.0**63;\n-   --  True if the exact algorithm implemented in Fixed_Aux can be used. The\n-   --  condition is a Small which is either an integer or the reciprocal of an\n-   --  integer with the appropriate magnitude.\n-\n-   Need_64 : constant Boolean :=\n-     Num'Object_Size > 32\n-       or else Num'Small > 2.0**31\n-       or else Num'Small < 2.0**(-31);\n    --  Throughout this generic body, we distinguish between the case where type\n-   --  Int32 is acceptable and where type Int64 is needed. This Boolean is used\n-   --  to test for these cases and since it is a constant, only code for the\n-   --  relevant case will be included in the instance.\n+   --  Int32 is OK and where type Int64 is OK. These boolean constants are used\n+   --  to test for this, such that only code for the relevant case is included\n+   --  in the instance; that's why the computation of their value must be fully\n+   --  static (although it is not a static expressions in the RM sense).\n \n-   E : constant Natural := 31 + 32 * Boolean'Pos (Need_64);\n+   OK_Get_32 : constant Boolean :=\n+     Num'Object_Size <= 32\n+       and then\n+         ((Num'Small_Numerator = 1 and then Num'Small_Denominator <= 2**31)\n+           or else\n+          (Num'Small_Denominator = 1 and then Num'Small_Numerator <= 2**31)\n+           or else\n+          (Num'Small_Numerator <= 2**27\n+            and then Num'Small_Denominator <= 2**27));\n+   --  These conditions are derived from the prerequisites of System.Value_F\n+\n+   OK_Put_32 : constant Boolean :=\n+     Num'Object_Size <= 32\n+       and then\n+         ((Num'Small_Numerator = 1 and then Num'Small_Denominator <= 2**31)\n+           or else\n+          (Num'Small_Denominator = 1 and then Num'Small_Numerator <= 2**31)\n+           or else\n+          (Num'Small_Numerator < Num'Small_Denominator\n+            and then Num'Small_Denominator <= 2**27)\n+           or else\n+          (Num'Small_Denominator < Num'Small_Numerator\n+            and then Num'Small_Numerator <= 2**25));\n+   --  These conditions are derived from the prerequisites of System.Image_F\n+\n+   OK_Get_64 : constant Boolean :=\n+     Num'Object_Size <= 64\n+       and then\n+         ((Num'Small_Numerator = 1 and then Num'Small_Denominator <= 2**63)\n+           or else\n+          (Num'Small_Denominator = 1 and then Num'Small_Numerator <= 2**63)\n+           or else\n+          (Num'Small_Numerator <= 2**59\n+            and then Num'Small_Denominator <= 2**59));\n+   --  These conditions are derived from the prerequisites of System.Value_F\n+\n+   OK_Put_64 : constant Boolean :=\n+     Num'Object_Size <= 64\n+       and then\n+         ((Num'Small_Numerator = 1 and then Num'Small_Denominator <= 2**63)\n+           or else\n+          (Num'Small_Denominator = 1 and then Num'Small_Numerator <= 2**63)\n+           or else\n+          (Num'Small_Numerator < Num'Small_Denominator\n+            and then Num'Small_Denominator <= 2**59)\n+           or else\n+          (Num'Small_Denominator < Num'Small_Numerator\n+            and then Num'Small_Numerator <= 2**53));\n+   --  These conditions are derived from the prerequisites of System.Image_F\n+\n+   E : constant Natural := 63 - 32 * Boolean'Pos (OK_Put_32);\n    --  T'Size - 1 for the selected Int{32,64}\n \n    F0 : constant Natural := 0;\n@@ -108,18 +146,18 @@ package body Ada.Wide_Text_IO.Fixed_IO is\n       pragma Unsuppress (Range_Check);\n \n    begin\n-      if not Exact then\n-         Float_Aux.Get (File, Long_Long_Float (Item), Width);\n-      elsif Need_64 then\n+      if OK_Get_32 then\n+         Item := Num'Fixed_Value\n+                   (Aux32.Get (File, Width,\n+                               -Num'Small_Numerator,\n+                               -Num'Small_Denominator));\n+      elsif OK_Get_64 then\n          Item := Num'Fixed_Value\n                    (Aux64.Get (File, Width,\n-                               Int64 (-Float'Ceiling (Num'Small)),\n-                               Int64 (-Float'Ceiling (1.0 / Num'Small))));\n+                               -Num'Small_Numerator,\n+                               -Num'Small_Denominator));\n       else\n-         Item := Num'Fixed_Value\n-                   (Aux32.Get (File, Width,\n-                               Int32 (-Float'Ceiling (Num'Small)),\n-                               Int32 (-Float'Ceiling (1.0 / Num'Small))));\n+         Float_Aux.Get (File, Long_Long_Float (Item), Width);\n       end if;\n \n    exception\n@@ -148,18 +186,18 @@ package body Ada.Wide_Text_IO.Fixed_IO is\n       --  Aux.Gets will raise Data_Error in any case.\n \n    begin\n-      if not Exact then\n-         Float_Aux.Gets (S, Long_Long_Float (Item), Last);\n-      elsif Need_64 then\n+      if OK_Get_32 then\n+         Item := Num'Fixed_Value\n+                   (Aux32.Gets (S, Last,\n+                                -Num'Small_Numerator,\n+                                -Num'Small_Denominator));\n+      elsif OK_Get_64 then\n          Item := Num'Fixed_Value\n                    (Aux64.Gets (S, Last,\n-                                Int64 (-Float'Ceiling (Num'Small)),\n-                                Int64 (-Float'Ceiling (1.0 / Num'Small))));\n+                                -Num'Small_Numerator,\n+                                -Num'Small_Denominator));\n       else\n-         Item := Num'Fixed_Value\n-                   (Aux32.Gets (S, Last,\n-                                Int32 (-Float'Ceiling (Num'Small)),\n-                                Int32 (-Float'Ceiling (1.0 / Num'Small))));\n+         Float_Aux.Gets (S, Long_Long_Float (Item), Last);\n       end if;\n \n    exception\n@@ -178,18 +216,16 @@ package body Ada.Wide_Text_IO.Fixed_IO is\n       Exp  : Field := Default_Exp)\n    is\n    begin\n-      if not Exact then\n-         Float_Aux.Put (File, Long_Long_Float (Item), Fore, Aft, Exp);\n-      elsif Need_64 then\n+      if OK_Put_32 then\n+         Aux32.Put (File, Int32'Integer_Value (Item), Fore, Aft, Exp,\n+                    -Num'Small_Numerator, -Num'Small_Denominator,\n+                    For0, Num'Aft);\n+      elsif OK_Put_64 then\n          Aux64.Put (File, Int64'Integer_Value (Item), Fore, Aft, Exp,\n-                    Int64 (-Float'Ceiling (Num'Small)),\n-                    Int64 (-Float'Ceiling (1.0 / Num'Small)),\n+                    -Num'Small_Numerator, -Num'Small_Denominator,\n                     For0, Num'Aft);\n       else\n-         Aux32.Put (File, Int32'Integer_Value (Item), Fore, Aft, Exp,\n-                    Int32 (-Float'Ceiling (Num'Small)),\n-                    Int32 (-Float'Ceiling (1.0 / Num'Small)),\n-                    For0, Num'Aft);\n+         Float_Aux.Put (File, Long_Long_Float (Item), Fore, Aft, Exp);\n       end if;\n    end Put;\n \n@@ -212,18 +248,16 @@ package body Ada.Wide_Text_IO.Fixed_IO is\n       S : String (To'First .. To'Last);\n \n    begin\n-      if not Exact then\n-         Float_Aux.Puts (S, Long_Long_Float (Item), Aft, Exp);\n-      elsif Need_64 then\n+      if OK_Put_32 then\n+         Aux32.Puts (S, Int32'Integer_Value (Item), Aft, Exp,\n+                     -Num'Small_Numerator, -Num'Small_Denominator,\n+                     For0, Num'Aft);\n+      elsif OK_Put_64 then\n          Aux64.Puts (S, Int64'Integer_Value (Item), Aft, Exp,\n-                     Int64 (-Float'Ceiling (Num'Small)),\n-                     Int64 (-Float'Ceiling (1.0 / Num'Small)),\n+                     -Num'Small_Numerator, -Num'Small_Denominator,\n                      For0, Num'Aft);\n       else\n-         Aux32.Puts (S, Int32'Integer_Value (Item), Aft, Exp,\n-                     Int32 (-Float'Ceiling (Num'Small)),\n-                     Int32 (-Float'Ceiling (1.0 / Num'Small)),\n-                     For0, Num'Aft);\n+         Float_Aux.Puts (S, Long_Long_Float (Item), Aft, Exp);\n       end if;\n \n       for J in S'Range loop"}, {"sha": "b4f1b1d90395735294847aa7be4e6262a43821fc", "filename": "gcc/ada/libgnat/a-wtfiio__128.adb", "status": "modified", "additions": 137, "deletions": 83, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Flibgnat%2Fa-wtfiio__128.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Flibgnat%2Fa-wtfiio__128.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-wtfiio__128.adb?ref=2bf891fa752e18b872d6c06d541aed1ae0b94580", "patch": "@@ -44,13 +44,13 @@ with System.WCh_WtS;       use System.WCh_WtS;\n package body Ada.Wide_Text_IO.Fixed_IO is\n \n    --  Note: we still use the floating-point I/O routines for types whose small\n-   --  is not a sufficiently small integer or the reciprocal thereof. This will\n-   --  result in inaccuracies for fixed point types that require more precision\n-   --  than is available in Long_Long_Float.\n+   --  is not the ratio of two sufficiently small integers. This will result in\n+   --  inaccuracies for fixed point types that require more precision than is\n+   --  available in Long_Long_Float.\n \n-   subtype Int32  is Interfaces.Integer_32;\n-   subtype Int64  is Interfaces.Integer_64;\n-   subtype Int128 is Interfaces.Integer_128;\n+   subtype Int32  is Interfaces.Integer_32;  use type Int32;\n+   subtype Int64  is Interfaces.Integer_64;  use type Int64;\n+   subtype Int128 is Interfaces.Integer_128; use type Int128;\n \n    package Aux32 is new\n      Ada.Wide_Text_IO.Fixed_Aux (Int32, Scan_Fixed32, Set_Image_Fixed32);\n@@ -61,31 +61,90 @@ package body Ada.Wide_Text_IO.Fixed_IO is\n    package Aux128 is new\n      Ada.Wide_Text_IO.Fixed_Aux (Int128, Scan_Fixed128, Set_Image_Fixed128);\n \n-   Exact : constant Boolean :=\n-     (Float'Floor (Num'Small) = Float'Ceiling (Num'Small)\n-       or else Float'Floor (1.0 / Num'Small) = Float'Ceiling (1.0 / Num'Small))\n-     and then Num'Small >= 2.0**(-127)\n-     and then Num'Small <= 2.0**127;\n-   --  True if the exact algorithm implemented in Fixed_Aux can be used. The\n-   --  condition is a Small which is either an integer or the reciprocal of an\n-   --  integer with the appropriate magnitude.\n-\n-   Need_64 : constant Boolean :=\n-     Num'Object_Size > 32\n-       or else Num'Small > 2.0**31\n-       or else Num'Small < 2.0**(-31);\n-   Need_128 : constant Boolean :=\n-     Num'Object_Size > 64\n-       or else Num'Small > 2.0**63\n-       or else Num'Small < 2.0**(-63);\n-   --  Throughout this generic body, we distinguish between the cases where\n-   --  type Int32 is acceptable, where type Int64 is acceptable, and where\n-   --  type Int128 is needed. These boolean constants are used to test for\n-   --  these cases and since they are constant, only code for the relevant\n-   --  case will be really included in the instance.\n+   --  Throughout this generic body, we distinguish between the case where type\n+   --  Int32 is OK, where type Int64 is OK and where type Int128 is OK. These\n+   --  boolean constants are used to test for this, such that only code for the\n+   --  relevant case is included in the instance; that's why the computation of\n+   --  their value must be fully static (although it is not a static expression\n+   --  in the RM sense).\n+\n+   OK_Get_32 : constant Boolean :=\n+     Num'Object_Size <= 32\n+       and then\n+         ((Num'Small_Numerator = 1 and then Num'Small_Denominator <= 2**31)\n+           or else\n+          (Num'Small_Denominator = 1 and then Num'Small_Numerator <= 2**31)\n+           or else\n+          (Num'Small_Numerator <= 2**27\n+            and then Num'Small_Denominator <= 2**27));\n+   --  These conditions are derived from the prerequisites of System.Value_F\n+\n+   OK_Put_32 : constant Boolean :=\n+     Num'Object_Size <= 32\n+       and then\n+         ((Num'Small_Numerator = 1 and then Num'Small_Denominator <= 2**31)\n+           or else\n+          (Num'Small_Denominator = 1 and then Num'Small_Numerator <= 2**31)\n+           or else\n+          (Num'Small_Numerator < Num'Small_Denominator\n+            and then Num'Small_Denominator <= 2**27)\n+           or else\n+          (Num'Small_Denominator < Num'Small_Numerator\n+            and then Num'Small_Numerator <= 2**25));\n+   --  These conditions are derived from the prerequisites of System.Image_F\n+\n+   OK_Get_64 : constant Boolean :=\n+     Num'Object_Size <= 64\n+       and then\n+         ((Num'Small_Numerator = 1 and then Num'Small_Denominator <= 2**63)\n+           or else\n+          (Num'Small_Denominator = 1 and then Num'Small_Numerator <= 2**63)\n+           or else\n+          (Num'Small_Numerator <= 2**59\n+            and then Num'Small_Denominator <= 2**59));\n+   --  These conditions are derived from the prerequisites of System.Value_F\n+\n+   OK_Put_64 : constant Boolean :=\n+     Num'Object_Size <= 64\n+       and then\n+         ((Num'Small_Numerator = 1 and then Num'Small_Denominator <= 2**63)\n+           or else\n+          (Num'Small_Denominator = 1 and then Num'Small_Numerator <= 2**63)\n+           or else\n+          (Num'Small_Numerator < Num'Small_Denominator\n+            and then Num'Small_Denominator <= 2**59)\n+           or else\n+          (Num'Small_Denominator < Num'Small_Numerator\n+            and then Num'Small_Numerator <= 2**53));\n+   --  These conditions are derived from the prerequisites of System.Image_F\n+\n+   OK_Get_128 : constant Boolean :=\n+     Num'Object_Size <= 128\n+       and then\n+         ((Num'Small_Numerator = 1 and then Num'Small_Denominator <= 2**127)\n+           or else\n+          (Num'Small_Denominator = 1 and then Num'Small_Numerator <= 2**127)\n+           or else\n+          (Num'Small_Numerator <= 2**123\n+            and then Num'Small_Denominator <= 2**123));\n+   --  These conditions are derived from the prerequisites of System.Value_F\n+\n+   OK_Put_128 : constant Boolean :=\n+     Num'Object_Size <= 128\n+       and then\n+         ((Num'Small_Numerator = 1 and then Num'Small_Denominator <= 2**127)\n+           or else\n+          (Num'Small_Denominator = 1 and then Num'Small_Numerator <= 2**127)\n+           or else\n+          (Num'Small_Numerator < Num'Small_Denominator\n+            and then Num'Small_Denominator <= 2**123)\n+           or else\n+          (Num'Small_Denominator < Num'Small_Numerator\n+            and then Num'Small_Numerator <= 2**122));\n+   --  These conditions are derived from the prerequisites of System.Image_F\n \n    E : constant Natural :=\n-         31 + 32 * Boolean'Pos (Need_64) + 64 * Boolean'Pos (Need_128);\n+         127 - 64 * Boolean'Pos (OK_Put_64) - 32 * Boolean'Pos (OK_Put_32);\n    --  T'Size - 1 for the selected Int{32,64,128}\n \n    F0 : constant Natural := 0;\n@@ -122,23 +181,23 @@ package body Ada.Wide_Text_IO.Fixed_IO is\n       pragma Unsuppress (Range_Check);\n \n    begin\n-      if not Exact then\n-         Float_Aux.Get (File, Long_Long_Float (Item), Width);\n-      elsif Need_128 then\n+      if OK_Get_32 then\n          Item := Num'Fixed_Value\n-                   (Aux128.Get (File, Width,\n-                                Int128 (-Float'Ceiling (Num'Small)),\n-                                Int128 (-Float'Ceiling (1.0 / Num'Small))));\n-      elsif Need_64 then\n+                   (Aux32.Get (File, Width,\n+                               -Num'Small_Numerator,\n+                               -Num'Small_Denominator));\n+      elsif OK_Get_64 then\n          Item := Num'Fixed_Value\n                    (Aux64.Get (File, Width,\n-                               Int64 (-Float'Ceiling (Num'Small)),\n-                               Int64 (-Float'Ceiling (1.0 / Num'Small))));\n-      else\n+                               -Num'Small_Numerator,\n+                               -Num'Small_Denominator));\n+      elsif OK_Get_128 then\n          Item := Num'Fixed_Value\n-                   (Aux32.Get (File, Width,\n-                               Int32 (-Float'Ceiling (Num'Small)),\n-                               Int32 (-Float'Ceiling (1.0 / Num'Small))));\n+                   (Aux128.Get (File, Width,\n+                                -Num'Small_Numerator,\n+                                -Num'Small_Denominator));\n+      else\n+         Float_Aux.Get (File, Long_Long_Float (Item), Width);\n       end if;\n \n    exception\n@@ -167,23 +226,23 @@ package body Ada.Wide_Text_IO.Fixed_IO is\n       --  Aux.Gets will raise Data_Error in any case.\n \n    begin\n-      if not Exact then\n-         Float_Aux.Gets (S, Long_Long_Float (Item), Last);\n-      elsif Need_128 then\n+      if OK_Get_32 then\n          Item := Num'Fixed_Value\n-                   (Aux128.Gets (S, Last,\n-                                 Int128 (-Float'Ceiling (Num'Small)),\n-                                 Int128 (-Float'Ceiling (1.0 / Num'Small))));\n-      elsif Need_64 then\n+                   (Aux32.Gets (S, Last,\n+                                -Num'Small_Numerator,\n+                                -Num'Small_Denominator));\n+      elsif OK_Get_64 then\n          Item := Num'Fixed_Value\n                    (Aux64.Gets (S, Last,\n-                                Int64 (-Float'Ceiling (Num'Small)),\n-                                Int64 (-Float'Ceiling (1.0 / Num'Small))));\n-      else\n+                                -Num'Small_Numerator,\n+                                -Num'Small_Denominator));\n+      elsif OK_Get_128 then\n          Item := Num'Fixed_Value\n-                   (Aux32.Gets (S, Last,\n-                                Int32 (-Float'Ceiling (Num'Small)),\n-                                Int32 (-Float'Ceiling (1.0 / Num'Small))));\n+                   (Aux128.Gets (S, Last,\n+                                 -Num'Small_Numerator,\n+                                 -Num'Small_Denominator));\n+      else\n+         Float_Aux.Gets (S, Long_Long_Float (Item), Last);\n       end if;\n \n    exception\n@@ -202,23 +261,20 @@ package body Ada.Wide_Text_IO.Fixed_IO is\n       Exp  : Field := Default_Exp)\n    is\n    begin\n-      if not Exact then\n-         Float_Aux.Put (File, Long_Long_Float (Item), Fore, Aft, Exp);\n-      elsif Need_128 then\n-         Aux128.Put (File, Int128'Integer_Value (Item), Fore, Aft, Exp,\n-                     Int128 (-Float'Ceiling (Num'Small)),\n-                     Int128 (-Float'Ceiling (1.0 / Num'Small)),\n-                     For0, Num'Aft);\n-      elsif Need_64 then\n+      if OK_Put_32 then\n+         Aux32.Put (File, Int32'Integer_Value (Item), Fore, Aft, Exp,\n+                    -Num'Small_Numerator, -Num'Small_Denominator,\n+                    For0, Num'Aft);\n+      elsif OK_Put_64 then\n          Aux64.Put (File, Int64'Integer_Value (Item), Fore, Aft, Exp,\n-                    Int64 (-Float'Ceiling (Num'Small)),\n-                    Int64 (-Float'Ceiling (1.0 / Num'Small)),\n+                    -Num'Small_Numerator, -Num'Small_Denominator,\n                     For0, Num'Aft);\n+      elsif OK_Put_128 then\n+         Aux128.Put (File, Int128'Integer_Value (Item), Fore, Aft, Exp,\n+                     -Num'Small_Numerator, -Num'Small_Denominator,\n+                     For0, Num'Aft);\n       else\n-         Aux32.Put (File, Int32'Integer_Value (Item), Fore, Aft, Exp,\n-                    Int32 (-Float'Ceiling (Num'Small)),\n-                    Int32 (-Float'Ceiling (1.0 / Num'Small)),\n-                    For0, Num'Aft);\n+         Float_Aux.Put (File, Long_Long_Float (Item), Fore, Aft, Exp);\n       end if;\n    end Put;\n \n@@ -241,24 +297,22 @@ package body Ada.Wide_Text_IO.Fixed_IO is\n       S : String (To'First .. To'Last);\n \n    begin\n-      if not Exact then\n-         Float_Aux.Puts (S, Long_Long_Float (Item), Aft, Exp);\n-      elsif Need_128 then\n-         Aux128.Puts (S, Int128'Integer_Value (Item), Aft, Exp,\n-                      Int128 (-Float'Ceiling (Num'Small)),\n-                      Int128 (-Float'Ceiling (1.0 / Num'Small)),\n-                      For0, Num'Aft);\n-      elsif Need_64 then\n+      if OK_Put_32 then\n+         Aux32.Puts (S, Int32'Integer_Value (Item), Aft, Exp,\n+                     -Num'Small_Numerator, -Num'Small_Denominator,\n+                     For0, Num'Aft);\n+      elsif OK_Put_64 then\n          Aux64.Puts (S, Int64'Integer_Value (Item), Aft, Exp,\n-                     Int64 (-Float'Ceiling (Num'Small)),\n-                     Int64 (-Float'Ceiling (1.0 / Num'Small)),\n+                     -Num'Small_Numerator, -Num'Small_Denominator,\n                      For0, Num'Aft);\n+      elsif OK_Put_128 then\n+         Aux128.Puts (S, Int128'Integer_Value (Item), Aft, Exp,\n+                      -Num'Small_Numerator, -Num'Small_Denominator,\n+                      For0, Num'Aft);\n       else\n-         Aux32.Puts (S, Int32'Integer_Value (Item), Aft, Exp,\n-                     Int32 (-Float'Ceiling (Num'Small)),\n-                     Int32 (-Float'Ceiling (1.0 / Num'Small)),\n-                     For0, Num'Aft);\n+         Float_Aux.Puts (S, Long_Long_Float (Item), Aft, Exp);\n       end if;\n+\n       for J in S'Range loop\n          To (J) := Wide_Character'Val (Character'Pos (S (J)));\n       end loop;"}, {"sha": "c666c7b58b322cad363416615a1e75c37649b66e", "filename": "gcc/ada/libgnat/a-ztfiio.adb", "status": "modified", "additions": 92, "deletions": 58, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Flibgnat%2Fa-ztfiio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Flibgnat%2Fa-ztfiio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztfiio.adb?ref=2bf891fa752e18b872d6c06d541aed1ae0b94580", "patch": "@@ -42,38 +42,76 @@ with System.WCh_WtS;      use System.WCh_WtS;\n package body Ada.Wide_Wide_Text_IO.Fixed_IO is\n \n    --  Note: we still use the floating-point I/O routines for types whose small\n-   --  is not a sufficiently small integer or the reciprocal thereof. This will\n-   --  result in inaccuracies for fixed point types that require more precision\n-   --  than is available in Long_Long_Float.\n+   --  is not the ratio of two sufficiently small integers. This will result in\n+   --  inaccuracies for fixed point types that require more precision than is\n+   --  available in Long_Long_Float.\n \n-   subtype Int32 is Interfaces.Integer_32;\n-   subtype Int64 is Interfaces.Integer_64;\n+   subtype Int32 is Interfaces.Integer_32; use type Int32;\n+   subtype Int64 is Interfaces.Integer_64; use type Int64;\n \n    package Aux32 is new\n      Ada.Wide_Wide_Text_IO.Fixed_Aux (Int32, Scan_Fixed32, Set_Image_Fixed32);\n \n    package Aux64 is new\n      Ada.Wide_Wide_Text_IO.Fixed_Aux (Int64, Scan_Fixed64, Set_Image_Fixed64);\n \n-   Exact : constant Boolean :=\n-     (Float'Floor (Num'Small) = Float'Ceiling (Num'Small)\n-       or else Float'Floor (1.0 / Num'Small) = Float'Ceiling (1.0 / Num'Small))\n-     and then Num'Small >= 2.0**(-63)\n-     and then Num'Small <= 2.0**63;\n-   --  True if the exact algorithm implemented in Fixed_Aux can be used. The\n-   --  condition is a Small which is either an integer or the reciprocal of an\n-   --  integer with the appropriate magnitude.\n-\n-   Need_64 : constant Boolean :=\n-     Num'Object_Size > 32\n-       or else Num'Small > 2.0**31\n-       or else Num'Small < 2.0**(-31);\n    --  Throughout this generic body, we distinguish between the case where type\n-   --  Int32 is acceptable and where type Int64 is needed. This Boolean is used\n-   --  to test for these cases and since it is a constant, only code for the\n-   --  relevant case will be included in the instance.\n+   --  Int32 is OK and where type Int64 is OK. These boolean constants are used\n+   --  to test for this, such that only code for the relevant case is included\n+   --  in the instance; that's why the computation of their value must be fully\n+   --  static (although it is not a static expressions in the RM sense).\n \n-   E : constant Natural := 31 + 32 * Boolean'Pos (Need_64);\n+   OK_Get_32 : constant Boolean :=\n+     Num'Object_Size <= 32\n+       and then\n+         ((Num'Small_Numerator = 1 and then Num'Small_Denominator <= 2**31)\n+           or else\n+          (Num'Small_Denominator = 1 and then Num'Small_Numerator <= 2**31)\n+           or else\n+          (Num'Small_Numerator <= 2**27\n+            and then Num'Small_Denominator <= 2**27));\n+   --  These conditions are derived from the prerequisites of System.Value_F\n+\n+   OK_Put_32 : constant Boolean :=\n+     Num'Object_Size <= 32\n+       and then\n+         ((Num'Small_Numerator = 1 and then Num'Small_Denominator <= 2**31)\n+           or else\n+          (Num'Small_Denominator = 1 and then Num'Small_Numerator <= 2**31)\n+           or else\n+          (Num'Small_Numerator < Num'Small_Denominator\n+            and then Num'Small_Denominator <= 2**27)\n+           or else\n+          (Num'Small_Denominator < Num'Small_Numerator\n+            and then Num'Small_Numerator <= 2**25));\n+   --  These conditions are derived from the prerequisites of System.Image_F\n+\n+   OK_Get_64 : constant Boolean :=\n+     Num'Object_Size <= 64\n+       and then\n+         ((Num'Small_Numerator = 1 and then Num'Small_Denominator <= 2**63)\n+           or else\n+          (Num'Small_Denominator = 1 and then Num'Small_Numerator <= 2**63)\n+           or else\n+          (Num'Small_Numerator <= 2**59\n+            and then Num'Small_Denominator <= 2**59));\n+   --  These conditions are derived from the prerequisites of System.Value_F\n+\n+   OK_Put_64 : constant Boolean :=\n+     Num'Object_Size <= 64\n+       and then\n+         ((Num'Small_Numerator = 1 and then Num'Small_Denominator <= 2**63)\n+           or else\n+          (Num'Small_Denominator = 1 and then Num'Small_Numerator <= 2**63)\n+           or else\n+          (Num'Small_Numerator < Num'Small_Denominator\n+            and then Num'Small_Denominator <= 2**59)\n+           or else\n+          (Num'Small_Denominator < Num'Small_Numerator\n+            and then Num'Small_Numerator <= 2**53));\n+   --  These conditions are derived from the prerequisites of System.Image_F\n+\n+   E : constant Natural := 63 - 32 * Boolean'Pos (OK_Put_32);\n    --  T'Size - 1 for the selected Int{32,64}\n \n    F0 : constant Natural := 0;\n@@ -108,18 +146,18 @@ package body Ada.Wide_Wide_Text_IO.Fixed_IO is\n       pragma Unsuppress (Range_Check);\n \n    begin\n-      if not Exact then\n-         Float_Aux.Get (File, Long_Long_Float (Item), Width);\n-      elsif Need_64 then\n+      if OK_Get_32 then\n+         Item := Num'Fixed_Value\n+                   (Aux32.Get (File, Width,\n+                               -Num'Small_Numerator,\n+                               -Num'Small_Denominator));\n+      elsif OK_Get_64 then\n          Item := Num'Fixed_Value\n                    (Aux64.Get (File, Width,\n-                               Int64 (-Float'Ceiling (Num'Small)),\n-                               Int64 (-Float'Ceiling (1.0 / Num'Small))));\n+                               -Num'Small_Numerator,\n+                               -Num'Small_Denominator));\n       else\n-         Item := Num'Fixed_Value\n-                   (Aux32.Get (File, Width,\n-                               Int32 (-Float'Ceiling (Num'Small)),\n-                               Int32 (-Float'Ceiling (1.0 / Num'Small))));\n+         Float_Aux.Get (File, Long_Long_Float (Item), Width);\n       end if;\n \n    exception\n@@ -148,18 +186,18 @@ package body Ada.Wide_Wide_Text_IO.Fixed_IO is\n       --  Aux.Gets will raise Data_Error in any case.\n \n    begin\n-      if not Exact then\n-         Float_Aux.Gets (S, Long_Long_Float (Item), Last);\n-      elsif Need_64 then\n+      if OK_Get_32 then\n+         Item := Num'Fixed_Value\n+                   (Aux32.Gets (S, Last,\n+                                -Num'Small_Numerator,\n+                                -Num'Small_Denominator));\n+      elsif OK_Get_64 then\n          Item := Num'Fixed_Value\n                    (Aux64.Gets (S, Last,\n-                                Int64 (-Float'Ceiling (Num'Small)),\n-                                Int64 (-Float'Ceiling (1.0 / Num'Small))));\n+                                -Num'Small_Numerator,\n+                                -Num'Small_Denominator));\n       else\n-         Item := Num'Fixed_Value\n-                   (Aux32.Gets (S, Last,\n-                                Int32 (-Float'Ceiling (Num'Small)),\n-                                Int32 (-Float'Ceiling (1.0 / Num'Small))));\n+         Float_Aux.Gets (S, Long_Long_Float (Item), Last);\n       end if;\n \n    exception\n@@ -178,18 +216,16 @@ package body Ada.Wide_Wide_Text_IO.Fixed_IO is\n       Exp  : Field := Default_Exp)\n    is\n    begin\n-      if not Exact then\n-         Float_Aux.Put (File, Long_Long_Float (Item), Fore, Aft, Exp);\n-      elsif Need_64 then\n+      if OK_Put_32 then\n+         Aux32.Put (File, Int32'Integer_Value (Item), Fore, Aft, Exp,\n+                    -Num'Small_Numerator, -Num'Small_Denominator,\n+                    For0, Num'Aft);\n+      elsif OK_Put_64 then\n          Aux64.Put (File, Int64'Integer_Value (Item), Fore, Aft, Exp,\n-                    Int64 (-Float'Ceiling (Num'Small)),\n-                    Int64 (-Float'Ceiling (1.0 / Num'Small)),\n+                    -Num'Small_Numerator, -Num'Small_Denominator,\n                     For0, Num'Aft);\n       else\n-         Aux32.Put (File, Int32'Integer_Value (Item), Fore, Aft, Exp,\n-                    Int32 (-Float'Ceiling (Num'Small)),\n-                    Int32 (-Float'Ceiling (1.0 / Num'Small)),\n-                    For0, Num'Aft);\n+         Float_Aux.Put (File, Long_Long_Float (Item), Fore, Aft, Exp);\n       end if;\n    end Put;\n \n@@ -212,18 +248,16 @@ package body Ada.Wide_Wide_Text_IO.Fixed_IO is\n       S : String (To'First .. To'Last);\n \n    begin\n-      if not Exact then\n-         Float_Aux.Puts (S, Long_Long_Float (Item), Aft, Exp);\n-      elsif Need_64 then\n+      if OK_Put_32 then\n+         Aux32.Puts (S, Int32'Integer_Value (Item), Aft, Exp,\n+                     -Num'Small_Numerator, -Num'Small_Denominator,\n+                     For0, Num'Aft);\n+      elsif OK_Put_64 then\n          Aux64.Puts (S, Int64'Integer_Value (Item), Aft, Exp,\n-                     Int64 (-Float'Ceiling (Num'Small)),\n-                     Int64 (-Float'Ceiling (1.0 / Num'Small)),\n+                     -Num'Small_Numerator, -Num'Small_Denominator,\n                      For0, Num'Aft);\n       else\n-         Aux32.Puts (S, Int32'Integer_Value (Item), Aft, Exp,\n-                     Int32 (-Float'Ceiling (Num'Small)),\n-                     Int32 (-Float'Ceiling (1.0 / Num'Small)),\n-                     For0, Num'Aft);\n+         Float_Aux.Puts (S, Long_Long_Float (Item), Aft, Exp);\n       end if;\n \n       for J in S'Range loop"}, {"sha": "47041466a02c41d1c67115fde1996113e476f372", "filename": "gcc/ada/libgnat/a-ztfiio__128.adb", "status": "modified", "additions": 136, "deletions": 83, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Flibgnat%2Fa-ztfiio__128.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Flibgnat%2Fa-ztfiio__128.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztfiio__128.adb?ref=2bf891fa752e18b872d6c06d541aed1ae0b94580", "patch": "@@ -44,13 +44,13 @@ with System.WCh_WtS;       use System.WCh_WtS;\n package body Ada.Wide_Wide_Text_IO.Fixed_IO is\n \n    --  Note: we still use the floating-point I/O routines for types whose small\n-   --  is not a sufficiently small integer or the reciprocal thereof. This will\n-   --  result in inaccuracies for fixed point types that require more precision\n-   --  than is available in Long_Long_Float.\n+   --  is not the ratio of two sufficiently small integers. This will result in\n+   --  inaccuracies for fixed point types that require more precision than is\n+   --  available in Long_Long_Float.\n \n-   subtype Int32  is Interfaces.Integer_32;\n-   subtype Int64  is Interfaces.Integer_64;\n-   subtype Int128 is Interfaces.Integer_128;\n+   subtype Int32  is Interfaces.Integer_32;  use type Int32;\n+   subtype Int64  is Interfaces.Integer_64;  use type Int64;\n+   subtype Int128 is Interfaces.Integer_128; use type Int128;\n \n    package Aux32 is new\n      Ada.Wide_Wide_Text_IO.Fixed_Aux (Int32, Scan_Fixed32, Set_Image_Fixed32);\n@@ -62,31 +62,90 @@ package body Ada.Wide_Wide_Text_IO.Fixed_IO is\n      Ada.Wide_Wide_Text_IO.Fixed_Aux\n       (Int128, Scan_Fixed128, Set_Image_Fixed128);\n \n-   Exact : constant Boolean :=\n-     (Float'Floor (Num'Small) = Float'Ceiling (Num'Small)\n-       or else Float'Floor (1.0 / Num'Small) = Float'Ceiling (1.0 / Num'Small))\n-     and then Num'Small >= 2.0**(-127)\n-     and then Num'Small <= 2.0**127;\n-   --  True if the exact algorithm implemented in Fixed_Aux can be used. The\n-   --  condition is a Small which is either an integer or the reciprocal of an\n-   --  integer with the appropriate magnitude.\n-\n-   Need_64 : constant Boolean :=\n-     Num'Object_Size > 32\n-       or else Num'Small > 2.0**31\n-       or else Num'Small < 2.0**(-31);\n-   Need_128 : constant Boolean :=\n-     Num'Object_Size > 64\n-       or else Num'Small > 2.0**63\n-       or else Num'Small < 2.0**(-63);\n-   --  Throughout this generic body, we distinguish between the cases where\n-   --  type Int32 is acceptable, where type Int64 is acceptable, and where\n-   --  type Int128 is needed. These boolean constants are used to test for\n-   --  these cases and since they are constant, only code for the relevant\n-   --  case will be really included in the instance.\n+   --  Throughout this generic body, we distinguish between the case where type\n+   --  Int32 is OK, where type Int64 is OK and where type Int128 is OK. These\n+   --  boolean constants are used to test for this, such that only code for the\n+   --  relevant case is included in the instance; that's why the computation of\n+   --  their value must be fully static (although it is not a static expression\n+   --  in the RM sense).\n+\n+   OK_Get_32 : constant Boolean :=\n+     Num'Object_Size <= 32\n+       and then\n+         ((Num'Small_Numerator = 1 and then Num'Small_Denominator <= 2**31)\n+           or else\n+          (Num'Small_Denominator = 1 and then Num'Small_Numerator <= 2**31)\n+           or else\n+          (Num'Small_Numerator <= 2**27\n+            and then Num'Small_Denominator <= 2**27));\n+   --  These conditions are derived from the prerequisites of System.Value_F\n+\n+   OK_Put_32 : constant Boolean :=\n+     Num'Object_Size <= 32\n+       and then\n+         ((Num'Small_Numerator = 1 and then Num'Small_Denominator <= 2**31)\n+           or else\n+          (Num'Small_Denominator = 1 and then Num'Small_Numerator <= 2**31)\n+           or else\n+          (Num'Small_Numerator < Num'Small_Denominator\n+            and then Num'Small_Denominator <= 2**27)\n+           or else\n+          (Num'Small_Denominator < Num'Small_Numerator\n+            and then Num'Small_Numerator <= 2**25));\n+   --  These conditions are derived from the prerequisites of System.Image_F\n+\n+   OK_Get_64 : constant Boolean :=\n+     Num'Object_Size <= 64\n+       and then\n+         ((Num'Small_Numerator = 1 and then Num'Small_Denominator <= 2**63)\n+           or else\n+          (Num'Small_Denominator = 1 and then Num'Small_Numerator <= 2**63)\n+           or else\n+          (Num'Small_Numerator <= 2**59\n+            and then Num'Small_Denominator <= 2**59));\n+   --  These conditions are derived from the prerequisites of System.Value_F\n+\n+   OK_Put_64 : constant Boolean :=\n+     Num'Object_Size <= 64\n+       and then\n+         ((Num'Small_Numerator = 1 and then Num'Small_Denominator <= 2**63)\n+           or else\n+          (Num'Small_Denominator = 1 and then Num'Small_Numerator <= 2**63)\n+           or else\n+          (Num'Small_Numerator < Num'Small_Denominator\n+            and then Num'Small_Denominator <= 2**59)\n+           or else\n+          (Num'Small_Denominator < Num'Small_Numerator\n+            and then Num'Small_Numerator <= 2**53));\n+   --  These conditions are derived from the prerequisites of System.Image_F\n+\n+   OK_Get_128 : constant Boolean :=\n+     Num'Object_Size <= 128\n+       and then\n+         ((Num'Small_Numerator = 1 and then Num'Small_Denominator <= 2**127)\n+           or else\n+          (Num'Small_Denominator = 1 and then Num'Small_Numerator <= 2**127)\n+           or else\n+          (Num'Small_Numerator <= 2**123\n+            and then Num'Small_Denominator <= 2**123));\n+   --  These conditions are derived from the prerequisites of System.Value_F\n+\n+   OK_Put_128 : constant Boolean :=\n+     Num'Object_Size <= 128\n+       and then\n+         ((Num'Small_Numerator = 1 and then Num'Small_Denominator <= 2**127)\n+           or else\n+          (Num'Small_Denominator = 1 and then Num'Small_Numerator <= 2**127)\n+           or else\n+          (Num'Small_Numerator < Num'Small_Denominator\n+            and then Num'Small_Denominator <= 2**123)\n+           or else\n+          (Num'Small_Denominator < Num'Small_Numerator\n+            and then Num'Small_Numerator <= 2**122));\n+   --  These conditions are derived from the prerequisites of System.Image_F\n \n    E : constant Natural :=\n-         31 + 32 * Boolean'Pos (Need_64) + 64 * Boolean'Pos (Need_128);\n+         127 - 64 * Boolean'Pos (OK_Put_64) - 32 * Boolean'Pos (OK_Put_32);\n    --  T'Size - 1 for the selected Int{32,64,128}\n \n    F0 : constant Natural := 0;\n@@ -123,23 +182,23 @@ package body Ada.Wide_Wide_Text_IO.Fixed_IO is\n       pragma Unsuppress (Range_Check);\n \n    begin\n-      if not Exact then\n-         Float_Aux.Get (File, Long_Long_Float (Item), Width);\n-      elsif Need_128 then\n+      if OK_Get_32 then\n          Item := Num'Fixed_Value\n-                   (Aux128.Get (File, Width,\n-                                Int128 (-Float'Ceiling (Num'Small)),\n-                                Int128 (-Float'Ceiling (1.0 / Num'Small))));\n-      elsif Need_64 then\n+                   (Aux32.Get (File, Width,\n+                               -Num'Small_Numerator,\n+                               -Num'Small_Denominator));\n+      elsif OK_Get_64 then\n          Item := Num'Fixed_Value\n                    (Aux64.Get (File, Width,\n-                               Int64 (-Float'Ceiling (Num'Small)),\n-                               Int64 (-Float'Ceiling (1.0 / Num'Small))));\n-      else\n+                               -Num'Small_Numerator,\n+                               -Num'Small_Denominator));\n+      elsif OK_Get_128 then\n          Item := Num'Fixed_Value\n-                   (Aux32.Get (File, Width,\n-                               Int32 (-Float'Ceiling (Num'Small)),\n-                               Int32 (-Float'Ceiling (1.0 / Num'Small))));\n+                   (Aux128.Get (File, Width,\n+                                -Num'Small_Numerator,\n+                                -Num'Small_Denominator));\n+      else\n+         Float_Aux.Get (File, Long_Long_Float (Item), Width);\n       end if;\n \n    exception\n@@ -168,23 +227,23 @@ package body Ada.Wide_Wide_Text_IO.Fixed_IO is\n       --  Aux.Gets will raise Data_Error in any case.\n \n    begin\n-      if not Exact then\n-         Float_Aux.Gets (S, Long_Long_Float (Item), Last);\n-      elsif Need_128 then\n+      if OK_Get_32 then\n          Item := Num'Fixed_Value\n-                   (Aux128.Gets (S, Last,\n-                                 Int128 (-Float'Ceiling (Num'Small)),\n-                                 Int128 (-Float'Ceiling (1.0 / Num'Small))));\n-      elsif Need_64 then\n+                   (Aux32.Gets (S, Last,\n+                                -Num'Small_Numerator,\n+                                -Num'Small_Denominator));\n+      elsif OK_Get_64 then\n          Item := Num'Fixed_Value\n                    (Aux64.Gets (S, Last,\n-                                Int64 (-Float'Ceiling (Num'Small)),\n-                                Int64 (-Float'Ceiling (1.0 / Num'Small))));\n-      else\n+                                -Num'Small_Numerator,\n+                                -Num'Small_Denominator));\n+      elsif OK_Get_128 then\n          Item := Num'Fixed_Value\n-                   (Aux32.Gets (S, Last,\n-                                Int32 (-Float'Ceiling (Num'Small)),\n-                                Int32 (-Float'Ceiling (1.0 / Num'Small))));\n+                   (Aux128.Gets (S, Last,\n+                                 -Num'Small_Numerator,\n+                                 -Num'Small_Denominator));\n+      else\n+         Float_Aux.Gets (S, Long_Long_Float (Item), Last);\n       end if;\n \n    exception\n@@ -203,23 +262,20 @@ package body Ada.Wide_Wide_Text_IO.Fixed_IO is\n       Exp  : Field := Default_Exp)\n    is\n    begin\n-      if not Exact then\n-         Float_Aux.Put (File, Long_Long_Float (Item), Fore, Aft, Exp);\n-      elsif Need_128 then\n-         Aux128.Put (File, Int128'Integer_Value (Item), Fore, Aft, Exp,\n-                     Int128 (-Float'Ceiling (Num'Small)),\n-                     Int128 (-Float'Ceiling (1.0 / Num'Small)),\n-                     For0, Num'Aft);\n-      elsif Need_64 then\n+      if OK_Put_32 then\n+         Aux32.Put (File, Int32'Integer_Value (Item), Fore, Aft, Exp,\n+                    -Num'Small_Numerator, -Num'Small_Denominator,\n+                    For0, Num'Aft);\n+      elsif OK_Put_64 then\n          Aux64.Put (File, Int64'Integer_Value (Item), Fore, Aft, Exp,\n-                    Int64 (-Float'Ceiling (Num'Small)),\n-                    Int64 (-Float'Ceiling (1.0 / Num'Small)),\n+                    -Num'Small_Numerator, -Num'Small_Denominator,\n                     For0, Num'Aft);\n+      elsif OK_Put_128 then\n+         Aux128.Put (File, Int128'Integer_Value (Item), Fore, Aft, Exp,\n+                     -Num'Small_Numerator, -Num'Small_Denominator,\n+                     For0, Num'Aft);\n       else\n-         Aux32.Put (File, Int32'Integer_Value (Item), Fore, Aft, Exp,\n-                    Int32 (-Float'Ceiling (Num'Small)),\n-                    Int32 (-Float'Ceiling (1.0 / Num'Small)),\n-                    For0, Num'Aft);\n+         Float_Aux.Put (File, Long_Long_Float (Item), Fore, Aft, Exp);\n       end if;\n    end Put;\n \n@@ -242,23 +298,20 @@ package body Ada.Wide_Wide_Text_IO.Fixed_IO is\n       S : String (To'First .. To'Last);\n \n    begin\n-      if not Exact then\n-         Float_Aux.Puts (S, Long_Long_Float (Item), Aft, Exp);\n-      elsif Need_128 then\n-         Aux128.Puts (S, Int128'Integer_Value (Item), Aft, Exp,\n-                      Int128 (-Float'Ceiling (Num'Small)),\n-                      Int128 (-Float'Ceiling (1.0 / Num'Small)),\n-                      For0, Num'Aft);\n-      elsif Need_64 then\n+      if OK_Put_32 then\n+         Aux32.Puts (S, Int32'Integer_Value (Item), Aft, Exp,\n+                     -Num'Small_Numerator, -Num'Small_Denominator,\n+                     For0, Num'Aft);\n+      elsif OK_Put_64 then\n          Aux64.Puts (S, Int64'Integer_Value (Item), Aft, Exp,\n-                     Int64 (-Float'Ceiling (Num'Small)),\n-                     Int64 (-Float'Ceiling (1.0 / Num'Small)),\n+                     -Num'Small_Numerator, -Num'Small_Denominator,\n                      For0, Num'Aft);\n+      elsif OK_Put_128 then\n+         Aux128.Puts (S, Int128'Integer_Value (Item), Aft, Exp,\n+                      -Num'Small_Numerator, -Num'Small_Denominator,\n+                      For0, Num'Aft);\n       else\n-         Aux32.Puts (S, Int32'Integer_Value (Item), Aft, Exp,\n-                     Int32 (-Float'Ceiling (Num'Small)),\n-                     Int32 (-Float'Ceiling (1.0 / Num'Small)),\n-                     For0, Num'Aft);\n+         Float_Aux.Puts (S, Long_Long_Float (Item), Aft, Exp);\n       end if;\n \n       for J in S'Range loop"}, {"sha": "aaa117f489bf0d56ae23408927512be5f4846c71", "filename": "gcc/ada/libgnat/s-fofi128.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Flibgnat%2Fs-fofi128.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Flibgnat%2Fs-fofi128.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-fofi128.ads?ref=2bf891fa752e18b872d6c06d541aed1ae0b94580", "patch": "@@ -43,7 +43,8 @@ package System.Fore_Fixed_128 is\n \n    package Impl is new Fore_F (Int128, Arith_128.Scaled_Divide128);\n \n-   function Fore_Fixed128 (Lo, Hi, Num, Den : Int128) return Natural\n+   function Fore_Fixed128\n+     (Lo, Hi, Num, Den : Int128; Scale : Integer) return Natural\n      renames Impl.Fore_Fixed;\n \n end System.Fore_Fixed_128;"}, {"sha": "cf94fb8ce7b616c083c94935377041613d73e7cb", "filename": "gcc/ada/libgnat/s-fofi32.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Flibgnat%2Fs-fofi32.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Flibgnat%2Fs-fofi32.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-fofi32.ads?ref=2bf891fa752e18b872d6c06d541aed1ae0b94580", "patch": "@@ -43,7 +43,8 @@ package System.Fore_Fixed_32 is\n \n    package Impl is new Fore_F (Int32, Arith_32.Scaled_Divide32);\n \n-   function Fore_Fixed32 (Lo, Hi, Num, Den : Int32) return Natural\n+   function Fore_Fixed32\n+     (Lo, Hi, Num, Den : Int32; Scale : Integer) return Natural\n      renames Impl.Fore_Fixed;\n \n end System.Fore_Fixed_32;"}, {"sha": "cdde2043ca4cb0868f63aca612f3a7bcc166e97b", "filename": "gcc/ada/libgnat/s-fofi64.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Flibgnat%2Fs-fofi64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Flibgnat%2Fs-fofi64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-fofi64.ads?ref=2bf891fa752e18b872d6c06d541aed1ae0b94580", "patch": "@@ -43,7 +43,8 @@ package System.Fore_Fixed_64 is\n \n    package Impl is new Fore_F (Int64, Arith_64.Scaled_Divide64);\n \n-   function Fore_Fixed64 (Lo, Hi, Num, Den : Int64) return Natural\n+   function Fore_Fixed64\n+     (Lo, Hi, Num, Den : Int64; Scale : Integer) return Natural\n      renames Impl.Fore_Fixed;\n \n end System.Fore_Fixed_64;"}, {"sha": "c9c476dfccaf946446bcae22715c36c78e172fda", "filename": "gcc/ada/libgnat/s-fore_f.adb", "status": "modified", "additions": 44, "deletions": 17, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Flibgnat%2Fs-fore_f.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Flibgnat%2Fs-fore_f.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-fore_f.adb?ref=2bf891fa752e18b872d6c06d541aed1ae0b94580", "patch": "@@ -39,16 +39,22 @@ package body System.Fore_F is\n    --  and has 19 digits, but the maximum number of 9's that can be represented\n    --  in Integer_64 is only 18.\n \n-   --  The prerequisite of the implementation is that the scaled divide does\n-   --  not overflow, which means that the absolute value of the bounds of\n+   --  The first prerequisite of the implementation is that the scaled divide\n+   --  does not overflow, which means that the absolute value of the bounds of\n    --  the subtype must be smaller than 10**Maxdigs * 2**(Int'Size - 1).\n    --  Otherwise Constraint_Error is raised by the scaled divide operation.\n \n+   --  The second prerequisite is that the computation of the operands does not\n+   --  overflow, which means that, if the small is larger than 1, it is either\n+   --  an integer or its numerator and denominator must be both smaller than\n+   --  the power 10**(Maxdigs - 1).\n+\n    ----------------\n    -- Fore_Fixed --\n    ----------------\n \n-   function Fore_Fixed (Lo, Hi, Num, Den : Int) return Natural is\n+   function Fore_Fixed (Lo, Hi, Num, Den : Int; Scale : Integer) return Natural\n+   is\n       pragma Assert (Num < 0 and then Den < 0);\n       --  Accept only negative numbers to allow -2**(Int'Size - 1)\n \n@@ -59,39 +65,60 @@ package body System.Fore_F is\n       T : Int := Int'Min (Negative_Abs (Lo), Negative_Abs (Hi));\n       F : Natural;\n \n+      Q, R : Int;\n+\n    begin\n       --  Initial value of 2 allows for sign and mandatory single digit\n \n       F := 2;\n \n-      --  If the Small is 1, then no scaling is needed\n+      --  The easy case is when Num is not larger than Den in magnitude,\n+      --  i.e. if S = Num / Den, then S <= 1, in which case we can just\n+      --  compute the product Q = T * S.\n+\n+      if Num >= Den then\n+         Scaled_Divide (T, Num, Den, Q, R, Round => False);\n+         T := Q;\n+\n+      --  Otherwise S > 1 and thus Scale <= 0, compute Q and R such that\n+\n+      --    T * Num = Q * (Den * 10**(-D)) + R\n \n-      if Num = -1 and then Den = -1 then\n-         null;\n+      --  with\n \n-      --  The easy case is when the Small is the reciprocal of an integer\n+      --    D = Integer'Max (-Maxdigs, Scale - 1)\n \n-      elsif Num = -1 then\n-         T := T / Den;\n+      --  then reason on Q if it is non-zero or else on R / Den.\n \n-      --  If the Small is an integer, compute Q and R such that\n+      --  This works only if Den * 10**(-D) does not overflow, which is true\n+      --  if Den = 1. Suppose that Num corresponds to the maximum value of -D,\n+      --  i.e. Maxdigs and 10**(-D) = 10**Maxdigs. If you change Den into 10,\n+      --  then S becomes 10 times smaller and, therefore, Scale is incremented\n+      --  by 1, which means that -D is decremented by 1 provided that Scale was\n+      --  initially not smaller than 1 - Maxdigs, so the multiplication still\n+      --  does not overflow. But you need to reach 10 to trigger this effect,\n+      --  which means that a leeway of 10 is required, so let's restrict this\n+      --  to a Num for which 10**(-D) <= 10**(Maxdigs - 1). To sum up, if S is\n+      --  the ratio of two integers with\n \n-      --    T * Small = Q * 10**Maxdigs - R\n+      --    1 < Den < Num <= B\n \n-      --  then reason on Q if it is non-zero or else on R.\n+      --  where B is a fixed limit, then the multiplication does not overflow.\n+      --  B can be taken as the largest integer Small such that D = 1 - Maxdigs\n+      --  i.e. such that Scale = 2 - Maxdigs, which is 10**(Maxdigs - 1) - 1.\n \n-      else pragma Assert (Den = -1);\n+      else\n          declare\n-            Q, R : Int;\n+            D : constant Integer := Integer'Max (-Maxdigs, Scale - 1);\n \n          begin\n-            Scaled_Divide (T, Num, -10**Maxdigs, Q, R, Round => False);\n+            Scaled_Divide (T, Num, Den * 10**(-D), Q, R, Round => False);\n \n             if Q /= 0 then\n                T := Q;\n-               F := F + Maxdigs;\n+               F := F - D;\n             else\n-               T := R;\n+               T := R / Den;\n             end if;\n          end;\n       end if;"}, {"sha": "cf6d983d20ae130fa0aca624f6ff342aa9fb7c03", "filename": "gcc/ada/libgnat/s-fore_f.ads", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Flibgnat%2Fs-fore_f.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Flibgnat%2Fs-fore_f.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-fore_f.ads?ref=2bf891fa752e18b872d6c06d541aed1ae0b94580", "patch": "@@ -30,7 +30,7 @@\n ------------------------------------------------------------------------------\n \n --  This package contains the routine used for the Fore attribute of ordinary\n---  fixed point types whose Small is an integer or its reciprocal.\n+--  fixed point types whose Small is the ratio of two Int values.\n \n generic\n \n@@ -44,8 +44,11 @@ generic\n package System.Fore_F is\n    pragma Pure;\n \n-   function Fore_Fixed (Lo, Hi, Num, Den : Int) return Natural;\n-   --  Compute Fore attribute value for an ordinary fixed point type with small\n-   --  Num/Den. The parameters are the low and high bounds (in units of small).\n+   function Fore_Fixed\n+     (Lo, Hi, Num, Den : Int; Scale : Integer) return Natural;\n+   --  Compute Fore attribute value for an ordinary fixed point type. The\n+   --  parameters are the low and high bounds (in units of small), the small\n+   --  Num/Den and the associated scale, which is the smallest integer N such\n+   --  that 10**N * (Num/Den) is greater or equal to 1, if it is nonpositive.\n \n end System.Fore_F;"}, {"sha": "94a7a2f8ac351a9f3f7fa8a331975f06a1460447", "filename": "gcc/ada/libgnat/s-imagef.adb", "status": "modified", "additions": 75, "deletions": 17, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Flibgnat%2Fs-imagef.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Flibgnat%2Fs-imagef.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imagef.adb?ref=2bf891fa752e18b872d6c06d541aed1ae0b94580", "patch": "@@ -34,6 +34,26 @@ with System.Img_Util; use System.Img_Util;\n \n package body System.Image_F is\n \n+   Maxdigs : constant Natural := Int'Width - 2;\n+   --  Maximum number of decimal digits that can be represented in an Int.\n+   --  The \"-2\" accounts for the sign and one extra digit, since we need the\n+   --  maximum number of 9's that can be represented, e.g. for the 64-bit case,\n+   --  Integer_64'Width is 20 since the maximum value is approximately 9.2E+18\n+   --  and has 19 digits, but the maximum number of 9's that can be represented\n+   --  in Integer_64 is only 18.\n+\n+   --  The first prerequisite of the implementation is that the first scaled\n+   --  divide does not overflow, which means that the absolute value of the\n+   --  input X must always be smaller than 10**Maxdigs * 2**(Int'Size - 1).\n+   --  Otherwise Constraint_Error is raised by the scaled divide operation.\n+\n+   --  The second prerequisite of the implementation is that the computation\n+   --  of the operands does not overflow when the small is neither an integer\n+   --  nor the reciprocal of an integer, which means that its numerator and\n+   --  denominator must be smaller than 10**(2*Maxdigs-1) / 2**(Int'Size - 1)\n+   --  if the small is larger than 1, and smaller than 2**(Int'Size - 1) / 10\n+   --  if the small is smaller than 1.\n+\n    package Image_I is new System.Image_I (Int);\n \n    procedure Set_Image_Integer\n@@ -113,6 +133,61 @@ package body System.Image_F is\n    --  in the denominator for the extra decimal scaling required, so case (3)\n    --  will not overflow.\n \n+   --  In fact this reasoning can be generalized to most S which are the ratio\n+   --  of two integers with bounded magnitude. Let S = Num / Den and rewrite\n+   --  case (1) above where Den = 1 into\n+\n+   --    (1b)   Y = -Num and Z = -Den * 10**(-D)\n+\n+   --  Suppose that Num corresponds to the maximum value of -D, i.e. 18 and\n+   --  10**(-D) = 10**18. If you change Den into 10, then S becomes 10 times\n+   --  smaller and, therefore, Fore is decremented by 1, which means that -D\n+   --  is as well, provided that Fore was initially not larger than 37, so the\n+   --  multiplication for Z still does not overflow. But you need to reach 10\n+   --  to trigger this effect, which means that a leeway of 10 is required, so\n+   --  let's restrict this to a Num for which 10**(-D) <= 10**17. To summarize\n+   --  this case, if S is the ratio of two integers with\n+\n+   --    Den < Num <= B1\n+\n+   --  where B1 is a fixed limit, then case (1b) does not overflow. B1 can be\n+   --  taken as the largest integer Small such that D = -17, i.e. Fore = 36,\n+   --  which means that B1 * 2.0**63 must be smaller than 10**35.\n+\n+   --  Let's continue and rewrite case (2) above when Num = 1 into\n+\n+   --    (2b)   Y = -Num * 10**D and Z = -Den, for D >= 0\n+\n+   --  Note that D <= 18 - (Fore - 1) and Fore >= 2 so D <= 17, thus you can\n+   --  safely change Num into 10 in the product, but then S becomes 10 times\n+   --  larger and, therefore, Fore is incremented by 1, which means that D is\n+   --  decremented by 1 so you again have a product lesser or equal to 10**17.\n+   --  To sum up, if S is the ratio of two integers with\n+\n+   --    Num <= Den * S0\n+\n+   --  where S0 is the largest Small such that D >= 0, then case (2b) does not\n+   --  overflow.\n+\n+   --  Let's conclude and rewrite case (3) above when Num = 1 into\n+\n+   --    (3b)   Y = -Num and Z = -Den * 10**(-D), for D < 0\n+\n+   --  As explained above, this occurs only if both S0 < S < 1 and D = -1 and\n+   --  is preserved if you scale up Num and Den simultaneously, what you can\n+   --  do until Den * 10 tops the upper bound. To sum up, if S is the ratio of\n+   --  two integers with\n+\n+   --    Den * S0 < Num < Den <= B2\n+\n+   --  where B2 is a fixed limit, then case (3b) does not overflow. B2 can be\n+   --  taken as the largest integer such that B2 * 10 is smaller than 2.0**63.\n+\n+   --  The conclusion is that the algorithm works if the small is the ratio of\n+   --  two integers in the range 1 .. 2**63 if either is equal to 1, or of two\n+   --  integers in the range 1 .. B1 if the small is larger than 1, or of two\n+   --  integers in the range 1 .. B2 if the small is smaller than 1.\n+\n    --  Using a scaled divide which truncates and returns a remainder R,\n    --  another K trailing digits can be calculated by computing the value\n    --  (R * (10.0**K)) / Z using another scaled divide. This procedure\n@@ -121,19 +196,6 @@ package body System.Image_F is\n    --  a possible carry propagating to the more significant digits, to\n    --  ensure correct rounding of the unit in the last place.\n \n-   Maxdigs : constant Natural := Int'Width - 2;\n-   --  Maximum number of decimal digits that can be represented in an Int.\n-   --  The \"-2\" accounts for the sign and one extra digit, since we need the\n-   --  maximum number of 9's that can be represented, e.g. for the 64-bit case,\n-   --  Integer_64'Width is 20 since the maximum value is approximately 9.2E+18\n-   --  and has 19 digits, but the maximum number of 9's that can be represented\n-   --  in Integer_64 is only 18.\n-\n-   --  The prerequisite of the implementation is that the first scaled divide\n-   --  does not overflow, which means that the absolute value of the input X\n-   --  must always be smaller than 10**Maxdigs * 2**(Int'Size - 1). Otherwise\n-   --  Constraint_Error is raised by the scaled divide operation.\n-\n    -----------------\n    -- Image_Fixed --\n    -----------------\n@@ -181,10 +243,6 @@ package body System.Image_F is\n       pragma Assert (Num < 0 and then Den < 0);\n       --  Accept only negative numbers to allow -2**(Int'Size - 1)\n \n-      pragma Assert (Num = -1 or else Den = -1);\n-      --  Accept only integer or reciprocal of integer to control the\n-      --  magnitude of the arithmetic operations below.\n-\n       A : constant Natural :=\n             Boolean'Pos (Exp > 0) * Aft0 + Natural'Max (Aft, 1) + 1;\n       --  Number of digits after the decimal point to be computed. If Exp is"}, {"sha": "ace7e6b31bdebc01a6ce352386261d2dbab3b6ce", "filename": "gcc/ada/libgnat/s-imagef.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Flibgnat%2Fs-imagef.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Flibgnat%2Fs-imagef.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imagef.ads?ref=2bf891fa752e18b872d6c06d541aed1ae0b94580", "patch": "@@ -30,9 +30,8 @@\n ------------------------------------------------------------------------------\n \n --  This package contains the routines for supporting the Image attribute for\n---  ordinary fixed point types whose Small is an integer or its reciprocal,\n---  and also for conversion operations required in Text_IO.Fixed_IO for such\n---  types.\n+--  ordinary fixed point types whose Small is the ratio of two Int values, and\n+--  also for conversion operations required in Text_IO.Fixed_IO for such types.\n \n generic\n "}, {"sha": "9a54cf368722878d053e742cc35d47d26a9624ce", "filename": "gcc/ada/libgnat/s-valuef.adb", "status": "modified", "additions": 49, "deletions": 4, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Flibgnat%2Fs-valuef.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Flibgnat%2Fs-valuef.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuef.adb?ref=2bf891fa752e18b872d6c06d541aed1ae0b94580", "patch": "@@ -35,6 +35,14 @@ with System.Value_R;\n \n package body System.Value_F is\n \n+   --  The prerequisite of the implementation is that the computation of the\n+   --  operands of the scaled divide does not unduly overflow when the small\n+   --  is neither an integer nor the reciprocal of an integer, which means\n+   --  that its numerator and denominator must be both not larger than the\n+   --  smallest divide 2**(Int'Size - 1) / Base where Base ranges over the\n+   --  supported values for the base of the literal. Given that the largest\n+   --  supported base is 16, this gives a limit of 2**(Int'Size - 5).\n+\n    package Impl is new Value_R (Uns, Floating => False);\n \n    function Integer_To_Fixed\n@@ -73,18 +81,55 @@ package body System.Value_F is\n \n    --    V = (Val * Base + Extra) * (Base ** (ScaleB - 1)) / (Num / Den)\n \n-   --  using two steps of scaled divide if Extra is non-zero\n+   --  using two steps of scaled divide if Extra is positive and ScaleB too\n \n-   --    (1)  Val * ((Base ** ScaleB) * Den) = Q1 * Num + R1\n+   --    (1)  Val * (Den * (Base ** ScaleB)) = Q1 * Num + R1\n \n-   --    (2)  Extra * ((Base ** ScaleB) * Den) = Q2 * (-Base) + R2\n+   --    (2)  Extra * (Den * (Base ** ScaleB)) = Q2 * -Base + R2\n \n    --  which yields after dividing (1) by Num and (2) by Num * Base and summing\n \n    --    V = Q1 + (R1 - Q2) / Num + R2 / (Num * Base)\n \n    --  but we get rid of the third term by using a rounding divide for (2).\n \n+   --  This works only if Den * (Base ** ScaleB) does not overflow for inputs\n+   --  corresponding to 'Image. Let S = Num / Den, B = Base and N the scale in\n+   --  base B of S, i.e. the smallest integer such that B**N * S >= 1. Then,\n+   --  for X a positive of the mantissa, i.e. 1 <= X <= 2**(M-1), we have\n+\n+   --    1/B <= X * S * B**(N-1) < 2**(M-1)\n+\n+   --  which means that the inputs corresponding to the output of 'Image have a\n+   --  ScaleB equal either to 1 - N or (after multiplying the inequality by B)\n+   --  to -N, possibly after renormalizing X, i.e. multiplying it by a suitable\n+   --  power of B. Therefore\n+\n+   --    Den * (Base ** ScaleB) <= Den * (B ** (1 - N)) < Num * B\n+\n+   --  which means that the product does not overflow if Num <= 2**(M-1) / B.\n+\n+   --  On the other hand, if Extra is positive and ScaleB negative, the above\n+   --  two steps are\n+\n+   --   (1b)  Val * Den = Q1 * (Num * (Base ** -ScaleB)) + R1\n+\n+   --   (2b)  Extra * Den = Q2 * -Base + R2\n+\n+   --  which yields after dividing (1b) by Num * (Base ** -ScaleB) and (2b) by\n+   --  Num * (Base ** (1 - ScaleB)) and summing\n+\n+   --    V = Q1 + (R1 - Q2) / (Num * (Base ** -ScaleB)) + R2 / ...\n+\n+   --  but we get rid of the third term by using a rounding divide for (2b).\n+\n+   --  This works only if Num * (Base ** -ScaleB) does not overflow for inputs\n+   --  corresponding to 'Image. With the determination of ScaleB above, we have\n+\n+   --    Num * (Base ** -ScaleB) <= Num * (B ** N) < Den * B\n+\n+   --  which means that the product does not overflow if Den <= 2**(M-1) / B.\n+\n    ----------------------\n    -- Integer_To_Fixed --\n    ----------------------\n@@ -234,7 +279,7 @@ package body System.Value_F is\n       --  third operands are always negative so the sign of the quotient is the\n       --  sign of the first operand and the sign of the remainder the opposite.\n \n-      if E /= 0 then\n+      if E > 0 then\n          Scaled_Divide (Unsigned_To_Signed (V), Y, Z, Q1, R1, Round => False);\n          Scaled_Divide (Unsigned_To_Signed (E), Y, -B, Q2, R2, Round => True);\n "}, {"sha": "abd4817c8bcbd819f6f3ebf37e4c9f1cebfbd78b", "filename": "gcc/ada/libgnat/s-valuef.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Flibgnat%2Fs-valuef.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Flibgnat%2Fs-valuef.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuef.ads?ref=2bf891fa752e18b872d6c06d541aed1ae0b94580", "patch": "@@ -30,8 +30,8 @@\n ------------------------------------------------------------------------------\n \n --  This package contains the routines for supporting the Value attribute for\n---  ordinary fixed point types, and also for conversion operations required in\n---  Text_IO.Fixed_IO for such types.\n+--  ordinary fixed point types whose Small is the ratio of two Int values, and\n+--  also for conversion operations required in Text_IO.Fixed_IO for such types.\n \n generic\n "}, {"sha": "504ca9738f75ce5ff6b8f2c66b0de7ad4cdc6c60", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=2bf891fa752e18b872d6c06d541aed1ae0b94580", "patch": "@@ -6064,6 +6064,17 @@ package body Sem_Attr is\n          Check_Real_Type;\n          Set_Etype (N, Universal_Real);\n \n+      ---------------------------------------\n+      -- Small_Denominator/Small_Numerator --\n+      ---------------------------------------\n+\n+      when Attribute_Small_Denominator\n+         | Attribute_Small_Numerator\n+      =>\n+         Check_E0;\n+         Check_Fixed_Point_Type;\n+         Set_Etype (N, Universal_Integer);\n+\n       ------------------\n       -- Storage_Pool --\n       ------------------\n@@ -9905,6 +9916,20 @@ package body Sem_Attr is\n             Fold_Ureal (N, Small_Value (P_Type), True);\n          end if;\n \n+      -----------------------\n+      -- Small_Denominator --\n+      -----------------------\n+\n+      when Attribute_Small_Denominator =>\n+         Fold_Uint (N, Norm_Den (Small_Value (P_Type)), True);\n+\n+      ---------------------\n+      -- Small_Numerator --\n+      ---------------------\n+\n+      when Attribute_Small_Numerator =>\n+         Fold_Uint (N, Norm_Num (Small_Value (P_Type)), True);\n+\n       -----------------\n       -- Stream_Size --\n       -----------------"}, {"sha": "647fb62f589bf6db0a088009cf0e2e36cee1ab23", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf891fa752e18b872d6c06d541aed1ae0b94580/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=2bf891fa752e18b872d6c06d541aed1ae0b94580", "patch": "@@ -1024,6 +1024,8 @@ package Snames is\n    Name_Signed_Zeros                   : constant Name_Id := N + $;\n    Name_Size                           : constant Name_Id := N + $;\n    Name_Small                          : constant Name_Id := N + $; -- Ada 83\n+   Name_Small_Denominator              : constant Name_Id := N + $; -- GNAT\n+   Name_Small_Numerator                : constant Name_Id := N + $; -- GNAT\n    Name_Storage_Size                   : constant Name_Id := N + $;\n    Name_Storage_Unit                   : constant Name_Id := N + $; -- GNAT\n    Name_Stream_Size                    : constant Name_Id := N + $; -- Ada 05\n@@ -1551,6 +1553,8 @@ package Snames is\n       Attribute_Signed_Zeros,\n       Attribute_Size,\n       Attribute_Small,\n+      Attribute_Small_Denominator,\n+      Attribute_Small_Numerator,\n       Attribute_Storage_Size,\n       Attribute_Storage_Unit,\n       Attribute_Stream_Size,"}]}