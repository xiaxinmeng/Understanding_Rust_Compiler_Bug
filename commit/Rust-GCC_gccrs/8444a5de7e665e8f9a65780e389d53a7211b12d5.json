{"sha": "8444a5de7e665e8f9a65780e389d53a7211b12d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ0NGE1ZGU3ZTY2NWU4ZjlhNjU3ODBlMzg5ZDUzYTcyMTFiMTJkNQ==", "commit": {"author": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2007-01-08T21:04:26Z"}, "committer": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2007-01-08T21:04:26Z"}, "message": "overflow-warn-1.C: Fix testcase.\n\n2007-01-08  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n\ntestsuite/\n\t* g++.dg/warn/overflow-warn-1.C: Fix testcase.\n\t* g++.dg/warn/overflow-warn-3.C: Likewise.\n\t* g++.dg/warn/overflow-warn-4.C: Likewise.\n\t* g++.dg/warn/overflow-warn-5.C: Likewise.\n\t* g++.dg/warn/overflow-warn-6.C: Likewise.\n\t* g++.dg/warn/Woverflow-1.C: Likewise.\n\t* g++.dg/warn/Woverflow-2.C: Likewise.\n\t* g++.dg/warn/Woverflow-3.C: Likewise.\n\t* g++.dg/warn/multiple-overflow-warn-2.C: Likewise.\n\nFrom-SVN: r120588", "tree": {"sha": "f4d638d23e3100f66333b19596d6f9e0226e0bb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4d638d23e3100f66333b19596d6f9e0226e0bb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8444a5de7e665e8f9a65780e389d53a7211b12d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8444a5de7e665e8f9a65780e389d53a7211b12d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8444a5de7e665e8f9a65780e389d53a7211b12d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8444a5de7e665e8f9a65780e389d53a7211b12d5/comments", "author": null, "committer": null, "parents": [{"sha": "b251af97928db06c0a2174b230a3ae9f83745a04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b251af97928db06c0a2174b230a3ae9f83745a04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b251af97928db06c0a2174b230a3ae9f83745a04"}], "stats": {"total": 889, "additions": 12, "deletions": 877}, "files": [{"sha": "af17631dbb32cacd25f67cafc68fcc4644e40cdd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8444a5de7e665e8f9a65780e389d53a7211b12d5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8444a5de7e665e8f9a65780e389d53a7211b12d5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8444a5de7e665e8f9a65780e389d53a7211b12d5", "patch": "@@ -1,3 +1,15 @@\n+2007-01-08  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n+\n+\t* g++.dg/warn/overflow-warn-1.C: Fix testcase.\n+\t* g++.dg/warn/overflow-warn-3.C: Likewise.\n+\t* g++.dg/warn/overflow-warn-4.C: Likewise.\n+\t* g++.dg/warn/overflow-warn-5.C: Likewise.\n+\t* g++.dg/warn/overflow-warn-6.C: Likewise.\n+\t* g++.dg/warn/Woverflow-1.C: Likewise.\n+\t* g++.dg/warn/Woverflow-2.C: Likewise.\n+\t* g++.dg/warn/Woverflow-3.C: Likewise.\n+\t* g++.dg/warn/multiple-overflow-warn-2.C: Likewise.\n+\n 2007-01-08  Roger Sayle  <roger@eyesopen.com>\n \n \t* gfortran.dg/array_constructor_14.f90: New test case."}, {"sha": "064af4561eaa6a710043afdcefd01d1a464b3eda", "filename": "gcc/testsuite/g++.dg/warn/Woverflow-1.C", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8444a5de7e665e8f9a65780e389d53a7211b12d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWoverflow-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8444a5de7e665e8f9a65780e389d53a7211b12d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWoverflow-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWoverflow-1.C?ref=8444a5de7e665e8f9a65780e389d53a7211b12d5", "patch": "@@ -5,17 +5,3 @@\n \n int foo = INT_MAX + 1;  /* { dg-warning \"integer overflow\" } */\n \n-/* { dg-do compile } */\n-/* { dg-options \"-O2\" } */\n-\n-#include <limits.h>\n-\n-int foo = INT_MAX + 1;  /* { dg-warning \"integer overflow\" } */\n-\n-/* { dg-do compile } */\n-/* { dg-options \"-O2\" } */\n-\n-#include <limits.h>\n-\n-int foo = INT_MAX + 1;  /* { dg-warning \"integer overflow\" } */\n-"}, {"sha": "44368b66f9f739daf2b19f0ff847b98caa9bde4a", "filename": "gcc/testsuite/g++.dg/warn/Woverflow-2.C", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8444a5de7e665e8f9a65780e389d53a7211b12d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWoverflow-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8444a5de7e665e8f9a65780e389d53a7211b12d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWoverflow-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWoverflow-2.C?ref=8444a5de7e665e8f9a65780e389d53a7211b12d5", "patch": "@@ -5,17 +5,3 @@\n \n int foo = INT_MAX + 1;  /* { dg-warning \"integer overflow\" } */\n \n-/* { dg-do compile } */\n-/* { dg-options \"-O2 -Woverflow\" } */\n-\n-#include <limits.h>\n-\n-int foo = INT_MAX + 1;  /* { dg-warning \"integer overflow\" } */\n-\n-/* { dg-do compile } */\n-/* { dg-options \"-O2 -Woverflow\" } */\n-\n-#include <limits.h>\n-\n-int foo = INT_MAX + 1;  /* { dg-warning \"integer overflow\" } */\n-"}, {"sha": "73a021b59460a4a7da0c96ba7b9d269f926b6ac5", "filename": "gcc/testsuite/g++.dg/warn/Woverflow-3.C", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8444a5de7e665e8f9a65780e389d53a7211b12d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWoverflow-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8444a5de7e665e8f9a65780e389d53a7211b12d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWoverflow-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWoverflow-3.C?ref=8444a5de7e665e8f9a65780e389d53a7211b12d5", "patch": "@@ -5,17 +5,3 @@\n \n int foo = INT_MAX + 1;\n \n-/* { dg-do compile } */\n-/* { dg-options \"-O2 -Wno-overflow\" } */\n-\n-#include <limits.h>\n-\n-int foo = INT_MAX + 1;\n-\n-/* { dg-do compile } */\n-/* { dg-options \"-O2 -Wno-overflow\" } */\n-\n-#include <limits.h>\n-\n-int foo = INT_MAX + 1;\n-"}, {"sha": "863016bfd68fc20421043ed81c418f303a5aeaf3", "filename": "gcc/testsuite/g++.dg/warn/multiple-overflow-warn-2.C", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8444a5de7e665e8f9a65780e389d53a7211b12d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fmultiple-overflow-warn-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8444a5de7e665e8f9a65780e389d53a7211b12d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fmultiple-overflow-warn-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fmultiple-overflow-warn-2.C?ref=8444a5de7e665e8f9a65780e389d53a7211b12d5", "patch": "@@ -10,27 +10,3 @@ g1 (void)\n   return INT_MAX + 1 - INT_MAX; /* { dg-bogus \"integer overflow in expression.*integer overflow in expression\" } */\n   /* { dg-warning \"integer overflow in expression\" \"\" { target *-*-* } 10 } */\n }\n-/* PR c/19978 : Test for duplicated warnings (binary operators).  */\n-/* { dg-do compile } */\n-/* { dg-options \"-Woverflow\" } */\n-\n-#include <limits.h>\n-\n-int \n-g1 (void)\n-{\n-  return INT_MAX + 1 - INT_MAX; /* { dg-bogus \"integer overflow in expression.*integer overflow in expression\" } */\n-  /* { dg-warning \"integer overflow in expression\" \"\" { target *-*-* } 10 } */\n-}\n-/* PR c/19978 : Test for duplicated warnings (binary operators).  */\n-/* { dg-do compile } */\n-/* { dg-options \"-Woverflow\" } */\n-\n-#include <limits.h>\n-\n-int \n-g1 (void)\n-{\n-  return INT_MAX + 1 - INT_MAX; /* { dg-bogus \"integer overflow in expression.*integer overflow in expression\" } */\n-  /* { dg-warning \"integer overflow in expression\" \"\" { target *-*-* } 10 } */\n-}"}, {"sha": "1c6c849990b505375bc6e61c0c66f9683274f548", "filename": "gcc/testsuite/g++.dg/warn/overflow-warn-1.C", "status": "modified", "additions": 0, "deletions": 245, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8444a5de7e665e8f9a65780e389d53a7211b12d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8444a5de7e665e8f9a65780e389d53a7211b12d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-1.C?ref=8444a5de7e665e8f9a65780e389d53a7211b12d5", "patch": "@@ -43,251 +43,6 @@ f (void)\n static int sc = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n \n \n-// Test for overflow in null pointer constant.  \n-void *n = 0;\n-/* The first two of these involve overflow, so are not null pointer\n-   constants.  The third has the overflow in an unevaluated\n-   subexpression, so is a null pointer constant.  */\n-void *p = 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n-/* { dg-error \"invalid conversion from 'int' to 'void\" \"null\" { target *-*-* } 51 } */\n-void *q = 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n-/* { dg-error \"invalid conversion from 'int' to 'void*'\" \"null\" { xfail *-*-* } 53 } */\n-void *r = (1 ? 0 : INT_MAX+1); /* { dg-bogus \"integer overflow in expression\" \"\" { xfail *-*-* } 55 } */\n-\n-void\n-g (int i)\n-{\n-  switch (i)\n-    {\n-    case 0 * (1/0): /* { dg-warning \"warning: division by zero\" } */\n-      ;\n-    case 1 + 0 * (INT_MAX + 1): /* { dg-warning \"warning: integer overflow in expression\" } */\n-      ;\n-    }\n-}\n-\n-int\n-h (void)\n-{\n-  return INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n-}\n-\n-int\n-h1 (void)\n-{\n-  return INT_MAX + 1 - INT_MAX; /* { dg-warning \"warning: integer overflow in expression\" } */\n-}\n-\n-void fuc (unsigned char);\n-void fsc (signed char);\n-\n-void\n-h2 (void)\n-{\n-  fsc (SCHAR_MAX + 1);\n-  fsc (SCHAR_MIN - 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n-  fsc (UCHAR_MAX);\n-  fsc (UCHAR_MAX + 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n-  fuc (-1);\n-  fuc (UCHAR_MAX + 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n-  fuc (SCHAR_MIN);\n-  fuc (SCHAR_MIN - 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n-  fuc (-UCHAR_MAX); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n-}\n-\n-void fui (unsigned int);\n-void fsi (signed int);\n-\n-int si;\n-unsigned ui;\n-\n-void\n-h2i (int x)\n-{\n-  /* For some reason, we only give certain warnings for implicit\n-     conversions among values of the same precision with -Wconversion,\n-     while we don't give others at all.  */\n-  fsi ((unsigned)INT_MAX + 1);\n-  si = (unsigned)INT_MAX + 1;\n-  si = x ? (unsigned)INT_MAX + 1 : 1;\n-  fsi ((unsigned)INT_MAX + 2);\n-  si = (unsigned)INT_MAX + 2;\n-  si = x ? (unsigned)INT_MAX + 2 : 1;\n-  fsi (UINT_MAX);\n-  si = UINT_MAX;\n-  fui (-1);\n-  ui = -1;\n-  ui = x ? -1 : 1U;\n-  fui (INT_MIN);\n-  ui = INT_MIN;\n-  ui = x ? INT_MIN : 1U;\n-}\n-/* Test for diagnostics for constant overflow.  */\n-/* Origin: Joseph Myers <joseph@codesourcery.com> */\n-/* { dg-do compile } */\n-/* { dg-options \"\" } */\n-\n-#include <limits.h>\n-\n-enum e {\n-  E0 = INT_MAX,\n-  /* Unsigned overflow wraps around.  */\n-  E1 = UINT_MAX + 1,\n-  /* Overflow in an unevaluated part of an expression is OK (example\n-     in the standard).  */\n-  E2 = 2 || 1 / 0, /* { dg-bogus \"warning: division by zero\" \"\" { xfail *-*-* } 14 } */\n-  E3 = 1 / 0, /* { dg-warning \"warning: division by zero\" } */\n-  /* { dg-error \"error: enumerator value for 'E3' is not an integer constant\" \"enum error\" { target *-*-* } 15 } */\n-  /* But as in DR#031, the 1/0 in an evaluated subexpression means the\n-     whole expression violates the constraints.  */\n-  E4 = 0 * (1 / 0), /* { dg-warning \"warning: division by zero\" } */\n-  /* { dg-error \"error: enumerator value for 'E4' is not an integer constant\" \"enum error\" { xfail *-*-* } 19 } */\n-  E5 = INT_MAX + 1, /* { dg-warning \"warning: integer overflow in expression\" } */\n-  /* Again, overflow in evaluated subexpression.  */\n-  E6 = 0 * (INT_MAX + 1), /* { dg-warning \"warning: integer overflow in expression\" } */\n-  /* A cast does not constitute overflow in conversion.  */\n-  E7 = (char) INT_MAX\n-};\n-\n-struct s {\n-  int a;\n-  int : 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n-  int : 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n-};\n-\n-void\n-f (void)\n-{\n-  /* This expression is not required to be a constant expression, so\n-     it should just involve undefined behavior at runtime.  */\n-  int c = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n-}\n-\n-/* But this expression does need to be constant.  */\n-static int sc = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n-\n-/* The first two of these involve overflow, so are not null pointer\n-   constants.  The third has the overflow in an unevaluated\n-   subexpression, so is a null pointer constant.  */\n-void *p = 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n-/* { dg-error \"invalid conversion from 'int' to 'void\" \"null\" { target *-*-* } 48 } */\n-void *q = 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n-/* { dg-error \"invalid conversion from 'int' to 'void*'\" \"null\" { xfail *-*-* } 50 } */\n-void *r = (1 ? 0 : INT_MAX+1); /* { dg-bogus \"integer overflow in expression\" \"\" { xfail *-*-* } 52 } */\n-\n-void\n-g (int i)\n-{\n-  switch (i)\n-    {\n-    case 0 * (1/0): /* { dg-warning \"warning: division by zero\" } */\n-      ;\n-    case 1 + 0 * (INT_MAX + 1): /* { dg-warning \"warning: integer overflow in expression\" } */\n-      ;\n-    }\n-}\n-\n-int\n-h (void)\n-{\n-  return INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n-}\n-\n-int\n-h1 (void)\n-{\n-  return INT_MAX + 1 - INT_MAX; /* { dg-warning \"warning: integer overflow in expression\" } */\n-}\n-\n-void fuc (unsigned char);\n-void fsc (signed char);\n-\n-void\n-h2 (void)\n-{\n-  fsc (SCHAR_MAX + 1);\n-  fsc (SCHAR_MIN - 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n-  fsc (UCHAR_MAX);\n-  fsc (UCHAR_MAX + 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n-  fuc (-1);\n-  fuc (UCHAR_MAX + 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n-  fuc (SCHAR_MIN);\n-  fuc (SCHAR_MIN - 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n-  fuc (-UCHAR_MAX); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n-}\n-\n-void fui (unsigned int);\n-void fsi (signed int);\n-\n-int si;\n-unsigned ui;\n-\n-void\n-h2i (int x)\n-{\n-  /* For some reason, we only give certain warnings for implicit\n-     conversions among values of the same precision with -Wconversion,\n-     while we don't give others at all.  */\n-  fsi ((unsigned)INT_MAX + 1);\n-  si = (unsigned)INT_MAX + 1;\n-  si = x ? (unsigned)INT_MAX + 1 : 1;\n-  fsi ((unsigned)INT_MAX + 2);\n-  si = (unsigned)INT_MAX + 2;\n-  si = x ? (unsigned)INT_MAX + 2 : 1;\n-  fsi (UINT_MAX);\n-  si = UINT_MAX;\n-  fui (-1);\n-  ui = -1;\n-  ui = x ? -1 : 1U;\n-  fui (INT_MIN);\n-  ui = INT_MIN;\n-  ui = x ? INT_MIN : 1U;\n-}\n-/* Test for diagnostics for constant overflow.  */\n-/* Origin: Joseph Myers <joseph@codesourcery.com> */\n-/* { dg-do compile } */\n-/* { dg-options \"\" } */\n-\n-#include <limits.h>\n-\n-enum e {\n-  E0 = INT_MAX,\n-  /* Unsigned overflow wraps around.  */\n-  E1 = UINT_MAX + 1,\n-  /* Overflow in an unevaluated part of an expression is OK (example\n-     in the standard).  */\n-  E2 = 2 || 1 / 0, /* { dg-bogus \"warning: division by zero\" \"\" { xfail *-*-* } 14 } */\n-  E3 = 1 / 0, /* { dg-warning \"warning: division by zero\" } */\n-  /* { dg-error \"error: enumerator value for 'E3' is not an integer constant\" \"enum error\" { target *-*-* } 15 } */\n-  /* But as in DR#031, the 1/0 in an evaluated subexpression means the\n-     whole expression violates the constraints.  */\n-  E4 = 0 * (1 / 0), /* { dg-warning \"warning: division by zero\" } */\n-  /* { dg-error \"error: enumerator value for 'E4' is not an integer constant\" \"enum error\" { xfail *-*-* } 19 } */\n-  E5 = INT_MAX + 1, /* { dg-warning \"warning: integer overflow in expression\" } */\n-  /* Again, overflow in evaluated subexpression.  */\n-  E6 = 0 * (INT_MAX + 1), /* { dg-warning \"warning: integer overflow in expression\" } */\n-  /* A cast does not constitute overflow in conversion.  */\n-  E7 = (char) INT_MAX\n-};\n-\n-struct s {\n-  int a;\n-  int : 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n-  int : 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n-};\n-\n-void\n-f (void)\n-{\n-  /* This expression is not required to be a constant expression, so\n-     it should just involve undefined behavior at runtime.  */\n-  int c = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n-}\n-\n-/* This expression is neither required to be constant.  */\n-static int sc = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n-\n-\n // Test for overflow in null pointer constant.  \n void *n = 0;\n /* The first two of these involve overflow, so are not null pointer"}, {"sha": "b449a49510384bd6e12b21a6242cebed716cb529", "filename": "gcc/testsuite/g++.dg/warn/overflow-warn-3.C", "status": "modified", "additions": 0, "deletions": 258, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8444a5de7e665e8f9a65780e389d53a7211b12d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8444a5de7e665e8f9a65780e389d53a7211b12d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-3.C?ref=8444a5de7e665e8f9a65780e389d53a7211b12d5", "patch": "@@ -47,264 +47,6 @@ f (void)\n static int sc = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n \n \n-// Test for overflow in null pointer constant.  \n-void *n = 0;\n-/* The first two of these involve overflow, so are not null pointer\n-   constants.  The third has the overflow in an unevaluated\n-   subexpression, so is a null pointer constant.  */\n-void *p = 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n-/* { dg-error \"invalid conversion from 'int' to 'void\" \"null\" { target *-*-* } 55 } */\n-\n-void *q = 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n-/* { dg-error \"invalid conversion from 'int' to 'void*'\" \"null\" { xfail *-*-* } 58 } */\n-void *r = (1 ? 0 : INT_MAX+1); /* { dg-bogus \"integer overflow in expression\" \"\" { xfail *-*-* } 60 } */\n-\n-void\n-g (int i)\n-{\n-  switch (i)\n-    {\n-    case 0 * (1/0): /* { dg-warning \"warning: division by zero\" } */\n-      ;\n-    case 1 + 0 * (INT_MAX + 1): /* { dg-warning \"warning: integer overflow in expression\" } */\n-      /* { dg-warning \"warning: overflow in constant expression\" \"constant\" { target *-*-* } 69 } */\n-      ;\n-    }\n-}\n-\n-int\n-h (void)\n-{\n-  return INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n-}\n-\n-int\n-h1 (void)\n-{\n-  return INT_MAX + 1 - INT_MAX; /* { dg-warning \"warning: integer overflow in expression\" } */\n-}\n-\n-void fuc (unsigned char);\n-void fsc (signed char);\n-\n-void\n-h2 (void)\n-{\n-  fsc (SCHAR_MAX + 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n-  fsc (SCHAR_MIN - 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n-  fsc (UCHAR_MAX); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n-  fsc (UCHAR_MAX + 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n-  fuc (-1);\n-  fuc (UCHAR_MAX + 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n-  fuc (SCHAR_MIN);\n-  fuc (SCHAR_MIN - 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n-  fuc (-UCHAR_MAX); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n-}\n-\n-void fui (unsigned int);\n-void fsi (signed int);\n-\n-int si;\n-unsigned ui;\n-\n-void\n-h2i (int x)\n-{\n-  /* For some reason, we only give certain warnings for implicit\n-     conversions among values of the same precision with -Wconversion,\n-     while we don't give others at all.  */\n-  fsi ((unsigned)INT_MAX + 1);\n-  si = (unsigned)INT_MAX + 1;\n-  si = x ? (unsigned)INT_MAX + 1 : 1;\n-  fsi ((unsigned)INT_MAX + 2);\n-  si = (unsigned)INT_MAX + 2;\n-  si = x ? (unsigned)INT_MAX + 2 : 1;\n-  fsi (UINT_MAX);\n-  si = UINT_MAX;\n-  fui (-1);\n-  ui = -1;\n-  ui = x ? -1 : 1U;\n-  fui (INT_MIN);\n-  ui = INT_MIN;\n-  ui = x ? INT_MIN : 1U;\n-}\n-/* Test for diagnostics for constant overflow.  Test with -pedantic.  */\n-/* Origin: Joseph Myers <joseph@codesourcery.com> */\n-/* { dg-do compile } */\n-/* { dg-options \"-fpermissive -pedantic\" } */\n-\n-#include <limits.h>\n-\n-enum e {\n-  E0 = INT_MAX,\n-  /* Unsigned overflow wraps around.  */\n-  E1 = UINT_MAX + 1,\n-  /* Overflow in an unevaluated part of an expression is OK (example\n-     in the standard).  */\n-  E2 = 2 || 1 / 0, /* { dg-bogus \"warning: division by zero\" \"\" { xfail *-*-* } 14 } */\n-  E3 = 1 / 0, /* { dg-warning \"warning: division by zero\" } */\n-  /* { dg-error \"error: enumerator value for 'E3' is not an integer constant\" \"enum error\" { target *-*-* } 15 } */\n-  /* But as in DR#031, the 1/0 in an evaluated subexpression means the\n-     whole expression violates the constraints.  */\n-  E4 = 0 * (1 / 0), /* { dg-warning \"warning: division by zero\" } */\n-  /* { dg-error \"error: enumerator value for 'E4' is not an integer constant\" \"enum error\" { xfail *-*-* } 19 } */\n-  E5 = INT_MAX + 1, /* { dg-warning \"warning: integer overflow in expression\" } */\n-  /* { dg-warning \"warning: overflow in constant expression\" \"constant\" { target *-*-* } 21 } */\n-  /* Again, overflow in evaluated subexpression.  */\n-  E6 = 0 * (INT_MAX + 1), /* { dg-warning \"warning: integer overflow in expression\" } */\n-  /* { dg-warning \"warning: overflow in constant expression\" \"constant\" { target *-*-* } 24 } */\n-  /* A cast does not constitute overflow in conversion.  */\n-  E7 = (char) INT_MAX\n-};\n-\n-struct s {\n-  int a;\n-  int : 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n-  int : 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n-  /* { dg-warning \"warning: overflow in constant expression\" \"constant\" { target *-*-* } 33 } */\n-};\n-\n-void\n-f (void)\n-{\n-  /* This expression is not required to be a constant expression, so\n-     it should just involve undefined behavior at runtime.  */\n-  int c = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n-\n-}\n-\n-/* But this expression does need to be constant (in C++ ???).  */\n-static int sc = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n-/* { dg-warning \"warning: overflow in constant expression\" \"constant\" { xfail *-*-* } 47 } */\n-\n-/* The first two of these involve overflow, so are not null pointer\n-   constants.  The third has the overflow in an unevaluated\n-   subexpression, so is a null pointer constant.  */\n-void *p = 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n-/* { dg-error \"invalid conversion from 'int' to 'void\" \"null\" { target *-*-* } 53 } */\n-\n-void *q = 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n-/* { dg-error \"invalid conversion from 'int' to 'void*'\" \"null\" { xfail *-*-* } 56 } */\n-void *r = (1 ? 0 : INT_MAX+1); /* { dg-bogus \"integer overflow in expression\" \"\" { xfail *-*-* } 58 } */\n-\n-void\n-g (int i)\n-{\n-  switch (i)\n-    {\n-    case 0 * (1/0): /* { dg-warning \"warning: division by zero\" } */\n-      ;\n-    case 1 + 0 * (INT_MAX + 1): /* { dg-warning \"warning: integer overflow in expression\" } */\n-      /* { dg-warning \"warning: overflow in constant expression\" \"constant\" { target *-*-* } 67 } */\n-      ;\n-    }\n-}\n-\n-int\n-h (void)\n-{\n-  return INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n-}\n-\n-int\n-h1 (void)\n-{\n-  return INT_MAX + 1 - INT_MAX; /* { dg-warning \"warning: integer overflow in expression\" } */\n-}\n-\n-void fuc (unsigned char);\n-void fsc (signed char);\n-\n-void\n-h2 (void)\n-{\n-  fsc (SCHAR_MAX + 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n-  fsc (SCHAR_MIN - 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n-  fsc (UCHAR_MAX); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n-  fsc (UCHAR_MAX + 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n-  fuc (-1);\n-  fuc (UCHAR_MAX + 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n-  fuc (SCHAR_MIN);\n-  fuc (SCHAR_MIN - 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n-  fuc (-UCHAR_MAX); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n-}\n-\n-void fui (unsigned int);\n-void fsi (signed int);\n-\n-int si;\n-unsigned ui;\n-\n-void\n-h2i (int x)\n-{\n-  /* For some reason, we only give certain warnings for implicit\n-     conversions among values of the same precision with -Wconversion,\n-     while we don't give others at all.  */\n-  fsi ((unsigned)INT_MAX + 1);\n-  si = (unsigned)INT_MAX + 1;\n-  si = x ? (unsigned)INT_MAX + 1 : 1;\n-  fsi ((unsigned)INT_MAX + 2);\n-  si = (unsigned)INT_MAX + 2;\n-  si = x ? (unsigned)INT_MAX + 2 : 1;\n-  fsi (UINT_MAX);\n-  si = UINT_MAX;\n-  fui (-1);\n-  ui = -1;\n-  ui = x ? -1 : 1U;\n-  fui (INT_MIN);\n-  ui = INT_MIN;\n-  ui = x ? INT_MIN : 1U;\n-}\n-/* Test for diagnostics for constant overflow.  Test with -pedantic.  */\n-/* Origin: Joseph Myers <joseph@codesourcery.com> */\n-/* { dg-do compile } */\n-/* { dg-options \"-fpermissive -pedantic\" } */\n-\n-#include <limits.h>\n-\n-enum e {\n-  E0 = INT_MAX,\n-  /* Unsigned overflow wraps around.  */\n-  E1 = UINT_MAX + 1,\n-  /* Overflow in an unevaluated part of an expression is OK (example\n-     in the standard).  */\n-  E2 = 2 || 1 / 0, /* { dg-bogus \"warning: division by zero\" \"\" { xfail *-*-* } 14 } */\n-  E3 = 1 / 0, /* { dg-warning \"warning: division by zero\" } */\n-  /* { dg-error \"error: enumerator value for 'E3' is not an integer constant\" \"enum error\" { target *-*-* } 15 } */\n-  /* But as in DR#031, the 1/0 in an evaluated subexpression means the\n-     whole expression violates the constraints.  */\n-  E4 = 0 * (1 / 0), /* { dg-warning \"warning: division by zero\" } */\n-  /* { dg-error \"error: enumerator value for 'E4' is not an integer constant\" \"enum error\" { xfail *-*-* } 19 } */\n-  E5 = INT_MAX + 1, /* { dg-warning \"warning: integer overflow in expression\" } */\n-  /* { dg-warning \"warning: overflow in constant expression\" \"constant\" { target *-*-* } 21 } */\n-  /* Again, overflow in evaluated subexpression.  */\n-  E6 = 0 * (INT_MAX + 1), /* { dg-warning \"warning: integer overflow in expression\" } */\n-  /* { dg-warning \"warning: overflow in constant expression\" \"constant\" { target *-*-* } 24 } */\n-  /* A cast does not constitute overflow in conversion.  */\n-  E7 = (char) INT_MAX\n-};\n-\n-struct s {\n-  int a;\n-  int : 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n-  int : 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n-  /* { dg-warning \"warning: overflow in constant expression\" \"constant\" { target *-*-* } 33 } */\n-};\n-\n-void\n-f (void)\n-{\n-  /* This expression is not required to be a constant expression, so\n-     it should just involve undefined behavior at runtime.  */\n-  int c = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n-\n-}\n-\n-/* This expression is neither required to be constant.  */\n-static int sc = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n-\n-\n // Test for overflow in null pointer constant.  \n void *n = 0;\n /* The first two of these involve overflow, so are not null pointer"}, {"sha": "65e220070fb6e1ff90d48ad3d9e55e46ed684280", "filename": "gcc/testsuite/g++.dg/warn/overflow-warn-4.C", "status": "modified", "additions": 0, "deletions": 258, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8444a5de7e665e8f9a65780e389d53a7211b12d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8444a5de7e665e8f9a65780e389d53a7211b12d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-4.C?ref=8444a5de7e665e8f9a65780e389d53a7211b12d5", "patch": "@@ -47,264 +47,6 @@ f (void)\n static int sc = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n \n \n-// Test for overflow in null pointer constant.  \n-void *n = 0;\n-/* The first two of these involve overflow, so are not null pointer\n-   constants.  The third has the overflow in an unevaluated\n-   subexpression, so is a null pointer constant.  */\n-void *p = 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n-/* { dg-error \"invalid conversion from 'int' to 'void\" \"null\" { target *-*-* } 55 } */\n-\n-void *q = 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n-/* { dg-error \"invalid conversion from 'int' to 'void*'\" \"null\" { xfail *-*-* } 58 } */\n-void *r = (1 ? 0 : INT_MAX+1); /* { dg-bogus \"integer overflow in expression\" \"\" { xfail *-*-* } 60 } */\n-\n-void\n-g (int i)\n-{\n-  switch (i)\n-    {\n-    case 0 * (1/0): /* { dg-warning \"warning: division by zero\" } */\n-      ;\n-    case 1 + 0 * (INT_MAX + 1): /* { dg-warning \"warning: integer overflow in expression\" } */\n-      /* { dg-error \"error: overflow in constant expression\" \"constant\" { target *-*-* } 69 } */\n-      ;\n-    }\n-}\n-\n-int\n-h (void)\n-{\n-  return INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n-}\n-\n-int\n-h1 (void)\n-{\n-  return INT_MAX + 1 - INT_MAX; /* { dg-warning \"warning: integer overflow in expression\" } */\n-}\n-\n-void fuc (unsigned char);\n-void fsc (signed char);\n-\n-void\n-h2 (void)\n-{\n-  fsc (SCHAR_MAX + 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n-  fsc (SCHAR_MIN - 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n-  fsc (UCHAR_MAX); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n-  fsc (UCHAR_MAX + 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n-  fuc (-1);\n-  fuc (UCHAR_MAX + 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n-  fuc (SCHAR_MIN);\n-  fuc (SCHAR_MIN - 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n-  fuc (-UCHAR_MAX); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n-}\n-\n-void fui (unsigned int);\n-void fsi (signed int);\n-\n-int si;\n-unsigned ui;\n-\n-void\n-h2i (int x)\n-{\n-  /* For some reason, we only give certain warnings for implicit\n-     conversions among values of the same precision with -Wconversion,\n-     while we don't give others at all.  */\n-  fsi ((unsigned)INT_MAX + 1);\n-  si = (unsigned)INT_MAX + 1;\n-  si = x ? (unsigned)INT_MAX + 1 : 1;\n-  fsi ((unsigned)INT_MAX + 2);\n-  si = (unsigned)INT_MAX + 2;\n-  si = x ? (unsigned)INT_MAX + 2 : 1;\n-  fsi (UINT_MAX);\n-  si = UINT_MAX;\n-  fui (-1);\n-  ui = -1;\n-  ui = x ? -1 : 1U;\n-  fui (INT_MIN);\n-  ui = INT_MIN;\n-  ui = x ? INT_MIN : 1U;\n-}\n-/* Test for diagnostics for constant overflow.  Test with -pedantic-errors.  */\n-/* Origin: Joseph Myers <joseph@codesourcery.com> */\n-/* { dg-do compile } */\n-/* { dg-options \"-pedantic-errors\" } */\n-\n-#include <limits.h>\n-\n-enum e {\n-  E0 = INT_MAX,\n-  /* Unsigned overflow wraps around.  */\n-  E1 = UINT_MAX + 1,\n-  /* Overflow in an unevaluated part of an expression is OK (example\n-     in the standard).  */\n-  E2 = 2 || 1 / 0, /* { dg-bogus \"warning: division by zero\" \"\" { xfail *-*-* } 14 } */\n-  E3 = 1 / 0, /* { dg-warning \"warning: division by zero\" } */\n-  /* { dg-error \"error: enumerator value for 'E3' is not an integer constant\" \"enum error\" { target *-*-* } 15 } */\n-  /* But as in DR#031, the 1/0 in an evaluated subexpression means the\n-     whole expression violates the constraints.  */\n-  E4 = 0 * (1 / 0), /* { dg-warning \"warning: division by zero\" } */\n-  /* { dg-error \"error: enumerator value for 'E4' is not an integer constant\" \"enum error\" { xfail *-*-* } 19 } */\n-  E5 = INT_MAX + 1, /* { dg-warning \"warning: integer overflow in expression\" } */\n-  /* { dg-error \"error: overflow in constant expression\" \"constant\" { target *-*-* } 21 } */\n-  /* Again, overflow in evaluated subexpression.  */\n-  E6 = 0 * (INT_MAX + 1), /* { dg-warning \"warning: integer overflow in expression\" } */\n-  /* { dg-error \"error: overflow in constant expression\" \"constant\" { target *-*-* } 24 } */\n-  /* A cast does not constitute overflow in conversion.  */\n-  E7 = (char) INT_MAX\n-};\n-\n-struct s {\n-  int a;\n-  int : 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n-  int : 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n-  /* { dg-error \"error: overflow in constant expression\" \"constant\" { target *-*-* } 33 } */\n-};\n-\n-void\n-f (void)\n-{\n-  /* This expression is not required to be a constant expression, so\n-     it should just involve undefined behavior at runtime.  */\n-  int c = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n-\n-}\n-\n-/* But this expression does need to be constant (in C++ ???).  */\n-static int sc = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n-/* { dg-error \"error: overflow in constant expression\" \"constant\" { xfail *-*-* } 47 } */\n-\n-/* The first two of these involve overflow, so are not null pointer\n-   constants.  The third has the overflow in an unevaluated\n-   subexpression, so is a null pointer constant.  */\n-void *p = 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n-/* { dg-error \"invalid conversion from 'int' to 'void\" \"null\" { target *-*-* } 53 } */\n-\n-void *q = 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n-/* { dg-error \"invalid conversion from 'int' to 'void*'\" \"null\" { xfail *-*-* } 56 } */\n-void *r = (1 ? 0 : INT_MAX+1); /* { dg-bogus \"integer overflow in expression\" \"\" { xfail *-*-* } 58 } */\n-\n-void\n-g (int i)\n-{\n-  switch (i)\n-    {\n-    case 0 * (1/0): /* { dg-warning \"warning: division by zero\" } */\n-      ;\n-    case 1 + 0 * (INT_MAX + 1): /* { dg-warning \"warning: integer overflow in expression\" } */\n-      /* { dg-error \"error: overflow in constant expression\" \"constant\" { target *-*-* } 67 } */\n-      ;\n-    }\n-}\n-\n-int\n-h (void)\n-{\n-  return INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n-}\n-\n-int\n-h1 (void)\n-{\n-  return INT_MAX + 1 - INT_MAX; /* { dg-warning \"warning: integer overflow in expression\" } */\n-}\n-\n-void fuc (unsigned char);\n-void fsc (signed char);\n-\n-void\n-h2 (void)\n-{\n-  fsc (SCHAR_MAX + 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n-  fsc (SCHAR_MIN - 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n-  fsc (UCHAR_MAX); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n-  fsc (UCHAR_MAX + 1); /* { dg-warning \"warning: overflow in implicit constant conversion\" } */\n-  fuc (-1);\n-  fuc (UCHAR_MAX + 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n-  fuc (SCHAR_MIN);\n-  fuc (SCHAR_MIN - 1); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n-  fuc (-UCHAR_MAX); /* { dg-warning \"warning: large integer implicitly truncated to unsigned type\" } */\n-}\n-\n-void fui (unsigned int);\n-void fsi (signed int);\n-\n-int si;\n-unsigned ui;\n-\n-void\n-h2i (int x)\n-{\n-  /* For some reason, we only give certain warnings for implicit\n-     conversions among values of the same precision with -Wconversion,\n-     while we don't give others at all.  */\n-  fsi ((unsigned)INT_MAX + 1);\n-  si = (unsigned)INT_MAX + 1;\n-  si = x ? (unsigned)INT_MAX + 1 : 1;\n-  fsi ((unsigned)INT_MAX + 2);\n-  si = (unsigned)INT_MAX + 2;\n-  si = x ? (unsigned)INT_MAX + 2 : 1;\n-  fsi (UINT_MAX);\n-  si = UINT_MAX;\n-  fui (-1);\n-  ui = -1;\n-  ui = x ? -1 : 1U;\n-  fui (INT_MIN);\n-  ui = INT_MIN;\n-  ui = x ? INT_MIN : 1U;\n-}\n-/* Test for diagnostics for constant overflow.  Test with -pedantic-errors.  */\n-/* Origin: Joseph Myers <joseph@codesourcery.com> */\n-/* { dg-do compile } */\n-/* { dg-options \"-pedantic-errors\" } */\n-\n-#include <limits.h>\n-\n-enum e {\n-  E0 = INT_MAX,\n-  /* Unsigned overflow wraps around.  */\n-  E1 = UINT_MAX + 1,\n-  /* Overflow in an unevaluated part of an expression is OK (example\n-     in the standard).  */\n-  E2 = 2 || 1 / 0, /* { dg-bogus \"warning: division by zero\" \"\" { xfail *-*-* } 14 } */\n-  E3 = 1 / 0, /* { dg-warning \"warning: division by zero\" } */\n-  /* { dg-error \"error: enumerator value for 'E3' is not an integer constant\" \"enum error\" { target *-*-* } 15 } */\n-  /* But as in DR#031, the 1/0 in an evaluated subexpression means the\n-     whole expression violates the constraints.  */\n-  E4 = 0 * (1 / 0), /* { dg-warning \"warning: division by zero\" } */\n-  /* { dg-error \"error: enumerator value for 'E4' is not an integer constant\" \"enum error\" { xfail *-*-* } 19 } */\n-  E5 = INT_MAX + 1, /* { dg-warning \"warning: integer overflow in expression\" } */\n-  /* { dg-error \"error: overflow in constant expression\" \"constant\" { target *-*-* } 21 } */\n-  /* Again, overflow in evaluated subexpression.  */\n-  E6 = 0 * (INT_MAX + 1), /* { dg-warning \"warning: integer overflow in expression\" } */\n-  /* { dg-error \"error: overflow in constant expression\" \"constant\" { target *-*-* } 24 } */\n-  /* A cast does not constitute overflow in conversion.  */\n-  E7 = (char) INT_MAX\n-};\n-\n-struct s {\n-  int a;\n-  int : 0 * (1 / 0); /* { dg-warning \"warning: division by zero\" } */\n-  int : 0 * (INT_MAX + 1); /* { dg-warning \"warning: integer overflow in expression\" } */\n-  /* { dg-error \"error: overflow in constant expression\" \"constant\" { target *-*-* } 33 } */\n-};\n-\n-void\n-f (void)\n-{\n-  /* This expression is not required to be a constant expression, so\n-     it should just involve undefined behavior at runtime.  */\n-  int c = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n-\n-}\n-\n-/* This expression is neither required to be constant.  */\n-static int sc = INT_MAX + 1; /* { dg-warning \"warning: integer overflow in expression\" } */\n-\n-\n // Test for overflow in null pointer constant.  \n void *n = 0;\n /* The first two of these involve overflow, so are not null pointer"}, {"sha": "472d4a7cab14185384cebeb819a6d104093f21fc", "filename": "gcc/testsuite/g++.dg/warn/overflow-warn-5.C", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8444a5de7e665e8f9a65780e389d53a7211b12d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8444a5de7e665e8f9a65780e389d53a7211b12d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-5.C?ref=8444a5de7e665e8f9a65780e389d53a7211b12d5", "patch": "@@ -5,17 +5,3 @@\n unsigned char rx_async(unsigned char p) {\n     return p & 512; /* { dg-warning \"overflow in implicit constant conversion\" } */\n }\n-/* PR c/27273 */\n-/* { dg-do compile } */\n-/* { dg-options \"-Woverflow\" } */\n-\n-unsigned char rx_async(unsigned char p) {\n-    return p & 512; /* { dg-warning \"overflow in implicit constant conversion\" } */\n-}\n-/* PR c/27273 */\n-/* { dg-do compile } */\n-/* { dg-options \"-Woverflow\" } */\n-\n-unsigned char rx_async(unsigned char p) {\n-    return p & 512; /* { dg-warning \"overflow in implicit constant conversion\" } */\n-}"}, {"sha": "fa0cc83fa4dedb47c995fef37b491ebe056191b2", "filename": "gcc/testsuite/g++.dg/warn/overflow-warn-6.C", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8444a5de7e665e8f9a65780e389d53a7211b12d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8444a5de7e665e8f9a65780e389d53a7211b12d5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-6.C?ref=8444a5de7e665e8f9a65780e389d53a7211b12d5", "patch": "@@ -16,39 +16,3 @@ h2 (int x)\n   return ((INT_MAX + 1) * 0) * x; /* { dg-warning \"warning: integer overflow in expression\" } */\n }\n \n-/* Test non-constant operands in overflowed expressions.  */\n-/* { dg-do compile } */\n-/* { dg-options \"-Woverflow\" } */\n-\n-#include <limits.h>\n-\n-int \n-h1 (int x)\n-{\n-  return x * (0 * (INT_MAX + 1)); /* { dg-warning \"warning: integer overflow in expression\" } */\n-}\n-\n-int \n-h2 (int x)\n-{\n-  return ((INT_MAX + 1) * 0) * x; /* { dg-warning \"warning: integer overflow in expression\" } */\n-}\n-\n-/* Test non-constant operands in overflowed expressions.  */\n-/* { dg-do compile } */\n-/* { dg-options \"-Woverflow\" } */\n-\n-#include <limits.h>\n-\n-int \n-h1 (int x)\n-{\n-  return x * (0 * (INT_MAX + 1)); /* { dg-warning \"warning: integer overflow in expression\" } */\n-}\n-\n-int \n-h2 (int x)\n-{\n-  return ((INT_MAX + 1) * 0) * x; /* { dg-warning \"warning: integer overflow in expression\" } */\n-}\n-"}]}