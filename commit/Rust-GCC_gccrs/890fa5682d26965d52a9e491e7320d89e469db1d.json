{"sha": "890fa5682d26965d52a9e491e7320d89e469db1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODkwZmE1NjgyZDI2OTY1ZDUyYTllNDkxZTczMjBkODllNDY5ZGIxZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2014-03-15T21:39:30Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2014-03-15T21:39:30Z"}, "message": "sparc-protos.h (tls_call_delay): Delete.\n\n\t* config/sparc/sparc-protos.h (tls_call_delay): Delete.\n\t(eligible_for_call_delay): New prototype.\n\t* config/sparc/sparc.c (tls_call_delay): Rename into...\n\t(eligible_for_call_delay): ...this.  Return false if the instruction\n\tcannot be put in the delay slot of a branch.\n\t(eligible_for_restore_insn): Simplify.\n\t(eligible_for_return_delay): Return false if the instruction cannot be\n\tput in the delay slot of a branch and simplify.\n\t(eligible_for_sibcall_delay): Return false if the instruction cannot be\n\tput in the delay slot of a branch.\n\t* config/sparc/sparc.md (fix_ut699): New attribute.\n\t(tls_call_delay): Delete.\n\t(in_call_delay): Reimplement.\n\t(eligible_for_sibcall_delay): Rename into...\n\t(in_sibcall_delay): ...this.\n\t(eligible_for_return_delay): Rename into...\n\t(in_return_delay): ...this.\n\t(in_branch_delay): Reimplement.\n\t(in_uncond_branch_delay): Delete.\n\t(in_annul_branch_delay): Delete.\n\nFrom-SVN: r208597", "tree": {"sha": "c7507011eb9848034f836534b413f6f4d5297755", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7507011eb9848034f836534b413f6f4d5297755"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/890fa5682d26965d52a9e491e7320d89e469db1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/890fa5682d26965d52a9e491e7320d89e469db1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/890fa5682d26965d52a9e491e7320d89e469db1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/890fa5682d26965d52a9e491e7320d89e469db1d/comments", "author": null, "committer": null, "parents": [{"sha": "dcf39d824fcffbe24b6cf9248be5bc8a82513ef6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcf39d824fcffbe24b6cf9248be5bc8a82513ef6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcf39d824fcffbe24b6cf9248be5bc8a82513ef6"}], "stats": {"total": 141, "additions": 70, "deletions": 71}, "files": [{"sha": "7d0ca2d1d5303c42ebdb884aa495cf2b42704d25", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/890fa5682d26965d52a9e491e7320d89e469db1d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/890fa5682d26965d52a9e491e7320d89e469db1d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=890fa5682d26965d52a9e491e7320d89e469db1d", "patch": "@@ -1,3 +1,26 @@\n+2014-03-15  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* config/sparc/sparc-protos.h (tls_call_delay): Delete.\n+\t(eligible_for_call_delay): New prototype.\n+\t* config/sparc/sparc.c (tls_call_delay): Rename into...\n+\t(eligible_for_call_delay): ...this.  Return false if the instruction\n+\tcannot be put in the delay slot of a branch.\n+\t(eligible_for_restore_insn): Simplify.\n+\t(eligible_for_return_delay): Return false if the instruction cannot be\n+\tput in the delay slot of a branch and simplify.\n+\t(eligible_for_sibcall_delay): Return false if the instruction cannot be\n+\tput in the delay slot of a branch.\n+\t* config/sparc/sparc.md (fix_ut699): New attribute.\n+\t(tls_call_delay): Delete.\n+\t(in_call_delay): Reimplement.\n+\t(eligible_for_sibcall_delay): Rename into...\n+\t(in_sibcall_delay): ...this.\n+\t(eligible_for_return_delay): Rename into...\n+\t(in_return_delay): ...this.\n+\t(in_branch_delay): Reimplement.\n+\t(in_uncond_branch_delay): Delete.\n+\t(in_annul_branch_delay): Delete.\n+\n 2014-03-14  Richard Henderson  <rth@redhat.com>\n \n \tPR target/60525"}, {"sha": "1d63e46406db0314149a4ac6836cab5ed954f923", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/890fa5682d26965d52a9e491e7320d89e469db1d/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/890fa5682d26965d52a9e491e7320d89e469db1d/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=890fa5682d26965d52a9e491e7320d89e469db1d", "patch": "@@ -86,9 +86,9 @@ extern int mems_ok_for_ldd_peep (rtx, rtx, rtx);\n extern rtx widen_mem_for_ldd_peep (rtx, rtx, enum machine_mode);\n extern int empty_delay_slot (rtx);\n extern int emit_cbcond_nop (rtx);\n+extern int eligible_for_call_delay (rtx);\n extern int eligible_for_return_delay (rtx);\n extern int eligible_for_sibcall_delay (rtx);\n-extern int tls_call_delay (rtx);\n extern int emit_move_sequence (rtx, enum machine_mode);\n extern int fp_sethi_p (rtx);\n extern int fp_mov_p (rtx);"}, {"sha": "134dfd494fdb241f992150820bace59f727541cd", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/890fa5682d26965d52a9e491e7320d89e469db1d/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/890fa5682d26965d52a9e491e7320d89e469db1d/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=890fa5682d26965d52a9e491e7320d89e469db1d", "patch": "@@ -3381,10 +3381,13 @@ emit_cbcond_nop (rtx insn)\n /* Return nonzero if TRIAL can go into the call delay slot.  */\n \n int\n-tls_call_delay (rtx trial)\n+eligible_for_call_delay (rtx trial)\n {\n   rtx pat;\n \n+  if (get_attr_in_branch_delay (trial) == IN_BRANCH_DELAY_FALSE)\n+    return 0;\n+\n   /* Binutils allows\n        call __tls_get_addr, %tgd_call (foo)\n         add %l7, %o0, %o0, %tgd_add (foo)\n@@ -3466,11 +3469,7 @@ eligible_for_restore_insn (rtx trial, bool return_p)\n \n   /* If we have the 'return' instruction, anything that does not use\n      local or output registers and can go into a delay slot wins.  */\n-  else if (return_p\n-\t   && TARGET_V9\n-\t   && !epilogue_renumber (&pat, 1)\n-\t   && get_attr_in_uncond_branch_delay (trial)\n-\t       == IN_UNCOND_BRANCH_DELAY_TRUE)\n+  else if (return_p && TARGET_V9 && !epilogue_renumber (&pat, 1))\n     return 1;\n \n   /* The 'restore src1,src2,dest' pattern for SImode.  */\n@@ -3513,21 +3512,20 @@ eligible_for_return_delay (rtx trial)\n   int regno;\n   rtx pat;\n \n-  if (! NONJUMP_INSN_P (trial))\n-    return 0;\n-\n-  if (get_attr_length (trial) != 1)\n-    return 0;\n-\n   /* If the function uses __builtin_eh_return, the eh_return machinery\n      occupies the delay slot.  */\n   if (crtl->calls_eh_return)\n     return 0;\n \n+  if (get_attr_in_branch_delay (trial) == IN_BRANCH_DELAY_FALSE)\n+    return 0;\n+\n   /* In the case of a leaf or flat function, anything can go into the slot.  */\n   if (sparc_leaf_function_p || TARGET_FLAT)\n-    return\n-      get_attr_in_uncond_branch_delay (trial) == IN_UNCOND_BRANCH_DELAY_TRUE;\n+    return 1;\n+\n+  if (!NONJUMP_INSN_P (trial))\n+    return 0;\n \n   pat = PATTERN (trial);\n   if (GET_CODE (pat) == PARALLEL)\n@@ -3547,9 +3545,7 @@ eligible_for_return_delay (rtx trial)\n \t  if (regno >= 8 && regno < 24)\n \t    return 0;\n \t}\n-      return !epilogue_renumber (&pat, 1)\n-\t&& (get_attr_in_uncond_branch_delay (trial)\n-\t    == IN_UNCOND_BRANCH_DELAY_TRUE);\n+      return !epilogue_renumber (&pat, 1);\n     }\n \n   if (GET_CODE (pat) != SET)\n@@ -3569,10 +3565,7 @@ eligible_for_return_delay (rtx trial)\n      instruction, it can probably go in.  But restore will not work\n      with FP_REGS.  */\n   if (! SPARC_INT_REG_P (regno))\n-    return (TARGET_V9\n-\t    && !epilogue_renumber (&pat, 1)\n-\t    && get_attr_in_uncond_branch_delay (trial)\n-\t       == IN_UNCOND_BRANCH_DELAY_TRUE);\n+    return TARGET_V9 && !epilogue_renumber (&pat, 1);\n \n   return eligible_for_restore_insn (trial, true);\n }\n@@ -3584,10 +3577,10 @@ eligible_for_sibcall_delay (rtx trial)\n {\n   rtx pat;\n \n-  if (! NONJUMP_INSN_P (trial) || GET_CODE (PATTERN (trial)) != SET)\n+  if (get_attr_in_branch_delay (trial) == IN_BRANCH_DELAY_FALSE)\n     return 0;\n \n-  if (get_attr_length (trial) != 1)\n+  if (!NONJUMP_INSN_P (trial))\n     return 0;\n \n   pat = PATTERN (trial);\n@@ -3606,6 +3599,9 @@ eligible_for_sibcall_delay (rtx trial)\n       return 1;\n     }\n \n+  if (GET_CODE (pat) != SET)\n+    return 0;\n+\n   /* Otherwise, only operations which can be done in tandem with\n      a `restore' insn can go into the delay slot.  */\n   if (GET_CODE (SET_DEST (pat)) != REG"}, {"sha": "7f4bd81b7f8bdb4d00da33ac7173cc09d496e296", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 27, "deletions": 47, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/890fa5682d26965d52a9e491e7320d89e469db1d/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/890fa5682d26965d52a9e491e7320d89e469db1d/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=890fa5682d26965d52a9e491e7320d89e469db1d", "patch": "@@ -291,7 +291,8 @@\n   (const_string \"none\"))\n \n (define_attr \"pic\" \"false,true\"\n-  (symbol_ref \"(flag_pic != 0 ? PIC_TRUE : PIC_FALSE)\"))\n+  (symbol_ref \"(flag_pic != 0\n+\t\t? PIC_TRUE : PIC_FALSE)\"))\n \n (define_attr \"calls_alloca\" \"false,true\"\n   (symbol_ref \"(cfun->calls_alloca != 0\n@@ -313,6 +314,10 @@\n   (symbol_ref \"(TARGET_FLAT != 0\n \t\t? FLAT_TRUE : FLAT_FALSE)\"))\n \n+(define_attr \"fix_ut699\" \"false,true\"\n+   (symbol_ref \"(sparc_fix_ut699 != 0\n+\t\t ? FIX_UT699_TRUE : FIX_UT699_FALSE)\"))\n+\n ;; Length (in # of insns).\n ;; Beware that setting a length greater or equal to 3 for conditional branches\n ;; has a side-effect (see output_cbranch and output_v9branch).\n@@ -427,32 +432,18 @@\n   [(set_attr \"length\" \"2\")\n    (set_attr \"type\" \"multi\")])\n \n-;; Attributes for instruction and branch scheduling\n-(define_attr \"tls_call_delay\" \"false,true\"\n-  (symbol_ref \"(tls_call_delay (insn)\n-\t\t? TLS_CALL_DELAY_TRUE : TLS_CALL_DELAY_FALSE)\"))\n-\n+;; Attributes for branch scheduling\n (define_attr \"in_call_delay\" \"false,true\"\n-  (cond [(eq_attr \"type\" \"uncond_branch,branch,cbcond,uncond_cbcond,call,sibcall,call_no_delay_slot,multi\")\n-\t\t(const_string \"false\")\n-\t (eq_attr \"type\" \"load,fpload,store,fpstore\")\n-\t\t(if_then_else (eq_attr \"length\" \"1\")\n-\t\t\t      (const_string \"true\")\n-\t\t\t      (const_string \"false\"))]\n-\t (if_then_else (and (eq_attr \"length\" \"1\")\n-\t\t\t    (eq_attr \"tls_call_delay\" \"true\"))\n-\t\t       (const_string \"true\")\n-\t\t       (const_string \"false\"))))\n-\n-(define_attr \"eligible_for_sibcall_delay\" \"false,true\"\n+  (symbol_ref \"(eligible_for_call_delay (insn)\n+\t\t? IN_CALL_DELAY_TRUE : IN_CALL_DELAY_FALSE)\"))\n+\n+(define_attr \"in_sibcall_delay\" \"false,true\"\n   (symbol_ref \"(eligible_for_sibcall_delay (insn)\n-\t\t? ELIGIBLE_FOR_SIBCALL_DELAY_TRUE\n-\t\t: ELIGIBLE_FOR_SIBCALL_DELAY_FALSE)\"))\n+\t\t? IN_SIBCALL_DELAY_TRUE : IN_SIBCALL_DELAY_FALSE)\"))\n \n-(define_attr \"eligible_for_return_delay\" \"false,true\"\n+(define_attr \"in_return_delay\" \"false,true\"\n   (symbol_ref \"(eligible_for_return_delay (insn)\n-\t\t? ELIGIBLE_FOR_RETURN_DELAY_TRUE\n-\t\t: ELIGIBLE_FOR_RETURN_DELAY_FALSE)\"))\n+\t\t? IN_RETURN_DELAY_TRUE : IN_RETURN_DELAY_FALSE)\"))\n \n ;; ??? !v9: Should implement the notion of predelay slots for floating-point\n ;; branches.  This would allow us to remove the nop always inserted before\n@@ -467,39 +458,28 @@\n ;; because it prevents us from moving back the final store of inner loops.\n \n (define_attr \"in_branch_delay\" \"false,true\"\n-  (if_then_else (and (eq_attr \"type\" \"!uncond_branch,branch,cbcond,uncond_cbcond,call,sibcall,call_no_delay_slot,multi\")\n-\t\t     (eq_attr \"length\" \"1\"))\n-\t\t(const_string \"true\")\n-\t\t(const_string \"false\")))\n-\n-(define_attr \"in_uncond_branch_delay\" \"false,true\"\n-  (if_then_else (and (eq_attr \"type\" \"!uncond_branch,branch,cbcond,uncond_cbcond,call,sibcall,call_no_delay_slot,multi\")\n-\t\t     (eq_attr \"length\" \"1\"))\n-\t\t(const_string \"true\")\n-\t\t(const_string \"false\")))\n-\n-(define_attr \"in_annul_branch_delay\" \"false,true\"\n-  (if_then_else (and (eq_attr \"type\" \"!uncond_branch,branch,cbcond,uncond_cbcond,call,sibcall,call_no_delay_slot,multi\")\n-\t\t     (eq_attr \"length\" \"1\"))\n-\t\t(const_string \"true\")\n-\t\t(const_string \"false\")))\n+  (cond [(eq_attr \"type\" \"uncond_branch,branch,cbcond,uncond_cbcond,call,sibcall,call_no_delay_slot,multi\")\n+\t   (const_string \"false\")\n+\t (and (eq_attr \"fix_ut699\" \"true\") (eq_attr \"type\" \"load,sload\"))\n+\t   (const_string \"false\")\n+\t (eq_attr \"length\" \"1\")\n+\t   (const_string \"true\")\n+\t] (const_string \"false\")))\n \n (define_delay (eq_attr \"type\" \"call\")\n   [(eq_attr \"in_call_delay\" \"true\") (nil) (nil)])\n \n (define_delay (eq_attr \"type\" \"sibcall\")\n-  [(eq_attr \"eligible_for_sibcall_delay\" \"true\") (nil) (nil)])\n+  [(eq_attr \"in_sibcall_delay\" \"true\") (nil) (nil)])\n+\n+(define_delay (eq_attr \"type\" \"return\")\n+  [(eq_attr \"in_return_delay\" \"true\") (nil) (nil)])\n \n (define_delay (eq_attr \"type\" \"branch\")\n-  [(eq_attr \"in_branch_delay\" \"true\")\n-   (nil) (eq_attr \"in_annul_branch_delay\" \"true\")])\n+  [(eq_attr \"in_branch_delay\" \"true\") (nil) (eq_attr \"in_branch_delay\" \"true\")])\n \n (define_delay (eq_attr \"type\" \"uncond_branch\")\n-  [(eq_attr \"in_uncond_branch_delay\" \"true\")\n-   (nil) (nil)])\n-\n-(define_delay (eq_attr \"type\" \"return\")\n-  [(eq_attr \"eligible_for_return_delay\" \"true\") (nil) (nil)])\n+  [(eq_attr \"in_branch_delay\" \"true\") (nil) (nil)])\n \n \n ;; Include SPARC DFA schedulers"}]}