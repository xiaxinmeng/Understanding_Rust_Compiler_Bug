{"sha": "760804f3b9b9127ea68abd96d1d96dc51c80f749", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzYwODA0ZjNiOWI5MTI3ZWE2OGFiZDk2ZDFkOTZkYzUxYzgwZjc0OQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-01-30T11:20:27Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-01-30T11:20:27Z"}, "message": "[multiple changes]\n\n2015-01-30  Yannick Moy  <moy@adacore.com>\n\n\t* sem_attr.adb: Code clean up.\n\n2015-01-30  Robert Dewar  <dewar@adacore.com>\n\n\t* ali.adb (Scan_ALI): Set Serious_Errors flag in Unit record.\n\t* ali.ads (Unit_Record): Add new field Serious_Errors.\n\t* lib-writ.adb (Write_Unit_Information): Set SE (serious errors)\n\tattribute in U line.\n\t* lib-writ.ads: New attribute SE (serious erors) in unit line.\n\n2015-01-30  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* einfo.adb Update the usage of attributes Entry_Bodies_Array,\n\tLit_Indexes, Scale_Value, Storage_Size_Variable,\n\tString_Literal_Low_Bound along associated routines and\n\tWrite_FieldX_Name.\n\t(Pending_Access_Types): New routine.\n\t(Set_Pending_Access_Types): New routine.\n\t(Write_Field15_Name): Add an entry for Pending_Access_Types.\n\t* einfo.ads Add new attribute Pending_Access_Types along\n\twith usage in nodes.  Update the usage of attributes\n\tEntry_Bodies_Array, Lit_Indexes, Scale_Value,\n\tStorage_Size_Variable, String_Literal_Low_Bound.\n\t(Pending_Access_Types): New routine along with pragma Inline.\n\t(Set_Pending_Access_Types): New routine along with pragma Inline.\n\t* exp_ch3.adb (Expand_Freeze_Array_Type): Add new local variable\n\tIns_Node. Determine the insertion node for anonynous access type\n\tthat acts as a component type of an array. Update the call to\n\tBuild_Finalization_Master.\n\t(Expand_Freeze_Record_Type): Update\n\tthe calls to Build_Finalization_Master.\n\t(Freeze_Type): Remove\n\tlocal variable RACW_Seen. Factor out the code that deals with\n\tremote access-to-class-wide types. Create a finalization master\n\twhen the designated type contains a private component. Fully\n\tinitialize all pending access types.\n\t(Process_RACW_Types): New routine.\n\t(Process_Pending_Access_Types): New routine.\n\t* exp_ch4.adb (Expand_Allocator_Expression): Allocation no longer\n\tneeds to set primitive Finalize_Address.\n\t(Expand_N_Allocator): Allocation no longer sets primitive\n\tFinalize_Address.\n\t* exp_ch6.adb (Add_Finalization_Master_Actual_To_Build_In_Place_Call):\n\tUpdate the call to Build_Finalization_Master.\n\t(Make_Build_In_Place_Call_In_Allocator): Allocation no longer\n\tneeds to set primitive Finalize_Address.\n\t* exp_ch7.adb (Add_Pending_Access_Type): New routine.\n\t(Build_Finalization_Master): New parameter profile. Associate\n\tprimitive Finalize_Address with the finalization master if the\n\tdesignated type has been frozen, otherwise treat the access\n\ttype as pending. Simplify the insertion of the master and\n\trelated initialization code.\n\t(Make_Finalize_Address_Body): Allow Finalize_Address for class-wide\n\tabstract types.\n\t(Make_Set_Finalize_Address_Call): Remove forlam parameter Typ.\n\tSimplify the implementation.\n\t* exp_ch7.ads (Build_Finalization_Master): New parameter profile\n\talong with comment on usage.\n\t(Make_Set_Finalize_Address_Call): Remove formal parameter Typ. Update\n\tthe comment on usage.\n\t* exp_util.adb (Build_Allocate_Deallocate_Proc): Use routine\n\tFinalize_Address to retrieve the primitive.\n\t(Finalize_Address): New routine.\n\t(Find_Finalize_Address): Removed.\n\t* exp_util.ads (Finalize_Address): New routine.\n\t* freeze.adb (Freeze_All): Remove the generation of finalization\n\tmasters.\n\t* sem_ch3.adb (Analyze_Full_Type_Declaration): Propagate any\n\tpending access types from the partial to the full view.\n\nFrom-SVN: r220279", "tree": {"sha": "a172122c09cac7216fa87e2b8da69fa6e59fe00d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a172122c09cac7216fa87e2b8da69fa6e59fe00d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/760804f3b9b9127ea68abd96d1d96dc51c80f749", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/760804f3b9b9127ea68abd96d1d96dc51c80f749", "html_url": "https://github.com/Rust-GCC/gccrs/commit/760804f3b9b9127ea68abd96d1d96dc51c80f749", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/760804f3b9b9127ea68abd96d1d96dc51c80f749/comments", "author": null, "committer": null, "parents": [{"sha": "3b506eefba6f84471264fa58bb0ffdaa418e63bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b506eefba6f84471264fa58bb0ffdaa418e63bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b506eefba6f84471264fa58bb0ffdaa418e63bd"}], "stats": {"total": 1061, "additions": 598, "deletions": 463}, "files": [{"sha": "56b0c13de1538689c979919825b34e3aa82f7f2c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=760804f3b9b9127ea68abd96d1d96dc51c80f749", "patch": "@@ -1,3 +1,75 @@\n+2015-01-30  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_attr.adb: Code clean up.\n+\n+2015-01-30  Robert Dewar  <dewar@adacore.com>\n+\n+\t* ali.adb (Scan_ALI): Set Serious_Errors flag in Unit record.\n+\t* ali.ads (Unit_Record): Add new field Serious_Errors.\n+\t* lib-writ.adb (Write_Unit_Information): Set SE (serious errors)\n+\tattribute in U line.\n+\t* lib-writ.ads: New attribute SE (serious erors) in unit line.\n+\n+2015-01-30  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* einfo.adb Update the usage of attributes Entry_Bodies_Array,\n+\tLit_Indexes, Scale_Value, Storage_Size_Variable,\n+\tString_Literal_Low_Bound along associated routines and\n+\tWrite_FieldX_Name.\n+\t(Pending_Access_Types): New routine.\n+\t(Set_Pending_Access_Types): New routine.\n+\t(Write_Field15_Name): Add an entry for Pending_Access_Types.\n+\t* einfo.ads Add new attribute Pending_Access_Types along\n+\twith usage in nodes.  Update the usage of attributes\n+\tEntry_Bodies_Array, Lit_Indexes, Scale_Value,\n+\tStorage_Size_Variable, String_Literal_Low_Bound.\n+\t(Pending_Access_Types): New routine along with pragma Inline.\n+\t(Set_Pending_Access_Types): New routine along with pragma Inline.\n+\t* exp_ch3.adb (Expand_Freeze_Array_Type): Add new local variable\n+\tIns_Node. Determine the insertion node for anonynous access type\n+\tthat acts as a component type of an array. Update the call to\n+\tBuild_Finalization_Master.\n+\t(Expand_Freeze_Record_Type): Update\n+\tthe calls to Build_Finalization_Master.\n+\t(Freeze_Type): Remove\n+\tlocal variable RACW_Seen. Factor out the code that deals with\n+\tremote access-to-class-wide types. Create a finalization master\n+\twhen the designated type contains a private component. Fully\n+\tinitialize all pending access types.\n+\t(Process_RACW_Types): New routine.\n+\t(Process_Pending_Access_Types): New routine.\n+\t* exp_ch4.adb (Expand_Allocator_Expression): Allocation no longer\n+\tneeds to set primitive Finalize_Address.\n+\t(Expand_N_Allocator): Allocation no longer sets primitive\n+\tFinalize_Address.\n+\t* exp_ch6.adb (Add_Finalization_Master_Actual_To_Build_In_Place_Call):\n+\tUpdate the call to Build_Finalization_Master.\n+\t(Make_Build_In_Place_Call_In_Allocator): Allocation no longer\n+\tneeds to set primitive Finalize_Address.\n+\t* exp_ch7.adb (Add_Pending_Access_Type): New routine.\n+\t(Build_Finalization_Master): New parameter profile. Associate\n+\tprimitive Finalize_Address with the finalization master if the\n+\tdesignated type has been frozen, otherwise treat the access\n+\ttype as pending. Simplify the insertion of the master and\n+\trelated initialization code.\n+\t(Make_Finalize_Address_Body): Allow Finalize_Address for class-wide\n+\tabstract types.\n+\t(Make_Set_Finalize_Address_Call): Remove forlam parameter Typ.\n+\tSimplify the implementation.\n+\t* exp_ch7.ads (Build_Finalization_Master): New parameter profile\n+\talong with comment on usage.\n+\t(Make_Set_Finalize_Address_Call): Remove formal parameter Typ. Update\n+\tthe comment on usage.\n+\t* exp_util.adb (Build_Allocate_Deallocate_Proc): Use routine\n+\tFinalize_Address to retrieve the primitive.\n+\t(Finalize_Address): New routine.\n+\t(Find_Finalize_Address): Removed.\n+\t* exp_util.ads (Finalize_Address): New routine.\n+\t* freeze.adb (Freeze_All): Remove the generation of finalization\n+\tmasters.\n+\t* sem_ch3.adb (Analyze_Full_Type_Declaration): Propagate any\n+\tpending access types from the partial to the full view.\n+\n 2015-01-30  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_disp.adb: Minor reformatting."}, {"sha": "83bf2b99065e47734d54ac745c0c40c2cfa46b04", "filename": "gcc/ada/ali.adb", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Fali.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Fali.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.adb?ref=760804f3b9b9127ea68abd96d1d96dc51c80f749", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1704,6 +1704,7 @@ package body ALI is\n             UL.Shared_Passive           := False;\n             UL.RCI                      := False;\n             UL.Remote_Types             := False;\n+            UL.Serious_Errors           := False;\n             UL.Has_RACW                 := False;\n             UL.Init_Scalars             := False;\n             UL.Is_Generic               := False;\n@@ -1956,10 +1957,14 @@ package body ALI is\n \n                Check_At_End_Of_Field;\n \n+            --  SE/SP/SU parameters\n+\n             elsif C = 'S' then\n                C := Getc;\n \n-               if C = 'P' then\n+               if C = 'E' then\n+                  Units.Table (Units.Last).Serious_Errors := True;\n+               elsif C = 'P' then\n                   Units.Table (Units.Last).Shared_Passive := True;\n                elsif C = 'U' then\n                   Units.Table (Units.Last).Unit_Kind := 's';"}, {"sha": "8dc87bb0fad724fe7893699994ad90443bb7ab9a", "filename": "gcc/ada/ali.ads", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Fali.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Fali.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.ads?ref=760804f3b9b9127ea68abd96d1d96dc51c80f749", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -302,6 +302,10 @@ package ALI is\n       --  Indicates presence of RT parameter for a package which has a\n       --  pragma Remote_Types.\n \n+      Serious_Errors : Boolean;\n+      --  Indicates presence of SE parameter indicating that compilation of\n+      --  the unit encountered as serious error.\n+\n       Shared_Passive : Boolean;\n       --  Indicates presence of SP parameter for a package which has a pragma\n       --  Shared_Passive."}, {"sha": "cfed66fe7c2bc8097554b6e6661b1d8f69a28d84", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 67, "deletions": 48, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=760804f3b9b9127ea68abd96d1d96dc51c80f749", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -121,15 +121,11 @@ package body Einfo is\n    --    Discriminant_Number             Uint15\n    --    DT_Position                     Uint15\n    --    DT_Entry_Count                  Uint15\n-   --    Entry_Bodies_Array              Node15\n    --    Entry_Parameters_Type           Node15\n    --    Extra_Formal                    Node15\n-   --    Lit_Indexes                     Node15\n+   --    Pending_Access_Types            Elist15\n    --    Related_Instance                Node15\n    --    Status_Flag_Or_Transient_Decl   Node15\n-   --    Scale_Value                     Uint15\n-   --    Storage_Size_Variable           Node15\n-   --    String_Literal_Low_Bound        Node15\n \n    --    Access_Disp_Table               Elist16\n    --    Body_References                 Elist16\n@@ -138,6 +134,7 @@ package body Einfo is\n    --    Entry_Formal                    Node16\n    --    First_Private_Entity            Node16\n    --    Lit_Strings                     Node16\n+   --    Scale_Value                     Uint16\n    --    String_Literal_Length           Uint16\n    --    Unset_Reference                 Node16\n \n@@ -159,14 +156,17 @@ package body Einfo is\n    --    Delta_Value                     Ureal18\n    --    Enclosing_Scope                 Node18\n    --    Equivalent_Type                 Node18\n+   --    Lit_Indexes                     Node18\n    --    Private_Dependents              Elist18\n    --    Renamed_Entity                  Node18\n    --    Renamed_Object                  Node18\n+   --    String_Literal_Low_Bound        Node18\n \n    --    Body_Entity                     Node19\n    --    Corresponding_Discriminant      Node19\n    --    Default_Aspect_Component_Value  Node19\n    --    Default_Aspect_Value            Node19\n+   --    Entry_Bodies_Array              Node19\n    --    Extra_Accessibility_Of_Result   Node19\n    --    Parent_Subtype                  Node19\n    --    Size_Check_Code                 Node19\n@@ -226,10 +226,9 @@ package body Einfo is\n \n    --    Dispatch_Table_Wrappers         Elist26\n    --    Last_Assignment                 Node26\n-   --    Original_Access_Type            Node26\n    --    Overridden_Operation            Node26\n    --    Package_Instantiation           Node26\n-   --    Relative_Deadline_Variable      Node26\n+   --    Storage_Size_Variable           Node26\n \n    --    Current_Use_Clause              Node27\n    --    Related_Type                    Node27\n@@ -238,6 +237,8 @@ package body Einfo is\n    --    Extra_Formals                   Node28\n    --    Finalizer                       Node28\n    --    Initialization_Statements       Node28\n+   --    Original_Access_Type            Node28\n+   --    Relative_Deadline_Variable      Node28\n    --    Underlying_Record_View          Node28\n \n    --    BIP_Initialization_Call         Node29\n@@ -1093,7 +1094,7 @@ package body Einfo is\n \n    function Entry_Bodies_Array (Id : E) return E is\n    begin\n-      return Node15 (Id);\n+      return Node19 (Id);\n    end Entry_Bodies_Array;\n \n    function Entry_Cancel_Parameter (Id : E) return E is\n@@ -2505,7 +2506,7 @@ package body Einfo is\n    function Lit_Indexes (Id : E) return E is\n    begin\n       pragma Assert (Is_Enumeration_Type (Id));\n-      return Node15 (Id);\n+      return Node18 (Id);\n    end Lit_Indexes;\n \n    function Lit_Strings (Id : E) return E is\n@@ -2689,7 +2690,7 @@ package body Einfo is\n    function Original_Access_Type (Id : E) return E is\n    begin\n       pragma Assert (Ekind (Id) = E_Access_Subprogram_Type);\n-      return Node26 (Id);\n+      return Node28 (Id);\n    end Original_Access_Type;\n \n    function Original_Array_Type (Id : E) return E is\n@@ -2738,6 +2739,12 @@ package body Einfo is\n       return Elist9 (Id);\n    end Part_Of_Constituents;\n \n+   function Pending_Access_Types (Id : E) return L is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      return Elist15 (Id);\n+   end Pending_Access_Types;\n+\n    function Postcondition_Proc (Id : E) return E is\n    begin\n       pragma Assert (Ekind (Id) = E_Procedure);\n@@ -2853,7 +2860,7 @@ package body Einfo is\n    function Relative_Deadline_Variable (Id : E) return E is\n    begin\n       pragma Assert (Is_Task_Type (Id));\n-      return Node26 (Implementation_Base_Type (Id));\n+      return Node28 (Implementation_Base_Type (Id));\n    end Relative_Deadline_Variable;\n \n    function Renamed_Entity (Id : E) return N is\n@@ -2929,7 +2936,7 @@ package body Einfo is\n \n    function Scale_Value (Id : E) return U is\n    begin\n-      return Uint15 (Id);\n+      return Uint16 (Id);\n    end Scale_Value;\n \n    function Scope_Depth_Value (Id : E) return U is\n@@ -3063,7 +3070,7 @@ package body Einfo is\n    function Storage_Size_Variable (Id : E) return E is\n    begin\n       pragma Assert (Is_Access_Type (Id) or else Is_Task_Type (Id));\n-      return Node15 (Implementation_Base_Type (Id));\n+      return Node26 (Implementation_Base_Type (Id));\n    end Storage_Size_Variable;\n \n    function Static_Elaboration_Desired (Id : E) return B is\n@@ -3103,7 +3110,7 @@ package body Einfo is\n \n    function String_Literal_Low_Bound (Id : E) return N is\n    begin\n-      return Node15 (Id);\n+      return Node18 (Id);\n    end String_Literal_Low_Bound;\n \n    function Subprograms_For_Type (Id : E) return E is\n@@ -3920,7 +3927,7 @@ package body Einfo is\n \n    procedure Set_Entry_Bodies_Array (Id : E; V : E) is\n    begin\n-      Set_Node15 (Id, V);\n+      Set_Node19 (Id, V);\n    end Set_Entry_Bodies_Array;\n \n    procedure Set_Entry_Cancel_Parameter (Id : E; V : E) is\n@@ -5386,7 +5393,7 @@ package body Einfo is\n    procedure Set_Lit_Indexes (Id : E; V : E) is\n    begin\n       pragma Assert (Is_Enumeration_Type (Id) and then Root_Type (Id) = Id);\n-      Set_Node15 (Id, V);\n+      Set_Node18 (Id, V);\n    end Set_Lit_Indexes;\n \n    procedure Set_Lit_Strings (Id : E; V : E) is\n@@ -5576,7 +5583,7 @@ package body Einfo is\n    procedure Set_Original_Access_Type (Id : E; V : E) is\n    begin\n       pragma Assert (Ekind (Id) = E_Access_Subprogram_Type);\n-      Set_Node26 (Id, V);\n+      Set_Node28 (Id, V);\n    end Set_Original_Access_Type;\n \n    procedure Set_Original_Array_Type (Id : E; V : E) is\n@@ -5625,6 +5632,12 @@ package body Einfo is\n       Set_Elist9 (Id, V);\n    end Set_Part_Of_Constituents;\n \n+   procedure Set_Pending_Access_Types (Id : E; V : L) is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      Set_Elist15 (Id, V);\n+   end Set_Pending_Access_Types;\n+\n    procedure Set_Postcondition_Proc (Id : E; V : E) is\n    begin\n       pragma Assert (Ekind (Id) = E_Procedure);\n@@ -5748,7 +5761,7 @@ package body Einfo is\n    procedure Set_Relative_Deadline_Variable (Id : E; V : E) is\n    begin\n       pragma Assert (Is_Task_Type (Id) and then Is_Base_Type (Id));\n-      Set_Node26 (Id, V);\n+      Set_Node28 (Id, V);\n    end Set_Relative_Deadline_Variable;\n \n    procedure Set_Renamed_Entity (Id : E; V : N) is\n@@ -5827,7 +5840,7 @@ package body Einfo is\n \n    procedure Set_Scale_Value (Id : E; V : U) is\n    begin\n-      Set_Uint15 (Id, V);\n+      Set_Uint16 (Id, V);\n    end Set_Scale_Value;\n \n    procedure Set_Scope_Depth_Value (Id : E; V : U) is\n@@ -5972,7 +5985,7 @@ package body Einfo is\n    begin\n       pragma Assert (Is_Access_Type (Id) or else Is_Task_Type (Id));\n       pragma Assert (Id = Base_Type (Id));\n-      Set_Node15 (Id, V);\n+      Set_Node26 (Id, V);\n    end Set_Storage_Size_Variable;\n \n    procedure Set_Static_Elaboration_Desired (Id : E; V : B) is\n@@ -6015,7 +6028,7 @@ package body Einfo is\n    procedure Set_String_Literal_Low_Bound (Id : E; V : N) is\n    begin\n       pragma Assert (Ekind (Id) = E_String_Literal_Subtype);\n-      Set_Node15 (Id, V);\n+      Set_Node18 (Id, V);\n    end Set_String_Literal_Low_Bound;\n \n    procedure Set_Subprograms_For_Type (Id : E; V : E) is\n@@ -9092,36 +9105,23 @@ package body Einfo is\n               E_Procedure                                  =>\n             Write_Str (\"DT_Position\");\n \n-         when E_Protected_Type                             =>\n-            Write_Str (\"Entry_Bodies_Array\");\n-\n          when Entry_Kind                                   =>\n             Write_Str (\"Entry_Parameters_Type\");\n \n          when Formal_Kind                                  =>\n             Write_Str (\"Extra_Formal\");\n \n-         when Enumeration_Kind                             =>\n-            Write_Str (\"Lit_Indexes\");\n+         when Type_Kind                                    =>\n+            Write_Str (\"Pending_Access_Types\");\n \n          when E_Package                                    |\n               E_Package_Body                               =>\n             Write_Str (\"Related_Instance\");\n \n-         when Decimal_Fixed_Point_Kind                     =>\n-            Write_Str (\"Scale_Value\");\n-\n          when E_Constant                                   |\n               E_Variable                                   =>\n             Write_Str (\"Status_Flag_Or_Transient_Decl\");\n \n-         when Access_Kind                                  |\n-              Task_Kind                                    =>\n-            Write_Str (\"Storage_Size_Variable\");\n-\n-         when E_String_Literal_Subtype                     =>\n-            Write_Str (\"String_Literal_Low_Bound\");\n-\n          when others                                       =>\n             Write_Str (\"Field15??\");\n       end case;\n@@ -9160,6 +9160,9 @@ package body Einfo is\n          when Enumeration_Kind                             =>\n             Write_Str (\"Lit_Strings\");\n \n+         when Decimal_Fixed_Point_Kind                     =>\n+            Write_Str (\"Scale_Value\");\n+\n          when E_String_Literal_Subtype                     =>\n             Write_Str (\"String_Literal_Length\");\n \n@@ -9282,6 +9285,9 @@ package body Einfo is\n          when Fixed_Point_Kind                             =>\n             Write_Str (\"Delta_Value\");\n \n+         when Enumeration_Kind                             =>\n+            Write_Str (\"Lit_Indexes\");\n+\n          when Incomplete_Or_Private_Kind                   |\n               E_Record_Subtype                             =>\n             Write_Str (\"Private_Dependents\");\n@@ -9296,6 +9302,9 @@ package body Einfo is\n               E_Generic_Package                            =>\n             Write_Str (\"Renamed_Entity\");\n \n+         when E_String_Literal_Subtype                     =>\n+            Write_Str (\"String_Literal_Low_Bound\");\n+\n          when others                                       =>\n             Write_Str (\"Field18??\");\n       end case;\n@@ -9321,6 +9330,14 @@ package body Einfo is\n          when E_Array_Type                                 =>\n             Write_Str (\"Default_Component_Value\");\n \n+         when E_Protected_Type                             =>\n+            Write_Str (\"Entry_Bodies_Array\");\n+\n+         when E_Function                                   |\n+              E_Operator                                   |\n+              E_Subprogram_Type                            =>\n+            Write_Str (\"Extra_Accessibility_Of_Result\");\n+\n          when E_Record_Type                                =>\n             Write_Str (\"Parent_Subtype\");\n \n@@ -9335,9 +9352,6 @@ package body Einfo is\n          when Private_Kind                                 =>\n             Write_Str (\"Underlying_Full_View\");\n \n-         when E_Function | E_Operator | E_Subprogram_Type =>\n-            Write_Str (\"Extra_Accessibility_Of_Result\");\n-\n          when others                                       =>\n             Write_Str (\"Field19??\");\n       end case;\n@@ -9648,8 +9662,9 @@ package body Einfo is\n               E_Variable                                   =>\n             Write_Str (\"Last_Assignment\");\n \n-         when E_Access_Subprogram_Type                     =>\n-            Write_Str (\"Original_Access_Type\");\n+         when E_Procedure                                  |\n+              E_Function                                   =>\n+            Write_Str (\"Overridden_Operation\");\n \n          when E_Generic_Package                            |\n               E_Package                                    =>\n@@ -9659,12 +9674,9 @@ package body Einfo is\n               E_Constant                                   =>\n             Write_Str (\"Related_Type\");\n \n-         when Task_Kind                                    =>\n-            Write_Str (\"Relative_Deadline_Variable\");\n-\n-         when E_Procedure                                  |\n-              E_Function                                   =>\n-            Write_Str (\"Overridden_Operation\");\n+         when Access_Kind                                  |\n+              Task_Kind                                    =>\n+            Write_Str (\"Storage_Size_Variable\");\n \n          when others                                       =>\n             Write_Str (\"Field26??\");\n@@ -9719,6 +9731,12 @@ package body Einfo is\n               E_Variable                                   =>\n             Write_Str (\"Initialization_Statements\");\n \n+         when E_Access_Subprogram_Type                     =>\n+            Write_Str (\"Original_Access_Type\");\n+\n+         when Task_Kind                                    =>\n+            Write_Str (\"Relative_Deadline_Variable\");\n+\n          when E_Record_Type =>\n             Write_Str (\"Underlying_Record_View\");\n \n@@ -9867,6 +9885,7 @@ package body Einfo is\n       case Ekind (Id) is\n          when Subprogram_Kind                              =>\n             Write_Str (\"Import_Pragma\");\n+\n          when others                                       =>\n             Write_Str (\"Field35??\");\n       end case;"}, {"sha": "0c9fb61c9175c4741b935d5d364073682f9656a2", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 32, "deletions": 19, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=760804f3b9b9127ea68abd96d1d96dc51c80f749", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1036,7 +1036,7 @@ package Einfo is\n --       at least one accept for this entry in the task body. Used to\n --       generate warnings for missing accepts.\n \n---    Entry_Bodies_Array (Node15)\n+--    Entry_Bodies_Array (Node19)\n --       Defined in protected types for which Has_Entries is true.\n --       This is the defining identifier for the array of entry body\n --       action procedures and barrier functions used by the runtime to\n@@ -3178,7 +3178,7 @@ package Einfo is\n --       field may be set as a result of a linker section pragma applied to the\n --       type of the object.\n \n---    Lit_Indexes (Node15)\n+--    Lit_Indexes (Node18)\n --       Defined in enumeration types and subtypes. Non-empty only for the\n --       case of an enumeration root type, where it contains the entity for\n --       the generated indexes entity. See unit Exp_Imgv for full details of\n@@ -3495,7 +3495,7 @@ package Einfo is\n --       Optimize_Alignment (Off) mode applies to the type/object, then neither\n --       of the flags Optimize_Alignment_Space/Optimize_Alignment_Time is set.\n \n---    Original_Access_Type (Node26)\n+--    Original_Access_Type (Node28)\n --       Defined in E_Access_Subprogram_Type entities. Set only if the access\n --       type was generated by the expander as part of processing an access\n --       to protected subprogram type. Points to the access to protected\n@@ -3578,6 +3578,14 @@ package Einfo is\n --       Present in abstract state entities. Contains all constituents that are\n --       subject to indicator Part_Of (both aspect and option variants).\n \n+--    Pending_Access_Types (Elist15)\n+--       Defined in all types. Set for incomplete, private, Taft-amendment\n+--       types, and their corresponding full views. This list contains all\n+--       access types, both named and anonymous, declared between the partial\n+--       and the full view. The list is used by the finalization machinery to\n+--       ensure that the finalization masters of all pending access types are\n+--       fully initialized when the full view is frozen.\n+\n --    Postcondition_Proc (Node8)\n --       Defined only in procedure entities, saves the entity of the generated\n --       postcondition proc if one is present, otherwise is set to Empty. Used\n@@ -3735,7 +3743,7 @@ package Einfo is\n --       associated dispatch table to point to entities containing primary or\n --       secondary tags. Not set in the _tag component of record types.\n \n---    Relative_Deadline_Variable (Node26) [implementation base type only]\n+--    Relative_Deadline_Variable (Node28) [implementation base type only]\n --       Defined in task type entities. This flag is set if a valid and\n --       effective pragma Relative_Deadline applies to the base type. Points\n --       to the entity for a variable that is created to hold the value given\n@@ -3852,7 +3860,7 @@ package Einfo is\n --       node (with a constraint), or a Range node, but not a simple\n --       subtype reference (a subtype is converted into a range).\n \n---    Scale_Value (Uint15)\n+--    Scale_Value (Uint16)\n --       Defined in decimal fixed-point types and subtypes. Contains the scale\n --       for the type (i.e. the value of type'Scale = the number of decimal\n --       digits after the decimal point).\n@@ -4043,7 +4051,7 @@ package Einfo is\n --       This attribute uses the same field as Overridden_Operation, which is\n --       irrelevant in init_procs.\n \n---    Storage_Size_Variable (Node15) [implementation base type only]\n+--    Storage_Size_Variable (Node26) [implementation base type only]\n --       Defined in access types and task type entities. This flag is set\n --       if a valid and effective pragma Storage_Size applies to the base\n --       type. Points to the entity for a variable that is created to\n@@ -4073,7 +4081,7 @@ package Einfo is\n --       to string literals in the program). Contains the length of the string\n --       literal.\n \n---    String_Literal_Low_Bound (Node15)\n+--    String_Literal_Low_Bound (Node18)\n --       Defined in string literal subtypes (which are created to correspond\n --       to string literals in the program). Contains an expression whose\n --       value represents the low bound of the literal. This is a copy of\n@@ -5280,6 +5288,7 @@ package Einfo is\n    --    Esize                               (Uint12)\n    --    RM_Size                             (Uint13)\n    --    Alignment                           (Uint14)\n+   --    Pending_Access_Types                (Elist15)\n    --    Related_Expression                  (Node24)\n    --    Current_Use_Clause                  (Node27)\n    --    Subprograms_For_Type                (Node29)\n@@ -5396,17 +5405,17 @@ package Einfo is\n    --    Directly_Designated_Type            (Node20)\n    --    Interface_Name                      (Node21)   (JGNAT usage only)\n    --    Needs_No_Actuals                    (Flag22)\n-   --    Original_Access_Type                (Node26)\n+   --    Original_Access_Type                (Node28)\n    --    Can_Use_Internal_Rep                (Flag229)\n    --    (plus type attributes)\n \n    --  E_Access_Type\n    --  E_Access_Subtype\n-   --    Storage_Size_Variable               (Node15)   (base type only)\n    --    Master_Id                           (Node17)\n    --    Directly_Designated_Type            (Node20)\n    --    Associated_Storage_Pool             (Node22)   (base type only)\n    --    Finalization_Master                 (Node23)   (base type only)\n+   --    Storage_Size_Variable               (Node26)   (base type only)\n    --    Has_Pragma_Controlled               (Flag27)   (base type only)\n    --    Has_Storage_Size_Clause             (Flag23)   (base type only)\n    --    Is_Access_Constant                  (Flag69)\n@@ -5426,15 +5435,15 @@ package Einfo is\n \n    --  E_Anonymous_Access_Subprogram_Type\n    --  E_Anonymous_Access_Protected_Subprogram_Type\n-   --    Storage_Size_Variable               (Node15)   ??? is this needed ???\n    --    Directly_Designated_Type            (Node20)\n+   --    Storage_Size_Variable               (Node26)   ??? is this needed ???\n    --    Can_Use_Internal_Rep                (Flag229)\n    --    (plus type attributes)\n \n    --  E_Anonymous_Access_Type\n-   --    Storage_Size_Variable               (Node15)   ??? is this needed ???\n    --    Directly_Designated_Type            (Node20)\n    --    Finalization_Master                 (Node23)\n+   --    Storage_Size_Variable               (Node26)   ??? is this needed ???\n    --    (plus type attributes)\n \n    --  E_Array_Type\n@@ -5558,7 +5567,7 @@ package Einfo is\n \n    --  E_Decimal_Fixed_Point_Type\n    --  E_Decimal_Fixed_Subtype\n-   --    Scale_Value                         (Uint15)\n+   --    Scale_Value                         (Uint16)\n    --    Digits_Value                        (Uint17)\n    --    Scalar_Range                        (Node20)\n    --    Delta_Value                         (Ureal18)\n@@ -5631,9 +5640,9 @@ package Einfo is\n \n    --  E_Enumeration_Type\n    --  E_Enumeration_Subtype\n-   --    Lit_Indexes                         (Node15)   (root type only)\n    --    Lit_Strings                         (Node16)   (root type only)\n    --    First_Literal                       (Node17)\n+   --    Lit_Indexes                         (Node18)   (root type only)\n    --    Default_Aspect_Value                (Node19)   (base type only)\n    --    Scalar_Range                        (Node20)\n    --    Enum_Pos_To_Rep                     (Node23)   (type only)\n@@ -5768,11 +5777,11 @@ package Einfo is\n    --    Scope_Depth                         (synth)\n \n    --  E_General_Access_Type\n-   --    Storage_Size_Variable               (Node15)   (base type only)\n    --    Master_Id                           (Node17)\n    --    Directly_Designated_Type            (Node20)\n    --    Associated_Storage_Pool             (Node22)   (root type only)\n    --    Finalization_Master                 (Node23)   (root type only)\n+   --    Storage_Size_Variable               (Node26)   (base type only)\n    --    (plus type attributes)\n \n    --  E_Generic_In_Parameter\n@@ -6072,10 +6081,10 @@ package Einfo is\n    --  E_Protected_Type\n    --  E_Protected_Subtype\n    --    Direct_Primitive_Operations         (Elist10)\n-   --    Entry_Bodies_Array                  (Node15)\n    --    First_Private_Entity                (Node16)\n    --    First_Entity                        (Node17)\n    --    Corresponding_Record_Type           (Node18)\n+   --    Entry_Bodies_Array                  (Node19)\n    --    Last_Entity                         (Node20)\n    --    Discriminant_Constraint             (Elist21)\n    --    Scope_Depth_Value                   (Uint22)\n@@ -6170,9 +6179,9 @@ package Einfo is\n    --    (plus type attributes)\n \n    --  E_String_Literal_Subtype\n-   --    String_Literal_Low_Bound            (Node15)\n    --    String_Literal_Length               (Uint16)\n    --    First_Index                         (Node17)   (always Empty)\n+   --    String_Literal_Low_Bound            (Node18)\n    --    Packed_Array_Impl_Type              (Node23)\n    --    (plus type attributes)\n \n@@ -6205,7 +6214,6 @@ package Einfo is\n    --  E_Task_Type\n    --  E_Task_Subtype\n    --    Direct_Primitive_Operations         (Elist10)\n-   --    Storage_Size_Variable               (Node15)   (base type only)\n    --    First_Private_Entity                (Node16)\n    --    First_Entity                        (Node17)\n    --    Corresponding_Record_Type           (Node18)\n@@ -6215,14 +6223,15 @@ package Einfo is\n    --    Scope_Depth                         (synth)\n    --    Stored_Constraint                   (Elist23)\n    --    Task_Body_Procedure                 (Node25)\n+   --    Storage_Size_Variable               (Node26)   (base type only)\n+   --    Relative_Deadline_Variable          (Node28)   (base type only)\n    --    Delay_Cleanups                      (Flag114)\n    --    Has_Master_Entity                   (Flag21)\n    --    Has_Storage_Size_Clause             (Flag23)   (base type only)\n    --    Uses_Sec_Stack                      (Flag95)   ???\n    --    Sec_Stack_Needed_For_Return         (Flag167)  ???\n    --    Has_Entries                         (synth)\n    --    Number_Entries                      (synth)\n-   --    Relative_Deadline_Variable          (Node26)   (base type only)\n    --    (plus type attributes)\n \n    --  E_Variable\n@@ -6868,6 +6877,7 @@ package Einfo is\n    function Packed_Array_Impl_Type              (Id : E) return E;\n    function Parent_Subtype                      (Id : E) return E;\n    function Part_Of_Constituents                (Id : E) return L;\n+   function Pending_Access_Types                (Id : E) return L;\n    function Postcondition_Proc                  (Id : E) return E;\n    function Prival                              (Id : E) return E;\n    function Prival_Link                         (Id : E) return E;\n@@ -7514,6 +7524,7 @@ package Einfo is\n    procedure Set_Packed_Array_Impl_Type          (Id : E; V : E);\n    procedure Set_Parent_Subtype                  (Id : E; V : E);\n    procedure Set_Part_Of_Constituents            (Id : E; V : L);\n+   procedure Set_Pending_Access_Types            (Id : E; V : L);\n    procedure Set_Postcondition_Proc              (Id : E; V : E);\n    procedure Set_Prival                          (Id : E; V : E);\n    procedure Set_Prival_Link                     (Id : E; V : E);\n@@ -8312,6 +8323,7 @@ package Einfo is\n    pragma Inline (Parameter_Mode);\n    pragma Inline (Parent_Subtype);\n    pragma Inline (Part_Of_Constituents);\n+   pragma Inline (Pending_Access_Types);\n    pragma Inline (Postcondition_Proc);\n    pragma Inline (Prival);\n    pragma Inline (Prival_Link);\n@@ -8757,6 +8769,7 @@ package Einfo is\n    pragma Inline (Set_Packed_Array_Impl_Type);\n    pragma Inline (Set_Parent_Subtype);\n    pragma Inline (Set_Part_Of_Constituents);\n+   pragma Inline (Set_Pending_Access_Types);\n    pragma Inline (Set_Postcondition_Proc);\n    pragma Inline (Set_Prival);\n    pragma Inline (Set_Prival_Link);"}, {"sha": "2a4b08750034b2436d728af21c95ffdf224f6f72", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 142, "deletions": 48, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=760804f3b9b9127ea68abd96d1d96dc51c80f749", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2395,16 +2395,14 @@ package body Exp_Ch3 is\n                      declare\n                         Parent_IP : constant Name_Id :=\n                                       Make_Init_Proc_Name (Etype (Rec_Ent));\n-                        Stmt      : Node_Id;\n-                        IP_Call   : Node_Id;\n+                        Stmt      : Node_Id := First (Stmts);\n+                        IP_Call   : Node_Id := Empty;\n                         IP_Stmts  : List_Id;\n \n                      begin\n                         --  Look for a call to the parent IP at the beginning\n                         --  of Stmts associated with the record extension\n \n-                        Stmt := First (Stmts);\n-                        IP_Call := Empty;\n                         while Present (Stmt) loop\n                            if Nkind (Stmt) = N_Procedure_Call_Statement\n                              and then Chars (Name (Stmt)) = Parent_IP\n@@ -6318,8 +6316,9 @@ package body Exp_Ch3 is\n \n    procedure Expand_Freeze_Array_Type (N : Node_Id) is\n       Typ      : constant Entity_Id := Entity (N);\n-      Comp_Typ : constant Entity_Id := Component_Type (Typ);\n       Base     : constant Entity_Id := Base_Type (Typ);\n+      Comp_Typ : constant Entity_Id := Component_Type (Typ);\n+      Ins_Node : Node_Id;\n \n    begin\n       if not Is_Bit_Packed_Array (Typ) then\n@@ -6386,10 +6385,22 @@ package body Exp_Ch3 is\n             if Ekind (Comp_Typ) = E_Anonymous_Access_Type\n               and then Needs_Finalization (Designated_Type (Comp_Typ))\n             then\n+               --  The finalization master is inserted before the declaration\n+               --  of the array type. The only exception to this is when the\n+               --  array type is an itype, in which case the master appears\n+               --  before the related context.\n+\n+               if Is_Itype (Typ) then\n+                  Ins_Node := Associated_Node_For_Itype (Typ);\n+               else\n+                  Ins_Node := Parent (Typ);\n+               end if;\n+\n                Build_Finalization_Master\n-                 (Typ        => Comp_Typ,\n-                  Ins_Node   => Parent (Typ),\n-                  Encl_Scope => Scope (Typ));\n+                 (Typ            => Comp_Typ,\n+                  For_Anonymous  => True,\n+                  Context_Scope  => Scope (Typ),\n+                  Insertion_Node => Ins_Node);\n             end if;\n          end if;\n \n@@ -7342,9 +7353,10 @@ package body Exp_Ch3 is\n                           (Root_Type (Comp_Typ), RTE (RE_Global_Pool_Object));\n \n                         Build_Finalization_Master\n-                          (Typ        => Root_Type (Comp_Typ),\n-                           Ins_Node   => Ins_Node,\n-                           Encl_Scope => Encl_Scope);\n+                          (Typ            => Root_Type (Comp_Typ),\n+                           For_Anonymous  => True,\n+                           Context_Scope  => Encl_Scope,\n+                           Insertion_Node => Ins_Node);\n \n                         Fin_Mas_Id := Finalization_Master (Comp_Typ);\n \n@@ -7387,9 +7399,10 @@ package body Exp_Ch3 is\n \n                   else\n                      Build_Finalization_Master\n-                       (Typ        => Comp_Typ,\n-                        Ins_Node   => Ins_Node,\n-                        Encl_Scope => Encl_Scope);\n+                       (Typ            => Comp_Typ,\n+                        For_Anonymous  => True,\n+                        Context_Scope  => Encl_Scope,\n+                        Insertion_Node => Ins_Node);\n                   end if;\n                end if;\n \n@@ -7466,9 +7479,97 @@ package body Exp_Ch3 is\n       --  Save the current Ghost mode in effect in case the type being frozen\n       --  sets a different mode.\n \n+      procedure Process_RACW_Types (Typ : Entity_Id);\n+      --  Validate and generate stubs for all RACW types associated with type\n+      --  Typ.\n+\n+      procedure Process_Pending_Access_Types (Typ : Entity_Id);\n+      --  Associate type Typ's Finalize_Address primitive with the finalization\n+      --  masters of pending access-to-Typ types.\n+\n       procedure Restore_Globals;\n       --  Restore the values of all saved global variables\n \n+      ------------------------\n+      -- Process_RACW_Types --\n+      ------------------------\n+\n+      procedure Process_RACW_Types (Typ : Entity_Id) is\n+         List : constant Elist_Id := Access_Types_To_Process (N);\n+         E    : Elmt_Id;\n+         Seen : Boolean := False;\n+\n+      begin\n+         if Present (List) then\n+            E := First_Elmt (List);\n+            while Present (E) loop\n+               if Is_Remote_Access_To_Class_Wide_Type (Node (E)) then\n+                  Validate_RACW_Primitives (Node (E));\n+                  Seen := True;\n+               end if;\n+\n+               Next_Elmt (E);\n+            end loop;\n+         end if;\n+\n+         --  If there are RACWs designating this type, make stubs now\n+\n+         if Seen then\n+            Remote_Types_Tagged_Full_View_Encountered (Typ);\n+         end if;\n+      end Process_RACW_Types;\n+\n+      ----------------------------------\n+      -- Process_Pending_Access_Types --\n+      ----------------------------------\n+\n+      procedure Process_Pending_Access_Types (Typ : Entity_Id) is\n+         E : Elmt_Id;\n+\n+      begin\n+         --  Finalize_Address is not generated in CodePeer mode because the\n+         --  body contains address arithmetic. This processing is disabled.\n+\n+         if CodePeer_Mode then\n+            null;\n+\n+         --  Certain itypes are generated for contexts that cannot allocate\n+         --  objects and should not set primitive Finalize_Address.\n+\n+         elsif Is_Itype (Typ)\n+           and then Nkind (Associated_Node_For_Itype (Typ)) =\n+                      N_Explicit_Dereference\n+         then\n+            null;\n+\n+         --  When an access type is declared after the incomplete view of a\n+         --  Taft-amendment type, the access type is considered pending in\n+         --  case the full view of the Taft-amendment type is controlled. If\n+         --  this is indeed the case, associate the Finalize_Address routine\n+         --  of the full view with the finalization masters of all pending\n+         --  access types. This scenario applies to anonymous access types as\n+         --  well.\n+\n+         elsif Needs_Finalization (Typ)\n+           and then Present (Pending_Access_Types (Typ))\n+         then\n+            E := First_Elmt (Pending_Access_Types (Typ));\n+            while Present (E) loop\n+\n+               --  Generate:\n+               --    Set_Finalize_Address\n+               --      (Ptr_Typ, <Typ>FD'Unrestricted_Access);\n+\n+               Append_Freeze_Action (Typ,\n+                 Make_Set_Finalize_Address_Call\n+                   (Loc     => Sloc (N),\n+                    Ptr_Typ => Node (E)));\n+\n+               Next_Elmt (E);\n+            end loop;\n+         end if;\n+      end Process_Pending_Access_Types;\n+\n       ---------------------\n       -- Restore_Globals --\n       ---------------------\n@@ -7480,9 +7581,8 @@ package body Exp_Ch3 is\n \n       --  Local variables\n \n-      Def_Id    : constant Entity_Id := Entity (N);\n-      RACW_Seen : Boolean := False;\n-      Result    : Boolean := False;\n+      Def_Id : constant Entity_Id := Entity (N);\n+      Result : Boolean := False;\n \n    --  Start of processing for Freeze_Type\n \n@@ -7493,29 +7593,10 @@ package body Exp_Ch3 is\n \n       Set_Ghost_Mode_For_Freeze (Def_Id, N);\n \n-      --  Process associated access types needing special processing\n-\n-      if Present (Access_Types_To_Process (N)) then\n-         declare\n-            E : Elmt_Id := First_Elmt (Access_Types_To_Process (N));\n-\n-         begin\n-            while Present (E) loop\n-               if Is_Remote_Access_To_Class_Wide_Type (Node (E)) then\n-                  Validate_RACW_Primitives (Node (E));\n-                  RACW_Seen := True;\n-               end if;\n-\n-               E := Next_Elmt (E);\n-            end loop;\n-         end;\n-\n-         --  If there are RACWs designating this type, make stubs now\n+      --  Process any remote access-to-class-wide types designating the type\n+      --  being frozen.\n \n-         if RACW_Seen then\n-            Remote_Types_Tagged_Full_View_Encountered (Def_Id);\n-         end if;\n-      end if;\n+      Process_RACW_Types (Def_Id);\n \n       --  Freeze processing for record types\n \n@@ -7760,18 +7841,26 @@ package body Exp_Ch3 is\n             then\n                null;\n \n-            --  Assume that incomplete and private types are always completed\n-            --  by a controlled full view.\n+            --  Create a finalization master for an access-to-controlled type\n+            --  or an access-to-incomplete type. It is assumed that the full\n+            --  view will be controlled.\n \n             elsif Needs_Finalization (Desig_Type)\n-              or else\n-                (Is_Incomplete_Or_Private_Type (Desig_Type)\n-                  and then No (Full_View (Desig_Type)))\n-              or else\n-                (Is_Array_Type (Desig_Type)\n-                  and then Needs_Finalization (Component_Type (Desig_Type)))\n+              or else (Is_Incomplete_Type (Desig_Type)\n+                         and then No (Full_View (Desig_Type)))\n             then\n                Build_Finalization_Master (Def_Id);\n+\n+            --  Create a finalization master when the designated type contains\n+            --  a private component. It is assumed that the full view will be\n+            --  controlled.\n+\n+            elsif Has_Private_Component (Desig_Type) then\n+               Build_Finalization_Master\n+                 (Typ            => Def_Id,\n+                  For_Private    => True,\n+                  Context_Scope  => Scope (Def_Id),\n+                  Insertion_Node => Declaration_Node (Desig_Type));\n             end if;\n          end;\n \n@@ -7810,6 +7899,11 @@ package body Exp_Ch3 is\n \n       end if;\n \n+      --  Complete the initialization of all pending access types' finalization\n+      --  masters now that the designated type has been is frozen and primitive\n+      --  Finalize_Address generated.\n+\n+      Process_Pending_Access_Types (Def_Id);\n       Freeze_Stream_Operations (N, Def_Id);\n \n       Restore_Globals;"}, {"sha": "98b24a9a6a138b33a1723d571f72f8b87e93e85c", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 14, "deletions": 56, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=760804f3b9b9127ea68abd96d1d96dc51c80f749", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1278,30 +1278,6 @@ package body Exp_Ch4 is\n                           Prefix => New_Occurrence_Of (Temp, Loc))),\n                     Typ     => T));\n             end if;\n-\n-            --  Generate:\n-            --    Set_Finalize_Address (<PtrT>FM, <T>FD'Unrestricted_Access);\n-\n-            --  Do not generate this call in the following cases:\n-\n-            --    * .NET/JVM - these targets do not support address arithmetic\n-            --    and unchecked conversion, key elements of Finalize_Address.\n-\n-            --    * CodePeer mode - TSS primitive Finalize_Address is not\n-            --    created in this mode.\n-\n-            if VM_Target = No_VM\n-              and then not CodePeer_Mode\n-              and then Present (Finalization_Master (PtrT))\n-              and then Present (Temp_Decl)\n-              and then Nkind (Expression (Temp_Decl)) = N_Allocator\n-            then\n-               Insert_Action (N,\n-                 Make_Set_Finalize_Address_Call\n-                   (Loc     => Loc,\n-                    Typ     => T,\n-                    Ptr_Typ => PtrT));\n-            end if;\n          end if;\n \n          Rewrite (N, New_Occurrence_Of (Temp, Loc));\n@@ -4868,40 +4844,22 @@ package body Exp_Ch4 is\n                       (Obj_Ref => New_Copy_Tree (Init_Arg1),\n                        Typ     => T));\n \n-                  if Present (Finalization_Master (PtrT)) then\n-\n-                     --  Special processing for .NET/JVM, the allocated object\n-                     --  is attached to the finalization master. Generate:\n-\n-                     --    Attach (<PtrT>FM, Root_Controlled_Ptr (Init_Arg1));\n+                  --  Special processing for .NET/JVM, the allocated object is\n+                  --  attached to the finalization master. Generate:\n \n-                     --  Types derived from [Limited_]Controlled are the only\n-                     --  ones considered since they have fields Prev and Next.\n-\n-                     if VM_Target /= No_VM then\n-                        if Is_Controlled (T) then\n-                           Insert_Action (N,\n-                             Make_Attach_Call\n-                               (Obj_Ref => New_Copy_Tree (Init_Arg1),\n-                                Ptr_Typ => PtrT));\n-                        end if;\n+                  --    Attach (<PtrT>FM, Root_Controlled_Ptr (Init_Arg1));\n \n-                     --  Default case, generate:\n+                  --  Types derived from [Limited_]Controlled are the only ones\n+                  --  considered since they have fields Prev and Next.\n \n-                     --    Set_Finalize_Address\n-                     --      (<PtrT>FM, <T>FD'Unrestricted_Access);\n-\n-                     --  Do not generate this call in CodePeer mode, as TSS\n-                     --  primitive Finalize_Address is not created in this\n-                     --  mode.\n-\n-                     elsif not CodePeer_Mode then\n-                        Insert_Action (N,\n-                          Make_Set_Finalize_Address_Call\n-                            (Loc     => Loc,\n-                             Typ     => T,\n-                             Ptr_Typ => PtrT));\n-                     end if;\n+                  if VM_Target /= No_VM\n+                    and then Is_Controlled (T)\n+                    and then Present (Finalization_Master (PtrT))\n+                  then\n+                     Insert_Action (N,\n+                       Make_Attach_Call\n+                         (Obj_Ref => New_Copy_Tree (Init_Arg1),\n+                          Ptr_Typ => PtrT));\n                   end if;\n                end if;\n "}, {"sha": "577637042281b82596e96782002a57e404040a5f", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 5, "deletions": 31, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=760804f3b9b9127ea68abd96d1d96dc51c80f749", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -415,9 +415,10 @@ package body Exp_Ch6 is\n                  and then No (Finalization_Master (Ptr_Typ))\n                then\n                   Build_Finalization_Master\n-                    (Typ        => Ptr_Typ,\n-                     Ins_Node   => Associated_Node_For_Itype (Ptr_Typ),\n-                     Encl_Scope => Scope (Ptr_Typ));\n+                    (Typ            => Ptr_Typ,\n+                     For_Anonymous  => True,\n+                     Context_Scope  => Scope (Ptr_Typ),\n+                     Insertion_Node => Associated_Node_For_Itype (Ptr_Typ));\n                end if;\n \n                --  Access-to-controlled types should always have a master\n@@ -8357,33 +8358,6 @@ package body Exp_Ch6 is\n       Add_Access_Actual_To_Build_In_Place_Call\n         (Func_Call, Function_Id, Return_Obj_Actual);\n \n-      --  If the build-in-place function call returns a controlled object,\n-      --  the finalization master will require a reference to routine\n-      --  Finalize_Address of the designated type. Setting this attribute\n-      --  is done in the same manner to expansion of allocators.\n-\n-      if Needs_Finalization (Result_Subt) then\n-\n-         --  Controlled types with supressed finalization do not need to\n-         --  associate the address of their Finalize_Address primitives with\n-         --  a master since they do not need a master to begin with.\n-\n-         if Is_Library_Level_Entity (Acc_Type)\n-           and then Finalize_Storage_Only (Result_Subt)\n-         then\n-            null;\n-\n-         --  Do not generate the call to Set_Finalize_Address in CodePeer mode\n-         --  because Finalize_Address is never built.\n-\n-         elsif not CodePeer_Mode then\n-            Insert_Action (Allocator,\n-              Make_Set_Finalize_Address_Call (Loc,\n-                Typ     => Etype (Function_Id),\n-                Ptr_Typ => Acc_Type));\n-         end if;\n-      end if;\n-\n       --  Finally, replace the allocator node with a reference to the temp\n \n       Rewrite (Allocator, New_Occurrence_Of (Return_Obj_Access, Loc));"}, {"sha": "a9a242e9b232c7435601b16659315438431bfaf0", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 129, "deletions": 132, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=760804f3b9b9127ea68abd96d1d96dc51c80f749", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -764,14 +764,42 @@ package body Exp_Ch7 is\n    -------------------------------\n \n    procedure Build_Finalization_Master\n-     (Typ        : Entity_Id;\n-      Ins_Node   : Node_Id := Empty;\n-      Encl_Scope : Entity_Id := Empty)\n+     (Typ            : Entity_Id;\n+      For_Anonymous  : Boolean   := False;\n+      For_Private    : Boolean   := False;\n+      Context_Scope  : Entity_Id := Empty;\n+      Insertion_Node : Node_Id   := Empty)\n    is\n+      procedure Add_Pending_Access_Type\n+        (Typ     : Entity_Id;\n+         Ptr_Typ : Entity_Id);\n+      --  Add access type Ptr_Typ to the pending access type list for type Typ\n+\n       function In_Deallocation_Instance (E : Entity_Id) return Boolean;\n       --  Determine whether entity E is inside a wrapper package created for\n       --  an instance of Ada.Unchecked_Deallocation.\n \n+      -----------------------------\n+      -- Add_Pending_Access_Type --\n+      -----------------------------\n+\n+      procedure Add_Pending_Access_Type\n+        (Typ     : Entity_Id;\n+         Ptr_Typ : Entity_Id)\n+      is\n+         List : Elist_Id;\n+\n+      begin\n+         if Present (Pending_Access_Types (Typ)) then\n+            List := Pending_Access_Types (Typ);\n+         else\n+            List := New_Elmt_List;\n+            Set_Pending_Access_Types (Typ, List);\n+         end if;\n+\n+         Prepend_Elmt (Ptr_Typ, List);\n+      end Add_Pending_Access_Type;\n+\n       ------------------------------\n       -- In_Deallocation_Instance --\n       ------------------------------\n@@ -799,7 +827,7 @@ package body Exp_Ch7 is\n \n       --  Local variables\n \n-      Desig_Typ : constant Entity_Id := Directly_Designated_Type (Typ);\n+      Desig_Typ : constant Entity_Id := Designated_Type (Typ);\n \n       Ptr_Typ : constant Entity_Id := Root_Type_Of_Full_View (Base_Type (Typ));\n       --  A finalization master created for a named access type is associated\n@@ -855,7 +883,7 @@ package body Exp_Ch7 is\n       --  requires a finalization master.\n \n       elsif Ekind (Ptr_Typ) = E_Anonymous_Access_Type\n-        and then No (Ins_Node)\n+        and then not For_Anonymous\n       then\n          return;\n \n@@ -874,25 +902,21 @@ package body Exp_Ch7 is\n       elsif VM_Target /= No_VM and then not Is_Controlled (Desig_Typ) then\n          return;\n \n-      --  Do not create finalization masters in SPARK mode because they result\n-      --  in unwanted expansion.\n-\n-      --  More detail would be useful here ???\n+      --  Do not create finalization masters in GNATprove mode because this\n+      --  unwanted extra expansion. A compilation in this mode keeps the tree\n+      --  as close as possible to the original sources.\n \n       elsif GNATprove_Mode then\n          return;\n       end if;\n \n       declare\n+         Actions    : constant List_Id    := New_List;\n          Loc        : constant Source_Ptr := Sloc (Ptr_Typ);\n-         Actions    : constant List_Id := New_List;\n          Fin_Mas_Id : Entity_Id;\n          Pool_Id    : Entity_Id;\n \n       begin\n-         --  Generate:\n-         --    Fnn : aliased Finalization_Master;\n-\n          --  Source access types use fixed master names since the master is\n          --  inserted in the same source unit only once. The only exception to\n          --  this are instances using the same access type as generic actual.\n@@ -910,34 +934,38 @@ package body Exp_Ch7 is\n             Fin_Mas_Id := Make_Temporary (Loc, 'F');\n          end if;\n \n+         Set_Finalization_Master (Ptr_Typ, Fin_Mas_Id);\n+\n+         --  Generate:\n+         --    <Ptr_Typ>FM : aliased Finalization_Master;\n+\n          Append_To (Actions,\n            Make_Object_Declaration (Loc,\n              Defining_Identifier => Fin_Mas_Id,\n              Aliased_Present     => True,\n              Object_Definition   =>\n                New_Occurrence_Of (RTE (RE_Finalization_Master), Loc)));\n \n-         --  Storage pool selection and attribute decoration of the generated\n-         --  master. Since .NET/JVM compilers do not support pools, this step\n-         --  is skipped.\n+         --  Set the associated pool and primitive Finalize_Address of the new\n+         --  finalization master. This step is skipped on .NET/JVM because the\n+         --  target does not support storage pools or address arithmetic.\n \n          if VM_Target = No_VM then\n \n-            --  If the access type has a user-defined pool, use it as the base\n-            --  storage medium for the finalization pool.\n+            --  The access type has a user-defined storage pool, use it\n \n             if Present (Associated_Storage_Pool (Ptr_Typ)) then\n                Pool_Id := Associated_Storage_Pool (Ptr_Typ);\n \n-            --  The default choice is the global pool\n+            --  Otherwise the default choice is the global storage pool\n \n             else\n                Pool_Id := RTE (RE_Global_Pool_Object);\n                Set_Associated_Storage_Pool (Ptr_Typ, Pool_Id);\n             end if;\n \n             --  Generate:\n-            --    Set_Base_Pool (Fnn, Pool_Id'Unchecked_Access);\n+            --    Set_Base_Pool (<Ptr_Typ>FM, Pool_Id'Unchecked_Access);\n \n             Append_To (Actions,\n               Make_Procedure_Call_Statement (Loc,\n@@ -948,67 +976,90 @@ package body Exp_Ch7 is\n                   Make_Attribute_Reference (Loc,\n                     Prefix         => New_Occurrence_Of (Pool_Id, Loc),\n                     Attribute_Name => Name_Unrestricted_Access))));\n+\n+            --  Finalize_Address is not generated in CodePeer mode because the\n+            --  body contains address arithmetic. Skip this step.\n+\n+            if CodePeer_Mode then\n+               null;\n+\n+            --  Associate the Finalize_Address primitive of the designated type\n+            --  with the finalization master of the access type. The designated\n+            --  type must be forzen as Finalize_Address is generated when the\n+            --  freeze node is expanded.\n+\n+            elsif Is_Frozen (Desig_Typ)\n+              and then Present (Finalize_Address (Desig_Typ))\n+\n+              --  The finalization master of an anonymous access type may need\n+              --  to be inserted in a specific place in the tree. For instance:\n+\n+              --    type Comp_Typ;\n+\n+              --    <finalization master of \"access Comp_Typ\">\n+\n+              --    type Rec_Typ is record\n+              --       Comp : access Comp_Typ;\n+              --    end record;\n+\n+              --    <freeze node for Comp_Typ>\n+              --    <freeze node for Rec_Typ>\n+\n+              --  Due to this oddity, the anonymous access type is stored for\n+              --  later processing (see below).\n+\n+              and then Ekind (Ptr_Typ) /= E_Anonymous_Access_Type\n+            then\n+               --  Generate:\n+               --    Set_Finalize_Address\n+               --      (<Ptr_Typ>FM, <Desig_Typ>FD'Unrestricted_Access);\n+\n+               Append_To (Actions,\n+                 Make_Set_Finalize_Address_Call\n+                   (Loc     => Loc,\n+                    Ptr_Typ => Ptr_Typ));\n+\n+            --  Otherwise the designated type is either anonymous access or a\n+            --  Taft-amendment type and has not been frozen. Store the access\n+            --  type for later processing (see Freeze_Type).\n+\n+            else\n+               Add_Pending_Access_Type (Desig_Typ, Ptr_Typ);\n+            end if;\n          end if;\n \n-         Set_Finalization_Master (Ptr_Typ, Fin_Mas_Id);\n+         --  A finalization master created for an anonymous access type or an\n+         --  access designating a type with private components must be inserted\n+         --  before a context-dependent node.\n \n-         --  A finalization master created for an anonymous access type must be\n-         --  inserted before a context-dependent node.\n+         if For_Anonymous or For_Private then\n \n-         if Present (Ins_Node) then\n-            Push_Scope (Encl_Scope);\n+            --  At this point both the scope of the context and the insertion\n+            --  mode must be known.\n+\n+            pragma Assert (Present (Context_Scope));\n+            pragma Assert (Present (Insertion_Node));\n+\n+            Push_Scope (Context_Scope);\n \n             --  Treat use clauses as declarations and insert directly in front\n             --  of them.\n \n-            if Nkind_In (Ins_Node, N_Use_Package_Clause,\n-                                   N_Use_Type_Clause)\n+            if Nkind_In (Insertion_Node, N_Use_Package_Clause,\n+                                         N_Use_Type_Clause)\n             then\n-               Insert_List_Before_And_Analyze (Ins_Node, Actions);\n+               Insert_List_Before_And_Analyze (Insertion_Node, Actions);\n             else\n-               Insert_Actions (Ins_Node, Actions);\n+               Insert_Actions (Insertion_Node, Actions);\n             end if;\n \n             Pop_Scope;\n \n-         elsif Ekind (Desig_Typ) = E_Incomplete_Type\n-           and then Has_Completion_In_Body (Desig_Typ)\n-         then\n-            Insert_Actions (Parent (Ptr_Typ), Actions);\n-\n-         --  If the designated type is not yet frozen, then append the actions\n-         --  to that type's freeze actions. The actions need to be appended to\n-         --  whichever type is frozen later, similarly to what Freeze_Type does\n-         --  for appending the storage pool declaration for an access type.\n-         --  Otherwise, the call to Set_Storage_Pool_Ptr might reference the\n-         --  pool object before it's declared. However, it's not clear that\n-         --  this is exactly the right test to accomplish that here. ???\n-\n-         elsif Present (Freeze_Node (Desig_Typ))\n-           and then not Analyzed (Freeze_Node (Desig_Typ))\n-         then\n-            Append_Freeze_Actions (Desig_Typ, Actions);\n-\n-         elsif Present (Freeze_Node (Ptr_Typ))\n-           and then not Analyzed (Freeze_Node (Ptr_Typ))\n-         then\n-            Append_Freeze_Actions (Ptr_Typ, Actions);\n-\n-         --  If there's a pool created locally for the access type, then we\n-         --  need to ensure that the master gets created after the pool object,\n-         --  because otherwise we can have a forward reference, so we force the\n-         --  master actions to be inserted and analyzed after the pool entity.\n-         --  Note that both the access type and its designated type may have\n-         --  already been frozen and had their freezing actions analyzed at\n-         --  this point. (This seems a little unclean.???)\n-\n-         elsif VM_Target = No_VM\n-           and then Scope (Pool_Id) = Scope (Ptr_Typ)\n-         then\n-            Insert_List_After_And_Analyze (Parent (Pool_Id), Actions);\n+         --  Otherwise the finalization master and its initialization become a\n+         --  part of the freeze node.\n \n          else\n-            Insert_Actions (Parent (Ptr_Typ), Actions);\n+            Append_Freeze_Actions (Ptr_Typ, Actions);\n          end if;\n       end;\n    end Build_Finalization_Master;\n@@ -7397,7 +7448,6 @@ package body Exp_Ch7 is\n       --  do not need the Finalize_Address primitive.\n \n       elsif not Needs_Finalization (Typ)\n-        or else Is_Abstract_Type (Typ)\n         or else Present (TSS (Typ, TSS_Finalize_Address))\n         or else\n           (Is_Class_Wide_Type (Typ)\n@@ -7801,85 +7851,32 @@ package body Exp_Ch7 is\n \n    function Make_Set_Finalize_Address_Call\n      (Loc     : Source_Ptr;\n-      Typ     : Entity_Id;\n       Ptr_Typ : Entity_Id) return Node_Id\n    is\n-      Desig_Typ   : constant Entity_Id :=\n-                      Available_View (Designated_Type (Ptr_Typ));\n-      Fin_Mas_Id  : constant Entity_Id := Finalization_Master (Ptr_Typ);\n-      Fin_Mas_Ref : Node_Id;\n-      Utyp        : Entity_Id;\n+      Desig_Typ : constant Entity_Id :=\n+                    Available_View (Designated_Type (Ptr_Typ));\n+      Fin_Addr  : constant Entity_Id := Finalize_Address (Desig_Typ);\n+      Fin_Mas   : constant Entity_Id := Finalization_Master (Ptr_Typ);\n \n    begin\n-      --  If the context is a class-wide allocator, we use the class-wide type\n-      --  to obtain the proper Finalize_Address routine.\n-\n-      if Is_Class_Wide_Type (Desig_Typ) then\n-         Utyp := Desig_Typ;\n-\n-      else\n-         Utyp := Typ;\n-\n-         if Is_Private_Type (Utyp) and then Present (Full_View (Utyp)) then\n-            Utyp := Full_View (Utyp);\n-         end if;\n-\n-         if Is_Concurrent_Type (Utyp) then\n-            Utyp := Corresponding_Record_Type (Utyp);\n-         end if;\n-      end if;\n-\n-      Utyp := Underlying_Type (Base_Type (Utyp));\n+      --  Both the finalization master and primitive Finalize_Address must be\n+      --  available.\n \n-      --  Deal with untagged derivation of private views. If the parent is\n-      --  now known to be protected, the finalization routine is the one\n-      --  defined on the corresponding record of the ancestor (corresponding\n-      --  records do not automatically inherit operations, but maybe they\n-      --  should???)\n-\n-      if Is_Untagged_Derivation (Typ) then\n-         if Is_Protected_Type (Typ) then\n-            Utyp := Corresponding_Record_Type (Root_Type (Base_Type (Typ)));\n-         else\n-            Utyp := Underlying_Type (Root_Type (Base_Type (Typ)));\n-\n-            if Is_Protected_Type (Utyp) then\n-               Utyp := Corresponding_Record_Type (Utyp);\n-            end if;\n-         end if;\n-      end if;\n-\n-      --  If the underlying_type is a subtype, we are dealing with the\n-      --  completion of a private type. We need to access the base type and\n-      --  generate a conversion to it.\n-\n-      if Utyp /= Base_Type (Utyp) then\n-         pragma Assert (Is_Private_Type (Typ));\n-\n-         Utyp := Base_Type (Utyp);\n-      end if;\n-\n-      Fin_Mas_Ref := New_Occurrence_Of (Fin_Mas_Id, Loc);\n-\n-      --  If the call is from a build-in-place function, the Master parameter\n-      --  is actually a pointer. Dereference it for the call.\n-\n-      if Is_Access_Type (Etype (Fin_Mas_Id)) then\n-         Fin_Mas_Ref := Make_Explicit_Dereference (Loc, Fin_Mas_Ref);\n-      end if;\n+      pragma Assert (Present (Fin_Addr) and Present (Fin_Mas));\n \n       --  Generate:\n-      --    Set_Finalize_Address (<Ptr_Typ>FM, <Utyp>FD'Unrestricted_Access);\n+      --    Set_Finalize_Address\n+      --      (<Ptr_Typ>FM, <Desig_Typ>FD'Unrestricted_Access);\n \n       return\n         Make_Procedure_Call_Statement (Loc,\n           Name                   =>\n             New_Occurrence_Of (RTE (RE_Set_Finalize_Address), Loc),\n           Parameter_Associations => New_List (\n-            Fin_Mas_Ref,\n+            New_Occurrence_Of (Fin_Mas, Loc),\n+\n             Make_Attribute_Reference (Loc,\n-              Prefix         =>\n-                New_Occurrence_Of (TSS (Utyp, TSS_Finalize_Address), Loc),\n+              Prefix         => New_Occurrence_Of (Fin_Addr, Loc),\n               Attribute_Name => Name_Unrestricted_Access)));\n    end Make_Set_Finalize_Address_Call;\n "}, {"sha": "f47abe86442de589d9e934c6bc0b6d5eac9af4ba", "filename": "gcc/ada/exp_ch7.ads", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Fexp_ch7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Fexp_ch7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.ads?ref=760804f3b9b9127ea68abd96d1d96dc51c80f749", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -98,17 +98,20 @@ package Exp_Ch7 is\n    --  exception will be saved to a global location.\n \n    procedure Build_Finalization_Master\n-     (Typ        : Entity_Id;\n-      Ins_Node   : Node_Id := Empty;\n-      Encl_Scope : Entity_Id := Empty);\n+     (Typ            : Entity_Id;\n+      For_Anonymous  : Boolean   := False;\n+      For_Private    : Boolean   := False;\n+      Context_Scope  : Entity_Id := Empty;\n+      Insertion_Node : Node_Id   := Empty);\n    --  Build a finalization master for an access type. The designated type may\n-   --  not necessarely be controlled or need finalization actions. The routine\n-   --  creates a wrapper around a user-defined storage pool or the general\n-   --  storage pool for access types. Ins_Nod and Encl_Scope are used in\n-   --  conjunction with anonymous access types. Ins_Node designates the\n-   --  insertion point before which the collection should be added. Encl_Scope\n-   --  is the scope of the context, either the enclosing record or the scope\n-   --  of the related function.\n+   --  not necessarely be controlled or need finalization actions depending on\n+   --  the context. Flag For_Anonymous must be set when creating a master for\n+   --  an anonymous access type. Flag For_Private must be set when the\n+   --  designated type contains a private component. Parameters Context_Scope\n+   --  and Insertion_Node must be used in conjunction with flags For_Anonymous\n+   --  and For_Private. Context_Scope is the scope of the context where the\n+   --  finalization master must be analyzed. Insertion_Node is the insertion\n+   --  point before which the master is inserted.\n \n    procedure Build_Late_Proc (Typ : Entity_Id; Nam : Name_Id);\n    --  Build one controlling procedure when a late body overrides one of\n@@ -222,15 +225,13 @@ package Exp_Ch7 is\n \n    function Make_Set_Finalize_Address_Call\n      (Loc     : Source_Ptr;\n-      Typ     : Entity_Id;\n       Ptr_Typ : Entity_Id) return Node_Id;\n+   --  Associate the Finalize_Address primitive of the designated type with the\n+   --  finalization master of access type Ptr_Typ. The returned call is:\n    --  Generate the following call:\n    --\n-   --    Set_Finalize_Address (<Ptr_Typ>FM, <Typ>FD'Unrestricted_Access);\n-   --\n-   --  where Finalize_Address is the corresponding TSS primitive of type Typ\n-   --  and Ptr_Typ is the access type of the related allocation. Loc is the\n-   --  source location of the related allocator.\n+   --    Set_Finalize_Address\n+   --      (<Ptr_Typ>FM, <Desig_Typ>FD'Unrestricted_Access);\n \n    --------------------------------------------\n    -- Task and Protected Object finalization --"}, {"sha": "6c35fd6ad6ba7bc247d79f25e40b07e7758748ed", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 78, "deletions": 81, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=760804f3b9b9127ea68abd96d1d96dc51c80f749", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -412,9 +412,6 @@ package body Exp_Util is\n       Proc_To_Call : Node_Id := Empty;\n       Ptr_Typ      : Entity_Id;\n \n-      function Find_Finalize_Address (Typ : Entity_Id) return Entity_Id;\n-      --  Locate TSS primitive Finalize_Address in type Typ\n-\n       function Find_Object (E : Node_Id) return Node_Id;\n       --  Given an arbitrary expression of an allocator, try to find an object\n       --  reference in it, otherwise return the original expression.\n@@ -423,82 +420,6 @@ package body Exp_Util is\n       --  Determine whether subprogram Subp denotes a custom allocate or\n       --  deallocate.\n \n-      ---------------------------\n-      -- Find_Finalize_Address --\n-      ---------------------------\n-\n-      function Find_Finalize_Address (Typ : Entity_Id) return Entity_Id is\n-         Utyp : Entity_Id := Typ;\n-\n-      begin\n-         --  Handle protected class-wide or task class-wide types\n-\n-         if Is_Class_Wide_Type (Utyp) then\n-            if Is_Concurrent_Type (Root_Type (Utyp)) then\n-               Utyp := Root_Type (Utyp);\n-\n-            elsif Is_Private_Type (Root_Type (Utyp))\n-              and then Present (Full_View (Root_Type (Utyp)))\n-              and then Is_Concurrent_Type (Full_View (Root_Type (Utyp)))\n-            then\n-               Utyp := Full_View (Root_Type (Utyp));\n-            end if;\n-         end if;\n-\n-         --  Handle private types\n-\n-         if Is_Private_Type (Utyp) and then Present (Full_View (Utyp)) then\n-            Utyp := Full_View (Utyp);\n-         end if;\n-\n-         --  Handle protected and task types\n-\n-         if Is_Concurrent_Type (Utyp)\n-           and then Present (Corresponding_Record_Type (Utyp))\n-         then\n-            Utyp := Corresponding_Record_Type (Utyp);\n-         end if;\n-\n-         Utyp := Underlying_Type (Base_Type (Utyp));\n-\n-         --  Deal with untagged derivation of private views. If the parent is\n-         --  now known to be protected, the finalization routine is the one\n-         --  defined on the corresponding record of the ancestor (corresponding\n-         --  records do not automatically inherit operations, but maybe they\n-         --  should???)\n-\n-         if Is_Untagged_Derivation (Typ) then\n-            if Is_Protected_Type (Typ) then\n-               Utyp := Corresponding_Record_Type (Root_Type (Base_Type (Typ)));\n-            else\n-               Utyp := Underlying_Type (Root_Type (Base_Type (Typ)));\n-\n-               if Is_Protected_Type (Utyp) then\n-                  Utyp := Corresponding_Record_Type (Utyp);\n-               end if;\n-            end if;\n-         end if;\n-\n-         --  If the underlying_type is a subtype, we are dealing with the\n-         --  completion of a private type. We need to access the base type and\n-         --  generate a conversion to it.\n-\n-         if Utyp /= Base_Type (Utyp) then\n-            pragma Assert (Is_Private_Type (Typ));\n-\n-            Utyp := Base_Type (Utyp);\n-         end if;\n-\n-         --  When dealing with an internally built full view for a type with\n-         --  unknown discriminants, use the original record type.\n-\n-         if Is_Underlying_Record_View (Utyp) then\n-            Utyp := Etype (Utyp);\n-         end if;\n-\n-         return TSS (Utyp, TSS_Finalize_Address);\n-      end Find_Finalize_Address;\n-\n       -----------------\n       -- Find_Object --\n       -----------------\n@@ -764,7 +685,7 @@ package body Exp_Util is\n             --  since it contains an Unchecked_Conversion.\n \n             if Needs_Finalization (Desig_Typ) and then not CodePeer_Mode then\n-               Fin_Addr_Id := Find_Finalize_Address (Desig_Typ);\n+               Fin_Addr_Id := Finalize_Address (Desig_Typ);\n                pragma Assert (Present (Fin_Addr_Id));\n \n                Append_To (Actuals,\n@@ -2443,6 +2364,82 @@ package body Exp_Util is\n       end if;\n    end Expand_Subtype_From_Expr;\n \n+   ----------------------\n+   -- Finalize_Address --\n+   ----------------------\n+\n+   function Finalize_Address (Typ : Entity_Id) return Entity_Id is\n+      Utyp : Entity_Id := Typ;\n+\n+   begin\n+      --  Handle protected class-wide or task class-wide types\n+\n+      if Is_Class_Wide_Type (Utyp) then\n+         if Is_Concurrent_Type (Root_Type (Utyp)) then\n+            Utyp := Root_Type (Utyp);\n+\n+         elsif Is_Private_Type (Root_Type (Utyp))\n+           and then Present (Full_View (Root_Type (Utyp)))\n+           and then Is_Concurrent_Type (Full_View (Root_Type (Utyp)))\n+         then\n+            Utyp := Full_View (Root_Type (Utyp));\n+         end if;\n+      end if;\n+\n+      --  Handle private types\n+\n+      if Is_Private_Type (Utyp) and then Present (Full_View (Utyp)) then\n+         Utyp := Full_View (Utyp);\n+      end if;\n+\n+      --  Handle protected and task types\n+\n+      if Is_Concurrent_Type (Utyp)\n+        and then Present (Corresponding_Record_Type (Utyp))\n+      then\n+         Utyp := Corresponding_Record_Type (Utyp);\n+      end if;\n+\n+      Utyp := Underlying_Type (Base_Type (Utyp));\n+\n+      --  Deal with untagged derivation of private views. If the parent is\n+      --  now known to be protected, the finalization routine is the one\n+      --  defined on the corresponding record of the ancestor (corresponding\n+      --  records do not automatically inherit operations, but maybe they\n+      --  should???)\n+\n+      if Is_Untagged_Derivation (Typ) then\n+         if Is_Protected_Type (Typ) then\n+            Utyp := Corresponding_Record_Type (Root_Type (Base_Type (Typ)));\n+         else\n+            Utyp := Underlying_Type (Root_Type (Base_Type (Typ)));\n+\n+            if Is_Protected_Type (Utyp) then\n+               Utyp := Corresponding_Record_Type (Utyp);\n+            end if;\n+         end if;\n+      end if;\n+\n+      --  If the underlying_type is a subtype, we are dealing with the\n+      --  completion of a private type. We need to access the base type and\n+      --  generate a conversion to it.\n+\n+      if Utyp /= Base_Type (Utyp) then\n+         pragma Assert (Is_Private_Type (Typ));\n+\n+         Utyp := Base_Type (Utyp);\n+      end if;\n+\n+      --  When dealing with an internally built full view for a type with\n+      --  unknown discriminants, use the original record type.\n+\n+      if Is_Underlying_Record_View (Utyp) then\n+         Utyp := Etype (Utyp);\n+      end if;\n+\n+      return TSS (Utyp, TSS_Finalize_Address);\n+   end Finalize_Address;\n+\n    ------------------------\n    -- Find_Interface_ADT --\n    ------------------------"}, {"sha": "68302602a1bdb81eccf5e34da11842364a670f1c", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=760804f3b9b9127ea68abd96d1d96dc51c80f749", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -450,6 +450,9 @@ package Exp_Util is\n    --  declarations and/or allocations when the type is indefinite (including\n    --  class-wide).\n \n+   function Finalize_Address (Typ : Entity_Id) return Entity_Id;\n+   --  Locate TSS primitive Finalize_Address in type Typ\n+\n    function Find_Interface_ADT\n      (T     : Entity_Id;\n       Iface : Entity_Id) return Elmt_Id;"}, {"sha": "fd06aa14623324e5dfb028fcda6c77289e55d8ed", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=760804f3b9b9127ea68abd96d1d96dc51c80f749", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1796,25 +1796,6 @@ package body Freeze is\n                   Next_Entity (Ent);\n                end loop;\n             end;\n-\n-         --  We add finalization masters to access types whose designated types\n-         --  require finalization. This is normally done when freezing the\n-         --  type, but this misses recursive type definitions where the later\n-         --  members of the recursion introduce controlled components (such as\n-         --  can happen when incomplete types are involved), as well cases\n-         --  where a component type is private and the controlled full type\n-         --  occurs after the access type is frozen. Cases that don't need a\n-         --  finalization master are generic formal types (the actual type will\n-         --  have it) and types derived from them,  and types with Java and CIL\n-         --  conventions, since those are used for API bindings.\n-         --  (Are there any other cases that should be excluded here???)\n-\n-         elsif Is_Access_Type (E)\n-           and then Comes_From_Source (E)\n-           and then not Is_Generic_Type (Root_Type (E))\n-           and then Needs_Finalization (Designated_Type (E))\n-         then\n-            Build_Finalization_Master (E);\n          end if;\n \n          Next_Entity (E);"}, {"sha": "b4667342753341979bc218740055e9262611ef5a", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=760804f3b9b9127ea68abd96d1d96dc51c80f749", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -499,6 +499,10 @@ package body Lib.Writ is\n             Write_Info_Str (\" RT\");\n          end if;\n \n+         if Serious_Errors_Detected /= 0 then\n+            Write_Info_Str (\" SE\");\n+         end if;\n+\n          if Is_Shared_Passive (Uent) then\n             Write_Info_Str (\" SP\");\n          end if;"}, {"sha": "d135eac1e9a8b72a4fb3a4d62a8f33fd51da9aac", "filename": "gcc/ada/lib-writ.ads", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Flib-writ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Flib-writ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.ads?ref=760804f3b9b9127ea68abd96d1d96dc51c80f749", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -598,11 +598,15 @@ package Lib.Writ is\n \n    --         RT  Unit has pragma Remote_Types\n \n-   --         SP  Unit has pragma Shared_Passive.\n+   --         SE  Compilation of unit encountered one or more serious errors.\n+   --             Normally the generation of an ALI file is suppressed if there\n+   --             is a serious error, but this can be overridden with -gnatQ.\n+\n+   --         SP  Unit has pragma Shared_Passive\n \n    --         SU  Unit is a subprogram, rather than a package\n \n-   --      The attributes may appear in any order, separated by spaces.\n+   --      The attributes may appear in any order, separated by spaces\n \n    --  -----------------------------\n    --  -- W, Y and Z Withed Units --"}, {"sha": "cf1ff9c460ddc360afaf1fb68bae79ac08c5cc91", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=760804f3b9b9127ea68abd96d1d96dc51c80f749", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -4595,7 +4595,8 @@ package body Sem_Attr is\n             --  corresponding pragma. Don't issue errors when analyzing aspect.\n \n             if Nkind (Prag) = N_Aspect_Specification\n-              and then Chars (Identifier (Prag)) = Name_Post\n+              and then Nam_In (Chars (Identifier (Prag)), Name_Post,\n+                                                          Name_Refined_Post)\n             then\n                null;\n "}, {"sha": "0a97caaf9999ce588e81beb3187ce736f6882964", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/760804f3b9b9127ea68abd96d1d96dc51c80f749/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=760804f3b9b9127ea68abd96d1d96dc51c80f749", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2792,6 +2792,14 @@ package body Sem_Ch3 is\n          Generate_Definition (Def_Id);\n       end if;\n \n+      --  Propagate any pending access types whose finalization masters need to\n+      --  be fully initialized from the partial to the full view. Guard against\n+      --  an illegal full view that remains unanalyzed.\n+\n+      if Is_Type (Def_Id) and then Is_Incomplete_Or_Private_Type (Prev) then\n+         Set_Pending_Access_Types (Def_Id, Pending_Access_Types (Prev));\n+      end if;\n+\n       if Chars (Scope (Def_Id)) = Name_System\n         and then Chars (Def_Id) = Name_Address\n         and then Is_Predefined_File_Name (Unit_File_Name (Get_Source_Unit (N)))"}]}