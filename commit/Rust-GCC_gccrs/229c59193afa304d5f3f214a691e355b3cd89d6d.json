{"sha": "229c59193afa304d5f3f214a691e355b3cd89d6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjI5YzU5MTkzYWZhMzA0ZDVmM2YyMTRhNjkxZTM1NWIzY2Q4OWQ2ZA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2014-10-24T20:52:41Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2014-10-24T20:52:41Z"}, "message": "check.c (check_co_collective): Reject coindexed A args.\n\n2014-10-24  Tobias Burnus  <burnus@net-b.de>\n\ngcc/fortran\n        * check.c (check_co_collective): Reject coindexed A args.\n        (gfc_check_co_reduce): Add OPERATOR checks.\n        * gfortran.texi (_gfortran_caf_co_broadcast,\n        * _gfortran_caf_co_max,\n        _gfortran_caf_co_min, _gfortran_caf_co_sum,\n        _gfortran_caf_co_reduce): Add ABI documentation.\n        * intrinsic.texi (CO_REDUCE): Document intrinsic.\n        (DPROD): Returns double not single precision.\n        * trans-decl.c (gfor_fndecl_co_reduce): New global var.\n        (gfc_build_builtin_function_decls): Init it.\n        * trans.h (gfor_fndecl_co_reduce): Declare it.\n        * trans-intrinsic.c (conv_co_collective,\n        gfc_conv_intrinsic_subroutine): Handle CO_REDUCE.\n\ngcc/testsuite/\n        * gfortran.dg/coarray_collectives_9.f90: Remove dg-error.\n        * gfortran.dg/coarray_collectives_13.f90: New.\n        * gfortran.dg/coarray_collectives_14.f90: New.\n        * gfortran.dg/coarray_collectives_15.f90: New.\n        * gfortran.dg/coarray_collectives_16.f90: New.\n\nFrom-SVN: r216678", "tree": {"sha": "18bad83bfccb41a662f817065b9b6a8b1752b346", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18bad83bfccb41a662f817065b9b6a8b1752b346"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/229c59193afa304d5f3f214a691e355b3cd89d6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/229c59193afa304d5f3f214a691e355b3cd89d6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/229c59193afa304d5f3f214a691e355b3cd89d6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/229c59193afa304d5f3f214a691e355b3cd89d6d/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "763206befb00fdcecfd8e54ccffd72d618077e92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/763206befb00fdcecfd8e54ccffd72d618077e92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/763206befb00fdcecfd8e54ccffd72d618077e92"}], "stats": {"total": 803, "additions": 758, "deletions": 45}, "files": [{"sha": "6c84d6192edbcdf2b1bf04c37e1ad4404e44be04", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/229c59193afa304d5f3f214a691e355b3cd89d6d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/229c59193afa304d5f3f214a691e355b3cd89d6d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=229c59193afa304d5f3f214a691e355b3cd89d6d", "patch": "@@ -1,3 +1,18 @@\n+2014-10-24  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* check.c (check_co_collective): Reject coindexed A args.\n+\t(gfc_check_co_reduce): Add OPERATOR checks.\n+\t* gfortran.texi (_gfortran_caf_co_broadcast, _gfortran_caf_co_max,\n+\t_gfortran_caf_co_min, _gfortran_caf_co_sum,\n+\t_gfortran_caf_co_reduce): Add ABI documentation.\n+\t* intrinsic.texi (CO_REDUCE): Document intrinsic.\n+\t(DPROD): Returns double not single precision.\n+\t* trans-decl.c (gfor_fndecl_co_reduce): New global var.\n+\t(gfc_build_builtin_function_decls): Init it.\n+\t* trans.h (gfor_fndecl_co_reduce): Declare it.\n+\t* trans-intrinsic.c (conv_co_collective,\n+\tgfc_conv_intrinsic_subroutine): Handle CO_REDUCE.\n+\n 2014-10-19  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR fortran/48979"}, {"sha": "6f1fe3fcff5da72febccb3c580fcc79bac950e82", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 153, "deletions": 20, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/229c59193afa304d5f3f214a691e355b3cd89d6d/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/229c59193afa304d5f3f214a691e355b3cd89d6d/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=229c59193afa304d5f3f214a691e355b3cd89d6d", "patch": "@@ -1433,6 +1433,13 @@ check_co_collective (gfc_expr *a, gfc_expr *image_idx, gfc_expr *stat,\n       return false;\n     }\n \n+  if (gfc_is_coindexed (a))\n+    {\n+      gfc_error (\"The A argument at %L to the intrinsic %s shall not be \"\n+\t\t \"coindexed\", &a->where, gfc_current_intrinsic);\n+      return false;\n+    }\n+\n   if (image_idx != NULL)\n     {\n       if (!type_check (image_idx, co_reduce ? 2 : 1, BT_INTEGER))\n@@ -1490,10 +1497,10 @@ gfc_check_co_broadcast (gfc_expr *a, gfc_expr *source_image, gfc_expr *stat,\n {\n   if (a->ts.type == BT_CLASS || gfc_expr_attr (a).alloc_comp)\n     {\n-       gfc_error (\"Support for the A argument at %L which is polymorphic A \"\n-                  \"argument or has allocatable components is not yet \"\n-\t\t  \"implemented\", &a->where);\n-       return false;\n+      gfc_error (\"Support for the A argument at %L which is polymorphic A \"\n+\t\t \"argument or has allocatable components is not yet \"\n+\t\t \"implemented\", &a->where);\n+      return false;\n     }\n   return check_co_collective (a, source_image, stat, errmsg, false);\n }\n@@ -1504,38 +1511,164 @@ gfc_check_co_reduce (gfc_expr *a, gfc_expr *op, gfc_expr *result_image,\n \t\t     gfc_expr *stat, gfc_expr *errmsg)\n {\n   symbol_attribute attr;\n+  gfc_formal_arglist *formal;\n+  gfc_symbol *sym;\n \n   if (a->ts.type == BT_CLASS)\n     {\n-       gfc_error (\"The A argument at %L of CO_REDUCE shall not be polymorphic\",\n-\t\t  &a->where);\n-       return false;\n+      gfc_error (\"The A argument at %L of CO_REDUCE shall not be polymorphic\",\n+\t\t &a->where);\n+      return false;\n     }\n \n   if (gfc_expr_attr (a).alloc_comp)\n     {\n-       gfc_error (\"Support for the A argument at %L with allocatable components\"\n-                  \" is not yet implemented\", &a->where);\n-       return false;\n+      gfc_error (\"Support for the A argument at %L with allocatable components\"\n+                 \" is not yet implemented\", &a->where);\n+      return false;\n     }\n \n+  if (!check_co_collective (a, result_image, stat, errmsg, true))\n+    return false;\n+\n+  if (!gfc_resolve_expr (op))\n+    return false;\n+\n   attr = gfc_expr_attr (op);\n   if (!attr.pure || !attr.function)\n     {\n-       gfc_error (\"OPERATOR argument at %L must be a PURE function\",\n-\t\t  &op->where);\n-       return false;\n+      gfc_error (\"OPERATOR argument at %L must be a PURE function\",\n+\t\t &op->where);\n+      return false;\n     }\n \n-  if (!check_co_collective (a, result_image, stat, errmsg, true))\n-    return false;\n+  if (attr.intrinsic)\n+    {\n+      /* None of the intrinsics fulfills the criteria of taking two arguments,\n+\t returning the same type and kind as the arguments and being permitted\n+\t as actual argument.  */\n+      gfc_error (\"Intrinsic function %s at %L is not permitted for CO_REDUCE\",\n+\t\t op->symtree->n.sym->name, &op->where);\n+      return false;\n+    }\n \n-  /* FIXME: After J3/WG5 has decided what they actually exactly want, more\n-     checks such as same-argument checks have to be added, implemented and\n-     intrinsic.texi upated.  */\n+  if (gfc_is_proc_ptr_comp (op))\n+    {\n+      gfc_component *comp = gfc_get_proc_ptr_comp (op);\n+      sym = comp->ts.interface;\n+    }\n+  else\n+    sym = op->symtree->n.sym;\n \n-  gfc_error(\"CO_REDUCE at %L is not yet implemented\", &a->where);\n-  return false;\n+  formal = sym->formal;\n+\n+  if (!formal || !formal->next || formal->next->next)\n+    {\n+      gfc_error (\"The function passed as OPERATOR at %L shall have two \"\n+\t\t \"arguments\", &op->where);\n+      return false;\n+    }\n+\n+  if (sym->result->ts.type == BT_UNKNOWN)\n+    gfc_set_default_type (sym->result, 0, NULL);\n+\n+  if (!gfc_compare_types (&a->ts, &sym->result->ts))\n+    {\n+      gfc_error (\"A argument at %L has type %s but the function passed as \"\n+\t\t \"OPERATOR at %L returns %s\",\n+\t\t &a->where, gfc_typename (&a->ts), &op->where,\n+\t\t gfc_typename (&sym->result->ts));\n+      return false;\n+    }\n+  if (!gfc_compare_types (&a->ts, &formal->sym->ts)\n+      || !gfc_compare_types (&a->ts, &formal->next->sym->ts))\n+    {\n+      gfc_error (\"The function passed as OPERATOR at %L has arguments of type \"\n+\t\t \"%s and %s but shall have type %s\", &op->where,\n+\t\t gfc_typename (&formal->sym->ts),\n+\t\t gfc_typename (&formal->next->sym->ts), gfc_typename (&a->ts));\n+      return false;\n+    }\n+  if (op->rank || attr.allocatable || attr.pointer || formal->sym->as\n+      || formal->next->sym->as || formal->sym->attr.allocatable\n+      || formal->next->sym->attr.allocatable || formal->sym->attr.pointer\n+      || formal->next->sym->attr.pointer)\n+    {\n+      gfc_error (\"The function passed as OPERATOR at %L shall have scalar \"\n+\t\t \"nonallocatable nonpointer arguments and return a \"\n+\t\t \"nonallocatable nonpointer scalar\", &op->where);\n+      return false;\n+    }\n+\n+  if (formal->sym->attr.value != formal->next->sym->attr.value)\n+    {\n+      gfc_error (\"The function passed as OPERATOR at %L shall have the VALUE \"\n+\t\t \"attribute either for none or both arguments\", &op->where);\n+      return false;\n+    }\n+\n+  if (formal->sym->attr.target != formal->next->sym->attr.target)\n+    {\n+      gfc_error (\"The function passed as OPERATOR at %L shall have the TARGET \"\n+\t\t \"attribute either for none or both arguments\", &op->where);\n+      return false;\n+    }\n+\n+  if (formal->sym->attr.asynchronous != formal->next->sym->attr.asynchronous)\n+    {\n+      gfc_error (\"The function passed as OPERATOR at %L shall have the \"\n+\t\t \"ASYNCHRONOUS attribute either for none or both arguments\",\n+\t\t &op->where);\n+      return false;\n+    }\n+\n+  if (formal->sym->attr.optional || formal->next->sym->attr.optional)\n+    {\n+      gfc_error (\"The function passed as OPERATOR at %L shall not have the \"\n+\t\t \"OPTIONAL attribute for either of the arguments\", &op->where);\n+      return false;\n+    }\n+\n+  if (a->ts.type == BT_CHARACTER)\n+    {\n+      gfc_charlen *cl;\n+      unsigned long actual_size, formal_size1, formal_size2, result_size;\n+\n+      cl = a->ts.u.cl;\n+      actual_size = cl && cl->length && cl->length->expr_type == EXPR_CONSTANT\n+\t\t     ? mpz_get_ui (cl->length->value.integer) : 0;\n+\n+      cl = formal->sym->ts.u.cl;\n+      formal_size1 = cl && cl->length && cl->length->expr_type == EXPR_CONSTANT\n+\t\t     ? mpz_get_ui (cl->length->value.integer) : 0;\n+\n+      cl = formal->next->sym->ts.u.cl;\n+      formal_size2 = cl && cl->length && cl->length->expr_type == EXPR_CONSTANT\n+\t\t     ? mpz_get_ui (cl->length->value.integer) : 0;\n+\n+      cl = sym->ts.u.cl;\n+      result_size = cl && cl->length && cl->length->expr_type == EXPR_CONSTANT\n+\t\t    ? mpz_get_ui (cl->length->value.integer) : 0;\n+\n+      if (actual_size\n+\t  && ((formal_size1 && actual_size != formal_size1)\n+\t       || (formal_size2 && actual_size != formal_size2)))\n+\t{\n+\t  gfc_error (\"The character length of the A argument at %L and of the \"\n+\t\t     \"arguments of the OPERATOR at %L shall be the same\",\n+\t\t     &a->where, &op->where);\n+\t  return false;\n+\t}\n+      if (actual_size && result_size && actual_size != result_size)\n+\t{\n+\t  gfc_error (\"The character length of the A argument at %L and of the \"\n+\t\t     \"function result of the OPERATOR at %L shall be the same\",\n+\t\t     &a->where, &op->where);\n+\t  return false;\n+\t}\n+    }\n+\n+  return true;\n }\n \n "}, {"sha": "41d6559fab0ba6f678012c96beeba1c74234f6b9", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/229c59193afa304d5f3f214a691e355b3cd89d6d/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/229c59193afa304d5f3f214a691e355b3cd89d6d/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=229c59193afa304d5f3f214a691e355b3cd89d6d", "patch": "@@ -3238,6 +3238,11 @@ caf_register_t;\n * _gfortran_caf_sendget:: Sending data between remote images\n * _gfortran_caf_lock:: Locking a lock variable\n * _gfortran_caf_unlock:: Unlocking a lock variable\n+* _gfortran_caf_co_broadcast:: Sending data to all images\n+* _gfortran_caf_co_max:: Collective maximum reduction\n+* _gfortran_caf_co_min:: Collective minimum reduction\n+* _gfortran_caf_co_sum:: Collective summing reduction\n+* _gfortran_caf_co_reduce:: Generic collective reduction\n @end menu\n \n \n@@ -3680,6 +3685,191 @@ images for critical-block locking variables.\n \n \n \n+@node _gfortran_caf_co_broadcast\n+@subsection @code{_gfortran_caf_co_broadcast} --- Sending data to all images\n+@cindex Coarray, _gfortran_caf_co_broadcast\n+\n+@table @asis\n+@item @emph{Description}:\n+Distribute a value from a given image to all other images in the team. Has to\n+be called collectively.\n+\n+@item @emph{Syntax}:\n+@code{void _gfortran_caf_co_broadcast (gfc_descriptor_t *a,\n+int source_image, int *stat, char *errmsg, int errmsg_len)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{a} @tab intent(inout) And array descriptor with the data to be\n+breoadcasted (on @var{source_image}) or to be received (other images).\n+@item @var{source_image} @tab The ID of the image from which the data should\n+be taken.\n+@item @var{stat} @tab intent(out) Stores the status STAT= and my may be NULL.\n+@item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n+an error message; may be NULL\n+@item @var{errmsg_len} @tab the buffer size of errmsg.\n+@end multitable\n+@end table\n+\n+\n+\n+@node _gfortran_caf_co_max\n+@subsection @code{_gfortran_caf_co_max} --- Collective maximum reduction\n+@cindex Coarray, _gfortran_caf_co_max\n+\n+@table @asis\n+@item @emph{Description}:\n+Calculates the for the each array element of the variable @var{a} the maximum\n+value for that element in the current team; if @var{result_image} has the\n+value 0, the result shall be stored on all images, otherwise, only on the\n+specified image. This function operates on numeric values and character\n+strings.\n+\n+@item @emph{Syntax}:\n+@code{void _gfortran_caf_co_max (gfc_descriptor_t *a, int result_image,\n+int *stat, char *errmsg, int a_len, int errmsg_len)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{a} @tab intent(inout) And array descriptor with the data to be\n+breoadcasted (on @var{source_image}) or to be received (other images).\n+@item @var{result_image} @tab The ID of the image to which the reduced\n+value should be copied to; if zero, it has to be copied to all images.\n+@item @var{stat} @tab intent(out) Stores the status STAT= and my may be NULL.\n+@item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n+an error message; may be NULL\n+@item @var{a_len} @tab The string length of argument @var{a}.\n+@item @var{errmsg_len} @tab the buffer size of errmsg.\n+@end multitable\n+\n+@item @emph{NOTES}\n+If @var{result_image} is nonzero, the value on all images except of the\n+specified one become undefined; hence, the library may make use of this.\n+@end table\n+\n+\n+\n+@node _gfortran_caf_co_min\n+@subsection @code{_gfortran_caf_co_min} --- Collective minimum reduction\n+@cindex Coarray, _gfortran_caf_co_min\n+\n+@table @asis\n+@item @emph{Description}:\n+Calculates the for the each array element of the variable @var{a} the minimum\n+value for that element in the current team; if @var{result_image} has the\n+value 0, the result shall be stored on all images, otherwise, only on the\n+specified image. This function operates on numeric values and character\n+strings.\n+\n+@item @emph{Syntax}:\n+@code{void _gfortran_caf_co_min (gfc_descriptor_t *a, int result_image,\n+int *stat, char *errmsg, int a_len, int errmsg_len)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{a} @tab intent(inout) And array descriptor with the data to be\n+breoadcasted (on @var{source_image}) or to be received (other images).\n+@item @var{result_image} @tab The ID of the image to which the reduced\n+value should be copied to; if zero, it has to be copied to all images.\n+@item @var{stat} @tab intent(out) Stores the status STAT= and my may be NULL.\n+@item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n+an error message; may be NULL\n+@item @var{a_len} @tab The string length of argument @var{a}.\n+@item @var{errmsg_len} @tab the buffer size of errmsg.\n+@end multitable\n+\n+@item @emph{NOTES}\n+If @var{result_image} is nonzero, the value on all images except of the\n+specified one become undefined; hence, the library may make use of this.\n+@end table\n+\n+\n+\n+@node _gfortran_caf_co_sum\n+@subsection @code{_gfortran_caf_co_sum} --- Collective summing reduction\n+@cindex Coarray, _gfortran_caf_co_sum\n+\n+@table @asis\n+@item @emph{Description}:\n+Calculates the for the each array element of the variable @var{a} the sum\n+value for that element in the current team; if @var{result_image} has the\n+value 0, the result shall be stored on all images, otherwise, only on the\n+specified image. This function operates on numeric values.\n+\n+@item @emph{Syntax}:\n+@code{void _gfortran_caf_co_sum (gfc_descriptor_t *a, int result_image,\n+int *stat, char *errmsg, int errmsg_len)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{a} @tab intent(inout) And array descriptor with the data to be\n+breoadcasted (on @var{source_image}) or to be received (other images).\n+@item @var{result_image} @tab The ID of the image to which the reduced\n+value should be copied to; if zero, it has to be copied to all images.\n+@item @var{stat} @tab intent(out) Stores the status STAT= and my may be NULL.\n+@item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n+an error message; may be NULL\n+@item @var{errmsg_len} @tab the buffer size of errmsg.\n+@end multitable\n+\n+@item @emph{NOTES}\n+If @var{result_image} is nonzero, the value on all images except of the\n+specified one become undefined; hence, the library may make use of this.\n+@end table\n+\n+\n+\n+@node _gfortran_caf_co_reduce\n+@subsection @code{_gfortran_caf_co_reduce} --- Generic collective reduction\n+@cindex Coarray, _gfortran_caf_co_reduce\n+\n+@table @asis\n+@item @emph{Description}:\n+Calculates the for the each array element of the variable @var{a} the reduction\n+value for that element in the current team; if @var{result_image} has the\n+value 0, the result shall be stored on all images, otherwise, only on the\n+specified image. The @var{opr} is a pure function doing a mathematically\n+commutative and associative operation.\n+\n+The @var{opr_flags} denote the following; the values are bitwise ored.\n+@code{GFC_CAF_BYREF} (1) if the result should be returned\n+by value; @code{GFC_CAF_HIDDENLEN} (2) whether the result and argument\n+string lengths shall be specified as hidden argument;\n+@code{GFC_CAF_ARG_VALUE} (4) whether the arguments shall be passed by value,\n+@code{GFC_CAF_ARG_DESC} (8) whether the arguments shall be passed by descriptor.\n+\n+\n+@item @emph{Syntax}:\n+@code{void _gfortran_caf_co_reduce (gfc_descriptor_t *a,\n+void * (*opr) (void *, void *), int opr_flags, int result_image,\n+int *stat, char *errmsg, int a_len, int errmsg_len)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{opr} @tab Function pointer to the reduction function.\n+@item @var{opr_flags} @tab Flags regarding the reduction function\n+@item @var{a} @tab intent(inout) And array descriptor with the data to be\n+breoadcasted (on @var{source_image}) or to be received (other images).\n+@item @var{result_image} @tab The ID of the image to which the reduced\n+value should be copied to; if zero, it has to be copied to all images.\n+@item @var{stat} @tab intent(out) Stores the status STAT= and my may be NULL.\n+@item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n+an error message; may be NULL\n+@item @var{a_len} @tab The string length of argument @var{a}.\n+@item @var{errmsg_len} @tab the buffer size of errmsg.\n+@end multitable\n+\n+@item @emph{NOTES}\n+If @var{result_image} is nonzero, the value on all images except of the\n+specified one become undefined; hence, the library may make use of this.\n+For character arguments, the result is passed as first argument, followed\n+by the result string length, next come the two string arguments, followed\n+by the two hidden arguments. With C binding, there are no hidden arguments\n+and by-reference passing and either only a single character is passed or\n+an array descriptor.\n+@end table\n+\n+\n @c Intrinsic Procedures\n @c ---------------------------------------------------------------------\n "}, {"sha": "90c9a3aaf468f6826fb04fc79b9d135b38481a96", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 94, "deletions": 13, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/229c59193afa304d5f3f214a691e355b3cd89d6d/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/229c59193afa304d5f3f214a691e355b3cd89d6d/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=229c59193afa304d5f3f214a691e355b3cd89d6d", "patch": "@@ -98,6 +98,7 @@ Some basic guidelines for editing this document:\n * @code{CO_BROADCAST}:  CO_BROADCAST, Copy a value to all images the current set of images\n * @code{CO_MAX}:        CO_MAX,    Maximal value on the current set of images\n * @code{CO_MIN}:        CO_MIN,    Minimal value on the current set of images\n+* @code{CO_REDUCE}:     CO_REDUCE, Reduction of values on the current set of images\n * @code{CO_SUM}:        CO_SUM,    Sum of values on the current set of images\n * @code{COMMAND_ARGUMENT_COUNT}: COMMAND_ARGUMENT_COUNT, Get number of command line arguments\n * @code{COMPILER_OPTIONS}: COMPILER_OPTIONS, Options passed to the compiler\n@@ -3340,7 +3341,7 @@ end program test\n @end smallexample\n \n @item @emph{See also}:\n-@ref{CO_MAX}, @ref{CO_MIN}, @ref{CO_SUM}\n+@ref{CO_MAX}, @ref{CO_MIN}, @ref{CO_SUM}, @ref{CO_REDUCE}\n @end table\n \n \n@@ -3354,7 +3355,7 @@ end program test\n @item @emph{Description}:\n @code{CO_MAX} determines element-wise the maximal value of @var{A} on all\n images of the current team.  If @var{RESULT_IMAGE} is present, the maximum\n-values are returned on in @var{A} on the specified image only and the value\n+values are returned in @var{A} on the specified image only and the value\n of @var{A} on the other images become undefined.  If @var{RESULT_IMAGE} is\n not present, the value is returned on all images.  If the execution was\n successful and @var{STAT} is present, it is assigned the value zero.  If the\n@@ -3394,7 +3395,7 @@ end program test\n @end smallexample\n \n @item @emph{See also}:\n-@ref{CO_MIN}, @ref{CO_SUM}, @ref{CO_BROADCAST}\n+@ref{CO_MIN}, @ref{CO_SUM}, @ref{CO_REDUCE}, @ref{CO_BROADCAST}\n @end table\n \n \n@@ -3408,7 +3409,7 @@ end program test\n @item @emph{Description}:\n @code{CO_MIN} determines element-wise the minimal value of @var{A} on all\n images of the current team.  If @var{RESULT_IMAGE} is present, the minimal\n-values are returned on in @var{A} on the specified image only and the value\n+values are returned in @var{A} on the specified image only and the value\n of @var{A} on the other images become undefined.  If @var{RESULT_IMAGE} is\n not present, the value is returned on all images.  If the execution was\n successful and @var{STAT} is present, it is assigned the value zero.  If the\n@@ -3448,7 +3449,87 @@ end program test\n @end smallexample\n \n @item @emph{See also}:\n-@ref{CO_MAX}, @ref{CO_SUM}, @ref{CO_BROADCAST}\n+@ref{CO_MAX}, @ref{CO_SUM}, @ref{CO_REDUCE}, @ref{CO_BROADCAST}\n+@end table\n+\n+\n+\n+@node CO_REDUCE\n+@section @code{CO_REDUCE} --- Reduction of values on the current set of images\n+@fnindex CO_REDUCE\n+@cindex Collectives, generic reduction\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{CO_REDUCE} determines element-wise the reduction of the value of @var{A}\n+on all images of the current team.  The pure function passed as @var{OPERATOR}\n+is used to pairwise reduce the values of @var{A} by passing either the value\n+of @var{A} of different images or the result values of such a reduction as\n+argument.  If @var{A} is an array, the deduction is done element wise. If\n+@var{RESULT_IMAGE} is present, the result values are returned in @var{A} on\n+the specified image only and the value of @var{A} on the other images become\n+undefined.  If @var{RESULT_IMAGE} is not present, the value is returned on all\n+images.  If the execution was successful and @var{STAT} is present, it is\n+assigned the value zero.  If the execution failed, @var{STAT} gets assigned\n+a nonzero value and, if present, @var{ERRMSG} gets assigned a value describing\n+the occurred error.\n+\n+@item @emph{Standard}:\n+Technical Specification (TS) 18508 or later\n+\n+@item @emph{Class}:\n+Collective subroutine\n+\n+@item @emph{Syntax}:\n+@code{CALL CO_REDUCE(A, OPERATOR, [, RESULT_IMAGE, STAT, ERRMSG])}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{A}            @tab is an @code{INTENT(INOUT)} argument and shall be\n+nonpolymorphic. If it is allocatable, it shall be allocated; if it is a pointer,\n+it shall be associated.  @var{A} shall have the same type and type parameters on\n+all images of the team; if it is an array, it shall have the same shape on all\n+images.\n+@item @var{OPERATOR}     @tab pure function with two scalar nonallocatable\n+arguments, which shall be nonpolymorphic and have the same type and type\n+parameters as @var{A}.  The function shall return a nonallocatable scalar of\n+the same type and type parameters as @var{A}.  The function shall be the same on\n+all images and with regards to the arguments mathematically commutative and\n+associative.  Note that @var{OPERATOR} may not be an elemental function, unless\n+it is an intrisic function.\n+@item @var{RESULT_IMAGE} @tab (optional) a scalar integer expression; if\n+present, it shall have the same the same value on all images and refer to an\n+image of the current team.\n+@item @var{STAT}         @tab (optional) a scalar integer variable\n+@item @var{ERRMSG}       @tab (optional) a scalar character variable\n+@end multitable\n+\n+@item @emph{Example}:\n+@smallexample\n+program test\n+  integer :: val\n+  val = this_image ()\n+  call co_reduce (val, result_image=1, operator=myprod)\n+  if (this_image() == 1) then\n+    write(*,*) \"Product value\", val  ! prints num_images() factorial\n+  end if\n+contains\n+  pure function myprod(a, b)\n+    integer, value :: a, b\n+    integer :: myprod\n+    myprod = a * b\n+  end function myprod\n+end program test\n+@end smallexample\n+\n+@item @emph{Note}:\n+While the rules permit in principle an intrinsic function, none of the\n+intrinsics in the standard fulfill the criteria of having a specific\n+function, which takes two arguments of the same type and returning that\n+type as result.\n+\n+@item @emph{See also}:\n+@ref{CO_MIN}, @ref{CO_MAX}, @ref{CO_SUM}, @ref{CO_BROADCAST}\n @end table\n \n \n@@ -3462,7 +3543,7 @@ end program test\n @item @emph{Description}:\n @code{CO_SUM} sums up the values of each element of @var{A} on all\n images of the current team.  If @var{RESULT_IMAGE} is present, the summed-up\n-values are returned on in @var{A} on the specified image only and the value\n+values are returned in @var{A} on the specified image only and the value\n of @var{A} on the other images become undefined.  If @var{RESULT_IMAGE} is\n not present, the value is returned on all images.  If the execution was\n successful and @var{STAT} is present, it is assigned the value zero.  If the\n@@ -3502,7 +3583,7 @@ end program test\n @end smallexample\n \n @item @emph{See also}:\n-@ref{CO_MAX}, @ref{CO_MIN}, @ref{CO_BROADCAST}\n+@ref{CO_MAX}, @ref{CO_MIN}, @ref{CO_REDUCE}, @ref{CO_BROADCAST}\n @end table\n \n \n@@ -3671,7 +3752,7 @@ value is of default @code{COMPLEX} type.\n If @var{X} and @var{Y} are of @code{REAL} type, or one is of @code{REAL}\n type and one is of @code{INTEGER} type, then the return value is of\n @code{COMPLEX} type with a kind equal to that of the @code{REAL}\n-argument with the highest precision.  \n+argument with the highest precision.\n \n @item @emph{Example}:\n @smallexample\n@@ -3689,7 +3770,7 @@ end program test_complex\n \n \n @node CONJG\n-@section @code{CONJG} --- Complex conjugate function \n+@section @code{CONJG} --- Complex conjugate function\n @fnindex CONJG\n @fnindex DCONJG\n @cindex complex conjugate\n@@ -3739,7 +3820,7 @@ end program test_conjg\n \n \n @node COS\n-@section @code{COS} --- Cosine function \n+@section @code{COS} --- Cosine function\n @fnindex COS\n @fnindex DCOS\n @fnindex CCOS\n@@ -3798,7 +3879,7 @@ Inverse function: @ref{ACOS}\n \n \n @node COSH\n-@section @code{COSH} --- Hyperbolic cosine function \n+@section @code{COSH} --- Hyperbolic cosine function\n @fnindex COSH\n @fnindex DCOSH\n @cindex hyperbolic cosine\n@@ -4166,7 +4247,7 @@ end program test_time_and_date\n \n \n @node DBLE\n-@section @code{DBLE} --- Double conversion function \n+@section @code{DBLE} --- Double conversion function\n @fnindex DBLE\n @cindex conversion, to real\n \n@@ -4448,7 +4529,7 @@ end program test_dprod\n @item @emph{Specific names}:\n @multitable @columnfractions .20 .20 .20 .25\n @item Name              @tab Argument               @tab Return type       @tab Standard\n-@item @code{DPROD(X,Y)} @tab @code{REAL(4) X, Y}    @tab @code{REAL(4)}    @tab Fortran 77 and later\n+@item @code{DPROD(X,Y)} @tab @code{REAL(4) X, Y}    @tab @code{REAL(8)}    @tab Fortran 77 and later\n @end multitable\n \n @end table"}, {"sha": "dda755b142b6ebbf99969f87ce65bcb8c56c3f7c", "filename": "gcc/fortran/libgfortran.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/229c59193afa304d5f3f214a691e355b3cd89d6d/gcc%2Ffortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/229c59193afa304d5f3f214a691e355b3cd89d6d/gcc%2Ffortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flibgfortran.h?ref=229c59193afa304d5f3f214a691e355b3cd89d6d", "patch": "@@ -130,6 +130,14 @@ typedef enum\n   GFC_CAF_ATOMIC_XOR\n } libcaf_atomic_codes;\n \n+\n+/* For CO_REDUCE.  */\n+#define GFC_CAF_BYREF      (1<<0)\n+#define GFC_CAF_HIDDENLEN  (1<<1)\n+#define GFC_CAF_ARG_VALUE  (1<<2)\n+#define GFC_CAF_ARG_DESC   (1<<3)\n+\n+\n /* Default unit number for preconnected standard input and output.  */\n #define GFC_STDIN_UNIT_NUMBER 5\n #define GFC_STDOUT_UNIT_NUMBER 6"}, {"sha": "3fbc789b3469e29ccc229067eb24ed23ba5061cf", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/229c59193afa304d5f3f214a691e355b3cd89d6d/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/229c59193afa304d5f3f214a691e355b3cd89d6d/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=229c59193afa304d5f3f214a691e355b3cd89d6d", "patch": "@@ -153,6 +153,7 @@ tree gfor_fndecl_caf_unlock;\n tree gfor_fndecl_co_broadcast;\n tree gfor_fndecl_co_max;\n tree gfor_fndecl_co_min;\n+tree gfor_fndecl_co_reduce;\n tree gfor_fndecl_co_sum;\n \n \n@@ -3445,6 +3446,14 @@ gfc_build_builtin_function_decls (void)\n \tvoid_type_node, 6, pvoid_type_node, integer_type_node,\n \tpint_type, pchar_type_node, integer_type_node, integer_type_node);\n \n+      gfor_fndecl_co_reduce = gfc_build_library_function_decl_with_spec (\n+\tget_identifier (PREFIX(\"caf_co_reduce\")), \"W.R.WW\",\n+\tvoid_type_node, 8, pvoid_type_node,\n+        build_pointer_type (build_varargs_function_type_list (void_type_node,\n+\t\t\t\t\t\t\t      NULL_TREE)),\n+\tinteger_type_node, integer_type_node, pint_type, pchar_type_node,\n+\tinteger_type_node, integer_type_node);\n+\n       gfor_fndecl_co_sum = gfc_build_library_function_decl_with_spec (\n \tget_identifier (PREFIX(\"caf_co_sum\")), \"W.WW\",\n \tvoid_type_node, 5, pvoid_type_node, integer_type_node,"}, {"sha": "932bf7972b56a0cbbb51670cded6e434f2425618", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 62, "deletions": 10, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/229c59193afa304d5f3f214a691e355b3cd89d6d/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/229c59193afa304d5f3f214a691e355b3cd89d6d/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=229c59193afa304d5f3f214a691e355b3cd89d6d", "patch": "@@ -8563,15 +8563,31 @@ conv_co_collective (gfc_code *code)\n   gfc_se argse;\n   stmtblock_t block, post_block;\n   tree fndecl, array, strlen, image_index, stat, errmsg, errmsg_len;\n+  gfc_expr *image_idx_expr, *stat_expr, *errmsg_expr, *opr_expr;\n \n   gfc_start_block (&block);\n   gfc_init_block (&post_block);\n \n+  if (code->resolved_isym->id == GFC_ISYM_CO_REDUCE)\n+    {\n+      opr_expr = code->ext.actual->next->expr;\n+      image_idx_expr = code->ext.actual->next->next->expr;\n+      stat_expr = code->ext.actual->next->next->next->expr;\n+      errmsg_expr = code->ext.actual->next->next->next->next->expr;\n+    }\n+  else\n+    {\n+      opr_expr = NULL;\n+      image_idx_expr = code->ext.actual->next->expr;\n+      stat_expr = code->ext.actual->next->next->expr;\n+      errmsg_expr = code->ext.actual->next->next->next->expr;\n+    }\n+\n   /* stat.  */\n-  if (code->ext.actual->next->next->expr)\n+  if (stat_expr)\n     {\n       gfc_init_se (&argse, NULL);\n-      gfc_conv_expr (&argse, code->ext.actual->next->next->expr);\n+      gfc_conv_expr (&argse, stat_expr);\n       gfc_add_block_to_block (&block, &argse.pre);\n       gfc_add_block_to_block (&post_block, &argse.post);\n       stat = argse.expr;\n@@ -8620,10 +8636,10 @@ conv_co_collective (gfc_code *code)\n     strlen = integer_zero_node;\n \n   /* image_index.  */\n-  if (code->ext.actual->next->expr)\n+  if (image_idx_expr)\n     {\n       gfc_init_se (&argse, NULL);\n-      gfc_conv_expr (&argse, code->ext.actual->next->expr);\n+      gfc_conv_expr (&argse, image_idx_expr);\n       gfc_add_block_to_block (&block, &argse.pre);\n       gfc_add_block_to_block (&post_block, &argse.post);\n       image_index = fold_convert (integer_type_node, argse.expr);\n@@ -8632,10 +8648,10 @@ conv_co_collective (gfc_code *code)\n     image_index = integer_zero_node;\n \n   /* errmsg.  */\n-  if (code->ext.actual->next->next->next->expr)\n+  if (errmsg_expr)\n     {\n       gfc_init_se (&argse, NULL);\n-      gfc_conv_expr (&argse, code->ext.actual->next->next->next->expr);\n+      gfc_conv_expr (&argse, errmsg_expr);\n       gfc_add_block_to_block (&block, &argse.pre);\n       gfc_add_block_to_block (&post_block, &argse.post);\n       errmsg = argse.expr;\n@@ -8659,6 +8675,9 @@ conv_co_collective (gfc_code *code)\n     case GFC_ISYM_CO_MIN:\n       fndecl = gfor_fndecl_co_min;\n       break;\n+    case GFC_ISYM_CO_REDUCE:\n+      fndecl = gfor_fndecl_co_reduce;\n+      break;\n     case GFC_ISYM_CO_SUM:\n       fndecl = gfor_fndecl_co_sum;\n       break;\n@@ -8670,9 +8689,44 @@ conv_co_collective (gfc_code *code)\n       || code->resolved_isym->id == GFC_ISYM_CO_BROADCAST)\n     fndecl = build_call_expr_loc (input_location, fndecl, 5, array,\n \t\t\t\t  image_index, stat, errmsg, errmsg_len);\n-  else\n+  else if (code->resolved_isym->id != GFC_ISYM_CO_REDUCE)\n     fndecl = build_call_expr_loc (input_location, fndecl, 6, array, image_index,\n \t\t\t\t  stat, errmsg, strlen, errmsg_len);\n+  else\n+    {\n+      tree opr, opr_flags;\n+\n+      // FIXME: Handle TS29113's bind(C) strings with descriptor.\n+      int opr_flag_int;\n+      if (gfc_is_proc_ptr_comp (opr_expr))\n+\t{\n+\t  gfc_symbol *sym = gfc_get_proc_ptr_comp (opr_expr)->ts.interface;\n+\t  opr_flag_int = sym->attr.dimension\n+\t\t\t || (sym->ts.type == BT_CHARACTER\n+\t\t\t     && !sym->attr.is_bind_c)\n+\t\t\t ? GFC_CAF_BYREF : 0;\n+\t  opr_flag_int |= opr_expr->ts.type == BT_CHARACTER\n+\t\t\t  && !sym->attr.is_bind_c\n+\t\t\t  ? GFC_CAF_HIDDENLEN : 0;\n+\t  opr_flag_int |= sym->formal->sym->attr.value ? GFC_CAF_ARG_VALUE : 0;\n+\t}\n+      else\n+\t{\n+\t  opr_flag_int = gfc_return_by_reference (opr_expr->symtree->n.sym)\n+\t\t\t ? GFC_CAF_BYREF : 0;\n+\t  opr_flag_int |= opr_expr->ts.type == BT_CHARACTER\n+\t\t\t  && !opr_expr->symtree->n.sym->attr.is_bind_c\n+\t\t\t  ? GFC_CAF_HIDDENLEN : 0;\n+\t  opr_flag_int |= opr_expr->symtree->n.sym->formal->sym->attr.value\n+\t\t\t  ? GFC_CAF_ARG_VALUE : 0;\n+\t}\n+      opr_flags = build_int_cst (integer_type_node, opr_flag_int);\n+      gfc_conv_expr (&argse, opr_expr);\n+      opr = gfc_build_addr_expr (NULL_TREE, argse.expr);\n+      fndecl = build_call_expr_loc (input_location, fndecl, 8, array, opr, opr_flags,\n+\t\t\t\t    image_index, stat, errmsg, strlen, errmsg_len);\n+    }\n+\n   gfc_add_expr_to_block (&block, fndecl);\n   gfc_add_block_to_block (&block, &post_block);\n \n@@ -9386,12 +9440,10 @@ gfc_conv_intrinsic_subroutine (gfc_code *code)\n       res = conv_caf_send (code);\n       break;\n \n-    case GFC_ISYM_CO_REDUCE:\n-      gcc_unreachable ();\n-      break;\n     case GFC_ISYM_CO_BROADCAST:\n     case GFC_ISYM_CO_MIN:\n     case GFC_ISYM_CO_MAX:\n+    case GFC_ISYM_CO_REDUCE:\n     case GFC_ISYM_CO_SUM:\n       res = conv_co_collective (code);\n       break;"}, {"sha": "51ad910875dd610701644de9be64555debd4a64d", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/229c59193afa304d5f3f214a691e355b3cd89d6d/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/229c59193afa304d5f3f214a691e355b3cd89d6d/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=229c59193afa304d5f3f214a691e355b3cd89d6d", "patch": "@@ -742,6 +742,7 @@ extern GTY(()) tree gfor_fndecl_caf_unlock;\n extern GTY(()) tree gfor_fndecl_co_broadcast;\n extern GTY(()) tree gfor_fndecl_co_max;\n extern GTY(()) tree gfor_fndecl_co_min;\n+extern GTY(()) tree gfor_fndecl_co_reduce;\n extern GTY(()) tree gfor_fndecl_co_sum;\n \n "}, {"sha": "00a78cc11182eecb70023f397d4b0b11a2012621", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/229c59193afa304d5f3f214a691e355b3cd89d6d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/229c59193afa304d5f3f214a691e355b3cd89d6d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=229c59193afa304d5f3f214a691e355b3cd89d6d", "patch": "@@ -1,3 +1,11 @@\n+2014-10-24  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* gfortran.dg/coarray_collectives_9.f90: Remove dg-error.\n+\t* gfortran.dg/coarray_collectives_13.f90: New.\n+\t* gfortran.dg/coarray_collectives_14.f90: New.\n+\t* gfortran.dg/coarray_collectives_15.f90: New.\n+\t* gfortran.dg/coarray_collectives_16.f90: New.\n+\n 2014-10-24  Jiong Wang  <jiong.wang@arm.com>\n \n \t* gcc.target/arm/aapcs/abitest.h: Declare memcpy."}, {"sha": "906785caf54fe83a3913ae568d7e12e4f9600a83", "filename": "gcc/testsuite/gfortran.dg/coarray_collectives_13.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/229c59193afa304d5f3f214a691e355b3cd89d6d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_collectives_13.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/229c59193afa304d5f3f214a691e355b3cd89d6d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_collectives_13.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_collectives_13.f90?ref=229c59193afa304d5f3f214a691e355b3cd89d6d", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=single -std=f2008\" }\n+!\n+!\n+! CO_REDUCE/CO_BROADCAST\n+!\n+program test\n+  implicit none\n+  intrinsic co_reduce ! { dg-error \"is not available in the current standard settings but new in TS 29113/TS 18508.\" }\n+  intrinsic co_broadcast ! { dg-error \"is not available in the current standard settings but new in TS 29113/TS 18508.\" }\n+end program test"}, {"sha": "f0ab9327b29ed1fe11c2c72b833db4ca90d009ae", "filename": "gcc/testsuite/gfortran.dg/coarray_collectives_14.f90", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/229c59193afa304d5f3f214a691e355b3cd89d6d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_collectives_14.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/229c59193afa304d5f3f214a691e355b3cd89d6d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_collectives_14.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_collectives_14.f90?ref=229c59193afa304d5f3f214a691e355b3cd89d6d", "patch": "@@ -0,0 +1,146 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=single -fmax-errors=80\" }\n+!\n+!\n+! CO_REDUCE (plus CO_MIN/MAX/SUM/BROADCAST)\n+!\n+program test\n+  implicit none (external, type)\n+  intrinsic co_reduce\n+  intrinsic co_broadcast\n+  intrinsic co_min\n+  intrinsic co_max\n+  intrinsic co_sum\n+  intrinsic dprod\n+  external ext\n+\n+  type t\n+    procedure(), nopass :: ext\n+    procedure(valid), nopass :: valid\n+    procedure(sub), nopass :: sub\n+    procedure(nonpure), nopass :: nonpure\n+    procedure(arg1), nopass :: arg1\n+    procedure(arg2), nopass :: arg2\n+    procedure(elem), nopass :: elem\n+    procedure(realo), nopass :: realo\n+    procedure(int8), nopass :: int8\n+    procedure(arr), nopass :: arr\n+    procedure(ptr), nopass :: ptr\n+    procedure(alloc), nopass :: alloc\n+    procedure(opt), nopass :: opt\n+    procedure(val), nopass :: val\n+    procedure(async), nopass :: async\n+    procedure(tgt), nopass :: tgt\n+    procedure(char44), nopass :: char44\n+    procedure(char34), nopass :: char34\n+  end type t\n+\n+  type(t) :: dt\n+  integer :: caf[*]\n+  character(len=3) :: c3\n+  character(len=4) :: c4\n+\n+\n+\n+  call co_min(caf[1]) ! { dg-error \"shall not be coindexed\" }\n+  call co_max(caf[1]) ! { dg-error \"shall not be coindexed\" }\n+  call co_sum(caf[1]) ! { dg-error \"shall not be coindexed\" }\n+  call co_broadcast(caf[1], source_image=1) ! { dg-error \"shall not be coindexed\" }\n+  call co_reduce(caf[1], valid) ! { dg-error \"shall not be coindexed\" }\n+\n+  call co_reduce(caf, valid) ! OK\n+  call co_reduce(caf, dt%valid) ! OK\n+  call co_reduce(caf, dprod) ! { dg-error \"is not permitted for CO_REDUCE\" }\n+  call co_reduce(caf, ext) ! { dg-error \"must be a PURE function\" }\n+  call co_reduce(caf, dt%ext) ! { dg-error \"must be a PURE function\" }\n+  call co_reduce(caf, sub) ! { dg-error \"must be a PURE function\" }\n+  call co_reduce(caf, dt%sub) ! { dg-error \"must be a PURE function\" }\n+  call co_reduce(caf, nonpure) ! { dg-error \"must be a PURE function\" }\n+  call co_reduce(caf, dt%nonpure) ! { dg-error \"must be a PURE function\" }\n+  call co_reduce(caf, arg1) ! { dg-error \"shall have two arguments\" }\n+  call co_reduce(caf, dt%arg1) ! { dg-error \"shall have two arguments\" }\n+  call co_reduce(caf, arg3) ! { dg-error \"shall have two arguments\" }\n+  call co_reduce(caf, dt%arg3) ! { dg-error \"shall have two arguments\" }\n+  call co_reduce(caf, elem) ! { dg-error \"ELEMENTAL non-INTRINSIC procedure 'elem' is not allowed as an actual argument\" }\n+  call co_reduce(caf, dt%elem) ! { dg-error \"ELEMENTAL non-INTRINSIC procedure 'elem' is not allowed as an actual argument\" }\n+  call co_reduce(caf, realo) ! { dg-error \"A argument at .1. has type INTEGER.4. but the function passed as OPERATOR at .2. returns REAL.4.\" }\n+  call co_reduce(caf, dt%realo) ! { dg-error \"A argument at .1. has type INTEGER.4. but the function passed as OPERATOR at .2. returns REAL.4.\" }\n+  call co_reduce(caf, int8) ! { dg-error \"A argument at .1. has type INTEGER.4. but the function passed as OPERATOR at .2. returns INTEGER.8.\" }\n+  call co_reduce(caf, dt%int8) ! { dg-error \"A argument at .1. has type INTEGER.4. but the function passed as OPERATOR at .2. returns INTEGER.8.\" }\n+  call co_reduce(caf, arr) ! { dg-error \"scalar nonallocatable nonpointer arguments and return a nonallocatable nonpointer scalar\" }\n+  call co_reduce(caf, dt%arr) ! { dg-error \"scalar nonallocatable nonpointer arguments and return a nonallocatable nonpointer scalar\" }\n+  call co_reduce(caf, ptr) ! { dg-error \"scalar nonallocatable nonpointer arguments and return a nonallocatable nonpointer scalar\" }\n+  call co_reduce(caf, dt%ptr) ! { dg-error \"scalar nonallocatable nonpointer arguments and return a nonallocatable nonpointer scalar\" }\n+  call co_reduce(caf, alloc) ! { dg-error \"scalar nonallocatable nonpointer arguments and return a nonallocatable nonpointer scalar\" }\n+  call co_reduce(caf, dt%alloc) ! { dg-error \"scalar nonallocatable nonpointer arguments and return a nonallocatable nonpointer scalar\" }\n+  call co_reduce(caf, opt) ! { dg-error \"shall not have the OPTIONAL attribute for either of the arguments\" }\n+  call co_reduce(caf, dt%opt) ! { dg-error \"shall not have the OPTIONAL attribute for either of the arguments\" }\n+  call co_reduce(caf, val) ! { dg-error \"shall have the VALUE attribute either for none or both arguments\" }\n+  call co_reduce(caf, dt%val) ! { dg-error \"shall have the VALUE attribute either for none or both arguments\" }\n+  call co_reduce(caf, async) ! { dg-error \"shall have the ASYNCHRONOUS attribute either for none or both arguments\" }\n+  call co_reduce(caf, dt%async) ! { dg-error \"shall have the ASYNCHRONOUS attribute either for none or both arguments\" }\n+  call co_reduce(caf, tgt) ! { dg-error \"shall have the TARGET attribute either for none or both arguments\" }\n+  call co_reduce(caf, dt%tgt) ! { dg-error \"shall have the TARGET attribute either for none or both arguments\" }\n+  call co_reduce(c4, char44) ! OK\n+  call co_reduce(c4, dt%char44) ! OK\n+  call co_reduce(c3, char34) ! { dg-error \"character length of the A argument at .1. and of the arguments of the OPERATOR at .2. shall be the same\" }\n+  call co_reduce(c3, dt%char34) ! { dg-error \"character length of the A argument at .1. and of the arguments of the OPERATOR at .2. shall be the same\" }\n+  call co_reduce(c4, char34) ! { dg-error \"The character length of the A argument at .1. and of the function result of the OPERATOR at .2. shall be the same\" }\n+  call co_reduce(c4, dt%char34) ! { dg-error \"The character length of the A argument at .1. and of the function result of the OPERATOR at .2. shall be the same\" }\n+\n+contains\n+  pure integer function valid(x,y)\n+    integer, value :: x, y\n+  end function valid\n+  impure integer function nonpure(x,y)\n+    integer, value :: x, y\n+  end function nonpure\n+  pure subroutine sub()\n+  end subroutine sub\n+  pure integer function arg3(x, y, z)\n+    integer, value :: x, y, z\n+  end function arg3\n+  pure integer function arg1(x)\n+    integer, value :: x\n+  end function arg1\n+  pure elemental integer function elem(x,y)\n+    integer, value :: x, y\n+  end function elem\n+  pure real function realo(x,y)\n+    integer, value :: x, y\n+  end function realo\n+  pure integer(8) function int8(x,y)\n+    integer, value :: x, y\n+  end function int8\n+  pure integer function arr(x,y)\n+    integer, intent(in) :: x(:), y\n+  end function arr\n+  pure integer function ptr(x,y)\n+    integer, intent(in), pointer :: x, y\n+  end function ptr\n+  pure integer function alloc(x,y)\n+    integer, intent(in), allocatable :: x, y\n+  end function alloc\n+  pure integer function opt(x,y)\n+    integer, intent(in) :: x, y\n+    optional :: x, y\n+  end function opt\n+  pure integer function val(x,y)\n+    integer, value :: x\n+    integer, intent(in) :: y\n+  end function val\n+  pure integer function tgt(x,y)\n+    integer, intent(in) :: x, y\n+    target :: x\n+  end function tgt\n+  pure integer function async(x,y)\n+    integer, intent(in) :: x, y\n+    asynchronous :: y\n+  end function async\n+  pure character(4) function char44(x,y)\n+    character(len=4), value :: x, y\n+  end function char44\n+  pure character(3) function char34(x,y)\n+    character(len=4), value :: x, y\n+  end function char34\n+end program test"}, {"sha": "1e14dbbc0371f9c7faaa4a8e7bc328ae5116534b", "filename": "gcc/testsuite/gfortran.dg/coarray_collectives_15.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/229c59193afa304d5f3f214a691e355b3cd89d6d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_collectives_15.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/229c59193afa304d5f3f214a691e355b3cd89d6d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_collectives_15.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_collectives_15.f90?ref=229c59193afa304d5f3f214a691e355b3cd89d6d", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do compile }\n+! { dg-options \"-fdump-tree-original -fcoarray=single\" }\n+!\n+! CO_REDUCE\n+!\n+program test\n+  implicit none\n+  intrinsic co_reduce\n+  integer :: stat1\n+  real :: val\n+  call co_reduce(val, valid, result_image=1, stat=stat1)\n+contains\n+  pure real function valid(x,y)\n+    real, value :: x, y\n+    valid = x * y\n+  end function valid\n+end program test\n+\n+! { dg-final { scan-tree-dump-times \"stat1 = 0;\" 1 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "d7fb00b336f861d67ba0e27372b6e58bbd6aa20d", "filename": "gcc/testsuite/gfortran.dg/coarray_collectives_16.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/229c59193afa304d5f3f214a691e355b3cd89d6d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_collectives_16.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/229c59193afa304d5f3f214a691e355b3cd89d6d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_collectives_16.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_collectives_16.f90?ref=229c59193afa304d5f3f214a691e355b3cd89d6d", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do compile }\n+! { dg-options \"-fdump-tree-original -fcoarray=lib\" }\n+!\n+! CO_REDUCE\n+!\n+program test\n+  implicit none\n+  intrinsic co_max\n+  integer :: stat1, stat2, stat3\n+  character(len=6) :: errmesg1\n+  character(len=7) :: errmesg2\n+  character(len=8) :: errmesg3\n+  real :: val1\n+  complex, allocatable :: val2(:)\n+  character(len=99) :: val3\n+  integer :: res\n+\n+  call co_reduce(val1, operator=fr, result_image=num_images(), stat=stat1, errmsg=errmesg1)\n+  call co_reduce(val2, operator=gz, result_image=4, stat=stat2, errmsg=errmesg2)\n+  call co_reduce(val3, operator=hc, result_image=res,stat=stat3, errmsg=errmesg3)\n+contains\n+  pure real function fr(x,y)\n+    real, value :: x, y\n+    fr = x * y\n+  end function fr\n+  pure complex function gz(x,y)\n+    complex, intent(in):: x, y\n+    gz = x *y\n+  end function gz\n+  pure character(len=99) function hc(x,y)\n+    character(len=99), intent(in):: x, y\n+    hc = x(1:50) // y(1:49)\n+  end function hc\n+end program test\n+\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_co_reduce \\\\(&desc.., &fr, 4, _gfortran_caf_num_images \\\\(0, -1\\\\), &stat1, errmesg1, 0, 6\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_co_reduce \\\\(&val2, &gz, 0, 4, &stat2, errmesg2, 0, 7\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_co_reduce \\\\(&desc.., &hc, 1, res, &stat3, errmesg3, 99, 8\\\\);\" 1 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "f53eb4e2f8d1cf68e0e3fe3baa2d408a898a1183", "filename": "gcc/testsuite/gfortran.dg/coarray_collectives_9.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/229c59193afa304d5f3f214a691e355b3cd89d6d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_collectives_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/229c59193afa304d5f3f214a691e355b3cd89d6d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_collectives_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_collectives_9.f90?ref=229c59193afa304d5f3f214a691e355b3cd89d6d", "patch": "@@ -49,8 +49,8 @@ end function red_f2\n   call co_reduce(val, red_f, stat=[1,2]) ! { dg-error \"must be a scalar\" }\n   call co_reduce(val, red_f, stat=1.0) ! { dg-error \"must be INTEGER\" }\n   call co_reduce(val, red_f, stat=1) ! { dg-error \"must be a variable\" }\n-  call co_reduce(val, red_f, stat=i, result_image=1) ! { dg-error \"CO_REDUCE at \\\\(1\\\\) is not yet implemented\" }\n-  call co_reduce(val, red_f, stat=i, errmsg=errmsg, result_image=1) ! { dg-error \"CO_REDUCE at \\\\(1\\\\) is not yet implemented\" }\n+  call co_reduce(val, red_f, stat=i, result_image=1) ! OK\n+  call co_reduce(val, red_f, stat=i, errmsg=errmsg, result_image=1) ! OK\n   call co_reduce(val, red_f, stat=i, errmsg=[errmsg], result_image=1) ! { dg-error \"must be a scalar\" }\n   call co_reduce(val, red_f, stat=i, errmsg=5, result_image=1) ! { dg-error \"must be CHARACTER\" }\n   call co_reduce(val, red_f, errmsg=\"abc\") ! { dg-error \"must be a variable\" }"}]}