{"sha": "95ad24179723a91622852711b74ee3dd95657ffe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTVhZDI0MTc5NzIzYTkxNjIyODUyNzExYjc0ZWUzZGQ5NTY1N2ZmZQ==", "commit": {"author": {"name": "Sebastian Pop", "email": "s.pop@samsung.com", "date": "2015-10-01T15:17:58Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2015-10-01T15:17:58Z"}, "message": "call scev analysis in scop-detection as in sese-to-poly\n\nBefore our rewrite of the scop detection, we used to not have a valid SESE\nregion under hand, and so we used to do more ad-hoc analysis of data references\nby trying to prove that at all levels of a loop nest the data references would\nbe still valid.\n\nNow that we have a valid SESE region, we can call the scev analysis in the same\nway on the same computed loop nest in the scop-detection as in the sese-to-poly.\n\nNext step will be to cache the data references analyzed in the scop detection\nand not compute the same info in sese-to-poly.\n\nThe patch fixes block-1.f90 that used to ICE on x86_64-linux when compiled with\n-m32.  Patch passed bootstrap with BOOT_CFLAGS=\"-g -O2 -fgraphite-identity\n-floop-nest-optimize\" and check on x86_64-linux using ISL-0.15.\n\n2015-09-28  Sebastian Pop  <s.pop@samsung.com>\n\tAditya Kumar  <aditya.k7@samsung.com>\n\n\tPR tree-optimization/67754\n\t* graphite-scop-detection.c (stmt_has_simple_data_refs_p): Call\n\tscev analysis on the same loop nest as analyze_drs_in_stmts.\n\t* graphite-sese-to-poly.c (outermost_loop_in_sese_1): Moved and renamed...\n\t(try_generate_gimple_bb): Call outermost_loop_in_sese.\n\t(analyze_drs_in_stmts): Same.\n\t* sese.c (outermost_loop_in_sese): ...here.\n\nCo-Authored-By: Aditya Kumar <aditya.k7@samsung.com>\n\nFrom-SVN: r228347", "tree": {"sha": "1aef56baeb80db4ce76b5b5c6737e4032b43b5dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1aef56baeb80db4ce76b5b5c6737e4032b43b5dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95ad24179723a91622852711b74ee3dd95657ffe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95ad24179723a91622852711b74ee3dd95657ffe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95ad24179723a91622852711b74ee3dd95657ffe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95ad24179723a91622852711b74ee3dd95657ffe/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf72400ff386816898a63d44045e3b2d18847872", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf72400ff386816898a63d44045e3b2d18847872", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf72400ff386816898a63d44045e3b2d18847872"}], "stats": {"total": 118, "additions": 60, "deletions": 58}, "files": [{"sha": "91b417ad6c424bc5383fc3a39e818af69978a490", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95ad24179723a91622852711b74ee3dd95657ffe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95ad24179723a91622852711b74ee3dd95657ffe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=95ad24179723a91622852711b74ee3dd95657ffe", "patch": "@@ -1,3 +1,14 @@\n+2015-10-01  Sebastian Pop  <s.pop@samsung.com>\n+\t    Aditya Kumar  <aditya.k7@samsung.com>\n+\n+\tPR tree-optimization/67754\n+\t* graphite-scop-detection.c (stmt_has_simple_data_refs_p): Call\n+\tscev analysis on the same loop nest as analyze_drs_in_stmts.\n+\t* graphite-sese-to-poly.c (outermost_loop_in_sese_1): Moved and renamed...\n+\t(try_generate_gimple_bb): Call outermost_loop_in_sese.\n+\t(analyze_drs_in_stmts): Same.\n+\t* sese.c (outermost_loop_in_sese): ...here.\n+\n 2015-10-01  Sebastian Pop  <s.pop@samsung.com>\n \t    Aditya Kumar  <aditya.k7@samsung.com>\n "}, {"sha": "c45df5555de08da1f712886a015806c626e164d1", "filename": "gcc/graphite-scop-detection.c", "status": "modified", "additions": 20, "deletions": 29, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95ad24179723a91622852711b74ee3dd95657ffe/gcc%2Fgraphite-scop-detection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95ad24179723a91622852711b74ee3dd95657ffe/gcc%2Fgraphite-scop-detection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.c?ref=95ad24179723a91622852711b74ee3dd95657ffe", "patch": "@@ -262,46 +262,37 @@ graphite_can_represent_expr (sese_l scop, loop_p loop, tree expr)\n static bool\n stmt_has_simple_data_refs_p (sese_l scop, gimple *stmt)\n {\n-  data_reference_p dr;\n-  int j;\n-  bool res = true;\n+  sese region = new_sese (scop.entry, scop.exit);\n+  loop_p nest = outermost_loop_in_sese (region, gimple_bb (stmt));\n+  loop_p loop = loop_containing_stmt (stmt);\n   vec<data_reference_p> drs = vNULL;\n-  loop_p outer;\n-  loop_p loop_around_scop = get_entry_bb (scop.entry)->loop_father;\n \n-  for (outer = loop_containing_stmt (stmt); outer && outer != loop_around_scop;\n-       outer = loop_outer (outer))\n+  graphite_find_data_references_in_stmt (nest, loop, stmt, &drs);\n+\n+  int j;\n+  data_reference_p dr;\n+  FOR_EACH_VEC_ELT (drs, j, dr)\n     {\n-      graphite_find_data_references_in_stmt (outer,\n-\t\t\t\t\t     loop_containing_stmt (stmt),\n-\t\t\t\t\t     stmt, &drs);\n+      int nb_subscripts = DR_NUM_DIMENSIONS (dr);\n+      tree ref = DR_REF (dr);\n \n-      FOR_EACH_VEC_ELT (drs, j, dr)\n+      for (int i = nb_subscripts - 1; i >= 0; i--)\n \t{\n-\t  int nb_subscripts = DR_NUM_DIMENSIONS (dr);\n-\t  tree ref = DR_REF (dr);\n-\n-\t  for (int i = nb_subscripts - 1; i >= 0; i--)\n+\t  if (!graphite_can_represent_scev (DR_ACCESS_FN (dr, i))\n+\t      || (TREE_CODE (ref) != ARRAY_REF\n+\t\t  && TREE_CODE (ref) != MEM_REF\n+\t\t  && TREE_CODE (ref) != COMPONENT_REF))\n \t    {\n-\t      if (!graphite_can_represent_scev (DR_ACCESS_FN (dr, i))\n-\t\t  || (TREE_CODE (ref) != ARRAY_REF\n-\t\t      && TREE_CODE (ref) != MEM_REF\n-\t\t      && TREE_CODE (ref) != COMPONENT_REF))\n-\t\t{\n-\t\t  free_data_refs (drs);\n-\t\t  return false;\n-\t\t}\n-\n-\t      ref = TREE_OPERAND (ref, 0);\n+\t      free_data_refs (drs);\n+\t      return false;\n \t    }\n-\t}\n \n-      free_data_refs (drs);\n-      drs.create (0);\n+\t  ref = TREE_OPERAND (ref, 0);\n+\t}\n     }\n \n   free_data_refs (drs);\n-  return res;\n+  return true;\n }\n \n /* Return true only when STMT is simple enough for being handled by Graphite."}, {"sha": "40b7d312bdedca4d414770bff5bd9a04f4208603", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 2, "deletions": 28, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95ad24179723a91622852711b74ee3dd95657ffe/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95ad24179723a91622852711b74ee3dd95657ffe/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=95ad24179723a91622852711b74ee3dd95657ffe", "patch": "@@ -274,32 +274,6 @@ free_scops (vec<scop_p> scops)\n   scops.release ();\n }\n \n-/* Same as outermost_loop_in_sese, returns the outermost loop\n-   containing BB in REGION, but makes sure that the returned loop\n-   belongs to the REGION, and so this returns the first loop in the\n-   REGION when the loop containing BB does not belong to REGION.  */\n-\n-static loop_p\n-outermost_loop_in_sese_1 (sese region, basic_block bb)\n-{\n-  loop_p nest = outermost_loop_in_sese (region, bb);\n-\n-  if (loop_in_sese_p (nest, region))\n-    return nest;\n-\n-  /* When the basic block BB does not belong to a loop in the region,\n-     return the first loop in the region.  */\n-  nest = nest->inner;\n-  while (nest)\n-    if (loop_in_sese_p (nest, region))\n-      break;\n-    else\n-      nest = nest->next;\n-\n-  gcc_assert (nest);\n-  return nest;\n-}\n-\n /* Generates a polyhedral black box only if the bb contains interesting\n    information.  */\n \n@@ -309,7 +283,7 @@ try_generate_gimple_bb (scop_p scop, basic_block bb)\n   vec<data_reference_p> drs;\n   drs.create (5);\n   sese region = SCOP_REGION (scop);\n-  loop_p nest = outermost_loop_in_sese_1 (region, bb);\n+  loop_p nest = outermost_loop_in_sese (region, bb);\n   gimple_stmt_iterator gsi;\n \n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n@@ -1934,7 +1908,7 @@ analyze_drs_in_stmts (scop_p scop, basic_block bb, vec<gimple *> stmts)\n   if (!bb_in_sese_p (bb, region))\n     return;\n \n-  nest = outermost_loop_in_sese_1 (region, bb);\n+  nest = outermost_loop_in_sese (region, bb);\n   gbb = gbb_from_bb (bb);\n \n   FOR_EACH_VEC_ELT (stmts, i, stmt)"}, {"sha": "803f519c1f5f06e99128560d6175260b64cb731c", "filename": "gcc/sese.c", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95ad24179723a91622852711b74ee3dd95657ffe/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95ad24179723a91622852711b74ee3dd95657ffe/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=95ad24179723a91622852711b74ee3dd95657ffe", "patch": "@@ -615,7 +615,7 @@ copy_bb_and_scalar_dependences (basic_block bb, sese region,\n /* Returns the outermost loop in SCOP that contains BB.  */\n \n struct loop *\n-outermost_loop_in_sese (sese region, basic_block bb)\n+outermost_loop_in_sese_1 (sese region, basic_block bb)\n {\n   struct loop *nest;\n \n@@ -627,6 +627,32 @@ outermost_loop_in_sese (sese region, basic_block bb)\n   return nest;\n }\n \n+/* Same as outermost_loop_in_sese_1, returns the outermost loop\n+   containing BB in REGION, but makes sure that the returned loop\n+   belongs to the REGION, and so this returns the first loop in the\n+   REGION when the loop containing BB does not belong to REGION.  */\n+\n+loop_p\n+outermost_loop_in_sese (sese region, basic_block bb)\n+{\n+  loop_p nest = outermost_loop_in_sese_1 (region, bb);\n+\n+  if (loop_in_sese_p (nest, region))\n+    return nest;\n+\n+  /* When the basic block BB does not belong to a loop in the region,\n+     return the first loop in the region.  */\n+  nest = nest->inner;\n+  while (nest)\n+    if (loop_in_sese_p (nest, region))\n+      break;\n+    else\n+      nest = nest->next;\n+\n+  gcc_assert (nest);\n+  return nest;\n+}\n+\n /* Sets the false region of an IF_REGION to REGION.  */\n \n void"}]}