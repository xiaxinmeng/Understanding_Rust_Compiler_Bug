{"sha": "2861f77f870baec825bf93d7fa89b1ee3dc52f10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjg2MWY3N2Y4NzBiYWVjODI1YmY5M2Q3ZmE4OWIxZWUzZGM1MmYxMA==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2007-08-28T00:56:05Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2007-08-28T00:56:05Z"}, "message": "write.c (stdbool.h): Add include.\n\n2007-08-27  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\t* io/write.c (stdbool.h): Add include. (sign_t): Move typedef to\n\tnew file write_float.def. Include write_float.def.\n\t(extract_real): Delete. (calculate_sign): Delete.\n\t(calculate_exp): Delete. (calculate_G_format): Delete.\n\t(output_float): Delete. (write_float): Delete.\n\t* io/write_float.def (calculate_sign): Added.\n\t(output_float): Refactored to be independent of kind and added to this\n\tfile for inclusion. (write_infnan): New function to write \"Infinite\" or\n\t\"NaN\" depending on flags passed, independent of kind.\n\t(CALCULATE_EXP): New macro to build kind specific functions. Use it.\n\t(OUTPUT_FLOAT_FMT_G): New macro, likewise. Use it.\n\t(DTOA, DTOAL): Macros to implement \"decimal to ascii\".\n\t(WRITE_FLOAT): New macro for kind specific write_float functions.\n\t(write_float): Revised function to determine kind and use WRITE_FLOAT\n\tto implement kind specific output.\n\nFrom-SVN: r127846", "tree": {"sha": "451fe572569ba81d76ead54039ae68f2726492e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/451fe572569ba81d76ead54039ae68f2726492e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2861f77f870baec825bf93d7fa89b1ee3dc52f10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2861f77f870baec825bf93d7fa89b1ee3dc52f10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2861f77f870baec825bf93d7fa89b1ee3dc52f10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2861f77f870baec825bf93d7fa89b1ee3dc52f10/comments", "author": null, "committer": null, "parents": [{"sha": "c7682132f340237a7c0dc1801c6394578e714b5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7682132f340237a7c0dc1801c6394578e714b5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7682132f340237a7c0dc1801c6394578e714b5d"}], "stats": {"total": 1582, "additions": 828, "deletions": 754}, "files": [{"sha": "1bd0055392fd77db91a78432860cf293fb35eae1", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2861f77f870baec825bf93d7fa89b1ee3dc52f10/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2861f77f870baec825bf93d7fa89b1ee3dc52f10/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=2861f77f870baec825bf93d7fa89b1ee3dc52f10", "patch": "@@ -1,3 +1,21 @@\n+2007-08-27  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\t* io/write.c (stdbool.h): Add include. (sign_t): Move typedef to\n+\tnew file write_float.def. Include write_float.def.\n+\t(extract_real): Delete. (calculate_sign): Delete.\n+\t(calculate_exp): Delete. (calculate_G_format): Delete.\n+\t(output_float): Delete. (write_float): Delete.\n+\t* io/write_float.def (calculate_sign): Added.\n+\t(output_float): Refactored to be independent of kind and added to this\n+\tfile for inclusion. (write_infnan): New function to write \"Infinite\" or\n+\t\"NaN\" depending on flags passed, independent of kind.\n+\t(CALCULATE_EXP): New macro to build kind specific functions. Use it.\n+\t(OUTPUT_FLOAT_FMT_G): New macro, likewise. Use it.\n+\t(DTOA, DTOAL): Macros to implement \"decimal to ascii\".\n+\t(WRITE_FLOAT): New macro for kind specific write_float functions.\n+\t(write_float): Revised function to determine kind and use WRITE_FLOAT\n+\tto implement kind specific output.\n+\n 2007-08-26  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libfortran/33055"}, {"sha": "229250886b3eb84280b1db6dd29c46ebe05c31c1", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 2, "deletions": 754, "changes": 756, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2861f77f870baec825bf93d7fa89b1ee3dc52f10/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2861f77f870baec825bf93d7fa89b1ee3dc52f10/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=2861f77f870baec825bf93d7fa89b1ee3dc52f10", "patch": "@@ -34,16 +34,13 @@ Boston, MA 02110-1301, USA.  */\n #include <ctype.h>\n #include <stdio.h>\n #include <stdlib.h>\n+#include <stdbool.h>\n #include \"libgfortran.h\"\n #include \"io.h\"\n \n #define star_fill(p, n) memset(p, '*', n)\n \n-\n-typedef enum\n-{ SIGN_NONE, SIGN_MINUS, SIGN_PLUS }\n-sign_t;\n-\n+#include \"write_float.def\"\n \n void\n write_a (st_parameter_dt *dtp, const fnode *f, const char *source, int len)\n@@ -235,653 +232,6 @@ extract_uint (const void *p, int len)\n   return i;\n }\n \n-static GFC_REAL_LARGEST\n-extract_real (const void *p, int len)\n-{\n-  GFC_REAL_LARGEST i = 0;\n-  switch (len)\n-    {\n-    case 4:\n-      {\n-\tGFC_REAL_4 tmp;\n-\tmemcpy ((void *) &tmp, p, len);\n-\ti = tmp;\n-      }\n-      break;\n-    case 8:\n-      {\n-\tGFC_REAL_8 tmp;\n-\tmemcpy ((void *) &tmp, p, len);\n-\ti = tmp;\n-      }\n-      break;\n-#ifdef HAVE_GFC_REAL_10\n-    case 10:\n-      {\n-\tGFC_REAL_10 tmp;\n-\tmemcpy ((void *) &tmp, p, len);\n-\ti = tmp;\n-      }\n-      break;\n-#endif\n-#ifdef HAVE_GFC_REAL_16\n-    case 16:\n-      {\n-\tGFC_REAL_16 tmp;\n-\tmemcpy ((void *) &tmp, p, len);\n-\ti = tmp;\n-      }\n-      break;\n-#endif\n-    default:\n-      internal_error (NULL, \"bad real kind\");\n-    }\n-  return i;\n-}\n-\n-\n-/* Given a flag that indicate if a value is negative or not, return a\n-   sign_t that gives the sign that we need to produce.  */\n-\n-static sign_t\n-calculate_sign (st_parameter_dt *dtp, int negative_flag)\n-{\n-  sign_t s = SIGN_NONE;\n-\n-  if (negative_flag)\n-    s = SIGN_MINUS;\n-  else\n-    switch (dtp->u.p.sign_status)\n-      {\n-      case SIGN_SP:\n-\ts = SIGN_PLUS;\n-\tbreak;\n-      case SIGN_SS:\n-\ts = SIGN_NONE;\n-\tbreak;\n-      case SIGN_S:\n-\ts = options.optional_plus ? SIGN_PLUS : SIGN_NONE;\n-\tbreak;\n-      }\n-\n-  return s;\n-}\n-\n-\n-/* Returns the value of 10**d.  */\n-\n-static GFC_REAL_LARGEST\n-calculate_exp (int d)\n-{\n-  int i;\n-  GFC_REAL_LARGEST r = 1.0;\n-\n-  for (i = 0; i< (d >= 0 ? d : -d); i++)\n-    r *= 10;\n-\n-  r = (d >= 0) ? r : 1.0 / r;\n-\n-  return r;\n-}\n-\n-\n-/* Generate corresponding I/O format for FMT_G output.\n-   The rules to translate FMT_G to FMT_E or FMT_F from DEC fortran\n-   LRM (table 11-2, Chapter 11, \"I/O Formatting\", P11-25) is:\n-\n-   Data Magnitude                              Equivalent Conversion\n-   0< m < 0.1-0.5*10**(-d-1)                   Ew.d[Ee]\n-   m = 0                                       F(w-n).(d-1), n' '\n-   0.1-0.5*10**(-d-1)<= m < 1-0.5*10**(-d)     F(w-n).d, n' '\n-   1-0.5*10**(-d)<= m < 10-0.5*10**(-d+1)      F(w-n).(d-1), n' '\n-   10-0.5*10**(-d+1)<= m < 100-0.5*10**(-d+2)  F(w-n).(d-2), n' '\n-   ................                           ..........\n-   10**(d-1)-0.5*10**(-1)<= m <10**d-0.5       F(w-n).0,n(' ')\n-   m >= 10**d-0.5                              Ew.d[Ee]\n-\n-   notes: for Gw.d ,  n' ' means 4 blanks\n-          for Gw.dEe, n' ' means e+2 blanks  */\n-\n-static fnode *\n-calculate_G_format (st_parameter_dt *dtp, const fnode *f,\n-\t\t    GFC_REAL_LARGEST value, int *num_blank)\n-{\n-  int e = f->u.real.e;\n-  int d = f->u.real.d;\n-  int w = f->u.real.w;\n-  fnode *newf;\n-  GFC_REAL_LARGEST m, exp_d;\n-  int low, high, mid;\n-  int ubound, lbound;\n-\n-  newf = get_mem (sizeof (fnode));\n-\n-  /* Absolute value.  */\n-  m = (value > 0.0) ? value : -value;\n-\n-  /* In case of the two data magnitude ranges,\n-     generate E editing, Ew.d[Ee].  */\n-  exp_d = calculate_exp (d);\n-  if ((m > 0.0 && m < 0.1 - 0.05 / exp_d) || (m >= exp_d - 0.5 ) ||\n-      ((m == 0.0) && !(compile_options.allow_std & GFC_STD_F2003)))\n-    {\n-      newf->format = FMT_E;\n-      newf->u.real.w = w;\n-      newf->u.real.d = d;\n-      newf->u.real.e = e;\n-      *num_blank = 0;\n-      return newf;\n-    }\n-\n-  /* Use binary search to find the data magnitude range.  */\n-  mid = 0;\n-  low = 0;\n-  high = d + 1;\n-  lbound = 0;\n-  ubound = d + 1;\n-\n-  while (low <= high)\n-    {\n-      GFC_REAL_LARGEST temp;\n-      mid = (low + high) / 2;\n-\n-      /* 0.1 * 10**mid - 0.5 * 10**(mid-d-1)  */\n-      temp = 0.1 * calculate_exp (mid) - 0.5 * calculate_exp (mid - d - 1);\n-\n-      if (m < temp)\n-        {\n-          ubound = mid;\n-          if (ubound == lbound + 1)\n-            break;\n-          high = mid - 1;\n-        }\n-      else if (m > temp)\n-        {\n-          lbound = mid;\n-          if (ubound == lbound + 1)\n-            {\n-              mid ++;\n-              break;\n-            }\n-          low = mid + 1;\n-        }\n-      else\n-        break;\n-    }\n-\n-  /* Pad with blanks where the exponent would be.  */\n-  if (e < 0)\n-    *num_blank = 4;\n-  else\n-    *num_blank = e + 2;\n-\n-  /* Generate the F editing. F(w-n).(-(mid-d-1)), n' '.  */\n-  newf->format = FMT_F;\n-  newf->u.real.w = f->u.real.w - *num_blank;\n-\n-  /* Special case.  */\n-  if (m == 0.0)\n-    newf->u.real.d = d - 1;\n-  else\n-    newf->u.real.d = - (mid - d - 1);\n-\n-  /* For F editing, the scale factor is ignored.  */\n-  dtp->u.p.scale_factor = 0;\n-  return newf;\n-}\n-\n-\n-/* Output a real number according to its format which is FMT_G free.  */\n-\n-static void\n-output_float (st_parameter_dt *dtp, const fnode *f, GFC_REAL_LARGEST value)\n-{\n-#if defined(HAVE_GFC_REAL_16) && __LDBL_DIG__ > 18\n-# define MIN_FIELD_WIDTH 46\n-#else\n-# define MIN_FIELD_WIDTH 31\n-#endif\n-#define STR(x) STR1(x)\n-#define STR1(x) #x\n-  /* This must be large enough to accurately hold any value.  */\n-  char buffer[MIN_FIELD_WIDTH+1];\n-  char *out;\n-  char *digits;\n-  int e;\n-  char expchar;\n-  format_token ft;\n-  int w;\n-  int d;\n-  int edigits;\n-  int ndigits;\n-  /* Number of digits before the decimal point.  */\n-  int nbefore;\n-  /* Number of zeros after the decimal point.  */\n-  int nzero;\n-  /* Number of digits after the decimal point.  */\n-  int nafter;\n-  /* Number of zeros after the decimal point, whatever the precision.  */\n-  int nzero_real;\n-  int leadzero;\n-  int nblanks;\n-  int i;\n-  int sign_bit;\n-  sign_t sign;\n-\n-  ft = f->format;\n-  w = f->u.real.w;\n-  d = f->u.real.d;\n-\n-  nzero_real = -1;\n-\n-\n-  /* We should always know the field width and precision.  */\n-  if (d < 0)\n-    internal_error (&dtp->common, \"Unspecified precision\");\n-\n-  /* Use sprintf to print the number in the format +D.DDDDe+ddd\n-     For an N digit exponent, this gives us (MIN_FIELD_WIDTH-5)-N digits\n-     after the decimal point, plus another one before the decimal point.  */\n-  sign = calculate_sign (dtp, value < 0.0);\n-  sign_bit = signbit (value);\n-  if (value < 0)\n-    value = -value;\n-\n-  /* Special case when format specifies no digits after the decimal point.  */\n-  if (d == 0 && ft == FMT_F)\n-    {\n-      if (value < 0.5)\n-\tvalue = 0.0;\n-      else if (value < 1.0)\n-\tvalue = value + 0.5;\n-    }\n-\n-  /* printf pads blanks for us on the exponent so we just need it big enough\n-     to handle the largest number of exponent digits expected.  */\n-  edigits=4;\n-\n-  if (ft == FMT_F || ft == FMT_EN\n-      || ((ft == FMT_D || ft == FMT_E) && dtp->u.p.scale_factor != 0))\n-    {\n-      /* Always convert at full precision to avoid double rounding.  */\n-      ndigits = MIN_FIELD_WIDTH - 4 - edigits;\n-    }\n-  else\n-    {\n-      /* We know the number of digits, so can let printf do the rounding\n-\t for us.  */\n-      if (ft == FMT_ES)\n-\tndigits = d + 1;\n-      else\n-\tndigits = d;\n-      if (ndigits > MIN_FIELD_WIDTH - 4 - edigits)\n-\tndigits = MIN_FIELD_WIDTH - 4 - edigits;\n-    }\n-\n-  /* #   The result will always contain a decimal point, even if no\n-   *     digits follow it\n-   *\n-   * -   The converted value is to be left adjusted on the field boundary\n-   *\n-   * +   A sign (+ or -) always be placed before a number\n-   *\n-   * MIN_FIELD_WIDTH  minimum field width\n-   *\n-   * *   (ndigits-1) is used as the precision\n-   *\n-   *   e format: [-]d.ddde\u00b1dd where there is one digit before the\n-   *   decimal-point character and the number of digits after it is\n-   *   equal to the precision. The exponent always contains at least two\n-   *   digits; if the value is zero, the exponent is 00.\n-   */\n-#ifdef HAVE_SNPRINTF\n-  snprintf (buffer, sizeof (buffer), \"%+-#\" STR(MIN_FIELD_WIDTH) \".*\"\n-\t   GFC_REAL_LARGEST_FORMAT \"e\", ndigits - 1, value);\n-#else\n-  sprintf (buffer, \"%+-#\" STR(MIN_FIELD_WIDTH) \".*\"\n-\t   GFC_REAL_LARGEST_FORMAT \"e\", ndigits - 1, value);\n-#endif\n-\n-  /* Check the resulting string has punctuation in the correct places.  */\n-  if (d != 0 && (buffer[2] != '.' || buffer[ndigits + 2] != 'e'))\n-      internal_error (&dtp->common, \"printf is broken\");\n-\n-  /* Read the exponent back in.  */\n-  e = atoi (&buffer[ndigits + 3]) + 1;\n-\n-  /* Make sure zero comes out as 0.0e0.   */\n-  if (value == 0.0)\n-    {\n-      e = 0;\n-      if (compile_options.sign_zero == 1)\n-        sign = calculate_sign (dtp, sign_bit);\n-      else\n-\tsign = calculate_sign (dtp, 0);\n-    }\n-\n-  /* Normalize the fractional component.  */\n-  buffer[2] = buffer[1];\n-  digits = &buffer[2];\n-\n-  /* Figure out where to place the decimal point.  */\n-  switch (ft)\n-    {\n-    case FMT_F:\n-      nbefore = e + dtp->u.p.scale_factor;\n-      if (nbefore < 0)\n-\t{\n-\t  nzero = -nbefore;\n-          nzero_real = nzero;\n-\t  if (nzero > d)\n-\t    nzero = d;\n-\t  nafter = d - nzero;\n-\t  nbefore = 0;\n-\t}\n-      else\n-\t{\n-\t  nzero = 0;\n-\t  nafter = d;\n-\t}\n-      expchar = 0;\n-      break;\n-\n-    case FMT_E:\n-    case FMT_D:\n-      i = dtp->u.p.scale_factor;\n-      if (value != 0.0)\n-\te -= i;\n-      if (i < 0)\n-\t{\n-\t  nbefore = 0;\n-\t  nzero = -i;\n-\t  nafter = d + i;\n-\t}\n-      else if (i > 0)\n-\t{\n-\t  nbefore = i;\n-\t  nzero = 0;\n-\t  nafter = (d - i) + 1;\n-\t}\n-      else /* i == 0 */\n-\t{\n-\t  nbefore = 0;\n-\t  nzero = 0;\n-\t  nafter = d;\n-\t}\n-\n-      if (ft == FMT_E)\n-\texpchar = 'E';\n-      else\n-\texpchar = 'D';\n-      break;\n-\n-    case FMT_EN:\n-      /* The exponent must be a multiple of three, with 1-3 digits before\n-\t the decimal point.  */\n-      if (value != 0.0)\n-        e--;\n-      if (e >= 0)\n-\tnbefore = e % 3;\n-      else\n-\t{\n-\t  nbefore = (-e) % 3;\n-\t  if (nbefore != 0)\n-\t    nbefore = 3 - nbefore;\n-\t}\n-      e -= nbefore;\n-      nbefore++;\n-      nzero = 0;\n-      nafter = d;\n-      expchar = 'E';\n-      break;\n-\n-    case FMT_ES:\n-      if (value != 0.0)\n-        e--;\n-      nbefore = 1;\n-      nzero = 0;\n-      nafter = d;\n-      expchar = 'E';\n-      break;\n-\n-    default:\n-      /* Should never happen.  */\n-      internal_error (&dtp->common, \"Unexpected format token\");\n-    }\n-\n-  /* Round the value.  */\n-  if (nbefore + nafter == 0)\n-    {\n-      ndigits = 0;\n-      if (nzero_real == d && digits[0] >= '5')\n-        {\n-          /* We rounded to zero but shouldn't have */\n-          nzero--;\n-          nafter = 1;\n-          digits[0] = '1';\n-          ndigits = 1;\n-        }\n-    }\n-  else if (nbefore + nafter < ndigits)\n-    {\n-      ndigits = nbefore + nafter;\n-      i = ndigits;\n-      if (digits[i] >= '5')\n-\t{\n-\t  /* Propagate the carry.  */\n-\t  for (i--; i >= 0; i--)\n-\t    {\n-\t      if (digits[i] != '9')\n-\t\t{\n-\t\t  digits[i]++;\n-\t\t  break;\n-\t\t}\n-\t      digits[i] = '0';\n-\t    }\n-\n-\t  if (i < 0)\n-\t    {\n-\t      /* The carry overflowed.  Fortunately we have some spare space\n-\t\t at the start of the buffer.  We may discard some digits, but\n-\t\t this is ok because we already know they are zero.  */\n-\t      digits--;\n-\t      digits[0] = '1';\n-\t      if (ft == FMT_F)\n-\t\t{\n-\t\t  if (nzero > 0)\n-\t\t    {\n-\t\t      nzero--;\n-\t\t      nafter++;\n-\t\t    }\n-\t\t  else\n-\t\t    nbefore++;\n-\t\t}\n-\t      else if (ft == FMT_EN)\n-\t\t{\n-\t\t  nbefore++;\n-\t\t  if (nbefore == 4)\n-\t\t    {\n-\t\t      nbefore = 1;\n-\t\t      e += 3;\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\te++;\n-\t    }\n-\t}\n-    }\n-\n-  /* Calculate the format of the exponent field.  */\n-  if (expchar)\n-    {\n-      edigits = 1;\n-      for (i = abs (e); i >= 10; i /= 10)\n-\tedigits++;\n-\n-      if (f->u.real.e < 0)\n-\t{\n-\t  /* Width not specified.  Must be no more than 3 digits.  */\n-\t  if (e > 999 || e < -999)\n-\t    edigits = -1;\n-\t  else\n-\t    {\n-\t      edigits = 4;\n-\t      if (e > 99 || e < -99)\n-\t\texpchar = ' ';\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* Exponent width specified, check it is wide enough.  */\n-\t  if (edigits > f->u.real.e)\n-\t    edigits = -1;\n-\t  else\n-\t    edigits = f->u.real.e + 2;\n-\t}\n-    }\n-  else\n-    edigits = 0;\n-\n-  /* Pick a field size if none was specified.  */\n-  if (w <= 0)\n-    w = nbefore + nzero + nafter + (sign != SIGN_NONE ? 2 : 1);\n-\n-  /* Create the ouput buffer.  */\n-  out = write_block (dtp, w);\n-  if (out == NULL)\n-    return;\n-\n-  /* Zero values always output as positive, even if the value was negative\n-     before rounding.  */\n-  for (i = 0; i < ndigits; i++)\n-    {\n-      if (digits[i] != '0')\n-\tbreak;\n-    }\n-  if (i == ndigits)\n-    {\n-      /* The output is zero, so set the sign according to the sign bit unless\n-\t -fno-sign-zero was specified.  */\n-      if (compile_options.sign_zero == 1)\n-        sign = calculate_sign (dtp, sign_bit);\n-      else\n-\tsign = calculate_sign (dtp, 0);\n-    }\n-\n-  /* Work out how much padding is needed.  */\n-  nblanks = w - (nbefore + nzero + nafter + edigits + 1);\n-  if (sign != SIGN_NONE)\n-    nblanks--;\n-\n-  /* Check the value fits in the specified field width.  */\n-  if (nblanks < 0 || edigits == -1)\n-    {\n-      star_fill (out, w);\n-      return;\n-    }\n-\n-  /* See if we have space for a zero before the decimal point.  */\n-  if (nbefore == 0 && nblanks > 0)\n-    {\n-      leadzero = 1;\n-      nblanks--;\n-    }\n-  else\n-    leadzero = 0;\n-\n-  /* Pad to full field width.  */\n-\n-  if ( ( nblanks > 0 ) && !dtp->u.p.no_leading_blank)\n-    {\n-      memset (out, ' ', nblanks);\n-      out += nblanks;\n-    }\n-\n-  /* Output the initial sign (if any).  */\n-  if (sign == SIGN_PLUS)\n-    *(out++) = '+';\n-  else if (sign == SIGN_MINUS)\n-    *(out++) = '-';\n-\n-  /* Output an optional leading zero.  */\n-  if (leadzero)\n-    *(out++) = '0';\n-\n-  /* Output the part before the decimal point, padding with zeros.  */\n-  if (nbefore > 0)\n-    {\n-      if (nbefore > ndigits)\n-\t{\n-\t  i = ndigits;\n-\t  memcpy (out, digits, i);\n-\t  ndigits = 0;\n-\t  while (i < nbefore)\n-\t    out[i++] = '0';\n-\t}\n-      else\n-\t{\n-\t  i = nbefore;\n-\t  memcpy (out, digits, i);\n-\t  ndigits -= i;\n-\t}\n-\n-      digits += i;\n-      out += nbefore;\n-    }\n-  /* Output the decimal point.  */\n-  *(out++) = '.';\n-\n-  /* Output leading zeros after the decimal point.  */\n-  if (nzero > 0)\n-    {\n-      for (i = 0; i < nzero; i++)\n-\t*(out++) = '0';\n-    }\n-\n-  /* Output digits after the decimal point, padding with zeros.  */\n-  if (nafter > 0)\n-    {\n-      if (nafter > ndigits)\n-\ti = ndigits;\n-      else\n-\ti = nafter;\n-\n-      memcpy (out, digits, i);\n-      while (i < nafter)\n-\tout[i++] = '0';\n-\n-      digits += i;\n-      ndigits -= i;\n-      out += nafter;\n-    }\n-\n-  /* Output the exponent.  */\n-  if (expchar)\n-    {\n-      if (expchar != ' ')\n-\t{\n-\t  *(out++) = expchar;\n-\t  edigits--;\n-\t}\n-#if HAVE_SNPRINTF\n-      snprintf (buffer, sizeof (buffer), \"%+0*d\", edigits, e);\n-#else\n-      sprintf (buffer, \"%+0*d\", edigits, e);\n-#endif\n-      memcpy (out, buffer, edigits);\n-    }\n-\n-  if (dtp->u.p.no_leading_blank)\n-    {\n-      out += edigits;\n-      memset( out , ' ' , nblanks );\n-      dtp->u.p.no_leading_blank = 0;\n-    }\n-#undef STR\n-#undef STR1\n-#undef MIN_FIELD_WIDTH\n-}\n-\n \n void\n write_l (st_parameter_dt *dtp, const fnode *f, char *source, int len)\n@@ -898,108 +248,6 @@ write_l (st_parameter_dt *dtp, const fnode *f, char *source, int len)\n   p[f->u.w - 1] = (n) ? 'T' : 'F';\n }\n \n-/* Output a real number according to its format.  */\n-\n-static void\n-write_float (st_parameter_dt *dtp, const fnode *f, const char *source, int len)\n-{\n-  GFC_REAL_LARGEST n;\n-  int nb =0, res, save_scale_factor;\n-  char * p, fin;\n-  fnode *f2 = NULL;\n-\n-  n = extract_real (source, len);\n-\n-  if (f->format != FMT_B && f->format != FMT_O && f->format != FMT_Z)\n-    {\n-      res = isfinite (n); \n-      if (res == 0)\n-\t{\n-\t  nb =  f->u.real.w;\n-\t  \n-\t  /* If the field width is zero, the processor must select a width \n-\t     not zero.  4 is chosen to allow output of '-Inf' or '+Inf' */\n-\t     \n-\t  if (nb == 0) nb = 4;\n-\t  p = write_block (dtp, nb);\n-          if (p == NULL)\n-            return;\n-\t  if (nb < 3)\n-\t    {\n-\t      memset (p, '*',nb);\n-\t      return;\n-\t    }\n-\n-\t  memset(p, ' ', nb);\n-\t  res = !isnan (n);\n-\t  if (res != 0)\n-\t    {\n-\t      if (signbit(n))\n-\t        {\n-\t        \n-\t          /* If the sign is negative and the width is 3, there is\n-\t             insufficient room to output '-Inf', so output asterisks */\n-\t             \n-\t          if (nb == 3)\n-\t            {\n-\t              memset (p, '*',nb);\n-\t              return;\n-\t            }\n-\t            \n-\t          /* The negative sign is mandatory */\n-\t            \n-\t          fin = '-';\n-\t\t}    \n-\t      else\n-\t      \n-\t          /* The positive sign is optional, but we output it for\n-\t             consistency */\n-\t             \n-\t\t  fin = '+';\n-\n-\t      if (nb > 8)\n-\t      \n-\t        /* We have room, so output 'Infinity' */\n-\t        \n-\t\tmemcpy(p + nb - 8, \"Infinity\", 8);\n-\t      else\n-\t      \n-\t        /* For the case of width equals 8, there is not enough room\n-\t           for the sign and 'Infinity' so we go with 'Inf' */\n-\t            \n-\t\tmemcpy(p + nb - 3, \"Inf\", 3);\n-\t      if (nb < 9 && nb > 3)\n-\t\tp[nb - 4] = fin;  /* Put the sign in front of Inf */\n-\t      else if (nb > 8)\n-\t\tp[nb - 9] = fin;  /* Put the sign in front of Infinity */\n-\t    }\n-\t  else\n-\t    memcpy(p + nb - 3, \"NaN\", 3);\n-\t  return;\n-\t}\n-    }\n-\n-  if (f->format != FMT_G)\n-    output_float (dtp, f, n);\n-  else\n-    {\n-      save_scale_factor = dtp->u.p.scale_factor;\n-      f2 = calculate_G_format (dtp, f, n, &nb);\n-      output_float (dtp, f2, n);\n-      dtp->u.p.scale_factor = save_scale_factor;\n-      if (f2 != NULL)\n-        free_mem(f2);\n-\n-      if (nb > 0)\n-        {\n-\t  p = write_block (dtp, nb);\n-          if (p == NULL)\n-            return;\n-          memset (p, ' ', nb);\n-        }\n-    }\n-}\n-\n \n static void\n write_int (st_parameter_dt *dtp, const fnode *f, const char *source, int len,"}, {"sha": "ff8be1903af898332ee75305275fbf4a4520237e", "filename": "libgfortran/io/write_float.def", "status": "added", "additions": 808, "deletions": 0, "changes": 808, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2861f77f870baec825bf93d7fa89b1ee3dc52f10/libgfortran%2Fio%2Fwrite_float.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2861f77f870baec825bf93d7fa89b1ee3dc52f10/libgfortran%2Fio%2Fwrite_float.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite_float.def?ref=2861f77f870baec825bf93d7fa89b1ee3dc52f10", "patch": "@@ -0,0 +1,808 @@\n+/* Copyright (C) 2007 Free Software Foundation, Inc.\n+   Contributed by Andy Vaught\n+   Write float code factoring to this file by Jerry DeLisle   \n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with Libgfortran; see the file COPYING.  If not, write to\n+the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+\n+typedef enum\n+{ SIGN_NONE, SIGN_MINUS, SIGN_PLUS }\n+sign_t;\n+\n+/* Given a flag that indicates if a value is negative or not, return a\n+   sign_t that gives the sign that we need to produce.  */\n+\n+static sign_t\n+calculate_sign (st_parameter_dt *dtp, int negative_flag)\n+{\n+  sign_t s = SIGN_NONE;\n+\n+  if (negative_flag)\n+    s = SIGN_MINUS;\n+  else\n+    switch (dtp->u.p.sign_status)\n+      {\n+      case SIGN_SP:\n+\ts = SIGN_PLUS;\n+\tbreak;\n+      case SIGN_SS:\n+\ts = SIGN_NONE;\n+\tbreak;\n+      case SIGN_S:\n+\ts = options.optional_plus ? SIGN_PLUS : SIGN_NONE;\n+\tbreak;\n+      }\n+\n+  return s;\n+}\n+\n+\n+/* Output a real number according to its format which is FMT_G free.  */\n+\n+static void\n+output_float (st_parameter_dt *dtp, const fnode *f, char *buffer,\n+\t      int sign_bit, bool zero_flag, int ndigits, int edigits)\n+{\n+  char *out;\n+  char *digits;\n+  int e;\n+  char expchar;\n+  format_token ft;\n+  int w;\n+  int d;\n+  /* Number of digits before the decimal point.  */\n+  int nbefore;\n+  /* Number of zeros after the decimal point.  */\n+  int nzero;\n+  /* Number of digits after the decimal point.  */\n+  int nafter;\n+  /* Number of zeros after the decimal point, whatever the precision.  */\n+  int nzero_real;\n+  int leadzero;\n+  int nblanks;\n+  int i;\n+  sign_t sign;\n+\n+  ft = f->format;\n+  w = f->u.real.w;\n+  d = f->u.real.d;\n+\n+  nzero_real = -1;\n+\n+  /* We should always know the field width and precision.  */\n+  if (d < 0)\n+    internal_error (&dtp->common, \"Unspecified precision\");\n+\n+  /* Use sprintf to print the number in the format +D.DDDDe+ddd\n+     For an N digit exponent, this gives us (MIN_FIELD_WIDTH-5)-N digits\n+     after the decimal point, plus another one before the decimal point.  */\n+\n+  sign = calculate_sign (dtp, sign_bit);\n+\n+  /* #   The result will always contain a decimal point, even if no\n+   *     digits follow it\n+   *\n+   * -   The converted value is to be left adjusted on the field boundary\n+   *\n+   * +   A sign (+ or -) always be placed before a number\n+   *\n+   * MIN_FIELD_WIDTH  minimum field width\n+   *\n+   * *   (ndigits-1) is used as the precision\n+   *\n+   *   e format: [-]d.ddde\u00b1dd where there is one digit before the\n+   *   decimal-point character and the number of digits after it is\n+   *   equal to the precision. The exponent always contains at least two\n+   *   digits; if the value is zero, the exponent is 00.\n+   */\n+\n+  /* Check the given string has punctuation in the correct places.  */\n+  if (d != 0 && (buffer[2] != '.' || buffer[ndigits + 2] != 'e'))\n+      internal_error (&dtp->common, \"printf is broken\");\n+\n+  /* Read the exponent back in.  */\n+  e = atoi (&buffer[ndigits + 3]) + 1;\n+\n+  /* Make sure zero comes out as 0.0e0.   */\n+  if (zero_flag)\n+    {\n+      e = 0;\n+      if (compile_options.sign_zero == 1)\n+\tsign = calculate_sign (dtp, sign_bit);\n+      else\n+\tsign = calculate_sign (dtp, 0);\n+    }\n+\n+  /* Normalize the fractional component.  */\n+  buffer[2] = buffer[1];\n+  digits = &buffer[2];\n+\n+  /* Figure out where to place the decimal point.  */\n+  switch (ft)\n+    {\n+    case FMT_F:\n+      nbefore = e + dtp->u.p.scale_factor;\n+      if (nbefore <= 0)\n+\t{\n+\t  nzero = -nbefore;\n+          nzero_real = nzero;\n+\t  if (nzero > d)\n+\t    nzero = d;\n+\t  nafter = d - nzero;\n+\t  nbefore = 0;\n+\t}\n+      else\n+\t{\n+\t  nzero = 0;\n+\t  nafter = d;\n+\t}\n+      expchar = 0;\n+      break;\n+\n+    case FMT_E:\n+    case FMT_D:\n+      i = dtp->u.p.scale_factor;\n+      if (!zero_flag)\n+\te -= i;\n+      if (i < 0)\n+\t{\n+\t  nbefore = 0;\n+\t  nzero = -i;\n+\t  nafter = d + i;\n+\t}\n+      else if (i > 0)\n+\t{\n+\t  nbefore = i;\n+\t  nzero = 0;\n+\t  nafter = (d - i) + 1;\n+\t}\n+      else /* i == 0 */\n+\t{\n+\t  nbefore = 0;\n+\t  nzero = 0;\n+\t  nafter = d;\n+\t}\n+\n+      if (ft == FMT_E)\n+\texpchar = 'E';\n+      else\n+\texpchar = 'D';\n+      break;\n+\n+    case FMT_EN:\n+      /* The exponent must be a multiple of three, with 1-3 digits before\n+\t the decimal point.  */\n+      if (!zero_flag)\n+        e--;\n+      if (e >= 0)\n+\tnbefore = e % 3;\n+      else\n+\t{\n+\t  nbefore = (-e) % 3;\n+\t  if (nbefore != 0)\n+\t    nbefore = 3 - nbefore;\n+\t}\n+      e -= nbefore;\n+      nbefore++;\n+      nzero = 0;\n+      nafter = d;\n+      expchar = 'E';\n+      break;\n+\n+    case FMT_ES:\n+      if (!zero_flag)\n+        e--;\n+      nbefore = 1;\n+      nzero = 0;\n+      nafter = d;\n+      expchar = 'E';\n+      break;\n+\n+    default:\n+      /* Should never happen.  */\n+      internal_error (&dtp->common, \"Unexpected format token\");\n+    }\n+\n+  /* Round the value.  */\n+  if (nbefore + nafter == 0)\n+    {\n+      ndigits = 0;\n+      if (nzero_real == d && digits[0] >= '5')\n+        {\n+          /* We rounded to zero but shouldn't have */\n+          nzero--;\n+          nafter = 1;\n+          digits[0] = '1';\n+          ndigits = 1;\n+        }\n+    }\n+  else if (nbefore + nafter < ndigits)\n+    {\n+      ndigits = nbefore + nafter;\n+      i = ndigits;\n+      if (digits[i] >= '5')\n+\t{\n+\t  /* Propagate the carry.  */\n+\t  for (i--; i >= 0; i--)\n+\t    {\n+\t      if (digits[i] != '9')\n+\t\t{\n+\t\t  digits[i]++;\n+\t\t  break;\n+\t\t}\n+\t      digits[i] = '0';\n+\t    }\n+\n+\t  if (i < 0)\n+\t    {\n+\t      /* The carry overflowed.  Fortunately we have some spare space\n+\t\t at the start of the buffer.  We may discard some digits, but\n+\t\t this is ok because we already know they are zero.  */\n+\t      digits--;\n+\t      digits[0] = '1';\n+\t      if (ft == FMT_F)\n+\t\t{\n+\t\t  if (nzero > 0)\n+\t\t    {\n+\t\t      nzero--;\n+\t\t      nafter++;\n+\t\t    }\n+\t\t  else\n+\t\t    nbefore++;\n+\t\t}\n+\t      else if (ft == FMT_EN)\n+\t\t{\n+\t\t  nbefore++;\n+\t\t  if (nbefore == 4)\n+\t\t    {\n+\t\t      nbefore = 1;\n+\t\t      e += 3;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\te++;\n+\t    }\n+\t}\n+    }\n+\n+  /* Calculate the format of the exponent field.  */\n+  if (expchar)\n+    {\n+      edigits = 1;\n+      for (i = abs (e); i >= 10; i /= 10)\n+\tedigits++;\n+\n+      if (f->u.real.e < 0)\n+\t{\n+\t  /* Width not specified.  Must be no more than 3 digits.  */\n+\t  if (e > 999 || e < -999)\n+\t    edigits = -1;\n+\t  else\n+\t    {\n+\t      edigits = 4;\n+\t      if (e > 99 || e < -99)\n+\t\texpchar = ' ';\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Exponent width specified, check it is wide enough.  */\n+\t  if (edigits > f->u.real.e)\n+\t    edigits = -1;\n+\t  else\n+\t    edigits = f->u.real.e + 2;\n+\t}\n+    }\n+  else\n+    edigits = 0;\n+\n+  /* Pick a field size if none was specified.  */\n+  if (w <= 0)\n+    w = nbefore + nzero + nafter + (sign != SIGN_NONE ? 2 : 1);\n+\n+  /* Create the ouput buffer.  */\n+  out = write_block (dtp, w);\n+  if (out == NULL)\n+    return;\n+\n+  /* Zero values always output as positive, even if the value was negative\n+     before rounding.  */\n+  for (i = 0; i < ndigits; i++)\n+    {\n+      if (digits[i] != '0')\n+\tbreak;\n+    }\n+  if (i == ndigits)\n+    {\n+      /* The output is zero, so set the sign according to the sign bit unless\n+\t -fno-sign-zero was specified.  */\n+      if (compile_options.sign_zero == 1)\n+        sign = calculate_sign (dtp, sign_bit);\n+      else\n+\tsign = calculate_sign (dtp, 0);\n+    }\n+\n+  /* Work out how much padding is needed.  */\n+  nblanks = w - (nbefore + nzero + nafter + edigits + 1);\n+  if (sign != SIGN_NONE)\n+    nblanks--;\n+\n+  /* Check the value fits in the specified field width.  */\n+  if (nblanks < 0 || edigits == -1)\n+    {\n+      star_fill (out, w);\n+      return;\n+    }\n+\n+  /* See if we have space for a zero before the decimal point.  */\n+  if (nbefore == 0 && nblanks > 0)\n+    {\n+      leadzero = 1;\n+      nblanks--;\n+    }\n+  else\n+    leadzero = 0;\n+\n+  /* Pad to full field width.  */\n+\n+  if ( ( nblanks > 0 ) && !dtp->u.p.no_leading_blank)\n+    {\n+      memset (out, ' ', nblanks);\n+      out += nblanks;\n+    }\n+\n+  /* Output the initial sign (if any).  */\n+  if (sign == SIGN_PLUS)\n+    *(out++) = '+';\n+  else if (sign == SIGN_MINUS)\n+    *(out++) = '-';\n+\n+  /* Output an optional leading zero.  */\n+  if (leadzero)\n+    *(out++) = '0';\n+\n+  /* Output the part before the decimal point, padding with zeros.  */\n+  if (nbefore > 0)\n+    {\n+      if (nbefore > ndigits)\n+\t{\n+\t  i = ndigits;\n+\t  memcpy (out, digits, i);\n+\t  ndigits = 0;\n+\t  while (i < nbefore)\n+\t    out[i++] = '0';\n+\t}\n+      else\n+\t{\n+\t  i = nbefore;\n+\t  memcpy (out, digits, i);\n+\t  ndigits -= i;\n+\t}\n+\n+      digits += i;\n+      out += nbefore;\n+    }\n+  /* Output the decimal point.  */\n+  *(out++) = '.';\n+\n+  /* Output leading zeros after the decimal point.  */\n+  if (nzero > 0)\n+    {\n+      for (i = 0; i < nzero; i++)\n+\t*(out++) = '0';\n+    }\n+\n+  /* Output digits after the decimal point, padding with zeros.  */\n+  if (nafter > 0)\n+    {\n+      if (nafter > ndigits)\n+\ti = ndigits;\n+      else\n+\ti = nafter;\n+\n+      memcpy (out, digits, i);\n+      while (i < nafter)\n+\tout[i++] = '0';\n+\n+      digits += i;\n+      ndigits -= i;\n+      out += nafter;\n+    }\n+\n+  /* Output the exponent.  */\n+  if (expchar)\n+    {\n+      if (expchar != ' ')\n+\t{\n+\t  *(out++) = expchar;\n+\t  edigits--;\n+\t}\n+#if HAVE_SNPRINTF\n+      snprintf (buffer, sizeof (buffer), \"%+0*d\", edigits, e);\n+#else\n+      sprintf (buffer, \"%+0*d\", edigits, e);\n+#endif\n+      memcpy (out, buffer, edigits);\n+    }\n+\n+  if (dtp->u.p.no_leading_blank)\n+    {\n+      out += edigits;\n+      memset( out , ' ' , nblanks );\n+      dtp->u.p.no_leading_blank = 0;\n+    }\n+#undef STR\n+#undef STR1\n+#undef MIN_FIELD_WIDTH\n+}\n+\n+\n+/* Write \"Infinite\" or \"Nan\" as appropriate for the given format.  */\n+\n+static void\n+write_infnan (st_parameter_dt *dtp, const fnode *f, int isnan_flag, int sign_bit)\n+{\n+  char * p, fin;\n+  int nb = 0;\n+\n+  if (f->format != FMT_B && f->format != FMT_O && f->format != FMT_Z)\n+    {\n+\t  nb =  f->u.real.w;\n+\t  \n+\t  /* If the field width is zero, the processor must select a width \n+\t     not zero.  4 is chosen to allow output of '-Inf' or '+Inf' */\n+\t     \n+\t  if (nb == 0) nb = 4;\n+\t  p = write_block (dtp, nb);\n+          if (p == NULL)\n+            return;\n+\t  if (nb < 3)\n+\t    {\n+\t      memset (p, '*',nb);\n+\t      return;\n+\t    }\n+\n+\t  memset(p, ' ', nb);\n+\t  if (!isnan_flag)\n+\t    {\n+\t      if (sign_bit)\n+\t        {\n+\t        \n+\t          /* If the sign is negative and the width is 3, there is\n+\t             insufficient room to output '-Inf', so output asterisks */\n+\t             \n+\t          if (nb == 3)\n+\t            {\n+\t              memset (p, '*',nb);\n+\t              return;\n+\t            }\n+\t            \n+\t          /* The negative sign is mandatory */\n+\t            \n+\t          fin = '-';\n+\t\t}    \n+\t      else\n+\t      \n+\t          /* The positive sign is optional, but we output it for\n+\t             consistency */\n+\t\t  fin = '+';\n+\n+\t      if (nb > 8)\n+\t      \n+\t        /* We have room, so output 'Infinity' */\n+\t\tmemcpy(p + nb - 8, \"Infinity\", 8);\n+\t      else\n+\t      \n+\t        /* For the case of width equals 8, there is not enough room\n+\t           for the sign and 'Infinity' so we go with 'Inf' */\n+\t\tmemcpy(p + nb - 3, \"Inf\", 3);\n+\n+\t      if (nb < 9 && nb > 3)\n+\t\tp[nb - 4] = fin;  /* Put the sign in front of Inf */\n+\t      else if (nb > 8)\n+\t\tp[nb - 9] = fin;  /* Put the sign in front of Infinity */\n+\t    }\n+\t  else\n+\t    memcpy(p + nb - 3, \"NaN\", 3);\n+\t  return;\n+\t}\n+    }\n+\n+\n+/* Returns the value of 10**d.  */\n+\n+#define CALCULATE_EXP(x) \\\n+inline static GFC_REAL_ ## x \\\n+calculate_exp_ ## x  (int d)\\\n+{\\\n+  int i;\\\n+  GFC_REAL_ ## x r = 1.0;\\\n+  for (i = 0; i< (d >= 0 ? d : -d); i++)\\\n+    r *= 10;\\\n+  r = (d >= 0) ? r : 1.0 / r;\\\n+  return r;\\\n+}\n+\n+CALCULATE_EXP(4)\n+\n+CALCULATE_EXP(8)\n+\n+#ifdef HAVE_GFC_REAL_10\n+CALCULATE_EXP(10)\n+#endif\n+\n+#ifdef HAVE_GFC_REAL_16\n+CALCULATE_EXP(16)\n+#endif\n+#undef CALCULATE_EXP\n+\n+/* Generate corresponding I/O format for FMT_G and output.\n+   The rules to translate FMT_G to FMT_E or FMT_F from DEC fortran\n+   LRM (table 11-2, Chapter 11, \"I/O Formatting\", P11-25) is:\n+\n+   Data Magnitude                              Equivalent Conversion\n+   0< m < 0.1-0.5*10**(-d-1)                   Ew.d[Ee]\n+   m = 0                                       F(w-n).(d-1), n' '\n+   0.1-0.5*10**(-d-1)<= m < 1-0.5*10**(-d)     F(w-n).d, n' '\n+   1-0.5*10**(-d)<= m < 10-0.5*10**(-d+1)      F(w-n).(d-1), n' '\n+   10-0.5*10**(-d+1)<= m < 100-0.5*10**(-d+2)  F(w-n).(d-2), n' '\n+   ................                           ..........\n+   10**(d-1)-0.5*10**(-1)<= m <10**d-0.5       F(w-n).0,n(' ')\n+   m >= 10**d-0.5                              Ew.d[Ee]\n+\n+   notes: for Gw.d ,  n' ' means 4 blanks\n+          for Gw.dEe, n' ' means e+2 blanks  */\n+\n+#define OUTPUT_FLOAT_FMT_G(x) \\\n+static void \\\n+output_float_FMT_G_ ## x (st_parameter_dt *dtp, const fnode *f, \\\n+\t\t      GFC_REAL_ ## x m, char *buffer, int sign_bit, \\\n+\t\t      bool zero_flag, int ndigits, int edigits) \\\n+{ \\\n+  int e = f->u.real.e;\\\n+  int d = f->u.real.d;\\\n+  int w = f->u.real.w;\\\n+  fnode *newf;\\\n+  GFC_REAL_ ## x exp_d;\\\n+  int low, high, mid;\\\n+  int ubound, lbound;\\\n+  char *p;\\\n+  int save_scale_factor, nb = 0;\\\n+\\\n+  save_scale_factor = dtp->u.p.scale_factor;\\\n+  newf = get_mem (sizeof (fnode));\\\n+\\\n+  exp_d = calculate_exp_ ## x (d);\\\n+  if ((m > 0.0 && m < 0.1 - 0.05 / exp_d) || (m >= exp_d - 0.5 ) ||\\\n+      ((m == 0.0) && !(compile_options.allow_std & GFC_STD_F2003)))\\\n+    { \\\n+      newf->format = FMT_E;\\\n+      newf->u.real.w = w;\\\n+      newf->u.real.d = d;\\\n+      newf->u.real.e = e;\\\n+      nb = 0;\\\n+      goto finish;\\\n+    }\\\n+\\\n+  mid = 0;\\\n+  low = 0;\\\n+  high = d + 1;\\\n+  lbound = 0;\\\n+  ubound = d + 1;\\\n+\\\n+  while (low <= high)\\\n+    { \\\n+      GFC_REAL_ ## x temp;\\\n+      mid = (low + high) / 2;\\\n+\\\n+      temp = 0.1 * calculate_exp_ ## x (mid) - 0.5\\\n+\t     * calculate_exp_ ## x (mid - d - 1);\\\n+\\\n+      if (m < temp)\\\n+        { \\\n+          ubound = mid;\\\n+          if (ubound == lbound + 1)\\\n+            break;\\\n+          high = mid - 1;\\\n+        }\\\n+      else if (m > temp)\\\n+        { \\\n+          lbound = mid;\\\n+          if (ubound == lbound + 1)\\\n+            { \\\n+              mid ++;\\\n+              break;\\\n+            }\\\n+          low = mid + 1;\\\n+        }\\\n+      else\\\n+        break;\\\n+    }\\\n+\\\n+  if (e < 0)\\\n+    nb = 4;\\\n+  else\\\n+    nb = e + 2;\\\n+\\\n+  newf->format = FMT_F;\\\n+  newf->u.real.w = f->u.real.w - nb;\\\n+\\\n+  if (m == 0.0)\\\n+    newf->u.real.d = d - 1;\\\n+  else\\\n+    newf->u.real.d = - (mid - d - 1);\\\n+\\\n+  dtp->u.p.scale_factor = 0;\\\n+\\\n+ finish:\\\n+  output_float (dtp, newf, buffer, sign_bit, zero_flag, ndigits, edigits);\\\n+  dtp->u.p.scale_factor = save_scale_factor;\\\n+\\\n+  free_mem(newf);\\\n+\\\n+  if (nb > 0)\\\n+    { \\\n+      p = write_block (dtp, nb);\\\n+      if (p == NULL)\\\n+\treturn;\\\n+      memset (p, ' ', nb);\\\n+    }\\\n+}\\\n+\n+OUTPUT_FLOAT_FMT_G(4)\n+\n+OUTPUT_FLOAT_FMT_G(8)\n+\n+#ifdef HAVE_GFC_REAL_10\n+OUTPUT_FLOAT_FMT_G(10)\n+#endif\n+\n+#ifdef HAVE_GFC_REAL_16\n+OUTPUT_FLOAT_FMT_G(16)\n+#endif\n+\n+#undef OUTPUT_FLOAT_FMT_G\n+\n+/* Define a macro to build code for write_float.  */\n+\n+#ifdef HAVE_SNPRINTF\n+\n+#define DTOA \\\n+snprintf (buffer, sizeof (buffer), \"%+-#\" STR(MIN_FIELD_WIDTH) \".*\" \\\n+\t  \"e\", ndigits - 1, tmp);\n+\n+#define DTOAL \\\n+snprintf (buffer, sizeof (buffer), \"%+-#\" STR(MIN_FIELD_WIDTH) \".*\" \\\n+\t  \"Le\", ndigits - 1, tmp);\n+\n+#else\n+\n+#define DTOA \\\n+sprintf (buffer, \"%+-#\" STR(MIN_FIELD_WIDTH) \".*\" \\\n+\t \"e\", ndigits - 1, tmp);\n+\n+#define DTOAL \\\n+sprintf (buffer, \"%+-#\" STR(MIN_FIELD_WIDTH) \".*\" \\\n+\t \"Le\", ndigits - 1, tmp);\n+\n+#endif\n+\n+#define WRITE_FLOAT(x,y)\\\n+{\\\n+\tGFC_REAL_ ## x tmp;\\\n+\ttmp = * (GFC_REAL_ ## x *)source;\\\n+\tsign_bit = signbit (tmp);\\\n+\tif (!isfinite (tmp))\\\n+\t  { \\\n+\t    write_infnan (dtp, f, isnan (tmp), sign_bit);\\\n+\t    return;\\\n+\t  }\\\n+\ttmp = sign_bit ? -tmp : tmp;\\\n+\tif (f->u.real.d == 0 && f->format == FMT_F)\\\n+\t  {\\\n+\t    if (tmp < 0.5)\\\n+\t      tmp = 0.0;\\\n+\t    else if (tmp < 1.0)\\\n+\t      tmp = tmp + 0.5;\\\n+\t  }\\\n+\tzero_flag = (tmp == 0.0);\\\n+\\\n+\tDTOA ## y\\\n+\\\n+\tif (f->format != FMT_G)\\\n+\t  output_float (dtp, f, buffer, sign_bit, zero_flag, ndigits, edigits);\\\n+\telse \\\n+\t  output_float_FMT_G_ ## x (dtp, f, tmp, buffer, sign_bit, zero_flag, \\\n+\t\t\t\tndigits, edigits);\\\n+}\\\n+\n+/* Output a real number according to its format.  */\n+\n+static void\n+write_float (st_parameter_dt *dtp, const fnode *f, const char *source, int len)\n+{\n+\n+#if defined(HAVE_GFC_REAL_16) && __LDBL_DIG__ > 18\n+# define MIN_FIELD_WIDTH 46\n+#else\n+# define MIN_FIELD_WIDTH 31\n+#endif\n+#define STR(x) STR1(x)\n+#define STR1(x) #x\n+\n+  /* This must be large enough to accurately hold any value.  */\n+  char buffer[MIN_FIELD_WIDTH+1];\n+  int sign_bit, ndigits, edigits;\n+  bool zero_flag;\n+\n+  /* printf pads blanks for us on the exponent so we just need it big enough\n+     to handle the largest number of exponent digits expected.  */\n+  edigits=4;\n+\n+  if (f->format == FMT_F || f->format == FMT_EN || f->format == FMT_G \n+      || ((f->format == FMT_D || f->format == FMT_E)\n+      && dtp->u.p.scale_factor != 0))\n+    {\n+      /* Always convert at full precision to avoid double rounding.  */\n+      ndigits = MIN_FIELD_WIDTH - 4 - edigits;\n+    }\n+  else\n+    {\n+      /* The number of digits is known, so let printf do the rounding.  */\n+      if (f->format == FMT_ES)\n+\tndigits = f->u.real.d + 1;\n+      else\n+\tndigits = f->u.real.d;\n+      if (ndigits > MIN_FIELD_WIDTH - 4 - edigits)\n+\tndigits = MIN_FIELD_WIDTH - 4 - edigits;\n+    }\n+\n+  switch (len)\n+    {\n+    case 4:\n+      WRITE_FLOAT(4,)\n+      break;\n+\n+    case 8:\n+      WRITE_FLOAT(8,)\n+      break;\n+\n+#ifdef HAVE_GFC_REAL_10\n+    case 10:\n+      WRITE_FLOAT(10,L)\n+      break;\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+    case 16:\n+      WRITE_FLOAT(16,L)\n+      break;\n+#endif\n+    default:\n+      internal_error (NULL, \"bad real kind\");\n+    }\n+}"}]}