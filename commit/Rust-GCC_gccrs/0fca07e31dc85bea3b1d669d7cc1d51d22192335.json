{"sha": "0fca07e31dc85bea3b1d669d7cc1d51d22192335", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZjYTA3ZTMxZGM4NWJlYTNiMWQ2NjlkN2NjMWQ1MWQyMjE5MjMzNQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2018-12-14T19:37:38Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2018-12-14T19:37:38Z"}, "message": "re PR c++/82294 (Array of objects with constexpr constructors initialized from space-inefficient memory image)\n\n\tPR c++/82294\n\tPR c++/87436\n\t* expr.h (categorize_ctor_elements): Add p_unique_nz_elts argument.\n\t* expr.c (categorize_ctor_elements_1): Likewise.  Compute it like\n\tp_nz_elts, except don't multiply it by mult.  Adjust recursive call.\n\tFix up COMPLEX_CST handling.\n\t(categorize_ctor_elements): Add p_unique_nz_elts argument, initialize\n\tit and pass it through to categorize_ctor_elements_1.\n\t(mostly_zeros_p, all_zeros_p): Adjust categorize_ctor_elements callers.\n\t* gimplify.c (gimplify_init_constructor): Likewise.  Don't force\n\tctor into readonly data section if num_unique_nonzero_elements is\n\tsmaller or equal to 1/8 of num_nonzero_elements and size is >= 64\n\tbytes.\n\n\t* g++.dg/tree-ssa/pr82294.C: New test.\n\t* g++.dg/tree-ssa/pr87436.C: New test.\n\nFrom-SVN: r267143", "tree": {"sha": "662864e452bc122b8f1cff2569205e4a587d86c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/662864e452bc122b8f1cff2569205e4a587d86c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fca07e31dc85bea3b1d669d7cc1d51d22192335", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fca07e31dc85bea3b1d669d7cc1d51d22192335", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fca07e31dc85bea3b1d669d7cc1d51d22192335", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fca07e31dc85bea3b1d669d7cc1d51d22192335/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "faa9232da39587b27b46341667d6d415d2af9280", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faa9232da39587b27b46341667d6d415d2af9280", "html_url": "https://github.com/Rust-GCC/gccrs/commit/faa9232da39587b27b46341667d6d415d2af9280"}], "stats": {"total": 148, "additions": 131, "deletions": 17}, "files": [{"sha": "527164c4f9ec4c86cb646df410fd13c42deb94ca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fca07e31dc85bea3b1d669d7cc1d51d22192335/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fca07e31dc85bea3b1d669d7cc1d51d22192335/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0fca07e31dc85bea3b1d669d7cc1d51d22192335", "patch": "@@ -1,3 +1,19 @@\n+2018-12-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/82294\n+\tPR c++/87436\n+\t* expr.h (categorize_ctor_elements): Add p_unique_nz_elts argument.\n+\t* expr.c (categorize_ctor_elements_1): Likewise.  Compute it like\n+\tp_nz_elts, except don't multiply it by mult.  Adjust recursive call.\n+\tFix up COMPLEX_CST handling.\n+\t(categorize_ctor_elements): Add p_unique_nz_elts argument, initialize\n+\tit and pass it through to categorize_ctor_elements_1.\n+\t(mostly_zeros_p, all_zeros_p): Adjust categorize_ctor_elements callers.\n+\t* gimplify.c (gimplify_init_constructor): Likewise.  Don't force\n+\tctor into readonly data section if num_unique_nonzero_elements is\n+\tsmaller or equal to 1/8 of num_nonzero_elements and size is >= 64\n+\tbytes.\n+\n 2018-12-14  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n \n \t* config/arm/arm.md (arm_movdi): Split if -mslow-flash-data and"}, {"sha": "b4a2133ebce3f7481b3d62d8b58da42c43cda871", "filename": "gcc/expr.c", "status": "modified", "additions": 43, "deletions": 15, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fca07e31dc85bea3b1d669d7cc1d51d22192335/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fca07e31dc85bea3b1d669d7cc1d51d22192335/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=0fca07e31dc85bea3b1d669d7cc1d51d22192335", "patch": "@@ -5945,10 +5945,11 @@ count_type_elements (const_tree type, bool for_ctor_p)\n \n static bool\n categorize_ctor_elements_1 (const_tree ctor, HOST_WIDE_INT *p_nz_elts,\n+\t\t\t    HOST_WIDE_INT *p_unique_nz_elts,\n \t\t\t    HOST_WIDE_INT *p_init_elts, bool *p_complete)\n {\n   unsigned HOST_WIDE_INT idx;\n-  HOST_WIDE_INT nz_elts, init_elts, num_fields;\n+  HOST_WIDE_INT nz_elts, unique_nz_elts, init_elts, num_fields;\n   tree value, purpose, elt_type;\n \n   /* Whether CTOR is a valid constant initializer, in accordance with what\n@@ -5958,6 +5959,7 @@ categorize_ctor_elements_1 (const_tree ctor, HOST_WIDE_INT *p_nz_elts,\n   bool const_p = const_from_elts_p ? true : TREE_STATIC (ctor);\n \n   nz_elts = 0;\n+  unique_nz_elts = 0;\n   init_elts = 0;\n   num_fields = 0;\n   elt_type = NULL_TREE;\n@@ -5982,12 +5984,13 @@ categorize_ctor_elements_1 (const_tree ctor, HOST_WIDE_INT *p_nz_elts,\n \t{\n \tcase CONSTRUCTOR:\n \t  {\n-\t    HOST_WIDE_INT nz = 0, ic = 0;\n+\t    HOST_WIDE_INT nz = 0, unz = 0, ic = 0;\n \n-\t    bool const_elt_p = categorize_ctor_elements_1 (value, &nz, &ic,\n-\t\t\t\t\t\t\t   p_complete);\n+\t    bool const_elt_p = categorize_ctor_elements_1 (value, &nz, &unz,\n+\t\t\t\t\t\t\t   &ic, p_complete);\n \n \t    nz_elts += mult * nz;\n+\t    unique_nz_elts += unz;\n  \t    init_elts += mult * ic;\n \n \t    if (const_from_elts_p && const_p)\n@@ -5999,21 +6002,31 @@ categorize_ctor_elements_1 (const_tree ctor, HOST_WIDE_INT *p_nz_elts,\n \tcase REAL_CST:\n \tcase FIXED_CST:\n \t  if (!initializer_zerop (value))\n-\t    nz_elts += mult;\n+\t    {\n+\t      nz_elts += mult;\n+\t      unique_nz_elts++;\n+\t    }\n \t  init_elts += mult;\n \t  break;\n \n \tcase STRING_CST:\n \t  nz_elts += mult * TREE_STRING_LENGTH (value);\n+\t  unique_nz_elts += TREE_STRING_LENGTH (value);\n \t  init_elts += mult * TREE_STRING_LENGTH (value);\n \t  break;\n \n \tcase COMPLEX_CST:\n \t  if (!initializer_zerop (TREE_REALPART (value)))\n-\t    nz_elts += mult;\n+\t    {\n+\t      nz_elts += mult;\n+\t      unique_nz_elts++;\n+\t    }\n \t  if (!initializer_zerop (TREE_IMAGPART (value)))\n-\t    nz_elts += mult;\n-\t  init_elts += mult;\n+\t    {\n+\t      nz_elts += mult;\n+\t      unique_nz_elts++;\n+\t    }\n+\t  init_elts += 2 * mult;\n \t  break;\n \n \tcase VECTOR_CST:\n@@ -6025,7 +6038,10 @@ categorize_ctor_elements_1 (const_tree ctor, HOST_WIDE_INT *p_nz_elts,\n \t      {\n \t\ttree v = VECTOR_CST_ELT (value, i);\n \t\tif (!initializer_zerop (v))\n-\t\t  nz_elts += mult;\n+\t\t  {\n+\t\t    nz_elts += mult;\n+\t\t    unique_nz_elts++;\n+\t\t  }\n \t\tinit_elts += mult;\n \t      }\n \t  }\n@@ -6035,6 +6051,7 @@ categorize_ctor_elements_1 (const_tree ctor, HOST_WIDE_INT *p_nz_elts,\n \t  {\n \t    HOST_WIDE_INT tc = count_type_elements (elt_type, false);\n \t    nz_elts += mult * tc;\n+\t    unique_nz_elts += tc;\n \t    init_elts += mult * tc;\n \n \t    if (const_from_elts_p && const_p)\n@@ -6054,6 +6071,7 @@ categorize_ctor_elements_1 (const_tree ctor, HOST_WIDE_INT *p_nz_elts,\n     *p_complete = false;\n \n   *p_nz_elts += nz_elts;\n+  *p_unique_nz_elts += unique_nz_elts;\n   *p_init_elts += init_elts;\n \n   return const_p;\n@@ -6062,6 +6080,11 @@ categorize_ctor_elements_1 (const_tree ctor, HOST_WIDE_INT *p_nz_elts,\n /* Examine CTOR to discover:\n    * how many scalar fields are set to nonzero values,\n      and place it in *P_NZ_ELTS;\n+   * the same, but counting RANGE_EXPRs as multiplier of 1 instead of\n+     high - low + 1 (this can be useful for callers to determine ctors\n+     that could be cheaply initialized with - perhaps nested - loops\n+     compared to copied from huge read-only data),\n+     and place it in *P_UNIQUE_NZ_ELTS;\n    * how many scalar fields in total are in CTOR,\n      and place it in *P_ELT_COUNT.\n    * whether the constructor is complete -- in the sense that every\n@@ -6073,13 +6096,16 @@ categorize_ctor_elements_1 (const_tree ctor, HOST_WIDE_INT *p_nz_elts,\n \n bool\n categorize_ctor_elements (const_tree ctor, HOST_WIDE_INT *p_nz_elts,\n+\t\t\t  HOST_WIDE_INT *p_unique_nz_elts,\n \t\t\t  HOST_WIDE_INT *p_init_elts, bool *p_complete)\n {\n   *p_nz_elts = 0;\n+  *p_unique_nz_elts = 0;\n   *p_init_elts = 0;\n   *p_complete = true;\n \n-  return categorize_ctor_elements_1 (ctor, p_nz_elts, p_init_elts, p_complete);\n+  return categorize_ctor_elements_1 (ctor, p_nz_elts, p_unique_nz_elts,\n+\t\t\t\t     p_init_elts, p_complete);\n }\n \n /* TYPE is initialized by a constructor with NUM_ELTS elements, the last\n@@ -6110,17 +6136,18 @@ complete_ctor_at_level_p (const_tree type, HOST_WIDE_INT num_elts,\n   return count_type_elements (type, true) == num_elts;\n }\n \n-/* Return 1 if EXP contains mostly (3/4)  zeros.  */\n+/* Return 1 if EXP contains mostly (3/4) zeros.  */\n \n static int\n mostly_zeros_p (const_tree exp)\n {\n   if (TREE_CODE (exp) == CONSTRUCTOR)\n     {\n-      HOST_WIDE_INT nz_elts, init_elts;\n+      HOST_WIDE_INT nz_elts, unz_elts, init_elts;\n       bool complete_p;\n \n-      categorize_ctor_elements (exp, &nz_elts, &init_elts, &complete_p);\n+      categorize_ctor_elements (exp, &nz_elts, &unz_elts, &init_elts,\n+\t\t\t\t&complete_p);\n       return !complete_p || nz_elts < init_elts / 4;\n     }\n \n@@ -6134,10 +6161,11 @@ all_zeros_p (const_tree exp)\n {\n   if (TREE_CODE (exp) == CONSTRUCTOR)\n     {\n-      HOST_WIDE_INT nz_elts, init_elts;\n+      HOST_WIDE_INT nz_elts, unz_elts, init_elts;\n       bool complete_p;\n \n-      categorize_ctor_elements (exp, &nz_elts, &init_elts, &complete_p);\n+      categorize_ctor_elements (exp, &nz_elts, &unz_elts, &init_elts,\n+\t\t\t\t&complete_p);\n       return nz_elts == 0;\n     }\n "}, {"sha": "4469652e443aa6b67b862f3cc83ffc1989400218", "filename": "gcc/expr.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fca07e31dc85bea3b1d669d7cc1d51d22192335/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fca07e31dc85bea3b1d669d7cc1d51d22192335/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=0fca07e31dc85bea3b1d669d7cc1d51d22192335", "patch": "@@ -309,7 +309,8 @@ extern bool can_move_by_pieces (unsigned HOST_WIDE_INT, unsigned int);\n extern unsigned HOST_WIDE_INT highest_pow2_factor (const_tree);\n \n extern bool categorize_ctor_elements (const_tree, HOST_WIDE_INT *,\n-\t\t\t\t      HOST_WIDE_INT *, bool *);\n+\t\t\t\t      HOST_WIDE_INT *, HOST_WIDE_INT *,\n+\t\t\t\t      bool *);\n \n extern void expand_operands (tree, tree, rtx, rtx*, rtx*,\n \t\t\t     enum expand_modifier);"}, {"sha": "465d138abbed15e3a8ee550c96073014293e0ee1", "filename": "gcc/gimplify.c", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fca07e31dc85bea3b1d669d7cc1d51d22192335/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fca07e31dc85bea3b1d669d7cc1d51d22192335/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=0fca07e31dc85bea3b1d669d7cc1d51d22192335", "patch": "@@ -4778,7 +4778,15 @@ gimplify_init_constructor (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n       {\n \tstruct gimplify_init_ctor_preeval_data preeval_data;\n \tHOST_WIDE_INT num_ctor_elements, num_nonzero_elements;\n+\tHOST_WIDE_INT num_unique_nonzero_elements;\n \tbool cleared, complete_p, valid_const_initializer;\n+\t/* Use readonly data for initializers of this or smaller size\n+\t   regardless of the num_nonzero_elements / num_unique_nonzero_elements\n+\t   ratio.  */\n+\tconst HOST_WIDE_INT min_unique_size = 64;\n+\t/* If num_nonzero_elements / num_unique_nonzero_elements ratio\n+\t   is smaller than this, use readonly data.  */\n+\tconst int unique_nonzero_ratio = 8;\n \n \t/* Aggregate types must lower constructors to initialization of\n \t   individual elements.  The exception is that a CONSTRUCTOR node\n@@ -4795,6 +4803,7 @@ gimplify_init_constructor (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t   can only do so if it known to be a valid constant initializer.  */\n \tvalid_const_initializer\n \t  = categorize_ctor_elements (ctor, &num_nonzero_elements,\n+\t\t\t\t      &num_unique_nonzero_elements,\n \t\t\t\t      &num_ctor_elements, &complete_p);\n \n \t/* If a const aggregate variable is being initialized, then it\n@@ -4803,7 +4812,15 @@ gimplify_init_constructor (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t    && num_nonzero_elements > 1\n \t    && TREE_READONLY (object)\n \t    && VAR_P (object)\n-\t    && (flag_merge_constants >= 2 || !TREE_ADDRESSABLE (object)))\n+\t    && (flag_merge_constants >= 2 || !TREE_ADDRESSABLE (object))\n+\t    /* For ctors that have many repeated nonzero elements\n+\t       represented through RANGE_EXPRs, prefer initializing\n+\t       those through runtime loops over copies of large amounts\n+\t       of data from readonly data section.  */\n+\t    && (num_unique_nonzero_elements\n+\t\t> num_nonzero_elements / unique_nonzero_ratio\n+\t\t|| ((unsigned HOST_WIDE_INT) int_size_in_bytes (type)\n+\t\t    <= (unsigned HOST_WIDE_INT) min_unique_size)))\n \t  {\n \t    if (notify_temp_creation)\n \t      return GS_ERROR;\n@@ -4896,6 +4913,13 @@ gimplify_init_constructor (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t       is so large as to make individual moves inefficient.  */\n \t    if (size > 0\n \t\t&& num_nonzero_elements > 1\n+\t\t/* For ctors that have many repeated nonzero elements\n+\t\t   represented through RANGE_EXPRs, prefer initializing\n+\t\t   those through runtime loops over copies of large amounts\n+\t\t   of data from readonly data section.  */\n+\t\t&& (num_unique_nonzero_elements\n+\t\t    > num_nonzero_elements / unique_nonzero_ratio\n+\t\t    || size <= min_unique_size)\n \t\t&& (size < num_nonzero_elements\n \t\t    || !can_move_by_pieces (size, align)))\n \t      {"}, {"sha": "1374be13f0eb0452acf4ab0ca1aa498c8c834395", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fca07e31dc85bea3b1d669d7cc1d51d22192335/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fca07e31dc85bea3b1d669d7cc1d51d22192335/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0fca07e31dc85bea3b1d669d7cc1d51d22192335", "patch": "@@ -1,3 +1,10 @@\n+2018-12-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/82294\n+\tPR c++/87436\n+\t* g++.dg/tree-ssa/pr82294.C: New test.\n+\t* g++.dg/tree-ssa/pr87436.C: New test.\n+\n 2018-11-14  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n \n \t* gcc.target/arm/thumb2-slow-flash-data-2.c: Require arm_fp_ok"}, {"sha": "25aaba7d01674236bf45ff0ac8a9d794459f89a2", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr82294.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fca07e31dc85bea3b1d669d7cc1d51d22192335/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr82294.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fca07e31dc85bea3b1d669d7cc1d51d22192335/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr82294.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr82294.C?ref=0fca07e31dc85bea3b1d669d7cc1d51d22192335", "patch": "@@ -0,0 +1,13 @@\n+// PR c++/82294\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-O2 -fdump-tree-gimple\" }\n+\n+// Verify we don't \"optimize\" the ctor as copying a 1KB .rodata\n+// object into the variable.  It is better to initialize it through\n+// a loop.\n+// { dg-final { scan-tree-dump-not \"this->arr = \" \"gimple\" } }\n+\n+struct S { int x; explicit constexpr S (); };\n+constexpr S::S () : x{7} {}\n+struct T { S arr[256]; explicit T (); };\n+T::T () {}"}, {"sha": "6e35bf8afff8c9eef1d532e8976130795aabe2a4", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr87436.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fca07e31dc85bea3b1d669d7cc1d51d22192335/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr87436.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fca07e31dc85bea3b1d669d7cc1d51d22192335/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr87436.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr87436.C?ref=0fca07e31dc85bea3b1d669d7cc1d51d22192335", "patch": "@@ -0,0 +1,25 @@\n+// PR c++/87436\n+// { dg-do compile { target { c++11 && size32plus } } }\n+// { dg-options \"-O2 -fdump-tree-gimple\" }\n+\n+// Verify we don't \"optimize\" the ctor as copying a 384MB .rodata\n+// object into the variable.  It is better to initialize it through\n+// two nested loops.\n+// { dg-final { scan-tree-dump-not \"this->arr = \" \"gimple\" } }\n+\n+struct S {\n+  int a = -1;\n+  short b = 3;\n+  int x = 0;\n+  int y = 1;\n+  int z = 42;\n+  float f = 0.123f;\n+};\n+\n+struct T { S arr[4096][4096]; };\n+\n+T *\n+foo ()\n+{\n+  return new T;\n+}"}]}