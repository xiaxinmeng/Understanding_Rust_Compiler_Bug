{"sha": "3bd06df78aded83cc747f067fb57b5c666046efa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2JkMDZkZjc4YWRlZDgzY2M3NDdmMDY3ZmI1N2I1YzY2NjA0NmVmYQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-04-17T07:02:32Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-04-17T07:02:32Z"}, "message": "mips.h (PREDICATE_CODES): Add macc_msac_operand.\n\n\t* config/mips/mips.h (PREDICATE_CODES): Add macc_msac_operand.\n\t* config/mips/mips.c (macc_msac_operand): New function.\n\t* config/mips/mips.md (*msac): Move after *macc.\n\t(*msac2): New.  Generalize macc-related peepholes so that they apply\n\tto msac too.\n\nFrom-SVN: r80790", "tree": {"sha": "ddbb0765cad6fa08e7d2e3e69d8d639d767011fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ddbb0765cad6fa08e7d2e3e69d8d639d767011fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3bd06df78aded83cc747f067fb57b5c666046efa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bd06df78aded83cc747f067fb57b5c666046efa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bd06df78aded83cc747f067fb57b5c666046efa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bd06df78aded83cc747f067fb57b5c666046efa/comments", "author": null, "committer": null, "parents": [{"sha": "38d396e511338696ce8953e36b0fa838e9f3ce7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38d396e511338696ce8953e36b0fa838e9f3ce7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38d396e511338696ce8953e36b0fa838e9f3ce7a"}], "stats": {"total": 204, "additions": 132, "deletions": 72}, "files": [{"sha": "e8f9213e7c05bf4792212ddba21466d719fac8a8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd06df78aded83cc747f067fb57b5c666046efa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd06df78aded83cc747f067fb57b5c666046efa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3bd06df78aded83cc747f067fb57b5c666046efa", "patch": "@@ -1,3 +1,11 @@\n+2004-04-17  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips.h (PREDICATE_CODES): Add macc_msac_operand.\n+\t* config/mips/mips.c (macc_msac_operand): New function.\n+\t* config/mips/mips.md (*msac): Move after *macc.\n+\t(*msac2): New.  Generalize macc-related peepholes so that they apply\n+\tto msac too.\n+\n 2004-04-17  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* opts.c (decode_options): Do not enable flag_rename_registers"}, {"sha": "16a1ab2529867821fa31ad89664fb30a298dba9e", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd06df78aded83cc747f067fb57b5c666046efa/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd06df78aded83cc747f067fb57b5c666046efa/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=3bd06df78aded83cc747f067fb57b5c666046efa", "patch": "@@ -1449,6 +1449,22 @@ extend_operator (rtx op, enum machine_mode mode)\n \t  && (GET_CODE (op) == ZERO_EXTEND || GET_CODE (op) == SIGN_EXTEND));\n }\n \n+/* Return true if X is the right hand side of a \"macc\" or \"msac\" instruction.\n+   This predicate is intended for use in peephole optimizations.  */\n+\n+int\n+macc_msac_operand (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  if (ISA_HAS_MACC && GET_CODE (x) == PLUS && REG_P (XEXP (x, 1)))\n+    x = XEXP (x, 0);\n+  else if (ISA_HAS_MSAC && GET_CODE (x) == MINUS && REG_P (XEXP (x, 0)))\n+    x = XEXP (x, 1);\n+  else\n+    return false;\n+\n+  return GET_CODE (x) == MULT && REG_P (XEXP (x, 0)) && REG_P (XEXP (x, 1));\n+}\n+\n /* Return nonzero if the code of this rtx pattern is EQ or NE.  */\n \n int"}, {"sha": "8bd9fb710de6130d58b78d14f6463d29d86e537e", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd06df78aded83cc747f067fb57b5c666046efa/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd06df78aded83cc747f067fb57b5c666046efa/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=3bd06df78aded83cc747f067fb57b5c666046efa", "patch": "@@ -2742,6 +2742,7 @@ typedef struct mips_args {\n \t\t\t\t  CONST_DOUBLE, CONST }},\t\t\\\n   {\"fcc_register_operand\",\t{ REG, SUBREG }},\t\t\t\\\n   {\"hilo_operand\",\t\t{ REG }},\t\t\t\t\\\n+  {\"macc_msac_operand\",\t\t{ PLUS, MINUS }},\t\t\t\\\n   {\"extend_operator\",\t\t{ ZERO_EXTEND, SIGN_EXTEND }},\n \n /* A list of predicates that do special things with modes, and so"}, {"sha": "0ac944419ec4a0258811d6022f86496ff0c3a736", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 83, "deletions": 72, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd06df78aded83cc747f067fb57b5c666046efa/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd06df78aded83cc747f067fb57b5c666046efa/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=3bd06df78aded83cc747f067fb57b5c666046efa", "patch": "@@ -1678,7 +1678,27 @@\n   [(set_attr \"type\" \"imadd\")\n    (set_attr \"mode\" \"SI\")])\n \n-;; Pattern generated by define_peephole2 below\n+(define_insn \"*msac\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l,d\")\n+        (minus:SI (match_operand:SI 1 \"register_operand\" \"0,l\")\n+                  (mult:SI (match_operand:SI 2 \"register_operand\" \"d,d\")\n+                           (match_operand:SI 3 \"register_operand\" \"d,d\"))))\n+   (clobber (match_scratch:SI 4 \"=h,h\"))\n+   (clobber (match_scratch:SI 5 \"=X,1\"))]\n+  \"ISA_HAS_MSAC\"\n+{\n+  if (which_alternative == 1)\n+    return \"msac\\t%0,%2,%3\";\n+  else if (TARGET_MIPS5500)\n+    return \"msub\\t%2,%3\";\n+  else\n+    return \"msac\\t$0,%2,%3\";\n+}\n+  [(set_attr \"type\"     \"imadd\")\n+   (set_attr \"mode\"     \"SI\")])\n+\n+;; Patterns generated by the define_peephole2 below.\n+\n (define_insn \"*macc2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n \t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"d\")\n@@ -1694,35 +1714,43 @@\n   [(set_attr \"type\"\t\"imadd\")\n    (set_attr \"mode\"\t\"SI\")])\n \n+(define_insn \"*msac2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n+\t(minus:SI (match_dup 0)\n+\t\t  (mult:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t\t   (match_operand:SI 2 \"register_operand\" \"d\"))))\n+   (set (match_operand:SI 3 \"register_operand\" \"=d\")\n+\t(minus:SI (match_dup 0)\n+\t\t  (mult:SI (match_dup 1)\n+\t\t\t   (match_dup 2))))\n+   (clobber (match_scratch:SI 4 \"=h\"))]\n+  \"ISA_HAS_MSAC && reload_completed\"\n+  \"msac\\t%3,%1,%2\"\n+  [(set_attr \"type\"\t\"imadd\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n ;; Convert macc $0,<r1>,<r2> & mflo <r3> into macc <r3>,<r1>,<r2>\n+;; Similarly msac.\n ;;\n ;; Operand 0: LO\n-;; Operand 1: GPR (1st multiplication operand)\n-;; Operand 2: GPR (2nd multiplication operand)\n-;; Operand 3: HI\n-;; Operand 4: GPR (destination)\n+;; Operand 1: macc/msac\n+;; Operand 2: HI\n+;; Operand 3: GPR (destination)\n (define_peephole2\n   [(parallel\n        [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t     (plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t\t       (match_operand:SI 2 \"register_operand\" \"\"))\n-\t\t      (match_dup 0)))\n-\t(clobber (match_operand:SI 3 \"register_operand\" \"\"))\n+\t     (match_operand:SI 1 \"macc_msac_operand\" \"\"))\n+\t(clobber (match_operand:SI 2 \"register_operand\" \"\"))\n \t(clobber (scratch:SI))])\n-   (set (match_operand:SI 4 \"register_operand\" \"\")\n+   (set (match_operand:SI 3 \"register_operand\" \"\")\n \t(match_dup 0))]\n-  \"ISA_HAS_MACC\n-   && true_regnum (operands[0]) == LO_REGNUM\n-   && GP_REG_P (true_regnum (operands[4]))\"\n+  \"true_regnum (operands[0]) == LO_REGNUM\n+   && GP_REG_P (true_regnum (operands[3]))\"\n   [(parallel [(set (match_dup 0)\n-\t\t   (plus:SI (mult:SI (match_dup 1)\n-\t\t\t\t     (match_dup 2))\n-\t\t\t    (match_dup 0)))\n-\t      (set (match_dup 4)\n-\t\t   (plus:SI (mult:SI (match_dup 1)\n-\t\t\t\t     (match_dup 2))\n-\t\t\t    (match_dup 0)))\n-\t      (clobber (match_dup 3))])]\n+\t\t   (match_dup 1))\n+\t      (set (match_dup 3)\n+\t\t   (match_dup 1))\n+\t      (clobber (match_dup 2))])]\n   \"\")\n \n ;; When we have a three-address multiplication instruction, it should\n@@ -1736,72 +1764,74 @@\n ;; Operand 1: LO\n ;; Operand 2: GPR (addend)\n ;; Operand 3: GPR (destination)\n-;; Operand 4: GPR (1st multiplication operand)\n-;; Operand 5: GPR (2nd multiplication operand)\n-;; Operand 6: HI\n+;; Operand 4: macc/msac\n+;; Operand 5: HI\n+;; Operand 6: new multiplication\n+;; Operand 7: new addition/subtraction\n (define_peephole2\n   [(match_scratch:SI 0 \"d\")\n    (set (match_operand:SI 1 \"register_operand\" \"\")\n \t(match_operand:SI 2 \"register_operand\" \"\"))\n    (match_dup 0)\n    (parallel\n        [(set (match_operand:SI 3 \"register_operand\" \"\")\n-\t     (plus:SI (mult:SI (match_operand:SI 4 \"register_operand\" \"\")\n-\t\t\t       (match_operand:SI 5 \"register_operand\" \"\"))\n-\t\t      (match_dup 1)))\n-\t(clobber (match_operand:SI 6 \"register_operand\" \"\"))\n+\t     (match_operand:SI 4 \"macc_msac_operand\" \"\"))\n+\t(clobber (match_operand:SI 5 \"register_operand\" \"\"))\n \t(clobber (match_dup 1))])]\n-  \"ISA_HAS_MACC && GENERATE_MULT3_SI\n+  \"GENERATE_MULT3_SI\n    && true_regnum (operands[1]) == LO_REGNUM\n    && peep2_reg_dead_p (2, operands[1])\n    && GP_REG_P (true_regnum (operands[3]))\"\n   [(parallel [(set (match_dup 0)\n-\t\t   (mult:SI (match_dup 4)\n-\t\t\t    (match_dup 5)))\n-\t      (clobber (match_dup 6))\n+\t\t   (match_dup 6))\n+\t      (clobber (match_dup 5))\n \t      (clobber (match_dup 1))])\n    (set (match_dup 3)\n-\t(plus:SI (match_dup 0)\n-\t\t (match_dup 2)))]\n-  \"\")\n+\t(match_dup 7))]\n+{\n+  operands[6] = XEXP (operands[4], GET_CODE (operands[4]) == PLUS ? 0 : 1);\n+  operands[7] = gen_rtx_fmt_ee (GET_CODE (operands[4]), SImode,\n+\t\t\t\toperands[2], operands[0]);\n+})\n \n ;; Same as above, except LO is the initial target of the macc.\n ;;\n ;; Operand 0: GPR (scratch)\n ;; Operand 1: LO\n ;; Operand 2: GPR (addend)\n-;; Operand 3: GPR (1st multiplication operand)\n-;; Operand 4: GPR (2nd multiplication operand)\n-;; Operand 5: HI\n-;; Operand 6: GPR (destination)\n+;; Operand 3: macc/msac\n+;; Operand 4: HI\n+;; Operand 5: GPR (destination)\n+;; Operand 6: new multiplication\n+;; Operand 7: new addition/subtraction\n (define_peephole2\n   [(match_scratch:SI 0 \"d\")\n    (set (match_operand:SI 1 \"register_operand\" \"\")\n \t(match_operand:SI 2 \"register_operand\" \"\"))\n    (match_dup 0)\n    (parallel\n        [(set (match_dup 1)\n-\t     (plus:SI (mult:SI (match_operand:SI 3 \"register_operand\" \"\")\n-\t\t\t       (match_operand:SI 4 \"register_operand\" \"\"))\n-\t\t      (match_dup 1)))\n-\t(clobber (match_operand:SI 5 \"register_operand\" \"\"))\n+\t     (match_operand:SI 3 \"macc_msac_operand\" \"\"))\n+\t(clobber (match_operand:SI 4 \"register_operand\" \"\"))\n \t(clobber (scratch:SI))])\n    (match_dup 0)\n-   (set (match_operand:SI 6 \"register_operand\" \"\")\n+   (set (match_operand:SI 5 \"register_operand\" \"\")\n \t(match_dup 1))]\n-  \"ISA_HAS_MACC && GENERATE_MULT3_SI\n+  \"GENERATE_MULT3_SI\n    && true_regnum (operands[1]) == LO_REGNUM\n    && peep2_reg_dead_p (3, operands[1])\n-   && GP_REG_P (true_regnum (operands[6]))\"\n+   && GP_REG_P (true_regnum (operands[5]))\"\n   [(parallel [(set (match_dup 0)\n-\t\t   (mult:SI (match_dup 3)\n-\t\t\t    (match_dup 4)))\n-\t      (clobber (match_dup 5))\n+\t\t   (match_dup 6))\n+\t      (clobber (match_dup 4))\n \t      (clobber (match_dup 1))])\n-   (set (match_dup 6)\n-\t(plus:SI (match_dup 0)\n-\t\t (match_dup 2)))]\n-  \"\")\n+   (set (match_dup 5)\n+\t(match_dup 7))]\n+{\n+  operands[6] = XEXP (operands[4], GET_CODE (operands[4]) == PLUS ? 0 : 1);\n+  operands[7] = gen_rtx_fmt_ee (GET_CODE (operands[4]), SImode,\n+\t\t\t\toperands[2], operands[0]);\n+})\n \n (define_insn \"*mul_sub_si\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=l,*d,*d\")\n@@ -1873,25 +1903,6 @@\n   [(set_attr \"type\"     \"imul\")\n    (set_attr \"mode\"     \"SI\")])\n \n-(define_insn \"*msac\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l,d\")\n-        (minus:SI (match_operand:SI 1 \"register_operand\" \"0,l\")\n-                  (mult:SI (match_operand:SI 2 \"register_operand\" \"d,d\")\n-                           (match_operand:SI 3 \"register_operand\" \"d,d\"))))\n-   (clobber (match_scratch:SI 4 \"=h,h\"))\n-   (clobber (match_scratch:SI 5 \"=X,1\"))]\n-  \"ISA_HAS_MSAC\"\n-{\n-  if (which_alternative == 1)\n-    return \"msac\\t%0,%2,%3\";\n-  else if (TARGET_MIPS5500)\n-    return \"msub\\t%2,%3\";\n-  else\n-    return \"msac\\t$0,%2,%3\";\n-}\n-  [(set_attr \"type\"     \"imadd\")\n-   (set_attr \"mode\"     \"SI\")])\n-\n (define_expand \"muldi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(mult:DI (match_operand:DI 1 \"register_operand\" \"\")"}, {"sha": "a8a7364ad26cec0fe234a7ec16c44c4e21554047", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd06df78aded83cc747f067fb57b5c666046efa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd06df78aded83cc747f067fb57b5c666046efa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3bd06df78aded83cc747f067fb57b5c666046efa", "patch": "@@ -1,3 +1,7 @@\n+2004-04-17  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* gcc.dg/vr-mult-[12].c: New tests.\n+\n 2004-04-16  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* gcc.dg/funcorder.c: xfail hppa*64*-*-*."}, {"sha": "a208067fb7dbda8f581055c1a5ef1611185f4204", "filename": "gcc/testsuite/gcc.dg/vr-mult-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd06df78aded83cc747f067fb57b5c666046efa/gcc%2Ftestsuite%2Fgcc.dg%2Fvr-mult-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd06df78aded83cc747f067fb57b5c666046efa/gcc%2Ftestsuite%2Fgcc.dg%2Fvr-mult-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvr-mult-1.c?ref=3bd06df78aded83cc747f067fb57b5c666046efa", "patch": "@@ -0,0 +1,10 @@\n+/* Make sure that mul/addu is preferred over mtlo/macc on targets that\n+   support both.  */\n+/* { dg-do compile { target mips*-*-* } } */\n+/* { dg-options \"-O2\" } */\n+#if defined (_MIPS_ARCH_VR5400) || defined (_MIPS_ARCH_VR5500)\n+int f (int a, int b, int c) { return a + b * c; }\n+#else\n+void f () { asm volatile (\"mul/addu\"); }\n+#endif\n+/* { dg-final { scan-assembler \"mul.*addu\" } } */"}, {"sha": "4a3ad98cc2a91348dfe6b62d75ab0ddee9fe9f2d", "filename": "gcc/testsuite/gcc.dg/vr-mult-2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd06df78aded83cc747f067fb57b5c666046efa/gcc%2Ftestsuite%2Fgcc.dg%2Fvr-mult-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd06df78aded83cc747f067fb57b5c666046efa/gcc%2Ftestsuite%2Fgcc.dg%2Fvr-mult-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvr-mult-2.c?ref=3bd06df78aded83cc747f067fb57b5c666046efa", "patch": "@@ -0,0 +1,10 @@\n+/* Make sure that mul/subu is preferred over mtlo/msac on targets that\n+   support both.  */\n+/* { dg-do compile { target mips*-*-* } } */\n+/* { dg-options \"-O2\" } */\n+#if defined (_MIPS_ARCH_VR5400) || defined (_MIPS_ARCH_VR5500)\n+int f (int a, int b, int c) { return a - b * c; }\n+#else\n+void f () { asm volatile (\"mul/subu\"); }\n+#endif\n+/* { dg-final { scan-assembler \"mul.*subu\" } } */"}]}