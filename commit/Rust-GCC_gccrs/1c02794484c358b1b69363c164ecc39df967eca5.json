{"sha": "1c02794484c358b1b69363c164ecc39df967eca5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWMwMjc5NDQ4NGMzNThiMWI2OTM2M2MxNjRlY2MzOWRmOTY3ZWNhNQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2019-10-28T07:33:29Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2019-10-28T07:33:29Z"}, "message": "Fortran] PR91863 - fix call to bind(C) with array descriptor\n\n        PR fortran/91863\n        * trans-expr.c (gfc_conv_gfc_desc_to_cfi_desc): Don't free data\n        memory as that's done on the Fortran side.\n        (gfc_conv_procedure_call): Handle void* pointers from\n        gfc_conv_gfc_desc_to_cfi_desc.\n\n        PR fortran/91863\n        * gfortran.dg/bind-c-intent-out.f90: New.\n\nFrom-SVN: r277502", "tree": {"sha": "906496c3f83650aed85ca5d8f9431a882b87ab05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/906496c3f83650aed85ca5d8f9431a882b87ab05"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c02794484c358b1b69363c164ecc39df967eca5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c02794484c358b1b69363c164ecc39df967eca5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c02794484c358b1b69363c164ecc39df967eca5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c02794484c358b1b69363c164ecc39df967eca5/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6d099a76a0f6a040a3e678f2bce7fc69cc3257d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d099a76a0f6a040a3e678f2bce7fc69cc3257d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d099a76a0f6a040a3e678f2bce7fc69cc3257d8"}], "stats": {"total": 77, "additions": 62, "deletions": 15}, "files": [{"sha": "e77a3a43a5ae01f78694c0f414b01e6a37851d8c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c02794484c358b1b69363c164ecc39df967eca5/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c02794484c358b1b69363c164ecc39df967eca5/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=1c02794484c358b1b69363c164ecc39df967eca5", "patch": "@@ -1,3 +1,11 @@\n+2019-10-28  Tobias Burnus  <tobias@codesourcery.com>\n+\n+\tPR fortran/91863\n+\t* trans-expr.c (gfc_conv_gfc_desc_to_cfi_desc): Don't free data\n+\tmemory as that's done on the Fortran side.\n+\t(gfc_conv_procedure_call): Handle void* pointers from\n+\tgfc_conv_gfc_desc_to_cfi_desc.\n+\n 2019-10-27  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/86248"}, {"sha": "7eba1bbd0822c078531ded0f362f5a64f0413073", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c02794484c358b1b69363c164ecc39df967eca5/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c02794484c358b1b69363c164ecc39df967eca5/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=1c02794484c358b1b69363c164ecc39df967eca5", "patch": "@@ -5206,7 +5206,6 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)\n   int attribute;\n   int cfi_attribute;\n   symbol_attribute attr = gfc_expr_attr (e);\n-  stmtblock_t block;\n \n   /* If this is a full array or a scalar, the allocatable and pointer\n      attributes can be passed. Otherwise it is 'CFI_attribute_other'*/\n@@ -5325,18 +5324,6 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)\n   /* The CFI descriptor is passed to the bind_C procedure.  */\n   parmse->expr = cfi_desc_ptr;\n \n-  /* Free the CFI descriptor.  */\n-  gfc_init_block (&block);\n-  cond = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t  logical_type_node, cfi_desc_ptr,\n-\t\t\t  build_int_cst (TREE_TYPE (cfi_desc_ptr), 0));\n-  tmp = gfc_call_free (cfi_desc_ptr);\n-  gfc_add_expr_to_block (&block, tmp);\n-  tmp = build3_v (COND_EXPR, cond,\n-\t\t  gfc_finish_block (&block),\n-\t\t  build_empty_stmt (input_location));\n-  gfc_prepend_expr_to_block (&parmse->post, tmp);\n-\n   /* Transfer values back to gfc descriptor.  */\n   tmp = gfc_build_addr_expr (NULL_TREE, parmse->expr);\n   tmp = build_call_expr_loc (input_location,\n@@ -6250,8 +6237,14 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t      gfc_add_expr_to_block (&se->pre, tmp);\n \t\t  }\n \n-\t\t  tmp = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t\t     parmse.expr);\n+\t\t  tmp = parmse.expr;\n+\t\t  /* With bind(C), the actual argument is replaced by a bind-C\n+\t\t     descriptor; in this case, the data component arrives here,\n+\t\t     which shall not be dereferenced, but still freed and\n+\t\t     nullified.  */\n+\t\t  if  (TREE_TYPE(tmp) != pvoid_type_node)\n+\t\t    tmp = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t       parmse.expr);\n \t\t  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (tmp)))\n \t\t    tmp = gfc_conv_descriptor_data_get (tmp);\n \t\t  tmp = gfc_deallocate_with_status (tmp, NULL_TREE, NULL_TREE,"}, {"sha": "c7fbd0e5c09093187bc6443ff814de7234768d95", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c02794484c358b1b69363c164ecc39df967eca5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c02794484c358b1b69363c164ecc39df967eca5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1c02794484c358b1b69363c164ecc39df967eca5", "patch": "@@ -1,3 +1,8 @@\n+2019-10-28  Tobias Burnus  <tobias@codesourcery.com>\n+\n+\tPR fortran/91863\n+\t* gfortran.dg/bind-c-intent-out.f90: New.\n+\n 2019-10-25  Jiufu Guo  <guojiufu@linux.ibm.com>\n \n \tPR tree-optimization/88760"}, {"sha": "493e546d45df9372bdb0fb45a9bf20fc6e1516b8", "filename": "gcc/testsuite/gfortran.dg/bind-c-intent-out.f90", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c02794484c358b1b69363c164ecc39df967eca5/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-intent-out.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c02794484c358b1b69363c164ecc39df967eca5/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-intent-out.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind-c-intent-out.f90?ref=1c02794484c358b1b69363c164ecc39df967eca5", "patch": "@@ -0,0 +1,41 @@\n+! { dg-do compile }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! PR fortran/91863\n+!\n+! Contributed by G. Steinmetz\n+!\n+\n+subroutine sub(x) bind(c)\n+  implicit none (type, external)\n+  integer, allocatable, intent(out) :: x(:)\n+\n+  allocate(x(3:5))\n+  x(:) = [1, 2, 3]\n+end subroutine sub\n+\n+\n+program p\n+  implicit none (type, external)\n+  interface\n+    subroutine sub(x) bind(c)\n+      integer, allocatable, intent(out) :: x(:)\n+    end\n+  end interface\n+  integer, allocatable :: a(:)\n+\n+  call sub(a)\n+  if (.not.allocated(a)) stop 1\n+  if (any(shape(a) /= [3])) stop 2\n+  if (lbound(a,1) /= 3 .or. ubound(a,1) /= 5) stop 3\n+  if (any(a /= [1, 2, 3])) stop 4\n+end program p\n+\n+! \"cfi\" only appears in context of \"a\" -> bind-C descriptor\n+! the intent(out) implies freeing in the callee (!), hence the \"free\"\n+! It is the only 'free' as 'a' is part of the main program and, hence, implicitly has the SAVE attribute.\n+! The  'cfi = 0' appears before the call due to the deallocate and when preparing the C descriptor\n+\n+! { dg-final { scan-tree-dump-times \"__builtin_free\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_free \\\\(cfi\\\\.\\[0-9\\]+\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"cfi\\\\.\\[0-9\\]+ = 0B;\" 2 \"original\" } }"}]}