{"sha": "b699150bde238c8e577296a116af226cc64e7052", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY5OTE1MGJkZTIzOGM4ZTU3NzI5NmExMTZhZjIyNmNjNjRlNzA1Mg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2007-06-01T02:12:37Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2007-06-01T02:12:37Z"}, "message": "Fixup whitespacing\n\nFrom-SVN: r125255", "tree": {"sha": "09218e8a7b599737f442e57c6f69ce673f9fe280", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09218e8a7b599737f442e57c6f69ce673f9fe280"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b699150bde238c8e577296a116af226cc64e7052", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b699150bde238c8e577296a116af226cc64e7052", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b699150bde238c8e577296a116af226cc64e7052", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b699150bde238c8e577296a116af226cc64e7052/comments", "author": null, "committer": null, "parents": [{"sha": "46a9e5217844297332b2e5e0c568d4448f365e96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46a9e5217844297332b2e5e0c568d4448f365e96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46a9e5217844297332b2e5e0c568d4448f365e96"}], "stats": {"total": 78, "additions": 39, "deletions": 39}, "files": [{"sha": "bf7b9bea36d9aec166f6c515e83389f47a9603d2", "filename": "libcpp/pch.c", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b699150bde238c8e577296a116af226cc64e7052/libcpp%2Fpch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b699150bde238c8e577296a116af226cc64e7052/libcpp%2Fpch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fpch.c?ref=b699150bde238c8e577296a116af226cc64e7052", "patch": "@@ -35,14 +35,14 @@ static int write_defs (cpp_reader *, cpp_hashnode *, void *);\n static int save_macros (cpp_reader *, cpp_hashnode *, void *);\n \n /* This structure represents a macro definition on disk.  */\n-struct macrodef_struct \n+struct macrodef_struct\n {\n   unsigned int definition_length;\n   unsigned short name_length;\n   unsigned short flags;\n };\n \n-/* This is how we write out a macro definition.  \n+/* This is how we write out a macro definition.\n    Suitable for being called by cpp_forall_identifiers.  */\n \n static int\n@@ -54,7 +54,7 @@ write_macdef (cpp_reader *pfile, cpp_hashnode *hn, void *file_p)\n     case NT_VOID:\n       if (! (hn->flags & NODE_POISONED))\n \treturn 1;\n-      \n+\n     case NT_MACRO:\n       if ((hn->flags & NODE_BUILTIN))\n \treturn 1;\n@@ -76,7 +76,7 @@ write_macdef (cpp_reader *pfile, cpp_hashnode *hn, void *file_p)\n \t    defn = NODE_NAME (hn);\n \t    s.definition_length = s.name_length;\n \t  }\n-\t\n+\n \tif (fwrite (&s, sizeof (s), 1, f) != 1\n \t    || fwrite (defn, 1, s.definition_length, f) != s.definition_length)\n \t  {\n@@ -86,7 +86,7 @@ write_macdef (cpp_reader *pfile, cpp_hashnode *hn, void *file_p)\n \t  }\n       }\n       return 1;\n-      \n+\n     case NT_ASSERTION:\n       /* Not currently implemented.  */\n       return 1;\n@@ -123,7 +123,7 @@ static int\n save_idents (cpp_reader *pfile ATTRIBUTE_UNUSED, cpp_hashnode *hn, void *ss_p)\n {\n   struct cpp_savedstate *const ss = (struct cpp_savedstate *)ss_p;\n-  \n+\n   if (hn->type != NT_VOID)\n     {\n       struct cpp_string news;\n@@ -136,7 +136,7 @@ save_idents (cpp_reader *pfile ATTRIBUTE_UNUSED, cpp_hashnode *hn, void *ss_p)\n \t{\n \t  struct cpp_string *sp;\n \t  unsigned char *text;\n-\t  \n+\n \t  sp = XNEW (struct cpp_string);\n \t  *slot = sp;\n \n@@ -157,7 +157,7 @@ hashmem (const void *p_p, size_t sz)\n   const unsigned char *p = (const unsigned char *)p_p;\n   size_t i;\n   hashval_t h;\n-  \n+\n   h = 0;\n   for (i = 0; i < sz; i++)\n     h = h * 67 - (*p++ - 113);\n@@ -194,10 +194,10 @@ cpp_save_state (cpp_reader *r, FILE *f)\n {\n   /* Save the list of non-void identifiers for the dependency checking.  */\n   r->savedstate = XNEW (struct cpp_savedstate);\n-  r->savedstate->definedhash = htab_create (100, cpp_string_hash, \n+  r->savedstate->definedhash = htab_create (100, cpp_string_hash,\n \t\t\t\t\t    cpp_string_eq, NULL);\n   cpp_forall_identifiers (r, save_idents, r->savedstate);\n-  \n+\n   /* Write out the list of defined identifiers.  */\n   cpp_forall_identifiers (r, write_macdef, f);\n \n@@ -210,20 +210,20 @@ static int\n count_defs (cpp_reader *pfile ATTRIBUTE_UNUSED, cpp_hashnode *hn, void *ss_p)\n {\n   struct cpp_savedstate *const ss = (struct cpp_savedstate *)ss_p;\n-  \n+\n   switch (hn->type)\n     {\n     case NT_MACRO:\n       if (hn->flags & NODE_BUILTIN)\n \treturn 1;\n-      \n+\n       /* else fall through.  */\n \n     case NT_VOID:\n       {\n \tstruct cpp_string news;\n \tvoid **slot;\n-\t\n+\n \tnews.len = NODE_LEN (hn);\n \tnews.text = NODE_NAME (hn);\n \tslot = (void **) htab_find (ss->definedhash, &news);\n@@ -249,20 +249,20 @@ static int\n write_defs (cpp_reader *pfile ATTRIBUTE_UNUSED, cpp_hashnode *hn, void *ss_p)\n {\n   struct cpp_savedstate *const ss = (struct cpp_savedstate *)ss_p;\n-  \n+\n   switch (hn->type)\n     {\n     case NT_MACRO:\n       if (hn->flags & NODE_BUILTIN)\n \treturn 1;\n-      \n+\n       /* else fall through.  */\n \n     case NT_VOID:\n       {\n \tstruct cpp_string news;\n \tvoid **slot;\n-\t\n+\n \tnews.len = NODE_LEN (hn);\n \tnews.text = NODE_NAME (hn);\n \tslot = (void **) htab_find (ss->definedhash, &news);\n@@ -303,7 +303,7 @@ cpp_write_pch_deps (cpp_reader *r, FILE *f)\n   struct cpp_savedstate *const ss = r->savedstate;\n   unsigned char *definedstrs;\n   size_t i;\n-  \n+\n   /* Collect the list of identifiers which have been seen and\n      weren't defined to anything previously.  */\n   ss->hashsize = 0;\n@@ -421,7 +421,7 @@ collect_ht_nodes (cpp_reader *pfile ATTRIBUTE_UNUSED, cpp_hashnode *hn,\n    with the preprocessor's current definitions.  It will be consistent\n    when:\n \n-   - anything that was defined just before the PCH was generated \n+   - anything that was defined just before the PCH was generated\n      is defined the same way now; and\n    - anything that was not defined then, but is defined now, was not\n      used by the PCH.\n@@ -441,17 +441,17 @@ cpp_valid_state (cpp_reader *r, const char *name, int fd)\n   unsigned char *first, *last;\n   unsigned int i;\n   unsigned int counter;\n-  \n+\n   /* Read in the list of identifiers that must be defined\n      Check that they are defined in the same way.  */\n   for (;;)\n     {\n       cpp_hashnode *h;\n       const unsigned char *newdefn;\n-      \n+\n       if (read (fd, &m, sizeof (m)) != sizeof (m))\n \tgoto error;\n-      \n+\n       if (m.name_length == 0)\n \tbreak;\n \n@@ -471,10 +471,10 @@ cpp_valid_state (cpp_reader *r, const char *name, int fd)\n \t  namebuf = XNEWVEC (unsigned char, namebufsz);\n \t}\n \n-      if ((size_t)read (fd, namebuf, m.definition_length) \n+      if ((size_t)read (fd, namebuf, m.definition_length)\n \t  != m.definition_length)\n \tgoto error;\n-      \n+\n       h = cpp_lookup (r, namebuf, m.name_length);\n       if (m.flags & NODE_POISONED\n \t  || h->type != NT_MACRO\n@@ -488,7 +488,7 @@ cpp_valid_state (cpp_reader *r, const char *name, int fd)\n \t}\n \n       newdefn = cpp_macro_definition (r, h);\n-      \n+\n       if (m.definition_length != ustrlen (newdefn)\n \t  || memcmp (namebuf, newdefn, m.definition_length) != 0)\n \t{\n@@ -516,31 +516,31 @@ cpp_valid_state (cpp_reader *r, const char *name, int fd)\n   nl.defs = XNEWVEC (cpp_hashnode *, nl.asize);\n   cpp_forall_identifiers (r, &collect_ht_nodes, &nl);\n   qsort (nl.defs, nl.n_defs, sizeof (cpp_hashnode *), &comp_hashnodes);\n- \n+\n   /* Loop through nl.defs and undeftab, both of which are sorted lists.\n      There should be no matches.  */\n   first = undeftab;\n   last = undeftab + m.definition_length;\n   i = 0;\n- \n+\n   while (first < last && i < nl.n_defs)\n     {\n       int cmp = ustrcmp (first, NODE_NAME (nl.defs[i]));\n- \n+\n       if (cmp < 0)\n  \tfirst += ustrlen (first) + 1;\n       else if (cmp > 0)\n  \t++i;\n       else\n \t{\n \t  if (CPP_OPTION (r, warn_invalid_pch))\n-\t    cpp_error (r, CPP_DL_WARNING_SYSHDR, \n+\t    cpp_error (r, CPP_DL_WARNING_SYSHDR,\n \t\t       \"%s: not used because `%s' is defined\",\n \t\t       name, first);\n \t  goto fail;\n \t}\n     }\n-   \n+\n   free(nl.defs);\n   nl.defs = NULL;\n   free (undeftab);\n@@ -554,7 +554,7 @@ cpp_valid_state (cpp_reader *r, const char *name, int fd)\n   if (counter && r->counter)\n     {\n       if (CPP_OPTION (r, warn_invalid_pch))\n-\tcpp_error (r, CPP_DL_WARNING_SYSHDR, \n+\tcpp_error (r, CPP_DL_WARNING_SYSHDR,\n \t\t   \"%s: not used because `__COUNTER__' is invalid\",\n \t\t   name);\n \tgoto fail;\n@@ -579,7 +579,7 @@ cpp_valid_state (cpp_reader *r, const char *name, int fd)\n \n /* Save all the existing macros.  */\n \n-struct save_macro_data \n+struct save_macro_data\n {\n   uchar **defns;\n   size_t count;\n@@ -601,7 +601,7 @@ struct save_macro_data\n    file were not saved in this way, but this is not done (yet), except\n    for builtins, and for #assert by default.  */\n \n-static int \n+static int\n save_macros (cpp_reader *r, cpp_hashnode *h, void *data_p)\n {\n   struct save_macro_data *data = (struct save_macro_data *)data_p;\n@@ -611,9 +611,9 @@ save_macros (cpp_reader *r, cpp_hashnode *h, void *data_p)\n       if (data->count == data->array_size)\n \t{\n \t  data->array_size *= 2;\n-\t  data->defns = XRESIZEVEC (uchar *, data->defns, (data->array_size)); \n+\t  data->defns = XRESIZEVEC (uchar *, data->defns, (data->array_size));\n \t}\n-      \n+\n       switch (h->type)\n \t{\n \tcase NT_ASSERTION:\n@@ -630,7 +630,7 @@ save_macros (cpp_reader *r, cpp_hashnode *h, void *data_p)\n \t    data->defns[data->count][defnlen] = '\\n';\n \t  }\n \t  break;\n-\t  \n+\n \tdefault:\n \t  abort ();\n \t}\n@@ -646,7 +646,7 @@ void\n cpp_prepare_state (cpp_reader *r, struct save_macro_data **data)\n {\n   struct save_macro_data *d = XNEW (struct save_macro_data);\n-  \n+\n   d->array_size = 512;\n   d->defns = XNEWVEC (uchar *, d->array_size);\n   d->count = 0;\n@@ -656,7 +656,7 @@ cpp_prepare_state (cpp_reader *r, struct save_macro_data **data)\n }\n \n /* Given a precompiled header that was previously determined to be valid,\n-   apply all its definitions (and undefinitions) to the current state. \n+   apply all its definitions (and undefinitions) to the current state.\n    DEPNAME is passed to deps_restore.  */\n \n int\n@@ -667,7 +667,7 @@ cpp_read_state (cpp_reader *r, const char *name, FILE *f,\n   struct lexer_state old_state;\n   unsigned int counter;\n \n-  /* Restore spec_nodes, which will be full of references to the old \n+  /* Restore spec_nodes, which will be full of references to the old\n      hashtable entries and so will now be invalid.  */\n   {\n     struct spec_nodes *s = &r->spec_nodes;\n@@ -732,7 +732,7 @@ cpp_read_state (cpp_reader *r, const char *name, FILE *f,\n     r->counter = counter;\n \n   return 0;\n-  \n+\n  error:\n   cpp_errno (r, CPP_DL_ERROR, \"while reading precompiled header\");\n   return -1;"}]}