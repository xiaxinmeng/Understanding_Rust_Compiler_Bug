{"sha": "6fa8e0896c6ec96eddcedb2b92502a7bbb525c03", "node_id": "C_kwDOANBUbNoAKDZmYThlMDg5NmM2ZWM5NmVkZGNlZGIyYjkyNTAyYTdiYmI1MjVjMDM", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-11-18T15:04:27Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-11-18T15:04:27Z"}, "message": "c++: unqual lookup performed twice w/ template-id ADL [PR102670]\n\nHere we're incorrectly performing unqualified lookup of 'adl' again at\nsubstitution time for the call adl<I>(t) (for which name lookup at parse\ntime found nothing) which causes us to reject the testcase because the\nsecond unqualified lookup finds the later-declared variable template\n'adl', leading to confusion.  Fixed thusly.\n\nThe testcase concepts-recursive-sat1.C needed to be adjusted to use ADL\nproper instead of relying on this incorrect second unqualified lookup.\n\n\tPR c++/102670\n\ngcc/cp/ChangeLog:\n\n\t* pt.c (tsubst_copy_and_build) <case CALL_EXPR>: When looking\n\tfor an identifier callee in the koenig_p case, also look through\n\tTEMPLATE_ID_EXPR.  Use tsubst_copy to substitute through the\n\ttemplate arguments of the template-id.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp2a/concepts-recursive-sat1.C: Adjust to use ADL\n\tproper.\n\t* g++.dg/cpp2a/fn-template23.C: New test.", "tree": {"sha": "bd370afc0e0047b2239d602b60b98e0421757f83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd370afc0e0047b2239d602b60b98e0421757f83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6fa8e0896c6ec96eddcedb2b92502a7bbb525c03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fa8e0896c6ec96eddcedb2b92502a7bbb525c03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fa8e0896c6ec96eddcedb2b92502a7bbb525c03", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fa8e0896c6ec96eddcedb2b92502a7bbb525c03/comments", "author": null, "committer": null, "parents": [{"sha": "e3dbd2e14020d5a4f3401fa60dd5792b99fae108", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3dbd2e14020d5a4f3401fa60dd5792b99fae108", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3dbd2e14020d5a4f3401fa60dd5792b99fae108"}], "stats": {"total": 62, "additions": 56, "deletions": 6}, "files": [{"sha": "2e31663c277bd98f9a38f832f4c48109be11b470", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa8e0896c6ec96eddcedb2b92502a7bbb525c03/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa8e0896c6ec96eddcedb2b92502a7bbb525c03/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6fa8e0896c6ec96eddcedb2b92502a7bbb525c03", "patch": "@@ -20267,7 +20267,10 @@ tsubst_copy_and_build (tree t,\n \t\t\t\t\t    /*done=*/false,\n \t\t\t\t\t    /*address_p=*/false);\n \t  }\n-\telse if (koenig_p && identifier_p (function))\n+\telse if (koenig_p\n+\t\t && (identifier_p (function)\n+\t\t     || (TREE_CODE (function) == TEMPLATE_ID_EXPR\n+\t\t\t && identifier_p (TREE_OPERAND (function, 0)))))\n \t  {\n \t    /* Do nothing; calling tsubst_copy_and_build on an identifier\n \t       would incorrectly perform unqualified lookup again.\n@@ -20280,6 +20283,12 @@ tsubst_copy_and_build (tree t,\n \t       FIXME but doing that causes c++/15272, so we need to stop\n \t       using IDENTIFIER_NODE in that situation.  */\n \t    qualified_p = false;\n+\n+\t    if (TREE_CODE (function) == TEMPLATE_ID_EXPR)\n+\t      /* Use tsubst_copy to substitute through the template arguments\n+\t\t of the template-id without performing unqualified lookup of\n+\t\t the template name.  */\n+\t      function = tsubst_copy (function, args, complain, in_decl);\n \t  }\n \telse\n \t  {"}, {"sha": "0103e7a591f8c582c33e0d110a22d61bb9abac52", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-recursive-sat1.C", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa8e0896c6ec96eddcedb2b92502a7bbb525c03/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-recursive-sat1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa8e0896c6ec96eddcedb2b92502a7bbb525c03/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-recursive-sat1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-recursive-sat1.C?ref=6fa8e0896c6ec96eddcedb2b92502a7bbb525c03", "patch": "@@ -3,16 +3,21 @@\n template<int N, typename T>\n concept Foo = requires(T t) { foo<N + 1>(t); }; // { dg-error \"template instantiation depth\" }\n \n-template<int N = 1, typename T = int>\n-  requires Foo<N, T>\n-int foo(T t)\n+namespace ns\n {\n-  return foo<N + 1>(t);\n+  struct S { };\n+\n+  template<int N, typename T>\n+    requires Foo<N, T>\n+  int foo(T t)\n+  {\n+    return foo<N + 1>(t);\n+  }\n }\n \n int main(int, char**)\n {\n-  return foo<1>(1);\n+  return foo<1>(ns::S{});\n }\n \n // { dg-prune-output \"compilation terminated\" }"}, {"sha": "b85d4c96dab6f94069eda4969f50857fb46cd86f", "filename": "gcc/testsuite/g++.dg/cpp2a/fn-template23.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa8e0896c6ec96eddcedb2b92502a7bbb525c03/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffn-template23.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa8e0896c6ec96eddcedb2b92502a7bbb525c03/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffn-template23.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffn-template23.C?ref=6fa8e0896c6ec96eddcedb2b92502a7bbb525c03", "patch": "@@ -0,0 +1,36 @@\n+// PR c++/102670\n+// { dg-do compile { target c++20 } }\n+\n+namespace ns {\n+  struct S { };\n+\n+  template<int I>\n+  constexpr int adl(const S &) {\n+    return I;\n+  }\n+}\n+\n+namespace redirect {\n+  template<class T, int I>\n+  concept can_call_adl = requires(T t) {\n+    adl<I>(t);\n+  };\n+\n+  template<int I>\n+  struct adl_fn {\n+    template<can_call_adl<I> T>\n+    constexpr decltype(auto) operator()(T t) const {\n+      return adl<I>(t);\n+    }\n+  };\n+\n+  namespace {\n+    template<int I>\n+    constexpr inline adl_fn<I> adl{};\n+  }\n+}\n+\n+int main() {\n+  static_assert(redirect::can_call_adl<ns::S, 3>);\n+  redirect::adl<3>(ns::S{});\n+}"}]}