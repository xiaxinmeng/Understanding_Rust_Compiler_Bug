{"sha": "ba52669fc5861ec7ae9d38ea007340fc6cef83ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE1MjY2OWZjNTg2MWVjN2FlOWQzOGVhMDA3MzQwZmM2Y2VmODNlYQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2016-03-10T10:47:13Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2016-03-10T10:47:13Z"}, "message": "PR69195, Reload confused by invalid reg_equiv\n\nOptimizing indirect jumps to direct jumps, and deleting dead insns can\nlead to changes in register lifetimes, which in turn can result in bad\nreg_equiv info being passed to reload.  So do these tasks before\ncalculating reg_equiv info.\n\ngcc/\n\tPR rtl-optimization/69195\n\tPR rtl-optimization/47992\n\t* ira.c (recorded_label_ref): Delete.\n\t(update_equiv_regs): Return void.\n\t(indirect_jump_optimize): New function.\n\t(ira): Call indirect_jump_optimize and delete_trivially_dead_insns\n\tbefore regstat_compute_ri.  Don't rebuild_jump_labels here.\n\tDelete update_regstat.\ngcc/testsuite/\n\t* gcc.dg/pr69195.c: New.\n\t* gcc.dg/pr69238.c: New.\n\nFrom-SVN: r234101", "tree": {"sha": "0fb488f6de57ef8b4dcf655f1d976f3492816539", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0fb488f6de57ef8b4dcf655f1d976f3492816539"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba52669fc5861ec7ae9d38ea007340fc6cef83ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba52669fc5861ec7ae9d38ea007340fc6cef83ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba52669fc5861ec7ae9d38ea007340fc6cef83ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba52669fc5861ec7ae9d38ea007340fc6cef83ea/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "27742332348988c735f3a9eb9fa24bce57bec7a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27742332348988c735f3a9eb9fa24bce57bec7a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27742332348988c735f3a9eb9fa24bce57bec7a6"}], "stats": {"total": 173, "additions": 123, "deletions": 50}, "files": [{"sha": "77c707f29abd324927168bd915929101c4cf74d3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba52669fc5861ec7ae9d38ea007340fc6cef83ea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba52669fc5861ec7ae9d38ea007340fc6cef83ea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ba52669fc5861ec7ae9d38ea007340fc6cef83ea", "patch": "@@ -1,3 +1,14 @@\n+2016-03-10  Alan Modra  <amodra@gmail.com>\n+\n+\tPR rtl-optimization/69195\n+\tPR rtl-optimization/47992\n+\t* ira.c (recorded_label_ref): Delete.\n+\t(update_equiv_regs): Return void.\n+\t(indirect_jump_optimize): New function.\n+\t(ira): Call indirect_jump_optimize and delete_trivially_dead_insns\n+\tbefore regstat_compute_ri.  Don't rebuild_jump_labels here.\n+\tDelete update_regstat.\n+\n 2016-03-10  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/70128"}, {"sha": "5e7a2edf3b4c5af7473ef7e4ebbe28e6b2f6d5ca", "filename": "gcc/ira.c", "status": "modified", "additions": 52, "deletions": 50, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba52669fc5861ec7ae9d38ea007340fc6cef83ea/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba52669fc5861ec7ae9d38ea007340fc6cef83ea/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=ba52669fc5861ec7ae9d38ea007340fc6cef83ea", "patch": "@@ -3319,9 +3319,6 @@ adjust_cleared_regs (rtx loc, const_rtx old_rtx ATTRIBUTE_UNUSED, void *data)\n   return NULL_RTX;\n }\n \n-/* Nonzero if we recorded an equivalence for a LABEL_REF.  */\n-static int recorded_label_ref;\n-\n /* Find registers that are equivalent to a single value throughout the\n    compilation (either because they can be referenced in memory or are\n    set once from a single constant).  Lower their priority for a\n@@ -3331,10 +3328,8 @@ static int recorded_label_ref;\n    value into the using insn.  If it succeeds, we can eliminate the\n    register completely.\n \n-   Initialize init_insns in ira_reg_equiv array.\n-\n-   Return non-zero if jump label rebuilding should be done.  */\n-static int\n+   Initialize init_insns in ira_reg_equiv array.  */\n+static void\n update_equiv_regs (void)\n {\n   rtx_insn *insn;\n@@ -3343,10 +3338,6 @@ update_equiv_regs (void)\n   bitmap cleared_regs;\n   bool *pdx_subregs;\n \n-  /* We need to keep track of whether or not we recorded a LABEL_REF so\n-     that we know if the jump optimizer needs to be rerun.  */\n-  recorded_label_ref = 0;\n-\n   /* Use pdx_subregs to show whether a reg is used in a paradoxical\n      subreg.  */\n   pdx_subregs = XCNEWVEC (bool, max_regno);\n@@ -3578,17 +3569,6 @@ update_equiv_regs (void)\n \t\t  = gen_rtx_INSN_LIST (VOIDmode, insn,\n \t\t\t\t       ira_reg_equiv[regno].init_insns);\n \n-\t      /* Record whether or not we created a REG_EQUIV note for a LABEL_REF.\n-\t\t We might end up substituting the LABEL_REF for uses of the\n-\t\t pseudo here or later.  That kind of transformation may turn an\n-\t\t indirect jump into a direct jump, in which case we must rerun the\n-\t\t jump optimizer to ensure that the JUMP_LABEL fields are valid.  */\n-\t      if (GET_CODE (x) == LABEL_REF\n-\t\t  || (GET_CODE (x) == CONST\n-\t\t      && GET_CODE (XEXP (x, 0)) == PLUS\n-\t\t      && (GET_CODE (XEXP (XEXP (x, 0), 0)) == LABEL_REF)))\n-\t\trecorded_label_ref = 1;\n-\n \t      reg_equiv[regno].replacement = x;\n \t      reg_equiv[regno].src_p = &SET_SRC (set);\n \t      reg_equiv[regno].loop_depth = (short) loop_depth;\n@@ -3706,9 +3686,9 @@ update_equiv_regs (void)\n \t  if (! INSN_P (insn))\n \t    continue;\n \n-\t  /* Don't substitute into a non-local goto, this confuses CFG.  */\n-\t  if (JUMP_P (insn)\n-\t      && find_reg_note (insn, REG_NON_LOCAL_GOTO, NULL_RTX))\n+\t  /* Don't substitute into jumps.  indirect_jump_optimize does\n+\t     this for anything we are prepared to handle.  */\n+\t  if (JUMP_P (insn))\n \t    continue;\n \n \t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n@@ -3860,11 +3840,50 @@ update_equiv_regs (void)\n   end_alias_analysis ();\n   free (reg_equiv);\n   free (pdx_subregs);\n-  return recorded_label_ref;\n }\n \n-\f\n+/* A pass over indirect jumps, converting simple cases to direct jumps.  */\n+static void\n+indirect_jump_optimize (void)\n+{\n+  basic_block bb;\n+  bool rebuild_p = false;\n \n+  FOR_EACH_BB_REVERSE_FN (bb, cfun)\n+    {\n+      rtx_insn *insn = BB_END (bb);\n+      if (!JUMP_P (insn))\n+\tcontinue;\n+\n+      rtx x = pc_set (insn);\n+      if (!x || !REG_P (SET_SRC (x)))\n+\tcontinue;\n+\n+      int regno = REGNO (SET_SRC (x));\n+      if (DF_REG_DEF_COUNT (regno) == 1)\n+\t{\n+\t  rtx_insn *def_insn = DF_REF_INSN (DF_REG_DEF_CHAIN (regno));\n+\t  rtx note = find_reg_note (def_insn, REG_LABEL_OPERAND, NULL_RTX);\n+\n+\t  if (note)\n+\t    {\n+\t      rtx lab = gen_rtx_LABEL_REF (Pmode, XEXP (note, 0));\n+\t      if (validate_replace_rtx (SET_SRC (x), lab, insn))\n+\t\trebuild_p = true;\n+\t    }\n+\t}\n+    }\n+\n+  if (rebuild_p)\n+    {\n+      timevar_push (TV_JUMP);\n+      rebuild_jump_labels (get_insns ());\n+      if (purge_all_dead_edges ())\n+\tdelete_unreachable_blocks ();\n+      timevar_pop (TV_JUMP);\n+    }\n+}\n+\f\n /* Set up fields memory, constant, and invariant from init_insns in\n    the structures of array ira_reg_equiv.  */\n static void\n@@ -5090,7 +5109,6 @@ ira (FILE *f)\n {\n   bool loops_p;\n   int ira_max_point_before_emit;\n-  int rebuild_p;\n   bool saved_flag_caller_saves = flag_caller_saves;\n   enum ira_region saved_flag_ira_region = flag_ira_region;\n \n@@ -5167,6 +5185,10 @@ ira (FILE *f)\n \n   df_clear_flags (DF_NO_INSN_RESCAN);\n \n+  indirect_jump_optimize ();\n+  if (delete_trivially_dead_insns (get_insns (), max_reg_num ()))\n+    df_analyze ();\n+\n   regstat_init_n_sets_and_refs ();\n   regstat_compute_ri ();\n \n@@ -5184,32 +5206,12 @@ ira (FILE *f)\n   if (resize_reg_info () && flag_ira_loop_pressure)\n     ira_set_pseudo_classes (true, ira_dump_file);\n \n-  rebuild_p = update_equiv_regs ();\n+  update_equiv_regs ();\n   setup_reg_equiv ();\n   setup_reg_equiv_init ();\n \n-  bool update_regstat = false;\n-\n-  if (optimize && rebuild_p)\n-    {\n-      timevar_push (TV_JUMP);\n-      rebuild_jump_labels (get_insns ());\n-      if (purge_all_dead_edges ())\n-\t{\n-\t  delete_unreachable_blocks ();\n-\t  update_regstat = true;\n-\t}\n-      timevar_pop (TV_JUMP);\n-    }\n-\n   allocated_reg_info_size = max_reg_num ();\n \n-  if (delete_trivially_dead_insns (get_insns (), max_reg_num ()))\n-    {\n-      df_analyze ();\n-      update_regstat = true;\n-    }\n-\n   /* It is not worth to do such improvement when we use a simple\n      allocation because of -O0 usage or because the function is too\n      big.  */\n@@ -5319,7 +5321,7 @@ ira (FILE *f)\n     check_allocation ();\n #endif\n \n-  if (update_regstat || max_regno != max_regno_before_ira)\n+  if (max_regno != max_regno_before_ira)\n     {\n       regstat_free_n_sets_and_refs ();\n       regstat_free_ri ();"}, {"sha": "9ae7afd6d9b5c9675c468fe24d05970e2b15b370", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba52669fc5861ec7ae9d38ea007340fc6cef83ea/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba52669fc5861ec7ae9d38ea007340fc6cef83ea/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ba52669fc5861ec7ae9d38ea007340fc6cef83ea", "patch": "@@ -1,3 +1,8 @@\n+2016-03-10  Alan Modra  <amodra@gmail.com>\n+\n+\t* gcc.dg/pr69195.c: New.\n+\t* gcc.dg/pr69238.c: New.\n+\n 2016-03-10  Tom de Vries  <tom@codesourcery.com>\n \n \tPR testsuite/68915"}, {"sha": "af373a1223ed57436ef0d25267670e4a7f694cdf", "filename": "gcc/testsuite/gcc.dg/pr69195.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba52669fc5861ec7ae9d38ea007340fc6cef83ea/gcc%2Ftestsuite%2Fgcc.dg%2Fpr69195.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba52669fc5861ec7ae9d38ea007340fc6cef83ea/gcc%2Ftestsuite%2Fgcc.dg%2Fpr69195.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr69195.c?ref=ba52669fc5861ec7ae9d38ea007340fc6cef83ea", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fno-dce -fno-forward-propagate\" } */\n+\n+void __attribute__ ((noinline, noclone))\n+foo (int *a, int n)\n+{\n+  int *lasta = a + n;\n+  for (; a != lasta; a++)\n+    {\n+      *a *= 2;\n+      a[1] = a[-1] + a[-2];\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  int a[16] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };\n+  int r[16] = { 1, 2, 6, 6, 16, 24, 44, 80,\n+\t\t136, 248, 432, 768, 1360, 2400, 4256, 3760 };\n+  unsigned i;\n+  foo (&a[2], 13);\n+  for (i = 0; i < 8; ++i)\n+    if (a[i] != r[i])\n+      __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "3538e634429707bcdd2cfec68a7c4e5e49a776b5", "filename": "gcc/testsuite/gcc.dg/pr69238.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba52669fc5861ec7ae9d38ea007340fc6cef83ea/gcc%2Ftestsuite%2Fgcc.dg%2Fpr69238.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba52669fc5861ec7ae9d38ea007340fc6cef83ea/gcc%2Ftestsuite%2Fgcc.dg%2Fpr69238.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr69238.c?ref=ba52669fc5861ec7ae9d38ea007340fc6cef83ea", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-dce -fno-forward-propagate -fno-rerun-cse-after-loop -funroll-loops\" } */\n+\n+\n+#define N 32\n+\n+short sa[N];\n+short sb[N];\n+int ia[N];\n+int ib[N];\n+\n+int __attribute__ ((noinline, noclone))\n+main1 (int n)\n+{\n+  int i;\n+  for (i = 0; i < n; i++)\n+    {\n+      sa[i+7] = sb[i];\n+      ia[i+3] = ib[i+1];\n+    }\n+  return 0;\n+}\n+\n+int\n+main (void)\n+{ \n+  return main1 (N-7);\n+}"}]}