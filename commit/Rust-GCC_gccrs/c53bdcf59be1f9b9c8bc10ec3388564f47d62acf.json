{"sha": "c53bdcf59be1f9b9c8bc10ec3388564f47d62acf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzUzYmRjZjU5YmUxZjliOWM4YmMxMGVjMzM4ODU2NGY0N2Q2MmFjZg==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2004-03-13T07:14:12Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2004-03-13T07:14:12Z"}, "message": "re PR target/14567 ([3.4 only] long double and va_arg complex args)\n\n\tPR target/14567\n\t* config/rs6000/rs6000.h (UNITS_PER_ARG, RS6000_ARG_SIZE): Delete.\n\t(HARD_REGNO_MODE_OK): Disallow TFmode for fp31.\n\t* config/rs6000/rs6000.c (rs6000_arg_size): New function.\n\tUpdate all users of RS6000_ARG_SIZE.\n\t(function_arg_advance): Count fregno using mode size.\n\t(function_arg): Handle long double split over regs and memory.\n\t(function_arg_partial_nregs): Likewise.\n\t(rs6000_va_arg): Repackage complex args.\n\nFrom-SVN: r79436", "tree": {"sha": "6203b2eff0f970afb254fb285321946988596d59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6203b2eff0f970afb254fb285321946988596d59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c53bdcf59be1f9b9c8bc10ec3388564f47d62acf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c53bdcf59be1f9b9c8bc10ec3388564f47d62acf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c53bdcf59be1f9b9c8bc10ec3388564f47d62acf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c53bdcf59be1f9b9c8bc10ec3388564f47d62acf/comments", "author": null, "committer": null, "parents": [{"sha": "8b0d605196ebf4556ef13b3a5a62d69f20ed2e36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b0d605196ebf4556ef13b3a5a62d69f20ed2e36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b0d605196ebf4556ef13b3a5a62d69f20ed2e36"}], "stats": {"total": 235, "additions": 162, "deletions": 73}, "files": [{"sha": "33d6149cf8a44fbd92e4030983bf3f5df650b774", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c53bdcf59be1f9b9c8bc10ec3388564f47d62acf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c53bdcf59be1f9b9c8bc10ec3388564f47d62acf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c53bdcf59be1f9b9c8bc10ec3388564f47d62acf", "patch": "@@ -1,3 +1,15 @@\n+2004-03-13  Alan Modra  <amodra@bigpond.net.au>\n+\n+\tPR target/14567\n+\t* config/rs6000/rs6000.h (UNITS_PER_ARG, RS6000_ARG_SIZE): Delete.\n+\t(HARD_REGNO_MODE_OK): Disallow TFmode for fp31.\n+\t* config/rs6000/rs6000.c (rs6000_arg_size): New function.\n+\tUpdate all users of RS6000_ARG_SIZE.\n+\t(function_arg_advance): Count fregno using mode size.\n+\t(function_arg): Handle long double split over regs and memory.\n+\t(function_arg_partial_nregs): Likewise.\n+\t(rs6000_va_arg): Repackage complex args.\n+\n 2004-03-13  Dean Ferreyra <dferreyra@igc.org>\n \n \tPR target/14047\n@@ -54,7 +66,7 @@\n \tthat corresponds to this FDE.\n \t(FRAME_BEGIN_LABEL): Allow target to override default label.\n \t(output_call_frame_info): If FDEs are linknonce, then use extra\n-\tindirection for FDE encoding, output a label for each FDE, and \n+\tindirection for FDE encoding, output a label for each FDE, and\n \toutput an empty label for each function without an FDE.\n \t(dwarf2out_begin_prologue): Set up decl field when creating an FDE.\n \t* varasm.c (globalize_decl): Call ASM_MAKE_LABEL_LINKONCE for\n@@ -114,10 +126,10 @@\n \t* target.h (struct gcc_target): Move calls substructure before\n \tbooleans.  Add split_complex_arg.\n \t* function.c (assign_parms, split_complex_args): Use it.\n-        * calls.c (expand_call): Likewise.\n-        (split_complex_values): Likewise.  Check for splittable types\n-        before allocating memory.\n-        (split_complex_types): Likewise.\n+\t* calls.c (expand_call): Likewise.\n+\t(split_complex_values): Likewise.  Check for splittable types\n+\tbefore allocating memory.\n+\t(split_complex_types): Likewise.\n \t* system.h (SPLIT_COMPLEX_ARGS): Poison.\n \t* expr.h (SPLIT_COMPLEX_ARGS): Remove.\n \t* target-def.h (TARGET_SPLIT_COMPLEX_ARG): New.\n@@ -247,7 +259,7 @@\n \t(set_frame_base_location): Unshare variable if needed.\n \t(set_variable_part): Init the refcount of new variable.\n \tUnshare the variables if needed.\n-\t(delete_variable_part): Unshare the variables if needed. \n+\t(delete_variable_part): Unshare the variables if needed.\n \t(emit_notes_for_differences_1): Init the refcount of new variable.\n \t(vt_add_function_parameters): Do not add function parameters to\n \tIN set of ENTRY_BLOCK_PTR because it is unused anyway.\n@@ -310,7 +322,7 @@\n \tand gt_pch_use_address.\n \t* config/host-linux.c, config/host-solaris.c: New files.\n \t* config/x-linux, config/x-solaris: New files.\n-\t* config/rs6000/host-darwin.c darwin_rs6000_gt_pch_get_address): \n+\t* config/rs6000/host-darwin.c (darwin_rs6000_gt_pch_get_address): \n \tUpdate for changed definition.\n \t(darwin_rs6000_gt_pch_use_address): Likewise.\n \t* doc/hostconfig.texi: Update docs.\n@@ -407,7 +419,7 @@\n \tPR bootstrap/12371\n \t* config/m68k/m68k.h (FIXED_REGISTERS): Add arg pointer.\n \t(CALL_USED_REGISTERS): Likewise.\n-        (REG_CLASS_CONTENTS): Likewise.\n+\t(REG_CLASS_CONTENTS): Likewise.\n \t(REG_ALLOC_ORDER): New.\n \t(REGNO_REG_CLASS): Use regno_reg_class.\n \t* config/m68k/m68k.c: Add regno_reg_class array.\n@@ -2099,7 +2111,7 @@\n \n \t* toplev.c (dump_file_tbl): Rename from dump_file.\n \t* bb-reorder.c, bt-load.c, cfgcleanup.c, cfglayout.c, cfgloopanal.c,\n- \tcfgloopmanip.c, cfgrtl.c, config/arm/arm.c, config/frv/frv.c,\n+\tcfgloopmanip.c, cfgrtl.c, config/arm/arm.c, config/frv/frv.c,\n \tconfig/i386/i386.c, config/ia64/ia64.c, config/mips/mips.c,\n \tconfig/sh/sh.c, cse.c, flow.c, ifcvt.c, loop-iv.c, loop-unroll.c,\n \tloop-unswitch.c, output.h, predict.c, profile.c, ra-build.c,\n@@ -5827,7 +5839,7 @@\n \n 2004-01-31  Paolo Bonzini  <bonzini@gnu.org>\n \n- \t* combine.c (cse_main): Set gen_lowpart to gen_lowpart_for_combine\n+\t* combine.c (cse_main): Set gen_lowpart to gen_lowpart_for_combine\n \tand restore it to gen_lowpart_general on exit.\n \t(gen_lowpart_for_combine): Adjust all callers to go through\n \tgen_lowpart.\n@@ -8109,7 +8121,7 @@\n \n \t* fixinc/inclhack.def (alpha___extern_prefix,\n \talpha___extern_prefix_standards): New hacks to obey\n- \t__PRAGMA_EXTERN_PREFIX.\n+\t__PRAGMA_EXTERN_PREFIX.\n \t* fixinc/tests/base/testing.h [ALPHA___EXTERN_PREFIX_CHECK]: New\n \ttest.\n \t* fixinc/tests/base/standards.h: Likewise."}, {"sha": "56e4e7653cdbf72dc99f746f1aa618bbfe7a563d", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 137, "deletions": 51, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c53bdcf59be1f9b9c8bc10ec3388564f47d62acf/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c53bdcf59be1f9b9c8bc10ec3388564f47d62acf/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=c53bdcf59be1f9b9c8bc10ec3388564f47d62acf", "patch": "@@ -3979,6 +3979,24 @@ function_arg_boundary (enum machine_mode mode, tree type ATTRIBUTE_UNUSED)\n   else\n     return PARM_BOUNDARY;\n }\n+\n+/* Compute the size (in words) of a function argument.  */\n+\n+static unsigned long\n+rs6000_arg_size (enum machine_mode mode, tree type)\n+{\n+  unsigned long size;\n+\n+  if (mode != BLKmode)\n+    size = GET_MODE_SIZE (mode);\n+  else\n+    size = int_size_in_bytes (type);\n+\n+  if (TARGET_32BIT)\n+    return (size + 3) >> 2;\n+  else\n+    return (size + 7) >> 3;\n+}\n \f\n /* Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE.\n@@ -4019,7 +4037,7 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t    align = ((6 - (cum->words & 3)) & 3);\n \t  else\n \t    align = cum->words & 1;\n-\t  cum->words += align + RS6000_ARG_SIZE (mode, type);\n+\t  cum->words += align + rs6000_arg_size (mode, type);\n \t  \n \t  if (TARGET_DEBUG_ARG)\n \t    {\n@@ -4046,7 +4064,7 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t    {\n \t      if (mode == DFmode)\n \t        cum->words += cum->words & 1;\n-\t      cum->words += RS6000_ARG_SIZE (mode, type);\n+\t      cum->words += rs6000_arg_size (mode, type);\n \t    }\n \t}\n       else\n@@ -4059,7 +4077,7 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t      || mode == TFmode)\n \t    n_words = 1;\n \t  else \n-\t    n_words = RS6000_ARG_SIZE (mode, type);\n+\t    n_words = rs6000_arg_size (mode, type);\n \n \t  /* Long long and SPE vectors are put in odd registers.  */\n \t  if (n_words == 2 && (gregno & 1) == 0)\n@@ -4096,11 +4114,11 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       int align = (TARGET_32BIT && (cum->words & 1) != 0\n \t\t   && function_arg_boundary (mode, type) == 64) ? 1 : 0;\n \n-      cum->words += align + RS6000_ARG_SIZE (mode, type);\n+      cum->words += align + rs6000_arg_size (mode, type);\n \n       if (GET_MODE_CLASS (mode) == MODE_FLOAT\n \t  && TARGET_HARD_FLOAT && TARGET_FPRS)\n-\tcum->fregno += (mode == TFmode ? 2 : 1);\n+\tcum->fregno += (GET_MODE_SIZE (mode) + 7) >> 3;\n \n       if (TARGET_DEBUG_ARG)\n \t{\n@@ -4122,7 +4140,7 @@ rs6000_spe_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   if (cum->stdarg)\n     {\n       int gregno = cum->sysv_gregno;\n-      int n_words = RS6000_ARG_SIZE (mode, type);\n+      int n_words = rs6000_arg_size (mode, type);\n \n       /* SPE vectors are put in odd registers.  */\n       if (n_words == 2 && (gregno & 1) == 0)\n@@ -4170,7 +4188,7 @@ rs6000_mixed_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t\t\t\t       gen_rtx_REG (mode,\n \t\t\t\t\t\t\t    cum->fregno),\n \t\t\t\t\t       const0_rtx)));\n-      else if (align_words + RS6000_ARG_SIZE (mode, type)\n+      else if (align_words + rs6000_arg_size (mode, type)\n \t       > GP_ARG_NUM_REG)\n \t/* If this is partially on the stack, then we only\n \t   include the portion actually in registers here.  */\n@@ -4394,13 +4412,13 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t      || mode == TFmode)\n \t    n_words = 1;\n \t  else \n-\t    n_words = RS6000_ARG_SIZE (mode, type);\n+\t    n_words = rs6000_arg_size (mode, type);\n \n \t  /* Long long and SPE vectors are put in odd registers.  */\n \t  if (n_words == 2 && (gregno & 1) == 0)\n \t    gregno += 1;\n \n-\t  /* Long long do not split between registers and stack.  */\n+\t  /* Long long does not split between registers and stack.  */\n \t  if (gregno + n_words - 1 <= GP_ARG_MAX_REG)\n \t    return gen_rtx_REG (mode, gregno);\n \t  else\n@@ -4422,39 +4440,69 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \n       if (USE_FP_FOR_ARG_P (cum, mode, type))\n \t{\n-\t  if (! type\n-\t      || ((cum->nargs_prototype > 0)\n-\t          /* IBM AIX extended its linkage convention definition always\n-\t\t     to require FP args after register save area hole on the\n-\t\t     stack.  */\n-\t          && (DEFAULT_ABI != ABI_AIX\n-\t\t      || ! TARGET_XL_CALL\n-\t\t      || (align_words < GP_ARG_NUM_REG))))\n-\t    return gen_rtx_REG (mode, cum->fregno);\n+\t  rtx fpr[2];\n+\t  rtx *r;\n+\t  bool needs_psave;\n+\t  enum machine_mode fmode = mode;\n+\t  int n;\n+\t  unsigned long n_fpreg = (GET_MODE_SIZE (mode) + 7) >> 3;\n+\n+\t  if (cum->fregno + n_fpreg > FP_ARG_MAX_REG + 1)\n+\t    {\n+\t      /* Long double split over regs and memory.  */\n+\t      if (fmode == TFmode)\n+\t\tfmode = DFmode;\n+\n+\t      /* Currently, we only ever need one reg here because complex\n+\t\t doubles are split.  */\n+\t      if (cum->fregno != FP_ARG_MAX_REG - 1)\n+\t\tabort ();\n+\t    }\n+\t  fpr[1] = gen_rtx_REG (fmode, cum->fregno);\n+\n+\t  /* Do we also need to pass this arg in the parameter save\n+\t     area?  */\n+\t  needs_psave = (type\n+\t\t\t && (cum->nargs_prototype <= 0\n+\t\t\t     || (DEFAULT_ABI == ABI_AIX\n+\t\t\t\t && TARGET_XL_CALL\n+\t\t\t\t && align_words >= GP_ARG_NUM_REG)));\n+\n+\t  if (!needs_psave && mode == fmode)\n+\t    return fpr[1];\n \n           if (TARGET_32BIT && TARGET_POWERPC64\n               && mode == DFmode && cum->stdarg)\n             return rs6000_mixed_function_arg (cum, mode, type, align_words);\n \n-          return gen_rtx_PARALLEL (mode,\n-\t    gen_rtvec (2,\n-\t\t       gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t((align_words >= GP_ARG_NUM_REG)\n-\t\t\t\t ? NULL_RTX\n-\t\t\t\t : (align_words\n-\t\t\t\t    + RS6000_ARG_SIZE (mode, type)\n-\t\t\t\t    > GP_ARG_NUM_REG\n-\t\t\t\t    /* If this is partially on the stack, then\n-\t\t\t\t       we only include the portion actually\n-\t\t\t\t       in registers here.  */\n-\t\t\t\t    ? gen_rtx_REG (Pmode,\n-\t\t\t\t\t       GP_ARG_MIN_REG + align_words)\n-\t\t\t\t    : gen_rtx_REG (mode,\n-\t\t\t\t\t       GP_ARG_MIN_REG + align_words))),\n-\t\t\t\tconst0_rtx),\n-\t\t       gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\tgen_rtx_REG (mode, cum->fregno),\n-\t\t\t\tconst0_rtx)));\n+\t  /* Describe where this piece goes.  */\n+\t  r = fpr + 1;\n+\t  *r = gen_rtx_EXPR_LIST (VOIDmode, *r, const0_rtx);\n+\t  n = 1;\n+\n+\t  if (needs_psave)\n+\t    {\n+\t      /* Now describe the part that goes in gprs or the stack.\n+\t\t This piece must come first, before the fprs.  */\n+\t      rtx reg = NULL_RTX;\n+\t      if (align_words < GP_ARG_NUM_REG)\n+\t\t{\n+\t\t  unsigned long n_words = rs6000_arg_size (mode, type);\n+\t\t  enum machine_mode rmode = mode;\n+\n+\t\t  if (align_words + n_words > GP_ARG_NUM_REG)\n+\t\t    /* If this is partially on the stack, then we only\n+\t\t       include the portion actually in registers here.\n+\t\t       We know this can only be one register because\n+\t\t       complex doubles are splt.  */\n+\t\t    rmode = Pmode;\n+\t\t  reg = gen_rtx_REG (rmode, GP_ARG_MIN_REG + align_words);\n+\t\t}\n+\t      *--r = gen_rtx_EXPR_LIST (VOIDmode, reg, const0_rtx);\n+\t      ++n;\n+\t    }\n+\n+\t  return gen_rtx_PARALLEL (mode, gen_rtvec_v (n, r));\n \t}\n       else if (align_words < GP_ARG_NUM_REG)\n \treturn gen_rtx_REG (mode, GP_ARG_MIN_REG + align_words);\n@@ -4471,27 +4519,31 @@ int\n function_arg_partial_nregs (CUMULATIVE_ARGS *cum, enum machine_mode mode, \n \t\t\t    tree type, int named)\n {\n+  int ret = 0;\n+\n   if (DEFAULT_ABI == ABI_V4)\n     return 0;\n \n-  if (USE_FP_FOR_ARG_P (cum, mode, type)\n-      || USE_ALTIVEC_FOR_ARG_P (cum, mode, type, named))\n+  if (USE_ALTIVEC_FOR_ARG_P (cum, mode, type, named)\n+      && cum->nargs_prototype >= 0)\n+    return 0;\n+\n+  if (USE_FP_FOR_ARG_P (cum, mode, type))\n     {\n-      if (cum->nargs_prototype >= 0)\n+      if (cum->fregno + ((GET_MODE_SIZE (mode) + 7) >> 3) > FP_ARG_MAX_REG + 1)\n+\tret = FP_ARG_MAX_REG - cum->fregno;\n+      else if (cum->nargs_prototype >= 0)\n \treturn 0;\n     }\n \n   if (cum->words < GP_ARG_NUM_REG\n-      && GP_ARG_NUM_REG < (cum->words + RS6000_ARG_SIZE (mode, type)))\n-    {\n-      int ret = GP_ARG_NUM_REG - cum->words;\n-      if (ret && TARGET_DEBUG_ARG)\n-\tfprintf (stderr, \"function_arg_partial_nregs: %d\\n\", ret);\n+      && GP_ARG_NUM_REG < cum->words + rs6000_arg_size (mode, type))\n+    ret = GP_ARG_NUM_REG - cum->words;\n \n-      return ret;\n-    }\n+  if (ret != 0 && TARGET_DEBUG_ARG)\n+    fprintf (stderr, \"function_arg_partial_nregs: %d\\n\", ret);\n \n-  return 0;\n+  return ret;\n }\n \f\n /* A C expression that indicates when an argument must be passed by\n@@ -4597,7 +4649,7 @@ setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       cfun->machine->sysv_varargs_p = 0;\n \n       if (MUST_PASS_IN_STACK (mode, type))\n-\tfirst_reg_offset += RS6000_ARG_SIZE (TYPE_MODE (type), type);\n+\tfirst_reg_offset += rs6000_arg_size (TYPE_MODE (type), type);\n     }\n \n   set = get_varargs_alias_set ();\n@@ -4787,8 +4839,42 @@ rs6000_va_arg (tree valist, tree type)\n \n \t  return expand_expr (t, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n \t}\n-      else\n-\treturn std_expand_builtin_va_arg (valist, type);\n+      if (SPLIT_COMPLEX_ARGS\n+\t  && TREE_CODE (type) == COMPLEX_TYPE)\n+\t{\n+\t  tree elem_type = TREE_TYPE (type);\n+\t  enum machine_mode elem_mode = TYPE_MODE (elem_type);\n+\t  int elem_size = GET_MODE_SIZE (elem_mode);\n+\n+\t  if (elem_size < UNITS_PER_WORD)\n+\t    {\n+\t      rtx real_part, imag_part, dest_real, rr;\n+\n+\t      real_part = rs6000_va_arg (valist, elem_type);\n+\t      imag_part = rs6000_va_arg (valist, elem_type);\n+\n+\t      /* We're not returning the value here, but the address.\n+\t\t real_part and imag_part are not contiguous, and we know\n+\t\t there is space available to pack real_part next to\n+\t\t imag_part.  float _Complex is not promoted to\n+\t\t double _Complex by the default promotion rules that\n+\t\t promote float to double.  */\n+\t      if (2 * elem_size > UNITS_PER_WORD)\n+\t\tabort ();\n+\n+\t      real_part = gen_rtx_MEM (elem_mode, real_part);\n+\t      imag_part = gen_rtx_MEM (elem_mode, imag_part);\n+\n+\t      dest_real = adjust_address (imag_part, elem_mode, -elem_size);\n+\t      rr = gen_reg_rtx (elem_mode);\n+\t      emit_move_insn (rr, real_part);\n+\t      emit_move_insn (dest_real, rr);\n+\n+\t      return XEXP (dest_real, 0);\n+\t    }\n+\t}\n+\n+      return std_expand_builtin_va_arg (valist, type);\n     }\n \n   f_gpr = TYPE_FIELDS (TREE_TYPE (va_list_type_node));"}, {"sha": "bd9d36bb53ec469cf37e6d8cbff22bff47d7f615", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c53bdcf59be1f9b9c8bc10ec3388564f47d62acf/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c53bdcf59be1f9b9c8bc10ec3388564f47d62acf/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=c53bdcf59be1f9b9c8bc10ec3388564f47d62acf", "patch": "@@ -1065,7 +1065,8 @@ extern const char *rs6000_warn_altivec_long_switch;\n   (INT_REGNO_P (REGNO) ?\t\t\t\t\t\t\\\n      INT_REGNO_P (REGNO + HARD_REGNO_NREGS (REGNO, MODE) - 1)\t        \\\n    : FP_REGNO_P (REGNO) ?\t\t\t\t\t\t\\\n-     (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\t\\\n+     ((GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\t\\\n+       && FP_REGNO_P (REGNO + HARD_REGNO_NREGS (REGNO, MODE) - 1))\t\\\n       || (GET_MODE_CLASS (MODE) == MODE_INT\t\t\t\t\\\n \t  && GET_MODE_SIZE (MODE) == UNITS_PER_FP_WORD))\t\t\\\n    : ALTIVEC_REGNO_P (REGNO) ? ALTIVEC_VECTOR_MODE (MODE)\t\t\\\n@@ -1762,16 +1763,6 @@ typedef struct rs6000_args\n   int sysv_gregno;\t\t/* next available GP register */\n } CUMULATIVE_ARGS;\n \n-/* Define intermediate macro to compute the size (in registers) of an argument\n-   for the RS/6000.  */\n-\n-#define UNITS_PER_ARG (TARGET_32BIT ? 4 : 8)\n-\n-#define RS6000_ARG_SIZE(MODE, TYPE)\t\t\t\t\t\\\n-((MODE) != BLKmode\t\t\t\t\t\t\t\\\n- ? (GET_MODE_SIZE (MODE) + (UNITS_PER_ARG - 1)) / UNITS_PER_ARG\t\t\\\n- : (int_size_in_bytes (TYPE) + (UNITS_PER_ARG - 1)) / UNITS_PER_ARG)\n-\n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n    For a library call, FNTYPE is 0.  */"}]}