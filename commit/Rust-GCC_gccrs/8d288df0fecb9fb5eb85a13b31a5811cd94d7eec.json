{"sha": "8d288df0fecb9fb5eb85a13b31a5811cd94d7eec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQyODhkZjBmZWNiOWZiNWViODVhMTNiMzFhNTgxMWNkOTRkN2VlYw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2006-05-13T17:58:50Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2006-05-13T17:58:50Z"}, "message": "sources.am, [...]: Rebuilt.\n\n\t* sources.am, Makefile.in: Rebuilt.\n\t* gnu/java/net/protocol/jar/Connection.java: Removed.\n\t* java/net/JarURLConnection.java: Removed.\n\nFrom-SVN: r113739", "tree": {"sha": "ae52b470fddfcc1ddd9c283f2dc261be86492a57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae52b470fddfcc1ddd9c283f2dc261be86492a57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d288df0fecb9fb5eb85a13b31a5811cd94d7eec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d288df0fecb9fb5eb85a13b31a5811cd94d7eec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d288df0fecb9fb5eb85a13b31a5811cd94d7eec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d288df0fecb9fb5eb85a13b31a5811cd94d7eec/comments", "author": null, "committer": null, "parents": [{"sha": "793da155cd7d8a61a7bcfd327d9b95200fa6536c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/793da155cd7d8a61a7bcfd327d9b95200fa6536c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/793da155cd7d8a61a7bcfd327d9b95200fa6536c"}], "stats": {"total": 599, "additions": 18, "deletions": 581}, "files": [{"sha": "1df0977249324c579baac560bca3f25ba3b9f121", "filename": "libjava/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d288df0fecb9fb5eb85a13b31a5811cd94d7eec/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d288df0fecb9fb5eb85a13b31a5811cd94d7eec/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=8d288df0fecb9fb5eb85a13b31a5811cd94d7eec", "patch": "@@ -1,3 +1,9 @@\n+2006-05-13  Tom Tromey  <tromey@redhat.com>\n+\n+\t* sources.am, Makefile.in: Rebuilt.\n+\t* gnu/java/net/protocol/jar/Connection.java: Removed.\n+\t* java/net/JarURLConnection.java: Removed.\n+\n 2006-05-13  Tom Tromey  <tromey@redhat.com>\n \n \t* include/java-interp.h (_Jv_InterpMethod::dump_object): Removed"}, {"sha": "3089e1780055419a1bdad1678765b8c94be33b29", "filename": "libjava/Makefile.in", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d288df0fecb9fb5eb85a13b31a5811cd94d7eec/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d288df0fecb9fb5eb85a13b31a5811cd94d7eec/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=8d288df0fecb9fb5eb85a13b31a5811cd94d7eec", "patch": "@@ -1,8 +1,8 @@\n-# Makefile.in generated by automake 1.9.6 from Makefile.am.\n+# Makefile.in generated by automake 1.9.3 from Makefile.am.\n # @configure_input@\n \n # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-# 2003, 2004, 2005  Free Software Foundation, Inc.\n+# 2003, 2004  Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n@@ -17,6 +17,8 @@\n \n \n \n+SOURCES = $(lib_gnu_awt_xlib_la_SOURCES) $(lib_gnu_java_awt_peer_gtk_la_SOURCES) $(lib_gnu_java_awt_peer_qt_la_SOURCES) $(libgcj_la_SOURCES) $(libgcjawt_la_SOURCES) $(libgij_la_SOURCES) $(gcj_dbtool_SOURCES) $(gen_from_JIS_SOURCES) $(gij_SOURCES) $(grmic_SOURCES) $(grmiregistry_SOURCES) $(jv_convert_SOURCES)\n+\n srcdir = @srcdir@\n top_srcdir = @top_srcdir@\n VPATH = @srcdir@\n@@ -1709,7 +1711,7 @@ classpath/gnu/java/net/protocol/https/Handler.java\n \n gnu_java_net_protocol_https_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(gnu_java_net_protocol_https_source_files)))\n gnu_java_net_protocol_jar_source_files = \\\n-gnu/java/net/protocol/jar/Connection.java \\\n+classpath/gnu/java/net/protocol/jar/Connection.java \\\n classpath/gnu/java/net/protocol/jar/Handler.java\n \n gnu_java_net_protocol_jar_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(gnu_java_net_protocol_jar_source_files)))\n@@ -3718,7 +3720,7 @@ classpath/java/net/Inet4Address.java \\\n classpath/java/net/Inet6Address.java \\\n java/net/InetAddress.java \\\n classpath/java/net/InetSocketAddress.java \\\n-java/net/JarURLConnection.java \\\n+classpath/java/net/JarURLConnection.java \\\n classpath/java/net/MalformedURLException.java \\\n classpath/java/net/MimeTypeMapper.java \\\n classpath/java/net/MulticastSocket.java \\\n@@ -7992,13 +7994,7 @@ uninstall-toolexecmainlibDATA:\n #     (which will cause the Makefiles to be regenerated when you run `make');\n # (2) otherwise, pass the desired values on the `make' command line.\n $(RECURSIVE_TARGETS):\n-\t@failcom='exit 1'; \\\n-\tfor f in x $$MAKEFLAGS; do \\\n-\t  case $$f in \\\n-\t    *=* | --[!k]*);; \\\n-\t    *k*) failcom='fail=yes';; \\\n-\t  esac; \\\n-\tdone; \\\n+\t@set fnord $$MAKEFLAGS; amf=$$2; \\\n \tdot_seen=no; \\\n \ttarget=`echo $@ | sed s/-recursive//`; \\\n \tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n@@ -8010,21 +8006,15 @@ $(RECURSIVE_TARGETS):\n \t    local_target=\"$$target\"; \\\n \t  fi; \\\n \t  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n-\t  || eval $$failcom; \\\n+\t   || case \"$$amf\" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \\\n \tdone; \\\n \tif test \"$$dot_seen\" = \"no\"; then \\\n \t  $(MAKE) $(AM_MAKEFLAGS) \"$$target-am\" || exit 1; \\\n \tfi; test -z \"$$fail\"\n \n mostlyclean-recursive clean-recursive distclean-recursive \\\n maintainer-clean-recursive:\n-\t@failcom='exit 1'; \\\n-\tfor f in x $$MAKEFLAGS; do \\\n-\t  case $$f in \\\n-\t    *=* | --[!k]*);; \\\n-\t    *k*) failcom='fail=yes';; \\\n-\t  esac; \\\n-\tdone; \\\n+\t@set fnord $$MAKEFLAGS; amf=$$2; \\\n \tdot_seen=no; \\\n \tcase \"$@\" in \\\n \t  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \\\n@@ -8045,7 +8035,7 @@ maintainer-clean-recursive:\n \t    local_target=\"$$target\"; \\\n \t  fi; \\\n \t  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n-\t  || eval $$failcom; \\\n+\t   || case \"$$amf\" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \\\n \tdone && test -z \"$$fail\"\n tags-recursive:\n \tlist='$(SUBDIRS)'; for subdir in $$list; do \\"}, {"sha": "34df18354e8928a6e5747ab4ed7e311d0c698560", "filename": "libjava/gnu/java/net/protocol/jar/Connection.java", "status": "removed", "additions": 0, "deletions": 292, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/793da155cd7d8a61a7bcfd327d9b95200fa6536c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fjar%2FConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/793da155cd7d8a61a7bcfd327d9b95200fa6536c/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fjar%2FConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fjar%2FConnection.java?ref=793da155cd7d8a61a7bcfd327d9b95200fa6536c", "patch": "@@ -1,292 +0,0 @@\n-/* Connection - jar url connection for java.net\n-   Copyright (C) 1999, 2002, 2003, 2005 Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n- \n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-\n-package gnu.java.net.protocol.jar;\n-\n-import java.io.BufferedInputStream;\n-import java.io.ByteArrayInputStream;\n-import java.io.File;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.net.JarURLConnection;\n-import java.net.MalformedURLException;\n-import java.net.ProtocolException;\n-import java.net.URL;\n-import java.net.URLConnection;\n-import java.text.SimpleDateFormat;\n-import java.util.Date;\n-import java.util.HashMap;\n-import java.util.Hashtable;\n-import java.util.Locale;\n-import java.util.jar.JarEntry;\n-import java.util.jar.JarFile;\n-import java.util.jar.JarInputStream;\n-import java.util.zip.ZipEntry;\n-import java.util.zip.ZipFile;\n-\n-/**\n- * This subclass of java.net.JarURLConnection models a URLConnection via\n- * the \"jar\" protocol.\n- *\n- * @author Kresten Krab Thorup (krab@gnu.org)\n- */\n-public final class Connection extends JarURLConnection\n-{\n-  private static Hashtable file_cache = new Hashtable();\n-\n-  /**\n-   * HTTP-style DateFormat, used to format the last-modified header.\n-   */\n-  private static SimpleDateFormat dateFormat\n-    = new SimpleDateFormat(\"EEE, dd MMM yyyy hh:mm:ss 'GMT'\",\n-                           new Locale (\"En\", \"Us\", \"Unix\"));\n-\n-  private JarFile jar_file;\n-\n-  /**\n-   * Cached JarURLConnection objects.\n-   */\n-  static HashMap connectionCache = new HashMap();\n-\n-  protected Connection(URL url)\n-    throws MalformedURLException\n-  {\n-    super(url);\n-  }\n-\n-  public synchronized void connect() throws IOException\n-  {\n-    // Call is ignored if already connected.\n-    if (connected)\n-      return;\n-\n-    if (getUseCaches())\n-      {\n-\tjarFileURLConnection =\n-          (URLConnection) connectionCache.get(getJarFileURL());\n-\n-\tif (jarFileURLConnection == null)\n-\t  {\n-\t    jarFileURLConnection = getJarFileURL().openConnection();\n-\t    jarFileURLConnection.setUseCaches(true);\n-\t    jarFileURLConnection.connect();\n-\t    connectionCache.put(getJarFileURL(), jarFileURLConnection);\n-\t  }\n-      }\n-    else\n-      {\n-\tjarFileURLConnection = getJarFileURL().openConnection();\n-\tjarFileURLConnection.connect();\n-      }\n-\n-    connected = true;\n-  }\n-\n-  public InputStream getInputStream() throws IOException\n-  {\n-    if (!connected)\n-      connect();\n-\n-    if (! doInput)\n-      throw new ProtocolException(\"Can't open InputStream if doInput is false\");\n-\n-    if (getEntryName() == null)\n-      {\n-\t// This is a JarURLConnection for the entire jar file.  \n-\n-\tInputStream in = new BufferedInputStream\n-\t  (jarFileURLConnection.getInputStream());\n-\treturn new JarInputStream(in);\n-      }\n-\n-    // Reaching this point, we're looking for an entry of a jar file.\n-\n-    JarFile jarfile = null;\n-\n-    try\n-      {\n-\tjarfile = getJarFile ();\n-      }\n-    catch (IOException x)\n-      {\n-\t/* ignore */\n-      }\n-    \n-    if (jarfile != null)\n-      {\n-\t// this is the easy way...\n-\tZipEntry entry = jarfile.getEntry\n-\t  (gnu.java.net.protocol.file.Connection.unquote(getEntryName()));\n-        \n-\tif (entry != null)\n-\t  return jarfile.getInputStream (entry);\n-\telse\n-\t  return null;\n-      }\n-    else\n-      {\n-\t// If the jar file is not local, ...\n-\tJarInputStream zis = new JarInputStream(\n-\t\t\tjarFileURLConnection.getInputStream ());\n-\n-\tString entryName = gnu.java.net.protocol.file.Connection.unquote(getEntryName());\n-\n-\t// This is hideous, we're doing a linear search...\n-\tfor (ZipEntry entry = zis.getNextEntry(); \n-\t     entry != null; \n-\t     entry = zis.getNextEntry())\n-\t  {\n-\t    if (entryName.equals(entry.getName()))\n-\t      {\n-\t\tint size = (int) entry.getSize();\n-\t\tbyte[] data = new byte[size];\n-\t\tzis.read (data, 0, size);\n-\t\treturn new ByteArrayInputStream (data);\n-\t      }\n-\t  }\n-      }\n-\n-    return null;\n-  }\n-\n-  public synchronized JarFile getJarFile() throws IOException\n-  {\n-    if (!connected)\n-      connect();\n-\n-    if (! doInput)\n-      throw new ProtocolException(\"Can't open JarFile if doInput is false\");\n-\n-    if (jar_file != null)\n-      return jar_file;\n-\n-    URL jarFileURL = getJarFileURL();\n-\n-    if (jarFileURL.getProtocol().equals (\"file\")\n-\t&& jarFileURL.getHost().equals (\"\"))\n-      {\n-\tif (getUseCaches())\n-\t  {\n-\t    jar_file = (JarFile) file_cache.get (jarFileURL);\n-\t    if (jar_file == null)\n-\t      {\n-\t\tjar_file = new JarFile \n-\t\t  (gnu.java.net.protocol.file.Connection.unquote(jarFileURL.getFile()));\n-\t\tfile_cache.put (jarFileURL, jar_file);\n-\t      }\n-\t  }\n-\telse\n-\t  jar_file = new JarFile \n-\t    (gnu.java.net.protocol.file.Connection.unquote(jarFileURL.getFile()));\n-      }\n-    else\n-      {\n-\tURLConnection urlconn = jarFileURL.openConnection();\n-\tInputStream is = urlconn.getInputStream();\n-\tbyte[] buf = new byte[4*1024];\n-\tFile f = File.createTempFile(\"cache\", \"jar\");\n-\tFileOutputStream fos = new FileOutputStream(f);\n-\tint len = 0;\n-\twhile ((len = is.read(buf)) != -1)\n-\t  fos.write(buf, 0, len);\n-        fos.close();\n-\t// Always verify the Manifest, open read only and delete when done.\n-\tjar_file = new JarFile (f, true,\n-\t\t\t\tZipFile.OPEN_READ | ZipFile.OPEN_DELETE);\n-      }\n-\n-    return jar_file;\n-  }\n-\n-  public String getHeaderField(String field)\n-  {\n-    try\n-      {\n-\tif (!connected)\n-\t  connect();\n-\n-\tif (field.equals(\"content-type\"))\n-          return guessContentTypeFromName(getJarEntry().getName());\n-\telse if (field.equals(\"content-length\"))\n-          return Long.toString(getJarEntry().getSize());\n-\telse if (field.equals(\"last-modified\"))\n-\t  {\n-\t    synchronized (dateFormat)\n-\t      {\n-        \treturn dateFormat.format(new Date(getJarEntry().getTime()));\n-\t      }\n-\t  }\n-      }\n-    catch (IOException e)\n-      {\n-        // Fall through.\n-      }\n-    return null;\n-  }\n-\n-  public int getContentLength()\n-  {\n-    if (!connected)\n-      return -1;\n-\n-    try\n-      {\n-        return (int) getJarEntry().getSize();\n-      }\n-    catch (IOException e)\n-      {\n-\treturn -1;\n-      }\n-  }\n-\n-  public long getLastModified()\n-  {\n-    if (!connected)\n-      return -1;\n-\n-    try\n-      {\n-\treturn getJarEntry().getTime();\n-      }\n-    catch (IOException e)\n-      {\n-\treturn -1;\n-      }\n-  }\n-}"}, {"sha": "9b87e8f83c20ea06e484ae87a75ef76e3127b519", "filename": "libjava/java/net/JarURLConnection.java", "status": "removed", "additions": 0, "deletions": 267, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/793da155cd7d8a61a7bcfd327d9b95200fa6536c/libjava%2Fjava%2Fnet%2FJarURLConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/793da155cd7d8a61a7bcfd327d9b95200fa6536c/libjava%2Fjava%2Fnet%2FJarURLConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FJarURLConnection.java?ref=793da155cd7d8a61a7bcfd327d9b95200fa6536c", "patch": "@@ -1,267 +0,0 @@\n-/* JarURLConnection.java -- Class for manipulating remote jar files\n-   Copyright (C) 1998, 2002, 2003 Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-package java.net;\n-\n-import java.io.IOException;\n-import java.security.cert.Certificate;\n-import java.util.jar.Attributes;\n-import java.util.jar.JarEntry;\n-import java.util.jar.JarFile;\n-import java.util.jar.JarInputStream;\n-import java.util.jar.Manifest;\n-import java.util.zip.ZipEntry;\n-\n-\n-/**\n- * This abstract class represents a common superclass for implementations\n- * of jar URL's.  A jar URL is a special type of URL that allows JAR\n- * files on remote systems to be accessed.  It has the form:\n- * <p>\n- * jar:&lt;standard URL pointing to jar filei&gt;!/file/within/jarfile\n- * <p> for example:\n- * <p>\n- * jar:http://www.urbanophile.com/java/foo.jar!/com/urbanophile/bar.class\n- * <p>\n- * That example URL points to the file /com/urbanophile/bar.class in the\n- * remote JAR file http://www.urbanophile.com/java/foo.jar.  The HTTP\n- * protocol is used only as an example.  Any supported remote protocol\n- * can be used.\n- * <p>\n- * This class currently works by retrieving the entire jar file into a\n- * local cache file, then performing standard jar operations on it.\n- * (At least this is true for the default protocol implementation).\n- *\n- * @author Aaron M. Renn (arenn@urbanophile.com)\n- * @author Kresten Krab Thorup (krab@gnu.org)\n- * @date Aug 10, 1999.\n- *\n- * @since 1.2\n- */\n-public abstract class JarURLConnection extends URLConnection\n-{\n-  /**\n-   * This is the actual URL that points the remote jar file.  This is parsed\n-   * out of the jar URL by the constructor.\n-   */\n-  private final URL jarFileURL;\n-\n-  /**\n-   * The connection to the jar file itself. A JarURLConnection\n-   * can represent an entry in a jar file or an entire jar file.  In\n-   * either case this describes just the jar file itself.\n-   */\n-  protected URLConnection jarFileURLConnection;\n-\n-  /**\n-   * This is the jar file \"entry name\" or portion after the \"!/\" in the\n-   * URL which represents the pathname inside the actual jar file.\n-   */\n-  private final String entryName;\n-\n-  /**\n-   * Creates a JarURLConnection from an URL object\n-   *\n-   * @param url The URL object for this connection.\n-   *\n-   * @exception MalformedURLException If url is invalid\n-   *\n-   * @specnote This constructor is protected since JDK 1.4\n-   */\n-  protected JarURLConnection(URL url) throws MalformedURLException\n-  {\n-    super(url);\n-\n-    if (! url.getProtocol().equals(\"jar\"))\n-      throw new MalformedURLException(url + \": Not jar protocol.\");\n-\n-    String spec = url.getFile();\n-    int bang = spec.indexOf(\"!/\");\n-    if (bang == -1)\n-      throw new MalformedURLException(url + \": No `!/' in spec.\");\n-\n-    // Extract the url for the jar itself.\n-    jarFileURL = new URL(spec.substring(0, bang));\n-\n-    // Get the name of the entry, if any.\n-    entryName = spec.length() == (bang + 2) ? null : spec.substring(bang + 2);\n-  }\n-\n-  /**\n-   * This method returns the \"real\" URL where the JarFile is located.\n-   * //****Is this right?*****\n-   *\n-   * @return The remote URL\n-   */\n-  public URL getJarFileURL()\n-  {\n-    return jarFileURL;\n-  }\n-\n-  /**\n-   * Returns the \"entry name\" portion of the jar URL.  This is the portion\n-   * after the \"!/\" in the jar URL that represents the pathname inside the\n-   * actual jar file.\n-   *\n-   * @return The entry name.\n-   */\n-  public String getEntryName()\n-  {\n-    return entryName;\n-  }\n-\n-  /**\n-   * Returns the entry in this jar file specified by the URL.\n-   *\n-   * @return The jar entry\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public JarEntry getJarEntry() throws IOException\n-  {\n-    JarFile jarfile = null;\n-\n-    if (entryName == null)\n-      return null;\n-\n-    if (! doInput)\n-      throw new ProtocolException(\"Can't open JarEntry if doInput is false\");\n-\n-    try\n-      {\n-\tjarfile = getJarFile ();\n-      }\n-    catch (IOException x)\n-      {\n-\t/* ignore */\n-      }\n-    \n-    if (jarfile == null)\n-      {\n-\tJarInputStream zis = new JarInputStream(\n-\t\t\tjarFileURLConnection.getInputStream ());\n-\n-\t// This is hideous, we're doing a linear search for the thing...\n-\tfor (ZipEntry ent = zis.getNextEntry (); \n-\t     ent != null; \n-\t     ent = zis.getNextEntry ())\n-\t  {\n-\t    if (entryName.equals (ent.getName()))\n-\t      {\n-\t\treturn new JarEntry (ent);\n-\t      }\n-\t  }\n-      }\n-\n-    else\n-      {\n-\treturn jarfile.getJarEntry (entryName);\n-      }\n-\n-    return null;\n-  }\n-\n-  /**\n-   * Returns a read-only JarFile object for the remote jar file\n-   *\n-   * @return The JarFile object\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public abstract JarFile getJarFile() throws IOException;\n-\n-  /**\n-   * Returns an array of Certificate objects for the jar file entry specified\n-   * by this URL or null if there are none\n-   *\n-   * @return A Certificate array\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public Certificate[] getCertificates() throws IOException\n-  {\n-    JarEntry entry = getJarEntry();\n-\n-    return entry != null ? entry.getCertificates() : null;\n-  }\n-\n-  /**\n-   * Returns the main Attributes for the jar file specified in the URL or\n-   * null if there are none\n-   *\n-   * @return The main Attributes for the JAR file for this connection\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public Attributes getMainAttributes() throws IOException\n-  {\n-    Manifest manifest = getManifest();\n-\n-    return manifest != null ? manifest.getMainAttributes() : null;\n-  }\n-\n-  /**\n-   * Returns the Attributes for the Jar entry specified by the URL or null\n-   * if none\n-   *\n-   * @return The Attributes object for this connection if the URL for it points\n-   * to a JAR file entry, null otherwise\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public Attributes getAttributes() throws IOException\n-  {\n-    JarEntry entry = getJarEntry();\n-\n-    return entry != null ? entry.getAttributes() : null;\n-  }\n-\n-  /**\n-   * Returns a Manifest object for this jar file, or null if there is no\n-   * manifest.\n-   *\n-   * @return The Manifest for this connection, or null if none\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public Manifest getManifest() throws IOException\n-  {\n-    JarFile file = getJarFile();\n-\n-    return file != null ? file.getManifest() : null;\n-  }\n-}"}, {"sha": "f47d594efc26cc48357c6dd1322acde933f651b8", "filename": "libjava/sources.am", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d288df0fecb9fb5eb85a13b31a5811cd94d7eec/libjava%2Fsources.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d288df0fecb9fb5eb85a13b31a5811cd94d7eec/libjava%2Fsources.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsources.am?ref=8d288df0fecb9fb5eb85a13b31a5811cd94d7eec", "patch": "@@ -1290,7 +1290,7 @@ gnu/java/net/protocol/https.list: $(gnu_java_net_protocol_https_source_files)\n \n \n gnu_java_net_protocol_jar_source_files = \\\n-gnu/java/net/protocol/jar/Connection.java \\\n+classpath/gnu/java/net/protocol/jar/Connection.java \\\n classpath/gnu/java/net/protocol/jar/Handler.java\n \n gnu_java_net_protocol_jar_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(gnu_java_net_protocol_jar_source_files)))\n@@ -4394,7 +4394,7 @@ classpath/java/net/Inet4Address.java \\\n classpath/java/net/Inet6Address.java \\\n java/net/InetAddress.java \\\n classpath/java/net/InetSocketAddress.java \\\n-java/net/JarURLConnection.java \\\n+classpath/java/net/JarURLConnection.java \\\n classpath/java/net/MalformedURLException.java \\\n classpath/java/net/MimeTypeMapper.java \\\n classpath/java/net/MulticastSocket.java \\"}]}