{"sha": "aa46c8a3df0de8053cd0f3b43dbe7fd47a8c8aff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE0NmM4YTNkZjBkZTgwNTNjZDBmM2I0M2RiZTdmZDQ3YThjOGFmZg==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2007-10-17T05:35:13Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2007-10-17T05:35:13Z"}, "message": "tree-ssa-structalias.c (rewrite_constraints): Don't test for directness anymore.\n\n2007-10-17  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* tree-ssa-structalias.c (rewrite_constraints): Don't test for\n\tdirectness anymore.\n\t(perform_var_substitution): Only DFS from real nodes. Don't test\n\tfor directness.\n\t(unite_pointer_equivalences): Fix broken test.\n\nFrom-SVN: r129401", "tree": {"sha": "770656ae6502e8c44c105b732f96fd4e559914c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/770656ae6502e8c44c105b732f96fd4e559914c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa46c8a3df0de8053cd0f3b43dbe7fd47a8c8aff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa46c8a3df0de8053cd0f3b43dbe7fd47a8c8aff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa46c8a3df0de8053cd0f3b43dbe7fd47a8c8aff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa46c8a3df0de8053cd0f3b43dbe7fd47a8c8aff/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "45b194f8db9ea93a5b91d6f2618e04bf0b9d7161", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45b194f8db9ea93a5b91d6f2618e04bf0b9d7161", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45b194f8db9ea93a5b91d6f2618e04bf0b9d7161"}], "stats": {"total": 120, "additions": 63, "deletions": 57}, "files": [{"sha": "b2e3272e1b0e30e7d989d13c67446e211b21f5ef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa46c8a3df0de8053cd0f3b43dbe7fd47a8c8aff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa46c8a3df0de8053cd0f3b43dbe7fd47a8c8aff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aa46c8a3df0de8053cd0f3b43dbe7fd47a8c8aff", "patch": "@@ -1,3 +1,11 @@\n+2007-10-17  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* tree-ssa-structalias.c (rewrite_constraints): Don't test for\n+\tdirectness anymore.\n+\t(perform_var_substitution): Only DFS from real nodes. Don't test\n+\tfor directness.\n+\t(unite_pointer_equivalences): Fix broken test.\n+\n 2007-10-17  Alan Modra  <amodra@bigpond.net.au>\n \n \t* config/rs6000/rs6000.c (rs6000_emit_epilogue): Correct"}, {"sha": "a99839c7e8443fa051d74b62f59d304c26093bd4", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 55, "deletions": 57, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa46c8a3df0de8053cd0f3b43dbe7fd47a8c8aff/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa46c8a3df0de8053cd0f3b43dbe7fd47a8c8aff/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=aa46c8a3df0de8053cd0f3b43dbe7fd47a8c8aff", "patch": "@@ -461,8 +461,10 @@ struct constraint_graph\n      variable substitution.  */\n   int *eq_rep;\n \n-  /* Pointer equivalence node for a node.  if pe[a] != a, then node a\n-     can be united with node pe[a] after initial constraint building.  */\n+  /* Pointer equivalence label for a node.  All nodes with the same\n+     pointer equivalence label can be unified together at some point\n+     (either during constraint optimization or after the constraint\n+     graph is built).  */\n   unsigned int *pe;\n \n   /* Pointer equivalence representative for a label.  This is used to\n@@ -969,13 +971,12 @@ init_graph (unsigned int size)\n   graph->indirect_cycles = XNEWVEC (int, graph->size);\n   graph->rep = XNEWVEC (unsigned int, graph->size);\n   graph->complex = XCNEWVEC (VEC(constraint_t, heap) *, size);\n-  graph->pe = XNEWVEC (unsigned int, graph->size);\n+  graph->pe = XCNEWVEC (unsigned int, graph->size);\n   graph->pe_rep = XNEWVEC (int, graph->size);\n \n   for (j = 0; j < graph->size; j++)\n     {\n       graph->rep[j] = j;\n-      graph->pe[j] = j;\n       graph->pe_rep[j] = -1;\n       graph->indirect_cycles[j] = -1;\n     }\n@@ -1276,28 +1277,29 @@ unify_nodes (constraint_graph_t graph, unsigned int to, unsigned int from,\n \t  changed_count--;\n \t}\n     }\n-\n-  /* If the solution changes because of the merging, we need to mark\n-     the variable as changed.  */\n-  if (bitmap_ior_into (get_varinfo (to)->solution,\n-\t\t       get_varinfo (from)->solution))\n+  if (get_varinfo (from)->solution)\n     {\n-      if (update_changed && !TEST_BIT (changed, to))\n+      /* If the solution changes because of the merging, we need to mark\n+\t the variable as changed.  */\n+      if (bitmap_ior_into (get_varinfo (to)->solution,\n+\t\t\t   get_varinfo (from)->solution))\n \t{\n-\t  SET_BIT (changed, to);\n-\t  changed_count++;\n+\t  if (update_changed && !TEST_BIT (changed, to))\n+\t    {\n+\t      SET_BIT (changed, to);\n+\t      changed_count++;\n+\t    }\n+\t}\n+      \n+      BITMAP_FREE (get_varinfo (from)->solution);\n+      BITMAP_FREE (get_varinfo (from)->oldsolution);\n+      \n+      if (stats.iterations > 0)\n+\t{\n+\t  BITMAP_FREE (get_varinfo (to)->oldsolution);\n+\t  get_varinfo (to)->oldsolution = BITMAP_ALLOC (&oldpta_obstack);\n \t}\n     }\n-\n-  BITMAP_FREE (get_varinfo (from)->solution);\n-  BITMAP_FREE (get_varinfo (from)->oldsolution);\n-\n-  if (stats.iterations > 0)\n-    {\n-      BITMAP_FREE (get_varinfo (to)->oldsolution);\n-      get_varinfo (to)->oldsolution = BITMAP_ALLOC (&oldpta_obstack);\n-    }\n-\n   if (valid_graph_edge (graph, to, to))\n     {\n       if (graph->succs[to])\n@@ -1942,13 +1944,13 @@ perform_var_substitution (constraint_graph_t graph)\n \n   /* Condense the nodes, which means to find SCC's, count incoming\n      predecessors, and unite nodes in SCC's.  */\n-  for (i = 0; i < LAST_REF_NODE; i++)\n+  for (i = 0; i < FIRST_REF_NODE; i++)\n     if (!TEST_BIT (si->visited, si->node_mapping[i]))\n       condense_visit (graph, si, si->node_mapping[i]);\n \n   sbitmap_zero (si->visited);\n   /* Actually the label the nodes for pointer equivalences  */\n-  for (i = 0; i < LAST_REF_NODE; i++)\n+  for (i = 0; i < FIRST_REF_NODE; i++)\n     if (!TEST_BIT (si->visited, si->node_mapping[i]))\n       label_visit (graph, si, si->node_mapping[i]);\n \n@@ -2014,8 +2016,7 @@ perform_var_substitution (constraint_graph_t graph)\n     {\n       unsigned int node = si->node_mapping[i];\n \n-      if (graph->pointer_label[node] == 0\n-\t  && TEST_BIT (graph->direct_nodes, node))\n+      if (graph->pointer_label[node] == 0)\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file,\n@@ -2100,13 +2101,20 @@ unite_pointer_equivalences (constraint_graph_t graph)\n \n   /* Go through the pointer equivalences and unite them to their\n      representative, if they aren't already.  */\n-  for (i = 0; i < graph->size; i++)\n+  for (i = 0; i < FIRST_REF_NODE; i++)\n     {\n       unsigned int label = graph->pe[i];\n-      int label_rep = graph->pe_rep[label];\n-\n-      if (label != i && unite (label_rep, i))\n-\tunify_nodes (graph, label_rep, i, false);\n+      if (label)\n+\t{\n+\t  int label_rep = graph->pe_rep[label];\n+\t  \n+\t  if (label_rep == -1)\n+\t    continue;\n+\t  \n+\t  label_rep = find (label_rep);\n+\t  if (label_rep >= 0 && unite (label_rep, find (i)))\n+\t    unify_nodes (graph, label_rep, i, false);\n+\t}\n     }\n }\n \n@@ -2177,40 +2185,30 @@ rewrite_constraints (constraint_graph_t graph,\n \t the constraint.  */\n       if (lhslabel == 0)\n \t{\n-\t  if (!TEST_BIT (graph->direct_nodes, lhsnode))\n-\t    lhslabel = graph->pointer_label[lhsnode] = pointer_equiv_class++;\n-\t  else\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t{\n-\n-\t\t  fprintf (dump_file, \"%s is a non-pointer variable,\"\n-\t\t\t   \"ignoring constraint:\",\n-\t\t\t   get_varinfo (lhs.var)->name);\n-\t\t  dump_constraint (dump_file, c);\n-\t\t}\n-\t      VEC_replace (constraint_t, constraints, i, NULL);\n-\t      continue;\n+\t      \n+\t      fprintf (dump_file, \"%s is a non-pointer variable,\"\n+\t\t       \"ignoring constraint:\",\n+\t\t       get_varinfo (lhs.var)->name);\n+\t      dump_constraint (dump_file, c);\n \t    }\n+\t  VEC_replace (constraint_t, constraints, i, NULL);\n+\t  continue;\n \t}\n \n       if (rhslabel == 0)\n \t{\n-\t  if (!TEST_BIT (graph->direct_nodes, rhsnode))\n-\t    rhslabel = graph->pointer_label[rhsnode] = pointer_equiv_class++;\n-\t  else\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t{\n-\n-\t\t  fprintf (dump_file, \"%s is a non-pointer variable,\"\n-\t\t\t   \"ignoring constraint:\",\n-\t\t\t   get_varinfo (rhs.var)->name);\n-\t\t  dump_constraint (dump_file, c);\n-\t\t}\n-\t      VEC_replace (constraint_t, constraints, i, NULL);\n-\t      continue;\n+\t      \n+\t      fprintf (dump_file, \"%s is a non-pointer variable,\"\n+\t\t       \"ignoring constraint:\",\n+\t\t       get_varinfo (rhs.var)->name);\n+\t      dump_constraint (dump_file, c);\n \t    }\n+\t  VEC_replace (constraint_t, constraints, i, NULL);\n+\t  continue;\n \t}\n \n       lhsvar = find_equivalent_node (graph, lhsvar, lhslabel);"}]}