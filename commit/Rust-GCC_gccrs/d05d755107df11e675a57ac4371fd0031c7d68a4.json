{"sha": "d05d755107df11e675a57ac4371fd0031c7d68a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDA1ZDc1NTEwN2RmMTFlNjc1YTU3YWM0MzcxZmQwMDMxYzdkNjhhNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-20T12:53:23Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-20T12:53:23Z"}, "message": "poly_int: MEM_OFFSET and MEM_SIZE\n\nThis patch changes the MEM_OFFSET and MEM_SIZE memory attributes\nfrom HOST_WIDE_INT to poly_int64.  Most of it is mechanical,\nbut there is one nonbovious change in widen_memory_access.\nPreviously the main while loop broke with:\n\n      /* Similarly for the decl.  */\n      else if (DECL_P (attrs.expr)\n               && DECL_SIZE_UNIT (attrs.expr)\n               && TREE_CODE (DECL_SIZE_UNIT (attrs.expr)) == INTEGER_CST\n               && compare_tree_int (DECL_SIZE_UNIT (attrs.expr), size) >= 0\n               && (! attrs.offset_known_p || attrs.offset >= 0))\n        break;\n\nbut it seemed wrong to optimistically assume the best case\nwhen the offset isn't known (and thus might be negative).\nAs it happens, the \"! attrs.offset_known_p\" condition was\nalways false, because we'd already nullified attrs.expr in\nthat case:\n\n  /* If we don't know what offset we were at within the expression, then\n     we can't know if we've overstepped the bounds.  */\n  if (! attrs.offset_known_p)\n    attrs.expr = NULL_TREE;\n\nThe patch therefore drops \"! attrs.offset_known_p ||\" when\nconverting the offset check to the may/must interface.\n\n2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* rtl.h (mem_attrs): Add a default constructor.  Change size and\n\toffset from HOST_WIDE_INT to poly_int64.\n\t* emit-rtl.h (set_mem_offset, set_mem_size, adjust_address_1)\n\t(adjust_automodify_address_1, set_mem_attributes_minus_bitpos)\n\t(widen_memory_access): Take the sizes and offsets as poly_int64s\n\trather than HOST_WIDE_INTs.\n\t* alias.c (ao_ref_from_mem): Handle the new form of MEM_OFFSET.\n\t(offset_overlap_p): Take poly_int64s rather than HOST_WIDE_INTs\n\tand ints.\n\t(adjust_offset_for_component_ref): Change the offset from a\n\tHOST_WIDE_INT to a poly_int64.\n\t(nonoverlapping_memrefs_p): Track polynomial offsets and sizes.\n\t* cfgcleanup.c (merge_memattrs): Update after mem_attrs changes.\n\t* dce.c (find_call_stack_args): Likewise.\n\t* dse.c (record_store): Likewise.\n\t* dwarf2out.c (tls_mem_loc_descriptor, dw_sra_loc_expr): Likewise.\n\t* print-rtl.c (rtx_writer::print_rtx): Likewise.\n\t* read-rtl-function.c (test_loading_mem): Likewise.\n\t* rtlanal.c (may_trap_p_1): Likewise.\n\t* simplify-rtx.c (delegitimize_mem_from_attrs): Likewise.\n\t* var-tracking.c (int_mem_offset, track_expr_p): Likewise.\n\t* emit-rtl.c (mem_attrs_eq_p, get_mem_align_offset): Likewise.\n\t(mem_attrs::mem_attrs): New function.\n\t(set_mem_attributes_minus_bitpos): Change bitpos from a\n\tHOST_WIDE_INT to poly_int64.\n\t(set_mem_alias_set, set_mem_addr_space, set_mem_align, set_mem_expr)\n\t(clear_mem_offset, clear_mem_size, change_address)\n\t(get_spill_slot_decl, set_mem_attrs_for_spill): Directly\n\tinitialize mem_attrs.\n\t(set_mem_offset, set_mem_size, adjust_address_1)\n\t(adjust_automodify_address_1, offset_address, widen_memory_access):\n\tLikewise.  Take poly_int64s rather than HOST_WIDE_INT.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255875", "tree": {"sha": "1178b6d79fbc857905717d3e51f99bd3df6cfbda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1178b6d79fbc857905717d3e51f99bd3df6cfbda"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d05d755107df11e675a57ac4371fd0031c7d68a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d05d755107df11e675a57ac4371fd0031c7d68a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d05d755107df11e675a57ac4371fd0031c7d68a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d05d755107df11e675a57ac4371fd0031c7d68a4/comments", "author": null, "committer": null, "parents": [{"sha": "a02ee6ef8834a80d4692736eb340db9854fe32ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a02ee6ef8834a80d4692736eb340db9854fe32ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a02ee6ef8834a80d4692736eb340db9854fe32ce"}], "stats": {"total": 370, "additions": 201, "deletions": 169}, "files": [{"sha": "9b04467a8de51e3f1ee656a5b69aee34169814ba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05d755107df11e675a57ac4371fd0031c7d68a4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05d755107df11e675a57ac4371fd0031c7d68a4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d05d755107df11e675a57ac4371fd0031c7d68a4", "patch": "@@ -1,3 +1,40 @@\n+2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* rtl.h (mem_attrs): Add a default constructor.  Change size and\n+\toffset from HOST_WIDE_INT to poly_int64.\n+\t* emit-rtl.h (set_mem_offset, set_mem_size, adjust_address_1)\n+\t(adjust_automodify_address_1, set_mem_attributes_minus_bitpos)\n+\t(widen_memory_access): Take the sizes and offsets as poly_int64s\n+\trather than HOST_WIDE_INTs.\n+\t* alias.c (ao_ref_from_mem): Handle the new form of MEM_OFFSET.\n+\t(offset_overlap_p): Take poly_int64s rather than HOST_WIDE_INTs\n+\tand ints.\n+\t(adjust_offset_for_component_ref): Change the offset from a\n+\tHOST_WIDE_INT to a poly_int64.\n+\t(nonoverlapping_memrefs_p): Track polynomial offsets and sizes.\n+\t* cfgcleanup.c (merge_memattrs): Update after mem_attrs changes.\n+\t* dce.c (find_call_stack_args): Likewise.\n+\t* dse.c (record_store): Likewise.\n+\t* dwarf2out.c (tls_mem_loc_descriptor, dw_sra_loc_expr): Likewise.\n+\t* print-rtl.c (rtx_writer::print_rtx): Likewise.\n+\t* read-rtl-function.c (test_loading_mem): Likewise.\n+\t* rtlanal.c (may_trap_p_1): Likewise.\n+\t* simplify-rtx.c (delegitimize_mem_from_attrs): Likewise.\n+\t* var-tracking.c (int_mem_offset, track_expr_p): Likewise.\n+\t* emit-rtl.c (mem_attrs_eq_p, get_mem_align_offset): Likewise.\n+\t(mem_attrs::mem_attrs): New function.\n+\t(set_mem_attributes_minus_bitpos): Change bitpos from a\n+\tHOST_WIDE_INT to poly_int64.\n+\t(set_mem_alias_set, set_mem_addr_space, set_mem_align, set_mem_expr)\n+\t(clear_mem_offset, clear_mem_size, change_address)\n+\t(get_spill_slot_decl, set_mem_attrs_for_spill): Directly\n+\tinitialize mem_attrs.\n+\t(set_mem_offset, set_mem_size, adjust_address_1)\n+\t(adjust_automodify_address_1, offset_address, widen_memory_access):\n+\tLikewise.  Take poly_int64s rather than HOST_WIDE_INT.\n+\n 2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "072fba207e78a1014741cc5ac14d8713f633d740", "filename": "gcc/alias.c", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05d755107df11e675a57ac4371fd0031c7d68a4/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05d755107df11e675a57ac4371fd0031c7d68a4/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=d05d755107df11e675a57ac4371fd0031c7d68a4", "patch": "@@ -330,7 +330,7 @@ ao_ref_from_mem (ao_ref *ref, const_rtx mem)\n \n   /* If MEM_OFFSET/MEM_SIZE get us outside of ref->offset/ref->max_size\n      drop ref->ref.  */\n-  if (MEM_OFFSET (mem) < 0\n+  if (maybe_lt (MEM_OFFSET (mem), 0)\n       || (ref->max_size_known_p ()\n \t  && maybe_gt ((MEM_OFFSET (mem) + MEM_SIZE (mem)) * BITS_PER_UNIT,\n \t\t       ref->max_size)))\n@@ -2331,12 +2331,15 @@ addr_side_effect_eval (rtx addr, int size, int n_refs)\n    absolute value of the sizes as the actual sizes.  */\n \n static inline bool\n-offset_overlap_p (HOST_WIDE_INT c, int xsize, int ysize)\n+offset_overlap_p (poly_int64 c, poly_int64 xsize, poly_int64 ysize)\n {\n-  return (xsize == 0 || ysize == 0\n-\t  || (c >= 0\n-\t      ? (abs (xsize) > c)\n-\t      : (abs (ysize) > -c)));\n+  if (known_eq (xsize, 0) || known_eq (ysize, 0))\n+    return true;\n+\n+  if (maybe_ge (c, 0))\n+    return maybe_gt (maybe_lt (xsize, 0) ? -xsize : xsize, c);\n+  else\n+    return maybe_gt (maybe_lt (ysize, 0) ? -ysize : ysize, -c);\n }\n \n /* Return one if X and Y (memory addresses) reference the\n@@ -2667,7 +2670,7 @@ decl_for_component_ref (tree x)\n \n static void\n adjust_offset_for_component_ref (tree x, bool *known_p,\n-\t\t\t\t HOST_WIDE_INT *offset)\n+\t\t\t\t poly_int64 *offset)\n {\n   if (!*known_p)\n     return;\n@@ -2708,8 +2711,8 @@ nonoverlapping_memrefs_p (const_rtx x, const_rtx y, bool loop_invariant)\n   rtx rtlx, rtly;\n   rtx basex, basey;\n   bool moffsetx_known_p, moffsety_known_p;\n-  HOST_WIDE_INT moffsetx = 0, moffsety = 0;\n-  HOST_WIDE_INT offsetx = 0, offsety = 0, sizex, sizey;\n+  poly_int64 moffsetx = 0, moffsety = 0;\n+  poly_int64 offsetx = 0, offsety = 0, sizex, sizey;\n \n   /* Unless both have exprs, we can't tell anything.  */\n   if (exprx == 0 || expry == 0)\n@@ -2811,12 +2814,10 @@ nonoverlapping_memrefs_p (const_rtx x, const_rtx y, bool loop_invariant)\n      we can avoid overlap is if we can deduce that they are nonoverlapping\n      pieces of that decl, which is very rare.  */\n   basex = MEM_P (rtlx) ? XEXP (rtlx, 0) : rtlx;\n-  if (GET_CODE (basex) == PLUS && CONST_INT_P (XEXP (basex, 1)))\n-    offsetx = INTVAL (XEXP (basex, 1)), basex = XEXP (basex, 0);\n+  basex = strip_offset_and_add (basex, &offsetx);\n \n   basey = MEM_P (rtly) ? XEXP (rtly, 0) : rtly;\n-  if (GET_CODE (basey) == PLUS && CONST_INT_P (XEXP (basey, 1)))\n-    offsety = INTVAL (XEXP (basey, 1)), basey = XEXP (basey, 0);\n+  basey = strip_offset_and_add (basey, &offsety);\n \n   /* If the bases are different, we know they do not overlap if both\n      are constants or if one is a constant and the other a pointer into the\n@@ -2837,10 +2838,10 @@ nonoverlapping_memrefs_p (const_rtx x, const_rtx y, bool loop_invariant)\n      declarations are necessarily different\n     (i.e. compare_base_decls (exprx, expry) == -1)  */\n \n-  sizex = (!MEM_P (rtlx) ? (int) GET_MODE_SIZE (GET_MODE (rtlx))\n+  sizex = (!MEM_P (rtlx) ? poly_int64 (GET_MODE_SIZE (GET_MODE (rtlx)))\n \t   : MEM_SIZE_KNOWN_P (rtlx) ? MEM_SIZE (rtlx)\n \t   : -1);\n-  sizey = (!MEM_P (rtly) ? (int) GET_MODE_SIZE (GET_MODE (rtly))\n+  sizey = (!MEM_P (rtly) ? poly_int64 (GET_MODE_SIZE (GET_MODE (rtly)))\n \t   : MEM_SIZE_KNOWN_P (rtly) ? MEM_SIZE (rtly)\n \t   : -1);\n \n@@ -2859,16 +2860,7 @@ nonoverlapping_memrefs_p (const_rtx x, const_rtx y, bool loop_invariant)\n   if (MEM_SIZE_KNOWN_P (y) && moffsety_known_p)\n     sizey = MEM_SIZE (y);\n \n-  /* Put the values of the memref with the lower offset in X's values.  */\n-  if (offsetx > offsety)\n-    {\n-      std::swap (offsetx, offsety);\n-      std::swap (sizex, sizey);\n-    }\n-\n-  /* If we don't know the size of the lower-offset value, we can't tell\n-     if they conflict.  Otherwise, we do the test.  */\n-  return sizex >= 0 && offsety >= offsetx + sizex;\n+  return !ranges_maybe_overlap_p (offsetx, sizex, offsety, sizey);\n }\n \n /* Helper for true_dependence and canon_true_dependence."}, {"sha": "f470f18c074dfa85abf2a92669e14f58ca20ed43", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05d755107df11e675a57ac4371fd0031c7d68a4/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05d755107df11e675a57ac4371fd0031c7d68a4/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=d05d755107df11e675a57ac4371fd0031c7d68a4", "patch": "@@ -864,8 +864,6 @@ merge_memattrs (rtx x, rtx y)\n \tMEM_ATTRS (x) = 0;\n       else\n \t{\n-\t  HOST_WIDE_INT mem_size;\n-\n \t  if (MEM_ALIAS_SET (x) != MEM_ALIAS_SET (y))\n \t    {\n \t      set_mem_alias_set (x, 0);\n@@ -881,20 +879,23 @@ merge_memattrs (rtx x, rtx y)\n \t    }\n \t  else if (MEM_OFFSET_KNOWN_P (x) != MEM_OFFSET_KNOWN_P (y)\n \t\t   || (MEM_OFFSET_KNOWN_P (x)\n-\t\t       && MEM_OFFSET (x) != MEM_OFFSET (y)))\n+\t\t       && maybe_ne (MEM_OFFSET (x), MEM_OFFSET (y))))\n \t    {\n \t      clear_mem_offset (x);\n \t      clear_mem_offset (y);\n \t    }\n \n-\t  if (MEM_SIZE_KNOWN_P (x) && MEM_SIZE_KNOWN_P (y))\n-\t    {\n-\t      mem_size = MAX (MEM_SIZE (x), MEM_SIZE (y));\n-\t      set_mem_size (x, mem_size);\n-\t      set_mem_size (y, mem_size);\n-\t    }\n+\t  if (!MEM_SIZE_KNOWN_P (x))\n+\t    clear_mem_size (y);\n+\t  else if (!MEM_SIZE_KNOWN_P (y))\n+\t    clear_mem_size (x);\n+\t  else if (known_le (MEM_SIZE (x), MEM_SIZE (y)))\n+\t    set_mem_size (x, MEM_SIZE (y));\n+\t  else if (known_le (MEM_SIZE (y), MEM_SIZE (x)))\n+\t    set_mem_size (y, MEM_SIZE (x));\n \t  else\n \t    {\n+\t      /* The sizes aren't ordered, so we can't merge them.  */\n \t      clear_mem_size (x);\n \t      clear_mem_size (y);\n \t    }"}, {"sha": "b41a4432fc7872ecff3a75b5bde96086deb08c74", "filename": "gcc/dce.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05d755107df11e675a57ac4371fd0031c7d68a4/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05d755107df11e675a57ac4371fd0031c7d68a4/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=d05d755107df11e675a57ac4371fd0031c7d68a4", "patch": "@@ -293,9 +293,8 @@ find_call_stack_args (rtx_call_insn *call_insn, bool do_mark, bool fast,\n       {\n \trtx mem = XEXP (XEXP (p, 0), 0), addr;\n \tHOST_WIDE_INT off = 0, size;\n-\tif (!MEM_SIZE_KNOWN_P (mem))\n+\tif (!MEM_SIZE_KNOWN_P (mem) || !MEM_SIZE (mem).is_constant (&size))\n \t  return false;\n-\tsize = MEM_SIZE (mem);\n \taddr = XEXP (mem, 0);\n \tif (GET_CODE (addr) == PLUS\n \t    && REG_P (XEXP (addr, 0))\n@@ -360,7 +359,9 @@ find_call_stack_args (rtx_call_insn *call_insn, bool do_mark, bool fast,\n \t&& MEM_P (XEXP (XEXP (p, 0), 0)))\n       {\n \trtx mem = XEXP (XEXP (p, 0), 0), addr;\n-\tHOST_WIDE_INT off = 0, byte;\n+\tHOST_WIDE_INT off = 0, byte, size;\n+\t/* Checked in the previous iteration.  */\n+\tsize = MEM_SIZE (mem).to_constant ();\n \taddr = XEXP (mem, 0);\n \tif (GET_CODE (addr) == PLUS\n \t    && REG_P (XEXP (addr, 0))\n@@ -386,7 +387,7 @@ find_call_stack_args (rtx_call_insn *call_insn, bool do_mark, bool fast,\n \t    set = single_set (DF_REF_INSN (defs->ref));\n \t    off += INTVAL (XEXP (SET_SRC (set), 1));\n \t  }\n-\tfor (byte = off; byte < off + MEM_SIZE (mem); byte++)\n+\tfor (byte = off; byte < off + size; byte++)\n \t  {\n \t    if (!bitmap_set_bit (sp_bytes, byte - min_sp_off))\n \t      gcc_unreachable ();\n@@ -469,8 +470,10 @@ find_call_stack_args (rtx_call_insn *call_insn, bool do_mark, bool fast,\n \t    break;\n \t}\n \n+      HOST_WIDE_INT size;\n       if (!MEM_SIZE_KNOWN_P (mem)\n-\t  || !check_argument_store (MEM_SIZE (mem), off, min_sp_off,\n+\t  || !MEM_SIZE (mem).is_constant (&size)\n+\t  || !check_argument_store (size, off, min_sp_off,\n \t\t\t\t    max_sp_off, sp_bytes))\n \tbreak;\n "}, {"sha": "3e0a4168fd2f546fcdace35ffd432a8a0bbb484d", "filename": "gcc/dse.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05d755107df11e675a57ac4371fd0031c7d68a4/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05d755107df11e675a57ac4371fd0031c7d68a4/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=d05d755107df11e675a57ac4371fd0031c7d68a4", "patch": "@@ -1365,6 +1365,7 @@ record_store (rtx body, bb_info_t bb_info)\n   /* At this point we know mem is a mem. */\n   if (GET_MODE (mem) == BLKmode)\n     {\n+      HOST_WIDE_INT const_size;\n       if (GET_CODE (XEXP (mem, 0)) == SCRATCH)\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1376,8 +1377,11 @@ record_store (rtx body, bb_info_t bb_info)\n       /* Handle (set (mem:BLK (addr) [... S36 ...]) (const_int 0))\n \t as memset (addr, 0, 36);  */\n       else if (!MEM_SIZE_KNOWN_P (mem)\n-\t       || MEM_SIZE (mem) <= 0\n-\t       || MEM_SIZE (mem) > MAX_OFFSET\n+\t       || maybe_le (MEM_SIZE (mem), 0)\n+\t       /* This is a limit on the bitmap size, which is only relevant\n+\t\t  for constant-sized MEMs.  */\n+\t       || (MEM_SIZE (mem).is_constant (&const_size)\n+\t\t   && const_size > MAX_OFFSET)\n \t       || GET_CODE (body) != SET\n \t       || !CONST_INT_P (SET_SRC (body)))\n \t{"}, {"sha": "ed79fd019d4999bd9a30ed533acf882e2443bf4e", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05d755107df11e675a57ac4371fd0031c7d68a4/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05d755107df11e675a57ac4371fd0031c7d68a4/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=d05d755107df11e675a57ac4371fd0031c7d68a4", "patch": "@@ -13774,7 +13774,7 @@ tls_mem_loc_descriptor (rtx mem)\n   if (loc_result == NULL)\n     return NULL;\n \n-  if (MEM_OFFSET (mem))\n+  if (maybe_ne (MEM_OFFSET (mem), 0))\n     loc_descr_plus_const (&loc_result, MEM_OFFSET (mem));\n \n   return loc_result;\n@@ -16377,8 +16377,10 @@ dw_sra_loc_expr (tree decl, rtx loc)\n \t     adjustment.  */\n \t  if (MEM_P (varloc))\n \t    {\n-\t      unsigned HOST_WIDE_INT memsize\n-\t\t= MEM_SIZE (varloc) * BITS_PER_UNIT;\n+\t      unsigned HOST_WIDE_INT memsize;\n+\t      if (!poly_uint64 (MEM_SIZE (varloc)).is_constant (&memsize))\n+\t\tgoto discard_descr;\n+\t      memsize *= BITS_PER_UNIT;\n \t      if (memsize != bitsize)\n \t\t{\n \t\t  if (BYTES_BIG_ENDIAN != WORDS_BIG_ENDIAN"}, {"sha": "e1ed2b0b336644dd45d4b8220abf1cffe9cc3126", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 84, "deletions": 94, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05d755107df11e675a57ac4371fd0031c7d68a4/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05d755107df11e675a57ac4371fd0031c7d68a4/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=d05d755107df11e675a57ac4371fd0031c7d68a4", "patch": "@@ -355,9 +355,9 @@ mem_attrs_eq_p (const struct mem_attrs *p, const struct mem_attrs *q)\n     return false;\n   return (p->alias == q->alias\n \t  && p->offset_known_p == q->offset_known_p\n-\t  && (!p->offset_known_p || p->offset == q->offset)\n+\t  && (!p->offset_known_p || known_eq (p->offset, q->offset))\n \t  && p->size_known_p == q->size_known_p\n-\t  && (!p->size_known_p || p->size == q->size)\n+\t  && (!p->size_known_p || known_eq (p->size, q->size))\n \t  && p->align == q->align\n \t  && p->addrspace == q->addrspace\n \t  && (p->expr == q->expr\n@@ -1773,6 +1773,17 @@ operand_subword_force (rtx op, unsigned int offset, machine_mode mode)\n   return result;\n }\n \f\n+mem_attrs::mem_attrs ()\n+  : expr (NULL_TREE),\n+    offset (0),\n+    size (0),\n+    alias (0),\n+    align (0),\n+    addrspace (ADDR_SPACE_GENERIC),\n+    offset_known_p (false),\n+    size_known_p (false)\n+{}\n+\n /* Returns 1 if both MEM_EXPR can be considered equal\n    and 0 otherwise.  */\n \n@@ -1799,7 +1810,7 @@ int\n get_mem_align_offset (rtx mem, unsigned int align)\n {\n   tree expr;\n-  unsigned HOST_WIDE_INT offset;\n+  poly_uint64 offset;\n \n   /* This function can't use\n      if (!MEM_EXPR (mem) || !MEM_OFFSET_KNOWN_P (mem)\n@@ -1841,12 +1852,13 @@ get_mem_align_offset (rtx mem, unsigned int align)\n \t  tree byte_offset = component_ref_field_offset (expr);\n \t  tree bit_offset = DECL_FIELD_BIT_OFFSET (field);\n \n+\t  poly_uint64 suboffset;\n \t  if (!byte_offset\n-\t      || !tree_fits_uhwi_p (byte_offset)\n+\t      || !poly_int_tree_p (byte_offset, &suboffset)\n \t      || !tree_fits_uhwi_p (bit_offset))\n \t    return -1;\n \n-\t  offset += tree_to_uhwi (byte_offset);\n+\t  offset += suboffset;\n \t  offset += tree_to_uhwi (bit_offset) / BITS_PER_UNIT;\n \n \t  if (inner == NULL_TREE)\n@@ -1870,7 +1882,10 @@ get_mem_align_offset (rtx mem, unsigned int align)\n   else\n     return -1;\n \n-  return offset & ((align / BITS_PER_UNIT) - 1);\n+  HOST_WIDE_INT misalign;\n+  if (!known_misalignment (offset, align / BITS_PER_UNIT, &misalign))\n+    return -1;\n+  return misalign;\n }\n \n /* Given REF (a MEM) and T, either the type of X or the expression\n@@ -1880,9 +1895,9 @@ get_mem_align_offset (rtx mem, unsigned int align)\n \n void\n set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n-\t\t\t\t HOST_WIDE_INT bitpos)\n+\t\t\t\t poly_int64 bitpos)\n {\n-  HOST_WIDE_INT apply_bitpos = 0;\n+  poly_int64 apply_bitpos = 0;\n   tree type;\n   struct mem_attrs attrs, *defattrs, *refattrs;\n   addr_space_t as;\n@@ -1903,8 +1918,6 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n      set_mem_attributes.  */\n   gcc_assert (!DECL_P (t) || ref != DECL_RTL_IF_SET (t));\n \n-  memset (&attrs, 0, sizeof (attrs));\n-\n   /* Get the alias set from the expression or type (perhaps using a\n      front-end routine) and use it.  */\n   attrs.alias = get_alias_set (t);\n@@ -2074,10 +2087,9 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t    {\n \t      attrs.expr = t2;\n \t      attrs.offset_known_p = false;\n-\t      if (tree_fits_uhwi_p (off_tree))\n+\t      if (poly_int_tree_p (off_tree, &attrs.offset))\n \t\t{\n \t\t  attrs.offset_known_p = true;\n-\t\t  attrs.offset = tree_to_uhwi (off_tree);\n \t\t  apply_bitpos = bitpos;\n \t\t}\n \t    }\n@@ -2098,27 +2110,29 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n       unsigned int obj_align;\n       unsigned HOST_WIDE_INT obj_bitpos;\n       get_object_alignment_1 (t, &obj_align, &obj_bitpos);\n-      obj_bitpos = (obj_bitpos - bitpos) & (obj_align - 1);\n-      if (obj_bitpos != 0)\n-\tobj_align = least_bit_hwi (obj_bitpos);\n+      unsigned int diff_align = known_alignment (obj_bitpos - bitpos);\n+      if (diff_align != 0)\n+\tobj_align = MIN (obj_align, diff_align);\n       attrs.align = MAX (attrs.align, obj_align);\n     }\n \n-  if (tree_fits_uhwi_p (new_size))\n+  poly_uint64 const_size;\n+  if (poly_int_tree_p (new_size, &const_size))\n     {\n       attrs.size_known_p = true;\n-      attrs.size = tree_to_uhwi (new_size);\n+      attrs.size = const_size;\n     }\n \n   /* If we modified OFFSET based on T, then subtract the outstanding\n      bit position offset.  Similarly, increase the size of the accessed\n      object to contain the negative offset.  */\n-  if (apply_bitpos)\n+  if (maybe_ne (apply_bitpos, 0))\n     {\n       gcc_assert (attrs.offset_known_p);\n-      attrs.offset -= apply_bitpos / BITS_PER_UNIT;\n+      poly_int64 bytepos = bits_to_bytes_round_down (apply_bitpos);\n+      attrs.offset -= bytepos;\n       if (attrs.size_known_p)\n-\tattrs.size += apply_bitpos / BITS_PER_UNIT;\n+\tattrs.size += bytepos;\n     }\n \n   /* Now set the attributes we computed above.  */\n@@ -2137,11 +2151,9 @@ set_mem_attributes (rtx ref, tree t, int objectp)\n void\n set_mem_alias_set (rtx mem, alias_set_type set)\n {\n-  struct mem_attrs attrs;\n-\n   /* If the new and old alias sets don't conflict, something is wrong.  */\n   gcc_checking_assert (alias_sets_conflict_p (set, MEM_ALIAS_SET (mem)));\n-  attrs = *get_mem_attrs (mem);\n+  mem_attrs attrs (*get_mem_attrs (mem));\n   attrs.alias = set;\n   set_mem_attrs (mem, &attrs);\n }\n@@ -2151,9 +2163,7 @@ set_mem_alias_set (rtx mem, alias_set_type set)\n void\n set_mem_addr_space (rtx mem, addr_space_t addrspace)\n {\n-  struct mem_attrs attrs;\n-\n-  attrs = *get_mem_attrs (mem);\n+  mem_attrs attrs (*get_mem_attrs (mem));\n   attrs.addrspace = addrspace;\n   set_mem_attrs (mem, &attrs);\n }\n@@ -2163,9 +2173,7 @@ set_mem_addr_space (rtx mem, addr_space_t addrspace)\n void\n set_mem_align (rtx mem, unsigned int align)\n {\n-  struct mem_attrs attrs;\n-\n-  attrs = *get_mem_attrs (mem);\n+  mem_attrs attrs (*get_mem_attrs (mem));\n   attrs.align = align;\n   set_mem_attrs (mem, &attrs);\n }\n@@ -2175,21 +2183,17 @@ set_mem_align (rtx mem, unsigned int align)\n void\n set_mem_expr (rtx mem, tree expr)\n {\n-  struct mem_attrs attrs;\n-\n-  attrs = *get_mem_attrs (mem);\n+  mem_attrs attrs (*get_mem_attrs (mem));\n   attrs.expr = expr;\n   set_mem_attrs (mem, &attrs);\n }\n \n /* Set the offset of MEM to OFFSET.  */\n \n void\n-set_mem_offset (rtx mem, HOST_WIDE_INT offset)\n+set_mem_offset (rtx mem, poly_int64 offset)\n {\n-  struct mem_attrs attrs;\n-\n-  attrs = *get_mem_attrs (mem);\n+  mem_attrs attrs (*get_mem_attrs (mem));\n   attrs.offset_known_p = true;\n   attrs.offset = offset;\n   set_mem_attrs (mem, &attrs);\n@@ -2200,21 +2204,17 @@ set_mem_offset (rtx mem, HOST_WIDE_INT offset)\n void\n clear_mem_offset (rtx mem)\n {\n-  struct mem_attrs attrs;\n-\n-  attrs = *get_mem_attrs (mem);\n+  mem_attrs attrs (*get_mem_attrs (mem));\n   attrs.offset_known_p = false;\n   set_mem_attrs (mem, &attrs);\n }\n \n /* Set the size of MEM to SIZE.  */\n \n void\n-set_mem_size (rtx mem, HOST_WIDE_INT size)\n+set_mem_size (rtx mem, poly_int64 size)\n {\n-  struct mem_attrs attrs;\n-\n-  attrs = *get_mem_attrs (mem);\n+  mem_attrs attrs (*get_mem_attrs (mem));\n   attrs.size_known_p = true;\n   attrs.size = size;\n   set_mem_attrs (mem, &attrs);\n@@ -2225,9 +2225,7 @@ set_mem_size (rtx mem, HOST_WIDE_INT size)\n void\n clear_mem_size (rtx mem)\n {\n-  struct mem_attrs attrs;\n-\n-  attrs = *get_mem_attrs (mem);\n+  mem_attrs attrs (*get_mem_attrs (mem));\n   attrs.size_known_p = false;\n   set_mem_attrs (mem, &attrs);\n }\n@@ -2290,9 +2288,9 @@ change_address (rtx memref, machine_mode mode, rtx addr)\n {\n   rtx new_rtx = change_address_1 (memref, mode, addr, 1, false);\n   machine_mode mmode = GET_MODE (new_rtx);\n-  struct mem_attrs attrs, *defattrs;\n+  struct mem_attrs *defattrs;\n \n-  attrs = *get_mem_attrs (memref);\n+  mem_attrs attrs (*get_mem_attrs (memref));\n   defattrs = mode_mem_attrs[(int) mmode];\n   attrs.expr = NULL_TREE;\n   attrs.offset_known_p = false;\n@@ -2327,15 +2325,14 @@ change_address (rtx memref, machine_mode mode, rtx addr)\n    has no inherent size.  */\n \n rtx\n-adjust_address_1 (rtx memref, machine_mode mode, HOST_WIDE_INT offset,\n+adjust_address_1 (rtx memref, machine_mode mode, poly_int64 offset,\n \t\t  int validate, int adjust_address, int adjust_object,\n-\t\t  HOST_WIDE_INT size)\n+\t\t  poly_int64 size)\n {\n   rtx addr = XEXP (memref, 0);\n   rtx new_rtx;\n   scalar_int_mode address_mode;\n-  int pbits;\n-  struct mem_attrs attrs = *get_mem_attrs (memref), *defattrs;\n+  struct mem_attrs attrs (*get_mem_attrs (memref)), *defattrs;\n   unsigned HOST_WIDE_INT max_align;\n #ifdef POINTERS_EXTEND_UNSIGNED\n   scalar_int_mode pointer_mode\n@@ -2352,8 +2349,10 @@ adjust_address_1 (rtx memref, machine_mode mode, HOST_WIDE_INT offset,\n     size = defattrs->size;\n \n   /* If there are no changes, just return the original memory reference.  */\n-  if (mode == GET_MODE (memref) && !offset\n-      && (size == 0 || (attrs.size_known_p && attrs.size == size))\n+  if (mode == GET_MODE (memref)\n+      && known_eq (offset, 0)\n+      && (known_eq (size, 0)\n+\t  || (attrs.size_known_p && known_eq (attrs.size, size)))\n       && (!validate || memory_address_addr_space_p (mode, addr,\n \t\t\t\t\t\t    attrs.addrspace)))\n     return memref;\n@@ -2366,22 +2365,17 @@ adjust_address_1 (rtx memref, machine_mode mode, HOST_WIDE_INT offset,\n   /* Convert a possibly large offset to a signed value within the\n      range of the target address space.  */\n   address_mode = get_address_mode (memref);\n-  pbits = GET_MODE_BITSIZE (address_mode);\n-  if (HOST_BITS_PER_WIDE_INT > pbits)\n-    {\n-      int shift = HOST_BITS_PER_WIDE_INT - pbits;\n-      offset = (((HOST_WIDE_INT) ((unsigned HOST_WIDE_INT) offset << shift))\n-\t\t>> shift);\n-    }\n+  offset = trunc_int_for_mode (offset, address_mode);\n \n   if (adjust_address)\n     {\n       /* If MEMREF is a LO_SUM and the offset is within the alignment of the\n \t object, we can merge it into the LO_SUM.  */\n-      if (GET_MODE (memref) != BLKmode && GET_CODE (addr) == LO_SUM\n-\t  && offset >= 0\n-\t  && (unsigned HOST_WIDE_INT) offset\n-\t      < GET_MODE_ALIGNMENT (GET_MODE (memref)) / BITS_PER_UNIT)\n+      if (GET_MODE (memref) != BLKmode\n+\t  && GET_CODE (addr) == LO_SUM\n+\t  && known_in_range_p (offset,\n+\t\t\t       0, (GET_MODE_ALIGNMENT (GET_MODE (memref))\n+\t\t\t\t   / BITS_PER_UNIT)))\n \taddr = gen_rtx_LO_SUM (address_mode, XEXP (addr, 0),\n \t\t\t       plus_constant (address_mode,\n \t\t\t\t\t      XEXP (addr, 1), offset));\n@@ -2392,7 +2386,7 @@ adjust_address_1 (rtx memref, machine_mode mode, HOST_WIDE_INT offset,\n       else if (POINTERS_EXTEND_UNSIGNED > 0\n \t       && GET_CODE (addr) == ZERO_EXTEND\n \t       && GET_MODE (XEXP (addr, 0)) == pointer_mode\n-\t       && trunc_int_for_mode (offset, pointer_mode) == offset)\n+\t       && known_eq (trunc_int_for_mode (offset, pointer_mode), offset))\n \taddr = gen_rtx_ZERO_EXTEND (address_mode,\n \t\t\t\t    plus_constant (pointer_mode,\n \t\t\t\t\t\t   XEXP (addr, 0), offset));\n@@ -2405,7 +2399,7 @@ adjust_address_1 (rtx memref, machine_mode mode, HOST_WIDE_INT offset,\n \n   /* If the address is a REG, change_address_1 rightfully returns memref,\n      but this would destroy memref's MEM_ATTRS.  */\n-  if (new_rtx == memref && offset != 0)\n+  if (new_rtx == memref && maybe_ne (offset, 0))\n     new_rtx = copy_rtx (new_rtx);\n \n   /* Conservatively drop the object if we don't know where we start from.  */\n@@ -2422,7 +2416,7 @@ adjust_address_1 (rtx memref, machine_mode mode, HOST_WIDE_INT offset,\n       attrs.offset += offset;\n \n       /* Drop the object if the new left end is not within its bounds.  */\n-      if (adjust_object && attrs.offset < 0)\n+      if (adjust_object && maybe_lt (attrs.offset, 0))\n \t{\n \t  attrs.expr = NULL_TREE;\n \t  attrs.alias = 0;\n@@ -2432,16 +2426,16 @@ adjust_address_1 (rtx memref, machine_mode mode, HOST_WIDE_INT offset,\n   /* Compute the new alignment by taking the MIN of the alignment and the\n      lowest-order set bit in OFFSET, but don't change the alignment if OFFSET\n      if zero.  */\n-  if (offset != 0)\n+  if (maybe_ne (offset, 0))\n     {\n-      max_align = least_bit_hwi (offset) * BITS_PER_UNIT;\n+      max_align = known_alignment (offset) * BITS_PER_UNIT;\n       attrs.align = MIN (attrs.align, max_align);\n     }\n \n-  if (size)\n+  if (maybe_ne (size, 0))\n     {\n       /* Drop the object if the new right end is not within its bounds.  */\n-      if (adjust_object && (offset + size) > attrs.size)\n+      if (adjust_object && maybe_gt (offset + size, attrs.size))\n \t{\n \t  attrs.expr = NULL_TREE;\n \t  attrs.alias = 0;\n@@ -2469,7 +2463,7 @@ adjust_address_1 (rtx memref, machine_mode mode, HOST_WIDE_INT offset,\n \n rtx\n adjust_automodify_address_1 (rtx memref, machine_mode mode, rtx addr,\n-\t\t\t     HOST_WIDE_INT offset, int validate)\n+\t\t\t     poly_int64 offset, int validate)\n {\n   memref = change_address_1 (memref, VOIDmode, addr, validate, false);\n   return adjust_address_1 (memref, mode, offset, validate, 0, 0, 0);\n@@ -2484,9 +2478,9 @@ offset_address (rtx memref, rtx offset, unsigned HOST_WIDE_INT pow2)\n {\n   rtx new_rtx, addr = XEXP (memref, 0);\n   machine_mode address_mode;\n-  struct mem_attrs attrs, *defattrs;\n+  struct mem_attrs *defattrs;\n \n-  attrs = *get_mem_attrs (memref);\n+  mem_attrs attrs (*get_mem_attrs (memref));\n   address_mode = get_address_mode (memref);\n   new_rtx = simplify_gen_binary (PLUS, address_mode, addr, offset);\n \n@@ -2554,17 +2548,16 @@ replace_equiv_address_nv (rtx memref, rtx addr, bool inplace)\n    operations plus masking logic.  */\n \n rtx\n-widen_memory_access (rtx memref, machine_mode mode, HOST_WIDE_INT offset)\n+widen_memory_access (rtx memref, machine_mode mode, poly_int64 offset)\n {\n   rtx new_rtx = adjust_address_1 (memref, mode, offset, 1, 1, 0, 0);\n-  struct mem_attrs attrs;\n   unsigned int size = GET_MODE_SIZE (mode);\n \n   /* If there are no changes, just return the original memory reference.  */\n   if (new_rtx == memref)\n     return new_rtx;\n \n-  attrs = *get_mem_attrs (new_rtx);\n+  mem_attrs attrs (*get_mem_attrs (new_rtx));\n \n   /* If we don't know what offset we were at within the expression, then\n      we can't know if we've overstepped the bounds.  */\n@@ -2586,28 +2579,30 @@ widen_memory_access (rtx memref, machine_mode mode, HOST_WIDE_INT offset)\n \n \t  /* Is the field at least as large as the access?  If so, ok,\n \t     otherwise strip back to the containing structure.  */\n-\t  if (TREE_CODE (DECL_SIZE_UNIT (field)) == INTEGER_CST\n-\t      && compare_tree_int (DECL_SIZE_UNIT (field), size) >= 0\n-\t      && attrs.offset >= 0)\n+\t  if (poly_int_tree_p (DECL_SIZE_UNIT (field))\n+\t      && known_ge (wi::to_poly_offset (DECL_SIZE_UNIT (field)), size)\n+\t      && known_ge (attrs.offset, 0))\n \t    break;\n \n-\t  if (! tree_fits_uhwi_p (offset))\n+\t  poly_uint64 suboffset;\n+\t  if (!poly_int_tree_p (offset, &suboffset))\n \t    {\n \t      attrs.expr = NULL_TREE;\n \t      break;\n \t    }\n \n \t  attrs.expr = TREE_OPERAND (attrs.expr, 0);\n-\t  attrs.offset += tree_to_uhwi (offset);\n+\t  attrs.offset += suboffset;\n \t  attrs.offset += (tree_to_uhwi (DECL_FIELD_BIT_OFFSET (field))\n \t\t\t   / BITS_PER_UNIT);\n \t}\n       /* Similarly for the decl.  */\n       else if (DECL_P (attrs.expr)\n \t       && DECL_SIZE_UNIT (attrs.expr)\n-\t       && TREE_CODE (DECL_SIZE_UNIT (attrs.expr)) == INTEGER_CST\n-\t       && compare_tree_int (DECL_SIZE_UNIT (attrs.expr), size) >= 0\n-\t       && (! attrs.offset_known_p || attrs.offset >= 0))\n+\t       && poly_int_tree_p (DECL_SIZE_UNIT (attrs.expr))\n+\t       && known_ge (wi::to_poly_offset (DECL_SIZE_UNIT (attrs.expr)),\n+\t\t\t   size)\n+\t       && known_ge (attrs.offset, 0))\n \tbreak;\n       else\n \t{\n@@ -2638,7 +2633,6 @@ get_spill_slot_decl (bool force_build_p)\n {\n   tree d = spill_slot_decl;\n   rtx rd;\n-  struct mem_attrs attrs;\n \n   if (d || !force_build_p)\n     return d;\n@@ -2652,7 +2646,7 @@ get_spill_slot_decl (bool force_build_p)\n \n   rd = gen_rtx_MEM (BLKmode, frame_pointer_rtx);\n   MEM_NOTRAP_P (rd) = 1;\n-  attrs = *mode_mem_attrs[(int) BLKmode];\n+  mem_attrs attrs (*mode_mem_attrs[(int) BLKmode]);\n   attrs.alias = new_alias_set ();\n   attrs.expr = d;\n   set_mem_attrs (rd, &attrs);\n@@ -2670,10 +2664,9 @@ get_spill_slot_decl (bool force_build_p)\n void\n set_mem_attrs_for_spill (rtx mem)\n {\n-  struct mem_attrs attrs;\n   rtx addr;\n \n-  attrs = *get_mem_attrs (mem);\n+  mem_attrs attrs (*get_mem_attrs (mem));\n   attrs.expr = get_spill_slot_decl (true);\n   attrs.alias = MEM_ALIAS_SET (DECL_RTL (attrs.expr));\n   attrs.addrspace = ADDR_SPACE_GENERIC;\n@@ -2683,10 +2676,7 @@ set_mem_attrs_for_spill (rtx mem)\n      with perhaps the plus missing for offset = 0.  */\n   addr = XEXP (mem, 0);\n   attrs.offset_known_p = true;\n-  attrs.offset = 0;\n-  if (GET_CODE (addr) == PLUS\n-      && CONST_INT_P (XEXP (addr, 1)))\n-    attrs.offset = INTVAL (XEXP (addr, 1));\n+  strip_offset (addr, &attrs.offset);\n \n   set_mem_attrs (mem, &attrs);\n   MEM_NOTRAP_P (mem) = 1;"}, {"sha": "3e0192123f53af14a6937f003efe8b2a6583b57c", "filename": "gcc/emit-rtl.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05d755107df11e675a57ac4371fd0031c7d68a4/gcc%2Femit-rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05d755107df11e675a57ac4371fd0031c7d68a4/gcc%2Femit-rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.h?ref=d05d755107df11e675a57ac4371fd0031c7d68a4", "patch": "@@ -333,13 +333,13 @@ extern void set_mem_addr_space (rtx, addr_space_t);\n extern void set_mem_expr (rtx, tree);\n \n /* Set the offset for MEM to OFFSET.  */\n-extern void set_mem_offset (rtx, HOST_WIDE_INT);\n+extern void set_mem_offset (rtx, poly_int64);\n \n /* Clear the offset recorded for MEM.  */\n extern void clear_mem_offset (rtx);\n \n /* Set the size for MEM to SIZE.  */\n-extern void set_mem_size (rtx, HOST_WIDE_INT);\n+extern void set_mem_size (rtx, poly_int64);\n \n /* Clear the size recorded for MEM.  */\n extern void clear_mem_size (rtx);\n@@ -489,10 +489,10 @@ extern rtx change_address (rtx, machine_mode, rtx);\n #define adjust_automodify_address_nv(MEMREF, MODE, ADDR, OFFSET) \\\n   adjust_automodify_address_1 (MEMREF, MODE, ADDR, OFFSET, 0)\n \n-extern rtx adjust_address_1 (rtx, machine_mode, HOST_WIDE_INT, int, int,\n-\t\t\t     int, HOST_WIDE_INT);\n+extern rtx adjust_address_1 (rtx, machine_mode, poly_int64, int, int,\n+\t\t\t     int, poly_int64);\n extern rtx adjust_automodify_address_1 (rtx, machine_mode, rtx,\n-\t\t\t\t\tHOST_WIDE_INT, int);\n+\t\t\t\t\tpoly_int64, int);\n \n /* Return a memory reference like MEMREF, but whose address is changed by\n    adding OFFSET, an RTX, to it.  POW2 is the highest power of two factor\n@@ -507,7 +507,7 @@ extern void set_mem_attributes (rtx, tree, int);\n /* Similar, except that BITPOS has not yet been applied to REF, so if\n    we alter MEM_OFFSET according to T then we should subtract BITPOS\n    expecting that it'll be added back in later.  */\n-extern void set_mem_attributes_minus_bitpos (rtx, tree, int, HOST_WIDE_INT);\n+extern void set_mem_attributes_minus_bitpos (rtx, tree, int, poly_int64);\n \n /* Return OFFSET if XEXP (MEM, 0) - OFFSET is known to be ALIGN\n    bits aligned for 0 <= OFFSET < ALIGN / BITS_PER_UNIT, or\n@@ -516,7 +516,7 @@ extern int get_mem_align_offset (rtx, unsigned int);\n \n /* Return a memory reference like MEMREF, but with its mode widened to\n    MODE and adjusted by OFFSET.  */\n-extern rtx widen_memory_access (rtx, machine_mode, HOST_WIDE_INT);\n+extern rtx widen_memory_access (rtx, machine_mode, poly_int64);\n \n extern void maybe_set_max_label_num (rtx_code_label *x);\n "}, {"sha": "1cf2604a8672d2bd0d752041a63b4a8f1a1d8dc8", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05d755107df11e675a57ac4371fd0031c7d68a4/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05d755107df11e675a57ac4371fd0031c7d68a4/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=d05d755107df11e675a57ac4371fd0031c7d68a4", "patch": "@@ -894,10 +894,16 @@ rtx_writer::print_rtx (const_rtx in_rtx)\n \tfputc (' ', m_outfile);\n \n       if (MEM_OFFSET_KNOWN_P (in_rtx))\n-\tfprintf (m_outfile, \"+\" HOST_WIDE_INT_PRINT_DEC, MEM_OFFSET (in_rtx));\n+\t{\n+\t  fprintf (m_outfile, \"+\");\n+\t  print_poly_int (m_outfile, MEM_OFFSET (in_rtx));\n+\t}\n \n       if (MEM_SIZE_KNOWN_P (in_rtx))\n-\tfprintf (m_outfile, \" S\" HOST_WIDE_INT_PRINT_DEC, MEM_SIZE (in_rtx));\n+\t{\n+\t  fprintf (m_outfile, \" S\");\n+\t  print_poly_int (m_outfile, MEM_SIZE (in_rtx));\n+\t}\n \n       if (MEM_ALIGN (in_rtx) != 1)\n \tfprintf (m_outfile, \" A%u\", MEM_ALIGN (in_rtx));"}, {"sha": "9be88ae0a6188e57562abc21f8125b67bfdaefb8", "filename": "gcc/read-rtl-function.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05d755107df11e675a57ac4371fd0031c7d68a4/gcc%2Fread-rtl-function.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05d755107df11e675a57ac4371fd0031c7d68a4/gcc%2Fread-rtl-function.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl-function.c?ref=d05d755107df11e675a57ac4371fd0031c7d68a4", "patch": "@@ -2143,9 +2143,9 @@ test_loading_mem ()\n   ASSERT_EQ (42, MEM_ALIAS_SET (mem1));\n   /* \"+17\".  */\n   ASSERT_TRUE (MEM_OFFSET_KNOWN_P (mem1));\n-  ASSERT_EQ (17, MEM_OFFSET (mem1));\n+  ASSERT_KNOWN_EQ (17, MEM_OFFSET (mem1));\n   /* \"S8\".  */\n-  ASSERT_EQ (8, MEM_SIZE (mem1));\n+  ASSERT_KNOWN_EQ (8, MEM_SIZE (mem1));\n   /* \"A128.  */\n   ASSERT_EQ (128, MEM_ALIGN (mem1));\n   /* \"AS5.  */\n@@ -2159,9 +2159,9 @@ test_loading_mem ()\n   ASSERT_EQ (43, MEM_ALIAS_SET (mem2));\n   /* \"+18\".  */\n   ASSERT_TRUE (MEM_OFFSET_KNOWN_P (mem2));\n-  ASSERT_EQ (18, MEM_OFFSET (mem2));\n+  ASSERT_KNOWN_EQ (18, MEM_OFFSET (mem2));\n   /* \"S9\".  */\n-  ASSERT_EQ (9, MEM_SIZE (mem2));\n+  ASSERT_KNOWN_EQ (9, MEM_SIZE (mem2));\n   /* \"AS6.  */\n   ASSERT_EQ (6, MEM_ADDR_SPACE (mem2));\n }"}, {"sha": "408298a8f7ad26d72742e3466d2f214aa41570f6", "filename": "gcc/rtl.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05d755107df11e675a57ac4371fd0031c7d68a4/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05d755107df11e675a57ac4371fd0031c7d68a4/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=d05d755107df11e675a57ac4371fd0031c7d68a4", "patch": "@@ -147,18 +147,20 @@ struct addr_diff_vec_flags\n    they cannot be modified in place.  */\n struct GTY(()) mem_attrs\n {\n+  mem_attrs ();\n+\n   /* The expression that the MEM accesses, or null if not known.\n      This expression might be larger than the memory reference itself.\n      (In other words, the MEM might access only part of the object.)  */\n   tree expr;\n \n   /* The offset of the memory reference from the start of EXPR.\n      Only valid if OFFSET_KNOWN_P.  */\n-  HOST_WIDE_INT offset;\n+  poly_int64 offset;\n \n   /* The size of the memory reference in bytes.  Only valid if\n      SIZE_KNOWN_P.  */\n-  HOST_WIDE_INT size;\n+  poly_int64 size;\n \n   /* The alias set of the memory reference.  */\n   alias_set_type alias;"}, {"sha": "2116907bb1367742491aa9b49a29d109c158ac0e", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05d755107df11e675a57ac4371fd0031c7d68a4/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05d755107df11e675a57ac4371fd0031c7d68a4/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=d05d755107df11e675a57ac4371fd0031c7d68a4", "patch": "@@ -2796,7 +2796,7 @@ may_trap_p_1 (const_rtx x, unsigned flags)\n \t  code_changed\n \t  || !MEM_NOTRAP_P (x))\n \t{\n-\t  HOST_WIDE_INT size = MEM_SIZE_KNOWN_P (x) ? MEM_SIZE (x) : -1;\n+\t  poly_int64 size = MEM_SIZE_KNOWN_P (x) ? MEM_SIZE (x) : -1;\n \t  return rtx_addr_can_trap_p_1 (XEXP (x, 0), 0, size,\n \t\t\t\t\tGET_MODE (x), code_changed);\n \t}"}, {"sha": "d4b70850c16bbf688185dec4d8bceb1d98955b3a", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05d755107df11e675a57ac4371fd0031c7d68a4/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05d755107df11e675a57ac4371fd0031c7d68a4/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=d05d755107df11e675a57ac4371fd0031c7d68a4", "patch": "@@ -289,7 +289,7 @@ delegitimize_mem_from_attrs (rtx x)\n     {\n       tree decl = MEM_EXPR (x);\n       machine_mode mode = GET_MODE (x);\n-      HOST_WIDE_INT offset = 0;\n+      poly_int64 offset = 0;\n \n       switch (TREE_CODE (decl))\n \t{\n@@ -346,28 +346,22 @@ delegitimize_mem_from_attrs (rtx x)\n \t  if (MEM_P (newx))\n \t    {\n \t      rtx n = XEXP (newx, 0), o = XEXP (x, 0);\n+\t      poly_int64 n_offset, o_offset;\n \n \t      /* Avoid creating a new MEM needlessly if we already had\n \t\t the same address.  We do if there's no OFFSET and the\n \t\t old address X is identical to NEWX, or if X is of the\n \t\t form (plus NEWX OFFSET), or the NEWX is of the form\n \t\t (plus Y (const_int Z)) and X is that with the offset\n \t\t added: (plus Y (const_int Z+OFFSET)).  */\n-\t      if (!((offset == 0\n-\t\t     || (GET_CODE (o) == PLUS\n-\t\t\t && GET_CODE (XEXP (o, 1)) == CONST_INT\n-\t\t\t && (offset == INTVAL (XEXP (o, 1))\n-\t\t\t     || (GET_CODE (n) == PLUS\n-\t\t\t\t && GET_CODE (XEXP (n, 1)) == CONST_INT\n-\t\t\t\t && (INTVAL (XEXP (n, 1)) + offset\n-\t\t\t\t     == INTVAL (XEXP (o, 1)))\n-\t\t\t\t && (n = XEXP (n, 0))))\n-\t\t\t && (o = XEXP (o, 0))))\n+\t      n = strip_offset (n, &n_offset);\n+\t      o = strip_offset (o, &o_offset);\n+\t      if (!(known_eq (o_offset, n_offset + offset)\n \t\t    && rtx_equal_p (o, n)))\n \t\tx = adjust_address_nv (newx, mode, offset);\n \t    }\n \t  else if (GET_MODE (x) == GET_MODE (newx)\n-\t\t   && offset == 0)\n+\t\t   && known_eq (offset, 0))\n \t    x = newx;\n \t}\n     }"}, {"sha": "1a4caaa09b4678877028393ee5c6e694e954ea43", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d05d755107df11e675a57ac4371fd0031c7d68a4/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d05d755107df11e675a57ac4371fd0031c7d68a4/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=d05d755107df11e675a57ac4371fd0031c7d68a4", "patch": "@@ -395,8 +395,9 @@ struct variable\n static inline HOST_WIDE_INT\n int_mem_offset (const_rtx mem)\n {\n-  if (MEM_OFFSET_KNOWN_P (mem))\n-    return MEM_OFFSET (mem);\n+  HOST_WIDE_INT offset;\n+  if (MEM_OFFSET_KNOWN_P (mem) && MEM_OFFSET (mem).is_constant (&offset))\n+    return offset;\n   return 0;\n }\n \n@@ -5256,7 +5257,7 @@ track_expr_p (tree expr, bool need_rtl)\n \t  && !tracked_record_parameter_p (realdecl))\n \treturn 0;\n       if (MEM_SIZE_KNOWN_P (decl_rtl)\n-\t  && MEM_SIZE (decl_rtl) > MAX_VAR_PARTS)\n+\t  && maybe_gt (MEM_SIZE (decl_rtl), MAX_VAR_PARTS))\n \treturn 0;\n     }\n "}]}