{"sha": "5847e8da2f62aa638ca037e2e02ef6f2de2975a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg0N2U4ZGEyZjYyYWE2MzhjYTAzN2UyZTAyZWY2ZjJkZTI5NzVhMA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2010-03-30T21:00:47Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-03-30T21:00:47Z"}, "message": "re PR debug/42977 (\"-fcompare-debug failure\" with \"-O2 -finline-functions -fomit-frame-pointer -ftracer -fsched2-use-superblocks -fPIC\")\n\n\tPR debug/42977\n\t* cselib.c (n_useless_values): Document handling of debug locs.\n\t(n_useless_debug_values, n_debug_values): New variables.\n\t(new_elt_loc_list): Don't add to debug values, keep count.\n\t(promote_debug_loc): New.\n\t(cselib_reset_table): Zero new variables.\n\t(entry_and_rtx_equal_p): Promote debug locs.\n\t(discard_useless_locs): Increment n_useless_debug_values for\n\tdebug values.\n\t(remove_useless_values): Adjust n_useless_values and n_debug_values\n\twith n_useless_debug_values.\n\t(add_mem_for_addr): Promote debug locs.\n\t(cselib_lookup_mem): Likewise.\n\t(cselib_lookup_addr): Renamed to...\n\t(cselib_lookup_addr_1): ... this.  Promote debug locs.\n\tDon't call...\n\t(cselib_log_lookup): ... this.  Turn into...\n\t(cselib_lookup_addr): ... new wrapper.\n\t(cselib_lookup_from_insn): New.\n\t(cselib_invalidate_regno): Increment n_useless_debug_values for\n\tdebug values.\n\t(cselib_invalidate_mem): Likewise.\n\t(cselib_process_insn): Take n_deleted and n_debug_values into\n\taccount to guard remove_useless_value call.\n\t(cselib_finish): Zero n_useless_debug_values.\n\t* cselib.h (cselib_lookup_from_insn): Declare.\n\t* sched-deps.c (sched_analyze_1): Use cselib_lookup_from_insn.\n\t(sched_analyze_2): Likewise.\n\nFrom-SVN: r157837", "tree": {"sha": "fb52b1312a84f4a1957b35bb95aa6010cdf7ac1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb52b1312a84f4a1957b35bb95aa6010cdf7ac1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5847e8da2f62aa638ca037e2e02ef6f2de2975a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5847e8da2f62aa638ca037e2e02ef6f2de2975a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5847e8da2f62aa638ca037e2e02ef6f2de2975a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5847e8da2f62aa638ca037e2e02ef6f2de2975a0/comments", "author": null, "committer": null, "parents": [{"sha": "e9e008859c047465491bc3bb336503dba10caf18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9e008859c047465491bc3bb336503dba10caf18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9e008859c047465491bc3bb336503dba10caf18"}], "stats": {"total": 248, "additions": 207, "deletions": 41}, "files": [{"sha": "503e8b701e5c37d9a5908c321f852b6817630daf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5847e8da2f62aa638ca037e2e02ef6f2de2975a0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5847e8da2f62aa638ca037e2e02ef6f2de2975a0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5847e8da2f62aa638ca037e2e02ef6f2de2975a0", "patch": "@@ -1,3 +1,34 @@\n+2010-03-30  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/42977\n+\t* cselib.c (n_useless_values): Document handling of debug locs.\n+\t(n_useless_debug_values, n_debug_values): New variables.\n+\t(new_elt_loc_list): Don't add to debug values, keep count.\n+\t(promote_debug_loc): New.\n+\t(cselib_reset_table): Zero new variables.\n+\t(entry_and_rtx_equal_p): Promote debug locs.\n+\t(discard_useless_locs): Increment n_useless_debug_values for\n+\tdebug values.\n+\t(remove_useless_values): Adjust n_useless_values and n_debug_values\n+\twith n_useless_debug_values.\n+\t(add_mem_for_addr): Promote debug locs.\n+\t(cselib_lookup_mem): Likewise.\n+\t(cselib_lookup_addr): Renamed to...\n+\t(cselib_lookup_addr_1): ... this.  Promote debug locs.\n+\tDon't call...\n+\t(cselib_log_lookup): ... this.  Turn into...\n+\t(cselib_lookup_addr): ... new wrapper.\n+\t(cselib_lookup_from_insn): New.\n+\t(cselib_invalidate_regno): Increment n_useless_debug_values for\n+\tdebug values.\n+\t(cselib_invalidate_mem): Likewise.\n+\t(cselib_process_insn): Take n_deleted and n_debug_values into\n+\taccount to guard remove_useless_value call.\n+\t(cselib_finish): Zero n_useless_debug_values.\n+\t* cselib.h (cselib_lookup_from_insn): Declare.\n+\t* sched-deps.c (sched_analyze_1): Use cselib_lookup_from_insn.\n+\t(sched_analyze_2): Likewise.\n+\n 2010-03-30  Jakub Jelinek  <jakub@redhat.com>\n \n \t* var-tracking.c (use_narrower_mode_test, use_narrower_mode): New"}, {"sha": "18807ca3bd421495100f1c2d2cc079bed6cd6a44", "filename": "gcc/cselib.c", "status": "modified", "additions": 173, "deletions": 39, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5847e8da2f62aa638ca037e2e02ef6f2de2975a0/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5847e8da2f62aa638ca037e2e02ef6f2de2975a0/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=5847e8da2f62aa638ca037e2e02ef6f2de2975a0", "patch": "@@ -97,9 +97,47 @@ static unsigned int next_uid;\n /* The number of registers we had when the varrays were last resized.  */\n static unsigned int cselib_nregs;\n \n-/* Count values without known locations.  Whenever this grows too big, we\n-   remove these useless values from the table.  */\n+/* Count values without known locations, or with only locations that\n+   wouldn't have been known except for debug insns.  Whenever this\n+   grows too big, we remove these useless values from the table.\n+\n+   Counting values with only debug values is a bit tricky.  We don't\n+   want to increment n_useless_values when we create a value for a\n+   debug insn, for this would get n_useless_values out of sync, but we\n+   want increment it if all locs in the list that were ever referenced\n+   in nondebug insns are removed from the list.\n+\n+   In the general case, once we do that, we'd have to stop accepting\n+   nondebug expressions in the loc list, to avoid having two values\n+   equivalent that, without debug insns, would have been made into\n+   separate values.  However, because debug insns never introduce\n+   equivalences themselves (no assignments), the only means for\n+   growing loc lists is through nondebug assignments.  If the locs\n+   also happen to be referenced in debug insns, it will work just fine.\n+\n+   A consequence of this is that there's at most one debug-only loc in\n+   each loc list.  If we keep it in the first entry, testing whether\n+   we have a debug-only loc list takes O(1).\n+\n+   Furthermore, since any additional entry in a loc list containing a\n+   debug loc would have to come from an assignment (nondebug) that\n+   references both the initial debug loc and the newly-equivalent loc,\n+   the initial debug loc would be promoted to a nondebug loc, and the\n+   loc list would not contain debug locs any more.\n+\n+   So the only case we have to be careful with in order to keep\n+   n_useless_values in sync between debug and nondebug compilations is\n+   to avoid incrementing n_useless_values when removing the single loc\n+   from a value that turns out to not appear outside debug values.  We\n+   increment n_useless_debug_values instead, and leave such values\n+   alone until, for other reasons, we garbage-collect useless\n+   values.  */\n static int n_useless_values;\n+static int n_useless_debug_values;\n+\n+/* Count values whose locs have been taken exclusively from debug\n+   insns for the entire life of the value.  */\n+static int n_debug_values;\n \n /* Number of useless values before we remove them from the hash table.  */\n #define MAX_USELESS_VALUES 32\n@@ -188,9 +226,33 @@ new_elt_loc_list (struct elt_loc_list *next, rtx loc)\n   el->next = next;\n   el->loc = loc;\n   el->setting_insn = cselib_current_insn;\n+  gcc_assert (!next || !next->setting_insn\n+\t      || !DEBUG_INSN_P (next->setting_insn));\n+\n+  /* If we're creating the first loc in a debug insn context, we've\n+     just created a debug value.  Count it.  */\n+  if (!next && cselib_current_insn && DEBUG_INSN_P (cselib_current_insn))\n+    n_debug_values++;\n+\n   return el;\n }\n \n+/* Promote loc L to a nondebug cselib_current_insn if L is marked as\n+   originating from a debug insn, maintaining the debug values\n+   count.  */\n+\n+static inline void\n+promote_debug_loc (struct elt_loc_list *l)\n+{\n+  if (l->setting_insn && DEBUG_INSN_P (l->setting_insn)\n+      && (!cselib_current_insn || !DEBUG_INSN_P (cselib_current_insn)))\n+    {\n+      n_debug_values--;\n+      l->setting_insn = cselib_current_insn;\n+      gcc_assert (!l->next);\n+    }\n+}\n+\n /* The elt_list at *PL is no longer needed.  Unchain it and free its\n    storage.  */\n \n@@ -305,6 +367,8 @@ cselib_reset_table (unsigned int num)\n     htab_empty (cselib_hash_table);\n \n   n_useless_values = 0;\n+  n_useless_debug_values = 0;\n+  n_debug_values = 0;\n \n   next_uid = num;\n \n@@ -349,7 +413,10 @@ entry_and_rtx_equal_p (const void *entry, const void *x_arg)\n      so we need to do a comparison.  */\n   for (l = v->locs; l; l = l->next)\n     if (rtx_equal_for_cselib_p (l->loc, x))\n-      return 1;\n+      {\n+\tpromote_debug_loc (l);\n+\treturn 1;\n+      }\n \n   return 0;\n }\n@@ -403,7 +470,8 @@ discard_useless_locs (void **x, void *info ATTRIBUTE_UNUSED)\n {\n   cselib_val *v = (cselib_val *)*x;\n   struct elt_loc_list **p = &v->locs;\n-  int had_locs = v->locs != 0;\n+  bool had_locs = v->locs != NULL;\n+  rtx setting_insn = v->locs ? v->locs->setting_insn : NULL;\n \n   while (*p)\n     {\n@@ -415,7 +483,10 @@ discard_useless_locs (void **x, void *info ATTRIBUTE_UNUSED)\n \n   if (had_locs && v->locs == 0 && !PRESERVED_VALUE_P (v->val_rtx))\n     {\n-      n_useless_values++;\n+      if (setting_insn && DEBUG_INSN_P (setting_insn))\n+\tn_useless_debug_values++;\n+      else\n+\tn_useless_values++;\n       values_became_useless = 1;\n     }\n   return 1;\n@@ -449,6 +520,7 @@ static void\n remove_useless_values (void)\n {\n   cselib_val **p, *v;\n+\n   /* First pass: eliminate locations that reference the value.  That in\n      turn can make more values useless.  */\n   do\n@@ -469,6 +541,10 @@ remove_useless_values (void)\n       }\n   *p = &dummy_val;\n \n+  n_useless_values += n_useless_debug_values;\n+  n_debug_values -= n_useless_debug_values;\n+  n_useless_debug_values = 0;\n+\n   htab_traverse (cselib_hash_table, discard_useless_values, 0);\n \n   gcc_assert (!n_useless_values);\n@@ -947,7 +1023,10 @@ add_mem_for_addr (cselib_val *addr_elt, cselib_val *mem_elt, rtx x)\n   for (l = mem_elt->locs; l; l = l->next)\n     if (MEM_P (l->loc)\n \t&& CSELIB_VAL_PTR (XEXP (l->loc, 0)) == addr_elt)\n-      return;\n+      {\n+\tpromote_debug_loc (l);\n+\treturn;\n+      }\n \n   addr_elt->addr_list = new_elt_list (addr_elt->addr_list, mem_elt);\n   mem_elt->locs\n@@ -985,7 +1064,10 @@ cselib_lookup_mem (rtx x, int create)\n   /* Find a value that describes a value of our mode at that address.  */\n   for (l = addr->addr_list; l; l = l->next)\n     if (GET_MODE (l->elt->val_rtx) == mode)\n-      return l->elt;\n+      {\n+\tpromote_debug_loc (l->elt->locs);\n+\treturn l->elt;\n+      }\n \n   if (! create)\n     return 0;\n@@ -1516,30 +1598,13 @@ cselib_subst_to_values (rtx x)\n   return copy;\n }\n \n-/* Log a lookup of X to the cselib table along with the result RET.  */\n-\n-static cselib_val *\n-cselib_log_lookup (rtx x, cselib_val *ret)\n-{\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fputs (\"cselib lookup \", dump_file);\n-      print_inline_rtx (dump_file, x, 2);\n-      fprintf (dump_file, \" => %u:%u\\n\",\n-\t       ret ? ret->uid : 0,\n-\t       ret ? ret->hash : 0);\n-    }\n-\n-  return ret;\n-}\n-\n /* Look up the rtl expression X in our tables and return the value it has.\n    If CREATE is zero, we return NULL if we don't know the value.  Otherwise,\n    we create a new one if possible, using mode MODE if X doesn't have a mode\n    (i.e. because it's a constant).  */\n \n-cselib_val *\n-cselib_lookup (rtx x, enum machine_mode mode, int create)\n+static cselib_val *\n+cselib_lookup_1 (rtx x, enum machine_mode mode, int create)\n {\n   void **slot;\n   cselib_val *e;\n@@ -1561,10 +1626,13 @@ cselib_lookup (rtx x, enum machine_mode mode, int create)\n \tl = l->next;\n       for (; l; l = l->next)\n \tif (mode == GET_MODE (l->elt->val_rtx))\n-\t  return cselib_log_lookup (x, l->elt);\n+\t  {\n+\t    promote_debug_loc (l->elt->locs);\n+\t    return l->elt;\n+\t  }\n \n       if (! create)\n-\treturn cselib_log_lookup (x, 0);\n+\treturn 0;\n \n       if (i < FIRST_PSEUDO_REGISTER)\n \t{\n@@ -1587,25 +1655,25 @@ cselib_lookup (rtx x, enum machine_mode mode, int create)\n       REG_VALUES (i)->next = new_elt_list (REG_VALUES (i)->next, e);\n       slot = htab_find_slot_with_hash (cselib_hash_table, x, e->hash, INSERT);\n       *slot = e;\n-      return cselib_log_lookup (x, e);\n+      return e;\n     }\n \n   if (MEM_P (x))\n-    return cselib_log_lookup (x, cselib_lookup_mem (x, create));\n+    return cselib_lookup_mem (x, create);\n \n   hashval = cselib_hash_rtx (x, create);\n   /* Can't even create if hashing is not possible.  */\n   if (! hashval)\n-    return cselib_log_lookup (x, 0);\n+    return 0;\n \n   slot = htab_find_slot_with_hash (cselib_hash_table, wrap_constant (mode, x),\n \t\t\t\t   hashval, create ? INSERT : NO_INSERT);\n   if (slot == 0)\n-    return cselib_log_lookup (x, 0);\n+    return 0;\n \n   e = (cselib_val *) *slot;\n   if (e)\n-    return cselib_log_lookup (x, e);\n+    return e;\n \n   e = new_cselib_val (hashval, mode, x);\n \n@@ -1614,7 +1682,51 @@ cselib_lookup (rtx x, enum machine_mode mode, int create)\n      cselib_subst_to_values will need to do lookups.  */\n   *slot = (void *) e;\n   e->locs = new_elt_loc_list (e->locs, cselib_subst_to_values (x));\n-  return cselib_log_lookup (x, e);\n+  return e;\n+}\n+\n+/* Wrapper for cselib_lookup, that indicates X is in INSN.  */\n+\n+cselib_val *\n+cselib_lookup_from_insn (rtx x, enum machine_mode mode,\n+\t\t\t int create, rtx insn)\n+{\n+  cselib_val *ret;\n+\n+  gcc_assert (!cselib_current_insn);\n+  cselib_current_insn = insn;\n+\n+  ret = cselib_lookup (x, mode, create);\n+\n+  cselib_current_insn = NULL;\n+\n+  return ret;\n+}\n+\n+/* Wrapper for cselib_lookup_1, that logs the lookup result and\n+   maintains invariants related with debug insns.  */\n+\n+cselib_val *\n+cselib_lookup (rtx x, enum machine_mode mode, int create)\n+{\n+  cselib_val *ret = cselib_lookup_1 (x, mode, create);\n+\n+  /* ??? Should we return NULL if we're not to create an entry, the\n+     found loc is a debug loc and cselib_current_insn is not DEBUG?\n+     If so, we should also avoid converting val to non-DEBUG; probably\n+     easiest setting cselib_current_insn to NULL before the call\n+     above.  */\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fputs (\"cselib lookup \", dump_file);\n+      print_inline_rtx (dump_file, x, 2);\n+      fprintf (dump_file, \" => %u:%u\\n\",\n+\t       ret ? ret->uid : 0,\n+\t       ret ? ret->hash : 0);\n+    }\n+\n+  return ret;\n }\n \n /* Invalidate any entries in reg_values that overlap REGNO.  This is called\n@@ -1663,6 +1775,8 @@ cselib_invalidate_regno (unsigned int regno, enum machine_mode mode)\n       while (*l)\n \t{\n \t  cselib_val *v = (*l)->elt;\n+\t  bool had_locs;\n+\t  rtx setting_insn;\n \t  struct elt_loc_list **p;\n \t  unsigned int this_last = i;\n \n@@ -1689,6 +1803,9 @@ cselib_invalidate_regno (unsigned int regno, enum machine_mode mode)\n \t  else\n \t    unchain_one_elt_list (l);\n \n+\t  had_locs = v->locs != NULL;\n+\t  setting_insn = v->locs ? v->locs->setting_insn : NULL;\n+\n \t  /* Now, we clear the mapping from value to reg.  It must exist, so\n \t     this code will crash intentionally if it doesn't.  */\n \t  for (p = &v->locs; ; p = &(*p)->next)\n@@ -1701,8 +1818,14 @@ cselib_invalidate_regno (unsigned int regno, enum machine_mode mode)\n \t\t  break;\n \t\t}\n \t    }\n-\t  if (v->locs == 0 && !PRESERVED_VALUE_P (v->val_rtx))\n-\t    n_useless_values++;\n+\n+\t  if (had_locs && v->locs == 0 && !PRESERVED_VALUE_P (v->val_rtx))\n+\t    {\n+\t      if (setting_insn && DEBUG_INSN_P (setting_insn))\n+\t\tn_useless_debug_values++;\n+\t      else\n+\t\tn_useless_values++;\n+\t    }\n \t}\n     }\n }\n@@ -1740,7 +1863,8 @@ cselib_invalidate_mem (rtx mem_rtx)\n     {\n       bool has_mem = false;\n       struct elt_loc_list **p = &v->locs;\n-      int had_locs = v->locs != 0;\n+      bool had_locs = v->locs != NULL;\n+      rtx setting_insn = v->locs ? v->locs->setting_insn : NULL;\n \n       while (*p)\n \t{\n@@ -1785,7 +1909,12 @@ cselib_invalidate_mem (rtx mem_rtx)\n \t}\n \n       if (had_locs && v->locs == 0 && !PRESERVED_VALUE_P (v->val_rtx))\n-\tn_useless_values++;\n+\t{\n+\t  if (setting_insn && DEBUG_INSN_P (setting_insn))\n+\t    n_useless_debug_values++;\n+\t  else\n+\t    n_useless_values++;\n+\t}\n \n       next = v->next_containing_mem;\n       if (has_mem)\n@@ -2079,7 +2208,10 @@ cselib_process_insn (rtx insn)\n       /* remove_useless_values is linear in the hash table size.  Avoid\n          quadratic behavior for very large hashtables with very few\n \t useless elements.  */\n-      && (unsigned int)n_useless_values > cselib_hash_table->n_elements / 4)\n+      && ((unsigned int)n_useless_values\n+\t  > (cselib_hash_table->n_elements\n+\t     - cselib_hash_table->n_deleted\n+\t     - n_debug_values) / 4))\n     remove_useless_values ();\n }\n \n@@ -2143,6 +2275,8 @@ cselib_finish (void)\n   used_regs = 0;\n   cselib_hash_table = 0;\n   n_useless_values = 0;\n+  n_useless_debug_values = 0;\n+  n_debug_values = 0;\n   next_uid = 0;\n }\n "}, {"sha": "90d963888c6aca1485c8412c012fcbcc249a6e68", "filename": "gcc/cselib.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5847e8da2f62aa638ca037e2e02ef6f2de2975a0/gcc%2Fcselib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5847e8da2f62aa638ca037e2e02ef6f2de2975a0/gcc%2Fcselib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.h?ref=5847e8da2f62aa638ca037e2e02ef6f2de2975a0", "patch": "@@ -77,6 +77,7 @@ extern void (*cselib_record_sets_hook) (rtx insn, struct cselib_set *sets,\n \t\t\t\t\tint n_sets);\n \n extern cselib_val *cselib_lookup (rtx, enum machine_mode, int);\n+extern cselib_val *cselib_lookup_from_insn (rtx, enum machine_mode, int, rtx);\n extern void cselib_init (int);\n extern void cselib_clear_table (void);\n extern void cselib_finish (void);"}, {"sha": "974ffd779b024e425637d6b80e2e8d05f48fe29b", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5847e8da2f62aa638ca037e2e02ef6f2de2975a0/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5847e8da2f62aa638ca037e2e02ef6f2de2975a0/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=5847e8da2f62aa638ca037e2e02ef6f2de2975a0", "patch": "@@ -2286,7 +2286,7 @@ sched_analyze_1 (struct deps *deps, rtx x, rtx insn)\n \t    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (dest));\n \n \t  t = shallow_copy_rtx (dest);\n-\t  cselib_lookup (XEXP (t, 0), address_mode, 1);\n+\t  cselib_lookup_from_insn (XEXP (t, 0), address_mode, 1, insn);\n \t  XEXP (t, 0) = cselib_subst_to_values (XEXP (t, 0));\n \t}\n       t = canon_rtx (t);\n@@ -2443,7 +2443,7 @@ sched_analyze_2 (struct deps *deps, rtx x, rtx insn)\n \t      = targetm.addr_space.address_mode (MEM_ADDR_SPACE (t));\n \n \t    t = shallow_copy_rtx (t);\n-\t    cselib_lookup (XEXP (t, 0), address_mode, 1);\n+\t    cselib_lookup_from_insn (XEXP (t, 0), address_mode, 1, insn);\n \t    XEXP (t, 0) = cselib_subst_to_values (XEXP (t, 0));\n \t  }\n "}]}