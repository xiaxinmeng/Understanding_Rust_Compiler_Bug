{"sha": "db1a8d988963af9d6891316fc565b5aa38e334be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGIxYThkOTg4OTYzYWY5ZDY4OTEzMTZmYzU2NWI1YWEzOGUzMzRiZQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2009-07-22T22:00:17Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2009-07-22T22:00:17Z"}, "message": "re PR target/37488 (register allocation spills floats needlessly)\n\n2009-07-22  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR target/37488\n\t* ira-lives.c (bb_has_abnormal_call_pred): New function.\n\t(process_bb_node_lives): Use it.\n\n\t* ira.c (setup_cover_and_important_classes): Don't setup\n\tira_important_class_nums.  Add cover classes to the end of\n\timportant classes.\n\t(cover_class_order, comp_reg_classes_func,\n\treorder_important_classes): New.\n\t(find_reg_class_closure): Use reorder_important_classes.\n\n\t* config/i386/i386.h (IRA_COVER_CLASSES): Remove.\n\n\t* config/i386/i386.c (i386_ira_cover_classes): New function.\n\t(TARGET_IRA_COVER_CLASSES): Redefine.\n\n\t* doc/tm.texi (TARGET_IRA_COVER_CLASSES): Add a comment about\n\timportance of order of cover classes in the array.\n\nFrom-SVN: r149962", "tree": {"sha": "e6debce284f28f6755b99e28e2d7cd846214ef7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6debce284f28f6755b99e28e2d7cd846214ef7d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db1a8d988963af9d6891316fc565b5aa38e334be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db1a8d988963af9d6891316fc565b5aa38e334be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db1a8d988963af9d6891316fc565b5aa38e334be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db1a8d988963af9d6891316fc565b5aa38e334be/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cae63f886fb819cd96eafb32964949bc8d6e9a4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cae63f886fb819cd96eafb32964949bc8d6e9a4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cae63f886fb819cd96eafb32964949bc8d6e9a4f"}], "stats": {"total": 142, "additions": 111, "deletions": 31}, "files": [{"sha": "774c458a3bf37b2cfc90b9fac4d87dc032bee355", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db1a8d988963af9d6891316fc565b5aa38e334be/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db1a8d988963af9d6891316fc565b5aa38e334be/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=db1a8d988963af9d6891316fc565b5aa38e334be", "patch": "@@ -1,3 +1,24 @@\n+2009-07-22  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR target/37488\n+\t* ira-lives.c (bb_has_abnormal_call_pred): New function.\n+\t(process_bb_node_lives): Use it.\n+\n+\t* ira.c (setup_cover_and_important_classes): Don't setup\n+\tira_important_class_nums.  Add cover classes to the end of\n+\timportant classes.\n+\t(cover_class_order, comp_reg_classes_func,\n+\treorder_important_classes): New.\n+\t(find_reg_class_closure): Use reorder_important_classes.\n+\n+\t* config/i386/i386.h (IRA_COVER_CLASSES): Remove.\n+\n+\t* config/i386/i386.c (i386_ira_cover_classes): New function.\n+\t(TARGET_IRA_COVER_CLASSES): Redefine.\n+\n+\t* doc/tm.texi (TARGET_IRA_COVER_CLASSES): Add a comment about\n+\timportance of order of cover classes in the array.\n+\t\n 2009-07-22  Diego Novillo  <dnovillo@google.com>\n \n \t* tree-pass.h (TDF_EH): Define."}, {"sha": "c11c34aefde53ed8ccbe956303ced7a2858d6531", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db1a8d988963af9d6891316fc565b5aa38e334be/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db1a8d988963af9d6891316fc565b5aa38e334be/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=db1a8d988963af9d6891316fc565b5aa38e334be", "patch": "@@ -26132,6 +26132,22 @@ ix86_free_from_memory (enum machine_mode mode)\n     }\n }\n \n+/* Implement TARGET_IRA_COVER_CLASSES.  If -mfpmath=sse, we prefer\n+   SSE_REGS to FLOAT_REGS if their costs for a pseudo are the\n+   same.  */\n+static const enum reg_class *\n+i386_ira_cover_classes (void)\n+{\n+  static const enum reg_class sse_fpmath_classes[] = {\n+    GENERAL_REGS, SSE_REGS, MMX_REGS, FLOAT_REGS, LIM_REG_CLASSES\n+  };\n+  static const enum reg_class no_sse_fpmath_classes[] = {\n+    GENERAL_REGS, FLOAT_REGS, MMX_REGS, SSE_REGS, LIM_REG_CLASSES\n+  };\n+\n+ return TARGET_SSE_MATH ? sse_fpmath_classes : no_sse_fpmath_classes;\n+}\n+\n /* Put float CONST_DOUBLE in the constant pool instead of fp regs.\n    QImode must go into class Q_REGS.\n    Narrow ALL_REGS to GENERAL_REGS.  This supports allowing movsf and\n@@ -30652,6 +30668,9 @@ ix86_enum_va_list (int idx, const char **pname, tree *ptree)\n #undef TARGET_LEGITIMATE_ADDRESS_P\n #define TARGET_LEGITIMATE_ADDRESS_P ix86_legitimate_address_p\n \n+#undef TARGET_IRA_COVER_CLASSES\n+#define TARGET_IRA_COVER_CLASSES i386_ira_cover_classes\n+\n #undef TARGET_FRAME_POINTER_REQUIRED\n #define TARGET_FRAME_POINTER_REQUIRED ix86_frame_pointer_required\n "}, {"sha": "15ac4d38247b53bf18f7c1e14a7b81d1ede21329", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db1a8d988963af9d6891316fc565b5aa38e334be/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db1a8d988963af9d6891316fc565b5aa38e334be/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=db1a8d988963af9d6891316fc565b5aa38e334be", "patch": "@@ -1288,19 +1288,6 @@ enum reg_class\n { 0xffffffff,0x1fffff }\t\t\t\t\t\t\t\\\n }\n \n-/* The following macro defines cover classes for Integrated Register\n-   Allocator.  Cover classes is a set of non-intersected register\n-   classes covering all hard registers used for register allocation\n-   purpose.  Any move between two registers of a cover class should be\n-   cheaper than load or store of the registers.  The macro value is\n-   array of register classes with LIM_REG_CLASSES used as the end\n-   marker.  */\n-\n-#define IRA_COVER_CLASSES\t\t\t\t\t\t     \\\n-{\t\t\t\t\t\t\t\t\t     \\\n-  GENERAL_REGS, FLOAT_REGS, MMX_REGS, SSE_REGS, LIM_REG_CLASSES\t\t     \\\n-}\n-\n /* The same information, inverted:\n    Return the class number of the smallest class containing\n    reg number REGNO.  This could be a conditional expression"}, {"sha": "8157714e1f60e8ac4bccbbdc9647c85e5e6e204f", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db1a8d988963af9d6891316fc565b5aa38e334be/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db1a8d988963af9d6891316fc565b5aa38e334be/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=db1a8d988963af9d6891316fc565b5aa38e334be", "patch": "@@ -2913,6 +2913,10 @@ purposes.  If a move between two registers in the same cover class is\n possible, it should be cheaper than a load or store of the registers.\n The array is terminated by a @code{LIM_REG_CLASSES} element.\n \n+The order of cover classes in the array is important.  If two classes\n+have the same cost of usage for a pseudo, the class occurred first in\n+the array is chosen for the pseudo.\n+\n This hook is called once at compiler startup, after the command-line\n options have been processed. It is then re-examined by every call to\n @code{target_reinit}."}, {"sha": "c010f679d37bf99857e9705c184757889ecb1171", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db1a8d988963af9d6891316fc565b5aa38e334be/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db1a8d988963af9d6891316fc565b5aa38e334be/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=db1a8d988963af9d6891316fc565b5aa38e334be", "patch": "@@ -814,6 +814,22 @@ process_single_reg_class_operands (bool in_p, int freq)\n     }\n }\n \n+/* Return true when one of the predecessor edges of BB is marked with\n+   EDGE_ABNORMAL_CALL or EDGE_EH.  */\n+static bool\n+bb_has_abnormal_call_pred (basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  \n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    {\n+      if (e->flags & (EDGE_ABNORMAL_CALL | EDGE_EH))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n /* Process insns of the basic block given by its LOOP_TREE_NODE to\n    update allocno live ranges, allocno hard register conflicts,\n    intersected calls, and register pressure info for allocnos for the\n@@ -1062,7 +1078,7 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t  /* No need to record conflicts for call clobbered regs if we\n \t     have nonlocal labels around, as we don't ever try to\n \t     allocate such regs in this case.  */\n-\t  if (!cfun->has_nonlocal_label)\n+\t  if (!cfun->has_nonlocal_label && bb_has_abnormal_call_pred (bb))\n \t    for (px = 0; px < FIRST_PSEUDO_REGISTER; px++)\n \t      if (call_used_regs[px])\n \t\tmake_regno_born (px);"}, {"sha": "e4caf31fb8d6674167f86ad146a28863139724a2", "filename": "gcc/ira.c", "status": "modified", "additions": 50, "deletions": 17, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db1a8d988963af9d6891316fc565b5aa38e334be/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db1a8d988963af9d6891316fc565b5aa38e334be/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=db1a8d988963af9d6891316fc565b5aa38e334be", "patch": "@@ -729,7 +729,7 @@ static void\n setup_cover_and_important_classes (void)\n {\n   int i, j, n, cl;\n-  bool set_p, eq_p;\n+  bool set_p;\n   const enum reg_class *cover_classes;\n   HARD_REG_SET temp_hard_regset2;\n   static enum reg_class classes[LIM_REG_CLASSES + 1];\n@@ -802,35 +802,30 @@ setup_cover_and_important_classes (void)\n       AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n       if (! hard_reg_set_empty_p (temp_hard_regset))\n \t{\n-\t  set_p = eq_p = false;\n+\t  set_p = false;\n \t  for (j = 0; j < ira_reg_class_cover_size; j++)\n \t    {\n \t      COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl]);\n \t      AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n \t      COPY_HARD_REG_SET (temp_hard_regset2,\n \t\t\t\t reg_class_contents[ira_reg_class_cover[j]]);\n \t      AND_COMPL_HARD_REG_SET (temp_hard_regset2, no_unit_alloc_regs);\n-\t      if ((enum reg_class) cl == ira_reg_class_cover[j])\n-\t\t{\n-\t\t  eq_p = false;\n-\t\t  set_p = true;\n-\t\t  break;\n-\t\t}\n-\t      else if (hard_reg_set_equal_p (temp_hard_regset,\n-\t\t\t\t\t     temp_hard_regset2))\n-\t\teq_p = true;\n+\t      if ((enum reg_class) cl == ira_reg_class_cover[j]\n+\t\t  || hard_reg_set_equal_p (temp_hard_regset,\n+\t\t\t\t\t   temp_hard_regset2))\n+\t\tbreak;\n \t      else if (hard_reg_set_subset_p (temp_hard_regset,\n \t\t\t\t\t      temp_hard_regset2))\n \t\tset_p = true;\n \t    }\n-\t  if (set_p && ! eq_p)\n-\t    {\n-\t      ira_important_class_nums[cl] = ira_important_classes_num;\n-\t      ira_important_classes[ira_important_classes_num++] =\n-\t\t(enum reg_class) cl;\n-\t    }\n+\t  if (set_p && j >= ira_reg_class_cover_size)\n+\t    ira_important_classes[ira_important_classes_num++]\n+\t      = (enum reg_class) cl;\n \t}\n     }\n+  for (j = 0; j < ira_reg_class_cover_size; j++)\n+    ira_important_classes[ira_important_classes_num++]\n+      = ira_reg_class_cover[j];\n }\n \n /* Map of all register classes to corresponding cover class containing\n@@ -925,6 +920,43 @@ setup_class_translate (void)\n     }\n }\n \n+/* Order numbers of cover classes in original target cover class\n+   array, -1 for non-cover classes.  */ \n+static int cover_class_order[N_REG_CLASSES];\n+\n+/* The function used to sort the important classes.  */\n+static int\n+comp_reg_classes_func (const void *v1p, const void *v2p)\n+{\n+  enum reg_class cl1 = *(const enum reg_class *) v1p;\n+  enum reg_class cl2 = *(const enum reg_class *) v2p;\n+  int diff;\n+\n+  cl1 = ira_class_translate[cl1];\n+  cl2 = ira_class_translate[cl2];\n+  if (cl1 != NO_REGS && cl2 != NO_REGS\n+      && (diff = cover_class_order[cl1] - cover_class_order[cl2]) != 0)\n+    return diff;\n+  return (int) cl1 - (int) cl2;\n+}\n+\n+/* Reorder important classes according to the order of their cover\n+   classes.  Set up array ira_important_class_nums too.  */\n+static void\n+reorder_important_classes (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < N_REG_CLASSES; i++)\n+    cover_class_order[i] = -1;\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n+    cover_class_order[ira_reg_class_cover[i]] = i;\n+  qsort (ira_important_classes, ira_important_classes_num,\n+\t sizeof (enum reg_class), comp_reg_classes_func);\n+  for (i = 0; i < ira_important_classes_num; i++)\n+    ira_important_class_nums[ira_important_classes[i]] = i;\n+}\n+\n /* The biggest important reg_class inside of intersection of the two\n    reg_classes (that is calculated taking only hard registers\n    available for allocation into account).  If the both reg_classes\n@@ -1089,6 +1121,7 @@ find_reg_class_closure (void)\n   setup_reg_subclasses ();\n   setup_cover_and_important_classes ();\n   setup_class_translate ();\n+  reorder_important_classes ();\n   setup_reg_class_relations ();\n }\n "}]}