{"sha": "b81f2dafdbd2c5aa49213b35dc12d4610834e39e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjgxZjJkYWZkYmQyYzVhYTQ5MjEzYjM1ZGMxMmQ0NjEwODM0ZTM5ZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-10-30T13:52:27Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-10-30T13:52:27Z"}, "message": "re PR tree-optimization/92275 (ICE: error: definition in block 11 does not dominate use in block 15 since r277566)\n\n2019-10-30  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/92275\n\t* tree-vect-loop-manip.c (slpeel_update_phi_nodes_for_loops):\n\tCopy all loop-closed PHIs.\n\n\t* gcc.dg/torture/pr92275.c: New testcase.\n\nFrom-SVN: r277621", "tree": {"sha": "b06a85d760253f856e8043dab8a3fa8b7e3e5640", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b06a85d760253f856e8043dab8a3fa8b7e3e5640"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b81f2dafdbd2c5aa49213b35dc12d4610834e39e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b81f2dafdbd2c5aa49213b35dc12d4610834e39e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b81f2dafdbd2c5aa49213b35dc12d4610834e39e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b81f2dafdbd2c5aa49213b35dc12d4610834e39e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "095578b5bc9f2ff72785ff14626c6a803c973176", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/095578b5bc9f2ff72785ff14626c6a803c973176", "html_url": "https://github.com/Rust-GCC/gccrs/commit/095578b5bc9f2ff72785ff14626c6a803c973176"}], "stats": {"total": 93, "additions": 70, "deletions": 23}, "files": [{"sha": "40e2c3ff9383ff73db41bc5676a846a1709ed465", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b81f2dafdbd2c5aa49213b35dc12d4610834e39e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b81f2dafdbd2c5aa49213b35dc12d4610834e39e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b81f2dafdbd2c5aa49213b35dc12d4610834e39e", "patch": "@@ -1,3 +1,9 @@\n+2019-10-30  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/92275\n+\t* tree-vect-loop-manip.c (slpeel_update_phi_nodes_for_loops):\n+\tCopy all loop-closed PHIs.\n+\n 2019-10-30  Martin Liska  <mliska@suse.cz>\n \n \t* ipa-icf-gimple.c (func_checker::compare_ssa_name): Use"}, {"sha": "10cf941529247b7598a1bc1fa67a8bbeb3b1528e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b81f2dafdbd2c5aa49213b35dc12d4610834e39e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b81f2dafdbd2c5aa49213b35dc12d4610834e39e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b81f2dafdbd2c5aa49213b35dc12d4610834e39e", "patch": "@@ -1,3 +1,8 @@\n+2019-10-30  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/92275\n+\t* gcc.dg/torture/pr92275.c: New testcase.\n+\n 2019-10-30  Jakub Jelinek  <jakub@redhat.com>\n \n \t* g++.dg/gomp/declare-variant-6.C: New test."}, {"sha": "b9f708897585d5accc9326ca89afdd441b47aa2d", "filename": "gcc/testsuite/gcc.dg/torture/pr92275.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b81f2dafdbd2c5aa49213b35dc12d4610834e39e/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr92275.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b81f2dafdbd2c5aa49213b35dc12d4610834e39e/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr92275.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr92275.c?ref=b81f2dafdbd2c5aa49213b35dc12d4610834e39e", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-ftree-vectorize\" } */\n+\n+unsigned long a, c;\n+int *b, *b2;\n+long d;\n+\n+void fn1()\n+{\n+  for (; b < b2; b++)\n+    d += *b * c;\n+  d *= a;\n+}"}, {"sha": "1fbcaf2676f3a099cccc5d4f63e18f4a689abeff", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 46, "deletions": 23, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b81f2dafdbd2c5aa49213b35dc12d4610834e39e/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b81f2dafdbd2c5aa49213b35dc12d4610834e39e/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=b81f2dafdbd2c5aa49213b35dc12d4610834e39e", "patch": "@@ -2004,6 +2004,29 @@ vect_gen_vector_loop_niters_mult_vf (loop_vec_info loop_vinfo,\n   *niters_vector_mult_vf_ptr = niters_vector_mult_vf;\n }\n \n+/* LCSSA_PHI is a lcssa phi of EPILOG loop which is copied from LOOP,\n+   this function searches for the corresponding lcssa phi node in exit\n+   bb of LOOP.  If it is found, return the phi result; otherwise return\n+   NULL.  */\n+\n+static tree\n+find_guard_arg (class loop *loop, class loop *epilog ATTRIBUTE_UNUSED,\n+\t\tgphi *lcssa_phi)\n+{\n+  gphi_iterator gsi;\n+  edge e = single_exit (loop);\n+\n+  gcc_assert (single_pred_p (e->dest));\n+  for (gsi = gsi_start_phis (e->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gphi *phi = gsi.phi ();\n+      if (operand_equal_p (PHI_ARG_DEF (phi, 0),\n+\t\t\t   PHI_ARG_DEF (lcssa_phi, 0), 0))\n+\treturn PHI_RESULT (phi);\n+    }\n+  return NULL_TREE;\n+}\n+\n /* Function slpeel_tree_duplicate_loop_to_edge_cfg duplciates FIRST/SECOND\n    from SECOND/FIRST and puts it at the original loop's preheader/exit\n    edge, the two loops are arranged as below:\n@@ -2091,6 +2114,29 @@ slpeel_update_phi_nodes_for_loops (loop_vec_info loop_vinfo,\n \t incoming edge.  */\n       adjust_phi_and_debug_stmts (update_phi, second_preheader_e, arg);\n     }\n+\n+  /* For epilogue peeling we have to make sure to copy all LC PHIs\n+     for correct vectorization of live stmts.  */\n+  if (loop == first)\n+    {\n+      basic_block orig_exit = single_exit (second)->dest;\n+      for (gsi_orig = gsi_start_phis (orig_exit);\n+\t   !gsi_end_p (gsi_orig); gsi_next (&gsi_orig))\n+\t{\n+\t  gphi *orig_phi = gsi_orig.phi ();\n+\t  tree orig_arg = PHI_ARG_DEF (orig_phi, 0);\n+\t  if (TREE_CODE (orig_arg) != SSA_NAME || virtual_operand_p  (orig_arg))\n+\t    continue;\n+\n+\t  /* Already created in the above loop.   */\n+\t  if (find_guard_arg (first, second, orig_phi))\n+\t    continue;\n+\n+\t  tree new_res = copy_ssa_name (orig_arg);\n+\t  gphi *lcphi = create_phi_node (new_res, between_bb);\n+\t  add_phi_arg (lcphi, orig_arg, single_exit (first), UNKNOWN_LOCATION);\n+\t}\n+    }\n }\n \n /* Function slpeel_add_loop_guard adds guard skipping from the beginning\n@@ -2175,29 +2221,6 @@ slpeel_update_phi_nodes_for_guard1 (class loop *skip_loop,\n     }\n }\n \n-/* LCSSA_PHI is a lcssa phi of EPILOG loop which is copied from LOOP,\n-   this function searches for the corresponding lcssa phi node in exit\n-   bb of LOOP.  If it is found, return the phi result; otherwise return\n-   NULL.  */\n-\n-static tree\n-find_guard_arg (class loop *loop, class loop *epilog ATTRIBUTE_UNUSED,\n-\t\tgphi *lcssa_phi)\n-{\n-  gphi_iterator gsi;\n-  edge e = single_exit (loop);\n-\n-  gcc_assert (single_pred_p (e->dest));\n-  for (gsi = gsi_start_phis (e->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      gphi *phi = gsi.phi ();\n-      if (operand_equal_p (PHI_ARG_DEF (phi, 0),\n-\t\t\t   PHI_ARG_DEF (lcssa_phi, 0), 0))\n-\treturn PHI_RESULT (phi);\n-    }\n-  return NULL_TREE;\n-}\n-\n /* LOOP and EPILOG are two consecutive loops in CFG and EPILOG is copied\n    from LOOP.  Function slpeel_add_loop_guard adds guard skipping from a\n    point between the two loops to the end of EPILOG.  Edges GUARD_EDGE"}]}