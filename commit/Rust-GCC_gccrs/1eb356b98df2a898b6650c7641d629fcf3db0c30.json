{"sha": "1eb356b98df2a898b6650c7641d629fcf3db0c30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWViMzU2Yjk4ZGYyYTg5OGI2NjUwYzc2NDFkNjI5ZmNmM2RiMGMzMA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-09-09T08:42:40Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-09-09T08:42:40Z"}, "message": "alpha.c (alpha_next_sequence_number): New.\n\n\t* config/alpha/alpha.c (alpha_next_sequence_number): New.\n\t(alpha_this_literal_sequence_number): New.\n\t(alpha_this_gpdisp_sequence_number): New.\n\t(some_operand, input_operand): Add HIGH.\n\t(local_symbolic_operand): New.\n\t(alpha_encode_section_info): New.\n\t(alpha_legitimate_address_p): Allow LO_SUM.\n\t(alpha_legitimize_address): Generate HIGH+LO_SUM.\n\t(alpha_expand_mov): Likewise.\n\t(secondary_reload_class): Check memory_operand not general_operand\n\tfor FP_REGS test.\n\t(alpha_expand_unaligned_load): Force LO_SUM addresses into a register.\n\t(alpha_expand_unaligned_store): Likewise.\n\t(alpha_expand_unaligned_load_words): Likewise.\n\t(alpha_expand_unaligned_store_words): Likewise.\n\t(alpha_expand_block_clear): Likewise.\n\t(print_operand): Handle %#, %*, %H.\n\t(print_operand_address): Handle LO_SUM.\n\t(find_lo_sum): New.\n\t(alpha_does_function_need_gp): Use it.\n\t(alpha_expand_block_move): Fix signed compare warnings.\n\t(alpha_sa_mask, alpha_align_insns): Likewise.\n\t* config/alpha/alpha-protos.h: Update.\n\t* config/alpha/alpha.h (TARGET_EXPLICIT_RELOCS): New.\n\t(MASK_EXPLICIT_RELOCS): New.\n\t(TARGET_SWITCHES): Add -mexplicit-relocs.\n\t(EXTRA_CONSTRAINT): Add 'T'.\n\t(PREFERRED_RELOAD_CLASS): HIGH goes in GENERAL_REGS.\n\t(ASM_APP_ON, ASM_APP_OFF): Turn on and off asm macro expansion.\n\t(ENCODE_SECTION_INFO): Out line.\n\t(REDO_SECTION_INFO_P): New.\n\t(STRIP_NAME_ENCODING): New.\n\t(ASM_OUTPUT_LABELREF): New.\n\t(PRINT_OPERAND_PUNCT_VALID_P): Add #, *.\n\t(PREDICATE_CODES): Update.\n\t* config/alpha/alpha.md (divmodsi_internal_er, divmoddi_internal_er,\n\tcall_osf_1_er_noreturn, call_osf_1_er, movdi_er_low, movdi_er_nofix,\n\tmovdi_er_fix, prologue_ldgp_1_er, builtin_setjmp_receiver_sub_label_er,\n\tbuiltin_setjmp_receiver_er, exception_receiver_1_er,\n\tcall_value_osf_1_er): New patterns.\n\t(sibcall_osf_1, sibcall_value_osf_1): Remove register alternative.\n\t(movqi, movhi, movsi): Add explicit $31 base register to lda.\n\t* config/alpha/elf.h (ASM_FILE_START): Set nomacro if explicit relocs.\n\t(FINAL_PRESCAN_INSN): New.\n\nFrom-SVN: r45493", "tree": {"sha": "c209f79839fde1bfb438a2a4d2fad6450548aa06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c209f79839fde1bfb438a2a4d2fad6450548aa06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1eb356b98df2a898b6650c7641d629fcf3db0c30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eb356b98df2a898b6650c7641d629fcf3db0c30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1eb356b98df2a898b6650c7641d629fcf3db0c30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eb356b98df2a898b6650c7641d629fcf3db0c30/comments", "author": null, "committer": null, "parents": [{"sha": "7b95ee3ddae43edbda4ee0e47e3803d6dbb76291", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b95ee3ddae43edbda4ee0e47e3803d6dbb76291", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b95ee3ddae43edbda4ee0e47e3803d6dbb76291"}], "stats": {"total": 658, "additions": 581, "deletions": 77}, "files": [{"sha": "fddbac35d202728dadc097cc627281e025e28369", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb356b98df2a898b6650c7641d629fcf3db0c30/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb356b98df2a898b6650c7641d629fcf3db0c30/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1eb356b98df2a898b6650c7641d629fcf3db0c30", "patch": "@@ -1,3 +1,50 @@\n+2001-09-09  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/alpha/alpha.c (alpha_next_sequence_number): New.\n+\t(alpha_this_literal_sequence_number): New.\n+\t(alpha_this_gpdisp_sequence_number): New.\n+\t(some_operand, input_operand): Add HIGH.\n+\t(local_symbolic_operand): New.\n+\t(alpha_encode_section_info): New.\n+\t(alpha_legitimate_address_p): Allow LO_SUM.\n+\t(alpha_legitimize_address): Generate HIGH+LO_SUM.\n+\t(alpha_expand_mov): Likewise.\n+\t(secondary_reload_class): Check memory_operand not general_operand\n+\tfor FP_REGS test.\n+\t(alpha_expand_unaligned_load): Force LO_SUM addresses into a register.\n+\t(alpha_expand_unaligned_store): Likewise.\n+\t(alpha_expand_unaligned_load_words): Likewise.\n+\t(alpha_expand_unaligned_store_words): Likewise.\n+\t(alpha_expand_block_clear): Likewise.\n+\t(print_operand): Handle %#, %*, %H.\n+\t(print_operand_address): Handle LO_SUM.\n+\t(find_lo_sum): New.\n+\t(alpha_does_function_need_gp): Use it.\n+\t(alpha_expand_block_move): Fix signed compare warnings.\n+\t(alpha_sa_mask, alpha_align_insns): Likewise.\n+\t* config/alpha/alpha-protos.h: Update.\n+\t* config/alpha/alpha.h (TARGET_EXPLICIT_RELOCS): New.\n+\t(MASK_EXPLICIT_RELOCS): New.\n+\t(TARGET_SWITCHES): Add -mexplicit-relocs.\n+\t(EXTRA_CONSTRAINT): Add 'T'.\n+\t(PREFERRED_RELOAD_CLASS): HIGH goes in GENERAL_REGS.\n+\t(ASM_APP_ON, ASM_APP_OFF): Turn on and off asm macro expansion.\n+\t(ENCODE_SECTION_INFO): Out line.\n+\t(REDO_SECTION_INFO_P): New.\n+\t(STRIP_NAME_ENCODING): New.\n+\t(ASM_OUTPUT_LABELREF): New.\n+\t(PRINT_OPERAND_PUNCT_VALID_P): Add #, *.\n+\t(PREDICATE_CODES): Update.\n+\t* config/alpha/alpha.md (divmodsi_internal_er, divmoddi_internal_er,\n+\tcall_osf_1_er_noreturn, call_osf_1_er, movdi_er_low, movdi_er_nofix,\n+\tmovdi_er_fix, prologue_ldgp_1_er, builtin_setjmp_receiver_sub_label_er,\n+\tbuiltin_setjmp_receiver_er, exception_receiver_1_er,\n+\tcall_value_osf_1_er): New patterns.\n+\t(sibcall_osf_1, sibcall_value_osf_1): Remove register alternative.\n+\t(movqi, movhi, movsi): Add explicit $31 base register to lda.\n+\t* config/alpha/elf.h (ASM_FILE_START): Set nomacro if explicit relocs.\n+\t(FINAL_PRESCAN_INSN): New.\n+\n Sat Sep  8 22:00:55 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* reg-stack.c (subst_stack_regs_pat): Fix fcmov reversal code."}, {"sha": "be18c633910f832810f11b54b73b756e9ffbe6e5", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb356b98df2a898b6650c7641d629fcf3db0c30/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb356b98df2a898b6650c7641d629fcf3db0c30/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=1eb356b98df2a898b6650c7641d629fcf3db0c30", "patch": "@@ -54,6 +54,7 @@ extern int some_operand PARAMS ((rtx, enum machine_mode));\n extern int some_ni_operand PARAMS ((rtx, enum machine_mode));\n extern int input_operand PARAMS ((rtx, enum machine_mode));\n extern int current_file_function_operand PARAMS ((rtx, enum machine_mode));\n+extern int local_symbolic_operand PARAMS ((rtx, enum machine_mode));\n extern int call_operand PARAMS ((rtx, enum machine_mode));\n extern int alpha_comparison_operator PARAMS ((rtx, enum machine_mode));\n extern int alpha_zero_comparison_operator PARAMS ((rtx, enum machine_mode));\n@@ -146,4 +147,5 @@ extern rtx function_arg PARAMS ((CUMULATIVE_ARGS, enum machine_mode,\n #endif\n extern void alpha_start_function PARAMS ((FILE *, const char *, tree));\n extern void alpha_end_function PARAMS ((FILE *, const char *, tree));\n+extern void alpha_encode_section_info PARAMS ((tree));\n #endif /* TREE CODE */"}, {"sha": "d0bbb9664fc2774ef981b183496177fe28f9e67c", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 309, "deletions": 36, "changes": 345, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb356b98df2a898b6650c7641d629fcf3db0c30/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb356b98df2a898b6650c7641d629fcf3db0c30/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=1eb356b98df2a898b6650c7641d629fcf3db0c30", "patch": "@@ -105,6 +105,14 @@ static int alpha_sr_alias_set;\n \n static const char *alpha_fnname;\n \n+/* The next explicit relocation sequence number.  */\n+int alpha_next_sequence_number = 1;\n+\n+/* The literal and gpdisp sequence numbers for this insn, as printed\n+   by %# and %* respectively.  */\n+int alpha_this_literal_sequence_number;\n+int alpha_this_gpdisp_sequence_number;\n+\n /* Declarations of static functions.  */\n static void alpha_set_memflags_1\n   PARAMS ((rtx, int, int, int));\n@@ -116,6 +124,8 @@ static void alpha_expand_unaligned_store_words\n   PARAMS ((rtx *out_regs, rtx smem, HOST_WIDE_INT words, HOST_WIDE_INT ofs));\n static void alpha_sa_mask\n   PARAMS ((unsigned long *imaskP, unsigned long *fmaskP));\n+static int find_lo_sum\n+  PARAMS ((rtx *, void *));\n static int alpha_does_function_need_gp\n   PARAMS ((void));\n static int alpha_ra_ever_killed\n@@ -662,7 +672,7 @@ some_operand (op, mode)\n   switch (GET_CODE (op))\n     {\n     case REG:  case MEM:  case CONST_DOUBLE:  case CONST_INT:  case LABEL_REF:\n-    case SYMBOL_REF:  case CONST:\n+    case SYMBOL_REF:  case CONST:  case HIGH:\n       return 1;\n \n     case SUBREG:\n@@ -733,6 +743,10 @@ input_operand (op, mode)\n     case CONSTANT_P_RTX:\n       return 1;\n \n+    case HIGH:\n+      return (TARGET_EXPLICIT_RELOCS\n+\t      && local_symbolic_operand (XEXP (op, 0), mode));\n+\n     default:\n       break;\n     }\n@@ -754,6 +768,41 @@ current_file_function_operand (op, mode)\n \t      || op == XEXP (DECL_RTL (current_function_decl), 0)));\n }\n \n+/* Return true if OP is a SYMBOL_REF or CONST referencing a variable\n+   known to be defined in this file.  */\n+\n+int\n+local_symbolic_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  const char *str;\n+\n+  if (GET_CODE (op) == LABEL_REF)\n+    return 1;\n+\n+  if (GET_CODE (op) == CONST\n+      && GET_CODE (XEXP (op, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT)\n+    op = XEXP (XEXP (op, 0), 0);\n+\n+  if (GET_CODE (op) != SYMBOL_REF)\n+    return 0;\n+\n+  str = XSTR (op, 0);\n+\n+  /* ??? SYMBOL_REF_FLAG is set for local function symbols, but we\n+     run into problems with the rtl inliner in that the symbol was\n+     once external, but is local after inlining, which results in\n+     unrecognizable insns.  */\n+\n+  return (CONSTANT_POOL_ADDRESS_P (op)\n+\t  /* If @, then ENCODE_SECTION_INFO sez it's local.  */\n+\t  || str[0] == '@'\n+\t  /* If *$, then ASM_GENERATE_INTERNAL_LABEL sez it's local.  */\n+\t  || (str[0] == '*' && str[1] == '$'));\n+}\n+\n /* Return 1 if OP is a valid operand for the MEM of a CALL insn.  */\n \n int\n@@ -1154,6 +1203,120 @@ alpha_tablejump_best_label (insn)\n   return best_label ? best_label : const0_rtx;\n }\n \f\n+/* If we are referencing a function that is static, make the SYMBOL_REF\n+   special.  We use this to see indicate we can branch to this function\n+   without setting PV or restoring GP. \n+\n+   If this is a variable that is known to be defined locally, add \"@v\"\n+   to the name.  If in addition the variable is to go in .sdata/.sbss,\n+   then add \"@s\" instead.  */\n+\n+void\n+alpha_encode_section_info (decl)\n+     tree decl;\n+{\n+  const char *symbol_str;\n+  bool is_local, is_small;\n+\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    {\n+      if (! TREE_PUBLIC (decl))\n+\tSYMBOL_REF_FLAG (XEXP (DECL_RTL (decl), 0)) = 1;\n+      return;\n+    }\n+\n+  /* Early out if we're not going to do anything with this data.  */\n+  if (! TARGET_EXPLICIT_RELOCS)\n+    return;\n+\n+  /* Careful not to prod global register variables.  */\n+  if (TREE_CODE (decl) != VAR_DECL\n+      || GET_CODE (DECL_RTL (decl)) != MEM\n+      || GET_CODE (XEXP (DECL_RTL (decl), 0)) != SYMBOL_REF)\n+    return;\n+    \n+  symbol_str = XSTR (XEXP (DECL_RTL (decl), 0), 0);\n+\n+  /* A variable is considered \"local\" if it is defined in this module.  */\n+\n+  if (DECL_EXTERNAL (decl))\n+    is_local = false;\n+  /* Linkonce and weak data is never local.  */\n+  else if (DECL_ONE_ONLY (decl) || DECL_WEAK (decl))\n+    is_local = false;\n+  else if (! TREE_PUBLIC (decl))\n+    is_local = true;\n+  /* If PIC, then assume that any global name can be overridden by\n+     symbols resolved from other modules.  */\n+  else if (flag_pic)\n+    is_local = false;\n+  /* Uninitialized COMMON variable may be unified with symbols\n+     resolved from other modules.  */\n+  else if (DECL_COMMON (decl)\n+\t   && (DECL_INITIAL (decl) == NULL\n+\t       || DECL_INITIAL (decl) == error_mark_node))\n+    is_local = false;\n+  /* Otherwise we're left with initialized (or non-common) global data\n+     which is of necessity defined locally.  */\n+  else\n+    is_local = true;\n+\n+  /* Determine if DECL will wind up in .sdata/.sbss.  */\n+\n+  is_small = false;\n+  if (DECL_SECTION_NAME (decl))\n+    {\n+      const char *section = TREE_STRING_POINTER (DECL_SECTION_NAME (decl));\n+      if (strcmp (section, \".sdata\") == 0\n+\t  || strcmp (section, \".sbss\") == 0)\n+\tis_small = true;\n+    }\n+  else\n+    {\n+      HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (decl));\n+\n+      /* If the variable has already been defined in the output file, then it\n+\t is too late to put it in sdata if it wasn't put there in the first\n+\t place.  The test is here rather than above, because if it is already\n+\t in sdata, then it can stay there.  */\n+\n+      if (TREE_ASM_WRITTEN (decl))\n+\t;\n+\n+      /* If this is an incomplete type with size 0, then we can't put it in\n+\t sdata because it might be too big when completed.  */\n+      else if (size > 0 && size <= g_switch_value)\n+\tis_small = true;\n+    }\n+\n+  /* Finally, encode this into the symbol string.  */\n+  if (is_local)\n+    {\n+      const char *string;\n+      char *newstr;\n+      size_t len;\n+\n+      if (symbol_str[0] == '@')\n+\t{\n+\t  if (symbol_str[1] == (is_small ? 's' : 'v'))\n+\t    return;\n+\t  symbol_str += 2;\n+\t}\n+\n+      len = strlen (symbol_str) + 1;\n+      newstr = alloca (len + 2);\n+\n+      newstr[0] = '@';\n+      newstr[1] = (is_small ? 's' : 'v');\n+      memcpy (newstr + 2, symbol_str, len);\n+\t  \n+      string = ggc_alloc_string (newstr, len + 2 - 1);\n+      XSTR (XEXP (DECL_RTL (decl), 0), 0) = string;\n+    }\n+  else if (symbol_str[0] == '@')\n+    abort ();\n+}\n+\n /* legitimate_address_p recognizes an RTL expression that is a valid\n    memory address for an instruction.  The MODE argument is the\n    machine mode for the MEM expression that wants to use this address.\n@@ -1222,6 +1385,30 @@ alpha_legitimate_address_p (mode, x, strict)\n \treturn true;\n     }\n \n+  /* If we're managing explicit relocations, LO_SUM is valid.  */\n+  else if (TARGET_EXPLICIT_RELOCS && GET_CODE (x) == LO_SUM)\n+    {\n+      rtx ofs = XEXP (x, 1);\n+      x = XEXP (x, 0);\n+\n+      /* Discard non-paradoxical subregs.  */\n+      if (GET_CODE (x) == SUBREG\n+          && (GET_MODE_SIZE (GET_MODE (x))\n+\t      < GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))))\n+\tx = SUBREG_REG (x);\n+\n+      /* Must have a valid base register.  */\n+      if (! (REG_P (x)\n+\t     && (strict\n+\t\t ? STRICT_REG_OK_FOR_BASE_P (x)\n+\t\t : NONSTRICT_REG_OK_FOR_BASE_P (x))))\n+\treturn false;\n+\n+      /* The symbol must be local.  */\n+      if (local_symbolic_operand (ofs, Pmode))\n+\treturn true;\n+    }\n+\n   return false;\n }\n \n@@ -1278,6 +1465,14 @@ alpha_legitimize_address (x, oldx, mode)\n       goto split_addend;\n     }\n \n+  /* If this is a local symbol, split the address into HIGH/LO_SUM parts.  */\n+  if (TARGET_EXPLICIT_RELOCS && local_symbolic_operand (x, Pmode))\n+    {\n+      rtx temp = gen_reg_rtx (Pmode);\n+      emit_insn (gen_rtx_SET (VOIDmode, temp, gen_rtx_HIGH (Pmode, x)));\n+      return gen_rtx_LO_SUM (Pmode, temp, x);\n+    }\n+\n   return NULL;\n \n  split_addend:\n@@ -1465,7 +1660,8 @@ secondary_reload_class (class, mode, x, in)\n \t      > GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))))\n \treturn GENERAL_REGS;\n \n-      if (in && INTEGRAL_MODE_P (mode) && ! general_operand (x, mode))\n+      if (in && INTEGRAL_MODE_P (mode)\n+\t  && ! (memory_operand (x, mode) || x == const0_rtx))\n \treturn GENERAL_REGS;\n     }\n \n@@ -1830,6 +2026,15 @@ alpha_expand_mov (mode, operands)\n       && ! reg_or_0_operand (operands[1], mode))\n     operands[1] = force_reg (mode, operands[1]);\n \n+  if (TARGET_EXPLICIT_RELOCS && local_symbolic_operand (operands[1], mode))\n+    {\n+      rtx scratch = no_new_pseudos ? operands[0] : gen_reg_rtx (Pmode);\n+      emit_insn (gen_rtx_SET (VOIDmode, scratch,\n+\t\t\t      gen_rtx_HIGH (Pmode, operands[1])));\n+      operands[1] = gen_rtx_LO_SUM (Pmode, scratch, operands[1]);\n+      return false;\n+    }\n+\n   /* Early out for non-constants and valid constants.  */\n   if (! CONSTANT_P (operands[1]) || input_operand (operands[1], mode))\n     return false;\n@@ -2961,7 +3166,7 @@ alpha_expand_unaligned_load (tgt, mem, size, ofs, sign)\n      HOST_WIDE_INT size, ofs;\n      int sign;\n {\n-  rtx meml, memh, addr, extl, exth, tmp;\n+  rtx meml, memh, addr, extl, exth, tmp, mema;\n   enum machine_mode mode;\n \n   meml = gen_reg_rtx (DImode);\n@@ -2970,28 +3175,31 @@ alpha_expand_unaligned_load (tgt, mem, size, ofs, sign)\n   extl = gen_reg_rtx (DImode);\n   exth = gen_reg_rtx (DImode);\n \n+  mema = XEXP (mem, 0);\n+  if (GET_CODE (mema) == LO_SUM)\n+    mema = force_reg (Pmode, mema);\n+\n   /* AND addresses cannot be in any alias set, since they may implicitly\n      alias surrounding code.  Ideally we'd have some alias set that \n      covered all types except those with alignment 8 or higher.  */\n \n   tmp = change_address (mem, DImode,\n \t\t\tgen_rtx_AND (DImode, \n-\t\t\t\t     plus_constant (XEXP (mem, 0), ofs),\n+\t\t\t\t     plus_constant (mema, ofs),\n \t\t\t\t     GEN_INT (-8)));\n   set_mem_alias_set (tmp, 0);\n   emit_move_insn (meml, tmp);\n \n   tmp = change_address (mem, DImode,\n \t\t\tgen_rtx_AND (DImode, \n-\t\t\t\t     plus_constant (XEXP (mem, 0),\n-\t\t\t\t\t\t    ofs + size - 1),\n+\t\t\t\t     plus_constant (mema, ofs + size - 1),\n \t\t\t\t     GEN_INT (-8)));\n   set_mem_alias_set (tmp, 0);\n   emit_move_insn (memh, tmp);\n \n   if (sign && size == 2)\n     {\n-      emit_move_insn (addr, plus_constant (XEXP (mem, 0), ofs+2));\n+      emit_move_insn (addr, plus_constant (mema, ofs+2));\n \n       emit_insn (gen_extxl (extl, meml, GEN_INT (64), addr));\n       emit_insn (gen_extqh (exth, memh, addr));\n@@ -3005,7 +3213,7 @@ alpha_expand_unaligned_load (tgt, mem, size, ofs, sign)\n     }\n   else\n     {\n-      emit_move_insn (addr, plus_constant (XEXP (mem, 0), ofs));\n+      emit_move_insn (addr, plus_constant (mema, ofs));\n       emit_insn (gen_extxl (extl, meml, GEN_INT (size*8), addr));\n       switch ((int) size)\n \t{\n@@ -3044,33 +3252,36 @@ alpha_expand_unaligned_store (dst, src, size, ofs)\n      rtx dst, src;\n      HOST_WIDE_INT size, ofs;\n {\n-  rtx dstl, dsth, addr, insl, insh, meml, memh;\n+  rtx dstl, dsth, addr, insl, insh, meml, memh, dsta;\n   \n   dstl = gen_reg_rtx (DImode);\n   dsth = gen_reg_rtx (DImode);\n   insl = gen_reg_rtx (DImode);\n   insh = gen_reg_rtx (DImode);\n \n+  dsta = XEXP (dst, 0);\n+  if (GET_CODE (dsta) == LO_SUM)\n+    dsta = force_reg (Pmode, dsta);\n+\n   /* AND addresses cannot be in any alias set, since they may implicitly\n      alias surrounding code.  Ideally we'd have some alias set that \n      covered all types except those with alignment 8 or higher.  */\n \n   meml = change_address (dst, DImode,\n \t\t\t gen_rtx_AND (DImode, \n-\t\t\t\t      plus_constant (XEXP (dst, 0), ofs),\n+\t\t\t\t      plus_constant (dsta, ofs),\n \t\t\t\t      GEN_INT (-8)));\n   set_mem_alias_set (meml, 0);\n \n   memh = change_address (dst, DImode,\n \t\t\t gen_rtx_AND (DImode, \n-\t\t\t\t      plus_constant (XEXP (dst, 0),\n-\t\t\t\t\t\t     ofs+size-1),\n+\t\t\t\t      plus_constant (dsta, ofs + size - 1),\n \t\t\t\t      GEN_INT (-8)));\n   set_mem_alias_set (memh, 0);\n \n   emit_move_insn (dsth, memh);\n   emit_move_insn (dstl, meml);\n-  addr = copy_addr_to_reg (plus_constant (XEXP (dst, 0), ofs));\n+  addr = copy_addr_to_reg (plus_constant (dsta, ofs));\n \n   if (src != const0_rtx)\n     {\n@@ -3143,9 +3354,13 @@ alpha_expand_unaligned_load_words (out_regs, smem, words, ofs)\n   rtx const im8 = GEN_INT (-8);\n   rtx const i64 = GEN_INT (64);\n   rtx ext_tmps[MAX_MOVE_WORDS], data_regs[MAX_MOVE_WORDS+1];\n-  rtx sreg, areg, tmp;\n+  rtx sreg, areg, tmp, smema;\n   HOST_WIDE_INT i;\n \n+  smema = XEXP (smem, 0);\n+  if (GET_CODE (smema) == LO_SUM)\n+    smema = force_reg (Pmode, smema);\n+\n   /* Generate all the tmp registers we need.  */\n   for (i = 0; i < words; ++i)\n     {\n@@ -3162,15 +3377,15 @@ alpha_expand_unaligned_load_words (out_regs, smem, words, ofs)\n     {\n       tmp = change_address (smem, DImode,\n \t\t\t    gen_rtx_AND (DImode,\n-\t\t\t\t\t plus_constant (XEXP(smem,0), 8*i),\n+\t\t\t\t\t plus_constant (smema, 8*i),\n \t\t\t\t\t im8));\n       set_mem_alias_set (tmp, 0);\n       emit_move_insn (data_regs[i], tmp);\n     }\n \n   tmp = change_address (smem, DImode,\n \t\t\tgen_rtx_AND (DImode,\n-\t\t\t\t     plus_constant (XEXP(smem,0), 8*words - 1),\n+\t\t\t\t     plus_constant (smema, 8*words - 1),\n \t\t\t\t     im8));\n   set_mem_alias_set (tmp, 0);\n   emit_move_insn (data_regs[words], tmp);\n@@ -3179,7 +3394,7 @@ alpha_expand_unaligned_load_words (out_regs, smem, words, ofs)\n      extxh with offset zero a noop instead of zeroing the register, so \n      we must take care of that edge condition ourselves with cmov.  */\n \n-  sreg = copy_addr_to_reg (XEXP (smem, 0));\n+  sreg = copy_addr_to_reg (smema);\n   areg = expand_binop (DImode, and_optab, sreg, GEN_INT (7), NULL, \n \t\t       1, OPTAB_WIDEN);\n   for (i = 0; i < words; ++i)\n@@ -3220,9 +3435,13 @@ alpha_expand_unaligned_store_words (data_regs, dmem, words, ofs)\n #endif\n   rtx ins_tmps[MAX_MOVE_WORDS];\n   rtx st_tmp_1, st_tmp_2, dreg;\n-  rtx st_addr_1, st_addr_2;\n+  rtx st_addr_1, st_addr_2, dmema;\n   HOST_WIDE_INT i;\n \n+  dmema = XEXP (dmem, 0);\n+  if (GET_CODE (dmema) == LO_SUM)\n+    dmema = force_reg (Pmode, dmema);\n+\n   /* Generate all the tmp registers we need.  */\n   if (data_regs != NULL)\n     for (i = 0; i < words; ++i)\n@@ -3235,23 +3454,20 @@ alpha_expand_unaligned_store_words (data_regs, dmem, words, ofs)\n \n   st_addr_2 = change_address (dmem, DImode,\n \t\t\t      gen_rtx_AND (DImode,\n-\t\t\t\t\t   plus_constant (XEXP(dmem,0),\n-\t\t\t\t\t\t\t  words*8 - 1),\n+\t\t\t\t\t   plus_constant (dmema, words*8 - 1),\n \t\t\t\t       im8));\n   set_mem_alias_set (st_addr_2, 0);\n \n   st_addr_1 = change_address (dmem, DImode,\n-\t\t\t      gen_rtx_AND (DImode, \n-\t\t\t\t\t   XEXP (dmem, 0),\n-\t\t\t\t\t   im8));\n+\t\t\t      gen_rtx_AND (DImode, dmema, im8));\n   set_mem_alias_set (st_addr_1, 0);\n \n   /* Load up the destination end bits.  */\n   emit_move_insn (st_tmp_2, st_addr_2);\n   emit_move_insn (st_tmp_1, st_addr_1);\n \n   /* Shift the input data into place.  */\n-  dreg = copy_addr_to_reg (XEXP (dmem, 0));\n+  dreg = copy_addr_to_reg (dmema);\n   if (data_regs != NULL)\n     {\n       for (i = words-1; i >= 0; --i)\n@@ -3285,7 +3501,7 @@ alpha_expand_unaligned_store_words (data_regs, dmem, words, ofs)\n     {\n       rtx tmp = change_address (dmem, DImode,\n \t\t\t\tgen_rtx_AND (DImode,\n-\t\t\t\t\t     plus_constant(XEXP (dmem,0), i*8),\n+\t\t\t\t\t     plus_constant(dmema, i*8),\n \t\t\t\t\t     im8));\n       set_mem_alias_set (tmp, 0);\n       emit_move_insn (tmp, data_regs ? ins_tmps[i-1] : const0_rtx);\n@@ -3315,7 +3531,7 @@ alpha_expand_block_move (operands)\n   rtx orig_dst = operands[0];\n   rtx data_regs[2 * MAX_MOVE_WORDS + 16];\n   rtx tmp;\n-  int i, words, ofs, nregs = 0;\n+  unsigned int i, words, ofs, nregs = 0;\n   \n   if (orig_bytes <= 0)\n     return 1;\n@@ -3773,7 +3989,7 @@ alpha_expand_block_clear (operands)\n       words = bytes / 8;\n \n       for (i = 0; i < words; ++i)\n-\temit_move_insn (adjust_address(orig_dst, DImode, ofs + i * 8),\n+\temit_move_insn (adjust_address (orig_dst, DImode, ofs + i * 8),\n \t\t\tconst0_rtx);\n \n       bytes -= words * 8;\n@@ -3785,18 +4001,23 @@ alpha_expand_block_clear (operands)\n \n   if (align >= 32 && bytes > 16)\n     {\n+      rtx orig_dsta;\n+\n       emit_move_insn (adjust_address (orig_dst, SImode, ofs), const0_rtx);\n       bytes -= 4;\n       ofs += 4;\n \n+      orig_dsta = XEXP (orig_dst, 0);\n+      if (GET_CODE (orig_dsta) == LO_SUM)\n+\torig_dsta = force_reg (Pmode, orig_dsta);\n+\n       words = bytes / 8;\n       for (i = 0; i < words; ++i)\n \t{\n \t  rtx mem\n \t    = change_address (orig_dst, DImode,\n \t\t\t      gen_rtx_AND (DImode,\n-\t\t\t\t\t   plus_constant (XEXP (orig_dst, 0),\n-\t\t\t\t\t\t\t  ofs + i*8),\n+\t\t\t\t\t   plus_constant (orig_dsta, ofs + i*8),\n \t\t\t\t\t   GEN_INT (-8)));\n \t  set_mem_alias_set (mem, 0);\n \t  emit_move_insn (mem, const0_rtx);\n@@ -4272,6 +4493,28 @@ print_operand (file, x, code)\n       fputc ((TARGET_FLOAT_VAX ? 'g' : 't'), file);\n       break;\n \n+    case '#':\n+      if (alpha_this_literal_sequence_number == 0)\n+\talpha_this_literal_sequence_number = alpha_next_sequence_number++;\n+      fprintf (file, \"%d\", alpha_this_literal_sequence_number);\n+      break;\n+\n+    case '*':\n+      if (alpha_this_gpdisp_sequence_number == 0)\n+\talpha_this_gpdisp_sequence_number = alpha_next_sequence_number++;\n+      fprintf (file, \"%d\", alpha_this_gpdisp_sequence_number);\n+      break;\n+\n+    case 'H':\n+      if (GET_CODE (x) == HIGH)\n+\t{\n+\t  output_addr_const (file, XEXP (x, 0));\n+\t  fputs (\"($29)\\t\\t!gprelhigh\", file);\n+\t}\n+      else\n+\toutput_operand_lossage (\"invalid %%H value\");\n+      break;\n+\n     case 'r':\n       /* If this operand is the constant zero, write it as \"$31\".  */\n       if (GET_CODE (x) == REG)\n@@ -4280,7 +4523,6 @@ print_operand (file, x, code)\n \tfprintf (file, \"$31\");\n       else\n \toutput_operand_lossage (\"invalid %%r value\");\n-\n       break;\n \n     case 'R':\n@@ -4291,7 +4533,6 @@ print_operand (file, x, code)\n \tfprintf (file, \"$f31\");\n       else\n \toutput_operand_lossage (\"invalid %%R value\");\n-\n       break;\n \n     case 'N':\n@@ -4512,12 +4753,33 @@ print_operand_address (file, addr)\n       offset = INTVAL (XEXP (addr, 1));\n       addr = XEXP (addr, 0);\n     }\n+\n+  if (GET_CODE (addr) == LO_SUM)\n+    {\n+      output_addr_const (file, XEXP (addr, 1));\n+      if (offset)\n+\t{\n+\t  fputc ('+', file);\n+\t  fprintf (file, HOST_WIDE_INT_PRINT_DEC, offset);\n+\t}\n+      \n+      addr = XEXP (addr, 0);\n+      if (GET_CODE (addr) == REG)\n+\tbasereg = REGNO (addr);\n+      else if (GET_CODE (addr) == SUBREG\n+\t       && GET_CODE (SUBREG_REG (addr)) == REG)\n+\tbasereg = subreg_regno (addr);\n+      else\n+\tabort ();\n+      fprintf (file, \"($%d)\\t\\t!gprellow\", basereg);\n+      return;\n+    }\n+\n   if (GET_CODE (addr) == REG)\n     basereg = REGNO (addr);\n   else if (GET_CODE (addr) == SUBREG\n \t   && GET_CODE (SUBREG_REG (addr)) == REG)\n-    basereg = REGNO (SUBREG_REG (addr))\n-\t      + SUBREG_BYTE (addr) / GET_MODE_SIZE (GET_MODE (addr));\n+    basereg = subreg_regno (addr);\n   else if (GET_CODE (addr) == CONST_INT)\n     offset = INTVAL (addr);\n   else\n@@ -4827,7 +5089,7 @@ alpha_sa_mask (imaskP, fmaskP)\n {\n   unsigned long imask = 0;\n   unsigned long fmask = 0;\n-  int i;\n+  unsigned int i;\n \n #ifdef ASM_OUTPUT_MI_THUNK\n   if (!current_function_is_thunk)\n@@ -4968,6 +5230,14 @@ vms_valid_decl_attribute_p (decl, attributes, identifier, args)\n \n #endif\n \n+static int\n+find_lo_sum (px, data)\n+     rtx *px;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  return GET_CODE (*px) == LO_SUM;\n+}\n+\n static int\n alpha_does_function_need_gp ()\n {\n@@ -5001,6 +5271,9 @@ alpha_does_function_need_gp ()\n \tenum attr_type type = get_attr_type (insn);\n \tif (type == TYPE_LDSYM || type == TYPE_JSR)\n \t  return 1;\n+\tif (TARGET_EXPLICIT_RELOCS\n+\t    && for_each_rtx (&PATTERN (insn), find_lo_sum, NULL) > 0)\n+\t  return 1;\n       }\n \n   return 0;\n@@ -6606,7 +6879,7 @@ alpha_align_insns (insns, max_align, next_group, next_nop)\n \n       /* If the known alignment is smaller than the recognized insn group,\n \t realign the output.  */\n-      else if (align < len)\n+      else if ((int) align < len)\n \t{\n \t  unsigned int new_log_align = len > 8 ? 4 : 3;\n \t  rtx where;\n@@ -6626,7 +6899,7 @@ alpha_align_insns (insns, max_align, next_group, next_nop)\n \t can make use of the knowledge of what sorts of instructions\n \t were issued in the previous group to make sure that all of\n \t the added nops are really free.  */\n-      else if (ofs + len > align)\n+      else if (ofs + len > (int) align)\n \t{\n \t  int nop_count = (align - ofs) / 4;\n \t  rtx where;"}, {"sha": "220eb6235a7af0589182965ca3b6330d8eb1c873", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 54, "deletions": 15, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb356b98df2a898b6650c7641d629fcf3db0c30/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb356b98df2a898b6650c7641d629fcf3db0c30/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=1eb356b98df2a898b6650c7641d629fcf3db0c30", "patch": "@@ -158,6 +158,10 @@ extern enum alpha_fp_trap_mode alpha_fptm;\n #define MASK_CIX\t(1 << 11)\n #define TARGET_CIX\t(target_flags & MASK_CIX)\n \n+/* This means use !literal style explicit relocations.  */\n+#define MASK_EXPLICIT_RELOCS (1 << 12)\n+#define TARGET_EXPLICIT_RELOCS (target_flags & MASK_EXPLICIT_RELOCS)\n+\n /* This means that the processor is an EV5, EV56, or PCA56.\n    Unlike alpha_cpu this is not affected by -mtune= setting.  */\n #define MASK_CPU_EV5\t(1 << 28)\n@@ -227,6 +231,9 @@ extern enum alpha_fp_trap_mode alpha_fptm;\n     {\"no-fix\", -MASK_FIX, \"\"},\t\t\t\t\t\t\\\n     {\"cix\", MASK_CIX, N_(\"Emit code for the counting ISA extension\")},\t\\\n     {\"no-cix\", -MASK_CIX, \"\"},\t\t\t\t\t\t\\\n+    {\"explicit-relocs\", MASK_EXPLICIT_RELOCS,\t\t\t\t\\\n+     N_(\"Emit code using explicit relocation directives\")},\t\t\\\n+    {\"no-explicit-relocs\", -MASK_EXPLICIT_RELOCS, \"\"},\t\t\t\\\n     {\"\", TARGET_DEFAULT | TARGET_CPU_DEFAULT, \"\"} }\n \n #define TARGET_DEFAULT MASK_FP|MASK_FPREGS\n@@ -792,6 +799,7 @@ enum reg_class { NO_REGS, PV_REG, GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n    : (C) == 'R' ? current_file_function_operand (OP, Pmode)\t\t\\\n    : (C) == 'S' ? (GET_CODE (OP) == CONST_INT\t\t\t\t\\\n \t\t   && (unsigned HOST_WIDE_INT) INTVAL (OP) < 64)\t\\\n+   : (C) == 'T' ? GET_CODE (OP) == HIGH\t\t\t\t\t\\\n    : 0)\n \n /* Given an rtx X being reloaded into a reg required to be\n@@ -803,8 +811,9 @@ enum reg_class { NO_REGS, PV_REG, GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n    register via memory.  */\n \n #define PREFERRED_RELOAD_CLASS(X, CLASS)\t\t\\\n-  (CONSTANT_P (X) && (X) != const0_rtx && (X) != CONST0_RTX (GET_MODE (X)) \\\n-   ? ((CLASS) == FLOAT_REGS || (CLASS) == NO_REGS ? NO_REGS : GENERAL_REGS)\\\n+  (GET_CODE (X) == HIGH ? GENERAL_REGS\t\t\t\\\n+   : CONSTANT_P (X) && (X) != const0_rtx && (X) != CONST0_RTX (GET_MODE (X)) \\\n+   ? ((CLASS) == FLOAT_REGS || (CLASS) == NO_REGS ? NO_REGS : GENERAL_REGS) \\\n    : (CLASS))\n \n /* Loading and storing HImode or QImode values to and from memory\n@@ -1737,13 +1746,11 @@ do {\t\t\t\t\t\t\t\t\t     \\\n \n /* Output to assembler file text saying following lines\n    may contain character constants, extra white space, comments, etc.  */\n-\n-#define ASM_APP_ON \"\"\n+#define ASM_APP_ON (TARGET_EXPLICIT_RELOCS ? \"\\t.set\\tmacro\\n\" : \"\")\n \n /* Output to assembler file text saying following lines\n    no longer contain unusual constructs.  */\n-\n-#define ASM_APP_OFF \"\"\n+#define ASM_APP_OFF (TARGET_EXPLICIT_RELOCS ? \"\\t.set\\tnomacro\\n\" : \"\")\n \n #define TEXT_SECTION_ASM_OP \"\\t.text\"\n \n@@ -1785,13 +1792,29 @@ literal_section ()\t\t\t\t\t\t\\\n \n #define READONLY_DATA_SECTION\tliteral_section\n \n-/* If we are referencing a function that is static, make the SYMBOL_REF\n-   special.  We use this to see indicate we can branch to this function\n-   without setting PV or restoring GP.  */\n+/* Define this macro if references to a symbol must be treated differently\n+   depending on something about the variable or function named by the symbol\n+   (such as what section it is in).  */\n+\n+#define ENCODE_SECTION_INFO(DECL)  alpha_encode_section_info (DECL)\n+\n+/* If a variable is weakened, made one only or moved into a different\n+   section, it may be necessary to redo the section info to move the\n+   variable out of sdata. */\n+\n+#define REDO_SECTION_INFO_P(DECL)                                       \\\n+   ((TREE_CODE (DECL) == VAR_DECL)                                      \\\n+    && (DECL_ONE_ONLY (DECL) || DECL_WEAK (DECL) || DECL_COMMON (DECL)  \\\n+        || DECL_SECTION_NAME (DECL) != 0))\n \n-#define ENCODE_SECTION_INFO(DECL)  \\\n-  if (TREE_CODE (DECL) == FUNCTION_DECL && ! TREE_PUBLIC (DECL)) \\\n-    SYMBOL_REF_FLAG (XEXP (DECL_RTL (DECL), 0)) = 1;\n+#define STRIP_NAME_ENCODING(VAR,SYMBOL_NAME)\t\\\n+do {\t\t\t\t\t\t\\\n+  (VAR) = (SYMBOL_NAME);\t\t\t\\\n+  if ((VAR)[0] == '@')\t\t\t\t\\\n+    (VAR) += 2;\t\t\t\t\t\\\n+  if ((VAR)[0] == '*')\t\t\t\t\\\n+    (VAR)++;\t\t\t\t\t\\\n+} while (0)\n \n /* How to refer to registers in assembler output.\n    This sequence is indexed by compiler's hard-register-number (see above).  */\n@@ -1810,6 +1833,20 @@ literal_section ()\t\t\t\t\t\t\\\n \n #define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n \n+/* Strip name encoding when emitting labels.  */\n+\n+#define ASM_OUTPUT_LABELREF(STREAM, NAME)\t\\\n+do {\t\t\t\t\t\t\\\n+  const char *name_ = NAME;\t\t\t\\\n+  if (*name_ == '@')\t\t\t\t\\\n+    name_ += 2;\t\t\t\t\t\\\n+  if (*name_ == '*')\t\t\t\t\\\n+    name_++;\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\\\n+    fputs (user_label_prefix, STREAM);\t\t\\\n+  fputs (name_, STREAM);\t\t\t\\\n+} while (0)\n+\n /* This is how to output the definition of a user-level label named NAME,\n    such as the label on a static function or variable NAME.  */\n \n@@ -2089,7 +2126,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n    */\n \n #define PRINT_OPERAND_PUNCT_VALID_P(CODE) \\\n-  ((CODE) == '/' || (CODE) == ',' || (CODE) == '-' || (CODE) == '~')\n+  ((CODE) == '/' || (CODE) == ',' || (CODE) == '-' || (CODE) == '~' \\\n+   || (CODE) == '#' || (CODE) == '*')\n \f\n /* Print a memory address as an operand to reference that memory location.  */\n \n@@ -2121,11 +2159,12 @@ do {\t\t\t\t\t\t\t\t\t\\\n   {\"divmod_operator\", {DIV, MOD, UDIV, UMOD}},\t\t\t\t\\\n   {\"fp0_operand\", {CONST_DOUBLE}},\t\t\t\t\t\\\n   {\"current_file_function_operand\", {SYMBOL_REF}},\t\t\t\\\n+  {\"local_symbolic_operand\", {SYMBOL_REF, CONST, LABEL_REF}},\t\t\\\n   {\"call_operand\", {REG, SYMBOL_REF}},\t\t\t\t\t\\\n   {\"input_operand\", {SUBREG, REG, MEM, CONST_INT, CONST_DOUBLE,\t\t\\\n-\t\t     SYMBOL_REF, CONST, LABEL_REF}},\t\t\t\\\n+\t\t     SYMBOL_REF, CONST, LABEL_REF, HIGH, LO_SUM}},\t\\\n   {\"some_operand\", {SUBREG, REG, MEM, CONST_INT, CONST_DOUBLE,\t\t\\\n-\t\t    SYMBOL_REF, CONST, LABEL_REF}},\t\t\t\\\n+\t\t    SYMBOL_REF, CONST, LABEL_REF, HIGH, LO_SUM}},\t\\\n   {\"some_ni_operand\", {SUBREG, REG, MEM}},\t\t\t\t\\\n   {\"aligned_memory_operand\", {MEM}},\t\t\t\t\t\\\n   {\"unaligned_memory_operand\", {MEM}},\t\t\t\t\t\\"}, {"sha": "3cce9794b24f291a3a994336f4527832028b3ffa", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 159, "deletions": 26, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb356b98df2a898b6650c7641d629fcf3db0c30/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb356b98df2a898b6650c7641d629fcf3db0c30/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=1eb356b98df2a898b6650c7641d629fcf3db0c30", "patch": "@@ -1103,6 +1103,18 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \n ;; Lengths of 8 for ldq $t12,__divq($gp); jsr $t9,($t12),__divq as\n ;; expanded by the assembler.\n+\n+(define_insn \"*divmodsi_internal_er\"\n+  [(set (reg:DI 27)\n+\t(sign_extend:DI (match_operator:SI 0 \"divmod_operator\"\n+\t\t\t[(reg:DI 24) (reg:DI 25)])))\n+   (clobber (reg:DI 23))\n+   (clobber (reg:DI 28))]\n+  \"TARGET_EXPLICIT_RELOCS && ! TARGET_ABI_OPEN_VMS\"\n+  \"ldq $27,__%E0($29)\\t\\t!literal!%#\\;jsr $23,($27),__%E0\\t\\t!lituse_jsr!%#\"\n+  [(set_attr \"type\" \"jsr\")\n+   (set_attr \"length\" \"8\")])\n+\n (define_insn \"*divmodsi_internal\"\n   [(set (reg:DI 27)\n \t(sign_extend:DI (match_operator:SI 0 \"divmod_operator\"\n@@ -1114,6 +1126,17 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n   [(set_attr \"type\" \"jsr\")\n    (set_attr \"length\" \"8\")])\n \n+(define_insn \"*divmoddi_internal_er\"\n+  [(set (reg:DI 27)\n+\t(match_operator:DI 0 \"divmod_operator\"\n+\t\t\t[(reg:DI 24) (reg:DI 25)]))\n+   (clobber (reg:DI 23))\n+   (clobber (reg:DI 28))]\n+  \"TARGET_EXPLICIT_RELOCS && ! TARGET_ABI_OPEN_VMS\"\n+  \"ldq $27,__%E0($29)\\t\\t!literal!%#\\;jsr $23,($27),__%E0\\t\\t!lituse_jsr!%#\"\n+  [(set_attr \"type\" \"jsr\")\n+   (set_attr \"length\" \"8\")])\n+\n (define_insn \"*divmoddi_internal\"\n   [(set (reg:DI 27)\n \t(match_operator:DI 0 \"divmod_operator\"\n@@ -4346,6 +4369,33 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n     }\n })\n \n+(define_insn \"*call_osf_1_er_noreturn\"\n+  [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"c,R,i\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (clobber (reg:DI 27))\n+   (clobber (reg:DI 26))]\n+  \"TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF\n+   && find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n+  \"@\n+   jsr $26,($27),0\n+   bsr $26,$%0..ng\n+   ldq $27,%0($29)\\t\\t!literal!%#\\;jsr $26,($27),%0\\t\\t!lituse_jsr!%#\"\n+  [(set_attr \"type\" \"jsr\")\n+   (set_attr \"length\" \"*,*,8\")])\n+\n+(define_insn \"*call_osf_1_er\"\n+  [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"c,R,i\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (clobber (reg:DI 27))\n+   (clobber (reg:DI 26))]\n+  \"TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF\"\n+  \"@\n+   jsr $26,($27),0\\;ldah $29,0($26)\\t\\t!gpdisp!%*\\;lda $29,0($29)\\t\\t!gpdisp!%*\n+   bsr $26,$%0..ng\n+   ldq $27,%0($29)\\t\\t!literal!%#\\;jsr $26,($27),%0\\t\\t!lituse_jsr!%#\\;ldah $29,0($26)\\t\\t!gpdisp!%*\\;lda $29,0($29)\\t\\t!gpdisp!%*\"\n+  [(set_attr \"type\" \"jsr\")\n+   (set_attr \"length\" \"12,*,16\")])\n+\n (define_insn \"*call_osf_1_noreturn\"\n   [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"c,R,i\"))\n \t (match_operand 1 \"\" \"\"))\n@@ -4373,14 +4423,11 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n    (set_attr \"length\" \"12,*,16\")])\n \n (define_insn \"*sibcall_osf_1\"\n-  [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"R,i\"))\n+  [(call (mem:DI (match_operand:DI 0 \"current_file_function_operand\" \"R\"))\n \t (match_operand 1 \"\" \"\"))]\n   \"TARGET_ABI_OSF\"\n-  \"@\n-   br $31,$%0..ng\n-   jmp $31,%0\"\n-  [(set_attr \"type\" \"jsr\")\n-   (set_attr \"length\" \"*,8\")])\n+  \"br $31,$%0..ng\"\n+  [(set_attr \"type\" \"jsr\")])\n \n (define_insn \"*call_nt_1\"\n   [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"r,R,i\"))\n@@ -4707,8 +4754,8 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n        || reg_or_0_operand (operands[1], SImode))\"\n   \"@\n    mov %r1,%0\n-   lda %0,%1\n-   ldah %0,%h1\n+   lda %0,%1($31)\n+   ldah %0,%h1($31)\n    ldl %0,%1\n    stl %r1,%0\n    fmov %R1,%0\n@@ -4724,8 +4771,8 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n        || reg_or_0_operand (operands[1], SImode))\"\n   \"@\n    mov %r1,%0\n-   lda %0,%1\n-   ldah %0,%h1\n+   lda %0,%1($31)\n+   ldah %0,%h1($31)\n    ldl %0,%1\n    stl %r1,%0\n    fmov %R1,%0\n@@ -4761,7 +4808,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n        || register_operand (operands[1], HImode))\"\n   \"@\n    mov %r1,%0\n-   lda %0,%L1\"\n+   lda %0,%L1($31)\"\n   [(set_attr \"type\" \"ilog,iadd\")])\n \n (define_insn \"*movhi_bwx\"\n@@ -4772,7 +4819,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n        || reg_or_0_operand (operands[1], HImode))\"\n   \"@\n    mov %r1,%0\n-   lda %0,%L1\n+   lda %0,%L1($31)\n    ldwu %0,%1\n    stw %r1,%0\"\n   [(set_attr \"type\" \"ilog,iadd,ild,ist\")])\n@@ -4785,7 +4832,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n        || register_operand (operands[1], QImode))\"\n   \"@\n    mov %r1,%0\n-   lda %0,%L1\"\n+   lda %0,%L1($31)\"\n   [(set_attr \"type\" \"ilog,iadd\")])\n \n (define_insn \"*movqi_bwx\"\n@@ -4796,7 +4843,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n        || reg_or_0_operand (operands[1], QImode))\"\n   \"@\n    mov %r1,%0\n-   lda %0,%L1\n+   lda %0,%L1($31)\n    ldbu %0,%1\n    stb %r1,%0\"\n   [(set_attr \"type\" \"ilog,iadd,ild,ist\")])\n@@ -4832,16 +4879,43 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n     FAIL;\n })\n \n+(define_insn \"*movdi_er_low\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:DI 2 \"local_symbolic_operand\" \"\")))]\n+  \"TARGET_EXPLICIT_RELOCS\"\n+  \"lda %0,%2(%1)\\t\\t!gprellow\")\n+\n+(define_insn \"*movdi_er_nofix\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,r,m,*f,*f,Q\")\n+\t(match_operand:DI 1 \"input_operand\" \"rJ,K,L,T,s,m,rJ,*fJ,Q,*f\"))]\n+  \"TARGET_EXPLICIT_RELOCS && ! TARGET_FIX\n+   && (register_operand (operands[0], DImode)\n+       || reg_or_0_operand (operands[1], DImode))\n+   && ! local_symbolic_operand (operands[1], DImode)\"\n+  \"@\n+   mov %r1,%0\n+   lda %0,%1($31)\n+   ldah %0,%h1($31)\n+   ldah %0,%H1\n+   ldq %0,%1($29)\\t\\t!literal\n+   ldq%A1 %0,%1\n+   stq%A0 %r1,%0\n+   fmov %R1,%0\n+   ldt %0,%1\n+   stt %R1,%0\"\n+  [(set_attr \"type\" \"ilog,iadd,iadd,iadd,ldsym,ild,ist,fcpys,fld,fst\")])\n+\n (define_insn \"*movdi_nofix\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,m,*f,*f,Q\")\n \t(match_operand:DI 1 \"input_operand\" \"rJ,K,L,s,m,rJ,*fJ,Q,*f\"))]\n-  \"! TARGET_FIX\n+  \"! TARGET_EXPLICIT_RELOCS && ! TARGET_FIX\n    && (register_operand (operands[0], DImode)\n        || reg_or_0_operand (operands[1], DImode))\"\n   \"@\n    mov %r1,%0\n-   lda %0,%1\n-   ldah %0,%h1\n+   lda %0,%1($31)\n+   ldah %0,%h1($31)\n    lda %0,%1\n    ldq%A1 %0,%1\n    stq%A0 %r1,%0\n@@ -4850,16 +4924,38 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n    stt %R1,%0\"\n   [(set_attr \"type\" \"ilog,iadd,iadd,ldsym,ild,ist,fcpys,fld,fst\")])\n \n+(define_insn \"*movdi_er_fix\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,r,m,*f,*f,Q,r,*f\")\n+\t(match_operand:DI 1 \"input_operand\" \"rJ,K,L,T,s,m,rJ,*fJ,Q,*f,*f,r\"))]\n+  \"TARGET_EXPLICIT_RELOCS && TARGET_FIX\n+   && (register_operand (operands[0], DImode)\n+       || reg_or_0_operand (operands[1], DImode))\n+   && ! local_symbolic_operand (operands[1], DImode)\"\n+  \"@\n+   mov %r1,%0\n+   lda %0,%1($31)\n+   ldah %0,%h1($31)\n+   ldah %0,%H1\n+   ldq %0,%1($29)\\t\\t!literal\n+   ldq%A1 %0,%1\n+   stq%A0 %r1,%0\n+   fmov %R1,%0\n+   ldt %0,%1\n+   stt %R1,%0\n+   ftoit %1,%0\n+   itoft %1,%0\"\n+  [(set_attr \"type\" \"ilog,iadd,iadd,iadd,ldsym,ild,ist,fcpys,fld,fst,ftoi,itof\")])\n+\n (define_insn \"*movdi_fix\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,m,*f,*f,Q,r,*f\")\n \t(match_operand:DI 1 \"input_operand\" \"rJ,K,L,s,m,rJ,*fJ,Q,*f,*f,r\"))]\n-  \"TARGET_FIX\n+  \"! TARGET_EXPLICIT_RELOCS && TARGET_FIX\n    && (register_operand (operands[0], DImode)\n        || reg_or_0_operand (operands[1], DImode))\"\n   \"@\n    mov %r1,%0\n-   lda %0,%1\n-   ldah %0,%h1\n+   lda %0,%1($31)\n+   ldah %0,%h1($31)\n    lda %0,%1\n    ldq%A1 %0,%1\n    stq%A0 %r1,%0\n@@ -5548,6 +5644,11 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n   \"\"\n   \"\")\n \n+(define_insn \"*prologue_ldgp_1_er\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_LDGP1)]\n+  \"TARGET_EXPLICIT_RELOCS\"\n+  \"ldah $29,0($27)\\t\\t!gpdisp!%*\\;lda $29,0($29)\\t\\t!gpdisp!%*\\n$%~..ng:\")\n+\n (define_insn \"*prologue_ldgp_1\"\n   [(unspec_volatile [(const_int 0)] UNSPECV_LDGP1)]\n   \"\"\n@@ -5637,13 +5738,27 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n   \"jmp $31,(%0),0\"\n   [(set_attr \"type\" \"ibr\")])\n \n+(define_insn \"*builtin_setjmp_receiver_sub_label_er\"\n+  [(unspec_volatile [(label_ref (match_operand 0 \"\" \"\"))] UNSPECV_SETJMPR)]\n+  \"TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF && TARGET_AS_CAN_SUBTRACT_LABELS\"\n+  \"\\n$LSJ%=:\\;ldah $29,0($27)\\t\\t!gpdisp!%*\\;lda $29,$LSJ%=-%l0($29)\\t\\t!gpdisp!%*\"\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"type\" \"multi\")])\n+\n (define_insn \"*builtin_setjmp_receiver_sub_label\"\n   [(unspec_volatile [(label_ref (match_operand 0 \"\" \"\"))] UNSPECV_SETJMPR)]\n   \"TARGET_ABI_OSF && TARGET_AS_CAN_SUBTRACT_LABELS\"\n   \"\\n$LSJ%=:\\;ldgp $29,$LSJ%=-%l0($27)\"\n   [(set_attr \"length\" \"8\")\n    (set_attr \"type\" \"multi\")])\n \n+(define_insn \"*builtin_setjmp_receiver_er\"\n+  [(unspec_volatile [(label_ref (match_operand 0 \"\" \"\"))] UNSPECV_SETJMPR)]\n+  \"TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF\"\n+  \"br $29,$LSJ%=\\n$LSJ%=:\\;ldah $29,0($29)\\t\\t!gpdisp!%*\\;lda $29,0($29)\\t\\t!gpdisp!%*\"\n+  [(set_attr \"length\" \"12\")\n+   (set_attr \"type\" \"multi\")])\n+\n (define_insn \"builtin_setjmp_receiver\"\n   [(unspec_volatile [(label_ref (match_operand 0 \"\" \"\"))] UNSPECV_SETJMPR)]\n   \"TARGET_ABI_OSF\"\n@@ -5661,6 +5776,13 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n     operands[0] = const0_rtx;\n })\n \n+(define_insn \"*exception_receiver_1_er\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_EHR)]\n+  \"TARGET_EXPLICIT_RELOCS && ! TARGET_LD_BUGGY_LDGP\"\n+  \"ldah $29,0($26)\\t\\t!gpdisp!%*\\;lda $29,0($29)\\t\\t!gpdisp!%*\"\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"type\" \"multi\")])\n+\n (define_insn \"*exception_receiver_1\"\n   [(unspec_volatile [(const_int 0)] UNSPECV_EHR)]\n   \"! TARGET_LD_BUGGY_LDGP\"\n@@ -5752,6 +5874,20 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n ;; The call patterns are at the end of the file because their\n ;; wildcard operand0 interferes with nice recognition.\n \n+(define_insn \"*call_value_osf_1_er\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"c,R,i\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (clobber (reg:DI 27))\n+   (clobber (reg:DI 26))]\n+  \"TARGET_EXPLICIT_RELOCS && TARGET_ABI_OSF\"\n+  \"@\n+   jsr $26,($27),0\\;ldah $29,0($26)\\t\\t!gpdisp!%*\\;lda $29,0($29)\\t\\t!gpdisp!%*\n+   bsr $26,$%1..ng\n+   ldq $27,%1($29)\\t\\t!literal!%#\\;jsr $26,($27),%1\\t\\t!lituse_jsr!%#\\;ldah $29,0($26)\\t\\t!gpdisp!%*\\;lda $29,0($29)\\t\\t!gpdisp!%*\"\n+  [(set_attr \"type\" \"jsr\")\n+   (set_attr \"length\" \"12,*,16\")])\n+\n (define_insn \"*call_value_osf_1\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"c,R,i\"))\n@@ -5768,14 +5904,11 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \n (define_insn \"*sibcall_value_osf_1\"\n   [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"R,i\"))\n+\t(call (mem:DI (match_operand:DI 1 \"current_file_function_operand\" \"R\"))\n \t      (match_operand 2 \"\" \"\")))]\n   \"TARGET_ABI_OSF\"\n-  \"@\n-   br $31,$%1..ng\n-   jmp $31,%1\"\n-  [(set_attr \"type\" \"jsr\")\n-   (set_attr \"length\" \"*,8\")])\n+  \"br $31,$%1..ng\"\n+  [(set_attr \"type\" \"jsr\")])\n \n (define_insn \"*call_value_nt_1\"\n   [(set (match_operand 0 \"\" \"\")"}, {"sha": "3bb51cca6b224dbf59789cdddb802f2d41db567a", "filename": "gcc/config/alpha/elf.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb356b98df2a898b6650c7641d629fcf3db0c30/gcc%2Fconfig%2Falpha%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb356b98df2a898b6650c7641d629fcf3db0c30/gcc%2Fconfig%2Falpha%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Felf.h?ref=1eb356b98df2a898b6650c7641d629fcf3db0c30", "patch": "@@ -58,6 +58,8 @@ do {\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n   fprintf (FILE, \"\\t.set noat\\n\");\t\t\t\t\\\n   fprintf (FILE, \"\\t.set noreorder\\n\");\t\t\t\t\\\n+  if (TARGET_EXPLICIT_RELOCS)\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t.set nomacro\\n\");\t\t\t\t\\\n   if (TARGET_BWX | TARGET_MAX | TARGET_FIX | TARGET_CIX)\t\\\n     {\t\t\t\t\t\t\t\t\\\n       fprintf (FILE, \"\\t.arch %s\\n\",\t\t\t\t\\\n@@ -591,3 +593,11 @@ void FN ()\t\t\t\t\t\\\n    only EH sections.  */\n #define ASM_PREFERRED_EH_DATA_FORMAT(CODE,GLOBAL)       \\\n   (((GLOBAL) ? DW_EH_PE_indirect : 0) | DW_EH_PE_pcrel | DW_EH_PE_sdata4)\n+\n+/* If defined, a C statement to be executed just prior to the output of\n+   assembler code for INSN.  */\n+#define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS)\t\\\n+ (alpha_this_literal_sequence_number = 0,\t\t\\\n+  alpha_this_gpdisp_sequence_number = 0)\n+extern int alpha_this_literal_sequence_number;\n+extern int alpha_this_gpdisp_sequence_number;"}]}