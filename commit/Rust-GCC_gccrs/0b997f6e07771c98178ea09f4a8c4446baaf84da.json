{"sha": "0b997f6e07771c98178ea09f4a8c4446baaf84da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI5OTdmNmUwNzc3MWM5ODE3OGVhMDlmNGE4YzQ0NDZiYWFmODRkYQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-10-16T08:03:04Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-10-16T08:57:03Z"}, "message": "libsanitizer: merge from master", "tree": {"sha": "c3ef933f3fda4195644c6734b2c212e9f77718e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3ef933f3fda4195644c6734b2c212e9f77718e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b997f6e07771c98178ea09f4a8c4446baaf84da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b997f6e07771c98178ea09f4a8c4446baaf84da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b997f6e07771c98178ea09f4a8c4446baaf84da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b997f6e07771c98178ea09f4a8c4446baaf84da/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a70aa7a627c0b918ce1da75c0dbe088539e420f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a70aa7a627c0b918ce1da75c0dbe088539e420f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a70aa7a627c0b918ce1da75c0dbe088539e420f"}], "stats": {"total": 3988, "additions": 2840, "deletions": 1148}, "files": [{"sha": "d2a25927007cb00edbbe3b4385b56216d405c7fe", "filename": "libsanitizer/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMERGE?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -1,4 +1,4 @@\n-b638b63b99d66786cb37336292604a2ae3490cfd\n+51ff04567b2f8d06b2062bd3ed72eab2e93e4466\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "58b496a3ca4b1c5d836821cd970d9bc9cdbb03c7", "filename": "libsanitizer/asan/asan_allocator.cpp", "status": "modified", "additions": 267, "deletions": 173, "changes": 440, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_allocator.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_allocator.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -15,20 +15,21 @@\n //===----------------------------------------------------------------------===//\n \n #include \"asan_allocator.h\"\n+\n #include \"asan_mapping.h\"\n #include \"asan_poisoning.h\"\n #include \"asan_report.h\"\n #include \"asan_stack.h\"\n #include \"asan_thread.h\"\n+#include \"lsan/lsan_common.h\"\n #include \"sanitizer_common/sanitizer_allocator_checks.h\"\n #include \"sanitizer_common/sanitizer_allocator_interface.h\"\n #include \"sanitizer_common/sanitizer_errno.h\"\n #include \"sanitizer_common/sanitizer_flags.h\"\n #include \"sanitizer_common/sanitizer_internal_defs.h\"\n #include \"sanitizer_common/sanitizer_list.h\"\n-#include \"sanitizer_common/sanitizer_stackdepot.h\"\n #include \"sanitizer_common/sanitizer_quarantine.h\"\n-#include \"lsan/lsan_common.h\"\n+#include \"sanitizer_common/sanitizer_stackdepot.h\"\n \n namespace __asan {\n \n@@ -50,6 +51,22 @@ static u32 RZSize2Log(u32 rz_size) {\n \n static AsanAllocator &get_allocator();\n \n+static void AtomicContextStore(volatile atomic_uint64_t *atomic_context,\n+                               u32 tid, u32 stack) {\n+  u64 context = tid;\n+  context <<= 32;\n+  context += stack;\n+  atomic_store(atomic_context, context, memory_order_relaxed);\n+}\n+\n+static void AtomicContextLoad(const volatile atomic_uint64_t *atomic_context,\n+                              u32 &tid, u32 &stack) {\n+  u64 context = atomic_load(atomic_context, memory_order_relaxed);\n+  stack = context;\n+  context >>= 32;\n+  tid = context;\n+}\n+\n // The memory chunk allocated from the underlying allocator looks like this:\n // L L L L L L H H U U U U U U R R\n //   L -- left redzone words (0 or more bytes)\n@@ -67,68 +84,110 @@ static AsanAllocator &get_allocator();\n //   ---------------------|\n //   M -- magic value kAllocBegMagic\n //   B -- address of ChunkHeader pointing to the first 'H'\n-static const uptr kAllocBegMagic = 0xCC6E96B9;\n-\n-struct ChunkHeader {\n-  // 1-st 8 bytes.\n-  u32 chunk_state       : 8;  // Must be first.\n-  u32 alloc_tid         : 24;\n-\n-  u32 free_tid          : 24;\n-  u32 from_memalign     : 1;\n-  u32 alloc_type        : 2;\n-  u32 rz_log            : 3;\n-  u32 lsan_tag          : 2;\n-  // 2-nd 8 bytes\n-  // This field is used for small sizes. For large sizes it is equal to\n-  // SizeClassMap::kMaxSize and the actual size is stored in the\n-  // SecondaryAllocator's metadata.\n-  u32 user_requested_size : 29;\n+\n+class ChunkHeader {\n+ public:\n+  atomic_uint8_t chunk_state;\n+  u8 alloc_type : 2;\n+  u8 lsan_tag : 2;\n+\n   // align < 8 -> 0\n   // else      -> log2(min(align, 512)) - 2\n-  u32 user_requested_alignment_log : 3;\n-  u32 alloc_context_id;\n+  u8 user_requested_alignment_log : 3;\n+\n+ private:\n+  u16 user_requested_size_hi;\n+  u32 user_requested_size_lo;\n+  atomic_uint64_t alloc_context_id;\n+\n+ public:\n+  uptr UsedSize() const {\n+    uptr R = user_requested_size_lo;\n+    if (sizeof(uptr) > sizeof(user_requested_size_lo))\n+      R += (uptr)user_requested_size_hi << (8 * sizeof(user_requested_size_lo));\n+    return R;\n+  }\n+\n+  void SetUsedSize(uptr size) {\n+    user_requested_size_lo = size;\n+    if (sizeof(uptr) > sizeof(user_requested_size_lo)) {\n+      size >>= (8 * sizeof(user_requested_size_lo));\n+      user_requested_size_hi = size;\n+      CHECK_EQ(user_requested_size_hi, size);\n+    }\n+  }\n+\n+  void SetAllocContext(u32 tid, u32 stack) {\n+    AtomicContextStore(&alloc_context_id, tid, stack);\n+  }\n+\n+  void GetAllocContext(u32 &tid, u32 &stack) const {\n+    AtomicContextLoad(&alloc_context_id, tid, stack);\n+  }\n };\n \n-struct ChunkBase : ChunkHeader {\n-  // Header2, intersects with user memory.\n-  u32 free_context_id;\n+class ChunkBase : public ChunkHeader {\n+  atomic_uint64_t free_context_id;\n+\n+ public:\n+  void SetFreeContext(u32 tid, u32 stack) {\n+    AtomicContextStore(&free_context_id, tid, stack);\n+  }\n+\n+  void GetFreeContext(u32 &tid, u32 &stack) const {\n+    AtomicContextLoad(&free_context_id, tid, stack);\n+  }\n };\n \n static const uptr kChunkHeaderSize = sizeof(ChunkHeader);\n static const uptr kChunkHeader2Size = sizeof(ChunkBase) - kChunkHeaderSize;\n COMPILER_CHECK(kChunkHeaderSize == 16);\n COMPILER_CHECK(kChunkHeader2Size <= 16);\n \n-// Every chunk of memory allocated by this allocator can be in one of 3 states:\n-// CHUNK_AVAILABLE: the chunk is in the free list and ready to be allocated.\n-// CHUNK_ALLOCATED: the chunk is allocated and not yet freed.\n-// CHUNK_QUARANTINE: the chunk was freed and put into quarantine zone.\n enum {\n-  CHUNK_AVAILABLE  = 0,  // 0 is the default value even if we didn't set it.\n-  CHUNK_ALLOCATED  = 2,\n-  CHUNK_QUARANTINE = 3\n+  // Either just allocated by underlying allocator, but AsanChunk is not yet\n+  // ready, or almost returned to undelying allocator and AsanChunk is already\n+  // meaningless.\n+  CHUNK_INVALID = 0,\n+  // The chunk is allocated and not yet freed.\n+  CHUNK_ALLOCATED = 2,\n+  // The chunk was freed and put into quarantine zone.\n+  CHUNK_QUARANTINE = 3,\n };\n \n-struct AsanChunk: ChunkBase {\n+class AsanChunk : public ChunkBase {\n+ public:\n   uptr Beg() { return reinterpret_cast<uptr>(this) + kChunkHeaderSize; }\n-  uptr UsedSize(bool locked_version = false) {\n-    if (user_requested_size != SizeClassMap::kMaxSize)\n-      return user_requested_size;\n-    return *reinterpret_cast<uptr *>(\n-               get_allocator().GetMetaData(AllocBeg(locked_version)));\n+  bool AddrIsInside(uptr addr) {\n+    return (addr >= Beg()) && (addr < Beg() + UsedSize());\n   }\n-  void *AllocBeg(bool locked_version = false) {\n-    if (from_memalign) {\n-      if (locked_version)\n-        return get_allocator().GetBlockBeginFastLocked(\n-            reinterpret_cast<void *>(this));\n-      return get_allocator().GetBlockBegin(reinterpret_cast<void *>(this));\n-    }\n-    return reinterpret_cast<void*>(Beg() - RZLog2Size(rz_log));\n+};\n+\n+class LargeChunkHeader {\n+  static constexpr uptr kAllocBegMagic =\n+      FIRST_32_SECOND_64(0xCC6E96B9, 0xCC6E96B9CC6E96B9ULL);\n+  atomic_uintptr_t magic;\n+  AsanChunk *chunk_header;\n+\n+ public:\n+  AsanChunk *Get() const {\n+    return atomic_load(&magic, memory_order_acquire) == kAllocBegMagic\n+               ? chunk_header\n+               : nullptr;\n   }\n-  bool AddrIsInside(uptr addr, bool locked_version = false) {\n-    return (addr >= Beg()) && (addr < Beg() + UsedSize(locked_version));\n+\n+  void Set(AsanChunk *p) {\n+    if (p) {\n+      chunk_header = p;\n+      atomic_store(&magic, kAllocBegMagic, memory_order_release);\n+      return;\n+    }\n+\n+    uptr old = kAllocBegMagic;\n+    if (!atomic_compare_exchange_strong(&magic, &old, 0,\n+                                        memory_order_release)) {\n+      CHECK_EQ(old, kAllocBegMagic);\n+    }\n   }\n };\n \n@@ -139,23 +198,23 @@ struct QuarantineCallback {\n   }\n \n   void Recycle(AsanChunk *m) {\n-    CHECK_EQ(m->chunk_state, CHUNK_QUARANTINE);\n-    atomic_store((atomic_uint8_t*)m, CHUNK_AVAILABLE, memory_order_relaxed);\n-    CHECK_NE(m->alloc_tid, kInvalidTid);\n-    CHECK_NE(m->free_tid, kInvalidTid);\n-    PoisonShadow(m->Beg(),\n-                 RoundUpTo(m->UsedSize(), SHADOW_GRANULARITY),\n-                 kAsanHeapLeftRedzoneMagic);\n-    void *p = reinterpret_cast<void *>(m->AllocBeg());\n+    void *p = get_allocator().GetBlockBegin(m);\n     if (p != m) {\n-      uptr *alloc_magic = reinterpret_cast<uptr *>(p);\n-      CHECK_EQ(alloc_magic[0], kAllocBegMagic);\n       // Clear the magic value, as allocator internals may overwrite the\n       // contents of deallocated chunk, confusing GetAsanChunk lookup.\n-      alloc_magic[0] = 0;\n-      CHECK_EQ(alloc_magic[1], reinterpret_cast<uptr>(m));\n+      reinterpret_cast<LargeChunkHeader *>(p)->Set(nullptr);\n+    }\n+\n+    u8 old_chunk_state = CHUNK_QUARANTINE;\n+    if (!atomic_compare_exchange_strong(&m->chunk_state, &old_chunk_state,\n+                                        CHUNK_INVALID, memory_order_acquire)) {\n+      CHECK_EQ(old_chunk_state, CHUNK_QUARANTINE);\n     }\n \n+    PoisonShadow(m->Beg(),\n+                 RoundUpTo(m->UsedSize(), SHADOW_GRANULARITY),\n+                 kAsanHeapLeftRedzoneMagic);\n+\n     // Statistics.\n     AsanStats &thread_stats = GetCurrentThreadStats();\n     thread_stats.real_frees++;\n@@ -299,23 +358,26 @@ struct Allocator {\n     // This could be a user-facing chunk (with redzones), or some internal\n     // housekeeping chunk, like TransferBatch. Start by assuming the former.\n     AsanChunk *ac = GetAsanChunk((void *)chunk);\n-    uptr allocated_size = allocator.GetActuallyAllocatedSize((void *)ac);\n-    uptr beg = ac->Beg();\n-    uptr end = ac->Beg() + ac->UsedSize(true);\n-    uptr chunk_end = chunk + allocated_size;\n-    if (chunk < beg && beg < end && end <= chunk_end &&\n-        ac->chunk_state == CHUNK_ALLOCATED) {\n-      // Looks like a valid AsanChunk in use, poison redzones only.\n-      PoisonShadow(chunk, beg - chunk, kAsanHeapLeftRedzoneMagic);\n-      uptr end_aligned_down = RoundDownTo(end, SHADOW_GRANULARITY);\n-      FastPoisonShadowPartialRightRedzone(\n-          end_aligned_down, end - end_aligned_down,\n-          chunk_end - end_aligned_down, kAsanHeapLeftRedzoneMagic);\n-    } else {\n-      // This is either not an AsanChunk or freed or quarantined AsanChunk.\n-      // In either case, poison everything.\n-      PoisonShadow(chunk, allocated_size, kAsanHeapLeftRedzoneMagic);\n+    uptr allocated_size = allocator.GetActuallyAllocatedSize((void *)chunk);\n+    if (ac && atomic_load(&ac->chunk_state, memory_order_acquire) ==\n+                  CHUNK_ALLOCATED) {\n+      uptr beg = ac->Beg();\n+      uptr end = ac->Beg() + ac->UsedSize();\n+      uptr chunk_end = chunk + allocated_size;\n+      if (chunk < beg && beg < end && end <= chunk_end) {\n+        // Looks like a valid AsanChunk in use, poison redzones only.\n+        PoisonShadow(chunk, beg - chunk, kAsanHeapLeftRedzoneMagic);\n+        uptr end_aligned_down = RoundDownTo(end, SHADOW_GRANULARITY);\n+        FastPoisonShadowPartialRightRedzone(\n+            end_aligned_down, end - end_aligned_down,\n+            chunk_end - end_aligned_down, kAsanHeapLeftRedzoneMagic);\n+        return;\n+      }\n     }\n+\n+    // This is either not an AsanChunk or freed or quarantined AsanChunk.\n+    // In either case, poison everything.\n+    PoisonShadow(chunk, allocated_size, kAsanHeapLeftRedzoneMagic);\n   }\n \n   void ReInitialize(const AllocatorOptions &options) {\n@@ -348,17 +410,18 @@ struct Allocator {\n \n   // -------------------- Helper methods. -------------------------\n   uptr ComputeRZLog(uptr user_requested_size) {\n-    u32 rz_log =\n-      user_requested_size <= 64        - 16   ? 0 :\n-      user_requested_size <= 128       - 32   ? 1 :\n-      user_requested_size <= 512       - 64   ? 2 :\n-      user_requested_size <= 4096      - 128  ? 3 :\n-      user_requested_size <= (1 << 14) - 256  ? 4 :\n-      user_requested_size <= (1 << 15) - 512  ? 5 :\n-      user_requested_size <= (1 << 16) - 1024 ? 6 : 7;\n-    u32 min_rz = atomic_load(&min_redzone, memory_order_acquire);\n-    u32 max_rz = atomic_load(&max_redzone, memory_order_acquire);\n-    return Min(Max(rz_log, RZSize2Log(min_rz)), RZSize2Log(max_rz));\n+    u32 rz_log = user_requested_size <= 64 - 16            ? 0\n+                 : user_requested_size <= 128 - 32         ? 1\n+                 : user_requested_size <= 512 - 64         ? 2\n+                 : user_requested_size <= 4096 - 128       ? 3\n+                 : user_requested_size <= (1 << 14) - 256  ? 4\n+                 : user_requested_size <= (1 << 15) - 512  ? 5\n+                 : user_requested_size <= (1 << 16) - 1024 ? 6\n+                                                           : 7;\n+    u32 hdr_log = RZSize2Log(RoundUpToPowerOfTwo(sizeof(ChunkHeader)));\n+    u32 min_log = RZSize2Log(atomic_load(&min_redzone, memory_order_acquire));\n+    u32 max_log = RZSize2Log(atomic_load(&max_redzone, memory_order_acquire));\n+    return Min(Max(rz_log, Max(min_log, hdr_log)), Max(max_log, hdr_log));\n   }\n \n   static uptr ComputeUserRequestedAlignmentLog(uptr user_requested_alignment) {\n@@ -378,16 +441,23 @@ struct Allocator {\n   // We have an address between two chunks, and we want to report just one.\n   AsanChunk *ChooseChunk(uptr addr, AsanChunk *left_chunk,\n                          AsanChunk *right_chunk) {\n+    if (!left_chunk)\n+      return right_chunk;\n+    if (!right_chunk)\n+      return left_chunk;\n     // Prefer an allocated chunk over freed chunk and freed chunk\n     // over available chunk.\n-    if (left_chunk->chunk_state != right_chunk->chunk_state) {\n-      if (left_chunk->chunk_state == CHUNK_ALLOCATED)\n+    u8 left_state = atomic_load(&left_chunk->chunk_state, memory_order_relaxed);\n+    u8 right_state =\n+        atomic_load(&right_chunk->chunk_state, memory_order_relaxed);\n+    if (left_state != right_state) {\n+      if (left_state == CHUNK_ALLOCATED)\n         return left_chunk;\n-      if (right_chunk->chunk_state == CHUNK_ALLOCATED)\n+      if (right_state == CHUNK_ALLOCATED)\n         return right_chunk;\n-      if (left_chunk->chunk_state == CHUNK_QUARANTINE)\n+      if (left_state == CHUNK_QUARANTINE)\n         return left_chunk;\n-      if (right_chunk->chunk_state == CHUNK_QUARANTINE)\n+      if (right_state == CHUNK_QUARANTINE)\n         return right_chunk;\n     }\n     // Same chunk_state: choose based on offset.\n@@ -402,10 +472,11 @@ struct Allocator {\n   bool UpdateAllocationStack(uptr addr, BufferedStackTrace *stack) {\n     AsanChunk *m = GetAsanChunkByAddr(addr);\n     if (!m) return false;\n-    if (m->chunk_state != CHUNK_ALLOCATED) return false;\n+    if (atomic_load(&m->chunk_state, memory_order_acquire) != CHUNK_ALLOCATED)\n+      return false;\n     if (m->Beg() != addr) return false;\n-    atomic_store((atomic_uint32_t *)&m->alloc_context_id, StackDepotPut(*stack),\n-                 memory_order_relaxed);\n+    AsanThread *t = GetCurrentThread();\n+    m->SetAllocContext(t ? t->tid() : 0, StackDepotPut(*stack));\n     return true;\n   }\n \n@@ -442,13 +513,10 @@ struct Allocator {\n     uptr needed_size = rounded_size + rz_size;\n     if (alignment > min_alignment)\n       needed_size += alignment;\n-    bool using_primary_allocator = true;\n     // If we are allocating from the secondary allocator, there will be no\n     // automatic right redzone, so add the right redzone manually.\n-    if (!PrimaryAllocator::CanAllocate(needed_size, alignment)) {\n+    if (!PrimaryAllocator::CanAllocate(needed_size, alignment))\n       needed_size += rz_size;\n-      using_primary_allocator = false;\n-    }\n     CHECK(IsAligned(needed_size, min_alignment));\n     if (size > kMaxAllowedMallocSize || needed_size > kMaxAllowedMallocSize ||\n         size > max_user_defined_malloc_size) {\n@@ -490,40 +558,19 @@ struct Allocator {\n \n     uptr alloc_beg = reinterpret_cast<uptr>(allocated);\n     uptr alloc_end = alloc_beg + needed_size;\n-    uptr beg_plus_redzone = alloc_beg + rz_size;\n-    uptr user_beg = beg_plus_redzone;\n+    uptr user_beg = alloc_beg + rz_size;\n     if (!IsAligned(user_beg, alignment))\n       user_beg = RoundUpTo(user_beg, alignment);\n     uptr user_end = user_beg + size;\n     CHECK_LE(user_end, alloc_end);\n     uptr chunk_beg = user_beg - kChunkHeaderSize;\n     AsanChunk *m = reinterpret_cast<AsanChunk *>(chunk_beg);\n     m->alloc_type = alloc_type;\n-    m->rz_log = rz_log;\n-    u32 alloc_tid = t ? t->tid() : 0;\n-    m->alloc_tid = alloc_tid;\n-    CHECK_EQ(alloc_tid, m->alloc_tid);  // Does alloc_tid fit into the bitfield?\n-    m->free_tid = kInvalidTid;\n-    m->from_memalign = user_beg != beg_plus_redzone;\n-    if (alloc_beg != chunk_beg) {\n-      CHECK_LE(alloc_beg+ 2 * sizeof(uptr), chunk_beg);\n-      reinterpret_cast<uptr *>(alloc_beg)[0] = kAllocBegMagic;\n-      reinterpret_cast<uptr *>(alloc_beg)[1] = chunk_beg;\n-    }\n-    if (using_primary_allocator) {\n-      CHECK(size);\n-      m->user_requested_size = size;\n-      CHECK(allocator.FromPrimary(allocated));\n-    } else {\n-      CHECK(!allocator.FromPrimary(allocated));\n-      m->user_requested_size = SizeClassMap::kMaxSize;\n-      uptr *meta = reinterpret_cast<uptr *>(allocator.GetMetaData(allocated));\n-      meta[0] = size;\n-      meta[1] = chunk_beg;\n-    }\n+    CHECK(size);\n+    m->SetUsedSize(size);\n     m->user_requested_alignment_log = user_requested_alignment_log;\n \n-    m->alloc_context_id = StackDepotPut(*stack);\n+    m->SetAllocContext(t ? t->tid() : 0, StackDepotPut(*stack));\n \n     uptr size_rounded_down_to_granularity =\n         RoundDownTo(size, SHADOW_GRANULARITY);\n@@ -556,38 +603,41 @@ struct Allocator {\n                                                  : __lsan::kDirectlyLeaked;\n #endif\n     // Must be the last mutation of metadata in this function.\n-    atomic_store((atomic_uint8_t *)m, CHUNK_ALLOCATED, memory_order_release);\n+    atomic_store(&m->chunk_state, CHUNK_ALLOCATED, memory_order_release);\n+    if (alloc_beg != chunk_beg) {\n+      CHECK_LE(alloc_beg + sizeof(LargeChunkHeader), chunk_beg);\n+      reinterpret_cast<LargeChunkHeader *>(alloc_beg)->Set(m);\n+    }\n     ASAN_MALLOC_HOOK(res, size);\n     return res;\n   }\n \n   // Set quarantine flag if chunk is allocated, issue ASan error report on\n   // available and quarantined chunks. Return true on success, false otherwise.\n   bool AtomicallySetQuarantineFlagIfAllocated(AsanChunk *m, void *ptr,\n-                                   BufferedStackTrace *stack) {\n+                                              BufferedStackTrace *stack) {\n     u8 old_chunk_state = CHUNK_ALLOCATED;\n     // Flip the chunk_state atomically to avoid race on double-free.\n-    if (!atomic_compare_exchange_strong((atomic_uint8_t *)m, &old_chunk_state,\n+    if (!atomic_compare_exchange_strong(&m->chunk_state, &old_chunk_state,\n                                         CHUNK_QUARANTINE,\n                                         memory_order_acquire)) {\n       ReportInvalidFree(ptr, old_chunk_state, stack);\n       // It's not safe to push a chunk in quarantine on invalid free.\n       return false;\n     }\n     CHECK_EQ(CHUNK_ALLOCATED, old_chunk_state);\n+    // It was a user data.\n+    m->SetFreeContext(kInvalidTid, 0);\n     return true;\n   }\n \n   // Expects the chunk to already be marked as quarantined by using\n   // AtomicallySetQuarantineFlagIfAllocated.\n   void QuarantineChunk(AsanChunk *m, void *ptr, BufferedStackTrace *stack) {\n-    CHECK_EQ(m->chunk_state, CHUNK_QUARANTINE);\n-    CHECK_GE(m->alloc_tid, 0);\n-    if (SANITIZER_WORDSIZE == 64)  // On 32-bits this resides in user area.\n-      CHECK_EQ(m->free_tid, kInvalidTid);\n+    CHECK_EQ(atomic_load(&m->chunk_state, memory_order_relaxed),\n+             CHUNK_QUARANTINE);\n     AsanThread *t = GetCurrentThread();\n-    m->free_tid = t ? t->tid() : 0;\n-    m->free_context_id = StackDepotPut(*stack);\n+    m->SetFreeContext(t ? t->tid() : 0, StackDepotPut(*stack));\n \n     Flags &fl = *flags();\n     if (fl.max_free_fill_size > 0) {\n@@ -676,7 +726,7 @@ struct Allocator {\n \n     void *new_ptr = Allocate(new_size, 8, stack, FROM_MALLOC, true);\n     if (new_ptr) {\n-      u8 chunk_state = m->chunk_state;\n+      u8 chunk_state = atomic_load(&m->chunk_state, memory_order_acquire);\n       if (chunk_state != CHUNK_ALLOCATED)\n         ReportInvalidFree(old_ptr, chunk_state, stack);\n       CHECK_NE(REAL(memcpy), nullptr);\n@@ -719,17 +769,24 @@ struct Allocator {\n   // -------------------------- Chunk lookup ----------------------\n \n   // Assumes alloc_beg == allocator.GetBlockBegin(alloc_beg).\n+  // Returns nullptr if AsanChunk is not yet initialized just after\n+  // get_allocator().Allocate(), or is being destroyed just before\n+  // get_allocator().Deallocate().\n   AsanChunk *GetAsanChunk(void *alloc_beg) {\n-    if (!alloc_beg) return nullptr;\n-    if (!allocator.FromPrimary(alloc_beg)) {\n-      uptr *meta = reinterpret_cast<uptr *>(allocator.GetMetaData(alloc_beg));\n-      AsanChunk *m = reinterpret_cast<AsanChunk *>(meta[1]);\n-      return m;\n+    if (!alloc_beg)\n+      return nullptr;\n+    AsanChunk *p = reinterpret_cast<LargeChunkHeader *>(alloc_beg)->Get();\n+    if (!p) {\n+      if (!allocator.FromPrimary(alloc_beg))\n+        return nullptr;\n+      p = reinterpret_cast<AsanChunk *>(alloc_beg);\n     }\n-    uptr *alloc_magic = reinterpret_cast<uptr *>(alloc_beg);\n-    if (alloc_magic[0] == kAllocBegMagic)\n-      return reinterpret_cast<AsanChunk *>(alloc_magic[1]);\n-    return reinterpret_cast<AsanChunk *>(alloc_beg);\n+    u8 state = atomic_load(&p->chunk_state, memory_order_relaxed);\n+    // It does not guaranty that Chunk is initialized, but it's\n+    // definitely not for any other value.\n+    if (state == CHUNK_ALLOCATED || state == CHUNK_QUARANTINE)\n+      return p;\n+    return nullptr;\n   }\n \n   AsanChunk *GetAsanChunkByAddr(uptr p) {\n@@ -747,16 +804,16 @@ struct Allocator {\n   uptr AllocationSize(uptr p) {\n     AsanChunk *m = GetAsanChunkByAddr(p);\n     if (!m) return 0;\n-    if (m->chunk_state != CHUNK_ALLOCATED) return 0;\n+    if (atomic_load(&m->chunk_state, memory_order_acquire) != CHUNK_ALLOCATED)\n+      return 0;\n     if (m->Beg() != p) return 0;\n     return m->UsedSize();\n   }\n \n   AsanChunkView FindHeapChunkByAddress(uptr addr) {\n     AsanChunk *m1 = GetAsanChunkByAddr(addr);\n-    if (!m1) return AsanChunkView(m1);\n     sptr offset = 0;\n-    if (AsanChunkView(m1).AddrIsAtLeft(addr, 1, &offset)) {\n+    if (!m1 || AsanChunkView(m1).AddrIsAtLeft(addr, 1, &offset)) {\n       // The address is in the chunk's left redzone, so maybe it is actually\n       // a right buffer overflow from the other chunk to the left.\n       // Search a bit to the left to see if there is another chunk.\n@@ -813,22 +870,40 @@ static AsanAllocator &get_allocator() {\n }\n \n bool AsanChunkView::IsValid() const {\n-  return chunk_ && chunk_->chunk_state != CHUNK_AVAILABLE;\n+  return chunk_ && atomic_load(&chunk_->chunk_state, memory_order_relaxed) !=\n+                       CHUNK_INVALID;\n }\n bool AsanChunkView::IsAllocated() const {\n-  return chunk_ && chunk_->chunk_state == CHUNK_ALLOCATED;\n+  return chunk_ && atomic_load(&chunk_->chunk_state, memory_order_relaxed) ==\n+                       CHUNK_ALLOCATED;\n }\n bool AsanChunkView::IsQuarantined() const {\n-  return chunk_ && chunk_->chunk_state == CHUNK_QUARANTINE;\n+  return chunk_ && atomic_load(&chunk_->chunk_state, memory_order_relaxed) ==\n+                       CHUNK_QUARANTINE;\n }\n uptr AsanChunkView::Beg() const { return chunk_->Beg(); }\n uptr AsanChunkView::End() const { return Beg() + UsedSize(); }\n uptr AsanChunkView::UsedSize() const { return chunk_->UsedSize(); }\n u32 AsanChunkView::UserRequestedAlignment() const {\n   return Allocator::ComputeUserAlignment(chunk_->user_requested_alignment_log);\n }\n-uptr AsanChunkView::AllocTid() const { return chunk_->alloc_tid; }\n-uptr AsanChunkView::FreeTid() const { return chunk_->free_tid; }\n+\n+uptr AsanChunkView::AllocTid() const {\n+  u32 tid = 0;\n+  u32 stack = 0;\n+  chunk_->GetAllocContext(tid, stack);\n+  return tid;\n+}\n+\n+uptr AsanChunkView::FreeTid() const {\n+  if (!IsQuarantined())\n+    return kInvalidTid;\n+  u32 tid = 0;\n+  u32 stack = 0;\n+  chunk_->GetFreeContext(tid, stack);\n+  return tid;\n+}\n+\n AllocType AsanChunkView::GetAllocType() const {\n   return (AllocType)chunk_->alloc_type;\n }\n@@ -840,8 +915,21 @@ static StackTrace GetStackTraceFromId(u32 id) {\n   return res;\n }\n \n-u32 AsanChunkView::GetAllocStackId() const { return chunk_->alloc_context_id; }\n-u32 AsanChunkView::GetFreeStackId() const { return chunk_->free_context_id; }\n+u32 AsanChunkView::GetAllocStackId() const {\n+  u32 tid = 0;\n+  u32 stack = 0;\n+  chunk_->GetAllocContext(tid, stack);\n+  return stack;\n+}\n+\n+u32 AsanChunkView::GetFreeStackId() const {\n+  if (!IsQuarantined())\n+    return 0;\n+  u32 tid = 0;\n+  u32 stack = 0;\n+  chunk_->GetFreeContext(tid, stack);\n+  return stack;\n+}\n \n StackTrace AsanChunkView::GetAllocStack() const {\n   return GetStackTraceFromId(GetAllocStackId());\n@@ -1005,7 +1093,7 @@ void AsanSoftRssLimitExceededCallback(bool limit_exceeded) {\n   instance.SetRssLimitExceeded(limit_exceeded);\n }\n \n-} // namespace __asan\n+}  // namespace __asan\n \n // --- Implementation of LSan-specific functions --- {{{1\n namespace __lsan {\n@@ -1022,34 +1110,36 @@ void GetAllocatorGlobalRange(uptr *begin, uptr *end) {\n   *end = *begin + sizeof(__asan::get_allocator());\n }\n \n-uptr PointsIntoChunk(void* p) {\n+uptr PointsIntoChunk(void *p) {\n   uptr addr = reinterpret_cast<uptr>(p);\n   __asan::AsanChunk *m = __asan::instance.GetAsanChunkByAddrFastLocked(addr);\n-  if (!m) return 0;\n-  uptr chunk = m->Beg();\n-  if (m->chunk_state != __asan::CHUNK_ALLOCATED)\n+  if (!m || atomic_load(&m->chunk_state, memory_order_acquire) !=\n+                __asan::CHUNK_ALLOCATED)\n     return 0;\n-  if (m->AddrIsInside(addr, /*locked_version=*/true))\n+  uptr chunk = m->Beg();\n+  if (m->AddrIsInside(addr))\n     return chunk;\n-  if (IsSpecialCaseOfOperatorNew0(chunk, m->UsedSize(/*locked_version*/ true),\n-                                  addr))\n+  if (IsSpecialCaseOfOperatorNew0(chunk, m->UsedSize(), addr))\n     return chunk;\n   return 0;\n }\n \n uptr GetUserBegin(uptr chunk) {\n   __asan::AsanChunk *m = __asan::instance.GetAsanChunkByAddrFastLocked(chunk);\n-  CHECK(m);\n-  return m->Beg();\n+  return m ? m->Beg() : 0;\n }\n \n LsanMetadata::LsanMetadata(uptr chunk) {\n-  metadata_ = reinterpret_cast<void *>(chunk - __asan::kChunkHeaderSize);\n+  metadata_ = chunk ? reinterpret_cast<void *>(chunk - __asan::kChunkHeaderSize)\n+                    : nullptr;\n }\n \n bool LsanMetadata::allocated() const {\n+  if (!metadata_)\n+    return false;\n   __asan::AsanChunk *m = reinterpret_cast<__asan::AsanChunk *>(metadata_);\n-  return m->chunk_state == __asan::CHUNK_ALLOCATED;\n+  return atomic_load(&m->chunk_state, memory_order_relaxed) ==\n+         __asan::CHUNK_ALLOCATED;\n }\n \n ChunkTag LsanMetadata::tag() const {\n@@ -1064,12 +1154,15 @@ void LsanMetadata::set_tag(ChunkTag value) {\n \n uptr LsanMetadata::requested_size() const {\n   __asan::AsanChunk *m = reinterpret_cast<__asan::AsanChunk *>(metadata_);\n-  return m->UsedSize(/*locked_version=*/true);\n+  return m->UsedSize();\n }\n \n u32 LsanMetadata::stack_trace_id() const {\n   __asan::AsanChunk *m = reinterpret_cast<__asan::AsanChunk *>(metadata_);\n-  return m->alloc_context_id;\n+  u32 tid = 0;\n+  u32 stack = 0;\n+  m->GetAllocContext(tid, stack);\n+  return stack;\n }\n \n void ForEachChunk(ForEachChunkCallback callback, void *arg) {\n@@ -1079,15 +1172,16 @@ void ForEachChunk(ForEachChunkCallback callback, void *arg) {\n IgnoreObjectResult IgnoreObjectLocked(const void *p) {\n   uptr addr = reinterpret_cast<uptr>(p);\n   __asan::AsanChunk *m = __asan::instance.GetAsanChunkByAddr(addr);\n-  if (!m) return kIgnoreObjectInvalid;\n-  if ((m->chunk_state == __asan::CHUNK_ALLOCATED) && m->AddrIsInside(addr)) {\n-    if (m->lsan_tag == kIgnored)\n-      return kIgnoreObjectAlreadyIgnored;\n-    m->lsan_tag = __lsan::kIgnored;\n-    return kIgnoreObjectSuccess;\n-  } else {\n+  if (!m ||\n+      (atomic_load(&m->chunk_state, memory_order_acquire) !=\n+       __asan::CHUNK_ALLOCATED) ||\n+      !m->AddrIsInside(addr)) {\n     return kIgnoreObjectInvalid;\n   }\n+  if (m->lsan_tag == kIgnored)\n+    return kIgnoreObjectAlreadyIgnored;\n+  m->lsan_tag = __lsan::kIgnored;\n+  return kIgnoreObjectSuccess;\n }\n }  // namespace __lsan\n "}, {"sha": "2963e979b55c0cd1b28622bac8df2830af4f25b5", "filename": "libsanitizer/asan/asan_allocator.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -15,10 +15,11 @@\n #define ASAN_ALLOCATOR_H\n \n #include \"asan_flags.h\"\n-#include \"asan_internal.h\"\n #include \"asan_interceptors.h\"\n+#include \"asan_internal.h\"\n #include \"sanitizer_common/sanitizer_allocator.h\"\n #include \"sanitizer_common/sanitizer_list.h\"\n+#include \"sanitizer_common/sanitizer_platform.h\"\n \n namespace __asan {\n \n@@ -28,7 +29,7 @@ enum AllocType {\n   FROM_NEW_BR = 3   // Memory block came from operator new [ ]\n };\n \n-struct AsanChunk;\n+class AsanChunk;\n \n struct AllocatorOptions {\n   u32 quarantine_size_mb;\n@@ -132,6 +133,10 @@ typedef DefaultSizeClassMap SizeClassMap;\n const uptr kAllocatorSpace =  ~(uptr)0;\n const uptr kAllocatorSize  =  0x2000000000ULL;  // 128G.\n typedef VeryCompactSizeClassMap SizeClassMap;\n+#elif SANITIZER_RISCV64\n+const uptr kAllocatorSpace = ~(uptr)0;\n+const uptr kAllocatorSize = 0x2000000000ULL;  // 128G.\n+typedef VeryDenseSizeClassMap SizeClassMap;\n # elif defined(__aarch64__)\n // AArch64/SANITIZER_CAN_USE_ALLOCATOR64 is only for 42-bit VMA\n // so no need to different values for different VMA.\n@@ -171,7 +176,7 @@ template <typename AddressSpaceViewTy>\n struct AP32 {\n   static const uptr kSpaceBeg = 0;\n   static const u64 kSpaceSize = SANITIZER_MMAP_RANGE_SIZE;\n-  static const uptr kMetadataSize = 16;\n+  static const uptr kMetadataSize = 0;\n   typedef __asan::SizeClassMap SizeClassMap;\n   static const uptr kRegionSizeLog = 20;\n   using AddressSpaceView = AddressSpaceViewTy;"}, {"sha": "cb6a89fe32ce752de484a9479ed007290991fc12", "filename": "libsanitizer/asan/asan_flags.cpp", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_flags.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_flags.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_flags.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -26,10 +26,6 @@ namespace __asan {\n \n Flags asan_flags_dont_use_directly;  // use via flags().\n \n-static const char *MaybeCallAsanDefaultOptions() {\n-  return (&__asan_default_options) ? __asan_default_options() : \"\";\n-}\n-\n static const char *MaybeUseAsanDefaultOptionsCompileDefinition() {\n #ifdef ASAN_DEFAULT_OPTIONS\n   return SANITIZER_STRINGIFY(ASAN_DEFAULT_OPTIONS);\n@@ -108,14 +104,14 @@ void InitializeFlags() {\n   asan_parser.ParseString(asan_compile_def);\n \n   // Override from user-specified string.\n-  const char *asan_default_options = MaybeCallAsanDefaultOptions();\n+  const char *asan_default_options = __asan_default_options();\n   asan_parser.ParseString(asan_default_options);\n #if CAN_SANITIZE_UB\n-  const char *ubsan_default_options = __ubsan::MaybeCallUbsanDefaultOptions();\n+  const char *ubsan_default_options = __ubsan_default_options();\n   ubsan_parser.ParseString(ubsan_default_options);\n #endif\n #if CAN_SANITIZE_LEAKS\n-  const char *lsan_default_options = __lsan::MaybeCallLsanDefaultOptions();\n+  const char *lsan_default_options = __lsan_default_options();\n   lsan_parser.ParseString(lsan_default_options);\n #endif\n "}, {"sha": "ec15abfa0fe8956512ea6981c0aa8c05ef0dbc5d", "filename": "libsanitizer/asan/asan_fuchsia.cpp", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_fuchsia.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_fuchsia.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_fuchsia.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -62,6 +62,8 @@ void AsanOnDeadlySignal(int signo, void *siginfo, void *context) {\n   UNIMPLEMENTED();\n }\n \n+bool PlatformUnpoisonStacks() { return false; }\n+\n // We can use a plain thread_local variable for TSD.\n static thread_local void *per_thread;\n \n@@ -196,6 +198,10 @@ bool HandleDlopenInit() {\n   return false;\n }\n \n+void FlushUnneededASanShadowMemory(uptr p, uptr size) {\n+  __sanitizer_fill_shadow(p, size, 0, 0);\n+}\n+\n }  // namespace __asan\n \n // These are declared (in extern \"C\") by <zircon/sanitizer.h>."}, {"sha": "9d7dbc6f264cea7b80a71a91da37cfa0cfbbd0db", "filename": "libsanitizer/asan/asan_globals.cpp", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_globals.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_globals.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_globals.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -154,6 +154,23 @@ static void CheckODRViolationViaIndicator(const Global *g) {\n   }\n }\n \n+// Check ODR violation for given global G by checking if it's already poisoned.\n+// We use this method in case compiler doesn't use private aliases for global\n+// variables.\n+static void CheckODRViolationViaPoisoning(const Global *g) {\n+  if (__asan_region_is_poisoned(g->beg, g->size_with_redzone)) {\n+    // This check may not be enough: if the first global is much larger\n+    // the entire redzone of the second global may be within the first global.\n+    for (ListOfGlobals *l = list_of_all_globals; l; l = l->next) {\n+      if (g->beg == l->g->beg &&\n+          (flags()->detect_odr_violation >= 2 || g->size != l->g->size) &&\n+          !IsODRViolationSuppressed(g->name))\n+        ReportODRViolation(g, FindRegistrationSite(g),\n+                           l->g, FindRegistrationSite(l->g));\n+    }\n+  }\n+}\n+\n // Clang provides two different ways for global variables protection:\n // it can poison the global itself or its private alias. In former\n // case we may poison same symbol multiple times, that can help us to\n@@ -199,6 +216,8 @@ static void RegisterGlobal(const Global *g) {\n     // where two globals with the same name are defined in different modules.\n     if (UseODRIndicator(g))\n       CheckODRViolationViaIndicator(g);\n+    else\n+      CheckODRViolationViaPoisoning(g);\n   }\n   if (CanPoisonMemory())\n     PoisonRedZones(*g);"}, {"sha": "8e9525673d12ae469afc508e7d6a3756af07d60a", "filename": "libsanitizer/asan/asan_interceptors.h", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -13,9 +13,10 @@\n #ifndef ASAN_INTERCEPTORS_H\n #define ASAN_INTERCEPTORS_H\n \n-#include \"asan_internal.h\"\n #include \"asan_interceptors_memintrinsics.h\"\n+#include \"asan_internal.h\"\n #include \"interception/interception.h\"\n+#include \"sanitizer_common/sanitizer_platform.h\"\n #include \"sanitizer_common/sanitizer_platform_interceptors.h\"\n \n namespace __asan {\n@@ -80,12 +81,7 @@ void InitializePlatformInterceptors();\n #if ASAN_HAS_EXCEPTIONS && !SANITIZER_WINDOWS && !SANITIZER_SOLARIS && \\\n     !SANITIZER_NETBSD\n # define ASAN_INTERCEPT___CXA_THROW 1\n-# if ! defined(ASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION) \\\n-     || ASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION\n-#   define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 1\n-# else\n-#   define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 0\n-# endif\n+# define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 1\n # if defined(_GLIBCXX_SJLJ_EXCEPTIONS) || (SANITIZER_IOS && defined(__arm__))\n #  define ASAN_INTERCEPT__UNWIND_SJLJ_RAISEEXCEPTION 1\n # else\n@@ -116,8 +112,9 @@ void InitializePlatformInterceptors();\n # define ASAN_INTERCEPT___STRDUP 0\n #endif\n \n-#if SANITIZER_LINUX && (defined(__arm__) || defined(__aarch64__) || \\\n-                        defined(__i386__) || defined(__x86_64__))\n+#if SANITIZER_LINUX &&                                                \\\n+    (defined(__arm__) || defined(__aarch64__) || defined(__i386__) || \\\n+     defined(__x86_64__) || SANITIZER_RISCV64)\n # define ASAN_INTERCEPT_VFORK 1\n #else\n # define ASAN_INTERCEPT_VFORK 0"}, {"sha": "3ae5503e83cdb550688f1e4e67f18bfa79269f0c", "filename": "libsanitizer/asan/asan_interceptors_vfork.S", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_interceptors_vfork.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_interceptors_vfork.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors_vfork.S?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -5,8 +5,9 @@\n #define COMMON_INTERCEPTOR_HANDLE_VFORK __asan_handle_vfork\n #include \"sanitizer_common/sanitizer_common_interceptors_vfork_aarch64.inc.S\"\n #include \"sanitizer_common/sanitizer_common_interceptors_vfork_arm.inc.S\"\n-#include \"sanitizer_common/sanitizer_common_interceptors_vfork_x86_64.inc.S\"\n #include \"sanitizer_common/sanitizer_common_interceptors_vfork_i386.inc.S\"\n+#include \"sanitizer_common/sanitizer_common_interceptors_vfork_riscv64.inc.S\"\n+#include \"sanitizer_common/sanitizer_common_interceptors_vfork_x86_64.inc.S\"\n #endif\n \n NO_EXEC_STACK_DIRECTIVE"}, {"sha": "3e6e660288746543a8d11b79f77f6ddb6e92dee7", "filename": "libsanitizer/asan/asan_interface_internal.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_interface_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_interface_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interface_internal.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -173,8 +173,8 @@ extern \"C\" {\n \n   SANITIZER_INTERFACE_ATTRIBUTE void __asan_print_accumulated_stats();\n \n-  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-  const char* __asan_default_options();\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  const char *__asan_default_options();\n \n   SANITIZER_INTERFACE_ATTRIBUTE\n   extern uptr __asan_shadow_memory_dynamic_address;"}, {"sha": "cfb54927c6cf4fea8dc7e83ab0f054b5357f5574", "filename": "libsanitizer/asan/asan_internal.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_internal.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -83,6 +83,16 @@ void *AsanDoesNotSupportStaticLinkage();\n void AsanCheckDynamicRTPrereqs();\n void AsanCheckIncompatibleRT();\n \n+// Unpoisons platform-specific stacks.\n+// Returns true if all stacks have been unpoisoned.\n+bool PlatformUnpoisonStacks();\n+\n+// asan_rtl.cpp\n+// Unpoison a region containing a stack.\n+// Performs a sanity check and warns if the bounds don't look right.\n+// The warning contains the type string to identify the stack type.\n+void UnpoisonStack(uptr bottom, uptr top, const char *type);\n+\n // asan_thread.cpp\n AsanThread *CreateMainThread();\n \n@@ -108,8 +118,6 @@ void AppendToErrorMessageBuffer(const char *buffer);\n \n void *AsanDlSymNext(const char *sym);\n \n-void ReserveShadowMemoryRange(uptr beg, uptr end, const char *name);\n-\n // Returns `true` iff most of ASan init process should be skipped due to the\n // ASan library being loaded via `dlopen()`. Platforms may perform any\n // `dlopen()` specific initialization inside this function."}, {"sha": "fb1a442b3d43780fb9d612344dba978761cbed22", "filename": "libsanitizer/asan/asan_linux.cpp", "status": "modified", "additions": 12, "deletions": 30, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_linux.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -87,57 +87,39 @@ void *AsanDoesNotSupportStaticLinkage() {\n   return &_DYNAMIC;  // defined in link.h\n }\n \n-static void UnmapFromTo(uptr from, uptr to) {\n-  CHECK(to >= from);\n-  if (to == from) return;\n-  uptr res = internal_munmap(reinterpret_cast<void *>(from), to - from);\n-  if (UNLIKELY(internal_iserror(res))) {\n-    Report(\n-        \"ERROR: AddresSanitizer failed to unmap 0x%zx (%zd) bytes at address \"\n-        \"%p\\n\",\n-        to - from, to - from, from);\n-    CHECK(\"unable to unmap\" && 0);\n-  }\n-}\n-\n #if ASAN_PREMAP_SHADOW\n-uptr FindPremappedShadowStart() {\n+uptr FindPremappedShadowStart(uptr shadow_size_bytes) {\n   uptr granularity = GetMmapGranularity();\n   uptr shadow_start = reinterpret_cast<uptr>(&__asan_shadow);\n   uptr premap_shadow_size = PremapShadowSize();\n-  uptr shadow_size = RoundUpTo(kHighShadowEnd, granularity);\n+  uptr shadow_size = RoundUpTo(shadow_size_bytes, granularity);\n   // We may have mapped too much. Release extra memory.\n   UnmapFromTo(shadow_start + shadow_size, shadow_start + premap_shadow_size);\n   return shadow_start;\n }\n #endif\n \n uptr FindDynamicShadowStart() {\n+  uptr shadow_size_bytes = MemToShadowSize(kHighMemEnd);\n #if ASAN_PREMAP_SHADOW\n   if (!PremapShadowFailed())\n-    return FindPremappedShadowStart();\n+    return FindPremappedShadowStart(shadow_size_bytes);\n #endif\n \n-  uptr granularity = GetMmapGranularity();\n-  uptr alignment = granularity * 8;\n-  uptr left_padding = granularity;\n-  uptr shadow_size = RoundUpTo(kHighShadowEnd, granularity);\n-  uptr map_size = shadow_size + left_padding + alignment;\n-\n-  uptr map_start = (uptr)MmapNoAccess(map_size);\n-  CHECK_NE(map_start, ~(uptr)0);\n-\n-  uptr shadow_start = RoundUpTo(map_start + left_padding, alignment);\n-  UnmapFromTo(map_start, shadow_start - left_padding);\n-  UnmapFromTo(shadow_start + shadow_size, map_start + map_size);\n-\n-  return shadow_start;\n+  return MapDynamicShadow(shadow_size_bytes, SHADOW_SCALE,\n+                          /*min_shadow_base_alignment*/ 0, kHighMemEnd);\n }\n \n void AsanApplyToGlobals(globals_op_fptr op, const void *needle) {\n   UNIMPLEMENTED();\n }\n \n+void FlushUnneededASanShadowMemory(uptr p, uptr size) {\n+  // Since asan's mapping is compacting, the shadow chunk may be\n+  // not page-aligned, so we only flush the page-aligned portion.\n+  ReleaseMemoryPagesToOS(MemToShadow(p), MemToShadow(p + size));\n+}\n+\n #if SANITIZER_ANDROID\n // FIXME: should we do anything for Android?\n void AsanCheckDynamicRTPrereqs() {}"}, {"sha": "c6950547f089f2e25df33b1c323ab1f704f127fa", "filename": "libsanitizer/asan/asan_mac.cpp", "status": "modified", "additions": 8, "deletions": 40, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mac.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -55,46 +55,8 @@ void *AsanDoesNotSupportStaticLinkage() {\n }\n \n uptr FindDynamicShadowStart() {\n-  uptr granularity = GetMmapGranularity();\n-  uptr alignment = 8 * granularity;\n-  uptr left_padding = granularity;\n-  uptr space_size = kHighShadowEnd + left_padding;\n-\n-  uptr largest_gap_found = 0;\n-  uptr max_occupied_addr = 0;\n-  VReport(2, \"FindDynamicShadowStart, space_size = %p\\n\", space_size);\n-  uptr shadow_start =\n-      FindAvailableMemoryRange(space_size, alignment, granularity,\n-                               &largest_gap_found, &max_occupied_addr);\n-  // If the shadow doesn't fit, restrict the address space to make it fit.\n-  if (shadow_start == 0) {\n-    VReport(\n-        2,\n-        \"Shadow doesn't fit, largest_gap_found = %p, max_occupied_addr = %p\\n\",\n-        largest_gap_found, max_occupied_addr);\n-    uptr new_max_vm = RoundDownTo(largest_gap_found << SHADOW_SCALE, alignment);\n-    if (new_max_vm < max_occupied_addr) {\n-      Report(\"Unable to find a memory range for dynamic shadow.\\n\");\n-      Report(\n-          \"space_size = %p, largest_gap_found = %p, max_occupied_addr = %p, \"\n-          \"new_max_vm = %p\\n\",\n-          space_size, largest_gap_found, max_occupied_addr, new_max_vm);\n-      CHECK(0 && \"cannot place shadow\");\n-    }\n-    RestrictMemoryToMaxAddress(new_max_vm);\n-    kHighMemEnd = new_max_vm - 1;\n-    space_size = kHighShadowEnd + left_padding;\n-    VReport(2, \"FindDynamicShadowStart, space_size = %p\\n\", space_size);\n-    shadow_start = FindAvailableMemoryRange(space_size, alignment, granularity,\n-                                            nullptr, nullptr);\n-    if (shadow_start == 0) {\n-      Report(\"Unable to find a memory range after restricting VM.\\n\");\n-      CHECK(0 && \"cannot place shadow after restricting vm\");\n-    }\n-  }\n-  CHECK_NE((uptr)0, shadow_start);\n-  CHECK(IsAligned(shadow_start, alignment));\n-  return shadow_start;\n+  return MapDynamicShadow(MemToShadowSize(kHighMemEnd), SHADOW_SCALE,\n+                          /*min_shadow_base_alignment*/ 0, kHighMemEnd);\n }\n \n // No-op. Mac does not support static linkage anyway.\n@@ -127,6 +89,12 @@ void AsanApplyToGlobals(globals_op_fptr op, const void *needle) {\n   op(globals, size / sizeof(__asan_global));\n }\n \n+void FlushUnneededASanShadowMemory(uptr p, uptr size) {\n+  // Since asan's mapping is compacting, the shadow chunk may be\n+  // not page-aligned, so we only flush the page-aligned portion.\n+  ReleaseMemoryPagesToOS(MemToShadow(p), MemToShadow(p + size));\n+}\n+\n void ReadContextStack(void *context, uptr *stack, uptr *ssize) {\n   UNIMPLEMENTED();\n }"}, {"sha": "9c3f0a5338ee5b090a1dae0e2a192c74b85340fc", "filename": "libsanitizer/asan/asan_malloc_linux.cpp", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_malloc_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_malloc_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_linux.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -34,7 +34,7 @@ static uptr last_dlsym_alloc_size_in_words;\n static const uptr kDlsymAllocPoolSize = SANITIZER_RTEMS ? 4096 : 1024;\n static uptr alloc_memory_for_dlsym[kDlsymAllocPoolSize];\n \n-static INLINE bool IsInDlsymAllocPool(const void *ptr) {\n+static inline bool IsInDlsymAllocPool(const void *ptr) {\n   uptr off = (uptr)ptr - (uptr)alloc_memory_for_dlsym;\n   return off < allocated_for_dlsym * sizeof(alloc_memory_for_dlsym[0]);\n }\n@@ -95,12 +95,12 @@ bool IsFromLocalPool(const void *ptr) {\n }\n #endif\n \n-static INLINE bool MaybeInDlsym() {\n+static inline bool MaybeInDlsym() {\n   // Fuchsia doesn't use dlsym-based interceptors.\n   return !SANITIZER_FUCHSIA && asan_init_is_running;\n }\n \n-static INLINE bool UseLocalPool() {\n+static inline bool UseLocalPool() {\n   return EarlyMalloc() || MaybeInDlsym();\n }\n \n@@ -120,19 +120,19 @@ static void *ReallocFromLocalPool(void *ptr, uptr size) {\n }\n \n INTERCEPTOR(void, free, void *ptr) {\n-  GET_STACK_TRACE_FREE;\n   if (UNLIKELY(IsInDlsymAllocPool(ptr))) {\n     DeallocateFromLocalPool(ptr);\n     return;\n   }\n+  GET_STACK_TRACE_FREE;\n   asan_free(ptr, &stack, FROM_MALLOC);\n }\n \n #if SANITIZER_INTERCEPT_CFREE\n INTERCEPTOR(void, cfree, void *ptr) {\n-  GET_STACK_TRACE_FREE;\n   if (UNLIKELY(IsInDlsymAllocPool(ptr)))\n     return;\n+  GET_STACK_TRACE_FREE;\n   asan_free(ptr, &stack, FROM_MALLOC);\n }\n #endif // SANITIZER_INTERCEPT_CFREE"}, {"sha": "e2c9be0379f2f3029e1d8d8a6a3ee9a28081c77b", "filename": "libsanitizer/asan/asan_malloc_local.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_malloc_local.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_malloc_local.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_local.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -17,7 +17,7 @@\n #include \"sanitizer_common/sanitizer_platform.h\"\n #include \"asan_internal.h\"\n \n-static INLINE bool EarlyMalloc() {\n+static inline bool EarlyMalloc() {\n   return SANITIZER_RTEMS &&\n          (!__asan::asan_inited || __asan::asan_init_is_running);\n }"}, {"sha": "f239c3ee2ff924bd8fbacf6b02e6ac4715ae38f8", "filename": "libsanitizer/asan/asan_mapping.h", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_mapping.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_mapping.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mapping.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -79,6 +79,20 @@\n // || `[0x1000000000, 0x11ffffffff]` || lowshadow  ||\n // || `[0x0000000000, 0x0fffffffff]` || lowmem     ||\n //\n+// RISC-V has only 38 bits for task size\n+// Low mem size is set with kRiscv64_ShadowOffset64 in\n+// compiler-rt/lib/asan/asan_allocator.h and in\n+// llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp with\n+// kRiscv64_ShadowOffset64, High mem top border is set with\n+// GetMaxVirtualAddress() in\n+// compiler-rt/lib/sanitizer_common/sanitizer_linux.cpp\n+// Default Linux/RISCV64 Sv39/Sv48 mapping:\n+// || `[0x000820000000, 0x003fffffffff]` || HighMem    ||\n+// || `[0x000124000000, 0x00081fffffff]` || HighShadow ||\n+// || `[0x000024000000, 0x000123ffffff]` || ShadowGap  ||\n+// || `[0x000020000000, 0x000023ffffff]` || LowShadow  ||\n+// || `[0x000000000000, 0x00001fffffff]` || LowMem     ||\n+//\n // Default Linux/AArch64 (42-bit VMA) mapping:\n // || `[0x10000000000, 0x3ffffffffff]` || highmem    ||\n // || `[0x0a000000000, 0x0ffffffffff]` || highshadow ||\n@@ -161,9 +175,10 @@ static const u64 kDefaultShadowOffset64 = 1ULL << 44;\n static const u64 kDefaultShort64bitShadowOffset =\n     0x7FFFFFFF & (~0xFFFULL << kDefaultShadowScale);  // < 2G.\n static const u64 kAArch64_ShadowOffset64 = 1ULL << 36;\n+static const u64 kRiscv64_ShadowOffset64 = 0x20000000;\n static const u64 kMIPS32_ShadowOffset32 = 0x0aaa0000;\n static const u64 kMIPS64_ShadowOffset64 = 1ULL << 37;\n-static const u64 kPPC64_ShadowOffset64 = 1ULL << 41;\n+static const u64 kPPC64_ShadowOffset64 = 1ULL << 44;\n static const u64 kSystemZ_ShadowOffset64 = 1ULL << 52;\n static const u64 kSPARC64_ShadowOffset64 = 1ULL << 43;  // 0x80000000000\n static const u64 kFreeBSD_ShadowOffset32 = 1ULL << 30;  // 0x40000000\n@@ -206,6 +221,10 @@ static const u64 kMyriadCacheBitMask32 = 0x40000000ULL;\n #else\n #  if SANITIZER_IOS\n #    define SHADOW_OFFSET __asan_shadow_memory_dynamic_address\n+#  elif SANITIZER_MAC && defined(__aarch64__)\n+#    define SHADOW_OFFSET __asan_shadow_memory_dynamic_address\n+#elif SANITIZER_RISCV64\n+#define SHADOW_OFFSET kRiscv64_ShadowOffset64\n #  elif defined(__aarch64__)\n #    define SHADOW_OFFSET kAArch64_ShadowOffset64\n #  elif defined(__powerpc64__)\n@@ -355,6 +374,8 @@ static inline bool AddrIsInShadowGap(uptr a) {\n \n namespace __asan {\n \n+static inline uptr MemToShadowSize(uptr size) { return size >> SHADOW_SCALE; }\n+\n static inline bool AddrIsInMem(uptr a) {\n   PROFILE_ASAN_MAPPING();\n   return AddrIsInLowMem(a) || AddrIsInMidMem(a) || AddrIsInHighMem(a) ||"}, {"sha": "44f872ef6190977399f1991ec17ca7d0d2fd5514", "filename": "libsanitizer/asan/asan_poisoning.cpp", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_poisoning.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_poisoning.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_poisoning.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -62,12 +62,6 @@ struct ShadowSegmentEndpoint {\n   }\n };\n \n-void FlushUnneededASanShadowMemory(uptr p, uptr size) {\n-  // Since asan's mapping is compacting, the shadow chunk may be\n-  // not page-aligned, so we only flush the page-aligned portion.\n-  ReleaseMemoryPagesToOS(MemToShadow(p), MemToShadow(p + size));\n-}\n-\n void AsanPoisonOrUnpoisonIntraObjectRedzone(uptr ptr, uptr size, bool poison) {\n   uptr end = ptr + size;\n   if (Verbosity()) {"}, {"sha": "d7f19d846544b8846ca737e07950c8b5206db8c3", "filename": "libsanitizer/asan/asan_posix.cpp", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_posix.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_posix.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_posix.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -17,13 +17,15 @@\n #include \"asan_internal.h\"\n #include \"asan_interceptors.h\"\n #include \"asan_mapping.h\"\n+#include \"asan_poisoning.h\"\n #include \"asan_report.h\"\n #include \"asan_stack.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n #include \"sanitizer_common/sanitizer_posix.h\"\n #include \"sanitizer_common/sanitizer_procmaps.h\"\n \n #include <pthread.h>\n+#include <signal.h>\n #include <stdlib.h>\n #include <sys/time.h>\n #include <sys/resource.h>\n@@ -37,6 +39,32 @@ void AsanOnDeadlySignal(int signo, void *siginfo, void *context) {\n   ReportDeadlySignal(sig);\n }\n \n+bool PlatformUnpoisonStacks() {\n+  stack_t signal_stack;\n+  CHECK_EQ(0, sigaltstack(nullptr, &signal_stack));\n+  uptr sigalt_bottom = (uptr)signal_stack.ss_sp;\n+  uptr sigalt_top = (uptr)((char *)signal_stack.ss_sp + signal_stack.ss_size);\n+  // If we're executing on the signal alternate stack AND the Linux flag\n+  // SS_AUTODISARM was used, then we cannot get the signal alternate stack\n+  // bounds from sigaltstack -- sigaltstack's output looks just as if no\n+  // alternate stack has ever been set up.\n+  // We're always unpoisoning the signal alternate stack to support jumping\n+  // between the default stack and signal alternate stack.\n+  if (signal_stack.ss_flags != SS_DISABLE)\n+    UnpoisonStack(sigalt_bottom, sigalt_top, \"sigalt\");\n+\n+  if (signal_stack.ss_flags != SS_ONSTACK)\n+    return false;\n+\n+  // Since we're on the signal altnerate stack, we cannot find the DEFAULT\n+  // stack bottom using a local variable.\n+  uptr default_bottom, tls_addr, tls_size, stack_size;\n+  GetThreadStackAndTls(/*main=*/false, &default_bottom, &stack_size, &tls_addr,\n+                       &tls_size);\n+  UnpoisonStack(default_bottom, default_bottom + stack_size, \"default\");\n+  return true;\n+}\n+\n // ---------------------- TSD ---------------- {{{1\n \n #if SANITIZER_NETBSD && !ASAN_DYNAMIC"}, {"sha": "666bb9b34bd39959c796663662256c3401cb5164", "filename": "libsanitizer/asan/asan_premap_shadow.cpp", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_premap_shadow.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_premap_shadow.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_premap_shadow.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -32,22 +32,8 @@ uptr PremapShadowSize() {\n // Returns an address aligned to 8 pages, such that one page on the left and\n // PremapShadowSize() bytes on the right of it are mapped r/o.\n uptr PremapShadow() {\n-  uptr granularity = GetMmapGranularity();\n-  uptr alignment = granularity * 8;\n-  uptr left_padding = granularity;\n-  uptr shadow_size = PremapShadowSize();\n-  uptr map_size = shadow_size + left_padding + alignment;\n-\n-  uptr map_start = (uptr)MmapNoAccess(map_size);\n-  CHECK_NE(map_start, ~(uptr)0);\n-\n-  uptr shadow_start = RoundUpTo(map_start + left_padding, alignment);\n-  uptr shadow_end = shadow_start + shadow_size;\n-  internal_munmap(reinterpret_cast<void *>(map_start),\n-                  shadow_start - left_padding - map_start);\n-  internal_munmap(reinterpret_cast<void *>(shadow_end),\n-                  map_start + map_size - shadow_end);\n-  return shadow_start;\n+  return MapDynamicShadow(PremapShadowSize(), /*mmap_alignment_scale*/ 3,\n+                          /*min_shadow_base_alignment*/ 0, kHighMemEnd);\n }\n \n bool PremapShadowFailed() {"}, {"sha": "4b4db1db6dc9c9a97ab3396112baa88b0c742105", "filename": "libsanitizer/asan/asan_report.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_report.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_report.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -411,7 +411,7 @@ static bool IsInvalidPointerPair(uptr a1, uptr a2) {\n   return false;\n }\n \n-static INLINE void CheckForInvalidPointerPair(void *p1, void *p2) {\n+static inline void CheckForInvalidPointerPair(void *p1, void *p2) {\n   switch (flags()->detect_invalid_pointer_pairs) {\n     case 0:\n       return;"}, {"sha": "ea0b4ad9db681a1e0c8edf81a02b56a633232022", "filename": "libsanitizer/asan/asan_rtems.cpp", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_rtems.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_rtems.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_rtems.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -50,6 +50,12 @@ void AsanApplyToGlobals(globals_op_fptr op, const void *needle) {\n   UNIMPLEMENTED();\n }\n \n+void FlushUnneededASanShadowMemory(uptr p, uptr size) {\n+  // Since asan's mapping is compacting, the shadow chunk may be\n+  // not page-aligned, so we only flush the page-aligned portion.\n+  ReleaseMemoryPagesToOS(MemToShadow(p), MemToShadow(p + size));\n+}\n+\n void AsanCheckDynamicRTPrereqs() {}\n void AsanCheckIncompatibleRT() {}\n void InitializeAsanInterceptors() {}\n@@ -64,6 +70,8 @@ void AsanOnDeadlySignal(int signo, void *siginfo, void *context) {\n   UNIMPLEMENTED();\n }\n \n+bool PlatformUnpoisonStacks() { return false; }\n+\n void EarlyInit() {\n   // Provide early initialization of shadow memory so that\n   // instrumented code running before full initialzation will not"}, {"sha": "115733cdaa48e195e37790d8ae1c68d875720aa3", "filename": "libsanitizer/asan/asan_rtl.cpp", "status": "modified", "additions": 46, "deletions": 29, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_rtl.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_rtl.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_rtl.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -319,7 +319,7 @@ static void InitializeHighMemEnd() {\n   kHighMemEnd = GetMaxUserVirtualAddress();\n   // Increase kHighMemEnd to make sure it's properly\n   // aligned together with kHighMemBeg:\n-  kHighMemEnd |= SHADOW_GRANULARITY * GetMmapGranularity() - 1;\n+  kHighMemEnd |= (GetMmapGranularity() << SHADOW_SCALE) - 1;\n #endif  // !ASAN_FIXED_MAPPING\n   CHECK_EQ((kHighMemBeg % GetMmapGranularity()), 0);\n #endif  // !SANITIZER_MYRIAD2\n@@ -551,22 +551,33 @@ class AsanInitializer {\n static AsanInitializer asan_initializer;\n #endif  // ASAN_DYNAMIC\n \n-} // namespace __asan\n-\n-// ---------------------- Interface ---------------- {{{1\n-using namespace __asan;\n-\n-void NOINLINE __asan_handle_no_return() {\n-  if (asan_init_is_running)\n+void UnpoisonStack(uptr bottom, uptr top, const char *type) {\n+  static const uptr kMaxExpectedCleanupSize = 64 << 20;  // 64M\n+  if (top - bottom > kMaxExpectedCleanupSize) {\n+    static bool reported_warning = false;\n+    if (reported_warning)\n+      return;\n+    reported_warning = true;\n+    Report(\n+        \"WARNING: ASan is ignoring requested __asan_handle_no_return: \"\n+        \"stack type: %s top: %p; bottom %p; size: %p (%zd)\\n\"\n+        \"False positive error reports may follow\\n\"\n+        \"For details see \"\n+        \"https://github.com/google/sanitizers/issues/189\\n\",\n+        type, top, bottom, top - bottom, top - bottom);\n     return;\n+  }\n+  PoisonShadow(bottom, top - bottom, 0);\n+}\n \n-  int local_stack;\n-  AsanThread *curr_thread = GetCurrentThread();\n-  uptr PageSize = GetPageSizeCached();\n-  uptr top, bottom;\n-  if (curr_thread) {\n+static void UnpoisonDefaultStack() {\n+  uptr bottom, top;\n+\n+  if (AsanThread *curr_thread = GetCurrentThread()) {\n+    int local_stack;\n+    const uptr page_size = GetPageSizeCached();\n     top = curr_thread->stack_top();\n-    bottom = ((uptr)&local_stack - PageSize) & ~(PageSize - 1);\n+    bottom = ((uptr)&local_stack - page_size) & ~(page_size - 1);\n   } else if (SANITIZER_RTEMS) {\n     // Give up On RTEMS.\n     return;\n@@ -578,25 +589,31 @@ void NOINLINE __asan_handle_no_return() {\n                          &tls_size);\n     top = bottom + stack_size;\n   }\n-  static const uptr kMaxExpectedCleanupSize = 64 << 20;  // 64M\n-  if (top - bottom > kMaxExpectedCleanupSize) {\n-    static bool reported_warning = false;\n-    if (reported_warning)\n-      return;\n-    reported_warning = true;\n-    Report(\"WARNING: ASan is ignoring requested __asan_handle_no_return: \"\n-           \"stack top: %p; bottom %p; size: %p (%zd)\\n\"\n-           \"False positive error reports may follow\\n\"\n-           \"For details see \"\n-           \"https://github.com/google/sanitizers/issues/189\\n\",\n-           top, bottom, top - bottom, top - bottom);\n-    return;\n-  }\n-  PoisonShadow(bottom, top - bottom, 0);\n+\n+  UnpoisonStack(bottom, top, \"default\");\n+}\n+\n+static void UnpoisonFakeStack() {\n+  AsanThread *curr_thread = GetCurrentThread();\n   if (curr_thread && curr_thread->has_fake_stack())\n     curr_thread->fake_stack()->HandleNoReturn();\n }\n \n+}  // namespace __asan\n+\n+// ---------------------- Interface ---------------- {{{1\n+using namespace __asan;\n+\n+void NOINLINE __asan_handle_no_return() {\n+  if (asan_init_is_running)\n+    return;\n+\n+  if (!PlatformUnpoisonStacks())\n+    UnpoisonDefaultStack();\n+\n+  UnpoisonFakeStack();\n+}\n+\n extern \"C\" void *__asan_extra_spill_area() {\n   AsanThread *t = GetCurrentThread();\n   CHECK(t);"}, {"sha": "2ead4425add8362f48e996cb2885b0619f01ed86", "filename": "libsanitizer/asan/asan_shadow_setup.cpp", "status": "modified", "additions": 4, "deletions": 41, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_shadow_setup.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_shadow_setup.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_shadow_setup.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -22,24 +22,6 @@\n \n namespace __asan {\n \n-// ---------------------- mmap -------------------- {{{1\n-// Reserve memory range [beg, end].\n-// We need to use inclusive range because end+1 may not be representable.\n-void ReserveShadowMemoryRange(uptr beg, uptr end, const char *name) {\n-  CHECK_EQ((beg % GetMmapGranularity()), 0);\n-  CHECK_EQ(((end + 1) % GetMmapGranularity()), 0);\n-  uptr size = end - beg + 1;\n-  DecreaseTotalMmap(size);  // Don't count the shadow against mmap_limit_mb.\n-  if (!MmapFixedSuperNoReserve(beg, size, name)) {\n-    Report(\n-        \"ReserveShadowMemoryRange failed while trying to map 0x%zx bytes. \"\n-        \"Perhaps you're using ulimit -v\\n\",\n-        size);\n-    Abort();\n-  }\n-  if (common_flags()->use_madv_dontdump) DontDumpShadowMemory(beg, size);\n-}\n-\n static void ProtectGap(uptr addr, uptr size) {\n   if (!flags()->protect_shadow_gap) {\n     // The shadow gap is unprotected, so there is a chance that someone\n@@ -57,30 +39,13 @@ static void ProtectGap(uptr addr, uptr size) {\n                              \"unprotected gap shadow\");\n     return;\n   }\n-  void *res = MmapFixedNoAccess(addr, size, \"shadow gap\");\n-  if (addr == (uptr)res) return;\n-  // A few pages at the start of the address space can not be protected.\n-  // But we really want to protect as much as possible, to prevent this memory\n-  // being returned as a result of a non-FIXED mmap().\n-  if (addr == kZeroBaseShadowStart) {\n-    uptr step = GetMmapGranularity();\n-    while (size > step && addr < kZeroBaseMaxShadowStart) {\n-      addr += step;\n-      size -= step;\n-      void *res = MmapFixedNoAccess(addr, size, \"shadow gap\");\n-      if (addr == (uptr)res) return;\n-    }\n-  }\n-\n-  Report(\n-      \"ERROR: Failed to protect the shadow gap. \"\n-      \"ASan cannot proceed correctly. ABORTING.\\n\");\n-  DumpProcessMap();\n-  Die();\n+  __sanitizer::ProtectGap(addr, size, kZeroBaseShadowStart,\n+                          kZeroBaseMaxShadowStart);\n }\n \n static void MaybeReportLinuxPIEBug() {\n-#if SANITIZER_LINUX && (defined(__x86_64__) || defined(__aarch64__))\n+#if SANITIZER_LINUX && \\\n+    (defined(__x86_64__) || defined(__aarch64__) || SANITIZER_RISCV64)\n   Report(\"This might be related to ELF_ET_DYN_BASE change in Linux 4.12.\\n\");\n   Report(\n       \"See https://github.com/google/sanitizers/issues/856 for possible \"\n@@ -99,8 +64,6 @@ void InitializeShadowMemory() {\n   // |kDefaultShadowSentinel|.\n   bool full_shadow_is_available = false;\n   if (shadow_start == kDefaultShadowSentinel) {\n-    __asan_shadow_memory_dynamic_address = 0;\n-    CHECK_EQ(0, kLowShadowBeg);\n     shadow_start = FindDynamicShadowStart();\n     if (SANITIZER_LINUX) full_shadow_is_available = true;\n   }"}, {"sha": "47ca85a1644358145f959dd63d0f1faaf5a88b5e", "filename": "libsanitizer/asan/asan_stack.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stack.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -51,11 +51,6 @@ u32 GetMallocContextSize();\n   stack.Unwind(pc, bp, nullptr,                    \\\n                common_flags()->fast_unwind_on_fatal)\n \n-#define GET_STACK_TRACE_SIGNAL(sig)                                        \\\n-  BufferedStackTrace stack;                                                \\\n-  stack.Unwind((sig).pc, (sig).bp, (sig).context,                          \\\n-               common_flags()->fast_unwind_on_fatal)\n-\n #define GET_STACK_TRACE_FATAL_HERE                                \\\n   GET_STACK_TRACE(kStackTraceMax, common_flags()->fast_unwind_on_fatal)\n "}, {"sha": "8044ae16ff9bd5507ad52b9c96d4f3e3c0fe32fe", "filename": "libsanitizer/asan/asan_win.cpp", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_win.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fasan%2Fasan_win.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -191,6 +191,12 @@ void AsanApplyToGlobals(globals_op_fptr op, const void *needle) {\n   UNIMPLEMENTED();\n }\n \n+void FlushUnneededASanShadowMemory(uptr p, uptr size) {\n+  // Since asan's mapping is compacting, the shadow chunk may be\n+  // not page-aligned, so we only flush the page-aligned portion.\n+  ReleaseMemoryPagesToOS(MemToShadow(p), MemToShadow(p + size));\n+}\n+\n // ---------------------- TSD ---------------- {{{\n static bool tsd_key_inited = false;\n \n@@ -247,15 +253,8 @@ void *AsanDoesNotSupportStaticLinkage() {\n }\n \n uptr FindDynamicShadowStart() {\n-  uptr granularity = GetMmapGranularity();\n-  uptr alignment = 8 * granularity;\n-  uptr left_padding = granularity;\n-  uptr space_size = kHighShadowEnd + left_padding;\n-  uptr shadow_start = FindAvailableMemoryRange(space_size, alignment,\n-                                               granularity, nullptr, nullptr);\n-  CHECK_NE((uptr)0, shadow_start);\n-  CHECK(IsAligned(shadow_start, alignment));\n-  return shadow_start;\n+  return MapDynamicShadow(MemToShadowSize(kHighMemEnd), SHADOW_SCALE,\n+                          /*min_shadow_base_alignment*/ 0, kHighMemEnd);\n }\n \n void AsanCheckDynamicRTPrereqs() {}\n@@ -268,6 +267,8 @@ void ReadContextStack(void *context, uptr *stack, uptr *ssize) {\n \n void AsanOnDeadlySignal(int, void *siginfo, void *context) { UNIMPLEMENTED(); }\n \n+bool PlatformUnpoisonStacks() { return false; }\n+\n #if SANITIZER_WINDOWS64\n // Exception handler for dealing with shadow memory.\n static LONG CALLBACK"}, {"sha": "792ef9cfaa32b08fd45be87e583250503076513f", "filename": "libsanitizer/include/sanitizer/asan_interface.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -188,8 +188,8 @@ const char *__asan_get_report_description(void);\n /// \\param addr Address to locate.\n /// \\param name Buffer to store the variable's name.\n /// \\param name_size Size in bytes of the variable's name buffer.\n-/// \\param region_address [out] Address of the region.\n-/// \\param region_size [out] Size of the region in bytes.\n+/// \\param[out] region_address Address of the region.\n+/// \\param[out] region_size Size of the region in bytes.\n ///\n /// \\returns Returns the category of the given pointer as a constant string.\n const char *__asan_locate_address(void *addr, char *name, size_t name_size,\n@@ -204,7 +204,7 @@ const char *__asan_locate_address(void *addr, char *name, size_t name_size,\n /// \\param addr A heap address.\n /// \\param trace A buffer to store the stack trace.\n /// \\param size Size in bytes of the trace buffer.\n-/// \\param thread_id [out] The thread ID of the address.\n+/// \\param[out] thread_id The thread ID of the address.\n ///\n /// \\returns Returns the number of stored frames or 0 on error.\n size_t __asan_get_alloc_stack(void *addr, void **trace, size_t size,\n@@ -219,7 +219,7 @@ size_t __asan_get_alloc_stack(void *addr, void **trace, size_t size,\n /// \\param addr A heap address.\n /// \\param trace A buffer to store the stack trace.\n /// \\param size Size in bytes of the trace buffer.\n-/// \\param thread_id [out] The thread ID of the address.\n+/// \\param[out] thread_id The thread ID of the address.\n ///\n /// \\returns Returns the number of stored frames or 0 on error.\n size_t __asan_get_free_stack(void *addr, void **trace, size_t size,\n@@ -228,8 +228,8 @@ size_t __asan_get_free_stack(void *addr, void **trace, size_t size,\n /// Gets the current shadow memory mapping (useful for calling from the\n /// debugger).\n ///\n-/// \\param shadow_scale [out] Shadow scale value.\n-/// \\param shadow_offset [out] Offset value.\n+/// \\param[out] shadow_scale Shadow scale value.\n+/// \\param[out] shadow_offset Offset value.\n void __asan_get_shadow_mapping(size_t *shadow_scale, size_t *shadow_offset);\n \n /// This is an internal function that is called to report an error. However,\n@@ -302,8 +302,8 @@ void *__asan_get_current_fake_stack(void);\n ///\n /// \\param fake_stack An opaque handler to a fake stack.\n /// \\param addr Address to test.\n-/// \\param beg [out] Beginning of fake frame.\n-/// \\param end [out] End of fake frame.\n+/// \\param[out] beg Beginning of fake frame.\n+/// \\param[out] end End of fake frame.\n /// \\returns Stack address or NULL.\n void *__asan_addr_is_in_fake_stack(void *fake_stack, void *addr, void **beg,\n                                    void **end);"}, {"sha": "b4f977bf5579c1b31e117142e251b5d97bbd41cf", "filename": "libsanitizer/include/sanitizer/common_interface_defs.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -320,7 +320,7 @@ void __sanitizer_print_memory_profile(size_t top_percent,\n /// signal callback runs during the switch, it will not benefit from stack\n /// use-after-return detection.\n ///\n-/// \\param fake_stack_save [out] Fake stack save location.\n+/// \\param[out] fake_stack_save Fake stack save location.\n /// \\param bottom Bottom address of stack.\n /// \\param size Size of stack in bytes.\n void __sanitizer_start_switch_fiber(void **fake_stack_save,\n@@ -335,8 +335,8 @@ void __sanitizer_start_switch_fiber(void **fake_stack_save,\n /// <c>__sanitizer_start_switch_fiber()</c>.\n ///\n /// \\param fake_stack_save Fake stack save location.\n-/// \\param bottom_old [out] Bottom address of old stack.\n-/// \\param size_old [out] Size of old stack in bytes.\n+/// \\param[out] bottom_old Bottom address of old stack.\n+/// \\param[out] size_old Size of old stack in bytes.\n void __sanitizer_finish_switch_fiber(void *fake_stack_save,\n                                      const void **bottom_old,\n                                      size_t *size_old);"}, {"sha": "18b2c81a6023c9af1212b37913232f57d45f2519", "filename": "libsanitizer/include/sanitizer/dfsan_interface.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Finclude%2Fsanitizer%2Fdfsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Finclude%2Fsanitizer%2Fdfsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fdfsan_interface.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -80,9 +80,11 @@ dfsan_label dfsan_has_label_with_desc(dfsan_label label, const char *desc);\n size_t dfsan_get_label_count(void);\n \n /// Flushes the DFSan shadow, i.e. forgets about all labels currently associated\n-/// with the application memory. Will work only if there are no other\n-/// threads executing DFSan-instrumented code concurrently.\n-/// Use this call to start over the taint tracking within the same procces.\n+/// with the application memory.  Use this call to start over the taint tracking\n+/// within the same process.\n+///\n+/// Note: If another thread is working with tainted data during the flush, that\n+/// taint could still be written to shadow after the flush.\n void dfsan_flush(void);\n \n /// Sets a callback to be invoked on calls to write().  The callback is invoked"}, {"sha": "eeb39fbed8b49acdd746abcee48e5ce1aec34063", "filename": "libsanitizer/include/sanitizer/msan_interface.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Finclude%2Fsanitizer%2Fmsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Finclude%2Fsanitizer%2Fmsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fmsan_interface.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -114,6 +114,9 @@ extern \"C\" {\n      call to __msan_scoped_disable_interceptor_checks. */\n   void __msan_scoped_enable_interceptor_checks(void);\n \n+  void __msan_start_switch_fiber(const void *bottom, size_t size);\n+  void __msan_finish_switch_fiber(const void **bottom_old, size_t *size_old);\n+\n #ifdef __cplusplus\n }  // extern \"C\"\n #endif"}, {"sha": "f661152ccbac7b7897210129855240e22e2fade7", "filename": "libsanitizer/include/sanitizer/netbsd_syscall_hooks.h", "status": "modified", "additions": 203, "deletions": 10, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Finclude%2Fsanitizer%2Fnetbsd_syscall_hooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Finclude%2Fsanitizer%2Fnetbsd_syscall_hooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fnetbsd_syscall_hooks.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -20,8 +20,8 @@\n // DO NOT EDIT! THIS FILE HAS BEEN GENERATED!\n //\n // Generated with: generate_netbsd_syscalls.awk\n-// Generated date: 2019-12-24\n-// Generated from: syscalls.master,v 1.296 2019/09/22 22:59:39 christos Exp\n+// Generated date: 2020-09-10\n+// Generated from: syscalls.master,v 1.306 2020/08/14 00:53:16 riastradh Exp\n //\n //===----------------------------------------------------------------------===//\n #ifndef SANITIZER_NETBSD_SYSCALL_HOOKS_H\n@@ -474,7 +474,12 @@\n   __sanitizer_syscall_pre_impl_dup2((long long)(from), (long long)(to))\n #define __sanitizer_syscall_post_dup2(res, from, to)                           \\\n   __sanitizer_syscall_post_impl_dup2(res, (long long)(from), (long long)(to))\n-/* syscall 91 has been skipped */\n+#define __sanitizer_syscall_pre_getrandom(buf, buflen, flags)                  \\\n+  __sanitizer_syscall_pre_impl_getrandom(                                      \\\n+      (long long)(buf), (long long)(buflen), (long long)(flags))\n+#define __sanitizer_syscall_post_getrandom(res, buf, buflen, flags)            \\\n+  __sanitizer_syscall_post_impl_getrandom(                                     \\\n+      res, (long long)(buf), (long long)(buflen), (long long)(flags))\n #define __sanitizer_syscall_pre_fcntl(fd, cmd, arg)                            \\\n   __sanitizer_syscall_pre_impl_fcntl((long long)(fd), (long long)(cmd),        \\\n                                      (long long)(arg))\n@@ -849,9 +854,31 @@\n #define __sanitizer_syscall_post_sysarch(res, op, parms)                       \\\n   __sanitizer_syscall_post_impl_sysarch(res, (long long)(op),                  \\\n                                         (long long)(parms))\n-/* syscall 166 has been skipped */\n-/* syscall 167 has been skipped */\n-/* syscall 168 has been skipped */\n+#define __sanitizer_syscall_pre___futex(uaddr, op, val, timeout, uaddr2, val2, \\\n+                                        val3)                                  \\\n+  __sanitizer_syscall_pre_impl___futex((long long)(uaddr), (long long)(op),    \\\n+                                       (long long)(val), (long long)(timeout), \\\n+                                       (long long)(uaddr2), (long long)(val2), \\\n+                                       (long long)(val3))\n+#define __sanitizer_syscall_post___futex(res, uaddr, op, val, timeout, uaddr2, \\\n+                                         val2, val3)                           \\\n+  __sanitizer_syscall_post_impl___futex(                                       \\\n+      res, (long long)(uaddr), (long long)(op), (long long)(val),              \\\n+      (long long)(timeout), (long long)(uaddr2), (long long)(val2),            \\\n+      (long long)(val3))\n+#define __sanitizer_syscall_pre___futex_set_robust_list(head, len)             \\\n+  __sanitizer_syscall_pre_impl___futex_set_robust_list((long long)(head),      \\\n+                                                       (long long)(len))\n+#define __sanitizer_syscall_post___futex_set_robust_list(res, head, len)       \\\n+  __sanitizer_syscall_post_impl___futex_set_robust_list(                       \\\n+      res, (long long)(head), (long long)(len))\n+#define __sanitizer_syscall_pre___futex_get_robust_list(lwpid, headp, lenp)    \\\n+  __sanitizer_syscall_pre_impl___futex_get_robust_list(                        \\\n+      (long long)(lwpid), (long long)(headp), (long long)(lenp))\n+#define __sanitizer_syscall_post___futex_get_robust_list(res, lwpid, headp,    \\\n+                                                         lenp)                 \\\n+  __sanitizer_syscall_post_impl___futex_get_robust_list(                       \\\n+      res, (long long)(lwpid), (long long)(headp), (long long)(lenp))\n #if !defined(_LP64)\n #define __sanitizer_syscall_pre_compat_10_osemsys(which, a2, a3, a4, a5)       \\\n   __sanitizer_syscall_pre_impl_compat_10_osemsys(                              \\\n@@ -2731,6 +2758,83 @@\n   __sanitizer_syscall_post_impl___fhstatvfs190(                                \\\n       res, (long long)(fhp), (long long)(fh_size), (long long)(buf),           \\\n       (long long)(flags))\n+#define __sanitizer_syscall_pre___acl_get_link(path, type, aclp)               \\\n+  __sanitizer_syscall_pre_impl___acl_get_link(                                 \\\n+      (long long)(path), (long long)(type), (long long)(aclp))\n+#define __sanitizer_syscall_post___acl_get_link(res, path, type, aclp)         \\\n+  __sanitizer_syscall_post_impl___acl_get_link(                                \\\n+      res, (long long)(path), (long long)(type), (long long)(aclp))\n+#define __sanitizer_syscall_pre___acl_set_link(path, type, aclp)               \\\n+  __sanitizer_syscall_pre_impl___acl_set_link(                                 \\\n+      (long long)(path), (long long)(type), (long long)(aclp))\n+#define __sanitizer_syscall_post___acl_set_link(res, path, type, aclp)         \\\n+  __sanitizer_syscall_post_impl___acl_set_link(                                \\\n+      res, (long long)(path), (long long)(type), (long long)(aclp))\n+#define __sanitizer_syscall_pre___acl_delete_link(path, type)                  \\\n+  __sanitizer_syscall_pre_impl___acl_delete_link((long long)(path),            \\\n+                                                 (long long)(type))\n+#define __sanitizer_syscall_post___acl_delete_link(res, path, type)            \\\n+  __sanitizer_syscall_post_impl___acl_delete_link(res, (long long)(path),      \\\n+                                                  (long long)(type))\n+#define __sanitizer_syscall_pre___acl_aclcheck_link(path, type, aclp)          \\\n+  __sanitizer_syscall_pre_impl___acl_aclcheck_link(                            \\\n+      (long long)(path), (long long)(type), (long long)(aclp))\n+#define __sanitizer_syscall_post___acl_aclcheck_link(res, path, type, aclp)    \\\n+  __sanitizer_syscall_post_impl___acl_aclcheck_link(                           \\\n+      res, (long long)(path), (long long)(type), (long long)(aclp))\n+#define __sanitizer_syscall_pre___acl_get_file(path, type, aclp)               \\\n+  __sanitizer_syscall_pre_impl___acl_get_file(                                 \\\n+      (long long)(path), (long long)(type), (long long)(aclp))\n+#define __sanitizer_syscall_post___acl_get_file(res, path, type, aclp)         \\\n+  __sanitizer_syscall_post_impl___acl_get_file(                                \\\n+      res, (long long)(path), (long long)(type), (long long)(aclp))\n+#define __sanitizer_syscall_pre___acl_set_file(path, type, aclp)               \\\n+  __sanitizer_syscall_pre_impl___acl_set_file(                                 \\\n+      (long long)(path), (long long)(type), (long long)(aclp))\n+#define __sanitizer_syscall_post___acl_set_file(res, path, type, aclp)         \\\n+  __sanitizer_syscall_post_impl___acl_set_file(                                \\\n+      res, (long long)(path), (long long)(type), (long long)(aclp))\n+#define __sanitizer_syscall_pre___acl_get_fd(filedes, type, aclp)              \\\n+  __sanitizer_syscall_pre_impl___acl_get_fd(                                   \\\n+      (long long)(filedes), (long long)(type), (long long)(aclp))\n+#define __sanitizer_syscall_post___acl_get_fd(res, filedes, type, aclp)        \\\n+  __sanitizer_syscall_post_impl___acl_get_fd(                                  \\\n+      res, (long long)(filedes), (long long)(type), (long long)(aclp))\n+#define __sanitizer_syscall_pre___acl_set_fd(filedes, type, aclp)              \\\n+  __sanitizer_syscall_pre_impl___acl_set_fd(                                   \\\n+      (long long)(filedes), (long long)(type), (long long)(aclp))\n+#define __sanitizer_syscall_post___acl_set_fd(res, filedes, type, aclp)        \\\n+  __sanitizer_syscall_post_impl___acl_set_fd(                                  \\\n+      res, (long long)(filedes), (long long)(type), (long long)(aclp))\n+#define __sanitizer_syscall_pre___acl_delete_file(path, type)                  \\\n+  __sanitizer_syscall_pre_impl___acl_delete_file((long long)(path),            \\\n+                                                 (long long)(type))\n+#define __sanitizer_syscall_post___acl_delete_file(res, path, type)            \\\n+  __sanitizer_syscall_post_impl___acl_delete_file(res, (long long)(path),      \\\n+                                                  (long long)(type))\n+#define __sanitizer_syscall_pre___acl_delete_fd(filedes, type)                 \\\n+  __sanitizer_syscall_pre_impl___acl_delete_fd((long long)(filedes),           \\\n+                                               (long long)(type))\n+#define __sanitizer_syscall_post___acl_delete_fd(res, filedes, type)           \\\n+  __sanitizer_syscall_post_impl___acl_delete_fd(res, (long long)(filedes),     \\\n+                                                (long long)(type))\n+#define __sanitizer_syscall_pre___acl_aclcheck_file(path, type, aclp)          \\\n+  __sanitizer_syscall_pre_impl___acl_aclcheck_file(                            \\\n+      (long long)(path), (long long)(type), (long long)(aclp))\n+#define __sanitizer_syscall_post___acl_aclcheck_file(res, path, type, aclp)    \\\n+  __sanitizer_syscall_post_impl___acl_aclcheck_file(                           \\\n+      res, (long long)(path), (long long)(type), (long long)(aclp))\n+#define __sanitizer_syscall_pre___acl_aclcheck_fd(filedes, type, aclp)         \\\n+  __sanitizer_syscall_pre_impl___acl_aclcheck_fd(                              \\\n+      (long long)(filedes), (long long)(type), (long long)(aclp))\n+#define __sanitizer_syscall_post___acl_aclcheck_fd(res, filedes, type, aclp)   \\\n+  __sanitizer_syscall_post_impl___acl_aclcheck_fd(                             \\\n+      res, (long long)(filedes), (long long)(type), (long long)(aclp))\n+#define __sanitizer_syscall_pre_lpathconf(path, name)                          \\\n+  __sanitizer_syscall_pre_impl_lpathconf((long long)(path), (long long)(name))\n+#define __sanitizer_syscall_post_lpathconf(res, path, name)                    \\\n+  __sanitizer_syscall_post_impl_lpathconf(res, (long long)(path),              \\\n+                                          (long long)(name))\n \n /* Compat with older releases */\n #define __sanitizer_syscall_pre_getvfsstat                                     \\\n@@ -3088,7 +3192,10 @@ void __sanitizer_syscall_post_impl_compat_43_ogetdtablesize(long long res);\n void __sanitizer_syscall_pre_impl_dup2(long long from, long long to);\n void __sanitizer_syscall_post_impl_dup2(long long res, long long from,\n                                         long long to);\n-/* syscall 91 has been skipped */\n+void __sanitizer_syscall_pre_impl_getrandom(long long buf, long long buflen,\n+                                            long long flags);\n+void __sanitizer_syscall_post_impl_getrandom(long long res, long long buf,\n+                                             long long buflen, long long flags);\n void __sanitizer_syscall_pre_impl_fcntl(long long fd, long long cmd,\n                                         long long arg);\n void __sanitizer_syscall_post_impl_fcntl(long long res, long long fd,\n@@ -3380,9 +3487,26 @@ void __sanitizer_syscall_post_impl_compat_09_ouname(long long res,\n void __sanitizer_syscall_pre_impl_sysarch(long long op, long long parms);\n void __sanitizer_syscall_post_impl_sysarch(long long res, long long op,\n                                            long long parms);\n-/* syscall 166 has been skipped */\n-/* syscall 167 has been skipped */\n-/* syscall 168 has been skipped */\n+void __sanitizer_syscall_pre_impl___futex(long long uaddr, long long op,\n+                                          long long val, long long timeout,\n+                                          long long uaddr2, long long val2,\n+                                          long long val3);\n+void __sanitizer_syscall_post_impl___futex(long long res, long long uaddr,\n+                                           long long op, long long val,\n+                                           long long timeout, long long uaddr2,\n+                                           long long val2, long long val3);\n+void __sanitizer_syscall_pre_impl___futex_set_robust_list(long long head,\n+                                                          long long len);\n+void __sanitizer_syscall_post_impl___futex_set_robust_list(long long res,\n+                                                           long long head,\n+                                                           long long len);\n+void __sanitizer_syscall_pre_impl___futex_get_robust_list(long long lwpid,\n+                                                          long long headp,\n+                                                          long long lenp);\n+void __sanitizer_syscall_post_impl___futex_get_robust_list(long long res,\n+                                                           long long lwpid,\n+                                                           long long headp,\n+                                                           long long lenp);\n #if !defined(_LP64)\n void __sanitizer_syscall_pre_impl_compat_10_osemsys(long long which,\n                                                     long long a2, long long a3,\n@@ -4802,6 +4926,75 @@ void __sanitizer_syscall_post_impl___fhstatvfs190(long long res, long long fhp,\n                                                   long long fh_size,\n                                                   long long buf,\n                                                   long long flags);\n+void __sanitizer_syscall_pre_impl___acl_get_link(long long path, long long type,\n+                                                 long long aclp);\n+void __sanitizer_syscall_post_impl___acl_get_link(long long res, long long path,\n+                                                  long long type,\n+                                                  long long aclp);\n+void __sanitizer_syscall_pre_impl___acl_set_link(long long path, long long type,\n+                                                 long long aclp);\n+void __sanitizer_syscall_post_impl___acl_set_link(long long res, long long path,\n+                                                  long long type,\n+                                                  long long aclp);\n+void __sanitizer_syscall_pre_impl___acl_delete_link(long long path,\n+                                                    long long type);\n+void __sanitizer_syscall_post_impl___acl_delete_link(long long res,\n+                                                     long long path,\n+                                                     long long type);\n+void __sanitizer_syscall_pre_impl___acl_aclcheck_link(long long path,\n+                                                      long long type,\n+                                                      long long aclp);\n+void __sanitizer_syscall_post_impl___acl_aclcheck_link(long long res,\n+                                                       long long path,\n+                                                       long long type,\n+                                                       long long aclp);\n+void __sanitizer_syscall_pre_impl___acl_get_file(long long path, long long type,\n+                                                 long long aclp);\n+void __sanitizer_syscall_post_impl___acl_get_file(long long res, long long path,\n+                                                  long long type,\n+                                                  long long aclp);\n+void __sanitizer_syscall_pre_impl___acl_set_file(long long path, long long type,\n+                                                 long long aclp);\n+void __sanitizer_syscall_post_impl___acl_set_file(long long res, long long path,\n+                                                  long long type,\n+                                                  long long aclp);\n+void __sanitizer_syscall_pre_impl___acl_get_fd(long long filedes,\n+                                               long long type, long long aclp);\n+void __sanitizer_syscall_post_impl___acl_get_fd(long long res,\n+                                                long long filedes,\n+                                                long long type, long long aclp);\n+void __sanitizer_syscall_pre_impl___acl_set_fd(long long filedes,\n+                                               long long type, long long aclp);\n+void __sanitizer_syscall_post_impl___acl_set_fd(long long res,\n+                                                long long filedes,\n+                                                long long type, long long aclp);\n+void __sanitizer_syscall_pre_impl___acl_delete_file(long long path,\n+                                                    long long type);\n+void __sanitizer_syscall_post_impl___acl_delete_file(long long res,\n+                                                     long long path,\n+                                                     long long type);\n+void __sanitizer_syscall_pre_impl___acl_delete_fd(long long filedes,\n+                                                  long long type);\n+void __sanitizer_syscall_post_impl___acl_delete_fd(long long res,\n+                                                   long long filedes,\n+                                                   long long type);\n+void __sanitizer_syscall_pre_impl___acl_aclcheck_file(long long path,\n+                                                      long long type,\n+                                                      long long aclp);\n+void __sanitizer_syscall_post_impl___acl_aclcheck_file(long long res,\n+                                                       long long path,\n+                                                       long long type,\n+                                                       long long aclp);\n+void __sanitizer_syscall_pre_impl___acl_aclcheck_fd(long long filedes,\n+                                                    long long type,\n+                                                    long long aclp);\n+void __sanitizer_syscall_post_impl___acl_aclcheck_fd(long long res,\n+                                                     long long filedes,\n+                                                     long long type,\n+                                                     long long aclp);\n+void __sanitizer_syscall_pre_impl_lpathconf(long long path, long long name);\n+void __sanitizer_syscall_post_impl_lpathconf(long long res, long long path,\n+                                             long long name);\n \n #ifdef __cplusplus\n } // extern \"C\""}, {"sha": "c8cc045783d4518a63884a22cbbdb83e308dd809", "filename": "libsanitizer/lsan/lsan.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Flsan%2Flsan.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Flsan%2Flsan.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -73,7 +73,7 @@ static void InitializeFlags() {\n   RegisterCommonFlags(&parser);\n \n   // Override from user-specified string.\n-  const char *lsan_default_options = MaybeCallLsanDefaultOptions();\n+  const char *lsan_default_options = __lsan_default_options();\n   parser.ParseString(lsan_default_options);\n   parser.ParseStringFromEnv(\"LSAN_OPTIONS\");\n "}, {"sha": "17e13cd014ba4351838967a93027db4e0901fd3b", "filename": "libsanitizer/lsan/lsan_allocator.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Flsan%2Flsan_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Flsan%2Flsan_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_allocator.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -65,13 +65,16 @@ struct AP32 {\n template <typename AddressSpaceView>\n using PrimaryAllocatorASVT = SizeClassAllocator32<AP32<AddressSpaceView>>;\n using PrimaryAllocator = PrimaryAllocatorASVT<LocalAddressSpaceView>;\n-#elif defined(__x86_64__) || defined(__powerpc64__)\n+#elif defined(__x86_64__) || defined(__powerpc64__) || defined(__s390x__)\n # if SANITIZER_FUCHSIA\n const uptr kAllocatorSpace = ~(uptr)0;\n const uptr kAllocatorSize  =  0x40000000000ULL;  // 4T.\n # elif defined(__powerpc64__)\n const uptr kAllocatorSpace = 0xa0000000000ULL;\n const uptr kAllocatorSize  = 0x20000000000ULL;  // 2T.\n+#elif defined(__s390x__)\n+const uptr kAllocatorSpace = 0x40000000000ULL;\n+const uptr kAllocatorSize = 0x40000000000ULL;  // 4T.\n # else\n const uptr kAllocatorSpace = 0x600000000000ULL;\n const uptr kAllocatorSize  = 0x40000000000ULL;  // 4T."}, {"sha": "107d63ac9117c60b7852bb4de8dc59152915b1fa", "filename": "libsanitizer/lsan/lsan_common.cpp", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Flsan%2Flsan_common.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Flsan%2Flsan_common.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -34,6 +34,7 @@ BlockingMutex global_mutex(LINKER_INITIALIZED);\n \n Flags lsan_flags;\n \n+\n void DisableCounterUnderflow() {\n   if (common_flags()->detect_leaks) {\n     Report(\"Unmatched call to __lsan_enable().\\n\");\n@@ -107,10 +108,6 @@ void InitializeRootRegions() {\n   root_regions = new (placeholder) InternalMmapVector<RootRegion>();\n }\n \n-const char *MaybeCallLsanDefaultOptions() {\n-  return (&__lsan_default_options) ? __lsan_default_options() : \"\";\n-}\n-\n void InitCommonLsan() {\n   InitializeRootRegions();\n   if (common_flags()->detect_leaks) {\n@@ -221,10 +218,7 @@ static void ProcessThreads(SuspendedThreadsList const &, Frontier *) {}\n // Scans thread data (stacks and TLS) for heap pointers.\n static void ProcessThreads(SuspendedThreadsList const &suspended_threads,\n                            Frontier *frontier) {\n-  InternalMmapVector<uptr> registers(suspended_threads.RegisterCount());\n-  uptr registers_begin = reinterpret_cast<uptr>(registers.data());\n-  uptr registers_end =\n-      reinterpret_cast<uptr>(registers.data() + registers.size());\n+  InternalMmapVector<uptr> registers;\n   for (uptr i = 0; i < suspended_threads.ThreadCount(); i++) {\n     tid_t os_id = static_cast<tid_t>(suspended_threads.GetThreadID(i));\n     LOG_THREADS(\"Processing thread %d.\\n\", os_id);\n@@ -241,7 +235,7 @@ static void ProcessThreads(SuspendedThreadsList const &suspended_threads,\n     }\n     uptr sp;\n     PtraceRegistersStatus have_registers =\n-        suspended_threads.GetRegistersAndSP(i, registers.data(), &sp);\n+        suspended_threads.GetRegistersAndSP(i, &registers, &sp);\n     if (have_registers != REGISTERS_AVAILABLE) {\n       Report(\"Unable to get registers from thread %d.\\n\", os_id);\n       // If unable to get SP, consider the entire stack to be reachable unless\n@@ -250,9 +244,13 @@ static void ProcessThreads(SuspendedThreadsList const &suspended_threads,\n       sp = stack_begin;\n     }\n \n-    if (flags()->use_registers && have_registers)\n+    if (flags()->use_registers && have_registers) {\n+      uptr registers_begin = reinterpret_cast<uptr>(registers.data());\n+      uptr registers_end =\n+          reinterpret_cast<uptr>(registers.data() + registers.size());\n       ScanRangeForPointers(registers_begin, registers_end, frontier,\n                            \"REGISTERS\", kReachable);\n+    }\n \n     if (flags()->use_stacks) {\n       LOG_THREADS(\"Stack at %p-%p (SP = %p).\\n\", stack_begin, stack_end, sp);\n@@ -892,12 +890,11 @@ int __lsan_do_recoverable_leak_check() {\n   return 0;\n }\n \n-#if !SANITIZER_SUPPORTS_WEAK_HOOKS\n-SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-const char * __lsan_default_options() {\n+SANITIZER_INTERFACE_WEAK_DEF(const char *, __lsan_default_options, void) {\n   return \"\";\n }\n \n+#if !SANITIZER_SUPPORTS_WEAK_HOOKS\n SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n int __lsan_is_turned_off() {\n   return 0;"}, {"sha": "3434beede82890fd4cac5e76c31ebda1d46236a0", "filename": "libsanitizer/lsan/lsan_common.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Flsan%2Flsan_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Flsan%2Flsan_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -29,10 +29,10 @@\n // To enable LeakSanitizer on a new architecture, one needs to implement the\n // internal_clone function as well as (probably) adjust the TLS machinery for\n // the new architecture inside the sanitizer library.\n-#if (SANITIZER_LINUX && !SANITIZER_ANDROID || SANITIZER_MAC) && \\\n-    (SANITIZER_WORDSIZE == 64) &&                               \\\n+#if (SANITIZER_LINUX && !SANITIZER_ANDROID || SANITIZER_MAC) &&          \\\n+    (SANITIZER_WORDSIZE == 64) &&                                        \\\n     (defined(__x86_64__) || defined(__mips64) || defined(__aarch64__) || \\\n-     defined(__powerpc64__))\n+     defined(__powerpc64__) || defined(__s390x__))\n #define CAN_SANITIZE_LEAKS 1\n #elif defined(__i386__) && \\\n     (SANITIZER_LINUX && !SANITIZER_ANDROID || SANITIZER_MAC)"}, {"sha": "39d075ddec09c9b95c76d5f2cf6f2c33f3ad87f6", "filename": "libsanitizer/lsan/lsan_interceptors.cpp", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Flsan%2Flsan_interceptors.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Flsan%2Flsan_interceptors.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_interceptors.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -476,6 +476,15 @@ INTERCEPTOR(int, pthread_join, void *th, void **ret) {\n   return res;\n }\n \n+INTERCEPTOR(int, pthread_detach, void *th) {\n+  ENSURE_LSAN_INITED;\n+  int tid = ThreadTid((uptr)th);\n+  int res = REAL(pthread_detach)(th);\n+  if (res == 0)\n+    ThreadDetach(tid);\n+  return res;\n+}\n+\n INTERCEPTOR(void, _exit, int status) {\n   if (status == 0 && HasReportedLeaks()) status = common_flags()->exitcode;\n   REAL(_exit)(status);\n@@ -508,6 +517,7 @@ void InitializeInterceptors() {\n   LSAN_MAYBE_INTERCEPT_MALLINFO;\n   LSAN_MAYBE_INTERCEPT_MALLOPT;\n   INTERCEPT_FUNCTION(pthread_create);\n+  INTERCEPT_FUNCTION(pthread_detach);\n   INTERCEPT_FUNCTION(pthread_join);\n   INTERCEPT_FUNCTION(_exit);\n "}, {"sha": "371a1f29dfe0b02bdc313204dbe2bacbb4b9ccfc", "filename": "libsanitizer/lsan/lsan_thread.cpp", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Flsan%2Flsan_thread.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Flsan%2Flsan_thread.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_thread.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -83,6 +83,11 @@ u32 ThreadTid(uptr uid) {\n   return thread_registry->FindThread(FindThreadByUid, (void *)uid);\n }\n \n+void ThreadDetach(u32 tid) {\n+  CHECK_NE(tid, kInvalidTid);\n+  thread_registry->DetachThread(tid, /* arg */ nullptr);\n+}\n+\n void ThreadJoin(u32 tid) {\n   CHECK_NE(tid, kInvalidTid);\n   thread_registry->JoinThread(tid, /* arg */ nullptr);"}, {"sha": "e876f9ff9cff41da96e1ebcf78f0778de481b9f2", "filename": "libsanitizer/lsan/lsan_thread.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Flsan%2Flsan_thread.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Flsan%2Flsan_thread.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_thread.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -46,6 +46,7 @@ void InitializeMainThread();\n \n u32 ThreadCreate(u32 tid, uptr uid, bool detached, void *arg = nullptr);\n void ThreadFinish();\n+void ThreadDetach(u32 tid);\n void ThreadJoin(u32 tid);\n u32 ThreadTid(uptr uid);\n "}, {"sha": "3157b35ffaf803595b6ec493e233ffdec6a4774d", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator.cpp", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -137,8 +137,14 @@ static void RawInternalFree(void *ptr, InternalAllocatorCache *cache) {\n \n #endif  // SANITIZER_GO || defined(SANITIZER_USE_MALLOC)\n \n+namespace {\n const u64 kBlockMagic = 0x6A6CB03ABCEBC041ull;\n \n+struct BlockHeader {\n+  u64 magic;\n+};\n+}  // namespace\n+\n static void NORETURN ReportInternalAllocatorOutOfMemory(uptr requested_size) {\n   SetAllocatorOutOfMemory();\n   Report(\"FATAL: %s: internal allocator is out of memory trying to allocate \"\n@@ -147,27 +153,28 @@ static void NORETURN ReportInternalAllocatorOutOfMemory(uptr requested_size) {\n }\n \n void *InternalAlloc(uptr size, InternalAllocatorCache *cache, uptr alignment) {\n-  if (size + sizeof(u64) < size)\n+  uptr s = size + sizeof(BlockHeader);\n+  if (s < size)\n     return nullptr;\n-  void *p = RawInternalAlloc(size + sizeof(u64), cache, alignment);\n+  BlockHeader *p = (BlockHeader *)RawInternalAlloc(s, cache, alignment);\n   if (UNLIKELY(!p))\n-    ReportInternalAllocatorOutOfMemory(size + sizeof(u64));\n-  ((u64*)p)[0] = kBlockMagic;\n-  return (char*)p + sizeof(u64);\n+    ReportInternalAllocatorOutOfMemory(s);\n+  p->magic = kBlockMagic;\n+  return p + 1;\n }\n \n void *InternalRealloc(void *addr, uptr size, InternalAllocatorCache *cache) {\n   if (!addr)\n     return InternalAlloc(size, cache);\n-  if (size + sizeof(u64) < size)\n+  uptr s = size + sizeof(BlockHeader);\n+  if (s < size)\n     return nullptr;\n-  addr = (char*)addr - sizeof(u64);\n-  size = size + sizeof(u64);\n-  CHECK_EQ(kBlockMagic, ((u64*)addr)[0]);\n-  void *p = RawInternalRealloc(addr, size, cache);\n+  BlockHeader *p = (BlockHeader *)addr - 1;\n+  CHECK_EQ(kBlockMagic, p->magic);\n+  p = (BlockHeader *)RawInternalRealloc(p, s, cache);\n   if (UNLIKELY(!p))\n-    ReportInternalAllocatorOutOfMemory(size);\n-  return (char*)p + sizeof(u64);\n+    ReportInternalAllocatorOutOfMemory(s);\n+  return p + 1;\n }\n \n void *InternalReallocArray(void *addr, uptr count, uptr size,\n@@ -198,10 +205,10 @@ void *InternalCalloc(uptr count, uptr size, InternalAllocatorCache *cache) {\n void InternalFree(void *addr, InternalAllocatorCache *cache) {\n   if (!addr)\n     return;\n-  addr = (char*)addr - sizeof(u64);\n-  CHECK_EQ(kBlockMagic, ((u64*)addr)[0]);\n-  ((u64*)addr)[0] = 0;\n-  RawInternalFree(addr, cache);\n+  BlockHeader *p = (BlockHeader *)addr - 1;\n+  CHECK_EQ(kBlockMagic, p->magic);\n+  p->magic = 0;\n+  RawInternalFree(p, cache);\n }\n \n // LowLevelAllocator"}, {"sha": "5ec47416fe0c98ae481d9496e77b0f4c2fbf6630", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -52,14 +52,14 @@ struct NoOpMapUnmapCallback {\n // Callback type for iterating over chunks.\n typedef void (*ForEachChunkCallback)(uptr chunk, void *arg);\n \n-INLINE u32 Rand(u32 *state) {  // ANSI C linear congruential PRNG.\n+inline u32 Rand(u32 *state) {  // ANSI C linear congruential PRNG.\n   return (*state = *state * 1103515245 + 12345) >> 16;\n }\n \n-INLINE u32 RandN(u32 *state, u32 n) { return Rand(state) % n; }  // [0, n)\n+inline u32 RandN(u32 *state, u32 n) { return Rand(state) % n; }  // [0, n)\n \n template<typename T>\n-INLINE void RandomShuffle(T *a, u32 n, u32 *rand_state) {\n+inline void RandomShuffle(T *a, u32 n, u32 *rand_state) {\n   if (n <= 1) return;\n   u32 state = *rand_state;\n   for (u32 i = n - 1; i > 0; i--)"}, {"sha": "1cc3992c4c9fae785cc0236a93926b0aeba34846", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_checks.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_checks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_checks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_checks.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -27,7 +27,7 @@ namespace __sanitizer {\n void SetErrnoToENOMEM();\n \n // A common errno setting logic shared by almost all sanitizer allocator APIs.\n-INLINE void *SetErrnoOnNull(void *ptr) {\n+inline void *SetErrnoOnNull(void *ptr) {\n   if (UNLIKELY(!ptr))\n     SetErrnoToENOMEM();\n   return ptr;\n@@ -41,7 +41,7 @@ INLINE void *SetErrnoOnNull(void *ptr) {\n // two and that the size is a multiple of alignment for POSIX implementation,\n // and a bit relaxed requirement for non-POSIX ones, that the size is a multiple\n // of alignment.\n-INLINE bool CheckAlignedAllocAlignmentAndSize(uptr alignment, uptr size) {\n+inline bool CheckAlignedAllocAlignmentAndSize(uptr alignment, uptr size) {\n #if SANITIZER_POSIX\n   return alignment != 0 && IsPowerOfTwo(alignment) &&\n          (size & (alignment - 1)) == 0;\n@@ -52,13 +52,13 @@ INLINE bool CheckAlignedAllocAlignmentAndSize(uptr alignment, uptr size) {\n \n // Checks posix_memalign() parameters, verifies that alignment is a power of two\n // and a multiple of sizeof(void *).\n-INLINE bool CheckPosixMemalignAlignment(uptr alignment) {\n+inline bool CheckPosixMemalignAlignment(uptr alignment) {\n   return alignment != 0 && IsPowerOfTwo(alignment) &&\n          (alignment % sizeof(void *)) == 0;\n }\n \n // Returns true if calloc(size, n) call overflows on size*n calculation.\n-INLINE bool CheckForCallocOverflow(uptr size, uptr n) {\n+inline bool CheckForCallocOverflow(uptr size, uptr n) {\n   if (!size)\n     return false;\n   uptr max = (uptr)-1L;\n@@ -67,7 +67,7 @@ INLINE bool CheckForCallocOverflow(uptr size, uptr n) {\n \n // Returns true if the size passed to pvalloc overflows when rounded to the next\n // multiple of page_size.\n-INLINE bool CheckForPvallocOverflow(uptr size, uptr page_size) {\n+inline bool CheckForPvallocOverflow(uptr size, uptr page_size) {\n   return RoundUpTo(size, page_size) < size;\n }\n "}, {"sha": "b90dabbf776929bc75a4f86ed56e935dd24c553c", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_primary32.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary32.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -153,6 +153,7 @@ class SizeClassAllocator32 {\n   }\n \n   void *GetMetaData(const void *p) {\n+    CHECK(kMetadataSize);\n     CHECK(PointerIsMine(p));\n     uptr mem = reinterpret_cast<uptr>(p);\n     uptr beg = ComputeRegionBeg(mem);"}, {"sha": "0a18b0c58ef7925ed97925db4aafaa8e6e73cc34", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_primary64.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary64.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -186,13 +186,13 @@ class SizeClassAllocator64 {\n \n   void *GetBlockBegin(const void *p) {\n     uptr class_id = GetSizeClass(p);\n+    if (class_id >= kNumClasses) return nullptr;\n     uptr size = ClassIdToSize(class_id);\n     if (!size) return nullptr;\n     uptr chunk_idx = GetChunkIdx((uptr)p, size);\n     uptr reg_beg = GetRegionBegin(p);\n     uptr beg = chunk_idx * size;\n     uptr next_beg = beg + size;\n-    if (class_id >= kNumClasses) return nullptr;\n     const RegionInfo *region = AddressSpaceView::Load(GetRegionInfo(class_id));\n     if (region->mapped_user >= next_beg)\n       return reinterpret_cast<void*>(reg_beg + beg);\n@@ -207,6 +207,7 @@ class SizeClassAllocator64 {\n   static uptr ClassID(uptr size) { return SizeClassMap::ClassID(size); }\n \n   void *GetMetaData(const void *p) {\n+    CHECK(kMetadataSize);\n     uptr class_id = GetSizeClass(p);\n     uptr size = ClassIdToSize(class_id);\n     uptr chunk_idx = GetChunkIdx(reinterpret_cast<uptr>(p), size);"}, {"sha": "61fb98742373a4ad03dae220a4747dcc1b7a5e37", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_secondary.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_secondary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_secondary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_secondary.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -18,8 +18,8 @@\n // (currently, 32 bits and internal allocator).\n class LargeMmapAllocatorPtrArrayStatic {\n  public:\n-  INLINE void *Init() { return &p_[0]; }\n-  INLINE void EnsureSpace(uptr n) { CHECK_LT(n, kMaxNumChunks); }\n+  inline void *Init() { return &p_[0]; }\n+  inline void EnsureSpace(uptr n) { CHECK_LT(n, kMaxNumChunks); }\n  private:\n   static const int kMaxNumChunks = 1 << 15;\n   uptr p_[kMaxNumChunks];\n@@ -31,14 +31,14 @@ class LargeMmapAllocatorPtrArrayStatic {\n // same functionality in Fuchsia case, which does not support MAP_NORESERVE.\n class LargeMmapAllocatorPtrArrayDynamic {\n  public:\n-  INLINE void *Init() {\n+  inline void *Init() {\n     uptr p = address_range_.Init(kMaxNumChunks * sizeof(uptr),\n                                  SecondaryAllocatorName);\n     CHECK(p);\n     return reinterpret_cast<void*>(p);\n   }\n \n-  INLINE void EnsureSpace(uptr n) {\n+  inline void EnsureSpace(uptr n) {\n     CHECK_LT(n, kMaxNumChunks);\n     DCHECK(n <= n_reserved_);\n     if (UNLIKELY(n == n_reserved_)) {"}, {"sha": "46f06957228c9b81c7aa3acbe7fa9bb16bcd3df6", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -72,12 +72,12 @@ namespace __sanitizer {\n // Clutter-reducing helpers.\n \n template<typename T>\n-INLINE typename T::Type atomic_load_relaxed(const volatile T *a) {\n+inline typename T::Type atomic_load_relaxed(const volatile T *a) {\n   return atomic_load(a, memory_order_relaxed);\n }\n \n template<typename T>\n-INLINE void atomic_store_relaxed(volatile T *a, typename T::Type v) {\n+inline void atomic_store_relaxed(volatile T *a, typename T::Type v) {\n   atomic_store(a, v, memory_order_relaxed);\n }\n "}, {"sha": "fc13ca52dda745dba5e40c30ad23ad189401b886", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic_clang.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -34,32 +34,32 @@ namespace __sanitizer {\n // See http://www.cl.cam.ac.uk/~pes20/cpp/cpp0xmappings.html\n // for mappings of the memory model to different processors.\n \n-INLINE void atomic_signal_fence(memory_order) {\n+inline void atomic_signal_fence(memory_order) {\n   __asm__ __volatile__(\"\" ::: \"memory\");\n }\n \n-INLINE void atomic_thread_fence(memory_order) {\n+inline void atomic_thread_fence(memory_order) {\n   __sync_synchronize();\n }\n \n template<typename T>\n-INLINE typename T::Type atomic_fetch_add(volatile T *a,\n+inline typename T::Type atomic_fetch_add(volatile T *a,\n     typename T::Type v, memory_order mo) {\n   (void)mo;\n   DCHECK(!((uptr)a % sizeof(*a)));\n   return __sync_fetch_and_add(&a->val_dont_use, v);\n }\n \n template<typename T>\n-INLINE typename T::Type atomic_fetch_sub(volatile T *a,\n+inline typename T::Type atomic_fetch_sub(volatile T *a,\n     typename T::Type v, memory_order mo) {\n   (void)mo;\n   DCHECK(!((uptr)a % sizeof(*a)));\n   return __sync_fetch_and_add(&a->val_dont_use, -v);\n }\n \n template<typename T>\n-INLINE typename T::Type atomic_exchange(volatile T *a,\n+inline typename T::Type atomic_exchange(volatile T *a,\n     typename T::Type v, memory_order mo) {\n   DCHECK(!((uptr)a % sizeof(*a)));\n   if (mo & (memory_order_release | memory_order_acq_rel | memory_order_seq_cst))\n@@ -71,7 +71,7 @@ INLINE typename T::Type atomic_exchange(volatile T *a,\n }\n \n template <typename T>\n-INLINE bool atomic_compare_exchange_strong(volatile T *a, typename T::Type *cmp,\n+inline bool atomic_compare_exchange_strong(volatile T *a, typename T::Type *cmp,\n                                            typename T::Type xchg,\n                                            memory_order mo) {\n   typedef typename T::Type Type;\n@@ -84,7 +84,7 @@ INLINE bool atomic_compare_exchange_strong(volatile T *a, typename T::Type *cmp,\n }\n \n template<typename T>\n-INLINE bool atomic_compare_exchange_weak(volatile T *a,\n+inline bool atomic_compare_exchange_weak(volatile T *a,\n                                          typename T::Type *cmp,\n                                          typename T::Type xchg,\n                                          memory_order mo) {"}, {"sha": "59155e9883ebe2f17f5a28030a73b19110a4c8d5", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic_clang_mips.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_mips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_mips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_mips.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -37,7 +37,7 @@ static struct {\n } __attribute__((aligned(32))) lock = {0, {0}};\n \n template <>\n-INLINE atomic_uint64_t::Type atomic_fetch_add(volatile atomic_uint64_t *ptr,\n+inline atomic_uint64_t::Type atomic_fetch_add(volatile atomic_uint64_t *ptr,\n                                               atomic_uint64_t::Type val,\n                                               memory_order mo) {\n   DCHECK(mo &\n@@ -55,14 +55,14 @@ INLINE atomic_uint64_t::Type atomic_fetch_add(volatile atomic_uint64_t *ptr,\n }\n \n template <>\n-INLINE atomic_uint64_t::Type atomic_fetch_sub(volatile atomic_uint64_t *ptr,\n+inline atomic_uint64_t::Type atomic_fetch_sub(volatile atomic_uint64_t *ptr,\n                                               atomic_uint64_t::Type val,\n                                               memory_order mo) {\n   return atomic_fetch_add(ptr, -val, mo);\n }\n \n template <>\n-INLINE bool atomic_compare_exchange_strong(volatile atomic_uint64_t *ptr,\n+inline bool atomic_compare_exchange_strong(volatile atomic_uint64_t *ptr,\n                                            atomic_uint64_t::Type *cmp,\n                                            atomic_uint64_t::Type xchg,\n                                            memory_order mo) {\n@@ -87,7 +87,7 @@ INLINE bool atomic_compare_exchange_strong(volatile atomic_uint64_t *ptr,\n }\n \n template <>\n-INLINE atomic_uint64_t::Type atomic_load(const volatile atomic_uint64_t *ptr,\n+inline atomic_uint64_t::Type atomic_load(const volatile atomic_uint64_t *ptr,\n                                          memory_order mo) {\n   DCHECK(mo &\n          (memory_order_relaxed | memory_order_releasae | memory_order_seq_cst));\n@@ -100,7 +100,7 @@ INLINE atomic_uint64_t::Type atomic_load(const volatile atomic_uint64_t *ptr,\n }\n \n template <>\n-INLINE void atomic_store(volatile atomic_uint64_t *ptr, atomic_uint64_t::Type v,\n+inline void atomic_store(volatile atomic_uint64_t *ptr, atomic_uint64_t::Type v,\n                          memory_order mo) {\n   DCHECK(mo &\n          (memory_order_relaxed | memory_order_releasae | memory_order_seq_cst));"}, {"sha": "7580ac2dc5889a882f5ff35744aca5b01904cf73", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic_clang_other.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_other.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_other.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_other.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -17,12 +17,12 @@\n namespace __sanitizer {\n \n \n-INLINE void proc_yield(int cnt) {\n+inline void proc_yield(int cnt) {\n   __asm__ __volatile__(\"\" ::: \"memory\");\n }\n \n template<typename T>\n-INLINE typename T::Type atomic_load(\n+inline typename T::Type atomic_load(\n     const volatile T *a, memory_order mo) {\n   DCHECK(mo & (memory_order_relaxed | memory_order_consume\n       | memory_order_acquire | memory_order_seq_cst));\n@@ -60,7 +60,7 @@ INLINE typename T::Type atomic_load(\n }\n \n template<typename T>\n-INLINE void atomic_store(volatile T *a, typename T::Type v, memory_order mo) {\n+inline void atomic_store(volatile T *a, typename T::Type v, memory_order mo) {\n   DCHECK(mo & (memory_order_relaxed | memory_order_release\n       | memory_order_seq_cst));\n   DCHECK(!((uptr)a % sizeof(*a)));"}, {"sha": "51597b49274128c497d3967efeacb2d71f299f29", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic_clang_x86.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_x86.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_x86.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_x86.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -16,15 +16,15 @@\n \n namespace __sanitizer {\n \n-INLINE void proc_yield(int cnt) {\n+inline void proc_yield(int cnt) {\n   __asm__ __volatile__(\"\" ::: \"memory\");\n   for (int i = 0; i < cnt; i++)\n     __asm__ __volatile__(\"pause\");\n   __asm__ __volatile__(\"\" ::: \"memory\");\n }\n \n template<typename T>\n-INLINE typename T::Type atomic_load(\n+inline typename T::Type atomic_load(\n     const volatile T *a, memory_order mo) {\n   DCHECK(mo & (memory_order_relaxed | memory_order_consume\n       | memory_order_acquire | memory_order_seq_cst));\n@@ -70,7 +70,7 @@ INLINE typename T::Type atomic_load(\n }\n \n template<typename T>\n-INLINE void atomic_store(volatile T *a, typename T::Type v, memory_order mo) {\n+inline void atomic_store(volatile T *a, typename T::Type v, memory_order mo) {\n   DCHECK(mo & (memory_order_relaxed | memory_order_release\n       | memory_order_seq_cst));\n   DCHECK(!((uptr)a % sizeof(*a)));"}, {"sha": "31317adcdfc99fd59708b4ac4db60deee4c65e9b", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic_msvc.h", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_msvc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_msvc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_msvc.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -54,21 +54,21 @@ extern \"C\" long long _InterlockedExchangeAdd64(long long volatile *Addend,\n \n namespace __sanitizer {\n \n-INLINE void atomic_signal_fence(memory_order) {\n+inline void atomic_signal_fence(memory_order) {\n   _ReadWriteBarrier();\n }\n \n-INLINE void atomic_thread_fence(memory_order) {\n+inline void atomic_thread_fence(memory_order) {\n   _mm_mfence();\n }\n \n-INLINE void proc_yield(int cnt) {\n+inline void proc_yield(int cnt) {\n   for (int i = 0; i < cnt; i++)\n     _mm_pause();\n }\n \n template<typename T>\n-INLINE typename T::Type atomic_load(\n+inline typename T::Type atomic_load(\n     const volatile T *a, memory_order mo) {\n   DCHECK(mo & (memory_order_relaxed | memory_order_consume\n       | memory_order_acquire | memory_order_seq_cst));\n@@ -86,7 +86,7 @@ INLINE typename T::Type atomic_load(\n }\n \n template<typename T>\n-INLINE void atomic_store(volatile T *a, typename T::Type v, memory_order mo) {\n+inline void atomic_store(volatile T *a, typename T::Type v, memory_order mo) {\n   DCHECK(mo & (memory_order_relaxed | memory_order_release\n       | memory_order_seq_cst));\n   DCHECK(!((uptr)a % sizeof(*a)));\n@@ -102,15 +102,15 @@ INLINE void atomic_store(volatile T *a, typename T::Type v, memory_order mo) {\n     atomic_thread_fence(memory_order_seq_cst);\n }\n \n-INLINE u32 atomic_fetch_add(volatile atomic_uint32_t *a,\n+inline u32 atomic_fetch_add(volatile atomic_uint32_t *a,\n     u32 v, memory_order mo) {\n   (void)mo;\n   DCHECK(!((uptr)a % sizeof(*a)));\n   return (u32)_InterlockedExchangeAdd((volatile long *)&a->val_dont_use,\n                                       (long)v);\n }\n \n-INLINE uptr atomic_fetch_add(volatile atomic_uintptr_t *a,\n+inline uptr atomic_fetch_add(volatile atomic_uintptr_t *a,\n     uptr v, memory_order mo) {\n   (void)mo;\n   DCHECK(!((uptr)a % sizeof(*a)));\n@@ -123,15 +123,15 @@ INLINE uptr atomic_fetch_add(volatile atomic_uintptr_t *a,\n #endif\n }\n \n-INLINE u32 atomic_fetch_sub(volatile atomic_uint32_t *a,\n+inline u32 atomic_fetch_sub(volatile atomic_uint32_t *a,\n     u32 v, memory_order mo) {\n   (void)mo;\n   DCHECK(!((uptr)a % sizeof(*a)));\n   return (u32)_InterlockedExchangeAdd((volatile long *)&a->val_dont_use,\n                                       -(long)v);\n }\n \n-INLINE uptr atomic_fetch_sub(volatile atomic_uintptr_t *a,\n+inline uptr atomic_fetch_sub(volatile atomic_uintptr_t *a,\n     uptr v, memory_order mo) {\n   (void)mo;\n   DCHECK(!((uptr)a % sizeof(*a)));\n@@ -144,28 +144,28 @@ INLINE uptr atomic_fetch_sub(volatile atomic_uintptr_t *a,\n #endif\n }\n \n-INLINE u8 atomic_exchange(volatile atomic_uint8_t *a,\n+inline u8 atomic_exchange(volatile atomic_uint8_t *a,\n     u8 v, memory_order mo) {\n   (void)mo;\n   DCHECK(!((uptr)a % sizeof(*a)));\n   return (u8)_InterlockedExchange8((volatile char*)&a->val_dont_use, v);\n }\n \n-INLINE u16 atomic_exchange(volatile atomic_uint16_t *a,\n+inline u16 atomic_exchange(volatile atomic_uint16_t *a,\n     u16 v, memory_order mo) {\n   (void)mo;\n   DCHECK(!((uptr)a % sizeof(*a)));\n   return (u16)_InterlockedExchange16((volatile short*)&a->val_dont_use, v);\n }\n \n-INLINE u32 atomic_exchange(volatile atomic_uint32_t *a,\n+inline u32 atomic_exchange(volatile atomic_uint32_t *a,\n     u32 v, memory_order mo) {\n   (void)mo;\n   DCHECK(!((uptr)a % sizeof(*a)));\n   return (u32)_InterlockedExchange((volatile long*)&a->val_dont_use, v);\n }\n \n-INLINE bool atomic_compare_exchange_strong(volatile atomic_uint8_t *a,\n+inline bool atomic_compare_exchange_strong(volatile atomic_uint8_t *a,\n                                            u8 *cmp,\n                                            u8 xchgv,\n                                            memory_order mo) {\n@@ -191,7 +191,7 @@ INLINE bool atomic_compare_exchange_strong(volatile atomic_uint8_t *a,\n   return false;\n }\n \n-INLINE bool atomic_compare_exchange_strong(volatile atomic_uintptr_t *a,\n+inline bool atomic_compare_exchange_strong(volatile atomic_uintptr_t *a,\n                                            uptr *cmp,\n                                            uptr xchg,\n                                            memory_order mo) {\n@@ -204,7 +204,7 @@ INLINE bool atomic_compare_exchange_strong(volatile atomic_uintptr_t *a,\n   return false;\n }\n \n-INLINE bool atomic_compare_exchange_strong(volatile atomic_uint16_t *a,\n+inline bool atomic_compare_exchange_strong(volatile atomic_uint16_t *a,\n                                            u16 *cmp,\n                                            u16 xchg,\n                                            memory_order mo) {\n@@ -217,7 +217,7 @@ INLINE bool atomic_compare_exchange_strong(volatile atomic_uint16_t *a,\n   return false;\n }\n \n-INLINE bool atomic_compare_exchange_strong(volatile atomic_uint32_t *a,\n+inline bool atomic_compare_exchange_strong(volatile atomic_uint32_t *a,\n                                            u32 *cmp,\n                                            u32 xchg,\n                                            memory_order mo) {\n@@ -230,7 +230,7 @@ INLINE bool atomic_compare_exchange_strong(volatile atomic_uint32_t *a,\n   return false;\n }\n \n-INLINE bool atomic_compare_exchange_strong(volatile atomic_uint64_t *a,\n+inline bool atomic_compare_exchange_strong(volatile atomic_uint64_t *a,\n                                            u64 *cmp,\n                                            u64 xchg,\n                                            memory_order mo) {\n@@ -244,7 +244,7 @@ INLINE bool atomic_compare_exchange_strong(volatile atomic_uint64_t *a,\n }\n \n template<typename T>\n-INLINE bool atomic_compare_exchange_weak(volatile T *a,\n+inline bool atomic_compare_exchange_weak(volatile T *a,\n                                          typename T::Type *cmp,\n                                          typename T::Type xchg,\n                                          memory_order mo) {"}, {"sha": "040db6fc2a16b707060d8cb6ec914e43688741be", "filename": "libsanitizer/sanitizer_common/sanitizer_common.h", "status": "modified", "additions": 71, "deletions": 29, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -53,25 +53,25 @@ const u64 kExternalPCBit = 1ULL << 60;\n extern const char *SanitizerToolName;  // Can be changed by the tool.\n \n extern atomic_uint32_t current_verbosity;\n-INLINE void SetVerbosity(int verbosity) {\n+inline void SetVerbosity(int verbosity) {\n   atomic_store(&current_verbosity, verbosity, memory_order_relaxed);\n }\n-INLINE int Verbosity() {\n+inline int Verbosity() {\n   return atomic_load(&current_verbosity, memory_order_relaxed);\n }\n \n #if SANITIZER_ANDROID\n-INLINE uptr GetPageSize() {\n+inline uptr GetPageSize() {\n // Android post-M sysconf(_SC_PAGESIZE) crashes if called from .preinit_array.\n   return 4096;\n }\n-INLINE uptr GetPageSizeCached() {\n+inline uptr GetPageSizeCached() {\n   return 4096;\n }\n #else\n uptr GetPageSize();\n extern uptr PageSizeCached;\n-INLINE uptr GetPageSizeCached() {\n+inline uptr GetPageSizeCached() {\n   if (!PageSizeCached)\n     PageSizeCached = GetPageSize();\n   return PageSizeCached;\n@@ -91,7 +91,7 @@ void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n \n // Memory management\n void *MmapOrDie(uptr size, const char *mem_type, bool raw_report = false);\n-INLINE void *MmapOrDieQuietly(uptr size, const char *mem_type) {\n+inline void *MmapOrDieQuietly(uptr size, const char *mem_type) {\n   return MmapOrDie(size, mem_type, /*raw_report*/ true);\n }\n void UnmapOrDie(void *addr, uptr size);\n@@ -121,6 +121,31 @@ bool MprotectReadOnly(uptr addr, uptr size);\n \n void MprotectMallocZones(void *addr, int prot);\n \n+#if SANITIZER_LINUX\n+// Unmap memory. Currently only used on Linux.\n+void UnmapFromTo(uptr from, uptr to);\n+#endif\n+\n+// Maps shadow_size_bytes of shadow memory and returns shadow address. It will\n+// be aligned to the mmap granularity * 2^shadow_scale, or to\n+// 2^min_shadow_base_alignment if that is larger. The returned address will\n+// have max(2^min_shadow_base_alignment, mmap granularity) on the left, and\n+// shadow_size_bytes bytes on the right, which on linux is mapped no access.\n+// The high_mem_end may be updated if the original shadow size doesn't fit.\n+uptr MapDynamicShadow(uptr shadow_size_bytes, uptr shadow_scale,\n+                      uptr min_shadow_base_alignment, uptr &high_mem_end);\n+\n+// Reserve memory range [beg, end]. If madvise_shadow is true then apply\n+// madvise (e.g. hugepages, core dumping) requested by options.\n+void ReserveShadowMemoryRange(uptr beg, uptr end, const char *name,\n+                              bool madvise_shadow = true);\n+\n+// Protect size bytes of memory starting at addr. Also try to protect\n+// several pages at the start of the address space as specified by\n+// zero_base_shadow_start, at most up to the size or zero_base_max_shadow_start.\n+void ProtectGap(uptr addr, uptr size, uptr zero_base_shadow_start,\n+                uptr zero_base_max_shadow_start);\n+\n // Find an available address space.\n uptr FindAvailableMemoryRange(uptr size, uptr alignment, uptr left_padding,\n                               uptr *largest_gap_found, uptr *max_occupied_addr);\n@@ -349,7 +374,7 @@ unsigned char _BitScanReverse64(unsigned long *index, unsigned __int64 mask);\n }\n #endif\n \n-INLINE uptr MostSignificantSetBitIndex(uptr x) {\n+inline uptr MostSignificantSetBitIndex(uptr x) {\n   CHECK_NE(x, 0U);\n   unsigned long up;\n #if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)\n@@ -366,7 +391,7 @@ INLINE uptr MostSignificantSetBitIndex(uptr x) {\n   return up;\n }\n \n-INLINE uptr LeastSignificantSetBitIndex(uptr x) {\n+inline uptr LeastSignificantSetBitIndex(uptr x) {\n   CHECK_NE(x, 0U);\n   unsigned long up;\n #if !SANITIZER_WINDOWS || defined(__clang__) || defined(__GNUC__)\n@@ -383,11 +408,11 @@ INLINE uptr LeastSignificantSetBitIndex(uptr x) {\n   return up;\n }\n \n-INLINE bool IsPowerOfTwo(uptr x) {\n+inline bool IsPowerOfTwo(uptr x) {\n   return (x & (x - 1)) == 0;\n }\n \n-INLINE uptr RoundUpToPowerOfTwo(uptr size) {\n+inline uptr RoundUpToPowerOfTwo(uptr size) {\n   CHECK(size);\n   if (IsPowerOfTwo(size)) return size;\n \n@@ -397,20 +422,20 @@ INLINE uptr RoundUpToPowerOfTwo(uptr size) {\n   return 1ULL << (up + 1);\n }\n \n-INLINE uptr RoundUpTo(uptr size, uptr boundary) {\n+inline uptr RoundUpTo(uptr size, uptr boundary) {\n   RAW_CHECK(IsPowerOfTwo(boundary));\n   return (size + boundary - 1) & ~(boundary - 1);\n }\n \n-INLINE uptr RoundDownTo(uptr x, uptr boundary) {\n+inline uptr RoundDownTo(uptr x, uptr boundary) {\n   return x & ~(boundary - 1);\n }\n \n-INLINE bool IsAligned(uptr a, uptr alignment) {\n+inline bool IsAligned(uptr a, uptr alignment) {\n   return (a & (alignment - 1)) == 0;\n }\n \n-INLINE uptr Log2(uptr x) {\n+inline uptr Log2(uptr x) {\n   CHECK(IsPowerOfTwo(x));\n   return LeastSignificantSetBitIndex(x);\n }\n@@ -426,14 +451,14 @@ template<class T> void Swap(T& a, T& b) {\n }\n \n // Char handling\n-INLINE bool IsSpace(int c) {\n+inline bool IsSpace(int c) {\n   return (c == ' ') || (c == '\\n') || (c == '\\t') ||\n          (c == '\\f') || (c == '\\r') || (c == '\\v');\n }\n-INLINE bool IsDigit(int c) {\n+inline bool IsDigit(int c) {\n   return (c >= '0') && (c <= '9');\n }\n-INLINE int ToLower(int c) {\n+inline int ToLower(int c) {\n   return (c >= 'A' && c <= 'Z') ? (c + 'a' - 'A') : c;\n }\n \n@@ -649,7 +674,8 @@ enum ModuleArch {\n   kModuleArchARMV7,\n   kModuleArchARMV7S,\n   kModuleArchARMV7K,\n-  kModuleArchARM64\n+  kModuleArchARM64,\n+  kModuleArchRISCV64\n };\n \n // Opens the file 'file_name\" and reads up to 'max_len' bytes.\n@@ -693,6 +719,8 @@ inline const char *ModuleArchToString(ModuleArch arch) {\n       return \"armv7k\";\n     case kModuleArchARM64:\n       return \"arm64\";\n+    case kModuleArchRISCV64:\n+      return \"riscv64\";\n   }\n   CHECK(0 && \"Invalid module arch\");\n   return \"\";\n@@ -815,37 +843,37 @@ void WriteToSyslog(const char *buffer);\n #if SANITIZER_MAC || SANITIZER_WIN_TRACE\n void LogFullErrorReport(const char *buffer);\n #else\n-INLINE void LogFullErrorReport(const char *buffer) {}\n+inline void LogFullErrorReport(const char *buffer) {}\n #endif\n \n #if SANITIZER_LINUX || SANITIZER_MAC\n void WriteOneLineToSyslog(const char *s);\n void LogMessageOnPrintf(const char *str);\n #else\n-INLINE void WriteOneLineToSyslog(const char *s) {}\n-INLINE void LogMessageOnPrintf(const char *str) {}\n+inline void WriteOneLineToSyslog(const char *s) {}\n+inline void LogMessageOnPrintf(const char *str) {}\n #endif\n \n #if SANITIZER_LINUX || SANITIZER_WIN_TRACE\n // Initialize Android logging. Any writes before this are silently lost.\n void AndroidLogInit();\n void SetAbortMessage(const char *);\n #else\n-INLINE void AndroidLogInit() {}\n+inline void AndroidLogInit() {}\n // FIXME: MacOS implementation could use CRSetCrashLogMessage.\n-INLINE void SetAbortMessage(const char *) {}\n+inline void SetAbortMessage(const char *) {}\n #endif\n \n #if SANITIZER_ANDROID\n void SanitizerInitializeUnwinder();\n AndroidApiLevel AndroidGetApiLevel();\n #else\n-INLINE void AndroidLogWrite(const char *buffer_unused) {}\n-INLINE void SanitizerInitializeUnwinder() {}\n-INLINE AndroidApiLevel AndroidGetApiLevel() { return ANDROID_NOT_ANDROID; }\n+inline void AndroidLogWrite(const char *buffer_unused) {}\n+inline void SanitizerInitializeUnwinder() {}\n+inline AndroidApiLevel AndroidGetApiLevel() { return ANDROID_NOT_ANDROID; }\n #endif\n \n-INLINE uptr GetPthreadDestructorIterations() {\n+inline uptr GetPthreadDestructorIterations() {\n #if SANITIZER_ANDROID\n   return (AndroidGetApiLevel() == ANDROID_LOLLIPOP_MR1) ? 8 : 4;\n #elif SANITIZER_POSIX\n@@ -951,7 +979,7 @@ RunOnDestruction<Fn> at_scope_exit(Fn fn) {\n #if SANITIZER_LINUX && SANITIZER_S390_64\n void AvoidCVE_2016_2143();\n #else\n-INLINE void AvoidCVE_2016_2143() {}\n+inline void AvoidCVE_2016_2143() {}\n #endif\n \n struct StackDepotStats {\n@@ -972,12 +1000,26 @@ bool GetRandom(void *buffer, uptr length, bool blocking = true);\n // Returns the number of logical processors on the system.\n u32 GetNumberOfCPUs();\n extern u32 NumberOfCPUsCached;\n-INLINE u32 GetNumberOfCPUsCached() {\n+inline u32 GetNumberOfCPUsCached() {\n   if (!NumberOfCPUsCached)\n     NumberOfCPUsCached = GetNumberOfCPUs();\n   return NumberOfCPUsCached;\n }\n \n+template <typename T>\n+class ArrayRef {\n+ public:\n+  ArrayRef() {}\n+  ArrayRef(T *begin, T *end) : begin_(begin), end_(end) {}\n+\n+  T *begin() { return begin_; }\n+  T *end() { return end_; }\n+\n+ private:\n+  T *begin_ = nullptr;\n+  T *end_ = nullptr;\n+};\n+\n }  // namespace __sanitizer\n \n inline void *operator new(__sanitizer::operator_new_size_type size,"}, {"sha": "5b510781d40764575a5bd917264d98ae8c958f42", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc", "status": "modified", "additions": 299, "deletions": 49, "changes": 348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -445,8 +445,10 @@ INTERCEPTOR(int, strcmp, const char *s1, const char *s2) {\n     c2 = (unsigned char)s2[i];\n     if (c1 != c2 || c1 == '\\0') break;\n   }\n-  COMMON_INTERCEPTOR_READ_STRING(ctx, s1, i + 1);\n-  COMMON_INTERCEPTOR_READ_STRING(ctx, s2, i + 1);\n+  if (common_flags()->intercept_strcmp) {\n+    COMMON_INTERCEPTOR_READ_STRING(ctx, s1, i + 1);\n+    COMMON_INTERCEPTOR_READ_STRING(ctx, s2, i + 1);\n+  }\n   int result = CharCmpX(c1, c2);\n   CALL_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strcmp, GET_CALLER_PC(), s1,\n                              s2, result);\n@@ -2199,6 +2201,24 @@ INTERCEPTOR(int, clock_settime, u32 clk_id, const void *tp) {\n #define INIT_CLOCK_GETTIME\n #endif\n \n+#if SANITIZER_INTERCEPT_CLOCK_GETCPUCLOCKID\n+INTERCEPTOR(int, clock_getcpuclockid, pid_t pid,\n+            __sanitizer_clockid_t *clockid) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, clock_getcpuclockid, pid, clockid);\n+  int res = REAL(clock_getcpuclockid)(pid, clockid);\n+  if (!res && clockid) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, clockid, sizeof *clockid);\n+  }\n+  return res;\n+}\n+\n+#define INIT_CLOCK_GETCPUCLOCKID                  \\\n+  COMMON_INTERCEPT_FUNCTION(clock_getcpuclockid);\n+#else\n+#define INIT_CLOCK_GETCPUCLOCKID\n+#endif\n+\n #if SANITIZER_INTERCEPT_GETITIMER\n INTERCEPTOR(int, getitimer, int which, void *curr_value) {\n   void *ctx;\n@@ -3092,6 +3112,34 @@ INTERCEPTOR(int, sendmmsg, int fd, struct __sanitizer_mmsghdr *msgvec,\n #define INIT_SENDMMSG\n #endif\n \n+#if SANITIZER_INTERCEPT_SYSMSG\n+INTERCEPTOR(int, msgsnd, int msqid, const void *msgp, SIZE_T msgsz,\n+            int msgflg) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, msgsnd, msqid, msgp, msgsz, msgflg);\n+  if (msgp)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, msgp, sizeof(long) + msgsz);\n+  int res = REAL(msgsnd)(msqid, msgp, msgsz, msgflg);\n+  return res;\n+}\n+\n+INTERCEPTOR(SSIZE_T, msgrcv, int msqid, void *msgp, SIZE_T msgsz,\n+            long msgtyp, int msgflg) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, msgrcv, msqid, msgp, msgsz, msgtyp, msgflg);\n+  SSIZE_T len = REAL(msgrcv)(msqid, msgp, msgsz, msgtyp, msgflg);\n+  if (len != -1)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, msgp, sizeof(long) + len);\n+  return len;\n+}\n+\n+#define INIT_SYSMSG                  \\\n+  COMMON_INTERCEPT_FUNCTION(msgsnd); \\\n+  COMMON_INTERCEPT_FUNCTION(msgrcv);\n+#else\n+#define INIT_SYSMSG\n+#endif\n+\n #if SANITIZER_INTERCEPT_GETPEERNAME\n INTERCEPTOR(int, getpeername, int sockfd, void *addr, unsigned *addrlen) {\n   void *ctx;\n@@ -4039,6 +4087,41 @@ INTERCEPTOR(int, sigfillset, __sanitizer_sigset_t *set) {\n #define INIT_SIGSETOPS\n #endif\n \n+#if SANITIZER_INTERCEPT_SIGSET_LOGICOPS\n+INTERCEPTOR(int, sigandset, __sanitizer_sigset_t *dst,\n+            __sanitizer_sigset_t *src1, __sanitizer_sigset_t *src2) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, sigandset, dst, src1, src2);\n+  if (src1)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, src1, sizeof(*src1));\n+  if (src2)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, src2, sizeof(*src2));\n+  int res = REAL(sigandset)(dst, src1, src2);\n+  if (!res && dst)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, sizeof(*dst));\n+  return res;\n+}\n+\n+INTERCEPTOR(int, sigorset, __sanitizer_sigset_t *dst,\n+            __sanitizer_sigset_t *src1, __sanitizer_sigset_t *src2) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, sigorset, dst, src1, src2);\n+  if (src1)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, src1, sizeof(*src1));\n+  if (src2)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, src2, sizeof(*src2));\n+  int res = REAL(sigorset)(dst, src1, src2);\n+  if (!res && dst)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, sizeof(*dst));\n+  return res;\n+}\n+#define INIT_SIGSET_LOGICOPS                    \\\n+  COMMON_INTERCEPT_FUNCTION(sigandset);   \\\n+  COMMON_INTERCEPT_FUNCTION(sigorset);\n+#else\n+#define INIT_SIGSET_LOGICOPS\n+#endif\n+\n #if SANITIZER_INTERCEPT_SIGPENDING\n INTERCEPTOR(int, sigpending, __sanitizer_sigset_t *set) {\n   void *ctx;\n@@ -4792,6 +4875,34 @@ INTERCEPTOR(char *, tmpnam_r, char *s) {\n #define INIT_TMPNAM_R\n #endif\n \n+#if SANITIZER_INTERCEPT_PTSNAME\n+INTERCEPTOR(char *, ptsname, int fd) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, ptsname, fd);\n+  char *res = REAL(ptsname)(fd);\n+  if (res != nullptr)\n+    COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, REAL(strlen)(res) + 1);\n+  return res;\n+}\n+#define INIT_PTSNAME COMMON_INTERCEPT_FUNCTION(ptsname);\n+#else\n+#define INIT_PTSNAME\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PTSNAME_R\n+INTERCEPTOR(int, ptsname_r, int fd, char *name, SIZE_T namesize) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, ptsname_r, fd, name, namesize);\n+  int res = REAL(ptsname_r)(fd, name, namesize);\n+  if (res == 0)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, name, REAL(strlen)(name) + 1);\n+  return res;\n+}\n+#define INIT_PTSNAME_R COMMON_INTERCEPT_FUNCTION(ptsname_r);\n+#else\n+#define INIT_PTSNAME_R\n+#endif\n+\n #if SANITIZER_INTERCEPT_TTYNAME\n INTERCEPTOR(char *, ttyname, int fd) {\n   void *ctx;\n@@ -5763,6 +5874,79 @@ INTERCEPTOR(int, xdr_string, __sanitizer_XDR *xdrs, char **p,\n #define INIT_XDR\n #endif  // SANITIZER_INTERCEPT_XDR\n \n+#if SANITIZER_INTERCEPT_XDRREC\n+typedef int (*xdrrec_cb)(char*, char*, int);\n+struct XdrRecWrapper {\n+  char *handle;\n+  xdrrec_cb rd, wr;\n+};\n+typedef AddrHashMap<XdrRecWrapper *, 11> XdrRecWrapMap;\n+static XdrRecWrapMap *xdrrec_wrap_map;\n+\n+static int xdrrec_wr_wrap(char *handle, char *buf, int count) {\n+  COMMON_INTERCEPTOR_UNPOISON_PARAM(3);\n+  COMMON_INTERCEPTOR_INITIALIZE_RANGE(buf, count);\n+  XdrRecWrapper *wrap = (XdrRecWrapper *)handle;\n+  return wrap->wr(wrap->handle, buf, count);\n+}\n+\n+static int xdrrec_rd_wrap(char *handle, char *buf, int count) {\n+  COMMON_INTERCEPTOR_UNPOISON_PARAM(3);\n+  XdrRecWrapper *wrap = (XdrRecWrapper *)handle;\n+  return wrap->rd(wrap->handle, buf, count);\n+}\n+\n+// This doesn't apply to the solaris version as it has a different function\n+// signature.\n+INTERCEPTOR(void, xdrrec_create, __sanitizer_XDR *xdr, unsigned sndsize,\n+            unsigned rcvsize, char *handle, int (*rd)(char*, char*, int),\n+            int (*wr)(char*, char*, int)) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, xdrrec_create, xdr, sndsize, rcvsize,\n+                           handle, rd, wr);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, &xdr->x_op, sizeof xdr->x_op);\n+\n+  // We can't allocate a wrapper on the stack, as the handle is used outside\n+  // this stack frame. So we put it on the heap, and keep track of it with\n+  // the HashMap (keyed by x_private). When we later need to xdr_destroy,\n+  // we can index the map, free the wrapper, and then clean the map entry.\n+  XdrRecWrapper *wrap_data =\n+      (XdrRecWrapper *)InternalAlloc(sizeof(XdrRecWrapper));\n+  wrap_data->handle = handle;\n+  wrap_data->rd = rd;\n+  wrap_data->wr = wr;\n+  if (wr)\n+    wr = xdrrec_wr_wrap;\n+  if (rd)\n+    rd = xdrrec_rd_wrap;\n+  handle = (char *)wrap_data;\n+\n+  REAL(xdrrec_create)(xdr, sndsize, rcvsize, handle, rd, wr);\n+  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, xdr, sizeof *xdr);\n+\n+  XdrRecWrapMap::Handle wrap(xdrrec_wrap_map, xdr->x_private, false, true);\n+  *wrap = wrap_data;\n+}\n+\n+// We have to intercept this to be able to free wrapper memory;\n+// otherwise it's not necessary.\n+INTERCEPTOR(void, xdr_destroy, __sanitizer_XDR *xdr) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, xdr_destroy, xdr);\n+\n+  XdrRecWrapMap::Handle wrap(xdrrec_wrap_map, xdr->x_private, true);\n+  InternalFree(*wrap);\n+  REAL(xdr_destroy)(xdr);\n+}\n+#define INIT_XDRREC_LINUX \\\n+  static u64 xdrrec_wrap_mem[sizeof(XdrRecWrapMap) / sizeof(u64) + 1]; \\\n+  xdrrec_wrap_map = new ((void *)&xdrrec_wrap_mem) XdrRecWrapMap(); \\\n+  COMMON_INTERCEPT_FUNCTION(xdrrec_create); \\\n+  COMMON_INTERCEPT_FUNCTION(xdr_destroy);\n+#else\n+#define INIT_XDRREC_LINUX\n+#endif\n+\n #if SANITIZER_INTERCEPT_TSEARCH\n INTERCEPTOR(void *, tsearch, void *key, void **rootp,\n             int (*compar)(const void *, const void *)) {\n@@ -7271,23 +7455,26 @@ INTERCEPTOR(int, setttyentpath, char *path) {\n #endif\n \n #if SANITIZER_INTERCEPT_PROTOENT\n-INTERCEPTOR(struct __sanitizer_protoent *, getprotoent) {\n-  void *ctx;\n-  COMMON_INTERCEPTOR_ENTER(ctx, getprotoent);\n-  struct __sanitizer_protoent *p = REAL(getprotoent)();\n-  if (p) {\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, sizeof(*p));\n+static void write_protoent(void *ctx, struct __sanitizer_protoent *p) {\n+  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, sizeof(*p));\n \n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->p_name, REAL(strlen)(p->p_name) + 1);\n+  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->p_name, REAL(strlen)(p->p_name) + 1);\n \n-    SIZE_T pp_size = 1; // One handles the trailing \\0\n+  SIZE_T pp_size = 1; // One handles the trailing \\0\n \n-    for (char **pp = p->p_aliases; *pp; ++pp, ++pp_size)\n-       COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *pp, REAL(strlen)(*pp) + 1);\n+  for (char **pp = p->p_aliases; *pp; ++pp, ++pp_size)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *pp, REAL(strlen)(*pp) + 1);\n \n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->p_aliases,\n-                                   pp_size * sizeof(char **));\n-  }\n+  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->p_aliases,\n+                                  pp_size * sizeof(char **));\n+}\n+\n+INTERCEPTOR(struct __sanitizer_protoent *, getprotoent) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getprotoent);\n+  struct __sanitizer_protoent *p = REAL(getprotoent)();\n+  if (p)\n+    write_protoent(ctx, p);\n   return p;\n }\n \n@@ -7297,39 +7484,17 @@ INTERCEPTOR(struct __sanitizer_protoent *, getprotobyname, const char *name) {\n   if (name)\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n   struct __sanitizer_protoent *p = REAL(getprotobyname)(name);\n-  if (p) {\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, sizeof(*p));\n-\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->p_name, REAL(strlen)(p->p_name) + 1);\n-\n-    SIZE_T pp_size = 1; // One handles the trailing \\0\n-\n-    for (char **pp = p->p_aliases; *pp; ++pp, ++pp_size)\n-       COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *pp, REAL(strlen)(*pp) + 1);\n-\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->p_aliases,\n-                                   pp_size * sizeof(char **));\n-  }\n+  if (p)\n+    write_protoent(ctx, p);\n   return p;\n }\n \n INTERCEPTOR(struct __sanitizer_protoent *, getprotobynumber, int proto) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getprotobynumber, proto);\n   struct __sanitizer_protoent *p = REAL(getprotobynumber)(proto);\n-  if (p) {\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, sizeof(*p));\n-\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->p_name, REAL(strlen)(p->p_name) + 1);\n-\n-    SIZE_T pp_size = 1; // One handles the trailing \\0\n-\n-    for (char **pp = p->p_aliases; *pp; ++pp, ++pp_size)\n-       COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *pp, REAL(strlen)(*pp) + 1);\n-\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->p_aliases,\n-                                   pp_size * sizeof(char **));\n-  }\n+  if (p)\n+    write_protoent(ctx, p);\n   return p;\n }\n #define INIT_PROTOENT \\\n@@ -7340,6 +7505,58 @@ INTERCEPTOR(struct __sanitizer_protoent *, getprotobynumber, int proto) {\n #define INIT_PROTOENT\n #endif\n \n+#if SANITIZER_INTERCEPT_PROTOENT_R\n+INTERCEPTOR(int, getprotoent_r, struct __sanitizer_protoent *result_buf,\n+            char *buf, SIZE_T buflen, struct __sanitizer_protoent **result) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getprotoent_r, result_buf, buf, buflen,\n+                           result);\n+  int res = REAL(getprotoent_r)(result_buf, buf, buflen, result);\n+\n+  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof *result);\n+  if (!res && *result)\n+    write_protoent(ctx, *result);\n+  return res;\n+}\n+\n+INTERCEPTOR(int, getprotobyname_r, const char *name,\n+            struct __sanitizer_protoent *result_buf, char *buf, SIZE_T buflen,\n+            struct __sanitizer_protoent **result) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getprotobyname_r, name, result_buf, buf,\n+                           buflen, result);\n+  if (name)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n+  int res = REAL(getprotobyname_r)(name, result_buf, buf, buflen, result);\n+\n+  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof *result);\n+  if (!res && *result)\n+    write_protoent(ctx, *result);\n+  return res;\n+}\n+\n+INTERCEPTOR(int, getprotobynumber_r, int num,\n+            struct __sanitizer_protoent *result_buf, char *buf,\n+            SIZE_T buflen, struct __sanitizer_protoent **result) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getprotobynumber_r, num, result_buf, buf,\n+                           buflen, result);\n+  int res = REAL(getprotobynumber_r)(num, result_buf, buf, buflen, result);\n+\n+  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof *result);\n+  if (!res && *result)\n+    write_protoent(ctx, *result);\n+  return res;\n+}\n+\n+#define INIT_PROTOENT_R \\\n+  COMMON_INTERCEPT_FUNCTION(getprotoent_r); \\\n+  COMMON_INTERCEPT_FUNCTION(getprotobyname_r); \\\n+  COMMON_INTERCEPT_FUNCTION(getprotobynumber_r);\n+#else\n+#define INIT_PROTOENT_R\n+#endif\n+\n #if SANITIZER_INTERCEPT_NETENT\n INTERCEPTOR(struct __sanitizer_netent *, getnetent) {\n   void *ctx;\n@@ -9676,12 +9893,25 @@ INTERCEPTOR(void, qsort, void *base, SIZE_T nmemb, SIZE_T size,\n     }\n   }\n   qsort_compar_f old_compar = qsort_compar;\n-  qsort_compar = compar;\n   SIZE_T old_size = qsort_size;\n-  qsort_size = size;\n+  // Handle qsort() implementations that recurse using an\n+  // interposable function call:\n+  bool already_wrapped = compar == wrapped_qsort_compar;\n+  if (already_wrapped) {\n+    // This case should only happen if the qsort() implementation calls itself\n+    // using a preemptible function call (e.g. the FreeBSD libc version).\n+    // Check that the size and comparator arguments are as expected.\n+    CHECK_NE(compar, qsort_compar);\n+    CHECK_EQ(qsort_size, size);\n+  } else {\n+    qsort_compar = compar;\n+    qsort_size = size;\n+  }\n   REAL(qsort)(base, nmemb, size, wrapped_qsort_compar);\n-  qsort_compar = old_compar;\n-  qsort_size = old_size;\n+  if (!already_wrapped) {\n+    qsort_compar = old_compar;\n+    qsort_size = old_size;\n+  }\n   COMMON_INTERCEPTOR_WRITE_RANGE(ctx, base, nmemb * size);\n }\n #define INIT_QSORT COMMON_INTERCEPT_FUNCTION(qsort)\n@@ -9714,12 +9944,25 @@ INTERCEPTOR(void, qsort_r, void *base, SIZE_T nmemb, SIZE_T size,\n     }\n   }\n   qsort_r_compar_f old_compar = qsort_r_compar;\n-  qsort_r_compar = compar;\n   SIZE_T old_size = qsort_r_size;\n-  qsort_r_size = size;\n+  // Handle qsort_r() implementations that recurse using an\n+  // interposable function call:\n+  bool already_wrapped = compar == wrapped_qsort_r_compar;\n+  if (already_wrapped) {\n+    // This case should only happen if the qsort() implementation calls itself\n+    // using a preemptible function call (e.g. the FreeBSD libc version).\n+    // Check that the size and comparator arguments are as expected.\n+    CHECK_NE(compar, qsort_r_compar);\n+    CHECK_EQ(qsort_r_size, size);\n+  } else {\n+    qsort_r_compar = compar;\n+    qsort_r_size = size;\n+  }\n   REAL(qsort_r)(base, nmemb, size, wrapped_qsort_r_compar, arg);\n-  qsort_r_compar = old_compar;\n-  qsort_r_size = old_size;\n+  if (!already_wrapped) {\n+    qsort_r_compar = old_compar;\n+    qsort_r_size = old_size;\n+  }\n   COMMON_INTERCEPTOR_WRITE_RANGE(ctx, base, nmemb * size);\n }\n #define INIT_QSORT_R COMMON_INTERCEPT_FUNCTION(qsort_r)\n@@ -9853,6 +10096,7 @@ static void InitializeCommonInterceptors() {\n   INIT_FGETGRENT_R;\n   INIT_SETPWENT;\n   INIT_CLOCK_GETTIME;\n+  INIT_CLOCK_GETCPUCLOCKID;\n   INIT_GETITIMER;\n   INIT_TIME;\n   INIT_GLOB;\n@@ -9879,6 +10123,7 @@ static void InitializeCommonInterceptors() {\n   INIT_SENDMSG;\n   INIT_RECVMMSG;\n   INIT_SENDMMSG;\n+  INIT_SYSMSG;\n   INIT_GETPEERNAME;\n   INIT_IOCTL;\n   INIT_INET_ATON;\n@@ -9915,6 +10160,7 @@ static void InitializeCommonInterceptors() {\n   INIT_SIGWAITINFO;\n   INIT_SIGTIMEDWAIT;\n   INIT_SIGSETOPS;\n+  INIT_SIGSET_LOGICOPS;\n   INIT_SIGPENDING;\n   INIT_SIGPROCMASK;\n   INIT_PTHREAD_SIGMASK;\n@@ -9956,6 +10202,8 @@ static void InitializeCommonInterceptors() {\n   INIT_PTHREAD_BARRIERATTR_GETPSHARED;\n   INIT_TMPNAM;\n   INIT_TMPNAM_R;\n+  INIT_PTSNAME;\n+  INIT_PTSNAME_R;\n   INIT_TTYNAME;\n   INIT_TTYNAME_R;\n   INIT_TEMPNAM;\n@@ -9985,6 +10233,7 @@ static void InitializeCommonInterceptors() {\n   INIT_BZERO;\n   INIT_FTIME;\n   INIT_XDR;\n+  INIT_XDRREC_LINUX;\n   INIT_TSEARCH;\n   INIT_LIBIO_INTERNALS;\n   INIT_FOPEN;\n@@ -10042,6 +10291,7 @@ static void InitializeCommonInterceptors() {\n   INIT_STRMODE;\n   INIT_TTYENT;\n   INIT_PROTOENT;\n+  INIT_PROTOENT_R;\n   INIT_NETENT;\n   INIT_GETMNTINFO;\n   INIT_MI_VECTOR_HASH;"}, {"sha": "082398ba960afd090b98531ee5cfaa211f9ebc3e", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors_format.inc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_format.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_format.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_format.inc?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -340,6 +340,12 @@ static void scanf_common(void *ctx, int n_inputs, bool allowGnuMalloc,\n       size = 0;\n     }\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, argp, size);\n+    // For %ms/%mc, write the allocated output buffer as well.\n+    if (dir.allocate) {\n+      char *buf = *(char **)argp;\n+      if (buf)\n+        COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, internal_strlen(buf) + 1);\n+    }\n   }\n }\n "}, {"sha": "b7ec27859b8a2ad284a0946c61a2659932f8fb80", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors_vfork_riscv64.inc.S", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_vfork_riscv64.inc.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_vfork_riscv64.inc.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_vfork_riscv64.inc.S?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -0,0 +1,56 @@\n+#if (defined(__riscv) && (__riscv_xlen == 64)) && defined(__linux__)\n+\n+#include \"sanitizer_common/sanitizer_asm.h\"\n+\n+ASM_HIDDEN(COMMON_INTERCEPTOR_SPILL_AREA)\n+\n+.comm _ZN14__interception10real_vforkE,8,8\n+.globl ASM_WRAPPER_NAME(vfork)\n+ASM_TYPE_FUNCTION(ASM_WRAPPER_NAME(vfork))\n+ASM_WRAPPER_NAME(vfork):\n+        // Save ra in the off-stack spill area.\n+        // allocate space on stack\n+        addi    sp, sp, -16\n+        // store ra value \n+        sd      ra, 8(sp)\n+        call    COMMON_INTERCEPTOR_SPILL_AREA\n+        // restore previous values from stack\n+        ld      ra, 8(sp)\n+        // adjust stack\n+        addi    sp, sp, 16\n+        // store ra by x10\n+        sd      ra, 0(x10)\n+\n+        // Call real vfork. This may return twice. User code that runs between the first and the second return\n+        // may clobber the stack frame of the interceptor; that's why it does not have a frame.\n+        la x10, _ZN14__interception10real_vforkE\n+        ld x10, 0(x10)\n+        jalr x10\n+\n+        // adjust stack\n+        addi    sp, sp, -16\n+        // store x10 by adjusted stack\n+        sd      x10, 8(sp)\n+        // jump to exit label if x10 is 0\n+        beqz    x10, .L_exit\n+\n+        // x0 != 0 => parent process. Clear stack shadow.\n+        // put old sp to x10\n+        addi   x10, sp, 16\n+        call   COMMON_INTERCEPTOR_HANDLE_VFORK\n+\n+.L_exit:\n+        // Restore ra\n+        call   COMMON_INTERCEPTOR_SPILL_AREA\n+        ld     ra, 0(x10)\n+        // load value by stack\n+        ld     x10, 8(sp)\n+        // adjust stack\n+        addi   sp, sp, 16\n+        ret\n+ASM_SIZE(vfork)\n+\n+.weak vfork\n+.set vfork, ASM_WRAPPER_NAME(vfork)\n+\n+#endif"}, {"sha": "047c5a17ea6e77dedc763482dc6b60dfad29a219", "filename": "libsanitizer/sanitizer_common/sanitizer_common_libcdep.cpp", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -139,6 +139,59 @@ uptr ReservedAddressRange::InitAligned(uptr size, uptr align,\n   return start;\n }\n \n+#if !SANITIZER_FUCHSIA && !SANITIZER_RTEMS\n+\n+// Reserve memory range [beg, end].\n+// We need to use inclusive range because end+1 may not be representable.\n+void ReserveShadowMemoryRange(uptr beg, uptr end, const char *name,\n+                              bool madvise_shadow) {\n+  CHECK_EQ((beg % GetMmapGranularity()), 0);\n+  CHECK_EQ(((end + 1) % GetMmapGranularity()), 0);\n+  uptr size = end - beg + 1;\n+  DecreaseTotalMmap(size);  // Don't count the shadow against mmap_limit_mb.\n+  if (madvise_shadow ? !MmapFixedSuperNoReserve(beg, size, name)\n+                     : !MmapFixedNoReserve(beg, size, name)) {\n+    Report(\n+        \"ReserveShadowMemoryRange failed while trying to map 0x%zx bytes. \"\n+        \"Perhaps you're using ulimit -v\\n\",\n+        size);\n+    Abort();\n+  }\n+  if (madvise_shadow && common_flags()->use_madv_dontdump)\n+    DontDumpShadowMemory(beg, size);\n+}\n+\n+void ProtectGap(uptr addr, uptr size, uptr zero_base_shadow_start,\n+                uptr zero_base_max_shadow_start) {\n+  if (!size)\n+    return;\n+  void *res = MmapFixedNoAccess(addr, size, \"shadow gap\");\n+  if (addr == (uptr)res)\n+    return;\n+  // A few pages at the start of the address space can not be protected.\n+  // But we really want to protect as much as possible, to prevent this memory\n+  // being returned as a result of a non-FIXED mmap().\n+  if (addr == zero_base_shadow_start) {\n+    uptr step = GetMmapGranularity();\n+    while (size > step && addr < zero_base_max_shadow_start) {\n+      addr += step;\n+      size -= step;\n+      void *res = MmapFixedNoAccess(addr, size, \"shadow gap\");\n+      if (addr == (uptr)res)\n+        return;\n+    }\n+  }\n+\n+  Report(\n+      \"ERROR: Failed to protect the shadow gap. \"\n+      \"%s cannot proceed correctly. ABORTING.\\n\",\n+      SanitizerToolName);\n+  DumpProcessMap();\n+  Die();\n+}\n+\n+#endif  // !SANITIZER_FUCHSIA && !SANITIZER_RTEMS\n+\n }  // namespace __sanitizer\n \n SANITIZER_INTERFACE_WEAK_DEF(void, __sanitizer_sandbox_on_notify,"}, {"sha": "1b89d6e176840570667808f8301c9a1c01b68c3b", "filename": "libsanitizer/sanitizer_common/sanitizer_common_syscalls.inc", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_syscalls.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_syscalls.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_syscalls.inc?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -2294,9 +2294,10 @@ PRE_SYSCALL(ni_syscall)() {}\n POST_SYSCALL(ni_syscall)(long res) {}\n \n PRE_SYSCALL(ptrace)(long request, long pid, long addr, long data) {\n-#if !SANITIZER_ANDROID && \\\n-    (defined(__i386) || defined(__x86_64) || defined(__mips64) || \\\n-     defined(__powerpc64__) || defined(__aarch64__) || defined(__s390__))\n+#if !SANITIZER_ANDROID &&                                                   \\\n+    (defined(__i386) || defined(__x86_64) || defined(__mips64) ||           \\\n+     defined(__powerpc64__) || defined(__aarch64__) || defined(__s390__) || \\\n+     SANITIZER_RISCV64)\n   if (data) {\n     if (request == ptrace_setregs) {\n       PRE_READ((void *)data, struct_user_regs_struct_sz);\n@@ -2315,9 +2316,10 @@ PRE_SYSCALL(ptrace)(long request, long pid, long addr, long data) {\n }\n \n POST_SYSCALL(ptrace)(long res, long request, long pid, long addr, long data) {\n-#if !SANITIZER_ANDROID && \\\n-    (defined(__i386) || defined(__x86_64) || defined(__mips64) || \\\n-     defined(__powerpc64__) || defined(__aarch64__) || defined(__s390__))\n+#if !SANITIZER_ANDROID &&                                                   \\\n+    (defined(__i386) || defined(__x86_64) || defined(__mips64) ||           \\\n+     defined(__powerpc64__) || defined(__aarch64__) || defined(__s390__) || \\\n+     SANITIZER_RISCV64)\n   if (res >= 0 && data) {\n     // Note that this is different from the interceptor in\n     // sanitizer_common_interceptors.inc."}, {"sha": "192e9392d494a3e92d5bfc44238c6607039b8c63", "filename": "libsanitizer/sanitizer_common/sanitizer_errno_codes.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_errno_codes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_errno_codes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_errno_codes.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -24,6 +24,7 @@ namespace __sanitizer {\n #define errno_ENOMEM 12\n #define errno_EBUSY 16\n #define errno_EINVAL 22\n+#define errno_ENAMETOOLONG 36\n \n // Those might not present or their value differ on different platforms.\n extern const int errno_EOWNERDEAD;"}, {"sha": "d3290493fd6daa8c27e34fec4aacb01bbb5c91bb", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -91,7 +91,7 @@ class FlagHandlerInclude : public FlagHandlerBase {\n     }\n     return parser_->ParseFile(value, ignore_missing_);\n   }\n-  bool Format(char *buffer, uptr size) {\n+  bool Format(char *buffer, uptr size) override {\n     // Note `original_path_` isn't actually what's parsed due to `%`\n     // substitutions. Printing the substituted path would require holding onto\n     // mmap'ed memory."}, {"sha": "d1412478fd2c48b949fb1703c492aa058d174089", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.inc", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.inc?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -40,7 +40,12 @@ COMMON_FLAG(bool, fast_unwind_on_check, false,\n COMMON_FLAG(bool, fast_unwind_on_fatal, false,\n             \"If available, use the fast frame-pointer-based unwinder on fatal \"\n             \"errors.\")\n-COMMON_FLAG(bool, fast_unwind_on_malloc, true,\n+// ARM thumb/thumb2 frame pointer is inconsistent on GCC and Clang [1]\n+// and fast-unwider is also unreliable with mixing arm and thumb code [2].\n+// [1] https://gcc.gnu.org/bugzilla/show_bug.cgi?id=92172\n+// [2] https://bugs.llvm.org/show_bug.cgi?id=44158\n+COMMON_FLAG(bool, fast_unwind_on_malloc,\n+            !(SANITIZER_LINUX && !SANITIZER_ANDROID && SANITIZER_ARM),\n             \"If available, use the fast frame-pointer-based unwinder on \"\n             \"malloc/free.\")\n COMMON_FLAG(bool, handle_ioctl, false, \"Intercept and handle ioctl requests.\")\n@@ -195,6 +200,9 @@ COMMON_FLAG(bool, intercept_strtok, true,\n COMMON_FLAG(bool, intercept_strpbrk, true,\n             \"If set, uses custom wrappers for strpbrk function \"\n             \"to find more errors.\")\n+COMMON_FLAG(\n+    bool, intercept_strcmp, true,\n+    \"If set, uses custom wrappers for strcmp functions to find more errors.\")\n COMMON_FLAG(bool, intercept_strlen, true,\n             \"If set, uses custom wrappers for strlen and strnlen functions \"\n             \"to find more errors.\")"}, {"sha": "38439e44f611e6fe59da7a9de1650a8a98f619c9", "filename": "libsanitizer/sanitizer_common/sanitizer_getauxval.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_getauxval.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_getauxval.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_getauxval.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -21,8 +21,9 @@\n \n #if SANITIZER_LINUX || SANITIZER_FUCHSIA\n \n-# if __GLIBC_PREREQ(2, 16) || (SANITIZER_ANDROID && __ANDROID_API__ >= 21) || \\\n-     SANITIZER_FUCHSIA\n+# if (__GLIBC_PREREQ(2, 16) || (SANITIZER_ANDROID && __ANDROID_API__ >= 21) || \\\n+      SANITIZER_FUCHSIA) &&                                                    \\\n+     !SANITIZER_GO\n #  define SANITIZER_USE_GETAUXVAL 1\n # else\n #  define SANITIZER_USE_GETAUXVAL 0"}, {"sha": "a6c5514870528c12e4e117864ea98297a0ceed78", "filename": "libsanitizer/sanitizer_common/sanitizer_internal_defs.h", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -196,9 +196,6 @@ typedef u64 tid_t;\n // This header should NOT include any other headers to avoid portability issues.\n \n // Common defs.\n-#ifndef INLINE\n-#define INLINE inline\n-#endif\n #define INTERFACE_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n #define SANITIZER_WEAK_DEFAULT_IMPL \\\n   extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE NOINLINE\n@@ -333,14 +330,10 @@ void NORETURN CheckFailed(const char *file, int line, const char *cond,\n \n #define UNIMPLEMENTED() UNREACHABLE(\"unimplemented\")\n \n-#define COMPILER_CHECK(pred) IMPL_COMPILER_ASSERT(pred, __LINE__)\n+#define COMPILER_CHECK(pred) static_assert(pred, \"\")\n \n #define ARRAY_SIZE(a) (sizeof(a)/sizeof((a)[0]))\n \n-#define IMPL_PASTE(a, b) a##b\n-#define IMPL_COMPILER_ASSERT(pred, line) \\\n-    typedef char IMPL_PASTE(assertion_failed_##_, line)[2*(int)(pred)-1]\n-\n // Limits for integral types. We have to redefine it in case we don't\n // have stdint.h (like in Visual Studio 9).\n #undef __INT64_C"}, {"sha": "c84946ca9bf29ff4c1de52d90cfe2bc474af3f09", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.cpp", "status": "modified", "additions": 96, "deletions": 20, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -154,6 +154,8 @@ namespace __sanitizer {\n \n #if SANITIZER_LINUX && defined(__x86_64__)\n #include \"sanitizer_syscall_linux_x86_64.inc\"\n+#elif SANITIZER_LINUX && SANITIZER_RISCV64\n+#include \"sanitizer_syscall_linux_riscv64.inc\"\n #elif SANITIZER_LINUX && defined(__aarch64__)\n #include \"sanitizer_syscall_linux_aarch64.inc\"\n #elif SANITIZER_LINUX && defined(__arm__)\n@@ -187,6 +189,10 @@ uptr internal_munmap(void *addr, uptr length) {\n int internal_mprotect(void *addr, uptr length, int prot) {\n   return internal_syscall(SYSCALL(mprotect), (uptr)addr, length, prot);\n }\n+\n+int internal_madvise(uptr addr, uptr length, int advice) {\n+  return internal_syscall(SYSCALL(madvise), addr, length, advice);\n+}\n #endif\n \n uptr internal_close(fd_t fd) {\n@@ -422,15 +428,6 @@ uptr internal_sched_yield() {\n   return internal_syscall(SYSCALL(sched_yield));\n }\n \n-void internal__exit(int exitcode) {\n-#if SANITIZER_FREEBSD || SANITIZER_OPENBSD\n-  internal_syscall(SYSCALL(exit), exitcode);\n-#else\n-  internal_syscall(SYSCALL(exit_group), exitcode);\n-#endif\n-  Die();  // Unreachable.\n-}\n-\n unsigned int internal_sleep(unsigned int seconds) {\n   struct timespec ts;\n   ts.tv_sec = seconds;\n@@ -447,6 +444,17 @@ uptr internal_execve(const char *filename, char *const argv[],\n }\n #endif  // !SANITIZER_SOLARIS && !SANITIZER_NETBSD\n \n+#if !SANITIZER_NETBSD\n+void internal__exit(int exitcode) {\n+#if SANITIZER_FREEBSD || SANITIZER_OPENBSD || SANITIZER_SOLARIS\n+  internal_syscall(SYSCALL(exit), exitcode);\n+#else\n+  internal_syscall(SYSCALL(exit_group), exitcode);\n+#endif\n+  Die();  // Unreachable.\n+}\n+#endif  // !SANITIZER_NETBSD\n+\n // ----------------- sanitizer_common.h\n bool FileExists(const char *filename) {\n   if (ShouldMockFailureToOpen(filename))\n@@ -706,15 +714,15 @@ struct linux_dirent {\n };\n #else\n struct linux_dirent {\n-#if SANITIZER_X32 || defined(__aarch64__)\n+#if SANITIZER_X32 || defined(__aarch64__) || SANITIZER_RISCV64\n   u64 d_ino;\n   u64 d_off;\n #else\n   unsigned long      d_ino;\n   unsigned long      d_off;\n #endif\n   unsigned short     d_reclen;\n-#ifdef __aarch64__\n+#if defined(__aarch64__) || SANITIZER_RISCV64\n   unsigned char      d_type;\n #endif\n   char               d_name[256];\n@@ -796,11 +804,29 @@ int internal_sysctl(const int *name, unsigned int namelen, void *oldp,\n #if SANITIZER_FREEBSD\n int internal_sysctlbyname(const char *sname, void *oldp, uptr *oldlenp,\n                           const void *newp, uptr newlen) {\n-  static decltype(sysctlbyname) *real = nullptr;\n-  if (!real)\n-    real = (decltype(sysctlbyname) *)dlsym(RTLD_NEXT, \"sysctlbyname\");\n-  CHECK(real);\n-  return real(sname, oldp, (size_t *)oldlenp, newp, (size_t)newlen);\n+  // Note: this function can be called during startup, so we need to avoid\n+  // calling any interceptable functions. On FreeBSD >= 1300045 sysctlbyname()\n+  // is a real syscall, but for older versions it calls sysctlnametomib()\n+  // followed by sysctl(). To avoid calling the intercepted version and\n+  // asserting if this happens during startup, call the real sysctlnametomib()\n+  // followed by internal_sysctl() if the syscall is not available.\n+#ifdef SYS___sysctlbyname\n+  return internal_syscall(SYSCALL(__sysctlbyname), sname,\n+                          internal_strlen(sname), oldp, (size_t *)oldlenp, newp,\n+                          (size_t)newlen);\n+#else\n+  static decltype(sysctlnametomib) *real_sysctlnametomib = nullptr;\n+  if (!real_sysctlnametomib)\n+    real_sysctlnametomib =\n+        (decltype(sysctlnametomib) *)dlsym(RTLD_NEXT, \"sysctlnametomib\");\n+  CHECK(real_sysctlnametomib);\n+\n+  int oid[CTL_MAXNAME];\n+  size_t len = CTL_MAXNAME;\n+  if (real_sysctlnametomib(sname, oid, &len) == -1)\n+    return (-1);\n+  return internal_sysctl(oid, len, oldp, oldlenp, newp, newlen);\n+#endif\n }\n #endif\n #endif\n@@ -861,9 +887,8 @@ uptr internal_sigprocmask(int how, __sanitizer_sigset_t *set,\n #else\n   __sanitizer_kernel_sigset_t *k_set = (__sanitizer_kernel_sigset_t *)set;\n   __sanitizer_kernel_sigset_t *k_oldset = (__sanitizer_kernel_sigset_t *)oldset;\n-  return internal_syscall(SYSCALL(rt_sigprocmask), (uptr)how,\n-                          (uptr)&k_set->sig[0], (uptr)&k_oldset->sig[0],\n-                          sizeof(__sanitizer_kernel_sigset_t));\n+  return internal_syscall(SYSCALL(rt_sigprocmask), (uptr)how, (uptr)k_set,\n+                          (uptr)k_oldset, sizeof(__sanitizer_kernel_sigset_t));\n #endif\n }\n \n@@ -1046,6 +1071,8 @@ uptr GetMaxVirtualAddress() {\n   // This should (does) work for both PowerPC64 Endian modes.\n   // Similarly, aarch64 has multiple address space layouts: 39, 42 and 47-bit.\n   return (1ULL << (MostSignificantSetBitIndex(GET_CURRENT_FRAME()) + 1)) - 1;\n+#elif SANITIZER_RISCV64\n+  return (1ULL << 38) - 1;\n # elif defined(__mips64)\n   return (1ULL << 40) - 1;  // 0x000000ffffffffffUL;\n # elif defined(__s390x__)\n@@ -1340,6 +1367,55 @@ uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n                        : \"memory\", \"$29\" );\n   return res;\n }\n+#elif SANITIZER_RISCV64\n+uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n+                    int *parent_tidptr, void *newtls, int *child_tidptr) {\n+  long long res;\n+  if (!fn || !child_stack)\n+    return -EINVAL;\n+  CHECK_EQ(0, (uptr)child_stack % 16);\n+  child_stack = (char *)child_stack - 2 * sizeof(unsigned long long);\n+  ((unsigned long long *)child_stack)[0] = (uptr)fn;\n+  ((unsigned long long *)child_stack)[1] = (uptr)arg;\n+\n+  register int (*__fn)(void *) __asm__(\"a0\") = fn;\n+  register void *__stack __asm__(\"a1\") = child_stack;\n+  register int __flags __asm__(\"a2\") = flags;\n+  register void *__arg __asm__(\"a3\") = arg;\n+  register int *__ptid __asm__(\"a4\") = parent_tidptr;\n+  register void *__tls __asm__(\"a5\") = newtls;\n+  register int *__ctid __asm__(\"a6\") = child_tidptr;\n+\n+  __asm__ __volatile__(\n+      \"mv a0,a2\\n\"          /* flags  */\n+      \"mv a2,a4\\n\"          /* ptid  */\n+      \"mv a3,a5\\n\"          /* tls  */\n+      \"mv a4,a6\\n\"          /* ctid  */\n+      \"addi a7, zero, %9\\n\" /* clone  */\n+\n+      \"ecall\\n\"\n+\n+      /* if (%r0 != 0)\n+       *   return %r0;\n+       */\n+      \"bnez a0, 1f\\n\"\n+\n+      /* In the child, now. Call \"fn(arg)\". */\n+      \"ld  a0,  8(sp)\\n\"\n+      \"ld  a1, 16(sp)\\n\"\n+      \"jalr a1\\n\"\n+\n+      /* Call _exit(%r0).  */\n+      \"addi  a7, zero, %10\\n\"\n+      \"ecall\\n\"\n+      \"1:\\n\"\n+\n+      : \"=r\"(res)\n+      : \"i\"(-EINVAL), \"r\"(__fn), \"r\"(__stack), \"r\"(__flags), \"r\"(__arg),\n+        \"r\"(__ptid), \"r\"(__tls), \"r\"(__ctid), \"i\"(__NR_clone), \"i\"(__NR_exit)\n+      : \"ra\", \"memory\");\n+  return res;\n+}\n #elif defined(__aarch64__)\n uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n                     int *parent_tidptr, void *newtls, int *child_tidptr) {\n@@ -2211,7 +2287,7 @@ void CheckNoDeepBind(const char *filename, int flag) {\n   if (flag & RTLD_DEEPBIND) {\n     Report(\n         \"You are trying to dlopen a %s shared library with RTLD_DEEPBIND flag\"\n-        \" which is incompatibe with sanitizer runtime \"\n+        \" which is incompatible with sanitizer runtime \"\n         \"(see https://github.com/google/sanitizers/issues/611 for details\"\n         \"). If you want to run %s library under sanitizers please remove \"\n         \"RTLD_DEEPBIND from dlopen flags.\\n\","}, {"sha": "a8625ca86e8d00db9d6f7c6b40fed60613657f34", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -60,9 +60,9 @@ uptr internal_prctl(int option, uptr arg2, uptr arg3, uptr arg4, uptr arg5);\n // internal_sigaction instead.\n int internal_sigaction_norestorer(int signum, const void *act, void *oldact);\n void internal_sigdelset(__sanitizer_sigset_t *set, int signum);\n-#if defined(__x86_64__) || defined(__mips__) || defined(__aarch64__) \\\n-  || defined(__powerpc64__) || defined(__s390__) || defined(__i386__) \\\n-  || defined(__arm__)\n+#if defined(__x86_64__) || defined(__mips__) || defined(__aarch64__) || \\\n+    defined(__powerpc64__) || defined(__s390__) || defined(__i386__) || \\\n+    defined(__arm__) || SANITIZER_RISCV64\n uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n                     int *parent_tidptr, void *newtls, int *child_tidptr);\n #endif\n@@ -109,7 +109,7 @@ void ForEachMappedRegion(link_map *map, void (*cb)(const void *, uptr));\n // Releases memory pages entirely within the [beg, end] address range.\n // The pages no longer count toward RSS; reads are guaranteed to return 0.\n // Requires (but does not verify!) that pages are MAP_PRIVATE.\n-INLINE void ReleaseMemoryPagesToOSAndZeroFill(uptr beg, uptr end) {\n+inline void ReleaseMemoryPagesToOSAndZeroFill(uptr beg, uptr end) {\n   // man madvise on Linux promises zero-fill for anonymous private pages.\n   // Testing shows the same behaviour for private (but not anonymous) mappings\n   // of shm_open() files, as long as the underlying file is untouched."}, {"sha": "b8b999363ff26d0fa396f9c13009c4dda46ec487", "filename": "libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cpp", "status": "modified", "additions": 113, "deletions": 49, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -13,7 +13,7 @@\n \n #include \"sanitizer_platform.h\"\n \n-#if SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_NETBSD ||                \\\n+#if SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_NETBSD || \\\n     SANITIZER_OPENBSD || SANITIZER_SOLARIS\n \n #include \"sanitizer_allocator_internal.h\"\n@@ -28,6 +28,10 @@\n #include \"sanitizer_placement_new.h\"\n #include \"sanitizer_procmaps.h\"\n \n+#if SANITIZER_NETBSD\n+#define _RTLD_SOURCE  // for __lwp_gettcb_fast() / __lwp_getprivate_fast()\n+#endif\n+\n #include <dlfcn.h>  // for dlsym()\n #include <link.h>\n #include <pthread.h>\n@@ -149,7 +153,7 @@ void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n   CHECK_EQ(pthread_getattr_np(pthread_self(), &attr), 0);\n   my_pthread_attr_getstack(&attr, &stackaddr, &stacksize);\n   pthread_attr_destroy(&attr);\n-#endif // SANITIZER_SOLARIS\n+#endif  // SANITIZER_SOLARIS\n \n   *stack_top = (uptr)stackaddr + stacksize;\n   *stack_bottom = (uptr)stackaddr;\n@@ -189,20 +193,20 @@ __attribute__((unused)) static bool GetLibcVersion(int *major, int *minor,\n #endif\n }\n \n-#if !SANITIZER_FREEBSD && !SANITIZER_ANDROID && !SANITIZER_GO &&               \\\n+#if !SANITIZER_FREEBSD && !SANITIZER_ANDROID && !SANITIZER_GO && \\\n     !SANITIZER_NETBSD && !SANITIZER_OPENBSD && !SANITIZER_SOLARIS\n static uptr g_tls_size;\n \n #ifdef __i386__\n-# define CHECK_GET_TLS_STATIC_INFO_VERSION (!__GLIBC_PREREQ(2, 27))\n+#define CHECK_GET_TLS_STATIC_INFO_VERSION (!__GLIBC_PREREQ(2, 27))\n #else\n-# define CHECK_GET_TLS_STATIC_INFO_VERSION 0\n+#define CHECK_GET_TLS_STATIC_INFO_VERSION 0\n #endif\n \n #if CHECK_GET_TLS_STATIC_INFO_VERSION\n-# define DL_INTERNAL_FUNCTION __attribute__((regparm(3), stdcall))\n+#define DL_INTERNAL_FUNCTION __attribute__((regparm(3), stdcall))\n #else\n-# define DL_INTERNAL_FUNCTION\n+#define DL_INTERNAL_FUNCTION\n #endif\n \n namespace {\n@@ -262,12 +266,11 @@ void InitTlsSize() {\n }\n #else\n void InitTlsSize() { }\n-#endif  // !SANITIZER_FREEBSD && !SANITIZER_ANDROID && !SANITIZER_GO &&\n-        // !SANITIZER_NETBSD && !SANITIZER_SOLARIS\n+#endif\n \n-#if (defined(__x86_64__) || defined(__i386__) || defined(__mips__) ||          \\\n-     defined(__aarch64__) || defined(__powerpc64__) || defined(__s390__) ||    \\\n-     defined(__arm__)) &&                                                      \\\n+#if (defined(__x86_64__) || defined(__i386__) || defined(__mips__) ||       \\\n+     defined(__aarch64__) || defined(__powerpc64__) || defined(__s390__) || \\\n+     defined(__arm__) || SANITIZER_RISCV64) &&                              \\\n     SANITIZER_LINUX && !SANITIZER_ANDROID\n // sizeof(struct pthread) from glibc.\n static atomic_uintptr_t thread_descriptor_size;\n@@ -307,6 +310,21 @@ uptr ThreadDescriptorSize() {\n #elif defined(__mips__)\n   // TODO(sagarthakur): add more values as per different glibc versions.\n   val = FIRST_32_SECOND_64(1152, 1776);\n+#elif SANITIZER_RISCV64\n+  int major;\n+  int minor;\n+  int patch;\n+  if (GetLibcVersion(&major, &minor, &patch) && major == 2) {\n+    // TODO: consider adding an optional runtime check for an unknown (untested)\n+    // glibc version\n+    if (minor <= 28)  // WARNING: the highest tested version is 2.29\n+      val = 1772;     // no guarantees for this one\n+    else if (minor <= 31)\n+      val = 1772;  // tested against glibc 2.29, 2.31\n+    else\n+      val = 1936;  // tested against glibc 2.32\n+  }\n+\n #elif defined(__aarch64__)\n   // The sizeof (struct pthread) is the same from GLIBC 2.17 to 2.22.\n   val = 1776;\n@@ -327,15 +345,17 @@ uptr ThreadSelfOffset() {\n   return kThreadSelfOffset;\n }\n \n-#if defined(__mips__) || defined(__powerpc64__)\n+#if defined(__mips__) || defined(__powerpc64__) || SANITIZER_RISCV64\n // TlsPreTcbSize includes size of struct pthread_descr and size of tcb\n // head structure. It lies before the static tls blocks.\n static uptr TlsPreTcbSize() {\n-# if defined(__mips__)\n+#if defined(__mips__)\n   const uptr kTcbHead = 16; // sizeof (tcbhead_t)\n-# elif defined(__powerpc64__)\n+#elif defined(__powerpc64__)\n   const uptr kTcbHead = 88; // sizeof (tcbhead_t)\n-# endif\n+#elif SANITIZER_RISCV64\n+  const uptr kTcbHead = 16;  // sizeof (tcbhead_t)\n+#endif\n   const uptr kTlsAlign = 16;\n   const uptr kTlsPreTcbSize =\n       RoundUpTo(ThreadDescriptorSize() + kTcbHead, kTlsAlign);\n@@ -345,11 +365,11 @@ static uptr TlsPreTcbSize() {\n \n uptr ThreadSelf() {\n   uptr descr_addr;\n-# if defined(__i386__)\n+#if defined(__i386__)\n   asm(\"mov %%gs:%c1,%0\" : \"=r\"(descr_addr) : \"i\"(kThreadSelfOffset));\n-# elif defined(__x86_64__)\n+#elif defined(__x86_64__)\n   asm(\"mov %%fs:%c1,%0\" : \"=r\"(descr_addr) : \"i\"(kThreadSelfOffset));\n-# elif defined(__mips__)\n+#elif defined(__mips__)\n   // MIPS uses TLS variant I. The thread pointer (in hardware register $29)\n   // points to the end of the TCB + 0x7000. The pthread_descr structure is\n   // immediately in front of the TCB. TlsPreTcbSize() includes the size of the\n@@ -361,12 +381,19 @@ uptr ThreadSelf() {\n                 rdhwr %0,$29;\\\n                 .set pop\" : \"=r\" (thread_pointer));\n   descr_addr = thread_pointer - kTlsTcbOffset - TlsPreTcbSize();\n-# elif defined(__aarch64__) || defined(__arm__)\n+#elif defined(__aarch64__) || defined(__arm__)\n   descr_addr = reinterpret_cast<uptr>(__builtin_thread_pointer()) -\n                                       ThreadDescriptorSize();\n-# elif defined(__s390__)\n+#elif SANITIZER_RISCV64\n+  uptr tcb_end;\n+  asm volatile(\"mv %0, tp;\\n\" : \"=r\"(tcb_end));\n+  // https://github.com/riscv/riscv-elf-psabi-doc/issues/53\n+  const uptr kTlsTcbOffset = 0x800;\n+  descr_addr =\n+      reinterpret_cast<uptr>(tcb_end - kTlsTcbOffset - TlsPreTcbSize());\n+#elif defined(__s390__)\n   descr_addr = reinterpret_cast<uptr>(__builtin_thread_pointer());\n-# elif defined(__powerpc64__)\n+#elif defined(__powerpc64__)\n   // PPC64LE uses TLS variant I. The thread pointer (in GPR 13)\n   // points to the end of the TCB + 0x7000. The pthread_descr structure is\n   // immediately in front of the TCB. TlsPreTcbSize() includes the size of the\n@@ -375,25 +402,25 @@ uptr ThreadSelf() {\n   uptr thread_pointer;\n   asm(\"addi %0,13,%1\" : \"=r\"(thread_pointer) : \"I\"(-kTlsTcbOffset));\n   descr_addr = thread_pointer - TlsPreTcbSize();\n-# else\n-#  error \"unsupported CPU arch\"\n-# endif\n+#else\n+#error \"unsupported CPU arch\"\n+#endif\n   return descr_addr;\n }\n #endif  // (x86_64 || i386 || MIPS) && SANITIZER_LINUX\n \n #if SANITIZER_FREEBSD\n static void **ThreadSelfSegbase() {\n   void **segbase = 0;\n-# if defined(__i386__)\n+#if defined(__i386__)\n   // sysarch(I386_GET_GSBASE, segbase);\n   __asm __volatile(\"mov %%gs:0, %0\" : \"=r\" (segbase));\n-# elif defined(__x86_64__)\n+#elif defined(__x86_64__)\n   // sysarch(AMD64_GET_FSBASE, segbase);\n   __asm __volatile(\"movq %%fs:0, %0\" : \"=r\" (segbase));\n-# else\n-#  error \"unsupported CPU arch\"\n-# endif\n+#else\n+#error \"unsupported CPU arch\"\n+#endif\n   return segbase;\n }\n \n@@ -404,7 +431,13 @@ uptr ThreadSelf() {\n \n #if SANITIZER_NETBSD\n static struct tls_tcb * ThreadSelfTlsTcb() {\n-  return (struct tls_tcb *)_lwp_getprivate();\n+  struct tls_tcb *tcb = nullptr;\n+#ifdef __HAVE___LWP_GETTCB_FAST\n+  tcb = (struct tls_tcb *)__lwp_gettcb_fast();\n+#elif defined(__HAVE___LWP_GETPRIVATE_FAST)\n+  tcb = (struct tls_tcb *)__lwp_getprivate_fast();\n+#endif\n+  return tcb;\n }\n \n uptr ThreadSelf() {\n@@ -428,19 +461,19 @@ int GetSizeFromHdr(struct dl_phdr_info *info, size_t size, void *data) {\n #if !SANITIZER_GO\n static void GetTls(uptr *addr, uptr *size) {\n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n-# if defined(__x86_64__) || defined(__i386__) || defined(__s390__)\n+#if defined(__x86_64__) || defined(__i386__) || defined(__s390__)\n   *addr = ThreadSelf();\n   *size = GetTlsSize();\n   *addr -= *size;\n   *addr += ThreadDescriptorSize();\n-# elif defined(__mips__) || defined(__aarch64__) || defined(__powerpc64__) \\\n-    || defined(__arm__)\n+#elif defined(__mips__) || defined(__aarch64__) || defined(__powerpc64__) || \\\n+    defined(__arm__) || SANITIZER_RISCV64\n   *addr = ThreadSelf();\n   *size = GetTlsSize();\n-# else\n+#else\n   *addr = 0;\n   *size = 0;\n-# endif\n+#endif\n #elif SANITIZER_FREEBSD\n   void** segbase = ThreadSelfSegbase();\n   *addr = 0;\n@@ -479,19 +512,19 @@ static void GetTls(uptr *addr, uptr *size) {\n   *addr = 0;\n   *size = 0;\n #else\n-# error \"Unknown OS\"\n+#error \"Unknown OS\"\n #endif\n }\n #endif\n \n #if !SANITIZER_GO\n uptr GetTlsSize() {\n-#if SANITIZER_FREEBSD || SANITIZER_ANDROID || SANITIZER_NETBSD ||              \\\n+#if SANITIZER_FREEBSD || SANITIZER_ANDROID || SANITIZER_NETBSD || \\\n     SANITIZER_OPENBSD || SANITIZER_SOLARIS\n   uptr addr, size;\n   GetTls(&addr, &size);\n   return size;\n-#elif defined(__mips__) || defined(__powerpc64__)\n+#elif defined(__mips__) || defined(__powerpc64__) || SANITIZER_RISCV64\n   return RoundUpTo(g_tls_size + TlsPreTcbSize(), 16);\n #else\n   return g_tls_size;\n@@ -526,11 +559,11 @@ void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n \n #if !SANITIZER_FREEBSD && !SANITIZER_OPENBSD\n typedef ElfW(Phdr) Elf_Phdr;\n-#elif SANITIZER_WORDSIZE == 32 && __FreeBSD_version <= 902001 // v9.2\n+#elif SANITIZER_WORDSIZE == 32 && __FreeBSD_version <= 902001  // v9.2\n #define Elf_Phdr XElf32_Phdr\n #define dl_phdr_info xdl_phdr_info\n #define dl_iterate_phdr(c, b) xdl_iterate_phdr((c), (b))\n-#endif // !SANITIZER_FREEBSD && !SANITIZER_OPENBSD\n+#endif  // !SANITIZER_FREEBSD && !SANITIZER_OPENBSD\n \n struct DlIteratePhdrData {\n   InternalMmapVectorNoCtor<LoadedModule> *modules;\n@@ -697,19 +730,15 @@ u32 GetNumberOfCPUs() {\n #elif SANITIZER_SOLARIS\n   return sysconf(_SC_NPROCESSORS_ONLN);\n #else\n-#if defined(CPU_COUNT)\n   cpu_set_t CPUs;\n   CHECK_EQ(sched_getaffinity(0, sizeof(cpu_set_t), &CPUs), 0);\n   return CPU_COUNT(&CPUs);\n-#else\n-  return 1;\n-#endif\n #endif\n }\n \n #if SANITIZER_LINUX\n \n-# if SANITIZER_ANDROID\n+#if SANITIZER_ANDROID\n static atomic_uint8_t android_log_initialized;\n \n void AndroidLogInit() {\n@@ -753,15 +782,15 @@ void SetAbortMessage(const char *str) {\n   if (&android_set_abort_message)\n     android_set_abort_message(str);\n }\n-# else\n+#else\n void AndroidLogInit() {}\n \n static bool ShouldLogAfterPrintf() { return true; }\n \n void WriteOneLineToSyslog(const char *s) { syslog(LOG_INFO, \"%s\", s); }\n \n void SetAbortMessage(const char *str) {}\n-# endif  // SANITIZER_ANDROID\n+#endif  // SANITIZER_ANDROID\n \n void LogMessageOnPrintf(const char *str) {\n   if (common_flags()->log_to_syslog && ShouldLogAfterPrintf())\n@@ -776,7 +805,7 @@ void LogMessageOnPrintf(const char *str) {\n // initialized after the vDSO function pointers, so if it exists, is not null\n // and is not empty, we can use clock_gettime.\n extern \"C\" SANITIZER_WEAK_ATTRIBUTE char *__progname;\n-INLINE bool CanUseVDSO() {\n+inline bool CanUseVDSO() {\n   // Bionic is safe, it checks for the vDSO function pointers to be initialized.\n   if (SANITIZER_ANDROID)\n     return true;\n@@ -845,6 +874,41 @@ void ReExec() {\n }\n #endif  // !SANITIZER_OPENBSD\n \n+void UnmapFromTo(uptr from, uptr to) {\n+  if (to == from)\n+    return;\n+  CHECK(to >= from);\n+  uptr res = internal_munmap(reinterpret_cast<void *>(from), to - from);\n+  if (UNLIKELY(internal_iserror(res))) {\n+    Report(\"ERROR: %s failed to unmap 0x%zx (%zd) bytes at address %p\\n\",\n+           SanitizerToolName, to - from, to - from, (void *)from);\n+    CHECK(\"unable to unmap\" && 0);\n+  }\n+}\n+\n+uptr MapDynamicShadow(uptr shadow_size_bytes, uptr shadow_scale,\n+                      uptr min_shadow_base_alignment,\n+                      UNUSED uptr &high_mem_end) {\n+  const uptr granularity = GetMmapGranularity();\n+  const uptr alignment =\n+      Max<uptr>(granularity << shadow_scale, 1ULL << min_shadow_base_alignment);\n+  const uptr left_padding =\n+      Max<uptr>(granularity, 1ULL << min_shadow_base_alignment);\n+\n+  const uptr shadow_size = RoundUpTo(shadow_size_bytes, granularity);\n+  const uptr map_size = shadow_size + left_padding + alignment;\n+\n+  const uptr map_start = (uptr)MmapNoAccess(map_size);\n+  CHECK_NE(map_start, ~(uptr)0);\n+\n+  const uptr shadow_start = RoundUpTo(map_start + left_padding, alignment);\n+\n+  UnmapFromTo(map_start, shadow_start - left_padding);\n+  UnmapFromTo(shadow_start + shadow_size, map_start + map_size);\n+\n+  return shadow_start;\n+}\n+\n } // namespace __sanitizer\n \n #endif"}, {"sha": "b1271120c0041382ce22304779601308b64b55ca", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.cpp", "status": "modified", "additions": 165, "deletions": 67, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -27,7 +27,6 @@\n #include \"sanitizer_flags.h\"\n #include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_libc.h\"\n-#include \"sanitizer_placement_new.h\"\n #include \"sanitizer_platform_limits_posix.h\"\n #include \"sanitizer_procmaps.h\"\n #include \"sanitizer_ptrauth.h\"\n@@ -38,7 +37,7 @@\n extern char **environ;\n #endif\n \n-#if defined(__has_include) && __has_include(<os/trace.h>) && defined(__BLOCKS__)\n+#if defined(__has_include) && __has_include(<os/trace.h>)\n #define SANITIZER_OS_TRACE 1\n #include <os/trace.h>\n #else\n@@ -138,6 +137,10 @@ int internal_mprotect(void *addr, uptr length, int prot) {\n   return mprotect(addr, length, prot);\n }\n \n+int internal_madvise(uptr addr, uptr length, int advice) {\n+  return madvise((void *)addr, length, advice);\n+}\n+\n uptr internal_close(fd_t fd) {\n   return close(fd);\n }\n@@ -388,7 +391,7 @@ void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n   // pthread_get_stacksize_np() returns an incorrect stack size for the main\n   // thread on Mavericks. See\n   // https://github.com/google/sanitizers/issues/261\n-  if ((GetMacosVersion() >= MACOS_VERSION_MAVERICKS) && at_initialization &&\n+  if ((GetMacosAlignedVersion() >= MacosVersion(10, 9)) && at_initialization &&\n       stacksize == (1 << 19))  {\n     struct rlimit rl;\n     CHECK_EQ(getrlimit(RLIMIT_STACK, &rl), 0);\n@@ -607,68 +610,111 @@ HandleSignalMode GetHandleSignalMode(int signum) {\n   return result;\n }\n \n-MacosVersion cached_macos_version = MACOS_VERSION_UNINITIALIZED;\n+// Offset example:\n+// XNU 17 -- macOS 10.13 -- iOS 11 -- tvOS 11 -- watchOS 4\n+constexpr u16 GetOSMajorKernelOffset() {\n+  if (TARGET_OS_OSX) return 4;\n+  if (TARGET_OS_IOS || TARGET_OS_TV) return 6;\n+  if (TARGET_OS_WATCH) return 13;\n+}\n+\n+using VersStr = char[64];\n \n-MacosVersion GetMacosVersionInternal() {\n-  int mib[2] = { CTL_KERN, KERN_OSRELEASE };\n-  char version[100];\n-  uptr len = 0, maxlen = sizeof(version) / sizeof(version[0]);\n-  for (uptr i = 0; i < maxlen; i++) version[i] = '\\0';\n-  // Get the version length.\n-  CHECK_NE(internal_sysctl(mib, 2, 0, &len, 0, 0), -1);\n-  CHECK_LT(len, maxlen);\n-  CHECK_NE(internal_sysctl(mib, 2, version, &len, 0, 0), -1);\n+static void GetOSVersion(VersStr vers) {\n+  uptr len = sizeof(VersStr);\n+  if (SANITIZER_IOSSIM) {\n+    const char *vers_env = GetEnv(\"SIMULATOR_RUNTIME_VERSION\");\n+    if (!vers_env) {\n+      Report(\"ERROR: Running in simulator but SIMULATOR_RUNTIME_VERSION env \"\n+          \"var is not set.\\n\");\n+      Die();\n+    }\n+    len = internal_strlcpy(vers, vers_env, len);\n+  } else {\n+    int res =\n+        internal_sysctlbyname(\"kern.osproductversion\", vers, &len, nullptr, 0);\n+    if (res) {\n+      // Fallback for XNU 17 (macOS 10.13) and below that do not provide the\n+      // `kern.osproductversion` property.\n+      u16 kernel_major = GetDarwinKernelVersion().major;\n+      u16 offset = GetOSMajorKernelOffset();\n+      CHECK_LE(kernel_major, 17);\n+      CHECK_GE(kernel_major, offset);\n+      u16 os_major = kernel_major - offset;\n+\n+      auto format = TARGET_OS_OSX ? \"10.%d\" : \"%d.0\";\n+      len = internal_snprintf(vers, len, format, os_major);\n+    }\n+  }\n+  CHECK_LT(len, sizeof(VersStr));\n+}\n \n-  // Expect <major>.<minor>(.<patch>)\n-  CHECK_GE(len, 3);\n-  const char *p = version;\n-  int major = internal_simple_strtoll(p, &p, /*base=*/10);\n-  if (*p != '.') return MACOS_VERSION_UNKNOWN;\n+void ParseVersion(const char *vers, u16 *major, u16 *minor) {\n+  // Format: <major>.<minor>[.<patch>]\\0\n+  CHECK_GE(internal_strlen(vers), 3);\n+  const char *p = vers;\n+  *major = internal_simple_strtoll(p, &p, /*base=*/10);\n+  CHECK_EQ(*p, '.');\n   p += 1;\n-  int minor = internal_simple_strtoll(p, &p, /*base=*/10);\n-  if (*p != '.') return MACOS_VERSION_UNKNOWN;\n-\n-  switch (major) {\n-    case 11: return MACOS_VERSION_LION;\n-    case 12: return MACOS_VERSION_MOUNTAIN_LION;\n-    case 13: return MACOS_VERSION_MAVERICKS;\n-    case 14: return MACOS_VERSION_YOSEMITE;\n-    case 15: return MACOS_VERSION_EL_CAPITAN;\n-    case 16: return MACOS_VERSION_SIERRA;\n-    case 17: return MACOS_VERSION_HIGH_SIERRA;\n-    case 18: return MACOS_VERSION_MOJAVE;\n-    case 19: return MACOS_VERSION_CATALINA;\n-    default:\n-      if (major < 9) return MACOS_VERSION_UNKNOWN;\n-      return MACOS_VERSION_UNKNOWN_NEWER;\n+  *minor = internal_simple_strtoll(p, &p, /*base=*/10);\n+}\n+\n+// Aligned versions example:\n+// macOS 10.15 -- iOS 13 -- tvOS 13 -- watchOS 6\n+static void MapToMacos(u16 *major, u16 *minor) {\n+  if (TARGET_OS_OSX)\n+    return;\n+\n+  if (TARGET_OS_IOS || TARGET_OS_TV)\n+    *major += 2;\n+  else if (TARGET_OS_WATCH)\n+    *major += 9;\n+  else\n+    UNREACHABLE(\"unsupported platform\");\n+\n+  if (*major >= 16) {  // macOS 11+\n+    *major -= 5;\n+  } else {  // macOS 10.15 and below\n+    *minor = *major;\n+    *major = 10;\n   }\n }\n \n-MacosVersion GetMacosVersion() {\n-  atomic_uint32_t *cache =\n-      reinterpret_cast<atomic_uint32_t*>(&cached_macos_version);\n-  MacosVersion result =\n-      static_cast<MacosVersion>(atomic_load(cache, memory_order_acquire));\n-  if (result == MACOS_VERSION_UNINITIALIZED) {\n-    result = GetMacosVersionInternal();\n-    atomic_store(cache, result, memory_order_release);\n+static MacosVersion GetMacosAlignedVersionInternal() {\n+  VersStr vers;\n+  GetOSVersion(vers);\n+\n+  u16 major, minor;\n+  ParseVersion(vers, &major, &minor);\n+  MapToMacos(&major, &minor);\n+\n+  return MacosVersion(major, minor);\n+}\n+\n+static_assert(sizeof(MacosVersion) == sizeof(atomic_uint32_t::Type),\n+              \"MacosVersion cache size\");\n+static atomic_uint32_t cached_macos_version;\n+\n+MacosVersion GetMacosAlignedVersion() {\n+  atomic_uint32_t::Type result =\n+      atomic_load(&cached_macos_version, memory_order_acquire);\n+  if (!result) {\n+    MacosVersion version = GetMacosAlignedVersionInternal();\n+    result = *reinterpret_cast<atomic_uint32_t::Type *>(&version);\n+    atomic_store(&cached_macos_version, result, memory_order_release);\n   }\n-  return result;\n+  return *reinterpret_cast<MacosVersion *>(&result);\n }\n \n DarwinKernelVersion GetDarwinKernelVersion() {\n-  char buf[100];\n-  size_t len = sizeof(buf);\n-  int res = internal_sysctlbyname(\"kern.osrelease\", buf, &len, nullptr, 0);\n+  VersStr vers;\n+  uptr len = sizeof(VersStr);\n+  int res = internal_sysctlbyname(\"kern.osrelease\", vers, &len, nullptr, 0);\n   CHECK_EQ(res, 0);\n+  CHECK_LT(len, sizeof(VersStr));\n \n-  // Format: <major>.<minor>.<patch>\\0\n-  CHECK_GE(len, 6);\n-  const char *p = buf;\n-  u16 major = internal_simple_strtoll(p, &p, /*base=*/10);\n-  CHECK_EQ(*p, '.');\n-  p += 1;\n-  u16 minor = internal_simple_strtoll(p, &p, /*base=*/10);\n+  u16 major, minor;\n+  ParseVersion(vers, &major, &minor);\n \n   return DarwinKernelVersion(major, minor);\n }\n@@ -719,7 +765,7 @@ void LogFullErrorReport(const char *buffer) {\n #if !SANITIZER_GO\n   // Log with os_trace. This will make it into the crash log.\n #if SANITIZER_OS_TRACE\n-  if (GetMacosVersion() >= MACOS_VERSION_YOSEMITE) {\n+  if (GetMacosAlignedVersion() >= MacosVersion(10, 10)) {\n     // os_trace requires the message (format parameter) to be a string literal.\n     if (internal_strncmp(SanitizerToolName, \"AddressSanitizer\",\n                          sizeof(\"AddressSanitizer\") - 1) == 0)\n@@ -808,6 +854,19 @@ void SignalContext::InitPcSpBp() {\n   GetPcSpBp(context, &pc, &sp, &bp);\n }\n \n+// ASan/TSan use mmap in a way that creates \u201cdeallocation gaps\u201d which triggers\n+// EXC_GUARD exceptions on macOS 10.15+ (XNU 19.0+).\n+static void DisableMmapExcGuardExceptions() {\n+  using task_exc_guard_behavior_t = uint32_t;\n+  using task_set_exc_guard_behavior_t =\n+      kern_return_t(task_t task, task_exc_guard_behavior_t behavior);\n+  auto *set_behavior = (task_set_exc_guard_behavior_t *)dlsym(\n+      RTLD_DEFAULT, \"task_set_exc_guard_behavior\");\n+  if (set_behavior == nullptr) return;\n+  const task_exc_guard_behavior_t task_exc_guard_none = 0;\n+  set_behavior(mach_task_self(), task_exc_guard_none);\n+}\n+\n void InitializePlatformEarly() {\n   // Only use xnu_fast_mmap when on x86_64 and the kernel supports it.\n   use_xnu_fast_mmap =\n@@ -816,6 +875,8 @@ void InitializePlatformEarly() {\n #else\n       false;\n #endif\n+  if (GetDarwinKernelVersion() >= DarwinKernelVersion(19, 0))\n+    DisableMmapExcGuardExceptions();\n }\n \n #if !SANITIZER_GO\n@@ -856,20 +917,10 @@ bool ReexecDisabled() {\n   return false;\n }\n \n-extern \"C\" SANITIZER_WEAK_ATTRIBUTE double dyldVersionNumber;\n-static const double kMinDyldVersionWithAutoInterposition = 360.0;\n-\n-bool DyldNeedsEnvVariable() {\n-  // Although sanitizer support was added to LLVM on OS X 10.7+, GCC users\n-  // still may want use them on older systems. On older Darwin platforms, dyld\n-  // doesn't export dyldVersionNumber symbol and we simply return true.\n-  if (!&dyldVersionNumber) return true;\n+static bool DyldNeedsEnvVariable() {\n   // If running on OS X 10.11+ or iOS 9.0+, dyld will interpose even if\n-  // DYLD_INSERT_LIBRARIES is not set. However, checking OS version via\n-  // GetMacosVersion() doesn't work for the simulator. Let's instead check\n-  // `dyldVersionNumber`, which is exported by dyld, against a known version\n-  // number from the first OS release where this appeared.\n-  return dyldVersionNumber < kMinDyldVersionWithAutoInterposition;\n+  // DYLD_INSERT_LIBRARIES is not set.\n+  return GetMacosAlignedVersion() < MacosVersion(10, 11);\n }\n \n void MaybeReexec() {\n@@ -1082,6 +1133,53 @@ uptr GetMaxVirtualAddress() {\n   return GetMaxUserVirtualAddress();\n }\n \n+uptr MapDynamicShadow(uptr shadow_size_bytes, uptr shadow_scale,\n+                      uptr min_shadow_base_alignment, uptr &high_mem_end) {\n+  const uptr granularity = GetMmapGranularity();\n+  const uptr alignment =\n+      Max<uptr>(granularity << shadow_scale, 1ULL << min_shadow_base_alignment);\n+  const uptr left_padding =\n+      Max<uptr>(granularity, 1ULL << min_shadow_base_alignment);\n+\n+  uptr space_size = shadow_size_bytes + left_padding;\n+\n+  uptr largest_gap_found = 0;\n+  uptr max_occupied_addr = 0;\n+  VReport(2, \"FindDynamicShadowStart, space_size = %p\\n\", space_size);\n+  uptr shadow_start =\n+      FindAvailableMemoryRange(space_size, alignment, granularity,\n+                               &largest_gap_found, &max_occupied_addr);\n+  // If the shadow doesn't fit, restrict the address space to make it fit.\n+  if (shadow_start == 0) {\n+    VReport(\n+        2,\n+        \"Shadow doesn't fit, largest_gap_found = %p, max_occupied_addr = %p\\n\",\n+        largest_gap_found, max_occupied_addr);\n+    uptr new_max_vm = RoundDownTo(largest_gap_found << shadow_scale, alignment);\n+    if (new_max_vm < max_occupied_addr) {\n+      Report(\"Unable to find a memory range for dynamic shadow.\\n\");\n+      Report(\n+          \"space_size = %p, largest_gap_found = %p, max_occupied_addr = %p, \"\n+          \"new_max_vm = %p\\n\",\n+          space_size, largest_gap_found, max_occupied_addr, new_max_vm);\n+      CHECK(0 && \"cannot place shadow\");\n+    }\n+    RestrictMemoryToMaxAddress(new_max_vm);\n+    high_mem_end = new_max_vm - 1;\n+    space_size = (high_mem_end >> shadow_scale) + left_padding;\n+    VReport(2, \"FindDynamicShadowStart, space_size = %p\\n\", space_size);\n+    shadow_start = FindAvailableMemoryRange(space_size, alignment, granularity,\n+                                            nullptr, nullptr);\n+    if (shadow_start == 0) {\n+      Report(\"Unable to find a memory range after restricting VM.\\n\");\n+      CHECK(0 && \"cannot place shadow after restricting vm\");\n+    }\n+  }\n+  CHECK_NE((uptr)0, shadow_start);\n+  CHECK(IsAligned(shadow_start, alignment));\n+  return shadow_start;\n+}\n+\n uptr FindAvailableMemoryRange(uptr size, uptr alignment, uptr left_padding,\n                               uptr *largest_gap_found,\n                               uptr *max_occupied_addr) {"}, {"sha": "023071e4f11de73d6d6c3361ece16ae6430a5aab", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.h", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -30,37 +30,32 @@ struct MemoryMappingLayoutData {\n   bool current_instrumented;\n };\n \n-enum MacosVersion {\n-  MACOS_VERSION_UNINITIALIZED = 0,\n-  MACOS_VERSION_UNKNOWN,\n-  MACOS_VERSION_LION,  // macOS 10.7; oldest currently supported\n-  MACOS_VERSION_MOUNTAIN_LION,\n-  MACOS_VERSION_MAVERICKS,\n-  MACOS_VERSION_YOSEMITE,\n-  MACOS_VERSION_EL_CAPITAN,\n-  MACOS_VERSION_SIERRA,\n-  MACOS_VERSION_HIGH_SIERRA,\n-  MACOS_VERSION_MOJAVE,\n-  MACOS_VERSION_CATALINA,\n-  MACOS_VERSION_UNKNOWN_NEWER\n-};\n-\n-struct DarwinKernelVersion {\n+template <typename VersionType>\n+struct VersionBase {\n   u16 major;\n   u16 minor;\n \n-  DarwinKernelVersion(u16 major, u16 minor) : major(major), minor(minor) {}\n+  VersionBase(u16 major, u16 minor) : major(major), minor(minor) {}\n \n-  bool operator==(const DarwinKernelVersion &other) const {\n+  bool operator==(const VersionType &other) const {\n     return major == other.major && minor == other.minor;\n   }\n-  bool operator>=(const DarwinKernelVersion &other) const {\n-    return major >= other.major ||\n+  bool operator>=(const VersionType &other) const {\n+    return major > other.major ||\n            (major == other.major && minor >= other.minor);\n   }\n+  bool operator<(const VersionType &other) const { return !(*this >= other); }\n+};\n+\n+struct MacosVersion : VersionBase<MacosVersion> {\n+  MacosVersion(u16 major, u16 minor) : VersionBase(major, minor) {}\n+};\n+\n+struct DarwinKernelVersion : VersionBase<DarwinKernelVersion> {\n+  DarwinKernelVersion(u16 major, u16 minor) : VersionBase(major, minor) {}\n };\n \n-MacosVersion GetMacosVersion();\n+MacosVersion GetMacosAlignedVersion();\n DarwinKernelVersion GetDarwinKernelVersion();\n \n char **GetEnviron();\n@@ -80,7 +75,7 @@ asm(\".desc ___crashreporter_info__, 0x10\");\n namespace __sanitizer {\n static BlockingMutex crashreporter_info_mutex(LINKER_INITIALIZED);\n \n-INLINE void CRAppendCrashLogMessage(const char *msg) {\n+inline void CRAppendCrashLogMessage(const char *msg) {\n   BlockingMutexLock l(&crashreporter_info_mutex);\n   internal_strlcat(__crashreporter_info_buff__, msg,\n                    sizeof(__crashreporter_info_buff__)); }"}, {"sha": "98ac7365da051d13a4169dfc68e0f635101d2e12", "filename": "libsanitizer/sanitizer_common/sanitizer_netbsd.cpp", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_netbsd.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_netbsd.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_netbsd.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -110,6 +110,11 @@ int internal_mprotect(void *addr, uptr length, int prot) {\n   return _REAL(mprotect, addr, length, prot);\n }\n \n+int internal_madvise(uptr addr, uptr length, int advice) {\n+  DEFINE__REAL(int, madvise, void *a, uptr b, int c);\n+  return _REAL(madvise, (void *)addr, length, advice);\n+}\n+\n uptr internal_close(fd_t fd) {\n   CHECK(&_sys_close);\n   return _sys_close(fd);"}, {"sha": "195901714b1935ced6fdba8b928723c703e14428", "filename": "libsanitizer/sanitizer_common/sanitizer_openbsd.cpp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_openbsd.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_openbsd.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_openbsd.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -52,6 +52,10 @@ int internal_mprotect(void *addr, uptr length, int prot) {\n   return mprotect(addr, length, prot);\n }\n \n+int internal_madvise(uptr addr, uptr length, int advice) {\n+  return madvise((void *)addr, length, advice);\n+}\n+\n int internal_sysctlbyname(const char *sname, void *oldp, uptr *oldlenp,\n                           const void *newp, uptr newlen) {\n   Printf(\"internal_sysctlbyname not implemented for OpenBSD\");"}, {"sha": "5547c68bc51708c4530387e1c74c732b2ae59b81", "filename": "libsanitizer/sanitizer_common/sanitizer_platform.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -132,6 +132,12 @@\n # define SANITIZER_X32 0\n #endif\n \n+#if defined(__i386__) || defined(_M_IX86)\n+# define SANITIZER_I386 1\n+#else\n+# define SANITIZER_I386 0\n+#endif\n+\n #if defined(__mips__)\n # define SANITIZER_MIPS 1\n # if defined(__mips64)\n@@ -213,6 +219,12 @@\n # define SANITIZER_MYRIAD2 0\n #endif\n \n+#if defined(__riscv) && (__riscv_xlen == 64)\n+#define SANITIZER_RISCV64 1\n+#else\n+#define SANITIZER_RISCV64 0\n+#endif\n+\n // By default we allow to use SizeClassAllocator64 on 64-bit platform.\n // But in some cases (e.g. AArch64's 39-bit address space) SizeClassAllocator64\n // does not work well and we need to fallback to SizeClassAllocator32.\n@@ -233,6 +245,8 @@\n // will still work but will consume more memory for TwoLevelByteMap.\n #if defined(__mips__)\n # define SANITIZER_MMAP_RANGE_SIZE FIRST_32_SECOND_64(1ULL << 32, 1ULL << 40)\n+#elif SANITIZER_RISCV64\n+#define SANITIZER_MMAP_RANGE_SIZE FIRST_32_SECOND_64(1ULL << 32, 1ULL << 38)\n #elif defined(__aarch64__)\n # if SANITIZER_MAC\n // Darwin iOS/ARM64 has a 36-bit VMA, 64GiB VM"}, {"sha": "37f178a6f5738c0e0277c5a6785737582b29bd5a", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_interceptors.h", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -15,6 +15,7 @@\n \n #include \"sanitizer_glibc_version.h\"\n #include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_platform.h\"\n \n #if SANITIZER_POSIX\n # define SI_POSIX 1\n@@ -240,6 +241,7 @@\n   (SI_MAC || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_CLOCK_GETTIME \\\n   (SI_FREEBSD || SI_NETBSD || SI_OPENBSD || SI_LINUX || SI_SOLARIS)\n+#define SANITIZER_INTERCEPT_CLOCK_GETCPUCLOCKID SI_LINUX\n #define SANITIZER_INTERCEPT_GETITIMER SI_POSIX\n #define SANITIZER_INTERCEPT_TIME SI_POSIX\n #define SANITIZER_INTERCEPT_GLOB SI_LINUX_NOT_ANDROID || SI_SOLARIS\n@@ -270,16 +272,17 @@\n #define SANITIZER_INTERCEPT_SENDMSG SI_POSIX\n #define SANITIZER_INTERCEPT_RECVMMSG SI_LINUX\n #define SANITIZER_INTERCEPT_SENDMMSG SI_LINUX\n+#define SANITIZER_INTERCEPT_SYSMSG SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_GETPEERNAME SI_POSIX\n #define SANITIZER_INTERCEPT_IOCTL SI_POSIX\n #define SANITIZER_INTERCEPT_INET_ATON SI_POSIX\n #define SANITIZER_INTERCEPT_SYSINFO SI_LINUX\n #define SANITIZER_INTERCEPT_READDIR SI_POSIX\n #define SANITIZER_INTERCEPT_READDIR64 SI_LINUX_NOT_ANDROID || SI_SOLARIS32\n-#if SI_LINUX_NOT_ANDROID && \\\n-  (defined(__i386) || defined(__x86_64) || defined(__mips64) || \\\n-    defined(__powerpc64__) || defined(__aarch64__) || defined(__arm__) || \\\n-    defined(__s390__))\n+#if SI_LINUX_NOT_ANDROID &&                                                \\\n+    (defined(__i386) || defined(__x86_64) || defined(__mips64) ||          \\\n+     defined(__powerpc64__) || defined(__aarch64__) || defined(__arm__) || \\\n+     defined(__s390__) || SANITIZER_RISCV64)\n #define SANITIZER_INTERCEPT_PTRACE 1\n #else\n #define SANITIZER_INTERCEPT_PTRACE 0\n@@ -331,6 +334,7 @@\n #define SANITIZER_INTERCEPT_SIGTIMEDWAIT SI_LINUX_NOT_ANDROID || SI_SOLARIS\n #define SANITIZER_INTERCEPT_SIGSETOPS \\\n   (SI_FREEBSD || SI_NETBSD || SI_MAC || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n+#define SANITIZER_INTERCEPT_SIGSET_LOGICOPS SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_SIGPENDING SI_POSIX\n #define SANITIZER_INTERCEPT_SIGPROCMASK SI_POSIX\n #define SANITIZER_INTERCEPT_PTHREAD_SIGMASK SI_POSIX\n@@ -341,7 +345,7 @@\n #define SANITIZER_INTERCEPT_STATFS \\\n   (SI_FREEBSD || SI_MAC || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_STATFS64 \\\n-  ((SI_MAC && !SI_IOS) || SI_LINUX_NOT_ANDROID)\n+  (((SI_MAC && !TARGET_CPU_ARM64) && !SI_IOS) || SI_LINUX_NOT_ANDROID)\n #define SANITIZER_INTERCEPT_STATVFS \\\n   (SI_FREEBSD || SI_NETBSD || SI_OPENBSD || SI_LINUX_NOT_ANDROID)\n #define SANITIZER_INTERCEPT_STATVFS64 SI_LINUX_NOT_ANDROID\n@@ -381,6 +385,8 @@\n #define SANITIZER_INTERCEPT_THR_EXIT SI_FREEBSD\n #define SANITIZER_INTERCEPT_TMPNAM SI_POSIX\n #define SANITIZER_INTERCEPT_TMPNAM_R SI_LINUX_NOT_ANDROID || SI_SOLARIS\n+#define SANITIZER_INTERCEPT_PTSNAME SI_LINUX\n+#define SANITIZER_INTERCEPT_PTSNAME_R SI_LINUX\n #define SANITIZER_INTERCEPT_TTYNAME SI_POSIX\n #define SANITIZER_INTERCEPT_TTYNAME_R SI_POSIX\n #define SANITIZER_INTERCEPT_TEMPNAM SI_POSIX\n@@ -437,6 +443,7 @@\n #define SANITIZER_INTERCEPT_FTIME \\\n   (!SI_FREEBSD && !SI_NETBSD && !SI_OPENBSD && SI_POSIX)\n #define SANITIZER_INTERCEPT_XDR SI_LINUX_NOT_ANDROID || SI_SOLARIS\n+#define SANITIZER_INTERCEPT_XDRREC SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_TSEARCH \\\n   (SI_LINUX_NOT_ANDROID || SI_MAC || SI_NETBSD || SI_OPENBSD || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_LIBIO_INTERNALS SI_LINUX_NOT_ANDROID\n@@ -494,17 +501,17 @@\n \n #define SANITIZER_INTERCEPT_MMAP SI_POSIX\n #define SANITIZER_INTERCEPT_MMAP64 SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_MALLOPT_AND_MALLINFO \\\n+#define SANITIZER_INTERCEPT_MALLOPT_AND_MALLINFO                            \\\n   (!SI_FREEBSD && !SI_MAC && !SI_NETBSD && !SI_OPENBSD && SI_NOT_FUCHSIA && \\\n-  SI_NOT_RTEMS)\n+   SI_NOT_RTEMS && !SI_SOLARIS)  // NOLINT\n #define SANITIZER_INTERCEPT_MEMALIGN \\\n   (!SI_FREEBSD && !SI_MAC && !SI_NETBSD && !SI_OPENBSD && SI_NOT_RTEMS)\n-#define SANITIZER_INTERCEPT_PVALLOC \\\n+#define SANITIZER_INTERCEPT_PVALLOC                                         \\\n   (!SI_FREEBSD && !SI_MAC && !SI_NETBSD && !SI_OPENBSD && SI_NOT_FUCHSIA && \\\n-  SI_NOT_RTEMS)\n-#define SANITIZER_INTERCEPT_CFREE \\\n+   SI_NOT_RTEMS && !SI_SOLARIS)  // NOLINT\n+#define SANITIZER_INTERCEPT_CFREE                                           \\\n   (!SI_FREEBSD && !SI_MAC && !SI_NETBSD && !SI_OPENBSD && SI_NOT_FUCHSIA && \\\n-  SI_NOT_RTEMS)\n+   SI_NOT_RTEMS && !SI_SOLARIS)  // NOLINT\n #define SANITIZER_INTERCEPT_REALLOCARRAY SI_POSIX\n #define SANITIZER_INTERCEPT_ALIGNED_ALLOC (!SI_MAC && SI_NOT_RTEMS)\n #define SANITIZER_INTERCEPT_MALLOC_USABLE_SIZE \\\n@@ -544,7 +551,8 @@\n #define SANITIZER_INTERCEPT_FGETLN (SI_NETBSD || SI_FREEBSD)\n #define SANITIZER_INTERCEPT_STRMODE (SI_NETBSD || SI_FREEBSD)\n #define SANITIZER_INTERCEPT_TTYENT SI_NETBSD\n-#define SANITIZER_INTERCEPT_PROTOENT SI_NETBSD\n+#define SANITIZER_INTERCEPT_PROTOENT (SI_NETBSD || SI_LINUX)\n+#define SANITIZER_INTERCEPT_PROTOENT_R (SI_LINUX_NOT_ANDROID)\n #define SANITIZER_INTERCEPT_NETENT SI_NETBSD\n #define SANITIZER_INTERCEPT_SETVBUF (SI_NETBSD || SI_FREEBSD || \\\n   SI_LINUX || SI_MAC)\n@@ -596,7 +604,10 @@\n #define SANITIZER_INTERCEPT_QSORT \\\n   (SI_POSIX && !SI_IOSSIM && !SI_WATCHOS && !SI_TVOS && !SI_ANDROID)\n #define SANITIZER_INTERCEPT_QSORT_R (SI_LINUX && !SI_ANDROID)\n-#define SANITIZER_INTERCEPT_SIGALTSTACK SI_POSIX\n+// sigaltstack on i386 macOS cannot be intercepted due to setjmp()\n+// calling it and assuming that it does not clobber registers.\n+#define SANITIZER_INTERCEPT_SIGALTSTACK \\\n+  (SI_POSIX && !(SANITIZER_MAC && SANITIZER_I386))\n #define SANITIZER_INTERCEPT_UNAME (SI_POSIX && !SI_FREEBSD)\n #define SANITIZER_INTERCEPT___XUNAME SI_FREEBSD\n "}, {"sha": "b1c15be58deaaaf73ac307b5416f488b1cecd87d", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_freebsd.cpp", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -81,8 +81,6 @@\n #include <sys/shm.h>\n #undef _KERNEL\n \n-#undef INLINE  // to avoid clashes with sanitizers' definitions\n-\n #undef IOC_DIRMASK\n \n // Include these after system headers to avoid name clashes and ambiguities."}, {"sha": "c51327e1269e081cb0e231b75cbce71b62601e88", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_linux.cpp", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -26,12 +26,9 @@\n \n // With old kernels (and even new kernels on powerpc) asm/stat.h uses types that\n // are not defined anywhere in userspace headers. Fake them. This seems to work\n-// fine with newer headers, too.  Beware that with <sys/stat.h>, struct stat\n-// takes the form of struct stat64 on 32-bit platforms if _FILE_OFFSET_BITS=64.\n-// Also, for some platforms (e.g. mips) there are additional members in the\n-// <sys/stat.h> struct stat:s.\n+// fine with newer headers, too.\n #include <linux/posix_types.h>\n-#if defined(__x86_64__)\n+#if defined(__x86_64__) ||  defined(__mips__)\n #include <sys/stat.h>\n #else\n #define ino_t __kernel_ino_t"}, {"sha": "c8f2aa5dba4af0fa6a1754c378dd0e6595fe50d9", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_netbsd.cpp", "status": "modified", "additions": 154, "deletions": 1, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_netbsd.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_netbsd.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_netbsd.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -34,6 +34,7 @@\n #include <sys/chio.h>\n #include <sys/clockctl.h>\n #include <sys/cpuio.h>\n+#include <sys/dkbad.h>\n #include <sys/dkio.h>\n #include <sys/drvctlio.h>\n #include <sys/dvdio.h>\n@@ -83,6 +84,7 @@\n \n #include <sys/resource.h>\n #include <sys/sem.h>\n+#include <sys/scsiio.h>\n #include <sys/sha1.h>\n #include <sys/sha2.h>\n #include <sys/shm.h>\n@@ -139,7 +141,158 @@\n #include <dev/ir/irdaio.h>\n #include <dev/isa/isvio.h>\n #include <dev/isa/wtreg.h>\n+#if __has_include(<dev/iscsi/iscsi_ioctl.h>)\n #include <dev/iscsi/iscsi_ioctl.h>\n+#else\n+/* Fallback for MKISCSI=no */\n+\n+typedef struct {\n+  uint32_t status;\n+  uint32_t session_id;\n+  uint32_t connection_id;\n+} iscsi_conn_status_parameters_t;\n+\n+typedef struct {\n+  uint32_t status;\n+  uint16_t interface_version;\n+  uint16_t major;\n+  uint16_t minor;\n+  uint8_t version_string[224];\n+} iscsi_get_version_parameters_t;\n+\n+typedef struct {\n+  uint32_t status;\n+  uint32_t session_id;\n+  uint32_t connection_id;\n+  struct {\n+    unsigned int immediate : 1;\n+  } options;\n+  uint64_t lun;\n+  scsireq_t req; /* from <sys/scsiio.h> */\n+} iscsi_iocommand_parameters_t;\n+\n+typedef enum {\n+  ISCSI_AUTH_None = 0,\n+  ISCSI_AUTH_CHAP = 1,\n+  ISCSI_AUTH_KRB5 = 2,\n+  ISCSI_AUTH_SRP = 3\n+} iscsi_auth_types_t;\n+\n+typedef enum {\n+  ISCSI_LOGINTYPE_DISCOVERY = 0,\n+  ISCSI_LOGINTYPE_NOMAP = 1,\n+  ISCSI_LOGINTYPE_MAP = 2\n+} iscsi_login_session_type_t;\n+\n+typedef enum { ISCSI_DIGEST_None = 0, ISCSI_DIGEST_CRC32C = 1 } iscsi_digest_t;\n+\n+typedef enum {\n+  ISCSI_SESSION_TERMINATED = 1,\n+  ISCSI_CONNECTION_TERMINATED,\n+  ISCSI_RECOVER_CONNECTION,\n+  ISCSI_DRIVER_TERMINATING\n+} iscsi_event_t;\n+\n+typedef struct {\n+  unsigned int mutual_auth : 1;\n+  unsigned int is_secure : 1;\n+  unsigned int auth_number : 4;\n+  iscsi_auth_types_t auth_type[4];\n+} iscsi_auth_info_t;\n+\n+typedef struct {\n+  uint32_t status;\n+  int socket;\n+  struct {\n+    unsigned int HeaderDigest : 1;\n+    unsigned int DataDigest : 1;\n+    unsigned int MaxConnections : 1;\n+    unsigned int DefaultTime2Wait : 1;\n+    unsigned int DefaultTime2Retain : 1;\n+    unsigned int MaxRecvDataSegmentLength : 1;\n+    unsigned int auth_info : 1;\n+    unsigned int user_name : 1;\n+    unsigned int password : 1;\n+    unsigned int target_password : 1;\n+    unsigned int TargetName : 1;\n+    unsigned int TargetAlias : 1;\n+    unsigned int ErrorRecoveryLevel : 1;\n+  } is_present;\n+  iscsi_auth_info_t auth_info;\n+  iscsi_login_session_type_t login_type;\n+  iscsi_digest_t HeaderDigest;\n+  iscsi_digest_t DataDigest;\n+  uint32_t session_id;\n+  uint32_t connection_id;\n+  uint32_t MaxRecvDataSegmentLength;\n+  uint16_t MaxConnections;\n+  uint16_t DefaultTime2Wait;\n+  uint16_t DefaultTime2Retain;\n+  uint16_t ErrorRecoveryLevel;\n+  void *user_name;\n+  void *password;\n+  void *target_password;\n+  void *TargetName;\n+  void *TargetAlias;\n+} iscsi_login_parameters_t;\n+\n+typedef struct {\n+  uint32_t status;\n+  uint32_t session_id;\n+} iscsi_logout_parameters_t;\n+\n+typedef struct {\n+  uint32_t status;\n+  uint32_t event_id;\n+} iscsi_register_event_parameters_t;\n+\n+typedef struct {\n+  uint32_t status;\n+  uint32_t session_id;\n+  uint32_t connection_id;\n+} iscsi_remove_parameters_t;\n+\n+typedef struct {\n+  uint32_t status;\n+  uint32_t session_id;\n+  void *response_buffer;\n+  uint32_t response_size;\n+  uint32_t response_used;\n+  uint32_t response_total;\n+  uint8_t key[224];\n+} iscsi_send_targets_parameters_t;\n+\n+typedef struct {\n+  uint32_t status;\n+  uint8_t InitiatorName[224];\n+  uint8_t InitiatorAlias[224];\n+  uint8_t ISID[6];\n+} iscsi_set_node_name_parameters_t;\n+\n+typedef struct {\n+  uint32_t status;\n+  uint32_t event_id;\n+  iscsi_event_t event_kind;\n+  uint32_t session_id;\n+  uint32_t connection_id;\n+  uint32_t reason;\n+} iscsi_wait_event_parameters_t;\n+\n+#define ISCSI_GET_VERSION _IOWR(0, 1, iscsi_get_version_parameters_t)\n+#define ISCSI_LOGIN _IOWR(0, 2, iscsi_login_parameters_t)\n+#define ISCSI_LOGOUT _IOWR(0, 3, iscsi_logout_parameters_t)\n+#define ISCSI_ADD_CONNECTION _IOWR(0, 4, iscsi_login_parameters_t)\n+#define ISCSI_RESTORE_CONNECTION _IOWR(0, 5, iscsi_login_parameters_t)\n+#define ISCSI_REMOVE_CONNECTION _IOWR(0, 6, iscsi_remove_parameters_t)\n+#define ISCSI_CONNECTION_STATUS _IOWR(0, 7, iscsi_conn_status_parameters_t)\n+#define ISCSI_SEND_TARGETS _IOWR(0, 8, iscsi_send_targets_parameters_t)\n+#define ISCSI_SET_NODE_NAME _IOWR(0, 9, iscsi_set_node_name_parameters_t)\n+#define ISCSI_IO_COMMAND _IOWR(0, 10, iscsi_iocommand_parameters_t)\n+#define ISCSI_REGISTER_EVENT _IOWR(0, 11, iscsi_register_event_parameters_t)\n+#define ISCSI_DEREGISTER_EVENT _IOWR(0, 12, iscsi_register_event_parameters_t)\n+#define ISCSI_WAIT_EVENT _IOWR(0, 13, iscsi_wait_event_parameters_t)\n+#define ISCSI_POLL_EVENT _IOWR(0, 14, iscsi_wait_event_parameters_t)\n+#endif\n #include <dev/ofw/openfirmio.h>\n #include <dev/pci/amrio.h>\n #include <dev/pci/mlyreg.h>\n@@ -372,7 +525,7 @@ struct urio_command {\n #include \"sanitizer_platform_limits_netbsd.h\"\n \n namespace __sanitizer {\n-void *__sanitizer_get_link_map_by_dlopen_handle(void* handle) {\n+void *__sanitizer_get_link_map_by_dlopen_handle(void *handle) {\n   void *p = nullptr;\n   return internal_dlinfo(handle, RTLD_DI_LINKMAP, &p) == 0 ? p : nullptr;\n }"}, {"sha": "9e28dcfef0415895280c6d59276005c33c515336", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_netbsd.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_netbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_netbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_netbsd.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -21,8 +21,8 @@\n \n namespace __sanitizer {\n void *__sanitizer_get_link_map_by_dlopen_handle(void *handle);\n-# define GET_LINK_MAP_BY_DLOPEN_HANDLE(handle) \\\n-    (link_map *)__sanitizer_get_link_map_by_dlopen_handle(handle)\n+#define GET_LINK_MAP_BY_DLOPEN_HANDLE(handle) \\\n+  (link_map *)__sanitizer_get_link_map_by_dlopen_handle(handle)\n \n extern unsigned struct_utsname_sz;\n extern unsigned struct_stat_sz;\n@@ -1024,12 +1024,10 @@ extern unsigned struct_RF_ProgressInfo_sz;\n extern unsigned struct_nvlist_ref_sz;\n extern unsigned struct_StringList_sz;\n \n-\n // A special value to mark ioctls that are not present on the target platform,\n // when it can not be determined without including any system headers.\n extern const unsigned IOCTL_NOT_PRESENT;\n \n-\n extern unsigned IOCTL_AFM_ADDFMAP;\n extern unsigned IOCTL_AFM_DELFMAP;\n extern unsigned IOCTL_AFM_CLEANFMAP;"}, {"sha": "1427cec48c4a36a671c5f0dfbd851938c83d9574", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cpp", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -90,7 +90,8 @@\n #if SANITIZER_LINUX\n # include <utime.h>\n # include <sys/ptrace.h>\n-# if defined(__mips64) || defined(__aarch64__) || defined(__arm__)\n+#if defined(__mips64) || defined(__aarch64__) || defined(__arm__) || \\\n+    SANITIZER_RISCV64\n #  include <asm/ptrace.h>\n #  ifdef __arm__\n typedef struct user_fpregs elf_fpregset_t;\n@@ -170,9 +171,9 @@ typedef struct user_fpregs elf_fpregset_t;\n namespace __sanitizer {\n   unsigned struct_utsname_sz = sizeof(struct utsname);\n   unsigned struct_stat_sz = sizeof(struct stat);\n-#if !SANITIZER_IOS\n+#if !SANITIZER_IOS && !(SANITIZER_MAC && TARGET_CPU_ARM64)\n   unsigned struct_stat64_sz = sizeof(struct stat64);\n-#endif // !SANITIZER_IOS\n+#endif // !SANITIZER_IOS && !(SANITIZER_MAC && TARGET_CPU_ARM64)\n   unsigned struct_rusage_sz = sizeof(struct rusage);\n   unsigned struct_tm_sz = sizeof(struct tm);\n   unsigned struct_passwd_sz = sizeof(struct passwd);\n@@ -197,9 +198,9 @@ namespace __sanitizer {\n   unsigned struct_regex_sz = sizeof(regex_t);\n   unsigned struct_regmatch_sz = sizeof(regmatch_t);\n \n-#if SANITIZER_MAC && !SANITIZER_IOS\n+#if (SANITIZER_MAC && !TARGET_CPU_ARM64) && !SANITIZER_IOS\n   unsigned struct_statfs64_sz = sizeof(struct statfs64);\n-#endif // SANITIZER_MAC && !SANITIZER_IOS\n+#endif // (SANITIZER_MAC && !TARGET_CPU_ARM64) && !SANITIZER_IOS\n \n #if !SANITIZER_ANDROID\n   unsigned struct_fstab_sz = sizeof(struct fstab);\n@@ -229,9 +230,9 @@ namespace __sanitizer {\n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n   // Use pre-computed size of struct ustat to avoid <sys/ustat.h> which\n   // has been removed from glibc 2.28.\n-#if defined(__aarch64__) || defined(__s390x__) || defined (__mips64) \\\n-  || defined(__powerpc64__) || defined(__arch64__) || defined(__sparcv9) \\\n-  || defined(__x86_64__) || (defined(__riscv) && __riscv_xlen == 64)\n+#if defined(__aarch64__) || defined(__s390x__) || defined(__mips64) ||     \\\n+    defined(__powerpc64__) || defined(__arch64__) || defined(__sparcv9) || \\\n+    defined(__x86_64__) || SANITIZER_RISCV64\n #define SIZEOF_STRUCT_USTAT 32\n #elif defined(__arm__) || defined(__i386__) || defined(__mips__) \\\n   || defined(__powerpc__) || defined(__s390__) || defined(__sparc__)\n@@ -303,13 +304,16 @@ unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);\n   int glob_altdirfunc = GLOB_ALTDIRFUNC;\n #endif\n \n-#if SANITIZER_LINUX && !SANITIZER_ANDROID && \\\n-    (defined(__i386) || defined(__x86_64) || defined(__mips64) || \\\n-      defined(__powerpc64__) || defined(__aarch64__) || defined(__arm__) || \\\n-      defined(__s390__))\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID &&                               \\\n+    (defined(__i386) || defined(__x86_64) || defined(__mips64) ||          \\\n+     defined(__powerpc64__) || defined(__aarch64__) || defined(__arm__) || \\\n+     defined(__s390__) || SANITIZER_RISCV64)\n #if defined(__mips64) || defined(__powerpc64__) || defined(__arm__)\n   unsigned struct_user_regs_struct_sz = sizeof(struct pt_regs);\n   unsigned struct_user_fpregs_struct_sz = sizeof(elf_fpregset_t);\n+#elif SANITIZER_RISCV64\n+  unsigned struct_user_regs_struct_sz = sizeof(struct user_regs_struct);\n+  unsigned struct_user_fpregs_struct_sz = sizeof(struct __riscv_q_ext_state);\n #elif defined(__aarch64__)\n   unsigned struct_user_regs_struct_sz = sizeof(struct user_pt_regs);\n   unsigned struct_user_fpregs_struct_sz = sizeof(struct user_fpsimd_state);\n@@ -321,7 +325,8 @@ unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);\n   unsigned struct_user_fpregs_struct_sz = sizeof(struct user_fpregs_struct);\n #endif // __mips64 || __powerpc64__ || __aarch64__\n #if defined(__x86_64) || defined(__mips64) || defined(__powerpc64__) || \\\n-    defined(__aarch64__) || defined(__arm__) || defined(__s390__)\n+    defined(__aarch64__) || defined(__arm__) || defined(__s390__) ||    \\\n+    SANITIZER_RISCV64\n   unsigned struct_user_fpxregs_struct_sz = 0;\n #else\n   unsigned struct_user_fpxregs_struct_sz = sizeof(struct user_fpxregs_struct);"}, {"sha": "e69560ee39e95572f557bd51fb654f06e591feb1", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -83,7 +83,7 @@ const unsigned struct_kernel_stat64_sz = 104;\n #elif defined(__mips__)\n const unsigned struct_kernel_stat_sz = SANITIZER_ANDROID\n                                            ? FIRST_32_SECOND_64(104, 128)\n-                                           : FIRST_32_SECOND_64(144, 216);\n+                                           : FIRST_32_SECOND_64(160, 216);\n const unsigned struct_kernel_stat64_sz = 104;\n #elif defined(__s390__) && !defined(__s390x__)\n const unsigned struct_kernel_stat_sz = 64;\n@@ -99,9 +99,9 @@ const unsigned struct_kernel_stat64_sz = 144;\n const unsigned struct___old_kernel_stat_sz = 0;\n const unsigned struct_kernel_stat_sz = 64;\n const unsigned struct_kernel_stat64_sz = 104;\n-#elif defined(__riscv) && __riscv_xlen == 64\n+#elif SANITIZER_RISCV64\n const unsigned struct_kernel_stat_sz = 128;\n-const unsigned struct_kernel_stat64_sz = 104;\n+const unsigned struct_kernel_stat64_sz = 0;  // RISCV64 does not use stat64\n #endif\n struct __sanitizer_perf_event_attr {\n   unsigned type;\n@@ -704,6 +704,12 @@ struct __sanitizer_dl_phdr_info {\n extern unsigned struct_ElfW_Phdr_sz;\n #endif\n \n+struct __sanitizer_protoent {\n+  char *p_name;\n+  char **p_aliases;\n+  int p_proto;\n+};\n+\n struct __sanitizer_addrinfo {\n   int ai_flags;\n   int ai_family;\n@@ -798,7 +804,7 @@ typedef void __sanitizer_FILE;\n #if SANITIZER_LINUX && !SANITIZER_ANDROID &&                               \\\n     (defined(__i386) || defined(__x86_64) || defined(__mips64) ||          \\\n      defined(__powerpc64__) || defined(__aarch64__) || defined(__arm__) || \\\n-     defined(__s390__))\n+     defined(__s390__) || SANITIZER_RISCV64)\n extern unsigned struct_user_regs_struct_sz;\n extern unsigned struct_user_fpregs_struct_sz;\n extern unsigned struct_user_fpxregs_struct_sz;"}, {"sha": "565b31f68aaee0b835f45fa9b6f204bf040b08d4", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_solaris.cpp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_solaris.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_solaris.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_solaris.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -202,7 +202,8 @@ CHECK_SIZE_AND_OFFSET(dl_phdr_info, dlpi_name);\n CHECK_SIZE_AND_OFFSET(dl_phdr_info, dlpi_phdr);\n CHECK_SIZE_AND_OFFSET(dl_phdr_info, dlpi_phnum);\n \n-CHECK_TYPE_SIZE(glob_t);\n+// There are additional fields we are not interested in.\n+COMPILER_CHECK(sizeof(__sanitizer_glob_t) <= sizeof(glob_t));\n CHECK_SIZE_AND_OFFSET(glob_t, gl_pathc);\n CHECK_SIZE_AND_OFFSET(glob_t, gl_pathv);\n CHECK_SIZE_AND_OFFSET(glob_t, gl_offs);"}, {"sha": "b8b75c20d9f9af346af8dce6f7e1ce7cf241c577", "filename": "libsanitizer/sanitizer_common/sanitizer_posix.cpp", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -293,7 +293,7 @@ uptr SignalContext::GetAddress() const {\n \n bool SignalContext::IsMemoryAccess() const {\n   auto si = static_cast<const siginfo_t *>(siginfo);\n-  return si->si_signo == SIGSEGV;\n+  return si->si_signo == SIGSEGV || si->si_signo == SIGBUS;\n }\n \n int SignalContext::GetType() const {\n@@ -354,11 +354,11 @@ int GetNamedMappingFd(const char *name, uptr size, int *flags) {\n   int fd = ReserveStandardFds(\n       internal_open(shmname, O_RDWR | O_CREAT | O_TRUNC | o_cloexec, S_IRWXU));\n   CHECK_GE(fd, 0);\n-  if (!o_cloexec) {\n-    int res = fcntl(fd, F_SETFD, FD_CLOEXEC);\n-    CHECK_EQ(0, res);\n-  }\n   int res = internal_ftruncate(fd, size);\n+#if !defined(O_CLOEXEC)\n+  res = fcntl(fd, F_SETFD, FD_CLOEXEC);\n+  CHECK_EQ(0, res);\n+#endif\n   CHECK_EQ(0, res);\n   res = internal_unlink(shmname);\n   CHECK_EQ(0, res);"}, {"sha": "66bcaf4fd2e48d8cc19bc71acc8ecdffc96902eb", "filename": "libsanitizer/sanitizer_common/sanitizer_posix.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -42,6 +42,7 @@ uptr internal_mmap(void *addr, uptr length, int prot, int flags,\n                    int fd, u64 offset);\n uptr internal_munmap(void *addr, uptr length);\n int internal_mprotect(void *addr, uptr length, int prot);\n+int internal_madvise(uptr addr, uptr length, int advice);\n \n // OS\n uptr internal_filesize(fd_t fd);  // -1 on error."}, {"sha": "37aaec362dd2ccdbcf1b307dbe411aaa47cb4a9b", "filename": "libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cpp", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -61,27 +61,24 @@ void ReleaseMemoryPagesToOS(uptr beg, uptr end) {\n   uptr beg_aligned = RoundUpTo(beg, page_size);\n   uptr end_aligned = RoundDownTo(end, page_size);\n   if (beg_aligned < end_aligned)\n-    // In the default Solaris compilation environment, madvise() is declared\n-    // to take a caddr_t arg; casting it to void * results in an invalid\n-    // conversion error, so use char * instead.\n-    madvise((char *)beg_aligned, end_aligned - beg_aligned,\n-            SANITIZER_MADVISE_DONTNEED);\n+    internal_madvise(beg_aligned, end_aligned - beg_aligned,\n+                     SANITIZER_MADVISE_DONTNEED);\n }\n \n void SetShadowRegionHugePageMode(uptr addr, uptr size) {\n #ifdef MADV_NOHUGEPAGE  // May not be defined on old systems.\n   if (common_flags()->no_huge_pages_for_shadow)\n-    madvise((char *)addr, size, MADV_NOHUGEPAGE);\n+    internal_madvise(addr, size, MADV_NOHUGEPAGE);\n   else\n-    madvise((char *)addr, size, MADV_HUGEPAGE);\n+    internal_madvise(addr, size, MADV_HUGEPAGE);\n #endif  // MADV_NOHUGEPAGE\n }\n \n bool DontDumpShadowMemory(uptr addr, uptr length) {\n #if defined(MADV_DONTDUMP)\n-  return madvise((char *)addr, length, MADV_DONTDUMP) == 0;\n+  return internal_madvise(addr, length, MADV_DONTDUMP) == 0;\n #elif defined(MADV_NOCORE)\n-  return madvise((char *)addr, length, MADV_NOCORE) == 0;\n+  return internal_madvise(addr, length, MADV_NOCORE) == 0;\n #else\n   return true;\n #endif  // MADV_DONTDUMP"}, {"sha": "4063ec8deaa12dd53a656a11ac31c592ed939ffd", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_solaris.cpp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_solaris.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_solaris.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_solaris.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -35,7 +35,8 @@ bool MemoryMappingLayout::Next(MemoryMappedSegment *segment) {\n   char *last = data_.proc_self_maps.data + data_.proc_self_maps.len;\n   if (data_.current >= last) return false;\n \n-  prxmap_t *xmapentry = (prxmap_t*)data_.current;\n+  prxmap_t *xmapentry =\n+      const_cast<prxmap_t *>(reinterpret_cast<const prxmap_t *>(data_.current));\n \n   segment->start = (uptr)xmapentry->pr_vaddr;\n   segment->end = (uptr)(xmapentry->pr_vaddr + xmapentry->pr_size);"}, {"sha": "a288068bf943833db17c3884b84b9725ccfe555e", "filename": "libsanitizer/sanitizer_common/sanitizer_ptrauth.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_ptrauth.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_ptrauth.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_ptrauth.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -18,4 +18,6 @@\n #define ptrauth_string_discriminator(__string) ((int)0)\n #endif\n \n+#define STRIP_PC(pc) ((uptr)ptrauth_strip(pc, 0))\n+\n #endif // SANITIZER_PTRAUTH_H"}, {"sha": "cefb870f7e258a7d9988566a95a7ef1f72753823", "filename": "libsanitizer/sanitizer_common/sanitizer_signal_interceptors.inc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_signal_interceptors.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_signal_interceptors.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_signal_interceptors.inc?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -53,7 +53,10 @@ INTERCEPTOR(uptr, signal, int signum, uptr handler) {\n \n INTERCEPTOR(int, sigaction_symname, int signum,\n             const __sanitizer_sigaction *act, __sanitizer_sigaction *oldact) {\n-  if (GetHandleSignalMode(signum) == kHandleSignalExclusive) return 0;\n+  if (GetHandleSignalMode(signum) == kHandleSignalExclusive) {\n+    if (!oldact) return 0;\n+    act = nullptr;\n+  }\n   SIGNAL_INTERCEPTOR_SIGACTION_IMPL(signum, act, oldact);\n }\n #define INIT_SIGACTION COMMON_INTERCEPT_FUNCTION(sigaction_symname)"}, {"sha": "8789dcd10a9543702d3f7b7c2c3a461b8f868586", "filename": "libsanitizer/sanitizer_common/sanitizer_solaris.cpp", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_solaris.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_solaris.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_solaris.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -74,6 +74,20 @@ DECLARE__REAL_AND_INTERNAL(int, mprotect, void *addr, uptr length, int prot) {\n   return _REAL(mprotect)(addr, length, prot);\n }\n \n+// Illumos' declaration of madvise cannot be made visible if _XOPEN_SOURCE\n+// is defined as g++ does on Solaris.\n+//\n+// This declaration is consistent with Solaris 11.4. Both Illumos and Solaris\n+// versions older than 11.4 declared madvise with a caddr_t as the first\n+// argument, but we don't currently support Solaris versions older than 11.4,\n+// and as mentioned above the declaration is not visible on Illumos so we can\n+// use any declaration we like on Illumos.\n+extern \"C\" int madvise(void *, size_t, int);\n+\n+int internal_madvise(uptr addr, uptr length, int advice) {\n+  return madvise((void *)addr, length, advice);\n+}\n+\n DECLARE__REAL_AND_INTERNAL(uptr, close, fd_t fd) {\n   return _REAL(close)(fd);\n }\n@@ -146,10 +160,6 @@ DECLARE__REAL_AND_INTERNAL(uptr, sched_yield, void) {\n   return sched_yield();\n }\n \n-DECLARE__REAL_AND_INTERNAL(void, _exit, int exitcode) {\n-  _exit(exitcode);\n-}\n-\n DECLARE__REAL_AND_INTERNAL(uptr, execve, const char *filename,\n                            char *const argv[], char *const envp[]) {\n   return _REAL(execve)(filename, argv, envp);"}, {"sha": "4692f50d323732ef50a65e7c50fc97e22ffc3c39", "filename": "libsanitizer/sanitizer_common/sanitizer_stackdepot.cpp", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -115,6 +115,12 @@ void StackDepotUnlockAll() {\n   theDepot.UnlockAll();\n }\n \n+void StackDepotPrintAll() {\n+#if !SANITIZER_GO\n+  theDepot.PrintAll();\n+#endif\n+}\n+\n bool StackDepotReverseMap::IdDescPair::IdComparator(\n     const StackDepotReverseMap::IdDescPair &a,\n     const StackDepotReverseMap::IdDescPair &b) {"}, {"sha": "0e26c1fc37c49099aa28487d1af09076e6282a72", "filename": "libsanitizer/sanitizer_common/sanitizer_stackdepot.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -41,6 +41,7 @@ StackTrace StackDepotGet(u32 id);\n \n void StackDepotLockAll();\n void StackDepotUnlockAll();\n+void StackDepotPrintAll();\n \n // Instantiating this class creates a snapshot of StackDepot which can be\n // efficiently queried with StackDepotGet(). You can use it concurrently with"}, {"sha": "1af2c1892eff7d7bce0cf4c20d52212cb77ef9b8", "filename": "libsanitizer/sanitizer_common/sanitizer_stackdepotbase.h", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepotbase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepotbase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepotbase.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -13,9 +13,11 @@\n #ifndef SANITIZER_STACKDEPOTBASE_H\n #define SANITIZER_STACKDEPOTBASE_H\n \n+#include <stdio.h>\n+\n+#include \"sanitizer_atomic.h\"\n #include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_mutex.h\"\n-#include \"sanitizer_atomic.h\"\n #include \"sanitizer_persistent_allocator.h\"\n \n namespace __sanitizer {\n@@ -34,6 +36,7 @@ class StackDepotBase {\n \n   void LockAll();\n   void UnlockAll();\n+  void PrintAll();\n \n  private:\n   static Node *find(Node *s, args_type args, u32 hash);\n@@ -172,6 +175,21 @@ void StackDepotBase<Node, kReservedBits, kTabSizeLog>::UnlockAll() {\n   }\n }\n \n+template <class Node, int kReservedBits, int kTabSizeLog>\n+void StackDepotBase<Node, kReservedBits, kTabSizeLog>::PrintAll() {\n+  for (int i = 0; i < kTabSize; ++i) {\n+    atomic_uintptr_t *p = &tab[i];\n+    lock(p);\n+    uptr v = atomic_load(p, memory_order_relaxed);\n+    Node *s = (Node *)(v & ~1UL);\n+    for (; s; s = s->link) {\n+      Printf(\"Stack for id %u:\\n\", s->id);\n+      s->load().Print();\n+    }\n+    unlock(p, s);\n+  }\n+}\n+\n } // namespace __sanitizer\n \n #endif // SANITIZER_STACKDEPOTBASE_H"}, {"sha": "b0487d8987db28b028f30bbcad4a2a9d189ef99d", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.cpp", "status": "modified", "additions": 40, "deletions": 14, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -10,9 +10,11 @@\n // run-time libraries.\n //===----------------------------------------------------------------------===//\n \n+#include \"sanitizer_stacktrace.h\"\n+\n #include \"sanitizer_common.h\"\n #include \"sanitizer_flags.h\"\n-#include \"sanitizer_stacktrace.h\"\n+#include \"sanitizer_platform.h\"\n \n namespace __sanitizer {\n \n@@ -21,6 +23,28 @@ uptr StackTrace::GetNextInstructionPc(uptr pc) {\n   return pc + 8;\n #elif defined(__powerpc__) || defined(__arm__) || defined(__aarch64__)\n   return pc + 4;\n+#elif SANITIZER_RISCV64\n+  // Current check order is 4 -> 2 -> 6 -> 8\n+  u8 InsnByte = *(u8 *)(pc);\n+  if (((InsnByte & 0x3) == 0x3) && ((InsnByte & 0x1c) != 0x1c)) {\n+    // xxxxxxxxxxxbbb11 | 32 bit | bbb != 111\n+    return pc + 4;\n+  }\n+  if ((InsnByte & 0x3) != 0x3) {\n+    // xxxxxxxxxxxxxxaa | 16 bit | aa != 11\n+    return pc + 2;\n+  }\n+  // RISC-V encoding allows instructions to be up to 8 bytes long\n+  if ((InsnByte & 0x3f) == 0x1f) {\n+    // xxxxxxxxxx011111 | 48 bit |\n+    return pc + 6;\n+  }\n+  if ((InsnByte & 0x7f) == 0x3f) {\n+    // xxxxxxxxx0111111 | 64 bit |\n+    return pc + 8;\n+  }\n+  // bail-out if could not figure out the instruction size\n+  return 0;\n #else\n   return pc + 1;\n #endif\n@@ -60,8 +84,8 @@ static inline uhwptr *GetCanonicFrame(uptr bp,\n   // Nope, this does not look right either. This means the frame after next does\n   // not have a valid frame pointer, but we can still extract the caller PC.\n   // Unfortunately, there is no way to decide between GCC and LLVM frame\n-  // layouts. Assume GCC.\n-  return bp_prev - 1;\n+  // layouts. Assume LLVM.\n+  return bp_prev;\n #else\n   return (uhwptr*)bp;\n #endif\n@@ -84,23 +108,19 @@ void BufferedStackTrace::UnwindFast(uptr pc, uptr bp, uptr stack_top,\n          IsAligned((uptr)frame, sizeof(*frame)) &&\n          size < max_depth) {\n #ifdef __powerpc__\n-    // PowerPC ABIs specify that the return address is saved on the\n-    // *caller's* stack frame.  Thus we must dereference the back chain\n-    // to find the caller frame before extracting it.\n+    // PowerPC ABIs specify that the return address is saved at offset\n+    // 16 of the *caller's* stack frame.  Thus we must dereference the\n+    // back chain to find the caller frame before extracting it.\n     uhwptr *caller_frame = (uhwptr*)frame[0];\n     if (!IsValidFrame((uptr)caller_frame, stack_top, bottom) ||\n         !IsAligned((uptr)caller_frame, sizeof(uhwptr)))\n       break;\n-    // For most ABIs the offset where the return address is saved is two\n-    // register sizes.  The exception is the SVR4 ABI, which uses an\n-    // offset of only one register size.\n-#ifdef _CALL_SYSV\n-    uhwptr pc1 = caller_frame[1];\n-#else\n     uhwptr pc1 = caller_frame[2];\n-#endif\n #elif defined(__s390__)\n     uhwptr pc1 = frame[14];\n+#elif defined(__riscv)\n+    // frame[-1] contains the return address\n+    uhwptr pc1 = frame[-1];\n #else\n     uhwptr pc1 = frame[1];\n #endif\n@@ -113,7 +133,13 @@ void BufferedStackTrace::UnwindFast(uptr pc, uptr bp, uptr stack_top,\n       trace_buffer[size++] = (uptr) pc1;\n     }\n     bottom = (uptr)frame;\n-    frame = GetCanonicFrame((uptr)frame[0], stack_top, bottom);\n+#if defined(__riscv)\n+    // frame[-2] contain fp of the previous frame\n+    uptr new_bp = (uptr)frame[-2];\n+#else\n+    uptr new_bp = (uptr)frame[0];\n+#endif\n+    frame = GetCanonicFrame(new_bp, stack_top, bottom);\n   }\n }\n "}, {"sha": "d9fd88d90a745f5b14a7881956d72c42dff99587", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.h", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -13,6 +13,7 @@\n #define SANITIZER_STACKTRACE_H\n \n #include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_platform.h\"\n \n namespace __sanitizer {\n \n@@ -85,6 +86,14 @@ uptr StackTrace::GetPreviousInstructionPc(uptr pc) {\n   return pc - 4;\n #elif defined(__sparc__) || defined(__mips__)\n   return pc - 8;\n+#elif SANITIZER_RISCV64\n+  // RV-64 has variable instruciton length...\n+  // C extentions gives us 2-byte instructoins\n+  // RV-64 has 4-byte instructions\n+  // + RISCV architecture allows instructions up to 8 bytes\n+  // It seems difficult to figure out the exact instruction length -\n+  // pc - 2 seems like a safe option for the purposes of stack tracing\n+  return pc - 2;\n #else\n   return pc - 1;\n #endif\n@@ -143,9 +152,17 @@ struct BufferedStackTrace : public StackTrace {\n   friend class FastUnwindTest;\n };\n \n+#if defined(__s390x__)\n+static const uptr kFrameSize = 160;\n+#elif defined(__s390__)\n+static const uptr kFrameSize = 96;\n+#else\n+static const uptr kFrameSize = 2 * sizeof(uhwptr);\n+#endif\n+\n // Check if given pointer points into allocated stack area.\n static inline bool IsValidFrame(uptr frame, uptr stack_top, uptr stack_bottom) {\n-  return frame > stack_bottom && frame < stack_top - 2 * sizeof (uhwptr);\n+  return frame > stack_bottom && frame < stack_top - kFrameSize;\n }\n \n }  // namespace __sanitizer"}, {"sha": "7808ba9b0f572f15cf8f6d2f474369203f36b4c9", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_libcdep.cpp", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -26,17 +26,23 @@ void StackTrace::Print() const {\n   InternalScopedString frame_desc(GetPageSizeCached() * 2);\n   InternalScopedString dedup_token(GetPageSizeCached());\n   int dedup_frames = common_flags()->dedup_token_length;\n+  bool symbolize = RenderNeedsSymbolization(common_flags()->stack_trace_format);\n   uptr frame_num = 0;\n   for (uptr i = 0; i < size && trace[i]; i++) {\n     // PCs in stack traces are actually the return addresses, that is,\n     // addresses of the next instructions after the call.\n     uptr pc = GetPreviousInstructionPc(trace[i]);\n-    SymbolizedStack *frames = Symbolizer::GetOrInit()->SymbolizePC(pc);\n+    SymbolizedStack *frames;\n+    if (symbolize)\n+      frames = Symbolizer::GetOrInit()->SymbolizePC(pc);\n+    else\n+      frames = SymbolizedStack::New(pc);\n     CHECK(frames);\n     for (SymbolizedStack *cur = frames; cur; cur = cur->next) {\n       frame_desc.clear();\n       RenderFrame(&frame_desc, common_flags()->stack_trace_format, frame_num++,\n-                  cur->info, common_flags()->symbolize_vs_style,\n+                  cur->info.address, symbolize ? &cur->info : nullptr,\n+                  common_flags()->symbolize_vs_style,\n                   common_flags()->strip_path_prefix);\n       Printf(\"%s\\n\", frame_desc.data());\n       if (dedup_frames-- > 0) {\n@@ -108,7 +114,12 @@ void __sanitizer_symbolize_pc(uptr pc, const char *fmt, char *out_buf,\n                               uptr out_buf_size) {\n   if (!out_buf_size) return;\n   pc = StackTrace::GetPreviousInstructionPc(pc);\n-  SymbolizedStack *frame = Symbolizer::GetOrInit()->SymbolizePC(pc);\n+  SymbolizedStack *frame;\n+  bool symbolize = RenderNeedsSymbolization(fmt);\n+  if (symbolize)\n+    frame = Symbolizer::GetOrInit()->SymbolizePC(pc);\n+  else\n+    frame = SymbolizedStack::New(pc);\n   if (!frame) {\n     internal_strncpy(out_buf, \"<can't symbolize>\", out_buf_size);\n     out_buf[out_buf_size - 1] = 0;\n@@ -121,7 +132,8 @@ void __sanitizer_symbolize_pc(uptr pc, const char *fmt, char *out_buf,\n   for (SymbolizedStack *cur = frame; cur && out_buf < out_end;\n        cur = cur->next) {\n     frame_desc.clear();\n-    RenderFrame(&frame_desc, fmt, frame_num++, cur->info,\n+    RenderFrame(&frame_desc, fmt, frame_num++, cur->info.address,\n+                symbolize ? &cur->info : nullptr,\n                 common_flags()->symbolize_vs_style,\n                 common_flags()->strip_path_prefix);\n     if (!frame_desc.length())\n@@ -134,6 +146,7 @@ void __sanitizer_symbolize_pc(uptr pc, const char *fmt, char *out_buf,\n   }\n   CHECK(out_buf <= out_end);\n   *out_buf = 0;\n+  frame->ClearAll();\n }\n \n SANITIZER_INTERFACE_ATTRIBUTE"}, {"sha": "c998322d394411a3740212d82d7d5932a0534d65", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_printer.cpp", "status": "modified", "additions": 60, "deletions": 32, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -107,8 +107,14 @@ static const char *DemangleFunctionName(const char *function) {\n static const char kDefaultFormat[] = \"    #%n %p %F %L\";\n \n void RenderFrame(InternalScopedString *buffer, const char *format, int frame_no,\n-                 const AddressInfo &info, bool vs_style,\n+                 uptr address, const AddressInfo *info, bool vs_style,\n                  const char *strip_path_prefix, const char *strip_func_prefix) {\n+  // info will be null in the case where symbolization is not needed for the\n+  // given format. This ensures that the code below will get a hard failure\n+  // rather than print incorrect information in case RenderNeedsSymbolization\n+  // ever ends up out of sync with this function. If non-null, the addresses\n+  // should match.\n+  CHECK(!info || address == info->address);\n   if (0 == internal_strcmp(format, \"DEFAULT\"))\n     format = kDefaultFormat;\n   for (const char *p = format; *p != '\\0'; p++) {\n@@ -126,71 +132,70 @@ void RenderFrame(InternalScopedString *buffer, const char *format, int frame_no,\n       buffer->append(\"%zu\", frame_no);\n       break;\n     case 'p':\n-      buffer->append(\"0x%zx\", info.address);\n+      buffer->append(\"0x%zx\", address);\n       break;\n     case 'm':\n-      buffer->append(\"%s\", StripPathPrefix(info.module, strip_path_prefix));\n+      buffer->append(\"%s\", StripPathPrefix(info->module, strip_path_prefix));\n       break;\n     case 'o':\n-      buffer->append(\"0x%zx\", info.module_offset);\n+      buffer->append(\"0x%zx\", info->module_offset);\n       break;\n     case 'f':\n-      buffer->append(\"%s\",\n-        DemangleFunctionName(\n-          StripFunctionName(info.function, strip_func_prefix)));\n+      buffer->append(\"%s\", DemangleFunctionName(StripFunctionName(\n+                               info->function, strip_func_prefix)));\n       break;\n     case 'q':\n-      buffer->append(\"0x%zx\", info.function_offset != AddressInfo::kUnknown\n-                                  ? info.function_offset\n+      buffer->append(\"0x%zx\", info->function_offset != AddressInfo::kUnknown\n+                                  ? info->function_offset\n                                   : 0x0);\n       break;\n     case 's':\n-      buffer->append(\"%s\", StripPathPrefix(info.file, strip_path_prefix));\n+      buffer->append(\"%s\", StripPathPrefix(info->file, strip_path_prefix));\n       break;\n     case 'l':\n-      buffer->append(\"%d\", info.line);\n+      buffer->append(\"%d\", info->line);\n       break;\n     case 'c':\n-      buffer->append(\"%d\", info.column);\n+      buffer->append(\"%d\", info->column);\n       break;\n     // Smarter special cases.\n     case 'F':\n       // Function name and offset, if file is unknown.\n-      if (info.function) {\n-        buffer->append(\"in %s\",\n-                       DemangleFunctionName(\n-                         StripFunctionName(info.function, strip_func_prefix)));\n-        if (!info.file && info.function_offset != AddressInfo::kUnknown)\n-          buffer->append(\"+0x%zx\", info.function_offset);\n+      if (info->function) {\n+        buffer->append(\"in %s\", DemangleFunctionName(StripFunctionName(\n+                                    info->function, strip_func_prefix)));\n+        if (!info->file && info->function_offset != AddressInfo::kUnknown)\n+          buffer->append(\"+0x%zx\", info->function_offset);\n       }\n       break;\n     case 'S':\n       // File/line information.\n-      RenderSourceLocation(buffer, info.file, info.line, info.column, vs_style,\n-                           strip_path_prefix);\n+      RenderSourceLocation(buffer, info->file, info->line, info->column,\n+                           vs_style, strip_path_prefix);\n       break;\n     case 'L':\n       // Source location, or module location.\n-      if (info.file) {\n-        RenderSourceLocation(buffer, info.file, info.line, info.column,\n+      if (info->file) {\n+        RenderSourceLocation(buffer, info->file, info->line, info->column,\n                              vs_style, strip_path_prefix);\n-      } else if (info.module) {\n-        RenderModuleLocation(buffer, info.module, info.module_offset,\n-                             info.module_arch, strip_path_prefix);\n+      } else if (info->module) {\n+        RenderModuleLocation(buffer, info->module, info->module_offset,\n+                             info->module_arch, strip_path_prefix);\n       } else {\n         buffer->append(\"(<unknown module>)\");\n       }\n       break;\n     case 'M':\n       // Module basename and offset, or PC.\n-      if (info.address & kExternalPCBit)\n-        {} // There PCs are not meaningful.\n-      else if (info.module)\n+      if (address & kExternalPCBit) {\n+        // There PCs are not meaningful.\n+      } else if (info->module) {\n         // Always strip the module name for %M.\n-        RenderModuleLocation(buffer, StripModuleName(info.module),\n-                             info.module_offset, info.module_arch, \"\");\n-      else\n-        buffer->append(\"(%p)\", (void *)info.address);\n+        RenderModuleLocation(buffer, StripModuleName(info->module),\n+                             info->module_offset, info->module_arch, \"\");\n+      } else {\n+        buffer->append(\"(%p)\", (void *)address);\n+      }\n       break;\n     default:\n       Report(\"Unsupported specifier in stack frame format: %c (0x%zx)!\\n\", *p,\n@@ -200,6 +205,29 @@ void RenderFrame(InternalScopedString *buffer, const char *format, int frame_no,\n   }\n }\n \n+bool RenderNeedsSymbolization(const char *format) {\n+  if (0 == internal_strcmp(format, \"DEFAULT\"))\n+    format = kDefaultFormat;\n+  for (const char *p = format; *p != '\\0'; p++) {\n+    if (*p != '%')\n+      continue;\n+    p++;\n+    switch (*p) {\n+      case '%':\n+        break;\n+      case 'n':\n+        // frame_no\n+        break;\n+      case 'p':\n+        // address\n+        break;\n+      default:\n+        return true;\n+    }\n+  }\n+  return false;\n+}\n+\n void RenderData(InternalScopedString *buffer, const char *format,\n                 const DataInfo *DI, const char *strip_path_prefix) {\n   for (const char *p = format; *p != '\\0'; p++) {"}, {"sha": "96119b2ee9e9f8fc0f34c112ba0d2e1eafcb8caf", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_printer.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -47,10 +47,12 @@ namespace __sanitizer {\n //        module+offset if it is known, or (<unknown module>) string.\n //   %M - prints module basename and offset, if it is known, or PC.\n void RenderFrame(InternalScopedString *buffer, const char *format, int frame_no,\n-                 const AddressInfo &info, bool vs_style,\n+                 uptr address, const AddressInfo *info, bool vs_style,\n                  const char *strip_path_prefix = \"\",\n                  const char *strip_func_prefix = \"\");\n \n+bool RenderNeedsSymbolization(const char *format);\n+\n void RenderSourceLocation(InternalScopedString *buffer, const char *file,\n                           int line, int column, bool vs_style,\n                           const char *strip_path_prefix);"}, {"sha": "7eb7c7684af5e5f6584baa9c9a491341f285f527", "filename": "libsanitizer/sanitizer_common/sanitizer_stoptheworld.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -32,13 +32,11 @@ class SuspendedThreadsList {\n \n   // Can't declare pure virtual functions in sanitizer runtimes:\n   // __cxa_pure_virtual might be unavailable. Use UNIMPLEMENTED() instead.\n-  virtual PtraceRegistersStatus GetRegistersAndSP(uptr index, uptr *buffer,\n-                                                  uptr *sp) const {\n+  virtual PtraceRegistersStatus GetRegistersAndSP(\n+      uptr index, InternalMmapVector<uptr> *buffer, uptr *sp) const {\n     UNIMPLEMENTED();\n   }\n \n-  // The buffer in GetRegistersAndSP should be at least this big.\n-  virtual uptr RegisterCount() const { UNIMPLEMENTED(); }\n   virtual uptr ThreadCount() const { UNIMPLEMENTED(); }\n   virtual tid_t GetThreadID(uptr index) const { UNIMPLEMENTED(); }\n "}, {"sha": "6a3c00458efb435b63d439f30b1305449d63e6b3", "filename": "libsanitizer/sanitizer_common/sanitizer_stoptheworld_linux_libcdep.cpp", "status": "modified", "additions": 68, "deletions": 27, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -13,10 +13,10 @@\n \n #include \"sanitizer_platform.h\"\n \n-#if SANITIZER_LINUX && (defined(__x86_64__) || defined(__mips__) || \\\n-                        defined(__aarch64__) || defined(__powerpc64__) || \\\n-                        defined(__s390__) || defined(__i386__) || \\\n-                        defined(__arm__))\n+#if SANITIZER_LINUX &&                                                   \\\n+    (defined(__x86_64__) || defined(__mips__) || defined(__aarch64__) || \\\n+     defined(__powerpc64__) || defined(__s390__) || defined(__i386__) || \\\n+     defined(__arm__) || SANITIZER_RISCV64)\n \n #include \"sanitizer_stoptheworld.h\"\n \n@@ -31,7 +31,7 @@\n #include <sys/types.h> // for pid_t\n #include <sys/uio.h> // for iovec\n #include <elf.h> // for NT_PRSTATUS\n-#if defined(__aarch64__) && !SANITIZER_ANDROID\n+#if (defined(__aarch64__) || SANITIZER_RISCV64) && !SANITIZER_ANDROID\n // GLIBC 2.20+ sys/user does not include asm/ptrace.h\n # include <asm/ptrace.h>\n #endif\n@@ -89,14 +89,14 @@ class SuspendedThreadsListLinux : public SuspendedThreadsList {\n  public:\n   SuspendedThreadsListLinux() { thread_ids_.reserve(1024); }\n \n-  tid_t GetThreadID(uptr index) const;\n-  uptr ThreadCount() const;\n+  tid_t GetThreadID(uptr index) const override;\n+  uptr ThreadCount() const override;\n   bool ContainsTid(tid_t thread_id) const;\n   void Append(tid_t tid);\n \n-  PtraceRegistersStatus GetRegistersAndSP(uptr index, uptr *buffer,\n-                                          uptr *sp) const;\n-  uptr RegisterCount() const;\n+  PtraceRegistersStatus GetRegistersAndSP(uptr index,\n+                                          InternalMmapVector<uptr> *buffer,\n+                                          uptr *sp) const override;\n \n  private:\n   InternalMmapVector<tid_t> thread_ids_;\n@@ -485,6 +485,9 @@ typedef user_regs_struct regs_struct;\n #else\n #define REG_SP rsp\n #endif\n+#define ARCH_IOVEC_FOR_GETREGSET\n+// Compiler may use FP registers to store pointers.\n+static constexpr uptr kExtraRegs[] = {NT_X86_XSTATE, NT_FPREGSET};\n \n #elif defined(__powerpc__) || defined(__powerpc64__)\n typedef pt_regs regs_struct;\n@@ -501,11 +504,19 @@ typedef struct user regs_struct;\n #elif defined(__aarch64__)\n typedef struct user_pt_regs regs_struct;\n #define REG_SP sp\n+static constexpr uptr kExtraRegs[] = {0};\n+#define ARCH_IOVEC_FOR_GETREGSET\n+\n+#elif SANITIZER_RISCV64\n+typedef struct user_regs_struct regs_struct;\n+#define REG_SP sp\n+static constexpr uptr kExtraRegs[] = {0};\n #define ARCH_IOVEC_FOR_GETREGSET\n \n #elif defined(__s390__)\n typedef _user_regs_struct regs_struct;\n #define REG_SP gprs[15]\n+static constexpr uptr kExtraRegs[] = {0};\n #define ARCH_IOVEC_FOR_GETREGSET\n \n #else\n@@ -533,39 +544,69 @@ void SuspendedThreadsListLinux::Append(tid_t tid) {\n }\n \n PtraceRegistersStatus SuspendedThreadsListLinux::GetRegistersAndSP(\n-    uptr index, uptr *buffer, uptr *sp) const {\n+    uptr index, InternalMmapVector<uptr> *buffer, uptr *sp) const {\n   pid_t tid = GetThreadID(index);\n-  regs_struct regs;\n+  constexpr uptr uptr_sz = sizeof(uptr);\n   int pterrno;\n #ifdef ARCH_IOVEC_FOR_GETREGSET\n-  struct iovec regset_io;\n-  regset_io.iov_base = &regs;\n-  regset_io.iov_len = sizeof(regs_struct);\n-  bool isErr = internal_iserror(internal_ptrace(PTRACE_GETREGSET, tid,\n-                                (void*)NT_PRSTATUS, (void*)&regset_io),\n-                                &pterrno);\n+  auto append = [&](uptr regset) {\n+    uptr size = buffer->size();\n+    // NT_X86_XSTATE requires 64bit alignment.\n+    uptr size_up = RoundUpTo(size, 8 / uptr_sz);\n+    buffer->reserve(Max<uptr>(1024, size_up));\n+    struct iovec regset_io;\n+    for (;; buffer->resize(buffer->capacity() * 2)) {\n+      buffer->resize(buffer->capacity());\n+      uptr available_bytes = (buffer->size() - size_up) * uptr_sz;\n+      regset_io.iov_base = buffer->data() + size_up;\n+      regset_io.iov_len = available_bytes;\n+      bool fail =\n+          internal_iserror(internal_ptrace(PTRACE_GETREGSET, tid,\n+                                           (void *)regset, (void *)&regset_io),\n+                           &pterrno);\n+      if (fail) {\n+        VReport(1, \"Could not get regset %p from thread %d (errno %d).\\n\",\n+                (void *)regset, tid, pterrno);\n+        buffer->resize(size);\n+        return false;\n+      }\n+\n+      // Far enough from the buffer size, no need to resize and repeat.\n+      if (regset_io.iov_len + 64 < available_bytes)\n+        break;\n+    }\n+    buffer->resize(size_up + RoundUpTo(regset_io.iov_len, uptr_sz) / uptr_sz);\n+    return true;\n+  };\n+\n+  buffer->clear();\n+  bool fail = !append(NT_PRSTATUS);\n+  if (!fail) {\n+    // Accept the first available and do not report errors.\n+    for (uptr regs : kExtraRegs)\n+      if (regs && append(regs))\n+        break;\n+  }\n #else\n-  bool isErr = internal_iserror(internal_ptrace(PTRACE_GETREGS, tid, nullptr,\n-                                &regs), &pterrno);\n-#endif\n-  if (isErr) {\n+  buffer->resize(RoundUpTo(sizeof(regs_struct), uptr_sz) / uptr_sz);\n+  bool fail = internal_iserror(\n+      internal_ptrace(PTRACE_GETREGS, tid, nullptr, buffer->data()), &pterrno);\n+  if (fail)\n     VReport(1, \"Could not get registers from thread %d (errno %d).\\n\", tid,\n             pterrno);\n+#endif\n+  if (fail) {\n     // ESRCH means that the given thread is not suspended or already dead.\n     // Therefore it's unsafe to inspect its data (e.g. walk through stack) and\n     // we should notify caller about this.\n     return pterrno == ESRCH ? REGISTERS_UNAVAILABLE_FATAL\n                             : REGISTERS_UNAVAILABLE;\n   }\n \n-  *sp = regs.REG_SP;\n-  internal_memcpy(buffer, &regs, sizeof(regs));\n+  *sp = reinterpret_cast<regs_struct *>(buffer->data())[0].REG_SP;\n   return REGISTERS_AVAILABLE;\n }\n \n-uptr SuspendedThreadsListLinux::RegisterCount() const {\n-  return sizeof(regs_struct) / sizeof(uptr);\n-}\n } // namespace __sanitizer\n \n #endif  // SANITIZER_LINUX && (defined(__x86_64__) || defined(__mips__)"}, {"sha": "a605d5b9ff6bd2cc8dbbd7001c2aba624fc85795", "filename": "libsanitizer/sanitizer_common/sanitizer_stoptheworld_mac.cpp", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_mac.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -31,15 +31,15 @@ class SuspendedThreadsListMac : public SuspendedThreadsList {\n  public:\n   SuspendedThreadsListMac() : threads_(1024) {}\n \n-  tid_t GetThreadID(uptr index) const;\n+  tid_t GetThreadID(uptr index) const override;\n   thread_t GetThread(uptr index) const;\n-  uptr ThreadCount() const;\n+  uptr ThreadCount() const override;\n   bool ContainsThread(thread_t thread) const;\n   void Append(thread_t thread);\n \n-  PtraceRegistersStatus GetRegistersAndSP(uptr index, uptr *buffer,\n-                                          uptr *sp) const;\n-  uptr RegisterCount() const;\n+  PtraceRegistersStatus GetRegistersAndSP(uptr index,\n+                                          InternalMmapVector<uptr> *buffer,\n+                                          uptr *sp) const override;\n \n  private:\n   InternalMmapVector<SuspendedThreadInfo> threads_;\n@@ -142,7 +142,7 @@ void SuspendedThreadsListMac::Append(thread_t thread) {\n }\n \n PtraceRegistersStatus SuspendedThreadsListMac::GetRegistersAndSP(\n-    uptr index, uptr *buffer, uptr *sp) const {\n+    uptr index, InternalMmapVector<uptr> *buffer, uptr *sp) const {\n   thread_t thread = GetThread(index);\n   regs_struct regs;\n   int err;\n@@ -159,7 +159,8 @@ PtraceRegistersStatus SuspendedThreadsListMac::GetRegistersAndSP(\n                                         : REGISTERS_UNAVAILABLE;\n   }\n \n-  internal_memcpy(buffer, &regs, sizeof(regs));\n+  buffer->resize(RoundUpTo(sizeof(regs), sizeof(uptr)) / sizeof(uptr));\n+  internal_memcpy(buffer->data(), &regs, sizeof(regs));\n #if defined(__aarch64__) && defined(arm_thread_state64_get_sp)\n   *sp = arm_thread_state64_get_sp(regs);\n #else\n@@ -173,9 +174,6 @@ PtraceRegistersStatus SuspendedThreadsListMac::GetRegistersAndSP(\n   return REGISTERS_AVAILABLE;\n }\n \n-uptr SuspendedThreadsListMac::RegisterCount() const {\n-  return MACHINE_THREAD_STATE_COUNT;\n-}\n } // namespace __sanitizer\n \n #endif  // SANITIZER_MAC && (defined(__x86_64__) || defined(__aarch64__)) ||"}, {"sha": "70df31e6351cb9ea2025d8fbc7b5d714893ce0a1", "filename": "libsanitizer/sanitizer_common/sanitizer_stoptheworld_netbsd_libcdep.cpp", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_netbsd_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_netbsd_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_netbsd_libcdep.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -57,9 +57,9 @@ class SuspendedThreadsListNetBSD : public SuspendedThreadsList {\n   bool ContainsTid(tid_t thread_id) const;\n   void Append(tid_t tid);\n \n-  PtraceRegistersStatus GetRegistersAndSP(uptr index, uptr *buffer,\n+  PtraceRegistersStatus GetRegistersAndSP(uptr index,\n+                                          InternalMmapVector<uptr> *buffer,\n                                           uptr *sp) const;\n-  uptr RegisterCount() const;\n \n  private:\n   InternalMmapVector<tid_t> thread_ids_;\n@@ -131,7 +131,7 @@ bool ThreadSuspender::SuspendAllThreads() {\n   pl.pl_lwpid = 0;\n \n   int val;\n-  while ((val = ptrace(op, pid_, (void *)&pl, sizeof(pl))) != -1 &&\n+  while ((val = internal_ptrace(op, pid_, (void *)&pl, sizeof(pl))) != -1 &&\n          pl.pl_lwpid != 0) {\n     suspended_threads_list_.Append(pl.pl_lwpid);\n     VReport(2, \"Appended thread %d in process %d.\\n\", pl.pl_lwpid, pid_);\n@@ -335,7 +335,7 @@ void SuspendedThreadsListNetBSD::Append(tid_t tid) {\n }\n \n PtraceRegistersStatus SuspendedThreadsListNetBSD::GetRegistersAndSP(\n-    uptr index, uptr *buffer, uptr *sp) const {\n+    uptr index, InternalMmapVector<uptr> *buffer, uptr *sp) const {\n   lwpid_t tid = GetThreadID(index);\n   pid_t ppid = internal_getppid();\n   struct reg regs;\n@@ -351,14 +351,12 @@ PtraceRegistersStatus SuspendedThreadsListNetBSD::GetRegistersAndSP(\n   }\n \n   *sp = PTRACE_REG_SP(&regs);\n-  internal_memcpy(buffer, &regs, sizeof(regs));\n+  buffer->resize(RoundUpTo(sizeof(regs), sizeof(uptr)) / sizeof(uptr));\n+  internal_memcpy(buffer->data(), &regs, sizeof(regs));\n \n   return REGISTERS_AVAILABLE;\n }\n \n-uptr SuspendedThreadsListNetBSD::RegisterCount() const {\n-  return sizeof(struct reg) / sizeof(uptr);\n-}\n }  // namespace __sanitizer\n \n #endif"}, {"sha": "311d676439c0b9ec4a4c26ad116eb667309329ab", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_libcdep.cpp", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -12,6 +12,7 @@\n \n #include \"sanitizer_allocator_internal.h\"\n #include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_platform.h\"\n #include \"sanitizer_symbolizer_internal.h\"\n \n namespace __sanitizer {\n@@ -258,6 +259,8 @@ class LLVMSymbolizerProcess : public SymbolizerProcess {\n     const char* const kSymbolizerArch = \"--default-arch=x86_64\";\n #elif defined(__i386__)\n     const char* const kSymbolizerArch = \"--default-arch=i386\";\n+#elif SANITIZER_RISCV64\n+    const char *const kSymbolizerArch = \"--default-arch=riscv64\";\n #elif defined(__aarch64__)\n     const char* const kSymbolizerArch = \"--default-arch=arm64\";\n #elif defined(__arm__)\n@@ -275,8 +278,8 @@ class LLVMSymbolizerProcess : public SymbolizerProcess {\n #endif\n \n     const char *const inline_flag = common_flags()->symbolize_inline_frames\n-                                        ? \"--inlining=true\"\n-                                        : \"--inlining=false\";\n+                                        ? \"--inlines\"\n+                                        : \"--no-inlines\";\n     int i = 0;\n     argv[i++] = path_to_binary;\n     argv[i++] = inline_flag;"}, {"sha": "f0f150871d3a73e86aa1fb3ce9c3770796c62ace", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_mac.cpp", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -33,8 +33,15 @@ bool DlAddrSymbolizer::SymbolizePC(uptr addr, SymbolizedStack *stack) {\n   int result = dladdr((const void *)addr, &info);\n   if (!result) return false;\n \n-  CHECK(addr >= reinterpret_cast<uptr>(info.dli_saddr));\n-  stack->info.function_offset = addr - reinterpret_cast<uptr>(info.dli_saddr);\n+  // Compute offset if possible. `dladdr()` doesn't always ensure that `addr >=\n+  // sym_addr` so only compute the offset when this holds. Failure to find the\n+  // function offset is not treated as a failure because it might still be\n+  // possible to get the symbol name.\n+  uptr sym_addr = reinterpret_cast<uptr>(info.dli_saddr);\n+  if (addr >= sym_addr) {\n+    stack->info.function_offset = addr - sym_addr;\n+  }\n+\n   const char *demangled = DemangleSwiftAndCXX(info.dli_sname);\n   if (!demangled) return false;\n   stack->info.function = internal_strdup(demangled);\n@@ -123,7 +130,7 @@ class AtosSymbolizerProcess : public SymbolizerProcess {\n     argv[i++] = path_to_binary;\n     argv[i++] = \"-p\";\n     argv[i++] = &pid_str_[0];\n-    if (GetMacosVersion() == MACOS_VERSION_MAVERICKS) {\n+    if (GetMacosAlignedVersion() == MacosVersion(10, 9)) {\n       // On Mavericks atos prints a deprecation warning which we suppress by\n       // passing -d. The warning isn't present on other OSX versions, even the\n       // newer ones.\n@@ -219,10 +226,10 @@ bool AtosSymbolizer::SymbolizePC(uptr addr, SymbolizedStack *stack) {\n       start_address = reinterpret_cast<uptr>(info.dli_saddr);\n   }\n \n-  // Only assig to `function_offset` if we were able to get the function's\n-  // start address.\n-  if (start_address != AddressInfo::kUnknown) {\n-    CHECK(addr >= start_address);\n+  // Only assign to `function_offset` if we were able to get the function's\n+  // start address and we got a sensible `start_address` (dladdr doesn't always\n+  // ensure that `addr >= sym_addr`).\n+  if (start_address != AddressInfo::kUnknown && addr >= start_address) {\n     stack->info.function_offset = addr - start_address;\n   }\n   return true;"}, {"sha": "30cba08ed53907de27af3902851af05dc53fce6d", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_markup.cpp", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_markup.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_markup.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_markup.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -83,11 +83,14 @@ void RenderData(InternalScopedString *buffer, const char *format,\n   buffer->append(kFormatData, DI->start);\n }\n \n+bool RenderNeedsSymbolization(const char *format) { return false; }\n+\n // We don't support the stack_trace_format flag at all.\n void RenderFrame(InternalScopedString *buffer, const char *format, int frame_no,\n-                 const AddressInfo &info, bool vs_style,\n+                 uptr address, const AddressInfo *info, bool vs_style,\n                  const char *strip_path_prefix, const char *strip_func_prefix) {\n-  buffer->append(kFormatFrame, frame_no, info.address);\n+  CHECK(!RenderNeedsSymbolization(format));\n+  buffer->append(kFormatFrame, frame_no, address);\n }\n \n Symbolizer *Symbolizer::PlatformInit() {"}, {"sha": "3c379a8480250fbd46c11a1bed165334cb48202c", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_posix_libcdep.cpp", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -78,13 +78,6 @@ static void InitializeSwiftDemangler() {\n // Attempts to demangle a Swift name. The demangler will return nullptr if a\n // non-Swift name is passed in.\n const char *DemangleSwift(const char *name) {\n-  if (!name) return nullptr;\n-\n-  // Check if we are dealing with a Swift mangled name first.\n-  if (name[0] != '_' || name[1] != 'T') {\n-    return nullptr;\n-  }\n-\n   if (swift_demangle_f)\n     return swift_demangle_f(name, internal_strlen(name), 0, 0, 0);\n \n@@ -321,9 +314,10 @@ class Addr2LinePool : public SymbolizerTool {\n \n #if SANITIZER_SUPPORTS_WEAK_HOOKS\n extern \"C\" {\n-SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-bool __sanitizer_symbolize_code(const char *ModuleName, u64 ModuleOffset,\n-                                char *Buffer, int MaxLength);\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE bool\n+__sanitizer_symbolize_code(const char *ModuleName, u64 ModuleOffset,\n+                           char *Buffer, int MaxLength,\n+                           bool SymbolizeInlineFrames);\n SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n bool __sanitizer_symbolize_data(const char *ModuleName, u64 ModuleOffset,\n                                 char *Buffer, int MaxLength);\n@@ -346,7 +340,8 @@ class InternalSymbolizer : public SymbolizerTool {\n \n   bool SymbolizePC(uptr addr, SymbolizedStack *stack) override {\n     bool result = __sanitizer_symbolize_code(\n-        stack->info.module, stack->info.module_offset, buffer_, kBufferSize);\n+        stack->info.module, stack->info.module_offset, buffer_, kBufferSize,\n+        common_flags()->symbolize_inline_frames);\n     if (result) ParseSymbolizePCOutput(buffer_, stack);\n     return result;\n   }"}, {"sha": "06301b83ea1f0ced884b51a843b7068041533259", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_report.cpp", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_report.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_report.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_report.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -33,7 +33,8 @@ void ReportErrorSummary(const char *error_type, const AddressInfo &info,\n   if (!common_flags()->print_summary) return;\n   InternalScopedString buff(kMaxSummaryLength);\n   buff.append(\"%s \", error_type);\n-  RenderFrame(&buff, \"%L %F\", 0, info, common_flags()->symbolize_vs_style,\n+  RenderFrame(&buff, \"%L %F\", 0, info.address, &info,\n+              common_flags()->symbolize_vs_style,\n               common_flags()->strip_path_prefix);\n   ReportErrorSummary(buff.data(), alt_tool_name);\n }\n@@ -47,14 +48,14 @@ bool ReportFile::SupportsColors() {\n   return SupportsColoredOutput(fd);\n }\n \n-static INLINE bool ReportSupportsColors() {\n+static inline bool ReportSupportsColors() {\n   return report_file.SupportsColors();\n }\n \n #else  // SANITIZER_FUCHSIA\n \n // Fuchsia's logs always go through post-processing that handles colorization.\n-static INLINE bool ReportSupportsColors() { return true; }\n+static inline bool ReportSupportsColors() { return true; }\n \n #endif  // !SANITIZER_FUCHSIA\n "}, {"sha": "89c12602057c7336d3c18503b566229d8169ed43", "filename": "libsanitizer/sanitizer_common/sanitizer_syscall_linux_riscv64.inc", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_riscv64.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_riscv64.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_riscv64.inc?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -0,0 +1,174 @@\n+//===-- sanitizer_syscall_linux_riscv64.inc ---------------------*- C++ -*-===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Implementations of internal_syscall and internal_iserror for Linux/riscv64.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+// About local register variables:\n+// https://gcc.gnu.org/onlinedocs/gcc/Local-Register-Variables.html#Local-Register-Variables\n+//\n+// Kernel ABI...\n+// To my surprise I haven't found much information regarding it.\n+// Kernel source and internet browsing shows that:\n+//  syscall number is passed in a7\n+//  (http://man7.org/linux/man-pages/man2/syscall.2.html) results are return in\n+//  a0 and a1 (http://man7.org/linux/man-pages/man2/syscall.2.html) arguments\n+//  are passed in: a0-a7 (see below)\n+//\n+//  Regarding the arguments. The only \"documentation\" I could find is\n+//  this comment (!!!) by Bruce Hold on google forums (!!!):\n+//    https://groups.google.com/a/groups.riscv.org/forum/#!topic/sw-dev/exbrzM3GZDQ\n+//    Confirmed by inspecting glibc sources.\n+//  Great way to document things.\n+#define SYSCALL(name) __NR_##name\n+\n+#define INTERNAL_SYSCALL_CLOBBERS \"memory\"\n+\n+static uptr __internal_syscall(u64 nr) {\n+  register u64 a7 asm(\"a7\") = nr;\n+  register u64 a0 asm(\"a0\");\n+  __asm__ volatile(\"ecall\\n\\t\"\n+                   : \"=r\"(a0)\n+                   : \"r\"(a7)\n+                   : INTERNAL_SYSCALL_CLOBBERS);\n+  return a0;\n+}\n+#define __internal_syscall0(n) (__internal_syscall)(n)\n+\n+static uptr __internal_syscall(u64 nr, u64 arg1) {\n+  register u64 a7 asm(\"a7\") = nr;\n+  register u64 a0 asm(\"a0\") = arg1;\n+  __asm__ volatile(\"ecall\\n\\t\"\n+                   : \"+r\"(a0)\n+                   : \"r\"(a7)\n+                   : INTERNAL_SYSCALL_CLOBBERS);\n+  return a0;\n+}\n+#define __internal_syscall1(n, a1) (__internal_syscall)(n, (u64)(a1))\n+\n+static uptr __internal_syscall(u64 nr, u64 arg1, long arg2) {\n+  register u64 a7 asm(\"a7\") = nr;\n+  register u64 a0 asm(\"a0\") = arg1;\n+  register u64 a1 asm(\"a1\") = arg2;\n+  __asm__ volatile(\"ecall\\n\\t\"\n+                   : \"+r\"(a0)\n+                   : \"r\"(a7), \"r\"(a1)\n+                   : INTERNAL_SYSCALL_CLOBBERS);\n+  return a0;\n+}\n+#define __internal_syscall2(n, a1, a2) \\\n+  (__internal_syscall)(n, (u64)(a1), (long)(a2))\n+\n+static uptr __internal_syscall(u64 nr, u64 arg1, long arg2, long arg3) {\n+  register u64 a7 asm(\"a7\") = nr;\n+  register u64 a0 asm(\"a0\") = arg1;\n+  register u64 a1 asm(\"a1\") = arg2;\n+  register u64 a2 asm(\"a2\") = arg3;\n+  __asm__ volatile(\"ecall\\n\\t\"\n+                   : \"+r\"(a0)\n+                   : \"r\"(a7), \"r\"(a1), \"r\"(a2)\n+                   : INTERNAL_SYSCALL_CLOBBERS);\n+  return a0;\n+}\n+#define __internal_syscall3(n, a1, a2, a3) \\\n+  (__internal_syscall)(n, (u64)(a1), (long)(a2), (long)(a3))\n+\n+static uptr __internal_syscall(u64 nr, u64 arg1, long arg2, long arg3,\n+                               u64 arg4) {\n+  register u64 a7 asm(\"a7\") = nr;\n+  register u64 a0 asm(\"a0\") = arg1;\n+  register u64 a1 asm(\"a1\") = arg2;\n+  register u64 a2 asm(\"a2\") = arg3;\n+  register u64 a3 asm(\"a3\") = arg4;\n+  __asm__ volatile(\"ecall\\n\\t\"\n+                   : \"+r\"(a0)\n+                   : \"r\"(a7), \"r\"(a1), \"r\"(a2), \"r\"(a3)\n+                   : INTERNAL_SYSCALL_CLOBBERS);\n+  return a0;\n+}\n+#define __internal_syscall4(n, a1, a2, a3, a4) \\\n+  (__internal_syscall)(n, (u64)(a1), (long)(a2), (long)(a3), (long)(a4))\n+\n+static uptr __internal_syscall(u64 nr, u64 arg1, long arg2, long arg3, u64 arg4,\n+                               long arg5) {\n+  register u64 a7 asm(\"a7\") = nr;\n+  register u64 a0 asm(\"a0\") = arg1;\n+  register u64 a1 asm(\"a1\") = arg2;\n+  register u64 a2 asm(\"a2\") = arg3;\n+  register u64 a3 asm(\"a3\") = arg4;\n+  register u64 a4 asm(\"a4\") = arg5;\n+  __asm__ volatile(\"ecall\\n\\t\"\n+                   : \"+r\"(a0)\n+                   : \"r\"(a7), \"r\"(a1), \"r\"(a2), \"r\"(a3), \"r\"(a4)\n+                   : INTERNAL_SYSCALL_CLOBBERS);\n+  return a0;\n+}\n+#define __internal_syscall5(n, a1, a2, a3, a4, a5)                       \\\n+  (__internal_syscall)(n, (u64)(a1), (long)(a2), (long)(a3), (long)(a4), \\\n+                       (u64)(a5))\n+\n+static uptr __internal_syscall(u64 nr, u64 arg1, long arg2, long arg3, u64 arg4,\n+                               long arg5, long arg6) {\n+  register u64 a7 asm(\"a7\") = nr;\n+  register u64 a0 asm(\"a0\") = arg1;\n+  register u64 a1 asm(\"a1\") = arg2;\n+  register u64 a2 asm(\"a2\") = arg3;\n+  register u64 a3 asm(\"a3\") = arg4;\n+  register u64 a4 asm(\"a4\") = arg5;\n+  register u64 a5 asm(\"a5\") = arg6;\n+  __asm__ volatile(\"ecall\\n\\t\"\n+                   : \"+r\"(a0)\n+                   : \"r\"(a7), \"r\"(a1), \"r\"(a2), \"r\"(a3), \"r\"(a4), \"r\"(a5)\n+                   : INTERNAL_SYSCALL_CLOBBERS);\n+  return a0;\n+}\n+#define __internal_syscall6(n, a1, a2, a3, a4, a5, a6)                   \\\n+  (__internal_syscall)(n, (u64)(a1), (long)(a2), (long)(a3), (long)(a4), \\\n+                       (u64)(a5), (long)(a6))\n+\n+static uptr __internal_syscall(u64 nr, u64 arg1, long arg2, long arg3, u64 arg4,\n+                               long arg5, long arg6, long arg7) {\n+  register u64 a7 asm(\"a7\") = nr;\n+  register u64 a0 asm(\"a0\") = arg1;\n+  register u64 a1 asm(\"a1\") = arg2;\n+  register u64 a2 asm(\"a2\") = arg3;\n+  register u64 a3 asm(\"a3\") = arg4;\n+  register u64 a4 asm(\"a4\") = arg5;\n+  register u64 a5 asm(\"a5\") = arg6;\n+  register u64 a6 asm(\"a6\") = arg7;\n+  __asm__ volatile(\"ecall\\n\\t\"\n+                   : \"+r\"(a0)\n+                   : \"r\"(a7), \"r\"(a1), \"r\"(a2), \"r\"(a3), \"r\"(a4), \"r\"(a5),\n+                     \"r\"(a6)\n+                   : INTERNAL_SYSCALL_CLOBBERS);\n+  return a0;\n+}\n+#define __internal_syscall7(n, a1, a2, a3, a4, a5, a6, a7)               \\\n+  (__internal_syscall)(n, (u64)(a1), (long)(a2), (long)(a3), (long)(a4), \\\n+                       (u64)(a5), (long)(a6), (long)(a7))\n+\n+#define __SYSCALL_NARGS_X(a1, a2, a3, a4, a5, a6, a7, a8, n, ...) n\n+#define __SYSCALL_NARGS(...) \\\n+  __SYSCALL_NARGS_X(__VA_ARGS__, 7, 6, 5, 4, 3, 2, 1, 0, )\n+#define __SYSCALL_CONCAT_X(a, b) a##b\n+#define __SYSCALL_CONCAT(a, b) __SYSCALL_CONCAT_X(a, b)\n+#define __SYSCALL_DISP(b, ...) \\\n+  __SYSCALL_CONCAT(b, __SYSCALL_NARGS(__VA_ARGS__))(__VA_ARGS__)\n+\n+#define internal_syscall(...) __SYSCALL_DISP(__internal_syscall, __VA_ARGS__)\n+\n+// Helper function used to avoid clobbering of errno.\n+bool internal_iserror(uptr retval, int *rverrno) {\n+  if (retval >= (uptr)-4095) {\n+    if (rverrno)\n+      *rverrno = -retval;\n+    return true;\n+  }\n+  return false;\n+}"}, {"sha": "c4a9d99fe2f014c738de0dc85a4424cdb4e3b76e", "filename": "libsanitizer/sanitizer_common/sanitizer_syscalls_netbsd.inc", "status": "modified", "additions": 113, "deletions": 6, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscalls_netbsd.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscalls_netbsd.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscalls_netbsd.inc?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -42,8 +42,8 @@\n // DO NOT EDIT! THIS FILE HAS BEEN GENERATED!\n //\n // Generated with: generate_netbsd_syscalls.awk\n-// Generated date: 2019-12-24\n-// Generated from: syscalls.master,v 1.296 2019/09/22 22:59:39 christos Exp\n+// Generated date: 2020-09-10\n+// Generated from: syscalls.master,v 1.306 2020/08/14 00:53:16 riastradh Exp\n //\n //===----------------------------------------------------------------------===//\n \n@@ -872,7 +872,13 @@ PRE_SYSCALL(dup2)(long long from_, long long to_) { /* Nothing to do */ }\n POST_SYSCALL(dup2)(long long res, long long from_, long long to_) {\n   /* Nothing to do */\n }\n-/* syscall 91 has been skipped */\n+PRE_SYSCALL(getrandom)(void *buf_, long long buflen_, long long flags_) {\n+  /* TODO */\n+}\n+POST_SYSCALL(getrandom)\n+(long long res, void *buf_, long long buflen_, long long flags_) {\n+  /* TODO */\n+}\n PRE_SYSCALL(fcntl)(long long fd_, long long cmd_, void *arg_) {\n   /* Nothing to do */\n }\n@@ -1332,9 +1338,29 @@ PRE_SYSCALL(compat_09_ouname)(void *name_) { /* TODO */ }\n POST_SYSCALL(compat_09_ouname)(long long res, void *name_) { /* TODO */ }\n PRE_SYSCALL(sysarch)(long long op_, void *parms_) { /* TODO */ }\n POST_SYSCALL(sysarch)(long long res, long long op_, void *parms_) { /* TODO */ }\n-/* syscall 166 has been skipped */\n-/* syscall 167 has been skipped */\n-/* syscall 168 has been skipped */\n+PRE_SYSCALL(__futex)\n+(void *uaddr_, long long op_, long long val_, void *timeout_, void *uaddr2_,\n+  long long val2_, long long val3_) {\n+  /* TODO */\n+}\n+POST_SYSCALL(__futex)\n+(long long res, void *uaddr_, long long op_, long long val_, void *timeout_,\n+  void *uaddr2_, long long val2_, long long val3_) {\n+  /* TODO */\n+}\n+PRE_SYSCALL(__futex_set_robust_list)(void *head_, long long len_) { /* TODO */ }\n+POST_SYSCALL(__futex_set_robust_list)\n+(long long res, void *head_, long long len_) {\n+  /* TODO */\n+}\n+PRE_SYSCALL(__futex_get_robust_list)\n+(long long lwpid_, void **headp_, void *lenp_) {\n+  /* TODO */\n+}\n+POST_SYSCALL(__futex_get_robust_list)\n+(long long res, long long lwpid_, void **headp_, void *lenp_) {\n+  /* TODO */\n+}\n #if !defined(_LP64)\n PRE_SYSCALL(compat_10_osemsys)\n (long long which_, long long a2_, long long a3_, long long a4_, long long a5_) {\n@@ -3824,6 +3850,87 @@ PRE_SYSCALL(__fhstatvfs190)\n }\n POST_SYSCALL(__fhstatvfs190)\n (long long res, void *fhp_, long long fh_size_, void *buf_, long long flags_) {}\n+PRE_SYSCALL(__acl_get_link)(void *path_, long long type_, void *aclp_) {\n+  /* TODO */\n+}\n+POST_SYSCALL(__acl_get_link)\n+(long long res, void *path_, long long type_, void *aclp_) {\n+  /* TODO */\n+}\n+PRE_SYSCALL(__acl_set_link)(void *path_, long long type_, void *aclp_) {\n+  /* TODO */\n+}\n+POST_SYSCALL(__acl_set_link)\n+(long long res, void *path_, long long type_, void *aclp_) {\n+  /* TODO */\n+}\n+PRE_SYSCALL(__acl_delete_link)(void *path_, long long type_) { /* TODO */ }\n+POST_SYSCALL(__acl_delete_link)(long long res, void *path_, long long type_) {\n+  /* TODO */\n+}\n+PRE_SYSCALL(__acl_aclcheck_link)(void *path_, long long type_, void *aclp_) {\n+  /* TODO */\n+}\n+POST_SYSCALL(__acl_aclcheck_link)\n+(long long res, void *path_, long long type_, void *aclp_) {\n+  /* TODO */\n+}\n+PRE_SYSCALL(__acl_get_file)(void *path_, long long type_, void *aclp_) {\n+  /* TODO */\n+}\n+POST_SYSCALL(__acl_get_file)\n+(long long res, void *path_, long long type_, void *aclp_) {\n+  /* TODO */\n+}\n+PRE_SYSCALL(__acl_set_file)(void *path_, long long type_, void *aclp_) {\n+  /* TODO */\n+}\n+POST_SYSCALL(__acl_set_file)\n+(long long res, void *path_, long long type_, void *aclp_) {\n+  /* TODO */\n+}\n+PRE_SYSCALL(__acl_get_fd)(long long filedes_, long long type_, void *aclp_) {\n+  /* TODO */\n+}\n+POST_SYSCALL(__acl_get_fd)\n+(long long res, long long filedes_, long long type_, void *aclp_) {\n+  /* TODO */\n+}\n+PRE_SYSCALL(__acl_set_fd)(long long filedes_, long long type_, void *aclp_) {\n+  /* TODO */\n+}\n+POST_SYSCALL(__acl_set_fd)\n+(long long res, long long filedes_, long long type_, void *aclp_) {\n+  /* TODO */\n+}\n+PRE_SYSCALL(__acl_delete_file)(void *path_, long long type_) { /* TODO */ }\n+POST_SYSCALL(__acl_delete_file)(long long res, void *path_, long long type_) {\n+  /* TODO */\n+}\n+PRE_SYSCALL(__acl_delete_fd)(long long filedes_, long long type_) { /* TODO */ }\n+POST_SYSCALL(__acl_delete_fd)\n+(long long res, long long filedes_, long long type_) {\n+  /* TODO */\n+}\n+PRE_SYSCALL(__acl_aclcheck_file)(void *path_, long long type_, void *aclp_) {\n+  /* TODO */\n+}\n+POST_SYSCALL(__acl_aclcheck_file)\n+(long long res, void *path_, long long type_, void *aclp_) {\n+  /* TODO */\n+}\n+PRE_SYSCALL(__acl_aclcheck_fd)\n+(long long filedes_, long long type_, void *aclp_) {\n+  /* TODO */\n+}\n+POST_SYSCALL(__acl_aclcheck_fd)\n+(long long res, long long filedes_, long long type_, void *aclp_) {\n+  /* TODO */\n+}\n+PRE_SYSCALL(lpathconf)(void *path_, long long name_) { /* TODO */ }\n+POST_SYSCALL(lpathconf)(long long res, void *path_, long long name_) {\n+  /* TODO */\n+}\n #undef SYS_MAXSYSARGS\n } // extern \"C\"\n "}, {"sha": "53a537d3984754b43a9f709561997942eaf7e670", "filename": "libsanitizer/sanitizer_common/sanitizer_win.cpp", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -348,6 +348,22 @@ bool DontDumpShadowMemory(uptr addr, uptr length) {\n   return true;\n }\n \n+uptr MapDynamicShadow(uptr shadow_size_bytes, uptr shadow_scale,\n+                      uptr min_shadow_base_alignment,\n+                      UNUSED uptr &high_mem_end) {\n+  const uptr granularity = GetMmapGranularity();\n+  const uptr alignment =\n+      Max<uptr>(granularity << shadow_scale, 1ULL << min_shadow_base_alignment);\n+  const uptr left_padding =\n+      Max<uptr>(granularity, 1ULL << min_shadow_base_alignment);\n+  uptr space_size = shadow_size_bytes + left_padding;\n+  uptr shadow_start = FindAvailableMemoryRange(space_size, alignment,\n+                                               granularity, nullptr, nullptr);\n+  CHECK_NE((uptr)0, shadow_start);\n+  CHECK(IsAligned(shadow_start, alignment));\n+  return shadow_start;\n+}\n+\n uptr FindAvailableMemoryRange(uptr size, uptr alignment, uptr left_padding,\n                               uptr *largest_gap_found,\n                               uptr *max_occupied_addr) {"}, {"sha": "94e0b50fed3607d184738339fa04e38276aa9c25", "filename": "libsanitizer/tsan/tsan_dispatch_defs.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_dispatch_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_dispatch_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_dispatch_defs.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -51,11 +51,18 @@ extern const dispatch_block_t _dispatch_data_destructor_munmap;\n #define DISPATCH_DATA_DESTRUCTOR_MUNMAP  _dispatch_data_destructor_munmap\n \n #if __has_attribute(noescape)\n-  #define DISPATCH_NOESCAPE __attribute__((__noescape__))\n+# define DISPATCH_NOESCAPE __attribute__((__noescape__))\n #else\n-  #define DISPATCH_NOESCAPE\n+# define DISPATCH_NOESCAPE\n #endif\n \n+#if SANITIZER_MAC\n+# define SANITIZER_WEAK_IMPORT extern \"C\" __attribute((weak_import))\n+#else\n+# define SANITIZER_WEAK_IMPORT extern \"C\" __attribute((weak))\n+#endif\n+\n+\n // Data types used in dispatch APIs\n typedef unsigned long size_t;\n typedef unsigned long uintptr_t;"}, {"sha": "466b2bf0f66ce5fa7e71008c2b7704929b8771f9", "filename": "libsanitizer/tsan/tsan_external.cpp", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_external.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_external.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_external.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -11,6 +11,7 @@\n //===----------------------------------------------------------------------===//\n #include \"tsan_rtl.h\"\n #include \"tsan_interceptors.h\"\n+#include \"sanitizer_common/sanitizer_ptrauth.h\"\n \n namespace __tsan {\n \n@@ -57,13 +58,13 @@ uptr TagFromShadowStackFrame(uptr pc) {\n #if !SANITIZER_GO\n \n typedef void(*AccessFunc)(ThreadState *, uptr, uptr, int);\n-void ExternalAccess(void *addr, void *caller_pc, void *tag, AccessFunc access) {\n+void ExternalAccess(void *addr, uptr caller_pc, void *tag, AccessFunc access) {\n   CHECK_LT(tag, atomic_load(&used_tags, memory_order_relaxed));\n   ThreadState *thr = cur_thread();\n-  if (caller_pc) FuncEntry(thr, (uptr)caller_pc);\n+  if (caller_pc) FuncEntry(thr, caller_pc);\n   InsertShadowStackFrameForTag(thr, (uptr)tag);\n   bool in_ignored_lib;\n-  if (!caller_pc || !libignore()->IsIgnored((uptr)caller_pc, &in_ignored_lib)) {\n+  if (!caller_pc || !libignore()->IsIgnored(caller_pc, &in_ignored_lib)) {\n     access(thr, CALLERPC, (uptr)addr, kSizeLog1);\n   }\n   FuncExit(thr);\n@@ -110,12 +111,12 @@ void __tsan_external_assign_tag(void *addr, void *tag) {\n \n SANITIZER_INTERFACE_ATTRIBUTE\n void __tsan_external_read(void *addr, void *caller_pc, void *tag) {\n-  ExternalAccess(addr, caller_pc, tag, MemoryRead);\n+  ExternalAccess(addr, STRIP_PC(caller_pc), tag, MemoryRead);\n }\n \n SANITIZER_INTERFACE_ATTRIBUTE\n void __tsan_external_write(void *addr, void *caller_pc, void *tag) {\n-  ExternalAccess(addr, caller_pc, tag, MemoryWrite);\n+  ExternalAccess(addr, STRIP_PC(caller_pc), tag, MemoryWrite);\n }\n }  // extern \"C\"\n "}, {"sha": "49e4a9c21da9c7a7ea5e25ac151ab71e681e126a", "filename": "libsanitizer/tsan/tsan_flags.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_flags.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_flags.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_flags.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -87,7 +87,7 @@ void InitializeFlags(Flags *f, const char *env, const char *env_option_name) {\n   // Let a frontend override.\n   parser.ParseString(__tsan_default_options());\n #if TSAN_CONTAINS_UBSAN\n-  const char *ubsan_default_options = __ubsan::MaybeCallUbsanDefaultOptions();\n+  const char *ubsan_default_options = __ubsan_default_options();\n   ubsan_parser.ParseString(ubsan_default_options);\n #endif\n   // Override from command line."}, {"sha": "2105c754486f08cb666ac77b179ff8410f5ae6ff", "filename": "libsanitizer/tsan/tsan_flags.inc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_flags.inc?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -76,6 +76,8 @@ TSAN_FLAG(int, io_sync, 1,\n TSAN_FLAG(bool, die_after_fork, true,\n           \"Die after multi-threaded fork if the child creates new threads.\")\n TSAN_FLAG(const char *, suppressions, \"\", \"Suppressions file name.\")\n+TSAN_FLAG(bool, ignore_interceptors_accesses, SANITIZER_MAC ? true : false,\n+          \"Ignore reads and writes from all interceptors.\")\n TSAN_FLAG(bool, ignore_noninstrumented_modules, SANITIZER_MAC ? true : false,\n           \"Interceptors should only detect races when called from instrumented \"\n           \"modules.\")"}, {"sha": "29576ea2d49ad92e08365bda8c6ac1fce0190924", "filename": "libsanitizer/tsan/tsan_interceptors.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -22,7 +22,7 @@ class ScopedInterceptor {\n LibIgnore *libignore();\n \n #if !SANITIZER_GO\n-INLINE bool in_symbolizer() {\n+inline bool in_symbolizer() {\n   cur_thread_init();\n   return UNLIKELY(cur_thread()->in_symbolizer);\n }"}, {"sha": "cbbb7ecb2397e40150c921b4b32f353a2396efef", "filename": "libsanitizer/tsan/tsan_interceptors_libdispatch.cpp", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_interceptors_libdispatch.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_interceptors_libdispatch.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors_libdispatch.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -19,6 +19,10 @@\n #include \"BlocksRuntime/Block.h\"\n #include \"tsan_dispatch_defs.h\"\n \n+#if SANITIZER_MAC\n+# include <Availability.h>\n+#endif\n+\n namespace __tsan {\n   typedef u16 uint16_t;\n \n@@ -219,6 +223,30 @@ static void invoke_and_release_block(void *param) {\n DISPATCH_INTERCEPT(dispatch, false)\n DISPATCH_INTERCEPT(dispatch_barrier, true)\n \n+// dispatch_async_and_wait() and friends were introduced in macOS 10.14.\n+// Linking of these interceptors fails when using an older SDK.\n+#if !SANITIZER_MAC || defined(__MAC_10_14)\n+// macOS 10.14 is greater than our minimal deployment target.  To ensure we\n+// generate a weak reference so the TSan dylib continues to work on older\n+// systems, we need to forward declare the intercepted functions as \"weak\n+// imports\".   Note that this file is multi-platform, so we cannot include the\n+// actual header file (#include <dispatch/dispatch.h>).\n+SANITIZER_WEAK_IMPORT void dispatch_async_and_wait(\n+    dispatch_queue_t queue, DISPATCH_NOESCAPE dispatch_block_t block);\n+SANITIZER_WEAK_IMPORT void dispatch_async_and_wait_f(\n+    dispatch_queue_t queue, void *context, dispatch_function_t work);\n+SANITIZER_WEAK_IMPORT void dispatch_barrier_async_and_wait(\n+    dispatch_queue_t queue, DISPATCH_NOESCAPE dispatch_block_t block);\n+SANITIZER_WEAK_IMPORT void dispatch_barrier_async_and_wait_f(\n+    dispatch_queue_t queue, void *context, dispatch_function_t work);\n+\n+DISPATCH_INTERCEPT_SYNC_F(dispatch_async_and_wait_f, false)\n+DISPATCH_INTERCEPT_SYNC_B(dispatch_async_and_wait, false)\n+DISPATCH_INTERCEPT_SYNC_F(dispatch_barrier_async_and_wait_f, true)\n+DISPATCH_INTERCEPT_SYNC_B(dispatch_barrier_async_and_wait, true)\n+#endif\n+\n+\n DECLARE_REAL(void, dispatch_after_f, dispatch_time_t when,\n              dispatch_queue_t queue, void *context, dispatch_function_t work)\n \n@@ -746,6 +774,10 @@ void InitializeLibdispatchInterceptors() {\n   INTERCEPT_FUNCTION(dispatch_barrier_async_f);\n   INTERCEPT_FUNCTION(dispatch_barrier_sync);\n   INTERCEPT_FUNCTION(dispatch_barrier_sync_f);\n+  INTERCEPT_FUNCTION(dispatch_async_and_wait);\n+  INTERCEPT_FUNCTION(dispatch_async_and_wait_f);\n+  INTERCEPT_FUNCTION(dispatch_barrier_async_and_wait);\n+  INTERCEPT_FUNCTION(dispatch_barrier_async_and_wait_f);\n   INTERCEPT_FUNCTION(dispatch_after);\n   INTERCEPT_FUNCTION(dispatch_after_f);\n   INTERCEPT_FUNCTION(dispatch_once);"}, {"sha": "6d62ff6a83825e8bf20904e1b8eb5055d2893584", "filename": "libsanitizer/tsan/tsan_interceptors_mach_vm.cpp", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_interceptors_mach_vm.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_interceptors_mach_vm.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors_mach_vm.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -19,34 +19,35 @@\n \n namespace __tsan {\n \n-static bool intersects_with_shadow(mach_vm_address_t *address,\n+static bool intersects_with_shadow(mach_vm_address_t address,\n                                    mach_vm_size_t size, int flags) {\n   // VM_FLAGS_FIXED is 0x0, so we have to test for VM_FLAGS_ANYWHERE.\n   if (flags & VM_FLAGS_ANYWHERE) return false;\n-  uptr ptr = *address;\n-  return !IsAppMem(ptr) || !IsAppMem(ptr + size - 1);\n+  return !IsAppMem(address) || !IsAppMem(address + size - 1);\n }\n \n TSAN_INTERCEPTOR(kern_return_t, mach_vm_allocate, vm_map_t target,\n                  mach_vm_address_t *address, mach_vm_size_t size, int flags) {\n   SCOPED_TSAN_INTERCEPTOR(mach_vm_allocate, target, address, size, flags);\n   if (target != mach_task_self())\n     return REAL(mach_vm_allocate)(target, address, size, flags);\n-  if (intersects_with_shadow(address, size, flags))\n+  if (address && intersects_with_shadow(*address, size, flags))\n     return KERN_NO_SPACE;\n-  kern_return_t res = REAL(mach_vm_allocate)(target, address, size, flags);\n-  if (res == KERN_SUCCESS)\n+  kern_return_t kr = REAL(mach_vm_allocate)(target, address, size, flags);\n+  if (kr == KERN_SUCCESS)\n     MemoryRangeImitateWriteOrResetRange(thr, pc, *address, size);\n-  return res;\n+  return kr;\n }\n \n TSAN_INTERCEPTOR(kern_return_t, mach_vm_deallocate, vm_map_t target,\n                  mach_vm_address_t address, mach_vm_size_t size) {\n   SCOPED_TSAN_INTERCEPTOR(mach_vm_deallocate, target, address, size);\n   if (target != mach_task_self())\n     return REAL(mach_vm_deallocate)(target, address, size);\n-  UnmapShadow(thr, address, size);\n-  return REAL(mach_vm_deallocate)(target, address, size);\n+  kern_return_t kr = REAL(mach_vm_deallocate)(target, address, size);\n+  if (kr == KERN_SUCCESS && address)\n+    UnmapShadow(thr, address, size);\n+  return kr;\n }\n \n }  // namespace __tsan"}, {"sha": "20c2747aaea4293631f7496ad4e1be4f9831b133", "filename": "libsanitizer/tsan/tsan_interceptors_posix.cpp", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_interceptors_posix.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_interceptors_posix.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors_posix.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -31,6 +31,8 @@\n #include \"tsan_mman.h\"\n #include \"tsan_fd.h\"\n \n+#include <stdarg.h>\n+\n using namespace __tsan;\n \n #if SANITIZER_FREEBSD || SANITIZER_MAC\n@@ -135,6 +137,7 @@ const int PTHREAD_BARRIER_SERIAL_THREAD = -1;\n #endif\n const int MAP_FIXED = 0x10;\n typedef long long_t;\n+typedef __sanitizer::u16 mode_t;\n \n // From /usr/include/unistd.h\n # define F_ULOCK 0      /* Unlock a previously locked region.  */\n@@ -254,7 +257,8 @@ ScopedInterceptor::ScopedInterceptor(ThreadState *thr, const char *fname,\n   if (!thr_->ignore_interceptors) FuncEntry(thr, pc);\n   DPrintf(\"#%d: intercept %s()\\n\", thr_->tid, fname);\n   ignoring_ =\n-      !thr_->in_ignored_lib && libignore()->IsIgnored(pc, &in_ignored_lib_);\n+      !thr_->in_ignored_lib && (flags()->ignore_interceptors_accesses ||\n+                                libignore()->IsIgnored(pc, &in_ignored_lib_));\n   EnableIgnores();\n }\n \n@@ -1507,20 +1511,28 @@ TSAN_INTERCEPTOR(int, fstat64, int fd, void *buf) {\n #define TSAN_MAYBE_INTERCEPT_FSTAT64\n #endif\n \n-TSAN_INTERCEPTOR(int, open, const char *name, int flags, int mode) {\n-  SCOPED_TSAN_INTERCEPTOR(open, name, flags, mode);\n+TSAN_INTERCEPTOR(int, open, const char *name, int oflag, ...) {\n+  va_list ap;\n+  va_start(ap, oflag);\n+  mode_t mode = va_arg(ap, int);\n+  va_end(ap);\n+  SCOPED_TSAN_INTERCEPTOR(open, name, oflag, mode);\n   READ_STRING(thr, pc, name, 0);\n-  int fd = REAL(open)(name, flags, mode);\n+  int fd = REAL(open)(name, oflag, mode);\n   if (fd >= 0)\n     FdFileCreate(thr, pc, fd);\n   return fd;\n }\n \n #if SANITIZER_LINUX\n-TSAN_INTERCEPTOR(int, open64, const char *name, int flags, int mode) {\n-  SCOPED_TSAN_INTERCEPTOR(open64, name, flags, mode);\n+TSAN_INTERCEPTOR(int, open64, const char *name, int oflag, ...) {\n+  va_list ap;\n+  va_start(ap, oflag);\n+  mode_t mode = va_arg(ap, int);\n+  va_end(ap);\n+  SCOPED_TSAN_INTERCEPTOR(open64, name, oflag, mode);\n   READ_STRING(thr, pc, name, 0);\n-  int fd = REAL(open64)(name, flags, mode);\n+  int fd = REAL(open64)(name, oflag, mode);\n   if (fd >= 0)\n     FdFileCreate(thr, pc, fd);\n   return fd;\n@@ -2436,13 +2448,13 @@ static void syscall_access_range(uptr pc, uptr p, uptr s, bool write) {\n   MemoryAccessRange(thr, pc, p, s, write);\n }\n \n-static void syscall_acquire(uptr pc, uptr addr) {\n+static USED void syscall_acquire(uptr pc, uptr addr) {\n   TSAN_SYSCALL();\n   Acquire(thr, pc, addr);\n   DPrintf(\"syscall_acquire(%p)\\n\", addr);\n }\n \n-static void syscall_release(uptr pc, uptr addr) {\n+static USED void syscall_release(uptr pc, uptr addr) {\n   TSAN_SYSCALL();\n   DPrintf(\"syscall_release(%p)\\n\", addr);\n   Release(thr, pc, addr);"}, {"sha": "55f1c9834f70d726d1029d9c06003abfb805bfc2", "filename": "libsanitizer/tsan/tsan_interface.cpp", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_interface.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_interface.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -14,15 +14,12 @@\n #include \"tsan_interface_ann.h\"\n #include \"tsan_rtl.h\"\n #include \"sanitizer_common/sanitizer_internal_defs.h\"\n+#include \"sanitizer_common/sanitizer_ptrauth.h\"\n \n #define CALLERPC ((uptr)__builtin_return_address(0))\n \n using namespace __tsan;\n \n-typedef u16 uint16_t;\n-typedef u32 uint32_t;\n-typedef u64 uint64_t;\n-\n void __tsan_init() {\n   cur_thread_init();\n   Initialize(cur_thread());\n@@ -43,13 +40,13 @@ void __tsan_write16(void *addr) {\n }\n \n void __tsan_read16_pc(void *addr, void *pc) {\n-  MemoryRead(cur_thread(), (uptr)pc, (uptr)addr, kSizeLog8);\n-  MemoryRead(cur_thread(), (uptr)pc, (uptr)addr + 8, kSizeLog8);\n+  MemoryRead(cur_thread(), STRIP_PC(pc), (uptr)addr, kSizeLog8);\n+  MemoryRead(cur_thread(), STRIP_PC(pc), (uptr)addr + 8, kSizeLog8);\n }\n \n void __tsan_write16_pc(void *addr, void *pc) {\n-  MemoryWrite(cur_thread(), (uptr)pc, (uptr)addr, kSizeLog8);\n-  MemoryWrite(cur_thread(), (uptr)pc, (uptr)addr + 8, kSizeLog8);\n+  MemoryWrite(cur_thread(), STRIP_PC(pc), (uptr)addr, kSizeLog8);\n+  MemoryWrite(cur_thread(), STRIP_PC(pc), (uptr)addr + 8, kSizeLog8);\n }\n \n // __tsan_unaligned_read/write calls are emitted by compiler."}, {"sha": "f5d743c10772ecab78fc4ea8b3c55c0b395dbcb5", "filename": "libsanitizer/tsan/tsan_interface_inl.h", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_interface_inl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_interface_inl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_inl.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -12,6 +12,7 @@\n \n #include \"tsan_interface.h\"\n #include \"tsan_rtl.h\"\n+#include \"sanitizer_common/sanitizer_ptrauth.h\"\n \n #define CALLERPC ((uptr)__builtin_return_address(0))\n \n@@ -50,35 +51,35 @@ void __tsan_write8(void *addr) {\n }\n \n void __tsan_read1_pc(void *addr, void *pc) {\n-  MemoryRead(cur_thread(), (uptr)pc, (uptr)addr, kSizeLog1);\n+  MemoryRead(cur_thread(), STRIP_PC(pc), (uptr)addr, kSizeLog1);\n }\n \n void __tsan_read2_pc(void *addr, void *pc) {\n-  MemoryRead(cur_thread(), (uptr)pc, (uptr)addr, kSizeLog2);\n+  MemoryRead(cur_thread(), STRIP_PC(pc), (uptr)addr, kSizeLog2);\n }\n \n void __tsan_read4_pc(void *addr, void *pc) {\n-  MemoryRead(cur_thread(), (uptr)pc, (uptr)addr, kSizeLog4);\n+  MemoryRead(cur_thread(), STRIP_PC(pc), (uptr)addr, kSizeLog4);\n }\n \n void __tsan_read8_pc(void *addr, void *pc) {\n-  MemoryRead(cur_thread(), (uptr)pc, (uptr)addr, kSizeLog8);\n+  MemoryRead(cur_thread(), STRIP_PC(pc), (uptr)addr, kSizeLog8);\n }\n \n void __tsan_write1_pc(void *addr, void *pc) {\n-  MemoryWrite(cur_thread(), (uptr)pc, (uptr)addr, kSizeLog1);\n+  MemoryWrite(cur_thread(), STRIP_PC(pc), (uptr)addr, kSizeLog1);\n }\n \n void __tsan_write2_pc(void *addr, void *pc) {\n-  MemoryWrite(cur_thread(), (uptr)pc, (uptr)addr, kSizeLog2);\n+  MemoryWrite(cur_thread(), STRIP_PC(pc), (uptr)addr, kSizeLog2);\n }\n \n void __tsan_write4_pc(void *addr, void *pc) {\n-  MemoryWrite(cur_thread(), (uptr)pc, (uptr)addr, kSizeLog4);\n+  MemoryWrite(cur_thread(), STRIP_PC(pc), (uptr)addr, kSizeLog4);\n }\n \n void __tsan_write8_pc(void *addr, void *pc) {\n-  MemoryWrite(cur_thread(), (uptr)pc, (uptr)addr, kSizeLog8);\n+  MemoryWrite(cur_thread(), STRIP_PC(pc), (uptr)addr, kSizeLog8);\n }\n \n void __tsan_vptr_update(void **vptr_p, void *new_val) {\n@@ -100,7 +101,7 @@ void __tsan_vptr_read(void **vptr_p) {\n }\n \n void __tsan_func_entry(void *pc) {\n-  FuncEntry(cur_thread(), (uptr)pc);\n+  FuncEntry(cur_thread(), STRIP_PC(pc));\n }\n \n void __tsan_func_exit() {\n@@ -124,9 +125,9 @@ void __tsan_write_range(void *addr, uptr size) {\n }\n \n void __tsan_read_range_pc(void *addr, uptr size, void *pc) {\n-  MemoryAccessRange(cur_thread(), (uptr)pc, (uptr)addr, size, false);\n+  MemoryAccessRange(cur_thread(), STRIP_PC(pc), (uptr)addr, size, false);\n }\n \n void __tsan_write_range_pc(void *addr, uptr size, void *pc) {\n-  MemoryAccessRange(cur_thread(), (uptr)pc, (uptr)addr, size, true);\n+  MemoryAccessRange(cur_thread(), STRIP_PC(pc), (uptr)addr, size, true);\n }"}, {"sha": "710e7ec97b7037616b0fc9c0630d35ed5854e01b", "filename": "libsanitizer/tsan/tsan_platform_linux.cpp", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_platform_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_platform_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_linux.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -8,25 +8,26 @@\n //\n // This file is a part of ThreadSanitizer (TSan), a race detector.\n //\n-// Linux- and FreeBSD-specific code.\n+// Linux- and BSD-specific code.\n //===----------------------------------------------------------------------===//\n \n-\n #include \"sanitizer_common/sanitizer_platform.h\"\n-#if SANITIZER_LINUX || SANITIZER_FREEBSD || SANITIZER_NETBSD\n+#if SANITIZER_LINUX || SANITIZER_FREEBSD || SANITIZER_NETBSD || \\\n+    SANITIZER_OPENBSD\n \n #include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n #include \"sanitizer_common/sanitizer_linux.h\"\n #include \"sanitizer_common/sanitizer_platform_limits_netbsd.h\"\n+#include \"sanitizer_common/sanitizer_platform_limits_openbsd.h\"\n #include \"sanitizer_common/sanitizer_platform_limits_posix.h\"\n #include \"sanitizer_common/sanitizer_posix.h\"\n #include \"sanitizer_common/sanitizer_procmaps.h\"\n-#include \"sanitizer_common/sanitizer_stoptheworld.h\"\n #include \"sanitizer_common/sanitizer_stackdepot.h\"\n+#include \"sanitizer_common/sanitizer_stoptheworld.h\"\n+#include \"tsan_flags.h\"\n #include \"tsan_platform.h\"\n #include \"tsan_rtl.h\"\n-#include \"tsan_flags.h\"\n \n #include <fcntl.h>\n #include <pthread.h>\n@@ -383,12 +384,16 @@ static uptr UnmangleLongJmpSp(uptr mangled_sp) {\n #endif\n }\n \n-#ifdef __powerpc__\n+#if SANITIZER_NETBSD\n+# ifdef __x86_64__\n+#  define LONG_JMP_SP_ENV_SLOT 6\n+# else\n+#  error unsupported\n+# endif\n+#elif defined(__powerpc__)\n # define LONG_JMP_SP_ENV_SLOT 0\n #elif SANITIZER_FREEBSD\n # define LONG_JMP_SP_ENV_SLOT 2\n-#elif SANITIZER_NETBSD\n-# define LONG_JMP_SP_ENV_SLOT 6\n #elif SANITIZER_LINUX\n # ifdef __aarch64__\n #  define LONG_JMP_SP_ENV_SLOT 13\n@@ -512,4 +517,5 @@ void cur_thread_finalize() {\n \n }  // namespace __tsan\n \n-#endif  // SANITIZER_LINUX || SANITIZER_FREEBSD || SANITIZER_NETBSD\n+#endif  // SANITIZER_LINUX || SANITIZER_FREEBSD || SANITIZER_NETBSD ||\n+        // SANITIZER_OPENBSD"}, {"sha": "eea52a34e97f4b5a6eb1d44914ba01ccba62d415", "filename": "libsanitizer/tsan/tsan_platform_mac.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_platform_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_platform_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_mac.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -258,7 +258,7 @@ void InitializePlatform() {\n       pthread_introspection_hook_install(&my_pthread_introspection_hook);\n #endif\n \n-  if (GetMacosVersion() >= MACOS_VERSION_MOJAVE) {\n+  if (GetMacosAlignedVersion() >= MacosVersion(10, 14)) {\n     // Libsystem currently uses a process-global key; this might change.\n     const unsigned kTLSLongjmpXorKeySlot = 0x7;\n     longjmp_xor_key = (uptr)pthread_getspecific(kTLSLongjmpXorKeySlot);\n@@ -267,7 +267,7 @@ void InitializePlatform() {\n \n #ifdef __aarch64__\n # define LONG_JMP_SP_ENV_SLOT \\\n-    ((GetMacosVersion() >= MACOS_VERSION_MOJAVE) ? 12 : 13)\n+    ((GetMacosAlignedVersion() >= MacosVersion(10, 14)) ? 12 : 13)\n #else\n # define LONG_JMP_SP_ENV_SLOT 2\n #endif"}, {"sha": "d56b6c3b9c54a8ed8f0840b28eac2ed648898c68", "filename": "libsanitizer/tsan/tsan_platform_posix.cpp", "status": "modified", "additions": 3, "deletions": 44, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_platform_posix.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_platform_posix.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_posix.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -29,10 +29,6 @@ static const char kShadowMemoryMappingHint[] =\n     \"HINT: if %s is not supported in your environment, you may set \"\n     \"TSAN_OPTIONS=%s=0\\n\";\n \n-static void NoHugePagesInShadow(uptr addr, uptr size) {\n-  SetShadowRegionHugePageMode(addr, size);\n-}\n-\n static void DontDumpShadow(uptr addr, uptr size) {\n   if (common_flags()->use_madv_dontdump)\n     if (!DontDumpShadowMemory(addr, size)) {\n@@ -46,7 +42,8 @@ static void DontDumpShadow(uptr addr, uptr size) {\n #if !SANITIZER_GO\n void InitializeShadowMemory() {\n   // Map memory shadow.\n-  if (!MmapFixedNoReserve(ShadowBeg(), ShadowEnd() - ShadowBeg(), \"shadow\")) {\n+  if (!MmapFixedSuperNoReserve(ShadowBeg(), ShadowEnd() - ShadowBeg(),\n+                               \"shadow\")) {\n     Printf(\"FATAL: ThreadSanitizer can not mmap the shadow memory\\n\");\n     Printf(\"FATAL: Make sure to compile with -fPIE and to link with -pie.\\n\");\n     Die();\n@@ -55,43 +52,6 @@ void InitializeShadowMemory() {\n   // Frequently a thread uses only a small part of stack and similarly\n   // a program uses a small part of large mmap. On some programs\n   // we see 20% memory usage reduction without huge pages for this range.\n-  // FIXME: don't use constants here.\n-#if defined(__x86_64__)\n-  const uptr kMadviseRangeBeg  = 0x7f0000000000ull;\n-  const uptr kMadviseRangeSize = 0x010000000000ull;\n-#elif defined(__mips64)\n-  const uptr kMadviseRangeBeg  = 0xff00000000ull;\n-  const uptr kMadviseRangeSize = 0x0100000000ull;\n-#elif defined(__aarch64__) && defined(__APPLE__)\n-  uptr kMadviseRangeBeg = LoAppMemBeg();\n-  uptr kMadviseRangeSize = LoAppMemEnd() - LoAppMemBeg();\n-#elif defined(__aarch64__)\n-  uptr kMadviseRangeBeg = 0;\n-  uptr kMadviseRangeSize = 0;\n-  if (vmaSize == 39) {\n-    kMadviseRangeBeg  = 0x7d00000000ull;\n-    kMadviseRangeSize = 0x0300000000ull;\n-  } else if (vmaSize == 42) {\n-    kMadviseRangeBeg  = 0x3f000000000ull;\n-    kMadviseRangeSize = 0x01000000000ull;\n-  } else {\n-    DCHECK(0);\n-  }\n-#elif defined(__powerpc64__)\n-  uptr kMadviseRangeBeg = 0;\n-  uptr kMadviseRangeSize = 0;\n-  if (vmaSize == 44) {\n-    kMadviseRangeBeg  = 0x0f60000000ull;\n-    kMadviseRangeSize = 0x0010000000ull;\n-  } else if (vmaSize == 46) {\n-    kMadviseRangeBeg  = 0x3f0000000000ull;\n-    kMadviseRangeSize = 0x010000000000ull;\n-  } else {\n-    DCHECK(0);\n-  }\n-#endif\n-  NoHugePagesInShadow(MemToShadow(kMadviseRangeBeg),\n-                      kMadviseRangeSize * kShadowMultiplier);\n   DontDumpShadow(ShadowBeg(), ShadowEnd() - ShadowBeg());\n   DPrintf(\"memory shadow: %zx-%zx (%zuGB)\\n\",\n       ShadowBeg(), ShadowEnd(),\n@@ -100,12 +60,11 @@ void InitializeShadowMemory() {\n   // Map meta shadow.\n   const uptr meta = MetaShadowBeg();\n   const uptr meta_size = MetaShadowEnd() - meta;\n-  if (!MmapFixedNoReserve(meta, meta_size, \"meta shadow\")) {\n+  if (!MmapFixedSuperNoReserve(meta, meta_size, \"meta shadow\")) {\n     Printf(\"FATAL: ThreadSanitizer can not mmap the shadow memory\\n\");\n     Printf(\"FATAL: Make sure to compile with -fPIE and to link with -pie.\\n\");\n     Die();\n   }\n-  NoHugePagesInShadow(meta, meta_size);\n   DontDumpShadow(meta, meta_size);\n   DPrintf(\"meta shadow: %zx-%zx (%zuGB)\\n\",\n       meta, meta + meta_size, meta_size >> 30);"}, {"sha": "4892c446c104b23e6237a97a9048f7f15cff4a0a", "filename": "libsanitizer/tsan/tsan_report.cpp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_report.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_report.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -128,7 +128,8 @@ void PrintStack(const ReportStack *ent) {\n   SymbolizedStack *frame = ent->frames;\n   for (int i = 0; frame && frame->info.address; frame = frame->next, i++) {\n     InternalScopedString res(2 * GetPageSizeCached());\n-    RenderFrame(&res, common_flags()->stack_trace_format, i, frame->info,\n+    RenderFrame(&res, common_flags()->stack_trace_format, i,\n+                frame->info.address, &frame->info,\n                 common_flags()->symbolize_vs_style,\n                 common_flags()->strip_path_prefix, kInterposedFunctionPrefix);\n     Printf(\"%s\\n\", res.data());"}, {"sha": "7b37ed50681e613a59924234d036cf24cdd8c43f", "filename": "libsanitizer/tsan/tsan_rtl.cpp", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_rtl.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_rtl.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -256,7 +256,8 @@ void MapShadow(uptr addr, uptr size) {\n   const uptr kPageSize = GetPageSizeCached();\n   uptr shadow_begin = RoundDownTo((uptr)MemToShadow(addr), kPageSize);\n   uptr shadow_end = RoundUpTo((uptr)MemToShadow(addr + size), kPageSize);\n-  if (!MmapFixedNoReserve(shadow_begin, shadow_end - shadow_begin, \"shadow\"))\n+  if (!MmapFixedSuperNoReserve(shadow_begin, shadow_end - shadow_begin,\n+                               \"shadow\"))\n     Die();\n \n   // Meta shadow is 2:1, so tread carefully.\n@@ -269,7 +270,8 @@ void MapShadow(uptr addr, uptr size) {\n   if (!data_mapped) {\n     // First call maps data+bss.\n     data_mapped = true;\n-    if (!MmapFixedNoReserve(meta_begin, meta_end - meta_begin, \"meta shadow\"))\n+    if (!MmapFixedSuperNoReserve(meta_begin, meta_end - meta_begin,\n+                                 \"meta shadow\"))\n       Die();\n   } else {\n     // Mapping continous heap.\n@@ -280,7 +282,8 @@ void MapShadow(uptr addr, uptr size) {\n       return;\n     if (meta_begin < mapped_meta_end)\n       meta_begin = mapped_meta_end;\n-    if (!MmapFixedNoReserve(meta_begin, meta_end - meta_begin, \"meta shadow\"))\n+    if (!MmapFixedSuperNoReserve(meta_begin, meta_end - meta_begin,\n+                                 \"meta shadow\"))\n       Die();\n     mapped_meta_end = meta_end;\n   }\n@@ -293,7 +296,7 @@ void MapThreadTrace(uptr addr, uptr size, const char *name) {\n   CHECK_GE(addr, TraceMemBeg());\n   CHECK_LE(addr + size, TraceMemEnd());\n   CHECK_EQ(addr, addr & ~((64 << 10) - 1));  // windows wants 64K alignment\n-  if (!MmapFixedNoReserve(addr, size, name)) {\n+  if (!MmapFixedSuperNoReserve(addr, size, name)) {\n     Printf(\"FATAL: ThreadSanitizer can not mmap thread trace (%p/%p)\\n\",\n         addr, size);\n     Die();\n@@ -957,7 +960,7 @@ static void MemoryRangeSet(ThreadState *thr, uptr pc, uptr addr, uptr size,\n     u64 *p1 = p;\n     p = RoundDown(end, kPageSize);\n     UnmapOrDie((void*)p1, (uptr)p - (uptr)p1);\n-    if (!MmapFixedNoReserve((uptr)p1, (uptr)p - (uptr)p1))\n+    if (!MmapFixedSuperNoReserve((uptr)p1, (uptr)p - (uptr)p1))\n       Die();\n     // Set the ending.\n     while (p < end) {"}, {"sha": "efdc53a1e9252b0dd0951d672baf0f42359d7917", "filename": "libsanitizer/tsan/tsan_rtl.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -458,22 +458,22 @@ struct ThreadState {\n ThreadState *cur_thread();\n void set_cur_thread(ThreadState *thr);\n void cur_thread_finalize();\n-INLINE void cur_thread_init() { }\n+inline void cur_thread_init() { }\n #else\n __attribute__((tls_model(\"initial-exec\")))\n extern THREADLOCAL char cur_thread_placeholder[];\n-INLINE ThreadState *cur_thread() {\n+inline ThreadState *cur_thread() {\n   return reinterpret_cast<ThreadState *>(cur_thread_placeholder)->current;\n }\n-INLINE void cur_thread_init() {\n+inline void cur_thread_init() {\n   ThreadState *thr = reinterpret_cast<ThreadState *>(cur_thread_placeholder);\n   if (UNLIKELY(!thr->current))\n     thr->current = thr;\n }\n-INLINE void set_cur_thread(ThreadState *thr) {\n+inline void set_cur_thread(ThreadState *thr) {\n   reinterpret_cast<ThreadState *>(cur_thread_placeholder)->current = thr;\n }\n-INLINE void cur_thread_finalize() { }\n+inline void cur_thread_finalize() { }\n #endif  // SANITIZER_MAC || SANITIZER_ANDROID\n #endif  // SANITIZER_GO\n "}, {"sha": "8285e21aa1ec7a797dfcf4840ee5a7851106b497", "filename": "libsanitizer/tsan/tsan_rtl_ppc64.S", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_rtl_ppc64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_rtl_ppc64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_ppc64.S?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -1,6 +1,5 @@\n #include \"tsan_ppc_regs.h\"\n \n-        .machine altivec\n         .section .text\n         .hidden __tsan_setjmp\n         .globl _setjmp"}, {"sha": "208d0df44df7b0a6322094964cc8deabb9380f5d", "filename": "libsanitizer/tsan/tsan_rtl_report.cpp", "status": "modified", "additions": 51, "deletions": 56, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_rtl_report.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_rtl_report.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_report.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -439,65 +439,61 @@ void RestoreStack(int tid, const u64 epoch, VarSizeStackTrace *stk,\n   ExtractTagFromStack(stk, tag);\n }\n \n-static bool HandleRacyStacks(ThreadState *thr, VarSizeStackTrace traces[2],\n-                             uptr addr_min, uptr addr_max) {\n-  bool equal_stack = false;\n-  RacyStacks hash;\n-  bool equal_address = false;\n-  RacyAddress ra0 = {addr_min, addr_max};\n-  {\n-    ReadLock lock(&ctx->racy_mtx);\n-    if (flags()->suppress_equal_stacks) {\n-      hash.hash[0] = md5_hash(traces[0].trace, traces[0].size * sizeof(uptr));\n-      hash.hash[1] = md5_hash(traces[1].trace, traces[1].size * sizeof(uptr));\n-      for (uptr i = 0; i < ctx->racy_stacks.Size(); i++) {\n-        if (hash == ctx->racy_stacks[i]) {\n-          VPrintf(2,\n-              \"ThreadSanitizer: suppressing report as doubled (stack)\\n\");\n-          equal_stack = true;\n-          break;\n-        }\n-      }\n-    }\n-    if (flags()->suppress_equal_addresses) {\n-      for (uptr i = 0; i < ctx->racy_addresses.Size(); i++) {\n-        RacyAddress ra2 = ctx->racy_addresses[i];\n-        uptr maxbeg = max(ra0.addr_min, ra2.addr_min);\n-        uptr minend = min(ra0.addr_max, ra2.addr_max);\n-        if (maxbeg < minend) {\n-          VPrintf(2, \"ThreadSanitizer: suppressing report as doubled (addr)\\n\");\n-          equal_address = true;\n-          break;\n-        }\n-      }\n+static bool FindRacyStacks(const RacyStacks &hash) {\n+  for (uptr i = 0; i < ctx->racy_stacks.Size(); i++) {\n+    if (hash == ctx->racy_stacks[i]) {\n+      VPrintf(2, \"ThreadSanitizer: suppressing report as doubled (stack)\\n\");\n+      return true;\n     }\n   }\n-  if (!equal_stack && !equal_address)\n+  return false;\n+}\n+\n+static bool HandleRacyStacks(ThreadState *thr, VarSizeStackTrace traces[2]) {\n+  if (!flags()->suppress_equal_stacks)\n     return false;\n-  if (!equal_stack) {\n-    Lock lock(&ctx->racy_mtx);\n-    ctx->racy_stacks.PushBack(hash);\n-  }\n-  if (!equal_address) {\n-    Lock lock(&ctx->racy_mtx);\n-    ctx->racy_addresses.PushBack(ra0);\n+  RacyStacks hash;\n+  hash.hash[0] = md5_hash(traces[0].trace, traces[0].size * sizeof(uptr));\n+  hash.hash[1] = md5_hash(traces[1].trace, traces[1].size * sizeof(uptr));\n+  {\n+    ReadLock lock(&ctx->racy_mtx);\n+    if (FindRacyStacks(hash))\n+      return true;\n   }\n-  return true;\n+  Lock lock(&ctx->racy_mtx);\n+  if (FindRacyStacks(hash))\n+    return true;\n+  ctx->racy_stacks.PushBack(hash);\n+  return false;\n }\n \n-static void AddRacyStacks(ThreadState *thr, VarSizeStackTrace traces[2],\n-                          uptr addr_min, uptr addr_max) {\n-  Lock lock(&ctx->racy_mtx);\n-  if (flags()->suppress_equal_stacks) {\n-    RacyStacks hash;\n-    hash.hash[0] = md5_hash(traces[0].trace, traces[0].size * sizeof(uptr));\n-    hash.hash[1] = md5_hash(traces[1].trace, traces[1].size * sizeof(uptr));\n-    ctx->racy_stacks.PushBack(hash);\n+static bool FindRacyAddress(const RacyAddress &ra0) {\n+  for (uptr i = 0; i < ctx->racy_addresses.Size(); i++) {\n+    RacyAddress ra2 = ctx->racy_addresses[i];\n+    uptr maxbeg = max(ra0.addr_min, ra2.addr_min);\n+    uptr minend = min(ra0.addr_max, ra2.addr_max);\n+    if (maxbeg < minend) {\n+      VPrintf(2, \"ThreadSanitizer: suppressing report as doubled (addr)\\n\");\n+      return true;\n+    }\n   }\n-  if (flags()->suppress_equal_addresses) {\n-    RacyAddress ra0 = {addr_min, addr_max};\n-    ctx->racy_addresses.PushBack(ra0);\n+  return false;\n+}\n+\n+static bool HandleRacyAddress(ThreadState *thr, uptr addr_min, uptr addr_max) {\n+  if (!flags()->suppress_equal_addresses)\n+    return false;\n+  RacyAddress ra0 = {addr_min, addr_max};\n+  {\n+    ReadLock lock(&ctx->racy_mtx);\n+    if (FindRacyAddress(ra0))\n+      return true;\n   }\n+  Lock lock(&ctx->racy_mtx);\n+  if (FindRacyAddress(ra0))\n+    return true;\n+  ctx->racy_addresses.PushBack(ra0);\n+  return false;\n }\n \n bool OutputReport(ThreadState *thr, const ScopedReport &srep) {\n@@ -618,6 +614,8 @@ void ReportRace(ThreadState *thr) {\n     if (IsExpectedReport(addr_min, addr_max - addr_min))\n       return;\n   }\n+  if (HandleRacyAddress(thr, addr_min, addr_max))\n+    return;\n \n   ReportType typ = ReportTypeRace;\n   if (thr->is_vptr_access && freed)\n@@ -668,7 +666,7 @@ void ReportRace(ThreadState *thr) {\n   if (IsFiredSuppression(ctx, typ, traces[1]))\n     return;\n \n-  if (HandleRacyStacks(thr, traces, addr_min, addr_max))\n+  if (HandleRacyStacks(thr, traces))\n     return;\n \n   // If any of the accesses has a tag, treat this as an \"external\" race.\n@@ -708,10 +706,7 @@ void ReportRace(ThreadState *thr) {\n   }\n #endif\n \n-  if (!OutputReport(thr, rep))\n-    return;\n-\n-  AddRacyStacks(thr, traces, addr_min, addr_max);\n+  OutputReport(thr, rep);\n }\n \n void PrintCurrentStack(ThreadState *thr, uptr pc) {"}, {"sha": "17ddd50f1284c0192b3966147b2c457827974b2e", "filename": "libsanitizer/tsan/tsan_sync.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_sync.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Ftsan%2Ftsan_sync.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_sync.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -175,7 +175,7 @@ void MetaMap::ResetRange(Processor *proc, uptr p, uptr sz) {\n   uptr metap = (uptr)MemToMeta(p0);\n   uptr metasz = sz0 / kMetaRatio;\n   UnmapOrDie((void*)metap, metasz);\n-  if (!MmapFixedNoReserve(metap, metasz))\n+  if (!MmapFixedSuperNoReserve(metap, metasz))\n     Die();\n }\n "}, {"sha": "846cd89ee19f8bbbed6a9ca45677321806619fc8", "filename": "libsanitizer/ubsan/ubsan_checks.inc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fubsan%2Fubsan_checks.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fubsan%2Fubsan_checks.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_checks.inc?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -37,6 +37,7 @@ UBSAN_CHECK(IntegerDivideByZero, \"integer-divide-by-zero\",\n             \"integer-divide-by-zero\")\n UBSAN_CHECK(FloatDivideByZero, \"float-divide-by-zero\", \"float-divide-by-zero\")\n UBSAN_CHECK(InvalidBuiltin, \"invalid-builtin-use\", \"invalid-builtin-use\")\n+UBSAN_CHECK(InvalidObjCCast, \"invalid-objc-cast\", \"invalid-objc-cast\")\n UBSAN_CHECK(ImplicitUnsignedIntegerTruncation,\n             \"implicit-unsigned-integer-truncation\",\n             \"implicit-unsigned-integer-truncation\")"}, {"sha": "25cefd46ce27ced7fb6092d8d04b5074c56ebe95", "filename": "libsanitizer/ubsan/ubsan_flags.cpp", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fubsan%2Fubsan_flags.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fubsan%2Fubsan_flags.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_flags.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -21,10 +21,6 @@\n \n namespace __ubsan {\n \n-const char *MaybeCallUbsanDefaultOptions() {\n-  return (&__ubsan_default_options) ? __ubsan_default_options() : \"\";\n-}\n-\n static const char *GetFlag(const char *flag) {\n   // We cannot call getenv() from inside a preinit array initializer\n   if (SANITIZER_CAN_USE_PREINIT_ARRAY) {\n@@ -54,7 +50,6 @@ void InitializeFlags() {\n   {\n     CommonFlags cf;\n     cf.CopyFrom(*common_flags());\n-    cf.print_summary = false;\n     cf.external_symbolizer_path = GetFlag(\"UBSAN_SYMBOLIZER_PATH\");\n     OverrideCommonFlags(cf);\n   }\n@@ -67,7 +62,7 @@ void InitializeFlags() {\n   RegisterUbsanFlags(&parser, f);\n \n   // Override from user-specified string.\n-  parser.ParseString(MaybeCallUbsanDefaultOptions());\n+  parser.ParseString(__ubsan_default_options());\n   // Override from environment variable.\n   parser.ParseStringFromEnv(\"UBSAN_OPTIONS\");\n   InitializeCommonFlags();"}, {"sha": "c47009bafe5399c3ac5f78a832c9681aa776bf90", "filename": "libsanitizer/ubsan/ubsan_flags.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fubsan%2Fubsan_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fubsan%2Fubsan_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_flags.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -34,8 +34,6 @@ inline Flags *flags() { return &ubsan_flags; }\n void InitializeFlags();\n void RegisterUbsanFlags(FlagParser *parser, Flags *f);\n \n-const char *MaybeCallUbsanDefaultOptions();\n-\n }  // namespace __ubsan\n \n extern \"C\" {"}, {"sha": "e201e6bba22078e3d873aeb5792b98ecd860cdaa", "filename": "libsanitizer/ubsan/ubsan_handlers.cpp", "status": "modified", "additions": 31, "deletions": 15, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fubsan%2Fubsan_handlers.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fubsan%2Fubsan_handlers.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -16,6 +16,7 @@\n #include \"ubsan_diag.h\"\n #include \"ubsan_flags.h\"\n #include \"ubsan_monitor.h\"\n+#include \"ubsan_value.h\"\n \n #include \"sanitizer_common/sanitizer_common.h\"\n \n@@ -640,6 +641,36 @@ void __ubsan::__ubsan_handle_invalid_builtin_abort(InvalidBuiltinData *Data) {\n   Die();\n }\n \n+static void handleInvalidObjCCast(InvalidObjCCast *Data, ValueHandle Pointer,\n+                                  ReportOptions Opts) {\n+  SourceLocation Loc = Data->Loc.acquire();\n+  ErrorType ET = ErrorType::InvalidObjCCast;\n+\n+  if (ignoreReport(Loc, Opts, ET))\n+    return;\n+\n+  ScopedReport R(Opts, Loc, ET);\n+\n+  const char *GivenClass = getObjCClassName(Pointer);\n+  const char *GivenClassStr = GivenClass ? GivenClass : \"<unknown type>\";\n+\n+  Diag(Loc, DL_Error, ET,\n+       \"invalid ObjC cast, object is a '%0', but expected a %1\")\n+      << GivenClassStr << Data->ExpectedType;\n+}\n+\n+void __ubsan::__ubsan_handle_invalid_objc_cast(InvalidObjCCast *Data,\n+                                               ValueHandle Pointer) {\n+  GET_REPORT_OPTIONS(false);\n+  handleInvalidObjCCast(Data, Pointer, Opts);\n+}\n+void __ubsan::__ubsan_handle_invalid_objc_cast_abort(InvalidObjCCast *Data,\n+                                                     ValueHandle Pointer) {\n+  GET_REPORT_OPTIONS(true);\n+  handleInvalidObjCCast(Data, Pointer, Opts);\n+  Die();\n+}\n+\n static void handleNonNullReturn(NonNullReturnData *Data, SourceLocation *LocPtr,\n                                 ReportOptions Opts, bool IsAttr) {\n   if (!LocPtr)\n@@ -863,21 +894,6 @@ void __ubsan_handle_cfi_bad_type(CFICheckFailData *Data, ValueHandle Vtable,\n \n }  // namespace __ubsan\n \n-void __ubsan::__ubsan_handle_cfi_bad_icall(CFIBadIcallData *CallData,\n-                                           ValueHandle Function) {\n-  GET_REPORT_OPTIONS(false);\n-  CFICheckFailData Data = {CFITCK_ICall, CallData->Loc, CallData->Type};\n-  handleCFIBadIcall(&Data, Function, Opts);\n-}\n-\n-void __ubsan::__ubsan_handle_cfi_bad_icall_abort(CFIBadIcallData *CallData,\n-                                                 ValueHandle Function) {\n-  GET_REPORT_OPTIONS(true);\n-  CFICheckFailData Data = {CFITCK_ICall, CallData->Loc, CallData->Type};\n-  handleCFIBadIcall(&Data, Function, Opts);\n-  Die();\n-}\n-\n void __ubsan::__ubsan_handle_cfi_check_fail(CFICheckFailData *Data,\n                                             ValueHandle Value,\n                                             uptr ValidVtable) {"}, {"sha": "219fb15de55fe02a4544422095baa0d8532baaa0", "filename": "libsanitizer/ubsan/ubsan_handlers.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fubsan%2Fubsan_handlers.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fubsan%2Fubsan_handlers.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -168,6 +168,14 @@ struct InvalidBuiltinData {\n /// Handle a builtin called in an invalid way.\n RECOVERABLE(invalid_builtin, InvalidBuiltinData *Data)\n \n+struct InvalidObjCCast {\n+  SourceLocation Loc;\n+  const TypeDescriptor &ExpectedType;\n+};\n+\n+/// Handle an invalid ObjC cast.\n+RECOVERABLE(invalid_objc_cast, InvalidObjCCast *Data, ValueHandle Pointer)\n+\n struct NonNullReturnData {\n   SourceLocation AttrLoc;\n };\n@@ -207,20 +215,12 @@ enum CFITypeCheckKind : unsigned char {\n   CFITCK_VMFCall,\n };\n \n-struct CFIBadIcallData {\n-  SourceLocation Loc;\n-  const TypeDescriptor &Type;\n-};\n-\n struct CFICheckFailData {\n   CFITypeCheckKind CheckKind;\n   SourceLocation Loc;\n   const TypeDescriptor &Type;\n };\n \n-/// \\brief Handle control flow integrity failure for indirect function calls.\n-RECOVERABLE(cfi_bad_icall, CFIBadIcallData *Data, ValueHandle Function)\n-\n /// \\brief Handle control flow integrity failures.\n RECOVERABLE(cfi_check_fail, CFICheckFailData *Data, ValueHandle Function,\n             uptr VtableIsValid)"}, {"sha": "94337d85017b4ac985cf47d9553f5f49ed4ba7d2", "filename": "libsanitizer/ubsan/ubsan_interface.inc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fubsan%2Fubsan_interface.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fubsan%2Fubsan_interface.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_interface.inc?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -27,6 +27,8 @@ INTERFACE_FUNCTION(__ubsan_handle_implicit_conversion)\n INTERFACE_FUNCTION(__ubsan_handle_implicit_conversion_abort)\n INTERFACE_FUNCTION(__ubsan_handle_invalid_builtin)\n INTERFACE_FUNCTION(__ubsan_handle_invalid_builtin_abort)\n+INTERFACE_FUNCTION(__ubsan_handle_invalid_objc_cast)\n+INTERFACE_FUNCTION(__ubsan_handle_invalid_objc_cast_abort)\n INTERFACE_FUNCTION(__ubsan_handle_load_invalid_value)\n INTERFACE_FUNCTION(__ubsan_handle_load_invalid_value_abort)\n INTERFACE_FUNCTION(__ubsan_handle_missing_return)"}, {"sha": "71d7fb18c9b3a5e94039e3843113050f31fa1c9f", "filename": "libsanitizer/ubsan/ubsan_platform.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fubsan%2Fubsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fubsan%2Fubsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_platform.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -12,7 +12,6 @@\n #ifndef UBSAN_PLATFORM_H\n #define UBSAN_PLATFORM_H\n \n-#ifndef CAN_SANITIZE_UB\n // Other platforms should be easy to add, and probably work as-is.\n #if defined(__linux__) || defined(__FreeBSD__) || defined(__APPLE__) ||        \\\n     defined(__NetBSD__) || defined(__OpenBSD__) || \\\n@@ -22,6 +21,5 @@\n #else\n # define CAN_SANITIZE_UB 0\n #endif\n-#endif //CAN_SANITIZE_UB\n \n #endif"}, {"sha": "79c3ba991d3980c088e98f4a2e81a70176cc0afc", "filename": "libsanitizer/ubsan/ubsan_value.cpp", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fubsan%2Fubsan_value.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fubsan%2Fubsan_value.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_value.cpp?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -16,9 +16,57 @@\n #include \"ubsan_value.h\"\n #include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n+#include \"sanitizer_common/sanitizer_mutex.h\"\n+\n+// TODO(dliew): Prefer '__APPLE__' here over 'SANITIZER_MAC', as the latter is\n+// unclear. rdar://58124919 tracks using a more obviously portable guard.\n+#if defined(__APPLE__)\n+#include <dlfcn.h>\n+#endif\n \n using namespace __ubsan;\n \n+typedef const char *(*ObjCGetClassNameTy)(void *);\n+\n+const char *__ubsan::getObjCClassName(ValueHandle Pointer) {\n+#if defined(__APPLE__)\n+  // We need to query the ObjC runtime for some information, but do not want\n+  // to introduce a static dependency from the ubsan runtime onto ObjC. Try to\n+  // grab a handle to the ObjC runtime used by the process.\n+  static bool AttemptedDlopen = false;\n+  static void *ObjCHandle = nullptr;\n+  static void *ObjCObjectGetClassName = nullptr;\n+\n+  // Prevent threads from racing to dlopen().\n+  static __sanitizer::StaticSpinMutex Lock;\n+  {\n+    __sanitizer::SpinMutexLock Guard(&Lock);\n+\n+    if (!AttemptedDlopen) {\n+      ObjCHandle = dlopen(\n+          \"/usr/lib/libobjc.A.dylib\",\n+          RTLD_LAZY         // Only bind symbols when used.\n+              | RTLD_LOCAL  // Only make symbols available via the handle.\n+              | RTLD_NOLOAD // Do not load the dylib, just grab a handle if the\n+                            // image is already loaded.\n+              | RTLD_FIRST  // Only search the image pointed-to by the handle.\n+      );\n+      AttemptedDlopen = true;\n+      if (!ObjCHandle)\n+        return nullptr;\n+      ObjCObjectGetClassName = dlsym(ObjCHandle, \"object_getClassName\");\n+    }\n+  }\n+\n+  if (!ObjCObjectGetClassName)\n+    return nullptr;\n+\n+  return ObjCGetClassNameTy(ObjCObjectGetClassName)((void *)Pointer);\n+#else\n+  return nullptr;\n+#endif\n+}\n+\n SIntMax Value::getSIntValue() const {\n   CHECK(getType().isSignedIntegerTy());\n   if (isInlineInt()) {"}, {"sha": "e0957276dd241975aa6643d625c68b528522d192", "filename": "libsanitizer/ubsan/ubsan_value.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fubsan%2Fubsan_value.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b997f6e07771c98178ea09f4a8c4446baaf84da/libsanitizer%2Fubsan%2Fubsan_value.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_value.h?ref=0b997f6e07771c98178ea09f4a8c4446baaf84da", "patch": "@@ -135,6 +135,9 @@ class TypeDescriptor {\n /// \\brief An opaque handle to a value.\n typedef uptr ValueHandle;\n \n+/// Returns the class name of the given ObjC object, or null if the name\n+/// cannot be found.\n+const char *getObjCClassName(ValueHandle Pointer);\n \n /// \\brief Representation of an operand value provided by the instrumented code.\n ///"}]}