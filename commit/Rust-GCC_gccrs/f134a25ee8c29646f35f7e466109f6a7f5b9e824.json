{"sha": "f134a25ee8c29646f35f7e466109f6a7f5b9e824", "node_id": "C_kwDOANBUbNoAKGYxMzRhMjVlZThjMjk2NDZmMzVmN2U0NjYxMDlmNmE3ZjViOWU4MjQ", "commit": {"author": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2022-08-05T12:28:50Z"}, "committer": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2022-08-30T14:50:17Z"}, "message": "omp-simd-clone: Allow fixed-lane vectors\n\nThe vecsize_int/vecsize_float has an assumption that all arguments will use\nthe same bitsize, and vary the number of lanes according to the element size,\nbut this is inappropriate on targets where the number of lanes is fixed and\nthe bitsize varies (i.e. amdgcn).\n\nWith this change the vecsize can be left zero and the vectorization factor will\nbe the same for all types.\n\ngcc/ChangeLog:\n\n\t* doc/tm.texi: Regenerate.\n\t* omp-simd-clone.cc (simd_clone_adjust_return_type): Allow zero\n\tvecsize.\n\t(simd_clone_adjust_argument_types): Likewise.\n\t* target.def (compute_vecsize_and_simdlen): Document the new\n\tvecsize_int and vecsize_float semantics.", "tree": {"sha": "3cbbf9b4be50af4c2fcb724e0d2a879b210c4680", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3cbbf9b4be50af4c2fcb724e0d2a879b210c4680"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f134a25ee8c29646f35f7e466109f6a7f5b9e824", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f134a25ee8c29646f35f7e466109f6a7f5b9e824", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f134a25ee8c29646f35f7e466109f6a7f5b9e824", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f134a25ee8c29646f35f7e466109f6a7f5b9e824/comments", "author": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1025025b612d632920fe710bb58d36e4d43f3220", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1025025b612d632920fe710bb58d36e4d43f3220", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1025025b612d632920fe710bb58d36e4d43f3220"}], "stats": {"total": 26, "additions": 21, "deletions": 5}, "files": [{"sha": "c3001c6ded9468bfa2f99183a6641b751df08532", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f134a25ee8c29646f35f7e466109f6a7f5b9e824/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f134a25ee8c29646f35f7e466109f6a7f5b9e824/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=f134a25ee8c29646f35f7e466109f6a7f5b9e824", "patch": "@@ -6253,6 +6253,9 @@ stores.\n This hook should set @var{vecsize_mangle}, @var{vecsize_int}, @var{vecsize_float}\n fields in @var{simd_clone} structure pointed by @var{clone_info} argument and also\n @var{simdlen} field if it was previously 0.\n+@var{vecsize_mangle} is a marker for the backend only. @var{vecsize_int} and\n+@var{vecsize_float} should be left zero on targets where the number of lanes is\n+not determined by the bitsize (in which case @var{simdlen} is always used).\n The hook should return 0 if SIMD clones shouldn't be emitted,\n or number of @var{vecsize_mangle} variants that should be emitted.\n @end deftypefn"}, {"sha": "68ee4c2c3b060dffa51f0f17a12cd2b8c90f330f", "filename": "gcc/omp-simd-clone.cc", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f134a25ee8c29646f35f7e466109f6a7f5b9e824/gcc%2Fomp-simd-clone.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f134a25ee8c29646f35f7e466109f6a7f5b9e824/gcc%2Fomp-simd-clone.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-simd-clone.cc?ref=f134a25ee8c29646f35f7e466109f6a7f5b9e824", "patch": "@@ -504,7 +504,10 @@ simd_clone_adjust_return_type (struct cgraph_node *node)\n     veclen = node->simdclone->vecsize_int;\n   else\n     veclen = node->simdclone->vecsize_float;\n-  veclen = exact_div (veclen, GET_MODE_BITSIZE (SCALAR_TYPE_MODE (t)));\n+  if (known_eq (veclen, 0))\n+    veclen = node->simdclone->simdlen;\n+  else\n+    veclen = exact_div (veclen, GET_MODE_BITSIZE (SCALAR_TYPE_MODE (t)));\n   if (multiple_p (veclen, node->simdclone->simdlen))\n     veclen = node->simdclone->simdlen;\n   if (POINTER_TYPE_P (t))\n@@ -618,8 +621,12 @@ simd_clone_adjust_argument_types (struct cgraph_node *node)\n \t    veclen = sc->vecsize_int;\n \t  else\n \t    veclen = sc->vecsize_float;\n-\t  veclen = exact_div (veclen,\n-\t\t\t      GET_MODE_BITSIZE (SCALAR_TYPE_MODE (parm_type)));\n+\t  if (known_eq (veclen, 0))\n+\t    veclen = sc->simdlen;\n+\t  else\n+\t    veclen\n+\t      = exact_div (veclen,\n+\t\t\t   GET_MODE_BITSIZE (SCALAR_TYPE_MODE (parm_type)));\n \t  if (multiple_p (veclen, sc->simdlen))\n \t    veclen = sc->simdlen;\n \t  adj.op = IPA_PARAM_OP_NEW;\n@@ -669,8 +676,11 @@ simd_clone_adjust_argument_types (struct cgraph_node *node)\n \tveclen = sc->vecsize_int;\n       else\n \tveclen = sc->vecsize_float;\n-      veclen = exact_div (veclen,\n-\t\t\t  GET_MODE_BITSIZE (SCALAR_TYPE_MODE (base_type)));\n+      if (known_eq (veclen, 0))\n+\tveclen = sc->simdlen;\n+      else\n+\tveclen = exact_div (veclen,\n+\t\t\t    GET_MODE_BITSIZE (SCALAR_TYPE_MODE (base_type)));\n       if (multiple_p (veclen, sc->simdlen))\n \tveclen = sc->simdlen;\n       if (sc->mask_mode != VOIDmode)"}, {"sha": "4d49ffc2c88077578c0b913f4c053df6c9ccb82a", "filename": "gcc/target.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f134a25ee8c29646f35f7e466109f6a7f5b9e824/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f134a25ee8c29646f35f7e466109f6a7f5b9e824/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=f134a25ee8c29646f35f7e466109f6a7f5b9e824", "patch": "@@ -1629,6 +1629,9 @@ DEFHOOK\n \"This hook should set @var{vecsize_mangle}, @var{vecsize_int}, @var{vecsize_float}\\n\\\n fields in @var{simd_clone} structure pointed by @var{clone_info} argument and also\\n\\\n @var{simdlen} field if it was previously 0.\\n\\\n+@var{vecsize_mangle} is a marker for the backend only. @var{vecsize_int} and\\n\\\n+@var{vecsize_float} should be left zero on targets where the number of lanes is\\n\\\n+not determined by the bitsize (in which case @var{simdlen} is always used).\\n\\\n The hook should return 0 if SIMD clones shouldn't be emitted,\\n\\\n or number of @var{vecsize_mangle} variants that should be emitted.\",\n int, (struct cgraph_node *, struct cgraph_simd_clone *, tree, int), NULL)"}]}