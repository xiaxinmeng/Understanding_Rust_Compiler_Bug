{"sha": "6ce0c3f5ed442fe46a2ba21de5a437704791dae5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNlMGMzZjVlZDQ0MmZlNDZhMmJhMjFkZTVhNDM3NzA0NzkxZGFlNQ==", "commit": {"author": {"name": "Thomas Quinot", "email": "quinot@adacore.com", "date": "2005-11-15T13:57:46Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-11-15T13:57:46Z"}, "message": "exp_dist.adb (Append_Array_Traversal): Modify constrained case to generate a set of nested array aggregates instead of...\n\n2005-11-14  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_dist.adb (Append_Array_Traversal): Modify constrained case to\n\tgenerate a set of nested array aggregates instead of a single flat\n\taggregate for multi-dimensional arrays.\n\nFrom-SVN: r106973", "tree": {"sha": "8d34c15a7af6355ed30ec16d56c0acc49a45cafe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d34c15a7af6355ed30ec16d56c0acc49a45cafe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ce0c3f5ed442fe46a2ba21de5a437704791dae5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ce0c3f5ed442fe46a2ba21de5a437704791dae5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ce0c3f5ed442fe46a2ba21de5a437704791dae5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ce0c3f5ed442fe46a2ba21de5a437704791dae5/comments", "author": null, "committer": null, "parents": [{"sha": "ed789fe9b07451de3170648409c7242083e21449", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed789fe9b07451de3170648409c7242083e21449", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed789fe9b07451de3170648409c7242083e21449"}], "stats": {"total": 151, "additions": 89, "deletions": 62}, "files": [{"sha": "4be4c869c80a73ccb922bfbf2f38e9908ebbe970", "filename": "gcc/ada/exp_dist.adb", "status": "modified", "additions": 89, "deletions": 62, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ce0c3f5ed442fe46a2ba21de5a437704791dae5/gcc%2Fada%2Fexp_dist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ce0c3f5ed442fe46a2ba21de5a437704791dae5/gcc%2Fada%2Fexp_dist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.adb?ref=6ce0c3f5ed442fe46a2ba21de5a437704791dae5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -97,7 +97,7 @@ package body Exp_Dist is\n    --  DSA expansion associates stubs to distributed object types using\n    --  a hash table on entity ids.\n \n-   function Hash (F : Name_Id)   return Hash_Index;\n+   function Hash (F : Name_Id) return Hash_Index;\n    --  The generation of subprogram identifiers requires an overload counter\n    --  to be associated with each remote subprogram names. These counters\n    --  are maintained in a hash table on name ids.\n@@ -270,7 +270,8 @@ package body Exp_Dist is\n    --  its constrained status.\n \n    function Is_RACW_Controlling_Formal\n-     (Parameter : Node_Id; Stub_Type : Entity_Id) return Boolean;\n+     (Parameter : Node_Id;\n+      Stub_Type : Entity_Id) return Boolean;\n    --  Return True if the current parameter is a controlling formal argument\n    --  of type Stub_Type or access to Stub_Type.\n \n@@ -10177,8 +10178,8 @@ package body Exp_Dist is\n          -- Find_Numeric_Representation --\n          ---------------------------------\n \n-         function Find_Numeric_Representation (Typ : Entity_Id)\n-           return Entity_Id\n+         function Find_Numeric_Representation\n+           (Typ : Entity_Id) return Entity_Id\n          is\n             FST    : constant Entity_Id := First_Subtype (Typ);\n             P_Size : constant Uint      := Esize (FST);\n@@ -10286,26 +10287,38 @@ package body Exp_Dist is\n             Append_To (Indices,\n               Make_Identifier (Loc, New_External_Name ('L', Depth)));\n \n-            if Constrained then\n-               Inner_Any := Any;\n-               Inner_Counter := Counter;\n-            else\n+            if not Constrained or else Depth > 1 then\n                Inner_Any := Make_Defining_Identifier (Loc,\n-                 New_External_Name ('A', Depth));\n+                              New_External_Name ('A', Depth));\n                Set_Etype (Inner_Any, RTE (RE_Any));\n+            else\n+               Inner_Any := Empty;\n+            end if;\n \n-               if Present (Counter) then\n-                  Inner_Counter := Make_Defining_Identifier (Loc,\n-                    New_External_Name ('J', Depth));\n-               else\n-                  Inner_Counter := Empty;\n-               end if;\n+            if Present (Counter) then\n+               Inner_Counter := Make_Defining_Identifier (Loc,\n+                                  New_External_Name ('J', Depth));\n+            else\n+               Inner_Counter := Empty;\n             end if;\n \n-            Append_Array_Traversal (Inner_Stmts,\n-              Any     => Inner_Any,\n-              Counter => Inner_Counter,\n-              Depth   => Depth + 1);\n+            declare\n+               Loop_Any : Node_Id := Inner_Any;\n+            begin\n+\n+               --  For the first dimension of a constrained array, we add\n+               --  elements directly in the corresponding Any; there is no\n+               --  intervening inner Any.\n+\n+               if No (Loop_Any) then\n+                  Loop_Any := Any;\n+               end if;\n+\n+               Append_Array_Traversal (Inner_Stmts,\n+                 Any     => Loop_Any,\n+                 Counter => Inner_Counter,\n+                 Depth   => Depth + 1);\n+            end;\n \n             Loop_Stm :=\n               Make_Implicit_Loop_Statement (Subprogram,\n@@ -10326,11 +10339,6 @@ package body Exp_Dist is\n                               Make_Integer_Literal (Loc, Depth))))),\n                 Statements => Inner_Stmts);\n \n-            if Constrained then\n-               Append_To (Stmts, Loop_Stm);\n-               return;\n-            end if;\n-\n             declare\n                Decls       : constant List_Id := New_List;\n                Dimen_Stmts : constant List_Id := New_List;\n@@ -10344,13 +10352,22 @@ package body Exp_Dist is\n \n             begin\n                if Depth = 1 then\n-                  Inner_Any_TypeCode_Expr :=\n-                    Make_Function_Call (Loc,\n-                      Name =>\n-                        New_Occurrence_Of (RTE (RE_Any_Member_Type), Loc),\n-                      Parameter_Associations => New_List (\n-                        New_Occurrence_Of (Any, Loc),\n-                        Make_Integer_Literal (Loc, Ndim)));\n+                  if Constrained then\n+                     Inner_Any_TypeCode_Expr :=\n+                       Make_Function_Call (Loc,\n+                         Name =>\n+                           New_Occurrence_Of (RTE (RE_Get_TC), Loc),\n+                         Parameter_Associations => New_List (\n+                           New_Occurrence_Of (Any, Loc)));\n+                  else\n+                     Inner_Any_TypeCode_Expr :=\n+                       Make_Function_Call (Loc,\n+                         Name =>\n+                           New_Occurrence_Of (RTE (RE_Any_Member_Type), Loc),\n+                             Parameter_Associations => New_List (\n+                               New_Occurrence_Of (Any, Loc),\n+                               Make_Integer_Literal (Loc, Ndim)));\n+                  end if;\n                else\n                   Inner_Any_TypeCode_Expr :=\n                     Make_Function_Call (Loc,\n@@ -10368,18 +10385,21 @@ package body Exp_Dist is\n                    Object_Definition   => New_Occurrence_Of (\n                                             RTE (RE_TypeCode), Loc),\n                    Expression          => Inner_Any_TypeCode_Expr));\n-               Append_To (Decls,\n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier => Inner_Any,\n-                   Object_Definition   =>\n-                     New_Occurrence_Of (RTE (RE_Any), Loc),\n-                   Expression          =>\n-                     Make_Function_Call (Loc,\n-                       Name =>\n-                         New_Occurrence_Of (\n-                           RTE (RE_Create_Any), Loc),\n-                       Parameter_Associations => New_List (\n-                         New_Occurrence_Of (Inner_Any_TypeCode, Loc)))));\n+\n+               if Present (Inner_Any) then\n+                  Append_To (Decls,\n+                    Make_Object_Declaration (Loc,\n+                      Defining_Identifier => Inner_Any,\n+                      Object_Definition   =>\n+                        New_Occurrence_Of (RTE (RE_Any), Loc),\n+                      Expression          =>\n+                        Make_Function_Call (Loc,\n+                          Name =>\n+                            New_Occurrence_Of (\n+                              RTE (RE_Create_Any), Loc),\n+                          Parameter_Associations => New_List (\n+                            New_Occurrence_Of (Inner_Any_TypeCode, Loc)))));\n+               end if;\n \n                if Present (Inner_Counter) then\n                   Append_To (Decls,\n@@ -10391,17 +10411,19 @@ package body Exp_Dist is\n                         Make_Integer_Literal (Loc, 0)));\n                end if;\n \n-               Length_Node := Make_Attribute_Reference (Loc,\n-                     Prefix         => New_Occurrence_Of (Arry, Loc),\n-                     Attribute_Name => Name_Length,\n-                     Expressions    =>\n-                       New_List (Make_Integer_Literal (Loc, Depth)));\n-               Set_Etype (Length_Node, RTE (RE_Long_Unsigned));\n-\n-               Add_Process_Element (Dimen_Stmts,\n-                 Datum   => Length_Node,\n-                 Any     => Inner_Any,\n-                 Counter => Inner_Counter);\n+               if not Constrained then\n+                  Length_Node := Make_Attribute_Reference (Loc,\n+                        Prefix         => New_Occurrence_Of (Arry, Loc),\n+                        Attribute_Name => Name_Length,\n+                        Expressions    =>\n+                          New_List (Make_Integer_Literal (Loc, Depth)));\n+                  Set_Etype (Length_Node, RTE (RE_Long_Unsigned));\n+\n+                  Add_Process_Element (Dimen_Stmts,\n+                    Datum   => Length_Node,\n+                    Any     => Inner_Any,\n+                    Counter => Inner_Counter);\n+               end if;\n \n                --  Loop_Stm does approrpriate processing for each element\n                --  of Inner_Any.\n@@ -10410,10 +10432,12 @@ package body Exp_Dist is\n \n                --  Link outer and inner any\n \n-               Add_Process_Element (Dimen_Stmts,\n-                 Any     => Any,\n-                 Counter => Counter,\n-                 Datum   => New_Occurrence_Of (Inner_Any, Loc));\n+               if Present (Inner_Any) then\n+                  Add_Process_Element (Dimen_Stmts,\n+                    Any     => Any,\n+                    Counter => Counter,\n+                    Datum   => New_Occurrence_Of (Inner_Any, Loc));\n+               end if;\n \n                Append_To (Stmts,\n                  Make_Block_Statement (Loc,\n@@ -10532,9 +10556,10 @@ package body Exp_Dist is\n    -------------------\n \n    function Scope_Of_Spec (Spec : Node_Id) return Entity_Id is\n-      Unit_Name : Node_Id := Defining_Unit_Name (Spec);\n+      Unit_Name : Node_Id;\n \n    begin\n+      Unit_Name := Defining_Unit_Name (Spec);\n       while Nkind (Unit_Name) /= N_Defining_Identifier loop\n          Unit_Name := Defining_Identifier (Unit_Name);\n       end loop;\n@@ -10757,7 +10782,8 @@ package body Exp_Dist is\n      (Loc                   : Source_Ptr;\n       Decls                 : List_Id;\n       RCI_Locator           : Entity_Id;\n-      Controlling_Parameter : Entity_Id) return RPC_Target is\n+      Controlling_Parameter : Entity_Id) return RPC_Target\n+   is\n    begin\n       case Get_PCS_Name is\n          when Name_PolyORB_DSA =>\n@@ -10798,7 +10824,8 @@ package body Exp_Dist is\n       Dynamically_Asynchronous : Boolean   := False;\n       Stub_Type                : Entity_Id := Empty;\n       RACW_Type                : Entity_Id := Empty;\n-      Parent_Primitive         : Entity_Id := Empty) return Node_Id is\n+      Parent_Primitive         : Entity_Id := Empty) return Node_Id\n+   is\n    begin\n       case Get_PCS_Name is\n          when Name_PolyORB_DSA =>"}]}