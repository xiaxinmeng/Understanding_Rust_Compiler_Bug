{"sha": "80b0e34e580ae4b0598cb2029b1529b5b69752a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODBiMGUzNGU1ODBhZTRiMDU5OGNiMjAyOWIxNTI5YjViNjk3NTJhNg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-09-20T23:43:50Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-09-20T23:43:50Z"}, "message": "Fix indentation.  Carry out renamings from hash.h.\n\nRename args and locals also.\n\nFrom-SVN: r2193", "tree": {"sha": "d648b4cecf0a444baad53f7531bb81c2de9310da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d648b4cecf0a444baad53f7531bb81c2de9310da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80b0e34e580ae4b0598cb2029b1529b5b69752a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80b0e34e580ae4b0598cb2029b1529b5b69752a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80b0e34e580ae4b0598cb2029b1529b5b69752a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80b0e34e580ae4b0598cb2029b1529b5b69752a6/comments", "author": null, "committer": null, "parents": [{"sha": "d0bd180dfbdf889def8f0caa2bc187953ca77eb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0bd180dfbdf889def8f0caa2bc187953ca77eb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0bd180dfbdf889def8f0caa2bc187953ca77eb7"}], "stats": {"total": 179, "additions": 90, "deletions": 89}, "files": [{"sha": "dd8fa506d013c7fefa8296cfbbd60fdac61eec9b", "filename": "gcc/objc/hash.c", "status": "modified", "additions": 90, "deletions": 89, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80b0e34e580ae4b0598cb2029b1529b5b69752a6/gcc%2Fobjc%2Fhash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80b0e34e580ae4b0598cb2029b1529b5b69752a6/gcc%2Fobjc%2Fhash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fhash.c?ref=80b0e34e580ae4b0598cb2029b1529b5b69752a6", "patch": "@@ -23,10 +23,13 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    the executable file might be covered by the GNU General Public License.  */\n \n /* \n-  $Header: /home/fsf/rms/c-runtime/dispatch/RCS/hash.c,v 0.14 1992/08/31 21:09:15 dglattin Exp rms $\n-  $Author: dglattin $\n-  $Date: 1992/08/31 21:09:15 $\n+  $Header: /home/fsf/rms/c-runtime/dispatch/RCS/hash.c,v 0.15 1992/09/02 02:04:32 rms Exp rms $\n+  $Author: rms $\n+  $Date: 1992/09/02 02:04:32 $\n   $Log: hash.c,v $\n+ * Revision 0.15  1992/09/02  02:04:32  rms\n+ * Changed some decls.\n+ *\n  * Revision 0.14  1992/08/31  21:09:15  dglattin\n  * minor documentation changes.\n  *\n@@ -99,194 +102,192 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n                                                   \n    These equations are percentages.  */\n #define FULLNESS(cache) \\\n-   ((((cache)->sizeOfHash * 75) / 100) <= (cache)->entriesInHash)\n+   ((((cache)->size * 75) / 100) <= (cache)->used)\n #define EXPANSION(cache) \\\n-  ((cache)->sizeOfHash * 2)\n+  ((cache)->size * 2)\n \n-Cache_t \n-hash_new (u_int sizeOfHash, HashFunc aHashFunc, CompareFunc aCompareFunc)\n+cache_ptr \n+hash_new (u_int size, hash_func_type hash_func, compare_func_type compare_func)\n {\n-  Cache_t retCache;\n+  cache_ptr cache;\n \n \n   /* Pass me a value greater than 0 and a power of 2.  */\n-  assert (sizeOfHash);\n-  assert (!(sizeOfHash & (sizeOfHash - 1)));\n+  assert (size);\n+  assert (!(size & (size - 1)));\n   \n   /* Allocate the cache structure.  calloc insures\n      its initialization for default values.  */\n-  retCache = (Cache_t) calloc (1, sizeof (Cache));\n-  assert (retCache);\n+  cache = (cache_ptr) calloc (1, sizeof (struct cache));\n+  assert (cache);\n   \n   /* Allocate the array of buckets for the cache.  \n      calloc initializes all of the pointers to NULL.  */\n-  retCache->theNodeTable\n-    = (CacheNode_t *) calloc (sizeOfHash, sizeof (CacheNode_t));\n-  assert (retCache->theNodeTable);\n+  cache->node_table\n+    = (node_ptr *) calloc (size, sizeof (node_ptr));\n+  assert (cache->node_table);\n   \n-  retCache->sizeOfHash  = sizeOfHash;\n+  cache->size  = size;\n \n   /* This should work for all processor architectures? */\n-  retCache->mask = (sizeOfHash - 1);\n+  cache->mask = (size - 1);\n \t\n   /* Store the hashing function so that codes can be computed.  */\n-  retCache->hashFunc = aHashFunc;\n+  cache->hash_func = hash_func;\n \n   /* Store the function that compares hash keys to \n      determine if they are equal.  */\n-  retCache->compareFunc = aCompareFunc;\n+  cache->compare_func = compare_func;\n \n-  return retCache;\n+  return cache;\n }\n \n \n void \n-hash_delete (Cache_t theCache)\n+hash_delete (cache_ptr cache)\n {\n-  CacheNode_t aNode;\n+  node_ptr node;\n \n \n   /* Purge all key/value pairs from the table.  */\n-  while (aNode = hash_next (theCache, NULL))\n-    hash_remove (theCache, aNode->theKey);\n+  while (node = hash_next (cache, NULL))\n+    hash_remove (cache, node->key);\n \n   /* Release the array of nodes and the cache itself.  */\n-  free (theCache->theNodeTable);\n-  free (theCache);\n+  free (cache->node_table);\n+  free (cache);\n }\n \n \n void \n-hash_add (Cache_t *theCache, void *aKey, void *aValue)\n+hash_add (cache_ptr *cachep, void *key, void *value)\n {\n-  u_int       indx = (*(*theCache)->hashFunc)(*theCache, aKey);\n-  CacheNode_t aCacheNode = (CacheNode_t) calloc (1, sizeof (CacheNode));\n+  u_int indx = (*(*cachep)->hash_func)(*cachep, key);\n+  node_ptr node = (node_ptr) calloc (1, sizeof (struct cache_node));\n \n \n-  assert (aCacheNode);\n+  assert (node);\n   \n   /* Initialize the new node.  */\n-  aCacheNode->theKey    = aKey;\n-  aCacheNode->theValue  = aValue;\n-  aCacheNode->nextNode  = (*(*theCache)->theNodeTable) [indx];\n+  node->key    = key;\n+  node->value  = value;\n+  node->next  = (*(*cachep)->node_table)[indx];\n   \n   /* Debugging.\n      Check the list for another key.  */\n #ifdef DEBUG\n-  { CacheNode_t checkHashNode = (*(*theCache)->theNodeTable) [indx];\n+  { node_ptr node1 = (*(*cachep)->node_table)[indx];\n     \n-    while (checkHashNode) {\n+    while (node1) {\n     \n-      assert (checkHashNode->theKey != aKey);\n-      checkHashNode = checkHashNode->nextNode;\n+      assert (node1->key != key);\n+      node1 = node1->next;\n     }\n   }\n #endif\n \n   /* Install the node as the first element on the list.  */\n-  (*(*theCache)->theNodeTable) [indx] = aCacheNode;\n+  (*(*cachep)->node_table)[indx] = node;\n \n   /* Bump the number of entries in the cache.  */\n-  ++(*theCache)->entriesInHash;\n+  ++(*cachep)->used;\n   \n   /* Check the hash table's fullness.   We're going\n      to expand if it is above the fullness level.  */\n-  if (FULLNESS (*theCache)) {\n+  if (FULLNESS (*cachep)) {\n     \n     /* The hash table has reached its fullness level.  Time to\n        expand it. \n        \n        I'm using a slow method here but is built on other\n        primitive functions thereby increasing its \n        correctness.  */\n-    CacheNode_t aNode = NULL;\n-    Cache_t     newCache = hash_new (EXPANSION (*theCache), \n-\t\t\t\t     (*theCache)->hashFunc, \n-\t\t\t\t     (*theCache)->compareFunc);\n+    node_ptr node1 = NULL;\n+    cache_ptr new = hash_new (EXPANSION (*cachep), \n+\t\t\t      (*cachep)->hash_func, \n+\t\t\t      (*cachep)->compare_func);\n \n     DEBUG_PRINTF (stderr, \"Expanding cache %#x from %d to %d\\n\",\n-\t\t  *theCache, (*theCache)->sizeOfHash, newCache->sizeOfHash);\n+\t\t  *cachep, (*cachep)->size, new->size);\n       \n     /* Copy the nodes from the first hash table to the new one.  */\n-    while (aNode = hash_next (*theCache, aNode))\n-      hash_add (&newCache, aNode->theKey, aNode->theValue);\n+    while (node1 = hash_next (*cachep, node1))\n+      hash_add (&new, node1->key, node1->value);\n \n     /* Trash the old cache.  */\n-    hash_delete (*theCache);\n+    hash_delete (*cachep);\n     \n     /* Return a pointer to the new hash table.  */\n-    *theCache = newCache;\n+    *cachep = new;\n   }\n }\n \n \n void \n-hash_remove (Cache_t theCache, void *aKey)\n+hash_remove (cache_ptr cache, void *key)\n {\n-  u_int       indx = (*theCache->hashFunc)(theCache, aKey);\n-  CacheNode_t aCacheNode = (*theCache->theNodeTable) [indx];\n+  u_int indx = (*cache->hash_func)(cache, key);\n+  node_ptr node = (*cache->node_table)[indx];\n   \n   \n   /* We assume there is an entry in the table.  Error if it is not.  */\n-  assert (aCacheNode);\n+  assert (node);\n   \n   /* Special case.  First element is the key/value pair to be removed.  */\n-  if ((*theCache->compareFunc)(aCacheNode->theKey, aKey)) {\n-    (*theCache->theNodeTable) [indx] = aCacheNode->nextNode;\n-    free (aCacheNode);\n+  if ((*cache->compare_func)(node->key, key)) {\n+    (*cache->node_table)[indx] = node->next;\n+    free (node);\n   } else {\n \n     /* Otherwise, find the hash entry.  */\n-    CacheNode_t prevHashNode = aCacheNode;\n+    node_ptr prev = node;\n     BOOL        removed = NO;\n     \n     do {\n     \n-      if ((*theCache->compareFunc)(aCacheNode->theKey, aKey)) {\n-        prevHashNode->nextNode = aCacheNode->nextNode, removed = YES;\n-        free (aCacheNode);\n+      if ((*cache->compare_func)(node->key, key)) {\n+        prev->next = node->next, removed = YES;\n+        free (node);\n       } else\n-        prevHashNode = aCacheNode, aCacheNode = aCacheNode->nextNode;\n-    } while (!removed && aCacheNode);\n+        prev = node, node = node->next;\n+    } while (!removed && node);\n     assert (removed);\n   }\n   \n   /* Decrement the number of entries in the hash table.  */\n-  --theCache->entriesInHash;\n+  --cache->used;\n }\n \n \n-CacheNode_t \n-hash_next (Cache_t theCache, CacheNode_t aCacheNode)\n+node_ptr \n+hash_next (cache_ptr cache, node_ptr node)\n {\n-  CacheNode_t theCacheNode = aCacheNode;\n-\n-\n   /* If the scan is being started then reset the last node \n      visitied pointer and bucket index.  */\n-  if (!theCacheNode)\n-    theCache->lastBucket  = 0;\n+  if (!node)\n+    cache->last_bucket  = 0;\n   \n   /* If there is a node visited last then check for another \n      entry in the same bucket;  Otherwise step to the next bucket.  */\n-  if (theCacheNode)\n-    if (theCacheNode->nextNode)\n+  if (node) {\n+    if (node->next)\n       /* There is a node which follows the last node \n \t returned.  Step to that node and retun it.  */\n-      return theCacheNode->nextNode;\n+      return node->next;\n     else\n-      ++theCache->lastBucket;\n+      ++cache->last_bucket;\n+  }\n \n   /* If the list isn't exhausted then search the buckets for \n      other nodes.  */\n-  if (theCache->lastBucket < theCache->sizeOfHash) {\n+  if (cache->last_bucket < cache->size) {\n     /*  Scan the remainder of the buckets looking for an entry\n \tat the head of the list.  Return the first item found.  */\n-    while (theCache->lastBucket < theCache->sizeOfHash)\n-      if ((*theCache->theNodeTable) [theCache->lastBucket])\n-        return (*theCache->theNodeTable) [theCache->lastBucket];\n+    while (cache->last_bucket < cache->size)\n+      if ((*cache->node_table)[cache->last_bucket])\n+        return (*cache->node_table)[cache->last_bucket];\n       else\n-        ++theCache->lastBucket;\n+        ++cache->last_bucket;\n   \n     /* No further nodes were found in the hash table.  */\n     return NULL;\n@@ -300,20 +301,20 @@ hash_next (Cache_t theCache, CacheNode_t aCacheNode)\n  * key/value pair isn't in the hash. \n  */\n void *\n-hash_value_for_key (Cache_t theCache, void *aKey)\n+hash_value_for_key (cache_ptr cache, void *key)\n {\n-  CacheNode_t aCacheNode\n-    =  (*theCache->theNodeTable) [(*theCache->hashFunc)(theCache, aKey)];\n-  void        *retVal = NULL;\n+  node_ptr node\n+    =  (*cache->node_table)[(*cache->hash_func)(cache, key)];\n+  void *retval = NULL;\n   \n \n-  if (aCacheNode)\n+  if (node)\n     do {\n-      if ((*theCache->compareFunc)(aCacheNode->theKey, aKey))\n-        retVal = aCacheNode->theValue;\n+      if ((*cache->compare_func)(node->key, key))\n+        retval = node->value;\n       else\n-        aCacheNode = aCacheNode->nextNode;\n-    } while (!retVal && aCacheNode);\n+        node = node->next;\n+    } while (!retval && node);\n   \n-  return retVal;\n+  return retval;\n }"}]}