{"sha": "754af126c04251c045d99b808915d9fde11de8a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzU0YWYxMjZjMDQyNTFjMDQ1ZDk5YjgwODkxNWQ5ZmRlMTFkZThhNQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2011-05-09T19:24:50Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2011-05-09T19:24:50Z"}, "message": "re PR c++/48737 ([C++0x][SFINAE] Hard errors with array list-construction with too many elements)\n\n/cp\n2011-05-09  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/48737\n\tPR c++/48744\n\t* decl.c (reshape_init): Take a complain parameter and do\n\tnot call error if tf_error is not set.\n\t(check_initializer, reshape_init_r, reshape_init_array,\n\treshape_init_array_1, reshape_init_vector, reshape_init_class):\n\tAdjust.\n\t* typeck2.c (digest_init_r): Take a complain parameter and\n\tpass it to convert_for_initialization.\n\t(digest_init, digest_init_flags, process_init_constructor_array,\n\tprocess_init_constructor_record, process_init_constructor_union,\n\tprocess_init_constructor, digest_init_r): Adjust.\n\t* init.c (expand_default_init, build_new_1): Likewise.\n\t* typeck.c (cp_build_modify_expr): Likewise.\n\t* decl2.c (grokfield): Likewise.\n\t* call.c (convert_like_real, convert_default_arg): Likewise.\n\t* semantics.c (finish_compound_literal): Pass complain to\n\treshape_init and digest_init.\n\t* cp-tree.h: Adjust declarations.\n\n/testsuite\n2011-05-09  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/48737\n\tPR c++/48744\n\t* g++.dg/template/sfinae28.C: New.\n\t* g++.dg/template/sfinae29.C: Likewise.\n\nFrom-SVN: r173590", "tree": {"sha": "1c5d88069cb3be67ae847b2bf84b28808589d61f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c5d88069cb3be67ae847b2bf84b28808589d61f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/754af126c04251c045d99b808915d9fde11de8a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/754af126c04251c045d99b808915d9fde11de8a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/754af126c04251c045d99b808915d9fde11de8a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/754af126c04251c045d99b808915d9fde11de8a5/comments", "author": null, "committer": null, "parents": [{"sha": "e4c0337862a3d76255d4ad7be49b4435910ede1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4c0337862a3d76255d4ad7be49b4435910ede1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4c0337862a3d76255d4ad7be49b4435910ede1e"}], "stats": {"total": 283, "additions": 206, "deletions": 77}, "files": [{"sha": "b89280dbda345d44426fcd0336f67e367bd4012a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754af126c04251c045d99b808915d9fde11de8a5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754af126c04251c045d99b808915d9fde11de8a5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=754af126c04251c045d99b808915d9fde11de8a5", "patch": "@@ -1,5 +1,27 @@\n+2011-05-09  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/48737\n+\tPR c++/48744\n+\t* decl.c (reshape_init): Take a complain parameter and do\n+\tnot call error if tf_error is not set.\n+\t(check_initializer, reshape_init_r, reshape_init_array,\n+\treshape_init_array_1, reshape_init_vector, reshape_init_class):\n+\tAdjust.\n+\t* typeck2.c (digest_init_r): Take a complain parameter and\n+\tpass it to convert_for_initialization.\n+\t(digest_init, digest_init_flags, process_init_constructor_array,\n+\tprocess_init_constructor_record, process_init_constructor_union,\n+\tprocess_init_constructor, digest_init_r): Adjust.\n+\t* init.c (expand_default_init, build_new_1): Likewise.\n+\t* typeck.c (cp_build_modify_expr): Likewise.\n+\t* decl2.c (grokfield): Likewise.\n+\t* call.c (convert_like_real, convert_default_arg): Likewise.\n+\t* semantics.c (finish_compound_literal): Pass complain to\n+\treshape_init and digest_init.\n+\t* cp-tree.h: Adjust declarations.\n+\n 2011-05-07  Fabien Ch\u00eane  <fabien@gcc.gnu.org>\n-\t\n+\n \tPR c++/48859\n \t* init.c (diagnose_uninitialized_cst_or_ref_member_1): stop the\n \trecursion if there is user defined constructor."}, {"sha": "095d1b0cb294a6492069be1ef9b8e53a3f71cff9", "filename": "gcc/cp/call.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754af126c04251c045d99b808915d9fde11de8a5/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754af126c04251c045d99b808915d9fde11de8a5/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=754af126c04251c045d99b808915d9fde11de8a5", "patch": "@@ -5670,7 +5670,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t  expr = build2 (COMPLEX_EXPR, totype, real, imag);\n \t  return fold_if_not_in_template (expr);\n \t}\n-      return get_target_expr (digest_init (totype, expr));\n+      return get_target_expr (digest_init (totype, expr, complain));\n \n     default:\n       break;\n@@ -6032,7 +6032,7 @@ convert_default_arg (tree type, tree arg, tree fn, int parmnum)\n   arg = break_out_target_exprs (arg);\n   if (TREE_CODE (arg) == CONSTRUCTOR)\n     {\n-      arg = digest_init (type, arg);\n+      arg = digest_init (type, arg, tf_warning_or_error);\n       arg = convert_for_initialization (0, type, arg, LOOKUP_IMPLICIT,\n \t\t\t\t\tICR_DEFAULT_ARGUMENT, fn, parmnum,\n                                         tf_warning_or_error);"}, {"sha": "53092ffc6e706a1eb792720b7d41034769ced2cf", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754af126c04251c045d99b808915d9fde11de8a5/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754af126c04251c045d99b808915d9fde11de8a5/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=754af126c04251c045d99b808915d9fde11de8a5", "patch": "@@ -4903,7 +4903,7 @@ extern tree cxx_comdat_group\t\t\t(tree);\n extern bool cp_missing_noreturn_ok_p\t\t(tree);\n extern void initialize_artificial_var\t\t(tree, VEC(constructor_elt,gc) *);\n extern tree check_var_type\t\t\t(tree, tree);\n-extern tree reshape_init (tree, tree);\n+extern tree reshape_init                        (tree, tree, tsubst_flags_t);\n extern tree next_initializable_field (tree);\n \n extern bool defer_mark_used_calls;\n@@ -5669,7 +5669,7 @@ extern int abstract_virtuals_error_sfinae\t(tree, tree, tsubst_flags_t);\n \n extern tree store_init_value\t\t\t(tree, tree, int);\n extern void check_narrowing\t\t\t(tree, tree);\n-extern tree digest_init\t\t\t\t(tree, tree);\n+extern tree digest_init\t\t\t\t(tree, tree, tsubst_flags_t);\n extern tree digest_init_flags\t\t\t(tree, tree, int);\n extern tree build_scoped_ref\t\t\t(tree, tree, tree *);\n extern tree build_x_arrow\t\t\t(tree);"}, {"sha": "ab36d18552ae7f9ce60fdd6efdc46fda094c1077", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 43, "deletions": 25, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754af126c04251c045d99b808915d9fde11de8a5/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754af126c04251c045d99b808915d9fde11de8a5/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=754af126c04251c045d99b808915d9fde11de8a5", "patch": "@@ -4878,7 +4878,7 @@ typedef struct reshape_iterator_t\n   constructor_elt *end;\n } reshape_iter;\n \n-static tree reshape_init_r (tree, reshape_iter *, bool);\n+static tree reshape_init_r (tree, reshape_iter *, bool, tsubst_flags_t);\n \n /* FIELD is a FIELD_DECL or NULL.  In the former case, the value\n    returned is the next FIELD_DECL (possibly FIELD itself) that can be\n@@ -4904,7 +4904,8 @@ next_initializable_field (tree field)\n    the iterator within the constructor.  */\n \n static tree\n-reshape_init_array_1 (tree elt_type, tree max_index, reshape_iter *d)\n+reshape_init_array_1 (tree elt_type, tree max_index, reshape_iter *d,\n+\t\t      tsubst_flags_t complain)\n {\n   tree new_init;\n   bool sized_array_p = (max_index != NULL_TREE);\n@@ -4936,7 +4937,8 @@ reshape_init_array_1 (tree elt_type, tree max_index, reshape_iter *d)\n       tree elt_init;\n \n       check_array_designated_initializer (d->cur);\n-      elt_init = reshape_init_r (elt_type, d, /*first_initializer_p=*/false);\n+      elt_init = reshape_init_r (elt_type, d, /*first_initializer_p=*/false,\n+\t\t\t\t complain);\n       if (elt_init == error_mark_node)\n \treturn error_mark_node;\n       CONSTRUCTOR_APPEND_ELT (CONSTRUCTOR_ELTS (new_init),\n@@ -4952,7 +4954,7 @@ reshape_init_array_1 (tree elt_type, tree max_index, reshape_iter *d)\n    Parameters are the same of reshape_init_r.  */\n \n static tree\n-reshape_init_array (tree type, reshape_iter *d)\n+reshape_init_array (tree type, reshape_iter *d, tsubst_flags_t complain)\n {\n   tree max_index = NULL_TREE;\n \n@@ -4961,14 +4963,14 @@ reshape_init_array (tree type, reshape_iter *d)\n   if (TYPE_DOMAIN (type))\n     max_index = array_type_nelts (type);\n \n-  return reshape_init_array_1 (TREE_TYPE (type), max_index, d);\n+  return reshape_init_array_1 (TREE_TYPE (type), max_index, d, complain);\n }\n \n /* Subroutine of reshape_init_r, processes the initializers for vectors.\n    Parameters are the same of reshape_init_r.  */\n \n static tree\n-reshape_init_vector (tree type, reshape_iter *d)\n+reshape_init_vector (tree type, reshape_iter *d, tsubst_flags_t complain)\n {\n   tree max_index = NULL_TREE;\n \n@@ -4979,8 +4981,9 @@ reshape_init_vector (tree type, reshape_iter *d)\n       tree value = d->cur->value;\n       if (!same_type_p (TREE_TYPE (value), type))\n \t{\n-\t  error (\"invalid type %qT as initializer for a vector of type %qT\",\n-\t\tTREE_TYPE (d->cur->value), type);\n+\t  if (complain & tf_error)\n+\t    error (\"invalid type %qT as initializer for a vector of type %qT\",\n+\t\t   TREE_TYPE (d->cur->value), type);\n \t  value = error_mark_node;\n \t}\n       ++d->cur;\n@@ -4991,14 +4994,15 @@ reshape_init_vector (tree type, reshape_iter *d)\n   if (TREE_CODE (type) == VECTOR_TYPE)\n     max_index = size_int (TYPE_VECTOR_SUBPARTS (type) - 1);\n \n-  return reshape_init_array_1 (TREE_TYPE (type), max_index, d);\n+  return reshape_init_array_1 (TREE_TYPE (type), max_index, d, complain);\n }\n \n /* Subroutine of reshape_init_r, processes the initializers for classes\n    or union. Parameters are the same of reshape_init_r.  */\n \n static tree\n-reshape_init_class (tree type, reshape_iter *d, bool first_initializer_p)\n+reshape_init_class (tree type, reshape_iter *d, bool first_initializer_p,\n+\t\t    tsubst_flags_t complain)\n {\n   tree field;\n   tree new_init;\n@@ -5018,7 +5022,8 @@ reshape_init_class (tree type, reshape_iter *d, bool first_initializer_p)\n \tinitializer-list {}.  */\n       if (!first_initializer_p)\n \t{\n-\t  error (\"initializer for %qT must be brace-enclosed\", type);\n+\t  if (complain & tf_error)\n+\t    error (\"initializer for %qT must be brace-enclosed\", type);\n \t  return error_mark_node;\n \t}\n       return new_init;\n@@ -5036,8 +5041,9 @@ reshape_init_class (tree type, reshape_iter *d, bool first_initializer_p)\n \n \t  if (!field || TREE_CODE (field) != FIELD_DECL)\n \t    {\n-\t      error (\"%qT has no non-static data member named %qD\", type,\n-\t\t    d->cur->index);\n+\t      if (complain & tf_error)\n+\t\terror (\"%qT has no non-static data member named %qD\", type,\n+\t\t       d->cur->index);\n \t      return error_mark_node;\n \t    }\n \t}\n@@ -5047,7 +5053,7 @@ reshape_init_class (tree type, reshape_iter *d, bool first_initializer_p)\n \tbreak;\n \n       field_init = reshape_init_r (TREE_TYPE (field), d,\n-\t\t\t\t   /*first_initializer_p=*/false);\n+\t\t\t\t   /*first_initializer_p=*/false, complain);\n       if (field_init == error_mark_node)\n \treturn error_mark_node;\n \n@@ -5074,7 +5080,8 @@ reshape_init_class (tree type, reshape_iter *d, bool first_initializer_p)\n    outermost CONSTRUCTOR node.  */\n \n static tree\n-reshape_init_r (tree type, reshape_iter *d, bool first_initializer_p)\n+reshape_init_r (tree type, reshape_iter *d, bool first_initializer_p,\n+\t\ttsubst_flags_t complain)\n {\n   tree init = d->cur->value;\n \n@@ -5089,7 +5096,12 @@ reshape_init_r (tree type, reshape_iter *d, bool first_initializer_p)\n       if (BRACE_ENCLOSED_INITIALIZER_P (init))\n \t{\n \t  if (CONSTRUCTOR_NELTS (init) > 2)\n-\t    error (\"too many initializers for %qT\", type);\n+\t    {\n+\t      if (complain & tf_error)\n+\t\terror (\"too many initializers for %qT\", type);\n+\t      else\n+\t\treturn error_mark_node;\n+\t    }\n \t}\n       else if (first_initializer_p && d->cur != d->end)\n \t{\n@@ -5116,7 +5128,8 @@ reshape_init_r (tree type, reshape_iter *d, bool first_initializer_p)\n \t{\n \t  if (SCALAR_TYPE_P (type))\n \t    {\n-\t      error (\"braces around scalar initializer for type %qT\", type);\n+\t      if (complain & tf_error)\n+\t\terror (\"braces around scalar initializer for type %qT\", type);\n \t      init = error_mark_node;\n \t    }\n \t  else\n@@ -5203,7 +5216,7 @@ reshape_init_r (tree type, reshape_iter *d, bool first_initializer_p)\n \t    {\n \t      ++d->cur;\n \t      gcc_assert (BRACE_ENCLOSED_INITIALIZER_P (init));\n-\t      return reshape_init (type, init);\n+\t      return reshape_init (type, init, complain);\n \t    }\n \t}\n \n@@ -5213,11 +5226,11 @@ reshape_init_r (tree type, reshape_iter *d, bool first_initializer_p)\n \n   /* Dispatch to specialized routines.  */\n   if (CLASS_TYPE_P (type))\n-    return reshape_init_class (type, d, first_initializer_p);\n+    return reshape_init_class (type, d, first_initializer_p, complain);\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n-    return reshape_init_array (type, d);\n+    return reshape_init_array (type, d, complain);\n   else if (TREE_CODE (type) == VECTOR_TYPE)\n-    return reshape_init_vector (type, d);\n+    return reshape_init_vector (type, d, complain);\n   else\n     gcc_unreachable();\n }\n@@ -5238,7 +5251,7 @@ reshape_init_r (tree type, reshape_iter *d, bool first_initializer_p)\n    revised CONSTRUCTOR node is returned.  */\n \n tree\n-reshape_init (tree type, tree init)\n+reshape_init (tree type, tree init, tsubst_flags_t complain)\n {\n   VEC(constructor_elt, gc) *v;\n   reshape_iter d;\n@@ -5257,14 +5270,19 @@ reshape_init (tree type, tree init)\n   d.cur = VEC_index (constructor_elt, v, 0);\n   d.end = d.cur + VEC_length (constructor_elt, v);\n \n-  new_init = reshape_init_r (type, &d, true);\n+  new_init = reshape_init_r (type, &d, true, complain);\n   if (new_init == error_mark_node)\n     return error_mark_node;\n \n   /* Make sure all the element of the constructor were used. Otherwise,\n      issue an error about exceeding initializers.  */\n   if (d.cur != d.end)\n-    error (\"too many initializers for %qT\", type);\n+    {\n+      if (complain & tf_error)\n+\terror (\"too many initializers for %qT\", type);\n+      else\n+\treturn error_mark_node;\n+    }\n \n   return new_init;\n }\n@@ -5417,7 +5435,7 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)\n \t      init = error_mark_node;\n \t    }\n \t  else\n-\t    init = reshape_init (type, init);\t    \n+\t    init = reshape_init (type, init, tf_warning_or_error);\t    \n \t}\n \n       /* If DECL has an array type without a specific bound, deduce the"}, {"sha": "91a66443bc8ad5579b2474ccca0ac937f7899c88", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754af126c04251c045d99b808915d9fde11de8a5/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754af126c04251c045d99b808915d9fde11de8a5/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=754af126c04251c045d99b808915d9fde11de8a5", "patch": "@@ -924,7 +924,7 @@ grokfield (const cp_declarator *declarator,\n       else if (!processing_template_decl)\n \t{\n \t  if (TREE_CODE (init) == CONSTRUCTOR)\n-\t    init = digest_init (TREE_TYPE (value), init);\n+\t    init = digest_init (TREE_TYPE (value), init, tf_warning_or_error);\n \t  init = maybe_constant_init (init);\n \n \t  if (init != error_mark_node && !TREE_CONSTANT (init))"}, {"sha": "b71ddfc0f9f7b627a349b8458e5978c47fda87dc", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754af126c04251c045d99b808915d9fde11de8a5/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754af126c04251c045d99b808915d9fde11de8a5/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=754af126c04251c045d99b808915d9fde11de8a5", "patch": "@@ -1435,7 +1435,7 @@ expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags,\n     {\n       /* A brace-enclosed initializer for an aggregate.  In C++0x this can\n \t happen for direct-initialization, too.  */\n-      init = digest_init (type, init);\n+      init = digest_init (type, init, complain);\n       init = build2 (INIT_EXPR, TREE_TYPE (exp), exp, init);\n       TREE_SIDE_EFFECTS (init) = 1;\n       finish_expr_stmt (init);\n@@ -2378,7 +2378,7 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n \t\t\t     \"verify length of initializer-list\");\n \t\t}\n \t      arraytype = build_cplus_array_type (type, domain);\n-\t      vecinit = digest_init (arraytype, vecinit);\n+\t      vecinit = digest_init (arraytype, vecinit, complain);\n \t    }\n \t  else if (*init)\n             {"}, {"sha": "0ba0370833b74828ed6aa927929f27a29bb45991", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754af126c04251c045d99b808915d9fde11de8a5/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754af126c04251c045d99b808915d9fde11de8a5/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=754af126c04251c045d99b808915d9fde11de8a5", "patch": "@@ -2369,7 +2369,7 @@ finish_compound_literal (tree type, tree compound_literal,\n   if (TREE_CODE (type) == ARRAY_TYPE\n       && check_array_initializer (NULL_TREE, type, compound_literal))\n     return error_mark_node;\n-  compound_literal = reshape_init (type, compound_literal);\n+  compound_literal = reshape_init (type, compound_literal, complain);\n   if (TREE_CODE (type) == ARRAY_TYPE\n       && TYPE_DOMAIN (type) == NULL_TREE)\n     {\n@@ -2378,7 +2378,7 @@ finish_compound_literal (tree type, tree compound_literal,\n       if (type == error_mark_node)\n \treturn error_mark_node;\n     }\n-  compound_literal = digest_init (type, compound_literal);\n+  compound_literal = digest_init (type, compound_literal, complain);\n   /* Put static/constant array temporaries in static variables, but always\n      represent class temporaries with TARGET_EXPR so we elide copies.  */\n   if ((!at_function_scope_p () || CP_TYPE_CONST_P (type))"}, {"sha": "d98c62bb940a75d68386156c2d6123b0d466110d", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754af126c04251c045d99b808915d9fde11de8a5/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754af126c04251c045d99b808915d9fde11de8a5/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=754af126c04251c045d99b808915d9fde11de8a5", "patch": "@@ -6715,7 +6715,7 @@ cp_build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs,\n \t    }\n \t  if (check_array_initializer (lhs, lhstype, newrhs))\n \t    return error_mark_node;\n-\t  newrhs = digest_init (lhstype, newrhs);\n+\t  newrhs = digest_init (lhstype, newrhs, complain);\n \t}\n \n       else if (!same_or_base_type_p (TYPE_MAIN_VARIANT (lhstype),"}, {"sha": "ec6b5d378504cb9fb103a8b86994d7bad6720121", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 87, "deletions": 41, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754af126c04251c045d99b808915d9fde11de8a5/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754af126c04251c045d99b808915d9fde11de8a5/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=754af126c04251c045d99b808915d9fde11de8a5", "patch": "@@ -39,7 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n \n static tree\n-process_init_constructor (tree type, tree init);\n+process_init_constructor (tree type, tree init, tsubst_flags_t complain);\n \n \n /* Print an error message stemming from an attempt to use\n@@ -783,8 +783,8 @@ check_narrowing (tree type, tree init)\n     }\n \n   if (!ok)\n-    permerror (input_location, \"narrowing conversion of %qE from %qT to %qT inside { }\",\n-\t       init, ftype, type);\n+    permerror (input_location, \"narrowing conversion of %qE from %qT \"\n+\t       \"to %qT inside { }\", init, ftype, type);\n }\n \n /* Process the initializer INIT for a variable of type TYPE, emitting\n@@ -797,7 +797,8 @@ check_narrowing (tree type, tree init)\n    NESTED is true iff we are being called for an element of a CONSTRUCTOR.  */\n \n static tree\n-digest_init_r (tree type, tree init, bool nested, int flags)\n+digest_init_r (tree type, tree init, bool nested, int flags,\n+\t       tsubst_flags_t complain)\n {\n   enum tree_code code = TREE_CODE (type);\n \n@@ -833,20 +834,24 @@ digest_init_r (tree type, tree init, bool nested, int flags)\n \t    {\n \t      if (char_type != char_type_node)\n \t\t{\n-\t\t  error (\"char-array initialized from wide string\");\n+\t\t  if (complain & tf_error)\n+\t\t    error (\"char-array initialized from wide string\");\n \t\t  return error_mark_node;\n \t\t}\n \t    }\n \t  else\n \t    {\n \t      if (char_type == char_type_node)\n \t\t{\n-\t\t  error (\"int-array initialized from non-wide string\");\n+\t\t  if (complain & tf_error)\n+\t\t    error (\"int-array initialized from non-wide string\");\n \t\t  return error_mark_node;\n \t\t}\n \t      else if (char_type != typ1)\n \t\t{\n-\t\t  error (\"int-array initialized from incompatible wide string\");\n+\t\t  if (complain & tf_error)\n+\t\t    error (\"int-array initialized from incompatible \"\n+\t\t\t   \"wide string\");\n \t\t  return error_mark_node;\n \t\t}\n \t    }\n@@ -861,7 +866,8 @@ digest_init_r (tree type, tree init, bool nested, int flags)\n \t\t counted in the length of the constant, but in C++ this would\n \t\t be invalid.  */\n \t      if (size < TREE_STRING_LENGTH (init))\n-\t\tpermerror (input_location, \"initializer-string for array of chars is too long\");\n+\t\tpermerror (input_location, \"initializer-string for array \"\n+\t\t\t   \"of chars is too long\");\n \t    }\n \t  return init;\n \t}\n@@ -878,7 +884,7 @@ digest_init_r (tree type, tree init, bool nested, int flags)\n \tcheck_narrowing (type, init);\n       init = convert_for_initialization (0, type, init, flags,\n \t\t\t\t\t ICR_INIT, NULL_TREE, 0,\n-\t\t\t\t\t tf_warning_or_error);\n+\t\t\t\t\t complain);\n       exp = &init;\n \n       /* Skip any conversions since we'll be outputting the underlying\n@@ -902,13 +908,14 @@ digest_init_r (tree type, tree init, bool nested, int flags)\n \n   if (BRACE_ENCLOSED_INITIALIZER_P (init)\n       && !TYPE_NON_AGGREGATE_CLASS (type))\n-    return process_init_constructor (type, init);\n+    return process_init_constructor (type, init, complain);\n   else\n     {\n       if (COMPOUND_LITERAL_P (init) && TREE_CODE (type) == ARRAY_TYPE)\n \t{\n-\t  error (\"cannot initialize aggregate of type %qT with \"\n-\t\t \"a compound literal\", type);\n+\t  if (complain & tf_error)\n+\t    error (\"cannot initialize aggregate of type %qT with \"\n+\t\t   \"a compound literal\", type);\n \n \t  return error_mark_node;\n \t}\n@@ -924,28 +931,29 @@ digest_init_r (tree type, tree init, bool nested, int flags)\n \t\t  (type, TREE_TYPE (init))))\n \t    return init;\n \n-\t  error (\"array must be initialized with a brace-enclosed\"\n-\t\t \" initializer\");\n+\t  if (complain & tf_error)\n+\t    error (\"array must be initialized with a brace-enclosed\"\n+\t\t   \" initializer\");\n \t  return error_mark_node;\n \t}\n \n       return convert_for_initialization (NULL_TREE, type, init,\n \t\t\t\t\t flags,\n \t\t\t\t\t ICR_INIT, NULL_TREE, 0,\n-                                         tf_warning_or_error);\n+                                         complain);\n     }\n }\n \n tree\n-digest_init (tree type, tree init)\n+digest_init (tree type, tree init, tsubst_flags_t complain)\n {\n-  return digest_init_r (type, init, false, LOOKUP_IMPLICIT);\n+  return digest_init_r (type, init, false, LOOKUP_IMPLICIT, complain);\n }\n \n tree\n digest_init_flags (tree type, tree init, int flags)\n {\n-  return digest_init_r (type, init, false, flags);\n+  return digest_init_r (type, init, false, flags, tf_warning_or_error);\n }\n \f\n /* Set of flags used within process_init_constructor to describe the\n@@ -974,7 +982,8 @@ picflag_from_initializer (tree init)\n    which describe the initializers.  */\n \n static int\n-process_init_constructor_array (tree type, tree init)\n+process_init_constructor_array (tree type, tree init,\n+\t\t\t\ttsubst_flags_t complain)\n {\n   unsigned HOST_WIDE_INT i, len = 0;\n   int flags = 0;\n@@ -1001,7 +1010,12 @@ process_init_constructor_array (tree type, tree init)\n \n   /* There must not be more initializers than needed.  */\n   if (!unbounded && VEC_length (constructor_elt, v)  > len)\n-    error (\"too many initializers for %qT\", type);\n+    {\n+      if (complain & tf_error)\n+\terror (\"too many initializers for %qT\", type);\n+      else\n+\treturn PICFLAG_ERRONEOUS;\n+    }\n \n   FOR_EACH_VEC_ELT (constructor_elt, v, i, ce)\n     {\n@@ -1017,7 +1031,8 @@ process_init_constructor_array (tree type, tree init)\n       else\n \tce->index = size_int (i);\n       gcc_assert (ce->value);\n-      ce->value = digest_init_r (TREE_TYPE (type), ce->value, true, LOOKUP_IMPLICIT);\n+      ce->value = digest_init_r (TREE_TYPE (type), ce->value, true,\n+\t\t\t\t LOOKUP_IMPLICIT, complain);\n \n       if (ce->value != error_mark_node)\n \tgcc_assert (same_type_ignoring_top_level_qualifiers_p\n@@ -1041,10 +1056,10 @@ process_init_constructor_array (tree type, tree init)\n \t      one up; if it's an array, recurse.  */\n \t    if (MAYBE_CLASS_TYPE_P (TREE_TYPE (type)))\n               next = build_functional_cast (TREE_TYPE (type), NULL_TREE,\n-                                            tf_warning_or_error);\n+                                            complain);\n \t    else\n \t      next = build_constructor (init_list_type_node, NULL);\n-\t    next = digest_init (TREE_TYPE (type), next);\n+\t    next = digest_init (TREE_TYPE (type), next, complain);\n \t  }\n \telse if (!zero_init_p (TREE_TYPE (type)))\n \t  next = build_zero_init (TREE_TYPE (type),\n@@ -1068,7 +1083,8 @@ process_init_constructor_array (tree type, tree init)\n    the initializers.  */\n \n static int\n-process_init_constructor_record (tree type, tree init)\n+process_init_constructor_record (tree type, tree init,\n+\t\t\t\t tsubst_flags_t complain)\n {\n   VEC(constructor_elt,gc) *v = NULL;\n   int flags = 0;\n@@ -1124,7 +1140,8 @@ process_init_constructor_record (tree type, tree init)\n \t    }\n \n \t  gcc_assert (ce->value);\n-\t  next = digest_init_r (type, ce->value, true, LOOKUP_IMPLICIT);\n+\t  next = digest_init_r (type, ce->value, true,\n+\t\t\t\tLOOKUP_IMPLICIT, complain);\n \t  ++idx;\n \t}\n       else if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (field)))\n@@ -1137,14 +1154,15 @@ process_init_constructor_record (tree type, tree init)\n \t  if (MAYBE_CLASS_TYPE_P (TREE_TYPE (field)))\n \t    {\n \t      next = finish_compound_literal (TREE_TYPE (field), next,\n-\t\t\t\t\t      tf_warning_or_error);\n+\t\t\t\t\t      complain);\n \t      /* direct-initialize the target. No temporary is going\n \t\t  to be involved.  */\n \t      if (TREE_CODE (next) == TARGET_EXPR)\n \t\tTARGET_EXPR_DIRECT_INIT_P (next) = true;\n \t    }\n \n-\t  next = digest_init_r (TREE_TYPE (field), next, true, LOOKUP_IMPLICIT);\n+\t  next = digest_init_r (TREE_TYPE (field), next, true,\n+\t\t\t\tLOOKUP_IMPLICIT, complain);\n \n \t  /* Warn when some struct elements are implicitly initialized.  */\n \t  warning (OPT_Wmissing_field_initializers,\n@@ -1153,11 +1171,26 @@ process_init_constructor_record (tree type, tree init)\n       else\n \t{\n \t  if (TREE_READONLY (field))\n-\t    error (\"uninitialized const member %qD\", field);\n+\t    {\n+\t      if (complain & tf_error)\n+\t\terror (\"uninitialized const member %qD\", field);\n+\t      else\n+\t\treturn PICFLAG_ERRONEOUS;\n+\t    }\n \t  else if (CLASSTYPE_READONLY_FIELDS_NEED_INIT (TREE_TYPE (field)))\n-\t    error (\"member %qD with uninitialized const fields\", field);\n+\t    {\n+\t      if (complain & tf_error)\n+\t\terror (\"member %qD with uninitialized const fields\", field);\n+\t      else\n+\t\treturn PICFLAG_ERRONEOUS;\n+\t    }\n \t  else if (TREE_CODE (TREE_TYPE (field)) == REFERENCE_TYPE)\n-\t    error (\"member %qD is uninitialized reference\", field);\n+\t    {\n+\t      if (complain & tf_error)\n+\t\terror (\"member %qD is uninitialized reference\", field);\n+\t      else\n+\t\treturn PICFLAG_ERRONEOUS;\n+\t    }\n \n \t  /* Warn when some struct elements are implicitly initialized\n \t     to zero.  */\n@@ -1181,8 +1214,13 @@ process_init_constructor_record (tree type, tree init)\n     }\n \n   if (idx < VEC_length (constructor_elt, CONSTRUCTOR_ELTS (init)))\n-    error (\"too many initializers for %qT\", type);\n-    \n+    {\n+      if (complain & tf_error)\n+\terror (\"too many initializers for %qT\", type);\n+      else\n+\treturn PICFLAG_ERRONEOUS;\n+    }\n+\n   CONSTRUCTOR_ELTS (init) = v;\n   return flags;\n }\n@@ -1192,7 +1230,8 @@ process_init_constructor_record (tree type, tree init)\n    which describe the initializer.  */\n \n static int\n-process_init_constructor_union (tree type, tree init)\n+process_init_constructor_union (tree type, tree init,\n+\t\t\t\ttsubst_flags_t complain)\n {\n   constructor_elt *ce;\n   int len;\n@@ -1204,6 +1243,8 @@ process_init_constructor_union (tree type, tree init)\n   len = VEC_length (constructor_elt, CONSTRUCTOR_ELTS (init));\n   if (len > 1)\n     {\n+      if (!(complain & tf_error))\n+\treturn PICFLAG_ERRONEOUS;\n       error (\"too many initializers for %qT\", type);\n       VEC_block_remove (constructor_elt, CONSTRUCTOR_ELTS (init), 1, len-1);\n     }\n@@ -1225,7 +1266,9 @@ process_init_constructor_union (tree type, tree init)\n \t      break;\n \t  if (!field)\n \t    {\n-\t      error (\"no field %qD found in union being initialized\", field);\n+\t      if (complain & tf_error)\n+\t\terror (\"no field %qD found in union being initialized\",\n+\t\t       field);\n \t      ce->value = error_mark_node;\n \t    }\n \t  ce->index = field;\n@@ -1234,7 +1277,8 @@ process_init_constructor_union (tree type, tree init)\n \t{\n \t  gcc_assert (TREE_CODE (ce->index) == INTEGER_CST\n \t\t      || TREE_CODE (ce->index) == RANGE_EXPR);\n-\t  error (\"index value instead of field name in union initializer\");\n+\t  if (complain & tf_error)\n+\t    error (\"index value instead of field name in union initializer\");\n \t  ce->value = error_mark_node;\n \t}\n     }\n@@ -1247,14 +1291,16 @@ process_init_constructor_union (tree type, tree init)\n \tfield = TREE_CHAIN (field);\n       if (field == NULL_TREE)\n \t{\n-\t  error (\"too many initializers for %qT\", type);\n+\t  if (complain & tf_error)\n+\t    error (\"too many initializers for %qT\", type);\n \t  ce->value = error_mark_node;\n \t}\n       ce->index = field;\n     }\n \n   if (ce->value && ce->value != error_mark_node)\n-    ce->value = digest_init_r (TREE_TYPE (ce->index), ce->value, true, LOOKUP_IMPLICIT);\n+    ce->value = digest_init_r (TREE_TYPE (ce->index), ce->value,\n+\t\t\t       true, LOOKUP_IMPLICIT, complain);\n \n   return picflag_from_initializer (ce->value);\n }\n@@ -1274,18 +1320,18 @@ process_init_constructor_union (tree type, tree init)\n    of error.  */\n \n static tree\n-process_init_constructor (tree type, tree init)\n+process_init_constructor (tree type, tree init, tsubst_flags_t complain)\n {\n   int flags;\n \n   gcc_assert (BRACE_ENCLOSED_INITIALIZER_P (init));\n \n   if (TREE_CODE (type) == ARRAY_TYPE || TREE_CODE (type) == VECTOR_TYPE)\n-    flags = process_init_constructor_array (type, init);\n+    flags = process_init_constructor_array (type, init, complain);\n   else if (TREE_CODE (type) == RECORD_TYPE)\n-    flags = process_init_constructor_record (type, init);\n+    flags = process_init_constructor_record (type, init, complain);\n   else if (TREE_CODE (type) == UNION_TYPE)\n-    flags = process_init_constructor_union (type, init);\n+    flags = process_init_constructor_union (type, init, complain);\n   else\n     gcc_unreachable ();\n "}, {"sha": "82478ea5c0e0e6be8175fbfa07dcb2f8237f86b7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754af126c04251c045d99b808915d9fde11de8a5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754af126c04251c045d99b808915d9fde11de8a5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=754af126c04251c045d99b808915d9fde11de8a5", "patch": "@@ -1,3 +1,10 @@\n+2011-05-09  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/48737\n+\tPR c++/48744\n+\t* g++.dg/template/sfinae28.C: New.\n+\t* g++.dg/template/sfinae29.C: Likewise.\n+\n 2011-05-09  Jason Merrill  <jason@redhat.com>\n \n \t* g++.dg/template/nontype23.C: New."}, {"sha": "be96983bf39919e15e6db19b9ea2b34eb414ec41", "filename": "gcc/testsuite/g++.dg/template/sfinae28.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754af126c04251c045d99b808915d9fde11de8a5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae28.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754af126c04251c045d99b808915d9fde11de8a5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae28.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae28.C?ref=754af126c04251c045d99b808915d9fde11de8a5", "patch": "@@ -0,0 +1,13 @@\n+// PR c++/48737\n+// { dg-options \"-std=c++0x\" }\n+\n+template<class T>\n+T&& create();\n+\n+template<class T, class... Args>\n+decltype(T{create<Args>()...}, char()) f(int);\n+\n+template<class, class...>\n+char (&f(...))[2];\n+\n+static_assert(sizeof(f<int[1], int, int>(0)) != 1, \"Error\");"}, {"sha": "486064c3af7664f36bafb6d9c03e26583ccd3c2f", "filename": "gcc/testsuite/g++.dg/template/sfinae29.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754af126c04251c045d99b808915d9fde11de8a5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae29.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754af126c04251c045d99b808915d9fde11de8a5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae29.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae29.C?ref=754af126c04251c045d99b808915d9fde11de8a5", "patch": "@@ -0,0 +1,23 @@\n+// PR c++/48744\n+// { dg-options \"-std=c++0x\" }\n+\n+template<class T>\n+struct add_rval_ref {\n+  typedef T&& type;\n+};\n+\n+template<>\n+struct add_rval_ref<void> {\n+  typedef void type;\n+};\n+\n+template<class T>\n+typename add_rval_ref<T>::type create();\n+\n+template<class T, class Arg>\n+decltype(T{create<Arg>()}, char()) f(int);\n+\n+template<class, class>\n+char (&f(...))[2];\n+\n+static_assert(sizeof(f<int, void>(0)) != 1, \"Error\");"}]}