{"sha": "bd60bab2ad76a635640db0101275111be8b04987", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ2MGJhYjJhZDc2YTYzNTY0MGRiMDEwMTI3NTExMWJlOGIwNDk4Nw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2008-03-31T17:08:31Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2008-03-31T17:08:31Z"}, "message": "builtins.c (expand_builtin_setjmp_receiver): Update call of get_arg_pointer_save_area.\n\n\n\t* builtins.c (expand_builtin_setjmp_receiver): Update call of\n\tget_arg_pointer_save_area.\n\t* expr.c (init_expr): Just clear out rtl.expr.\n\t* function.c (free_after_compilation): Clear out whole RTL structure.\n\t(get_func_frame_size): Merge into ...\n\t(get_frame_size): ... this one.\n\t(assign_stack_local_1): Merge into ...\n\t(assign_stack_local): ... this one.\n\t(expand_function_end): Update call of get_arg_pointer_save_area.\n\t(get_art_pointer_save_area): Remove cfun argument.\n\t* function.h (emit_status): regno_pointer_align does not need length\n\tattribute. Move x_regno_reg_rtx to ...\n\t(regno_reg_rtx): ... new global array.\n\t(reg_rtx_no, seq_stack, REGNO_POINTER_ALIGN): Update accestors.\n\t(pending_stack_adjust, inhibit_defer_pop, saveregs_value,\n\tapply_args_value, forced_labels, stack_pointer_delta): Update accestors.\n\t(struct varasm_status): Move here from varasm.c\n\t(struct rtl_data): New. Move here some fields from struct function.\n\t(return_label, naked_return_label, stack_slot_list, parm_birth_insn,\n\tframe_offset, stack_check_probe_note, arg_pointer_save_area,\n\tused_temp_slots avail_temp_slots, temp_slot_level,\n\tnonlocal_goto_handler_labels): Update accesstors.\n\t(rtl): New global variable.\n\t(struct function): Move some fileds to rtl_data.\n\t(get_arg_pointer_save_area): Update prototype.\n\t* emit-rtl.c (rtl): Declare.\n\t(regno_reg_rtx): Declare.\n\t(first_insn, last_insn, cur_insn_uid, last_location, first_label_num): Update.\n\t(gen_reg_rtx): Update.\n\t(init_virtual_regs): Do not tate emit_status argument.\n\t(init_emit): Do not allocate emit.\n\t* varasm.c (varasm_statuc): Move to function.h.\n\t(n_deferred_constatns): Update accestor.\n\t(init_varasm_status): Do not allocate varasm_status.\n\t(force_const_mem, get_pool_size, output_constant_pool): Update.\n\t* stmt.c (force_label_rtx): Do not use x_ prefixes.\n\t(expand_nl_goto_receiver): Update get_arg_pointer_save_area.\n\nFrom-SVN: r133759", "tree": {"sha": "484f1e4819fe26e37e4e3754778504623c82e3b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/484f1e4819fe26e37e4e3754778504623c82e3b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd60bab2ad76a635640db0101275111be8b04987", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd60bab2ad76a635640db0101275111be8b04987", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd60bab2ad76a635640db0101275111be8b04987", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd60bab2ad76a635640db0101275111be8b04987/comments", "author": null, "committer": null, "parents": [{"sha": "2566855a60b790dd23a7375319e7dc0ec7886cee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2566855a60b790dd23a7375319e7dc0ec7886cee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2566855a60b790dd23a7375319e7dc0ec7886cee"}], "stats": {"total": 417, "additions": 213, "deletions": 204}, "files": [{"sha": "bc37e45d0197f9b4128432b2b1f59279c164a767", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd60bab2ad76a635640db0101275111be8b04987/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd60bab2ad76a635640db0101275111be8b04987/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bd60bab2ad76a635640db0101275111be8b04987", "patch": "@@ -1,3 +1,43 @@\n+2008-03-31  Jan Hubicka  <jh@suse.cz>\n+\n+\t* builtins.c (expand_builtin_setjmp_receiver): Update call of\n+\tget_arg_pointer_save_area.\n+\t* expr.c (init_expr): Just clear out rtl.expr.\n+\t* function.c (free_after_compilation): Clear out whole RTL structure.\n+\t(get_func_frame_size): Merge into ...\n+\t(get_frame_size): ... this one.\n+\t(assign_stack_local_1): Merge into ...\n+\t(assign_stack_local): ... this one.\n+\t(expand_function_end): Update call of get_arg_pointer_save_area.\n+\t(get_art_pointer_save_area): Remove cfun argument.\n+\t* function.h (emit_status): regno_pointer_align does not need length\n+\tattribute. Move x_regno_reg_rtx to ...\n+\t(regno_reg_rtx): ... new global array.\n+\t(reg_rtx_no, seq_stack, REGNO_POINTER_ALIGN): Update accestors.\n+\t(pending_stack_adjust, inhibit_defer_pop, saveregs_value,\n+\tapply_args_value, forced_labels, stack_pointer_delta): Update accestors.\n+\t(struct varasm_status): Move here from varasm.c\n+\t(struct rtl_data): New. Move here some fields from struct function.\n+\t(return_label, naked_return_label, stack_slot_list, parm_birth_insn,\n+\tframe_offset, stack_check_probe_note, arg_pointer_save_area,\n+\tused_temp_slots avail_temp_slots, temp_slot_level,\n+\tnonlocal_goto_handler_labels): Update accesstors.\n+\t(rtl): New global variable.\n+\t(struct function): Move some fileds to rtl_data.\n+\t(get_arg_pointer_save_area): Update prototype.\n+\t* emit-rtl.c (rtl): Declare.\n+\t(regno_reg_rtx): Declare.\n+\t(first_insn, last_insn, cur_insn_uid, last_location, first_label_num): Update.\n+\t(gen_reg_rtx): Update.\n+\t(init_virtual_regs): Do not tate emit_status argument.\n+\t(init_emit): Do not allocate emit.\n+\t* varasm.c (varasm_statuc): Move to function.h.\n+\t(n_deferred_constatns): Update accestor.\n+\t(init_varasm_status): Do not allocate varasm_status.\n+\t(force_const_mem, get_pool_size, output_constant_pool): Update.\n+\t* stmt.c (force_label_rtx): Do not use x_ prefixes.\n+\t(expand_nl_goto_receiver): Update get_arg_pointer_save_area.\n+\n 2008-03-31  Zdenek Dvorak  <ook@ucw.cz>\n \n \tPR rtl-optimization/35729"}, {"sha": "f268738bb7dedfa48272f8e93415cc0961f254c9", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd60bab2ad76a635640db0101275111be8b04987/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd60bab2ad76a635640db0101275111be8b04987/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=bd60bab2ad76a635640db0101275111be8b04987", "patch": "@@ -741,7 +741,7 @@ expand_builtin_setjmp_receiver (rtx receiver_label ATTRIBUTE_UNUSED)\n \t  /* Now restore our arg pointer from the address at which it\n \t     was saved in our stack frame.  */\n \t  emit_move_insn (virtual_incoming_args_rtx,\n-\t\t\t  copy_to_reg (get_arg_pointer_save_area (cfun)));\n+\t\t\t  copy_to_reg (get_arg_pointer_save_area ()));\n \t}\n     }\n #endif"}, {"sha": "d000ee06b4323a97a4b792ea47103e76213e166f", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 33, "deletions": 28, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd60bab2ad76a635640db0101275111be8b04987/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd60bab2ad76a635640db0101275111be8b04987/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=bd60bab2ad76a635640db0101275111be8b04987", "patch": "@@ -66,6 +66,16 @@ enum machine_mode word_mode;\t/* Mode whose width is BITS_PER_WORD.  */\n enum machine_mode double_mode;\t/* Mode whose width is DOUBLE_TYPE_SIZE.  */\n enum machine_mode ptr_mode;\t/* Mode whose width is POINTER_SIZE.  */\n \n+/* Datastructures maintained for currently processed function in RTL form.  */\n+\n+struct rtl_data rtl;\n+\n+/* Indexed by pseudo register number, gives the rtx for that pseudo.\n+   Allocated in parallel with regno_pointer_align.  \n+   FIXME: We could put it into emit_status struct, but gengtype is not able to deal\n+   with length attribute nested in top level structures.  */\n+\n+rtx * regno_reg_rtx;\n \n /* This is *not* reset after each function.  It gives each CODE_LABEL\n    in the entire compilation a unique label number.  */\n@@ -162,11 +172,11 @@ static GTY ((if_marked (\"ggc_marked_p\"), param_is (struct rtx_def)))\n static GTY ((if_marked (\"ggc_marked_p\"), param_is (struct rtx_def)))\n      htab_t const_fixed_htab;\n \n-#define first_insn (cfun->emit->x_first_insn)\n-#define last_insn (cfun->emit->x_last_insn)\n-#define cur_insn_uid (cfun->emit->x_cur_insn_uid)\n-#define last_location (cfun->emit->x_last_location)\n-#define first_label_num (cfun->emit->x_first_label_num)\n+#define first_insn (rtl.emit.x_first_insn)\n+#define last_insn (rtl.emit.x_last_insn)\n+#define cur_insn_uid (rtl.emit.x_cur_insn_uid)\n+#define last_location (rtl.emit.x_last_location)\n+#define first_label_num (rtl.emit.x_first_label_num)\n \n static rtx make_call_insn_raw (rtx);\n static rtx change_address_1 (rtx, enum machine_mode, rtx, int);\n@@ -853,7 +863,6 @@ byte_lowpart_offset (enum machine_mode outer_mode,\n rtx\n gen_reg_rtx (enum machine_mode mode)\n {\n-  struct function *f = cfun;\n   rtx val;\n \n   gcc_assert (can_create_pseudo_p ());\n@@ -878,22 +887,22 @@ gen_reg_rtx (enum machine_mode mode)\n   /* Make sure regno_pointer_align, and regno_reg_rtx are large\n      enough to have an element for this pseudo reg number.  */\n \n-  if (reg_rtx_no == f->emit->regno_pointer_align_length)\n+  if (reg_rtx_no == rtl.emit.regno_pointer_align_length)\n     {\n-      int old_size = f->emit->regno_pointer_align_length;\n+      int old_size = rtl.emit.regno_pointer_align_length;\n       char *new;\n       rtx *new1;\n \n-      new = ggc_realloc (f->emit->regno_pointer_align, old_size * 2);\n+      new = xrealloc (rtl.emit.regno_pointer_align, old_size * 2);\n       memset (new + old_size, 0, old_size);\n-      f->emit->regno_pointer_align = (unsigned char *) new;\n+      rtl.emit.regno_pointer_align = (unsigned char *) new;\n \n-      new1 = ggc_realloc (f->emit->x_regno_reg_rtx,\n+      new1 = ggc_realloc (regno_reg_rtx,\n \t\t\t  old_size * 2 * sizeof (rtx));\n       memset (new1 + old_size, 0, old_size * sizeof (rtx));\n       regno_reg_rtx = new1;\n \n-      f->emit->regno_pointer_align_length = old_size * 2;\n+      rtl.emit.regno_pointer_align_length = old_size * 2;\n     }\n \n   val = gen_raw_REG (mode, reg_rtx_no);\n@@ -4789,14 +4798,13 @@ in_sequence_p (void)\n /* Put the various virtual registers into REGNO_REG_RTX.  */\n \n static void\n-init_virtual_regs (struct emit_status *es)\n+init_virtual_regs (void)\n {\n-  rtx *ptr = es->x_regno_reg_rtx;\n-  ptr[VIRTUAL_INCOMING_ARGS_REGNUM] = virtual_incoming_args_rtx;\n-  ptr[VIRTUAL_STACK_VARS_REGNUM] = virtual_stack_vars_rtx;\n-  ptr[VIRTUAL_STACK_DYNAMIC_REGNUM] = virtual_stack_dynamic_rtx;\n-  ptr[VIRTUAL_OUTGOING_ARGS_REGNUM] = virtual_outgoing_args_rtx;\n-  ptr[VIRTUAL_CFA_REGNUM] = virtual_cfa_rtx;\n+  regno_reg_rtx[VIRTUAL_INCOMING_ARGS_REGNUM] = virtual_incoming_args_rtx;\n+  regno_reg_rtx[VIRTUAL_STACK_VARS_REGNUM] = virtual_stack_vars_rtx;\n+  regno_reg_rtx[VIRTUAL_STACK_DYNAMIC_REGNUM] = virtual_stack_dynamic_rtx;\n+  regno_reg_rtx[VIRTUAL_OUTGOING_ARGS_REGNUM] = virtual_outgoing_args_rtx;\n+  regno_reg_rtx[VIRTUAL_CFA_REGNUM] = virtual_cfa_rtx;\n }\n \n \f\n@@ -4970,9 +4978,6 @@ copy_insn (rtx insn)\n void\n init_emit (void)\n {\n-  struct function *f = cfun;\n-\n-  f->emit = ggc_alloc (sizeof (struct emit_status));\n   first_insn = NULL;\n   last_insn = NULL;\n   cur_insn_uid = 1;\n@@ -4983,22 +4988,22 @@ init_emit (void)\n \n   /* Init the tables that describe all the pseudo regs.  */\n \n-  f->emit->regno_pointer_align_length = LAST_VIRTUAL_REGISTER + 101;\n+  rtl.emit.regno_pointer_align_length = LAST_VIRTUAL_REGISTER + 101;\n \n-  f->emit->regno_pointer_align\n-    = ggc_alloc_cleared (f->emit->regno_pointer_align_length\n-\t\t\t * sizeof (unsigned char));\n+  rtl.emit.regno_pointer_align\n+    = xmalloc (rtl.emit.regno_pointer_align_length\n+\t       * sizeof (unsigned char));\n \n   regno_reg_rtx\n-    = ggc_alloc (f->emit->regno_pointer_align_length * sizeof (rtx));\n+    = ggc_alloc (rtl.emit.regno_pointer_align_length * sizeof (rtx));\n \n   /* Put copies of all the hard registers into regno_reg_rtx.  */\n   memcpy (regno_reg_rtx,\n \t  static_regno_reg_rtx,\n \t  FIRST_PSEUDO_REGISTER * sizeof (rtx));\n \n   /* Put copies of all the virtual register rtx into regno_reg_rtx.  */\n-  init_virtual_regs (f->emit);\n+  init_virtual_regs ();\n \n   /* Indicate that the virtual registers and stack locations are\n      all pointers.  */"}, {"sha": "7ecbccf633cac8484952a9148d3efb882a730d66", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd60bab2ad76a635640db0101275111be8b04987/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd60bab2ad76a635640db0101275111be8b04987/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=bd60bab2ad76a635640db0101275111be8b04987", "patch": "@@ -344,7 +344,7 @@ init_expr_target (void)\n void\n init_expr (void)\n {\n-  cfun->expr = ggc_alloc_cleared (sizeof (struct expr_status));\n+  memset (&rtl.expr, 0, sizeof (rtl.expr));\n }\n \f\n /* Copy data from FROM to TO, where the machine modes are not the same."}, {"sha": "325a205d827f0796424b02926a7e6ce20231afa0", "filename": "gcc/function.c", "status": "modified", "additions": 30, "deletions": 69, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd60bab2ad76a635640db0101275111be8b04987/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd60bab2ad76a635640db0101275111be8b04987/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=bd60bab2ad76a635640db0101275111be8b04987", "patch": "@@ -193,8 +193,6 @@ struct temp_slot GTY(())\n \f\n /* Forward declarations.  */\n \n-static rtx assign_stack_local_1 (enum machine_mode, HOST_WIDE_INT, int,\n-\t\t\t\t struct function *);\n static struct temp_slot *find_temp_slot_from_address (rtx);\n static void pad_to_arg_alignment (struct args_size *, int, struct args_size *);\n static void pad_below (struct args_size *, enum machine_mode, tree);\n@@ -315,53 +313,29 @@ free_after_compilation (struct function *f)\n   VEC_free (int, heap, prologue);\n   VEC_free (int, heap, epilogue);\n   VEC_free (int, heap, sibcall_epilogue);\n+  free (rtl.emit.regno_pointer_align);\n \n+  memset (&rtl, 0, sizeof (rtl));\n   f->eh = NULL;\n-  f->expr = NULL;\n-  f->emit = NULL;\n-  f->varasm = NULL;\n   f->machine = NULL;\n   f->cfg = NULL;\n \n-  f->x_avail_temp_slots = NULL;\n-  f->x_used_temp_slots = NULL;\n   f->arg_offset_rtx = NULL;\n   f->return_rtx = NULL;\n   f->internal_arg_pointer = NULL;\n-  f->x_nonlocal_goto_handler_labels = NULL;\n-  f->x_return_label = NULL;\n-  f->x_naked_return_label = NULL;\n-  f->x_stack_slot_list = NULL;\n-  f->x_stack_check_probe_note = NULL;\n-  f->x_arg_pointer_save_area = NULL;\n-  f->x_parm_birth_insn = NULL;\n-  f->epilogue_delay_list = NULL;\n }\n \f\n-/* Allocate fixed slots in the stack frame of the current function.  */\n-\n-/* Return size needed for stack frame based on slots so far allocated in\n-   function F.\n-   This size counts from zero.  It is not rounded to PREFERRED_STACK_BOUNDARY;\n-   the caller may have to do that.  */\n-\n-static HOST_WIDE_INT\n-get_func_frame_size (struct function *f)\n-{\n-  if (FRAME_GROWS_DOWNWARD)\n-    return -f->x_frame_offset;\n-  else\n-    return f->x_frame_offset;\n-}\n-\n /* Return size needed for stack frame based on slots so far allocated.\n    This size counts from zero.  It is not rounded to PREFERRED_STACK_BOUNDARY;\n    the caller may have to do that.  */\n \n HOST_WIDE_INT\n get_frame_size (void)\n {\n-  return get_func_frame_size (cfun);\n+  if (FRAME_GROWS_DOWNWARD)\n+    return -frame_offset;\n+  else\n+    return frame_offset;\n }\n \n /* Issue an error message and return TRUE if frame OFFSET overflows in\n@@ -393,13 +367,10 @@ frame_offset_overflow (HOST_WIDE_INT offset, tree func)\n    -2 means use BITS_PER_UNIT,\n    positive specifies alignment boundary in bits.\n \n-   We do not round to stack_boundary here.\n+   We do not round to stack_boundary here.  */\n \n-   FUNCTION specifies the function to allocate in.  */\n-\n-static rtx\n-assign_stack_local_1 (enum machine_mode mode, HOST_WIDE_INT size, int align,\n-\t\t      struct function *function)\n+rtx\n+assign_stack_local (enum machine_mode mode, HOST_WIDE_INT size, int align)\n {\n   rtx x, addr;\n   int bigend_correction = 0;\n@@ -434,14 +405,14 @@ assign_stack_local_1 (enum machine_mode mode, HOST_WIDE_INT size, int align,\n     alignment = align / BITS_PER_UNIT;\n \n   if (FRAME_GROWS_DOWNWARD)\n-    function->x_frame_offset -= size;\n+    frame_offset -= size;\n \n   /* Ignore alignment we can't do with expected alignment of the boundary.  */\n   if (alignment * BITS_PER_UNIT > PREFERRED_STACK_BOUNDARY)\n     alignment = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;\n \n-  if (function->stack_alignment_needed < alignment * BITS_PER_UNIT)\n-    function->stack_alignment_needed = alignment * BITS_PER_UNIT;\n+  if (cfun->stack_alignment_needed < alignment * BITS_PER_UNIT)\n+    cfun->stack_alignment_needed = alignment * BITS_PER_UNIT;\n \n   /* Calculate how many bytes the start of local variables is off from\n      stack alignment.  */\n@@ -461,13 +432,13 @@ assign_stack_local_1 (enum machine_mode mode, HOST_WIDE_INT size, int align,\n \t  like.  So we instead assume that ALIGNMENT is a power of two and\n \t  use logical operations which are unambiguous.  */\n       if (FRAME_GROWS_DOWNWARD)\n-\tfunction->x_frame_offset\n-\t  = (FLOOR_ROUND (function->x_frame_offset - frame_phase,\n+\tframe_offset\n+\t  = (FLOOR_ROUND (frame_offset - frame_phase,\n \t\t\t  (unsigned HOST_WIDE_INT) alignment)\n \t     + frame_phase);\n       else\n-\tfunction->x_frame_offset\n-\t  = (CEIL_ROUND (function->x_frame_offset - frame_phase,\n+\tframe_offset\n+\t  = (CEIL_ROUND (frame_offset - frame_phase,\n \t\t\t (unsigned HOST_WIDE_INT) alignment)\n \t     + frame_phase);\n     }\n@@ -479,41 +450,31 @@ assign_stack_local_1 (enum machine_mode mode, HOST_WIDE_INT size, int align,\n \n   /* If we have already instantiated virtual registers, return the actual\n      address relative to the frame pointer.  */\n-  if (function == cfun && virtuals_instantiated)\n+  if (virtuals_instantiated)\n     addr = plus_constant (frame_pointer_rtx,\n \t\t\t  trunc_int_for_mode\n \t\t\t  (frame_offset + bigend_correction\n \t\t\t   + STARTING_FRAME_OFFSET, Pmode));\n   else\n     addr = plus_constant (virtual_stack_vars_rtx,\n \t\t\t  trunc_int_for_mode\n-\t\t\t  (function->x_frame_offset + bigend_correction,\n+\t\t\t  (frame_offset + bigend_correction,\n \t\t\t   Pmode));\n \n   if (!FRAME_GROWS_DOWNWARD)\n-    function->x_frame_offset += size;\n+    frame_offset += size;\n \n   x = gen_rtx_MEM (mode, addr);\n   MEM_NOTRAP_P (x) = 1;\n \n-  function->x_stack_slot_list\n-    = gen_rtx_EXPR_LIST (VOIDmode, x, function->x_stack_slot_list);\n+  stack_slot_list\n+    = gen_rtx_EXPR_LIST (VOIDmode, x, stack_slot_list);\n \n-  if (frame_offset_overflow (function->x_frame_offset, function->decl))\n-    function->x_frame_offset = 0;\n+  if (frame_offset_overflow (frame_offset, current_function_decl))\n+    frame_offset = 0;\n \n   return x;\n }\n-\n-/* Wrapper around assign_stack_local_1;  assign a local stack slot for the\n-   current function.  */\n-\n-rtx\n-assign_stack_local (enum machine_mode mode, HOST_WIDE_INT size, int align)\n-{\n-  return assign_stack_local_1 (mode, size, align, cfun);\n-}\n-\n \f\n /* Removes temporary slot TEMP from LIST.  */\n \n@@ -3975,7 +3936,7 @@ static void\n prepare_function_start (void)\n {\n   init_emit ();\n-  init_varasm_status (cfun);\n+  init_varasm_status ();\n   init_expr ();\n \n   cse_not_expected = ! optimize;\n@@ -4440,7 +4401,7 @@ expand_function_end (void)\n   /* If arg_pointer_save_area was referenced only from a nested\n      function, we will not have initialized it yet.  Do that now.  */\n   if (arg_pointer_save_area && ! cfun->arg_pointer_save_area_init)\n-    get_arg_pointer_save_area (cfun);\n+    get_arg_pointer_save_area ();\n \n   /* If we are doing stack checking and this function makes calls,\n      do a stack probe at the start of the function to ensure we have enough\n@@ -4673,17 +4634,17 @@ expand_function_end (void)\n }\n \n rtx\n-get_arg_pointer_save_area (struct function *f)\n+get_arg_pointer_save_area (void)\n {\n-  rtx ret = f->x_arg_pointer_save_area;\n+  rtx ret = arg_pointer_save_area;\n \n   if (! ret)\n     {\n-      ret = assign_stack_local_1 (Pmode, GET_MODE_SIZE (Pmode), 0, f);\n-      f->x_arg_pointer_save_area = ret;\n+      ret = assign_stack_local (Pmode, GET_MODE_SIZE (Pmode), 0);\n+      arg_pointer_save_area = ret;\n     }\n \n-  if (f == cfun && ! f->arg_pointer_save_area_init)\n+  if (! cfun->arg_pointer_save_area_init)\n     {\n       rtx seq;\n "}, {"sha": "6c95dcd1435e34812d6e99cfa02cb03fc6ee3c8c", "filename": "gcc/function.h", "status": "modified", "additions": 99, "deletions": 80, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd60bab2ad76a635640db0101275111be8b04987/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd60bab2ad76a635640db0101275111be8b04987/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=bd60bab2ad76a635640db0101275111be8b04987", "patch": "@@ -78,20 +78,22 @@ struct emit_status GTY(())\n   /* Indexed by pseudo register number, if nonzero gives the known alignment\n      for that pseudo (if REG_POINTER is set in x_regno_reg_rtx).\n      Allocated in parallel with x_regno_reg_rtx.  */\n-  unsigned char * GTY ((length (\"%h.x_reg_rtx_no\")))\n-    regno_pointer_align;\n-\n-  /* Indexed by pseudo register number, gives the rtx for that pseudo.\n-     Allocated in parallel with regno_pointer_align.  */\n-  rtx * GTY ((length (\"%h.x_reg_rtx_no\"))) x_regno_reg_rtx;\n+  unsigned char * GTY((skip)) regno_pointer_align;\n };\n \n+\n+/* Indexed by pseudo register number, gives the rtx for that pseudo.\n+   Allocated in parallel with regno_pointer_align.  \n+   FIXME: We could put it into emit_status struct, but gengtype is not able to deal\n+   with length attribute nested in top level structures.  */\n+\n+extern GTY ((length (\"rtl.emit.x_reg_rtx_no\"))) rtx * regno_reg_rtx;\n+\n /* For backward compatibility... eventually these should all go away.  */\n-#define reg_rtx_no (cfun->emit->x_reg_rtx_no)\n-#define regno_reg_rtx (cfun->emit->x_regno_reg_rtx)\n-#define seq_stack (cfun->emit->sequence_stack)\n+#define reg_rtx_no (rtl.emit.x_reg_rtx_no)\n+#define seq_stack (rtl.emit.sequence_stack)\n \n-#define REGNO_POINTER_ALIGN(REGNO) (cfun->emit->regno_pointer_align[REGNO])\n+#define REGNO_POINTER_ALIGN(REGNO) (rtl.emit.regno_pointer_align[REGNO])\n \n struct expr_status GTY(())\n {\n@@ -134,12 +136,12 @@ struct expr_status GTY(())\n   rtx x_forced_labels;\n };\n \n-#define pending_stack_adjust (cfun->expr->x_pending_stack_adjust)\n-#define inhibit_defer_pop (cfun->expr->x_inhibit_defer_pop)\n-#define saveregs_value (cfun->expr->x_saveregs_value)\n-#define apply_args_value (cfun->expr->x_apply_args_value)\n-#define forced_labels (cfun->expr->x_forced_labels)\n-#define stack_pointer_delta (cfun->expr->x_stack_pointer_delta)\n+#define pending_stack_adjust (rtl.expr.x_pending_stack_adjust)\n+#define inhibit_defer_pop (rtl.expr.x_inhibit_defer_pop)\n+#define saveregs_value (rtl.expr.x_saveregs_value)\n+#define apply_args_value (rtl.expr.x_apply_args_value)\n+#define forced_labels (rtl.expr.x_forced_labels)\n+#define stack_pointer_delta (rtl.expr.x_stack_pointer_delta)\n \n struct gimple_df;\n struct temp_slot;\n@@ -159,15 +161,91 @@ enum function_frequency {\n   FUNCTION_FREQUENCY_HOT\n };\n \n+struct varasm_status GTY(())\n+{\n+  /* If we're using a per-function constant pool, this is it.  */\n+  struct rtx_constant_pool *pool;\n+\n+  /* Number of tree-constants deferred during the expansion of this\n+     function.  */\n+  unsigned int deferred_constants;\n+};\n+\n+/* Datastructures maintained for currently processed function in RTL form.  */\n+struct rtl_data GTY(())\n+{\n+  struct expr_status expr;\n+  struct emit_status emit;\n+  struct varasm_status varasm;\n+\n+  /* List (chain of EXPR_LIST) of labels heading the current handlers for\n+     nonlocal gotos.  */\n+  rtx x_nonlocal_goto_handler_labels;\n+\n+  /* Label that will go on function epilogue.\n+     Jumping to this label serves as a \"return\" instruction\n+     on machines which require execution of the epilogue on all returns.  */\n+  rtx x_return_label;\n+\n+  /* Label that will go on the end of function epilogue.\n+     Jumping to this label serves as a \"naked return\" instruction\n+     on machines which require execution of the epilogue on all returns.  */\n+  rtx x_naked_return_label;\n+\n+  /* List (chain of EXPR_LISTs) of all stack slots in this function.\n+     Made for the sake of unshare_all_rtl.  */\n+  rtx x_stack_slot_list;\n+\n+  /* Place after which to insert the tail_recursion_label if we need one.  */\n+  rtx x_stack_check_probe_note;\n+\n+  /* Location at which to save the argument pointer if it will need to be\n+     referenced.  There are two cases where this is done: if nonlocal gotos\n+     exist, or if vars stored at an offset from the argument pointer will be\n+     needed by inner routines.  */\n+  rtx x_arg_pointer_save_area;\n+\n+  /* Offset to end of allocated area of stack frame.\n+     If stack grows down, this is the address of the last stack slot allocated.\n+     If stack grows up, this is the address for the next slot.  */\n+  HOST_WIDE_INT x_frame_offset;\n+\n+  /* Insn after which register parms and SAVE_EXPRs are born, if nonopt.  */\n+  rtx x_parm_birth_insn;\n+\n+  /* List of all used temporaries allocated, by level.  */\n+  VEC(temp_slot_p,gc) *x_used_temp_slots;\n+\n+  /* List of available temp slots.  */\n+  struct temp_slot *x_avail_temp_slots;\n+\n+  /* Current nesting level for temporaries.  */\n+  int x_temp_slot_level;\n+\n+  /* Highest label number in current function.  */\n+  int inl_max_label_num;\n+};\n+\n+#define return_label (rtl.x_return_label)\n+#define naked_return_label (rtl.x_naked_return_label)\n+#define stack_slot_list (rtl.x_stack_slot_list)\n+#define parm_birth_insn (rtl.x_parm_birth_insn)\n+#define frame_offset (rtl.x_frame_offset)\n+#define stack_check_probe_note (rtl.x_stack_check_probe_note)\n+#define arg_pointer_save_area (rtl.x_arg_pointer_save_area)\n+#define used_temp_slots (rtl.x_used_temp_slots)\n+#define avail_temp_slots (rtl.x_avail_temp_slots)\n+#define temp_slot_level (rtl.x_temp_slot_level)\n+#define nonlocal_goto_handler_labels (rtl.x_nonlocal_goto_handler_labels)\n+\n+extern GTY(()) struct rtl_data rtl;\n+\n /* This structure can save all the important global and static variables\n    describing the status of the current function.  */\n \n struct function GTY(())\n {\n   struct eh_status *eh;\n-  struct expr_status *expr;\n-  struct emit_status *emit;\n-  struct varasm_status *varasm;\n \n   /* The control flow graph for this function.  */\n   struct control_flow_graph *cfg;\n@@ -228,38 +306,6 @@ struct function GTY(())\n      has_hard_reg_initial_val (see integrate.[hc]).  */\n   struct initial_value_struct *hard_reg_initial_vals;\n \n-  /* List (chain of EXPR_LIST) of labels heading the current handlers for\n-     nonlocal gotos.  */\n-  rtx x_nonlocal_goto_handler_labels;\n-\n-  /* Label that will go on function epilogue.\n-     Jumping to this label serves as a \"return\" instruction\n-     on machines which require execution of the epilogue on all returns.  */\n-  rtx x_return_label;\n-\n-  /* Label that will go on the end of function epilogue.\n-     Jumping to this label serves as a \"naked return\" instruction\n-     on machines which require execution of the epilogue on all returns.  */\n-  rtx x_naked_return_label;\n-\n-  /* List (chain of EXPR_LISTs) of all stack slots in this function.\n-     Made for the sake of unshare_all_rtl.  */\n-  rtx x_stack_slot_list;\n-\n-  /* Place after which to insert the tail_recursion_label if we need one.  */\n-  rtx x_stack_check_probe_note;\n-\n-  /* Location at which to save the argument pointer if it will need to be\n-     referenced.  There are two cases where this is done: if nonlocal gotos\n-     exist, or if vars stored at an offset from the argument pointer will be\n-     needed by inner routines.  */\n-  rtx x_arg_pointer_save_area;\n-\n-  /* Offset to end of allocated area of stack frame.\n-     If stack grows down, this is the address of the last stack slot allocated.\n-     If stack grows up, this is the address for the next slot.  */\n-  HOST_WIDE_INT x_frame_offset;\n-\n   /* A PARM_DECL that should contain the static chain for this function.\n      It will be initialized at the beginning of the function.  */\n   tree static_chain_decl;\n@@ -269,21 +315,6 @@ struct function GTY(())\n      pointer.  */\n   tree nonlocal_goto_save_area;\n \n-  /* Insn after which register parms and SAVE_EXPRs are born, if nonopt.  */\n-  rtx x_parm_birth_insn;\n-\n-  /* List of all used temporaries allocated, by level.  */\n-  VEC(temp_slot_p,gc) *x_used_temp_slots;\n-\n-  /* List of available temp slots.  */\n-  struct temp_slot *x_avail_temp_slots;\n-\n-  /* Current nesting level for temporaries.  */\n-  int x_temp_slot_level;\n-\n-  /* Highest label number in current function.  */\n-  int inl_max_label_num;\n-\n   /* Function sequence number for profiling, debugging, etc.  */\n   int funcdef_no;\n \n@@ -521,18 +552,6 @@ extern void instantiate_decl_rtl (rtx x);\n #define current_function_has_nonlocal_goto (cfun->has_nonlocal_goto)\n #define current_function_has_asm_statement (cfun->has_asm_statement)\n \n-#define return_label (cfun->x_return_label)\n-#define naked_return_label (cfun->x_naked_return_label)\n-#define stack_slot_list (cfun->x_stack_slot_list)\n-#define parm_birth_insn (cfun->x_parm_birth_insn)\n-#define frame_offset (cfun->x_frame_offset)\n-#define stack_check_probe_note (cfun->x_stack_check_probe_note)\n-#define arg_pointer_save_area (cfun->x_arg_pointer_save_area)\n-#define used_temp_slots (cfun->x_used_temp_slots)\n-#define avail_temp_slots (cfun->x_avail_temp_slots)\n-#define temp_slot_level (cfun->x_temp_slot_level)\n-#define nonlocal_goto_handler_labels (cfun->x_nonlocal_goto_handler_labels)\n-#define rtl_df (cfun->df)\n #define current_loops (cfun->x_current_loops)\n #define dom_computed (cfun->cfg->x_dom_computed)\n #define n_bbs_in_dom_tree (cfun->cfg->x_n_bbs_in_dom_tree)\n@@ -570,14 +589,14 @@ extern struct machine_function * (*init_machine_status) (void);\n extern void free_after_parsing (struct function *);\n extern void free_after_compilation (struct function *);\n \n-extern void init_varasm_status (struct function *);\n+extern void init_varasm_status (void);\n \n #ifdef RTX_CODE\n extern void diddle_return_value (void (*)(rtx, void*), void*);\n extern void clobber_return_register (void);\n #endif\n \n-extern rtx get_arg_pointer_save_area (struct function *);\n+extern rtx get_arg_pointer_save_area (void);\n \n /* Returns the name of the current function.  */\n extern const char *current_function_name (void);"}, {"sha": "35ba37b1c26b2c5f2b8f626d045a50efe9144123", "filename": "gcc/stmt.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd60bab2ad76a635640db0101275111be8b04987/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd60bab2ad76a635640db0101275111be8b04987/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=bd60bab2ad76a635640db0101275111be8b04987", "patch": "@@ -160,8 +160,7 @@ force_label_rtx (tree label)\n   else\n     p = cfun;\n \n-  p->expr->x_forced_labels = gen_rtx_EXPR_LIST (VOIDmode, ref,\n-\t\t\t\t\t\tp->expr->x_forced_labels);\n+  forced_labels = gen_rtx_EXPR_LIST (VOIDmode, ref, forced_labels);\n   return ref;\n }\n \n@@ -1821,7 +1820,7 @@ expand_nl_goto_receiver (void)\n \t  /* Now restore our arg pointer from the address at which it\n \t     was saved in our stack frame.  */\n \t  emit_move_insn (virtual_incoming_args_rtx,\n-\t\t\t  copy_to_reg (get_arg_pointer_save_area (cfun)));\n+\t\t\t  copy_to_reg (get_arg_pointer_save_area ()));\n \t}\n     }\n #endif"}, {"sha": "f4607b49eea209f519da436ac7aba58256ae531f", "filename": "gcc/varasm.c", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd60bab2ad76a635640db0101275111be8b04987/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd60bab2ad76a635640db0101275111be8b04987/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=bd60bab2ad76a635640db0101275111be8b04987", "patch": "@@ -70,17 +70,7 @@ struct addr_const;\n struct constant_descriptor_rtx;\n struct rtx_constant_pool;\n \n-struct varasm_status GTY(())\n-{\n-  /* If we're using a per-function constant pool, this is it.  */\n-  struct rtx_constant_pool *pool;\n-\n-  /* Number of tree-constants deferred during the expansion of this\n-     function.  */\n-  unsigned int deferred_constants;\n-};\n-\n-#define n_deferred_constants (cfun->varasm->deferred_constants)\n+#define n_deferred_constants (rtl.varasm.deferred_constants)\n \n /* Number for making the label on the next\n    constant that is stored in memory.  */\n@@ -3464,15 +3454,10 @@ create_constant_pool (void)\n /* Initialize constant pool hashing for a new function.  */\n \n void\n-init_varasm_status (struct function *f)\n+init_varasm_status (void)\n {\n-  struct varasm_status *p;\n-\n-  p = ggc_alloc (sizeof (struct varasm_status));\n-  f->varasm = p;\n-\n-  p->pool = create_constant_pool ();\n-  p->deferred_constants = 0;\n+  rtl.varasm.pool = create_constant_pool ();\n+  rtl.varasm.deferred_constants = 0;\n }\n \f\n /* Given a MINUS expression, simplify it if both sides\n@@ -3509,7 +3494,7 @@ force_const_mem (enum machine_mode mode, rtx x)\n   /* Decide which pool to use.  */\n   pool = (targetm.use_blocks_for_constant_p (mode, x)\n \t  ? shared_constant_pool\n-\t  : cfun->varasm->pool);\n+\t  : rtl.varasm.pool);\n \n   /* Lookup the value in the hashtable.  */\n   tmp.constant = x;\n@@ -3621,7 +3606,7 @@ get_pool_mode (const_rtx addr)\n int\n get_pool_size (void)\n {\n-  return cfun->varasm->pool->offset;\n+  return rtl.varasm.pool->offset;\n }\n \f\n /* Worker function for output_constant_pool_1.  Emit assembly for X\n@@ -3863,7 +3848,7 @@ static void\n output_constant_pool (const char *fnname ATTRIBUTE_UNUSED,\n \t\t      tree fndecl ATTRIBUTE_UNUSED)\n {\n-  struct rtx_constant_pool *pool = cfun->varasm->pool;\n+  struct rtx_constant_pool *pool = rtl.varasm.pool;\n \n   /* It is possible for gcc to call force_const_mem and then to later\n      discard the instructions which refer to the constant.  In such a"}]}