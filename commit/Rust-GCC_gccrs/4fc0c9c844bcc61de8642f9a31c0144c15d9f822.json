{"sha": "4fc0c9c844bcc61de8642f9a31c0144c15d9f822", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZjMGM5Yzg0NGJjYzYxZGU4NjQyZjlhMzFjMDE0NGMxNWQ5ZjgyMg==", "commit": {"author": {"name": "Dominik Vogt", "email": "vogt@linux.vnet.ibm.com", "date": "2016-07-04T14:21:06Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2016-07-04T14:21:06Z"}, "message": "Minor cleanup to allocate_dynamic_stack_space\n\ngcc/ChangeLog:\n\n2016-07-04  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n\t    Jeff Law  <law@redhat.com>\n\n\t* explow.c (allocate_dynamic_stack_space): Simplify knowing that\n\tMUST_ALIGN was always true and extra_align ist always BITS_PER_UNIT.\n\n\nCo-Authored-By: Jeff Law <law@redhat.com>\n\nFrom-SVN: r237983", "tree": {"sha": "13db14e194b43a4ed58ffd604ef152425490230f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13db14e194b43a4ed58ffd604ef152425490230f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fc0c9c844bcc61de8642f9a31c0144c15d9f822", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fc0c9c844bcc61de8642f9a31c0144c15d9f822", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fc0c9c844bcc61de8642f9a31c0144c15d9f822", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fc0c9c844bcc61de8642f9a31c0144c15d9f822/comments", "author": {"login": "vogtd", "id": 9690100, "node_id": "MDQ6VXNlcjk2OTAxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/9690100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vogtd", "html_url": "https://github.com/vogtd", "followers_url": "https://api.github.com/users/vogtd/followers", "following_url": "https://api.github.com/users/vogtd/following{/other_user}", "gists_url": "https://api.github.com/users/vogtd/gists{/gist_id}", "starred_url": "https://api.github.com/users/vogtd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vogtd/subscriptions", "organizations_url": "https://api.github.com/users/vogtd/orgs", "repos_url": "https://api.github.com/users/vogtd/repos", "events_url": "https://api.github.com/users/vogtd/events{/privacy}", "received_events_url": "https://api.github.com/users/vogtd/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "430bb38e4b1cdc41d52d85324dac4bba9deeb23e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/430bb38e4b1cdc41d52d85324dac4bba9deeb23e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/430bb38e4b1cdc41d52d85324dac4bba9deeb23e"}], "stats": {"total": 102, "additions": 36, "deletions": 66}, "files": [{"sha": "2351e896992d9ca5abd903ebc23c6a4e4f2e3c1b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fc0c9c844bcc61de8642f9a31c0144c15d9f822/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fc0c9c844bcc61de8642f9a31c0144c15d9f822/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4fc0c9c844bcc61de8642f9a31c0144c15d9f822", "patch": "@@ -1,3 +1,9 @@\n+2016-07-04  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n+\t    Jeff Law  <law@redhat.com>\n+\n+\t* explow.c (allocate_dynamic_stack_space): Simplify knowing that\n+\tMUST_ALIGN was always true and extra_align ist always BITS_PER_UNIT.\n+\n 2016-07-04  Yuri Rumyantsev  <ysrumyan@gmail.com>\n \n \t* config/i386/i386.c (ix86_expand_vec_perm): Add handle one-operand"}, {"sha": "09a033081dca7f6b356a5ec1829b0b939db1696b", "filename": "gcc/explow.c", "status": "modified", "additions": 30, "deletions": 66, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fc0c9c844bcc61de8642f9a31c0144c15d9f822/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fc0c9c844bcc61de8642f9a31c0144c15d9f822/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=4fc0c9c844bcc61de8642f9a31c0144c15d9f822", "patch": "@@ -1174,8 +1174,7 @@ allocate_dynamic_stack_space (rtx size, unsigned size_align,\n   HOST_WIDE_INT stack_usage_size = -1;\n   rtx_code_label *final_label;\n   rtx final_target, target;\n-  unsigned extra_align = 0;\n-  bool must_align;\n+  unsigned extra;\n \n   /* If we're asking for zero bytes, it doesn't matter what we point\n      to since we can't dereference it.  But return a reasonable\n@@ -1246,48 +1245,21 @@ allocate_dynamic_stack_space (rtx size, unsigned size_align,\n     crtl->preferred_stack_boundary = PREFERRED_STACK_BOUNDARY;\n \n   /* We will need to ensure that the address we return is aligned to\n-     REQUIRED_ALIGN.  If STACK_DYNAMIC_OFFSET is defined, we don't\n-     always know its final value at this point in the compilation (it\n-     might depend on the size of the outgoing parameter lists, for\n-     example), so we must align the value to be returned in that case.\n-     (Note that STACK_DYNAMIC_OFFSET will have a default nonzero value if\n-     STACK_POINTER_OFFSET or ACCUMULATE_OUTGOING_ARGS are defined).\n-     We must also do an alignment operation on the returned value if\n-     the stack pointer alignment is less strict than REQUIRED_ALIGN.\n-\n-     If we have to align, we must leave space in SIZE for the hole\n-     that might result from the alignment operation.  */\n-\n-  must_align = (crtl->preferred_stack_boundary < required_align);\n-  if (must_align)\n-    {\n-      if (required_align > PREFERRED_STACK_BOUNDARY)\n-\textra_align = PREFERRED_STACK_BOUNDARY;\n-      else if (required_align > STACK_BOUNDARY)\n-\textra_align = STACK_BOUNDARY;\n-      else\n-\textra_align = BITS_PER_UNIT;\n-    }\n+     REQUIRED_ALIGN.  At this point in the compilation, we don't always\n+     know the final value of the STACK_DYNAMIC_OFFSET used in function.c\n+     (it might depend on the size of the outgoing parameter lists, for\n+     example), so we must preventively align the value.  We leave space\n+     in SIZE for the hole that might result from the alignment operation.  */\n \n-  /* ??? STACK_POINTER_OFFSET is always defined now.  */\n-#if defined (STACK_DYNAMIC_OFFSET) || defined (STACK_POINTER_OFFSET)\n-  must_align = true;\n-  extra_align = BITS_PER_UNIT;\n-#endif\n-\n-  if (must_align)\n-    {\n-      unsigned extra = (required_align - extra_align) / BITS_PER_UNIT;\n+  extra = (required_align - BITS_PER_UNIT) / BITS_PER_UNIT;\n+  size = plus_constant (Pmode, size, extra);\n+  size = force_operand (size, NULL_RTX);\n \n-      size = plus_constant (Pmode, size, extra);\n-      size = force_operand (size, NULL_RTX);\n-\n-      if (flag_stack_usage_info)\n-\tstack_usage_size += extra;\n+  if (flag_stack_usage_info)\n+    stack_usage_size += extra;\n \n-      if (extra && size_align > extra_align)\n-\tsize_align = extra_align;\n-    }\n+  if (extra && size_align > BITS_PER_UNIT)\n+    size_align = BITS_PER_UNIT;\n \n   /* Round the size to a multiple of the required stack alignment.\n      Since the stack if presumed to be rounded before this allocation,\n@@ -1361,13 +1333,10 @@ allocate_dynamic_stack_space (rtx size, unsigned size_align,\n       if (MALLOC_ABI_ALIGNMENT >= required_align)\n \task = size;\n       else\n-\t{\n-\t  ask = expand_binop (Pmode, add_optab, size,\n-\t\t\t      gen_int_mode (required_align / BITS_PER_UNIT - 1,\n-\t\t\t\t\t    Pmode),\n-\t\t\t      NULL_RTX, 1, OPTAB_LIB_WIDEN);\n-\t  must_align = true;\n-\t}\n+\task = expand_binop (Pmode, add_optab, size,\n+\t\t\t    gen_int_mode (required_align / BITS_PER_UNIT - 1,\n+\t\t\t\t\t  Pmode),\n+\t\t\t    NULL_RTX, 1, OPTAB_LIB_WIDEN);\n \n       func = init_one_libfunc (\"__morestack_allocate_stack_space\");\n \n@@ -1478,24 +1447,19 @@ allocate_dynamic_stack_space (rtx size, unsigned size_align,\n       target = final_target;\n     }\n \n-  if (must_align)\n-    {\n-      /* CEIL_DIV_EXPR needs to worry about the addition overflowing,\n-\t but we know it can't.  So add ourselves and then do\n-\t TRUNC_DIV_EXPR.  */\n-      target = expand_binop (Pmode, add_optab, target,\n-\t\t\t     gen_int_mode (required_align / BITS_PER_UNIT - 1,\n-\t\t\t\t\t   Pmode),\n-\t\t\t     NULL_RTX, 1, OPTAB_LIB_WIDEN);\n-      target = expand_divmod (0, TRUNC_DIV_EXPR, Pmode, target,\n-\t\t\t      gen_int_mode (required_align / BITS_PER_UNIT,\n-\t\t\t\t\t    Pmode),\n-\t\t\t      NULL_RTX, 1);\n-      target = expand_mult (Pmode, target,\n-\t\t\t    gen_int_mode (required_align / BITS_PER_UNIT,\n-\t\t\t\t\t  Pmode),\n-\t\t\t    NULL_RTX, 1);\n-    }\n+  /* CEIL_DIV_EXPR needs to worry about the addition overflowing,\n+     but we know it can't.  So add ourselves and then do\n+     TRUNC_DIV_EXPR.  */\n+  target = expand_binop (Pmode, add_optab, target,\n+\t\t\t gen_int_mode (required_align / BITS_PER_UNIT - 1,\n+\t\t\t\t       Pmode),\n+\t\t\t NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+  target = expand_divmod (0, TRUNC_DIV_EXPR, Pmode, target,\n+\t\t\t  gen_int_mode (required_align / BITS_PER_UNIT, Pmode),\n+\t\t\t  NULL_RTX, 1);\n+  target = expand_mult (Pmode, target,\n+\t\t\tgen_int_mode (required_align / BITS_PER_UNIT, Pmode),\n+\t\t\tNULL_RTX, 1);\n \n   /* Now that we've committed to a return value, mark its alignment.  */\n   mark_reg_pointer (target, required_align);"}]}