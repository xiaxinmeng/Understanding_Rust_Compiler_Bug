{"sha": "052cec9b0e00300eb75e6712cb82ad1e9d4ba3b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDUyY2VjOWIwZTAwMzAwZWI3NWU2NzEyY2I4MmFkMWU5ZDRiYTNiNA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2008-01-14T19:32:10Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2008-01-14T19:32:10Z"}, "message": "decl.c (gnat_to_gnu_entity): Process renamings before converting the expression to the type of the object.\n\n\t* decl.c (gnat_to_gnu_entity) <object>: Process renamings\n\tbefore converting the expression to the type of the object.\n\t* trans.c (maybe_stabilize_reference) <CONSTRUCTOR>: New case.\n\tStabilize constructors for special wrapping types.\n\nFrom-SVN: r131531", "tree": {"sha": "8cc6a97b41802b07368b171b5eddc2d051a9c406", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8cc6a97b41802b07368b171b5eddc2d051a9c406"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/052cec9b0e00300eb75e6712cb82ad1e9d4ba3b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/052cec9b0e00300eb75e6712cb82ad1e9d4ba3b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/052cec9b0e00300eb75e6712cb82ad1e9d4ba3b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/052cec9b0e00300eb75e6712cb82ad1e9d4ba3b4/comments", "author": null, "committer": null, "parents": [{"sha": "8103eebfb73229a018f22718665864730e43c58f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8103eebfb73229a018f22718665864730e43c58f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8103eebfb73229a018f22718665864730e43c58f"}], "stats": {"total": 235, "additions": 218, "deletions": 17}, "files": [{"sha": "1dd2fc5625ecf98ecc37cb273b84d8116a3a5d95", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/052cec9b0e00300eb75e6712cb82ad1e9d4ba3b4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/052cec9b0e00300eb75e6712cb82ad1e9d4ba3b4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=052cec9b0e00300eb75e6712cb82ad1e9d4ba3b4", "patch": "@@ -1,3 +1,10 @@\n+2008-01-14  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* decl.c (gnat_to_gnu_entity) <object>: Process renamings\n+\tbefore converting the expression to the type of the object.\n+\t* trans.c (maybe_stabilize_reference) <CONSTRUCTOR>: New case.\n+\tStabilize constructors for special wrapping types.\n+\n 2008-01-13  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* trans.c (call_to_gnu):Invoke the addressable_p predicate only"}, {"sha": "2ddfe5a89c0ec05725e7c312433be4ace869ae5a", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/052cec9b0e00300eb75e6712cb82ad1e9d4ba3b4/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/052cec9b0e00300eb75e6712cb82ad1e9d4ba3b4/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=052cec9b0e00300eb75e6712cb82ad1e9d4ba3b4", "patch": "@@ -740,23 +740,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t\t   (TYPE_QUALS (gnu_type)\n \t\t\t\t\t    | TYPE_QUAL_VOLATILE));\n \n-\t/* Convert the expression to the type of the object except in the\n-\t   case where the object's type is unconstrained or the object's type\n-\t   is a padded record whose field is of self-referential size.  In\n-\t   the former case, converting will generate unnecessary evaluations\n-\t   of the CONSTRUCTOR to compute the size and in the latter case, we\n-\t   want to only copy the actual data.  */\n-\tif (gnu_expr\n-\t    && TREE_CODE (gnu_type) != UNCONSTRAINED_ARRAY_TYPE\n-\t    && !CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_type))\n-\t    && !(TREE_CODE (gnu_type) == RECORD_TYPE\n-\t\t && TYPE_IS_PADDING_P (gnu_type)\n-\t\t && (CONTAINS_PLACEHOLDER_P\n-\t\t     (TYPE_SIZE (TREE_TYPE (TYPE_FIELDS (gnu_type)))))))\n-\t  gnu_expr = convert (gnu_type, gnu_expr);\n-\n \t/* If this is a renaming, avoid as much as possible to create a new\n-\t   object.  However, in several cases, creating it is required.  */\n+\t   object.  However, in several cases, creating it is required.\n+\t   This processing needs to be applied to the raw expression so\n+\t   as to make it more likely to rename the underlying object.  */\n \tif (Present (Renamed_Object (gnat_entity)))\n \t  {\n \t    bool create_normal_object = false;\n@@ -905,7 +892,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   the object.  If there is an initializer, it will have already\n \t   been converted to the right type, but we need to create the\n \t   template if there is no initializer.  */\n-\telse if (definition && TREE_CODE (gnu_type) == RECORD_TYPE\n+\telse if (definition\n+\t\t && TREE_CODE (gnu_type) == RECORD_TYPE\n \t\t && (TYPE_CONTAINS_TEMPLATE_P (gnu_type)\n \t\t     /* Beware that padding might have been introduced\n \t\t\tvia maybe_pad_type above.  */\n@@ -932,6 +920,21 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\tNULL_TREE));\n \t  }\n \n+\t/* Convert the expression to the type of the object except in the\n+\t   case where the object's type is unconstrained or the object's type\n+\t   is a padded record whose field is of self-referential size.  In\n+\t   the former case, converting will generate unnecessary evaluations\n+\t   of the CONSTRUCTOR to compute the size and in the latter case, we\n+\t   want to only copy the actual data.  */\n+\tif (gnu_expr\n+\t    && TREE_CODE (gnu_type) != UNCONSTRAINED_ARRAY_TYPE\n+\t    && !CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_type))\n+\t    && !(TREE_CODE (gnu_type) == RECORD_TYPE\n+\t\t && TYPE_IS_PADDING_P (gnu_type)\n+\t\t && (CONTAINS_PLACEHOLDER_P\n+\t\t     (TYPE_SIZE (TREE_TYPE (TYPE_FIELDS (gnu_type)))))))\n+\t  gnu_expr = convert (gnu_type, gnu_expr);\n+\n \t/* If this is a pointer and it does not have an initializing\n \t   expression, initialize it to NULL, unless the object is\n \t   imported.  */"}, {"sha": "5b04972b2d235c50cc28b77318643685cb179170", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/052cec9b0e00300eb75e6712cb82ad1e9d4ba3b4/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/052cec9b0e00300eb75e6712cb82ad1e9d4ba3b4/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=052cec9b0e00300eb75e6712cb82ad1e9d4ba3b4", "patch": "@@ -6503,6 +6503,28 @@ maybe_stabilize_reference (tree ref, bool force, bool *success)\n       result = gnat_stabilize_reference_1 (ref, force);\n       break;\n \n+    case CONSTRUCTOR:\n+      /* Constructors with 1 element are used extensively to formally\n+\t convert objects to special wrapping types.  */\n+      if (TREE_CODE (type) == RECORD_TYPE\n+\t  && VEC_length (constructor_elt, CONSTRUCTOR_ELTS (ref)) == 1)\n+\t{\n+\t  tree index\n+\t    = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (ref), 0)->index;\n+\t  tree value\n+\t    = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (ref), 0)->value;\n+\t  result\n+\t    = build_constructor_single (type, index,\n+\t\t\t\t\tgnat_stabilize_reference_1 (value,\n+\t\t\t\t\t\t\t\t    force));\n+\t}\n+      else\n+\t{\n+\t  *success = false;\n+\t  return ref;\n+\t}\n+      break;\n+\n     case ERROR_MARK:\n       ref = error_mark_node;\n "}, {"sha": "ac27643aeea6c68f47dc080e0eb939c59b1a3143", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/052cec9b0e00300eb75e6712cb82ad1e9d4ba3b4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/052cec9b0e00300eb75e6712cb82ad1e9d4ba3b4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=052cec9b0e00300eb75e6712cb82ad1e9d4ba3b4", "patch": "@@ -1,3 +1,8 @@\n+2008-01-14  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/rep_clause2.ad[sb]: New test.\n+\t* gnat.dg/rep_problem2.adb: Rename to rep_clause1.adb.\n+\n 2008-01-14  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \tPR c++/24924"}, {"sha": "b7f5c7dd41008c4666e61e23188a582a5a376718", "filename": "gcc/testsuite/gnat.dg/rep_clause1.adb", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/052cec9b0e00300eb75e6712cb82ad1e9d4ba3b4/gcc%2Ftestsuite%2Fgnat.dg%2Frep_clause1.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/052cec9b0e00300eb75e6712cb82ad1e9d4ba3b4/gcc%2Ftestsuite%2Fgnat.dg%2Frep_clause1.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Frep_clause1.adb?ref=052cec9b0e00300eb75e6712cb82ad1e9d4ba3b4", "patch": "@@ -0,0 +1,101 @@\n+--  { dg-do compile }\n+\n+with Ada.Text_IO; use Ada.Text_IO;\n+\n+procedure Rep_Clause1 is\n+   \n+   type Int_16 is range 0 .. 65535;\n+   for Int_16'Size use 16;\n+   \n+   ----------------------------------------------\n+      \n+   type Rec_A is\n+      record\n+         Int_1 : Int_16;\n+         Int_2 : Int_16;\n+         Int_3 : Int_16;\n+         Int_4 : Int_16;\n+      end record;\n+      \n+      \n+   for Rec_A use record\n+      Int_1 at 0 range  0 .. 15;\n+      Int_2 at 2 range  0 .. 15;\n+      Int_3 at 4 range  0 .. 15;\n+      Int_4 at 6 range  0 .. 15;\n+   end record;\n+   \n+   Rec_A_Size : constant := 4 * 16;\n+   \n+   for Rec_A'Size use Rec_A_Size;\n+   \n+   ----------------------------------------------\n+   \n+   type Rec_B_Version_1 is\n+      record\n+         Rec_1 : Rec_A;\n+         Rec_2 : Rec_A;\n+         Int_1 : Int_16;\n+      end record;\n+  \n+   for Rec_B_Version_1 use record\n+      Rec_1 at  0 range  0 .. 63;\n+      Rec_2 at  8 range  0 .. 63;\n+      Int_1 at 16 range  0 .. 15;\n+   end record;\n+  \n+   Rec_B_Size : constant := 2 * Rec_A_Size + 16;\n+   \n+   for Rec_B_Version_1'Size use Rec_B_Size;\n+   for Rec_B_Version_1'Alignment use 2;\n+\n+   ----------------------------------------------\n+\n+   type Rec_B_Version_2 is\n+      record\n+         Int_1 : Int_16;\n+         Rec_1 : Rec_A;\n+         Rec_2 : Rec_A;\n+      end record;\n+   \n+   for Rec_B_Version_2 use record\n+      Int_1 at  0 range  0 .. 15;\n+      Rec_1 at  2 range  0 .. 63;\n+      Rec_2 at 10 range  0 .. 63;\n+   end record;\n+\n+   for Rec_B_Version_2'Size use Rec_B_Size;\n+   \n+   ----------------------------------------------\n+   \n+   Arr_A_Length : constant := 2;\n+   Arr_A_Size   : constant := Arr_A_Length * Rec_B_Size;\n+   \n+   type Arr_A_Version_1 is array (1 .. Arr_A_Length) of Rec_B_Version_1;\n+   type Arr_A_Version_2 is array (1 .. Arr_A_Length) of Rec_B_Version_2;\n+   \n+   pragma Pack (Arr_A_Version_1);\n+   pragma Pack (Arr_A_Version_2);\n+   \n+   for Arr_A_Version_1'Size use Arr_A_Size;\n+   for Arr_A_Version_2'Size use Arr_A_Size;\n+   \n+   ----------------------------------------------\n+\n+begin\n+   --  Put_Line (\"Arr_A_Size =\" & Arr_A_Size'Img);\n+   \n+   if Arr_A_Version_1'Size /= Arr_A_Size then\n+      Ada.Text_IO.Put_Line\n+        (\"Version 1 Size mismatch! \" &\n+         \"Arr_A_Version_1'Size =\" & Arr_A_Version_1'Size'Img);\n+   end if;\n+   \n+   if Arr_A_Version_2'Size /= Arr_A_Size then\n+      Ada.Text_IO.Put_Line\n+        (\"Version 2 Size mismatch! \" &\n+         \"Arr_A_Version_2'Size =\" & Arr_A_Version_2'Size'Img);\n+   \n+   end if;\n+\n+end;"}, {"sha": "b6cd49f9f98ec667ac97a81405bf5c88fe6e28d4", "filename": "gcc/testsuite/gnat.dg/rep_clause2.adb", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/052cec9b0e00300eb75e6712cb82ad1e9d4ba3b4/gcc%2Ftestsuite%2Fgnat.dg%2Frep_clause2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/052cec9b0e00300eb75e6712cb82ad1e9d4ba3b4/gcc%2Ftestsuite%2Fgnat.dg%2Frep_clause2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Frep_clause2.adb?ref=052cec9b0e00300eb75e6712cb82ad1e9d4ba3b4", "patch": "@@ -0,0 +1,10 @@\n+-- { dg-do compile }\r\n+\r\n+package body Rep_Clause2 is\r\n+\r\n+   procedure Assign (From : Data; Offset : Positive; I : Index; To : out Bit_Array) is\r\n+   begin\r\n+     To (Offset .. Offset + 7) := Bit_Array (Conv (From.D(I).S.N));\r\n+   end;\r\n+\r\n+end Rep_Clause2;\r"}, {"sha": "cc8b33e8b4c8647f8ed038f0dbbbd318caa7c399", "filename": "gcc/testsuite/gnat.dg/rep_clause2.ads", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/052cec9b0e00300eb75e6712cb82ad1e9d4ba3b4/gcc%2Ftestsuite%2Fgnat.dg%2Frep_clause2.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/052cec9b0e00300eb75e6712cb82ad1e9d4ba3b4/gcc%2Ftestsuite%2Fgnat.dg%2Frep_clause2.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Frep_clause2.ads?ref=052cec9b0e00300eb75e6712cb82ad1e9d4ba3b4", "patch": "@@ -0,0 +1,53 @@\n+with Unchecked_Conversion;\r\n+\r\n+package Rep_Clause2 is\r\n+\r\n+   type Tiny is range 0 .. 3;\r\n+   for Tiny'Size use 2;\r\n+\r\n+   type Small is range 0 .. 255;\r\n+   for Small'Size use 8;\r\n+\r\n+   type Small_Data is record\r\n+      D : Tiny;\r\n+      N : Small;\r\n+   end record;\r\n+   pragma Pack (Small_Data);\r\n+\r\n+   type Chunk is\r\n+   record\r\n+      S : Small_Data;\r\n+      C : Character;\r\n+   end record;\r\n+\r\n+   for Chunk use record\r\n+      S at 0 range  0 .. 15;\r\n+      C at 2 range  0 .. 7;\r\n+   end record;\r\n+\r\n+   type Index is range 1 .. 10;\r\n+\r\n+   type Data_Array is array (Index) of Chunk;\r\n+   for Data_Array'Alignment use 2;\r\n+   pragma Pack (Data_Array);\r\n+\r\n+   type Data is record\r\n+     D : Data_Array;\r\n+   end record;\r\n+\r\n+   type Bit is range 0 .. 1;\r\n+   for Bit'Size use 1;\r\n+\r\n+   type Bit_Array is array (Positive range <>) of Bit;\r\n+   pragma Pack (Bit_Array);\r\n+\r\n+   type Byte is new Bit_Array (1 .. 8);\r\n+   for  Byte'Size use 8;\r\n+   for  Byte'Alignment use 1;\r\n+\r\n+   function Conv\r\n+     is new Unchecked_Conversion(Source => Small, Target => Byte);\r\n+\r\n+   procedure Assign (From : Data; Offset : Positive; I : Index; To : out Bit_Array);\r\n+\r\n+end Rep_Clause2;\r"}]}