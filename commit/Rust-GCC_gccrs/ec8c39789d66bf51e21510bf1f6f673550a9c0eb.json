{"sha": "ec8c39789d66bf51e21510bf1f6f673550a9c0eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM4YzM5Nzg5ZDY2YmY1MWUyMTUxMGJmMWY2ZjY3MzU1MGE5YzBlYg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-02-16T08:02:37Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-02-16T08:02:37Z"}, "message": "params.def (PARAM_MAX_VARTRACK_SIZE): New.\n\n\t* params.def (PARAM_MAX_VARTRACK_SIZE): New.\n\t* doc/invoke.texi: Document it.\n\t* var-tracking.c: Include toplev.h and params.h.\n\t(vt_find_locations): Return bool indicating success.  Compute\n\thash sizes unconditionally.  Check new parameter, report.\n\t(variable_tracking_main_1): Check vt_find_locations results and\n\tretry.  Renamed from...\n\t(variable_tracking_main): ... this.  New wrapper to preserve\n\tflag_var_tracking_assignments.\n\t* Makefile.in (var-tracking.o): Adjust dependencies.\n\n\t* lib/prune.exp: Prune variable tracking size limit exceeded\n\tnotes.\n\nFrom-SVN: r156794", "tree": {"sha": "65d3fa222f5d5a514634543c55a936847719d170", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65d3fa222f5d5a514634543c55a936847719d170"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec8c39789d66bf51e21510bf1f6f673550a9c0eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec8c39789d66bf51e21510bf1f6f673550a9c0eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec8c39789d66bf51e21510bf1f6f673550a9c0eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec8c39789d66bf51e21510bf1f6f673550a9c0eb/comments", "author": null, "committer": null, "parents": [{"sha": "1e2ddf80b6806a33e0043437466f9549e5f5bac2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e2ddf80b6806a33e0043437466f9549e5f5bac2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e2ddf80b6806a33e0043437466f9549e5f5bac2"}], "stats": {"total": 122, "additions": 108, "deletions": 14}, "files": [{"sha": "5fad55c2da615ab855dabe27150891a7bf96300c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8c39789d66bf51e21510bf1f6f673550a9c0eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8c39789d66bf51e21510bf1f6f673550a9c0eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ec8c39789d66bf51e21510bf1f6f673550a9c0eb", "patch": "@@ -1,3 +1,16 @@\n+2010-02-16  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* params.def (PARAM_MAX_VARTRACK_SIZE): New.\n+\t* doc/invoke.texi: Document it.\n+\t* var-tracking.c: Include toplev.h and params.h.\n+\t(vt_find_locations): Return bool indicating success.  Compute\n+\thash sizes unconditionally.  Check new parameter, report.\n+\t(variable_tracking_main_1): Check vt_find_locations results and\n+\tretry.  Renamed from...\n+\t(variable_tracking_main): ... this.  New wrapper to preserve\n+\tflag_var_tracking_assignments.\n+\t* Makefile.in (var-tracking.o): Adjust dependencies.\n+\n 2010-02-16  Jack Howarth <howarth@bromo.med.uc.edu>\n             Jakub Jelinek <jakub@redhat.com>\n "}, {"sha": "6c656eaa6e7a5f591dcd762c1ad5c2c81caa6f4c", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8c39789d66bf51e21510bf1f6f673550a9c0eb/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8c39789d66bf51e21510bf1f6f673550a9c0eb/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ec8c39789d66bf51e21510bf1f6f673550a9c0eb", "patch": "@@ -3025,7 +3025,7 @@ var-tracking.o : var-tracking.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TREE_H) hard-reg-set.h insn-config.h reload.h $(FLAGS_H) \\\n    $(BASIC_BLOCK_H) output.h sbitmap.h alloc-pool.h $(FIBHEAP_H) $(HASHTAB_H) \\\n    $(REGS_H) $(EXPR_H) $(TIMEVAR_H) $(TREE_PASS_H) $(TREE_FLOW_H) \\\n-   cselib.h $(TARGET_H)\n+   cselib.h $(TARGET_H) $(TOPLEV_H) $(PARAMS_H)\n profile.o : profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) output.h $(REGS_H) $(EXPR_H) $(FUNCTION_H) \\\n    $(TOPLEV_H) $(COVERAGE_H) $(TREE_FLOW_H) value-prof.h cfghooks.h \\"}, {"sha": "a81cc9932336a2e2fc643cb18cae928ce24bf661", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8c39789d66bf51e21510bf1f6f673550a9c0eb/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8c39789d66bf51e21510bf1f6f673550a9c0eb/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=ec8c39789d66bf51e21510bf1f6f673550a9c0eb", "patch": "@@ -8428,6 +8428,15 @@ with more basic blocks than this parameter won't have loop invariant\n motion optimization performed on them.  The default value of the\n parameter is 1000 for -O1 and 10000 for -O2 and above.\n \n+@item max-vartrack-size\n+Sets a maximum number of hash table slots to use during variable\n+tracking dataflow analysis of any function.  If this limit is exceeded\n+with variable tracking at assignments enabled, analysis for that\n+function is retried without it, after removing all debug insns from\n+the function.  If the limit is exceeded even without debug insns, var\n+tracking analysis is completely disabled for the function.  Setting\n+the parameter to zero makes it unlimited.\n+\n @item min-nondebug-insn-uid\n Use uids starting at this parameter for nondebug insns.  The range below\n the parameter is reserved exclusively for debug insns created by"}, {"sha": "21dcb44a90e49a58def476a5fe80b764b80bde04", "filename": "gcc/params.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8c39789d66bf51e21510bf1f6f673550a9c0eb/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8c39789d66bf51e21510bf1f6f673550a9c0eb/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=ec8c39789d66bf51e21510bf1f6f673550a9c0eb", "patch": "@@ -764,6 +764,13 @@ DEFPARAM (PARAM_PREFETCH_MIN_INSN_TO_MEM_RATIO,\n \t  \"Min. ratio of insns to mem ops to enable prefetching in a loop\",\n \t  3, 0, 0)\n \n+/* Set maximum hash table size for var tracking.  */\n+\n+DEFPARAM (PARAM_MAX_VARTRACK_SIZE,\n+\t  \"max-vartrack-size\",\n+\t  \"Max. size of var tracking hash tables\",\n+\t  50000000, 0, 0)\n+\n /* Set minimum insn uid for non-debug insns.  */\n \n DEFPARAM (PARAM_MIN_NONDEBUG_INSN_UID,"}, {"sha": "1c512343bd50eb72a1a6e79b284d1a83229423c8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8c39789d66bf51e21510bf1f6f673550a9c0eb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8c39789d66bf51e21510bf1f6f673550a9c0eb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ec8c39789d66bf51e21510bf1f6f673550a9c0eb", "patch": "@@ -1,3 +1,8 @@\n+2010-02-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* lib/prune.exp: Prune variable tracking size limit exceeded\n+\tnotes.\n+\n 2010-02-16  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/43031"}, {"sha": "ef647d533edd7097594d0b640dd1e5b96f9e3a73", "filename": "gcc/testsuite/lib/prune.exp", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8c39789d66bf51e21510bf1f6f673550a9c0eb/gcc%2Ftestsuite%2Flib%2Fprune.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8c39789d66bf51e21510bf1f6f673550a9c0eb/gcc%2Ftestsuite%2Flib%2Fprune.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fprune.exp?ref=ec8c39789d66bf51e21510bf1f6f673550a9c0eb", "patch": "@@ -37,6 +37,9 @@ proc prune_gcc_output { text } {\n     regsub -all \"(^|\\n)\\[^\\n\\]*: Additional NOP may be necessary to workaround Itanium processor A/B step errata\" $text \"\" text\n     regsub -all \"(^|\\n)\\[^\\n*\\]*: Assembler messages:\\[^\\n\\]*\" $text \"\" text\n \n+    # Ignore harmless VTA note.\n+    regsub -all \"(^|\\n)\\[^\\n\\]*: note: variable tracking size limit exceeded with -fvar-tracking-assignments, retrying without\\[^\\n\\]*\" $text \"\" text\n+\n     # It would be nice to avoid passing anything to gcc that would cause it to\n     # issue these messages (since ignoring them seems like a hack on our part),\n     # but that's too difficult in the general case.  For example, sometimes"}, {"sha": "049dca49fc9426150ea94ecee79224eb558f4fbf", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 70, "deletions": 13, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8c39789d66bf51e21510bf1f6f673550a9c0eb/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8c39789d66bf51e21510bf1f6f673550a9c0eb/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=ec8c39789d66bf51e21510bf1f6f673550a9c0eb", "patch": "@@ -109,6 +109,8 @@\n #include \"tree-flow.h\"\n #include \"cselib.h\"\n #include \"target.h\"\n+#include \"toplev.h\"\n+#include \"params.h\"\n \n /* var-tracking.c assumes that tree code with the same value as VALUE rtx code\n    has no chance to appear in REG_EXPR/MEM_EXPRs and isn't a decl.\n@@ -448,7 +450,7 @@ static int add_uses (rtx *, void *);\n static void add_uses_1 (rtx *, void *);\n static void add_stores (rtx, const_rtx, void *);\n static bool compute_bb_dataflow (basic_block);\n-static void vt_find_locations (void);\n+static bool vt_find_locations (void);\n \n static void dump_attrs_list (attrs);\n static int dump_var_slot (void **, void *);\n@@ -5510,7 +5512,7 @@ compute_bb_dataflow (basic_block bb)\n \n /* Find the locations of variables in the whole function.  */\n \n-static void\n+static bool\n vt_find_locations (void)\n {\n   fibheap_t worklist, pending, fibheap_swap;\n@@ -5521,6 +5523,8 @@ vt_find_locations (void)\n   int *rc_order;\n   int i;\n   int htabsz = 0;\n+  int htabmax = PARAM_VALUE (PARAM_MAX_VARTRACK_SIZE);\n+  bool success = true;\n \n   /* Compute reverse completion order of depth first search of the CFG\n      so that the data-flow runs faster.  */\n@@ -5542,7 +5546,7 @@ vt_find_locations (void)\n     fibheap_insert (pending, bb_order[bb->index], bb);\n   sbitmap_ones (in_pending);\n \n-  while (!fibheap_empty (pending))\n+  while (success && !fibheap_empty (pending))\n     {\n       fibheap_swap = pending;\n       pending = worklist;\n@@ -5565,11 +5569,11 @@ vt_find_locations (void)\n \n \t      SET_BIT (visited, bb->index);\n \n-\t      if (dump_file && VTI (bb)->in.vars)\n+\t      if (VTI (bb)->in.vars)\n \t\t{\n \t\t  htabsz\n-\t\t    -= htab_size (shared_hash_htab (VTI (bb)->in.vars))\n-\t\t       + htab_size (shared_hash_htab (VTI (bb)->out.vars));\n+\t\t    -= (htab_size (shared_hash_htab (VTI (bb)->in.vars))\n+\t\t\t+ htab_size (shared_hash_htab (VTI (bb)->out.vars)));\n \t\t  oldinsz\n \t\t    = htab_elements (shared_hash_htab (VTI (bb)->in.vars));\n \t\t  oldoutsz\n@@ -5633,9 +5637,21 @@ vt_find_locations (void)\n \t\t}\n \n \t      changed = compute_bb_dataflow (bb);\n-\t      if (dump_file)\n-\t\thtabsz += htab_size (shared_hash_htab (VTI (bb)->in.vars))\n-\t\t\t  + htab_size (shared_hash_htab (VTI (bb)->out.vars));\n+\t      htabsz += (htab_size (shared_hash_htab (VTI (bb)->in.vars))\n+\t\t\t + htab_size (shared_hash_htab (VTI (bb)->out.vars)));\n+\n+\t      if (htabmax && htabsz > htabmax)\n+\t\t{\n+\t\t  if (MAY_HAVE_DEBUG_INSNS)\n+\t\t    inform (DECL_SOURCE_LOCATION (cfun->decl),\n+\t\t\t    \"variable tracking size limit exceeded with \"\n+\t\t\t    \"-fvar-tracking-assignments, retrying without\");\n+\t\t  else\n+\t\t    inform (DECL_SOURCE_LOCATION (cfun->decl),\n+\t\t\t    \"variable tracking size limit exceeded\");\n+\t\t  success = false;\n+\t\t  break;\n+\t\t}\n \n \t      if (changed)\n \t\t{\n@@ -5686,7 +5702,7 @@ vt_find_locations (void)\n \t}\n     }\n \n-  if (MAY_HAVE_DEBUG_INSNS)\n+  if (success && MAY_HAVE_DEBUG_INSNS)\n     FOR_EACH_BB (bb)\n       gcc_assert (VTI (bb)->flooded);\n \n@@ -5697,6 +5713,8 @@ vt_find_locations (void)\n   sbitmap_free (visited);\n   sbitmap_free (in_worklist);\n   sbitmap_free (in_pending);\n+\n+  return success;\n }\n \n /* Print the content of the LIST to dump file.  */\n@@ -7599,9 +7617,11 @@ vt_finalize (void)\n \n /* The entry point to variable tracking pass.  */\n \n-unsigned int\n-variable_tracking_main (void)\n+static inline unsigned int\n+variable_tracking_main_1 (void)\n {\n+  bool success;\n+\n   if (flag_var_tracking_assignments < 0)\n     {\n       delete_debug_insns ();\n@@ -7626,7 +7646,31 @@ variable_tracking_main (void)\n \t}\n     }\n \n-  vt_find_locations ();\n+  success = vt_find_locations ();\n+\n+  if (!success && flag_var_tracking_assignments > 0)\n+    {\n+      vt_finalize ();\n+\n+      delete_debug_insns ();\n+\n+      /* This is later restored by our caller.  */\n+      flag_var_tracking_assignments = 0;\n+\n+      vt_initialize ();\n+\n+      if (!frame_pointer_needed && !vt_stack_adjustments ())\n+\tgcc_unreachable ();\n+\n+      success = vt_find_locations ();\n+    }\n+\n+  if (!success)\n+    {\n+      vt_finalize ();\n+      vt_debug_insns_local (false);\n+      return 0;\n+    }\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -7640,6 +7684,19 @@ variable_tracking_main (void)\n   vt_debug_insns_local (false);\n   return 0;\n }\n+\n+unsigned int\n+variable_tracking_main (void)\n+{\n+  unsigned int ret;\n+  int save = flag_var_tracking_assignments;\n+\n+  ret = variable_tracking_main_1 ();\n+\n+  flag_var_tracking_assignments = save;\n+\n+  return ret;\n+}\n \f\n static bool\n gate_handle_var_tracking (void)"}]}