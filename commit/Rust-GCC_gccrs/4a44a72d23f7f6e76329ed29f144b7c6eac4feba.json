{"sha": "4a44a72d23f7f6e76329ed29f144b7c6eac4feba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE0NGE3MmQyM2Y3ZjZlNzYzMjllZDI5ZjE0NGI3YzZlYWM0ZmViYQ==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2009-08-27T11:42:56Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2009-08-27T11:42:56Z"}, "message": "re PR fortran/37425 (Fortran 2003: GENERIC bindings as operators)\n\n2009-08-27  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/37425\n\t* gfortran.h (gfc_expr): Optionally store base-object in compcall value\n\tand add a new flag to distinguish assign-calls generated.\n\t(gfc_find_typebound_proc): Add locus argument.\n\t(gfc_find_typebound_user_op), (gfc_find_typebound_intrinsic_op): Ditto.\n\t(gfc_extend_expr): Return if failure was by a real error.\n\t* interface.c (matching_typebound_op): New routine.\n\t(build_compcall_for_operator): New routine.\n\t(gfc_extend_expr): Handle type-bound operators, some clean-up and\n\treturn if failure was by a real error or just by not finding an\n\tappropriate operator definition.\n\t(gfc_extend_assign): Handle type-bound assignments.\n\t* module.c (MOD_VERSION): Incremented.\n\t(mio_intrinsic_op): New routine.\n\t(mio_full_typebound_tree): New routine to make typebound-procedures IO\n\tcode reusable for type-bound user operators.\n\t(mio_f2k_derived): IO of type-bound operators.\n\t* primary.c (gfc_match_varspec): Initialize new fields in gfc_expr and\n\tpass locus to gfc_find_typebound_proc.\n\t* resolve.c (resolve_operator): Only output error about no matching\n\tinterface if gfc_extend_expr did not already fail with an error.\n\t(extract_compcall_passed_object): Use specified base-object if present.\n\t(update_compcall_arglist): Handle ignore_pass field.\n\t(resolve_ordinary_assign): Update to handle extended code for\n\ttype-bound assignments, too.\n\t(resolve_code): Handle EXEC_ASSIGN_CALL statement code.\n\t(resolve_tb_generic_targets): Pass locus to gfc_find_typebound_proc.\n\t(resolve_typebound_generic), (resolve_typebound_procedure): Ditto.\n\t(resolve_typebound_intrinsic_op), (resolve_typebound_user_op): Ditto.\n\t(ensure_not_abstract_walker), (resolve_fl_derived): Ditto.\n\t(resolve_typebound_procedures): Remove not-implemented error.\n\t(resolve_typebound_call): Handle assign-call flag.\n\t* symbol.c (find_typebound_proc_uop): New argument to pass locus for\n\terror message about PRIVATE, verify that a found procedure is not marked\n\tas erraneous.\n\t(gfc_find_typebound_intrinsic_op): Ditto.\n\t(gfc_find_typebound_proc), (gfc_find_typebound_user_op): New locus arg.\n\n2009-08-27  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/37425\n\t* gfortran.dg/impure_assignment_1.f90: Change expected error message.\n\t* gfortran.dg/typebound_operator_1.f03: Remove check for not-implemented\n\terror and fix problem with recursive assignment.\n\t* gfortran.dg/typebound_operator_2.f03: No not-implemented check.\n\t* gfortran.dg/typebound_operator_3.f03: New test.\n\t* gfortran.dg/typebound_operator_4.f03: New test.\n\nFrom-SVN: r151140", "tree": {"sha": "f369fcdea13ac4e8e34e46ac4c3a080fde15b4ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f369fcdea13ac4e8e34e46ac4c3a080fde15b4ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a44a72d23f7f6e76329ed29f144b7c6eac4feba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a44a72d23f7f6e76329ed29f144b7c6eac4feba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a44a72d23f7f6e76329ed29f144b7c6eac4feba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a44a72d23f7f6e76329ed29f144b7c6eac4feba/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c6a21142739cda7214691bd17f66ab9c72d78164", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6a21142739cda7214691bd17f66ab9c72d78164", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6a21142739cda7214691bd17f66ab9c72d78164"}], "stats": {"total": 793, "additions": 660, "deletions": 133}, "files": [{"sha": "23dce579c12aeb1f730d0f97aea59741a1dadb13", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a44a72d23f7f6e76329ed29f144b7c6eac4feba/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a44a72d23f7f6e76329ed29f144b7c6eac4feba/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4a44a72d23f7f6e76329ed29f144b7c6eac4feba", "patch": "@@ -1,3 +1,43 @@\n+2009-08-27  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/37425\n+\t* gfortran.h (gfc_expr): Optionally store base-object in compcall value\n+\tand add a new flag to distinguish assign-calls generated.\n+\t(gfc_find_typebound_proc): Add locus argument.\n+\t(gfc_find_typebound_user_op), (gfc_find_typebound_intrinsic_op): Ditto.\n+\t(gfc_extend_expr): Return if failure was by a real error.\n+\t* interface.c (matching_typebound_op): New routine.\n+\t(build_compcall_for_operator): New routine.\n+\t(gfc_extend_expr): Handle type-bound operators, some clean-up and\n+\treturn if failure was by a real error or just by not finding an\n+\tappropriate operator definition.\n+\t(gfc_extend_assign): Handle type-bound assignments.\n+\t* module.c (MOD_VERSION): Incremented.\n+\t(mio_intrinsic_op): New routine.\n+\t(mio_full_typebound_tree): New routine to make typebound-procedures IO\n+\tcode reusable for type-bound user operators.\n+\t(mio_f2k_derived): IO of type-bound operators.\n+\t* primary.c (gfc_match_varspec): Initialize new fields in gfc_expr and\n+\tpass locus to gfc_find_typebound_proc.\n+\t* resolve.c (resolve_operator): Only output error about no matching\n+\tinterface if gfc_extend_expr did not already fail with an error.\n+\t(extract_compcall_passed_object): Use specified base-object if present.\n+\t(update_compcall_arglist): Handle ignore_pass field.\n+\t(resolve_ordinary_assign): Update to handle extended code for\n+\ttype-bound assignments, too.\n+\t(resolve_code): Handle EXEC_ASSIGN_CALL statement code.\n+\t(resolve_tb_generic_targets): Pass locus to gfc_find_typebound_proc.\n+\t(resolve_typebound_generic), (resolve_typebound_procedure): Ditto.\n+\t(resolve_typebound_intrinsic_op), (resolve_typebound_user_op): Ditto.\n+\t(ensure_not_abstract_walker), (resolve_fl_derived): Ditto.\n+\t(resolve_typebound_procedures): Remove not-implemented error.\n+\t(resolve_typebound_call): Handle assign-call flag.\n+\t* symbol.c (find_typebound_proc_uop): New argument to pass locus for\n+\terror message about PRIVATE, verify that a found procedure is not marked\n+\tas erraneous.\n+\t(gfc_find_typebound_intrinsic_op): Ditto.\n+\t(gfc_find_typebound_proc), (gfc_find_typebound_user_op): New locus arg.\n+\n 2009-08-22      Bud Davis <bdavis9659@sbcglobal.net>\n \n \tPR fortran/28093"}, {"sha": "16c596bd753f1e157e0ea14701dc1813b9b566f9", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a44a72d23f7f6e76329ed29f144b7c6eac4feba/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a44a72d23f7f6e76329ed29f144b7c6eac4feba/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=4a44a72d23f7f6e76329ed29f144b7c6eac4feba", "patch": "@@ -1622,8 +1622,8 @@ typedef struct gfc_expr\n   int rank;\n   mpz_t *shape;\t\t/* Can be NULL if shape is unknown at compile time */\n \n-  /* Nonnull for functions and structure constructors, the base object for\n-     component-calls.  */\n+  /* Nonnull for functions and structure constructors, may also used to hold the\n+     base-object for component calls.  */\n   gfc_symtree *symtree;\n \n   gfc_ref *ref;\n@@ -1699,8 +1699,19 @@ typedef struct gfc_expr\n     {\n       gfc_actual_arglist* actual;\n       const char* name;\n-      void* padding;  /* Overlap gfc_typebound_proc with esym.  */\n-      gfc_typebound_proc* tbp;\n+      /* Base-object, whose component was called.  NULL means that it should\n+\t be taken from symtree/ref.  */\n+      struct gfc_expr* base_object;\n+      gfc_typebound_proc* tbp; /* Should overlap with esym.  */\n+\n+      /* For type-bound operators, we want to call PASS procedures but already\n+\t have the full arglist; mark this, so that it is not extended by the\n+\t PASS argument.  */\n+      unsigned ignore_pass:1;\n+\n+      /* Do assign-calls rather than calls, that is appropriate dependency\n+\t checking.  */\n+      unsigned assign:1;\n     }\n     compcall;\n \n@@ -2458,11 +2469,13 @@ gfc_gsymbol *gfc_find_gsymbol (gfc_gsymbol *, const char *);\n \n gfc_typebound_proc* gfc_get_typebound_proc (void);\n gfc_symbol* gfc_get_derived_super_type (gfc_symbol*);\n-gfc_symtree* gfc_find_typebound_proc (gfc_symbol*, gfc_try*, const char*, bool);\n+gfc_symtree* gfc_find_typebound_proc (gfc_symbol*, gfc_try*,\n+\t\t\t\t      const char*, bool, locus*);\n gfc_symtree* gfc_find_typebound_user_op (gfc_symbol*, gfc_try*,\n-\t\t\t\t\t const char*, bool);\n+\t\t\t\t\t const char*, bool, locus*);\n gfc_typebound_proc* gfc_find_typebound_intrinsic_op (gfc_symbol*, gfc_try*,\n-\t\t\t\t\t\t     gfc_intrinsic_op, bool);\n+\t\t\t\t\t\t     gfc_intrinsic_op, bool,\n+\t\t\t\t\t\t     locus*);\n gfc_symtree* gfc_get_tbp_symtree (gfc_symtree**, const char*);\n \n void gfc_copy_formal_args (gfc_symbol *, gfc_symbol *);\n@@ -2643,7 +2656,7 @@ void gfc_procedure_use (gfc_symbol *, gfc_actual_arglist **, locus *);\n void gfc_ppc_use (gfc_component *, gfc_actual_arglist **, locus *);\n gfc_symbol *gfc_search_interface (gfc_interface *, int,\n \t\t\t\t  gfc_actual_arglist **);\n-gfc_try gfc_extend_expr (gfc_expr *);\n+gfc_try gfc_extend_expr (gfc_expr *, bool *);\n void gfc_free_formal_arglist (gfc_formal_arglist *);\n gfc_try gfc_extend_assign (gfc_code *, gfc_namespace *);\n gfc_try gfc_add_interface (gfc_symbol *);"}, {"sha": "6d16fe10f420d40f0f745622b5a7b79b4509bde4", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 199, "deletions": 49, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a44a72d23f7f6e76329ed29f144b7c6eac4feba/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a44a72d23f7f6e76329ed29f144b7c6eac4feba/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=4a44a72d23f7f6e76329ed29f144b7c6eac4feba", "patch": "@@ -2554,16 +2554,119 @@ gfc_find_sym_in_symtree (gfc_symbol *sym)\n }\n \n \n+/* See if the arglist to an operator-call contains a derived-type argument\n+   with a matching type-bound operator.  If so, return the matching specific\n+   procedure defined as operator-target as well as the base-object to use\n+   (which is the found derived-type argument with operator).  */\n+\n+static gfc_typebound_proc*\n+matching_typebound_op (gfc_expr** tb_base,\n+\t\t       gfc_actual_arglist* args,\n+\t\t       gfc_intrinsic_op op, const char* uop)\n+{\n+  gfc_actual_arglist* base;\n+\n+  for (base = args; base; base = base->next)\n+    if (base->expr->ts.type == BT_DERIVED)\n+      {\n+\tgfc_typebound_proc* tb;\n+\tgfc_symbol* derived;\n+\tgfc_try result;\n+\n+\tderived = base->expr->ts.u.derived;\n+\n+\tif (op == INTRINSIC_USER)\n+\t  {\n+\t    gfc_symtree* tb_uop;\n+\n+\t    gcc_assert (uop);\n+\t    tb_uop = gfc_find_typebound_user_op (derived, &result, uop,\n+\t\t\t\t\t\t false, NULL);\n+\n+\t    if (tb_uop)\n+\t      tb = tb_uop->n.tb;\n+\t    else\n+\t      tb = NULL;\n+\t  }\n+\telse\n+\t  tb = gfc_find_typebound_intrinsic_op (derived, &result, op,\n+\t\t\t\t\t\tfalse, NULL);\n+\n+\t/* This means we hit a PRIVATE operator which is use-associated and\n+\t   should thus not be seen.  */\n+\tif (result == FAILURE)\n+\t  tb = NULL;\n+\n+\t/* Look through the super-type hierarchy for a matching specific\n+\t   binding.  */\n+\tfor (; tb; tb = tb->overridden)\n+\t  {\n+\t    gfc_tbp_generic* g;\n+\n+\t    gcc_assert (tb->is_generic);\n+\t    for (g = tb->u.generic; g; g = g->next)\n+\t      {\n+\t\tgfc_symbol* target;\n+\t\tgfc_actual_arglist* argcopy;\n+\t\tbool matches;\n+\n+\t\tgcc_assert (g->specific);\n+\t\tif (g->specific->error)\n+\t\t  continue;\n+\n+\t\ttarget = g->specific->u.specific->n.sym;\n+\n+\t\t/* Check if this arglist matches the formal.  */\n+\t\targcopy = gfc_copy_actual_arglist (args);\n+\t\tmatches = gfc_arglist_matches_symbol (&argcopy, target);\n+\t\tgfc_free_actual_arglist (argcopy);\n+\n+\t\t/* Return if we found a match.  */\n+\t\tif (matches)\n+\t\t  {\n+\t\t    *tb_base = base->expr;\n+\t\t    return g->specific;\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n+\n+  return NULL;\n+}\n+\n+\n+/* For the 'actual arglist' of an operator call and a specific typebound\n+   procedure that has been found the target of a type-bound operator, build the\n+   appropriate EXPR_COMPCALL and resolve it.  We take this indirection over\n+   type-bound procedures rather than resolving type-bound operators 'directly'\n+   so that we can reuse the existing logic.  */\n+\n+static void\n+build_compcall_for_operator (gfc_expr* e, gfc_actual_arglist* actual,\n+\t\t\t     gfc_expr* base, gfc_typebound_proc* target)\n+{\n+  e->expr_type = EXPR_COMPCALL;\n+  e->value.compcall.tbp = target;\n+  e->value.compcall.name = \"operator\"; /* Should not matter.  */\n+  e->value.compcall.actual = actual;\n+  e->value.compcall.base_object = base;\n+  e->value.compcall.ignore_pass = 1;\n+  e->value.compcall.assign = 0;\n+}\n+\n+\n /* This subroutine is called when an expression is being resolved.\n    The expression node in question is either a user defined operator\n    or an intrinsic operator with arguments that aren't compatible\n    with the operator.  This subroutine builds an actual argument list\n    corresponding to the operands, then searches for a compatible\n    interface.  If one is found, the expression node is replaced with\n-   the appropriate function call.  */\n+   the appropriate function call.\n+   real_error is an additional output argument that specifies if FAILURE\n+   is because of some real error and not because no match was found.  */\n \n gfc_try\n-gfc_extend_expr (gfc_expr *e)\n+gfc_extend_expr (gfc_expr *e, bool *real_error)\n {\n   gfc_actual_arglist *actual;\n   gfc_symbol *sym;\n@@ -2576,6 +2679,8 @@ gfc_extend_expr (gfc_expr *e)\n   actual = gfc_get_actual_arglist ();\n   actual->expr = e->value.op.op1;\n \n+  *real_error = false;\n+\n   if (e->value.op.op2 != NULL)\n     {\n       actual->next = gfc_get_actual_arglist ();\n@@ -2605,47 +2710,20 @@ gfc_extend_expr (gfc_expr *e)\n \t     to check if either is defined.  */\n \t  switch (i)\n \t    {\n-\t      case INTRINSIC_EQ:\n-\t      case INTRINSIC_EQ_OS:\n-\t\tsym = gfc_search_interface (ns->op[INTRINSIC_EQ], 0, &actual);\n-\t\tif (sym == NULL)\n-\t\t  sym = gfc_search_interface (ns->op[INTRINSIC_EQ_OS], 0, &actual);\n-\t\tbreak;\n-\n-\t      case INTRINSIC_NE:\n-\t      case INTRINSIC_NE_OS:\n-\t\tsym = gfc_search_interface (ns->op[INTRINSIC_NE], 0, &actual);\n-\t\tif (sym == NULL)\n-\t\t  sym = gfc_search_interface (ns->op[INTRINSIC_NE_OS], 0, &actual);\n-\t\tbreak;\n-\n-\t      case INTRINSIC_GT:\n-\t      case INTRINSIC_GT_OS:\n-\t\tsym = gfc_search_interface (ns->op[INTRINSIC_GT], 0, &actual);\n-\t\tif (sym == NULL)\n-\t\t  sym = gfc_search_interface (ns->op[INTRINSIC_GT_OS], 0, &actual);\n-\t\tbreak;\n-\n-\t      case INTRINSIC_GE:\n-\t      case INTRINSIC_GE_OS:\n-\t\tsym = gfc_search_interface (ns->op[INTRINSIC_GE], 0, &actual);\n-\t\tif (sym == NULL)\n-\t\t  sym = gfc_search_interface (ns->op[INTRINSIC_GE_OS], 0, &actual);\n-\t\tbreak;\n-\n-\t      case INTRINSIC_LT:\n-\t      case INTRINSIC_LT_OS:\n-\t\tsym = gfc_search_interface (ns->op[INTRINSIC_LT], 0, &actual);\n-\t\tif (sym == NULL)\n-\t\t  sym = gfc_search_interface (ns->op[INTRINSIC_LT_OS], 0, &actual);\n-\t\tbreak;\n-\n-\t      case INTRINSIC_LE:\n-\t      case INTRINSIC_LE_OS:\n-\t\tsym = gfc_search_interface (ns->op[INTRINSIC_LE], 0, &actual);\n-\t\tif (sym == NULL)\n-\t\t  sym = gfc_search_interface (ns->op[INTRINSIC_LE_OS], 0, &actual);\n-\t\tbreak;\n+#define CHECK_OS_COMPARISON(comp) \\\n+  case INTRINSIC_##comp: \\\n+  case INTRINSIC_##comp##_OS: \\\n+    sym = gfc_search_interface (ns->op[INTRINSIC_##comp], 0, &actual); \\\n+    if (!sym) \\\n+      sym = gfc_search_interface (ns->op[INTRINSIC_##comp##_OS], 0, &actual); \\\n+    break;\n+\t      CHECK_OS_COMPARISON(EQ)\n+\t      CHECK_OS_COMPARISON(NE)\n+\t      CHECK_OS_COMPARISON(GT)\n+\t      CHECK_OS_COMPARISON(GE)\n+\t      CHECK_OS_COMPARISON(LT)\n+\t      CHECK_OS_COMPARISON(LE)\n+#undef CHECK_OS_COMPARISON\n \n \t      default:\n \t\tsym = gfc_search_interface (ns->op[i], 0, &actual);\n@@ -2656,8 +2734,59 @@ gfc_extend_expr (gfc_expr *e)\n \t}\n     }\n \n+  /* TODO: Do an ambiguity-check and error if multiple matching interfaces are\n+     found rather than just taking the first one and not checking further.  */\n+\n   if (sym == NULL)\n     {\n+      gfc_typebound_proc* tbo;\n+      gfc_expr* tb_base;\n+\n+      /* See if we find a matching type-bound operator.  */\n+      if (i == INTRINSIC_USER)\n+\ttbo = matching_typebound_op (&tb_base, actual,\n+\t\t\t\t     i, e->value.op.uop->name);\n+      else\n+\tswitch (i)\n+\t  {\n+#define CHECK_OS_COMPARISON(comp) \\\n+  case INTRINSIC_##comp: \\\n+  case INTRINSIC_##comp##_OS: \\\n+    tbo = matching_typebound_op (&tb_base, actual, \\\n+\t\t\t\t INTRINSIC_##comp, NULL); \\\n+    if (!tbo) \\\n+      tbo = matching_typebound_op (&tb_base, actual, \\\n+\t\t\t\t   INTRINSIC_##comp##_OS, NULL); \\\n+    break;\n+\t    CHECK_OS_COMPARISON(EQ)\n+\t    CHECK_OS_COMPARISON(NE)\n+\t    CHECK_OS_COMPARISON(GT)\n+\t    CHECK_OS_COMPARISON(GE)\n+\t    CHECK_OS_COMPARISON(LT)\n+\t    CHECK_OS_COMPARISON(LE)\n+#undef CHECK_OS_COMPARISON\n+\n+\t    default:\n+\t      tbo = matching_typebound_op (&tb_base, actual, i, NULL);\n+\t      break;\n+\t  }\n+\t      \n+      /* If there is a matching typebound-operator, replace the expression with\n+\t a call to it and succeed.  */\n+      if (tbo)\n+\t{\n+\t  gfc_try result;\n+\n+\t  gcc_assert (tb_base);\n+\t  build_compcall_for_operator (e, actual, tb_base, tbo);\n+\n+\t  result = gfc_resolve_expr (e);\n+\t  if (result == FAILURE)\n+\t    *real_error = true;\n+\n+\t  return result;\n+\t}\n+\n       /* Don't use gfc_free_actual_arglist().  */\n       if (actual->next != NULL)\n \tgfc_free (actual->next);\n@@ -2675,16 +2804,12 @@ gfc_extend_expr (gfc_expr *e)\n   e->value.function.name = NULL;\n   e->user_operator = 1;\n \n-  if (gfc_pure (NULL) && !gfc_pure (sym))\n+  if (gfc_resolve_expr (e) == FAILURE)\n     {\n-      gfc_error (\"Function '%s' called in lieu of an operator at %L must \"\n-\t\t \"be PURE\", sym->name, &e->where);\n+      *real_error = true;\n       return FAILURE;\n     }\n \n-  if (gfc_resolve_expr (e) == FAILURE)\n-    return FAILURE;\n-\n   return SUCCESS;\n }\n \n@@ -2726,8 +2851,33 @@ gfc_extend_assign (gfc_code *c, gfc_namespace *ns)\n \tbreak;\n     }\n \n+  /* TODO: Ambiguity-check, see above for gfc_extend_expr.  */\n+\n   if (sym == NULL)\n     {\n+      gfc_typebound_proc* tbo;\n+      gfc_expr* tb_base;\n+\n+      /* See if we find a matching type-bound assignment.  */\n+      tbo = matching_typebound_op (&tb_base, actual,\n+\t\t\t\t   INTRINSIC_ASSIGN, NULL);\n+\t      \n+      /* If there is one, replace the expression with a call to it and\n+\t succeed.  */\n+      if (tbo)\n+\t{\n+\t  gcc_assert (tb_base);\n+\t  c->expr1 = gfc_get_expr ();\n+\t  build_compcall_for_operator (c->expr1, actual, tb_base, tbo);\n+\t  c->expr1->value.compcall.assign = 1;\n+\t  c->expr2 = NULL;\n+\t  c->op = EXEC_COMPCALL;\n+\n+\t  /* c is resolved from the caller, so no need to do it here.  */\n+\n+\t  return SUCCESS;\n+\t}\n+\n       gfc_free (actual->next);\n       gfc_free (actual);\n       return FAILURE;"}, {"sha": "ec15d3f800077ec5f2b55787f66a5eb1f4a90df3", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 74, "deletions": 11, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a44a72d23f7f6e76329ed29f144b7c6eac4feba/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a44a72d23f7f6e76329ed29f144b7c6eac4feba/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=4a44a72d23f7f6e76329ed29f144b7c6eac4feba", "patch": "@@ -77,7 +77,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Don't put any single quote (') in MOD_VERSION, \n    if yout want it to be recognized.  */\n-#define MOD_VERSION \"2\"\n+#define MOD_VERSION \"3\"\n \n \n /* Structure that describes a position within a module file.  */\n@@ -1461,6 +1461,25 @@ mio_integer (int *ip)\n }\n \n \n+/* Read or write a gfc_intrinsic_op value.  */\n+\n+static void\n+mio_intrinsic_op (gfc_intrinsic_op* op)\n+{\n+  /* FIXME: Would be nicer to do this via the operators symbolic name.  */\n+  if (iomode == IO_OUTPUT)\n+    {\n+      int converted = (int) *op;\n+      write_atom (ATOM_INTEGER, &converted);\n+    }\n+  else\n+    {\n+      require_atom (ATOM_INTEGER);\n+      *op = (gfc_intrinsic_op) atom_int;\n+    }\n+}\n+\n+\n /* Read or write a character pointer that points to a string on the heap.  */\n \n static const char *\n@@ -3324,6 +3343,7 @@ mio_typebound_proc (gfc_typebound_proc** proc)\n   mio_rparen ();\n }\n \n+/* Walker-callback function for this purpose.  */\n static void\n mio_typebound_symtree (gfc_symtree* st)\n {\n@@ -3341,6 +3361,33 @@ mio_typebound_symtree (gfc_symtree* st)\n   mio_rparen ();\n }\n \n+/* IO a full symtree (in all depth).  */\n+static void\n+mio_full_typebound_tree (gfc_symtree** root)\n+{\n+  mio_lparen ();\n+\n+  if (iomode == IO_OUTPUT)\n+    gfc_traverse_symtree (*root, &mio_typebound_symtree);\n+  else\n+    {\n+      while (peek_atom () == ATOM_LPAREN)\n+\t{\n+\t  gfc_symtree* st;\n+\n+\t  mio_lparen (); \n+\n+\t  require_atom (ATOM_STRING);\n+\t  st = gfc_get_tbp_symtree (root, atom_string);\n+\t  gfc_free (atom_string);\n+\n+\t  mio_typebound_symtree (st);\n+\t}\n+    }\n+\n+  mio_rparen ();\n+}\n+\n static void\n mio_finalizer (gfc_finalizer **f)\n {\n@@ -3388,24 +3435,40 @@ mio_f2k_derived (gfc_namespace *f2k)\n   mio_rparen ();\n \n   /* Handle type-bound procedures.  */\n+  mio_full_typebound_tree (&f2k->tb_sym_root);\n+\n+  /* Type-bound user operators.  */\n+  mio_full_typebound_tree (&f2k->tb_uop_root);\n+\n+  /* Type-bound intrinsic operators.  */\n   mio_lparen ();\n   if (iomode == IO_OUTPUT)\n-    gfc_traverse_symtree (f2k->tb_sym_root, &mio_typebound_symtree);\n-  else\n     {\n-      while (peek_atom () == ATOM_LPAREN)\n+      int op;\n+      for (op = GFC_INTRINSIC_BEGIN; op != GFC_INTRINSIC_END; ++op)\n \t{\n-\t  gfc_symtree* st;\n-\n-\t  mio_lparen (); \n+\t  gfc_intrinsic_op realop;\n \n-\t  require_atom (ATOM_STRING);\n-\t  st = gfc_get_tbp_symtree (&f2k->tb_sym_root, atom_string);\n-\t  gfc_free (atom_string);\n+\t  if (op == INTRINSIC_USER || !f2k->tb_op[op])\n+\t    continue;\n \n-\t  mio_typebound_symtree (st);\n+\t  mio_lparen ();\n+\t  realop = (gfc_intrinsic_op) op;\n+\t  mio_intrinsic_op (&realop);\n+\t  mio_typebound_proc (&f2k->tb_op[op]);\n+\t  mio_rparen ();\n \t}\n     }\n+  else\n+    while (peek_atom () != ATOM_RPAREN)\n+      {\n+\tgfc_intrinsic_op op;\n+\n+\tmio_lparen ();\n+\tmio_intrinsic_op (&op);\n+\tmio_typebound_proc (&f2k->tb_op[op]);\n+\tmio_rparen ();\n+      }\n   mio_rparen ();\n }\n "}, {"sha": "267819c69f65f7388997eaabbedbaf99fb20f77a", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a44a72d23f7f6e76329ed29f144b7c6eac4feba/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a44a72d23f7f6e76329ed29f144b7c6eac4feba/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=4a44a72d23f7f6e76329ed29f144b7c6eac4feba", "patch": "@@ -1783,7 +1783,7 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n       if (m != MATCH_YES)\n \treturn MATCH_ERROR;\n \n-      tbp = gfc_find_typebound_proc (sym, &t, name, false);\n+      tbp = gfc_find_typebound_proc (sym, &t, name, false, &gfc_current_locus);\n       if (tbp)\n \t{\n \t  gfc_symbol* tbp_sym;\n@@ -1802,6 +1802,9 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n \t  primary->expr_type = EXPR_COMPCALL;\n \t  primary->value.compcall.tbp = tbp->n.tb;\n \t  primary->value.compcall.name = tbp->name;\n+\t  primary->value.compcall.ignore_pass = 0;\n+\t  primary->value.compcall.assign = 0;\n+\t  primary->value.compcall.base_object = NULL;\n \t  gcc_assert (primary->symtree->n.sym->attr.referenced);\n \t  if (tbp_sym)\n \t    primary->ts = tbp_sym->ts;"}, {"sha": "e1c931ba0fffd06d9487f09a5d1811e7f07440e9", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 65, "deletions": 46, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a44a72d23f7f6e76329ed29f144b7c6eac4feba/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a44a72d23f7f6e76329ed29f144b7c6eac4feba/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=4a44a72d23f7f6e76329ed29f144b7c6eac4feba", "patch": "@@ -3508,8 +3508,14 @@ resolve_operator (gfc_expr *e)\n \n bad_op:\n \n-  if (gfc_extend_expr (e) == SUCCESS)\n-    return SUCCESS;\n+  {\n+    bool real_error;\n+    if (gfc_extend_expr (e, &real_error) == SUCCESS)\n+      return SUCCESS;\n+\n+    if (real_error)\n+      return FAILURE;\n+  }\n \n   if (dual_locus_error)\n     gfc_error (msg, &op1->where, &op2->where);\n@@ -4685,10 +4691,15 @@ extract_compcall_passed_object (gfc_expr* e)\n \n   gcc_assert (e->expr_type == EXPR_COMPCALL);\n \n-  po = gfc_get_expr ();\n-  po->expr_type = EXPR_VARIABLE;\n-  po->symtree = e->symtree;\n-  po->ref = gfc_copy_ref (e->ref);\n+  if (e->value.compcall.base_object)\n+    po = gfc_copy_expr (e->value.compcall.base_object);\n+  else\n+    {\n+      po = gfc_get_expr ();\n+      po->expr_type = EXPR_VARIABLE;\n+      po->symtree = e->symtree;\n+      po->ref = gfc_copy_ref (e->ref);\n+    }\n \n   if (gfc_resolve_expr (po) == FAILURE)\n     return NULL;\n@@ -4721,7 +4732,7 @@ update_compcall_arglist (gfc_expr* e)\n       return FAILURE;\n     }\n \n-  if (tbp->nopass)\n+  if (tbp->nopass || e->value.compcall.ignore_pass)\n     {\n       gfc_free_expr (po);\n       return SUCCESS;\n@@ -4957,7 +4968,7 @@ resolve_typebound_call (gfc_code* c)\n \n   c->ext.actual = newactual;\n   c->symtree = target;\n-  c->op = EXEC_CALL;\n+  c->op = (c->expr1->value.compcall.assign ? EXEC_ASSIGN_CALL : EXEC_CALL);\n \n   gcc_assert (!c->expr1->ref && !c->expr1->value.compcall.actual);\n   gfc_free_expr (c->expr1);\n@@ -4983,6 +4994,9 @@ resolve_compcall (gfc_expr* e)\n       return FAILURE;\n     }\n \n+  /* These must not be assign-calls!  */\n+  gcc_assert (!e->value.compcall.assign);\n+\n   if (check_typebound_baseobject (e) == FAILURE)\n     return FAILURE;\n \n@@ -6909,24 +6923,40 @@ resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)\n \n   if (gfc_extend_assign (code, ns) == SUCCESS)\n     {\n-      lhs = code->ext.actual->expr;\n-      rhs = code->ext.actual->next->expr;\n-      if (gfc_pure (NULL) && !gfc_pure (code->symtree->n.sym))\n+      gfc_symbol* assign_proc;\n+      gfc_expr** rhsptr;\n+\n+      if (code->op == EXEC_ASSIGN_CALL)\n \t{\n-\t  gfc_error (\"Subroutine '%s' called instead of assignment at \"\n-\t\t     \"%L must be PURE\", code->symtree->n.sym->name,\n-\t\t     &code->loc);\n-\t  return rval;\n+\t  lhs = code->ext.actual->expr;\n+\t  rhsptr = &code->ext.actual->next->expr;\n+\t  assign_proc = code->symtree->n.sym;\n+\t}\n+      else\n+\t{\n+\t  gfc_actual_arglist* args;\n+\t  gfc_typebound_proc* tbp;\n+\n+\t  gcc_assert (code->op == EXEC_COMPCALL);\n+\n+\t  args = code->expr1->value.compcall.actual;\n+\t  lhs = args->expr;\n+\t  rhsptr = &args->next->expr;\n+\n+\t  tbp = code->expr1->value.compcall.tbp;\n+\t  gcc_assert (!tbp->is_generic);\n+\t  assign_proc = tbp->u.specific->n.sym;\n \t}\n \n       /* Make a temporary rhs when there is a default initializer\n \t and rhs is the same symbol as the lhs.  */\n-      if (rhs->expr_type == EXPR_VARIABLE\n-\t    && rhs->symtree->n.sym->ts.type == BT_DERIVED\n-\t    && has_default_initializer (rhs->symtree->n.sym->ts.u.derived)\n-\t    && (lhs->symtree->n.sym == rhs->symtree->n.sym))\n-        code->ext.actual->next->expr = gfc_get_parentheses (rhs);\n+      if ((*rhsptr)->expr_type == EXPR_VARIABLE\n+\t    && (*rhsptr)->symtree->n.sym->ts.type == BT_DERIVED\n+\t    && has_default_initializer ((*rhsptr)->symtree->n.sym->ts.u.derived)\n+\t    && (lhs->symtree->n.sym == (*rhsptr)->symtree->n.sym))\n+\t*rhsptr = gfc_get_parentheses (*rhsptr);\n \n+      resolve_code (code, ns);\n       return true;\n     }\n \n@@ -6935,8 +6965,8 @@ resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)\n \n   if (rhs->is_boz\n       && gfc_notify_std (GFC_STD_GNU, \"Extension: BOZ literal at %L outside \"\n-                         \"a DATA statement and outside INT/REAL/DBLE/CMPLX\",\n-                         &code->loc) == FAILURE)\n+\t\t\t \"a DATA statement and outside INT/REAL/DBLE/CMPLX\",\n+\t\t\t &code->loc) == FAILURE)\n     return false;\n \n   /* Handle the case of a BOZ literal on the RHS.  */\n@@ -6981,7 +7011,7 @@ resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)\n  \trlen = rhs->value.character.length;\n \n       else if (rhs->ts.u.cl != NULL\n-\t         && rhs->ts.u.cl->length != NULL\n+\t\t && rhs->ts.u.cl->length != NULL\n \t\t && rhs->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n \trlen = mpz_get_si (rhs->ts.u.cl->length->value.integer);\n \n@@ -7115,6 +7145,7 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \tcase EXEC_EXIT:\n \tcase EXEC_CONTINUE:\n \tcase EXEC_DT_END:\n+\tcase EXEC_ASSIGN_CALL:\n \t  break;\n \n \tcase EXEC_ENTRY:\n@@ -8870,8 +8901,8 @@ resolve_tb_generic_targets (gfc_symbol* super_type,\n \t/* Look for an inherited specific binding.  */\n \tif (super_type)\n \t  {\n-\t    inherited = gfc_find_typebound_proc (super_type, NULL,\n-\t\t\t\t\t\t target_name, true);\n+\t    inherited = gfc_find_typebound_proc (super_type, NULL, target_name,\n+\t\t\t\t\t\t true, NULL);\n \n \t    if (inherited)\n \t      {\n@@ -8952,7 +8983,8 @@ resolve_typebound_generic (gfc_symbol* derived, gfc_symtree* st)\n   if (super_type)\n     {\n       gfc_symtree* overridden;\n-      overridden = gfc_find_typebound_proc (super_type, NULL, st->name, true);\n+      overridden = gfc_find_typebound_proc (super_type, NULL, st->name,\n+\t\t\t\t\t    true, NULL);\n \n       if (overridden && overridden->n.tb)\n \tst->n.tb->overridden = overridden->n.tb;\n@@ -9006,7 +9038,7 @@ resolve_typebound_intrinsic_op (gfc_symbol* derived, gfc_intrinsic_op op,\n   super_type = gfc_get_derived_super_type (derived);\n   if (super_type && super_type->f2k_derived)\n     p->overridden = gfc_find_typebound_intrinsic_op (super_type, NULL,\n-\t\t\t\t\t\t     op, true);\n+\t\t\t\t\t\t     op, true, NULL);\n   else\n     p->overridden = NULL;\n \n@@ -9021,10 +9053,10 @@ resolve_typebound_intrinsic_op (gfc_symbol* derived, gfc_intrinsic_op op,\n \n       target_proc = get_checked_tb_operator_target (target, p->where);\n       if (!target_proc)\n-\treturn FAILURE;\n+\tgoto error;\n \n       if (!gfc_check_operator_interface (target_proc, op, p->where))\n-\treturn FAILURE;\n+\tgoto error;\n     }\n \n   return SUCCESS;\n@@ -9062,7 +9094,7 @@ resolve_typebound_user_op (gfc_symtree* stree)\n     {\n       gfc_symtree* overridden;\n       overridden = gfc_find_typebound_user_op (super_type, NULL,\n-\t\t\t\t\t       stree->name, true);\n+\t\t\t\t\t       stree->name, true, NULL);\n \n       if (overridden && overridden->n.tb)\n \tstree->n.tb->overridden = overridden->n.tb;\n@@ -9225,7 +9257,7 @@ resolve_typebound_procedure (gfc_symtree* stree)\n     {\n       gfc_symtree* overridden;\n       overridden = gfc_find_typebound_proc (super_type, NULL,\n-\t\t\t\t\t    stree->name, true);\n+\t\t\t\t\t    stree->name, true, NULL);\n \n       if (overridden && overridden->n.tb)\n \tstree->n.tb->overridden = overridden->n.tb;\n@@ -9265,7 +9297,6 @@ static gfc_try\n resolve_typebound_procedures (gfc_symbol* derived)\n {\n   int op;\n-  bool found_op;\n \n   if (!derived->f2k_derived || !derived->f2k_derived->tb_sym_root)\n     return SUCCESS;\n@@ -9277,7 +9308,6 @@ resolve_typebound_procedures (gfc_symbol* derived)\n     gfc_traverse_symtree (derived->f2k_derived->tb_sym_root,\n \t\t\t  &resolve_typebound_procedure);\n \n-  found_op = (derived->f2k_derived->tb_uop_root != NULL);\n   if (derived->f2k_derived->tb_uop_root)\n     gfc_traverse_symtree (derived->f2k_derived->tb_uop_root,\n \t\t\t  &resolve_typebound_user_op);\n@@ -9288,17 +9318,6 @@ resolve_typebound_procedures (gfc_symbol* derived)\n       if (p && resolve_typebound_intrinsic_op (derived, (gfc_intrinsic_op) op,\n \t\t\t\t\t       p) == FAILURE)\n \tresolve_bindings_result = FAILURE;\n-      if (p)\n-\tfound_op = true;\n-    }\n-\n-  /* FIXME: Remove this (and found_op) once calls are fully implemented.  */\n-  if (found_op)\n-    {\n-      gfc_error (\"Derived type '%s' at %L contains type-bound OPERATOR's,\"\n-\t\t \" they are not yet implemented.\",\n-\t\t derived->name, &derived->declared_at);\n-      resolve_bindings_result = FAILURE;\n     }\n \n   return resolve_bindings_result;\n@@ -9343,7 +9362,7 @@ ensure_not_abstract_walker (gfc_symbol* sub, gfc_symtree* st)\n   if (st->n.tb && st->n.tb->deferred)\n     {\n       gfc_symtree* overriding;\n-      overriding = gfc_find_typebound_proc (sub, NULL, st->name, true);\n+      overriding = gfc_find_typebound_proc (sub, NULL, st->name, true, NULL);\n       gcc_assert (overriding && overriding->n.tb);\n       if (overriding->n.tb->deferred)\n \t{\n@@ -9594,7 +9613,7 @@ resolve_fl_derived (gfc_symbol *sym)\n       /* If this type is an extension, see if this component has the same name\n \t as an inherited type-bound procedure.  */\n       if (super_type\n-\t  && gfc_find_typebound_proc (super_type, NULL, c->name, true))\n+\t  && gfc_find_typebound_proc (super_type, NULL, c->name, true, NULL))\n \t{\n \t  gfc_error (\"Component '%s' of '%s' at %L has the same name as an\"\n \t\t     \" inherited type-bound procedure\","}, {"sha": "150d14952b3c633aef060a85378caf84d3c96807", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a44a72d23f7f6e76329ed29f144b7c6eac4feba/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a44a72d23f7f6e76329ed29f144b7c6eac4feba/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=4a44a72d23f7f6e76329ed29f144b7c6eac4feba", "patch": "@@ -4539,7 +4539,8 @@ gfc_get_derived_super_type (gfc_symbol* derived)\n \n static gfc_symtree*\n find_typebound_proc_uop (gfc_symbol* derived, gfc_try* t,\n-\t\t\t const char* name, bool noaccess, bool uop)\n+\t\t\t const char* name, bool noaccess, bool uop,\n+\t\t\t locus* where)\n {\n   gfc_symtree* res;\n   gfc_symtree* root;\n@@ -4555,7 +4556,7 @@ find_typebound_proc_uop (gfc_symbol* derived, gfc_try* t,\n \n   /* Try to find it in the current type's namespace.  */\n   res = gfc_find_symtree (root, name);\n-  if (res && res->n.tb)\n+  if (res && res->n.tb && !res->n.tb->error)\n     {\n       /* We found one.  */\n       if (t)\n@@ -4564,7 +4565,9 @@ find_typebound_proc_uop (gfc_symbol* derived, gfc_try* t,\n       if (!noaccess && derived->attr.use_assoc\n \t  && res->n.tb->access == ACCESS_PRIVATE)\n \t{\n-\t  gfc_error (\"'%s' of '%s' is PRIVATE at %C\", name, derived->name);\n+\t  if (where)\n+\t    gfc_error (\"'%s' of '%s' is PRIVATE at %L\",\n+\t\t       name, derived->name, where);\n \t  if (t)\n \t    *t = FAILURE;\n \t}\n@@ -4579,7 +4582,8 @@ find_typebound_proc_uop (gfc_symbol* derived, gfc_try* t,\n       super_type = gfc_get_derived_super_type (derived);\n       gcc_assert (super_type);\n \n-      return find_typebound_proc_uop (super_type, t, name, noaccess, uop);\n+      return find_typebound_proc_uop (super_type, t, name,\n+\t\t\t\t      noaccess, uop, where);\n     }\n \n   /* Nothing found.  */\n@@ -4592,16 +4596,16 @@ find_typebound_proc_uop (gfc_symbol* derived, gfc_try* t,\n \n gfc_symtree*\n gfc_find_typebound_proc (gfc_symbol* derived, gfc_try* t,\n-\t\t\t const char* name, bool noaccess)\n+\t\t\t const char* name, bool noaccess, locus* where)\n {\n-  return find_typebound_proc_uop (derived, t, name, noaccess, false);\n+  return find_typebound_proc_uop (derived, t, name, noaccess, false, where);\n }\n \n gfc_symtree*\n gfc_find_typebound_user_op (gfc_symbol* derived, gfc_try* t,\n-\t\t\t    const char* name, bool noaccess)\n+\t\t\t    const char* name, bool noaccess, locus* where)\n {\n-  return find_typebound_proc_uop (derived, t, name, noaccess, true);\n+  return find_typebound_proc_uop (derived, t, name, noaccess, true, where);\n }\n \n \n@@ -4610,7 +4614,8 @@ gfc_find_typebound_user_op (gfc_symbol* derived, gfc_try* t,\n \n gfc_typebound_proc*\n gfc_find_typebound_intrinsic_op (gfc_symbol* derived, gfc_try* t,\n-\t\t\t\t gfc_intrinsic_op op, bool noaccess)\n+\t\t\t\t gfc_intrinsic_op op, bool noaccess,\n+\t\t\t\t locus* where)\n {\n   gfc_typebound_proc* res;\n \n@@ -4625,7 +4630,7 @@ gfc_find_typebound_intrinsic_op (gfc_symbol* derived, gfc_try* t,\n     res = NULL;\n \n   /* Check access.  */\n-  if (res)\n+  if (res && !res->error)\n     {\n       /* We found one.  */\n       if (t)\n@@ -4634,8 +4639,9 @@ gfc_find_typebound_intrinsic_op (gfc_symbol* derived, gfc_try* t,\n       if (!noaccess && derived->attr.use_assoc\n \t  && res->access == ACCESS_PRIVATE)\n \t{\n-\t  gfc_error (\"'%s' of '%s' is PRIVATE at %C\",\n-\t\t     gfc_op2string (op), derived->name);\n+\t  if (where)\n+\t    gfc_error (\"'%s' of '%s' is PRIVATE at %L\",\n+\t\t       gfc_op2string (op), derived->name, where);\n \t  if (t)\n \t    *t = FAILURE;\n \t}\n@@ -4650,7 +4656,8 @@ gfc_find_typebound_intrinsic_op (gfc_symbol* derived, gfc_try* t,\n       super_type = gfc_get_derived_super_type (derived);\n       gcc_assert (super_type);\n \n-      return gfc_find_typebound_intrinsic_op (super_type, t, op, noaccess);\n+      return gfc_find_typebound_intrinsic_op (super_type, t, op,\n+\t\t\t\t\t      noaccess, where);\n     }\n \n   /* Nothing found.  */"}, {"sha": "ad8b144ae6e5de4f4d1a140f21695b016e295a14", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a44a72d23f7f6e76329ed29f144b7c6eac4feba/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a44a72d23f7f6e76329ed29f144b7c6eac4feba/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4a44a72d23f7f6e76329ed29f144b7c6eac4feba", "patch": "@@ -1,3 +1,13 @@\n+2009-08-27  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/37425\n+\t* gfortran.dg/impure_assignment_1.f90: Change expected error message.\n+\t* gfortran.dg/typebound_operator_1.f03: Remove check for not-implemented\n+\terror and fix problem with recursive assignment.\n+\t* gfortran.dg/typebound_operator_2.f03: No not-implemented check.\n+\t* gfortran.dg/typebound_operator_3.f03: New test.\n+\t* gfortran.dg/typebound_operator_4.f03: New test.\n+\n 2009-08-27  Dodji Seketeli  <dodji@redhat.com>\n \n \tPR debug/41770"}, {"sha": "6a1660c38e986e358e1a269e5f8a12eccfd9ca8f", "filename": "gcc/testsuite/gfortran.dg/impure_assignment_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a44a72d23f7f6e76329ed29f144b7c6eac4feba/gcc%2Ftestsuite%2Fgfortran.dg%2Fimpure_assignment_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a44a72d23f7f6e76329ed29f144b7c6eac4feba/gcc%2Ftestsuite%2Fgfortran.dg%2Fimpure_assignment_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fimpure_assignment_1.f90?ref=4a44a72d23f7f6e76329ed29f144b7c6eac4feba", "patch": "@@ -21,7 +21,7 @@ END MODULE M1\n PURE SUBROUTINE S2(I,J)\n      TYPE(T1), INTENT(OUT):: I\n      TYPE(T1), INTENT(IN) :: J\n-     I=J                      ! { dg-error \"must be PURE\" }\n+     I=J                      ! { dg-error \"is not PURE\" }\n END SUBROUTINE S2\n END\n ! { dg-final { cleanup-modules \"M1\" } }"}, {"sha": "25565908fdbc62a77a8cb7e6f369b2e7310afada", "filename": "gcc/testsuite/gfortran.dg/typebound_operator_1.f03", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a44a72d23f7f6e76329ed29f144b7c6eac4feba/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a44a72d23f7f6e76329ed29f144b7c6eac4feba/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_1.f03?ref=4a44a72d23f7f6e76329ed29f144b7c6eac4feba", "patch": "@@ -8,7 +8,8 @@\n MODULE m\n   IMPLICIT NONE\n \n-  TYPE t ! { dg-error \"not yet implemented\" }\n+  TYPE t\n+    LOGICAL :: x\n   CONTAINS\n     PROCEDURE, PASS :: onearg\n     PROCEDURE, PASS :: twoarg1\n@@ -41,8 +42,8 @@ END FUNCTION twoarg2\n \n   SUBROUTINE assign_proc (me, b)\n     CLASS(t), INTENT(OUT) :: me\n-    CLASS(t), INTENT(IN) :: b\n-    me = t ()\n+    LOGICAL, INTENT(IN) :: b\n+    me%x = .NOT. b\n   END SUBROUTINE assign_proc\n \n END MODULE m"}, {"sha": "71e8e4ffebfc372ff2d58e12798e19854b96e98e", "filename": "gcc/testsuite/gfortran.dg/typebound_operator_2.f03", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a44a72d23f7f6e76329ed29f144b7c6eac4feba/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a44a72d23f7f6e76329ed29f144b7c6eac4feba/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_2.f03?ref=4a44a72d23f7f6e76329ed29f144b7c6eac4feba", "patch": "@@ -8,7 +8,7 @@\n MODULE m\n   IMPLICIT NONE\n \n-  TYPE t ! { dg-error \"not yet implemented\" }\n+  TYPE t\n   CONTAINS\n     PROCEDURE, PASS :: onearg\n     PROCEDURE, PASS :: onearg_alt => onearg"}, {"sha": "9f2369a1f0701fb724c8a3ce2f1ff3c90cb9a094", "filename": "gcc/testsuite/gfortran.dg/typebound_operator_3.f03", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a44a72d23f7f6e76329ed29f144b7c6eac4feba/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a44a72d23f7f6e76329ed29f144b7c6eac4feba/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_3.f03?ref=4a44a72d23f7f6e76329ed29f144b7c6eac4feba", "patch": "@@ -0,0 +1,127 @@\n+! { dg-do run }\n+! { dg-options \"-w\" }\n+! FIXME: Remove -w when CLASS is fully implemented.\n+\n+! Type-bound procedures\n+! Check they can actually be called and run correctly.\n+! This also checks for correct module save/restore.\n+\n+! FIXME: Check that calls to inherited bindings work once CLASS allows that.\n+\n+MODULE m\n+  IMPLICIT NONE\n+\n+  TYPE mynum\n+    REAL :: num_real\n+    INTEGER :: num_int\n+  CONTAINS\n+    PROCEDURE, PASS, PRIVATE :: add_mynum ! Check that this may be PRIVATE.\n+    PROCEDURE, PASS :: add_int\n+    PROCEDURE, PASS :: add_real\n+    PROCEDURE, PASS :: assign_int\n+    PROCEDURE, PASS :: assign_real\n+    PROCEDURE, PASS(from) :: assign_to_int\n+    PROCEDURE, PASS(from) :: assign_to_real\n+    PROCEDURE, PASS :: get_all\n+\n+    GENERIC :: OPERATOR(+) => add_mynum, add_int, add_real\n+    GENERIC :: OPERATOR(.GET.) => get_all\n+    GENERIC :: ASSIGNMENT(=) => assign_int, assign_real, &\n+                                assign_to_int, assign_to_real\n+  END TYPE mynum\n+\n+CONTAINS\n+\n+  TYPE(mynum) FUNCTION add_mynum (a, b)\n+    CLASS(mynum), INTENT(IN) :: a, b\n+    add_mynum = mynum (a%num_real + b%num_real, a%num_int + b%num_int)\n+  END FUNCTION add_mynum\n+\n+  TYPE(mynum) FUNCTION add_int (a, b)\n+    CLASS(mynum), INTENT(IN) :: a\n+    INTEGER, INTENT(IN) :: b\n+    add_int = mynum (a%num_real, a%num_int + b)\n+  END FUNCTION add_int\n+\n+  TYPE(mynum) FUNCTION add_real (a, b)\n+    CLASS(mynum), INTENT(IN) :: a\n+    REAL, INTENT(IN) :: b\n+    add_real = mynum (a%num_real + b, a%num_int)\n+  END FUNCTION add_real\n+\n+  REAL FUNCTION get_all (me)\n+    CLASS(mynum), INTENT(IN) :: me\n+    get_all = me%num_real + me%num_int\n+  END FUNCTION get_all\n+\n+  SUBROUTINE assign_real (dest, from)\n+    CLASS(mynum), INTENT(INOUT) :: dest\n+    REAL, INTENT(IN) :: from\n+    dest%num_real = from\n+  END SUBROUTINE assign_real\n+\n+  SUBROUTINE assign_int (dest, from)\n+    CLASS(mynum), INTENT(INOUT) :: dest\n+    INTEGER, INTENT(IN) :: from\n+    dest%num_int = from\n+  END SUBROUTINE assign_int\n+\n+  SUBROUTINE assign_to_real (dest, from)\n+    REAL, INTENT(OUT) :: dest\n+    CLASS(mynum), INTENT(IN) :: from\n+    dest = from%num_real\n+  END SUBROUTINE assign_to_real\n+\n+  SUBROUTINE assign_to_int (dest, from)\n+    INTEGER, INTENT(OUT) :: dest\n+    CLASS(mynum), INTENT(IN) :: from\n+    dest = from%num_int\n+  END SUBROUTINE assign_to_int\n+\n+  ! Test it works basically within the module.\n+  SUBROUTINE check_in_module ()\n+    IMPLICIT NONE\n+    TYPE(mynum) :: num\n+\n+    num = mynum (1.0, 2)\n+    num = num + 7\n+    IF (num%num_real /= 1.0 .OR. num%num_int /= 9) CALL abort ()\n+  END SUBROUTINE check_in_module\n+\n+END MODULE m\n+\n+! Here we see it also works for use-associated operators loaded from a module.\n+PROGRAM main\n+  USE m, ONLY: mynum, check_in_module\n+  IMPLICIT NONE\n+\n+  TYPE(mynum) :: num1, num2, num3\n+  REAL :: real_var\n+  INTEGER :: int_var\n+\n+  CALL check_in_module ()\n+\n+  num1 = mynum (1.0, 2)\n+  num2 = mynum (2.0, 3)\n+\n+  num3 = num1 + num2\n+  IF (num3%num_real /= 3.0 .OR. num3%num_int /= 5) CALL abort ()\n+\n+  num3 = num1 + 5\n+  IF (num3%num_real /= 1.0 .OR. num3%num_int /= 7) CALL abort ()\n+\n+  num3 = num1 + (-100.5)\n+  IF (num3%num_real /= -99.5 .OR. num3%num_int /= 2) CALL abort ()\n+\n+  num3 = 42\n+  num3 = -1.2\n+  IF (num3%num_real /= -1.2 .OR. num3%num_int /= 42) CALL abort ()\n+\n+  real_var = num3\n+  int_var = num3\n+  IF (real_var /= -1.2 .OR. int_var /= 42) CALL abort ()\n+\n+  IF (.GET. num1 /= 3.0) CALL abort ()\n+END PROGRAM main\n+\n+! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "ee7c2989f6b2b619452f78d5bedc3993acf5fb4c", "filename": "gcc/testsuite/gfortran.dg/typebound_operator_4.f03", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a44a72d23f7f6e76329ed29f144b7c6eac4feba/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_4.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a44a72d23f7f6e76329ed29f144b7c6eac4feba/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_4.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_4.f03?ref=4a44a72d23f7f6e76329ed29f144b7c6eac4feba", "patch": "@@ -0,0 +1,94 @@\n+! { dg-do compile }\n+! { dg-options \"-w\" }\n+! FIXME: Remove -w when CLASS is fully implemented.\n+\n+! Type-bound procedures\n+! Check for errors with operator calls.\n+\n+MODULE m\n+  IMPLICIT NONE\n+\n+  TYPE myint\n+    INTEGER :: value\n+  CONTAINS\n+    PROCEDURE, PASS :: add_int\n+    PROCEDURE, PASS :: assign_int\n+    GENERIC, PRIVATE :: OPERATOR(.PLUS.) => add_int\n+    GENERIC, PRIVATE :: OPERATOR(+) => add_int\n+    GENERIC, PRIVATE :: ASSIGNMENT(=) => assign_int\n+  END TYPE myint\n+\n+  TYPE myreal\n+    REAL :: value\n+  CONTAINS\n+    PROCEDURE, PASS :: add_real\n+    PROCEDURE, PASS :: assign_real\n+    GENERIC :: OPERATOR(.PLUS.) => add_real\n+    GENERIC :: OPERATOR(+) => add_real\n+    GENERIC :: ASSIGNMENT(=) => assign_real\n+  END TYPE myreal\n+\n+CONTAINS\n+\n+  PURE TYPE(myint) FUNCTION add_int (a, b)\n+    CLASS(myint), INTENT(IN) :: a\n+    INTEGER, INTENT(IN) :: b\n+    add_int = myint (a%value + b)\n+  END FUNCTION add_int\n+\n+  PURE SUBROUTINE assign_int (dest, from)\n+    CLASS(myint), INTENT(OUT) :: dest\n+    INTEGER, INTENT(IN) :: from\n+    dest = myint (from)\n+  END SUBROUTINE assign_int\n+\n+  TYPE(myreal) FUNCTION add_real (a, b)\n+    CLASS(myreal), INTENT(IN) :: a\n+    REAL, INTENT(IN) :: b\n+    add_real = myreal (a%value + b)\n+  END FUNCTION add_real\n+\n+  SUBROUTINE assign_real (dest, from)\n+    CLASS(myreal), INTENT(OUT) :: dest\n+    REAL, INTENT(IN) :: from\n+    dest = myreal (from)\n+  END SUBROUTINE assign_real\n+\n+  SUBROUTINE in_module ()\n+    TYPE(myint) :: x\n+    x = 0 ! { dg-bogus \"Can't convert\" }\n+    x = x + 42 ! { dg-bogus \"Operands of\" }\n+    x = x .PLUS. 5 ! { dg-bogus \"Unknown operator\" }\n+  END SUBROUTINE in_module\n+\n+  PURE SUBROUTINE iampure ()\n+    TYPE(myint) :: x\n+\n+    x = 0 ! { dg-bogus \"is not PURE\" }\n+    x = x + 42 ! { dg-bogus \"to a non-PURE procedure\" }\n+    x = x .PLUS. 5 ! { dg-bogus \"to a non-PURE procedure\" }\n+  END SUBROUTINE iampure\n+\n+END MODULE m\n+\n+PURE SUBROUTINE iampure2 ()\n+  USE m\n+  IMPLICIT NONE\n+  TYPE(myreal) :: x\n+\n+  x = 0.0 ! { dg-error \"is not PURE\" }\n+  x = x + 42.0 ! { dg-error \"to a non-PURE procedure\" }\n+  x = x .PLUS. 5.0 ! { dg-error \"to a non-PURE procedure\" }\n+END SUBROUTINE iampure2\n+\n+PROGRAM main\n+  USE m\n+  IMPLICIT NONE\n+  TYPE(myint) :: x\n+\n+  x = 0 ! { dg-error \"Can't convert\" }\n+  x = x + 42 ! { dg-error \"Operands of\" }\n+  x = x .PLUS. 5 ! { dg-error \"Unknown operator\" }\n+END PROGRAM main\n+\n+! { dg-final { cleanup-modules \"m\" } }"}]}