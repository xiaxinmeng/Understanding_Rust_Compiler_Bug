{"sha": "c5418dcb96ee2bdffa835d6e0f3adb617abb1822", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU0MThkY2I5NmVlMmJkZmZhODM1ZDZlMGYzYWRiNjE3YWJiMTgyMg==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2006-02-24T18:16:25Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2006-02-24T18:16:25Z"}, "message": "re PR libfortran/26423 (Error on binary I/O for large array)\n\n2006-02-24  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libgfortran/26423\n\t* io/unix.c (fd_seek): Revert change from 25949.\n\t(fd_read): Same.\n\t(fd_write): Same.\n\nFrom-SVN: r111420", "tree": {"sha": "5e671113bd77714f30e86a5773c4f55f1480218f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e671113bd77714f30e86a5773c4f55f1480218f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5418dcb96ee2bdffa835d6e0f3adb617abb1822", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5418dcb96ee2bdffa835d6e0f3adb617abb1822", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5418dcb96ee2bdffa835d6e0f3adb617abb1822", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5418dcb96ee2bdffa835d6e0f3adb617abb1822/comments", "author": null, "committer": null, "parents": [{"sha": "69ca35491357cd22ed769ea202f3a7f32b9f599b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69ca35491357cd22ed769ea202f3a7f32b9f599b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69ca35491357cd22ed769ea202f3a7f32b9f599b"}], "stats": {"total": 23, "additions": 17, "deletions": 6}, "files": [{"sha": "a570af48c759a3d9c946e2dca09f48d462630f29", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5418dcb96ee2bdffa835d6e0f3adb617abb1822/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5418dcb96ee2bdffa835d6e0f3adb617abb1822/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=c5418dcb96ee2bdffa835d6e0f3adb617abb1822", "patch": "@@ -1,3 +1,10 @@\n+2006-02-24  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libgfortran/26423\n+\t* io/unix.c (fd_seek): Revert change from 25949.\n+\t(fd_read): Same.\n+\t(fd_write): Same.\n+\n 2006-02-19  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \t* io/open.c (edit_modes): Correct abusive copy-pasting."}, {"sha": "1293b24c9db5f3e1fe06f4ddb44dbece3877a348", "filename": "libgfortran/io/unix.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5418dcb96ee2bdffa835d6e0f3adb617abb1822/libgfortran%2Fio%2Funix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5418dcb96ee2bdffa835d6e0f3adb617abb1822/libgfortran%2Fio%2Funix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.c?ref=c5418dcb96ee2bdffa835d6e0f3adb617abb1822", "patch": "@@ -562,9 +562,15 @@ fd_sfree (unix_stream * s)\n static try\n fd_seek (unix_stream * s, gfc_offset offset)\n {\n-  s->logical_offset = offset;\n+  if (s->physical_offset == offset) /* Are we lucky and avoid syscall?  */\n+    {\n+      s->logical_offset = offset;\n+      return SUCCESS;\n+    }\n \n-  return SUCCESS;\n+  s->physical_offset = s->logical_offset = offset;\n+\n+  return (lseek (s->fd, offset, SEEK_SET) < 0) ? FAILURE : SUCCESS;\n }\n \n \n@@ -666,8 +672,7 @@ fd_read (unix_stream * s, void * buf, size_t * nbytes)\n       return errno;\n     }\n \n-  if (is_seekable ((stream *) s) && s->physical_offset != s->logical_offset \n-      && lseek (s->fd, s->logical_offset, SEEK_SET) < 0)\n+  if (is_seekable ((stream *) s) && fd_seek (s, s->logical_offset) == FAILURE)\n     {\n       *nbytes = 0;\n       return errno;\n@@ -715,8 +720,7 @@ fd_write (unix_stream * s, const void * buf, size_t * nbytes)\n       return errno;\n     }\n \n-  if (is_seekable ((stream *) s) && s->physical_offset != s->logical_offset\n-      && lseek (s->fd, s->logical_offset, SEEK_SET) < 0)\n+  if (is_seekable ((stream *) s) && fd_seek (s, s->logical_offset) == FAILURE)\n     {\n       *nbytes = 0;\n       return errno;"}]}