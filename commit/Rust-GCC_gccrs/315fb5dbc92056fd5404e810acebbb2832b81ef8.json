{"sha": "315fb5dbc92056fd5404e810acebbb2832b81ef8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE1ZmI1ZGJjOTIwNTZmZDU0MDRlODEwYWNlYmJiMjgzMmI4MWVmOA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-08-30T16:03:48Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-08-30T16:03:48Z"}, "message": "name-lookup.c (pop_binding, [...]): Replace abort with gcc_assert or gcc_unreachable.\n\n\t* name-lookup.c (pop_binding, pushdecl,\n\tset_identifier_type_value_with_scope, push_overloaded_decl,\n\targ_assoc_type): Replace abort with gcc_assert or gcc_unreachable.\n\t* parser.c (cp_parser_diagnose_invalid_type_name,\n\tcp_parser_postfix_expression, cp_parser_unary_expression,\n\tcp_parser_check_declarator_template_para): Likewise.\n\t* pt.c (push_inline_template_parms_recursive,\n\tcheck_explicit_specialization, convert_nontype_argument,\n\tcoerce_template_template_parms, uses_template_parms,\n\tinstantiate_class_template, tsubst_decl, tsubst, tsubst_copy,\n\ttsubst_expr, instantiate_template,\n\tmaybe_adjust_types_for_deduction, type_unification_real,\n\tresolve_overloaded_unification, template_decl_level,\n\ttype_dependent_expression_p): Likewise.\n\t* search.c (lookup_base_r): Likewise.\n\t* semantics.c (finish_stmt_expr, simplify_aggr_init_expr): Likewise.\n\t* tree.c (lvalue_p_1, count_functions, cxx_printable_name,\n\tverify_stmt_tree_r, get_type_decl, stabilize_call): Likewise.\n\t* typeck.c (common_type, get_member_function_from_ptrfunc,\n\tbuild_binary_op, build_unary_op, expand_ptrmemfunc_cst): Likewise.\n\t* typeck2.c (cxx_incomplete_type_diagnostic,\n\tsplit_nonconstant_init_1, store_init_value,\n\tprocess_init_constructor): Likewise.\n\nFrom-SVN: r86782", "tree": {"sha": "5bef1416b58d33002abdc3fef59a0c970f5aaccc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bef1416b58d33002abdc3fef59a0c970f5aaccc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/315fb5dbc92056fd5404e810acebbb2832b81ef8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/315fb5dbc92056fd5404e810acebbb2832b81ef8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/315fb5dbc92056fd5404e810acebbb2832b81ef8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/315fb5dbc92056fd5404e810acebbb2832b81ef8/comments", "author": null, "committer": null, "parents": [{"sha": "e044819338009d646f06a398aba9a3ec920fecc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e044819338009d646f06a398aba9a3ec920fecc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e044819338009d646f06a398aba9a3ec920fecc7"}], "stats": {"total": 357, "additions": 175, "deletions": 182}, "files": [{"sha": "c589b3418a70a9b57ae52404b36c2a9848bedf55", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315fb5dbc92056fd5404e810acebbb2832b81ef8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315fb5dbc92056fd5404e810acebbb2832b81ef8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=315fb5dbc92056fd5404e810acebbb2832b81ef8", "patch": "@@ -1,3 +1,29 @@\n+2004-08-30  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* name-lookup.c (pop_binding, pushdecl,\n+\tset_identifier_type_value_with_scope, push_overloaded_decl,\n+\targ_assoc_type): Replace abort with gcc_assert or gcc_unreachable.\n+\t* parser.c (cp_parser_diagnose_invalid_type_name,\n+\tcp_parser_postfix_expression, cp_parser_unary_expression,\n+\tcp_parser_check_declarator_template_para): Likewise.\n+\t* pt.c (push_inline_template_parms_recursive,\n+\tcheck_explicit_specialization, convert_nontype_argument,\n+\tcoerce_template_template_parms, uses_template_parms,\n+\tinstantiate_class_template, tsubst_decl, tsubst, tsubst_copy,\n+\ttsubst_expr, instantiate_template,\n+\tmaybe_adjust_types_for_deduction, type_unification_real,\n+\tresolve_overloaded_unification, template_decl_level,\n+\ttype_dependent_expression_p): Likewise.\n+\t* search.c (lookup_base_r): Likewise.\n+\t* semantics.c (finish_stmt_expr, simplify_aggr_init_expr): Likewise.\n+\t* tree.c (lvalue_p_1, count_functions, cxx_printable_name,\n+\tverify_stmt_tree_r, get_type_decl, stabilize_call): Likewise.\n+\t* typeck.c (common_type, get_member_function_from_ptrfunc,\n+\tbuild_binary_op, build_unary_op, expand_ptrmemfunc_cst): Likewise.\n+\t* typeck2.c (cxx_incomplete_type_diagnostic,\n+\tsplit_nonconstant_init_1, store_init_value,\n+\tprocess_init_constructor): Likewise.\n+\n 2004-08-30  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* call.c (check_dtor_name): Replace abort with gcc_assert or"}, {"sha": "5ca98a9a8ff28b46130017868b6d5c828557def2", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315fb5dbc92056fd5404e810acebbb2832b81ef8/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315fb5dbc92056fd5404e810acebbb2832b81ef8/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=315fb5dbc92056fd5404e810acebbb2832b81ef8", "patch": "@@ -457,10 +457,11 @@ pop_binding (tree id, tree decl)\n      binding for this identifier.  Remove that binding.  */\n   if (binding->value == decl)\n     binding->value = NULL_TREE;\n-  else if (binding->type == decl)\n-    binding->type = NULL_TREE;\n   else\n-    abort ();\n+    {\n+      gcc_assert (binding->type == decl);\n+      binding->type = NULL_TREE;\n+    }\n \n   if (!binding->value && !binding->type)\n     {\n@@ -745,10 +746,7 @@ pushdecl (tree x)\n \t    }\n \t  else if (TREE_CODE (t) == PARM_DECL)\n \t    {\n-\t      if (DECL_CONTEXT (t) == NULL_TREE)\n-\t\t/* This is probably caused by too many errors, but calling\n-\t\t   abort will say that if errors have occurred.  */\n-\t\tabort ();\n+\t      gcc_assert (DECL_CONTEXT (t));\n \n \t      /* Check for duplicate params.  */\n \t      if (duplicate_decls (x, t))\n@@ -1759,15 +1757,12 @@ set_identifier_type_value_with_scope (tree id, tree decl, cxx_scope *b)\n     {\n       cxx_binding *binding =\n \tbinding_for_name (NAMESPACE_LEVEL (current_namespace), id);\n-      if (decl)\n-\t{\n-\t  if (binding->value)\n-\t    supplement_binding (binding, decl);\n-\t  else\n-\t    binding->value = decl;\n-\t}\n+      gcc_assert (decl);\n+      if (binding->value)\n+\tsupplement_binding (binding, decl);\n       else\n-\tabort ();\n+\tbinding->value = decl;\n+      \n       /* Store marker instead of real type.  */\n       type = global_type_node;\n     }\n@@ -2098,7 +2093,7 @@ push_overloaded_decl (tree decl, int flags)\n \t      }\n \n \t  /* We should always find a previous binding in this case.  */\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       /* Install the new binding.  */\n@@ -4476,11 +4471,10 @@ arg_assoc_type (struct arg_lookup *k, tree type)\n     case TYPENAME_TYPE:\n       return false;\n     case LANG_TYPE:\n-      if (type == unknown_type_node)\n-\treturn false;\n-      /* else fall through */\n+      gcc_assert (type == unknown_type_node);\n+      return false;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   return false;\n }"}, {"sha": "b0064420f192f88f812793330462072a7db0272a", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315fb5dbc92056fd5404e810acebbb2832b81ef8/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315fb5dbc92056fd5404e810acebbb2832b81ef8/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=315fb5dbc92056fd5404e810acebbb2832b81ef8", "patch": "@@ -2230,7 +2230,7 @@ cp_parser_diagnose_invalid_type_name (cp_parser *parser, tree scope, tree id)\n \terror (\"`%E' in class `%T' does not name a type\",\n \t       id, parser->scope);\n       else\n-\tabort();\n+\tgcc_unreachable ();\n     }\n }\n \n@@ -3806,7 +3806,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t      = build_const_cast (type, expression);\n \t    break;\n \t  default:\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t  }\n       }\n       break;\n@@ -4177,7 +4177,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n     }\n \n   /* We should never get here.  */\n-  abort ();\n+  gcc_unreachable ();\n   return error_mark_node;\n }\n \n@@ -4741,7 +4741,7 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       if (non_constant_p\n@@ -14460,9 +14460,9 @@ cp_parser_check_declarator_template_parameters (cp_parser* parser,\n       return true;\n \n     default:\n-      abort ();\n-      return false;\n+      gcc_unreachable ();\n     }\n+  return false;\n }\n \n /* NUM_TEMPLATES were used in the current declaration.  If that is"}, {"sha": "d7335a06e6b69a248b2da03dbf7d31814ba19aab", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 85, "deletions": 93, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315fb5dbc92056fd5404e810acebbb2832b81ef8/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315fb5dbc92056fd5404e810acebbb2832b81ef8/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=315fb5dbc92056fd5404e810acebbb2832b81ef8", "patch": "@@ -384,7 +384,7 @@ push_inline_template_parms_recursive (tree parmlist, int levels)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n }\n@@ -1759,7 +1759,7 @@ check_explicit_specialization (tree declarator,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (specialization || member_specialization)\n@@ -3597,8 +3597,7 @@ convert_nontype_argument (tree type, tree expr)\n \n     default:\n       /* All non-type parameters must have one of these types.  */\n-      abort ();\n-      break;\n+      gcc_unreachable ();\n     }\n \n   return error_mark_node;\n@@ -3690,7 +3689,7 @@ coerce_template_template_parms (tree parm_parms,\n \t  break;\n \t  \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n   return 1;\n@@ -4890,10 +4889,12 @@ uses_template_parms (tree t)\n \t   || TREE_CODE_CLASS (TREE_CODE (t)) == 'c')\n     dependent_p = (type_dependent_expression_p (t)\n \t\t   || value_dependent_expression_p (t));\n-  else if (t == error_mark_node)\n-    dependent_p = false;\n-  else \n-    abort ();\n+  else\n+    {\n+      gcc_assert (t == error_mark_node);\n+      dependent_p = false;\n+    }\n+  \n   processing_template_decl = saved_processing_template_decl;\n \n   return dependent_p;\n@@ -5470,16 +5471,13 @@ instantiate_class_template (tree type)\n \n   pbinfo = TYPE_BINFO (pattern);\n \n-#ifdef ENABLE_CHECKING\n-  if (DECL_CLASS_SCOPE_P (TYPE_MAIN_DECL (pattern))\n-      && ! COMPLETE_TYPE_P (TYPE_CONTEXT (type))\n-      && ! TYPE_BEING_DEFINED (TYPE_CONTEXT (type)))\n-    /* We should never instantiate a nested class before its enclosing\n-       class; we need to look up the nested class by name before we can\n-       instantiate it, and that lookup should instantiate the enclosing\n-       class.  */\n-    abort ();\n-#endif\n+  /* We should never instantiate a nested class before its enclosing\n+     class; we need to look up the nested class by name before we can\n+     instantiate it, and that lookup should instantiate the enclosing\n+     class.  */\n+  gcc_assert (!DECL_CLASS_SCOPE_P (TYPE_MAIN_DECL (pattern))\n+\t      || COMPLETE_TYPE_P (TYPE_CONTEXT (type))\n+\t      || TYPE_BEING_DEFINED (TYPE_CONTEXT (type)));\n \n   base_list = NULL_TREE;\n   if (BINFO_N_BASE_BINFOS (pbinfo))\n@@ -6535,7 +6533,7 @@ tsubst_decl (tree t, tree args, tree type, tsubst_flags_t complain)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     } \n \n   /* Restore the file and line information.  */\n@@ -6813,9 +6811,11 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \tint idx;\n \tint level;\n \tint levels;\n+\ttree arg = NULL_TREE;\n \n \tr = NULL_TREE;\n \n+\tgcc_assert (TREE_VEC_LENGTH (args) > 0);\n \tif (TREE_CODE (t) == TEMPLATE_TYPE_PARM\n \t    || TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM\n \t    || TREE_CODE (t) == BOUND_TEMPLATE_TEMPLATE_PARM)\n@@ -6829,57 +6829,50 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t    level = TEMPLATE_PARM_LEVEL (t);\n \t  }\n \n-\tif (TREE_VEC_LENGTH (args) > 0)\n-\t  {\n-\t    tree arg = NULL_TREE;\n+\tlevels = TMPL_ARGS_DEPTH (args);\n+\tif (level <= levels)\n+\t  arg = TMPL_ARG (args, level, idx);\n \n-\t    levels = TMPL_ARGS_DEPTH (args);\n-\t    if (level <= levels)\n-\t      arg = TMPL_ARG (args, level, idx);\n-\n-\t    if (arg == error_mark_node)\n-\t      return error_mark_node;\n-\t    else if (arg != NULL_TREE)\n+\tif (arg == error_mark_node)\n+\t  return error_mark_node;\n+\telse if (arg != NULL_TREE)\n+\t  {\n+\t    if (TREE_CODE (t) == TEMPLATE_TYPE_PARM)\n \t      {\n-\t\tif (TREE_CODE (t) == TEMPLATE_TYPE_PARM)\n-\t\t  {\n-\t\t    gcc_assert (TYPE_P (arg));\n-\t\t    return cp_build_qualified_type_real\n-\t\t      (arg, cp_type_quals (arg) | cp_type_quals (t),\n-\t\t       complain | tf_ignore_bad_quals);\n-\t\t  }\n-\t\telse if (TREE_CODE (t) == BOUND_TEMPLATE_TEMPLATE_PARM)\n-\t\t  {\n-\t\t    /* We are processing a type constructed from\n-\t\t       a template template parameter.  */\n-\t\t    tree argvec = tsubst (TYPE_TI_ARGS (t),\n-\t\t\t\t\t  args, complain, in_decl);\n-\t\t    if (argvec == error_mark_node)\n-\t\t      return error_mark_node;\n+\t\tgcc_assert (TYPE_P (arg));\n+\t\treturn cp_build_qualified_type_real\n+\t\t  (arg, cp_type_quals (arg) | cp_type_quals (t),\n+\t\t   complain | tf_ignore_bad_quals);\n+\t      }\n+\t    else if (TREE_CODE (t) == BOUND_TEMPLATE_TEMPLATE_PARM)\n+\t      {\n+\t\t/* We are processing a type constructed from a\n+\t\t   template template parameter.  */\n+\t\ttree argvec = tsubst (TYPE_TI_ARGS (t),\n+\t\t\t\t      args, complain, in_decl);\n+\t\tif (argvec == error_mark_node)\n+\t\t  return error_mark_node;\n \t\t\t\n-\t\t    /* We can get a TEMPLATE_TEMPLATE_PARM here when \n-\t\t       we are resolving nested-types in the signature of \n-\t\t       a member function templates.\n-\t\t       Otherwise ARG is a TEMPLATE_DECL and is the real \n-\t\t       template to be instantiated.  */\n-\t\t    if (TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM)\n-\t\t      arg = TYPE_NAME (arg);\n-\n-\t\t    r = lookup_template_class (arg, \n-\t\t\t\t\t       argvec, in_decl, \n-\t\t\t\t\t       DECL_CONTEXT (arg),\n-\t\t\t\t\t       /*entering_scope=*/0,\n-\t                                       complain);\n-\t\t    return cp_build_qualified_type_real\n-\t\t      (r, TYPE_QUALS (t), complain);\n-\t\t  }\n-\t\telse\n-\t\t  /* TEMPLATE_TEMPLATE_PARM or TEMPLATE_PARM_INDEX.  */\n-\t\t  return arg;\n+\t\t/* We can get a TEMPLATE_TEMPLATE_PARM here when we\n+\t\t   are resolving nested-types in the signature of a\n+\t\t   member function templates.  Otherwise ARG is a\n+\t\t   TEMPLATE_DECL and is the real template to be\n+\t\t   instantiated.  */\n+\t\tif (TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM)\n+\t\t  arg = TYPE_NAME (arg);\n+\t\t\n+\t\tr = lookup_template_class (arg, \n+\t\t\t\t\t   argvec, in_decl, \n+\t\t\t\t\t   DECL_CONTEXT (arg),\n+\t\t\t\t\t    /*entering_scope=*/0,\n+\t\t\t\t\t   complain);\n+\t\treturn cp_build_qualified_type_real\n+\t\t  (r, TYPE_QUALS (t), complain);\n \t      }\n+\t    else\n+\t      /* TEMPLATE_TEMPLATE_PARM or TEMPLATE_PARM_INDEX.  */\n+\t      return arg;\n \t  }\n-\telse\n-\t  abort ();\n \n \tif (level == 1)\n \t  /* This can happen during the attempted tsubst'ing in\n@@ -6932,7 +6925,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t    break;\n \t   \n \t  default:\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t  }\n \n \treturn r;\n@@ -6975,7 +6968,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       \n     case TREE_BINFO:\n       /* We should never be tsubsting a binfo.  */\n-      abort ();\n+      gcc_unreachable ();\n \n     case TREE_VEC:\n       /* A vector of template arguments.  */\n@@ -7251,7 +7244,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     case INDIRECT_REF:\n     case ADDR_EXPR:\n     case CALL_EXPR:\n-      abort ();\n+      gcc_unreachable ();\n \n     case ARRAY_REF:\n       {\n@@ -7501,7 +7494,7 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t  /* We didn't find the name.  That should never happen; if\n \t     name-lookup found it during preliminary parsing, we\n \t     should find it again here during instantiation.  */\n-\tabort ();\n+\tgcc_unreachable ();\n       }\n       return t;\n \n@@ -7786,7 +7779,7 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       /* We shouldn't have built any of these during initial template\n \t generation.  Instead, they should be built during instantiation\n \t in response to the saved STMT_IS_FULL_EXPR_P setting.  */\n-      abort ();\n+      gcc_unreachable ();\n \n     default:\n       return t;\n@@ -8098,10 +8091,10 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       return fold_offsetof (t);\n \n     default:\n-      if (!STATEMENT_CODE_P (TREE_CODE (t)))\n-\treturn tsubst_copy_and_build (t, args, complain, in_decl,\n-\t\t\t\t      /*function_p=*/false);\n-      abort ();\n+      gcc_assert (!STATEMENT_CODE_P (TREE_CODE (t)));\n+      \n+      return tsubst_copy_and_build (t, args, complain, in_decl,\n+\t\t\t\t    /*function_p=*/false);\n     }\n \n   return NULL_TREE;\n@@ -8734,7 +8727,7 @@ instantiate_template (tree tmpl, tree targ_ptr, tsubst_flags_t complain)\n \tif (DECL_NAME (clone) == DECL_NAME (tmpl))\n \t  return clone;\n       /* We should always have found the clone by now.  */\n-      abort ();\n+      gcc_unreachable ();\n       return NULL_TREE;\n     }\n   \n@@ -8996,7 +8989,7 @@ maybe_adjust_types_for_deduction (unification_kind_t strict,\n         }\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (TREE_CODE (*parm) != REFERENCE_TYPE)\n@@ -9095,7 +9088,7 @@ type_unification_real (tree tparms,\n       break;\n       \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (xlen == 0)\n@@ -9283,16 +9276,16 @@ resolve_overloaded_unification (tree tparms,\n \t    }\n \t}\n     }\n-  else if (TREE_CODE (arg) == OVERLOAD\n-\t   || TREE_CODE (arg) == FUNCTION_DECL)\n+  else\n     {\n+      gcc_assert (TREE_CODE (arg) == OVERLOAD\n+\t\t  || TREE_CODE (arg) == FUNCTION_DECL);\n+  \n       for (; arg; arg = OVL_NEXT (arg))\n \tgood += try_one_overload (tparms, targs, tempargs, parm,\n \t\t\t\t  TREE_TYPE (OVL_CURRENT (arg)),\n \t\t\t\t  strict, sub_strict, addr_p);\n     }\n-  else\n-    abort ();\n \n   /* [temp.deduct.type] A template-argument can be deduced from a pointer\n      to function or pointer to member function argument if the set of\n@@ -9593,9 +9586,9 @@ template_decl_level (tree decl)\n       return TEMPLATE_PARM_LEVEL (DECL_INITIAL (decl));\n \n     default:\n-      abort ();\n-      return 0;\n+      gcc_unreachable ();\n     }\n+  return 0;\n }\n \n /* Decide whether ARG can be unified with PARM, considering only the\n@@ -11959,24 +11952,23 @@ type_dependent_expression_p (tree expression)\n       \n       if (TREE_CODE (expression) == BASELINK)\n \texpression = BASELINK_FUNCTIONS (expression);\n+      \n       if (TREE_CODE (expression) == TEMPLATE_ID_EXPR)\n \t{\n \t  if (any_dependent_template_arguments_p\n \t      (TREE_OPERAND (expression, 1)))\n \t    return true;\n \t  expression = TREE_OPERAND (expression, 0);\n \t}\n-      if (TREE_CODE (expression) == OVERLOAD)\n+      gcc_assert (TREE_CODE (expression) == OVERLOAD);\n+      \n+      while (expression)\n \t{\n-\t  while (expression)\n-\t    {\n-\t      if (type_dependent_expression_p (OVL_CURRENT (expression)))\n-\t\treturn true;\n-\t      expression = OVL_NEXT (expression);\n-\t    }\n-\t  return false;\n+\t  if (type_dependent_expression_p (OVL_CURRENT (expression)))\n+\t    return true;\n+\t  expression = OVL_NEXT (expression);\n \t}\n-      abort ();\n+      return false;\n     }\n   \n   return (dependent_type_p (TREE_TYPE (expression)));"}, {"sha": "d2b29f8977be9f0f33e984ae060f2e541404709d", "filename": "gcc/cp/search.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315fb5dbc92056fd5404e810acebbb2832b81ef8/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315fb5dbc92056fd5404e810acebbb2832b81ef8/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=315fb5dbc92056fd5404e810acebbb2832b81ef8", "patch": "@@ -161,7 +161,7 @@ lookup_base_r (tree binfo, tree base, base_access access,\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n   return found;"}, {"sha": "cadb5a7e0381cfcc0535bde2f16b7f0cbc71cd2d", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315fb5dbc92056fd5404e810acebbb2832b81ef8/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315fb5dbc92056fd5404e810acebbb2832b81ef8/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=315fb5dbc92056fd5404e810acebbb2832b81ef8", "patch": "@@ -1563,7 +1563,7 @@ finish_stmt_expr (tree stmt_expr, bool has_no_scope)\n \t      result_stmt_p = &TREE_OPERAND (t, 0);\n \t      break;\n \t    default:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t    }\n \t}\n       type = TREE_TYPE (EXPR_STMT_EXPR (result_stmt));\n@@ -1601,10 +1601,8 @@ finish_stmt_expr (tree stmt_expr, bool has_no_scope)\n \t     returning a value directly, give it the appropriate type.  */\n \t  if (VOID_TYPE_P (TREE_TYPE (result)))\n \t    TREE_TYPE (result) = type;\n-\t  else if (same_type_p (TREE_TYPE (result), type))\n-\t    ;\n \t  else\n-\t    abort ();\n+\t    gcc_assert (same_type_p (TREE_TYPE (result), type));\n \t}\n       else if (TREE_CODE (result) == STATEMENT_LIST)\n \t/* We need to wrap a STATEMENT_LIST in a BIND_EXPR so it can have a\n@@ -2771,12 +2769,11 @@ simplify_aggr_init_expr (tree *tp)\n   else if (1)\n     style = pcc;\n #endif\n-  else if (TREE_ADDRESSABLE (type))\n-    style = arg;\n   else\n-    /* We shouldn't build an AGGR_INIT_EXPR if we don't need any special\n-       handling.  See build_cplus_new.  */\n-    abort ();\n+    {\n+      gcc_assert (TREE_ADDRESSABLE (type));\n+      style = arg;\n+    }\n \n   if (style == ctor || style == arg)\n     {\n@@ -2793,11 +2790,9 @@ simplify_aggr_init_expr (tree *tp)\n \t{\n \t  /* The return type might have different cv-quals from the slot.  */\n \t  tree fntype = TREE_TYPE (TREE_TYPE (fn));\n-#ifdef ENABLE_CHECKING\n-\t  if (TREE_CODE (fntype) != FUNCTION_TYPE\n-\t      && TREE_CODE (fntype) != METHOD_TYPE)\n-\t    abort ();\n-#endif\n+\t  \n+\t  gcc_assert (TREE_CODE (fntype) == FUNCTION_TYPE\n+\t\t      || TREE_CODE (fntype) == METHOD_TYPE);\n \t  addr = convert (build_pointer_type (TREE_TYPE (fntype)), addr);\n \t}\n "}, {"sha": "2038b058aca36e6e711c160c9fb6dbc1b56fe99c", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315fb5dbc92056fd5404e810acebbb2832b81ef8/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315fb5dbc92056fd5404e810acebbb2832b81ef8/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=315fb5dbc92056fd5404e810acebbb2832b81ef8", "patch": "@@ -126,7 +126,7 @@ lvalue_p_1 (tree ref,\n \n       /* A currently unresolved scope ref.  */\n     case SCOPE_REF:\n-      abort ();\n+      gcc_unreachable ();\n     case MAX_EXPR:\n     case MIN_EXPR:\n       op1_lvalue_kind = lvalue_p_1 (TREE_OPERAND (ref, 0),\n@@ -796,17 +796,14 @@ int\n count_functions (tree t)\n {\n   int i;\n+  \n   if (TREE_CODE (t) == FUNCTION_DECL)\n     return 1;\n-  else if (TREE_CODE (t) == OVERLOAD)\n-    {\n-      for (i = 0; t; t = OVL_CHAIN (t))\n-\ti++;\n-      return i;\n-    }\n-\n-  abort ();\n-  return 0;\n+  gcc_assert (TREE_CODE (t) == OVERLOAD);\n+  \n+  for (i = 0; t; t = OVL_CHAIN (t))\n+    i++;\n+  return i;\n }\n \n int\n@@ -915,8 +912,7 @@ cxx_printable_name (tree decl, int v)\n \tring_counter += 1;\n       if (ring_counter == PRINT_RING_SIZE)\n \tring_counter = 0;\n-      if (decl_ring[ring_counter] == current_function_decl)\n-\tabort ();\n+      gcc_assert (decl_ring[ring_counter] != current_function_decl);\n     }\n \n   if (print_ring[ring_counter])\n@@ -1016,8 +1012,7 @@ verify_stmt_tree_r (tree* tp,\n \n   /* If this statement is already present in the hash table, then\n      there is a circularity in the statement tree.  */\n-  if (htab_find (*statements, t))\n-    abort ();\n+  gcc_assert (!htab_find (*statements, t));\n \n   slot = htab_find_slot (*statements, t, INSERT);\n   *slot = t;\n@@ -1371,13 +1366,8 @@ get_type_decl (tree t)\n     return t;\n   if (TYPE_P (t))\n     return TYPE_STUB_DECL (t);\n-  if (t == error_mark_node)\n-    return t;\n-\n-  abort ();\n-\n-  /* Stop compiler from complaining control reaches end of non-void function.  */\n-  return 0;\n+  gcc_assert (t == error_mark_node);\n+  return t;\n }\n \n /* Returns the namespace that contains DECL, whether directly or\n@@ -2279,9 +2269,8 @@ stabilize_call (tree call, tree *initp)\n   if (call == error_mark_node)\n     return;\n \n-  if (TREE_CODE (call) != CALL_EXPR\n-      && TREE_CODE (call) != AGGR_INIT_EXPR)\n-    abort ();\n+  gcc_assert (TREE_CODE (call) == CALL_EXPR\n+\t      || TREE_CODE (call) == AGGR_INIT_EXPR);\n \n   for (t = TREE_OPERAND (call, 1); t; t = TREE_CHAIN (t))\n     if (TREE_SIDE_EFFECTS (TREE_VALUE (t)))"}, {"sha": "3ec1e427582b9711ee2f42711d375e6ddf6369b3", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315fb5dbc92056fd5404e810acebbb2832b81ef8/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315fb5dbc92056fd5404e810acebbb2832b81ef8/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=315fb5dbc92056fd5404e810acebbb2832b81ef8", "patch": "@@ -753,7 +753,7 @@ common_type (tree t1, tree t2)\n     return composite_pointer_type (t1, t2, error_mark_node, error_mark_node,\n \t\t\t\t   \"conversion\");\n   else\n-    abort ();\n+    gcc_unreachable ();\n }\n \f\n /* Compare two exception specifier types for exactness or subsetness, if\n@@ -2353,7 +2353,7 @@ get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       /* Convert down to the right base before using the instance.  First\n@@ -3081,11 +3081,16 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t    return e;\n \t  return cp_build_binary_op (EQ_EXPR, e, integer_zero_node);\n \t}\n-      else if ((TYPE_PTRMEMFUNC_P (type0)\n-\t\t&& same_type_p (TYPE_PTRMEMFUNC_FN_TYPE (type0), type1))\n-\t       || (TYPE_PTRMEMFUNC_P (type1)\n-\t\t   && same_type_p (TYPE_PTRMEMFUNC_FN_TYPE (type1), type0)))\n-\tabort ();\n+      else\n+\t{\n+\t  gcc_assert (!TYPE_PTRMEMFUNC_P (type0)\n+\t\t      || !same_type_p (TYPE_PTRMEMFUNC_FN_TYPE (type0),\n+\t\t\t\t       type1));\n+\t  gcc_assert (!TYPE_PTRMEMFUNC_P (type1)\n+\t\t      || !same_type_p (TYPE_PTRMEMFUNC_FN_TYPE (type1),\n+\t\t\t\t       type0));\n+\t}\n+      \n       break;\n \n     case MAX_EXPR:\n@@ -3975,14 +3980,8 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t address of a function is a no-op, so just return the\n \t argument.  */\n \n-      if (TREE_CODE (arg) == IDENTIFIER_NODE\n-\t  && IDENTIFIER_OPNAME_P (arg))\n-\t{\n-\t  abort ();\n-\t  /* We don't know the type yet, so just work around the problem.\n-\t     We know that this will resolve to an lvalue.  */\n-\t  return build1 (ADDR_EXPR, unknown_type_node, arg);\n-\t}\n+      gcc_assert (TREE_CODE (arg) != IDENTIFIER_NODE\n+\t\t  || !IDENTIFIER_OPNAME_P (arg));\n \n       if (TREE_CODE (arg) == COMPONENT_REF && type_unknown_p (arg)\n \t  && !really_overloaded_fn (TREE_OPERAND (arg, 1)))\n@@ -5540,7 +5539,7 @@ expand_ptrmemfunc_cst (tree cst, tree *delta, tree *pfn)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       *pfn = fold (build1 (NOP_EXPR, TYPE_PTRMEMFUNC_FN_TYPE (type),"}, {"sha": "8d776915e84a17c6b46512b827ad0c885bf74833", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/315fb5dbc92056fd5404e810acebbb2832b81ef8/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/315fb5dbc92056fd5404e810acebbb2832b81ef8/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=315fb5dbc92056fd5404e810acebbb2832b81ef8", "patch": "@@ -373,7 +373,7 @@ cxx_incomplete_type_diagnostic (tree value, tree type, int diag_type)\n       (*p_msg_at) (\"`%D' has incomplete type\", value);\n       decl = 1;\n     }\n-retry:\n+ retry:\n   /* We must print an error message.  Be clever about what it says.  */\n \n   switch (TREE_CODE (type))\n@@ -423,7 +423,7 @@ cxx_incomplete_type_diagnostic (tree value, tree type, int diag_type)\n       break;\n     \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -509,7 +509,7 @@ split_nonconstant_init_1 (tree dest, tree init)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -568,9 +568,8 @@ store_init_value (tree decl, tree init)\n \n   if (IS_AGGR_TYPE (type))\n     {\n-      if (! TYPE_HAS_TRIVIAL_INIT_REF (type)\n-\t  && TREE_CODE (init) != CONSTRUCTOR)\n-\tabort ();\n+      gcc_assert (TYPE_HAS_TRIVIAL_INIT_REF (type)\n+\t\t  || TREE_CODE (init) == CONSTRUCTOR);\n \n       if (TREE_CODE (init) == TREE_LIST)\n \t{\n@@ -1107,8 +1106,7 @@ process_init_constructor (tree type, tree init, tree* elts)\n \n \t  next1 = digest_init (TREE_TYPE (field),\n \t\t\t       TREE_VALUE (tail), &tail1);\n-\t  if (tail1 != 0 && TREE_CODE (tail1) != TREE_LIST)\n-\t    abort ();\n+\t  gcc_assert (!tail1 || TREE_CODE (tail1) == TREE_LIST);\n \t  tail = tail1;\n \t}\n       else"}]}