{"sha": "da92057001929e2c650454e11d828d4296217e3d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE5MjA1NzAwMTkyOWUyYzY1MDQ1NGUxMWQ4MjhkNDI5NjIxN2UzZA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zackw@panix.com", "date": "2001-08-22T00:33:33Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2001-08-22T00:33:33Z"}, "message": "expmed.c (mode_for_extraction): New function.\n\n\t* expmed.c (mode_for_extraction): New function.\n\t(store_bit_field, extract_bit_field): Use it.\n\t* expr.h: Prototype it and provide an enum for its first argument.\n\n\t* combine.c, function.c, recog.c: Don't include insn-codes.h.\n\tUse mode_for_extraction rather than testing HAVE_insv/extv/extzv\n\tand digging through the insn_data tables.\n\t* Makefile.in: Update dependencies.\n\nFrom-SVN: r45086", "tree": {"sha": "129eec34d330cb3fc70326b18b8ff46f6e80e5e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/129eec34d330cb3fc70326b18b8ff46f6e80e5e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da92057001929e2c650454e11d828d4296217e3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da92057001929e2c650454e11d828d4296217e3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da92057001929e2c650454e11d828d4296217e3d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da92057001929e2c650454e11d828d4296217e3d/comments", "author": {"login": "zackw", "id": 325899, "node_id": "MDQ6VXNlcjMyNTg5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/325899?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zackw", "html_url": "https://github.com/zackw", "followers_url": "https://api.github.com/users/zackw/followers", "following_url": "https://api.github.com/users/zackw/following{/other_user}", "gists_url": "https://api.github.com/users/zackw/gists{/gist_id}", "starred_url": "https://api.github.com/users/zackw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zackw/subscriptions", "organizations_url": "https://api.github.com/users/zackw/orgs", "repos_url": "https://api.github.com/users/zackw/repos", "events_url": "https://api.github.com/users/zackw/events{/privacy}", "received_events_url": "https://api.github.com/users/zackw/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d8693c6fa425fecaf6570114f1cd69aaf3c08043", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8693c6fa425fecaf6570114f1cd69aaf3c08043", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8693c6fa425fecaf6570114f1cd69aaf3c08043"}], "stats": {"total": 261, "additions": 138, "deletions": 123}, "files": [{"sha": "f07bea4c9fc6cf31c94252ce9654da7844de7ce8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da92057001929e2c650454e11d828d4296217e3d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da92057001929e2c650454e11d828d4296217e3d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=da92057001929e2c650454e11d828d4296217e3d", "patch": "@@ -1,3 +1,14 @@\n+2001-08-21  Zack Weinberg  <zackw@panix.com>\n+\n+\t* expmed.c (mode_for_extraction): New function.\n+\t(store_bit_field, extract_bit_field): Use it.\n+\t* expr.h: Prototype it and provide an enum for its first argument.\n+\n+\t* combine.c, function.c, recog.c: Don't include insn-codes.h.\n+\tUse mode_for_extraction rather than testing HAVE_insv/extv/extzv\n+\tand digging through the insn_data tables.\n+\t* Makefile.in: Update dependencies.\n+\n 2001-08-22  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* cppfiles.c (stack_include_file): line-map.c now handles include"}, {"sha": "22861cc04c6f18baae97d087a00490f90576952b", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da92057001929e2c650454e11d828d4296217e3d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da92057001929e2c650454e11d828d4296217e3d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=da92057001929e2c650454e11d828d4296217e3d", "patch": "@@ -1380,7 +1380,7 @@ varasm.o : varasm.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) flags.h \\\n    output.h c-pragma.h toplev.h xcoffout.h debug.h $(GGC_H) $(TM_P_H) \\\n    $(HASHTAB_H) $(TARGET_H)\n function.o : function.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n-   function.h insn-codes.h $(EXPR_H) libfuncs.h $(REGS_H) hard-reg-set.h \\\n+   function.h $(EXPR_H) libfuncs.h $(REGS_H) hard-reg-set.h \\\n    insn-config.h $(RECOG_H) output.h toplev.h except.h hash.h $(GGC_H) $(TM_P_H)\n stmt.o : stmt.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h function.h  \\\n    insn-config.h hard-reg-set.h $(EXPR_H) libfuncs.h except.h \\\n@@ -1490,7 +1490,7 @@ flow.o : flow.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h insn-config.h\n dominance.o : dominance.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) hard-reg-set.h \\\n    $(BASIC_BLOCK_H)\n combine.o : combine.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) flags.h function.h \\\n-   insn-config.h insn-codes.h $(INSN_ATTR_H) $(REGS_H) $(EXPR_H) \\\n+   insn-config.h $(INSN_ATTR_H) $(REGS_H) $(EXPR_H) \\\n    $(BASIC_BLOCK_H) $(RECOG_H) real.h hard-reg-set.h toplev.h $(TM_P_H)\n regclass.o : regclass.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) hard-reg-set.h flags.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) insn-config.h $(RECOG_H) reload.h real.h \\\n@@ -1545,7 +1545,7 @@ final.o : final.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h intl.h \\\n    toplev.h reload.h dwarf2out.h $(BASIC_BLOCK_H) $(TM_P_H) $(TARGET_H)\n recog.o : recog.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) function.h $(BASIC_BLOCK_H) \\\n    $(REGS_H) $(RECOG_H) $(EXPR_H) hard-reg-set.h flags.h insn-config.h \\\n-   $(INSN_ATTR_H) insn-codes.h real.h toplev.h output.h reload.h $(TM_P_H)\n+   $(INSN_ATTR_H) real.h toplev.h output.h reload.h $(TM_P_H)\n reg-stack.o : reg-stack.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) $(RECOG_H) \\\n    $(REGS_H) hard-reg-set.h flags.h insn-config.h toplev.h reload.h \\\n    varray.h function.h $(TM_P_H)"}, {"sha": "5c6dcbcc4b915684e3a5e1b60aa62e04336ae080", "filename": "gcc/combine.c", "status": "modified", "additions": 23, "deletions": 54, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da92057001929e2c650454e11d828d4296217e3d/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da92057001929e2c650454e11d828d4296217e3d/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=da92057001929e2c650454e11d828d4296217e3d", "patch": "@@ -83,7 +83,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"insn-config.h\"\n-#include \"insn-codes.h\"\n #include \"function.h\"\n /* Include expr.h after insn-config.h so we get HAVE_conditional_move.  */\n #include \"expr.h\"\n@@ -6004,59 +6003,28 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \n   /* Get the mode to use should INNER not be a MEM, the mode for the position,\n      and the mode for the result.  */\n-#ifdef HAVE_insv\n-  if (in_dest)\n+  if (in_dest && mode_for_extraction(EP_insv, -1) != MAX_MACHINE_MODE)\n     {\n-      wanted_inner_reg_mode\n-\t= insn_data[(int) CODE_FOR_insv].operand[0].mode;\n-      if (wanted_inner_reg_mode == VOIDmode)\n-\twanted_inner_reg_mode = word_mode;\n-\n-      pos_mode = insn_data[(int) CODE_FOR_insv].operand[2].mode;\n-      if (pos_mode == VOIDmode)\n-\tpos_mode = word_mode;\n-\n-      extraction_mode = insn_data[(int) CODE_FOR_insv].operand[3].mode;\n-      if (extraction_mode == VOIDmode)\n-\textraction_mode = word_mode;\n+      wanted_inner_reg_mode = mode_for_extraction (EP_insv, 0);\n+      pos_mode = mode_for_extraction (EP_insv, 2);\n+      extraction_mode = mode_for_extraction (EP_insv, 3);\n     }\n-#endif\n \n-#ifdef HAVE_extzv\n-  if (! in_dest && unsignedp)\n+  if (! in_dest && unsignedp\n+      && mode_for_extraction (EP_extzv, -1) != MAX_MACHINE_MODE)\n     {\n-      wanted_inner_reg_mode\n-\t= insn_data[(int) CODE_FOR_extzv].operand[1].mode;\n-      if (wanted_inner_reg_mode == VOIDmode)\n-\twanted_inner_reg_mode = word_mode;\n-\n-      pos_mode = insn_data[(int) CODE_FOR_extzv].operand[3].mode;\n-      if (pos_mode == VOIDmode)\n-\tpos_mode = word_mode;\n-\n-      extraction_mode = insn_data[(int) CODE_FOR_extzv].operand[0].mode;\n-      if (extraction_mode == VOIDmode)\n-\textraction_mode = word_mode;\n+      wanted_inner_reg_mode = mode_for_extraction (EP_extzv, 1);\n+      pos_mode = mode_for_extraction (EP_extzv, 3);\n+      extraction_mode = mode_for_extraction (EP_extzv, 0);\n     }\n-#endif\n \n-#ifdef HAVE_extv\n-  if (! in_dest && ! unsignedp)\n+  if (! in_dest && ! unsignedp\n+      && mode_for_extraction (EP_extv, -1) != MAX_MACHINE_MODE)\n     {\n-      wanted_inner_reg_mode\n-\t= insn_data[(int) CODE_FOR_extv].operand[1].mode;\n-      if (wanted_inner_reg_mode == VOIDmode)\n-\twanted_inner_reg_mode = word_mode;\n-\n-      pos_mode = insn_data[(int) CODE_FOR_extv].operand[3].mode;\n-      if (pos_mode == VOIDmode)\n-\tpos_mode = word_mode;\n-\n-      extraction_mode = insn_data[(int) CODE_FOR_extv].operand[0].mode;\n-      if (extraction_mode == VOIDmode)\n-\textraction_mode = word_mode;\n+      wanted_inner_reg_mode = mode_for_extraction (EP_extv, 1);\n+      pos_mode = mode_for_extraction (EP_extv, 3);\n+      extraction_mode = mode_for_extraction (EP_extv, 0);\n     }\n-#endif\n \n   /* Never narrow an object, since that might not be safe.  */\n \n@@ -10235,14 +10203,15 @@ simplify_comparison (code, pop0, pop1)\n \t    {\n \t      if (BITS_BIG_ENDIAN)\n \t\t{\n-#ifdef HAVE_extzv\n-\t\t  mode = insn_data[(int) CODE_FOR_extzv].operand[1].mode;\n-\t\t  if (mode == VOIDmode)\n-\t\t    mode = word_mode;\n-\t\t  i = (GET_MODE_BITSIZE (mode) - 1 - i);\n-#else\n-\t\t  i = BITS_PER_WORD - 1 - i;\n-#endif\n+\t\t  enum machine_mode new_mode\n+\t\t    = mode_for_extraction (EP_extzv, 1);\n+\t\t  if (new_mode == MAX_MACHINE_MODE)\n+\t\t    i = BITS_PER_WORD - 1 - i;\n+\t\t  else\n+\t\t    {\n+\t\t      mode = new_mode;\n+\t\t      i = (GET_MODE_BITSIZE (mode) - 1 - i);\n+\t\t    }\n \t\t}\n \n \t      op0 = XEXP (op0, 2);"}, {"sha": "e3918d807af8dfe2c55ad9c5a955c7ce426d7835", "filename": "gcc/expmed.c", "status": "modified", "additions": 70, "deletions": 32, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da92057001929e2c650454e11d828d4296217e3d/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da92057001929e2c650454e11d828d4296217e3d/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=da92057001929e2c650454e11d828d4296217e3d", "patch": "@@ -203,6 +203,61 @@ negate_rtx (mode, x)\n \n   return result;\n }\n+\n+/* Report on the availability of insv/extv/extzv and the desired mode\n+   of each of their operands.  Returns MAX_MACHINE_MODE if HAVE_foo\n+   is false; else the mode of the specified operand.  If OPNO is -1,\n+   all the caller cares about is whether the insn is available.  */\n+enum machine_mode\n+mode_for_extraction (pattern, opno)\n+     enum extraction_pattern pattern;\n+     int opno;\n+{\n+  const struct insn_data *data;\n+\n+  switch (pattern)\n+    {\n+    case EP_insv:\n+#ifdef HAVE_insv\n+      if (HAVE_insv)\n+\t{\n+\t  data = &insn_data[CODE_FOR_insv];\n+\t  break;\n+\t}\n+#endif\n+      return MAX_MACHINE_MODE;\n+\n+    case EP_extv:\n+#ifdef HAVE_extv\n+      if (HAVE_extv)\n+\t{\n+\t  data = &insn_data[CODE_FOR_extv];\n+\t  break;\n+\t}\n+#endif\n+      return MAX_MACHINE_MODE;\n+\n+    case EP_extzv:\n+#ifdef HAVE_extzv\n+      if (HAVE_extzv)\n+\t{\n+\t  data = &insn_data[CODE_FOR_extzv];\n+\t  break;\n+\t}\n+#endif\n+      return MAX_MACHINE_MODE;\n+    }\n+\n+  if (opno == -1)\n+    return VOIDmode;\n+\n+  /* Everyone who uses this function used to follow it with\n+     if (result == VOIDmode) result = word_mode; */\n+  if (data->operand[opno].mode == VOIDmode)\n+    return word_mode;\n+  return data->operand[opno].mode;\n+}\n+\n \f\n /* Generate code to store value from rtx VALUE\n    into a bit-field within structure STR_RTX\n@@ -234,15 +289,13 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n   unsigned HOST_WIDE_INT offset = bitnum / unit;\n   unsigned HOST_WIDE_INT bitpos = bitnum % unit;\n   register rtx op0 = str_rtx;\n-#ifdef HAVE_insv\n+\n   unsigned HOST_WIDE_INT insv_bitsize;\n   enum machine_mode op_mode;\n \n-  op_mode = insn_data[(int) CODE_FOR_insv].operand[3].mode;\n-  if (op_mode == VOIDmode)\n-    op_mode = word_mode;\n-  insv_bitsize = GET_MODE_BITSIZE (op_mode);\n-#endif\n+  op_mode = mode_for_extraction (EP_insv, 3);\n+  if (op_mode != MAX_MACHINE_MODE)\n+    insv_bitsize = GET_MODE_BITSIZE (op_mode);\n \n   /* It is wrong to have align==0, since every object is aligned at\n      least at a bit boundary.  This usually means a bug elsewhere.  */\n@@ -475,8 +528,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n   /* Now OFFSET is nonzero only if OP0 is memory\n      and is therefore always measured in bytes.  */\n \n-#ifdef HAVE_insv\n-  if (HAVE_insv\n+  if (op_mode != MAX_MACHINE_MODE\n       && GET_MODE (value) != BLKmode\n       && !(bitsize == 1 && GET_CODE (value) == CONST_INT)\n       /* Ensure insv's size is wide enough for this field.  */\n@@ -617,7 +669,6 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n     }\n   else\n     insv_loses:\n-#endif\n     /* Insv is not available; store using shifts and boolean ops.  */\n     store_fixed_bit_field (op0, offset, bitsize, bitpos, value, align);\n   return value;\n@@ -981,28 +1032,18 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n   rtx spec_target = target;\n   rtx spec_target_subreg = 0;\n   enum machine_mode int_mode;\n-#ifdef HAVE_extv\n   unsigned HOST_WIDE_INT extv_bitsize;\n   enum machine_mode extv_mode;\n-#endif\n-#ifdef HAVE_extzv\n   unsigned HOST_WIDE_INT extzv_bitsize;\n   enum machine_mode extzv_mode;\n-#endif\n \n-#ifdef HAVE_extv\n-  extv_mode = insn_data[(int) CODE_FOR_extv].operand[0].mode;\n-  if (extv_mode == VOIDmode)\n-    extv_mode = word_mode;\n-  extv_bitsize = GET_MODE_BITSIZE (extv_mode);\n-#endif\n+  extv_mode = mode_for_extraction (EP_extv, 0);\n+  if (extv_mode != MAX_MACHINE_MODE)\n+    extv_bitsize = GET_MODE_BITSIZE (extv_mode);\n \n-#ifdef HAVE_extzv\n-  extzv_mode = insn_data[(int) CODE_FOR_extzv].operand[0].mode;\n-  if (extzv_mode == VOIDmode)\n-    extzv_mode = word_mode;\n-  extzv_bitsize = GET_MODE_BITSIZE (extzv_mode);\n-#endif\n+  extzv_mode = mode_for_extraction (EP_extzv, 0);\n+  if (extzv_mode != MAX_MACHINE_MODE)\n+    extzv_bitsize = GET_MODE_BITSIZE (extzv_mode);\n \n   /* Discount the part of the structure before the desired byte.\n      We need to know how many bytes are safe to reference after it.  */\n@@ -1236,8 +1277,7 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \n   if (unsignedp)\n     {\n-#ifdef HAVE_extzv\n-      if (HAVE_extzv\n+      if (extzv_mode != MAX_MACHINE_MODE\n \t  && (extzv_bitsize >= bitsize)\n \t  && ! ((GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG)\n \t\t&& (bitsize + bitpos > extzv_bitsize)))\n@@ -1369,14 +1409,12 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t}\n       else\n         extzv_loses:\n-#endif\n       target = extract_fixed_bit_field (int_mode, op0, offset, bitsize, \n \t\t\t\t\tbitpos, target, 1, align);\n     }\n   else\n     {\n-#ifdef HAVE_extv\n-      if (HAVE_extv\n+      if (extv_mode != MAX_MACHINE_MODE\n \t  && (extv_bitsize >= bitsize)\n \t  && ! ((GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG)\n \t\t&& (bitsize + bitpos > extv_bitsize)))\n@@ -1503,7 +1541,6 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t} \n       else\n \textv_loses:\n-#endif\n       target = extract_fixed_bit_field (int_mode, op0, offset, bitsize, \n \t\t\t\t\tbitpos, target, 0, align);\n     }\n@@ -2000,7 +2037,8 @@ expand_shift (code, mode, shifted, amount, target, unsignedp)\n \t     that is in range, try a rotate in the opposite direction.  */\n \n \t  if (temp == 0 && GET_CODE (op1) == CONST_INT\n-\t      && INTVAL (op1) > 0 && INTVAL (op1) < GET_MODE_BITSIZE (mode))\n+\t      && INTVAL (op1) > 0\n+\t      && (unsigned int) INTVAL (op1) < GET_MODE_BITSIZE (mode))\n \t    temp = expand_binop (mode,\n \t\t\t\t left ? rotr_optab : rotl_optab,\n \t\t\t\t shifted, "}, {"sha": "9bf2adb5a5094db5f79c547c79567f9fcd654aa8", "filename": "gcc/expr.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da92057001929e2c650454e11d828d4296217e3d/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da92057001929e2c650454e11d828d4296217e3d/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=da92057001929e2c650454e11d828d4296217e3d", "patch": "@@ -715,6 +715,14 @@ extern rtx hard_libcall_value PARAMS ((enum machine_mode));\n    of STACK_BOUNDARY / BITS_PER_UNIT.  */\n extern rtx round_push PARAMS ((rtx));\n \n+/* Return the mode desired by operand N of a particular bitfield\n+   insert/extract insn, or MAX_MACHINE_MODE if no such insn is\n+   available.  */\n+\n+enum extraction_pattern { EP_insv, EP_extv, EP_extzv };\n+extern enum machine_mode\n+mode_for_extraction PARAMS ((enum extraction_pattern, int));\n+\n extern rtx store_bit_field PARAMS ((rtx, unsigned HOST_WIDE_INT,\n \t\t\t\t    unsigned HOST_WIDE_INT,\n \t\t\t\t    enum machine_mode, rtx,"}, {"sha": "93add2af83c53b021daf8eca2e994019728bda85", "filename": "gcc/function.c", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da92057001929e2c650454e11d828d4296217e3d/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da92057001929e2c650454e11d828d4296217e3d/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=da92057001929e2c650454e11d828d4296217e3d", "patch": "@@ -50,7 +50,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n #include \"insn-config.h\"\n-#include \"insn-codes.h\"\n #include \"recog.h\"\n #include \"output.h\"\n #include \"basic-block.h\"\n@@ -2064,23 +2063,21 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t      enum machine_mode is_mode = GET_MODE (tem);\n \t      HOST_WIDE_INT pos = INTVAL (XEXP (x, 2));\n \n-#ifdef HAVE_extzv\n \t      if (GET_CODE (x) == ZERO_EXTRACT)\n \t\t{\n-\t\t  wanted_mode\n-\t\t    = insn_data[(int) CODE_FOR_extzv].operand[1].mode;\n-\t\t  if (wanted_mode == VOIDmode)\n-\t\t    wanted_mode = word_mode;\n+\t\t  enum machine_mode new_mode\n+\t\t    = mode_for_extraction (EP_extzv, 1);\n+\t\t  if (new_mode != MAX_MACHINE_MODE)\n+\t\t    wanted_mode = new_mode;\n \t\t}\n-#endif\n-#ifdef HAVE_extv\n-\t      if (GET_CODE (x) == SIGN_EXTRACT)\n+\t      else if (GET_CODE (x) == SIGN_EXTRACT)\n \t\t{\n-\t\t  wanted_mode = insn_data[(int) CODE_FOR_extv].operand[1].mode;\n-\t\t  if (wanted_mode == VOIDmode)\n-\t\t    wanted_mode = word_mode;\n+\t\t  enum machine_mode new_mode\n+\t\t    = mode_for_extraction (EP_extv, 1);\n+\t\t  if (new_mode != MAX_MACHINE_MODE)\n+\t\t    wanted_mode = new_mode;\n \t\t}\n-#endif\n+\n \t      /* If we have a narrower mode, we can do something.  */\n \t      if (wanted_mode != VOIDmode\n \t\t  && GET_MODE_SIZE (wanted_mode) < GET_MODE_SIZE (is_mode))\n@@ -2215,9 +2212,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n       {\n \trtx dest = SET_DEST (x);\n \trtx src = SET_SRC (x);\n-#ifdef HAVE_insv\n \trtx outerdest = dest;\n-#endif\n \n \twhile (GET_CODE (dest) == SUBREG || GET_CODE (dest) == STRICT_LOW_PART\n \t       || GET_CODE (dest) == SIGN_EXTRACT\n@@ -2236,8 +2231,8 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t/* We will need to rerecognize this insn.  */\n \tINSN_CODE (insn) = -1;\n \n-#ifdef HAVE_insv\n-\tif (GET_CODE (outerdest) == ZERO_EXTRACT && dest == var)\n+\tif (GET_CODE (outerdest) == ZERO_EXTRACT && dest == var\n+\t    && mode_for_extraction (EP_insv, -1) != MAX_MACHINE_MODE)\n \t  {\n \t    /* Since this case will return, ensure we fixup all the\n \t       operands here.  */\n@@ -2268,9 +2263,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t\tenum machine_mode is_mode = GET_MODE (tem);\n \t\tHOST_WIDE_INT pos = INTVAL (XEXP (outerdest, 2));\n \n-\t\twanted_mode = insn_data[(int) CODE_FOR_insv].operand[0].mode;\n-\t\tif (wanted_mode == VOIDmode)\n-\t\t  wanted_mode = word_mode;\n+\t\twanted_mode = mode_for_extraction (EP_insv, 0);\n \n \t\t/* If we have a narrower mode, we can do something.  */\n \t\tif (GET_MODE_SIZE (wanted_mode) < GET_MODE_SIZE (is_mode))\n@@ -2311,7 +2304,6 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t    XEXP (outerdest, 0) = tem1;\n \t    return;\n \t  }\n-#endif\n \n \t/* STRICT_LOW_PART is a no-op on memory references\n \t   and it can cause combinations to be unrecognizable,"}, {"sha": "3ec2eeba0ddf3822e0b5c5dae97482f28268b4f0", "filename": "gcc/recog.c", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da92057001929e2c650454e11d828d4296217e3d/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da92057001929e2c650454e11d828d4296217e3d/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=da92057001929e2c650454e11d828d4296217e3d", "patch": "@@ -30,7 +30,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"recog.h\"\n #include \"regs.h\"\n #include \"expr.h\"\n-#include \"insn-codes.h\"\n #include \"function.h\"\n #include \"flags.h\"\n #include \"real.h\"\n@@ -566,22 +565,20 @@ validate_replace_rtx_1 (loc, from, to, object)\n \t  enum machine_mode is_mode = GET_MODE (XEXP (x, 0));\n \t  int pos = INTVAL (XEXP (x, 2));\n \n-#ifdef HAVE_extzv\n-\t  if (code == ZERO_EXTRACT)\n+\t  if (GET_CODE (x) == ZERO_EXTRACT)\n \t    {\n-\t      wanted_mode = insn_data[(int) CODE_FOR_extzv].operand[1].mode;\n-\t      if (wanted_mode == VOIDmode)\n-\t\twanted_mode = word_mode;\n+\t      enum machine_mode new_mode\n+\t\t= mode_for_extraction (EP_extzv, 1);\n+\t      if (new_mode != MAX_MACHINE_MODE)\n+\t\twanted_mode = new_mode;\n \t    }\n-#endif\n-#ifdef HAVE_extv\n-\t  if (code == SIGN_EXTRACT)\n+\t  else if (GET_CODE (x) == SIGN_EXTRACT)\n \t    {\n-\t      wanted_mode = insn_data[(int) CODE_FOR_extv].operand[1].mode;\n-\t      if (wanted_mode == VOIDmode)\n-\t\twanted_mode = word_mode;\n+\t      enum machine_mode new_mode\n+\t\t= mode_for_extraction (EP_extv, 1);\n+\t      if (new_mode != MAX_MACHINE_MODE)\n+\t\twanted_mode = new_mode;\n \t    }\n-#endif\n \n \t  /* If we have a narrower mode, we can do something.  */\n \t  if (wanted_mode != VOIDmode"}]}