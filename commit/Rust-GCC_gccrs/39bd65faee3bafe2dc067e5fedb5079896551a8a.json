{"sha": "39bd65faee3bafe2dc067e5fedb5079896551a8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzliZDY1ZmFlZTNiYWZlMmRjMDY3ZTVmZWRiNTA3OTg5NjU1MWE4YQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-01-04T12:02:24Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-01-04T12:51:56Z"}, "message": "tree-optimization/98464 - replace loop info with avail at uses\n\nThis does VN replacement in loop nb_iterations consistent with\nthe rest of the IL by using availability at the definition site\nof uses.\n\n2021-01-04  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/98464\n\t* tree-ssa-sccvn.c (vn_valueize_for_srt): Rename from ...\n\t(vn_valueize_wrapper): ... this.  Temporarily adjust vn_context_bb.\n\t(process_bb): Adjust.\n\n\t* g++.dg/opt/pr98464.C: New testcase.", "tree": {"sha": "9da1da01aeca091cfad6664b0490ed8c03da488c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9da1da01aeca091cfad6664b0490ed8c03da488c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39bd65faee3bafe2dc067e5fedb5079896551a8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39bd65faee3bafe2dc067e5fedb5079896551a8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39bd65faee3bafe2dc067e5fedb5079896551a8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39bd65faee3bafe2dc067e5fedb5079896551a8a/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f2b73175666f678adbf007907c7aa2661284bd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f2b73175666f678adbf007907c7aa2661284bd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f2b73175666f678adbf007907c7aa2661284bd3"}], "stats": {"total": 178, "additions": 172, "deletions": 6}, "files": [{"sha": "38d0c1b1f7c07144d9cca112b8e714fa03722735", "filename": "gcc/testsuite/g++.dg/opt/pr98464.C", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39bd65faee3bafe2dc067e5fedb5079896551a8a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr98464.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39bd65faee3bafe2dc067e5fedb5079896551a8a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr98464.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr98464.C?ref=39bd65faee3bafe2dc067e5fedb5079896551a8a", "patch": "@@ -0,0 +1,155 @@\n+// { dg-do compile }\n+// { dg-require-effective-target c++11 }\n+// { dg-options \"-O3 -fno-tree-dce\" }\n+\n+template < typename, typename, template < typename > class _Op,            typename... _Args > struct __detector {\n+      using type = _Op< _Args... >;\n+    };\n+     template < typename _Default, template < typename > class _Op,            typename... _Args > using __detected_or = __detector< _Default, void, _Op, _Args... >;\n+     template < typename _Default, template < typename > class _Op,            typename... _Args > using __detected_or_t = typename __detected_or< _Default, _Op, _Args... >::type;\n+     template < typename, typename > struct __replace_first_arg;\n+     template < template < typename > class _Template, typename _Up, typename _Tp,            typename... _Types > struct __replace_first_arg< _Template< _Tp, _Types... >, _Up > {\n+      using type = _Template< _Up >;\n+    };\n+     template < class > class min_pointer;\n+     class MoveOnly;\n+     struct pointer_traits {\n+      template < typename _Up >   using rebind = typename __replace_first_arg< min_pointer< int >, _Up >::type;\n+    };\n+     template < typename _Iterator > class __normal_iterator {\n+    public:   __normal_iterator(_Iterator);\n+    };\n+     struct __allocator_traits_base {\n+      template < typename _Tp > using __pointer = typename _Tp::pointer;\n+    };\n+     template < typename _Alloc > struct allocator_traits : __allocator_traits_base {\n+      typedef typename _Alloc::value_type value_type;\n+      using pointer = __detected_or_t< value_type, __pointer, _Alloc >;\n+      template < typename _Tp > struct _Ptr {\n+       using type = pointer_traits::rebind< _Tp >;\n+     };\n+      using const_pointer = typename _Ptr< value_type >::type;\n+      using size_type = int;\n+      static pointer allocate(_Alloc __a, size_type __n) {\n+       return __a.allocate(__n);\n+     }\n+    };\n+     template < typename _ForwardIterator, typename _Allocator > void _Destroy(_ForwardIterator __first, _ForwardIterator __last, _Allocator) {\n+      for (;\n+    __first != __last;\n+    ++__first)     ;\n+    }\n+     template < typename _InputIterator, typename _ForwardIterator,            typename _Allocator > _ForwardIterator __uninitialized_copy_a(_InputIterator, _ForwardIterator,                                         _Allocator);\n+     template < typename _InputIterator, typename _ForwardIterator,            typename _Allocator > _ForwardIterator __uninitialized_move_if_noexcept_a(_InputIterator __last,                                                     _ForwardIterator __result,                                                     _Allocator __alloc) {\n+      return __uninitialized_copy_a(__last, __result, __alloc);\n+    }\n+     template < typename _ForwardIterator, typename _Size, typename _Allocator > _ForwardIterator __uninitialized_default_n_a(_ForwardIterator __first,                                              _Size __n, _Allocator) {\n+      for (;\n+    __n;\n+    --__n, ++__first)     ;\n+      return __first;\n+    }\n+     template < typename _Alloc > struct _Vector_base {\n+      typedef _Alloc _Tp_alloc_type;\n+      typedef typename _Tp_alloc_type ::pointer pointer;\n+      struct _Vector_impl_data {\n+       pointer _M_start;\n+       pointer _M_finish;\n+       pointer _M_end_of_storage;\n+     };\n+      struct _Vector_impl : _Tp_alloc_type, _Vector_impl_data {\n+       _Vector_impl(_Tp_alloc_type) {\n+ }\n+     };\n+      _Vector_base(long __n, _Alloc __a) : _M_impl(__a) {\n+       _M_impl._M_end_of_storage = _M_impl._M_start + __n;\n+     }\n+      _Vector_impl _M_impl;\n+      pointer _M_allocate(long __n) {\n+       return __n ? allocator_traits< _Tp_alloc_type >::allocate(_M_impl, __n)                : pointer();\n+     }\n+    };\n+     template < typename, typename _Alloc > class vector : _Vector_base< _Alloc > {\n+    public:   typedef typename _Alloc::pointer pointer;\n+      typedef __normal_iterator<       typename allocator_traits< _Alloc >::const_pointer >       const_iterator;\n+      typedef _Alloc allocator_type;\n+      vector(long __n, allocator_type __a = allocator_type())       : _Vector_base< _Alloc >(__n, __a) {\n+       this->_M_impl._M_finish =         __uninitialized_default_n_a(this->_M_impl._M_start, __n, 0);\n+     }\n+      ~vector() {\n+   _Destroy(this->_M_impl._M_start, this->_M_impl._M_finish, 0);\n+   }\n+      const_iterator cbegin() {\n+   return this->_M_impl._M_start;\n+   }\n+      typename _Alloc::value_type operator[](long) {\n+       return *this->_M_impl._M_start;\n+     }\n+      void insert(const_iterator, MoveOnly &&) {\n+       if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)       ;\n+       else       _M_realloc_insert();\n+     }\n+      template < typename... > void _M_realloc_insert();\n+    };\n+     template < typename _Tp, typename _Alloc > template < typename... > void vector< _Tp, _Alloc >::_M_realloc_insert() {\n+      long __trans_tmp_6 = this->_M_impl._M_finish - this->_M_impl._M_start;\n+      pointer __old_start = this->_M_impl._M_start;\n+      pointer __old_finish = this->_M_impl._M_finish;\n+      pointer __new_start(this->_M_allocate(__trans_tmp_6));\n+      pointer __new_finish =       __uninitialized_move_if_noexcept_a(__old_finish, __new_finish, 0);\n+      _Destroy(__old_start, __old_finish, 0);\n+      this->_M_impl._M_start = __new_start;\n+      this->_M_impl._M_finish = __new_finish;\n+    }\n+     class MoveOnly {\n+      int data_;\n+     public:   bool operator==(MoveOnly) {\n+   return data_;\n+   }\n+    };\n+     void __assert_fail();\n+     template < class T > class min_pointer {\n+      T *ptr_;\n+      min_pointer(T *p) : ptr_(p) {\n+  }\n+     public:   min_pointer() = default;\n+      T operator*() {\n+   return *ptr_;\n+   }\n+      void operator++() {\n+   ++ptr_;\n+   }\n+      void operator+=(long n) {\n+   ptr_ += n;\n+   }\n+      min_pointer operator+(long n) {\n+       min_pointer tmp(*this);\n+       tmp += n;\n+       return tmp;\n+     }\n+      friend long operator-(min_pointer x, min_pointer y) {\n+       return x.ptr_ - y.ptr_;\n+     }\n+      friend bool operator==(min_pointer x, min_pointer y) {\n+       return x.ptr_ == y.ptr_;\n+     }\n+      friend bool operator!=(min_pointer x, min_pointer y) {\n+   return !(x == y);\n+   }\n+      friend class min_allocator;\n+    };\n+     class min_allocator {\n+    public:   typedef MoveOnly value_type;\n+      typedef min_pointer< MoveOnly > pointer;\n+      pointer allocate(long) {\n+       return static_cast< MoveOnly * >(operator new(sizeof(MoveOnly)));\n+     }\n+    };\n+     int main() {\n+      vector< int, min_allocator > v(100);\n+      v.insert(v.cbegin(), MoveOnly());\n+      int j = 0;\n+      for (;\n+    j < 10;\n+    ++j)     v[j] == MoveOnly() ? void() : __assert_fail();\n+    }"}, {"sha": "17016853a34994ed787f64e550bb2a061872e375", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39bd65faee3bafe2dc067e5fedb5079896551a8a/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39bd65faee3bafe2dc067e5fedb5079896551a8a/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=39bd65faee3bafe2dc067e5fedb5079896551a8a", "patch": "@@ -304,12 +304,23 @@ static vn_nary_op_t last_inserted_nary;\n static vn_tables_t valid_info;\n \n \n-/* Valueization hook.  Valueize NAME if it is an SSA name, otherwise\n-   just return it.  */\n+/* Valueization hook for simplify_replace_tree.  Valueize NAME if it is\n+   an SSA name, otherwise just return it.  */\n tree (*vn_valueize) (tree);\n-tree vn_valueize_wrapper (tree t, void* context ATTRIBUTE_UNUSED)\n-{\n-  return vn_valueize (t);\n+static tree\n+vn_valueize_for_srt (tree t, void* context ATTRIBUTE_UNUSED)\n+{\n+  basic_block saved_vn_context_bb = vn_context_bb;\n+  /* Look for sth available at the definition block of the argument.\n+     This avoids inconsistencies between availability there which\n+     decides if the stmt can be removed and availability at the\n+     use site.  The SSA property ensures that things available\n+     at the definition are also available at uses.  */\n+  if (!SSA_NAME_IS_DEFAULT_DEF (t))\n+    vn_context_bb = gimple_bb (SSA_NAME_DEF_STMT (t));\n+  tree res = vn_valueize (t);\n+  vn_context_bb = saved_vn_context_bb;\n+  return res;\n }\n \n \n@@ -6995,7 +7006,7 @@ process_bb (rpo_elim &avail, basic_block bb,\n       if (bb->loop_father->nb_iterations)\n \tbb->loop_father->nb_iterations\n \t  = simplify_replace_tree (bb->loop_father->nb_iterations,\n-\t\t\t\t   NULL_TREE, NULL_TREE, &vn_valueize_wrapper);\n+\t\t\t\t   NULL_TREE, NULL_TREE, &vn_valueize_for_srt);\n     }\n \n   /* Value-number all defs in the basic-block.  */"}]}