{"sha": "cfff829fc6573d9919054d46b9beaa20dab9272d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZmZjgyOWZjNjU3M2Q5OTE5MDU0ZDQ2YjliZWFhMjBkYWI5MjcyZA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2007-10-25T12:38:38Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2007-10-25T12:38:38Z"}, "message": "tree-flow.h (mem_sym_stats): Remove.\n\n2007-10-25  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-flow.h (mem_sym_stats): Remove.\n\t(dump_mem_sym_stats_for_var): Declare.\n\t* tree-dfa.c (dump_variable): Call dump_mem_sym_stats_for_var.\n\t(mem_sym_stats): Move ...\n\t* tree-ssa-alias.c (mem_sym_stats): ... here and make it static.\n\t(mem_sym_score): Rename from ...\n\t(pscore): ... this.  Remove.\n\t(dump_mem_sym_stats_for_var): New function.  Dump the score, but\n\tnot the frequencies.\n\t(compare_mp_info_entries): Make sort stable by disambiguating\n\ton DECL_UID.\n\nFrom-SVN: r129625", "tree": {"sha": "cb6c9e8430678265683eed3c5a6c8758b6106844", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb6c9e8430678265683eed3c5a6c8758b6106844"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfff829fc6573d9919054d46b9beaa20dab9272d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfff829fc6573d9919054d46b9beaa20dab9272d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfff829fc6573d9919054d46b9beaa20dab9272d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfff829fc6573d9919054d46b9beaa20dab9272d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1fcd0a2c503b9fd16cf52df248c92c387d0086f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fcd0a2c503b9fd16cf52df248c92c387d0086f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fcd0a2c503b9fd16cf52df248c92c387d0086f9"}], "stats": {"total": 163, "additions": 93, "deletions": 70}, "files": [{"sha": "7c4c706f2d5fa6342eb8617915a379b2e2aef96b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfff829fc6573d9919054d46b9beaa20dab9272d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfff829fc6573d9919054d46b9beaa20dab9272d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cfff829fc6573d9919054d46b9beaa20dab9272d", "patch": "@@ -1,3 +1,17 @@\n+2007-10-25  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-flow.h (mem_sym_stats): Remove.\n+\t(dump_mem_sym_stats_for_var): Declare.\n+\t* tree-dfa.c (dump_variable): Call dump_mem_sym_stats_for_var.\n+\t(mem_sym_stats): Move ...\n+\t* tree-ssa-alias.c (mem_sym_stats): ... here and make it static.\n+\t(mem_sym_score): Rename from ...\n+\t(pscore): ... this.  Remove.\n+\t(dump_mem_sym_stats_for_var): New function.  Dump the score, but\n+\tnot the frequencies.\n+\t(compare_mp_info_entries): Make sort stable by disambiguating\n+\ton DECL_UID.\n+\n 2007-10-25  Ira Rosen  <irar@il.ibm.com>\n \n \tPR tree-optimization/33866"}, {"sha": "79f3b8712bcde3a5c9efedb05fc980248bb1809b", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 1, "deletions": 32, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfff829fc6573d9919054d46b9beaa20dab9272d/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfff829fc6573d9919054d46b9beaa20dab9272d/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=cfff829fc6573d9919054d46b9beaa20dab9272d", "patch": "@@ -345,16 +345,7 @@ dump_variable (FILE *file, tree var)\n   if (TREE_THIS_VOLATILE (var))\n     fprintf (file, \", is volatile\");\n \n-  if (mem_sym_stats (cfun, var))\n-    {\n-      mem_sym_stats_t stats = mem_sym_stats (cfun, var);\n-      fprintf (file, \", direct reads: %ld\", stats->num_direct_reads);\n-      fprintf (file, \", direct writes: %ld\", stats->num_direct_writes);\n-      fprintf (file, \", indirect reads: %ld\", stats->num_indirect_reads);\n-      fprintf (file, \", indirect writes: %ld\", stats->num_indirect_writes);\n-      fprintf (file, \", read frequency: %ld\", stats->frequency_reads);\n-      fprintf (file, \", write frequency: %ld\", stats->frequency_writes);\n-    }\n+  dump_mem_sym_stats_for_var (file, var);\n \n   if (is_call_clobbered (var))\n     {\n@@ -1010,25 +1001,3 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n   return exp;\n }\n \n-\n-/* Return memory reference statistics for variable VAR in function FN.\n-   This is computed by alias analysis, but it is not kept\n-   incrementally up-to-date.  So, these stats are only accurate if\n-   pass_may_alias has been run recently.  If no alias information\n-   exists, this function returns NULL.  */\n-\n-mem_sym_stats_t\n-mem_sym_stats (struct function *fn, tree var)\n-{\n-  void **slot;\n-  struct pointer_map_t *stats_map = gimple_mem_ref_stats (fn)->mem_sym_stats;\n-\n-  if (stats_map == NULL)\n-    return NULL;\n-\n-  slot = pointer_map_contains (stats_map, var);\n-  if (slot == NULL)\n-    return NULL;\n-\n-  return (mem_sym_stats_t) *slot;\n-}"}, {"sha": "1d6808bfd6cd6a11af4517d7b968c1f75e9848e6", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfff829fc6573d9919054d46b9beaa20dab9272d/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfff829fc6573d9919054d46b9beaa20dab9272d/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=cfff829fc6573d9919054d46b9beaa20dab9272d", "patch": "@@ -810,7 +810,6 @@ extern void find_new_referenced_vars (tree *);\n extern tree make_rename_temp (tree, const char *);\n extern void set_default_def (tree, tree);\n extern tree gimple_default_def (struct function *, tree);\n-extern struct mem_sym_stats_d *mem_sym_stats (struct function *, tree);\n \n /* In tree-phinodes.c  */\n extern void reserve_phi_args_for_new_edge (basic_block);\n@@ -856,6 +855,7 @@ extern void dump_mem_ref_stats (FILE *);\n extern void debug_mem_ref_stats (void);\n extern void debug_memory_partitions (void);\n extern void debug_mem_sym_stats (tree var);\n+extern void dump_mem_sym_stats_for_var (FILE *, tree);\n extern void debug_all_mem_sym_stats (void);\n \n /* Call-back function for walk_use_def_chains().  At each reaching"}, {"sha": "e96f0ef899b7d6dbb3c681714c5cfda63559151e", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 77, "deletions": 37, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfff829fc6573d9919054d46b9beaa20dab9272d/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfff829fc6573d9919054d46b9beaa20dab9272d/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=cfff829fc6573d9919054d46b9beaa20dab9272d", "patch": "@@ -242,6 +242,29 @@ get_mem_sym_stats_for (tree var)\n }\n \n \n+/* Return memory reference statistics for variable VAR in function FN.\n+   This is computed by alias analysis, but it is not kept\n+   incrementally up-to-date.  So, these stats are only accurate if\n+   pass_may_alias has been run recently.  If no alias information\n+   exists, this function returns NULL.  */\n+\n+static mem_sym_stats_t\n+mem_sym_stats (struct function *fn, tree var)\n+{\n+  void **slot;\n+  struct pointer_map_t *stats_map = gimple_mem_ref_stats (fn)->mem_sym_stats;\n+\n+  if (stats_map == NULL)\n+    return NULL;\n+\n+  slot = pointer_map_contains (stats_map, var);\n+  if (slot == NULL)\n+    return NULL;\n+\n+  return (mem_sym_stats_t) *slot;\n+}\n+\n+\n /* Set MPT to be the memory partition associated with symbol SYM.  */\n \n static inline void\n@@ -774,6 +797,40 @@ count_mem_refs (long *num_vuses_p, long *num_vdefs_p,\n }\n \n \n+/* The list is sorted by increasing partitioning score (PSCORE).\n+   This score is computed such that symbols with high scores are\n+   those that are least likely to be partitioned.  Given a symbol\n+   MP->VAR, PSCORE(S) is the result of the following weighted sum\n+\n+   PSCORE(S) =   FW * 64 + FR * 32\n+   \t       + DW * 16 + DR *  8 \n+   \t       + IW *  4 + IR *  2\n+               + NO_ALIAS\n+\n+   where\n+\n+   FW\t\tExecution frequency of writes to S\n+   FR\t\tExecution frequency of reads from S\n+   DW\t\tNumber of direct writes to S\n+   DR\t\tNumber of direct reads from S\n+   IW\t\tNumber of indirect writes to S\n+   IR\t\tNumber of indirect reads from S\n+   NO_ALIAS\tState of the NO_ALIAS* flags\n+\n+   The basic idea here is that symbols that are frequently\n+   written-to in hot paths of the code are the last to be considered\n+   for partitioning.  */\n+\n+static inline long\n+mem_sym_score (mem_sym_stats_t mp)\n+{\n+  return mp->frequency_writes * 64 + mp->frequency_reads * 32\n+         + mp->num_direct_writes * 16 + mp->num_direct_reads * 8\n+\t + mp->num_indirect_writes * 4 + mp->num_indirect_reads * 2\n+\t + var_ann (mp->var)->noalias_state;\n+}\n+\n+\n /* Dump memory reference stats for function CFUN to FILE.  */\n \n void\n@@ -874,6 +931,23 @@ debug_mem_sym_stats (tree var)\n   dump_mem_sym_stats (stderr, var);\n }\n \n+/* Dump memory reference stats for variable VAR to FILE.  For use\n+   of tree-dfa.c:dump_variable.  */\n+\n+void\n+dump_mem_sym_stats_for_var (FILE *file, tree var)\n+{\n+  mem_sym_stats_t stats = mem_sym_stats (cfun, var);\n+\n+  if (stats == NULL)\n+    return;\n+\n+  fprintf (file, \", score: %ld\", mem_sym_score (stats));\n+  fprintf (file, \", direct reads: %ld\", stats->num_direct_reads);\n+  fprintf (file, \", direct writes: %ld\", stats->num_direct_writes);\n+  fprintf (file, \", indirect reads: %ld\", stats->num_indirect_reads);\n+  fprintf (file, \", indirect writes: %ld\", stats->num_indirect_writes);\n+}\n \n /* Dump memory reference stats for all memory symbols to FILE.  */\n \n@@ -950,56 +1024,22 @@ update_mem_sym_stats_from_stmt (tree var, tree stmt, long num_direct_reads,\n }\n \n \n-/* The list is sorted by increasing partitioning score (PSCORE).\n-   This score is computed such that symbols with high scores are\n-   those that are least likely to be partitioned.  Given a symbol\n-   MP->VAR, PSCORE(S) is the result of the following weighted sum\n-\n-   PSCORE(S) =   FW * 64 + FR * 32\n-   \t       + DW * 16 + DR *  8 \n-   \t       + IW *  4 + IR *  2\n-               + NO_ALIAS\n-\n-   where\n-\n-   FW\t\tExecution frequency of writes to S\n-   FR\t\tExecution frequency of reads from S\n-   DW\t\tNumber of direct writes to S\n-   DR\t\tNumber of direct reads from S\n-   IW\t\tNumber of indirect writes to S\n-   IR\t\tNumber of indirect reads from S\n-   NO_ALIAS\tState of the NO_ALIAS* flags\n-\n-   The basic idea here is that symbols that are frequently\n-   written-to in hot paths of the code are the last to be considered\n-   for partitioning.  */\n-\n-static inline long\n-pscore (mem_sym_stats_t mp)\n-{\n-  return mp->frequency_writes * 64 + mp->frequency_reads * 32\n-         + mp->num_direct_writes * 16 + mp->num_direct_reads * 8\n-\t + mp->num_indirect_writes * 4 + mp->num_indirect_reads * 2\n-\t + var_ann (mp->var)->noalias_state;\n-}\n-\n-\n /* Given two MP_INFO entries MP1 and MP2, return -1 if MP1->VAR should\n    be partitioned before MP2->VAR, 0 if they are the same or 1 if\n    MP1->VAR should be partitioned after MP2->VAR.  */\n \n static inline int\n compare_mp_info_entries (mem_sym_stats_t mp1, mem_sym_stats_t mp2)\n {\n-  long pscore1 = pscore (mp1);\n-  long pscore2 = pscore (mp2);\n+  long pscore1 = mem_sym_score (mp1);\n+  long pscore2 = mem_sym_score (mp2);\n \n   if (pscore1 < pscore2)\n     return -1;\n   else if (pscore1 > pscore2)\n     return 1;\n   else\n-    return 0;\n+    return DECL_UID (mp1->var) - DECL_UID (mp2->var);\n }\n \n "}]}