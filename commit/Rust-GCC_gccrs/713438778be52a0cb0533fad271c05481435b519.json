{"sha": "713438778be52a0cb0533fad271c05481435b519", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzEzNDM4Nzc4YmU1MmEwY2IwNTMzZmFkMjcxYzA1NDgxNDM1YjUxOQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2013-10-09T13:09:23Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2013-10-09T13:09:23Z"}, "message": "tree-flow.h: Move some protoypes.\n\n\n\t* tree-flow.h: Move some protoypes.  Include new tree-ssa-loop.h.\n\t(struct affine_iv, struct tree_niter_desc): Move to tree-ssa-loop.h.\n\t(enum move_pos): Move to tree-ssa-loop-im.h\n\t* cfgloop.h: Move some prototypes.\n\t(gcov_type_to_double_int): relocate from tree-ssa-loop.niter.c.\n\t* tree-flow-inline.h (loop_containing_stmt): Move to tree-ssa-loop.h.\n\t* tree-ssa-loop.h: New File.  Include other tree-ssa-loop-*.h files.\n\t(struct affine_iv, struct tree_niter_desc): Relocate from tree-flow.h.\n\t(loop_containing_stmt): Relocate from tree-flow-inline.h.\n\t* tree-ssa-loop-ch.c: (do_while_loop_p): Make static.\n\t* tree-ssa-loop-im.c (for_each_index): Move to tree-ssa-loop.c.\n\t(enum move_pos): Relocate here.\n\t(lsm_tmp_name_add, gen_lsm_tmp_name, get_lsm_tmp_name): Move to\n\ttree-ssa-loop.c.\n\t(execute_sm_if_changed_flag_set): Change get_lsm_tmp_name call.\n\t(tree_ssa_loop_im, gate_tree_ssa_loop_im, pass_data_lim, make_pass_lim):\n\tRelocate here from tree-ssa-loop.c.\n\t* tree-ssa-loop-ivcanon.c (tree_num_loop_insns): Move to \n\ttree-ssa-loop.c.\n\t(loop_edge_to_cancel, unloop_loops): Make static.\n\t(tree_ssa_loop_ivcanon, gate_tree_ssa_loop_ivcanon, pass_data_iv_canon,\n\tmake_pass_iv_canon): Relocate from tree-ssa-loop.c.\n\t(tree_complete_unroll, gate_tree_complete_unroll,\n\tpass_data_complete_unroll, make_pass_complete_unroll): Relocate here.\n\t(tree_complete_unroll_inner, gate_tree_complete_unroll_inner,\n\tpass_data_complete_unrolli, make_pass_complete_unrolli): Relocate here.\n\t* tree-ssa-loop-ivopts.c: Remove local prototypes.\n\t(stmt_invariant_in_loop_p): Remove unused function.\n\t* tree-ssa-loop-ivopts.h: New file.  Add prototypes.\n\t* tree-ssa-loop-manip.h: New file.  Add prototypes.\n\t* tree-ssa-loop-niter.c (record_niter_bound): Move to cfgloop.c.\n\t(gcov_type_to_double_int): Move to cfgloop.h.\n\t(double_int_cmp, bound_index,\n\testimate_numbers_of_iterations_loop): Make static.\n\t(estimated_loop_iterations): Factor out get_estimated_loop_iterations.\n\t(max_loop_iterations): Factor out get_max_loop_iterations.\n\t(estimated_loop_iterations_int, max_stmt_executions_int): Move to\n\tcfgloop.c.\n\t* tree-ssa-loop-niter.h: New file.  Add prototypes.\n\t* tree-ssa-loop-prefetch.c (tree_ssa_loop_prefetch,\n\tgate_tree_ssa_loop_prefetch, pass_data_loop_prefetch,\n\tmake_pass_loop_prefetch): Relocate from tree-ssa-loop.c.\n\t* tree-ssa-loop-unswitch.c (tree_ssa_loop_unswitch,\n\tgate_tree_ssa_loop_unswitch, pass_data_tree_unswitch,\n\tmake_pass_tree_unswitch): Relocate from tree-ssa-loop.c.\n\t* tree-ssa-loop.c (tree_ssa_loop_im, gate_tree_ssa_loop_im,\n\tpass_data_lim, make_pass_lim): Move to tree-ssa-loop-im.c.\n\t(tree_ssa_loop_unswitch, gate_tree_ssa_loop_unswitch,\n\tpass_data_tree_unswitch, make_pass_tree_unswitch): Move.\n\t(tree_ssa_loop_ivcanon, gate_tree_ssa_loop_ivcanon, pass_data_iv_canon,\n\tmake_pass_iv_canon, tree_complete_unroll, gate_tree_complete_unroll,\n\tpass_data_complete_unroll, make_pass_complete_unroll,\n\ttree_complete_unroll_inner, gate_tree_complete_unroll_inner,\n\tpass_data_complete_unrolli, make_pass_complete_unrolli): Move to\n\ttree-ssa-loop-ivcanon.c.\n\t(tree_ssa_loop_prefetch, gate_tree_ssa_loop_prefetch,\n\tpass_data_loop_prefetch, make_pass_loop_prefetch): Move to\n\ttree-ssa-loop-prefetch.c.\n\t(for_each_index, lsm_tmp_name_add, gen_lsm_tmp_name): Relocate from\n\ttree-ssa-loop-im.c.\n\t(get_lsm_tmp_name): Relocate and add suffix parameter.\n\t(tree_num_loop_insns): Relocate from tree-ssa-ivcanon.c.\n\t* tree-scalar-evolution.h (simple_iv): Don't use affive_iv typedef.\n\t* cfgloop.c (record_niter_bound, estimated_loop_iterations_int,\n\tmax_stmt_executions_int): Move from tree-ssa-loop-niter.c.\n\t(get_estimated_loop_iterations): Factor out accessor from \n\testimated_loop_iterations in tree-ssa-loop-niter.c.\n\t(get_max_loop_iterations): Factor out accessor from _max_loop_iterations\n\tin tree-ssa-niter.c.\n\t* loop-unroll.c (decide_unroll_constant_iterations,\n\tdecide_unroll_runtime_iterations, decide_peel_simple,\n\tdecide_unroll_stupid): Use new get_* accessors.\n\nFrom-SVN: r203317", "tree": {"sha": "daafe0156356e7c30b23700b33e51ef2d3acc1a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/daafe0156356e7c30b23700b33e51ef2d3acc1a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/713438778be52a0cb0533fad271c05481435b519", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/713438778be52a0cb0533fad271c05481435b519", "html_url": "https://github.com/Rust-GCC/gccrs/commit/713438778be52a0cb0533fad271c05481435b519", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/713438778be52a0cb0533fad271c05481435b519/comments", "author": null, "committer": null, "parents": [{"sha": "826cacfe24c4643799d85f07b25d15a0d3b76bc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/826cacfe24c4643799d85f07b25d15a0d3b76bc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/826cacfe24c4643799d85f07b25d15a0d3b76bc0"}], "stats": {"total": 1890, "additions": 1034, "deletions": 856}, "files": [{"sha": "92fc367e69a77eef141bf2a066b2b0694d5264c2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713438778be52a0cb0533fad271c05481435b519/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713438778be52a0cb0533fad271c05481435b519/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=713438778be52a0cb0533fad271c05481435b519", "patch": "@@ -1,3 +1,78 @@\n+2013-10-09  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* tree-flow.h: Move some protoypes.  Include new tree-ssa-loop.h.\n+\t(struct affine_iv, struct tree_niter_desc): Move to tree-ssa-loop.h.\n+\t(enum move_pos): Move to tree-ssa-loop-im.h\n+\t* cfgloop.h: Move some prototypes.\n+\t(gcov_type_to_double_int): relocate from tree-ssa-loop.niter.c.\n+\t* tree-flow-inline.h (loop_containing_stmt): Move to tree-ssa-loop.h.\n+\t* tree-ssa-loop.h: New File.  Include other tree-ssa-loop-*.h files.\n+\t(struct affine_iv, struct tree_niter_desc): Relocate from tree-flow.h.\n+\t(loop_containing_stmt): Relocate from tree-flow-inline.h.\n+\t* tree-ssa-loop-ch.c: (do_while_loop_p): Make static.\n+\t* tree-ssa-loop-im.c (for_each_index): Move to tree-ssa-loop.c.\n+\t(enum move_pos): Relocate here.\n+\t(lsm_tmp_name_add, gen_lsm_tmp_name, get_lsm_tmp_name): Move to\n+\ttree-ssa-loop.c.\n+\t(execute_sm_if_changed_flag_set): Change get_lsm_tmp_name call.\n+\t(tree_ssa_loop_im, gate_tree_ssa_loop_im, pass_data_lim, make_pass_lim):\n+\tRelocate here from tree-ssa-loop.c.\n+\t* tree-ssa-loop-ivcanon.c (tree_num_loop_insns): Move to \n+\ttree-ssa-loop.c.\n+\t(loop_edge_to_cancel, unloop_loops): Make static.\n+\t(tree_ssa_loop_ivcanon, gate_tree_ssa_loop_ivcanon, pass_data_iv_canon,\n+\tmake_pass_iv_canon): Relocate from tree-ssa-loop.c.\n+\t(tree_complete_unroll, gate_tree_complete_unroll,\n+\tpass_data_complete_unroll, make_pass_complete_unroll): Relocate here.\n+\t(tree_complete_unroll_inner, gate_tree_complete_unroll_inner,\n+\tpass_data_complete_unrolli, make_pass_complete_unrolli): Relocate here.\n+\t* tree-ssa-loop-ivopts.c: Remove local prototypes.\n+\t(stmt_invariant_in_loop_p): Remove unused function.\n+\t* tree-ssa-loop-ivopts.h: New file.  Add prototypes.\n+\t* tree-ssa-loop-manip.h: New file.  Add prototypes.\n+\t* tree-ssa-loop-niter.c (record_niter_bound): Move to cfgloop.c.\n+\t(gcov_type_to_double_int): Move to cfgloop.h.\n+\t(double_int_cmp, bound_index,\n+\testimate_numbers_of_iterations_loop): Make static.\n+\t(estimated_loop_iterations): Factor out get_estimated_loop_iterations.\n+\t(max_loop_iterations): Factor out get_max_loop_iterations.\n+\t(estimated_loop_iterations_int, max_stmt_executions_int): Move to\n+\tcfgloop.c.\n+\t* tree-ssa-loop-niter.h: New file.  Add prototypes.\n+\t* tree-ssa-loop-prefetch.c (tree_ssa_loop_prefetch,\n+\tgate_tree_ssa_loop_prefetch, pass_data_loop_prefetch,\n+\tmake_pass_loop_prefetch): Relocate from tree-ssa-loop.c.\n+\t* tree-ssa-loop-unswitch.c (tree_ssa_loop_unswitch,\n+\tgate_tree_ssa_loop_unswitch, pass_data_tree_unswitch,\n+\tmake_pass_tree_unswitch): Relocate from tree-ssa-loop.c.\n+\t* tree-ssa-loop.c (tree_ssa_loop_im, gate_tree_ssa_loop_im,\n+\tpass_data_lim, make_pass_lim): Move to tree-ssa-loop-im.c.\n+\t(tree_ssa_loop_unswitch, gate_tree_ssa_loop_unswitch,\n+\tpass_data_tree_unswitch, make_pass_tree_unswitch): Move.\n+\t(tree_ssa_loop_ivcanon, gate_tree_ssa_loop_ivcanon, pass_data_iv_canon,\n+\tmake_pass_iv_canon, tree_complete_unroll, gate_tree_complete_unroll,\n+\tpass_data_complete_unroll, make_pass_complete_unroll,\n+\ttree_complete_unroll_inner, gate_tree_complete_unroll_inner,\n+\tpass_data_complete_unrolli, make_pass_complete_unrolli): Move to\n+\ttree-ssa-loop-ivcanon.c.\n+\t(tree_ssa_loop_prefetch, gate_tree_ssa_loop_prefetch,\n+\tpass_data_loop_prefetch, make_pass_loop_prefetch): Move to\n+\ttree-ssa-loop-prefetch.c.\n+\t(for_each_index, lsm_tmp_name_add, gen_lsm_tmp_name): Relocate from\n+\ttree-ssa-loop-im.c.\n+\t(get_lsm_tmp_name): Relocate and add suffix parameter.\n+\t(tree_num_loop_insns): Relocate from tree-ssa-ivcanon.c.\n+\t* tree-scalar-evolution.h (simple_iv): Don't use affive_iv typedef.\n+\t* cfgloop.c (record_niter_bound, estimated_loop_iterations_int,\n+\tmax_stmt_executions_int): Move from tree-ssa-loop-niter.c.\n+\t(get_estimated_loop_iterations): Factor out accessor from \n+\testimated_loop_iterations in tree-ssa-loop-niter.c.\n+\t(get_max_loop_iterations): Factor out accessor from _max_loop_iterations\n+\tin tree-ssa-niter.c.\n+\t* loop-unroll.c (decide_unroll_constant_iterations,\n+\tdecide_unroll_runtime_iterations, decide_peel_simple,\n+\tdecide_unroll_stupid): Use new get_* accessors.\n+\n 2013-10-09  Marc Glisse  <marc.glisse@inria.fr>\n \n \tPR tree-optimization/20318"}, {"sha": "272a675ab7dc8d7c909acb579966c8ca8c27d54e", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713438778be52a0cb0533fad271c05481435b519/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713438778be52a0cb0533fad271c05481435b519/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=713438778be52a0cb0533fad271c05481435b519", "patch": "@@ -1781,3 +1781,113 @@ get_loop_location (struct loop *loop)\n   return DECL_SOURCE_LOCATION (current_function_decl);\n }\n \n+/* Records that every statement in LOOP is executed I_BOUND times.\n+   REALISTIC is true if I_BOUND is expected to be close to the real number\n+   of iterations.  UPPER is true if we are sure the loop iterates at most\n+   I_BOUND times.  */\n+\n+void\n+record_niter_bound (struct loop *loop, double_int i_bound, bool realistic,\n+\t\t    bool upper)\n+{\n+  /* Update the bounds only when there is no previous estimation, or when the\n+     current estimation is smaller.  */\n+  if (upper\n+      && (!loop->any_upper_bound\n+\t  || i_bound.ult (loop->nb_iterations_upper_bound)))\n+    {\n+      loop->any_upper_bound = true;\n+      loop->nb_iterations_upper_bound = i_bound;\n+    }\n+  if (realistic\n+      && (!loop->any_estimate\n+\t  || i_bound.ult (loop->nb_iterations_estimate)))\n+    {\n+      loop->any_estimate = true;\n+      loop->nb_iterations_estimate = i_bound;\n+    }\n+\n+  /* If an upper bound is smaller than the realistic estimate of the\n+     number of iterations, use the upper bound instead.  */\n+  if (loop->any_upper_bound\n+      && loop->any_estimate\n+      && loop->nb_iterations_upper_bound.ult (loop->nb_iterations_estimate))\n+    loop->nb_iterations_estimate = loop->nb_iterations_upper_bound;\n+}\n+\n+/* Similar to estimated_loop_iterations, but returns the estimate only\n+   if it fits to HOST_WIDE_INT.  If this is not the case, or the estimate\n+   on the number of iterations of LOOP could not be derived, returns -1.  */\n+\n+HOST_WIDE_INT\n+estimated_loop_iterations_int (struct loop *loop)\n+{\n+  double_int nit;\n+  HOST_WIDE_INT hwi_nit;\n+\n+  if (!get_estimated_loop_iterations (loop, &nit))\n+    return -1;\n+\n+  if (!nit.fits_shwi ())\n+    return -1;\n+  hwi_nit = nit.to_shwi ();\n+\n+  return hwi_nit < 0 ? -1 : hwi_nit;\n+}\n+\n+/* Returns an upper bound on the number of executions of statements\n+   in the LOOP.  For statements before the loop exit, this exceeds\n+   the number of execution of the latch by one.  */\n+\n+HOST_WIDE_INT\n+max_stmt_executions_int (struct loop *loop)\n+{\n+  HOST_WIDE_INT nit = max_loop_iterations_int (loop);\n+  HOST_WIDE_INT snit;\n+\n+  if (nit == -1)\n+    return -1;\n+\n+  snit = (HOST_WIDE_INT) ((unsigned HOST_WIDE_INT) nit + 1);\n+\n+  /* If the computation overflows, return -1.  */\n+  return snit < 0 ? -1 : snit;\n+}\n+\n+/* Sets NIT to the estimated number of executions of the latch of the\n+   LOOP.  If we have no reliable estimate, the function returns false, otherwise\n+   returns true.  */\n+\n+bool\n+get_estimated_loop_iterations (struct loop *loop, double_int *nit)\n+{\n+  /* Even if the bound is not recorded, possibly we can derrive one from\n+     profile.  */\n+  if (!loop->any_estimate)\n+    {\n+      if (loop->header->count)\n+\t{\n+          *nit = gcov_type_to_double_int\n+\t\t   (expected_loop_iterations_unbounded (loop) + 1);\n+\t  return true;\n+\t}\n+      return false;\n+    }\n+\n+  *nit = loop->nb_iterations_estimate;\n+  return true;\n+}\n+\n+/* Sets NIT to an upper bound for the maximum number of executions of the\n+   latch of the LOOP.  If we have no reliable estimate, the function returns\n+   false, otherwise returns true.  */\n+\n+bool\n+get_max_loop_iterations (struct loop *loop, double_int *nit)\n+{\n+  if (!loop->any_upper_bound)\n+    return false;\n+\n+  *nit = loop->nb_iterations_upper_bound;\n+  return true;\n+}"}, {"sha": "9048e0226077ffd1d4c6dbf7442b52f4f0229711", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713438778be52a0cb0533fad271c05481435b519/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713438778be52a0cb0533fad271c05481435b519/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=713438778be52a0cb0533fad271c05481435b519", "patch": "@@ -255,7 +255,6 @@ extern bool flow_bb_inside_loop_p (const struct loop *, const_basic_block);\n extern struct loop * find_common_loop (struct loop *, struct loop *);\n struct loop *superloop_at_depth (struct loop *, unsigned);\n struct eni_weights_d;\n-extern unsigned tree_num_loop_insns (struct loop *, struct eni_weights_d *);\n extern int num_loop_insns (const struct loop *);\n extern int average_num_loop_insns (const struct loop *);\n extern unsigned get_loop_level (const struct loop *);\n@@ -306,16 +305,6 @@ gcov_type expected_loop_iterations_unbounded (const struct loop *);\n extern unsigned expected_loop_iterations (const struct loop *);\n extern rtx doloop_condition_get (rtx);\n \n-void estimate_numbers_of_iterations_loop (struct loop *);\n-void record_niter_bound (struct loop *, double_int, bool, bool);\n-bool estimated_loop_iterations (struct loop *, double_int *);\n-bool max_loop_iterations (struct loop *, double_int *);\n-HOST_WIDE_INT estimated_loop_iterations_int (struct loop *);\n-HOST_WIDE_INT max_loop_iterations_int (struct loop *);\n-bool max_stmt_executions (struct loop *, double_int *);\n-bool estimated_stmt_executions (struct loop *, double_int *);\n-HOST_WIDE_INT max_stmt_executions_int (struct loop *);\n-HOST_WIDE_INT estimated_stmt_executions_int (struct loop *);\n \n /* Loop manipulation.  */\n extern bool can_duplicate_loop_p (const struct loop *loop);\n@@ -735,7 +724,6 @@ enum\n extern void unroll_and_peel_loops (int);\n extern void doloop_optimize_loops (void);\n extern void move_loop_invariants (void);\n-extern bool finite_loop_p (struct loop *);\n extern void scale_loop_profile (struct loop *loop, int scale, gcov_type iteration_bound);\n extern vec<basic_block> get_loop_hot_path (const struct loop *loop);\n \n@@ -751,5 +739,26 @@ loop_outermost (struct loop *loop)\n   return (*loop->superloops)[1];\n }\n \n+extern void record_niter_bound (struct loop *, double_int, bool, bool);\n+extern HOST_WIDE_INT estimated_loop_iterations_int (struct loop *);\n+extern HOST_WIDE_INT max_loop_iterations_int (struct loop *);\n+extern bool get_estimated_loop_iterations (struct loop *loop, double_int *nit);\n+extern bool get_max_loop_iterations (struct loop *loop, double_int *nit);\n \n+/* Converts VAL to double_int.  */\n+\n+static inline double_int\n+gcov_type_to_double_int (gcov_type val)\n+{\n+  double_int ret;\n+\n+  ret.low = (unsigned HOST_WIDE_INT) val;\n+  /* If HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_WIDEST_INT, avoid shifting by\n+     the size of type.  */\n+  val >>= HOST_BITS_PER_WIDE_INT - 1;\n+  val >>= 1;\n+  ret.high = (unsigned HOST_WIDE_INT) val;\n+\n+  return ret;\n+}\n #endif /* GCC_CFGLOOP_H */"}, {"sha": "7fd317713fba3817d1487e0849b37d39f1e8e826", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713438778be52a0cb0533fad271c05481435b519/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713438778be52a0cb0533fad271c05481435b519/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=713438778be52a0cb0533fad271c05481435b519", "patch": "@@ -694,8 +694,8 @@ decide_unroll_constant_iterations (struct loop *loop, int flags)\n      than one exit it may well loop less than determined maximal number\n      of iterations.  */\n   if (desc->niter < 2 * nunroll\n-      || ((estimated_loop_iterations (loop, &iterations)\n-\t   || max_loop_iterations (loop, &iterations))\n+      || ((get_estimated_loop_iterations (loop, &iterations)\n+\t   || get_max_loop_iterations (loop, &iterations))\n \t  && iterations.ult (double_int::from_shwi (2 * nunroll))))\n     {\n       if (dump_file)\n@@ -999,8 +999,8 @@ decide_unroll_runtime_iterations (struct loop *loop, int flags)\n     }\n \n   /* Check whether the loop rolls.  */\n-  if ((estimated_loop_iterations (loop, &iterations)\n-       || max_loop_iterations (loop, &iterations))\n+  if ((get_estimated_loop_iterations (loop, &iterations)\n+       || get_max_loop_iterations (loop, &iterations))\n       && iterations.ult (double_int::from_shwi (2 * nunroll)))\n     {\n       if (dump_file)\n@@ -1388,7 +1388,7 @@ decide_peel_simple (struct loop *loop, int flags)\n     }\n \n   /* If we have realistic estimate on number of iterations, use it.  */\n-  if (estimated_loop_iterations (loop, &iterations))\n+  if (get_estimated_loop_iterations (loop, &iterations))\n     {\n       if (double_int::from_shwi (npeel).ule (iterations))\n \t{\n@@ -1406,7 +1406,7 @@ decide_peel_simple (struct loop *loop, int flags)\n     }\n   /* If we have small enough bound on iterations, we can still peel (completely\n      unroll).  */\n-  else if (max_loop_iterations (loop, &iterations)\n+  else if (get_max_loop_iterations (loop, &iterations)\n            && iterations.ult (double_int::from_shwi (npeel)))\n     npeel = iterations.to_shwi () + 1;\n   else\n@@ -1556,8 +1556,8 @@ decide_unroll_stupid (struct loop *loop, int flags)\n     }\n \n   /* Check whether the loop rolls.  */\n-  if ((estimated_loop_iterations (loop, &iterations)\n-       || max_loop_iterations (loop, &iterations))\n+  if ((get_estimated_loop_iterations (loop, &iterations)\n+       || get_max_loop_iterations (loop, &iterations))\n       && iterations.ult (double_int::from_shwi (2 * nunroll)))\n     {\n       if (dump_file)"}, {"sha": "8243f29774748a2067669cc71d1fd819989644cd", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713438778be52a0cb0533fad271c05481435b519/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713438778be52a0cb0533fad271c05481435b519/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=713438778be52a0cb0533fad271c05481435b519", "patch": "@@ -107,21 +107,6 @@ may_be_aliased (const_tree var)\n \t      || TREE_ADDRESSABLE (var)));\n }\n \n-\n-/* Returns the loop of the statement STMT.  */\n-\n-static inline struct loop *\n-loop_containing_stmt (gimple stmt)\n-{\n-  basic_block bb = gimple_bb (stmt);\n-  if (!bb)\n-    return NULL;\n-\n-  return bb->loop_father;\n-}\n-\n-\n-\n /* Return true if VAR cannot be modified by the program.  */\n \n static inline bool"}, {"sha": "2aed9ddfee1c59481bf046fb7909ad662230f89a", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 111, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713438778be52a0cb0533fad271c05481435b519/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713438778be52a0cb0533fad271c05481435b519/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=713438778be52a0cb0533fad271c05481435b519", "patch": "@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pretty-print.h\"\n #include \"gimple-low.h\"\n #include \"tree-into-ssa.h\"\n+#include \"tree-ssa-loop.h\"\n \n /* This structure is used to map a gimple statement to a label,\n    or list of labels to represent transaction restart.  */\n@@ -244,109 +245,19 @@ extern basic_block move_sese_region_to_fn (struct function *, basic_block,\n void remove_edge_and_dominated_blocks (edge);\n bool tree_node_can_be_shared (tree);\n \n-/* In tree-ssa-loop-ch.c  */\n-bool do_while_loop_p (struct loop *);\n-\n-/* Affine iv.  */\n-\n-typedef struct\n-{\n-  /* Iv = BASE + STEP * i.  */\n-  tree base, step;\n-\n-  /* True if this iv does not overflow.  */\n-  bool no_overflow;\n-} affine_iv;\n-\n-/* Description of number of iterations of a loop.  All the expressions inside\n-   the structure can be evaluated at the end of the loop's preheader\n-   (and due to ssa form, also anywhere inside the body of the loop).  */\n-\n-struct tree_niter_desc\n-{\n-  tree assumptions;\t/* The boolean expression.  If this expression evaluates\n-\t\t\t   to false, then the other fields in this structure\n-\t\t\t   should not be used; there is no guarantee that they\n-\t\t\t   will be correct.  */\n-  tree may_be_zero;\t/* The boolean expression.  If it evaluates to true,\n-\t\t\t   the loop will exit in the first iteration (i.e.\n-\t\t\t   its latch will not be executed), even if the niter\n-\t\t\t   field says otherwise.  */\n-  tree niter;\t\t/* The expression giving the number of iterations of\n-\t\t\t   a loop (provided that assumptions == true and\n-\t\t\t   may_be_zero == false), more precisely the number\n-\t\t\t   of executions of the latch of the loop.  */\n-  double_int max;\t/* The upper bound on the number of iterations of\n-\t\t\t   the loop.  */\n-\n-  /* The simplified shape of the exit condition.  The loop exits if\n-     CONTROL CMP BOUND is false, where CMP is one of NE_EXPR,\n-     LT_EXPR, or GT_EXPR, and step of CONTROL is positive if CMP is\n-     LE_EXPR and negative if CMP is GE_EXPR.  This information is used\n-     by loop unrolling.  */\n-  affine_iv control;\n-  tree bound;\n-  enum tree_code cmp;\n-};\n \n \n /* In tree-ssa-loop*.c  */\n \n-unsigned int tree_ssa_lim (void);\n-unsigned int tree_ssa_unswitch_loops (void);\n-unsigned int canonicalize_induction_variables (void);\n-unsigned int tree_unroll_loops_completely (bool, bool);\n-unsigned int tree_ssa_prefetch_arrays (void);\n-void tree_ssa_iv_optimize (void);\n unsigned tree_predictive_commoning (void);\n-tree canonicalize_loop_ivs (struct loop *, tree *, bool);\n bool parallelize_loops (void);\n \n-bool loop_only_exit_p (const struct loop *, const_edge);\n-bool number_of_iterations_exit (struct loop *, edge,\n-\t\t\t\tstruct tree_niter_desc *niter, bool,\n-\t\t\t\tbool every_iteration = true);\n-tree find_loop_niter (struct loop *, edge *);\n-tree loop_niter_by_eval (struct loop *, edge);\n-tree find_loop_niter_by_eval (struct loop *, edge *);\n-void estimate_numbers_of_iterations (void);\n-bool scev_probably_wraps_p (tree, tree, gimple, struct loop *, bool);\n bool convert_affine_scev (struct loop *, tree, tree *, tree *, gimple, bool);\n \n-bool nowrap_type_p (tree);\n enum ev_direction {EV_DIR_GROWS, EV_DIR_DECREASES, EV_DIR_UNKNOWN};\n enum ev_direction scev_direction (const_tree);\n \n-void free_numbers_of_iterations_estimates (void);\n-void free_numbers_of_iterations_estimates_loop (struct loop *);\n-void rewrite_into_loop_closed_ssa (bitmap, unsigned);\n-void verify_loop_closed_ssa (bool);\n-bool for_each_index (tree *, bool (*) (tree, tree *, void *), void *);\n-void create_iv (tree, tree, tree, struct loop *, gimple_stmt_iterator *, bool,\n-\t\ttree *, tree *);\n-basic_block split_loop_exit_edge (edge);\n-void standard_iv_increment_position (struct loop *, gimple_stmt_iterator *,\n-\t\t\t\t     bool *);\n-basic_block ip_end_pos (struct loop *);\n-basic_block ip_normal_pos (struct loop *);\n-bool gimple_duplicate_loop_to_header_edge (struct loop *, edge,\n-\t\t\t\t\t unsigned int, sbitmap,\n-\t\t\t\t\t edge, vec<edge> *,\n-\t\t\t\t\t int);\n struct loop *slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *, edge);\n-tree expand_simple_operations (tree);\n-void substitute_in_loop_info (struct loop *, tree, tree);\n-edge single_dom_exit (struct loop *);\n-bool can_unroll_loop_p (struct loop *loop, unsigned factor,\n-\t\t\tstruct tree_niter_desc *niter);\n-void tree_unroll_loop (struct loop *, unsigned,\n-\t\t       edge, struct tree_niter_desc *);\n-typedef void (*transform_callback)(struct loop *, void *);\n-void tree_transform_and_unroll_loop (struct loop *, unsigned,\n-\t\t\t\t     edge, struct tree_niter_desc *,\n-\t\t\t\t     transform_callback, void *);\n-bool contains_abnormal_ssa_name_p (tree);\n-bool stmt_dominates_stmt_p (gimple, gimple);\n \n /* In tree-ssa-threadedge.c */\n extern void threadedge_initialize_values (void);\n@@ -362,19 +273,6 @@ extern void thread_across_edge (gimple, edge, bool,\n \t\t\t\tvec<tree> *, tree (*) (gimple, gimple));\n extern void propagate_threaded_block_debug_into (basic_block, basic_block);\n \n-/* In tree-ssa-loop-im.c  */\n-/* The possibilities of statement movement.  */\n-\n-enum move_pos\n-  {\n-    MOVE_IMPOSSIBLE,\t\t/* No movement -- side effect expression.  */\n-    MOVE_PRESERVE_EXECUTION,\t/* Must not cause the non-executed statement\n-\t\t\t\t   become executed -- memory accesses, ... */\n-    MOVE_POSSIBLE\t\t/* Unlimited movement.  */\n-  };\n-extern enum move_pos movement_possibility (gimple);\n-char *get_lsm_tmp_name (tree, unsigned);\n-\n /* In tree-loop-linear.c  */\n extern void linear_transform_loops (void);\n extern unsigned perfect_loop_nest_depth (struct loop *);\n@@ -385,14 +283,6 @@ extern void graphite_transform_loops (void);\n /* In tree-data-ref.c  */\n extern void tree_check_data_deps (void);\n \n-/* In tree-ssa-loop-ivopts.c  */\n-bool expr_invariant_in_loop_p (struct loop *, tree);\n-bool stmt_invariant_in_loop_p (struct loop *, gimple);\n-struct loop *outermost_invariant_loop_for_expr (struct loop *, tree);\n-bool multiplier_allowed_in_address_p (HOST_WIDE_INT, enum machine_mode,\n-\t\t\t\t      addr_space_t);\n-bool may_be_nonaddressable_p (tree expr);\n-\n /* In gimplify.c  */\n tree force_gimple_operand_1 (tree, gimple_seq *, gimple_predicate, tree);\n tree force_gimple_operand (tree, gimple_seq *, bool, tree);"}, {"sha": "db7ac4c66f046ae4834d6fe8e2f8d3aa4fc04663", "filename": "gcc/tree-scalar-evolution.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713438778be52a0cb0533fad271c05481435b519/gcc%2Ftree-scalar-evolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713438778be52a0cb0533fad271c05481435b519/gcc%2Ftree-scalar-evolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.h?ref=713438778be52a0cb0533fad271c05481435b519", "patch": "@@ -36,7 +36,8 @@ extern tree resolve_mixers (struct loop *, tree);\n extern void gather_stats_on_scev_database (void);\n extern unsigned int scev_const_prop (void);\n extern bool expression_expensive_p (tree);\n-extern bool simple_iv (struct loop *, struct loop *, tree, affine_iv *, bool);\n+extern bool simple_iv (struct loop *, struct loop *, tree, struct affine_iv_d *,\n+\t\t       bool);\n extern tree compute_overall_effect_of_inner_loop (struct loop *, tree);\n \n /* Returns the basic block preceding LOOP or ENTRY_BLOCK_PTR when the"}, {"sha": "b74855e62de830fdf7163693a65dc7f14ba6c127", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713438778be52a0cb0533fad271c05481435b519/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713438778be52a0cb0533fad271c05481435b519/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=713438778be52a0cb0533fad271c05481435b519", "patch": "@@ -29,7 +29,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"tree-inline.h\"\n #include \"flags.h\"\n-#include \"tree-inline.h\"\n \n /* Duplicates headers of loops if they are small enough, so that the statements\n    in the loop body are always executed when the loop is entered.  This\n@@ -100,7 +99,7 @@ should_duplicate_loop_header_p (basic_block header, struct loop *loop,\n \n /* Checks whether LOOP is a do-while style loop.  */\n \n-bool\n+static bool\n do_while_loop_p (struct loop *loop)\n {\n   gimple stmt = last_stmt (loop->latch);"}, {"sha": "84f50cdb92d357e4e91781c34ca69ebf0d2cc10e", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 67, "deletions": 208, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713438778be52a0cb0533fad271c05481435b519/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713438778be52a0cb0533fad271c05481435b519/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=713438778be52a0cb0533fad271c05481435b519", "patch": "@@ -242,98 +242,16 @@ clear_lim_data (gimple stmt)\n   *p = NULL;\n }\n \n-/* Calls CBCK for each index in memory reference ADDR_P.  There are two\n-   kinds situations handled; in each of these cases, the memory reference\n-   and DATA are passed to the callback:\n \n-   Access to an array: ARRAY_{RANGE_}REF (base, index).  In this case we also\n-   pass the pointer to the index to the callback.\n-\n-   Pointer dereference: INDIRECT_REF (addr).  In this case we also pass the\n-   pointer to addr to the callback.\n-\n-   If the callback returns false, the whole search stops and false is returned.\n-   Otherwise the function returns true after traversing through the whole\n-   reference *ADDR_P.  */\n-\n-bool\n-for_each_index (tree *addr_p, bool (*cbck) (tree, tree *, void *), void *data)\n-{\n-  tree *nxt, *idx;\n-\n-  for (; ; addr_p = nxt)\n-    {\n-      switch (TREE_CODE (*addr_p))\n-\t{\n-\tcase SSA_NAME:\n-\t  return cbck (*addr_p, addr_p, data);\n-\n-\tcase MEM_REF:\n-\t  nxt = &TREE_OPERAND (*addr_p, 0);\n-\t  return cbck (*addr_p, nxt, data);\n-\n-\tcase BIT_FIELD_REF:\n-\tcase VIEW_CONVERT_EXPR:\n-\tcase REALPART_EXPR:\n-\tcase IMAGPART_EXPR:\n-\t  nxt = &TREE_OPERAND (*addr_p, 0);\n-\t  break;\n-\n-\tcase COMPONENT_REF:\n-\t  /* If the component has varying offset, it behaves like index\n-\t     as well.  */\n-\t  idx = &TREE_OPERAND (*addr_p, 2);\n-\t  if (*idx\n-\t      && !cbck (*addr_p, idx, data))\n-\t    return false;\n-\n-\t  nxt = &TREE_OPERAND (*addr_p, 0);\n-\t  break;\n+/* The possibilities of statement movement.  */\n+enum move_pos\n+  {\n+    MOVE_IMPOSSIBLE,\t\t/* No movement -- side effect expression.  */\n+    MOVE_PRESERVE_EXECUTION,\t/* Must not cause the non-executed statement\n+\t\t\t\t   become executed -- memory accesses, ... */\n+    MOVE_POSSIBLE\t\t/* Unlimited movement.  */\n+  };\n \n-\tcase ARRAY_REF:\n-\tcase ARRAY_RANGE_REF:\n-\t  nxt = &TREE_OPERAND (*addr_p, 0);\n-\t  if (!cbck (*addr_p, &TREE_OPERAND (*addr_p, 1), data))\n-\t    return false;\n-\t  break;\n-\n-\tcase VAR_DECL:\n-\tcase PARM_DECL:\n-\tcase CONST_DECL:\n-\tcase STRING_CST:\n-\tcase RESULT_DECL:\n-\tcase VECTOR_CST:\n-\tcase COMPLEX_CST:\n-\tcase INTEGER_CST:\n-\tcase REAL_CST:\n-\tcase FIXED_CST:\n-\tcase CONSTRUCTOR:\n-\t  return true;\n-\n-\tcase ADDR_EXPR:\n-\t  gcc_assert (is_gimple_min_invariant (*addr_p));\n-\t  return true;\n-\n-\tcase TARGET_MEM_REF:\n-\t  idx = &TMR_BASE (*addr_p);\n-\t  if (*idx\n-\t      && !cbck (*addr_p, idx, data))\n-\t    return false;\n-\t  idx = &TMR_INDEX (*addr_p);\n-\t  if (*idx\n-\t      && !cbck (*addr_p, idx, data))\n-\t    return false;\n-\t  idx = &TMR_INDEX2 (*addr_p);\n-\t  if (*idx\n-\t      && !cbck (*addr_p, idx, data))\n-\t    return false;\n-\t  return true;\n-\n-\tdefault:\n-    \t  gcc_unreachable ();\n-\t}\n-    }\n-}\n \n /* If it is possible to hoist the statement STMT unconditionally,\n    returns MOVE_POSSIBLE.\n@@ -1741,122 +1659,6 @@ first_mem_ref_loc (struct loop *loop, mem_ref_p ref)\n   return locp;\n }\n \n-/* The name and the length of the currently generated variable\n-   for lsm.  */\n-#define MAX_LSM_NAME_LENGTH 40\n-static char lsm_tmp_name[MAX_LSM_NAME_LENGTH + 1];\n-static int lsm_tmp_name_length;\n-\n-/* Adds S to lsm_tmp_name.  */\n-\n-static void\n-lsm_tmp_name_add (const char *s)\n-{\n-  int l = strlen (s) + lsm_tmp_name_length;\n-  if (l > MAX_LSM_NAME_LENGTH)\n-    return;\n-\n-  strcpy (lsm_tmp_name + lsm_tmp_name_length, s);\n-  lsm_tmp_name_length = l;\n-}\n-\n-/* Stores the name for temporary variable that replaces REF to\n-   lsm_tmp_name.  */\n-\n-static void\n-gen_lsm_tmp_name (tree ref)\n-{\n-  const char *name;\n-\n-  switch (TREE_CODE (ref))\n-    {\n-    case MEM_REF:\n-    case TARGET_MEM_REF:\n-      gen_lsm_tmp_name (TREE_OPERAND (ref, 0));\n-      lsm_tmp_name_add (\"_\");\n-      break;\n-\n-    case ADDR_EXPR:\n-      gen_lsm_tmp_name (TREE_OPERAND (ref, 0));\n-      break;\n-\n-    case BIT_FIELD_REF:\n-    case VIEW_CONVERT_EXPR:\n-    case ARRAY_RANGE_REF:\n-      gen_lsm_tmp_name (TREE_OPERAND (ref, 0));\n-      break;\n-\n-    case REALPART_EXPR:\n-      gen_lsm_tmp_name (TREE_OPERAND (ref, 0));\n-      lsm_tmp_name_add (\"_RE\");\n-      break;\n-\n-    case IMAGPART_EXPR:\n-      gen_lsm_tmp_name (TREE_OPERAND (ref, 0));\n-      lsm_tmp_name_add (\"_IM\");\n-      break;\n-\n-    case COMPONENT_REF:\n-      gen_lsm_tmp_name (TREE_OPERAND (ref, 0));\n-      lsm_tmp_name_add (\"_\");\n-      name = get_name (TREE_OPERAND (ref, 1));\n-      if (!name)\n-\tname = \"F\";\n-      lsm_tmp_name_add (name);\n-      break;\n-\n-    case ARRAY_REF:\n-      gen_lsm_tmp_name (TREE_OPERAND (ref, 0));\n-      lsm_tmp_name_add (\"_I\");\n-      break;\n-\n-    case SSA_NAME:\n-    case VAR_DECL:\n-    case PARM_DECL:\n-      name = get_name (ref);\n-      if (!name)\n-\tname = \"D\";\n-      lsm_tmp_name_add (name);\n-      break;\n-\n-    case STRING_CST:\n-      lsm_tmp_name_add (\"S\");\n-      break;\n-\n-    case RESULT_DECL:\n-      lsm_tmp_name_add (\"R\");\n-      break;\n-\n-    case INTEGER_CST:\n-      /* Nothing.  */\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-/* Determines name for temporary variable that replaces REF.\n-   The name is accumulated into the lsm_tmp_name variable.\n-   N is added to the name of the temporary.  */\n-\n-char *\n-get_lsm_tmp_name (tree ref, unsigned n)\n-{\n-  char ns[2];\n-\n-  lsm_tmp_name_length = 0;\n-  gen_lsm_tmp_name (ref);\n-  lsm_tmp_name_add (\"_lsm\");\n-  if (n < 10)\n-    {\n-      ns[0] = '0' + n;\n-      ns[1] = 0;\n-      lsm_tmp_name_add (ns);\n-    }\n-  return lsm_tmp_name;\n-}\n-\n struct prev_flag_edges {\n   /* Edge to insert new flag comparison code.  */\n   edge append_cond_position;\n@@ -2026,8 +1828,7 @@ static tree\n execute_sm_if_changed_flag_set (struct loop *loop, mem_ref_p ref)\n {\n   tree flag;\n-  char *str = get_lsm_tmp_name (ref->mem.ref, ~0);\n-  lsm_tmp_name_add (\"_flag\");\n+  char *str = get_lsm_tmp_name (ref->mem.ref, ~0, \"_flag\");\n   flag = create_tmp_reg (boolean_type_node, str);\n   for_all_locs_in_loop (loop, ref, sm_set_flag_if_changed (flag));\n   return flag;\n@@ -2639,3 +2440,61 @@ tree_ssa_lim (void)\n \n   return todo;\n }\n+\n+/* Loop invariant motion pass.  */\n+\n+static unsigned int\n+tree_ssa_loop_im (void)\n+{\n+  if (number_of_loops (cfun) <= 1)\n+    return 0;\n+\n+  return tree_ssa_lim ();\n+}\n+\n+static bool\n+gate_tree_ssa_loop_im (void)\n+{\n+  return flag_tree_loop_im != 0;\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_lim =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"lim\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_LIM, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_lim : public gimple_opt_pass\n+{\n+public:\n+  pass_lim (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_lim, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_lim (m_ctxt); }\n+  bool gate () { return gate_tree_ssa_loop_im (); }\n+  unsigned int execute () { return tree_ssa_loop_im (); }\n+\n+}; // class pass_lim\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_lim (gcc::context *ctxt)\n+{\n+  return new pass_lim (ctxt);\n+}\n+\n+"}, {"sha": "8db5b9ede7e79834a0d8da6c40a6d7fa1ecd1700", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 181, "deletions": 19, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713438778be52a0cb0533fad271c05481435b519/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713438778be52a0cb0533fad271c05481435b519/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=713438778be52a0cb0533fad271c05481435b519", "patch": "@@ -107,23 +107,6 @@ create_canonical_iv (struct loop *loop, edge exit, tree niter)\n   update_stmt (cond);\n }\n \n-/* Computes an estimated number of insns in LOOP, weighted by WEIGHTS.  */\n-\n-unsigned\n-tree_num_loop_insns (struct loop *loop, eni_weights *weights)\n-{\n-  basic_block *body = get_loop_body (loop);\n-  gimple_stmt_iterator gsi;\n-  unsigned size = 0, i;\n-\n-  for (i = 0; i < loop->num_nodes; i++)\n-    for (gsi = gsi_start_bb (body[i]); !gsi_end_p (gsi); gsi_next (&gsi))\n-      size += estimate_num_insns (gsi_stmt (gsi), weights);\n-  free (body);\n-\n-  return size;\n-}\n-\n /* Describe size of loop as detected by tree_estimate_loop_size.  */\n struct loop_size\n {\n@@ -422,7 +405,7 @@ estimated_unrolled_size (struct loop_size *size,\n    loop-niter identified as having undefined effect in the last iteration.\n    The other cases are hopefully rare and will be cleaned up later.  */\n \n-edge\n+static edge\n loop_edge_to_cancel (struct loop *loop)\n {\n   vec<edge> exits;\n@@ -598,7 +581,7 @@ static vec<int> loops_to_unloop_nunroll;\n    LOOP_CLOSED_SSA_INVALIDATED is used to bookkepp the case\n    when we need to go into loop closed SSA form.  */\n \n-void\n+static void\n unloop_loops (bitmap loop_closed_ssa_invalidated,\n \t      bool *irred_invalidated)\n {\n@@ -1253,3 +1236,182 @@ tree_unroll_loops_completely (bool may_increase_size, bool unroll_outer)\n \n   return 0;\n }\n+\n+/* Canonical induction variable creation pass.  */\n+\n+static unsigned int\n+tree_ssa_loop_ivcanon (void)\n+{\n+  if (number_of_loops (cfun) <= 1)\n+    return 0;\n+\n+  return canonicalize_induction_variables ();\n+}\n+\n+static bool\n+gate_tree_ssa_loop_ivcanon (void)\n+{\n+  return flag_tree_loop_ivcanon != 0;\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_iv_canon =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"ivcanon\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_LOOP_IVCANON, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_iv_canon : public gimple_opt_pass\n+{\n+public:\n+  pass_iv_canon (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_iv_canon, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_tree_ssa_loop_ivcanon (); }\n+  unsigned int execute () { return tree_ssa_loop_ivcanon (); }\n+\n+}; // class pass_iv_canon\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_iv_canon (gcc::context *ctxt)\n+{\n+  return new pass_iv_canon (ctxt);\n+}\n+\n+/* Complete unrolling of loops.  */\n+\n+static unsigned int\n+tree_complete_unroll (void)\n+{\n+  if (number_of_loops (cfun) <= 1)\n+    return 0;\n+\n+  return tree_unroll_loops_completely (flag_unroll_loops\n+\t\t\t\t       || flag_peel_loops\n+\t\t\t\t       || optimize >= 3, true);\n+}\n+\n+static bool\n+gate_tree_complete_unroll (void)\n+{\n+  return true;\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_complete_unroll =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"cunroll\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_COMPLETE_UNROLL, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_complete_unroll : public gimple_opt_pass\n+{\n+public:\n+  pass_complete_unroll (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_complete_unroll, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_tree_complete_unroll (); }\n+  unsigned int execute () { return tree_complete_unroll (); }\n+\n+}; // class pass_complete_unroll\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_complete_unroll (gcc::context *ctxt)\n+{\n+  return new pass_complete_unroll (ctxt);\n+}\n+\n+/* Complete unrolling of inner loops.  */\n+\n+static unsigned int\n+tree_complete_unroll_inner (void)\n+{\n+  unsigned ret = 0;\n+\n+  loop_optimizer_init (LOOPS_NORMAL\n+\t\t       | LOOPS_HAVE_RECORDED_EXITS);\n+  if (number_of_loops (cfun) > 1)\n+    {\n+      scev_initialize ();\n+      ret = tree_unroll_loops_completely (optimize >= 3, false);\n+      free_numbers_of_iterations_estimates ();\n+      scev_finalize ();\n+    }\n+  loop_optimizer_finalize ();\n+\n+  return ret;\n+}\n+\n+static bool\n+gate_tree_complete_unroll_inner (void)\n+{\n+  return optimize >= 2;\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_complete_unrolli =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"cunrolli\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_COMPLETE_UNROLL, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_flow, /* todo_flags_finish */\n+};\n+\n+class pass_complete_unrolli : public gimple_opt_pass\n+{\n+public:\n+  pass_complete_unrolli (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_complete_unrolli, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_tree_complete_unroll_inner (); }\n+  unsigned int execute () { return tree_complete_unroll_inner (); }\n+\n+}; // class pass_complete_unrolli\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_complete_unrolli (gcc::context *ctxt)\n+{\n+  return new pass_complete_unrolli (ctxt);\n+}\n+\n+"}, {"sha": "5e8fa36f39494772c6a1ca2f80512a77c9439964", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713438778be52a0cb0533fad271c05481435b519/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713438778be52a0cb0533fad271c05481435b519/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=713438778be52a0cb0533fad271c05481435b519", "patch": "@@ -452,7 +452,6 @@ single_dom_exit (struct loop *loop)\n \n /* Dumps information about the induction variable IV to FILE.  */\n \n-extern void dump_iv (FILE *, struct iv *);\n void\n dump_iv (FILE *file, struct iv *iv)\n {\n@@ -497,7 +496,6 @@ dump_iv (FILE *file, struct iv *iv)\n \n /* Dumps information about the USE to FILE.  */\n \n-extern void dump_use (FILE *, struct iv_use *);\n void\n dump_use (FILE *file, struct iv_use *use)\n {\n@@ -541,7 +539,6 @@ dump_use (FILE *file, struct iv_use *use)\n \n /* Dumps information about the uses to FILE.  */\n \n-extern void dump_uses (FILE *, struct ivopts_data *);\n void\n dump_uses (FILE *file, struct ivopts_data *data)\n {\n@@ -559,7 +556,6 @@ dump_uses (FILE *file, struct ivopts_data *data)\n \n /* Dumps information about induction variable candidate CAND to FILE.  */\n \n-extern void dump_cand (FILE *, struct iv_cand *);\n void\n dump_cand (FILE *file, struct iv_cand *cand)\n {\n@@ -1454,29 +1450,6 @@ expr_invariant_in_loop_p (struct loop *loop, tree expr)\n   return true;\n }\n \n-/* Returns true if statement STMT is obviously invariant in LOOP,\n-   i.e. if all its operands on the RHS are defined outside of the LOOP.\n-   LOOP should not be the function body.  */\n-\n-bool\n-stmt_invariant_in_loop_p (struct loop *loop, gimple stmt)\n-{\n-  unsigned i;\n-  tree lhs;\n-\n-  gcc_assert (loop_depth (loop) > 0);\n-\n-  lhs = gimple_get_lhs (stmt);\n-  for (i = 0; i < gimple_num_ops (stmt); i++)\n-    {\n-      tree op = gimple_op (stmt, i);\n-      if (op != lhs && !expr_invariant_in_loop_p (loop, op))\n-\treturn false;\n-    }\n-\n-  return true;\n-}\n-\n /* Cumulates the steps of indices into DATA and replaces their values with the\n    initial ones.  Returns false when the value of the index cannot be determined.\n    Callback for for_each_index.  */"}, {"sha": "1af92be21a862d88f9c92b9b0e5898b779f737db", "filename": "gcc/tree-ssa-loop-ivopts.h", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713438778be52a0cb0533fad271c05481435b519/gcc%2Ftree-ssa-loop-ivopts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713438778be52a0cb0533fad271c05481435b519/gcc%2Ftree-ssa-loop-ivopts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.h?ref=713438778be52a0cb0533fad271c05481435b519", "patch": "@@ -0,0 +1,36 @@\n+/* Header file for Induction variable optimizations.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_TREE_SSA_LOOP_IVOPTS_H\n+#define GCC_TREE_SSA_LOOP_IVOPTS_H\n+\n+extern edge single_dom_exit (struct loop *);\n+extern void dump_iv (FILE *, struct iv *);\n+extern void dump_use (FILE *, struct iv_use *);\n+extern void dump_uses (FILE *, struct ivopts_data *);\n+extern void dump_cand (FILE *, struct iv_cand *);\n+extern bool contains_abnormal_ssa_name_p (tree);\n+extern struct loop *outermost_invariant_loop_for_expr (struct loop *, tree);\n+extern bool expr_invariant_in_loop_p (struct loop *, tree);\n+bool may_be_nonaddressable_p (tree expr);\n+bool multiplier_allowed_in_address_p (HOST_WIDE_INT, enum machine_mode,\n+\t\t\t\t      addr_space_t);\n+void tree_ssa_iv_optimize (void);\n+\n+#endif /* GCC_TREE_SSA_LOOP_IVOPTS_H */"}, {"sha": "a1dcd22193d898adc3c926044a8d0bae85558bb3", "filename": "gcc/tree-ssa-loop-manip.h", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713438778be52a0cb0533fad271c05481435b519/gcc%2Ftree-ssa-loop-manip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713438778be52a0cb0533fad271c05481435b519/gcc%2Ftree-ssa-loop-manip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.h?ref=713438778be52a0cb0533fad271c05481435b519", "patch": "@@ -0,0 +1,49 @@\n+/* Header file for High-level loop manipulation functions.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_TREE_SSA_LOOP_MANIP_H\n+#define GCC_TREE_SSA_LOOP_MANIP_H\n+\n+typedef void (*transform_callback)(struct loop *, void *);\n+\n+extern void create_iv (tree, tree, tree, struct loop *, gimple_stmt_iterator *,\n+\t\t       bool, tree *, tree *);\n+extern void rewrite_into_loop_closed_ssa (bitmap, unsigned);\n+extern void verify_loop_closed_ssa (bool);\n+extern basic_block split_loop_exit_edge (edge);\n+extern basic_block ip_end_pos (struct loop *);\n+extern basic_block ip_normal_pos (struct loop *);\n+extern void standard_iv_increment_position (struct loop *,\n+\t\t\t\t\t    gimple_stmt_iterator *, bool *);\n+extern bool gimple_duplicate_loop_to_header_edge (struct loop *, edge,\n+\t\t\t\t\t\t  unsigned int, sbitmap,\n+\t\t\t\t\t\t  edge, vec<edge> *,\n+\t\t\t\t\t\t  int);\n+extern bool can_unroll_loop_p (struct loop *loop, unsigned factor,\n+\t\t\t       struct tree_niter_desc *niter);\n+extern void tree_transform_and_unroll_loop (struct loop *, unsigned,\n+\t\t\t\t\t    edge, struct tree_niter_desc *,\n+\t\t\t\t\t    transform_callback, void *);\n+extern void tree_unroll_loop (struct loop *, unsigned,\n+\t\t\t      edge, struct tree_niter_desc *);\n+extern tree canonicalize_loop_ivs (struct loop *, tree *, bool);\n+\n+\n+\n+#endif /* GCC_TREE_SSA_LOOP_MANIP_H */"}, {"sha": "8bcb1c6b26e23bb85c5b41369560b3ab6cc1536f", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 6, "deletions": 110, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713438778be52a0cb0533fad271c05481435b519/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713438778be52a0cb0533fad271c05481435b519/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=713438778be52a0cb0533fad271c05481435b519", "patch": "@@ -39,6 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-inline.h\"\n #include \"tree-pass.h\"\n \n+\n #define SWAP(X, Y) do { affine_iv *tmp = (X); (X) = (Y); (Y) = tmp; } while (0)\n \n /* The maximum number of dominator BBs we search for conditions\n@@ -2507,40 +2508,6 @@ derive_constant_upper_bound_ops (tree type, tree op0,\n     }\n }\n \n-/* Records that every statement in LOOP is executed I_BOUND times.\n-   REALISTIC is true if I_BOUND is expected to be close to the real number\n-   of iterations.  UPPER is true if we are sure the loop iterates at most\n-   I_BOUND times.  */\n-\n-void\n-record_niter_bound (struct loop *loop, double_int i_bound, bool realistic,\n-\t\t    bool upper)\n-{\n-  /* Update the bounds only when there is no previous estimation, or when the\n-     current estimation is smaller.  */\n-  if (upper\n-      && (!loop->any_upper_bound\n-\t  || i_bound.ult (loop->nb_iterations_upper_bound)))\n-    {\n-      loop->any_upper_bound = true;\n-      loop->nb_iterations_upper_bound = i_bound;\n-    }\n-  if (realistic\n-      && (!loop->any_estimate\n-\t  || i_bound.ult (loop->nb_iterations_estimate)))\n-    {\n-      loop->any_estimate = true;\n-      loop->nb_iterations_estimate = i_bound;\n-    }\n-\n-  /* If an upper bound is smaller than the realistic estimate of the\n-     number of iterations, use the upper bound instead.  */\n-  if (loop->any_upper_bound\n-      && loop->any_estimate\n-      && loop->nb_iterations_upper_bound.ult (loop->nb_iterations_estimate))\n-    loop->nb_iterations_estimate = loop->nb_iterations_upper_bound;\n-}\n-\n /* Emit a -Waggressive-loop-optimizations warning if needed.  */\n \n static void\n@@ -3008,26 +2975,11 @@ infer_loop_bounds_from_undefined (struct loop *loop)\n   free (bbs);\n }\n \n-/* Converts VAL to double_int.  */\n \n-static double_int\n-gcov_type_to_double_int (gcov_type val)\n-{\n-  double_int ret;\n-\n-  ret.low = (unsigned HOST_WIDE_INT) val;\n-  /* If HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_WIDEST_INT, avoid shifting by\n-     the size of type.  */\n-  val >>= HOST_BITS_PER_WIDE_INT - 1;\n-  val >>= 1;\n-  ret.high = (unsigned HOST_WIDE_INT) val;\n-\n-  return ret;\n-}\n \n /* Compare double ints, callback for qsort.  */\n \n-int\n+static int\n double_int_cmp (const void *p1, const void *p2)\n {\n   const double_int *d1 = (const double_int *)p1;\n@@ -3042,7 +2994,7 @@ double_int_cmp (const void *p1, const void *p2)\n /* Return index of BOUND in BOUNDS array sorted in increasing order.\n    Lookup by binary search.  */\n \n-int\n+static int\n bound_index (vec<double_int> bounds, double_int bound)\n {\n   unsigned int end = bounds.length ();\n@@ -3349,7 +3301,7 @@ maybe_lower_iteration_bound (struct loop *loop)\n /* Records estimates on numbers of iterations of LOOP.  If USE_UNDEFINED_P\n    is true also use estimates derived from undefined behavior.  */\n \n-void\n+static void\n estimate_numbers_of_iterations_loop (struct loop *loop)\n {\n   vec<edge> exits;\n@@ -3433,21 +3385,7 @@ estimated_loop_iterations (struct loop *loop, double_int *nit)\n   if (scev_initialized_p ())\n     estimate_numbers_of_iterations_loop (loop);\n \n-  /* Even if the bound is not recorded, possibly we can derrive one from\n-     profile.  */\n-  if (!loop->any_estimate)\n-    {\n-      if (loop->header->count)\n-\t{\n-          *nit = gcov_type_to_double_int\n-\t\t   (expected_loop_iterations_unbounded (loop) + 1);\n-\t  return true;\n-\t}\n-      return false;\n-    }\n-\n-  *nit = loop->nb_iterations_estimate;\n-  return true;\n+  return (get_estimated_loop_iterations (loop, nit));\n }\n \n /* Sets NIT to an upper bound for the maximum number of executions of the\n@@ -3461,31 +3399,8 @@ max_loop_iterations (struct loop *loop, double_int *nit)\n      estimate.  Otherwise just return whatever we recorded earlier.  */\n   if (scev_initialized_p ())\n     estimate_numbers_of_iterations_loop (loop);\n-  if (!loop->any_upper_bound)\n-    return false;\n-\n-  *nit = loop->nb_iterations_upper_bound;\n-  return true;\n-}\n-\n-/* Similar to estimated_loop_iterations, but returns the estimate only\n-   if it fits to HOST_WIDE_INT.  If this is not the case, or the estimate\n-   on the number of iterations of LOOP could not be derived, returns -1.  */\n \n-HOST_WIDE_INT\n-estimated_loop_iterations_int (struct loop *loop)\n-{\n-  double_int nit;\n-  HOST_WIDE_INT hwi_nit;\n-\n-  if (!estimated_loop_iterations (loop, &nit))\n-    return -1;\n-\n-  if (!nit.fits_shwi ())\n-    return -1;\n-  hwi_nit = nit.to_shwi ();\n-\n-  return hwi_nit < 0 ? -1 : hwi_nit;\n+  return get_max_loop_iterations (loop, nit);\n }\n \n /* Similar to max_loop_iterations, but returns the estimate only\n@@ -3508,25 +3423,6 @@ max_loop_iterations_int (struct loop *loop)\n   return hwi_nit < 0 ? -1 : hwi_nit;\n }\n \n-/* Returns an upper bound on the number of executions of statements\n-   in the LOOP.  For statements before the loop exit, this exceeds\n-   the number of execution of the latch by one.  */\n-\n-HOST_WIDE_INT\n-max_stmt_executions_int (struct loop *loop)\n-{\n-  HOST_WIDE_INT nit = max_loop_iterations_int (loop);\n-  HOST_WIDE_INT snit;\n-\n-  if (nit == -1)\n-    return -1;\n-\n-  snit = (HOST_WIDE_INT) ((unsigned HOST_WIDE_INT) nit + 1);\n-\n-  /* If the computation overflows, return -1.  */\n-  return snit < 0 ? -1 : snit;\n-}\n-\n /* Returns an estimate for the number of executions of statements\n    in the LOOP.  For statements before the loop exit, this exceeds\n    the number of execution of the latch by one.  */"}, {"sha": "aa05282c59d577a2d985633ed41494c67bfe8ba5", "filename": "gcc/tree-ssa-loop-niter.h", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713438778be52a0cb0533fad271c05481435b519/gcc%2Ftree-ssa-loop-niter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713438778be52a0cb0533fad271c05481435b519/gcc%2Ftree-ssa-loop-niter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.h?ref=713438778be52a0cb0533fad271c05481435b519", "patch": "@@ -0,0 +1,46 @@\n+/* Header file for loop interation estimates.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_TREE_SSA_LOOP_NITER_H\n+#define GCC_TREE_SSA_LOOP_NITER_H\n+\n+extern tree expand_simple_operations (tree);\n+extern bool loop_only_exit_p (const struct loop *, const_edge);\n+extern bool number_of_iterations_exit (struct loop *, edge,\n+\t\t\t\t       struct tree_niter_desc *niter, bool,\n+\t\t\t\t       bool every_iteration = true);\n+extern tree find_loop_niter (struct loop *, edge *);\n+extern bool finite_loop_p (struct loop *);\n+extern tree loop_niter_by_eval (struct loop *, edge);\n+extern tree find_loop_niter_by_eval (struct loop *, edge *);\n+extern bool estimated_loop_iterations (struct loop *, double_int *);\n+extern bool max_loop_iterations (struct loop *, double_int *);\n+extern HOST_WIDE_INT max_stmt_executions_int (struct loop *);\n+extern HOST_WIDE_INT estimated_stmt_executions_int (struct loop *);\n+extern bool max_stmt_executions (struct loop *, double_int *);\n+extern bool estimated_stmt_executions (struct loop *, double_int *);\n+extern void estimate_numbers_of_iterations (void);\n+extern bool stmt_dominates_stmt_p (gimple, gimple);\n+extern bool nowrap_type_p (tree);\n+extern bool scev_probably_wraps_p (tree, tree, gimple, struct loop *, bool);\n+extern void free_numbers_of_iterations_estimates_loop (struct loop *);\n+extern void free_numbers_of_iterations_estimates (void);\n+extern void substitute_in_loop_info (struct loop *, tree, tree);\n+\n+#endif /* GCC_TREE_SSA_LOOP_NITER_H */"}, {"sha": "5a51ba66c490c5453ec3716dab00952357fdf5ab", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713438778be52a0cb0533fad271c05481435b519/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713438778be52a0cb0533fad271c05481435b519/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=713438778be52a0cb0533fad271c05481435b519", "patch": "@@ -1988,3 +1988,60 @@ tree_ssa_prefetch_arrays (void)\n   free_original_copy_tables ();\n   return todo_flags;\n }\n+\n+/* Prefetching.  */\n+\n+static unsigned int\n+tree_ssa_loop_prefetch (void)\n+{\n+  if (number_of_loops (cfun) <= 1)\n+    return 0;\n+\n+  return tree_ssa_prefetch_arrays ();\n+}\n+\n+static bool\n+gate_tree_ssa_loop_prefetch (void)\n+{\n+  return flag_prefetch_loop_arrays > 0;\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_loop_prefetch =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"aprefetch\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_PREFETCH, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_loop_prefetch : public gimple_opt_pass\n+{\n+public:\n+  pass_loop_prefetch (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_loop_prefetch, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_tree_ssa_loop_prefetch (); }\n+  unsigned int execute () { return tree_ssa_loop_prefetch (); }\n+\n+}; // class pass_loop_prefetch\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_loop_prefetch (gcc::context *ctxt)\n+{\n+  return new pass_loop_prefetch (ctxt);\n+}\n+\n+"}, {"sha": "74af9758b1adad31917d3c3ae3c849b90f806076", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713438778be52a0cb0533fad271c05481435b519/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713438778be52a0cb0533fad271c05481435b519/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=713438778be52a0cb0533fad271c05481435b519", "patch": "@@ -388,3 +388,60 @@ tree_unswitch_loop (struct loop *loop,\n \t\t       NULL, prob_true, prob_true,\n \t\t       REG_BR_PROB_BASE - prob_true, false);\n }\n+\n+/* Loop unswitching pass.  */\n+\n+static unsigned int\n+tree_ssa_loop_unswitch (void)\n+{\n+  if (number_of_loops (cfun) <= 1)\n+    return 0;\n+\n+  return tree_ssa_unswitch_loops ();\n+}\n+\n+static bool\n+gate_tree_ssa_loop_unswitch (void)\n+{\n+  return flag_unswitch_loops != 0;\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_tree_unswitch =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"unswitch\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_LOOP_UNSWITCH, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_tree_unswitch : public gimple_opt_pass\n+{\n+public:\n+  pass_tree_unswitch (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_tree_unswitch, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_tree_ssa_loop_unswitch (); }\n+  unsigned int execute () { return tree_ssa_loop_unswitch (); }\n+\n+}; // class pass_tree_unswitch\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_tree_unswitch (gcc::context *ctxt)\n+{\n+  return new pass_tree_unswitch (ctxt);\n+}\n+\n+"}, {"sha": "bf2fbc885d678abf5a8af3b26df3a3db13059234", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 232, "deletions": 343, "changes": 575, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713438778be52a0cb0533fad271c05481435b519/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713438778be52a0cb0533fad271c05481435b519/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=713438778be52a0cb0533fad271c05481435b519", "patch": "@@ -134,117 +134,6 @@ make_pass_tree_loop_init (gcc::context *ctxt)\n   return new pass_tree_loop_init (ctxt);\n }\n \n-/* Loop invariant motion pass.  */\n-\n-static unsigned int\n-tree_ssa_loop_im (void)\n-{\n-  if (number_of_loops (cfun) <= 1)\n-    return 0;\n-\n-  return tree_ssa_lim ();\n-}\n-\n-static bool\n-gate_tree_ssa_loop_im (void)\n-{\n-  return flag_tree_loop_im != 0;\n-}\n-\n-namespace {\n-\n-const pass_data pass_data_lim =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"lim\", /* name */\n-  OPTGROUP_LOOP, /* optinfo_flags */\n-  true, /* has_gate */\n-  true, /* has_execute */\n-  TV_LIM, /* tv_id */\n-  PROP_cfg, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_lim : public gimple_opt_pass\n-{\n-public:\n-  pass_lim (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_lim, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  opt_pass * clone () { return new pass_lim (m_ctxt); }\n-  bool gate () { return gate_tree_ssa_loop_im (); }\n-  unsigned int execute () { return tree_ssa_loop_im (); }\n-\n-}; // class pass_lim\n-\n-} // anon namespace\n-\n-gimple_opt_pass *\n-make_pass_lim (gcc::context *ctxt)\n-{\n-  return new pass_lim (ctxt);\n-}\n-\n-/* Loop unswitching pass.  */\n-\n-static unsigned int\n-tree_ssa_loop_unswitch (void)\n-{\n-  if (number_of_loops (cfun) <= 1)\n-    return 0;\n-\n-  return tree_ssa_unswitch_loops ();\n-}\n-\n-static bool\n-gate_tree_ssa_loop_unswitch (void)\n-{\n-  return flag_unswitch_loops != 0;\n-}\n-\n-namespace {\n-\n-const pass_data pass_data_tree_unswitch =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"unswitch\", /* name */\n-  OPTGROUP_LOOP, /* optinfo_flags */\n-  true, /* has_gate */\n-  true, /* has_execute */\n-  TV_TREE_LOOP_UNSWITCH, /* tv_id */\n-  PROP_cfg, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_tree_unswitch : public gimple_opt_pass\n-{\n-public:\n-  pass_tree_unswitch (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_tree_unswitch, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  bool gate () { return gate_tree_ssa_loop_unswitch (); }\n-  unsigned int execute () { return tree_ssa_loop_unswitch (); }\n-\n-}; // class pass_tree_unswitch\n-\n-} // anon namespace\n-\n-gimple_opt_pass *\n-make_pass_tree_unswitch (gcc::context *ctxt)\n-{\n-  return new pass_tree_unswitch (ctxt);\n-}\n-\n /* Predictive commoning.  */\n \n static unsigned\n@@ -515,61 +404,6 @@ make_pass_check_data_deps (gcc::context *ctxt)\n   return new pass_check_data_deps (ctxt);\n }\n \n-/* Canonical induction variable creation pass.  */\n-\n-static unsigned int\n-tree_ssa_loop_ivcanon (void)\n-{\n-  if (number_of_loops (cfun) <= 1)\n-    return 0;\n-\n-  return canonicalize_induction_variables ();\n-}\n-\n-static bool\n-gate_tree_ssa_loop_ivcanon (void)\n-{\n-  return flag_tree_loop_ivcanon != 0;\n-}\n-\n-namespace {\n-\n-const pass_data pass_data_iv_canon =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"ivcanon\", /* name */\n-  OPTGROUP_LOOP, /* optinfo_flags */\n-  true, /* has_gate */\n-  true, /* has_execute */\n-  TV_TREE_LOOP_IVCANON, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_iv_canon : public gimple_opt_pass\n-{\n-public:\n-  pass_iv_canon (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_iv_canon, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  bool gate () { return gate_tree_ssa_loop_ivcanon (); }\n-  unsigned int execute () { return tree_ssa_loop_ivcanon (); }\n-\n-}; // class pass_iv_canon\n-\n-} // anon namespace\n-\n-gimple_opt_pass *\n-make_pass_iv_canon (gcc::context *ctxt)\n-{\n-  return new pass_iv_canon (ctxt);\n-}\n-\n /* Propagation of constants using scev.  */\n \n static bool\n@@ -667,128 +501,6 @@ make_pass_record_bounds (gcc::context *ctxt)\n   return new pass_record_bounds (ctxt);\n }\n \n-/* Complete unrolling of loops.  */\n-\n-static unsigned int\n-tree_complete_unroll (void)\n-{\n-  if (number_of_loops (cfun) <= 1)\n-    return 0;\n-\n-  return tree_unroll_loops_completely (flag_unroll_loops\n-\t\t\t\t       || flag_peel_loops\n-\t\t\t\t       || optimize >= 3, true);\n-}\n-\n-static bool\n-gate_tree_complete_unroll (void)\n-{\n-  return true;\n-}\n-\n-namespace {\n-\n-const pass_data pass_data_complete_unroll =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"cunroll\", /* name */\n-  OPTGROUP_LOOP, /* optinfo_flags */\n-  true, /* has_gate */\n-  true, /* has_execute */\n-  TV_COMPLETE_UNROLL, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_complete_unroll : public gimple_opt_pass\n-{\n-public:\n-  pass_complete_unroll (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_complete_unroll, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  bool gate () { return gate_tree_complete_unroll (); }\n-  unsigned int execute () { return tree_complete_unroll (); }\n-\n-}; // class pass_complete_unroll\n-\n-} // anon namespace\n-\n-gimple_opt_pass *\n-make_pass_complete_unroll (gcc::context *ctxt)\n-{\n-  return new pass_complete_unroll (ctxt);\n-}\n-\n-/* Complete unrolling of inner loops.  */\n-\n-static unsigned int\n-tree_complete_unroll_inner (void)\n-{\n-  unsigned ret = 0;\n-\n-  loop_optimizer_init (LOOPS_NORMAL\n-\t\t       | LOOPS_HAVE_RECORDED_EXITS);\n-  if (number_of_loops (cfun) > 1)\n-    {\n-      scev_initialize ();\n-      ret = tree_unroll_loops_completely (optimize >= 3, false);\n-      free_numbers_of_iterations_estimates ();\n-      scev_finalize ();\n-    }\n-  loop_optimizer_finalize ();\n-\n-  return ret;\n-}\n-\n-static bool\n-gate_tree_complete_unroll_inner (void)\n-{\n-  return optimize >= 2;\n-}\n-\n-namespace {\n-\n-const pass_data pass_data_complete_unrolli =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"cunrolli\", /* name */\n-  OPTGROUP_LOOP, /* optinfo_flags */\n-  true, /* has_gate */\n-  true, /* has_execute */\n-  TV_COMPLETE_UNROLL, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  TODO_verify_flow, /* todo_flags_finish */\n-};\n-\n-class pass_complete_unrolli : public gimple_opt_pass\n-{\n-public:\n-  pass_complete_unrolli (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_complete_unrolli, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  bool gate () { return gate_tree_complete_unroll_inner (); }\n-  unsigned int execute () { return tree_complete_unroll_inner (); }\n-\n-}; // class pass_complete_unrolli\n-\n-} // anon namespace\n-\n-gimple_opt_pass *\n-make_pass_complete_unrolli (gcc::context *ctxt)\n-{\n-  return new pass_complete_unrolli (ctxt);\n-}\n-\n /* Parallelization.  */\n \n static bool\n@@ -846,61 +558,6 @@ make_pass_parallelize_loops (gcc::context *ctxt)\n   return new pass_parallelize_loops (ctxt);\n }\n \n-/* Prefetching.  */\n-\n-static unsigned int\n-tree_ssa_loop_prefetch (void)\n-{\n-  if (number_of_loops (cfun) <= 1)\n-    return 0;\n-\n-  return tree_ssa_prefetch_arrays ();\n-}\n-\n-static bool\n-gate_tree_ssa_loop_prefetch (void)\n-{\n-  return flag_prefetch_loop_arrays > 0;\n-}\n-\n-namespace {\n-\n-const pass_data pass_data_loop_prefetch =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"aprefetch\", /* name */\n-  OPTGROUP_LOOP, /* optinfo_flags */\n-  true, /* has_gate */\n-  true, /* has_execute */\n-  TV_TREE_PREFETCH, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_loop_prefetch : public gimple_opt_pass\n-{\n-public:\n-  pass_loop_prefetch (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_loop_prefetch, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  bool gate () { return gate_tree_ssa_loop_prefetch (); }\n-  unsigned int execute () { return tree_ssa_loop_prefetch (); }\n-\n-}; // class pass_loop_prefetch\n-\n-} // anon namespace\n-\n-gimple_opt_pass *\n-make_pass_loop_prefetch (gcc::context *ctxt)\n-{\n-  return new pass_loop_prefetch (ctxt);\n-}\n-\n /* Induction variable optimizations.  */\n \n static unsigned int\n@@ -1004,3 +661,235 @@ make_pass_tree_loop_done (gcc::context *ctxt)\n {\n   return new pass_tree_loop_done (ctxt);\n }\n+\n+/* Calls CBCK for each index in memory reference ADDR_P.  There are two\n+   kinds situations handled; in each of these cases, the memory reference\n+   and DATA are passed to the callback:\n+\n+   Access to an array: ARRAY_{RANGE_}REF (base, index).  In this case we also\n+   pass the pointer to the index to the callback.\n+\n+   Pointer dereference: INDIRECT_REF (addr).  In this case we also pass the\n+   pointer to addr to the callback.\n+\n+   If the callback returns false, the whole search stops and false is returned.\n+   Otherwise the function returns true after traversing through the whole\n+   reference *ADDR_P.  */\n+\n+bool\n+for_each_index (tree *addr_p, bool (*cbck) (tree, tree *, void *), void *data)\n+{\n+  tree *nxt, *idx;\n+\n+  for (; ; addr_p = nxt)\n+    {\n+      switch (TREE_CODE (*addr_p))\n+\t{\n+\tcase SSA_NAME:\n+\t  return cbck (*addr_p, addr_p, data);\n+\n+\tcase MEM_REF:\n+\t  nxt = &TREE_OPERAND (*addr_p, 0);\n+\t  return cbck (*addr_p, nxt, data);\n+\n+\tcase BIT_FIELD_REF:\n+\tcase VIEW_CONVERT_EXPR:\n+\tcase REALPART_EXPR:\n+\tcase IMAGPART_EXPR:\n+\t  nxt = &TREE_OPERAND (*addr_p, 0);\n+\t  break;\n+\n+\tcase COMPONENT_REF:\n+\t  /* If the component has varying offset, it behaves like index\n+\t     as well.  */\n+\t  idx = &TREE_OPERAND (*addr_p, 2);\n+\t  if (*idx\n+\t      && !cbck (*addr_p, idx, data))\n+\t    return false;\n+\n+\t  nxt = &TREE_OPERAND (*addr_p, 0);\n+\t  break;\n+\n+\tcase ARRAY_REF:\n+\tcase ARRAY_RANGE_REF:\n+\t  nxt = &TREE_OPERAND (*addr_p, 0);\n+\t  if (!cbck (*addr_p, &TREE_OPERAND (*addr_p, 1), data))\n+\t    return false;\n+\t  break;\n+\n+\tcase VAR_DECL:\n+\tcase PARM_DECL:\n+\tcase CONST_DECL:\n+\tcase STRING_CST:\n+\tcase RESULT_DECL:\n+\tcase VECTOR_CST:\n+\tcase COMPLEX_CST:\n+\tcase INTEGER_CST:\n+\tcase REAL_CST:\n+\tcase FIXED_CST:\n+\tcase CONSTRUCTOR:\n+\t  return true;\n+\n+\tcase ADDR_EXPR:\n+\t  gcc_assert (is_gimple_min_invariant (*addr_p));\n+\t  return true;\n+\n+\tcase TARGET_MEM_REF:\n+\t  idx = &TMR_BASE (*addr_p);\n+\t  if (*idx\n+\t      && !cbck (*addr_p, idx, data))\n+\t    return false;\n+\t  idx = &TMR_INDEX (*addr_p);\n+\t  if (*idx\n+\t      && !cbck (*addr_p, idx, data))\n+\t    return false;\n+\t  idx = &TMR_INDEX2 (*addr_p);\n+\t  if (*idx\n+\t      && !cbck (*addr_p, idx, data))\n+\t    return false;\n+\t  return true;\n+\n+\tdefault:\n+    \t  gcc_unreachable ();\n+\t}\n+    }\n+}\n+\n+\n+/* The name and the length of the currently generated variable\n+   for lsm.  */\n+#define MAX_LSM_NAME_LENGTH 40\n+static char lsm_tmp_name[MAX_LSM_NAME_LENGTH + 1];\n+static int lsm_tmp_name_length;\n+\n+/* Adds S to lsm_tmp_name.  */\n+\n+static void\n+lsm_tmp_name_add (const char *s)\n+{\n+  int l = strlen (s) + lsm_tmp_name_length;\n+  if (l > MAX_LSM_NAME_LENGTH)\n+    return;\n+\n+  strcpy (lsm_tmp_name + lsm_tmp_name_length, s);\n+  lsm_tmp_name_length = l;\n+}\n+\n+/* Stores the name for temporary variable that replaces REF to\n+   lsm_tmp_name.  */\n+\n+static void\n+gen_lsm_tmp_name (tree ref)\n+{\n+  const char *name;\n+\n+  switch (TREE_CODE (ref))\n+    {\n+    case MEM_REF:\n+    case TARGET_MEM_REF:\n+      gen_lsm_tmp_name (TREE_OPERAND (ref, 0));\n+      lsm_tmp_name_add (\"_\");\n+      break;\n+\n+    case ADDR_EXPR:\n+      gen_lsm_tmp_name (TREE_OPERAND (ref, 0));\n+      break;\n+\n+    case BIT_FIELD_REF:\n+    case VIEW_CONVERT_EXPR:\n+    case ARRAY_RANGE_REF:\n+      gen_lsm_tmp_name (TREE_OPERAND (ref, 0));\n+      break;\n+\n+    case REALPART_EXPR:\n+      gen_lsm_tmp_name (TREE_OPERAND (ref, 0));\n+      lsm_tmp_name_add (\"_RE\");\n+      break;\n+\n+    case IMAGPART_EXPR:\n+      gen_lsm_tmp_name (TREE_OPERAND (ref, 0));\n+      lsm_tmp_name_add (\"_IM\");\n+      break;\n+\n+    case COMPONENT_REF:\n+      gen_lsm_tmp_name (TREE_OPERAND (ref, 0));\n+      lsm_tmp_name_add (\"_\");\n+      name = get_name (TREE_OPERAND (ref, 1));\n+      if (!name)\n+\tname = \"F\";\n+      lsm_tmp_name_add (name);\n+      break;\n+\n+    case ARRAY_REF:\n+      gen_lsm_tmp_name (TREE_OPERAND (ref, 0));\n+      lsm_tmp_name_add (\"_I\");\n+      break;\n+\n+    case SSA_NAME:\n+    case VAR_DECL:\n+    case PARM_DECL:\n+      name = get_name (ref);\n+      if (!name)\n+\tname = \"D\";\n+      lsm_tmp_name_add (name);\n+      break;\n+\n+    case STRING_CST:\n+      lsm_tmp_name_add (\"S\");\n+      break;\n+\n+    case RESULT_DECL:\n+      lsm_tmp_name_add (\"R\");\n+      break;\n+\n+    case INTEGER_CST:\n+      /* Nothing.  */\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Determines name for temporary variable that replaces REF.\n+   The name is accumulated into the lsm_tmp_name variable.\n+   N is added to the name of the temporary.  */\n+\n+char *\n+get_lsm_tmp_name (tree ref, unsigned n, const char *suffix)\n+{\n+  char ns[2];\n+\n+  lsm_tmp_name_length = 0;\n+  gen_lsm_tmp_name (ref);\n+  lsm_tmp_name_add (\"_lsm\");\n+  if (n < 10)\n+    {\n+      ns[0] = '0' + n;\n+      ns[1] = 0;\n+      lsm_tmp_name_add (ns);\n+    }\n+  return lsm_tmp_name;\n+  if (suffix != NULL)\n+    lsm_tmp_name_add (suffix);\n+}\n+\n+/* Computes an estimated number of insns in LOOP, weighted by WEIGHTS.  */\n+\n+unsigned\n+tree_num_loop_insns (struct loop *loop, eni_weights *weights)\n+{\n+  basic_block *body = get_loop_body (loop);\n+  gimple_stmt_iterator gsi;\n+  unsigned size = 0, i;\n+\n+  for (i = 0; i < loop->num_nodes; i++)\n+    for (gsi = gsi_start_bb (body[i]); !gsi_end_p (gsi); gsi_next (&gsi))\n+      size += estimate_num_insns (gsi_stmt (gsi), weights);\n+  free (body);\n+\n+  return size;\n+}\n+\n+\n+"}, {"sha": "1c96d9cee5e627208ccc3985ed704df54528215b", "filename": "gcc/tree-ssa-loop.h", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/713438778be52a0cb0533fad271c05481435b519/gcc%2Ftree-ssa-loop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/713438778be52a0cb0533fad271c05481435b519/gcc%2Ftree-ssa-loop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.h?ref=713438778be52a0cb0533fad271c05481435b519", "patch": "@@ -0,0 +1,85 @@\n+/* Header file for SSA loop optimizations.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_TREE_SSA_LOOP_H\n+#define GCC_TREE_SSA_LOOP_H\n+\n+#include \"tree-ssa-loop-ivopts.h\"\n+#include \"tree-ssa-loop-manip.h\"\n+#include \"tree-ssa-loop-niter.h\"\n+\n+/* Affine iv.  */\n+\n+typedef struct affine_iv_d\n+{\n+  /* Iv = BASE + STEP * i.  */\n+  tree base, step;\n+\n+  /* True if this iv does not overflow.  */\n+  bool no_overflow;\n+} affine_iv;\n+\n+/* Description of number of iterations of a loop.  All the expressions inside\n+   the structure can be evaluated at the end of the loop's preheader\n+   (and due to ssa form, also anywhere inside the body of the loop).  */\n+\n+struct tree_niter_desc\n+{\n+  tree assumptions;\t/* The boolean expression.  If this expression evaluates\n+\t\t\t   to false, then the other fields in this structure\n+\t\t\t   should not be used; there is no guarantee that they\n+\t\t\t   will be correct.  */\n+  tree may_be_zero;\t/* The boolean expression.  If it evaluates to true,\n+\t\t\t   the loop will exit in the first iteration (i.e.\n+\t\t\t   its latch will not be executed), even if the niter\n+\t\t\t   field says otherwise.  */\n+  tree niter;\t\t/* The expression giving the number of iterations of\n+\t\t\t   a loop (provided that assumptions == true and\n+\t\t\t   may_be_zero == false), more precisely the number\n+\t\t\t   of executions of the latch of the loop.  */\n+  double_int max;\t/* The upper bound on the number of iterations of\n+\t\t\t   the loop.  */\n+\n+  /* The simplified shape of the exit condition.  The loop exits if\n+     CONTROL CMP BOUND is false, where CMP is one of NE_EXPR,\n+     LT_EXPR, or GT_EXPR, and step of CONTROL is positive if CMP is\n+     LE_EXPR and negative if CMP is GE_EXPR.  This information is used\n+     by loop unrolling.  */\n+  affine_iv control;\n+  tree bound;\n+  enum tree_code cmp;\n+};\n+\n+extern bool for_each_index (tree *, bool (*) (tree, tree *, void *), void *);\n+extern char *get_lsm_tmp_name (tree ref, unsigned n, const char *suffix = NULL);\n+extern unsigned tree_num_loop_insns (struct loop *, struct eni_weights_d *);\n+\n+/* Returns the loop of the statement STMT.  */\n+\n+static inline struct loop *\n+loop_containing_stmt (gimple stmt)\n+{\n+  basic_block bb = gimple_bb (stmt);\n+  if (!bb)\n+    return NULL;\n+\n+  return bb->loop_father;\n+}\n+\n+#endif /* GCC_TREE_SSA_LOOP_H */"}]}