{"sha": "56ca756cd95ffa1e2dadabd88a0b31380b84be64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZjYTc1NmNkOTVmZmExZTJkYWRhYmQ4OGEwYjMxMzgwYjg0YmU2NA==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2012-05-01T04:03:21Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2012-05-01T04:03:21Z"}, "message": "re PR target/53038 (cfi_restore for cr before cr is actually restored)\n\n\tPR target/53038\n\t* config/rs6000/rs6000.c (load_lr_save, restore_saved_lr,\n\tload_cr_save, add_crlr_cfa_restore): New functions.\n\t(rs6000_restore_saved_cr): Rename to..\n\t(restore_saved_cr): ..this.  Add cfa_restore notes for cr.\n\t(rs6000_emit_epilogue): Use new functions.  Adjust condition\n\tfor emitting lr and cr cfa_restore.  Emit cfa_restores for fp\n\tregs when using out-of-line restore only when shrink wrapping.\n\nFrom-SVN: r187010", "tree": {"sha": "aab96b5745cd4e454f1277fed88da99e30005fcf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aab96b5745cd4e454f1277fed88da99e30005fcf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56ca756cd95ffa1e2dadabd88a0b31380b84be64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56ca756cd95ffa1e2dadabd88a0b31380b84be64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56ca756cd95ffa1e2dadabd88a0b31380b84be64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56ca756cd95ffa1e2dadabd88a0b31380b84be64/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f8e4c7e6649ea9357aa63d9c18d3d4c2198bf224", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8e4c7e6649ea9357aa63d9c18d3d4c2198bf224", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8e4c7e6649ea9357aa63d9c18d3d4c2198bf224"}], "stats": {"total": 170, "additions": 120, "deletions": 50}, "files": [{"sha": "e7999fb54bf3d2babb5348555bf9890fbb117ed5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56ca756cd95ffa1e2dadabd88a0b31380b84be64/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56ca756cd95ffa1e2dadabd88a0b31380b84be64/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=56ca756cd95ffa1e2dadabd88a0b31380b84be64", "patch": "@@ -1,3 +1,14 @@\n+2012-05-01  Alan Modra  <amodra@gmail.com>\n+\n+\tPR target/53038\n+\t* config/rs6000/rs6000.c (load_lr_save, restore_saved_lr,\n+\tload_cr_save, add_crlr_cfa_restore): New functions.\n+\t(rs6000_restore_saved_cr): Rename to..\n+\t(restore_saved_cr): ..this.  Add cfa_restore notes for cr.\n+\t(rs6000_emit_epilogue): Use new functions.  Adjust condition\n+\tfor emitting lr and cr cfa_restore.  Emit cfa_restores for fp\n+\tregs when using out-of-line restore only when shrink wrapping.\n+\n 2012-04-30  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR middle-end/53136"}, {"sha": "dca434b19450d2f7bc09633230006b477cc28d31", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 109, "deletions": 50, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56ca756cd95ffa1e2dadabd88a0b31380b84be64/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56ca756cd95ffa1e2dadabd88a0b31380b84be64/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=56ca756cd95ffa1e2dadabd88a0b31380b84be64", "patch": "@@ -952,7 +952,6 @@ static void rs6000_set_default_type_attributes (tree);\n static bool rs6000_reg_live_or_pic_offset_p (int);\n static tree rs6000_builtin_vectorized_libmass (tree, tree, tree);\n static tree rs6000_builtin_vectorized_function (tree, tree, tree);\n-static void rs6000_restore_saved_cr (rtx, int);\n static bool rs6000_output_addr_const_extra (FILE *, rtx);\n static void rs6000_output_function_prologue (FILE *, HOST_WIDE_INT);\n static void rs6000_output_function_epilogue (FILE *, HOST_WIDE_INT);\n@@ -20276,10 +20275,37 @@ rs6000_output_function_prologue (FILE *file,\n    we restore after the pop when possible.  */\n #define ALWAYS_RESTORE_ALTIVEC_BEFORE_POP 0\n \n+/* Restoring cr is a two step process: loading a reg from the frame\n+   save, then moving the reg to cr.  For ABI_V4 we must let the\n+   unwinder know that the stack location is no longer valid at or\n+   before the stack deallocation, but we can't emit a cfa_restore for\n+   cr at the stack deallocation like we do for other registers.\n+   The trouble is that it is possible for the move to cr to be\n+   scheduled after the stack deallocation.  So say exactly where cr\n+   is located on each of the two insns.  */\n+\n+static rtx\n+load_cr_save (int regno, rtx frame_reg_rtx, int offset, bool exit_func)\n+{\n+  rtx mem = gen_frame_mem_offset (SImode, frame_reg_rtx, offset);\n+  rtx reg = gen_rtx_REG (SImode, regno);\n+  rtx insn = emit_move_insn (reg, mem);\n+\n+  if (!exit_func && DEFAULT_ABI == ABI_V4)\n+    {\n+      rtx cr = gen_rtx_REG (SImode, CR2_REGNO);\n+      rtx set = gen_rtx_SET (VOIDmode, reg, cr);\n+\n+      add_reg_note (insn, REG_CFA_REGISTER, set);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+  return reg;\n+}\n+\n /* Reload CR from REG.  */\n \n static void\n-rs6000_restore_saved_cr (rtx reg, int using_mfcr_multiple)\n+restore_saved_cr (rtx reg, int using_mfcr_multiple, bool exit_func)\n {\n   int count = 0;\n   int i;\n@@ -20317,11 +20343,59 @@ rs6000_restore_saved_cr (rtx reg, int using_mfcr_multiple)\n   else\n     for (i = 0; i < 8; i++)\n       if (df_regs_ever_live_p (CR0_REGNO+i) && ! call_used_regs[CR0_REGNO+i])\n-\t{\n-\t  emit_insn (gen_movsi_to_cr_one (gen_rtx_REG (CCmode,\n-\t\t\t\t\t\t       CR0_REGNO+i),\n-\t\t\t\t\t  reg));\n-\t}\n+\temit_insn (gen_movsi_to_cr_one (gen_rtx_REG (CCmode, CR0_REGNO+i),\n+\t\t\t\t\treg));\n+\n+  if (!exit_func && (DEFAULT_ABI == ABI_V4 || flag_shrink_wrap))\n+    {\n+      rtx insn = get_last_insn ();\n+      rtx cr = gen_rtx_REG (SImode, CR2_REGNO);\n+\n+      add_reg_note (insn, REG_CFA_RESTORE, cr);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+}\n+\n+/* Like cr, the move to lr instruction can be scheduled after the\n+   stack deallocation, but unlike cr, its stack frame save is still\n+   valid.  So we only need to emit the cfa_restore on the correct\n+   instruction.  */\n+\n+static void\n+load_lr_save (int regno, rtx frame_reg_rtx, int offset)\n+{\n+  rtx mem = gen_frame_mem_offset (Pmode, frame_reg_rtx, offset);\n+  rtx reg = gen_rtx_REG (Pmode, regno);\n+\n+  emit_move_insn (reg, mem);\n+}\n+\n+static void\n+restore_saved_lr (int regno, bool exit_func)\n+{\n+  rtx reg = gen_rtx_REG (Pmode, regno);\n+  rtx lr = gen_rtx_REG (Pmode, LR_REGNO);\n+  rtx insn = emit_move_insn (lr, reg);\n+\n+  if (!exit_func && flag_shrink_wrap)\n+    {\n+      add_reg_note (insn, REG_CFA_RESTORE, lr);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+}\n+\n+static rtx\n+add_crlr_cfa_restore (const rs6000_stack_t *info, rtx cfa_restores)\n+{\n+  if (info->cr_save_p)\n+    cfa_restores = alloc_reg_note (REG_CFA_RESTORE,\n+\t\t\t\t   gen_rtx_REG (SImode, CR2_REGNO),\n+\t\t\t\t   cfa_restores);\n+  if (info->lr_save_p)\n+    cfa_restores = alloc_reg_note (REG_CFA_RESTORE,\n+\t\t\t\t   gen_rtx_REG (Pmode, LR_REGNO),\n+\t\t\t\t   cfa_restores);\n+  return cfa_restores;\n }\n \n /* Return true if OFFSET from stack pointer can be clobbered by signals.\n@@ -20372,6 +20446,7 @@ rs6000_emit_epilogue (int sibcall)\n   enum machine_mode reg_mode = Pmode;\n   int reg_size = TARGET_32BIT ? 4 : 8;\n   int i;\n+  bool exit_func;\n   unsigned ptr_regno;\n \n   info = rs6000_stack_info ();\n@@ -20824,22 +20899,22 @@ rs6000_emit_epilogue (int sibcall)\n       emit_insn (generate_set_vrsave (reg, info, 1));\n     }\n \n+  /* If we exit by an out-of-line restore function on ABI_V4 then that\n+     function will deallocate the stack, so we don't need to worry\n+     about the unwinder restoring cr from an invalid stack frame\n+     location.  */\n+  exit_func = (!restoring_FPRs_inline\n+\t       || (!restoring_GPRs_inline\n+\t\t   && info->first_fp_reg_save == 64));\n+\n   /* Get the old lr if we saved it.  If we are restoring registers\n      out-of-line, then the out-of-line routines can do this for us.  */\n   if (restore_lr && restoring_GPRs_inline)\n-    {\n-      rtx mem = gen_frame_mem_offset (Pmode, frame_reg_rtx,\n-\t\t\t\t      info->lr_save_offset + frame_off);\n-\n-      emit_move_insn (gen_rtx_REG (Pmode, 0), mem);\n-    }\n+    load_lr_save (0, frame_reg_rtx, info->lr_save_offset + frame_off);\n \n   /* Get the old cr if we saved it.  */\n   if (info->cr_save_p)\n     {\n-      rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-\t\t\t       GEN_INT (info->cr_save_offset + frame_off));\n-      rtx mem = gen_frame_mem (SImode, addr);\n       unsigned cr_save_regno = 12;\n \n       if (!restoring_GPRs_inline)\n@@ -20857,14 +20932,14 @@ rs6000_emit_epilogue (int sibcall)\n       else if (REGNO (frame_reg_rtx) == 12)\n \tcr_save_regno = 11;\n \n-      cr_save_reg = gen_rtx_REG (SImode, cr_save_regno);\n-      emit_move_insn (cr_save_reg, mem);\n+      cr_save_reg = load_cr_save (cr_save_regno, frame_reg_rtx,\n+\t\t\t\t  info->cr_save_offset + frame_off,\n+\t\t\t\t  exit_func);\n     }\n \n   /* Set LR here to try to overlap restores below.  */\n   if (restore_lr && restoring_GPRs_inline)\n-    emit_move_insn (gen_rtx_REG (Pmode, LR_REGNO),\n-\t\t    gen_rtx_REG (Pmode, 0));\n+    restore_saved_lr (0, exit_func);\n \n   /* Load exception handler data registers, if needed.  */\n   if (crtl->calls_eh_return)\n@@ -20983,7 +21058,7 @@ rs6000_emit_epilogue (int sibcall)\n \tframe_off = -end_save;\n \n       if (can_use_exit && info->cr_save_p)\n-\trs6000_restore_saved_cr (cr_save_reg, using_mtcr_multiple);\n+\trestore_saved_cr (cr_save_reg, using_mtcr_multiple, true);\n \n       ptr_off = -end_save;\n       rs6000_emit_savres_rtx (info, ptr_reg,\n@@ -21046,23 +21121,14 @@ rs6000_emit_epilogue (int sibcall)\n \t The cfa_restores must be emitted on or before the insn that\n \t invalidates the stack, and of course must not be emitted\n \t before the insn that actually does the restore.  The latter\n-\t is why the LR cfa_restore condition below is a little\n-\t complicated.  It's also why it is a bad idea to emit the\n-\t cfa_restores as a group on the last instruction here that\n-\t actually does a restore: That insn may be reordered with\n-\t respect to others doing restores.  */\n-      if (info->cr_save_p)\n-\tcfa_restores = alloc_reg_note (REG_CFA_RESTORE,\n-\t\t\t\t       gen_rtx_REG (SImode, CR2_REGNO),\n-\t\t\t\t       cfa_restores);\n+\t is why it is a bad idea to emit the cfa_restores as a group\n+\t on the last instruction here that actually does a restore:\n+\t That insn may be reordered with respect to others doing\n+\t restores.  */\n       if (flag_shrink_wrap\n-\t  && (restore_lr\n-\t      || (info->lr_save_p\n-\t\t  && !restoring_GPRs_inline\n-\t\t  && info->first_fp_reg_save == 64)))\n-\tcfa_restores = alloc_reg_note (REG_CFA_RESTORE,\n-\t\t\t\t       gen_rtx_REG (Pmode, LR_REGNO),\n-\t\t\t\t       cfa_restores);\n+\t  && !restoring_GPRs_inline\n+\t  && info->first_fp_reg_save == 64)\n+\tcfa_restores = add_crlr_cfa_restore (info, cfa_restores);\n \n       for (i = info->first_gp_reg_save; i < 32; i++)\n \tif (!restoring_GPRs_inline\n@@ -21086,12 +21152,8 @@ rs6000_emit_epilogue (int sibcall)\n \n   if (restore_lr && !restoring_GPRs_inline)\n     {\n-      rtx mem = gen_frame_mem_offset (Pmode, frame_reg_rtx,\n-\t\t\t\t      info->lr_save_offset + frame_off);\n-\n-      emit_move_insn (gen_rtx_REG (Pmode, 0), mem);\n-      emit_move_insn (gen_rtx_REG (Pmode, LR_REGNO),\n-\t\t      gen_rtx_REG (Pmode, 0));\n+      load_lr_save (0, frame_reg_rtx, info->lr_save_offset + frame_off);\n+      restore_saved_lr (0, exit_func);\n     }\n \n   /* Restore fpr's if we need to do it without calling a function.  */\n@@ -21118,7 +21180,7 @@ rs6000_emit_epilogue (int sibcall)\n \n   /* If we saved cr, restore it here.  Just those that were used.  */\n   if (info->cr_save_p)\n-    rs6000_restore_saved_cr (cr_save_reg, using_mtcr_multiple);\n+    restore_saved_cr (cr_save_reg, using_mtcr_multiple, exit_func);\n \n   /* If this is V.4, unwind the stack pointer after all of the loads\n      have been done, or set up r11 if we are restoring fp out of line.  */\n@@ -21198,11 +21260,8 @@ rs6000_emit_epilogue (int sibcall)\n \t  int i;\n \t  rtx sym;\n \n-\t  if ((DEFAULT_ABI == ABI_V4 || flag_shrink_wrap)\n-\t      && lr)\n-\t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE,\n-\t\t\t\t\t   gen_rtx_REG (Pmode, LR_REGNO),\n-\t\t\t\t\t   cfa_restores);\n+\t  if (flag_shrink_wrap)\n+\t    cfa_restores = add_crlr_cfa_restore (info, cfa_restores);\n \n \t  sym = rs6000_savres_routine_sym (info,\n \t\t\t\t\t   SAVRES_FPR | (lr ? SAVRES_LR : 0));\n@@ -21221,7 +21280,7 @@ rs6000_emit_epilogue (int sibcall)\n \t      reg = gen_rtx_REG (DFmode, info->first_fp_reg_save + i);\n \n \t      RTVEC_ELT (p, i + 4) = gen_rtx_SET (VOIDmode, reg, mem);\n-\t      if (DEFAULT_ABI == ABI_V4 || flag_shrink_wrap)\n+\t      if (flag_shrink_wrap)\n \t\tcfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg,\n \t\t\t\t\t       cfa_restores);\n \t    }"}]}