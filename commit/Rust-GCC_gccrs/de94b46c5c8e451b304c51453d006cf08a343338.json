{"sha": "de94b46c5c8e451b304c51453d006cf08a343338", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGU5NGI0NmM1YzhlNDUxYjMwNGM1MTQ1M2QwMDZjZjA4YTM0MzMzOA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2003-04-03T15:42:16Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2003-04-03T15:42:16Z"}, "message": "gengtype-lex.l (IWORD): Add CHAR_BITFIELD.\n\ngcc:\n\t* gengtype-lex.l (IWORD): Add CHAR_BITFIELD.\n\t* system.h (CHAR_BITFIELD): New.\ncp:\n\t* operators.def (DEF_SIMPLE_OPERATOR, DEF_ASSN_OPERATOR,\n\tDEF_ASSN_OPERATOR): Delete spurious semi-colon.\n\t* rtti.c (dfs_class_hint_mark): Likewise.\n\n\t* decl.c (push_local_name, push_class_level_binding,\n\tmaybe_inject_for_scope_var): Don't use POP_TIMEVAR_AND_RETURN in\n\tfunctions returning void.\n\t* decl2.c (add_using_namespace): Likewise.\n\n\t* decl.c (print_binding_level, print_other_binding_stack,\n\tprint_binding_stack): Cast argument of %p specifier to void*.\n\t* ptree.c (cxx_print_decl): Likewise.\n\n\t* cp-tree.h (VAR_OR_FUNCTION_DECL_CHECK,\n\tVAR_FUNCTION_OR_PARM_DECL_CHECK,\n\tVAR_TEMPL_TYPE_OR_FUNCTION_DECL_CHECK, RECORD_OR_UNION_TYPE_CHECK,\n\tBOUND_TEMPLATE_TEMPLATE_PARM_TYPE_CHECK, LANG_TYPE_CLASS_CHECK,\n\tLANG_TYPE_PTRMEM_CHECK, LANG_DECL_U2_CHECK): Add __extension__.\n\n\t* decl.c (set_current_binding_level): New macro.  Use throughout\n\twhen setting the current binding level.\n\n\t* cp-tree.h (cp_lvalue_kind, base_access): Delete trailing comma\n\tin enum.\n\t* method.c (mangling_flags): Likewise.\n\n\t* cp-tree.h (lang_type_header): Add __extension__ and use\n\tCHAR_BITFIELD for members.\n\nFrom-SVN: r65201", "tree": {"sha": "d3d44863b6742a605d5b7492dbb65562073f1f4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3d44863b6742a605d5b7492dbb65562073f1f4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de94b46c5c8e451b304c51453d006cf08a343338", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de94b46c5c8e451b304c51453d006cf08a343338", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de94b46c5c8e451b304c51453d006cf08a343338", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de94b46c5c8e451b304c51453d006cf08a343338/comments", "author": null, "committer": null, "parents": [{"sha": "203dcb741cbd8542593607b34f68ce6b6dba83c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/203dcb741cbd8542593607b34f68ce6b6dba83c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/203dcb741cbd8542593607b34f68ce6b6dba83c3"}], "stats": {"total": 168, "additions": 115, "deletions": 53}, "files": [{"sha": "3d9392bf3763ee09e1864b5559416d083fe0dd1a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de94b46c5c8e451b304c51453d006cf08a343338/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de94b46c5c8e451b304c51453d006cf08a343338/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=de94b46c5c8e451b304c51453d006cf08a343338", "patch": "@@ -1,3 +1,8 @@\n+2003-04-03  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* gengtype-lex.l (IWORD): Add CHAR_BITFIELD.\n+\t* system.h (CHAR_BITFIELD): New.\n+\n 2003-04-03  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/h8300.md (a peephole2): Generalize to accept GT"}, {"sha": "8667f01bd81c511612a6e59c102577eab55ab0a9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de94b46c5c8e451b304c51453d006cf08a343338/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de94b46c5c8e451b304c51453d006cf08a343338/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=de94b46c5c8e451b304c51453d006cf08a343338", "patch": "@@ -1,3 +1,34 @@\n+2003-04-03  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* operators.def (DEF_SIMPLE_OPERATOR, DEF_ASSN_OPERATOR,\n+\tDEF_ASSN_OPERATOR): Delete spurious semi-colon.\n+\t* rtti.c (dfs_class_hint_mark): Likewise.\n+\n+\t* decl.c (push_local_name, push_class_level_binding,\n+\tmaybe_inject_for_scope_var): Don't use POP_TIMEVAR_AND_RETURN in\n+\tfunctions returning void.\n+\t* decl2.c (add_using_namespace): Likewise.\n+\n+\t* decl.c (print_binding_level, print_other_binding_stack,\n+\tprint_binding_stack): Cast argument of %p specifier to void*.\n+\t* ptree.c (cxx_print_decl): Likewise.\n+\n+\t* cp-tree.h (VAR_OR_FUNCTION_DECL_CHECK,\n+\tVAR_FUNCTION_OR_PARM_DECL_CHECK,\n+\tVAR_TEMPL_TYPE_OR_FUNCTION_DECL_CHECK, RECORD_OR_UNION_TYPE_CHECK,\n+\tBOUND_TEMPLATE_TEMPLATE_PARM_TYPE_CHECK, LANG_TYPE_CLASS_CHECK,\n+\tLANG_TYPE_PTRMEM_CHECK, LANG_DECL_U2_CHECK): Add __extension__.\n+\n+\t* decl.c (set_current_binding_level): New macro.  Use throughout\n+\twhen setting the current binding level.\n+\n+\t* cp-tree.h (cp_lvalue_kind, base_access): Delete trailing comma\n+\tin enum.\n+\t* method.c (mangling_flags): Likewise.\n+\n+\t* cp-tree.h (lang_type_header): Add __extension__ and use\n+\tCHAR_BITFIELD for members.\n+\n 2003-04-02  Geoffrey Keating  <geoffk@apple.com>\n \n \tPR other/9274"}, {"sha": "66c6355a7cf86c01dd1213b62e7dcd1e6644150c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de94b46c5c8e451b304c51453d006cf08a343338/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de94b46c5c8e451b304c51453d006cf08a343338/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=de94b46c5c8e451b304c51453d006cf08a343338", "patch": "@@ -158,15 +158,15 @@ struct diagnostic_context;\n \n #if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)\n \n-#define VAR_OR_FUNCTION_DECL_CHECK(NODE)\t\t\t\\\n+#define VAR_OR_FUNCTION_DECL_CHECK(NODE) __extension__\t\t\\\n ({  const tree __t = (NODE);\t\t\t\t\t\\\n     enum tree_code const __c = TREE_CODE(__t);\t\t\t\\\n     if (__c != VAR_DECL && __c != FUNCTION_DECL)\t\t\\\n       tree_check_failed (__t, VAR_DECL, __FILE__, __LINE__,\t\\\n \t\t\t __FUNCTION__);\t\t\t\t\\\n     __t; })\n \n-#define VAR_FUNCTION_OR_PARM_DECL_CHECK(NODE)\t\t\t\\\n+#define VAR_FUNCTION_OR_PARM_DECL_CHECK(NODE) __extension__\t\\\n ({  const tree __t = (NODE);\t\t\t\t\t\\\n     enum tree_code const __c = TREE_CODE(__t);\t\t\t\\\n     if (__c != VAR_DECL\t\t\t\t\t\t\\\n@@ -176,7 +176,7 @@ struct diagnostic_context;\n \t\t\t __FUNCTION__);\t\t\t\t\\\n     __t; })\n \n-#define VAR_TEMPL_TYPE_OR_FUNCTION_DECL_CHECK(NODE)\t\t\\\n+#define VAR_TEMPL_TYPE_OR_FUNCTION_DECL_CHECK(NODE) __extension__ \\\n ({  const tree __t = (NODE);\t\t\t\t\t\\\n     enum tree_code const __c = TREE_CODE(__t);\t\t\t\\\n     if (__c != VAR_DECL\t\t\t\t\t\t\\\n@@ -187,15 +187,15 @@ struct diagnostic_context;\n \t\t\t __FUNCTION__);\t\t\t\t\\\n     __t; })\n \n-#define RECORD_OR_UNION_TYPE_CHECK(NODE)\t\t\t\\\n+#define RECORD_OR_UNION_TYPE_CHECK(NODE) __extension__\t\t\\\n ({  const tree __t = (NODE);\t\t\t\t\t\\\n     enum tree_code const __c = TREE_CODE(__t);\t\t\t\\\n     if (__c != RECORD_TYPE && __c != UNION_TYPE)\t\t\\\n       tree_check_failed (__t, RECORD_TYPE, __FILE__, __LINE__,\t\\\n \t\t\t __FUNCTION__);\t\t\t\t\\\n     __t; })\n \n-#define BOUND_TEMPLATE_TEMPLATE_PARM_TYPE_CHECK(NODE)\t\t\\\n+#define BOUND_TEMPLATE_TEMPLATE_PARM_TYPE_CHECK(NODE) __extension__ \\\n ({  const tree __t = (NODE);\t\t\t\t\t\\\n     enum tree_code const __c = TREE_CODE(__t);\t\t\t\\\n     if (__c != BOUND_TEMPLATE_TEMPLATE_PARM)\t\t\t\\\n@@ -1036,17 +1036,17 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n /* This is a few header flags for 'struct lang_type'.  Actually,\n    all but the first are used only for lang_type_class; they\n    are put in this structure to save space.  */\n-struct lang_type_header GTY(())\n+__extension__ struct lang_type_header GTY(())\n {\n-  unsigned char is_lang_type_class : 1;\n-\n-  unsigned char has_type_conversion : 1;\n-  unsigned char has_init_ref : 1;\n-  unsigned char has_default_ctor : 1;\n-  unsigned char uses_multiple_inheritance : 1;\n-  unsigned char const_needs_init : 1;\n-  unsigned char ref_needs_init : 1;\n-  unsigned char has_const_assign_ref : 1;\n+  CHAR_BITFIELD is_lang_type_class : 1;\n+\n+  CHAR_BITFIELD has_type_conversion : 1;\n+  CHAR_BITFIELD has_init_ref : 1;\n+  CHAR_BITFIELD has_default_ctor : 1;\n+  CHAR_BITFIELD uses_multiple_inheritance : 1;\n+  CHAR_BITFIELD const_needs_init : 1;\n+  CHAR_BITFIELD ref_needs_init : 1;\n+  CHAR_BITFIELD has_const_assign_ref : 1;\n };\n \n /* This structure provides additional information above and beyond\n@@ -1154,13 +1154,13 @@ struct lang_type GTY(())\n \n #if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)\n \n-#define LANG_TYPE_CLASS_CHECK(NODE)\t\t\t\t\\\n+#define LANG_TYPE_CLASS_CHECK(NODE) __extension__\t\t\\\n ({  struct lang_type *lt = TYPE_LANG_SPECIFIC (NODE);\t\t\\\n     if (! lt->u.h.is_lang_type_class)\t\t\t\t\\\n       lang_check_failed (__FILE__, __LINE__, __FUNCTION__);\t\\\n     &lt->u.c; })\n \n-#define LANG_TYPE_PTRMEM_CHECK(NODE)\t\t\t\t\\\n+#define LANG_TYPE_PTRMEM_CHECK(NODE) __extension__\t\t\\\n ({  struct lang_type *lt = TYPE_LANG_SPECIFIC (NODE);\t\t\\\n     if (lt->u.h.is_lang_type_class)\t\t\t\t\\\n       lang_check_failed (__FILE__, __LINE__, __FUNCTION__);\t\\\n@@ -1748,7 +1748,7 @@ struct lang_decl GTY(())\n \n #if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)\n \n-#define LANG_DECL_U2_CHECK(NODE, TF)\t\t\t\t\\\n+#define LANG_DECL_U2_CHECK(NODE, TF) __extension__\t\t\\\n ({  struct lang_decl *lt = DECL_LANG_SPECIFIC (NODE);\t\t\\\n     if (lt->decl_flags.u2sel != TF)\t\t\t\t\\\n       lang_check_failed (__FILE__, __LINE__, __FUNCTION__);\t\\\n@@ -2941,7 +2941,7 @@ typedef enum cp_lvalue_kind {\n   clk_none = 0,     /* Things that are not an lvalue.  */\n   clk_ordinary = 1, /* An ordinary lvalue.  */\n   clk_class = 2,    /* An rvalue of class-type.  */\n-  clk_bitfield = 4, /* An lvalue for a bit-field.  */\n+  clk_bitfield = 4  /* An lvalue for a bit-field.  */\n } cp_lvalue_kind;\n \n /* The kinds of scopes we recognize.  */\n@@ -3051,7 +3051,7 @@ typedef enum base_access {\n   ba_check = 2,    /* Check access */\n   ba_not_special = 3, /* Do not consider special privilege\n \t\t         current_class_type might give.  */\n-  ba_quiet = 4,    /* Do not issue error messages (bit mask).  */\n+  ba_quiet = 4     /* Do not issue error messages (bit mask).  */\n } base_access;\n \n /* The kind of base we can find, looking in a class hierarchy."}, {"sha": "f33b733e325e4fe93c382d172f3352aea49b3cfc", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 40, "deletions": 21, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de94b46c5c8e451b304c51453d006cf08a343338/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de94b46c5c8e451b304c51453d006cf08a343338/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=de94b46c5c8e451b304c51453d006cf08a343338", "patch": "@@ -438,6 +438,14 @@ struct cp_binding_level GTY(())\n    ? cp_function_chain->bindings\t\t\\\n    : scope_chain->bindings)\n \n+#define set_current_binding_level(bl) do {\t\\\n+   struct cp_binding_level * const bl_ = bl;\t\\\n+   if (cfun && cp_function_chain->bindings)\t\\\n+     cp_function_chain->bindings = bl_;\t\t\\\n+   else\t\t\t\t\t\t\\\n+     scope_chain->bindings = bl_;\t\t\\\n+ } while (0)\n+\n /* The binding level of the current class, if any.  */\n \n #define class_binding_level scope_chain->class_bindings\n@@ -487,7 +495,7 @@ push_binding_level (struct cp_binding_level *newlevel,\n      are active.  */\n   memset ((char*) newlevel, 0, sizeof (struct cp_binding_level));\n   newlevel->level_chain = current_binding_level;\n-  current_binding_level = newlevel;\n+  set_current_binding_level (newlevel);\n   newlevel->tag_transparent = tag_transparent;\n   newlevel->more_cleanups_ok = 1;\n \n@@ -543,7 +551,7 @@ pop_binding_level (void)\n #endif /* defined(DEBUG_BINDING_LEVELS) */\n   {\n     register struct cp_binding_level *level = current_binding_level;\n-    current_binding_level = current_binding_level->level_chain;\n+    set_current_binding_level (current_binding_level->level_chain);\n     level->level_chain = free_binding_level;\n #if 0 /* defined(DEBUG_BINDING_LEVELS) */\n     if (level->binding_depth != binding_depth)\n@@ -558,7 +566,7 @@ static void\n suspend_binding_level (void)\n {\n   if (class_binding_level)\n-    current_binding_level = class_binding_level;\n+    set_current_binding_level (class_binding_level);\n \n   if (global_binding_level)\n     {\n@@ -580,7 +588,7 @@ suspend_binding_level (void)\n     }\n   is_class_level = 0;\n #endif /* defined(DEBUG_BINDING_LEVELS) */\n-  current_binding_level = current_binding_level->level_chain;\n+  set_current_binding_level (current_binding_level->level_chain);\n   find_class_binding_level ();\n }\n \n@@ -592,7 +600,7 @@ resume_binding_level (struct cp_binding_level* b)\n   my_friendly_assert(!class_binding_level, 386);\n   /* Also, resuming a non-directly nested namespace is a no-no.  */\n   my_friendly_assert(b->level_chain == current_binding_level, 386);\n-  current_binding_level = b;\n+  set_current_binding_level (b);\n #if defined(DEBUG_BINDING_LEVELS)\n   b->binding_depth = binding_depth;\n   indent ();\n@@ -1860,7 +1868,7 @@ print_binding_level (struct cp_binding_level* lvl)\n   tree t;\n   int i = 0, len;\n   fprintf (stderr, \" blocks=\");\n-  fprintf (stderr, HOST_PTR_PRINTF, lvl->blocks);\n+  fprintf (stderr, HOST_PTR_PRINTF, (void *) lvl->blocks);\n   if (lvl->tag_transparent)\n     fprintf (stderr, \" tag-transparent\");\n   if (lvl->more_cleanups_ok)\n@@ -1961,7 +1969,7 @@ print_other_binding_stack (struct cp_binding_level *stack)\n   for (level = stack; level != global_binding_level; level = level->level_chain)\n     {\n       fprintf (stderr, \"binding level \");\n-      fprintf (stderr, HOST_PTR_PRINTF, level);\n+      fprintf (stderr, HOST_PTR_PRINTF, (void *) level);\n       fprintf (stderr, \"\\n\");\n       print_binding_level (level);\n     }\n@@ -1972,11 +1980,11 @@ print_binding_stack (void)\n {\n   struct cp_binding_level *b;\n   fprintf (stderr, \"current_binding_level=\");\n-  fprintf (stderr, HOST_PTR_PRINTF, current_binding_level);\n+  fprintf (stderr, HOST_PTR_PRINTF, (void *) current_binding_level);\n   fprintf (stderr, \"\\nclass_binding_level=\");\n-  fprintf (stderr, HOST_PTR_PRINTF, class_binding_level);\n+  fprintf (stderr, HOST_PTR_PRINTF, (void *) class_binding_level);\n   fprintf (stderr, \"\\nglobal_binding_level=\");\n-  fprintf (stderr, HOST_PTR_PRINTF, global_binding_level);\n+  fprintf (stderr, HOST_PTR_PRINTF, (void *) global_binding_level);\n   fprintf (stderr, \"\\n\");\n   if (class_binding_level)\n     {\n@@ -2497,7 +2505,8 @@ push_local_name (tree decl)\n \t    DECL_DISCRIMINATOR (decl) = 1;\n \n \t  VARRAY_TREE (local_names, i) = decl;\n-\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, (void)0);\n+\t  timevar_pop (TV_NAME_LOOKUP);\n+\t  return;\n \t}\n     }\n \n@@ -4065,9 +4074,9 @@ pushdecl_with_scope (tree x, struct cp_binding_level* level)\n   else\n     {\n       b = current_binding_level;\n-      current_binding_level = level;\n+      set_current_binding_level (level);\n       x = pushdecl (x);\n-      current_binding_level = b;\n+      set_current_binding_level (b);\n     }\n   current_function_decl = function_decl;\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, x);\n@@ -4205,7 +4214,10 @@ push_class_level_binding (tree name, tree x)\n   /* The class_binding_level will be NULL if x is a template\n      parameter name in a member template.  */\n   if (!class_binding_level)\n-    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, (void)0);\n+    {\n+      timevar_pop (TV_NAME_LOOKUP);\n+      return;\n+    }\n \n   /* Make sure that this new member does not have the same name\n      as a template parameter.  */\n@@ -4255,7 +4267,8 @@ push_class_level_binding (tree name, tree x)\n \t    INHERITED_VALUE_BINDING_P (binding) = 0;\n \t    TREE_TYPE (shadow) = x;\n \t    IDENTIFIER_CLASS_VALUE (name) = x;\n-\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, (void)0);\n+\t    timevar_pop (TV_NAME_LOOKUP);\n+\t    return;\n \t  }\n     }\n \n@@ -6190,7 +6203,7 @@ cxx_init_decl_processing (void)\n   current_lang_name = lang_name_c;\n \n   current_function_decl = NULL_TREE;\n-  current_binding_level = NULL_BINDING_LEVEL;\n+  set_current_binding_level (NULL_BINDING_LEVEL);\n   free_binding_level = NULL_BINDING_LEVEL;\n \n   build_common_tree_nodes (flag_signed_char);\n@@ -7846,13 +7859,19 @@ maybe_inject_for_scope_var (tree decl)\n {\n   timevar_push (TV_NAME_LOOKUP);\n   if (!DECL_NAME (decl))\n-    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, (void)0);\n+    {\n+      timevar_pop (TV_NAME_LOOKUP);\n+      return;\n+    }\n   \n   /* Declarations of __FUNCTION__ and its ilk appear magically when\n      the variable is first used.  If that happens to be inside a\n      for-loop, we don't want to do anything special.  */\n   if (DECL_PRETTY_FUNCTION_P (decl))\n-    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, (void)0);\n+    {\n+      timevar_pop (TV_NAME_LOOKUP);\n+      return;\n+    }\n \n   if (current_binding_level->is_for_scope)\n     {\n@@ -9960,10 +9979,10 @@ grokdeclarator (tree declarator,\n   if (decl_context == NORMAL && !toplevel_bindings_p ())\n     {\n       struct cp_binding_level *b = current_binding_level;\n-      current_binding_level = b->level_chain;\n+      set_current_binding_level (b->level_chain);\n       if (current_binding_level != 0 && toplevel_bindings_p ())\n \tdecl_context = PARM;\n-      current_binding_level = b;\n+      set_current_binding_level (b);\n     }\n \n   if (name == NULL)\n@@ -13433,7 +13452,7 @@ start_function (tree declspecs, tree declarator, tree attrs, int flags)\n      FIXME factor out the non-RTL stuff.  */\n   bl = current_binding_level;\n   init_function_start (decl1, input_filename, lineno);\n-  current_binding_level = bl;\n+  set_current_binding_level (bl);\n \n   /* Even though we're inside a function body, we still don't want to\n      call expand_expr to calculate the size of a variable-sized array."}, {"sha": "0f8617c141f26454016786944f0b9ea552e03063", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de94b46c5c8e451b304c51453d006cf08a343338/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de94b46c5c8e451b304c51453d006cf08a343338/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=de94b46c5c8e451b304c51453d006cf08a343338", "patch": "@@ -3457,7 +3457,10 @@ add_using_namespace (tree user, tree used, bool indirect)\n   timevar_push (TV_NAME_LOOKUP);\n   /* Using oneself is a no-op.  */\n   if (user == used)\n-    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, (void)0);\n+    {\n+      timevar_pop (TV_NAME_LOOKUP);\n+      return;\n+    }\n   my_friendly_assert (TREE_CODE (user) == NAMESPACE_DECL, 380);\n   my_friendly_assert (TREE_CODE (used) == NAMESPACE_DECL, 380);\n   /* Check if we already have this.  */\n@@ -3467,7 +3470,8 @@ add_using_namespace (tree user, tree used, bool indirect)\n       if (!indirect)\n \t/* Promote to direct usage.  */\n \tTREE_INDIRECT_USING (t) = 0;\n-      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, (void)0);\n+      timevar_pop (TV_NAME_LOOKUP);\n+      return;\n     }\n \n   /* Add used to the user's using list.  */"}, {"sha": "b5a88f2f11d12416003e14b0abc85e4ba90ef5fa", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de94b46c5c8e451b304c51453d006cf08a343338/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de94b46c5c8e451b304c51453d006cf08a343338/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=de94b46c5c8e451b304c51453d006cf08a343338", "patch": "@@ -50,7 +50,7 @@ enum mangling_flags\n   mf_maybe_uninstantiated = 1,\n   /* When mangling a numeric value, use the form `_XX_' (instead of\n      just `XX') if the value has more than one digit.  */\n-  mf_use_underscores_around_value = 2,\n+  mf_use_underscores_around_value = 2\n };\n \n typedef enum mangling_flags mangling_flags;"}, {"sha": "b4de745a154ac0ed9eb6c8b3f9c5fb8636b8c2b0", "filename": "gcc/cp/operators.def", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de94b46c5c8e451b304c51453d006cf08a343338/gcc%2Fcp%2Foperators.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de94b46c5c8e451b304c51453d006cf08a343338/gcc%2Fcp%2Foperators.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foperators.def?ref=de94b46c5c8e451b304c51453d006cf08a343338", "patch": "@@ -131,7 +131,7 @@ DEF_SIMPLE_OPERATOR (\"--\", POSTDECREMENT_EXPR, \"mm\", 2)\n DEF_SIMPLE_OPERATOR (\"<?\", MIN_EXPR, \"v23min\", 2)\n DEF_SIMPLE_OPERATOR (\">?\", MAX_EXPR, \"v23max\", 2)\n /* This one is needed for mangling.  */\n-DEF_SIMPLE_OPERATOR (\"::\", SCOPE_REF, \"sr\", 2);\n+DEF_SIMPLE_OPERATOR (\"::\", SCOPE_REF, \"sr\", 2)\n \n /* Assignment operators.  */\n DEF_ASSN_OPERATOR (\"=\", NOP_EXPR, \"aS\", 2)\n@@ -146,8 +146,8 @@ DEF_ASSN_OPERATOR (\"^=\", BIT_XOR_EXPR, \"eO\", 2)\n DEF_ASSN_OPERATOR (\"<<=\", LSHIFT_EXPR, \"lS\", 2)\n DEF_ASSN_OPERATOR (\">>=\", RSHIFT_EXPR, \"rS\", 2)\n /* These operators are GNU extensions.  */\n-DEF_ASSN_OPERATOR (\"<?=\", MIN_EXPR, \"v23miN\", 2);\n-DEF_ASSN_OPERATOR (\">?=\", MAX_EXPR, \"v23maX\", 2);\n+DEF_ASSN_OPERATOR (\"<?=\", MIN_EXPR, \"v23miN\", 2)\n+DEF_ASSN_OPERATOR (\">?=\", MAX_EXPR, \"v23maX\", 2)\n \n /* Ternary operators.  */\n DEF_SIMPLE_OPERATOR (\"?:\", COND_EXPR, \"qu\", 3)"}, {"sha": "aefc9613e7587168e2a8c94927d5717304f2d551", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de94b46c5c8e451b304c51453d006cf08a343338/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de94b46c5c8e451b304c51453d006cf08a343338/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=de94b46c5c8e451b304c51453d006cf08a343338", "patch": "@@ -48,19 +48,19 @@ cxx_print_decl (FILE *file, tree node, int indent)\n       && DECL_PENDING_INLINE_INFO (node))\n     {\n       fprintf (file, \" pending-inline-info \");\n-      fprintf (file, HOST_PTR_PRINTF, DECL_PENDING_INLINE_INFO (node));\n+      fprintf (file, HOST_PTR_PRINTF, (void *) DECL_PENDING_INLINE_INFO (node));\n     }\n   if (TREE_CODE (node) == TYPE_DECL\n       && DECL_SORTED_FIELDS (node))\n     {\n       fprintf (file, \" sorted-fields \");\n-      fprintf (file, HOST_PTR_PRINTF, DECL_SORTED_FIELDS (node));\n+      fprintf (file, HOST_PTR_PRINTF, (void *) DECL_SORTED_FIELDS (node));\n     }\n   if ((TREE_CODE (node) == FUNCTION_DECL || TREE_CODE (node) == VAR_DECL)\n       && DECL_TEMPLATE_INFO (node))\n     {\n       fprintf (file, \" template-info \");\n-      fprintf (file, HOST_PTR_PRINTF,  DECL_TEMPLATE_INFO (node));\n+      fprintf (file, HOST_PTR_PRINTF, (void *) DECL_TEMPLATE_INFO (node));\n     }\n }\n "}, {"sha": "24ba0fd9b0244fafda23d110325d7c29fea87124", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de94b46c5c8e451b304c51453d006cf08a343338/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de94b46c5c8e451b304c51453d006cf08a343338/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=de94b46c5c8e451b304c51453d006cf08a343338", "patch": "@@ -922,7 +922,7 @@ dfs_class_hint_mark (tree binfo, void *data)\n       SET_CLASSTYPE_MARKED (basetype);\n     }\n   return NULL_TREE;\n-};\n+}\n \n /* Clear the base's dfs marks, after searching for duplicate bases.  */\n "}, {"sha": "36b1596651e16e2c8719b1a201c0ddc1f328b210", "filename": "gcc/gengtype-lex.l", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de94b46c5c8e451b304c51453d006cf08a343338/gcc%2Fgengtype-lex.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de94b46c5c8e451b304c51453d006cf08a343338/gcc%2Fgengtype-lex.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-lex.l?ref=de94b46c5c8e451b304c51453d006cf08a343338", "patch": "@@ -52,7 +52,7 @@ update_lineno (l, len)\n \n ID\t[[:alpha:]_][[:alnum:]_]*\n WS\t[[:space:]]+\n-IWORD\tshort|long|(un)?signed|char|int|HOST_WIDE_INT|bool|size_t\n+IWORD\tshort|long|(un)?signed|char|int|HOST_WIDE_INT|bool|size_t|CHAR_BITFIELD\n ITYPE\t{IWORD}({WS}{IWORD})*\n \n %x in_struct in_struct_comment in_comment in_yacc_escape"}, {"sha": "adece55d99bc9f743e4ab6b5546db9c9574aca95", "filename": "gcc/system.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de94b46c5c8e451b304c51453d006cf08a343338/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de94b46c5c8e451b304c51453d006cf08a343338/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=de94b46c5c8e451b304c51453d006cf08a343338", "patch": "@@ -508,13 +508,16 @@ extern void abort PARAMS ((void));\n #define HOST_BIT_BUCKET \"/dev/null\"\n #endif\n \n-/* Be conservative and only use enum bitfields with GCC.\n+/* Be conservative and only use enum bitfields with GCC.  Likewise for\n+   char bitfields.\n    FIXME: provide a complete autoconf test for buggy enum bitfields.  */\n \n #if (GCC_VERSION > 2000)\n #define ENUM_BITFIELD(TYPE) enum TYPE\n+#define CHAR_BITFIELD unsigned char\n #else\n #define ENUM_BITFIELD(TYPE) unsigned int\n+#define CHAR_BITFIELD unsigned int\n #endif\n \n #ifndef offsetof"}]}