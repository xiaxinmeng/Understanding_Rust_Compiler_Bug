{"sha": "671a00ee70091ace175ea7391af1010d612cb89e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjcxYTAwZWU3MDA5MWFjZTE3NWVhNzM5MWFmMTAxMGQ2MTJjYjg5ZQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2017-08-01T17:21:29Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2017-08-01T17:21:29Z"}, "message": "Make mempcpy more optimal (PR middle-end/70140).\n\n2017-08-01  Martin Liska  <mliska@suse.cz>\n\n\tPR middle-end/70140\n\t* gcc.dg/string-opt-1.c: Adjust test-case to scan for memcpy.\n2017-08-01  Martin Liska  <mliska@suse.cz>\n\n\tPR middle-end/70140\n\t* builtins.c (expand_builtin_memcpy_args): Remove.\n\t(expand_builtin_memcpy): Call newly added function\n\texpand_builtin_memory_copy_args.\n\t(expand_builtin_memcpy_with_bounds): Likewise.\n\t(expand_builtin_mempcpy): Remove last argument.\n\t(expand_builtin_mempcpy_with_bounds): Likewise.\n\t(expand_builtin_memory_copy_args): New function created from\n\texpand_builtin_mempcpy_args with small modifications.\n\t(expand_builtin_mempcpy_args): Remove.\n\t(expand_builtin_stpcpy): Remove unused argument.\n\t(expand_builtin): Likewise.\n\t(expand_builtin_with_bounds): Likewise.\n\nFrom-SVN: r250789", "tree": {"sha": "deab89a2cd2fded2bbb3bc7b075d51aeb7ae9eb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/deab89a2cd2fded2bbb3bc7b075d51aeb7ae9eb2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/671a00ee70091ace175ea7391af1010d612cb89e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/671a00ee70091ace175ea7391af1010d612cb89e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/671a00ee70091ace175ea7391af1010d612cb89e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/671a00ee70091ace175ea7391af1010d612cb89e/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7d3eecca8d4cb8d11667a3998820200a439a899a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d3eecca8d4cb8d11667a3998820200a439a899a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d3eecca8d4cb8d11667a3998820200a439a899a"}], "stats": {"total": 340, "additions": 168, "deletions": 172}, "files": [{"sha": "36a02215b48d06fc5fbc9b9e458078f339606655", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671a00ee70091ace175ea7391af1010d612cb89e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671a00ee70091ace175ea7391af1010d612cb89e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=671a00ee70091ace175ea7391af1010d612cb89e", "patch": "@@ -1,3 +1,19 @@\n+2017-08-01  Martin Liska  <mliska@suse.cz>\n+\n+\tPR middle-end/70140\n+\t* builtins.c (expand_builtin_memcpy_args): Remove.\n+\t(expand_builtin_memcpy): Call newly added function\n+\texpand_builtin_memory_copy_args.\n+\t(expand_builtin_memcpy_with_bounds): Likewise.\n+\t(expand_builtin_mempcpy): Remove last argument.\n+\t(expand_builtin_mempcpy_with_bounds): Likewise.\n+\t(expand_builtin_memory_copy_args): New function created from\n+\texpand_builtin_mempcpy_args with small modifications.\n+\t(expand_builtin_mempcpy_args): Remove.\n+\t(expand_builtin_stpcpy): Remove unused argument.\n+\t(expand_builtin): Likewise.\n+\t(expand_builtin_with_bounds): Likewise.\n+\n 2017-08-01  Martin Liska  <mliska@suse.cz>\n \n \tRevert r250771"}, {"sha": "016f68d2cb610e8568d6709fd11878b84fca4db4", "filename": "gcc/builtins.c", "status": "modified", "additions": 101, "deletions": 167, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671a00ee70091ace175ea7391af1010d612cb89e/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671a00ee70091ace175ea7391af1010d612cb89e/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=671a00ee70091ace175ea7391af1010d612cb89e", "patch": "@@ -121,12 +121,12 @@ static rtx builtin_memcpy_read_str (void *, HOST_WIDE_INT, machine_mode);\n static rtx expand_builtin_memchr (tree, rtx);\n static rtx expand_builtin_memcpy (tree, rtx);\n static rtx expand_builtin_memcpy_with_bounds (tree, rtx);\n-static rtx expand_builtin_memcpy_args (tree, tree, tree, rtx, tree);\n+static rtx expand_builtin_memory_copy_args (tree dest, tree src, tree len,\n+\t\t\t\t\t    rtx target, tree exp, int endp);\n static rtx expand_builtin_memmove (tree, rtx);\n-static rtx expand_builtin_mempcpy (tree, rtx, machine_mode);\n-static rtx expand_builtin_mempcpy_with_bounds (tree, rtx, machine_mode);\n-static rtx expand_builtin_mempcpy_args (tree, tree, tree, rtx,\n-\t\t\t\t\tmachine_mode, int, tree);\n+static rtx expand_builtin_mempcpy (tree, rtx);\n+static rtx expand_builtin_mempcpy_with_bounds (tree, rtx);\n+static rtx expand_builtin_mempcpy_args (tree, tree, tree, rtx, tree, int);\n static rtx expand_builtin_strcat (tree, rtx);\n static rtx expand_builtin_strcpy (tree, rtx);\n static rtx expand_builtin_strcpy_args (tree, tree, rtx);\n@@ -2961,81 +2961,6 @@ determine_block_size (tree len, rtx len_rtx,\n \t\t\t  GET_MODE_MASK (GET_MODE (len_rtx)));\n }\n \n-/* Helper function to do the actual work for expand_builtin_memcpy.  */\n-\n-static rtx\n-expand_builtin_memcpy_args (tree dest, tree src, tree len, rtx target, tree exp)\n-{\n-  const char *src_str;\n-  unsigned int src_align = get_pointer_alignment (src);\n-  unsigned int dest_align = get_pointer_alignment (dest);\n-  rtx dest_mem, src_mem, dest_addr, len_rtx;\n-  HOST_WIDE_INT expected_size = -1;\n-  unsigned int expected_align = 0;\n-  unsigned HOST_WIDE_INT min_size;\n-  unsigned HOST_WIDE_INT max_size;\n-  unsigned HOST_WIDE_INT probable_max_size;\n-\n-  /* If DEST is not a pointer type, call the normal function.  */\n-  if (dest_align == 0)\n-    return NULL_RTX;\n-\n-  /* If either SRC is not a pointer type, don't do this\n-     operation in-line.  */\n-  if (src_align == 0)\n-    return NULL_RTX;\n-\n-  if (currently_expanding_gimple_stmt)\n-    stringop_block_profile (currently_expanding_gimple_stmt,\n-\t\t\t    &expected_align, &expected_size);\n-\n-  if (expected_align < dest_align)\n-    expected_align = dest_align;\n-  dest_mem = get_memory_rtx (dest, len);\n-  set_mem_align (dest_mem, dest_align);\n-  len_rtx = expand_normal (len);\n-  determine_block_size (len, len_rtx, &min_size, &max_size,\n-\t\t\t&probable_max_size);\n-  src_str = c_getstr (src);\n-\n-  /* If SRC is a string constant and block move would be done\n-     by pieces, we can avoid loading the string from memory\n-     and only stored the computed constants.  */\n-  if (src_str\n-      && CONST_INT_P (len_rtx)\n-      && (unsigned HOST_WIDE_INT) INTVAL (len_rtx) <= strlen (src_str) + 1\n-      && can_store_by_pieces (INTVAL (len_rtx), builtin_memcpy_read_str,\n-\t\t\t      CONST_CAST (char *, src_str),\n-\t\t\t      dest_align, false))\n-    {\n-      dest_mem = store_by_pieces (dest_mem, INTVAL (len_rtx),\n-\t\t\t\t  builtin_memcpy_read_str,\n-\t\t\t\t  CONST_CAST (char *, src_str),\n-\t\t\t\t  dest_align, false, 0);\n-      dest_mem = force_operand (XEXP (dest_mem, 0), target);\n-      dest_mem = convert_memory_address (ptr_mode, dest_mem);\n-      return dest_mem;\n-    }\n-\n-  src_mem = get_memory_rtx (src, len);\n-  set_mem_align (src_mem, src_align);\n-\n-  /* Copy word part most expediently.  */\n-  dest_addr = emit_block_move_hints (dest_mem, src_mem, len_rtx,\n-\t\t\t\t     CALL_EXPR_TAILCALL (exp)\n-\t\t\t\t     ? BLOCK_OP_TAILCALL : BLOCK_OP_NORMAL,\n-\t\t\t\t     expected_align, expected_size,\n-\t\t\t\t     min_size, max_size, probable_max_size);\n-\n-  if (dest_addr == 0)\n-    {\n-      dest_addr = force_operand (XEXP (dest_mem, 0), target);\n-      dest_addr = convert_memory_address (ptr_mode, dest_addr);\n-    }\n-\n-  return dest_addr;\n-}\n-\n /* Try to verify that the sizes and lengths of the arguments to a string\n    manipulation function given by EXP are within valid bounds and that\n    the operation does not lead to buffer overflow.  Arguments other than\n@@ -3378,7 +3303,8 @@ expand_builtin_memcpy (tree exp, rtx target)\n \n   check_memop_sizes (exp, dest, src, len);\n \n-  return expand_builtin_memcpy_args (dest, src, len, target, exp);\n+  return expand_builtin_memory_copy_args (dest, src, len, target, exp,\n+\t\t\t\t\t  /*endp=*/ 0);\n }\n \n /* Check a call EXP to the memmove built-in for validity.\n@@ -3418,7 +3344,8 @@ expand_builtin_memcpy_with_bounds (tree exp, rtx target)\n       tree dest = CALL_EXPR_ARG (exp, 0);\n       tree src = CALL_EXPR_ARG (exp, 2);\n       tree len = CALL_EXPR_ARG (exp, 4);\n-      rtx res = expand_builtin_memcpy_args (dest, src, len, target, exp);\n+      rtx res = expand_builtin_memory_copy_args (dest, src, len, target, exp,\n+\t\t\t\t\t\t /*end_p=*/ 0);\n \n       /* Return src bounds with the result.  */\n       if (res)\n@@ -3440,7 +3367,7 @@ expand_builtin_memcpy_with_bounds (tree exp, rtx target)\n    stpcpy.  */\n \n static rtx\n-expand_builtin_mempcpy (tree exp, rtx target, machine_mode mode)\n+expand_builtin_mempcpy (tree exp, rtx target)\n {\n   if (!validate_arglist (exp,\n  \t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n@@ -3457,8 +3384,7 @@ expand_builtin_mempcpy (tree exp, rtx target, machine_mode mode)\n     return NULL_RTX;\n \n   return expand_builtin_mempcpy_args (dest, src, len,\n-\t\t\t\t      target, mode, /*endp=*/ 1,\n-\t\t\t\t      exp);\n+\t\t\t\t      target, exp, /*endp=*/ 1);\n }\n \n /* Expand an instrumented call EXP to the mempcpy builtin.\n@@ -3467,7 +3393,7 @@ expand_builtin_mempcpy (tree exp, rtx target, machine_mode mode)\n    mode MODE if that's convenient).  */\n \n static rtx\n-expand_builtin_mempcpy_with_bounds (tree exp, rtx target, machine_mode mode)\n+expand_builtin_mempcpy_with_bounds (tree exp, rtx target)\n {\n   if (!validate_arglist (exp,\n \t\t\t POINTER_TYPE, POINTER_BOUNDS_TYPE,\n@@ -3480,7 +3406,7 @@ expand_builtin_mempcpy_with_bounds (tree exp, rtx target, machine_mode mode)\n       tree src = CALL_EXPR_ARG (exp, 2);\n       tree len = CALL_EXPR_ARG (exp, 4);\n       rtx res = expand_builtin_mempcpy_args (dest, src, len, target,\n-\t\t\t\t\t     mode, 1, exp);\n+\t\t\t\t\t     exp, 1);\n \n       /* Return src bounds with the result.  */\n       if (res)\n@@ -3493,94 +3419,103 @@ expand_builtin_mempcpy_with_bounds (tree exp, rtx target, machine_mode mode)\n     }\n }\n \n-/* Helper function to do the actual work for expand_builtin_mempcpy.  The\n-   arguments to the builtin_mempcpy call DEST, SRC, and LEN are broken out\n-   so that this can also be called without constructing an actual CALL_EXPR.\n-   The other arguments and return value are the same as for\n-   expand_builtin_mempcpy.  */\n+/* Helper function to do the actual work for expand of memory copy family\n+   functions (memcpy, mempcpy, stpcpy).  Expansing should assign LEN bytes\n+   of memory from SRC to DEST and assign to TARGET if convenient.\n+   If ENDP is 0 return the\n+   destination pointer, if ENDP is 1 return the end pointer ala\n+   mempcpy, and if ENDP is 2 return the end pointer minus one ala\n+   stpcpy.  */\n \n static rtx\n-expand_builtin_mempcpy_args (tree dest, tree src, tree len,\n-\t\t\t     rtx target, machine_mode mode, int endp,\n-\t\t\t     tree orig_exp)\n+expand_builtin_memory_copy_args (tree dest, tree src, tree len,\n+\t\t\t\t rtx target, tree exp, int endp)\n {\n-  tree fndecl = get_callee_fndecl (orig_exp);\n+  const char *src_str;\n+  unsigned int src_align = get_pointer_alignment (src);\n+  unsigned int dest_align = get_pointer_alignment (dest);\n+  rtx dest_mem, src_mem, dest_addr, len_rtx;\n+  HOST_WIDE_INT expected_size = -1;\n+  unsigned int expected_align = 0;\n+  unsigned HOST_WIDE_INT min_size;\n+  unsigned HOST_WIDE_INT max_size;\n+  unsigned HOST_WIDE_INT probable_max_size;\n \n-    /* If return value is ignored, transform mempcpy into memcpy.  */\n-  if (target == const0_rtx\n-      && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_CHKP_MEMPCPY_NOBND_NOCHK_CHKP\n-      && builtin_decl_implicit_p (BUILT_IN_CHKP_MEMCPY_NOBND_NOCHK_CHKP))\n-    {\n-      tree fn = builtin_decl_implicit (BUILT_IN_CHKP_MEMCPY_NOBND_NOCHK_CHKP);\n-      tree result = build_call_nofold_loc (UNKNOWN_LOCATION, fn, 3,\n-\t\t\t\t\t   dest, src, len);\n-      return expand_expr (result, target, mode, EXPAND_NORMAL);\n-    }\n-  else if (target == const0_rtx\n-\t   && builtin_decl_implicit_p (BUILT_IN_MEMCPY))\n-    {\n-      tree fn = builtin_decl_implicit (BUILT_IN_MEMCPY);\n-      tree result = build_call_nofold_loc (UNKNOWN_LOCATION, fn, 3,\n-\t\t\t\t\t   dest, src, len);\n-      return expand_expr (result, target, mode, EXPAND_NORMAL);\n-    }\n-  else\n-    {\n-      const char *src_str;\n-      unsigned int src_align = get_pointer_alignment (src);\n-      unsigned int dest_align = get_pointer_alignment (dest);\n-      rtx dest_mem, src_mem, len_rtx;\n+  /* If DEST is not a pointer type, call the normal function.  */\n+  if (dest_align == 0)\n+    return NULL_RTX;\n \n-      /* If either SRC or DEST is not a pointer type, don't do this\n-\t operation in-line.  */\n-      if (dest_align == 0 || src_align == 0)\n-\treturn NULL_RTX;\n+  /* If either SRC is not a pointer type, don't do this\n+     operation in-line.  */\n+  if (src_align == 0)\n+    return NULL_RTX;\n \n-      /* If LEN is not constant, call the normal function.  */\n-      if (! tree_fits_uhwi_p (len))\n-\treturn NULL_RTX;\n+  if (currently_expanding_gimple_stmt)\n+    stringop_block_profile (currently_expanding_gimple_stmt,\n+\t\t\t    &expected_align, &expected_size);\n \n-      len_rtx = expand_normal (len);\n-      src_str = c_getstr (src);\n+  if (expected_align < dest_align)\n+    expected_align = dest_align;\n+  dest_mem = get_memory_rtx (dest, len);\n+  set_mem_align (dest_mem, dest_align);\n+  len_rtx = expand_normal (len);\n+  determine_block_size (len, len_rtx, &min_size, &max_size,\n+\t\t\t&probable_max_size);\n+  src_str = c_getstr (src);\n \n-      /* If SRC is a string constant and block move would be done\n-\t by pieces, we can avoid loading the string from memory\n-\t and only stored the computed constants.  */\n-      if (src_str\n-\t  && CONST_INT_P (len_rtx)\n-\t  && (unsigned HOST_WIDE_INT) INTVAL (len_rtx) <= strlen (src_str) + 1\n-\t  && can_store_by_pieces (INTVAL (len_rtx), builtin_memcpy_read_str,\n+  /* If SRC is a string constant and block move would be done\n+     by pieces, we can avoid loading the string from memory\n+     and only stored the computed constants.  */\n+  if (src_str\n+      && CONST_INT_P (len_rtx)\n+      && (unsigned HOST_WIDE_INT) INTVAL (len_rtx) <= strlen (src_str) + 1\n+      && can_store_by_pieces (INTVAL (len_rtx), builtin_memcpy_read_str,\n+\t\t\t      CONST_CAST (char *, src_str),\n+\t\t\t      dest_align, false))\n+    {\n+      dest_mem = store_by_pieces (dest_mem, INTVAL (len_rtx),\n+\t\t\t\t  builtin_memcpy_read_str,\n \t\t\t\t  CONST_CAST (char *, src_str),\n-\t\t\t\t  dest_align, false))\n-\t{\n-\t  dest_mem = get_memory_rtx (dest, len);\n-\t  set_mem_align (dest_mem, dest_align);\n-\t  dest_mem = store_by_pieces (dest_mem, INTVAL (len_rtx),\n-\t\t\t\t      builtin_memcpy_read_str,\n-\t\t\t\t      CONST_CAST (char *, src_str),\n-\t\t\t\t      dest_align, false, endp);\n-\t  dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n-\t  dest_mem = convert_memory_address (ptr_mode, dest_mem);\n-\t  return dest_mem;\n-\t}\n+\t\t\t\t  dest_align, false, endp);\n+      dest_mem = force_operand (XEXP (dest_mem, 0), target);\n+      dest_mem = convert_memory_address (ptr_mode, dest_mem);\n+      return dest_mem;\n+    }\n \n-      if (CONST_INT_P (len_rtx)\n-\t  && can_move_by_pieces (INTVAL (len_rtx),\n-\t\t\t\t MIN (dest_align, src_align)))\n-\t{\n-\t  dest_mem = get_memory_rtx (dest, len);\n-\t  set_mem_align (dest_mem, dest_align);\n-\t  src_mem = get_memory_rtx (src, len);\n-\t  set_mem_align (src_mem, src_align);\n-\t  dest_mem = move_by_pieces (dest_mem, src_mem, INTVAL (len_rtx),\n-\t\t\t\t     MIN (dest_align, src_align), endp);\n-\t  dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n-\t  dest_mem = convert_memory_address (ptr_mode, dest_mem);\n-\t  return dest_mem;\n-\t}\n+  src_mem = get_memory_rtx (src, len);\n+  set_mem_align (src_mem, src_align);\n \n-      return NULL_RTX;\n+  /* Copy word part most expediently.  */\n+  dest_addr = emit_block_move_hints (dest_mem, src_mem, len_rtx,\n+\t\t\t\t     CALL_EXPR_TAILCALL (exp)\n+\t\t\t\t     && (endp == 0 || target == const0_rtx)\n+\t\t\t\t     ? BLOCK_OP_TAILCALL : BLOCK_OP_NORMAL,\n+\t\t\t\t     expected_align, expected_size,\n+\t\t\t\t     min_size, max_size, probable_max_size);\n+\n+  if (dest_addr == 0)\n+    {\n+      dest_addr = force_operand (XEXP (dest_mem, 0), target);\n+      dest_addr = convert_memory_address (ptr_mode, dest_addr);\n     }\n+\n+  if (endp && target != const0_rtx)\n+    {\n+      dest_addr = gen_rtx_PLUS (ptr_mode, dest_addr, len_rtx);\n+      /* stpcpy pointer to last byte.  */\n+      if (endp == 2)\n+\tdest_addr = gen_rtx_MINUS (ptr_mode, dest_addr, const1_rtx);\n+    }\n+\n+  return dest_addr;\n+}\n+\n+static rtx\n+expand_builtin_mempcpy_args (tree dest, tree src, tree len,\n+\t\t\t     rtx target, tree orig_exp, int endp)\n+{\n+  return expand_builtin_memory_copy_args (dest, src, len, target, orig_exp,\n+\t\t\t\t\t  endp);\n }\n \n /* Expand into a movstr instruction, if one is available.  Return NULL_RTX if\n@@ -3738,8 +3673,7 @@ expand_builtin_stpcpy (tree exp, rtx target, machine_mode mode)\n \n       lenp1 = size_binop_loc (loc, PLUS_EXPR, len, ssize_int (1));\n       ret = expand_builtin_mempcpy_args (dst, src, lenp1,\n-\t\t\t\t\t target, mode, /*endp=*/2,\n-\t\t\t\t\t exp);\n+\t\t\t\t\t target, exp, /*endp=*/2);\n \n       if (ret)\n \treturn ret;\n@@ -6902,7 +6836,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n       break;\n \n     case BUILT_IN_MEMPCPY:\n-      target = expand_builtin_mempcpy (exp, target, mode);\n+      target = expand_builtin_mempcpy (exp, target);\n       if (target)\n \treturn target;\n       break;\n@@ -7681,7 +7615,7 @@ expand_builtin_with_bounds (tree exp, rtx target,\n       break;\n \n     case BUILT_IN_CHKP_MEMPCPY_NOBND_NOCHK_CHKP:\n-      target = expand_builtin_mempcpy_with_bounds (exp, target, mode);\n+      target = expand_builtin_mempcpy_with_bounds (exp, target);\n       if (target)\n \treturn target;\n       break;"}, {"sha": "53081a7c3304a64784ea4b005f4a03ad6ccd3543", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671a00ee70091ace175ea7391af1010d612cb89e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671a00ee70091ace175ea7391af1010d612cb89e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=671a00ee70091ace175ea7391af1010d612cb89e", "patch": "@@ -1,3 +1,8 @@\n+2017-08-01  Martin Liska  <mliska@suse.cz>\n+\n+\tPR middle-end/70140\n+\t* gcc.dg/string-opt-1.c: Adjust test-case to scan for memcpy.\n+\n 2017-08-01  Martin Liska  <mliska@suse.cz>\n \n \tRevert r250771"}, {"sha": "2f060732bf042e7083dfef0824ffc3c84b6e65a4", "filename": "gcc/testsuite/gcc.dg/string-opt-1.c", "status": "modified", "additions": 46, "deletions": 5, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671a00ee70091ace175ea7391af1010d612cb89e/gcc%2Ftestsuite%2Fgcc.dg%2Fstring-opt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671a00ee70091ace175ea7391af1010d612cb89e/gcc%2Ftestsuite%2Fgcc.dg%2Fstring-opt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstring-opt-1.c?ref=671a00ee70091ace175ea7391af1010d612cb89e", "patch": "@@ -1,11 +1,52 @@\n-/* Ensure mempcpy is not \"optimized\" into memcpy followed by addition.  */\n+/* Ensure mempcpy is \"optimized\" into memcpy followed by addition.  */\n /* { dg-do compile } */\n /* { dg-options \"-O2\" } */\n \n-void *\n-fn (char *x, char *y, int z)\n+char *buffer;\n+char *test;\n+\n+#define SIZE 100\n+\n+char *\n+__attribute__((noinline))\n+my_memcpy (char *d, char *s, unsigned l)\n+{\n+  return __builtin_memcpy (d, s, l);\n+}\n+\n+char *\n+__attribute__((noinline))\n+my_mempcpy (char *d, char *s, unsigned l)\n+{\n+  return __builtin_mempcpy (d, s, l);\n+}\n+\n+void\n+run_test (char *d, char *s, unsigned l)\n {\n-  return __builtin_mempcpy (x, y, z);\n+  char *r = my_mempcpy (d, s, l);\n+  if (r != d + l)\n+    __builtin_abort ();\n+\n+  r = my_memcpy (d, s, l);\n+  if (r != d)\n+    __builtin_abort ();\n+}\n+\n+int\n+main (void)\n+{\n+  const char* const foo = \"hello world\";\n+  unsigned l = __builtin_strlen (foo) + 1;\n+\n+  buffer = __builtin_malloc (SIZE);\n+  __builtin_memcpy (buffer, foo, l);\n+  test = __builtin_malloc (SIZE);\n+\n+  run_test (test, buffer, l);\n+\n+  return 0;\n }\n \n-/* { dg-final { scan-assembler-not \"memcpy\" } } */\n+/* { dg-final { scan-assembler-not \"\\<mempcpy\\>\" } } */\n+/* { dg-final { scan-assembler \"memcpy\" } } */"}]}