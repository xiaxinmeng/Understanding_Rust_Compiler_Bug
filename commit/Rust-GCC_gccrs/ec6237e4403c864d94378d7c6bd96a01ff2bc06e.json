{"sha": "ec6237e4403c864d94378d7c6bd96a01ff2bc06e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM2MjM3ZTQ0MDNjODY0ZDk0Mzc4ZDdjNmJkOTZhMDFmZjJiYzA2ZQ==", "commit": {"author": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2008-03-11T17:43:22Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2008-03-11T17:43:22Z"}, "message": "arm.c (use_return_insn): Check TARGET_APCS_FRAME.\n\n2008-03-11  Paul Brook  <paul@codesourcery.com>\n\tVladimir Prus  <vladimir@codesourcery.com>\n\n\t* config/arm/arm.c (use_return_insn): Check TARGET_APCS_FRAME.\n\t(arm_compute_save_reg0_reg12_mask): Always\n\tcheck if register 11 must be saved.  Always safe hard frame pointer\n\twhen frame_pointer_needeed.\n\t(arm_compute_save_reg_mask): Save IP and PC\n\tonly with apcs frames.\n\t(arm_output_epilogue): Adjust Thumb2 codepath to\n\tbe also invoked and work for ARM non-apcs frames.\n\t(arm_expand_prologue): Don't bother saving IP\n\tfor non-apcs frame, since it's not clobbered by\n\tprologue code.  Implement non-apcs frame\n\tlayout.\n\nFrom-SVN: r133117", "tree": {"sha": "9aab21af74f13d71b320c1bcf209e001e2f18eeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9aab21af74f13d71b320c1bcf209e001e2f18eeb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec6237e4403c864d94378d7c6bd96a01ff2bc06e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec6237e4403c864d94378d7c6bd96a01ff2bc06e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec6237e4403c864d94378d7c6bd96a01ff2bc06e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec6237e4403c864d94378d7c6bd96a01ff2bc06e/comments", "author": null, "committer": null, "parents": [{"sha": "2f6025a15b2eed2f15eb1a997330f097e4814641", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f6025a15b2eed2f15eb1a997330f097e4814641", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f6025a15b2eed2f15eb1a997330f097e4814641"}], "stats": {"total": 127, "additions": 86, "deletions": 41}, "files": [{"sha": "c3fb00aabe64e5809b90500fab81e23a2af3c199", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6237e4403c864d94378d7c6bd96a01ff2bc06e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6237e4403c864d94378d7c6bd96a01ff2bc06e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ec6237e4403c864d94378d7c6bd96a01ff2bc06e", "patch": "@@ -1,3 +1,19 @@\n+2008-03-11  Paul Brook  <paul@codesourcery.com>\n+\tVladimir Prus  <vladimir@codesourcery.com>\n+\n+\t* config/arm/arm.c (use_return_insn): Check TARGET_APCS_FRAME.\n+\t(arm_compute_save_reg0_reg12_mask): Always\n+\tcheck if register 11 must be saved.  Always safe hard frame pointer\n+\twhen frame_pointer_needeed.\n+\t(arm_compute_save_reg_mask): Save IP and PC\n+\tonly with apcs frames.\n+\t(arm_output_epilogue): Adjust Thumb2 codepath to\n+\tbe also invoked and work for ARM non-apcs frames.\n+\t(arm_expand_prologue): Don't bother saving IP\n+\tfor non-apcs frame, since it's not clobbered by\n+\tprologue code.  Implement non-apcs frame\n+\tlayout.\n+\n 2008-03-11  Paolo Bonzini  <bonzini@gnu.org>\n \n \tPR rtl-optimization/35281\n@@ -6,9 +22,9 @@\n \n 2008-03-11  Paolo Bonzini  <bonzini@gnu.org>\n \n-        * langhooks-def.h (LANG_HOOKS_CLEAR_BINDING_STACK): Delete.\n-        * langhooks.h (struct lang_hooks): Delete clear_binding_stack member.\n-        * toplev.c (compile_file): Don't call it.\n+\t* langhooks-def.h (LANG_HOOKS_CLEAR_BINDING_STACK): Delete.\n+\t* langhooks.h (struct lang_hooks): Delete clear_binding_stack member.\n+\t* toplev.c (compile_file): Don't call it.\n \n 2008-03-11  Uros Bizjak  <ubizjak@gmail.com>\n "}, {"sha": "531dd1fe3eb0d1dc971df20bdd3037fe6f0baa02", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 67, "deletions": 38, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6237e4403c864d94378d7c6bd96a01ff2bc06e/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6237e4403c864d94378d7c6bd96a01ff2bc06e/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=ec6237e4403c864d94378d7c6bd96a01ff2bc06e", "patch": "@@ -1662,7 +1662,8 @@ use_return_insn (int iscond, rtx sibling)\n       || current_function_calls_alloca\n       /* Or if there is a stack adjustment.  However, if the stack pointer\n \t is saved on the stack, we can use a pre-incrementing stack load.  */\n-      || !(stack_adjust == 0 || (frame_pointer_needed && stack_adjust == 4)))\n+      || !(stack_adjust == 0 || (TARGET_APCS_FRAME && frame_pointer_needed\n+\t\t\t\t && stack_adjust == 4)))\n     return 0;\n \n   saved_int_regs = arm_compute_save_reg_mask ();\n@@ -10706,25 +10707,14 @@ arm_compute_save_reg0_reg12_mask (void)\n     }\n   else\n     {\n-      /* In arm mode we handle r11 (FP) as a special case.  */\n-      unsigned last_reg = TARGET_ARM ? 10 : 11;\n-      \n       /* In the normal case we only need to save those registers\n \t which are call saved and which are used by this function.  */\n-      for (reg = 0; reg <= last_reg; reg++)\n+      for (reg = 0; reg <= 11; reg++)\n \tif (df_regs_ever_live_p (reg) && ! call_used_regs[reg])\n \t  save_reg_mask |= (1 << reg);\n \n       /* Handle the frame pointer as a special case.  */\n-      if (! TARGET_APCS_FRAME\n-\t  && ! frame_pointer_needed\n-\t  && df_regs_ever_live_p (HARD_FRAME_POINTER_REGNUM)\n-\t  && ! call_used_regs[HARD_FRAME_POINTER_REGNUM])\n-\tsave_reg_mask |= 1 << HARD_FRAME_POINTER_REGNUM;\n-      else if (! TARGET_APCS_FRAME\n-\t       && ! frame_pointer_needed\n-\t       && df_regs_ever_live_p (HARD_FRAME_POINTER_REGNUM)\n-\t       && ! call_used_regs[HARD_FRAME_POINTER_REGNUM])\n+      if (frame_pointer_needed)\n \tsave_reg_mask |= 1 << HARD_FRAME_POINTER_REGNUM;\n \n       /* If we aren't loading the PIC register,\n@@ -10775,7 +10765,7 @@ arm_compute_save_reg_mask (void)\n \n   /* If we are creating a stack frame, then we must save the frame pointer,\n      IP (which will hold the old stack pointer), LR and the PC.  */\n-  if (frame_pointer_needed && TARGET_ARM)\n+  if (TARGET_APCS_FRAME && frame_pointer_needed && TARGET_ARM)\n     save_reg_mask |=\n       (1 << ARM_HARD_FRAME_POINTER_REGNUM)\n       | (1 << IP_REGNUM)\n@@ -11306,7 +11296,7 @@ arm_output_epilogue (rtx sibling)\n     if (saved_regs_mask & (1 << reg))\n       floats_offset += 4;\n \n-  if (frame_pointer_needed && TARGET_ARM)\n+  if (TARGET_APCS_FRAME && frame_pointer_needed && TARGET_ARM)\n     {\n       /* This variable is for the Virtual Frame Pointer, not VFP regs.  */\n       int vfp_offset = offsets->frame;\n@@ -11452,32 +11442,60 @@ arm_output_epilogue (rtx sibling)\n     }\n   else\n     {\n+      /* This branch is executed for ARM mode (non-apcs frames) and\n+\t Thumb-2 mode. Frame layout is essentially the same for those\n+\t cases, except that in ARM mode frame pointer points to the\n+\t first saved register, while in Thumb-2 mode the frame pointer points\n+\t to the last saved register.\n+\n+\t It is possible to make frame pointer point to last saved\n+\t register in both cases, and remove some conditionals below.\n+\t That means that fp setup in prologue would be just \"mov fp, sp\"\n+\t and sp restore in epilogue would be just \"mov sp, fp\", whereas\n+\t now we have to use add/sub in those cases. However, the value\n+\t of that would be marginal, as both mov and add/sub are 32-bit\n+\t in ARM mode, and it would require extra conditionals\n+\t in arm_expand_prologue to distingish ARM-apcs-frame case\n+\t (where frame pointer is required to point at first register)\n+\t and ARM-non-apcs-frame. Therefore, such change is postponed\n+\t until real need arise.  */\n       HOST_WIDE_INT amount;\n       int rfe;\n       /* Restore stack pointer if necessary.  */\n-      if (frame_pointer_needed)\n-\t{\n-\t  /* For Thumb-2 restore sp from the frame pointer.\n-\t     Operand restrictions mean we have to increment FP, then copy\n-\t     to SP.  */\n-\t  amount = offsets->locals_base - offsets->saved_regs;\n-\t  operands[0] = hard_frame_pointer_rtx;\n-\t}\n-      else\n+      if (TARGET_ARM && frame_pointer_needed)\n \t{\n \t  operands[0] = stack_pointer_rtx;\n-\t  amount = offsets->outgoing_args - offsets->saved_regs;\n+\t  operands[1] = hard_frame_pointer_rtx;\n+\t  \n+\t  operands[2] = GEN_INT (offsets->frame - offsets->saved_regs);\n+\t  output_add_immediate (operands);\n \t}\n-\n-      if (amount)\n+      else\n \t{\n-\t  operands[1] = operands[0];\n-\t  operands[2] = GEN_INT (amount);\n-\t  output_add_immediate (operands);\n+\t  if (frame_pointer_needed)\n+\t    {\n+\t      /* For Thumb-2 restore sp from the frame pointer.\n+\t\t Operand restrictions mean we have to incrememnt FP, then copy\n+\t\t to SP.  */\n+\t      amount = offsets->locals_base - offsets->saved_regs;\n+\t      operands[0] = hard_frame_pointer_rtx;\n+\t    }\n+\t  else\n+\t    {\n+\t      operands[0] = stack_pointer_rtx;\n+\t      amount = offsets->outgoing_args - offsets->saved_regs;\n+\t    }\n+\t  \n+\t  if (amount)\n+\t    {\n+\t      operands[1] = operands[0];\n+\t      operands[2] = GEN_INT (amount);\n+\t      output_add_immediate (operands);\n+\t    }\n+\t  if (frame_pointer_needed)\n+\t    asm_fprintf (f, \"\\tmov\\t%r, %r\\n\",\n+\t\t\t SP_REGNUM, HARD_FRAME_POINTER_REGNUM);\n \t}\n-      if (frame_pointer_needed)\n-\tasm_fprintf (f, \"\\tmov\\t%r, %r\\n\",\n-\t\t     SP_REGNUM, HARD_FRAME_POINTER_REGNUM);\n \n       if (arm_fpu_arch == FPUTYPE_FPA_EMU2)\n \t{\n@@ -12320,7 +12338,10 @@ arm_expand_prologue (void)\n       emit_insn (gen_movsi (stack_pointer_rtx, r1));\n     }\n \n-  if (frame_pointer_needed && TARGET_ARM)\n+  /* For APCS frames, if IP register is clobbered\n+     when creating frame, save that register in a special\n+     way.  */\n+  if (TARGET_APCS_FRAME && frame_pointer_needed && TARGET_ARM)\n     {\n       if (IS_INTERRUPT (func_type))\n \t{\n@@ -12419,13 +12440,13 @@ arm_expand_prologue (void)\n     }\n \n   /* If this is an interrupt service routine, and the link register\n-     is going to be pushed, and we are not creating a stack frame,\n-     (which would involve an extra push of IP and a pop in the epilogue)\n+     is going to be pushed, and we're not generating extra\n+     push of IP (needed when frame is needed and frame layout if apcs),\n      subtracting four from LR now will mean that the function return\n      can be done with a single instruction.  */\n   if ((func_type == ARM_FT_ISR || func_type == ARM_FT_FIQ)\n       && (live_regs_mask & (1 << LR_REGNUM)) != 0\n-      && ! frame_pointer_needed\n+      && !(frame_pointer_needed && TARGET_APCS_FRAME)\n       && TARGET_ARM)\n     {\n       rtx lr = gen_rtx_REG (SImode, LR_REGNUM);\n@@ -12446,6 +12467,7 @@ arm_expand_prologue (void)\n   if (frame_pointer_needed && TARGET_ARM)\n     {\n       /* Create the new frame pointer.  */\n+      if (TARGET_APCS_FRAME)\n \t{\n \t  insn = GEN_INT (-(4 + args_to_push + fp_offset));\n \t  insn = emit_insn (gen_addsi3 (hard_frame_pointer_rtx, ip_rtx, insn));\n@@ -12467,6 +12489,13 @@ arm_expand_prologue (void)\n \t      emit_insn (gen_prologue_use (ip_rtx));\n \t    }\n \t}\n+      else\n+\t{\n+\t  insn = GEN_INT (saved_regs - 4);\n+\t  insn = emit_insn (gen_addsi3 (hard_frame_pointer_rtx,\n+\t\t\t\t\tstack_pointer_rtx, insn));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n     }\n \n   offsets = arm_get_frame_offsets ();"}]}