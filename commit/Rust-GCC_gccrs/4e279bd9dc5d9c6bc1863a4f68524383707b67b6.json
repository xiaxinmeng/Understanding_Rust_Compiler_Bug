{"sha": "4e279bd9dc5d9c6bc1863a4f68524383707b67b6", "node_id": "C_kwDOANBUbNoAKDRlMjc5YmQ5ZGM1ZDljNmJjMTg2M2E0ZjY4NTI0MzgzNzA3YjY3YjY", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-03-31T20:38:54Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-05-19T14:05:28Z"}, "message": "[Ada] Small housekeeping work\n\nNo functional changes.\n\ngcc/ada/\n\n\t* gcc-interface/trans.cc (Subprogram_Body_to_gnu): Rename a couple\n\tof local variables and use Is_Generic_Subprogram predicate.\n\t(process_decls): Likewise.", "tree": {"sha": "20792588af4a0632261c259d940157430d2bc79e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20792588af4a0632261c259d940157430d2bc79e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e279bd9dc5d9c6bc1863a4f68524383707b67b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e279bd9dc5d9c6bc1863a4f68524383707b67b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e279bd9dc5d9c6bc1863a4f68524383707b67b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e279bd9dc5d9c6bc1863a4f68524383707b67b6/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b0cd3f02ed6c151aacb50364222566bef29e72f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b0cd3f02ed6c151aacb50364222566bef29e72f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b0cd3f02ed6c151aacb50364222566bef29e72f"}], "stats": {"total": 83, "additions": 39, "deletions": 44}, "files": [{"sha": "cdd0df68e5b77734c155bfc3a4863eb9522ca740", "filename": "gcc/ada/gcc-interface/trans.cc", "status": "modified", "additions": 39, "deletions": 44, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e279bd9dc5d9c6bc1863a4f68524383707b67b6/gcc%2Fada%2Fgcc-interface%2Ftrans.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e279bd9dc5d9c6bc1863a4f68524383707b67b6/gcc%2Fada%2Fgcc-interface%2Ftrans.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.cc?ref=4e279bd9dc5d9c6bc1863a4f68524383707b67b6", "patch": "@@ -3848,11 +3848,11 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n      specification has appeared before for this body, then the identifier\n      occurring in that specification will also be a defining identifier and all\n      the calls to this subprogram will point to that specification.  */\n-  Entity_Id gnat_subprog_id\n+  Entity_Id gnat_subprog\n     = (Present (Corresponding_Spec (gnat_node))\n        ? Corresponding_Spec (gnat_node) : Defining_Entity (gnat_node));\n   /* The FUNCTION_DECL node corresponding to the subprogram spec.   */\n-  tree gnu_subprog_decl;\n+  tree gnu_subprog;\n   /* Its RESULT_DECL node.  */\n   tree gnu_result_decl;\n   /* Its FUNCTION_TYPE node.  */\n@@ -3866,11 +3866,8 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   struct language_function *gnu_subprog_language;\n   vec<parm_attr, va_gc> *cache;\n \n-  /* If this is a generic object or if it has been eliminated,\n-     ignore it.  */\n-  if (Ekind (gnat_subprog_id) == E_Generic_Procedure\n-      || Ekind (gnat_subprog_id) == E_Generic_Function\n-      || Is_Eliminated (gnat_subprog_id))\n+  /* If this is a generic subprogram or it has been eliminated, ignore it.  */\n+  if (Is_Generic_Subprogram (gnat_subprog) || Is_Eliminated (gnat_subprog))\n     return;\n \n   /* If this subprogram acts as its own spec, define it.  Otherwise, just get\n@@ -3879,13 +3876,13 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n      treat it as not being defined in that case.  Such a subprogram cannot\n      have an address clause or a freeze node, so this test is safe, though it\n      does disable some otherwise-useful error checking.  */\n-  gnu_subprog_decl\n-    = gnat_to_gnu_entity (gnat_subprog_id, NULL_TREE,\n+  gnu_subprog\n+    = gnat_to_gnu_entity (gnat_subprog, NULL_TREE,\n \t\t\t  Acts_As_Spec (gnat_node)\n-\t\t\t  && !present_gnu_tree (gnat_subprog_id));\n-  DECL_FUNCTION_IS_DEF (gnu_subprog_decl) = true;\n-  gnu_result_decl = DECL_RESULT (gnu_subprog_decl);\n-  gnu_subprog_type = TREE_TYPE (gnu_subprog_decl);\n+\t\t\t  && !present_gnu_tree (gnat_subprog));\n+  DECL_FUNCTION_IS_DEF (gnu_subprog) = true;\n+  gnu_result_decl = DECL_RESULT (gnu_subprog);\n+  gnu_subprog_type = TREE_TYPE (gnu_subprog);\n   gnu_cico_list = TYPE_CI_CO_LIST (gnu_subprog_type);\n   if (gnu_cico_list && TREE_VALUE (gnu_cico_list) == void_type_node)\n     gnu_return_var_elmt = gnu_cico_list;\n@@ -3900,25 +3897,25 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n     }\n \n   /* Set the line number in the decl to correspond to that of the body.  */\n-  if (DECL_IGNORED_P (gnu_subprog_decl))\n+  if (DECL_IGNORED_P (gnu_subprog))\n     locus = UNKNOWN_LOCATION;\n-  else if (!Sloc_to_locus (Sloc (gnat_node), &locus, false, gnu_subprog_decl))\n+  else if (!Sloc_to_locus (Sloc (gnat_node), &locus, false, gnu_subprog))\n     locus = input_location;\n-  DECL_SOURCE_LOCATION (gnu_subprog_decl) = locus;\n+  DECL_SOURCE_LOCATION (gnu_subprog) = locus;\n \n   /* Try to create a bona-fide thunk and hand it over to the middle-end.  */\n-  if (Is_Thunk (gnat_subprog_id)\n-      && maybe_make_gnu_thunk (gnat_subprog_id, gnu_subprog_decl))\n+  if (Is_Thunk (gnat_subprog)\n+      && maybe_make_gnu_thunk (gnat_subprog, gnu_subprog))\n     return;\n \n   /* Initialize the information structure for the function.  */\n-  allocate_struct_function (gnu_subprog_decl, false);\n+  allocate_struct_function (gnu_subprog, false);\n   gnu_subprog_language = ggc_cleared_alloc<language_function> ();\n-  DECL_STRUCT_FUNCTION (gnu_subprog_decl)->language = gnu_subprog_language;\n-  DECL_STRUCT_FUNCTION (gnu_subprog_decl)->function_start_locus = locus;\n+  DECL_STRUCT_FUNCTION (gnu_subprog)->language = gnu_subprog_language;\n+  DECL_STRUCT_FUNCTION (gnu_subprog)->function_start_locus = locus;\n   set_cfun (NULL);\n \n-  begin_subprog_body (gnu_subprog_decl);\n+  begin_subprog_body (gnu_subprog);\n \n   /* If there are copy-in/copy-out parameters, we need to ensure that they are\n      properly copied out by the return statement.  We do this by making a new\n@@ -3946,7 +3943,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \t    = create_var_decl (get_identifier (\"RETVAL\"), NULL_TREE,\n \t\t\t       gnu_return_type, NULL_TREE,\n \t\t\t       false, false, false, false, false,\n-\t\t\t       true, false, NULL, gnat_subprog_id);\n+\t\t\t       true, false, NULL, gnat_subprog);\n \t  TREE_VALUE (gnu_return_var_elmt) = gnu_return_var;\n \t}\n \n@@ -3957,7 +3954,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \t put it into TYPE_CI_CO_LIST, which must contain an empty entry too.\n \t We can match up the entries because TYPE_CI_CO_LIST is in the order\n \t of the parameters.  */\n-      for (gnat_param = First_Formal_With_Extras (gnat_subprog_id);\n+      for (gnat_param = First_Formal_With_Extras (gnat_subprog);\n \t   Present (gnat_param);\n \t   gnat_param = Next_Formal_With_Extras (gnat_param))\n \tif (!present_gnu_tree (gnat_param))\n@@ -3999,7 +3996,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   /* Attempt setting the end_locus of our GCC body tree, typically a BIND_EXPR,\n      then the end_locus of our GCC subprogram declaration tree.  */\n   set_end_locus_from_node (gnu_result, gnat_node);\n-  set_end_locus_from_node (gnu_subprog_decl, gnat_node);\n+  set_end_locus_from_node (gnu_subprog, gnat_node);\n \n   /* If we populated the parameter attributes cache, we need to make sure that\n      the cached expressions are evaluated on all the possible paths leading to\n@@ -4097,7 +4094,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \n   /* On SEH targets, install an exception handler around the main entry\n      point to catch unhandled exceptions.  */\n-  if (DECL_NAME (gnu_subprog_decl) == main_identifier_node\n+  if (DECL_NAME (gnu_subprog) == main_identifier_node\n       && targetm_common.except_unwind_info (&global_options) == UI_SEH)\n     {\n       tree t;\n@@ -4119,7 +4116,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \n   /* Finally annotate the parameters and disconnect the trees for parameters\n      that we have turned into variables since they are now unusable.  */\n-  for (gnat_param = First_Formal_With_Extras (gnat_subprog_id);\n+  for (gnat_param = First_Formal_With_Extras (gnat_subprog);\n        Present (gnat_param);\n        gnat_param = Next_Formal_With_Extras (gnat_param))\n     {\n@@ -4141,7 +4138,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n      a Named Return Value, finalize the optimization.  */\n   if (optimize && !optimize_debug && gnu_subprog_language->named_ret_val)\n     {\n-      finalize_nrv (gnu_subprog_decl,\n+      finalize_nrv (gnu_subprog,\n \t\t    gnu_subprog_language->named_ret_val,\n \t\t    gnu_subprog_language->other_ret_val,\n \t\t    gnu_subprog_language->gnat_ret);\n@@ -4151,10 +4148,10 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \n   /* If this is an inlined external function that has been marked uninlinable,\n      drop the body and stop there.  Otherwise compile the body.  */\n-  if (DECL_EXTERNAL (gnu_subprog_decl) && DECL_UNINLINABLE (gnu_subprog_decl))\n-    DECL_SAVED_TREE (gnu_subprog_decl) = NULL_TREE;\n+  if (DECL_EXTERNAL (gnu_subprog) && DECL_UNINLINABLE (gnu_subprog))\n+    DECL_SAVED_TREE (gnu_subprog) = NULL_TREE;\n   else\n-    rest_of_subprog_body_compilation (gnu_subprog_decl);\n+    rest_of_subprog_body_compilation (gnu_subprog);\n }\n \n /* The type of an atomic access.  */\n@@ -9224,31 +9221,29 @@ process_decls (List_Id gnat_decls, List_Id gnat_decls2,\n \t      record_code_position\n \t\t(Proper_Body (Unit (Library_Unit (gnat_decl))));\n \n-\t    /* We defer most subprogram bodies to the second pass.  */\n+\t    /* We defer most subprogram bodies to the second pass.  For bodies\n+\t       that act as their own specs and stubs, the entity itself must be\n+\t       elaborated in the first pass, because it may be used in other\n+\t       declarations.  */\n \t    else if (Nkind (gnat_decl) == N_Subprogram_Body)\n \t      {\n \t\tif (Acts_As_Spec (gnat_decl))\n \t\t  {\n-\t\t    Node_Id gnat_subprog_id = Defining_Entity (gnat_decl);\n+\t\t    Entity_Id gnat_subprog = Defining_Entity (gnat_decl);\n \n-\t\t    if (Ekind (gnat_subprog_id) != E_Generic_Procedure\n-\t\t\t&& Ekind (gnat_subprog_id) != E_Generic_Function)\n-\t\t      gnat_to_gnu_entity (gnat_subprog_id, NULL_TREE, true);\n+\t\t    if (!Is_Generic_Subprogram (gnat_subprog))\n+\t\t      gnat_to_gnu_entity (gnat_subprog, NULL_TREE, true);\n \t\t  }\n \t      }\n \n-\t    /* For bodies and stubs that act as their own specs, the entity\n-\t       itself must be elaborated in the first pass, because it may\n-\t       be used in other declarations.  */\n \t    else if (Nkind (gnat_decl) == N_Subprogram_Body_Stub)\n \t      {\n-\t\tNode_Id gnat_subprog_id\n+\t\tEntity_Id gnat_subprog\n \t\t  = Defining_Entity (Specification (gnat_decl));\n \n-\t\t    if (Ekind (gnat_subprog_id) != E_Subprogram_Body\n-\t\t\t&& Ekind (gnat_subprog_id) != E_Generic_Procedure\n-\t\t\t&& Ekind (gnat_subprog_id) != E_Generic_Function)\n-\t\t      gnat_to_gnu_entity (gnat_subprog_id, NULL_TREE, true);\n+\t\tif (!Is_Generic_Subprogram (gnat_subprog)\n+\t\t    && Ekind (gnat_subprog) != E_Subprogram_Body)\n+\t\t  gnat_to_gnu_entity (gnat_subprog, NULL_TREE, true);\n \t      }\n \n \t    /* Concurrent stubs stand for the corresponding subprogram bodies,"}]}