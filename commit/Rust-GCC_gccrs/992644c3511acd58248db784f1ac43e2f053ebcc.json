{"sha": "992644c3511acd58248db784f1ac43e2f053ebcc", "node_id": "C_kwDOANBUbNoAKDk5MjY0NGMzNTExYWNkNTgyNDhkYjc4NGYxYWM0M2UyZjA1M2ViY2M", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-10T15:00:40Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-10T15:00:40Z"}, "message": "Extend modref by side-effect analysis\n\nMake modref to also collect info whether function has side\neffects.  This allows pure/const function detection and also handling\nfunctions which do store some memory in similar way as we handle\npure/consts now.\n\nThe code is symmetric to what ipa-pure-const does.  Modref is actually more\ncapable on proving that a given function is pure/const (since it understands\nthat non-pure function can be called when it only modifies data on stack)\nso we could retire ipa-pure-const's pure-const discovery at some point.\n\nHowever this patch only does the anlaysis - the consumers of this flag\nwill come next.\n\nBootstrapped/regtested x86_64-linux. I plan to commit it later today\nif there are no complains.\n\ngcc/ChangeLog:\n\n\t* ipa-modref.c: Include tree-eh.h\n\t(modref_summary::modref_summary): Initialize side_effects.\n\t(struct modref_summary_lto): New bool field side_effects.\n\t(modref_summary_lto::modref_summary_lto): Initialize side_effects.\n\t(modref_summary::dump): Dump side_effects.\n\t(modref_summary_lto::dump): Dump side_effects.\n\t(merge_call_side_effects): Merge side effects.\n\t(process_fnspec): Calls to non-const/pure or looping\n\tfunction is a side effect.\n\t(analyze_call): Self-recursion is a side-effect; handle\n\tspecial builtins.\n\t(analyze_load): Watch for volatile and throwing memory.\n\t(analyze_store): Likewise.\n\t(analyze_stmt): Watch for volatitle asm.\n\t(analyze_function): Handle side_effects.\n\t(modref_summaries::duplicate): Duplicate side_effects.\n\t(modref_summaries_lto::duplicate): Likewise.\n\t(modref_write): Stream side_effects.\n\t(read_section): Likewise.\n\t(update_signature): Update.\n\t(propagate_unknown_call): Handle side_effects.\n\t(modref_propagate_in_scc): Likewise.\n\t* ipa-modref.h (struct modref_summary): Add side_effects.\n\t* ipa-pure-const.c (special_builtin_state): Rename to ...\n\t(builtin_safe_for_const_function_p): ... this one.\n\t(check_call): Update.\n\t(finite_function_p): Break out from ...\n\t(propagate_pure_const): ... here\n\t* ipa-utils.h (finite_function): Declare.", "tree": {"sha": "f5fee4afb22e7567234c3a08c1020605e94fb613", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5fee4afb22e7567234c3a08c1020605e94fb613"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/992644c3511acd58248db784f1ac43e2f053ebcc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/992644c3511acd58248db784f1ac43e2f053ebcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/992644c3511acd58248db784f1ac43e2f053ebcc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/992644c3511acd58248db784f1ac43e2f053ebcc/comments", "author": null, "committer": null, "parents": [{"sha": "a5c9b9bc2b60845624b105a98297bdf854c289da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5c9b9bc2b60845624b105a98297bdf854c289da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5c9b9bc2b60845624b105a98297bdf854c289da"}], "stats": {"total": 276, "additions": 219, "deletions": 57}, "files": [{"sha": "f8b7b900527ddf22e1691440ee963acf4280e3a2", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 157, "deletions": 6, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/992644c3511acd58248db784f1ac43e2f053ebcc/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/992644c3511acd58248db784f1ac43e2f053ebcc/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=992644c3511acd58248db784f1ac43e2f053ebcc", "patch": "@@ -87,6 +87,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssanames.h\"\n #include \"attribs.h\"\n #include \"tree-cfg.h\"\n+#include \"tree-eh.h\"\n \n \n namespace {\n@@ -275,7 +276,7 @@ static GTY(()) fast_function_summary <modref_summary_lto *, va_gc>\n \n modref_summary::modref_summary ()\n   : loads (NULL), stores (NULL), retslot_flags (0), static_chain_flags (0),\n-    writes_errno (false)\n+    writes_errno (false), side_effects (false)\n {\n }\n \n@@ -373,6 +374,7 @@ struct GTY(()) modref_summary_lto\n   eaf_flags_t retslot_flags;\n   eaf_flags_t static_chain_flags;\n   bool writes_errno;\n+  bool side_effects;\n \n   modref_summary_lto ();\n   ~modref_summary_lto ();\n@@ -384,7 +386,7 @@ struct GTY(()) modref_summary_lto\n \n modref_summary_lto::modref_summary_lto ()\n   : loads (NULL), stores (NULL), retslot_flags (0), static_chain_flags (0),\n-    writes_errno (false)\n+    writes_errno (false), side_effects (false)\n {\n }\n \n@@ -617,6 +619,8 @@ modref_summary::dump (FILE *out)\n     }\n   if (writes_errno)\n     fprintf (out, \"  Writes errno\\n\");\n+  if (side_effects)\n+    fprintf (out, \"  Side effects\\n\");\n   if (arg_flags.length ())\n     {\n       for (unsigned int i = 0; i < arg_flags.length (); i++)\n@@ -649,6 +653,8 @@ modref_summary_lto::dump (FILE *out)\n   dump_lto_records (stores, out);\n   if (writes_errno)\n     fprintf (out, \"  Writes errno\\n\");\n+  if (side_effects)\n+    fprintf (out, \"  Side effects\\n\");\n   if (arg_flags.length ())\n     {\n       for (unsigned int i = 0; i < arg_flags.length (); i++)\n@@ -982,6 +988,12 @@ merge_call_side_effects (modref_summary *cur_summary,\n \t  changed = true;\n \t}\n     }\n+  if (!cur_summary->side_effects\n+      && callee_summary->side_effects)\n+    {\n+      cur_summary->side_effects = true;\n+      changed = true;\n+    }\n   return changed;\n }\n \n@@ -1077,6 +1089,18 @@ process_fnspec (modref_summary *cur_summary,\n \t\tgcall *call, bool ignore_stores)\n {\n   attr_fnspec fnspec = gimple_call_fnspec (call);\n+  int flags = gimple_call_flags (call);\n+\n+  if (!(flags & (ECF_CONST | ECF_NOVOPS))\n+      || (flags & ECF_LOOPING_CONST_OR_PURE)\n+      || (cfun->can_throw_non_call_exceptions\n+\t  && stmt_could_throw_p (cfun, call)))\n+    {\n+      if (cur_summary)\n+\tcur_summary->side_effects = true;\n+      if (cur_summary_lto)\n+\tcur_summary_lto->side_effects = true;\n+    }\n   if (!fnspec.known_p ())\n     {\n       if (dump_file && gimple_call_builtin_p (call, BUILT_IN_NORMAL))\n@@ -1214,6 +1238,10 @@ analyze_call (modref_summary *cur_summary, modref_summary_lto *cur_summary_lto,\n   if (recursive_call_p (current_function_decl, callee))\n     {\n       recursive_calls->safe_push (stmt);\n+      if (cur_summary)\n+\tcur_summary->side_effects = true;\n+      if (cur_summary_lto)\n+\tcur_summary_lto->side_effects = true;\n       if (dump_file)\n \tfprintf (dump_file, \" - Skipping recursive call.\\n\");\n       return true;\n@@ -1224,6 +1252,20 @@ analyze_call (modref_summary *cur_summary, modref_summary_lto *cur_summary_lto,\n   /* Get the function symbol and its availability.  */\n   enum availability avail;\n   callee_node = callee_node->function_symbol (&avail);\n+  bool looping;\n+  if (builtin_safe_for_const_function_p (&looping, callee))\n+    {\n+      if (looping)\n+\t{\n+\t  if (cur_summary)\n+\t    cur_summary->side_effects = true;\n+\t  if (cur_summary_lto)\n+\t    cur_summary_lto->side_effects = true;\n+\t}\n+      if (dump_file)\n+\tfprintf (dump_file, \" - Bulitin is safe for const.\\n\");\n+      return true;\n+    }\n   if (avail <= AVAIL_INTERPOSABLE)\n     {\n       if (dump_file)\n@@ -1270,6 +1312,18 @@ analyze_load (gimple *, tree, tree op, void *data)\n       fprintf (dump_file, \"\\n\");\n     }\n \n+  if (TREE_THIS_VOLATILE (op)\n+      || (cfun->can_throw_non_call_exceptions\n+\t  && tree_could_throw_p (op)))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \" (volatile or can throw; marking side effects) \");\n+      if (summary)\n+\tsummary->side_effects = true;\n+      if (summary_lto)\n+\tsummary_lto->side_effects = true;\n+    }\n+\n   if (!record_access_p (op))\n     return false;\n \n@@ -1298,6 +1352,18 @@ analyze_store (gimple *, tree, tree op, void *data)\n       fprintf (dump_file, \"\\n\");\n     }\n \n+  if (TREE_THIS_VOLATILE (op)\n+      || (cfun->can_throw_non_call_exceptions\n+\t  && tree_could_throw_p (op)))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \" (volatile or can throw; marking side effects) \");\n+      if (summary)\n+\tsummary->side_effects = true;\n+      if (summary_lto)\n+\tsummary_lto->side_effects = true;\n+    }\n+\n   if (!record_access_p (op))\n     return false;\n \n@@ -1334,6 +1400,15 @@ analyze_stmt (modref_summary *summary, modref_summary_lto *summary_lto,\n   switch (gimple_code (stmt))\n    {\n    case GIMPLE_ASM:\n+      if (gimple_asm_volatile_p (as_a <gasm *> (stmt))\n+\t  || (cfun->can_throw_non_call_exceptions\n+\t      && stmt_could_throw_p (cfun, stmt)))\n+\t{\n+\t  if (summary)\n+\t    summary->side_effects = true;\n+\t  if (summary_lto)\n+\t    summary_lto->side_effects = true;\n+\t}\n      /* If the ASM statement does not read nor write memory, there's nothing\n \tto do.  Otherwise just give up.  */\n      if (!gimple_asm_clobbers_memory_p (as_a <gasm *> (stmt)))\n@@ -1365,7 +1440,14 @@ analyze_stmt (modref_summary *summary, modref_summary_lto *summary_lto,\n       }\n      return true;\n    default:\n-     /* Nothing to do for other types of statements.  */\n+     if (cfun->can_throw_non_call_exceptions\n+\t && stmt_could_throw_p (cfun, stmt))\n+\t{\n+\t  if (summary)\n+\t    summary->side_effects = true;\n+\t  if (summary_lto)\n+\t    summary_lto->side_effects = true;\n+\t}\n      return true;\n    }\n }\n@@ -2616,6 +2698,7 @@ analyze_function (function *f, bool ipa)\n \t\t\t\t\t\t    param_modref_max_refs,\n \t\t\t\t\t\t    param_modref_max_accesses);\n       summary->writes_errno = false;\n+      summary->side_effects = false;\n     }\n   if (lto)\n     {\n@@ -2630,6 +2713,7 @@ analyze_function (function *f, bool ipa)\n \t\t\t\t  param_modref_max_refs,\n \t\t\t\t  param_modref_max_accesses);\n       summary_lto->writes_errno = false;\n+      summary_lto->side_effects = false;\n     }\n \n   analyze_parms (summary, summary_lto, ipa,\n@@ -2700,6 +2784,12 @@ analyze_function (function *f, bool ipa)\n       summaries_lto->remove (fnode);\n       summary_lto = NULL;\n     }\n+  if (summary && !summary->global_memory_written_p () && !summary->side_effects\n+      && !finite_function_p ())\n+    summary->side_effects = true;\n+  if (summary_lto && !summary_lto->side_effects && !finite_function_p ())\n+    summary_lto->side_effects = true;\n+\n   if (ipa && !summary && !summary_lto)\n     remove_modref_edge_summaries (fnode);\n \n@@ -2904,6 +2994,7 @@ modref_summaries::duplicate (cgraph_node *, cgraph_node *dst,\n \t\t\t src_data->loads->max_accesses);\n   dst_data->loads->copy_from (src_data->loads);\n   dst_data->writes_errno = src_data->writes_errno;\n+  dst_data->side_effects = src_data->side_effects;\n   if (src_data->arg_flags.length ())\n     dst_data->arg_flags = src_data->arg_flags.copy ();\n   dst_data->retslot_flags = src_data->retslot_flags;\n@@ -2931,6 +3022,7 @@ modref_summaries_lto::duplicate (cgraph_node *, cgraph_node *,\n \t\t\t src_data->loads->max_accesses);\n   dst_data->loads->copy_from (src_data->loads);\n   dst_data->writes_errno = src_data->writes_errno;\n+  dst_data->side_effects = src_data->side_effects;\n   if (src_data->arg_flags.length ())\n     dst_data->arg_flags = src_data->arg_flags.copy ();\n   dst_data->retslot_flags = src_data->retslot_flags;\n@@ -3259,6 +3351,7 @@ modref_write ()\n \n \t  struct bitpack_d bp = bitpack_create (ob->main_stream);\n \t  bp_pack_value (&bp, r->writes_errno, 1);\n+\t  bp_pack_value (&bp, r->side_effects, 1);\n \t  if (!flag_wpa)\n \t    {\n \t      for (cgraph_edge *e = cnode->indirect_calls;\n@@ -3328,9 +3421,15 @@ read_section (struct lto_file_decl_data *file_data, const char *data,\n \tmodref_sum = optimization_summaries->get_create (node);\n \n       if (modref_sum)\n-\tmodref_sum->writes_errno = false;\n+\t{\n+\t  modref_sum->writes_errno = false;\n+\t  modref_sum->side_effects = false;\n+\t}\n       if (modref_sum_lto)\n-\tmodref_sum_lto->writes_errno = false;\n+\t{\n+\t  modref_sum_lto->writes_errno = false;\n+\t  modref_sum_lto->side_effects = false;\n+\t}\n \n       gcc_assert (!modref_sum || (!modref_sum->loads\n \t\t\t\t  && !modref_sum->stores));\n@@ -3375,6 +3474,13 @@ read_section (struct lto_file_decl_data *file_data, const char *data,\n \t  if (modref_sum_lto)\n \t    modref_sum_lto->writes_errno = true;\n \t}\n+      if (bp_unpack_value (&bp, 1))\n+\t{\n+\t  if (modref_sum)\n+\t    modref_sum->side_effects = true;\n+\t  if (modref_sum_lto)\n+\t    modref_sum_lto->side_effects = true;\n+\t}\n       if (!flag_ltrans)\n \t{\n \t  for (cgraph_edge *e = node->indirect_calls; e; e = e->next_callee)\n@@ -3523,7 +3629,7 @@ update_signature (struct cgraph_node *node)\n \n   map.reserve (max + 1);\n   for (i = 0; i <= max; i++)\n-    map.quick_push (-1);\n+    map.quick_push (MODREF_UNKNOWN_PARM);\n   FOR_EACH_VEC_SAFE_ELT (info->param_adjustments->m_adj_params, i, p)\n     {\n       int idx = info->param_adjustments->get_original_index (i);\n@@ -3862,6 +3968,39 @@ propagate_unknown_call (cgraph_node *node,\n   bool changed = false;\n   class fnspec_summary *fnspec_sum = fnspec_summaries->get (e);\n   auto_vec <modref_parm_map, 32> parm_map;\n+  bool looping;\n+\n+  if (e->callee\n+      && builtin_safe_for_const_function_p (&looping, e->callee->decl))\n+    {\n+      if (cur_summary && !cur_summary->side_effects)\n+\t{\n+\t  cur_summary->side_effects = true;\n+\t  changed = true;\n+\t}\n+      if (cur_summary_lto && !cur_summary_lto->side_effects)\n+\t{\n+\t  cur_summary_lto->side_effects = true;\n+\t  changed = true;\n+\t}\n+      return changed;\n+    }\n+\n+  if (!(ecf_flags & (ECF_CONST | ECF_NOVOPS))\n+      || (ecf_flags & ECF_LOOPING_CONST_OR_PURE))\n+    {\n+      if (cur_summary && !cur_summary->side_effects)\n+\t{\n+\t  cur_summary->side_effects = true;\n+\t  changed = true;\n+\t}\n+      if (cur_summary_lto && !cur_summary_lto->side_effects)\n+\t{\n+\t  cur_summary_lto->side_effects = true;\n+\t  changed = true;\n+\t}\n+    }\n+\n   if (fnspec_sum\n       && compute_parm_map (e, &parm_map))\n     {\n@@ -4126,6 +4265,12 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t\t  changed |= cur_summary->loads->merge\n \t\t\t\t  (callee_summary->loads, &parm_map,\n \t\t\t\t   &chain_map, !first);\n+\t\t  if (!cur_summary->side_effects\n+\t\t      && callee_summary->side_effects)\n+\t\t    {\n+\t\t      cur_summary->side_effects = true;\n+\t\t      changed = true;\n+\t\t    }\n \t\t  if (!ignore_stores)\n \t\t    {\n \t\t      changed |= cur_summary->stores->merge\n@@ -4144,6 +4289,12 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t\t  changed |= cur_summary_lto->loads->merge\n \t\t\t\t  (callee_summary_lto->loads, &parm_map,\n \t\t\t\t   &chain_map, !first);\n+\t\t  if (!cur_summary_lto->side_effects\n+\t\t      && callee_summary_lto->side_effects)\n+\t\t    {\n+\t\t      cur_summary_lto->side_effects = true;\n+\t\t      changed = true;\n+\t\t    }\n \t\t  if (!ignore_stores)\n \t\t    {\n \t\t      changed |= cur_summary_lto->stores->merge"}, {"sha": "49c99f263a79987a59a1eaffba6151c1e5c3a7cc", "filename": "gcc/ipa-modref.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/992644c3511acd58248db784f1ac43e2f053ebcc/gcc%2Fipa-modref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/992644c3511acd58248db784f1ac43e2f053ebcc/gcc%2Fipa-modref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.h?ref=992644c3511acd58248db784f1ac43e2f053ebcc", "patch": "@@ -34,6 +34,7 @@ struct GTY(()) modref_summary\n   eaf_flags_t retslot_flags;\n   eaf_flags_t static_chain_flags;\n   bool writes_errno;\n+  bool side_effects;\n \n   modref_summary ();\n   ~modref_summary ();"}, {"sha": "505ed4f8a3bc83b7a83f1e1dc702de07a3556004", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 57, "deletions": 51, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/992644c3511acd58248db784f1ac43e2f053ebcc/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/992644c3511acd58248db784f1ac43e2f053ebcc/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=992644c3511acd58248db784f1ac43e2f053ebcc", "patch": "@@ -506,11 +506,10 @@ worse_state (enum pure_const_state_e *state, bool *looping,\n   *looping = MAX (*looping, looping2);\n }\n \n-/* Recognize special cases of builtins that are by themselves not pure or const\n+/* Recognize special cases of builtins that are by themselves not const\n    but function using them is.  */\n-static bool\n-special_builtin_state (enum pure_const_state_e *state, bool *looping,\n-\t\t       tree callee)\n+bool\n+builtin_safe_for_const_function_p (bool *looping, tree callee)\n {\n   if (DECL_BUILT_IN_CLASS (callee) == BUILT_IN_NORMAL)\n     switch (DECL_FUNCTION_CODE (callee))\n@@ -532,11 +531,9 @@ special_builtin_state (enum pure_const_state_e *state, bool *looping,\n       case BUILT_IN_DWARF_CFA:\n       case BUILT_IN_RETURN_ADDRESS:\n \t*looping = false;\n-\t*state = IPA_CONST;\n \treturn true;\n       case BUILT_IN_PREFETCH:\n \t*looping = true;\n-\t*state = IPA_CONST;\n \treturn true;\n       default:\n \tbreak;\n@@ -594,17 +591,16 @@ check_call (funct_state local, gcall *call, bool ipa)\n      graph.  */\n   if (callee_t)\n     {\n-      enum pure_const_state_e call_state;\n       bool call_looping;\n \n       if (gimple_call_builtin_p (call, BUILT_IN_NORMAL)\n \t  && !nonfreeing_call_p (call))\n \tlocal->can_free = true;\n \n-      if (special_builtin_state (&call_state, &call_looping, callee_t))\n+      if (builtin_safe_for_const_function_p (&call_looping, callee_t))\n \t{\n \t  worse_state (&local->pure_const_state, &local->looping,\n-\t\t       call_state, call_looping,\n+\t\t       IPA_CONST, call_looping,\n \t\t       NULL, NULL);\n \t  return;\n \t}\n@@ -1007,6 +1003,51 @@ malloc_candidate_p (function *fun, bool ipa)\n \n #undef DUMP_AND_RETURN\n \n+/* Return true if function is known to be finite.  */\n+\n+bool\n+finite_function_p ()\n+{\n+  /* Const functions cannot have back edges (an\n+     indication of possible infinite loop side\n+     effect.  */\n+  bool finite = true;\n+  if (mark_dfs_back_edges ())\n+    {\n+      /* Preheaders are needed for SCEV to work.\n+\t Simple latches and recorded exits improve chances that loop will\n+\t proved to be finite in testcases such as in loop-15.c\n+\t and loop-24.c  */\n+      loop_optimizer_init (LOOPS_HAVE_PREHEADERS\n+\t\t\t   | LOOPS_HAVE_SIMPLE_LATCHES\n+\t\t\t   | LOOPS_HAVE_RECORDED_EXITS);\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tflow_loops_dump (dump_file, NULL, 0);\n+      if (mark_irreducible_loops ())\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"    has irreducible loops\\n\");\n+\t  finite = false;\n+\t}\n+      else\n+\t{\n+\t  scev_initialize ();\n+\t  for (auto loop : loops_list (cfun, 0))\n+\t    if (!finite_loop_p (loop))\n+\t      {\n+\t\tif (dump_file)\n+\t\t  fprintf (dump_file, \"    cannot prove finiteness of \"\n+\t\t\t   \"loop %i\\n\", loop->num);\n+\t\tfinite =false;\n+\t\tbreak;\n+\t      }\n+\t  scev_finalize ();\n+\t}\n+      loop_optimizer_finalize ();\n+    }\n+  return finite;\n+}\n+\n /* This is the main routine for finding the reference patterns for\n    global variables within a function FN.  */\n \n@@ -1065,45 +1106,10 @@ analyze_function (struct cgraph_node *fn, bool ipa)\n     }\n \n end:\n-  if (l->pure_const_state != IPA_NEITHER)\n-    {\n-      /* Const functions cannot have back edges (an\n-\t indication of possible infinite loop side\n-\t effect.  */\n-      if (mark_dfs_back_edges ())\n-        {\n-\t  /* Preheaders are needed for SCEV to work.\n-\t     Simple latches and recorded exits improve chances that loop will\n-\t     proved to be finite in testcases such as in loop-15.c\n-\t     and loop-24.c  */\n-\t  loop_optimizer_init (LOOPS_HAVE_PREHEADERS\n-\t\t\t       | LOOPS_HAVE_SIMPLE_LATCHES\n-\t\t\t       | LOOPS_HAVE_RECORDED_EXITS);\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    flow_loops_dump (dump_file, NULL, 0);\n-\t  if (mark_irreducible_loops ())\n-\t    {\n-\t      if (dump_file)\n-\t        fprintf (dump_file, \"    has irreducible loops\\n\");\n-\t      l->looping = true;\n-\t    }\n-\t  else\n-\t    {\n-\t      scev_initialize ();\n-\t      for (auto loop : loops_list (cfun, 0))\n-\t\tif (!finite_loop_p (loop))\n-\t\t  {\n-\t\t    if (dump_file)\n-\t\t      fprintf (dump_file, \"    cannot prove finiteness of \"\n-\t\t\t       \"loop %i\\n\", loop->num);\n-\t\t    l->looping =true;\n-\t\t    break;\n-\t\t  }\n-\t      scev_finalize ();\n-\t    }\n-          loop_optimizer_finalize ();\n-\t}\n-    }\n+  if (l->pure_const_state != IPA_NEITHER\n+      && !l->looping\n+      && !finite_function_p ())\n+    l->looping = true;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"    checking previously known:\");\n@@ -1539,9 +1545,9 @@ propagate_pure_const (void)\n \t\t      edge_looping = y_l->looping;\n \t\t    }\n \t\t}\n-\t      else if (special_builtin_state (&edge_state, &edge_looping,\n-\t\t\t\t\t      y->decl))\n-\t\t;\n+\t      else if (builtin_safe_for_const_function_p (&edge_looping,\n+\t\t\t\t\t\t\t   y->decl))\n+\t\tedge_state = IPA_CONST;\n \t      else\n \t\tstate_from_flags (&edge_state, &edge_looping,\n \t\t\t\t  flags_from_decl_or_type (y->decl),"}, {"sha": "824780f562a244eace07315cdf5b528fa1a1c41c", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/992644c3511acd58248db784f1ac43e2f053ebcc/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/992644c3511acd58248db784f1ac43e2f053ebcc/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=992644c3511acd58248db784f1ac43e2f053ebcc", "patch": "@@ -47,6 +47,10 @@ void ipa_merge_profiles (struct cgraph_node *dst,\n \t\t\t struct cgraph_node *src, bool preserve_body = false);\n bool recursive_call_p (tree, tree);\n \n+/* In ipa-pure-const.c  */\n+bool finite_function_p ();\n+bool builtin_safe_for_const_function_p (bool *, tree);\n+\n /* In ipa-profile.c  */\n bool ipa_propagate_frequency (struct cgraph_node *node);\n "}]}