{"sha": "03bd2f1af7c1f2343940f6ca5409048ba16a2e4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNiZDJmMWFmN2MxZjIzNDM5NDBmNmNhNTQwOTA0OGJhMTZhMmU0Yw==", "commit": {"author": {"name": "Andreas Krebbel", "email": "Andreas.Krebbel@de.ibm.com", "date": "2009-06-14T14:45:32Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2009-06-14T14:45:32Z"}, "message": "passes.c: Add bswap pass.\n\n2009-06-14  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n\n\t* passes.c: Add bswap pass.\n\t* tree-pass.h: Add pass_optimize_bswap declaration.\n\t* tree-ssa-math-opts.c: Include diagnostics.h for print_gimple_stmt.\n\tInclude rtl.h, expr.h and optabs.h for optab_handler check.\n\t(struct symbolic_number, pass_optimize_bswap): New definition.\n\t(do_shift_rotate, verify_symbolic_number_p): New functions.\n\t(find_bswap_1, find_bswap, execute_optimize_bswap): New functions.\n\t(gate_optimize_bswap): New function.\n\t* tree.c (widest_int_cst_value): New function.\n\t* tree.h (widest_int_cst_value): Prototype added.\n\n2009-06-14  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n\n\t* gcc.dg/optimize-bswap-1.c: New testcase.\n\nFrom-SVN: r148471", "tree": {"sha": "b8f6f449a98ff4e7527b14909b70123620025068", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8f6f449a98ff4e7527b14909b70123620025068"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03bd2f1af7c1f2343940f6ca5409048ba16a2e4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03bd2f1af7c1f2343940f6ca5409048ba16a2e4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03bd2f1af7c1f2343940f6ca5409048ba16a2e4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03bd2f1af7c1f2343940f6ca5409048ba16a2e4c/comments", "author": null, "committer": null, "parents": [{"sha": "a810f82f7bd1fb1c3f4fa1f332e736cb1ada36c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a810f82f7bd1fb1c3f4fa1f332e736cb1ada36c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a810f82f7bd1fb1c3f4fa1f332e736cb1ada36c4"}], "stats": {"total": 486, "additions": 485, "deletions": 1}, "files": [{"sha": "7a924476d114b9aaa42a8dc2a477ba53cc4d3c2a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03bd2f1af7c1f2343940f6ca5409048ba16a2e4c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03bd2f1af7c1f2343940f6ca5409048ba16a2e4c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=03bd2f1af7c1f2343940f6ca5409048ba16a2e4c", "patch": "@@ -1,3 +1,16 @@\n+2009-06-14  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n+\n+\t* passes.c: Add bswap pass.\n+\t* tree-pass.h: Add pass_optimize_bswap declaration.\n+\t* tree-ssa-math-opts.c: Include diagnostics.h for print_gimple_stmt.\n+\tInclude rtl.h, expr.h and optabs.h for optab_handler check.\n+\t(struct symbolic_number, pass_optimize_bswap): New definition.\n+\t(do_shift_rotate, verify_symbolic_number_p): New functions.\n+\t(find_bswap_1, find_bswap, execute_optimize_bswap): New functions.\n+\t(gate_optimize_bswap): New function.\n+\t* tree.c (widest_int_cst_value): New function.\n+\t* tree.h (widest_int_cst_value): Prototype added.\n+\n 2009-06-14  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* cfgcleanup.c (old_insns_match_p): Remove code to substitute"}, {"sha": "6870973229dd9ec23f56e312bccd36f444c0b294", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03bd2f1af7c1f2343940f6ca5409048ba16a2e4c/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03bd2f1af7c1f2343940f6ca5409048ba16a2e4c/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=03bd2f1af7c1f2343940f6ca5409048ba16a2e4c", "patch": "@@ -638,6 +638,7 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_copy_prop);\n       NEXT_PASS (pass_fold_builtins);\n       NEXT_PASS (pass_cse_sincos);\n+      NEXT_PASS (pass_optimize_bswap);\n       NEXT_PASS (pass_split_crit_edges);\n       NEXT_PASS (pass_pre);\n       NEXT_PASS (pass_sink_code);"}, {"sha": "25ae32056578ef10d36a20cf9e5ff81bae6d8f80", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03bd2f1af7c1f2343940f6ca5409048ba16a2e4c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03bd2f1af7c1f2343940f6ca5409048ba16a2e4c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=03bd2f1af7c1f2343940f6ca5409048ba16a2e4c", "patch": "@@ -1,3 +1,7 @@\n+2009-06-14  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n+\n+\t* gcc.dg/optimize-bswap-1.c: New testcase.\n+\n 2009-06-14  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/40389"}, {"sha": "a603f6d9193f75d0b103a59601fa365e826da57f", "filename": "gcc/testsuite/gcc.dg/optimize-bswap-1.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03bd2f1af7c1f2343940f6ca5409048ba16a2e4c/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswap-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03bd2f1af7c1f2343940f6ca5409048ba16a2e4c/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswap-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswap-1.c?ref=03bd2f1af7c1f2343940f6ca5409048ba16a2e4c", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target stdint_types } */\n+/* { dg-options \"-O2 -fdump-tree-bswap\" } */\n+\n+#include <stdint.h>\n+\n+#define __const_swab32(x) ((uint32_t)(\t\t\t\t      \\\n+        (((uint32_t)(x) & (uint32_t)0x000000ffUL) << 24) |            \\\n+        (((uint32_t)(x) & (uint32_t)0x0000ff00UL) <<  8) |            \\\n+        (((uint32_t)(x) & (uint32_t)0x00ff0000UL) >>  8) |            \\\n+        (((uint32_t)(x) & (uint32_t)0xff000000UL) >> 24)))\n+\n+#define __const_swab64(x) ((uint64_t)(\t\t\t                        \\\n+\t(((uint64_t)(x) & (uint64_t)0x00000000000000ffULL) << 56) |             \\\n+\t(((uint64_t)(x) & (uint64_t)0x000000000000ff00ULL) << 40) |\t\t\\\n+\t(((uint64_t)(x) & (uint64_t)0x0000000000ff0000ULL) << 24) |\t\t\\\n+\t(((uint64_t)(x) & (uint64_t)0x00000000ff000000ULL) <<  8) |\t\t\\\n+\t(((uint64_t)(x) & (uint64_t)0x000000ff00000000ULL) >>  8) |\t\t\\\n+\t(((uint64_t)(x) & (uint64_t)0x0000ff0000000000ULL) >> 24) |\t\t\\\n+\t(((uint64_t)(x) & (uint64_t)0x00ff000000000000ULL) >> 40) |\t\t\\\n+\t(((uint64_t)(x) & (uint64_t)0xff00000000000000ULL) >> 56)))\n+\n+/* This byte swap implementation is used by the Linux kernel and the\n+   GNU C library.  */\n+\n+uint32_t\n+swap32_a (uint32_t in)\n+{\n+  return __const_swab32 (in);\n+}\n+\n+uint64_t\n+swap64 (uint64_t in)\n+{\n+  return __const_swab64 (in);\n+}\n+\n+/* The OpenSSH byte swap implementation.  */\n+uint32_t\n+swap32_b (uint32_t in)\n+{\n+  uint32_t a;\n+\n+  a = (in << 16) | (in >> 16);\n+  a = ((a & 0x00ff00ff) << 8) | ((a & 0xff00ff00) >> 8);\n+\n+  return a;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"32 bit bswap implementation found at\" 2 \"bswap\" } } */\n+/* { dg-final { scan-tree-dump-times \"64 bit bswap implementation found at\" 1 \"bswap\" } } */\n+/* { dg-final { cleanup-tree-dump \"bswap\" } } */"}, {"sha": "1268e35609ffe91d47246b4a617a49a186dbba06", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03bd2f1af7c1f2343940f6ca5409048ba16a2e4c/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03bd2f1af7c1f2343940f6ca5409048ba16a2e4c/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=03bd2f1af7c1f2343940f6ca5409048ba16a2e4c", "patch": "@@ -377,6 +377,7 @@ extern struct gimple_opt_pass pass_late_warn_uninitialized;\n extern struct gimple_opt_pass pass_cse_reciprocals;\n extern struct gimple_opt_pass pass_cse_sincos;\n extern struct gimple_opt_pass pass_convert_to_rsqrt;\n+extern struct gimple_opt_pass pass_optimize_bswap;\n extern struct gimple_opt_pass pass_warn_function_return;\n extern struct gimple_opt_pass pass_warn_function_noreturn;\n extern struct gimple_opt_pass pass_cselim;"}, {"sha": "d864e201c776d7d28637433616f9f0e3a80fdc2a", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 384, "deletions": 1, "changes": 385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03bd2f1af7c1f2343940f6ca5409048ba16a2e4c/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03bd2f1af7c1f2343940f6ca5409048ba16a2e4c/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=03bd2f1af7c1f2343940f6ca5409048ba16a2e4c", "patch": "@@ -97,7 +97,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"alloc-pool.h\"\n #include \"basic-block.h\"\n #include \"target.h\"\n-\n+#include \"diagnostic.h\"\n+#include \"rtl.h\"\n+#include \"expr.h\"\n+#include \"optabs.h\"\n \n /* This structure represents one basic block that either computes a\n    division, or is a common dominator for basic block that compute a\n@@ -879,3 +882,383 @@ struct gimple_opt_pass pass_convert_to_rsqrt =\n     | TODO_verify_stmts                 /* todo_flags_finish */\n  }\n };\n+\n+/* A symbolic number is used to detect byte permutation and selection\n+   patterns.  Therefore the field N contains an artificial number\n+   consisting of byte size markers:\n+\n+   0    - byte has the value 0\n+   1..size - byte contains the content of the byte\n+   number indexed with that value minus one  */\n+\n+struct symbolic_number {\n+  unsigned HOST_WIDEST_INT n;\n+  int size;\n+};\n+\n+/* Perform a SHIFT or ROTATE operation by COUNT bits on symbolic\n+   number N.  Return false if the requested operation is not permitted\n+   on a symbolic number.  */\n+\n+static inline bool\n+do_shift_rotate (enum tree_code code,\n+\t\t struct symbolic_number *n,\n+\t\t int count)\n+{\n+  if (count % 8 != 0)\n+    return false;\n+\n+  /* Zero out the extra bits of N in order to avoid them being shifted\n+     into the significant bits.  */\n+  if (n->size < (int)sizeof (HOST_WIDEST_INT))\n+    n->n &= ((unsigned HOST_WIDEST_INT)1 << (n->size * BITS_PER_UNIT)) - 1;\n+\n+  switch (code)\n+    {\n+    case LSHIFT_EXPR:\n+      n->n <<= count;\n+      break;\n+    case RSHIFT_EXPR:\n+      n->n >>= count;\n+      break;\n+    case LROTATE_EXPR:\n+      n->n = (n->n << count) | (n->n >> ((n->size * BITS_PER_UNIT) - count));\n+      break;\n+    case RROTATE_EXPR:\n+      n->n = (n->n >> count) | (n->n << ((n->size * BITS_PER_UNIT) - count));\n+      break;\n+    default:\n+      return false;\n+    }\n+  return true;\n+}\n+\n+/* Perform sanity checking for the symbolic number N and the gimple\n+   statement STMT.  */\n+\n+static inline bool\n+verify_symbolic_number_p (struct symbolic_number *n, gimple stmt)\n+{\n+  tree lhs_type;\n+\n+  lhs_type = gimple_expr_type (stmt);\n+\n+  if (TREE_CODE (lhs_type) != INTEGER_TYPE)\n+    return false;\n+\n+  if (TYPE_PRECISION (lhs_type) != n->size * BITS_PER_UNIT)\n+    return false;\n+\n+  return true;\n+}\n+\n+/* find_bswap_1 invokes itself recursively with N and tries to perform\n+   the operation given by the rhs of STMT on the result.  If the\n+   operation could successfully be executed the function returns the\n+   tree expression of the source operand and NULL otherwise.  */\n+\n+static tree\n+find_bswap_1 (gimple stmt, struct symbolic_number *n, int limit)\n+{\n+  enum tree_code code;\n+  tree rhs1, rhs2 = NULL;\n+  gimple rhs1_stmt, rhs2_stmt;\n+  tree source_expr1;\n+  enum gimple_rhs_class rhs_class;\n+\n+  if (!limit || !is_gimple_assign (stmt))\n+    return NULL_TREE;\n+\n+  rhs1 = gimple_assign_rhs1 (stmt);\n+\n+  if (TREE_CODE (rhs1) != SSA_NAME)\n+    return NULL_TREE;\n+\n+  code = gimple_assign_rhs_code (stmt);\n+  rhs_class = gimple_assign_rhs_class (stmt);\n+  rhs1_stmt = SSA_NAME_DEF_STMT (rhs1);\n+\n+  if (rhs_class == GIMPLE_BINARY_RHS)\n+    rhs2 = gimple_assign_rhs2 (stmt);\n+\n+  /* Handle unary rhs and binary rhs with integer constants as second\n+     operand.  */\n+\n+  if (rhs_class == GIMPLE_UNARY_RHS\n+      || (rhs_class == GIMPLE_BINARY_RHS\n+\t  && TREE_CODE (rhs2) == INTEGER_CST))\n+    {\n+      if (code != BIT_AND_EXPR\n+\t  && code != LSHIFT_EXPR\n+\t  && code != RSHIFT_EXPR\n+\t  && code != LROTATE_EXPR\n+\t  && code != RROTATE_EXPR\n+\t  && code != NOP_EXPR\n+\t  && code != CONVERT_EXPR)\n+\treturn NULL_TREE;\n+\n+      source_expr1 = find_bswap_1 (rhs1_stmt, n, limit - 1);\n+\n+      /* If find_bswap_1 returned NULL STMT is a leaf node and we have\n+\t to initialize the symbolic number.  */\n+      if (!source_expr1)\n+\t{\n+\t  /* Set up the symbolic number N by setting each byte to a\n+\t     value between 1 and the byte size of rhs1.  The highest\n+\t     order byte is set to 1 and the lowest order byte to\n+\t     n.size.  */\n+\t  n->size = TYPE_PRECISION (TREE_TYPE (rhs1));\n+\t  if (n->size % BITS_PER_UNIT != 0)\n+\t    return NULL_TREE;\n+\t  n->size /= BITS_PER_UNIT;\n+\t  n->n = (sizeof (HOST_WIDEST_INT) < 8 ? 0 :\n+\t\t  (unsigned HOST_WIDEST_INT)0x01020304 << 32 | 0x05060708);\n+\t  n->n >>= (sizeof (HOST_WIDEST_INT) - n->size) * BITS_PER_UNIT;\n+\n+\t  source_expr1 = rhs1;\n+\t}\n+\n+      switch (code)\n+\t{\n+\tcase BIT_AND_EXPR:\n+\t  {\n+\t    int i;\n+\t    unsigned HOST_WIDEST_INT val = widest_int_cst_value (rhs2);\n+\t    unsigned HOST_WIDEST_INT tmp = val;\n+\n+\t    /* Only constants masking full bytes are allowed.  */\n+\t    for (i = 0; i < n->size; i++, tmp >>= BITS_PER_UNIT)\n+\t      if ((tmp & 0xff) != 0 && (tmp & 0xff) != 0xff)\n+\t\treturn NULL_TREE;\n+\n+\t    n->n &= val;\n+\t  }\n+\t  break;\n+\tcase LSHIFT_EXPR:\n+\tcase RSHIFT_EXPR:\n+\tcase LROTATE_EXPR:\n+\tcase RROTATE_EXPR:\n+\t  if (!do_shift_rotate (code, n, (int)TREE_INT_CST_LOW (rhs2)))\n+\t    return NULL_TREE;\n+\t  break;\n+\tCASE_CONVERT:\n+\t  {\n+\t    int type_size;\n+\n+\t    type_size = TYPE_PRECISION (gimple_expr_type (stmt));\n+\t    if (type_size % BITS_PER_UNIT != 0)\n+\t      return NULL_TREE;\n+\n+\t    type_size /= BITS_PER_UNIT;\n+\n+\t    if (type_size / BITS_PER_UNIT < (int)(sizeof (HOST_WIDEST_INT)))\n+\t      {\n+\t\t/* If STMT casts to a smaller type mask out the bits not\n+\t\t   belonging to the target type.  */\n+\t\tn->size = type_size / BITS_PER_UNIT;\n+\t\tn->n &= ((unsigned HOST_WIDEST_INT)1 << type_size) - 1;\n+\t      }\n+\t  }\n+\t  break;\n+\tdefault:\n+\t  return NULL_TREE;\n+\t};\n+      return verify_symbolic_number_p (n, stmt) ? source_expr1 : NULL;\n+    }\n+\n+  /* Handle binary rhs.  */\n+\n+  if (rhs_class == GIMPLE_BINARY_RHS)\n+    {\n+      struct symbolic_number n1, n2;\n+      tree source_expr2;\n+\n+      if (code != BIT_IOR_EXPR)\n+\treturn NULL_TREE;\n+\n+      if (TREE_CODE (rhs2) != SSA_NAME)\n+\treturn NULL_TREE;\n+\n+      rhs2_stmt = SSA_NAME_DEF_STMT (rhs2);\n+\n+      switch (code)\n+\t{\n+\tcase BIT_IOR_EXPR:\n+\t  source_expr1 = find_bswap_1 (rhs1_stmt, &n1, limit - 1);\n+\n+\t  if (!source_expr1)\n+\t    return NULL_TREE;\n+\n+\t  source_expr2 = find_bswap_1 (rhs2_stmt, &n2, limit - 1);\n+\n+\t  if (source_expr1 != source_expr2\n+\t      || n1.size != n2.size)\n+\t    return NULL_TREE;\n+\n+\t  n->size = n1.size;\n+\t  n->n = n1.n | n2.n;\n+\n+\t  if (!verify_symbolic_number_p (n, stmt))\n+\t    return NULL_TREE;\n+\n+\t  break;\n+\tdefault:\n+\t  return NULL_TREE;\n+\t}\n+      return source_expr1;\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Check if STMT completes a bswap implementation consisting of ORs,\n+   SHIFTs and ANDs.  Return the source tree expression on which the\n+   byte swap is performed and NULL if no bswap was found.  */\n+\n+static tree\n+find_bswap (gimple stmt)\n+{\n+/* The number which the find_bswap result should match in order to\n+   have a full byte swap.  The insignificant bytes are masked out\n+   before using it.  */\n+  unsigned HOST_WIDEST_INT cmp =\n+    sizeof (HOST_WIDEST_INT) < 8 ? 0 :\n+    (unsigned HOST_WIDEST_INT)0x08070605 << 32 | 0x04030201;\n+\n+  struct symbolic_number n;\n+  tree source_expr;\n+\n+  source_expr =  find_bswap_1 (stmt, &n,\n+\t\t\t       TREE_INT_CST_LOW (\n+\t\t\t\t TYPE_SIZE_UNIT (gimple_expr_type (stmt))));\n+\n+  if (!source_expr)\n+    return NULL_TREE;\n+\n+  /* Zero out the extra bits of N and CMP.  */\n+  if (n.size < (int)sizeof (HOST_WIDEST_INT))\n+    {\n+      unsigned HOST_WIDEST_INT mask =\n+\t((unsigned HOST_WIDEST_INT)1 << (n.size * BITS_PER_UNIT)) - 1;\n+\n+      n.n &= mask;\n+      cmp &= mask;\n+    }\n+\n+  /* A complete byte swap should make the symbolic number to start\n+     with the largest digit in the highest order byte.  */\n+  if (cmp != n.n)\n+    return NULL_TREE;\n+\n+  return source_expr;\n+}\n+\n+/* Find manual byte swap implementations and turn them into a bswap\n+   builtin invokation.  */\n+\n+static unsigned int\n+execute_optimize_bswap (void)\n+{\n+  basic_block bb;\n+  bool bswap32_p, bswap64_p;\n+  bool changed = false;\n+\n+  if (BITS_PER_UNIT != 8)\n+    return 0;\n+\n+  if (sizeof (HOST_WIDEST_INT) < 8)\n+    return 0;\n+\n+  bswap32_p = (built_in_decls[BUILT_IN_BSWAP32]\n+\t       && optab_handler (bswap_optab, SImode)->insn_code !=\n+\t       CODE_FOR_nothing);\n+  bswap64_p = (built_in_decls[BUILT_IN_BSWAP64]\n+\t       && optab_handler (bswap_optab, DImode)->insn_code !=\n+\t       CODE_FOR_nothing);\n+\n+  if (!bswap32_p && !bswap64_p)\n+    return 0;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      gimple_stmt_iterator gsi;\n+\n+      for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+        {\n+\t  gimple stmt = gsi_stmt (gsi);\n+\t  tree bswap_src;\n+\t  tree fndecl = NULL_TREE;\n+\t  int type_size;\n+\t  gimple call;\n+\n+\t  if (!is_gimple_assign (stmt)\n+\t      || gimple_assign_rhs_code (stmt) != BIT_IOR_EXPR)\n+\t    continue;\n+\n+\t  type_size = TYPE_PRECISION (gimple_expr_type (stmt));\n+\n+\t  switch (type_size)\n+\t    {\n+\t    case 32:\n+\t      if (bswap32_p)\n+\t\tfndecl = built_in_decls[BUILT_IN_BSWAP32];\n+\t      break;\n+\t    case 64:\n+\t      if (bswap64_p)\n+\t\tfndecl = built_in_decls[BUILT_IN_BSWAP64];\n+\t      break;\n+\t    default:\n+\t      continue;\n+\t    }\n+\n+\t  if (!fndecl)\n+\t    continue;\n+\n+\t  bswap_src = find_bswap (stmt);\n+\n+\t  if (!bswap_src)\n+\t    continue;\n+\n+\t  changed = true;\n+\t  call = gimple_build_call (fndecl, 1, bswap_src);\n+\t  gimple_call_set_lhs (call, gimple_assign_lhs (stmt));\n+\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"%d bit bswap implementation found at: \",\n+\t\t       (int)type_size);\n+\t      print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t    }\n+\n+\t  gsi_insert_after (&gsi, call, GSI_SAME_STMT);\n+\t  gsi_remove (&gsi, true);\n+\t}\n+    }\n+\n+  return (changed ? TODO_dump_func | TODO_update_ssa | TODO_verify_ssa\n+\t  | TODO_verify_stmts : 0);\n+}\n+\n+static bool\n+gate_optimize_bswap (void)\n+{\n+  return flag_expensive_optimizations && optimize;\n+}\n+\n+struct gimple_opt_pass pass_optimize_bswap =\n+{\n+ {\n+  GIMPLE_PASS,\n+  \"bswap\",\t\t\t\t/* name */\n+  gate_optimize_bswap,                  /* gate */\n+  execute_optimize_bswap,\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_NONE,\t\t\t\t/* tv_id */\n+  PROP_ssa,\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  0                                     /* todo_flags_finish */\n+ }\n+};"}, {"sha": "6ed29ca42d1bcc582929ea3958b92e81520b8f49", "filename": "gcc/tree.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03bd2f1af7c1f2343940f6ca5409048ba16a2e4c/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03bd2f1af7c1f2343940f6ca5409048ba16a2e4c/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=03bd2f1af7c1f2343940f6ca5409048ba16a2e4c", "patch": "@@ -8489,6 +8489,35 @@ int_cst_value (const_tree x)\n   return val;\n }\n \n+/* Return value of a constant X and sign-extend it.  */\n+\n+HOST_WIDEST_INT\n+widest_int_cst_value (const_tree x)\n+{\n+  unsigned bits = TYPE_PRECISION (TREE_TYPE (x));\n+  unsigned HOST_WIDEST_INT val = TREE_INT_CST_LOW (x);\n+\n+#if HOST_BITS_PER_WIDEST_INT > HOST_BITS_PER_WIDE_INT\n+  gcc_assert (HOST_BITS_PER_WIDEST_INT >= 2 * HOST_BITS_PER_WIDE_INT);\n+  val |= TREE_INT_CST_HIGH (x) << HOST_BITS_PER_WIDE_INT;\n+#else\n+  /* Make sure the sign-extended value will fit in a HOST_WIDE_INT.  */\n+  gcc_assert (TREE_INT_CST_HIGH (x) == 0\n+\t      || TREE_INT_CST_HIGH (x) == -1);\n+#endif\n+\n+  if (bits < HOST_BITS_PER_WIDEST_INT)\n+    {\n+      bool negative = ((val >> (bits - 1)) & 1) != 0;\n+      if (negative)\n+\tval |= (~(unsigned HOST_WIDEST_INT) 0) << (bits - 1) << 1;\n+      else\n+\tval &= ~((~(unsigned HOST_WIDEST_INT) 0) << (bits - 1) << 1);\n+    }\n+\n+  return val;\n+}\n+\n /* If TYPE is an integral type, return an equivalent type which is\n     unsigned iff UNSIGNEDP is true.  If TYPE is not an integral type,\n     return TYPE itself.  */"}, {"sha": "9c1a1aa67dc0d0ac905d4413b797e818214f38c7", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03bd2f1af7c1f2343940f6ca5409048ba16a2e4c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03bd2f1af7c1f2343940f6ca5409048ba16a2e4c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=03bd2f1af7c1f2343940f6ca5409048ba16a2e4c", "patch": "@@ -4868,6 +4868,7 @@ extern tree build_nonstandard_integer_type (unsigned HOST_WIDE_INT, int);\n extern tree build_range_type (tree, tree, tree);\n extern bool subrange_type_for_debug_p (const_tree, tree *, tree *);\n extern HOST_WIDE_INT int_cst_value (const_tree);\n+extern HOST_WIDEST_INT widest_int_cst_value (const_tree);\n \n extern bool fields_compatible_p (const_tree, const_tree);\n extern tree find_compatible_field (tree, tree);"}]}