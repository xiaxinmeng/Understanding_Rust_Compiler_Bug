{"sha": "b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjg2OThhMGYzNzk0Y2EyZmRhOTgzN2RmZGQ4M2ZlZWExYTRjYTc1Yw==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2009-11-25T10:55:54Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2009-11-25T10:55:54Z"}, "message": "Remove trailing white spaces.\n\n2009-11-25  H.J. Lu  <hongjiu.lu@intel.com>\n\n\t* alias.c: Remove trailing white spaces.\n\t* alloc-pool.c: Likewise.\n\t* alloc-pool.h: Likewise.\n\t* attribs.c: Likewise.\n\t* auto-inc-dec.c: Likewise.\n\t* basic-block.h: Likewise.\n\t* bb-reorder.c: Likewise.\n\t* bt-load.c: Likewise.\n\t* builtins.c: Likewise.\n\t* builtins.def: Likewise.\n\t* c-common.c: Likewise.\n\t* c-common.h: Likewise.\n\t* c-cppbuiltin.c: Likewise.\n\t* c-decl.c: Likewise.\n\t* c-format.c: Likewise.\n\t* c-lex.c: Likewise.\n\t* c-omp.c: Likewise.\n\t* c-opts.c: Likewise.\n\t* c-parser.c: Likewise.\n\t* c-pretty-print.c: Likewise.\n\t* c-tree.h: Likewise.\n\t* c-typeck.c: Likewise.\n\t* caller-save.c: Likewise.\n\t* calls.c: Likewise.\n\t* cfg.c: Likewise.\n\t* cfganal.c: Likewise.\n\t* cfgexpand.c: Likewise.\n\t* cfghooks.c: Likewise.\n\t* cfghooks.h: Likewise.\n\t* cfglayout.c: Likewise.\n\t* cfgloop.c: Likewise.\n\t* cfgloop.h: Likewise.\n\t* cfgloopmanip.c: Likewise.\n\t* cfgrtl.c: Likewise.\n\t* cgraph.c: Likewise.\n\t* cgraph.h: Likewise.\n\t* cgraphbuild.c: Likewise.\n\t* cgraphunit.c: Likewise.\n\t* cif-code.def: Likewise.\n\t* collect2.c: Likewise.\n\t* combine.c: Likewise.\n\t* convert.c: Likewise.\n\t* coverage.c: Likewise.\n\t* crtstuff.c: Likewise.\n\t* cse.c: Likewise.\n\t* cselib.c: Likewise.\n\t* dbgcnt.c: Likewise.\n\t* dbgcnt.def: Likewise.\n\t* dbgcnt.h: Likewise.\n\t* dbxout.c: Likewise.\n\t* dce.c: Likewise.\n\t* ddg.c: Likewise.\n\t* ddg.h: Likewise.\n\t* defaults.h: Likewise.\n\t* df-byte-scan.c: Likewise.\n\t* df-core.c: Likewise.\n\t* df-problems.c: Likewise.\n\t* df-scan.c: Likewise.\n\t* df.h: Likewise.\n\t* dfp.c: Likewise.\n\t* diagnostic.c: Likewise.\n\t* diagnostic.h: Likewise.\n\t* dominance.c: Likewise.\n\t* domwalk.c: Likewise.\n\t* double-int.c: Likewise.\n\t* double-int.h: Likewise.\n\t* dse.c: Likewise.\n\t* dwarf2asm.c: Likewise.\n\t* dwarf2asm.h: Likewise.\n\t* dwarf2out.c: Likewise.\n\t* ebitmap.c: Likewise.\n\t* ebitmap.h: Likewise.\n\t* emit-rtl.c: Likewise.\n\t* et-forest.c: Likewise.\n\t* except.c: Likewise.\n\t* except.h: Likewise.\n\t* expmed.c: Likewise.\n\t* expr.c: Likewise.\n\t* expr.h: Likewise.\n\t* final.c: Likewise.\n\t* flags.h: Likewise.\n\t* fold-const.c: Likewise.\n\t* function.c: Likewise.\n\t* function.h: Likewise.\n\t* fwprop.c: Likewise.\n\t* gcc.c: Likewise.\n\t* gcov-dump.c: Likewise.\n\t* gcov-io.c: Likewise.\n\t* gcov-io.h: Likewise.\n\t* gcov.c: Likewise.\n\t* gcse.c: Likewise.\n\t* genattr.c: Likewise.\n\t* genattrtab.c: Likewise.\n\t* genautomata.c: Likewise.\n\t* genchecksum.c: Likewise.\n\t* genconfig.c: Likewise.\n\t* genflags.c: Likewise.\n\t* gengtype-parse.c: Likewise.\n\t* gengtype.c: Likewise.\n\t* gengtype.h: Likewise.\n\t* genmddeps.c: Likewise.\n\t* genmodes.c: Likewise.\n\t* genopinit.c: Likewise.\n\t* genpreds.c: Likewise.\n\t* gensupport.c: Likewise.\n\t* ggc-common.c: Likewise.\n\t* ggc-page.c: Likewise.\n\t* ggc-zone.c: Likewise.\n\t* ggc.h: Likewise.\n\t* gimple-iterator.c: Likewise.\n\t* gimple-low.c: Likewise.\n\t* gimple-pretty-print.c: Likewise.\n\t* gimple.c: Likewise.\n\t* gimple.def: Likewise.\n\t* gimple.h: Likewise.\n\t* gimplify.c: Likewise.\n\t* graphds.c: Likewise.\n\t* graphite-clast-to-gimple.c: Likewise.\n\t* gthr-nks.h: Likewise.\n\t* gthr-posix.c: Likewise.\n\t* gthr-posix.h: Likewise.\n\t* gthr-posix95.h: Likewise.\n\t* gthr-single.h: Likewise.\n\t* gthr-tpf.h: Likewise.\n\t* gthr-vxworks.h: Likewise.\n\t* gthr.h: Likewise.\n\t* haifa-sched.c: Likewise.\n\t* hard-reg-set.h: Likewise.\n\t* hooks.c: Likewise.\n\t* hooks.h: Likewise.\n\t* hosthooks.h: Likewise.\n\t* hwint.h: Likewise.\n\t* ifcvt.c: Likewise.\n\t* incpath.c: Likewise.\n\t* init-regs.c: Likewise.\n\t* integrate.c: Likewise.\n\t* ipa-cp.c: Likewise.\n\t* ipa-inline.c: Likewise.\n\t* ipa-prop.c: Likewise.\n\t* ipa-pure-const.c: Likewise.\n\t* ipa-reference.c: Likewise.\n\t* ipa-struct-reorg.c: Likewise.\n\t* ipa-struct-reorg.h: Likewise.\n\t* ipa-type-escape.c: Likewise.\n\t* ipa-type-escape.h: Likewise.\n\t* ipa-utils.c: Likewise.\n\t* ipa-utils.h: Likewise.\n\t* ipa.c: Likewise.\n\t* ira-build.c: Likewise.\n\t* ira-color.c: Likewise.\n\t* ira-conflicts.c: Likewise.\n\t* ira-costs.c: Likewise.\n\t* ira-emit.c: Likewise.\n\t* ira-int.h: Likewise.\n\t* ira-lives.c: Likewise.\n\t* ira.c: Likewise.\n\t* jump.c: Likewise.\n\t* lambda-code.c: Likewise.\n\t* lambda-mat.c: Likewise.\n\t* lambda-trans.c: Likewise.\n\t* lambda.h: Likewise.\n\t* langhooks.c: Likewise.\n\t* lcm.c: Likewise.\n\t* libgcov.c: Likewise.\n\t* lists.c: Likewise.\n\t* loop-doloop.c: Likewise.\n\t* loop-init.c: Likewise.\n\t* loop-invariant.c: Likewise.\n\t* loop-iv.c: Likewise.\n\t* loop-unroll.c: Likewise.\n\t* lower-subreg.c: Likewise.\n\t* lto-cgraph.c: Likewise.\n\t* lto-compress.c: Likewise.\n\t* lto-opts.c: Likewise.\n\t* lto-section-in.c: Likewise.\n\t* lto-section-out.c: Likewise.\n\t* lto-streamer-in.c: Likewise.\n\t* lto-streamer-out.c: Likewise.\n\t* lto-streamer.c: Likewise.\n\t* lto-streamer.h: Likewise.\n\t* lto-symtab.c: Likewise.\n\t* lto-wpa-fixup.c: Likewise.\n\t* matrix-reorg.c: Likewise.\n\t* mcf.c: Likewise.\n\t* mode-switching.c: Likewise.\n\t* modulo-sched.c: Likewise.\n\t* omega.c: Likewise.\n\t* omega.h: Likewise.\n\t* omp-low.c: Likewise.\n\t* optabs.c: Likewise.\n\t* optabs.h: Likewise.\n\t* opts-common.c: Likewise.\n\t* opts.c: Likewise.\n\t* params.def: Likewise.\n\t* params.h: Likewise.\n\t* passes.c: Likewise.\n\t* plugin.c: Likewise.\n\t* postreload-gcse.c: Likewise.\n\t* postreload.c: Likewise.\n\t* predict.c: Likewise.\n\t* predict.def: Likewise.\n\t* pretty-print.c: Likewise.\n\t* pretty-print.h: Likewise.\n\t* print-rtl.c: Likewise.\n\t* print-tree.c: Likewise.\n\t* profile.c: Likewise.\n\t* read-rtl.c: Likewise.\n\t* real.c: Likewise.\n\t* recog.c: Likewise.\n\t* reg-stack.c: Likewise.\n\t* regcprop.c: Likewise.\n\t* reginfo.c: Likewise.\n\t* regmove.c: Likewise.\n\t* regrename.c: Likewise.\n\t* regs.h: Likewise.\n\t* regstat.c: Likewise.\n\t* reload.c: Likewise.\n\t* reload1.c: Likewise.\n\t* resource.c: Likewise.\n\t* rtl.c: Likewise.\n\t* rtl.def: Likewise.\n\t* rtl.h: Likewise.\n\t* rtlanal.c: Likewise.\n\t* sbitmap.c: Likewise.\n\t* sched-deps.c: Likewise.\n\t* sched-ebb.c: Likewise.\n\t* sched-int.h: Likewise.\n\t* sched-rgn.c: Likewise.\n\t* sched-vis.c: Likewise.\n\t* sdbout.c: Likewise.\n\t* sel-sched-dump.c: Likewise.\n\t* sel-sched-dump.h: Likewise.\n\t* sel-sched-ir.c: Likewise.\n\t* sel-sched-ir.h: Likewise.\n\t* sel-sched.c: Likewise.\n\t* sel-sched.h: Likewise.\n\t* sese.c: Likewise.\n\t* sese.h: Likewise.\n\t* simplify-rtx.c: Likewise.\n\t* stack-ptr-mod.c: Likewise.\n\t* stmt.c: Likewise.\n\t* stor-layout.c: Likewise.\n\t* store-motion.c: Likewise.\n\t* stringpool.c: Likewise.\n\t* stub-objc.c: Likewise.\n\t* sync-builtins.def: Likewise.\n\t* target-def.h: Likewise.\n\t* target.h: Likewise.\n\t* targhooks.c: Likewise.\n\t* targhooks.h: Likewise.\n\t* timevar.c: Likewise.\n\t* tlink.c: Likewise.\n\t* toplev.c: Likewise.\n\t* toplev.h: Likewise.\n\t* tracer.c: Likewise.\n\t* tree-affine.c: Likewise.\n\t* tree-affine.h: Likewise.\n\t* tree-browser.def: Likewise.\n\t* tree-call-cdce.c: Likewise.\n\t* tree-cfg.c: Likewise.\n\t* tree-cfgcleanup.c: Likewise.\n\t* tree-chrec.c: Likewise.\n\t* tree-chrec.h: Likewise.\n\t* tree-complex.c: Likewise.\n\t* tree-data-ref.c: Likewise.\n\t* tree-data-ref.h: Likewise.\n\t* tree-dfa.c: Likewise.\n\t* tree-dump.c: Likewise.\n\t* tree-dump.h: Likewise.\n\t* tree-eh.c: Likewise.\n\t* tree-flow-inline.h: Likewise.\n\t* tree-flow.h: Likewise.\n\t* tree-if-conv.c: Likewise.\n\t* tree-inline.c: Likewise.\n\t* tree-into-ssa.c: Likewise.\n\t* tree-loop-distribution.c: Likewise.\n\t* tree-loop-linear.c: Likewise.\n\t* tree-mudflap.c: Likewise.\n\t* tree-nested.c: Likewise.\n\t* tree-nomudflap.c: Likewise.\n\t* tree-nrv.c: Likewise.\n\t* tree-object-size.c: Likewise.\n\t* tree-optimize.c: Likewise.\n\t* tree-outof-ssa.c: Likewise.\n\t* tree-parloops.c: Likewise.\n\t* tree-pass.h: Likewise.\n\t* tree-phinodes.c: Likewise.\n\t* tree-predcom.c: Likewise.\n\t* tree-pretty-print.c: Likewise.\n\t* tree-profile.c: Likewise.\n\t* tree-scalar-evolution.c: Likewise.\n\t* tree-ssa-address.c: Likewise.\n\t* tree-ssa-alias.c: Likewise.\n\t* tree-ssa-ccp.c: Likewise.\n\t* tree-ssa-coalesce.c: Likewise.\n\t* tree-ssa-copy.c: Likewise.\n\t* tree-ssa-copyrename.c: Likewise.\n\t* tree-ssa-dce.c: Likewise.\n\t* tree-ssa-dom.c: Likewise.\n\t* tree-ssa-dse.c: Likewise.\n\t* tree-ssa-forwprop.c: Likewise.\n\t* tree-ssa-ifcombine.c: Likewise.\n\t* tree-ssa-live.c: Likewise.\n\t* tree-ssa-live.h: Likewise.\n\t* tree-ssa-loop-ch.c: Likewise.\n\t* tree-ssa-loop-im.c: Likewise.\n\t* tree-ssa-loop-ivcanon.c: Likewise.\n\t* tree-ssa-loop-ivopts.c: Likewise.\n\t* tree-ssa-loop-manip.c: Likewise.\n\t* tree-ssa-loop-niter.c: Likewise.\n\t* tree-ssa-loop-prefetch.c: Likewise.\n\t* tree-ssa-loop-unswitch.c: Likewise.\n\t* tree-ssa-loop.c: Likewise.\n\t* tree-ssa-math-opts.c: Likewise.\n\t* tree-ssa-operands.c: Likewise.\n\t* tree-ssa-operands.h: Likewise.\n\t* tree-ssa-phiopt.c: Likewise.\n\t* tree-ssa-phiprop.c: Likewise.\n\t* tree-ssa-pre.c: Likewise.\n\t* tree-ssa-propagate.c: Likewise.\n\t* tree-ssa-reassoc.c: Likewise.\n\t* tree-ssa-sccvn.c: Likewise.\n\t* tree-ssa-sink.c: Likewise.\n\t* tree-ssa-structalias.c: Likewise.\n\t* tree-ssa-ter.c: Likewise.\n\t* tree-ssa-threadedge.c: Likewise.\n\t* tree-ssa-threadupdate.c: Likewise.\n\t* tree-ssa-uncprop.c: Likewise.\n\t* tree-ssa.c: Likewise.\n\t* tree-ssanames.c: Likewise.\n\t* tree-switch-conversion.c: Likewise.\n\t* tree-tailcall.c: Likewise.\n\t* tree-vect-data-refs.c: Likewise.\n\t* tree-vect-generic.c: Likewise.\n\t* tree-vect-loop-manip.c: Likewise.\n\t* tree-vect-loop.c: Likewise.\n\t* tree-vect-patterns.c: Likewise.\n\t* tree-vect-slp.c: Likewise.\n\t* tree-vect-stmts.c: Likewise.\n\t* tree-vectorizer.c: Likewise.\n\t* tree-vectorizer.h: Likewise.\n\t* tree-vrp.c: Likewise.\n\t* tree.c: Likewise.\n\t* tree.def: Likewise.\n\t* tree.h: Likewise.\n\t* treestruct.def: Likewise.\n\t* unwind-compat.c: Likewise.\n\t* unwind-dw2-fde-glibc.c: Likewise.\n\t* unwind-dw2.c: Likewise.\n\t* value-prof.c: Likewise.\n\t* value-prof.h: Likewise.\n\t* var-tracking.c: Likewise.\n\t* varasm.c: Likewise.\n\t* varpool.c: Likewise.\n\t* vec.c: Likewise.\n\t* vec.h: Likewise.\n\t* vmsdbgout.c: Likewise.\n\t* web.c: Likewise.\n\t* xcoffout.c: Likewise.\n\nFrom-SVN: r154645", "tree": {"sha": "4375f002b368e9044a1d9ca874026be04b7c3105", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4375f002b368e9044a1d9ca874026be04b7c3105"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "98aa3f36a781727c603ad99ada9632131154b9a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98aa3f36a781727c603ad99ada9632131154b9a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98aa3f36a781727c603ad99ada9632131154b9a7"}], "stats": {"total": 18904, "additions": 9633, "deletions": 9271}, "files": [{"sha": "e2e25069b5962a78402c9fc18177f4d1ce0c869e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 362, "deletions": 0, "changes": 362, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -1,3 +1,365 @@\n+2009-11-25  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* alias.c: Remove trailing white spaces.\n+\t* alloc-pool.c: Likewise.\n+\t* alloc-pool.h: Likewise.\n+\t* attribs.c: Likewise.\n+\t* auto-inc-dec.c: Likewise.\n+\t* basic-block.h: Likewise.\n+\t* bb-reorder.c: Likewise.\n+\t* bt-load.c: Likewise.\n+\t* builtins.c: Likewise.\n+\t* builtins.def: Likewise.\n+\t* c-common.c: Likewise.\n+\t* c-common.h: Likewise.\n+\t* c-cppbuiltin.c: Likewise.\n+\t* c-decl.c: Likewise.\n+\t* c-format.c: Likewise.\n+\t* c-lex.c: Likewise.\n+\t* c-omp.c: Likewise.\n+\t* c-opts.c: Likewise.\n+\t* c-parser.c: Likewise.\n+\t* c-pretty-print.c: Likewise.\n+\t* c-tree.h: Likewise.\n+\t* c-typeck.c: Likewise.\n+\t* caller-save.c: Likewise.\n+\t* calls.c: Likewise.\n+\t* cfg.c: Likewise.\n+\t* cfganal.c: Likewise.\n+\t* cfgexpand.c: Likewise.\n+\t* cfghooks.c: Likewise.\n+\t* cfghooks.h: Likewise.\n+\t* cfglayout.c: Likewise.\n+\t* cfgloop.c: Likewise.\n+\t* cfgloop.h: Likewise.\n+\t* cfgloopmanip.c: Likewise.\n+\t* cfgrtl.c: Likewise.\n+\t* cgraph.c: Likewise.\n+\t* cgraph.h: Likewise.\n+\t* cgraphbuild.c: Likewise.\n+\t* cgraphunit.c: Likewise.\n+\t* cif-code.def: Likewise.\n+\t* collect2.c: Likewise.\n+\t* combine.c: Likewise.\n+\t* convert.c: Likewise.\n+\t* coverage.c: Likewise.\n+\t* crtstuff.c: Likewise.\n+\t* cse.c: Likewise.\n+\t* cselib.c: Likewise.\n+\t* dbgcnt.c: Likewise.\n+\t* dbgcnt.def: Likewise.\n+\t* dbgcnt.h: Likewise.\n+\t* dbxout.c: Likewise.\n+\t* dce.c: Likewise.\n+\t* ddg.c: Likewise.\n+\t* ddg.h: Likewise.\n+\t* defaults.h: Likewise.\n+\t* df-byte-scan.c: Likewise.\n+\t* df-core.c: Likewise.\n+\t* df-problems.c: Likewise.\n+\t* df-scan.c: Likewise.\n+\t* df.h: Likewise.\n+\t* dfp.c: Likewise.\n+\t* diagnostic.c: Likewise.\n+\t* diagnostic.h: Likewise.\n+\t* dominance.c: Likewise.\n+\t* domwalk.c: Likewise.\n+\t* double-int.c: Likewise.\n+\t* double-int.h: Likewise.\n+\t* dse.c: Likewise.\n+\t* dwarf2asm.c: Likewise.\n+\t* dwarf2asm.h: Likewise.\n+\t* dwarf2out.c: Likewise.\n+\t* ebitmap.c: Likewise.\n+\t* ebitmap.h: Likewise.\n+\t* emit-rtl.c: Likewise.\n+\t* et-forest.c: Likewise.\n+\t* except.c: Likewise.\n+\t* except.h: Likewise.\n+\t* expmed.c: Likewise.\n+\t* expr.c: Likewise.\n+\t* expr.h: Likewise.\n+\t* final.c: Likewise.\n+\t* flags.h: Likewise.\n+\t* fold-const.c: Likewise.\n+\t* function.c: Likewise.\n+\t* function.h: Likewise.\n+\t* fwprop.c: Likewise.\n+\t* gcc.c: Likewise.\n+\t* gcov-dump.c: Likewise.\n+\t* gcov-io.c: Likewise.\n+\t* gcov-io.h: Likewise.\n+\t* gcov.c: Likewise.\n+\t* gcse.c: Likewise.\n+\t* genattr.c: Likewise.\n+\t* genattrtab.c: Likewise.\n+\t* genautomata.c: Likewise.\n+\t* genchecksum.c: Likewise.\n+\t* genconfig.c: Likewise.\n+\t* genflags.c: Likewise.\n+\t* gengtype-parse.c: Likewise.\n+\t* gengtype.c: Likewise.\n+\t* gengtype.h: Likewise.\n+\t* genmddeps.c: Likewise.\n+\t* genmodes.c: Likewise.\n+\t* genopinit.c: Likewise.\n+\t* genpreds.c: Likewise.\n+\t* gensupport.c: Likewise.\n+\t* ggc-common.c: Likewise.\n+\t* ggc-page.c: Likewise.\n+\t* ggc-zone.c: Likewise.\n+\t* ggc.h: Likewise.\n+\t* gimple-iterator.c: Likewise.\n+\t* gimple-low.c: Likewise.\n+\t* gimple-pretty-print.c: Likewise.\n+\t* gimple.c: Likewise.\n+\t* gimple.def: Likewise.\n+\t* gimple.h: Likewise.\n+\t* gimplify.c: Likewise.\n+\t* graphds.c: Likewise.\n+\t* graphite-clast-to-gimple.c: Likewise.\n+\t* gthr-nks.h: Likewise.\n+\t* gthr-posix.c: Likewise.\n+\t* gthr-posix.h: Likewise.\n+\t* gthr-posix95.h: Likewise.\n+\t* gthr-single.h: Likewise.\n+\t* gthr-tpf.h: Likewise.\n+\t* gthr-vxworks.h: Likewise.\n+\t* gthr.h: Likewise.\n+\t* haifa-sched.c: Likewise.\n+\t* hard-reg-set.h: Likewise.\n+\t* hooks.c: Likewise.\n+\t* hooks.h: Likewise.\n+\t* hosthooks.h: Likewise.\n+\t* hwint.h: Likewise.\n+\t* ifcvt.c: Likewise.\n+\t* incpath.c: Likewise.\n+\t* init-regs.c: Likewise.\n+\t* integrate.c: Likewise.\n+\t* ipa-cp.c: Likewise.\n+\t* ipa-inline.c: Likewise.\n+\t* ipa-prop.c: Likewise.\n+\t* ipa-pure-const.c: Likewise.\n+\t* ipa-reference.c: Likewise.\n+\t* ipa-struct-reorg.c: Likewise.\n+\t* ipa-struct-reorg.h: Likewise.\n+\t* ipa-type-escape.c: Likewise.\n+\t* ipa-type-escape.h: Likewise.\n+\t* ipa-utils.c: Likewise.\n+\t* ipa-utils.h: Likewise.\n+\t* ipa.c: Likewise.\n+\t* ira-build.c: Likewise.\n+\t* ira-color.c: Likewise.\n+\t* ira-conflicts.c: Likewise.\n+\t* ira-costs.c: Likewise.\n+\t* ira-emit.c: Likewise.\n+\t* ira-int.h: Likewise.\n+\t* ira-lives.c: Likewise.\n+\t* ira.c: Likewise.\n+\t* jump.c: Likewise.\n+\t* lambda-code.c: Likewise.\n+\t* lambda-mat.c: Likewise.\n+\t* lambda-trans.c: Likewise.\n+\t* lambda.h: Likewise.\n+\t* langhooks.c: Likewise.\n+\t* lcm.c: Likewise.\n+\t* libgcov.c: Likewise.\n+\t* lists.c: Likewise.\n+\t* loop-doloop.c: Likewise.\n+\t* loop-init.c: Likewise.\n+\t* loop-invariant.c: Likewise.\n+\t* loop-iv.c: Likewise.\n+\t* loop-unroll.c: Likewise.\n+\t* lower-subreg.c: Likewise.\n+\t* lto-cgraph.c: Likewise.\n+\t* lto-compress.c: Likewise.\n+\t* lto-opts.c: Likewise.\n+\t* lto-section-in.c: Likewise.\n+\t* lto-section-out.c: Likewise.\n+\t* lto-streamer-in.c: Likewise.\n+\t* lto-streamer-out.c: Likewise.\n+\t* lto-streamer.c: Likewise.\n+\t* lto-streamer.h: Likewise.\n+\t* lto-symtab.c: Likewise.\n+\t* lto-wpa-fixup.c: Likewise.\n+\t* matrix-reorg.c: Likewise.\n+\t* mcf.c: Likewise.\n+\t* mode-switching.c: Likewise.\n+\t* modulo-sched.c: Likewise.\n+\t* omega.c: Likewise.\n+\t* omega.h: Likewise.\n+\t* omp-low.c: Likewise.\n+\t* optabs.c: Likewise.\n+\t* optabs.h: Likewise.\n+\t* opts-common.c: Likewise.\n+\t* opts.c: Likewise.\n+\t* params.def: Likewise.\n+\t* params.h: Likewise.\n+\t* passes.c: Likewise.\n+\t* plugin.c: Likewise.\n+\t* postreload-gcse.c: Likewise.\n+\t* postreload.c: Likewise.\n+\t* predict.c: Likewise.\n+\t* predict.def: Likewise.\n+\t* pretty-print.c: Likewise.\n+\t* pretty-print.h: Likewise.\n+\t* print-rtl.c: Likewise.\n+\t* print-tree.c: Likewise.\n+\t* profile.c: Likewise.\n+\t* read-rtl.c: Likewise.\n+\t* real.c: Likewise.\n+\t* recog.c: Likewise.\n+\t* reg-stack.c: Likewise.\n+\t* regcprop.c: Likewise.\n+\t* reginfo.c: Likewise.\n+\t* regmove.c: Likewise.\n+\t* regrename.c: Likewise.\n+\t* regs.h: Likewise.\n+\t* regstat.c: Likewise.\n+\t* reload.c: Likewise.\n+\t* reload1.c: Likewise.\n+\t* resource.c: Likewise.\n+\t* rtl.c: Likewise.\n+\t* rtl.def: Likewise.\n+\t* rtl.h: Likewise.\n+\t* rtlanal.c: Likewise.\n+\t* sbitmap.c: Likewise.\n+\t* sched-deps.c: Likewise.\n+\t* sched-ebb.c: Likewise.\n+\t* sched-int.h: Likewise.\n+\t* sched-rgn.c: Likewise.\n+\t* sched-vis.c: Likewise.\n+\t* sdbout.c: Likewise.\n+\t* sel-sched-dump.c: Likewise.\n+\t* sel-sched-dump.h: Likewise.\n+\t* sel-sched-ir.c: Likewise.\n+\t* sel-sched-ir.h: Likewise.\n+\t* sel-sched.c: Likewise.\n+\t* sel-sched.h: Likewise.\n+\t* sese.c: Likewise.\n+\t* sese.h: Likewise.\n+\t* simplify-rtx.c: Likewise.\n+\t* stack-ptr-mod.c: Likewise.\n+\t* stmt.c: Likewise.\n+\t* stor-layout.c: Likewise.\n+\t* store-motion.c: Likewise.\n+\t* stringpool.c: Likewise.\n+\t* stub-objc.c: Likewise.\n+\t* sync-builtins.def: Likewise.\n+\t* target-def.h: Likewise.\n+\t* target.h: Likewise.\n+\t* targhooks.c: Likewise.\n+\t* targhooks.h: Likewise.\n+\t* timevar.c: Likewise.\n+\t* tlink.c: Likewise.\n+\t* toplev.c: Likewise.\n+\t* toplev.h: Likewise.\n+\t* tracer.c: Likewise.\n+\t* tree-affine.c: Likewise.\n+\t* tree-affine.h: Likewise.\n+\t* tree-browser.def: Likewise.\n+\t* tree-call-cdce.c: Likewise.\n+\t* tree-cfg.c: Likewise.\n+\t* tree-cfgcleanup.c: Likewise.\n+\t* tree-chrec.c: Likewise.\n+\t* tree-chrec.h: Likewise.\n+\t* tree-complex.c: Likewise.\n+\t* tree-data-ref.c: Likewise.\n+\t* tree-data-ref.h: Likewise.\n+\t* tree-dfa.c: Likewise.\n+\t* tree-dump.c: Likewise.\n+\t* tree-dump.h: Likewise.\n+\t* tree-eh.c: Likewise.\n+\t* tree-flow-inline.h: Likewise.\n+\t* tree-flow.h: Likewise.\n+\t* tree-if-conv.c: Likewise.\n+\t* tree-inline.c: Likewise.\n+\t* tree-into-ssa.c: Likewise.\n+\t* tree-loop-distribution.c: Likewise.\n+\t* tree-loop-linear.c: Likewise.\n+\t* tree-mudflap.c: Likewise.\n+\t* tree-nested.c: Likewise.\n+\t* tree-nomudflap.c: Likewise.\n+\t* tree-nrv.c: Likewise.\n+\t* tree-object-size.c: Likewise.\n+\t* tree-optimize.c: Likewise.\n+\t* tree-outof-ssa.c: Likewise.\n+\t* tree-parloops.c: Likewise.\n+\t* tree-pass.h: Likewise.\n+\t* tree-phinodes.c: Likewise.\n+\t* tree-predcom.c: Likewise.\n+\t* tree-pretty-print.c: Likewise.\n+\t* tree-profile.c: Likewise.\n+\t* tree-scalar-evolution.c: Likewise.\n+\t* tree-ssa-address.c: Likewise.\n+\t* tree-ssa-alias.c: Likewise.\n+\t* tree-ssa-ccp.c: Likewise.\n+\t* tree-ssa-coalesce.c: Likewise.\n+\t* tree-ssa-copy.c: Likewise.\n+\t* tree-ssa-copyrename.c: Likewise.\n+\t* tree-ssa-dce.c: Likewise.\n+\t* tree-ssa-dom.c: Likewise.\n+\t* tree-ssa-dse.c: Likewise.\n+\t* tree-ssa-forwprop.c: Likewise.\n+\t* tree-ssa-ifcombine.c: Likewise.\n+\t* tree-ssa-live.c: Likewise.\n+\t* tree-ssa-live.h: Likewise.\n+\t* tree-ssa-loop-ch.c: Likewise.\n+\t* tree-ssa-loop-im.c: Likewise.\n+\t* tree-ssa-loop-ivcanon.c: Likewise.\n+\t* tree-ssa-loop-ivopts.c: Likewise.\n+\t* tree-ssa-loop-manip.c: Likewise.\n+\t* tree-ssa-loop-niter.c: Likewise.\n+\t* tree-ssa-loop-prefetch.c: Likewise.\n+\t* tree-ssa-loop-unswitch.c: Likewise.\n+\t* tree-ssa-loop.c: Likewise.\n+\t* tree-ssa-math-opts.c: Likewise.\n+\t* tree-ssa-operands.c: Likewise.\n+\t* tree-ssa-operands.h: Likewise.\n+\t* tree-ssa-phiopt.c: Likewise.\n+\t* tree-ssa-phiprop.c: Likewise.\n+\t* tree-ssa-pre.c: Likewise.\n+\t* tree-ssa-propagate.c: Likewise.\n+\t* tree-ssa-reassoc.c: Likewise.\n+\t* tree-ssa-sccvn.c: Likewise.\n+\t* tree-ssa-sink.c: Likewise.\n+\t* tree-ssa-structalias.c: Likewise.\n+\t* tree-ssa-ter.c: Likewise.\n+\t* tree-ssa-threadedge.c: Likewise.\n+\t* tree-ssa-threadupdate.c: Likewise.\n+\t* tree-ssa-uncprop.c: Likewise.\n+\t* tree-ssa.c: Likewise.\n+\t* tree-ssanames.c: Likewise.\n+\t* tree-switch-conversion.c: Likewise.\n+\t* tree-tailcall.c: Likewise.\n+\t* tree-vect-data-refs.c: Likewise.\n+\t* tree-vect-generic.c: Likewise.\n+\t* tree-vect-loop-manip.c: Likewise.\n+\t* tree-vect-loop.c: Likewise.\n+\t* tree-vect-patterns.c: Likewise.\n+\t* tree-vect-slp.c: Likewise.\n+\t* tree-vect-stmts.c: Likewise.\n+\t* tree-vectorizer.c: Likewise.\n+\t* tree-vectorizer.h: Likewise.\n+\t* tree-vrp.c: Likewise.\n+\t* tree.c: Likewise.\n+\t* tree.def: Likewise.\n+\t* tree.h: Likewise.\n+\t* treestruct.def: Likewise.\n+\t* unwind-compat.c: Likewise.\n+\t* unwind-dw2-fde-glibc.c: Likewise.\n+\t* unwind-dw2.c: Likewise.\n+\t* value-prof.c: Likewise.\n+\t* value-prof.h: Likewise.\n+\t* var-tracking.c: Likewise.\n+\t* varasm.c: Likewise.\n+\t* varpool.c: Likewise.\n+\t* vec.c: Likewise.\n+\t* vec.h: Likewise.\n+\t* vmsdbgout.c: Likewise.\n+\t* web.c: Likewise.\n+\t* xcoffout.c: Likewise.\n+\n 2009-11-24  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* pa.c (output_call): Only use sr4 for long interspace calls if"}, {"sha": "41a2f2318f74cd3757a3e4bef8c090aa3ca4b1c2", "filename": "gcc/alias.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -452,8 +452,8 @@ walk_mems_2 (rtx *x, rtx mem)\n     {\n       if (alias_sets_conflict_p (MEM_ALIAS_SET(*x), MEM_ALIAS_SET(mem)))\n         return 1;\n-        \n-      return -1;  \n+\n+      return -1;\n     }\n   return 0;\n }\n@@ -467,7 +467,7 @@ walk_mems_1 (rtx *x, rtx *pat)\n       if (for_each_rtx (pat, (rtx_function) walk_mems_2, *x))\n         /* Indicate that dependence was determined and stop traversal.  */\n         return 1;\n-        \n+\n       return -1;\n     }\n   return 0;"}, {"sha": "6eecef53ee2ce8503323a637d5bb7bce60d9ccef", "filename": "gcc/alloc-pool.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Falloc-pool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Falloc-pool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -274,7 +274,7 @@ pool_alloc (alloc_pool pool)\n \t  block = XNEWVEC (char, pool->block_size);\n \t  block_header = (alloc_pool_list) block;\n \t  block += align_eight (sizeof (struct alloc_pool_list_def));\n-\t  \n+\n \t  /* Throw it on the block list.  */\n \t  block_header->next = pool->block_list;\n \t  pool->block_list = block_header;\n@@ -290,7 +290,7 @@ pool_alloc (alloc_pool pool)\n \t  pool->blocks_allocated += 1;\n \t}\n \n-      \n+\n       /* We now know that we can take the first elt off the virgin list and\n \t put it on the returned list. */\n       block = pool->virgin_free_list;\n@@ -374,8 +374,8 @@ print_statistics (void **slot, void *b)\n   if (d->allocated)\n     {\n       fprintf (stderr, \"%-22s %6d %10lu %10lu(%10lu) %10lu(%10lu) %10lu(%10lu)\\n\", d->name,\n-\t       d->elt_size, d->created, d->allocated, d->allocated / d->elt_size, \n-\t       d->peak, d->peak / d->elt_size, \n+\t       d->elt_size, d->created, d->allocated, d->allocated / d->elt_size,\n+\t       d->peak, d->peak / d->elt_size,\n \t       d->current, d->current / d->elt_size);\n       i->total_allocated += d->allocated;\n       i->total_created += d->created;"}, {"sha": "fa9848a2b9b84dc7fcbf211b262fafe198954bac", "filename": "gcc/alloc-pool.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Falloc-pool.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Falloc-pool.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -45,7 +45,7 @@ typedef struct alloc_pool_def\n   char* virgin_free_list;\n \n   /* The number of elements in the virgin_free_list that can be\n-     allocated before needing another block.  */ \n+     allocated before needing another block.  */\n   size_t virgin_elts_remaining;\n \n   size_t elts_allocated;"}, {"sha": "9f2f50bdfd93a1c98272548c722700f47ab30c5a", "filename": "gcc/attribs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -192,7 +192,7 @@ init_attributes (void)\n /* Insert a single ATTR into the attribute table.  */\n \n void\n-register_attribute (const struct attribute_spec *attr) \n+register_attribute (const struct attribute_spec *attr)\n {\n   struct substring str;\n   void **slot;"}, {"sha": "830fc5e09f05fae45e70af5199f8b944ad5eeb0e", "filename": "gcc/auto-inc-dec.c", "status": "modified", "additions": 106, "deletions": 106, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fauto-inc-dec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fauto-inc-dec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-inc-dec.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -1,7 +1,7 @@\n /* Discovery of auto-inc and auto-dec instructions.\n    Copyright (C) 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n    Contributed by Kenneth Zadeck <zadeck@naturalbridge.com>\n-   \n+\n This file is part of GCC.\n \n GCC is free software; you can redistribute it and/or modify it under\n@@ -74,7 +74,7 @@ along with GCC; see the file COPYING3.  If not see\n            ...\n            b <- a + c\n \n-\t   (For this case to be true, b must not be assigned or used between \n+\t   (For this case to be true, b must not be assigned or used between\n \t   the *a and the assignment to b.  B must also be a Pmode reg.)\n \n         becomes\n@@ -104,9 +104,9 @@ along with GCC; see the file COPYING3.  If not see\n        by the pointer.  This is useful for machines that have\n        HAVE_PRE_MODIFY_DISP, HAVE_POST_MODIFY_DISP defined.\n \n-    3) c is a register.  This is useful for machines that have \n-       HAVE_PRE_MODIFY_REG,  HAVE_POST_MODIFY_REG  \n-  \n+    3) c is a register.  This is useful for machines that have\n+       HAVE_PRE_MODIFY_REG,  HAVE_POST_MODIFY_REG\n+\n   The is one special case: if a already had an offset equal to it +-\n   its width and that offset is equal to -c when the increment was\n   before the ref or +c if the increment was after the ref, then if we\n@@ -129,7 +129,7 @@ enum form\n    ANY is used for constants that are not +-size or 0.  REG is used if\n    the forms are reg1 + reg2.  */\n \n-enum inc_state \n+enum inc_state\n {\n   INC_ZERO,           /* == 0  */\n   INC_NEG_SIZE,       /* == +size  */\n@@ -295,7 +295,7 @@ init_decision_table (void)\n /* Parsed fields of an inc insn of the form \"reg_res = reg0+reg1\" or\n    \"reg_res = reg0+c\".  */\n \n-static struct inc_insn \n+static struct inc_insn\n {\n   rtx insn;           /* The insn being parsed.  */\n   rtx pat;            /* The pattern of the insn.  */\n@@ -311,10 +311,10 @@ static struct inc_insn\n \n /* Dump the parsed inc insn to FILE.  */\n \n-static void \n+static void\n dump_inc_insn (FILE *file)\n {\n-  const char *f = ((inc_insn.form == FORM_PRE_ADD) \n+  const char *f = ((inc_insn.form == FORM_PRE_ADD)\n \t      || (inc_insn.form == FORM_PRE_INC)) ? \"pre\" : \"post\";\n \n   dump_insn_slim (file, inc_insn.insn);\n@@ -324,26 +324,26 @@ dump_inc_insn (FILE *file)\n     case FORM_PRE_ADD:\n     case FORM_POST_ADD:\n       if (inc_insn.reg1_is_const)\n-\tfprintf (file, \"found %s add(%d) r[%d]=r[%d]+%d\\n\", \n-\t\t f, INSN_UID (inc_insn.insn), \n-\t\t REGNO (inc_insn.reg_res), \n+\tfprintf (file, \"found %s add(%d) r[%d]=r[%d]+%d\\n\",\n+\t\t f, INSN_UID (inc_insn.insn),\n+\t\t REGNO (inc_insn.reg_res),\n \t\t REGNO (inc_insn.reg0), (int) inc_insn.reg1_val);\n       else\n-\tfprintf (file, \"found %s add(%d) r[%d]=r[%d]+r[%d]\\n\", \n-\t\t f, INSN_UID (inc_insn.insn), \n-\t\t REGNO (inc_insn.reg_res), \n+\tfprintf (file, \"found %s add(%d) r[%d]=r[%d]+r[%d]\\n\",\n+\t\t f, INSN_UID (inc_insn.insn),\n+\t\t REGNO (inc_insn.reg_res),\n \t\t REGNO (inc_insn.reg0), REGNO (inc_insn.reg1));\n       break;\n-      \n+\n     case FORM_PRE_INC:\n     case FORM_POST_INC:\n       if (inc_insn.reg1_is_const)\n-\tfprintf (file, \"found %s inc(%d) r[%d]+=%d\\n\", \n-\t\t f, INSN_UID (inc_insn.insn), \n+\tfprintf (file, \"found %s inc(%d) r[%d]+=%d\\n\",\n+\t\t f, INSN_UID (inc_insn.insn),\n \t\t REGNO (inc_insn.reg_res), (int) inc_insn.reg1_val);\n       else\n-\tfprintf (file, \"found %s inc(%d) r[%d]+=r[%d]\\n\", \n-\t\t f, INSN_UID (inc_insn.insn), \n+\tfprintf (file, \"found %s inc(%d) r[%d]+=r[%d]\\n\",\n+\t\t f, INSN_UID (inc_insn.insn),\n \t\t REGNO (inc_insn.reg_res), REGNO (inc_insn.reg1));\n       break;\n \n@@ -372,18 +372,18 @@ static struct mem_insn\n \n /* Dump the parsed mem insn to FILE.  */\n \n-static void \n+static void\n dump_mem_insn (FILE *file)\n {\n   dump_insn_slim (file, mem_insn.insn);\n \n   if (mem_insn.reg1_is_const)\n-    fprintf (file, \"found mem(%d) *(r[%d]+%d)\\n\", \n-\t     INSN_UID (mem_insn.insn), \n+    fprintf (file, \"found mem(%d) *(r[%d]+%d)\\n\",\n+\t     INSN_UID (mem_insn.insn),\n \t     REGNO (mem_insn.reg0), (int) mem_insn.reg1_val);\n   else\n-    fprintf (file, \"found mem(%d) *(r[%d]+r[%d])\\n\", \n-\t     INSN_UID (mem_insn.insn), \n+    fprintf (file, \"found mem(%d) *(r[%d]+r[%d])\\n\",\n+\t     INSN_UID (mem_insn.insn),\n \t     REGNO (mem_insn.reg0), REGNO (mem_insn.reg1));\n }\n \n@@ -409,17 +409,17 @@ static rtx *reg_next_def = NULL;\n    insn.  Moving the REG_EQUAL and REG_EQUIV is clearly wrong and it\n    does not appear that there are any other kinds of relevant notes.  */\n \n-static void \n+static void\n move_dead_notes (rtx to_insn, rtx from_insn, rtx pattern)\n {\n-  rtx note; \n+  rtx note;\n   rtx next_note;\n   rtx prev_note = NULL;\n \n   for (note = REG_NOTES (from_insn); note; note = next_note)\n     {\n       next_note = XEXP (note, 1);\n-      \n+\n       if ((REG_NOTE_KIND (note) == REG_DEAD)\n \t  && pattern == XEXP (note, 0))\n \t{\n@@ -451,7 +451,7 @@ insert_move_insn_before (rtx next_insn, rtx dest_reg, rtx src_reg)\n   return insns;\n }\n \n-  \n+\n /* Change mem_insn.mem_loc so that uses NEW_ADDR which has an\n    increment of INC_REG.  To have reached this point, the change is a\n    legitimate one from a dataflow point of view.  The only questions\n@@ -504,7 +504,7 @@ attempt_change (rtx new_addr, rtx inc_reg)\n   if (! validate_change (mem_insn.insn, mem_insn.mem_loc, new_mem, 0))\n     {\n       if (dump_file)\n-\tfprintf (dump_file, \"validation failure\\n\"); \n+\tfprintf (dump_file, \"validation failure\\n\");\n       return false;\n     }\n \n@@ -517,7 +517,7 @@ attempt_change (rtx new_addr, rtx inc_reg)\n       /* Replace the addition with a move.  Do it at the location of\n \t the addition since the operand of the addition may change\n \t before the memory reference.  */\n-      mov_insn = insert_move_insn_before (inc_insn.insn, \n+      mov_insn = insert_move_insn_before (inc_insn.insn,\n \t\t\t\t\t  inc_insn.reg_res, inc_insn.reg0);\n       move_dead_notes (mov_insn, inc_insn.insn, inc_insn.reg0);\n \n@@ -543,7 +543,7 @@ attempt_change (rtx new_addr, rtx inc_reg)\n       break;\n \n     case FORM_POST_ADD:\n-      mov_insn = insert_move_insn_before (mem_insn.insn, \n+      mov_insn = insert_move_insn_before (mem_insn.insn,\n \t\t\t\t\t  inc_insn.reg_res, inc_insn.reg0);\n       move_dead_notes (mov_insn, inc_insn.insn, inc_insn.reg0);\n \n@@ -603,7 +603,7 @@ attempt_change (rtx new_addr, rtx inc_reg)\n    Assuming the form is ok, a prototype new address is built which is\n    passed to ATTEMPT_CHANGE for final processing.  */\n \n-static bool \n+static bool\n try_merge (void)\n {\n   enum gen_form gen_form;\n@@ -648,13 +648,13 @@ try_merge (void)\n       return false;\n     }\n \n-  mem_insn.reg1_state = (mem_insn.reg1_is_const) \n+  mem_insn.reg1_state = (mem_insn.reg1_is_const)\n     ? set_inc_state (mem_insn.reg1_val, size) : INC_REG;\n   inc_insn.reg1_state = (inc_insn.reg1_is_const)\n     ? set_inc_state (inc_insn.reg1_val, size) : INC_REG;\n \n   /* Now get the form that we are generating.  */\n-  gen_form = decision_table \n+  gen_form = decision_table\n     [inc_insn.reg1_state][mem_insn.reg1_state][inc_insn.form];\n \n   if (dbg_cnt (auto_inc_dec) == false)\n@@ -671,25 +671,25 @@ try_merge (void)\n \tfprintf (dump_file, \"trying SIMPLE_PRE_INC\\n\");\n       return attempt_change (gen_rtx_PRE_INC (reg_mode, inc_reg), inc_reg);\n       break;\n-      \n+\n     case SIMPLE_POST_INC:    /* size++  */\n       if (dump_file)\n \tfprintf (dump_file, \"trying SIMPLE_POST_INC\\n\");\n       return attempt_change (gen_rtx_POST_INC (reg_mode, inc_reg), inc_reg);\n       break;\n-      \n+\n     case SIMPLE_PRE_DEC:     /* --size  */\n       if (dump_file)\n \tfprintf (dump_file, \"trying SIMPLE_PRE_DEC\\n\");\n       return attempt_change (gen_rtx_PRE_DEC (reg_mode, inc_reg), inc_reg);\n       break;\n-      \n+\n     case SIMPLE_POST_DEC:    /* size--  */\n       if (dump_file)\n \tfprintf (dump_file, \"trying SIMPLE_POST_DEC\\n\");\n       return attempt_change (gen_rtx_POST_DEC (reg_mode, inc_reg), inc_reg);\n       break;\n-      \n+\n     case DISP_PRE:           /* ++con   */\n       if (dump_file)\n \tfprintf (dump_file, \"trying DISP_PRE\\n\");\n@@ -700,7 +700,7 @@ try_merge (void)\n \t\t\t\t\t\t\t       inc_insn.reg1)),\n \t\t\t     inc_reg);\n       break;\n-      \n+\n     case DISP_POST:          /* con++   */\n       if (dump_file)\n \tfprintf (dump_file, \"trying POST_DISP\\n\");\n@@ -711,7 +711,7 @@ try_merge (void)\n \t\t\t\t\t\t\t\tinc_insn.reg1)),\n \t\t\t     inc_reg);\n       break;\n-      \n+\n     case REG_PRE:            /* ++reg   */\n       if (dump_file)\n \tfprintf (dump_file, \"trying PRE_REG\\n\");\n@@ -722,7 +722,7 @@ try_merge (void)\n \t\t\t\t\t\t\t       inc_insn.reg1)),\n \t\t\t     inc_reg);\n       break;\n-      \n+\n     case REG_POST:            /* reg++   */\n       if (dump_file)\n \tfprintf (dump_file, \"trying POST_REG\\n\");\n@@ -758,30 +758,30 @@ get_next_ref (int regno, basic_block bb, rtx *next_array)\n \n /* Reverse the operands in a mem insn.  */\n \n-static void \n+static void\n reverse_mem (void)\n {\n-  rtx tmp = mem_insn.reg1; \n+  rtx tmp = mem_insn.reg1;\n   mem_insn.reg1 = mem_insn.reg0;\n   mem_insn.reg0 = tmp;\n }\n \n \n /* Reverse the operands in a inc insn.  */\n \n-static void \n+static void\n reverse_inc (void)\n {\n-  rtx tmp = inc_insn.reg1; \n+  rtx tmp = inc_insn.reg1;\n   inc_insn.reg1 = inc_insn.reg0;\n   inc_insn.reg0 = tmp;\n }\n \n \n /* Return true if INSN is of a form \"a = b op c\" where a and b are\n    regs.  op is + if c is a reg and +|- if c is a const.  Fill in\n-   INC_INSN with what is found.  \n-   \n+   INC_INSN with what is found.\n+\n    This function is called in two contexts, if BEFORE_MEM is true,\n    this is called for each insn in the basic block.  If BEFORE_MEM is\n    false, it is called for the instruction in the block that uses the\n@@ -812,7 +812,7 @@ parse_add_or_inc (rtx insn, bool before_mem)\n   inc_insn.reg0 = XEXP (SET_SRC (pat), 0);\n   if (rtx_equal_p (inc_insn.reg_res, inc_insn.reg0))\n     inc_insn.form = before_mem ? FORM_PRE_INC : FORM_POST_INC;\n-  else \n+  else\n     inc_insn.form = before_mem ? FORM_PRE_ADD : FORM_POST_ADD;\n \n   if (CONST_INT_P (XEXP (SET_SRC (pat), 1)))\n@@ -838,8 +838,8 @@ parse_add_or_inc (rtx insn, bool before_mem)\n       /* Process a = b + c where c is a reg.  */\n       inc_insn.reg1 = XEXP (SET_SRC (pat), 1);\n       inc_insn.reg1_is_const = false;\n-      \n-      if (inc_insn.form == FORM_PRE_INC \n+\n+      if (inc_insn.form == FORM_PRE_INC\n \t  || inc_insn.form == FORM_POST_INC)\n \treturn true;\n       else if (rtx_equal_p (inc_insn.reg_res, inc_insn.reg1))\n@@ -850,7 +850,7 @@ parse_add_or_inc (rtx insn, bool before_mem)\n \t  inc_insn.form = before_mem ? FORM_PRE_INC : FORM_POST_INC;\n \t  return true;\n \t}\n-      else \n+      else\n \treturn true;\n     }\n \n@@ -862,7 +862,7 @@ parse_add_or_inc (rtx insn, bool before_mem)\n    ADDRESS_OF_X to see if any single one of them is compatible with\n    what has been found in inc_insn.\n \n-   -1 is returned for success.  0 is returned if nothing was found and \n+   -1 is returned for success.  0 is returned if nothing was found and\n    1 is returned for failure. */\n \n static int\n@@ -897,15 +897,15 @@ find_address (rtx *address_of_x)\n \t{\n \t  /* Match with *(reg0 + reg1) where reg1 is a const. */\n \t  HOST_WIDE_INT val = INTVAL (b);\n-\t  if (inc_insn.reg1_is_const \n+\t  if (inc_insn.reg1_is_const\n \t      && (inc_insn.reg1_val == val || inc_insn.reg1_val == -val))\n \t    {\n \t      mem_insn.reg1_val = val;\n \t      return -1;\n \t    }\n \t}\n-      else if (!inc_insn.reg1_is_const \n-\t       && rtx_equal_p (inc_insn.reg1, b)) \n+      else if (!inc_insn.reg1_is_const\n+\t       && rtx_equal_p (inc_insn.reg1, b))\n \t/* Match with *(reg0 + reg1). */\n \treturn -1;\n     }\n@@ -965,7 +965,7 @@ find_address (rtx *address_of_x)\n    add of the second register.  The FIRST_TRY parameter is used to\n    only allow the parameters to be reversed once.  */\n \n-static bool \n+static bool\n find_inc (bool first_try)\n {\n   rtx insn;\n@@ -977,16 +977,16 @@ find_inc (bool first_try)\n   if (count_occurrences (PATTERN (mem_insn.insn), mem_insn.reg0, 1) != 1)\n     {\n       if (dump_file)\n-\tfprintf (dump_file, \"mem count failure\\n\"); \n+\tfprintf (dump_file, \"mem count failure\\n\");\n       return false;\n     }\n \n   if (dump_file)\n     dump_mem_insn (dump_file);\n \n   /* Find the next use that is an inc.  */\n-  insn = get_next_ref (REGNO (mem_insn.reg0), \n-\t\t       BASIC_BLOCK (BLOCK_NUM (mem_insn.insn)), \n+  insn = get_next_ref (REGNO (mem_insn.reg0),\n+\t\t       BASIC_BLOCK (BLOCK_NUM (mem_insn.insn)),\n \t\t       reg_next_inc_use);\n   if (!insn)\n     return false;\n@@ -997,11 +997,11 @@ find_inc (bool first_try)\n     {\n       /* Next use was not an add.  Look for one extra case. It could be\n \t that we have:\n-\t \n+\n \t *(a + b)\n \t ...= a;\n \t ...= b + a\n-\t \n+\n \t if we reverse the operands in the mem ref we would\n \t find this.  Only try it once though.  */\n       if (first_try && !mem_insn.reg1_is_const)\n@@ -1013,13 +1013,13 @@ find_inc (bool first_try)\n \treturn false;\n     }\n \n-  /* Need to assure that none of the operands of the inc instruction are \n+  /* Need to assure that none of the operands of the inc instruction are\n      assigned to by the mem insn.  */\n   for (def_rec = DF_INSN_DEFS (mem_insn.insn); *def_rec; def_rec++)\n     {\n       df_ref def = *def_rec;\n       unsigned int regno = DF_REF_REGNO (def);\n-      if ((regno == REGNO (inc_insn.reg0)) \n+      if ((regno == REGNO (inc_insn.reg0))\n \t  || (regno == REGNO (inc_insn.reg_res)))\n \t{\n \t  if (dump_file)\n@@ -1041,26 +1041,26 @@ find_inc (bool first_try)\n     {\n       /* Make sure that there is no insn that assigns to inc_insn.res\n \t between the mem_insn and the inc_insn.  */\n-      rtx other_insn = get_next_ref (REGNO (inc_insn.reg_res), \n-\t\t\t\t     BASIC_BLOCK (BLOCK_NUM (mem_insn.insn)), \n+      rtx other_insn = get_next_ref (REGNO (inc_insn.reg_res),\n+\t\t\t\t     BASIC_BLOCK (BLOCK_NUM (mem_insn.insn)),\n \t\t\t\t     reg_next_def);\n       if (other_insn != inc_insn.insn)\n \t{\n \t  if (dump_file)\n-\t    fprintf (dump_file, \n+\t    fprintf (dump_file,\n \t\t     \"result of add is assigned to between mem and inc insns.\\n\");\n \t  return false;\n \t}\n \n-      other_insn = get_next_ref (REGNO (inc_insn.reg_res), \n-\t\t\t\t BASIC_BLOCK (BLOCK_NUM (mem_insn.insn)), \n+      other_insn = get_next_ref (REGNO (inc_insn.reg_res),\n+\t\t\t\t BASIC_BLOCK (BLOCK_NUM (mem_insn.insn)),\n \t\t\t\t reg_next_use);\n-      if (other_insn \n+      if (other_insn\n \t  && (other_insn != inc_insn.insn)\n \t  && (DF_INSN_LUID (inc_insn.insn) > DF_INSN_LUID (other_insn)))\n \t{\n \t  if (dump_file)\n-\t    fprintf (dump_file, \n+\t    fprintf (dump_file,\n \t\t     \"result of add is used between mem and inc insns.\\n\");\n \t  return false;\n \t}\n@@ -1087,7 +1087,7 @@ find_inc (bool first_try)\n \t      int luid = DF_INSN_LUID (inc_insn.insn);\n \t      if (inc_insn.form == FORM_POST_ADD)\n \t\t{\n-\t\t  /* The trick is that we are not going to increment r0, \n+\t\t  /* The trick is that we are not going to increment r0,\n \t\t     we are going to increment the result of the add insn.\n \t\t     For this trick to be correct, the result reg of\n \t\t     the inc must be a valid addressing reg.  */\n@@ -1102,16 +1102,16 @@ find_inc (bool first_try)\n \n \t\t  /* We also need to make sure that the next use of\n \t\t     inc result is after the inc.  */\n-\t\t  other_insn \n+\t\t  other_insn\n \t\t    = get_next_ref (REGNO (inc_insn.reg1), bb, reg_next_use);\n \t\t  if (other_insn && luid > DF_INSN_LUID (other_insn))\n \t\t    return false;\n \n \t\t  if (!rtx_equal_p (mem_insn.reg0, inc_insn.reg0))\n-\t\t    reverse_inc (); \n+\t\t    reverse_inc ();\n \t\t}\n \n-\t      other_insn \n+\t      other_insn\n \t\t= get_next_ref (REGNO (inc_insn.reg1), bb, reg_next_def);\n \t      if (other_insn && luid > DF_INSN_LUID (other_insn))\n \t\treturn false;\n@@ -1130,14 +1130,14 @@ find_inc (bool first_try)\n \t need to treat it as if it was *(b + a).  It may also be that\n \t the add is of the form a + c where c does not match b and\n \t then we just abandon this.  */\n-      \n+\n       int luid = DF_INSN_LUID (inc_insn.insn);\n       rtx other_insn;\n-      \n+\n       /* Make sure this reg appears only once in this insn.  */\n       if (count_occurrences (PATTERN (mem_insn.insn), mem_insn.reg1, 1) != 1)\n \treturn false;\n-      \n+\n       if (inc_insn.form == FORM_POST_ADD)\n \t{\n \t  /* For this trick to be correct, the result reg of the inc\n@@ -1167,7 +1167,7 @@ find_inc (bool first_try)\n \n \t      /* Need to check that there are no assignments to b\n \t\t before the add insn.  */\n-\t      other_insn \n+\t      other_insn\n \t\t= get_next_ref (REGNO (inc_insn.reg1), bb, reg_next_def);\n \t      if (other_insn && luid > DF_INSN_LUID (other_insn))\n \t\treturn false;\n@@ -1188,28 +1188,28 @@ find_inc (bool first_try)\n \t\t}\n \t      /* To have gotten here know that.\n \t       *(b + a)\n-\t       \n+\n \t       ... = (b + a)\n-\t       \n+\n \t       We also know that the lhs of the inc is not b or a.  We\n \t       need to make sure that there are no assignments to b\n-\t       between the mem ref and the inc.  */\t \n-\t      \n-\t      other_insn \n+\t       between the mem ref and the inc.  */\n+\n+\t      other_insn\n \t\t= get_next_ref (REGNO (inc_insn.reg0), bb, reg_next_def);\n \t      if (other_insn && luid > DF_INSN_LUID (other_insn))\n \t\treturn false;\n \t    }\n \n \t  /* Need to check that the next use of the add result is later than\n \t     add insn since this will be the reg incremented.  */\n-\t  other_insn \n+\t  other_insn\n \t    = get_next_ref (REGNO (inc_insn.reg_res), bb, reg_next_use);\n \t  if (other_insn && luid > DF_INSN_LUID (other_insn))\n \t    return false;\n \t}\n       else /* FORM_POST_INC.  There is less to check here because we\n-\t      know that operands must line up.  */ \n+\t      know that operands must line up.  */\n \t{\n \t  if (!rtx_equal_p (mem_insn.reg1, inc_insn.reg1))\n \t    /* See comment above on find_inc (false) call.  */\n@@ -1219,19 +1219,19 @@ find_inc (bool first_try)\n \t\t  reverse_mem ();\n \t\t  return find_inc (false);\n \t\t}\n-\t      else \n+\t      else\n \t\treturn false;\n \t    }\n-      \n+\n \t  /* To have gotten here know that.\n \t   *(a + b)\n-\t   \n+\n \t   ... = (a + b)\n-\t   \n+\n \t   We also know that the lhs of the inc is not b.  We need to make\n \t   sure that there are no assignments to b between the mem ref and\n \t   the inc.  */\n-\t  other_insn \n+\t  other_insn\n \t    = get_next_ref (REGNO (inc_insn.reg1), bb, reg_next_def);\n \t  if (other_insn && luid > DF_INSN_LUID (other_insn))\n \t    return false;\n@@ -1240,7 +1240,7 @@ find_inc (bool first_try)\n \n   if (inc_insn.form == FORM_POST_INC)\n     {\n-      other_insn \n+      other_insn\n \t= get_next_ref (REGNO (inc_insn.reg0), bb, reg_next_use);\n       /* When we found inc_insn, we were looking for the\n \t next add or inc, not the next insn that used the\n@@ -1348,10 +1348,10 @@ merge_in_block (int max_reg, basic_block bb)\n       bool insn_is_add_or_inc = true;\n \n       if (!NONDEBUG_INSN_P (insn))\n-\tcontinue;\t\n+\tcontinue;\n \n       /* This continue is deliberate.  We do not want the uses of the\n-\t jump put into reg_next_use because it is not considered safe to \n+\t jump put into reg_next_use because it is not considered safe to\n \t combine a preincrement with a jump.  */\n       if (JUMP_P (insn))\n \tcontinue;\n@@ -1381,22 +1381,22 @@ merge_in_block (int max_reg, basic_block bb)\n \t\t\t clear of c because the inc insn is going to move\n \t\t\t into the mem_insn.insn.  */\n \t\t      int luid = DF_INSN_LUID (mem_insn.insn);\n-\t\t      rtx other_insn \n+\t\t      rtx other_insn\n \t\t\t= get_next_ref (REGNO (inc_insn.reg1), bb, reg_next_use);\n-\t\t      \n+\n \t\t      if (other_insn && luid > DF_INSN_LUID (other_insn))\n \t\t\tok = false;\n-\t\t      \n-\t\t      other_insn \n+\n+\t\t      other_insn\n \t\t\t= get_next_ref (REGNO (inc_insn.reg1), bb, reg_next_def);\n-\t\t      \n+\n \t\t      if (other_insn && luid > DF_INSN_LUID (other_insn))\n \t\t\tok = false;\n \t\t    }\n-\t\t  \n+\n \t\t  if (dump_file)\n \t\t    dump_inc_insn (dump_file);\n-\t\t  \n+\n \t\t  if (ok && find_address (&PATTERN (mem_insn.insn)) == -1)\n \t\t    {\n \t\t      if (dump_file)\n@@ -1417,7 +1417,7 @@ merge_in_block (int max_reg, basic_block bb)\n \t  if (find_mem (&PATTERN (insn)))\n \t    success_in_block++;\n \t}\n-      \n+\n       /* If the inc insn was merged with a mem, the inc insn is gone\n \t and there is noting to update.  */\n       if (DF_INSN_UID_GET (uid))\n@@ -1432,7 +1432,7 @@ merge_in_block (int max_reg, basic_block bb)\n \t      reg_next_inc_use[DF_REF_REGNO (def)] = NULL;\n \t      reg_next_def[DF_REF_REGNO (def)] = insn;\n \t    }\n-\t  \n+\n \t  for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n \t    {\n \t      df_ref use = *use_rec;\n@@ -1441,7 +1441,7 @@ merge_in_block (int max_reg, basic_block bb)\n \t\treg_next_inc_use[DF_REF_REGNO (use)] = insn;\n \t      else\n \t\treg_next_inc_use[DF_REF_REGNO (use)] = NULL;\n-\t    }  \n+\t    }\n \t}\n       else if (dump_file)\n \tfprintf (dump_file, \"skipping update of deleted insn %d\\n\", uid);\n@@ -1464,7 +1464,7 @@ merge_in_block (int max_reg, basic_block bb)\n \n #endif\n \n-static unsigned int \n+static unsigned int\n rest_of_handle_auto_inc_dec (void)\n {\n #ifdef AUTO_INC_DEC\n@@ -1523,7 +1523,7 @@ struct rtl_opt_pass pass_inc_dec =\n   0,                                    /* properties_provided */\n   0,                                    /* properties_destroyed */\n   0,                                    /* todo_flags_start */\n-  TODO_dump_func | \n+  TODO_dump_func |\n   TODO_df_finish,                       /* todo_flags_finish */\n  }\n };"}, {"sha": "3d9b6727cf9b8a1917b228a3ab20e82c515d3fab", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -463,7 +463,7 @@ struct GTY(()) control_flow_graph {\n   for ((INSN) = BB_HEAD (BB), (CURR) = (INSN) ? NEXT_INSN ((INSN)): NULL;\t\\\n        (INSN) && (INSN) != NEXT_INSN (BB_END (BB));\t\\\n        (INSN) = (CURR), (CURR) = (INSN) ? NEXT_INSN ((INSN)) : NULL)\n-       \n+\n #define FOR_BB_INSNS_REVERSE(BB, INSN)\t\t\\\n   for ((INSN) = BB_END (BB);\t\t\t\\\n        (INSN) && (INSN) != PREV_INSN (BB_HEAD (BB));\t\\"}, {"sha": "561d7d0044435bdee903f8359bf9fcf271b2c53a", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -1374,7 +1374,7 @@ fix_up_fall_thru_edges (void)\n         edge_iterator ei;\n \n         /* Find EDGE_CAN_FALLTHRU edge.  */\n-        FOR_EACH_EDGE (e, ei, cur_bb->succs) \n+        FOR_EACH_EDGE (e, ei, cur_bb->succs)\n           if (e->flags & EDGE_CAN_FALLTHRU)\n           {\n             fall_thru = e;\n@@ -1438,7 +1438,7 @@ fix_up_fall_thru_edges (void)\n \t\t  /* This is the case where both edges out of the basic\n \t\t     block are crossing edges. Here we will fix up the\n \t\t     fall through edge. The jump edge will be taken care\n-\t\t     of later.  The EDGE_CROSSING flag of fall_thru edge \n+\t\t     of later.  The EDGE_CROSSING flag of fall_thru edge\n                      is unset before the call to force_nonfallthru\n                      function because if a new basic-block is created\n                      this edge remains in the current section boundary"}, {"sha": "5e3d12c359a047d239e605072756adff181d5468", "filename": "gcc/bt-load.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -1417,7 +1417,7 @@ migrate_btr_defs (enum reg_class btr_class, int allow_callee_save)\n   CLEAR_HARD_REG_SET (all_btrs);\n   for (first_btr = -1, reg = 0; reg < FIRST_PSEUDO_REGISTER; reg++)\n     if (TEST_HARD_REG_BIT (reg_class_contents[(int) btr_class], reg)\n-\t&& (allow_callee_save || call_used_regs[reg] \n+\t&& (allow_callee_save || call_used_regs[reg]\n \t    || df_regs_ever_live_p (reg)))\n       {\n \tSET_HARD_REG_BIT (all_btrs, reg);"}, {"sha": "cfdf5d5c535fd3d0aea8de3c12ca4c31b1a93070", "filename": "gcc/builtins.c", "status": "modified", "additions": 131, "deletions": 131, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -118,7 +118,7 @@ static rtx expand_builtin_strncmp (tree, rtx, enum machine_mode);\n static rtx builtin_memcpy_read_str (void *, HOST_WIDE_INT, enum machine_mode);\n static rtx expand_builtin_memcpy (tree, rtx);\n static rtx expand_builtin_mempcpy (tree, rtx, enum machine_mode);\n-static rtx expand_builtin_mempcpy_args (tree, tree, tree, rtx, \n+static rtx expand_builtin_mempcpy_args (tree, tree, tree, rtx,\n \t\t\t\t\tenum machine_mode, int);\n static rtx expand_builtin_strcpy (tree, rtx);\n static rtx expand_builtin_strcpy_args (tree, tree, rtx);\n@@ -280,7 +280,7 @@ get_object_alignment (tree exp, unsigned int align, unsigned int max_align)\n    {\n       HOST_WIDE_INT bitsize, bitpos;\n       tree offset;\n-      enum machine_mode mode; \n+      enum machine_mode mode;\n       int unsignedp, volatilep;\n \n       exp = get_inner_reference (exp, &bitsize, &bitpos, &offset,\n@@ -829,7 +829,7 @@ expand_builtin_longjmp (rtx buf_addr, rtx value)\n   rtx fp, lab, stack, insn, last;\n   enum machine_mode sa_mode = STACK_SAVEAREA_MODE (SAVE_NONLOCAL);\n \n-  /* DRAP is needed for stack realign if longjmp is expanded to current \n+  /* DRAP is needed for stack realign if longjmp is expanded to current\n      function  */\n   if (SUPPORTS_STACK_ALIGNMENT)\n     crtl->need_drap = true;\n@@ -2430,7 +2430,7 @@ expand_builtin_cexpi (tree exp, rtx target, rtx subtarget)\n \tfn = built_in_decls[BUILT_IN_SINCOSL];\n       else\n \tgcc_unreachable ();\n- \n+\n       op1 = assign_temp (TREE_TYPE (arg), 0, 1, 1);\n       op2 = assign_temp (TREE_TYPE (arg), 0, 1, 1);\n       op1a = copy_to_mode_reg (Pmode, XEXP (op1, 0));\n@@ -2481,7 +2481,7 @@ expand_builtin_cexpi (tree exp, rtx target, rtx subtarget)\n \n       /* Make sure not to fold the cexp call again.  */\n       call = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (fn)), fn);\n-      return expand_expr (build_call_nary (ctype, call, 1, narg), \n+      return expand_expr (build_call_nary (ctype, call, 1, narg),\n \t\t\t  target, VOIDmode, EXPAND_NORMAL);\n     }\n \n@@ -2662,7 +2662,7 @@ expand_builtin_int_roundingfn_2 (tree exp, rtx target)\n \n   if (!validate_arglist (exp, REAL_TYPE, VOID_TYPE))\n      gcc_unreachable ();\n- \n+\n   arg = CALL_EXPR_ARG (exp, 0);\n \n   switch (DECL_FUNCTION_CODE (fndecl))\n@@ -3110,7 +3110,7 @@ expand_builtin_powi (tree exp, rtx target, rtx subtarget)\n   return target;\n }\n \n-/* Expand expression EXP which is a call to the strlen builtin.  Return \n+/* Expand expression EXP which is a call to the strlen builtin.  Return\n    NULL_RTX if we failed the caller should emit a normal call, otherwise\n    try to get the result in TARGET, if convenient.  */\n \n@@ -3268,7 +3268,7 @@ expand_builtin_memcpy (tree exp, rtx target)\n \t operation in-line.  */\n       if (src_align == 0)\n \treturn NULL_RTX;\n- \n+\n       if (currently_expanding_gimple_stmt)\n         stringop_block_profile (currently_expanding_gimple_stmt,\n \t\t\t\t&expected_align, &expected_size);\n@@ -3485,8 +3485,8 @@ expand_movstr (tree dest, tree src, rtx target, int endp)\n   return target;\n }\n \n-/* Expand expression EXP, which is a call to the strcpy builtin.  Return \n-   NULL_RTX if we failed the caller should emit a normal call, otherwise \n+/* Expand expression EXP, which is a call to the strcpy builtin.  Return\n+   NULL_RTX if we failed the caller should emit a normal call, otherwise\n    try to get the result in TARGET, if convenient (and in mode MODE if that's\n    convenient).  */\n \n@@ -3606,7 +3606,7 @@ builtin_strncpy_read_str (void *data, HOST_WIDE_INT offset,\n   return c_readstr (str + offset, mode);\n }\n \n-/* Expand expression EXP, which is a call to the strncpy builtin.  Return \n+/* Expand expression EXP, which is a call to the strncpy builtin.  Return\n    NULL_RTX if we failed the caller should emit a normal call.  */\n \n static rtx\n@@ -3699,8 +3699,8 @@ builtin_memset_gen_str (void *data, HOST_WIDE_INT offset ATTRIBUTE_UNUSED,\n   return force_reg (mode, target);\n }\n \n-/* Expand expression EXP, which is a call to the memset builtin.  Return \n-   NULL_RTX if we failed the caller should emit a normal call, otherwise \n+/* Expand expression EXP, which is a call to the memset builtin.  Return\n+   NULL_RTX if we failed the caller should emit a normal call, otherwise\n    try to get the result in TARGET, if convenient (and in mode MODE if that's\n    convenient).  */\n \n@@ -3793,7 +3793,7 @@ expand_builtin_memset_args (tree dest, tree val, tree len,\n \t\t\t\t\tdest_align, expected_align,\n \t\t\t\t\texpected_size))\n \tgoto do_libcall;\n-      \n+\n       dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n       dest_mem = convert_memory_address (ptr_mode, dest_mem);\n       return dest_mem;\n@@ -3814,7 +3814,7 @@ expand_builtin_memset_args (tree dest, tree val, tree len,\n \t\t\t\t\tdest_align, expected_align,\n \t\t\t\t\texpected_size))\n \tgoto do_libcall;\n-      \n+\n       dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n       dest_mem = convert_memory_address (ptr_mode, dest_mem);\n       return dest_mem;\n@@ -3848,7 +3848,7 @@ expand_builtin_memset_args (tree dest, tree val, tree len,\n   return expand_call (fn, target, target == const0_rtx);\n }\n \n-/* Expand expression EXP, which is a call to the bzero builtin.  Return \n+/* Expand expression EXP, which is a call to the bzero builtin.  Return\n    NULL_RTX if we failed the caller should emit a normal call.  */\n \n static rtx\n@@ -4122,7 +4122,7 @@ expand_builtin_strcmp (tree exp, ATTRIBUTE_UNUSED rtx target)\n   return NULL_RTX;\n }\n \n-/* Expand expression EXP, which is a call to the strncmp builtin. Return \n+/* Expand expression EXP, which is a call to the strncmp builtin. Return\n    NULL_RTX if we failed the caller should emit a normal call, otherwise try to get\n    the result in TARGET, if convenient.  */\n \n@@ -4805,7 +4805,7 @@ expand_builtin_alloca (tree exp, rtx target)\n   rtx result;\n \n   /* Emit normal call if marked not-inlineable.  */\n-  if (CALL_CANNOT_INLINE_P (exp)) \n+  if (CALL_CANNOT_INLINE_P (exp))\n     return NULL_RTX;\n \n   if (!validate_arglist (exp, INTEGER_TYPE, VOID_TYPE))\n@@ -4871,7 +4871,7 @@ expand_builtin_unop (enum machine_mode target_mode, tree exp, rtx target,\n   return convert_to_mode (target_mode, target, 0);\n }\n \n-/* Expand a call to __builtin_expect.  We just return our argument \n+/* Expand a call to __builtin_expect.  We just return our argument\n    as the builtin_expect semantic should've been already executed by\n    tree branch prediction pass. */\n \n@@ -5613,7 +5613,7 @@ expand_builtin_fork_or_exec (tree fn, tree exp, rtx target, int ignore)\n   call = rewrite_call_expr (EXPR_LOCATION (exp), exp, 0, decl, 0);\n   return expand_call (call, target, ignore);\n  }\n-  \n+\n \n \f\n /* Reconstitute a mode for a __sync intrinsic operation.  Since the type of\n@@ -5774,7 +5774,7 @@ expand_builtin_compare_and_swap (enum machine_mode mode, tree exp,\n /* Expand the __sync_lock_test_and_set intrinsic.  Note that the most\n    general form is actually an atomic exchange, and some targets only\n    support a reduced form with the second argument being a constant 1.\n-   EXP is the CALL_EXPR; TARGET is an optional place for us to store \n+   EXP is the CALL_EXPR; TARGET is an optional place for us to store\n    the results.  */\n \n static rtx\n@@ -6747,7 +6747,7 @@ builtin_mathfn_code (const_tree t)\n \n       if (! more_const_call_expr_args_p (&iter))\n \treturn END_BUILTINS;\n-      \n+\n       arg = next_const_call_expr_arg (&iter);\n       argtype = TREE_TYPE (arg);\n \n@@ -7188,12 +7188,12 @@ fold_builtin_cabs (location_t loc, tree arg, tree type, tree fndecl)\n       && (res = do_mpfr_arg2 (TREE_REALPART (arg), TREE_IMAGPART (arg),\n \t\t\t      type, mpfr_hypot)))\n     return res;\n-  \n+\n   if (TREE_CODE (arg) == COMPLEX_EXPR)\n     {\n       tree real = TREE_OPERAND (arg, 0);\n       tree imag = TREE_OPERAND (arg, 1);\n-      \n+\n       /* If either part is zero, cabs is fabs of the other.  */\n       if (real_zerop (real))\n \treturn fold_build1_loc (loc, ABS_EXPR, type, imag);\n@@ -7265,7 +7265,7 @@ fold_builtin_sqrt (location_t loc, tree arg, tree type)\n   /* Calculate the result when the argument is a constant.  */\n   if ((res = do_mpfr_arg1 (arg, type, mpfr_sqrt, &dconst0, NULL, true)))\n     return res;\n-  \n+\n   /* Optimize sqrt(expN(x)) = expN(x*0.5).  */\n   fcode = builtin_mathfn_code (arg);\n   if (flag_unsafe_math_optimizations && BUILTIN_EXPONENT_P (fcode))\n@@ -7394,7 +7394,7 @@ fold_builtin_cbrt (location_t loc, tree arg, tree type)\n \t}\n \n       /* Optimize cbrt(pow(x,y)) -> pow(x,y/3) iff x is nonnegative.  */\n-      if (fcode == BUILT_IN_POW \n+      if (fcode == BUILT_IN_POW\n           || fcode == BUILT_IN_POWF\n \t  || fcode == BUILT_IN_POWL)\n \t{\n@@ -7430,7 +7430,7 @@ fold_builtin_cos (location_t loc,\n   /* Calculate the result when the argument is a constant.  */\n   if ((res = do_mpfr_arg1 (arg, type, mpfr_cos, NULL, NULL, 0)))\n     return res;\n-  \n+\n   /* Optimize cos(-x) into cos (x).  */\n   if ((narg = fold_strip_sign_ops (arg)))\n     return build_call_expr_loc (loc, fndecl, 1, narg);\n@@ -7451,12 +7451,12 @@ fold_builtin_cosh (location_t loc, tree arg, tree type, tree fndecl)\n       /* Calculate the result when the argument is a constant.  */\n       if ((res = do_mpfr_arg1 (arg, type, mpfr_cosh, NULL, NULL, 0)))\n \treturn res;\n-  \n+\n       /* Optimize cosh(-x) into cosh (x).  */\n       if ((narg = fold_strip_sign_ops (arg)))\n \treturn build_call_expr_loc (loc, fndecl, 1, narg);\n     }\n-  \n+\n   return NULL_TREE;\n }\n \n@@ -7479,7 +7479,7 @@ fold_builtin_ccos (location_t loc,\n       if ((tmp = do_mpc_arg1 (arg, type, (hyper ? mpc_cosh : mpc_cos))))\n \treturn tmp;\n #endif\n-  \n+\n       /* Optimize fn(-x) into fn(x).  */\n       if ((tmp = fold_strip_sign_ops (arg)))\n \treturn build_call_expr_loc (loc, fndecl, 1, tmp);\n@@ -7503,7 +7503,7 @@ fold_builtin_tan (tree arg, tree type)\n   /* Calculate the result when the argument is a constant.  */\n   if ((res = do_mpfr_arg1 (arg, type, mpfr_tan, NULL, NULL, 0)))\n     return res;\n-  \n+\n   /* Optimize tan(atan(x)) = x.  */\n   fcode = builtin_mathfn_code (arg);\n   if (flag_unsafe_math_optimizations\n@@ -7576,7 +7576,7 @@ fold_builtin_cexp (location_t loc, tree arg0, tree type)\n   if ((res = do_mpc_arg1 (arg0, type, mpc_exp)))\n     return res;\n #endif\n-  \n+\n   rtype = TREE_TYPE (TREE_TYPE (arg0));\n \n   /* In case we can figure out the real part of arg0 and it is constant zero\n@@ -8001,7 +8001,7 @@ fold_builtin_logarithm (location_t loc, tree fndecl, tree arg,\n \t  {\n \t  CASE_FLT_FN (BUILT_IN_EXP):\n \t    /* Prepare to do logN(exp(exponent) -> exponent*logN(e).  */\n-\t    x = build_real (type, real_value_truncate (TYPE_MODE (type), \n+\t    x = build_real (type, real_value_truncate (TYPE_MODE (type),\n                                                        dconst_e ()));\n \t    exponent = CALL_EXPR_ARG (arg, 0);\n \t    break;\n@@ -8068,23 +8068,23 @@ fold_builtin_hypot (location_t loc, tree fndecl,\n   /* Calculate the result when the argument is a constant.  */\n   if ((res = do_mpfr_arg2 (arg0, arg1, type, mpfr_hypot)))\n     return res;\n-  \n+\n   /* If either argument to hypot has a negate or abs, strip that off.\n      E.g. hypot(-x,fabs(y)) -> hypot(x,y).  */\n   narg0 = fold_strip_sign_ops (arg0);\n   narg1 = fold_strip_sign_ops (arg1);\n   if (narg0 || narg1)\n     {\n-      return build_call_expr_loc (loc, fndecl, 2, narg0 ? narg0 : arg0, \n+      return build_call_expr_loc (loc, fndecl, 2, narg0 ? narg0 : arg0,\n \t\t\t      narg1 ? narg1 : arg1);\n     }\n-  \n+\n   /* If either argument is zero, hypot is fabs of the other.  */\n   if (real_zerop (arg0))\n     return fold_build1_loc (loc, ABS_EXPR, type, arg1);\n   else if (real_zerop (arg1))\n     return fold_build1_loc (loc, ABS_EXPR, type, arg0);\n-      \n+\n   /* hypot(x,x) -> fabs(x)*sqrt(2).  */\n   if (flag_unsafe_math_optimizations\n       && operand_equal_p (arg0, arg1, OEP_PURE_SAME))\n@@ -8310,7 +8310,7 @@ fold_builtin_exponent (location_t loc, tree fndecl, tree arg,\n     {\n       tree type = TREE_TYPE (TREE_TYPE (fndecl));\n       tree res;\n-      \n+\n       /* Calculate the result when the argument is a constant.  */\n       if ((res = do_mpfr_arg1 (arg, type, func, NULL, NULL, 0)))\n \treturn res;\n@@ -8490,7 +8490,7 @@ fold_builtin_memory_op (location_t loc, tree dest, tree src,\n \t  src_align = get_pointer_alignment (src, BIGGEST_ALIGNMENT);\n \t  dest_align = get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n \n-\t  /* Both DEST and SRC must be pointer types. \n+\t  /* Both DEST and SRC must be pointer types.\n \t     ??? This is what old code did.  Is the testing for pointer types\n \t     really mandatory?\n \n@@ -9238,7 +9238,7 @@ fold_builtin_toascii (location_t loc, tree arg)\n {\n   if (!validate_arg (arg, INTEGER_TYPE))\n     return NULL_TREE;\n-      \n+\n   /* Transform toascii(c) -> (c & 0x7f).  */\n   return fold_build2_loc (loc, BIT_AND_EXPR, integer_type_node, arg,\n \t\t      build_int_cst (NULL_TREE, 0x7f));\n@@ -9329,7 +9329,7 @@ fold_builtin_fmin_fmax (location_t loc, tree arg0, tree arg1,\n       /* Transform fmin/fmax(x,x) -> x.  */\n       if (operand_equal_p (arg0, arg1, OEP_PURE_SAME))\n \treturn omit_one_operand_loc (loc, type, arg0, arg1);\n-      \n+\n       /* Convert fmin/fmax to MIN_EXPR/MAX_EXPR.  C99 requires these\n \t functions to return the numeric arg if the other one is NaN.\n \t These tree codes don't honor that, so only transform if\n@@ -9352,7 +9352,7 @@ fold_builtin_carg (location_t loc, tree arg, tree type)\n       && TREE_CODE (TREE_TYPE (TREE_TYPE (arg))) == REAL_TYPE)\n     {\n       tree atan2_fn = mathfn_built_in (type, BUILT_IN_ATAN2);\n-      \n+\n       if (atan2_fn)\n         {\n   \t  tree new_arg = builtin_save_expr (arg);\n@@ -9361,7 +9361,7 @@ fold_builtin_carg (location_t loc, tree arg, tree type)\n \t  return build_call_expr_loc (loc, atan2_fn, 2, i_arg, r_arg);\n \t}\n     }\n-  \n+\n   return NULL_TREE;\n }\n \n@@ -9372,13 +9372,13 @@ fold_builtin_logb (location_t loc, tree arg, tree rettype)\n {\n   if (! validate_arg (arg, REAL_TYPE))\n     return NULL_TREE;\n-  \n+\n   STRIP_NOPS (arg);\n-      \n+\n   if (TREE_CODE (arg) == REAL_CST && ! TREE_OVERFLOW (arg))\n     {\n       const REAL_VALUE_TYPE *const value = TREE_REAL_CST_PTR (arg);\n-\t  \n+\n       switch (value->cl)\n       {\n       case rvc_nan:\n@@ -9403,7 +9403,7 @@ fold_builtin_logb (location_t loc, tree arg, tree rettype)\n \tbreak;\n       }\n     }\n-  \n+\n   return NULL_TREE;\n }\n \n@@ -9414,13 +9414,13 @@ fold_builtin_significand (location_t loc, tree arg, tree rettype)\n {\n   if (! validate_arg (arg, REAL_TYPE))\n     return NULL_TREE;\n-  \n+\n   STRIP_NOPS (arg);\n-      \n+\n   if (TREE_CODE (arg) == REAL_CST && ! TREE_OVERFLOW (arg))\n     {\n       const REAL_VALUE_TYPE *const value = TREE_REAL_CST_PTR (arg);\n-\t  \n+\n       switch (value->cl)\n       {\n       case rvc_zero:\n@@ -9442,7 +9442,7 @@ fold_builtin_significand (location_t loc, tree arg, tree rettype)\n \tbreak;\n       }\n     }\n-  \n+\n   return NULL_TREE;\n }\n \n@@ -9453,20 +9453,20 @@ fold_builtin_frexp (location_t loc, tree arg0, tree arg1, tree rettype)\n {\n   if (! validate_arg (arg0, REAL_TYPE) || ! validate_arg (arg1, POINTER_TYPE))\n     return NULL_TREE;\n-  \n+\n   STRIP_NOPS (arg0);\n-      \n+\n   if (!(TREE_CODE (arg0) == REAL_CST && ! TREE_OVERFLOW (arg0)))\n     return NULL_TREE;\n-  \n+\n   arg1 = build_fold_indirect_ref_loc (loc, arg1);\n \n   /* Proceed if a valid pointer type was passed in.  */\n   if (TYPE_MAIN_VARIANT (TREE_TYPE (arg1)) == integer_type_node)\n     {\n       const REAL_VALUE_TYPE *const value = TREE_REAL_CST_PTR (arg0);\n       tree frac, exp;\n-\t  \n+\n       switch (value->cl)\n       {\n       case rvc_zero:\n@@ -9492,7 +9492,7 @@ fold_builtin_frexp (location_t loc, tree arg0, tree arg1, tree rettype)\n       default:\n \tgcc_unreachable ();\n       }\n-\t\t\n+\n       /* Create the COMPOUND_EXPR (*arg1 = trunc, frac). */\n       arg1 = fold_build2_loc (loc, MODIFY_EXPR, rettype, arg1, exp);\n       TREE_SIDE_EFFECTS (arg1) = 1;\n@@ -9520,7 +9520,7 @@ fold_builtin_load_exponent (location_t loc, tree arg0, tree arg1,\n \t  || (TREE_CODE (arg0) == REAL_CST\n \t      && !real_isfinite (&TREE_REAL_CST (arg0))))\n \treturn omit_one_operand_loc (loc, type, arg0, arg1);\n-      \n+\n       /* If both arguments are constant, then try to evaluate it.  */\n       if ((ldexp || REAL_MODE_FORMAT (TYPE_MODE (type))->b == 2)\n \t  && TREE_CODE (arg0) == REAL_CST && !TREE_OVERFLOW (arg0)\n@@ -9529,28 +9529,28 @@ fold_builtin_load_exponent (location_t loc, tree arg0, tree arg1,\n \t  /* Bound the maximum adjustment to twice the range of the\n \t     mode's valid exponents.  Use abs to ensure the range is\n \t     positive as a sanity check.  */\n-\t  const long max_exp_adj = 2 * \n+\t  const long max_exp_adj = 2 *\n \t    labs (REAL_MODE_FORMAT (TYPE_MODE (type))->emax\n \t\t - REAL_MODE_FORMAT (TYPE_MODE (type))->emin);\n \n \t  /* Get the user-requested adjustment.  */\n \t  const HOST_WIDE_INT req_exp_adj = tree_low_cst (arg1, 0);\n-\t  \n+\n \t  /* The requested adjustment must be inside this range.  This\n \t     is a preliminary cap to avoid things like overflow, we\n \t     may still fail to compute the result for other reasons.  */\n \t  if (-max_exp_adj < req_exp_adj && req_exp_adj < max_exp_adj)\n \t    {\n \t      REAL_VALUE_TYPE initial_result;\n-\t      \n+\n \t      real_ldexp (&initial_result, &TREE_REAL_CST (arg0), req_exp_adj);\n \n \t      /* Ensure we didn't overflow.  */\n \t      if (! real_isinf (&initial_result))\n \t        {\n \t\t  const REAL_VALUE_TYPE trunc_result\n \t\t    = real_value_truncate (TYPE_MODE (type), initial_result);\n-\t\t  \n+\n \t\t  /* Only proceed if the target mode can hold the\n \t\t     resulting value.  */\n \t\t  if (REAL_VALUES_EQUAL (initial_result, trunc_result))\n@@ -9570,12 +9570,12 @@ fold_builtin_modf (location_t loc, tree arg0, tree arg1, tree rettype)\n {\n   if (! validate_arg (arg0, REAL_TYPE) || ! validate_arg (arg1, POINTER_TYPE))\n     return NULL_TREE;\n-  \n+\n   STRIP_NOPS (arg0);\n-      \n+\n   if (!(TREE_CODE (arg0) == REAL_CST && ! TREE_OVERFLOW (arg0)))\n     return NULL_TREE;\n-  \n+\n   arg1 = build_fold_indirect_ref_loc (loc, arg1);\n \n   /* Proceed if a valid pointer type was passed in.  */\n@@ -9607,15 +9607,15 @@ fold_builtin_modf (location_t loc, tree arg0, tree arg1, tree rettype)\n \t  frac.sign = value->sign;\n \tbreak;\n       }\n-\t      \n+\n       /* Create the COMPOUND_EXPR (*arg1 = trunc, frac). */\n       arg1 = fold_build2_loc (loc, MODIFY_EXPR, rettype, arg1,\n \t\t\t  build_real (rettype, trunc));\n       TREE_SIDE_EFFECTS (arg1) = 1;\n       return fold_build2_loc (loc, COMPOUND_EXPR, rettype, arg1,\n \t\t\t  build_real (rettype, frac));\n     }\n-  \n+\n   return NULL_TREE;\n }\n \n@@ -9760,7 +9760,7 @@ fold_builtin_classify (location_t loc, tree fndecl, tree arg, int builtin_index)\n \t\t\t\t\tsignbit_call, integer_zero_node);\n \t    isinf_call = fold_build2_loc (loc, NE_EXPR, integer_type_node,\n \t\t\t\t      isinf_call, integer_zero_node);\n-\t    \n+\n \t    tmp = fold_build3_loc (loc, COND_EXPR, integer_type_node, signbit_call,\n \t\t\t       integer_minus_one_node, integer_one_node);\n \t    tmp = fold_build3_loc (loc, COND_EXPR, integer_type_node,\n@@ -9818,13 +9818,13 @@ fold_builtin_fpclassify (location_t loc, tree exp)\n   enum machine_mode mode;\n   REAL_VALUE_TYPE r;\n   char buf[128];\n-  \n+\n   /* Verify the required arguments in the original call.  */\n   if (!validate_arglist (exp, INTEGER_TYPE, INTEGER_TYPE,\n \t\t\t INTEGER_TYPE, INTEGER_TYPE,\n \t\t\t INTEGER_TYPE, REAL_TYPE, VOID_TYPE))\n     return NULL_TREE;\n-  \n+\n   fp_nan = CALL_EXPR_ARG (exp, 0);\n   fp_infinite = CALL_EXPR_ARG (exp, 1);\n   fp_normal = CALL_EXPR_ARG (exp, 2);\n@@ -9835,12 +9835,12 @@ fold_builtin_fpclassify (location_t loc, tree exp)\n   mode = TYPE_MODE (type);\n   arg = builtin_save_expr (fold_build1_loc (loc, ABS_EXPR, type, arg));\n \n-  /* fpclassify(x) -> \n+  /* fpclassify(x) ->\n        isnan(x) ? FP_NAN :\n          (fabs(x) == Inf ? FP_INFINITE :\n \t   (fabs(x) >= DBL_MIN ? FP_NORMAL :\n \t     (x == 0 ? FP_ZERO : FP_SUBNORMAL))).  */\n-  \n+\n   tmp = fold_build2_loc (loc, EQ_EXPR, integer_type_node, arg,\n \t\t     build_real (type, dconst0));\n   res = fold_build3_loc (loc, COND_EXPR, integer_type_node,\n@@ -9851,7 +9851,7 @@ fold_builtin_fpclassify (location_t loc, tree exp)\n   tmp = fold_build2_loc (loc, GE_EXPR, integer_type_node,\n \t\t     arg, build_real (type, r));\n   res = fold_build3_loc (loc, COND_EXPR, integer_type_node, tmp, fp_normal, res);\n-  \n+\n   if (HONOR_INFINITIES (mode))\n     {\n       real_inf (&r);\n@@ -9866,7 +9866,7 @@ fold_builtin_fpclassify (location_t loc, tree exp)\n       tmp = fold_build2_loc (loc, ORDERED_EXPR, integer_type_node, arg, arg);\n       res = fold_build3_loc (loc, COND_EXPR, integer_type_node, tmp, res, fp_nan);\n     }\n-  \n+\n   return res;\n }\n \n@@ -9991,13 +9991,13 @@ fold_builtin_1 (location_t loc, tree fndecl, tree arg0, bool ignore)\n \n     CASE_FLT_FN (BUILT_IN_CONJ):\n       if (validate_arg (arg0, COMPLEX_TYPE)\n-\t&& TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE) \n+\t&& TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n \treturn fold_build1_loc (loc, CONJ_EXPR, type, arg0);\n     break;\n \n     CASE_FLT_FN (BUILT_IN_CREAL):\n       if (validate_arg (arg0, COMPLEX_TYPE)\n-\t&& TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE) \n+\t&& TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n \treturn non_lvalue_loc (loc, fold_build1_loc (loc, REALPART_EXPR, type, arg0));;\n     break;\n \n@@ -10009,86 +10009,86 @@ fold_builtin_1 (location_t loc, tree fndecl, tree arg0, bool ignore)\n \n     CASE_FLT_FN (BUILT_IN_CCOS):\n       return fold_builtin_ccos(loc, arg0, type, fndecl, /*hyper=*/ false);\n-    \n+\n     CASE_FLT_FN (BUILT_IN_CCOSH):\n       return fold_builtin_ccos(loc, arg0, type, fndecl, /*hyper=*/ true);\n-    \n+\n #ifdef HAVE_mpc\n     CASE_FLT_FN (BUILT_IN_CSIN):\n       if (validate_arg (arg0, COMPLEX_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE) \n+\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n \treturn do_mpc_arg1 (arg0, type, mpc_sin);\n     break;\n-    \n+\n     CASE_FLT_FN (BUILT_IN_CSINH):\n       if (validate_arg (arg0, COMPLEX_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE) \n+\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n \treturn do_mpc_arg1 (arg0, type, mpc_sinh);\n     break;\n-    \n+\n     CASE_FLT_FN (BUILT_IN_CTAN):\n       if (validate_arg (arg0, COMPLEX_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE) \n+\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n \treturn do_mpc_arg1 (arg0, type, mpc_tan);\n     break;\n-    \n+\n     CASE_FLT_FN (BUILT_IN_CTANH):\n       if (validate_arg (arg0, COMPLEX_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE) \n+\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n \treturn do_mpc_arg1 (arg0, type, mpc_tanh);\n     break;\n-    \n+\n     CASE_FLT_FN (BUILT_IN_CLOG):\n       if (validate_arg (arg0, COMPLEX_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE) \n+\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n \treturn do_mpc_arg1 (arg0, type, mpc_log);\n     break;\n-    \n+\n     CASE_FLT_FN (BUILT_IN_CSQRT):\n       if (validate_arg (arg0, COMPLEX_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE) \n+\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n \treturn do_mpc_arg1 (arg0, type, mpc_sqrt);\n     break;\n-    \n+\n #ifdef HAVE_mpc_arc\n     CASE_FLT_FN (BUILT_IN_CASIN):\n       if (validate_arg (arg0, COMPLEX_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE) \n+\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n \treturn do_mpc_arg1 (arg0, type, mpc_asin);\n     break;\n-    \n+\n     CASE_FLT_FN (BUILT_IN_CACOS):\n       if (validate_arg (arg0, COMPLEX_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE) \n+\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n \treturn do_mpc_arg1 (arg0, type, mpc_acos);\n     break;\n-    \n+\n     CASE_FLT_FN (BUILT_IN_CATAN):\n       if (validate_arg (arg0, COMPLEX_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE) \n+\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n \treturn do_mpc_arg1 (arg0, type, mpc_atan);\n     break;\n-    \n+\n     CASE_FLT_FN (BUILT_IN_CASINH):\n       if (validate_arg (arg0, COMPLEX_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE) \n+\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n \treturn do_mpc_arg1 (arg0, type, mpc_asinh);\n     break;\n-    \n+\n     CASE_FLT_FN (BUILT_IN_CACOSH):\n       if (validate_arg (arg0, COMPLEX_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE) \n+\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n \treturn do_mpc_arg1 (arg0, type, mpc_acosh);\n     break;\n-    \n+\n     CASE_FLT_FN (BUILT_IN_CATANH):\n       if (validate_arg (arg0, COMPLEX_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE) \n+\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n \treturn do_mpc_arg1 (arg0, type, mpc_atanh);\n     break;\n #endif /* HAVE_mpc_arc */\n #endif /* HAVE_mpc */\n-    \n+\n     CASE_FLT_FN (BUILT_IN_CABS):\n       return fold_builtin_cabs (loc, arg0, type, fndecl);\n \n@@ -10181,7 +10181,7 @@ fold_builtin_1 (location_t loc, tree fndecl, tree arg0, bool ignore)\n       if (validate_arg (arg0, REAL_TYPE))\n \treturn do_mpfr_arg1 (arg0, type, mpfr_gamma, NULL, NULL, 0);\n     break;\n- \n+\n     CASE_FLT_FN (BUILT_IN_EXP):\n       return fold_builtin_exponent (loc, fndecl, arg0, mpfr_exp);\n \n@@ -10196,7 +10196,7 @@ fold_builtin_1 (location_t loc, tree fndecl, tree arg0, bool ignore)\n       if (validate_arg (arg0, REAL_TYPE))\n \treturn do_mpfr_arg1 (arg0, type, mpfr_expm1, NULL, NULL, 0);\n     break;\n- \n+\n     CASE_FLT_FN (BUILT_IN_LOG):\n     return fold_builtin_logarithm (loc, fndecl, arg0, mpfr_log);\n \n@@ -10410,7 +10410,7 @@ fold_builtin_2 (location_t loc, tree fndecl, tree arg0, tree arg1, bool ignore)\n       if (validate_arg (arg0, COMPLEX_TYPE)\n \t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE\n \t  && validate_arg (arg1, COMPLEX_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg1))) == REAL_TYPE) \n+\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg1))) == REAL_TYPE)\n \treturn do_mpc_arg2 (arg0, arg1, type, /*do_nonfinite=*/ 0, mpc_pow);\n     break;\n #endif\n@@ -10664,7 +10664,7 @@ fold_builtin_3 (location_t loc, tree fndecl,\n    ARG2, and ARG3.  IGNORE is true if the result of the function call is\n    ignored.  This function returns NULL_TREE if no simplification was\n    possible.  */\n- \n+\n static tree\n fold_builtin_4 (location_t loc, tree fndecl,\n \t\ttree arg0, tree arg1, tree arg2, tree arg3, bool ignore)\n@@ -10710,9 +10710,9 @@ fold_builtin_4 (location_t loc, tree fndecl,\n     fixed argument patterns.  Foldings that do varargs-to-varargs\n     transformations, or that match calls with more than 4 arguments,\n     need to be handled with fold_builtin_varargs instead.  */\n- \n+\n #define MAX_ARGS_TO_FOLD_BUILTIN 4\n- \n+\n static tree\n fold_builtin_n (location_t loc, tree fndecl, tree *args, int nargs, bool ignore)\n {\n@@ -10861,10 +10861,10 @@ fold_call_expr (location_t loc, tree exp, bool ignore)\n     }\n   return NULL_TREE;\n }\n- \n+\n /* Conveniently construct a function call expression.  FNDECL names the\n     function to be called and ARGLIST is a TREE_LIST of arguments.  */\n- \n+\n tree\n build_function_call_expr (location_t loc, tree fndecl, tree arglist)\n {\n@@ -10882,7 +10882,7 @@ build_function_call_expr (location_t loc, tree fndecl, tree arglist)\n /* Conveniently construct a function call expression.  FNDECL names the\n    function to be called, N is the number of arguments, and the \"...\"\n    parameters are the argument expressions.  */\n- \n+\n tree\n build_call_expr_loc (location_t loc, tree fndecl, int n, ...)\n {\n@@ -10987,15 +10987,15 @@ rewrite_call_expr (location_t loc, tree exp, int skip, tree fndecl, int n, ...)\n       for (j = skip; j < oldnargs; j++, i++)\n \tbuffer[i] = CALL_EXPR_ARG (exp, j);\n     }\n-  else \n+  else\n     buffer = CALL_EXPR_ARGP (exp) + skip;\n \n   return fold (build_call_array_loc (loc, TREE_TYPE (exp), fn, nargs, buffer));\n }\n \n /* Validate a single argument ARG against a tree code CODE representing\n    a type.  */\n-  \n+\n static bool\n validate_arg (const_tree arg, enum tree_code code)\n {\n@@ -11449,7 +11449,7 @@ fold_builtin_strcat (location_t loc ATTRIBUTE_UNUSED, tree dst, tree src)\n \t  /* If we don't have a movstr we don't want to emit an strcpy\n \t     call.  We have to do that if the length of the source string\n \t     isn't computable (in that case we can use memcpy probably\n-\t     later expanding to a sequence of mov instructions).  If we \n+\t     later expanding to a sequence of mov instructions).  If we\n \t     have movstr instructions we can emit strcpy calls.  */\n \t  if (!HAVE_movstr)\n \t    {\n@@ -11759,7 +11759,7 @@ fold_builtin_next_arg (tree exp, bool va_start_p)\n     arg = SSA_NAME_VAR (arg);\n \n   /* We destructively modify the call to be __builtin_va_start (ap, 0)\n-     or __builtin_next_arg (0) the first time we see it, after checking \n+     or __builtin_next_arg (0) the first time we see it, after checking\n      the arguments and if needed issuing a warning.  */\n   if (!integer_zerop (arg))\n     {\n@@ -12129,7 +12129,7 @@ maybe_emit_sprintf_chk_warning (tree exp, enum built_in_function fcode)\n   int nargs = call_expr_nargs (exp);\n \n   /* Verify the required arguments in the original call.  */\n-  \n+\n   if (nargs < 4)\n     return;\n   size = CALL_EXPR_ARG (exp, 2);\n@@ -13097,7 +13097,7 @@ do_mpfr_arg1 (tree arg, tree type, int (*func)(mpfr_ptr, mpfr_srcptr, mp_rnd_t),\n \t      bool inclusive)\n {\n   tree result = NULL_TREE;\n-  \n+\n   STRIP_NOPS (arg);\n \n   /* To proceed, MPFR must exactly represent the target floating point\n@@ -13125,7 +13125,7 @@ do_mpfr_arg1 (tree arg, tree type, int (*func)(mpfr_ptr, mpfr_srcptr, mp_rnd_t),\n \t  mpfr_clear (m);\n \t}\n     }\n-  \n+\n   return result;\n }\n \n@@ -13140,7 +13140,7 @@ do_mpfr_arg2 (tree arg1, tree arg2, tree type,\n \t      int (*func)(mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mp_rnd_t))\n {\n   tree result = NULL_TREE;\n-  \n+\n   STRIP_NOPS (arg1);\n   STRIP_NOPS (arg2);\n \n@@ -13170,7 +13170,7 @@ do_mpfr_arg2 (tree arg1, tree arg2, tree type,\n \t  mpfr_clears (m1, m2, NULL);\n \t}\n     }\n-  \n+\n   return result;\n }\n \n@@ -13185,7 +13185,7 @@ do_mpfr_arg3 (tree arg1, tree arg2, tree arg3, tree type,\n \t      int (*func)(mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_srcptr, mp_rnd_t))\n {\n   tree result = NULL_TREE;\n-  \n+\n   STRIP_NOPS (arg1);\n   STRIP_NOPS (arg2);\n   STRIP_NOPS (arg3);\n@@ -13219,7 +13219,7 @@ do_mpfr_arg3 (tree arg1, tree arg2, tree arg3, tree type,\n \t  mpfr_clears (m1, m2, m3, NULL);\n \t}\n     }\n-  \n+\n   return result;\n }\n \n@@ -13235,9 +13235,9 @@ do_mpfr_sincos (tree arg, tree arg_sinp, tree arg_cosp)\n {\n   tree const type = TREE_TYPE (arg);\n   tree result = NULL_TREE;\n-  \n+\n   STRIP_NOPS (arg);\n-  \n+\n   /* To proceed, MPFR must exactly represent the target floating point\n      format, which only happens when the target base equals two.  */\n   if (REAL_MODE_FORMAT (TYPE_MODE (type))->b == 2\n@@ -13336,7 +13336,7 @@ do_mpfr_bessel_n (tree arg1, tree arg2, tree type,\n \t  mpfr_clear (m);\n \t}\n     }\n-  \n+\n   return result;\n }\n \n@@ -13350,10 +13350,10 @@ do_mpfr_remquo (tree arg0, tree arg1, tree arg_quo)\n {\n   tree const type = TREE_TYPE (arg0);\n   tree result = NULL_TREE;\n-  \n+\n   STRIP_NOPS (arg0);\n   STRIP_NOPS (arg1);\n-  \n+\n   /* To proceed, MPFR must exactly represent the target floating point\n      format, which only happens when the target base equals two.  */\n   if (REAL_MODE_FORMAT (TYPE_MODE (type))->b == 2\n@@ -13427,7 +13427,7 @@ do_mpfr_lgamma_r (tree arg, tree arg_sg, tree type)\n   tree result = NULL_TREE;\n \n   STRIP_NOPS (arg);\n-  \n+\n   /* To proceed, MPFR must exactly represent the target floating point\n      format, which only happens when the target base equals two.  Also\n      verify ARG is a constant and that ARG_SG is an int pointer.  */\n@@ -13489,7 +13489,7 @@ static tree\n do_mpc_arg1 (tree arg, tree type, int (*func)(mpc_ptr, mpc_srcptr, mpc_rnd_t))\n {\n   tree result = NULL_TREE;\n-  \n+\n   STRIP_NOPS (arg);\n \n   /* To proceed, MPFR must exactly represent the target floating point\n@@ -13510,7 +13510,7 @@ do_mpc_arg1 (tree arg, tree type, int (*func)(mpc_ptr, mpc_srcptr, mpc_rnd_t))\n \t  const mpc_rnd_t crnd = fmt->round_towards_zero ? MPC_RNDZZ : MPC_RNDNN;\n \t  int inexact;\n \t  mpc_t m;\n-\t  \n+\n \t  mpc_init2 (m, prec);\n \t  mpfr_from_real (mpc_realref(m), re, rnd);\n \t  mpfr_from_real (mpc_imagref(m), im, rnd);\n@@ -13538,7 +13538,7 @@ do_mpc_arg2 (tree arg0, tree arg1, tree type, int do_nonfinite,\n \t     int (*func)(mpc_ptr, mpc_srcptr, mpc_srcptr, mpc_rnd_t))\n {\n   tree result = NULL_TREE;\n-  \n+\n   STRIP_NOPS (arg0);\n   STRIP_NOPS (arg1);\n \n@@ -13566,7 +13566,7 @@ do_mpc_arg2 (tree arg0, tree arg1, tree type, int do_nonfinite,\n \t  const mpc_rnd_t crnd = fmt->round_towards_zero ? MPC_RNDZZ : MPC_RNDNN;\n \t  int inexact;\n \t  mpc_t m0, m1;\n-\t  \n+\n \t  mpc_init2 (m0, prec);\n \t  mpc_init2 (m1, prec);\n \t  mpfr_from_real (mpc_realref(m0), re0, rnd);"}, {"sha": "09177a9001a9cd141895611028cc5de9726c523a", "filename": "gcc/builtins.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -643,7 +643,7 @@ DEF_EXT_LIB_BUILTIN    (BUILT_IN_FFSL, \"ffsl\", BT_FN_INT_LONG, ATTR_CONST_NOTHRO\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_FFSLL, \"ffsll\", BT_FN_INT_LONGLONG, ATTR_CONST_NOTHROW_LIST)\n DEF_EXT_LIB_BUILTIN        (BUILT_IN_FORK, \"fork\", BT_FN_PID, ATTR_NOTHROW_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_FRAME_ADDRESS, \"frame_address\", BT_FN_PTR_UINT, ATTR_NULL)\n-DEF_LIB_BUILTIN        (BUILT_IN_FREE, \"free\", BT_FN_VOID_PTR, ATTR_NOTHROW_LIST) \n+DEF_LIB_BUILTIN        (BUILT_IN_FREE, \"free\", BT_FN_VOID_PTR, ATTR_NOTHROW_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_FROB_RETURN_ADDR, \"frob_return_addr\", BT_FN_PTR_PTR, ATTR_NULL)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_GETTEXT, \"gettext\", BT_FN_STRING_CONST_STRING, ATTR_FORMAT_ARG_1)\n DEF_C99_BUILTIN        (BUILT_IN_IMAXABS, \"imaxabs\", BT_FN_INTMAX_INTMAX, ATTR_CONST_NOTHROW_LIST)"}, {"sha": "747e7051e3ea65be82704a8a37859566929c35ba", "filename": "gcc/c-common.c", "status": "modified", "additions": 80, "deletions": 80, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -1542,7 +1542,7 @@ decl_constant_value_for_optimization (tree exp)\n void\n constant_expression_warning (tree value)\n {\n-  if (warn_overflow && pedantic \n+  if (warn_overflow && pedantic\n       && (TREE_CODE (value) == INTEGER_CST || TREE_CODE (value) == REAL_CST\n \t  || TREE_CODE (value) == FIXED_CST\n \t  || TREE_CODE (value) == VECTOR_CST\n@@ -1585,20 +1585,20 @@ overflow_warning (location_t loc, tree value)\n     case INTEGER_CST:\n       warning_at (loc, OPT_Woverflow, \"integer overflow in expression\");\n       break;\n-      \n+\n     case REAL_CST:\n       warning_at (loc, OPT_Woverflow,\n \t\t  \"floating point overflow in expression\");\n       break;\n-      \n+\n     case FIXED_CST:\n       warning_at (loc, OPT_Woverflow, \"fixed-point overflow in expression\");\n       break;\n \n     case VECTOR_CST:\n       warning_at (loc, OPT_Woverflow, \"vector overflow in expression\");\n       break;\n-      \n+\n     case COMPLEX_CST:\n       if (TREE_CODE (TREE_REALPART (value)) == INTEGER_CST)\n \twarning_at (loc, OPT_Woverflow,\n@@ -1620,7 +1620,7 @@ overflow_warning (location_t loc, tree value)\n    had CODE_LEFT and CODE_RIGHT, into an expression of type TYPE.  */\n void\n warn_logical_operator (location_t location, enum tree_code code, tree type,\n-\t\t       enum tree_code code_left, tree op_left, \n+\t\t       enum tree_code code_left, tree op_left,\n \t\t       enum tree_code ARG_UNUSED (code_right), tree op_right)\n {\n   int or_op = (code == TRUTH_ORIF_EXPR || code == TRUTH_OR_EXPR);\n@@ -1677,12 +1677,12 @@ warn_logical_operator (location_t location, enum tree_code code, tree type,\n \n   if (rhs && TREE_CODE (rhs) == C_MAYBE_CONST_EXPR)\n     rhs = C_MAYBE_CONST_EXPR_EXPR (rhs);\n-  \n+\n   /* If this is an OR operation, invert both sides; we will invert\n      again at the end.  */\n   if (or_op)\n     in0_p = !in0_p, in1_p = !in1_p;\n-  \n+\n   /* If both expressions are the same, if we can merge the ranges, and we\n      can build the range test, return it or it inverted.  */\n   if (lhs && rhs && operand_equal_p (lhs, rhs, 0)\n@@ -1741,7 +1741,7 @@ strict_aliasing_warning (tree otype, tree type, tree expr)\n \t}\n       else\n         {\n-          /* warn_strict_aliasing >= 3.   This includes the default (3).  \n+          /* warn_strict_aliasing >= 3.   This includes the default (3).\n              Only warn if the cast is dereferenced immediately.  */\n           alias_set_type set1 =\n \t    get_alias_set (TREE_TYPE (TREE_OPERAND (expr, 0)));\n@@ -1806,7 +1806,7 @@ check_main_parameter_types (tree decl)\n        {\n        case 1:\n          if (TYPE_MAIN_VARIANT (type) != integer_type_node)\n-           pedwarn (input_location, OPT_Wmain, \"first argument of %q+D should be %<int%>\", \n+           pedwarn (input_location, OPT_Wmain, \"first argument of %q+D should be %<int%>\",\n \t\t    decl);\n          break;\n \n@@ -1901,7 +1901,7 @@ vector_types_convertible_p (const_tree t1, const_tree t2, bool emit_lax_note)\n    both args are zero-extended or both are sign-extended.\n    Otherwise, we might change the result.\n    Eg, (short)-1 | (unsigned short)-1 is (int)-1\n-   but calculated in (unsigned short) it would be (unsigned short)-1.  \n+   but calculated in (unsigned short) it would be (unsigned short)-1.\n */\n tree shorten_binary_op (tree result_type, tree op0, tree op1, bool bitwise)\n {\n@@ -1916,13 +1916,13 @@ tree shorten_binary_op (tree result_type, tree op0, tree op1, bool bitwise)\n      from signed char and that RESULT_TYPE is long long int.\n      If we explicitly cast OP0 to RESULT_TYPE, OP0 would look\n      like\n-     \n+\n      (long long int) (unsigned int) signed_char\n \n      which get_narrower would narrow down to\n-     \n+\n      (unsigned int) signed char\n-     \n+\n      If we do not cast OP0 first, get_narrower would return\n      signed_char, which is inconsistent with the case of the\n      explicit cast.  */\n@@ -1937,7 +1937,7 @@ tree shorten_binary_op (tree result_type, tree op0, tree op1, bool bitwise)\n \n   /* Handle the case that OP0 (or OP1) does not *contain* a conversion\n      but it *requires* conversion to FINAL_TYPE.  */\n-  \n+\n   if ((TYPE_PRECISION (TREE_TYPE (op0))\n        == TYPE_PRECISION (TREE_TYPE (arg0)))\n       && TREE_TYPE (op0) != result_type)\n@@ -1946,18 +1946,18 @@ tree shorten_binary_op (tree result_type, tree op0, tree op1, bool bitwise)\n        == TYPE_PRECISION (TREE_TYPE (arg1)))\n       && TREE_TYPE (op1) != result_type)\n     unsigned1 = TYPE_UNSIGNED (TREE_TYPE (op1));\n-  \n+\n   /* Now UNSIGNED0 is 1 if ARG0 zero-extends to FINAL_TYPE.  */\n-  \n+\n   /* For bitwise operations, signedness of nominal type\n      does not matter.  Consider only how operands were extended.  */\n   if (bitwise)\n     uns = unsigned0;\n-  \n+\n   /* Note that in all three cases below we refrain from optimizing\n      an unsigned operation on sign-extended args.\n      That would not be valid.  */\n-  \n+\n   /* Both args variable: if both extended in same way\n      from same width, do it in that width.\n      Do it unsigned if args were zero-extended.  */\n@@ -2036,7 +2036,7 @@ conversion_warning (tree type, tree expr)\n       /* Conversion from boolean to a signed:1 bit-field (which only\n \t can hold the values 0 and -1) doesn't lose information - but\n \t it does change the value.  */\n-      if (TYPE_PRECISION (type) == 1 && !TYPE_UNSIGNED (type)) \n+      if (TYPE_PRECISION (type) == 1 && !TYPE_UNSIGNED (type))\n \twarning (OPT_Wconversion,\n                  \"conversion to %qT from boolean expression\", type);\n       return;\n@@ -2057,7 +2057,7 @@ conversion_warning (tree type, tree expr)\n                && TREE_CODE (type) == INTEGER_TYPE\n                && !int_fits_type_p (expr, type))\n         {\n-          if (TYPE_UNSIGNED (type) && !TYPE_UNSIGNED (expr_type) \n+          if (TYPE_UNSIGNED (type) && !TYPE_UNSIGNED (expr_type)\n \t      && tree_int_cst_sgn (expr) < 0)\n \t    warning (OPT_Wsign_conversion,\n \t\t     \"negative integer implicitly converted to unsigned type\");\n@@ -2102,7 +2102,7 @@ conversion_warning (tree type, tree expr)\n \ttree op1 = TREE_OPERAND (expr, 1);\n \ttree op2 = TREE_OPERAND (expr, 2);\n \n-\tif ((TREE_CODE (op1) == REAL_CST || TREE_CODE (op1) == INTEGER_CST \n+\tif ((TREE_CODE (op1) == REAL_CST || TREE_CODE (op1) == INTEGER_CST\n \t     || TREE_CODE (op1) == COND_EXPR)\n \t    && (TREE_CODE (op2) == REAL_CST || TREE_CODE (op2) == INTEGER_CST\n \t\t|| TREE_CODE (op2) == COND_EXPR))\n@@ -2129,15 +2129,15 @@ conversion_warning (tree type, tree expr)\n \t  expr_type = TREE_TYPE (expr);\n \n \t  /* Don't warn for short y; short x = ((int)y & 0xff);  */\n-\t  if (TREE_CODE (expr) == BIT_AND_EXPR \n-\t\t|| TREE_CODE (expr) == BIT_IOR_EXPR \n+\t  if (TREE_CODE (expr) == BIT_AND_EXPR\n+\t\t|| TREE_CODE (expr) == BIT_IOR_EXPR\n \t      || TREE_CODE (expr) == BIT_XOR_EXPR)\n \t    {\n \t      /* If both args were extended from a shortest type,\n \t\t use that type if that is safe.  */\n-\t      expr_type = shorten_binary_op (expr_type, \n-\t\t\t\t\t     TREE_OPERAND (expr, 0), \n-\t\t\t\t\t     TREE_OPERAND (expr, 1), \n+\t      expr_type = shorten_binary_op (expr_type,\n+\t\t\t\t\t     TREE_OPERAND (expr, 0),\n+\t\t\t\t\t     TREE_OPERAND (expr, 1),\n \t\t\t\t\t     /* bitwise */1);\n \n \t      if (TREE_CODE (expr) == BIT_AND_EXPR)\n@@ -2155,13 +2155,13 @@ conversion_warning (tree type, tree expr)\n \t\t       && int_fits_type_p (op0, c_common_unsigned_type (type)))\n \t\t      || (TREE_CODE (op1) == INTEGER_CST\n \t\t\t  && int_fits_type_p (op1, c_common_signed_type (type))\n-\t\t\t  && int_fits_type_p (op1, \n+\t\t\t  && int_fits_type_p (op1,\n \t\t\t\t\t      c_common_unsigned_type (type))))\n \t\t    return;\n \t\t  /* If constant is unsigned and fits in the target\n \t\t     type, then the result will also fit.  */\n \t\t  else if ((TREE_CODE (op0) == INTEGER_CST\n-\t\t\t    && unsigned0 \n+\t\t\t    && unsigned0\n \t\t\t    && int_fits_type_p (op0, type))\n \t\t\t   || (TREE_CODE (op1) == INTEGER_CST\n \t\t\t       && unsigned1\n@@ -2170,7 +2170,7 @@ conversion_warning (tree type, tree expr)\n \t\t}\n \t    }\n           /* Warn for integer types converted to smaller integer types.  */\n-\t  if (TYPE_PRECISION (type) < TYPE_PRECISION (expr_type)) \n+\t  if (TYPE_PRECISION (type) < TYPE_PRECISION (expr_type))\n \t    give_warning = true;\n \n \t  /* When they are the same width but different signedness,\n@@ -2194,9 +2194,9 @@ conversion_warning (tree type, tree expr)\n         {\n           tree type_low_bound = TYPE_MIN_VALUE (expr_type);\n           tree type_high_bound = TYPE_MAX_VALUE (expr_type);\n-          REAL_VALUE_TYPE real_low_bound \n+          REAL_VALUE_TYPE real_low_bound\n \t    = real_value_from_int_cst (0, type_low_bound);\n-          REAL_VALUE_TYPE real_high_bound \n+          REAL_VALUE_TYPE real_high_bound\n \t    = real_value_from_int_cst (0, type_high_bound);\n \n           if (!exact_real_truncate (TYPE_MODE (type), &real_low_bound)\n@@ -2245,7 +2245,7 @@ warnings_for_convert_and_check (tree type, tree expr, tree result)\n           else\n             conversion_warning (type, expr);\n         }\n-      else if (!int_fits_type_p (expr, c_common_unsigned_type (type))) \n+      else if (!int_fits_type_p (expr, c_common_unsigned_type (type)))\n \twarning (OPT_Woverflow,\n \t\t \"overflow in implicit constant conversion\");\n       /* No warning for converting 0x80000000 to int.  */\n@@ -2294,7 +2294,7 @@ convert_and_check (tree type, tree expr)\n \n   if (TREE_TYPE (expr) == type)\n     return expr;\n-  \n+\n   result = convert (type, expr);\n \n   if (c_inhibit_evaluation_warnings == 0\n@@ -2600,7 +2600,7 @@ verify_tree (tree x, struct tlist **pbefore_sp, struct tlist **pno_sp,\n       {\n \tcall_expr_arg_iterator iter;\n \ttree arg;\n-\ttmp_before = tmp_nosp = 0; \n+\ttmp_before = tmp_nosp = 0;\n \tverify_tree (CALL_EXPR_FN (x), &tmp_before, &tmp_nosp, NULL_TREE);\n \tFOR_EACH_CALL_EXPR_ARG (arg, iter, x)\n \t  {\n@@ -3685,7 +3685,7 @@ shorten_compare (tree *op0_ptr, tree *op1_ptr, tree *restype_ptr,\n \t\t  && !(TREE_CODE (primop0) == INTEGER_CST\n \t\t       && !TREE_OVERFLOW (convert (c_common_signed_type (type),\n \t\t\t\t\t\t   primop0))))\n-\t\twarning (OPT_Wtype_limits, \n+\t\twarning (OPT_Wtype_limits,\n \t\t\t \"comparison of unsigned expression >= 0 is always true\");\n \t      value = truthvalue_true_node;\n \t      break;\n@@ -3695,7 +3695,7 @@ shorten_compare (tree *op0_ptr, tree *op1_ptr, tree *restype_ptr,\n \t\t  && !(TREE_CODE (primop0) == INTEGER_CST\n \t\t       && !TREE_OVERFLOW (convert (c_common_signed_type (type),\n \t\t\t\t\t\t   primop0))))\n-\t\twarning (OPT_Wtype_limits, \n+\t\twarning (OPT_Wtype_limits,\n \t\t\t \"comparison of unsigned expression < 0 is always false\");\n \t      value = truthvalue_false_node;\n \t      break;\n@@ -3737,19 +3737,19 @@ pointer_int_sum (location_t loc, enum tree_code resultcode,\n \n   if (TREE_CODE (TREE_TYPE (result_type)) == VOID_TYPE)\n     {\n-      pedwarn (loc, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+      pedwarn (loc, pedantic ? OPT_pedantic : OPT_Wpointer_arith,\n \t       \"pointer of type %<void *%> used in arithmetic\");\n       size_exp = integer_one_node;\n     }\n   else if (TREE_CODE (TREE_TYPE (result_type)) == FUNCTION_TYPE)\n     {\n-      pedwarn (loc, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+      pedwarn (loc, pedantic ? OPT_pedantic : OPT_Wpointer_arith,\n \t       \"pointer to a function used in arithmetic\");\n       size_exp = integer_one_node;\n     }\n   else if (TREE_CODE (TREE_TYPE (result_type)) == METHOD_TYPE)\n     {\n-      pedwarn (loc, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+      pedwarn (loc, pedantic ? OPT_pedantic : OPT_Wpointer_arith,\n \t       \"pointer to member function used in arithmetic\");\n       size_exp = integer_one_node;\n     }\n@@ -3912,7 +3912,7 @@ c_common_truthvalue_conversion (location_t location, tree expr)\n       if (TREE_TYPE (expr) == truthvalue_type_node)\n \treturn expr;\n       expr = build2 (TREE_CODE (expr), truthvalue_type_node,\n-\t\t     c_common_truthvalue_conversion (location, \n+\t\t     c_common_truthvalue_conversion (location,\n \t\t\t\t\t\t     TREE_OPERAND (expr, 0)),\n \t\t     c_common_truthvalue_conversion (location,\n \t\t\t\t\t\t     TREE_OPERAND (expr, 1)));\n@@ -4005,7 +4005,7 @@ c_common_truthvalue_conversion (location_t location, tree expr)\n \t{\n \t  expr = build2 (COMPOUND_EXPR, truthvalue_type_node,\n \t\t\t TREE_OPERAND (expr, 1),\n-\t\t\t c_common_truthvalue_conversion \n+\t\t\t c_common_truthvalue_conversion\n \t\t\t (location, TREE_OPERAND (expr, 0)));\n \t  goto ret;\n \t}\n@@ -4361,7 +4361,7 @@ c_sizeof_or_alignof_type (location_t loc,\n       if (is_sizeof)\n \t{\n \t  if (complain && (pedantic || warn_pointer_arith))\n-\t    pedwarn (loc, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+\t    pedwarn (loc, pedantic ? OPT_pedantic : OPT_Wpointer_arith,\n \t\t     \"invalid application of %<sizeof%> to a function type\");\n           else if (!complain)\n             return error_mark_node;\n@@ -4374,7 +4374,7 @@ c_sizeof_or_alignof_type (location_t loc,\n     {\n       if (type_code == VOID_TYPE\n \t  && complain && (pedantic || warn_pointer_arith))\n-\tpedwarn (loc, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+\tpedwarn (loc, pedantic ? OPT_pedantic : OPT_Wpointer_arith,\n \t\t \"invalid application of %qs to a void type\", op_name);\n       else if (!complain)\n         return error_mark_node;\n@@ -4770,7 +4770,7 @@ c_common_nodes_and_builtins (void)\n \n   /* Only supported decimal floating point extension if the target\n      actually supports underlying modes. */\n-  if (targetm.scalar_mode_supported_p (SDmode) \n+  if (targetm.scalar_mode_supported_p (SDmode)\n       && targetm.scalar_mode_supported_p (DDmode)\n       && targetm.scalar_mode_supported_p (TDmode))\n     {\n@@ -5332,7 +5332,7 @@ c_add_case_label (location_t loc, splay_tree cases, tree cond, tree orig_type,\n \n   /* Case ranges are a GNU extension.  */\n   if (high_value)\n-    pedwarn (loc, OPT_pedantic, \n+    pedwarn (loc, OPT_pedantic,\n \t     \"range expressions in switch statements are non-standard\");\n \n   type = TREE_TYPE (cond);\n@@ -6269,7 +6269,7 @@ get_priority (tree args, bool is_destructor)\n \n   if (!args)\n     return DEFAULT_INIT_PRIORITY;\n-  \n+\n   if (!SUPPORTS_INIT_PRIORITY)\n     {\n       if (is_destructor)\n@@ -6293,12 +6293,12 @@ get_priority (tree args, bool is_destructor)\n       if (is_destructor)\n \twarning (0,\n \t\t \"destructor priorities from 0 to %d are reserved \"\n-\t\t \"for the implementation\", \n+\t\t \"for the implementation\",\n \t\t MAX_RESERVED_INIT_PRIORITY);\n       else\n \twarning (0,\n \t\t \"constructor priorities from 0 to %d are reserved \"\n-\t\t \"for the implementation\", \n+\t\t \"for the implementation\",\n \t\t MAX_RESERVED_INIT_PRIORITY);\n     }\n   return pri;\n@@ -6578,7 +6578,7 @@ handle_section_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n \t      && current_function_decl != NULL_TREE\n \t      && !TREE_STATIC (decl))\n \t    {\n-\t      error_at (DECL_SOURCE_LOCATION (decl), \n+\t      error_at (DECL_SOURCE_LOCATION (decl),\n \t\t\t\"section attribute cannot be specified for \"\n \t\t\t\"local variables\");\n \t      *no_add_attrs = true;\n@@ -6744,11 +6744,11 @@ handle_alias_attribute (tree *node, tree name, tree args,\n       *no_add_attrs = true;\n     }\n   else if ((TREE_CODE (decl) == FUNCTION_DECL && DECL_INITIAL (decl))\n-      || (TREE_CODE (decl) != FUNCTION_DECL \n+      || (TREE_CODE (decl) != FUNCTION_DECL\n \t  && TREE_PUBLIC (decl) && !DECL_EXTERNAL (decl))\n       /* A static variable declaration is always a tentative definition,\n \t but the alias is a non-tentative definition which overrides.  */\n-      || (TREE_CODE (decl) != FUNCTION_DECL \n+      || (TREE_CODE (decl) != FUNCTION_DECL\n \t  && ! TREE_PUBLIC (decl) && DECL_INITIAL (decl)))\n     {\n       error (\"%q+D defined both normally and as an alias\", decl);\n@@ -7091,11 +7091,11 @@ handle_alloc_size_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n       tree position = TREE_VALUE (args);\n \n       if (TREE_CODE (position) != INTEGER_CST\n-\t  || TREE_INT_CST_HIGH (position) \n+\t  || TREE_INT_CST_HIGH (position)\n \t  || TREE_INT_CST_LOW (position) < 1\n \t  || TREE_INT_CST_LOW (position) > arg_count )\n \t{\n-\t  warning (OPT_Wattributes, \n+\t  warning (OPT_Wattributes,\n \t           \"alloc_size parameter outside range\");\n \t  *no_add_attrs = true;\n \t  return NULL_TREE;\n@@ -7653,7 +7653,7 @@ handle_sentinel_attribute (tree *node, tree name, tree args,\n \n       if (TREE_CODE (position) != INTEGER_CST)\n \t{\n-\t  warning (OPT_Wattributes, \n+\t  warning (OPT_Wattributes,\n \t\t   \"requested position is not an integer constant\");\n \t  *no_add_attrs = true;\n \t}\n@@ -7679,10 +7679,10 @@ handle_type_generic_attribute (tree *node, tree ARG_UNUSED (name),\n \t\t\t       bool * ARG_UNUSED (no_add_attrs))\n {\n   tree params;\n-  \n+\n   /* Ensure we have a function type.  */\n   gcc_assert (TREE_CODE (*node) == FUNCTION_TYPE);\n-  \n+\n   params = TYPE_ARG_TYPES (*node);\n   while (params && ! VOID_TYPE_P (TREE_VALUE (params)))\n     params = TREE_CHAIN (params);\n@@ -8054,7 +8054,7 @@ check_builtin_function_arguments (tree fndecl, int nargs, tree *args)\n       if (validate_nargs (fndecl, nargs, 6))\n \t{\n \t  unsigned i;\n-\t  \n+\n \t  for (i=0; i<5; i++)\n \t    if (TREE_CODE (args[i]) != INTEGER_CST)\n \t      {\n@@ -8166,7 +8166,7 @@ catenate_strings (const char *lhs, const char *rhs_start, int rhs_size)\n    TOKEN, which had the associated VALUE.  */\n \n void\n-c_parse_error (const char *gmsgid, enum cpp_ttype token_type, \n+c_parse_error (const char *gmsgid, enum cpp_ttype token_type,\n \t       tree value, unsigned char token_flags)\n {\n #define catenate_messages(M1, M2) catenate_strings ((M1), (M2), sizeof (M2))\n@@ -8175,8 +8175,8 @@ c_parse_error (const char *gmsgid, enum cpp_ttype token_type,\n \n   if (token_type == CPP_EOF)\n     message = catenate_messages (gmsgid, \" at end of input\");\n-  else if (token_type == CPP_CHAR \n-\t   || token_type == CPP_WCHAR \n+  else if (token_type == CPP_CHAR\n+\t   || token_type == CPP_WCHAR\n \t   || token_type == CPP_CHAR16\n \t   || token_type == CPP_CHAR32)\n     {\n@@ -8208,8 +8208,8 @@ c_parse_error (const char *gmsgid, enum cpp_ttype token_type,\n       free (message);\n       message = NULL;\n     }\n-  else if (token_type == CPP_STRING \n-\t   || token_type == CPP_WSTRING \n+  else if (token_type == CPP_STRING\n+\t   || token_type == CPP_WSTRING\n \t   || token_type == CPP_STRING16\n \t   || token_type == CPP_STRING32\n \t   || token_type == CPP_UTF8STRING)\n@@ -8585,7 +8585,7 @@ complete_array_type (tree *ptype, tree initial_value, bool do_default)\n \n   /* Make sure we have the canonical MAIN_TYPE. */\n   hashcode = iterative_hash_object (TYPE_HASH (unqual_elt), hashcode);\n-  hashcode = iterative_hash_object (TYPE_HASH (TYPE_DOMAIN (main_type)), \n+  hashcode = iterative_hash_object (TYPE_HASH (TYPE_DOMAIN (main_type)),\n \t\t\t\t    hashcode);\n   main_type = type_hash_canon (hashcode, main_type);\n \n@@ -8596,7 +8596,7 @@ complete_array_type (tree *ptype, tree initial_value, bool do_default)\n   else if (TYPE_CANONICAL (TREE_TYPE (main_type)) != TREE_TYPE (main_type)\n \t   || (TYPE_CANONICAL (TYPE_DOMAIN (main_type))\n \t       != TYPE_DOMAIN (main_type)))\n-    TYPE_CANONICAL (main_type) \n+    TYPE_CANONICAL (main_type)\n       = build_array_type (TYPE_CANONICAL (TREE_TYPE (main_type)),\n \t\t\t  TYPE_CANONICAL (TYPE_DOMAIN (main_type)));\n   else\n@@ -8891,7 +8891,7 @@ warn_about_parentheses (enum tree_code code,\n \t || ((CODE) != INTEGER_CST                                          \\\n \t     && (integer_onep (ARG) || integer_zerop (ARG))))\n \n-  switch (code) \n+  switch (code)\n     {\n     case LSHIFT_EXPR:\n       if (code_left == PLUS_EXPR || code_right == PLUS_EXPR)\n@@ -9041,16 +9041,16 @@ warn_for_div_by_zero (location_t loc, tree divisor)\n    The arguments of this function map directly to local variables\n    of build_binary_op.  */\n \n-void \n+void\n warn_for_sign_compare (location_t location,\n-\t\t       tree orig_op0, tree orig_op1, \n-\t\t       tree op0, tree op1, \n+\t\t       tree orig_op0, tree orig_op1,\n+\t\t       tree op0, tree op1,\n \t\t       tree result_type, enum tree_code resultcode)\n {\n   int op0_signed = !TYPE_UNSIGNED (TREE_TYPE (orig_op0));\n   int op1_signed = !TYPE_UNSIGNED (TREE_TYPE (orig_op1));\n   int unsignedp0, unsignedp1;\n-  \n+\n   /* In C++, check for comparison of different enum types.  */\n   if (c_dialect_cxx()\n       && TREE_CODE (TREE_TYPE (orig_op0)) == ENUMERAL_TYPE\n@@ -9078,10 +9078,10 @@ warn_for_sign_compare (location_t location,\n \n       if (op0_signed)\n         sop = orig_op0, uop = orig_op1;\n-      else \n+      else\n         sop = orig_op1, uop = orig_op0;\n \n-      STRIP_TYPE_NOPS (sop); \n+      STRIP_TYPE_NOPS (sop);\n       STRIP_TYPE_NOPS (uop);\n       base_type = (TREE_CODE (result_type) == COMPLEX_TYPE\n \t\t   ? TREE_TYPE (result_type) : result_type);\n@@ -9107,23 +9107,23 @@ warn_for_sign_compare (location_t location,\n                && int_fits_type_p (TYPE_MAX_VALUE (TREE_TYPE (uop)),\n \t\t\t\t   c_common_signed_type (base_type)))\n         /* OK */;\n-      else \n+      else\n         warning_at (location,\n-\t\t    OPT_Wsign_compare, \n+\t\t    OPT_Wsign_compare,\n \t\t    \"comparison between signed and unsigned integer expressions\");\n     }\n-  \n+\n   /* Warn if two unsigned values are being compared in a size larger\n      than their original size, and one (and only one) is the result of\n      a `~' operator.  This comparison will always fail.\n-     \n+\n      Also warn if one operand is a constant, and the constant does not\n      have all bits set that are set in the ~ operand when it is\n      extended.  */\n \n   op0 = get_narrower (op0, &unsignedp0);\n   op1 = get_narrower (op1, &unsignedp1);\n-  \n+\n   if ((TREE_CODE (op0) == BIT_NOT_EXPR)\n       ^ (TREE_CODE (op1) == BIT_NOT_EXPR))\n     {\n@@ -9138,7 +9138,7 @@ warn_for_sign_compare (location_t location,\n           HOST_WIDE_INT constant, mask;\n           int unsignedp;\n           unsigned int bits;\n-          \n+\n           if (host_integerp (op0, 0))\n             {\n               primop = op1;\n@@ -9151,7 +9151,7 @@ warn_for_sign_compare (location_t location,\n               unsignedp = unsignedp0;\n               constant = tree_low_cst (op1, 0);\n             }\n-          \n+\n           bits = TYPE_PRECISION (TREE_TYPE (primop));\n           if (bits < TYPE_PRECISION (result_type)\n               && bits < HOST_BITS_PER_LONG && unsignedp)\n@@ -9160,10 +9160,10 @@ warn_for_sign_compare (location_t location,\n               if ((mask & constant) != mask)\n \t\t{\n \t\t  if (constant == 0)\n-\t\t    warning (OPT_Wsign_compare, \n+\t\t    warning (OPT_Wsign_compare,\n \t\t\t     \"promoted ~unsigned is always non-zero\");\n \t\t  else\n-\t\t    warning_at (location, OPT_Wsign_compare, \n+\t\t    warning_at (location, OPT_Wsign_compare,\n \t\t\t\t\"comparison of promoted ~unsigned with constant\");\n \t\t}\n             }"}, {"sha": "5830d7b9335210f9aa36c1af81f459bc375174c9", "filename": "gcc/c-common.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -1038,9 +1038,9 @@ extern void warn_about_parentheses (enum tree_code,\n extern void warn_for_unused_label (tree label);\n extern void warn_for_div_by_zero (location_t, tree divisor);\n extern void warn_for_sign_compare (location_t,\n-\t\t\t\t   tree orig_op0, tree orig_op1, \n-\t\t\t\t   tree op0, tree op1, \n-\t\t\t\t   tree result_type, \n+\t\t\t\t   tree orig_op0, tree orig_op1,\n+\t\t\t\t   tree op0, tree op1,\n+\t\t\t\t   tree result_type,\n \t\t\t\t   enum tree_code resultcode);\n extern void set_underlying_type (tree x);\n extern bool is_typedef_decl (tree x);"}, {"sha": "1565aac23db5588962e1a3e4a5e137565c81c02b", "filename": "gcc/c-cppbuiltin.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-cppbuiltin.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -60,7 +60,7 @@ static void builtin_define_type_max (const char *, tree);\n static void builtin_define_type_minmax (const char *, const char *, tree);\n static void builtin_define_type_precision (const char *, tree);\n static void builtin_define_type_sizeof (const char *, tree);\n-static void builtin_define_float_constants (const char *, \n+static void builtin_define_float_constants (const char *,\n \t\t\t\t\t    const char *,\n \t\t\t\t\t    const char *,\n \t\t\t\t\t    tree);\n@@ -84,9 +84,9 @@ builtin_define_type_sizeof (const char *name, tree type)\n /* Define the float.h constants for TYPE using NAME_PREFIX, FP_SUFFIX,\n    and FP_CAST. */\n static void\n-builtin_define_float_constants (const char *name_prefix, \n-\t\t                const char *fp_suffix, \n-\t\t\t\tconst char *fp_cast, \n+builtin_define_float_constants (const char *name_prefix,\n+\t\t                const char *fp_suffix,\n+\t\t\t\tconst char *fp_cast,\n \t\t\t\ttree type)\n {\n   /* Used to convert radix-based values to base 10 values in several cases.\n@@ -205,7 +205,7 @@ builtin_define_float_constants (const char *name_prefix,\n      construct the following numbers directly as a hexadecimal\n      constants.  */\n   get_max_float (fmt, buf, sizeof (buf));\n-  \n+\n   sprintf (name, \"__%s_MAX__\", name_prefix);\n   builtin_define_with_hex_fp_value (name, type, decimal_dig, buf, fp_suffix, fp_cast);\n \n@@ -260,8 +260,8 @@ builtin_define_float_constants (const char *name_prefix,\n \n /* Define __DECx__ constants for TYPE using NAME_PREFIX and SUFFIX. */\n static void\n-builtin_define_decimal_float_constants (const char *name_prefix, \n-\t\t\t\t\tconst char *suffix, \n+builtin_define_decimal_float_constants (const char *name_prefix,\n+\t\t\t\t\tconst char *suffix,\n \t\t\t\t\ttree type)\n {\n   const struct real_format *fmt;\n@@ -286,7 +286,7 @@ builtin_define_decimal_float_constants (const char *name_prefix,\n   /* Compute the minimum representable value.  */\n   sprintf (name, \"__%s_MIN__\", name_prefix);\n   sprintf (buf, \"1E%d%s\", fmt->emin - 1, suffix);\n-  builtin_define_with_value (name, buf, 0); \n+  builtin_define_with_value (name, buf, 0);\n \n   /* Compute the maximum representable value.  */\n   sprintf (name, \"__%s_MAX__\", name_prefix);\n@@ -300,7 +300,7 @@ builtin_define_decimal_float_constants (const char *name_prefix,\n   *p = 0;\n   /* fmt->p plus 1, to account for the decimal point and fmt->emax\n      minus 1 because the digits are nines, not 1.0.  */\n-  sprintf (&buf[fmt->p + 1], \"E%d%s\", fmt->emax - 1, suffix); \n+  sprintf (&buf[fmt->p + 1], \"E%d%s\", fmt->emax - 1, suffix);\n   builtin_define_with_value (name, buf, 0);\n \n   /* Compute epsilon (the difference between 1 and least value greater\n@@ -319,7 +319,7 @@ builtin_define_decimal_float_constants (const char *name_prefix,\n \t*p++ = '.';\n     }\n   *p = 0;\n-  sprintf (&buf[fmt->p], \"1E%d%s\", fmt->emin - 1, suffix); \n+  sprintf (&buf[fmt->p], \"1E%d%s\", fmt->emin - 1, suffix);\n   builtin_define_with_value (name, buf, 0);\n }\n \n@@ -935,7 +935,7 @@ builtin_define_with_int_value (const char *macro, HOST_WIDE_INT value)\n static void\n builtin_define_with_hex_fp_value (const char *macro,\n \t\t\t\t  tree type, int digits,\n-\t\t\t\t  const char *hex_str, \n+\t\t\t\t  const char *hex_str,\n \t\t\t\t  const char *fp_suffix,\n \t\t\t\t  const char *fp_cast)\n {\n@@ -961,7 +961,7 @@ builtin_define_with_hex_fp_value (const char *macro,\n   sprintf (buf1, \"%s%s\", dec_str, fp_suffix);\n   sprintf (buf2, fp_cast, buf1);\n   sprintf (buf1, \"%s=%s\", macro, buf2);\n-  \n+\n   cpp_define (parse_in, buf1);\n }\n "}, {"sha": "59179dd5858170797ed918710a9392d77e692db8", "filename": "gcc/c-decl.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -1102,7 +1102,7 @@ pop_scope (void)\n \t      error (\"label %q+D used but not defined\", p);\n \t      DECL_INITIAL (p) = error_mark_node;\n \t    }\n-\t  else \n+\t  else\n \t    warn_for_unused_label (p);\n \n \t  /* Labels go in BLOCK_VARS.  */\n@@ -1897,7 +1897,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t    }\n \t  else if (warn_traditional)\n \t    {\n-\t      warned |= warning (OPT_Wtraditional, \n+\t      warned |= warning (OPT_Wtraditional,\n \t\t\t\t \"non-static declaration of %q+D \"\n \t\t\t\t \"follows static declaration\", newdecl);\n \t    }\n@@ -1975,7 +1975,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t\t}\n \t      else if (warn_traditional)\n \t\t{\n-\t\t  warned |= warning (OPT_Wtraditional, \n+\t\t  warned |= warning (OPT_Wtraditional,\n \t\t\t\t     \"non-static declaration of %q+D \"\n \t\t\t\t     \"follows static declaration\", newdecl);\n \t\t}\n@@ -2046,14 +2046,14 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n       if (DECL_DECLARED_INLINE_P (newdecl)\n \t  && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (olddecl)))\n \t{\n-\t  warned |= warning (OPT_Wattributes, \n+\t  warned |= warning (OPT_Wattributes,\n \t\t\t     \"inline declaration of %qD follows \"\n \t\t\t     \"declaration with attribute noinline\", newdecl);\n \t}\n       else if (DECL_DECLARED_INLINE_P (olddecl)\n \t       && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (newdecl)))\n \t{\n-\t  warned |= warning (OPT_Wattributes, \n+\t  warned |= warning (OPT_Wattributes,\n \t\t\t     \"declaration of %q+D with attribute \"\n \t\t\t     \"noinline follows inline declaration \", newdecl);\n \t}\n@@ -2812,8 +2812,8 @@ implicit_decl_warning (tree id, tree olddecl)\n       if (flag_isoc99)\n \twarned = pedwarn (input_location, OPT_Wimplicit_function_declaration,\n \t\t\t  \"implicit declaration of function %qE\", id);\n-      else \n-\twarned = warning (OPT_Wimplicit_function_declaration, \n+      else\n+\twarned = warning (OPT_Wimplicit_function_declaration,\n \t\t\t  G_(\"implicit declaration of function %qE\"), id);\n       if (olddecl && warned)\n \tlocate_old_decl (olddecl);\n@@ -3497,10 +3497,10 @@ c_make_fname_decl (location_t loc, tree id, int type_dep)\n \n   if (current_function_decl\n       /* For invalid programs like this:\n-        \n+\n          void foo()\n          const char* p = __FUNCTION__;\n-        \n+\n \t the __FUNCTION__ is believed to appear in K&R style function\n \t parameter declarator.  In that case we still don't have\n \t function_scope.  */\n@@ -4653,7 +4653,7 @@ warn_variable_length_array (tree name, tree size)\n \t}\n       else\n \t{\n-\t  if (name) \n+\t  if (name)\n \t    pedwarn (input_location, OPT_Wvla,\n \t\t     \"ISO C90 forbids variable length array %qE\",\n \t\t     name);\n@@ -4880,11 +4880,11 @@ grokdeclarator (const struct c_declarator *declarator,\n       else\n \t{\n \t  if (name)\n-\t    pedwarn_c99 (loc, flag_isoc99 ? 0 : OPT_Wimplicit_int, \n+\t    pedwarn_c99 (loc, flag_isoc99 ? 0 : OPT_Wimplicit_int,\n \t\t\t \"type defaults to %<int%> in declaration of %qE\",\n \t\t\t name);\n \t  else\n-\t    pedwarn_c99 (input_location, flag_isoc99 ? 0 : OPT_Wimplicit_int, \n+\t    pedwarn_c99 (input_location, flag_isoc99 ? 0 : OPT_Wimplicit_int,\n \t\t\t \"type defaults to %<int%> in type name\");\n \t}\n     }\n@@ -4946,8 +4946,8 @@ grokdeclarator (const struct c_declarator *declarator,\n \t  || storage_class == csc_typedef))\n     {\n       if (storage_class == csc_auto)\n-\tpedwarn (loc, \n-\t\t (current_scope == file_scope) ? 0 : OPT_pedantic, \n+\tpedwarn (loc,\n+\t\t (current_scope == file_scope) ? 0 : OPT_pedantic,\n \t\t \"function definition declared %<auto%>\");\n       if (storage_class == csc_register)\n \terror_at (loc, \"function definition declared %<register%>\");\n@@ -6833,7 +6833,7 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n \n       if (pedantic && TREE_CODE (t) == RECORD_TYPE\n \t  && flexible_array_type_p (TREE_TYPE (x)))\n-\tpedwarn (DECL_SOURCE_LOCATION (x), OPT_pedantic, \n+\tpedwarn (DECL_SOURCE_LOCATION (x), OPT_pedantic,\n \t\t \"invalid use of structure with flexible array member\");\n \n       if (DECL_NAME (x))\n@@ -7284,7 +7284,7 @@ build_enumerator (location_t loc,\n      (6.4.4.3/2 in the C99 Standard).  GCC allows any integer type as\n      an extension.  */\n   else if (!int_fits_type_p (value, integer_type_node))\n-    pedwarn (loc, OPT_pedantic, \n+    pedwarn (loc, OPT_pedantic,\n \t     \"ISO C restricts enumerator values to range of %<int%>\");\n \n   /* The ISO C Standard mandates enumerators to have type int, even\n@@ -7396,7 +7396,7 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n     }\n \n   if (warn_about_return_type)\n-    pedwarn_c99 (loc, flag_isoc99 ? 0 \n+    pedwarn_c99 (loc, flag_isoc99 ? 0\n \t\t : (warn_return_type ? OPT_Wreturn_type : OPT_Wimplicit_int),\n \t\t \"return type defaults to %<int%>\");\n \n@@ -7693,7 +7693,7 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n \t  if (flag_isoc99)\n \t    pedwarn (DECL_SOURCE_LOCATION (decl),\n \t\t     0, \"type of %qD defaults to %<int%>\", decl);\n-\t  else \n+\t  else\n \t    warning_at (DECL_SOURCE_LOCATION (decl),\n \t\t\tOPT_Wmissing_parameter_type,\n \t\t\t\"type of %qD defaults to %<int%>\", decl);\n@@ -8039,7 +8039,7 @@ finish_function (void)\n   c_determine_visibility (fndecl);\n \n   /* For GNU C extern inline functions disregard inline limits.  */\n-  if (DECL_EXTERNAL (fndecl) \n+  if (DECL_EXTERNAL (fndecl)\n       && DECL_DECLARED_INLINE_P (fndecl))\n     DECL_DISREGARD_INLINE_LIMITS (fndecl) = 1;\n \n@@ -8896,7 +8896,7 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t    case RID_DFLOAT32:\n \t    case RID_DFLOAT64:\n \t    case RID_DFLOAT128:\n-\t      { \n+\t      {\n \t\tconst char *str;\n \t\tif (i == RID_DFLOAT32)\n \t\t  str = \"_Decimal32\";\n@@ -9065,7 +9065,7 @@ declspecs_add_scspec (struct c_declspecs *specs, tree scspec)\n \t      && C_IS_RESERVED_WORD (scspec));\n   i = C_RID_CODE (scspec);\n   if (specs->non_sc_seen_p)\n-    warning (OPT_Wold_style_declaration, \n+    warning (OPT_Wold_style_declaration,\n              \"%qE is not at beginning of declaration\", scspec);\n   switch (i)\n     {\n@@ -9187,7 +9187,7 @@ finish_declspecs (struct c_declspecs *specs)\n       else if (specs->complex_p)\n \t{\n \t  specs->typespec_word = cts_double;\n-\t  pedwarn (input_location, OPT_pedantic, \n+\t  pedwarn (input_location, OPT_pedantic,\n \t\t   \"ISO C does not support plain %<complex%> meaning \"\n \t\t   \"%<double complex%>\");\n \t}\n@@ -9232,7 +9232,7 @@ finish_declspecs (struct c_declspecs *specs)\n \tspecs->type = char_type_node;\n       if (specs->complex_p)\n \t{\n-\t  pedwarn (input_location, OPT_pedantic, \n+\t  pedwarn (input_location, OPT_pedantic,\n \t\t   \"ISO C does not support complex integer types\");\n \t  specs->type = build_complex_type (specs->type);\n \t}\n@@ -9258,7 +9258,7 @@ finish_declspecs (struct c_declspecs *specs)\n \t\t       : integer_type_node);\n       if (specs->complex_p)\n \t{\n-\t  pedwarn (input_location, OPT_pedantic, \n+\t  pedwarn (input_location, OPT_pedantic,\n \t\t   \"ISO C does not support complex integer types\");\n \t  specs->type = build_complex_type (specs->type);\n \t}"}, {"sha": "3d46bd2c813879a962ba225ce9540c500d374b59", "filename": "gcc/c-format.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -1775,7 +1775,7 @@ check_format_info_main (format_check_results *res,\n       scalar_identity_flag = 0;\n       if (fli)\n \t{\n-\t  while (fli->name != 0 \n+\t  while (fli->name != 0\n  \t\t && strncmp (fli->name, format_chars, strlen (fli->name)))\n \t      fli++;\n \t  if (fli->name != 0)"}, {"sha": "5535eaeb42edb0a94da705a8d78e2b5b83170713", "filename": "gcc/c-lex.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -433,7 +433,7 @@ c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags,\n \t}\n       *value = build_string (tok->val.str.len, (const char *) tok->val.str.text);\n       break;\n-      \n+\n     case CPP_PRAGMA:\n       *value = build_int_cst (NULL, tok->val.pragma);\n       break;\n@@ -588,11 +588,11 @@ interpret_integer (const cpp_token *token, unsigned int flags)\n       type = integer_types[itk];\n       if (itk > itk_unsigned_long\n \t  && (flags & CPP_N_WIDTH) != CPP_N_LARGE)\n-\temit_diagnostic \n+\temit_diagnostic\n \t  ((c_dialect_cxx () ? cxx_dialect == cxx98 : !flag_isoc99)\n \t   ? DK_PEDWARN : DK_WARNING,\n \t   input_location, OPT_Wlong_long,\n-\t   (flags & CPP_N_UNSIGNED) \n+\t   (flags & CPP_N_UNSIGNED)\n \t   ? \"integer constant is too large for %<unsigned long%> type\"\n \t   : \"integer constant is too large for %<long%> type\");\n     }\n@@ -689,9 +689,9 @@ interpret_float (const cpp_token *token, unsigned int flags)\n      has any suffixes, cut them off; REAL_VALUE_ATOF/ REAL_VALUE_HTOF\n      can't handle them.  */\n   copylen = token->val.str.len;\n-  if (flags & CPP_N_DFLOAT) \n+  if (flags & CPP_N_DFLOAT)\n     copylen -= 2;\n-  else \n+  else\n     {\n       if ((flags & CPP_N_WIDTH) != CPP_N_MEDIUM)\n \t/* Must be an F or L or machine defined suffix.  */\n@@ -732,7 +732,7 @@ interpret_float (const cpp_token *token, unsigned int flags)\n     {\n       REAL_VALUE_TYPE realvoidmode;\n       int overflow = real_from_string (&realvoidmode, copy);\n-      if (overflow < 0 || !REAL_VALUES_EQUAL (realvoidmode, dconst0)) \n+      if (overflow < 0 || !REAL_VALUES_EQUAL (realvoidmode, dconst0))\n \twarning (OPT_Woverflow, \"floating constant truncated to zero\");\n     }\n "}, {"sha": "6f1cb99720e5bc7080494f6730f069a68d7b403e", "filename": "gcc/c-omp.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-omp.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -1,4 +1,4 @@\n-/* This file contains routines to construct GNU OpenMP constructs, \n+/* This file contains routines to construct GNU OpenMP constructs,\n    called from parsing in the C and C++ front ends.\n \n    Copyright (C) 2005, 2007, 2008, 2009 Free Software Foundation, Inc.\n@@ -154,7 +154,7 @@ c_finish_omp_atomic (location_t loc, enum tree_code code, tree lhs, tree rhs)\n       \t\t\t input_location, rhs, NULL_TREE);\n   if (x == error_mark_node)\n     return error_mark_node;\n-  gcc_assert (TREE_CODE (x) == MODIFY_EXPR);  \n+  gcc_assert (TREE_CODE (x) == MODIFY_EXPR);\n   rhs = TREE_OPERAND (x, 1);\n \n   /* Punt the actual generation of atomic operations to common code.  */\n@@ -275,7 +275,7 @@ c_finish_omp_for (location_t locus, tree declv, tree initv, tree condv,\n \t      fail = true;\n \t    }\n \n-\t  init = build_modify_expr (elocus, decl, NULL_TREE, NOP_EXPR, \n+\t  init = build_modify_expr (elocus, decl, NULL_TREE, NOP_EXPR,\n \t      \t\t\t    /* FIXME diagnostics: This should\n \t\t\t\t       be the location of the INIT.  */\n \t      \t\t\t    elocus,"}, {"sha": "cf1e3723da12722ca24c99f7d76100dbeda69d11", "filename": "gcc/c-opts.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-opts.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -270,7 +270,7 @@ c_common_handle_option (size_t scode, const char *arg, int value)\n   /* Prevent resetting the language standard to a C dialect when the driver\n      has already determined that we're looking at assembler input.  */\n   bool preprocessing_asm_p = (cpp_get_options (parse_in)->lang == CLK_ASM);\n- \n+\n   switch (code)\n     {\n     default:\n@@ -466,10 +466,10 @@ c_common_handle_option (size_t scode, const char *arg, int value)\n       global_dc->warning_as_error_requested = value;\n       break;\n \n-    case OPT_Werror_implicit_function_declaration: \n+    case OPT_Werror_implicit_function_declaration:\n       /* For backward compatibility, this is the same as\n \t -Werror=implicit-function-declaration.  */\n-      enable_warning_as_error (\"implicit-function-declaration\", value, CL_C | CL_ObjC); \n+      enable_warning_as_error (\"implicit-function-declaration\", value, CL_C | CL_ObjC);\n       break;\n \n     case OPT_Wformat:\n@@ -1145,7 +1145,7 @@ c_common_post_options (const char **pfilename)\n     }\n \n   /* -Wimplicit-function-declaration is enabled by default for C99.  */\n-  if (warn_implicit_function_declaration == -1) \n+  if (warn_implicit_function_declaration == -1)\n     warn_implicit_function_declaration = flag_isoc99;\n \n   /* If we're allowing C++0x constructs, don't warn about C++0x\n@@ -1435,7 +1435,7 @@ sanitize_cpp_opts (void)\n \n   /* Wlong-long is disabled by default. It is enabled by:\n       [-pedantic | -Wtraditional] -std=[gnu|c]++98 ; or\n-      [-pedantic | -Wtraditional] -std=non-c99 . \n+      [-pedantic | -Wtraditional] -std=non-c99 .\n \n       Either -Wlong-long or -Wno-long-long override any other settings.  */\n   if (warn_long_long == -1)"}, {"sha": "37f779635132b9ca7f043b51f31429d0d82c7a3d", "filename": "gcc/c-parser.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -992,7 +992,7 @@ c_parser_translation_unit (c_parser *parser)\n {\n   if (c_parser_next_token_is (parser, CPP_EOF))\n     {\n-      pedwarn (c_parser_peek_token (parser)->location, OPT_pedantic, \n+      pedwarn (c_parser_peek_token (parser)->location, OPT_pedantic,\n \t       \"ISO C forbids an empty translation unit\");\n     }\n   else\n@@ -1078,7 +1078,7 @@ c_parser_external_declaration (c_parser *parser)\n \t}\n       break;\n     case CPP_SEMICOLON:\n-      pedwarn (c_parser_peek_token (parser)->location, OPT_pedantic, \n+      pedwarn (c_parser_peek_token (parser)->location, OPT_pedantic,\n \t       \"ISO C does not allow extra %<;%> outside of a function\");\n       c_parser_consume_token (parser);\n       break;\n@@ -1158,9 +1158,9 @@ c_parser_external_declaration (c_parser *parser)\n    C we also allow but diagnose declarations without declaration\n    specifiers, but only at top level (elsewhere they conflict with\n    other syntax).\n-   \n+\n    OpenMP:\n-   \n+\n    declaration:\n      threadprivate-directive  */\n \n@@ -1908,7 +1908,7 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n \t  /* Parse any stray semicolon.  */\n \t  if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n \t    {\n-\t      pedwarn (c_parser_peek_token (parser)->location, OPT_pedantic, \n+\t      pedwarn (c_parser_peek_token (parser)->location, OPT_pedantic,\n \t\t       \"extra semicolon in struct or union specified\");\n \t      c_parser_consume_token (parser);\n \t      continue;\n@@ -1937,7 +1937,7 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n \t  else\n \t    {\n \t      if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))\n-\t\tpedwarn (c_parser_peek_token (parser)->location, 0, \n+\t\tpedwarn (c_parser_peek_token (parser)->location, 0,\n \t\t\t \"no semicolon at end of struct or union\");\n \t      else\n \t\t{\n@@ -2033,7 +2033,7 @@ c_parser_struct_declaration (c_parser *parser)\n       tree ret;\n       if (!specs->type_seen_p)\n \t{\n-\t  pedwarn (decl_loc, OPT_pedantic, \n+\t  pedwarn (decl_loc, OPT_pedantic,\n \t\t   \"ISO C forbids member declarations with no members\");\n \t  shadow_tag_warned (specs, pedantic);\n \t  ret = NULL_TREE;\n@@ -2414,7 +2414,7 @@ c_parser_direct_declarator_inner (c_parser *parser, bool id_present,\n   /* Parse a sequence of array declarators and parameter lists.  */\n   if (c_parser_next_token_is (parser, CPP_OPEN_SQUARE))\n     {\n-      location_t brace_loc = c_parser_peek_token (parser)->location; \n+      location_t brace_loc = c_parser_peek_token (parser)->location;\n       struct c_declarator *declarator;\n       struct c_declspecs *quals_attrs = build_null_declspecs ();\n       bool static_seen;\n@@ -3143,7 +3143,7 @@ c_parser_initelt (c_parser *parser)\n       /* Old-style structure member designator.  */\n       set_init_label (c_parser_peek_token (parser)->value);\n       /* Use the colon as the error location.  */\n-      pedwarn (c_parser_peek_2nd_token (parser)->location, OPT_pedantic, \n+      pedwarn (c_parser_peek_2nd_token (parser)->location, OPT_pedantic,\n \t       \"obsolete use of designated initializer with %<:%>\");\n       c_parser_consume_token (parser);\n       c_parser_consume_token (parser);\n@@ -3278,7 +3278,7 @@ c_parser_initelt (c_parser *parser)\n \t\t  c_parser_consume_token (parser);\n \t\t  set_init_index (first, second);\n \t\t  if (second)\n-\t\t    pedwarn (ellipsis_loc, OPT_pedantic, \n+\t\t    pedwarn (ellipsis_loc, OPT_pedantic,\n \t\t\t     \"ISO C forbids specifying range of elements to initialize\");\n \t\t}\n \t      else\n@@ -3291,14 +3291,14 @@ c_parser_initelt (c_parser *parser)\n \t  if (c_parser_next_token_is (parser, CPP_EQ))\n \t    {\n \t      if (!flag_isoc99)\n-\t\tpedwarn (des_loc, OPT_pedantic, \n+\t\tpedwarn (des_loc, OPT_pedantic,\n \t\t\t \"ISO C90 forbids specifying subobject to initialize\");\n \t      c_parser_consume_token (parser);\n \t    }\n \t  else\n \t    {\n \t      if (des_seen == 1)\n-\t\tpedwarn (c_parser_peek_token (parser)->location, OPT_pedantic, \n+\t\tpedwarn (c_parser_peek_token (parser)->location, OPT_pedantic,\n \t\t\t \"obsolete use of designated initializer without %<=%>\");\n \t      else\n \t\t{\n@@ -3385,9 +3385,9 @@ c_parser_initval (c_parser *parser, struct c_expr *after)\n    old parser in requiring something after label declarations.\n    Although they are erroneous if the labels declared aren't defined,\n    is it useful for the syntax to be this way?\n-   \n+\n    OpenMP:\n-   \n+\n    block-item:\n      openmp-directive\n \n@@ -3496,7 +3496,7 @@ c_parser_compound_statement_nostart (c_parser *parser)\n \t  mark_valid_location_for_stdc_pragma (false);\n \t  c_parser_declaration_or_fndef (parser, true, true, true, true);\n \t  if (last_stmt)\n-\t    pedwarn_c90 (loc, \n+\t    pedwarn_c90 (loc,\n \t\t\t (pedantic && !flag_isoc99)\n \t\t\t ? OPT_pedantic\n \t\t\t : OPT_Wdeclaration_after_statement,\n@@ -3553,13 +3553,13 @@ c_parser_compound_statement_nostart (c_parser *parser)\n \t}\n       else if (c_parser_next_token_is_keyword (parser, RID_ELSE))\n         {\n-          if (parser->in_if_block) \n+          if (parser->in_if_block)\n             {\n \t      mark_valid_location_for_stdc_pragma (save_valid_for_pragma);\n               error_at (loc, \"\"\"expected %<}%> before %<else%>\");\n               return;\n             }\n-          else \n+          else\n             {\n               error_at (loc, \"%<else%> without a previous %<if%>\");\n               c_parser_consume_token (parser);\n@@ -3658,7 +3658,7 @@ c_parser_label (c_parser *parser)\n \t  error_at (c_parser_peek_token (parser)->location,\n \t\t    \"a label can only be part of a statement and \"\n \t\t    \"a declaration is not a statement\");\n-\t  c_parser_declaration_or_fndef (parser, /*fndef_ok*/ false, \n+\t  c_parser_declaration_or_fndef (parser, /*fndef_ok*/ false,\n \t\t\t\t\t /*nested*/ true, /*empty_ok*/ false,\n \t\t\t\t\t /*start_attr_ok*/ true);\n \t}\n@@ -4014,7 +4014,7 @@ c_parser_else_body (c_parser *parser)\n       add_stmt (build_empty_stmt (loc));\n       c_parser_consume_token (parser);\n     }\n-  else \n+  else\n     c_parser_statement_after_labels (parser);\n   return c_end_compound_stmt (else_loc, block, flag_isoc99);\n }\n@@ -4501,7 +4501,7 @@ c_parser_asm_clobbers (c_parser *parser)\n }\n \n /* Parse asm goto labels, a GNU extension.\n- \n+\n    asm-goto-operands:\n      identifier\n      asm-goto-operands , identifier\n@@ -4652,7 +4652,7 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after)\n   if (c_parser_next_token_is (parser, CPP_COLON))\n     {\n       tree eptype = NULL_TREE;\n-      pedwarn (c_parser_peek_token (parser)->location, OPT_pedantic, \n+      pedwarn (c_parser_peek_token (parser)->location, OPT_pedantic,\n \t       \"ISO C forbids omitting the middle term of a ?: expression\");\n       if (TREE_CODE (cond.value) == EXCESS_PRECISION_EXPR)\n \t{\n@@ -5436,7 +5436,7 @@ c_parser_postfix_expression (c_parser *parser)\n \t  c_parser_compound_statement_nostart (parser);\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t\t     \"expected %<)%>\");\n-\t  pedwarn (loc, OPT_pedantic, \n+\t  pedwarn (loc, OPT_pedantic,\n \t\t   \"ISO C forbids braced-groups within expressions\");\n \t  expr.value = c_finish_stmt_expr (brace_loc, stmt);\n \t}\n@@ -6216,7 +6216,7 @@ c_parser_objc_class_instance_variables (c_parser *parser)\n       /* Parse any stray semicolon.  */\n       if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n \t{\n-\t  pedwarn (c_parser_peek_token (parser)->location, OPT_pedantic, \n+\t  pedwarn (c_parser_peek_token (parser)->location, OPT_pedantic,\n \t\t   \"extra semicolon in struct or union specified\");\n \t  c_parser_consume_token (parser);\n \t  continue;\n@@ -6433,7 +6433,7 @@ c_parser_objc_method_definition (c_parser *parser)\n   if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n     {\n       c_parser_consume_token (parser);\n-      pedwarn (c_parser_peek_token (parser)->location, OPT_pedantic, \n+      pedwarn (c_parser_peek_token (parser)->location, OPT_pedantic,\n \t       \"extra semicolon in method definition specified\");\n     }\n   if (!c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n@@ -6470,7 +6470,7 @@ c_parser_objc_methodprotolist (c_parser *parser)\n       switch (c_parser_peek_token (parser)->type)\n \t{\n \tcase CPP_SEMICOLON:\n-\t  pedwarn (c_parser_peek_token (parser)->location, OPT_pedantic, \n+\t  pedwarn (c_parser_peek_token (parser)->location, OPT_pedantic,\n \t\t   \"ISO C does not allow extra %<;%> outside of a function\");\n \t  c_parser_consume_token (parser);\n \t  break;\n@@ -7046,7 +7046,7 @@ c_parser_pragma (c_parser *parser, enum pragma_context context)\n   c_parser_consume_pragma (parser);\n   c_invoke_pragma_handler (id);\n \n-  /* Skip to EOL, but suppress any error message.  Those will have been \n+  /* Skip to EOL, but suppress any error message.  Those will have been\n      generated by the handler routine through calling error, as opposed\n      to calling c_parser_error.  */\n   parser->error = true;\n@@ -7810,7 +7810,7 @@ c_parser_omp_structured_block (c_parser *parser)\n    binop:\n      +, *, -, /, &, ^, |, <<, >>\n \n-  where x is an lvalue expression with scalar type.  \n+  where x is an lvalue expression with scalar type.\n \n   LOC is the location of the #pragma token.  */\n \n@@ -8320,7 +8320,7 @@ c_parser_omp_ordered (location_t loc, c_parser *parser)\n \n    section-sequence:\n      section-directive[opt] structured-block\n-     section-sequence section-directive structured-block  \n+     section-sequence section-directive structured-block\n \n     SECTIONS_LOC is the location of the #pragma omp sections.  */\n "}, {"sha": "352ee098a0e2ea7c00ffb479c892cc4ee4a93ba1", "filename": "gcc/c-pretty-print.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -847,7 +847,7 @@ pp_c_integer_constant (c_pretty_printer *pp, tree i)\n \t  high = ~high + !low;\n \t  low = -low;\n \t}\n-      sprintf (pp_buffer (pp)->digit_buffer, HOST_WIDE_INT_PRINT_DOUBLE_HEX, \n+      sprintf (pp_buffer (pp)->digit_buffer, HOST_WIDE_INT_PRINT_DOUBLE_HEX,\n \t       (unsigned HOST_WIDE_INT) high, (unsigned HOST_WIDE_INT) low);\n       pp_string (pp, pp_buffer (pp)->digit_buffer);\n     }\n@@ -1953,7 +1953,7 @@ pp_c_conditional_expression (c_pretty_printer *pp, tree e)\n static void\n pp_c_assignment_expression (c_pretty_printer *pp, tree e)\n {\n-  if (TREE_CODE (e) == MODIFY_EXPR \n+  if (TREE_CODE (e) == MODIFY_EXPR\n       || TREE_CODE (e) == INIT_EXPR)\n     {\n       pp_c_unary_expression (pp, TREE_OPERAND (e, 0));"}, {"sha": "2309d51d58914c5726881ff92db7a0310cdcbadf", "filename": "gcc/c-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -521,7 +521,7 @@ extern struct c_expr c_expr_sizeof_expr (location_t, struct c_expr);\n extern struct c_expr c_expr_sizeof_type (location_t, struct c_type_name *);\n extern struct c_expr parser_build_unary_op (location_t, enum tree_code,\n     \t\t\t\t\t    struct c_expr);\n-extern struct c_expr parser_build_binary_op (location_t, \n+extern struct c_expr parser_build_binary_op (location_t,\n     \t\t\t\t\t     enum tree_code, struct c_expr,\n \t\t\t\t\t     struct c_expr);\n extern tree build_conditional_expr (location_t, tree, bool, tree, tree,"}, {"sha": "184b4063709dc65e6cb4f18b9bff2f7dee114954", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -566,7 +566,7 @@ composite_type (tree t1, tree t2)\n \t\t      {\n \t\t\tTREE_VALUE (n) = composite_type (TREE_TYPE (memb),\n \t\t\t\t\t\t\t TREE_VALUE (p2));\n-\t\t\tpedwarn (input_location, OPT_pedantic, \n+\t\t\tpedwarn (input_location, OPT_pedantic,\n \t\t\t\t \"function types not truly compatible in ISO C\");\n \t\t\tgoto parm_done;\n \t\t      }\n@@ -591,7 +591,7 @@ composite_type (tree t1, tree t2)\n \t\t      {\n \t\t\tTREE_VALUE (n) = composite_type (TREE_TYPE (memb),\n \t\t\t\t\t\t\t TREE_VALUE (p1));\n-\t\t\tpedwarn (input_location, OPT_pedantic, \n+\t\t\tpedwarn (input_location, OPT_pedantic,\n \t\t\t\t \"function types not truly compatible in ISO C\");\n \t\t\tgoto parm_done;\n \t\t      }\n@@ -2261,10 +2261,10 @@ build_array_ref (location_t loc, tree array, tree index)\n \t  while (TREE_CODE (foo) == COMPONENT_REF)\n \t    foo = TREE_OPERAND (foo, 0);\n \t  if (TREE_CODE (foo) == VAR_DECL && C_DECL_REGISTER (foo))\n-\t    pedwarn (loc, OPT_pedantic, \n+\t    pedwarn (loc, OPT_pedantic,\n \t\t     \"ISO C forbids subscripting %<register%> array\");\n \t  else if (!flag_isoc99 && !lvalue_p (foo))\n-\t    pedwarn (loc, OPT_pedantic, \n+\t    pedwarn (loc, OPT_pedantic,\n \t\t     \"ISO C90 forbids subscripting non-lvalue array\");\n \t}\n \n@@ -2347,7 +2347,7 @@ build_external_ref (location_t loc, tree id, int fun, tree *type)\n     warn_deprecated_use (ref, NULL_TREE);\n \n   /* Recursive call does not count as usage.  */\n-  if (ref != current_function_decl) \n+  if (ref != current_function_decl)\n     {\n       TREE_USED (ref) = 1;\n     }\n@@ -2566,7 +2566,7 @@ build_function_call_vec (location_t loc, tree function, VEC(tree,gc) *params,\n   tree tem;\n   int nargs;\n   tree *argarray;\n-  \n+\n \n   /* Strip NON_LVALUE_EXPRs, etc., since we aren't using as an lvalue.  */\n   STRIP_TYPE_NOPS (function);\n@@ -2690,7 +2690,7 @@ build_function_call_vec (location_t loc, tree function, VEC(tree,gc) *params,\n       && !strncmp (IDENTIFIER_POINTER (name), \"__builtin_\", 10))\n     {\n       if (require_constant_value)\n-\tresult = \n+\tresult =\n \t  fold_build_call_array_initializer_loc (loc, TREE_TYPE (fntype),\n \t\t\t\t\t\t function, nargs, argarray);\n       else\n@@ -3107,8 +3107,8 @@ parser_build_binary_op (location_t location, enum tree_code code,\n     warning_at (location, OPT_Waddress,\n \t\t\"comparison with string literal results in unspecified behavior\");\n \n-  if (TREE_OVERFLOW_P (result.value) \n-      && !TREE_OVERFLOW_P (arg1.value) \n+  if (TREE_OVERFLOW_P (result.value)\n+      && !TREE_OVERFLOW_P (arg1.value)\n       && !TREE_OVERFLOW_P (arg2.value))\n     overflow_warning (location, result.value);\n \n@@ -3170,10 +3170,10 @@ pointer_diff (location_t loc, tree op0, tree op1)\n \n \n   if (TREE_CODE (target_type) == VOID_TYPE)\n-    pedwarn (loc, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+    pedwarn (loc, pedantic ? OPT_pedantic : OPT_Wpointer_arith,\n \t     \"pointer of type %<void *%> used in subtraction\");\n   if (TREE_CODE (target_type) == FUNCTION_TYPE)\n-    pedwarn (loc, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+    pedwarn (loc, pedantic ? OPT_pedantic : OPT_Wpointer_arith,\n \t     \"pointer to a function used in subtraction\");\n \n   /* If the conversion to ptrdiff_type does anything like widening or\n@@ -3337,7 +3337,7 @@ build_unary_op (location_t location,\n       else if (typecode == COMPLEX_TYPE)\n \t{\n \t  code = CONJ_EXPR;\n-\t  pedwarn (location, OPT_pedantic, \n+\t  pedwarn (location, OPT_pedantic,\n \t\t   \"ISO C does not support %<~%> for complex conjugation\");\n \t  if (!noconvert)\n \t    arg = default_conversion (arg);\n@@ -3456,7 +3456,7 @@ build_unary_op (location_t location,\n \t{\n \t  tree real, imag;\n \n-\t  pedwarn (location, OPT_pedantic, \n+\t  pedwarn (location, OPT_pedantic,\n \t\t   \"ISO C does not support %<++%> and %<--%> on complex types\");\n \n \t  arg = stabilize_reference (arg);\n@@ -3507,10 +3507,10 @@ build_unary_op (location_t location,\n \t\t     || TREE_CODE (TREE_TYPE (argtype)) == VOID_TYPE)\n \t      {\n \t\tif (code == PREINCREMENT_EXPR || code == POSTINCREMENT_EXPR)\n-\t\t  pedwarn (location, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+\t\t  pedwarn (location, pedantic ? OPT_pedantic : OPT_Wpointer_arith,\n \t\t\t   \"wrong type argument to increment\");\n \t\telse\n-\t\t  pedwarn (location, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+\t\t  pedwarn (location, pedantic ? OPT_pedantic : OPT_Wpointer_arith,\n \t\t\t   \"wrong type argument to decrement\");\n \t      }\n \n@@ -4229,7 +4229,7 @@ build_compound_expr (location_t loc, tree expr1, tree expr2)\n \t\t   && CONVERT_EXPR_P (TREE_OPERAND (expr1, 1)))\n \t    ; /* (void) a, (void) b, c */\n \t  else\n-\t    warning_at (loc, OPT_Wunused_value, \n+\t    warning_at (loc, OPT_Wunused_value,\n \t\t\t\"left-hand operand of comma expression has no effect\");\n \t}\n     }\n@@ -4348,7 +4348,7 @@ handle_warn_cast_qual (tree type, tree otype)\n   while (TREE_CODE (in_type) == POINTER_TYPE);\n }\n \n-/* Build an expression representing a cast to type TYPE of expression EXPR.  \n+/* Build an expression representing a cast to type TYPE of expression EXPR.\n    LOC is the location of the cast-- typically the open paren of the cast.  */\n \n tree\n@@ -4395,7 +4395,7 @@ build_c_cast (location_t loc, tree type, tree expr)\n     {\n       if (TREE_CODE (type) == RECORD_TYPE\n \t  || TREE_CODE (type) == UNION_TYPE)\n-\tpedwarn (loc, OPT_pedantic, \n+\tpedwarn (loc, OPT_pedantic,\n \t\t \"ISO C forbids casting nonscalar to the same type\");\n     }\n   else if (TREE_CODE (type) == UNION_TYPE)\n@@ -4633,7 +4633,7 @@ c_cast_expr (location_t loc, struct c_type_name *type_name, tree expr)\n \n tree\n build_modify_expr (location_t location, tree lhs, tree lhs_origtype,\n-\t\t   enum tree_code modifycode, \n+\t\t   enum tree_code modifycode,\n \t\t   location_t rhs_loc, tree rhs, tree rhs_origtype)\n {\n   tree result;\n@@ -5096,7 +5096,7 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n \t    }\n \n \t  if (!fundecl || !DECL_IN_SYSTEM_HEADER (fundecl))\n-\t    pedwarn (location, OPT_pedantic, \n+\t    pedwarn (location, OPT_pedantic,\n \t\t     \"ISO C prohibits argument conversion to union type\");\n \n \t  rhs = fold_convert_loc (location, TREE_TYPE (memb), rhs);\n@@ -5435,7 +5435,7 @@ store_init_value (location_t init_loc, tree decl, tree init, tree origtype)\n \n   /* ANSI wants warnings about out-of-range constant initializers.  */\n   STRIP_TYPE_NOPS (value);\n-  if (TREE_STATIC (decl)) \n+  if (TREE_STATIC (decl))\n     constant_expression_warning (value);\n \n   /* Check if we need to set array size from compound literal size.  */\n@@ -5620,7 +5620,7 @@ pedwarn_init (location_t location, int opt, const char *msgid)\n     pedwarn (location, opt, \"(near initialization for %qs)\", ofwhat);\n }\n \n-/* Issue a warning for a bad initializer component.  \n+/* Issue a warning for a bad initializer component.\n \n    OPT is the OPT_W* value corresponding to the warning option that\n    controls this warning.  MSGID identifies the message.  The\n@@ -5648,7 +5648,7 @@ maybe_warn_string_init (tree type, struct c_expr expr)\n       && TREE_CODE (type) == ARRAY_TYPE\n       && TREE_CODE (expr.value) == STRING_CST\n       && expr.original_code != STRING_CST)\n-    pedwarn_init (input_location, OPT_pedantic, \n+    pedwarn_init (input_location, OPT_pedantic,\n \t\t  \"array initialized from parenthesized string constant\");\n }\n \n@@ -8264,7 +8264,7 @@ c_finish_return (location_t loc, tree retval, tree origtype)\n       if ((warn_return_type || flag_isoc99)\n \t  && valtype != 0 && TREE_CODE (valtype) != VOID_TYPE)\n \t{\n-\t  pedwarn_c99 (loc, flag_isoc99 ? 0 : OPT_Wreturn_type, \n+\t  pedwarn_c99 (loc, flag_isoc99 ? 0 : OPT_Wreturn_type,\n \t\t       \"%<return%> with no value, in \"\n \t\t       \"function returning non-void\");\n \t  no_warning = true;\n@@ -8274,9 +8274,9 @@ c_finish_return (location_t loc, tree retval, tree origtype)\n     {\n       current_function_returns_null = 1;\n       if (TREE_CODE (TREE_TYPE (retval)) != VOID_TYPE)\n-\tpedwarn (loc, 0, \n+\tpedwarn (loc, 0,\n \t\t \"%<return%> with a value, in function returning void\");\n-      else \n+      else\n \tpedwarn (loc, OPT_pedantic, \"ISO C forbids \"\n \t\t \"%<return%> with expression, in function returning void\");\n     }\n@@ -9499,7 +9499,7 @@ build_binary_op (location_t location, enum tree_code code,\n \t{\n \t  result_type = type0;\n \t  if (pedantic)\n-\t    pedwarn (location, OPT_pedantic, \n+\t    pedwarn (location, OPT_pedantic,\n \t\t     \"ordered comparison of pointer with integer zero\");\n \t  else if (extra_warnings)\n \t    warning_at (location, OPT_Wextra,\n@@ -9508,7 +9508,7 @@ build_binary_op (location_t location, enum tree_code code,\n       else if (code1 == POINTER_TYPE && null_pointer_constant_p (orig_op0))\n \t{\n \t  result_type = type1;\n-\t  pedwarn (location, OPT_pedantic, \n+\t  pedwarn (location, OPT_pedantic,\n \t\t   \"ordered comparison of pointer with integer zero\");\n \t}\n       else if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n@@ -9653,7 +9653,7 @@ build_binary_op (location_t location, enum tree_code code,\n       if (shorten && none_complex)\n \t{\n \t  final_type = result_type;\n-\t  result_type = shorten_binary_op (result_type, op0, op1, \n+\t  result_type = shorten_binary_op (result_type, op0, op1,\n \t\t\t\t\t   shorten == -1);\n \t}\n \n@@ -10220,11 +10220,11 @@ c_build_qualified_type (tree type, int type_quals)\n           else if (TYPE_CANONICAL (element_type) != element_type\n                    || (domain && TYPE_CANONICAL (domain) != domain))\n             {\n-              tree unqualified_canon \n+              tree unqualified_canon\n                 = build_array_type (TYPE_CANONICAL (element_type),\n-                                    domain? TYPE_CANONICAL (domain) \n+                                    domain? TYPE_CANONICAL (domain)\n                                           : NULL_TREE);\n-              TYPE_CANONICAL (t) \n+              TYPE_CANONICAL (t)\n                 = c_build_qualified_type (unqualified_canon, type_quals);\n             }\n           else"}, {"sha": "e12deb73ead0d5939663618c891d21fa224fd90b", "filename": "gcc/caller-save.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -311,7 +311,7 @@ init_save_areas (void)\n     for (j = 1; j <= MOVE_MAX_WORDS; j++)\n       regno_save_mem[i][j] = 0;\n   save_slots_num = 0;\n-    \n+\n }\n \n /* The structure represents a hard register which should be saved\n@@ -394,7 +394,7 @@ saved_hard_reg_compare_func (const void *v1p, const void *v2p)\n {\n   const struct saved_hard_reg *p1 = *(struct saved_hard_reg * const *) v1p;\n   const struct saved_hard_reg *p2 = *(struct saved_hard_reg * const *) v2p;\n-  \n+\n   if (flag_omit_frame_pointer)\n     {\n       if (p1->call_freq - p2->call_freq != 0)\n@@ -467,7 +467,7 @@ setup_save_areas (void)\n       int best_slot_num;\n       int prev_save_slots_num;\n       rtx prev_save_slots[FIRST_PSEUDO_REGISTER];\n-      \n+\n       initiate_saved_hard_regs ();\n       /* Create hard reg saved regs.  */\n       for (chain = reload_insn_chain; chain != 0; chain = next)\n@@ -510,10 +510,10 @@ setup_save_areas (void)\n \t    {\n \t      int r = reg_renumber[regno];\n \t      int bound;\n-\t      \n+\n \t      if (r < 0)\n \t\tcontinue;\n-\t      \n+\n \t      bound = r + hard_regno_nregs[r][PSEUDO_REGNO_MODE (regno)];\n \t      for (; r < bound; r++)\n \t\tif (TEST_HARD_REG_BIT (used_regs, r))\n@@ -568,7 +568,7 @@ setup_save_areas (void)\n \t    {\n \t      int r = reg_renumber[regno];\n \t      int bound;\n-\t      \n+\n \t      if (r < 0)\n \t\tcontinue;\n \n@@ -686,17 +686,17 @@ setup_save_areas (void)\n       /* Now run through all the call-used hard-registers and allocate\n \t space for them in the caller-save area.  Try to allocate space\n \t in a manner which allows multi-register saves/restores to be done.  */\n-      \n+\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tfor (j = MOVE_MAX_WORDS; j > 0; j--)\n \t  {\n \t    int do_save = 1;\n-\t    \n+\n \t    /* If no mode exists for this size, try another.  Also break out\n \t       if we have already saved this hard register.  */\n \t    if (regno_save_mode[i][j] == VOIDmode || regno_save_mem[i][1] != 0)\n \t      continue;\n-\t    \n+\n \t    /* See if any register in this group has been saved.  */\n \t    for (k = 0; k < j; k++)\n \t      if (regno_save_mem[i + k][1])\n@@ -706,7 +706,7 @@ setup_save_areas (void)\n \t\t}\n \t    if (! do_save)\n \t      continue;\n-\t    \n+\n \t    for (k = 0; k < j; k++)\n \t      if (! TEST_HARD_REG_BIT (hard_regs_used, i + k))\n \t\t{\n@@ -715,7 +715,7 @@ setup_save_areas (void)\n \t\t}\n \t    if (! do_save)\n \t      continue;\n-\t    \n+\n \t    /* We have found an acceptable mode to store in.  Since\n \t       hard register is always saved in the widest mode\n \t       available, the mode may be wider than necessary, it is\n@@ -727,7 +727,7 @@ setup_save_areas (void)\n \t      = assign_stack_local_1 (regno_save_mode[i][j],\n \t\t\t\t      GET_MODE_SIZE (regno_save_mode[i][j]),\n \t\t\t\t      0, true);\n-\t    \n+\n \t    /* Setup single word save area just in case...  */\n \t    for (k = 0; k < j; k++)\n \t      /* This should not depend on WORDS_BIG_ENDIAN."}, {"sha": "34fde8b52808298183898696729acdf1eeb46640", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -903,7 +903,7 @@ store_unaligned_arguments_into_pseudos (struct arg_data *args, int num_actuals)\n }\n \n /* Fill in ARGS_SIZE and ARGS array based on the parameters found in\n-   CALL_EXPR EXP.  \n+   CALL_EXPR EXP.\n \n    NUM_ACTUALS is the total number of parameters.\n \n@@ -1343,7 +1343,7 @@ precompute_arguments (int num_actuals, struct arg_data *args)\n    compute and return the final value for MUST_PREALLOCATE.  */\n \n static int\n-finalize_must_preallocate (int must_preallocate, int num_actuals, \n+finalize_must_preallocate (int must_preallocate, int num_actuals,\n \t\t\t   struct arg_data *args, struct args_size *args_size)\n {\n   /* See if we have or want to preallocate stack space."}, {"sha": "834bb5cc2bd9c24547d0282d9cd05218ae56c850", "filename": "gcc/cfg.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -92,9 +92,9 @@ init_flow (struct function *the_fun)\n   EXIT_BLOCK_PTR_FOR_FUNCTION (the_fun)\n     = GGC_CNEW (struct basic_block_def);\n   EXIT_BLOCK_PTR_FOR_FUNCTION (the_fun)->index = EXIT_BLOCK;\n-  ENTRY_BLOCK_PTR_FOR_FUNCTION (the_fun)->next_bb \n+  ENTRY_BLOCK_PTR_FOR_FUNCTION (the_fun)->next_bb\n     = EXIT_BLOCK_PTR_FOR_FUNCTION (the_fun);\n-  EXIT_BLOCK_PTR_FOR_FUNCTION (the_fun)->prev_bb \n+  EXIT_BLOCK_PTR_FOR_FUNCTION (the_fun)->prev_bb\n     = ENTRY_BLOCK_PTR_FOR_FUNCTION (the_fun);\n }\n \f\n@@ -171,13 +171,13 @@ compact_blocks (void)\n \n   SET_BASIC_BLOCK (ENTRY_BLOCK, ENTRY_BLOCK_PTR);\n   SET_BASIC_BLOCK (EXIT_BLOCK, EXIT_BLOCK_PTR);\n-  \n+\n   if (df)\n     df_compact_blocks ();\n-  else \n+  else\n     {\n       basic_block bb;\n-      \n+\n       i = NUM_FIXED_BLOCKS;\n       FOR_EACH_BB (bb)\n \t{\n@@ -433,7 +433,7 @@ clear_bb_flags (void)\n   basic_block bb;\n \n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n-    bb->flags = (BB_PARTITION (bb)  \n+    bb->flags = (BB_PARTITION (bb)\n \t\t | (bb->flags & (BB_DISABLE_SCHEDULE + BB_RTL + BB_NON_LOCAL_GOTO_TARGET)));\n }\n \f\n@@ -544,7 +544,7 @@ dump_bb_info (basic_block bb, bool header, bool footer, int flags,\n       fprintf (file, HOST_WIDEST_INT_PRINT_DEC, bb->count);\n       fprintf (file, \", freq %i\", bb->frequency);\n       /* Both maybe_hot_bb_p & probably_never_executed_bb_p functions\n-\t crash without cfun. */ \n+\t crash without cfun. */\n       if (cfun && maybe_hot_bb_p (bb))\n \tfputs (\", maybe hot\", file);\n       if (cfun && probably_never_executed_bb_p (bb))\n@@ -584,7 +584,7 @@ dump_bb_info (basic_block bb, bool header, bool footer, int flags,\n \n /* Dump the register info to FILE.  */\n \n-void \n+void\n dump_reg_info (FILE *file)\n {\n   unsigned int i, max = max_reg_num ();\n@@ -598,14 +598,14 @@ dump_reg_info (FILE *file)\n   for (i = FIRST_PSEUDO_REGISTER; i < max; i++)\n     {\n       enum reg_class rclass, altclass;\n-      \n+\n       if (regstat_n_sets_and_refs)\n \tfprintf (file, \"\\nRegister %d used %d times across %d insns\",\n \t\t i, REG_N_REFS (i), REG_LIVE_LENGTH (i));\n       else if (df)\n \tfprintf (file, \"\\nRegister %d used %d times across %d insns\",\n \t\t i, DF_REG_USE_COUNT (i) + DF_REG_DEF_COUNT (i), REG_LIVE_LENGTH (i));\n-      \n+\n       if (REG_BASIC_BLOCK (i) >= NUM_FIXED_BLOCKS)\n \tfprintf (file, \" in block %d\", REG_BASIC_BLOCK (i));\n       if (regstat_n_sets_and_refs)\n@@ -627,7 +627,7 @@ dump_reg_info (FILE *file)\n       if (regno_reg_rtx[i] != NULL\n \t  && PSEUDO_REGNO_BYTES (i) != UNITS_PER_WORD)\n \tfprintf (file, \"; %d bytes\", PSEUDO_REGNO_BYTES (i));\n-      \n+\n       rclass = reg_preferred_class (i);\n       altclass = reg_alternate_class (i);\n       if (rclass != GENERAL_REGS || altclass != ALL_REGS)\n@@ -641,7 +641,7 @@ dump_reg_info (FILE *file)\n \t\t     reg_class_names[(int) rclass],\n \t\t     reg_class_names[(int) altclass]);\n \t}\n-      \n+\n       if (regno_reg_rtx[i] != NULL && REG_POINTER (regno_reg_rtx[i]))\n \tfputs (\"; pointer\", file);\n       fputs (\".\\n\", file);"}, {"sha": "22a0503c01336eab9dc43ee324f120a667139b13", "filename": "gcc/cfganal.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -653,7 +653,7 @@ connect_infinite_loops_to_exit (void)\n    true, unreachable blocks are deleted.  */\n \n int\n-post_order_compute (int *post_order, bool include_entry_exit, \n+post_order_compute (int *post_order, bool include_entry_exit,\n \t\t    bool delete_unreachable)\n {\n   edge_iterator *stack;\n@@ -719,9 +719,9 @@ post_order_compute (int *post_order, bool include_entry_exit,\n       post_order[post_order_num++] = ENTRY_BLOCK;\n       count = post_order_num;\n     }\n-  else \n+  else\n     count = post_order_num + 2;\n-  \n+\n   /* Delete the unreachable blocks if some were found and we are\n      supposed to do it.  */\n   if (delete_unreachable && (count != n_basic_blocks))\n@@ -731,11 +731,11 @@ post_order_compute (int *post_order, bool include_entry_exit,\n       for (b = ENTRY_BLOCK_PTR->next_bb; b != EXIT_BLOCK_PTR; b = next_bb)\n \t{\n \t  next_bb = b->next_bb;\n-\t  \n+\n \t  if (!(TEST_BIT (visited, b->index)))\n \t    delete_basic_block (b);\n \t}\n-      \n+\n       tidy_fallthru_edges ();\n     }\n \n@@ -745,16 +745,16 @@ post_order_compute (int *post_order, bool include_entry_exit,\n }\n \n \n-/* Helper routine for inverted_post_order_compute. \n+/* Helper routine for inverted_post_order_compute.\n    BB has to belong to a region of CFG\n    unreachable by inverted traversal from the exit.\n    i.e. there's no control flow path from ENTRY to EXIT\n    that contains this BB.\n    This can happen in two cases - if there's an infinite loop\n    or if there's a block that has no successor\n    (call to a function with no return).\n-   Some RTL passes deal with this condition by \n-   calling connect_infinite_loops_to_exit () and/or \n+   Some RTL passes deal with this condition by\n+   calling connect_infinite_loops_to_exit () and/or\n    add_noreturn_fake_exit_edges ().\n    However, those methods involve modifying the CFG itself\n    which may not be desirable.\n@@ -801,12 +801,12 @@ dfs_find_deadend (basic_block bb)\n    with no successors can't visit all blocks.\n    To solve this problem, we first do inverted traversal\n    starting from the blocks with no successor.\n-   And if there's any block left that's not visited by the regular \n+   And if there's any block left that's not visited by the regular\n    inverted traversal from EXIT,\n    those blocks are in such problematic region.\n-   Among those, we find one block that has \n+   Among those, we find one block that has\n    any visited predecessor (which is an entry into such a region),\n-   and start looking for a \"dead end\" from that block \n+   and start looking for a \"dead end\" from that block\n    and do another inverted traversal from that block.  */\n \n int\n@@ -833,14 +833,14 @@ inverted_post_order_compute (int *post_order)\n     if (EDGE_COUNT (bb->succs) == 0)\n       {\n         /* Push the initial edge on to the stack.  */\n-        if (EDGE_COUNT (bb->preds) > 0) \n+        if (EDGE_COUNT (bb->preds) > 0)\n           {\n             stack[sp++] = ei_start (bb->preds);\n             SET_BIT (visited, bb->index);\n           }\n       }\n \n-  do \n+  do\n     {\n       bool has_unvisited_bb = false;\n \n@@ -880,7 +880,7 @@ inverted_post_order_compute (int *post_order)\n             }\n         }\n \n-      /* Detect any infinite loop and activate the kludge. \n+      /* Detect any infinite loop and activate the kludge.\n          Note that this doesn't check EXIT_BLOCK itself\n          since EXIT_BLOCK is always added after the outer do-while loop.  */\n       FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n@@ -914,15 +914,15 @@ inverted_post_order_compute (int *post_order)\n \n       if (has_unvisited_bb && sp == 0)\n         {\n-          /* No blocks are reachable from EXIT at all. \n+          /* No blocks are reachable from EXIT at all.\n              Find a dead-end from the ENTRY, and restart the iteration. */\n           basic_block be = dfs_find_deadend (ENTRY_BLOCK_PTR);\n           gcc_assert (be != NULL);\n           SET_BIT (visited, be->index);\n           stack[sp++] = ei_start (be->preds);\n         }\n \n-      /* The only case the below while fires is \n+      /* The only case the below while fires is\n          when there's an infinite loop.  */\n     }\n   while (sp);\n@@ -940,14 +940,14 @@ inverted_post_order_compute (int *post_order)\n   REV_POST_ORDER is nonzero, return the reverse completion number for each\n   node.  Returns the number of nodes visited.  A depth first search\n   tries to get as far away from the starting point as quickly as\n-  possible. \n+  possible.\n \n   pre_order is a really a preorder numbering of the graph.\n   rev_post_order is really a reverse postorder numbering of the graph.\n  */\n \n int\n-pre_and_rev_post_order_compute (int *pre_order, int *rev_post_order, \n+pre_and_rev_post_order_compute (int *pre_order, int *rev_post_order,\n \t\t\t\tbool include_entry_exit)\n {\n   edge_iterator *stack;\n@@ -968,7 +968,7 @@ pre_and_rev_post_order_compute (int *pre_order, int *rev_post_order,\n       if (rev_post_order)\n \trev_post_order[rev_post_order_num--] = ENTRY_BLOCK;\n     }\n-  else \n+  else\n     rev_post_order_num -= NUM_FIXED_BLOCKS;\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n@@ -1165,12 +1165,12 @@ dfs_enumerate_from (basic_block bb, int reverse,\n   static sbitmap visited;\n   static unsigned v_size;\n \n-#define MARK_VISITED(BB) (SET_BIT (visited, (BB)->index)) \n-#define UNMARK_VISITED(BB) (RESET_BIT (visited, (BB)->index)) \n-#define VISITED_P(BB) (TEST_BIT (visited, (BB)->index)) \n+#define MARK_VISITED(BB) (SET_BIT (visited, (BB)->index))\n+#define UNMARK_VISITED(BB) (RESET_BIT (visited, (BB)->index))\n+#define VISITED_P(BB) (TEST_BIT (visited, (BB)->index))\n \n   /* Resize the VISITED sbitmap if necessary.  */\n-  size = last_basic_block; \n+  size = last_basic_block;\n   if (size < 10)\n     size = 10;\n "}, {"sha": "087b6240b9bf5b7f325015cdebdbd0141cc4950b", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -61,7 +61,7 @@ gimple_assign_rhs_to_tree (gimple stmt)\n {\n   tree t;\n   enum gimple_rhs_class grhs_class;\n-    \n+\n   grhs_class = get_gimple_rhs_class (gimple_expr_code (stmt));\n \n   if (grhs_class == GIMPLE_BINARY_RHS)\n@@ -373,7 +373,7 @@ stack_var_conflict_p (size_t x, size_t y)\n   gcc_assert (index < stack_vars_conflict_alloc);\n   return stack_vars_conflict[index];\n }\n- \n+\n /* Returns true if TYPE is or contains a union type.  */\n \n static bool\n@@ -962,7 +962,7 @@ defer_stack_allocation (tree var, bool toplevel)\n \n /* A subroutine of expand_used_vars.  Expand one variable according to\n    its flavor.  Variables to be placed on the stack are not actually\n-   expanded yet, merely recorded.  \n+   expanded yet, merely recorded.\n    When REALLY_EXPAND is false, only add stack values to be allocated.\n    Return stack usage this variable is supposed to take.\n */\n@@ -1285,7 +1285,7 @@ account_used_vars_for_block (tree block, bool toplevel)\n }\n \n /* Prepare for expanding variables.  */\n-static void \n+static void\n init_vars_expansion (void)\n {\n   tree t;\n@@ -1554,7 +1554,7 @@ label_rtx_for_bb (basic_block bb ATTRIBUTE_UNUSED)\n     return (rtx) *elt;\n \n   /* Find the tree label if it is present.  */\n-     \n+\n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       lab_stmt = gsi_stmt (gsi);\n@@ -3188,7 +3188,7 @@ expand_gimple_basic_block (basic_block bb)\n \t\t  /* Ignore this stmt if it is in the list of\n \t\t     replaceable expressions.  */\n \t\t  if (SA.values\n-\t\t      && bitmap_bit_p (SA.values, \n+\t\t      && bitmap_bit_p (SA.values,\n \t\t\t\t       SSA_NAME_VERSION (DEF_FROM_PTR (def_p))))\n \t\t    continue;\n \t\t}\n@@ -3451,7 +3451,7 @@ expand_stack_alignment (void)\n \n   if (! SUPPORTS_STACK_ALIGNMENT)\n     return;\n-  \n+\n   if (cfun->calls_alloca\n       || cfun->has_nonlocal_label\n       || crtl->has_nonlocal_goto)\n@@ -3496,7 +3496,7 @@ expand_stack_alignment (void)\n   /* Target has to redefine TARGET_GET_DRAP_RTX to support stack\n      alignment.  */\n   gcc_assert (targetm.calls.get_drap_rtx != NULL);\n-  drap_rtx = targetm.calls.get_drap_rtx (); \n+  drap_rtx = targetm.calls.get_drap_rtx ();\n \n   /* stack_realign_drap and drap_rtx must match.  */\n   gcc_assert ((stack_realign_drap != 0) == (drap_rtx != NULL));\n@@ -3575,10 +3575,10 @@ gimple_expand_cfg (void)\n   if (warn_stack_protect)\n     {\n       if (cfun->calls_alloca)\n-\twarning (OPT_Wstack_protector, \n+\twarning (OPT_Wstack_protector,\n \t\t \"not protecting local variables: variable length buffer\");\n       if (has_short_buffer && !crtl->stack_protect_guard)\n-\twarning (OPT_Wstack_protector, \n+\twarning (OPT_Wstack_protector,\n \t\t \"not protecting function: no buffer at least %d bytes long\",\n \t\t (int) PARAM_VALUE (PARAM_SSP_BUFFER_SIZE));\n     }"}, {"sha": "ad5fb6b6c4cb2f37744c91b73a6a28f2e1b4d797", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -770,7 +770,7 @@ make_forwarder_block (basic_block bb, bool (*redirect_edge_p) (edge),\n               && dummy->loop_father->header == dummy\n               && dummy->loop_father->latch == e_src)\n             dummy->loop_father->latch = jump;\n-          \n+\n           if (new_bb_cbk != NULL)\n             new_bb_cbk (jump);\n         }"}, {"sha": "574176805e2724949ff1b5363212dce0e2d5ddca", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -57,7 +57,7 @@ struct cfg_hooks\n   /* Creates a new basic block just after basic block B by splitting\n      everything after specified instruction I.  */\n   basic_block (*split_block) (basic_block b, void * i);\n-  \n+\n   /* Move block B immediately after block A.  */\n   bool (*move_block_after) (basic_block b, basic_block a);\n "}, {"sha": "9d23b16c116c46bb8faf72c870a151152e1e64b0", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -694,7 +694,7 @@ relink_block_chain (bool stay_in_cfglayout_mode)\n   free_original_copy_tables ();\n   if (stay_in_cfglayout_mode)\n     initialize_original_copy_tables ();\n-  \n+\n   /* Finally, put basic_block_info in the new order.  */\n   compact_blocks ();\n }\n@@ -928,7 +928,7 @@ fixup_reorder_chain (void)\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \tif (e->flags & EDGE_FALLTHRU)\n \t  break;\n-      \n+\n       if (e && !can_fallthru (e->src, e->dest))\n \tforce_nonfallthru (e);\n     }"}, {"sha": "0365f568b301f98d1e2512eecd5cff62e34118f6", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -523,7 +523,7 @@ flow_loops_find (struct loops *loops)\n    profile is usually too flat and unreliable for this (and it is mostly based\n    on the loop structure of the program, so it does not make much sense to\n    derive the loop structure from it).  */\n-   \n+\n static edge\n find_subloop_latch_edge_by_profile (VEC (edge, heap) *latches)\n {\n@@ -656,7 +656,7 @@ form_subloop (struct loop *loop, edge latch)\n   edge_iterator ei;\n   edge e, new_entry;\n   struct loop *new_loop;\n-      \n+\n   mfb_reis_set = pointer_set_create ();\n   FOR_EACH_EDGE (e, ei, loop->header->preds)\n     {\n@@ -892,7 +892,7 @@ get_loop_body_in_dom_order (const struct loop *loop)\n /* Gets body of a LOOP sorted via provided BB_COMPARATOR.  */\n \n basic_block *\n-get_loop_body_in_custom_order (const struct loop *loop, \n+get_loop_body_in_custom_order (const struct loop *loop,\n \t\t\t       int (*bb_comparator) (const void *, const void *))\n {\n   basic_block *bbs = get_loop_body (loop);\n@@ -983,7 +983,7 @@ loop_exit_free (void *ex)\n   for (; exit; exit = next)\n     {\n       next = exit->next_e;\n-\t  \n+\n       exit->next->prev = exit->prev;\n       exit->prev->next = exit->next;\n \n@@ -1037,7 +1037,7 @@ rescan_loop_exit (edge e, bool new_edge, bool removed)\n \t  exit->next_e = exits;\n \t  exits = exit;\n \t}\n-    } \n+    }\n \n   if (!exits && new_edge)\n     return;\n@@ -1523,7 +1523,7 @@ verify_loop_structure (void)\n \t      exit = get_exit_descriptions (e);\n \t      if (!exit)\n \t\t{\n-\t\t  error (\"Exit %d->%d not recorded\", \n+\t\t  error (\"Exit %d->%d not recorded\",\n \t\t\t e->src->index, e->dest->index);\n \t\t  err = 1;\n \t\t}\n@@ -1541,7 +1541,7 @@ verify_loop_structure (void)\n \n \t      if (eloops != 0)\n \t\t{\n-\t\t  error (\"Wrong list of exited loops for edge  %d->%d\", \n+\t\t  error (\"Wrong list of exited loops for edge  %d->%d\",\n \t\t\t e->src->index, e->dest->index);\n \t\t  err = 1;\n \t\t}"}, {"sha": "26f9050076a0095139f1cb14c6c81d469cc00fba", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -58,7 +58,7 @@ struct GTY ((chain_next (\"%h.next\"))) nb_iter_bound {\n      b) it is consistent with the result of number_of_iterations_exit.  */\n   double_int bound;\n \n-  /* True if the statement will cause the loop to be leaved the (at most) \n+  /* True if the statement will cause the loop to be leaved the (at most)\n      BOUND + 1-st time it is executed, that is, all the statements after it\n      are executed at most BOUND times.  */\n   bool is_exit;\n@@ -240,7 +240,7 @@ extern unsigned get_loop_body_with_size (const struct loop *, basic_block *,\n \t\t\t\t\t unsigned);\n extern basic_block *get_loop_body_in_dom_order (const struct loop *);\n extern basic_block *get_loop_body_in_bfs_order (const struct loop *);\n-extern basic_block *get_loop_body_in_custom_order (const struct loop *, \n+extern basic_block *get_loop_body_in_custom_order (const struct loop *,\n \t\t\t       int (*) (const void *, const void *));\n \n extern VEC (edge, heap) *get_loop_exit_edges (const struct loop *);\n@@ -293,7 +293,7 @@ extern struct loop *create_empty_loop_on_edge (edge, tree, tree, tree, tree,\n \t\t\t\t\t       tree *, tree *, struct loop *);\n extern struct loop * duplicate_loop (struct loop *, struct loop *);\n extern void duplicate_subloops (struct loop *, struct loop *);\n-extern bool duplicate_loop_to_header_edge (struct loop *, edge, \n+extern bool duplicate_loop_to_header_edge (struct loop *, edge,\n \t\t\t\t\t   unsigned, sbitmap, edge,\n  \t\t\t\t\t   VEC (edge, heap) **, int);\n extern struct loop *loopify (edge, edge,"}, {"sha": "1c77141af654947f9ac69cd2e4d1c96aec41bccf", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -164,7 +164,7 @@ fix_loop_placement (struct loop *loop)\n    placement of subloops of FROM->loop_father, that might also be altered due\n    to this change; the condition for them is similar, except that instead of\n    successors we consider edges coming out of the loops.\n- \n+\n    If the changes may invalidate the information about irreducible regions,\n    IRRED_INVALIDATED is set to true.  */\n \n@@ -330,7 +330,7 @@ remove_path (edge e)\n \t  {\n \t    SET_BIT (seen, ae->dest->index);\n \t    bord_bbs[n_bord_bbs++] = ae->dest;\n-\t  \n+\n \t    if (ae->flags & EDGE_IRREDUCIBLE_LOOP)\n \t      irred_invalidated = true;\n \t  }\n@@ -504,7 +504,7 @@ update_dominators_in_loop (struct loop *loop)\n }\n \n /* Creates an if region as shown above. CONDITION is used to create\n-   the test for the if. \n+   the test for the if.\n \n    |\n    |     -------------                 -------------\n@@ -549,7 +549,7 @@ create_empty_if_region_on_edge (edge entry_edge, tree condition)\n \n   succ_bb = entry_edge->dest;\n   cond_bb = split_edge (entry_edge);\n-  \n+\n   /* Insert condition in cond_bb.  */\n   gsi = gsi_last_bb (cond_bb);\n   simple_cond =\n@@ -558,7 +558,7 @@ create_empty_if_region_on_edge (edge entry_edge, tree condition)\n   cond_stmt = gimple_build_cond_from_tree (simple_cond, NULL_TREE, NULL_TREE);\n   gsi = gsi_last_bb (cond_bb);\n   gsi_insert_after (&gsi, cond_stmt, GSI_NEW_STMT);\n-  \n+\n   join_bb = split_edge (single_succ_edge (cond_bb));\n \n   e_true = single_succ_edge (cond_bb);\n@@ -839,7 +839,7 @@ unloop (struct loop *loop, bool *irred_invalidated)\n    condition stated in description of fix_loop_placement holds for them.\n    It is used in case when we removed some edges coming out of LOOP, which\n    may cause the right placement of LOOP inside loop tree to change.\n- \n+\n    IRRED_INVALIDATED is set to true if a change in the loop structures might\n    invalidate the information about irreducible regions.  */\n \n@@ -1320,7 +1320,7 @@ has_preds_from_loop (basic_block block, struct loop *loop)\n {\n   edge e;\n   edge_iterator ei;\n-  \n+\n   FOR_EACH_EDGE (e, ei, block->preds)\n     if (e->src->loop_father == loop)\n       return true;\n@@ -1331,7 +1331,7 @@ has_preds_from_loop (basic_block block, struct loop *loop)\n    CP_SIMPLE_PREHEADERS is set in FLAGS, we only force LOOP to have single\n    entry; otherwise we also force preheader block to have only one successor.\n    When CP_FALLTHRU_PREHEADERS is set in FLAGS, we force the preheader block\n-   to be a fallthru predecessor to the loop header and to have only \n+   to be a fallthru predecessor to the loop header and to have only\n    predecessors from outside of the loop.\n    The function also updates dominators.  */\n \n@@ -1360,7 +1360,7 @@ create_preheader (struct loop *loop, int flags)\n   if (nentry == 1)\n     {\n       bool need_forwarder_block = false;\n-      \n+\n       /* We do not allow entry block to be the loop preheader, since we\n \t     cannot emit code there.  */\n       if (single_entry->src == ENTRY_BLOCK_PTR)\n@@ -1416,7 +1416,7 @@ create_preheader (struct loop *loop, int flags)\n   if (dump_file)\n     fprintf (dump_file, \"Created preheader block for loop %i\\n\",\n \t     loop->num);\n-  \n+\n   if (flags & CP_FALLTHRU_PREHEADERS)\n     gcc_assert ((single_succ_edge (dummy)->flags & EDGE_FALLTHRU)\n                 && !JUMP_P (BB_END (dummy)));\n@@ -1524,7 +1524,7 @@ lv_adjust_loop_entry_edge (basic_block first_head, basic_block second_head,\n    is the ratio by that the frequencies in the original loop should\n    be scaled.  ELSE_SCALE is the ratio by that the frequencies in the\n    new loop should be scaled.\n-   \n+\n    If PLACE_AFTER is true, we place the new loop after LOOP in the\n    instruction stream, otherwise it is placed before LOOP.  */\n "}, {"sha": "1a47bfe7143274bbdce4c596394ef1c2846a4cd3", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -470,7 +470,7 @@ emit_insn_at_entry (rtx insn)\n }\n \n /* Update BLOCK_FOR_INSN of insns between BEGIN and END\n-   (or BARRIER if found) and notify df of the bb change. \n+   (or BARRIER if found) and notify df of the bb change.\n    The insn chain range is inclusive\n    (i.e. both BEGIN and END will be updated. */\n \n@@ -1256,7 +1256,7 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n   if (abnormal_edge_flags)\n     make_edge (src, target, abnormal_edge_flags);\n \n-  df_mark_solutions_dirty (); \n+  df_mark_solutions_dirty ();\n   return new_bb;\n }\n \n@@ -1612,7 +1612,7 @@ rtl_dump_bb (basic_block bb, FILE *outf, int indent, int flags ATTRIBUTE_UNUSED)\n   s_indent = (char *) alloca ((size_t) indent + 1);\n   memset (s_indent, ' ', (size_t) indent);\n   s_indent[indent] = '\\0';\n-  \n+\n   if (df)\n     {\n       df_dump_top (bb, outf);\n@@ -1679,7 +1679,7 @@ print_rtl_with_bb (FILE *outf, const_rtx rtx_first)\n \t    {\n \t      edge e;\n \t      edge_iterator ei;\n-\t      \n+\n \t      fprintf (outf, \";; Start of basic block (\");\n \t      FOR_EACH_EDGE (e, ei, bb->preds)\n \t\tfprintf (outf, \" %d\", e->src->index);"}, {"sha": "8fd5e7fbf084382f1c13004e5f83784e62503674", "filename": "gcc/cgraph.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -795,8 +795,8 @@ cgraph_set_call_stmt_including_clones (struct cgraph_node *orig,\n }\n \n /* Like cgraph_create_edge walk the clone tree and update all clones sharing\n-   same function body.  \n-   \n+   same function body.\n+\n    TODO: COUNT and LOOP_DEPTH should be properly distributed based on relative\n    frequencies of the clones.  */\n \n@@ -1853,7 +1853,7 @@ clone_function_name (tree decl)\n }\n \n /* Create callgraph node clone with new declaration.  The actual body will\n-   be copied later at compilation stage.  \n+   be copied later at compilation stage.\n \n    TODO: after merging in ipa-sra use function call notes instead of args_to_skip\n    bitmap interface.\n@@ -2004,7 +2004,7 @@ cgraph_function_body_availability (struct cgraph_node *node)\n    GIMPLE.\n \n    The function is assumed to be reachable and have address taken (so no\n-   API breaking optimizations are performed on it).  \n+   API breaking optimizations are performed on it).\n \n    Main work done by this function is to enqueue the function for later\n    processing to avoid need the passes to be re-entrant.  */"}, {"sha": "a683c5bc97092ec2f37fe91b085e69a988a28a14", "filename": "gcc/cgraph.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -227,7 +227,7 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\"))) cgraph_node {\n      ABSTRACT_DECL_ORIGIN of a reachable function.  */\n   unsigned abstract_and_needed : 1;\n   /* Set when function is reachable by call from other function\n-     that is either reachable or needed.  \n+     that is either reachable or needed.\n      This flag is computed at original cgraph construction and then\n      updated in cgraph_remove_unreachable_nodes.  Note that after\n      cgraph_remove_unreachable_nodes cgraph still can contain unreachable\n@@ -312,7 +312,7 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"))) cgrap\n   cgraph_inline_failed_t inline_failed;\n   /* Expected number of executions: calculated in profile.c.  */\n   gcov_type count;\n-  /* Expected frequency of executions within the function. \n+  /* Expected frequency of executions within the function.\n      When set to CGRAPH_FREQ_BASE, the edge is expected to be called once\n      per function call.  The range is 0 to CGRAPH_FREQ_MAX.  */\n   int frequency;\n@@ -669,7 +669,7 @@ cgraph_node_set_size (cgraph_node_set set)\n struct GTY(()) constant_descriptor_tree {\n   /* A MEM for the constant.  */\n   rtx rtl;\n-  \n+\n   /* The value of the constant.  */\n   tree value;\n "}, {"sha": "bcc66c0eecd47de44e409839fe006288915901da", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -33,7 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n \n /* Walk tree and record all calls and references to functions/variables.\n-   Called via walk_tree: TP is pointer to tree to be examined.  \n+   Called via walk_tree: TP is pointer to tree to be examined.\n    When DATA is non-null, record references to callgraph.\n    */\n \n@@ -222,14 +222,14 @@ struct gimple_opt_pass pass_build_cgraph_edges =\n };\n \n /* Record references to functions and other variables present in the\n-   initial value of DECL, a variable.  \n+   initial value of DECL, a variable.\n    When ONLY_VARS is true, we mark needed only variables, not functions.  */\n \n void\n record_references_in_initializer (tree decl, bool only_vars)\n {\n   struct pointer_set_t *visited_nodes = pointer_set_create ();\n-  walk_tree (&DECL_INITIAL (decl), record_reference, \n+  walk_tree (&DECL_INITIAL (decl), record_reference,\n             only_vars ? NULL : decl, visited_nodes);\n   pointer_set_destroy (visited_nodes);\n }"}, {"sha": "4a4e6a4b6e37d7e230be90390c587afe8152a5c5", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -151,8 +151,8 @@ static GTY (()) VEC(tree, gc) *static_dtors;\n \n /* When target does not have ctors and dtors, we call all constructor\n    and destructor by special initialization/destruction function\n-   recognized by collect2.  \n-   \n+   recognized by collect2.\n+\n    When we are going to build this function, collect all constructors and\n    destructors and turn them into normal functions.  */\n \n@@ -239,7 +239,7 @@ compare_ctor (const void *p1, const void *p2)\n   f2 = *(const tree *)p2;\n   priority1 = DECL_INIT_PRIORITY (f1);\n   priority2 = DECL_INIT_PRIORITY (f2);\n-  \n+\n   if (priority1 < priority2)\n     return -1;\n   else if (priority1 > priority2)\n@@ -265,7 +265,7 @@ compare_dtor (const void *p1, const void *p2)\n   f2 = *(const tree *)p2;\n   priority1 = DECL_FINI_PRIORITY (f1);\n   priority2 = DECL_FINI_PRIORITY (f2);\n-  \n+\n   if (priority1 < priority2)\n     return -1;\n   else if (priority1 > priority2)\n@@ -286,25 +286,25 @@ cgraph_build_cdtor_fns (void)\n     {\n       gcc_assert (!targetm.have_ctors_dtors);\n       qsort (VEC_address (tree, static_ctors),\n-\t     VEC_length (tree, static_ctors), \n+\t     VEC_length (tree, static_ctors),\n \t     sizeof (tree),\n \t     compare_ctor);\n       build_cdtor (/*ctor_p=*/true,\n \t\t   VEC_address (tree, static_ctors),\n-\t\t   VEC_length (tree, static_ctors)); \n+\t\t   VEC_length (tree, static_ctors));\n       VEC_truncate (tree, static_ctors, 0);\n     }\n \n   if (!VEC_empty (tree, static_dtors))\n     {\n       gcc_assert (!targetm.have_ctors_dtors);\n       qsort (VEC_address (tree, static_dtors),\n-\t     VEC_length (tree, static_dtors), \n+\t     VEC_length (tree, static_dtors),\n \t     sizeof (tree),\n \t     compare_dtor);\n       build_cdtor (/*ctor_p=*/false,\n \t\t   VEC_address (tree, static_dtors),\n-\t\t   VEC_length (tree, static_dtors)); \n+\t\t   VEC_length (tree, static_dtors));\n       VEC_truncate (tree, static_dtors, 0);\n     }\n }\n@@ -1689,7 +1689,7 @@ cgraph_copy_node_for_versioning (struct cgraph_node *old_version,\n     TREE_MAP is a mapping of tree nodes we want to replace with\n     new ones (according to results of prior analysis).\n     OLD_VERSION_NODE is the node that is versioned.\n-    It returns the new version's cgraph node. \n+    It returns the new version's cgraph node.\n     ARGS_TO_SKIP lists arguments to be omitted from functions\n     */\n \n@@ -1739,7 +1739,7 @@ cgraph_function_versioning (struct cgraph_node *old_version_node,\n \n   /* Update the call_expr on the edges to call the new version node. */\n   update_call_expr (new_version_node);\n-  \n+\n   cgraph_call_function_insertion_hooks (new_version_node);\n   return new_version_node;\n }"}, {"sha": "2de63b621788887c7c8879a8e79f4f97c4544646", "filename": "gcc/cif-code.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcif-code.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcif-code.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcif-code.def?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -61,7 +61,7 @@ DEFCIFCODE(MAX_INLINE_INSNS_SINGLE_LIMIT,\n DEFCIFCODE(MAX_INLINE_INSNS_AUTO_LIMIT,\n \t   N_(\"--param max-inline-insns-auto limit reached\"))\n DEFCIFCODE(INLINE_UNIT_GROWTH_LIMIT,\n-\t   N_(\"--param inline-unit-growth limit reached\")) \n+\t   N_(\"--param inline-unit-growth limit reached\"))\n \n /* Recursive inlining.  */\n DEFCIFCODE(RECURSIVE_INLINING, N_(\"recursive inlining\"))"}, {"sha": "aa4b549b11b0d06fbc34d72ddbf1055744d2c0cf", "filename": "gcc/collect2.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -349,7 +349,7 @@ typedef enum {\n enum scanfilter_masks {\n   SCAN_NOTHING = 0,\n \n-  SCAN_CTOR = 1 << SYM_CTOR, \n+  SCAN_CTOR = 1 << SYM_CTOR,\n   SCAN_DTOR = 1 << SYM_DTOR,\n   SCAN_INIT = 1 << SYM_INIT,\n   SCAN_FINI = 1 << SYM_FINI,\n@@ -1157,7 +1157,7 @@ main (int argc, char **argv)\n   char **ld1_argv;\n   const char **ld1;\n   bool use_plugin = false;\n-  \n+\n   /* The kinds of symbols we will have to consider when scanning the\n      outcome of a first pass link.  This is ALL to start with, then might\n      be adjusted before getting to the first pass link per se, typically on\n@@ -1653,25 +1653,25 @@ main (int argc, char **argv)\n      would otherwise reference them all, hence drag all the corresponding\n      objects even if nothing else is referenced.  */\n   {\n-    const char **export_object_lst \n+    const char **export_object_lst\n       = CONST_CAST2 (const char **, char **, object_lst);\n-    \n+\n     struct id *list = libs.first;\n \n     /* Compute the filter to use from the current one, do scan, then adjust\n        the \"current\" filter to remove what we just included here.  This will\n        control whether we need a first pass link later on or not, and what\n        will remain to be scanned there.  */\n-    \n+\n     scanfilter this_filter\n       = shared_obj ? ld1_filter : (ld1_filter & ~SCAN_DWEH);\n-    \n+\n     while (export_object_lst < object)\n       scan_prog_file (*export_object_lst++, PASS_OBJ, this_filter);\n-    \n+\n     for (; list; list = list->next)\n       scan_prog_file (list->name, PASS_FIRST, this_filter);\n-    \n+\n     ld1_filter = ld1_filter & ~this_filter;\n   }\n \n@@ -1744,9 +1744,9 @@ main (int argc, char **argv)\n \n   /* Load the program, searching all libraries and attempting to provide\n      undefined symbols from repository information.\n-     \n+\n      If -r or they will be run via some other method, do not build the\n-     constructor or destructor list, just return now.  */  \n+     constructor or destructor list, just return now.  */\n   {\n     bool early_exit\n       = rflag || (! DO_COLLECT_EXPORT_LIST && ! do_collecting);\n@@ -1759,10 +1759,10 @@ main (int argc, char **argv)\n        objects and libraries has performed above.  In the !shared_obj case, we\n        expect the relevant tables to be dragged together with their associated\n        functions from precise cross reference insertions by the compiler.  */\n-       \n+\n     if (early_exit || ld1_filter != SCAN_NOTHING)\n       do_tlink (ld1_argv, object_lst);\n-    \n+\n     if (early_exit)\n       {\n #ifdef COLLECT_EXPORT_LIST"}, {"sha": "cdc677d17c73eb0d823af65df38d67d8e7471453", "filename": "gcc/combine.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -767,7 +767,7 @@ do_SUBST_MODE (rtx *into, enum machine_mode newval)\n /* Subroutine of try_combine.  Determine whether the combine replacement\n    patterns NEWPAT, NEWI2PAT and NEWOTHERPAT are cheaper according to\n    insn_rtx_cost that the original instruction sequence I1, I2, I3 and\n-   undobuf.other_insn.  Note that I1 and/or NEWI2PAT may be NULL_RTX. \n+   undobuf.other_insn.  Note that I1 and/or NEWI2PAT may be NULL_RTX.\n    NEWOTHERPAT and undobuf.other_insn may also both be NULL_RTX.  This\n    function returns false, if the costs of all instructions can be\n    estimated, and the replacements are more expensive than the original\n@@ -912,7 +912,7 @@ create_log_links (void)\n      register and establishing log links when def is encountered.\n      Note that we do not clear next_use array in order to save time,\n      so we have to test whether the use is in the same basic block as def.\n-              \n+\n      There are a few cases below when we do not consider the definition or\n      usage -- these are taken from original flow.c did. Don't ask me why it is\n      done this way; I don't know and if it works, I don't want to know.  */\n@@ -1367,7 +1367,7 @@ setup_incoming_promotions (rtx first)\n       mode2 = TYPE_MODE (DECL_ARG_TYPE (arg));\n       uns3 = TYPE_UNSIGNED (DECL_ARG_TYPE (arg));\n \n-      /* The mode and signedness of the argument as it is actually passed, \n+      /* The mode and signedness of the argument as it is actually passed,\n          after any TARGET_PROMOTE_FUNCTION_ARGS-driven ABI promotions.  */\n       mode3 = promote_function_mode (DECL_ARG_TYPE (arg), mode2, &uns3,\n \t\t\t\t     TREE_TYPE (cfun->decl), 0);\n@@ -3887,7 +3887,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \n     if (newi2pat && new_i2_notes)\n       distribute_notes (new_i2_notes, i2, i2, NULL_RTX, NULL_RTX, NULL_RTX);\n-    \n+\n     if (new_i3_notes)\n       distribute_notes (new_i3_notes, i3, i3, NULL_RTX, NULL_RTX, NULL_RTX);\n \n@@ -4033,7 +4033,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t}\n       df_insn_rescan (i3);\n     }\n-  \n+\n   /* Set new_direct_jump_p if a new return or simple jump instruction\n      has been created.  Adjust the CFG accordingly.  */\n \n@@ -4061,7 +4061,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n       *new_direct_jump_p = 1;\n       update_cfg_for_uncondjump (i3);\n     }\n-  \n+\n   combine_successes++;\n   undo_commit ();\n \n@@ -5272,7 +5272,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t}\n \n       /* Try simplify a*(b/c) as (a*b)/c.  */\n-      if (FLOAT_MODE_P (mode) && flag_associative_math \n+      if (FLOAT_MODE_P (mode) && flag_associative_math\n \t  && GET_CODE (XEXP (x, 0)) == DIV)\n \t{\n \t  rtx tem = simplify_binary_operation (MULT, mode,\n@@ -10175,7 +10175,7 @@ recog_for_combine (rtx *pnewpat, rtx insn, rtx *pnotes)\n \t  if (REG_P (XEXP (XVECEXP (newpat, 0, i), 0))\n \t      && ! reg_dead_at_p (XEXP (XVECEXP (newpat, 0, i), 0), insn))\n \t    return -1;\n-\t  if (GET_CODE (XEXP (XVECEXP (newpat, 0, i), 0)) != SCRATCH) \n+\t  if (GET_CODE (XEXP (XVECEXP (newpat, 0, i), 0)) != SCRATCH)\n \t    {\n \t      gcc_assert (REG_P (XEXP (XVECEXP (newpat, 0, i), 0)));\n \t      notes = alloc_reg_note (REG_UNUSED,"}, {"sha": "4fe95ced915aae7aed263527177d3a8307772404", "filename": "gcc/convert.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -434,7 +434,7 @@ convert_to_integer (tree type, tree expr)\n       tree s_intype = TREE_TYPE (s_expr);\n       const enum built_in_function fcode = builtin_mathfn_code (s_expr);\n       tree fn = 0;\n-      \n+\n       switch (fcode)\n         {\n \tCASE_FLT_FN (BUILT_IN_CEIL):\n@@ -494,7 +494,7 @@ convert_to_integer (tree type, tree expr)\n \tdefault:\n \t  break;\n \t}\n-      \n+\n       if (fn)\n         {\n \t  tree newexpr = build_call_expr (fn, 1, CALL_EXPR_ARG (s_expr, 0));\n@@ -515,7 +515,7 @@ convert_to_integer (tree type, tree expr)\n       tree s_intype = TREE_TYPE (s_expr);\n       const enum built_in_function fcode = builtin_mathfn_code (s_expr);\n       tree fn = 0;\n-       \n+\n       switch (fcode)\n \t{\n \tCASE_FLT_FN (BUILT_IN_LOGB):"}, {"sha": "e04d22b7a88d98fb6d5431c2c553f9ec0d175030", "filename": "gcc/coverage.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -201,7 +201,7 @@ read_counts_file (void)\n \n   /* Read and discard the stamp.  */\n   gcov_read_unsigned ();\n-  \n+\n   counts_hash = htab_create (10,\n \t\t\t     htab_counts_entry_hash, htab_counts_entry_eq,\n \t\t\t     htab_counts_entry_del);\n@@ -779,7 +779,7 @@ build_ctr_info_value (unsigned int counter, tree type)\n       varpool_finalize_decl (tree_ctr_tables[counter]);\n \n       value = tree_cons (fields,\n-\t\t\t build1 (ADDR_EXPR, TREE_TYPE (fields), \n+\t\t\t build1 (ADDR_EXPR, TREE_TYPE (fields),\n \t\t\t\t\t    tree_ctr_tables[counter]),\n \t\t\t value);\n     }\n@@ -1003,14 +1003,14 @@ coverage_init (const char *filename)\n   int len = strlen (filename);\n   /* + 1 for extra '/', in case prefix doesn't end with /.  */\n   int prefix_len;\n- \n+\n   if (profile_data_prefix == 0 && filename[0] != '/')\n     profile_data_prefix = getpwd ();\n \n   prefix_len = (profile_data_prefix) ? strlen (profile_data_prefix) + 1 : 0;\n \n   /* Name of da file.  */\n-  da_file_name = XNEWVEC (char, len + strlen (GCOV_DATA_SUFFIX) \n+  da_file_name = XNEWVEC (char, len + strlen (GCOV_DATA_SUFFIX)\n \t\t\t  + prefix_len + 1);\n \n   if (profile_data_prefix)"}, {"sha": "c44abb54d04398350862c24f0b7f952d89aad9d4", "filename": "gcc/crtstuff.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcrtstuff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcrtstuff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcrtstuff.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -135,7 +135,7 @@ call_ ## FUNC (void)\t\t\t\t\t\\\n    declaration for functions that we want to have weak references.\n \n    Neither way is particularly good.  */\n-   \n+\n /* References to __register_frame_info and __deregister_frame_info should\n    be weak in this file if at all possible.  */\n extern void __register_frame_info (const void *, struct object *)\n@@ -254,7 +254,7 @@ void *__dso_handle = 0;\n extern void __cxa_finalize (void *) TARGET_ATTRIBUTE_WEAK;\n \n /* Run all the global destructors on exit from the program.  */\n- \n+\n /* Some systems place the number of pointers in the first word of the\n    table.  On SVR4 however, that word is -1.  In all cases, the table is\n    null-terminated.  On SVR4, we start from the beginning of the list and\n@@ -546,7 +546,7 @@ STATIC EH_FRAME_SECTION_CONST int32 __FRAME_END__[]\n \n #ifdef JCR_SECTION_NAME\n /* Null terminate the .jcr section array.  */\n-STATIC void *__JCR_END__[1] \n+STATIC void *__JCR_END__[1]\n    __attribute__ ((unused, section(JCR_SECTION_NAME),\n \t\t   aligned(sizeof(void *))))\n    = { 0 };"}, {"sha": "484198a9615a230e6b717cb3ae5a95fa8a14a091", "filename": "gcc/cse.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -2237,7 +2237,7 @@ hash_rtx_string (const char *ps)\n   return hash;\n }\n \n-/* Same as hash_rtx, but call CB on each rtx if it is not NULL.  \n+/* Same as hash_rtx, but call CB on each rtx if it is not NULL.\n    When the callback returns true, we continue with the new rtx.  */\n \n unsigned\n@@ -2260,7 +2260,7 @@ hash_rtx_cb (const_rtx x, enum machine_mode mode,\n     return hash;\n \n   /* Invoke the callback first.  */\n-  if (cb != NULL \n+  if (cb != NULL\n       && ((*cb) (x, mode, &newx, &newmode)))\n     {\n       hash += hash_rtx_cb (newx, newmode, do_not_record_p,\n@@ -2370,7 +2370,7 @@ hash_rtx_cb (const_rtx x, enum machine_mode mode,\n \t  {\n \t    elt = CONST_VECTOR_ELT (x, i);\n \t    hash += hash_rtx_cb (elt, GET_MODE (elt),\n-                                 do_not_record_p, hash_arg_in_memory_p, \n+                                 do_not_record_p, hash_arg_in_memory_p,\n                                  have_reg_qty, cb);\n \t  }\n \n@@ -2516,7 +2516,7 @@ hash_rtx_cb (const_rtx x, enum machine_mode mode,\n \t      x = XEXP (x, i);\n \t      goto repeat;\n \t    }\n-          \n+\n \t  hash += hash_rtx_cb (XEXP (x, i), VOIDmode, do_not_record_p,\n                                hash_arg_in_memory_p,\n                                have_reg_qty, cb);\n@@ -2684,8 +2684,8 @@ exp_equiv_p (const_rtx x, const_rtx y, int validate, bool for_gcse)\n \t     They could e.g. be two different entities allocated into the\n \t     same space on the stack (see e.g. PR25130).  In that case, the\n \t     MEM addresses can be the same, even though the two MEMs are\n-\t     absolutely not equivalent.  \n-   \n+\t     absolutely not equivalent.\n+\n \t     But because really all MEM attributes should be the same for\n \t     equivalent MEMs, we just use the invariant that MEMs that have\n \t     the same attributes share the same mem_attrs data structure.  */\n@@ -3427,7 +3427,7 @@ fold_rtx (rtx x, rtx insn)\n \t\t     constant through simplifications.  */\n \t\t  p = lookup (folded_arg0, SAFE_HASH (folded_arg0, mode_arg0),\n \t\t\t      mode_arg0);\n-\t\t  \n+\n \t\t  if (p != NULL)\n \t\t    {\n \t\t      cheapest_simplification = x;\n@@ -6001,7 +6001,7 @@ cse_process_notes (rtx x, rtx object, bool *changed)\n    describe the path.\n    It is filled with a queue of basic blocks, starting with FIRST_BB\n    and following a trace through the CFG.\n-  \n+\n    If all paths starting at FIRST_BB have been followed, or no new path\n    starting at FIRST_BB can be constructed, this function returns FALSE.\n    Otherwise, DATA->path is filled and the function returns TRUE indicating\n@@ -6017,7 +6017,7 @@ cse_find_path (basic_block first_bb, struct cse_basic_block_data *data,\n   basic_block bb;\n   edge e;\n   int path_size;\n- \n+\n   SET_BIT (cse_visited_basic_blocks, first_bb->index);\n \n   /* See if there is a previous path.  */\n@@ -6178,7 +6178,7 @@ cse_prescan_path (struct cse_basic_block_data *data)\n   int path_entry;\n \n   /* Scan to end of each basic block in the path.  */\n-  for (path_entry = 0; path_entry < path_size; path_entry++) \n+  for (path_entry = 0; path_entry < path_size; path_entry++)\n     {\n       basic_block bb;\n       rtx insn;\n@@ -6784,7 +6784,7 @@ cse_change_cc_mode (rtx *loc, void *data)\n       && GET_MODE (*loc) != GET_MODE (args->newreg))\n     {\n       validate_change (args->insn, loc, args->newreg, 1);\n-      \n+\n       return -1;\n     }\n   return 0;\n@@ -6804,10 +6804,10 @@ cse_change_cc_mode_insn (rtx insn, rtx newreg)\n \n   args.insn = insn;\n   args.newreg = newreg;\n-  \n+\n   for_each_rtx (&PATTERN (insn), cse_change_cc_mode, &args);\n   for_each_rtx (&REG_NOTES (insn), cse_change_cc_mode, &args);\n-  \n+\n   /* If the following assertion was triggered, there is most probably\n      something wrong with the cc_modes_compatible back end function.\n      CC modes only can be considered compatible if the insn - with the mode\n@@ -6926,7 +6926,7 @@ cse_cc_succs (basic_block bb, basic_block orig_bb, rtx cc_reg, rtx cc_src,\n \t\t\t\t       XEXP (SET_SRC (set), 0))\n \t\t       && rtx_equal_p (XEXP (cc_src, 1),\n \t\t\t\t       XEXP (SET_SRC (set), 1)))\n-\t\t\t   \n+\n \t\t{\n \t\t  comp_mode = targetm.cc_modes_compatible (mode, set_mode);\n \t\t  if (comp_mode != VOIDmode\n@@ -7183,8 +7183,8 @@ struct rtl_opt_pass pass_cse =\n  {\n   RTL_PASS,\n   \"cse1\",                               /* name */\n-  gate_handle_cse,                      /* gate */   \n-  rest_of_handle_cse,\t\t\t/* execute */       \n+  gate_handle_cse,                      /* gate */\n+  rest_of_handle_cse,\t\t\t/* execute */\n   NULL,                                 /* sub */\n   NULL,                                 /* next */\n   0,                                    /* static_pass_number */\n@@ -7246,8 +7246,8 @@ struct rtl_opt_pass pass_cse2 =\n  {\n   RTL_PASS,\n   \"cse2\",                               /* name */\n-  gate_handle_cse2,                     /* gate */   \n-  rest_of_handle_cse2,\t\t\t/* execute */       \n+  gate_handle_cse2,                     /* gate */\n+  rest_of_handle_cse2,\t\t\t/* execute */\n   NULL,                                 /* sub */\n   NULL,                                 /* next */\n   0,                                    /* static_pass_number */\n@@ -7307,8 +7307,8 @@ struct rtl_opt_pass pass_cse_after_global_opts =\n  {\n   RTL_PASS,\n   \"cse_local\",                          /* name */\n-  gate_handle_cse_after_global_opts,    /* gate */   \n-  rest_of_handle_cse_after_global_opts, /* execute */       \n+  gate_handle_cse_after_global_opts,    /* gate */\n+  rest_of_handle_cse_after_global_opts, /* execute */\n   NULL,                                 /* sub */\n   NULL,                                 /* next */\n   0,                                    /* static_pass_number */"}, {"sha": "66d92a01ad0d304bf2d6986c76470b6d0a2ed4e6", "filename": "gcc/cselib.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -278,7 +278,7 @@ entry_and_rtx_equal_p (const void *entry, const void *x_arg)\n \n   gcc_assert (!CONST_INT_P (x) && GET_CODE (x) != CONST_FIXED\n \t      && (mode != VOIDmode || GET_CODE (x) != CONST_DOUBLE));\n-  \n+\n   if (mode != GET_MODE (v->val_rtx))\n     return 0;\n \n@@ -815,10 +815,10 @@ cselib_hash_rtx (rtx x, int create)\n \t  {\n \t    rtx tem = XEXP (x, i);\n \t    unsigned int tem_hash = cselib_hash_rtx (tem, create);\n-\t    \n+\n \t    if (tem_hash == 0)\n \t      return 0;\n-\t    \n+\n \t    hash += tem_hash;\n \t  }\n \t  break;\n@@ -827,24 +827,24 @@ cselib_hash_rtx (rtx x, int create)\n \t    {\n \t      unsigned int tem_hash\n \t\t= cselib_hash_rtx (XVECEXP (x, i, j), create);\n-\t      \n+\n \t      if (tem_hash == 0)\n \t\treturn 0;\n-\t      \n+\n \t      hash += tem_hash;\n \t    }\n \t  break;\n \n \tcase 's':\n \t  {\n \t    const unsigned char *p = (const unsigned char *) XSTR (x, i);\n-\t    \n+\n \t    if (p)\n \t      while (*p)\n \t\thash += *p++;\n \t    break;\n \t  }\n-\t  \n+\n \tcase 'i':\n \t  hash += XINT (x, i);\n \t  break;\n@@ -853,7 +853,7 @@ cselib_hash_rtx (rtx x, int create)\n \tcase 't':\n \t  /* unused */\n \t  break;\n-\t  \n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -971,7 +971,7 @@ cselib_lookup_mem (rtx x, int create)\n    non-reg results, we just take the first one because they will all\n    expand to the same place.  */\n \n-static rtx \n+static rtx\n expand_loc (struct elt_loc_list *p, struct expand_value_data *evd,\n \t    int max_depth)\n {\n@@ -983,16 +983,16 @@ expand_loc (struct elt_loc_list *p, struct expand_value_data *evd,\n     {\n       /* Avoid infinite recursion trying to expand a reg into a\n \t the same reg.  */\n-      if ((REG_P (p->loc)) \n-\t  && (REGNO (p->loc) < regno) \n+      if ((REG_P (p->loc))\n+\t  && (REGNO (p->loc) < regno)\n \t  && !bitmap_bit_p (evd->regs_active, REGNO (p->loc)))\n \t{\n \t  reg_result = p->loc;\n \t  regno = REGNO (p->loc);\n \t}\n       /* Avoid infinite recursion and do not try to expand the\n \t value.  */\n-      else if (GET_CODE (p->loc) == VALUE \n+      else if (GET_CODE (p->loc) == VALUE\n \t       && CSELIB_VAL_PTR (p->loc)->locs == p_in)\n \tcontinue;\n       else if (!REG_P (p->loc))\n@@ -1013,9 +1013,9 @@ expand_loc (struct elt_loc_list *p, struct expand_value_data *evd,\n \t  if (result)\n \t    return result;\n \t}\n-\t\n+\n     }\n-  \n+\n   if (regno != UINT_MAX)\n     {\n       rtx result;\n@@ -1034,7 +1034,7 @@ expand_loc (struct elt_loc_list *p, struct expand_value_data *evd,\n \t  print_inline_rtx (dump_file, reg_result, 0);\n \t  fprintf (dump_file, \"\\n\");\n \t}\n-      else \n+      else\n \tfprintf (dump_file, \"NULL\\n\");\n     }\n   return reg_result;\n@@ -1045,7 +1045,7 @@ expand_loc (struct elt_loc_list *p, struct expand_value_data *evd,\n    This is the opposite of common subexpression.  Because local value\n    numbering is such a weak optimization, the expanded expression is\n    pretty much unique (not from a pointer equals point of view but\n-   from a tree shape point of view.  \n+   from a tree shape point of view.\n \n    This function returns NULL if the expansion fails.  The expansion\n    will fail if there is no value number for one of the operands or if\n@@ -1124,7 +1124,7 @@ cselib_expand_value_rtx_1 (rtx orig, struct expand_value_data *evd,\n \t    {\n \t      rtx result;\n \t      int regno = REGNO (orig);\n-\t      \n+\n \t      /* The only thing that we are not willing to do (this\n \t\t is requirement of dse and if others potential uses\n \t\t need this function we should add a parm to control\n@@ -1156,11 +1156,11 @@ cselib_expand_value_rtx_1 (rtx orig, struct expand_value_data *evd,\n \n \t      if (result)\n \t\treturn result;\n-\t      else \n+\t      else\n \t\treturn orig;\n \t    }\n       }\n-      \n+\n     case CONST_INT:\n     case CONST_DOUBLE:\n     case CONST_VECTOR:\n@@ -1979,7 +1979,7 @@ cselib_process_insn (rtx insn)\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (call_used_regs[i]\n \t    || (REG_VALUES (i) && REG_VALUES (i)->elt\n-\t\t&& HARD_REGNO_CALL_PART_CLOBBERED (i, \n+\t\t&& HARD_REGNO_CALL_PART_CLOBBERED (i,\n \t\t      GET_MODE (REG_VALUES (i)->elt->val_rtx))))\n \t  cselib_invalidate_regno (i, reg_raw_mode[i]);\n \n@@ -2025,11 +2025,11 @@ cselib_process_insn (rtx insn)\n void\n cselib_init (bool record_memory)\n {\n-  elt_list_pool = create_alloc_pool (\"elt_list\", \n+  elt_list_pool = create_alloc_pool (\"elt_list\",\n \t\t\t\t     sizeof (struct elt_list), 10);\n-  elt_loc_list_pool = create_alloc_pool (\"elt_loc_list\", \n+  elt_loc_list_pool = create_alloc_pool (\"elt_loc_list\",\n \t\t\t\t         sizeof (struct elt_loc_list), 10);\n-  cselib_val_pool = create_alloc_pool (\"cselib_val_list\", \n+  cselib_val_pool = create_alloc_pool (\"cselib_val_list\",\n \t\t\t\t       sizeof (cselib_val), 10);\n   value_pool = create_alloc_pool (\"value\", RTX_CODE_SIZE (VALUE), 100);\n   cselib_record_memory = record_memory;"}, {"sha": "6c3bd9192a8ccb29dcdea2791a2355e330168eaf", "filename": "gcc/dbgcnt.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdbgcnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdbgcnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbgcnt.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -15,7 +15,7 @@ for more details.\n \n You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  \n+<http://www.gnu.org/licenses/>.\n \n See dbgcnt.def for usage information.  */\n \n@@ -62,7 +62,7 @@ dbg_cnt (enum debug_counter index)\n {\n   count[index]++;\n   if (dump_file && count[index] == limit[index])\n-    fprintf (dump_file, \"***dbgcnt: limit reached for %s.***\\n\", \n+    fprintf (dump_file, \"***dbgcnt: limit reached for %s.***\\n\",\n \t     map[index].name);\n \n   return dbg_cnt_is_enabled (index);\n@@ -104,7 +104,7 @@ dbg_cnt_process_single_pair (const char *arg)\n    const char *colon = strchr (arg, ':');\n    char *endptr = NULL;\n    int value;\n-   \n+\n    if (colon == NULL)\n      return NULL;\n \n@@ -113,7 +113,7 @@ dbg_cnt_process_single_pair (const char *arg)\n    if (endptr != NULL && endptr != colon + 1\n        && dbg_cnt_set_limit_by_name (arg, colon - arg, value))\n      return endptr;\n-   \n+\n    return NULL;\n }\n \n@@ -140,7 +140,7 @@ dbg_cnt_process_opt (const char *arg)\n \n /* Print name, limit and count of all counters.   */\n \n-void \n+void\n dbg_cnt_list_all_counters (void)\n {\n   int i;"}, {"sha": "78553a41d6e3eeae93d2056a3a746731ad249b0c", "filename": "gcc/dbgcnt.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdbgcnt.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdbgcnt.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbgcnt.def?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -71,7 +71,7 @@ along with GCC; see the file COPYING3.  If not see\n    assuming that the following script is called binarySearch,\n    the command:\n \n-\tbinarySearch tryTest \n+\tbinarySearch tryTest\n \n    will automatically find the highest value of the counter for which\n    the program fails.  If tryTest never fails, binarySearch will\n@@ -82,7 +82,7 @@ along with GCC; see the file COPYING3.  If not see\n    dump_file of the form:\n \n        ***dbgcnt: limit reached for %s.***\n-\t\n+\n    Assuming that the dump file is logging the analysis/transformations\n    it is making, this pinpoints the exact position in the log file\n    where the problem transformation is being logged."}, {"sha": "354e88a48eaff2d7f9bf85abeeb8e4651357e436", "filename": "gcc/dbgcnt.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdbgcnt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdbgcnt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbgcnt.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -15,7 +15,7 @@ for more details.\n \n You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  \n+<http://www.gnu.org/licenses/>.\n \n See dbgcnt.def for usage information.  */\n "}, {"sha": "a314e7b4430dca73c70faee7f9757422948124c1", "filename": "gcc/dbxout.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -216,8 +216,8 @@ struct dbx_file\n   struct dbx_file *prev;          /* Chain to traverse all pending bincls.  */\n };\n \n-/* This is the top of the stack.  \n-   \n+/* This is the top of the stack.\n+\n    This is not saved for PCH, because restoring a PCH should not change it.\n    next_file_number does have to be saved, because the PCH may use some\n    file numbers; however, just before restoring a PCH, next_file_number\n@@ -306,7 +306,7 @@ static void emit_pending_bincls         (void);\n static inline void emit_pending_bincls_if_required (void);\n \n static void dbxout_init (const char *);\n- \n+\n static void dbxout_finish (const char *);\n static void dbxout_start_source_file (unsigned, const char *);\n static void dbxout_end_source_file (unsigned);\n@@ -848,7 +848,7 @@ do {\t\t\t\t\t\t\t\t\\\n    SYM is the DECL of the symbol under consideration; it is used only\n    for its DECL_SOURCE_LINE.  The other arguments are all passed directly\n    to DBX_FINISH_STABS; see above for details.  */\n-   \n+\n static void\n dbxout_finish_complex_stabs (tree sym, stab_code_type code,\n \t\t\t     rtx addr, const char *label, int number)\n@@ -902,7 +902,7 @@ dbxout_finish_complex_stabs (tree sym, stab_code_type code,\n       obstack_grow (&stabstr_ob, \"\\\",\", 2);\n       len = obstack_object_size (&stabstr_ob);\n       str = XOBFINISH (&stabstr_ob, char *);\n-      \n+\n       fwrite (str, 1, len, asm_out_file);\n       DBX_FINISH_STABS (sym, code, line, addr, label, number);\n     }\n@@ -919,7 +919,7 @@ dbxout_function_end (tree decl ATTRIBUTE_UNUSED)\n   /* The Lscope label must be emitted even if we aren't doing anything\n      else; dbxout_block needs it.  */\n   switch_to_section (function_section (current_function_decl));\n-  \n+\n   /* Convert Lscope into the appropriate format for local labels in case\n      the system doesn't insert underscores in front of user generated\n      labels.  */\n@@ -939,10 +939,10 @@ dbxout_function_end (tree decl ATTRIBUTE_UNUSED)\n   if (flag_reorder_blocks_and_partition)\n     {\n       dbxout_begin_empty_stabs (N_FUN);\n-      dbxout_stab_value_label_diff (crtl->subsections.hot_section_end_label, \n+      dbxout_stab_value_label_diff (crtl->subsections.hot_section_end_label,\n \t\t\t\t    crtl->subsections.hot_section_label);\n       dbxout_begin_empty_stabs (N_FUN);\n-      dbxout_stab_value_label_diff (crtl->subsections.cold_section_end_label, \n+      dbxout_stab_value_label_diff (crtl->subsections.cold_section_end_label,\n \t\t\t\t    crtl->subsections.cold_section_label);\n     }\n   else\n@@ -1178,7 +1178,7 @@ dbxout_start_source_file (unsigned int line ATTRIBUTE_UNUSED,\n \n   n->next = current_file;\n   n->next_type_number = 1;\n-  /* Do not assign file number now. \n+  /* Do not assign file number now.\n      Delay it until we actually emit BINCL.  */\n   n->file_number = 0;\n   n->prev = NULL;\n@@ -1259,7 +1259,7 @@ dbxout_source_file (const char *filename)\n     }\n }\n \n-/* Output N_BNSYM, line number symbol entry, and local symbol at \n+/* Output N_BNSYM, line number symbol entry, and local symbol at\n    function scope  */\n \n static void\n@@ -1275,7 +1275,7 @@ dbxout_begin_prologue (unsigned int lineno, const char *filename)\n   scope_labelno++;\n \n   dbxout_source_line (lineno, filename, 0, true);\n-  /* Output function begin block at function scope, referenced \n+  /* Output function begin block at function scope, referenced\n      by dbxout_block, dbxout_source_line and dbxout_function_end.  */\n   emit_pending_bincls_if_required ();\n   targetm.asm_out.internal_label (asm_out_file, \"LFBB\", scope_labelno);\n@@ -1299,7 +1299,7 @@ dbxout_source_line (unsigned int lineno, const char *filename,\n       char begin_label[20];\n       dbxout_begin_stabn_sline (lineno);\n       /* Reference current function start using LFBB.  */\n-      ASM_GENERATE_INTERNAL_LABEL (begin_label, \"LFBB\", scope_labelno); \n+      ASM_GENERATE_INTERNAL_LABEL (begin_label, \"LFBB\", scope_labelno);\n       dbxout_stab_value_internal_label_diff (\"LM\", &dbxout_source_line_counter,\n \t\t\t\t\t     begin_label);\n     }\n@@ -2093,7 +2093,7 @@ dbxout_type (tree type, int full)\n \t    int i;\n \t    tree child;\n \t    VEC(tree,gc) *accesses = BINFO_BASE_ACCESSES (binfo);\n-\t    \n+\n \t    if (use_gnu_debug_info_extensions)\n \t      {\n \t\tif (BINFO_N_BASE_BINFOS (binfo))\n@@ -2320,7 +2320,7 @@ static void\n dbxout_type_name (tree type)\n {\n   tree t = TYPE_NAME (type);\n-  \n+\n   gcc_assert (t);\n   switch (TREE_CODE (t))\n     {\n@@ -3138,7 +3138,7 @@ dbxout_symbol_name (tree decl, const char *suffix, int letter)\n {\n   tree name;\n \n-  if (DECL_CONTEXT (decl) \n+  if (DECL_CONTEXT (decl)\n       && (TYPE_P (DECL_CONTEXT (decl))\n \t  || TREE_CODE (DECL_CONTEXT (decl)) == NAMESPACE_DECL))\n     /* One slight hitch: if this is a VAR_DECL which is a class member\n@@ -3190,12 +3190,12 @@ dbxout_common_check (tree decl, int *value)\n   rtx home;\n   rtx sym_addr;\n   const char *name = NULL;\n-  \n+\n   /* If the decl isn't a VAR_DECL, or if it isn't static, or if\n      it does not have a value (the offset into the common area), or if it\n      is thread local (as opposed to global) then it isn't common, and shouldn't\n      be handled as such.\n-     \n+\n      ??? DECL_THREAD_LOCAL_P check prevents problems with improper .stabs\n      for thread-local symbols.  Can be handled via same mechanism as used\n      in dwarf2out.c.  */\n@@ -3206,7 +3206,7 @@ dbxout_common_check (tree decl, int *value)\n       || !is_fortran ())\n     return NULL;\n \n-  home = DECL_RTL (decl); \n+  home = DECL_RTL (decl);\n   if (home == NULL_RTX || GET_CODE (home) != MEM)\n     return NULL;\n \n@@ -3431,7 +3431,7 @@ dbxout_parms (tree parms)\n \t       that it was actually passed by invisible reference.  */\n \n \t    code = DBX_REGPARM_STABS_CODE;\n- \n+\n \t    /* GDB likes this marked with a special letter.  */\n \t    letter = (use_gnu_debug_info_extensions\n \t\t      ? 'a' : DBX_REGPARM_STABS_LETTER);\n@@ -3502,7 +3502,7 @@ dbxout_parms (tree parms)\n \t  continue;\n \n \tdbxout_begin_complex_stabs ();\n-\t    \n+\n \tif (DECL_NAME (parms))\n \t  {\n \t    stabstr_I (DECL_NAME (parms));"}, {"sha": "855bef32237bc7511c9214297b9aa583c80b9cdd", "filename": "gcc/dce.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -622,7 +622,7 @@ mark_artificial_uses (void)\n \n   FOR_ALL_BB (bb)\n     {\n-      for (use_rec = df_get_artificial_uses (bb->index); \n+      for (use_rec = df_get_artificial_uses (bb->index);\n \t   *use_rec; use_rec++)\n \tfor (defs = DF_REF_CHAIN (*use_rec); defs; defs = defs->next)\n \t  if (! DF_REF_IS_ARTIFICIAL (defs->ref))\n@@ -825,7 +825,7 @@ byte_dce_process_block (basic_block bb, bool redo_out, bitmap au)\n \t\tmark_insn (insn, true);\n \t\tgoto quickexit;\n \t      }\n-\t    \n+\n \t    last = start + len;\n \t    while (start < last)\n \t      if (bitmap_bit_p (local_live, start++))\n@@ -834,9 +834,9 @@ byte_dce_process_block (basic_block bb, bool redo_out, bitmap au)\n \t\t  goto quickexit;\n \t\t}\n \t  }\n-\t\n-      quickexit: \n-\t\n+\n+      quickexit:\n+\n \t/* No matter if the instruction is needed or not, we remove\n \t   any regno in the defs from the live set.  */\n \tdf_byte_lr_simulate_defs (insn, local_live);\n@@ -848,12 +848,12 @@ byte_dce_process_block (basic_block bb, bool redo_out, bitmap au)\n \n \tif (dump_file)\n \t  {\n-\t    fprintf (dump_file, \"finished processing insn %d live out = \", \n+\t    fprintf (dump_file, \"finished processing insn %d live out = \",\n \t\t     INSN_UID (insn));\n \t    df_print_byte_regset (dump_file, local_live);\n \t  }\n       }\n-  \n+\n   df_byte_lr_simulate_artificial_refs_at_top (bb, local_live);\n \n   block_changed = !bitmap_equal_p (local_live, DF_BYTE_LR_IN (bb));\n@@ -913,10 +913,10 @@ dce_process_block (basic_block bb, bool redo_out, bitmap au)\n \t      needed = true;\n \t      break;\n \t    }\n-\t    \n+\n \tif (needed)\n \t  mark_insn (insn, true);\n-\t\n+\n \t/* No matter if the instruction is needed or not, we remove\n \t   any regno in the defs from the live set.  */\n \tdf_simulate_defs (insn, local_live);\n@@ -926,7 +926,7 @@ dce_process_block (basic_block bb, bool redo_out, bitmap au)\n \tif (marked_insn_p (insn))\n \t  df_simulate_uses (insn, local_live);\n       }\n-  \n+\n   df_simulate_finalize_backwards (bb, local_live);\n \n   block_changed = !bitmap_equal_p (local_live, DF_LR_IN (bb));\n@@ -986,15 +986,15 @@ fast_dce (bool byte_level)\n \t    }\n \n \t  if (byte_level)\n-\t    local_changed \n+\t    local_changed\n \t      = byte_dce_process_block (bb, bitmap_bit_p (redo_out, index),\n \t\t\t\t\t  bb_has_eh_pred (bb) ? au_eh : au);\n \t  else\n-\t    local_changed \n+\t    local_changed\n \t      = dce_process_block (bb, bitmap_bit_p (redo_out, index),\n \t\t\t\t   bb_has_eh_pred (bb) ? au_eh : au);\n \t  bitmap_set_bit (processed, index);\n-\t  \n+\n \t  if (local_changed)\n \t    {\n \t      edge e;\n@@ -1010,7 +1010,7 @@ fast_dce (bool byte_level)\n \t\t  bitmap_set_bit (redo_out, e->src->index);\n \t    }\n \t}\n-      \n+\n       if (global_changed)\n \t{\n \t  /* Turn off the RUN_DCE flag to prevent recursive calls to\n@@ -1023,11 +1023,11 @@ fast_dce (bool byte_level)\n \t  sbitmap_zero (marked);\n \t  bitmap_clear (processed);\n \t  bitmap_clear (redo_out);\n-\t  \n+\n \t  /* We do not need to rescan any instructions.  We only need\n \t     to redo the dataflow equations for the blocks that had a\n \t     change at the top of the block.  Then we need to redo the\n-\t     iteration.  */ \n+\t     iteration.  */\n \t  if (byte_level)\n \t    df_analyze_problem (df_byte_lr, all_blocks, postorder, n_blocks);\n \t  else"}, {"sha": "23fa6fa2aeb071550b47648e325633c016a1e864", "filename": "gcc/ddg.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -355,7 +355,7 @@ add_inter_loop_mem_dep (ddg_ptr g, ddg_node_ptr from, ddg_node_ptr to)\n   if (!insn_alias_sets_conflict_p (from->insn, to->insn))\n     /* Do not create edge if memory references have disjoint alias sets.  */\n     return;\n-    \n+\n   if (mem_write_insn_p (from->insn))\n     {\n       if (mem_read_insn_p (to->insn))\n@@ -523,10 +523,10 @@ create_ddg (basic_block bb, int closing_branch_deps)\n       g->nodes[i++].insn = insn;\n       first_note = NULL_RTX;\n     }\n-  \n+\n   /* We must have found a branch in DDG.  */\n   gcc_assert (g->closing_branch);\n-  \n+\n \n   /* Build the data dependency graph.  */\n   build_intra_loop_deps (g);\n@@ -869,9 +869,9 @@ static int\n compare_sccs (const void *s1, const void *s2)\n {\n   const int rec_l1 = (*(const ddg_scc_ptr *)s1)->recurrence_length;\n-  const int rec_l2 = (*(const ddg_scc_ptr *)s2)->recurrence_length; \n+  const int rec_l2 = (*(const ddg_scc_ptr *)s2)->recurrence_length;\n   return ((rec_l2 > rec_l1) - (rec_l2 < rec_l1));\n-\t  \n+\n }\n \n /* Order the backarcs in descending recMII order using compare_sccs.  */"}, {"sha": "e17e534af4d382bc276578423e9f40770774c640", "filename": "gcc/ddg.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fddg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fddg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -27,7 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n /* For basic_block.  */\n #include \"basic-block.h\"\n #include \"df.h\"\n- \n+\n typedef struct ddg_node *ddg_node_ptr;\n typedef struct ddg_edge *ddg_edge_ptr;\n typedef struct ddg *ddg_ptr;"}, {"sha": "0363a460e061bdd7d01ffbd2e1d105c7d05c9fec", "filename": "gcc/defaults.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -460,11 +460,11 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #ifndef DECIMAL32_TYPE_SIZE\n #define DECIMAL32_TYPE_SIZE 32\n-#endif \n+#endif\n \n-#ifndef DECIMAL64_TYPE_SIZE \n+#ifndef DECIMAL64_TYPE_SIZE\n #define DECIMAL64_TYPE_SIZE 64\n-#endif \n+#endif\n \n #ifndef DECIMAL128_TYPE_SIZE\n #define DECIMAL128_TYPE_SIZE 128"}, {"sha": "8271465041e01a3ca7d7071a8586c23cd22f9ef7", "filename": "gcc/df-byte-scan.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdf-byte-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdf-byte-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-byte-scan.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -43,12 +43,12 @@ along with GCC; see the file COPYING3.  If not see\n /* Helper for df_compute_accessed_bytes.  Ref is some sort of extract.\n    Return true if this effects the entire reg in REF.  Return false if\n    otherwise and set START_BYTE and LAST_BYTE.  See the description of\n-   df_compute_accessed_bytes for a description of MM.  */ \n+   df_compute_accessed_bytes for a description of MM.  */\n \n-static bool \n+static bool\n df_compute_accessed_bytes_extract (df_ref ref,\n \t\t\t\t   enum df_mm mm ,\n-\t\t\t\t   unsigned int *start_byte, \n+\t\t\t\t   unsigned int *start_byte,\n \t\t\t\t   unsigned int *last_byte)\n {\n   int start;\n@@ -61,12 +61,12 @@ df_compute_accessed_bytes_extract (df_ref ref,\n \n   /* (*_extract:M1 (reg:M2 X) WIDTH POS)\n      (*_extract:M1 (subreg:M1 (reg:M2 X N) WIDTH POS)\n-      \n+\n      This is a bitfield extraction.  The assignment clobbers/extracts\n      exactly the bits named by WIDTH and POS and does not affect the\n      other bits in register X.  It is also technically possible that\n      the bits asked for are longer than units per word.  */\n-  \n+\n   int offset = DF_REF_EXTRACT_OFFSET (ref);\n   int width = DF_REF_EXTRACT_WIDTH (ref);\n \n@@ -134,9 +134,9 @@ df_compute_accessed_bytes_extract (df_ref ref,\n     last = m2_size;\n \n   if (dump_file)\n-    fprintf (dump_file, \"    cpb extract regno=%d start=%d last=%d\\n\", \n+    fprintf (dump_file, \"    cpb extract regno=%d start=%d last=%d\\n\",\n \t     DF_REF_REGNO (ref), start, last);\n-  \n+\n   *start_byte = start;\n   *last_byte = last;\n   return false;\n@@ -145,11 +145,11 @@ df_compute_accessed_bytes_extract (df_ref ref,\n \n /* Helper for df_compute_accessed_bytes.  Ref is a strict_low_part.\n    Return true if this effects the entire reg in REF. Return false if\n-   otherwise and set START_BYTE and LAST_BYTE.  */ \n+   otherwise and set START_BYTE and LAST_BYTE.  */\n \n-static bool \n-df_compute_accessed_bytes_strict_low_part (df_ref ref, \n-\t\t\t\t\t   unsigned int *start_byte, \n+static bool\n+df_compute_accessed_bytes_strict_low_part (df_ref ref,\n+\t\t\t\t\t   unsigned int *start_byte,\n \t\t\t\t\t   unsigned int *last_byte)\n {\n   int start;\n@@ -177,17 +177,17 @@ df_compute_accessed_bytes_strict_low_part (df_ref ref,\n   gcc_assert (m1_size <= m2_size);\n \n   /* (set (strict_low_part (subreg:M1 (reg:M2 X) N)) ...)\n-      \n+\n   This is a bitfield insertion.  The assignment clobbers exactly the\n   bits named by the subreg--the M1 bits at position N.  It is also\n   technically possible that the bits asked for are longer than units\n   per word.  */\n-  \n+\n   start = offset;\n   last = offset + m1_size;\n \n   if (dump_file)\n-    fprintf (dump_file, \"    cpb strict low part regno=%d start=%d last=%d\\n\", \n+    fprintf (dump_file, \"    cpb strict low part regno=%d start=%d last=%d\\n\",\n \t     DF_REF_REGNO (ref), start, last);\n \n   *start_byte = start;\n@@ -197,10 +197,10 @@ df_compute_accessed_bytes_strict_low_part (df_ref ref,\n \n /* Helper for df_compute_accessed_bytes.  Ref is a naked subreg.\n    Return true if this effects the entire reg in REF. Return false if\n-   otherwise and set START_BYTE and LAST_BYTE.  */ \n+   otherwise and set START_BYTE and LAST_BYTE.  */\n \n-static bool \n-df_compute_accessed_bytes_subreg (df_ref ref, unsigned int *start_byte, \n+static bool\n+df_compute_accessed_bytes_subreg (df_ref ref, unsigned int *start_byte,\n \t\t\t\t  unsigned int *last_byte)\n \n {\n@@ -231,31 +231,31 @@ df_compute_accessed_bytes_subreg (df_ref ref, unsigned int *start_byte,\n   /* Defs and uses are different in the amount of the reg that touch.  */\n   if (DF_REF_REG_DEF_P (ref))\n     {\n-      /* This is an lvalue.  */ \n+      /* This is an lvalue.  */\n \n       if (m2_size > UNITS_PER_WORD)\n \t{\n \t  /* The assignment clobbers UNITS_PER_WORD segments of X.\n \t     Look at the bytes named by the subreg, and expand it to\n \t     cover a UNITS_PER_WORD part of register X.  That part of\n \t     register X is clobbered, the rest is not.\n-\t     \n+\n \t     E.g., (subreg:SI (reg:DI X) 0), where UNITS_PER_WORD is the\n \t     size of SImode, clobbers the first SImode part of X, and does\n \t     not affect the second SImode part.\n-\t     \n+\n \t     E.g., (subreg:QI (reg:DI X) 0), where UNITS_PER_WORD is the\n \t     size of SImode, clobbers the first SImode part of X, and does\n \t     not affect the second SImode part.  Here the QImode byte is\n \t     expanded to a UNITS_PER_WORD portion of the register for\n \t     purposes of determining what is clobbered.\n-\t     \n+\n \t     If this is an rvalue, then it touches just the bytes that it\n \t     talks about.  */\n \t  int offset = SUBREG_BYTE (reg);\n-\t  \n+\n \t  start = offset & ~(UNITS_PER_WORD - 1);\n-\t  last = (offset + m1_size + UNITS_PER_WORD - 1) \n+\t  last = (offset + m1_size + UNITS_PER_WORD - 1)\n \t    & ~(UNITS_PER_WORD - 1);\n \t}\n       else\n@@ -264,17 +264,17 @@ df_compute_accessed_bytes_subreg (df_ref ref, unsigned int *start_byte,\n \t   X.  */\n \treturn true;\n     }\n-  else \n+  else\n     {\n       /* This is an rvalue. It touches just the bytes they explicitly\n \t mentioned.  */\n       int offset = SUBREG_BYTE (reg);\n       start = offset;\n       last = start + m1_size;\n     }\n-  \n+\n   if (dump_file)\n-    fprintf (dump_file, \"    cpb subreg regno=%d start=%d last=%d\\n\", \n+    fprintf (dump_file, \"    cpb subreg regno=%d start=%d last=%d\\n\",\n \t     DF_REF_REGNO (ref), start, last);\n \n   *start_byte = start;\n@@ -299,15 +299,15 @@ df_compute_accessed_bytes_subreg (df_ref ref, unsigned int *start_byte,\n    in, START_BYTE and LAST_BYTE are set to 0 and false is returned.\n    This means that this use can be ignored.  */\n \n-bool \n-df_compute_accessed_bytes (df_ref ref, enum df_mm mm, \n-\t\t\t   unsigned int *start_byte, \n+bool\n+df_compute_accessed_bytes (df_ref ref, enum df_mm mm,\n+\t\t\t   unsigned int *start_byte,\n \t\t\t   unsigned int *last_byte)\n {\n   if (!dbg_cnt (df_byte_scan))\n     return true;\n \n-  if (!DF_REF_REG_DEF_P (ref) \n+  if (!DF_REF_REG_DEF_P (ref)\n       && DF_REF_FLAGS_IS_SET (ref, DF_REF_READ_WRITE))\n     {\n       if (DF_REF_FLAGS_IS_SET (ref, DF_REF_PRE_POST_MODIFY))\n@@ -331,7 +331,7 @@ df_compute_accessed_bytes (df_ref ref, enum df_mm mm,\n   if (DF_REF_FLAGS_IS_SET (ref, DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT))\n     return df_compute_accessed_bytes_extract (ref, mm, start_byte, last_byte);\n   else if (DF_REF_FLAGS_IS_SET (ref, DF_REF_STRICT_LOW_PART))\n-    return df_compute_accessed_bytes_strict_low_part (ref, \n+    return df_compute_accessed_bytes_strict_low_part (ref,\n \t\t\t\t\t\t      start_byte, last_byte);\n   else if (GET_CODE (DF_REF_REG (ref)) == SUBREG)\n     return df_compute_accessed_bytes_subreg (ref, start_byte, last_byte);"}, {"sha": "5ec802d0f8b72ac383dd43eb4c7792e98077493d", "filename": "gcc/df-core.c", "status": "modified", "additions": 89, "deletions": 89, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -1,7 +1,7 @@\n /* Allocation for dataflow support routines.\n    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,\n    2008, 2009 Free Software Foundation, Inc.\n-   Originally contributed by Michael P. Hayes \n+   Originally contributed by Michael P. Hayes\n              (m.hayes@elec.canterbury.ac.nz, mhayes@redhat.com)\n    Major rewrite contributed by Danny Berlin (dberlin@dberlin.org)\n              and Kenneth Zadeck (zadeck@naturalbridge.com).\n@@ -43,7 +43,7 @@ There are three variations of the live variable problem that are\n available whenever dataflow is available.  The LR problem finds the\n areas that can reach a use of a variable, the UR problems finds the\n areas that can be reached from a definition of a variable.  The LIVE\n-problem finds the intersection of these two areas.  \n+problem finds the intersection of these two areas.\n \n There are several optional problems.  These can be enabled when they\n are needed and disabled when they are not needed.\n@@ -59,7 +59,7 @@ section.\n In the middle layer, basic blocks are scanned to produce transfer\n functions which describe the effects of that block on the global\n dataflow solution.  The transfer functions are only rebuilt if the\n-some instruction within the block has changed.  \n+some instruction within the block has changed.\n \n The top layer is the dataflow solution itself.  The dataflow solution\n is computed by using an efficient iterative solver and the transfer\n@@ -200,7 +200,7 @@ There are four ways of doing the incremental scanning:\n 4) Do it yourself - In this mechanism, the pass updates the insns\n    itself using the low level df primitives.  Currently no pass does\n    this, but it has the advantage that it is quite efficient given\n-   that the pass generally has exact knowledge of what it is changing.  \n+   that the pass generally has exact knowledge of what it is changing.\n \n DATA STRUCTURES\n \n@@ -247,7 +247,7 @@ to the engine that resolves the dataflow equations.\n \n DATA STRUCTURES:\n \n-The basic object is a DF_REF (reference) and this may either be a \n+The basic object is a DF_REF (reference) and this may either be a\n DEF (definition) or a USE of a register.\n \n These are linked into a variety of lists; namely reg-def, reg-use,\n@@ -291,12 +291,12 @@ There are 4 ways to obtain access to refs:\n \n 1) References are divided into two categories, REAL and ARTIFICIAL.\n \n-   REAL refs are associated with instructions.  \n+   REAL refs are associated with instructions.\n \n    ARTIFICIAL refs are associated with basic blocks.  The heads of\n    these lists can be accessed by calling df_get_artificial_defs or\n-   df_get_artificial_uses for the particular basic block.  \n- \n+   df_get_artificial_uses for the particular basic block.\n+\n    Artificial defs and uses occur both at the beginning and ends of blocks.\n \n      For blocks that area at the destination of eh edges, the\n@@ -315,14 +315,14 @@ There are 4 ways to obtain access to refs:\n      Artificial defs occur at the end of the entry block.  These arise\n      from registers that are live at entry to the function.\n \n-2) There are three types of refs: defs, uses and eq_uses.  (Eq_uses are \n+2) There are three types of refs: defs, uses and eq_uses.  (Eq_uses are\n    uses that appear inside a REG_EQUAL or REG_EQUIV note.)\n \n    All of the eq_uses, uses and defs associated with each pseudo or\n    hard register may be linked in a bidirectional chain.  These are\n    called reg-use or reg_def chains.  If the changeable flag\n    DF_EQ_NOTES is set when the chains are built, the eq_uses will be\n-   treated like uses.  If it is not set they are ignored.  \n+   treated like uses.  If it is not set they are ignored.\n \n    The first use, eq_use or def for a register can be obtained using\n    the DF_REG_USE_CHAIN, DF_REG_EQ_USE_CHAIN or DF_REG_DEF_CHAIN\n@@ -347,14 +347,14 @@ There are 4 ways to obtain access to refs:\n    has been set the array will contain the eq_uses.  Otherwise these\n    are ignored when building the array and assigning the ids.  Note\n    that the values in the id field of a ref may change across calls to\n-   df_analyze or df_reorganize_defs or df_reorganize_uses. \n+   df_analyze or df_reorganize_defs or df_reorganize_uses.\n \n    If the only use of this array is to find all of the refs, it is\n    better to traverse all of the registers and then traverse all of\n    reg-use or reg-def chains.\n \n NOTES:\n- \n+\n Embedded addressing side-effects, such as POST_INC or PRE_INC, generate\n both a use and a def.  These are both marked read/write to show that they\n are dependent. For example, (set (reg 40) (mem (post_inc (reg 42))))\n@@ -371,7 +371,7 @@ operation.  We generate both a use and a def and again mark them\n read/write.\n \n Paradoxical subreg writes do not leave a trace of the old content, so they\n-are write-only operations.  \n+are write-only operations.\n */\n \n \n@@ -448,7 +448,7 @@ df_add_problem (struct df_problem *problem)\n      However for this to work, the computation of RI must be pushed\n      after which ever of those problems is defined, but we do not\n      require any of those except for LR to have actually been\n-     defined.  */ \n+     defined.  */\n   df->num_problems_defined++;\n   for (i = df->num_problems_defined - 2; i >= 0; i--)\n     {\n@@ -492,7 +492,7 @@ df_clear_flags (int changeable_flags)\n    not called or is called with null, the entire function in\n    analyzed.  */\n \n-void \n+void\n df_set_blocks (bitmap blocks)\n {\n   if (blocks)\n@@ -515,7 +515,7 @@ df_set_blocks (bitmap blocks)\n \t\t{\n \t\t  bitmap_iterator bi;\n \t\t  unsigned int bb_index;\n-\t\t  \n+\n \t\t  EXECUTE_IF_SET_IN_BITMAP (diff, 0, bb_index, bi)\n \t\t    {\n \t\t      basic_block bb = BASIC_BLOCK (bb_index);\n@@ -552,7 +552,7 @@ df_set_blocks (bitmap blocks)\n \t\t\tBITMAP_ALLOC (&df_bitmap_obstack);\n \t\t      FOR_ALL_BB(bb)\n \t\t\t{\n-\t\t\t  bitmap_set_bit (blocks_to_reset, bb->index); \n+\t\t\t  bitmap_set_bit (blocks_to_reset, bb->index);\n \t\t\t}\n \t\t    }\n \t\t  dflow->problem->reset_fun (blocks_to_reset);\n@@ -729,7 +729,7 @@ rest_of_handle_df_initialize (void)\n   gcc_assert (df->n_blocks == df->n_blocks_inverted);\n \n   df->hard_regs_live_count = XNEWVEC (unsigned int, FIRST_PSEUDO_REGISTER);\n-  memset (df->hard_regs_live_count, 0, \n+  memset (df->hard_regs_live_count, 0,\n \t  sizeof (unsigned int) * FIRST_PSEUDO_REGISTER);\n \n   df_hard_reg_init ();\n@@ -809,7 +809,7 @@ rest_of_handle_df_finish (void)\n   for (i = 0; i < df->num_problems_defined; i++)\n     {\n       struct dataflow *dflow = df->problems_in_order[i];\n-      dflow->problem->free_fun (); \n+      dflow->problem->free_fun ();\n     }\n \n   if (df->postorder)\n@@ -854,7 +854,7 @@ struct rtl_opt_pass pass_df_finish =\n \n \n /* Helper function for df_worklist_dataflow.\n-   Propagate the dataflow forward. \n+   Propagate the dataflow forward.\n    Given a BB_INDEX, do the dataflow propagation\n    and set bits on for successors in PENDING\n    if the out set of the dataflow has changed. */\n@@ -873,16 +873,16 @@ df_worklist_propagate_forward (struct dataflow *dataflow,\n   /*  Calculate <conf_op> of incoming edges.  */\n   if (EDGE_COUNT (bb->preds) > 0)\n     FOR_EACH_EDGE (e, ei, bb->preds)\n-      {\t\t\t\t\t\t\t\t\n-        if (TEST_BIT (considered, e->src->index))\t\t\n+      {\n+        if (TEST_BIT (considered, e->src->index))\n           dataflow->problem->con_fun_n (e);\n-      }\t\t\t\t\t\t\t\t\n+      }\n   else if (dataflow->problem->con_fun_0)\n     dataflow->problem->con_fun_0 (bb);\n \n   if (dataflow->problem->trans_fun (bb_index))\n     {\n-      /* The out set of this block has changed. \n+      /* The out set of this block has changed.\n          Propagate to the outgoing blocks.  */\n       FOR_EACH_EDGE (e, ei, bb->succs)\n         {\n@@ -912,16 +912,16 @@ df_worklist_propagate_backward (struct dataflow *dataflow,\n   /*  Calculate <conf_op> of incoming edges.  */\n   if (EDGE_COUNT (bb->succs) > 0)\n     FOR_EACH_EDGE (e, ei, bb->succs)\n-      {\t\t\t\t\t\t\t\t\n-        if (TEST_BIT (considered, e->dest->index))\t\t\n+      {\n+        if (TEST_BIT (considered, e->dest->index))\n           dataflow->problem->con_fun_n (e);\n-      }\t\t\t\t\t\t\t\t\n+      }\n   else if (dataflow->problem->con_fun_0)\n     dataflow->problem->con_fun_0 (bb);\n \n   if (dataflow->problem->trans_fun (bb_index))\n     {\n-      /* The out set of this block has changed. \n+      /* The out set of this block has changed.\n          Propagate to the outgoing blocks.  */\n       FOR_EACH_EDGE (e, ei, bb->preds)\n         {\n@@ -937,7 +937,7 @@ df_worklist_propagate_backward (struct dataflow *dataflow,\n \n /* This will free \"pending\". */\n \n-static void \n+static void\n df_worklist_dataflow_doublequeue (struct dataflow *dataflow,\n \t\t\t  \t  bitmap pending,\n                                   sbitmap considered,\n@@ -972,7 +972,7 @@ df_worklist_dataflow_doublequeue (struct dataflow *dataflow,\n \t    df_worklist_propagate_forward (dataflow, bb_index,\n \t\t\t\t\t   bbindex_to_postorder,\n \t\t\t\t\t   pending, considered);\n-\t  else \n+\t  else\n \t    df_worklist_propagate_backward (dataflow, bb_index,\n \t\t\t\t\t    bbindex_to_postorder,\n \t\t\t\t\t    pending, considered);\n@@ -993,13 +993,13 @@ df_worklist_dataflow_doublequeue (struct dataflow *dataflow,\n }\n \n /* Worklist-based dataflow solver. It uses sbitmap as a worklist,\n-   with \"n\"-th bit representing the n-th block in the reverse-postorder order. \n+   with \"n\"-th bit representing the n-th block in the reverse-postorder order.\n    The solver is a double-queue algorithm similar to the \"double stack\" solver\n    from Cooper, Harvey and Kennedy, \"Iterative data-flow analysis, Revisited\".\n    The only significant difference is that the worklist in this implementation\n    is always sorted in RPO of the CFG visiting direction.  */\n \n-void \n+void\n df_worklist_dataflow (struct dataflow *dataflow,\n                       bitmap blocks_to_consider,\n                       int *blocks_in_postorder,\n@@ -1069,16 +1069,16 @@ df_prune_to_subcfg (int list[], unsigned len, bitmap blocks)\n }\n \n \n-/* Execute dataflow analysis on a single dataflow problem. \n+/* Execute dataflow analysis on a single dataflow problem.\n \n    BLOCKS_TO_CONSIDER are the blocks whose solution can either be\n    examined or will be computed.  For calls from DF_ANALYZE, this is\n-   the set of blocks that has been passed to DF_SET_BLOCKS.  \n+   the set of blocks that has been passed to DF_SET_BLOCKS.\n */\n \n void\n-df_analyze_problem (struct dataflow *dflow, \n-\t\t    bitmap blocks_to_consider, \n+df_analyze_problem (struct dataflow *dflow,\n+\t\t    bitmap blocks_to_consider,\n \t\t    int *postorder, int n_blocks)\n {\n   timevar_push (dflow->problem->tv_id);\n@@ -1088,7 +1088,7 @@ df_analyze_problem (struct dataflow *dflow,\n     dflow->problem->verify_start_fun ();\n #endif\n \n-  /* (Re)Allocate the datastructures necessary to solve the problem.  */ \n+  /* (Re)Allocate the datastructures necessary to solve the problem.  */\n   if (dflow->problem->alloc_fun)\n     dflow->problem->alloc_fun (blocks_to_consider);\n \n@@ -1125,7 +1125,7 @@ df_analyze (void)\n   bitmap current_all_blocks = BITMAP_ALLOC (&df_bitmap_obstack);\n   bool everything;\n   int i;\n-  \n+\n   if (df->postorder)\n     free (df->postorder);\n   if (df->postorder_inverted)\n@@ -1167,10 +1167,10 @@ df_analyze (void)\n     {\n       everything = false;\n       bitmap_and_into (df->blocks_to_analyze, current_all_blocks);\n-      df->n_blocks = df_prune_to_subcfg (df->postorder, \n+      df->n_blocks = df_prune_to_subcfg (df->postorder,\n \t\t\t\t\t df->n_blocks, df->blocks_to_analyze);\n-      df->n_blocks_inverted = df_prune_to_subcfg (df->postorder_inverted, \n-\t\t\t                          df->n_blocks_inverted, \n+      df->n_blocks_inverted = df_prune_to_subcfg (df->postorder_inverted,\n+\t\t\t                          df->n_blocks_inverted,\n                                                   df->blocks_to_analyze);\n       BITMAP_FREE (current_all_blocks);\n     }\n@@ -1214,7 +1214,7 @@ df_analyze (void)\n \n /* Return the number of basic blocks from the last call to df_analyze.  */\n \n-int \n+int\n df_get_n_blocks (enum df_flow_dir dir)\n {\n   gcc_assert (dir != DF_NONE);\n@@ -1230,7 +1230,7 @@ df_get_n_blocks (enum df_flow_dir dir)\n }\n \n \n-/* Return a pointer to the array of basic blocks in the reverse postorder. \n+/* Return a pointer to the array of basic blocks in the reverse postorder.\n    Depending on the direction of the dataflow problem,\n    it returns either the usual reverse postorder array\n    or the reverse postorder of inverted traversal. */\n@@ -1248,7 +1248,7 @@ df_get_postorder (enum df_flow_dir dir)\n   return df->postorder;\n }\n \n-static struct df_problem user_problem; \n+static struct df_problem user_problem;\n static struct dataflow user_dflow;\n \n /* Interface for calling iterative dataflow with user defined\n@@ -1277,7 +1277,7 @@ df_simple_dataflow (enum df_flow_dir dir,\n   df_worklist_dataflow (&user_dflow, blocks, postorder, n_blocks);\n }\n \n-\t\t\t      \n+\n \f\n /*----------------------------------------------------------------------------\n    Functions to support limited incremental change.\n@@ -1300,7 +1300,7 @@ df_get_bb_info (struct dataflow *dflow, unsigned int index)\n /* Set basic block info.  */\n \n static void\n-df_set_bb_info (struct dataflow *dflow, unsigned int index, \n+df_set_bb_info (struct dataflow *dflow, unsigned int index,\n \t\tvoid *bb_info)\n {\n   gcc_assert (dflow->block_info);\n@@ -1310,12 +1310,12 @@ df_set_bb_info (struct dataflow *dflow, unsigned int index,\n \n /* Mark the solutions as being out of date.  */\n \n-void \n+void\n df_mark_solutions_dirty (void)\n {\n   if (df)\n     {\n-      int p; \n+      int p;\n       for (p = 1; p < df->num_problems_defined; p++)\n \tdf->problems_in_order[p]->solutions_dirty = true;\n     }\n@@ -1324,25 +1324,25 @@ df_mark_solutions_dirty (void)\n \n /* Return true if BB needs it's transfer functions recomputed.  */\n \n-bool \n+bool\n df_get_bb_dirty (basic_block bb)\n {\n   if (df && df_live)\n     return bitmap_bit_p (df_live->out_of_date_transfer_functions, bb->index);\n-  else \n+  else\n     return false;\n }\n \n \n /* Mark BB as needing it's transfer functions as being out of\n    date.  */\n \n-void \n+void\n df_set_bb_dirty (basic_block bb)\n {\n   if (df)\n     {\n-      int p; \n+      int p;\n       for (p = 1; p < df->num_problems_defined; p++)\n \t{\n \t  struct dataflow *dflow = df->problems_in_order[p];\n@@ -1359,7 +1359,7 @@ df_set_bb_dirty (basic_block bb)\n static void\n df_clear_bb_dirty (basic_block bb)\n {\n-  int p; \n+  int p;\n   for (p = 1; p < df->num_problems_defined; p++)\n     {\n       struct dataflow *dflow = df->problems_in_order[p];\n@@ -1370,7 +1370,7 @@ df_clear_bb_dirty (basic_block bb)\n /* Called from the rtl_compact_blocks to reorganize the problems basic\n    block info.  */\n \n-void \n+void\n df_compact_blocks (void)\n {\n   int i, p;\n@@ -1396,7 +1396,7 @@ df_compact_blocks (void)\n \t    bitmap_set_bit (dflow->out_of_date_transfer_functions, EXIT_BLOCK);\n \n \t  i = NUM_FIXED_BLOCKS;\n-\t  FOR_EACH_BB (bb) \n+\t  FOR_EACH_BB (bb)\n \t    {\n \t      if (bitmap_bit_p (tmp, bb->index))\n \t\tbitmap_set_bit (dflow->out_of_date_transfer_functions, i);\n@@ -1414,20 +1414,20 @@ df_compact_blocks (void)\n \t     place in the block_info vector.  Null out the copied\n \t     item.  The entry and exit blocks never move.  */\n \t  i = NUM_FIXED_BLOCKS;\n-\t  FOR_EACH_BB (bb) \n+\t  FOR_EACH_BB (bb)\n \t    {\n \t      df_set_bb_info (dflow, i, problem_temps[bb->index]);\n \t      problem_temps[bb->index] = NULL;\n \t      i++;\n \t    }\n-\t  memset (dflow->block_info + i, 0, \n+\t  memset (dflow->block_info + i, 0,\n \t\t  (last_basic_block - i) *sizeof (void *));\n \n \t  /* Free any block infos that were not copied (and NULLed).\n \t     These are from orphaned blocks.  */\n \t  for (i = NUM_FIXED_BLOCKS; i < last_basic_block; i++)\n \t    {\n-\t      basic_block bb = BASIC_BLOCK (i); \n+\t      basic_block bb = BASIC_BLOCK (i);\n \t      if (problem_temps[i] && bb)\n \t\tdflow->problem->free_bb_fun\n \t\t  (bb, problem_temps[i]);\n@@ -1446,7 +1446,7 @@ df_compact_blocks (void)\n       bitmap_copy (tmp, df->blocks_to_analyze);\n       bitmap_clear (df->blocks_to_analyze);\n       i = NUM_FIXED_BLOCKS;\n-      FOR_EACH_BB (bb) \n+      FOR_EACH_BB (bb)\n \t{\n \t  if (bitmap_bit_p (tmp, bb->index))\n \t    bitmap_set_bit (df->blocks_to_analyze, i);\n@@ -1459,7 +1459,7 @@ df_compact_blocks (void)\n   free (problem_temps);\n \n   i = NUM_FIXED_BLOCKS;\n-  FOR_EACH_BB (bb) \n+  FOR_EACH_BB (bb)\n     {\n       SET_BASIC_BLOCK (i, bb);\n       bb->index = i;\n@@ -1481,7 +1481,7 @@ df_compact_blocks (void)\n /* Shove NEW_BLOCK in at OLD_INDEX.  Called from ifcvt to hack a\n    block.  There is no excuse for people to do this kind of thing.  */\n \n-void \n+void\n df_bb_replace (int old_index, basic_block new_block)\n {\n   int new_block_index = new_block->index;\n@@ -1500,7 +1500,7 @@ df_bb_replace (int old_index, basic_block new_block)\n \t{\n \t  df_grow_bb_info (dflow);\n \t  gcc_assert (df_get_bb_info (dflow, old_index) == NULL);\n-\t  df_set_bb_info (dflow, old_index, \n+\t  df_set_bb_info (dflow, old_index,\n \t\t\t  df_get_bb_info (dflow, new_block_index));\n \t}\n     }\n@@ -1525,7 +1525,7 @@ df_bb_delete (int bb_index)\n \n   if (!df)\n     return;\n-  \n+\n   for (i = 0; i < df->num_problems_defined; i++)\n     {\n       struct dataflow *dflow = df->problems_in_order[i];\n@@ -1534,7 +1534,7 @@ df_bb_delete (int bb_index)\n \t  void *bb_info = df_get_bb_info (dflow, bb_index);\n \t  if (bb_info)\n \t    {\n-\t      dflow->problem->free_bb_fun (bb, bb_info); \n+\t      dflow->problem->free_bb_fun (bb, bb_info);\n \t      df_set_bb_info (dflow, bb_index, NULL);\n \t    }\n \t}\n@@ -1620,7 +1620,7 @@ df_check_cfg_clean (void)\n   if (df_lr->solutions_dirty)\n     return;\n \n-  if (saved_cfg == NULL) \n+  if (saved_cfg == NULL)\n     return;\n \n   new_map = df_compute_cfg_image ();\n@@ -1648,7 +1648,7 @@ df_set_clean_cfg (void)\n \n /* Return first def of REGNO within BB.  */\n \n-df_ref \n+df_ref\n df_bb_regno_first_def_find (basic_block bb, unsigned int regno)\n {\n   rtx insn;\n@@ -1674,7 +1674,7 @@ df_bb_regno_first_def_find (basic_block bb, unsigned int regno)\n \n /* Return last def of REGNO within BB.  */\n \n-df_ref \n+df_ref\n df_bb_regno_last_def_find (basic_block bb, unsigned int regno)\n {\n   rtx insn;\n@@ -1701,7 +1701,7 @@ df_bb_regno_last_def_find (basic_block bb, unsigned int regno)\n /* Finds the reference corresponding to the definition of REG in INSN.\n    DF is the dataflow object.  */\n \n-df_ref \n+df_ref\n df_find_def (rtx insn, rtx reg)\n {\n   unsigned int uid;\n@@ -1723,19 +1723,19 @@ df_find_def (rtx insn, rtx reg)\n }\n \n \n-/* Return true if REG is defined in INSN, zero otherwise.  */ \n+/* Return true if REG is defined in INSN, zero otherwise.  */\n \n bool\n df_reg_defined (rtx insn, rtx reg)\n {\n   return df_find_def (insn, reg) != NULL;\n }\n-  \n+\n \n /* Finds the reference corresponding to the use of REG in INSN.\n    DF is the dataflow object.  */\n-  \n-df_ref \n+\n+df_ref\n df_find_use (rtx insn, rtx reg)\n {\n   unsigned int uid;\n@@ -1751,26 +1751,26 @@ df_find_use (rtx insn, rtx reg)\n       df_ref use = *use_rec;\n       if (rtx_equal_p (DF_REF_REAL_REG (use), reg))\n \treturn use;\n-    } \n+    }\n   if (df->changeable_flags & DF_EQ_NOTES)\n     for (use_rec = DF_INSN_UID_EQ_USES (uid); *use_rec; use_rec++)\n       {\n \tdf_ref use = *use_rec;\n \tif (rtx_equal_p (DF_REF_REAL_REG (use), reg))\n-\t  return use; \n+\t  return use;\n       }\n   return NULL;\n }\n \n \n-/* Return true if REG is referenced in INSN, zero otherwise.  */ \n+/* Return true if REG is referenced in INSN, zero otherwise.  */\n \n bool\n df_reg_used (rtx insn, rtx reg)\n {\n   return df_find_use (insn, reg) != NULL;\n }\n-  \n+\n \f\n /*----------------------------------------------------------------------------\n    Debugging and printing functions.\n@@ -1895,18 +1895,18 @@ df_dump_region (FILE *file)\n \n       fprintf (file, \"\\n\\nstarting region dump\\n\");\n       df_dump_start (file);\n-      \n-      EXECUTE_IF_SET_IN_BITMAP (df->blocks_to_analyze, 0, bb_index, bi) \n+\n+      EXECUTE_IF_SET_IN_BITMAP (df->blocks_to_analyze, 0, bb_index, bi)\n \t{\n \t  basic_block bb = BASIC_BLOCK (bb_index);\n-\t  \n+\n \t  df_print_bb_index (bb, file);\n \t  df_dump_top (bb, file);\n \t  df_dump_bottom (bb, file);\n \t}\n       fprintf (file, \"\\n\");\n     }\n-  else \n+  else\n     df_dump (file);\n }\n \n@@ -1934,13 +1934,13 @@ df_dump_start (FILE *file)\n \t{\n \t  df_dump_problem_function fun = dflow->problem->dump_start_fun;\n \t  if (fun)\n-\t    fun(file); \n+\t    fun(file);\n \t}\n     }\n }\n \n \n-/* Dump the top of the block information for BB.  */ \n+/* Dump the top of the block information for BB.  */\n \n void\n df_dump_top (basic_block bb, FILE *file)\n@@ -1957,13 +1957,13 @@ df_dump_top (basic_block bb, FILE *file)\n \t{\n \t  df_dump_bb_problem_function bbfun = dflow->problem->dump_top_fun;\n \t  if (bbfun)\n-\t    bbfun (bb, file); \n+\t    bbfun (bb, file);\n \t}\n     }\n }\n \n \n-/* Dump the bottom of the block information for BB.  */ \n+/* Dump the bottom of the block information for BB.  */\n \n void\n df_dump_bottom (basic_block bb, FILE *file)\n@@ -1980,7 +1980,7 @@ df_dump_bottom (basic_block bb, FILE *file)\n \t{\n \t  df_dump_bb_problem_function bbfun = dflow->problem->dump_bottom_fun;\n \t  if (bbfun)\n-\t    bbfun (bb, file); \n+\t    bbfun (bb, file);\n \t}\n     }\n }\n@@ -2028,16 +2028,16 @@ df_mws_dump (struct df_mw_hardreg **mws, FILE *file)\n {\n   while (*mws)\n     {\n-      fprintf (file, \"mw %c r[%d..%d]\\n\", \n+      fprintf (file, \"mw %c r[%d..%d]\\n\",\n \t       (DF_MWS_REG_DEF_P (*mws)) ? 'd' : 'u',\n \t       (*mws)->start_regno, (*mws)->end_regno);\n       mws++;\n     }\n }\n \n \n-static void \n-df_insn_uid_debug (unsigned int uid, \n+static void\n+df_insn_uid_debug (unsigned int uid,\n \t\t   bool follow_chain, FILE *file)\n {\n   fprintf (file, \"insn %d luid %d\",\n@@ -2085,7 +2085,7 @@ df_insn_debug_regno (rtx insn, FILE *file)\n \t   INSN_UID (insn), BLOCK_FOR_INSN (insn)->index,\n \t   DF_INSN_INFO_LUID (insn_info));\n   df_refs_chain_dump (DF_INSN_INFO_DEFS (insn_info), false, file);\n-    \n+\n   fprintf (file, \" uses \");\n   df_refs_chain_dump (DF_INSN_INFO_USES (insn_info), false, file);\n "}, {"sha": "cc7ab882a366fa690e423e4ee6105cb4236e20bb", "filename": "gcc/df-problems.c", "status": "modified", "additions": 276, "deletions": 276, "changes": 552, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -1,7 +1,7 @@\n /* Standard problems for dataflow support routines.\n    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,\n    2008, 2009 Free Software Foundation, Inc.\n-   Originally contributed by Michael P. Hayes \n+   Originally contributed by Michael P. Hayes\n              (m.hayes@elec.canterbury.ac.nz, mhayes@redhat.com)\n    Major rewrite contributed by Danny Berlin (dberlin@dberlin.org)\n              and Kenneth Zadeck (zadeck@naturalbridge.com).\n@@ -47,7 +47,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Note that turning REG_DEAD_DEBUGGING on will cause\n    gcc.c-torture/unsorted/dump-noaddr.c to fail because it prints\n-   addresses in the dumps.  */  \n+   addresses in the dumps.  */\n #if 0\n #define REG_DEAD_DEBUGGING\n #endif\n@@ -73,7 +73,7 @@ df_get_live_out (basic_block bb)\n \n   if (df_live)\n     return DF_LIVE_OUT (bb);\n-  else \n+  else\n     return DF_LR_OUT (bb);\n }\n \n@@ -89,7 +89,7 @@ df_get_live_in (basic_block bb)\n \n   if (df_live)\n     return DF_LIVE_IN (bb);\n-  else \n+  else\n     return DF_LR_IN (bb);\n }\n \n@@ -136,7 +136,7 @@ df_chain_dump (struct df_link *link, FILE *file)\n \n /* Print some basic block info as part of df_dump.  */\n \n-void \n+void\n df_print_bb_index (basic_block bb, FILE *file)\n {\n   edge e;\n@@ -147,13 +147,13 @@ df_print_bb_index (basic_block bb, FILE *file)\n     {\n       basic_block pred = e->src;\n       fprintf (file, \"%d%s \", pred->index, e->flags & EDGE_EH ? \"(EH)\" : \"\");\n-    } \n+    }\n   fprintf (file, \")->[%d]->( \", bb->index);\n   FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n       basic_block succ = e->dest;\n       fprintf (file, \"%d%s \", succ->index, e->flags & EDGE_EH ? \"(EH)\" : \"\");\n-    } \n+    }\n   fprintf (file, \")\\n\");\n }\n \n@@ -168,12 +168,12 @@ df_print_bb_index (basic_block bb, FILE *file)\n    ----------------------------------------------------------------------------*/\n \n /* This problem plays a large number of games for the sake of\n-   efficiency.  \n-   \n+   efficiency.\n+\n    1) The order of the bits in the bitvectors.  After the scanning\n    phase, all of the defs are sorted.  All of the defs for the reg 0\n    are first, followed by all defs for reg 1 and so on.\n-   \n+\n    2) There are two kill sets, one if the number of defs is less or\n    equal to DF_SPARSE_THRESHOLD and another if the number of defs is\n    greater.\n@@ -195,8 +195,8 @@ df_print_bb_index (basic_block bb, FILE *file)\n struct df_rd_problem_data\n {\n   /* The set of defs to regs invalidated by call.  */\n-  bitmap sparse_invalidated_by_call;  \n-  /* The set of defs to regs invalidate by call for rd.  */  \n+  bitmap sparse_invalidated_by_call;\n+  /* The set of defs to regs invalidate by call for rd.  */\n   bitmap dense_invalidated_by_call;\n   /* An obstack for the bitmaps we need for this problem.  */\n   bitmap_obstack rd_bitmaps;\n@@ -205,7 +205,7 @@ struct df_rd_problem_data\n /* Set basic block info.  */\n \n static void\n-df_rd_set_bb_info (unsigned int index, \n+df_rd_set_bb_info (unsigned int index,\n \t\t   struct df_rd_bb_info *bb_info)\n {\n   gcc_assert (df_rd);\n@@ -217,7 +217,7 @@ df_rd_set_bb_info (unsigned int index,\n /* Free basic block info.  */\n \n static void\n-df_rd_free_bb_info (basic_block bb ATTRIBUTE_UNUSED, \n+df_rd_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n \t\t    void *vbb_info)\n {\n   struct df_rd_bb_info *bb_info = (struct df_rd_bb_info *) vbb_info;\n@@ -236,15 +236,15 @@ df_rd_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n /* Allocate or reset bitmaps for DF_RD blocks. The solution bits are\n    not touched unless the block is new.  */\n \n-static void \n+static void\n df_rd_alloc (bitmap all_blocks)\n {\n   unsigned int bb_index;\n   bitmap_iterator bi;\n   struct df_rd_problem_data *problem_data;\n \n   if (!df_rd->block_pool)\n-    df_rd->block_pool = create_alloc_pool (\"df_rd_block pool\", \n+    df_rd->block_pool = create_alloc_pool (\"df_rd_block pool\",\n \t\t\t\t\t   sizeof (struct df_rd_bb_info), 50);\n \n   if (df_rd->problem_data)\n@@ -253,7 +253,7 @@ df_rd_alloc (bitmap all_blocks)\n       bitmap_clear (problem_data->sparse_invalidated_by_call);\n       bitmap_clear (problem_data->dense_invalidated_by_call);\n     }\n-  else \n+  else\n     {\n       problem_data = XNEW (struct df_rd_problem_data);\n       df_rd->problem_data = problem_data;\n@@ -275,13 +275,13 @@ df_rd_alloc (bitmap all_blocks)\n     {\n       struct df_rd_bb_info *bb_info = df_rd_get_bb_info (bb_index);\n       if (bb_info)\n-\t{ \n+\t{\n \t  bitmap_clear (bb_info->kill);\n \t  bitmap_clear (bb_info->sparse_kill);\n \t  bitmap_clear (bb_info->gen);\n \t}\n       else\n-\t{ \n+\t{\n \t  bb_info = (struct df_rd_bb_info *) pool_alloc (df_rd->block_pool);\n \t  df_rd_set_bb_info (bb_index, bb_info);\n \t  bb_info->kill = BITMAP_ALLOC (&problem_data->rd_bitmaps);\n@@ -310,8 +310,8 @@ df_rd_simulate_artificial_defs_at_top (basic_block bb, bitmap local_rd)\n \t{\n \t  unsigned int dregno = DF_REF_REGNO (def);\n \t  if (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n-\t    bitmap_clear_range (local_rd, \n-\t\t\t\tDF_DEFS_BEGIN (dregno), \n+\t    bitmap_clear_range (local_rd,\n+\t\t\t\tDF_DEFS_BEGIN (dregno),\n \t\t\t\tDF_DEFS_COUNT (dregno));\n \t  bitmap_set_bit (local_rd, DF_REF_ID (def));\n \t}\n@@ -336,10 +336,10 @@ df_rd_simulate_one_insn (basic_block bb ATTRIBUTE_UNUSED, rtx insn,\n           || (dregno >= FIRST_PSEUDO_REGISTER))\n         {\n           if (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n-\t    bitmap_clear_range (local_rd, \n-\t\t\t\tDF_DEFS_BEGIN (dregno), \n+\t    bitmap_clear_range (local_rd,\n+\t\t\t\tDF_DEFS_BEGIN (dregno),\n \t\t\t\tDF_DEFS_COUNT (dregno));\n-\t  if (!(DF_REF_FLAGS (def) \n+\t  if (!(DF_REF_FLAGS (def)\n \t\t& (DF_REF_MUST_CLOBBER | DF_REF_MAY_CLOBBER)))\n \t    bitmap_set_bit (local_rd, DF_REF_ID (def));\n \t}\n@@ -352,7 +352,7 @@ df_rd_simulate_one_insn (basic_block bb ATTRIBUTE_UNUSED, rtx insn,\n    of kill sets.   */\n \n static void\n-df_rd_bb_local_compute_process_def (struct df_rd_bb_info *bb_info, \n+df_rd_bb_local_compute_process_def (struct df_rd_bb_info *bb_info,\n \t\t\t\t    df_ref *def_rec,\n \t\t\t\t    int top_flag)\n {\n@@ -364,20 +364,20 @@ df_rd_bb_local_compute_process_def (struct df_rd_bb_info *bb_info,\n \t  unsigned int regno = DF_REF_REGNO (def);\n \t  unsigned int begin = DF_DEFS_BEGIN (regno);\n \t  unsigned int n_defs = DF_DEFS_COUNT (regno);\n-\t  \n+\n \t  if ((!(df->changeable_flags & DF_NO_HARD_REGS))\n \t      || (regno >= FIRST_PSEUDO_REGISTER))\n \t    {\n \t      /* Only the last def(s) for a regno in the block has any\n-\t\t effect.  */ \n+\t\t effect.  */\n \t      if (!bitmap_bit_p (seen_in_block, regno))\n \t\t{\n \t\t  /* The first def for regno in insn gets to knock out the\n \t\t     defs from other instructions.  */\n \t\t  if ((!bitmap_bit_p (seen_in_insn, regno))\n \t\t      /* If the def is to only part of the reg, it does\n \t\t\t not kill the other defs that reach here.  */\n-\t\t      && (!(DF_REF_FLAGS (def) & \n+\t\t      && (!(DF_REF_FLAGS (def) &\n \t\t\t    (DF_REF_PARTIAL | DF_REF_CONDITIONAL | DF_REF_MAY_CLOBBER))))\n \t\t    {\n \t\t      if (n_defs > DF_SPARSE_THRESHOLD)\n@@ -391,11 +391,11 @@ df_rd_bb_local_compute_process_def (struct df_rd_bb_info *bb_info,\n \t\t\t  bitmap_clear_range (bb_info->gen, begin, n_defs);\n \t\t\t}\n \t\t    }\n-\t\t  \n+\n \t\t  bitmap_set_bit (seen_in_insn, regno);\n \t\t  /* All defs for regno in the instruction may be put into\n \t\t     the gen set.  */\n-\t\t  if (!(DF_REF_FLAGS (def) \n+\t\t  if (!(DF_REF_FLAGS (def)\n \t\t\t& (DF_REF_MUST_CLOBBER | DF_REF_MAY_CLOBBER)))\n \t\t    bitmap_set_bit (bb_info->gen, DF_REF_ID (def));\n \t\t}\n@@ -419,7 +419,7 @@ df_rd_bb_local_compute (unsigned int bb_index)\n \n   /* Artificials are only hard regs.  */\n   if (!(df->changeable_flags & DF_NO_HARD_REGS))\n-    df_rd_bb_local_compute_process_def (bb_info, \n+    df_rd_bb_local_compute_process_def (bb_info,\n \t\t\t\t\tdf_get_artificial_defs (bb_index),\n \t\t\t\t\t0);\n \n@@ -430,7 +430,7 @@ df_rd_bb_local_compute (unsigned int bb_index)\n       if (!INSN_P (insn))\n \tcontinue;\n \n-      df_rd_bb_local_compute_process_def (bb_info, \n+      df_rd_bb_local_compute_process_def (bb_info,\n \t\t\t\t\t  DF_INSN_UID_DEFS (uid), 0);\n \n       /* This complex dance with the two bitmaps is required because\n@@ -447,7 +447,7 @@ df_rd_bb_local_compute (unsigned int bb_index)\n      are going backwards through the block and these are logically at\n      the start.  */\n   if (!(df->changeable_flags & DF_NO_HARD_REGS))\n-    df_rd_bb_local_compute_process_def (bb_info, \n+    df_rd_bb_local_compute_process_def (bb_info,\n \t\t\t\t\tdf_get_artificial_defs (bb_index),\n \t\t\t\t\tDF_REF_AT_TOP);\n }\n@@ -475,15 +475,15 @@ df_rd_local_compute (bitmap all_blocks)\n     {\n       df_rd_bb_local_compute (bb_index);\n     }\n-  \n+\n   /* Set up the knockout bit vectors to be applied across EH_EDGES.  */\n   EXECUTE_IF_SET_IN_BITMAP (regs_invalidated_by_call_regset, 0, regno, bi)\n     {\n       if (DF_DEFS_COUNT (regno) > DF_SPARSE_THRESHOLD)\n \tbitmap_set_bit (sparse_invalidated, regno);\n       else\n-\tbitmap_set_range (dense_invalidated, \n-\t\t\t  DF_DEFS_BEGIN (regno), \n+\tbitmap_set_range (dense_invalidated,\n+\t\t\t  DF_DEFS_BEGIN (regno),\n \t\t\t  DF_DEFS_COUNT (regno));\n     }\n \n@@ -494,7 +494,7 @@ df_rd_local_compute (bitmap all_blocks)\n \n /* Initialize the solution bit vectors for problem.  */\n \n-static void \n+static void\n df_rd_init_solution (bitmap all_blocks)\n {\n   unsigned int bb_index;\n@@ -503,7 +503,7 @@ df_rd_init_solution (bitmap all_blocks)\n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n     {\n       struct df_rd_bb_info *bb_info = df_rd_get_bb_info (bb_index);\n-      \n+\n       bitmap_copy (bb_info->out, bb_info->gen);\n       bitmap_clear (bb_info->in);\n     }\n@@ -517,7 +517,7 @@ df_rd_confluence_n (edge e)\n   bitmap op1 = df_rd_get_bb_info (e->dest->index)->in;\n   bitmap op2 = df_rd_get_bb_info (e->src->index)->out;\n \n-  if (e->flags & EDGE_FAKE) \n+  if (e->flags & EDGE_FAKE)\n     return;\n \n   if (e->flags & EDGE_EH)\n@@ -535,8 +535,8 @@ df_rd_confluence_n (edge e)\n \n       EXECUTE_IF_SET_IN_BITMAP (sparse_invalidated, 0, regno, bi)\n  \t{\n- \t  bitmap_clear_range (tmp, \n- \t\t\t      DF_DEFS_BEGIN (regno), \n+ \t  bitmap_clear_range (tmp,\n+ \t\t\t      DF_DEFS_BEGIN (regno),\n  \t\t\t      DF_DEFS_COUNT (regno));\n \t}\n       bitmap_ior_into (op1, tmp);\n@@ -563,7 +563,7 @@ df_rd_transfer_function (int bb_index)\n \n   if (bitmap_empty_p (sparse_kill))\n     return  bitmap_ior_and_compl (out, gen, in, kill);\n-  else \n+  else\n     {\n       struct df_rd_problem_data *problem_data;\n       bool changed = false;\n@@ -577,8 +577,8 @@ df_rd_transfer_function (int bb_index)\n       bitmap_copy (tmp, in);\n       EXECUTE_IF_SET_IN_BITMAP (sparse_kill, 0, regno, bi)\n \t{\n-\t  bitmap_clear_range (tmp, \n-\t\t\t      DF_DEFS_BEGIN (regno), \n+\t  bitmap_clear_range (tmp,\n+\t\t\t      DF_DEFS_BEGIN (regno),\n \t\t\t      DF_DEFS_COUNT (regno));\n \t}\n       bitmap_and_compl_into (tmp, kill);\n@@ -589,7 +589,7 @@ df_rd_transfer_function (int bb_index)\n \t  BITMAP_FREE (out);\n \t  bb_info->out = tmp;\n \t}\n-      else \n+      else\n \t  BITMAP_FREE (tmp);\n       return changed;\n     }\n@@ -608,7 +608,7 @@ df_rd_free (void)\n     {\n       free_alloc_pool (df_rd->block_pool);\n       bitmap_obstack_release (&problem_data->rd_bitmaps);\n-      \n+\n       df_rd->block_info_size = 0;\n       free (df_rd->block_info);\n       free (df_rd->problem_data);\n@@ -626,8 +626,8 @@ df_rd_start_dump (FILE *file)\n     = (struct df_rd_problem_data *) df_rd->problem_data;\n   unsigned int m = DF_REG_SIZE(df);\n   unsigned int regno;\n-  \n-  if (!df_rd->block_info) \n+\n+  if (!df_rd->block_info)\n     return;\n \n   fprintf (file, \";; Reaching defs:\\n\\n\");\n@@ -639,8 +639,8 @@ df_rd_start_dump (FILE *file)\n \n   for (regno = 0; regno < m; regno++)\n     if (DF_DEFS_COUNT (regno))\n-      fprintf (file, \"%d[%d,%d] \", regno, \n-\t       DF_DEFS_BEGIN (regno), \n+      fprintf (file, \"%d[%d,%d] \", regno,\n+\t       DF_DEFS_BEGIN (regno),\n \t       DF_DEFS_COUNT (regno));\n   fprintf (file, \"\\n\");\n \n@@ -655,7 +655,7 @@ df_rd_top_dump (basic_block bb, FILE *file)\n   struct df_rd_bb_info *bb_info = df_rd_get_bb_info (bb->index);\n   if (!bb_info || !bb_info->in)\n     return;\n-  \n+\n   fprintf (file, \";; rd  in  \\t(%d)\\n\", (int) bitmap_count_bits (bb_info->in));\n   dump_bitmap (file, bb_info->in);\n   fprintf (file, \";; rd  gen \\t(%d)\\n\", (int) bitmap_count_bits (bb_info->gen));\n@@ -673,7 +673,7 @@ df_rd_bottom_dump (basic_block bb, FILE *file)\n   struct df_rd_bb_info *bb_info = df_rd_get_bb_info (bb->index);\n   if (!bb_info || !bb_info->out)\n     return;\n-  \n+\n   fprintf (file, \";; rd  out \\t(%d)\\n\", (int) bitmap_count_bits (bb_info->out));\n   dump_bitmap (file, bb_info->out);\n }\n@@ -690,8 +690,8 @@ static struct df_problem problem_RD =\n   df_rd_local_compute,        /* Local compute function.  */\n   df_rd_init_solution,        /* Init the solution specific data.  */\n   df_worklist_dataflow,       /* Worklist solver.  */\n-  NULL,                       /* Confluence operator 0.  */ \n-  df_rd_confluence_n,         /* Confluence operator n.  */ \n+  NULL,                       /* Confluence operator 0.  */\n+  df_rd_confluence_n,         /* Confluence operator n.  */\n   df_rd_transfer_function,    /* Transfer function.  */\n   NULL,                       /* Finalize function.  */\n   df_rd_free,                 /* Free all of the problem information.  */\n@@ -702,7 +702,7 @@ static struct df_problem problem_RD =\n   NULL,                       /* Incremental solution verify start.  */\n   NULL,                       /* Incremental solution verify end.  */\n   NULL,                       /* Dependent problem.  */\n-  TV_DF_RD,                   /* Timing variable.  */ \n+  TV_DF_RD,                   /* Timing variable.  */\n   true                        /* Reset blocks on dropping out of blocks_to_analyze.  */\n };\n \n@@ -739,19 +739,19 @@ struct df_lr_problem_data\n /* Set basic block info.  */\n \n static void\n-df_lr_set_bb_info (unsigned int index, \n+df_lr_set_bb_info (unsigned int index,\n \t\t   struct df_lr_bb_info *bb_info)\n {\n   gcc_assert (df_lr);\n   gcc_assert (index < df_lr->block_info_size);\n   df_lr->block_info[index] = bb_info;\n }\n \n- \n+\n /* Free basic block info.  */\n \n static void\n-df_lr_free_bb_info (basic_block bb ATTRIBUTE_UNUSED, \n+df_lr_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n \t\t    void *vbb_info)\n {\n   struct df_lr_bb_info *bb_info = (struct df_lr_bb_info *) vbb_info;\n@@ -769,14 +769,14 @@ df_lr_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n /* Allocate or reset bitmaps for DF_LR blocks. The solution bits are\n    not touched unless the block is new.  */\n \n-static void \n+static void\n df_lr_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n {\n   unsigned int bb_index;\n   bitmap_iterator bi;\n \n   if (!df_lr->block_pool)\n-    df_lr->block_pool = create_alloc_pool (\"df_lr_block pool\", \n+    df_lr->block_pool = create_alloc_pool (\"df_lr_block pool\",\n \t\t\t\t\t   sizeof (struct df_lr_bb_info), 50);\n \n   df_grow_bb_info (df_lr);\n@@ -785,12 +785,12 @@ df_lr_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n     {\n       struct df_lr_bb_info *bb_info = df_lr_get_bb_info (bb_index);\n       if (bb_info)\n-\t{ \n+\t{\n \t  bitmap_clear (bb_info->def);\n \t  bitmap_clear (bb_info->use);\n \t}\n       else\n-\t{ \n+\t{\n \t  bb_info = (struct df_lr_bb_info *) pool_alloc (df_lr->block_pool);\n \t  df_lr_set_bb_info (bb_index, bb_info);\n \t  bb_info->use = BITMAP_ALLOC (NULL);\n@@ -806,7 +806,7 @@ df_lr_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n \n /* Reset the global solution for recalculation.  */\n \n-static void \n+static void\n df_lr_reset (bitmap all_blocks)\n {\n   unsigned int bb_index;\n@@ -859,7 +859,7 @@ df_lr_bb_local_compute (unsigned int bb_index)\n       unsigned int uid = INSN_UID (insn);\n \n       if (!NONDEBUG_INSN_P (insn))\n-\tcontinue;\t\n+\tcontinue;\n \n       for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n \t{\n@@ -895,7 +895,7 @@ df_lr_bb_local_compute (unsigned int bb_index)\n \t  bitmap_clear_bit (bb_info->use, dregno);\n \t}\n     }\n-  \n+\n #ifdef EH_USES\n   /* Process the uses that are live into an exception handler.  */\n   for (use_rec = df_get_artificial_uses (bb_index); *use_rec; use_rec++)\n@@ -923,12 +923,12 @@ df_lr_local_compute (bitmap all_blocks ATTRIBUTE_UNUSED)\n {\n   unsigned int bb_index;\n   bitmap_iterator bi;\n-    \n+\n   bitmap_clear (df->hardware_regs_used);\n-  \n+\n   /* The all-important stack pointer must always be live.  */\n   bitmap_set_bit (df->hardware_regs_used, STACK_POINTER_REGNUM);\n-  \n+\n   /* Before reload, there are a few registers that must be forced\n      live everywhere -- which might not already be the case for\n      blocks within infinite loops.  */\n@@ -937,21 +937,21 @@ df_lr_local_compute (bitmap all_blocks ATTRIBUTE_UNUSED)\n       /* Any reference to any pseudo before reload is a potential\n \t reference of the frame pointer.  */\n       bitmap_set_bit (df->hardware_regs_used, FRAME_POINTER_REGNUM);\n-      \n+\n #if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n       /* Pseudos with argument area equivalences may require\n \t reloading via the argument pointer.  */\n       if (fixed_regs[ARG_POINTER_REGNUM])\n \tbitmap_set_bit (df->hardware_regs_used, ARG_POINTER_REGNUM);\n #endif\n-      \n+\n       /* Any constant, or pseudo with constant equivalences, may\n \t require reloading from memory using the pic register.  */\n       if ((unsigned) PIC_OFFSET_TABLE_REGNUM != INVALID_REGNUM\n \t  && fixed_regs[PIC_OFFSET_TABLE_REGNUM])\n \tbitmap_set_bit (df->hardware_regs_used, PIC_OFFSET_TABLE_REGNUM);\n     }\n-  \n+\n   EXECUTE_IF_SET_IN_BITMAP (df_lr->out_of_date_transfer_functions, 0, bb_index, bi)\n     {\n       if (bb_index == EXIT_BLOCK)\n@@ -971,7 +971,7 @@ df_lr_local_compute (bitmap all_blocks ATTRIBUTE_UNUSED)\n \n /* Initialize the solution vectors.  */\n \n-static void \n+static void\n df_lr_init (bitmap all_blocks)\n {\n   unsigned int bb_index;\n@@ -995,7 +995,7 @@ df_lr_confluence_0 (basic_block bb)\n   bitmap op1 = df_lr_get_bb_info (bb->index)->out;\n   if (bb != EXIT_BLOCK_PTR)\n     bitmap_copy (op1, df->hardware_regs_used);\n-} \n+}\n \n \n /* Confluence function that ignores fake edges.  */\n@@ -1005,7 +1005,7 @@ df_lr_confluence_n (edge e)\n {\n   bitmap op1 = df_lr_get_bb_info (e->src->index)->out;\n   bitmap op2 = df_lr_get_bb_info (e->dest->index)->in;\n- \n+\n   /* Call-clobbered registers die across exception and call edges.  */\n   /* ??? Abnormal call edges ignored for the moment, as this gets\n      confused by sibling call edges, which crashes reg-stack.  */\n@@ -1015,7 +1015,7 @@ df_lr_confluence_n (edge e)\n     bitmap_ior_into (op1, op2);\n \n   bitmap_ior_into (op1, df->hardware_regs_used);\n-} \n+}\n \n \n /* Transfer function.  */\n@@ -1087,7 +1087,7 @@ df_lr_free (void)\n \t    }\n \t}\n       free_alloc_pool (df_lr->block_pool);\n-      \n+\n       df_lr->block_info_size = 0;\n       free (df_lr->block_info);\n     }\n@@ -1106,7 +1106,7 @@ df_lr_top_dump (basic_block bb, FILE *file)\n   struct df_lr_problem_data *problem_data;\n   if (!bb_info || !bb_info->in)\n     return;\n-      \n+\n   fprintf (file, \";; lr  in  \\t\");\n   df_print_regset (file, bb_info->in);\n   if (df_lr->problem_data)\n@@ -1119,7 +1119,7 @@ df_lr_top_dump (basic_block bb, FILE *file)\n   df_print_regset (file, bb_info->use);\n   fprintf (file, \";; lr  def \\t\");\n   df_print_regset (file, bb_info->def);\n-}  \n+}\n \n \n /* Debugging info at bottom of bb.  */\n@@ -1131,7 +1131,7 @@ df_lr_bottom_dump (basic_block bb, FILE *file)\n   struct df_lr_problem_data *problem_data;\n   if (!bb_info || !bb_info->out)\n     return;\n-  \n+\n   fprintf (file, \";; lr  out \\t\");\n   df_print_regset (file, bb_info->out);\n   if (df_lr->problem_data)\n@@ -1140,7 +1140,7 @@ df_lr_bottom_dump (basic_block bb, FILE *file)\n       fprintf (file, \";;  old out  \\t\");\n       df_print_regset (file, problem_data->out[bb->index]);\n     }\n-}  \n+}\n \n \n /* Build the datastructure to verify that the solution to the dataflow\n@@ -1157,7 +1157,7 @@ df_lr_verify_solution_start (void)\n       return;\n     }\n \n-  /* Set it true so that the solution is recomputed.  */ \n+  /* Set it true so that the solution is recomputed.  */\n   df_lr->solutions_dirty = true;\n \n   problem_data = XNEW (struct df_lr_problem_data);\n@@ -1231,8 +1231,8 @@ static struct df_problem problem_LR =\n   df_lr_local_compute,        /* Local compute function.  */\n   df_lr_init,                 /* Init the solution specific data.  */\n   df_worklist_dataflow,       /* Worklist solver.  */\n-  df_lr_confluence_0,         /* Confluence operator 0.  */ \n-  df_lr_confluence_n,         /* Confluence operator n.  */ \n+  df_lr_confluence_0,         /* Confluence operator 0.  */\n+  df_lr_confluence_n,         /* Confluence operator n.  */\n   df_lr_transfer_function,    /* Transfer function.  */\n   df_lr_finalize,             /* Finalize function.  */\n   df_lr_free,                 /* Free all of the problem information.  */\n@@ -1243,7 +1243,7 @@ static struct df_problem problem_LR =\n   df_lr_verify_solution_start,/* Incremental solution verify start.  */\n   df_lr_verify_solution_end,  /* Incremental solution verify end.  */\n   NULL,                       /* Dependent problem.  */\n-  TV_DF_LR,                   /* Timing variable.  */ \n+  TV_DF_LR,                   /* Timing variable.  */\n   false                       /* Reset blocks on dropping out of blocks_to_analyze.  */\n };\n \n@@ -1294,7 +1294,7 @@ df_lr_verify_transfer_functions (void)\n \t  /* Make a copy of the transfer functions and then compute\n \t     new ones to see if the transfer functions have\n \t     changed.  */\n-\t  if (!bitmap_bit_p (df_lr->out_of_date_transfer_functions, \n+\t  if (!bitmap_bit_p (df_lr->out_of_date_transfer_functions,\n \t\t\t     bb->index))\n \t    {\n \t      bitmap_copy (saved_def, bb_info->def);\n@@ -1312,7 +1312,7 @@ df_lr_verify_transfer_functions (void)\n \t  /* If we do not have basic block info, the block must be in\n \t     the list of dirty blocks or else some one has added a\n \t     block behind our backs. */\n-\t  gcc_assert (bitmap_bit_p (df_lr->out_of_date_transfer_functions, \n+\t  gcc_assert (bitmap_bit_p (df_lr->out_of_date_transfer_functions,\n \t\t\t\t    bb->index));\n \t}\n       /* Make sure no one created a block without following\n@@ -1321,8 +1321,8 @@ df_lr_verify_transfer_functions (void)\n     }\n \n   /* Make sure there are no dirty bits in blocks that have been deleted.  */\n-  gcc_assert (!bitmap_intersect_compl_p (df_lr->out_of_date_transfer_functions, \n-\t\t\t\t\t all_blocks)); \n+  gcc_assert (!bitmap_intersect_compl_p (df_lr->out_of_date_transfer_functions,\n+\t\t\t\t\t all_blocks));\n \n   BITMAP_FREE (saved_def);\n   BITMAP_FREE (saved_use);\n@@ -1349,7 +1349,7 @@ df_lr_verify_transfer_functions (void)\n \n    Then, the in and out sets for the LIVE problem itself are computed.\n    These are the logical AND of the IN and OUT sets from the LR problem\n-   and the must-initialized problem. \n+   and the must-initialized problem.\n ----------------------------------------------------------------------------*/\n \n /* Private data used to verify the solution for this problem.  */\n@@ -1367,7 +1367,7 @@ static bitmap df_live_scratch;\n /* Set basic block info.  */\n \n static void\n-df_live_set_bb_info (unsigned int index, \n+df_live_set_bb_info (unsigned int index,\n \t\t   struct df_live_bb_info *bb_info)\n {\n   gcc_assert (df_live);\n@@ -1379,7 +1379,7 @@ df_live_set_bb_info (unsigned int index,\n /* Free basic block info.  */\n \n static void\n-df_live_free_bb_info (basic_block bb ATTRIBUTE_UNUSED, \n+df_live_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n \t\t    void *vbb_info)\n {\n   struct df_live_bb_info *bb_info = (struct df_live_bb_info *) vbb_info;\n@@ -1397,14 +1397,14 @@ df_live_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n /* Allocate or reset bitmaps for DF_LIVE blocks. The solution bits are\n    not touched unless the block is new.  */\n \n-static void \n+static void\n df_live_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n {\n   unsigned int bb_index;\n   bitmap_iterator bi;\n \n   if (!df_live->block_pool)\n-    df_live->block_pool = create_alloc_pool (\"df_live_block pool\", \n+    df_live->block_pool = create_alloc_pool (\"df_live_block pool\",\n \t\t\t\t\t   sizeof (struct df_live_bb_info), 100);\n   if (!df_live_scratch)\n     df_live_scratch = BITMAP_ALLOC (NULL);\n@@ -1415,12 +1415,12 @@ df_live_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n     {\n       struct df_live_bb_info *bb_info = df_live_get_bb_info (bb_index);\n       if (bb_info)\n-\t{ \n+\t{\n \t  bitmap_clear (bb_info->kill);\n \t  bitmap_clear (bb_info->gen);\n \t}\n       else\n-\t{ \n+\t{\n \t  bb_info = (struct df_live_bb_info *) pool_alloc (df_live->block_pool);\n \t  df_live_set_bb_info (bb_index, bb_info);\n \t  bb_info->kill = BITMAP_ALLOC (NULL);\n@@ -1435,7 +1435,7 @@ df_live_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n \n /* Reset the global solution for recalculation.  */\n \n-static void \n+static void\n df_live_reset (bitmap all_blocks)\n {\n   unsigned int bb_index;\n@@ -1517,7 +1517,7 @@ df_live_local_compute (bitmap all_blocks ATTRIBUTE_UNUSED)\n \n   df_grow_insn_info ();\n \n-  EXECUTE_IF_SET_IN_BITMAP (df_live->out_of_date_transfer_functions, \n+  EXECUTE_IF_SET_IN_BITMAP (df_live->out_of_date_transfer_functions,\n \t\t\t    0, bb_index, bi)\n     {\n       df_live_bb_local_compute (bb_index);\n@@ -1529,7 +1529,7 @@ df_live_local_compute (bitmap all_blocks ATTRIBUTE_UNUSED)\n \n /* Initialize the solution vectors.  */\n \n-static void \n+static void\n df_live_init (bitmap all_blocks)\n {\n   unsigned int bb_index;\n@@ -1554,12 +1554,12 @@ df_live_confluence_n (edge e)\n {\n   bitmap op1 = df_live_get_bb_info (e->dest->index)->in;\n   bitmap op2 = df_live_get_bb_info (e->src->index)->out;\n- \n-  if (e->flags & EDGE_FAKE) \n+\n+  if (e->flags & EDGE_FAKE)\n     return;\n \n   bitmap_ior_into (op1, op2);\n-} \n+}\n \n \n /* Transfer function for the forwards must-initialized problem.  */\n@@ -1602,13 +1602,13 @@ df_live_finalize (bitmap all_blocks)\n \t{\n \t  struct df_lr_bb_info *bb_lr_info = df_lr_get_bb_info (bb_index);\n \t  struct df_live_bb_info *bb_live_info = df_live_get_bb_info (bb_index);\n-  \n+\n \t  /* No register may reach a location where it is not used.  Thus\n \t     we trim the rr result to the places where it is used.  */\n \t  bitmap_and_into (bb_live_info->in, bb_lr_info->in);\n \t  bitmap_and_into (bb_live_info->out, bb_lr_info->out);\n \t}\n-      \n+\n       df_live->solutions_dirty = false;\n     }\n }\n@@ -1622,7 +1622,7 @@ df_live_free (void)\n   if (df_live->block_info)\n     {\n       unsigned int i;\n-      \n+\n       for (i = 0; i < df_live->block_info_size; i++)\n \t{\n \t  struct df_live_bb_info *bb_info = df_live_get_bb_info (i);\n@@ -1634,7 +1634,7 @@ df_live_free (void)\n \t      BITMAP_FREE (bb_info->out);\n \t    }\n \t}\n-      \n+\n       free_alloc_pool (df_live->block_pool);\n       df_live->block_info_size = 0;\n       free (df_live->block_info);\n@@ -1657,7 +1657,7 @@ df_live_top_dump (basic_block bb, FILE *file)\n \n   if (!bb_info || !bb_info->in)\n     return;\n-      \n+\n   fprintf (file, \";; live  in  \\t\");\n   df_print_regset (file, bb_info->in);\n   if (df_live->problem_data)\n@@ -1683,7 +1683,7 @@ df_live_bottom_dump (basic_block bb, FILE *file)\n \n   if (!bb_info || !bb_info->out)\n     return;\n-      \n+\n   fprintf (file, \";; live  out \\t\");\n   df_print_regset (file, bb_info->out);\n   if (df_live->problem_data)\n@@ -1709,7 +1709,7 @@ df_live_verify_solution_start (void)\n       return;\n     }\n \n-  /* Set it true so that the solution is recomputed.  */ \n+  /* Set it true so that the solution is recomputed.  */\n   df_live->solutions_dirty = true;\n \n   problem_data = XNEW (struct df_live_problem_data);\n@@ -1778,8 +1778,8 @@ static struct df_problem problem_LIVE =\n   df_live_local_compute,        /* Local compute function.  */\n   df_live_init,                 /* Init the solution specific data.  */\n   df_worklist_dataflow,         /* Worklist solver.  */\n-  NULL,                         /* Confluence operator 0.  */ \n-  df_live_confluence_n,         /* Confluence operator n.  */ \n+  NULL,                         /* Confluence operator 0.  */\n+  df_live_confluence_n,         /* Confluence operator n.  */\n   df_live_transfer_function,    /* Transfer function.  */\n   df_live_finalize,             /* Finalize function.  */\n   df_live_free,                 /* Free all of the problem information.  */\n@@ -1817,7 +1817,7 @@ df_live_set_all_dirty (void)\n {\n   basic_block bb;\n   FOR_ALL_BB (bb)\n-    bitmap_set_bit (df_live->out_of_date_transfer_functions, \n+    bitmap_set_bit (df_live->out_of_date_transfer_functions,\n \t\t    bb->index);\n }\n \n@@ -1852,7 +1852,7 @@ df_live_verify_transfer_functions (void)\n \t  /* Make a copy of the transfer functions and then compute\n \t     new ones to see if the transfer functions have\n \t     changed.  */\n-\t  if (!bitmap_bit_p (df_live->out_of_date_transfer_functions, \n+\t  if (!bitmap_bit_p (df_live->out_of_date_transfer_functions,\n \t\t\t     bb->index))\n \t    {\n \t      bitmap_copy (saved_gen, bb_info->gen);\n@@ -1870,7 +1870,7 @@ df_live_verify_transfer_functions (void)\n \t  /* If we do not have basic block info, the block must be in\n \t     the list of dirty blocks or else some one has added a\n \t     block behind our backs. */\n-\t  gcc_assert (bitmap_bit_p (df_live->out_of_date_transfer_functions, \n+\t  gcc_assert (bitmap_bit_p (df_live->out_of_date_transfer_functions,\n \t\t\t\t    bb->index));\n \t}\n       /* Make sure no one created a block without following\n@@ -1879,8 +1879,8 @@ df_live_verify_transfer_functions (void)\n     }\n \n   /* Make sure there are no dirty bits in blocks that have been deleted.  */\n-  gcc_assert (!bitmap_intersect_compl_p (df_live->out_of_date_transfer_functions, \n-\t\t\t\t\t all_blocks)); \n+  gcc_assert (!bitmap_intersect_compl_p (df_live->out_of_date_transfer_functions,\n+\t\t\t\t\t all_blocks));\n   BITMAP_FREE (saved_gen);\n   BITMAP_FREE (saved_kill);\n   BITMAP_FREE (all_blocks);\n@@ -1906,7 +1906,7 @@ df_chain_create (df_ref src, df_ref dst)\n {\n   struct df_link *head = DF_REF_CHAIN (src);\n   struct df_link *link = (struct df_link *) pool_alloc (df_chain->block_pool);\n-  \n+\n   DF_REF_CHAIN (src) = link;\n   link->next = head;\n   link->ref = dst;\n@@ -1915,7 +1915,7 @@ df_chain_create (df_ref src, df_ref dst)\n \n \n /* Delete any du or ud chains that start at REF and point to\n-   TARGET.  */ \n+   TARGET.  */\n static void\n df_chain_unlink_1 (df_ref ref, df_ref target)\n {\n@@ -1958,10 +1958,10 @@ df_chain_unlink (df_ref ref)\n \n \n /* Copy the du or ud chain starting at FROM_REF and attach it to\n-   TO_REF.  */ \n+   TO_REF.  */\n \n-void \n-df_chain_copy (df_ref to_ref, \n+void\n+df_chain_copy (df_ref to_ref,\n \t       struct df_link *from_ref)\n {\n   while (from_ref)\n@@ -1980,7 +1980,7 @@ df_chain_remove_problem (void)\n   bitmap_iterator bi;\n   unsigned int bb_index;\n \n-  /* Wholesale destruction of the old chains.  */ \n+  /* Wholesale destruction of the old chains.  */\n   if (df_chain->block_pool)\n     free_alloc_pool (df_chain->block_pool);\n \n@@ -1997,11 +1997,11 @@ df_chain_remove_problem (void)\n       if (df_chain_problem_p (DF_UD_CHAIN))\n \tfor (use_rec = df_get_artificial_uses (bb->index); *use_rec; use_rec++)\n \t  DF_REF_CHAIN (*use_rec) = NULL;\n-      \n+\n       FOR_BB_INSNS (bb, insn)\n \t{\n \t  unsigned int uid = INSN_UID (insn);\n-\t  \n+\n \t  if (INSN_P (insn))\n \t    {\n \t      if (df_chain_problem_p (DF_DU_CHAIN))\n@@ -2036,11 +2036,11 @@ df_chain_fully_remove_problem (void)\n \n /* Create def-use or use-def chains.  */\n \n-static void  \n+static void\n df_chain_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n {\n   df_chain_remove_problem ();\n-  df_chain->block_pool = create_alloc_pool (\"df_chain_block pool\", \n+  df_chain->block_pool = create_alloc_pool (\"df_chain_block pool\",\n \t\t\t\t\t sizeof (struct df_link), 50);\n   df_chain->optional_p = true;\n }\n@@ -2064,7 +2064,7 @@ df_chain_create_bb_process_use (bitmap local_rd,\n {\n   bitmap_iterator bi;\n   unsigned int def_index;\n-  \n+\n   while (*use_rec)\n     {\n       df_ref use = *use_rec;\n@@ -2080,13 +2080,13 @@ df_chain_create_bb_process_use (bitmap local_rd,\n \t\t{\n \t\t  unsigned int first_index = DF_DEFS_BEGIN (uregno);\n \t\t  unsigned int last_index = first_index + count - 1;\n-\t\t  \n+\n \t\t  EXECUTE_IF_SET_IN_BITMAP (local_rd, first_index, def_index, bi)\n \t\t    {\n \t\t      df_ref def;\n-\t\t      if (def_index > last_index) \n+\t\t      if (def_index > last_index)\n \t\t\tbreak;\n-\t\t      \n+\n \t\t      def = DF_DEFS_GET (def_index);\n \t\t      if (df_chain_problem_p (DF_DU_CHAIN))\n \t\t\tdf_chain_create (def, use);\n@@ -2121,16 +2121,16 @@ df_chain_create_bb (unsigned int bb_index)\n #ifdef EH_USES\n   /* Create the chains for the artificial uses from the EH_USES at the\n      beginning of the block.  */\n-  \n+\n   /* Artificials are only hard regs.  */\n   if (!(df->changeable_flags & DF_NO_HARD_REGS))\n     df_chain_create_bb_process_use (cpy,\n-\t\t\t\t    df_get_artificial_uses (bb->index), \n+\t\t\t\t    df_get_artificial_uses (bb->index),\n \t\t\t\t    DF_REF_AT_TOP);\n #endif\n \n   df_rd_simulate_artificial_defs_at_top (bb, cpy);\n-  \n+\n   /* Process the regular instructions next.  */\n   FOR_BB_INSNS (bb, insn)\n     if (INSN_P (insn))\n@@ -2151,7 +2151,7 @@ df_chain_create_bb (unsigned int bb_index)\n      at the end of the block.  */\n   if (!(df->changeable_flags & DF_NO_HARD_REGS))\n     df_chain_create_bb_process_use (cpy,\n-\t\t\t\t    df_get_artificial_uses (bb->index), \n+\t\t\t\t    df_get_artificial_uses (bb->index),\n \t\t\t\t    0);\n \n   BITMAP_FREE (cpy);\n@@ -2165,7 +2165,7 @@ df_chain_finalize (bitmap all_blocks)\n {\n   unsigned int bb_index;\n   bitmap_iterator bi;\n-  \n+\n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n     {\n       df_chain_create_bb (bb_index);\n@@ -2195,7 +2195,7 @@ df_chain_top_dump (basic_block bb, FILE *file)\n       df_ref *def_rec = df_get_artificial_defs (bb->index);\n       if (*def_rec)\n \t{\n-\t  \n+\n \t  fprintf (file, \";;  DU chains for artificial defs\\n\");\n \t  while (*def_rec)\n \t    {\n@@ -2205,7 +2205,7 @@ df_chain_top_dump (basic_block bb, FILE *file)\n \t      fprintf (file, \"\\n\");\n \t      def_rec++;\n \t    }\n-\t}      \n+\t}\n \n       FOR_BB_INSNS (bb, insn)\n \t{\n@@ -2215,9 +2215,9 @@ df_chain_top_dump (basic_block bb, FILE *file)\n \t      def_rec = DF_INSN_INFO_DEFS (insn_info);\n \t      if (*def_rec)\n \t\t{\n-\t\t  fprintf (file, \";;   DU chains for insn luid %d uid %d\\n\", \n+\t\t  fprintf (file, \";;   DU chains for insn luid %d uid %d\\n\",\n \t\t\t   DF_INSN_INFO_LUID (insn_info), INSN_UID (insn));\n-\t\t  \n+\n \t\t  while (*def_rec)\n \t\t    {\n \t\t      df_ref def = *def_rec;\n@@ -2254,7 +2254,7 @@ df_chain_bottom_dump (basic_block bb, FILE *file)\n \t      fprintf (file, \"\\n\");\n \t      use_rec++;\n \t    }\n-\t}      \n+\t}\n \n       FOR_BB_INSNS (bb, insn)\n \t{\n@@ -2265,9 +2265,9 @@ df_chain_bottom_dump (basic_block bb, FILE *file)\n \t      use_rec = DF_INSN_INFO_USES (insn_info);\n \t      if (*use_rec || *eq_use_rec)\n \t\t{\n-\t\t  fprintf (file, \";;   UD chains for insn luid %d uid %d\\n\", \n+\t\t  fprintf (file, \";;   UD chains for insn luid %d uid %d\\n\",\n \t\t\t   DF_INSN_INFO_LUID (insn_info), INSN_UID (insn));\n-\t\t  \n+\n \t\t  while (*use_rec)\n \t\t    {\n \t\t      df_ref use = *use_rec;\n@@ -2303,8 +2303,8 @@ static struct df_problem problem_CHAIN =\n   NULL,                       /* Local compute function.  */\n   NULL,                       /* Init the solution specific data.  */\n   NULL,                       /* Iterative solver.  */\n-  NULL,                       /* Confluence operator 0.  */ \n-  NULL,                       /* Confluence operator n.  */ \n+  NULL,                       /* Confluence operator 0.  */\n+  NULL,                       /* Confluence operator n.  */\n   NULL,                       /* Transfer function.  */\n   df_chain_finalize,          /* Finalize function.  */\n   df_chain_free,              /* Free all of the problem information.  */\n@@ -2377,8 +2377,8 @@ struct df_byte_lr_problem_data\n   bitmap needs_expansion;\n \n   /* The start position and len for each regno in the various bit\n-     vectors.  */ \n-  unsigned int* regno_start;  \n+     vectors.  */\n+  unsigned int* regno_start;\n   unsigned int* regno_len;\n   /* An obstack for the bitmaps we need for this problem.  */\n   bitmap_obstack byte_lr_bitmaps;\n@@ -2387,21 +2387,21 @@ struct df_byte_lr_problem_data\n \n /* Get the starting location for REGNO in the df_byte_lr bitmaps.  */\n \n-int \n+int\n df_byte_lr_get_regno_start (unsigned int regno)\n {\n-  struct df_byte_lr_problem_data *problem_data \n+  struct df_byte_lr_problem_data *problem_data\n     = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;;\n   return problem_data->regno_start[regno];\n }\n \n \n /* Get the len for REGNO in the df_byte_lr bitmaps.  */\n \n-int \n+int\n df_byte_lr_get_regno_len (unsigned int regno)\n-{  \n-  struct df_byte_lr_problem_data *problem_data \n+{\n+  struct df_byte_lr_problem_data *problem_data\n     = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;;\n   return problem_data->regno_len[regno];\n }\n@@ -2410,19 +2410,19 @@ df_byte_lr_get_regno_len (unsigned int regno)\n /* Set basic block info.  */\n \n static void\n-df_byte_lr_set_bb_info (unsigned int index, \n+df_byte_lr_set_bb_info (unsigned int index,\n \t\t\tstruct df_byte_lr_bb_info *bb_info)\n {\n   gcc_assert (df_byte_lr);\n   gcc_assert (index < df_byte_lr->block_info_size);\n   df_byte_lr->block_info[index] = bb_info;\n }\n \n- \n+\n /* Free basic block info.  */\n \n static void\n-df_byte_lr_free_bb_info (basic_block bb ATTRIBUTE_UNUSED, \n+df_byte_lr_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n \t\t\t void *vbb_info)\n {\n   struct df_byte_lr_bb_info *bb_info = (struct df_byte_lr_bb_info *) vbb_info;\n@@ -2443,36 +2443,36 @@ df_byte_lr_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n static void\n df_byte_lr_check_regs (df_ref *ref_rec)\n {\n-  struct df_byte_lr_problem_data *problem_data \n+  struct df_byte_lr_problem_data *problem_data\n     = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n \n   for (; *ref_rec; ref_rec++)\n     {\n       df_ref ref = *ref_rec;\n-      if (DF_REF_FLAGS_IS_SET (ref, DF_REF_SIGN_EXTRACT \n-\t\t\t       | DF_REF_ZERO_EXTRACT \n+      if (DF_REF_FLAGS_IS_SET (ref, DF_REF_SIGN_EXTRACT\n+\t\t\t       | DF_REF_ZERO_EXTRACT\n \t\t\t       | DF_REF_STRICT_LOW_PART)\n \t  || GET_CODE (DF_REF_REG (ref)) == SUBREG)\n \tbitmap_set_bit (problem_data->needs_expansion, DF_REF_REGNO (ref));\n     }\n }\n \n \n-/* Expand bitmap SRC which is indexed by regno to DEST which is indexed by \n+/* Expand bitmap SRC which is indexed by regno to DEST which is indexed by\n    regno_start and regno_len.  */\n \n static void\n df_byte_lr_expand_bitmap (bitmap dest, bitmap src)\n {\n-  struct df_byte_lr_problem_data *problem_data \n+  struct df_byte_lr_problem_data *problem_data\n     = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n   bitmap_iterator bi;\n   unsigned int i;\n \n   bitmap_clear (dest);\n   EXECUTE_IF_SET_IN_BITMAP (src, 0, i, bi)\n     {\n-      bitmap_set_range (dest, problem_data->regno_start[i], \n+      bitmap_set_range (dest, problem_data->regno_start[i],\n \t\t\tproblem_data->regno_len[i]);\n     }\n }\n@@ -2481,7 +2481,7 @@ df_byte_lr_expand_bitmap (bitmap dest, bitmap src)\n /* Allocate or reset bitmaps for DF_BYTE_LR blocks. The solution bits are\n    not touched unless the block is new.  */\n \n-static void \n+static void\n df_byte_lr_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n {\n   unsigned int bb_index;\n@@ -2496,7 +2496,7 @@ df_byte_lr_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n   df_byte_lr->problem_data = problem_data;\n \n   if (!df_byte_lr->block_pool)\n-    df_byte_lr->block_pool = create_alloc_pool (\"df_byte_lr_block pool\", \n+    df_byte_lr->block_pool = create_alloc_pool (\"df_byte_lr_block pool\",\n \t\t\t\t\t   sizeof (struct df_byte_lr_bb_info), 50);\n \n   df_grow_bb_info (df_byte_lr);\n@@ -2513,7 +2513,7 @@ df_byte_lr_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n   problem_data->hardware_regs_used = BITMAP_ALLOC (&problem_data->byte_lr_bitmaps);\n   problem_data->invalidated_by_call = BITMAP_ALLOC (&problem_data->byte_lr_bitmaps);\n   problem_data->needs_expansion = BITMAP_ALLOC (&problem_data->byte_lr_bitmaps);\n-  \n+\n   /* Discover which regno's use subregs, extracts or\n      strict_low_parts.  */\n   FOR_EACH_BB (bb)\n@@ -2533,36 +2533,36 @@ df_byte_lr_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n \n   bitmap_set_bit (df_byte_lr->out_of_date_transfer_functions, ENTRY_BLOCK);\n   bitmap_set_bit (df_byte_lr->out_of_date_transfer_functions, EXIT_BLOCK);\n-  \n+\n   /* Allocate the slots for each regno.  */\n   for (regno = 0; regno < max_reg; regno++)\n     {\n       int len;\n       problem_data->regno_start[regno] = index;\n       if (bitmap_bit_p (problem_data->needs_expansion, regno))\n \tlen = GET_MODE_SIZE (GET_MODE (regno_reg_rtx[regno]));\n-      else \n+      else\n \tlen = 1;\n-      \n+\n       problem_data->regno_len[regno] = len;\n       index += len;\n     }\n \n-  df_byte_lr_expand_bitmap (problem_data->hardware_regs_used, \n+  df_byte_lr_expand_bitmap (problem_data->hardware_regs_used,\n \t\t\t    df->hardware_regs_used);\n-  df_byte_lr_expand_bitmap (problem_data->invalidated_by_call, \n+  df_byte_lr_expand_bitmap (problem_data->invalidated_by_call,\n \t\t\t    regs_invalidated_by_call_regset);\n \n   EXECUTE_IF_SET_IN_BITMAP (df_byte_lr->out_of_date_transfer_functions, 0, bb_index, bi)\n     {\n       struct df_byte_lr_bb_info *bb_info = df_byte_lr_get_bb_info (bb_index);\n       if (bb_info)\n-\t{ \n+\t{\n \t  bitmap_clear (bb_info->def);\n \t  bitmap_clear (bb_info->use);\n \t}\n       else\n-\t{ \n+\t{\n \t  bb_info = (struct df_byte_lr_bb_info *) pool_alloc (df_byte_lr->block_pool);\n \t  df_byte_lr_set_bb_info (bb_index, bb_info);\n \t  bb_info->use = BITMAP_ALLOC (&problem_data->byte_lr_bitmaps);\n@@ -2571,14 +2571,14 @@ df_byte_lr_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n \t  bb_info->out = BITMAP_ALLOC (&problem_data->byte_lr_bitmaps);\n \t}\n     }\n-  \n+\n   df_byte_lr->optional_p = true;\n }\n \n \n /* Reset the global solution for recalculation.  */\n \n-static void \n+static void\n df_byte_lr_reset (bitmap all_blocks)\n {\n   unsigned int bb_index;\n@@ -2599,7 +2599,7 @@ df_byte_lr_reset (bitmap all_blocks)\n static void\n df_byte_lr_bb_local_compute (unsigned int bb_index)\n {\n-  struct df_byte_lr_problem_data *problem_data \n+  struct df_byte_lr_problem_data *problem_data\n     = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n   basic_block bb = BASIC_BLOCK (bb_index);\n   struct df_byte_lr_bb_info *bb_info = df_byte_lr_get_bb_info (bb_index);\n@@ -2640,7 +2640,7 @@ df_byte_lr_bb_local_compute (unsigned int bb_index)\n       unsigned int uid = INSN_UID (insn);\n \n       if (!INSN_P (insn))\n-\tcontinue;\t\n+\tcontinue;\n \n       for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n \t{\n@@ -2701,7 +2701,7 @@ df_byte_lr_bb_local_compute (unsigned int bb_index)\n \t  bitmap_clear_range (bb_info->use, start, len);\n \t}\n     }\n-  \n+\n #ifdef EH_USES\n   /* Process the uses that are live into an exception handler.  */\n   for (use_rec = df_get_artificial_uses (bb_index); *use_rec; use_rec++)\n@@ -2747,7 +2747,7 @@ df_byte_lr_local_compute (bitmap all_blocks ATTRIBUTE_UNUSED)\n \n /* Initialize the solution vectors.  */\n \n-static void \n+static void\n df_byte_lr_init (bitmap all_blocks)\n {\n   unsigned int bb_index;\n@@ -2768,24 +2768,24 @@ df_byte_lr_init (bitmap all_blocks)\n static void\n df_byte_lr_confluence_0 (basic_block bb)\n {\n-  struct df_byte_lr_problem_data *problem_data \n+  struct df_byte_lr_problem_data *problem_data\n     = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n   bitmap op1 = df_byte_lr_get_bb_info (bb->index)->out;\n   if (bb != EXIT_BLOCK_PTR)\n     bitmap_copy (op1, problem_data->hardware_regs_used);\n-} \n+}\n \n \n /* Confluence function that ignores fake edges.  */\n \n static void\n df_byte_lr_confluence_n (edge e)\n {\n-  struct df_byte_lr_problem_data *problem_data \n+  struct df_byte_lr_problem_data *problem_data\n     = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n   bitmap op1 = df_byte_lr_get_bb_info (e->src->index)->out;\n   bitmap op2 = df_byte_lr_get_bb_info (e->dest->index)->in;\n- \n+\n   /* Call-clobbered registers die across exception and call edges.  */\n   /* ??? Abnormal call edges ignored for the moment, as this gets\n      confused by sibling call edges, which crashes reg-stack.  */\n@@ -2795,7 +2795,7 @@ df_byte_lr_confluence_n (edge e)\n     bitmap_ior_into (op1, op2);\n \n   bitmap_ior_into (op1, problem_data->hardware_regs_used);\n-} \n+}\n \n \n /* Transfer function.  */\n@@ -2846,14 +2846,14 @@ df_byte_lr_top_dump (basic_block bb, FILE *file)\n   struct df_byte_lr_bb_info *bb_info = df_byte_lr_get_bb_info (bb->index);\n   if (!bb_info || !bb_info->in)\n     return;\n-      \n+\n   fprintf (file, \";; blr  in  \\t\");\n   df_print_byte_regset (file, bb_info->in);\n   fprintf (file, \";; blr  use \\t\");\n   df_print_byte_regset (file, bb_info->use);\n   fprintf (file, \";; blr  def \\t\");\n   df_print_byte_regset (file, bb_info->def);\n-}  \n+}\n \n \n /* Debugging info at bottom of bb.  */\n@@ -2864,10 +2864,10 @@ df_byte_lr_bottom_dump (basic_block bb, FILE *file)\n   struct df_byte_lr_bb_info *bb_info = df_byte_lr_get_bb_info (bb->index);\n   if (!bb_info || !bb_info->out)\n     return;\n-  \n+\n   fprintf (file, \";; blr  out \\t\");\n   df_print_byte_regset (file, bb_info->out);\n-}  \n+}\n \n \n /* All of the information associated with every instance of the problem.  */\n@@ -2882,8 +2882,8 @@ static struct df_problem problem_BYTE_LR =\n   df_byte_lr_local_compute,        /* Local compute function.  */\n   df_byte_lr_init,                 /* Init the solution specific data.  */\n   df_worklist_dataflow,            /* Worklist solver.  */\n-  df_byte_lr_confluence_0,         /* Confluence operator 0.  */ \n-  df_byte_lr_confluence_n,         /* Confluence operator n.  */ \n+  df_byte_lr_confluence_0,         /* Confluence operator 0.  */\n+  df_byte_lr_confluence_n,         /* Confluence operator n.  */\n   df_byte_lr_transfer_function,    /* Transfer function.  */\n   NULL,                            /* Finalize function.  */\n   df_byte_lr_free,                 /* Free all of the problem information.  */\n@@ -2894,7 +2894,7 @@ static struct df_problem problem_BYTE_LR =\n   NULL,                            /* Incremental solution verify start.  */\n   NULL,                            /* Incremental solution verify end.  */\n   NULL,                            /* Dependent problem.  */\n-  TV_DF_BYTE_LR,                   /* Timing variable.  */ \n+  TV_DF_BYTE_LR,                   /* Timing variable.  */\n   false                            /* Reset blocks on dropping out of blocks_to_analyze.  */\n };\n \n@@ -2918,7 +2918,7 @@ df_byte_lr_add_problem (void)\n void\n df_byte_lr_simulate_defs (rtx insn, bitmap live)\n {\n-  struct df_byte_lr_problem_data *problem_data \n+  struct df_byte_lr_problem_data *problem_data\n     = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n   df_ref *def_rec;\n   unsigned int uid = INSN_UID (insn);\n@@ -2946,15 +2946,15 @@ df_byte_lr_simulate_defs (rtx insn, bitmap live)\n \t    bitmap_clear_range (live, start, len);\n \t}\n     }\n-}  \n+}\n \n \n /* Simulate the effects of the uses of INSN on LIVE.  */\n \n-void \n+void\n df_byte_lr_simulate_uses (rtx insn, bitmap live)\n {\n-  struct df_byte_lr_problem_data *problem_data \n+  struct df_byte_lr_problem_data *problem_data\n     = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n   df_ref *use_rec;\n   unsigned int uid = INSN_UID (insn);\n@@ -2967,13 +2967,13 @@ df_byte_lr_simulate_uses (rtx insn, bitmap live)\n       unsigned int len = problem_data->regno_len[uregno];\n       unsigned int sb;\n       unsigned int lb;\n-      \n+\n       if (!df_compute_accessed_bytes (use, DF_MM_MAY, &sb, &lb))\n \t{\n \t  start += sb;\n \t  len = lb - sb;\n \t}\n-      \n+\n       /* Add use to set of uses in this BB.  */\n       if (len)\n \tbitmap_set_range (live, start, len);\n@@ -2984,17 +2984,17 @@ df_byte_lr_simulate_uses (rtx insn, bitmap live)\n /* Apply the artificial uses and defs at the top of BB in a forwards\n    direction.  */\n \n-void \n+void\n df_byte_lr_simulate_artificial_refs_at_top (basic_block bb, bitmap live)\n {\n-  struct df_byte_lr_problem_data *problem_data \n+  struct df_byte_lr_problem_data *problem_data\n     = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n   df_ref *def_rec;\n #ifdef EH_USES\n   df_ref *use_rec;\n #endif\n   int bb_index = bb->index;\n-  \n+\n #ifdef EH_USES\n   for (use_rec = df_get_artificial_uses (bb_index); *use_rec; use_rec++)\n     {\n@@ -3013,7 +3013,7 @@ df_byte_lr_simulate_artificial_refs_at_top (basic_block bb, bitmap live)\n     {\n       df_ref def = *def_rec;\n       if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n-\t{      \n+\t{\n \t  unsigned int dregno = DF_REF_REGNO (def);\n \t  unsigned int start = problem_data->regno_start[dregno];\n \t  unsigned int len = problem_data->regno_len[dregno];\n@@ -3026,15 +3026,15 @@ df_byte_lr_simulate_artificial_refs_at_top (basic_block bb, bitmap live)\n /* Apply the artificial uses and defs at the end of BB in a backwards\n    direction.  */\n \n-void \n+void\n df_byte_lr_simulate_artificial_refs_at_end (basic_block bb, bitmap live)\n {\n-  struct df_byte_lr_problem_data *problem_data \n+  struct df_byte_lr_problem_data *problem_data\n     = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n   df_ref *def_rec;\n   df_ref *use_rec;\n   int bb_index = bb->index;\n-  \n+\n   for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n     {\n       df_ref def = *def_rec;\n@@ -3066,14 +3066,14 @@ df_byte_lr_simulate_artificial_refs_at_end (basic_block bb, bitmap live)\n    This problem computes REG_DEAD and REG_UNUSED notes.\n    ----------------------------------------------------------------------------*/\n \n-static void \n+static void\n df_note_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n {\n   df_note->optional_p = true;\n }\n \n #ifdef REG_DEAD_DEBUGGING\n-static void \n+static void\n df_print_note (const char *prefix, rtx insn, rtx note)\n {\n   if (dump_file)\n@@ -3091,14 +3091,14 @@ df_print_note (const char *prefix, rtx insn, rtx note)\n    just leave the notes alone. */\n \n #ifdef STACK_REGS\n-static inline bool \n+static inline bool\n df_ignore_stack_reg (int regno)\n {\n   return regstack_completed\n     && IN_RANGE (regno, FIRST_STACK_REG, LAST_STACK_REG);\n }\n #else\n-static inline bool \n+static inline bool\n df_ignore_stack_reg (int regno ATTRIBUTE_UNUSED)\n {\n   return false;\n@@ -3122,7 +3122,7 @@ df_kill_notes (rtx insn, rtx *old_dead_notes, rtx *old_unused_notes)\n       switch (REG_NOTE_KIND (link))\n \t{\n \tcase REG_DEAD:\n-\t  /* After reg-stack, we need to ignore any unused notes \n+\t  /* After reg-stack, we need to ignore any unused notes\n \t     for the stack registers.  */\n \t  if (df_ignore_stack_reg (REGNO (XEXP (link, 0))))\n \t    {\n@@ -3142,7 +3142,7 @@ df_kill_notes (rtx insn, rtx *old_dead_notes, rtx *old_unused_notes)\n \t  break;\n \n \tcase REG_UNUSED:\n-\t  /* After reg-stack, we need to ignore any unused notes \n+\t  /* After reg-stack, we need to ignore any unused notes\n \t     for the stack registers.  */\n \t  if (df_ignore_stack_reg (REGNO (XEXP (link, 0))))\n \t    {\n@@ -3160,7 +3160,7 @@ df_kill_notes (rtx insn, rtx *old_dead_notes, rtx *old_unused_notes)\n \t      *pprev = link = next;\n \t    }\n \t  break;\n-\t  \n+\n \tdefault:\n \t  pprev = &XEXP (link, 1);\n \t  link = *pprev;\n@@ -3200,7 +3200,7 @@ df_set_note (enum reg_note note_type, rtx insn, rtx old, rtx reg)\n \tprev = curr;\n \tcurr = XEXP (curr, 1);\n       }\n-  \n+\n   /* Did not find the note.  */\n   add_reg_note (insn, note_type, reg);\n   return old;\n@@ -3241,14 +3241,14 @@ df_whole_mw_reg_unused_p (struct df_mw_hardreg *mws,\n \n static rtx\n df_set_unused_notes_for_mw (rtx insn, rtx old, struct df_mw_hardreg *mws,\n-\t\t\t    bitmap live, bitmap do_not_gen, \n+\t\t\t    bitmap live, bitmap do_not_gen,\n \t\t\t    bitmap artificial_uses)\n {\n   unsigned int r;\n-  \n+\n #ifdef REG_DEAD_DEBUGGING\n   if (dump_file)\n-    fprintf (dump_file, \"mw_set_unused looking at mws[%d..%d]\\n\", \n+    fprintf (dump_file, \"mw_set_unused looking at mws[%d..%d]\\n\",\n \t     mws->start_regno, mws->end_regno);\n #endif\n \n@@ -3322,11 +3322,11 @@ df_set_dead_notes_for_mw (rtx insn, rtx old, struct df_mw_hardreg *mws,\n   bool is_debug = *added_notes_p;\n \n   *added_notes_p = false;\n-  \n+\n #ifdef REG_DEAD_DEBUGGING\n   if (dump_file)\n     {\n-      fprintf (dump_file, \"mw_set_dead looking at mws[%d..%d]\\n  do_not_gen =\", \n+      fprintf (dump_file, \"mw_set_dead looking at mws[%d..%d]\\n  do_not_gen =\",\n \t       mws->start_regno, mws->end_regno);\n       df_print_regset (dump_file, do_not_gen);\n       fprintf (dump_file, \"  live =\");\n@@ -3375,11 +3375,11 @@ df_set_dead_notes_for_mw (rtx insn, rtx old, struct df_mw_hardreg *mws,\n    LIVE.  Do not generate notes for registers in ARTIFICIAL_USES.  */\n \n static rtx\n-df_create_unused_note (rtx insn, rtx old, df_ref def, \n+df_create_unused_note (rtx insn, rtx old, df_ref def,\n \t\t       bitmap live, bitmap artificial_uses)\n {\n   unsigned int dregno = DF_REF_REGNO (def);\n-  \n+\n #ifdef REG_DEAD_DEBUGGING\n   if (dump_file)\n     {\n@@ -3393,14 +3393,14 @@ df_create_unused_note (rtx insn, rtx old, df_ref def,\n \t|| bitmap_bit_p (artificial_uses, dregno)\n \t|| df_ignore_stack_reg (dregno)))\n     {\n-      rtx reg = (DF_REF_LOC (def)) \n+      rtx reg = (DF_REF_LOC (def))\n                 ? *DF_REF_REAL_LOC (def): DF_REF_REG (def);\n       old = df_set_note (REG_UNUSED, insn, old, reg);\n #ifdef REG_DEAD_DEBUGGING\n       df_print_note (\"adding 3: \", insn, REG_NOTES (insn));\n #endif\n     }\n-  \n+\n   return old;\n }\n \n@@ -3410,7 +3410,7 @@ df_create_unused_note (rtx insn, rtx old, df_ref def,\n    BB.  The three bitvectors are scratch regs used here.  */\n \n static void\n-df_note_bb_compute (unsigned int bb_index, \n+df_note_bb_compute (unsigned int bb_index,\n \t\t    bitmap live, bitmap do_not_gen, bitmap artificial_uses)\n {\n   basic_block bb = BASIC_BLOCK (bb_index);\n@@ -3450,13 +3450,13 @@ df_note_bb_compute (unsigned int bb_index,\n \t{\n \t  unsigned int regno = DF_REF_REGNO (use);\n \t  bitmap_set_bit (live, regno);\n-\t  \n+\n \t  /* Notes are not generated for any of the artificial registers\n \t     at the bottom of the block.  */\n \t  bitmap_set_bit (artificial_uses, regno);\n \t}\n     }\n-  \n+\n #ifdef REG_DEAD_DEBUGGING\n   if (dump_file)\n     {\n@@ -3472,7 +3472,7 @@ df_note_bb_compute (unsigned int bb_index,\n       rtx old_dead_notes;\n       rtx old_unused_notes;\n       int debug_insn;\n- \n+\n       if (!INSN_P (insn))\n \tcontinue;\n \n@@ -3496,12 +3496,12 @@ df_note_bb_compute (unsigned int bb_index,\n \t  mws_rec = DF_INSN_UID_MWS (uid);\n \t  while (*mws_rec)\n \t    {\n-\t      struct df_mw_hardreg *mws = *mws_rec; \n-\t      if ((DF_MWS_REG_DEF_P (mws)) \n+\t      struct df_mw_hardreg *mws = *mws_rec;\n+\t      if ((DF_MWS_REG_DEF_P (mws))\n \t\t  && !df_ignore_stack_reg (mws->start_regno))\n-\t\told_unused_notes \n-\t\t  = df_set_unused_notes_for_mw (insn, old_unused_notes, \n-\t\t\t\t\t\tmws, live, do_not_gen, \n+\t\told_unused_notes\n+\t\t  = df_set_unused_notes_for_mw (insn, old_unused_notes,\n+\t\t\t\t\t\tmws, live, do_not_gen,\n \t\t\t\t\t\tartificial_uses);\n \t      mws_rec++;\n \t    }\n@@ -3515,7 +3515,7 @@ df_note_bb_compute (unsigned int bb_index,\n \t      if (!DF_REF_FLAGS_IS_SET (def, DF_REF_MUST_CLOBBER | DF_REF_MAY_CLOBBER))\n \t\t{\n \t\t  old_unused_notes\n-\t\t    = df_create_unused_note (insn, old_unused_notes, \n+\t\t    = df_create_unused_note (insn, old_unused_notes,\n \t\t\t\t\t     def, live, artificial_uses);\n \t\t  bitmap_set_bit (do_not_gen, dregno);\n \t\t}\n@@ -3530,11 +3530,11 @@ df_note_bb_compute (unsigned int bb_index,\n \t  mws_rec = DF_INSN_UID_MWS (uid);\n \t  while (*mws_rec)\n \t    {\n-\t      struct df_mw_hardreg *mws = *mws_rec; \n+\t      struct df_mw_hardreg *mws = *mws_rec;\n \t      if (DF_MWS_REG_DEF_P (mws))\n \t\told_unused_notes\n-\t\t  = df_set_unused_notes_for_mw (insn, old_unused_notes, \n-\t\t\t\t\t\tmws, live, do_not_gen, \n+\t\t  = df_set_unused_notes_for_mw (insn, old_unused_notes,\n+\t\t\t\t\t\tmws, live, do_not_gen,\n \t\t\t\t\t\tartificial_uses);\n \t      mws_rec++;\n \t    }\n@@ -3544,7 +3544,7 @@ df_note_bb_compute (unsigned int bb_index,\n \t      df_ref def = *def_rec;\n \t      unsigned int dregno = DF_REF_REGNO (def);\n \t      old_unused_notes\n-\t\t= df_create_unused_note (insn, old_unused_notes, \n+\t\t= df_create_unused_note (insn, old_unused_notes,\n \t\t\t\t\t def, live, artificial_uses);\n \n \t      if (!DF_REF_FLAGS_IS_SET (def, DF_REF_MUST_CLOBBER | DF_REF_MAY_CLOBBER))\n@@ -3554,13 +3554,13 @@ df_note_bb_compute (unsigned int bb_index,\n \t\tbitmap_clear_bit (live, dregno);\n \t    }\n \t}\n-      \n+\n       /* Process the uses.  */\n       mws_rec = DF_INSN_UID_MWS (uid);\n       while (*mws_rec)\n \t{\n-\t  struct df_mw_hardreg *mws = *mws_rec; \n-\t  if ((DF_MWS_REG_DEF_P (mws))  \n+\t  struct df_mw_hardreg *mws = *mws_rec;\n+\t  if ((DF_MWS_REG_DEF_P (mws))\n \t      && !df_ignore_stack_reg (mws->start_regno))\n \t    {\n \t      bool really_add_notes = debug_insn != 0;\n@@ -3603,7 +3603,7 @@ df_note_bb_compute (unsigned int bb_index,\n \t\t   && (!(DF_REF_FLAGS (use) & DF_REF_READ_WRITE))\n \t\t   && (!df_ignore_stack_reg (uregno)))\n \t\t{\n-\t\t  rtx reg = (DF_REF_LOC (use)) \n+\t\t  rtx reg = (DF_REF_LOC (use))\n                             ? *DF_REF_REAL_LOC (use) : DF_REF_REG (use);\n \t\t  old_dead_notes = df_set_note (REG_DEAD, insn, old_dead_notes, reg);\n \n@@ -3687,8 +3687,8 @@ static struct df_problem problem_NOTE =\n   df_note_compute,            /* Local compute function.  */\n   NULL,                       /* Init the solution specific data.  */\n   NULL,                       /* Iterative solver.  */\n-  NULL,                       /* Confluence operator 0.  */ \n-  NULL,                       /* Confluence operator n.  */ \n+  NULL,                       /* Confluence operator 0.  */\n+  NULL,                       /* Confluence operator n.  */\n   NULL,                       /* Transfer function.  */\n   NULL,                       /* Finalize function.  */\n   df_note_free,               /* Free all of the problem information.  */\n@@ -3718,7 +3718,7 @@ df_note_add_problem (void)\n \n \f\n /*----------------------------------------------------------------------------\n-   Functions for simulating the effects of single insns.  \n+   Functions for simulating the effects of single insns.\n \n    You can either simulate in the forwards direction, starting from\n    the top of a block or the backwards direction from the end of the\n@@ -3772,12 +3772,12 @@ df_simulate_defs (rtx insn, bitmap live)\n       if (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n \tbitmap_clear_bit (live, dregno);\n     }\n-}  \n+}\n \n \n /* Simulate the effects of the uses of INSN on LIVE.  */\n \n-void \n+void\n df_simulate_uses (rtx insn, bitmap live)\n {\n   df_ref *use_rec;\n@@ -3824,13 +3824,13 @@ df_simulate_fixup_sets (basic_block bb, bitmap live)\n /* Apply the artificial uses and defs at the end of BB in a backwards\n    direction.  */\n \n-void \n+void\n df_simulate_initialize_backwards (basic_block bb, bitmap live)\n {\n   df_ref *def_rec;\n   df_ref *use_rec;\n   int bb_index = bb->index;\n-  \n+\n   for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n     {\n       df_ref def = *def_rec;\n@@ -3849,12 +3849,12 @@ df_simulate_initialize_backwards (basic_block bb, bitmap live)\n \n /* Simulate the backwards effects of INSN on the bitmap LIVE.  */\n \n-void \n+void\n df_simulate_one_insn_backwards (basic_block bb, rtx insn, bitmap live)\n {\n   if (!NONDEBUG_INSN_P (insn))\n-    return;\t\n-  \n+    return;\n+\n   df_simulate_defs (insn, live);\n   df_simulate_uses (insn, live);\n   df_simulate_fixup_sets (bb, live);\n@@ -3864,15 +3864,15 @@ df_simulate_one_insn_backwards (basic_block bb, rtx insn, bitmap live)\n /* Apply the artificial uses and defs at the top of BB in a backwards\n    direction.  */\n \n-void \n+void\n df_simulate_finalize_backwards (basic_block bb, bitmap live)\n {\n   df_ref *def_rec;\n #ifdef EH_USES\n   df_ref *use_rec;\n #endif\n   int bb_index = bb->index;\n-  \n+\n   for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n     {\n       df_ref def = *def_rec;\n@@ -3892,7 +3892,7 @@ df_simulate_finalize_backwards (basic_block bb, bitmap live)\n /*----------------------------------------------------------------------------\n    The following three functions are used only for FORWARDS scanning:\n    i.e. they process the defs and the REG_DEAD and REG_UNUSED notes.\n-   Thus it is important to add the DF_NOTES problem to the stack of \n+   Thus it is important to add the DF_NOTES problem to the stack of\n    problems computed before using these functions.\n \n    df_simulate_initialize_forwards should be called first with a\n@@ -3909,12 +3909,12 @@ df_simulate_finalize_backwards (basic_block bb, bitmap live)\n    unless (as is the case for fwprop) they are correct when liveness\n    bitmaps are *under*estimated.  */\n \n-void \n+void\n df_simulate_initialize_forwards (basic_block bb, bitmap live)\n {\n   df_ref *def_rec;\n   int bb_index = bb->index;\n-  \n+\n   for (def_rec = df_get_artificial_defs (bb_index); *def_rec; def_rec++)\n     {\n       df_ref def = *def_rec;\n@@ -3925,14 +3925,14 @@ df_simulate_initialize_forwards (basic_block bb, bitmap live)\n \n /* Simulate the forwards effects of INSN on the bitmap LIVE.  */\n \n-void \n+void\n df_simulate_one_insn_forwards (basic_block bb, rtx insn, bitmap live)\n {\n   rtx link;\n   if (! INSN_P (insn))\n-    return;\t\n+    return;\n \n-  /* Make sure that DF_NOTE really is an active df problem.  */ \n+  /* Make sure that DF_NOTE really is an active df problem.  */\n   gcc_assert (df_note);\n \n   /* Note that this is the opposite as how the problem is defined, because\n@@ -3958,7 +3958,7 @@ df_simulate_one_insn_forwards (basic_block bb, rtx insn, bitmap live)\n \t\twhile (--n >= 0)\n \t\t  bitmap_clear_bit (live, regno + n);\n \t      }\n-\t    else \n+\t    else\n \t      bitmap_clear_bit (live, regno);\n \t  }\n \t  break;\n@@ -4015,13 +4015,13 @@ df_simulate_one_insn_forwards (basic_block bb, rtx insn, bitmap live)\n     init-set of BB3 includes r10 and r12, but not r11.  Note that we do\n     not need to iterate the dominance frontier, because we do not insert\n     anything like PHI functions there!  Instead, dataflow will take care of\n-    propagating the information to BB3's successors. \n+    propagating the information to BB3's successors.\n    ---------------------------------------------------------------------------*/\n \n /* Set basic block info.  */\n \n static void\n-df_md_set_bb_info (unsigned int index, \n+df_md_set_bb_info (unsigned int index,\n                    struct df_md_bb_info *bb_info)\n {\n   gcc_assert (df_md);\n@@ -4031,7 +4031,7 @@ df_md_set_bb_info (unsigned int index,\n \n \n static void\n-df_md_free_bb_info (basic_block bb ATTRIBUTE_UNUSED, \n+df_md_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n                     void *vbb_info)\n {\n   struct df_md_bb_info *bb_info = (struct df_md_bb_info *) vbb_info;\n@@ -4050,14 +4050,14 @@ df_md_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n /* Allocate or reset bitmaps for DF_MD. The solution bits are\n    not touched unless the block is new.  */\n \n-static void \n+static void\n df_md_alloc (bitmap all_blocks)\n {\n   unsigned int bb_index;\n   bitmap_iterator bi;\n \n   if (!df_md->block_pool)\n-    df_md->block_pool = create_alloc_pool (\"df_md_block pool\", \n+    df_md->block_pool = create_alloc_pool (\"df_md_block pool\",\n                                            sizeof (struct df_md_bb_info), 50);\n \n   df_grow_bb_info (df_md);\n@@ -4066,15 +4066,15 @@ df_md_alloc (bitmap all_blocks)\n     {\n       struct df_md_bb_info *bb_info = df_md_get_bb_info (bb_index);\n       if (bb_info)\n-        { \n+        {\n           bitmap_clear (bb_info->init);\n           bitmap_clear (bb_info->gen);\n           bitmap_clear (bb_info->kill);\n           bitmap_clear (bb_info->in);\n           bitmap_clear (bb_info->out);\n         }\n       else\n-        { \n+        {\n           bb_info = (struct df_md_bb_info *) pool_alloc (df_md->block_pool);\n           df_md_set_bb_info (bb_index, bb_info);\n           bb_info->init = BITMAP_ALLOC (NULL);\n@@ -4139,7 +4139,7 @@ df_md_simulate_one_insn (basic_block bb ATTRIBUTE_UNUSED, rtx insn,\n }\n \n static void\n-df_md_bb_local_compute_process_def (struct df_md_bb_info *bb_info, \n+df_md_bb_local_compute_process_def (struct df_md_bb_info *bb_info,\n                                     df_ref *def_rec,\n                                     int top_flag)\n {\n@@ -4186,7 +4186,7 @@ df_md_bb_local_compute (unsigned int bb_index)\n \n   /* Artificials are only hard regs.  */\n   if (!(df->changeable_flags & DF_NO_HARD_REGS))\n-    df_md_bb_local_compute_process_def (bb_info, \n+    df_md_bb_local_compute_process_def (bb_info,\n                                         df_get_artificial_defs (bb_index),\n                                         DF_REF_AT_TOP);\n \n@@ -4200,7 +4200,7 @@ df_md_bb_local_compute (unsigned int bb_index)\n     }\n \n   if (!(df->changeable_flags & DF_NO_HARD_REGS))\n-    df_md_bb_local_compute_process_def (bb_info, \n+    df_md_bb_local_compute_process_def (bb_info,\n                                         df_get_artificial_defs (bb_index),\n                                         0);\n }\n@@ -4221,7 +4221,7 @@ df_md_local_compute (bitmap all_blocks)\n     {\n       df_md_bb_local_compute (bb_index);\n     }\n-  \n+\n   BITMAP_FREE (seen_in_insn);\n \n   frontiers = XNEWVEC (bitmap, last_basic_block);\n@@ -4249,7 +4249,7 @@ df_md_local_compute (bitmap all_blocks)\n \n /* Reset the global solution for recalculation.  */\n \n-static void \n+static void\n df_md_reset (bitmap all_blocks)\n {\n   unsigned int bb_index;\n@@ -4278,7 +4278,7 @@ df_md_transfer_function (int bb_index)\n \n /* Initialize the solution bit vectors for problem.  */\n \n-static void \n+static void\n df_md_init (bitmap all_blocks)\n {\n   unsigned int bb_index;\n@@ -4287,7 +4287,7 @@ df_md_init (bitmap all_blocks)\n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n     {\n       struct df_md_bb_info *bb_info = df_md_get_bb_info (bb_index);\n-      \n+\n       bitmap_copy (bb_info->in, bb_info->init);\n       df_md_transfer_function (bb_index);\n     }\n@@ -4298,7 +4298,7 @@ df_md_confluence_0 (basic_block bb)\n {\n   struct df_md_bb_info *bb_info = df_md_get_bb_info (bb->index);\n   bitmap_copy (bb_info->in, bb_info->init);\n-} \n+}\n \n /* In of target gets or of out of source.  */\n \n@@ -4308,7 +4308,7 @@ df_md_confluence_n (edge e)\n   bitmap op1 = df_md_get_bb_info (e->dest->index)->in;\n   bitmap op2 = df_md_get_bb_info (e->src->index)->out;\n \n-  if (e->flags & EDGE_FAKE) \n+  if (e->flags & EDGE_FAKE)\n     return;\n \n   if (e->flags & EDGE_EH)\n@@ -4352,7 +4352,7 @@ df_md_top_dump (basic_block bb, FILE *file)\n   struct df_md_bb_info *bb_info = df_md_get_bb_info (bb->index);\n   if (!bb_info || !bb_info->in)\n     return;\n-      \n+\n   fprintf (file, \";; md  in  \\t\");\n   df_print_regset (file, bb_info->in);\n   fprintf (file, \";; md  init  \\t\");\n@@ -4371,10 +4371,10 @@ df_md_bottom_dump (basic_block bb, FILE *file)\n   struct df_md_bb_info *bb_info = df_md_get_bb_info (bb->index);\n   if (!bb_info || !bb_info->out)\n     return;\n-  \n+\n   fprintf (file, \";; md  out \\t\");\n   df_print_regset (file, bb_info->out);\n-}  \n+}\n \n static struct df_problem problem_MD =\n {\n@@ -4386,8 +4386,8 @@ static struct df_problem problem_MD =\n   df_md_local_compute,        /* Local compute function.  */\n   df_md_init,                 /* Init the solution specific data.  */\n   df_worklist_dataflow,       /* Worklist solver.  */\n-  df_md_confluence_0,         /* Confluence operator 0.  */ \n-  df_md_confluence_n,         /* Confluence operator n.  */ \n+  df_md_confluence_0,         /* Confluence operator 0.  */\n+  df_md_confluence_n,         /* Confluence operator n.  */\n   df_md_transfer_function,    /* Transfer function.  */\n   NULL,                       /* Finalize function.  */\n   df_md_free,                 /* Free all of the problem information.  */\n@@ -4398,7 +4398,7 @@ static struct df_problem problem_MD =\n   NULL,\t\t\t      /* Incremental solution verify start.  */\n   NULL,\t\t\t      /* Incremental solution verify end.  */\n   NULL,                       /* Dependent problem.  */\n-  TV_DF_MD,                   /* Timing variable.  */ \n+  TV_DF_MD,                   /* Timing variable.  */\n   false                       /* Reset blocks on dropping out of blocks_to_analyze.  */\n };\n "}, {"sha": "4428b8820e9c6bbad9d2fea3fb80564f0652076b", "filename": "gcc/df-scan.c", "status": "modified", "additions": 290, "deletions": 290, "changes": 580, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -1,7 +1,7 @@\n /* Scanning of rtl for dataflow analysis.\n    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,\n    2008, 2009  Free Software Foundation, Inc.\n-   Originally contributed by Michael P. Hayes \n+   Originally contributed by Michael P. Hayes\n              (m.hayes@elec.canterbury.ac.nz, mhayes@redhat.com)\n    Major rewrite contributed by Danny Berlin (dberlin@dberlin.org)\n              and Kenneth Zadeck (zadeck@naturalbridge.com).\n@@ -75,7 +75,7 @@ DEF_VEC_ALLOC_P_STACK(df_mw_hardreg_ptr);\n \n /* The following two macros free the vecs that hold either the refs or\n    the mw refs.  They are a little tricky because the vec has 0\n-   elements is special and is not to be freed.  */ \n+   elements is special and is not to be freed.  */\n #define df_scan_free_ref_vec(V) \\\n   do { \\\n     if (V && *V) \\\n@@ -107,7 +107,7 @@ static df_ref df_null_ref_rec[1];\n static struct df_mw_hardreg * df_null_mw_rec[1];\n \n static void df_ref_record (enum df_ref_class, struct df_collection_rec *,\n-\t\t\t   rtx, rtx *, \n+\t\t\t   rtx, rtx *,\n \t\t\t   basic_block, struct df_insn_info *,\n \t\t\t   enum df_ref_type, int ref_flags,\n \t\t\t   int, int, enum machine_mode);\n@@ -120,17 +120,17 @@ static void df_defs_record (struct df_collection_rec *, rtx,\n static void df_uses_record (enum df_ref_class, struct df_collection_rec *,\n \t\t\t    rtx *, enum df_ref_type,\n \t\t\t    basic_block, struct df_insn_info *,\n-\t\t\t    int ref_flags, \n+\t\t\t    int ref_flags,\n \t\t\t    int, int, enum machine_mode);\n \n-static df_ref df_ref_create_structure (enum df_ref_class, \n-\t\t\t\t       struct df_collection_rec *, rtx, rtx *, \n+static df_ref df_ref_create_structure (enum df_ref_class,\n+\t\t\t\t       struct df_collection_rec *, rtx, rtx *,\n \t\t\t\t       basic_block, struct df_insn_info *,\n \t\t\t\t       enum df_ref_type, int ref_flags,\n \t\t\t\t       int, int, enum machine_mode);\n \n-static void df_insn_refs_collect (struct df_collection_rec*, \n-\t\t\t\t  basic_block, struct df_insn_info *); \n+static void df_insn_refs_collect (struct df_collection_rec*,\n+\t\t\t\t  basic_block, struct df_insn_info *);\n static void df_canonize_collection_rec (struct df_collection_rec *);\n \n static void df_get_regular_block_artificial_uses (bitmap);\n@@ -144,13 +144,13 @@ static void df_grow_ref_info (struct df_ref_info *, unsigned int);\n static void df_ref_chain_delete_du_chain (df_ref *);\n static void df_ref_chain_delete (df_ref *);\n \n-static void df_refs_add_to_chains (struct df_collection_rec *, \n+static void df_refs_add_to_chains (struct df_collection_rec *,\n \t\t\t\t   basic_block, rtx);\n \n static bool df_insn_refs_verify (struct df_collection_rec *, basic_block, rtx, bool);\n static void df_entry_block_defs_collect (struct df_collection_rec *, bitmap);\n static void df_exit_block_uses_collect (struct df_collection_rec *, bitmap);\n-static void df_install_ref (df_ref, struct df_reg_info *, \n+static void df_install_ref (df_ref, struct df_reg_info *,\n \t\t\t    struct df_ref_info *, bool);\n \n static int df_ref_compare (const void *, const void *);\n@@ -193,7 +193,7 @@ typedef struct df_scan_bb_info *df_scan_bb_info_t;\n \n \n /* Internal function to shut down the scanning problem.  */\n-static void \n+static void\n df_scan_free_internal (void)\n {\n   struct df_scan_problem_data *problem_data\n@@ -282,7 +282,7 @@ df_scan_free_internal (void)\n /* Set basic block info.  */\n \n static void\n-df_scan_set_bb_info (unsigned int index, \n+df_scan_set_bb_info (unsigned int index,\n \t\t     struct df_scan_bb_info *bb_info)\n {\n   gcc_assert (df_scan);\n@@ -307,10 +307,10 @@ df_scan_free_bb_info (basic_block bb, void *vbb_info)\n \t    /* Record defs within INSN.  */\n \t    df_insn_delete (bb, INSN_UID (insn));\n \t}\n-      \n+\n       if (bb_index < df_scan->block_info_size)\n \tbb_info = df_scan_get_bb_info (bb_index);\n-      \n+\n       /* Get rid of any artificial uses or defs.  */\n       df_ref_chain_delete_du_chain (bb_info->artificial_defs);\n       df_ref_chain_delete_du_chain (bb_info->artificial_uses);\n@@ -326,7 +326,7 @@ df_scan_free_bb_info (basic_block bb, void *vbb_info)\n /* Allocate the problem data for the scanning problem.  This should be\n    called when the problem is created or when the entire function is to\n    be rescanned.  */\n-void \n+void\n df_scan_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n {\n   struct df_scan_problem_data *problem_data;\n@@ -339,41 +339,41 @@ df_scan_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n   if (df_scan->problem_data)\n     df_scan_free_internal ();\n \n-  df_scan->block_pool \n-    = create_alloc_pool (\"df_scan_block pool\", \n-\t\t\t sizeof (struct df_scan_bb_info), \n+  df_scan->block_pool\n+    = create_alloc_pool (\"df_scan_block pool\",\n+\t\t\t sizeof (struct df_scan_bb_info),\n \t\t\t block_size);\n \n   problem_data = XNEW (struct df_scan_problem_data);\n   df_scan->problem_data = problem_data;\n   df_scan->computed = true;\n \n-  problem_data->ref_base_pool \n-    = create_alloc_pool (\"df_scan ref base\", \n+  problem_data->ref_base_pool\n+    = create_alloc_pool (\"df_scan ref base\",\n \t\t\t sizeof (struct df_base_ref), block_size);\n-  problem_data->ref_artificial_pool \n-    = create_alloc_pool (\"df_scan ref artificial\", \n+  problem_data->ref_artificial_pool\n+    = create_alloc_pool (\"df_scan ref artificial\",\n \t\t\t sizeof (struct df_artificial_ref), block_size);\n-  problem_data->ref_regular_pool \n-    = create_alloc_pool (\"df_scan ref regular\", \n+  problem_data->ref_regular_pool\n+    = create_alloc_pool (\"df_scan ref regular\",\n \t\t\t sizeof (struct df_regular_ref), block_size);\n-  problem_data->ref_extract_pool \n-    = create_alloc_pool (\"df_scan ref extract\", \n+  problem_data->ref_extract_pool\n+    = create_alloc_pool (\"df_scan ref extract\",\n \t\t\t sizeof (struct df_extract_ref), block_size);\n-  problem_data->insn_pool \n-    = create_alloc_pool (\"df_scan insn\", \n+  problem_data->insn_pool\n+    = create_alloc_pool (\"df_scan insn\",\n \t\t\t sizeof (struct df_insn_info), block_size);\n-  problem_data->reg_pool \n-    = create_alloc_pool (\"df_scan reg\", \n+  problem_data->reg_pool\n+    = create_alloc_pool (\"df_scan reg\",\n \t\t\t sizeof (struct df_reg_info), block_size);\n-  problem_data->mw_reg_pool \n-    = create_alloc_pool (\"df_scan mw_reg\", \n+  problem_data->mw_reg_pool\n+    = create_alloc_pool (\"df_scan mw_reg\",\n \t\t\t sizeof (struct df_mw_hardreg), block_size);\n \n   bitmap_obstack_initialize (&problem_data->reg_bitmaps);\n   bitmap_obstack_initialize (&problem_data->insn_bitmaps);\n \n-  insn_num += insn_num / 4; \n+  insn_num += insn_num / 4;\n   df_grow_reg_info ();\n \n   df_grow_insn_info ();\n@@ -406,7 +406,7 @@ df_scan_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n \n /* Free all of the data associated with the scan problem.  */\n \n-static void \n+static void\n df_scan_free (void)\n {\n   if (df_scan->problem_data)\n@@ -422,7 +422,7 @@ df_scan_free (void)\n }\n \n /* Dump the preamble for DF_SCAN dump. */\n-static void \n+static void\n df_scan_start_dump (FILE *file ATTRIBUTE_UNUSED)\n {\n   int i;\n@@ -451,7 +451,7 @@ df_scan_start_dump (FILE *file ATTRIBUTE_UNUSED)\n     if (df_regs_ever_live_p (i))\n       fprintf (file, \" %d[%s]\", i, reg_names[i]);\n   fprintf (file, \"\\n;;  ref usage \\t\");\n-  \n+\n   for (i = 0; i < (int)df->regs_inited; i++)\n     if (DF_REG_DEF_COUNT (i) || DF_REG_USE_COUNT (i) || DF_REG_EQ_USE_COUNT (i))\n       {\n@@ -488,12 +488,12 @@ df_scan_start_dump (FILE *file ATTRIBUTE_UNUSED)\n \t    icount++;\n \t}\n \n-  fprintf (file, \"\\n;;    total ref usage %d{%dd,%du,%de} in %d{%d regular + %d call} insns.\\n\", \n+  fprintf (file, \"\\n;;    total ref usage %d{%dd,%du,%de} in %d{%d regular + %d call} insns.\\n\",\n \t   dcount + ucount + ecount, dcount, ucount, ecount, icount + ccount, icount, ccount);\n }\n \n /* Dump the bb_info for a given basic block. */\n-static void \n+static void\n df_scan_start_block (basic_block bb, FILE *file)\n {\n   struct df_scan_bb_info *bb_info\n@@ -527,8 +527,8 @@ static struct df_problem problem_SCAN =\n   NULL,                       /* Local compute function.  */\n   NULL,                       /* Init the solution specific data.  */\n   NULL,                       /* Iterative solver.  */\n-  NULL,                       /* Confluence operator 0.  */ \n-  NULL,                       /* Confluence operator n.  */ \n+  NULL,                       /* Confluence operator 0.  */\n+  NULL,                       /* Confluence operator n.  */\n   NULL,                       /* Transfer function.  */\n   NULL,                       /* Finalize function.  */\n   df_scan_free,               /* Free all of the problem information.  */\n@@ -562,12 +562,12 @@ df_scan_add_problem (void)\n \n /* First, grow the reg_info information.  If the current size is less than\n    the number of pseudos, grow to 25% more than the number of\n-   pseudos.  \n+   pseudos.\n \n    Second, assure that all of the slots up to max_reg_num have been\n    filled with reg_info structures.  */\n \n-void \n+void\n df_grow_reg_info (void)\n {\n   unsigned int max_reg = max_reg_num ();\n@@ -608,14 +608,14 @@ df_grow_reg_info (void)\n       df->use_info.begin[i] = 0;\n       df->use_info.count[i] = 0;\n     }\n-  \n+\n   df->regs_inited = max_reg;\n }\n \n \n /* Grow the ref information.  */\n \n-static void \n+static void\n df_grow_ref_info (struct df_ref_info *ref_info, unsigned int new_size)\n {\n   if (ref_info->refs_size < new_size)\n@@ -634,7 +634,7 @@ df_grow_ref_info (struct df_ref_info *ref_info, unsigned int new_size)\n    ref_info->total_size.  */\n \n static void\n-df_check_and_grow_ref_info (struct df_ref_info *ref_info, \n+df_check_and_grow_ref_info (struct df_ref_info *ref_info,\n \t\t\t    unsigned bitmap_addend)\n {\n   if (ref_info->refs_size < ref_info->total_size + bitmap_addend)\n@@ -650,7 +650,7 @@ df_check_and_grow_ref_info (struct df_ref_info *ref_info,\n    number of instructions, grow to 25% more than the number of\n    instructions.  */\n \n-void \n+void\n df_grow_insn_info (void)\n {\n   unsigned int new_size = get_max_uid () + 1;\n@@ -685,7 +685,7 @@ df_scan_blocks (void)\n   df_get_regular_block_artificial_uses (df->regular_block_artificial_uses);\n   df_get_eh_block_artificial_uses (df->eh_block_artificial_uses);\n \n-  bitmap_ior_into (df->eh_block_artificial_uses, \n+  bitmap_ior_into (df->eh_block_artificial_uses,\n \t\t   df->regular_block_artificial_uses);\n \n   /* ENTRY and EXIT blocks have special defs/uses.  */\n@@ -706,17 +706,17 @@ df_scan_blocks (void)\n \n \n /* Create a new ref of type DF_REF_TYPE for register REG at address\n-   LOC within INSN of BB.  This function is only used externally. \n+   LOC within INSN of BB.  This function is only used externally.\n \n    If the REF_FLAGS field contain DF_REF_SIGN_EXTRACT or\n    DF_REF_ZERO_EXTRACT.  WIDTH, OFFSET and MODE are used to access the\n    fields if they were constants.  Otherwise they should be -1 if\n    those flags were set.  */\n \n-df_ref \n-df_ref_create (rtx reg, rtx *loc, rtx insn, \n+df_ref\n+df_ref_create (rtx reg, rtx *loc, rtx insn,\n \t       basic_block bb,\n-\t       enum df_ref_type ref_type, \n+\t       enum df_ref_type ref_type,\n \t       int ref_flags,\n \t       int width, int offset, enum machine_mode mode)\n {\n@@ -741,7 +741,7 @@ df_ref_create (rtx reg, rtx *loc, rtx insn,\n   else\n     cl = DF_REF_BASE;\n   ref = df_ref_create_structure (cl, NULL, reg, loc, bb, DF_INSN_INFO_GET (insn),\n-                                 ref_type, ref_flags, \n+                                 ref_type, ref_flags,\n \t\t\t\t width, offset, mode);\n \n   if (DF_REF_REG_DEF_P (ref))\n@@ -781,7 +781,7 @@ df_ref_create (rtx reg, rtx *loc, rtx insn,\n     add_to_table = bitmap_bit_p (df->blocks_to_analyze, bb->index);\n \n   df_install_ref (ref, reg_info[DF_REF_REGNO (ref)], ref_info, add_to_table);\n-  \n+\n   if (add_to_table)\n     switch (ref_info->ref_order)\n       {\n@@ -828,7 +828,7 @@ df_ref_create (rtx reg, rtx *loc, rtx insn,\n #endif\n   /* By adding the ref directly, df_insn_rescan my not find any\n      differences even though the block will have changed.  So we need\n-     to mark the block dirty ourselves.  */  \n+     to mark the block dirty ourselves.  */\n   if (!DEBUG_INSN_P (DF_REF_INSN (ref)))\n     df_set_bb_dirty (bb);\n \n@@ -872,9 +872,9 @@ df_free_ref (df_ref ref)\n    Also delete the def-use or use-def chain if it exists.  */\n \n static void\n-df_reg_chain_unlink (df_ref ref) \n+df_reg_chain_unlink (df_ref ref)\n {\n-  df_ref next = DF_REF_NEXT_REG (ref);  \n+  df_ref next = DF_REF_NEXT_REG (ref);\n   df_ref prev = DF_REF_PREV_REG (ref);\n   int id = DF_REF_ID (ref);\n   struct df_reg_info *reg_info;\n@@ -886,7 +886,7 @@ df_reg_chain_unlink (df_ref ref)\n       reg_info = DF_REG_DEF_GET (regno);\n       refs = df->def_info.refs;\n     }\n-  else \n+  else\n     {\n       if (DF_REF_FLAGS (ref) & DF_REF_IN_NOTE)\n \t{\n@@ -919,15 +919,15 @@ df_reg_chain_unlink (df_ref ref)\n       else\n \trefs[id] = NULL;\n     }\n-  \n+\n   /* Delete any def-use or use-def chains that start here. It is\n      possible that there is trash in this field.  This happens for\n      insns that have been deleted when rescanning has been deferred\n      and the chain problem has also been deleted.  The chain tear down\n      code skips deleted insns.  */\n   if (df_chain && DF_REF_CHAIN (ref))\n     df_chain_unlink (ref);\n-  \n+\n   reg_info->n_refs--;\n   if (DF_REF_FLAGS_IS_SET (ref, DF_HARD_REG_LIVE))\n     {\n@@ -962,7 +962,7 @@ df_ref_compress_rec (df_ref **vec_ptr, df_ref ref)\n     {\n       while (*vec && *vec != ref)\n \tvec++;\n-      \n+\n       while (*vec)\n \t{\n \t  *vec = *(vec+1);\n@@ -994,7 +994,7 @@ df_ref_remove (df_ref ref)\n     {\n       if (DF_REF_IS_ARTIFICIAL (ref))\n \t{\n-\t  struct df_scan_bb_info *bb_info \n+\t  struct df_scan_bb_info *bb_info\n \t    = df_scan_get_bb_info (DF_REF_BBNO (ref));\n \t  df_ref_compress_rec (&bb_info->artificial_defs, ref);\n \t}\n@@ -1009,11 +1009,11 @@ df_ref_remove (df_ref ref)\n     {\n       if (DF_REF_IS_ARTIFICIAL (ref))\n \t{\n-\t  struct df_scan_bb_info *bb_info \n+\t  struct df_scan_bb_info *bb_info\n \t    = df_scan_get_bb_info (DF_REF_BBNO (ref));\n \t  df_ref_compress_rec (&bb_info->artificial_uses, ref);\n \t}\n-      else \n+      else\n \t{\n \t  unsigned int uid = DF_REF_INSN_UID (ref);\n \t  struct df_insn_info *insn_rec = DF_INSN_UID_GET (uid);\n@@ -1027,7 +1027,7 @@ df_ref_remove (df_ref ref)\n \n   /* By deleting the ref directly, df_insn_rescan my not find any\n      differences even though the block will have changed.  So we need\n-     to mark the block dirty ourselves.  */  \n+     to mark the block dirty ourselves.  */\n   if (!DEBUG_INSN_P (DF_REF_INSN (ref)))\n     df_set_bb_dirty (DF_REF_BB (ref));\n   df_reg_chain_unlink (ref);\n@@ -1065,7 +1065,7 @@ df_ref_chain_delete_du_chain (df_ref *ref_rec)\n   while (*ref_rec)\n     {\n       df_ref ref = *ref_rec;\n-      /* CHAIN is allocated by DF_CHAIN. So make sure to \n+      /* CHAIN is allocated by DF_CHAIN. So make sure to\n          pass df_scan instance for the problem.  */\n       if (DF_REF_CHAIN (ref))\n         df_chain_unlink (ref);\n@@ -1117,7 +1117,7 @@ df_mw_hardreg_chain_delete (struct df_mw_hardreg **hardregs)\n    except when called from df_process_deferred_rescans to mark the block\n    as dirty.  */\n \n-void \n+void\n df_insn_delete (basic_block bb, unsigned int uid)\n {\n   struct df_insn_info *insn_info = NULL;\n@@ -1157,7 +1157,7 @@ df_insn_delete (basic_block bb, unsigned int uid)\n   bitmap_clear_bit (df->insns_to_notes_rescan, uid);\n   if (insn_info)\n     {\n-      struct df_scan_problem_data *problem_data \n+      struct df_scan_problem_data *problem_data\n \t= (struct df_scan_problem_data *) df_scan->problem_data;\n \n       /* In general, notes do not have the insn_info fields\n@@ -1168,14 +1168,14 @@ df_insn_delete (basic_block bb, unsigned int uid)\n       if (insn_info->defs)\n \t{\n \t  df_mw_hardreg_chain_delete (insn_info->mw_hardregs);\n-\t  \n+\n \t  if (df_chain)\n \t    {\n \t      df_ref_chain_delete_du_chain (insn_info->defs);\n-\t      df_ref_chain_delete_du_chain (insn_info->uses);  \n+\t      df_ref_chain_delete_du_chain (insn_info->uses);\n \t      df_ref_chain_delete_du_chain (insn_info->eq_uses);\n \t    }\n-\t  \n+\n \t  df_ref_chain_delete (insn_info->defs);\n \t  df_ref_chain_delete (insn_info->uses);\n \t  df_ref_chain_delete (insn_info->eq_uses);\n@@ -1192,7 +1192,7 @@ static void\n df_free_collection_rec (struct df_collection_rec *collection_rec)\n {\n   unsigned int ix;\n-  struct df_scan_problem_data *problem_data \n+  struct df_scan_problem_data *problem_data\n     = (struct df_scan_problem_data *) df_scan->problem_data;\n   df_ref ref;\n   struct df_mw_hardreg *mw;\n@@ -1216,7 +1216,7 @@ df_free_collection_rec (struct df_collection_rec *collection_rec)\n \n /* Rescan INSN.  Return TRUE if the rescanning produced any changes.  */\n \n-bool \n+bool\n df_insn_rescan (rtx insn)\n {\n   unsigned int uid = INSN_UID (insn);\n@@ -1256,7 +1256,7 @@ df_insn_rescan (rtx insn)\n \t}\n       if (dump_file)\n \tfprintf (dump_file, \"deferring rescan insn with uid = %d.\\n\", uid);\n-    \n+\n       bitmap_clear_bit (df->insns_to_delete, uid);\n       bitmap_clear_bit (df->insns_to_notes_rescan, uid);\n       bitmap_set_bit (df->insns_to_rescan, INSN_UID (insn));\n@@ -1382,13 +1382,13 @@ df_insn_rescan_all (void)\n   bitmap_iterator bi;\n   unsigned int uid;\n   bitmap tmp = BITMAP_ALLOC (&df_bitmap_obstack);\n-  \n+\n   if (df->changeable_flags & DF_NO_INSN_RESCAN)\n     {\n       df_clear_flags (DF_NO_INSN_RESCAN);\n       no_insn_rescan = true;\n     }\n-  \n+\n   if (df->changeable_flags & DF_DEFER_INSN_RESCAN)\n     {\n       df_clear_flags (DF_DEFER_INSN_RESCAN);\n@@ -1408,7 +1408,7 @@ df_insn_rescan_all (void)\n   bitmap_clear (df->insns_to_rescan);\n   bitmap_clear (df->insns_to_notes_rescan);\n \n-  FOR_EACH_BB (bb) \n+  FOR_EACH_BB (bb)\n     {\n       rtx insn;\n       FOR_BB_INSNS (bb, insn)\n@@ -1434,13 +1434,13 @@ df_process_deferred_rescans (void)\n   bitmap_iterator bi;\n   unsigned int uid;\n   bitmap tmp = BITMAP_ALLOC (&df_bitmap_obstack);\n-  \n+\n   if (df->changeable_flags & DF_NO_INSN_RESCAN)\n     {\n       df_clear_flags (DF_NO_INSN_RESCAN);\n       no_insn_rescan = true;\n     }\n-  \n+\n   if (df->changeable_flags & DF_DEFER_INSN_RESCAN)\n     {\n       df_clear_flags (DF_DEFER_INSN_RESCAN);\n@@ -1502,13 +1502,13 @@ df_process_deferred_rescans (void)\n    INCLUDE_EQ_USES.  */\n \n static unsigned int\n-df_count_refs (bool include_defs, bool include_uses, \n+df_count_refs (bool include_defs, bool include_uses,\n \t       bool include_eq_uses)\n {\n   unsigned int regno;\n   int size = 0;\n   unsigned int m = df->regs_inited;\n-  \n+\n   for (regno = 0; regno < m; regno++)\n     {\n       if (include_defs)\n@@ -1526,10 +1526,10 @@ df_count_refs (bool include_defs, bool include_uses,\n    or reg-def chains.  This version processes the refs in reg order\n    which is likely to be best if processing the whole function.  */\n \n-static void \n+static void\n df_reorganize_refs_by_reg_by_reg (struct df_ref_info *ref_info,\n-\t\t\t\t  bool include_defs, \n-\t\t\t\t  bool include_uses, \n+\t\t\t\t  bool include_defs,\n+\t\t\t\t  bool include_uses,\n \t\t\t\t  bool include_eq_uses)\n {\n   unsigned int m = df->regs_inited;\n@@ -1546,7 +1546,7 @@ df_reorganize_refs_by_reg_by_reg (struct df_ref_info *ref_info,\n   else\n     start = 0;\n \n-  ref_info->total_size \n+  ref_info->total_size\n     = df_count_refs (include_defs, include_uses, include_eq_uses);\n \n   df_check_and_grow_ref_info (ref_info, 1);\n@@ -1558,7 +1558,7 @@ df_reorganize_refs_by_reg_by_reg (struct df_ref_info *ref_info,\n       if (include_defs)\n \t{\n \t  df_ref ref = DF_REG_DEF_CHAIN (regno);\n-\t  while (ref) \n+\t  while (ref)\n \t    {\n \t      ref_info->refs[offset] = ref;\n \t      DF_REF_ID (ref) = offset++;\n@@ -1570,7 +1570,7 @@ df_reorganize_refs_by_reg_by_reg (struct df_ref_info *ref_info,\n       if (include_uses)\n \t{\n \t  df_ref ref = DF_REG_USE_CHAIN (regno);\n-\t  while (ref) \n+\t  while (ref)\n \t    {\n \t      ref_info->refs[offset] = ref;\n \t      DF_REF_ID (ref) = offset++;\n@@ -1582,7 +1582,7 @@ df_reorganize_refs_by_reg_by_reg (struct df_ref_info *ref_info,\n       if (include_eq_uses)\n \t{\n \t  df_ref ref = DF_REG_EQ_USE_CHAIN (regno);\n-\t  while (ref) \n+\t  while (ref)\n \t    {\n \t      ref_info->refs[offset] = ref;\n \t      DF_REF_ID (ref) = offset++;\n@@ -1593,7 +1593,7 @@ df_reorganize_refs_by_reg_by_reg (struct df_ref_info *ref_info,\n \t}\n       ref_info->count[regno] = count;\n     }\n-  \n+\n   /* The bitmap size is not decremented when refs are deleted.  So\n      reset it now that we have squished out all of the empty\n      slots.  */\n@@ -1606,18 +1606,18 @@ df_reorganize_refs_by_reg_by_reg (struct df_ref_info *ref_info,\n    which is likely to be best if processing some segment of the\n    function.  */\n \n-static void \n+static void\n df_reorganize_refs_by_reg_by_insn (struct df_ref_info *ref_info,\n-\t\t\t\t   bool include_defs, \n-\t\t\t\t   bool include_uses, \n+\t\t\t\t   bool include_defs,\n+\t\t\t\t   bool include_uses,\n \t\t\t\t   bool include_eq_uses)\n {\n   bitmap_iterator bi;\n   unsigned int bb_index;\n   unsigned int m = df->regs_inited;\n   unsigned int offset = 0;\n   unsigned int r;\n-  unsigned int start \n+  unsigned int start\n     = (df->changeable_flags & DF_NO_HARD_REGS) ? FIRST_PSEUDO_REGISTER : 0;\n \n   memset (ref_info->begin, 0, sizeof (int) * df->regs_inited);\n@@ -1650,7 +1650,7 @@ df_reorganize_refs_by_reg_by_insn (struct df_ref_info *ref_info,\n \t  if (INSN_P (insn))\n \t    {\n \t      unsigned int uid = INSN_UID (insn);\n-\t      \n+\n \t      if (include_defs)\n \t\tfor (ref_rec = DF_INSN_UID_DEFS (uid); *ref_rec; ref_rec++)\n \t\t  {\n@@ -1679,7 +1679,7 @@ df_reorganize_refs_by_reg_by_insn (struct df_ref_info *ref_info,\n       offset += ref_info->count[r];\n       ref_info->count[r] = 0;\n     }\n-  \n+\n   EXECUTE_IF_SET_IN_BITMAP (df->blocks_to_analyze, 0, bb_index, bi)\n     {\n       basic_block bb = BASIC_BLOCK (bb_index);\n@@ -1718,7 +1718,7 @@ df_reorganize_refs_by_reg_by_insn (struct df_ref_info *ref_info,\n \t  if (INSN_P (insn))\n \t    {\n \t      unsigned int uid = INSN_UID (insn);\n-\t      \n+\n \t      if (include_defs)\n \t\tfor (ref_rec = DF_INSN_UID_DEFS (uid); *ref_rec; ref_rec++)\n \t\t  {\n@@ -1772,25 +1772,25 @@ df_reorganize_refs_by_reg_by_insn (struct df_ref_info *ref_info,\n /* Take build ref table for either the uses or defs from the reg-use\n    or reg-def chains.  */\n \n-static void \n+static void\n df_reorganize_refs_by_reg (struct df_ref_info *ref_info,\n-\t\t\t   bool include_defs, \n-\t\t\t   bool include_uses, \n+\t\t\t   bool include_defs,\n+\t\t\t   bool include_uses,\n \t\t\t   bool include_eq_uses)\n {\n   if (df->analyze_subset)\n-    df_reorganize_refs_by_reg_by_insn (ref_info, include_defs, \n+    df_reorganize_refs_by_reg_by_insn (ref_info, include_defs,\n \t\t\t\t       include_uses, include_eq_uses);\n   else\n-    df_reorganize_refs_by_reg_by_reg (ref_info, include_defs, \n+    df_reorganize_refs_by_reg_by_reg (ref_info, include_defs,\n \t\t\t\t       include_uses, include_eq_uses);\n }\n \n \n /* Add the refs in REF_VEC to the table in REF_INFO starting at OFFSET.  */\n-static unsigned int \n-df_add_refs_to_table (unsigned int offset, \n-\t\t      struct df_ref_info *ref_info, \n+static unsigned int\n+df_add_refs_to_table (unsigned int offset,\n+\t\t      struct df_ref_info *ref_info,\n \t\t      df_ref *ref_vec)\n {\n   while (*ref_vec)\n@@ -1813,32 +1813,32 @@ df_add_refs_to_table (unsigned int offset,\n    eq_uses if INCLUDE_EQ_USES.  */\n \n static unsigned int\n-df_reorganize_refs_by_insn_bb (basic_block bb, unsigned int offset, \n+df_reorganize_refs_by_insn_bb (basic_block bb, unsigned int offset,\n \t\t\t       struct df_ref_info *ref_info,\n-\t\t\t       bool include_defs, bool include_uses, \n+\t\t\t       bool include_defs, bool include_uses,\n \t\t\t       bool include_eq_uses)\n {\n   rtx insn;\n \n   if (include_defs)\n-    offset = df_add_refs_to_table (offset, ref_info, \n+    offset = df_add_refs_to_table (offset, ref_info,\n \t\t\t\t   df_get_artificial_defs (bb->index));\n   if (include_uses)\n-    offset = df_add_refs_to_table (offset, ref_info, \n+    offset = df_add_refs_to_table (offset, ref_info,\n \t\t\t\t   df_get_artificial_uses (bb->index));\n \n   FOR_BB_INSNS (bb, insn)\n     if (INSN_P (insn))\n       {\n \tunsigned int uid = INSN_UID (insn);\n \tif (include_defs)\n-\t  offset = df_add_refs_to_table (offset, ref_info, \n+\t  offset = df_add_refs_to_table (offset, ref_info,\n \t\t\t\t\t DF_INSN_UID_DEFS (uid));\n \tif (include_uses)\n-\t  offset = df_add_refs_to_table (offset, ref_info, \n+\t  offset = df_add_refs_to_table (offset, ref_info,\n \t\t\t\t\t DF_INSN_UID_USES (uid));\n \tif (include_eq_uses)\n-\t  offset = df_add_refs_to_table (offset, ref_info, \n+\t  offset = df_add_refs_to_table (offset, ref_info,\n \t\t\t\t\t DF_INSN_UID_EQ_USES (uid));\n       }\n   return offset;\n@@ -1852,7 +1852,7 @@ df_reorganize_refs_by_insn_bb (basic_block bb, unsigned int offset,\n \n static void\n df_reorganize_refs_by_insn (struct df_ref_info *ref_info,\n-\t\t\t    bool include_defs, bool include_uses, \n+\t\t\t    bool include_defs, bool include_uses,\n \t\t\t    bool include_eq_uses)\n {\n   basic_block bb;\n@@ -1867,8 +1867,8 @@ df_reorganize_refs_by_insn (struct df_ref_info *ref_info,\n \n       EXECUTE_IF_SET_IN_BITMAP (df->blocks_to_analyze, 0, index, bi)\n \t{\n-\t  offset = df_reorganize_refs_by_insn_bb (BASIC_BLOCK (index), offset, ref_info, \n-\t\t\t\t\t\t  include_defs, include_uses, \n+\t  offset = df_reorganize_refs_by_insn_bb (BASIC_BLOCK (index), offset, ref_info,\n+\t\t\t\t\t\t  include_defs, include_uses,\n \t\t\t\t\t\t  include_eq_uses);\n \t}\n \n@@ -1877,8 +1877,8 @@ df_reorganize_refs_by_insn (struct df_ref_info *ref_info,\n   else\n     {\n       FOR_ALL_BB (bb)\n-\toffset = df_reorganize_refs_by_insn_bb (bb, offset, ref_info, \n-\t\t\t\t\t\tinclude_defs, include_uses, \n+\toffset = df_reorganize_refs_by_insn_bb (bb, offset, ref_info,\n+\t\t\t\t\t\tinclude_defs, include_uses,\n \t\t\t\t\t\tinclude_eq_uses);\n       ref_info->table_size = offset;\n     }\n@@ -1887,7 +1887,7 @@ df_reorganize_refs_by_insn (struct df_ref_info *ref_info,\n \n /* If the use refs in DF are not organized, reorganize them.  */\n \n-void \n+void\n df_maybe_reorganize_use_refs (enum df_ref_order order)\n {\n   if (order == df->use_info.ref_order)\n@@ -1922,14 +1922,14 @@ df_maybe_reorganize_use_refs (enum df_ref_order order)\n       gcc_unreachable ();\n       break;\n     }\n-      \n+\n   df->use_info.ref_order = order;\n }\n \n \n /* If the def refs in DF are not organized, reorganize them.  */\n \n-void \n+void\n df_maybe_reorganize_def_refs (enum df_ref_order order)\n {\n   if (order == df->def_info.ref_order)\n@@ -1958,14 +1958,14 @@ df_maybe_reorganize_def_refs (enum df_ref_order order)\n       gcc_unreachable ();\n       break;\n     }\n-      \n+\n   df->def_info.ref_order = order;\n }\n \n \n /* Change all of the basic block references in INSN to use the insn's\n-   current basic block.  This function is called from routines that move \n-   instructions from one block to another.  */  \n+   current basic block.  This function is called from routines that move\n+   instructions from one block to another.  */\n \n void\n df_insn_change_bb (rtx insn, basic_block new_bb)\n@@ -2001,7 +2001,7 @@ df_insn_change_bb (rtx insn, basic_block new_bb)\n   if (old_bb)\n     {\n       if (dump_file)\n-\tfprintf (dump_file, \"  from %d to %d\\n\", \n+\tfprintf (dump_file, \"  from %d to %d\\n\",\n \t\t old_bb->index, new_bb->index);\n       df_set_bb_dirty (old_bb);\n     }\n@@ -2014,7 +2014,7 @@ df_insn_change_bb (rtx insn, basic_block new_bb)\n /* Helper function for df_ref_change_reg_with_loc.  */\n \n static void\n-df_ref_change_reg_with_loc_1 (struct df_reg_info *old_df, \n+df_ref_change_reg_with_loc_1 (struct df_reg_info *old_df,\n \t\t\t      struct df_reg_info *new_df,\n \t\t\t      int new_regno, rtx loc)\n {\n@@ -2062,11 +2062,11 @@ df_ref_change_reg_with_loc_1 (struct df_reg_info *old_df,\n \t  else\n \t    ref_vec = insn_info->uses;\n \t  if (dump_file)\n-\t    fprintf (dump_file, \"changing reg in insn %d\\n\", \n-\t\t     DF_REF_INSN_UID (the_ref)); \n-      \n+\t    fprintf (dump_file, \"changing reg in insn %d\\n\",\n+\t\t     DF_REF_INSN_UID (the_ref));\n+\n \t  ref_vec_t = ref_vec;\n-\t  \n+\n \t  /* Find the length.  */\n \t  while (*ref_vec_t)\n \t    {\n@@ -2096,11 +2096,11 @@ df_ref_change_reg_with_loc (int old_regno, int new_regno, rtx loc)\n \n   df_grow_reg_info ();\n \n-  df_ref_change_reg_with_loc_1 (DF_REG_DEF_GET (old_regno), \n+  df_ref_change_reg_with_loc_1 (DF_REG_DEF_GET (old_regno),\n \t\t\t\tDF_REG_DEF_GET (new_regno), new_regno, loc);\n-  df_ref_change_reg_with_loc_1 (DF_REG_USE_GET (old_regno), \n+  df_ref_change_reg_with_loc_1 (DF_REG_USE_GET (old_regno),\n \t\t\t\tDF_REG_USE_GET (new_regno), new_regno, loc);\n-  df_ref_change_reg_with_loc_1 (DF_REG_EQ_USE_GET (old_regno), \n+  df_ref_change_reg_with_loc_1 (DF_REG_EQ_USE_GET (old_regno),\n \t\t\t\tDF_REG_EQ_USE_GET (new_regno), new_regno, loc);\n }\n \n@@ -2113,7 +2113,7 @@ df_mw_hardreg_chain_delete_eq_uses (struct df_insn_info *insn_info)\n   struct df_mw_hardreg **mw_vec = insn_info->mw_hardregs;\n   unsigned int deleted = 0;\n   unsigned int count = 0;\n-  struct df_scan_problem_data *problem_data \n+  struct df_scan_problem_data *problem_data\n     = (struct df_scan_problem_data *) df_scan->problem_data;\n \n   if (!*mw_vec)\n@@ -2130,7 +2130,7 @@ df_mw_hardreg_chain_delete_eq_uses (struct df_insn_info *insn_info)\n \t  /* Shove the remaining ones down one to fill the gap.  While\n \t     this looks n**2, it is highly unusual to have any mw regs\n \t     in eq_notes and the chances of more than one are almost\n-\t     non existent.  */ \n+\t     non existent.  */\n \t  while (*temp_vec)\n \t    {\n \t      *temp_vec = *(temp_vec + 1);\n@@ -2190,7 +2190,7 @@ df_notes_rescan (rtx insn)\n \t  insn_info->eq_uses = df_null_ref_rec;\n \t  insn_info->mw_hardregs = df_null_mw_rec;\n \t}\n-      \n+\n       bitmap_clear_bit (df->insns_to_delete, uid);\n       /* If the insn is set to be rescanned, it does not need to also\n \t be notes rescanned.  */\n@@ -2253,22 +2253,22 @@ df_notes_rescan (rtx insn)\n \t\t expanding it if necessary.  */\n \t      if (mw_len > num_deleted)\n \t\t{\n-\t\t  insn_info->mw_hardregs = \n+\t\t  insn_info->mw_hardregs =\n \t\t    XRESIZEVEC (struct df_mw_hardreg *,\n \t\t\t\tinsn_info->mw_hardregs,\n \t\t\t\tcount + 1 + mw_len);\n \t\t}\n \t      memcpy (&insn_info->mw_hardregs[count],\n-\t\t      VEC_address (df_mw_hardreg_ptr, collection_rec.mw_vec), \n+\t\t      VEC_address (df_mw_hardreg_ptr, collection_rec.mw_vec),\n \t\t      mw_len * sizeof (struct df_mw_hardreg *));\n \t      insn_info->mw_hardregs[count + mw_len] = NULL;\n-\t      qsort (insn_info->mw_hardregs, count + mw_len, \n+\t      qsort (insn_info->mw_hardregs, count + mw_len,\n \t\t     sizeof (struct df_mw_hardreg *), df_mw_compare);\n \t    }\n \t  else\n \t    {\n-\t      /* No vector there. */  \n-\t      insn_info->mw_hardregs \n+\t      /* No vector there. */\n+\t      insn_info->mw_hardregs\n \t\t= XNEWVEC (struct df_mw_hardreg*, 1 + mw_len);\n \t      memcpy (insn_info->mw_hardregs,\n \t\t      VEC_address (df_mw_hardreg_ptr, collection_rec.mw_vec),\n@@ -2294,28 +2294,28 @@ df_notes_rescan (rtx insn)\n ----------------------------------------------------------------------------*/\n \n \n-/* Return true if the contents of two df_ref's are identical. \n+/* Return true if the contents of two df_ref's are identical.\n    It ignores DF_REF_MARKER.  */\n \n static bool\n df_ref_equal_p (df_ref ref1, df_ref ref2)\n {\n   if (!ref2)\n     return false;\n-  \n+\n   if (ref1 == ref2)\n     return true;\n \n   if (DF_REF_CLASS (ref1) != DF_REF_CLASS (ref2)\n       || DF_REF_REGNO (ref1) != DF_REF_REGNO (ref2)\n       || DF_REF_REG (ref1) != DF_REF_REG (ref2)\n       || DF_REF_TYPE (ref1) != DF_REF_TYPE (ref2)\n-      || ((DF_REF_FLAGS (ref1) & ~(DF_REF_REG_MARKER + DF_REF_MW_HARDREG)) \n+      || ((DF_REF_FLAGS (ref1) & ~(DF_REF_REG_MARKER + DF_REF_MW_HARDREG))\n \t  != (DF_REF_FLAGS (ref2) & ~(DF_REF_REG_MARKER + DF_REF_MW_HARDREG)))\n       || DF_REF_BB (ref1) != DF_REF_BB (ref2)\n       || DF_REF_INSN_INFO (ref1) != DF_REF_INSN_INFO (ref2))\n     return false;\n-  \n+\n   switch (DF_REF_CLASS (ref1))\n     {\n     case DF_REF_ARTIFICIAL:\n@@ -2357,7 +2357,7 @@ df_ref_compare (const void *r1, const void *r2)\n \n   if (DF_REF_REGNO (ref1) != DF_REF_REGNO (ref2))\n     return (int)DF_REF_REGNO (ref1) - (int)DF_REF_REGNO (ref2);\n-  \n+\n   if (DF_REF_TYPE (ref1) != DF_REF_TYPE (ref2))\n     return (int)DF_REF_TYPE (ref1) - (int)DF_REF_TYPE (ref2);\n \n@@ -2439,7 +2439,7 @@ df_sort_and_compress_refs (VEC(df_ref,stack) **ref_vec)\n          which is the most common case for large COUNT case\n          (which happens for CALL INSNs),\n          no need to sort and filter out duplicate.\n-         Simply return the count.  \n+         Simply return the count.\n          Make sure DF_GET_ADD_REFS adds refs in the increasing order\n          of DF_REF_COMPARE.  */\n       if (i == count - 1)\n@@ -2469,7 +2469,7 @@ df_sort_and_compress_refs (VEC(df_ref,stack) **ref_vec)\n }\n \n \n-/* Return true if the contents of two df_ref's are identical. \n+/* Return true if the contents of two df_ref's are identical.\n    It ignores DF_REF_MARKER.  */\n \n static bool\n@@ -2522,7 +2522,7 @@ static void\n df_sort_and_compress_mws (VEC(df_mw_hardreg_ptr,stack) **mw_vec)\n {\n   unsigned int count;\n-  struct df_scan_problem_data *problem_data \n+  struct df_scan_problem_data *problem_data\n     = (struct df_scan_problem_data *) df_scan->problem_data;\n   unsigned int i;\n   unsigned int dist = 0;\n@@ -2585,8 +2585,8 @@ df_canonize_collection_rec (struct df_collection_rec *collection_rec)\n /* Add the new df_ref to appropriate reg_info/ref_info chains.  */\n \n static void\n-df_install_ref (df_ref this_ref, \n-\t\tstruct df_reg_info *reg_info, \n+df_install_ref (df_ref this_ref,\n+\t\tstruct df_reg_info *reg_info,\n \t\tstruct df_ref_info *ref_info,\n \t\tbool add_to_table)\n {\n@@ -2613,7 +2613,7 @@ df_install_ref (df_ref this_ref,\n \n   if (head)\n     DF_REF_PREV_REG (head) = this_ref;\n-  \n+\n   if (add_to_table)\n     {\n       gcc_assert (ref_info->ref_order != DF_REF_ORDER_NO_TABLE);\n@@ -2622,10 +2622,10 @@ df_install_ref (df_ref this_ref,\n       /* Add the ref to the big array of defs.  */\n       ref_info->refs[ref_info->table_size] = this_ref;\n       ref_info->table_size++;\n-    }    \n+    }\n   else\n     DF_REF_ID (this_ref) = -1;\n-  \n+\n   ref_info->total_size++;\n }\n \n@@ -2637,7 +2637,7 @@ df_install_ref (df_ref this_ref,\n static df_ref *\n df_install_refs (basic_block bb,\n \t\t VEC(df_ref,stack)* old_vec,\n-\t\t struct df_reg_info **reg_info, \n+\t\t struct df_reg_info **reg_info,\n \t\t struct df_ref_info *ref_info,\n \t\t bool is_notes)\n {\n@@ -2677,10 +2677,10 @@ df_install_refs (basic_block bb,\n       for (ix = 0; VEC_iterate (df_ref, old_vec, ix, this_ref); ++ix)\n \t{\n \t  new_vec[ix] = this_ref;\n-\t  df_install_ref (this_ref, reg_info[DF_REF_REGNO (this_ref)], \n+\t  df_install_ref (this_ref, reg_info[DF_REF_REGNO (this_ref)],\n \t\t\t  ref_info, add_to_table);\n \t}\n-      \n+\n       new_vec[count] = NULL;\n       return new_vec;\n     }\n@@ -2700,9 +2700,9 @@ df_install_mws (VEC(df_mw_hardreg_ptr,stack) *old_vec)\n   count = VEC_length (df_mw_hardreg_ptr, old_vec);\n   if (count)\n     {\n-      struct df_mw_hardreg **new_vec \n+      struct df_mw_hardreg **new_vec\n \t= XNEWVEC (struct df_mw_hardreg*, count + 1);\n-      memcpy (new_vec, VEC_address (df_mw_hardreg_ptr, old_vec), \n+      memcpy (new_vec, VEC_address (df_mw_hardreg_ptr, old_vec),\n \t      sizeof (struct df_mw_hardreg*) * count);\n       new_vec[count] = NULL;\n       return new_vec;\n@@ -2716,7 +2716,7 @@ df_install_mws (VEC(df_mw_hardreg_ptr,stack) *old_vec)\n    chains and update other necessary information.  */\n \n static void\n-df_refs_add_to_chains (struct df_collection_rec *collection_rec, \n+df_refs_add_to_chains (struct df_collection_rec *collection_rec,\n \t\t       basic_block bb, rtx insn)\n {\n   if (insn)\n@@ -2728,31 +2728,31 @@ df_refs_add_to_chains (struct df_collection_rec *collection_rec,\n       if (collection_rec->def_vec)\n \t{\n \t  df_scan_free_ref_vec (insn_rec->defs);\n-\t  insn_rec->defs \n+\t  insn_rec->defs\n \t    = df_install_refs (bb, collection_rec->def_vec,\n \t\t\t       df->def_regs,\n \t\t\t       &df->def_info, false);\n \t}\n       if (collection_rec->use_vec)\n \t{\n \t  df_scan_free_ref_vec (insn_rec->uses);\n-\t  insn_rec->uses \n-\t    = df_install_refs (bb, collection_rec->use_vec, \n+\t  insn_rec->uses\n+\t    = df_install_refs (bb, collection_rec->use_vec,\n \t\t\t       df->use_regs,\n \t\t\t       &df->use_info, false);\n \t}\n       if (collection_rec->eq_use_vec)\n \t{\n \t  df_scan_free_ref_vec (insn_rec->eq_uses);\n-\t  insn_rec->eq_uses \n-\t    = df_install_refs (bb, collection_rec->eq_use_vec, \n+\t  insn_rec->eq_uses\n+\t    = df_install_refs (bb, collection_rec->eq_use_vec,\n \t\t\t       df->eq_use_regs,\n \t\t\t       &df->use_info, true);\n \t}\n       if (collection_rec->mw_vec)\n \t{\n \t  df_scan_free_mws_vec (insn_rec->mw_hardregs);\n-\t  insn_rec->mw_hardregs \n+\t  insn_rec->mw_hardregs\n \t    = df_install_mws (collection_rec->mw_vec);\n \t}\n     }\n@@ -2761,32 +2761,32 @@ df_refs_add_to_chains (struct df_collection_rec *collection_rec,\n       struct df_scan_bb_info *bb_info = df_scan_get_bb_info (bb->index);\n \n       df_scan_free_ref_vec (bb_info->artificial_defs);\n-      bb_info->artificial_defs \n+      bb_info->artificial_defs\n \t= df_install_refs (bb, collection_rec->def_vec,\n \t\t\t   df->def_regs,\n \t\t\t   &df->def_info, false);\n       df_scan_free_ref_vec (bb_info->artificial_uses);\n-      bb_info->artificial_uses \n-\t= df_install_refs (bb, collection_rec->use_vec, \n+      bb_info->artificial_uses\n+\t= df_install_refs (bb, collection_rec->use_vec,\n \t\t\t   df->use_regs,\n \t\t\t   &df->use_info, false);\n     }\n }\n \n \n-/* Allocate a ref and initialize its fields. \n+/* Allocate a ref and initialize its fields.\n \n    If the REF_FLAGS field contain DF_REF_SIGN_EXTRACT or\n    DF_REF_ZERO_EXTRACT.  WIDTH, OFFSET and MODE are used to access the fields\n    if they were constants.  Otherwise they should be -1 if those flags\n    were set.  */\n \n-static df_ref \n-df_ref_create_structure (enum df_ref_class cl, \n+static df_ref\n+df_ref_create_structure (enum df_ref_class cl,\n \t\t\t struct df_collection_rec *collection_rec,\n-\t\t\t rtx reg, rtx *loc, \n+\t\t\t rtx reg, rtx *loc,\n \t\t\t basic_block bb, struct df_insn_info *info,\n-\t\t\t enum df_ref_type ref_type, \n+\t\t\t enum df_ref_type ref_type,\n \t\t\t int ref_flags,\n \t\t\t int width, int offset, enum machine_mode mode)\n {\n@@ -2842,7 +2842,7 @@ df_ref_create_structure (enum df_ref_class cl,\n   DF_REF_FLAGS_CLEAR (this_ref, DF_HARD_REG_LIVE);\n \n   /* See if this ref needs to have DF_HARD_REG_LIVE bit set.  */\n-  if ((regno < FIRST_PSEUDO_REGISTER) \n+  if ((regno < FIRST_PSEUDO_REGISTER)\n       && (!DF_REF_IS_ARTIFICIAL (this_ref)))\n     {\n       if (DF_REF_REG_DEF_P (this_ref))\n@@ -2871,7 +2871,7 @@ df_ref_create_structure (enum df_ref_class cl,\n \n \n /* Create new references of type DF_REF_TYPE for each part of register REG\n-   at address LOC within INSN of BB. \n+   at address LOC within INSN of BB.\n \n    If the REF_FLAGS field contain DF_REF_SIGN_EXTRACT or\n    DF_REF_ZERO_EXTRACT.  WIDTH, OFFSET and MODE are used to access the\n@@ -2880,13 +2880,13 @@ df_ref_create_structure (enum df_ref_class cl,\n \n \n static void\n-df_ref_record (enum df_ref_class cl, \n+df_ref_record (enum df_ref_class cl,\n \t       struct df_collection_rec *collection_rec,\n-               rtx reg, rtx *loc, \n+               rtx reg, rtx *loc,\n \t       basic_block bb, struct df_insn_info *insn_info,\n-\t       enum df_ref_type ref_type, \n+\t       enum df_ref_type ref_type,\n \t       int ref_flags,\n-\t       int width, int offset, enum machine_mode mode) \n+\t       int width, int offset, enum machine_mode mode)\n {\n   unsigned int regno;\n \n@@ -2916,7 +2916,7 @@ df_ref_record (enum df_ref_class cl,\n \t  and REG_UNUSED notes.  */\n       if ((endregno != regno + 1) && insn_info)\n \t{\n-\t  /* Sets to a subreg of a multiword register are partial. \n+\t  /* Sets to a subreg of a multiword register are partial.\n \t     Sets to a non-subreg of a multiword register are not.  */\n \t  if (GET_CODE (reg) == SUBREG)\n \t    ref_flags |= DF_REF_PARTIAL;\n@@ -2935,16 +2935,16 @@ df_ref_record (enum df_ref_class cl,\n \n       for (i = regno; i < endregno; i++)\n \t{\n-\t  ref = df_ref_create_structure (cl, collection_rec, regno_reg_rtx[i], loc, \n-\t\t\t\t\t bb, insn_info, ref_type, ref_flags, \n+\t  ref = df_ref_create_structure (cl, collection_rec, regno_reg_rtx[i], loc,\n+\t\t\t\t\t bb, insn_info, ref_type, ref_flags,\n \t\t\t\t\t width, offset, mode);\n \n           gcc_assert (ORIGINAL_REGNO (DF_REF_REG (ref)) == i);\n \t}\n     }\n   else\n     {\n-      df_ref_create_structure (cl, collection_rec, reg, loc, bb, insn_info, \n+      df_ref_create_structure (cl, collection_rec, reg, loc, bb, insn_info,\n \t\t\t       ref_type, ref_flags, width, offset, mode);\n     }\n }\n@@ -3003,8 +3003,8 @@ df_def_record_1 (struct df_collection_rec *collection_rec,\n \t  if (GET_CODE (temp) == EXPR_LIST || GET_CODE (temp) == CLOBBER\n \t      || GET_CODE (temp) == SET)\n \t    df_def_record_1 (collection_rec,\n-                             temp, bb, insn_info, \n-\t\t\t     GET_CODE (temp) == CLOBBER \n+                             temp, bb, insn_info,\n+\t\t\t     GET_CODE (temp) == CLOBBER\n \t\t\t     ? flags | DF_REF_MUST_CLOBBER : flags);\n \t}\n       return;\n@@ -3021,7 +3021,7 @@ df_def_record_1 (struct df_collection_rec *collection_rec,\n   if (GET_CODE (dst) == ZERO_EXTRACT)\n     {\n       flags |= DF_REF_READ_WRITE | DF_REF_PARTIAL | DF_REF_ZERO_EXTRACT;\n-      \n+\n       if (CONST_INT_P (XEXP (dst, 1))\n \t  && CONST_INT_P (XEXP (dst, 2)))\n \t{\n@@ -3038,15 +3038,15 @@ df_def_record_1 (struct df_collection_rec *collection_rec,\n   /* At this point if we do not have a reg or a subreg, just return.  */\n   if (REG_P (dst))\n     {\n-      df_ref_record (cl, collection_rec, \n-\t\t     dst, loc, bb, insn_info, DF_REF_REG_DEF, flags, \n+      df_ref_record (cl, collection_rec,\n+\t\t     dst, loc, bb, insn_info, DF_REF_REG_DEF, flags,\n \t\t     width, offset, mode);\n \n       /* We want to keep sp alive everywhere - by making all\n \t writes to sp also use of sp. */\n       if (REGNO (dst) == STACK_POINTER_REGNUM)\n \tdf_ref_record (DF_REF_BASE, collection_rec,\n-\t\t       dst, NULL, bb, insn_info, DF_REF_REG_USE, flags, \n+\t\t       dst, NULL, bb, insn_info, DF_REF_REG_USE, flags,\n \t\t       width, offset, mode);\n     }\n   else if (GET_CODE (dst) == SUBREG && REG_P (SUBREG_REG (dst)))\n@@ -3056,8 +3056,8 @@ df_def_record_1 (struct df_collection_rec *collection_rec,\n \n       flags |= DF_REF_SUBREG;\n \n-      df_ref_record (cl, collection_rec, \n-\t\t     dst, loc, bb, insn_info, DF_REF_REG_DEF, flags, \n+      df_ref_record (cl, collection_rec,\n+\t\t     dst, loc, bb, insn_info, DF_REF_REG_DEF, flags,\n \t\t     width, offset, mode);\n     }\n }\n@@ -3066,7 +3066,7 @@ df_def_record_1 (struct df_collection_rec *collection_rec,\n /* Process all the registers defined in the pattern rtx, X.  */\n \n static void\n-df_defs_record (struct df_collection_rec *collection_rec, \n+df_defs_record (struct df_collection_rec *collection_rec,\n                 rtx x, basic_block bb, struct df_insn_info *insn_info,\n \t\tint flags)\n {\n@@ -3081,7 +3081,7 @@ df_defs_record (struct df_collection_rec *collection_rec,\n     }\n   else if (code == COND_EXEC)\n     {\n-      df_defs_record (collection_rec, COND_EXEC_CODE (x), \n+      df_defs_record (collection_rec, COND_EXEC_CODE (x),\n \t\t      bb, insn_info, DF_REF_CONDITIONAL);\n     }\n   else if (code == PARALLEL)\n@@ -3095,7 +3095,7 @@ df_defs_record (struct df_collection_rec *collection_rec,\n }\n \n \n-/* Process all the registers used in the rtx at address LOC.  \n+/* Process all the registers used in the rtx at address LOC.\n \n    If the REF_FLAGS field contain DF_REF_SIGN_EXTRACT or\n    DF_REF_ZERO_EXTRACT.  WIDTH, OFFSET and MODE are used to access the\n@@ -3147,8 +3147,8 @@ df_uses_record (enum df_ref_class cl, struct df_collection_rec *collection_rec,\n \n     case MEM:\n       df_uses_record (cl, collection_rec,\n-\t\t      &XEXP (x, 0), DF_REF_REG_MEM_LOAD, \n-\t\t      bb, insn_info, flags & DF_REF_IN_NOTE, \n+\t\t      &XEXP (x, 0), DF_REF_REG_MEM_LOAD,\n+\t\t      bb, insn_info, flags & DF_REF_IN_NOTE,\n \t\t      width, offset, mode);\n       return;\n \n@@ -3159,16 +3159,16 @@ df_uses_record (enum df_ref_class cl, struct df_collection_rec *collection_rec,\n       if (!REG_P (SUBREG_REG (x)))\n \t{\n \t  loc = &SUBREG_REG (x);\n-\t  df_uses_record (cl, collection_rec, loc, ref_type, bb, insn_info, flags, \n+\t  df_uses_record (cl, collection_rec, loc, ref_type, bb, insn_info, flags,\n \t\t\t  width, offset, mode);\n \t  return;\n \t}\n       /* ... Fall through ...  */\n \n     case REG:\n-      df_ref_record (cl, collection_rec, \n+      df_ref_record (cl, collection_rec,\n \t\t     x, loc, bb, insn_info,\n-\t\t     ref_type, flags, \n+\t\t     ref_type, flags,\n \t\t     width, offset, mode);\n       return;\n \n@@ -3191,7 +3191,7 @@ df_uses_record (enum df_ref_class cl, struct df_collection_rec *collection_rec,\n \t      flags |= DF_REF_SIGN_EXTRACT;\n \n \t    df_uses_record (DF_REF_EXTRACT, collection_rec,\n-\t\t\t    &XEXP (x, 0), ref_type, bb, insn_info, flags, \n+\t\t\t    &XEXP (x, 0), ref_type, bb, insn_info, flags,\n \t\t\t    width, offset, mode);\n \t    return;\n \t  }\n@@ -3203,17 +3203,17 @@ df_uses_record (enum df_ref_class cl, struct df_collection_rec *collection_rec,\n \trtx dst = SET_DEST (x);\n \tgcc_assert (!(flags & DF_REF_IN_NOTE));\n \tdf_uses_record (cl, collection_rec,\n-\t\t\t&SET_SRC (x), DF_REF_REG_USE, bb, insn_info, flags, \n+\t\t\t&SET_SRC (x), DF_REF_REG_USE, bb, insn_info, flags,\n \t\t\twidth, offset, mode);\n \n \tswitch (GET_CODE (dst))\n \t  {\n \t    case SUBREG:\n \t      if (df_read_modify_subreg_p (dst))\n \t\t{\n-\t\t  df_uses_record (cl, collection_rec, &SUBREG_REG (dst), \n-\t\t\t\t  DF_REF_REG_USE, bb, insn_info, \n-\t\t\t\t  flags | DF_REF_READ_WRITE | DF_REF_SUBREG, \n+\t\t  df_uses_record (cl, collection_rec, &SUBREG_REG (dst),\n+\t\t\t\t  DF_REF_REG_USE, bb, insn_info,\n+\t\t\t\t  flags | DF_REF_READ_WRITE | DF_REF_SUBREG,\n \t\t\t\t  width, offset, mode);\n \t\t  break;\n \t\t}\n@@ -3226,7 +3226,7 @@ df_uses_record (enum df_ref_class cl, struct df_collection_rec *collection_rec,\n \t\tbreak;\n \t    case MEM:\n \t      df_uses_record (cl, collection_rec, &XEXP (dst, 0),\n-\t\t\t      DF_REF_REG_MEM_STORE, bb, insn_info, flags, \n+\t\t\t      DF_REF_REG_MEM_STORE, bb, insn_info, flags,\n \t\t\t      width, offset, mode);\n \t      break;\n \t    case STRICT_LOW_PART:\n@@ -3235,10 +3235,10 @@ df_uses_record (enum df_ref_class cl, struct df_collection_rec *collection_rec,\n \t\t/* A strict_low_part uses the whole REG and not just the\n \t\t SUBREG.  */\n \t\tdst = XEXP (dst, 0);\n-\t\tdf_uses_record (cl, collection_rec, \n-\t\t\t\t(GET_CODE (dst) == SUBREG) ? &SUBREG_REG (dst) : temp, \n+\t\tdf_uses_record (cl, collection_rec,\n+\t\t\t\t(GET_CODE (dst) == SUBREG) ? &SUBREG_REG (dst) : temp,\n \t\t\t\tDF_REF_REG_USE, bb, insn_info,\n-\t\t\t\tDF_REF_READ_WRITE | DF_REF_STRICT_LOW_PART, \n+\t\t\t\tDF_REF_READ_WRITE | DF_REF_STRICT_LOW_PART,\n \t\t\t\twidth, offset, mode);\n \t      }\n \t      break;\n@@ -3253,7 +3253,7 @@ df_uses_record (enum df_ref_class cl, struct df_collection_rec *collection_rec,\n \t\t    if (GET_CODE (XEXP (dst,0)) == MEM)\n \t\t      {\n \t\t\t/* Handle the case of zero_extract(mem(...)) in the set dest.\n-\t\t\t   This special case is allowed only if the mem is a single byte and \n+\t\t\t   This special case is allowed only if the mem is a single byte and\n \t\t\t   is useful to set a bitfield in memory.  */\n \t\t\tdf_uses_record (DF_REF_EXTRACT, collection_rec, &XEXP (XEXP (dst,0), 0),\n \t\t\t\t\tDF_REF_REG_MEM_STORE, bb, insn_info,\n@@ -3262,23 +3262,23 @@ df_uses_record (enum df_ref_class cl, struct df_collection_rec *collection_rec,\n \t\t      }\n \t\t    else\n \t\t      {\n-\t\t\tdf_uses_record (DF_REF_EXTRACT, collection_rec, &XEXP (dst, 0), \n-\t\t\t\t\tDF_REF_REG_USE, bb, insn_info, \n-\t\t\t\t\tDF_REF_READ_WRITE | DF_REF_ZERO_EXTRACT, \n+\t\t\tdf_uses_record (DF_REF_EXTRACT, collection_rec, &XEXP (dst, 0),\n+\t\t\t\t\tDF_REF_REG_USE, bb, insn_info,\n+\t\t\t\t\tDF_REF_READ_WRITE | DF_REF_ZERO_EXTRACT,\n \t\t\t\t\twidth, offset, mode);\n \t\t      }\n \t\t  }\n-\t\telse \n+\t\telse\n \t\t  {\n-\t\t    df_uses_record (cl, collection_rec, &XEXP (dst, 1), \n-\t\t\t\t    DF_REF_REG_USE, bb, insn_info, flags, \n+\t\t    df_uses_record (cl, collection_rec, &XEXP (dst, 1),\n+\t\t\t\t    DF_REF_REG_USE, bb, insn_info, flags,\n \t\t\t\t    width, offset, mode);\n-\t\t    df_uses_record (cl, collection_rec, &XEXP (dst, 2), \n-\t\t\t\t    DF_REF_REG_USE, bb, insn_info, flags, \n+\t\t    df_uses_record (cl, collection_rec, &XEXP (dst, 2),\n+\t\t\t\t    DF_REF_REG_USE, bb, insn_info, flags,\n \t\t\t\t    width, offset, mode);\n-\t\t    df_uses_record (cl, collection_rec, &XEXP (dst, 0), \n-\t\t\t\t    DF_REF_REG_USE, bb, insn_info, \n-\t\t\t\t    DF_REF_READ_WRITE | DF_REF_ZERO_EXTRACT, \n+\t\t    df_uses_record (cl, collection_rec, &XEXP (dst, 0),\n+\t\t\t\t    DF_REF_REG_USE, bb, insn_info,\n+\t\t\t\t    DF_REF_READ_WRITE | DF_REF_ZERO_EXTRACT,\n \t\t\t\t    width, offset, mode);\n \t\t  }\n \n@@ -3331,7 +3331,7 @@ df_uses_record (enum df_ref_class cl, struct df_collection_rec *collection_rec,\n \n \t    for (j = 0; j < ASM_OPERANDS_INPUT_LENGTH (x); j++)\n \t      df_uses_record (cl, collection_rec, &ASM_OPERANDS_INPUT (x, j),\n-\t\t\t      DF_REF_REG_USE, bb, insn_info, flags, \n+\t\t\t      DF_REF_REG_USE, bb, insn_info, flags,\n \t\t\t      width, offset, mode);\n \t    return;\n \t  }\n@@ -3354,9 +3354,9 @@ df_uses_record (enum df_ref_class cl, struct df_collection_rec *collection_rec,\n       gcc_assert (!DEBUG_INSN_P (insn_info->insn));\n       /* Catch the def of the register being modified.  */\n       df_ref_record (cl, collection_rec, XEXP (x, 0), &XEXP (x, 0),\n-\t\t     bb, insn_info, \n+\t\t     bb, insn_info,\n \t\t     DF_REF_REG_DEF,\n-                     flags | DF_REF_READ_WRITE | DF_REF_PRE_POST_MODIFY, \n+                     flags | DF_REF_READ_WRITE | DF_REF_PRE_POST_MODIFY,\n \t\t     width, offset, mode);\n \n       /* ... Fall through to handle uses ...  */\n@@ -3380,17 +3380,17 @@ df_uses_record (enum df_ref_class cl, struct df_collection_rec *collection_rec,\n \t\tloc = &XEXP (x, 0);\n \t\tgoto retry;\n \t      }\n-\t    df_uses_record (cl, collection_rec, &XEXP (x, i), ref_type, \n-\t\t\t    bb, insn_info, flags, \n+\t    df_uses_record (cl, collection_rec, &XEXP (x, i), ref_type,\n+\t\t\t    bb, insn_info, flags,\n \t\t\t    width, offset, mode);\n \t  }\n \telse if (fmt[i] == 'E')\n \t  {\n \t    int j;\n \t    for (j = 0; j < XVECLEN (x, i); j++)\n \t      df_uses_record (cl, collection_rec,\n-\t\t\t      &XVECEXP (x, i, j), ref_type, \n-\t\t\t      bb, insn_info, flags, \n+\t\t\t      &XVECEXP (x, i, j), ref_type,\n+\t\t\t      bb, insn_info, flags,\n \t\t\t      width, offset, mode);\n \t  }\n       }\n@@ -3439,7 +3439,7 @@ df_get_conditional_uses (struct df_collection_rec *collection_rec)\n \n static void\n df_get_call_refs (struct df_collection_rec * collection_rec,\n-                  basic_block bb, \n+                  basic_block bb,\n                   struct df_insn_info *insn_info,\n                   int flags)\n {\n@@ -3485,7 +3485,7 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n   /* The stack ptr is used (honorarily) by a CALL insn.  */\n   df_ref_record (DF_REF_BASE, collection_rec, regno_reg_rtx[STACK_POINTER_REGNUM],\n \t\t NULL, bb, insn_info, DF_REF_REG_USE,\n-\t\t DF_REF_CALL_STACK_USAGE | flags, \n+\t\t DF_REF_CALL_STACK_USAGE | flags,\n \t\t -1, -1, VOIDmode);\n \n   /* Calls may also reference any of the global registers,\n@@ -3508,11 +3508,11 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n \t  && (!bitmap_bit_p (defs_generated, ui))\n \t  && (!is_sibling_call\n \t      || !bitmap_bit_p (df->exit_block_uses, ui)\n-\t      || refers_to_regno_p (ui, ui+1, \n+\t      || refers_to_regno_p (ui, ui+1,\n \t\t\t\t    crtl->return_rtx, NULL)))\n-        df_ref_record (DF_REF_BASE, collection_rec, regno_reg_rtx[ui], \n+        df_ref_record (DF_REF_BASE, collection_rec, regno_reg_rtx[ui],\n \t\t       NULL, bb, insn_info, DF_REF_REG_DEF,\n-\t\t       DF_REF_MAY_CLOBBER | flags, \n+\t\t       DF_REF_MAY_CLOBBER | flags,\n \t\t       -1, -1, VOIDmode);\n     }\n \n@@ -3526,8 +3526,8 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n    and reg chains. */\n \n static void\n-df_insn_refs_collect (struct df_collection_rec* collection_rec, \n-\t\t      basic_block bb, struct df_insn_info *insn_info) \n+df_insn_refs_collect (struct df_collection_rec* collection_rec,\n+\t\t      basic_block bb, struct df_insn_info *insn_info)\n {\n   rtx note;\n   bool is_cond_exec = (GET_CODE (PATTERN (insn_info->insn)) == COND_EXEC);\n@@ -3572,12 +3572,12 @@ df_insn_refs_collect (struct df_collection_rec* collection_rec,\n     }\n \n   if (CALL_P (insn_info->insn))\n-    df_get_call_refs (collection_rec, bb, insn_info, \n+    df_get_call_refs (collection_rec, bb, insn_info,\n \t\t      (is_cond_exec) ? DF_REF_CONDITIONAL : 0);\n \n   /* Record the register uses.  */\n   df_uses_record (DF_REF_REGULAR, collection_rec,\n-\t\t  &PATTERN (insn_info->insn), DF_REF_REG_USE, bb, insn_info, 0, \n+\t\t  &PATTERN (insn_info->insn), DF_REF_REG_USE, bb, insn_info, 0,\n \t\t  -1, -1, VOIDmode);\n \n   /* DF_REF_CONDITIONAL needs corresponding USES. */\n@@ -3660,14 +3660,14 @@ df_bb_refs_collect (struct df_collection_rec *collection_rec, basic_block bb)\n   if (bb->flags & BB_NON_LOCAL_GOTO_TARGET)\n     df_ref_record (DF_REF_ARTIFICIAL, collection_rec, hard_frame_pointer_rtx, NULL,\n \t\t   bb, NULL, DF_REF_REG_DEF, DF_REF_AT_TOP, -1, -1, VOIDmode);\n- \n+\n   /* Add the artificial uses.  */\n   if (bb->index >= NUM_FIXED_BLOCKS)\n     {\n       bitmap_iterator bi;\n       unsigned int regno;\n-      bitmap au = bb_has_eh_pred (bb) \n-\t? df->eh_block_artificial_uses \n+      bitmap au = bb_has_eh_pred (bb)\n+\t? df->eh_block_artificial_uses\n \t: df->regular_block_artificial_uses;\n \n       EXECUTE_IF_SET_IN_BITMAP (au, 0, regno, bi)\n@@ -3697,7 +3697,7 @@ df_bb_refs_record (int bb_index, bool scan_insns)\n \n   bb_info = df_scan_get_bb_info (bb_index);\n \n-  /* Need to make sure that there is a record in the basic block info. */  \n+  /* Need to make sure that there is a record in the basic block info. */\n   if (!bb_info)\n     {\n       bb_info = (struct df_scan_bb_info *) pool_alloc (df_scan->block_pool);\n@@ -3769,7 +3769,7 @@ df_get_regular_block_artificial_uses (bitmap regular_block_artificial_uses)\n       /* Any reference to any pseudo before reload is a potential\n \t reference of the frame pointer.  */\n       bitmap_set_bit (regular_block_artificial_uses, FRAME_POINTER_REGNUM);\n-      \n+\n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n       bitmap_set_bit (regular_block_artificial_uses, HARD_FRAME_POINTER_REGNUM);\n #endif\n@@ -3780,7 +3780,7 @@ df_get_regular_block_artificial_uses (bitmap regular_block_artificial_uses)\n       if (fixed_regs[ARG_POINTER_REGNUM])\n \tbitmap_set_bit (regular_block_artificial_uses, ARG_POINTER_REGNUM);\n #endif\n-      \n+\n       /* Any constant, or pseudo with constant equivalences, may\n \t require reloading from memory using the pic register.  */\n       if ((unsigned) PIC_OFFSET_TABLE_REGNUM != INVALID_REGNUM\n@@ -3880,7 +3880,7 @@ df_get_entry_block_def_set (bitmap entry_block_defs)\n \tbitmap_set_bit (entry_block_defs, i);\n #endif\n     }\n-      \n+\n   /* The always important stack pointer.  */\n   bitmap_set_bit (entry_block_defs, STACK_POINTER_REGNUM);\n \n@@ -3926,7 +3926,7 @@ df_get_entry_block_def_set (bitmap entry_block_defs)\n       if (fixed_regs[ARG_POINTER_REGNUM])\n \tbitmap_set_bit (entry_block_defs, ARG_POINTER_REGNUM);\n #endif\n-\t  \n+\n #ifdef PIC_OFFSET_TABLE_REGNUM\n       /* Any constant, or pseudo with constant equivalences, may\n \t require reloading from memory using the pic register.  */\n@@ -3940,26 +3940,26 @@ df_get_entry_block_def_set (bitmap entry_block_defs)\n   if (REG_P (INCOMING_RETURN_ADDR_RTX))\n     bitmap_set_bit (entry_block_defs, REGNO (INCOMING_RETURN_ADDR_RTX));\n #endif\n-            \n+\n   targetm.live_on_entry (entry_block_defs);\n }\n \n \n /* Return the (conservative) set of hard registers that are defined on\n-   entry to the function.  \n-   It uses df->entry_block_defs to determine which register \n+   entry to the function.\n+   It uses df->entry_block_defs to determine which register\n    reference to include.  */\n \n static void\n-df_entry_block_defs_collect (struct df_collection_rec *collection_rec, \n+df_entry_block_defs_collect (struct df_collection_rec *collection_rec,\n \t\t\t     bitmap entry_block_defs)\n {\n-  unsigned int i; \n+  unsigned int i;\n   bitmap_iterator bi;\n \n   EXECUTE_IF_SET_IN_BITMAP (entry_block_defs, 0, i, bi)\n     {\n-      df_ref_record (DF_REF_ARTIFICIAL, collection_rec, regno_reg_rtx[i], NULL, \n+      df_ref_record (DF_REF_ARTIFICIAL, collection_rec, regno_reg_rtx[i], NULL,\n \t\t     ENTRY_BLOCK_PTR, NULL, DF_REF_REG_DEF, 0, -1, -1,\n \t\t     VOIDmode);\n     }\n@@ -4028,17 +4028,17 @@ df_update_entry_block_defs (void)\n static void\n df_get_exit_block_use_set (bitmap exit_block_uses)\n {\n-  unsigned int i; \n+  unsigned int i;\n \n   bitmap_clear (exit_block_uses);\n \n   /* Stack pointer is always live at the exit.  */\n   bitmap_set_bit (exit_block_uses, STACK_POINTER_REGNUM);\n-  \n+\n   /* Mark the frame pointer if needed at the end of the function.\n      If we end up eliminating it, it will be removed from the live\n      list of each basic block by reload.  */\n-  \n+\n   if ((!reload_completed) || frame_pointer_needed)\n     {\n       bitmap_set_bit (exit_block_uses, FRAME_POINTER_REGNUM);\n@@ -4057,14 +4057,14 @@ df_get_exit_block_use_set (bitmap exit_block_uses)\n       && fixed_regs[PIC_OFFSET_TABLE_REGNUM])\n     bitmap_set_bit (exit_block_uses, PIC_OFFSET_TABLE_REGNUM);\n #endif\n-  \n+\n   /* Mark all global registers, and all registers used by the\n      epilogue as being live at the end of the function since they\n      may be referenced by our caller.  */\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if (global_regs[i] || EPILOGUE_USES (i))\n       bitmap_set_bit (exit_block_uses, i);\n-  \n+\n   if (HAVE_epilogue && epilogue_completed)\n     {\n       /* Mark all call-saved registers that we actually used.  */\n@@ -4073,7 +4073,7 @@ df_get_exit_block_use_set (bitmap exit_block_uses)\n \t    && !TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n \t  bitmap_set_bit (exit_block_uses, i);\n     }\n-  \n+\n #ifdef EH_RETURN_DATA_REGNO\n   /* Mark the registers that will contain data for the handler.  */\n   if (reload_completed && crtl->calls_eh_return)\n@@ -4104,20 +4104,20 @@ df_get_exit_block_use_set (bitmap exit_block_uses)\n       if (tmp && REG_P (tmp))\n \tdf_mark_reg (tmp, exit_block_uses);\n     }\n-#endif \n+#endif\n \n   /* Mark function return value.  */\n   diddle_return_value (df_mark_reg, (void*) exit_block_uses);\n }\n \n \n-/* Return the refs of hard registers that are used in the exit block.  \n+/* Return the refs of hard registers that are used in the exit block.\n    It uses df->exit_block_uses to determine register to include.  */\n \n static void\n df_exit_block_uses_collect (struct df_collection_rec *collection_rec, bitmap exit_block_uses)\n {\n-  unsigned int i; \n+  unsigned int i;\n   bitmap_iterator bi;\n \n   EXECUTE_IF_SET_IN_BITMAP (exit_block_uses, 0, i, bi)\n@@ -4127,7 +4127,7 @@ df_exit_block_uses_collect (struct df_collection_rec *collection_rec, bitmap exi\n #if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n   /* It is deliberate that this is not put in the exit block uses but\n      I do not know why.  */\n-  if (reload_completed \n+  if (reload_completed\n       && !bitmap_bit_p (exit_block_uses, ARG_POINTER_REGNUM)\n       && bb_has_eh_pred (EXIT_BLOCK_PTR)\n       && fixed_regs[ARG_POINTER_REGNUM])\n@@ -4139,7 +4139,7 @@ df_exit_block_uses_collect (struct df_collection_rec *collection_rec, bitmap exi\n }\n \n \n-/* Record the set of hard registers that are used in the exit block.  \n+/* Record the set of hard registers that are used in the exit block.\n    It uses df->exit_block_uses to determine which bit to include.  */\n \n static void\n@@ -4199,7 +4199,7 @@ static bool initialized = false;\n \n /* Initialize some platform specific structures.  */\n \n-void \n+void\n df_hard_reg_init (void)\n {\n #ifdef ELIMINABLE_REGS\n@@ -4212,22 +4212,22 @@ df_hard_reg_init (void)\n   /* Record which registers will be eliminated.  We use this in\n      mark_used_regs.  */\n   CLEAR_HARD_REG_SET (elim_reg_set);\n-  \n+\n #ifdef ELIMINABLE_REGS\n   for (i = 0; i < (int) ARRAY_SIZE (eliminables); i++)\n     SET_HARD_REG_BIT (elim_reg_set, eliminables[i].from);\n #else\n   SET_HARD_REG_BIT (elim_reg_set, FRAME_POINTER_REGNUM);\n #endif\n-  \n+\n   initialized = true;\n }\n \n \n /* Recompute the parts of scanning that are based on regs_ever_live\n-   because something changed in that array.  */ \n+   because something changed in that array.  */\n \n-void \n+void\n df_update_entry_exit_and_calls (void)\n {\n   basic_block bb;\n@@ -4237,7 +4237,7 @@ df_update_entry_exit_and_calls (void)\n \n   /* The call insns need to be rescanned because there may be changes\n      in the set of registers clobbered across the call.  */\n-  FOR_EACH_BB (bb) \n+  FOR_EACH_BB (bb)\n     {\n       rtx insn;\n       FOR_BB_INSNS (bb, insn)\n@@ -4254,7 +4254,7 @@ df_update_entry_exit_and_calls (void)\n    this array.  See the comment in df.h for df->hard_regs_live_count\n    for the conditions that this array is set. */\n \n-bool \n+bool\n df_hard_reg_used_p (unsigned int reg)\n {\n   gcc_assert (df);\n@@ -4279,7 +4279,7 @@ df_hard_reg_used_count (unsigned int reg)\n \n /* Get the value of regs_ever_live[REGNO].  */\n \n-bool \n+bool\n df_regs_ever_live_p (unsigned int regno)\n {\n   return regs_ever_live[regno];\n@@ -4289,7 +4289,7 @@ df_regs_ever_live_p (unsigned int regno)\n /* Set regs_ever_live[REGNO] to VALUE.  If this cause regs_ever_live\n    to change, schedule that change for the next update.  */\n \n-void \n+void\n df_set_regs_ever_live (unsigned int regno, bool value)\n {\n   if (regs_ever_live[regno] == value)\n@@ -4309,7 +4309,7 @@ df_compute_regs_ever_live (bool reset)\n {\n   unsigned int i;\n   bool changed = df->redo_entry_and_exit;\n-  \n+\n   if (reset)\n     memset (regs_ever_live, 0, sizeof (regs_ever_live));\n \n@@ -4342,10 +4342,10 @@ df_compute_regs_ever_live (bool reset)\n \n \n /* Mark all refs in the reg chain.  Verify that all of the registers\n-are in the correct chain.  */ \n+are in the correct chain.  */\n \n static unsigned int\n-df_reg_chain_mark (df_ref refs, unsigned int regno, \n+df_reg_chain_mark (df_ref refs, unsigned int regno,\n \t\t   bool is_def, bool is_eq_use)\n {\n   unsigned int count = 0;\n@@ -4380,7 +4380,7 @@ df_reg_chain_mark (df_ref refs, unsigned int regno,\n }\n \n \n-/* Verify that all of the registers in the chain are unmarked.  */ \n+/* Verify that all of the registers in the chain are unmarked.  */\n \n static void\n df_reg_chain_verify_unmarked (df_ref refs)\n@@ -4461,7 +4461,7 @@ df_mws_verify (VEC(df_mw_hardreg_ptr,stack) *new_rec,\n \n /* Return true if the existing insn refs information is complete and\n    correct. Otherwise (i.e. if there's any missing or extra refs),\n-   return the correct df_ref chain in REFS_RETURN.  \n+   return the correct df_ref chain in REFS_RETURN.\n \n    If ABORT_IF_FAIL, leave the refs that are verified (already in the\n    ref chain) as DF_REF_MARKED(). If it's false, then it's a per-insn\n@@ -4472,7 +4472,7 @@ df_mws_verify (VEC(df_mw_hardreg_ptr,stack) *new_rec,\n \n static bool\n df_insn_refs_verify (struct df_collection_rec *collection_rec,\n-\t\t     basic_block bb, \n+\t\t     basic_block bb,\n                      rtx insn,\n \t\t     bool abort_if_fail)\n {\n@@ -4487,19 +4487,19 @@ df_insn_refs_verify (struct df_collection_rec *collection_rec,\n       /* The insn_rec was created but it was never filled out.  */\n       if (abort_if_fail)\n \tgcc_assert (0);\n-      else \n+      else\n \treturn false;\n     }\n \n   /* Unfortunately we cannot opt out early if one of these is not\n      right because the marks will not get cleared.  */\n-  ret1 = df_refs_verify (collection_rec->def_vec, DF_INSN_UID_DEFS (uid), \n+  ret1 = df_refs_verify (collection_rec->def_vec, DF_INSN_UID_DEFS (uid),\n \t\t\t abort_if_fail);\n-  ret2 = df_refs_verify (collection_rec->use_vec, DF_INSN_UID_USES (uid), \n+  ret2 = df_refs_verify (collection_rec->use_vec, DF_INSN_UID_USES (uid),\n \t\t\t abort_if_fail);\n-  ret3 = df_refs_verify (collection_rec->eq_use_vec, DF_INSN_UID_EQ_USES (uid), \n+  ret3 = df_refs_verify (collection_rec->eq_use_vec, DF_INSN_UID_EQ_USES (uid),\n \t\t\t abort_if_fail);\n-  ret4 = df_mws_verify (collection_rec->mw_vec, DF_INSN_UID_MWS (uid), \n+  ret4 = df_mws_verify (collection_rec->mw_vec, DF_INSN_UID_MWS (uid),\n \t\t       abort_if_fail);\n   return (ret1 && ret2 && ret3 && ret4);\n }\n@@ -4515,7 +4515,7 @@ df_bb_verify (basic_block bb)\n   rtx insn;\n   struct df_scan_bb_info *bb_info = df_scan_get_bb_info (bb->index);\n   struct df_collection_rec collection_rec;\n-  \n+\n   memset (&collection_rec, 0, sizeof (struct df_collection_rec));\n   collection_rec.def_vec = VEC_alloc (df_ref, stack, 128);\n   collection_rec.use_vec = VEC_alloc (df_ref, stack, 32);\n@@ -4538,12 +4538,12 @@ df_bb_verify (basic_block bb)\n   df_refs_verify (collection_rec.def_vec, df_get_artificial_defs (bb->index), true);\n   df_refs_verify (collection_rec.use_vec, df_get_artificial_uses (bb->index), true);\n   df_free_collection_rec (&collection_rec);\n-  \n+\n   return true;\n }\n \n \n-/* Returns true if the entry block has correct and complete df_ref set.  \n+/* Returns true if the entry block has correct and complete df_ref set.\n    If not it either aborts if ABORT_IF_FAIL is true or returns false.  */\n \n static bool\n@@ -4572,7 +4572,7 @@ df_entry_block_bitmap_verify (bool abort_if_fail)\n }\n \n \n-/* Returns true if the exit block has correct and complete df_ref set.  \n+/* Returns true if the exit block has correct and complete df_ref set.\n    If not it either aborts if ABORT_IF_FAIL is true or returns false. */\n \n static bool\n@@ -4620,11 +4620,11 @@ df_scan_verify (void)\n   /* (1) All of the refs are marked by going thru the reg chains.  */\n   for (i = 0; i < DF_REG_SIZE (df); i++)\n     {\n-      gcc_assert (df_reg_chain_mark (DF_REG_DEF_CHAIN (i), i, true, false) \n+      gcc_assert (df_reg_chain_mark (DF_REG_DEF_CHAIN (i), i, true, false)\n \t\t  == DF_REG_DEF_COUNT(i));\n-      gcc_assert (df_reg_chain_mark (DF_REG_USE_CHAIN (i), i, false, false) \n+      gcc_assert (df_reg_chain_mark (DF_REG_USE_CHAIN (i), i, false, false)\n \t\t  == DF_REG_USE_COUNT(i));\n-      gcc_assert (df_reg_chain_mark (DF_REG_EQ_USE_CHAIN (i), i, false, true) \n+      gcc_assert (df_reg_chain_mark (DF_REG_EQ_USE_CHAIN (i), i, false, true)\n \t\t  == DF_REG_EQ_USE_COUNT(i));\n     }\n \n@@ -4637,13 +4637,13 @@ df_scan_verify (void)\n   df_get_regular_block_artificial_uses (regular_block_artificial_uses);\n   df_get_eh_block_artificial_uses (eh_block_artificial_uses);\n \n-  bitmap_ior_into (eh_block_artificial_uses, \n+  bitmap_ior_into (eh_block_artificial_uses,\n \t\t   regular_block_artificial_uses);\n \n   /* Check artificial_uses bitmaps didn't change. */\n-  gcc_assert (bitmap_equal_p (regular_block_artificial_uses, \n+  gcc_assert (bitmap_equal_p (regular_block_artificial_uses,\n \t\t\t      df->regular_block_artificial_uses));\n-  gcc_assert (bitmap_equal_p (eh_block_artificial_uses, \n+  gcc_assert (bitmap_equal_p (eh_block_artificial_uses,\n \t\t\t      df->eh_block_artificial_uses));\n \n   BITMAP_FREE (regular_block_artificial_uses);\n@@ -4653,7 +4653,7 @@ df_scan_verify (void)\n      the refs are verified in df_bb_verify.  */\n   df_entry_block_bitmap_verify (true);\n   df_exit_block_bitmap_verify (true);\n-    \n+\n   /* (3) All of the insns in all of the blocks are traversed and the\n      marks are cleared both in the artificial refs attached to the\n      blocks and the real refs inside the insns.  It is a failure to"}, {"sha": "be37fa412a81bde11621b71f2fc39a00d657fefc", "filename": "gcc/df.h", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -2,7 +2,7 @@\n    for GNU compiler.  This is part of flow optimization.\n    Copyright (C) 1999, 2000, 2001, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n-   Originally contributed by Michael P. Hayes \n+   Originally contributed by Michael P. Hayes\n              (m.hayes@elec.canterbury.ac.nz, mhayes@redhat.com)\n    Major rewrite contributed by Danny Berlin (dberlin@dberlin.org)\n              and Kenneth Zadeck (zadeck@naturalbridge.com).\n@@ -38,14 +38,14 @@ struct df_link;\n struct df_insn_info;\n union df_ref_d;\n \n-/* Data flow problems.  All problems must have a unique id here.  */ \n+/* Data flow problems.  All problems must have a unique id here.  */\n \n /* Scanning is not really a dataflow problem, but it is useful to have\n    the basic block functions in the vector so that things get done in\n    a uniform manner.  The last four problems can be added or deleted\n    at any time are always defined (though LIVE is always there at -O2\n    or higher); the others are always there.  */\n-#define DF_SCAN    0 \n+#define DF_SCAN    0\n #define DF_LR      1      /* Live Registers backward. */\n #define DF_LIVE    2      /* Live Registers & Uninitialized Registers */\n #define DF_RD      3      /* Reaching Defs. */\n@@ -105,7 +105,7 @@ enum df_ref_flags\n     /* This flag is set if this ref is a partial use or def of the\n        associated register.  */\n     DF_REF_PARTIAL = 1 << 4,\n-    \n+\n     /* Read-modify-write refs generate both a use and a def and\n        these are marked with this flag to show that they are not\n        independent.  */\n@@ -120,7 +120,7 @@ enum df_ref_flags\n \n     /* This flag is set if this ref, generally a def, is a real\n        clobber. This is not currently set for registers live across a\n-       call because that clobbering may or may not happen.  \n+       call because that clobbering may or may not happen.\n \n        Most of the uses of this are with sets that have a\n        GET_CODE(..)==CLOBBER.  Note that this is set even if the\n@@ -133,7 +133,7 @@ enum df_ref_flags\n     /* If the ref has one of the following two flags set, then the\n        struct df_ref can be cast to struct df_ref_extract to access\n        the width and offset fields.  */\n- \n+\n     /* This flag is set if the ref contains a SIGN_EXTRACT.  */\n     DF_REF_SIGN_EXTRACT = 1 << 8,\n \n@@ -165,14 +165,14 @@ enum df_ref_flags\n /* The possible ordering of refs within the df_ref_info.  */\n enum df_ref_order\n   {\n-    /* There is not table.  */ \n+    /* There is not table.  */\n     DF_REF_ORDER_NO_TABLE,\n \n     /* There is a table of refs but it is not (or no longer) organized\n        by one of the following methods.  */\n     DF_REF_ORDER_UNORDERED,\n     DF_REF_ORDER_UNORDERED_WITH_NOTES,\n-  \n+\n     /* Organize the table by reg order, all of the refs with regno 0\n        followed by all of the refs with regno 1 ... .  Within all of\n        the regs for a particular regno, the refs are unordered.  */\n@@ -183,7 +183,7 @@ enum df_ref_order\n     DF_REF_ORDER_BY_REG_WITH_NOTES,\n \n     /* Organize the refs in insn order.  The insns are ordered within a\n-       block, and the blocks are ordered by FOR_ALL_BB.  */  \n+       block, and the blocks are ordered by FOR_ALL_BB.  */\n     DF_REF_ORDER_BY_INSN,\n \n     /* For uses, the refs within eq notes may be added for\n@@ -255,7 +255,7 @@ typedef void (*df_verify_solution_end) (void);\n struct df_problem {\n   /* The unique id of the problem.  This is used it index into\n      df->defined_problems to make accessing the problem data easy.  */\n-  unsigned int id;                        \n+  unsigned int id;\n   enum df_flow_dir dir;\t\t\t/* Dataflow direction.  */\n   df_alloc_function alloc_fun;\n   df_reset_function reset_fun;\n@@ -296,7 +296,7 @@ struct dataflow\n   unsigned int block_info_size;\n \n   /* The pool to allocate the block_info from. */\n-  alloc_pool block_pool;                \n+  alloc_pool block_pool;\n \n   /* The lr and live problems have their transfer functions recomputed\n      only if necessary.  This is possible for them because, the\n@@ -313,15 +313,15 @@ struct dataflow\n \n   /* Local flags for some of the problems. */\n   unsigned int local_flags;\n-  \n+\n   /* True if this problem of this instance has been initialized.  This\n      is used by the dumpers to keep garbage out of the dumps if, for\n      debugging a dump is produced before the first call to\n      df_analyze after a new problem is added.  */\n   bool computed;\n \n   /* True if the something has changed which invalidates the dataflow\n-     solutions.  Note that this bit is always true for all problems except \n+     solutions.  Note that this bit is always true for all problems except\n      lr and live.  */\n   bool solutions_dirty;\n \n@@ -338,7 +338,7 @@ struct dataflow\n    REG_UNUSED notes.  */\n struct df_mw_hardreg\n {\n-  rtx mw_reg;                   /* The multiword hardreg.  */ \n+  rtx mw_reg;                   /* The multiword hardreg.  */\n   /* These two bitfields are intentionally oversized, in the hope that\n      accesses to 16-bit fields will usually be quicker.  */\n   ENUM_BITFIELD(df_ref_type) type : 16;\n@@ -348,7 +348,7 @@ struct df_mw_hardreg\n   unsigned int end_regno;       /* Last word of the multi word subreg.  */\n   unsigned int mw_order;        /* Same as df_ref.ref_order.  */\n };\n- \n+\n \n /* Define a register reference structure.  One of these is allocated\n     for every register reference (use or def).  Note some register\n@@ -364,17 +364,17 @@ struct df_base_ref\n   int flags : 16;\t\t/* Various df_ref_flags.  */\n   rtx reg;\t\t\t/* The register referenced.  */\n   struct df_link *chain;\t/* Head of def-use, use-def.  */\n-  /* Pointer to the insn info of the containing instruction.  FIXME! \n+  /* Pointer to the insn info of the containing instruction.  FIXME!\n      Currently this is NULL for artificial refs but this will be used\n-     when FUDs are added.  */ \n+     when FUDs are added.  */\n   struct df_insn_info *insn_info;\n   /* For each regno, there are three chains of refs, one for the uses,\n      the eq_uses and the defs.  These chains go thru the refs\n      themselves rather than using an external structure.  */\n   union df_ref_d *next_reg;     /* Next ref with same regno and type.  */\n   union df_ref_d *prev_reg;     /* Prev ref with same regno and type.  */\n   unsigned int regno;\t\t/* The register number referenced.  */\n-  /* Location in the ref table.  This is only valid after a call to \n+  /* Location in the ref table.  This is only valid after a call to\n      df_maybe_reorganize_[use,def]_refs which is an expensive operation.  */\n   int id;\n   /* The index at which the operand was scanned in the insn.  This is\n@@ -384,7 +384,7 @@ struct df_base_ref\n \n \n /* The three types of df_refs.  Note that the df_ref_extract is an\n-   extension of the df_regular_ref, not the df_base_ref.  */  \n+   extension of the df_regular_ref, not the df_base_ref.  */\n struct df_artificial_ref\n {\n   struct df_base_ref base;\n@@ -436,14 +436,14 @@ struct df_insn_info\n   df_ref *defs;\t                /* Head of insn-def chain.  */\n   df_ref *uses;\t                /* Head of insn-use chain.  */\n   /* Head of insn-use chain for uses in REG_EQUAL/EQUIV notes.  */\n-  df_ref *eq_uses;       \n+  df_ref *eq_uses;\n   struct df_mw_hardreg **mw_hardregs;\n   /* The logical uid of the insn in the basic block.  This is valid\n      after any call to df_analyze but may rot after insns are added,\n      deleted or moved. */\n-  int luid; \n+  int luid;\n };\n- \n+\n /* These links are used for ref-ref chains.  Currently only DEF-USE and\n    USE-DEF chains can be built by DF.  */\n struct df_link\n@@ -456,11 +456,11 @@ struct df_link\n enum df_chain_flags\n {\n   /* Flags that control the building of chains.  */\n-  DF_DU_CHAIN      =  1, /* Build DU chains.  */  \n+  DF_DU_CHAIN      =  1, /* Build DU chains.  */\n   DF_UD_CHAIN      =  2  /* Build UD chains.  */\n };\n \n-enum df_changeable_flags \n+enum df_changeable_flags\n {\n   /* Scanning flags.  */\n   /* Flag to control the running of dce as a side effect of building LR.  */\n@@ -533,13 +533,13 @@ struct df\n      the problem local data without having to search the first\n      array.  */\n \n-  struct dataflow *problems_in_order[DF_LAST_PROBLEM_PLUS1]; \n-  struct dataflow *problems_by_index[DF_LAST_PROBLEM_PLUS1]; \n+  struct dataflow *problems_in_order[DF_LAST_PROBLEM_PLUS1];\n+  struct dataflow *problems_by_index[DF_LAST_PROBLEM_PLUS1];\n \n   /* If not NULL, this subset of blocks of the program to be\n      considered for analysis.  At certain times, this will contain all\n      the blocks in the function so it cannot be used as an indicator\n-     of if we are analyzing a subset.  See analyze_subset.  */ \n+     of if we are analyzing a subset.  See analyze_subset.  */\n   bitmap blocks_to_analyze;\n \n   /* The following information is really the problem data for the\n@@ -578,12 +578,12 @@ struct df\n   bitmap insns_to_delete;\n   bitmap insns_to_rescan;\n   bitmap insns_to_notes_rescan;\n-  int *postorder;                /* The current set of basic blocks \n+  int *postorder;                /* The current set of basic blocks\n                                     in reverse postorder.  */\n-  int *postorder_inverted;       /* The current set of basic blocks \n+  int *postorder_inverted;       /* The current set of basic blocks\n                                     in reverse postorder of inverted CFG.  */\n   int n_blocks;                  /* The number of blocks in reverse postorder.  */\n-  int n_blocks_inverted;         /* The number of blocks \n+  int n_blocks_inverted;         /* The number of blocks\n                                     in reverse postorder of inverted CFG.  */\n \n   /* An array [FIRST_PSEUDO_REGISTER], indexed by regno, of the number\n@@ -624,20 +624,20 @@ struct df\n \n /* Most transformations that wish to use live register analysis will\n    use these macros.  This info is the and of the lr and live sets.  */\n-#define DF_LIVE_IN(BB) (DF_LIVE_BB_INFO(BB)->in) \n-#define DF_LIVE_OUT(BB) (DF_LIVE_BB_INFO(BB)->out) \n+#define DF_LIVE_IN(BB) (DF_LIVE_BB_INFO(BB)->in)\n+#define DF_LIVE_OUT(BB) (DF_LIVE_BB_INFO(BB)->out)\n \n /* These macros are used by passes that are not tolerant of\n    uninitialized variables.  This intolerance should eventually\n    be fixed.  */\n-#define DF_LR_IN(BB) (DF_LR_BB_INFO(BB)->in) \n-#define DF_LR_OUT(BB) (DF_LR_BB_INFO(BB)->out) \n+#define DF_LR_IN(BB) (DF_LR_BB_INFO(BB)->in)\n+#define DF_LR_OUT(BB) (DF_LR_BB_INFO(BB)->out)\n \n /* These macros are used by passes that are not tolerant of\n    uninitialized variables.  This intolerance should eventually\n    be fixed.  */\n-#define DF_BYTE_LR_IN(BB) (DF_BYTE_LR_BB_INFO(BB)->in) \n-#define DF_BYTE_LR_OUT(BB) (DF_BYTE_LR_BB_INFO(BB)->out) \n+#define DF_BYTE_LR_IN(BB) (DF_BYTE_LR_BB_INFO(BB)->in)\n+#define DF_BYTE_LR_OUT(BB) (DF_BYTE_LR_BB_INFO(BB)->out)\n \n /* Macros to access the elements within the ref structure.  */\n \n@@ -674,8 +674,8 @@ struct df\n #define DF_REF_IS_REG_MARKED(REF) (DF_REF_FLAGS_IS_SET ((REF),DF_REF_REG_MARKER))\n #define DF_REF_NEXT_REG(REF) ((REF)->base.next_reg)\n #define DF_REF_PREV_REG(REF) ((REF)->base.prev_reg)\n-/* The following two macros may only be applied if one of \n-   DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT is true. */ \n+/* The following two macros may only be applied if one of\n+   DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT is true. */\n #define DF_REF_EXTRACT_WIDTH(REF) ((REF)->extract_ref.width)\n #define DF_REF_EXTRACT_OFFSET(REF) ((REF)->extract_ref.offset)\n #define DF_REF_EXTRACT_MODE(REF) ((REF)->extract_ref.mode)\n@@ -695,7 +695,7 @@ struct df\n /* Macros to get the refs out of def_info or use_info refs table.  If\n    the focus of the dataflow has been set to some subset of blocks\n    with df_set_blocks, these macros will only find the uses and defs\n-   in that subset of blocks.  \n+   in that subset of blocks.\n \n    These macros should be used with care.  The def macros are only\n    usable after a call to df_maybe_reorganize_def_refs and the use\n@@ -791,10 +791,10 @@ struct df_scan_bb_info\n \n /* Reaching definitions.  All bitmaps are indexed by the id field of\n    the ref except sparse_kill which is indexed by regno.  */\n-struct df_rd_bb_info \n+struct df_rd_bb_info\n {\n   /* Local sets to describe the basic blocks.   */\n-  bitmap kill;  \n+  bitmap kill;\n   bitmap sparse_kill;\n   bitmap gen;   /* The set of defs generated in this block.  */\n \n@@ -807,7 +807,7 @@ struct df_rd_bb_info\n /* Multiple reaching definitions.  All bitmaps are referenced by the\n    register number.  */\n \n-struct df_md_bb_info \n+struct df_md_bb_info\n {\n   /* Local sets to describe the basic blocks.  */\n   bitmap gen;    /* Partial/conditional definitions live at BB out.  */\n@@ -823,10 +823,10 @@ struct df_md_bb_info\n /* Live registers, a backwards dataflow problem.  All bitmaps are\n    referenced by the register number.  */\n \n-struct df_lr_bb_info \n+struct df_lr_bb_info\n {\n   /* Local sets to describe the basic blocks.  */\n-  bitmap def;   /* The set of registers set in this block \n+  bitmap def;   /* The set of registers set in this block\n                    - except artificial defs at the top.  */\n   bitmap use;   /* The set of registers used in this block.  */\n \n@@ -840,7 +840,7 @@ struct df_lr_bb_info\n    register number.  Anded results of the forwards and backward live\n    info.  Note that the forwards live information is not available\n    separately.  */\n-struct df_live_bb_info \n+struct df_live_bb_info\n {\n   /* Local sets to describe the basic blocks.  */\n   bitmap kill;  /* The set of registers unset in this block.  Calls,\n@@ -856,10 +856,10 @@ struct df_live_bb_info\n /* Live registers, a backwards dataflow problem.  These bitmaps are\n indexed by the df_byte_lr_offset array which is indexed by pseudo.  */\n \n-struct df_byte_lr_bb_info \n+struct df_byte_lr_bb_info\n {\n   /* Local sets to describe the basic blocks.  */\n-  bitmap def;   /* The set of registers set in this block \n+  bitmap def;   /* The set of registers set in this block\n                    - except artificial defs at the top.  */\n   bitmap use;   /* The set of registers used in this block.  */\n \n@@ -871,7 +871,7 @@ struct df_byte_lr_bb_info\n \n /* This is used for debugging and for the dumpers to find the latest\n    instance so that the df info can be added to the dumps.  This\n-   should not be used by regular code.  */ \n+   should not be used by regular code.  */\n extern struct df *df;\n #define df_scan    (df->problems_by_index[DF_SCAN])\n #define df_rd      (df->problems_by_index[DF_RD])\n@@ -993,7 +993,7 @@ extern void df_scan_add_problem (void);\n extern void df_grow_reg_info (void);\n extern void df_grow_insn_info (void);\n extern void df_scan_blocks (void);\n-extern df_ref df_ref_create (rtx, rtx *, rtx,basic_block, \n+extern df_ref df_ref_create (rtx, rtx *, rtx,basic_block,\n \t\t\t\t     enum df_ref_type, int ref_flags,\n \t\t\t\t     int, int, enum machine_mode);\n extern void df_ref_remove (df_ref);\n@@ -1023,7 +1023,7 @@ extern bool df_read_modify_subreg_p (rtx);\n extern void df_scan_verify (void);\n \n /* Functions defined in df-byte-scan.c.  */\n-extern bool df_compute_accessed_bytes (df_ref, enum df_mm, \n+extern bool df_compute_accessed_bytes (df_ref, enum df_mm,\n \t\t\t\t       unsigned int *, unsigned int *);\n \n "}, {"sha": "90ca2a2a4f2926f3ced3598af446fecd0babb6f8", "filename": "gcc/dfp.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdfp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdfp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdfp.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -138,7 +138,7 @@ encode_decimal32 (const struct real_format *fmt ATTRIBUTE_UNUSED,\n   decContextDefault (&set, DEC_INIT_DECIMAL128);\n   set.traps = 0;\n \n-  decimal_to_decnumber (r, &dn); \n+  decimal_to_decnumber (r, &dn);\n   decimal32FromNumber (&d32, &dn, &set);\n \n   memcpy (&image, d32.bytes, sizeof (int32_t));\n@@ -163,7 +163,7 @@ decode_decimal32 (const struct real_format *fmt ATTRIBUTE_UNUSED,\n   memcpy (&d32.bytes, &image, sizeof (int32_t));\n \n   decimal32ToNumber (&d32, &dn);\n-  decimal_from_decnumber (r, &dn, &set); \n+  decimal_from_decnumber (r, &dn, &set);\n }\n \n /* Encode a real into an IEEE 754 decimal64 type.  */\n@@ -204,7 +204,7 @@ encode_decimal64 (const struct real_format *fmt ATTRIBUTE_UNUSED,\n void\n decode_decimal64 (const struct real_format *fmt ATTRIBUTE_UNUSED,\n \t\t  REAL_VALUE_TYPE *r, const long *buf)\n-{ \n+{\n   decNumber dn;\n   decimal64 d64;\n   decContext set;\n@@ -229,7 +229,7 @@ decode_decimal64 (const struct real_format *fmt ATTRIBUTE_UNUSED,\n     }\n \n   decimal64ToNumber (&d64, &dn);\n-  decimal_from_decnumber (r, &dn, &set); \n+  decimal_from_decnumber (r, &dn, &set);\n }\n \n /* Encode a real into an IEEE 754 decimal128 type.  */\n@@ -311,7 +311,7 @@ decode_decimal128 (const struct real_format *fmt ATTRIBUTE_UNUSED,\n     }\n \n   decimal128ToNumber (&d128, &dn);\n-  decimal_from_decnumber (r, &dn, &set); \n+  decimal_from_decnumber (r, &dn, &set);\n }\n \n /* Helper function to convert from a binary real internal\n@@ -365,10 +365,10 @@ decimal_do_compare (const REAL_VALUE_TYPE *a, const REAL_VALUE_TYPE *b,\n       decimal_from_binary (&b1, b);\n       b = &b1;\n     }\n-    \n+\n   /* Convert into decNumber form for comparison operation.  */\n   decContextDefault (&set, DEC_INIT_DECIMAL128);\n-  set.traps = 0;  \n+  set.traps = 0;\n   decimal128ToNumber ((const decimal128 *) a->sig, &dn2);\n   decimal128ToNumber ((const decimal128 *) b->sig, &dn3);\n \n@@ -382,7 +382,7 @@ decimal_do_compare (const REAL_VALUE_TYPE *a, const REAL_VALUE_TYPE *b,\n     return 0;\n   else if (decNumberIsNegative (&dn))\n     return -1;\n-  else \n+  else\n     return 1;\n }\n \n@@ -435,7 +435,7 @@ decimal_round_for_format (const struct real_format *fmt, REAL_VALUE_TYPE *r)\n    binary and decimal types.  */\n \n void\n-decimal_real_convert (REAL_VALUE_TYPE *r, enum machine_mode mode, \n+decimal_real_convert (REAL_VALUE_TYPE *r, enum machine_mode mode,\n \t\t      const REAL_VALUE_TYPE *a)\n {\n   const struct real_format *fmt = REAL_MODE_FORMAT (mode);\n@@ -484,7 +484,7 @@ decimal_do_add (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *op0,\n \n   if (subtract_p)\n     decNumberSubtract (&dn, &dn2, &dn3, &set);\n-  else \n+  else\n     decNumberAdd (&dn, &dn2, &dn3, &set);\n \n   decimal_from_decnumber (r, &dn, &set);\n@@ -697,7 +697,7 @@ decimal_real_arithmetic (REAL_VALUE_TYPE *r, enum tree_code code,\n \n void\n decimal_real_maxval (REAL_VALUE_TYPE *r, int sign, enum machine_mode mode)\n-{ \n+{\n   const char *max;\n \n   switch (mode)"}, {"sha": "28217a7cc786df943e8e3a61307e3a8c448d871f", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -300,7 +300,7 @@ diagnostic_classify_diagnostic (diagnostic_context *context,\n    DC.  This function is *the* subroutine in terms of which front-ends\n    should implement their specific diagnostic handling modules.  The\n    front-end independent format specifiers are exactly those described\n-   in the documentation of output_format.  \n+   in the documentation of output_format.\n    Return true if a diagnostic was printed, false otherwise.  */\n \n bool\n@@ -320,9 +320,9 @@ diagnostic_report_diagnostic (diagnostic_context *context,\n   if (diagnostic->kind == DK_NOTE && flag_compare_debug)\n     return false;\n \n-  if (diagnostic->kind == DK_PEDWARN) \n+  if (diagnostic->kind == DK_PEDWARN)\n     diagnostic->kind = pedantic_warning_kind ();\n-  \n+\n   if (context->lock > 0)\n     {\n       /* If we're reporting an ICE in the middle of some other error,\n@@ -344,7 +344,7 @@ diagnostic_report_diagnostic (diagnostic_context *context,\n       diagnostic->kind = DK_ERROR;\n       maybe_print_warnings_as_errors_message = true;\n     }\n-  \n+\n   if (diagnostic->option_index)\n     {\n       /* This tests if the user provided the appropriate -Wfoo or\n@@ -384,7 +384,7 @@ diagnostic_report_diagnostic (diagnostic_context *context,\n       dump_active_plugins (stderr);\n     }\n \n-  if (diagnostic->kind == DK_ICE) \n+  if (diagnostic->kind == DK_ICE)\n     {\n #ifndef ENABLE_CHECKING\n       /* When not checking, ICEs are converted to fatal errors when an\n@@ -405,13 +405,13 @@ diagnostic_report_diagnostic (diagnostic_context *context,\n \t\t\t\t    diagnostic->message.args_ptr);\n     }\n   ++diagnostic_kind_count (context, diagnostic->kind);\n-  \n+\n   saved_format_spec = diagnostic->message.format_spec;\n   if (context->show_option_requested && diagnostic->option_index)\n     diagnostic->message.format_spec\n       = ACONCAT ((diagnostic->message.format_spec,\n                   \" [\", cl_options[diagnostic->option_index].opt_text, \"]\", NULL));\n-  \n+\n   diagnostic->message.locus = &diagnostic->location;\n   diagnostic->message.abstract_origin = &diagnostic->abstract_origin;\n   diagnostic->abstract_origin = NULL;\n@@ -482,7 +482,7 @@ verbatim (const char *gmsgid, ...)\n }\n \n bool\n-emit_diagnostic (diagnostic_t kind, location_t location, int opt, \n+emit_diagnostic (diagnostic_t kind, location_t location, int opt,\n \t\t const char *gmsgid, ...)\n {\n   diagnostic_info diagnostic;\n@@ -520,7 +520,7 @@ inform (location_t location, const char *gmsgid, ...)\n }\n \n /* A warning at INPUT_LOCATION.  Use this for code which is correct according\n-   to the relevant language specification but is likely to be buggy anyway.  \n+   to the relevant language specification but is likely to be buggy anyway.\n    Returns true if the warning was printed, false if it was inhibited.  */\n bool\n warning (int opt, const char *gmsgid, ...)"}, {"sha": "0cfadb6fe51e6ec4161814f319979566ff459138", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -28,7 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Constants used to discriminate diagnostics.  */\n typedef enum\n {\n-#define DEFINE_DIAGNOSTIC_KIND(K, msgid) K,  \n+#define DEFINE_DIAGNOSTIC_KIND(K, msgid) K,\n #include \"diagnostic.def\"\n #undef DEFINE_DIAGNOSTIC_KIND\n   DK_LAST_DIAGNOSTIC_KIND\n@@ -70,7 +70,7 @@ struct diagnostic_context\n   /* True if we should display the \"warnings are being tread as error\"\n      message, usually displayed once per compiler run.  */\n   bool issue_warnings_are_errors_message;\n-  \n+\n   /* True if it has been requested that warnings be treated as errors.  */\n   bool warning_as_error_requested;\n "}, {"sha": "f93c4dcb2d2b8b1b94e14f3c8ee24e6fe6b14ce2", "filename": "gcc/dominance.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -717,7 +717,7 @@ set_immediate_dominator (enum cdi_direction dir, basic_block bb,\n {\n   unsigned int dir_index = dom_convert_dir_to_idx (dir);\n   struct et_node *node = bb->dom[dir_index];\n- \n+\n   gcc_assert (dom_computed[dir_index]);\n \n   if (node->father)\n@@ -758,7 +758,7 @@ get_dominated_by (enum cdi_direction dir, basic_block bb)\n /* Returns the list of basic blocks that are immediately dominated (in\n    direction DIR) by some block between N_REGION ones stored in REGION,\n    except for blocks in the REGION itself.  */\n-  \n+\n VEC (basic_block, heap) *\n get_dominated_by_region (enum cdi_direction dir, basic_block *region,\n \t\t\t unsigned n_region)\n@@ -815,7 +815,7 @@ redirect_immediate_dominators (enum cdi_direction dir, basic_block bb,\n {\n   unsigned int dir_index = dom_convert_dir_to_idx (dir);\n   struct et_node *bb_node, *to_node, *son;\n- \n+\n   bb_node = bb->dom[dir_index];\n   to_node = to->dom[dir_index];\n \n@@ -862,7 +862,7 @@ nearest_common_dominator_for_set (enum cdi_direction dir, bitmap blocks)\n   unsigned i, first;\n   bitmap_iterator bi;\n   basic_block dom;\n-  \n+\n   first = bitmap_first_set_bit (blocks);\n   dom = BASIC_BLOCK (first);\n   EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i, bi)\n@@ -881,11 +881,11 @@ nearest_common_dominator_for_set (enum cdi_direction dir, bitmap blocks)\n     You can view these as bounds for the range of dfs numbers the\n     nodes in the subtree of the dominator tree rooted at that node\n     will contain.\n-    \n+\n     The dominator tree is always a simple acyclic tree, so there are\n     only three possible relations two nodes in the dominator tree have\n     to each other:\n-    \n+\n     1. Node A is above Node B (and thus, Node A dominates node B)\n \n      A\n@@ -899,10 +899,10 @@ nearest_common_dominator_for_set (enum cdi_direction dir, bitmap blocks)\n    B, and DFS_Number_Out of A will be >= DFS_Number_Out of B.  This is\n    because we must hit A in the dominator tree *before* B on the walk\n    down, and we will hit A *after* B on the walk back up\n-   \n+\n    2. Node A is below node B (and thus, node B dominates node A)\n-   \n-   \n+\n+\n      B\n      |\n      A\n@@ -911,10 +911,10 @@ nearest_common_dominator_for_set (enum cdi_direction dir, bitmap blocks)\n \n    In the above case, DFS_Number_In of A will be >= DFS_Number_In of\n    B, and DFS_Number_Out of A will be <= DFS_Number_Out of B.\n-   \n+\n    This is because we must hit A in the dominator tree *after* B on\n    the walk down, and we will hit A *before* B on the walk back up\n-   \n+\n    3. Node A and B are siblings (and thus, neither dominates the other)\n \n      C\n@@ -937,7 +937,7 @@ nearest_common_dominator_for_set (enum cdi_direction dir, bitmap blocks)\n \n    A_Dominates_B (node A, node B)\n    {\n-     return DFS_Number_In(A) <= DFS_Number_In(B) \n+     return DFS_Number_In(A) <= DFS_Number_In(B)\n             && DFS_Number_Out (A) >= DFS_Number_Out(B);\n    }\n \n@@ -950,10 +950,10 @@ nearest_common_dominator_for_set (enum cdi_direction dir, bitmap blocks)\n /* Return TRUE in case BB1 is dominated by BB2.  */\n bool\n dominated_by_p (enum cdi_direction dir, const_basic_block bb1, const_basic_block bb2)\n-{ \n+{\n   unsigned int dir_index = dom_convert_dir_to_idx (dir);\n   struct et_node *n1 = bb1->dom[dir_index], *n2 = bb2->dom[dir_index];\n- \n+\n   gcc_assert (dom_computed[dir_index]);\n \n   if (dom_computed[dir_index] == DOM_OK)\n@@ -1389,7 +1389,7 @@ add_to_dominance_info (enum cdi_direction dir, basic_block bb)\n   gcc_assert (!bb->dom[dir_index]);\n \n   n_bbs_in_dom_tree[dir_index]++;\n-  \n+\n   bb->dom[dir_index] = et_new_tree (bb);\n \n   if (dom_computed[dir_index] == DOM_OK)"}, {"sha": "07764eb80474226e2d52d64e678c93a2e44cb24d", "filename": "gcc/domwalk.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdomwalk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdomwalk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -27,7 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"domwalk.h\"\n #include \"ggc.h\"\n \n-/* This file implements a generic walker for dominator trees. \n+/* This file implements a generic walker for dominator trees.\n \n   To understand the dominator walker one must first have a grasp of dominators,\n   immediate dominators and the dominator tree.\n@@ -69,8 +69,8 @@ along with GCC; see the file COPYING3.  If not see\n        |    +--9    11\n        |      /      |\n        +--- 10 ---> 12\n-\t  \n-  \n+\n+\n   We have a dominator tree which looks like\n \n                    1\n@@ -88,34 +88,34 @@ along with GCC; see the file COPYING3.  If not see\n                    9\n                    |\n                   10\n-  \n-  \n-  \n+\n+\n+\n   The dominator tree is the basis for a number of analysis, transformation\n   and optimization algorithms that operate on a semi-global basis.\n-  \n+\n   The dominator walker is a generic routine which visits blocks in the CFG\n   via a depth first search of the dominator tree.  In the example above\n   the dominator walker might visit blocks in the following order\n   1, 2, 3, 4, 5, 8, 9, 10, 6, 7, 11, 12.\n-  \n+\n   The dominator walker has a number of callbacks to perform actions\n   during the walk of the dominator tree.  There are two callbacks\n   which walk statements, one before visiting the dominator children,\n-  one after visiting the dominator children.  There is a callback \n+  one after visiting the dominator children.  There is a callback\n   before and after each statement walk callback.  In addition, the\n   dominator walker manages allocation/deallocation of data structures\n   which are local to each block visited.\n-  \n+\n   The dominator walker is meant to provide a generic means to build a pass\n   which can analyze or transform/optimize a function based on walking\n   the dominator tree.  One simply fills in the dominator walker data\n   structure with the appropriate callbacks and calls the walker.\n-  \n+\n   We currently use the dominator walker to prune the set of variables\n   which might need PHI nodes (which can greatly improve compile-time\n   performance in some cases).\n-  \n+\n   We also use the dominator walker to rewrite the function into SSA form\n   which reduces code duplication since the rewriting phase is inherently\n   a walk of the dominator tree."}, {"sha": "a49ce473a7e44a624467e4c66336e54d06575af3", "filename": "gcc/double-int.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdouble-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdouble-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -1,18 +1,18 @@\n /* Operations with long integers.\n    Copyright (C) 2006, 2007, 2009 Free Software Foundation, Inc.\n-   \n+\n This file is part of GCC.\n-   \n+\n GCC is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n Free Software Foundation; either version 3, or (at your option) any\n later version.\n-   \n+\n GCC is distributed in the hope that it will be useful, but WITHOUT\n ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n for more details.\n-   \n+\n You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n@@ -50,7 +50,7 @@ double_int_mask (unsigned prec)\n /* Clears the bits of CST over the precision PREC.  If UNS is false, the bits\n    outside of the precision are set to the sign bit (i.e., the PREC-th one),\n    otherwise they are set to zero.\n- \n+\n    This corresponds to returning the value represented by PREC lowermost bits\n    of CST, with the given signedness.  */\n \n@@ -102,7 +102,7 @@ double_int_sext (double_int cst, unsigned prec)\n     {\n       r.low = cst.low & mask.low;\n       r.high = cst.high & mask.high;\n-    } \n+    }\n \n   return r;\n }\n@@ -450,7 +450,7 @@ mpz_get_double_int (const_tree type, mpz_t val, bool wrap)\n   double_int res;\n \n   if (!wrap)\n-    {  \n+    {\n       mpz_t min, max;\n \n       mpz_init (min);"}, {"sha": "84185890e2944fb1631ad10dd7ce029e498c3a21", "filename": "gcc/double-int.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdouble-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdouble-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -1,18 +1,18 @@\n /* Operations with long integers.\n    Copyright (C) 2006, 2007, 2008 Free Software Foundation, Inc.\n-   \n+\n This file is part of GCC.\n-   \n+\n GCC is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n Free Software Foundation; either version 3, or (at your option) any\n later version.\n-   \n+\n GCC is distributed in the hope that it will be useful, but WITHOUT\n ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n for more details.\n-   \n+\n You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n@@ -72,7 +72,7 @@ static inline double_int\n shwi_to_double_int (HOST_WIDE_INT cst)\n {\n   double_int r;\n-  \n+\n   r.low = (unsigned HOST_WIDE_INT) cst;\n   r.high = cst < 0 ? -1 : 0;\n \n@@ -94,7 +94,7 @@ static inline double_int\n uhwi_to_double_int (unsigned HOST_WIDE_INT cst)\n {\n   double_int r;\n-  \n+\n   r.low = cst;\n   r.high = 0;\n "}, {"sha": "9569a6176e104cc9f6d1be676e705efe268878c6", "filename": "gcc/dse.c", "status": "modified", "additions": 193, "deletions": 193, "changes": 386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -48,13 +48,13 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n \n /* This file contains three techniques for performing Dead Store\n-   Elimination (dse).  \n+   Elimination (dse).\n \n    * The first technique performs dse locally on any base address.  It\n    is based on the cselib which is a local value numbering technique.\n    This technique is local to a basic block but deals with a fairly\n    general addresses.\n- \n+\n    * The second technique performs dse globally but is restricted to\n    base addresses that are either constant or are relative to the\n    frame_pointer.\n@@ -84,7 +84,7 @@ along with GCC; see the file COPYING3.  If not see\n    stores, only one store to an address is necessary because those\n    stores die at the end of the function.\n \n-   3) Set up the global dataflow equations based on processing the \n+   3) Set up the global dataflow equations based on processing the\n    info parsed in the first step.\n \n    4) Solve the dataflow equations.\n@@ -138,10 +138,10 @@ along with GCC; see the file COPYING3.  If not see\n      These are expensive and cumbersome in our bitmap formulation so\n      care has been taken to avoid large vectors filled with 1s.  See\n      the comments in bb_info and in the dataflow confluence functions\n-     for details.  \n+     for details.\n \n    There are two places for further enhancements to this algorithm:\n-   \n+\n    1) The original dse which was embedded in a pass called flow also\n    did local address forwarding.  For example in\n \n@@ -183,7 +183,7 @@ along with GCC; see the file COPYING3.  If not see\n      with the same mode and alias set.  The backout in this case is a\n      little more graceful than (a).  In this case the slot is unmarked\n      as being a spill slot and if final address comes out to be based\n-     off the frame pointer, the global algorithm handles this slot.  \n+     off the frame pointer, the global algorithm handles this slot.\n \n      c) For any pass that may prespill, there is currently no\n      mechanism to tell the dse pass that the slot being used has the\n@@ -203,7 +203,7 @@ static bitmap scratch = NULL;\n struct insn_info;\n \n /* This structure holds information about a candidate store.  */\n-struct store_info \n+struct store_info\n {\n \n   /* False means this is a clobber.  */\n@@ -216,7 +216,7 @@ struct store_info\n      true, this is -1.  Otherwise, it is the index into the group\n      table.  */\n   int group_id;\n-  \n+\n   /* This is the cselib value.  */\n   cselib_val *cse_base;\n \n@@ -285,7 +285,7 @@ static alloc_pool rtx_store_info_pool;\n \n /* This structure holds information about a load.  These are only\n    built for rtx bases.  */\n-struct read_info \n+struct read_info\n {\n   /* The id of the mem group of the base address.  */\n   int group_id;\n@@ -310,7 +310,7 @@ static alloc_pool read_info_pool;\n \n /* One of these records is created for each insn.  */\n \n-struct insn_info \n+struct insn_info\n {\n   /* Set true if the insn contains a store but the insn itself cannot\n      be deleted.  This is set if the insn is a parallel and there is\n@@ -384,10 +384,10 @@ typedef struct insn_info *insn_info_t;\n static alloc_pool insn_info_pool;\n \n /* The linked list of stores that are under consideration in this\n-   basic block.  */   \n+   basic block.  */\n static insn_info_t active_local_stores;\n \n-struct bb_info \n+struct bb_info\n {\n \n   /* Pointer to the insn info for the last insn in the block.  These\n@@ -410,7 +410,7 @@ struct bb_info\n \n   /* The set of store positions that exist in this block before a wild read.  */\n   bitmap gen;\n-  \n+\n   /* The set of load positions that exist in this block above the\n      same position of a store.  */\n   bitmap kill;\n@@ -455,7 +455,7 @@ static bb_info_t *bb_table;\n    memory.  There are also not many of the rtx bases because they are\n    very limited in scope.  */\n \n-struct group_info \n+struct group_info\n {\n   /* The actual base of the address.  */\n   rtx rtx_base;\n@@ -475,7 +475,7 @@ struct group_info\n   /* A mem wrapped around the base pointer for the group in order to\n      do read dependency.  */\n   rtx base_mem;\n-  \n+\n   /* Canonized version of base_mem's address.  */\n   rtx canon_base_addr;\n \n@@ -506,8 +506,8 @@ struct group_info\n      positions in the global bitmaps.  It is only created after all of\n      the all of stores have been scanned and we know which ones we\n      care about.  */\n-  int *offset_map_n, *offset_map_p; \n-  int offset_map_size_n, offset_map_size_p; \n+  int *offset_map_n, *offset_map_p;\n+  int offset_map_size_n, offset_map_size_p;\n };\n typedef struct group_info *group_info_t;\n typedef const struct group_info *const_group_info_t;\n@@ -527,7 +527,7 @@ static VEC(group_info_t,heap) *rtx_group_vec;\n \n /* This structure holds the set of changes that are being deferred\n    when removing read operation.  See replace_read.  */\n-struct deferred_change \n+struct deferred_change\n {\n \n   /* The mem that is being replaced.  */\n@@ -555,7 +555,7 @@ static bitmap clear_alias_sets = NULL;\n \n /* The set of clear_alias_sets that have been disqualified because\n    there are loads or stores using a different mode than the alias set\n-   was registered with.  */ \n+   was registered with.  */\n static bitmap disqualified_clear_alias_sets = NULL;\n \n /* The group that holds all of the clear_alias_sets.  */\n@@ -578,10 +578,10 @@ static alloc_pool clear_alias_mode_pool;\n static bool stores_off_frame_dead_at_return;\n \n /* Counter for stats.  */\n-static int globally_deleted; \n-static int locally_deleted; \n-static int spill_deleted; \n-      \n+static int globally_deleted;\n+static int locally_deleted;\n+static int spill_deleted;\n+\n static bitmap all_blocks;\n \n /* The number of bits used in the global bitmaps.  */\n@@ -596,7 +596,7 @@ static bool gate_dse2 (void);\n /*----------------------------------------------------------------------------\n    Zeroth step.\n \n-   Initialization.  \n+   Initialization.\n ----------------------------------------------------------------------------*/\n \n /* Hashtable callbacks for maintaining the \"bases\" field of\n@@ -605,9 +605,9 @@ static bool gate_dse2 (void);\n static int\n clear_alias_mode_eq (const void *p1, const void *p2)\n {\n-  const struct clear_alias_mode_holder * h1 \n+  const struct clear_alias_mode_holder * h1\n     = (const struct clear_alias_mode_holder *) p1;\n-  const struct clear_alias_mode_holder * h2 \n+  const struct clear_alias_mode_holder * h2\n     = (const struct clear_alias_mode_holder *) p2;\n   return h1->alias_set == h2->alias_set;\n }\n@@ -616,7 +616,7 @@ clear_alias_mode_eq (const void *p1, const void *p2)\n static hashval_t\n clear_alias_mode_hash (const void *p)\n {\n-  const struct clear_alias_mode_holder *holder \n+  const struct clear_alias_mode_holder *holder\n     = (const struct clear_alias_mode_holder *) p;\n   return holder->alias_set;\n }\n@@ -629,11 +629,11 @@ clear_alias_set_lookup (alias_set_type alias_set)\n {\n   struct clear_alias_mode_holder tmp_holder;\n   void **slot;\n-  \n+\n   tmp_holder.alias_set = alias_set;\n   slot = htab_find_slot (clear_alias_mode_table, &tmp_holder, NO_INSERT);\n   gcc_assert (*slot);\n-  \n+\n   return (struct clear_alias_mode_holder *) *slot;\n }\n \n@@ -664,8 +664,8 @@ invariant_group_base_hash (const void *p)\n static group_info_t\n get_group_info (rtx base)\n {\n-  struct group_info tmp_gi; \n-  group_info_t gi; \n+  struct group_info tmp_gi;\n+  group_info_t gi;\n   void **slot;\n \n   if (base)\n@@ -712,7 +712,7 @@ get_group_info (rtx base)\n       gi->store2_p = BITMAP_ALLOC (NULL);\n       gi->group_kill = BITMAP_ALLOC (NULL);\n       gi->process_globally = false;\n-      gi->frame_related = \n+      gi->frame_related =\n \t(base == frame_pointer_rtx) || (base == hard_frame_pointer_rtx);\n       gi->offset_map_size_n = 0;\n       gi->offset_map_size_p = 0;\n@@ -737,22 +737,22 @@ dse_step0 (void)\n   scratch = BITMAP_ALLOC (NULL);\n \n   rtx_store_info_pool\n-    = create_alloc_pool (\"rtx_store_info_pool\", \n+    = create_alloc_pool (\"rtx_store_info_pool\",\n \t\t\t sizeof (struct store_info), 100);\n   read_info_pool\n-    = create_alloc_pool (\"read_info_pool\", \n+    = create_alloc_pool (\"read_info_pool\",\n \t\t\t sizeof (struct read_info), 100);\n   insn_info_pool\n-    = create_alloc_pool (\"insn_info_pool\", \n+    = create_alloc_pool (\"insn_info_pool\",\n \t\t\t sizeof (struct insn_info), 100);\n   bb_info_pool\n-    = create_alloc_pool (\"bb_info_pool\", \n+    = create_alloc_pool (\"bb_info_pool\",\n \t\t\t sizeof (struct bb_info), 100);\n   rtx_group_info_pool\n-    = create_alloc_pool (\"rtx_group_info_pool\", \n+    = create_alloc_pool (\"rtx_group_info_pool\",\n \t\t\t sizeof (struct group_info), 100);\n   deferred_change_pool\n-    = create_alloc_pool (\"deferred_change_pool\", \n+    = create_alloc_pool (\"deferred_change_pool\",\n \t\t\t sizeof (struct deferred_change), 10);\n \n   rtx_group_table = htab_create (11, invariant_group_base_hash,\n@@ -764,7 +764,7 @@ dse_step0 (void)\n   stores_off_frame_dead_at_return = !cfun->stdarg;\n \n   init_alias_analysis ();\n-  \n+\n   if (clear_alias_sets)\n     clear_alias_group = get_group_info (NULL);\n   else\n@@ -783,7 +783,7 @@ dse_step0 (void)\n \n /* Delete all of the store_info recs from INSN_INFO.  */\n \n-static void \n+static void\n free_store_info (insn_info_t insn_info)\n {\n   store_info_t store_info = insn_info->store_rec;\n@@ -832,7 +832,7 @@ replace_inc_dec (rtx *r, void *d)\n \t\t\t  data->insn);\n \treturn -1;\n       }\n-\t\t \n+\n     case PRE_DEC:\n     case POST_DEC:\n       {\n@@ -843,7 +843,7 @@ replace_inc_dec (rtx *r, void *d)\n \t\t\t  data->insn);\n \treturn -1;\n       }\n-\t\n+\n     case PRE_MODIFY:\n     case POST_MODIFY:\n       {\n@@ -859,7 +859,7 @@ replace_inc_dec (rtx *r, void *d)\n       return 0;\n     }\n }\n-\t\t\t \n+\n \n /* If X is a MEM, check the address to see if it is PRE/POST-INC/DEC/MODIFY\n    and generate an add to replace that.  */\n@@ -876,7 +876,7 @@ replace_inc_dec_mem (rtx *r, void *d)\n       data.insn = (rtx) d;\n \n       for_each_rtx (&XEXP (x, 0), replace_inc_dec, &data);\n-\t\n+\n       return -1;\n     }\n   return 0;\n@@ -894,7 +894,7 @@ check_for_inc_dec (rtx insn)\n }\n \n \n-/* Delete the insn and free all of the fields inside INSN_INFO.  */ \n+/* Delete the insn and free all of the fields inside INSN_INFO.  */\n \n static void\n delete_dead_store_insn (insn_info_t insn_info)\n@@ -907,18 +907,18 @@ delete_dead_store_insn (insn_info_t insn_info)\n   check_for_inc_dec (insn_info->insn);\n   if (dump_file)\n     {\n-      fprintf (dump_file, \"Locally deleting insn %d \", \n+      fprintf (dump_file, \"Locally deleting insn %d \",\n \t       INSN_UID (insn_info->insn));\n       if (insn_info->store_rec->alias_set)\n-\tfprintf (dump_file, \"alias set %d\\n\", \n+\tfprintf (dump_file, \"alias set %d\\n\",\n \t\t (int) insn_info->store_rec->alias_set);\n       else\n \tfprintf (dump_file, \"\\n\");\n     }\n \n   free_store_info (insn_info);\n   read_info = insn_info->read_rec;\n-\t\n+\n   while (read_info)\n     {\n       read_info_t next = read_info->next;\n@@ -961,10 +961,10 @@ set_usage_bits (group_info_t group, HOST_WIDE_INT offset, HOST_WIDE_INT width)\n \t    store2 = group->store2_p;\n \t    ai = i;\n \t  }\n-\t\n+\n \tif (bitmap_bit_p (store1, ai))\n \t  bitmap_set_bit (store2, ai);\n-\telse \n+\telse\n \t  {\n \t    bitmap_set_bit (store1, ai);\n \t    if (i < 0)\n@@ -998,7 +998,7 @@ add_wild_read (bb_info_t bb_info)\n           pool_free (read_info_pool, *ptr);\n           *ptr = next;\n \t}\n-      else \n+      else\n \tptr = &(*ptr)->next;\n     }\n   insn_info->wild_read = true;\n@@ -1043,8 +1043,8 @@ const_or_frame_p (rtx x)\n     }\n }\n \n-/* Take all reasonable action to put the address of MEM into the form \n-   that we can do analysis on.  \n+/* Take all reasonable action to put the address of MEM into the form\n+   that we can do analysis on.\n \n    The gold standard is to get the address into the form: address +\n    OFFSET where address is something that rtx_varies_p considers a\n@@ -1054,8 +1054,8 @@ const_or_frame_p (rtx x)\n    obtained from that.\n \n    If that fails, we try cselib to get a value we can at least use\n-   locally.  If that fails we return false.  \n-   \n+   locally.  If that fails we return false.\n+\n    The GROUP_ID is set to -1 for cselib bases and the index of the\n    group for non_varying bases.\n \n@@ -1065,7 +1065,7 @@ static bool\n canon_address (rtx mem,\n \t       alias_set_type *alias_set_out,\n \t       int *group_id,\n-\t       HOST_WIDE_INT *offset, \n+\t       HOST_WIDE_INT *offset,\n \t       cselib_val **base)\n {\n   enum machine_mode address_mode\n@@ -1085,18 +1085,18 @@ canon_address (rtx mem,\n \tfprintf (dump_file, \"found alias set %d\\n\", (int) alias_set);\n       if (bitmap_bit_p (clear_alias_sets, alias_set))\n \t{\n-\t  struct clear_alias_mode_holder *entry \n+\t  struct clear_alias_mode_holder *entry\n \t    = clear_alias_set_lookup (alias_set);\n \n \t  /* If the modes do not match, we cannot process this set.  */\n \t  if (entry->mode != GET_MODE (mem))\n \t    {\n \t      if (dump_file)\n-\t\tfprintf (dump_file, \n-\t\t\t \"disqualifying alias set %d, (%s) != (%s)\\n\", \n-\t\t\t (int) alias_set, GET_MODE_NAME (entry->mode), \n+\t\tfprintf (dump_file,\n+\t\t\t \"disqualifying alias set %d, (%s) != (%s)\\n\",\n+\t\t\t (int) alias_set, GET_MODE_NAME (entry->mode),\n \t\t\t GET_MODE_NAME (GET_MODE (mem)));\n-\t      \n+\n \t      bitmap_set_bit (disqualified_clear_alias_sets, alias_set);\n \t      return false;\n \t    }\n@@ -1126,12 +1126,12 @@ canon_address (rtx mem,\n       if (expanded)\n \t{\n \t  /* Use cselib to replace all of the reg references with the full\n-\t     expression.  This will take care of the case where we have \n+\t     expression.  This will take care of the case where we have\n \n \t     r_x = base + offset;\n \t     val = *r_x;\n-   \n-\t     by making it into \n+\n+\t     by making it into\n \n \t     val = *(base + offset);  */\n \n@@ -1199,7 +1199,7 @@ canon_address (rtx mem,\n       return false;\n     }\n   if (dump_file)\n-    fprintf (dump_file, \"  varying cselib base=%d offset = %d\\n\", \n+    fprintf (dump_file, \"  varying cselib base=%d offset = %d\\n\",\n \t     (*base)->value, (int)*offset);\n   return true;\n }\n@@ -1344,7 +1344,7 @@ record_store (rtx body, bb_info_t bb_info)\n     {\n       if (GET_CODE (XEXP (mem, 0)) == SCRATCH)\n \t{\n-\t  if (dump_file) \n+\t  if (dump_file)\n \t    fprintf (dump_file, \" adding wild read for (clobber (mem:BLK (scratch))\\n\");\n \t  add_wild_read (bb_info);\n \t  insn_info->cannot_delete = true;\n@@ -1394,15 +1394,15 @@ record_store (rtx body, bb_info_t bb_info)\n       bitmap store2 = clear_alias_group->store2_p;\n \n       gcc_assert (GET_MODE (mem) != BLKmode);\n-      \n+\n       if (bitmap_bit_p (store1, spill_alias_set))\n \tbitmap_set_bit (store2, spill_alias_set);\n-      else \n+      else\n \tbitmap_set_bit (store1, spill_alias_set);\n-\t\n+\n       if (clear_alias_group->offset_map_size_p < spill_alias_set)\n \tclear_alias_group->offset_map_size_p = spill_alias_set;\n-  \n+\n       store_info = (store_info_t) pool_alloc (rtx_store_info_pool);\n \n       if (dump_file)\n@@ -1413,10 +1413,10 @@ record_store (rtx body, bb_info_t bb_info)\n     {\n       /* In the restrictive case where the base is a constant or the\n \t frame pointer we can do global analysis.  */\n-      \n-      group_info_t group \n+\n+      group_info_t group\n \t= VEC_index (group_info_t, rtx_group_vec, group_id);\n-      \n+\n       store_info = (store_info_t) pool_alloc (rtx_store_info_pool);\n       set_usage_bits (group, offset, width);\n \n@@ -1511,7 +1511,7 @@ record_store (rtx body, bb_info_t bb_info)\n \tdel = false;\n       else if (s_info->alias_set)\n \t{\n-\t  struct clear_alias_mode_holder *entry \n+\t  struct clear_alias_mode_holder *entry\n \t    = clear_alias_set_lookup (s_info->alias_set);\n \t  /* Generally, spills cannot be processed if and of the\n \t     references to the slot have a different mode.  But if\n@@ -1528,13 +1528,13 @@ record_store (rtx body, bb_info_t bb_info)\n \t    fprintf (dump_file, \"    trying spill store in insn=%d alias_set=%d\\n\",\n \t\t     INSN_UID (ptr->insn), (int) s_info->alias_set);\n \t}\n-      else if ((s_info->group_id == group_id) \n+      else if ((s_info->group_id == group_id)\n \t       && (s_info->cse_base == base))\n \t{\n \t  HOST_WIDE_INT i;\n \t  if (dump_file)\n \t    fprintf (dump_file, \"    trying store in insn=%d gid=%d[%d..%d)\\n\",\n-\t\t     INSN_UID (ptr->insn), s_info->group_id, \n+\t\t     INSN_UID (ptr->insn), s_info->group_id,\n \t\t     (int)s_info->begin, (int)s_info->end);\n \n \t  /* Even if PTR won't be eliminated as unneeded, if both\n@@ -1582,7 +1582,7 @@ record_store (rtx body, bb_info_t bb_info)\n \t   the value of store_info.  If it is, set the rhs to NULL to\n \t   keep it from being used to remove a load.  */\n \t{\n-\t  if (canon_true_dependence (s_info->mem, \n+\t  if (canon_true_dependence (s_info->mem,\n \t\t\t\t     GET_MODE (s_info->mem),\n \t\t\t\t     s_info->mem_addr,\n \t\t\t\t     mem, mem_addr, rtx_varies_p))\n@@ -1601,20 +1601,20 @@ record_store (rtx body, bb_info_t bb_info)\n       if (del)\n \t{\n \t  insn_info_t insn_to_delete = ptr;\n-\t  \n+\n \t  if (last)\n \t    last->next_local_store = ptr->next_local_store;\n \t  else\n \t    active_local_stores = ptr->next_local_store;\n-\t  \n+\n \t  delete_dead_store_insn (insn_to_delete);\n \t}\n       else\n \tlast = ptr;\n-      \n+\n       ptr = next;\n     }\n-  \n+\n   /* Finish filling in the store_info.  */\n   store_info->next = insn_info->store_rec;\n   insn_info->store_rec = store_info;\n@@ -1651,7 +1651,7 @@ record_store (rtx body, bb_info_t bb_info)\n static void\n dump_insn_info (const char * start, insn_info_t insn_info)\n {\n-  fprintf (dump_file, \"%s insn=%d %s\\n\", start, \n+  fprintf (dump_file, \"%s insn=%d %s\\n\", start,\n \t   INSN_UID (insn_info->insn),\n \t   insn_info->store_rec ? \"has store\" : \"naked\");\n }\n@@ -1876,7 +1876,7 @@ get_stored_val (store_info_t store_info, enum machine_mode read_mode,\n      ...\n      ... <- A\n \n-   and change it into \n+   and change it into\n    r2 <- r1\n    A <- r1\n    ...\n@@ -1903,7 +1903,7 @@ get_stored_val (store_info_t store_info, enum machine_mode read_mode,\n    went ok.  */\n \n static bool\n-replace_read (store_info_t store_info, insn_info_t store_insn, \n+replace_read (store_info_t store_info, insn_info_t store_insn,\n \t      read_info_t read_info, insn_info_t read_insn, rtx *loc,\n \t      bitmap regs_live)\n {\n@@ -1958,17 +1958,17 @@ replace_read (store_info_t store_info, insn_info_t store_insn,\n \n       for (this_insn = insns; this_insn != NULL_RTX; this_insn = NEXT_INSN (this_insn))\n \tnote_stores (PATTERN (this_insn), look_for_hardregs, regs_set);\n-      \n+\n       bitmap_and_into (regs_set, regs_live);\n       if (!bitmap_empty_p (regs_set))\n \t{\n \t  if (dump_file)\n \t    {\n-\t      fprintf (dump_file, \n+\t      fprintf (dump_file,\n \t\t       \"abandoning replacement because sequence clobbers live hardregs:\");\n \t      df_print_regset (dump_file, regs_set);\n \t    }\n-\t  \n+\n \t  BITMAP_FREE (regs_set);\n \t  return false;\n \t}\n@@ -1979,25 +1979,25 @@ replace_read (store_info_t store_info, insn_info_t store_insn,\n     {\n       deferred_change_t deferred_change =\n \t(deferred_change_t) pool_alloc (deferred_change_pool);\n-      \n+\n       /* Insert this right before the store insn where it will be safe\n \t from later insns that might change it before the read.  */\n       emit_insn_before (insns, store_insn->insn);\n-      \n+\n       /* And now for the kludge part: cselib croaks if you just\n \t return at this point.  There are two reasons for this:\n-\t \n+\n \t 1) Cselib has an idea of how many pseudos there are and\n \t that does not include the new ones we just added.\n-\t \n+\n \t 2) Cselib does not know about the move insn we added\n \t above the store_info, and there is no way to tell it\n \t about it, because it has \"moved on\".\n-\t \n+\n \t Problem (1) is fixable with a certain amount of engineering.\n \t Problem (2) is requires starting the bb from scratch.  This\n \t could be expensive.\n-\t \n+\n \t So we are just going to have to lie.  The move/extraction\n \t insns are not really an issue, cselib did not see them.  But\n \t the use of the new pseudo read_insn is a real problem because\n@@ -2006,13 +2006,13 @@ replace_read (store_info_t store_info, insn_info_t store_insn,\n \t and when we are finished with the block, we undo this.  We\n \t keep a table of mems to get rid of.  At the end of the basic\n \t block we can put them back.  */\n-      \n+\n       *loc = read_info->mem;\n       deferred_change->next = deferred_change_list;\n       deferred_change_list = deferred_change;\n       deferred_change->loc = loc;\n       deferred_change->reg = read_reg;\n-      \n+\n       /* Get rid of the read_info, from the point of view of the\n \t rest of dse, play like this read never happened.  */\n       read_insn->read_rec = read_info->next;\n@@ -2025,7 +2025,7 @@ replace_read (store_info_t store_info, insn_info_t store_insn,\n \t}\n       return true;\n     }\n-  else \n+  else\n     {\n       if (dump_file)\n \t{\n@@ -2050,7 +2050,7 @@ check_mem_read_rtx (rtx *loc, void *data)\n   HOST_WIDE_INT offset = 0;\n   HOST_WIDE_INT width = 0;\n   alias_set_type spill_alias_set = 0;\n-  cselib_val *base = NULL;  \n+  cselib_val *base = NULL;\n   int group_id;\n   read_info_t read_info;\n \n@@ -2132,7 +2132,7 @@ check_mem_read_rtx (rtx *loc, void *data)\n \t  /* Skip the clobbers.  */\n \t  while (!store_info->is_set)\n \t    store_info = store_info->next;\n-\t  \n+\n \t  if (store_info->alias_set == spill_alias_set)\n \t    {\n \t      if (dump_file)\n@@ -2154,7 +2154,7 @@ check_mem_read_rtx (rtx *loc, void *data)\n \t the frame pointer and offset is a constant.  */\n       insn_info_t i_ptr = active_local_stores;\n       insn_info_t last = NULL;\n-      \n+\n       if (dump_file)\n \t{\n \t  if (width == -1)\n@@ -2169,35 +2169,35 @@ check_mem_read_rtx (rtx *loc, void *data)\n \t{\n \t  bool remove = false;\n \t  store_info_t store_info = i_ptr->store_rec;\n-\t  \n+\n \t  /* Skip the clobbers.  */\n \t  while (!store_info->is_set)\n \t    store_info = store_info->next;\n-\t  \n+\n \t  /* There are three cases here.  */\n \t  if (store_info->group_id < 0)\n \t    /* We have a cselib store followed by a read from a\n \t       const base. */\n-\t    remove \n-\t      = canon_true_dependence (store_info->mem, \n+\t    remove\n+\t      = canon_true_dependence (store_info->mem,\n \t\t\t\t       GET_MODE (store_info->mem),\n \t\t\t\t       store_info->mem_addr,\n \t\t\t\t       mem, mem_addr, rtx_varies_p);\n-\t  \n+\n \t  else if (group_id == store_info->group_id)\n \t    {\n \t      /* This is a block mode load.  We may get lucky and\n \t\t canon_true_dependence may save the day.  */\n \t      if (width == -1)\n-\t\tremove \n-\t\t  = canon_true_dependence (store_info->mem, \n+\t\tremove\n+\t\t  = canon_true_dependence (store_info->mem,\n \t\t\t\t\t   GET_MODE (store_info->mem),\n \t\t\t\t\t   store_info->mem_addr,\n \t\t\t\t\t   mem, mem_addr, rtx_varies_p);\n-\t      \n+\n \t      /* If this read is just reading back something that we just\n \t\t stored, rewrite the read.  */\n-\t      else \n+\t      else\n \t\t{\n \t\t  if (store_info->rhs\n \t\t      && offset >= store_info->begin\n@@ -2211,17 +2211,17 @@ check_mem_read_rtx (rtx *loc, void *data)\n \n \t\t  /* The bases are the same, just see if the offsets\n \t\t     overlap.  */\n-\t\t  if ((offset < store_info->end) \n+\t\t  if ((offset < store_info->end)\n \t\t      && (offset + width > store_info->begin))\n \t\t    remove = true;\n \t\t}\n \t    }\n-\t  \n-\t  /* else \n+\n+\t  /* else\n \t     The else case that is missing here is that the\n \t     bases are constant but different.  There is nothing\n \t     to do here because there is no overlap.  */\n-\t  \n+\n \t  if (remove)\n \t    {\n \t      if (dump_file)\n@@ -2237,7 +2237,7 @@ check_mem_read_rtx (rtx *loc, void *data)\n \t  i_ptr = i_ptr->next_local_store;\n \t}\n     }\n-  else \n+  else\n     {\n       insn_info_t i_ptr = active_local_stores;\n       insn_info_t last = NULL;\n@@ -2252,7 +2252,7 @@ check_mem_read_rtx (rtx *loc, void *data)\n \t{\n \t  bool remove = false;\n \t  store_info_t store_info = i_ptr->store_rec;\n-\t  \n+\n \t  if (dump_file)\n \t    fprintf (dump_file, \" processing cselib load against insn %d\\n\",\n \t\t     INSN_UID (i_ptr->insn));\n@@ -2276,16 +2276,16 @@ check_mem_read_rtx (rtx *loc, void *data)\n \t    return 0;\n \n \t  if (!store_info->alias_set)\n-\t    remove = canon_true_dependence (store_info->mem, \n+\t    remove = canon_true_dependence (store_info->mem,\n \t\t\t\t\t    GET_MODE (store_info->mem),\n \t\t\t\t\t    store_info->mem_addr,\n \t\t\t\t\t    mem, mem_addr, rtx_varies_p);\n-\t  \n+\n \t  if (remove)\n \t    {\n \t      if (dump_file)\n \t\tdump_insn_info (\"removing from active\", i_ptr);\n-\t      \n+\n \t      if (last)\n \t\tlast->next_local_store = i_ptr->next_local_store;\n \t      else\n@@ -2299,7 +2299,7 @@ check_mem_read_rtx (rtx *loc, void *data)\n   return 0;\n }\n \n-/* A for_each_rtx callback in which DATA points the INSN_INFO for \n+/* A for_each_rtx callback in which DATA points the INSN_INFO for\n    as check_mem_read_rtx.  Nullify the pointer if i_m_r_m_r returns\n    true for any part of *LOC.  */\n \n@@ -2389,7 +2389,7 @@ scan_insn (bb_info_t bb_info, rtx insn)\n   insn_info->prev_insn = bb_info->last_insn;\n   insn_info->insn = insn;\n   bb_info->last_insn = insn_info;\n-  \n+\n   if (DEBUG_INSN_P (insn))\n     {\n       insn_info->cannot_delete = true;\n@@ -2488,7 +2488,7 @@ scan_insn (bb_info_t bb_info, rtx insn)\n \t\t{\n \t\t  if (dump_file)\n \t\t    dump_insn_info (\"removing from active\", i_ptr);\n-\t\t  \n+\n \t\t  if (last)\n \t\t    last->next_local_store = i_ptr->next_local_store;\n \t\t  else\n@@ -2538,7 +2538,7 @@ scan_insn (bb_info_t bb_info, rtx insn)\n       || (RTX_FRAME_RELATED_P (insn))\n       || find_reg_note (insn, REG_FRAME_RELATED_EXPR, NULL_RTX))\n     insn_info->cannot_delete = true;\n-  \n+\n   body = PATTERN (insn);\n   if (GET_CODE (body) == PARALLEL)\n     {\n@@ -2550,7 +2550,7 @@ scan_insn (bb_info_t bb_info, rtx insn)\n     mems_found += record_store (body, bb_info);\n \n   if (dump_file)\n-    fprintf (dump_file, \"mems_found = %d, cannot_delete = %s\\n\", \n+    fprintf (dump_file, \"mems_found = %d, cannot_delete = %s\\n\",\n \t     mems_found, insn_info->cannot_delete ? \"true\" : \"false\");\n \n   /* If we found some sets of mems, add it into the active_local_stores so\n@@ -2586,7 +2586,7 @@ remove_useless_values (cselib_val *base)\n \t being deleted, then the insn can not be deleted.  */\n       while (store_info)\n \t{\n-\t  if ((store_info->group_id == -1) \n+\t  if ((store_info->group_id == -1)\n \t      && (store_info->cse_base == base))\n \t    {\n \t      del = true;\n@@ -2605,7 +2605,7 @@ remove_useless_values (cselib_val *base)\n \t}\n       else\n \tlast = insn_info;\n-  \n+\n       insn_info = insn_info->next_local_store;\n     }\n }\n@@ -2618,7 +2618,7 @@ dse_step1 (void)\n {\n   basic_block bb;\n   bitmap regs_live = BITMAP_ALLOC (NULL);\n-  \n+\n   cselib_init (false);\n   all_blocks = BITMAP_ALLOC (NULL);\n   bitmap_set_bit (all_blocks, ENTRY_BLOCK);\n@@ -2644,11 +2644,11 @@ dse_step1 (void)\n \t  rtx insn;\n \n \t  cse_store_info_pool\n-\t    = create_alloc_pool (\"cse_store_info_pool\", \n+\t    = create_alloc_pool (\"cse_store_info_pool\",\n \t\t\t\t sizeof (struct store_info), 100);\n \t  active_local_stores = NULL;\n \t  cselib_clear_table ();\n-\t  \n+\n \t  /* Scan the insns.  */\n \t  FOR_BB_INSNS (bb, insn)\n \t    {\n@@ -2658,7 +2658,7 @@ dse_step1 (void)\n \t      if (INSN_P (insn))\n \t\tdf_simulate_one_insn_forwards (bb, insn, regs_live);\n \t    }\n-\t  \n+\n \t  /* This is something of a hack, because the global algorithm\n \t     is supposed to take care of the case where stores go dead\n \t     at the end of the function.  However, the global\n@@ -2684,10 +2684,10 @@ dse_step1 (void)\n \t\t    store_info = store_info->next;\n \t\t  if (store_info->alias_set && !i_ptr->cannot_delete)\n \t\t    delete_dead_store_insn (i_ptr);\n-\t\t  else \n+\t\t  else\n \t\t    if (store_info->group_id >= 0)\n \t\t      {\n-\t\t\tgroup_info_t group \n+\t\t\tgroup_info_t group\n \t\t\t  = VEC_index (group_info_t, rtx_group_vec, store_info->group_id);\n \t\t\tif (group->frame_related && !i_ptr->cannot_delete)\n \t\t\t  delete_dead_store_insn (i_ptr);\n@@ -2789,7 +2789,7 @@ dse_step2_init (void)\n \t for the position.  We do this because the stack related\n \t stores can be deleted if their is no read between them and\n \t the end of the function.\n-\t \n+\n \t To make this work in the current framework, we take the stack\n \t related bases add all of the bits from store1 into store2.\n \t This has the effect of making the eligible even if there is\n@@ -2800,7 +2800,7 @@ dse_step2_init (void)\n \t  bitmap_ior_into (group->store2_n, group->store1_n);\n \t  bitmap_ior_into (group->store2_p, group->store1_p);\n \t  if (dump_file)\n-\t    fprintf (dump_file, \"group %d is frame related \", i); \n+\t    fprintf (dump_file, \"group %d is frame related \", i);\n \t}\n \n       group->offset_map_size_n++;\n@@ -2810,7 +2810,7 @@ dse_step2_init (void)\n       group->process_globally = false;\n       if (dump_file)\n \t{\n-\t  fprintf (dump_file, \"group %d(%d+%d): \", i, \n+\t  fprintf (dump_file, \"group %d(%d+%d): \", i,\n \t\t   (int)bitmap_count_bits (group->store2_n),\n \t\t   (int)bitmap_count_bits (group->store2_p));\n \t  bitmap_print (dump_file, group->store2_n, \"n \", \" \");\n@@ -2851,7 +2851,7 @@ dse_step2_nospill (void)\n \t}\n       EXECUTE_IF_SET_IN_BITMAP (group->store2_p, 0, j, bi)\n \t{\n-\t  bitmap_set_bit (group->group_kill, current_position); \n+\t  bitmap_set_bit (group->group_kill, current_position);\n \t  group->offset_map_p[j] = current_position++;\n \t  group->process_globally = true;\n \t}\n@@ -2875,24 +2875,24 @@ dse_step2_spill (void)\n \n   if (dump_file)\n     {\n-      bitmap_print (dump_file, clear_alias_sets, \n+      bitmap_print (dump_file, clear_alias_sets,\n \t\t    \"clear alias sets              \", \"\\n\");\n-      bitmap_print (dump_file, disqualified_clear_alias_sets, \n+      bitmap_print (dump_file, disqualified_clear_alias_sets,\n \t\t    \"disqualified clear alias sets \", \"\\n\");\n     }\n \n   memset (group->offset_map_n, 0, sizeof(int) * group->offset_map_size_n);\n   memset (group->offset_map_p, 0, sizeof(int) * group->offset_map_size_p);\n   bitmap_clear (group->group_kill);\n-  \n+\n   /* Remove the disqualified positions from the store2_p set.  */\n   bitmap_and_compl_into (group->store2_p, disqualified_clear_alias_sets);\n-  \n+\n   /* We do not need to process the store2_n set because\n      alias_sets are always positive.  */\n   EXECUTE_IF_SET_IN_BITMAP (group->store2_p, 0, j, bi)\n     {\n-      bitmap_set_bit (group->group_kill, current_position); \n+      bitmap_set_bit (group->group_kill, current_position);\n       group->offset_map_p[j] = current_position++;\n       group->process_globally = true;\n     }\n@@ -2904,25 +2904,25 @@ dse_step2_spill (void)\n \f\n /*----------------------------------------------------------------------------\n   Third step.\n-  \n+\n   Build the bit vectors for the transfer functions.\n ----------------------------------------------------------------------------*/\n \n \n /* Note that this is NOT a general purpose function.  Any mem that has\n    an alias set registered here expected to be COMPLETELY unaliased:\n-   i.e it's addresses are not and need not be examined.  \n+   i.e it's addresses are not and need not be examined.\n \n    It is known that all references to this address will have this\n    alias set and there are NO other references to this address in the\n-   function.  \n+   function.\n \n    Currently the only place that is known to be clean enough to use\n-   this interface is the code that assigns the spill locations.  \n+   this interface is the code that assigns the spill locations.\n \n    All of the mems that have alias_sets registered are subjected to a\n    very powerful form of dse where function calls, volatile reads and\n-   writes, and reads from random location are not taken into account.  \n+   writes, and reads from random location are not taken into account.\n \n    It is also assumed that these locations go dead when the function\n    returns.  This assumption could be relaxed if there were found to\n@@ -2939,8 +2939,8 @@ dse_step2_spill (void)\n    elements.  So when we see a mode mismatch, we just bail.  */\n \n \n-void \n-dse_record_singleton_alias_set (alias_set_type alias_set, \n+void\n+dse_record_singleton_alias_set (alias_set_type alias_set,\n \t\t\t\tenum machine_mode mode)\n {\n   struct clear_alias_mode_holder tmp_holder;\n@@ -2958,7 +2958,7 @@ dse_record_singleton_alias_set (alias_set_type alias_set,\n       disqualified_clear_alias_sets = BITMAP_ALLOC (NULL);\n       clear_alias_mode_table = htab_create (11, clear_alias_mode_hash,\n \t\t\t\t\t    clear_alias_mode_eq, NULL);\n-      clear_alias_mode_pool = create_alloc_pool (\"clear_alias_mode_pool\", \n+      clear_alias_mode_pool = create_alloc_pool (\"clear_alias_mode_pool\",\n \t\t\t\t\t\t sizeof (struct clear_alias_mode_holder), 100);\n     }\n \n@@ -2978,7 +2978,7 @@ dse_record_singleton_alias_set (alias_set_type alias_set,\n \n /* Remove ALIAS_SET from the sets of stack slots being considered.  */\n \n-void \n+void\n dse_invalidate_singleton_alias_set (alias_set_type alias_set)\n {\n   if ((!gate_dse()) || !alias_set)\n@@ -3013,13 +3013,13 @@ get_bitmap_index (group_info_t group_info, HOST_WIDE_INT offset)\n /* Process the STORE_INFOs into the bitmaps into GEN and KILL.  KILL\n    may be NULL. */\n \n-static void \n+static void\n scan_stores_nospill (store_info_t store_info, bitmap gen, bitmap kill)\n {\n   while (store_info)\n     {\n       HOST_WIDE_INT i;\n-      group_info_t group_info \n+      group_info_t group_info\n \t= VEC_index (group_info_t, rtx_group_vec, store_info->group_id);\n       if (group_info->process_globally)\n \tfor (i = store_info->begin; i < store_info->end; i++)\n@@ -3040,14 +3040,14 @@ scan_stores_nospill (store_info_t store_info, bitmap gen, bitmap kill)\n /* Process the STORE_INFOs into the bitmaps into GEN and KILL.  KILL\n    may be NULL. */\n \n-static void \n+static void\n scan_stores_spill (store_info_t store_info, bitmap gen, bitmap kill)\n {\n   while (store_info)\n     {\n       if (store_info->alias_set)\n \t{\n-\t  int index = get_bitmap_index (clear_alias_group, \n+\t  int index = get_bitmap_index (clear_alias_group,\n \t\t\t\t\tstore_info->alias_set);\n \t  if (index != 0)\n \t    {\n@@ -3079,7 +3079,7 @@ scan_reads_nospill (insn_info_t insn_info, bitmap gen, bitmap kill)\n \t  {\n \t    if (kill)\n \t      bitmap_ior_into (kill, group->group_kill);\n-\t    bitmap_and_compl_into (gen, group->group_kill); \n+\t    bitmap_and_compl_into (gen, group->group_kill);\n \t  }\n     }\n \n@@ -3124,7 +3124,7 @@ scan_reads_nospill (insn_info_t insn_info, bitmap gen, bitmap kill)\n \t\t     something else with a different constant\n \t\t     base.  */\n \t\t  if ((read_info->group_id < 0)\n-\t\t      && canon_true_dependence (group->base_mem, \n+\t\t      && canon_true_dependence (group->base_mem,\n \t\t\t\t\t\tQImode,\n \t\t\t\t\t\tgroup->canon_base_addr,\n \t\t\t\t\t\tread_info->mem, NULL_RTX,\n@@ -3137,7 +3137,7 @@ scan_reads_nospill (insn_info_t insn_info, bitmap gen, bitmap kill)\n \t\t}\n \t    }\n \t}\n-      \n+\n       read_info = read_info->next;\n     }\n }\n@@ -3152,7 +3152,7 @@ scan_reads_spill (read_info_t read_info, bitmap gen, bitmap kill)\n     {\n       if (read_info->alias_set)\n \t{\n-\t  int index = get_bitmap_index (clear_alias_group, \n+\t  int index = get_bitmap_index (clear_alias_group,\n \t\t\t\t\tread_info->alias_set);\n \t  if (index != 0)\n \t    {\n@@ -3161,7 +3161,7 @@ scan_reads_spill (read_info_t read_info, bitmap gen, bitmap kill)\n \t      bitmap_clear_bit (gen, index);\n \t    }\n \t}\n-      \n+\n       read_info = read_info->next;\n     }\n }\n@@ -3214,7 +3214,7 @@ dse_step3_scan (bool for_spills, basic_block bb)\n     insn_info = bb_info->last_insn;\n   else\n     insn_info = find_insn_before_first_wild_read (bb_info);\n-    \n+\n   /* In the spill case or in the no_spill case if there is no wild\n      read in the block, we will need a kill set.  */\n   if (insn_info == bb_info->last_insn)\n@@ -3224,7 +3224,7 @@ dse_step3_scan (bool for_spills, basic_block bb)\n       else\n \tbb_info->kill = BITMAP_ALLOC (NULL);\n     }\n-  else \n+  else\n     if (bb_info->kill)\n       BITMAP_FREE (bb_info->kill);\n \n@@ -3234,7 +3234,7 @@ dse_step3_scan (bool for_spills, basic_block bb)\n \t this phase.  */\n       if (insn_info->insn && INSN_P (insn_info->insn))\n \t{\n-\t  /* Process the read(s) last.  */ \n+\t  /* Process the read(s) last.  */\n \t  if (for_spills)\n \t    {\n \t      scan_stores_spill (insn_info->store_rec, bb_info->gen, bb_info->kill);\n@@ -3245,7 +3245,7 @@ dse_step3_scan (bool for_spills, basic_block bb)\n \t      scan_stores_nospill (insn_info->store_rec, bb_info->gen, bb_info->kill);\n \t      scan_reads_nospill (insn_info, bb_info->gen, bb_info->kill);\n \t    }\n-\t}\t  \n+\t}\n \n       insn_info = insn_info->prev_insn;\n     }\n@@ -3260,12 +3260,12 @@ dse_step3_exit_block_scan (bb_info_t bb_info)\n {\n   /* The gen set is all 0's for the exit block except for the\n      frame_pointer_group.  */\n-  \n+\n   if (stores_off_frame_dead_at_return)\n     {\n       unsigned int i;\n       group_info_t group;\n-      \n+\n       for (i = 0; VEC_iterate (group_info_t, rtx_group_vec, i, group); i++)\n \t{\n \t  if (group->process_globally && group->frame_related)\n@@ -3290,9 +3290,9 @@ mark_reachable_blocks (sbitmap unreachable_blocks, basic_block bb)\n     {\n       RESET_BIT (unreachable_blocks, bb->index);\n       FOR_EACH_EDGE (e, ei, bb->preds)\n-\t{\t\t\t\t\t\t\t\t\n+\t{\n \t  mark_reachable_blocks (unreachable_blocks, e->src);\n-\t}\t\t\t\t\t\t\t\t\n+\t}\n     }\n }\n \n@@ -3306,7 +3306,7 @@ dse_step3 (bool for_spills)\n   sbitmap_iterator sbi;\n   bitmap all_ones = NULL;\n   unsigned int i;\n-  \n+\n   sbitmap_ones (unreachable_blocks);\n \n   FOR_ALL_BB (bb)\n@@ -3418,7 +3418,7 @@ dse_confluence_n (edge e)\n \n \n /* Propagate the info from the out to the in set of BB_INDEX's basic\n-   block.  There are three cases:  \n+   block.  There are three cases:\n \n    1) The block has no kill set.  In this case the kill set is all\n    ones.  It does not matter what the out set of the block is, none of\n@@ -3444,12 +3444,12 @@ dse_transfer_function (int bb_index)\n \t{\n \t  /* Case 3 above.  */\n \t  if (bb_info->in)\n-\t    return bitmap_ior_and_compl (bb_info->in, bb_info->gen, \n+\t    return bitmap_ior_and_compl (bb_info->in, bb_info->gen,\n \t\t\t\t\t bb_info->out, bb_info->kill);\n \t  else\n \t    {\n \t      bb_info->in = BITMAP_ALLOC (NULL);\n-\t      bitmap_ior_and_compl (bb_info->in, bb_info->gen, \n+\t      bitmap_ior_and_compl (bb_info->in, bb_info->gen,\n \t\t\t\t    bb_info->out, bb_info->kill);\n \t      return true;\n \t    }\n@@ -3478,9 +3478,9 @@ dse_transfer_function (int bb_index)\n static void\n dse_step4 (void)\n {\n-  df_simple_dataflow (DF_BACKWARD, NULL, dse_confluence_0, \n-\t\t      dse_confluence_n, dse_transfer_function, \n-\t   \t      all_blocks, df_get_postorder (DF_BACKWARD), \n+  df_simple_dataflow (DF_BACKWARD, NULL, dse_confluence_0,\n+\t\t      dse_confluence_n, dse_transfer_function,\n+\t   \t      all_blocks, df_get_postorder (DF_BACKWARD),\n \t\t      df_get_n_blocks (DF_BACKWARD));\n   if (dump_file)\n     {\n@@ -3543,7 +3543,7 @@ dse_step5_nospill (void)\n \n \t  /* There may have been code deleted by the dce pass run before\n \t     this phase.  */\n-\t  if (insn_info->insn \n+\t  if (insn_info->insn\n \t      && INSN_P (insn_info->insn)\n \t      && (!insn_info->cannot_delete)\n \t      && (!bitmap_empty_p (v)))\n@@ -3552,7 +3552,7 @@ dse_step5_nospill (void)\n \n \t      /* Try to delete the current insn.  */\n \t      deleted = true;\n-\t      \n+\n \t      /* Skip the clobbers.  */\n \t      while (!store_info->is_set)\n \t\tstore_info = store_info->next;\n@@ -3562,19 +3562,19 @@ dse_step5_nospill (void)\n \t      else\n \t\t{\n \t\t  HOST_WIDE_INT i;\n-\t\t  group_info_t group_info \n+\t\t  group_info_t group_info\n \t\t    = VEC_index (group_info_t, rtx_group_vec, store_info->group_id);\n-\t\t  \n+\n \t\t  for (i = store_info->begin; i < store_info->end; i++)\n \t\t    {\n \t\t      int index = get_bitmap_index (group_info, i);\n-\t\t      \n+\n \t\t      if (dump_file)\n-\t\t\tfprintf (dump_file, \"i = %d, index = %d\\n\", (int)i, index); \n+\t\t\tfprintf (dump_file, \"i = %d, index = %d\\n\", (int)i, index);\n \t\t      if (index == 0 || !bitmap_bit_p (v, index))\n \t\t\t{\n \t\t\t  if (dump_file)\n-\t\t\t    fprintf (dump_file, \"failing at i = %d\\n\", (int)i); \n+\t\t\t    fprintf (dump_file, \"failing at i = %d\\n\", (int)i);\n \t\t\t  deleted = false;\n \t\t\t  break;\n \t\t\t}\n@@ -3594,7 +3594,7 @@ dse_step5_nospill (void)\n \t  /* We do want to process the local info if the insn was\n \t     deleted.  For instance, if the insn did a wild read, we\n \t     no longer need to trash the info.  */\n-\t  if (insn_info->insn \n+\t  if (insn_info->insn\n \t      && INSN_P (insn_info->insn)\n \t      && (!deleted))\n \t    {\n@@ -3612,7 +3612,7 @@ dse_step5_nospill (void)\n \t\t  scan_reads_nospill (insn_info, v, NULL);\n \t\t}\n \t    }\n-\t      \n+\n \t  insn_info = insn_info->prev_insn;\n \t}\n     }\n@@ -3634,51 +3634,51 @@ dse_step5_spill (void)\n \t  bool deleted = false;\n \t  /* There may have been code deleted by the dce pass run before\n \t     this phase.  */\n-\t  if (insn_info->insn \n+\t  if (insn_info->insn\n \t      && INSN_P (insn_info->insn)\n \t      && (!insn_info->cannot_delete)\n \t      && (!bitmap_empty_p (v)))\n \t    {\n \t      /* Try to delete the current insn.  */\n \t      store_info_t store_info = insn_info->store_rec;\n \t      deleted = true;\n-\t      \n+\n \t      while (store_info)\n \t\t{\n \t\t  if (store_info->alias_set)\n \t\t    {\n-\t\t      int index = get_bitmap_index (clear_alias_group, \n+\t\t      int index = get_bitmap_index (clear_alias_group,\n \t\t\t\t\t\t    store_info->alias_set);\n \t\t      if (index == 0 || !bitmap_bit_p (v, index))\n \t\t\t{\n \t\t\t  deleted = false;\n \t\t\t  break;\n \t\t\t}\n \t\t    }\n-\t\t  else \n+\t\t  else\n \t\t    deleted = false;\n \t\t  store_info = store_info->next;\n \t\t}\n \t      if (deleted && dbg_cnt (dse))\n \t\t{\n \t\t  if (dump_file)\n-\t\t    fprintf (dump_file, \"Spill deleting insn %d\\n\", \n+\t\t    fprintf (dump_file, \"Spill deleting insn %d\\n\",\n \t\t\t     INSN_UID (insn_info->insn));\n \t\t  check_for_inc_dec (insn_info->insn);\n \t\t  delete_insn (insn_info->insn);\n \t\t  spill_deleted++;\n \t\t  insn_info->insn = NULL;\n \t\t}\n \t    }\n-\t  \n-\t  if (insn_info->insn \n+\n+\t  if (insn_info->insn\n \t      && INSN_P (insn_info->insn)\n \t      && (!deleted))\n \t    {\n \t      scan_stores_spill (insn_info->store_rec, v, NULL);\n \t      scan_reads_spill (insn_info->read_rec, v, NULL);\n \t    }\n-\t      \n+\n \t  insn_info = insn_info->prev_insn;\n \t}\n     }\n@@ -3739,16 +3739,16 @@ dse_step6 (void)\n /*----------------------------------------------------------------------------\n    Seventh step.\n \n-   Destroy everything left standing. \n+   Destroy everything left standing.\n ----------------------------------------------------------------------------*/\n \n-static void \n+static void\n dse_step7 (bool global_done)\n {\n   unsigned int i;\n   group_info_t group;\n   basic_block bb;\n-  \n+\n   for (i = 0; VEC_iterate (group_info_t, rtx_group_vec, i, group); i++)\n     {\n       free (group->offset_map_n);\n@@ -3834,7 +3834,7 @@ rest_of_handle_dse (void)\n      pass to process the spills.  These are special in that they are\n      totally transparent, i.e, there is no aliasing issues that need\n      to be considered.  This means that the wild reads that kill\n-     everything else do not apply here.  */ \n+     everything else do not apply here.  */\n   if (clear_alias_sets && dse_step2_spill ())\n     {\n       if (!did_global)"}, {"sha": "3657d0be89b4374f0811623539672b1037c9a4cf", "filename": "gcc/dwarf2asm.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdwarf2asm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdwarf2asm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -268,7 +268,7 @@ dw2_asm_output_addr_rtx (int size, rtx addr,\n    If COMMENT is not NULL and comments in the debug information\n    have been requested by the user, append the given COMMENT\n    to the generated output.  */\n-   \n+\n void\n dw2_asm_output_nstring (const char *str, size_t orig_len,\n \t\t\tconst char *comment, ...)\n@@ -528,7 +528,7 @@ eh_data_format_name (int format)\n   };\n \n   gcc_assert (format >= 0 && format < 0x100 && format_names[format]);\n-  \n+\n   return format_names[format];\n #else\n   }"}, {"sha": "e7be9bdbaee8836c4a573c1dd2daa78a4e990e31", "filename": "gcc/dwarf2asm.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdwarf2asm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdwarf2asm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -30,7 +30,7 @@ extern void dw2_asm_output_delta (int, const char *, const char *,\n \t\t\t\t  const char *, ...)\n      ATTRIBUTE_NULL_PRINTF_4;\n \n-extern void dw2_asm_output_offset (int, const char *, section *, \n+extern void dw2_asm_output_offset (int, const char *, section *,\n \t\t\t\t   const char *, ...)\n      ATTRIBUTE_NULL_PRINTF_4;\n "}, {"sha": "3a6053e529de4400bf01e35033ec22603875c68d", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -804,7 +804,7 @@ add_fde_cfi (const char *label, dw_cfi_ref cfi)\n \n       /* Emit the state save.  */\n       emit_cfa_remember = false;\n-      cfi_remember = new_cfi (); \n+      cfi_remember = new_cfi ();\n       cfi_remember->dw_cfi_opc = DW_CFA_remember_state;\n       add_fde_cfi (label, cfi_remember);\n     }\n@@ -1042,7 +1042,7 @@ def_cfa_1 (const char *label, dw_cfa_location *loc_p)\n   if (loc.reg == old_cfa.reg && !loc.indirect)\n     {\n       /* Construct a \"DW_CFA_def_cfa_offset <offset>\" instruction, indicating\n-\t the CFA register did not change but the offset did.  The data \n+\t the CFA register did not change but the offset did.  The data\n \t factoring for DW_CFA_def_cfa_offset_sf happens in output_cfi, or\n \t in the assembler via the .cfi_def_cfa_offset directive.  */\n       if (loc.offset < 0)\n@@ -1882,7 +1882,7 @@ dwarf2out_frame_debug_cfa_offset (rtx set, const char *label)\n   addr = XEXP (set, 0);\n   gcc_assert (MEM_P (addr));\n   addr = XEXP (addr, 0);\n-  \n+\n   /* As documented, only consider extremely simple addresses.  */\n   switch (GET_CODE (addr))\n     {\n@@ -2870,7 +2870,7 @@ dwarf2out_begin_epilogue (rtx insn)\n void\n dwarf2out_frame_debug_restore_state (void)\n {\n-  dw_cfi_ref cfi = new_cfi (); \n+  dw_cfi_ref cfi = new_cfi ();\n   const char *label = dwarf2out_cfi_label (false);\n \n   cfi->dw_cfi_opc = DW_CFA_restore_state;\n@@ -9605,7 +9605,7 @@ htab_decl_del (void *what)\n   free (entry);\n }\n \n-/* Copy DIE and its ancestors, up to, but not including, the compile unit \n+/* Copy DIE and its ancestors, up to, but not including, the compile unit\n    or type unit entry, to a new tree.  Adds the new tree to UNIT and returns\n    a pointer to the copy of DIE.  If DECL_TABLE is provided, it is used\n    to check if the ancestor has already been copied into UNIT.  */\n@@ -14044,7 +14044,7 @@ add_loc_descr_to_each (dw_loc_list_ref list, dw_loc_descr_ref ref)\n \n    TODO: We handle only simple cases of RET or LIST having at most one\n    element. General case would inolve sorting the lists in program order\n-   and merging them that will need some additional work.  \n+   and merging them that will need some additional work.\n    Adding that will improve quality of debug info especially for SRA-ed\n    structures.  */\n \n@@ -14432,7 +14432,7 @@ loc_list_from_tree (tree loc, int want_address)\n \tif (bytepos > 0)\n \t  add_loc_descr_to_each (list_ret, new_loc_descr (DW_OP_plus_uconst, bytepos, 0));\n \telse if (bytepos < 0)\n-\t  loc_list_plus_const (list_ret, bytepos); \n+\t  loc_list_plus_const (list_ret, bytepos);\n \n \thave_address = 1;\n \tbreak;\n@@ -15041,11 +15041,11 @@ add_data_member_location_attribute (dw_die_ref die, tree decl)\n       else\n \t{\n \t  enum dwarf_location_atom op;\n-\t  \n+\n \t  /* The DWARF2 standard says that we should assume that the structure\n \t     address is already on the stack, so we can specify a structure\n \t     field address by using DW_OP_plus_uconst.  */\n-\t  \n+\n #ifdef MIPS_DEBUGGING_INFO\n \t  /* ??? The SGI dwarf reader does not handle the DW_OP_plus_uconst\n \t     operator correctly.  It works only if we leave the offset on the\n@@ -15054,7 +15054,7 @@ add_data_member_location_attribute (dw_die_ref die, tree decl)\n #else\n \t  op = DW_OP_plus_uconst;\n #endif\n-\t  \n+\n \t  loc_descr = new_loc_descr (op, offset, 0);\n \t}\n     }\n@@ -16889,7 +16889,7 @@ gen_array_type_die (tree type, dw_die_ref context_die)\n     add_subscript_info (array_die, type, collapse_nested_arrays);\n \n   /* Add representation of the type of the elements of this array type and\n-     emit the corresponding DIE if we haven't done it already.  */  \n+     emit the corresponding DIE if we haven't done it already.  */\n   element_type = TREE_TYPE (type);\n   if (collapse_nested_arrays)\n     while (TREE_CODE (element_type) == ARRAY_TYPE)\n@@ -17834,7 +17834,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t of the pack. Note that the set of pack arguments can be empty.\n \t In that case, the DW_TAG_GNU_formal_parameter_pack DIE will not have any\n \t children DIE.\n-\t\n+\n \t Otherwise, we just consider the parameters of DECL.  */\n       while (generic_decl_parm || parm)\n \t{\n@@ -19922,7 +19922,7 @@ gen_remaining_tmpl_value_param_die_attribute (void)\n \n \n /* Replace DW_AT_name for the decl with name.  */\n- \n+\n static void\n dwarf2out_set_name (tree decl, tree name)\n {\n@@ -20577,7 +20577,7 @@ prune_unused_types_mark (dw_die_ref die, int dokids)\n \t breaking out types into comdat sections, do this\n \t for all type definitions.  */\n       if (die->die_tag == DW_TAG_array_type\n-          || (dwarf_version >= 4 \n+          || (dwarf_version >= 4\n               && is_type_die (die) && ! is_declaration_die (die)))\n \tFOR_EACH_CHILD (die, c, prune_unused_types_mark (c, 1));\n       else"}, {"sha": "472ff2e57ae7d003b90db93fc8d8eb9cb1a196e2", "filename": "gcc/ebitmap.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Febitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Febitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Febitmap.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -88,15 +88,15 @@ ebitmap_last_set_bit (ebitmap map)\n   unsigned int i = 0;\n   ebitmap_iterator ebi;\n   bool foundbit = false;\n-  \n+\n   /* This is not the fastest way to do this, we could simply look for\n      the popcount, and start there, but this function is not used\n      anywhere speed critical.  */\n   EXECUTE_IF_SET_IN_EBITMAP (map, 0, i, ebi)\n     {\n       foundbit = true;\n     }\n-  \n+\n \n   if (foundbit)\n     return i;\n@@ -176,7 +176,7 @@ ebitmap_array_init (ebitmap map, unsigned int size)\n static inline void\n ebitmap_array_clear (ebitmap map)\n {\n-  if (map->elts) \n+  if (map->elts)\n     {\n       free (map->elts);\n       map->elts = NULL;\n@@ -225,15 +225,15 @@ ebitmap_clear_bit (ebitmap map, unsigned int bit)\n   unsigned int bitindex, shift;\n   bool have_eltwordindex = false;\n   EBITMAP_ELT_TYPE *elt_ptr;\n-  \n+\n   /* If the bit can't exist in our bitmap, just return.  */\n   if (map->numwords == 0)\n     return;\n \n   if (wordindex >= map->wordmask->n_bits\n       || !TEST_BIT (map->wordmask, wordindex))\n     return;\n-  \n+\n   if (map->cache != NULL && map->cacheindex == wordindex)\n     elt_ptr = map->cache;\n   else\n@@ -242,18 +242,18 @@ ebitmap_clear_bit (ebitmap map, unsigned int bit)\n       elt_ptr = &map->elts[eltwordindex];\n       have_eltwordindex = true;\n     }\n-  \n+\n   bitindex = bit % EBITMAP_ELT_BITS;\n   shift = bitindex;\n-  \n+\n   *(elt_ptr) &= ~(((EBITMAP_ELT_TYPE)1) << shift);\n \n   /* Clear out the empty words.  */\n   if (*(elt_ptr) == 0)\n     {\n       if (!have_eltwordindex)\n \teltwordindex = sbitmap_popcount (map->wordmask, wordindex);\n-      \n+\n       if (map->cache != NULL && map->cacheindex == eltwordindex)\n \tmap->cache = NULL;\n "}, {"sha": "b067ddb892a17131cb1bafe9ce9f4fc57d931ea7", "filename": "gcc/ebitmap.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Febitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Febitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Febitmap.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -26,7 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n #define EBITMAP_ELT_TYPE unsigned HOST_WIDEST_FAST_INT\n \n typedef struct ebitmap_def\n-{  \n+{\n   unsigned int n_elts;\t\t/* number of elements in the array.  */\n   sbitmap wordmask;\t\t/* wordmask saying which words are\n \t\t\t\t   nonzero.  */\n@@ -86,11 +86,11 @@ typedef struct {\n   /* The word mask iterator.  */\n   sbitmap_iterator maskiter;\n } ebitmap_iterator;\n-  \n+\n static inline void\n ebitmap_iter_init (ebitmap_iterator *i, ebitmap bmp, unsigned int min)\n {\n-  sbitmap_iter_init (&i->maskiter, bmp->wordmask, \n+  sbitmap_iter_init (&i->maskiter, bmp->wordmask,\n \t\t     min / EBITMAP_ELT_BITS);\n   i->size = bmp->numwords;\n   if (i->size == 0)"}, {"sha": "91212adadbc3f382886e26ca0aeeb6317ea7b6e9", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -73,7 +73,7 @@ enum machine_mode ptr_mode;\t/* Mode whose width is POINTER_SIZE.  */\n struct rtl_data x_rtl;\n \n /* Indexed by pseudo register number, gives the rtx for that pseudo.\n-   Allocated in parallel with regno_pointer_align.  \n+   Allocated in parallel with regno_pointer_align.\n    FIXME: We could put it into emit_status struct, but gengtype is not able to deal\n    with length attribute nested in top level structures.  */\n \n@@ -535,7 +535,7 @@ immed_double_const (HOST_WIDE_INT i0, HOST_WIDE_INT i1, enum machine_mode mode)\n \tgen_int_mode.\n      2) GET_MODE_BITSIZE (mode) == 2 * HOST_BITS_PER_WIDE_INT, but the value of\n \tthe integer fits into HOST_WIDE_INT anyway (i.e., i1 consists only\n-\tfrom copies of the sign bit, and sign of i0 and i1 are the same),  then \n+\tfrom copies of the sign bit, and sign of i0 and i1 are the same),  then\n \twe return a CONST_INT for i0.\n      3) Otherwise, we create a CONST_DOUBLE for i0 and i1.  */\n   if (mode != VOIDmode)\n@@ -865,7 +865,7 @@ gen_reg_rtx (enum machine_mode mode)\n   /* If a virtual register with bigger mode alignment is generated,\n      increase stack alignment estimation because it might be spilled\n      to stack later.  */\n-  if (SUPPORTS_STACK_ALIGNMENT \n+  if (SUPPORTS_STACK_ALIGNMENT\n       && crtl->stack_alignment_estimated < align\n       && !crtl->stack_realign_processed)\n     {\n@@ -1189,7 +1189,7 @@ gen_lowpart_common (enum machine_mode mode, rtx x)\n     innermode = mode_for_size (HOST_BITS_PER_WIDE_INT, MODE_INT, 0);\n   else if (innermode == VOIDmode)\n     innermode = mode_for_size (HOST_BITS_PER_WIDE_INT * 2, MODE_INT, 0);\n-  \n+\n   xsize = GET_MODE_SIZE (innermode);\n \n   gcc_assert (innermode != VOIDmode && innermode != BLKmode);\n@@ -1250,7 +1250,7 @@ gen_highpart (enum machine_mode mode, rtx x)\n   result = simplify_gen_subreg (mode, x, GET_MODE (x),\n \t\t\t\tsubreg_highpart_offset (mode, GET_MODE (x)));\n   gcc_assert (result);\n-  \n+\n   /* simplify_gen_subreg is not guaranteed to return a valid operand for\n      the target if we have a MEM.  gen_highpart must return a valid operand,\n      emitting code if necessary to do so.  */\n@@ -1259,7 +1259,7 @@ gen_highpart (enum machine_mode mode, rtx x)\n       result = validize_mem (result);\n       gcc_assert (result);\n     }\n-  \n+\n   return result;\n }\n \n@@ -1583,11 +1583,11 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \n   /* We can set the alignment from the type if we are making an object,\n      this is an INDIRECT_REF, or if TYPE_ALIGN_OK.  */\n-  if (objectp || TREE_CODE (t) == INDIRECT_REF \n-      || TREE_CODE (t) == ALIGN_INDIRECT_REF \n+  if (objectp || TREE_CODE (t) == INDIRECT_REF\n+      || TREE_CODE (t) == ALIGN_INDIRECT_REF\n       || TYPE_ALIGN_OK (type))\n     align = MAX (align, TYPE_ALIGN (type));\n-  else \n+  else\n     if (TREE_CODE (t) == MISALIGNED_INDIRECT_REF)\n       {\n \tif (integer_zerop (TREE_OPERAND (t, 1)))\n@@ -2465,7 +2465,7 @@ verify_rtx_sharing (rtx orig, rtx insn)\n     }\n #endif\n   gcc_assert (!RTX_FLAG (x, used));\n-  \n+\n   RTX_FLAG (x, used) = 1;\n \n   /* Now scan the subexpressions recursively.  */\n@@ -2673,7 +2673,7 @@ copy_rtx_if_shared_1 (rtx *orig1)\n   format_ptr = GET_RTX_FORMAT (code);\n   length = GET_RTX_LENGTH (code);\n   last_ptr = NULL;\n-  \n+\n   for (i = 0; i < length; i++)\n     {\n       switch (*format_ptr++)\n@@ -2689,12 +2689,12 @@ copy_rtx_if_shared_1 (rtx *orig1)\n \t    {\n \t      int j;\n \t      int len = XVECLEN (x, i);\n-              \n+\n               /* Copy the vector iff I copied the rtx and the length\n \t\t is nonzero.  */\n \t      if (copied && len > 0)\n \t\tXVEC (x, i) = gen_rtvec_v (len, XVEC (x, i)->elem);\n-              \n+\n               /* Call recursively on all inside the vector.  */\n \t      for (j = 0; j < len; j++)\n                 {\n@@ -2769,7 +2769,7 @@ reset_used_flags (rtx x)\n \n   format_ptr = GET_RTX_FORMAT (code);\n   length = GET_RTX_LENGTH (code);\n-  \n+\n   for (i = 0; i < length; i++)\n     {\n       switch (*format_ptr++)\n@@ -3812,7 +3812,7 @@ add_insn_before (rtx insn, rtx before, basic_block bb)\n       gcc_assert (stack);\n     }\n \n-  if (!bb \n+  if (!bb\n       && !BARRIER_P (before)\n       && !BARRIER_P (insn))\n     bb = BLOCK_FOR_INSN (before);\n@@ -5009,15 +5009,15 @@ rtx\n emit_note_copy (rtx orig)\n {\n   rtx note;\n-  \n+\n   note = rtx_alloc (NOTE);\n-  \n+\n   INSN_UID (note) = cur_insn_uid++;\n   NOTE_DATA (note) = NOTE_DATA (orig);\n   NOTE_KIND (note) = NOTE_KIND (orig);\n   BLOCK_FOR_INSN (note) = NULL;\n   add_insn (note);\n-  \n+\n   return note;\n }\n \n@@ -5996,7 +5996,7 @@ emit_copy_of_insn_after (rtx insn, rtx after)\n       SIBLING_CALL_P (new_rtx) = SIBLING_CALL_P (insn);\n       RTL_CONST_CALL_P (new_rtx) = RTL_CONST_CALL_P (insn);\n       RTL_PURE_CALL_P (new_rtx) = RTL_PURE_CALL_P (insn);\n-      RTL_LOOPING_CONST_OR_PURE_CALL_P (new_rtx) \n+      RTL_LOOPING_CONST_OR_PURE_CALL_P (new_rtx)\n \t= RTL_LOOPING_CONST_OR_PURE_CALL_P (insn);\n       break;\n "}, {"sha": "c15b6d8f2c31b2d58dae5e0ad359e8028d5ee40f", "filename": "gcc/et-forest.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fet-forest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fet-forest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fet-forest.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -210,7 +210,7 @@ record_path_before_1 (struct et_occ *occ, int depth)\n \n   if (occ->prev)\n     {\n-      m = record_path_before_1 (occ->prev, depth); \n+      m = record_path_before_1 (occ->prev, depth);\n       if (m < mn)\n \tmn = m;\n     }\n@@ -261,7 +261,7 @@ check_path_after_1 (struct et_occ *occ, int depth)\n \n   if (occ->next)\n     {\n-      m = check_path_after_1 (occ->next, depth); \n+      m = check_path_after_1 (occ->next, depth);\n       if (m < mn)\n \tmn =  m;\n     }\n@@ -308,7 +308,7 @@ et_splay (struct et_occ *occ)\n   record_path_before (occ);\n   et_check_tree_sanity (occ);\n #endif\n- \n+\n   while (occ->parent)\n     {\n       occ_depth = occ->depth;\n@@ -444,7 +444,7 @@ static struct et_occ *\n et_new_occ (struct et_node *node)\n {\n   struct et_occ *nw;\n-  \n+\n   if (!et_occurrences)\n     et_occurrences = create_alloc_pool (\"et_occ pool\", sizeof (struct et_occ), 300);\n   nw = (struct et_occ *) pool_alloc (et_occurrences);\n@@ -467,7 +467,7 @@ struct et_node *\n et_new_tree (void *data)\n {\n   struct et_node *nw;\n-  \n+\n   if (!et_nodes)\n     et_nodes = create_alloc_pool (\"et_node pool\", sizeof (struct et_node), 300);\n   nw = (struct et_node *) pool_alloc (et_nodes);\n@@ -590,7 +590,7 @@ et_split (struct et_node *t)\n \n   for (r = rmost->next; r->prev; r = r->prev)\n     continue;\n-  et_splay (r); \n+  et_splay (r);\n \n   r->prev->parent = NULL;\n   p_occ = t->parent_occ;"}, {"sha": "572aad0f8422e6a7a35ac617ab17fe8c607308db", "filename": "gcc/except.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -48,7 +48,7 @@ along with GCC; see the file COPYING3.  If not see\n    a given statement does throw.  During this lowering process,\n    we create an EH_LANDING_PAD node for each EH_REGION that has\n    some code within the function that needs to be executed if a\n-   throw does happen.  We also create RESX statements that are \n+   throw does happen.  We also create RESX statements that are\n    used to transfer control from an inner EH_REGION to an outer\n    EH_REGION.  We also create EH_DISPATCH statements as placeholders\n    for a runtime type comparison that should be made in order to\n@@ -75,7 +75,7 @@ along with GCC; see the file COPYING3.  If not see\n    handler for the exception must be within a function somewhere\n    up the call chain, so we call back into the exception runtime\n    (__builtin_unwind_resume).\n-   \n+\n    During pass_expand (cfgexpand.c), we generate REG_EH_REGION notes\n    that create an rtl to eh_region mapping that corresponds to the\n    gimple to eh_region mapping that had been recorded in the\n@@ -93,7 +93,7 @@ along with GCC; see the file COPYING3.  If not see\n    frame are emitted at this time.\n \n    During pass_convert_to_eh_region_ranges (except.c), we transform\n-   the REG_EH_REGION notes attached to individual insns into \n+   the REG_EH_REGION notes attached to individual insns into\n    non-overlapping ranges of insns bounded by NOTE_INSN_EH_REGION_BEG\n    and NOTE_INSN_EH_REGION_END.  Each insn within such ranges has the\n    same associated action within the exception region tree, meaning\n@@ -611,7 +611,7 @@ duplicate_eh_regions (struct function *ifun,\n   data.eh_map = pointer_map_create ();\n \n   outer_region = get_eh_region_from_lp_number (outer_lp);\n-  \n+\n   /* Copy all the regions in the subtree.  */\n   if (copy_region)\n     duplicate_eh_regions_1 (&data, copy_region, outer_region);\n@@ -1490,7 +1490,7 @@ remove_eh_landing_pad (eh_landing_pad lp)\n   for (pp = &lp->region->landing_pads; *pp != lp; pp = &(*pp)->next_lp)\n     continue;\n   *pp = lp->next_lp;\n-  \n+\n   if (lp->post_landing_pad)\n     EH_LANDING_PAD_NR (lp->post_landing_pad) = 0;\n   VEC_replace (eh_landing_pad, cfun->eh->lp_array, lp->index, NULL);\n@@ -1555,7 +1555,7 @@ for_each_eh_label (void (*callback) (rtx))\n }\n \f\n /* Create the REG_EH_REGION note for INSN, given its ECF_FLAGS for a\n-   call insn. \n+   call insn.\n \n    At the gimple level, we use LP_NR\n        > 0 : The statement transfers to landing pad LP_NR"}, {"sha": "13aadd79ccbbe67afe17cb1e288b1d65cf01ebd0", "filename": "gcc/except.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -156,7 +156,7 @@ struct GTY(()) eh_region_d\n \t The normal way for this to happen is for there to be a CLEANUP region\n \t contained within this MUST_NOT_THROW region.  Note that if the\n \t runtime handles the MUST_NOT_THROW region, we have no control over\n-\t what termination function is called; it will be decided by the \n+\t what termination function is called; it will be decided by the\n \t personality function in effect for this CIE.  */\n       tree failure_decl;\n       /* The location assigned to the call of FAILURE_DECL, if expanded.  */"}, {"sha": "d51b45426778b34762eca666fff7bc98bd69ba96", "filename": "gcc/expmed.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -390,7 +390,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t always get higher addresses.  */\n       int inner_mode_size = GET_MODE_SIZE (GET_MODE (SUBREG_REG (op0)));\n       int outer_mode_size = GET_MODE_SIZE (GET_MODE (op0));\n-      \n+\n       byte_offset = 0;\n \n       /* Paradoxical subregs need special handling on big endian machines.  */\n@@ -2365,7 +2365,7 @@ struct alg_hash_entry {\n      Otherwise, the cost within which multiplication by T is\n      impossible.  */\n   struct mult_cost cost;\n- \n+\n   /* OPtimized for speed? */\n   bool speed;\n };\n@@ -3198,7 +3198,7 @@ expand_mult (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n \t\t\t\t   target, unsignedp);\n \t    }\n \t}\n-        \n+\n       /* We used to test optimize here, on the grounds that it's better to\n \t produce a smaller program when -O is not used.  But this causes\n \t such a terrible slowdown sometimes that it seems better to always\n@@ -3577,8 +3577,8 @@ expand_mult_highpart (enum machine_mode mode, rtx op0, rtx op1,\n \n   cnst1 = INTVAL (op1) & GET_MODE_MASK (mode);\n \n-  /* We can't optimize modes wider than BITS_PER_WORD. \n-     ??? We might be able to perform double-word arithmetic if \n+  /* We can't optimize modes wider than BITS_PER_WORD.\n+     ??? We might be able to perform double-word arithmetic if\n      mode == word_mode, however all the cost calculations in\n      synth_mult etc. assume single-word operations.  */\n   if (GET_MODE_BITSIZE (wider_mode) > BITS_PER_WORD)\n@@ -4944,7 +4944,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t  if (!remainder)\n \t    {\n \t      remainder = gen_reg_rtx (compute_mode);\n-\t      if (!expand_twoval_binop_libfunc \n+\t      if (!expand_twoval_binop_libfunc\n \t\t  (unsignedp ? udivmod_optab : sdivmod_optab,\n \t\t   op0, op1,\n \t\t   NULL_RTX, remainder,\n@@ -4987,12 +4987,12 @@ make_tree (tree type, rtx x)\n \t\t && (GET_MODE_BITSIZE (TYPE_MODE (type))\n \t\t     < HOST_BITS_PER_WIDE_INT)))\n \t  hi = -1;\n-      \n+\n \tt = build_int_cst_wide (type, INTVAL (x), hi);\n-\t\n+\n \treturn t;\n       }\n-      \n+\n     case CONST_DOUBLE:\n       if (GET_MODE (x) == VOIDmode)\n \tt = build_int_cst_wide (type,\n@@ -5154,7 +5154,7 @@ emit_cstore (rtx target, enum insn_code icode, enum rtx_code code,\n     target_mode = result_mode;\n   if (!target)\n     target = gen_reg_rtx (target_mode);\n-  \n+\n   if (optimize\n       || !(insn_data[(int) icode].operand[0].predicate (target, result_mode)))\n     subtarget = gen_reg_rtx (result_mode);\n@@ -5530,7 +5530,7 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n       /* Cannot split ORDERED and UNORDERED, only try the above trick.   */\n       if (code == ORDERED || code == UNORDERED)\n \treturn 0;\n-\t\n+\n       and_them = split_comparison (code, mode, &first_code, &code);\n \n       /* If there are no NaNs, the first comparison should always fall through.\n@@ -5783,7 +5783,7 @@ emit_store_flag_force (rtx target, enum rtx_code code, rtx op0, rtx op1,\n   /* If this failed, we have to do this with set/compare/jump/set code.\n      For foo != 0, if foo is in OP0, just replace it with 1 if nonzero.  */\n   trueval = normalizep ? GEN_INT (normalizep) : const1_rtx;\n-  if (code == NE \n+  if (code == NE\n       && GET_MODE_CLASS (mode) == MODE_INT\n       && REG_P (target)\n       && op0 == target"}, {"sha": "75c17923cd0651d6bb790c6f5777fa7211bb2675", "filename": "gcc/expr.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -2311,7 +2311,7 @@ can_store_by_pieces (unsigned HOST_WIDE_INT len,\n   if (len == 0)\n     return 1;\n \n-  if (! (memsetp \n+  if (! (memsetp\n \t ? SET_BY_PIECES_P (len, align)\n \t : STORE_BY_PIECES_P (len, align)))\n     return 0;\n@@ -4511,7 +4511,7 @@ emit_storent_insn (rtx to, rtx from)\n \n    If CALL_PARAM_P is nonzero, this is a store into a call param on the\n    stack, and block moves may need to be treated specially.\n- \n+\n    If NONTEMPORAL is true, try using a nontemporal store instruction.  */\n \n rtx\n@@ -5753,7 +5753,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n    ALIAS_SET is the alias set for the destination.  This value will\n    (in general) be different from that for TARGET, since TARGET is a\n    reference to the containing structure.\n-   \n+\n    If NONTEMPORAL is true, try generating a nontemporal store.  */\n \n static rtx\n@@ -6143,7 +6143,7 @@ contains_packed_reference (const_tree exp)\n \tcase COMPONENT_REF:\n \t  {\n \t    tree field = TREE_OPERAND (exp, 1);\n-\t    packed_p = DECL_PACKED (field) \n+\t    packed_p = DECL_PACKED (field)\n \t\t       || TYPE_PACKED (TREE_TYPE (field))\n \t\t       || TYPE_PACKED (TREE_TYPE (exp));\n \t    if (packed_p)\n@@ -6750,7 +6750,7 @@ highest_pow2_factor_for_target (const_tree target, const_tree exp)\n {\n   unsigned HOST_WIDE_INT talign = target_align (target) / BITS_PER_UNIT;\n   unsigned HOST_WIDE_INT factor = highest_pow2_factor (exp);\n-  \n+\n   return MAX (factor, talign);\n }\n \f\n@@ -6940,7 +6940,7 @@ expand_expr_addr_expr_1 (tree exp, rtx target, enum machine_mode tmode,\n \n       if (modifier != EXPAND_NORMAL)\n \tresult = force_operand (result, NULL);\n-      tmp = expand_expr (offset, NULL_RTX, tmode, \n+      tmp = expand_expr (offset, NULL_RTX, tmode,\n \t\t\t modifier == EXPAND_INITIALIZER\n \t\t\t  ? EXPAND_INITIALIZER : EXPAND_NORMAL);\n \n@@ -7390,9 +7390,9 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \treturn CONST0_RTX (mode);\n       }\n \n-    case POINTER_PLUS_EXPR: \n+    case POINTER_PLUS_EXPR:\n       /* Even though the sizetype mode and the pointer's mode can be different\n-         expand is able to handle this correctly and get the correct result out \n+         expand is able to handle this correctly and get the correct result out\n          of the PLUS_EXPR code.  */\n       /* Make sure to sign-extend the sizetype offset in a POINTER_PLUS_EXPR\n          if sizetype precision is smaller than pointer precision.  */\n@@ -9330,7 +9330,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       /* If both modes are integral, then we can convert from one to the\n \t other.  */\n       else if (SCALAR_INT_MODE_P (GET_MODE (op0)) && SCALAR_INT_MODE_P (mode))\n-\top0 = convert_modes (mode, GET_MODE (op0), op0, \n+\top0 = convert_modes (mode, GET_MODE (op0), op0,\n \t\t\t     TYPE_UNSIGNED (TREE_TYPE (treeop0)));\n       /* As a last resort, spill op0 to memory, and reload it in a\n \t different mode.  */"}, {"sha": "93c66a8d474bcb1fb1b00222c584ed6025062103", "filename": "gcc/expr.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -395,7 +395,7 @@ extern rtx builtin_strncpy_read_str (void *, HOST_WIDE_INT, enum machine_mode);\n \f\n /* Functions from expr.c:  */\n \n-/* This is run during target initialization to set up which modes can be \n+/* This is run during target initialization to set up which modes can be\n    used directly in memory and to initialize the block move optab.  */\n extern void init_expr_target (void);\n \n@@ -484,7 +484,7 @@ extern rtx clear_storage_hints (rtx, rtx, enum block_op_methods,\n rtx set_storage_via_libcall (rtx, rtx, rtx, bool);\n \n /* Expand a setmem pattern; return true if successful.  */\n-extern bool set_storage_via_setmem (rtx, rtx, rtx, unsigned int, \n+extern bool set_storage_via_setmem (rtx, rtx, rtx, unsigned int,\n \t\t\t\t    unsigned int, HOST_WIDE_INT);\n \n /* Determine whether the LEN bytes can be moved by using several move\n@@ -546,7 +546,7 @@ extern rtx store_expr (tree, rtx, int, bool);\n extern rtx force_operand (rtx, rtx);\n \n /* Work horses for expand_expr.  */\n-extern rtx expand_expr_real (tree, rtx, enum machine_mode, \n+extern rtx expand_expr_real (tree, rtx, enum machine_mode,\n \t\t\t     enum expand_modifier, rtx *);\n extern rtx expand_expr_real_1 (tree, rtx, enum machine_mode,\n \t\t\t       enum expand_modifier, rtx *);"}, {"sha": "5d037f53933a2c38d9eea442f1469cb2a05f15df", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -1413,7 +1413,7 @@ int\n asm_str_count (const char *templ)\n {\n   int count = 1;\n-  \n+\n   if (!*templ)\n     return 0;\n "}, {"sha": "519aa920cd83fcedfa2c4c108de4e9ff700d4173", "filename": "gcc/flags.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -114,17 +114,17 @@ extern int optimize_size;\n /* True if this is the LTO front end (lto1).  This is used to disable\n    gimple generation and lowering passes that are normally run on the\n    output of a front end.  These passes must be bypassed for lto since\n-   they have already been done before the gimple was written.  */ \n+   they have already been done before the gimple was written.  */\n \n extern bool in_lto_p;\n \n /* Nonzero if we should write GIMPLE bytecode for link-time optimization.  */\n \n extern int flag_generate_lto;\n \n-/* Used to set the level of -Wstrict-aliasing, when no level is specified.  \n+/* Used to set the level of -Wstrict-aliasing, when no level is specified.\n    The external way to set the default level is to use\n-   -Wstrict-aliasing=level.  \n+   -Wstrict-aliasing=level.\n    ONOFF is assumed to take value 1 when -Wstrict-aliasing is specified,\n    and 0 otherwise.  After calling this function, wstrict_aliasing will be\n    set to the default value of -Wstrict_aliasing=level.  */\n@@ -264,8 +264,8 @@ extern bool sel_sched_switch_set;\n /* Whether to run the warn_unused_result attribute pass.  */\n extern bool flag_warn_unused_result;\n \n-/* Values of the -falign-* flags: how much to align labels in code. \n-   0 means `use default', 1 means `don't align'.  \n+/* Values of the -falign-* flags: how much to align labels in code.\n+   0 means `use default', 1 means `don't align'.\n    For each variable, there is an _log variant which is the power\n    of two not less than the variable, for .align output.  */\n "}, {"sha": "40a580e77a65dfbae8f3277b794e339047b6360c", "filename": "gcc/fold-const.c", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -1064,7 +1064,7 @@ negate_mathfn_p (enum built_in_function code)\n     CASE_FLT_FN (BUILT_IN_NEARBYINT):\n     CASE_FLT_FN (BUILT_IN_RINT):\n       return !flag_rounding_math;\n-    \n+\n     default:\n       break;\n     }\n@@ -1244,7 +1244,7 @@ fold_negate_expr (location_t loc, tree t)\n         return fold_build2_loc (loc, PLUS_EXPR, type, TREE_OPERAND (t, 0),\n                             build_int_cst (type, 1));\n       break;\n-      \n+\n     case INTEGER_CST:\n       tem = fold_negate_const (t, type);\n       if (TREE_OVERFLOW (tem) == TREE_OVERFLOW (t)\n@@ -1282,7 +1282,7 @@ fold_negate_expr (location_t loc, tree t)\n \t\t\t    fold_negate_expr (loc, TREE_OPERAND (t, 0)),\n \t\t\t    fold_negate_expr (loc, TREE_OPERAND (t, 1)));\n       break;\n-      \n+\n     case CONJ_EXPR:\n       if (negate_expr_p (t))\n \treturn fold_build1_loc (loc, CONJ_EXPR, type,\n@@ -2034,7 +2034,7 @@ const_binop (enum tree_code code, tree arg1, tree arg2, int notrunc)\n \t    tree compare = fold_build2 (LT_EXPR, boolean_type_node,\n \t\t\t\t\tfold_abs_const (r2, TREE_TYPE (type)),\n \t\t\t\t\tfold_abs_const (i2, TREE_TYPE (type)));\n-\t    \n+\n \t    if (integer_nonzerop (compare))\n \t      {\n \t\t/* In the TRUE branch, we compute\n@@ -2096,44 +2096,44 @@ const_binop (enum tree_code code, tree arg1, tree arg2, int notrunc)\n       tree type = TREE_TYPE(arg1);\n       int count = TYPE_VECTOR_SUBPARTS (type), i;\n       tree elements1, elements2, list = NULL_TREE;\n-      \n+\n       if(TREE_CODE(arg2) != VECTOR_CST)\n         return NULL_TREE;\n-        \n+\n       elements1 = TREE_VECTOR_CST_ELTS (arg1);\n       elements2 = TREE_VECTOR_CST_ELTS (arg2);\n \n       for (i = 0; i < count; i++)\n \t{\n           tree elem1, elem2, elem;\n-          \n+\n           /* The trailing elements can be empty and should be treated as 0 */\n           if(!elements1)\n             elem1 = fold_convert_const (NOP_EXPR, TREE_TYPE (type), integer_zero_node);\n           else\n             {\n               elem1 = TREE_VALUE(elements1);\n               elements1 = TREE_CHAIN (elements1);\n-            }  \n-            \n+            }\n+\n           if(!elements2)\n             elem2 = fold_convert_const (NOP_EXPR, TREE_TYPE (type), integer_zero_node);\n           else\n             {\n               elem2 = TREE_VALUE(elements2);\n               elements2 = TREE_CHAIN (elements2);\n             }\n-              \n+\n           elem = const_binop (code, elem1, elem2, notrunc);\n-          \n+\n           /* It is possible that const_binop cannot handle the given\n             code and return NULL_TREE */\n           if(elem == NULL_TREE)\n             return NULL_TREE;\n-          \n+\n           list = tree_cons (NULL_TREE, elem, list);\n \t}\n-      return build_vector(type, nreverse(list));  \n+      return build_vector(type, nreverse(list));\n     }\n   return NULL_TREE;\n }\n@@ -2573,7 +2573,7 @@ build_zero_vector (tree type)\n \n   elem = fold_convert_const (NOP_EXPR, TREE_TYPE (type), integer_zero_node);\n   units = TYPE_VECTOR_SUBPARTS (type);\n-  \n+\n   list = NULL_TREE;\n   for (i = 0; i < units; i++)\n     list = tree_cons (NULL_TREE, elem, list);\n@@ -3250,7 +3250,7 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \t\t\t\t   TREE_REAL_CST (arg1)))\n \t  return 1;\n \n-\t\n+\n \tif (!HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg0))))\n \t  {\n \t    /* If we do not distinguish between signed and unsigned zero,\n@@ -3409,7 +3409,7 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \n \tcase COND_EXPR:\n \t  return OP_SAME (0) && OP_SAME (1) && OP_SAME (2);\n-\t  \n+\n \tdefault:\n \t  return 0;\n \t}\n@@ -4126,7 +4126,7 @@ make_bit_field_ref (location_t loc, tree inner, tree type,\n       tree size = TYPE_SIZE (TREE_TYPE (inner));\n       if ((INTEGRAL_TYPE_P (TREE_TYPE (inner))\n \t   || POINTER_TYPE_P (TREE_TYPE (inner)))\n-\t  && host_integerp (size, 0) \n+\t  && host_integerp (size, 0)\n \t  && tree_low_cst (size, 0) == bitsize)\n \treturn fold_convert_loc (loc, type, inner);\n     }\n@@ -5536,7 +5536,7 @@ fold_cond_expr_with_comparison (location_t loc, tree type,\n \t    tem = fold_build2_loc (loc, MIN_EXPR, TREE_TYPE (arg00), arg00,\n \t\t\t\t   fold_convert_loc (loc, TREE_TYPE (arg00),\n \t\t\t\t\t\t     arg2));\n-\t    return pedantic_non_lvalue_loc (loc, \n+\t    return pedantic_non_lvalue_loc (loc,\n \t\t\t\t\t    fold_convert_loc (loc, type, tem));\n \t  }\n \tbreak;\n@@ -7271,7 +7271,7 @@ fold_single_bit_test (location_t loc, enum tree_code code,\n \t operations as unsigned.  If we must use the AND, we have a choice.\n \t Normally unsigned is faster, but for some machines signed is.  */\n #ifdef LOAD_EXTEND_OP\n-      ops_unsigned = (LOAD_EXTEND_OP (operand_mode) == SIGN_EXTEND \n+      ops_unsigned = (LOAD_EXTEND_OP (operand_mode) == SIGN_EXTEND\n \t\t      && !flag_syntax_only) ? 0 : 1;\n #else\n       ops_unsigned = 1;\n@@ -7556,7 +7556,7 @@ try_move_mult_to_index (location_t loc, tree addr, tree op1)\n \n       STRIP_NOPS (arg0);\n       STRIP_NOPS (arg1);\n-  \n+\n       if (TREE_CODE (arg0) == INTEGER_CST)\n         {\n           s = arg0;\n@@ -8445,7 +8445,7 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)\n     case FIX_TRUNC_EXPR:\n       if (TREE_TYPE (op0) == type)\n \treturn op0;\n-      \n+\n       /* If we have (type) (a CMP b) and type is an integral type, return\n          new expression involving the new type.  */\n       if (COMPARISON_CLASS_P (op0) && INTEGRAL_TYPE_P (type))\n@@ -9377,7 +9377,7 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t      && (code == EQ_EXPR\n \t\t  || code == NE_EXPR\n \t\t  || POINTER_TYPE_OVERFLOW_UNDEFINED))\n-\t\t\n+\n \t    {\n \t      if (code != EQ_EXPR\n \t\t  && code != NE_EXPR\n@@ -9652,7 +9652,7 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \n       /* Likewise, we can simplify a comparison of a real constant with\n          a MINUS_EXPR whose first operand is also a real constant, i.e.\n-         (c1 - x) < c2 becomes x > c1-c2.  Reordering is allowed on \n+         (c1 - x) < c2 becomes x > c1-c2.  Reordering is allowed on\n          floating-point types only if -fassociative-math is set.  */\n       if (flag_associative_math\n \t  && TREE_CODE (arg1) == REAL_CST\n@@ -9976,7 +9976,7 @@ get_pointer_modulus_and_residue (tree expr, unsigned HOST_WIDE_INT *residue,\n       tree op0, op1;\n       unsigned HOST_WIDE_INT modulus;\n       enum tree_code inner_code;\n-      \n+\n       op0 = TREE_OPERAND (expr, 0);\n       STRIP_NOPS (op0);\n       modulus = get_pointer_modulus_and_residue (op0, residue,\n@@ -9996,7 +9996,7 @@ get_pointer_modulus_and_residue (tree expr, unsigned HOST_WIDE_INT *residue,\n \t  if (TREE_CODE (op1) == INTEGER_CST)\n \t    {\n \t      unsigned HOST_WIDE_INT align;\n-\t      \n+\n \t      /* Compute the greatest power-of-2 divisor of op1.  */\n \t      align = TREE_INT_CST_LOW (op1);\n \t      align &= -align;\n@@ -10165,7 +10165,7 @@ fold_binary_loc (location_t loc,\n       if (TREE_CODE (arg0) == COND_EXPR || COMPARISON_CLASS_P (arg0))\n \t{\n \t  tem = fold_binary_op_with_conditional_arg (loc, code, type, op0, op1,\n-\t\t\t\t\t\t     arg0, arg1, \n+\t\t\t\t\t\t     arg0, arg1,\n \t\t\t\t\t\t     /*cond_first_p=*/1);\n \t  if (tem != NULL_TREE)\n \t    return tem;\n@@ -10174,7 +10174,7 @@ fold_binary_loc (location_t loc,\n       if (TREE_CODE (arg1) == COND_EXPR || COMPARISON_CLASS_P (arg1))\n \t{\n \t  tem = fold_binary_op_with_conditional_arg (loc, code, type, op0, op1,\n-\t\t\t\t\t\t     arg1, arg0, \n+\t\t\t\t\t\t     arg1, arg0,\n \t\t\t\t\t             /*cond_first_p=*/0);\n \t  if (tem != NULL_TREE)\n \t    return tem;\n@@ -10456,7 +10456,7 @@ fold_binary_loc (location_t loc,\n \t    return fold_build2_loc (loc, MULT_EXPR, type, arg0,\n \t\t\t\tbuild_real (type, dconst2));\n \n-          /* Convert a + (b*c + d*e) into (a + b*c) + d*e.  \n+          /* Convert a + (b*c + d*e) into (a + b*c) + d*e.\n              We associate floats only if the user has specified\n              -fassociative-math.  */\n           if (flag_associative_math\n@@ -10473,7 +10473,7 @@ fold_binary_loc (location_t loc,\n                   return fold_build2_loc (loc, PLUS_EXPR, type, tree0, tree11);\n                 }\n             }\n-          /* Convert (b*c + d*e) + a into b*c + (d*e +a).  \n+          /* Convert (b*c + d*e) + a into b*c + (d*e +a).\n              We associate floats only if the user has specified\n              -fassociative-math.  */\n           if (flag_associative_math\n@@ -10909,7 +10909,7 @@ fold_binary_loc (location_t loc,\n \t      tree diff = build2 (MINUS_EXPR, type, op0, op1);\n \t      return fold_build2_loc (loc, MULT_EXPR, type, diff,\n \t\t\t          fold_convert_loc (loc, type, esz));\n-\t\t\t          \n+\n \t    }\n \t}\n \n@@ -11288,7 +11288,7 @@ fold_binary_loc (location_t loc,\n \n \t  if (width > HOST_BITS_PER_WIDE_INT)\n \t    {\n-\t      mhi = (unsigned HOST_WIDE_INT) -1 \n+\t      mhi = (unsigned HOST_WIDE_INT) -1\n \t\t    >> (2 * HOST_BITS_PER_WIDE_INT - width);\n \t      mlo = -1;\n \t    }\n@@ -11475,7 +11475,7 @@ fold_binary_loc (location_t loc,\n \t\t\t    fold_convert_loc (loc, type, t1));\n \t  return t1;\n \t}\n-\t\n+\n       /* Convert ~X ^ ~Y to X ^ Y.  */\n       if (TREE_CODE (arg0) == BIT_NOT_EXPR\n \t  && TREE_CODE (arg1) == BIT_NOT_EXPR)\n@@ -11505,7 +11505,7 @@ fold_binary_loc (location_t loc,\n \t  && operand_equal_p (TREE_OPERAND (arg0, 1), arg1, 0))\n \t{\n \t  tem = fold_convert_loc (loc, type, TREE_OPERAND (arg0, 0));\n-\t  return fold_build2_loc (loc, BIT_AND_EXPR, type, \n+\t  return fold_build2_loc (loc, BIT_AND_EXPR, type,\n \t\t\t      fold_build1_loc (loc, BIT_NOT_EXPR, type, tem),\n \t\t\t      fold_convert_loc (loc, type, arg1));\n \t}\n@@ -11624,7 +11624,7 @@ fold_binary_loc (location_t loc,\n \t  && operand_equal_p (TREE_OPERAND (arg0, 1), arg1, 0))\n \t{\n \t  tem = fold_convert_loc (loc, type, TREE_OPERAND (arg0, 0));\n-\t  return fold_build2_loc (loc, BIT_AND_EXPR, type, \n+\t  return fold_build2_loc (loc, BIT_AND_EXPR, type,\n \t\t\t      fold_build1_loc (loc, BIT_NOT_EXPR, type, tem),\n \t\t\t      fold_convert_loc (loc, type, arg1));\n \t}\n@@ -11889,7 +11889,7 @@ fold_binary_loc (location_t loc,\n \t\t}\n \t    }\n \t}\n-      /* Convert A/B/C to A/(B*C).  */ \n+      /* Convert A/B/C to A/(B*C).  */\n       if (flag_reciprocal_math\n \t  && TREE_CODE (arg0) == RDIV_EXPR)\n \treturn fold_build2_loc (loc, RDIV_EXPR, type, TREE_OPERAND (arg0, 0),\n@@ -14222,7 +14222,7 @@ fold_checksum_tree (const_tree expr, struct md5_ctx *ctx, htab_t ht)\n   enum tree_code code;\n   union tree_node buf;\n   int i, len;\n-  \n+\n recursive_label:\n \n   gcc_assert ((sizeof (struct tree_exp) + 5 * sizeof (tree)\n@@ -14332,7 +14332,7 @@ fold_checksum_tree (const_tree expr, struct md5_ctx *ctx, htab_t ht)\n \t}\n       if (CODE_CONTAINS_STRUCT (TREE_CODE (expr), TS_DECL_WITH_VIS))\n \tfold_checksum_tree (DECL_SECTION_NAME (expr), ctx, ht);\n-\t  \n+\n       if (CODE_CONTAINS_STRUCT (TREE_CODE (expr), TS_DECL_NON_COMMON))\n \t{\n \t  fold_checksum_tree (DECL_VINDEX (expr), ctx, ht);\n@@ -14377,7 +14377,7 @@ debug_fold_checksum (const_tree t)\n   unsigned char checksum[16];\n   struct md5_ctx ctx;\n   htab_t ht = htab_create (32, htab_hash_pointer, htab_eq_pointer, NULL);\n-  \n+\n   md5_init_ctx (&ctx);\n   fold_checksum_tree (t, &ctx, ht);\n   md5_finish_ctx (&ctx, checksum);\n@@ -14412,14 +14412,14 @@ fold_build1_stat_loc (location_t loc,\n   md5_finish_ctx (&ctx, checksum_before);\n   htab_empty (ht);\n #endif\n-  \n+\n   tem = fold_unary_loc (loc, code, type, op0);\n   if (!tem)\n     {\n       tem = build1_stat (code, type, op0 PASS_MEM_STAT);\n       SET_EXPR_LOCATION (tem, loc);\n     }\n-  \n+\n #ifdef ENABLE_FOLD_CHECKING\n   md5_init_ctx (&ctx);\n   fold_checksum_tree (op0, &ctx, ht);\n@@ -14470,7 +14470,7 @@ fold_build2_stat_loc (location_t loc,\n       tem = build2_stat (code, type, op0, op1 PASS_MEM_STAT);\n       SET_EXPR_LOCATION (tem, loc);\n     }\n-  \n+\n #ifdef ENABLE_FOLD_CHECKING\n   md5_init_ctx (&ctx);\n   fold_checksum_tree (op0, &ctx, ht);\n@@ -14479,7 +14479,7 @@ fold_build2_stat_loc (location_t loc,\n \n   if (memcmp (checksum_before_op0, checksum_after_op0, 16))\n     fold_check_failed (op0, tem);\n-  \n+\n   md5_init_ctx (&ctx);\n   fold_checksum_tree (op1, &ctx, ht);\n   md5_finish_ctx (&ctx, checksum_after_op1);\n@@ -14535,7 +14535,7 @@ fold_build3_stat_loc (location_t loc, enum tree_code code, tree type,\n       tem =  build3_stat (code, type, op0, op1, op2 PASS_MEM_STAT);\n       SET_EXPR_LOCATION (tem, loc);\n     }\n-      \n+\n #ifdef ENABLE_FOLD_CHECKING\n   md5_init_ctx (&ctx);\n   fold_checksum_tree (op0, &ctx, ht);\n@@ -14544,15 +14544,15 @@ fold_build3_stat_loc (location_t loc, enum tree_code code, tree type,\n \n   if (memcmp (checksum_before_op0, checksum_after_op0, 16))\n     fold_check_failed (op0, tem);\n-  \n+\n   md5_init_ctx (&ctx);\n   fold_checksum_tree (op1, &ctx, ht);\n   md5_finish_ctx (&ctx, checksum_after_op1);\n   htab_empty (ht);\n \n   if (memcmp (checksum_before_op1, checksum_after_op1, 16))\n     fold_check_failed (op1, tem);\n-  \n+\n   md5_init_ctx (&ctx);\n   fold_checksum_tree (op2, &ctx, ht);\n   md5_finish_ctx (&ctx, checksum_after_op2);\n@@ -14597,7 +14597,7 @@ fold_build_call_array_loc (location_t loc, tree type, tree fn,\n #endif\n \n   tem = fold_builtin_call_array (loc, type, fn, nargs, argarray);\n-      \n+\n #ifdef ENABLE_FOLD_CHECKING\n   md5_init_ctx (&ctx);\n   fold_checksum_tree (fn, &ctx, ht);\n@@ -14606,7 +14606,7 @@ fold_build_call_array_loc (location_t loc, tree type, tree fn,\n \n   if (memcmp (checksum_before_fn, checksum_after_fn, 16))\n     fold_check_failed (fn, tem);\n-  \n+\n   md5_init_ctx (&ctx);\n   for (i = 0; i < nargs; i++)\n     fold_checksum_tree (argarray[i], &ctx, ht);\n@@ -14952,10 +14952,10 @@ tree_binary_nonnegative_warnv_p (enum tree_code code, tree type, tree op0,\n \t  && (TREE_CODE (op0) == NOP_EXPR || TREE_CODE (op0) == INTEGER_CST)\n \t  && (TREE_CODE (op1) == NOP_EXPR || TREE_CODE (op1) == INTEGER_CST))\n \t{\n-\t  tree inner0 = (TREE_CODE (op0) == NOP_EXPR) \n+\t  tree inner0 = (TREE_CODE (op0) == NOP_EXPR)\n \t    ? TREE_TYPE (TREE_OPERAND (op0, 0))\n \t    : TREE_TYPE (op0);\n-\t  tree inner1 = (TREE_CODE (op1) == NOP_EXPR) \n+\t  tree inner1 = (TREE_CODE (op1) == NOP_EXPR)\n \t    ? TREE_TYPE (TREE_OPERAND (op1, 0))\n \t    : TREE_TYPE (op1);\n \n@@ -16003,7 +16003,7 @@ fold_build_cleanup_point_expr (tree type, tree expr)\n       if (!TREE_SIDE_EFFECTS (op))\n         return expr;\n     }\n-  \n+\n   return build1 (CLEANUP_POINT_EXPR, type, expr);\n }\n \n@@ -16067,17 +16067,17 @@ fold_indirect_ref_1 (location_t loc, tree type, tree op0)\n   /* ((foo*)&vectorfoo)[1] => BIT_FIELD_REF<vectorfoo,...> */\n   if (TREE_CODE (sub) == POINTER_PLUS_EXPR\n       && TREE_CODE (TREE_OPERAND (sub, 1)) == INTEGER_CST)\n-    { \n+    {\n       tree op00 = TREE_OPERAND (sub, 0);\n       tree op01 = TREE_OPERAND (sub, 1);\n       tree op00type;\n-      \n+\n       STRIP_NOPS (op00);\n       op00type = TREE_TYPE (op00);\n       if (TREE_CODE (op00) == ADDR_EXPR\n           && TREE_CODE (TREE_TYPE (op00type)) == VECTOR_TYPE\n           && type == TREE_TYPE (TREE_TYPE (op00type)))\n-\t{ \n+\t{\n \t  HOST_WIDE_INT offset = tree_low_cst (op01, 0);\n \t  tree part_width = TYPE_SIZE (type);\n \t  unsigned HOST_WIDE_INT part_widthi = tree_low_cst (part_width, 0)/BITS_PER_UNIT;\n@@ -16088,7 +16088,7 @@ fold_indirect_ref_1 (location_t loc, tree type, tree op0)\n \t    return fold_build3_loc (loc,\n \t\t\t\tBIT_FIELD_REF, type, TREE_OPERAND (op00, 0),\n \t\t\t\tpart_width, index);\n-        \n+\n \t}\n     }\n \n@@ -16113,7 +16113,7 @@ fold_indirect_ref_1 (location_t loc, tree type, tree op0)\n \t\t\t\tTREE_OPERAND (op00, 0));\n \t}\n     }\n-  \n+\n   /* *(foo *)fooarrptr => (*fooarrptr)[0] */\n   if (TREE_CODE (TREE_TYPE (subtype)) == ARRAY_TYPE\n       && type == TREE_TYPE (TREE_TYPE (subtype)))\n@@ -16437,7 +16437,7 @@ fold_strip_sign_ops (tree exp)\n       if (arg1)\n \treturn fold_build2_loc (loc, COMPOUND_EXPR, TREE_TYPE (exp), arg0, arg1);\n       break;\n-      \n+\n     case COND_EXPR:\n       arg0 = fold_strip_sign_ops (TREE_OPERAND (exp, 1));\n       arg1 = fold_strip_sign_ops (TREE_OPERAND (exp, 2));\n@@ -16447,7 +16447,7 @@ fold_strip_sign_ops (tree exp)\n \t\t\t    arg0 ? arg0 : TREE_OPERAND (exp, 1),\n \t\t\t    arg1 ? arg1 : TREE_OPERAND (exp, 2));\n       break;\n-      \n+\n     case CALL_EXPR:\n       {\n \tconst enum built_in_function fcode = builtin_mathfn_code (exp);"}, {"sha": "88e036c0857ed1ecde9e67b6e372734919fae884", "filename": "gcc/function.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -243,7 +243,7 @@ get_frame_size (void)\n \n bool\n frame_offset_overflow (HOST_WIDE_INT offset, tree func)\n-{  \n+{\n   unsigned HOST_WIDE_INT size = FRAME_GROWS_DOWNWARD ? -offset : offset;\n \n   if (size > ((unsigned HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (Pmode) - 1))\n@@ -710,7 +710,7 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size,\n   /* Try to find an available, already-allocated temporary of the proper\n      mode which meets the size and alignment requirements.  Choose the\n      smallest one with the closest alignment.\n-   \n+\n      If assign_stack_temp is called outside of the tree->rtl expansion,\n      we cannot reuse the stack slots (that may still refer to\n      VIRTUAL_STACK_VARS_REGNUM).  */\n@@ -1844,7 +1844,7 @@ aggregate_value_p (const_tree exp, const_tree fntype)\n      check for by-invisible-reference returns, typically for CALL_EXPR input\n      EXPressions.  */\n   const_tree fndecl = NULL_TREE;\n-  \n+\n   if (fntype)\n     switch (TREE_CODE (fntype))\n       {\n@@ -1887,7 +1887,7 @@ aggregate_value_p (const_tree exp, const_tree fntype)\n   if (TREE_CODE (exp) == CALL_EXPR && fndecl && DECL_RESULT (fndecl)\n       && DECL_BY_REFERENCE (DECL_RESULT (fndecl)))\n     return 1;\n-      \n+\n   if (targetm.calls.return_in_memory (type, fntype))\n     return 1;\n   /* Types that are TREE_ADDRESSABLE must be constructed in memory,\n@@ -1921,7 +1921,7 @@ use_register_for_decl (const_tree decl)\n {\n   if (!targetm.calls.allocate_stack_slots_for_args())\n     return true;\n-  \n+\n   /* Honor volatile.  */\n   if (TREE_SIDE_EFFECTS (decl))\n     return false;\n@@ -2501,7 +2501,7 @@ assign_parm_adjust_entry_rtl (struct assign_parm_data_one *data)\n \t locations.  The Irix 6 ABI has examples of this.  */\n       if (GET_CODE (entry_parm) == PARALLEL)\n \temit_group_store (validize_mem (stack_parm), entry_parm,\n-\t\t\t  data->passed_type, \n+\t\t\t  data->passed_type,\n \t\t\t  int_size_in_bytes (data->passed_type));\n       else\n \t{\n@@ -2626,7 +2626,7 @@ assign_parm_setup_block_p (struct assign_parm_data_one *data)\n   return false;\n }\n \n-/* A subroutine of assign_parms.  Arrange for the parameter to be \n+/* A subroutine of assign_parms.  Arrange for the parameter to be\n    present and valid in DATA->STACK_RTL.  */\n \n static void\n@@ -3167,7 +3167,7 @@ assign_parms (tree fndecl)\n \t      crtl->stack_alignment_estimated = align;\n \t    }\n \t}\n-\t\n+\n       if (cfun->stdarg && !TREE_CHAIN (parm))\n \tassign_parms_setup_varargs (&all, &data, false);\n \n@@ -3224,7 +3224,7 @@ assign_parms (tree fndecl)\n \t\t  crtl->stack_alignment_estimated = align;\n \t\t}\n \t    }\n-\t} \n+\t}\n     }\n \n   /* If we are receiving a struct value address as the first argument, set up\n@@ -3747,7 +3747,7 @@ setjmp_vars_warning (bitmap setjmp_crosses, tree block)\n \t  && DECL_RTL_SET_P (decl)\n \t  && REG_P (DECL_RTL (decl))\n \t  && regno_clobbered_at_setjmp (setjmp_crosses, REGNO (DECL_RTL (decl))))\n-\twarning (OPT_Wclobbered, \"variable %q+D might be clobbered by\" \n+\twarning (OPT_Wclobbered, \"variable %q+D might be clobbered by\"\n                  \" %<longjmp%> or %<vfork%>\", decl);\n     }\n \n@@ -3767,14 +3767,14 @@ setjmp_args_warning (bitmap setjmp_crosses)\n     if (DECL_RTL (decl) != 0\n \t&& REG_P (DECL_RTL (decl))\n \t&& regno_clobbered_at_setjmp (setjmp_crosses, REGNO (DECL_RTL (decl))))\n-      warning (OPT_Wclobbered, \n+      warning (OPT_Wclobbered,\n                \"argument %q+D might be clobbered by %<longjmp%> or %<vfork%>\",\n \t       decl);\n }\n \n /* Generate warning messages for variables live across setjmp.  */\n \n-void \n+void\n generate_setjmp_warnings (void)\n {\n   bitmap setjmp_crosses = regstat_get_setjmp_crosses ();\n@@ -4076,7 +4076,7 @@ pop_cfun (void)\n \n /* Return value of funcdef and increase it.  */\n int\n-get_next_funcdef_no (void) \n+get_next_funcdef_no (void)\n {\n   return funcdef_no++;\n }\n@@ -4135,7 +4135,7 @@ allocate_struct_function (tree fndecl, bool abstract_p)\n \t   && TYPE_ARG_TYPES (fntype) != 0\n \t   && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))\n \t       != void_type_node));\n-      \n+\n       /* Assume all registers in stdarg functions need to be saved.  */\n       cfun->va_list_gpr_size = VA_LIST_MAX_GPR_SIZE;\n       cfun->va_list_fpr_size = VA_LIST_MAX_FPR_SIZE;\n@@ -4229,8 +4229,8 @@ struct rtl_opt_pass pass_init_function =\n  {\n   RTL_PASS,\n   \"*init_function\",                     /* name */\n-  NULL,                                 /* gate */   \n-  init_function_for_compilation,        /* execute */       \n+  NULL,                                 /* gate */\n+  init_function_for_compilation,        /* execute */\n   NULL,                                 /* sub */\n   NULL,                                 /* next */\n   0,                                    /* static_pass_number */\n@@ -5005,15 +5005,15 @@ thread_prologue_and_epilogue_insns (void)\n       seq = gen_prologue ();\n       emit_insn (seq);\n \n-      /* Insert an explicit USE for the frame pointer \n+      /* Insert an explicit USE for the frame pointer\n          if the profiling is on and the frame pointer is required.  */\n       if (crtl->profile && frame_pointer_needed)\n \temit_use (hard_frame_pointer_rtx);\n \n       /* Retain a map of the prologue insns.  */\n       record_insns (seq, NULL, &prologue_insn_hash);\n       emit_note (NOTE_INSN_PROLOGUE_END);\n- \n+\n #ifndef PROFILE_BEFORE_PROLOGUE\n       /* Ensure that instructions are not moved into the prologue when\n \t profiling is on.  The call to the profiling routine can be\n@@ -5286,7 +5286,7 @@ thread_prologue_and_epilogue_insns (void)\n       for (insn = epilogue_end; insn; insn = next)\n \t{\n \t  next = NEXT_INSN (insn);\n-\t  if (NOTE_P (insn) \n+\t  if (NOTE_P (insn)\n \t      && (NOTE_KIND (insn) == NOTE_INSN_FUNCTION_BEG))\n \t    reorder_insns (insn, insn, PREV_INSN (epilogue_end));\n \t}\n@@ -5389,7 +5389,7 @@ reposition_prologue_and_epilogue_notes (void)\n \t  if (note)\n \t    {\n \t      /* If the function has a single basic block, and no real\n-\t\t epilogue insns (e.g. sibcall with no cleanup), the \n+\t\t epilogue insns (e.g. sibcall with no cleanup), the\n \t\t epilogue note can get scheduled before the prologue\n \t\t note.  If we have frame related prologue insns, having\n \t\t them scanned during the epilogue will result in a crash.\n@@ -5586,7 +5586,7 @@ struct rtl_opt_pass pass_thread_prologue_and_epilogue =\n \f\n \n /* This mini-pass fixes fall-out from SSA in asm statements that have\n-   in-out constraints.  Say you start with \n+   in-out constraints.  Say you start with\n \n      orig = inout;\n      asm (\"\": \"+mr\" (inout));"}, {"sha": "fb2965a2c6b74340ec4396f494fd55c168911cbe", "filename": "gcc/function.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -86,7 +86,7 @@ struct GTY(()) emit_status {\n \n \n /* Indexed by pseudo register number, gives the rtx for that pseudo.\n-   Allocated in parallel with regno_pointer_align.  \n+   Allocated in parallel with regno_pointer_align.\n    FIXME: We could put it into emit_status struct, but gengtype is not able to deal\n    with length attribute nested in top level structures.  */\n \n@@ -335,7 +335,7 @@ struct GTY(()) rtl_data {\n   /* The stack alignment estimated before reload, with consideration of\n      following factors:\n      1. Alignment of local stack variables (max_used_stack_slot_alignment)\n-     2. Alignment requirement to call other functions \n+     2. Alignment requirement to call other functions\n         (preferred_stack_boundary)\n      3. Alignment of non-local stack variables but might be spilled in\n         local stack.  */\n@@ -361,7 +361,7 @@ struct GTY(()) rtl_data {\n   /* Nonzero if function being compiled has nonlocal gotos to parent\n      function.  */\n   bool has_nonlocal_goto;\n-  \n+\n   /* Nonzero if function being compiled has an asm statement.  */\n   bool has_asm_statement;\n \n@@ -488,7 +488,7 @@ struct GTY(()) function {\n   tree static_chain_decl;\n \n   /* An expression that contains the non-local goto save area.  The first\n-     word is the saved frame pointer and the second is the saved stack \n+     word is the saved frame pointer and the second is the saved stack\n      pointer.  */\n   tree nonlocal_goto_save_area;\n \n@@ -553,7 +553,7 @@ struct GTY(()) function {\n      from nested functions.  */\n   unsigned int has_nonlocal_label : 1;\n \n-  /* Nonzero if we've set cannot_be_copied_reason.  I.e. if \n+  /* Nonzero if we've set cannot_be_copied_reason.  I.e. if\n      (cannot_be_copied_set && !cannot_be_copied_reason), the function\n      can in fact be copied.  */\n   unsigned int cannot_be_copied_set : 1;"}, {"sha": "1159211ae989bb16ffbdaff50d8af563de8341db", "filename": "gcc/fwprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -905,7 +905,7 @@ update_df (rtx insn, rtx *loc, df_ref *use_rec, enum df_ref_type type,\n          use was within a MEM.  */\n       new_use = df_ref_create (DF_REF_REG (orig_use), new_loc,\n \t\t\t       insn, BLOCK_FOR_INSN (insn),\n-\t\t\t       type, DF_REF_FLAGS (orig_use) | new_flags, \n+\t\t\t       type, DF_REF_FLAGS (orig_use) | new_flags,\n \t\t\t       width, offset, mode);\n \n       /* Set up the use-def chain.  */"}, {"sha": "543cb5a74b377ac09fd0ced0deefa04d0c27bde8", "filename": "gcc/gcc.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -2960,7 +2960,7 @@ execute (void)\n \n   commands[0].prog = argbuf[0]; /* first command.  */\n   commands[0].argv = &argbuf[0];\n- \n+\n   if (!wrapper_string)\n     {\n       string = find_a_file (&exec_prefixes, commands[0].prog, X_OK, false);\n@@ -4309,7 +4309,7 @@ process_command (int argc, const char **argv)\n   /* Set up the search paths.  We add directories that we expect to\n      contain GNU Toolchain components before directories specified by\n      the machine description so that we will find GNU components (like\n-     the GNU assembler) before those of the host system.  */ \n+     the GNU assembler) before those of the host system.  */\n \n   /* If we don't know where the toolchain has been installed, use the\n      configured-in locations.  */\n@@ -6265,7 +6265,7 @@ handle_braces (const char *p)\n \t  if (atom == end_atom)\n \t    {\n \t      if (!n_way_choice || disj_matched || *p == '|'\n-\t\t  || a_is_negated || a_is_suffix || a_is_spectype \n+\t\t  || a_is_negated || a_is_suffix || a_is_spectype\n \t\t  || a_is_starred)\n \t\tgoto invalid;\n \n@@ -7048,9 +7048,9 @@ main (int argc, char **argv)\n       else if (*cross_compile == '0')\n \t{\n \t  add_prefix (&startfile_prefixes,\n-\t\t      concat (gcc_exec_prefix \n-\t\t\t      ? gcc_exec_prefix : standard_exec_prefix, \n-\t\t\t      machine_suffix, \n+\t\t      concat (gcc_exec_prefix\n+\t\t\t      ? gcc_exec_prefix : standard_exec_prefix,\n+\t\t\t      machine_suffix,\n \t\t\t      standard_startfile_prefix, NULL),\n \t\t      NULL, PREFIX_PRIORITY_LAST, 0, 1);\n \t}\n@@ -8564,9 +8564,9 @@ getenv_spec_function (int argc, const char **argv)\n       ptr[0] = '\\\\';\n       ptr[1] = *value++;\n     }\n-  \n+\n   strcpy (ptr, argv[1]);\n-  \n+\n   return result;\n }\n "}, {"sha": "c090c986784676a9997b9f67b30be6f62b77b6db", "filename": "gcc/gcov-dump.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgcov-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgcov-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-dump.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -157,7 +157,7 @@ dump_file (const char *filename)\n     const char *type = NULL;\n     int endianness = 0;\n     char m[4], v[4];\n-    \n+\n     if ((endianness = gcov_magic (magic, GCOV_DATA_MAGIC)))\n       type = \"data\";\n     else if ((endianness = gcov_magic (magic, GCOV_NOTE_MAGIC)))\n@@ -171,13 +171,13 @@ dump_file (const char *filename)\n     version = gcov_read_unsigned ();\n     GCOV_UNSIGNED2STRING (v, version);\n     GCOV_UNSIGNED2STRING (m, magic);\n-    \n+\n     printf (\"%s:%s:magic `%.4s':version `%.4s'%s\\n\", filename, type,\n  \t    m, v, endianness < 0 ? \" (swapped endianness)\" : \"\");\n     if (version != GCOV_VERSION)\n       {\n \tchar e[4];\n-\t\n+\n \tGCOV_UNSIGNED2STRING (e, GCOV_VERSION);\n \tprintf (\"%s:warning:current version is `%.4s'\\n\", filename, e);\n       }\n@@ -189,7 +189,7 @@ dump_file (const char *filename)\n \n     printf (\"%s:stamp %lu\\n\", filename, (unsigned long)stamp);\n   }\n-  \n+\n   while (1)\n     {\n       gcov_position_t base, position = gcov_position ();"}, {"sha": "6d371cdcddf28048364452a92ae3fc02603eea4b", "filename": "gcc/gcov-io.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgcov-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgcov-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -73,7 +73,7 @@ gcov_open (const char *name, int mode)\n   s_flock.l_len = 0; /* Until EOF.  */\n   s_flock.l_pid = getpid ();\n #endif\n-  \n+\n   gcc_assert (!gcov_var.file);\n   gcov_var.start = 0;\n   gcov_var.offset = gcov_var.length = 0;\n@@ -145,7 +145,7 @@ gcov_open (const char *name, int mode)\n #endif\n \n   setbuf (gcov_var.file, (char *)0);\n-  \n+\n   return 1;\n }\n \n@@ -200,12 +200,12 @@ static void\n gcov_allocate (unsigned length)\n {\n   size_t new_size = gcov_var.alloc;\n-  \n+\n   if (!new_size)\n     new_size = GCOV_BLOCK_SIZE;\n   new_size += length;\n   new_size *= 2;\n-  \n+\n   gcov_var.alloc = new_size;\n   gcov_var.buffer = XRESIZEVAR (gcov_unsigned_t, gcov_var.buffer, new_size << 2);\n }\n@@ -248,7 +248,7 @@ gcov_write_words (unsigned words)\n #endif\n   result = &gcov_var.buffer[gcov_var.offset];\n   gcov_var.offset += words;\n-  \n+\n   return result;\n }\n \n@@ -296,7 +296,7 @@ gcov_write_string (const char *string)\n       length = strlen (string);\n       alloc = (length + 4) >> 2;\n     }\n-  \n+\n   buffer = gcov_write_words (1 + alloc);\n \n   buffer[0] = alloc;\n@@ -317,7 +317,7 @@ gcov_write_tag (gcov_unsigned_t tag)\n \n   buffer[0] = tag;\n   buffer[1] = 0;\n-  \n+\n   return result;\n }\n \n@@ -389,7 +389,7 @@ gcov_read_words (unsigned words)\n {\n   const gcov_unsigned_t *result;\n   unsigned excess = gcov_var.length - gcov_var.offset;\n-  \n+\n   gcc_assert (gcov_var.mode > 0);\n   if (excess < words)\n     {\n@@ -472,7 +472,7 @@ GCOV_LINKAGE const char *\n gcov_read_string (void)\n {\n   unsigned length = gcov_read_unsigned ();\n-  \n+\n   if (!length)\n     return 0;\n \n@@ -485,7 +485,7 @@ gcov_read_summary (struct gcov_summary *summary)\n {\n   unsigned ix;\n   struct gcov_ctr_summary *csum;\n-  \n+\n   summary->checksum = gcov_read_unsigned ();\n   for (csum = summary->ctrs, ix = GCOV_COUNTERS_SUMMABLE; ix--; csum++)\n     {\n@@ -538,7 +538,7 @@ GCOV_LINKAGE time_t\n gcov_time (void)\n {\n   struct stat status;\n-  \n+\n   if (fstat (fileno (gcov_var.file), &status))\n     return 0;\n   else"}, {"sha": "ffc62ca7f6958485b89759d3a3a9c90cb972998e", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -61,7 +61,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    file. It need not be an absolute time stamp, merely a ticker that\n    increments fast enough and cycles slow enough to distinguish\n    different compile/run/compile cycles.\n-   \n+\n    Although the ident and version are formally 32 bit numbers, they\n    are derived from 4 character ASCII strings.  The version number\n    consists of the single character major version number, a two\n@@ -338,11 +338,11 @@ typedef HOST_WIDEST_INT gcov_type;\n /* Number of counters used for value profiling.  */\n #define GCOV_N_VALUE_COUNTERS \\\n   (GCOV_LAST_VALUE_COUNTER - GCOV_FIRST_VALUE_COUNTER + 1)\n-  \n+\n   /* A list of human readable names of the counters */\n #define GCOV_COUNTER_NAMES\t{\"arcs\", \"interval\", \"pow2\", \"single\", \\\n \t\t\t\t \"delta\",\"indirect_call\", \"average\", \"ior\"}\n-  \n+\n   /* Names of merge functions for counters.  */\n #define GCOV_MERGE_FUNCTIONS\t{\"__gcov_merge_add\",\t\\\n \t\t\t\t \"__gcov_merge_add\",\t\\\n@@ -352,7 +352,7 @@ typedef HOST_WIDEST_INT gcov_type;\n \t\t\t\t \"__gcov_merge_single\", \\\n \t\t\t\t \"__gcov_merge_add\",\t\\\n \t\t\t\t \"__gcov_merge_ior\"}\n-  \n+\n /* Convert a counter index to a tag.  */\n #define GCOV_TAG_FOR_COUNTER(COUNT)\t\t\t\t\\\n \t(GCOV_TAG_COUNTER_BASE + ((gcov_unsigned_t)(COUNT) << 17))\n@@ -438,7 +438,7 @@ struct gcov_info\n \n   gcov_unsigned_t stamp;\t/* uniquifying time stamp */\n   const char *filename;\t\t/* output file name */\n-  \n+\n   unsigned n_functions;\t\t/* number of functions */\n   const struct gcov_fn_info *functions; /* table of functions */\n \n@@ -469,7 +469,7 @@ extern void __gcov_merge_delta (gcov_type *, unsigned) ATTRIBUTE_HIDDEN;\n extern void __gcov_merge_ior (gcov_type *, unsigned) ATTRIBUTE_HIDDEN;\n \n /* The profiler functions.  */\n-extern void __gcov_interval_profiler (gcov_type *, gcov_type, int, unsigned); \n+extern void __gcov_interval_profiler (gcov_type *, gcov_type, int, unsigned);\n extern void __gcov_pow2_profiler (gcov_type *, gcov_type);\n extern void __gcov_one_value_profiler (gcov_type *, gcov_type);\n extern void __gcov_indirect_call_profiler (gcov_type *, gcov_type, void *, void *);"}, {"sha": "1d1fc0bc3585a9cb466ac2979a0002b2a91ecc4f", "filename": "gcc/gcov.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -684,7 +684,7 @@ create_file_names (const char *file_name)\n     *cptr = 0;\n \n   length = strlen (name);\n-  \n+\n   bbg_file_name = XNEWVEC (char, length + strlen (GCOV_NOTE_SUFFIX) + 1);\n   strcpy (bbg_file_name, name);\n   strcpy (bbg_file_name + length, GCOV_NOTE_SUFFIX);\n@@ -721,7 +721,7 @@ find_source (const char *file_name)\n       src->index = source_index++;\n       src->next = sources;\n       sources = src;\n-      \n+\n       if (!stat (file_name, &status))\n \tsrc->file_time = status.st_mtime;\n     }\n@@ -1043,7 +1043,7 @@ read_count_file (void)\n \n       GCOV_UNSIGNED2STRING (v, version);\n       GCOV_UNSIGNED2STRING (e, GCOV_VERSION);\n-      \n+\n       fnotice (stderr, \"%s:version '%.4s', prefer version '%.4s'\\n\",\n \t       da_file_name, v, e);\n     }\n@@ -1896,11 +1896,11 @@ output_lines (FILE *gcov_file, const source_t *src)\n \t{\n \t  arc_t *arc = fn->blocks[fn->num_blocks - 1].pred;\n \t  gcov_type return_count = fn->blocks[fn->num_blocks - 1].count;\n-\t  \n+\n \t  for (; arc; arc = arc->pred_next)\n \t    if (arc->fake)\n \t      return_count -= arc->count;\n-\t  \n+\n \t  fprintf (gcov_file, \"function %s\", fn->name);\n \t  fprintf (gcov_file, \" called %s\",\n \t\t   format_gcov (fn->blocks[0].count, 0, -1));"}, {"sha": "8be10cdbb3aa5d53ecea015059610b9141e6fa1b", "filename": "gcc/gcse.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -214,7 +214,7 @@ along with GCC; see the file COPYING3.  If not see\n \n    In addition, expressions in REG_EQUAL notes are candidates for GXSE-ing.\n    This allows PRE to hoist expressions that are expressed in multiple insns,\n-   such as comprex address calculations (e.g. for PIC code, or loads with a \n+   such as comprex address calculations (e.g. for PIC code, or loads with a\n    high part and as lowe part).\n \n    PRE handles moving invariant expressions out of loops (by treating them as\n@@ -843,17 +843,17 @@ can_assign_to_reg_without_clobbers_p (rtx x)\n      valid.  */\n   PUT_MODE (SET_DEST (PATTERN (test_insn)), GET_MODE (x));\n   SET_SRC (PATTERN (test_insn)) = x;\n-  \n+\n   icode = recog (PATTERN (test_insn), test_insn, &num_clobbers);\n   if (icode < 0)\n     return false;\n-  \n+\n   if (num_clobbers > 0 && added_clobbers_hard_reg_p (icode))\n     return false;\n-  \n+\n   if (targetm.cannot_copy_insn_p && targetm.cannot_copy_insn_p (test_insn))\n     return false;\n-  \n+\n   return true;\n }\n \n@@ -2094,7 +2094,7 @@ compute_transp (const_rtx x, int indx, sbitmap *bmap, int set_p)\n \n \t    /* Now iterate over the blocks which have memory modifications\n \t       but which do not have any calls.  */\n-\t    EXECUTE_IF_AND_COMPL_IN_BITMAP (modify_mem_list_set, \n+\t    EXECUTE_IF_AND_COMPL_IN_BITMAP (modify_mem_list_set,\n \t\t\t\t\t    blocks_with_calls,\n \t\t\t\t\t    0, bb_index, bi)\n \t      {\n@@ -2993,7 +2993,7 @@ bypass_block (basic_block bb, rtx setcc, rtx jump)\n   for (ei = ei_start (bb->preds); (e = ei_safe_edge (ei)); )\n     {\n       removed_p = 0;\n-\t  \n+\n       if (e->flags & EDGE_COMPLEX)\n \t{\n \t  ei_next (&ei);\n@@ -3328,7 +3328,7 @@ pre_expr_reaches_here_p_work (basic_block occr_bb, struct expr *expr, basic_bloc\n {\n   edge pred;\n   edge_iterator ei;\n-  \n+\n   FOR_EACH_EDGE (pred, ei, bb->preds)\n     {\n       basic_block pred_bb = pred->src;\n@@ -3410,7 +3410,7 @@ process_insert_insn (struct expr *expr)\n       if (insn_invalid_p (insn))\n \tgcc_unreachable ();\n     }\n-  \n+\n \n   pat = get_insns ();\n   end_sequence ();\n@@ -4980,7 +4980,7 @@ one_cprop_pass (void)\n      FIXME: This local pass should not be necessary after CSE (but for\n \t    some reason it still is).  It is also (proven) not necessary\n \t    to run the local pass right after FWPWOP.\n-\t    \n+\n      FIXME: The global analysis would not get into infinite loops if it\n \t    would use the DF solver (via df_simple_dataflow) instead of\n \t    the solver implemented in this file.  */\n@@ -5127,8 +5127,8 @@ struct rtl_opt_pass pass_rtl_cprop =\n  {\n   RTL_PASS,\n   \"cprop\",                              /* name */\n-  gate_rtl_cprop,                       /* gate */   \n-  execute_rtl_cprop,  \t\t\t/* execute */       \n+  gate_rtl_cprop,                       /* gate */\n+  execute_rtl_cprop,  \t\t\t/* execute */\n   NULL,                                 /* sub */\n   NULL,                                 /* next */\n   0,                                    /* static_pass_number */\n@@ -5148,8 +5148,8 @@ struct rtl_opt_pass pass_rtl_pre =\n  {\n   RTL_PASS,\n   \"rtl pre\",                            /* name */\n-  gate_rtl_pre,                         /* gate */   \n-  execute_rtl_pre,    \t\t\t/* execute */       \n+  gate_rtl_pre,                         /* gate */\n+  execute_rtl_pre,    \t\t\t/* execute */\n   NULL,                                 /* sub */\n   NULL,                                 /* next */\n   0,                                    /* static_pass_number */\n@@ -5169,8 +5169,8 @@ struct rtl_opt_pass pass_rtl_hoist =\n  {\n   RTL_PASS,\n   \"hoist\",                              /* name */\n-  gate_rtl_hoist,                       /* gate */   \n-  execute_rtl_hoist,  \t\t\t/* execute */       \n+  gate_rtl_hoist,                       /* gate */\n+  execute_rtl_hoist,  \t\t\t/* execute */\n   NULL,                                 /* sub */\n   NULL,                                 /* next */\n   0,                                    /* static_pass_number */"}, {"sha": "18bba53034d6d20bfebdc2fc5266e38c7a600ca8", "filename": "gcc/genattr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgenattr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgenattr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattr.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -256,7 +256,7 @@ main (int argc, char **argv)\n       printf (\"   define_insn_reservation will be changed after\\n\");\n       printf (\"   last call of dfa_start.  */\\n\");\n       printf (\"extern void dfa_clean_insn_cache (void);\\n\\n\");\n-      printf (\"extern void dfa_clear_single_insn_cache (rtx);\\n\\n\");      \n+      printf (\"extern void dfa_clear_single_insn_cache (rtx);\\n\\n\");\n       printf (\"/* Initiate and finish work with DFA.  They should be\\n\");\n       printf (\"   called as the first and the last interface\\n\");\n       printf (\"   functions.  */\\n\");"}, {"sha": "1e5198a3dadb4cddc04a7638810af685195e53a4", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -1941,22 +1941,22 @@ evaluate_eq_attr (rtx exp, rtx value, int insn_code, int insn_index)\n       else\n \tnewexp = false_rtx;\n       break;\n-      \n+\n     case SYMBOL_REF:\n       {\n \tchar *p;\n \tchar string[256];\n-\t\n+\n \tgcc_assert (GET_CODE (exp) == EQ_ATTR);\n \tgcc_assert (strlen (XSTR (exp, 0)) + strlen (XSTR (exp, 1)) + 2\n \t\t    <= 256);\n-\t\n+\n \tstrcpy (string, XSTR (exp, 0));\n \tstrcat (string, \"_\");\n \tstrcat (string, XSTR (exp, 1));\n \tfor (p = string; *p; p++)\n \t  *p = TOUPPER (*p);\n-\t\n+\n \tnewexp = attr_rtx (EQ, value,\n \t\t\t   attr_rtx (SYMBOL_REF,\n \t\t\t\t     DEF_ATTR_STRING (string)));\n@@ -1967,12 +1967,12 @@ evaluate_eq_attr (rtx exp, rtx value, int insn_code, int insn_index)\n       /* We construct an IOR of all the cases for which the\n \t requested attribute value is present.  Since we start with\n \t FALSE, if it is not present, FALSE will be returned.\n-\t  \n+\n \t Each case is the AND of the NOT's of the previous conditions with the\n \t current condition; in the default case the current condition is TRUE.\n-\t  \n+\n \t For each possible COND value, call ourselves recursively.\n-\t  \n+\n \t The extra TRUE and FALSE expressions will be eliminated by another\n \t call to the simplification routine.  */\n \n@@ -2108,7 +2108,7 @@ simplify_and_tree (rtx exp, rtx *pterm, int insn_code, int insn_index)\n \n       if (attr_alt_subset_p (exp, *pterm))\n \t*pterm = true_rtx;\n-\t\n+\n       return exp;\n     }\n \n@@ -4307,7 +4307,7 @@ gen_insn_reserv (rtx def)\n   decl->insn_num        = n_insn_reservs;\n   decl->bypassed\t= false;\n   decl->next            = 0;\n-  \n+\n   *last_insn_reserv_p = decl;\n   last_insn_reserv_p  = &decl->next;\n   n_insn_reservs++;\n@@ -4392,7 +4392,7 @@ make_automaton_attrs (void)\n \n   code_exp = rtx_alloc (COND);\n   lats_exp = rtx_alloc (COND);\n-  \n+\n   XVEC (code_exp, 0) = rtvec_alloc (n_insn_reservs * 2);\n   XVEC (lats_exp, 0) = rtvec_alloc (n_insn_reservs * 2);\n \n@@ -4405,7 +4405,7 @@ make_automaton_attrs (void)\n     {\n       XVECEXP (code_exp, 0, i)   = decl->condexp;\n       XVECEXP (lats_exp, 0, i)   = decl->condexp;\n-      \n+\n       XVECEXP (code_exp, 0, i+1) = make_numeric_value (decl->insn_num);\n       XVECEXP (lats_exp, 0, i+1) = make_numeric_value (decl->default_latency);\n     }"}, {"sha": "f3321410da5a6afd5b23678f4e7319ae5100fbc6", "filename": "gcc/genautomata.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -2382,7 +2382,7 @@ insert_bypass (struct bypass_decl *bypass)\n   struct bypass_decl *curr, *last;\n   struct insn_reserv_decl *out_insn_reserv = bypass->out_insn_reserv;\n   struct insn_reserv_decl *in_insn_reserv = bypass->in_insn_reserv;\n-  \n+\n   for (curr = out_insn_reserv->bypass_list, last = NULL;\n        curr != NULL;\n        last = curr, curr = curr->next)\n@@ -2420,7 +2420,7 @@ insert_bypass (struct bypass_decl *bypass)\n \t    last = curr;\n \t    break;\n \t  }\n-\t  \n+\n       }\n   if (last == NULL)\n     {\n@@ -2936,7 +2936,7 @@ process_regexp_cycles (regexp_t regexp, int max_start_cycle,\n       {\n \tint max_cycle = 0;\n \tint min_cycle = 0;\n-\t\n+\n \tfor (i = 0; i < REGEXP_ALLOF (regexp)->regexps_num; i++)\n \t  {\n \t    process_regexp_cycles (REGEXP_ALLOF (regexp)->regexps [i],\n@@ -2956,7 +2956,7 @@ process_regexp_cycles (regexp_t regexp, int max_start_cycle,\n       {\n \tint max_cycle = 0;\n \tint min_cycle = 0;\n-\t\n+\n \tfor (i = 0; i < REGEXP_ONEOF (regexp)->regexps_num; i++)\n \t  {\n \t    process_regexp_cycles (REGEXP_ONEOF (regexp)->regexps [i],\n@@ -4779,7 +4779,7 @@ transform_3 (regexp_t regexp)\n \t\t  default:\n \t\t    break;\n \t\t  }\n-\t      \n+\n \t      if (allof_length == 1)\n \t\tREGEXP_SEQUENCE (result)->regexps [i] = allof_op;\n \t      else\n@@ -4963,7 +4963,7 @@ store_alt_unit_usage (regexp_t regexp, regexp_t unit, int cycle,\n   length = (cycle + 1) * REGEXP_ONEOF (regexp)->regexps_num;\n   while (VEC_length (unit_usage_t, cycle_alt_unit_usages) < length)\n     VEC_safe_push (unit_usage_t, heap, cycle_alt_unit_usages, 0);\n-  \n+\n   index = cycle * REGEXP_ONEOF (regexp)->regexps_num + alt_num;\n   prev = NULL;\n   for (curr = VEC_index (unit_usage_t, cycle_alt_unit_usages, index);\n@@ -5078,14 +5078,14 @@ check_regexp_units_distribution (const char *insn_reserv_name,\n \t\t\tgcc_assert (unit->mode == rm_nothing);\n \t\t    }\n \t\t  break;\n-\t\t  \n+\n \t\tcase rm_unit:\n \t\t  store_alt_unit_usage (regexp, allof, j, i);\n \t\t  break;\n-\t\t  \n+\n \t\tcase rm_nothing:\n \t\t  break;\n-\t\t  \n+\n \t\tdefault:\n \t\t  gcc_unreachable ();\n \t\t}\n@@ -5101,10 +5101,10 @@ check_regexp_units_distribution (const char *insn_reserv_name,\n \t\tcase rm_unit:\n \t\t  store_alt_unit_usage (regexp, unit, 0, i);\n \t\t  break;\n-\t\t  \n+\n \t\tcase rm_nothing:\n \t\t  break;\n-\t\t  \n+\n \t\tdefault:\n \t\t  gcc_unreachable ();\n \t\t}\n@@ -5271,7 +5271,7 @@ process_seq_for_forming_states (regexp_t regexp, automaton_t automaton,\n         set_state_reserv (state_being_formed, curr_cycle,\n                           REGEXP_UNIT (regexp)->unit_decl->unit_num);\n       return curr_cycle;\n-      \n+\n     case rm_sequence:\n       for (i = 0; i < REGEXP_SEQUENCE (regexp)->regexps_num; i++)\n \tcurr_cycle\n@@ -5283,7 +5283,7 @@ process_seq_for_forming_states (regexp_t regexp, automaton_t automaton,\n       {\n \tint finish_cycle = 0;\n \tint cycle;\n-\t\n+\n \tfor (i = 0; i < REGEXP_ALLOF (regexp)->regexps_num; i++)\n \t  {\n \t    cycle = process_seq_for_forming_states (REGEXP_ALLOF (regexp)\n@@ -5819,7 +5819,7 @@ cache_presence (state_t state)\n   unsigned int sz;\n   sz = (description->query_units_num + sizeof (int) * CHAR_BIT - 1)\n         / (sizeof (int) * CHAR_BIT);\n-  \n+\n   state->presence_signature = XCREATENODEVEC (unsigned int, sz);\n   for (i = 0; i < description->units_num; i++)\n     if (units_array [i]->query_p)\n@@ -5965,7 +5965,7 @@ partition_equiv_class (state_t first_state, int odd_iteration_flag,\n \t       curr_state = next_state)\n \t    {\n \t      next_state = curr_state->next_equiv_class_state;\n-\t      if (state_is_differed (curr_state, first_state, \n+\t      if (state_is_differed (curr_state, first_state,\n \t\t\t\t     odd_iteration_flag))\n \t\t{\n \t\t  /* Remove curr state from the class equivalence.  */\n@@ -6705,11 +6705,11 @@ form_regexp (regexp_t regexp)\n \tconst char *name = (regexp->mode == rm_unit\n \t\t\t    ? REGEXP_UNIT (regexp)->name\n \t\t\t    : REGEXP_RESERV (regexp)->name);\n-\t\n+\n \tobstack_grow (&irp, name, strlen (name));\n \tbreak;\n       }\n-      \n+\n     case rm_sequence:\n       for (i = 0; i < REGEXP_SEQUENCE (regexp)->regexps_num; i++)\n \t{\n@@ -6735,7 +6735,7 @@ form_regexp (regexp_t regexp)\n         }\n       obstack_1grow (&irp, ')');\n       break;\n-      \n+\n     case rm_oneof:\n       for (i = 0; i < REGEXP_ONEOF (regexp)->regexps_num; i++)\n \t{\n@@ -6748,11 +6748,11 @@ form_regexp (regexp_t regexp)\n           obstack_1grow (&irp, ')');\n \t}\n       break;\n-      \n+\n     case rm_repeat:\n       {\n \tchar digits [30];\n-\t\n+\n \tif (REGEXP_REPEAT (regexp)->regexp->mode == rm_sequence\n \t    || REGEXP_REPEAT (regexp)->regexp->mode == rm_allof\n \t    || REGEXP_REPEAT (regexp)->regexp->mode == rm_oneof)\n@@ -7654,7 +7654,7 @@ output_dead_lock_vect (automaton_t automaton)\n   output_states_vect = 0;\n   pass_states (automaton, add_states_vect_el);\n \n-  VEC_safe_grow (vect_el_t, heap, dead_lock_vect, \n+  VEC_safe_grow (vect_el_t, heap, dead_lock_vect,\n \t\t VEC_length (state_t, output_states_vect));\n   for (i = 0; i < VEC_length (state_t, output_states_vect); i++)\n     {\n@@ -7709,7 +7709,7 @@ output_reserved_units_table (automaton_t automaton)\n \t\t\t * state_byte_size);\n \n   reserved_units_table = VEC_alloc (vect_el_t, heap, reserved_units_size);\n-\t\t \n+\n   for (i = 0; i < reserved_units_size; i++)\n     VEC_quick_push (vect_el_t, reserved_units_table, 0);\n   for (n = 0; n < VEC_length (state_t, output_states_vect); n++)\n@@ -8218,7 +8218,7 @@ output_min_insn_conflict_delay_func (void)\n   fprintf (output_file, \"}\\n\\n\");\n }\n \n-/* Output the array holding default latency values.  These are used in \n+/* Output the array holding default latency values.  These are used in\n    insn_latency and maximal_insn_latency function implementations.  */\n static void\n output_default_latencies (void)\n@@ -8442,7 +8442,7 @@ output_print_reservation_func (void)\n \t{\n \t  gcc_assert (j == DECL_INSN_RESERV (decl)->insn_num);\n \t  j++;\n-\t  \n+\n \t  fprintf (output_file, \"\\n      \\\"%s\\\",\",\n \t\t   regexp_representation (DECL_INSN_RESERV (decl)->regexp));\n \t  finish_regexp_representation ();"}, {"sha": "38487a051036314c138538a25eb6dcb08f3e8ca6", "filename": "gcc/genchecksum.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgenchecksum.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgenchecksum.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenchecksum.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -34,21 +34,21 @@ dosum (const char *file)\n   FILE *f;\n   unsigned char result[16];\n   int i;\n-  \n+\n   f = fopen (file, \"rb\");\n   if (!f)\n     {\n       fprintf (stderr, \"opening %s: %s\\n\", file, xstrerror (errno));\n       exit (1);\n     }\n-  \n+\n   /* Some executable formats have timestamps in the first 16 bytes, yuck.  */\n   if (fseek (f, 16, SEEK_SET) != 0)\n      {\n       fprintf (stderr, \"seeking in %s: %s\\n\", file, xstrerror (errno));\n       exit (1);\n     }\n-  \n+\n   if (md5_stream (f, result) != 0\n       || fclose (f) != 0)\n      {"}, {"sha": "a0a023dce47c99ae76e283dc75fb712738e81713", "filename": "gcc/genconfig.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgenconfig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgenconfig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconfig.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -57,7 +57,7 @@ static void gen_peephole (rtx);\n static void gen_peephole2 (rtx);\n \n /* RECOG_P will be nonzero if this pattern was seen in a context where it will\n-   be used to recognize, rather than just generate an insn. \n+   be used to recognize, rather than just generate an insn.\n \n    NON_PC_SET_SRC will be nonzero if this pattern was seen in a SET_SRC\n    of a SET whose destination is not (pc).  */\n@@ -287,13 +287,13 @@ main (int argc, char **argv)\n       desc = read_md_rtx (&line_no, &insn_code_number);\n       if (desc == NULL)\n \tbreak;\n-\t\n-      switch (GET_CODE (desc)) \n+\n+      switch (GET_CODE (desc))\n \t{\n   \t  case DEFINE_INSN:\n \t    gen_insn (desc);\n \t    break;\n-\t  \n+\n \t  case DEFINE_EXPAND:\n \t    gen_expand (desc);\n \t    break;"}, {"sha": "fcfd2f1bd899938e6d440ae90d77801eec4bc48e", "filename": "gcc/genflags.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgenflags.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgenflags.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenflags.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -195,15 +195,15 @@ gen_insn (int line_no, rtx insn)\n   int len;\n   int truth = maybe_eval_c_test (XSTR (insn, 2));\n \n-  lt = strchr (name, '<'); \n+  lt = strchr (name, '<');\n   if (lt && strchr (lt + 1, '>'))\n     {\n       message_with_line (line_no, \"unresolved iterator\");\n       have_error = 1;\n       return;\n     }\n \n-  gt = strchr (name, '>'); \n+  gt = strchr (name, '>');\n   if (lt || gt)\n     {\n       message_with_line (line_no,"}, {"sha": "c6b6e933cc569b372fb624bb8a79b02f89ca57bd", "filename": "gcc/gengtype-parse.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgengtype-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgengtype-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-parse.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -695,7 +695,7 @@ type (options_p *optsp, bool nested)\n     case UNION:\n       {\n \toptions_p opts = 0;\n-    /* GTY annotations follow attribute syntax \n+    /* GTY annotations follow attribute syntax\n        GTY_BEFORE_ID is for union/struct declarations\n        GTY_AFTER_ID is for variable declarations.  */\n     enum {\n@@ -729,22 +729,22 @@ type (options_p *optsp, bool nested)\n         is_gty = GTY_AFTER_ID;\n         opts = gtymarker_opt ();\n \t  }\n-        \n-    if (is_gty) \n+\n+    if (is_gty)\n       {\n         if (token () == '{')\n           {\n             pair_p fields;\n \n-            if (is_gty == GTY_AFTER_ID) \n+            if (is_gty == GTY_AFTER_ID)\n                 parse_error (\"GTY must be specified before identifier\");\n-              \n+\n             advance ();\n             fields = struct_field_seq ();\n             require ('}');\n             return new_structure (s, is_union, &lexer_line, fields, opts);\n           }\n-      } \n+      }\n     else if (token () == '{')\n       consume_balanced ('{', '}');\n \tif (opts)"}, {"sha": "91f3f57d7c9a77b6592f9161cfe90d6b91542c39", "filename": "gcc/gengtype.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -463,7 +463,7 @@ read_input_list (const char *listname)\n \t things there are.  (We do not bother resizing the arrays down.)  */\n       num_lang_dirs = langno;\n       /* Add the plugin files if provided.  */\n-      if (plugin_files) \n+      if (plugin_files)\n \t{\n \t  size_t i;\n \t  for (i = 0; i < nb_plugin_files; i++)\n@@ -976,7 +976,7 @@ write_rtx_next (void)\n {\n   outf_p f = get_output_file_with_visibility (NULL);\n   int i;\n-  if (!f) \n+  if (!f)\n     return;\n \n   oprintf (f, \"\\n/* Used to implement the RTX_NEXT macro.  */\\n\");\n@@ -1393,7 +1393,7 @@ set_gc_used_type (type_p t, enum gc_used_enum level, type_p param[NUM_PARAM])\n \t\t\t\t&length, &skip, &nested_ptr);\n \n \t    if (nested_ptr && f->type->kind == TYPE_POINTER)\n-\t      set_gc_used_type (nested_ptr, GC_POINTED_TO, \n+\t      set_gc_used_type (nested_ptr, GC_POINTED_TO,\n \t\t\t\tpass_param ? param : NULL);\n \t    else if (length && f->type->kind == TYPE_POINTER)\n \t      set_gc_used_type (f->type->u.p, GC_USED, NULL);\n@@ -1503,7 +1503,7 @@ create_file (const char *name, const char *oname)\n   return f;\n }\n \n-/* Print, like fprintf, to O.  \n+/* Print, like fprintf, to O.\n    N.B. You might think this could be implemented more efficiently\n    with vsnprintf().  Unfortunately, there are C libraries that\n    provide that function but without the C99 semantics for its return\n@@ -1517,7 +1517,7 @@ oprintf (outf_p o, const char *format, ...)\n \n   /* In plugin mode, the O could be a NULL pointer, so avoid crashing\n      in that case.  */\n-  if (!o) \n+  if (!o)\n     return;\n \n   va_start (ap, format);\n@@ -1564,7 +1564,7 @@ open_base_files (void)\n   {\n     /* The order of files here matters very much.  */\n     static const char *const ifiles [] = {\n-      \"config.h\", \"system.h\", \"coretypes.h\", \"tm.h\", \"varray.h\", \n+      \"config.h\", \"system.h\", \"coretypes.h\", \"tm.h\", \"varray.h\",\n       \"hashtab.h\", \"splay-tree.h\",  \"obstack.h\", \"bitmap.h\", \"input.h\",\n       \"tree.h\", \"rtl.h\", \"function.h\", \"insn-config.h\", \"expr.h\",\n       \"hard-reg-set.h\", \"basic-block.h\", \"cselib.h\", \"insn-addr.h\",\n@@ -1593,7 +1593,7 @@ static const char *\n get_file_realbasename (const char *f)\n {\n   const char * lastslash = strrchr (f, '/');\n-  \n+\n   return (lastslash != NULL) ? lastslash + 1 : f;\n }\n \n@@ -1635,7 +1635,7 @@ get_prefix_langdir_index (const char *f)\n     {\n       const char * langdir = lang_dir_names [lang_index];\n       size_t langdir_len = strlen (langdir);\n-\t  \n+\n       if (f_len > langdir_len\n \t  && IS_DIR_SEPARATOR (f[langdir_len])\n \t  && memcmp (f, langdir, langdir_len) == 0)\n@@ -1676,7 +1676,7 @@ get_file_gtfilename (const char *f)\n \n   const char *basename = get_file_realbasename (f);\n   const char *langdir = get_file_langdir (f);\n-  \n+\n   char * result =\n     (langdir ? xasprintf (\"gt-%s-%s\", langdir, basename)\n      : xasprintf (\"gt-%s\", basename));\n@@ -1735,7 +1735,7 @@ get_output_file_with_visibility (const char *input_file)\n       || (len > 2 && memcmp (basename+len-2, \".y\", 2) == 0)\n       || (len > 3 && memcmp (basename+len-3, \".in\", 3) == 0))\n     {\n-      output_name = get_file_gtfilename (input_file); \n+      output_name = get_file_gtfilename (input_file);\n       for_name = basename;\n     }\n   /* Some headers get used by more than one front-end; hence, it\n@@ -1761,7 +1761,7 @@ get_output_file_with_visibility (const char *input_file)\n   else if (strncmp (basename, \"objc\", 4) == 0 && IS_DIR_SEPARATOR (basename[4])\n \t   && strcmp (basename + 5, \"objc-act.h\") == 0)\n     output_name = \"gt-objc-objc-act.h\", for_name = \"objc/objc-act.c\";\n-  else \n+  else\n     {\n       int lang_index = get_prefix_langdir_index (basename);\n \n@@ -2172,9 +2172,9 @@ walk_type (type_p t, struct walk_type_data *d)\n \t\td->indent += 2;\n \t\td->val = xasprintf (\"x%d\", d->counter++);\n \t\toprintf (d->of, \"%*s%s %s * %s%s =\\n\", d->indent, \"\",\n-\t\t\t (nested_ptr_d->type->kind == TYPE_UNION \n-\t\t\t  ? \"union\" : \"struct\"), \n-\t\t\t nested_ptr_d->type->u.s.tag, \n+\t\t\t (nested_ptr_d->type->kind == TYPE_UNION\n+\t\t\t  ? \"union\" : \"struct\"),\n+\t\t\t nested_ptr_d->type->u.s.tag,\n \t\t\t d->fn_wants_lvalue ? \"\" : \"const \",\n \t\t\t d->val);\n \t\toprintf (d->of, \"%*s\", d->indent + 2, \"\");\n@@ -2262,7 +2262,7 @@ walk_type (type_p t, struct walk_type_data *d)\n \telse\n \t  oprintf (d->of, \"%s\", t->u.a.len);\n \toprintf (d->of, \");\\n\");\n-\t\n+\n \toprintf (d->of, \"%*sfor (i%d = 0; i%d != l%d; i%d++) {\\n\",\n \t\t d->indent, \"\",\n \t\t loopcounter, loopcounter, loopcounter, loopcounter);\n@@ -2790,8 +2790,8 @@ write_types (outf_p output_header, type_p structures, type_p param_structs,\n \t    continue;\n \t  }\n       }\n-  \n-  /* At last we emit the functions code.  */ \n+\n+  /* At last we emit the functions code.  */\n   oprintf (output_header, \"\\n/* functions code */\\n\");\n   for (s = structures; s; s = s->next)\n     if (s->gc_used == GC_POINTED_TO\n@@ -2807,7 +2807,7 @@ write_types (outf_p output_header, type_p structures, type_p param_structs,\n \t    break;\n \tif (opt)\n \t  continue;\n-\t\n+\n \tif (s->kind == TYPE_LANG_STRUCT)\n \t  {\n \t    type_p ss;\n@@ -2934,7 +2934,7 @@ write_local (outf_p output_header, type_p structures, type_p param_structs)\n {\n   type_p s;\n \n-  if (!output_header) \n+  if (!output_header)\n     return;\n   oprintf (output_header, \"\\n/* Local pointer-walking routines.  */\\n\");\n   for (s = structures; s; s = s->next)\n@@ -3021,7 +3021,7 @@ write_enum_defn (type_p structures, type_p param_structs)\n {\n   type_p s;\n \n-  if (!header_file) \n+  if (!header_file)\n     return;\n   oprintf (header_file, \"\\n/* Enumeration of types known.  */\\n\");\n   oprintf (header_file, \"enum gt_types_enum {\\n\");\n@@ -3073,7 +3073,7 @@ static void\n put_mangled_filename (outf_p f, const char *fn)\n {\n   const char *name = get_output_file_name (fn);\n-  if (!f || !name) \n+  if (!f || !name)\n     return;\n   for (; *name != 0; name++)\n     if (ISALNUM (*name))\n@@ -3719,11 +3719,11 @@ main (int argc, char **argv)\n         strcpy (plugin_files[i], name);\n       }\n     }\n-  else if (argc == 3) \n+  else if (argc == 3)\n     {\n       srcdir = argv[1];\n       inputlist = argv[2];\n-    } \n+    }\n   else\n     fatal (\"usage: gengtype [-P pluginout.h] srcdir input-list \"\n            \"[file1 file2 ... fileN]\");"}, {"sha": "cb58fa7af813d8d9a37a0953ffefe6d1f200f29e", "filename": "gcc/gengtype.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgengtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgengtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -20,7 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_GENGTYPE_H\n #define GCC_GENGTYPE_H\n \n-/* A file position, mostly for error messages.  \n+/* A file position, mostly for error messages.\n    The FILE element may be compared using pointer equality.  */\n struct fileloc {\n   const char *file;\n@@ -38,7 +38,7 @@ extern int lexer_toplevel_done;\n extern struct fileloc lexer_line;\n \n /* Print an error message.  */\n-extern void error_at_line \n+extern void error_at_line\n   (struct fileloc *pos, const char *msg, ...) ATTRIBUTE_PRINTF_2;\n \n /* Like asprintf, but calls fatal() on out of memory.  */"}, {"sha": "fb5c3113e543d1a5789776c68ce57f9fa3fd9f0c", "filename": "gcc/genmddeps.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgenmddeps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgenmddeps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmddeps.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -48,7 +48,7 @@ main (int argc, char **argv)\n \n   progname = \"genmddeps\";\n   include_callback = add_filedep;\n-  \n+\n   if (init_md_reader_args (argc, argv) != SUCCESS_EXIT_CODE)\n     return (FATAL_EXIT_CODE);\n "}, {"sha": "2aa559f3d259355f07c5c235bf44783176d3bf58", "filename": "gcc/genmodes.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -179,7 +179,7 @@ new_mode (enum mode_class cl, const char *name,\n   n_modes[cl]++;\n \n   *htab_find_slot (modes_by_name, m, INSERT) = m;\n-  \n+\n   return m;\n }\n \n@@ -230,7 +230,7 @@ new_adjust (const char *name,\n \t     mode_class_names[required_class_to] + 5);\n       return;\n     }\n-  \n+\n   for (a = *category; a; a = a->next)\n     if (a->mode == mode)\n       {\n@@ -1147,7 +1147,7 @@ emit_class_narrowest_mode (void)\n \t\t\t ? modes[c]->next->name\n \t\t\t : void_mode->name))\n \t\t   : void_mode->name);\n-  \n+\n   print_closer ();\n }\n \n@@ -1295,7 +1295,7 @@ emit_mode_adjustments (void)\n \t      a->file, a->line, a->adjustment);\n       printf (\"  mode_fbit[%smode] = s;\\n\", a->mode->name);\n     }\n-      \n+\n   /* Real mode formats don't have to propagate anywhere.  */\n   for (a = adj_format; a; a = a->next)\n     printf (\"\\n  /* %s:%d */\\n  REAL_MODE_FORMAT (%smode) = %s;\\n\",\n@@ -1397,7 +1397,7 @@ main (int argc, char **argv)\n \n   if (have_error)\n     return FATAL_EXIT_CODE;\n-  \n+\n   calc_wider_mode ();\n \n   if (gen_header)"}, {"sha": "d28baabba7fdf940548dc22325c2b637bbd77ee4", "filename": "gcc/genopinit.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -182,9 +182,9 @@ static const char * const optabs[] =\n   \"optab_handler (logb_optab, $A)->insn_code = CODE_FOR_$(logb$a2$)\",\n   \"optab_handler (ilogb_optab, $A)->insn_code = CODE_FOR_$(ilogb$a2$)\",\n   \"optab_handler (log_optab, $A)->insn_code = CODE_FOR_$(log$a2$)\",\n-  \"optab_handler (log10_optab, $A)->insn_code = CODE_FOR_$(log10$a2$)\",  \n-  \"optab_handler (log2_optab, $A)->insn_code = CODE_FOR_$(log2$a2$)\",  \n-  \"optab_handler (log1p_optab, $A)->insn_code = CODE_FOR_$(log1p$a2$)\",  \n+  \"optab_handler (log10_optab, $A)->insn_code = CODE_FOR_$(log10$a2$)\",\n+  \"optab_handler (log2_optab, $A)->insn_code = CODE_FOR_$(log2$a2$)\",\n+  \"optab_handler (log1p_optab, $A)->insn_code = CODE_FOR_$(log1p$a2$)\",\n   \"optab_handler (tan_optab, $A)->insn_code = CODE_FOR_$(tan$a2$)\",\n   \"optab_handler (atan_optab, $A)->insn_code = CODE_FOR_$(atan$a2$)\",\n   \"optab_handler (strlen_optab, $A)->insn_code = CODE_FOR_$(strlen$a$)\",\n@@ -366,14 +366,14 @@ gen_insn (rtx insn)\n \t\t\tbreak;\n \n \t\t    if (*p == 0\n-\t\t\t&& (! force_int || mode_class[i] == MODE_INT \n+\t\t\t&& (! force_int || mode_class[i] == MODE_INT\n \t\t\t    || mode_class[i] == MODE_VECTOR_INT)\n \t\t        && (! force_partial_int\n                             || mode_class[i] == MODE_INT\n                             || mode_class[i] == MODE_PARTIAL_INT\n \t\t\t    || mode_class[i] == MODE_VECTOR_INT)\n \t\t\t&& (! force_float\n-\t\t\t    || mode_class[i] == MODE_FLOAT \n+\t\t\t    || mode_class[i] == MODE_FLOAT\n \t\t\t    || mode_class[i] == MODE_DECIMAL_FLOAT\n \t\t\t    || mode_class[i] == MODE_COMPLEX_FLOAT\n \t\t\t    || mode_class[i] == MODE_VECTOR_FLOAT)"}, {"sha": "db56c0a4948eb91007aa55579e0c7535867a4aaf", "filename": "gcc/genpreds.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -102,7 +102,7 @@ process_define_predicate (rtx defn, int lineno)\n   for (p = XSTR (defn, 0) + 1; *p; p++)\n     if (!ISALNUM (*p) && *p != '_')\n       goto bad_name;\n-  \n+\n   if (validate_exp (XEXP (defn, 1), XSTR (defn, 0), lineno))\n     return;\n \n@@ -153,7 +153,7 @@ process_define_predicate (rtx defn, int lineno)\n    The only wart is that there's no way to insist on a { } string in\n    an RTL template, so we have to handle \"\" strings.  */\n \n-   \n+\n static void\n write_predicate_subfunction (struct pred_data *p)\n {\n@@ -290,7 +290,7 @@ mark_mode_tests (rtx exp)\n       NO_MODE_TEST (exp) = (NO_MODE_TEST (XEXP (exp, 0))\n \t\t\t    && NO_MODE_TEST (XEXP (exp, 1)));\n       break;\n-      \n+\n     case IOR:\n       mark_mode_tests (XEXP (exp, 0));\n       mark_mode_tests (XEXP (exp, 1));\n@@ -383,23 +383,23 @@ add_mode_tests (struct pred_data *p)\n \t  {\n \t    int test0 = NO_MODE_TEST (XEXP (subexp, 0));\n \t    int test1 = NO_MODE_TEST (XEXP (subexp, 1));\n-\t    \n+\n \t    gcc_assert (test0 || test1);\n-\t    \n+\n \t    if (test0 && test1)\n \t      goto break_loop;\n \t    pos = test0 ? &XEXP (subexp, 0) : &XEXP (subexp, 1);\n \t  }\n \t  break;\n-\t  \n+\n \tcase IF_THEN_ELSE:\n \t  {\n \t    int test0 = NO_MODE_TEST (XEXP (subexp, 0));\n \t    int test1 = NO_MODE_TEST (XEXP (subexp, 1));\n \t    int test2 = NO_MODE_TEST (XEXP (subexp, 2));\n-\t    \n+\n \t    gcc_assert ((test0 && test1) || test2);\n-\t    \n+\n \t    if (test0 && test1 && test2)\n \t      goto break_loop;\n \t    if (test0 && test1)\n@@ -411,7 +411,7 @@ add_mode_tests (struct pred_data *p)\n \t      pos = &XEXP (subexp, 2);\n \t  }\n \t  break;\n-\t  \n+\n \tdefault:\n \t  goto break_loop;\n \t}\n@@ -473,7 +473,7 @@ write_match_code (const char *path, const char *codes)\n \t  putchar (TOUPPER (*code));\n \t  code++;\n \t}\n-      \n+\n       if (*codes == ',')\n \tfputs (\" || \", stdout);\n     }\n@@ -493,7 +493,7 @@ write_predicate_expr (rtx exp)\n       write_predicate_expr (XEXP (exp, 1));\n       putchar (')');\n       break;\n-  \n+\n     case IOR:\n       putchar ('(');\n       write_predicate_expr (XEXP (exp, 0));\n@@ -801,7 +801,7 @@ add_constraint (const char *name, const char *regclass,\n       return;\n     }\n \n-  \n+\n   namelen = strlen (name);\n   slot = &constraints_by_letter_table[(unsigned int)name[0]];\n   for (iter = slot; *iter; iter = &(*iter)->next_this_letter)\n@@ -861,7 +861,7 @@ add_constraint (const char *name, const char *regclass,\n \t  else\n \t    message_with_line (lineno, \"constraint names beginning with '%c' \"\n \t\t\t       \"(%s) are reserved for %s constraints\",\n-\t\t\t       name[0], name, \n+\t\t\t       name[0], name,\n \t\t\t       GET_RTX_NAME (appropriate_code));\n \n \t  have_error = 1;\n@@ -896,7 +896,7 @@ add_constraint (const char *name, const char *regclass,\n \t}\n     }\n \n-  \n+\n   c = XOBNEW (rtl_obstack, struct constraint_data);\n   c->name = name;\n   c->c_name = need_mangled_name ? mangle (name) : name;\n@@ -1048,7 +1048,7 @@ write_insn_constraint_len (void)\n \t\"  return 1;\\n\"\n \t\"}\\n\");\n }\n-  \n+\n /* Write out the function which computes the register class corresponding\n    to a register constraint.  */\n static void\n@@ -1320,7 +1320,7 @@ write_tm_preds_h (void)\n   puts (\"#endif /* tm-preds.h */\");\n }\n \n-/* Write insn-preds.c.  \n+/* Write insn-preds.c.\n    N.B. the list of headers to include was copied from genrecog; it\n    may not be ideal.\n \n@@ -1367,7 +1367,7 @@ write_insn_preds_c (void)\n       if (have_register_constraints)\n \twrite_regclass_for_constraint ();\n       write_constraint_satisfied_p ();\n-      \n+\n       if (have_const_int_constraints)\n \twrite_insn_const_int_ok_for_constraint ();\n "}, {"sha": "f0b5613e05084faa0a12e7a2d8e9f62d7602989e", "filename": "gcc/gensupport.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -336,7 +336,7 @@ process_rtx (rtx desc, int lineno)\n \n \t/* Queue them.  */\n \tinsn_elem\n-\t  = queue_pattern (desc, &define_insn_tail, read_rtx_filename, \n+\t  = queue_pattern (desc, &define_insn_tail, read_rtx_filename,\n \t\t\t   lineno);\n \tsplit_elem\n \t  = queue_pattern (split, &other_tail, read_rtx_filename, lineno);\n@@ -875,7 +875,7 @@ process_one_cond_exec (struct queue_elem *ce_elem)\n \t  XVECEXP (split, 2, i) = pattern;\n \t}\n       /* Add the new split to the queue.  */\n-      queue_pattern (split, &other_tail, read_rtx_filename, \n+      queue_pattern (split, &other_tail, read_rtx_filename,\n \t\t     insn_elem->split->lineno);\n     }\n }\n@@ -927,7 +927,7 @@ init_md_reader_args_cb (int argc, char **argv, bool (*parse_opt)(const char *))\n     {\n       if (argv[i][0] != '-')\n \tcontinue;\n-      \n+\n       c = argv[i][1];\n       switch (c)\n \t{\n@@ -996,7 +996,7 @@ init_md_reader_args_cb (int argc, char **argv, bool (*parse_opt)(const char *))\n \t      /* Read stdin.  */\n \t      if (already_read_stdin)\n \t\tfatal (\"cannot read standard input twice\");\n-\t      \n+\n \t      base_dir = NULL;\n \t      read_rtx_filename = in_fname = \"<stdin>\";\n \t      read_rtx_lineno = 1;\n@@ -1405,7 +1405,7 @@ init_predicate_table (void)\n \tfor (j = 0; j < NUM_RTX_CODE; j++)\n \t  if (GET_RTX_CLASS (j) == RTX_CONST_OBJ)\n \t    add_predicate_code (pred, (enum rtx_code) j);\n-      \n+\n       add_predicate (pred);\n     }\n }"}, {"sha": "fc42f45d59c2bd4ba44b75d076040275a222ee2c", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -41,7 +41,7 @@ along with GCC; see the file COPYING3.  If not see\n # include <sys/mman.h>\n # ifdef HAVE_MINCORE\n /* This is on Solaris.  */\n-#  include <sys/types.h> \n+#  include <sys/types.h>\n # endif\n #endif\n \n@@ -101,7 +101,7 @@ static VEC(const_ggc_root_tab_t, heap) *extra_root_vec;\n /* Dynamically register a new GGC root table RT. This is useful for\n    plugins. */\n \n-void \n+void\n ggc_register_root_tab (const struct ggc_root_tab* rt)\n {\n   if (rt)\n@@ -523,11 +523,11 @@ gt_pch_save (FILE *f)\n \n   /* Try to arrange things so that no relocation is necessary, but\n      don't try very hard.  On most platforms, this will always work,\n-     and on the rest it's a lot of work to do better.  \n+     and on the rest it's a lot of work to do better.\n      (The extra work goes in HOST_HOOKS_GT_PCH_GET_ADDRESS and\n      HOST_HOOKS_GT_PCH_USE_ADDRESS.)  */\n   mmi.preferred_base = host_hooks.gt_pch_get_address (mmi.size, fileno (f));\n-      \n+\n   ggc_pch_this_base (state.d, mmi.preferred_base);\n \n   state.ptrs = XNEWVEC (struct ptr_data *, state.count);\n@@ -710,7 +710,7 @@ mmap_gt_pch_get_address (size_t size, int fd)\n }\n \n /* Default version of HOST_HOOKS_GT_PCH_USE_ADDRESS when mmap is present.\n-   Map SIZE bytes of FD+OFFSET at BASE.  Return 1 if we succeeded at \n+   Map SIZE bytes of FD+OFFSET at BASE.  Return 1 if we succeeded at\n    mapping the data at BASE, -1 if we couldn't.\n \n    This version assumes that the kernel honors the START operand of mmap\n@@ -802,7 +802,7 @@ ggc_min_heapsize_heuristic (void)\n   phys_kbytes /= 8;\n \n #if defined(HAVE_GETRLIMIT) && defined (RLIMIT_RSS)\n-  /* Try not to overrun the RSS limit while doing garbage collection.  \n+  /* Try not to overrun the RSS limit while doing garbage collection.\n      The RSS limit is only advisory, so no margin is subtracted.  */\n  {\n    struct rlimit rlim;"}, {"sha": "84b5c110c23a4423b5654b0b2dabc6ca71d39bf1", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -439,16 +439,16 @@ static struct globals\n     /* Total allocations and overhead for sizes less than 32, 64 and 128.\n        These sizes are interesting because they are typical cache line\n        sizes.  */\n-   \n+\n     unsigned long long total_allocated_under32;\n     unsigned long long total_overhead_under32;\n-  \n+\n     unsigned long long total_allocated_under64;\n     unsigned long long total_overhead_under64;\n-  \n+\n     unsigned long long total_allocated_under128;\n     unsigned long long total_overhead_under128;\n-  \n+\n     /* The allocations for each of the allocation orders.  */\n     unsigned long long total_allocated_per_order[NUM_ORDERS];\n \n@@ -945,7 +945,7 @@ free_page (page_entry *entry)\n       /* We cannot free a page from a context deeper than the current\n \t one.  */\n       gcc_assert (entry->context_depth == top->context_depth);\n-      \n+\n       /* Put top element into freed slot.  */\n       G.by_depth[i] = top;\n       G.save_in_use[i] = G.save_in_use[G.by_depth_in_use-1];\n@@ -1413,7 +1413,7 @@ ggc_free (void *p)\n \n #ifdef ENABLE_GC_ALWAYS_COLLECT\n   /* In the completely-anal-checking mode, we do *not* immediately free\n-     the data, but instead verify that the data is *actually* not \n+     the data, but instead verify that the data is *actually* not\n      reachable the next time we collect.  */\n   {\n     struct free_object *fo = XNEW (struct free_object);\n@@ -1440,7 +1440,7 @@ ggc_free (void *p)\n \t/* If the page is completely full, then it's supposed to\n \t   be after all pages that aren't.  Since we've freed one\n \t   object from a page that was full, we need to move the\n-\t   page to the head of the list. \n+\t   page to the head of the list.\n \n \t   PE is the node we want to move.  Q is the previous node\n \t   and P is the next node in the list.  */\n@@ -1484,7 +1484,7 @@ ggc_free (void *p)\n static void\n compute_inverse (unsigned order)\n {\n-  size_t size, inv; \n+  size_t size, inv;\n   unsigned int e;\n \n   size = OBJECT_SIZE (order);\n@@ -1744,7 +1744,7 @@ sweep_pages (void)\n \t\tG.pages[order] = next;\n \t      else\n \t\tprevious->next = next;\n-\t    \n+\n \t      /* Splice P out of the back pointers too.  */\n \t      if (next)\n \t\tnext->prev = previous;\n@@ -2044,7 +2044,7 @@ ggc_print_statistics (void)\n \t   SCALE (G.allocated), STAT_LABEL(G.allocated),\n \t   SCALE (total_overhead), STAT_LABEL (total_overhead));\n \n-#ifdef GATHER_STATISTICS  \n+#ifdef GATHER_STATISTICS\n   {\n     fprintf (stderr, \"\\nTotal allocations and overheads during the compilation process\\n\");\n \n@@ -2065,7 +2065,7 @@ ggc_print_statistics (void)\n              G.stats.total_overhead_under128);\n     fprintf (stderr, \"Total Allocated under 128B:            %10lld\\n\",\n              G.stats.total_allocated_under128);\n-   \n+\n     for (i = 0; i < NUM_ORDERS; i++)\n       if (G.stats.total_allocated_per_order[i])\n         {"}, {"sha": "cae23e128deb4d184a13d049a37a9021d138f87d", "filename": "gcc/ggc-zone.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fggc-zone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fggc-zone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-zone.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -426,13 +426,13 @@ struct alloc_zone\n     /* Total allocations and overhead for sizes less than 32, 64 and 128.\n        These sizes are interesting because they are typical cache line\n        sizes.  */\n-   \n+\n     unsigned long long total_allocated_under32;\n     unsigned long long total_overhead_under32;\n-  \n+\n     unsigned long long total_allocated_under64;\n     unsigned long long total_overhead_under64;\n-  \n+\n     unsigned long long total_allocated_under128;\n     unsigned long long total_overhead_under128;\n   } stats;\n@@ -1315,7 +1315,7 @@ ggc_alloc_zone_stat (size_t orig_size, struct alloc_zone *zone\n   /* Keep track of how many bytes are being allocated.  This\n      information is used in deciding when to collect.  */\n   zone->allocated += size;\n-  \n+\n   timevar_ggc_mem_total += size;\n \n #ifdef GATHER_STATISTICS\n@@ -1521,7 +1521,7 @@ ggc_set_mark (const void *p)\n       offset = (ptr - pch_zone.page) / BYTES_PER_MARK_BIT;\n       mark_word = offset / (8 * sizeof (mark_type));\n       mark_bit = offset % (8 * sizeof (mark_type));\n-      \n+\n       if (pch_zone.mark_bits[mark_word] & (1 << mark_bit))\n \treturn 1;\n       pch_zone.mark_bits[mark_word] |= (1 << mark_bit);\n@@ -1571,7 +1571,7 @@ ggc_marked_p (const void *p)\n       offset = (ptr - pch_zone.page) / BYTES_PER_MARK_BIT;\n       mark_word = offset / (8 * sizeof (mark_type));\n       mark_bit = offset % (8 * sizeof (mark_type));\n-      \n+\n       return (pch_zone.mark_bits[mark_word] & (1 << mark_bit)) != 0;\n     }\n \n@@ -1963,7 +1963,7 @@ ggc_collect_1 (struct alloc_zone *zone, bool need_marking)\n       ggc_prune_overhead_list ();\n #endif\n     }\n-  \n+\n   sweep_pages (zone);\n   zone->was_collected = true;\n   zone->allocated_last_gc = zone->allocated;\n@@ -2178,7 +2178,7 @@ ggc_print_statistics (void)\n \t      chunk = chunk->next_free;\n \t    }\n \t}\n-      \n+\n       fprintf (stderr, \"%20s %10lu%c %10lu%c %10lu%c\\n\",\n \t       zone->name,\n \t       SCALE (allocated), LABEL (allocated),\n@@ -2221,7 +2221,7 @@ ggc_print_statistics (void)\n \t   SCALE (total_allocated), LABEL(total_allocated),\n \t   SCALE (total_overhead), LABEL (total_overhead));\n \n-#ifdef GATHER_STATISTICS  \n+#ifdef GATHER_STATISTICS\n   {\n     unsigned long long all_overhead = 0, all_allocated = 0;\n     unsigned long long all_overhead_under32 = 0, all_allocated_under32 = 0;\n@@ -2240,7 +2240,7 @@ ggc_print_statistics (void)\n \n \tall_allocated_under64 += zone->stats.total_allocated_under64;\n \tall_overhead_under64 += zone->stats.total_overhead_under64;\n-\t\n+\n \tall_allocated_under128 += zone->stats.total_allocated_under128;\n \tall_overhead_under128 += zone->stats.total_overhead_under128;\n "}, {"sha": "bc94d6c0c1be3ebea7fe41d263b3525a9ca04584", "filename": "gcc/ggc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -226,7 +226,7 @@ extern void *ggc_realloc_stat (void *, size_t MEM_STAT_DECL);\n extern void *ggc_calloc (size_t, size_t);\n /* Free a block.  To be used when known for certain it's not reachable.  */\n extern void ggc_free (void *);\n- \n+\n extern void ggc_record_overhead (size_t, size_t, void * MEM_STAT_DECL);\n extern void ggc_free_overhead (void *);\n extern void ggc_prune_overhead_list (void);"}, {"sha": "9a3c382606eb1ed04cffeb3eb5a8a2c0ca170d94", "filename": "gcc/gimple-iterator.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgimple-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgimple-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -45,9 +45,9 @@ static void\n update_modified_stmts (gimple_seq seq)\n {\n   gimple_stmt_iterator gsi;\n- \n+\n   if (!ssa_operands_active ())\n-    return;  \n+    return;\n   for (gsi = gsi_start (seq); !gsi_end_p (gsi); gsi_next (&gsi))\n     update_stmt_if_modified (gsi_stmt (gsi));\n }\n@@ -60,7 +60,7 @@ static void\n update_bb_for_stmts (gimple_seq_node first, basic_block bb)\n {\n   gimple_seq_node n;\n-  \n+\n   for (n = first; n; n = n->next)\n     gimple_set_bb (n->stmt, bb);\n }"}, {"sha": "63d501deb50ee20a34de7b6fb2b8e44d46cc20ca", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -202,7 +202,7 @@ lower_function_body (void)\n   return 0;\n }\n \n-struct gimple_opt_pass pass_lower_cf = \n+struct gimple_opt_pass pass_lower_cf =\n {\n  {\n   GIMPLE_PASS,\n@@ -309,7 +309,7 @@ static void\n lower_omp_directive (gimple_stmt_iterator *gsi, struct lower_data *data)\n {\n   gimple stmt;\n-  \n+\n   stmt = gsi_stmt (*gsi);\n \n   lower_sequence (gimple_omp_body (stmt), data);\n@@ -616,7 +616,7 @@ block_may_fallthru (const_tree block)\n     {\n     case GOTO_EXPR:\n     case RETURN_EXPR:\n-      /* Easy cases.  If the last statement of the block implies \n+      /* Easy cases.  If the last statement of the block implies\n \t control transfer, then we can't fall through.  */\n       return false;\n \n@@ -659,7 +659,7 @@ block_may_fallthru (const_tree block)\n     case CALL_EXPR:\n       /* Functions that do not return do not fall through.  */\n       return (call_expr_flags (stmt) & ECF_NORETURN) == 0;\n-    \n+\n     case CLEANUP_POINT_EXPR:\n       return block_may_fallthru (TREE_OPERAND (stmt, 0));\n \n@@ -686,7 +686,7 @@ gimple_stmt_may_fallthru (gimple stmt)\n     case GIMPLE_GOTO:\n     case GIMPLE_RETURN:\n     case GIMPLE_RESX:\n-      /* Easy cases.  If the last statement of the seq implies \n+      /* Easy cases.  If the last statement of the seq implies\n \t control transfer, then we can't fall through.  */\n       return false;\n "}, {"sha": "6329d51f2da65b3a58faf65ea8ef01b35b735bd7", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -228,7 +228,7 @@ dump_gimple_fmt (pretty_printer *buffer, int spc, int flags,\n               default:\n                 gcc_unreachable ();\n             }\n-        } \n+        }\n       else\n         pp_character (buffer, *c);\n     }\n@@ -270,13 +270,13 @@ dump_unary_rhs (pretty_printer *buffer, gimple gs, int spc, int flags)\n       else\n \tdump_generic_node (buffer, rhs, spc, flags, false);\n       break;\n-      \n+\n     case PAREN_EXPR:\n       pp_string (buffer, \"((\");\n       dump_generic_node (buffer, rhs, spc, flags, false);\n       pp_string (buffer, \"))\");\n       break;\n-      \n+\n     case ABS_EXPR:\n       pp_string (buffer, \"ABS_EXPR <\");\n       dump_generic_node (buffer, rhs, spc, flags, false);"}, {"sha": "a04683a87ac00df5c86e2dc9d0574153de72ee4f", "filename": "gcc/gimple.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -171,7 +171,7 @@ gimple_set_subcode (gimple g, unsigned subcode)\n \n /* Build a tuple with operands.  CODE is the statement to build (which\n    must be one of the GIMPLE_WITH_OPS tuples).  SUBCODE is the sub-code\n-   for the new tuple.  NUM_OPS is the number of operands to allocate.  */ \n+   for the new tuple.  NUM_OPS is the number of operands to allocate.  */\n \n #define gimple_build_with_ops(c, s, n) \\\n   gimple_build_with_ops_stat (c, s, n MEM_STAT_INFO)\n@@ -350,7 +350,7 @@ gimple_build_assign_with_ops_stat (enum tree_code subcode, tree lhs, tree op1,\n   /* Need 1 operand for LHS and 1 or 2 for the RHS (depending on the\n      code).  */\n   num_ops = get_gimple_rhs_num_ops (subcode) + 1;\n-  \n+\n   p = gimple_build_with_ops_stat (GIMPLE_ASSIGN, (unsigned)subcode, num_ops\n   \t\t\t          PASS_MEM_STAT);\n   gimple_assign_set_lhs (p, lhs);\n@@ -375,7 +375,7 @@ gimple_build_assign_with_ops_stat (enum tree_code subcode, tree lhs, tree op1,\n \n gimple\n gimplify_assign (tree dst, tree src, gimple_seq *seq_p)\n-{ \n+{\n   tree t = build2 (MODIFY_EXPR, TREE_TYPE (dst), dst, src);\n   gimplify_and_add (t, seq_p);\n   ggc_free (t);\n@@ -485,7 +485,7 @@ gimple_build_goto (tree dest)\n \n /* Build a GIMPLE_NOP statement.  */\n \n-gimple \n+gimple\n gimple_build_nop (void)\n {\n   return gimple_alloc (GIMPLE_NOP, 0);\n@@ -517,7 +517,7 @@ gimple_build_bind (tree vars, gimple_seq body, tree block)\n    */\n \n static inline gimple\n-gimple_build_asm_1 (const char *string, unsigned ninputs, unsigned noutputs, \n+gimple_build_asm_1 (const char *string, unsigned ninputs, unsigned noutputs,\n                     unsigned nclobbers, unsigned nlabels)\n {\n   gimple p;\n@@ -539,7 +539,7 @@ gimple_build_asm_1 (const char *string, unsigned ninputs, unsigned noutputs,\n #ifdef GATHER_STATISTICS\n   gimple_alloc_sizes[(int) gimple_alloc_kind (GIMPLE_ASM)] += size;\n #endif\n-  \n+\n   return p;\n }\n \n@@ -555,7 +555,7 @@ gimple_build_asm_1 (const char *string, unsigned ninputs, unsigned noutputs,\n    LABELS is a vector of destination labels.  */\n \n gimple\n-gimple_build_asm_vec (const char *string, VEC(tree,gc)* inputs, \n+gimple_build_asm_vec (const char *string, VEC(tree,gc)* inputs,\n                       VEC(tree,gc)* outputs, VEC(tree,gc)* clobbers,\n \t\t      VEC(tree,gc)* labels)\n {\n@@ -564,10 +564,10 @@ gimple_build_asm_vec (const char *string, VEC(tree,gc)* inputs,\n \n   p = gimple_build_asm_1 (string,\n                           VEC_length (tree, inputs),\n-                          VEC_length (tree, outputs), \n+                          VEC_length (tree, outputs),\n                           VEC_length (tree, clobbers),\n \t\t\t  VEC_length (tree, labels));\n-  \n+\n   for (i = 0; i < VEC_length (tree, inputs); i++)\n     gimple_asm_set_input_op (p, i, VEC_index (tree, inputs, i));\n \n@@ -576,10 +576,10 @@ gimple_build_asm_vec (const char *string, VEC(tree,gc)* inputs,\n \n   for (i = 0; i < VEC_length (tree, clobbers); i++)\n     gimple_asm_set_clobber_op (p, i, VEC_index (tree, clobbers, i));\n-  \n+\n   for (i = 0; i < VEC_length (tree, labels); i++)\n     gimple_asm_set_label_op (p, i, VEC_index (tree, labels, i));\n-  \n+\n   return p;\n }\n \n@@ -684,7 +684,7 @@ gimple_build_resx (int region)\n    NLABELS is the number of labels in the switch excluding the default.\n    DEFAULT_LABEL is the default label for the switch statement.  */\n \n-gimple \n+gimple\n gimple_build_switch_nlabels (unsigned nlabels, tree index, tree default_label)\n {\n   /* nlabels + 1 default label + 1 index.  */\n@@ -700,10 +700,10 @@ gimple_build_switch_nlabels (unsigned nlabels, tree index, tree default_label)\n /* Build a GIMPLE_SWITCH statement.\n \n    INDEX is the switch's index.\n-   NLABELS is the number of labels in the switch excluding the DEFAULT_LABEL. \n+   NLABELS is the number of labels in the switch excluding the DEFAULT_LABEL.\n    ... are the labels excluding the default.  */\n \n-gimple \n+gimple\n gimple_build_switch (unsigned nlabels, tree index, tree default_label, ...)\n {\n   va_list al;\n@@ -779,7 +779,7 @@ gimple_build_debug_bind_stat (tree var, tree value, gimple stmt MEM_STAT_DECL)\n    BODY is the sequence of statements for which only one thread can execute.\n    NAME is optional identifier for this critical block.  */\n \n-gimple \n+gimple\n gimple_build_omp_critical (gimple_seq body, tree name)\n {\n   gimple p = gimple_alloc (GIMPLE_OMP_CRITICAL, 0);\n@@ -793,7 +793,7 @@ gimple_build_omp_critical (gimple_seq body, tree name)\n /* Build a GIMPLE_OMP_FOR statement.\n \n    BODY is sequence of statements inside the for loop.\n-   CLAUSES, are any of the OMP loop construct's clauses: private, firstprivate, \n+   CLAUSES, are any of the OMP loop construct's clauses: private, firstprivate,\n    lastprivate, reductions, ordered, schedule, and nowait.\n    COLLAPSE is the collapse count.\n    PRE_BODY is the sequence of statements that are loop invariant.  */\n@@ -822,8 +822,8 @@ gimple_build_omp_for (gimple_seq body, tree clauses, size_t collapse,\n    CHILD_FN is the function created for the parallel threads to execute.\n    DATA_ARG are the shared data argument(s).  */\n \n-gimple \n-gimple_build_omp_parallel (gimple_seq body, tree clauses, tree child_fn, \n+gimple\n+gimple_build_omp_parallel (gimple_seq body, tree clauses, tree child_fn,\n \t\t\t   tree data_arg)\n {\n   gimple p = gimple_alloc (GIMPLE_OMP_PARALLEL, 0);\n@@ -846,7 +846,7 @@ gimple_build_omp_parallel (gimple_seq body, tree clauses, tree child_fn,\n    COPY_FN is the optional function for firstprivate initialization.\n    ARG_SIZE and ARG_ALIGN are size and alignment of the data block.  */\n \n-gimple \n+gimple\n gimple_build_omp_task (gimple_seq body, tree clauses, tree child_fn,\n \t\t       tree data_arg, tree copy_fn, tree arg_size,\n \t\t       tree arg_align)\n@@ -884,7 +884,7 @@ gimple_build_omp_section (gimple_seq body)\n \n    BODY is the sequence of statements to be executed by just the master.  */\n \n-gimple \n+gimple\n gimple_build_omp_master (gimple_seq body)\n {\n   gimple p = gimple_alloc (GIMPLE_OMP_MASTER, 0);\n@@ -900,7 +900,7 @@ gimple_build_omp_master (gimple_seq body)\n    CONTROL_DEF is the definition of the control variable.\n    CONTROL_USE is the use of the control variable.  */\n \n-gimple \n+gimple\n gimple_build_omp_continue (tree control_def, tree control_use)\n {\n   gimple p = gimple_alloc (GIMPLE_OMP_CONTINUE, 0);\n@@ -914,7 +914,7 @@ gimple_build_omp_continue (tree control_def, tree control_use)\n    BODY is the sequence of statements inside a loop that will executed in\n    sequence.  */\n \n-gimple \n+gimple\n gimple_build_omp_ordered (gimple_seq body)\n {\n   gimple p = gimple_alloc (GIMPLE_OMP_ORDERED, 0);\n@@ -928,7 +928,7 @@ gimple_build_omp_ordered (gimple_seq body)\n /* Build a GIMPLE_OMP_RETURN statement.\n    WAIT_P is true if this is a non-waiting return.  */\n \n-gimple \n+gimple\n gimple_build_omp_return (bool wait_p)\n {\n   gimple p = gimple_alloc (GIMPLE_OMP_RETURN, 0);\n@@ -945,7 +945,7 @@ gimple_build_omp_return (bool wait_p)\n    CLAUSES are any of the OMP sections contsruct's clauses: private,\n    firstprivate, lastprivate, reduction, and nowait.  */\n \n-gimple \n+gimple\n gimple_build_omp_sections (gimple_seq body, tree clauses)\n {\n   gimple p = gimple_alloc (GIMPLE_OMP_SECTIONS, 0);\n@@ -972,7 +972,7 @@ gimple_build_omp_sections_switch (void)\n    CLAUSES are any of the OMP single construct's clauses: private, firstprivate,\n    copyprivate, nowait.  */\n \n-gimple \n+gimple\n gimple_build_omp_single (gimple_seq body, tree clauses)\n {\n   gimple p = gimple_alloc (GIMPLE_OMP_SINGLE, 0);\n@@ -1081,7 +1081,7 @@ gimple_seq_free (gimple_seq seq)\n   /* If this triggers, it's a sign that the same list is being freed\n      twice.  */\n   gcc_assert (seq != gimple_seq_cache || gimple_seq_cache == NULL);\n-  \n+\n   /* Add SEQ to the pool of free sequences.  */\n   seq->next_free = gimple_seq_cache;\n   gimple_seq_cache = seq;\n@@ -1179,7 +1179,7 @@ gimple_seq_copy (gimple_seq src)\n \n /* Walk all the statements in the sequence SEQ calling walk_gimple_stmt\n    on each one.  WI is as in walk_gimple_stmt.\n-   \n+\n    If walk_gimple_stmt returns non-NULL, the walk is stopped, the\n    value is stored in WI->CALLBACK_RESULT and the statement that\n    produced the value is returned.\n@@ -1789,7 +1789,7 @@ gimple_assign_single_p (gimple gs)\n    assignment.  I suspect there may be cases where gimple_assign_copy_p,\n    gimple_assign_single_p, or equivalent logic is used where a similar\n    treatment of unary NOPs is appropriate.  */\n-   \n+\n bool\n gimple_assign_unary_nop_p (gimple gs)\n {\n@@ -2902,7 +2902,7 @@ get_base_address (tree t)\n {\n   while (handled_component_p (t))\n     t = TREE_OPERAND (t, 0);\n-  \n+\n   if (SSA_VAR_P (t)\n       || TREE_CODE (t) == STRING_CST\n       || TREE_CODE (t) == CONSTRUCTOR"}, {"sha": "7a1503c9270b0d545b571186298ec441b5d43a9e", "filename": "gcc/gimple.def", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgimple.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgimple.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.def?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -32,7 +32,7 @@ DEFGSCODE(GIMPLE_ERROR_MARK, \"gimple_error_mark\", GSS_BASE)\n \n /* GIMPLE_COND <COND_CODE, OP1, OP2, TRUE_LABEL, FALSE_LABEL>\n    represents the conditional jump:\n-   \n+\n    if (OP1 COND_CODE OP2) goto TRUE_LABEL else goto FALSE_LABEL\n \n    COND_CODE is the tree code used as the comparison predicate.  It\n@@ -74,7 +74,7 @@ DEFGSCODE(GIMPLE_LABEL, \"gimple_label\", GSS_WITH_OPS)\n DEFGSCODE(GIMPLE_SWITCH, \"gimple_switch\", GSS_WITH_OPS)\n \n /* IMPORTANT.\n-   \n+\n    Do not rearrange the codes between GIMPLE_ASSIGN and GIMPLE_RETURN.\n    It's exposed by GIMPLE_RANGE_CHECK calls. These are all the GIMPLE\n    statements with memory and register operands.  */\n@@ -132,7 +132,7 @@ DEFGSCODE(GIMPLE_RETURN, \"gimple_return\", GSS_WITH_MEM_OPS)\n \n /* GIMPLE_BIND <VARS, BLOCK, BODY> represents a lexical scope.\n    VARS is the set of variables declared in that scope.\n-   BLOCK is the symbol binding block used for debug information.  \n+   BLOCK is the symbol binding block used for debug information.\n    BODY is the sequence of statements in the scope.  */\n DEFGSCODE(GIMPLE_BIND, \"gimple_bind\", GSS_BIND)\n \n@@ -190,7 +190,7 @@ DEFGSCODE(GIMPLE_NOP, \"gimple_nop\", GSS_BASE)\n \n \n /* IMPORTANT.\n-   \n+\n    Do not rearrange any of the GIMPLE_OMP_* codes.  This ordering is\n    exposed by the range check in gimple_omp_subcode().  */\n \n@@ -345,6 +345,6 @@ DEFGSCODE(GIMPLE_PREDICT, \"gimple_predict\", GSS_BASE)\n /*  This node represents a cleanup expression.  It is ONLY USED INTERNALLY\n     by the gimplifier as a placeholder for cleanups, and its uses will be\n     cleaned up by the time gimplification is done.\n-    \n+\n     This tuple should not exist outside of the gimplifier proper.  */\n DEFGSCODE(GIMPLE_WITH_CLEANUP_EXPR, \"gimple_with_cleanup_expr\", GSS_WCE)"}, {"sha": "7872d9e30e5e26bcc0724f9c8faec7f4cbe982be", "filename": "gcc/gimple.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -584,13 +584,13 @@ struct GTY(()) gimple_omp_for_iter {\n \n   /* Index variable.  */\n   tree index;\n-    \n+\n   /* Initial value.  */\n   tree initial;\n \n   /* Final value.  */\n   tree final;\n-                                 \n+\n   /* Increment.  */\n   tree incr;\n };\n@@ -700,7 +700,7 @@ struct GTY(()) gimple_statement_omp_single {\n };\n \n \n-/* GIMPLE_OMP_ATOMIC_LOAD.  \n+/* GIMPLE_OMP_ATOMIC_LOAD.\n    Note: This is based on gimple_statement_base, not g_s_omp, because g_s_omp\n    contains a sequence, which we don't need here.  */\n \n@@ -986,7 +986,7 @@ struct gimplify_ctx\n   gimple_seq conditional_cleanups;\n   tree exit_label;\n   tree return_temp;\n-  \n+\n   VEC(tree,heap) *case_labels;\n   /* The formal temporary table.  Should this be persistent?  */\n   htab_t temp_htab;\n@@ -1102,7 +1102,7 @@ gimple_has_substatements (gimple g)\n       return false;\n     }\n }\n-\t  \n+\n \n /* Return the basic block holding statement G.  */\n \n@@ -2493,7 +2493,7 @@ gimple_goto_dest (const_gimple gs)\n \n /* Set DEST to be the destination of the unconditonal jump GS.  */\n \n-static inline void \n+static inline void\n gimple_goto_set_dest (gimple gs, tree dest)\n {\n   GIMPLE_CHECK (gs, GIMPLE_GOTO);\n@@ -3368,7 +3368,7 @@ gimple_debug_bind_has_value_p (gimple dbg)\n \n /* Return the body for the OMP statement GS.  */\n \n-static inline gimple_seq \n+static inline gimple_seq\n gimple_omp_body (gimple gs)\n {\n   return gs->omp.body;\n@@ -4434,7 +4434,7 @@ gsi_start_bb (basic_block bb)\n {\n   gimple_stmt_iterator i;\n   gimple_seq seq;\n-  \n+\n   seq = bb_seq (bb);\n   i.ptr = gimple_seq_first (seq);\n   i.seq = seq;\n@@ -4585,7 +4585,7 @@ gsi_last_nondebug_bb (basic_block bb)\n }\n \n /* Return a pointer to the current stmt.\n-   \n+\n   NOTE: You may want to use gsi_replace on the iterator itself,\n   as this performs additional bookkeeping that will not be done\n   if you simply assign through a pointer returned by gsi_stmt_ptr.  */"}, {"sha": "a3c6834beff70b8ded0e5f8a50d829af8f81626e", "filename": "gcc/gimplify.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -803,7 +803,7 @@ gimple_set_do_not_emit_location (gimple g)\n static void\n annotate_one_with_location (gimple gs, location_t location)\n {\n-  if (!gimple_has_location (gs) \n+  if (!gimple_has_location (gs)\n       && !gimple_do_not_emit_location_p (gs)\n       && should_carry_location_p (gs))\n     gimple_set_location (gs, location);\n@@ -1445,20 +1445,20 @@ gimplify_switch_expr (tree *expr_p, gimple_seq *pre_p)\n       tree default_case = NULL_TREE;\n       size_t i, len;\n       gimple gimple_switch;\n-      \n+\n       /* If someone can be bothered to fill in the labels, they can\n \t be bothered to null out the body too.  */\n       gcc_assert (!SWITCH_LABELS (switch_expr));\n \n-      /* save old labels, get new ones from body, then restore the old \n+      /* save old labels, get new ones from body, then restore the old\n          labels.  Save all the things from the switch body to append after.  */\n       saved_labels = gimplify_ctxp->case_labels;\n       gimplify_ctxp->case_labels = VEC_alloc (tree, heap, 8);\n \n       gimplify_stmt (&SWITCH_BODY (switch_expr), &switch_body_seq);\n       labels = gimplify_ctxp->case_labels;\n       gimplify_ctxp->case_labels = saved_labels;\n- \n+\n       i = 0;\n       while (i < VEC_length (tree, labels))\n \t{\n@@ -1547,7 +1547,7 @@ gimplify_switch_expr (tree *expr_p, gimple_seq *pre_p)\n \t    }\n \t}\n \n-      gimple_switch = gimple_build_switch_vec (SWITCH_COND (switch_expr), \n+      gimple_switch = gimple_build_switch_vec (SWITCH_COND (switch_expr),\n                                                default_case, labels);\n       gimplify_seq_add_stmt (pre_p, gimple_switch);\n       gimplify_seq_add_seq (pre_p, switch_body_seq);\n@@ -1793,7 +1793,7 @@ gimplify_conversion (tree *expr_p)\n /* Nonlocal VLAs seen in the current function.  */\n static struct pointer_set_t *nonlocal_vlas;\n \n-/* Gimplify a VAR_DECL or PARM_DECL.  Returns GS_OK if we expanded a \n+/* Gimplify a VAR_DECL or PARM_DECL.  Returns GS_OK if we expanded a\n    DECL_VALUE_EXPR, and it's worth re-examining things.  */\n \n static enum gimplify_status\n@@ -1913,7 +1913,7 @@ gimplify_compound_lval (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \tgoto restart;\n       else\n \tbreak;\n-\t       \n+\n       VEC_safe_push (tree, heap, stack, *p);\n     }\n \n@@ -2272,7 +2272,7 @@ gimplify_call_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n \t      *expr_p = build_empty_stmt (EXPR_LOCATION (*expr_p));\n \t      return GS_OK;\n \t    }\n-\t  \n+\n \t  if (fold_builtin_next_arg (*expr_p, true))\n \t    {\n \t      *expr_p = build_empty_stmt (EXPR_LOCATION (*expr_p));\n@@ -3125,7 +3125,7 @@ gimplify_modify_expr_to_memset (tree *expr_p, tree size, bool want_value,\n   /* Assert our assumptions, to abort instead of producing wrong code\n      silently if they are not met.  Beware that the RHS CONSTRUCTOR might\n      not be immediately exposed.  */\n-  from = TREE_OPERAND (*expr_p, 1);  \n+  from = TREE_OPERAND (*expr_p, 1);\n   if (TREE_CODE (from) == WITH_SIZE_EXPR)\n     from = TREE_OPERAND (from, 0);\n \n@@ -3358,18 +3358,18 @@ gimplify_init_ctor_eval_range (tree object, tree lower, tree upper,\n }\n \n /* Return true if FDECL is accessing a field that is zero sized.  */\n-   \n+\n static bool\n zero_sized_field_decl (const_tree fdecl)\n {\n-  if (TREE_CODE (fdecl) == FIELD_DECL && DECL_SIZE (fdecl) \n+  if (TREE_CODE (fdecl) == FIELD_DECL && DECL_SIZE (fdecl)\n       && integer_zerop (DECL_SIZE (fdecl)))\n     return true;\n   return false;\n }\n \n /* Return true if TYPE is zero sized.  */\n-   \n+\n static bool\n zero_sized_type (const_tree type)\n {\n@@ -3616,7 +3616,7 @@ gimplify_init_constructor (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t      return GS_OK;\n \t    break;\n \t  }\n- \n+\n \t/* Fetch information about the constructor to direct later processing.\n \t   We might want to make static versions of it in various cases, and\n \t   can only do so if it known to be a valid constant initializer.  */\n@@ -4025,7 +4025,7 @@ gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p,\n \tbreak;\n       case INDIRECT_REF:\n \t{\n-\t  /* If we have code like \n+\t  /* If we have code like\n \n \t        *(const A*)(A*)&x\n \n@@ -4196,7 +4196,7 @@ gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p,\n \t    *expr_p = wrap;\n \t  return GS_OK;\n \t}\n-\t\n+\n       case COMPOUND_LITERAL_EXPR:\n \t{\n \t  tree complit = TREE_OPERAND (*expr_p, 1);\n@@ -4717,7 +4717,7 @@ gimplify_asm_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n   VEC(tree, gc) *clobbers;\n   VEC(tree, gc) *labels;\n   tree link_next;\n-  \n+\n   expr = *expr_p;\n   noutputs = list_length (ASM_OUTPUTS (expr));\n   oconstraints = (const char **) alloca ((noutputs) * sizeof (const char *));\n@@ -4902,7 +4902,7 @@ gimplify_asm_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n       TREE_CHAIN (link) = NULL_TREE;\n       VEC_safe_push (tree, gc, inputs, link);\n     }\n-  \n+\n   for (link = ASM_CLOBBERS (expr); link; ++i, link = TREE_CHAIN (link))\n     VEC_safe_push (tree, gc, clobbers, link);\n \n@@ -5277,7 +5277,7 @@ omp_add_variable (struct gimplify_omp_ctx *ctx, tree decl, unsigned int flags)\n     }\n \n   /* When adding a variable-sized variable, we have to handle all sorts\n-     of additional bits of data: the pointer replacement variable, and \n+     of additional bits of data: the pointer replacement variable, and\n      the parameters of the type.  */\n   if (DECL_SIZE (decl) && TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST)\n     {\n@@ -5309,7 +5309,7 @@ omp_add_variable (struct gimplify_omp_ctx *ctx, tree decl, unsigned int flags)\n \tflags = GOVD_PRIVATE | GOVD_DEBUG_PRIVATE\n \t\t| (flags & (GOVD_SEEN | GOVD_EXPLICIT));\n \n-      /* We're going to make use of the TYPE_SIZE_UNIT at least in the \n+      /* We're going to make use of the TYPE_SIZE_UNIT at least in the\n \t alloca statement we generate for the variable, so make sure it\n \t is available.  This isn't automatically needed for the SHARED\n \t case, since we won't be allocating local storage then.\n@@ -5628,7 +5628,7 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t      push_gimplify_context (&gctx);\n \t      gimplify_and_add (OMP_CLAUSE_REDUCTION_MERGE (c),\n \t\t  \t\t&OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (c));\n-\t      pop_gimplify_context \n+\t      pop_gimplify_context\n \t\t(gimple_seq_first_stmt (OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (c)));\n \t      OMP_CLAUSE_REDUCTION_INIT (c) = NULL_TREE;\n \t      OMP_CLAUSE_REDUCTION_MERGE (c) = NULL_TREE;\n@@ -5825,7 +5825,7 @@ gimplify_adjust_omp_clauses (tree *list_p)\n \t  OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE (c)\n \t    = (n->value & GOVD_FIRSTPRIVATE) != 0;\n \t  break;\n-\t  \n+\n \tcase OMP_CLAUSE_REDUCTION:\n \tcase OMP_CLAUSE_COPYIN:\n \tcase OMP_CLAUSE_COPYPRIVATE:\n@@ -5851,7 +5851,7 @@ gimplify_adjust_omp_clauses (tree *list_p)\n \n   /* Add in any implicit data sharing.  */\n   splay_tree_foreach (ctx->variables, gimplify_adjust_omp_clauses_1, list_p);\n-  \n+\n   gimplify_omp_ctxp = ctx->outer_context;\n   delete_omp_context (ctx);\n }\n@@ -5975,7 +5975,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t{\n \t  var = create_tmp_var (TREE_TYPE (decl), get_name (decl));\n \t  TREE_OPERAND (t, 0) = var;\n-                              \n+\n \t  gimplify_seq_add_stmt (&for_body, gimple_build_assign (decl, var));\n \n \t  omp_add_variable (gimplify_omp_ctxp, var, GOVD_PRIVATE | GOVD_SEEN);\n@@ -6125,14 +6125,14 @@ gimplify_omp_workshare (tree *expr_p, gimple_seq *pre_p)\n }\n \n /* A subroutine of gimplify_omp_atomic.  The front end is supposed to have\n-   stabilized the lhs of the atomic operation as *ADDR.  Return true if \n+   stabilized the lhs of the atomic operation as *ADDR.  Return true if\n    EXPR is this stabilized form.  */\n \n static bool\n goa_lhs_expr_p (tree expr, tree addr)\n {\n   /* Also include casts to other type variants.  The C front end is fond\n-     of adding these for e.g. volatile variables.  This is like \n+     of adding these for e.g. volatile variables.  This is like\n      STRIP_TYPE_NOPS but includes the main variant lookup.  */\n   STRIP_USELESS_TYPE_CONVERSION (expr);\n \n@@ -6178,7 +6178,7 @@ goa_stabilize_expr (tree *expr_p, gimple_seq *pre_p, tree lhs_addr,\n     }\n   if (is_gimple_val (expr))\n     return 0;\n- \n+\n   saw_lhs = 0;\n   switch (TREE_CODE_CLASS (TREE_CODE (expr)))\n     {\n@@ -7458,7 +7458,7 @@ gimplify_body (tree *body_p, tree fndecl, bool do_parms)\n \n /* Entry point to the gimplification pass.  FNDECL is the FUNCTION_DECL\n    node for the function we want to gimplify.\n-   \n+\n    Returns the sequence of GIMPLE statements corresponding to the body\n    of FNDECL.  */\n "}, {"sha": "4ee71dff904d485fd501540042c338290a0d8ef3", "filename": "gcc/graphds.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgraphds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgraphds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphds.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -266,7 +266,7 @@ graphds_dfs (struct graph *g, int *qs, int nq, VEC (int, heap) **qt,\n    numbers assigned by the previous pass.  If SUBGRAPH is not NULL, it\n    specifies the subgraph of G whose strongly connected components we want\n    to determine.\n-   \n+\n    After running this function, v->component is the number of the strongly\n    connected component for each vertex of G.  Returns the number of the\n    sccs of G.  */\n@@ -409,7 +409,7 @@ graphds_domtree (struct graph *g, int entry,\n \n   /* We use a slight modification of the standard iterative algorithm, as\n      described in\n-     \n+\n      K. D. Cooper, T. J. Harvey and K. Kennedy: A Simple, Fast Dominance\n \tAlgorithm\n "}, {"sha": "3f3bb3bb43492c86a2844182589c2eddb0c79f55", "filename": "gcc/graphite-clast-to-gimple.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgraphite-clast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgraphite-clast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-clast-to-gimple.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -789,7 +789,7 @@ compute_cloog_iv_types_1 (poly_bb_p pbb, struct clast_user_stmt *user_stmt)\n     {\n       PTR *slot;\n       struct ivtype_map_elt_s tmp;\n-      struct clast_expr *expr = (struct clast_expr *) \n+      struct clast_expr *expr = (struct clast_expr *)\n \t((struct clast_assignment *)t)->RHS;\n \n       /* Create an entry (clast_var, type).  */"}, {"sha": "311c6904b1ae8915b8108cd36348bf165db78479", "filename": "gcc/gthr-nks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgthr-nks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgthr-nks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-nks.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -100,7 +100,7 @@ __gthread_objc_thread_detach (void (*func)(void *), void *arg)\n     NXContextFree (context);\n     thread_id = NULL;\n   }\n-  \n+\n   return thread_id;\n }\n "}, {"sha": "1987ba738c2c242fc913626b881a246a26afdf6b", "filename": "gcc/gthr-posix.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgthr-posix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgthr-posix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-posix.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -72,8 +72,8 @@ pthread_create (pthread_t *thread ATTRIBUTE_UNUSED,\n   return 0;\n }\n \n-int \n-pthread_join (pthread_t thread ATTRIBUTE_UNUSED, \n+int\n+pthread_join (pthread_t thread ATTRIBUTE_UNUSED,\n \t      void **value_ptr ATTRIBUTE_UNUSED)\n {\n   return 0;\n@@ -84,7 +84,7 @@ pthread_exit (void *value_ptr ATTRIBUTE_UNUSED)\n {\n }\n \n-int \n+int\n pthread_detach (pthread_t thread ATTRIBUTE_UNUSED)\n {\n   return 0;\n@@ -178,7 +178,7 @@ pthread_cond_wait (pthread_cond_t *cond ATTRIBUTE_UNUSED,\n \n int\n pthread_cond_timedwait (pthread_cond_t *cond ATTRIBUTE_UNUSED, \r\n-\t\t\tpthread_mutex_t *mutex ATTRIBUTE_UNUSED, \n+\t\t\tpthread_mutex_t *mutex ATTRIBUTE_UNUSED,\n \t\t\tconst struct timespec *abstime ATTRIBUTE_UNUSED)\n {\n   return 0;"}, {"sha": "61b4dda4271a43ae97aed13a0b92b1695c9b8f2e", "filename": "gcc/gthr-posix.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgthr-posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgthr-posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-posix.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -51,7 +51,7 @@ typedef struct timespec __gthread_time_t;\n \n /* POSIX like conditional variables are supported.  Please look at comments\n    in gthr.h for details. */\n-#define __GTHREAD_HAS_COND\t1\t\n+#define __GTHREAD_HAS_COND\t1\n \n #define __GTHREAD_MUTEX_INIT PTHREAD_MUTEX_INITIALIZER\n #define __GTHREAD_ONCE_INIT PTHREAD_ONCE_INIT\n@@ -237,7 +237,7 @@ __gthread_active_p (void)\n static inline int\n __gthread_active_p (void)\n {\n-  static void *const __gthread_active_ptr \n+  static void *const __gthread_active_ptr\n     = __extension__ (void *) &__gthrw_(pthread_cancel);\n   return __gthread_active_ptr != 0;\n }"}, {"sha": "55e254eb21f15bd5649a81edaff36771609af213", "filename": "gcc/gthr-posix95.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgthr-posix95.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgthr-posix95.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-posix95.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -171,7 +171,7 @@ __gthread_active_p (void)\n static inline int\n __gthread_active_p (void)\n {\n-  static void *const __gthread_active_ptr \n+  static void *const __gthread_active_ptr\n     = __extension__ (void *) &__gthrw_(pthread_cancel);\n   return __gthread_active_ptr != 0;\n }"}, {"sha": "357528ad1f16d4aa54518b12498d249ea178b252", "filename": "gcc/gthr-single.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgthr-single.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgthr-single.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-single.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -213,12 +213,12 @@ __gthread_active_p (void)\n   return 0;\n }\n \n-static inline int \n+static inline int\n __gthread_once (__gthread_once_t *__once UNUSED, void (*__func) (void) UNUSED)\n {\n   return 0;\n }\n-  \n+\n static inline int UNUSED\n __gthread_key_create (__gthread_key_t *__key UNUSED, void (*__func) (void *) UNUSED)\n {\n@@ -230,14 +230,14 @@ __gthread_key_delete (__gthread_key_t __key UNUSED)\n {\n   return 0;\n }\n-  \n+\n static inline void *\n __gthread_getspecific (__gthread_key_t __key UNUSED)\n {\n   return 0;\n }\n \n-static inline int \n+static inline int\n __gthread_setspecific (__gthread_key_t __key UNUSED, const void *__v UNUSED)\n {\n   return 0;"}, {"sha": "fb23e91cfcd4d37f5a18eb2c1f8514a392b95676", "filename": "gcc/gthr-tpf.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgthr-tpf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgthr-tpf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-tpf.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -23,7 +23,7 @@ a copy of the GCC Runtime Library Exception along with this program;\n see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n-/* TPF needs its own version of gthr-*.h because TPF always links to \n+/* TPF needs its own version of gthr-*.h because TPF always links to\n    the thread library.  However, for performance reasons we still do not\n    want to issue thread api calls unless a check is made to see that we\n    are running as a thread.  */\n@@ -206,7 +206,7 @@ __gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)\n \n static inline int\n __gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex)\n-{ \n+{\n   if (__tpf_pthread_active ())\n     {\n       pthread_mutexattr_t __attr;"}, {"sha": "d4da14ef49295674f6dfc9fd87436223764f5f49", "filename": "gcc/gthr-vxworks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgthr-vxworks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgthr-vxworks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-vxworks.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -137,7 +137,7 @@ __gthread_once_t;\n \n #if defined (__RTP__)\n # define __GTHREAD_ONCE_INIT { 0 }\n-#elif defined (__PPC__) \n+#elif defined (__PPC__)\n # define __GTHREAD_ONCE_INIT { 0, 0, 0, 0 }\n #else\n # define __GTHREAD_ONCE_INIT { 0, 0 }"}, {"sha": "6edfbcd69c38c99689b7e287d86045ddb0e8600e", "filename": "gcc/gthr.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgthr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fgthr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -101,16 +101,16 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    All functions returning int should return zero on success or the error\n    number.  If the operation is not supported, -1 is returned.\n \n-   If the following are also defined, you should \n+   If the following are also defined, you should\n      #define __GTHREADS_CXX0X 1\n-   to enable the c++0x thread library. \n- \n+   to enable the c++0x thread library.\n+\n    Types:\n      __gthread_t\n      __gthread_time_t\n \n    Interface:\n-     int __gthread_create (__gthread_t *thread, void *(*func) (void*), \n+     int __gthread_create (__gthread_t *thread, void *(*func) (void*),\n                            void *args);\n      int __gthread_join (__gthread_t thread, void **value_ptr);\n      int __gthread_detach (__gthread_t thread);\n@@ -122,9 +122,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n                                     const __gthread_time_t *abs_timeout);\n      int __gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *m,\n                                           const __gthread_time_t *abs_time);\n-     \n+\n      int __gthread_cond_signal (__gthread_cond_t *cond);\n-     int __gthread_cond_timedwait (__gthread_cond_t *cond, \n+     int __gthread_cond_timedwait (__gthread_cond_t *cond,\n                                    __gthread_mutex_t *mutex,\n                                    const __gthread_time_t *abs_timeout);\n      int __gthread_cond_timedwait_recursive (__gthread_cond_t *cond,\n@@ -137,7 +137,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n      POSIX/Unix95 threads with -D_PTHREADS95\n      DCE threads with -D_DCE_THREADS\n      Solaris/UI threads with -D_SOLARIS_THREADS\n-   \n+\n */\n \n /* Check first for thread specific defines.  */"}, {"sha": "204fab6aff94ec189e1d0e5acfa5dd02e00a6fb6", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 177, "deletions": 177, "changes": 354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -185,7 +185,7 @@ fix_sched_param (const char *param, const char *val)\n     warning (0, \"fix_sched_param: unknown param: %s\", param);\n }\n \n-/* This is a placeholder for the scheduler parameters common \n+/* This is a placeholder for the scheduler parameters common\n    to all schedulers.  */\n struct common_sched_info_def *common_sched_info;\n \n@@ -295,7 +295,7 @@ static int q_size = 0;\n    queue or ready list.\n    QUEUE_READY     - INSN is in ready list.\n    N >= 0 - INSN queued for X [where NEXT_Q_AFTER (q_ptr, X) == N] cycles.  */\n-   \n+\n #define QUEUE_INDEX(INSN) (HID (INSN)->queue_index)\n \n /* The following variable value refers for all current and future\n@@ -336,7 +336,7 @@ static int may_trap_exp (const_rtx, int);\n static int haifa_luid_for_non_insn (rtx x);\n \n /* Haifa version of sched_info hooks common to all headers.  */\n-const struct common_sched_info_def haifa_common_sched_info = \n+const struct common_sched_info_def haifa_common_sched_info =\n   {\n     NULL, /* fix_recovery_cfg */\n     NULL, /* add_block */\n@@ -726,7 +726,7 @@ initiate_bb_reg_pressure_info (basic_block bb)\n     for (i = 0; ; ++i)\n       {\n \tunsigned int regno = EH_RETURN_DATA_REGNO (i);\n-\t\n+\n \tif (regno == INVALID_REGNUM)\n \t  break;\n \tif (! bitmap_bit_p (df_get_live_in (bb), regno))\n@@ -740,7 +740,7 @@ static void\n save_reg_pressure (void)\n {\n   int i;\n-  \n+\n   for (i = 0; i < ira_reg_class_cover_size; i++)\n     saved_reg_pressure[ira_reg_class_cover[i]]\n       = curr_reg_pressure[ira_reg_class_cover[i]];\n@@ -752,7 +752,7 @@ static void\n restore_reg_pressure (void)\n {\n   int i;\n-  \n+\n   for (i = 0; i < ira_reg_class_cover_size; i++)\n     curr_reg_pressure[ira_reg_class_cover[i]]\n       = saved_reg_pressure[ira_reg_class_cover[i]];\n@@ -887,7 +887,7 @@ dep_cost_1 (dep_t link, dw_t dw)\n \t  else if (bypass_p (insn))\n \t    cost = insn_latency (insn, used);\n \t}\n-\t\n+\n \n       if (targetm.sched.adjust_cost_2)\n \tcost = targetm.sched.adjust_cost_2 (used, (int) dep_type, insn, cost,\n@@ -940,7 +940,7 @@ increase_insn_priority (rtx insn, int amount)\n     }\n   else\n     {\n-      /* In sel-sched.c INSN_PRIORITY is not kept up to date.  \n+      /* In sel-sched.c INSN_PRIORITY is not kept up to date.\n \t Use EXPR_PRIORITY instead. */\n       sel_add_to_insn_priority (insn, amount);\n     }\n@@ -1027,7 +1027,7 @@ priority (rtx insn)\n \t     different than that of normal instructions.  Instead of walking\n \t     through INSN_FORW_DEPS (check) list, we walk through\n \t     INSN_FORW_DEPS list of each instruction in the corresponding\n-\t     recovery block.  */ \n+\t     recovery block.  */\n \n           /* Selective scheduling does not define RECOVERY_BLOCK macro.  */\n \t  rec = sel_sched_p () ? NULL : RECOVERY_BLOCK (insn);\n@@ -1078,7 +1078,7 @@ priority (rtx insn)\n \t\t\tthis_priority = next_priority;\n \t\t    }\n \t\t}\n-\t      \n+\n \t      twin = PREV_INSN (twin);\n \t    }\n \t  while (twin != prev_first);\n@@ -1178,7 +1178,7 @@ rank_for_schedule (const void *x, const void *y)\n     }\n \n   /* The insn in a schedule group should be issued the first.  */\n-  if (flag_sched_group_heuristic && \n+  if (flag_sched_group_heuristic &&\n       SCHED_GROUP_P (tmp) != SCHED_GROUP_P (tmp2))\n     return SCHED_GROUP_P (tmp2) ? 1 : -1;\n \n@@ -1216,7 +1216,7 @@ rank_for_schedule (const void *x, const void *y)\n \n   if (flag_sched_critical_path_heuristic && priority_val)\n     return priority_val;\n-    \n+\n   /* Prefer speculative insn with greater dependencies weakness.  */\n   if (flag_sched_spec_insn_heuristic && spec_info)\n     {\n@@ -1229,7 +1229,7 @@ rank_for_schedule (const void *x, const void *y)\n \tdw1 = ds_weak (ds1);\n       else\n \tdw1 = NO_DEP_WEAK;\n-      \n+\n       ds2 = TODO_SPEC (tmp2) & SPECULATIVE;\n       if (ds2)\n \tdw2 = ds_weak (ds2);\n@@ -1416,7 +1416,7 @@ HAIFA_INLINE static rtx\n ready_remove_first (struct ready_list *ready)\n {\n   rtx t;\n-  \n+\n   gcc_assert (ready->n_ready);\n   t = ready->vec[ready->first--];\n   ready->n_ready--;\n@@ -1444,7 +1444,7 @@ rtx\n ready_element (struct ready_list *ready, int index)\n {\n   gcc_assert (ready->n_ready && index < ready->n_ready);\n-  \n+\n   return ready->vec[ready->first - index];\n }\n \n@@ -1534,7 +1534,7 @@ advance_state (state_t state)\n \t\t      targetm.sched.dfa_pre_cycle_insn ());\n \n   state_transition (state, NULL);\n-  \n+\n   if (targetm.sched.dfa_post_cycle_insn)\n     state_transition (state,\n \t\t      targetm.sched.dfa_post_cycle_insn ());\n@@ -1728,7 +1728,7 @@ schedule_insn (rtx insn)\n   if (INSN_TICK (insn) > clock_var)\n     /* INSN has been prematurely moved from the queue to the ready list.\n        This is possible only if following flag is set.  */\n-    gcc_assert (flag_sched_stalled_insns);    \n+    gcc_assert (flag_sched_stalled_insns);\n \n   /* ??? Probably, if INSN is scheduled prematurely, we should leave\n      INSN_TICK untouched.  This is a machine-dependent issue, actually.  */\n@@ -1753,10 +1753,10 @@ schedule_insn (rtx insn)\n \n       if (!IS_SPECULATION_BRANCHY_CHECK_P (insn))\n \t{\n-\t  int effective_cost;      \n-\t  \n+\t  int effective_cost;\n+\n \t  effective_cost = try_ready (next);\n-\t  \n+\n \t  if (effective_cost >= 0\n \t      && SCHED_GROUP_P (next)\n \t      && advance < effective_cost)\n@@ -1804,7 +1804,7 @@ schedule_insn (rtx insn)\n /* Functions for handling of notes.  */\n \n /* Insert the INSN note at the end of the notes list.  */\n-static void \n+static void\n add_to_note_list (rtx insn, rtx *note_list_end_p)\n {\n   PREV_INSN (insn) = *note_list_end_p;\n@@ -1832,7 +1832,7 @@ concat_note_lists (rtx from_end, rtx *to_endp)\n \n   from_start = from_end;\n   /* A note list should be traversed via PREV_INSN.  */\n-  while (PREV_INSN (from_start) != NULL) \n+  while (PREV_INSN (from_start) != NULL)\n     from_start = PREV_INSN (from_start);\n \n   add_to_note_list (from_start, to_endp);\n@@ -2123,17 +2123,17 @@ queue_to_ready (struct ready_list *ready)\n }\n \n /* Used by early_queue_to_ready.  Determines whether it is \"ok\" to\n-   prematurely move INSN from the queue to the ready list.  Currently, \n-   if a target defines the hook 'is_costly_dependence', this function \n+   prematurely move INSN from the queue to the ready list.  Currently,\n+   if a target defines the hook 'is_costly_dependence', this function\n    uses the hook to check whether there exist any dependences which are\n-   considered costly by the target, between INSN and other insns that \n+   considered costly by the target, between INSN and other insns that\n    have already been scheduled.  Dependences are checked up to Y cycles\n    back, with default Y=1; The flag -fsched-stalled-insns-dep=Y allows\n-   controlling this value. \n-   (Other considerations could be taken into account instead (or in \n+   controlling this value.\n+   (Other considerations could be taken into account instead (or in\n    addition) depending on user flags and target hooks.  */\n \n-static bool \n+static bool\n ok_for_early_queue_removal (rtx insn)\n {\n   int n_cycles;\n@@ -2173,9 +2173,9 @@ ok_for_early_queue_removal (rtx insn)\n \t\tbreak;\n \t    }\n \n-\t  if (!prev_insn) \n+\t  if (!prev_insn)\n \t    break;\n-\t  prev_insn = PREV_INSN (prev_insn);     \n+\t  prev_insn = PREV_INSN (prev_insn);\n \t}\n     }\n \n@@ -2186,7 +2186,7 @@ ok_for_early_queue_removal (rtx insn)\n /* Remove insns from the queue, before they become \"ready\" with respect\n    to FU latency considerations.  */\n \n-static int \n+static int\n early_queue_to_ready (state_t state, struct ready_list *ready)\n {\n   rtx insn;\n@@ -2200,20 +2200,20 @@ early_queue_to_ready (state_t state, struct ready_list *ready)\n   int insns_removed = 0;\n \n   /*\n-     Flag '-fsched-stalled-insns=X' determines the aggressiveness of this \n-     function: \n+     Flag '-fsched-stalled-insns=X' determines the aggressiveness of this\n+     function:\n \n-     X == 0: There is no limit on how many queued insns can be removed          \n+     X == 0: There is no limit on how many queued insns can be removed\n              prematurely.  (flag_sched_stalled_insns = -1).\n \n-     X >= 1: Only X queued insns can be removed prematurely in each \n+     X >= 1: Only X queued insns can be removed prematurely in each\n \t     invocation.  (flag_sched_stalled_insns = X).\n \n      Otherwise: Early queue removal is disabled.\n          (flag_sched_stalled_insns = 0)\n   */\n \n-  if (! flag_sched_stalled_insns)   \n+  if (! flag_sched_stalled_insns)\n     return 0;\n \n   for (stalls = 0; stalls <= max_insn_queue_index; stalls++)\n@@ -2232,7 +2232,7 @@ early_queue_to_ready (state_t state, struct ready_list *ready)\n \t\tprint_rtl_single (sched_dump, insn);\n \n \t      memcpy (temp_state, state, dfa_state_size);\n-\t      if (recog_memoized (insn) < 0) \n+\t      if (recog_memoized (insn) < 0)\n \t\t/* non-negative to indicate that it's not ready\n \t\t   to avoid infinite Q->R->Q->R... */\n \t\tcost = 0;\n@@ -2243,7 +2243,7 @@ early_queue_to_ready (state_t state, struct ready_list *ready)\n \t\tfprintf (sched_dump, \"transition cost = %d\\n\", cost);\n \n \t      move_to_ready = false;\n-\t      if (cost < 0) \n+\t      if (cost < 0)\n \t\t{\n \t\t  move_to_ready = ok_for_early_queue_removal (insn);\n \t\t  if (move_to_ready == true)\n@@ -2252,7 +2252,7 @@ early_queue_to_ready (state_t state, struct ready_list *ready)\n \t\t      q_size -= 1;\n \t\t      ready_add (ready, insn, false);\n \n-\t\t      if (prev_link)   \n+\t\t      if (prev_link)\n \t\t\tXEXP (prev_link, 1) = next_link;\n \t\t      else\n \t\t\tinsn_queue[NEXT_Q_AFTER (q_ptr, stalls)] = next_link;\n@@ -2276,11 +2276,11 @@ early_queue_to_ready (state_t state, struct ready_list *ready)\n \n \t      link = next_link;\n \t    } /* while link */\n-\t} /* if link */    \n+\t} /* if link */\n \n     } /* for stalls.. */\n \n-  return insns_removed; \n+  return insns_removed;\n }\n \n \n@@ -2348,9 +2348,9 @@ move_insn (rtx insn, rtx last, rtx nt)\n       int jump_p = 0;\n \n       bb = BLOCK_FOR_INSN (insn);\n- \n+\n       /* BB_HEAD is either LABEL or NOTE.  */\n-      gcc_assert (BB_HEAD (bb) != insn);      \n+      gcc_assert (BB_HEAD (bb) != insn);\n \n       if (BB_END (bb) == insn)\n \t/* If this is last instruction in BB, move end marker one\n@@ -2364,7 +2364,7 @@ move_insn (rtx insn, rtx last, rtx nt)\n \t\t\t  && IS_SPECULATION_BRANCHY_CHECK_P (insn))\n \t\t      || (common_sched_info->sched_pass_id\n \t\t\t  == SCHED_EBB_PASS));\n-\t  \n+\n \t  gcc_assert (BLOCK_FOR_INSN (PREV_INSN (insn)) == bb);\n \n \t  BB_END (bb) = PREV_INSN (insn);\n@@ -2385,7 +2385,7 @@ move_insn (rtx insn, rtx last, rtx nt)\n \t      && (LABEL_P (note)\n \t\t  || BARRIER_P (note)))\n \t    note = NEXT_INSN (note);\n-      \n+\n \t  gcc_assert (NOTE_INSN_BASIC_BLOCK_P (note));\n \t}\n       else\n@@ -2413,13 +2413,13 @@ move_insn (rtx insn, rtx last, rtx nt)\n \t}\n \n       df_insn_change_bb (insn, bb);\n-  \n+\n       /* Update BB_END, if needed.  */\n       if (BB_END (bb) == last)\n-\tBB_END (bb) = insn;  \n+\tBB_END (bb) = insn;\n     }\n \n-  SCHED_GROUP_P (insn) = 0;  \n+  SCHED_GROUP_P (insn) = 0;\n }\n \n /* Return true if scheduling INSN will finish current clock cycle.  */\n@@ -2528,8 +2528,8 @@ max_issue (struct ready_list *ready, int privileged_n, state_t state,\n   /* ??? We used to assert here that we never issue more insns than issue_rate.\n      However, some targets (e.g. MIPS/SB1) claim lower issue rate than can be\n      achieved to get better performance.  Until these targets are fixed to use\n-     scheduler hooks to manipulate insns priority instead, the assert should \n-     be disabled.  \n+     scheduler hooks to manipulate insns priority instead, the assert should\n+     be disabled.\n \n      gcc_assert (more_issue >= 0);  */\n \n@@ -2646,7 +2646,7 @@ max_issue (struct ready_list *ready, int privileged_n, state_t state,\n     }\n \n   /* Restore the original state of the DFA.  */\n-  memcpy (state, choice_stack->state, dfa_state_size);  \n+  memcpy (state, choice_stack->state, dfa_state_size);\n \n   return best;\n }\n@@ -2698,7 +2698,7 @@ choose_ready (struct ready_list *ready, rtx *insn_ptr)\n       rtx insn;\n       int try_data = 1, try_control = 1;\n       ds_t ts;\n-      \n+\n       insn = ready_element (ready, 0);\n       if (INSN_CODE (insn) < 0)\n \t{\n@@ -2717,16 +2717,16 @@ choose_ready (struct ready_list *ready, rtx *insn_ptr)\n \n \t      x = ready_element (ready, i);\n \t      s = TODO_SPEC (x);\n-\t      \n+\n \t      if (spec_info->flags & PREFER_NON_DATA_SPEC\n \t\t  && !(s & DATA_SPEC))\n-\t\t{\t\t  \n+\t\t{\n \t\t  try_data = 0;\n \t\t  if (!(spec_info->flags & PREFER_NON_CONTROL_SPEC)\n \t\t      || !try_control)\n \t\t    break;\n \t\t}\n-\t      \n+\n \t      if (spec_info->flags & PREFER_NON_CONTROL_SPEC\n \t\t  && !(s & CONTROL_SPEC))\n \t\t{\n@@ -2790,17 +2790,17 @@ choose_ready (struct ready_list *ready, rtx *insn_ptr)\n \t{\n \t  *insn_ptr = ready_remove_first (ready);\n \t  if (sched_verbose >= 4)\n-\t    fprintf (sched_dump, \";;\\t\\tChosen insn (but can't issue) : %s \\n\", \n+\t    fprintf (sched_dump, \";;\\t\\tChosen insn (but can't issue) : %s \\n\",\n                      (*current_sched_info->print_insn) (*insn_ptr, 0));\n \t  return 0;\n \t}\n       else\n \t{\n-\t  if (sched_verbose >= 4)    \n+\t  if (sched_verbose >= 4)\n \t    fprintf (sched_dump, \";;\\t\\tChosen insn : %s\\n\",\n \t\t     (*current_sched_info->print_insn)\n \t\t     (ready_element (ready, index), 0));\n-          \n+\n \t  *insn_ptr = ready_remove (ready, index);\n \t  return 0;\n \t}\n@@ -2871,7 +2871,7 @@ schedule_block (basic_block *target_bb)\n   /* Start just before the beginning of time.  */\n   clock_var = -1;\n \n-  /* We need queue and ready lists and clock_var be initialized \n+  /* We need queue and ready lists and clock_var be initialized\n      in try_ready () (which is called through init_ready_list ()).  */\n   (*current_sched_info->init_ready_list) ();\n \n@@ -3037,9 +3037,9 @@ schedule_block (basic_block *target_bb)\n \t\tprint_curr_reg_pressure ();\n \t    }\n \n-\t  if (ready.n_ready == 0 \n-\t      && can_issue_more \n-\t      && reload_completed) \n+\t  if (ready.n_ready == 0\n+\t      && can_issue_more\n+\t      && reload_completed)\n \t    {\n \t      /* Allow scheduling insns directly from the queue in case\n \t\t there's nothing better to do (ready list is empty) but\n@@ -3095,10 +3095,10 @@ schedule_block (basic_block *target_bb)\n \t       to have the highest priority (so it will be returned by\n \t       the ready_remove_first call above), we invoke\n \t       ready_add (&ready, insn, true).\n-\t       But, still, there is one issue: INSN can be later \n-\t       discarded by scheduler's front end through \n+\t       But, still, there is one issue: INSN can be later\n+\t       discarded by scheduler's front end through\n \t       current_sched_info->can_schedule_ready_p, hence, won't\n-\t       be issued next.  */ \n+\t       be issued next.  */\n \t    {\n \t      ready_add (&ready, insn, true);\n               break;\n@@ -3140,7 +3140,7 @@ schedule_block (basic_block *target_bb)\n  \t\t  advance = cost;\n  \t\t  break;\n  \t\t}\n- \n+\n \t      continue;\n \t    }\n \n@@ -3153,12 +3153,12 @@ schedule_block (basic_block *target_bb)\n \t      continue;\n \t    }\n \n-\t  /* DECISION is made.  */\t\n-  \n+\t  /* DECISION is made.  */\n+\n           if (TODO_SPEC (insn) & SPECULATIVE)\n             generate_recovery_code (insn);\n \n-\t  if (control_flow_insn_p (last_scheduled_insn)\t     \n+\t  if (control_flow_insn_p (last_scheduled_insn)\n \t      /* This is used to switch basic blocks by request\n \t\t from scheduler front-end (actually, sched-ebb.c only).\n \t\t This is used to process blocks with single fallthru\n@@ -3168,7 +3168,7 @@ schedule_block (basic_block *target_bb)\n \t    {\n \t      *target_bb = current_sched_info->advance_target_bb\n \t\t(*target_bb, 0);\n-\t      \n+\n \t      if (sched_verbose)\n \t\t{\n \t\t  rtx x;\n@@ -3180,15 +3180,15 @@ schedule_block (basic_block *target_bb)\n \n \t      last_scheduled_insn = bb_note (*target_bb);\n \t    }\n- \n+\n \t  /* Update counters, etc in the scheduler's front end.  */\n \t  (*current_sched_info->begin_schedule_ready) (insn,\n \t\t\t\t\t\t       last_scheduled_insn);\n- \n+\n \t  move_insn (insn, last_scheduled_insn, current_sched_info->next_tail);\n \t  reemit_notes (insn);\n \t  last_scheduled_insn = insn;\n-\t  \n+\n \t  if (memcmp (curr_state, temp_state, dfa_state_size) != 0)\n             {\n               cycle_issued_insns++;\n@@ -3282,19 +3282,19 @@ schedule_block (basic_block *target_bb)\n     /* Sanity check -- queue must be empty now.  Meaningless if region has\n        multiple bbs.  */\n     gcc_assert (!q_size && !ready.n_ready && !ready.n_debug);\n-  else \n+  else\n     {\n       /* We must maintain QUEUE_INDEX between blocks in region.  */\n       for (i = ready.n_ready - 1; i >= 0; i--)\n \t{\n \t  rtx x;\n-\t  \n+\n \t  x = ready_element (&ready, i);\n \t  QUEUE_INDEX (x) = QUEUE_NOWHERE;\n \t  TODO_SPEC (x) = (TODO_SPEC (x) & ~SPECULATIVE) | HARD_DEP;\n \t}\n \n-      if (q_size)   \n+      if (q_size)\n \tfor (i = 0; i <= max_insn_queue_index; i++)\n \t  {\n \t    rtx link;\n@@ -3356,7 +3356,7 @@ set_priorities (rtx head, rtx tail)\n {\n   rtx insn;\n   int n_insn;\n-  int sched_max_insns_priority = \n+  int sched_max_insns_priority =\n \tcurrent_sched_info->sched_max_insns_priority;\n   rtx prev_head;\n \n@@ -3398,7 +3398,7 @@ setup_sched_dump (void)\n \t\t? stderr : dump_file);\n }\n \n-/* Initialize some global state for the scheduler.  This function works \n+/* Initialize some global state for the scheduler.  This function works\n    with the common data shared between all the schedulers.  It is called\n    from the scheduler specific initialization routine.  */\n \n@@ -3478,8 +3478,8 @@ sched_init (void)\n     }\n \n   df_analyze ();\n-  \n-  /* Do not run DCE after reload, as this can kill nops inserted \n+\n+  /* Do not run DCE after reload, as this can kill nops inserted\n      by bundling.  */\n   if (reload_completed)\n     df_clear_flags (DF_LR_RUN_DCE);\n@@ -3506,7 +3506,7 @@ sched_init (void)\n       saved_reg_live = BITMAP_ALLOC (NULL);\n       region_ref_regs = BITMAP_ALLOC (NULL);\n     }\n-  \n+\n   curr_state = xmalloc (dfa_state_size);\n }\n \n@@ -3597,7 +3597,7 @@ haifa_sched_finish (void)\n   sched_finish ();\n }\n \n-/* Free global data used during insn scheduling.  This function works with \n+/* Free global data used during insn scheduling.  This function works with\n    the common data shared between the schedulers.  */\n \n void\n@@ -3644,7 +3644,7 @@ fix_inter_tick (rtx head, rtx tail)\n   int next_clock = clock_var + 1;\n \n   bitmap_initialize (&processed, 0);\n-  \n+\n   /* Iterates over scheduled instructions and fix their INSN_TICKs and\n      INSN_TICKs of dependent instructions, so that INSN_TICKs are consistent\n      across different blocks.  */\n@@ -3655,26 +3655,26 @@ fix_inter_tick (rtx head, rtx tail)\n \t  int tick;\n \t  sd_iterator_def sd_it;\n \t  dep_t dep;\n-                  \n+\n \t  tick = INSN_TICK (head);\n \t  gcc_assert (tick >= MIN_TICK);\n-\t  \n+\n \t  /* Fix INSN_TICK of instruction from just scheduled block.  */\n \t  if (!bitmap_bit_p (&processed, INSN_LUID (head)))\n \t    {\n \t      bitmap_set_bit (&processed, INSN_LUID (head));\n \t      tick -= next_clock;\n-\t      \n+\n \t      if (tick < MIN_TICK)\n \t\ttick = MIN_TICK;\n-\t      \n-\t      INSN_TICK (head) = tick;\t\t \n+\n+\t      INSN_TICK (head) = tick;\n \t    }\n-\t  \n+\n \t  FOR_EACH_DEP (head, SD_LIST_RES_FORW, sd_it, dep)\n \t    {\n \t      rtx next;\n-\t      \n+\n \t      next = DEP_CON (dep);\n \t      tick = INSN_TICK (next);\n \n@@ -3686,10 +3686,10 @@ fix_inter_tick (rtx head, rtx tail)\n \t\t{\n \t\t  bitmap_set_bit (&processed, INSN_LUID (next));\n \t\t  tick -= next_clock;\n-\t\t  \n+\n \t\t  if (tick < MIN_TICK)\n \t\t    tick = MIN_TICK;\n-\t\t  \n+\n \t\t  if (tick > INTER_TICK (next))\n \t\t    INTER_TICK (next) = tick;\n \t\t  else\n@@ -3704,7 +3704,7 @@ fix_inter_tick (rtx head, rtx tail)\n }\n \n static int haifa_speculate_insn (rtx, ds_t, rtx *);\n-  \n+\n /* Check if NEXT is ready to be added to the ready or queue list.\n    If \"yes\", add it to the proper list.\n    Returns:\n@@ -3713,7 +3713,7 @@ static int haifa_speculate_insn (rtx, ds_t, rtx *);\n    0 < N - queued for N cycles.  */\n int\n try_ready (rtx next)\n-{  \n+{\n   ds_t old_ts, *ts;\n \n   ts = &TODO_SPEC (next);\n@@ -3722,7 +3722,7 @@ try_ready (rtx next)\n   gcc_assert (!(old_ts & ~(SPECULATIVE | HARD_DEP))\n \t      && ((old_ts & HARD_DEP)\n \t\t  || (old_ts & SPECULATIVE)));\n-  \n+\n   if (sd_lists_empty_p (next, SD_LIST_BACK))\n     /* NEXT has all its dependencies resolved.  */\n     {\n@@ -3798,11 +3798,11 @@ try_ready (rtx next)\n     {\n       int res;\n       rtx new_pat;\n-      \n+\n       gcc_assert ((*ts & SPECULATIVE) && !(*ts & ~SPECULATIVE));\n-      \n+\n       res = haifa_speculate_insn (next, *ts, &new_pat);\n-\t\n+\n       switch (res)\n \t{\n \tcase -1:\n@@ -3811,47 +3811,47 @@ try_ready (rtx next)\n \t     so we won't reanalyze anything.  */\n \t  *ts = (*ts & ~SPECULATIVE) | HARD_DEP;\n \t  break;\n-\t  \n+\n \tcase 0:\n \t  /* We follow the rule, that every speculative insn\n \t     has non-null ORIG_PAT.  */\n \t  if (!ORIG_PAT (next))\n \t    ORIG_PAT (next) = PATTERN (next);\n \t  break;\n-\t  \n-\tcase 1:                  \n+\n+\tcase 1:\n \t  if (!ORIG_PAT (next))\n \t    /* If we gonna to overwrite the original pattern of insn,\n \t       save it.  */\n \t    ORIG_PAT (next) = PATTERN (next);\n-\t  \n+\n \t  haifa_change_pattern (next, new_pat);\n \t  break;\n-\t  \n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n     }\n-  \n+\n   /* We need to restore pattern only if (*ts == 0), because otherwise it is\n      either correct (*ts & SPECULATIVE),\n      or we simply don't care (*ts & HARD_DEP).  */\n-  \n+\n   gcc_assert (!ORIG_PAT (next)\n \t      || !IS_SPECULATION_BRANCHY_CHECK_P (next));\n-  \n+\n   if (*ts & HARD_DEP)\n     {\n       /* We can't assert (QUEUE_INDEX (next) == QUEUE_NOWHERE) here because\n \t control-speculative NEXT could have been discarded by sched-rgn.c\n \t (the same case as when discarded by can_schedule_ready_p ()).  */\n       /*gcc_assert (QUEUE_INDEX (next) == QUEUE_NOWHERE);*/\n-      \n+\n       change_queue_index (next, QUEUE_NOWHERE);\n       return -1;\n     }\n   else if (!(*ts & BEGIN_SPEC) && ORIG_PAT (next) && !IS_SPECULATION_CHECK_P (next))\n-    /* We should change pattern of every previously speculative \n+    /* We should change pattern of every previously speculative\n        instruction - and we determine if NEXT was speculative by using\n        ORIG_PAT field.  Except one case - speculation checks have ORIG_PAT\n        pat too, so skip them.  */\n@@ -3861,12 +3861,12 @@ try_ready (rtx next)\n     }\n \n   if (sched_verbose >= 2)\n-    {\t      \n+    {\n       int s = TODO_SPEC (next);\n-          \n+\n       fprintf (sched_dump, \";;\\t\\tdependencies resolved: insn %s\",\n                (*current_sched_info->print_insn) (next, 0));\n-          \n+\n       if (spec_info && spec_info->dump)\n         {\n           if (s & BEGIN_DATA)\n@@ -3878,10 +3878,10 @@ try_ready (rtx next)\n         }\n \n       fprintf (sched_dump, \"\\n\");\n-    }          \n-  \n+    }\n+\n   adjust_priority (next);\n-        \n+\n   return fix_tick_ready (next);\n }\n \n@@ -3904,10 +3904,10 @@ fix_tick_ready (rtx next)\n       full_p = (tick == INVALID_TICK);\n \n       FOR_EACH_DEP (next, SD_LIST_RES_BACK, sd_it, dep)\n-        {       \n+        {\n           rtx pro = DEP_PRO (dep);\n           int tick1;\n-              \n+\n \t  gcc_assert (INSN_TICK (pro) >= MIN_TICK);\n \n           tick1 = INSN_TICK (pro) + dep_cost (dep);\n@@ -3940,10 +3940,10 @@ change_queue_index (rtx next, int delay)\n {\n   int i = QUEUE_INDEX (next);\n \n-  gcc_assert (QUEUE_NOWHERE <= delay && delay <= max_insn_queue_index \n+  gcc_assert (QUEUE_NOWHERE <= delay && delay <= max_insn_queue_index\n \t      && delay != 0);\n   gcc_assert (i != QUEUE_SCHEDULED);\n-  \n+\n   if ((delay > 0 && NEXT_Q_AFTER (q_ptr, delay) == i)\n       || (delay < 0 && delay == i))\n     /* We have nothing to do.  */\n@@ -3954,18 +3954,18 @@ change_queue_index (rtx next, int delay)\n     ready_remove_insn (next);\n   else if (i >= 0)\n     queue_remove (next);\n-    \n+\n   /* Add it to the proper place.  */\n   if (delay == QUEUE_READY)\n     ready_add (readyp, next, false);\n   else if (delay >= 1)\n     queue_insn (next, delay);\n-    \n+\n   if (sched_verbose >= 2)\n-    {\t      \n+    {\n       fprintf (sched_dump, \";;\\t\\ttick updated: insn %s\",\n \t       (*current_sched_info->print_insn) (next, 0));\n-      \n+\n       if (delay == QUEUE_READY)\n \tfprintf (sched_dump, \" into ready\\n\");\n       else if (delay >= 1)\n@@ -4047,10 +4047,10 @@ generate_recovery_code (rtx insn)\n {\n   if (TODO_SPEC (insn) & BEGIN_SPEC)\n     begin_speculative_block (insn);\n-  \n+\n   /* Here we have insn with no dependencies to\n      instructions other then CHECK_SPEC ones.  */\n-  \n+\n   if (TODO_SPEC (insn) & BE_IN_SPEC)\n     add_to_speculative_block (insn);\n }\n@@ -4094,7 +4094,7 @@ process_insn_forw_deps_be_in_spec (rtx insn, rtx twin, ds_t fs)\n \t\t  ds_t new_ds;\n \n \t\t  new_ds = (ds & ~BEGIN_SPEC) | fs;\n-\t\t  \n+\n \t\t  if (/* consumer can 'be in speculative'.  */\n \t\t      sched_insn_is_legitimate_for_speculation_p (consumer,\n \t\t\t\t\t\t\t\t  new_ds))\n@@ -4121,7 +4121,7 @@ static void\n begin_speculative_block (rtx insn)\n {\n   if (TODO_SPEC (insn) & BEGIN_DATA)\n-    nr_begin_data++;      \n+    nr_begin_data++;\n   if (TODO_SPEC (insn) & BEGIN_CONTROL)\n     nr_begin_control++;\n \n@@ -4152,7 +4152,7 @@ add_to_speculative_block (rtx insn)\n \n   TODO_SPEC (insn) &= ~BE_IN_SPEC;\n   gcc_assert (!TODO_SPEC (insn));\n-  \n+\n   DONE_SPEC (insn) |= ts;\n \n   /* First we convert all simple checks to branchy.  */\n@@ -4263,7 +4263,7 @@ add_to_speculative_block (rtx insn)\n \n       twin = XEXP (twins, 1);\n       free_INSN_LIST_node (twins);\n-      twins = twin;      \n+      twins = twin;\n     }\n \n   calc_priorities (priorities_roots);\n@@ -4354,16 +4354,16 @@ init_before_recovery (basic_block *before_recovery_ptr)\n \n   if (e)\n     {\n-      /* We create two basic blocks: \n+      /* We create two basic blocks:\n          1. Single instruction block is inserted right after E->SRC\n-         and has jump to \n+         and has jump to\n          2. Empty block right before EXIT_BLOCK.\n          Between these two blocks recovery blocks will be emitted.  */\n \n       basic_block single, empty;\n       rtx x, label;\n \n-      /* If the fallthrough edge to exit we've found is from the block we've \n+      /* If the fallthrough edge to exit we've found is from the block we've\n \t created before, don't do anything more.  */\n       if (last == after_recovery)\n \treturn;\n@@ -4397,7 +4397,7 @@ init_before_recovery (basic_block *before_recovery_ptr)\n       JUMP_LABEL (x) = label;\n       LABEL_NUSES (label)++;\n       haifa_init_insn (x);\n-          \n+\n       emit_barrier_after (x);\n \n       sched_init_only_bb (empty, NULL);\n@@ -4413,8 +4413,8 @@ init_before_recovery (basic_block *before_recovery_ptr)\n \n       if (sched_verbose >= 2 && spec_info->dump)\n         fprintf (spec_info->dump,\n-\t\t \";;\\t\\tFixed fallthru to EXIT : %d->>%d->%d->>EXIT\\n\", \n-                 last->index, single->index, empty->index);      \n+\t\t \";;\\t\\tFixed fallthru to EXIT : %d->>%d->%d->>EXIT\\n\",\n+                 last->index, single->index, empty->index);\n     }\n   else\n     before_recovery = last;\n@@ -4427,7 +4427,7 @@ sched_create_recovery_block (basic_block *before_recovery_ptr)\n   rtx label;\n   rtx barrier;\n   basic_block rec;\n-  \n+\n   haifa_recovery_bb_recently_added_p = true;\n   haifa_recovery_bb_ever_added_p = true;\n \n@@ -4445,8 +4445,8 @@ sched_create_recovery_block (basic_block *before_recovery_ptr)\n \n   if (BB_PARTITION (before_recovery) != BB_UNPARTITIONED)\n     BB_SET_PARTITION (rec, BB_COLD_PARTITION);\n-  \n-  if (sched_verbose && spec_info->dump)    \n+\n+  if (sched_verbose && spec_info->dump)\n     fprintf (spec_info->dump, \";;\\t\\tGenerated recovery block rec%d\\n\",\n              rec->index);\n \n@@ -4464,13 +4464,13 @@ sched_create_recovery_edges (basic_block first_bb, basic_block rec,\n   int edge_flags;\n \n   /* This is fixing of incoming edge.  */\n-  /* ??? Which other flags should be specified?  */      \n+  /* ??? Which other flags should be specified?  */\n   if (BB_PARTITION (first_bb) != BB_PARTITION (rec))\n     /* Partition type is the same, if it is \"unpartitioned\".  */\n     edge_flags = EDGE_CROSSING;\n   else\n     edge_flags = 0;\n-      \n+\n   make_edge (first_bb, rec, edge_flags);\n   label = block_label (second_bb);\n   jump = emit_jump_insn_after (gen_jump (label), BB_END (rec));\n@@ -4491,9 +4491,9 @@ sched_create_recovery_edges (basic_block first_bb, basic_block rec,\n       edge_flags = EDGE_CROSSING;\n     }\n   else\n-    edge_flags = 0;  \n+    edge_flags = 0;\n \n-  make_single_succ_edge (rec, second_bb, edge_flags);  \n+  make_single_succ_edge (rec, second_bb, edge_flags);\n }\n \n /* This function creates recovery code for INSN.  If MUTATE_P is nonzero,\n@@ -4541,7 +4541,7 @@ create_check_block_twin (rtx insn, bool mutate_p)\n   if (rec != EXIT_BLOCK_PTR)\n     {\n       /* To have mem_reg alive at the beginning of second_bb,\n-\t we emit check BEFORE insn, so insn after splitting \n+\t we emit check BEFORE insn, so insn after splitting\n \t insn will be at the beginning of second_bb, which will\n \t provide us with the correct life information.  */\n       check = emit_jump_insn_before (check, insn);\n@@ -4619,14 +4619,14 @@ create_check_block_twin (rtx insn, bool mutate_p)\n \n       sched_create_recovery_edges (first_bb, rec, second_bb);\n \n-      sched_init_only_bb (second_bb, first_bb);      \n+      sched_init_only_bb (second_bb, first_bb);\n       sched_init_only_bb (rec, EXIT_BLOCK_PTR);\n \n       jump = BB_END (rec);\n       haifa_init_insn (jump);\n     }\n \n-  /* Move backward dependences from INSN to CHECK and \n+  /* Move backward dependences from INSN to CHECK and\n      move forward dependences from INSN to TWIN.  */\n \n   /* First, create dependencies between INSN's producers and CHECK & TWIN.  */\n@@ -4639,7 +4639,7 @@ create_check_block_twin (rtx insn, bool mutate_p)\n \t check --TRUE--> producer  ??? or ANTI ???\n \t twin  --TRUE--> producer\n \t twin  --ANTI--> check\n-\t \n+\n \t If BEGIN_CONTROL: [insn ~~ANTI~~> producer]:\n \t check --ANTI--> producer\n \t twin  --ANTI--> producer\n@@ -4648,7 +4648,7 @@ create_check_block_twin (rtx insn, bool mutate_p)\n \t If BE_IN_SPEC: [insn ~~TRUE~~> producer]:\n \t check ~~TRUE~~> producer\n \t twin  ~~TRUE~~> producer\n-\t twin  --ANTI--> check  */\t      \t  \n+\t twin  --ANTI--> check  */\n \n       ds = DEP_STATUS (dep);\n \n@@ -4665,7 +4665,7 @@ create_check_block_twin (rtx insn, bool mutate_p)\n \t{\n \t  DEP_CON (new_dep) = twin;\n \t  sd_add_dep (new_dep, false);\n-\t}    \n+\t}\n     }\n \n   /* Second, remove backward dependencies of INSN.  */\n@@ -4686,11 +4686,11 @@ create_check_block_twin (rtx insn, bool mutate_p)\n \n   /* Fields (DONE_SPEC (x) & BEGIN_SPEC) and CHECK_SPEC (x) are set only\n      here.  */\n-  \n+\n   gcc_assert (!DONE_SPEC (insn));\n-  \n+\n   if (!mutate_p)\n-    { \n+    {\n       ds_t ts = TODO_SPEC (insn);\n \n       DONE_SPEC (insn) = ts & BEGIN_SPEC;\n@@ -4726,7 +4726,7 @@ create_check_block_twin (rtx insn, bool mutate_p)\n \t}\n       else\n \t{\n-\t  if (spec_info->dump)    \n+\t  if (spec_info->dump)\n \t    fprintf (spec_info->dump, \";;\\t\\tRemoved simple check : %s\\n\",\n \t\t     (*current_sched_info->print_insn) (insn, 0));\n \n@@ -4781,7 +4781,7 @@ fix_recovery_deps (basic_block rec)\n   rtx link;\n \n   bitmap_initialize (&in_ready, 0);\n-  \n+\n   /* NOTE - a basic block note.  */\n   note = NEXT_INSN (BB_HEAD (rec));\n   gcc_assert (NOTE_INSN_BASIC_BLOCK_P (note));\n@@ -4816,7 +4816,7 @@ fix_recovery_deps (basic_block rec)\n \t      sd_iterator_next (&sd_it);\n \t    }\n \t}\n-      \n+\n       insn = PREV_INSN (insn);\n     }\n   while (insn != note);\n@@ -4831,10 +4831,10 @@ fix_recovery_deps (basic_block rec)\n   /* Fixing jump's dependences.  */\n   insn = BB_HEAD (rec);\n   jump = BB_END (rec);\n-      \n+\n   gcc_assert (LABEL_P (insn));\n   insn = NEXT_INSN (insn);\n-  \n+\n   gcc_assert (NOTE_INSN_BASIC_BLOCK_P (insn));\n   add_jump_dependencies (insn, jump);\n }\n@@ -4948,7 +4948,7 @@ unlink_bb_notes (basic_block first, basic_block last)\n       if (LABEL_P (label))\n \tnote = NEXT_INSN (label);\n       else\n-\tnote = label;      \n+\tnote = label;\n       gcc_assert (NOTE_INSN_BASIC_BLOCK_P (note));\n \n       prev = PREV_INSN (label);\n@@ -4962,7 +4962,7 @@ unlink_bb_notes (basic_block first, basic_block last)\n \n       if (last == first)\n \tbreak;\n-      \n+\n       last = last->prev_bb;\n     }\n   while (1);\n@@ -4977,30 +4977,30 @@ restore_bb_notes (basic_block first)\n     return;\n \n   /* We DON'T unlink basic block notes of the first block in the ebb.  */\n-  first = first->next_bb;  \n+  first = first->next_bb;\n   /* Remember: FIRST is actually a second basic block in the ebb.  */\n \n   while (first != EXIT_BLOCK_PTR\n \t && bb_header[first->index])\n     {\n       rtx prev, label, note, next;\n-      \n+\n       label = bb_header[first->index];\n       prev = PREV_INSN (label);\n       next = NEXT_INSN (prev);\n \n       if (LABEL_P (label))\n \tnote = NEXT_INSN (label);\n       else\n-\tnote = label;      \n+\tnote = label;\n       gcc_assert (NOTE_INSN_BASIC_BLOCK_P (note));\n \n       bb_header[first->index] = 0;\n \n       NEXT_INSN (prev) = label;\n       NEXT_INSN (note) = next;\n       PREV_INSN (next) = note;\n-      \n+\n       first = first->next_bb;\n     }\n \n@@ -5022,7 +5022,7 @@ fix_jump_move (rtx jump)\n \n   gcc_assert (common_sched_info->sched_pass_id == SCHED_EBB_PASS\n \t      || IS_SPECULATION_BRANCHY_CHECK_P (jump));\n-  \n+\n   if (!NOTE_INSN_BASIC_BLOCK_P (BB_END (jump_bb_next)))\n     /* if jump_bb_next is not empty.  */\n     BB_END (jump_bb) = BB_END (jump_bb_next);\n@@ -5051,9 +5051,9 @@ move_block_after_check (rtx jump)\n   bb = BLOCK_FOR_INSN (PREV_INSN (jump));\n   jump_bb = BLOCK_FOR_INSN (jump);\n   jump_bb_next = jump_bb->next_bb;\n-  \n+\n   update_bb_for_insn (jump_bb);\n-  \n+\n   gcc_assert (IS_SPECULATION_CHECK_P (jump)\n \t      || IS_SPECULATION_CHECK_P (BB_END (jump_bb_next)));\n \n@@ -5067,7 +5067,7 @@ move_block_after_check (rtx jump)\n   move_succs (&t, jump_bb_next);\n \n   df_mark_solutions_dirty ();\n-  \n+\n   common_sched_info->fix_recovery_cfg\n     (bb->index, jump_bb->index, jump_bb_next->index);\n }\n@@ -5160,7 +5160,7 @@ add_jump_dependencies (rtx insn, rtx jump)\n       insn = NEXT_INSN (insn);\n       if (insn == jump)\n \tbreak;\n-      \n+\n       if (dep_list_size (insn) == 0)\n \t{\n \t  dep_def _new_dep, *new_dep = &_new_dep;\n@@ -5234,23 +5234,23 @@ check_cfg (rtx head, rtx tail)\n   next_tail = NEXT_INSN (tail);\n \n   do\n-    {      \n-      not_last = head != tail;        \n+    {\n+      not_last = head != tail;\n \n       if (not_first)\n \tgcc_assert (NEXT_INSN (PREV_INSN (head)) == head);\n       if (not_last)\n \tgcc_assert (PREV_INSN (NEXT_INSN (head)) == head);\n \n-      if (LABEL_P (head) \n+      if (LABEL_P (head)\n \t  || (NOTE_INSN_BASIC_BLOCK_P (head)\n \t      && (!not_first\n \t\t  || (not_first && !LABEL_P (PREV_INSN (head))))))\n \t{\n-\t  gcc_assert (bb == 0);\t  \n+\t  gcc_assert (bb == 0);\n \t  bb = BLOCK_FOR_INSN (head);\n \t  if (bb != 0)\n-\t    gcc_assert (BB_HEAD (bb) == head);      \n+\t    gcc_assert (BB_HEAD (bb) == head);\n \t  else\n \t    /* This is the case of jump table.  See inside_basic_block_p ().  */\n \t    gcc_assert (LABEL_P (head) && !inside_basic_block_p (head));\n@@ -5266,7 +5266,7 @@ check_cfg (rtx head, rtx tail)\n \t  gcc_assert (inside_basic_block_p (head)\n \t\t      || NOTE_P (head));\n \t  gcc_assert (BLOCK_FOR_INSN (head) == bb);\n-\t\n+\n \t  if (LABEL_P (head))\n \t    {\n \t      head = NEXT_INSN (head);\n@@ -5384,7 +5384,7 @@ sched_scan (const struct sched_scan_info_def *ssi,\n   extend_insn ();\n \n   if (bbs != NULL)\n-    {      \n+    {\n       unsigned i;\n       basic_block x;\n \n@@ -5481,12 +5481,12 @@ sched_extend_target (void)\n static void\n extend_h_i_d (void)\n {\n-  int reserve = (get_max_uid () + 1 \n+  int reserve = (get_max_uid () + 1\n                  - VEC_length (haifa_insn_data_def, h_i_d));\n-  if (reserve > 0 \n+  if (reserve > 0\n       && ! VEC_space (haifa_insn_data_def, h_i_d, reserve))\n     {\n-      VEC_safe_grow_cleared (haifa_insn_data_def, heap, h_i_d, \n+      VEC_safe_grow_cleared (haifa_insn_data_def, heap, h_i_d,\n                              3 * get_max_uid () / 2);\n       sched_extend_target ();\n     }\n@@ -5585,7 +5585,7 @@ sched_split_block_1 (basic_block first_bb, rtx after)\n   e = split_block (first_bb, after);\n   gcc_assert (e->src == first_bb);\n \n-  /* sched_split_block emits note if *check == BB_END.  Probably it \n+  /* sched_split_block emits note if *check == BB_END.  Probably it\n      is better to rip that note off.  */\n \n   return e->dest;"}, {"sha": "272a2394d5d486b120a85cb920562bc6229b7e20", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -19,7 +19,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #ifndef GCC_HARD_REG_SET_H\n-#define GCC_HARD_REG_SET_H \n+#define GCC_HARD_REG_SET_H\n \n /* Define the type of a set of hard registers.  */\n \n@@ -500,10 +500,10 @@ typedef struct\n \n #define HARD_REG_ELT_BITS UHOST_BITS_PER_WIDE_INT\n \n-/* The implementation of the iterator functions is fully analogous to \n+/* The implementation of the iterator functions is fully analogous to\n    the bitmap iterators.  */\n static inline void\n-hard_reg_set_iter_init (hard_reg_set_iterator *iter, HARD_REG_SET set, \n+hard_reg_set_iter_init (hard_reg_set_iterator *iter, HARD_REG_SET set,\n                         unsigned min, unsigned *regno)\n {\n #ifdef HARD_REG_SET_LONGS\n@@ -525,7 +525,7 @@ hard_reg_set_iter_init (hard_reg_set_iterator *iter, HARD_REG_SET set,\n   *regno = min;\n }\n \n-static inline bool \n+static inline bool\n hard_reg_set_iter_set (hard_reg_set_iterator *iter, unsigned *regno)\n {\n   while (1)\n@@ -544,7 +544,7 @@ hard_reg_set_iter_set (hard_reg_set_iterator *iter, unsigned *regno)\n             }\n           return (*regno < FIRST_PSEUDO_REGISTER);\n         }\n-  \n+\n       /* Round to the beginning of the next word.  */\n       *regno = (*regno + HARD_REG_ELT_BITS - 1);\n       *regno -= *regno % HARD_REG_ELT_BITS;"}, {"sha": "ccbce01ac855d7e2d544c45856248334718c0387", "filename": "gcc/hooks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -14,7 +14,7 @@\n \n    You should have received a copy of the GNU General Public License\n    along with this program; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  \n+   <http://www.gnu.org/licenses/>.\n \n    In other words, you are welcome to use, share and improve this program.\n    You are forbidden to forbid anyone else to use, share and improve"}, {"sha": "e0430de19f38771bfb778888e251ac3e4a9e58e3", "filename": "gcc/hooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -14,7 +14,7 @@\n \n    You should have received a copy of the GNU General Public License\n    along with this program; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  \n+   <http://www.gnu.org/licenses/>.\n \n    In other words, you are welcome to use, share and improve this program.\n    You are forbidden to forbid anyone else to use, share and improve"}, {"sha": "ce0e382c03eb256fa6029fcde2eb68ac28c90c23", "filename": "gcc/hosthooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fhosthooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fhosthooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhosthooks.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -30,7 +30,7 @@ struct host_hooks\n   void * (*gt_pch_get_address) (size_t size, int fd);\n \n   /* ADDR is an address returned by gt_pch_get_address.  Attempt to allocate\n-     SIZE bytes at the same address and load it with the data from FD at \n+     SIZE bytes at the same address and load it with the data from FD at\n      OFFSET.  Return -1 if we couldn't allocate memory at ADDR, return 0\n      if the memory is allocated but the data not loaded, return 1 if done.  */\n   int (*gt_pch_use_address) (void *addr, size_t size, int fd, size_t offset);"}, {"sha": "7dec86080dc41b3e4276f0e1cc6b316f72c08073", "filename": "gcc/hwint.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fhwint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fhwint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhwint.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -17,13 +17,13 @@\n \n /* The string that should be inserted into a printf style format to\n    indicate a \"long\" operand.  */\n-#ifndef HOST_LONG_FORMAT \n+#ifndef HOST_LONG_FORMAT\n #define HOST_LONG_FORMAT \"l\"\n #endif\n \n /* The string that should be inserted into a printf style format to\n    indicate a \"long long\" operand.  */\n-#ifndef HOST_LONG_LONG_FORMAT \n+#ifndef HOST_LONG_LONG_FORMAT\n #define HOST_LONG_LONG_FORMAT \"ll\"\n #endif\n "}, {"sha": "348c0cca8bfc06bf2c42b2fb33ba11a21c9322eb", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -3765,7 +3765,7 @@ find_if_case_2 (basic_block test_bb, edge then_edge, edge else_edge)\n \t     test_bb->index, else_bb->index);\n \n   /* ELSE is small.  */\n-  if (! cheap_bb_rtx_cost_p (else_bb, \n+  if (! cheap_bb_rtx_cost_p (else_bb,\n \tCOSTS_N_INSNS (BRANCH_COST (optimize_bb_for_speed_p (else_edge->src),\n \t\t\t\t    predictable_edge_p (else_edge)))))\n     return FALSE;\n@@ -3987,11 +3987,11 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \t\tfail = 1;\n \t    }\n \t}\n-      \n+\n       /* For TEST, we're interested in a range of insns, not a whole block.\n \t Moreover, we're interested in the insns live from OTHER_BB.  */\n-      \n-      /* The loop below takes the set of live registers \n+\n+      /* The loop below takes the set of live registers\n          after JUMP, and calculates the live set before EARLIEST. */\n       bitmap_copy (test_live, df_get_live_in (other_bb));\n       df_simulate_initialize_backwards (test_bb, test_live);\n@@ -4157,7 +4157,7 @@ if_convert (void)\n       FOR_EACH_BB (bb)\n \t{\n           basic_block new_bb;\n-          while (!df_get_bb_dirty (bb) \n+          while (!df_get_bb_dirty (bb)\n                  && (new_bb = find_if_header (bb, pass)) != NULL)\n             bb = new_bb;\n \t}"}, {"sha": "9cc783f6132bb3cf8bee09c1b122c1ef3967d1e7", "filename": "gcc/incpath.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fincpath.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fincpath.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fincpath.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -171,8 +171,8 @@ add_standard_paths (const char *sysroot, const char *iprefix,\n \t\t   && strncmp (p->fname, cpp_PREFIX, cpp_PREFIX_len) == 0)\n \t    {\n  \t      static const char *relocated_prefix;\n-\t      /* If this path starts with the configure-time prefix, \n-\t\t but the compiler has been relocated, replace it \n+\t      /* If this path starts with the configure-time prefix,\n+\t\t but the compiler has been relocated, replace it\n \t\t with the run-time prefix.  The run-time exec prefix\n \t\t is GCC_EXEC_PREFIX.  Compute the path from there back\n \t\t to the toplevel prefix.  */\n@@ -182,13 +182,13 @@ add_standard_paths (const char *sysroot, const char *iprefix,\n \t\t  /* Make relative prefix expects the first argument\n \t\t     to be a program, not a directory.  */\n \t\t  dummy = concat (gcc_exec_prefix, \"dummy\", NULL);\n-\t\t  relocated_prefix \n+\t\t  relocated_prefix\n \t\t    = make_relative_prefix (dummy,\n \t\t\t\t\t    cpp_EXEC_PREFIX,\n \t\t\t\t\t    cpp_PREFIX);\n \t\t}\n \t      str = concat (relocated_prefix,\n-\t\t\t    p->fname + cpp_PREFIX_len, \n+\t\t\t    p->fname + cpp_PREFIX_len,\n \t\t\t    NULL);\n \t      str = update_path (str, p->component);\n \t    }\n@@ -399,7 +399,7 @@ add_path (char *path, int chain, int cxx_aware, bool user_supplied_p)\n   char* end = path + pathlen - 1;\n   /* Preserve the lead '/' or lead \"c:/\".  */\n   char* start = path + (pathlen > 2 && path[1] == ':' ? 3 : 1);\n-  \n+\n   for (; end > start && IS_DIR_SEPARATOR (*end); end--)\n     *end = 0;\n #endif"}, {"sha": "b4dd5e9a1fbb2a3f623090d384945ac2013545a7", "filename": "gcc/init-regs.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Finit-regs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Finit-regs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finit-regs.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -1,4 +1,4 @@\n-/* Initialization of uninitialized regs. \n+/* Initialization of uninitialized regs.\n    Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -99,16 +99,16 @@ initialize_uninitialized_regs (void)\n \t\t  rtx move_insn;\n \t\t  rtx reg = DF_REF_REAL_REG (use);\n \n-\t\t  bitmap_set_bit (already_genned, regno); \n+\t\t  bitmap_set_bit (already_genned, regno);\n \n \t\t  start_sequence ();\n \t\t  emit_move_insn (reg, CONST0_RTX (GET_MODE (reg)));\n \t\t  move_insn = get_insns ();\n \t\t  end_sequence ();\n \t\t  emit_insn_before (move_insn, insn);\n \t\t  if (dump_file)\n-\t\t    fprintf (dump_file, \n-\t\t\t     \"adding initialization in %s of reg %d at in block %d for insn %d.\\n\", \n+\t\t    fprintf (dump_file,\n+\t\t\t     \"adding initialization in %s of reg %d at in block %d for insn %d.\\n\",\n \t\t\t     current_function_name (), regno, bb->index, uid);\n \t\t}\n \t    }\n@@ -117,7 +117,7 @@ initialize_uninitialized_regs (void)\n \n   if (optimize == 1)\n     {\n-      if (dump_file) \n+      if (dump_file)\n \tdf_dump (dump_file);\n       df_remove_problem (df_live);\n     }"}, {"sha": "0884017e3916e20ffc3dfd5f1d60156d22ad7101", "filename": "gcc/integrate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -343,7 +343,7 @@ allocate_initial_values (rtx *reg_equiv_memory_loc)\n \t{\n \t  int regno = REGNO (ivs->entries[i].pseudo);\n \t  rtx x = targetm.allocate_initial_value (ivs->entries[i].hard_reg);\n-  \n+\n \t  if (x && REG_N_SETS (REGNO (ivs->entries[i].pseudo)) <= 1)\n \t    {\n \t      if (MEM_P (x))"}, {"sha": "b6e471230fa8c3be19865915baac704233d4a333", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -1,19 +1,19 @@\n /* Interprocedural constant propagation\n    Copyright (C) 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n    Contributed by Razya Ladelsky <RAZYA@il.ibm.com>\n-   \n+\n This file is part of GCC.\n-   \n+\n GCC is free software; you can redistribute it and/or modify it under\n the terms of the GNU General Public License as published by the Free\n Software Foundation; either version 3, or (at your option) any later\n version.\n-   \n+\n GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n WARRANTY; without even the implied warranty of MERCHANTABILITY or\n FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n for more details.\n-   \n+\n You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n@@ -27,7 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n    {\n      printf (\"value is %d\",y);\n    }\n-   \n+\n    int f (int x)\n    {\n      g (x);\n@@ -43,32 +43,32 @@ along with GCC; see the file COPYING3.  If not see\n      f (3);\n      h (3);\n    }\n-   \n-   \n+\n+\n    The IPCP algorithm will find that g's formal argument y is always called\n    with the value 3.\n \n    The algorithm used is based on \"Interprocedural Constant Propagation\", by\n    Challahan David, Keith D Cooper, Ken Kennedy, Linda Torczon, Comp86, pg\n    152-161\n-   \n+\n    The optimization is divided into three stages:\n \n    First stage - intraprocedural analysis\n    =======================================\n    This phase computes jump_function and modification flags.\n-   \n+\n    A jump function for a callsite represents the values passed as an actual\n    arguments of a given callsite. There are three types of values:\n    Pass through - the caller's formal parameter is passed as an actual argument.\n    Constant - a constant is passed as an actual argument.\n    Unknown - neither of the above.\n-   \n+\n    The jump function info, ipa_jump_func, is stored in ipa_edge_args\n    structure (defined in ipa_prop.h and pointed to by cgraph_node->aux)\n    modified_flags are defined in ipa_node_params structure\n    (defined in ipa_prop.h and pointed to by cgraph_edge->aux).\n-   \n+\n    -ipcp_init_stage() is the first stage driver.\n \n    Second stage - interprocedural analysis\n@@ -79,10 +79,10 @@ along with GCC; see the file COPYING3.  If not see\n    TOP - unknown.\n    BOTTOM - non constant.\n    CONSTANT - constant value.\n-   \n+\n    Lattice describing a formal parameter p will have a constant value if all\n    callsites invoking this function have the same constant value passed to p.\n-   \n+\n    The lattices are stored in ipcp_lattice which is itself in ipa_node_params\n    structure (defined in ipa_prop.h and pointed to by cgraph_edge->aux).\n \n@@ -115,7 +115,7 @@ along with GCC; see the file COPYING3.  If not see\n    and many calls redirected back to fit the description above.\n \n    -ipcp_insert_stage() is the third phase driver.\n-   \n+\n */\n \n #include \"config.h\"\n@@ -473,7 +473,7 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n       if (cgraph_maybe_hot_edge_p (e))\n \tn_hot_calls ++;\n     }\n-  \n+\n   if (!n_calls)\n     {\n       if (dump_file)\n@@ -487,7 +487,7 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n         fprintf (dump_file, \"Considering %s for cloning; code would shrink.\\n\",\n  \t         cgraph_node_name (node));\n       return true;\n-    }  \n+    }\n \n   if (!flag_ipa_cp_clone)\n     {\n@@ -634,7 +634,7 @@ ipcp_init_stage (void)\n \t  if (ipa_get_cs_argument_count (IPA_EDGE_REF (cs))\n \t      != ipa_get_param_count (IPA_NODE_REF (cs->callee)))\n \t    {\n-\t      /* Handle cases of functions with \n+\t      /* Handle cases of functions with\n \t         a variable number of parameters.  */\n \t      ipa_set_called_with_variable_arg (IPA_NODE_REF (cs->callee));\n \t      if (flag_indirect_inlining)\n@@ -1291,7 +1291,7 @@ ipcp_generate_summary (void)\n   ipa_check_create_node_params ();\n   ipa_check_create_edge_args ();\n   ipa_register_cgraph_hooks ();\n-  /* 1. Call the init stage to initialize \n+  /* 1. Call the init stage to initialize\n      the ipa_node_params and ipa_edge_args structures.  */\n   ipcp_init_stage ();\n }"}, {"sha": "120c234f89b8a90cf808024556c844c1bc64e286", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -262,7 +262,7 @@ cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n       else\n \t{\n \t  struct cgraph_node *n;\n-\t  n = cgraph_clone_node (e->callee, e->count, e->frequency, e->loop_nest, \n+\t  n = cgraph_clone_node (e->callee, e->count, e->frequency, e->loop_nest,\n \t\t\t\t update_original, NULL);\n \t  cgraph_redirect_edge_callee (e, n);\n \t}\n@@ -402,7 +402,7 @@ cgraph_estimate_growth (struct cgraph_node *node)\n }\n \n /* Return false when inlining WHAT into TO is not good idea\n-   as it would cause too large growth of function bodies.  \n+   as it would cause too large growth of function bodies.\n    When ONE_ONLY is true, assume that only one call site is going\n    to be inlined, otherwise figure out how many call sites in\n    TO calls WHAT and verify that all can be inlined.\n@@ -571,7 +571,7 @@ cgraph_edge_badness (struct cgraph_edge *edge)\n       badness = growth * 10000;\n       div *= MIN (100 * inline_summary (edge->callee)->time_inlining_benefit\n       \t          / (edge->callee->global.time + 1) + 1, 100);\n-      \n+\n \n       /* Decrease badness if call is nested.  */\n       /* Compress the range so we don't overflow.  */\n@@ -595,7 +595,7 @@ cgraph_edge_badness (struct cgraph_edge *edge)\n       badness = cgraph_estimate_growth (edge->callee) * 256;\n \n       /* Decrease badness if call is nested.  */\n-      if (badness > 0)    \n+      if (badness > 0)\n \tbadness >>= nest;\n       else\n         {\n@@ -744,7 +744,7 @@ cgraph_decide_recursive_inlining (struct cgraph_node *node,\n     }\n \n   if (dump_file)\n-    fprintf (dump_file, \n+    fprintf (dump_file,\n \t     \"  Performing recursive inlining on %s\\n\",\n \t     cgraph_node_name (node));\n \n@@ -773,7 +773,7 @@ cgraph_decide_recursive_inlining (struct cgraph_node *node,\n       if (depth > max_depth)\n \t{\n           if (dump_file)\n-\t    fprintf (dump_file, \n+\t    fprintf (dump_file,\n \t\t     \"   maximal depth reached\\n\");\n \t  continue;\n \t}\n@@ -789,15 +789,15 @@ cgraph_decide_recursive_inlining (struct cgraph_node *node,\n           if (curr->count * 100 / node->count < probability)\n \t    {\n \t      if (dump_file)\n-\t\tfprintf (dump_file, \n+\t\tfprintf (dump_file,\n \t\t\t \"   Probability of edge is too small\\n\");\n \t      continue;\n \t    }\n \t}\n \n       if (dump_file)\n \t{\n-\t  fprintf (dump_file, \n+\t  fprintf (dump_file,\n \t\t   \"   Inlining call of depth %i\", depth);\n \t  if (node->count)\n \t    {\n@@ -816,7 +816,7 @@ cgraph_decide_recursive_inlining (struct cgraph_node *node,\n \n   fibheap_delete (heap);\n   if (dump_file)\n-    fprintf (dump_file, \n+    fprintf (dump_file,\n \t     \"\\n   Inlined %i times, body grown from size %i to %i, time %i to %i\\n\", n,\n \t     master_clone->global.size, node->global.size,\n \t     master_clone->global.time, node->global.time);\n@@ -947,11 +947,11 @@ cgraph_decide_inlining_of_small_functions (void)\n \n       if (dump_file)\n \t{\n-\t  fprintf (dump_file, \n+\t  fprintf (dump_file,\n \t\t   \"\\nConsidering %s with %i size\\n\",\n \t\t   cgraph_node_name (edge->callee),\n \t\t   edge->callee->global.size);\n-\t  fprintf (dump_file, \n+\t  fprintf (dump_file,\n \t\t   \" to be inlined into %s in %s:%i\\n\"\n \t\t   \" Estimated growth after inlined into all callees is %+i insns.\\n\"\n \t\t   \" Estimated badness is %i, frequency %.2f.\\n\",\n@@ -1089,7 +1089,7 @@ cgraph_decide_inlining_of_small_functions (void)\n \n       if (dump_file)\n \t{\n-\t  fprintf (dump_file, \n+\t  fprintf (dump_file,\n \t\t   \" Inlined into %s which now has size %i and self time %i,\"\n \t\t   \"net change of %+i.\\n\",\n \t\t   cgraph_node_name (edge->caller),\n@@ -1228,7 +1228,7 @@ cgraph_decide_inlining (void)\n \t    if (e->inline_failed)\n \t      e->inline_failed = CIF_RECURSIVE_INLINING;\n \t  if (dump_file)\n-\t    fprintf (dump_file, \n+\t    fprintf (dump_file,\n \t\t     \" Inlined for a net change of %+i size.\\n\",\n \t\t     overall_size - old_size);\n \t}\n@@ -1360,7 +1360,7 @@ try_inline (struct cgraph_edge *e, enum inlining_mode mode, int depth)\n           return false;\n \t}\n     }\n-      \n+\n   callee->aux = (void *)(size_t) mode;\n   if (dump_file)\n     {\n@@ -1375,7 +1375,7 @@ try_inline (struct cgraph_edge *e, enum inlining_mode mode, int depth)\n \n       /* In order to fully inline always_inline functions, we need to\n \t recurse here, since the inlined functions might not be processed by\n-\t incremental inlining at all yet.  \n+\t incremental inlining at all yet.\n \n \t Also flattening needs to be done recursively.  */\n \n@@ -1402,7 +1402,7 @@ leaf_node_p (struct cgraph_node *n)\n }\n \n /* Decide on the inlining.  We do so in the topological order to avoid\n-   expenses on updating data structures.  \n+   expenses on updating data structures.\n    DEPTH is depth of recursion, used only for debug output.  */\n \n static bool\n@@ -1638,7 +1638,7 @@ cgraph_gate_early_inlining (void)\n   return flag_early_inlining;\n }\n \n-struct gimple_opt_pass pass_early_inline = \n+struct gimple_opt_pass pass_early_inline =\n {\n  {\n   GIMPLE_PASS,\n@@ -1669,7 +1669,7 @@ cgraph_gate_ipa_early_inlining (void)\n \n /* IPA pass wrapper for early inlining pass.  We need to run early inlining\n    before tree profiling so we have stand alone IPA pass for doing so.  */\n-struct simple_ipa_opt_pass pass_ipa_early_inline = \n+struct simple_ipa_opt_pass pass_ipa_early_inline =\n {\n  {\n   SIMPLE_IPA_PASS,\n@@ -1723,7 +1723,7 @@ likely_eliminated_by_inlining_p (gimple stmt)\n  \t    while (handled_component_p (inner_rhs)\n \t           || TREE_CODE (inner_rhs) == ADDR_EXPR || TREE_CODE (inner_rhs) == INDIRECT_REF)\n \t      inner_rhs = TREE_OPERAND (inner_rhs, 0);\n-\t\t\n+\n \n \t    if (TREE_CODE (inner_rhs) == PARM_DECL\n \t        || (TREE_CODE (inner_rhs) == SSA_NAME\n@@ -1875,7 +1875,7 @@ compute_inline_parameters_for_current (void)\n   return 0;\n }\n \n-struct gimple_opt_pass pass_inline_parameters = \n+struct gimple_opt_pass pass_inline_parameters =\n {\n  {\n   GIMPLE_PASS,\n@@ -1963,7 +1963,7 @@ inline_generate_summary (void)\n   for (node = cgraph_nodes; node; node = node->next)\n     if (node->analyzed)\n       analyze_function (node);\n-  \n+\n   return;\n }\n \n@@ -2003,7 +2003,7 @@ inline_transform (struct cgraph_node *node)\n    and inliner, so when ipa-cp is active, we don't need to write them\n    twice.  */\n \n-static void \n+static void\n inline_read_summary (void)\n {\n   if (flag_indirect_inlining)\n@@ -2020,7 +2020,7 @@ inline_read_summary (void)\n    Jump functions are shared among ipa-cp and inliner, so when ipa-cp is\n    active, we don't need to write them twice.  */\n \n-static void \n+static void\n inline_write_summary (cgraph_node_set set)\n {\n   if (flag_indirect_inlining && !flag_ipa_cp)"}, {"sha": "6a018f456eacc4a090b70cc33c888694a02c57de", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -2190,7 +2190,7 @@ ipa_prop_read_jump_functions (void)\n     }\n }\n \n-/* After merging units, we can get mismatch in argument counts. \n+/* After merging units, we can get mismatch in argument counts.\n    Also decl merging might've rendered parameter lists obsolette.\n    Also compute called_with_variable_arg info.  */\n "}, {"sha": "9efcb8d0524a47d8c975a267c26365c6c311a670", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -69,13 +69,13 @@ enum pure_const_state_e\n \n /* Holder for the const_state.  There is one of these per function\n    decl.  */\n-struct funct_state_d \n+struct funct_state_d\n {\n   /* See above.  */\n   enum pure_const_state_e pure_const_state;\n   /* What user set here; we can be always sure about this.  */\n-  enum pure_const_state_e state_previously_known; \n-  bool looping_previously_known; \n+  enum pure_const_state_e state_previously_known;\n+  bool looping_previously_known;\n \n   /* True if the function could possibly infinite loop.  There are a\n      lot of ways that this could be determined.  We are pretty\n@@ -92,7 +92,7 @@ typedef struct funct_state_d * funct_state;\n \n /* The storage of the funct_state is abstracted because there is the\n    possibility that it may be desirable to move this to the cgraph\n-   local info.  */ \n+   local info.  */\n \n /* Array, indexed by cgraph node uid, of function states.  */\n \n@@ -114,7 +114,7 @@ finish_state (void)\n }\n \n \n-/* Return the function state from NODE.  */ \n+/* Return the function state from NODE.  */\n \n static inline funct_state\n get_function_state (struct cgraph_node *node)\n@@ -139,14 +139,14 @@ set_function_state (struct cgraph_node *node, funct_state s)\n /* Check to see if the use (or definition when CHECKING_WRITE is true)\n    variable T is legal in a function that is either pure or const.  */\n \n-static inline void \n-check_decl (funct_state local, \n+static inline void\n+check_decl (funct_state local,\n \t    tree t, bool checking_write)\n {\n   /* Do not want to do anything with volatile except mark any\n      function that uses one to be not const or pure.  */\n-  if (TREE_THIS_VOLATILE (t)) \n-    { \n+  if (TREE_THIS_VOLATILE (t))\n+    {\n       local->pure_const_state = IPA_NEITHER;\n       if (dump_file)\n         fprintf (dump_file, \"    Volatile operand is not const/pure\");\n@@ -170,7 +170,7 @@ check_decl (funct_state local,\n   /* Since we have dealt with the locals and params cases above, if we\n      are CHECKING_WRITE, this cannot be a pure or constant\n      function.  */\n-  if (checking_write) \n+  if (checking_write)\n     {\n       local->pure_const_state = IPA_NEITHER;\n       if (dump_file)\n@@ -183,7 +183,7 @@ check_decl (funct_state local,\n       /* Readonly reads are safe.  */\n       if (TREE_READONLY (t) && !TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (t)))\n \treturn; /* Read of a constant, do not change the function state.  */\n-      else \n+      else\n \t{\n           if (dump_file)\n             fprintf (dump_file, \"    global memory read is not const\\n\");\n@@ -211,7 +211,7 @@ check_decl (funct_state local,\n /* Check to see if the use (or definition when CHECKING_WRITE is true)\n    variable T is legal in a function that is either pure or const.  */\n \n-static inline void \n+static inline void\n check_op (funct_state local, tree t, bool checking_write)\n {\n   t = get_base_address (t);\n@@ -286,17 +286,17 @@ check_call (funct_state local, gimple call, bool ipa)\n \t      }\n \t  }\n     }\n-  \n+\n   /* The const and pure flags are set by a variety of places in the\n      compiler (including here).  If someone has already set the flags\n      for the callee, (such as for some of the builtins) we will use\n-     them, otherwise we will compute our own information. \n-  \n+     them, otherwise we will compute our own information.\n+\n      Const and pure functions have less clobber effects than other\n      functions so we process these first.  Otherwise if it is a call\n      outside the compilation unit or an indirect call we punt.  This\n      leaves local calls which will be processed by following the call\n-     graph.  */  \n+     graph.  */\n   if (callee_t)\n     {\n       callee = cgraph_node(callee_t);\n@@ -354,12 +354,12 @@ check_call (funct_state local, gimple call, bool ipa)\n \t    }\n           local->can_throw = true;\n \t}\n-      if (flags & ECF_CONST) \n+      if (flags & ECF_CONST)\n \t{\n           if (callee_t && DECL_LOOPING_CONST_OR_PURE_P (callee_t))\n             local->looping = true;\n \t }\n-      else if (flags & ECF_PURE) \n+      else if (flags & ECF_PURE)\n \t{\n           if (callee_t && DECL_LOOPING_CONST_OR_PURE_P (callee_t))\n             local->looping = true;\n@@ -368,7 +368,7 @@ check_call (funct_state local, gimple call, bool ipa)\n \t  if (local->pure_const_state == IPA_CONST)\n \t    local->pure_const_state = IPA_PURE;\n \t}\n-      else \n+      else\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"    uknown function call is not const/pure\\n\");\n@@ -457,7 +457,7 @@ check_stmt (gimple_stmt_iterator *gsip, funct_state local, bool ipa)\n       for (i = 0; i < gimple_asm_nclobbers (stmt); i++)\n \t{\n \t  tree op = gimple_asm_clobber_op (stmt, i);\n-\t  if (simple_cst_equal(TREE_VALUE (op), memory_identifier_string) == 1) \n+\t  if (simple_cst_equal(TREE_VALUE (op), memory_identifier_string) == 1)\n \t    {\n               if (dump_file)\n                 fprintf (dump_file, \"    memory asm clobber is not const/pure\");\n@@ -500,13 +500,13 @@ analyze_function (struct cgraph_node *fn, bool ipa)\n \n   if (dump_file)\n     {\n-      fprintf (dump_file, \"\\n\\n local analysis of %s\\n \", \n+      fprintf (dump_file, \"\\n\\n local analysis of %s\\n \",\n \t       cgraph_node_name (fn));\n     }\n-  \n+\n   push_cfun (DECL_STRUCT_FUNCTION (decl));\n   current_function_decl = decl;\n-  \n+\n   FOR_EACH_BB (this_block)\n     {\n       gimple_stmt_iterator gsi;\n@@ -544,7 +544,7 @@ analyze_function (struct cgraph_node *fn, bool ipa)\n \t        fprintf (dump_file, \"    has irreducible loops\\n\");\n \t      l->looping = true;\n \t    }\n-\t  else \n+\t  else\n \t    {\n \t      loop_iterator li;\n \t      struct loop *loop;\n@@ -663,7 +663,7 @@ register_hooks (void)\n /* Analyze each function in the cgraph to see if it is locally PURE or\n    CONST.  */\n \n-static void \n+static void\n generate_summary (void)\n {\n   struct cgraph_node *node;\n@@ -676,7 +676,7 @@ generate_summary (void)\n      operations.  */\n   visited_nodes = pointer_set_create ();\n \n-  /* Process all of the functions. \n+  /* Process all of the functions.\n \n      We process AVAIL_OVERWRITABLE functions.  We can not use the results\n      by default, but the info can be used at LTO with -fwhole-program or\n@@ -708,9 +708,9 @@ pure_const_write_summary (cgraph_node_set set)\n       if (node->analyzed && get_function_state (node) != NULL)\n \tcount++;\n     }\n-  \n+\n   lto_output_uleb128_stream (ob->main_stream, count);\n-  \n+\n   /* Process all of the functions.  */\n   for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n     {\n@@ -721,13 +721,13 @@ pure_const_write_summary (cgraph_node_set set)\n \t  funct_state fs;\n \t  int node_ref;\n \t  lto_cgraph_encoder_t encoder;\n-\t  \n+\n \t  fs = get_function_state (node);\n \n \t  encoder = ob->decl_state->cgraph_node_encoder;\n \t  node_ref = lto_cgraph_encoder_encode (encoder, node);\n \t  lto_output_uleb128_stream (ob->main_stream, node_ref);\n-\t\n+\n \t  /* Note that flags will need to be read in the opposite\n \t     order as we are pushing the bitflags into FLAGS.  */\n \t  bp = bitpack_create ();\n@@ -747,7 +747,7 @@ pure_const_write_summary (cgraph_node_set set)\n \n /* Deserialize the ipa info for lto.  */\n \n-static void \n+static void\n pure_const_read_summary (void)\n {\n   struct lto_file_decl_data **file_data_vec = lto_get_file_decl_data ();\n@@ -760,8 +760,8 @@ pure_const_read_summary (void)\n       const char *data;\n       size_t len;\n       struct lto_input_block *ib\n-\t= lto_create_simple_input_block (file_data, \n-\t\t\t\t\t LTO_section_ipa_pure_const, \n+\t= lto_create_simple_input_block (file_data,\n+\t\t\t\t\t LTO_section_ipa_pure_const,\n \t\t\t\t\t &data, &len);\n       if (ib)\n \t{\n@@ -796,8 +796,8 @@ pure_const_read_summary (void)\n \t      bitpack_delete (bp);\n \t    }\n \n-\t  lto_destroy_simple_input_block (file_data, \n-\t\t\t\t\t  LTO_section_ipa_pure_const, \n+\t  lto_destroy_simple_input_block (file_data,\n+\t\t\t\t\t  LTO_section_ipa_pure_const,\n \t\t\t\t\t  ib, data, len);\n \t}\n     }\n@@ -884,8 +884,8 @@ propagate (void)\n \n \t  if (count > 1)\n \t    looping = true;\n-\t\t\n-\t  for (e = w->callees; e; e = e->next_callee) \n+\n+\t  for (e = w->callees; e; e = e->next_callee)\n \t    {\n \t      struct cgraph_node *y = e->callee;\n \n@@ -943,22 +943,22 @@ propagate (void)\n \t    {\n \t    case IPA_CONST:\n \t      if (!TREE_READONLY (w->decl) && dump_file)\n-\t\tfprintf (dump_file, \"Function found to be %sconst: %s\\n\",  \n+\t\tfprintf (dump_file, \"Function found to be %sconst: %s\\n\",\n \t\t\t this_looping ? \"looping \" : \"\",\n-\t\t\t cgraph_node_name (w)); \n+\t\t\t cgraph_node_name (w));\n \t      TREE_READONLY (w->decl) = 1;\n \t      DECL_LOOPING_CONST_OR_PURE_P (w->decl) = this_looping;\n \t      break;\n-\t      \n+\n \t    case IPA_PURE:\n \t      if (!DECL_PURE_P (w->decl) && dump_file)\n-\t\tfprintf (dump_file, \"Function found to be %spure: %s\\n\",  \n+\t\tfprintf (dump_file, \"Function found to be %spure: %s\\n\",\n \t\t\t this_looping ? \"looping \" : \"\",\n-\t\t\t cgraph_node_name (w)); \n+\t\t\t cgraph_node_name (w));\n \t      DECL_PURE_P (w->decl) = 1;\n \t      DECL_LOOPING_CONST_OR_PURE_P (w->decl) = this_looping;\n \t      break;\n-\t      \n+\n \t    default:\n \t      break;\n \t    }\n@@ -1006,16 +1006,16 @@ propagate (void)\n \n \t  if (can_throw)\n \t    break;\n-\t\t\n-\t  for (e = w->callees; e; e = e->next_callee) \n+\n+\t  for (e = w->callees; e; e = e->next_callee)\n \t    {\n \t      struct cgraph_node *y = e->callee;\n \n \t      if (cgraph_function_body_availability (y) > AVAIL_OVERWRITABLE)\n \t\t{\n \t\t  funct_state y_l = get_function_state (y);\n \n-\t\t  if (can_throw) \n+\t\t  if (can_throw)\n \t\t    break;\n \t\t  if (y_l->can_throw && !TREE_NOTHROW (w->decl)\n \t\t      && e->can_throw_external)\n@@ -1041,7 +1041,7 @@ propagate (void)\n \t      for (e = w->callers; e; e = e->next_caller)\n \t        e->can_throw_external = false;\n \t      if (dump_file)\n-\t\tfprintf (dump_file, \"Function found to be nothrow: %s\\n\",  \n+\t\tfprintf (dump_file, \"Function found to be nothrow: %s\\n\",\n \t\t\t cgraph_node_name (w));\n \t    }\n \t  else if (can_throw && !TREE_NOTHROW (w->decl))\n@@ -1064,7 +1064,7 @@ propagate (void)\n       if (cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n \tfree (get_function_state (node));\n     }\n-  \n+\n   free (order);\n   VEC_free (funct_state, heap, funct_state_vec);\n   finish_state ();"}, {"sha": "032bef278ebcca00d26864a31f308303f86db00e", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 125, "deletions": 125, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c", "patch": "@@ -19,7 +19,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n /* This file gathers information about how variables whose scope is\n-   confined to the compilation unit are used.  \n+   confined to the compilation unit are used.\n \n    There are two categories of information produced by this pass:\n \n@@ -41,7 +41,7 @@ along with GCC; see the file COPYING3.  If not see\n    local and global sets are examined to make the call clobbering less\n    traumatic, promote some statics to registers, and improve aliasing\n    information.\n-   \n+\n    Currently must be run after inlining decisions have been made since\n    otherwise, the local sets will not contain information that is\n    consistent with post inlined state.  The global sets are not prone\n@@ -79,9 +79,9 @@ static void duplicate_node_data (struct cgraph_node *src,\n \t\t\t\t void *data ATTRIBUTE_UNUSED);\n \n /* The static variables defined within the compilation unit that are\n-   loaded or stored directly by function that owns this structure.  */ \n+   loaded or stored directly by function that owns this structure.  */\n \n-struct ipa_reference_local_vars_info_d \n+struct ipa_reference_local_vars_info_d\n {\n   bitmap statics_read;\n   bitmap statics_written;\n@@ -104,7 +104,7 @@ struct ipa_reference_local_vars_info_d\n    strongly connected component will have the same information.  This\n    sharing saves both time and space in the computation of the vectors\n    as well as their translation from decl_uid form to ann_uid\n-   form.  */ \n+   form.  */\n \n struct ipa_reference_global_vars_info_d\n {\n@@ -116,7 +116,7 @@ struct ipa_reference_global_vars_info_d\n \n typedef struct ipa_reference_local_vars_info_d *ipa_reference_local_vars_info_t;\n typedef struct ipa_reference_global_vars_info_d *ipa_reference_global_vars_info_t;\n-struct ipa_reference_vars_info_d \n+struct ipa_reference_vars_info_d\n {\n   ipa_reference_local_vars_info_t local;\n   ipa_reference_global_vars_info_t global;\n@@ -196,41 +196,41 @@ set_reference_vars_info (struct cgraph_node *node, ipa_reference_vars_info_t inf\n /* Get a bitmap that contains all of the locally referenced static\n    variables for function FN.  */\n static ipa_reference_local_vars_info_t\n-get_local_reference_vars_info (struct cgraph_node *fn) \n+get_local_reference_vars_info (struct cgraph_node *fn)\n {\n   ipa_reference_vars_info_t info = get_reference_vars_info (fn);\n \n   if (info)\n     return info->local;\n   else\n-    /* This phase was not run.  */ \n+    /* This phase was not run.  */\n     return NULL;\n }\n \n /* Get a bitmap that contains all of the globally referenced static\n    variables for function FN.  */\n- \n+\n static ipa_reference_global_vars_info_t\n-get_global_reference_vars_info (struct cgraph_node *fn) \n+get_global_reference_vars_info (struct cgraph_node *fn)\n {\n   ipa_reference_vars_info_t info = get_reference_vars_info (fn);\n \n   if (info)\n     return info->global;\n   else\n-    /* This phase was not run.  */ \n+    /* This phase was not run.  */\n     return NULL;\n }\n \n /* Return a bitmap indexed by VAR_DECL uid for the static variables\n    that are read during the execution of the function FN.  Returns\n    NULL if no data is available.  */\n \n-bitmap \n-ipa_reference_get_read_global (struct cgraph_node *fn) \n+bitmap\n+ipa_reference_get_read_global (struct cgraph_node *fn)\n {\n   ipa_reference_global_vars_info_t g = get_global_reference_vars_info (fn);\n-  if (g) \n+  if (g)\n     return g->statics_read;\n   else\n     return NULL;\n@@ -241,11 +241,11 @@ ipa_reference_get_read_global (struct cgraph_node *fn)\n    that variables written may or may not be read during the function\n    call.  Returns NULL if no data is available.  */\n \n-bitmap \n-ipa_reference_get_written_global (struct cgraph_node *fn) \n+bitmap\n+ipa_reference_get_written_global (struct cgraph_node *fn)\n {\n   ipa_reference_global_vars_info_t g = get_global_reference_vars_info (fn);\n-  if (g) \n+  if (g)\n     return g->statics_written;\n   else\n     return NULL;\n@@ -255,11 +255,11 @@ ipa_reference_get_written_global (struct cgraph_node *fn)\n    that are not read during the execution of the function FN.  Returns\n    NULL if no data is available.  */\n \n-bitmap \n-ipa_reference_get_not_read_global (struct cgraph_node *fn) \n+bitmap\n+ipa_reference_get_not_read_global (struct cgraph_node *fn)\n {\n   ipa_reference_global_vars_info_t g = get_global_reference_vars_info (fn);\n-  if (g) \n+  if (g)\n     return g->statics_not_read;\n   else\n     return NULL;\n@@ -270,11 +270,11 @@ ipa_reference_get_not_read_global (struct cgraph_node *fn)\n    that variables written may or may not be read during the function\n    call.  Returns NULL if no data is available.  */\n \n-bitmap \n-ipa_reference_get_not_written_global (struct cgraph_node *fn) \n+bitmap\n+ipa_reference_get_not_written_global (struct cgraph_node *fn)\n {\n   ipa_reference_global_vars_info_t g = get_global_reference_vars_info (fn);\n-  if (g) \n+  if (g)\n     return g->statics_not_written;\n   else\n     return NULL;\n@@ -285,8 +285,8 @@ ipa_reference_get_not_written_global (struct cgraph_node *fn)\n /* Add VAR to all_module_statics and the two\n    reference_vars_to_consider* sets.  */\n \n-static inline void \n-add_static_var (tree var) \n+static inline void\n+add_static_var (tree var)\n {\n   int uid = DECL_UID (var);\n   gcc_assert (TREE_CODE (var) == VAR_DECL);\n@@ -301,7 +301,7 @@ add_static_var (tree var)\n /* Return true if the variable T is the right kind of static variable to\n    perform compilation unit scope escape analysis.  */\n \n-static inline bool \n+static inline bool\n has_proper_scope_for_analysis (tree t)\n {\n   /* If the variable has the \"used\" attribute, treat it as if it had a\n@@ -311,7 +311,7 @@ has_proper_scope_for_analysis (tree t)\n \n   /* Do not want to do anything with volatile except mark any\n      function that uses one to be not const or pure.  */\n-  if (TREE_THIS_VOLATILE (t)) \n+  if (TREE_THIS_VOLATILE (t))\n     return false;\n \n   /* Do not care about a local automatic that is not static.  */\n@@ -395,16 +395,16 @@ check_asm_memory_clobber (ipa_reference_local_vars_info_t local, gimple stmt)\n {\n   size_t i;\n   tree op;\n-  \n+\n   for (i = 0; i < gimple_asm_nclobbers (stmt); i++)\n     {\n       op = gimple_asm_clobber_op (stmt, i);\n-      if (simple_cst_equal(TREE_VALUE (op), memory_identifier_string) == 1) \n+      if (simple_cst_equal(TREE_VALUE (op), memory_identifier_string) == 1)\n \t{\n \t  /* Abandon all hope, ye who enter here. */\n \t  local->calls_read_all = true;\n \t  local->calls_write_all = true;\n-\t}      \n+\t}\n     }\n }\n \n@@ -420,11 +420,11 @@ check_call (ipa_reference_local_vars_info_t local, gimple stmt)\n      time.  */\n   if (!callee_t)\n     {\n-      if (flags & ECF_CONST) \n+      if (flags & ECF_CONST)\n \t;\n       else if (flags & ECF_PURE)\n \tlocal->calls_read_all = true;\n-      else \n+      else\n \t{\n \t  local->calls_read_all = true;\n \t  /* When function does not reutrn, it is safe to ignore anythign it writes\n@@ -461,11 +461,11 @@ scan_stmt_for_static_refs (gimple_stmt_iterator *gsip,\n     check_call (local, stmt);\n   else if (gimple_code (stmt) == GIMPLE_ASM)\n     check_asm_memory_clobber (local, stmt);\n-  \n+\n   return NULL;\n }\n \n-/* Call-back to scan variable initializers for static references.  \n+/* Call-back to scan variable initializers for static references.\n    Called using walk_tree.  */\n \n static tree\n@@ -483,15 +483,15 @@ scan_initializer_for_static_refs (tree *tp, int *walk_subtrees,\n      won't find anything useful there anyway.  */\n   else if (IS_TYPE_OR_DECL_P (*tp))\n     *walk_subtrees = 0;\n- \n+\n   return NULL;\n }\n \n /* Lookup the tree node for the static variable that has UID.  */\n static tree\n get_static_decl (int index)\n {\n-  splay_tree_node stn = \n+  splay_tree_node stn =\n     splay_tree_lookup (reference_vars_to_consider, index);\n   if (stn)\n     return (tree)stn->value;\n@@ -504,7 +504,7 @@ get_static_decl (int index)\n static const char *\n get_static_name (int index)\n {\n-  splay_tree_node stn = \n+  splay_tree_node stn =\n     splay_tree_lookup (reference_vars_to_consider, index);\n   if (stn)\n     return lang_hooks.decl_printable_name ((tree)(stn->value), 2);\n@@ -519,7 +519,7 @@ static void\n propagate_bits (ipa_reference_global_vars_info_t x_global, struct cgraph_node *x)\n {\n   struct cgraph_edge *e;\n-  for (e = x->callees; e; e = e->next_callee) \n+  for (e = x->callees; e; e = e->next_callee)\n     {\n       struct cgraph_node *y = e->callee;\n \n@@ -528,60 +528,60 @@ propagate_bits (ipa_reference_global_vars_info_t x_global, struct cgraph_node *x\n \t{\n \t  if (get_reference_vars_info (y))\n \t    {\n-\t      ipa_reference_vars_info_t y_info \n+\t      ipa_reference_vars_info_t y_info\n \t\t= get_reference_vars_info (y);\n \t      ipa_reference_global_vars_info_t y_global = y_info->global;\n \n \t      /* Calls in current cycle do not have global computed yet.  */\n \t      if (!y_info->global)\n \t\tcontinue;\n-\t      \n+\n \t      if (x_global->statics_read\n \t\t  != all_module_statics)\n \t\t{\n-\t\t  if (y_global->statics_read \n+\t\t  if (y_global->statics_read\n \t\t      == all_module_statics)\n \t\t    {\n \t\t      BITMAP_FREE (x_global->statics_read);\n-\t\t      x_global->statics_read \n+\t\t      x_global->statics_read\n \t\t\t= all_module_statics;\n \t\t    }\n \t\t  /* Skip bitmaps that are pointer equal to node's bitmap\n \t\t     (no reason to spin within the cycle).  */\n-\t\t  else if (x_global->statics_read \n+\t\t  else if (x_global->statics_read\n \t\t\t   != y_global->statics_read)\n \t\t    bitmap_ior_into (x_global->statics_read,\n \t\t\t\t     y_global->statics_read);\n \t\t}\n-\t      \n-\t      if (x_global->statics_written \n+\n+\t      if (x_global->statics_written\n \t\t  != all_module_statics)\n \t\t{\n-\t\t  if (y_global->statics_written \n+\t\t  if (y_global->statics_written\n \t\t      == all_module_statics)\n \t\t    {\n \t\t      BITMAP_FREE (x_global->statics_written);\n-\t\t      x_global->statics_written \n+\t\t      x_global->statics_written\n \t\t\t= all_module_statics;\n \t\t    }\n \t\t  /* Skip bitmaps that are pointer equal to node's bitmap\n \t\t     (no reason to spin within the cycle).  */\n-\t\t  else if (x_global->statics_written \n+\t\t  else if (x_global->statics_written\n \t\t\t   != y_global->statics_written)\n \t\t    bitmap_ior_into (x_global->statics_written,\n \t\t\t\t     y_global->statics_written);\n \t\t}\n \t    }\n-\t  else \n+\t  else\n \t    gcc_unreachable ();\n \t}\n     }\n }\n \n /* The init routine for analyzing global static variable usage.  See\n    comments at top for description.  */\n-static void \n-ipa_init (void) \n+static void\n+ipa_init (void)\n {\n   static bool init_p = false;\n \n@@ -621,7 +621,7 @@ ipa_init (void)\n    compilation unit but their right hand sides may contain references\n    to variables defined within this unit.  */\n \n-static void \n+static void\n analyze_variable (struct varpool_node *vnode)\n {\n   struct walk_stmt_info wi;\n@@ -639,7 +639,7 @@ analyze_variable (struct varpool_node *vnode)\n static ipa_reference_local_vars_info_t\n init_function_info (struct cgraph_node *fn)\n {\n-  ipa_reference_vars_info_t info \n+  ipa_reference_vars_info_t info\n     = XCNEW (struct ipa_reference_vars_info_d);\n   ipa_reference_local_vars_info_t l\n     = XCNEW (struct ipa_reference_local_vars_info_d);\n@@ -674,7 +674,7 @@ analyze_function (struct cgraph_node *fn)\n \n   push_cfun (DECL_STRUCT_FUNCTION (decl));\n   current_function_decl = decl;\n-  \n+\n   init_function_info (fn);\n   FOR_EACH_BB_FN (this_block, this_cfun)\n     {\n@@ -724,7 +724,7 @@ analyze_function (struct cgraph_node *fn)\n        step = TREE_CHAIN (step))\n     {\n       tree var = TREE_VALUE (step);\n-      if (TREE_CODE (var) == VAR_DECL \n+      if (TREE_CODE (var) == VAR_DECL\n \t  && DECL_INITIAL (var)\n \t  && !TREE_STATIC (var))\n \tgcc_unreachable ();\n@@ -760,29 +760,29 @@ clean_function (struct cgraph_node *fn)\n {\n   ipa_reference_vars_info_t info = get_reference_vars_info (fn);\n   ipa_reference_global_vars_info_t g = info->global;\n-  \n+\n   clean_function_local_data (fn);\n   if (g)\n     {\n       if (g->statics_read\n \t  && g->statics_read != all_module_statics)\n \tBITMAP_FREE (g->statics_read);\n-      \n+\n       if (g->statics_written\n \t  && g->statics_written != all_module_statics)\n \tBITMAP_FREE (g->statics_written);\n-      \n+\n       if (g->statics_not_read\n \t  && g->statics_not_read != all_module_statics)\n \tBITMAP_FREE (g->statics_not_read);\n-      \n+\n       if (g->statics_not_written\n \t  && g->statics_not_written != all_module_statics)\n \tBITMAP_FREE (g->statics_not_written);\n       free (g);\n       info->global = NULL;\n     }\n-  \n+\n   free (get_reference_vars_info (fn));\n   set_reference_vars_info (fn, NULL);\n }\n@@ -872,7 +872,7 @@ remove_node_data (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n /* Analyze each function in the cgraph to see which global or statics\n    are read or written.  */\n \n-static void \n+static void\n generate_summary (void)\n {\n   struct cgraph_node *node;\n@@ -881,7 +881,7 @@ generate_summary (void)\n   bitmap_iterator bi;\n   bitmap module_statics_readonly;\n   bitmap bm_temp;\n-  \n+\n   ipa_init ();\n   module_statics_readonly = BITMAP_ALLOC (&local_info_obstack);\n   bm_temp = BITMAP_ALLOC (&local_info_obstack);\n@@ -890,7 +890,7 @@ generate_summary (void)\n   FOR_EACH_STATIC_INITIALIZER (vnode)\n     analyze_variable (vnode);\n \n-  /* Process all of the functions next. \n+  /* Process all of the functions next.\n \n      We do not want to process any of the clones so we check that this\n      is a master clone.  However, we do need to process any\n@@ -899,7 +899,7 @@ generate_summary (void)\n      overwrite such a function cannot access the statics because it\n      would not be in the same compilation unit.  When the analysis is\n      finished, the computed information of these AVAIL_OVERWRITABLE is\n-     replaced with worst case info.  \n+     replaced with worst case info.\n   */\n   for (node = cgraph_nodes; node; node = node->next)\n     if (cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n@@ -914,90 +914,90 @@ generate_summary (void)\n     {\n       splay_tree_remove (reference_vars_to_consider, index);\n     }\n-  \n-  bitmap_and_compl_into (all_module_statics, \n+\n+  bitmap_and_compl_into (all_module_statics,\n \t\t\t module_statics_escape);\n-  \n+\n   bitmap_and_compl (module_statics_readonly, all_module_statics,\n \t\t    module_statics_written);\n-  \n+\n   /* If the address is not taken, we can unset the addressable bit\n      on this variable.  */\n   EXECUTE_IF_SET_IN_BITMAP (all_module_statics, 0, index, bi)\n     {\n       tree var = get_static_decl (index);\n       TREE_ADDRESSABLE (var) = 0;\n-      if (dump_file) \n+      if (dump_file)\n \tfprintf (dump_file, \"Not TREE_ADDRESSABLE var %s\\n\",\n \t\t get_static_name (index));\n     }\n-  \n+\n   /* If the variable is never written, we can set the TREE_READONLY\n      flag.  Additionally if it has a DECL_INITIAL that is made up of\n      constants we can treat the entire global as a constant.  */\n-  \n+\n   bitmap_and_compl (module_statics_readonly, all_module_statics,\n \t\t    module_statics_written);\n   EXECUTE_IF_SET_IN_BITMAP (module_statics_readonly, 0, index, bi)\n     {\n       tree var = get_static_decl (index);\n-      \n+\n       /* Ignore variables in named sections - changing TREE_READONLY\n \t changes the section flags, potentially causing conflicts with\n \t other variables in the same named section.  */\n       if (DECL_SECTION_NAME (var) == NULL_TREE)\n \t{\n \t  TREE_READONLY (var) = 1;\n \t  if (dump_file)\n-\t    fprintf (dump_file, \"read-only var %s\\n\", \n+\t    fprintf (dump_file, \"read-only var %s\\n\",\n \t\t     get_static_name (index));\n \t}\n     }\n-  \n+\n   BITMAP_FREE(module_statics_escape);\n   BITMAP_FREE(module_statics_written);\n   module_statics_escape = NULL;\n   module_statics_written = NULL;\n-  \n+\n   if (dump_file)\n     EXECUTE_IF_SET_IN_BITMAP (all_module_statics, 0, index, bi)\n       {\n \tfprintf (dump_file, \"\\nPromotable global:%s\",\n \t\t get_static_name (index));\n       }\n-  \n+\n   for (node = cgraph_nodes; node; node = node->next)\n     if (cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n       {\n \tipa_reference_local_vars_info_t l;\n \tl = get_reference_vars_info (node)->local;\n-\t\n+\n \t/* Any variables that are not in all_module_statics are\n \t   removed from the local maps.  This will include all of the\n \t   variables that were found to escape in the function\n \t   scanning.  */\n \tif (l->statics_read)\n-\t  bitmap_and_into (l->statics_read, \n+\t  bitmap_and_into (l->statics_read,\n \t\t\t   all_module_statics);\n \tif (l->statics_written)\n-\t  bitmap_and_into (l->statics_written, \n+\t  bitmap_and_into (l->statics_written,\n \t\t\t   all_module_statics);\n       }\n-  \n+\n   BITMAP_FREE(module_statics_readonly);\n   BITMAP_FREE(bm_temp);\n-  \n+\n   if (dump_file)\n     for (node = cgraph_nodes; node; node = node->next)\n       if (cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n \t{\n \t  ipa_reference_local_vars_info_t l;\n \t  unsigned int index;\n \t  bitmap_iterator bi;\n-\t  \n+\n \t  l = get_reference_vars_info (node)->local;\n-\t  fprintf (dump_file, \n-\t\t   \"\\nFunction name:%s/%i:\", \n+\t  fprintf (dump_file,\n+\t\t   \"\\nFunction name:%s/%i:\",\n \t\t   cgraph_node_name (node), node->uid);\n \t  fprintf (dump_file, \"\\n  locals read: \");\n \t  if (l->statics_read)\n@@ -1029,14 +1029,14 @@ static bool\n write_node_summary_p (struct cgraph_node *node)\n {\n   gcc_assert (node->global.inlined_to == NULL);\n-  return (node->analyzed \n+  return (node->analyzed\n \t  && cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE\n \t  && get_reference_vars_info (node) != NULL);\n }\n \n /* Serialize the ipa info for lto.  */\n \n-static void \n+static void\n ipa_reference_write_summary (cgraph_node_set set)\n {\n   struct cgraph_node *node;\n@@ -1048,9 +1048,9 @@ ipa_reference_write_summary (cgraph_node_set set)\n   for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n     if (write_node_summary_p (csi_node (csi)))\n \tcount++;\n-  \n+\n   lto_output_uleb128_stream (ob->main_stream, count);\n-  \n+\n   /* Process all of the functions.  */\n   for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n     {\n@@ -1099,10 +1099,10 @@ ipa_reference_write_summary (cgraph_node_set set)\n \n /* Deserialize the ipa info for lto.  */\n \n-static void \n+static void\n ipa_reference_read_summary (void)\n {\n-  struct lto_file_decl_data ** file_data_vec \n+  struct lto_file_decl_data ** file_data_vec\n     = lto_get_file_decl_data ();\n   struct lto_file_decl_data * file_data;\n   unsigned int j = 0;\n@@ -1114,11 +1114,11 @@ ipa_reference_read_summary (void)\n       const char *data;\n       size_t len;\n       struct lto_input_block *ib\n-\t= lto_create_simple_input_block (file_data, \n-\t\t\t\t\t LTO_section_ipa_reference, \n+\t= lto_create_simple_input_block (file_data,\n+\t\t\t\t\t LTO_section_ipa_reference,\n \t\t\t\t\t &data, &len);\n       if (ib)\n-\t{ \n+\t{\n \t  unsigned int i;\n \t  unsigned int f_count = lto_input_uleb128 (ib);\n \n@@ -1147,7 +1147,7 @@ ipa_reference_read_summary (void)\n \t\t\t\t\t\t\t\t   var_index);\n \t\t    add_static_var (v_decl);\n \t\t    bitmap_set_bit (l->statics_read, DECL_UID (v_decl));\n-\t\t  } \n+\t\t  }\n \n \t      /* Set the statics written.  */\n \t      v_count = lto_input_sleb128 (ib);\n@@ -1161,11 +1161,11 @@ ipa_reference_read_summary (void)\n \t\t\t\t\t\t\t\t   var_index);\n \t\t    add_static_var (v_decl);\n \t\t    bitmap_set_bit (l->statics_written, DECL_UID (v_decl));\n-\t\t  } \n+\t\t  }\n \t    }\n \n-\t  lto_destroy_simple_input_block (file_data, \n-\t\t\t\t\t  LTO_section_ipa_reference, \n+\t  lto_destroy_simple_input_block (file_data,\n+\t\t\t\t\t  LTO_section_ipa_reference,\n \t\t\t\t\t  ib, data, len);\n \t}\n     }\n@@ -1212,7 +1212,7 @@ propagate (void)\n   int i;\n \n   cgraph_remove_function_insertion_hook (function_insertion_hook_holder);\n-  if (dump_file) \n+  if (dump_file)\n     dump_cgraph (dump_file);\n \n   /* Propagate the local information thru the call graph to produce\n@@ -1226,18 +1226,18 @@ propagate (void)\n   for (i = 0; i < order_pos; i++ )\n     {\n       ipa_reference_vars_info_t node_info;\n-      ipa_reference_global_vars_info_t node_g = \n+      ipa_reference_global_vars_info_t node_g =\n \tXCNEW (struct ipa_reference_global_vars_info_d);\n       ipa_reference_local_vars_info_t node_l;\n       struct cgraph_edge *e;\n-      \n+\n       bool read_all;\n       bool write_all;\n       struct ipa_dfs_info * w_info;\n \n       node = order[i];\n       node_info = get_reference_vars_info (node);\n-      if (!node_info) \n+      if (!node_info)\n \t{\n \t  dump_cgraph_node (stderr, node);\n \t  dump_cgraph (stderr);\n@@ -1254,7 +1254,7 @@ propagate (void)\n       if (cgraph_function_body_availability (node) <= AVAIL_OVERWRITABLE)\n         read_write_all_from_decl (node->decl, &read_all, &write_all);\n \n-      for (e = node->callees; e; e = e->next_callee) \n+      for (e = node->callees; e; e = e->next_callee)\n         if (cgraph_function_body_availability (e->callee) <= AVAIL_OVERWRITABLE)\n           read_write_all_from_decl (e->callee->decl, &read_all, &write_all);\n \n@@ -1265,14 +1265,14 @@ propagate (void)\n       w = w_info->next_cycle;\n       while (w)\n \t{\n-\t  ipa_reference_local_vars_info_t w_l = \n+\t  ipa_reference_local_vars_info_t w_l =\n \t    get_reference_vars_info (w)->local;\n \n \t  /* When function is overwrittable, we can not assume anything.  */\n \t  if (cgraph_function_body_availability (w) <= AVAIL_OVERWRITABLE)\n \t    read_write_all_from_decl (w->decl, &read_all, &write_all);\n \n-\t  for (e = w->callees; e; e = e->next_callee) \n+\t  for (e = w->callees; e; e = e->next_callee)\n \t    if (cgraph_function_body_availability (e->callee) <= AVAIL_OVERWRITABLE)\n \t      read_write_all_from_decl (e->callee->decl, &read_all, &write_all);\n \n@@ -1285,20 +1285,20 @@ propagate (void)\n \n \n       /* Initialized the bitmaps for the reduced nodes */\n-      if (read_all) \n+      if (read_all)\n \tnode_g->statics_read = all_module_statics;\n-      else \n+      else\n \t{\n \t  node_g->statics_read = BITMAP_ALLOC (&global_info_obstack);\n-\t  bitmap_copy (node_g->statics_read, \n+\t  bitmap_copy (node_g->statics_read,\n \t\t       node_l->statics_read);\n \t}\n-      if (write_all) \n+      if (write_all)\n \tnode_g->statics_written = all_module_statics;\n       else\n \t{\n \t  node_g->statics_written = BITMAP_ALLOC (&global_info_obstack);\n-\t  bitmap_copy (node_g->statics_written, \n+\t  bitmap_copy (node_g->statics_written,\n \t\t       node_l->statics_written);\n \t}\n \n@@ -1307,10 +1307,10 @@ propagate (void)\n       w = w_info->next_cycle;\n       while (w)\n \t{\n-\t  ipa_reference_vars_info_t w_ri = \n+\t  ipa_reference_vars_info_t w_ri =\n \t    get_reference_vars_info (w);\n \t  ipa_reference_local_vars_info_t w_l = w_ri->local;\n-\t  \n+\n \t  /* These global bitmaps are initialized from the local info\n \t     of all of the nodes in the region.  However there is no\n \t     need to do any work if the bitmaps were set to\n@@ -1332,7 +1332,7 @@ propagate (void)\n       w = w_info->next_cycle;\n       while (w)\n \t{\n-\t  ipa_reference_vars_info_t w_ri = \n+\t  ipa_reference_vars_info_t w_ri =\n \t    get_reference_vars_info (w);\n \n \t  gcc_assert (!w_ri->global);\n@@ -1360,8 +1360,8 @@ propagate (void)\n \t  node_info = get_reference_vars_info (node);\n \t  node_g = node_info->global;\n \t  node_l = node_info->local;\n-\t  fprintf (dump_file, \n-\t\t   \"\\nFunction name:%s/%i:\", \n+\t  fprintf (dump_file,\n+\t\t   \"\\nFunction name:%s/%i:\",\n \t\t   cgraph_node_name (node), node->uid);\n \t  fprintf (dump_file, \"\\n  locals read: \");\n \t  if (node_l->statics_read)\n@@ -1382,9 +1382,9 @@ propagate (void)\n \n \t  w_info = (struct ipa_dfs_info *) node->aux;\n \t  w = w_info->next_cycle;\n-\t  while (w) \n+\t  while (w)\n \t    {\n-\t      ipa_reference_vars_info_t w_ri = \n+\t      ipa_reference_vars_info_t w_ri =\n \t\tget_reference_vars_info (w);\n \t      ipa_reference_local_vars_info_t w_l = w_ri->local;\n \t      fprintf (dump_file, \"\\n  next cycle: %s/%i \",\n@@ -1404,7 +1404,7 @@ propagate (void)\n \t\t  fprintf(dump_file, \"%s \",\n \t\t\t  get_static_name (index));\n \t\t}\n-\t      \n+\n \n \t      w_info = (struct ipa_dfs_info *) w->aux;\n \t      w = w_info->next_cycle;\n@@ -1440,20 +1440,20 @@ propagate (void)\n       node = order[i];\n       node_info = get_reference_vars_info (node);\n       node_g = node_info->global;\n-      \n+\n       /* Create the complimentary sets.  These are more useful for\n \t certain apis.  */\n       node_g->statics_not_read = BITMAP_ALLOC (&global_info_obstack);\n       node_g->statics_not_written = BITMAP_ALLOC (&global_info_obstack);\n \n-      if (node_g->statics_read != all_module_statics) \n-\tbitmap_and_compl (node_g->statics_not_read, \n+      if (node_g->statics_read != all_module_statics)\n+\tbitmap_and_compl (node_g->statics_not_read,\n \t\t\t  all_module_statics,\n \t\t\t  node_g->statics_read);\n \n-      if (node_g->statics_written \n-\t  != all_module_statics) \n-\tbitmap_and_compl (node_g->statics_not_written, \n+      if (node_g->statics_written\n+\t  != all_module_statics)\n+\tbitmap_and_compl (node_g->statics_not_written,\n \t\t\t  all_module_statics,\n \t\t\t  node_g->statics_written);\n    }\n@@ -1465,13 +1465,13 @@ propagate (void)\n       ipa_reference_vars_info_t node_info;\n       node_info = get_reference_vars_info (node);\n       /* Get rid of the aux information.  */\n-      \n+\n       if (node->aux)\n \t{\n \t  free (node->aux);\n \t  node->aux = NULL;\n \t}\n-      \n+\n       if (cgraph_function_body_availability (node) == AVAIL_OVERWRITABLE)\n \tclean_function (node);\n       else if (node_info)"}, {"sha": "43ed0a53c947a04f4540a88b2be6ccf8caea2c4b", "filename": "gcc/ipa-struct-reorg.c", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fipa-struct-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fipa-struct-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-struct-reorg.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "e6df1cf9052ab314d163dc72739beeadb78db63f", "filename": "gcc/ipa-struct-reorg.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fipa-struct-reorg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fipa-struct-reorg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-struct-reorg.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "0c8d229f3cff738fda745f2398967b59e069f20e", "filename": "gcc/ipa-type-escape.c", "status": "modified", "additions": 216, "deletions": 216, "changes": 432, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fipa-type-escape.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fipa-type-escape.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-type-escape.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "0cb9a248bc3f3dde40ade82e2c8a2dffe17b18d6", "filename": "gcc/ipa-type-escape.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fipa-type-escape.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fipa-type-escape.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-type-escape.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "4b88f599d53d97ca0a65f6e539c3aac0d465989e", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "fa18a4f0b98ebc7da1932cf2df53cb7c963beaa8", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "1b68a7a409278aa95191abfe24f08d26dd1425bc", "filename": "gcc/ipa.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "16909a9a42a739a2a3e1a3eb76b8bf95488f231a", "filename": "gcc/ira-build.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "87237b5c90a12befb196c99a211023218409ead4", "filename": "gcc/ira-color.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "251b527661f2ee783eeea3a06081ee0fca9e62ef", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "9e11219ce0104686d6bd9608be56c14118a18a0f", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "9d66bfe48ff8bcf9bc90d914cb52f3a8f6451d7f", "filename": "gcc/ira-emit.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fira-emit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fira-emit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-emit.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "a32c837ac0f76a82873b5593739c5d4ed1778540", "filename": "gcc/ira-int.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "4302598233ac90b6c8b73fb4f2f167206c2791df", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "7165caa1b182cbdb2f05eeeba81a988e858e6910", "filename": "gcc/ira.c", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "c95c2116ba6e6aca9cb418eed213bf12090bc3dc", "filename": "gcc/jump.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "e5fe6299f28fb4776d027de0237b99ef5ad22c11", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 100, "deletions": 100, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "fb9098b20e167a4c0849342c80ec6ba831a4c927", "filename": "gcc/lambda-mat.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flambda-mat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flambda-mat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-mat.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "d34a63e2e867bd84baac365644a2c88d963f66e1", "filename": "gcc/lambda-trans.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flambda-trans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flambda-trans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-trans.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "189c1fc50b3a7f00a51cf1d5377961fbf9c239f8", "filename": "gcc/lambda.h", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flambda.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flambda.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "8505ec40b98f555723a5cf9e93f83740a37195b6", "filename": "gcc/langhooks.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "2c0bc8445dbf45cfdda227c5177fc1f1deab7219", "filename": "gcc/lcm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "4076409e11ce66d0cd8ed6047f94c5c930e5d456", "filename": "gcc/libgcov.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flibgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flibgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcov.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "5517e5f6a6200995be2f5f77c613f7d87df3391b", "filename": "gcc/lists.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flists.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flists.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flists.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "0fa0fe21e51d153a820f30d16ec632306220ec90", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "da01f04879eb2a02b61b1ec3fe5f646bf88046d7", "filename": "gcc/loop-init.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "03f0a13baa0685bade9fdab51913158c80a6ba97", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "16e9a52697dafbd76784ff9fa706edefc8ac01f9", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "6b7fe8ad09116b997616a4472cfab1149a9a76ad", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 120, "deletions": 120, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "590e8e8e01b17776abc9bc44d878313415561aa4", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "0f77df1a14595d80c486c313cbc3fb0e1416f8dc", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "e29ded397fe08ed561cef64e28102c8d894d9e9d", "filename": "gcc/lto-compress.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flto-compress.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flto-compress.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-compress.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "f96dfab522d1dd917576c9739498e9eff97a9062", "filename": "gcc/lto-opts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flto-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flto-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-opts.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "9277b12005fb501064531fa80646b7c0db86b63d", "filename": "gcc/lto-section-in.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flto-section-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flto-section-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-in.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "895394f3a1b9c7545c162d32aa48d92286903743", "filename": "gcc/lto-section-out.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flto-section-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flto-section-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-out.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "9559869b5ba7cbbbc67b7f0ad5b1f4ccfe610bc4", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "7389081182b37fabddfcb1fd88126efcb6355725", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "01664f7bce5cbdbcb74d5e64b3b41486b36a3368", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "703d6fabbff35864d954a34567f6df59d85c2ed4", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "ab96b48cd36df28d4c7d8ed088600ffb17a72a63", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "0839aa9df9a954d50f973214793a0b2234e4f8de", "filename": "gcc/lto-wpa-fixup.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flto-wpa-fixup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Flto-wpa-fixup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-wpa-fixup.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "71c7419a8f54fa224672ad6160d53fa2553b2a7b", "filename": "gcc/matrix-reorg.c", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fmatrix-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fmatrix-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatrix-reorg.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "af993fba05778b77e11a0fd86714086c2e63d377", "filename": "gcc/mcf.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fmcf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fmcf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmcf.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "140c513918e0b55dfcdcb6529f232c60d288aa2f", "filename": "gcc/mode-switching.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fmode-switching.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fmode-switching.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-switching.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "cc9f788a8a7b94227369550ee2108c3d47736b5b", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "ff7da4e16098224a597db936c0d8447dc5d0def5", "filename": "gcc/omega.c", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fomega.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fomega.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomega.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "e75466ec097d19af19a702542a9a0f181c1cf3cd", "filename": "gcc/omega.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fomega.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fomega.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomega.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "ba4d76495c3c0154bdb64c99a7bdb69a94285549", "filename": "gcc/omp-low.c", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "9e659dc3869de8cbe72dac269ae79feaa811e138", "filename": "gcc/optabs.c", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "0161d3e6d3bca84a963f17ae2029a487050a87e3", "filename": "gcc/optabs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "b70b823db16eb247b7f68704d81dc5ebb81f7b06", "filename": "gcc/opts-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fopts-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fopts-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts-common.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "3a825ce364d36da6633e3fb3faea7d92cf39ec36", "filename": "gcc/opts.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "7e09701dda3f2d9ca9ac8109b35d09945445804b", "filename": "gcc/params.def", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "e0bb4fa7e9bd151711a3204456bc41ba035181e5", "filename": "gcc/params.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "57b55c08fc997cf97e6fb429571564e8a3484197", "filename": "gcc/passes.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "c43e0c844a136ba2bfa6b3034acc7d9ab2091c38", "filename": "gcc/plugin.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fplugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fplugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fplugin.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "d7c8878c49630f33275da435f720da2ca9cd560d", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "eaedee13a74c92a1e4064e5059cd170fc5edd520", "filename": "gcc/postreload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "eb5ddef2e3871b0c71bdbbb46ed299d478294a53", "filename": "gcc/predict.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "4b3e87aa568cbf5b48a3426d6d32ba93d28a92ad", "filename": "gcc/predict.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fpredict.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fpredict.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.def?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "56789490931c68e8cbf8d9cb20288b36dbdd7752", "filename": "gcc/pretty-print.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fpretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fpretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "3ba503538508c54dd8e6da00de033a6d7213f2c4", "filename": "gcc/pretty-print.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fpretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fpretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "be380b11edb07bb647be48be89c15243b076bd71", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "a44d23a847404e81e542a71ed0cd1ed943a21046", "filename": "gcc/print-tree.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "104956188bc674927b34515fd7d6c5e1d06d7c18", "filename": "gcc/profile.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "9f922ae8cd99a56f0d94b37a22b05aa61b3a0b20", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "25e599dfe352e4f2d57a0721c87f6d9702c9cc63", "filename": "gcc/real.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "5a6490edf974104726455357432e552e61cd1130", "filename": "gcc/recog.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "a17f4f80e0d8565f6ec7962d925386b792673652", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "199ff295d02d436ec744c2529519d5b3d5bb942f", "filename": "gcc/regcprop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "ee6c7ee6447a162154d4bf0edab7b8cd4ed71df9", "filename": "gcc/reginfo.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "18afc5b6dcda6e9c4b8d71e3afe98bde7896297c", "filename": "gcc/regmove.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "2b22aa68a9eae76f4d190cc0bf56f99cdb1f0958", "filename": "gcc/regrename.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "39c4fa32c681a0ec2612cbe73d92bbc5e1aeb759", "filename": "gcc/regs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "cb4471b235bc5917b419fabdf1a6ebdacf4c8e6d", "filename": "gcc/regstat.c", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fregstat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fregstat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregstat.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "97c6bacf25bc59fc552c441a1c411b7196a5af4f", "filename": "gcc/reload.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "2555dc8b33cd6e182d79fd2cc4a821d362f94f8c", "filename": "gcc/reload1.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "9dc44b9ac298f6497479a57f6d749fe193f8a30c", "filename": "gcc/resource.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "fe9c9514f1cd40624b9af8ab00ad8ebbc861b4bb", "filename": "gcc/rtl.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "54f2a6028dd089b7dd08fc5b22edee514853fcf5", "filename": "gcc/rtl.def", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "960237cec5302040360d151aa2ef86966e55fb77", "filename": "gcc/rtl.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "0e3b77bc0c9f1fbf7df79ddc86ffcb9d139ceabb", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "f429f70eccf6dc57e8c81cbee604140b32e0ddc8", "filename": "gcc/sbitmap.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "21632c3b5ed9ac1d0818c90e9474a3bac24175ff", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "f4875601f160f5352f309a97c13504667da821a0", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "0d3a855690ed97112e9279cb1846cb9646563abf", "filename": "gcc/sched-int.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "68da37bbd7e8e2ce627207819687add72956f756", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "5754a56a5fa744860557b33f167d9d4cfb20d3ff", "filename": "gcc/sched-vis.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsched-vis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsched-vis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-vis.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "f4541ea0763b8b45985e05cf1fba07fc1f320d41", "filename": "gcc/sdbout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "dbf1c34fccc1751cb9be47132696410aab76d839", "filename": "gcc/sel-sched-dump.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsel-sched-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsel-sched-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-dump.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "d4ebd779a7a6e9178181e87eb04cfae30d7b3a38", "filename": "gcc/sel-sched-dump.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsel-sched-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsel-sched-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-dump.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "3484d861c4baa729c10fbd69700cf842095933c4", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 366, "deletions": 366, "changes": 732, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "1950a65e77f67a157b921cb145b8d1af1c895e69", "filename": "gcc/sel-sched-ir.h", "status": "modified", "additions": 59, "deletions": 59, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsel-sched-ir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsel-sched-ir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "e5ebc57387b19a755e936a223b0b5e93575bebe8", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 688, "deletions": 688, "changes": 1376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "d2dce32432ef73a5a68b5f3d9235702f18b80bbd", "filename": "gcc/sel-sched.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsel-sched.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsel-sched.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "338f482eec173c6270acfb386d39df6337d041c6", "filename": "gcc/sese.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "c126a6964f8f09b640f087ce47b7510927eb167a", "filename": "gcc/sese.h", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsese.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsese.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "5e384d4e8f4300caeee92cefa35a79e7234834f5", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "e7d92a5e7b9f9c6aa9fb6d266d6fa1c61deeb210", "filename": "gcc/stack-ptr-mod.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fstack-ptr-mod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fstack-ptr-mod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstack-ptr-mod.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "14f13812b36ec050b0329a79ab5459e531708eba", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "6f08d8cdf97787637c2902c91a59022e8845b51a", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "4878729eec02ec0ec05eae0b2e1d77b173f5414c", "filename": "gcc/store-motion.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fstore-motion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fstore-motion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstore-motion.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "79f8cb2c8d1a748e76b852e5f8031dec4ba63bc8", "filename": "gcc/stringpool.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fstringpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fstringpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstringpool.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "b7748f79c6e56e1719dace8611765c951642b477", "filename": "gcc/stub-objc.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fstub-objc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fstub-objc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstub-objc.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "b51d5dfbdaf3a000d0d74f11b997d258d833d8bb", "filename": "gcc/sync-builtins.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsync-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Fsync-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsync-builtins.def?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "c57977b127735da9939f99aea64c49990e22de5b", "filename": "gcc/target-def.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "477a512d703b7c8197d5516252f0ae246dc47908", "filename": "gcc/target.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "d619ae53c3e6ddb33c298b95f83fb11ecd07a769", "filename": "gcc/targhooks.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "631bdf216dff2d02ca4e9682ed95bef5ace3321c", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "4ba2864a2352fe5611c458ae6ef2996555518ae9", "filename": "gcc/timevar.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftimevar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftimevar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "1894c6c709a3b8f7e68ef3b1059e2584b75f5cff", "filename": "gcc/tlink.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftlink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftlink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftlink.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "ccba7498c37083d9b5f0364af9b39738a6357436", "filename": "gcc/toplev.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "53f981c71416a7e19d9740f129982c784cc14d25", "filename": "gcc/toplev.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "918ed7845374b9978dd4b541bc9e72d2834849e7", "filename": "gcc/tracer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "1c3745ec7309c20bfc2ed00fcf078127a4d8bea7", "filename": "gcc/tree-affine.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-affine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-affine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "0abda96a9da018188793969a272f09993849fee4", "filename": "gcc/tree-affine.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-affine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-affine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "cd8145b684de95de449dd5c8020059d3f0457835", "filename": "gcc/tree-browser.def", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-browser.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-browser.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-browser.def?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "8b1ece89f56bac3e48b19fb0d9638aab4f68d6cf", "filename": "gcc/tree-call-cdce.c", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-call-cdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-call-cdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-call-cdce.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "3a0868981470566b1060a5309ce12a9de80992ec", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "495450bf12ce4d5a7b899e2c385b61488099e0c8", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "9711e20b5beb79819a83d016b4266e07aa547e29", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 176, "deletions": 176, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "fcff93a55da9b2edad91d3242815649c8f303c61", "filename": "gcc/tree-chrec.h", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-chrec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-chrec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "8f246fa080cf568b0f7d642d4b88381344c44dd2", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "1b0421c5ef08caed5f13b5f08074763ddcf65ea2", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 279, "deletions": 279, "changes": 558, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "e945ecb464d50523249f347c1ddb6122f9dd559a", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "69535f1dc60af8c2e1063116ae2582c8bf27413b", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "e0512bc80a34ef1dfddd9827ae20b12fba303f8d", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "eeb28e0aad6a071b680d13d6ef5b86f6a6d8cead", "filename": "gcc/tree-dump.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "21da53470a26204cb7ec39cd1c91f9a71e81be16", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "3446790fa7a0e715b839af9ee38ed0f37b28a68c", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "cde7792cb4a868d4ddfa34652a70dd4bd4e28057", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "7f193ec98b0625a73f9938756ebf28e68e57bf2a", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "2991c9e0b50a1ff740d4f6d235a7807780602b41", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "d6f659c0624726d52047111e6997147ed1eae51c", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "f9c96d3120e26d8149b7bb9048c95d3c1be08421", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "5461975d77ad428f6f8b93b6b229110705964b71", "filename": "gcc/tree-loop-linear.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-loop-linear.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-loop-linear.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-linear.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "590f7c358d9a57f43d80e0a21ef025acc0f98e6f", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "fb95088b64805e9f3ca4edf5a781ab3b31004448", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "9e9d624bb02629e3ccfeaab5e8100fedd7934c10", "filename": "gcc/tree-nomudflap.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-nomudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-nomudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nomudflap.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "defa8def89c7866d30998fc52b0c946d1f7929a7", "filename": "gcc/tree-nrv.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-nrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-nrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nrv.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "135342d58b07681d1d0b594435ab4fab7236c577", "filename": "gcc/tree-object-size.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "781cbeaf39a00585195d87c5c02503ec6afa6a58", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "a82cec824fdf201795c4f1eceff6a947a88125ea", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "56b88a89ad081e6f5b2d4a40b4724bddbcf15831", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 80, "deletions": 80, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "1bff0bd52cec83b3bc7d6a2f8ecb0cf84e2bcca6", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "6e63ed4f8f6121a2e17754df60d232815251803a", "filename": "gcc/tree-phinodes.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-phinodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-phinodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "78d45b88364cf906d583c58ba14d090a443b619a", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "caa19ac8d6cc39c3cfcb8dcd338823bdd2e9e4f3", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "3d681e03421cd64f9e6fd0e949db48ae971d36f9", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "087ba798830eebaea90946b53bf503ad1791c6ae", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 288, "deletions": 288, "changes": 576, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "5cd5d9d29c678d1359cf95e0d0bc41b1cb8c9c6d", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "6ba550bbff026f460bbfa299f1138c4c5593ffc0", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "f3f113c902f28a20a49ad62b127ddd72f05afb5d", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "867e15c06e06244a88006c20e36173d2a4088a73", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "4b8d0b9660b8aff56eb2db05a0ca1991ab79239b", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "d62a09416d14da5a44f3393c1112baaa8e74ac72", "filename": "gcc/tree-ssa-copyrename.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-ssa-copyrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-ssa-copyrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copyrename.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "8669cdfa852248ec7ff0b545bd1d524cb46aa22b", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}, {"sha": "dd9fd56678561df74f04eb6ee2aa6353289cf7e8", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8698a0f3794ca2fda9837dfdd83feea1a4ca75c/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=b8698a0f3794ca2fda9837dfdd83feea1a4ca75c"}]}