{"sha": "312def2eda47dd591c50f9bf9959fc3129e275e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzEyZGVmMmVkYTQ3ZGQ1OTFjNTBmOWJmOTk1OWZjMzEyOWUyNzVlMA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-08-08T21:31:39Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-08-08T21:31:39Z"}, "message": "(num_sign_bit_copies): Properly handle case when MODE is narrower than that of X.\n\n(num_sign_bit_copies): Properly handle case when MODE is narrower than that\nof X.\n(simplify_shift_const): Remove change of July 26.\n\nFrom-SVN: r5110", "tree": {"sha": "183cc19aba5df130a788a5bd88d0675d808837a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/183cc19aba5df130a788a5bd88d0675d808837a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/312def2eda47dd591c50f9bf9959fc3129e275e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/312def2eda47dd591c50f9bf9959fc3129e275e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/312def2eda47dd591c50f9bf9959fc3129e275e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/312def2eda47dd591c50f9bf9959fc3129e275e0/comments", "author": null, "committer": null, "parents": [{"sha": "00aae7b152f77c0aa1e0bd9ac2001635ca9c7c95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00aae7b152f77c0aa1e0bd9ac2001635ca9c7c95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00aae7b152f77c0aa1e0bd9ac2001635ca9c7c95"}], "stats": {"total": 43, "additions": 21, "deletions": 22}, "files": [{"sha": "ffc92f8c96810fbf4d4197c0584e962195b98946", "filename": "gcc/combine.c", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/312def2eda47dd591c50f9bf9959fc3129e275e0/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/312def2eda47dd591c50f9bf9959fc3129e275e0/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=312def2eda47dd591c50f9bf9959fc3129e275e0", "patch": "@@ -6687,6 +6687,11 @@ num_sign_bit_copies (x, mode)\n \n   bitwidth = GET_MODE_BITSIZE (mode);\n \n+  /* For a smaller object, just ignore the high bits. */\n+  if (bitwidth < GET_MODE_BITSIZE (GET_MODE (x)))\n+    return MAX (1, (num_sign_bit_copies (x, GET_MODE (x))\n+\t\t    - (GET_MODE_BITSIZE (GET_MODE (x)) - bitwidth)));\n+     \n   switch (code)\n     {\n     case REG:\n@@ -7181,31 +7186,25 @@ simplify_shift_const (x, code, result_mode, varop, count)\n       else if (count < 0)\n \tabort ();\n \n-      /* If we have replaced VAROP with something wider\n-\t (such as, the SUBREG_REG), then this won't work;\n-\t num_sign_bit_copies will give the wrong answer in that case.  */\n-      if (shift_mode == GET_MODE (varop))\n+      /* An arithmetic right shift of a quantity known to be -1 or 0\n+\t is a no-op.  */\n+      if (code == ASHIFTRT\n+\t  && (num_sign_bit_copies (varop, shift_mode)\n+\t      == GET_MODE_BITSIZE (shift_mode)))\n \t{\n-\t  /* An arithmetic right shift of a quantity known to be -1 or 0\n-\t     is a no-op.  */\n-\t  if (code == ASHIFTRT\n-\t      && (num_sign_bit_copies (varop, shift_mode)\n-\t\t  == GET_MODE_BITSIZE (shift_mode)))\n-\t    {\n-\t      count = 0;\n-\t      break;\n-\t    }\n+\t  count = 0;\n+\t  break;\n+\t}\n \n-\t  /* If we are doing an arithmetic right shift and discarding all but\n-\t     the sign bit copies, this is equivalent to doing a shift by the\n-\t     bitsize minus one.  Convert it into that shift because it will often\n-\t     allow other simplifications.  */\n+      /* If we are doing an arithmetic right shift and discarding all but\n+\t the sign bit copies, this is equivalent to doing a shift by the\n+\t bitsize minus one.  Convert it into that shift because it will often\n+\t allow other simplifications.  */\n \n-\t  if (code == ASHIFTRT\n-\t      && (count + num_sign_bit_copies (varop, shift_mode)\n-\t\t  >= GET_MODE_BITSIZE (shift_mode)))\n-\t    count = GET_MODE_BITSIZE (shift_mode) - 1;\n-\t}\n+      if (code == ASHIFTRT\n+\t  && (count + num_sign_bit_copies (varop, shift_mode)\n+\t      >= GET_MODE_BITSIZE (shift_mode)))\n+\tcount = GET_MODE_BITSIZE (shift_mode) - 1;\n \n       /* We simplify the tests below and elsewhere by converting\n \t ASHIFTRT to LSHIFTRT if we know the sign bit is clear."}]}