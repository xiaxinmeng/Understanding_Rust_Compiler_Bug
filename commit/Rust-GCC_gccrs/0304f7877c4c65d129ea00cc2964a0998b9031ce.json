{"sha": "0304f7877c4c65d129ea00cc2964a0998b9031ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDMwNGY3ODc3YzRjNjVkMTI5ZWEwMGNjMjk2NGEwOTk4YjkwMzFjZQ==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1998-10-27T23:19:31Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-10-27T23:19:31Z"}, "message": "final.c (cleanup_subreg_operands): New function.\n\n        * final.c (cleanup_subreg_operands): New function.\n        (final_scan_insn): Use it.\n        (alter_subreg): Clear the \"used\" field when we turn a SUBREG into\n        a REG.\n        * reload1.c (reload): Delete CLOBBER insns and also cleanup SUBREG\n        operands when reload has finished.\n        * reload.h (cleanup_subreg_operands): Declare..\n        * flow.c (life_analysis_1): No longer delete CLOBBER insns after\n        reload.  Handled in reload itself.\nShould fix sh, sparc and probably other problems with post-reload life pass\nand scheduling interactions.\n\nFrom-SVN: r23377", "tree": {"sha": "c70a7a8b1e67a64ee37c4cbef242efc253b9a280", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c70a7a8b1e67a64ee37c4cbef242efc253b9a280"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0304f7877c4c65d129ea00cc2964a0998b9031ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0304f7877c4c65d129ea00cc2964a0998b9031ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0304f7877c4c65d129ea00cc2964a0998b9031ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0304f7877c4c65d129ea00cc2964a0998b9031ce/comments", "author": null, "committer": null, "parents": [{"sha": "bd09c530b225d9d838c63842e605aafe12a817e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd09c530b225d9d838c63842e605aafe12a817e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd09c530b225d9d838c63842e605aafe12a817e3"}], "stats": {"total": 108, "additions": 70, "deletions": 38}, "files": [{"sha": "23af1029d6667a2d85602ba0d98b0754c801c1e7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0304f7877c4c65d129ea00cc2964a0998b9031ce/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0304f7877c4c65d129ea00cc2964a0998b9031ce/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0304f7877c4c65d129ea00cc2964a0998b9031ce", "patch": "@@ -1,3 +1,15 @@\n+Wed Oct 28 00:10:35 1998  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* final.c (cleanup_subreg_operands): New function.\n+\t(final_scan_insn): Use it.\n+\t(alter_subreg): Clear the \"used\" field when we turn a SUBREG into\n+\ta REG.\n+\t* reload1.c (reload): Delete CLOBBER insns and also cleanup SUBREG\n+\toperands when reload has finished.\n+\t* reload.h (cleanup_subreg_operands): Declare..\n+\t* flow.c (life_analysis_1): No longer delete CLOBBER insns after\n+\treload.  Handled in reload itself.\n+\n Tue Oct 27 23:32:34 1998  Bernd Schmidt <crux@pool.informatik.rwth-aachen.de>\n \n \t* reload.h (struct insn_chain): Add need_operand_change element."}, {"sha": "4c19c84a9fdd1ca00fd020234d46b6e131bae577", "filename": "gcc/final.c", "status": "modified", "additions": 47, "deletions": 17, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0304f7877c4c65d129ea00cc2964a0998b9031ce/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0304f7877c4c65d129ea00cc2964a0998b9031ce/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=0304f7877c4c65d129ea00cc2964a0998b9031ce", "patch": "@@ -2844,23 +2844,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \n \tinsn_code_number = recog_memoized (insn);\n \tinsn_extract (insn);\n-\tfor (i = 0; i < insn_n_operands[insn_code_number]; i++)\n-\t  {\n-\t    if (GET_CODE (recog_operand[i]) == SUBREG)\n-\t      recog_operand[i] = alter_subreg (recog_operand[i]);\n-\t    else if (GET_CODE (recog_operand[i]) == PLUS\n-\t\t     || GET_CODE (recog_operand[i]) == MULT)\n-\t      recog_operand[i] = walk_alter_subreg (recog_operand[i]);\n-\t  }\n-\n-\tfor (i = 0; i < insn_n_dups[insn_code_number]; i++)\n-\t  {\n-\t    if (GET_CODE (*recog_dup_loc[i]) == SUBREG)\n-\t      *recog_dup_loc[i] = alter_subreg (*recog_dup_loc[i]);\n-\t    else if (GET_CODE (*recog_dup_loc[i]) == PLUS\n-\t\t     || GET_CODE (*recog_dup_loc[i]) == MULT)\n-\t      *recog_dup_loc[i] = walk_alter_subreg (*recog_dup_loc[i]);\n-\t  }\n+\tcleanup_subreg_operands (insn);\n \n #ifdef REGISTER_CONSTRAINTS\n \tif (! constrain_operands (insn_code_number, 1))\n@@ -3039,6 +3023,49 @@ output_source_line (file, insn)\n     }\n }\n \f\n+\n+/* For each operand in INSN, simplify (subreg (reg)) so that it refers\n+   directly to the desired hard register.  */\n+void\n+cleanup_subreg_operands (insn)\n+     rtx insn;\n+{\n+  int insn_code_number, i;\n+\n+  /* Ignore things we can not handle.  */\n+  if (GET_RTX_CLASS (GET_CODE (insn)) != 'i'\n+      || GET_CODE (PATTERN (insn)) == USE\n+      || GET_CODE (PATTERN (insn)) == ADDR_VEC\n+      || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC\n+      || asm_noperands (PATTERN (insn)) >= 0)\n+    return;\n+\n+  /* Try to recognize the instruction.\n+     If successful, verify that the operands satisfy the\n+     constraints for the instruction.  Crash if they don't,\n+     since `reload' should have changed them so that they do.  */\n+\n+  insn_code_number = recog_memoized (insn);\n+  insn_extract (insn);\n+  for (i = 0; i < insn_n_operands[insn_code_number]; i++)\n+    {\n+      if (GET_CODE (recog_operand[i]) == SUBREG)\n+        recog_operand[i] = alter_subreg (recog_operand[i]);\n+      else if (GET_CODE (recog_operand[i]) == PLUS\n+               || GET_CODE (recog_operand[i]) == MULT)\n+       recog_operand[i] = walk_alter_subreg (recog_operand[i]);\n+    }\n+\n+  for (i = 0; i < insn_n_dups[insn_code_number]; i++)\n+    {\n+      if (GET_CODE (*recog_dup_loc[i]) == SUBREG)\n+        *recog_dup_loc[i] = alter_subreg (*recog_dup_loc[i]);\n+      else if (GET_CODE (*recog_dup_loc[i]) == PLUS\n+               || GET_CODE (*recog_dup_loc[i]) == MULT)\n+        *recog_dup_loc[i] = walk_alter_subreg (*recog_dup_loc[i]);\n+    }\n+}\n+\n /* If X is a SUBREG, replace it with a REG or a MEM,\n    based on the thing it is a subreg of.  */\n \n@@ -3072,6 +3099,9 @@ alter_subreg (x)\n #else\n       REGNO (x) = REGNO (y) + SUBREG_WORD (x);\n #endif\n+      /* This field has a different meaning for REGs and SUBREGs.  Make sure\n+\t to clear it!  */\n+      x->used = 0;\n     }\n   else if (GET_CODE (y) == MEM)\n     {"}, {"sha": "51af041506e1a2fb9a0911baca1468711dacd943", "filename": "gcc/flow.c", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0304f7877c4c65d129ea00cc2964a0998b9031ce/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0304f7877c4c65d129ea00cc2964a0998b9031ce/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=0304f7877c4c65d129ea00cc2964a0998b9031ce", "patch": "@@ -1358,23 +1358,6 @@ life_analysis_1 (f, nregs)\n   if (reload_completed)\n     bcopy (regs_ever_live, save_regs_ever_live, (sizeof (regs_ever_live)));\n \n-  /* Also remove all CLOBBER insns after reload.  They can cause us to think\n-     a value is dead when it really is not dead.  */\n-  if (reload_completed)\n-    {\n-      rtx insn;\n-\n-      for (insn = f; insn; insn = NEXT_INSN (insn))\n-\t{\n-\t  if (GET_CODE (insn) == INSN\n-\t      && GET_CODE (PATTERN (insn)) == CLOBBER)\n-\t    {\n-              PUT_CODE (insn, NOTE);\n-              NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-              NOTE_SOURCE_FILE (insn) = 0;\n-\t    }\n-\t}\n-    }\n   bzero (regs_ever_live, sizeof regs_ever_live);\n \n   /* Allocate and zero out many data structures"}, {"sha": "968d3124af49a54b6c2f008a33e39f49aabc8473", "filename": "gcc/reload.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0304f7877c4c65d129ea00cc2964a0998b9031ce/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0304f7877c4c65d129ea00cc2964a0998b9031ce/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=0304f7877c4c65d129ea00cc2964a0998b9031ce", "patch": "@@ -339,3 +339,6 @@ extern void setup_save_areas PROTO((void));\n \n /* Find the places where hard regs are live across calls and save them.  */\n extern void save_call_clobbered_regs PROTO((void));\n+\n+/* Replace (subreg (reg)) with the appropriate (reg) for any operands.  */\n+extern void cleanup_subreg_operands PROTO ((rtx));"}, {"sha": "7e702d30733295d681052743c1726f82a35aa91d", "filename": "gcc/reload1.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0304f7877c4c65d129ea00cc2964a0998b9031ce/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0304f7877c4c65d129ea00cc2964a0998b9031ce/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=0304f7877c4c65d129ea00cc2964a0998b9031ce", "patch": "@@ -1037,16 +1037,17 @@ reload (first, global, dumpfile)\n     }\n \n   /* Make a pass over all the insns and delete all USEs which we inserted\n-     only to tag a REG_EQUAL note on them.  Also remove all REG_DEAD and\n-     REG_UNUSED notes.  */\n+     only to tag a REG_EQUAL note on them.  Remove all REG_DEAD and REG_UNUSED\n+     notes.  Delete all CLOBBER insns and simplify (subreg (reg)) operands.  */\n \n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n       {\n \trtx *pnote;\n \n-\tif (GET_CODE (PATTERN (insn)) == USE\n-\t    && find_reg_note (insn, REG_EQUAL, NULL_RTX))\n+\tif ((GET_CODE (PATTERN (insn)) == USE\n+\t     && find_reg_note (insn, REG_EQUAL, NULL_RTX))\n+\t    || GET_CODE (PATTERN (insn)) == CLOBBER)\n \t  {\n \t    PUT_CODE (insn, NOTE);\n \t    NOTE_SOURCE_FILE (insn) = 0;\n@@ -1063,6 +1064,9 @@ reload (first, global, dumpfile)\n \t    else\n \t      pnote = &XEXP (*pnote, 1);\n \t  }\n+\n+\t/* And simplify (subreg (reg)) if it appears as an operand.  */\n+\tcleanup_subreg_operands (insn);\n       }\n \n   /* If we are doing stack checking, give a warning if this function's"}]}