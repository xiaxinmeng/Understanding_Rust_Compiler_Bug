{"sha": "95bd1dd72f8e33c77da74e7e6707f206784f6b15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTViZDFkZDcyZjhlMzNjNzdkYTc0ZTdlNjcwN2YyMDY3ODRmNmIxNQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-01-18T02:26:43Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-01-18T02:26:43Z"}, "message": "alias.c: Fix comment typos.\n\n\t* alias.c: Fix comment typos.\n\t* basic-block.h: Likewise.\n\t* c-common.c: Likewise.\n\t* c-common.h: Likewise.\n\t* c-decl.c: Likewise.\n\t* c-opts.c: Likewise.\n\t* c-pragma.c: Likewise.\n\t* c-pretty-print.h: Likewise.\n\t* cfg.c: Likewise.\n\t* cfganal.c: Likewise.\n\t* cfgbuild.c: Likewise.\n\t* cfgcleanup.c: Likewise.\n\t* cfglayout.c: Likewise.\n\t* cfgrtl.c: Likewise.\n\t* convert.c: Likewise.\n\t* cpphash.h: Likewise.\n\t* cpplex.c: Likewise.\n\t* cpplib.h: Likewise.\n\t* df.h: Likewise.\n\t* diagnostic.c: Likewise.\n\t* diagnostic.h: Likewise.\n\t* dwarf2.h: Likewise.\n\nFrom-SVN: r61462", "tree": {"sha": "6a219732ec330734a0ab46ead554f3e3bd32ba25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a219732ec330734a0ab46ead554f3e3bd32ba25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95bd1dd72f8e33c77da74e7e6707f206784f6b15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95bd1dd72f8e33c77da74e7e6707f206784f6b15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95bd1dd72f8e33c77da74e7e6707f206784f6b15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95bd1dd72f8e33c77da74e7e6707f206784f6b15/comments", "author": null, "committer": null, "parents": [{"sha": "d5840e09def0a9a4efbcc31ae5bf30b9761335bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5840e09def0a9a4efbcc31ae5bf30b9761335bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5840e09def0a9a4efbcc31ae5bf30b9761335bd"}], "stats": {"total": 99, "additions": 62, "deletions": 37}, "files": [{"sha": "5e5e1ba3b23455ecdda310f2b41c0a866f2373d0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=95bd1dd72f8e33c77da74e7e6707f206784f6b15", "patch": "@@ -1,3 +1,28 @@\n+2003-01-17  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* alias.c: Fix comment typos.\n+\t* basic-block.h: Likewise.\n+\t* c-common.c: Likewise.\n+\t* c-common.h: Likewise.\n+\t* c-decl.c: Likewise.\n+\t* c-opts.c: Likewise.\n+\t* c-pragma.c: Likewise.\n+\t* c-pretty-print.h: Likewise.\n+\t* cfg.c: Likewise.\n+\t* cfganal.c: Likewise.\n+\t* cfgbuild.c: Likewise.\n+\t* cfgcleanup.c: Likewise.\n+\t* cfglayout.c: Likewise.\n+\t* cfgrtl.c: Likewise.\n+\t* convert.c: Likewise.\n+\t* cpphash.h: Likewise.\n+\t* cpplex.c: Likewise.\n+\t* cpplib.h: Likewise.\n+\t* df.h: Likewise.\n+\t* diagnostic.c: Likewise.\n+\t* diagnostic.h: Likewise.\n+\t* dwarf2.h: Likewise.\n+\n 2003-01-17  Stan Shebs  <shebs@apple.com>\n \n \t* config/darwin-protos.h: Forward-declare struct cpp_reader."}, {"sha": "23f413418444051a95236f840d0869d883cba74d", "filename": "gcc/alias.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=95bd1dd72f8e33c77da74e7e6707f206784f6b15", "patch": "@@ -64,7 +64,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n    To see whether two alias sets can point to the same memory, we must\n    see if either alias set is a subset of the other. We need not trace\n-   past immediate descendents, however, since we propagate all\n+   past immediate descendants, however, since we propagate all\n    grandchildren up one level.\n \n    Alias set zero is implicitly a superset of all other alias sets.\n@@ -77,7 +77,7 @@ typedef struct alias_set_entry\n   HOST_WIDE_INT alias_set;\n \n   /* The children of the alias set.  These are not just the immediate\n-     children, but, in fact, all descendents.  So, if we have:\n+     children, but, in fact, all descendants.  So, if we have:\n \n        struct T { struct S s; float f; }\n \n@@ -1953,7 +1953,7 @@ adjust_offset_for_component_ref (x, offset)\n   return GEN_INT (ioffset);\n }\n \n-/* Return nonzero if we can deterimine the exprs corresponding to memrefs\n+/* Return nonzero if we can determine the exprs corresponding to memrefs\n    X and Y and they do not overlap.  */\n \n static int"}, {"sha": "5dd0007b2896cfa09ecba7a6b57f6abaa5fec552", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=95bd1dd72f8e33c77da74e7e6707f206784f6b15", "patch": "@@ -478,7 +478,7 @@ struct loop\n \n      This does not include loop exits due to return instructions.\n      This is because all bivs and givs are pseudos, and hence must be\n-     dead after a return, so the presense of a return does not affect\n+     dead after a return, so the presence of a return does not affect\n      any of the optimizations that use this info.  It is simpler to\n      just not include return instructions on this list.  */\n   rtx exit_labels;"}, {"sha": "2eb2eb7e8c85f0c6f7a4ba603a61cceff70e2eb4", "filename": "gcc/c-common.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=95bd1dd72f8e33c77da74e7e6707f206784f6b15", "patch": "@@ -872,7 +872,7 @@ const struct attribute_spec c_common_attribute_table[] =\n };\n \n /* Give the specifications for the format attributes, used by C and all\n-   descendents.  */\n+   descendants.  */\n \n const struct attribute_spec c_common_format_attribute_table[] =\n {\n@@ -2994,7 +2994,7 @@ c_common_get_alias_set (t)\n   if (! TYPE_P (t))\n     return -1;\n \n-  /* The C standard guarantess that any object may be accessed via an\n+  /* The C standard guarantees that any object may be accessed via an\n      lvalue that has character type.  */\n   if (t == char_type_node\n       || t == signed_char_type_node\n@@ -6355,7 +6355,7 @@ handle_nonnull_attribute (node, name, args, flags, no_add_attrs)\n   unsigned HOST_WIDE_INT attr_arg_num;\n \n   /* If no arguments are specified, all pointer arguments should be\n-     non-null.  Veryify a full prototype is given so that the arguments\n+     non-null.  Verify a full prototype is given so that the arguments\n      will have the correct types when we actually check them later.  */\n   if (! args)\n     {"}, {"sha": "8164fa809426e9c4d2a55dedab41c461d6178f58", "filename": "gcc/c-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=95bd1dd72f8e33c77da74e7e6707f206784f6b15", "patch": "@@ -1010,7 +1010,7 @@ extern tree strip_array_types                   PARAMS ((tree));\n /* GOTO_STMT accessor. This gives access to the label associated with\n    a goto statement.  */\n #define GOTO_DESTINATION(NODE)  TREE_OPERAND (GOTO_STMT_CHECK (NODE), 0)\n-/* True for goto created artifically by the compiler.  */\n+/* True for goto created artificially by the compiler.  */\n #define GOTO_FAKE_P(NODE)\t(TREE_LANG_FLAG_0 (GOTO_STMT_CHECK (NODE)))\n \n /* COMPOUND_STMT accessor. This gives access to the TREE_LIST of"}, {"sha": "c6aa2709dcc7554151e18c99312bf36f3dee1229", "filename": "gcc/c-decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=95bd1dd72f8e33c77da74e7e6707f206784f6b15", "patch": "@@ -2922,7 +2922,7 @@ start_decl (declarator, declspecs, initialized, attributes)\n \n      Thread-local variables are never common, since there's no entrenched\n      body of code to break, and it allows more efficient variable references\n-     in the presense of dynamic linking.  */\n+     in the presence of dynamic linking.  */\n \n   if (TREE_CODE (decl) == VAR_DECL\n       && !initialized\n@@ -5024,7 +5024,7 @@ grokfield (filename, line, declarator, declspecs, width)\n \t     again this is an anonymous struct.\n \t   Otherwise this is an error.\n \n-\t Oh what a horrid tangled web we weave.  I wonder if MS consiously\n+\t Oh what a horrid tangled web we weave.  I wonder if MS consciously\n \t took this from Plan 9 or if it was an accident of implementation\n \t that took root before someone noticed the bug...  */\n "}, {"sha": "bb074615e2a9bbc0088299d50d5600c9d17ebf2b", "filename": "gcc/c-opts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-opts.c?ref=95bd1dd72f8e33c77da74e7e6707f206784f6b15", "patch": "@@ -314,7 +314,7 @@ static const struct cl_option cl_options[] =\n #undef COMMAND_LINE_OPTIONS\n \n /* Holds switches parsed by c_common_decode_option (), but whose\n-   handling is deffered to c_common_post_options ().  */\n+   handling is deferred to c_common_post_options ().  */\n static void defer_opt PARAMS ((enum opt_code, const char *));\n static struct deferred_opt\n {"}, {"sha": "78e9d9dd1055cb3d35b2e3a4155f7f49fdc7c416", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=95bd1dd72f8e33c77da74e7e6707f206784f6b15", "patch": "@@ -424,7 +424,7 @@ handle_pragma_extern_prefix (dummy)\n }\n #endif\n \n-/* Hook from the front ends to apply the results of one of the preceeding\n+/* Hook from the front ends to apply the results of one of the preceding\n    pragmas that rename variables.  */\n \n tree"}, {"sha": "3bdd6fec4a745fdc7ec17ac71d9c1946bf44f6cf", "filename": "gcc/c-pretty-print.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fc-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fc-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.h?ref=95bd1dd72f8e33c77da74e7e6707f206784f6b15", "patch": "@@ -42,7 +42,7 @@ struct c_pretty_print_info\n   int *offset_list;\n \n   /* These must be overridden by each of the C and C++ front-end to\n-     reflect their understanding of syntatic productions when they differ.  */\n+     reflect their understanding of syntactic productions when they differ.  */\n   c_pretty_print_fn declaration;\n   c_pretty_print_fn declaration_specifiers;\n   c_pretty_print_fn type_specifier;"}, {"sha": "ec9fff5f46553d45095d85fe178d30e5117828c1", "filename": "gcc/cfg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=95bd1dd72f8e33c77da74e7e6707f206784f6b15", "patch": "@@ -572,7 +572,7 @@ dump_flow_info (file)\n \n       /* Check the consistency of profile information.  We can't do that\n \t in verify_flow_info, as the counts may get invalid for incompletely\n-\t solved graphs, later elliminating of conditionals or roundoff errors.\n+\t solved graphs, later eliminating of conditionals or roundoff errors.\n \t It is still practical to have them reported for debugging of simple\n \t testcases.  */\n       sum = 0;"}, {"sha": "adbe86611240037e6c4c6f59f71e71340f2beb3c", "filename": "gcc/cfganal.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=95bd1dd72f8e33c77da74e7e6707f206784f6b15", "patch": "@@ -234,7 +234,7 @@ set_edge_can_fallthru_flag ()\n \t    e->flags |= EDGE_CAN_FALLTHRU;\n \t}\n \n-      /* If the BB ends with an invertable condjump all (2) edges are\n+      /* If the BB ends with an invertible condjump all (2) edges are\n \t CAN_FALLTHRU edges.  */\n       if (!bb->succ || !bb->succ->succ_next || bb->succ->succ_next->succ_next)\n \tcontinue;"}, {"sha": "2e1830c924f3995d1bf1a4a7c92f7899e2bebba6", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=95bd1dd72f8e33c77da74e7e6707f206784f6b15", "patch": "@@ -148,7 +148,7 @@ count_basic_blocks (f)\n \n   for (insn = f; insn; insn = NEXT_INSN (insn))\n     {\n-      /* Code labels and barriers causes curent basic block to be\n+      /* Code labels and barriers causes current basic block to be\n          terminated at previous real insn.  */\n       if ((GET_CODE (insn) == CODE_LABEL || GET_CODE (insn) == BARRIER)\n \t  && saw_insn)"}, {"sha": "19e9fd54468278dc453ba97a66a1952b07542bac", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=95bd1dd72f8e33c77da74e7e6707f206784f6b15", "patch": "@@ -263,7 +263,7 @@ mentions_nonequal_regs (x, data)\n   return 0;\n }\n /* Attempt to prove that the basic block B will have no side effects and\n-   allways continues in the same edge if reached via E.  Return the edge\n+   always continues in the same edge if reached via E.  Return the edge\n    if exist, NULL otherwise.  */\n \n static edge\n@@ -323,7 +323,7 @@ thread_jump (mode, e, b)\n     return NULL;\n \n   /* Ensure that the comparison operators are equivalent.\n-     ??? This is far too pesimistic.  We should allow swapped operands,\n+     ??? This is far too pessimistic.  We should allow swapped operands,\n      different CCmodes, or for example comparisons for interval, that\n      dominate even when operands are not equivalent.  */\n   if (!rtx_equal_p (XEXP (cond1, 0), XEXP (cond2, 0))\n@@ -1146,7 +1146,7 @@ outgoing_edges_match (mode, bb1, bb2)\n       /* Do not crossjump across loop boundaries.  This is a temporary\n \t workaround for the common scenario in which crossjumping results\n \t in killing the duplicated loop condition, making bb-reorder rotate\n-\t the loop incorectly, leaving an extra unconditional jump inside\n+\t the loop incorrectly, leaving an extra unconditional jump inside\n \t the loop.\n \n \t This check should go away once bb-reorder knows how to duplicate\n@@ -1776,7 +1776,7 @@ cleanup_cfg (mode)\n     {\n       changed = true;\n       /* We've possibly created trivially dead code.  Cleanup it right\n-\t now to introduce more oppurtunities for try_optimize_cfg.  */\n+\t now to introduce more opportunities for try_optimize_cfg.  */\n       if (!(mode & (CLEANUP_NO_INSN_DEL\n \t\t    | CLEANUP_UPDATE_LIFE | CLEANUP_PRE_SIBCALL))\n \t  && !reload_completed)\n@@ -1790,8 +1790,8 @@ cleanup_cfg (mode)\n       delete_unreachable_blocks (), changed = true;\n       if (mode & CLEANUP_UPDATE_LIFE)\n \t{\n-\t  /* Cleaning up CFG introduces more oppurtunities for dead code\n-\t     removal that in turn may introduce more oppurtunities for\n+\t  /* Cleaning up CFG introduces more opportunities for dead code\n+\t     removal that in turn may introduce more opportunities for\n \t     cleaning up the CFG.  */\n \t  if (!update_life_info_in_dirty_blocks (UPDATE_LIFE_GLOBAL_RM_NOTES,\n \t\t\t\t\t\t PROP_DEATH_NOTES"}, {"sha": "9c52ac1fd543481be8c3e165047c3d4a50d67d6e", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=95bd1dd72f8e33c77da74e7e6707f206784f6b15", "patch": "@@ -717,7 +717,7 @@ cfg_layout_can_duplicate_bb_p (bb)\n        return false;\n \n   /* Do not attempt to duplicate tablejumps, as we need to unshare\n-     the dispatch table.  This is dificult to do, as the instructions\n+     the dispatch table.  This is difficult to do, as the instructions\n      computing jump destination may be hoisted outside the basic block.  */\n   if (GET_CODE (bb->end) == JUMP_INSN && JUMP_LABEL (bb->end)\n       && (next = next_nonnote_insn (JUMP_LABEL (bb->end)))"}, {"sha": "07f4a8c09570e18b214569f3819d7767154a13f2", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=95bd1dd72f8e33c77da74e7e6707f206784f6b15", "patch": "@@ -33,7 +33,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n      - Edge redirection with updating and optimizing of insn chain\n \t block_label, redirect_edge_and_branch,\n \t redirect_edge_and_branch_force, tidy_fallthru_edge, force_nonfallthru\n-     - Edge splitting and commiting to edges\n+     - Edge splitting and committing to edges\n \t split_edge, insert_insn_on_edge, commit_edge_insertions\n      - Dumping and debugging\n \t print_rtl_with_bb, dump_bb, debug_bb, debug_bb_n"}, {"sha": "30aa629a45060b13e9c4a367804e98f4e4accecb", "filename": "gcc/convert.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=95bd1dd72f8e33c77da74e7e6707f206784f6b15", "patch": "@@ -155,7 +155,7 @@ convert_to_real (type, expr)\n       if (TYPE_PRECISION (TREE_TYPE (arg0)) > TYPE_PRECISION (type))\n \tnewtype = TREE_TYPE (arg0);\n \n-      /* Be curefull about integer to fp conversions.\n+      /* Be careful about integer to fp conversions.\n \t These may overflow still.  */\n       if (FLOAT_TYPE_P (TREE_TYPE (arg0))\n \t  && TYPE_PRECISION (newtype) <= TYPE_PRECISION (itype)"}, {"sha": "75f6bc5e2fcb1abdf6c37b9a22dcef04ff8932a7", "filename": "gcc/cpphash.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=95bd1dd72f8e33c77da74e7e6707f206784f6b15", "patch": "@@ -362,7 +362,7 @@ struct cpp_reader\n      _cpp_maybe_push_include_file has yet to restore the line map.  */\n   struct pending_option **next_include_file;\n \n-  /* Multiple inlcude optimisation.  */\n+  /* Multiple include optimisation.  */\n   const cpp_hashnode *mi_cmacro;\n   const cpp_hashnode *mi_ind_cmacro;\n   bool mi_valid;"}, {"sha": "4427b3e3e1e14e07b25cc63895d699c0d9a69fb1", "filename": "gcc/cpplex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=95bd1dd72f8e33c77da74e7e6707f206784f6b15", "patch": "@@ -607,7 +607,7 @@ unescaped_terminator_p (pfile, dest)\n {\n   const unsigned char *start, *temp;\n \n-  /* In #include-style directives, terminators are not escapeable.  */\n+  /* In #include-style directives, terminators are not escapable.  */\n   if (pfile->state.angled_headers)\n     return 1;\n "}, {"sha": "556c78381f399b0eeb617298d8d88358f8b8246c", "filename": "gcc/cpplib.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=95bd1dd72f8e33c77da74e7e6707f206784f6b15", "patch": "@@ -434,7 +434,7 @@ extern const char *progname;\n    entries for all identifiers: either macros defined by #define\n    commands (type NT_MACRO), assertions created with #assert\n    (NT_ASSERTION), or neither of the above (NT_VOID).  Builtin macros\n-   like __LINE__ are flagged NODE_BUILTIN.  Poisioned identifiers are\n+   like __LINE__ are flagged NODE_BUILTIN.  Poisoned identifiers are\n    flagged NODE_POISONED.  NODE_OPERATOR (C++ only) indicates an\n    identifier that behaves like an operator such as \"xor\".\n    NODE_DIAGNOSTIC is for speed in lex_token: it indicates a\n@@ -544,7 +544,7 @@ extern int cpp_handle_option PARAMS ((cpp_reader *, int, char **));\n    too.  If there was an error opening the file, it returns NULL.\n \n    If you want cpplib to manage its own hashtable, pass in a NULL\n-   pointer.  Otherise you should pass in an initialized hash table\n+   pointer.  Otherwise you should pass in an initialized hash table\n    that cpplib will share; this technique is used by the C front\n    ends.  */\n extern const char *cpp_read_main_file PARAMS ((cpp_reader *, const char *,\n@@ -654,7 +654,7 @@ extern cpp_num cpp_interpret_integer PARAMS ((cpp_reader *, const cpp_token *,\n    others assumed clear, to fill out a cpp_num structure.  */\n cpp_num cpp_num_sign_extend PARAMS ((cpp_num, size_t));\n \n-/* Diagnostic levels.  To get a dianostic without associating a\n+/* Diagnostic levels.  To get a diagnostic without associating a\n    position in the translation unit with it, use cpp_error_with_line\n    with a line number of zero.  */\n "}, {"sha": "6324a6bf982212950493cbbbe2f655e500182119", "filename": "gcc/df.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=95bd1dd72f8e33c77da74e7e6707f206784f6b15", "patch": "@@ -57,7 +57,7 @@ enum df_ref_flags\n        and where the mode change of that subreg expression is invalid for\n        this class.  Note, that this flag can also be set on df_refs\n        representing the REG itself (i.e. one might not see the subreg\n-       anyore).  Also note, that this flag is set also for hardreg refs.\n+       anymore).  Also note, that this flag is set also for hardreg refs.\n        I.e. you must check yourself if it's a pseudo.  */\n     DF_REF_MODE_CHANGE = 2\n   };\n@@ -80,7 +80,7 @@ struct insn_info\n {\n   struct df_link *defs;\t\t/* Head of insn-def chain.  */\n   struct df_link *uses;\t\t/* Head of insn-use chain.  */\n-  /* ???? The following luid field should be considerd private so that\n+  /* ???? The following luid field should be considered private so that\n      we can change it on the fly to accommodate new insns?  */\n   int luid;\t\t\t/* Logical UID.  */\n #if 0"}, {"sha": "a192229bd59f6a6f9749bd5577feeec40bd076c3", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=95bd1dd72f8e33c77da74e7e6707f206784f6b15", "patch": "@@ -644,7 +644,7 @@ build_message_string VPARAMS ((const char *msg, ...))\n   return str;\n }\n \n-/* Same as diagnsotic_build_prefix, but only the source FILE is given.  */\n+/* Same as diagnostic_build_prefix, but only the source FILE is given.  */\n char *\n file_name_as_prefix (f)\n      const char *f;\n@@ -817,7 +817,7 @@ diagnostic_set_info (diagnostic, msgid, args, file, line, kind)\n {\n   diagnostic->message.format_spec = msgid;\n   diagnostic->message.args_ptr = args;\n-  /* If the diagnostic message doesn't specify a loccation,\n+  /* If the diagnostic message doesn't specify a location,\n      use FILE and LINE.  */\n   if (!text_specifies_location (&diagnostic->message, &diagnostic->location))\n     {"}, {"sha": "2bb0f8af3491e0503b3d36cd7536d1a527e2a51e", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=95bd1dd72f8e33c77da74e7e6707f206784f6b15", "patch": "@@ -33,7 +33,7 @@ typedef struct\n   va_list *args_ptr;\n } text_info;\n \n-/* Contants used to discreminate diagnostics.  */\n+/* Contants used to discriminate diagnostics.  */\n typedef enum\n {\n #define DEFINE_DIAGNOSTIC_KIND(K, M) K,  \n@@ -282,7 +282,7 @@ extern diagnostic_context *global_dc;\n \n #define report_diagnostic(D) diagnostic_report_diagnostic (global_dc, D)\n \n-/* Dignostic related functions.  */\n+/* Diagnostic related functions.  */\n extern void diagnostic_initialize\tPARAMS ((diagnostic_context *));\n extern void diagnostic_report_current_module PARAMS ((diagnostic_context *));\n extern void diagnostic_report_current_function PARAMS ((diagnostic_context *));"}, {"sha": "2345d3aad140937184b3eaffcf9f5b046dfa2dc5", "filename": "gcc/dwarf2.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fdwarf2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bd1dd72f8e33c77da74e7e6707f206784f6b15/gcc%2Fdwarf2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2.h?ref=95bd1dd72f8e33c77da74e7e6707f206784f6b15", "patch": "@@ -4,7 +4,7 @@\n    Free Software Foundation, Inc.\n \n    Written by Gary Funck (gary@intrepid.com) The Ada Joint Program\n-   Office (AJPO), Florida State Unviversity and Silicon Graphics Inc.\n+   Office (AJPO), Florida State University and Silicon Graphics Inc.\n    provided support for this effort -- June 21, 1995.\n \n    Derived from the DWARF 1 implementation written by Ron Guilmette"}]}