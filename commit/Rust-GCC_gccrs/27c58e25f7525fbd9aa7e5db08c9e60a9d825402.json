{"sha": "27c58e25f7525fbd9aa7e5db08c9e60a9d825402", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjdjNThlMjVmNzUyNWZiZDlhYTdlNWRiMDhjOWU2MGE5ZDgyNTQwMg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-04-28T06:40:28Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-04-28T06:40:28Z"}, "message": "optimize.c (copy_body_r): Use STRIP_TYPE_NOPS when copying variables.\n\n\t* optimize.c (copy_body_r): Use STRIP_TYPE_NOPS when copying\n\tvariables.\n\t(initialize_inlined_parameters): Try to avoid creating new\n\tVAR_DECLs.\n\nFrom-SVN: r33505", "tree": {"sha": "8fb94ae8beb2c4383007b1de702a7846556c1e3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8fb94ae8beb2c4383007b1de702a7846556c1e3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27c58e25f7525fbd9aa7e5db08c9e60a9d825402", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27c58e25f7525fbd9aa7e5db08c9e60a9d825402", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27c58e25f7525fbd9aa7e5db08c9e60a9d825402", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27c58e25f7525fbd9aa7e5db08c9e60a9d825402/comments", "author": null, "committer": null, "parents": [{"sha": "26026d3803c021234bb9ce9b46cba8792764b758", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26026d3803c021234bb9ce9b46cba8792764b758", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26026d3803c021234bb9ce9b46cba8792764b758"}], "stats": {"total": 43, "additions": 41, "deletions": 2}, "files": [{"sha": "c556a21cd12011bed41fcf748bbca0f7de576951", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27c58e25f7525fbd9aa7e5db08c9e60a9d825402/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27c58e25f7525fbd9aa7e5db08c9e60a9d825402/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=27c58e25f7525fbd9aa7e5db08c9e60a9d825402", "patch": "@@ -1,3 +1,10 @@\n+2000-04-27  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* optimize.c (copy_body_r): Use STRIP_TYPE_NOPS when copying\n+\tvariables.\n+\t(initialize_inlined_parameters): Try to avoid creating new\n+\tVAR_DECLs.\n+\n 2000-04-27  Alex Samuel  <samuel@codesourcery.com>\n \n \t* lex.c (my_get_run_time): Remove."}, {"sha": "9863d4abfe1f683bed64832ea701ed635f416a85", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27c58e25f7525fbd9aa7e5db08c9e60a9d825402/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27c58e25f7525fbd9aa7e5db08c9e60a9d825402/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=27c58e25f7525fbd9aa7e5db08c9e60a9d825402", "patch": "@@ -306,6 +306,7 @@ copy_body_r (tp, walk_subtrees, data)\n       new_decl = remap_decl (*tp, id);\n       my_friendly_assert (new_decl != NULL_TREE, 19991203);\n       /* Replace this variable with the copy.  */\n+      STRIP_TYPE_NOPS (new_decl);\n       *tp = new_decl;\n     }\n   else if (nonstatic_local_decl_p (*tp) \n@@ -384,7 +385,38 @@ initialize_inlined_parameters (id, args, fn)\n     {\n       tree init_stmt;\n       tree var;\n-\n+      tree value;\n+      \n+      /* Find the initializer.  */\n+      value = TREE_VALUE (a);\n+      /* If the parameter is never assigned to, we may not need to\n+\t create a new variable here at all.  Instead, we may be able\n+\t to just use the argument value.  */\n+      if (TREE_READONLY (p) && !TREE_SIDE_EFFECTS (value))\n+\t{\n+\t  /* Simplify the value, if possible.  */\n+\t  value = fold (decl_constant_value (value));\n+\t  \n+\t  /* We can't risk substituting complex expressions.  They\n+\t     might contain variables that will be assigned to later.\n+\t     Theoretically, we could check the expression to see if\n+\t     all of the variables that determine its value are\n+\t     read-only, but we don't bother.  */\n+\t  if (TREE_CONSTANT (value) || TREE_READONLY_DECL_P (value))\n+\t    {\n+\t      /* If this is a declaration, wrap it a NOP_EXPR so that\n+\t\t we don't try to put the VALUE on the list of\n+\t\t BLOCK_VARS.  */\n+\t      if (DECL_P (value))\n+\t\tvalue = build1 (NOP_EXPR, TREE_TYPE (value), value);\n+\n+\t      splay_tree_insert (id->decl_map,\n+\t\t\t\t (splay_tree_key) p,\n+\t\t\t\t (splay_tree_value) value);\n+\t      continue;\n+\t    }\n+\t}\n+\t\n       /* Make an equivalent VAR_DECL.  */\n       var = copy_decl_for_inlining (p, fn, VARRAY_TREE (id->fns, 0));\n       /* Register the VAR_DECL as the equivalent for the PARM_DECL;\n@@ -400,7 +432,7 @@ initialize_inlined_parameters (id, args, fn)\n \t object will be constructed in VAR.  */\n       init_stmt = build_min_nt (EXPR_STMT,\n \t\t\t\tbuild (INIT_EXPR, TREE_TYPE (p),\n-\t\t\t\t       var, TREE_VALUE (a)));\n+\t\t\t\t       var, value));\n       /* Declare this new variable.  Note that we do this *after* the\n \t initialization because we are going to reverse all the\n \t initialization statements below.  */"}]}