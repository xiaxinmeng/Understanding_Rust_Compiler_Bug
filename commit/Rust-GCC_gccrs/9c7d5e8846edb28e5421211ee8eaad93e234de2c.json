{"sha": "9c7d5e8846edb28e5421211ee8eaad93e234de2c", "node_id": "C_kwDOANBUbNoAKDljN2Q1ZTg4NDZlZGIyOGU1NDIxMjExZWU4ZWFhZDkzZTIzNGRlMmM", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-12-10T02:14:20Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-12-10T04:25:41Z"}, "message": "d: Merge upstream dmd 3982604c5, druntime bc58b1e9, phobos 12329adb6.\n\nD front-end changes:\n\n    - Import dmd mainline development.\n    - Split off enum EXP from enum TOK.\n    - Integer promotions now follow C integral promotions by default.\n    - Implements __traits(initSymbol).\n    - Lowering of array construction has been moved to the dmd\n      front-end.\n    - Fix segfault in dmd.lexer from unaligned read (PR103529).\n\nDruntime changes:\n\n    - Import druntime mainline development.\n    - Define SIG_BLOCK for Solaris (PR103528).\n\nPhobos changes:\n\n    - Import phobos mainline development.\n\ngcc/d/ChangeLog:\n\n\tPR d/103529\n\t* dmd/MERGE: Merge upstream dmd 3982604c5.\n\t* Make-lang.in (D_FRONTEND_OBJS): Add d/root-optional.o.\n\t* d-attribs.cc (build_attributes): Update for new front-end interface.\n\t* d-codegen.cc (d_build_call): Likewise.\n\t* d-compiler.cc (Compiler::paintAsType): Likewise.\n\t* d-lang.cc (d_handle_option): Remove OPT_fpreview_intpromote, add\n\thandling of OPT_frevert_intpromote.\n\t* d-port.cc (Port::valcpy): Assert buffer is aligned.\n\t* d-target.cc (Target::isVectorOpSupported): Update for new front-end\n\tinterface.\n\t* decl.cc (layout_class_initializer): Likewise.\n\t* expr.cc (lvalue_p): Likewise.\n\t(binop_assignment): Likewise.\n\t(ExprVisitor::visit): Likewise.\n\t(ExprVisitor::visit (AssignExp *)): Remove generation of _d_arrayctor\n\tand _d_arraysetctor library helpers.\n\t(ExprVisitor::visit (VarExp *)): Support __traits(initSymbol).\n\t* intrinsics.cc (expand_intrinsic_rotate): Update for new front-end\n\tinterface.\n\t* lang.opt (fpreview=intpromote): Remove.\n\t(frevert=intpromote): New.\n\t* runtime.def (ARRAYCTOR): Remove.\n\t(ARRAYSETCTOR): Remove.\n\t* toir.cc (IRVisitor::visit): Update for new front-end interface.\n\t* types.cc (layout_aggregate_members): Likewise.\n\t* dmd/root/optional.d: New file.\n\t* dmd/root/optional.h: New file.\n\nlibphobos/ChangeLog:\n\n\tPR d/103528\n\t* libdruntime/MERGE: Merge upstream druntime bc58b1e9.\n\t* libdruntime/Makefile.am (DRUNTIME_DSOURCES_LINUX): Remove\n\tcore/sys/linux/syscalls.d.\n\t* libdruntime/Makefile.in: Regenerate.\n\t* src/MERGE: Merge upstream phobos 12329adb6.\n\t* testsuite/libphobos.config/config.exp: Add test22523.\n\t* libdruntime/core/sys/linux/syscalls.d: Removed.\n\t* testsuite/libphobos.config/test22523.d: New test.", "tree": {"sha": "36b78f03305b82ef82ec5ecfaf29844fadd86ddc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36b78f03305b82ef82ec5ecfaf29844fadd86ddc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9c7d5e8846edb28e5421211ee8eaad93e234de2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c7d5e8846edb28e5421211ee8eaad93e234de2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c7d5e8846edb28e5421211ee8eaad93e234de2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c7d5e8846edb28e5421211ee8eaad93e234de2c/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38c60e5075f89265a560eab166d43247624a7535", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38c60e5075f89265a560eab166d43247624a7535", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38c60e5075f89265a560eab166d43247624a7535"}], "stats": {"total": 11338, "additions": 6436, "deletions": 4902}, "files": [{"sha": "00169a743a1b881843c2d3b52e47084ad8b85b56", "filename": "gcc/d/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2FMake-lang.in?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -162,6 +162,7 @@ D_FRONTEND_OBJS = \\\n \td/root-filename.o \\\n \td/root-hash.o \\\n \td/root-longdouble.o \\\n+\td/root-optional.o \\\n \td/root-port.o \\\n \td/root-region.o \\\n \td/root-rmem.o \\"}, {"sha": "5c9f569d1c4c60c46b4d1e3e86eaa32665900a0a", "filename": "gcc/d/d-attribs.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fd-attribs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fd-attribs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-attribs.cc?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -337,10 +337,10 @@ build_attributes (Expressions *eattrs)\n \tcontinue;\n \n       /* Get the result of the attribute if it hasn't already been folded.  */\n-      if (attr->op == TOKcall)\n+      if (attr->op == EXP::call)\n \tattr = attr->ctfeInterpret ();\n \n-      if (attr->op != TOKstructliteral)\n+      if (attr->op != EXP::structLiteral)\n \t{\n \t  warning_at (make_location_t (attr->loc), OPT_Wattributes,\n \t\t      \"%qE attribute has no effect\",\n@@ -353,7 +353,7 @@ build_attributes (Expressions *eattrs)\n       Expressions *elems = attr->isStructLiteralExp ()->elements;\n       Expression *e0 = (*elems)[0];\n \n-      if (e0->op != TOKstring)\n+      if (e0->op != EXP::string_)\n \t{\n \t  warning_at (make_location_t (attr->loc), OPT_Wattributes,\n \t\t      \"unknown attribute %qs\", e0->toChars());"}, {"sha": "39c3c6ce987b864193fa5abac2b4afcb904899d0", "filename": "gcc/d/d-codegen.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fd-codegen.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fd-codegen.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-codegen.cc?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -2154,9 +2154,9 @@ d_build_call (TypeFunction *tf, tree callable, tree object,\n \t{\n \tLagain:\n \t  Expression *arg = (*arguments)[i];\n-\t  gcc_assert (arg->op != TOKtuple);\n+\t  gcc_assert (arg->op != EXP::tuple);\n \n-\t  if (arg->op == TOKcomma)\n+\t  if (arg->op == EXP::comma)\n \t    {\n \t      CommaExp *ce = arg->isCommaExp ();\n \t      tree tce = build_expr (ce->e1);\n@@ -2200,7 +2200,7 @@ d_build_call (TypeFunction *tf, tree callable, tree object,\n \t      /* Nested structs also have ADDRESSABLE set, but if the type has\n \t\t neither a copy constructor nor a destructor available, then we\n \t\t need to take care of copying its value before passing it.  */\n-\t      if (arg->op == TOKstructliteral || (!sd->postblit && !sd->dtor))\n+\t      if (arg->op == EXP::structLiteral || (!sd->postblit && !sd->dtor))\n \t\ttarg = force_target_expr (targ);\n \n \t      targ = convert (build_reference_type (TREE_TYPE (targ)),"}, {"sha": "c1e78c0a5debcc5fd7351b0d5ae483c70906a59c", "filename": "gcc/d/d-compiler.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fd-compiler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fd-compiler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-compiler.cc?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -50,7 +50,7 @@ Compiler::paintAsType (UnionExp *, Expression *expr, Type *type)\n     cst = build_integer_cst (expr->toInteger (), build_ctype (expr->type));\n   else if (expr->type->isfloating ())\n     cst = build_float_cst (expr->toReal (), expr->type);\n-  else if (expr->op == TOKarrayliteral)\n+  else if (expr->op == EXP::arrayLiteral)\n     {\n       /* Build array as VECTOR_CST, assumes EXPR is constant.  */\n       Expressions *elements = expr->isArrayLiteralExp ()->elements;\n@@ -99,7 +99,7 @@ Compiler::paintAsType (UnionExp *, Expression *expr, Type *type)\n       cst = native_interpret_expr (vectype, buffer, len);\n \n       Expression *e = d_eval_constant_expression (expr->loc, cst);\n-      gcc_assert (e != NULL && e->op == TOKvector);\n+      gcc_assert (e != NULL && e->op == EXP::vector);\n \n       return e->isVectorExp ()->e1;\n     }"}, {"sha": "2c5d206a95fa69193f320ab8055d86d4fe8a0cf7", "filename": "gcc/d/d-lang.cc", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fd-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fd-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-lang.cc?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -620,10 +620,6 @@ d_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,\n       global.params.inclusiveInContracts = value;\n       break;\n \n-    case OPT_fpreview_intpromote:\n-      global.params.fix16997 = value;\n-      break;\n-\n     case OPT_fpreview_nosharedaccess:\n       global.params.noSharedAccess = value;\n       break;\n@@ -642,8 +638,9 @@ d_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,\n \n     case OPT_frevert_all:\n       global.params.useDIP25 = FeatureState::disabled;\n-      global.params.markdown = !value;\n       global.params.dtorFields = FeatureState::disabled;\n+      global.params.fix16997 = !value;\n+      global.params.markdown = !value;\n       break;\n \n     case OPT_frevert_dip25:\n@@ -654,6 +651,10 @@ d_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,\n       global.params.dtorFields = FeatureState::disabled;\n       break;\n \n+    case OPT_frevert_intpromote:\n+      global.params.fix16997 = !value;\n+      break;\n+\n     case OPT_frevert_markdown:\n       global.params.markdown = !value;\n       break;"}, {"sha": "4e867a7db4a53979819e993b0af14edd0167cb8b", "filename": "gcc/d/d-port.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fd-port.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fd-port.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-port.cc?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -145,6 +145,8 @@ Port::readlongBE (const void *buffer)\n void\n Port::valcpy (void *buffer, uint64_t value, size_t sz)\n {\n+  gcc_assert (((size_t) buffer) % sz == 0);\n+\n   switch (sz)\n     {\n     case 1:"}, {"sha": "dd244f1211981a5b8bd0251b4126aa3d1b9210a2", "filename": "gcc/d/d-target.cc", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fd-target.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fd-target.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-target.cc?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -287,7 +287,7 @@ Target::isVectorTypeSupported (int sz, Type *type)\n    Returns true if the operation is supported or type is not a vector.  */\n \n bool\n-Target::isVectorOpSupported (Type *type, unsigned op, Type *)\n+Target::isVectorOpSupported (Type *type, EXP op, Type *)\n {\n   if (type->ty != TY::Tvector)\n     return true;\n@@ -299,31 +299,31 @@ Target::isVectorOpSupported (Type *type, unsigned op, Type *)\n   /* Don't support if expression cannot be represented.  */\n   switch (op)\n     {\n-    case TOKpow:\n-    case TOKpowass:\n+    case EXP::pow:\n+    case EXP::powAssign:\n       /* pow() is lowered as a function call.  */\n       return false;\n \n-    case TOKmod:\n-    case TOKmodass:\n+    case EXP::mod:\n+    case EXP::modAssign:\n       /* fmod() is lowered as a function call.  */\n       if (type->isfloating ())\n \treturn false;\n       break;\n \n-    case TOKandand:\n-    case TOKoror:\n+    case EXP::andAnd:\n+    case EXP::orOr:\n       /* Logical operators must have a result type of bool.  */\n       return false;\n \n-    case TOKle:\n-    case TOKlt:\n-    case TOKge:\n-    case TOKgt:\n-    case TOKequal:\n-    case TOKnotequal:\n-    case TOKidentity:\n-    case TOKnotidentity:\n+    case EXP::lessOrEqual:\n+    case EXP::lessThan:\n+    case EXP::greaterOrEqual:\n+    case EXP::greaterThan:\n+    case EXP::equal:\n+    case EXP::notEqual:\n+    case EXP::identity:\n+    case EXP::notIdentity:\n       /* Comparison operators must have a result type of bool.  */\n       return false;\n "}, {"sha": "bbde4a669e45b0d00995601e1f9bbd50d57d2f37", "filename": "gcc/d/decl.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdecl.cc?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -2239,7 +2239,7 @@ layout_class_initializer (ClassDeclaration *cd)\n   ne->type = cd->type;\n \n   Expression *e = ne->ctfeInterpret ();\n-  gcc_assert (e->op == TOKclassreference);\n+  gcc_assert (e->op == EXP::classReference);\n \n   return build_class_instance (e->isClassReferenceExp ());\n }"}, {"sha": "4bae16c86eb97fa0c54286ff20c7371abfbb8c6e", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -1,4 +1,4 @@\n-568496d5b6ed02d577dfa86f73c7bb4edee05813\n+3982604c54e8770585985a33577fbf19b9b5c9ce\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "d8a65179a9e3fc550358b107a0ce3dfa572b0522", "filename": "gcc/d/dmd/access.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Faccess.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Faccess.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faccess.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -201,7 +201,7 @@ bool checkAccess(Loc loc, Scope* sc, Expression e, Dsymbol d)\n     {\n         // Do access check\n         ClassDeclaration cd = tc.sym;\n-        if (e.op == TOK.super_)\n+        if (e.op == EXP.super_)\n         {\n             if (ClassDeclaration cd2 = sc.func.toParent().isClassDeclaration())\n                 cd = cd2;"}, {"sha": "dc772e8eeac6d6c58a5c351ced6cd9963936019c", "filename": "gcc/d/dmd/aggregate.d", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Faggregate.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Faggregate.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faggregate.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -472,7 +472,7 @@ extern (C++) abstract class AggregateDeclaration : ScopeDsymbol\n         }\n         foreach (e; *elements)\n         {\n-            if (e && e.op == TOK.error)\n+            if (e && e.op == EXP.error)\n                 return false;\n         }\n \n@@ -565,6 +565,18 @@ extern (C++) abstract class AggregateDeclaration : ScopeDsymbol\n \n     override final Type getType()\n     {\n+        /* Apply storage classes to forward references. (Issue 22254)\n+         * Note: Avoid interfaces for now. Implementing qualifiers on interface\n+         * definitions exposed some issues in their TypeInfo generation in DMD.\n+         * Related PR: https://github.com/dlang/dmd/pull/13312\n+         */\n+        if (semanticRun == PASS.init && !isInterfaceDeclaration())\n+        {\n+            auto stc = storage_class;\n+            if (_scope)\n+                stc |= _scope.stc;\n+            type = type.addSTC(stc);\n+        }\n         return type;\n     }\n "}, {"sha": "80db47ded1d9eda77c89dad1f5d4188ed499399e", "filename": "gcc/d/dmd/aliasthis.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Faliasthis.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Faliasthis.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faliasthis.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -91,7 +91,7 @@ Expression resolveAliasThis(Scope* sc, Expression e, bool gag = false, bool find\n         if (ad.aliasthis)\n         {\n             Loc loc = e.loc;\n-            Type tthis = (e.op == TOK.type ? e.type : null);\n+            Type tthis = (e.op == EXP.type ? e.type : null);\n             const flags = DotExpFlag.noAliasThis | (gag ? DotExpFlag.gag : 0);\n             uint olderrors = gag ? global.startGagging() : 0;\n             e = dotExp(e.type, sc, e, ad.aliasthis.ident, flags);\n@@ -100,7 +100,7 @@ Expression resolveAliasThis(Scope* sc, Expression e, bool gag = false, bool find\n \n             if (tthis && ad.aliasthis.sym.needThis())\n             {\n-                if (e.op == TOK.variable)\n+                if (e.op == EXP.variable)\n                 {\n                     if (auto fd = (cast(VarExp)e).var.isFuncDeclaration())\n                     {"}, {"sha": "a234501075ceb6a41d58c694ece1f3d3666207ed", "filename": "gcc/d/dmd/arrayop.d", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Farrayop.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Farrayop.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Farrayop.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -23,6 +23,7 @@ import dmd.expression;\n import dmd.expressionsem;\n import dmd.func;\n import dmd.globals;\n+import dmd.hdrgen;\n import dmd.id;\n import dmd.identifier;\n import dmd.mtype;\n@@ -37,9 +38,9 @@ import dmd.visitor;\n bool isArrayOpValid(Expression e)\n {\n     //printf(\"isArrayOpValid() %s\\n\", e.toChars());\n-    if (e.op == TOK.slice)\n+    if (e.op == EXP.slice)\n         return true;\n-    if (e.op == TOK.arrayLiteral)\n+    if (e.op == EXP.arrayLiteral)\n     {\n         Type t = e.type.toBasetype();\n         while (t.ty == Tarray || t.ty == Tsarray)\n@@ -53,17 +54,17 @@ bool isArrayOpValid(Expression e)\n         {\n             return isArrayOpValid((cast(UnaExp)e).e1);\n         }\n-        if (isBinArrayOp(e.op) || isBinAssignArrayOp(e.op) || e.op == TOK.assign)\n+        if (isBinArrayOp(e.op) || isBinAssignArrayOp(e.op) || e.op == EXP.assign)\n         {\n             BinExp be = cast(BinExp)e;\n             return isArrayOpValid(be.e1) && isArrayOpValid(be.e2);\n         }\n-        if (e.op == TOK.construct)\n+        if (e.op == EXP.construct)\n         {\n             BinExp be = cast(BinExp)e;\n-            return be.e1.op == TOK.slice && isArrayOpValid(be.e2);\n+            return be.e1.op == EXP.slice && isArrayOpValid(be.e2);\n         }\n-        // if (e.op == TOK.call)\n+        // if (e.op == EXP.call)\n         // {\n         // TODO: Decide if [] is required after arrayop calls.\n         // }\n@@ -74,7 +75,7 @@ bool isArrayOpValid(Expression e)\n \n bool isNonAssignmentArrayOp(Expression e)\n {\n-    if (e.op == TOK.slice)\n+    if (e.op == EXP.slice)\n         return isNonAssignmentArrayOp((cast(SliceExp)e).e1);\n \n     Type tb = e.type.toBasetype();\n@@ -166,11 +167,11 @@ Expression arrayOp(BinAssignExp e, Scope* sc)\n     if (tn && (!tn.isMutable() || !tn.isAssignable()))\n     {\n         e.error(\"slice `%s` is not mutable\", e.e1.toChars());\n-        if (e.op == TOK.addAssign)\n+        if (e.op == EXP.addAssign)\n             checkPossibleAddCatError!(AddAssignExp, CatAssignExp)(e.isAddAssignExp);\n         return ErrorExp.get();\n     }\n-    if (e.e1.op == TOK.arrayLiteral)\n+    if (e.e1.op == EXP.arrayLiteral)\n     {\n         return e.e1.modifiableLvalue(sc, e.e1);\n     }\n@@ -228,7 +229,7 @@ private void buildArrayOp(Scope* sc, Expression e, Objects* tiargs, Expressions*\n                 // RPN, prefix unary ops with u\n                 OutBuffer buf;\n                 buf.writestring(\"u\");\n-                buf.writestring(Token.toString(e.op));\n+                buf.writestring(EXPtoString(e.op));\n                 e.e1.accept(this);\n                 tiargs.push(new StringExp(Loc.initial, buf.extractSlice()).expressionSemantic(sc));\n             }\n@@ -246,7 +247,7 @@ private void buildArrayOp(Scope* sc, Expression e, Objects* tiargs, Expressions*\n                 // RPN\n                 e.e1.accept(this);\n                 e.e2.accept(this);\n-                tiargs.push(new StringExp(Loc.initial, Token.toString(e.op)).expressionSemantic(sc));\n+                tiargs.push(new StringExp(Loc.initial, EXPtoString(e.op)).expressionSemantic(sc));\n             }\n         }\n     }\n@@ -274,12 +275,12 @@ bool isArrayOpImplicitCast(TypeDArray tfrom, TypeDArray tto)\n /***********************************************\n  * Test if expression is a unary array op.\n  */\n-bool isUnaArrayOp(TOK op)\n+bool isUnaArrayOp(EXP op)\n {\n     switch (op)\n     {\n-    case TOK.negate:\n-    case TOK.tilde:\n+    case EXP.negate:\n+    case EXP.tilde:\n         return true;\n     default:\n         break;\n@@ -290,19 +291,19 @@ bool isUnaArrayOp(TOK op)\n /***********************************************\n  * Test if expression is a binary array op.\n  */\n-bool isBinArrayOp(TOK op)\n+bool isBinArrayOp(EXP op)\n {\n     switch (op)\n     {\n-    case TOK.add:\n-    case TOK.min:\n-    case TOK.mul:\n-    case TOK.div:\n-    case TOK.mod:\n-    case TOK.xor:\n-    case TOK.and:\n-    case TOK.or:\n-    case TOK.pow:\n+    case EXP.add:\n+    case EXP.min:\n+    case EXP.mul:\n+    case EXP.div:\n+    case EXP.mod:\n+    case EXP.xor:\n+    case EXP.and:\n+    case EXP.or:\n+    case EXP.pow:\n         return true;\n     default:\n         break;\n@@ -313,19 +314,19 @@ bool isBinArrayOp(TOK op)\n /***********************************************\n  * Test if expression is a binary assignment array op.\n  */\n-bool isBinAssignArrayOp(TOK op)\n+bool isBinAssignArrayOp(EXP op)\n {\n     switch (op)\n     {\n-    case TOK.addAssign:\n-    case TOK.minAssign:\n-    case TOK.mulAssign:\n-    case TOK.divAssign:\n-    case TOK.modAssign:\n-    case TOK.xorAssign:\n-    case TOK.andAssign:\n-    case TOK.orAssign:\n-    case TOK.powAssign:\n+    case EXP.addAssign:\n+    case EXP.minAssign:\n+    case EXP.mulAssign:\n+    case EXP.divAssign:\n+    case EXP.modAssign:\n+    case EXP.xorAssign:\n+    case EXP.andAssign:\n+    case EXP.orAssign:\n+    case EXP.powAssign:\n         return true;\n     default:\n         break;\n@@ -339,9 +340,9 @@ bool isBinAssignArrayOp(TOK op)\n bool isArrayOpOperand(Expression e)\n {\n     //printf(\"Expression.isArrayOpOperand() %s\\n\", e.toChars());\n-    if (e.op == TOK.slice)\n+    if (e.op == EXP.slice)\n         return true;\n-    if (e.op == TOK.arrayLiteral)\n+    if (e.op == EXP.arrayLiteral)\n     {\n         Type t = e.type.toBasetype();\n         while (t.ty == Tarray || t.ty == Tsarray)\n@@ -354,7 +355,7 @@ bool isArrayOpOperand(Expression e)\n         return (isUnaArrayOp(e.op) ||\n                 isBinArrayOp(e.op) ||\n                 isBinAssignArrayOp(e.op) ||\n-                e.op == TOK.assign);\n+                e.op == EXP.assign);\n     }\n     return false;\n }\n@@ -371,9 +372,9 @@ bool isArrayOpOperand(Expression e)\n ErrorExp arrayOpInvalidError(Expression e)\n {\n     e.error(\"invalid array operation `%s` (possible missing [])\", e.toChars());\n-    if (e.op == TOK.add)\n+    if (e.op == EXP.add)\n         checkPossibleAddCatError!(AddExp, CatExp)(e.isAddExp());\n-    else if (e.op == TOK.addAssign)\n+    else if (e.op == EXP.addAssign)\n         checkPossibleAddCatError!(AddAssignExp, CatAssignExp)(e.isAddAssignExp());\n     return ErrorExp.get();\n }"}, {"sha": "f6387651e5f0842be7ec53ba61c33655b5ca39b4", "filename": "gcc/d/dmd/astenums.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fastenums.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fastenums.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fastenums.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -62,7 +62,7 @@ enum STC : ulong  // transfer changes to declaration.h\n     foreach_            = 0x4000,   /// variable for foreach loop\n     variadic            = 0x8000,   /// the `variadic` parameter in: T foo(T a, U b, V variadic...)\n \n-    ctorinit            = 0x1_0000,   /// can only be set inside constructor\n+    //                  = 0x1_0000,\n     templateparameter   = 0x2_0000,   /// template parameter\n     ref_                = 0x4_0000,   /// `ref`\n     scope_              = 0x8_0000,   /// `scope`\n@@ -74,7 +74,7 @@ enum STC : ulong  // transfer changes to declaration.h\n \n     returninferred      = 0x100_0000,   /// `return` has been inferred and should not be part of mangling, `return_` must also be set\n     immutable_          = 0x200_0000,   /// `immutable`\n-    init                = 0x400_0000,   /// has explicit initializer\n+    //                  = 0x400_0000,\n     manifest            = 0x800_0000,   /// manifest constant\n \n     nodtor              = 0x1000_0000,   /// do not run destructor"}, {"sha": "e8704aabf73098c9fe3e326f0e5973d7dd1f1734", "filename": "gcc/d/dmd/attrib.d", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fattrib.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fattrib.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fattrib.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -929,12 +929,13 @@ extern (C++) final class PragmaDeclaration : AttribDeclaration\n             (*args)[0] = e;\n         }\n \n-        if (e.isBool(true))\n+        const opt = e.toBool();\n+        if (opt.isEmpty())\n+            return PINLINE.default_;\n+        else if (opt.get())\n             return PINLINE.always;\n-        else if (e.isBool(false))\n-            return PINLINE.never;\n         else\n-            return PINLINE.default_;\n+            return PINLINE.never;\n     }\n \n     override const(char)* kind() const\n@@ -1198,7 +1199,7 @@ extern (C++) final class StaticForeachDeclaration : AttribDeclaration\n \n         // expand static foreach\n         import dmd.statementsem: makeTupleForeach;\n-        Dsymbols* d = makeTupleForeach!(true,true)(_scope, sfe.aggrfe, decl, sfe.needExpansion).decl;\n+        Dsymbols* d = makeTupleForeach(_scope, true, true, sfe.aggrfe, decl, sfe.needExpansion).decl;\n         if (d) // process generated declarations\n         {\n             // Add members lazily."}, {"sha": "5945644482a281ecefbfb69ab644963ba7d08fb8", "filename": "gcc/d/dmd/blockexit.d", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fblockexit.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fblockexit.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fblockexit.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -94,15 +94,15 @@ int blockExit(Statement s, FuncDeclaration func, bool mustNotThrow)\n             result = BE.fallthru;\n             if (s.exp)\n             {\n-                if (s.exp.op == TOK.halt)\n+                if (s.exp.op == EXP.halt)\n                 {\n                     result = BE.halt;\n                     return;\n                 }\n-                if (s.exp.op == TOK.assert_)\n+                if (s.exp.op == EXP.assert_)\n                 {\n                     AssertExp a = cast(AssertExp)s.exp;\n-                    if (a.e1.isBool(false)) // if it's an assert(0)\n+                    if (a.e1.toBool().hasValue(false)) // if it's an assert(0)\n                     {\n                         result = BE.halt;\n                         return;\n@@ -216,7 +216,7 @@ int blockExit(Statement s, FuncDeclaration func, bool mustNotThrow)\n             {\n                 if (canThrow(s.condition, func, mustNotThrow))\n                     result |= BE.throw_;\n-                if (!(result & BE.break_) && s.condition.isBool(true))\n+                if (!(result & BE.break_) && s.condition.toBool().hasValue(true))\n                     result &= ~BE.fallthru;\n             }\n             result &= ~(BE.break_ | BE.continue_);\n@@ -235,9 +235,10 @@ int blockExit(Statement s, FuncDeclaration func, bool mustNotThrow)\n             {\n                 if (canThrow(s.condition, func, mustNotThrow))\n                     result |= BE.throw_;\n-                if (s.condition.isBool(true))\n+                const opt = s.condition.toBool();\n+                if (opt.hasValue(true))\n                     result &= ~BE.fallthru;\n-                else if (s.condition.isBool(false))\n+                else if (opt.hasValue(false))\n                     return;\n             }\n             else\n@@ -274,11 +275,13 @@ int blockExit(Statement s, FuncDeclaration func, bool mustNotThrow)\n             result = BE.none;\n             if (canThrow(s.condition, func, mustNotThrow))\n                 result |= BE.throw_;\n-            if (s.condition.isBool(true))\n+\n+            const opt = s.condition.toBool();\n+            if (opt.hasValue(true))\n             {\n                 result |= blockExit(s.ifbody, func, mustNotThrow);\n             }\n-            else if (s.condition.isBool(false))\n+            else if (opt.hasValue(false))\n             {\n                 result |= blockExit(s.elsebody, func, mustNotThrow);\n             }\n@@ -534,4 +537,3 @@ int blockExit(Statement s, FuncDeclaration func, bool mustNotThrow)\n     s.accept(be);\n     return be.result;\n }\n-"}, {"sha": "2f5b6c734a68c778fda721e26d273b3dcaa9deeb", "filename": "gcc/d/dmd/builtin.d", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fbuiltin.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fbuiltin.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fbuiltin.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -13,8 +13,6 @@\n \n module dmd.builtin;\n \n-import core.stdc.math;\n-import core.stdc.string;\n import dmd.arraytypes;\n import dmd.expression;\n import dmd.func;"}, {"sha": "b67a9d14dd4c6855bfab8d095a326bf31d8b1799", "filename": "gcc/d/dmd/canthrow.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fcanthrow.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fcanthrow.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcanthrow.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -150,7 +150,7 @@ extern (C++) bool canThrow(Expression e, FuncDeclaration func, bool mustNotThrow\n         override void visit(AssignExp ae)\n         {\n             // blit-init cannot throw\n-            if (ae.op == TOK.blit)\n+            if (ae.op == EXP.blit)\n                 return;\n             /* Element-wise assignment could invoke postblits.\n              */"}, {"sha": "c536d25f0a3b79319055bc70f4a95e1306598d14", "filename": "gcc/d/dmd/clone.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fclone.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fclone.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fclone.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -578,7 +578,7 @@ FuncDeclaration buildXopEquals(StructDeclaration sd, Scope* sc)\n     fop.generated = true;\n     Expression e1 = new IdentifierExp(loc, Id.p);\n     Expression e2 = new IdentifierExp(loc, Id.q);\n-    Expression e = new EqualExp(TOK.equal, loc, e1, e2);\n+    Expression e = new EqualExp(EXP.equal, loc, e1, e2);\n     fop.fbody = new ReturnStatement(loc, e);\n     uint errors = global.startGagging(); // Do not report errors\n     Scope* sc2 = sc.push();\n@@ -642,13 +642,13 @@ FuncDeclaration buildXopCmp(StructDeclaration sd, Scope* sc)\n                 Dsymbol s = null;\n                 switch (e.op)\n                 {\n-                case TOK.overloadSet:\n+                case EXP.overloadSet:\n                     s = (cast(OverExp)e).vars;\n                     break;\n-                case TOK.scope_:\n+                case EXP.scope_:\n                     s = (cast(ScopeExp)e).sds;\n                     break;\n-                case TOK.variable:\n+                case EXP.variable:\n                     s = (cast(VarExp)e).var;\n                     break;\n                 default:"}, {"sha": "ce23436d782f0a29a2c33815b4ed2690c03661d0", "filename": "gcc/d/dmd/common/outbuffer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fcommon%2Foutbuffer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fcommon%2Foutbuffer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcommon%2Foutbuffer.h?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -49,7 +49,7 @@ struct OutBuffer\n     void reserve(d_size_t nbytes);\n     void setsize(d_size_t size);\n     void reset();\n-    void write(const void *data, size_t nbytes);\n+    void write(const void *data, d_size_t nbytes);\n     void writestring(const char *string);\n     void prependstring(const char *string);\n     void writenl();                     // write newline"}, {"sha": "abf28144c41baa8c8e70f724c8d71f31e058a3f6", "filename": "gcc/d/dmd/cond.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fcond.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fcond.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcond.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -152,7 +152,7 @@ extern (C++) final class StaticForeach : RootObject\n         sc = sc.endCTFE();\n         el = el.optimize(WANTvalue);\n         el = el.ctfeInterpret();\n-        if (el.op == TOK.int64)\n+        if (el.op == EXP.int64)\n         {\n             Expressions *es = void;\n             if (auto ale = aggr.isArrayLiteralExp())"}, {"sha": "3ca23f24d7e5ffa1dd74b6e6e0a6c750e3a09b03", "filename": "gcc/d/dmd/constfold.d", "status": "modified", "additions": 83, "deletions": 83, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fconstfold.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fconstfold.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fconstfold.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -56,13 +56,13 @@ int isConst(Expression e)\n     //printf(\"Expression::isConst(): %s\\n\", e.toChars());\n     switch (e.op)\n     {\n-    case TOK.int64:\n-    case TOK.float64:\n-    case TOK.complex80:\n+    case EXP.int64:\n+    case EXP.float64:\n+    case EXP.complex80:\n         return 1;\n-    case TOK.null_:\n+    case EXP.null_:\n         return 0;\n-    case TOK.symbolOffset:\n+    case EXP.symbolOffset:\n         return 2;\n     default:\n         return 0;\n@@ -71,13 +71,13 @@ int isConst(Expression e)\n }\n \n /**********************************\n- * Initialize a TOK.cantExpression Expression.\n+ * Initialize a EXP.cantExpression Expression.\n  * Params:\n  *      ue = where to write it\n  */\n void cantExp(out UnionExp ue)\n {\n-    emplaceExp!(CTFEExp)(&ue, TOK.cantExpression);\n+    emplaceExp!(CTFEExp)(&ue, EXP.cantExpression);\n }\n \n /* =============================== constFold() ============================== */\n@@ -120,15 +120,15 @@ UnionExp Not(Type type, Expression e1)\n {\n     UnionExp ue = void;\n     Loc loc = e1.loc;\n-    emplaceExp!(IntegerExp)(&ue, loc, e1.isBool(false) ? 1 : 0, type);\n+    emplaceExp!(IntegerExp)(&ue, loc, e1.toBool().hasValue(false) ? 1 : 0, type);\n     return ue;\n }\n \n private UnionExp Bool(Type type, Expression e1)\n {\n     UnionExp ue = void;\n     Loc loc = e1.loc;\n-    emplaceExp!(IntegerExp)(&ue, loc, e1.isBool(true) ? 1 : 0, type);\n+    emplaceExp!(IntegerExp)(&ue, loc, e1.toBool().hasValue(true) ? 1 : 0, type);\n     return ue;\n }\n \n@@ -222,13 +222,13 @@ UnionExp Add(const ref Loc loc, Type type, Expression e1, Expression e2)\n         }\n         emplaceExp!(ComplexExp)(&ue, loc, v, type);\n     }\n-    else if (e1.op == TOK.symbolOffset)\n+    else if (e1.op == EXP.symbolOffset)\n     {\n         SymOffExp soe = cast(SymOffExp)e1;\n         emplaceExp!(SymOffExp)(&ue, loc, soe.var, soe.offset + e2.toInteger());\n         ue.exp().type = type;\n     }\n-    else if (e2.op == TOK.symbolOffset)\n+    else if (e2.op == EXP.symbolOffset)\n     {\n         SymOffExp soe = cast(SymOffExp)e2;\n         emplaceExp!(SymOffExp)(&ue, loc, soe.var, soe.offset + e1.toInteger());\n@@ -325,7 +325,7 @@ UnionExp Min(const ref Loc loc, Type type, Expression e1, Expression e2)\n         }\n         emplaceExp!(ComplexExp)(&ue, loc, v, type);\n     }\n-    else if (e1.op == TOK.symbolOffset)\n+    else if (e1.op == EXP.symbolOffset)\n     {\n         SymOffExp soe = cast(SymOffExp)e1;\n         emplaceExp!(SymOffExp)(&ue, loc, soe.var, soe.offset - e2.toInteger());\n@@ -722,26 +722,26 @@ UnionExp Xor(const ref Loc loc, Type type, Expression e1, Expression e2)\n     return ue;\n }\n \n-/* Also returns TOK.cantExpression if cannot be computed.\n+/* Also returns EXP.cantExpression if cannot be computed.\n  */\n-UnionExp Equal(TOK op, const ref Loc loc, Type type, Expression e1, Expression e2)\n+UnionExp Equal(EXP op, const ref Loc loc, Type type, Expression e1, Expression e2)\n {\n     UnionExp ue = void;\n     int cmp = 0;\n     real_t r1 = CTFloat.zero;\n     real_t r2 = CTFloat.zero;\n     //printf(\"Equal(e1 = %s, e2 = %s)\\n\", e1.toChars(), e2.toChars());\n-    assert(op == TOK.equal || op == TOK.notEqual);\n-    if (e1.op == TOK.null_)\n+    assert(op == EXP.equal || op == EXP.notEqual);\n+    if (e1.op == EXP.null_)\n     {\n-        if (e2.op == TOK.null_)\n+        if (e2.op == EXP.null_)\n             cmp = 1;\n-        else if (e2.op == TOK.string_)\n+        else if (e2.op == EXP.string_)\n         {\n             StringExp es2 = cast(StringExp)e2;\n             cmp = (0 == es2.len);\n         }\n-        else if (e2.op == TOK.arrayLiteral)\n+        else if (e2.op == EXP.arrayLiteral)\n         {\n             ArrayLiteralExp es2 = cast(ArrayLiteralExp)e2;\n             cmp = !es2.elements || (0 == es2.elements.dim);\n@@ -752,14 +752,14 @@ UnionExp Equal(TOK op, const ref Loc loc, Type type, Expression e1, Expression e\n             return ue;\n         }\n     }\n-    else if (e2.op == TOK.null_)\n+    else if (e2.op == EXP.null_)\n     {\n-        if (e1.op == TOK.string_)\n+        if (e1.op == EXP.string_)\n         {\n             StringExp es1 = cast(StringExp)e1;\n             cmp = (0 == es1.len);\n         }\n-        else if (e1.op == TOK.arrayLiteral)\n+        else if (e1.op == EXP.arrayLiteral)\n         {\n             ArrayLiteralExp es1 = cast(ArrayLiteralExp)e1;\n             cmp = !es1.elements || (0 == es1.elements.dim);\n@@ -770,7 +770,7 @@ UnionExp Equal(TOK op, const ref Loc loc, Type type, Expression e1, Expression e\n             return ue;\n         }\n     }\n-    else if (e1.op == TOK.string_ && e2.op == TOK.string_)\n+    else if (e1.op == EXP.string_ && e2.op == EXP.string_)\n     {\n         StringExp es1 = cast(StringExp)e1;\n         StringExp es2 = cast(StringExp)e2;\n@@ -787,7 +787,7 @@ UnionExp Equal(TOK op, const ref Loc loc, Type type, Expression e1, Expression e\n         else\n             cmp = 0;\n     }\n-    else if (e1.op == TOK.arrayLiteral && e2.op == TOK.arrayLiteral)\n+    else if (e1.op == EXP.arrayLiteral && e2.op == EXP.arrayLiteral)\n     {\n         ArrayLiteralExp es1 = cast(ArrayLiteralExp)e1;\n         ArrayLiteralExp es2 = cast(ArrayLiteralExp)e2;\n@@ -803,7 +803,7 @@ UnionExp Equal(TOK op, const ref Loc loc, Type type, Expression e1, Expression e\n             {\n                 auto ee1 = es1[i];\n                 auto ee2 = es2[i];\n-                ue = Equal(TOK.equal, loc, Type.tint32, ee1, ee2);\n+                ue = Equal(EXP.equal, loc, Type.tint32, ee1, ee2);\n                 if (CTFEExp.isCantExp(ue.exp()))\n                     return ue;\n                 cmp = cast(int)ue.exp().toInteger();\n@@ -812,15 +812,15 @@ UnionExp Equal(TOK op, const ref Loc loc, Type type, Expression e1, Expression e\n             }\n         }\n     }\n-    else if (e1.op == TOK.arrayLiteral && e2.op == TOK.string_)\n+    else if (e1.op == EXP.arrayLiteral && e2.op == EXP.string_)\n     {\n         // Swap operands and use common code\n         Expression etmp = e1;\n         e1 = e2;\n         e2 = etmp;\n         goto Lsa;\n     }\n-    else if (e1.op == TOK.string_ && e2.op == TOK.arrayLiteral)\n+    else if (e1.op == EXP.string_ && e2.op == EXP.arrayLiteral)\n     {\n     Lsa:\n         StringExp es1 = cast(StringExp)e1;\n@@ -847,7 +847,7 @@ UnionExp Equal(TOK op, const ref Loc loc, Type type, Expression e1, Expression e\n             }\n         }\n     }\n-    else if (e1.op == TOK.structLiteral && e2.op == TOK.structLiteral)\n+    else if (e1.op == EXP.structLiteral && e2.op == EXP.structLiteral)\n     {\n         StructLiteralExp es1 = cast(StructLiteralExp)e1;\n         StructLiteralExp es2 = cast(StructLiteralExp)e2;\n@@ -873,8 +873,8 @@ UnionExp Equal(TOK op, const ref Loc loc, Type type, Expression e1, Expression e\n                     cmp = 0;\n                     break;\n                 }\n-                ue = Equal(TOK.equal, loc, Type.tint32, ee1, ee2);\n-                if (ue.exp().op == TOK.cantExpression)\n+                ue = Equal(EXP.equal, loc, Type.tint32, ee1, ee2);\n+                if (ue.exp().op == EXP.cantExpression)\n                     return ue;\n                 cmp = cast(int)ue.exp().toInteger();\n                 if (cmp == 0)\n@@ -920,25 +920,25 @@ UnionExp Equal(TOK op, const ref Loc loc, Type type, Expression e1, Expression e\n         cantExp(ue);\n         return ue;\n     }\n-    if (op == TOK.notEqual)\n+    if (op == EXP.notEqual)\n         cmp ^= 1;\n     emplaceExp!(IntegerExp)(&ue, loc, cmp, type);\n     return ue;\n }\n \n-UnionExp Identity(TOK op, const ref Loc loc, Type type, Expression e1, Expression e2)\n+UnionExp Identity(EXP op, const ref Loc loc, Type type, Expression e1, Expression e2)\n {\n     UnionExp ue = void;\n     int cmp;\n-    if (e1.op == TOK.null_)\n+    if (e1.op == EXP.null_)\n     {\n-        cmp = (e2.op == TOK.null_);\n+        cmp = (e2.op == EXP.null_);\n     }\n-    else if (e2.op == TOK.null_)\n+    else if (e2.op == EXP.null_)\n     {\n         cmp = 0;\n     }\n-    else if (e1.op == TOK.symbolOffset && e2.op == TOK.symbolOffset)\n+    else if (e1.op == EXP.symbolOffset && e2.op == EXP.symbolOffset)\n     {\n         SymOffExp es1 = cast(SymOffExp)e1;\n         SymOffExp es2 = cast(SymOffExp)e2;\n@@ -962,24 +962,24 @@ UnionExp Identity(TOK op, const ref Loc loc, Type type, Expression e1, Expressio\n         }\n         else\n         {\n-            ue = Equal((op == TOK.identity) ? TOK.equal : TOK.notEqual, loc, type, e1, e2);\n+            ue = Equal((op == EXP.identity) ? EXP.equal : EXP.notEqual, loc, type, e1, e2);\n             return ue;\n         }\n     }\n-    if (op == TOK.notIdentity)\n+    if (op == EXP.notIdentity)\n         cmp ^= 1;\n     emplaceExp!(IntegerExp)(&ue, loc, cmp, type);\n     return ue;\n }\n \n-UnionExp Cmp(TOK op, const ref Loc loc, Type type, Expression e1, Expression e2)\n+UnionExp Cmp(EXP op, const ref Loc loc, Type type, Expression e1, Expression e2)\n {\n     UnionExp ue = void;\n     dinteger_t n;\n     real_t r1 = CTFloat.zero;\n     real_t r2 = CTFloat.zero;\n     //printf(\"Cmp(e1 = %s, e2 = %s)\\n\", e1.toChars(), e2.toChars());\n-    if (e1.op == TOK.string_ && e2.op == TOK.string_)\n+    if (e1.op == EXP.string_ && e2.op == EXP.string_)\n     {\n         StringExp es1 = cast(StringExp)e1;\n         StringExp es2 = cast(StringExp)e2;\n@@ -1032,7 +1032,7 @@ UnionExp Cmp(TOK op, const ref Loc loc, Type type, Expression e1, Expression e2)\n     return ue;\n }\n \n-/* Also returns TOK.cantExpression if cannot be computed.\n+/* Also returns EXP.cantExpression if cannot be computed.\n  *  to: type to cast to\n  *  type: type to paint the result\n  */\n@@ -1048,7 +1048,7 @@ UnionExp Cast(const ref Loc loc, Type type, Type to, Expression e1)\n         emplaceExp!(UnionExp)(&ue, e1);\n         return ue;\n     }\n-    if (e1.op == TOK.vector && (cast(TypeVector)e1.type).basetype.equals(type) && type.equals(to))\n+    if (e1.op == EXP.vector && (cast(TypeVector)e1.type).basetype.equals(type) && type.equals(to))\n     {\n         Expression ex = (cast(VectorExp)e1).e1;\n         emplaceExp!(UnionExp)(&ue, ex);\n@@ -1067,14 +1067,14 @@ UnionExp Cast(const ref Loc loc, Type type, Type to, Expression e1)\n     }\n     /* Allow casting from one string type to another\n      */\n-    if (e1.op == TOK.string_)\n+    if (e1.op == EXP.string_)\n     {\n         if (tb.ty == Tarray && typeb.ty == Tarray && tb.nextOf().size() == typeb.nextOf().size())\n         {\n             goto L1;\n         }\n     }\n-    if (e1.op == TOK.arrayLiteral && typeb == tb)\n+    if (e1.op == EXP.arrayLiteral && typeb == tb)\n     {\n     L1:\n         Expression ex = expType(to, e1);\n@@ -1157,7 +1157,7 @@ UnionExp Cast(const ref Loc loc, Type type, Type to, Expression e1)\n     {\n         cantExp(ue);\n     }\n-    else if (tb.ty == Tstruct && e1.op == TOK.int64)\n+    else if (tb.ty == Tstruct && e1.op == EXP.int64)\n     {\n         // Struct = 0;\n         StructDeclaration sd = tb.toDsymbol(null).isStructDeclaration();\n@@ -1169,7 +1169,7 @@ UnionExp Cast(const ref Loc loc, Type type, Type to, Expression e1)\n             UnionExp zero;\n             emplaceExp!(IntegerExp)(&zero, 0);\n             ue = Cast(loc, v.type, v.type, zero.exp());\n-            if (ue.exp().op == TOK.cantExpression)\n+            if (ue.exp().op == EXP.cantExpression)\n                 return ue;\n             elements.push(ue.exp().copy());\n         }\n@@ -1193,18 +1193,18 @@ UnionExp ArrayLength(Type type, Expression e1)\n {\n     UnionExp ue = void;\n     Loc loc = e1.loc;\n-    if (e1.op == TOK.string_)\n+    if (e1.op == EXP.string_)\n     {\n         StringExp es1 = cast(StringExp)e1;\n         emplaceExp!(IntegerExp)(&ue, loc, es1.len, type);\n     }\n-    else if (e1.op == TOK.arrayLiteral)\n+    else if (e1.op == EXP.arrayLiteral)\n     {\n         ArrayLiteralExp ale = cast(ArrayLiteralExp)e1;\n         size_t dim = ale.elements ? ale.elements.dim : 0;\n         emplaceExp!(IntegerExp)(&ue, loc, dim, type);\n     }\n-    else if (e1.op == TOK.assocArrayLiteral)\n+    else if (e1.op == EXP.assocArrayLiteral)\n     {\n         AssocArrayLiteralExp ale = cast(AssocArrayLiteralExp)e1;\n         size_t dim = ale.keys.dim;\n@@ -1220,15 +1220,15 @@ UnionExp ArrayLength(Type type, Expression e1)\n     return ue;\n }\n \n-/* Also return TOK.cantExpression if this fails\n+/* Also return EXP.cantExpression if this fails\n  */\n UnionExp Index(Type type, Expression e1, Expression e2)\n {\n     UnionExp ue = void;\n     Loc loc = e1.loc;\n     //printf(\"Index(e1 = %s, e2 = %s)\\n\", e1.toChars(), e2.toChars());\n     assert(e1.type);\n-    if (e1.op == TOK.string_ && e2.op == TOK.int64)\n+    if (e1.op == EXP.string_ && e2.op == EXP.int64)\n     {\n         StringExp es1 = cast(StringExp)e1;\n         uinteger_t i = e2.toInteger();\n@@ -1242,7 +1242,7 @@ UnionExp Index(Type type, Expression e1, Expression e2)\n             emplaceExp!(IntegerExp)(&ue, loc, es1.charAt(i), type);\n         }\n     }\n-    else if (e1.type.toBasetype().ty == Tsarray && e2.op == TOK.int64)\n+    else if (e1.type.toBasetype().ty == Tsarray && e2.op == EXP.int64)\n     {\n         TypeSArray tsa = cast(TypeSArray)e1.type.toBasetype();\n         uinteger_t length = tsa.dim.toInteger();\n@@ -1252,7 +1252,7 @@ UnionExp Index(Type type, Expression e1, Expression e2)\n             e1.error(\"array index %llu is out of bounds `%s[0 .. %llu]`\", i, e1.toChars(), length);\n             emplaceExp!(ErrorExp)(&ue);\n         }\n-        else if (e1.op == TOK.arrayLiteral)\n+        else if (e1.op == EXP.arrayLiteral)\n         {\n             ArrayLiteralExp ale = cast(ArrayLiteralExp)e1;\n             auto e = ale[cast(size_t)i];\n@@ -1266,10 +1266,10 @@ UnionExp Index(Type type, Expression e1, Expression e2)\n         else\n             cantExp(ue);\n     }\n-    else if (e1.type.toBasetype().ty == Tarray && e2.op == TOK.int64)\n+    else if (e1.type.toBasetype().ty == Tarray && e2.op == EXP.int64)\n     {\n         uinteger_t i = e2.toInteger();\n-        if (e1.op == TOK.arrayLiteral)\n+        if (e1.op == EXP.arrayLiteral)\n         {\n             ArrayLiteralExp ale = cast(ArrayLiteralExp)e1;\n             if (i >= ale.elements.dim)\n@@ -1291,7 +1291,7 @@ UnionExp Index(Type type, Expression e1, Expression e2)\n         else\n             cantExp(ue);\n     }\n-    else if (e1.op == TOK.assocArrayLiteral)\n+    else if (e1.op == EXP.assocArrayLiteral)\n     {\n         AssocArrayLiteralExp ae = cast(AssocArrayLiteralExp)e1;\n         /* Search the keys backwards, in case there are duplicate keys\n@@ -1300,10 +1300,10 @@ UnionExp Index(Type type, Expression e1, Expression e2)\n         {\n             i--;\n             Expression ekey = (*ae.keys)[i];\n-            ue = Equal(TOK.equal, loc, Type.tbool, ekey, e2);\n+            ue = Equal(EXP.equal, loc, Type.tbool, ekey, e2);\n             if (CTFEExp.isCantExp(ue.exp()))\n                 return ue;\n-            if (ue.exp().isBool(true))\n+            if (ue.exp().toBool().hasValue(true))\n             {\n                 Expression e = (*ae.values)[i];\n                 e.type = type;\n@@ -1322,7 +1322,7 @@ UnionExp Index(Type type, Expression e1, Expression e2)\n     return ue;\n }\n \n-/* Also return TOK.cantExpression if this fails\n+/* Also return EXP.cantExpression if this fails\n  */\n UnionExp Slice(Type type, Expression e1, Expression lwr, Expression upr)\n {\n@@ -1347,7 +1347,7 @@ UnionExp Slice(Type type, Expression e1, Expression lwr, Expression upr)\n                  newupr <= upr);\n     }\n \n-    if (e1.op == TOK.string_ && lwr.op == TOK.int64 && upr.op == TOK.int64)\n+    if (e1.op == EXP.string_ && lwr.op == EXP.int64 && upr.op == EXP.int64)\n     {\n         StringExp es1 = cast(StringExp)e1;\n         const uinteger_t ilwr = lwr.toInteger();\n@@ -1367,7 +1367,7 @@ UnionExp Slice(Type type, Expression e1, Expression lwr, Expression upr)\n             es.type = type;\n         }\n     }\n-    else if (e1.op == TOK.arrayLiteral && lwr.op == TOK.int64 && upr.op == TOK.int64 && !hasSideEffect(e1))\n+    else if (e1.op == EXP.arrayLiteral && lwr.op == EXP.int64 && upr.op == EXP.int64 && !hasSideEffect(e1))\n     {\n         ArrayLiteralExp es1 = cast(ArrayLiteralExp)e1;\n         const uinteger_t ilwr = lwr.toInteger();\n@@ -1480,14 +1480,14 @@ private Expressions* copyElements(Expression e1, Expression e2 = null)\n         }\n     }\n \n-    if (e1.op == TOK.arrayLiteral)\n+    if (e1.op == EXP.arrayLiteral)\n         append(cast(ArrayLiteralExp)e1);\n     else\n         elems.push(e1);\n \n     if (e2)\n     {\n-        if (e2.op == TOK.arrayLiteral)\n+        if (e2.op == EXP.arrayLiteral)\n             append(cast(ArrayLiteralExp)e2);\n         else\n             elems.push(e2);\n@@ -1496,7 +1496,7 @@ private Expressions* copyElements(Expression e1, Expression e2 = null)\n     return elems;\n }\n \n-/* Also return TOK.cantExpression if this fails\n+/* Also return EXP.cantExpression if this fails\n  */\n UnionExp Cat(const ref Loc loc, Type type, Expression e1, Expression e2)\n {\n@@ -1507,13 +1507,13 @@ UnionExp Cat(const ref Loc loc, Type type, Expression e1, Expression e2)\n     Type t2 = e2.type.toBasetype();\n     //printf(\"Cat(e1 = %s, e2 = %s)\\n\", e1.toChars(), e2.toChars());\n     //printf(\"\\tt1 = %s, t2 = %s, type = %s\\n\", t1.toChars(), t2.toChars(), type.toChars());\n-    if (e1.op == TOK.null_ && (e2.op == TOK.int64 || e2.op == TOK.structLiteral))\n+    if (e1.op == EXP.null_ && (e2.op == EXP.int64 || e2.op == EXP.structLiteral))\n     {\n         e = e2;\n         t = t1;\n         goto L2;\n     }\n-    else if ((e1.op == TOK.int64 || e1.op == TOK.structLiteral) && e2.op == TOK.null_)\n+    else if ((e1.op == EXP.int64 || e1.op == EXP.structLiteral) && e2.op == EXP.null_)\n     {\n         e = e1;\n         t = t2;\n@@ -1547,7 +1547,7 @@ UnionExp Cat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         assert(ue.exp().type);\n         return ue;\n     }\n-    else if (e1.op == TOK.null_ && e2.op == TOK.null_)\n+    else if (e1.op == EXP.null_ && e2.op == EXP.null_)\n     {\n         if (type == e1.type)\n         {\n@@ -1575,7 +1575,7 @@ UnionExp Cat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         assert(ue.exp().type);\n         return ue;\n     }\n-    else if (e1.op == TOK.string_ && e2.op == TOK.string_)\n+    else if (e1.op == EXP.string_ && e2.op == EXP.string_)\n     {\n         // Concatenate the strings\n         StringExp es1 = cast(StringExp)e1;\n@@ -1604,7 +1604,7 @@ UnionExp Cat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         assert(ue.exp().type);\n         return ue;\n     }\n-    else if (e2.op == TOK.string_ && e1.op == TOK.arrayLiteral && t1.nextOf().isintegral())\n+    else if (e2.op == EXP.string_ && e1.op == EXP.arrayLiteral && t1.nextOf().isintegral())\n     {\n         // [chars] ~ string --> [chars]\n         StringExp es = cast(StringExp)e2;\n@@ -1621,7 +1621,7 @@ UnionExp Cat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         assert(ue.exp().type);\n         return ue;\n     }\n-    else if (e1.op == TOK.string_ && e2.op == TOK.arrayLiteral && t2.nextOf().isintegral())\n+    else if (e1.op == EXP.string_ && e2.op == EXP.arrayLiteral && t2.nextOf().isintegral())\n     {\n         // string ~ [chars] --> [chars]\n         StringExp es = cast(StringExp)e1;\n@@ -1638,7 +1638,7 @@ UnionExp Cat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         assert(ue.exp().type);\n         return ue;\n     }\n-    else if (e1.op == TOK.string_ && e2.op == TOK.int64)\n+    else if (e1.op == EXP.string_ && e2.op == EXP.int64)\n     {\n         // string ~ char --> string\n         StringExp es1 = cast(StringExp)e1;\n@@ -1663,7 +1663,7 @@ UnionExp Cat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         assert(ue.exp().type);\n         return ue;\n     }\n-    else if (e1.op == TOK.int64 && e2.op == TOK.string_)\n+    else if (e1.op == EXP.int64 && e2.op == EXP.string_)\n     {\n         // [w|d]?char ~ string --> string\n         // We assume that we only ever prepend one char of the same type\n@@ -1684,7 +1684,7 @@ UnionExp Cat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         assert(ue.exp().type);\n         return ue;\n     }\n-    else if (e1.op == TOK.arrayLiteral && e2.op == TOK.arrayLiteral && t1.nextOf().equals(t2.nextOf()))\n+    else if (e1.op == EXP.arrayLiteral && e2.op == EXP.arrayLiteral && t1.nextOf().equals(t2.nextOf()))\n     {\n         // Concatenate the arrays\n         auto elems = copyElements(e1, e2);\n@@ -1701,12 +1701,12 @@ UnionExp Cat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         assert(ue.exp().type);\n         return ue;\n     }\n-    else if (e1.op == TOK.arrayLiteral && e2.op == TOK.null_ && t1.nextOf().equals(t2.nextOf()))\n+    else if (e1.op == EXP.arrayLiteral && e2.op == EXP.null_ && t1.nextOf().equals(t2.nextOf()))\n     {\n         e = e1;\n         goto L3;\n     }\n-    else if (e1.op == TOK.null_ && e2.op == TOK.arrayLiteral && t1.nextOf().equals(t2.nextOf()))\n+    else if (e1.op == EXP.null_ && e2.op == EXP.arrayLiteral && t1.nextOf().equals(t2.nextOf()))\n     {\n         e = e2;\n     L3:\n@@ -1725,9 +1725,9 @@ UnionExp Cat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         assert(ue.exp().type);\n         return ue;\n     }\n-    else if ((e1.op == TOK.arrayLiteral || e1.op == TOK.null_) && e1.type.toBasetype().nextOf() && e1.type.toBasetype().nextOf().equals(e2.type))\n+    else if ((e1.op == EXP.arrayLiteral || e1.op == EXP.null_) && e1.type.toBasetype().nextOf() && e1.type.toBasetype().nextOf().equals(e2.type))\n     {\n-        auto elems = (e1.op == TOK.arrayLiteral)\n+        auto elems = (e1.op == EXP.arrayLiteral)\n                 ? copyElements(e1) : new Expressions();\n         elems.push(e2);\n \n@@ -1743,7 +1743,7 @@ UnionExp Cat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         assert(ue.exp().type);\n         return ue;\n     }\n-    else if (e2.op == TOK.arrayLiteral && e2.type.toBasetype().nextOf().equals(e1.type))\n+    else if (e2.op == EXP.arrayLiteral && e2.type.toBasetype().nextOf().equals(e1.type))\n     {\n         auto elems = copyElements(e1, e2);\n \n@@ -1759,13 +1759,13 @@ UnionExp Cat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         assert(ue.exp().type);\n         return ue;\n     }\n-    else if (e1.op == TOK.null_ && e2.op == TOK.string_)\n+    else if (e1.op == EXP.null_ && e2.op == EXP.string_)\n     {\n         t = e1.type;\n         e = e2;\n         goto L1;\n     }\n-    else if (e1.op == TOK.string_ && e2.op == TOK.null_)\n+    else if (e1.op == EXP.string_ && e2.op == EXP.null_)\n     {\n         e = e1;\n         t = e2.type;\n@@ -1801,13 +1801,13 @@ UnionExp Ptr(Type type, Expression e1)\n {\n     //printf(\"Ptr(e1 = %s)\\n\", e1.toChars());\n     UnionExp ue = void;\n-    if (e1.op == TOK.add)\n+    if (e1.op == EXP.add)\n     {\n         AddExp ae = cast(AddExp)e1;\n-        if (ae.e1.op == TOK.address && ae.e2.op == TOK.int64)\n+        if (ae.e1.op == EXP.address && ae.e2.op == EXP.int64)\n         {\n             AddrExp ade = cast(AddrExp)ae.e1;\n-            if (ade.e1.op == TOK.structLiteral)\n+            if (ade.e1.op == EXP.structLiteral)\n             {\n                 StructLiteralExp se = cast(StructLiteralExp)ade.e1;\n                 uint offset = cast(uint)ae.e2.toInteger();"}, {"sha": "dfc45e0bc31ee76822783ab80b93e46ed7ec4f97", "filename": "gcc/d/dmd/cparse.d", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fcparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fcparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcparse.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -212,7 +212,7 @@ final class CParser(AST) : Parser!AST\n         case TOK.sizeof_:\n         Lexp:\n             auto exp = cparseExpression();\n-            if (token.value == TOK.identifier && exp.op == TOK.identifier)\n+            if (token.value == TOK.identifier && exp.op == EXP.identifier)\n             {\n                 error(\"found `%s` when expecting `;` or `=`, did you mean `%s %s = %s`?\", peek(&token).toChars(), exp.toChars(), token.toChars(), peek(peek(&token)).toChars());\n                 nextToken();\n@@ -781,11 +781,11 @@ final class CParser(AST) : Parser!AST\n                 break;\n \n             case TOK.plusPlus:\n-                e = new AST.PostExp(TOK.plusPlus, loc, e);\n+                e = new AST.PostExp(EXP.plusPlus, loc, e);\n                 break;\n \n             case TOK.minusMinus:\n-                e = new AST.PostExp(TOK.minusMinus, loc, e);\n+                e = new AST.PostExp(EXP.minusMinus, loc, e);\n                 break;\n \n             case TOK.leftParenthesis:\n@@ -841,14 +841,14 @@ final class CParser(AST) : Parser!AST\n             // Parse `++` as an unary operator so that cast expressions only give\n             // an error for being non-lvalues.\n             e = cparseCastExp();\n-            e = new AST.PreExp(TOK.prePlusPlus, loc, e);\n+            e = new AST.PreExp(EXP.prePlusPlus, loc, e);\n             break;\n \n         case TOK.minusMinus:\n             nextToken();\n             // Parse `--` as an unary operator, same as prefix increment.\n             e = cparseCastExp();\n-            e = new AST.PreExp(TOK.preMinusMinus, loc, e);\n+            e = new AST.PreExp(EXP.preMinusMinus, loc, e);\n             break;\n \n         case TOK.and:\n@@ -1122,14 +1122,15 @@ final class CParser(AST) : Parser!AST\n         const loc = token.loc;\n \n         auto e = cparseShiftExp();\n-        TOK op = token.value;\n \n-        switch (op)\n+        EXP op = EXP.reserved;\n+        switch (token.value)\n         {\n-        case TOK.lessThan:\n-        case TOK.lessOrEqual:\n-        case TOK.greaterThan:\n-        case TOK.greaterOrEqual:\n+        case TOK.lessThan:       op = EXP.lessThan; goto Lcmp;\n+        case TOK.lessOrEqual:    op = EXP.lessOrEqual; goto Lcmp;\n+        case TOK.greaterThan:    op = EXP.greaterThan; goto Lcmp;\n+        case TOK.greaterOrEqual: op = EXP.greaterOrEqual; goto Lcmp;\n+        Lcmp:\n             nextToken();\n             auto e2 = cparseShiftExp();\n             e = new AST.CmpExp(op, loc, e, e2);\n@@ -1153,12 +1154,13 @@ final class CParser(AST) : Parser!AST\n         const loc = token.loc;\n \n         auto e = cparseRelationalExp();\n-        const TOK op = token.value;\n \n-        switch (op)\n+        EXP op = EXP.reserved;\n+        switch (token.value)\n         {\n-        case TOK.equal:\n-        case TOK.notEqual:\n+        case TOK.equal:         op = EXP.equal;    goto Lequal;\n+        case TOK.notEqual:      op = EXP.notEqual; goto Lequal;\n+        Lequal:\n             nextToken();\n             auto e2 = cparseRelationalExp();\n             e = new AST.EqualExp(op, loc, e, e2);\n@@ -1245,7 +1247,7 @@ final class CParser(AST) : Parser!AST\n         {\n             nextToken();\n             auto e2 = cparseOrExp();\n-            e = new AST.LogicalExp(loc, TOK.andAnd, e, e2);\n+            e = new AST.LogicalExp(loc, EXP.andAnd, e, e2);\n         }\n         return e;\n     }\n@@ -1265,7 +1267,7 @@ final class CParser(AST) : Parser!AST\n         {\n             nextToken();\n             auto e2 = cparseAndAndExp();\n-            e = new AST.LogicalExp(loc, TOK.orOr, e, e2);\n+            e = new AST.LogicalExp(loc, EXP.orOr, e, e2);\n         }\n         return e;\n     }\n@@ -1693,7 +1695,11 @@ final class CParser(AST) : Parser!AST\n             switch (token.value)\n             {\n                 case TOK.identifier:\n-                    error(\"missing comma\");\n+                    if (s)\n+                    {\n+                        error(\"missing comma or semicolon after declaration of `%s`, found `%s` instead\", s.toChars(), token.toChars());\n+                        goto Lend;\n+                    }\n                     goto default;\n \n                 case TOK.semicolon:\n@@ -1707,7 +1713,8 @@ final class CParser(AST) : Parser!AST\n                     break;\n \n                 default:\n-                    error(\"`=`, `;` or `,` expected\");\n+                    error(\"`=`, `;` or `,` expected to end declaration instead of `%s`\", token.toChars());\n+                Lend:\n                     while (token.value != TOK.semicolon && token.value != TOK.endOfFile)\n                         nextToken();\n                     nextToken();"}, {"sha": "4ad79da02f296f8b84f0635a5e03f0beba14458f", "filename": "gcc/d/dmd/cppmangle.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fcppmangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fcppmangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcppmangle.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -490,7 +490,7 @@ private final class CppMangleVisitor : Visitor\n                 mangle_function(d.isFuncDeclaration());\n                 buf.writestring(\"EE\");\n             }\n-            else if (e && e.op == TOK.variable && (cast(VarExp)e).var.isVarDeclaration())\n+            else if (e && e.op == EXP.variable && (cast(VarExp)e).var.isVarDeclaration())\n             {\n                 VarDeclaration vd = (cast(VarExp)e).var.isVarDeclaration();\n                 buf.writeByte('L');"}, {"sha": "9cd09bab643b24a9face25c49d680016cfd7f371", "filename": "gcc/d/dmd/ctfeexpr.d", "status": "modified", "additions": 197, "deletions": 197, "changes": 394, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fctfeexpr.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fctfeexpr.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fctfeexpr.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -46,7 +46,7 @@ extern (C++) final class ClassReferenceExp : Expression\n \n     extern (D) this(const ref Loc loc, StructLiteralExp lit, Type type)\n     {\n-        super(loc, TOK.classReference, __traits(classInstanceSize, ClassReferenceExp));\n+        super(loc, EXP.classReference, __traits(classInstanceSize, ClassReferenceExp));\n         assert(lit && lit.sd && lit.sd.isClassDeclaration());\n         this.value = lit;\n         this.type = type;\n@@ -131,7 +131,7 @@ extern (C++) final class ThrownExceptionExp : Expression\n \n     extern (D) this(const ref Loc loc, ClassReferenceExp victim)\n     {\n-        super(loc, TOK.thrownException, __traits(classInstanceSize, ThrownExceptionExp));\n+        super(loc, EXP.thrownException, __traits(classInstanceSize, ThrownExceptionExp));\n         this.thrown = victim;\n         this.type = victim.type;\n     }\n@@ -167,7 +167,7 @@ extern (C++) final class ThrownExceptionExp : Expression\n  */\n extern (C++) final class CTFEExp : Expression\n {\n-    extern (D) this(TOK tok)\n+    extern (D) this(EXP tok)\n     {\n         super(Loc.initial, tok, __traits(classInstanceSize, CTFEExp));\n         type = Type.tvoid;\n@@ -177,17 +177,17 @@ extern (C++) final class CTFEExp : Expression\n     {\n         switch (op)\n         {\n-        case TOK.cantExpression:\n+        case EXP.cantExpression:\n             return \"<cant>\";\n-        case TOK.voidExpression:\n+        case EXP.voidExpression:\n             return \"cast(void)0\";\n-        case TOK.showCtfeContext:\n+        case EXP.showCtfeContext:\n             return \"<error>\";\n-        case TOK.break_:\n+        case EXP.break_:\n             return \"<break>\";\n-        case TOK.continue_:\n+        case EXP.continue_:\n             return \"<continue>\";\n-        case TOK.goto_:\n+        case EXP.goto_:\n             return \"<goto>\";\n         default:\n             assert(0);\n@@ -206,19 +206,19 @@ extern (C++) final class CTFEExp : Expression\n \n     extern (D) static bool isCantExp(const Expression e)\n     {\n-        return e && e.op == TOK.cantExpression;\n+        return e && e.op == EXP.cantExpression;\n     }\n \n     extern (D) static bool isGotoExp(const Expression e)\n     {\n-        return e && e.op == TOK.goto_;\n+        return e && e.op == EXP.goto_;\n     }\n }\n \n // True if 'e' is CTFEExp::cantexp, or an exception\n bool exceptionOrCantInterpret(const Expression e)\n {\n-    return e && (e.op == TOK.cantExpression || e.op == TOK.thrownException || e.op == TOK.showCtfeContext);\n+    return e && (e.op == EXP.cantExpression || e.op == EXP.thrownException || e.op == EXP.showCtfeContext);\n }\n \n /************** Aggregate literals (AA/string/array/struct) ******************/\n@@ -231,29 +231,29 @@ bool needToCopyLiteral(const Expression expr)\n     {\n         switch (e.op)\n         {\n-        case TOK.arrayLiteral:\n+        case EXP.arrayLiteral:\n             return (cast(ArrayLiteralExp)e).ownedByCtfe == OwnedBy.code;\n-        case TOK.assocArrayLiteral:\n+        case EXP.assocArrayLiteral:\n             return (cast(AssocArrayLiteralExp)e).ownedByCtfe == OwnedBy.code;\n-        case TOK.structLiteral:\n+        case EXP.structLiteral:\n             return (cast(StructLiteralExp)e).ownedByCtfe == OwnedBy.code;\n-        case TOK.string_:\n-        case TOK.this_:\n-        case TOK.variable:\n+        case EXP.string_:\n+        case EXP.this_:\n+        case EXP.variable:\n             return false;\n-        case TOK.assign:\n+        case EXP.assign:\n             return false;\n-        case TOK.index:\n-        case TOK.dotVariable:\n-        case TOK.slice:\n-        case TOK.cast_:\n+        case EXP.index:\n+        case EXP.dotVariable:\n+        case EXP.slice:\n+        case EXP.cast_:\n             e = (cast(UnaExp)e).e1;\n             continue;\n-        case TOK.concatenate:\n+        case EXP.concatenate:\n             return needToCopyLiteral((cast(BinExp)e).e1) || needToCopyLiteral((cast(BinExp)e).e2);\n-        case TOK.concatenateAssign:\n-        case TOK.concatenateElemAssign:\n-        case TOK.concatenateDcharAssign:\n+        case EXP.concatenateAssign:\n+        case EXP.concatenateElemAssign:\n+        case EXP.concatenateDcharAssign:\n             e = (cast(BinExp)e).e2;\n             continue;\n         default:\n@@ -358,7 +358,7 @@ UnionExp copyLiteral(Expression e)\n         r.origin = sle.origin;\n         return ue;\n     }\n-    if (e.op == TOK.function_ || e.op == TOK.delegate_ || e.op == TOK.symbolOffset || e.op == TOK.null_ || e.op == TOK.variable || e.op == TOK.dotVariable || e.op == TOK.int64 || e.op == TOK.float64 || e.op == TOK.char_ || e.op == TOK.complex80 || e.op == TOK.void_ || e.op == TOK.vector || e.op == TOK.typeid_)\n+    if (e.op == EXP.function_ || e.op == EXP.delegate_ || e.op == EXP.symbolOffset || e.op == EXP.null_ || e.op == EXP.variable || e.op == EXP.dotVariable || e.op == EXP.int64 || e.op == EXP.float64 || e.op == EXP.char_ || e.op == EXP.complex80 || e.op == EXP.void_ || e.op == EXP.vector || e.op == EXP.typeid_)\n     {\n         // Simple value types\n         // Keep e1 for DelegateExp and DotVarExp\n@@ -372,7 +372,7 @@ UnionExp copyLiteral(Expression e)\n         if (se.type.toBasetype().ty == Tsarray)\n         {\n             // same with resolveSlice()\n-            if (se.e1.op == TOK.null_)\n+            if (se.e1.op == EXP.null_)\n             {\n                 emplaceExp!(NullExp)(&ue, se.loc, se.type);\n                 return ue;\n@@ -415,7 +415,7 @@ UnionExp copyLiteral(Expression e)\n         emplaceExp!(ClassReferenceExp)(&ue, e.loc, cre.value, e.type);\n         return ue;\n     }\n-    if (e.op == TOK.error)\n+    if (e.op == EXP.error)\n     {\n         emplaceExp!(UnionExp)(&ue, e);\n         return ue;\n@@ -468,11 +468,11 @@ private UnionExp paintTypeOntoLiteralCopy(Type type, Expression lit)\n     {\n         emplaceExp!(IndexExp)(&ue, lit.loc, ie.e1, ie.e2);\n     }\n-    else if (lit.op == TOK.arrayLiteral)\n+    else if (lit.op == EXP.arrayLiteral)\n     {\n         emplaceExp!(SliceExp)(&ue, lit.loc, lit, ctfeEmplaceExp!IntegerExp(Loc.initial, 0, Type.tsize_t), ArrayLength(Type.tsize_t, lit).copy());\n     }\n-    else if (lit.op == TOK.string_)\n+    else if (lit.op == EXP.string_)\n     {\n         // For strings, we need to introduce another level of indirection\n         emplaceExp!(SliceExp)(&ue, lit.loc, lit, ctfeEmplaceExp!IntegerExp(Loc.initial, 0, Type.tsize_t), ArrayLength(Type.tsize_t, lit).copy());\n@@ -490,7 +490,7 @@ private UnionExp paintTypeOntoLiteralCopy(Type type, Expression lit)\n     {\n         // Can't type paint from struct to struct*; this needs another\n         // level of indirection\n-        if (lit.op == TOK.structLiteral && isPointer(type))\n+        if (lit.op == EXP.structLiteral && isPointer(type))\n             lit.error(\"CTFE internal error: painting `%s`\", type.toChars());\n         ue = copyLiteral(lit);\n     }\n@@ -511,7 +511,7 @@ Expression resolveSlice(Expression e, UnionExp* pue = null)\n     SliceExp se = e.isSliceExp();\n     if (!se)\n         return e;\n-    if (se.e1.op == TOK.null_)\n+    if (se.e1.op == EXP.null_)\n         return se.e1;\n     if (pue)\n     {\n@@ -531,30 +531,30 @@ uinteger_t resolveArrayLength(const Expression e)\n {\n     switch (e.op)\n     {\n-        case TOK.vector:\n+        case EXP.vector:\n             return e.isVectorExp().dim;\n \n-        case TOK.null_:\n+        case EXP.null_:\n             return 0;\n \n-        case TOK.slice:\n+        case EXP.slice:\n         {\n             auto se = cast(SliceExp)e;\n             const ilo = se.lwr.toInteger();\n             const iup = se.upr.toInteger();\n             return iup - ilo;\n         }\n \n-        case TOK.string_:\n+        case EXP.string_:\n             return e.isStringExp().len;\n \n-        case TOK.arrayLiteral:\n+        case EXP.arrayLiteral:\n         {\n             const ale = e.isArrayLiteralExp();\n             return ale.elements ? ale.elements.dim : 0;\n         }\n \n-        case TOK.assocArrayLiteral:\n+        case EXP.assocArrayLiteral:\n         {\n             return e.isAssocArrayLiteralExp().keys.dim;\n         }\n@@ -667,7 +667,7 @@ bool isPointer(Type t)\n // For CTFE only. Returns true if 'e' is true or a non-null pointer.\n bool isTrueBool(Expression e)\n {\n-    return e.isBool(true) || ((e.type.ty == Tpointer || e.type.ty == Tclass) && e.op != TOK.null_);\n+    return e.toBool().hasValue(true) || ((e.type.ty == Tpointer || e.type.ty == Tclass) && e.op != EXP.null_);\n }\n \n /* Is it safe to convert from srcPointee* to destPointee* ?\n@@ -725,20 +725,20 @@ Expression getAggregateFromPointer(Expression e, dinteger_t* ofs)\n         const ex = dve.e1;\n         const v = dve.var.isVarDeclaration();\n         assert(v);\n-        StructLiteralExp se = (ex.op == TOK.classReference)\n+        StructLiteralExp se = (ex.op == EXP.classReference)\n             ? (cast(ClassReferenceExp)ex).value\n             : cast(StructLiteralExp)ex;\n \n         // We can't use getField, because it makes a copy\n-        const i = (ex.op == TOK.classReference)\n+        const i = (ex.op == EXP.classReference)\n             ? (cast(ClassReferenceExp)ex).getFieldIndex(e.type, v.offset)\n             : se.getFieldIndex(e.type, v.offset);\n         e = (*se.elements)[i];\n     }\n     if (auto ie = e.isIndexExp())\n     {\n         // Note that each AA element is part of its own memory block\n-        if ((ie.e1.type.ty == Tarray || ie.e1.type.ty == Tsarray || ie.e1.op == TOK.string_ || ie.e1.op == TOK.arrayLiteral) && ie.e2.op == TOK.int64)\n+        if ((ie.e1.type.ty == Tarray || ie.e1.type.ty == Tsarray || ie.e1.op == EXP.string_ || ie.e1.op == EXP.arrayLiteral) && ie.e2.op == EXP.int64)\n         {\n             *ofs = ie.e2.toInteger();\n             return ie.e1;\n@@ -747,7 +747,7 @@ Expression getAggregateFromPointer(Expression e, dinteger_t* ofs)\n     if (auto se = e.isSliceExp())\n     {\n         if (se && e.type.toBasetype().ty == Tsarray &&\n-           (se.e1.type.ty == Tarray || se.e1.type.ty == Tsarray || se.e1.op == TOK.string_ || se.e1.op == TOK.arrayLiteral) && se.lwr.op == TOK.int64)\n+           (se.e1.type.ty == Tarray || se.e1.type.ty == Tsarray || se.e1.op == EXP.string_ || se.e1.op == EXP.arrayLiteral) && se.lwr.op == EXP.int64)\n         {\n             *ofs = se.lwr.toInteger();\n             return se.e1;\n@@ -773,17 +773,17 @@ bool pointToSameMemoryBlock(Expression agg1, Expression agg2)\n         return true;\n     // For integers cast to pointers, we regard them as non-comparable\n     // unless they are identical. (This may be overly strict).\n-    if (agg1.op == TOK.int64 && agg2.op == TOK.int64 && agg1.toInteger() == agg2.toInteger())\n+    if (agg1.op == EXP.int64 && agg2.op == EXP.int64 && agg1.toInteger() == agg2.toInteger())\n     {\n         return true;\n     }\n     // Note that type painting can occur with VarExp, so we\n     // must compare the variables being pointed to.\n-    if (agg1.op == TOK.variable && agg2.op == TOK.variable && (cast(VarExp)agg1).var == (cast(VarExp)agg2).var)\n+    if (agg1.op == EXP.variable && agg2.op == EXP.variable && (cast(VarExp)agg1).var == (cast(VarExp)agg2).var)\n     {\n         return true;\n     }\n-    if (agg1.op == TOK.symbolOffset && agg2.op == TOK.symbolOffset && (cast(SymOffExp)agg1).var == (cast(SymOffExp)agg2).var)\n+    if (agg1.op == EXP.symbolOffset && agg2.op == EXP.symbolOffset && (cast(SymOffExp)agg1).var == (cast(SymOffExp)agg2).var)\n     {\n         return true;\n     }\n@@ -803,51 +803,51 @@ UnionExp pointerDifference(const ref Loc loc, Type type, Expression e1, Expressi\n         const sz = pointee.size();\n         emplaceExp!(IntegerExp)(&ue, loc, (ofs1 - ofs2) * sz, type);\n     }\n-    else if (agg1.op == TOK.string_ && agg2.op == TOK.string_ &&\n+    else if (agg1.op == EXP.string_ && agg2.op == EXP.string_ &&\n              (cast(StringExp)agg1).peekString().ptr == (cast(StringExp)agg2).peekString().ptr)\n     {\n         Type pointee = (cast(TypePointer)agg1.type).next;\n         const sz = pointee.size();\n         emplaceExp!(IntegerExp)(&ue, loc, (ofs1 - ofs2) * sz, type);\n     }\n-    else if (agg1.op == TOK.symbolOffset && agg2.op == TOK.symbolOffset &&\n+    else if (agg1.op == EXP.symbolOffset && agg2.op == EXP.symbolOffset &&\n              (cast(SymOffExp)agg1).var == (cast(SymOffExp)agg2).var)\n     {\n         emplaceExp!(IntegerExp)(&ue, loc, ofs1 - ofs2, type);\n     }\n     else\n     {\n         error(loc, \"`%s - %s` cannot be interpreted at compile time: cannot subtract pointers to two different memory blocks\", e1.toChars(), e2.toChars());\n-        emplaceExp!(CTFEExp)(&ue, TOK.cantExpression);\n+        emplaceExp!(CTFEExp)(&ue, EXP.cantExpression);\n     }\n     return ue;\n }\n \n // Return eptr op e2, where eptr is a pointer, e2 is an integer,\n-// and op is TOK.add or TOK.min\n-UnionExp pointerArithmetic(const ref Loc loc, TOK op, Type type, Expression eptr, Expression e2)\n+// and op is EXP.add or EXP.min\n+UnionExp pointerArithmetic(const ref Loc loc, EXP op, Type type, Expression eptr, Expression e2)\n {\n     UnionExp ue;\n     if (eptr.type.nextOf().ty == Tvoid)\n     {\n         error(loc, \"cannot perform arithmetic on `void*` pointers at compile time\");\n     Lcant:\n-        emplaceExp!(CTFEExp)(&ue, TOK.cantExpression);\n+        emplaceExp!(CTFEExp)(&ue, EXP.cantExpression);\n         return ue;\n     }\n-    if (eptr.op == TOK.address)\n+    if (eptr.op == EXP.address)\n         eptr = (cast(AddrExp)eptr).e1;\n     dinteger_t ofs1;\n     Expression agg1 = getAggregateFromPointer(eptr, &ofs1);\n-    if (agg1.op == TOK.symbolOffset)\n+    if (agg1.op == EXP.symbolOffset)\n     {\n         if ((cast(SymOffExp)agg1).var.type.ty != Tsarray)\n         {\n             error(loc, \"cannot perform pointer arithmetic on arrays of unknown length at compile time\");\n             goto Lcant;\n         }\n     }\n-    else if (agg1.op != TOK.string_ && agg1.op != TOK.arrayLiteral)\n+    else if (agg1.op != EXP.string_ && agg1.op != EXP.arrayLiteral)\n     {\n         error(loc, \"cannot perform pointer arithmetic on non-arrays at compile time\");\n         goto Lcant;\n@@ -857,7 +857,7 @@ UnionExp pointerArithmetic(const ref Loc loc, TOK op, Type type, Expression eptr\n     dinteger_t sz = pointee.size();\n     sinteger_t indx;\n     dinteger_t len;\n-    if (agg1.op == TOK.symbolOffset)\n+    if (agg1.op == EXP.symbolOffset)\n     {\n         indx = ofs1 / sz;\n         len = (cast(TypeSArray)(cast(SymOffExp)agg1).var.type).dim.toInteger();\n@@ -869,9 +869,9 @@ UnionExp pointerArithmetic(const ref Loc loc, TOK op, Type type, Expression eptr\n         indx = ofs1;\n         len = dollar.toInteger();\n     }\n-    if (op == TOK.add || op == TOK.addAssign || op == TOK.plusPlus)\n+    if (op == EXP.add || op == EXP.addAssign || op == EXP.plusPlus)\n         indx += ofs2 / sz;\n-    else if (op == TOK.min || op == TOK.minAssign || op == TOK.minusMinus)\n+    else if (op == EXP.min || op == EXP.minAssign || op == EXP.minusMinus)\n         indx -= ofs2 / sz;\n     else\n     {\n@@ -883,14 +883,14 @@ UnionExp pointerArithmetic(const ref Loc loc, TOK op, Type type, Expression eptr\n         error(loc, \"cannot assign pointer to index %lld inside memory block `[0..%lld]`\", indx, len);\n         goto Lcant;\n     }\n-    if (agg1.op == TOK.symbolOffset)\n+    if (agg1.op == EXP.symbolOffset)\n     {\n         emplaceExp!(SymOffExp)(&ue, loc, (cast(SymOffExp)agg1).var, indx * sz);\n         SymOffExp se = cast(SymOffExp)ue.exp();\n         se.type = type;\n         return ue;\n     }\n-    if (agg1.op != TOK.arrayLiteral && agg1.op != TOK.string_)\n+    if (agg1.op != EXP.arrayLiteral && agg1.op != EXP.string_)\n     {\n         error(loc, \"CTFE internal error: pointer arithmetic `%s`\", agg1.toChars());\n         goto Lcant;\n@@ -918,61 +918,61 @@ UnionExp pointerArithmetic(const ref Loc loc, TOK op, Type type, Expression eptr\n \n // Return 1 if true, 0 if false\n // -1 if comparison is illegal because they point to non-comparable memory blocks\n-int comparePointers(TOK op, Expression agg1, dinteger_t ofs1, Expression agg2, dinteger_t ofs2)\n+int comparePointers(EXP op, Expression agg1, dinteger_t ofs1, Expression agg2, dinteger_t ofs2)\n {\n     if (pointToSameMemoryBlock(agg1, agg2))\n     {\n         int n;\n         switch (op)\n         {\n-        case TOK.lessThan:\n+        case EXP.lessThan:\n             n = (ofs1 < ofs2);\n             break;\n-        case TOK.lessOrEqual:\n+        case EXP.lessOrEqual:\n             n = (ofs1 <= ofs2);\n             break;\n-        case TOK.greaterThan:\n+        case EXP.greaterThan:\n             n = (ofs1 > ofs2);\n             break;\n-        case TOK.greaterOrEqual:\n+        case EXP.greaterOrEqual:\n             n = (ofs1 >= ofs2);\n             break;\n-        case TOK.identity:\n-        case TOK.equal:\n+        case EXP.identity:\n+        case EXP.equal:\n             n = (ofs1 == ofs2);\n             break;\n-        case TOK.notIdentity:\n-        case TOK.notEqual:\n+        case EXP.notIdentity:\n+        case EXP.notEqual:\n             n = (ofs1 != ofs2);\n             break;\n         default:\n             assert(0);\n         }\n         return n;\n     }\n-    const null1 = (agg1.op == TOK.null_);\n-    const null2 = (agg2.op == TOK.null_);\n+    const null1 = (agg1.op == EXP.null_);\n+    const null2 = (agg2.op == EXP.null_);\n     int cmp;\n     if (null1 || null2)\n     {\n         switch (op)\n         {\n-        case TOK.lessThan:\n+        case EXP.lessThan:\n             cmp = null1 && !null2;\n             break;\n-        case TOK.greaterThan:\n+        case EXP.greaterThan:\n             cmp = !null1 && null2;\n             break;\n-        case TOK.lessOrEqual:\n+        case EXP.lessOrEqual:\n             cmp = null1;\n             break;\n-        case TOK.greaterOrEqual:\n+        case EXP.greaterOrEqual:\n             cmp = null2;\n             break;\n-        case TOK.identity:\n-        case TOK.equal:\n-        case TOK.notIdentity: // 'cmp' gets inverted below\n-        case TOK.notEqual:\n+        case EXP.identity:\n+        case EXP.equal:\n+        case EXP.notIdentity: // 'cmp' gets inverted below\n+        case EXP.notEqual:\n             cmp = (null1 == null2);\n             break;\n         default:\n@@ -983,17 +983,17 @@ int comparePointers(TOK op, Expression agg1, dinteger_t ofs1, Expression agg2, d\n     {\n         switch (op)\n         {\n-        case TOK.identity:\n-        case TOK.equal:\n-        case TOK.notIdentity: // 'cmp' gets inverted below\n-        case TOK.notEqual:\n+        case EXP.identity:\n+        case EXP.equal:\n+        case EXP.notIdentity: // 'cmp' gets inverted below\n+        case EXP.notEqual:\n             cmp = 0;\n             break;\n         default:\n             return -1; // memory blocks are different\n         }\n     }\n-    if (op == TOK.notIdentity || op == TOK.notEqual)\n+    if (op == EXP.notIdentity || op == EXP.notEqual)\n         cmp ^= 1;\n     return cmp;\n }\n@@ -1019,35 +1019,35 @@ Expression paintFloatInt(UnionExp* pue, Expression fromVal, Type to)\n /// with >,is, ==, etc, using ctfeCmp, ctfeEqual, ctfeIdentity\n bool isCtfeComparable(Expression e)\n {\n-    if (e.op == TOK.slice)\n+    if (e.op == EXP.slice)\n         e = (cast(SliceExp)e).e1;\n     if (e.isConst() != 1)\n     {\n-        if (e.op == TOK.null_ || e.op == TOK.string_ || e.op == TOK.function_ || e.op == TOK.delegate_ || e.op == TOK.arrayLiteral || e.op == TOK.structLiteral || e.op == TOK.assocArrayLiteral || e.op == TOK.classReference)\n+        if (e.op == EXP.null_ || e.op == EXP.string_ || e.op == EXP.function_ || e.op == EXP.delegate_ || e.op == EXP.arrayLiteral || e.op == EXP.structLiteral || e.op == EXP.assocArrayLiteral || e.op == EXP.classReference)\n         {\n             return true;\n         }\n         // https://issues.dlang.org/show_bug.cgi?id=14123\n         // TypeInfo object is comparable in CTFE\n-        if (e.op == TOK.typeid_)\n+        if (e.op == EXP.typeid_)\n             return true;\n         return false;\n     }\n     return true;\n }\n \n-/// Map TOK comparison ops\n-private bool numCmp(N)(TOK op, N n1, N n2)\n+/// Map EXP comparison ops\n+private bool numCmp(N)(EXP op, N n1, N n2)\n {\n     switch (op)\n     {\n-    case TOK.lessThan:\n+    case EXP.lessThan:\n         return n1 < n2;\n-    case TOK.lessOrEqual:\n+    case EXP.lessOrEqual:\n         return n1 <= n2;\n-    case TOK.greaterThan:\n+    case EXP.greaterThan:\n         return n1 > n2;\n-    case TOK.greaterOrEqual:\n+    case EXP.greaterOrEqual:\n         return n1 >= n2;\n \n     default:\n@@ -1056,35 +1056,35 @@ private bool numCmp(N)(TOK op, N n1, N n2)\n }\n \n /// Returns cmp OP 0; where OP is ==, !=, <, >=, etc. Result is 0 or 1\n-bool specificCmp(TOK op, int rawCmp)\n+bool specificCmp(EXP op, int rawCmp)\n {\n     return numCmp!int(op, rawCmp, 0);\n }\n \n /// Returns e1 OP e2; where OP is ==, !=, <, >=, etc. Result is 0 or 1\n-bool intUnsignedCmp(TOK op, dinteger_t n1, dinteger_t n2)\n+bool intUnsignedCmp(EXP op, dinteger_t n1, dinteger_t n2)\n {\n     return numCmp!dinteger_t(op, n1, n2);\n }\n \n /// Returns e1 OP e2; where OP is ==, !=, <, >=, etc. Result is 0 or 1\n-bool intSignedCmp(TOK op, sinteger_t n1, sinteger_t n2)\n+bool intSignedCmp(EXP op, sinteger_t n1, sinteger_t n2)\n {\n     return numCmp!sinteger_t(op, n1, n2);\n }\n \n /// Returns e1 OP e2; where OP is ==, !=, <, >=, etc. Result is 0 or 1\n-bool realCmp(TOK op, real_t r1, real_t r2)\n+bool realCmp(EXP op, real_t r1, real_t r2)\n {\n     // Don't rely on compiler, handle NAN arguments separately\n     if (CTFloat.isNaN(r1) || CTFloat.isNaN(r2)) // if unordered\n     {\n         switch (op)\n         {\n-        case TOK.lessThan:\n-        case TOK.lessOrEqual:\n-        case TOK.greaterThan:\n-        case TOK.greaterOrEqual:\n+        case EXP.lessThan:\n+        case EXP.lessOrEqual:\n+        case EXP.greaterThan:\n+        case EXP.greaterOrEqual:\n             return false;\n \n         default:\n@@ -1128,7 +1128,7 @@ private int ctfeCmpArrays(const ref Loc loc, Expression e1, Expression e2, uinte\n     auto se2 = x2.isStringExp();\n     auto ae2 = x2.isArrayLiteralExp();\n \n-    // Now both must be either TOK.arrayLiteral or TOK.string_\n+    // Now both must be either EXP.arrayLiteral or EXP.string_\n     if (se1 && se2)\n         return sliceCmpStringWithString(se1, se2, cast(size_t)lo1, cast(size_t)lo2, cast(size_t)len);\n     if (se1 && ae2)\n@@ -1171,13 +1171,13 @@ private FuncDeclaration funcptrOf(Expression e)\n         return de.func;\n     if (auto fe = e.isFuncExp())\n         return fe.fd;\n-    assert(e.op == TOK.null_);\n+    assert(e.op == EXP.null_);\n     return null;\n }\n \n private bool isArray(const Expression e)\n {\n-    return e.op == TOK.arrayLiteral || e.op == TOK.string_ || e.op == TOK.slice || e.op == TOK.null_;\n+    return e.op == EXP.arrayLiteral || e.op == EXP.string_ || e.op == EXP.slice || e.op == EXP.null_;\n }\n \n /*****\n@@ -1192,14 +1192,14 @@ private bool isArray(const Expression e)\n  */\n private int ctfeRawCmp(const ref Loc loc, Expression e1, Expression e2, bool identity = false)\n {\n-    if (e1.op == TOK.classReference || e2.op == TOK.classReference)\n+    if (e1.op == EXP.classReference || e2.op == EXP.classReference)\n     {\n-        if (e1.op == TOK.classReference && e2.op == TOK.classReference &&\n+        if (e1.op == EXP.classReference && e2.op == EXP.classReference &&\n             (cast(ClassReferenceExp)e1).value == (cast(ClassReferenceExp)e2).value)\n             return 0;\n         return 1;\n     }\n-    if (e1.op == TOK.typeid_ && e2.op == TOK.typeid_)\n+    if (e1.op == EXP.typeid_ && e2.op == EXP.typeid_)\n     {\n         // printf(\"e1: %s\\n\", e1.toChars());\n         // printf(\"e2: %s\\n\", e2.toChars());\n@@ -1210,15 +1210,15 @@ private int ctfeRawCmp(const ref Loc loc, Expression e1, Expression e2, bool ide\n         return t1 != t2;\n     }\n     // null == null, regardless of type\n-    if (e1.op == TOK.null_ && e2.op == TOK.null_)\n+    if (e1.op == EXP.null_ && e2.op == EXP.null_)\n         return 0;\n     if (e1.type.ty == Tpointer && e2.type.ty == Tpointer)\n     {\n         // Can only be an equality test.\n         dinteger_t ofs1, ofs2;\n         Expression agg1 = getAggregateFromPointer(e1, &ofs1);\n         Expression agg2 = getAggregateFromPointer(e2, &ofs2);\n-        if ((agg1 == agg2) || (agg1.op == TOK.variable && agg2.op == TOK.variable && (cast(VarExp)agg1).var == (cast(VarExp)agg2).var))\n+        if ((agg1 == agg2) || (agg1.op == EXP.variable && agg2.op == EXP.variable && (cast(VarExp)agg1).var == (cast(VarExp)agg2).var))\n         {\n             if (ofs1 == ofs2)\n                 return 0;\n@@ -1232,17 +1232,17 @@ private int ctfeRawCmp(const ref Loc loc, Expression e1, Expression e2, bool ide\n             return 1;\n         // If both are delegate literals, assume they have the\n         // same closure pointer. TODO: We don't support closures yet!\n-        if (e1.op == TOK.function_ && e2.op == TOK.function_)\n+        if (e1.op == EXP.function_ && e2.op == EXP.function_)\n             return 0;\n-        assert(e1.op == TOK.delegate_ && e2.op == TOK.delegate_);\n+        assert(e1.op == EXP.delegate_ && e2.op == EXP.delegate_);\n         // Same .funcptr. Do they have the same .ptr?\n         Expression ptr1 = (cast(DelegateExp)e1).e1;\n         Expression ptr2 = (cast(DelegateExp)e2).e1;\n         dinteger_t ofs1, ofs2;\n         Expression agg1 = getAggregateFromPointer(ptr1, &ofs1);\n         Expression agg2 = getAggregateFromPointer(ptr2, &ofs2);\n-        // If they are TOK.variable, it means they are FuncDeclarations\n-        if ((agg1 == agg2 && ofs1 == ofs2) || (agg1.op == TOK.variable && agg2.op == TOK.variable && (cast(VarExp)agg1).var == (cast(VarExp)agg2).var))\n+        // If they are EXP.variable, it means they are FuncDeclarations\n+        if ((agg1 == agg2 && ofs1 == ofs2) || (agg1.op == EXP.variable && agg2.op == EXP.variable && (cast(VarExp)agg1).var == (cast(VarExp)agg2).var))\n         {\n             return 0;\n         }\n@@ -1293,7 +1293,7 @@ private int ctfeRawCmp(const ref Loc loc, Expression e1, Expression e2, bool ide\n         }\n         return c1 != c2;\n     }\n-    if (e1.op == TOK.structLiteral && e2.op == TOK.structLiteral)\n+    if (e1.op == EXP.structLiteral && e2.op == EXP.structLiteral)\n     {\n         StructLiteralExp es1 = cast(StructLiteralExp)e1;\n         StructLiteralExp es2 = cast(StructLiteralExp)e2;\n@@ -1314,7 +1314,7 @@ private int ctfeRawCmp(const ref Loc loc, Expression e1, Expression e2, bool ide\n                 Expression ee2 = (*es2.elements)[i];\n \n                 // https://issues.dlang.org/show_bug.cgi?id=16284\n-                if (ee1.op == TOK.void_ && ee2.op == TOK.void_) // if both are VoidInitExp\n+                if (ee1.op == EXP.void_ && ee2.op == EXP.void_) // if both are VoidInitExp\n                     continue;\n \n                 if (ee1 == ee2)\n@@ -1328,7 +1328,7 @@ private int ctfeRawCmp(const ref Loc loc, Expression e1, Expression e2, bool ide\n             return 0; // All elements are equal\n         }\n     }\n-    if (e1.op == TOK.assocArrayLiteral && e2.op == TOK.assocArrayLiteral)\n+    if (e1.op == EXP.assocArrayLiteral && e2.op == EXP.assocArrayLiteral)\n     {\n         AssocArrayLiteralExp es1 = cast(AssocArrayLiteralExp)e1;\n         AssocArrayLiteralExp es2 = cast(AssocArrayLiteralExp)e2;\n@@ -1367,27 +1367,27 @@ private int ctfeRawCmp(const ref Loc loc, Expression e1, Expression e2, bool ide\n }\n \n /// Evaluate ==, !=.  Resolves slices before comparing. Returns 0 or 1\n-bool ctfeEqual(const ref Loc loc, TOK op, Expression e1, Expression e2)\n+bool ctfeEqual(const ref Loc loc, EXP op, Expression e1, Expression e2)\n {\n-    return !ctfeRawCmp(loc, e1, e2) ^ (op == TOK.notEqual);\n+    return !ctfeRawCmp(loc, e1, e2) ^ (op == EXP.notEqual);\n }\n \n /// Evaluate is, !is.  Resolves slices before comparing. Returns 0 or 1\n-bool ctfeIdentity(const ref Loc loc, TOK op, Expression e1, Expression e2)\n+bool ctfeIdentity(const ref Loc loc, EXP op, Expression e1, Expression e2)\n {\n     //printf(\"ctfeIdentity %s %s\\n\", e1.toChars(), e2.toChars());\n-    //printf(\"ctfeIdentity op = '%s', e1 = %s %s, e2 = %s %s\\n\", Token::toChars(op),\n-    //    Token::toChars(e1.op), e1.toChars(), Token::toChars(e2.op), e1.toChars());\n+    //printf(\"ctfeIdentity op = '%s', e1 = %s %s, e2 = %s %s\\n\", EXPtoString(op).ptr,\n+    //    EXPtoString(e1.op).ptr, e1.toChars(), EXPtoString(e2.op).ptr, e1.toChars());\n     bool cmp;\n-    if (e1.op == TOK.null_)\n+    if (e1.op == EXP.null_)\n     {\n-        cmp = (e2.op == TOK.null_);\n+        cmp = (e2.op == EXP.null_);\n     }\n-    else if (e2.op == TOK.null_)\n+    else if (e2.op == EXP.null_)\n     {\n         cmp = false;\n     }\n-    else if (e1.op == TOK.symbolOffset && e2.op == TOK.symbolOffset)\n+    else if (e1.op == EXP.symbolOffset && e2.op == EXP.symbolOffset)\n     {\n         SymOffExp es1 = cast(SymOffExp)e1;\n         SymOffExp es2 = cast(SymOffExp)e2;\n@@ -1407,13 +1407,13 @@ bool ctfeIdentity(const ref Loc loc, TOK op, Expression e1, Expression e2)\n     {\n         cmp = !ctfeRawCmp(loc, e1, e2, true);\n     }\n-    if (op == TOK.notIdentity || op == TOK.notEqual)\n+    if (op == EXP.notIdentity || op == EXP.notEqual)\n         cmp ^= true;\n     return cmp;\n }\n \n /// Evaluate >,<=, etc. Resolves slices before comparing. Returns 0 or 1\n-bool ctfeCmp(const ref Loc loc, TOK op, Expression e1, Expression e2)\n+bool ctfeCmp(const ref Loc loc, EXP op, Expression e1, Expression e2)\n {\n     Type t1 = e1.type.toBasetype();\n     Type t2 = e2.type.toBasetype();\n@@ -1435,7 +1435,7 @@ UnionExp ctfeCat(const ref Loc loc, Type type, Expression e1, Expression e2)\n     Type t1 = e1.type.toBasetype();\n     Type t2 = e2.type.toBasetype();\n     UnionExp ue;\n-    if (e2.op == TOK.string_ && e1.op == TOK.arrayLiteral && t1.nextOf().isintegral())\n+    if (e2.op == EXP.string_ && e1.op == EXP.arrayLiteral && t1.nextOf().isintegral())\n     {\n         // [chars] ~ string => string (only valid for CTFE)\n         StringExp es1 = cast(StringExp)e2;\n@@ -1448,9 +1448,9 @@ UnionExp ctfeCat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         foreach (size_t i; 0 .. es2.elements.dim)\n         {\n             Expression es2e = (*es2.elements)[i];\n-            if (es2e.op != TOK.int64)\n+            if (es2e.op != EXP.int64)\n             {\n-                emplaceExp!(CTFEExp)(&ue, TOK.cantExpression);\n+                emplaceExp!(CTFEExp)(&ue, EXP.cantExpression);\n                 return ue;\n             }\n             dinteger_t v = es2e.toInteger();\n@@ -1464,7 +1464,7 @@ UnionExp ctfeCat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         es.type = type;\n         return ue;\n     }\n-    if (e1.op == TOK.string_ && e2.op == TOK.arrayLiteral && t2.nextOf().isintegral())\n+    if (e1.op == EXP.string_ && e2.op == EXP.arrayLiteral && t2.nextOf().isintegral())\n     {\n         // string ~ [chars] => string (only valid for CTFE)\n         // Concatenate the strings\n@@ -1478,9 +1478,9 @@ UnionExp ctfeCat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         foreach (size_t i; 0 .. es2.elements.dim)\n         {\n             Expression es2e = (*es2.elements)[i];\n-            if (es2e.op != TOK.int64)\n+            if (es2e.op != EXP.int64)\n             {\n-                emplaceExp!(CTFEExp)(&ue, TOK.cantExpression);\n+                emplaceExp!(CTFEExp)(&ue, EXP.cantExpression);\n                 return ue;\n             }\n             const v = es2e.toInteger();\n@@ -1495,7 +1495,7 @@ UnionExp ctfeCat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         es.type = type;\n         return ue;\n     }\n-    if (e1.op == TOK.arrayLiteral && e2.op == TOK.arrayLiteral && t1.nextOf().equals(t2.nextOf()))\n+    if (e1.op == EXP.arrayLiteral && e2.op == EXP.arrayLiteral && t1.nextOf().equals(t2.nextOf()))\n     {\n         //  [ e1 ] ~ [ e2 ] ---> [ e1, e2 ]\n         ArrayLiteralExp es1 = cast(ArrayLiteralExp)e1;\n@@ -1505,13 +1505,13 @@ UnionExp ctfeCat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         es1.elements.insert(es1.elements.dim, copyLiteralArray(es2.elements));\n         return ue;\n     }\n-    if (e1.op == TOK.arrayLiteral && e2.op == TOK.null_ && t1.nextOf().equals(t2.nextOf()))\n+    if (e1.op == EXP.arrayLiteral && e2.op == EXP.null_ && t1.nextOf().equals(t2.nextOf()))\n     {\n         //  [ e1 ] ~ null ----> [ e1 ].dup\n         ue = paintTypeOntoLiteralCopy(type, copyLiteral(e1).copy());\n         return ue;\n     }\n-    if (e1.op == TOK.null_ && e2.op == TOK.arrayLiteral && t1.nextOf().equals(t2.nextOf()))\n+    if (e1.op == EXP.null_ && e2.op == EXP.arrayLiteral && t1.nextOf().equals(t2.nextOf()))\n     {\n         //  null ~ [ e2 ] ----> [ e2 ].dup\n         ue = paintTypeOntoLiteralCopy(type, copyLiteral(e2).copy());\n@@ -1532,7 +1532,7 @@ Expression findKeyInAA(const ref Loc loc, AssocArrayLiteralExp ae, Expression e2\n     {\n         --i;\n         Expression ekey = (*ae.keys)[i];\n-        const int eq = ctfeEqual(loc, TOK.equal, ekey, e2);\n+        const int eq = ctfeEqual(loc, EXP.equal, ekey, e2);\n         if (eq)\n         {\n             return (*ae.values)[i];\n@@ -1581,10 +1581,10 @@ Expression ctfeCast(UnionExp* pue, const ref Loc loc, Type type, Type to, Expres\n         return paintTypeOntoLiteral(pue, to, e);\n     }\n \n-    if (e.op == TOK.null_)\n+    if (e.op == EXP.null_)\n         return paint();\n \n-    if (e.op == TOK.classReference)\n+    if (e.op == EXP.classReference)\n     {\n         // Disallow reinterpreting class casts. Do this by ensuring that\n         // the original class can implicitly convert to the target class\n@@ -1603,7 +1603,7 @@ Expression ctfeCast(UnionExp* pue, const ref Loc loc, Type type, Type to, Expres\n         return paint();\n \n     // Allow casting away const for struct literals\n-    if (e.op == TOK.structLiteral && e.type.toBasetype().castMod(0) == to.toBasetype().castMod(0))\n+    if (e.op == EXP.structLiteral && e.type.toBasetype().castMod(0) == to.toBasetype().castMod(0))\n         return paint();\n \n     Expression r;\n@@ -1647,14 +1647,14 @@ Expression ctfeCast(UnionExp* pue, const ref Loc loc, Type type, Type to, Expres\n  */\n void assignInPlace(Expression dest, Expression src)\n {\n-    if (!(dest.op == TOK.structLiteral || dest.op == TOK.arrayLiteral || dest.op == TOK.string_))\n+    if (!(dest.op == EXP.structLiteral || dest.op == EXP.arrayLiteral || dest.op == EXP.string_))\n     {\n         printf(\"invalid op %d %d\\n\", src.op, dest.op);\n         assert(0);\n     }\n     Expressions* oldelems;\n     Expressions* newelems;\n-    if (dest.op == TOK.structLiteral)\n+    if (dest.op == EXP.structLiteral)\n     {\n         assert(dest.op == src.op);\n         oldelems = (cast(StructLiteralExp)dest).elements;\n@@ -1666,22 +1666,22 @@ void assignInPlace(Expression dest, Expression src)\n             foreach (_; 0 .. newelems.dim - oldelems.dim)\n                 oldelems.push(null);\n     }\n-    else if (dest.op == TOK.arrayLiteral && src.op == TOK.arrayLiteral)\n+    else if (dest.op == EXP.arrayLiteral && src.op == EXP.arrayLiteral)\n     {\n         oldelems = (cast(ArrayLiteralExp)dest).elements;\n         newelems = (cast(ArrayLiteralExp)src).elements;\n     }\n-    else if (dest.op == TOK.string_ && src.op == TOK.string_)\n+    else if (dest.op == EXP.string_ && src.op == EXP.string_)\n     {\n         sliceAssignStringFromString(cast(StringExp)dest, cast(StringExp)src, 0);\n         return;\n     }\n-    else if (dest.op == TOK.arrayLiteral && src.op == TOK.string_)\n+    else if (dest.op == EXP.arrayLiteral && src.op == EXP.string_)\n     {\n         sliceAssignArrayLiteralFromString(cast(ArrayLiteralExp)dest, cast(StringExp)src, 0);\n         return;\n     }\n-    else if (src.op == TOK.arrayLiteral && dest.op == TOK.string_)\n+    else if (src.op == EXP.arrayLiteral && dest.op == EXP.string_)\n     {\n         sliceAssignStringFromArrayLiteral(cast(StringExp)dest, cast(ArrayLiteralExp)src, 0);\n         return;\n@@ -1696,12 +1696,12 @@ void assignInPlace(Expression dest, Expression src)\n     {\n         Expression e = (*newelems)[i];\n         Expression o = (*oldelems)[i];\n-        if (e.op == TOK.structLiteral)\n+        if (e.op == EXP.structLiteral)\n         {\n             assert(o.op == e.op);\n             assignInPlace(o, e);\n         }\n-        else if (e.type.ty == Tsarray && e.op != TOK.void_ && o.type.ty == Tsarray)\n+        else if (e.type.ty == Tsarray && e.op != EXP.void_ && o.type.ty == Tsarray)\n         {\n             assignInPlace(o, e);\n         }\n@@ -1724,7 +1724,7 @@ Expression assignAssocArrayElement(const ref Loc loc, AssocArrayLiteralExp aae,\n     {\n         j--;\n         Expression ekey = (*aae.keys)[j];\n-        int eq = ctfeEqual(loc, TOK.equal, ekey, index);\n+        int eq = ctfeEqual(loc, EXP.equal, ekey, index);\n         if (eq)\n         {\n             (*valuesx)[j] = newval;\n@@ -1752,13 +1752,13 @@ UnionExp changeArrayLiteralLength(const ref Loc loc, TypeArray arrayType, Expres\n     auto elements = new Expressions(newlen);\n     // Resolve slices\n     size_t indxlo = 0;\n-    if (oldval.op == TOK.slice)\n+    if (oldval.op == EXP.slice)\n     {\n         indxlo = cast(size_t)(cast(SliceExp)oldval).lwr.toInteger();\n         oldval = (cast(SliceExp)oldval).e1;\n     }\n     size_t copylen = oldlen < newlen ? oldlen : newlen;\n-    if (oldval.op == TOK.string_)\n+    if (oldval.op == EXP.string_)\n     {\n         StringExp oldse = cast(StringExp)oldval;\n         void* s = mem.xcalloc(newlen + 1, oldse.sz);\n@@ -1793,7 +1793,7 @@ UnionExp changeArrayLiteralLength(const ref Loc loc, TypeArray arrayType, Expres\n     {\n         if (oldlen != 0)\n         {\n-            assert(oldval.op == TOK.arrayLiteral);\n+            assert(oldval.op == EXP.arrayLiteral);\n             ArrayLiteralExp ae = cast(ArrayLiteralExp)oldval;\n             foreach (size_t i; 0 .. copylen)\n                 (*elements)[i] = (*ae.elements)[indxlo + i];\n@@ -1825,89 +1825,89 @@ bool isCtfeValueValid(Expression newval)\n     Type tb = newval.type.toBasetype();\n     switch (newval.op)\n     {\n-        case TOK.int64:\n-        case TOK.float64:\n-        case TOK.char_:\n-        case TOK.complex80:\n+        case EXP.int64:\n+        case EXP.float64:\n+        case EXP.char_:\n+        case EXP.complex80:\n             return tb.isscalar();\n \n-        case TOK.null_:\n+        case EXP.null_:\n             return tb.ty == Tnull    ||\n                    tb.ty == Tpointer ||\n                    tb.ty == Tarray   ||\n                    tb.ty == Taarray  ||\n                    tb.ty == Tclass   ||\n                    tb.ty == Tdelegate;\n \n-        case TOK.string_:\n+        case EXP.string_:\n             return true; // CTFE would directly use the StringExp in AST.\n \n-        case TOK.arrayLiteral:\n+        case EXP.arrayLiteral:\n             return true; //((ArrayLiteralExp *)newval)->ownedByCtfe;\n \n-        case TOK.assocArrayLiteral:\n+        case EXP.assocArrayLiteral:\n             return true; //((AssocArrayLiteralExp *)newval)->ownedByCtfe;\n \n-        case TOK.structLiteral:\n+        case EXP.structLiteral:\n             return true; //((StructLiteralExp *)newval)->ownedByCtfe;\n \n-        case TOK.classReference:\n+        case EXP.classReference:\n             return true;\n \n-        case TOK.type:\n+        case EXP.type:\n             return true;\n \n-        case TOK.vector:\n+        case EXP.vector:\n             return true; // vector literal\n \n-        case TOK.function_:\n+        case EXP.function_:\n             return true; // function literal or delegate literal\n \n-        case TOK.delegate_:\n+        case EXP.delegate_:\n         {\n             // &struct.func or &clasinst.func\n             // &nestedfunc\n             Expression ethis = (cast(DelegateExp)newval).e1;\n-            return (ethis.op == TOK.structLiteral || ethis.op == TOK.classReference || ethis.op == TOK.variable && (cast(VarExp)ethis).var == (cast(DelegateExp)newval).func);\n+            return (ethis.op == EXP.structLiteral || ethis.op == EXP.classReference || ethis.op == EXP.variable && (cast(VarExp)ethis).var == (cast(DelegateExp)newval).func);\n         }\n \n-        case TOK.symbolOffset:\n+        case EXP.symbolOffset:\n         {\n             // function pointer, or pointer to static variable\n             Declaration d = (cast(SymOffExp)newval).var;\n             return d.isFuncDeclaration() || d.isDataseg();\n         }\n \n-        case TOK.typeid_:\n+        case EXP.typeid_:\n         {\n             // always valid\n             return true;\n         }\n \n-        case TOK.address:\n+        case EXP.address:\n         {\n             // e1 should be a CTFE reference\n             Expression e1 = (cast(AddrExp)newval).e1;\n             return tb.ty == Tpointer &&\n             (\n-                (e1.op == TOK.structLiteral || e1.op == TOK.arrayLiteral) && isCtfeValueValid(e1) ||\n-                 e1.op == TOK.variable ||\n-                 e1.op == TOK.dotVariable && isCtfeReferenceValid(e1) ||\n-                 e1.op == TOK.index && isCtfeReferenceValid(e1) ||\n-                 e1.op == TOK.slice && e1.type.toBasetype().ty == Tsarray\n+                (e1.op == EXP.structLiteral || e1.op == EXP.arrayLiteral) && isCtfeValueValid(e1) ||\n+                 e1.op == EXP.variable ||\n+                 e1.op == EXP.dotVariable && isCtfeReferenceValid(e1) ||\n+                 e1.op == EXP.index && isCtfeReferenceValid(e1) ||\n+                 e1.op == EXP.slice && e1.type.toBasetype().ty == Tsarray\n             );\n         }\n \n-        case TOK.slice:\n+        case EXP.slice:\n         {\n             // e1 should be an array aggregate\n             const SliceExp se = cast(SliceExp)newval;\n-            assert(se.lwr && se.lwr.op == TOK.int64);\n-            assert(se.upr && se.upr.op == TOK.int64);\n-            return (tb.ty == Tarray || tb.ty == Tsarray) && (se.e1.op == TOK.string_ || se.e1.op == TOK.arrayLiteral);\n+            assert(se.lwr && se.lwr.op == EXP.int64);\n+            assert(se.upr && se.upr.op == EXP.int64);\n+            return (tb.ty == Tarray || tb.ty == Tsarray) && (se.e1.op == EXP.string_ || se.e1.op == EXP.arrayLiteral);\n         }\n \n-        case TOK.void_:\n+        case EXP.void_:\n             return true; // uninitialized value\n \n         default:\n@@ -1920,27 +1920,27 @@ bool isCtfeReferenceValid(Expression newval)\n {\n     switch (newval.op)\n     {\n-        case TOK.this_:\n+        case EXP.this_:\n             return true;\n \n-        case TOK.variable:\n+        case EXP.variable:\n         {\n             const VarDeclaration v = (cast(VarExp)newval).var.isVarDeclaration();\n             assert(v);\n             // Must not be a reference to a reference\n             return true;\n         }\n \n-        case TOK.index:\n+        case EXP.index:\n         {\n             const Expression eagg = (cast(IndexExp)newval).e1;\n-            return eagg.op == TOK.string_ || eagg.op == TOK.arrayLiteral || eagg.op == TOK.assocArrayLiteral;\n+            return eagg.op == EXP.string_ || eagg.op == EXP.arrayLiteral || eagg.op == EXP.assocArrayLiteral;\n         }\n \n-        case TOK.dotVariable:\n+        case EXP.dotVariable:\n         {\n             Expression eagg = (cast(DotVarExp)newval).e1;\n-            return (eagg.op == TOK.structLiteral || eagg.op == TOK.classReference) && isCtfeValueValid(eagg);\n+            return (eagg.op == EXP.structLiteral || eagg.op == EXP.classReference) && isCtfeValueValid(eagg);\n         }\n \n         default:\n@@ -1959,44 +1959,44 @@ void showCtfeExpr(Expression e, int level = 0)\n     // We need the struct definition to detect block assignment\n     StructDeclaration sd = null;\n     ClassDeclaration cd = null;\n-    if (e.op == TOK.structLiteral)\n+    if (e.op == EXP.structLiteral)\n     {\n         elements = (cast(StructLiteralExp)e).elements;\n         sd = (cast(StructLiteralExp)e).sd;\n         printf(\"STRUCT type = %s %p:\\n\", e.type.toChars(), e);\n     }\n-    else if (e.op == TOK.classReference)\n+    else if (e.op == EXP.classReference)\n     {\n         elements = (cast(ClassReferenceExp)e).value.elements;\n         cd = (cast(ClassReferenceExp)e).originalClass();\n         printf(\"CLASS type = %s %p:\\n\", e.type.toChars(), (cast(ClassReferenceExp)e).value);\n     }\n-    else if (e.op == TOK.arrayLiteral)\n+    else if (e.op == EXP.arrayLiteral)\n     {\n         elements = (cast(ArrayLiteralExp)e).elements;\n         printf(\"ARRAY LITERAL type=%s %p:\\n\", e.type.toChars(), e);\n     }\n-    else if (e.op == TOK.assocArrayLiteral)\n+    else if (e.op == EXP.assocArrayLiteral)\n     {\n         printf(\"AA LITERAL type=%s %p:\\n\", e.type.toChars(), e);\n     }\n-    else if (e.op == TOK.string_)\n+    else if (e.op == EXP.string_)\n     {\n         printf(\"STRING %s %p\\n\", e.toChars(), e.isStringExp.peekString.ptr);\n     }\n-    else if (e.op == TOK.slice)\n+    else if (e.op == EXP.slice)\n     {\n         printf(\"SLICE %p: %s\\n\", e, e.toChars());\n         showCtfeExpr((cast(SliceExp)e).e1, level + 1);\n     }\n-    else if (e.op == TOK.variable)\n+    else if (e.op == EXP.variable)\n     {\n         printf(\"VAR %p %s\\n\", e, e.toChars());\n         VarDeclaration v = (cast(VarExp)e).var.isVarDeclaration();\n         if (v && getValue(v))\n             showCtfeExpr(getValue(v), level + 1);\n     }\n-    else if (e.op == TOK.address)\n+    else if (e.op == EXP.address)\n     {\n         // This is potentially recursive. We mustn't try to print the thing we're pointing to.\n         printf(\"POINTER %p to %p: %s\\n\", e, (cast(AddrExp)e).e1, e.toChars());\n@@ -2069,7 +2069,7 @@ UnionExp voidInitLiteral(Type t, VarDeclaration var)\n         Expression elem = voidInitLiteral(tsa.next, var).copy();\n         // For aggregate value types (structs, static arrays) we must\n         // create an a separate copy for each element.\n-        const mustCopy = (elem.op == TOK.arrayLiteral || elem.op == TOK.structLiteral);\n+        const mustCopy = (elem.op == EXP.arrayLiteral || elem.op == EXP.structLiteral);\n         const d = cast(size_t)tsa.dim.toInteger();\n         auto elements = new Expressions(d);\n         foreach (i; 0 .. d)"}, {"sha": "2e5a79d0febba7ae62a66ca6ad950d8fd5a9a1c7", "filename": "gcc/d/dmd/dcast.d", "status": "modified", "additions": 133, "deletions": 43, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fdcast.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fdcast.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdcast.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -29,6 +29,7 @@ import dmd.expression;\n import dmd.expressionsem;\n import dmd.func;\n import dmd.globals;\n+import dmd.hdrgen;\n import dmd.impcnvtab;\n import dmd.id;\n import dmd.importc;\n@@ -994,7 +995,7 @@ MATCH implicitConvTo(Expression e, Type t)\n             Type typeb = e.type.toBasetype();\n \n             // Look for pointers to functions where the functions are overloaded.\n-            if (e.e1.op == TOK.overloadSet &&\n+            if (e.e1.op == EXP.overloadSet &&\n                 (tb.ty == Tpointer || tb.ty == Tdelegate) && tb.nextOf().ty == Tfunction)\n             {\n                 OverExp eo = e.e1.isOverExp();\n@@ -1019,7 +1020,7 @@ MATCH implicitConvTo(Expression e, Type t)\n                 }\n             }\n \n-            if (e.e1.op == TOK.variable &&\n+            if (e.e1.op == EXP.variable &&\n                 typeb.ty == Tpointer && typeb.nextOf().ty == Tfunction &&\n                 tb.ty == Tpointer && tb.nextOf().ty == Tfunction)\n             {\n@@ -1443,7 +1444,7 @@ MATCH implicitConvTo(Expression e, Type t)\n             }\n \n             // Enhancement 10724\n-            if (tb.ty == Tpointer && e.e1.op == TOK.string_)\n+            if (tb.ty == Tpointer && e.e1.op == EXP.string_)\n                 e.e1.accept(this);\n         }\n \n@@ -1564,7 +1565,7 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n                 result = e;\n                 return;\n             }\n-            if (e.op == TOK.variable)\n+            if (e.op == EXP.variable)\n             {\n                 VarDeclaration v = (cast(VarExp)e).var.isVarDeclaration();\n                 if (v && v.storage_class & STC.manifest)\n@@ -1728,6 +1729,11 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n                     }\n                     const fsize = t1b.nextOf().size();\n                     const tsize = tob.nextOf().size();\n+                    if (fsize == SIZE_INVALID || tsize == SIZE_INVALID)\n+                    {\n+                        result = ErrorExp.get();\n+                        return;\n+                    }\n                     if (fsize != tsize)\n                     {\n                         const dim = t1b.isTypeSArray().dim.toInteger();\n@@ -1846,7 +1852,7 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n         override void visit(StructLiteralExp e)\n         {\n             visit(cast(Expression)e);\n-            if (result.op == TOK.structLiteral)\n+            if (result.op == EXP.structLiteral)\n                 (cast(StructLiteralExp)result).stype = t; // commit type\n         }\n \n@@ -1868,6 +1874,13 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n             }\n \n             StringExp se = e;\n+\n+            void lcast()\n+            {\n+                result = new CastExp(e.loc, se, t);\n+                result.type = t; // so semantic() won't be run on e\n+            }\n+\n             if (!e.committed)\n             {\n                 se = cast(StringExp)e.copy();\n@@ -1942,7 +1955,7 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n                     se = cast(StringExp)e.copy();\n                     copied = 1;\n                 }\n-                goto Lcast;\n+                return lcast();\n             }\n             if (typeb.ty != Tsarray && typeb.ty != Tarray && typeb.ty != Tpointer)\n             {\n@@ -1951,10 +1964,16 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n                     se = cast(StringExp)e.copy();\n                     copied = 1;\n                 }\n-                goto Lcast;\n+                return lcast();\n             }\n \n-            if (typeb.nextOf().size() == tb.nextOf().size())\n+            const nextSz = typeb.nextOf().size();\n+            if (nextSz == SIZE_INVALID)\n+            {\n+                result = ErrorExp.get();\n+                return;\n+            }\n+            if (nextSz == tb.nextOf().size())\n             {\n                 if (!copied)\n                 {\n@@ -2135,7 +2154,7 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n             }\n \n             // Look for pointers to functions where the functions are overloaded.\n-            if (e.e1.op == TOK.overloadSet &&\n+            if (e.e1.op == EXP.overloadSet &&\n                 (tb.ty == Tpointer || tb.ty == Tdelegate) && tb.nextOf().ty == Tfunction)\n             {\n                 OverExp eo = cast(OverExp)e.e1;\n@@ -2169,7 +2188,7 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n                 }\n             }\n \n-            if (e.e1.op == TOK.variable &&\n+            if (e.e1.op == EXP.variable &&\n                 typeb.ty == Tpointer && typeb.nextOf().ty == Tfunction &&\n                 tb.ty == Tpointer && tb.nextOf().ty == Tfunction)\n             {\n@@ -2621,7 +2640,7 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n                 if (e.e1.implicitConvTo(t1b) > MATCH.nomatch)\n                 {\n                     Expression e1x = e.e1.implicitCastTo(sc, t1b);\n-                    assert(e1x.op != TOK.error);\n+                    assert(e1x.op != EXP.error);\n                     e = cast(SliceExp)e.copy();\n                     e.e1 = e1x;\n                     e.type = t;\n@@ -2732,10 +2751,10 @@ Expression inferType(Expression e, Type t, int flag = 0)\n \n     if (t) switch (e.op)\n     {\n-        case TOK.arrayLiteral:      return visitAle(cast(ArrayLiteralExp) e);\n-        case TOK.assocArrayLiteral: return visitAar(cast(AssocArrayLiteralExp) e);\n-        case TOK.function_:         return visitFun(cast(FuncExp) e);\n-        case TOK.question:          return visitTer(cast(CondExp) e);\n+        case EXP.arrayLiteral:      return visitAle(cast(ArrayLiteralExp) e);\n+        case EXP.assocArrayLiteral: return visitAar(cast(AssocArrayLiteralExp) e);\n+        case EXP.function_:         return visitFun(cast(FuncExp) e);\n+        case EXP.question:          return visitTer(cast(CondExp) e);\n         default:\n     }\n     return e;\n@@ -2789,7 +2808,7 @@ Expression scaleFactor(BinExp be, Scope* sc)\n     if (sc.func && !sc.intypeof)\n     {\n         eoff = eoff.optimize(WANTvalue);\n-        if (eoff.op == TOK.int64 && eoff.toInteger() == 0)\n+        if (eoff.op == EXP.int64 && eoff.toInteger() == 0)\n         {\n         }\n         else if (sc.func.setUnsafe())\n@@ -2811,7 +2830,7 @@ Expression scaleFactor(BinExp be, Scope* sc)\n  */\n private bool isVoidArrayLiteral(Expression e, Type other)\n {\n-    while (e.op == TOK.arrayLiteral && e.type.ty == Tarray && ((cast(ArrayLiteralExp)e).elements.dim == 1))\n+    while (e.op == EXP.arrayLiteral && e.type.ty == Tarray && ((cast(ArrayLiteralExp)e).elements.dim == 1))\n     {\n         auto ale = cast(ArrayLiteralExp)e;\n         e = ale[0];\n@@ -2823,7 +2842,7 @@ private bool isVoidArrayLiteral(Expression e, Type other)\n     if (other.ty != Tsarray && other.ty != Tarray)\n         return false;\n     Type t = e.type;\n-    return (e.op == TOK.arrayLiteral && t.ty == Tarray && t.nextOf().ty == Tvoid && (cast(ArrayLiteralExp)e).elements.dim == 0);\n+    return (e.op == EXP.arrayLiteral && t.ty == Tarray && t.nextOf().ty == Tvoid && (cast(ArrayLiteralExp)e).elements.dim == 0);\n }\n \n /**\n@@ -2833,15 +2852,15 @@ private bool isVoidArrayLiteral(Expression e, Type other)\n  *\n  * Params:\n  *     sc  = Current scope\n- *     op  = Operator such as `e1 op e2`. In practice, either TOK.question\n+ *     op  = Operator such as `e1 op e2`. In practice, either EXP.question\n  *           or one of the binary operator.\n  *     pe1 = The LHS of the operation, will be rewritten\n  *     pe2 = The RHS of the operation, will be rewritten\n  *\n  * Returns:\n  *      The resulting type in case of success, `null` in case of error\n  */\n-Type typeMerge(Scope* sc, TOK op, ref Expression pe1, ref Expression pe2)\n+Type typeMerge(Scope* sc, EXP op, ref Expression pe1, ref Expression pe2)\n {\n     //printf(\"typeMerge() %s op %s\\n\", e1.toChars(), e2.toChars());\n \n@@ -2906,9 +2925,9 @@ Type typeMerge(Scope* sc, TOK op, ref Expression pe1, ref Expression pe2)\n         }\n     }\n \n-    if (op != TOK.question || t1b.ty != t2b.ty && (t1b.isTypeBasic() && t2b.isTypeBasic()))\n+    if (op != EXP.question || t1b.ty != t2b.ty && (t1b.isTypeBasic() && t2b.isTypeBasic()))\n     {\n-        if (op == TOK.question && t1b.ty.isSomeChar() && t2b.ty.isSomeChar())\n+        if (op == EXP.question && t1b.ty.isSomeChar() && t2b.ty.isSomeChar())\n         {\n             e1 = e1.castTo(sc, Type.tdchar);\n             e2 = e2.castTo(sc, Type.tdchar);\n@@ -3077,7 +3096,7 @@ Lagain:\n         return null;\n     }\n \n-    if ((t1.ty == Tsarray || t1.ty == Tarray) && (e2.op == TOK.null_ && t2.ty == Tpointer && t2.nextOf().ty == Tvoid || e2.op == TOK.arrayLiteral && t2.ty == Tsarray && t2.nextOf().ty == Tvoid && t2.isTypeSArray().dim.toInteger() == 0 || isVoidArrayLiteral(e2, t1)))\n+    if ((t1.ty == Tsarray || t1.ty == Tarray) && (e2.op == EXP.null_ && t2.ty == Tpointer && t2.nextOf().ty == Tvoid || e2.op == EXP.arrayLiteral && t2.ty == Tsarray && t2.nextOf().ty == Tvoid && t2.isTypeSArray().dim.toInteger() == 0 || isVoidArrayLiteral(e2, t1)))\n     {\n         /*  (T[n] op void*)   => T[]\n          *  (T[]  op void*)   => T[]\n@@ -3089,7 +3108,7 @@ Lagain:\n         return coerce(t1.nextOf().arrayOf());\n     }\n \n-    if ((t2.ty == Tsarray || t2.ty == Tarray) && (e1.op == TOK.null_ && t1.ty == Tpointer && t1.nextOf().ty == Tvoid || e1.op == TOK.arrayLiteral && t1.ty == Tsarray && t1.nextOf().ty == Tvoid && t1.isTypeSArray().dim.toInteger() == 0 || isVoidArrayLiteral(e1, t2)))\n+    if ((t2.ty == Tsarray || t2.ty == Tarray) && (e1.op == EXP.null_ && t1.ty == Tpointer && t1.nextOf().ty == Tvoid || e1.op == EXP.arrayLiteral && t1.ty == Tsarray && t1.nextOf().ty == Tvoid && t1.isTypeSArray().dim.toInteger() == 0 || isVoidArrayLiteral(e1, t2)))\n     {\n         /*  (void*   op T[n]) => T[]\n          *  (void*   op T[])  => T[]\n@@ -3107,9 +3126,9 @@ Lagain:\n         // Tsarray op [x, y, ...] should to be Tsarray\n         // https://issues.dlang.org/show_bug.cgi?id=14737\n         // Tsarray ~ [x, y, ...] should to be Tarray\n-        if (t1.ty == Tsarray && e2.op == TOK.arrayLiteral && op != TOK.concatenate)\n+        if (t1.ty == Tsarray && e2.op == EXP.arrayLiteral && op != EXP.concatenate)\n             return convert(e2, t1);\n-        if (m == MATCH.constant && (op == TOK.addAssign || op == TOK.minAssign || op == TOK.mulAssign || op == TOK.divAssign || op == TOK.modAssign || op == TOK.powAssign || op == TOK.andAssign || op == TOK.orAssign || op == TOK.xorAssign))\n+        if (m == MATCH.constant && (op == EXP.addAssign || op == EXP.minAssign || op == EXP.mulAssign || op == EXP.divAssign || op == EXP.modAssign || op == EXP.powAssign || op == EXP.andAssign || op == EXP.orAssign || op == EXP.xorAssign))\n         {\n             // Don't make the lvalue const\n             return Lret(t2);\n@@ -3121,7 +3140,7 @@ Lagain:\n     {\n         // https://issues.dlang.org/show_bug.cgi?id=7285\n         // https://issues.dlang.org/show_bug.cgi?id=14737\n-        if (t2.ty == Tsarray && e1.op == TOK.arrayLiteral && op != TOK.concatenate)\n+        if (t2.ty == Tsarray && e1.op == EXP.arrayLiteral && op != EXP.concatenate)\n             return convert(e1, t2);\n         return convert(e2, t1);\n     }\n@@ -3134,9 +3153,9 @@ Lagain:\n         Type t1n = t1.nextOf();\n         Type t2n = t2.nextOf();\n         ubyte mod;\n-        if (e1.op == TOK.null_ && e2.op != TOK.null_)\n+        if (e1.op == EXP.null_ && e2.op != EXP.null_)\n             mod = t2n.mod;\n-        else if (e1.op != TOK.null_ && e2.op == TOK.null_)\n+        else if (e1.op != EXP.null_ && e2.op == EXP.null_)\n             mod = t1n.mod;\n         else if (!t1n.isImmutable() && !t2n.isImmutable() && t1n.isShared() != t2n.isShared())\n             return null;\n@@ -3161,9 +3180,9 @@ Lagain:\n         if (t1.mod != t2.mod)\n         {\n             ubyte mod;\n-            if (e1.op == TOK.null_ && e2.op != TOK.null_)\n+            if (e1.op == EXP.null_ && e2.op != EXP.null_)\n                 mod = t2.mod;\n-            else if (e1.op != TOK.null_ && e2.op == TOK.null_)\n+            else if (e1.op != EXP.null_ && e2.op == EXP.null_)\n                 mod = t1.mod;\n             else if (!t1.isImmutable() && !t2.isImmutable() && t1.isShared() != t2.isShared())\n                 return null;\n@@ -3352,9 +3371,9 @@ Lagain:\n         goto Lagain;\n     }\n \n-    if ((e1.op == TOK.string_ || e1.op == TOK.null_) && e1.implicitConvTo(t2))\n+    if ((e1.op == EXP.string_ || e1.op == EXP.null_) && e1.implicitConvTo(t2))\n         return convert(e1, t2);\n-    if ((e2.op == TOK.string_ || e2.op == TOK.null_) && e2.implicitConvTo(t1))\n+    if ((e2.op == EXP.string_ || e2.op == EXP.null_) && e2.implicitConvTo(t1))\n         return convert(e2, t1);\n     if (t1.ty == Tsarray && t2.ty == Tsarray && e2.implicitConvTo(t1.nextOf().arrayOf()))\n         return coerce(t1.nextOf().arrayOf());\n@@ -3427,6 +3446,69 @@ LmodCompare:\n     if (t1.ty == Tnull && (t2.ty == Tpointer || t2.ty == Taarray || t2.ty == Tarray))\n         return convert(e1, t2);\n \n+    /// Covers array operations for user-defined types\n+    Type checkArrayOpType(Expression e1, Expression e2, EXP op, Scope *sc)\n+    {\n+        // scalar op scalar - we shouldn't be here\n+        if (e1.type.ty != Tarray && e1.type.ty != Tsarray && e2.type.ty != Tarray && e2.type.ty != Tsarray)\n+            return null;\n+\n+        // only supporting slices and array literals\n+        if (!e1.isSliceExp() && !e1.isArrayLiteralExp() && !e2.isSliceExp() && !e2.isArrayLiteralExp())\n+            return null;\n+\n+        // start with e1 op e2 and if either one of e1 or e2 is a slice or array literal,\n+        // replace it with the first element of the array\n+        Expression lhs = e1;\n+        Expression rhs = e2;\n+\n+        // T[x .. y] op ?\n+        if (e1.isSliceExp())\n+            lhs = new IndexExp(Loc.initial, (cast(UnaExp)e1).e1, IntegerExp.literal!0);\n+\n+        // [t1, t2, .. t3] op ?\n+        if (e1.isArrayLiteralExp())\n+            lhs = (cast(ArrayLiteralExp)e1).opIndex(0);\n+\n+        // ? op U[z .. t]\n+        if (e2.isSliceExp())\n+            rhs = new IndexExp(Loc.initial, (cast(UnaExp)e2).e1, IntegerExp.literal!0);\n+\n+        // ? op [u1, u2, .. u3]\n+        if (e2.isArrayLiteralExp())\n+            rhs = (cast(ArrayLiteralExp)e2).opIndex(0);\n+\n+        // create a new binary expression with the new lhs and rhs (at this stage, at least\n+        // one of lhs/rhs has been replaced with the 0'th element of the array it was before)\n+        Expression exp;\n+        switch (op)\n+        {\n+            case EXP.add:\n+                exp = new AddExp(Loc.initial, lhs, rhs); break;\n+            case EXP.min:\n+                exp = new MinExp(Loc.initial, lhs, rhs); break;\n+            case EXP.mul:\n+                exp = new MulExp(Loc.initial, lhs, rhs); break;\n+            case EXP.div:\n+                exp = new DivExp(Loc.initial, lhs, rhs); break;\n+            case EXP.pow:\n+                exp = new PowExp(Loc.initial, lhs, rhs); break;\n+            default:\n+                exp = null;\n+        }\n+\n+        if (exp)\n+        {\n+            // if T op U is valid and has type V\n+            // then T[] op U and T op U[] should be valid and have type V[]\n+            Expression e = exp.trySemantic(sc);\n+            if (e && e.type)\n+                return e.type.arrayOf;\n+        }\n+\n+        return null;\n+    }\n+\n     if (t1.ty == Tarray && isBinArrayOp(op) && isArrayOpOperand(e1))\n     {\n         if (e2.implicitConvTo(t1.nextOf()))\n@@ -3463,8 +3545,12 @@ LmodCompare:\n                     e2 = e2.castTo(sc, t);\n                 return Lret(t);\n             }\n-            return null;\n         }\n+\n+        t = checkArrayOpType(e1, e2, op, sc);\n+        if (t !is null)\n+            return Lret(t);\n+\n         return null;\n     }\n     else if (t2.ty == Tarray && isBinArrayOp(op) && isArrayOpOperand(e2))\n@@ -3483,15 +3569,19 @@ LmodCompare:\n             t = e1.type.arrayOf();\n         }\n         else\n-            return null;\n+        {\n+            t = checkArrayOpType(e1, e2, op, sc);\n+            if (t is null)\n+                return null;\n+        }\n \n-        //printf(\"test %s\\n\", Token::toChars(op));\n+        //printf(\"test %s\\n\", EXPtoString(op).ptr);\n         e1 = e1.optimize(WANTvalue);\n         if (isCommutative(op) && e1.isConst())\n         {\n             /* Swap operands to minimize number of functions generated\n              */\n-            //printf(\"swap %s\\n\", Token::toChars(op));\n+            //printf(\"swap %s\\n\", EXPtoString(op).ptr);\n             Expression tmp = e1;\n             e1 = e2;\n             e2 = tmp;\n@@ -3512,15 +3602,15 @@ Expression typeCombine(BinExp be, Scope* sc)\n     Expression errorReturn()\n     {\n         Expression ex = be.incompatibleTypes();\n-        if (ex.op == TOK.error)\n+        if (ex.op == EXP.error)\n             return ex;\n         return ErrorExp.get();\n     }\n \n     Type t1 = be.e1.type.toBasetype();\n     Type t2 = be.e2.type.toBasetype();\n \n-    if (be.op == TOK.min || be.op == TOK.add)\n+    if (be.op == EXP.min || be.op == EXP.add)\n     {\n         // struct+struct, and class+class are errors\n         if (t1.ty == Tstruct && t2.ty == Tstruct)\n@@ -3540,9 +3630,9 @@ Expression typeCombine(BinExp be, Scope* sc)\n         return errorReturn();\n \n     // If the types have no value, return an error\n-    if (be.e1.op == TOK.error)\n+    if (be.e1.op == EXP.error)\n         return be.e1;\n-    if (be.e2.op == TOK.error)\n+    if (be.e2.op == EXP.error)\n         return be.e2;\n     return null;\n }\n@@ -3606,8 +3696,8 @@ void fix16997(Scope* sc, UnaExp ue)\n             case Tchar:\n             case Twchar:\n             case Tdchar:\n-                ue.deprecation(\"integral promotion not done for `%s`, use '-preview=intpromote' switch or `%scast(int)(%s)`\",\n-                    ue.toChars(), Token.toChars(ue.op), ue.e1.toChars());\n+                ue.deprecation(\"integral promotion not done for `%s`, remove '-revert=intpromote' switch or `%scast(int)(%s)`\",\n+                    ue.toChars(), EXPtoString(ue.op).ptr, ue.e1.toChars());\n                 break;\n \n             default:"}, {"sha": "18c8ca2da749a21588b5350d862a02c931a315d3", "filename": "gcc/d/dmd/declaration.d", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fdeclaration.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fdeclaration.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -94,7 +94,7 @@ bool modifyFieldVar(Loc loc, Scope* sc, VarDeclaration var, Expression e1)\n             ((fd.isCtorDeclaration() && var.isField()) ||\n              (fd.isStaticCtorDeclaration() && !var.isField())) &&\n             fd.toParentDecl() == var.toParent2() &&\n-            (!e1 || e1.op == TOK.this_))\n+            (!e1 || e1.op == EXP.this_))\n         {\n             bool result = true;\n \n@@ -250,7 +250,10 @@ extern (C++) abstract class Declaration : Dsymbol\n     override final d_uns64 size(const ref Loc loc)\n     {\n         assert(type);\n-        return type.size();\n+        const sz = type.size();\n+        if (sz == SIZE_INVALID)\n+            errors = true;\n+        return sz;\n     }\n \n     /**\n@@ -371,7 +374,7 @@ extern (C++) abstract class Declaration : Dsymbol\n             }\n         }\n \n-        if (e1 && e1.op == TOK.this_ && isField())\n+        if (e1 && e1.op == EXP.this_ && isField())\n         {\n             VarDeclaration vthis = (cast(ThisExp)e1).var;\n             for (Scope* scx = sc; scx; scx = scx.enclosing)\n@@ -385,7 +388,7 @@ extern (C++) abstract class Declaration : Dsymbol\n             }\n         }\n \n-        if (v && (isCtorinit() || isField()))\n+        if (v && (v.isCtorinit() || isField()))\n         {\n             // It's only modifiable if inside the right constructor\n             if ((storage_class & (STC.foreach_ | STC.ref_)) == (STC.foreach_ | STC.ref_))\n@@ -434,11 +437,6 @@ extern (C++) abstract class Declaration : Dsymbol\n         return false;\n     }\n \n-    final bool isCtorinit() const pure nothrow @nogc @safe\n-    {\n-        return (storage_class & STC.ctorinit) != 0;\n-    }\n-\n     final bool isFinal() const pure nothrow @nogc @safe\n     {\n         return (storage_class & STC.final_) != 0;\n@@ -655,7 +653,7 @@ extern (C++) final class TupleDeclaration : Declaration\n             if (o.dyncast() == DYNCAST.expression)\n             {\n                 Expression e = cast(Expression)o;\n-                if (e.op == TOK.dSymbol)\n+                if (e.op == EXP.dSymbol)\n                 {\n                     DsymbolExp ve = cast(DsymbolExp)e;\n                     Declaration d = ve.s.isDeclaration();\n@@ -1062,6 +1060,7 @@ extern (C++) class VarDeclaration : Declaration\n     bool ctorinit;                  // it has been initialized in a ctor\n     bool iscatchvar;                // this is the exception object variable in catch() clause\n     bool isowner;                   // this is an Owner, despite it being `scope`\n+    bool setInCtorOnly;             // field can only be set in a constructor, as it is const or immutable\n \n     // Both these mean the var is not rebindable once assigned,\n     // and the destructor gets run when it goes out of scope\n@@ -1131,7 +1130,7 @@ extern (C++) class VarDeclaration : Declaration\n                 RootObject o = (*v2.objects)[i];\n                 assert(o.dyncast() == DYNCAST.expression);\n                 Expression e = cast(Expression)o;\n-                assert(e.op == TOK.dSymbol);\n+                assert(e.op == EXP.dSymbol);\n                 DsymbolExp se = cast(DsymbolExp)e;\n                 se.s.setFieldOffset(ad, fieldState, isunion);\n             }\n@@ -1250,6 +1249,11 @@ extern (C++) class VarDeclaration : Declaration\n         return false;\n     }\n \n+    final bool isCtorinit() const pure nothrow @nogc @safe\n+    {\n+        return setInCtorOnly;\n+    }\n+\n     /*******************************\n      * Does symbol go into data segment?\n      * Includes extern variables.\n@@ -1607,7 +1611,7 @@ extern (C++) class VarDeclaration : Declaration\n             ExpInitializer ez = _init.isExpInitializer();\n             assert(ez);\n             Expression e = ez.exp;\n-            if (e.op == TOK.construct || e.op == TOK.blit)\n+            if (e.op == EXP.construct || e.op == EXP.blit)\n                 e = (cast(AssignExp)e).e2;\n             return lambdaCheckForNestedRef(e, sc);\n         }\n@@ -1670,11 +1674,11 @@ extern (C++) class VarDeclaration : Declaration\n         assert(this.loc != Loc.initial);\n         assert(v.loc != Loc.initial);\n \n-        if (auto ld = this.loc.linnum - v.loc.linnum)\n-            return ld < 0;\n+        if (this.loc.linnum != v.loc.linnum)\n+            return this.loc.linnum < v.loc.linnum;\n \n-        if (auto cd = this.loc.charnum - v.loc.charnum)\n-            return cd < 0;\n+        if (this.loc.charnum != v.loc.charnum)\n+            return this.loc.charnum < v.loc.charnum;\n \n         // Default fallback\n         return this.sequenceNumber < v.sequenceNumber;\n@@ -1930,9 +1934,9 @@ extern (C++) class BitFieldDeclaration : VarDeclaration\n  */\n extern (C++) final class SymbolDeclaration : Declaration\n {\n-    StructDeclaration dsym;\n+    AggregateDeclaration dsym;\n \n-    extern (D) this(const ref Loc loc, StructDeclaration dsym)\n+    extern (D) this(const ref Loc loc, AggregateDeclaration dsym)\n     {\n         super(loc, dsym.ident);\n         this.dsym = dsym;"}, {"sha": "884146e141669c0ca7f9a582943a330e540e4dd3", "filename": "gcc/d/dmd/declaration.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fdeclaration.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fdeclaration.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.h?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -53,7 +53,7 @@ struct IntRange;\n     #define STCforeach            0x4000ULL    /// variable for foreach loop\n     #define STCvariadic           0x8000ULL    /// the `variadic` parameter in: T foo(T a, U b, V variadic...)\n \n-    #define STCctorinit           0x10000ULL    /// can only be set inside constructor\n+    //                            0x10000ULL\n     #define STCtemplateparameter  0x20000ULL    /// template parameter\n     #define STCref                0x40000ULL    /// `ref`\n     #define STCscope              0x80000ULL    /// `scope`\n@@ -65,7 +65,7 @@ struct IntRange;\n \n     #define STCreturninferred     0x1000000ULL    /// `return` has been inferred and should not be part of mangling, `return` must also be set\n     #define STCimmutable          0x2000000ULL    /// `immutable`\n-    #define STCinit               0x4000000ULL    /// has explicit initializer\n+    //                            0x4000000ULL\n     #define STCmanifest           0x8000000ULL    /// manifest constant\n \n     #define STCnodtor             0x10000000ULL    /// do not run destructor\n@@ -131,7 +131,6 @@ class Declaration : public Dsymbol\n     virtual bool isDataseg();\n     virtual bool isThreadlocal();\n     virtual bool isCodeseg() const;\n-    bool isCtorinit() const     { return (storage_class & STCctorinit) != 0; }\n     bool isFinal() const        { return (storage_class & STCfinal) != 0; }\n     virtual bool isAbstract()   { return (storage_class & STCabstract) != 0; }\n     bool isConst() const        { return (storage_class & STCconst) != 0; }\n@@ -247,6 +246,7 @@ class VarDeclaration : public Declaration\n     bool ctorinit;              // it has been initialized in a ctor\n     bool iscatchvar;            // this is the exception object variable in catch() clause\n     bool isowner;               // this is an Owner, despite it being `scope`\n+    bool setInCtorOnly;         // field can only be set in a constructor, as it is const or immutable\n     bool onstack;               // it is a class that was allocated on the stack\n     bool mynew;                 // it is a class new'd with custom operator new\n     char canassign;             // it can be assigned to\n@@ -266,6 +266,7 @@ class VarDeclaration : public Declaration\n     bool needThis();\n     bool isExport() const;\n     bool isImportedSymbol() const;\n+    bool isCtorinit() const;\n     bool isDataseg();\n     bool isThreadlocal();\n     bool isCTFE();\n@@ -303,7 +304,7 @@ class BitFieldDeclaration : public VarDeclaration\n class SymbolDeclaration : public Declaration\n {\n public:\n-    StructDeclaration *dsym;\n+    AggregateDeclaration *dsym;\n \n     // Eliminate need for dynamic_cast\n     SymbolDeclaration *isSymbolDeclaration() { return (SymbolDeclaration *)this; }"}, {"sha": "891adb3c6bdc677823a127ff5641946603ec3d8a", "filename": "gcc/d/dmd/dinterpret.d", "status": "modified", "additions": 333, "deletions": 301, "changes": 634, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fdinterpret.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fdinterpret.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdinterpret.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -34,6 +34,7 @@ import dmd.expression;\n import dmd.expressionsem;\n import dmd.func;\n import dmd.globals;\n+import dmd.hdrgen;\n import dmd.id;\n import dmd.identifier;\n import dmd.init;\n@@ -63,26 +64,26 @@ public Expression ctfeInterpret(Expression e)\n {\n     switch (e.op)\n     {\n-        case TOK.int64:\n-        case TOK.float64:\n-        case TOK.complex80:\n-        case TOK.null_:\n-        case TOK.void_:\n-        case TOK.string_:\n-        case TOK.this_:\n-        case TOK.super_:\n-        case TOK.type:\n-        case TOK.typeid_:\n-        case TOK.template_:              // non-eponymous template/instance\n-        case TOK.scope_:                 // ditto\n-        case TOK.dotTemplateDeclaration: // ditto, e.e1 doesn't matter here\n-        case TOK.dotTemplateInstance:    // ditto\n-        case TOK.dot:                    // ditto\n+        case EXP.int64:\n+        case EXP.float64:\n+        case EXP.complex80:\n+        case EXP.null_:\n+        case EXP.void_:\n+        case EXP.string_:\n+        case EXP.this_:\n+        case EXP.super_:\n+        case EXP.type:\n+        case EXP.typeid_:\n+        case EXP.template_:              // non-eponymous template/instance\n+        case EXP.scope_:                 // ditto\n+        case EXP.dotTemplateDeclaration: // ditto, e.e1 doesn't matter here\n+        case EXP.dotTemplateInstance:    // ditto\n+        case EXP.dot:                    // ditto\n              if (e.type.ty == Terror)\n                 return ErrorExp.get();\n-            goto case TOK.error;\n+            goto case EXP.error;\n \n-        case TOK.error:\n+        case EXP.error:\n             return e;\n \n         default:\n@@ -115,7 +116,7 @@ public Expression ctfeInterpret(Expression e)\n  */\n public Expression ctfeInterpretForPragmaMsg(Expression e)\n {\n-    if (e.op == TOK.error || e.op == TOK.type)\n+    if (e.op == EXP.error || e.op == EXP.type)\n         return e;\n \n     // It's also OK for it to be a function declaration (happens only with\n@@ -410,7 +411,7 @@ private struct InterState\n  *      thisarg   = 'this', if a needThis() function, NULL if not.\n  *\n  * Returns:\n- * result expression if successful, TOK.cantExpression if not,\n+ * result expression if successful, EXP.cantExpression if not,\n  * or CTFEExp if function returned void.\n  */\n private Expression interpretFunction(UnionExp* pue, FuncDeclaration fd, InterState* istate, Expressions* arguments, Expression thisarg)\n@@ -507,7 +508,7 @@ private Expression interpretFunction(UnionExp* pue, FuncDeclaration fd, InterSta\n             /* Struct literals are passed by value, but we don't need to\n              * copy them if they are passed as const\n              */\n-            if (earg.op == TOK.structLiteral && !(fparam.storageClass & (STC.const_ | STC.immutable_)))\n+            if (earg.op == EXP.structLiteral && !(fparam.storageClass & (STC.const_ | STC.immutable_)))\n                 earg = copyLiteral(earg).copy();\n         }\n         if (auto tee = earg.isThrownExceptionExp())\n@@ -563,7 +564,7 @@ private Expression interpretFunction(UnionExp* pue, FuncDeclaration fd, InterSta\n         }\n         ctfeGlobals.stack.push(v);\n \n-        if (fparam.isReference() && earg.op == TOK.variable &&\n+        if (fparam.isReference() && earg.op == EXP.variable &&\n             earg.isVarExp().var.toParent2() == fd)\n         {\n             VarDeclaration vx = earg.isVarExp().var.isVarDeclaration();\n@@ -660,16 +661,16 @@ private Expression interpretFunction(UnionExp* pue, FuncDeclaration fd, InterSta\n         }\n         else\n         {\n-            assert(!e || (e.op != TOK.continue_ && e.op != TOK.break_));\n+            assert(!e || (e.op != EXP.continue_ && e.op != EXP.break_));\n             break;\n         }\n     }\n     // If fell off the end of a void function, return void\n     if (!e && tf.next.ty == Tvoid)\n         e = CTFEExp.voidexp;\n-    if (tf.isref && e.op == TOK.variable && e.isVarExp().var == fd.vthis)\n+    if (tf.isref && e.op == EXP.variable && e.isVarExp().var == fd.vthis)\n         e = thisarg;\n-    if (tf.isref && fd.isThis2 && e.op == TOK.index)\n+    if (tf.isref && fd.isThis2 && e.op == EXP.index)\n     {\n         auto ie = e.isIndexExp();\n         auto pe = ie.e1.isPtrExp();\n@@ -733,14 +734,14 @@ public:\n         this.goal = goal;\n     }\n \n-    // If e is TOK.throw_exception or TOK.cantExpression,\n+    // If e is EXP.throw_exception or EXP.cantExpression,\n     // set it to 'result' and returns true.\n     bool exceptionOrCant(Expression e)\n     {\n         if (exceptionOrCantInterpret(e))\n         {\n             // Make sure e is not pointing to a stack temporary\n-            result = (e.op == TOK.cantExpression) ? CTFEExp.cantexp : e;\n+            result = (e.op == EXP.cantExpression) ? CTFEExp.cantexp : e;\n             return true;\n         }\n         return false;\n@@ -839,7 +840,7 @@ public:\n                 continue;\n             if (exceptionOrCant(e))\n                 return;\n-            if (e.op == TOK.break_)\n+            if (e.op == EXP.break_)\n             {\n                 if (istate.gotoTarget && istate.gotoTarget != s)\n                 {\n@@ -850,7 +851,7 @@ public:\n                 result = null;\n                 return;\n             }\n-            if (e.op == TOK.continue_)\n+            if (e.op == EXP.continue_)\n             {\n                 if (istate.gotoTarget && istate.gotoTarget != s)\n                 {\n@@ -894,7 +895,7 @@ public:\n \n         if (isTrueBool(e))\n             result = interpret(pue, s.ifbody, istate);\n-        else if (e.isBool(false))\n+        else if (e.toBool().hasValue(false))\n             result = interpret(pue, s.elsebody, istate);\n         else\n         {\n@@ -935,7 +936,7 @@ public:\n             if (auto eaddr = e.isAddrExp())\n                 x = eaddr.e1;\n             VarDeclaration v;\n-            while (x.op == TOK.variable && (v = (cast(VarExp)x).var.isVarDeclaration()) !is null)\n+            while (x.op == EXP.variable && (v = (cast(VarExp)x).var.isVarDeclaration()) !is null)\n             {\n                 if (v.storage_class & STC.ref_)\n                 {\n@@ -952,7 +953,7 @@ public:\n                 else\n                     break;\n             }\n-            // TODO: If it is a TOK.dotVariable or TOK.index, we should check that it is not\n+            // TODO: If it is a EXP.dotVariable or EXP.index, we should check that it is not\n             // pointing to a local struct or static array.\n         }\n         if (auto se = e.isStructLiteralExp())\n@@ -1023,7 +1024,7 @@ public:\n             return;\n         }\n \n-        // We need to treat pointers specially, because TOK.symbolOffset can be used to\n+        // We need to treat pointers specially, because EXP.symbolOffset can be used to\n         // return a value OR a pointer\n         Expression e = interpret(pue, s.exp, istate);\n         if (exceptionOrCant(e))\n@@ -1122,7 +1123,7 @@ public:\n \n             if (exceptionOrCant(e))\n                 return;\n-            if (e && e.op == TOK.break_)\n+            if (e && e.op == EXP.break_)\n             {\n                 if (istate.gotoTarget && istate.gotoTarget != s)\n                 {\n@@ -1132,7 +1133,7 @@ public:\n                 istate.gotoTarget = null;\n                 break;\n             }\n-            if (e && e.op == TOK.continue_)\n+            if (e && e.op == EXP.continue_)\n             {\n                 if (istate.gotoTarget && istate.gotoTarget != s)\n                 {\n@@ -1158,7 +1159,7 @@ public:\n                 result = CTFEExp.cantexp;\n                 return;\n             }\n-            if (e.isBool(false))\n+            if (e.toBool().hasValue(false))\n                 break;\n             assert(isTrueBool(e));\n         }\n@@ -1189,7 +1190,7 @@ public:\n                 Expression e = interpret(&ue, s.condition, istate);\n                 if (exceptionOrCant(e))\n                     return;\n-                if (e.isBool(false))\n+                if (e.toBool().hasValue(false))\n                     break;\n                 assert(isTrueBool(e));\n             }\n@@ -1201,7 +1202,7 @@ public:\n \n             if (exceptionOrCant(e))\n                 return;\n-            if (e && e.op == TOK.break_)\n+            if (e && e.op == EXP.break_)\n             {\n                 if (istate.gotoTarget && istate.gotoTarget != s)\n                 {\n@@ -1211,7 +1212,7 @@ public:\n                 istate.gotoTarget = null;\n                 break;\n             }\n-            if (e && e.op == TOK.continue_)\n+            if (e && e.op == EXP.continue_)\n             {\n                 if (istate.gotoTarget && istate.gotoTarget != s)\n                 {\n@@ -1263,7 +1264,7 @@ public:\n                 return;\n             if (exceptionOrCant(e))\n                 return;\n-            if (e && e.op == TOK.break_)\n+            if (e && e.op == EXP.break_)\n             {\n                 if (istate.gotoTarget && istate.gotoTarget != s)\n                 {\n@@ -1290,7 +1291,7 @@ public:\n                 Expression ecase = interpret(&uecase, cs.exp, istate);\n                 if (exceptionOrCant(ecase))\n                     return;\n-                if (ctfeEqual(cs.exp.loc, TOK.equal, econdition, ecase))\n+                if (ctfeEqual(cs.exp.loc, EXP.equal, econdition, ecase))\n                 {\n                     scase = cs;\n                     break;\n@@ -1310,7 +1311,7 @@ public:\n         istate.start = scase;\n         Expression e = interpret(pue, s._body, istate);\n         assert(!istate.start); // jump must not fail\n-        if (e && e.op == TOK.break_)\n+        if (e && e.op == EXP.break_)\n         {\n             if (istate.gotoTarget && istate.gotoTarget != s)\n             {\n@@ -1515,7 +1516,7 @@ public:\n             (*collateral.value.elements)[bypass] = boss;\n             return newest;\n         }\n-        while ((*boss.value.elements)[next].op == TOK.classReference)\n+        while ((*boss.value.elements)[next].op == EXP.classReference)\n         {\n             boss = cast(ClassReferenceExp)(*boss.value.elements)[next];\n         }\n@@ -1606,7 +1607,7 @@ public:\n         if (exceptionOrCant(e))\n             return;\n \n-        assert(e.op == TOK.classReference);\n+        assert(e.op == EXP.classReference);\n         result = ctfeEmplaceExp!ThrownExceptionExp(s.loc, e.isClassReferenceExp());\n     }\n \n@@ -1630,7 +1631,7 @@ public:\n         }\n \n         // If it is with(Enum) {...}, just execute the body.\n-        if (s.exp.op == TOK.scope_ || s.exp.op == TOK.type)\n+        if (s.exp.op == EXP.scope_ || s.exp.op == EXP.type)\n         {\n             result = interpret(pue, s._body, istate);\n             return;\n@@ -1707,7 +1708,7 @@ public:\n     {\n         debug (LOG)\n         {\n-            printf(\"%s Expression::interpret() '%s' %s\\n\", e.loc.toChars(), Token.toChars(e.op), e.toChars());\n+            printf(\"%s Expression::interpret() '%s' %s\\n\", e.loc.toChars(), EXPtoString(e.op).ptr, e.toChars());\n             printf(\"type = %s\\n\", e.type.toChars());\n             showCtfeExpr(e);\n         }\n@@ -1755,17 +1756,17 @@ public:\n         {\n             if (istate && istate.fd.isThis2)\n             {\n-                assert(result.op == TOK.address);\n+                assert(result.op == EXP.address);\n                 result = (cast(AddrExp)result).e1;\n-                assert(result.op == TOK.arrayLiteral);\n+                assert(result.op == EXP.arrayLiteral);\n                 result = (*(cast(ArrayLiteralExp)result).elements)[0];\n                 if (e.type.ty == Tstruct)\n                 {\n                     result = (cast(AddrExp)result).e1;\n                 }\n                 return;\n             }\n-            assert(result.op == TOK.structLiteral || result.op == TOK.classReference || result.op == TOK.type);\n+            assert(result.op == EXP.structLiteral || result.op == EXP.classReference || result.op == EXP.type);\n             return;\n         }\n         e.error(\"value of `this` is not known at compile time\");\n@@ -1909,7 +1910,7 @@ public:\n             dinteger_t indx = e.offset / sz;\n             assert(sz * indx == e.offset);\n             Expression aggregate = null;\n-            if (val.op == TOK.arrayLiteral || val.op == TOK.string_)\n+            if (val.op == EXP.arrayLiteral || val.op == EXP.string_)\n             {\n                 aggregate = val;\n             }\n@@ -2054,13 +2055,13 @@ public:\n                     return CTFEExp.cantexp;\n                 assert(e.type);\n \n-                if (e.op == TOK.construct || e.op == TOK.blit)\n+                if (e.op == EXP.construct || e.op == EXP.blit)\n                 {\n                     AssignExp ae = cast(AssignExp)e;\n                     e = ae.e2;\n                 }\n \n-                if (e.op == TOK.error)\n+                if (e.op == EXP.error)\n                 {\n                     // FIXME: Ultimately all errors should be detected in prior semantic analysis stage.\n                 }\n@@ -2142,12 +2143,20 @@ public:\n         }\n         else if (SymbolDeclaration s = d.isSymbolDeclaration())\n         {\n+            // exclude void[]-typed `__traits(initSymbol)`\n+            if (auto ta = s.type.toBasetype().isTypeDArray())\n+            {\n+                assert(ta.next.ty == Tvoid);\n+                error(loc, \"cannot determine the address of the initializer symbol during CTFE\");\n+                return CTFEExp.cantexp;\n+            }\n+\n             // Struct static initializers, for example\n             e = s.dsym.type.defaultInitLiteral(loc);\n-            if (e.op == TOK.error)\n+            if (e.op == EXP.error)\n                 error(loc, \"CTFE failed because of previous errors in `%s.init`\", s.toChars());\n             e = e.expressionSemantic(null);\n-            if (e.op == TOK.error)\n+            if (e.op == EXP.error)\n                 e = CTFEExp.cantexp;\n             else // Convert NULL to CTFEExp\n                 e = interpret(e, istate, goal);\n@@ -2195,10 +2204,10 @@ public:\n                 {\n                     // Strip off the nest of ref variables\n                     Expression ev = getValue(v);\n-                    if (ev.op == TOK.variable ||\n-                        ev.op == TOK.index ||\n-                        (ev.op == TOK.slice && ev.type.toBasetype().ty == Tsarray) ||\n-                        ev.op == TOK.dotVariable)\n+                    if (ev.op == EXP.variable ||\n+                        ev.op == EXP.index ||\n+                        (ev.op == EXP.slice && ev.type.toBasetype().ty == Tsarray) ||\n+                        ev.op == EXP.dotVariable)\n                     {\n                         result = interpret(pue, ev, istate, goal);\n                         return;\n@@ -2363,13 +2372,13 @@ public:\n             if (exceptionOrCant(ex))\n                 return;\n \n-            if (result.op == TOK.null_)\n+            if (result.op == EXP.null_)\n             {\n                 e.error(\"null pointer dereference evaluating typeid. `%s` is `null`\", ex.toChars());\n                 result = CTFEExp.cantexp;\n                 return;\n             }\n-            if (result.op != TOK.classReference)\n+            if (result.op != EXP.classReference)\n             {\n                 e.error(\"CTFE internal error: determining classinfo\");\n                 result = CTFEExp.cantexp;\n@@ -2406,7 +2415,7 @@ public:\n             // A tuple of assignments can contain void (Bug 5676).\n             if (goal == CTFEGoal.Nothing)\n                 continue;\n-            if (ex.op == TOK.voidExpression)\n+            if (ex.op == EXP.voidExpression)\n             {\n                 e.error(\"CTFE internal error: void element `%s` in tuple\", exp.toChars());\n                 assert(0);\n@@ -2464,7 +2473,7 @@ public:\n             else\n             {\n                 // segfault bug 6250\n-                assert(exp.op != TOK.index || (cast(IndexExp)exp).e1 != e);\n+                assert(exp.op != EXP.index || (cast(IndexExp)exp).e1 != e);\n \n                 ex = interpretRegion(exp, istate);\n                 if (exceptionOrCant(ex))\n@@ -2569,7 +2578,7 @@ public:\n             for (size_t j = i; j < keysx.dim; j++)\n             {\n                 auto ekey2 = (*keysx)[j];\n-                if (!ctfeEqual(e.loc, TOK.equal, ekey, ekey2))\n+                if (!ctfeEqual(e.loc, EXP.equal, ekey, ekey2))\n                     continue;\n \n                 // Remove ekey\n@@ -2904,15 +2913,15 @@ public:\n             return;\n         switch (e.op)\n         {\n-        case TOK.negate:\n+        case EXP.negate:\n             *pue = Neg(e.type, e1);\n             break;\n \n-        case TOK.tilde:\n+        case EXP.tilde:\n             *pue = Com(e.type, e1);\n             break;\n \n-        case TOK.not:\n+        case EXP.not:\n             *pue = Not(e.type, e1);\n             break;\n \n@@ -2948,7 +2957,7 @@ public:\n         {\n             printf(\"%s BinExp::interpretCommon() %s\\n\", e.loc.toChars(), e.toChars());\n         }\n-        if (e.e1.type.ty == Tpointer && e.e2.type.ty == Tpointer && e.op == TOK.min)\n+        if (e.e1.type.ty == Tpointer && e.e2.type.ty == Tpointer && e.op == EXP.min)\n         {\n             UnionExp ue1 = void;\n             Expression e1 = interpret(&ue1, e.e1, istate);\n@@ -2976,7 +2985,7 @@ public:\n             result = (*pue).exp();\n             return;\n         }\n-        if (e.e2.type.ty == Tpointer && e.e1.type.isintegral() && e.op == TOK.add)\n+        if (e.e2.type.ty == Tpointer && e.e1.type.isintegral() && e.op == EXP.add)\n         {\n             UnionExp ue1 = void;\n             Expression e1 = interpret(&ue1, e.e1, istate);\n@@ -3015,7 +3024,7 @@ public:\n         if (!evalOperand(&ue2, e.e2, e2))\n             return;\n \n-        if (e.op == TOK.rightShift || e.op == TOK.leftShift || e.op == TOK.unsignedRightShift)\n+        if (e.op == EXP.rightShift || e.op == EXP.leftShift || e.op == EXP.unsignedRightShift)\n         {\n             const sinteger_t i2 = e2.toInteger();\n             const d_uns64 sz = e1.type.size() * 8;\n@@ -3073,13 +3082,13 @@ public:\n             {\n                 // The following should really be an assert()\n                 e1.error(\"CTFE internal error: non-constant value `%s`\", e1.toChars());\n-                emplaceExp!CTFEExp(&ue, TOK.cantExpression);\n+                emplaceExp!CTFEExp(&ue, EXP.cantExpression);\n                 return ue;\n             }\n             if (e2.isConst() != 1)\n             {\n                 e2.error(\"CTFE internal error: non-constant value `%s`\", e2.toChars());\n-                emplaceExp!CTFEExp(&ue, TOK.cantExpression);\n+                emplaceExp!CTFEExp(&ue, EXP.cantExpression);\n                 return ue;\n             }\n \n@@ -3116,7 +3125,7 @@ public:\n             const cmp = comparePointers(e.op, agg1, ofs1, agg2, ofs2);\n             if (cmp == -1)\n             {\n-                char dir = (e.op == TOK.greaterThan || e.op == TOK.greaterOrEqual) ? '<' : '>';\n+                char dir = (e.op == EXP.greaterThan || e.op == EXP.greaterOrEqual) ? '<' : '>';\n                 e.error(\"the ordering of pointers to unrelated memory blocks is indeterminate in CTFE. To check if they point to the same memory block, use both `>` and `<` inside `&&` or `||`, eg `%s && %s %c= %s + 1`\", e.toChars(), e.e1.toChars(), dir, e.e2.toChars());\n                 result = CTFEExp.cantexp;\n                 return;\n@@ -3162,73 +3171,73 @@ public:\n     {\n         switch (e.op)\n         {\n-        case TOK.add:\n+        case EXP.add:\n             interpretCommon(e, &Add);\n             return;\n \n-        case TOK.min:\n+        case EXP.min:\n             interpretCommon(e, &Min);\n             return;\n \n-        case TOK.mul:\n+        case EXP.mul:\n             interpretCommon(e, &Mul);\n             return;\n \n-        case TOK.div:\n+        case EXP.div:\n             interpretCommon(e, &Div);\n             return;\n \n-        case TOK.mod:\n+        case EXP.mod:\n             interpretCommon(e, &Mod);\n             return;\n \n-        case TOK.leftShift:\n+        case EXP.leftShift:\n             interpretCommon(e, &Shl);\n             return;\n \n-        case TOK.rightShift:\n+        case EXP.rightShift:\n             interpretCommon(e, &Shr);\n             return;\n \n-        case TOK.unsignedRightShift:\n+        case EXP.unsignedRightShift:\n             interpretCommon(e, &Ushr);\n             return;\n \n-        case TOK.and:\n+        case EXP.and:\n             interpretCommon(e, &And);\n             return;\n \n-        case TOK.or:\n+        case EXP.or:\n             interpretCommon(e, &Or);\n             return;\n \n-        case TOK.xor:\n+        case EXP.xor:\n             interpretCommon(e, &Xor);\n             return;\n \n-        case TOK.pow:\n+        case EXP.pow:\n             interpretCommon(e, &Pow);\n             return;\n \n-        case TOK.equal:\n-        case TOK.notEqual:\n+        case EXP.equal:\n+        case EXP.notEqual:\n             interpretCompareCommon(e, &ctfeEqual);\n             return;\n \n-        case TOK.identity:\n-        case TOK.notIdentity:\n+        case EXP.identity:\n+        case EXP.notIdentity:\n             interpretCompareCommon(e, &ctfeIdentity);\n             return;\n \n-        case TOK.lessThan:\n-        case TOK.lessOrEqual:\n-        case TOK.greaterThan:\n-        case TOK.greaterOrEqual:\n+        case EXP.lessThan:\n+        case EXP.lessOrEqual:\n+        case EXP.greaterThan:\n+        case EXP.greaterOrEqual:\n             interpretCompareCommon(e, &ctfeCmp);\n             return;\n \n         default:\n-            printf(\"be = '%s' %s at [%s]\\n\", Token.toChars(e.op), e.toChars(), e.loc.toChars());\n+            printf(\"be = '%s' %s at [%s]\\n\", EXPtoString(e.op).ptr, e.toChars(), e.loc.toChars());\n             assert(0);\n         }\n     }\n@@ -3286,7 +3295,7 @@ public:\n          * So we need to recurse to determine if it is a block assignment.\n          */\n         bool isBlockAssignment = false;\n-        if (e1.op == TOK.slice)\n+        if (e1.op == EXP.slice)\n         {\n             // a[] = e can have const e. So we compare the naked types.\n             Type tdst = e1.type.toBasetype();\n@@ -3306,7 +3315,7 @@ public:\n         //      Deal with reference assignment\n         // ---------------------------------------\n         // If it is a construction of a ref variable, it is a ref assignment\n-        if ((e.op == TOK.construct || e.op == TOK.blit) &&\n+        if ((e.op == EXP.construct || e.op == EXP.blit) &&\n             ((cast(AssignExp)e).memset == MemorySet.referenceInit))\n         {\n             assert(!fp);\n@@ -3329,7 +3338,7 @@ public:\n \n         if (fp)\n         {\n-            while (e1.op == TOK.cast_)\n+            while (e1.op == EXP.cast_)\n             {\n                 CastExp ce = cast(CastExp)e1;\n                 e1 = ce.e1;\n@@ -3342,7 +3351,7 @@ public:\n         AssocArrayLiteralExp existingAA = null;\n         Expression lastIndex = null;\n         Expression oldval = null;\n-        if (e1.op == TOK.index && (cast(IndexExp)e1).e1.type.toBasetype().ty == Taarray)\n+        if (e1.op == EXP.index && (cast(IndexExp)e1).e1.type.toBasetype().ty == Taarray)\n         {\n             // ---------------------------------------\n             //      Deal with AA index assignment\n@@ -3356,7 +3365,7 @@ public:\n              */\n             IndexExp ie = cast(IndexExp)e1;\n             int depth = 0; // how many nested AA indices are there?\n-            while (ie.e1.op == TOK.index && (cast(IndexExp)ie.e1).e1.type.toBasetype().ty == Taarray)\n+            while (ie.e1.op == EXP.index && (cast(IndexExp)ie.e1).e1.type.toBasetype().ty == Taarray)\n             {\n                 assert(ie.modifiable);\n                 ie = cast(IndexExp)ie.e1;\n@@ -3430,7 +3439,7 @@ public:\n                 oldval = copyLiteral(e.e1.type.defaultInitLiteral(e.loc)).copy();\n \n                 Expression newaae = oldval;\n-                while (e1.op == TOK.index && (cast(IndexExp)e1).e1.type.toBasetype().ty == Taarray)\n+                while (e1.op == EXP.index && (cast(IndexExp)e1).e1.type.toBasetype().ty == Taarray)\n                 {\n                     Expression ekey = interpretRegion((cast(IndexExp)e1).e2, istate);\n                     if (exceptionOrCant(ekey))\n@@ -3465,13 +3474,13 @@ public:\n             assert(existingAA && lastIndex);\n             e1 = null; // stomp\n         }\n-        else if (e1.op == TOK.arrayLength)\n+        else if (e1.op == EXP.arrayLength)\n         {\n             oldval = interpretRegion(e1, istate);\n             if (exceptionOrCant(oldval))\n                 return;\n         }\n-        else if (e.op == TOK.construct || e.op == TOK.blit)\n+        else if (e.op == EXP.construct || e.op == EXP.blit)\n         {\n             // Unless we have a simple var assignment, we're\n             // only modifying part of the variable. So we need to make sure\n@@ -3501,10 +3510,10 @@ public:\n             if (exceptionOrCant(e1))\n                 return;\n \n-            if (e1.op == TOK.index && (cast(IndexExp)e1).e1.type.toBasetype().ty == Taarray)\n+            if (e1.op == EXP.index && (cast(IndexExp)e1).e1.type.toBasetype().ty == Taarray)\n             {\n                 IndexExp ie = cast(IndexExp)e1;\n-                assert(ie.e1.op == TOK.assocArrayLiteral);\n+                assert(ie.e1.op == EXP.assocArrayLiteral);\n                 existingAA = cast(AssocArrayLiteralExp)ie.e1;\n                 lastIndex = ie.e2;\n             }\n@@ -3516,15 +3525,15 @@ public:\n         Expression newval = interpretRegion(e.e2, istate);\n         if (exceptionOrCant(newval))\n             return;\n-        if (e.op == TOK.blit && newval.op == TOK.int64)\n+        if (e.op == EXP.blit && newval.op == EXP.int64)\n         {\n             Type tbn = e.type.baseElemOf();\n             if (tbn.ty == Tstruct)\n             {\n                 /* Look for special case of struct being initialized with 0.\n                  */\n                 newval = e.type.defaultInitLiteral(e.loc);\n-                if (newval.op == TOK.error)\n+                if (newval.op == EXP.error)\n                 {\n                     result = CTFEExp.cantexp;\n                     return;\n@@ -3554,7 +3563,7 @@ public:\n             if (e.e1.type.ty != Tpointer)\n             {\n                 // ~= can create new values (see bug 6052)\n-                if (e.op == TOK.concatenateAssign || e.op == TOK.concatenateElemAssign || e.op == TOK.concatenateDcharAssign)\n+                if (e.op == EXP.concatenateAssign || e.op == EXP.concatenateElemAssign || e.op == EXP.concatenateDcharAssign)\n                 {\n                     // We need to dup it and repaint the type. For a dynamic array\n                     // we can skip duplication, because it gets copied later anyway.\n@@ -3574,10 +3583,10 @@ public:\n                 newval = (*fp)(e.loc, e.type, oldval, newval).copy();\n             }\n             else if (e.e2.type.isintegral() &&\n-                     (e.op == TOK.addAssign ||\n-                      e.op == TOK.minAssign ||\n-                      e.op == TOK.plusPlus ||\n-                      e.op == TOK.minusMinus))\n+                     (e.op == EXP.addAssign ||\n+                      e.op == EXP.minAssign ||\n+                      e.op == EXP.plusPlus ||\n+                      e.op == EXP.minusMinus))\n             {\n                 newval = pointerArithmetic(e.loc, e.op, e.type, oldval, newval).copy();\n             }\n@@ -3612,7 +3621,7 @@ public:\n             result = ctfeCast(pue, e.loc, e.type, e.type, fp && post ? oldval : newval);\n             return;\n         }\n-        if (e1.op == TOK.arrayLength)\n+        if (e1.op == EXP.arrayLength)\n         {\n             /* Change the assignment from:\n              *  arr.length = n;\n@@ -3692,11 +3701,11 @@ public:\n \n         /* Block assignment or element-wise assignment.\n          */\n-        if (e1.op == TOK.slice ||\n-            e1.op == TOK.vector ||\n-            e1.op == TOK.arrayLiteral ||\n-            e1.op == TOK.string_ ||\n-            e1.op == TOK.null_ && e1.type.toBasetype().ty == Tarray)\n+        if (e1.op == EXP.slice ||\n+            e1.op == EXP.vector ||\n+            e1.op == EXP.arrayLiteral ||\n+            e1.op == EXP.string_ ||\n+            e1.op == EXP.null_ && e1.type.toBasetype().ty == Tarray)\n         {\n             // Note that slice assignments don't support things like ++, so\n             // we don't need to remember 'returnValue'.\n@@ -3709,8 +3718,8 @@ public:\n                 if (auto dve = e1x.isDotVarExp())\n                 {\n                     auto ex = dve.e1;\n-                    auto sle = ex.op == TOK.structLiteral ? (cast(StructLiteralExp)ex)\n-                             : ex.op == TOK.classReference ? (cast(ClassReferenceExp)ex).value\n+                    auto sle = ex.op == EXP.structLiteral ? (cast(StructLiteralExp)ex)\n+                             : ex.op == EXP.classReference ? (cast(ClassReferenceExp)ex).value\n                              : null;\n                     auto v = dve.var.isVarDeclaration();\n                     if (!sle || !v)\n@@ -3745,7 +3754,7 @@ public:\n             if (v is v2 || !v.isOverlappedWith(v2))\n                 continue;\n             auto e = (*sle.elements)[i];\n-            if (e.op != TOK.void_)\n+            if (e.op != EXP.void_)\n                 (*sle.elements)[i] = voidInitLiteral(e.type, v).copy();\n         }\n     }\n@@ -3768,8 +3777,8 @@ public:\n              *  e.v = newval\n              */\n             auto ex = dve.e1;\n-            auto sle = ex.op == TOK.structLiteral ? (cast(StructLiteralExp)ex)\n-                     : ex.op == TOK.classReference ? (cast(ClassReferenceExp)ex).value\n+            auto sle = ex.op == EXP.structLiteral ? (cast(StructLiteralExp)ex)\n+                     : ex.op == EXP.classReference ? (cast(ClassReferenceExp)ex).value\n                      : null;\n             auto v = (cast(DotVarExp)e1).var.isVarDeclaration();\n             if (!sle || !v)\n@@ -3783,7 +3792,7 @@ public:\n                 return CTFEExp.cantexp;\n             }\n \n-            int fieldi = ex.op == TOK.structLiteral ? findFieldIndexByName(sle.sd, v)\n+            int fieldi = ex.op == EXP.structLiteral ? findFieldIndexByName(sle.sd, v)\n                        : (cast(ClassReferenceExp)ex).findFieldIndexByName(v);\n             if (fieldi == -1)\n             {\n@@ -3820,7 +3829,7 @@ public:\n                 existingSE.setCodeUnit(index, cast(dchar)newval.toInteger());\n                 return null;\n             }\n-            if (aggregate.op != TOK.arrayLiteral)\n+            if (aggregate.op != EXP.arrayLiteral)\n             {\n                 e.error(\"index assignment `%s` is not yet supported in CTFE \", e.toChars());\n                 return CTFEExp.cantexp;\n@@ -3848,21 +3857,21 @@ public:\n         if (auto ve = newval.isVectorExp())\n         {\n             // Ensure ve is an array literal, and not a broadcast\n-            if (ve.e1.op == TOK.int64 || ve.e1.op == TOK.float64) // if broadcast\n+            if (ve.e1.op == EXP.int64 || ve.e1.op == EXP.float64) // if broadcast\n             {\n                 UnionExp ue = void;\n                 Expression ex = interpretVectorToArray(&ue, ve);\n                 ve.e1 = (ex == ue.exp()) ? ue.copy() : ex;\n             }\n         }\n \n-        if (newval.op == TOK.structLiteral && oldval)\n+        if (newval.op == EXP.structLiteral && oldval)\n         {\n-            assert(oldval.op == TOK.structLiteral || oldval.op == TOK.arrayLiteral || oldval.op == TOK.string_);\n+            assert(oldval.op == EXP.structLiteral || oldval.op == EXP.arrayLiteral || oldval.op == EXP.string_);\n             newval = copyLiteral(newval).copy();\n             assignInPlace(oldval, newval);\n         }\n-        else if (wantCopy && e.op == TOK.assign)\n+        else if (wantCopy && e.op == EXP.assign)\n         {\n             // Currently postblit/destructor calls on static array are done\n             // in the druntime internal functions so they don't appear in AST.\n@@ -3878,8 +3887,8 @@ public:\n                     return CTFEExp.cantexp;\n                 }\n             }\n-            assert(oldval.op == TOK.arrayLiteral);\n-            assert(newval.op == TOK.arrayLiteral);\n+            assert(oldval.op == EXP.arrayLiteral);\n+            assert(newval.op == EXP.arrayLiteral);\n \n             Expressions* oldelems = (cast(ArrayLiteralExp)oldval).elements;\n             Expressions* newelems = (cast(ArrayLiteralExp)newval).elements;\n@@ -3907,7 +3916,7 @@ public:\n             if (wantCopy)\n                 newval = copyLiteral(newval).copy();\n \n-            if (t1b.ty == Tsarray && e.op == TOK.construct && e.e2.isLvalue())\n+            if (t1b.ty == Tsarray && e.op == EXP.construct && e.e2.isLvalue())\n             {\n                 // https://issues.dlang.org/show_bug.cgi?id=9245\n                 if (Expression ex = evaluatePostblit(istate, newval))\n@@ -3923,7 +3932,7 @@ public:\n             *payload = oldval;\n \n         // Blit assignment should return the newly created value.\n-        if (e.op == TOK.blit)\n+        if (e.op == EXP.blit)\n             return oldval;\n \n         return null;\n@@ -3938,7 +3947,7 @@ public:\n      * This could be a slice assignment or a block assignment, and\n      * dest could be either an array literal, or a string.\n      *\n-     * Returns TOK.cantExpression on failure. If there are no errors,\n+     * Returns EXP.cantExpression on failure. If there are no errors,\n      * it returns aggregate[low..upp], except that as an optimisation,\n      * if goal == CTFEGoal.Nothing, it will return NULL\n      */\n@@ -4024,7 +4033,7 @@ public:\n                 lowerbound = 0;\n                 upperbound = se.len;\n             }\n-            else if (e1.op == TOK.null_)\n+            else if (e1.op == EXP.null_)\n             {\n                 lowerbound = 0;\n                 upperbound = 0;\n@@ -4088,7 +4097,7 @@ public:\n                         return CTFEExp.cantexp;\n                     }\n                 }\n-                assert(newval.op != TOK.slice);\n+                assert(newval.op != EXP.slice);\n             }\n             if (auto se = newval.isStringExp())\n             {\n@@ -4126,7 +4135,7 @@ public:\n                 return CTFEExp.cantexp;\n             }\n \n-            if (newval.op == TOK.slice && !isBlockAssignment)\n+            if (newval.op == EXP.slice && !isBlockAssignment)\n             {\n                 auto se = cast(SliceExp)newval;\n                 auto aggr2 = se.e1;\n@@ -4142,7 +4151,7 @@ public:\n                     // Currently overlapping for struct array is allowed.\n                     // The order of elements processing depends on the overlapping.\n                     // https://issues.dlang.org/show_bug.cgi?id=14024\n-                    assert(aggr2.op == TOK.arrayLiteral);\n+                    assert(aggr2.op == EXP.arrayLiteral);\n                     Expressions* oldelems = existingAE.elements;\n                     Expressions* newelems = (cast(ArrayLiteralExp)aggr2).elements;\n \n@@ -4210,22 +4219,22 @@ public:\n                 }\n                 // no overlapping\n                 //length?\n-                assert(newval.op != TOK.slice);\n+                assert(newval.op != EXP.slice);\n             }\n-            if (newval.op == TOK.string_ && !isBlockAssignment)\n+            if (newval.op == EXP.string_ && !isBlockAssignment)\n             {\n                 /* Mixed slice: it was initialized as an array literal of chars/integers.\n                  * Now a slice of it is being set with a string.\n                  */\n                 sliceAssignArrayLiteralFromString(existingAE, cast(StringExp)newval, cast(size_t)firstIndex);\n                 return newval;\n             }\n-            if (newval.op == TOK.arrayLiteral && !isBlockAssignment)\n+            if (newval.op == EXP.arrayLiteral && !isBlockAssignment)\n             {\n                 Expressions* oldelems = existingAE.elements;\n                 Expressions* newelems = (cast(ArrayLiteralExp)newval).elements;\n                 Type elemtype = existingAE.type.nextOf();\n-                bool needsPostblit = e.op != TOK.blit && e.e2.isLvalue();\n+                bool needsPostblit = e.op != EXP.blit && e.e2.isLvalue();\n                 foreach (j, newelem; *newelems)\n                 {\n                     newelem = paintTypeOntoLiteral(elemtype, newelem);\n@@ -4265,7 +4274,7 @@ public:\n                     bool directblk = (cast(TypeArray)ae.type).next.equivalent(newval.type);\n                     for (size_t k = lwr; k < upr; k++)\n                     {\n-                        if (!directblk && (*w)[k].op == TOK.arrayLiteral)\n+                        if (!directblk && (*w)[k].op == EXP.arrayLiteral)\n                         {\n                             // Multidimensional array block assign\n                             if (Expression ex = assignTo(cast(ArrayLiteralExp)(*w)[k]))\n@@ -4303,16 +4312,16 @@ public:\n \n             Type tn = newval.type.toBasetype();\n             bool wantRef = (tn.ty == Tarray || isAssocArray(tn) || tn.ty == Tclass);\n-            bool cow = newval.op != TOK.structLiteral && newval.op != TOK.arrayLiteral && newval.op != TOK.string_;\n+            bool cow = newval.op != EXP.structLiteral && newval.op != EXP.arrayLiteral && newval.op != EXP.string_;\n             Type tb = tn.baseElemOf();\n             StructDeclaration sd = (tb.ty == Tstruct ? (cast(TypeStruct)tb).sym : null);\n \n             RecursiveBlock rb;\n             rb.istate = istate;\n             rb.newval = newval;\n             rb.refCopy = wantRef || cow;\n-            rb.needsPostblit = sd && sd.postblit && e.op != TOK.blit && e.e2.isLvalue();\n-            rb.needsDtor = sd && sd.dtor && e.op == TOK.assign;\n+            rb.needsPostblit = sd && sd.postblit && e.op != EXP.blit && e.e2.isLvalue();\n+            rb.needsDtor = sd && sd.dtor && e.op == EXP.assign;\n             if (Expression ex = rb.assignTo(existingAE, cast(size_t)lowerbound, cast(size_t)upperbound))\n                 return ex;\n \n@@ -4338,57 +4347,57 @@ public:\n     {\n         switch (e.op)\n         {\n-        case TOK.addAssign:\n+        case EXP.addAssign:\n             interpretAssignCommon(e, &Add);\n             return;\n \n-        case TOK.minAssign:\n+        case EXP.minAssign:\n             interpretAssignCommon(e, &Min);\n             return;\n \n-        case TOK.concatenateAssign:\n-        case TOK.concatenateElemAssign:\n-        case TOK.concatenateDcharAssign:\n+        case EXP.concatenateAssign:\n+        case EXP.concatenateElemAssign:\n+        case EXP.concatenateDcharAssign:\n             interpretAssignCommon(e, &ctfeCat);\n             return;\n \n-        case TOK.mulAssign:\n+        case EXP.mulAssign:\n             interpretAssignCommon(e, &Mul);\n             return;\n \n-        case TOK.divAssign:\n+        case EXP.divAssign:\n             interpretAssignCommon(e, &Div);\n             return;\n \n-        case TOK.modAssign:\n+        case EXP.modAssign:\n             interpretAssignCommon(e, &Mod);\n             return;\n \n-        case TOK.leftShiftAssign:\n+        case EXP.leftShiftAssign:\n             interpretAssignCommon(e, &Shl);\n             return;\n \n-        case TOK.rightShiftAssign:\n+        case EXP.rightShiftAssign:\n             interpretAssignCommon(e, &Shr);\n             return;\n \n-        case TOK.unsignedRightShiftAssign:\n+        case EXP.unsignedRightShiftAssign:\n             interpretAssignCommon(e, &Ushr);\n             return;\n \n-        case TOK.andAssign:\n+        case EXP.andAssign:\n             interpretAssignCommon(e, &And);\n             return;\n \n-        case TOK.orAssign:\n+        case EXP.orAssign:\n             interpretAssignCommon(e, &Or);\n             return;\n \n-        case TOK.xorAssign:\n+        case EXP.xorAssign:\n             interpretAssignCommon(e, &Xor);\n             return;\n \n-        case TOK.powAssign:\n+        case EXP.powAssign:\n             interpretAssignCommon(e, &Pow);\n             return;\n \n@@ -4403,7 +4412,7 @@ public:\n         {\n             printf(\"%s PostExp::interpret() %s\\n\", e.loc.toChars(), e.toChars());\n         }\n-        if (e.op == TOK.plusPlus)\n+        if (e.op == EXP.plusPlus)\n             interpretAssignCommon(e, &Add, 1);\n         else\n             interpretAssignCommon(e, &Min, 1);\n@@ -4421,19 +4430,19 @@ public:\n     static int isPointerCmpExp(Expression e, Expression* p1, Expression* p2)\n     {\n         int ret = 1;\n-        while (e.op == TOK.not)\n+        while (e.op == EXP.not)\n         {\n             ret *= -1;\n             e = (cast(NotExp)e).e1;\n         }\n         switch (e.op)\n         {\n-        case TOK.lessThan:\n-        case TOK.lessOrEqual:\n+        case EXP.lessThan:\n+        case EXP.lessOrEqual:\n             ret *= -1;\n             goto case; /+ fall through +/\n-        case TOK.greaterThan:\n-        case TOK.greaterOrEqual:\n+        case EXP.greaterThan:\n+        case EXP.greaterOrEqual:\n             *p1 = (cast(BinExp)e).e1;\n             *p2 = (cast(BinExp)e).e2;\n             if (!(isPointer((*p1).type) && isPointer((*p2).type)))\n@@ -4465,7 +4474,7 @@ public:\n      */\n     private void interpretFourPointerRelation(UnionExp* pue, BinExp e)\n     {\n-        assert(e.op == TOK.andAnd || e.op == TOK.orOr);\n+        assert(e.op == EXP.andAnd || e.op == EXP.orOr);\n \n         /*  It can only be an isInside expression, if both e1 and e2 are\n          *  directional pointer comparisons.\n@@ -4506,7 +4515,7 @@ public:\n         Expression agg1 = getAggregateFromPointer(p1, &ofs1);\n         Expression agg2 = getAggregateFromPointer(p2, &ofs2);\n \n-        if (!pointToSameMemoryBlock(agg1, agg2) && agg1.op != TOK.null_ && agg2.op != TOK.null_)\n+        if (!pointToSameMemoryBlock(agg1, agg2) && agg1.op != EXP.null_ && agg2.op != EXP.null_)\n         {\n             // Here it is either CANT_INTERPRET,\n             // or an IsInside comparison returning false.\n@@ -4545,7 +4554,7 @@ public:\n                 (dir1 != dir2 && pointToSameMemoryBlock(agg1, agg3) && pointToSameMemoryBlock(agg2, agg4)))\n             {\n                 // it's a legal two-sided comparison\n-                emplaceExp!(IntegerExp)(pue, e.loc, (e.op == TOK.andAnd) ? 0 : 1, e.type);\n+                emplaceExp!(IntegerExp)(pue, e.loc, (e.op == EXP.andAnd) ? 0 : 1, e.type);\n                 result = pue.exp();\n                 return;\n             }\n@@ -4582,29 +4591,29 @@ public:\n          * Returns:\n          *      negate operator\n          */\n-        static TOK negateRelation(TOK op) pure\n+        static EXP negateRelation(EXP op) pure\n         {\n             switch (op)\n             {\n-                case TOK.greaterOrEqual:  op = TOK.lessThan;       break;\n-                case TOK.greaterThan:     op = TOK.lessOrEqual;    break;\n-                case TOK.lessOrEqual:     op = TOK.greaterThan;    break;\n-                case TOK.lessThan:        op = TOK.greaterOrEqual; break;\n+                case EXP.greaterOrEqual:  op = EXP.lessThan;       break;\n+                case EXP.greaterThan:     op = EXP.lessOrEqual;    break;\n+                case EXP.lessOrEqual:     op = EXP.greaterThan;    break;\n+                case EXP.lessThan:        op = EXP.greaterOrEqual; break;\n                 default:                  assert(0);\n             }\n             return op;\n         }\n \n-        const TOK cmpop = nott ? negateRelation(ex.op) : ex.op;\n+        const EXP cmpop = nott ? negateRelation(ex.op) : ex.op;\n         const cmp = comparePointers(cmpop, agg1, ofs1, agg2, ofs2);\n         // We already know this is a valid comparison.\n         assert(cmp >= 0);\n-        if (e.op == TOK.andAnd && cmp == 1 || e.op == TOK.orOr && cmp == 0)\n+        if (e.op == EXP.andAnd && cmp == 1 || e.op == EXP.orOr && cmp == 0)\n         {\n             result = interpret(pue, e.e2, istate);\n             return;\n         }\n-        emplaceExp!(IntegerExp)(pue, e.loc, (e.op == TOK.andAnd) ? 0 : 1, e.type);\n+        emplaceExp!(IntegerExp)(pue, e.loc, (e.op == EXP.andAnd) ? 0 : 1, e.type);\n         result = pue.exp();\n     }\n \n@@ -4625,22 +4634,22 @@ public:\n             return;\n \n         bool res;\n-        const andand = e.op == TOK.andAnd;\n-        if (andand ? result.isBool(false) : isTrueBool(result))\n+        const andand = e.op == EXP.andAnd;\n+        if (andand ? result.toBool().hasValue(false) : isTrueBool(result))\n             res = !andand;\n-        else if (andand ? isTrueBool(result) : result.isBool(false))\n+        else if (andand ? isTrueBool(result) : result.toBool().hasValue(false))\n         {\n             UnionExp ue2 = void;\n             result = interpret(&ue2, e.e2, istate);\n             if (exceptionOrCant(result))\n                 return;\n-            if (result.op == TOK.voidExpression)\n+            if (result.op == EXP.voidExpression)\n             {\n                 assert(e.type.ty == Tvoid);\n                 result = null;\n                 return;\n             }\n-            if (result.isBool(false))\n+            if (result.toBool().hasValue(false))\n                 res = false;\n             else if (isTrueBool(result))\n                 res = true;\n@@ -4762,8 +4771,8 @@ public:\n                 if (auto ce = ea.isCastExp())\n                     ea = ce.e1;\n \n-                // printf(\"2 ea = %s, %s %s\\n\", ea.type.toChars(), Token.toChars(ea.op), ea.toChars());\n-                if (ea.op == TOK.variable || ea.op == TOK.symbolOffset)\n+                // printf(\"2 ea = %s, %s %s\\n\", ea.type.toChars(), EXPtoString(ea.op).ptr, ea.toChars());\n+                if (ea.op == EXP.variable || ea.op == EXP.symbolOffset)\n                     result = getVarExp(e.loc, istate, (cast(SymbolExp)ea).var, CTFEGoal.RValue);\n                 else if (auto ae = ea.isAddrExp())\n                     result = interpretRegion(ae.e1, istate);\n@@ -4805,6 +4814,29 @@ public:\n                 result = interpretRegion(ae, istate);\n                 return;\n             }\n+            else if (fd.ident == Id._d_arrayctor || fd.ident == Id._d_arraysetctor)\n+            {\n+                // In expressionsem.d `T[x] ea = eb;` was lowered to `_d_array{,set}ctor(ea[], eb[]);`.\n+                // The following code will rewrite it back to `ea = eb` and then interpret that expression.\n+                if (fd.ident == Id._d_arraysetctor)\n+                    assert(e.arguments.dim == 2);\n+                else\n+                    assert(e.arguments.dim == 3);\n+\n+                Expression ea = (*e.arguments)[0];\n+                if (ea.isCastExp)\n+                    ea = ea.isCastExp.e1;\n+\n+                Expression eb = (*e.arguments)[1];\n+                if (eb.isCastExp && fd.ident == Id._d_arrayctor)\n+                    eb = eb.isCastExp.e1;\n+\n+                ConstructExp ce = new ConstructExp(e.loc, ea, eb);\n+                ce.type = ea.type;\n+\n+                result = interpret(ce, istate);\n+                return;\n+            }\n         }\n         else if (auto soe = ecall.isSymOffExp())\n         {\n@@ -4848,23 +4880,23 @@ public:\n             // Currently this is satisfied because closure is not yet supported.\n             assert(!fd.isNested() || fd.needThis());\n \n-            if (pthis.op == TOK.typeid_)\n+            if (pthis.op == EXP.typeid_)\n             {\n                 pthis.error(\"static variable `%s` cannot be read at compile time\", pthis.toChars());\n                 result = CTFEExp.cantexp;\n                 return;\n             }\n             assert(pthis);\n \n-            if (pthis.op == TOK.null_)\n+            if (pthis.op == EXP.null_)\n             {\n                 assert(pthis.type.toBasetype().ty == Tclass);\n                 e.error(\"function call through null class reference `%s`\", pthis.toChars());\n                 result = CTFEExp.cantexp;\n                 return;\n             }\n \n-            assert(pthis.op == TOK.structLiteral || pthis.op == TOK.classReference || pthis.op == TOK.type);\n+            assert(pthis.op == EXP.structLiteral || pthis.op == EXP.classReference || pthis.op == EXP.type);\n \n             if (fd.isVirtual() && !e.directcall)\n             {\n@@ -4899,7 +4931,7 @@ public:\n         }\n \n         result = interpretFunction(pue, fd, istate, e.arguments, pthis);\n-        if (result.op == TOK.voidExpression)\n+        if (result.op == EXP.voidExpression)\n             return;\n         if (!exceptionOrCantInterpret(result))\n         {\n@@ -4929,7 +4961,7 @@ public:\n         // If it creates a variable, and there's no context for\n         // the variable to be created in, we need to create one now.\n         InterState istateComma;\n-        if (!istate && firstComma(e.e1).op == TOK.declaration)\n+        if (!istate && firstComma(e.e1).op == EXP.declaration)\n         {\n             ctfeGlobals.stack.startFrame(null);\n             istate = &istateComma;\n@@ -4946,8 +4978,8 @@ public:\n \n         // If the comma returns a temporary variable, it needs to be an lvalue\n         // (this is particularly important for struct constructors)\n-        if (e.e1.op == TOK.declaration &&\n-            e.e2.op == TOK.variable &&\n+        if (e.e1.op == EXP.declaration &&\n+            e.e2.op == EXP.variable &&\n             e.e1.isDeclarationExp().declaration == e.e2.isVarExp().var &&\n             e.e2.isVarExp().var.storage_class & STC.ctfe)\n         {\n@@ -4967,7 +4999,7 @@ public:\n                 newval = interpretRegion(newval, istate);\n                 if (exceptionOrCant(newval))\n                     return endTempStackFrame();\n-                if (newval.op != TOK.voidExpression)\n+                if (newval.op != EXP.voidExpression)\n                 {\n                     // v isn't necessarily null.\n                     setValueWithoutChecking(v, copyLiteral(newval).copy());\n@@ -4999,7 +5031,7 @@ public:\n \n         if (isPointer(e.econd.type))\n         {\n-            if (econd.op != TOK.null_)\n+            if (econd.op != EXP.null_)\n             {\n                 econd = IntegerExp.createBool(true);\n             }\n@@ -5010,7 +5042,7 @@ public:\n             result = interpret(pue, e.e1, istate, goal);\n             incUsageCtfe(istate, e.e1.loc);\n         }\n-        else if (econd.isBool(false))\n+        else if (econd.toBool().hasValue(false))\n         {\n             result = interpret(pue, e.e2, istate, goal);\n             incUsageCtfe(istate, e.e2.loc);\n@@ -5033,7 +5065,7 @@ public:\n         assert(e1);\n         if (exceptionOrCant(e1))\n             return;\n-        if (e1.op != TOK.string_ && e1.op != TOK.arrayLiteral && e1.op != TOK.slice && e1.op != TOK.null_)\n+        if (e1.op != EXP.string_ && e1.op != EXP.arrayLiteral && e1.op != EXP.slice && e1.op != EXP.null_)\n         {\n             e.error(\"`%s` cannot be evaluated at compile time\", e.toChars());\n             result = CTFEExp.cantexp;\n@@ -5055,7 +5087,7 @@ public:\n     {\n         if (auto ale = e.e1.isArrayLiteralExp())\n             return ale;         // it's already an array literal\n-        if (e.e1.op == TOK.int64 || e.e1.op == TOK.float64)\n+        if (e.e1.op == EXP.int64 || e.e1.op == EXP.float64)\n         {\n             // Convert literal __vector(int) -> __vector([array])\n             auto elements = new Expressions(e.dim);\n@@ -5086,7 +5118,7 @@ public:\n         assert(e1);\n         if (exceptionOrCant(e1))\n             return;\n-        if (e1.op != TOK.arrayLiteral && e1.op != TOK.int64 && e1.op != TOK.float64)\n+        if (e1.op != EXP.arrayLiteral && e1.op != EXP.int64 && e1.op != EXP.float64)\n         {\n             e.error(\"`%s` cannot be evaluated at compile time\", e.toChars());\n             result = CTFEExp.cantexp;\n@@ -5115,7 +5147,7 @@ public:\n         if (auto ve = e1.isVectorExp())\n         {\n             result = interpretVectorToArray(pue, ve);\n-            if (result.op != TOK.vector)\n+            if (result.op != EXP.vector)\n                 return;\n         }\n         e.error(\"`%s` cannot be evaluated at compile time\", e.toChars());\n@@ -5169,24 +5201,24 @@ public:\n             dinteger_t ofs;\n             Expression agg = getAggregateFromPointer(e1, &ofs);\n \n-            if (agg.op == TOK.null_)\n+            if (agg.op == EXP.null_)\n             {\n                 e.error(\"cannot index through null pointer `%s`\", e.e1.toChars());\n                 return false;\n             }\n-            if (agg.op == TOK.int64)\n+            if (agg.op == EXP.int64)\n             {\n                 e.error(\"cannot index through invalid pointer `%s` of value `%s`\", e.e1.toChars(), e1.toChars());\n                 return false;\n             }\n             // Pointer to a non-array variable\n-            if (agg.op == TOK.symbolOffset)\n+            if (agg.op == EXP.symbolOffset)\n             {\n                 e.error(\"mutable variable `%s` cannot be %s at compile time, even through a pointer\", cast(char*)(modify ? \"modified\" : \"read\"), (cast(SymOffExp)agg).var.toChars());\n                 return false;\n             }\n \n-            if (agg.op == TOK.arrayLiteral || agg.op == TOK.string_)\n+            if (agg.op == EXP.arrayLiteral || agg.op == EXP.string_)\n             {\n                 dinteger_t len = resolveArrayLength(agg);\n                 if (ofs + indx >= len)\n@@ -5211,7 +5243,7 @@ public:\n         Expression e1 = interpretRegion(e.e1, istate);\n         if (exceptionOrCantInterpret(e1))\n             return false;\n-        if (e1.op == TOK.null_)\n+        if (e1.op == EXP.null_)\n         {\n             e.error(\"cannot index null array `%s`\", e.e1.toChars());\n             return false;\n@@ -5225,11 +5257,11 @@ public:\n \n         // Set the $ variable, and find the array literal to modify\n         dinteger_t len;\n-        if (e1.op == TOK.variable && e1.type.toBasetype().ty == Tsarray)\n+        if (e1.op == EXP.variable && e1.type.toBasetype().ty == Tsarray)\n             len = e1.type.toBasetype().isTypeSArray().dim.toInteger();\n         else\n         {\n-            if (e1.op != TOK.arrayLiteral && e1.op != TOK.string_ && e1.op != TOK.slice && e1.op != TOK.vector)\n+            if (e1.op != EXP.arrayLiteral && e1.op != EXP.string_ && e1.op != EXP.slice && e1.op != EXP.vector)\n             {\n                 e.error(\"cannot determine length of `%s` at compile time\", e.e1.toChars());\n                 return false;\n@@ -5248,7 +5280,7 @@ public:\n             ctfeGlobals.stack.pop(e.lengthVar); // $ is defined only inside []\n         if (exceptionOrCantInterpret(e2))\n             return false;\n-        if (e2.op != TOK.int64)\n+        if (e2.op != EXP.int64)\n         {\n             e.error(\"CTFE internal error: non-integral index `[%s]`\", e.e2.toChars());\n             return false;\n@@ -5297,7 +5329,7 @@ public:\n                 result = CTFEExp.cantexp;\n                 return;\n             }\n-            if (agg.op == TOK.arrayLiteral || agg.op == TOK.string_)\n+            if (agg.op == EXP.arrayLiteral || agg.op == EXP.string_)\n             {\n                 if (goal == CTFEGoal.LValue)\n                 {\n@@ -5327,7 +5359,7 @@ public:\n             Expression e1 = interpretRegion(e.e1, istate);\n             if (exceptionOrCant(e1))\n                 return;\n-            if (e1.op == TOK.null_)\n+            if (e1.op == EXP.null_)\n             {\n                 if (goal == CTFEGoal.LValue && e1.type.ty == Taarray && e.modifiable)\n                 {\n@@ -5355,7 +5387,7 @@ public:\n                 return;\n             }\n \n-            assert(e1.op == TOK.assocArrayLiteral);\n+            assert(e1.op == EXP.assocArrayLiteral);\n             UnionExp e2tmp = void;\n             e2 = resolveSlice(e2, &e2tmp);\n             result = findKeyInAA(e.loc, cast(AssocArrayLiteralExp)e1, e2);\n@@ -5387,7 +5419,7 @@ public:\n         result = ctfeIndex(pue, e.loc, e.type, agg, indexToAccess);\n         if (exceptionOrCant(result))\n             return;\n-        if (result.op == TOK.void_)\n+        if (result.op == EXP.void_)\n         {\n             e.error(\"`%s` is used before initialized\", e.toChars());\n             errorSupplemental(result.loc, \"originally uninitialized here\");\n@@ -5410,7 +5442,7 @@ public:\n             Expression e1 = interpretRegion(e.e1, istate);\n             if (exceptionOrCant(e1))\n                 return;\n-            if (e1.op == TOK.int64)\n+            if (e1.op == EXP.int64)\n             {\n                 e.error(\"cannot slice invalid pointer `%s` of value `%s`\", e.e1.toChars(), e1.toChars());\n                 result = CTFEExp.cantexp;\n@@ -5432,7 +5464,7 @@ public:\n             Expression agg = getAggregateFromPointer(e1, &ofs);\n             ilwr += ofs;\n             iupr += ofs;\n-            if (agg.op == TOK.null_)\n+            if (agg.op == EXP.null_)\n             {\n                 if (iupr == ilwr)\n                 {\n@@ -5444,19 +5476,19 @@ public:\n                 result = CTFEExp.cantexp;\n                 return;\n             }\n-            if (agg.op == TOK.symbolOffset)\n+            if (agg.op == EXP.symbolOffset)\n             {\n                 e.error(\"slicing pointers to static variables is not supported in CTFE\");\n                 result = CTFEExp.cantexp;\n                 return;\n             }\n-            if (agg.op != TOK.arrayLiteral && agg.op != TOK.string_)\n+            if (agg.op != EXP.arrayLiteral && agg.op != EXP.string_)\n             {\n                 e.error(\"pointer `%s` cannot be sliced at compile time (it does not point to an array)\", e.e1.toChars());\n                 result = CTFEExp.cantexp;\n                 return;\n             }\n-            assert(agg.op == TOK.arrayLiteral || agg.op == TOK.string_);\n+            assert(agg.op == EXP.arrayLiteral || agg.op == EXP.string_);\n             dinteger_t len = ArrayLength(Type.tsize_t, agg).exp().toInteger();\n             //Type *pointee = ((TypePointer *)agg.type)->next;\n             if (iupr > (len + 1) || iupr < ilwr)\n@@ -5503,11 +5535,11 @@ public:\n         /* Set dollar to the length of the array\n          */\n         uinteger_t dollar;\n-        if ((e1.op == TOK.variable || e1.op == TOK.dotVariable) && e1.type.toBasetype().ty == Tsarray)\n+        if ((e1.op == EXP.variable || e1.op == EXP.dotVariable) && e1.type.toBasetype().ty == Tsarray)\n             dollar = e1.type.toBasetype().isTypeSArray().dim.toInteger();\n         else\n         {\n-            if (e1.op != TOK.arrayLiteral && e1.op != TOK.string_ && e1.op != TOK.null_ && e1.op != TOK.slice && e1.op != TOK.vector)\n+            if (e1.op != EXP.arrayLiteral && e1.op != EXP.string_ && e1.op != EXP.null_ && e1.op != EXP.slice && e1.op != EXP.vector)\n             {\n                 e.error(\"cannot determine length of `%s` at compile time\", e1.toChars());\n                 result = CTFEExp.cantexp;\n@@ -5546,7 +5578,7 @@ public:\n \n         uinteger_t ilwr = lwr.toInteger();\n         uinteger_t iupr = upr.toInteger();\n-        if (e1.op == TOK.null_)\n+        if (e1.op == EXP.null_)\n         {\n             if (ilwr == 0 && iupr == 0)\n             {\n@@ -5578,7 +5610,7 @@ public:\n             result.type = e.type;\n             return;\n         }\n-        if (e1.op == TOK.arrayLiteral || e1.op == TOK.string_)\n+        if (e1.op == EXP.arrayLiteral || e1.op == EXP.string_)\n         {\n             if (iupr < ilwr || dollar < iupr)\n             {\n@@ -5604,13 +5636,13 @@ public:\n         Expression e2 = interpretRegion(e.e2, istate);\n         if (exceptionOrCant(e2))\n             return;\n-        if (e2.op == TOK.null_)\n+        if (e2.op == EXP.null_)\n         {\n             emplaceExp!(NullExp)(pue, e.loc, e.type);\n             result = pue.exp();\n             return;\n         }\n-        if (e2.op != TOK.assocArrayLiteral)\n+        if (e2.op != EXP.assocArrayLiteral)\n         {\n             e.error(\"`%s` cannot be interpreted at compile time\", e.toChars());\n             result = CTFEExp.cantexp;\n@@ -5663,7 +5695,7 @@ public:\n          * result in [x,y] and then x or y is on the stack.\n          * But if they are both strings, we can, because it isn't the x~[y] case.\n          */\n-        if (!(e1.op == TOK.string_ && e2.op == TOK.string_))\n+        if (!(e1.op == EXP.string_ && e2.op == EXP.string_))\n         {\n             if (e1 == ue1.exp())\n                 e1 = ue1.copy();\n@@ -5706,7 +5738,7 @@ public:\n         if (exceptionOrCant(result))\n             return;\n \n-        if (result.op == TOK.null_)\n+        if (result.op == EXP.null_)\n         {\n             result = CTFEExp.voidexp;\n             return;\n@@ -5716,7 +5748,7 @@ public:\n         switch (tb.ty)\n         {\n         case Tclass:\n-            if (result.op != TOK.classReference)\n+            if (result.op != EXP.classReference)\n             {\n                 e.error(\"`delete` on invalid class reference `%s`\", result.toChars());\n                 result = CTFEExp.cantexp;\n@@ -5752,8 +5784,8 @@ public:\n             tb = (cast(TypePointer)tb).next.toBasetype();\n             if (tb.ty == Tstruct)\n             {\n-                if (result.op != TOK.address ||\n-                    (cast(AddrExp)result).e1.op != TOK.structLiteral)\n+                if (result.op != EXP.address ||\n+                    (cast(AddrExp)result).e1.op != EXP.structLiteral)\n                 {\n                     e.error(\"`delete` on invalid struct pointer `%s`\", result.toChars());\n                     result = CTFEExp.cantexp;\n@@ -5776,7 +5808,7 @@ public:\n             auto tv = tb.nextOf().baseElemOf();\n             if (tv.ty == Tstruct)\n             {\n-                if (result.op != TOK.arrayLiteral)\n+                if (result.op != EXP.arrayLiteral)\n                 {\n                     e.error(\"`delete` on invalid struct array `%s`\", result.toChars());\n                     result = CTFEExp.cantexp;\n@@ -5819,11 +5851,11 @@ public:\n             result = CTFEExp.voidexp;\n             return;\n         }\n-        if (e.to.ty == Tpointer && e1.op != TOK.null_)\n+        if (e.to.ty == Tpointer && e1.op != EXP.null_)\n         {\n             Type pointee = (cast(TypePointer)e.type).next;\n             // Implement special cases of normally-unsafe casts\n-            if (e1.op == TOK.int64)\n+            if (e1.op == EXP.int64)\n             {\n                 // Happens with Windows HANDLEs, for example.\n                 result = paintTypeOntoLiteral(pue, e.to, e1);\n@@ -5869,7 +5901,7 @@ public:\n \n             if (auto se = e1.isSliceExp())\n             {\n-                if (se.e1.op == TOK.null_)\n+                if (se.e1.op == EXP.null_)\n                 {\n                     result = paintTypeOntoLiteral(pue, e.type, se.e1);\n                     return;\n@@ -5881,7 +5913,7 @@ public:\n                 result = pue.exp();\n                 return;\n             }\n-            if (e1.op == TOK.arrayLiteral || e1.op == TOK.string_)\n+            if (e1.op == EXP.arrayLiteral || e1.op == EXP.string_)\n             {\n                 // Create a CTFE pointer &[1,2,3][0] or &\"abc\"[0]\n                 auto ei = ctfeEmplaceExp!IndexExp(e.loc, e1, ctfeEmplaceExp!IntegerExp(e.loc, 0, Type.tsize_t));\n@@ -5890,7 +5922,7 @@ public:\n                 result = pue.exp();\n                 return;\n             }\n-            if (e1.op == TOK.index && !(cast(IndexExp)e1).e1.type.equals(e1.type))\n+            if (e1.op == EXP.index && !(cast(IndexExp)e1).e1.type.equals(e1.type))\n             {\n                 // type painting operation\n                 IndexExp ie = cast(IndexExp)e1;\n@@ -5899,7 +5931,7 @@ public:\n                     // get the original type. For strings, it's just the type...\n                     Type origType = ie.e1.type.nextOf();\n                     // ..but for arrays of type void*, it's the type of the element\n-                    if (ie.e1.op == TOK.arrayLiteral && ie.e2.op == TOK.int64)\n+                    if (ie.e1.op == EXP.arrayLiteral && ie.e2.op == EXP.int64)\n                     {\n                         ArrayLiteralExp ale = cast(ArrayLiteralExp)ie.e1;\n                         const indx = cast(size_t)ie.e2.toInteger();\n@@ -5939,7 +5971,7 @@ public:\n                     return;\n                 }\n \n-                if (castToSarrayPointer && pointee.toBasetype().ty == Tsarray && ae.e1.op == TOK.index)\n+                if (castToSarrayPointer && pointee.toBasetype().ty == Tsarray && ae.e1.op == EXP.index)\n                 {\n                     // &val[idx]\n                     dinteger_t dim = (cast(TypeSArray)pointee.toBasetype()).dim.toInteger();\n@@ -5956,7 +5988,7 @@ public:\n                 }\n             }\n \n-            if (e1.op == TOK.variable || e1.op == TOK.symbolOffset)\n+            if (e1.op == EXP.variable || e1.op == EXP.symbolOffset)\n             {\n                 // type painting operation\n                 Type origType = (cast(SymbolExp)e1).var.type;\n@@ -5977,7 +6009,7 @@ public:\n \n             // Check if we have a null pointer (eg, inside a struct)\n             e1 = interpretRegion(e1, istate);\n-            if (e1.op != TOK.null_)\n+            if (e1.op != EXP.null_)\n             {\n                 e.error(\"pointer cast from `%s` to `%s` is not supported at compile time\", e1.type.toChars(), e.to.toChars());\n                 result = CTFEExp.cantexp;\n@@ -5990,10 +6022,10 @@ public:\n             e1 = interpretRegion(e.e1, istate);\n             if (exceptionOrCant(e1))\n                 return;\n-            assert(e1.op == TOK.vector);\n+            assert(e1.op == EXP.vector);\n             e1 = interpretVectorToArray(pue, e1.isVectorExp());\n         }\n-        if (e.to.ty == Tarray && e1.op == TOK.slice)\n+        if (e.to.ty == Tarray && e1.op == EXP.slice)\n         {\n             // Note that the slice may be void[], so when checking for dangerous\n             // casts, we need to use the original type, which is se.e1.\n@@ -6023,11 +6055,11 @@ public:\n         auto tobt = e.to.toBasetype();\n         if (tobt.ty == Tbool && e1.type.ty == Tpointer)\n         {\n-            emplaceExp!(IntegerExp)(pue, e.loc, e1.op != TOK.null_, e.to);\n+            emplaceExp!(IntegerExp)(pue, e.loc, e1.op != EXP.null_, e.to);\n             result = pue.exp();\n             return;\n         }\n-        else if (tobt.isTypeBasic() && e1.op == TOK.null_)\n+        else if (tobt.isTypeBasic() && e1.op == EXP.null_)\n         {\n             if (tobt.isintegral())\n                 emplaceExp!(IntegerExp)(pue, e.loc, 0, e.to);\n@@ -6051,7 +6083,7 @@ public:\n         if (isTrueBool(e1))\n         {\n         }\n-        else if (e1.isBool(false))\n+        else if (e1.toBool().hasValue(false))\n         {\n             if (e.msg)\n             {\n@@ -6106,7 +6138,7 @@ public:\n         // Constant fold *(&structliteral + offset)\n         if (auto ae = e.e1.isAddExp())\n         {\n-            if (ae.e1.op == TOK.address && ae.e2.op == TOK.int64)\n+            if (ae.e1.op == EXP.address && ae.e2.op == EXP.int64)\n             {\n                 AddrExp ade = cast(AddrExp)ae.e1;\n                 Expression ex = interpretRegion(ade.e1, istate);\n@@ -6128,7 +6160,7 @@ public:\n         if (exceptionOrCant(result))\n             return;\n \n-        if (result.op == TOK.function_)\n+        if (result.op == EXP.function_)\n             return;\n         if (auto soe = result.isSymOffExp())\n         {\n@@ -6142,9 +6174,9 @@ public:\n         if (result.isStringExp())\n             return;\n \n-        if (result.op != TOK.address)\n+        if (result.op != EXP.address)\n         {\n-            if (result.op == TOK.null_)\n+            if (result.op == EXP.null_)\n                 e.error(\"dereference of null pointer `%s`\", e.e1.toChars());\n             else\n                 e.error(\"dereference of invalid pointer `%s`\", result.toChars());\n@@ -6155,7 +6187,7 @@ public:\n         // *(&x) ==> x\n         result = (cast(AddrExp)result).e1;\n \n-        if (result.op == TOK.slice && e.type.toBasetype().ty == Tsarray)\n+        if (result.op == EXP.slice && e.type.toBasetype().ty == Tsarray)\n         {\n             /* aggr[lwr..upr]\n              * upr may exceed the upper boundary of aggr, but the check is deferred\n@@ -6212,7 +6244,7 @@ public:\n             return;\n         }\n \n-        if (ex.op == TOK.null_)\n+        if (ex.op == EXP.null_)\n         {\n             if (ex.type.toBasetype().ty == Tclass)\n                 e.error(\"class `%s` is `null` and cannot be dereferenced\", e.e1.toChars());\n@@ -6225,18 +6257,18 @@ public:\n         StructLiteralExp se;\n         int i;\n \n-        if (ex.op != TOK.structLiteral && ex.op != TOK.classReference && ex.op != TOK.typeid_)\n+        if (ex.op != EXP.structLiteral && ex.op != EXP.classReference && ex.op != EXP.typeid_)\n         {\n             return notImplementedYet();\n         }\n \n         // We can't use getField, because it makes a copy\n-        if (ex.op == TOK.classReference)\n+        if (ex.op == EXP.classReference)\n         {\n             se = (cast(ClassReferenceExp)ex).value;\n             i = (cast(ClassReferenceExp)ex).findFieldIndexByName(v);\n         }\n-        else if (ex.op == TOK.typeid_)\n+        else if (ex.op == EXP.typeid_)\n         {\n             if (v.ident == Identifier.idPool(\"name\"))\n             {\n@@ -6336,7 +6368,7 @@ public:\n         Expression index = interpret(e.e2, istate);\n         if (exceptionOrCant(index))\n             return;\n-        if (agg.op == TOK.null_)\n+        if (agg.op == EXP.null_)\n         {\n             result = CTFEExp.voidexp;\n             return;\n@@ -6349,7 +6381,7 @@ public:\n         foreach (j, evalue; *valuesx)\n         {\n             Expression ekey = (*keysx)[j];\n-            int eq = ctfeEqual(e.loc, TOK.equal, ekey, index);\n+            int eq = ctfeEqual(e.loc, EXP.equal, ekey, index);\n             if (eq)\n                 ++removed;\n             else if (removed != 0)\n@@ -6435,11 +6467,11 @@ Expression interpretRegion(Expression e, InterState* istate, CTFEGoal goal = CTF\n     // mimicking UnionExp.copy, but with region allocation\n     switch (uexp.op)\n     {\n-        case TOK.cantExpression: return CTFEExp.cantexp;\n-        case TOK.voidExpression: return CTFEExp.voidexp;\n-        case TOK.break_:         return CTFEExp.breakexp;\n-        case TOK.continue_:      return CTFEExp.continueexp;\n-        case TOK.goto_:          return CTFEExp.gotoexp;\n+        case EXP.cantExpression: return CTFEExp.cantexp;\n+        case EXP.voidExpression: return CTFEExp.voidexp;\n+        case EXP.break_:         return CTFEExp.breakexp;\n+        case EXP.continue_:      return CTFEExp.continueexp;\n+        case EXP.goto_:          return CTFEExp.gotoexp;\n         default:                 break;\n     }\n     auto p = ctfeGlobals.region.malloc(uexp.size);\n@@ -6454,7 +6486,7 @@ Expression interpretRegion(Expression e, InterState* istate, CTFEGoal goal = CTF\n  *    istate = context\n  * Returns:\n  *      NULL    continue to next statement\n- *      TOK.cantExpression      cannot interpret statement at compile time\n+ *      EXP.cantExpression      cannot interpret statement at compile time\n  *      !NULL   expression from return statement, or thrown exception\n  */\n Expression interpret(UnionExp* pue, Statement s, InterState* istate)\n@@ -6490,7 +6522,7 @@ private Expression scrubReturnValue(const ref Loc loc, Expression e)\n      */\n     static bool isVoid(const Expression e, bool checkArrayType = false) pure\n     {\n-        if (e.op == TOK.void_)\n+        if (e.op == EXP.void_)\n             return true;\n \n         static bool isEntirelyVoid(const Expressions* elems)\n@@ -6539,7 +6571,7 @@ private Expression scrubReturnValue(const ref Loc loc, Expression e)\n             else\n             {\n                 e = scrubReturnValue(loc, e);\n-                if (CTFEExp.isCantExp(e) || e.op == TOK.error)\n+                if (CTFEExp.isCantExp(e) || e.op == EXP.error)\n                     return e;\n             }\n         }\n@@ -6560,7 +6592,7 @@ private Expression scrubReturnValue(const ref Loc loc, Expression e)\n         return null;\n     }\n \n-    if (e.op == TOK.classReference)\n+    if (e.op == EXP.classReference)\n     {\n         StructLiteralExp sle = (cast(ClassReferenceExp)e).value;\n         if (auto ex = scrubSE(sle))\n@@ -6640,7 +6672,7 @@ private Expression scrubCacheValue(Expression e)\n         return null;\n     }\n \n-    if (e.op == TOK.classReference)\n+    if (e.op == EXP.classReference)\n     {\n         if (auto ex = scrubSE((cast(ClassReferenceExp)e).value))\n             return ex;\n@@ -6717,14 +6749,14 @@ private Expression copyRegionExp(Expression e)\n \n     switch (e.op)\n     {\n-        case TOK.classReference:\n+        case EXP.classReference:\n         {\n             auto cre = e.isClassReferenceExp();\n             cre.value = copyRegionExp(cre.value).isStructLiteralExp();\n             break;\n         }\n \n-        case TOK.structLiteral:\n+        case EXP.structLiteral:\n         {\n             auto sle = e.isStructLiteralExp();\n \n@@ -6754,20 +6786,20 @@ private Expression copyRegionExp(Expression e)\n             return slec;\n         }\n \n-        case TOK.arrayLiteral:\n+        case EXP.arrayLiteral:\n         {\n             auto ale = e.isArrayLiteralExp();\n             ale.basis = copyRegionExp(ale.basis);\n             copyArray(ale.elements);\n             break;\n         }\n \n-        case TOK.assocArrayLiteral:\n+        case EXP.assocArrayLiteral:\n             copyArray(e.isAssocArrayLiteralExp().keys);\n             copyArray(e.isAssocArrayLiteralExp().values);\n             break;\n \n-        case TOK.slice:\n+        case EXP.slice:\n         {\n             auto se = e.isSliceExp();\n             se.e1  = copyRegionExp(se.e1);\n@@ -6776,56 +6808,56 @@ private Expression copyRegionExp(Expression e)\n             break;\n         }\n \n-        case TOK.tuple:\n+        case EXP.tuple:\n         {\n             auto te = e.isTupleExp();\n             te.e0 = copyRegionExp(te.e0);\n             copyArray(te.exps);\n             break;\n         }\n \n-        case TOK.address:\n-        case TOK.delegate_:\n-        case TOK.vector:\n-        case TOK.dotVariable:\n+        case EXP.address:\n+        case EXP.delegate_:\n+        case EXP.vector:\n+        case EXP.dotVariable:\n         {\n             UnaExp ue = cast(UnaExp)e;\n             ue.e1 = copyRegionExp(ue.e1);\n             break;\n         }\n \n-        case TOK.index:\n+        case EXP.index:\n         {\n             BinExp be = cast(BinExp)e;\n             be.e1 = copyRegionExp(be.e1);\n             be.e2 = copyRegionExp(be.e2);\n             break;\n         }\n \n-        case TOK.this_:\n-        case TOK.super_:\n-        case TOK.variable:\n-        case TOK.type:\n-        case TOK.function_:\n-        case TOK.typeid_:\n-        case TOK.string_:\n-        case TOK.int64:\n-        case TOK.error:\n-        case TOK.float64:\n-        case TOK.complex80:\n-        case TOK.null_:\n-        case TOK.void_:\n-        case TOK.symbolOffset:\n-        case TOK.char_:\n+        case EXP.this_:\n+        case EXP.super_:\n+        case EXP.variable:\n+        case EXP.type:\n+        case EXP.function_:\n+        case EXP.typeid_:\n+        case EXP.string_:\n+        case EXP.int64:\n+        case EXP.error:\n+        case EXP.float64:\n+        case EXP.complex80:\n+        case EXP.null_:\n+        case EXP.void_:\n+        case EXP.symbolOffset:\n+        case EXP.char_:\n             break;\n \n-        case TOK.cantExpression:\n-        case TOK.voidExpression:\n-        case TOK.showCtfeContext:\n+        case EXP.cantExpression:\n+        case EXP.voidExpression:\n+        case EXP.showCtfeContext:\n             return e;\n \n         default:\n-            printf(\"e: %s, %s\\n\", Token.toChars(e.op), e.toChars());\n+            printf(\"e: %s, %s\\n\", EXPtoString(e.op).ptr, e.toChars());\n             assert(0);\n     }\n \n@@ -6848,7 +6880,7 @@ private Expression interpret_length(UnionExp* pue, InterState* istate, Expressio\n     if (auto aae = earg.isAssocArrayLiteralExp())\n         len = aae.keys.dim;\n     else\n-        assert(earg.op == TOK.null_);\n+        assert(earg.op == EXP.null_);\n     emplaceExp!(IntegerExp)(pue, earg.loc, len, Type.tsize_t);\n     return pue.exp();\n }\n@@ -6862,12 +6894,12 @@ private Expression interpret_keys(UnionExp* pue, InterState* istate, Expression\n     earg = interpret(pue, earg, istate);\n     if (exceptionOrCantInterpret(earg))\n         return earg;\n-    if (earg.op == TOK.null_)\n+    if (earg.op == EXP.null_)\n     {\n         emplaceExp!(NullExp)(pue, earg.loc, earg.type);\n         return pue.exp();\n     }\n-    if (earg.op != TOK.assocArrayLiteral && earg.type.toBasetype().ty != Taarray)\n+    if (earg.op != EXP.assocArrayLiteral && earg.type.toBasetype().ty != Taarray)\n         return null;\n     AssocArrayLiteralExp aae = earg.isAssocArrayLiteralExp();\n     auto ae = ctfeEmplaceExp!ArrayLiteralExp(aae.loc, returnType, aae.keys);\n@@ -6885,12 +6917,12 @@ private Expression interpret_values(UnionExp* pue, InterState* istate, Expressio\n     earg = interpret(pue, earg, istate);\n     if (exceptionOrCantInterpret(earg))\n         return earg;\n-    if (earg.op == TOK.null_)\n+    if (earg.op == EXP.null_)\n     {\n         emplaceExp!(NullExp)(pue, earg.loc, earg.type);\n         return pue.exp();\n     }\n-    if (earg.op != TOK.assocArrayLiteral && earg.type.toBasetype().ty != Taarray)\n+    if (earg.op != EXP.assocArrayLiteral && earg.type.toBasetype().ty != Taarray)\n         return null;\n     auto aae = earg.isAssocArrayLiteralExp();\n     auto ae = ctfeEmplaceExp!ArrayLiteralExp(aae.loc, returnType, aae.values);\n@@ -6909,12 +6941,12 @@ private Expression interpret_dup(UnionExp* pue, InterState* istate, Expression e\n     earg = interpret(pue, earg, istate);\n     if (exceptionOrCantInterpret(earg))\n         return earg;\n-    if (earg.op == TOK.null_)\n+    if (earg.op == EXP.null_)\n     {\n         emplaceExp!(NullExp)(pue, earg.loc, earg.type);\n         return pue.exp();\n     }\n-    if (earg.op != TOK.assocArrayLiteral && earg.type.toBasetype().ty != Taarray)\n+    if (earg.op != EXP.assocArrayLiteral && earg.type.toBasetype().ty != Taarray)\n         return null;\n     auto aae = copyLiteral(earg).copy().isAssocArrayLiteralExp();\n     for (size_t i = 0; i < aae.keys.dim; i++)\n@@ -6935,7 +6967,7 @@ private Expression interpret_aaApply(UnionExp* pue, InterState* istate, Expressi\n     aa = interpret(aa, istate);\n     if (exceptionOrCantInterpret(aa))\n         return aa;\n-    if (aa.op != TOK.assocArrayLiteral)\n+    if (aa.op != EXP.assocArrayLiteral)\n     {\n         emplaceExp!(IntegerExp)(pue, deleg.loc, 0, Type.tsize_t);\n         return pue.exp();\n@@ -7316,7 +7348,7 @@ private Expression evaluateIfBuiltin(UnionExp* pue, InterState* istate, const re\n     }\n     if (pthis && !fd.fbody && fd.isCtorDeclaration() && fd.parent && fd.parent.parent && fd.parent.parent.ident == Id.object)\n     {\n-        if (pthis.op == TOK.classReference && fd.parent.ident == Id.Throwable)\n+        if (pthis.op == EXP.classReference && fd.parent.ident == Id.Throwable)\n         {\n             // At present, the constructors just copy their arguments into the struct.\n             // But we might need some magic if stack tracing gets added to druntime.\n@@ -7383,7 +7415,7 @@ private Expression evaluatePostblit(InterState* istate, Expression e)\n         }\n         return null;\n     }\n-    if (e.op == TOK.structLiteral)\n+    if (e.op == EXP.structLiteral)\n     {\n         // e.__postblit()\n         UnionExp ue = void;\n@@ -7412,7 +7444,7 @@ private Expression evaluateDtor(InterState* istate, Expression e)\n         foreach_reverse (elem; *ale.elements)\n             e = evaluateDtor(istate, elem);\n     }\n-    else if (e.op == TOK.structLiteral)\n+    else if (e.op == EXP.structLiteral)\n     {\n         // e.__dtor()\n         e = interpretFunction(&ue, sd.dtor, istate, null, e);"}, {"sha": "065968025a63325a880b8f7a272a69a97736071f", "filename": "gcc/d/dmd/dmangle.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fdmangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fdmangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmangle.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -979,15 +979,15 @@ public:\n                     goto Lsa;\n                 }\n                 buf.writeByte('V');\n-                if (ea.op == TOK.tuple)\n+                if (ea.op == EXP.tuple)\n                 {\n                     ea.error(\"tuple is not a valid template value argument\");\n                     continue;\n                 }\n                 // Now that we know it is not an alias, we MUST obtain a value\n                 uint olderr = global.errors;\n                 ea = ea.ctfeInterpret();\n-                if (ea.op == TOK.error || olderr != global.errors)\n+                if (ea.op == EXP.error || olderr != global.errors)\n                     continue;\n \n                 /* Use type mangling that matches what it would be for a function parameter"}, {"sha": "1f05642d301d99a58b7583241361502c7bafccee", "filename": "gcc/d/dmd/dstruct.d", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fdstruct.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fdstruct.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdstruct.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -522,14 +522,14 @@ private bool _isZeroInit(Expression exp)\n {\n     switch (exp.op)\n     {\n-        case TOK.int64:\n+        case EXP.int64:\n             return exp.toInteger() == 0;\n \n-        case TOK.null_:\n-        case TOK.false_:\n+        case EXP.null_:\n+        case EXP.false_:\n             return true;\n \n-        case TOK.structLiteral:\n+        case EXP.structLiteral:\n         {\n             auto sle = cast(StructLiteralExp) exp;\n             foreach (i; 0 .. sle.sd.fields.dim)\n@@ -546,7 +546,7 @@ private bool _isZeroInit(Expression exp)\n             return true;\n         }\n \n-        case TOK.arrayLiteral:\n+        case EXP.arrayLiteral:\n         {\n             auto ale = cast(ArrayLiteralExp)exp;\n \n@@ -566,7 +566,7 @@ private bool _isZeroInit(Expression exp)\n             return true;\n         }\n \n-        case TOK.string_:\n+        case EXP.string_:\n         {\n             StringExp se = cast(StringExp)exp;\n \n@@ -581,14 +581,14 @@ private bool _isZeroInit(Expression exp)\n             return true;\n         }\n \n-        case TOK.vector:\n+        case EXP.vector:\n         {\n             auto ve = cast(VectorExp) exp;\n             return _isZeroInit(ve.e1);\n         }\n \n-        case TOK.float64:\n-        case TOK.complex80:\n+        case EXP.float64:\n+        case EXP.complex80:\n         {\n             import dmd.root.ctfloat : CTFloat;\n             return (exp.toReal()      is CTFloat.zero) &&"}, {"sha": "b1d1b1d8d7c39ba4c6c65ee194f0e341388d372d", "filename": "gcc/d/dmd/dsymbol.d", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fdsymbol.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fdsymbol.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -1785,11 +1785,11 @@ extern (C++) final class WithScopeSymbol : ScopeDsymbol\n         Expression eold = null;\n         for (Expression e = withstate.exp; e != eold; e = resolveAliasThis(_scope, e))\n         {\n-            if (e.op == TOK.scope_)\n+            if (e.op == EXP.scope_)\n             {\n                 s = (cast(ScopeExp)e).sds;\n             }\n-            else if (e.op == TOK.type)\n+            else if (e.op == EXP.type)\n             {\n                 s = e.type.toDsymbol(null);\n             }\n@@ -1826,14 +1826,14 @@ extern (C++) final class WithScopeSymbol : ScopeDsymbol\n extern (C++) final class ArrayScopeSymbol : ScopeDsymbol\n {\n     // either a SliceExp, an IndexExp, an ArrayExp, a TypeTuple or a TupleDeclaration.\n-    // Discriminated using DYNCAST and, for expressions, also TOK\n+    // Discriminated using DYNCAST and, for expressions, also EXP\n     private RootObject arrayContent;\n     Scope* sc;\n \n     extern (D) this(Scope* sc, Expression exp)\n     {\n         super(exp.loc, null);\n-        assert(exp.op == TOK.index || exp.op == TOK.slice || exp.op == TOK.array);\n+        assert(exp.op == EXP.index || exp.op == EXP.slice || exp.op == EXP.array);\n         this.sc = sc;\n         this.arrayContent = exp;\n     }\n@@ -1950,7 +1950,7 @@ extern (C++) final class ArrayScopeSymbol : ScopeDsymbol\n             else if (ce.type && (t = ce.type.toBasetype()) !is null && (t.ty == Tstruct || t.ty == Tclass))\n             {\n                 // Look for opDollar\n-                assert(exp.op == TOK.array || exp.op == TOK.slice);\n+                assert(exp.op == EXP.array || exp.op == EXP.slice);\n                 AggregateDeclaration ad = isAggregate(t);\n                 assert(ad);\n                 Dsymbol s = ad.search(loc, Id.opDollar);\n@@ -1962,11 +1962,11 @@ extern (C++) final class ArrayScopeSymbol : ScopeDsymbol\n                 if (TemplateDeclaration td = s.isTemplateDeclaration())\n                 {\n                     dinteger_t dim = 0;\n-                    if (exp.op == TOK.array)\n+                    if (exp.op == EXP.array)\n                     {\n                         dim = (cast(ArrayExp)exp).currentDimension;\n                     }\n-                    else if (exp.op == TOK.slice)\n+                    else if (exp.op == EXP.slice)\n                     {\n                         dim = 0; // slices are currently always one-dimensional\n                     }\n@@ -1987,7 +1987,7 @@ extern (C++) final class ArrayScopeSymbol : ScopeDsymbol\n                      * Note that it's impossible to have both template & function opDollar,\n                      * because both take no arguments.\n                      */\n-                    if (exp.op == TOK.array && (cast(ArrayExp)exp).arguments.dim != 1)\n+                    if (exp.op == EXP.array && (cast(ArrayExp)exp).arguments.dim != 1)\n                     {\n                         exp.error(\"`%s` only defines opDollar for one dimension\", ad.toChars());\n                         return null;"}, {"sha": "0bf9a80f37d16a64e66ddae514faa756e9ab2c04", "filename": "gcc/d/dmd/dsymbolsem.d", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbolsem.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -133,7 +133,7 @@ AlignDeclaration getAlignment(AlignDeclaration ad, Scope* sc)\n         e = e.ctfeInterpret();\n         exp = e;                // could be re-evaluated if exps are assigned to more than one AlignDeclaration by CParser.applySpecifier(),\n                                 // e.g. `_Alignas(8) int a, b;`\n-        if (e.op == TOK.error)\n+        if (e.op == EXP.error)\n             errors = true;\n         else\n         {\n@@ -611,7 +611,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             }\n         Lnomatch:\n \n-            if (ie && ie.op == TOK.tuple)\n+            if (ie && ie.op == EXP.tuple)\n             {\n                 auto te = ie.isTupleExp();\n                 size_t tedim = te.exps.dim;\n@@ -652,6 +652,8 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                     storage_class |= arg.storageClass;\n                 auto v = new VarDeclaration(dsym.loc, arg.type, id, ti, storage_class);\n                 //printf(\"declaring field %s of type %s\\n\", v.toChars(), v.type.toChars());\n+                v.overlapped = dsym.overlapped;\n+\n                 v.dsymbolSemantic(sc);\n \n                 if (sc.scopesym)\n@@ -879,11 +881,11 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         if ((!dsym._init || dsym._init.isVoidInitializer) && !fd)\n         {\n             // If not mutable, initializable by constructor only\n-            dsym.storage_class |= STC.ctorinit;\n+            dsym.setInCtorOnly = true;\n         }\n \n         if (dsym._init)\n-            dsym.storage_class |= STC.init; // remember we had an explicit initializer\n+        { } // remember we had an explicit initializer\n         else if (dsym.storage_class & STC.manifest)\n             dsym.error(\"manifest constants must have initializers\");\n \n@@ -1013,7 +1015,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                     exp = exp.expressionSemantic(sc);\n                     dsym.canassign--;\n                     exp = exp.optimize(WANTvalue);\n-                    if (exp.op == TOK.error)\n+                    if (exp.op == EXP.error)\n                     {\n                         dsym._init = new ErrorInitializer();\n                         ei = null;\n@@ -1024,7 +1026,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                     if (ei && dsym.isScope())\n                     {\n                         Expression ex = ei.exp.lastComma();\n-                        if (ex.op == TOK.blit || ex.op == TOK.construct)\n+                        if (ex.op == EXP.blit || ex.op == EXP.construct)\n                             ex = (cast(AssignExp)ex).e2;\n                         if (auto ne = ex.isNewExp())\n                         {\n@@ -1057,7 +1059,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                     // Don't run CTFE for the temporary variables inside typeof\n                     dsym._init = dsym._init.initializerSemantic(sc, dsym.type, sc.intypeof == 1 ? INITnointerpret : INITinterpret);\n                     const init_err = dsym._init.isExpInitializer();\n-                    if (init_err && init_err.exp.op == TOK.showCtfeContext)\n+                    if (init_err && init_err.exp.op == EXP.showCtfeContext)\n                     {\n                          errorSupplemental(dsym.loc, \"compile time context created here\");\n                     }\n@@ -1085,7 +1087,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                     dsym.inuse++;\n                     // Bug 20549. Don't try this on modules or packages, syntaxCopy\n                     // could crash (inf. recursion) on a mod/pkg referencing itself\n-                    if (ei && (ei.exp.op != TOK.scope_ ? true : !ei.exp.isScopeExp().sds.isPackage()))\n+                    if (ei && (ei.exp.op != EXP.scope_ ? true : !ei.exp.isScopeExp().sds.isPackage()))\n                     {\n                         if (ei.exp.type)\n                         {\n@@ -1241,7 +1243,10 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             width.error(\"bit-field `%s` has zero width\", dsym.toChars());\n             dsym.errors = true;\n         }\n-        const max_width = dsym.type.size() * 8;\n+        const sz = dsym.type.size();\n+        if (sz == SIZE_INVALID)\n+            dsym.errors = true;\n+        const max_width = sz * 8;\n         if (uwidth > max_width)\n         {\n             width.error(\"width `%lld` of bit-field `%s` does not fit in type `%s`\", cast(long)uwidth, dsym.toChars(), dsym.type.toChars());\n@@ -1459,7 +1464,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n     override void visit(AnonDeclaration scd)\n     {\n-        //printf(\"\\tAnonDeclaration::semantic %s %p\\n\", isunion ? \"union\" : \"struct\", this);\n+        //printf(\"\\tAnonDeclaration::semantic isunion:%d ptr:%p\\n\", scd.isunion, scd);\n         assert(sc.parent);\n         auto p = sc.parent.pastMixin();\n         auto ad = p.isAggregateDeclaration();\n@@ -1479,6 +1484,11 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             for (size_t i = 0; i < scd.decl.dim; i++)\n             {\n                 Dsymbol s = (*scd.decl)[i];\n+                if (auto var = s.isVarDeclaration)\n+                {\n+                    if (scd.isunion)\n+                        var.overlapped = true;\n+                }\n                 s.dsymbolSemantic(sc);\n             }\n             sc = sc.pop();\n@@ -1651,7 +1661,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                     e = resolveProperties(sc, e);\n                     sc = sc.endCTFE();\n                     e = ctfeInterpretForPragmaMsg(e);\n-                    if (e.op == TOK.error)\n+                    if (e.op == EXP.error)\n                     {\n                         errorSupplemental(pd.loc, \"while evaluating `pragma(msg, %s)`\", (*pd.args)[i].toChars());\n                         return;\n@@ -2185,7 +2195,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                     e = resolveProperties(sc, e);\n                     e = e.integralPromotions(sc);\n                     e = e.ctfeInterpret();\n-                    if (e.op == TOK.error)\n+                    if (e.op == EXP.error)\n                         return errorReturn(em);\n                     auto ie = e.isIntegerExp();\n                     if (!ie)\n@@ -2303,7 +2313,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             e = e.expressionSemantic(sc);\n             e = resolveProperties(sc, e);\n             e = e.ctfeInterpret();\n-            if (e.op == TOK.error)\n+            if (e.op == EXP.error)\n                 return errorReturn();\n             if (first && !em.ed.memtype && !em.ed.isAnonymous())\n             {\n@@ -2331,7 +2341,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                         ev = ev.implicitCastTo(sc, em.ed.memtype);\n                         ev = ev.ctfeInterpret();\n                         ev = ev.castTo(sc, em.ed.type);\n-                        if (ev.op == TOK.error)\n+                        if (ev.op == EXP.error)\n                             em.ed.errors = true;\n                         enm.value = ev;\n                     });\n@@ -2429,7 +2439,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             // Set value to (eprev + 1).\n             // But first check that (eprev != emax)\n             assert(eprev);\n-            Expression e = new EqualExp(TOK.equal, em.loc, eprev, emax);\n+            Expression e = new EqualExp(EXP.equal, em.loc, eprev, emax);\n             e = e.expressionSemantic(sc);\n             e = e.ctfeInterpret();\n             if (e.toInteger())\n@@ -2446,20 +2456,20 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             e = e.ctfeInterpret();\n \n             // save origValue (without cast) for better json output\n-            if (e.op != TOK.error) // avoid duplicate diagnostics\n+            if (e.op != EXP.error) // avoid duplicate diagnostics\n             {\n                 assert(emprev.origValue);\n                 em.origValue = new AddExp(em.loc, emprev.origValue, IntegerExp.literal!1);\n                 em.origValue = em.origValue.expressionSemantic(sc);\n                 em.origValue = em.origValue.ctfeInterpret();\n             }\n \n-            if (e.op == TOK.error)\n+            if (e.op == EXP.error)\n                 return errorReturn();\n             if (e.type.isfloating())\n             {\n                 // Check that e != eprev (not always true for floats)\n-                Expression etest = new EqualExp(TOK.equal, em.loc, e, eprev);\n+                Expression etest = new EqualExp(EXP.equal, em.loc, e, eprev);\n                 etest = etest.expressionSemantic(sc);\n                 etest = etest.ctfeInterpret();\n                 if (etest.toInteger())\n@@ -4162,7 +4172,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n             Expression e = new IdentifierExp(Loc.initial, v.ident);\n             e = new AddAssignExp(Loc.initial, e, IntegerExp.literal!1);\n-            e = new EqualExp(TOK.notEqual, Loc.initial, e, IntegerExp.literal!1);\n+            e = new EqualExp(EXP.notEqual, Loc.initial, e, IntegerExp.literal!1);\n             s = new IfStatement(Loc.initial, null, e, new ReturnStatement(Loc.initial, null), null, Loc.initial);\n \n             sa.push(s);\n@@ -4239,7 +4249,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n             Expression e = new IdentifierExp(Loc.initial, v.ident);\n             e = new AddAssignExp(Loc.initial, e, IntegerExp.literal!(-1));\n-            e = new EqualExp(TOK.notEqual, Loc.initial, e, IntegerExp.literal!0);\n+            e = new EqualExp(EXP.notEqual, Loc.initial, e, IntegerExp.literal!0);\n             s = new IfStatement(Loc.initial, null, e, new ReturnStatement(Loc.initial, null), null, Loc.initial);\n \n             sa.push(s);\n@@ -4616,6 +4626,8 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n         if (cldec.errors)\n             cldec.type = Type.terror;\n+        if (cldec.semanticRun == PASS.init)\n+            cldec.type = cldec.type.addSTC(sc.stc | cldec.storage_class);\n         cldec.type = cldec.type.typeSemantic(cldec.loc, sc);\n         if (auto tc = cldec.type.isTypeClass())\n             if (tc.sym != cldec)\n@@ -6422,7 +6434,7 @@ void aliasSemantic(AliasDeclaration ds, Scope* sc)\n                 s = getDsymbol(e);\n                 if (!s)\n                 {\n-                    if (e.op != TOK.error)\n+                    if (e.op != EXP.error)\n                         ds.error(\"cannot alias an expression `%s`\", e.toChars());\n                     return errorRet();\n                 }\n@@ -6606,7 +6618,7 @@ private void aliasAssignSemantic(AliasAssign ds, Scope* sc)\n                 s = getDsymbol(e);\n                 if (!s)\n                 {\n-                    if (e.op != TOK.error)\n+                    if (e.op != EXP.error)\n                         ds.error(\"cannot alias an expression `%s`\", e.toChars());\n                     return errorRet();\n                 }"}, {"sha": "5dedcba562771bd7fa0a7c9e653bed177b180b8f", "filename": "gcc/d/dmd/dtemplate.d", "status": "modified", "additions": 75, "deletions": 62, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fdtemplate.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fdtemplate.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtemplate.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -144,7 +144,7 @@ extern (C++) bool isError(const RootObject o)\n     if (const t = isType(o))\n         return (t.ty == Terror);\n     if (const e = isExpression(o))\n-        return (e.op == TOK.error || !e.type || e.type.ty == Terror);\n+        return (e.op == EXP.error || !e.type || e.type.ty == Terror);\n     if (const v = isTuple(o))\n         return arrayObjectIsError(&v.objects);\n     const s = isDsymbol(o);\n@@ -297,8 +297,8 @@ private bool match(RootObject o1, RootObject o2)\n \n         static if (log)\n         {\n-            printf(\"\\te1 = %s '%s' %s\\n\", e1.type ? e1.type.toChars() : \"null\", Token.toChars(e1.op), e1.toChars());\n-            printf(\"\\te2 = %s '%s' %s\\n\", e2.type ? e2.type.toChars() : \"null\", Token.toChars(e2.op), e2.toChars());\n+            printf(\"\\te1 = %s '%s' %s\\n\", e1.type ? e1.type.toChars() : \"null\", EXPtoString(e1.op).ptr, e1.toChars());\n+            printf(\"\\te2 = %s '%s' %s\\n\", e2.type ? e2.type.toChars() : \"null\", EXPtoString(e2.op).ptr, e2.toChars());\n         }\n \n         // two expressions can be equal although they do not have the same\n@@ -421,26 +421,26 @@ private size_t expressionHash(Expression e)\n \n     switch (e.op)\n     {\n-    case TOK.int64:\n+    case EXP.int64:\n         return cast(size_t) e.isIntegerExp().getInteger();\n \n-    case TOK.float64:\n+    case EXP.float64:\n         return CTFloat.hash(e.isRealExp().value);\n \n-    case TOK.complex80:\n+    case EXP.complex80:\n         auto ce = e.isComplexExp();\n         return mixHash(CTFloat.hash(ce.toReal), CTFloat.hash(ce.toImaginary));\n \n-    case TOK.identifier:\n+    case EXP.identifier:\n         return cast(size_t)cast(void*) e.isIdentifierExp().ident;\n \n-    case TOK.null_:\n+    case EXP.null_:\n         return cast(size_t)cast(void*) e.isNullExp().type;\n \n-    case TOK.string_:\n+    case EXP.string_:\n         return calcHash(e.isStringExp.peekData());\n \n-    case TOK.tuple:\n+    case EXP.tuple:\n     {\n         auto te = e.isTupleExp();\n         size_t hash = 0;\n@@ -450,7 +450,7 @@ private size_t expressionHash(Expression e)\n         return hash;\n     }\n \n-    case TOK.arrayLiteral:\n+    case EXP.arrayLiteral:\n     {\n         auto ae = e.isArrayLiteralExp();\n         size_t hash;\n@@ -459,7 +459,7 @@ private size_t expressionHash(Expression e)\n         return hash;\n     }\n \n-    case TOK.assocArrayLiteral:\n+    case EXP.assocArrayLiteral:\n     {\n         auto ae = e.isAssocArrayLiteralExp();\n         size_t hash;\n@@ -469,7 +469,7 @@ private size_t expressionHash(Expression e)\n         return hash;\n     }\n \n-    case TOK.structLiteral:\n+    case EXP.structLiteral:\n     {\n         auto se = e.isStructLiteralExp();\n         size_t hash;\n@@ -478,10 +478,10 @@ private size_t expressionHash(Expression e)\n         return hash;\n     }\n \n-    case TOK.variable:\n+    case EXP.variable:\n         return cast(size_t)cast(void*) e.isVarExp().var;\n \n-    case TOK.function_:\n+    case EXP.function_:\n         return cast(size_t)cast(void*) e.isFuncExp().fd;\n \n     default:\n@@ -1629,7 +1629,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n                             farg = (*fargs)[argi + i];\n \n                             // Check invalid arguments to detect errors early.\n-                            if (farg.op == TOK.error || farg.type.ty == Terror)\n+                            if (farg.op == EXP.error || farg.type.ty == Terror)\n                                 return nomatch();\n \n                             if (!(fparam.storageClass & STC.lazy_) && farg.type.ty == Tvoid)\n@@ -1825,7 +1825,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n                 }\n                 {\n                     // Check invalid arguments to detect errors early.\n-                    if (farg.op == TOK.error || farg.type.ty == Terror)\n+                    if (farg.op == EXP.error || farg.type.ty == Terror)\n                         return nomatch();\n \n                     Type att = null;\n@@ -1837,7 +1837,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n                     }\n                     Type argtype = farg.type;\n \n-                    if (!(fparam.storageClass & STC.lazy_) && argtype.ty == Tvoid && farg.op != TOK.function_)\n+                    if (!(fparam.storageClass & STC.lazy_) && argtype.ty == Tvoid && farg.op != EXP.function_)\n                         return nomatch();\n \n                     // https://issues.dlang.org/show_bug.cgi?id=12876\n@@ -1853,17 +1853,17 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n                         Type taai;\n                         if (argtype.ty == Tarray && (prmtype.ty == Tsarray || prmtype.ty == Taarray && (taai = (cast(TypeAArray)prmtype).index).ty == Tident && (cast(TypeIdentifier)taai).idents.dim == 0))\n                         {\n-                            if (farg.op == TOK.string_)\n+                            if (farg.op == EXP.string_)\n                             {\n                                 StringExp se = cast(StringExp)farg;\n                                 argtype = se.type.nextOf().sarrayOf(se.len);\n                             }\n-                            else if (farg.op == TOK.arrayLiteral)\n+                            else if (farg.op == EXP.arrayLiteral)\n                             {\n                                 ArrayLiteralExp ae = cast(ArrayLiteralExp)farg;\n                                 argtype = ae.type.nextOf().sarrayOf(ae.elements.dim);\n                             }\n-                            else if (farg.op == TOK.slice)\n+                            else if (farg.op == EXP.slice)\n                             {\n                                 SliceExp se = cast(SliceExp)farg;\n                                 if (Type tsa = toStaticArrayType(se))\n@@ -1939,7 +1939,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n                     {\n                         if (!farg.isLvalue())\n                         {\n-                            if ((farg.op == TOK.string_ || farg.op == TOK.slice) && (prmtype.ty == Tsarray || prmtype.ty == Taarray))\n+                            if ((farg.op == EXP.string_ || farg.op == EXP.slice) && (prmtype.ty == Tsarray || prmtype.ty == Taarray))\n                             {\n                                 // Allow conversion from T[lwr .. upr] to ref T[upr-lwr]\n                             }\n@@ -2280,13 +2280,13 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n         Declaration d;\n         VarDeclaration v = null;\n \n-        if (ea && ea.op == TOK.type)\n+        if (ea && ea.op == EXP.type)\n             ta = ea.type;\n-        else if (ea && ea.op == TOK.scope_)\n+        else if (ea && ea.op == EXP.scope_)\n             sa = (cast(ScopeExp)ea).sds;\n-        else if (ea && (ea.op == TOK.this_ || ea.op == TOK.super_))\n+        else if (ea && (ea.op == EXP.this_ || ea.op == EXP.super_))\n             sa = (cast(ThisExp)ea).var;\n-        else if (ea && ea.op == TOK.function_)\n+        else if (ea && ea.op == EXP.function_)\n         {\n             if ((cast(FuncExp)ea).td)\n                 sa = (cast(FuncExp)ea).td;\n@@ -3826,7 +3826,7 @@ MATCH deduceType(RootObject o, Scope* sc, Type tparam, TemplateParameters* param\n                 if (tparam.ty == Tsarray)\n                 {\n                     TypeSArray tsa = cast(TypeSArray)tparam;\n-                    if (tsa.dim.op == TOK.variable && (cast(VarExp)tsa.dim).var.storage_class & STC.templateparameter)\n+                    if (tsa.dim.op == EXP.variable && (cast(VarExp)tsa.dim).var.storage_class & STC.templateparameter)\n                     {\n                         Identifier id = (cast(VarExp)tsa.dim).var.ident;\n                         i = templateIdentifierLookup(id, parameters);\n@@ -4209,7 +4209,7 @@ MATCH deduceType(RootObject o, Scope* sc, Type tparam, TemplateParameters* param\n                         /* If it is one of the template parameters for this template,\n                          * we should not attempt to interpret it. It already has a value.\n                          */\n-                        if (e2.op == TOK.variable && ((cast(VarExp)e2).var.storage_class & STC.templateparameter))\n+                        if (e2.op == EXP.variable && ((cast(VarExp)e2).var.storage_class & STC.templateparameter))\n                         {\n                             /*\n                              * (T:Number!(e2), int e2)\n@@ -4847,9 +4847,9 @@ MATCH deduceType(RootObject o, Scope* sc, Type tparam, TemplateParameters* param\n                 // Reset inference target for the later re-semantic\n                 e.fd.treq = null;\n \n-                if (ex.op == TOK.error)\n+                if (ex.op == EXP.error)\n                     return;\n-                if (ex.op != TOK.function_)\n+                if (ex.op != EXP.function_)\n                     return;\n                 visit(ex.type);\n                 return;\n@@ -6642,13 +6642,13 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n             else if (ea)\n             {\n             Lexpr:\n-                //printf(\"+[%d] ea = %s %s\\n\", j, Token.toChars(ea.op), ea.toChars());\n+                //printf(\"+[%d] ea = %s %s\\n\", j, EXPtoString(ea.op).ptr, ea.toChars());\n                 if (flags & 1) // only used by __traits\n                 {\n                     ea = ea.expressionSemantic(sc);\n \n                     // must not interpret the args, excepting template parameters\n-                    if (ea.op != TOK.variable || ((cast(VarExp)ea).var.storage_class & STC.templateparameter))\n+                    if (ea.op != EXP.variable || ((cast(VarExp)ea).var.storage_class & STC.templateparameter))\n                     {\n                         ea = ea.optimize(WANTvalue);\n                     }\n@@ -6659,7 +6659,7 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n                     ea = ea.expressionSemantic(sc);\n                     sc = sc.endCTFE();\n \n-                    if (ea.op == TOK.variable)\n+                    if (ea.op == EXP.variable)\n                     {\n                         /* If the parameter is a function that is not called\n                          * explicitly, i.e. `foo!func` as opposed to `foo!func()`,\n@@ -6687,8 +6687,8 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n                             ea = ErrorExp.get();\n                     }\n                 }\n-                //printf(\"-[%d] ea = %s %s\\n\", j, Token.toChars(ea.op), ea.toChars());\n-                if (ea.op == TOK.tuple)\n+                //printf(\"-[%d] ea = %s %s\\n\", j, EXPtoString(ea.op).ptr, ea.toChars());\n+                if (ea.op == EXP.tuple)\n                 {\n                     // Expand tuple\n                     TupleExp te = cast(TupleExp)ea;\n@@ -6703,24 +6703,24 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n                     j--;\n                     continue;\n                 }\n-                if (ea.op == TOK.error)\n+                if (ea.op == EXP.error)\n                 {\n                     err = true;\n                     continue;\n                 }\n                 (*tiargs)[j] = ea;\n \n-                if (ea.op == TOK.type)\n+                if (ea.op == EXP.type)\n                 {\n                     ta = ea.type;\n                     goto Ltype;\n                 }\n-                if (ea.op == TOK.scope_)\n+                if (ea.op == EXP.scope_)\n                 {\n                     sa = (cast(ScopeExp)ea).sds;\n                     goto Ldsym;\n                 }\n-                if (ea.op == TOK.function_)\n+                if (ea.op == EXP.function_)\n                 {\n                     FuncExp fe = cast(FuncExp)ea;\n                     /* A function literal, that is passed to template and\n@@ -6741,24 +6741,24 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n                         //goto Ldsym;\n                     }\n                 }\n-                if (ea.op == TOK.dotVariable && !(flags & 1))\n+                if (ea.op == EXP.dotVariable && !(flags & 1))\n                 {\n                     // translate expression to dsymbol.\n                     sa = (cast(DotVarExp)ea).var;\n                     goto Ldsym;\n                 }\n-                if (ea.op == TOK.template_)\n+                if (ea.op == EXP.template_)\n                 {\n                     sa = (cast(TemplateExp)ea).td;\n                     goto Ldsym;\n                 }\n-                if (ea.op == TOK.dotTemplateDeclaration && !(flags & 1))\n+                if (ea.op == EXP.dotTemplateDeclaration && !(flags & 1))\n                 {\n                     // translate expression to dsymbol.\n                     sa = (cast(DotTemplateExp)ea).td;\n                     goto Ldsym;\n                 }\n-                if (ea.op == TOK.dot)\n+                if (ea.op == EXP.dot)\n                 {\n                     if (auto se = (cast(DotExp)ea).e2.isScopeExp())\n                     {\n@@ -7256,17 +7256,17 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n             Tuple va = isTuple(o);\n             if (ea)\n             {\n-                if (ea.op == TOK.variable)\n+                if (ea.op == EXP.variable)\n                 {\n                     sa = (cast(VarExp)ea).var;\n                     goto Lsa;\n                 }\n-                if (ea.op == TOK.this_)\n+                if (ea.op == EXP.this_)\n                 {\n                     sa = (cast(ThisExp)ea).var;\n                     goto Lsa;\n                 }\n-                if (ea.op == TOK.function_)\n+                if (ea.op == EXP.function_)\n                 {\n                     if ((cast(FuncExp)ea).td)\n                         sa = (cast(FuncExp)ea).td;\n@@ -7275,7 +7275,7 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n                     goto Lsa;\n                 }\n                 // Emulate Expression.toMangleBuffer call that had exist in TemplateInstance.genIdent.\n-                if (ea.op != TOK.int64 && ea.op != TOK.float64 && ea.op != TOK.complex80 && ea.op != TOK.null_ && ea.op != TOK.string_ && ea.op != TOK.arrayLiteral && ea.op != TOK.assocArrayLiteral && ea.op != TOK.structLiteral)\n+                if (ea.op != EXP.int64 && ea.op != EXP.float64 && ea.op != EXP.complex80 && ea.op != EXP.null_ && ea.op != EXP.string_ && ea.op != EXP.arrayLiteral && ea.op != EXP.assocArrayLiteral && ea.op != EXP.structLiteral)\n                 {\n                     ea.error(\"expression `%s` is not a valid template value argument\", ea.toChars());\n                     errors = true;\n@@ -7319,6 +7319,19 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n                                 goto L1; // dparent is most nested\n                             }\n                         }\n+                        //https://issues.dlang.org/show_bug.cgi?id=17870\n+                        if (dparent.isClassDeclaration() && enclosing.isClassDeclaration())\n+                        {\n+                            auto pc = dparent.isClassDeclaration();\n+                            auto ec = enclosing.isClassDeclaration();\n+                            if (pc.isBaseOf(ec, null))\n+                                goto L1;\n+                            else if (ec.isBaseOf(pc, null))\n+                            {\n+                                enclosing = dparent;\n+                                goto L1;\n+                            }\n+                        }\n                         error(\"`%s` is nested in both `%s` and `%s`\", toChars(), enclosing.toChars(), dparent.toChars());\n                         errors = true;\n                     }\n@@ -7584,15 +7597,15 @@ void unSpeculative(Scope* sc, RootObject o)\n bool definitelyValueParameter(Expression e)\n {\n     // None of these can be value parameters\n-    if (e.op == TOK.tuple || e.op == TOK.scope_ ||\n-        e.op == TOK.type || e.op == TOK.dotType ||\n-        e.op == TOK.template_ || e.op == TOK.dotTemplateDeclaration ||\n-        e.op == TOK.function_ || e.op == TOK.error ||\n-        e.op == TOK.this_ || e.op == TOK.super_ ||\n-        e.op == TOK.dot)\n+    if (e.op == EXP.tuple || e.op == EXP.scope_ ||\n+        e.op == EXP.type || e.op == EXP.dotType ||\n+        e.op == EXP.template_ || e.op == EXP.dotTemplateDeclaration ||\n+        e.op == EXP.function_ || e.op == EXP.error ||\n+        e.op == EXP.this_ || e.op == EXP.super_ ||\n+        e.op == EXP.dot)\n         return false;\n \n-    if (e.op != TOK.dotVariable)\n+    if (e.op != EXP.dotVariable)\n         return true;\n \n     /* Template instantiations involving a DotVar expression are difficult.\n@@ -7606,20 +7619,20 @@ bool definitelyValueParameter(Expression e)\n     if (f)\n         return false;\n \n-    while (e.op == TOK.dotVariable)\n+    while (e.op == EXP.dotVariable)\n     {\n         e = (cast(DotVarExp)e).e1;\n     }\n     // this.x.y and super.x.y couldn't possibly be valid values.\n-    if (e.op == TOK.this_ || e.op == TOK.super_)\n+    if (e.op == EXP.this_ || e.op == EXP.super_)\n         return false;\n \n     // e.type.x could be an alias\n-    if (e.op == TOK.dotType)\n+    if (e.op == EXP.dotType)\n         return false;\n \n     // var.x.y is the only other possible form of alias\n-    if (e.op != TOK.variable)\n+    if (e.op != EXP.variable)\n         return true;\n \n     VarDeclaration v = (cast(VarExp)e).var.isVarDeclaration();\n@@ -8010,7 +8023,7 @@ MATCH matchArg(TemplateParameter tp, Scope* sc, RootObject oarg, size_t i, Templ\n             uint olderrors = global.startGagging();\n             ei = resolveProperties(sc, ei);\n             ei = ei.ctfeInterpret();\n-            if (global.endGagging(olderrors) || ei.op == TOK.error)\n+            if (global.endGagging(olderrors) || ei.op == EXP.error)\n                 return matchArgNoMatch();\n \n             /* https://issues.dlang.org/show_bug.cgi?id=14520\n@@ -8032,7 +8045,7 @@ MATCH matchArg(TemplateParameter tp, Scope* sc, RootObject oarg, size_t i, Templ\n             m = MATCH.convert;\n         }\n \n-        if (ei && ei.op == TOK.variable)\n+        if (ei && ei.op == EXP.variable)\n         {\n             // Resolve const variables that we had skipped earlier\n             ei = ei.ctfeInterpret();\n@@ -8110,9 +8123,9 @@ MATCH matchArg(TemplateParameter tp, Scope* sc, RootObject oarg, size_t i, Templ\n         Type ta = isType(oarg);\n         RootObject sa = ta && !ta.deco ? null : getDsymbol(oarg);\n         Expression ea = isExpression(oarg);\n-        if (ea && (ea.op == TOK.this_ || ea.op == TOK.super_))\n+        if (ea && (ea.op == EXP.this_ || ea.op == EXP.super_))\n             sa = (cast(ThisExp)ea).var;\n-        else if (ea && ea.op == TOK.scope_)\n+        else if (ea && ea.op == EXP.scope_)\n             sa = (cast(ScopeExp)ea).sds;\n         if (sa)\n         {"}, {"sha": "51f53c8402fb8e8466ce67941ed7022580d105ca", "filename": "gcc/d/dmd/dtoh.d", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fdtoh.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fdtoh.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtoh.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -21,6 +21,7 @@ import dmd.attrib;\n import dmd.dsymbol;\n import dmd.errors;\n import dmd.globals;\n+import dmd.hdrgen;\n import dmd.identifier;\n import dmd.root.filename;\n import dmd.visitor;\n@@ -2395,7 +2396,7 @@ public:\n     {\n         debug (Debug_DtoH) mixin(traceVisit!e);\n \n-        buf.writestring(tokToString(e.op));\n+        buf.writestring(expToString(e.op));\n         e.e1.accept(this);\n     }\n \n@@ -2405,20 +2406,20 @@ public:\n \n         e.e1.accept(this);\n         buf.writeByte(' ');\n-        buf.writestring(tokToString(e.op));\n+        buf.writestring(expToString(e.op));\n         buf.writeByte(' ');\n         e.e2.accept(this);\n     }\n \n     /// Translates operator `op` into the C++ representation\n-    private extern(D) static string tokToString(const TOK op)\n+    private extern(D) static string expToString(const EXP op)\n     {\n-        switch (op) with (TOK)\n+        switch (op) with (EXP)\n         {\n             case identity:      return \"==\";\n             case notIdentity:   return \"!=\";\n             default:\n-                return Token.toString(op);\n+                return EXPtoString(op);\n         }\n     }\n "}, {"sha": "62f87e506ab69515cace5608893625467cfc8b89", "filename": "gcc/d/dmd/escape.d", "status": "modified", "additions": 27, "deletions": 38, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fescape.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fescape.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fescape.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -536,8 +536,8 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag)\n {\n     enum log = false;\n     if (log) printf(\"checkAssignEscape(e: %s)\\n\", e.toChars());\n-    if (e.op != TOK.assign && e.op != TOK.blit && e.op != TOK.construct &&\n-        e.op != TOK.concatenateAssign && e.op != TOK.concatenateElemAssign && e.op != TOK.concatenateDcharAssign)\n+    if (e.op != EXP.assign && e.op != EXP.blit && e.op != EXP.construct &&\n+        e.op != EXP.concatenateAssign && e.op != EXP.concatenateElemAssign && e.op != EXP.concatenateDcharAssign)\n         return false;\n     auto ae = cast(BinExp)e;\n     Expression e1 = ae.e1;\n@@ -568,7 +568,7 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag)\n \n     VarDeclaration va = expToVariable(e1);\n \n-    if (va && e.op == TOK.concatenateElemAssign)\n+    if (va && e.op == EXP.concatenateElemAssign)\n     {\n         /* https://issues.dlang.org/show_bug.cgi?id=17842\n          * Draw an equivalence between:\n@@ -596,11 +596,6 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag)\n \n     FuncDeclaration fd = sc.func;\n \n-    // Try to infer 'scope' for va if in a function not marked @system\n-    bool inferScope = false;\n-    if (va && fd && fd.type && fd.type.isTypeFunction())\n-        inferScope = fd.type.isTypeFunction().trust != TRUST.system;\n-    //printf(\"inferScope = %d, %d\\n\", inferScope, (va.storage_class & STCmaybescope) != 0);\n \n     // Determine if va is a parameter that is an indirect reference\n     const bool vaIsRef = va && va.storage_class & STC.parameter &&\n@@ -677,7 +672,7 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag)\n                 if (va.isScope())\n                     continue;\n \n-                if (inferScope && !va.doNotInferScope)\n+                if (!va.doNotInferScope)\n                 {\n                     if (log) printf(\"inferring scope for lvalue %s\\n\", va.toChars());\n                     va.storage_class |= STC.scope_ | STC.scopeinferred;\n@@ -713,7 +708,7 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag)\n \n             if (va && !va.isDataseg() && !va.doNotInferScope)\n             {\n-                if (!va.isScope() && inferScope)\n+                if (!va.isScope())\n                 {   /* v is scope, and va is not scope, so va needs to\n                      * infer scope\n                      */\n@@ -749,7 +744,7 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag)\n             {\n                 if (va && !va.isDataseg() && !va.doNotInferScope)\n                 {\n-                    if (!va.isScope() && inferScope)\n+                    if (!va.isScope())\n                     {   //printf(\"inferring scope for %s\\n\", va.toChars());\n                         va.storage_class |= STC.scope_ | STC.scopeinferred;\n                     }\n@@ -840,15 +835,15 @@ ByRef:\n \n         if (va && !va.isDataseg() && !va.doNotInferScope)\n         {\n-            if (!va.isScope() && inferScope)\n+            if (!va.isScope())\n             {   //printf(\"inferring scope for %s\\n\", va.toChars());\n                 va.storage_class |= STC.scope_ | STC.scopeinferred;\n             }\n             if (v.storage_class & STC.return_ && !(va.storage_class & STC.return_))\n                 va.storage_class |= STC.return_ | STC.returninferred;\n             continue;\n         }\n-        if (e1.op == TOK.structLiteral)\n+        if (e1.op == EXP.structLiteral)\n             continue;\n         if (fd.setUnsafe())\n         {\n@@ -890,7 +885,7 @@ ByRef:\n                 /* Don't infer STC.scope_ for va, because then a closure\n                  * won't be generated for fd.\n                  */\n-                //if (!va.isScope() && inferScope)\n+                //if (!va.isScope())\n                     //va.storage_class |= STC.scope_ | STC.scopeinferred;\n                 continue;\n             }\n@@ -909,7 +904,7 @@ ByRef:\n \n         /* Do not allow slicing of a static array returned by a function\n          */\n-        if (ee.op == TOK.call && ee.type.toBasetype().isTypeSArray() && e1.type.toBasetype().isTypeDArray() &&\n+        if (ee.op == EXP.call && ee.type.toBasetype().isTypeSArray() && e1.type.toBasetype().isTypeDArray() &&\n             !(va && va.storage_class & STC.temp))\n         {\n             if (!gag)\n@@ -919,7 +914,7 @@ ByRef:\n             continue;\n         }\n \n-        if (ee.op == TOK.call && ee.type.toBasetype().isTypeStruct() &&\n+        if (ee.op == EXP.call && ee.type.toBasetype().isTypeStruct() &&\n             (!va || !(va.storage_class & STC.temp)) &&\n             fd.setUnsafe())\n         {\n@@ -930,7 +925,7 @@ ByRef:\n             continue;\n         }\n \n-        if (ee.op == TOK.structLiteral &&\n+        if (ee.op == EXP.structLiteral &&\n             (!va || !(va.storage_class & STC.temp)) &&\n             fd.setUnsafe())\n         {\n@@ -943,7 +938,7 @@ ByRef:\n \n         if (va && !va.isDataseg() && !va.doNotInferScope)\n         {\n-            if (!va.isScope() && inferScope)\n+            if (!va.isScope())\n             {   //printf(\"inferring scope for %s\\n\", va.toChars());\n                 va.storage_class |= STC.scope_ | STC.scopeinferred;\n             }\n@@ -993,17 +988,13 @@ bool checkThrowEscape(Scope* sc, Expression e, bool gag)\n         if (v.isScope() && !v.iscatchvar)       // special case: allow catch var to be rethrown\n                                                 // despite being `scope`\n         {\n-            if (sc._module && sc._module.isRoot())\n+            if (global.params.useDIP1000 == FeatureState.enabled) // https://issues.dlang.org/show_bug.cgi?id=17029\n             {\n-                // Only look for errors if in module listed on command line\n-                if (global.params.useDIP1000 == FeatureState.enabled) // https://issues.dlang.org/show_bug.cgi?id=17029\n-                {\n-                    if (!gag)\n-                        error(e.loc, \"scope variable `%s` may not be thrown\", v.toChars());\n-                    result = true;\n-                }\n-                continue;\n+                if (!gag)\n+                    error(e.loc, \"scope variable `%s` may not be thrown\", v.toChars());\n+                result = true;\n             }\n+            continue;\n         }\n         else\n         {\n@@ -1051,7 +1042,7 @@ bool checkNewEscape(Scope* sc, Expression e, bool gag)\n \n         if (v.isScope())\n         {\n-            if (sc._module && sc._module.isRoot() &&\n+            if (\n                 /* This case comes up when the ReturnStatement of a __foreachbody is\n                  * checked for escapes by the caller of __foreachbody. Skip it.\n                  *\n@@ -1128,9 +1119,6 @@ bool checkNewEscape(Scope* sc, Expression e, bool gag)\n         if (!v.isReference())\n             continue;\n \n-        if (!sc._module || !sc._module.isRoot())\n-            continue;\n-\n         // https://dlang.org/spec/function.html#return-ref-parameters\n         // Only look for errors if in module listed on command line\n         if (p == sc.func)\n@@ -1264,7 +1252,7 @@ private bool checkReturnEscapeImpl(Scope* sc, Expression e, bool refs, bool gag)\n                 continue;\n \n             auto pfunc = p.isFuncDeclaration();\n-            if (pfunc && sc._module && sc._module.isRoot() &&\n+            if (pfunc &&\n                 /* This case comes up when the ReturnStatement of a __foreachbody is\n                  * checked for escapes by the caller of __foreachbody. Skip it.\n                  *\n@@ -1284,7 +1272,8 @@ private bool checkReturnEscapeImpl(Scope* sc, Expression e, bool refs, bool gag)\n                )\n             {\n                 // Only look for errors if in module listed on command line\n-                if (global.params.useDIP1000 == FeatureState.enabled) // https://issues.dlang.org/show_bug.cgi?id=17029\n+                // https://issues.dlang.org/show_bug.cgi?id=17029\n+                if (global.params.useDIP1000 == FeatureState.enabled && sc.func.setUnsafe())\n                 {\n                     if (!gag)\n                         error(e.loc, \"scope variable `%s` may not be returned\", v.toChars());\n@@ -1398,7 +1387,7 @@ private bool checkReturnEscapeImpl(Scope* sc, Expression e, bool refs, bool gag)\n             {\n                 inferReturn(sc.func, v);        // infer addition of 'return'\n             }\n-            else if (sc._module && sc._module.isRoot())\n+            else\n             {\n                 // https://dlang.org/spec/function.html#return-ref-parameters\n                 // Only look for errors if in module listed on command line\n@@ -1528,7 +1517,7 @@ void escapeByValue(Expression e, EscapeByResults* er, bool live = false)\n              * allowed, but CTFE can generate one out of a new expression,\n              * but it'll be placed in static data so no need to check it.\n              */\n-            if (e.e1.op != TOK.structLiteral)\n+            if (e.e1.op != EXP.structLiteral)\n                 escapeByRef(e.e1, er, live);\n         }\n \n@@ -1768,7 +1757,7 @@ void escapeByValue(Expression e, EscapeByResults* er, bool live = false)\n                 }\n             }\n             // If 'this' is returned, check it too\n-            if (e.e1.op == TOK.dotVariable && t1.ty == Tfunction)\n+            if (e.e1.op == EXP.dotVariable && t1.ty == Tfunction)\n             {\n                 DotVarExp dve = e.e1.isDotVarExp();\n                 FuncDeclaration fd = dve.var.isFuncDeclaration();\n@@ -2024,7 +2013,7 @@ void escapeByRef(Expression e, EscapeByResults* er, bool live = false)\n                     }\n                 }\n                 // If 'this' is returned by ref, check it too\n-                if (e.e1.op == TOK.dotVariable && t1.ty == Tfunction)\n+                if (e.e1.op == EXP.dotVariable && t1.ty == Tfunction)\n                 {\n                     DotVarExp dve = e.e1.isDotVarExp();\n \n@@ -2051,7 +2040,7 @@ void escapeByRef(Expression e, EscapeByResults* er, bool live = false)\n                     }\n                 }\n                 // If it's a delegate, check it too\n-                if (e.e1.op == TOK.variable && t1.ty == Tdelegate)\n+                if (e.e1.op == EXP.variable && t1.ty == Tdelegate)\n                 {\n                     escapeByValue(e.e1, er, live);\n                 }"}, {"sha": "e6b7e3014f18894ea0e32628931f962db27b5188", "filename": "gcc/d/dmd/expression.d", "status": "modified", "additions": 394, "deletions": 390, "changes": 784, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fexpression.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fexpression.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c"}, {"sha": "411822cb9d6b3a1f1f7b8a24077f15c3b7e1763f", "filename": "gcc/d/dmd/expression.h", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fexpression.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fexpression.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.h?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -18,6 +18,7 @@\n #include \"tokens.h\"\n \n #include \"root/dcompat.h\"\n+#include \"root/optional.h\"\n \n class Type;\n class TypeVector;\n@@ -76,7 +77,7 @@ enum class ModifyFlags\n class Expression : public ASTNode\n {\n public:\n-    TOK op;                     // to minimize use of dynamic_cast\n+    EXP op;                     // to minimize use of dynamic_cast\n     unsigned char size;         // # of bytes in Expression so we can copy() it\n     unsigned char parens;       // if this is a parenthesized expression\n     Type *type;                 // !=NULL means that semantic() has been run\n@@ -121,8 +122,7 @@ class Expression : public ASTNode\n     // A compile-time result is required. Give an error if not possible\n     Expression *ctfeInterpret();\n     int isConst();\n-    virtual bool isBool(bool result);\n-\n+    virtual Optional<bool> toBool();\n     virtual bool hasCode()\n     {\n         return true;\n@@ -249,7 +249,7 @@ class IntegerExp : public Expression\n     real_t toReal();\n     real_t toImaginary();\n     complex_t toComplex();\n-    bool isBool(bool result);\n+    Optional<bool> toBool();\n     Expression *toLvalue(Scope *sc, Expression *e);\n     void accept(Visitor *v) { v->visit(this); }\n     dinteger_t getInteger() { return value; }\n@@ -280,7 +280,7 @@ class RealExp : public Expression\n     real_t toReal();\n     real_t toImaginary();\n     complex_t toComplex();\n-    bool isBool(bool result);\n+    Optional<bool> toBool();\n     void accept(Visitor *v) { v->visit(this); }\n };\n \n@@ -297,7 +297,7 @@ class ComplexExp : public Expression\n     real_t toReal();\n     real_t toImaginary();\n     complex_t toComplex();\n-    bool isBool(bool result);\n+    Optional<bool> toBool();\n     void accept(Visitor *v) { v->visit(this); }\n };\n \n@@ -336,7 +336,7 @@ class ThisExp : public Expression\n     VarDeclaration *var;\n \n     ThisExp *syntaxCopy();\n-    bool isBool(bool result);\n+    Optional<bool> toBool();\n     bool isLvalue();\n     Expression *toLvalue(Scope *sc, Expression *e);\n \n@@ -353,7 +353,7 @@ class NullExp : public Expression\n {\n public:\n     bool equals(const RootObject *o) const;\n-    bool isBool(bool result);\n+    Optional<bool> toBool();\n     StringExp *toStringExp();\n     void accept(Visitor *v) { v->visit(this); }\n };\n@@ -374,7 +374,7 @@ class StringExp : public Expression\n     bool equals(const RootObject *o) const;\n     StringExp *toStringExp();\n     StringExp *toUTF8(Scope *sc);\n-    bool isBool(bool result);\n+    Optional<bool> toBool();\n     bool isLvalue();\n     Expression *toLvalue(Scope *sc, Expression *e);\n     Expression *modifiableLvalue(Scope *sc, Expression *e);\n@@ -420,7 +420,7 @@ class ArrayLiteralExp : public Expression\n     bool equals(const RootObject *o) const;\n     Expression *getElement(d_size_t i); // use opIndex instead\n     Expression *opIndex(d_size_t i);\n-    bool isBool(bool result);\n+    Optional<bool> toBool();\n     StringExp *toStringExp();\n \n     void accept(Visitor *v) { v->visit(this); }\n@@ -435,7 +435,7 @@ class AssocArrayLiteralExp : public Expression\n \n     bool equals(const RootObject *o) const;\n     AssocArrayLiteralExp *syntaxCopy();\n-    bool isBool(bool result);\n+    Optional<bool> toBool();\n \n     void accept(Visitor *v) { v->visit(this); }\n };\n@@ -567,7 +567,7 @@ class SymOffExp : public SymbolExp\n public:\n     dinteger_t offset;\n \n-    bool isBool(bool result);\n+    Optional<bool> toBool();\n \n     void accept(Visitor *v) { v->visit(this); }\n };\n@@ -926,7 +926,7 @@ class SliceExp : public UnaExp\n     bool isLvalue();\n     Expression *toLvalue(Scope *sc, Expression *e);\n     Expression *modifiableLvalue(Scope *sc, Expression *e);\n-    bool isBool(bool result);\n+    Optional<bool> toBool();\n \n     void accept(Visitor *v) { v->visit(this); }\n };\n@@ -997,7 +997,7 @@ class CommaExp : public BinExp\n     bool isLvalue();\n     Expression *toLvalue(Scope *sc, Expression *e);\n     Expression *modifiableLvalue(Scope *sc, Expression *e);\n-    bool isBool(bool result);\n+    Optional<bool> toBool();\n     Expression *addDtorHook(Scope *sc);\n     void accept(Visitor *v) { v->visit(this); }\n };"}, {"sha": "ec2bce47b47174b6a1072fafcd10f8e0634fb406", "filename": "gcc/d/dmd/expressionsem.d", "status": "modified", "additions": 444, "deletions": 358, "changes": 802, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c"}, {"sha": "e9a43f9210547b7c9aaf3c6ebd074f10aaa0f762", "filename": "gcc/d/dmd/foreachvar.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fforeachvar.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fforeachvar.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fforeachvar.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -223,7 +223,7 @@ void foreachExpAndVar(Statement s,\n         void visitWith(WithStatement s)\n         {\n             // If it is with(Enum) {...}, just execute the body.\n-            if (s.exp.op == TOK.scope_ || s.exp.op == TOK.type)\n+            if (s.exp.op == EXP.scope_ || s.exp.op == EXP.type)\n             {\n             }\n             else"}, {"sha": "da33587fc88a802718c5945e3abd85ceb37c045d", "filename": "gcc/d/dmd/func.d", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Ffunc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Ffunc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffunc.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -1306,7 +1306,14 @@ extern (C++) class FuncDeclaration : Declaration\n         if (!fbody)\n             return false;\n \n-        if (isVirtualMethod())\n+        if (isVirtualMethod() &&\n+            /*\n+             * https://issues.dlang.org/show_bug.cgi?id=21719\n+             *\n+             * If we have an auto virtual function we can infer\n+             * the attributes.\n+             */\n+            !(inferRetType && !isCtorDeclaration()))\n             return false;               // since they may be overridden\n \n         if (sc.func &&"}, {"sha": "7409dcc290273ef489325bae58c2281db4e957cf", "filename": "gcc/d/dmd/globals.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fglobals.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fglobals.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fglobals.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -148,7 +148,7 @@ extern (C++) struct Param\n     bool betterC;           // be a \"better C\" compiler; no dependency on D runtime\n     bool addMain;           // add a default main() function\n     bool allInst;           // generate code for all template instantiations\n-    bool fix16997;          // fix integral promotions for unary + - ~ operators\n+    bool fix16997 = true;   // fix integral promotions for unary + - ~ operators\n                             // https://issues.dlang.org/show_bug.cgi?id=16997\n     bool fixAliasThis;      // if the current scope has an alias this, check it before searching upper scopes\n     bool inclusiveInContracts;   // 'in' contracts of overridden methods must be a superset of parent contract"}, {"sha": "a454298673965d7704c041fa561ff4588f6df316", "filename": "gcc/d/dmd/hdrgen.d", "status": "modified", "additions": 175, "deletions": 20, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fhdrgen.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fhdrgen.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fhdrgen.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -164,7 +164,7 @@ public:\n \n     override void visit(ExpStatement s)\n     {\n-        if (s.exp && s.exp.op == TOK.declaration &&\n+        if (s.exp && s.exp.op == EXP.declaration &&\n             (cast(DeclarationExp)s.exp).declaration)\n         {\n             // bypass visit(DeclarationExp)\n@@ -202,7 +202,7 @@ public:\n         foreach (sx; *s.statements)\n         {\n             auto ds = sx ? sx.isExpStatement() : null;\n-            if (ds && ds.exp.op == TOK.declaration)\n+            if (ds && ds.exp.op == EXP.declaration)\n             {\n                 auto d = (cast(DeclarationExp)ds.exp).declaration;\n                 assert(d.isDeclaration());\n@@ -1260,7 +1260,7 @@ public:\n             {\n                 buf.writestring(\" = \");\n                 ExpInitializer ie = vd._init.isExpInitializer();\n-                if (ie && (ie.exp.op == TOK.construct || ie.exp.op == TOK.blit))\n+                if (ie && (ie.exp.op == EXP.construct || ie.exp.op == EXP.blit))\n                     (cast(AssignExp)ie.exp).e2.expressionToBuffer(buf, hgs);\n                 else\n                     vd._init.initializerToBuffer(buf, hgs);\n@@ -1511,7 +1511,7 @@ public:\n         {\n             buf.writestring(\" = \");\n             auto ie = v._init.isExpInitializer();\n-            if (ie && (ie.exp.op == TOK.construct || ie.exp.op == TOK.blit))\n+            if (ie && (ie.exp.op == EXP.construct || ie.exp.op == EXP.blit))\n                 (cast(AssignExp)ie.exp).e2.expressionToBuffer(buf, hgs);\n             else\n                 v._init.initializerToBuffer(buf, hgs);\n@@ -1569,7 +1569,7 @@ public:\n                 buf.writestring(\"in\");\n                 if (auto es = frequire.isExpStatement())\n                 {\n-                    assert(es.exp && es.exp.op == TOK.assert_);\n+                    assert(es.exp && es.exp.op == EXP.assert_);\n                     buf.writestring(\" (\");\n                     (cast(AssertExp)es.exp).e1.expressionToBuffer(buf, hgs);\n                     buf.writeByte(')');\n@@ -1592,7 +1592,7 @@ public:\n                 buf.writestring(\"out\");\n                 if (auto es = fensure.ensure.isExpStatement())\n                 {\n-                    assert(es.exp && es.exp.op == TOK.assert_);\n+                    assert(es.exp && es.exp.op == EXP.assert_);\n                     buf.writestring(\" (\");\n                     if (fensure.id)\n                     {\n@@ -1749,7 +1749,7 @@ public:\n         buf.writestring(\"invariant\");\n         if(auto es = d.fbody.isExpStatement())\n         {\n-            assert(es.exp && es.exp.op == TOK.assert_);\n+            assert(es.exp && es.exp.op == EXP.assert_);\n             buf.writestring(\" (\");\n             (cast(AssertExp)es.exp).e1.expressionToBuffer(buf, hgs);\n             buf.writestring(\");\");\n@@ -1812,7 +1812,7 @@ public:\n     ////////////////////////////////////////////////////////////////////////////\n     override void visit(Expression e)\n     {\n-        buf.writestring(Token.toString(e.op));\n+        buf.writestring(EXPtoString(e.op));\n     }\n \n     override void visit(IntegerExp e)\n@@ -2278,15 +2278,15 @@ public:\n \n     override void visit(UnaExp e)\n     {\n-        buf.writestring(Token.toString(e.op));\n+        buf.writestring(EXPtoString(e.op));\n         expToBuffer(e.e1, precedence[e.op], buf, hgs);\n     }\n \n     override void visit(BinExp e)\n     {\n         expToBuffer(e.e1, precedence[e.op], buf, hgs);\n         buf.writeByte(' ');\n-        buf.writestring(Token.toString(e.op));\n+        buf.writestring(EXPtoString(e.op));\n         buf.writeByte(' ');\n         expToBuffer(e.e2, cast(PREC)(precedence[e.op] + 1), buf, hgs);\n     }\n@@ -2415,7 +2415,7 @@ public:\n \n     override void visit(CallExp e)\n     {\n-        if (e.e1.op == TOK.type)\n+        if (e.e1.op == EXP.type)\n         {\n             /* Avoid parens around type to prevent forbidden cast syntax:\n              *   (sometype)(arg1)\n@@ -2540,12 +2540,12 @@ public:\n     override void visit(PostExp e)\n     {\n         expToBuffer(e.e1, precedence[e.op], buf, hgs);\n-        buf.writestring(Token.toString(e.op));\n+        buf.writestring(EXPtoString(e.op));\n     }\n \n     override void visit(PreExp e)\n     {\n-        buf.writestring(Token.toString(e.op));\n+        buf.writestring(EXPtoString(e.op));\n         expToBuffer(e.e1, precedence[e.op], buf, hgs);\n     }\n \n@@ -2568,7 +2568,7 @@ public:\n \n     override void visit(DefaultInitExp e)\n     {\n-        buf.writestring(Token.toString(e.op));\n+        buf.writestring(EXPtoString(e.op));\n     }\n \n     override void visit(ClassReferenceExp e)\n@@ -3144,7 +3144,7 @@ private void parameterToBuffer(Parameter p, OutBuffer* buf, HdrGenState* hgs)\n     {\n         buf.writeByte('@');\n \n-        bool isAnonymous = p.userAttribDecl.atts.dim > 0 && (*p.userAttribDecl.atts)[0].op != TOK.call;\n+        bool isAnonymous = p.userAttribDecl.atts.dim > 0 && !(*p.userAttribDecl.atts)[0].isCallExp();\n         if (isAnonymous)\n             buf.writeByte('(');\n \n@@ -3253,9 +3253,9 @@ private void sizeToBuffer(Expression e, OutBuffer* buf, HdrGenState* hgs)\n {\n     if (e.type == Type.tsize_t)\n     {\n-        Expression ex = (e.op == TOK.cast_ ? (cast(CastExp)e).e1 : e);\n+        Expression ex = (e.op == EXP.cast_ ? (cast(CastExp)e).e1 : e);\n         ex = ex.optimize(WANTvalue);\n-        const dinteger_t uval = ex.op == TOK.int64 ? ex.toInteger() : cast(dinteger_t)-1;\n+        const dinteger_t uval = ex.op == EXP.int64 ? ex.toInteger() : cast(dinteger_t)-1;\n         if (cast(sinteger_t)uval >= 0)\n         {\n             dinteger_t sizemax = void;\n@@ -3292,7 +3292,7 @@ private void expToBuffer(Expression e, PREC pr, OutBuffer* buf, HdrGenState* hgs\n     debug\n     {\n         if (precedence[e.op] == PREC.zero)\n-            printf(\"precedence not defined for token '%s'\\n\", Token.toChars(e.op));\n+            printf(\"precedence not defined for token '%s'\\n\", EXPtoString(e.op).ptr);\n     }\n     if (e.op == 0xFF)\n     {\n@@ -3422,7 +3422,7 @@ private void tiargsToBuffer(TemplateInstance ti, OutBuffer* buf, HdrGenState* hg\n         }\n         else if (Expression e = isExpression(oarg))\n         {\n-            if (e.op == TOK.int64 || e.op == TOK.float64 || e.op == TOK.null_ || e.op == TOK.string_ || e.op == TOK.this_)\n+            if (e.op == EXP.int64 || e.op == EXP.float64 || e.op == EXP.null_ || e.op == EXP.string_ || e.op == EXP.this_)\n             {\n                 buf.writestring(e.toChars());\n                 return;\n@@ -3460,7 +3460,7 @@ private void objectToBuffer(RootObject oarg, OutBuffer* buf, HdrGenState* hgs)\n     }\n     else if (auto e = isExpression(oarg))\n     {\n-        if (e.op == TOK.variable)\n+        if (e.op == EXP.variable)\n             e = e.optimize(WANTvalue); // added to fix https://issues.dlang.org/show_bug.cgi?id=7375\n         expToBuffer(e, PREC.assign, buf, hgs);\n     }\n@@ -3962,3 +3962,158 @@ private void typeToBufferx(Type t, OutBuffer* buf, HdrGenState* hgs)\n         case Ttag:       return visitTag(cast(TypeTag)t);\n     }\n }\n+\n+/****************************************\n+ * Convert EXP to char*.\n+ */\n+\n+string EXPtoString(EXP op)\n+{\n+    static immutable char*[EXP.max + 1] strings =\n+    [\n+        EXP.type : \"type\",\n+        EXP.error : \"error\",\n+        EXP.objcClassReference : \"class\",\n+\n+        EXP.typeof_ : \"typeof\",\n+        EXP.mixin_ : \"mixin\",\n+\n+        EXP.import_ : \"import\",\n+        EXP.dotVariable : \"dotvar\",\n+        EXP.scope_ : \"scope\",\n+        EXP.identifier : \"identifier\",\n+        EXP.this_ : \"this\",\n+        EXP.super_ : \"super\",\n+        EXP.int64 : \"long\",\n+        EXP.float64 : \"double\",\n+        EXP.complex80 : \"creal\",\n+        EXP.null_ : \"null\",\n+        EXP.string_ : \"string\",\n+        EXP.arrayLiteral : \"arrayliteral\",\n+        EXP.assocArrayLiteral : \"assocarrayliteral\",\n+        EXP.classReference : \"classreference\",\n+        EXP.file : \"__FILE__\",\n+        EXP.fileFullPath : \"__FILE_FULL_PATH__\",\n+        EXP.line : \"__LINE__\",\n+        EXP.moduleString : \"__MODULE__\",\n+        EXP.functionString : \"__FUNCTION__\",\n+        EXP.prettyFunction : \"__PRETTY_FUNCTION__\",\n+        EXP.typeid_ : \"typeid\",\n+        EXP.is_ : \"is\",\n+        EXP.assert_ : \"assert\",\n+        EXP.halt : \"halt\",\n+        EXP.template_ : \"template\",\n+        EXP.dSymbol : \"symbol\",\n+        EXP.function_ : \"function\",\n+        EXP.variable : \"var\",\n+        EXP.symbolOffset : \"symoff\",\n+        EXP.structLiteral : \"structLiteral\",\n+        EXP.compoundLiteral : \"compoundliteral\",\n+        EXP.arrayLength : \"arraylength\",\n+        EXP.delegatePointer : \"delegateptr\",\n+        EXP.delegateFunctionPointer : \"delegatefuncptr\",\n+        EXP.remove : \"remove\",\n+        EXP.tuple : \"tuple\",\n+        EXP.traits : \"__traits\",\n+        EXP.default_ : \"default\",\n+        EXP.overloadSet : \"__overloadset\",\n+        EXP.void_ : \"void\",\n+        EXP.vectorArray : \"vectorarray\",\n+        EXP._Generic : \"_Generic\",\n+\n+        // post\n+        EXP.dotTemplateInstance : \"dotti\",\n+        EXP.dotIdentifier : \"dotid\",\n+        EXP.dotTemplateDeclaration : \"dottd\",\n+        EXP.dot : \".\",\n+        EXP.dotType : \"dottype\",\n+        EXP.plusPlus : \"++\",\n+        EXP.minusMinus : \"--\",\n+        EXP.prePlusPlus : \"++\",\n+        EXP.preMinusMinus : \"--\",\n+        EXP.call : \"call\",\n+        EXP.slice : \"..\",\n+        EXP.array : \"[]\",\n+        EXP.index : \"[i]\",\n+\n+        EXP.delegate_ : \"delegate\",\n+        EXP.address : \"&\",\n+        EXP.star : \"*\",\n+        EXP.negate : \"-\",\n+        EXP.uadd : \"+\",\n+        EXP.not : \"!\",\n+        EXP.tilde : \"~\",\n+        EXP.delete_ : \"delete\",\n+        EXP.new_ : \"new\",\n+        EXP.newAnonymousClass : \"newanonclass\",\n+        EXP.cast_ : \"cast\",\n+\n+        EXP.vector : \"__vector\",\n+        EXP.pow : \"^^\",\n+\n+        EXP.mul : \"*\",\n+        EXP.div : \"/\",\n+        EXP.mod : \"%\",\n+\n+        EXP.add : \"+\",\n+        EXP.min : \"-\",\n+        EXP.concatenate : \"~\",\n+\n+        EXP.leftShift : \"<<\",\n+        EXP.rightShift : \">>\",\n+        EXP.unsignedRightShift : \">>>\",\n+\n+        EXP.lessThan : \"<\",\n+        EXP.lessOrEqual : \"<=\",\n+        EXP.greaterThan : \">\",\n+        EXP.greaterOrEqual : \">=\",\n+        EXP.in_ : \"in\",\n+\n+        EXP.equal : \"==\",\n+        EXP.notEqual : \"!=\",\n+        EXP.identity : \"is\",\n+        EXP.notIdentity : \"!is\",\n+\n+        EXP.and : \"&\",\n+        EXP.xor : \"^\",\n+        EXP.or : \"|\",\n+\n+        EXP.andAnd : \"&&\",\n+        EXP.orOr : \"||\",\n+\n+        EXP.question : \"?\",\n+\n+        EXP.assign : \"=\",\n+        EXP.construct : \"=\",\n+        EXP.blit : \"=\",\n+        EXP.addAssign : \"+=\",\n+        EXP.minAssign : \"-=\",\n+        EXP.concatenateAssign : \"~=\",\n+        EXP.concatenateElemAssign : \"~=\",\n+        EXP.concatenateDcharAssign : \"~=\",\n+        EXP.mulAssign : \"*=\",\n+        EXP.divAssign : \"/=\",\n+        EXP.modAssign : \"%=\",\n+        EXP.powAssign : \"^^=\",\n+        EXP.leftShiftAssign : \"<<=\",\n+        EXP.rightShiftAssign : \">>=\",\n+        EXP.unsignedRightShiftAssign : \">>>=\",\n+        EXP.andAssign : \"&=\",\n+        EXP.orAssign : \"|=\",\n+        EXP.xorAssign : \"^=\",\n+\n+        EXP.comma : \",\",\n+        EXP.declaration : \"declaration\",\n+\n+        EXP.interval : \"interval\",\n+    ];\n+    const p = strings[op];\n+    if (!p)\n+    {\n+        printf(\"error: EXP %d has no string\\n\", op);\n+        return \"XXXXX\";\n+        //assert(0);\n+    }\n+    assert(p);\n+    return p[0 .. strlen(p)];\n+}"}, {"sha": "cd3011731f55220ceb535f8a4ff871268d80bb1b", "filename": "gcc/d/dmd/iasmgcc.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fiasmgcc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fiasmgcc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fiasmgcc.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -348,7 +348,7 @@ extern (C++) public Statement gccAsmSemantic(GccAsmStatement s, Scope *sc)\n \n             e = (*s.constraints)[i];\n             e = e.expressionSemantic(sc);\n-            assert(e.op == TOK.string_ && (cast(StringExp) e).sz == 1);\n+            assert(e.op == EXP.string_ && (cast(StringExp) e).sz == 1);\n             (*s.constraints)[i] = e;\n         }\n     }\n@@ -360,7 +360,7 @@ extern (C++) public Statement gccAsmSemantic(GccAsmStatement s, Scope *sc)\n         {\n             Expression e = (*s.clobbers)[i];\n             e = e.expressionSemantic(sc);\n-            assert(e.op == TOK.string_ && (cast(StringExp) e).sz == 1);\n+            assert(e.op == EXP.string_ && (cast(StringExp) e).sz == 1);\n             (*s.clobbers)[i] = e;\n         }\n     }"}, {"sha": "83c89c05fda1630612e97daac544de219684f252", "filename": "gcc/d/dmd/id.d", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fid.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fid.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fid.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -315,6 +315,8 @@ immutable Msgtable[] msgtable =\n     { \"dup\" },\n     { \"_aaApply\" },\n     { \"_aaApply2\" },\n+    { \"_d_arrayctor\" },\n+    { \"_d_arraysetctor\" },\n \n     // For pragma's\n     { \"Pinline\", \"inline\" },\n@@ -463,6 +465,7 @@ immutable Msgtable[] msgtable =\n     { \"getUnitTests\" },\n     { \"getVirtualIndex\" },\n     { \"getPointerBitmap\" },\n+    { \"initSymbol\" },\n     { \"getCppNamespaces\" },\n     { \"isReturnOnStack\" },\n     { \"isZeroInit\" },"}, {"sha": "c5aa0f46dd1fdcda39c2d0bdf9550aa61a03a396", "filename": "gcc/d/dmd/initsem.d", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Finitsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Finitsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finitsem.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -225,7 +225,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n                 auto tm = vd.type.addMod(t.mod);\n                 auto iz = i.value[j].initializerSemantic(sc, tm, needInterpret);\n                 auto ex = iz.initializerToExpression();\n-                if (ex.op == TOK.error)\n+                if (ex.op == EXP.error)\n                 {\n                     errors = true;\n                     elems[fieldi] = ErrorExp.get(); // for better diagnostics on multiple errors\n@@ -331,7 +331,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n                     errors = true;\n                 }\n                 length = cast(uint)idxvalue;\n-                if (idx.op == TOK.error)\n+                if (idx.op == EXP.error)\n                     errors = true;\n             }\n             Initializer val = i.value[j];\n@@ -344,7 +344,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n                 errors = true;\n             ei = val.isExpInitializer();\n             // found a tuple, expand it\n-            if (ei && ei.exp.op == TOK.tuple)\n+            if (ei && ei.exp.op == EXP.tuple)\n             {\n                 TupleExp te = cast(TupleExp)ei.exp;\n                 i.index.remove(j);\n@@ -384,6 +384,8 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n             return err();\n \n         const sz = t.nextOf().size();\n+        if (sz == SIZE_INVALID)\n+            return err();\n         bool overflow;\n         const max = mulu(i.dim, sz, overflow);\n         if (overflow || max >= amax)\n@@ -403,7 +405,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n         i.exp = resolveProperties(sc, i.exp);\n         if (needInterpret)\n             sc = sc.endCTFE();\n-        if (i.exp.op == TOK.error)\n+        if (i.exp.op == EXP.error)\n             return err();\n         uint olderrors = global.errors;\n \n@@ -437,7 +439,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n                  */\n                 i.exp = i.exp.optimize(WANTvalue);\n             i.exp = i.exp.ctfeInterpret();\n-            if (i.exp.op == TOK.voidExpression)\n+            if (i.exp.op == EXP.voidExpression)\n                 error(i.loc, \"variables cannot be initialized with an expression of type `void`. Use `void` initialization instead.\");\n         }\n         else\n@@ -455,7 +457,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n             i.exp = new TupleExp(i.exp.loc, new Expressions());\n             i.exp.type = et;\n         }\n-        if (i.exp.op == TOK.type)\n+        if (i.exp.op == EXP.type)\n         {\n             i.exp.error(\"initializer must be an expression, not `%s`\", i.exp.toChars());\n             return err();\n@@ -467,7 +469,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n             return err();\n         }\n         Type ti = i.exp.type.toBasetype();\n-        if (i.exp.op == TOK.tuple && i.expandTuples && !i.exp.implicitConvTo(t))\n+        if (i.exp.op == EXP.tuple && i.expandTuples && !i.exp.implicitConvTo(t))\n         {\n             return new ExpInitializer(i.loc, i.exp);\n         }\n@@ -477,7 +479,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n          * Allow this by doing an explicit cast, which will lengthen the string\n          * literal.\n          */\n-        if (i.exp.op == TOK.string_ && tb.ty == Tsarray)\n+        if (i.exp.op == EXP.string_ && tb.ty == Tsarray)\n         {\n             StringExp se = cast(StringExp)i.exp;\n             Type typeb = se.type.toBasetype();\n@@ -562,12 +564,12 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n             {\n                 uinteger_t dim1 = (cast(TypeSArray)tb).dim.toInteger();\n                 uinteger_t dim2 = dim1;\n-                if (i.exp.op == TOK.arrayLiteral)\n+                if (i.exp.op == EXP.arrayLiteral)\n                 {\n                     ArrayLiteralExp ale = cast(ArrayLiteralExp)i.exp;\n                     dim2 = ale.elements ? ale.elements.dim : 0;\n                 }\n-                else if (i.exp.op == TOK.slice)\n+                else if (i.exp.op == EXP.slice)\n                 {\n                     Type tx = toStaticArrayType(cast(SliceExp)i.exp);\n                     if (tx)\n@@ -582,7 +584,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n             i.exp = i.exp.implicitCastTo(sc, t);\n         }\n     L1:\n-        if (i.exp.op == TOK.error)\n+        if (i.exp.op == EXP.error)\n         {\n             return i;\n         }\n@@ -667,7 +669,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n                 auto tm = vd.type.addMod(ts.mod);\n                 auto iz = di.initializer.initializerSemantic(sc, tm, needInterpret);\n                 auto ex = iz.initializerToExpression();\n-                if (ex.op == TOK.error)\n+                if (ex.op == EXP.error)\n                 {\n                     errors = true;\n                     continue;\n@@ -823,6 +825,8 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n         }\n \n         const sz = tn.size(); // element size\n+        if (sz == SIZE_INVALID)\n+            return err();\n         bool overflow;\n         const max = mulu(edim, sz, overflow);\n         if (overflow || max >= amax)\n@@ -930,7 +934,7 @@ Initializer inferType(Initializer init, Scope* sc)\n                 }\n                 assert(iz.isExpInitializer());\n                 (*values)[i] = (cast(ExpInitializer)iz).exp;\n-                assert((*values)[i].op != TOK.error);\n+                assert(!(*values)[i].isErrorExp());\n             }\n             Expression e = new AssocArrayLiteralExp(init.loc, keys, values);\n             auto ei = new ExpInitializer(init.loc, e);\n@@ -953,7 +957,7 @@ Initializer inferType(Initializer init, Scope* sc)\n                 }\n                 assert(iz.isExpInitializer());\n                 (*elements)[i] = (cast(ExpInitializer)iz).exp;\n-                assert((*elements)[i].op != TOK.error);\n+                assert(!(*elements)[i].isErrorExp());\n             }\n             Expression e = new ArrayLiteralExp(init.loc, null, elements);\n             auto ei = new ExpInitializer(init.loc, e);\n@@ -977,11 +981,11 @@ Initializer inferType(Initializer init, Scope* sc)\n         init.exp = init.exp.expressionSemantic(sc);\n \n         // for static alias this: https://issues.dlang.org/show_bug.cgi?id=17684\n-        if (init.exp.op == TOK.type)\n+        if (init.exp.op == EXP.type)\n             init.exp = resolveAliasThis(sc, init.exp);\n \n         init.exp = resolveProperties(sc, init.exp);\n-        if (init.exp.op == TOK.scope_)\n+        if (init.exp.op == EXP.scope_)\n         {\n             ScopeExp se = cast(ScopeExp)init.exp;\n             TemplateInstance ti = se.sds.isTemplateInstance();\n@@ -1006,16 +1010,16 @@ Initializer inferType(Initializer init, Scope* sc)\n                 return new ErrorInitializer();\n             }\n         }\n-        if (init.exp.op == TOK.address)\n+        if (init.exp.op == EXP.address)\n         {\n             AddrExp ae = cast(AddrExp)init.exp;\n-            if (ae.e1.op == TOK.overloadSet)\n+            if (ae.e1.op == EXP.overloadSet)\n             {\n                 init.exp.error(\"cannot infer type from overloaded function symbol `%s`\", init.exp.toChars());\n                 return new ErrorInitializer();\n             }\n         }\n-        if (init.exp.op == TOK.error)\n+        if (init.exp.op == EXP.error)\n         {\n             return new ErrorInitializer();\n         }\n@@ -1125,7 +1129,7 @@ extern (C++) Expression initializerToExpression(Initializer init, Type itype = n\n             {\n                 if (auto e = init.index[i])\n                 {\n-                    if (e.op == TOK.int64)\n+                    if (e.op == EXP.int64)\n                     {\n                         const uinteger_t idxval = e.toInteger();\n                         if (idxval >= amax)\n@@ -1206,7 +1210,7 @@ extern (C++) Expression initializerToExpression(Initializer init, Type itype = n\n          */\n         foreach (e; (*elements)[0 .. edim])\n         {\n-            if (e.op == TOK.error)\n+            if (e.op == EXP.error)\n             {\n                 return e;\n             }\n@@ -1222,7 +1226,7 @@ extern (C++) Expression initializerToExpression(Initializer init, Type itype = n\n         {\n             //printf(\"ExpInitializer::toExpression(t = %s) exp = %s\\n\", itype.toChars(), i.exp.toChars());\n             Type tb = itype.toBasetype();\n-            Expression e = (i.exp.op == TOK.construct || i.exp.op == TOK.blit) ? (cast(AssignExp)i.exp).e2 : i.exp;\n+            Expression e = (i.exp.op == EXP.construct || i.exp.op == EXP.blit) ? (cast(AssignExp)i.exp).e2 : i.exp;\n             if (tb.ty == Tsarray && e.implicitConvTo(tb.nextOf()))\n             {\n                 TypeSArray tsa = cast(TypeSArray)tb;\n@@ -1277,7 +1281,7 @@ private bool hasNonConstPointers(Expression e)\n \n     if (e.type.ty == Terror)\n         return false;\n-    if (e.op == TOK.null_)\n+    if (e.op == EXP.null_)\n         return false;\n     if (auto se = e.isStructLiteralExp())\n     {\n@@ -1318,11 +1322,11 @@ private bool hasNonConstPointers(Expression e)\n     }\n     if (e.type.ty == Tpointer && !e.type.isPtrToFunction())\n     {\n-        if (e.op == TOK.symbolOffset) // address of a global is OK\n+        if (e.op == EXP.symbolOffset) // address of a global is OK\n             return false;\n-        if (e.op == TOK.int64) // cast(void *)int is OK\n+        if (e.op == EXP.int64) // cast(void *)int is OK\n             return false;\n-        if (e.op == TOK.string_) // \"abc\".ptr is OK\n+        if (e.op == EXP.string_) // \"abc\".ptr is OK\n             return false;\n         return true;\n     }"}, {"sha": "336f8dd80ec52d58fca8d0ceedb37e2de4b0f636", "filename": "gcc/d/dmd/lambdacomp.d", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Flambdacomp.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Flambdacomp.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Flambdacomp.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -26,6 +26,7 @@ import dmd.dtemplate;\n import dmd.expression;\n import dmd.func;\n import dmd.dmangle;\n+import dmd.hdrgen;\n import dmd.mtype;\n import dmd.common.outbuffer;\n import dmd.root.rmem;\n@@ -337,7 +338,7 @@ public:\n             return;\n \n         buf.writeByte('(');\n-        buf.writestring(Token.toString(exp.op));\n+        buf.writestring(EXPtoString(exp.op));\n         exp.e1.accept(this);\n         if (buf.length != 0)\n             buf.writestring(\")_\");\n@@ -370,7 +371,7 @@ public:\n             return;\n \n         buf.writeByte('(');\n-        buf.writestring(Token.toChars(exp.op));\n+        buf.writestring(EXPtoString(exp.op).ptr);\n \n         exp.e1.accept(this);\n         if (buf.length == 0)"}, {"sha": "d38cce4ca007860675ae5e8d7f726a9dfb3cdd17", "filename": "gcc/d/dmd/lexer.d", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Flexer.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Flexer.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Flexer.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -386,6 +386,20 @@ class Lexer\n                 // Intentionally not advancing `p`, such that subsequent calls keep returning TOK.endOfFile.\n                 return;\n             case ' ':\n+                // Skip 4 spaces at a time after aligning 'p' to a 4-byte boundary.\n+                while ((cast(size_t)p) % uint.sizeof)\n+                {\n+                    if (*p != ' ')\n+                        goto LendSkipFourSpaces;\n+                    p++;\n+                }\n+                while (*(cast(uint*)p) == 0x20202020) // ' ' == 0x20\n+                    p += 4;\n+                // Skip over any remaining space on the line.\n+                while (*p == ' ')\n+                    p++;\n+            LendSkipFourSpaces:\n+                continue; // skip white space\n             case '\\t':\n             case '\\v':\n             case '\\f':\n@@ -394,19 +408,11 @@ class Lexer\n             case '\\r':\n                 p++;\n                 if (*p != '\\n') // if CR stands by itself\n-                {\n                     endOfLine();\n-                    goto skipFourSpaces;\n-                }\n                 continue; // skip white space\n             case '\\n':\n                 p++;\n                 endOfLine();\n-                skipFourSpaces:\n-                while (*(cast(uint*)p) == 0x20202020) //' ' == 0x20\n-                {\n-                    p+=4;\n-                }\n                 continue; // skip white space\n             case '0':\n                 if (!isZeroSecond(p[1]))        // if numeric literal does not continue"}, {"sha": "e338a05a524cea5f165a57c62b70e96ea4bc63af", "filename": "gcc/d/dmd/mtype.d", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fmtype.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fmtype.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -515,7 +515,7 @@ extern (C++) abstract class Type : ASTNode\n                         }\n                         else if (tp1.ty == Tdelegate)\n                         {\n-                            if (tp1.implicitConvTo(tp2))\n+                            if (tp2.implicitConvTo(tp1))\n                                 goto Lcov;\n                         }\n                     }\n@@ -4783,7 +4783,7 @@ extern (C++) final class TypeFunction : TypeNext\n                             goto Nomatch;\n                         }\n \n-                        if (arg.op == TOK.string_ && tp.ty == Tsarray)\n+                        if (arg.op == EXP.string_ && tp.ty == Tsarray)\n                         {\n                             if (ta.ty != Tsarray)\n                             {\n@@ -4792,7 +4792,7 @@ extern (C++) final class TypeFunction : TypeNext\n                                 ta = tn.sarrayOf(dim);\n                             }\n                         }\n-                        else if (arg.op == TOK.slice && tp.ty == Tsarray)\n+                        else if (arg.op == EXP.slice && tp.ty == Tsarray)\n                         {\n                             // Allow conversion from T[lwr .. upr] to ref T[upr-lwr]\n                             if (ta.ty != Tsarray)\n@@ -4805,7 +4805,7 @@ extern (C++) final class TypeFunction : TypeNext\n                         else if ((p.storageClass & STC.in_) && global.params.previewIn)\n                         {\n                             // Allow converting a literal to an `in` which is `ref`\n-                            if (arg.op == TOK.arrayLiteral && tp.ty == Tsarray)\n+                            if (arg.op == EXP.arrayLiteral && tp.ty == Tsarray)\n                             {\n                                 Type tn = tp.nextOf();\n                                 dinteger_t dim = (cast(TypeSArray)tp).dim.toUInteger();\n@@ -4988,7 +4988,7 @@ extern (C++) final class TypeFunction : TypeNext\n     {\n         assert(to);\n \n-        if (this == to)\n+        if (this.equals(to))\n             return MATCH.constant;\n \n         if (this.covariant(to) == Covariant.yes)\n@@ -5301,7 +5301,7 @@ extern (C++) final class TypeDelegate : TypeNext\n         //printf(\"TypeDelegate.implicitConvTo(this=%p, to=%p)\\n\", this, to);\n         //printf(\"from: %s\\n\", toChars());\n         //printf(\"to  : %s\\n\", to.toChars());\n-        if (this == to)\n+        if (this.equals(to))\n             return MATCH.exact;\n \n         if (auto toDg = to.isTypeDelegate())\n@@ -5814,7 +5814,7 @@ extern (C++) final class TypeStruct : Type\n             }\n             else\n                 e = vd.type.defaultInitLiteral(loc);\n-            if (e && e.op == TOK.error)\n+            if (e && e.op == EXP.error)\n                 return e;\n             if (e)\n                 offset = vd.offset + cast(uint)vd.type.size();\n@@ -6225,7 +6225,7 @@ extern (C++) final class TypeEnum : Type\n \n     override bool isZeroInit(const ref Loc loc)\n     {\n-        return sym.getDefaultValue(loc).isBool(false);\n+        return sym.getDefaultValue(loc).toBool().hasValue(false);\n     }\n \n     override bool hasPointers()"}, {"sha": "31a25a714178a2eba0c595351c3ec5b178aa1339", "filename": "gcc/d/dmd/nogc.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fnogc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fnogc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fnogc.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -136,7 +136,7 @@ public:\n \n     override void visit(DeleteExp e)\n     {\n-        if (e.e1.op == TOK.variable)\n+        if (e.e1.op == EXP.variable)\n         {\n             VarDeclaration v = (cast(VarExp)e.e1).var.isVarDeclaration();\n             if (v && v.onstack)\n@@ -189,7 +189,7 @@ public:\n \n     override void visit(AssignExp e)\n     {\n-        if (e.e1.op == TOK.arrayLength)\n+        if (e.e1.op == EXP.arrayLength)\n         {\n             if (f.setGC())\n             {\n@@ -230,7 +230,7 @@ public:\n Expression checkGC(Scope* sc, Expression e)\n {\n     FuncDeclaration f = sc.func;\n-    if (e && e.op != TOK.error && f && sc.intypeof != 1 && !(sc.flags & SCOPE.ctfe) &&\n+    if (e && e.op != EXP.error && f && sc.intypeof != 1 && !(sc.flags & SCOPE.ctfe) &&\n            (f.type.ty == Tfunction &&\n             (cast(TypeFunction)f.type).isnogc || (f.flags & FUNCFLAG.nogcInprocess) || global.params.vgc) &&\n            !(sc.flags & SCOPE.debug_))"}, {"sha": "156428eb6991c3406fe4ad1dd380a256d8dd8373", "filename": "gcc/d/dmd/ob.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fob.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fob.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fob.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -1362,7 +1362,7 @@ void genKill(ref ObState obstate, ObNode* ob)\n \n             override void visit(Expression e)\n             {\n-                //printf(\"[%s] %s: %s\\n\", e.loc.toChars(), Token.toChars(e.op), e.toChars());\n+                //printf(\"[%s] %s: %s\\n\", e.loc.toChars(), EXPtoString(e.op).ptr, e.toChars());\n                 //assert(0);\n             }\n \n@@ -1644,7 +1644,7 @@ void genKill(ref ObState obstate, ObNode* ob)\n                  * allowed, but CTFE can generate one out of a new expression,\n                  * but it'll be placed in static data so no need to check it.\n                  */\n-                if (e.e1.op != TOK.structLiteral)\n+                if (e.e1.op != EXP.structLiteral)\n                     e.e1.accept(this);\n             }\n \n@@ -2378,7 +2378,7 @@ void checkObErrors(ref ObState obstate)\n                  * allowed, but CTFE can generate one out of a new expression,\n                  * but it'll be placed in static data so no need to check it.\n                  */\n-                if (e.e1.op != TOK.structLiteral)\n+                if (e.e1.op != EXP.structLiteral)\n                     e.e1.accept(this);\n             }\n "}, {"sha": "42363818dd813505ea7203cac047f346974b3dbf", "filename": "gcc/d/dmd/objc.d", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fobjc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fobjc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fobjc.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -540,10 +540,10 @@ extern(C++) private final class Supported : Objc\n     override void setSelector(FuncDeclaration fd, Scope* sc)\n     {\n         foreachUda(fd, sc, (e) {\n-            if (e.op != TOK.structLiteral)\n+            if (!e.isStructLiteralExp())\n                 return 0;\n \n-            auto literal = cast(StructLiteralExp) e;\n+            auto literal = e.isStructLiteralExp();\n             assert(literal.sd);\n \n             if (!isCoreUda(literal.sd, Id.udaSelector))\n@@ -616,10 +616,10 @@ extern(C++) private final class Supported : Objc\n         int count;\n \n         foreachUda(fd, sc, (e) {\n-            if (e.op != TOK.type)\n+            if (!e.isTypeExp())\n                 return 0;\n \n-            auto typeExp = cast(TypeExp) e;\n+            auto typeExp = e.isTypeExp();\n \n             if (typeExp.type.ty != Tenum)\n                 return 0;\n@@ -861,10 +861,10 @@ extern(D) private:\n         arrayExpressionSemantic(udas, sc, true);\n \n         return udas.each!((uda) {\n-            if (uda.op != TOK.tuple)\n+            if (!uda.isTupleExp())\n                 return 0;\n \n-            auto exps = (cast(TupleExp) uda).exps;\n+            auto exps = uda.isTupleExp().exps;\n \n             return exps.each!((e) {\n                 assert(e);"}, {"sha": "4d250c04771a43dd968e6f6dbc584eb6a0c88cea", "filename": "gcc/d/dmd/opover.d", "status": "modified", "additions": 162, "deletions": 161, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fopover.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fopover.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fopover.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -29,6 +29,7 @@ import dmd.expression;\n import dmd.expressionsem;\n import dmd.func;\n import dmd.globals;\n+import dmd.hdrgen;\n import dmd.id;\n import dmd.identifier;\n import dmd.mtype;\n@@ -41,23 +42,23 @@ import dmd.visitor;\n  * Determine if operands of binary op can be reversed\n  * to fit operator overload.\n  */\n-bool isCommutative(TOK op)\n+bool isCommutative(EXP op)\n {\n     switch (op)\n     {\n-    case TOK.add:\n-    case TOK.mul:\n-    case TOK.and:\n-    case TOK.or:\n-    case TOK.xor:\n+    case EXP.add:\n+    case EXP.mul:\n+    case EXP.and:\n+    case EXP.or:\n+    case EXP.xor:\n     // EqualExp\n-    case TOK.equal:\n-    case TOK.notEqual:\n+    case EXP.equal:\n+    case EXP.notEqual:\n     // CmpExp\n-    case TOK.lessThan:\n-    case TOK.lessOrEqual:\n-    case TOK.greaterThan:\n-    case TOK.greaterOrEqual:\n+    case EXP.lessThan:\n+    case EXP.lessOrEqual:\n+    case EXP.greaterThan:\n+    case EXP.greaterOrEqual:\n         return true;\n     default:\n         break;\n@@ -72,47 +73,47 @@ private Identifier opId(Expression e)\n {\n     switch (e.op)\n     {\n-    case TOK.uadd:                      return Id.uadd;\n-    case TOK.negate:                    return Id.neg;\n-    case TOK.tilde:                     return Id.com;\n-    case TOK.cast_:                     return Id._cast;\n-    case TOK.in_:                       return Id.opIn;\n-    case TOK.plusPlus:                  return Id.postinc;\n-    case TOK.minusMinus:                return Id.postdec;\n-    case TOK.add:                       return Id.add;\n-    case TOK.min:                       return Id.sub;\n-    case TOK.mul:                       return Id.mul;\n-    case TOK.div:                       return Id.div;\n-    case TOK.mod:                       return Id.mod;\n-    case TOK.pow:                       return Id.pow;\n-    case TOK.leftShift:                 return Id.shl;\n-    case TOK.rightShift:                return Id.shr;\n-    case TOK.unsignedRightShift:        return Id.ushr;\n-    case TOK.and:                       return Id.iand;\n-    case TOK.or:                        return Id.ior;\n-    case TOK.xor:                       return Id.ixor;\n-    case TOK.concatenate:               return Id.cat;\n-    case TOK.assign:                    return Id.assign;\n-    case TOK.addAssign:                 return Id.addass;\n-    case TOK.minAssign:                 return Id.subass;\n-    case TOK.mulAssign:                 return Id.mulass;\n-    case TOK.divAssign:                 return Id.divass;\n-    case TOK.modAssign:                 return Id.modass;\n-    case TOK.powAssign:                 return Id.powass;\n-    case TOK.leftShiftAssign:           return Id.shlass;\n-    case TOK.rightShiftAssign:          return Id.shrass;\n-    case TOK.unsignedRightShiftAssign:  return Id.ushrass;\n-    case TOK.andAssign:                 return Id.andass;\n-    case TOK.orAssign:                  return Id.orass;\n-    case TOK.xorAssign:                 return Id.xorass;\n-    case TOK.concatenateAssign:         return Id.catass;\n-    case TOK.equal:                     return Id.eq;\n-    case TOK.lessThan:\n-    case TOK.lessOrEqual:\n-    case TOK.greaterThan:\n-    case TOK.greaterOrEqual:            return Id.cmp;\n-    case TOK.array:                     return Id.index;\n-    case TOK.star:                      return Id.opStar;\n+    case EXP.uadd:                      return Id.uadd;\n+    case EXP.negate:                    return Id.neg;\n+    case EXP.tilde:                     return Id.com;\n+    case EXP.cast_:                     return Id._cast;\n+    case EXP.in_:                       return Id.opIn;\n+    case EXP.plusPlus:                  return Id.postinc;\n+    case EXP.minusMinus:                return Id.postdec;\n+    case EXP.add:                       return Id.add;\n+    case EXP.min:                       return Id.sub;\n+    case EXP.mul:                       return Id.mul;\n+    case EXP.div:                       return Id.div;\n+    case EXP.mod:                       return Id.mod;\n+    case EXP.pow:                       return Id.pow;\n+    case EXP.leftShift:                 return Id.shl;\n+    case EXP.rightShift:                return Id.shr;\n+    case EXP.unsignedRightShift:        return Id.ushr;\n+    case EXP.and:                       return Id.iand;\n+    case EXP.or:                        return Id.ior;\n+    case EXP.xor:                       return Id.ixor;\n+    case EXP.concatenate:               return Id.cat;\n+    case EXP.assign:                    return Id.assign;\n+    case EXP.addAssign:                 return Id.addass;\n+    case EXP.minAssign:                 return Id.subass;\n+    case EXP.mulAssign:                 return Id.mulass;\n+    case EXP.divAssign:                 return Id.divass;\n+    case EXP.modAssign:                 return Id.modass;\n+    case EXP.powAssign:                 return Id.powass;\n+    case EXP.leftShiftAssign:           return Id.shlass;\n+    case EXP.rightShiftAssign:          return Id.shrass;\n+    case EXP.unsignedRightShiftAssign:  return Id.ushrass;\n+    case EXP.andAssign:                 return Id.andass;\n+    case EXP.orAssign:                  return Id.orass;\n+    case EXP.xorAssign:                 return Id.xorass;\n+    case EXP.concatenateAssign:         return Id.catass;\n+    case EXP.equal:                     return Id.eq;\n+    case EXP.lessThan:\n+    case EXP.lessOrEqual:\n+    case EXP.greaterThan:\n+    case EXP.greaterOrEqual:            return Id.cmp;\n+    case EXP.array:                     return Id.index;\n+    case EXP.star:                      return Id.opStar;\n     default:                            assert(0);\n     }\n }\n@@ -125,76 +126,76 @@ private Identifier opId_r(Expression e)\n {\n     switch (e.op)\n     {\n-    case TOK.in_:               return Id.opIn_r;\n-    case TOK.add:               return Id.add_r;\n-    case TOK.min:               return Id.sub_r;\n-    case TOK.mul:               return Id.mul_r;\n-    case TOK.div:               return Id.div_r;\n-    case TOK.mod:               return Id.mod_r;\n-    case TOK.pow:               return Id.pow_r;\n-    case TOK.leftShift:         return Id.shl_r;\n-    case TOK.rightShift:        return Id.shr_r;\n-    case TOK.unsignedRightShift:return Id.ushr_r;\n-    case TOK.and:               return Id.iand_r;\n-    case TOK.or:                return Id.ior_r;\n-    case TOK.xor:               return Id.ixor_r;\n-    case TOK.concatenate:       return Id.cat_r;\n+    case EXP.in_:               return Id.opIn_r;\n+    case EXP.add:               return Id.add_r;\n+    case EXP.min:               return Id.sub_r;\n+    case EXP.mul:               return Id.mul_r;\n+    case EXP.div:               return Id.div_r;\n+    case EXP.mod:               return Id.mod_r;\n+    case EXP.pow:               return Id.pow_r;\n+    case EXP.leftShift:         return Id.shl_r;\n+    case EXP.rightShift:        return Id.shr_r;\n+    case EXP.unsignedRightShift:return Id.ushr_r;\n+    case EXP.and:               return Id.iand_r;\n+    case EXP.or:                return Id.ior_r;\n+    case EXP.xor:               return Id.ixor_r;\n+    case EXP.concatenate:       return Id.cat_r;\n     default:                    return null;\n     }\n }\n \n /*******************************************\n  * Helper function to turn operator into template argument list\n  */\n-Objects* opToArg(Scope* sc, TOK op)\n+Objects* opToArg(Scope* sc, EXP op)\n {\n     /* Remove the = from op=\n      */\n     switch (op)\n     {\n-    case TOK.addAssign:\n-        op = TOK.add;\n+    case EXP.addAssign:\n+        op = EXP.add;\n         break;\n-    case TOK.minAssign:\n-        op = TOK.min;\n+    case EXP.minAssign:\n+        op = EXP.min;\n         break;\n-    case TOK.mulAssign:\n-        op = TOK.mul;\n+    case EXP.mulAssign:\n+        op = EXP.mul;\n         break;\n-    case TOK.divAssign:\n-        op = TOK.div;\n+    case EXP.divAssign:\n+        op = EXP.div;\n         break;\n-    case TOK.modAssign:\n-        op = TOK.mod;\n+    case EXP.modAssign:\n+        op = EXP.mod;\n         break;\n-    case TOK.andAssign:\n-        op = TOK.and;\n+    case EXP.andAssign:\n+        op = EXP.and;\n         break;\n-    case TOK.orAssign:\n-        op = TOK.or;\n+    case EXP.orAssign:\n+        op = EXP.or;\n         break;\n-    case TOK.xorAssign:\n-        op = TOK.xor;\n+    case EXP.xorAssign:\n+        op = EXP.xor;\n         break;\n-    case TOK.leftShiftAssign:\n-        op = TOK.leftShift;\n+    case EXP.leftShiftAssign:\n+        op = EXP.leftShift;\n         break;\n-    case TOK.rightShiftAssign:\n-        op = TOK.rightShift;\n+    case EXP.rightShiftAssign:\n+        op = EXP.rightShift;\n         break;\n-    case TOK.unsignedRightShiftAssign:\n-        op = TOK.unsignedRightShift;\n+    case EXP.unsignedRightShiftAssign:\n+        op = EXP.unsignedRightShift;\n         break;\n-    case TOK.concatenateAssign:\n-        op = TOK.concatenate;\n+    case EXP.concatenateAssign:\n+        op = EXP.concatenate;\n         break;\n-    case TOK.powAssign:\n-        op = TOK.pow;\n+    case EXP.powAssign:\n+        op = EXP.pow;\n         break;\n     default:\n         break;\n     }\n-    Expression e = new StringExp(Loc.initial, Token.toString(op));\n+    Expression e = new StringExp(Loc.initial, EXPtoString(op));\n     e = e.expressionSemantic(sc);\n     auto tiargs = new Objects();\n     tiargs.push(e);\n@@ -216,13 +217,13 @@ private Expression checkAliasThisForLhs(AggregateDeclaration ad, Scope* sc, BinE\n     BinExp be = cast(BinExp)e.copy();\n     // Resolve 'alias this' but in case of assigment don't resolve properties yet\n     // because 'e1 = e2' could mean 'e1(e2)' or 'e1() = e2'\n-    bool findOnly = (e.op == TOK.assign);\n+    bool findOnly = (e.op == EXP.assign);\n     be.e1 = resolveAliasThis(sc, e.e1, true, findOnly);\n     if (!be.e1)\n         return null;\n \n     Expression result;\n-    if (be.op == TOK.concatenateAssign)\n+    if (be.op == EXP.concatenateAssign)\n         result = be.op_overload(sc);\n     else\n         result = be.trySemantic(sc);\n@@ -247,7 +248,7 @@ private Expression checkAliasThisForRhs(AggregateDeclaration ad, Scope* sc, BinE\n         return null;\n \n     Expression result;\n-    if (be.op == TOK.concatenateAssign)\n+    if (be.op == EXP.concatenateAssign)\n         result = be.op_overload(sc);\n     else\n         result = be.trySemantic(sc);\n@@ -269,17 +270,17 @@ private Expression checkAliasThisForRhs(AggregateDeclaration ad, Scope* sc, BinE\n  *      `null` if not an operator overload,\n  *      otherwise the lowered expression\n  */\n-Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n+Expression op_overload(Expression e, Scope* sc, EXP* pop = null)\n {\n     extern (C++) final class OpOverload : Visitor\n     {\n         alias visit = Visitor.visit;\n     public:\n         Scope* sc;\n-        TOK* pop;\n+        EXP* pop;\n         Expression result;\n \n-        extern (D) this(Scope* sc, TOK* pop)\n+        extern (D) this(Scope* sc, EXP* pop)\n         {\n             this.sc = sc;\n             this.pop = pop;\n@@ -293,22 +294,22 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n         override void visit(UnaExp e)\n         {\n             //printf(\"UnaExp::op_overload() (%s)\\n\", e.toChars());\n-            if (e.e1.op == TOK.array)\n+            if (e.e1.op == EXP.array)\n             {\n                 ArrayExp ae = cast(ArrayExp)e.e1;\n                 ae.e1 = ae.e1.expressionSemantic(sc);\n                 ae.e1 = resolveProperties(sc, ae.e1);\n                 Expression ae1old = ae.e1;\n-                const(bool) maybeSlice = (ae.arguments.dim == 0 || ae.arguments.dim == 1 && (*ae.arguments)[0].op == TOK.interval);\n+                const(bool) maybeSlice = (ae.arguments.dim == 0 || ae.arguments.dim == 1 && (*ae.arguments)[0].op == EXP.interval);\n                 IntervalExp ie = null;\n                 if (maybeSlice && ae.arguments.dim)\n                 {\n-                    assert((*ae.arguments)[0].op == TOK.interval);\n+                    assert((*ae.arguments)[0].op == EXP.interval);\n                     ie = cast(IntervalExp)(*ae.arguments)[0];\n                 }\n                 while (true)\n                 {\n-                    if (ae.e1.op == TOK.error)\n+                    if (ae.e1.op == EXP.error)\n                     {\n                         result = ae.e1;\n                         return;\n@@ -326,7 +327,7 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n                         result = resolveOpDollar(sc, ae, &e0);\n                         if (!result) // op(a[i..j]) might be: a.opSliceUnary!(op)(i, j)\n                             goto Lfallback;\n-                        if (result.op == TOK.error)\n+                        if (result.op == EXP.error)\n                             return;\n                         /* Rewrite op(a[arguments]) as:\n                          *      a.opIndexUnary!(op)(arguments)\n@@ -350,7 +351,7 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n                     {\n                         // Deal with $\n                         result = resolveOpDollar(sc, ae, ie, &e0);\n-                        if (result.op == TOK.error)\n+                        if (result.op == EXP.error)\n                             return;\n                         /* Rewrite op(a[i..j]) as:\n                          *      a.opSliceUnary!(op)(i, j)\n@@ -385,7 +386,7 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n             }\n             e.e1 = e.e1.expressionSemantic(sc);\n             e.e1 = resolveProperties(sc, e.e1);\n-            if (e.e1.op == TOK.error)\n+            if (e.e1.op == EXP.error)\n             {\n                 result = e.e1;\n                 return;\n@@ -407,7 +408,7 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n                     return;\n                 }\n                 // D1-style operator overloads, deprecated\n-                if (e.op != TOK.prePlusPlus && e.op != TOK.preMinusMinus)\n+                if (e.op != EXP.prePlusPlus && e.op != EXP.preMinusMinus)\n                 {\n                     auto id = opId(e);\n                     fd = search_function(ad, id);\n@@ -416,7 +417,7 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n                         // @@@DEPRECATED_2.098@@@.\n                         // Deprecated in 2.088\n                         // Make an error in 2.098\n-                        e.deprecation(\"`%s` is deprecated.  Use `opUnary(string op)() if (op == \\\"%s\\\")` instead.\", id.toChars(), Token.toChars(e.op));\n+                        e.deprecation(\"`%s` is deprecated.  Use `opUnary(string op)() if (op == \\\"%s\\\")` instead.\", id.toChars(), EXPtoString(e.op).ptr);\n                         // Rewrite +e1 as e1.add()\n                         result = build_overload(e.loc, sc, e.e1, null, fd);\n                         return;\n@@ -428,7 +429,7 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n                     /* Rewrite op(e1) as:\n                      *      op(e1.aliasthis)\n                      */\n-                    //printf(\"att una %s e1 = %s\\n\", Token::toChars(op), this.e1.type.toChars());\n+                    //printf(\"att una %s e1 = %s\\n\", EXPtoString(op).ptr, this.e1.type.toChars());\n                     Expression e1 = new DotIdExp(e.loc, e.e1, ad.aliasthis.ident);\n                     UnaExp ue = cast(UnaExp)e.copy();\n                     ue.e1 = e1;\n@@ -444,16 +445,16 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n             ae.e1 = ae.e1.expressionSemantic(sc);\n             ae.e1 = resolveProperties(sc, ae.e1);\n             Expression ae1old = ae.e1;\n-            const(bool) maybeSlice = (ae.arguments.dim == 0 || ae.arguments.dim == 1 && (*ae.arguments)[0].op == TOK.interval);\n+            const(bool) maybeSlice = (ae.arguments.dim == 0 || ae.arguments.dim == 1 && (*ae.arguments)[0].op == EXP.interval);\n             IntervalExp ie = null;\n             if (maybeSlice && ae.arguments.dim)\n             {\n-                assert((*ae.arguments)[0].op == TOK.interval);\n+                assert((*ae.arguments)[0].op == EXP.interval);\n                 ie = cast(IntervalExp)(*ae.arguments)[0];\n             }\n             while (true)\n             {\n-                if (ae.e1.op == TOK.error)\n+                if (ae.e1.op == EXP.error)\n                 {\n                     result = ae.e1;\n                     return;\n@@ -467,7 +468,7 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n                 {\n                     // If the non-aggregate expression ae.e1 is indexable or sliceable,\n                     // convert it to the corresponding concrete expression.\n-                    if (isIndexableNonAggregate(t1b) || ae.e1.op == TOK.type)\n+                    if (isIndexableNonAggregate(t1b) || ae.e1.op == EXP.type)\n                     {\n                         // Convert to SliceExp\n                         if (maybeSlice)\n@@ -492,7 +493,7 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n                     result = resolveOpDollar(sc, ae, &e0);\n                     if (!result) // a[i..j] might be: a.opSlice(i, j)\n                         goto Lfallback;\n-                    if (result.op == TOK.error)\n+                    if (result.op == EXP.error)\n                         return;\n                     /* Rewrite e1[arguments] as:\n                      *      e1.opIndex(arguments)\n@@ -511,7 +512,7 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n                     }\n                 }\n             Lfallback:\n-                if (maybeSlice && ae.e1.op == TOK.type)\n+                if (maybeSlice && ae.e1.op == EXP.type)\n                 {\n                     result = new SliceExp(ae.loc, ae.e1, ie);\n                     result = result.expressionSemantic(sc);\n@@ -522,7 +523,7 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n                 {\n                     // Deal with $\n                     result = resolveOpDollar(sc, ae, ie, &e0);\n-                    if (result.op == TOK.error)\n+                    if (result.op == EXP.error)\n                         return;\n                     /* Rewrite a[i..j] as:\n                      *      a.opSlice(i, j)\n@@ -615,7 +616,7 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n             int argsset = 0;\n             AggregateDeclaration ad1 = isAggregate(e.e1.type);\n             AggregateDeclaration ad2 = isAggregate(e.e2.type);\n-            if (e.op == TOK.assign && ad1 == ad2)\n+            if (e.op == EXP.assign && ad1 == ad2)\n             {\n                 StructDeclaration sd = ad1.isStructDeclaration();\n                 if (sd &&\n@@ -632,13 +633,13 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n             Dsymbol s = null;\n             Dsymbol s_r = null;\n             Objects* tiargs = null;\n-            if (e.op == TOK.plusPlus || e.op == TOK.minusMinus)\n+            if (e.op == EXP.plusPlus || e.op == EXP.minusMinus)\n             {\n                 // Bug4099 fix\n                 if (ad1 && search_function(ad1, Id.opUnary))\n                     return;\n             }\n-            if (e.op != TOK.equal && e.op != TOK.notEqual && e.op != TOK.assign && e.op != TOK.plusPlus && e.op != TOK.minusMinus)\n+            if (e.op != EXP.equal && e.op != EXP.notEqual && e.op != EXP.assign && e.op != EXP.plusPlus && e.op != EXP.minusMinus)\n             {\n                 /* Try opBinary and opBinaryRight\n                  */\n@@ -684,9 +685,9 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n                         // Deprecated in 2.088\n                         // Make an error in 2.098\n                         if (id == Id.postinc || id == Id.postdec)\n-                            e.deprecation(\"`%s` is deprecated.  Use `opUnary(string op)() if (op == \\\"%s\\\")` instead.\", id.toChars(), Token.toChars(e.op));\n+                            e.deprecation(\"`%s` is deprecated.  Use `opUnary(string op)() if (op == \\\"%s\\\")` instead.\", id.toChars(), EXPtoString(e.op).ptr);\n                         else\n-                            e.deprecation(\"`%s` is deprecated.  Use `opBinary(string op)(...) if (op == \\\"%s\\\")` instead.\", id.toChars(), Token.toChars(e.op));\n+                            e.deprecation(\"`%s` is deprecated.  Use `opBinary(string op)(...) if (op == \\\"%s\\\")` instead.\", id.toChars(), EXPtoString(e.op).ptr);\n                     }\n                 }\n                 if (ad2 && id_r)\n@@ -702,7 +703,7 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n                         // @@@DEPRECATED_2.098@@@.\n                         // Deprecated in 2.088\n                         // Make an error in 2.098\n-                        e.deprecation(\"`%s` is deprecated.  Use `opBinaryRight(string op)(...) if (op == \\\"%s\\\")` instead.\", id_r.toChars(), Token.toChars(e.op));\n+                        e.deprecation(\"`%s` is deprecated.  Use `opBinaryRight(string op)(...) if (op == \\\"%s\\\")` instead.\", id_r.toChars(), EXPtoString(e.op).ptr);\n                     }\n                 }\n             }\n@@ -751,7 +752,7 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n                         goto L1;\n                     m.lastf = null;\n                 }\n-                if (e.op == TOK.plusPlus || e.op == TOK.minusMinus)\n+                if (e.op == EXP.plusPlus || e.op == EXP.minusMinus)\n                 {\n                     // Kludge because operator overloading regards e++ and e--\n                     // as unary, but it's implemented as a binary.\n@@ -855,7 +856,7 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n             }\n \n             Expression tempResult;\n-            if (!(e.op == TOK.assign && ad2 && ad1 == ad2)) // https://issues.dlang.org/show_bug.cgi?id=2943\n+            if (!(e.op == EXP.assign && ad2 && ad1 == ad2)) // https://issues.dlang.org/show_bug.cgi?id=2943\n             {\n                 result = checkAliasThisForLhs(ad1, sc, e);\n                 if (result)\n@@ -871,7 +872,7 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n                      * one of the members, hence the `ad1.fields.dim == 2 && ad1.vthis`\n                      * condition.\n                      */\n-                    if (e.op != TOK.assign || e.e1.op == TOK.type)\n+                    if (e.op != EXP.assign || e.e1.op == EXP.type)\n                         return;\n \n                     if (ad1.fields.dim == 1 || (ad1.fields.dim == 2 && ad1.vthis))\n@@ -888,7 +889,7 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n                     tempResult = result;\n                 }\n             }\n-            if (!(e.op == TOK.assign && ad1 && ad1 == ad2)) // https://issues.dlang.org/show_bug.cgi?id=2943\n+            if (!(e.op == EXP.assign && ad1 && ad1 == ad2)) // https://issues.dlang.org/show_bug.cgi?id=2943\n             {\n                 result = checkAliasThisForRhs(ad2, sc, e);\n                 if (result)\n@@ -925,12 +926,12 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n \n             /* Check for class equality with null literal or typeof(null).\n              */\n-            if (t1.ty == Tclass && e.e2.op == TOK.null_ ||\n-                t2.ty == Tclass && e.e1.op == TOK.null_)\n+            if (t1.ty == Tclass && e.e2.op == EXP.null_ ||\n+                t2.ty == Tclass && e.e1.op == EXP.null_)\n             {\n                 e.error(\"use `%s` instead of `%s` when comparing with `null`\",\n-                    Token.toChars(e.op == TOK.equal ? TOK.identity : TOK.notIdentity),\n-                    Token.toChars(e.op));\n+                    EXPtoString(e.op == EXP.equal ? EXP.identity : EXP.notIdentity).ptr,\n+                    EXPtoString(e.op).ptr);\n                 result = ErrorExp.get();\n                 return;\n             }\n@@ -968,7 +969,7 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n                     result = new DotIdExp(e.loc, result, Id.object);\n                     result = new DotIdExp(e.loc, result, Id.eq);\n                     result = new CallExp(e.loc, result, e1x, e2x);\n-                    if (e.op == TOK.notEqual)\n+                    if (e.op == EXP.notEqual)\n                         result = new NotExp(e.loc, result);\n                     result = result.expressionSemantic(sc);\n                     return;\n@@ -978,7 +979,7 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n             result = compare_overload(e, sc, Id.eq, null);\n             if (result)\n             {\n-                if (lastComma(result).op == TOK.call && e.op == TOK.notEqual)\n+                if (lastComma(result).op == EXP.call && e.op == EXP.notEqual)\n                 {\n                     result = new NotExp(result.loc, result);\n                     result = result.expressionSemantic(sc);\n@@ -998,7 +999,7 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n                  * This is just a rewriting for deterministic AST representation\n                  * as the backend input.\n                  */\n-                auto op2 = e.op == TOK.equal ? TOK.identity : TOK.notIdentity;\n+                auto op2 = e.op == EXP.equal ? EXP.identity : EXP.notIdentity;\n                 result = new IdentityExp(op2, e.loc, e.e1, e.e2);\n                 result = result.expressionSemantic(sc);\n                 return;\n@@ -1016,7 +1017,7 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n                 if (!global.params.fieldwise && !needOpEquals(sd))\n                 {\n                     // Use bitwise equality.\n-                    auto op2 = e.op == TOK.equal ? TOK.identity : TOK.notIdentity;\n+                    auto op2 = e.op == EXP.equal ? EXP.identity : EXP.notIdentity;\n                     result = new IdentityExp(op2, e.loc, e.e1, e.e2);\n                     result = result.expressionSemantic(sc);\n                     return;\n@@ -1063,7 +1064,7 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n \n             /* Check for tuple equality.\n              */\n-            if (e.e1.op == TOK.tuple && e.e2.op == TOK.tuple)\n+            if (e.e1.op == EXP.tuple && e.e2.op == EXP.tuple)\n             {\n                 auto tup1 = cast(TupleExp)e.e1;\n                 auto tup2 = cast(TupleExp)e.e2;\n@@ -1079,7 +1080,7 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n                 if (dim == 0)\n                 {\n                     // zero-length tuple comparison should always return true or false.\n-                    result = IntegerExp.createBool(e.op == TOK.equal);\n+                    result = IntegerExp.createBool(e.op == EXP.equal);\n                 }\n                 else\n                 {\n@@ -1093,10 +1094,10 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n \n                         if (!result)\n                             result = eeq;\n-                        else if (e.op == TOK.equal)\n-                            result = new LogicalExp(e.loc, TOK.andAnd, result, eeq);\n+                        else if (e.op == EXP.equal)\n+                            result = new LogicalExp(e.loc, EXP.andAnd, result, eeq);\n                         else\n-                            result = new LogicalExp(e.loc, TOK.orOr, result, eeq);\n+                            result = new LogicalExp(e.loc, EXP.orOr, result, eeq);\n                     }\n                     assert(result);\n                 }\n@@ -1119,22 +1120,22 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n         override void visit(BinAssignExp e)\n         {\n             //printf(\"BinAssignExp::op_overload() (%s)\\n\", e.toChars());\n-            if (e.e1.op == TOK.array)\n+            if (e.e1.op == EXP.array)\n             {\n                 ArrayExp ae = cast(ArrayExp)e.e1;\n                 ae.e1 = ae.e1.expressionSemantic(sc);\n                 ae.e1 = resolveProperties(sc, ae.e1);\n                 Expression ae1old = ae.e1;\n-                const(bool) maybeSlice = (ae.arguments.dim == 0 || ae.arguments.dim == 1 && (*ae.arguments)[0].op == TOK.interval);\n+                const(bool) maybeSlice = (ae.arguments.dim == 0 || ae.arguments.dim == 1 && (*ae.arguments)[0].op == EXP.interval);\n                 IntervalExp ie = null;\n                 if (maybeSlice && ae.arguments.dim)\n                 {\n-                    assert((*ae.arguments)[0].op == TOK.interval);\n+                    assert((*ae.arguments)[0].op == EXP.interval);\n                     ie = cast(IntervalExp)(*ae.arguments)[0];\n                 }\n                 while (true)\n                 {\n-                    if (ae.e1.op == TOK.error)\n+                    if (ae.e1.op == EXP.error)\n                     {\n                         result = ae.e1;\n                         return;\n@@ -1152,10 +1153,10 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n                         result = resolveOpDollar(sc, ae, &e0);\n                         if (!result) // (a[i..j] op= e2) might be: a.opSliceOpAssign!(op)(e2, i, j)\n                             goto Lfallback;\n-                        if (result.op == TOK.error)\n+                        if (result.op == EXP.error)\n                             return;\n                         result = e.e2.expressionSemantic(sc);\n-                        if (result.op == TOK.error)\n+                        if (result.op == EXP.error)\n                             return;\n                         e.e2 = result;\n                         /* Rewrite a[arguments] op= e2 as:\n@@ -1181,10 +1182,10 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n                     {\n                         // Deal with $\n                         result = resolveOpDollar(sc, ae, ie, &e0);\n-                        if (result.op == TOK.error)\n+                        if (result.op == EXP.error)\n                             return;\n                         result = e.e2.expressionSemantic(sc);\n-                        if (result.op == TOK.error)\n+                        if (result.op == EXP.error)\n                             return;\n                         e.e2 = result;\n                         /* Rewrite (a[i..j] op= e2) as:\n@@ -1261,7 +1262,7 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n                     // @@@DEPRECATED_2.098@@@.\n                     // Deprecated in 2.088\n                     // Make an error in 2.098\n-                    scope char[] op = Token.toString(e.op).dup;\n+                    scope char[] op = EXPtoString(e.op).dup;\n                     op[$-1] = '\\0'; // remove trailing `=`\n                     e.deprecation(\"`%s` is deprecated.  Use `opOpAssign(string op)(...) if (op == \\\"%s\\\")` instead.\", id.toChars(), op.ptr);\n                 }\n@@ -1319,7 +1320,7 @@ Expression op_overload(Expression e, Scope* sc, TOK* pop = null)\n /******************************************\n  * Common code for overloading of EqualExp and CmpExp\n  */\n-private Expression compare_overload(BinExp e, Scope* sc, Identifier id, TOK* pop)\n+private Expression compare_overload(BinExp e, Scope* sc, Identifier id, EXP* pop)\n {\n     //printf(\"BinExp::compare_overload(id = %s) %s\\n\", id.toChars(), e.toChars());\n     AggregateDeclaration ad1 = isAggregate(e.e1.type);\n@@ -1415,7 +1416,7 @@ private Expression compare_overload(BinExp e, Scope* sc, Identifier id, TOK* pop\n      * at this point, no matching opEquals was found for structs,\n      * so we should not follow the alias this comparison code.\n      */\n-    if ((e.op == TOK.equal || e.op == TOK.notEqual) && ad1 == ad2)\n+    if ((e.op == EXP.equal || e.op == EXP.notEqual) && ad1 == ad2)\n         return null;\n     Expression result = checkAliasThisForLhs(ad1, sc, e);\n     return result ? result : checkAliasThisForRhs(isAggregate(e.e2.type), sc, e);\n@@ -1482,7 +1483,7 @@ bool inferForeachAggregate(Scope* sc, bool isForeach, ref Expression feaggr, out\n         aggr = aggr.expressionSemantic(sc);\n         aggr = resolveProperties(sc, aggr);\n         aggr = aggr.optimize(WANTvalue);\n-        if (!aggr.type || aggr.op == TOK.error)\n+        if (!aggr.type || aggr.op == EXP.error)\n             return false;\n         Type tab = aggr.type.toBasetype();\n         switch (tab.ty)\n@@ -1507,7 +1508,7 @@ bool inferForeachAggregate(Scope* sc, bool isForeach, ref Expression feaggr, out\n                     // opApply aggregate\n                     break;\n                 }\n-                if (feaggr.op != TOK.type)\n+                if (feaggr.op != EXP.type)\n                 {\n                     /* See if rewriting `aggr` to `aggr[]` will work\n                      */\n@@ -1538,7 +1539,7 @@ bool inferForeachAggregate(Scope* sc, bool isForeach, ref Expression feaggr, out\n         }\n \n         case Tdelegate:        // https://dlang.org/spec/statement.html#foreach_over_delegates\n-            if (aggr.op == TOK.delegate_)\n+            if (aggr.op == EXP.delegate_)\n             {\n                 sapply = (cast(DelegateExp)aggr).func;\n             }\n@@ -1590,7 +1591,7 @@ bool inferApplyArgTypes(ForeachStatement fes, Scope* sc, ref Dsymbol sapply)\n             ethis = fes.aggr;\n         else\n         {\n-            assert(tab.ty == Tdelegate && fes.aggr.op == TOK.delegate_);\n+            assert(tab.ty == Tdelegate && fes.aggr.op == EXP.delegate_);\n             ethis = (cast(DelegateExp)fes.aggr).e1;\n         }\n \n@@ -1854,14 +1855,14 @@ private bool matchParamsToOpApply(TypeFunction tf, Parameters* parameters, bool\n  * Returns:\n  *      reverse of op\n  */\n-private TOK reverseRelation(TOK op) pure\n+private EXP reverseRelation(EXP op) pure\n {\n     switch (op)\n     {\n-        case TOK.greaterOrEqual:  op = TOK.lessOrEqual;    break;\n-        case TOK.greaterThan:     op = TOK.lessThan;       break;\n-        case TOK.lessOrEqual:     op = TOK.greaterOrEqual; break;\n-        case TOK.lessThan:        op = TOK.greaterThan;    break;\n+        case EXP.greaterOrEqual:  op = EXP.lessOrEqual;    break;\n+        case EXP.greaterThan:     op = EXP.lessThan;       break;\n+        case EXP.lessOrEqual:     op = EXP.greaterOrEqual; break;\n+        case EXP.lessThan:        op = EXP.greaterThan;    break;\n         default:                  break;\n     }\n     return op;"}, {"sha": "6b2176b29112bf7ec34f0742219eca162e979482", "filename": "gcc/d/dmd/optimize.d", "status": "modified", "additions": 806, "deletions": 729, "changes": 1535, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Foptimize.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Foptimize.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Foptimize.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -103,14 +103,14 @@ Expression expandVar(int result, VarDeclaration v)\n                     }\n                     return nullReturn();\n                 }\n-                if (ei.op == TOK.construct || ei.op == TOK.blit)\n+                if (ei.op == EXP.construct || ei.op == EXP.blit)\n                 {\n                     AssignExp ae = cast(AssignExp)ei;\n                     ei = ae.e2;\n                     if (ei.isConst() == 1)\n                     {\n                     }\n-                    else if (ei.op == TOK.string_)\n+                    else if (ei.op == EXP.string_)\n                     {\n                         // https://issues.dlang.org/show_bug.cgi?id=14459\n                         // Do not constfold the string literal\n@@ -136,8 +136,8 @@ Expression expandVar(int result, VarDeclaration v)\n                 }\n                 else if (!(v.storage_class & STC.manifest) &&\n                          ei.isConst() != 1 &&\n-                         ei.op != TOK.string_ &&\n-                         ei.op != TOK.address)\n+                         ei.op != EXP.string_ &&\n+                         ei.op != EXP.address)\n                 {\n                     return nullReturn();\n                 }\n@@ -179,17 +179,16 @@ private Expression fromConstInitializer(int result, Expression e1)\n     //printf(\"fromConstInitializer(result = %x, %s)\\n\", result, e1.toChars());\n     //static int xx; if (xx++ == 10) assert(0);\n     Expression e = e1;\n-    if (e1.op == TOK.variable)\n+    if (auto ve = e1.isVarExp())\n     {\n-        VarExp ve = cast(VarExp)e1;\n         VarDeclaration v = ve.var.isVarDeclaration();\n         e = expandVar(result, v);\n         if (e)\n         {\n             // If it is a comma expression involving a declaration, we mustn't\n             // perform a copy -- we'd get two declarations of the same variable.\n             // See bugzilla 4465.\n-            if (e.op == TOK.comma && (cast(CommaExp)e).e1.op == TOK.declaration)\n+            if (e.op == EXP.comma && e.isCommaExp().e1.isDeclarationExp())\n                 e = e1;\n             else if (e.type != e1.type && e1.type && e1.type.ty != Tident)\n             {\n@@ -207,47 +206,53 @@ private Expression fromConstInitializer(int result, Expression e1)\n     return e;\n }\n \n-/* It is possible for constant folding to change an array expression of\n+/***\n+ * It is possible for constant folding to change an array expression of\n  * unknown length, into one where the length is known.\n  * If the expression 'arr' is a literal, set lengthVar to be its length.\n+ * Params:\n+ *    lengthVar = variable declaration for the `.length` property\n+ *    arr = String, ArrayLiteral, or of TypeSArray\n  */\n package void setLengthVarIfKnown(VarDeclaration lengthVar, Expression arr)\n {\n     if (!lengthVar)\n         return;\n     if (lengthVar._init && !lengthVar._init.isVoidInitializer())\n         return; // we have previously calculated the length\n-    size_t len;\n-    if (arr.op == TOK.string_)\n-        len = (cast(StringExp)arr).len;\n-    else if (arr.op == TOK.arrayLiteral)\n-        len = (cast(ArrayLiteralExp)arr).elements.dim;\n+    d_uns64 len;\n+    if (auto se = arr.isStringExp())\n+        len = se.len;\n+    else if (auto ale = arr.isArrayLiteralExp())\n+        len = ale.elements.dim;\n     else\n     {\n-        Type t = arr.type.toBasetype();\n-        if (t.ty == Tsarray)\n-            len = cast(size_t)(cast(TypeSArray)t).dim.toInteger();\n-        else\n+        auto tsa = arr.type.toBasetype().isTypeSArray();\n+        if (!tsa)\n             return; // we don't know the length yet\n+        len = tsa.dim.toInteger();\n     }\n     Expression dollar = new IntegerExp(Loc.initial, len, Type.tsize_t);\n     lengthVar._init = new ExpInitializer(Loc.initial, dollar);\n     lengthVar.storage_class |= STC.static_ | STC.const_;\n }\n \n-/* Same as above, but determines the length from 'type'. */\n+/***\n+ * Same as above, but determines the length from 'type'.\n+ * Params:\n+ *    lengthVar = variable declaration for the `.length` property\n+ *    type = TypeSArray\n+ */\n package void setLengthVarIfKnown(VarDeclaration lengthVar, Type type)\n {\n     if (!lengthVar)\n         return;\n     if (lengthVar._init && !lengthVar._init.isVoidInitializer())\n         return; // we have previously calculated the length\n-    size_t len;\n-    Type t = type.toBasetype();\n-    if (t.ty == Tsarray)\n-        len = cast(size_t)(cast(TypeSArray)t).dim.toInteger();\n-    else\n+    auto tsa = type.toBasetype().isTypeSArray();\n+    if (!tsa)\n         return; // we don't know the length yet\n+    d_uns64 len = tsa.dim.toInteger();\n     Expression dollar = new IntegerExp(Loc.initial, len, Type.tsize_t);\n     lengthVar._init = new ExpInitializer(Loc.initial, dollar);\n     lengthVar.storage_class |= STC.static_ | STC.const_;\n@@ -265,579 +270,477 @@ package void setLengthVarIfKnown(VarDeclaration lengthVar, Type type)\n  */\n Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n {\n-    extern (C++) final class OptimizeVisitor : Visitor\n-    {\n-        alias visit = Visitor.visit;\n-\n-        Expression ret;\n-        private const int result;\n-        private const bool keepLvalue;\n+    Expression ret = e;\n \n-        extern (D) this(Expression e, int result, bool keepLvalue)\n-        {\n-            this.ret = e;               // default result is original expression\n-            this.result = result;\n-            this.keepLvalue = keepLvalue;\n-        }\n+    void error()\n+    {\n+        ret = ErrorExp.get();\n+    }\n \n-        void error()\n+    /* Returns: true if error\n+     */\n+    bool expOptimize(ref Expression e, int flags, bool keepLvalue = false)\n+    {\n+        if (!e)\n+            return false;\n+        Expression ex = Expression_optimize(e, flags, keepLvalue);\n+        if (ex.op == EXP.error)\n         {\n-            ret = ErrorExp.get();\n+            ret = ex; // store error result\n+            return true;\n         }\n-\n-        bool expOptimize(ref Expression e, int flags, bool keepLvalue = false)\n+        else\n         {\n-            if (!e)\n-                return false;\n-            Expression ex = Expression_optimize(e, flags, keepLvalue);\n-            if (ex.op == TOK.error)\n-            {\n-                ret = ex; // store error result\n-                return true;\n-            }\n-            else\n-            {\n-                e = ex; // modify original\n-                return false;\n-            }\n+            e = ex; // modify original\n+            return false;\n         }\n+    }\n \n-        bool unaOptimize(UnaExp e, int flags)\n-        {\n-            return expOptimize(e.e1, flags);\n-        }\n+    bool unaOptimize(UnaExp e, int flags)\n+    {\n+        return expOptimize(e.e1, flags);\n+    }\n \n-        bool binOptimize(BinExp e, int flags, bool keepLhsLvalue = false)\n-        {\n-            expOptimize(e.e1, flags, keepLhsLvalue);\n-            expOptimize(e.e2, flags);\n-            return ret.op == TOK.error;\n-        }\n+    bool binOptimize(BinExp e, int flags, bool keepLhsLvalue = false)\n+    {\n+        return expOptimize(e.e1, flags, keepLhsLvalue) |\n+               expOptimize(e.e2, flags);\n+    }\n \n-        override void visit(Expression e)\n-        {\n-            //printf(\"Expression::optimize(result = x%x) %s\\n\", result, e.toChars());\n-        }\n+    void visitExp(Expression e)\n+    {\n+        //printf(\"Expression::optimize(result = x%x) %s\\n\", result, e.toChars());\n+    }\n \n-        override void visit(VarExp e)\n-        {\n-            VarDeclaration v = e.var.isVarDeclaration();\n+    void visitVar(VarExp e)\n+    {\n+        VarDeclaration v = e.var.isVarDeclaration();\n \n-            if (!(keepLvalue && v && !(v.storage_class & STC.manifest)))\n-                ret = fromConstInitializer(result, e);\n+        if (!(keepLvalue && v && !(v.storage_class & STC.manifest)))\n+            ret = fromConstInitializer(result, e);\n \n-            // if unoptimized, try to optimize the dtor expression\n-            // (e.g., might be a LogicalExp with constant lhs)\n-            if (ret == e && v && v.edtor)\n+        // if unoptimized, try to optimize the dtor expression\n+        // (e.g., might be a LogicalExp with constant lhs)\n+        if (ret == e && v && v.edtor)\n+        {\n+            // prevent infinite recursion (`<var>.~this()`)\n+            if (!v.inuse)\n             {\n-                // prevent infinite recursion (`<var>.~this()`)\n-                if (!v.inuse)\n-                {\n-                    v.inuse++;\n-                    expOptimize(v.edtor, WANTvalue);\n-                    v.inuse--;\n-                }\n+                v.inuse++;\n+                expOptimize(v.edtor, WANTvalue);\n+                v.inuse--;\n             }\n         }\n+    }\n \n-        override void visit(TupleExp e)\n+    void visitTuple(TupleExp e)\n+    {\n+        expOptimize(e.e0, WANTvalue);\n+        for (size_t i = 0; i < e.exps.dim; i++)\n         {\n-            expOptimize(e.e0, WANTvalue);\n-            for (size_t i = 0; i < e.exps.dim; i++)\n-            {\n-                expOptimize((*e.exps)[i], WANTvalue);\n-            }\n+            expOptimize((*e.exps)[i], WANTvalue);\n         }\n+    }\n \n-        override void visit(ArrayLiteralExp e)\n+    void visitArrayLiteral(ArrayLiteralExp e)\n+    {\n+        if (e.elements)\n         {\n-            if (e.elements)\n+            expOptimize(e.basis, result & WANTexpand);\n+            for (size_t i = 0; i < e.elements.dim; i++)\n             {\n-                expOptimize(e.basis, result & WANTexpand);\n-                for (size_t i = 0; i < e.elements.dim; i++)\n-                {\n-                    expOptimize((*e.elements)[i], result & WANTexpand);\n-                }\n+                expOptimize((*e.elements)[i], result & WANTexpand);\n             }\n         }\n+    }\n \n-        override void visit(AssocArrayLiteralExp e)\n+    void visitAssocArrayLiteral(AssocArrayLiteralExp e)\n+    {\n+        assert(e.keys.dim == e.values.dim);\n+        for (size_t i = 0; i < e.keys.dim; i++)\n         {\n-            assert(e.keys.dim == e.values.dim);\n-            for (size_t i = 0; i < e.keys.dim; i++)\n-            {\n-                expOptimize((*e.keys)[i], result & WANTexpand);\n-                expOptimize((*e.values)[i], result & WANTexpand);\n-            }\n+            expOptimize((*e.keys)[i], result & WANTexpand);\n+            expOptimize((*e.values)[i], result & WANTexpand);\n         }\n+    }\n \n-        override void visit(StructLiteralExp e)\n+    void visitStructLiteral(StructLiteralExp e)\n+    {\n+        if (e.stageflags & stageOptimize)\n+            return;\n+        int old = e.stageflags;\n+        e.stageflags |= stageOptimize;\n+        if (e.elements)\n         {\n-            if (e.stageflags & stageOptimize)\n-                return;\n-            int old = e.stageflags;\n-            e.stageflags |= stageOptimize;\n-            if (e.elements)\n+            for (size_t i = 0; i < e.elements.dim; i++)\n             {\n-                for (size_t i = 0; i < e.elements.dim; i++)\n-                {\n-                    expOptimize((*e.elements)[i], result & WANTexpand);\n-                }\n+                expOptimize((*e.elements)[i], result & WANTexpand);\n             }\n-            e.stageflags = old;\n         }\n+        e.stageflags = old;\n+    }\n \n-        override void visit(UnaExp e)\n-        {\n-            //printf(\"UnaExp::optimize() %s\\n\", e.toChars());\n-            if (unaOptimize(e, result))\n-                return;\n-        }\n+    void visitUna(UnaExp e)\n+    {\n+        //printf(\"UnaExp::optimize() %s\\n\", e.toChars());\n+        if (unaOptimize(e, result))\n+            return;\n+    }\n \n-        override void visit(NegExp e)\n+    void visitNeg(NegExp e)\n+    {\n+        if (unaOptimize(e, result))\n+            return;\n+        if (e.e1.isConst() == 1)\n         {\n-            if (unaOptimize(e, result))\n-                return;\n-            if (e.e1.isConst() == 1)\n-            {\n-                ret = Neg(e.type, e.e1).copy();\n-            }\n+            ret = Neg(e.type, e.e1).copy();\n         }\n+    }\n \n-        override void visit(ComExp e)\n+    void visitCom(ComExp e)\n+    {\n+        if (unaOptimize(e, result))\n+            return;\n+        if (e.e1.isConst() == 1)\n         {\n-            if (unaOptimize(e, result))\n-                return;\n-            if (e.e1.isConst() == 1)\n-            {\n-                ret = Com(e.type, e.e1).copy();\n-            }\n+            ret = Com(e.type, e.e1).copy();\n         }\n+    }\n \n-        override void visit(NotExp e)\n+    void visitNop(NotExp e)\n+    {\n+        if (unaOptimize(e, result))\n+            return;\n+        if (e.e1.isConst() == 1)\n         {\n-            if (unaOptimize(e, result))\n-                return;\n-            if (e.e1.isConst() == 1)\n-            {\n-                ret = Not(e.type, e.e1).copy();\n-            }\n+            ret = Not(e.type, e.e1).copy();\n         }\n+    }\n \n-        override void visit(SymOffExp e)\n+    void visitSymOff(SymOffExp e)\n+    {\n+        assert(e.var);\n+    }\n+\n+    void visitAddr(AddrExp e)\n+    {\n+        //printf(\"AddrExp::optimize(result = %d) %s\\n\", result, e.toChars());\n+        /* Rewrite &(a,b) as (a,&b)\n+         */\n+        if (auto ce = e.e1.isCommaExp())\n         {\n-            assert(e.var);\n+            auto ae = new AddrExp(e.loc, ce.e2, e.type);\n+            ret = new CommaExp(ce.loc, ce.e1, ae);\n+            ret.type = e.type;\n+            return;\n         }\n-\n-        override void visit(AddrExp e)\n+        // Keep lvalue-ness\n+        if (expOptimize(e.e1, result, true))\n+            return;\n+        // Convert &*ex to ex\n+        if (auto pe = e.e1.isPtrExp())\n         {\n-            //printf(\"AddrExp::optimize(result = %d) %s\\n\", result, e.toChars());\n-            /* Rewrite &(a,b) as (a,&b)\n-             */\n-            if (e.e1.op == TOK.comma)\n+            Expression ex = pe.e1;\n+            if (e.type.equals(ex.type))\n+                ret = ex;\n+            else if (e.type.toBasetype().equivalent(ex.type.toBasetype()))\n             {\n-                CommaExp ce = cast(CommaExp)e.e1;\n-                auto ae = new AddrExp(e.loc, ce.e2, e.type);\n-                ret = new CommaExp(ce.loc, ce.e1, ae);\n+                ret = ex.copy();\n                 ret.type = e.type;\n-                return;\n-            }\n-            // Keep lvalue-ness\n-            if (expOptimize(e.e1, result, true))\n-                return;\n-            // Convert &*ex to ex\n-            if (e.e1.op == TOK.star)\n-            {\n-                Expression ex = (cast(PtrExp)e.e1).e1;\n-                if (e.type.equals(ex.type))\n-                    ret = ex;\n-                else if (e.type.toBasetype().equivalent(ex.type.toBasetype()))\n-                {\n-                    ret = ex.copy();\n-                    ret.type = e.type;\n-                }\n-                return;\n-            }\n-            if (e.e1.op == TOK.variable)\n-            {\n-                VarExp ve = cast(VarExp)e.e1;\n-                if (!ve.var.isReference() && !ve.var.isImportedSymbol())\n-                {\n-                    ret = new SymOffExp(e.loc, ve.var, 0, ve.hasOverloads);\n-                    ret.type = e.type;\n-                    return;\n-                }\n-            }\n-            if (e.e1.op == TOK.index)\n-            {\n-                // Convert &array[n] to &array+n\n-                IndexExp ae = cast(IndexExp)e.e1;\n-                if (ae.e2.op == TOK.int64 && ae.e1.op == TOK.variable)\n-                {\n-                    sinteger_t index = ae.e2.toInteger();\n-                    VarExp ve = cast(VarExp)ae.e1;\n-                    if (ve.type.ty == Tsarray && !ve.var.isImportedSymbol())\n-                    {\n-                        TypeSArray ts = cast(TypeSArray)ve.type;\n-                        sinteger_t dim = ts.dim.toInteger();\n-                        if (index < 0 || index >= dim)\n-                        {\n-                            e.error(\"array index %lld is out of bounds `[0..%lld]`\", index, dim);\n-                            return error();\n-                        }\n-\n-                        import core.checkedint : mulu;\n-                        bool overflow;\n-                        const offset = mulu(index, ts.nextOf().size(e.loc), overflow);\n-                        if (overflow)\n-                        {\n-                            e.error(\"array offset overflow\");\n-                            return error();\n-                        }\n-\n-                        ret = new SymOffExp(e.loc, ve.var, offset);\n-                        ret.type = e.type;\n-                        return;\n-                    }\n-                }\n             }\n+            return;\n         }\n-\n-        override void visit(PtrExp e)\n+        if (auto ve = e.e1.isVarExp())\n         {\n-            //printf(\"PtrExp::optimize(result = x%x) %s\\n\", result, e.toChars());\n-            if (expOptimize(e.e1, result))\n-                return;\n-            // Convert *&ex to ex\n-            // But only if there is no type punning involved\n-            if (e.e1.op == TOK.address)\n+            if (!ve.var.isReference() && !ve.var.isImportedSymbol())\n             {\n-                Expression ex = (cast(AddrExp)e.e1).e1;\n-                if (e.type.equals(ex.type))\n-                    ret = ex;\n-                else if (e.type.toBasetype().equivalent(ex.type.toBasetype()))\n-                {\n-                    ret = ex.copy();\n-                    ret.type = e.type;\n-                }\n-            }\n-            if (keepLvalue)\n+                ret = new SymOffExp(e.loc, ve.var, 0, ve.hasOverloads);\n+                ret.type = e.type;\n                 return;\n-            // Constant fold *(&structliteral + offset)\n-            if (e.e1.op == TOK.add)\n-            {\n-                Expression ex = Ptr(e.type, e.e1).copy();\n-                if (!CTFEExp.isCantExp(ex))\n-                {\n-                    ret = ex;\n-                    return;\n-                }\n             }\n-            if (e.e1.op == TOK.symbolOffset)\n+        }\n+        if (auto ae = e.e1.isIndexExp())\n+        {\n+            // Convert &array[n] to &array+n\n+            if (ae.e2.op == EXP.int64 && ae.e1.isVarExp())\n             {\n-                SymOffExp se = cast(SymOffExp)e.e1;\n-                VarDeclaration v = se.var.isVarDeclaration();\n-                Expression ex = expandVar(result, v);\n-                if (ex && ex.op == TOK.structLiteral)\n+                sinteger_t index = ae.e2.toInteger();\n+                VarExp ve = ae.e1.isVarExp();\n+                if (ve.type.isTypeSArray() && !ve.var.isImportedSymbol())\n                 {\n-                    StructLiteralExp sle = cast(StructLiteralExp)ex;\n-                    ex = sle.getField(e.type, cast(uint)se.offset);\n-                    if (ex && !CTFEExp.isCantExp(ex))\n+                    TypeSArray ts = ve.type.isTypeSArray();\n+                    sinteger_t dim = ts.dim.toInteger();\n+                    if (index < 0 || index >= dim)\n                     {\n-                        ret = ex;\n-                        return;\n+                        e.error(\"array index %lld is out of bounds `[0..%lld]`\", index, dim);\n+                        return error();\n                     }\n-                }\n-            }\n-        }\n \n-        override void visit(DotVarExp e)\n-        {\n-            //printf(\"DotVarExp::optimize(result = x%x) %s\\n\", result, e.toChars());\n-            if (expOptimize(e.e1, result))\n-                return;\n-            if (keepLvalue)\n-                return;\n-            Expression ex = e.e1;\n-            if (ex.op == TOK.variable)\n-            {\n-                VarExp ve = cast(VarExp)ex;\n-                VarDeclaration v = ve.var.isVarDeclaration();\n-                ex = expandVar(result, v);\n-            }\n-            if (ex && ex.op == TOK.structLiteral)\n-            {\n-                StructLiteralExp sle = cast(StructLiteralExp)ex;\n-                VarDeclaration vf = e.var.isVarDeclaration();\n-                if (vf && !vf.overlapped)\n-                {\n-                    /* https://issues.dlang.org/show_bug.cgi?id=13021\n-                     * Prevent optimization if vf has overlapped fields.\n-                     */\n-                    ex = sle.getField(e.type, vf.offset);\n-                    if (ex && !CTFEExp.isCantExp(ex))\n+                    import core.checkedint : mulu;\n+                    bool overflow;\n+                    const offset = mulu(index, ts.nextOf().size(e.loc), overflow);\n+                    if (overflow)\n                     {\n-                        ret = ex;\n-                        return;\n+                        e.error(\"array offset overflow\");\n+                        return error();\n                     }\n+\n+                    ret = new SymOffExp(e.loc, ve.var, offset);\n+                    ret.type = e.type;\n+                    return;\n                 }\n             }\n         }\n+    }\n \n-        override void visit(NewExp e)\n+    void visitPtr(PtrExp e)\n+    {\n+        //printf(\"PtrExp::optimize(result = x%x) %s\\n\", result, e.toChars());\n+        if (expOptimize(e.e1, result))\n+            return;\n+        // Convert *&ex to ex\n+        // But only if there is no type punning involved\n+        if (auto ey = e.e1.isAddrExp())\n         {\n-            expOptimize(e.thisexp, WANTvalue);\n-            // Optimize parameters\n-            if (e.newargs)\n+            Expression ex = ey.e1;\n+            if (e.type.equals(ex.type))\n+                ret = ex;\n+            else if (e.type.toBasetype().equivalent(ex.type.toBasetype()))\n             {\n-                for (size_t i = 0; i < e.newargs.dim; i++)\n-                {\n-                    expOptimize((*e.newargs)[i], WANTvalue);\n-                }\n+                ret = ex.copy();\n+                ret.type = e.type;\n             }\n-            if (e.arguments)\n+        }\n+        if (keepLvalue)\n+            return;\n+        // Constant fold *(&structliteral + offset)\n+        if (e.e1.op == EXP.add)\n+        {\n+            Expression ex = Ptr(e.type, e.e1).copy();\n+            if (!CTFEExp.isCantExp(ex))\n             {\n-                for (size_t i = 0; i < e.arguments.dim; i++)\n-                {\n-                    expOptimize((*e.arguments)[i], WANTvalue);\n-                }\n+                ret = ex;\n+                return;\n             }\n         }\n-\n-        override void visit(CallExp e)\n+        if (auto se = e.e1.isSymOffExp())\n         {\n-            //printf(\"CallExp::optimize(result = %d) %s\\n\", result, e.toChars());\n-            // Optimize parameters with keeping lvalue-ness\n-            if (expOptimize(e.e1, result))\n-                return;\n-            if (e.arguments)\n+            VarDeclaration v = se.var.isVarDeclaration();\n+            Expression ex = expandVar(result, v);\n+            if (ex && ex.isStructLiteralExp())\n             {\n-                Type t1 = e.e1.type.toBasetype();\n-                if (t1.ty == Tdelegate)\n-                    t1 = t1.nextOf();\n-                // t1 can apparently be void for __ArrayDtor(T) calls\n-                if (auto tf = t1.isTypeFunction())\n+                StructLiteralExp sle = ex.isStructLiteralExp();\n+                ex = sle.getField(e.type, cast(uint)se.offset);\n+                if (ex && !CTFEExp.isCantExp(ex))\n                 {\n-                    for (size_t i = 0; i < e.arguments.dim; i++)\n-                    {\n-                        Parameter p = tf.parameterList[i];\n-                        bool keep = p && p.isReference();\n-                        expOptimize((*e.arguments)[i], WANTvalue, keep);\n-                    }\n+                    ret = ex;\n+                    return;\n                 }\n             }\n         }\n+    }\n \n-        override void visit(CastExp e)\n+    void visitDotVar(DotVarExp e)\n+    {\n+        //printf(\"DotVarExp::optimize(result = x%x) %s\\n\", result, e.toChars());\n+        if (expOptimize(e.e1, result))\n+            return;\n+        if (keepLvalue)\n+            return;\n+        Expression ex = e.e1;\n+        if (auto ve = ex.isVarExp())\n         {\n-            //printf(\"CastExp::optimize(result = %d) %s\\n\", result, e.toChars());\n-            //printf(\"from %s to %s\\n\", e.type.toChars(), e.to.toChars());\n-            //printf(\"from %s\\n\", e.type.toChars());\n-            //printf(\"e1.type %s\\n\", e.e1.type.toChars());\n-            //printf(\"type = %p\\n\", e.type);\n-            assert(e.type);\n-            TOK op1 = e.e1.op;\n-            Expression e1old = e.e1;\n-            if (expOptimize(e.e1, result, keepLvalue))\n-                return;\n-            if (!keepLvalue)\n-                e.e1 = fromConstInitializer(result, e.e1);\n-            if (e.e1 == e1old && e.e1.op == TOK.arrayLiteral && e.type.toBasetype().ty == Tpointer && e.e1.type.toBasetype().ty != Tsarray)\n-            {\n-                // Casting this will result in the same expression, and\n-                // infinite loop because of Expression::implicitCastTo()\n-                return; // no change\n-            }\n-            if ((e.e1.op == TOK.string_ || e.e1.op == TOK.arrayLiteral) &&\n-                (e.type.ty == Tpointer || e.type.ty == Tarray))\n+            VarDeclaration v = ve.var.isVarDeclaration();\n+            ex = expandVar(result, v);\n+        }\n+        if (ex && ex.isStructLiteralExp())\n+        {\n+            StructLiteralExp sle = ex.isStructLiteralExp();\n+            VarDeclaration vf = e.var.isVarDeclaration();\n+            if (vf && !vf.overlapped)\n             {\n-                const esz  = e.type.nextOf().size(e.loc);\n-                const e1sz = e.e1.type.toBasetype().nextOf().size(e.e1.loc);\n-                if (esz == SIZE_INVALID || e1sz == SIZE_INVALID)\n-                    return error();\n-\n-                if (e1sz == esz)\n+                /* https://issues.dlang.org/show_bug.cgi?id=13021\n+                 * Prevent optimization if vf has overlapped fields.\n+                 */\n+                ex = sle.getField(e.type, vf.offset);\n+                if (ex && !CTFEExp.isCantExp(ex))\n                 {\n-                    // https://issues.dlang.org/show_bug.cgi?id=12937\n-                    // If target type is void array, trying to paint\n-                    // e.e1 with that type will cause infinite recursive optimization.\n-                    if (e.type.nextOf().ty == Tvoid)\n-                        return;\n-                    ret = e.e1.castTo(null, e.type);\n-                    //printf(\" returning1 %s\\n\", ret.toChars());\n+                    ret = ex;\n                     return;\n                 }\n             }\n+        }\n+    }\n \n-            if (e.e1.op == TOK.structLiteral && e.e1.type.implicitConvTo(e.type) >= MATCH.constant)\n-            {\n-                //printf(\" returning2 %s\\n\", e.e1.toChars());\n-            L1:\n-                // Returning e1 with changing its type\n-                ret = (e1old == e.e1 ? e.e1.copy() : e.e1);\n-                ret.type = e.type;\n-                return;\n-            }\n-            /* The first test here is to prevent infinite loops\n-             */\n-            if (op1 != TOK.arrayLiteral && e.e1.op == TOK.arrayLiteral)\n-            {\n-                ret = e.e1.castTo(null, e.to);\n-                return;\n-            }\n-            if (e.e1.op == TOK.null_ && (e.type.ty == Tpointer || e.type.ty == Tclass || e.type.ty == Tarray))\n-            {\n-                //printf(\" returning3 %s\\n\", e.e1.toChars());\n-                goto L1;\n-            }\n-            if (e.type.ty == Tclass && e.e1.type.ty == Tclass)\n-            {\n-                import dmd.astenums : Sizeok;\n-\n-                // See if we can remove an unnecessary cast\n-                ClassDeclaration cdfrom = e.e1.type.isClassHandle();\n-                ClassDeclaration cdto = e.type.isClassHandle();\n-                if (cdfrom.errors || cdto.errors)\n-                    return error();\n-                if (cdto == ClassDeclaration.object && !cdfrom.isInterfaceDeclaration())\n-                    goto L1;    // can always convert a class to Object\n-                // Need to determine correct offset before optimizing away the cast.\n-                // https://issues.dlang.org/show_bug.cgi?id=16980\n-                cdfrom.size(e.loc);\n-                assert(cdfrom.sizeok == Sizeok.done);\n-                assert(cdto.sizeok == Sizeok.done || !cdto.isBaseOf(cdfrom, null));\n-                int offset;\n-                if (cdto.isBaseOf(cdfrom, &offset) && offset == 0)\n-                {\n-                    //printf(\" returning4 %s\\n\", e.e1.toChars());\n-                    goto L1;\n-                }\n-            }\n-            if (e.e1.type.mutableOf().unSharedOf().equals(e.to.mutableOf().unSharedOf()))\n+    void visitNew(NewExp e)\n+    {\n+        expOptimize(e.thisexp, WANTvalue);\n+        // Optimize parameters\n+        if (e.newargs)\n+        {\n+            for (size_t i = 0; i < e.newargs.dim; i++)\n             {\n-                //printf(\" returning5 %s\\n\", e.e1.toChars());\n-                goto L1;\n+                expOptimize((*e.newargs)[i], WANTvalue);\n             }\n-            if (e.e1.isConst())\n+        }\n+        if (e.arguments)\n+        {\n+            for (size_t i = 0; i < e.arguments.dim; i++)\n             {\n-                if (e.e1.op == TOK.symbolOffset)\n-                {\n-                    if (e.type.toBasetype().ty != Tsarray)\n-                    {\n-                        const esz = e.type.size(e.loc);\n-                        const e1sz = e.e1.type.size(e.e1.loc);\n-                        if (esz == SIZE_INVALID ||\n-                            e1sz == SIZE_INVALID)\n-                            return error();\n-\n-                        if (esz == e1sz)\n-                            goto L1;\n-                    }\n-                    return;\n-                }\n-                if (e.to.toBasetype().ty != Tvoid)\n-                {\n-                    if (e.e1.type.equals(e.type) && e.type.equals(e.to))\n-                        ret = e.e1;\n-                    else\n-                        ret = Cast(e.loc, e.type, e.to, e.e1).copy();\n-                }\n+                expOptimize((*e.arguments)[i], WANTvalue);\n             }\n-            //printf(\" returning6 %s\\n\", ret.toChars());\n         }\n+    }\n \n-        override void visit(BinAssignExp e)\n+    void visitCall(CallExp e)\n+    {\n+        //printf(\"CallExp::optimize(result = %d) %s\\n\", result, e.toChars());\n+        // Optimize parameters with keeping lvalue-ness\n+        if (expOptimize(e.e1, result))\n+            return;\n+        if (e.arguments)\n         {\n-            //printf(\"BinAssignExp::optimize(result = %d) %s\\n\", result, e.toChars());\n-            if (binOptimize(e, result, /*keepLhsLvalue*/ true))\n-                return;\n-            if (e.op == TOK.leftShiftAssign || e.op == TOK.rightShiftAssign || e.op == TOK.unsignedRightShiftAssign)\n+            Type t1 = e.e1.type.toBasetype();\n+            if (t1.ty == Tdelegate)\n+                t1 = t1.nextOf();\n+            // t1 can apparently be void for __ArrayDtor(T) calls\n+            if (auto tf = t1.isTypeFunction())\n             {\n-                if (e.e2.isConst() == 1)\n+                for (size_t i = 0; i < e.arguments.dim; i++)\n                 {\n-                    sinteger_t i2 = e.e2.toInteger();\n-                    d_uns64 sz = e.e1.type.size(e.e1.loc);\n-                    assert(sz != SIZE_INVALID);\n-                    sz *= 8;\n-                    if (i2 < 0 || i2 >= sz)\n-                    {\n-                        e.error(\"shift assign by %lld is outside the range `0..%llu`\", i2, cast(ulong)sz - 1);\n-                        return error();\n-                    }\n+                    Parameter p = tf.parameterList[i];\n+                    bool keep = p && p.isReference();\n+                    expOptimize((*e.arguments)[i], WANTvalue, keep);\n                 }\n             }\n         }\n+    }\n \n-        override void visit(BinExp e)\n+    void visitCast(CastExp e)\n+    {\n+        //printf(\"CastExp::optimize(result = %d) %s\\n\", result, e.toChars());\n+        //printf(\"from %s to %s\\n\", e.type.toChars(), e.to.toChars());\n+        //printf(\"from %s\\n\", e.type.toChars());\n+        //printf(\"e1.type %s\\n\", e.e1.type.toChars());\n+        //printf(\"type = %p\\n\", e.type);\n+        assert(e.type);\n+        const op1 = e.e1.op;\n+        Expression e1old = e.e1;\n+        if (expOptimize(e.e1, result, keepLvalue))\n+            return;\n+        if (!keepLvalue)\n+            e.e1 = fromConstInitializer(result, e.e1);\n+        if (e.e1 == e1old && e.e1.op == EXP.arrayLiteral && e.type.toBasetype().ty == Tpointer && e.e1.type.toBasetype().ty != Tsarray)\n         {\n-            //printf(\"BinExp::optimize(result = %d) %s\\n\", result, e.toChars());\n-            const keepLhsLvalue = e.op == TOK.construct || e.op == TOK.blit || e.op == TOK.assign\n-                || e.op == TOK.plusPlus || e.op == TOK.minusMinus\n-                || e.op == TOK.prePlusPlus || e.op == TOK.preMinusMinus;\n-            binOptimize(e, result, keepLhsLvalue);\n+            // Casting this will result in the same expression, and\n+            // infinite loop because of Expression::implicitCastTo()\n+            return; // no change\n         }\n-\n-        override void visit(AddExp e)\n+        if ((e.e1.op == EXP.string_ || e.e1.op == EXP.arrayLiteral) &&\n+            (e.type.ty == Tpointer || e.type.ty == Tarray))\n         {\n-            //printf(\"AddExp::optimize(%s)\\n\", e.toChars());\n-            if (binOptimize(e, result))\n-                return;\n-            if (e.e1.isConst() && e.e2.isConst())\n+            const esz  = e.type.nextOf().size(e.loc);\n+            const e1sz = e.e1.type.toBasetype().nextOf().size(e.e1.loc);\n+            if (esz == SIZE_INVALID || e1sz == SIZE_INVALID)\n+                return error();\n+\n+            if (e1sz == esz)\n             {\n-                if (e.e1.op == TOK.symbolOffset && e.e2.op == TOK.symbolOffset)\n+                // https://issues.dlang.org/show_bug.cgi?id=12937\n+                // If target type is void array, trying to paint\n+                // e.e1 with that type will cause infinite recursive optimization.\n+                if (e.type.nextOf().ty == Tvoid)\n                     return;\n-                ret = Add(e.loc, e.type, e.e1, e.e2).copy();\n+                ret = e.e1.castTo(null, e.type);\n+                //printf(\" returning1 %s\\n\", ret.toChars());\n+                return;\n             }\n         }\n \n-        override void visit(MinExp e)\n+        if (e.e1.op == EXP.structLiteral && e.e1.type.implicitConvTo(e.type) >= MATCH.constant)\n         {\n-            if (binOptimize(e, result))\n-                return;\n-            if (e.e1.isConst() && e.e2.isConst())\n-            {\n-                if (e.e2.op == TOK.symbolOffset)\n-                    return;\n-                ret = Min(e.loc, e.type, e.e1, e.e2).copy();\n-            }\n+            //printf(\" returning2 %s\\n\", e.e1.toChars());\n+        L1:\n+            // Returning e1 with changing its type\n+            ret = (e1old == e.e1 ? e.e1.copy() : e.e1);\n+            ret.type = e.type;\n+            return;\n         }\n-\n-        override void visit(MulExp e)\n+        /* The first test here is to prevent infinite loops\n+         */\n+        if (op1 != EXP.arrayLiteral && e.e1.op == EXP.arrayLiteral)\n         {\n-            //printf(\"MulExp::optimize(result = %d) %s\\n\", result, e.toChars());\n-            if (binOptimize(e, result))\n-                return;\n-            if (e.e1.isConst() == 1 && e.e2.isConst() == 1)\n-            {\n-                ret = Mul(e.loc, e.type, e.e1, e.e2).copy();\n-            }\n+            ret = e.e1.castTo(null, e.to);\n+            return;\n         }\n-\n-        override void visit(DivExp e)\n+        if (e.e1.op == EXP.null_ && (e.type.ty == Tpointer || e.type.ty == Tclass || e.type.ty == Tarray))\n         {\n-            //printf(\"DivExp::optimize(%s)\\n\", e.toChars());\n-            if (binOptimize(e, result))\n-                return;\n-            if (e.e1.isConst() == 1 && e.e2.isConst() == 1)\n+            //printf(\" returning3 %s\\n\", e.e1.toChars());\n+            goto L1;\n+        }\n+        if (e.type.ty == Tclass && e.e1.type.ty == Tclass)\n+        {\n+            import dmd.astenums : Sizeok;\n+\n+            // See if we can remove an unnecessary cast\n+            ClassDeclaration cdfrom = e.e1.type.isClassHandle();\n+            ClassDeclaration cdto = e.type.isClassHandle();\n+            if (cdfrom.errors || cdto.errors)\n+                return error();\n+            if (cdto == ClassDeclaration.object && !cdfrom.isInterfaceDeclaration())\n+                goto L1;    // can always convert a class to Object\n+            // Need to determine correct offset before optimizing away the cast.\n+            // https://issues.dlang.org/show_bug.cgi?id=16980\n+            cdfrom.size(e.loc);\n+            assert(cdfrom.sizeok == Sizeok.done);\n+            assert(cdto.sizeok == Sizeok.done || !cdto.isBaseOf(cdfrom, null));\n+            int offset;\n+            if (cdto.isBaseOf(cdfrom, &offset) && offset == 0)\n             {\n-                ret = Div(e.loc, e.type, e.e1, e.e2).copy();\n+                //printf(\" returning4 %s\\n\", e.e1.toChars());\n+                goto L1;\n             }\n         }\n-\n-        override void visit(ModExp e)\n+        if (e.e1.type.mutableOf().unSharedOf().equals(e.to.mutableOf().unSharedOf()))\n         {\n-            if (binOptimize(e, result))\n+            //printf(\" returning5 %s\\n\", e.e1.toChars());\n+            goto L1;\n+        }\n+        if (e.e1.isConst())\n+        {\n+            if (e.e1.op == EXP.symbolOffset)\n+            {\n+                if (e.type.toBasetype().ty != Tsarray)\n+                {\n+                    const esz = e.type.size(e.loc);\n+                    const e1sz = e.e1.type.size(e.e1.loc);\n+                    if (esz == SIZE_INVALID ||\n+                        e1sz == SIZE_INVALID)\n+                        return error();\n+\n+                    if (esz == e1sz)\n+                        goto L1;\n+                }\n                 return;\n-            if (e.e1.isConst() == 1 && e.e2.isConst() == 1)\n+            }\n+            if (e.to.toBasetype().ty != Tvoid)\n             {\n-                ret = Mod(e.loc, e.type, e.e1, e.e2).copy();\n+                if (e.e1.type.equals(e.type) && e.type.equals(e.to))\n+                    ret = e.e1;\n+                else\n+                    ret = Cast(e.loc, e.type, e.to, e.e1).copy();\n             }\n         }\n+        //printf(\" returning6 %s\\n\", ret.toChars());\n+    }\n \n-        extern (D) void shift_optimize(BinExp e, UnionExp function(const ref Loc, Type, Expression, Expression) shift)\n+    void visitBinAssign(BinAssignExp e)\n+    {\n+        //printf(\"BinAssignExp::optimize(result = %d) %s\\n\", result, e.toChars());\n+        if (binOptimize(e, result, /*keepLhsLvalue*/ true))\n+            return;\n+        if (e.op == EXP.leftShiftAssign || e.op == EXP.rightShiftAssign || e.op == EXP.unsignedRightShiftAssign)\n         {\n-            if (binOptimize(e, result))\n-                return;\n             if (e.e2.isConst() == 1)\n             {\n                 sinteger_t i2 = e.e2.toInteger();\n@@ -846,329 +749,410 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n                 sz *= 8;\n                 if (i2 < 0 || i2 >= sz)\n                 {\n-                    e.error(\"shift by %lld is outside the range `0..%llu`\", i2, cast(ulong)sz - 1);\n+                    e.error(\"shift assign by %lld is outside the range `0..%llu`\", i2, cast(ulong)sz - 1);\n                     return error();\n                 }\n-                if (e.e1.isConst() == 1)\n-                    ret = (*shift)(e.loc, e.type, e.e1, e.e2).copy();\n             }\n         }\n+    }\n \n-        override void visit(ShlExp e)\n-        {\n-            //printf(\"ShlExp::optimize(result = %d) %s\\n\", result, e.toChars());\n-            shift_optimize(e, &Shl);\n-        }\n+    void visitBin(BinExp e)\n+    {\n+        //printf(\"BinExp::optimize(result = %d) %s\\n\", result, e.toChars());\n+        const keepLhsLvalue = e.op == EXP.construct || e.op == EXP.blit || e.op == EXP.assign\n+            || e.op == EXP.plusPlus || e.op == EXP.minusMinus\n+            || e.op == EXP.prePlusPlus || e.op == EXP.preMinusMinus;\n+        binOptimize(e, result, keepLhsLvalue);\n+    }\n \n-        override void visit(ShrExp e)\n+    void visitAdd(AddExp e)\n+    {\n+        //printf(\"AddExp::optimize(%s)\\n\", e.toChars());\n+        if (binOptimize(e, result))\n+            return;\n+        if (e.e1.isConst() && e.e2.isConst())\n         {\n-            //printf(\"ShrExp::optimize(result = %d) %s\\n\", result, e.toChars());\n-            shift_optimize(e, &Shr);\n+            if (e.e1.op == EXP.symbolOffset && e.e2.op == EXP.symbolOffset)\n+                return;\n+            ret = Add(e.loc, e.type, e.e1, e.e2).copy();\n         }\n+    }\n \n-        override void visit(UshrExp e)\n+    void visitMin(MinExp e)\n+    {\n+        if (binOptimize(e, result))\n+            return;\n+        if (e.e1.isConst() && e.e2.isConst())\n         {\n-            //printf(\"UshrExp::optimize(result = %d) %s\\n\", result, toChars());\n-            shift_optimize(e, &Ushr);\n+            if (e.e2.op == EXP.symbolOffset)\n+                return;\n+            ret = Min(e.loc, e.type, e.e1, e.e2).copy();\n         }\n+    }\n \n-        override void visit(AndExp e)\n+    void visitMul(MulExp e)\n+    {\n+        //printf(\"MulExp::optimize(result = %d) %s\\n\", result, e.toChars());\n+        if (binOptimize(e, result))\n+            return;\n+        if (e.e1.isConst() == 1 && e.e2.isConst() == 1)\n         {\n-            if (binOptimize(e, result))\n-                return;\n-            if (e.e1.isConst() == 1 && e.e2.isConst() == 1)\n-                ret = And(e.loc, e.type, e.e1, e.e2).copy();\n+            ret = Mul(e.loc, e.type, e.e1, e.e2).copy();\n         }\n+    }\n \n-        override void visit(OrExp e)\n+    void visitDiv(DivExp e)\n+    {\n+        //printf(\"DivExp::optimize(%s)\\n\", e.toChars());\n+        if (binOptimize(e, result))\n+            return;\n+        if (e.e1.isConst() == 1 && e.e2.isConst() == 1)\n         {\n-            if (binOptimize(e, result))\n-                return;\n-            if (e.e1.isConst() == 1 && e.e2.isConst() == 1)\n-                ret = Or(e.loc, e.type, e.e1, e.e2).copy();\n+            ret = Div(e.loc, e.type, e.e1, e.e2).copy();\n         }\n+    }\n \n-        override void visit(XorExp e)\n+    void visitMod(ModExp e)\n+    {\n+        if (binOptimize(e, result))\n+            return;\n+        if (e.e1.isConst() == 1 && e.e2.isConst() == 1)\n         {\n-            if (binOptimize(e, result))\n-                return;\n-            if (e.e1.isConst() == 1 && e.e2.isConst() == 1)\n-                ret = Xor(e.loc, e.type, e.e1, e.e2).copy();\n+            ret = Mod(e.loc, e.type, e.e1, e.e2).copy();\n         }\n+    }\n \n-        override void visit(PowExp e)\n+    extern (D) void shift_optimize(BinExp e, UnionExp function(const ref Loc, Type, Expression, Expression) shift)\n+    {\n+        if (binOptimize(e, result))\n+            return;\n+        if (e.e2.isConst() == 1)\n         {\n-            if (binOptimize(e, result))\n-                return;\n-            // All negative integral powers are illegal.\n-            if (e.e1.type.isintegral() && (e.e2.op == TOK.int64) && cast(sinteger_t)e.e2.toInteger() < 0)\n+            sinteger_t i2 = e.e2.toInteger();\n+            d_uns64 sz = e.e1.type.size(e.e1.loc);\n+            assert(sz != SIZE_INVALID);\n+            sz *= 8;\n+            if (i2 < 0 || i2 >= sz)\n             {\n-                e.error(\"cannot raise `%s` to a negative integer power. Did you mean `(cast(real)%s)^^%s` ?\", e.e1.type.toBasetype().toChars(), e.e1.toChars(), e.e2.toChars());\n+                e.error(\"shift by %lld is outside the range `0..%llu`\", i2, cast(ulong)sz - 1);\n                 return error();\n             }\n-            // If e2 *could* have been an integer, make it one.\n-            if (e.e2.op == TOK.float64 && e.e2.toReal() == real_t(cast(sinteger_t)e.e2.toReal()))\n-            {\n-                // This only applies to floating point, or positive integral powers.\n-                if (e.e1.type.isfloating() || cast(sinteger_t)e.e2.toInteger() >= 0)\n-                    e.e2 = new IntegerExp(e.loc, e.e2.toInteger(), Type.tint64);\n-            }\n-            if (e.e1.isConst() == 1 && e.e2.isConst() == 1)\n-            {\n-                Expression ex = Pow(e.loc, e.type, e.e1, e.e2).copy();\n-                if (!CTFEExp.isCantExp(ex))\n-                {\n-                    ret = ex;\n-                    return;\n-                }\n-            }\n+            if (e.e1.isConst() == 1)\n+                ret = (*shift)(e.loc, e.type, e.e1, e.e2).copy();\n         }\n+    }\n+\n+    void visitShl(ShlExp e)\n+    {\n+        //printf(\"ShlExp::optimize(result = %d) %s\\n\", result, e.toChars());\n+        shift_optimize(e, &Shl);\n+    }\n+\n+    void visitShr(ShrExp e)\n+    {\n+        //printf(\"ShrExp::optimize(result = %d) %s\\n\", result, e.toChars());\n+        shift_optimize(e, &Shr);\n+    }\n+\n+    void visitUshr(UshrExp e)\n+    {\n+        //printf(\"UshrExp::optimize(result = %d) %s\\n\", result, toChars());\n+        shift_optimize(e, &Ushr);\n+    }\n \n-        override void visit(CommaExp e)\n+    void visitAnd(AndExp e)\n+    {\n+        if (binOptimize(e, result))\n+            return;\n+        if (e.e1.isConst() == 1 && e.e2.isConst() == 1)\n+            ret = And(e.loc, e.type, e.e1, e.e2).copy();\n+    }\n+\n+    void visitOr(OrExp e)\n+    {\n+        if (binOptimize(e, result))\n+            return;\n+        if (e.e1.isConst() == 1 && e.e2.isConst() == 1)\n+            ret = Or(e.loc, e.type, e.e1, e.e2).copy();\n+    }\n+\n+    void visitXor(XorExp e)\n+    {\n+        if (binOptimize(e, result))\n+            return;\n+        if (e.e1.isConst() == 1 && e.e2.isConst() == 1)\n+            ret = Xor(e.loc, e.type, e.e1, e.e2).copy();\n+    }\n+\n+    void visitPow(PowExp e)\n+    {\n+        if (binOptimize(e, result))\n+            return;\n+        // All negative integral powers are illegal.\n+        if (e.e1.type.isintegral() && (e.e2.op == EXP.int64) && cast(sinteger_t)e.e2.toInteger() < 0)\n         {\n-            //printf(\"CommaExp::optimize(result = %d) %s\\n\", result, e.toChars());\n-            // Comma needs special treatment, because it may\n-            // contain compiler-generated declarations. We can interpret them, but\n-            // otherwise we must NOT attempt to constant-fold them.\n-            // In particular, if the comma returns a temporary variable, it needs\n-            // to be an lvalue (this is particularly important for struct constructors)\n-            expOptimize(e.e1, WANTvalue);\n-            expOptimize(e.e2, result, keepLvalue);\n-            if (ret.op == TOK.error)\n-                return;\n-            if (!e.e1 || e.e1.op == TOK.int64 || e.e1.op == TOK.float64 || !hasSideEffect(e.e1))\n-            {\n-                ret = e.e2;\n-                if (ret)\n-                    ret.type = e.type;\n-            }\n-            //printf(\"-CommaExp::optimize(result = %d) %s\\n\", result, e.e.toChars());\n+            e.error(\"cannot raise `%s` to a negative integer power. Did you mean `(cast(real)%s)^^%s` ?\", e.e1.type.toBasetype().toChars(), e.e1.toChars(), e.e2.toChars());\n+            return error();\n         }\n-\n-        override void visit(ArrayLengthExp e)\n+        // If e2 *could* have been an integer, make it one.\n+        if (e.e2.op == EXP.float64 && e.e2.toReal() == real_t(cast(sinteger_t)e.e2.toReal()))\n         {\n-            //printf(\"ArrayLengthExp::optimize(result = %d) %s\\n\", result, e.toChars());\n-            if (unaOptimize(e, WANTexpand))\n-                return;\n-            // CTFE interpret static immutable arrays (to get better diagnostics)\n-            if (e.e1.op == TOK.variable)\n-            {\n-                VarDeclaration v = (cast(VarExp)e.e1).var.isVarDeclaration();\n-                if (v && (v.storage_class & STC.static_) && (v.storage_class & STC.immutable_) && v._init)\n-                {\n-                    if (Expression ci = v.getConstInitializer())\n-                        e.e1 = ci;\n-                }\n-            }\n-            if (e.e1.op == TOK.string_ || e.e1.op == TOK.arrayLiteral || e.e1.op == TOK.assocArrayLiteral || e.e1.type.toBasetype().ty == Tsarray)\n-            {\n-                ret = ArrayLength(e.type, e.e1).copy();\n-            }\n+            // This only applies to floating point, or positive integral powers.\n+            if (e.e1.type.isfloating() || cast(sinteger_t)e.e2.toInteger() >= 0)\n+                e.e2 = new IntegerExp(e.loc, e.e2.toInteger(), Type.tint64);\n         }\n-\n-        override void visit(EqualExp e)\n+        if (e.e1.isConst() == 1 && e.e2.isConst() == 1)\n         {\n-            //printf(\"EqualExp::optimize(result = %x) %s\\n\", result, e.toChars());\n-            if (binOptimize(e, WANTvalue))\n-                return;\n-            Expression e1 = fromConstInitializer(result, e.e1);\n-            Expression e2 = fromConstInitializer(result, e.e2);\n-            if (e1.op == TOK.error)\n+            Expression ex = Pow(e.loc, e.type, e.e1, e.e2).copy();\n+            if (!CTFEExp.isCantExp(ex))\n             {\n-                ret = e1;\n+                ret = ex;\n                 return;\n             }\n-            if (e2.op == TOK.error)\n-            {\n-                ret = e2;\n-                return;\n-            }\n-            ret = Equal(e.op, e.loc, e.type, e1, e2).copy();\n-            if (CTFEExp.isCantExp(ret))\n-                ret = e;\n         }\n+    }\n \n-        override void visit(IdentityExp e)\n+    void visitComma(CommaExp e)\n+    {\n+        //printf(\"CommaExp::optimize(result = %d) %s\\n\", result, e.toChars());\n+        // Comma needs special treatment, because it may\n+        // contain compiler-generated declarations. We can interpret them, but\n+        // otherwise we must NOT attempt to constant-fold them.\n+        // In particular, if the comma returns a temporary variable, it needs\n+        // to be an lvalue (this is particularly important for struct constructors)\n+        expOptimize(e.e1, WANTvalue);\n+        expOptimize(e.e2, result, keepLvalue);\n+        if (ret.op == EXP.error)\n+            return;\n+        if (!e.e1 || e.e1.op == EXP.int64 || e.e1.op == EXP.float64 || !hasSideEffect(e.e1))\n         {\n-            //printf(\"IdentityExp::optimize(result = %d) %s\\n\", result, e.toChars());\n-            if (binOptimize(e, WANTvalue))\n-                return;\n-            if ((e.e1.isConst() && e.e2.isConst()) || (e.e1.op == TOK.null_ && e.e2.op == TOK.null_))\n+            ret = e.e2;\n+            if (ret)\n+                ret.type = e.type;\n+        }\n+        //printf(\"-CommaExp::optimize(result = %d) %s\\n\", result, e.e.toChars());\n+    }\n+\n+    void visitArrayLength(ArrayLengthExp e)\n+    {\n+        //printf(\"ArrayLengthExp::optimize(result = %d) %s\\n\", result, e.toChars());\n+        if (unaOptimize(e, WANTexpand))\n+            return;\n+        // CTFE interpret static immutable arrays (to get better diagnostics)\n+        if (auto ve = e.e1.isVarExp())\n+        {\n+            VarDeclaration v = ve.var.isVarDeclaration();\n+            if (v && (v.storage_class & STC.static_) && (v.storage_class & STC.immutable_) && v._init)\n             {\n-                ret = Identity(e.op, e.loc, e.type, e.e1, e.e2).copy();\n-                if (CTFEExp.isCantExp(ret))\n-                    ret = e;\n+                if (Expression ci = v.getConstInitializer())\n+                    e.e1 = ci;\n             }\n         }\n+        if (e.e1.op == EXP.string_ || e.e1.op == EXP.arrayLiteral || e.e1.op == EXP.assocArrayLiteral || e.e1.type.toBasetype().ty == Tsarray)\n+        {\n+            ret = ArrayLength(e.type, e.e1).copy();\n+        }\n+    }\n \n-        override void visit(IndexExp e)\n+    void visitEqual(EqualExp e)\n+    {\n+        //printf(\"EqualExp::optimize(result = %x) %s\\n\", result, e.toChars());\n+        if (binOptimize(e, WANTvalue))\n+            return;\n+        Expression e1 = fromConstInitializer(result, e.e1);\n+        Expression e2 = fromConstInitializer(result, e.e2);\n+        if (e1.op == EXP.error)\n         {\n-            //printf(\"IndexExp::optimize(result = %d) %s\\n\", result, e.toChars());\n-            if (expOptimize(e.e1, result & WANTexpand))\n-                return;\n-            Expression ex = fromConstInitializer(result, e.e1);\n-            // We might know $ now\n-            setLengthVarIfKnown(e.lengthVar, ex);\n-            if (expOptimize(e.e2, WANTvalue))\n-                return;\n-            // Don't optimize to an array literal element directly in case an lvalue is requested\n-            if (keepLvalue && ex.op == TOK.arrayLiteral)\n-                return;\n-            ret = Index(e.type, ex, e.e2).copy();\n-            if (CTFEExp.isCantExp(ret) || (!ret.isErrorExp() && keepLvalue && !ret.isLvalue()))\n-                ret = e;\n+            ret = e1;\n+            return;\n+        }\n+        if (e2.op == EXP.error)\n+        {\n+            ret = e2;\n+            return;\n         }\n+        ret = Equal(e.op, e.loc, e.type, e1, e2).copy();\n+        if (CTFEExp.isCantExp(ret))\n+            ret = e;\n+    }\n \n-        override void visit(SliceExp e)\n+    void visitIdentity(IdentityExp e)\n+    {\n+        //printf(\"IdentityExp::optimize(result = %d) %s\\n\", result, e.toChars());\n+        if (binOptimize(e, WANTvalue))\n+            return;\n+        if ((e.e1.isConst() && e.e2.isConst()) || (e.e1.op == EXP.null_ && e.e2.op == EXP.null_))\n         {\n-            //printf(\"SliceExp::optimize(result = %d) %s\\n\", result, e.toChars());\n-            if (expOptimize(e.e1, result & WANTexpand))\n-                return;\n-            if (!e.lwr)\n-            {\n-                if (e.e1.op == TOK.string_)\n-                {\n-                    // Convert slice of string literal into dynamic array\n-                    Type t = e.e1.type.toBasetype();\n-                    if (Type tn = t.nextOf())\n-                        ret = e.e1.castTo(null, tn.arrayOf());\n-                }\n-            }\n-            else\n-            {\n-                e.e1 = fromConstInitializer(result, e.e1);\n-                // We might know $ now\n-                setLengthVarIfKnown(e.lengthVar, e.e1);\n-                expOptimize(e.lwr, WANTvalue);\n-                expOptimize(e.upr, WANTvalue);\n-                if (ret.op == TOK.error)\n-                    return;\n-                ret = Slice(e.type, e.e1, e.lwr, e.upr).copy();\n-                if (CTFEExp.isCantExp(ret))\n-                    ret = e;\n-            }\n-            // https://issues.dlang.org/show_bug.cgi?id=14649\n-            // Leave the slice form so it might be\n-            // a part of array operation.\n-            // Assume that the backend codegen will handle the form `e[]`\n-            // as an equal to `e` itself.\n-            if (ret.op == TOK.string_)\n-            {\n-                e.e1 = ret;\n-                e.lwr = null;\n-                e.upr = null;\n+            ret = Identity(e.op, e.loc, e.type, e.e1, e.e2).copy();\n+            if (CTFEExp.isCantExp(ret))\n                 ret = e;\n-            }\n-            //printf(\"-SliceExp::optimize() %s\\n\", ret.toChars());\n         }\n+    }\n+\n+    void visitIndex(IndexExp e)\n+    {\n+        //printf(\"IndexExp::optimize(result = %d) %s\\n\", result, e.toChars());\n+        if (expOptimize(e.e1, result & WANTexpand))\n+            return;\n+        Expression ex = fromConstInitializer(result, e.e1);\n+        // We might know $ now\n+        setLengthVarIfKnown(e.lengthVar, ex);\n+        if (expOptimize(e.e2, WANTvalue))\n+            return;\n+        // Don't optimize to an array literal element directly in case an lvalue is requested\n+        if (keepLvalue && ex.op == EXP.arrayLiteral)\n+            return;\n+        ret = Index(e.type, ex, e.e2).copy();\n+        if (CTFEExp.isCantExp(ret) || (!ret.isErrorExp() && keepLvalue && !ret.isLvalue()))\n+            ret = e;\n+    }\n \n-        override void visit(LogicalExp e)\n+    void visitSlice(SliceExp e)\n+    {\n+        //printf(\"SliceExp::optimize(result = %d) %s\\n\", result, e.toChars());\n+        if (expOptimize(e.e1, result & WANTexpand))\n+            return;\n+        if (!e.lwr)\n         {\n-            //printf(\"LogicalExp::optimize(%d) %s\\n\", result, e.toChars());\n-            if (expOptimize(e.e1, WANTvalue))\n-                return;\n-            const oror = e.op == TOK.orOr;\n-            if (e.e1.isBool(oror))\n-            {\n-                // Replace with (e1, oror)\n-                ret = IntegerExp.createBool(oror);\n-                ret = Expression.combine(e.e1, ret);\n-                if (e.type.toBasetype().ty == Tvoid)\n-                {\n-                    ret = new CastExp(e.loc, ret, Type.tvoid);\n-                    ret.type = e.type;\n-                }\n-                ret = Expression_optimize(ret, result, false);\n-                return;\n-            }\n-            expOptimize(e.e2, WANTvalue);\n-            if (e.e1.isConst())\n+            if (e.e1.op == EXP.string_)\n             {\n-                if (e.e2.isConst())\n-                {\n-                    bool n1 = e.e1.isBool(true);\n-                    bool n2 = e.e2.isBool(true);\n-                    ret = new IntegerExp(e.loc, oror ? (n1 || n2) : (n1 && n2), e.type);\n-                }\n-                else if (e.e1.isBool(!oror))\n-                {\n-                    if (e.type.toBasetype().ty == Tvoid)\n-                        ret = e.e2;\n-                    else\n-                    {\n-                        ret = new CastExp(e.loc, e.e2, e.type);\n-                        ret.type = e.type;\n-                    }\n-                }\n+                // Convert slice of string literal into dynamic array\n+                Type t = e.e1.type.toBasetype();\n+                if (Type tn = t.nextOf())\n+                    ret = e.e1.castTo(null, tn.arrayOf());\n             }\n         }\n-\n-        override void visit(CmpExp e)\n+        else\n         {\n-            //printf(\"CmpExp::optimize() %s\\n\", e.toChars());\n-            if (binOptimize(e, WANTvalue))\n+            e.e1 = fromConstInitializer(result, e.e1);\n+            // We might know $ now\n+            setLengthVarIfKnown(e.lengthVar, e.e1);\n+            expOptimize(e.lwr, WANTvalue);\n+            expOptimize(e.upr, WANTvalue);\n+            if (ret.op == EXP.error)\n                 return;\n-            Expression e1 = fromConstInitializer(result, e.e1);\n-            Expression e2 = fromConstInitializer(result, e.e2);\n-            ret = Cmp(e.op, e.loc, e.type, e1, e2).copy();\n+            ret = Slice(e.type, e.e1, e.lwr, e.upr).copy();\n             if (CTFEExp.isCantExp(ret))\n                 ret = e;\n         }\n+        // https://issues.dlang.org/show_bug.cgi?id=14649\n+        // Leave the slice form so it might be\n+        // a part of array operation.\n+        // Assume that the backend codegen will handle the form `e[]`\n+        // as an equal to `e` itself.\n+        if (ret.op == EXP.string_)\n+        {\n+            e.e1 = ret;\n+            e.lwr = null;\n+            e.upr = null;\n+            ret = e;\n+        }\n+        //printf(\"-SliceExp::optimize() %s\\n\", ret.toChars());\n+    }\n \n-        override void visit(CatExp e)\n+    void visitLogical(LogicalExp e)\n+    {\n+        //printf(\"LogicalExp::optimize(%d) %s\\n\", result, e.toChars());\n+        if (expOptimize(e.e1, WANTvalue))\n+            return;\n+        const oror = e.op == EXP.orOr;\n+        if (e.e1.toBool().hasValue(oror))\n         {\n-            //printf(\"CatExp::optimize(%d) %s\\n\", result, e.toChars());\n-            if (binOptimize(e, result))\n-                return;\n-            if (e.e1.op == TOK.concatenate)\n+            // Replace with (e1, oror)\n+            ret = IntegerExp.createBool(oror);\n+            ret = Expression.combine(e.e1, ret);\n+            if (e.type.toBasetype().ty == Tvoid)\n             {\n-                // https://issues.dlang.org/show_bug.cgi?id=12798\n-                // optimize ((expr ~ str1) ~ str2)\n-                CatExp ce1 = cast(CatExp)e.e1;\n-                scope CatExp cex = new CatExp(e.loc, ce1.e2, e.e2);\n-                cex.type = e.type;\n-                Expression ex = Expression_optimize(cex, result, false);\n-                if (ex != cex)\n-                {\n-                    e.e1 = ce1.e1;\n-                    e.e2 = ex;\n-                }\n+                ret = new CastExp(e.loc, ret, Type.tvoid);\n+                ret.type = e.type;\n             }\n-            // optimize \"str\"[] -> \"str\"\n-            if (e.e1.op == TOK.slice)\n+            ret = Expression_optimize(ret, result, false);\n+            return;\n+        }\n+        expOptimize(e.e2, WANTvalue);\n+        if (e.e1.isConst())\n+        {\n+            const e1Opt = e.e1.toBool();\n+            if (e.e2.isConst())\n             {\n-                SliceExp se1 = cast(SliceExp)e.e1;\n-                if (se1.e1.op == TOK.string_ && !se1.lwr)\n-                    e.e1 = se1.e1;\n+                bool n1 = e1Opt.hasValue(true);\n+                bool n2 = e.e2.toBool().hasValue(true);\n+                ret = new IntegerExp(e.loc, oror ? (n1 || n2) : (n1 && n2), e.type);\n             }\n-            if (e.e2.op == TOK.slice)\n+            else if (e1Opt.hasValue(!oror))\n             {\n-                SliceExp se2 = cast(SliceExp)e.e2;\n-                if (se2.e1.op == TOK.string_ && !se2.lwr)\n-                    e.e2 = se2.e1;\n+                if (e.type.toBasetype().ty == Tvoid)\n+                    ret = e.e2;\n+                else\n+                {\n+                    ret = new CastExp(e.loc, e.e2, e.type);\n+                    ret.type = e.type;\n+                }\n             }\n-            ret = Cat(e.loc, e.type, e.e1, e.e2).copy();\n-            if (CTFEExp.isCantExp(ret))\n-                ret = e;\n         }\n+    }\n \n-        override void visit(CondExp e)\n+    void visitCmp(CmpExp e)\n+    {\n+        //printf(\"CmpExp::optimize() %s\\n\", e.toChars());\n+        if (binOptimize(e, WANTvalue))\n+            return;\n+        Expression e1 = fromConstInitializer(result, e.e1);\n+        Expression e2 = fromConstInitializer(result, e.e2);\n+        ret = Cmp(e.op, e.loc, e.type, e1, e2).copy();\n+        if (CTFEExp.isCantExp(ret))\n+            ret = e;\n+    }\n+\n+    void visitCat(CatExp e)\n+    {\n+        //printf(\"CatExp::optimize(%d) %s\\n\", result, e.toChars());\n+        if (binOptimize(e, result))\n+            return;\n+        if (auto ce1 = e.e1.isCatExp())\n         {\n-            if (expOptimize(e.econd, WANTvalue))\n-                return;\n-            if (e.econd.isBool(true))\n-                ret = Expression_optimize(e.e1, result, keepLvalue);\n-            else if (e.econd.isBool(false))\n-                ret = Expression_optimize(e.e2, result, keepLvalue);\n-            else\n+            // https://issues.dlang.org/show_bug.cgi?id=12798\n+            // optimize ((expr ~ str1) ~ str2)\n+            scope CatExp cex = new CatExp(e.loc, ce1.e2, e.e2);\n+            cex.type = e.type;\n+            Expression ex = Expression_optimize(cex, result, false);\n+            if (ex != cex)\n             {\n-                expOptimize(e.e1, result, keepLvalue);\n-                expOptimize(e.e2, result, keepLvalue);\n+                e.e1 = ce1.e1;\n+                e.e2 = ex;\n             }\n         }\n+        // optimize \"str\"[] -> \"str\"\n+        if (auto se1 = e.e1.isSliceExp())\n+        {\n+            if (se1.e1.op == EXP.string_ && !se1.lwr)\n+                e.e1 = se1.e1;\n+        }\n+        if (auto se2 = e.e2.isSliceExp())\n+        {\n+            if (se2.e1.op == EXP.string_ && !se2.lwr)\n+                e.e2 = se2.e1;\n+        }\n+        ret = Cat(e.loc, e.type, e.e1, e.e2).copy();\n+        if (CTFEExp.isCantExp(ret))\n+            ret = e;\n     }\n \n-    scope OptimizeVisitor v = new OptimizeVisitor(e, result, keepLvalue);\n+    void visitCond(CondExp e)\n+    {\n+        if (expOptimize(e.econd, WANTvalue))\n+            return;\n+        const opt = e.econd.toBool();\n+        if (opt.hasValue(true))\n+            ret = Expression_optimize(e.e1, result, keepLvalue);\n+        else if (opt.hasValue(false))\n+            ret = Expression_optimize(e.e2, result, keepLvalue);\n+        else\n+        {\n+            expOptimize(e.e1, result, keepLvalue);\n+            expOptimize(e.e2, result, keepLvalue);\n+        }\n+    }\n \n     // Optimize the expression until it can no longer be simplified.\n     size_t b;\n@@ -1179,10 +1163,103 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n             e.error(\"infinite loop while optimizing expression\");\n             fatal();\n         }\n-        auto ex = v.ret;\n-        ex.accept(v);\n-        if (ex == v.ret)\n+\n+        auto ex = ret;\n+        switch (ex.op)\n+        {\n+            case EXP.variable:          visitVar(ex.isVarExp()); break;\n+            case EXP.tuple:             visitTuple(ex.isTupleExp()); break;\n+            case EXP.arrayLiteral:      visitArrayLiteral(ex.isArrayLiteralExp()); break;\n+            case EXP.assocArrayLiteral: visitAssocArrayLiteral(ex.isAssocArrayLiteralExp()); break;\n+            case EXP.structLiteral:     visitStructLiteral(ex.isStructLiteralExp()); break;\n+\n+            case EXP.import_:\n+            case EXP.assert_:\n+            case EXP.dotIdentifier:\n+            case EXP.dotTemplateDeclaration:\n+            case EXP.dotTemplateInstance:\n+            case EXP.delegate_:\n+            case EXP.dotType:\n+            case EXP.uadd:\n+            case EXP.delete_:\n+            case EXP.vector:\n+            case EXP.vectorArray:\n+            case EXP.array:\n+            case EXP.delegatePointer:\n+            case EXP.delegateFunctionPointer:\n+            case EXP.preMinusMinus:\n+            case EXP.prePlusPlus:       visitUna(cast(UnaExp)ex); break;\n+\n+            case EXP.negate:            visitNeg(ex.isNegExp()); break;\n+            case EXP.tilde:             visitCom(ex.isComExp()); break;\n+            case EXP.not:               visitNop(ex.isNotExp()); break;\n+            case EXP.symbolOffset:      visitSymOff(ex.isSymOffExp()); break;\n+            case EXP.address:           visitAddr(ex.isAddrExp()); break;\n+            case EXP.star:              visitPtr(ex.isPtrExp()); break;\n+            case EXP.dotVariable:       visitDotVar(ex.isDotVarExp()); break;\n+            case EXP.new_:              visitNew(ex.isNewExp()); break;\n+            case EXP.call:              visitCall(ex.isCallExp()); break;\n+            case EXP.cast_:             visitCast(ex.isCastExp()); break;\n+\n+            case EXP.addAssign:\n+            case EXP.minAssign:\n+            case EXP.mulAssign:\n+            case EXP.divAssign:\n+            case EXP.modAssign:\n+            case EXP.andAssign:\n+            case EXP.orAssign:\n+            case EXP.xorAssign:\n+            case EXP.powAssign:\n+            case EXP.leftShiftAssign:\n+            case EXP.rightShiftAssign:\n+            case EXP.unsignedRightShiftAssign:\n+            case EXP.concatenateElemAssign:\n+            case EXP.concatenateDcharAssign:\n+            case EXP.concatenateAssign: visitBinAssign(ex.isBinAssignExp()); break;\n+\n+            case EXP.minusMinus:\n+            case EXP.plusPlus:\n+            case EXP.assign:\n+            case EXP.construct:\n+            case EXP.blit:\n+            case EXP.in_:\n+            case EXP.remove:\n+            case EXP.dot:                       visitBin(cast(BinExp)ex); break;\n+\n+            case EXP.add:                       visitAdd(ex.isAddExp()); break;\n+            case EXP.min:                       visitMin(ex.isMinExp()); break;\n+            case EXP.mul:                       visitMul(ex.isMulExp()); break;\n+            case EXP.div:                       visitDiv(ex.isDivExp()); break;\n+            case EXP.mod:                       visitMod(ex.isModExp()); break;\n+            case EXP.leftShift:                 visitShl(ex.isShlExp()); break;\n+            case EXP.rightShift:                visitShr(ex.isShrExp()); break;\n+            case EXP.unsignedRightShift:        visitUshr(ex.isUshrExp()); break;\n+            case EXP.and:                       visitAnd(ex.isAndExp()); break;\n+            case EXP.or:                        visitOr(ex.isOrExp()); break;\n+            case EXP.xor:                       visitXor(ex.isXorExp()); break;\n+            case EXP.pow:                       visitPow(ex.isPowExp()); break;\n+            case EXP.comma:                     visitComma(ex.isCommaExp()); break;\n+            case EXP.arrayLength:               visitArrayLength(ex.isArrayLengthExp()); break;\n+            case EXP.notEqual:\n+            case EXP.equal:                     visitEqual(ex.isEqualExp()); break;\n+            case EXP.notIdentity:\n+            case EXP.identity:                  visitIdentity(ex.isIdentityExp()); break;\n+            case EXP.index:                     visitIndex(ex.isIndexExp()); break;\n+            case EXP.slice:                     visitSlice(ex.isSliceExp()); break;\n+            case EXP.andAnd:\n+            case EXP.orOr:                      visitLogical(ex.isLogicalExp()); break;\n+            case EXP.lessThan:\n+            case EXP.lessOrEqual:\n+            case EXP.greaterThan:\n+            case EXP.greaterOrEqual:            visitCmp(cast(CmpExp)ex); break;\n+            case EXP.concatenate:               visitCat(ex.isCatExp()); break;\n+            case EXP.question:                  visitCond(ex.isCondExp()); break;\n+\n+            default:                            visitExp(ex); break;\n+        }\n+\n+        if (ex == ret)\n             break;\n     }\n-    return v.ret;\n+    return ret;\n }"}, {"sha": "2229e7853db3861f428d3aa838cbf624a82208f3", "filename": "gcc/d/dmd/parse.d", "status": "modified", "additions": 178, "deletions": 162, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -50,146 +50,146 @@ private enum CARRAYDECL = 1;\n  *\n  * Used by hdrgen\n  */\n-immutable PREC[TOK.max + 1] precedence =\n+immutable PREC[EXP.max + 1] precedence =\n [\n-    TOK.type : PREC.expr,\n-    TOK.error : PREC.expr,\n-    TOK.objcClassReference : PREC.expr, // Objective-C class reference, same as TOK.type\n-\n-    TOK.typeof_ : PREC.primary,\n-    TOK.mixin_ : PREC.primary,\n-\n-    TOK.import_ : PREC.primary,\n-    TOK.dotVariable : PREC.primary,\n-    TOK.scope_ : PREC.primary,\n-    TOK.identifier : PREC.primary,\n-    TOK.this_ : PREC.primary,\n-    TOK.super_ : PREC.primary,\n-    TOK.int64 : PREC.primary,\n-    TOK.float64 : PREC.primary,\n-    TOK.complex80 : PREC.primary,\n-    TOK.null_ : PREC.primary,\n-    TOK.string_ : PREC.primary,\n-    TOK.arrayLiteral : PREC.primary,\n-    TOK.assocArrayLiteral : PREC.primary,\n-    TOK.classReference : PREC.primary,\n-    TOK.file : PREC.primary,\n-    TOK.fileFullPath : PREC.primary,\n-    TOK.line : PREC.primary,\n-    TOK.moduleString : PREC.primary,\n-    TOK.functionString : PREC.primary,\n-    TOK.prettyFunction : PREC.primary,\n-    TOK.typeid_ : PREC.primary,\n-    TOK.is_ : PREC.primary,\n-    TOK.assert_ : PREC.primary,\n-    TOK.halt : PREC.primary,\n-    TOK.template_ : PREC.primary,\n-    TOK.dSymbol : PREC.primary,\n-    TOK.function_ : PREC.primary,\n-    TOK.variable : PREC.primary,\n-    TOK.symbolOffset : PREC.primary,\n-    TOK.structLiteral : PREC.primary,\n-    TOK.compoundLiteral : PREC.primary,\n-    TOK.arrayLength : PREC.primary,\n-    TOK.delegatePointer : PREC.primary,\n-    TOK.delegateFunctionPointer : PREC.primary,\n-    TOK.remove : PREC.primary,\n-    TOK.tuple : PREC.primary,\n-    TOK.traits : PREC.primary,\n-    TOK.default_ : PREC.primary,\n-    TOK.overloadSet : PREC.primary,\n-    TOK.void_ : PREC.primary,\n-    TOK.vectorArray : PREC.primary,\n-    TOK._Generic : PREC.primary,\n+    EXP.type : PREC.expr,\n+    EXP.error : PREC.expr,\n+    EXP.objcClassReference : PREC.expr, // Objective-C class reference, same as EXP.type\n+\n+    EXP.typeof_ : PREC.primary,\n+    EXP.mixin_ : PREC.primary,\n+\n+    EXP.import_ : PREC.primary,\n+    EXP.dotVariable : PREC.primary,\n+    EXP.scope_ : PREC.primary,\n+    EXP.identifier : PREC.primary,\n+    EXP.this_ : PREC.primary,\n+    EXP.super_ : PREC.primary,\n+    EXP.int64 : PREC.primary,\n+    EXP.float64 : PREC.primary,\n+    EXP.complex80 : PREC.primary,\n+    EXP.null_ : PREC.primary,\n+    EXP.string_ : PREC.primary,\n+    EXP.arrayLiteral : PREC.primary,\n+    EXP.assocArrayLiteral : PREC.primary,\n+    EXP.classReference : PREC.primary,\n+    EXP.file : PREC.primary,\n+    EXP.fileFullPath : PREC.primary,\n+    EXP.line : PREC.primary,\n+    EXP.moduleString : PREC.primary,\n+    EXP.functionString : PREC.primary,\n+    EXP.prettyFunction : PREC.primary,\n+    EXP.typeid_ : PREC.primary,\n+    EXP.is_ : PREC.primary,\n+    EXP.assert_ : PREC.primary,\n+    EXP.halt : PREC.primary,\n+    EXP.template_ : PREC.primary,\n+    EXP.dSymbol : PREC.primary,\n+    EXP.function_ : PREC.primary,\n+    EXP.variable : PREC.primary,\n+    EXP.symbolOffset : PREC.primary,\n+    EXP.structLiteral : PREC.primary,\n+    EXP.compoundLiteral : PREC.primary,\n+    EXP.arrayLength : PREC.primary,\n+    EXP.delegatePointer : PREC.primary,\n+    EXP.delegateFunctionPointer : PREC.primary,\n+    EXP.remove : PREC.primary,\n+    EXP.tuple : PREC.primary,\n+    EXP.traits : PREC.primary,\n+    EXP.default_ : PREC.primary,\n+    EXP.overloadSet : PREC.primary,\n+    EXP.void_ : PREC.primary,\n+    EXP.vectorArray : PREC.primary,\n+    EXP._Generic : PREC.primary,\n \n     // post\n-    TOK.dotTemplateInstance : PREC.primary,\n-    TOK.dotIdentifier : PREC.primary,\n-    TOK.dotTemplateDeclaration : PREC.primary,\n-    TOK.dot : PREC.primary,\n-    TOK.dotType : PREC.primary,\n-    TOK.plusPlus : PREC.primary,\n-    TOK.minusMinus : PREC.primary,\n-    TOK.prePlusPlus : PREC.primary,\n-    TOK.preMinusMinus : PREC.primary,\n-    TOK.call : PREC.primary,\n-    TOK.slice : PREC.primary,\n-    TOK.array : PREC.primary,\n-    TOK.index : PREC.primary,\n-\n-    TOK.delegate_ : PREC.unary,\n-    TOK.address : PREC.unary,\n-    TOK.star : PREC.unary,\n-    TOK.negate : PREC.unary,\n-    TOK.uadd : PREC.unary,\n-    TOK.not : PREC.unary,\n-    TOK.tilde : PREC.unary,\n-    TOK.delete_ : PREC.unary,\n-    TOK.new_ : PREC.unary,\n-    TOK.newAnonymousClass : PREC.unary,\n-    TOK.cast_ : PREC.unary,\n-\n-    TOK.vector : PREC.unary,\n-    TOK.pow : PREC.pow,\n-\n-    TOK.mul : PREC.mul,\n-    TOK.div : PREC.mul,\n-    TOK.mod : PREC.mul,\n-\n-    TOK.add : PREC.add,\n-    TOK.min : PREC.add,\n-    TOK.concatenate : PREC.add,\n-\n-    TOK.leftShift : PREC.shift,\n-    TOK.rightShift : PREC.shift,\n-    TOK.unsignedRightShift : PREC.shift,\n-\n-    TOK.lessThan : PREC.rel,\n-    TOK.lessOrEqual : PREC.rel,\n-    TOK.greaterThan : PREC.rel,\n-    TOK.greaterOrEqual : PREC.rel,\n-    TOK.in_ : PREC.rel,\n+    EXP.dotTemplateInstance : PREC.primary,\n+    EXP.dotIdentifier : PREC.primary,\n+    EXP.dotTemplateDeclaration : PREC.primary,\n+    EXP.dot : PREC.primary,\n+    EXP.dotType : PREC.primary,\n+    EXP.plusPlus : PREC.primary,\n+    EXP.minusMinus : PREC.primary,\n+    EXP.prePlusPlus : PREC.primary,\n+    EXP.preMinusMinus : PREC.primary,\n+    EXP.call : PREC.primary,\n+    EXP.slice : PREC.primary,\n+    EXP.array : PREC.primary,\n+    EXP.index : PREC.primary,\n+\n+    EXP.delegate_ : PREC.unary,\n+    EXP.address : PREC.unary,\n+    EXP.star : PREC.unary,\n+    EXP.negate : PREC.unary,\n+    EXP.uadd : PREC.unary,\n+    EXP.not : PREC.unary,\n+    EXP.tilde : PREC.unary,\n+    EXP.delete_ : PREC.unary,\n+    EXP.new_ : PREC.unary,\n+    EXP.newAnonymousClass : PREC.unary,\n+    EXP.cast_ : PREC.unary,\n+\n+    EXP.vector : PREC.unary,\n+    EXP.pow : PREC.pow,\n+\n+    EXP.mul : PREC.mul,\n+    EXP.div : PREC.mul,\n+    EXP.mod : PREC.mul,\n+\n+    EXP.add : PREC.add,\n+    EXP.min : PREC.add,\n+    EXP.concatenate : PREC.add,\n+\n+    EXP.leftShift : PREC.shift,\n+    EXP.rightShift : PREC.shift,\n+    EXP.unsignedRightShift : PREC.shift,\n+\n+    EXP.lessThan : PREC.rel,\n+    EXP.lessOrEqual : PREC.rel,\n+    EXP.greaterThan : PREC.rel,\n+    EXP.greaterOrEqual : PREC.rel,\n+    EXP.in_ : PREC.rel,\n \n     /* Note that we changed precedence, so that < and != have the same\n      * precedence. This change is in the parser, too.\n      */\n-    TOK.equal : PREC.rel,\n-    TOK.notEqual : PREC.rel,\n-    TOK.identity : PREC.rel,\n-    TOK.notIdentity : PREC.rel,\n-\n-    TOK.and : PREC.and,\n-    TOK.xor : PREC.xor,\n-    TOK.or : PREC.or,\n-\n-    TOK.andAnd : PREC.andand,\n-    TOK.orOr : PREC.oror,\n-\n-    TOK.question : PREC.cond,\n-\n-    TOK.assign : PREC.assign,\n-    TOK.construct : PREC.assign,\n-    TOK.blit : PREC.assign,\n-    TOK.addAssign : PREC.assign,\n-    TOK.minAssign : PREC.assign,\n-    TOK.concatenateAssign : PREC.assign,\n-    TOK.concatenateElemAssign : PREC.assign,\n-    TOK.concatenateDcharAssign : PREC.assign,\n-    TOK.mulAssign : PREC.assign,\n-    TOK.divAssign : PREC.assign,\n-    TOK.modAssign : PREC.assign,\n-    TOK.powAssign : PREC.assign,\n-    TOK.leftShiftAssign : PREC.assign,\n-    TOK.rightShiftAssign : PREC.assign,\n-    TOK.unsignedRightShiftAssign : PREC.assign,\n-    TOK.andAssign : PREC.assign,\n-    TOK.orAssign : PREC.assign,\n-    TOK.xorAssign : PREC.assign,\n-\n-    TOK.comma : PREC.expr,\n-    TOK.declaration : PREC.expr,\n-\n-    TOK.interval : PREC.assign,\n+    EXP.equal : PREC.rel,\n+    EXP.notEqual : PREC.rel,\n+    EXP.identity : PREC.rel,\n+    EXP.notIdentity : PREC.rel,\n+\n+    EXP.and : PREC.and,\n+    EXP.xor : PREC.xor,\n+    EXP.or : PREC.or,\n+\n+    EXP.andAnd : PREC.andand,\n+    EXP.orOr : PREC.oror,\n+\n+    EXP.question : PREC.cond,\n+\n+    EXP.assign : PREC.assign,\n+    EXP.construct : PREC.assign,\n+    EXP.blit : PREC.assign,\n+    EXP.addAssign : PREC.assign,\n+    EXP.minAssign : PREC.assign,\n+    EXP.concatenateAssign : PREC.assign,\n+    EXP.concatenateElemAssign : PREC.assign,\n+    EXP.concatenateDcharAssign : PREC.assign,\n+    EXP.mulAssign : PREC.assign,\n+    EXP.divAssign : PREC.assign,\n+    EXP.modAssign : PREC.assign,\n+    EXP.powAssign : PREC.assign,\n+    EXP.leftShiftAssign : PREC.assign,\n+    EXP.rightShiftAssign : PREC.assign,\n+    EXP.unsignedRightShiftAssign : PREC.assign,\n+    EXP.andAssign : PREC.assign,\n+    EXP.orAssign : PREC.assign,\n+    EXP.xorAssign : PREC.assign,\n+\n+    EXP.comma : PREC.expr,\n+    EXP.declaration : PREC.expr,\n+\n+    EXP.interval : PREC.assign,\n ];\n \n enum ParseStatementFlags : int\n@@ -4079,7 +4079,7 @@ class Parser(AST) : Lexer\n                     // Handle delegate declaration:\n                     //      t delegate(parameter list) nothrow pure\n                     //      t function(parameter list) nothrow pure\n-                    TOK save = token.value;\n+                    const save = token.value;\n                     nextToken();\n \n                     auto parameterList = parseParameterList(null);\n@@ -5752,7 +5752,7 @@ LagainStc:\n                  * Error: found 'foo' when expecting ';' following statement\n                  * becomes Error: found `(` when expecting `;` or `=`, did you mean `Foo foo = 42`?\n                  */\n-                if (token.value == TOK.identifier && exp.op == TOK.identifier)\n+                if (token.value == TOK.identifier && exp.op == EXP.identifier)\n                 {\n                     error(\"found `%s` when expecting `;` or `=`, did you mean `%s %s = %s`?\", peek(&token).toChars(), exp.toChars(), token.toChars(), peek(peek(&token)).toChars());\n                     nextToken();\n@@ -5911,7 +5911,7 @@ LagainStc:\n                     // mixin(string)\n                     AST.Expression e = parseAssignExp();\n                     check(TOK.semicolon);\n-                    if (e.op == TOK.mixin_)\n+                    if (e.op == EXP.mixin_)\n                     {\n                         AST.MixinExp cpe = cast(AST.MixinExp)e;\n                         s = new AST.CompileStatement(loc, cpe.exps);\n@@ -6816,8 +6816,8 @@ LagainStc:\n         {\n             switch (token.value)\n             {\n-            case TOK.file:           e = new AST.FileInitExp(token.loc, TOK.file); break;\n-            case TOK.fileFullPath:   e = new AST.FileInitExp(token.loc, TOK.fileFullPath); break;\n+            case TOK.file:           e = new AST.FileInitExp(token.loc, EXP.file); break;\n+            case TOK.fileFullPath:   e = new AST.FileInitExp(token.loc, EXP.fileFullPath); break;\n             case TOK.line:           e = new AST.LineInitExp(token.loc); break;\n             case TOK.moduleString:   e = new AST.ModuleInitExp(token.loc); break;\n             case TOK.functionString: e = new AST.FuncInitExp(token.loc); break;\n@@ -8470,14 +8470,14 @@ LagainStc:\n             nextToken();\n             e = parseUnaryExp();\n             //e = new AddAssignExp(loc, e, new IntegerExp(loc, 1, Type::tint32));\n-            e = new AST.PreExp(TOK.prePlusPlus, loc, e);\n+            e = new AST.PreExp(EXP.prePlusPlus, loc, e);\n             break;\n \n         case TOK.minusMinus:\n             nextToken();\n             e = parseUnaryExp();\n             //e = new MinAssignExp(loc, e, new IntegerExp(loc, 1, Type::tint32));\n-            e = new AST.PreExp(TOK.preMinusMinus, loc, e);\n+            e = new AST.PreExp(EXP.preMinusMinus, loc, e);\n             break;\n \n         case TOK.mul:\n@@ -8785,11 +8785,11 @@ LagainStc:\n                 break;\n \n             case TOK.plusPlus:\n-                e = new AST.PostExp(TOK.plusPlus, loc, e);\n+                e = new AST.PostExp(EXP.plusPlus, loc, e);\n                 break;\n \n             case TOK.minusMinus:\n-                e = new AST.PostExp(TOK.minusMinus, loc, e);\n+                e = new AST.PostExp(EXP.minusMinus, loc, e);\n                 break;\n \n             case TOK.leftParenthesis:\n@@ -8946,21 +8946,18 @@ LagainStc:\n         const loc = token.loc;\n \n         auto e = parseShiftExp();\n-        TOK op = token.value;\n+        EXP op = EXP.reserved;\n \n-        switch (op)\n+        switch (token.value)\n         {\n-        case TOK.equal:\n-        case TOK.notEqual:\n+        case TOK.equal:         op = EXP.equal; goto Lequal;\n+        case TOK.notEqual:      op = EXP.notEqual; goto Lequal;\n+        Lequal:\n             nextToken();\n             auto e2 = parseShiftExp();\n             e = new AST.EqualExp(op, loc, e, e2);\n             break;\n \n-        case TOK.is_:\n-            op = TOK.identity;\n-            goto L1;\n-\n         case TOK.not:\n         {\n             // Attempt to identify '!is'\n@@ -8977,19 +8974,21 @@ LagainStc:\n             if (tv != TOK.is_)\n                 break;\n             nextToken();\n-            op = TOK.notIdentity;\n-            goto L1;\n+            op = EXP.notIdentity;\n+            goto Lidentity;\n         }\n-        L1:\n+        case TOK.is_:           op = EXP.identity; goto Lidentity;\n+        Lidentity:\n             nextToken();\n             auto e2 = parseShiftExp();\n             e = new AST.IdentityExp(op, loc, e, e2);\n             break;\n \n-        case TOK.lessThan:\n-        case TOK.lessOrEqual:\n-        case TOK.greaterThan:\n-        case TOK.greaterOrEqual:\n+        case TOK.lessThan:       op = EXP.lessThan;       goto Lcmp;\n+        case TOK.lessOrEqual:    op = EXP.lessOrEqual;    goto Lcmp;\n+        case TOK.greaterThan:    op = EXP.greaterThan;    goto Lcmp;\n+        case TOK.greaterOrEqual: op = EXP.greaterOrEqual; goto Lcmp;\n+        Lcmp:\n             nextToken();\n             auto e2 = parseShiftExp();\n             e = new AST.CmpExp(op, loc, e, e2);\n@@ -9064,7 +9063,7 @@ LagainStc:\n         {\n             nextToken();\n             auto e2 = parseOrExp();\n-            e = new AST.LogicalExp(loc, TOK.andAnd, e, e2);\n+            e = new AST.LogicalExp(loc, EXP.andAnd, e, e2);\n         }\n         return e;\n     }\n@@ -9078,7 +9077,7 @@ LagainStc:\n         {\n             nextToken();\n             auto e2 = parseAndAndExp();\n-            e = new AST.LogicalExp(loc, TOK.orOr, e, e2);\n+            e = new AST.LogicalExp(loc, EXP.orOr, e, e2);\n         }\n         return e;\n     }\n@@ -9107,92 +9106,109 @@ LagainStc:\n             return e;\n \n         // require parens for e.g. `t ? a = 1 : b = 2`\n-        if (e.op == TOK.question && !e.parens && precedence[token.value] == PREC.assign)\n-            dmd.errors.error(e.loc, \"`%s` must be surrounded by parentheses when next to operator `%s`\",\n-                e.toChars(), Token.toChars(token.value));\n+        void checkRequiredParens()\n+        {\n+            if (e.op == EXP.question && !e.parens)\n+                dmd.errors.error(e.loc, \"`%s` must be surrounded by parentheses when next to operator `%s`\",\n+                    e.toChars(), Token.toChars(token.value));\n+        }\n \n         const loc = token.loc;\n         switch (token.value)\n         {\n         case TOK.assign:\n+            checkRequiredParens();\n             nextToken();\n             auto e2 = parseAssignExp();\n             e = new AST.AssignExp(loc, e, e2);\n             break;\n \n         case TOK.addAssign:\n+            checkRequiredParens();\n             nextToken();\n             auto e2 = parseAssignExp();\n             e = new AST.AddAssignExp(loc, e, e2);\n             break;\n \n         case TOK.minAssign:\n+            checkRequiredParens();\n             nextToken();\n             auto e2 = parseAssignExp();\n             e = new AST.MinAssignExp(loc, e, e2);\n             break;\n \n         case TOK.mulAssign:\n+            checkRequiredParens();\n             nextToken();\n             auto e2 = parseAssignExp();\n             e = new AST.MulAssignExp(loc, e, e2);\n             break;\n \n         case TOK.divAssign:\n+            checkRequiredParens();\n             nextToken();\n             auto e2 = parseAssignExp();\n             e = new AST.DivAssignExp(loc, e, e2);\n             break;\n \n         case TOK.modAssign:\n+            checkRequiredParens();\n             nextToken();\n             auto e2 = parseAssignExp();\n             e = new AST.ModAssignExp(loc, e, e2);\n             break;\n \n         case TOK.powAssign:\n+            checkRequiredParens();\n             nextToken();\n             auto e2 = parseAssignExp();\n             e = new AST.PowAssignExp(loc, e, e2);\n             break;\n \n         case TOK.andAssign:\n+            checkRequiredParens();\n             nextToken();\n             auto e2 = parseAssignExp();\n             e = new AST.AndAssignExp(loc, e, e2);\n             break;\n \n         case TOK.orAssign:\n+            checkRequiredParens();\n             nextToken();\n             auto e2 = parseAssignExp();\n             e = new AST.OrAssignExp(loc, e, e2);\n             break;\n \n         case TOK.xorAssign:\n+            checkRequiredParens();\n             nextToken();\n             auto e2 = parseAssignExp();\n             e = new AST.XorAssignExp(loc, e, e2);\n             break;\n \n         case TOK.leftShiftAssign:\n+            checkRequiredParens();\n             nextToken();\n             auto e2 = parseAssignExp();\n             e = new AST.ShlAssignExp(loc, e, e2);\n             break;\n \n         case TOK.rightShiftAssign:\n+            checkRequiredParens();\n             nextToken();\n             auto e2 = parseAssignExp();\n             e = new AST.ShrAssignExp(loc, e, e2);\n             break;\n \n         case TOK.unsignedRightShiftAssign:\n+            checkRequiredParens();\n             nextToken();\n             auto e2 = parseAssignExp();\n             e = new AST.UshrAssignExp(loc, e, e2);\n             break;\n \n         case TOK.concatenateAssign:\n+            checkRequiredParens();\n             nextToken();\n             auto e2 = parseAssignExp();\n             e = new AST.CatAssignExp(loc, e, e2);"}, {"sha": "b9f0c5e2eb8d247bd3bee1ae292240b120f33eac", "filename": "gcc/d/dmd/printast.d", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fprintast.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fprintast.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fprintast.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -16,6 +16,7 @@ import core.stdc.stdio;\n import dmd.expression;\n import dmd.tokens;\n import dmd.visitor;\n+import dmd.hdrgen;\n \n /********************\n  * Print AST data structure in a nice format.\n@@ -45,7 +46,8 @@ extern (C++) final class PrintASTVisitor : Visitor\n     override void visit(Expression e)\n     {\n         printIndent(indent);\n-        printf(\"%s %s\\n\", Token.toChars(e.op), e.type ? e.type.toChars() : \"\");\n+        auto s = EXPtoString(e.op);\n+        printf(\"%.*s %s\\n\", cast(int)s.length, s.ptr, e.type ? e.type.toChars() : \"\");\n     }\n \n     override void visit(IntegerExp e)\n@@ -68,7 +70,8 @@ extern (C++) final class PrintASTVisitor : Visitor\n     override void visit(StructLiteralExp e)\n     {\n         printIndent(indent);\n-        printf(\"%s %s, %s\\n\", Token.toChars(e.op), e.type ? e.type.toChars() : \"\", e.toChars());\n+        auto s = EXPtoString(e.op);\n+        printf(\"%.*s %s, %s\\n\", cast(int)s.length, s.ptr, e.type ? e.type.toChars() : \"\", e.toChars());\n     }\n \n     override void visit(SymbolExp e)"}, {"sha": "8b0bcf26049d87d1c3c0bbcbd231553592d33871", "filename": "gcc/d/dmd/root/dcompat.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Froot%2Fdcompat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Froot%2Fdcompat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fdcompat.h?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -43,6 +43,9 @@ typedef unsigned d_size_t;\n         __APPLE__ && __SIZEOF_SIZE_T__ == 8\n // DMD versions between 2.079 and 2.081 mapped D ulong to uint64_t on OS X.\n typedef uint64_t d_size_t;\n+#elif defined(__OpenBSD__) && !defined(__LP64__)\n+// size_t is 'unsigned long', which makes it mangle differently than D's 'uint'\n+typedef unsigned d_size_t;\n #else\n typedef size_t d_size_t;\n #endif"}, {"sha": "2722529bbac9cf715088cc29b9a143934b19ce94", "filename": "gcc/d/dmd/root/file.d", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Froot%2Ffile.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Froot%2Ffile.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Ffile.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -120,11 +120,10 @@ nothrow:\n                 perror(\"\\tclose error\");\n                 goto err;\n             }\n-            // Always store a wchar ^Z past end of buffer so scanner has a sentinel\n-            buffer[size] = 0; // ^Z is obsolete, use 0\n-            buffer[size + 1] = 0;\n-            buffer[size + 2] = 0; //add two more so lexer doesnt read pass the buffer\n-            buffer[size + 3] = 0;\n+            // Always store a wchar ^Z past end of buffer so scanner has a\n+            // sentinel, although ^Z got obselete, so fill with two 0s and add\n+            // two more so lexer doesn't read pass the buffer.\n+            buffer[size .. size + 4] = 0;\n \n             result.success = true;\n             result.buffer.data = buffer[0 .. size];\n@@ -160,11 +159,10 @@ nothrow:\n                 goto err2;\n             if (!CloseHandle(h))\n                 goto err;\n-            // Always store a wchar ^Z past end of buffer so scanner has a sentinel\n-            buffer[size] = 0; // ^Z is obsolete, use 0\n-            buffer[size + 1] = 0;\n-            buffer[size + 2] = 0; //add two more so lexer doesnt read pass the buffer\n-            buffer[size + 3] = 0;\n+            // Always store a wchar ^Z past end of buffer so scanner has a\n+            // sentinel, although ^Z got obselete, so fill with two 0s and add\n+            // two more so lexer doesn't read pass the buffer.\n+            buffer[size .. size + 4] = 0;\n             result.success = true;\n             result.buffer.data = buffer[0 .. size];\n             return result;"}, {"sha": "a593ddd54fdf5fa4662e73301707847823f4aef3", "filename": "gcc/d/dmd/root/optional.d", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Froot%2Foptional.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Froot%2Foptional.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Foptional.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -0,0 +1,86 @@\n+/**\n+ * Optional implementation.\n+ *\n+ * Copyright:   Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n+ * Authors:     $(LINK2 http://www.digitalmars.com, Walter Bright)\n+ * License:     $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+ * Source:      $(LINK2 https://github.com/dlang/dmd/blob/master/src/dmd/root/optional.d, root/_optional.d)\n+ * Documentation:  https://dlang.org/phobos/dmd_root_optional.html\n+ * Coverage:    https://codecov.io/gh/dlang/dmd/src/master/src/dmd/root/optional.d\n+ */\n+module dmd.root.optional;\n+\n+///\n+unittest\n+{\n+    import core.exception : AssertError;\n+\n+    Optional!int opt;\n+    assert( opt.isEmpty());\n+    assert(!opt.isPresent());\n+    assert(!opt.hasValue(1));\n+    assert(!opt.hasValue(2));\n+\n+    bool caught;\n+    try\n+        cast(void) opt.get();\n+    catch (AssertError)\n+        caught = true;\n+    assert(caught);\n+\n+    opt = Optional!int(1);\n+    assert(!opt.isEmpty());\n+    assert( opt.isPresent());\n+    assert( opt.get() == 1);\n+    assert( opt.hasValue(1));\n+    assert(!opt.hasValue(2));\n+}\n+\n+/// Optional type that is either `empty` or contains a value of type `T`\n+extern (C++) struct Optional(T)\n+{\n+    /// the value (if present)\n+    private T value;\n+\n+    /// whether `value` is set\n+    private bool present;\n+\n+    /// Creates an `Optional` with the given value\n+    this(T value)\n+    {\n+        this.value = value;\n+        this.present = true;\n+    }\n+\n+    // Ctor wrapper for the C++ interface (required by older host compilers)\n+    /// ditto\n+    static Optional!T create(T val)\n+    {\n+        return Optional!T(val);\n+    }\n+\n+    /// Returns: Whether this `Optional` contains a value\n+    bool isPresent() const\n+    {\n+        return this.present;\n+    }\n+\n+    /// Returns: Whether this `Optional` does not contain a value\n+    bool isEmpty() const\n+    {\n+        return !this.present;\n+    }\n+\n+    /// Returns: The value if present\n+    inout(T) get() inout\n+    {\n+        assert(present);\n+        return value;\n+    }\n+\n+    /// Returns: Whether this `Optional` contains the supplied value\n+    bool hasValue(const T exp) const\n+    {\n+        return present && value == exp;\n+    }\n+}"}, {"sha": "fa52b584f3265d07d56d0170d2c7f1f772c5e740", "filename": "gcc/d/dmd/root/optional.h", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Froot%2Foptional.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Froot%2Foptional.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Foptional.h?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -0,0 +1,42 @@\n+#pragma once\n+\n+/**\n+ * Optional implementation.\n+ *\n+ * Copyright:   Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n+ * Authors:     $(LINK2 http://www.digitalmars.com, Walter Bright)\n+ * License:     $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+ * Source:      $(LINK2 https://github.com/dlang/dmd/blob/master/src/dmd/root/optional.h, root/_optional.h)\n+ * Documentation:  https://dlang.org/phobos/dmd_root_optional.html\n+ * Coverage:    https://codecov.io/gh/dlang/dmd/src/master/src/dmd/root/optional.h\n+ */\n+\n+/// Optional type that is either `empty` or contains a value of type `T`\n+template<typename T>\n+struct Optional final\n+{\n+private:\n+    /** the value (if present) **/\n+    T value;\n+\n+    /** whether `value` is set **/\n+    bool present;\n+\n+public:\n+    /** Creates an `Optional` with the given value **/\n+    Optional(T);\n+\n+    /** Creates an `Optional` with the given value **/\n+    static Optional<T> create(T);\n+\n+    /** Checks whether this `Optional` contains a value **/\n+    bool isPresent() const;\n+\n+    /** Checks whether this `Optional` does not contain a value **/\n+    bool isEmpty() const;\n+\n+    /** Returns: The value if present **/\n+    T get();\n+\n+    bool hasValue(const T) const;\n+};"}, {"sha": "7eb3e235e41f0aa861d1efa561184f871eeba7c2", "filename": "gcc/d/dmd/safe.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fsafe.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fsafe.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsafe.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -46,7 +46,7 @@ import dmd.tokens;\n bool checkUnsafeAccess(Scope* sc, Expression e, bool readonly, bool printmsg)\n {\n     //printf(\"checkUnsafeAccess(e: '%s', readonly: %d, printmsg: %d)\\n\", e.toChars(), readonly, printmsg);\n-    if (e.op != TOK.dotVariable)\n+    if (e.op != EXP.dotVariable)\n         return false;\n     DotVarExp dve = cast(DotVarExp)e;\n     if (VarDeclaration v = dve.var.isVarDeclaration())\n@@ -170,7 +170,7 @@ bool isSafeCast(Expression e, Type tfrom, Type tto)\n          */\n         if (tfromn.ty == Tvoid && ttobn.isMutable())\n         {\n-            if (ttob.ty == Tarray && e.op == TOK.arrayLiteral)\n+            if (ttob.ty == Tarray && e.op == EXP.arrayLiteral)\n                 return true;\n             return false;\n         }"}, {"sha": "c3fe7520175d14063ccc325c022a66a98c2c2009", "filename": "gcc/d/dmd/semantic2.d", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fsemantic2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fsemantic2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsemantic2.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -278,15 +278,15 @@ private extern(C++) final class Semantic2Visitor : Visitor\n                         return false;\n                     }\n \n-                    if (e.op == TOK.classReference)\n+                    if (e.op == EXP.classReference)\n                         return true;\n-                    if (e.op == TOK.address && (cast(AddrExp)e).e1.op == TOK.structLiteral)\n+                    if (e.op == EXP.address && (cast(AddrExp)e).e1.op == EXP.structLiteral)\n                         return true;\n-                    if (e.op == TOK.arrayLiteral)\n+                    if (e.op == EXP.arrayLiteral)\n                         return arrayHasInvalidEnumInitializer((cast(ArrayLiteralExp)e).elements);\n-                    if (e.op == TOK.structLiteral)\n+                    if (e.op == EXP.structLiteral)\n                         return arrayHasInvalidEnumInitializer((cast(StructLiteralExp)e).elements);\n-                    if (e.op == TOK.assocArrayLiteral)\n+                    if (e.op == EXP.assocArrayLiteral)\n                     {\n                         AssocArrayLiteralExp ae = cast(AssocArrayLiteralExp)e;\n                         return arrayHasInvalidEnumInitializer(ae.values) ||\n@@ -306,13 +306,13 @@ private extern(C++) final class Semantic2Visitor : Visitor\n             if ((vd.type.ty == Tclass) && vd.type.isMutable() && !vd.type.isShared())\n             {\n                 ExpInitializer ei = vd._init.isExpInitializer();\n-                if (ei && ei.exp.op == TOK.classReference)\n+                if (ei && ei.exp.op == EXP.classReference)\n                     vd.error(\"is a thread-local class and cannot have a static initializer. Use `static this()` to initialize instead.\");\n             }\n             else if (vd.type.ty == Tpointer && vd.type.nextOf().ty == Tstruct && vd.type.nextOf().isMutable() && !vd.type.nextOf().isShared())\n             {\n                 ExpInitializer ei = vd._init.isExpInitializer();\n-                if (ei && ei.exp.op == TOK.address && (cast(AddrExp)ei.exp).e1.op == TOK.structLiteral)\n+                if (ei && ei.exp.op == EXP.address && (cast(AddrExp)ei.exp).e1.op == EXP.structLiteral)\n                     vd.error(\"is a thread-local pointer to struct and cannot have a static initializer. Use `static this()` to initialize instead.\");\n             }\n         }\n@@ -569,7 +569,7 @@ private extern(C++) final class Semantic2Visitor : Visitor\n                 e = e.expressionSemantic(sc);\n                 if (definitelyValueParameter(e))\n                     e = e.ctfeInterpret();\n-                if (e.op == TOK.tuple)\n+                if (e.op == EXP.tuple)\n                 {\n                     TupleExp te = cast(TupleExp)e;\n                     eval(sc, te.exps, lastTag);\n@@ -697,7 +697,7 @@ private void doGNUABITagSemantic(ref Expression e, ref Expression* lastTag)\n     import dmd.dmangle;\n \n     // When `@gnuAbiTag` is used, the type will be the UDA, not the struct literal\n-    if (e.op == TOK.type)\n+    if (e.op == EXP.type)\n     {\n         e.error(\"`@%s` at least one argument expected\", Id.udaGNUAbiTag.toChars());\n         return;"}, {"sha": "893f96b4ea9ff90abf419131c4712e29a2c5f5a1", "filename": "gcc/d/dmd/semantic3.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fsemantic3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fsemantic3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsemantic3.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -611,7 +611,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                     for (size_t i = 0; i < funcdecl.returns.dim;)\n                     {\n                         Expression exp = (*funcdecl.returns)[i].exp;\n-                        if (exp.op == TOK.variable && (cast(VarExp)exp).var == funcdecl.vresult)\n+                        if (exp.op == EXP.variable && (cast(VarExp)exp).var == funcdecl.vresult)\n                         {\n                             if (addReturn0())\n                                 exp.type = Type.tint32;\n@@ -817,7 +817,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                     {\n                         ReturnStatement rs = (*funcdecl.returns)[i];\n                         Expression exp = rs.exp;\n-                        if (exp.op == TOK.error)\n+                        if (exp.op == EXP.error)\n                             continue;\n                         if (tret.ty == Terror)\n                         {"}, {"sha": "99833b55a329b3ecee443ef6e8f13ba3235cd165", "filename": "gcc/d/dmd/sideeffect.d", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fsideeffect.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fsideeffect.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsideeffect.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -47,7 +47,7 @@ extern (C++) bool isTrivialExp(Expression e)\n              * CallExp is always non trivial expression,\n              * especially for inlining.\n              */\n-            if (e.op == TOK.call)\n+            if (e.op == EXP.call)\n             {\n                 stop = true;\n                 return;\n@@ -153,36 +153,36 @@ private bool lambdaHasSideEffect(Expression e, bool assumeImpureCalls = false)\n     switch (e.op)\n     {\n     // Sort the cases by most frequently used first\n-    case TOK.assign:\n-    case TOK.plusPlus:\n-    case TOK.minusMinus:\n-    case TOK.declaration:\n-    case TOK.construct:\n-    case TOK.blit:\n-    case TOK.addAssign:\n-    case TOK.minAssign:\n-    case TOK.concatenateAssign:\n-    case TOK.concatenateElemAssign:\n-    case TOK.concatenateDcharAssign:\n-    case TOK.mulAssign:\n-    case TOK.divAssign:\n-    case TOK.modAssign:\n-    case TOK.leftShiftAssign:\n-    case TOK.rightShiftAssign:\n-    case TOK.unsignedRightShiftAssign:\n-    case TOK.andAssign:\n-    case TOK.orAssign:\n-    case TOK.xorAssign:\n-    case TOK.powAssign:\n-    case TOK.in_:\n-    case TOK.remove:\n-    case TOK.assert_:\n-    case TOK.halt:\n-    case TOK.delete_:\n-    case TOK.new_:\n-    case TOK.newAnonymousClass:\n+    case EXP.assign:\n+    case EXP.plusPlus:\n+    case EXP.minusMinus:\n+    case EXP.declaration:\n+    case EXP.construct:\n+    case EXP.blit:\n+    case EXP.addAssign:\n+    case EXP.minAssign:\n+    case EXP.concatenateAssign:\n+    case EXP.concatenateElemAssign:\n+    case EXP.concatenateDcharAssign:\n+    case EXP.mulAssign:\n+    case EXP.divAssign:\n+    case EXP.modAssign:\n+    case EXP.leftShiftAssign:\n+    case EXP.rightShiftAssign:\n+    case EXP.unsignedRightShiftAssign:\n+    case EXP.andAssign:\n+    case EXP.orAssign:\n+    case EXP.xorAssign:\n+    case EXP.powAssign:\n+    case EXP.in_:\n+    case EXP.remove:\n+    case EXP.assert_:\n+    case EXP.halt:\n+    case EXP.delete_:\n+    case EXP.new_:\n+    case EXP.newAnonymousClass:\n         return true;\n-    case TOK.call:\n+    case EXP.call:\n         {\n             if (assumeImpureCalls)\n                 return true;\n@@ -207,13 +207,13 @@ private bool lambdaHasSideEffect(Expression e, bool assumeImpureCalls = false)\n             }\n             break;\n         }\n-    case TOK.cast_:\n+    case EXP.cast_:\n         {\n             CastExp ce = cast(CastExp)e;\n             /* if:\n              *  cast(classtype)func()  // because it may throw\n              */\n-            if (ce.to.ty == Tclass && ce.e1.op == TOK.call && ce.e1.type.ty == Tclass)\n+            if (ce.to.ty == Tclass && ce.e1.op == EXP.call && ce.e1.type.ty == Tclass)\n                 return true;\n             break;\n         }\n@@ -235,7 +235,7 @@ bool discardValue(Expression e)\n         return false;\n     switch (e.op)\n     {\n-    case TOK.cast_:\n+    case EXP.cast_:\n         {\n             CastExp ce = cast(CastExp)e;\n             if (ce.to.equals(Type.tvoid))\n@@ -247,9 +247,9 @@ bool discardValue(Expression e)\n             }\n             break; // complain\n         }\n-    case TOK.error:\n+    case EXP.error:\n         return false;\n-    case TOK.variable:\n+    case EXP.variable:\n         {\n             VarDeclaration v = (cast(VarExp)e).var.isVarDeclaration();\n             if (v && (v.storage_class & STC.temp))\n@@ -260,7 +260,7 @@ bool discardValue(Expression e)\n             }\n             break;\n         }\n-    case TOK.call:\n+    case EXP.call:\n         /* Issue 3882: */\n         if (global.params.warnings != DiagnosticReporting.off && !global.gag)\n         {\n@@ -285,7 +285,7 @@ bool discardValue(Expression e)\n                     const(char)* s;\n                     if (ce.f)\n                         s = ce.f.toPrettyChars();\n-                    else if (ce.e1.op == TOK.star)\n+                    else if (ce.e1.op == EXP.star)\n                     {\n                         // print 'fp' if ce.e1 is (*fp)\n                         s = (cast(PtrExp)ce.e1).e1.toChars();\n@@ -297,13 +297,13 @@ bool discardValue(Expression e)\n             }\n         }\n         return false;\n-    case TOK.andAnd:\n-    case TOK.orOr:\n+    case EXP.andAnd:\n+    case EXP.orOr:\n         {\n             LogicalExp aae = cast(LogicalExp)e;\n             return discardValue(aae.e2);\n         }\n-    case TOK.question:\n+    case EXP.question:\n         {\n             CondExp ce = cast(CondExp)e;\n             /* https://issues.dlang.org/show_bug.cgi?id=6178\n@@ -333,7 +333,7 @@ bool discardValue(Expression e)\n             }\n             return false;\n         }\n-    case TOK.comma:\n+    case EXP.comma:\n         {\n             CommaExp ce = cast(CommaExp)e;\n             // Don't complain about compiler-generated comma expressions\n@@ -344,7 +344,7 @@ bool discardValue(Expression e)\n             // This is concretely done in expressionSemantic, if a CommaExp has Tvoid as type\n             return discardValue(ce.e2);\n         }\n-    case TOK.tuple:\n+    case EXP.tuple:\n         /* Pass without complaint if any of the tuple elements have side effects.\n          * Ideally any tuple elements with no side effects should raise an error,\n          * this needs more investigation as to what is the right thing to do."}, {"sha": "6979cdf7977c083bbdb5ced9e4e8733720e69504", "filename": "gcc/d/dmd/statementsem.d", "status": "modified", "additions": 424, "deletions": 458, "changes": 882, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fstatementsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fstatementsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatementsem.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -125,7 +125,7 @@ private LabelStatement checkLabeledLoop(Scope* sc, Statement statement)\n private Expression checkAssignmentAsCondition(Expression e)\n {\n     auto ec = lastComma(e);\n-    if (ec.op == TOK.assign)\n+    if (ec.op == EXP.assign)\n     {\n         ec.error(\"assignment cannot be used as a condition, perhaps `==` was meant?\");\n         return ErrorExp.get();\n@@ -213,7 +213,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n \n         s.exp = s.exp.optimize(WANTvalue);\n         s.exp = checkGC(sc, s.exp);\n-        if (s.exp.op == TOK.error)\n+        if (s.exp.op == EXP.error)\n             return setError();\n         result = s;\n     }\n@@ -546,7 +546,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n             ds._body = ds._body.semanticScope(sc, ds, ds, null);\n         sc.inLoop = inLoopSave;\n \n-        if (ds.condition.op == TOK.dotIdentifier)\n+        if (ds.condition.op == EXP.dotIdentifier)\n             (cast(DotIdExp)ds.condition).noderef = true;\n \n         // check in syntax level\n@@ -561,7 +561,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n \n         ds.condition = ds.condition.toBoolean(sc);\n \n-        if (ds.condition.op == TOK.error)\n+        if (ds.condition.op == EXP.error)\n             return setError();\n         if (ds._body && ds._body.isErrorStatement())\n         {\n@@ -619,7 +619,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n \n         if (fs.condition)\n         {\n-            if (fs.condition.op == TOK.dotIdentifier)\n+            if (fs.condition.op == EXP.dotIdentifier)\n                 (cast(DotIdExp)fs.condition).noderef = true;\n \n             // check in syntax level\n@@ -652,406 +652,13 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n \n         sc.pop();\n \n-        if (fs.condition && fs.condition.op == TOK.error ||\n-            fs.increment && fs.increment.op == TOK.error ||\n+        if (fs.condition && fs.condition.op == EXP.error ||\n+            fs.increment && fs.increment.op == EXP.error ||\n             fs._body && fs._body.isErrorStatement())\n             return setError();\n         result = fs;\n     }\n \n-\n-    /*******************\n-     * Type check and unroll `foreach` over an expression tuple as well\n-     * as `static foreach` statements and `static foreach`\n-     * declarations. For `static foreach` statements and `static\n-     * foreach` declarations, the visitor interface is used (and the\n-     * result is written into the `result` field.) For `static\n-     * foreach` declarations, the resulting Dsymbols* are returned\n-     * directly.\n-     *\n-     * The unrolled body is wrapped into a\n-     *  - UnrolledLoopStatement, for `foreach` over an expression tuple.\n-     *  - ForwardingStatement, for `static foreach` statements.\n-     *  - ForwardingAttribDeclaration, for `static foreach` declarations.\n-     *\n-     * `static foreach` variables are declared as `STC.local`, such\n-     * that they are inserted into the local symbol tables of the\n-     * forwarding constructs instead of forwarded. For `static\n-     * foreach` with multiple foreach loop variables whose aggregate\n-     * has been lowered into a sequence of tuples, this function\n-     * expands the tuples into multiple `STC.local` `static foreach`\n-     * variables.\n-     */\n-    auto makeTupleForeach(bool isStatic, bool isDecl)(ForeachStatement fs, Dsymbols* dbody, bool needExpansion)\n-    {\n-        // Voldemort return type\n-        union U\n-        {\n-            Statement statement;\n-            Dsymbols* decl;\n-        }\n-\n-        U result;\n-\n-        auto returnEarly()\n-        {\n-            if (isDecl)\n-                result.decl = null;\n-            else\n-                result.statement = new ErrorStatement();\n-            return result;\n-        }\n-\n-        auto loc = fs.loc;\n-        size_t dim = fs.parameters.dim;\n-        static if(isStatic) bool skipCheck = needExpansion;\n-        else enum skipCheck = false;\n-        if (!skipCheck && (dim < 1 || dim > 2))\n-        {\n-            fs.error(\"only one (value) or two (key,value) arguments for tuple `foreach`\");\n-            setError();\n-            return returnEarly();\n-        }\n-\n-        Type paramtype = (*fs.parameters)[dim - 1].type;\n-        if (paramtype)\n-        {\n-            paramtype = paramtype.typeSemantic(loc, sc);\n-            if (paramtype.ty == Terror)\n-            {\n-                setError();\n-                return returnEarly();\n-            }\n-        }\n-\n-        Type tab = fs.aggr.type.toBasetype();\n-        TypeTuple tuple = cast(TypeTuple)tab;\n-        static if(!isDecl)\n-        {\n-            auto statements = new Statements();\n-        }\n-        else\n-        {\n-            auto declarations = new Dsymbols();\n-        }\n-        //printf(\"aggr: op = %d, %s\\n\", fs.aggr.op, fs.aggr.toChars());\n-        size_t n;\n-        TupleExp te = null;\n-        if (fs.aggr.op == TOK.tuple) // expression tuple\n-        {\n-            te = cast(TupleExp)fs.aggr;\n-            n = te.exps.dim;\n-        }\n-        else if (fs.aggr.op == TOK.type) // type tuple\n-        {\n-            n = Parameter.dim(tuple.arguments);\n-        }\n-        else\n-            assert(0);\n-        foreach (j; 0 .. n)\n-        {\n-            size_t k = (fs.op == TOK.foreach_) ? j : n - 1 - j;\n-            Expression e = null;\n-            Type t = null;\n-            if (te)\n-                e = (*te.exps)[k];\n-            else\n-                t = Parameter.getNth(tuple.arguments, k).type;\n-            Parameter p = (*fs.parameters)[0];\n-            static if(!isDecl)\n-            {\n-                auto st = new Statements();\n-            }\n-            else\n-            {\n-                auto st = new Dsymbols();\n-            }\n-\n-            static if(isStatic) bool skip = needExpansion;\n-            else enum skip = false;\n-            if (!skip && dim == 2)\n-            {\n-                // Declare key\n-                if (p.storageClass & (STC.out_ | STC.ref_ | STC.lazy_))\n-                {\n-                    fs.error(\"no storage class for key `%s`\", p.ident.toChars());\n-                    setError();\n-                    return returnEarly();\n-                }\n-                static if(isStatic)\n-                {\n-                    if(!p.type)\n-                    {\n-                        p.type = Type.tsize_t;\n-                    }\n-                }\n-                p.type = p.type.typeSemantic(loc, sc);\n-\n-                if (!p.type.isintegral())\n-                {\n-                    fs.error(\"foreach: key cannot be of non-integral type `%s`\",\n-                             p.type.toChars());\n-                    setError();\n-                    return returnEarly();\n-                }\n-\n-                const length = te ? te.exps.length : tuple.arguments.length;\n-                IntRange dimrange = IntRange(SignExtendedNumber(length))._cast(Type.tsize_t);\n-                // https://issues.dlang.org/show_bug.cgi?id=12504\n-                dimrange.imax = SignExtendedNumber(dimrange.imax.value-1);\n-                if (!IntRange.fromType(p.type).contains(dimrange))\n-                {\n-                    fs.error(\"index type `%s` cannot cover index range 0..%llu\",\n-                             p.type.toChars(), cast(ulong)length);\n-                    setError();\n-                    return returnEarly();\n-                }\n-                Initializer ie = new ExpInitializer(Loc.initial, new IntegerExp(k));\n-                auto var = new VarDeclaration(loc, p.type, p.ident, ie);\n-                var.storage_class |= STC.foreach_ | STC.manifest;\n-                static if(isStatic) var.storage_class |= STC.local;\n-                static if(!isDecl)\n-                {\n-                    st.push(new ExpStatement(loc, var));\n-                }\n-                else\n-                {\n-                    st.push(var);\n-                }\n-                p = (*fs.parameters)[1]; // value\n-            }\n-            /***********************\n-             * Declares a unrolled `foreach` loop variable or a `static foreach` variable.\n-             *\n-             * Params:\n-             *     storageClass = The storage class of the variable.\n-             *     type = The declared type of the variable.\n-             *     ident = The name of the variable.\n-             *     e = The initializer of the variable (i.e. the current element of the looped over aggregate).\n-             *     t = The type of the initializer.\n-             * Returns:\n-             *     `true` iff the declaration was successful.\n-             */\n-            bool declareVariable(StorageClass storageClass, Type type, Identifier ident, Expression e, Type t)\n-            {\n-                if (storageClass & (STC.out_ | STC.lazy_) ||\n-                    storageClass & STC.ref_ && !te)\n-                {\n-                    fs.error(\"no storage class for value `%s`\", ident.toChars());\n-                    setError();\n-                    return false;\n-                }\n-                Declaration var;\n-                if (e)\n-                {\n-                    Type tb = e.type.toBasetype();\n-                    Dsymbol ds = null;\n-                    if (!(storageClass & STC.manifest))\n-                    {\n-                        if ((isStatic || tb.ty == Tfunction || storageClass&STC.alias_) && e.op == TOK.variable)\n-                            ds = (cast(VarExp)e).var;\n-                        else if (e.op == TOK.template_)\n-                            ds = (cast(TemplateExp)e).td;\n-                        else if (e.op == TOK.scope_)\n-                            ds = (cast(ScopeExp)e).sds;\n-                        else if (e.op == TOK.function_)\n-                        {\n-                            auto fe = cast(FuncExp)e;\n-                            ds = fe.td ? cast(Dsymbol)fe.td : fe.fd;\n-                        }\n-                        else if (e.op == TOK.overloadSet)\n-                            ds = (cast(OverExp)e).vars;\n-                    }\n-                    else if (storageClass & STC.alias_)\n-                    {\n-                        fs.error(\"`foreach` loop variable cannot be both `enum` and `alias`\");\n-                        setError();\n-                        return false;\n-                    }\n-\n-                    if (ds)\n-                    {\n-                        var = new AliasDeclaration(loc, ident, ds);\n-                        if (storageClass & STC.ref_)\n-                        {\n-                            fs.error(\"symbol `%s` cannot be `ref`\", ds.toChars());\n-                            setError();\n-                            return false;\n-                        }\n-                        if (paramtype)\n-                        {\n-                            fs.error(\"cannot specify element type for symbol `%s`\", ds.toChars());\n-                            setError();\n-                            return false;\n-                        }\n-                    }\n-                    else if (e.op == TOK.type)\n-                    {\n-                        var = new AliasDeclaration(loc, ident, e.type);\n-                        if (paramtype)\n-                        {\n-                            fs.error(\"cannot specify element type for type `%s`\", e.type.toChars());\n-                            setError();\n-                            return false;\n-                        }\n-                    }\n-                    else\n-                    {\n-                        e = resolveProperties(sc, e);\n-                        Initializer ie = new ExpInitializer(Loc.initial, e);\n-                        auto v = new VarDeclaration(loc, type, ident, ie, storageClass);\n-                        v.storage_class |= STC.foreach_;\n-                        if (storageClass & STC.ref_)\n-                            v.storage_class |= STC.ref_;\n-                        if (isStatic || storageClass&STC.manifest || e.isConst() ||\n-                            e.op == TOK.string_ ||\n-                            e.op == TOK.structLiteral ||\n-                            e.op == TOK.arrayLiteral)\n-                        {\n-                            if (v.storage_class & STC.ref_)\n-                            {\n-                                static if (!isStatic)\n-                                {\n-                                    fs.error(\"constant value `%s` cannot be `ref`\", ie.toChars());\n-                                }\n-                                else\n-                                {\n-                                    if (!needExpansion)\n-                                    {\n-                                        fs.error(\"constant value `%s` cannot be `ref`\", ie.toChars());\n-                                    }\n-                                    else\n-                                    {\n-                                        fs.error(\"constant value `%s` cannot be `ref`\", ident.toChars());\n-                                    }\n-                                }\n-                                setError();\n-                                return false;\n-                            }\n-                            else\n-                                v.storage_class |= STC.manifest;\n-                        }\n-                        var = v;\n-                    }\n-                }\n-                else\n-                {\n-                    var = new AliasDeclaration(loc, ident, t);\n-                    if (paramtype)\n-                    {\n-                        fs.error(\"cannot specify element type for symbol `%s`\", fs.toChars());\n-                        setError();\n-                        return false;\n-                    }\n-                }\n-                static if (isStatic)\n-                {\n-                    var.storage_class |= STC.local;\n-                }\n-                static if (!isDecl)\n-                {\n-                    st.push(new ExpStatement(loc, var));\n-                }\n-                else\n-                {\n-                    st.push(var);\n-                }\n-                return true;\n-            }\n-            static if (!isStatic)\n-            {\n-                // Declare value\n-                if (!declareVariable(p.storageClass, p.type, p.ident, e, t))\n-                {\n-                    return returnEarly();\n-                }\n-            }\n-            else\n-            {\n-                if (!needExpansion)\n-                {\n-                    // Declare value\n-                    if (!declareVariable(p.storageClass, p.type, p.ident, e, t))\n-                    {\n-                        return returnEarly();\n-                    }\n-                }\n-                else\n-                { // expand tuples into multiple `static foreach` variables.\n-                    assert(e && !t);\n-                    auto ident = Identifier.generateId(\"__value\");\n-                    declareVariable(0, e.type, ident, e, null);\n-                    import dmd.cond: StaticForeach;\n-                    auto field = Identifier.idPool(StaticForeach.tupleFieldName.ptr,StaticForeach.tupleFieldName.length);\n-                    Expression access = new DotIdExp(loc, e, field);\n-                    access = expressionSemantic(access, sc);\n-                    if (!tuple) return returnEarly();\n-                    //printf(\"%s\\n\",tuple.toChars());\n-                    foreach (l; 0 .. dim)\n-                    {\n-                        auto cp = (*fs.parameters)[l];\n-                        Expression init_ = new IndexExp(loc, access, new IntegerExp(loc, l, Type.tsize_t));\n-                        init_ = init_.expressionSemantic(sc);\n-                        assert(init_.type);\n-                        declareVariable(p.storageClass, init_.type, cp.ident, init_, null);\n-                    }\n-                }\n-            }\n-\n-            static if (!isDecl)\n-            {\n-                if (fs._body) // https://issues.dlang.org/show_bug.cgi?id=17646\n-                    st.push(fs._body.syntaxCopy());\n-                Statement res = new CompoundStatement(loc, st);\n-            }\n-            else\n-            {\n-                st.append(Dsymbol.arraySyntaxCopy(dbody));\n-            }\n-            static if (!isStatic)\n-            {\n-                res = new ScopeStatement(loc, res, fs.endloc);\n-            }\n-            else static if (!isDecl)\n-            {\n-                auto fwd = new ForwardingStatement(loc, res);\n-                res = fwd;\n-            }\n-            else\n-            {\n-                import dmd.attrib: ForwardingAttribDeclaration;\n-                auto res = new ForwardingAttribDeclaration(st);\n-            }\n-            static if (!isDecl)\n-            {\n-                statements.push(res);\n-            }\n-            else\n-            {\n-                declarations.push(res);\n-            }\n-        }\n-\n-        static if (!isStatic)\n-        {\n-            Statement res = new UnrolledLoopStatement(loc, statements);\n-            if (LabelStatement ls = checkLabeledLoop(sc, fs))\n-                ls.gotoTarget = res;\n-            if (te && te.e0)\n-                res = new CompoundStatement(loc, new ExpStatement(te.e0.loc, te.e0), res);\n-            result.statement = res;\n-        }\n-        else static if (!isDecl)\n-        {\n-            result.statement = new CompoundStatement(loc, statements);\n-        }\n-        else\n-        {\n-            result.decl = declarations;\n-        }\n-        return result;\n-    }\n-\n     override void visit(ForeachStatement fs)\n     {\n         /* https://dlang.org/spec/statement.html#foreach-statement\n@@ -1090,12 +697,12 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n         fs.aggr = fs.aggr.expressionSemantic(sc);\n         fs.aggr = resolveProperties(sc, fs.aggr);\n         fs.aggr = fs.aggr.optimize(WANTvalue);\n-        if (fs.aggr.op == TOK.error)\n+        if (fs.aggr.op == EXP.error)\n             return setError();\n         Expression oaggr = fs.aggr;     // remember original for error messages\n         if (fs.aggr.type && fs.aggr.type.toBasetype().ty == Tstruct &&\n             (cast(TypeStruct)(fs.aggr.type.toBasetype())).sym.dtor &&\n-            fs.aggr.op != TOK.type && !fs.aggr.isLvalue())\n+            !fs.aggr.isTypeExp() && !fs.aggr.isLvalue())\n         {\n             // https://issues.dlang.org/show_bug.cgi?id=14653\n             // Extend the life of rvalue aggregate till the end of foreach.\n@@ -1178,7 +785,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n \n         if (tab.ty == Ttuple) // don't generate new scope for tuple loops\n         {\n-            Statement s = makeTupleForeach!(false,false)(fs, null, false).statement;\n+            Statement s = makeTupleForeach(sc, false, false, fs, null, false).statement;\n             if (vinit)\n                 s = new CompoundStatement(loc, new ExpStatement(loc, vinit), s);\n             result = s.statementSemantic(sc);\n@@ -1283,7 +890,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n             {\n                 e = new DeclarationExp(loc, vinit);\n                 e = e.expressionSemantic(sc2);\n-                if (e.op == TOK.error)\n+                if (e.op == EXP.error)\n                     return null;\n             }\n \n@@ -1421,7 +1028,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n                     if (var.storage_class & STC.ref_)\n                     {\n                         if (fs.aggr.checkModifiable(sc2, ModifyFlags.noError) == Modifiable.initialization)\n-                            var.storage_class |= STC.ctorinit;\n+                            var.setInCtorOnly = true;\n \n                         Type t = tab.nextOf();\n                         if (t.constConv(p.type) == MATCH.nomatch)\n@@ -1446,7 +1053,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n                 auto ie = new ExpInitializer(loc, new SliceExp(loc, fs.aggr, null, null));\n                 const valueIsRef = cast(bool) ((*fs.parameters)[dim - 1].storageClass & STC.ref_);\n                 VarDeclaration tmp;\n-                if (fs.aggr.op == TOK.arrayLiteral && !valueIsRef)\n+                if (fs.aggr.op == EXP.arrayLiteral && !valueIsRef)\n                 {\n                     auto ale = cast(ArrayLiteralExp)fs.aggr;\n                     size_t edim = ale.elements ? ale.elements.dim : 0;\n@@ -1456,7 +1063,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n                     // if telem has been specified explicitly,\n                     // converting array literal elements to telem might make it @nogc.\n                     fs.aggr = fs.aggr.implicitCastTo(sc, telem.sarrayOf(edim));\n-                    if (fs.aggr.op == TOK.error)\n+                    if (fs.aggr.op == EXP.error)\n                         return retError();\n \n                     // for (T[edim] tmp = a, ...)\n@@ -1498,12 +1105,12 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n                 if (fs.op == TOK.foreach_reverse_)\n                 {\n                     // key--\n-                    cond = new PostExp(TOK.minusMinus, loc, new VarExp(loc, fs.key));\n+                    cond = new PostExp(EXP.minusMinus, loc, new VarExp(loc, fs.key));\n                 }\n                 else\n                 {\n                     // key < tmp.length\n-                    cond = new CmpExp(TOK.lessThan, loc, new VarExp(loc, fs.key), tmp_length);\n+                    cond = new CmpExp(EXP.lessThan, loc, new VarExp(loc, fs.key), tmp_length);\n                 }\n \n                 Expression increment = null;\n@@ -1603,7 +1210,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n                  */\n                 VarDeclaration r;\n                 Statement _init;\n-                if (vinit && fs.aggr.op == TOK.variable && (cast(VarExp)fs.aggr).var == vinit)\n+                if (vinit && fs.aggr.op == EXP.variable && (cast(VarExp)fs.aggr).var == vinit)\n                 {\n                     r = vinit;\n                     _init = new ExpStatement(loc, vinit);\n@@ -1788,7 +1395,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n         ec = new DotIdExp(fs.loc, fs.aggr, sapply.ident);\n         ec = new CallExp(fs.loc, ec, flde);\n         ec = ec.expressionSemantic(sc2);\n-        if (ec.op == TOK.error)\n+        if (ec.op == EXP.error)\n             return null;\n         if (ec.type != Type.tint32)\n         {\n@@ -1805,15 +1412,15 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n         /* Call:\n          *      aggr(flde)\n          */\n-        if (fs.aggr.op == TOK.delegate_ && (cast(DelegateExp)fs.aggr).func.isNested() &&\n+        if (fs.aggr.op == EXP.delegate_ && (cast(DelegateExp)fs.aggr).func.isNested() &&\n             !(cast(DelegateExp)fs.aggr).func.needThis())\n         {\n             // https://issues.dlang.org/show_bug.cgi?id=3560\n             fs.aggr = (cast(DelegateExp)fs.aggr).e1;\n         }\n         ec = new CallExp(fs.loc, fs.aggr, flde);\n         ec = ec.expressionSemantic(sc2);\n-        if (ec.op == TOK.error)\n+        if (ec.op == EXP.error)\n             return null;\n         if (ec.type != Type.tint32)\n         {\n@@ -2063,7 +1670,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n         Expression flde = new FuncExp(fs.loc, fld);\n         flde = flde.expressionSemantic(sc);\n         fld.tookAddressOf = 0;\n-        if (flde.op == TOK.error)\n+        if (flde.op == EXP.error)\n             return null;\n         return cast(FuncExp)flde;\n     }\n@@ -2143,7 +1750,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n             }\n             fs.prm.type = fs.prm.type.addStorageClass(fs.prm.storageClass);\n         }\n-        if (fs.prm.type.ty == Terror || fs.lwr.op == TOK.error || fs.upr.op == TOK.error)\n+        if (fs.prm.type.ty == Terror || fs.lwr.op == EXP.error || fs.upr.op == EXP.error)\n         {\n             return setError();\n         }\n@@ -2187,29 +1794,29 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n         Expression cond;\n         if (fs.op == TOK.foreach_reverse_)\n         {\n-            cond = new PostExp(TOK.minusMinus, loc, new VarExp(loc, fs.key));\n+            cond = new PostExp(EXP.minusMinus, loc, new VarExp(loc, fs.key));\n             if (fs.prm.type.isscalar())\n             {\n                 // key-- > tmp\n-                cond = new CmpExp(TOK.greaterThan, loc, cond, new VarExp(loc, tmp));\n+                cond = new CmpExp(EXP.greaterThan, loc, cond, new VarExp(loc, tmp));\n             }\n             else\n             {\n                 // key-- != tmp\n-                cond = new EqualExp(TOK.notEqual, loc, cond, new VarExp(loc, tmp));\n+                cond = new EqualExp(EXP.notEqual, loc, cond, new VarExp(loc, tmp));\n             }\n         }\n         else\n         {\n             if (fs.prm.type.isscalar())\n             {\n                 // key < tmp\n-                cond = new CmpExp(TOK.lessThan, loc, new VarExp(loc, fs.key), new VarExp(loc, tmp));\n+                cond = new CmpExp(EXP.lessThan, loc, new VarExp(loc, fs.key), new VarExp(loc, tmp));\n             }\n             else\n             {\n                 // key != tmp\n-                cond = new EqualExp(TOK.notEqual, loc, new VarExp(loc, fs.key), new VarExp(loc, tmp));\n+                cond = new EqualExp(EXP.notEqual, loc, new VarExp(loc, fs.key), new VarExp(loc, tmp));\n             }\n         }\n \n@@ -2218,7 +1825,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n         {\n             // key += 1\n             //increment = new AddAssignExp(loc, new VarExp(loc, fs.key), IntegerExp.literal!1);\n-            increment = new PreExp(TOK.prePlusPlus, loc, new VarExp(loc, fs.key));\n+            increment = new PreExp(EXP.prePlusPlus, loc, new VarExp(loc, fs.key));\n         }\n         if ((fs.prm.storageClass & STC.ref_) && fs.prm.type.equals(fs.key.type))\n         {\n@@ -2300,7 +1907,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n         }\n         else\n         {\n-            if (ifs.condition.op == TOK.dotIdentifier)\n+            if (ifs.condition.op == EXP.dotIdentifier)\n                 (cast(DotIdExp)ifs.condition).noderef = true;\n \n             ifs.condition = ifs.condition.expressionSemantic(scd);\n@@ -2337,7 +1944,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n \n         ctorflow_then.freeFieldinit();          // free extra copy of the data\n \n-        if (ifs.condition.op == TOK.error ||\n+        if (ifs.condition.op == EXP.error ||\n             (ifs.ifbody && ifs.ifbody.isErrorStatement()) ||\n             (ifs.elsebody && ifs.elsebody.isErrorStatement()))\n         {\n@@ -2396,7 +2003,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n \n                     // pragma(msg) is allowed to contain types as well as expressions\n                     e = ctfeInterpretForPragmaMsg(e);\n-                    if (e.op == TOK.error)\n+                    if (e.op == EXP.error)\n                     {\n                         errorSupplemental(ps.loc, \"while evaluating `pragma(msg, %s)`\", arg.toChars());\n                         return setError();\n@@ -2506,9 +2113,10 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n                     return setError();\n                 }\n \n-                if (e.isBool(true))\n+                const opt = e.toBool();\n+                if (opt.hasValue(true))\n                     inlining = PINLINE.always;\n-                else if (e.isBool(false))\n+                else if (opt.hasValue(false))\n                     inlining = PINLINE.never;\n \n                     FuncDeclaration fd = sc.func;\n@@ -2565,7 +2173,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n \n         Type att = null;\n         TypeEnum te = null;\n-        while (ss.condition.op != TOK.error)\n+        while (!ss.condition.isErrorExp())\n         {\n             // preserve enum type for final switches\n             if (ss.condition.type.ty == Tenum)\n@@ -2581,7 +2189,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n                 break;\n             }\n             ss.condition = integralPromotions(ss.condition, sc);\n-            if (ss.condition.op != TOK.error && ss.condition.type.isintegral())\n+            if (!ss.condition.isErrorExp() && ss.condition.type.isintegral())\n                 break;\n \n             auto ad = isAggregate(ss.condition.type);\n@@ -2594,7 +2202,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n                 }\n             }\n \n-            if (ss.condition.op != TOK.error)\n+            if (!ss.condition.isErrorExp())\n             {\n                 ss.error(\"`%s` must be of integral or string type, it is a `%s`\",\n                     ss.condition.toChars(), ss.condition.type.toChars());\n@@ -2606,7 +2214,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n             ss.condition = ErrorExp.get();\n         ss.condition = ss.condition.optimize(WANTvalue);\n         ss.condition = checkGC(sc, ss.condition);\n-        if (ss.condition.op == TOK.error)\n+        if (ss.condition.op == EXP.error)\n             conditionError = true;\n \n         bool needswitcherror = false;\n@@ -2869,12 +2477,12 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n             Expression e = cs.exp;\n             // Remove all the casts the user and/or implicitCastTo may introduce\n             // otherwise we'd sometimes fail the check below.\n-            while (e.op == TOK.cast_)\n+            while (e.op == EXP.cast_)\n                 e = (cast(CastExp)e).e1;\n \n             /* This is where variables are allowed as case expressions.\n              */\n-            if (e.op == TOK.variable)\n+            if (e.op == EXP.variable)\n             {\n                 VarExp ve = cast(VarExp)e;\n                 VarDeclaration v = ve.var.isVarDeclaration();\n@@ -2924,7 +2532,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n \n             if (StringExp se = cs.exp.toStringExp())\n                 cs.exp = se;\n-            else if (cs.exp.op != TOK.int64 && cs.exp.op != TOK.error)\n+            else if (!cs.exp.isIntegerExp() && !cs.exp.isErrorExp())\n             {\n                 cs.error(\"`case` must be a `string` or an integral constant, not `%s`\", cs.exp.toChars());\n                 errors = true;\n@@ -2982,7 +2590,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n             result = cs.statement;\n             return;\n         }\n-        if (errors || cs.exp.op == TOK.error)\n+        if (errors || cs.exp.op == EXP.error)\n             return setError();\n \n         cs.lastVar = sc.lastVar;\n@@ -3020,7 +2628,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n         crs.last = crs.last.implicitCastTo(sc, sw.condition.type);\n         crs.last = crs.last.ctfeInterpret();\n \n-        if (crs.first.op == TOK.error || crs.last.op == TOK.error || errors)\n+        if (crs.first.op == EXP.error || crs.last.op == EXP.error || errors)\n         {\n             if (crs.statement)\n                 crs.statement.statementSemantic(sc);\n@@ -3151,7 +2759,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n             gcs.exp = gcs.exp.expressionSemantic(sc);\n             gcs.exp = gcs.exp.implicitCastTo(sc, sc.sw.condition.type);\n             gcs.exp = gcs.exp.optimize(WANTvalue);\n-            if (gcs.exp.op == TOK.error)\n+            if (gcs.exp.op == EXP.error)\n                 return setError();\n         }\n \n@@ -3173,7 +2781,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n             TypeFunction tf = cast(TypeFunction)fd.type;\n         assert(tf.ty == Tfunction);\n \n-        if (rs.exp && rs.exp.op == TOK.variable && (cast(VarExp)rs.exp).var == fd.vresult)\n+        if (rs.exp && rs.exp.op == EXP.variable && (cast(VarExp)rs.exp).var == fd.vresult)\n         {\n             // return vresult;\n             if (sc.fes)\n@@ -3250,7 +2858,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n             rs.exp.checkSharedAccess(sc, returnSharedRef);\n \n             // for static alias this: https://issues.dlang.org/show_bug.cgi?id=17684\n-            if (rs.exp.op == TOK.type)\n+            if (rs.exp.op == EXP.type)\n                 rs.exp = resolveAliasThis(sc, rs.exp);\n \n             rs.exp = resolveProperties(sc, rs.exp);\n@@ -3266,7 +2874,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n \n             // Extract side-effect part\n             rs.exp = Expression.extractLast(rs.exp, e0);\n-            if (rs.exp.op == TOK.call)\n+            if (rs.exp.op == EXP.call)\n                 rs.exp = valueNoDtor(rs.exp);\n \n             if (e0)\n@@ -3322,7 +2930,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n                     else if (m1 && !m2)\n                     {\n                     }\n-                    else if (rs.exp.op != TOK.error)\n+                    else if (!rs.exp.isErrorExp())\n                     {\n                         rs.error(\"expected return type of `%s`, not `%s`:\",\n                                  tret.toChars(),\n@@ -3508,7 +3116,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n         }\n         if (e0)\n         {\n-            if (e0.op == TOK.declaration || e0.op == TOK.comma)\n+            if (e0.op == EXP.declaration || e0.op == EXP.comma)\n             {\n                 rs.exp = Expression.combine(e0, rs.exp);\n             }\n@@ -3702,7 +3310,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n             ss.exp = resolveProperties(sc, ss.exp);\n             ss.exp = ss.exp.optimize(WANTvalue);\n             ss.exp = checkGC(sc, ss.exp);\n-            if (ss.exp.op == TOK.error)\n+            if (ss.exp.op == EXP.error)\n             {\n                 if (ss._body)\n                     ss._body = ss._body.statementSemantic(sc);\n@@ -3826,15 +3434,15 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n         ws.exp = resolveProperties(sc, ws.exp);\n         ws.exp = ws.exp.optimize(WANTvalue);\n         ws.exp = checkGC(sc, ws.exp);\n-        if (ws.exp.op == TOK.error)\n+        if (ws.exp.op == EXP.error)\n             return setError();\n-        if (ws.exp.op == TOK.scope_)\n+        if (ws.exp.op == EXP.scope_)\n         {\n             sym = new WithScopeSymbol(ws);\n             sym.parent = sc.scopesym;\n             sym.endlinnum = ws.endloc.linnum;\n         }\n-        else if (ws.exp.op == TOK.type)\n+        else if (ws.exp.op == EXP.type)\n         {\n             Dsymbol s = (cast(TypeExp)ws.exp).type.toDsymbol(sc);\n             if (!s || !s.isScopeDsymbol())\n@@ -4133,7 +3741,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n         FuncDeclaration fd = sc.parent.isFuncDeclaration();\n         fd.hasReturnExp |= 2;\n \n-        if (ts.exp.op == TOK.new_)\n+        if (ts.exp.op == EXP.new_)\n         {\n             NewExp ne = cast(NewExp)ts.exp;\n             ne.thrownew = true;\n@@ -4142,7 +3750,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n         ts.exp = ts.exp.expressionSemantic(sc);\n         ts.exp = resolveProperties(sc, ts.exp);\n         ts.exp = checkGC(sc, ts.exp);\n-        if (ts.exp.op == TOK.error)\n+        if (ts.exp.op == EXP.error)\n             return setError();\n \n         checkThrowEscape(sc, ts.exp, false);\n@@ -4499,7 +4107,7 @@ Statement scopeCode(Statement statement, Scope* sc, out Statement sentry, out St\n {\n     if (auto es = statement.isExpStatement())\n     {\n-        if (es.exp && es.exp.op == TOK.declaration)\n+        if (es.exp && es.exp.op == EXP.declaration)\n         {\n             auto de = cast(DeclarationExp)es.exp;\n             auto v = de.declaration.isVarDeclaration();\n@@ -4565,15 +4173,373 @@ Statement scopeCode(Statement statement, Scope* sc, out Statement sentry, out St\n     return statement;\n }\n \n-\n /*******************\n- * See StatementSemanticVisitor.makeTupleForeach.  This is a simple\n- * wrapper that returns the generated statements/declarations.\n+ * Type check and unroll `foreach` over an expression tuple as well\n+ * as `static foreach` statements and `static foreach`\n+ * declarations. For `static foreach` statements and `static\n+ * foreach` declarations, the visitor interface is used (and the\n+ * result is written into the `result` field.) For `static\n+ * foreach` declarations, the resulting Dsymbols* are returned\n+ * directly.\n+ *\n+ * The unrolled body is wrapped into a\n+ *  - UnrolledLoopStatement, for `foreach` over an expression tuple.\n+ *  - ForwardingStatement, for `static foreach` statements.\n+ *  - ForwardingAttribDeclaration, for `static foreach` declarations.\n+ *\n+ * `static foreach` variables are declared as `STC.local`, such\n+ * that they are inserted into the local symbol tables of the\n+ * forwarding constructs instead of forwarded. For `static\n+ * foreach` with multiple foreach loop variables whose aggregate\n+ * has been lowered into a sequence of tuples, this function\n+ * expands the tuples into multiple `STC.local` `static foreach`\n+ * variables.\n  */\n-auto makeTupleForeach(bool isStatic, bool isDecl)(Scope* sc, ForeachStatement fs, Dsymbols* dbody, bool needExpansion)\n+public auto makeTupleForeach(Scope* sc, bool isStatic, bool isDecl, ForeachStatement fs, Dsymbols* dbody, bool needExpansion)\n {\n-    scope v = new StatementSemanticVisitor(sc);\n-    return v.makeTupleForeach!(isStatic, isDecl)(fs, dbody, needExpansion);\n+    // Voldemort return type\n+    union U\n+    {\n+        Statement statement;\n+        Dsymbols* decl;\n+    }\n+\n+    U result;\n+\n+    auto returnEarly()\n+    {\n+        if (isDecl)\n+            result.decl = null;\n+        else\n+            result.statement = new ErrorStatement();\n+        return result;\n+    }\n+\n+    auto loc = fs.loc;\n+    size_t dim = fs.parameters.dim;\n+    const bool skipCheck = isStatic && needExpansion;\n+    if (!skipCheck && (dim < 1 || dim > 2))\n+    {\n+        fs.error(\"only one (value) or two (key,value) arguments for tuple `foreach`\");\n+        return returnEarly();\n+    }\n+\n+    Type paramtype = (*fs.parameters)[dim - 1].type;\n+    if (paramtype)\n+    {\n+        paramtype = paramtype.typeSemantic(loc, sc);\n+        if (paramtype.ty == Terror)\n+        {\n+            return returnEarly();\n+        }\n+    }\n+\n+    Type tab = fs.aggr.type.toBasetype();\n+    TypeTuple tuple = cast(TypeTuple)tab;\n+\n+    Statements* statements;\n+    Dsymbols* declarations;\n+    if (isDecl)\n+        declarations = new Dsymbols();\n+    else\n+        statements = new Statements();\n+\n+    //printf(\"aggr: op = %d, %s\\n\", fs.aggr.op, fs.aggr.toChars());\n+    size_t n;\n+    TupleExp te = null;\n+    if (fs.aggr.op == EXP.tuple) // expression tuple\n+    {\n+        te = cast(TupleExp)fs.aggr;\n+        n = te.exps.dim;\n+    }\n+    else if (fs.aggr.op == EXP.type) // type tuple\n+    {\n+        n = Parameter.dim(tuple.arguments);\n+    }\n+    else\n+        assert(0);\n+    foreach (j; 0 .. n)\n+    {\n+        size_t k = (fs.op == TOK.foreach_) ? j : n - 1 - j;\n+        Expression e = null;\n+        Type t = null;\n+        if (te)\n+            e = (*te.exps)[k];\n+        else\n+            t = Parameter.getNth(tuple.arguments, k).type;\n+        Parameter p = (*fs.parameters)[0];\n+\n+        Statements* stmts;\n+        Dsymbols* decls;\n+        if (isDecl)\n+            decls = new Dsymbols();\n+        else\n+            stmts = new Statements();\n+\n+        const bool skip = isStatic && needExpansion;\n+        if (!skip && dim == 2)\n+        {\n+            // Declare key\n+            if (p.storageClass & (STC.out_ | STC.ref_ | STC.lazy_))\n+            {\n+                fs.error(\"no storage class for key `%s`\", p.ident.toChars());\n+                return returnEarly();\n+            }\n+\n+            if (isStatic)\n+            {\n+                if (!p.type)\n+                {\n+                    p.type = Type.tsize_t;\n+                }\n+            }\n+            p.type = p.type.typeSemantic(loc, sc);\n+\n+            if (!p.type.isintegral())\n+            {\n+                fs.error(\"foreach: key cannot be of non-integral type `%s`\",\n+                         p.type.toChars());\n+                return returnEarly();\n+            }\n+\n+            const length = te ? te.exps.length : tuple.arguments.length;\n+            IntRange dimrange = IntRange(SignExtendedNumber(length))._cast(Type.tsize_t);\n+            // https://issues.dlang.org/show_bug.cgi?id=12504\n+            dimrange.imax = SignExtendedNumber(dimrange.imax.value-1);\n+            if (!IntRange.fromType(p.type).contains(dimrange))\n+            {\n+                fs.error(\"index type `%s` cannot cover index range 0..%llu\",\n+                         p.type.toChars(), cast(ulong)length);\n+                return returnEarly();\n+            }\n+            Initializer ie = new ExpInitializer(Loc.initial, new IntegerExp(k));\n+            auto var = new VarDeclaration(loc, p.type, p.ident, ie);\n+            var.storage_class |= STC.foreach_ | STC.manifest;\n+            if (isStatic)\n+                var.storage_class |= STC.local;\n+\n+            if (isDecl)\n+                decls.push(var);\n+            else\n+                stmts.push(new ExpStatement(loc, var));\n+\n+            p = (*fs.parameters)[1]; // value\n+        }\n+        /***********************\n+         * Declares a unrolled `foreach` loop variable or a `static foreach` variable.\n+         *\n+         * Params:\n+         *     storageClass = The storage class of the variable.\n+         *     type = The declared type of the variable.\n+         *     ident = The name of the variable.\n+         *     e = The initializer of the variable (i.e. the current element of the looped over aggregate).\n+         *     t = The type of the initializer.\n+         * Returns:\n+         *     `true` iff the declaration was successful.\n+         */\n+        bool declareVariable(StorageClass storageClass, Type type, Identifier ident, Expression e, Type t)\n+        {\n+            if (storageClass & (STC.out_ | STC.lazy_) ||\n+                storageClass & STC.ref_ && !te)\n+            {\n+                fs.error(\"no storage class for value `%s`\", ident.toChars());\n+                return false;\n+            }\n+            Declaration var;\n+            if (e)\n+            {\n+                Type tb = e.type.toBasetype();\n+                Dsymbol ds = null;\n+                if (!(storageClass & STC.manifest))\n+                {\n+                    if ((isStatic || tb.ty == Tfunction || storageClass&STC.alias_) && e.op == EXP.variable)\n+                        ds = (cast(VarExp)e).var;\n+                    else if (e.op == EXP.template_)\n+                        ds = (cast(TemplateExp)e).td;\n+                    else if (e.op == EXP.scope_)\n+                        ds = (cast(ScopeExp)e).sds;\n+                    else if (e.op == EXP.function_)\n+                    {\n+                        auto fe = cast(FuncExp)e;\n+                        ds = fe.td ? cast(Dsymbol)fe.td : fe.fd;\n+                    }\n+                    else if (e.op == EXP.overloadSet)\n+                        ds = (cast(OverExp)e).vars;\n+                }\n+                else if (storageClass & STC.alias_)\n+                {\n+                    fs.error(\"`foreach` loop variable cannot be both `enum` and `alias`\");\n+                    return false;\n+                }\n+\n+                if (ds)\n+                {\n+                    var = new AliasDeclaration(loc, ident, ds);\n+                    if (storageClass & STC.ref_)\n+                    {\n+                        fs.error(\"symbol `%s` cannot be `ref`\", ds.toChars());\n+                        return false;\n+                    }\n+                    if (paramtype)\n+                    {\n+                        fs.error(\"cannot specify element type for symbol `%s`\", ds.toChars());\n+                        return false;\n+                    }\n+                }\n+                else if (e.op == EXP.type)\n+                {\n+                    var = new AliasDeclaration(loc, ident, e.type);\n+                    if (paramtype)\n+                    {\n+                        fs.error(\"cannot specify element type for type `%s`\", e.type.toChars());\n+                        return false;\n+                    }\n+                }\n+                else\n+                {\n+                    e = resolveProperties(sc, e);\n+                    Initializer ie = new ExpInitializer(Loc.initial, e);\n+                    auto v = new VarDeclaration(loc, type, ident, ie, storageClass);\n+                    v.storage_class |= STC.foreach_;\n+                    if (storageClass & STC.ref_)\n+                        v.storage_class |= STC.ref_;\n+                    if (isStatic || storageClass&STC.manifest || e.isConst() ||\n+                        e.op == EXP.string_ ||\n+                        e.op == EXP.structLiteral ||\n+                        e.op == EXP.arrayLiteral)\n+                    {\n+                        if (v.storage_class & STC.ref_)\n+                        {\n+                            if (!isStatic)\n+                            {\n+                                fs.error(\"constant value `%s` cannot be `ref`\", ie.toChars());\n+                            }\n+                            else\n+                            {\n+                                if (!needExpansion)\n+                                {\n+                                    fs.error(\"constant value `%s` cannot be `ref`\", ie.toChars());\n+                                }\n+                                else\n+                                {\n+                                    fs.error(\"constant value `%s` cannot be `ref`\", ident.toChars());\n+                                }\n+                            }\n+                            return false;\n+                        }\n+                        else\n+                            v.storage_class |= STC.manifest;\n+                    }\n+                    var = v;\n+                }\n+            }\n+            else\n+            {\n+                var = new AliasDeclaration(loc, ident, t);\n+                if (paramtype)\n+                {\n+                    fs.error(\"cannot specify element type for symbol `%s`\", fs.toChars());\n+                    return false;\n+                }\n+            }\n+            if (isStatic)\n+            {\n+                var.storage_class |= STC.local;\n+            }\n+\n+            if (isDecl)\n+                decls.push(var);\n+            else\n+                stmts.push(new ExpStatement(loc, var));\n+            return true;\n+        }\n+\n+        if (!isStatic)\n+        {\n+            // Declare value\n+            if (!declareVariable(p.storageClass, p.type, p.ident, e, t))\n+            {\n+                return returnEarly();\n+            }\n+        }\n+        else\n+        {\n+            if (!needExpansion)\n+            {\n+                // Declare value\n+                if (!declareVariable(p.storageClass, p.type, p.ident, e, t))\n+                {\n+                    return returnEarly();\n+                }\n+            }\n+            else\n+            {   // expand tuples into multiple `static foreach` variables.\n+                assert(e && !t);\n+                auto ident = Identifier.generateId(\"__value\");\n+                declareVariable(0, e.type, ident, e, null);\n+                import dmd.cond: StaticForeach;\n+                auto field = Identifier.idPool(StaticForeach.tupleFieldName.ptr,StaticForeach.tupleFieldName.length);\n+                Expression access = new DotIdExp(loc, e, field);\n+                access = expressionSemantic(access, sc);\n+                if (!tuple) return returnEarly();\n+                //printf(\"%s\\n\",tuple.toChars());\n+                foreach (l; 0 .. dim)\n+                {\n+                    auto cp = (*fs.parameters)[l];\n+                    Expression init_ = new IndexExp(loc, access, new IntegerExp(loc, l, Type.tsize_t));\n+                    init_ = init_.expressionSemantic(sc);\n+                    assert(init_.type);\n+                    declareVariable(p.storageClass, init_.type, cp.ident, init_, null);\n+                }\n+            }\n+        }\n+\n+        Statement s;\n+        Dsymbol d;\n+        if (isDecl)\n+            decls.append(Dsymbol.arraySyntaxCopy(dbody));\n+        else\n+        {\n+            if (fs._body) // https://issues.dlang.org/show_bug.cgi?id=17646\n+                stmts.push(fs._body.syntaxCopy());\n+            s = new CompoundStatement(loc, stmts);\n+        }\n+\n+        if (!isStatic)\n+        {\n+            s = new ScopeStatement(loc, s, fs.endloc);\n+        }\n+        else if (isDecl)\n+        {\n+            import dmd.attrib: ForwardingAttribDeclaration;\n+            d = new ForwardingAttribDeclaration(decls);\n+        }\n+        else\n+        {\n+            s = new ForwardingStatement(loc, s);\n+        }\n+\n+        if (isDecl)\n+            declarations.push(d);\n+        else\n+            statements.push(s);\n+    }\n+\n+    if (!isStatic)\n+    {\n+        Statement res = new UnrolledLoopStatement(loc, statements);\n+        if (LabelStatement ls = checkLabeledLoop(sc, fs))\n+            ls.gotoTarget = res;\n+        if (te && te.e0)\n+            res = new CompoundStatement(loc, new ExpStatement(te.e0.loc, te.e0), res);\n+        result.statement = res;\n+    }\n+    else if (isDecl)\n+        result.decl = declarations;\n+    else\n+        result.statement = new CompoundStatement(loc, statements);\n+\n+    return result;\n }\n \n /*********************************\n@@ -4611,16 +4577,16 @@ private Statements* flatten(Statement statement, Scope* sc)\n              * expand template mixin in statement scope\n              * to handle variable destructors.\n              */\n-            if (!es.exp || es.exp.op != TOK.declaration)\n+            if (!es.exp || !es.exp.isDeclarationExp())\n                 return null;\n \n-            Dsymbol d = (cast(DeclarationExp)es.exp).declaration;\n+            Dsymbol d = es.exp.isDeclarationExp().declaration;\n             auto tm = d.isTemplateMixin();\n             if (!tm)\n                 return null;\n \n             Expression e = es.exp.expressionSemantic(sc);\n-            if (e.op == TOK.error || tm.errors)\n+            if (e.op == EXP.error || tm.errors)\n                 return errorStatements();\n             assert(tm.members);\n \n@@ -4697,7 +4663,7 @@ private Statements* flatten(Statement statement, Scope* sc)\n             sfs.sfe.prepare(sc);\n             if (sfs.sfe.ready())\n             {\n-                Statement s = makeTupleForeach!(true, false)(sc, sfs.sfe.aggrfe, null, sfs.sfe.needExpansion).statement;\n+                Statement s = makeTupleForeach(sc, true, false, sfs.sfe.aggrfe, null, sfs.sfe.needExpansion).statement;\n                 auto result = s.flatten(sc);\n                 if (result)\n                 {"}, {"sha": "6d74ad29a5a471d279e37544b944155bb6ef8e09", "filename": "gcc/d/dmd/staticcond.d", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fstaticcond.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Fstaticcond.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstaticcond.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -48,19 +48,19 @@ bool evalStaticCondition(Scope* sc, Expression original, Expression e, out bool\n \n     bool impl(Expression e)\n     {\n-        if (e.op == TOK.not)\n+        if (e.isNotExp())\n         {\n             NotExp ne = cast(NotExp)e;\n             return !impl(ne.e1);\n         }\n \n-        if (e.op == TOK.andAnd || e.op == TOK.orOr)\n+        if (e.op == EXP.andAnd || e.op == EXP.orOr)\n         {\n             LogicalExp aae = cast(LogicalExp)e;\n             bool result = impl(aae.e1);\n             if (errors)\n                 return false;\n-            if (e.op == TOK.andAnd)\n+            if (e.op == EXP.andAnd)\n             {\n                 if (!result)\n                     return false;\n@@ -74,7 +74,7 @@ bool evalStaticCondition(Scope* sc, Expression original, Expression e, out bool\n             return !errors && result;\n         }\n \n-        if (e.op == TOK.question)\n+        if (e.op == EXP.question)\n         {\n             CondExp ce = cast(CondExp)e;\n             bool result = impl(ce.econd);\n@@ -99,7 +99,7 @@ bool evalStaticCondition(Scope* sc, Expression original, Expression e, out bool\n         e = e.optimize(WANTvalue);\n \n         if (nerrors != global.errors ||\n-            e.op == TOK.error ||\n+            e.isErrorExp() ||\n             e.type.toBasetype() == Type.terror)\n         {\n             errors = true;\n@@ -108,9 +108,10 @@ bool evalStaticCondition(Scope* sc, Expression original, Expression e, out bool\n \n         e = e.ctfeInterpret();\n \n-        if (e.isBool(true))\n+        const opt = e.toBool();\n+        if (opt.hasValue(true))\n             return true;\n-        else if (e.isBool(false))\n+        else if (opt.hasValue(false))\n         {\n             if (negatives)\n                 negatives.push(before);\n@@ -171,27 +172,27 @@ private uint visualizeFull(Expression original, Expression instantiated,\n     // returns true if satisfied\n     bool impl(Expression orig, Expression e, bool inverted, bool orOperand, bool unreached)\n     {\n-        TOK op = orig.op;\n+        EXP op = orig.op;\n \n         // lower all 'not' to the bottom\n         // !(A && B) -> !A || !B\n         // !(A || B) -> !A && !B\n         if (inverted)\n         {\n-            if (op == TOK.andAnd)\n-                op = TOK.orOr;\n-            else if (op == TOK.orOr)\n-                op = TOK.andAnd;\n+            if (op == EXP.andAnd)\n+                op = EXP.orOr;\n+            else if (op == EXP.orOr)\n+                op = EXP.andAnd;\n         }\n \n-        if (op == TOK.not)\n+        if (op == EXP.not)\n         {\n             NotExp no = cast(NotExp)orig;\n             NotExp ne = cast(NotExp)e;\n             assert(ne);\n             return impl(no.e1, ne.e1, !inverted, orOperand, unreached);\n         }\n-        else if (op == TOK.andAnd)\n+        else if (op == EXP.andAnd)\n         {\n             BinExp bo = cast(BinExp)orig;\n             BinExp be = cast(BinExp)e;\n@@ -200,7 +201,7 @@ private uint visualizeFull(Expression original, Expression instantiated,\n             const r2 = impl(bo.e2, be.e2, inverted, false, unreached || !r1);\n             return r1 && r2;\n         }\n-        else if (op == TOK.orOr)\n+        else if (op == EXP.orOr)\n         {\n             if (!orOperand) // do not indent A || B || C twice\n                 indent++;\n@@ -214,7 +215,7 @@ private uint visualizeFull(Expression original, Expression instantiated,\n                 indent--;\n             return r1 || r2;\n         }\n-        else if (op == TOK.question)\n+        else if (op == EXP.question)\n         {\n             CondExp co = cast(CondExp)orig;\n             CondExp ce = cast(CondExp)e;\n@@ -308,24 +309,24 @@ private uint visualizeShort(Expression original, Expression instantiated,\n \n     bool impl(Expression orig, Expression e, bool inverted)\n     {\n-        TOK op = orig.op;\n+        EXP op = orig.op;\n \n         if (inverted)\n         {\n-            if (op == TOK.andAnd)\n-                op = TOK.orOr;\n-            else if (op == TOK.orOr)\n-                op = TOK.andAnd;\n+            if (op == EXP.andAnd)\n+                op = EXP.orOr;\n+            else if (op == EXP.orOr)\n+                op = EXP.andAnd;\n         }\n \n-        if (op == TOK.not)\n+        if (op == EXP.not)\n         {\n             NotExp no = cast(NotExp)orig;\n             NotExp ne = cast(NotExp)e;\n             assert(ne);\n             return impl(no.e1, ne.e1, !inverted);\n         }\n-        else if (op == TOK.andAnd)\n+        else if (op == EXP.andAnd)\n         {\n             BinExp bo = cast(BinExp)orig;\n             BinExp be = cast(BinExp)e;\n@@ -334,7 +335,7 @@ private uint visualizeShort(Expression original, Expression instantiated,\n             r = r && impl(bo.e2, be.e2, inverted);\n             return r;\n         }\n-        else if (op == TOK.orOr)\n+        else if (op == EXP.orOr)\n         {\n             BinExp bo = cast(BinExp)orig;\n             BinExp be = cast(BinExp)e;\n@@ -346,7 +347,7 @@ private uint visualizeShort(Expression original, Expression instantiated,\n                 stack.setDim(lbefore); // purge added positive items\n             return r;\n         }\n-        else if (op == TOK.question)\n+        else if (op == EXP.question)\n         {\n             CondExp co = cast(CondExp)orig;\n             CondExp ce = cast(CondExp)e;"}, {"sha": "7a875a5d66315b6daeb73a9fa31337f8ec143ac0", "filename": "gcc/d/dmd/target.d", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Ftarget.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Ftarget.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftarget.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -27,7 +27,7 @@ module dmd.target;\n \n import dmd.globals : Param;\n \n-enum CPU\n+enum CPU : ubyte\n {\n     x87,\n     mmx,\n@@ -66,6 +66,7 @@ extern (C++) struct Target\n     import dmd.mtype : Type, TypeFunction, TypeTuple;\n     import dmd.root.ctfloat : real_t;\n     import dmd.statement : Statement;\n+    import dmd.tokens : EXP;\n \n     /// Bit decoding of the Target.OS\n     enum OS : ubyte\n@@ -213,7 +214,7 @@ extern (C++) struct Target\n      * Returns:\n      *      true if the operation is supported or type is not a vector\n      */\n-    extern (C++) bool isVectorOpSupported(Type type, uint op, Type t2 = null);\n+    extern (C++) bool isVectorOpSupported(Type type, EXP op, Type t2 = null);\n \n     /**\n      * Default system linkage for the target."}, {"sha": "13636932078191179d64020a8eb7e4142b44ab7a", "filename": "gcc/d/dmd/target.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftarget.h?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -26,7 +26,7 @@ class Type;\n class TypeTuple;\n class TypeFunction;\n \n-enum class CPU\n+enum class CPU : unsigned char\n {\n     x87,\n     mmx,\n@@ -194,7 +194,7 @@ struct Target\n     unsigned fieldalign(Type *type);\n     Type *va_listType(const Loc &loc, Scope *sc);  // get type of va_list\n     int isVectorTypeSupported(int sz, Type *type);\n-    bool isVectorOpSupported(Type *type, unsigned op, Type *t2 = NULL);\n+    bool isVectorOpSupported(Type *type, EXP op, Type *t2 = NULL);\n     // ABI and backend.\n     LINK systemLinkage();\n     TypeTuple *toArgTypes(Type *t);"}, {"sha": "b462742485675a8b556c3d4a8227a5cd726b5b44", "filename": "gcc/d/dmd/templateparamsem.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Ftemplateparamsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Ftemplateparamsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftemplateparamsem.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -87,8 +87,8 @@ private extern (C++) final class TemplateParameterSemanticVisitor : Visitor\n                 sc = sc.endCTFE();\n                 e = e.implicitCastTo(sc, tvp.valType);\n                 e = e.ctfeInterpret();\n-                if (e.op == TOK.int64 || e.op == TOK.float64 ||\n-                    e.op == TOK.complex80 || e.op == TOK.null_ || e.op == TOK.string_)\n+                if (e.op == EXP.int64 || e.op == EXP.float64 ||\n+                    e.op == EXP.complex80 || e.op == EXP.null_ || e.op == EXP.string_)\n                     tvp.specValue = e;\n             }\n \n@@ -100,7 +100,7 @@ private extern (C++) final class TemplateParameterSemanticVisitor : Visitor\n                 sc = sc.endCTFE();\n                 e = e.implicitCastTo(sc, tvp.valType);\n                 e = e.ctfeInterpret();\n-                if (e.op == TOK.int64)\n+                if (e.op == EXP.int64)\n                     tvp.defaultValue = e;\n             }\n         }"}, {"sha": "2609af56ac0082430cde77cba4d803ba14b4dea9", "filename": "gcc/d/dmd/tokens.d", "status": "modified", "additions": 158, "deletions": 2, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Ftokens.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Ftokens.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftokens.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -318,6 +318,157 @@ enum TOK : ushort\n     __attribute__,\n }\n \n+/// Expression nodes\n+enum EXP : ubyte\n+{\n+    reserved,\n+\n+    // Other\n+    negate,\n+    cast_,\n+    null_,\n+    assert_,\n+    true_,\n+    false_,\n+    array,\n+    call,\n+    address,\n+    type,\n+    throw_,\n+    new_,\n+    delete_,\n+    star,\n+    symbolOffset,\n+    variable,\n+    dotVariable,\n+    dotIdentifier,\n+    dotTemplateInstance,\n+    dotType,\n+    slice,\n+    arrayLength,\n+    version_,\n+    dollar,\n+    template_,\n+    dotTemplateDeclaration,\n+    declaration,\n+    typeof_,\n+    pragma_,\n+    dSymbol,\n+    typeid_,\n+    uadd,\n+    remove,\n+    newAnonymousClass,\n+    arrayLiteral,\n+    assocArrayLiteral,\n+    structLiteral,\n+    classReference,\n+    thrownException,\n+    delegatePointer,\n+    delegateFunctionPointer,\n+\n+    // Operators\n+    lessThan,\n+    greaterThan,\n+    lessOrEqual,\n+    greaterOrEqual,\n+    equal,\n+    notEqual,\n+    identity,\n+    notIdentity,\n+    index,\n+    is_,\n+\n+    leftShift,\n+    rightShift,\n+    leftShiftAssign,\n+    rightShiftAssign,\n+    unsignedRightShift,\n+    unsignedRightShiftAssign,\n+    concatenate,\n+    concatenateAssign, // ~=\n+    concatenateElemAssign,\n+    concatenateDcharAssign,\n+    add,\n+    min,\n+    addAssign,\n+    minAssign,\n+    mul,\n+    div,\n+    mod,\n+    mulAssign,\n+    divAssign,\n+    modAssign,\n+    and,\n+    or,\n+    xor,\n+    andAssign,\n+    orAssign,\n+    xorAssign,\n+    assign,\n+    not,\n+    tilde,\n+    plusPlus,\n+    minusMinus,\n+    construct,\n+    blit,\n+    dot,\n+    comma,\n+    question,\n+    andAnd,\n+    orOr,\n+    prePlusPlus,\n+    preMinusMinus,\n+\n+    // Leaf operators\n+    identifier,\n+    string_,\n+    this_,\n+    super_,\n+    halt,\n+    tuple,\n+    error,\n+\n+    // Basic types\n+    void_,\n+    int64,\n+    float64,\n+    complex80,\n+    char_,\n+    import_,\n+    delegate_,\n+    function_,\n+    mixin_,\n+    in_,\n+    default_,\n+    break_,\n+    continue_,\n+    goto_,\n+    scope_,\n+\n+    traits,\n+    overloadSet,\n+    line,\n+    file,\n+    fileFullPath,\n+    moduleString,   // __MODULE__\n+    functionString, // __FUNCTION__\n+    prettyFunction, // __PRETTY_FUNCTION__\n+    shared_,\n+    pow,\n+    powAssign,\n+    vector,\n+\n+    voidExpression,\n+    cantExpression,\n+    showCtfeContext,\n+    objcClassReference,\n+    vectorArray,\n+    arrow,      // ->\n+    compoundLiteral, // ( type-name ) { initializer-list }\n+    _Generic,\n+    interval,\n+}\n+\n enum FirstCKeyword = TOK.inline;\n \n // Assert that all token enum members have consecutive values and\n@@ -1009,12 +1160,17 @@ nothrow:\n         return p;\n     }\n \n-    static const(char)* toChars(uint value)\n+    static const(char)* toChars(TOK value)\n     {\n         return toString(value).ptr;\n     }\n \n-    extern (D) static string toString(uint value) pure nothrow @nogc @safe\n+    static const(char)* toChars(ushort value)\n+    {\n+        return toString(cast(TOK)value).ptr;\n+    }\n+\n+    extern (D) static string toString(TOK value) pure nothrow @nogc @safe\n     {\n         return tochars[value];\n     }"}, {"sha": "f3e4411217e626926ba8b8a78149909e4586ca3e", "filename": "gcc/d/dmd/tokens.h", "status": "modified", "additions": 447, "deletions": 181, "changes": 628, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Ftokens.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Ftokens.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftokens.h?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -32,187 +32,453 @@ class Identifier;\n         ?       &&      ||\n  */\n \n-typedef unsigned short TOK;\n-enum\n+enum class TOK : unsigned short\n {\n-        TOKreserved,\n-\n-        // Other\n-        TOKlparen,      TOKrparen,\n-        TOKlbracket,    TOKrbracket,\n-        TOKlcurly,      TOKrcurly,\n-        TOKcolon,       TOKneg,\n-        TOKsemicolon,   TOKdotdotdot,\n-        TOKeof,         TOKcast,\n-        TOKnull,        TOKassert,\n-        TOKtrue,        TOKfalse,\n-        TOKarray,       TOKcall,\n-        TOKaddress,\n-        TOKtype,        TOKthrow,\n-        TOKnew,         TOKdelete,\n-        TOKstar,        TOKsymoff,\n-        TOKvar,         TOKdotvar,\n-        TOKdotid,       TOKdotti,\n-        TOKdottype,     TOKslice,\n-        TOKarraylength, TOKversion,\n-        TOKmodule,      TOKdollar,\n-        TOKtemplate,    TOKdottd,\n-        TOKdeclaration, TOKtypeof,\n-        TOKpragma,      TOKdsymbol,\n-        TOKtypeid,      TOKuadd,\n-        TOKremove,\n-        TOKnewanonclass, TOKcomment,\n-        TOKarrayliteral, TOKassocarrayliteral,\n-        TOKstructliteral,\n-        TOKclassreference,\n-        TOKthrownexception,\n-        TOKdelegateptr,\n-        TOKdelegatefuncptr,\n-\n-// 54\n-        // Operators\n-        TOKlt,          TOKgt,\n-        TOKle,          TOKge,\n-        TOKequal,       TOKnotequal,\n-        TOKidentity,    TOKnotidentity,\n-        TOKindex,       TOKis,\n-\n-// 64\n-        TOKshl,         TOKshr,\n-        TOKshlass,      TOKshrass,\n-        TOKushr,        TOKushrass,\n-        TOKcat,         TOKcatass,      TOKcatelemass,  TOKcatdcharass,     // ~ ~=\n-        TOKadd,         TOKmin,         TOKaddass,      TOKminass,\n-        TOKmul,         TOKdiv,         TOKmod,\n-        TOKmulass,      TOKdivass,      TOKmodass,\n-        TOKand,         TOKor,          TOKxor,\n-        TOKandass,      TOKorass,       TOKxorass,\n-        TOKassign,      TOKnot,         TOKtilde,\n-        TOKplusplus,    TOKminusminus,  TOKconstruct,   TOKblit,\n-        TOKdot,         TOKcomma,\n-        TOKquestion,    TOKandand,      TOKoror,\n-        TOKpreplusplus, TOKpreminusminus,\n-\n-// 105\n-        // Numeric literals\n-        TOKint32v, TOKuns32v,\n-        TOKint64v, TOKuns64v,\n-        TOKint128v, TOKuns128v,\n-        TOKfloat32v, TOKfloat64v, TOKfloat80v,\n-        TOKimaginary32v, TOKimaginary64v, TOKimaginary80v,\n-\n-        // Char constants\n-        TOKcharv, TOKwcharv, TOKdcharv,\n-\n-        // Leaf operators\n-        TOKidentifier,  TOKstring, TOKxstring,\n-        TOKthis,        TOKsuper,\n-        TOKhalt,        TOKtuple,\n-        TOKerror,\n-\n-        // Basic types\n-        TOKvoid,\n-        TOKint8, TOKuns8,\n-        TOKint16, TOKuns16,\n-        TOKint32, TOKuns32,\n-        TOKint64, TOKuns64,\n-        TOKint128, TOKuns128,\n-        TOKfloat32, TOKfloat64, TOKfloat80,\n-        TOKimaginary32, TOKimaginary64, TOKimaginary80,\n-        TOKcomplex32, TOKcomplex64, TOKcomplex80,\n-        TOKchar, TOKwchar, TOKdchar, TOKbool,\n-\n-// 152\n-        // Aggregates\n-        TOKstruct, TOKclass, TOKinterface, TOKunion, TOKenum, TOKimport,\n-        TOKalias, TOKoverride, TOKdelegate, TOKfunction,\n-        TOKmixin,\n-\n-        TOKalign, TOKextern, TOKprivate, TOKprotected, TOKpublic, TOKexport,\n-        TOKstatic, TOKfinal, TOKconst, TOKabstract,\n-        TOKdebug, TOKdeprecated, TOKin, TOKout, TOKinout, TOKlazy,\n-        TOKauto, TOKpackage, TOKimmutable,\n-\n-// 182\n-        // Statements\n-        TOKif, TOKelse, TOKwhile, TOKfor, TOKdo, TOKswitch,\n-        TOKcase, TOKdefault, TOKbreak, TOKcontinue, TOKwith,\n-        TOKsynchronized, TOKreturn, TOKgoto, TOKtry, TOKcatch, TOKfinally,\n-        TOKasm, TOKforeach, TOKforeach_reverse,\n-        TOKscope,\n-        TOKon_scope_exit, TOKon_scope_failure, TOKon_scope_success,\n-\n-// 206\n-        // Contracts\n-        TOKinvariant,\n-\n-        // Testing\n-        TOKunittest,\n-\n-        // Added after 1.0\n-        TOKargTypes,\n-        TOKref,\n-        TOKmacro,\n-\n-// 211\n-        TOKparameters,\n-        TOKtraits,\n-        TOKoverloadset,\n-        TOKpure,\n-        TOKnothrow,\n-        TOKgshared,\n-        TOKline,\n-        TOKfile,\n-        TOKfilefullpath,\n-        TOKmodulestring,\n-        TOKfuncstring,\n-        TOKprettyfunc,\n-        TOKshared,\n-        TOKat,\n-        TOKpow,\n-        TOKpowass,\n-        TOKgoesto,\n-        TOKvector,\n-        TOKpound,\n-\n-// 230\n-        TOKinterval,\n-        TOKvoidexp,\n-        TOKcantexp,\n-        TOKshowctfecontext,\n-\n-        TOKobjc_class_reference,\n-        TOKvectorarray,\n-\n-        TOKarrow,\n-        TOKcolonColon,\n-        TOKwchar_tLiteral,\n-        TOKcompoundLiteral,\n-\n-        TOKinline,\n-        TOKregister,\n-        TOKrestrict,\n-        TOKsigned,\n-        TOKsizeof_,\n-        TOKtypedef_,\n-        TOKunsigned,\n-        TOKvolatile,\n-        TOK_Alignas,\n-        TOK_Alignof,\n-        TOK_Atomic,\n-        TOK_Bool,\n-        TOK_Complex,\n-        TOK_Generic,\n-        TOK_Imaginary,\n-        TOK_Noreturn,\n-        TOK_Static_assert,\n-        TOK_Thread_local,\n-\n-        TOK__cdecl,\n-        TOK__declspec,\n-        TOK__attribute__,\n-\n-        TOKMAX\n+    reserved,\n+\n+    // Other\n+    leftParenthesis,\n+    rightParenthesis,\n+    leftBracket,\n+    rightBracket,\n+    leftCurly,\n+    rightCurly,\n+    colon,\n+    negate,\n+    semicolon,\n+    dotDotDot,\n+    endOfFile,\n+    cast_,\n+    null_,\n+    assert_,\n+    true_,\n+    false_,\n+    array,\n+    call,\n+    address,\n+    type,\n+    throw_,\n+    new_,\n+    delete_,\n+    star,\n+    symbolOffset,\n+    variable,\n+    dotVariable,\n+    dotIdentifier,\n+    dotTemplateInstance,\n+    dotType,\n+    slice,\n+    arrayLength,\n+    version_,\n+    module_,\n+    dollar,\n+    template_,\n+    dotTemplateDeclaration,\n+    declaration,\n+    typeof_,\n+    pragma_,\n+    dSymbol,\n+    typeid_,\n+    uadd,\n+    remove,\n+    newAnonymousClass,\n+    comment,\n+    arrayLiteral,\n+    assocArrayLiteral,\n+    structLiteral,\n+    classReference,\n+    thrownException,\n+    delegatePointer,\n+    delegateFunctionPointer,\n+\n+    // Operators\n+    lessThan,       // 54\n+    greaterThan,\n+    lessOrEqual,\n+    greaterOrEqual,\n+    equal,\n+    notEqual,\n+    identity,\n+    notIdentity,\n+    index,\n+    is_,\n+\n+    leftShift,      // 64\n+    rightShift,\n+    leftShiftAssign,\n+    rightShiftAssign,\n+    unsignedRightShift,\n+    unsignedRightShiftAssign,\n+    concatenate,\n+    concatenateAssign, // ~=\n+    concatenateElemAssign,\n+    concatenateDcharAssign,\n+    add,\n+    min,\n+    addAssign,\n+    minAssign,\n+    mul,\n+    div,\n+    mod,\n+    mulAssign,\n+    divAssign,\n+    modAssign,\n+    and_,\n+    or_,\n+    xor_,\n+    andAssign,\n+    orAssign,\n+    xorAssign,\n+    assign,\n+    not_,\n+    tilde,\n+    plusPlus,\n+    minusMinus,\n+    construct,\n+    blit,\n+    dot,\n+    comma,\n+    question,\n+    andAnd,\n+    orOr,\n+    prePlusPlus,\n+    preMinusMinus,\n+\n+    // Numeric literals\n+    int32Literal,   // 104,\n+    uns32Literal,\n+    int64Literal,\n+    uns64Literal,\n+    int128Literal,\n+    uns128Literal,\n+    float32Literal,\n+    float64Literal,\n+    float80Literal,\n+    imaginary32Literal,\n+    imaginary64Literal,\n+    imaginary80Literal,\n+\n+    // Char constants\n+    charLiteral,    // 116,\n+    wcharLiteral,\n+    dcharLiteral,\n+\n+    // Leaf operators\n+    identifier,     // 119,\n+    string_,\n+    hexadecimalString,\n+    this_,\n+    super_,\n+    halt,\n+    tuple,\n+    error,\n+\n+    // Basic types\n+    void_,          // 127\n+    int8,\n+    uns8,\n+    int16,\n+    uns16,\n+    int32,\n+    uns32,\n+    int64,\n+    uns64,\n+    int128,\n+    uns128,\n+    float32,\n+    float64,\n+    float80,\n+    imaginary32,\n+    imaginary64,\n+    imaginary80,\n+    complex32,\n+    complex64,\n+    complex80,\n+    char_,\n+    wchar_,\n+    dchar_,\n+    bool_,\n+\n+    // Aggregates\n+    struct_,        // 151\n+    class_,\n+    interface_,\n+    union_,\n+    enum_,\n+    import_,\n+    alias_,\n+    override_,\n+    delegate_,\n+    function_,\n+    mixin_,\n+    align_,\n+    extern_,\n+    private_,\n+    protected_,\n+    public_,\n+    export_,\n+    static_,\n+    final_,\n+    const_,\n+    abstract_,\n+    debug_,\n+    deprecated_,\n+    in_,\n+    out_,\n+    inout_,\n+    lazy_,\n+    auto_,\n+    package_,\n+    immutable_,\n+\n+    // Statements\n+    if_,            // 181\n+    else_,\n+    while_,\n+    for_,\n+    do_,\n+    switch_,\n+    case_,\n+    default_,\n+    break_,\n+    continue_,\n+    with_,\n+    synchronized_,\n+    return_,\n+    goto_,\n+    try_,\n+    catch_,\n+    finally_,\n+    asm_,\n+    foreach_,\n+    foreach_reverse_,\n+    scope_,\n+    onScopeExit,\n+    onScopeFailure,\n+    onScopeSuccess,\n+\n+    // Contracts\n+    invariant_,     // 205\n+\n+    // Testing\n+    unittest_,\n+\n+    // Added after 1.0\n+    argumentTypes,\n+    ref_,\n+    macro_,\n+\n+    parameters,     // 210\n+    traits,\n+    overloadSet,\n+    pure_,\n+    nothrow_,\n+    gshared,\n+    line,\n+    file,\n+    fileFullPath,\n+    moduleString,   // __MODULE__\n+    functionString, // __FUNCTION__\n+    prettyFunction, // __PRETTY_FUNCTION__\n+    shared_,\n+    at,\n+    pow,\n+    powAssign,\n+    goesTo,\n+    vector,\n+    pound,\n+\n+    interval,       // 229\n+    voidExpression,\n+    cantExpression,\n+    showCtfeContext,\n+\n+    objcClassReference,\n+    vectorArray,\n+\n+    arrow,      // ->\n+    colonColon, // ::\n+    wchar_tLiteral,\n+    compoundLiteral, // ( type-name ) { initializer-list }\n+\n+    // C only keywords\n+    inline_,\n+    register_,\n+    restrict_,\n+    signed_,\n+    sizeof_,\n+    typedef_,\n+    unsigned_,\n+    volatile_,\n+    _Alignas_,\n+    _Alignof_,\n+    _Atomic_,\n+    _Bool_,\n+    _Complex_,\n+    _Generic_,\n+    _Imaginary_,\n+    _Noreturn_,\n+    _Static_assert_,\n+    _Thread_local_,\n+\n+    // C only extended keywords\n+    cdecl,\n+    declspec,\n+    attribute__,\n+\n+    MAX,\n+};\n+\n+enum class EXP : unsigned char\n+{\n+    reserved,\n+\n+    // Other\n+    negate,\n+    cast_,\n+    null_,\n+    assert_,\n+    true_,\n+    false_,\n+    array,\n+    call,\n+    address,\n+    type,\n+    throw_,\n+    new_,\n+    delete_,\n+    star,\n+    symbolOffset,\n+    variable,\n+    dotVariable,\n+    dotIdentifier,\n+    dotTemplateInstance,\n+    dotType,\n+    slice,\n+    arrayLength,\n+    version_,\n+    dollar,\n+    template_,\n+    dotTemplateDeclaration,\n+    declaration,\n+    typeof_,\n+    pragma_,\n+    dSymbol,\n+    typeid_,\n+    uadd,\n+    remove,\n+    newAnonymousClass,\n+    arrayLiteral,\n+    assocArrayLiteral,\n+    structLiteral,\n+    classReference,\n+    thrownException,\n+    delegatePointer,\n+    delegateFunctionPointer,\n+\n+    // Operators\n+    lessThan,\n+    greaterThan,\n+    lessOrEqual,\n+    greaterOrEqual,\n+    equal,\n+    notEqual,\n+    identity,\n+    notIdentity,\n+    index,\n+    is_,\n+\n+    leftShift,\n+    rightShift,\n+    leftShiftAssign,\n+    rightShiftAssign,\n+    unsignedRightShift,\n+    unsignedRightShiftAssign,\n+    concatenate,\n+    concatenateAssign, // ~=\n+    concatenateElemAssign,\n+    concatenateDcharAssign,\n+    add,\n+    min,\n+    addAssign,\n+    minAssign,\n+    mul,\n+    div,\n+    mod,\n+    mulAssign,\n+    divAssign,\n+    modAssign,\n+    and_,\n+    or_,\n+    xor_,\n+    andAssign,\n+    orAssign,\n+    xorAssign,\n+    assign,\n+    not_,\n+    tilde,\n+    plusPlus,\n+    minusMinus,\n+    construct,\n+    blit,\n+    dot,\n+    comma,\n+    question,\n+    andAnd,\n+    orOr,\n+    prePlusPlus,\n+    preMinusMinus,\n+\n+    // Leaf operators\n+    identifier,\n+    string_,\n+    this_,\n+    super_,\n+    halt,\n+    tuple,\n+    error,\n+\n+    // Basic types\n+    void_,\n+    int64,\n+    float64,\n+    complex80,\n+    char_,\n+    import_,\n+    delegate_,\n+    function_,\n+    mixin_,\n+    in_,\n+    default_,\n+    break_,\n+    continue_,\n+    goto_,\n+    scope_,\n+\n+    traits,\n+    overloadSet,\n+    line,\n+    file,\n+    fileFullPath,\n+    moduleString,   // __MODULE__\n+    functionString, // __FUNCTION__\n+    prettyFunction, // __PRETTY_FUNCTION__\n+    shared_,\n+    pow,\n+    powAssign,\n+    vector,\n+\n+    voidExpression,\n+    cantExpression,\n+    showCtfeContext,\n+    objcClassReference,\n+    vectorArray,\n+    arrow,      // ->\n+    compoundLiteral, // ( type-name ) { initializer-list }\n+    _Generic_,\n+    interval,\n+\n+    MAX\n };\n \n #define TOKwild TOKinout\n@@ -255,7 +521,7 @@ struct Token\n     int isKeyword();\n     const char *toChars() const;\n \n-    static const char *toChars(unsigned value);\n+    static const char *toChars(TOK value);\n };\n \n #if defined(__GNUC__)"}, {"sha": "7b9a8c8fdff24bd198fa75118943ca1c1c5b347f", "filename": "gcc/d/dmd/traits.d", "status": "modified", "additions": 31, "deletions": 10, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Ftraits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Ftraits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftraits.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -80,9 +80,9 @@ private Dsymbol getDsymbolWithoutExpCtx(RootObject oarg)\n {\n     if (auto e = isExpression(oarg))\n     {\n-        if (e.op == TOK.dotVariable)\n+        if (e.op == EXP.dotVariable)\n             return (cast(DotVarExp)e).var;\n-        if (e.op == TOK.dotTemplateDeclaration)\n+        if (e.op == EXP.dotTemplateDeclaration)\n             return (cast(DotTemplateExp)e).td;\n     }\n     return getDsymbol(oarg);\n@@ -569,7 +569,7 @@ Expression semanticTraits(TraitsExp e, Scope* sc)\n     {\n         if (global.params.vcomplex)\n         {\n-            if (isTypeX(t => t.iscomplex() || t.isimaginary()).isBool(true))\n+            if (isTypeX(t => t.iscomplex() || t.isimaginary()).toBool().hasValue(true))\n                 return True();\n         }\n         return isDsymX(t => t.isDeprecated());\n@@ -998,7 +998,7 @@ Expression semanticTraits(TraitsExp e, Scope* sc)\n                 e.error(\"`bool` expected as third argument of `__traits(getOverloads)`, not `%s` of type `%s`\", b.toChars(), b.type.toChars());\n                 return ErrorExp.get();\n             }\n-            includeTemplates = b.isBool(true);\n+            includeTemplates = b.toBool().hasValue(true);\n         }\n \n         StringExp se = ex.toStringExp();\n@@ -1055,7 +1055,7 @@ Expression semanticTraits(TraitsExp e, Scope* sc)\n         }\n         else if (e.ident == Id.getMember)\n         {\n-            if (ex.op == TOK.dotIdentifier)\n+            if (ex.op == EXP.dotIdentifier)\n                 // Prevent semantic() from replacing Symbol with its initializer\n                 (cast(DotIdExp)ex).wantsym = true;\n             ex = ex.expressionSemantic(scx);\n@@ -1085,7 +1085,7 @@ Expression semanticTraits(TraitsExp e, Scope* sc)\n             {\n                 if (dve.var.isFuncDeclaration() || dve.var.isOverDeclaration())\n                     f = dve.var;\n-                if (dve.e1.op == TOK.dotType || dve.e1.op == TOK.this_)\n+                if (dve.e1.op == EXP.dotType || dve.e1.op == EXP.this_)\n                     ex = null;\n                 else\n                     ex = dve.e1;\n@@ -1105,7 +1105,7 @@ Expression semanticTraits(TraitsExp e, Scope* sc)\n                 if (td && td.funcroot)\n                     f = td.funcroot;\n                 ex = null;\n-                if (dte.e1.op != TOK.dotType && dte.e1.op != TOK.this_)\n+                if (dte.e1.op != EXP.dotType && dte.e1.op != EXP.this_)\n                     ex = dte.e1;\n             }\n             bool[string] funcTypeHash;\n@@ -1290,7 +1290,7 @@ Expression semanticTraits(TraitsExp e, Scope* sc)\n                 Expression x = isExpression(o);\n                 Type t = isType(o);\n                 if (x)\n-                    printf(\"e = %s %s\\n\", Token.toChars(x.op), x.toChars());\n+                    printf(\"e = %s %s\\n\", EXPtoString(x.op).ptr, x.toChars());\n                 if (t)\n                     printf(\"t = %d %s\\n\", t.ty, t.toChars());\n             }\n@@ -1792,7 +1792,7 @@ Expression semanticTraits(TraitsExp e, Scope* sc)\n                         err |= tf.isnothrow && canThrow(ex, sc2.func, false);\n                     }\n                     ex = checkGC(sc2, ex);\n-                    if (ex.op == TOK.error)\n+                    if (ex.op == EXP.error)\n                         err = true;\n                 }\n             }\n@@ -1919,6 +1919,27 @@ Expression semanticTraits(TraitsExp e, Scope* sc)\n     {\n         return pointerBitmap(e);\n     }\n+    if (e.ident == Id.initSymbol)\n+    {\n+        if (dim != 1)\n+            return dimError(1);\n+\n+        auto o = (*e.args)[0];\n+        Type t = isType(o);\n+        AggregateDeclaration ad = t ? isAggregate(t) : null;\n+\n+        // Interfaces don't have an init symbol and hence cause linker errors\n+        if (!ad || ad.isInterfaceDeclaration())\n+        {\n+            e.error(\"struct / class type expected as argument to __traits(initSymbol) instead of `%s`\", o.toChars());\n+            return ErrorExp.get();\n+        }\n+\n+        Declaration d = new SymbolDeclaration(ad.loc, ad);\n+        d.type = Type.tvoid.arrayOf().constOf();\n+        d.storage_class |= STC.rvalue;\n+        return new VarExp(e.loc, d);\n+    }\n     if (e.ident == Id.isZeroInit)\n     {\n         if (dim != 1)\n@@ -2105,7 +2126,7 @@ private bool isSame(RootObject o1, RootObject o2, Scope* sc)\n         }\n         else if (auto ea = isExpression(oarg))\n         {\n-            if (ea.op == TOK.function_)\n+            if (ea.op == EXP.function_)\n             {\n                 if (auto fe = cast(FuncExp)ea)\n                     return fe.fd;"}, {"sha": "417d2c11af4900d2588e7f5dc8dd0674d91234ec", "filename": "gcc/d/dmd/typesem.d", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Ftypesem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fdmd%2Ftypesem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftypesem.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -153,7 +153,7 @@ private void resolveTupleIndex(const ref Loc loc, Scope* sc, Dsymbol s, out Expr\n \n     eindex = semanticLength(sc, tup, eindex);\n     eindex = eindex.ctfeInterpret();\n-    if (eindex.op == TOK.error)\n+    if (eindex.op == EXP.error)\n     {\n         pt = Type.terror;\n         return;\n@@ -386,7 +386,7 @@ private void resolveHelper(TypeQualified mt, const ref Loc loc, Scope* sc, Dsymb\n          *  enum a = 1; alias b = a;\n          *  template X(alias e){ alias v = e; }  alias x = X!(1);\n          *  struct S { int v; alias w = v; }\n-         *      // TypeIdentifier 'a', 'e', and 'v' should be TOK.variable,\n+         *      // TypeIdentifier 'a', 'e', and 'v' should be EXP.variable,\n          *      // because getDsymbol() need to work in AliasDeclaration::semantic().\n          */\n         if (!v.type ||\n@@ -602,7 +602,7 @@ Expression typeToExpression(Type t)\n  */\n Expression typeToExpressionHelper(TypeQualified t, Expression e, size_t i = 0)\n {\n-    //printf(\"toExpressionHelper(e = %s %s)\\n\", Token.toChars(e.op), e.toChars());\n+    //printf(\"toExpressionHelper(e = %s %s)\\n\", EXPtoString(e.op).ptr, e.toChars());\n     foreach (id; t.idents[i .. t.idents.dim])\n     {\n         //printf(\"\\t[%d] e: '%s', id: '%s'\\n\", i, e.toChars(), id.toChars());\n@@ -722,7 +722,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n         {\n             mtype.dim = semanticLength(sc, tup, mtype.dim);\n             mtype.dim = mtype.dim.ctfeInterpret();\n-            if (mtype.dim.op == TOK.error)\n+            if (mtype.dim.op == EXP.error)\n                 return error();\n \n             uinteger_t d = mtype.dim.toUInteger();\n@@ -758,7 +758,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n \n             mtype.dim = mtype.dim.optimize(WANTvalue);\n             mtype.dim = mtype.dim.ctfeInterpret();\n-            if (mtype.dim.op == TOK.error)\n+            if (mtype.dim.op == EXP.error)\n                 return error();\n \n             errors = global.errors;\n@@ -768,15 +768,15 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n \n             mtype.dim = mtype.dim.implicitCastTo(sc, Type.tsize_t);\n             mtype.dim = mtype.dim.optimize(WANTvalue);\n-            if (mtype.dim.op == TOK.error)\n+            if (mtype.dim.op == EXP.error)\n                 return error();\n \n             errors = global.errors;\n             dinteger_t d2 = mtype.dim.toInteger();\n             if (errors != global.errors)\n                 return error();\n \n-            if (mtype.dim.op == TOK.error)\n+            if (mtype.dim.op == EXP.error)\n                 return error();\n \n             Type overflowError()\n@@ -1273,7 +1273,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                 iz = iz.initializerSemantic(sc, fparam.type, INITnointerpret);\n                 e = iz.initializerToExpression();\n             }\n-            if (e.op == TOK.function_) // https://issues.dlang.org/show_bug.cgi?id=4820\n+            if (e.op == EXP.function_) // https://issues.dlang.org/show_bug.cgi?id=4820\n             {\n                 FuncExp fe = cast(FuncExp)e;\n                 // Replace function literal with a function symbol,\n@@ -1299,7 +1299,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                 e = e.toLvalue(sc, e);\n \n             fparam.defaultArg = e;\n-            return (e.op != TOK.error);\n+            return (e.op != EXP.error);\n         }\n \n         ubyte wildparams = 0;\n@@ -1707,7 +1707,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                     .error(loc, \"%s `%s` is used as a type\", s.kind, s.toPrettyChars);\n                 //assert(0);\n             }\n-            else if (e.op == TOK.variable) // special case: variable is used as a type\n+            else if (e.op == EXP.variable) // special case: variable is used as a type\n             {\n                 Dsymbol varDecl = mtype.toDsymbol(sc);\n                 const(Loc) varDeclLoc = varDecl.getLoc();\n@@ -1814,43 +1814,43 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n         {\n             switch (e.op)\n             {\n-            case TOK.dotVariable:\n+            case EXP.dotVariable:\n                 mtype.sym = (cast(DotVarExp)e).var;\n                 break;\n-            case TOK.variable:\n+            case EXP.variable:\n                 mtype.sym = (cast(VarExp)e).var;\n                 break;\n-            case TOK.function_:\n+            case EXP.function_:\n                 auto fe = cast(FuncExp)e;\n                 mtype.sym = fe.td ? fe.td : fe.fd;\n                 break;\n-            case TOK.dotTemplateDeclaration:\n+            case EXP.dotTemplateDeclaration:\n                 mtype.sym = (cast(DotTemplateExp)e).td;\n                 break;\n-            case TOK.dSymbol:\n+            case EXP.dSymbol:\n                 mtype.sym = (cast(DsymbolExp)e).s;\n                 break;\n-            case TOK.template_:\n+            case EXP.template_:\n                 mtype.sym = (cast(TemplateExp)e).td;\n                 break;\n-            case TOK.scope_:\n+            case EXP.scope_:\n                 mtype.sym = (cast(ScopeExp)e).sds;\n                 break;\n-            case TOK.tuple:\n+            case EXP.tuple:\n                 TupleExp te = e.toTupleExp();\n                 Objects* elems = new Objects(te.exps.dim);\n                 foreach (i; 0 .. elems.dim)\n                 {\n                     auto src = (*te.exps)[i];\n                     switch (src.op)\n                     {\n-                    case TOK.type:\n+                    case EXP.type:\n                         (*elems)[i] = (cast(TypeExp)src).type;\n                         break;\n-                    case TOK.dotType:\n+                    case EXP.dotType:\n                         (*elems)[i] = (cast(DotTypeExp)src).sym.isType();\n                         break;\n-                    case TOK.overloadSet:\n+                    case EXP.overloadSet:\n                         (*elems)[i] = (cast(OverExp)src).type;\n                         break;\n                     default:\n@@ -1863,13 +1863,13 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                 TupleDeclaration td = new TupleDeclaration(e.loc, Identifier.generateId(\"__aliastup\"), elems);\n                 mtype.sym = td;\n                 break;\n-            case TOK.dotType:\n+            case EXP.dotType:\n                 result = (cast(DotTypeExp)e).sym.isType();\n                 break;\n-            case TOK.type:\n+            case EXP.type:\n                 result = (cast(TypeExp)e).type;\n                 break;\n-            case TOK.overloadSet:\n+            case EXP.overloadSet:\n                 result = (cast(OverExp)e).type;\n                 break;\n             default:\n@@ -1979,7 +1979,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n         mtype.upr = semanticLength(sc, tbn, mtype.upr);\n         mtype.lwr = mtype.lwr.ctfeInterpret();\n         mtype.upr = mtype.upr.ctfeInterpret();\n-        if (mtype.lwr.op == TOK.error || mtype.upr.op == TOK.error)\n+        if (mtype.lwr.op == EXP.error || mtype.upr.op == EXP.error)\n             return error();\n \n         uinteger_t i1 = mtype.lwr.toUInteger();\n@@ -2861,7 +2861,7 @@ void resolve(Type mt, const ref Loc loc, Scope* sc, out Expression pe, out Type\n             {\n                 mt.dim = semanticLength(sc, tup, mt.dim);\n                 mt.dim = mt.dim.ctfeInterpret();\n-                if (mt.dim.op == TOK.error)\n+                if (mt.dim.op == EXP.error)\n                     return returnError();\n \n                 const d = mt.dim.toUInteger();\n@@ -2879,7 +2879,7 @@ void resolve(Type mt, const ref Loc loc, Scope* sc, out Expression pe, out Type\n                 if (o.dyncast() == DYNCAST.expression)\n                 {\n                     Expression e = cast(Expression)o;\n-                    if (e.op == TOK.dSymbol)\n+                    if (e.op == EXP.dSymbol)\n                         return returnSymbol((cast(DsymbolExp)e).s);\n                     else\n                         return returnExp(e);\n@@ -3124,16 +3124,16 @@ void resolve(Type mt, const ref Loc loc, Scope* sc, out Expression pe, out Type\n         exp2 = resolvePropertiesOnly(sc2, exp2);\n         sc2.pop();\n \n-        if (exp2.op == TOK.error)\n+        if (exp2.op == EXP.error)\n         {\n             if (!global.gag)\n                 mt.exp = exp2;\n             goto Lerr;\n         }\n         mt.exp = exp2;\n \n-        if (mt.exp.op == TOK.type ||\n-            mt.exp.op == TOK.scope_)\n+        if (mt.exp.op == EXP.type ||\n+            mt.exp.op == EXP.scope_)\n         {\n             if (mt.exp.checkType())\n                 goto Lerr;\n@@ -3145,8 +3145,8 @@ void resolve(Type mt, const ref Loc loc, Scope* sc, out Expression pe, out Type\n              * template functions.\n              */\n         }\n-        if (auto f = mt.exp.op == TOK.variable    ? (cast(   VarExp)mt.exp).var.isFuncDeclaration()\n-                   : mt.exp.op == TOK.dotVariable ? (cast(DotVarExp)mt.exp).var.isFuncDeclaration() : null)\n+        if (auto f = mt.exp.op == EXP.variable    ? (cast(   VarExp)mt.exp).var.isFuncDeclaration()\n+                   : mt.exp.op == EXP.dotVariable ? (cast(DotVarExp)mt.exp).var.isFuncDeclaration() : null)\n         {\n             // f might be a unittest declaration which is incomplete when compiled\n             // without -unittest. That causes a segfault in checkForwardRef, see\n@@ -3377,12 +3377,12 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n             printf(\"Type::dotExp(e = '%s', ident = '%s')\\n\", e.toChars(), ident.toChars());\n         }\n         Expression ex = e.lastComma();\n-        if (ex.op == TOK.dotVariable)\n+        if (ex.op == EXP.dotVariable)\n         {\n             DotVarExp dv = cast(DotVarExp)ex;\n             v = dv.var.isVarDeclaration();\n         }\n-        else if (ex.op == TOK.variable)\n+        else if (ex.op == EXP.variable)\n         {\n             VarExp ve = cast(VarExp)ex;\n             v = ve.var.isVarDeclaration();\n@@ -3552,9 +3552,9 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n         {\n             printf(\"TypeVector::dotExp(e = '%s', ident = '%s')\\n\", e.toChars(), ident.toChars());\n         }\n-        if (ident == Id.ptr && e.op == TOK.call)\n+        if (ident == Id.ptr && e.op == EXP.call)\n         {\n-            /* The trouble with TOK.call is the return ABI for float[4] is different from\n+            /* The trouble with EXP.call is the return ABI for float[4] is different from\n              * __vector(float[4]), and a type paint won't do.\n              */\n             e = new AddrExp(e.loc, e);\n@@ -3618,7 +3618,7 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n         }\n         else if (ident == Id.ptr)\n         {\n-            if (e.op == TOK.type)\n+            if (e.op == EXP.type)\n             {\n                 e.error(\"`%s` is not an expression\", e.toChars());\n                 return ErrorExp.get();\n@@ -3644,19 +3644,19 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n         {\n             printf(\"TypeDArray::dotExp(e = '%s', ident = '%s')\\n\", e.toChars(), ident.toChars());\n         }\n-        if (e.op == TOK.type && (ident == Id.length || ident == Id.ptr))\n+        if (e.op == EXP.type && (ident == Id.length || ident == Id.ptr))\n         {\n             e.error(\"`%s` is not an expression\", e.toChars());\n             return ErrorExp.get();\n         }\n         if (ident == Id.length)\n         {\n-            if (e.op == TOK.string_)\n+            if (e.op == EXP.string_)\n             {\n                 StringExp se = cast(StringExp)e;\n                 return new IntegerExp(se.loc, se.len, Type.tsize_t);\n             }\n-            if (e.op == TOK.null_)\n+            if (e.op == EXP.null_)\n             {\n                 return new IntegerExp(e.loc, 0, Type.tsize_t);\n             }\n@@ -3864,7 +3864,7 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n                 if (!gagError)\n                 {\n                     global.endGagging(errors);\n-                    if (exp && exp.op == TOK.error)\n+                    if (exp && exp.op == EXP.error)\n                         exp = null;\n                 }\n \n@@ -3886,7 +3886,7 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n         {\n             printf(\"TypeStruct::dotExp(e = '%s', ident = '%s')\\n\", e.toChars(), ident.toChars());\n         }\n-        assert(e.op != TOK.dot);\n+        assert(e.op != EXP.dot);\n \n         // https://issues.dlang.org/show_bug.cgi?id=14010\n         if (ident == Id._mangleof)\n@@ -3909,7 +3909,7 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n             }\n \n             Expression e0;\n-            Expression ev = e.op == TOK.type ? null : e;\n+            Expression ev = e.op == EXP.type ? null : e;\n             if (ev)\n                 ev = extractSideEffect(sc, \"__tup\", e0, ev);\n \n@@ -4003,7 +4003,7 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n         TemplateDeclaration td = s.isTemplateDeclaration();\n         if (td)\n         {\n-            if (e.op == TOK.type)\n+            if (e.op == EXP.type)\n                 e = new TemplateExp(e.loc, td);\n             else\n                 e = new DotTemplateExp(e.loc, e, td);\n@@ -4024,7 +4024,7 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n             s = ti.inst.toAlias();\n             if (!s.isTemplateInstance())\n                 goto L1;\n-            if (e.op == TOK.type)\n+            if (e.op == EXP.type)\n                 e = new ScopeExp(e.loc, ti);\n             else\n                 e = new DotExp(e.loc, e, new ScopeExp(e.loc, ti));\n@@ -4040,7 +4040,7 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n         if (o)\n         {\n             auto oe = new OverExp(e.loc, o);\n-            if (e.op == TOK.type)\n+            if (e.op == EXP.type)\n             {\n                 return oe;\n             }\n@@ -4054,7 +4054,7 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n             return ErrorExp.get();\n         }\n \n-        if (e.op == TOK.type)\n+        if (e.op == EXP.type)\n         {\n             /* It's:\n              *    Struct.d\n@@ -4084,7 +4084,7 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n             return ve;\n         }\n \n-        bool unreal = e.op == TOK.variable && (cast(VarExp)e).var.isField();\n+        bool unreal = e.op == EXP.variable && (cast(VarExp)e).var.isField();\n         if (d.isDataseg() || unreal && d.isField())\n         {\n             // (e, d)\n@@ -4146,7 +4146,7 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n         {\n             printf(\"TypeClass::dotExp(e = '%s', ident = '%s')\\n\", e.toChars(), ident.toChars());\n         }\n-        assert(e.op != TOK.dot);\n+        assert(e.op != EXP.dot);\n \n         // https://issues.dlang.org/show_bug.cgi?id=12543\n         if (ident == Id.__sizeof || ident == Id.__xalignof || ident == Id._mangleof)\n@@ -4167,7 +4167,7 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n             mt.sym.size(e.loc); // do semantic of type\n \n             Expression e0;\n-            Expression ev = e.op == TOK.type ? null : e;\n+            Expression ev = e.op == EXP.type ? null : e;\n             if (ev)\n                 ev = extractSideEffect(sc, \"__tup\", e0, ev);\n \n@@ -4207,7 +4207,7 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n             // See if it's a 'this' class or a base class\n             if (mt.sym.ident == ident)\n             {\n-                if (e.op == TOK.type)\n+                if (e.op == EXP.type)\n                 {\n                     return mt.Type.getProperty(sc, e.loc, ident, 0);\n                 }\n@@ -4217,7 +4217,7 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n             }\n             if (auto cbase = mt.sym.searchBase(ident))\n             {\n-                if (e.op == TOK.type)\n+                if (e.op == EXP.type)\n                 {\n                     return mt.Type.getProperty(sc, e.loc, ident, 0);\n                 }\n@@ -4238,7 +4238,7 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n                 }\n \n                 Type t = Type.typeinfoclass.type;\n-                if (e.op == TOK.type || e.op == TOK.dotType)\n+                if (e.op == EXP.type || e.op == EXP.dotType)\n                 {\n                     /* For type.classinfo, we know the classinfo\n                      * at compile time.\n@@ -4412,7 +4412,7 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n \n         Expression toTemplateExp(TemplateDeclaration td)\n         {\n-            if (e.op == TOK.type)\n+            if (e.op == EXP.type)\n                 e = new TemplateExp(e.loc, td);\n             else\n                 e = new DotTemplateExp(e.loc, e, td);\n@@ -4439,7 +4439,7 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n             s = ti.inst.toAlias();\n             if (!s.isTemplateInstance())\n                 goto L1;\n-            if (e.op == TOK.type)\n+            if (e.op == EXP.type)\n                 e = new ScopeExp(e.loc, ti);\n             else\n                 e = new DotExp(e.loc, e, new ScopeExp(e.loc, ti));\n@@ -4456,7 +4456,7 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n         if (o)\n         {\n             auto oe = new OverExp(e.loc, o);\n-            if (e.op == TOK.type)\n+            if (e.op == EXP.type)\n             {\n                 return oe;\n             }\n@@ -4470,7 +4470,7 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n             return ErrorExp.get();\n         }\n \n-        if (e.op == TOK.type)\n+        if (e.op == EXP.type)\n         {\n             /* It's:\n              *    Class.d\n@@ -4589,7 +4589,7 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n                 assert(0);\n         }\n \n-        bool unreal = e.op == TOK.variable && (cast(VarExp)e).var.isField();\n+        bool unreal = e.op == EXP.variable && (cast(VarExp)e).var.isField();\n         if (d.isDataseg() || unreal && d.isField())\n         {\n             // (e, d)\n@@ -4750,7 +4750,7 @@ extern (C++) Expression defaultInit(Type mt, const ref Loc loc)\n             Parameter p = (*mt.arguments)[i];\n             assert(p.type);\n             Expression e = p.type.defaultInitLiteral(loc);\n-            if (e.op == TOK.error)\n+            if (e.op == EXP.error)\n             {\n                 return e;\n             }\n@@ -4818,7 +4818,7 @@ private Expression getMaxMinValue(EnumDeclaration ed, const ref Loc loc, Identif\n \n     static Expression pvalToResult(Expression e, const ref Loc loc)\n     {\n-        if (e.op != TOK.error)\n+        if (e.op != EXP.error)\n         {\n             e = e.copy();\n             e.loc = loc;\n@@ -4902,12 +4902,12 @@ private Expression getMaxMinValue(EnumDeclaration ed, const ref Loc loc, Identif\n              *      maxval = e;\n              */\n             Expression e = em.value;\n-            Expression ec = new CmpExp(id == Id.max ? TOK.greaterThan : TOK.lessThan, em.loc, e, *pval);\n+            Expression ec = new CmpExp(id == Id.max ? EXP.greaterThan : EXP.lessThan, em.loc, e, *pval);\n             ed.inuse++;\n             ec = ec.expressionSemantic(em._scope);\n             ed.inuse--;\n             ec = ec.ctfeInterpret();\n-            if (ec.op == TOK.error)\n+            if (ec.op == EXP.error)\n             {\n                 ed.errors = true;\n                 continue;"}, {"sha": "f1c014dbc168861021220116892e75e6b0692c44", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 138, "deletions": 121, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -88,7 +88,7 @@ lvalue_p (Expression *e)\n   if (ce != NULL && ce->e1->isLvalue ())\n     return true;\n \n-  return (e->op != TOKslice && e->isLvalue ());\n+  return (e->op != EXP::slice && e->isLvalue ());\n }\n \n /* Build an expression of code CODE, data type TYPE, and operands ARG0 and\n@@ -162,7 +162,7 @@ binop_assignment (tree_code code, Expression *e1, Expression *e2)\n {\n   /* Skip casts for lhs assignment.  */\n   Expression *e1b = e1;\n-  while (e1b->op == TOKcast)\n+  while (e1b->op == EXP::cast_)\n     {\n       CastExp *ce = e1b->isCastExp ();\n       gcc_assert (same_type_p (ce->type, ce->to));\n@@ -264,7 +264,7 @@ class ExprVisitor : public Visitor\n \n   void visit (IdentityExp *e)\n   {\n-    tree_code code = (e->op == TOKidentity) ? EQ_EXPR : NE_EXPR;\n+    tree_code code = (e->op == EXP::identity) ? EQ_EXPR : NE_EXPR;\n     Type *tb1 = e->e1->type->toBasetype ();\n     Type *tb2 = e->e2->type->toBasetype ();\n \n@@ -331,7 +331,7 @@ class ExprVisitor : public Visitor\n   {\n     Type *tb1 = e->e1->type->toBasetype ();\n     Type *tb2 = e->e2->type->toBasetype ();\n-    tree_code code = (e->op == TOKequal) ? EQ_EXPR : NE_EXPR;\n+    tree_code code = (e->op == EXP::equal) ? EQ_EXPR : NE_EXPR;\n \n     if ((tb1->ty == TY::Tsarray || tb1->ty == TY::Tarray)\n \t&& (tb2->ty == TY::Tsarray || tb2->ty == TY::Tarray))\n@@ -391,7 +391,7 @@ class ExprVisitor : public Visitor\n \t       Otherwise for inequality:\n \t\t    (e1.length != 0 && memcmp);  */\n \t    tree tsizecmp = build_boolop (code, t1len, size_zero_node);\n-\t    if (e->op == TOKequal)\n+\t    if (e->op == EXP::equal)\n \t      result = build_boolop (TRUTH_ORIF_EXPR, tsizecmp, result);\n \t    else\n \t      result = build_boolop (TRUTH_ANDIF_EXPR, tsizecmp, result);\n@@ -404,7 +404,7 @@ class ExprVisitor : public Visitor\n \t    else\n \t      {\n \t\ttree tlencmp = build_boolop (code, t1len, t2len);\n-\t\tif (e->op == TOKequal)\n+\t\tif (e->op == EXP::equal)\n \t\t  result = build_boolop (TRUTH_ANDIF_EXPR, tlencmp, result);\n \t\telse\n \t\t  result = build_boolop (TRUTH_ORIF_EXPR, tlencmp, result);\n@@ -428,7 +428,7 @@ class ExprVisitor : public Visitor\n \t\t\t\t\t d_array_convert (e->e2),\n \t\t\t\t\t build_typeinfo (e->loc, t1array));\n \n-\t    if (e->op == TOKnotequal)\n+\t    if (e->op == EXP::notEqual)\n \t      result = build1 (TRUTH_NOT_EXPR, build_ctype (e->type), result);\n \n \t    this->result_ = result;\n@@ -453,7 +453,7 @@ class ExprVisitor : public Visitor\n \t\t\t\t     build_expr (e->e1),\n \t\t\t\t     build_expr (e->e2));\n \n-\tif (e->op == TOKnotequal)\n+\tif (e->op == EXP::notEqual)\n \t  result = build1 (TRUTH_NOT_EXPR, build_ctype (e->type), result);\n \n \tthis->result_ = result;\n@@ -499,19 +499,19 @@ class ExprVisitor : public Visitor\n \n     switch (e->op)\n       {\n-      case TOKle:\n+      case EXP::lessOrEqual:\n \tcode = LE_EXPR;\n \tbreak;\n \n-      case TOKlt:\n+      case EXP::lessThan:\n \tcode = LT_EXPR;\n \tbreak;\n \n-      case TOKge:\n+      case EXP::greaterOrEqual:\n \tcode = GE_EXPR;\n \tbreak;\n \n-      case TOKgt:\n+      case EXP::greaterThan:\n \tcode = GT_EXPR;\n \tbreak;\n \n@@ -540,7 +540,7 @@ class ExprVisitor : public Visitor\n \n   void visit (LogicalExp *e)\n   {\n-    tree_code code = (e->op == TOKandand) ? TRUTH_ANDIF_EXPR : TRUTH_ORIF_EXPR;\n+    tree_code code = (e->op == EXP::andAnd) ? TRUTH_ANDIF_EXPR : TRUTH_ORIF_EXPR;\n \n     if (e->e2->type->toBasetype ()->ty != TY::Tvoid)\n       {\n@@ -559,7 +559,7 @@ class ExprVisitor : public Visitor\n \ttree t2 = build_expr_dtor (e->e2);\n \n \t/* Invert condition for logical or if expression.  */\n-\tif (e->op == TOKoror)\n+\tif (e->op == EXP::orOr)\n \t  t1 = build1 (TRUTH_NOT_EXPR, d_bool_type, t1);\n \n \tthis->result_ = build_condition (build_ctype (e->type),\n@@ -576,8 +576,8 @@ class ExprVisitor : public Visitor\n \n     switch (e->op)\n       {\n-      case TOKadd:\n-      case TOKmin:\n+      case EXP::add:\n+      case EXP::min:\n \tif ((e->e1->type->isreal () && e->e2->type->isimaginary ())\n \t    || (e->e1->type->isimaginary () && e->e2->type->isreal ()))\n \t  {\n@@ -586,7 +586,7 @@ class ExprVisitor : public Visitor\n \t    tree t1 = build_expr (e->e1);\n \t    tree t2 = build_expr (e->e2);\n \n-\t    if (e->op == TOKmin)\n+\t    if (e->op == EXP::min)\n \t      t2 = build1 (NEGATE_EXPR, TREE_TYPE (t2), t2);\n \n \t    if (e->e1->type->isreal ())\n@@ -597,22 +597,22 @@ class ExprVisitor : public Visitor\n \t    return;\n \t  }\n \telse\n-\t  code = (e->op == TOKadd)\n+\t  code = (e->op == EXP::add)\n \t    ? PLUS_EXPR : MINUS_EXPR;\n \tbreak;\n \n-      case TOKmul:\n+      case EXP::mul:\n \tcode = MULT_EXPR;\n \tbreak;\n \n-      case TOKdiv:\n+      case EXP::div:\n \t/* Determine if the div expression is a lowered pointer diff operation.\n \t   The front-end rewrites `(p1 - p2)' into `(p1 - p2) / stride'.  */\n \tif (MinExp *me = e->e1->isMinExp ())\n \t  {\n \t    if (me->e1->type->ty == TY::Tpointer\n \t\t&& me->e2->type->ty == TY::Tpointer\n-\t\t&& e->e2->op == TOKint64)\n+\t\t&& e->e2->op == EXP::int64)\n \t      {\n \t\tcode = EXACT_DIV_EXPR;\n \t\tbreak;\n@@ -623,32 +623,32 @@ class ExprVisitor : public Visitor\n \t  ? TRUNC_DIV_EXPR : RDIV_EXPR;\n \tbreak;\n \n-      case TOKmod:\n+      case EXP::mod:\n \tcode = e->e1->type->isfloating ()\n \t  ? FLOAT_MOD_EXPR : TRUNC_MOD_EXPR;\n \tbreak;\n \n-      case TOKand:\n+      case EXP::and_:\n \tcode = BIT_AND_EXPR;\n \tbreak;\n \n-      case TOKor:\n+      case EXP::or_:\n \tcode = BIT_IOR_EXPR;\n \tbreak;\n \n-      case TOKxor:\n+      case EXP::xor_:\n \tcode = BIT_XOR_EXPR;\n \tbreak;\n \n-      case TOKshl:\n+      case EXP::leftShift:\n \tcode = LSHIFT_EXPR;\n \t  break;\n \n-      case TOKshr:\n+      case EXP::rightShift:\n \tcode = RSHIFT_EXPR;\n \tbreak;\n \n-      case TOKushr:\n+      case EXP::unsignedRightShift:\n \tcode = UNSIGNED_RSHIFT_EXPR;\n \tbreak;\n \n@@ -678,15 +678,15 @@ class ExprVisitor : public Visitor\n \n     tree result;\n \n-    if (e->e1->op == TOKcat)\n+    if (e->e1->op == EXP::concatenate)\n       {\n \t/* Flatten multiple concatenations to an array.\n \t   So the expression ((a ~ b) ~ c) becomes [a, b, c]  */\n \tint ndims = 2;\n \n-\tfor (Expression *ex = e->e1; ex->op == TOKcat;)\n+\tfor (Expression *ex = e->e1; ex->op == EXP::concatenate;)\n \t  {\n-\t    if (ex->op == TOKcat)\n+\t    if (ex->op == EXP::concatenate)\n \t      {\n \t\tex = ex->isCatExp ()->e1;\n \t\tndims++;\n@@ -703,7 +703,7 @@ class ExprVisitor : public Visitor\n \tint dim = ndims - 1;\n \n \tfor (Expression *oe = ce->e2; oe != NULL;\n-\t     (ce->e1->op != TOKcat\n+\t     (ce->e1->op != EXP::concatenate\n \t      ? (oe = ce->e1)\n \t      : (ce = ce->e1->isCatExp (), oe = ce->e2)))\n \t  {\n@@ -751,59 +751,59 @@ class ExprVisitor : public Visitor\n \n     switch (e->op)\n       {\n-      case TOKaddass:\n+      case EXP::addAssign:\n \tcode = PLUS_EXPR;\n \tbreak;\n \n-      case TOKminass:\n+      case EXP::minAssign:\n \tcode = MINUS_EXPR;\n \tbreak;\n \n-      case TOKmulass:\n+      case EXP::mulAssign:\n \tcode = MULT_EXPR;\n \tbreak;\n \n-      case TOKdivass:\n+      case EXP::divAssign:\n \tcode = e->e1->type->isintegral ()\n \t  ? TRUNC_DIV_EXPR : RDIV_EXPR;\n \tbreak;\n \n-      case TOKmodass:\n+      case EXP::modAssign:\n \tcode = e->e1->type->isfloating ()\n \t  ? FLOAT_MOD_EXPR : TRUNC_MOD_EXPR;\n \tbreak;\n \n-      case TOKandass:\n+      case EXP::andAssign:\n \tcode = BIT_AND_EXPR;\n \tbreak;\n \n-      case TOKorass:\n+      case EXP::orAssign:\n \tcode = BIT_IOR_EXPR;\n \tbreak;\n \n-      case TOKxorass:\n+      case EXP::xorAssign:\n \tcode = BIT_XOR_EXPR;\n \tbreak;\n \n-      case TOKpowass:\n+      case EXP::powAssign:\n \tgcc_unreachable ();\n \n-      case TOKshlass:\n+      case EXP::leftShiftAssign:\n \tcode = LSHIFT_EXPR;\n \tbreak;\n \n-      case TOKshrass:\n-      case TOKushrass:\n+      case EXP::rightShiftAssign:\n+      case EXP::unsignedRightShiftAssign:\n \t/* Use the original lhs type before it was promoted.  The left operand\n \t   of `>>>=' does not undergo integral promotions before shifting.\n \t   Strip off casts just incase anyway.  */\n-\twhile (e1b->op == TOKcast)\n+\twhile (e1b->op == EXP::cast_)\n \t  {\n \t    CastExp *ce = e1b->isCastExp ();\n \t    gcc_assert (same_type_p (ce->type, ce->to));\n \t    e1b = ce->e1;\n \t  }\n-\tcode = (e->op == TOKshrass) ? RSHIFT_EXPR : UNSIGNED_RSHIFT_EXPR;\n+\tcode = (e->op == EXP::rightShiftAssign) ? RSHIFT_EXPR : UNSIGNED_RSHIFT_EXPR;\n \tbreak;\n \n       default:\n@@ -908,15 +908,15 @@ class ExprVisitor : public Visitor\n     /* First, handle special assignment semantics.  */\n \n     /* Look for array.length = n;  */\n-    if (e->e1->op == TOKarraylength)\n+    if (e->e1->op == EXP::arrayLength)\n       {\n \t/* This case should have been rewritten to `_d_arraysetlengthT` in the\n \t   semantic phase.  */\n \tgcc_unreachable ();\n       }\n \n     /* Look for array[] = n;  */\n-    if (e->e1->op == TOKslice)\n+    if (e->e1->op == EXP::slice)\n       {\n \tSliceExp *se = e->e1->isSliceExp ();\n \tType *stype = se->e1->type->toBasetype ();\n@@ -937,15 +937,18 @@ class ExprVisitor : public Visitor\n \t    tree init = stabilize_expr (&t1);\n \t    t1 = d_save_expr (t1);\n \n-\t    if ((postblit || destructor) && e->op != TOKblit)\n+\t    if ((postblit || destructor) && e->op != EXP::blit)\n \t      {\n-\t\tlibcall_fn libcall = (e->op == TOKconstruct)\n-\t\t  ? LIBCALL_ARRAYSETCTOR : LIBCALL_ARRAYSETASSIGN;\n+\t\t/* Need to call postblit/destructor as part of assignment.\n+\t\t   Construction has already been handled by the front-end.  */\n+\t\tgcc_assert (e->op != EXP::construct);\n+\n \t\t/* So we can call postblits on const/immutable objects.  */\n \t\tType *tm = etype->unSharedOf ()->mutableOf ();\n \t\ttree ti = build_typeinfo (e->loc, tm);\n \n-\t\tresult = build_libcall (libcall, Type::tvoid, 4,\n+\t\t/* Generate: _d_arraysetassign (t1.ptr, &t2, t1.length, ti);  */\n+\t\tresult = build_libcall (LIBCALL_ARRAYSETASSIGN, Type::tvoid, 4,\n \t\t\t\t\td_array_ptr (t1),\n \t\t\t\t\tbuild_address (t2),\n \t\t\t\t\td_array_length (t1), ti);\n@@ -1011,14 +1014,11 @@ class ExprVisitor : public Visitor\n \n \t\tthis->result_ = compound_expr (result, t1);\n \t      }\n-\t    else if ((postblit || destructor) && e->op != TOKblit)\n+\t    else if ((postblit || destructor)\n+\t\t     && e->op != EXP::blit && e->op != EXP::construct)\n \t      {\n-\t\t/* Generate: _d_arrayassign(ti, from, to)\n-\t\t\t or: _d_arrayctor(ti, from, to)  */\n-\t\tlibcall_fn libcall = (e->op == TOKconstruct)\n-\t\t  ? LIBCALL_ARRAYCTOR : LIBCALL_ARRAYASSIGN;\n-\n-\t\tthis->result_ = build_libcall (libcall, e->type, 3,\n+\t\t/* Generate: _d_arrayassign(ti, from, to);  */\n+\t\tthis->result_ = build_libcall (LIBCALL_ARRAYASSIGN, e->type, 3,\n \t\t\t\t\t       build_typeinfo (e->loc, etype),\n \t\t\t\t\t       d_array_convert (e->e2),\n \t\t\t\t\t       d_array_convert (e->e1));\n@@ -1039,8 +1039,8 @@ class ExprVisitor : public Visitor\n     /* Look for reference initializations.  */\n     if (e->memset == MemorySet::referenceInit)\n       {\n-\tgcc_assert (e->op == TOKconstruct || e->op == TOKblit);\n-\tgcc_assert (e->e1->op == TOKvar);\n+\tgcc_assert (e->op == EXP::construct || e->op == EXP::blit);\n+\tgcc_assert (e->e1->op == EXP::variable);\n \n \tDeclaration *decl = e->e1->isVarExp ()->var;\n \tif (decl->storage_class & (STCout | STCref))\n@@ -1060,7 +1060,7 @@ class ExprVisitor : public Visitor\n \n     /* Other types of assignments that may require post construction.  */\n     Type *tb1 = e->e1->type->toBasetype ();\n-    tree_code modifycode = (e->op == TOKconstruct) ? INIT_EXPR : MODIFY_EXPR;\n+    tree_code modifycode = (e->op == EXP::construct) ? INIT_EXPR : MODIFY_EXPR;\n \n     /* Look for struct assignment.  */\n     if (tb1->ty == TY::Tstruct)\n@@ -1071,10 +1071,10 @@ class ExprVisitor : public Visitor\n \tStructDeclaration *sd = tb1->isTypeStruct ()->sym;\n \n \t/* Look for struct = 0.  */\n-\tif (e->e2->op == TOKint64)\n+\tif (e->e2->op == EXP::int64)\n \t  {\n \t    /* Use memset to fill struct.  */\n-\t    gcc_assert (e->op == TOKblit);\n+\t    gcc_assert (e->op == EXP::blit);\n \t    tree result = build_memset_call (t1);\n \n \t    /* Maybe set-up hidden pointer to outer scope context.  */\n@@ -1095,8 +1095,8 @@ class ExprVisitor : public Visitor\n \t    tree init = NULL_TREE;\n \n \t    /* Fill any alignment holes in the struct using memset.  */\n-\t    if ((e->op == TOKconstruct\n-\t\t || (e->e2->op == TOKstructliteral && e->op == TOKblit))\n+\t    if ((e->op == EXP::construct\n+\t\t || (e->e2->op == EXP::structLiteral && e->op == EXP::blit))\n \t\t&& (sd->isUnionDeclaration () || !identity_compare_p (sd)))\n \t      {\n \t\tt1 = stabilize_reference (t1);\n@@ -1120,10 +1120,10 @@ class ExprVisitor : public Visitor\n     if (tb1->ty == TY::Tsarray)\n       {\n \t/* Look for array = 0.  */\n-\tif (e->e2->op == TOKint64)\n+\tif (e->e2->op == EXP::int64)\n \t  {\n \t    /* Use memset to fill the array.  */\n-\t    gcc_assert (e->op == TOKblit);\n+\t    gcc_assert (e->op == EXP::blit);\n \t    this->result_ = build_memset_call (build_expr (e->e1));\n \t    return;\n \t  }\n@@ -1132,17 +1132,17 @@ class ExprVisitor : public Visitor\n \tgcc_assert (e->e2->type->toBasetype ()->ty == TY::Tsarray);\n \n \t/* Determine if we need to run postblit.  */\n-\tbool postblit = needs_postblit (etype);\n-\tbool destructor = needs_dtor (etype);\n-\tbool lvalue = lvalue_p (e->e2);\n+\tconst bool postblit = needs_postblit (etype);\n+\tconst bool destructor = needs_dtor (etype);\n+\tconst bool lvalue = lvalue_p (e->e2);\n \n \t/* Optimize static array assignment with array literal.  Even if the\n \t   elements in rhs are all rvalues and don't have to call postblits,\n \t   this assignment should call dtors on old assigned elements.  */\n \tif ((!postblit && !destructor)\n-\t    || (e->op == TOKconstruct && e->e2->op == TOKarrayliteral)\n-\t    || (e->op == TOKconstruct && !lvalue && postblit)\n-\t    || (e->op == TOKblit || e->e1->type->size () == 0))\n+\t    || (e->op == EXP::construct && e->e2->op == EXP::arrayLiteral)\n+\t    || (e->op == EXP::construct && !lvalue && postblit)\n+\t    || (e->op == EXP::blit || e->e1->type->size () == 0))\n \t  {\n \t    tree t1 = build_expr (e->e1);\n \t    tree t2 = convert_for_assignment (build_expr (e->e2),\n@@ -1152,32 +1152,22 @@ class ExprVisitor : public Visitor\n \t    return;\n \t  }\n \n+\t/* All other kinds of lvalue or rvalue static array assignment.\n+\t   Array construction has already been handled by the front-end.  */\n+\tgcc_assert (e->op != EXP::construct);\n+\n+\t/* Generate: _d_arrayassign_l()\n+\t\t or: _d_arrayassign_r()  */\n+\tlibcall_fn libcall = (lvalue)\n+\t  ? LIBCALL_ARRAYASSIGN_L : LIBCALL_ARRAYASSIGN_R;\n+\ttree elembuf = build_local_temp (build_ctype (etype));\n \tType *arrtype = (e->type->ty == TY::Tsarray)\n \t  ? etype->arrayOf () : e->type;\n-\ttree result;\n-\n-\tif (e->op == TOKconstruct)\n-\t  {\n-\t    /* Generate: _d_arrayctor(ti, from, to)  */\n-\t    result = build_libcall (LIBCALL_ARRAYCTOR, arrtype, 3,\n-\t\t\t\t    build_typeinfo (e->loc, etype),\n-\t\t\t\t    d_array_convert (e->e2),\n-\t\t\t\t    d_array_convert (e->e1));\n-\t  }\n-\telse\n-\t  {\n-\t    /* Generate: _d_arrayassign_l()\n-\t\t     or: _d_arrayassign_r()  */\n-\t    libcall_fn libcall = (lvalue)\n-\t      ? LIBCALL_ARRAYASSIGN_L : LIBCALL_ARRAYASSIGN_R;\n-\t    tree elembuf = build_local_temp (build_ctype (etype));\n-\n-\t    result = build_libcall (libcall, arrtype, 4,\n-\t\t\t\t    build_typeinfo (e->loc, etype),\n-\t\t\t\t    d_array_convert (e->e2),\n-\t\t\t\t    d_array_convert (e->e1),\n-\t\t\t\t    build_address (elembuf));\n-\t  }\n+\ttree result = build_libcall (libcall, arrtype, 4,\n+\t\t\t\t     build_typeinfo (e->loc, etype),\n+\t\t\t\t     d_array_convert (e->e2),\n+\t\t\t\t     d_array_convert (e->e1),\n+\t\t\t\t     build_address (elembuf));\n \n \t/* Cast the libcall result back to a static array.  */\n \tif (e->type->ty == TY::Tsarray)\n@@ -1202,12 +1192,12 @@ class ExprVisitor : public Visitor\n   {\n     tree result;\n \n-    if (e->op == TOKplusplus)\n+    if (e->op == EXP::plusPlus)\n       {\n \tresult = build2 (POSTINCREMENT_EXPR, build_ctype (e->type),\n \t\t\t build_expr (e->e1), build_expr (e->e2));\n       }\n-    else if (e->op == TOKminusminus)\n+    else if (e->op == EXP::minusMinus)\n       {\n \tresult = build2 (POSTDECREMENT_EXPR, build_ctype (e->type),\n \t\t\t build_expr (e->e1), build_expr (e->e2));\n@@ -1441,7 +1431,7 @@ class ExprVisitor : public Visitor\n \t   the destructor is called for the object instance.  */\n \tlibcall_fn libcall;\n \n-\tif (e->e1->op == TOKvar)\n+\tif (e->e1->op == EXP::variable)\n \t  {\n \t    VarDeclaration *v = e->e1->isVarExp ()->var->isVarDeclaration ();\n \t    if (v && v->onstack)\n@@ -1586,10 +1576,10 @@ class ExprVisitor : public Visitor\n     size_t offset;\n     tree result;\n \n-    if (e->e1->op == TOKadd)\n+    if (e->e1->op == EXP::add)\n       {\n \tAddExp *ae = e->e1->isAddExp ();\n-\tif (ae->e1->op == TOKaddress\n+\tif (ae->e1->op == EXP::address\n \t    && ae->e2->isConst () && ae->e2->type->isintegral ())\n \t  {\n \t    Expression *ex = ae->e1->isAddrExp ()->e1;\n@@ -1598,7 +1588,7 @@ class ExprVisitor : public Visitor\n \t    offset = ae->e2->toUInteger ();\n \t  }\n       }\n-    else if (e->e1->op == TOKsymoff)\n+    else if (e->e1->op == EXP::symbolOffset)\n       {\n \tSymOffExp *se = e->e1->isSymOffExp ();\n \tif (!declaration_reference_p (se->var))\n@@ -1650,7 +1640,7 @@ class ExprVisitor : public Visitor\n \n     /* The frontend optimizer can convert const symbol into a struct literal.\n        Taking the address of a struct literal is otherwise illegal.  */\n-    if (e->e1->op == TOKstructliteral)\n+    if (e->e1->op == EXP::structLiteral)\n       {\n \tStructLiteralExp *sle = e->e1->isStructLiteralExp ()->origin;\n \tgcc_assert (sle != NULL);\n@@ -1689,21 +1679,21 @@ class ExprVisitor : public Visitor\n     TypeFunction *tf = NULL;\n \n     /* Calls to delegates can sometimes look like this.  */\n-    if (e1b->op == TOKcomma)\n+    if (e1b->op == EXP::comma)\n       {\n \te1b = e1b->isCommaExp ()->e2;\n-\tgcc_assert (e1b->op == TOKvar);\n+\tgcc_assert (e1b->op == EXP::variable);\n \n \tDeclaration *var = e1b->isVarExp ()->var;\n \tgcc_assert (var->isFuncDeclaration () && !var->needThis ());\n       }\n \n-    if (e1b->op == TOKdotvar && tb->ty != TY::Tdelegate)\n+    if (e1b->op == EXP::dotVariable && tb->ty != TY::Tdelegate)\n       {\n \tDotVarExp *dve = e1b->isDotVarExp ();\n \n \t/* Don't modify the static initializer for struct literals.  */\n-\tif (dve->e1->op == TOKstructliteral)\n+\tif (dve->e1->op == EXP::structLiteral)\n \t  {\n \t    StructLiteralExp *sle = dve->e1->isStructLiteralExp ();\n \t    sle->useStaticInit = false;\n@@ -1775,7 +1765,7 @@ class ExprVisitor : public Visitor\n       {\n \t/* This could be a delegate expression (TY == Tdelegate), but not\n \t   actually a delegate variable.  */\n-\tif (e1b->op == TOKdotvar)\n+\tif (e1b->op == EXP::dotVariable)\n \t  {\n \t    /* This gets the true function type, getting the function type\n \t       from e1->type can sometimes be incorrect, such as when calling\n@@ -1795,7 +1785,7 @@ class ExprVisitor : public Visitor\n \tobject = delegate_object (callee);\n \tcallee = delegate_method (callee);\n       }\n-    else if (e1b->op == TOKvar)\n+    else if (e1b->op == EXP::variable)\n       {\n \tFuncDeclaration *fd = e1b->isVarExp ()->var->isFuncDeclaration ();\n \tgcc_assert (fd != NULL);\n@@ -1877,7 +1867,7 @@ class ExprVisitor : public Visitor\n \n     if (e->func->isNested () && !e->func->isThis ())\n       {\n-\tif (e->e1->op == TOKnull)\n+\tif (e->e1->op == EXP::null_)\n \t  object = build_expr (e->e1);\n \telse\n \t  object = get_frame_for_symbol (e->func);\n@@ -1908,7 +1898,7 @@ class ExprVisitor : public Visitor\n \n \t/* Get pointer to function out of the virtual table.  */\n \tif (e->func->isVirtual () && !e->func->isFinalFunc ()\n-\t    && e->e1->op != TOKsuper && e->e1->op != TOKdottype)\n+\t    && e->e1->op != EXP::super_ && e->e1->op != EXP::dotType)\n \t  {\n \t    tree fntype = build_pointer_type (TREE_TYPE (fndecl));\n \t    object = d_save_expr (object);\n@@ -2105,9 +2095,9 @@ class ExprVisitor : public Visitor\n     Type *ftype = e->type->toBasetype ();\n \n     /* This check is for lambda's, remove `vthis' as function isn't nested.  */\n-    if (e->fd->tok == TOKreserved && ftype->ty == TY::Tpointer)\n+    if (e->fd->tok == TOK::reserved && ftype->ty == TY::Tpointer)\n       {\n-\te->fd->tok = TOKfunction;\n+\te->fd->tok = TOK::function_;\n \te->fd->vthis = NULL;\n       }\n \n@@ -2196,9 +2186,9 @@ class ExprVisitor : public Visitor\n     FuncLiteralDeclaration *fld = e->var->isFuncLiteralDeclaration ();\n     if (fld != NULL)\n       {\n-\tif (fld->tok == TOKreserved)\n+\tif (fld->tok == TOK::reserved)\n \t  {\n-\t    fld->tok = TOKfunction;\n+\t    fld->tok = TOK::function_;\n \t    fld->vthis = NULL;\n \t  }\n \n@@ -2210,7 +2200,7 @@ class ExprVisitor : public Visitor\n       {\n \t/* Want the initializer, not the expression.  */\n \tVarDeclaration *var = e->var->isVarDeclaration ();\n-\tSymbolDeclaration *sd = e->var->isSymbolDeclaration ();\n+\tSymbolDeclaration *sdecl = e->var->isSymbolDeclaration ();\n \ttree init = NULL_TREE;\n \n \tif (var && (var->isConst () || var->isImmutable ())\n@@ -2226,8 +2216,15 @@ class ExprVisitor : public Visitor\n \t\tvar->inuse--;\n \t      }\n \t  }\n-\telse if (sd && sd->dsym)\n-\t  init = layout_struct_initializer (sd->dsym);\n+\telse if (sdecl && sdecl->dsym)\n+\t  {\n+\t    if (StructDeclaration *sd = sdecl->dsym->isStructDeclaration ())\n+\t      init = layout_struct_initializer (sd);\n+\t    else if (ClassDeclaration *cd = sdecl->dsym->isClassDeclaration ())\n+\t      init = layout_class_initializer (cd);\n+\t    else\n+\t      gcc_unreachable ();\n+\t  }\n \telse\n \t  error_at (make_location_t (e->loc), \"non-constant expression %qs\",\n \t\t    e->toChars ());\n@@ -2242,6 +2239,26 @@ class ExprVisitor : public Visitor\n \ttree result = get_decl_tree (e->var);\n \tTREE_USED (result) = 1;\n \n+\t/* The variable expression generated for `__traits(initSymbol)'.  */\n+\tif (SymbolDeclaration *sd = e->var->isSymbolDeclaration ())\n+\t  {\n+\t    if (e->type->isTypeDArray ())\n+\t      {\n+\t\t/* Generate a slice for non-zero initialized aggregates,\n+\t\t   otherwise create an empty array.  */\n+\t\tgcc_assert (e->type == Type::tvoid->arrayOf ()->constOf ());\n+\n+\t\ttree type = build_ctype (e->type);\n+\t\ttree length = size_int (sd->dsym->structsize);\n+\t\ttree ptr = (sd->dsym->isStructDeclaration ()\n+\t\t\t    && sd->dsym->type->isZeroInit (e->loc))\n+\t\t  ? null_pointer_node : build_address (result);\n+\n+\t\tthis->result_ = d_array_value (type, length, ptr);\n+\t\treturn;\n+\t      }\n+\t  }\n+\n \t/* For variables that are references - currently only out/inout\n \t   arguments; objects don't count - evaluating the variable means\n \t   we want what it refers to.  */\n@@ -2954,7 +2971,7 @@ class ExprVisitor : public Visitor\n     tree type = build_ctype (e->type);\n \n     /* First handle array literal expressions.  */\n-    if (e->e1->op == TOKarrayliteral)\n+    if (e->e1->op == EXP::arrayLiteral)\n       {\n \tArrayLiteralExp *ale = e->e1->isArrayLiteralExp ();\n \tvec <constructor_elt, va_gc> *elms = NULL;"}, {"sha": "dec2bd47265b04f1e5c764c109ae8e29c8ae778b", "filename": "gcc/d/intrinsics.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fintrinsics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fintrinsics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fintrinsics.cc?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -431,7 +431,7 @@ expand_intrinsic_rotate (intrinsic_code intrinsic, tree callexp)\n       gcc_assert (ti && ti->tiargs && ti->tiargs->length == 2);\n \n       Expression *e = isExpression ((*ti->tiargs)[0]);\n-      gcc_assert (e && e->op == TOKint64);\n+      gcc_assert (e && e->op == EXP::int64);\n       count = build_expr (e, true);\n     }\n "}, {"sha": "893bc238631a77fdb3b430f346e07745d531c733", "filename": "gcc/d/lang.opt", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Flang.opt?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -380,10 +380,6 @@ fpreview=inclusiveincontracts\n D RejectNegative\n Implement 'in' contracts of overridden methods to be a superset of parent contract.\n \n-fpreview=intpromote\n-D RejectNegative\n-Use C-style integral promotion for unary '+', '-' and '~'.\n-\n fpreview=nosharedaccess\n D RejectNegative\n Disable access to shared memory objects.\n@@ -412,6 +408,10 @@ frevert=dtorfields\n D RejectNegative\n Don't destruct fields of partially constructed objects.\n \n+frevert=intpromote\n+D RejectNegative\n+Use C-style integral promotion for unary '+', '-' and '~'.\n+\n frevert=markdown\n D RejectNegative\n Disable Markdown replacements in Ddoc."}, {"sha": "3961a1d9bed37354593fc6083163c63d3b2f2196", "filename": "gcc/d/runtime.def", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fruntime.def?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -140,13 +140,6 @@ DEF_D_RUNTIME (ARRAYASSIGN_R, \"_d_arrayassign_r\", RT(ARRAY_VOID),\n DEF_D_RUNTIME (ARRAYSETASSIGN, \"_d_arraysetassign\", RT(VOIDPTR),\n \t       P4(VOIDPTR, VOIDPTR, SIZE_T, CONST_TYPEINFO), 0)\n \n-/* Used for constructing a new array from an existing array.  The `set' variant\n-   is for when the constructor value is a single element.  */\n-DEF_D_RUNTIME (ARRAYCTOR, \"_d_arrayctor\", RT(ARRAY_VOID),\n-\t       P3(CONST_TYPEINFO, ARRAY_VOID, ARRAY_VOID), 0)\n-DEF_D_RUNTIME (ARRAYSETCTOR, \"_d_arraysetctor\", RT(VOIDPTR),\n-\t       P4(VOIDPTR, VOIDPTR, SIZE_T, CONST_TYPEINFO), 0)\n-\n /* Used for concatenating two or more arrays together.  Then `n' variant is\n    for when there is more than two arrays to handle.  */\n DEF_D_RUNTIME (ARRAYCATT, \"_d_arraycatT\", RT(ARRAY_BYTE),"}, {"sha": "17b63ba8a7d7597b4a2585927f4c5f031994c89b", "filename": "gcc/d/toir.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Ftoir.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Ftoir.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftoir.cc?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -969,8 +969,7 @@ class IRVisitor : public Visitor\n \tStructLiteralExp *sle = NULL;\n \tbool using_rvo_p = false;\n \n-\tif (DotVarExp *dve = (s->exp->op == TOKcall\n-\t\t\t      && s->exp->isCallExp ()->e1->op == TOKdotvar\n+\tif (DotVarExp *dve = (s->exp->isCallExp ()\n \t\t\t      ? s->exp->isCallExp ()->e1->isDotVarExp ()\n \t\t\t      : NULL))\n \t  {"}, {"sha": "1d551e5249bd2015a97ba33c2eea56ee9f11f9d8", "filename": "gcc/d/types.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Fd%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftypes.cc?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -338,7 +338,7 @@ layout_aggregate_members (Dsymbols *members, tree context, bool inherited_p)\n \t\t  RootObject *ro = (*td->objects)[j];\n \t\t  gcc_assert (ro->dyncast () == DYNCAST_EXPRESSION);\n \t\t  Expression *e = (Expression *) ro;\n-\t\t  gcc_assert (e->op == TOKdsymbol);\n+\t\t  gcc_assert (e->op == EXP::dSymbol);\n \t\t  DsymbolExp *se = e->isDsymbolExp ();\n \n \t\t  tmembers.push (se->s);"}, {"sha": "1afe0a28cfb566647c0936221b06d921e9eb4361", "filename": "gcc/testsuite/gdc.test/compilable/covariant_override.d", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcovariant_override.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcovariant_override.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcovariant_override.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -0,0 +1,34 @@\n+// https://issues.dlang.org/show_bug.cgi?id=21538\n+// REQUIRED_ARGS: -preview=dip1000\n+\n+interface I\n+{\n+    void f(void delegate() @safe dg) @safe;\n+}\n+\n+class CI : I\n+{\n+    override void f(void delegate() @system dg) @safe { }\n+}\n+\n+abstract class A\n+{\n+    void f(void delegate() @safe dg) @safe;\n+}\n+\n+class CA : A\n+{\n+    override void f(void delegate() @system dg) @safe { }\n+}\n+\n+// https://issues.dlang.org/show_bug.cgi?id=20904\n+auto blah(void delegate())\n+{\n+}\n+\n+void delegate()[string] r;\n+void main()\n+{\n+    void delegate() nothrow a;\n+    r[\"v\"] = a;\n+}"}, {"sha": "be7bee83fa0a74d2ee041ffcccfc11f230db812e", "filename": "gcc/testsuite/gdc.test/compilable/emptygenmain.d", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Femptygenmain.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Femptygenmain.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Femptygenmain.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -0,0 +1,3 @@\n+// REQUIRED_ARGS: -main -c\n+\n+void foo() { }"}, {"sha": "22734cf48b3c13bdf36ef2fd21ee00f826e602e7", "filename": "gcc/testsuite/gdc.test/compilable/noreturn1.d", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fnoreturn1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fnoreturn1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fnoreturn1.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -111,3 +111,15 @@ void* useTls()\n     void* a3 = &globalNoreturn;\n     return a1 < a2 ? a2 : a3;\n }\n+\n+/***************************************************/\n+\n+noreturn testfn(noreturn function() fn)\n+{\n+    fn();\n+}\n+\n+noreturn testdg(noreturn delegate() dg)\n+{\n+    dg();\n+}"}, {"sha": "2329b609170ee7a50d7e978b3315835762cc6f4a", "filename": "gcc/testsuite/gdc.test/compilable/test17870.d", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17870.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17870.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17870.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -0,0 +1,26 @@\n+alias AliasSeq(T...) = T;\n+\n+class A\n+{\n+    int z = 3;\n+}\n+\n+class B : A\n+{\n+    int a = 1;\n+}\n+\n+class C : B\n+{\n+    int b = 2;\n+    alias tup = AliasSeq!(b, a, z);\n+}\n+\n+void main()\n+{\n+    static const ins = new C;\n+    static assert(&ins.tup[0] == &ins.b);\n+    static assert(&ins.tup[1] == &ins.a);\n+    static assert(&ins.tup[2] == &ins.z);\n+    static assert(ins.tup == AliasSeq!(2,1,3));\n+}"}, {"sha": "7252edd752063d31086ed9d20100ce5191db3ac5", "filename": "gcc/testsuite/gdc.test/compilable/test19873.d", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest19873.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest19873.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest19873.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -0,0 +1,37 @@\n+// PERMUTE_ARGS -preview=dip1000\n+// https://issues.dlang.org/show_bug.cgi?id=19873\n+int* ed(scope int* x)\n+{\n+    auto y = x;\n+    return y;\n+}\n+\n+int* et(scope int* x) @trusted\n+{\n+    auto y = x;\n+    return y;\n+}\n+\n+int* es(scope int* x) @system\n+{\n+    auto y = x;\n+    return y;\n+}\n+\n+auto ad(scope int* x)\n+{\n+    auto y = x;\n+    return y;\n+}\n+\n+auto at(scope int* x) @trusted\n+{\n+    auto y = x;\n+    return y;\n+}\n+\n+auto as(scope int* x) @system\n+{\n+    auto y = x;\n+    return y;\n+}"}, {"sha": "9d444e16c785d7f2962cf3d34afd9608e1bf90ca", "filename": "gcc/testsuite/gdc.test/compilable/test21719.d", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21719.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21719.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21719.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -0,0 +1,21 @@\n+// https://issues.dlang.org/show_bug.cgi?id=21719\n+\n+struct S\n+{\n+    auto f()\n+    {\n+    } // inferred to be @safe @nogc pure nothrow\n+}\n+\n+class C\n+{\n+    auto f() // should also infer the same attributes\n+    {\n+    }\n+}\n+\n+pure @nogc nothrow @safe void test(S s, C c)\n+{\n+    s.f;\n+    c.f;\n+}"}, {"sha": "94f6596a19d30b36a01571dfc1c0917defcbf6b9", "filename": "gcc/testsuite/gdc.test/compilable/test22254.d", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22254.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22254.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22254.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -0,0 +1,19 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22254\n+\n+struct Template(T) { T t; }\n+\n+Template!Bar a;\n+Template!Bar b;\n+\n+immutable struct Bar { }\n+\n+static assert(is(typeof(a) == typeof(b)));\n+static assert(is(typeof(a) == Template!(immutable Bar)));\n+\n+Template!C c1;\n+Template!C c2;\n+\n+immutable class C { }\n+\n+static assert(is(typeof(c1) == typeof(c2)));\n+static assert(is(typeof(c1) == Template!(immutable C)));"}, {"sha": "af5d0a433eb9103a4a7d49288463db221c9f66d7", "filename": "gcc/testsuite/gdc.test/compilable/test22510.d", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22510.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22510.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22510.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -0,0 +1,18 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22510\n+\n+struct S\n+{\n+\tint b;\n+\n+    @disable this(this);\n+    this (scope ref inout S) inout\n+    {\n+    \tthis.b = b;\n+    }\n+}\n+\n+void main()\n+{\n+\tauto scoped_s = S(4);\n+\tauto heap_s = new S(42);\n+}"}, {"sha": "7738770775d45e498f365bf91e4b8b0a832af554", "filename": "gcc/testsuite/gdc.test/fail_compilation/covariant_override.d", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fcovariant_override.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fcovariant_override.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fcovariant_override.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -0,0 +1,35 @@\n+/++\n+https://issues.dlang.org/show_bug.cgi?id=21538\n+\n+TEST_OUTPUT:\n+---\n+fail_compilation/covariant_override.d(23): Error: function `@safe void covariant_override.CI.f(void delegate() @safe dg)` does not override any function, did you mean to override `@safe void covariant_override.I.f(void delegate() @system dg)`?\n+fail_compilation/covariant_override.d(34): Error: function `@safe void covariant_override.CA.f(void delegate() @safe dg)` does not override any function, did you mean to override `@safe void covariant_override.A.f(void delegate() @system dg)`?\n+fail_compilation/covariant_override.d(20): Error: class `covariant_override.CI` interface function `void f(void delegate() @system dg) @safe` is not implemented\n+---\n+++/\n+\n+static assert(!is(void delegate() @system : void delegate() @safe));\n+static assert( is(void delegate() @safe : void delegate() @system));\n+\n+interface I\n+{\n+    void f(void delegate() @system dg) @safe;\n+}\n+\n+class CI : I\n+{\n+    // this overrride should not be legal\n+    override void f(void delegate() @safe dg) @safe { }\n+}\n+\n+abstract class A\n+{\n+    void f(void delegate() @system dg) @safe;\n+}\n+\n+class CA : A\n+{\n+    // this overrride should not be legal\n+    override void f(void delegate() @safe dg) @safe { }\n+}"}, {"sha": "4b31a92f9ab3480f824c853287418d33d311efa4", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail10964.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail10964.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail10964.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail10964.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -5,8 +5,8 @@ fail_compilation/fail10964.d(28): Error: function `fail10964.S.__postblit` is no\n fail_compilation/fail10964.d(29): Error: function `fail10964.S.__postblit` is not `nothrow`\n fail_compilation/fail10964.d(30): Error: function `fail10964.S.__postblit` is not `nothrow`\n fail_compilation/fail10964.d(33): Error: function `fail10964.S.__postblit` is not `nothrow`\n-fail_compilation/fail10964.d(34): Error: function `fail10964.S.__postblit` is not `nothrow`\n-fail_compilation/fail10964.d(35): Error: function `fail10964.S.__postblit` is not `nothrow`\n+fail_compilation/fail10964.d(34): Error: function `core.internal.array.construction._d_arraysetctor!(S[], S)._d_arraysetctor` is not `nothrow`\n+fail_compilation/fail10964.d(35): Error: function `core.internal.array.construction._d_arrayctor!(S[], S)._d_arrayctor` is not `nothrow`\n fail_compilation/fail10964.d(22): Error: `nothrow` function `fail10964.foo` may throw\n ---\n */"}, {"sha": "d9f554a4b78b1c5d2eef7133640ea7d3f5997d64", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail10968.d", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail10968.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail10968.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail10968.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -1,24 +1,26 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail10968.d(39): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(39): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(27):        `fail10968.SA.__postblit` is declared here\n-fail_compilation/fail10968.d(40): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(40): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(27):        `fail10968.SA.__postblit` is declared here\n fail_compilation/fail10968.d(41): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n fail_compilation/fail10968.d(41): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(27):        `fail10968.SA.__postblit` is declared here\n-fail_compilation/fail10968.d(44): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(44): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(27):        `fail10968.SA.__postblit` is declared here\n-fail_compilation/fail10968.d(45): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(45): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(27):        `fail10968.SA.__postblit` is declared here\n+fail_compilation/fail10968.d(29):        `fail10968.SA.__postblit` is declared here\n+fail_compilation/fail10968.d(42): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n+fail_compilation/fail10968.d(42): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n+fail_compilation/fail10968.d(29):        `fail10968.SA.__postblit` is declared here\n+fail_compilation/fail10968.d(43): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n+fail_compilation/fail10968.d(43): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n+fail_compilation/fail10968.d(29):        `fail10968.SA.__postblit` is declared here\n fail_compilation/fail10968.d(46): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n fail_compilation/fail10968.d(46): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n-fail_compilation/fail10968.d(27):        `fail10968.SA.__postblit` is declared here\n+fail_compilation/fail10968.d(29):        `fail10968.SA.__postblit` is declared here\n+fail_compilation/fail10968.d(47): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n+fail_compilation/fail10968.d(47): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n+fail_compilation/fail10968.d(29):        `fail10968.SA.__postblit` is declared here\n+fail_compilation/fail10968.d(47): Error: `pure` function `fail10968.bar` cannot call impure function `core.internal.array.construction._d_arraysetctor!(SA[], SA)._d_arraysetctor`\n+fail_compilation/fail10968.d(48): Error: `pure` function `fail10968.bar` cannot call impure function `fail10968.SA.__postblit`\n+fail_compilation/fail10968.d(48): Error: `@safe` function `fail10968.bar` cannot call `@system` function `fail10968.SA.__postblit`\n+fail_compilation/fail10968.d(29):        `fail10968.SA.__postblit` is declared here\n+fail_compilation/fail10968.d(48): Error: `pure` function `fail10968.bar` cannot call impure function `core.internal.array.construction._d_arrayctor!(SA[], SA)._d_arrayctor`\n ---\n */\n \n@@ -49,12 +51,12 @@ void bar() pure @safe\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail10968.d(72): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n-fail_compilation/fail10968.d(73): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n fail_compilation/fail10968.d(74): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n-fail_compilation/fail10968.d(77): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n-fail_compilation/fail10968.d(78): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n+fail_compilation/fail10968.d(75): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n+fail_compilation/fail10968.d(76): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n fail_compilation/fail10968.d(79): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n+fail_compilation/fail10968.d(80): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n+fail_compilation/fail10968.d(81): Error: struct `fail10968.SD` is not copyable because it has a disabled postblit\n ---\n */\n "}, {"sha": "279d9da6dfc2141eae26f56367525487687745d7", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail16997.d", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail16997.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail16997.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail16997.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -1,25 +1,25 @@\n /*\n-REQUIRED_ARGS: -de\n+REQUIRED_ARGS: -de -revert=intpromote\n TEST_OUTPUT:\n ---\n-fail_compilation/fail16997.d(31): Deprecation: integral promotion not done for `~c`, use '-preview=intpromote' switch or `~cast(int)(c)`\n-fail_compilation/fail16997.d(32): Deprecation: integral promotion not done for `-c`, use '-preview=intpromote' switch or `-cast(int)(c)`\n-fail_compilation/fail16997.d(33): Deprecation: integral promotion not done for `+c`, use '-preview=intpromote' switch or `+cast(int)(c)`\n-fail_compilation/fail16997.d(36): Deprecation: integral promotion not done for `~w`, use '-preview=intpromote' switch or `~cast(int)(w)`\n-fail_compilation/fail16997.d(37): Deprecation: integral promotion not done for `-w`, use '-preview=intpromote' switch or `-cast(int)(w)`\n-fail_compilation/fail16997.d(38): Deprecation: integral promotion not done for `+w`, use '-preview=intpromote' switch or `+cast(int)(w)`\n-fail_compilation/fail16997.d(41): Deprecation: integral promotion not done for `~sb`, use '-preview=intpromote' switch or `~cast(int)(sb)`\n-fail_compilation/fail16997.d(42): Deprecation: integral promotion not done for `-sb`, use '-preview=intpromote' switch or `-cast(int)(sb)`\n-fail_compilation/fail16997.d(43): Deprecation: integral promotion not done for `+sb`, use '-preview=intpromote' switch or `+cast(int)(sb)`\n-fail_compilation/fail16997.d(46): Deprecation: integral promotion not done for `~ub`, use '-preview=intpromote' switch or `~cast(int)(ub)`\n-fail_compilation/fail16997.d(47): Deprecation: integral promotion not done for `-ub`, use '-preview=intpromote' switch or `-cast(int)(ub)`\n-fail_compilation/fail16997.d(48): Deprecation: integral promotion not done for `+ub`, use '-preview=intpromote' switch or `+cast(int)(ub)`\n-fail_compilation/fail16997.d(51): Deprecation: integral promotion not done for `~s`, use '-preview=intpromote' switch or `~cast(int)(s)`\n-fail_compilation/fail16997.d(52): Deprecation: integral promotion not done for `-s`, use '-preview=intpromote' switch or `-cast(int)(s)`\n-fail_compilation/fail16997.d(53): Deprecation: integral promotion not done for `+s`, use '-preview=intpromote' switch or `+cast(int)(s)`\n-fail_compilation/fail16997.d(56): Deprecation: integral promotion not done for `~us`, use '-preview=intpromote' switch or `~cast(int)(us)`\n-fail_compilation/fail16997.d(57): Deprecation: integral promotion not done for `-us`, use '-preview=intpromote' switch or `-cast(int)(us)`\n-fail_compilation/fail16997.d(58): Deprecation: integral promotion not done for `+us`, use '-preview=intpromote' switch or `+cast(int)(us)`\n+fail_compilation/fail16997.d(31): Deprecation: integral promotion not done for `~c`, remove '-revert=intpromote' switch or `~cast(int)(c)`\n+fail_compilation/fail16997.d(32): Deprecation: integral promotion not done for `-c`, remove '-revert=intpromote' switch or `-cast(int)(c)`\n+fail_compilation/fail16997.d(33): Deprecation: integral promotion not done for `+c`, remove '-revert=intpromote' switch or `+cast(int)(c)`\n+fail_compilation/fail16997.d(36): Deprecation: integral promotion not done for `~w`, remove '-revert=intpromote' switch or `~cast(int)(w)`\n+fail_compilation/fail16997.d(37): Deprecation: integral promotion not done for `-w`, remove '-revert=intpromote' switch or `-cast(int)(w)`\n+fail_compilation/fail16997.d(38): Deprecation: integral promotion not done for `+w`, remove '-revert=intpromote' switch or `+cast(int)(w)`\n+fail_compilation/fail16997.d(41): Deprecation: integral promotion not done for `~sb`, remove '-revert=intpromote' switch or `~cast(int)(sb)`\n+fail_compilation/fail16997.d(42): Deprecation: integral promotion not done for `-sb`, remove '-revert=intpromote' switch or `-cast(int)(sb)`\n+fail_compilation/fail16997.d(43): Deprecation: integral promotion not done for `+sb`, remove '-revert=intpromote' switch or `+cast(int)(sb)`\n+fail_compilation/fail16997.d(46): Deprecation: integral promotion not done for `~ub`, remove '-revert=intpromote' switch or `~cast(int)(ub)`\n+fail_compilation/fail16997.d(47): Deprecation: integral promotion not done for `-ub`, remove '-revert=intpromote' switch or `-cast(int)(ub)`\n+fail_compilation/fail16997.d(48): Deprecation: integral promotion not done for `+ub`, remove '-revert=intpromote' switch or `+cast(int)(ub)`\n+fail_compilation/fail16997.d(51): Deprecation: integral promotion not done for `~s`, remove '-revert=intpromote' switch or `~cast(int)(s)`\n+fail_compilation/fail16997.d(52): Deprecation: integral promotion not done for `-s`, remove '-revert=intpromote' switch or `-cast(int)(s)`\n+fail_compilation/fail16997.d(53): Deprecation: integral promotion not done for `+s`, remove '-revert=intpromote' switch or `+cast(int)(s)`\n+fail_compilation/fail16997.d(56): Deprecation: integral promotion not done for `~us`, remove '-revert=intpromote' switch or `~cast(int)(us)`\n+fail_compilation/fail16997.d(57): Deprecation: integral promotion not done for `-us`, remove '-revert=intpromote' switch or `-cast(int)(us)`\n+fail_compilation/fail16997.d(58): Deprecation: integral promotion not done for `+us`, remove '-revert=intpromote' switch or `+cast(int)(us)`\n ---\n */\n "}, {"sha": "b83639b0d08cb37ab364f141adfc8b381f3c27ce", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail809.d", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c60e5075f89265a560eab166d43247624a7535/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail809.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c60e5075f89265a560eab166d43247624a7535/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail809.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail809.d?ref=38c60e5075f89265a560eab166d43247624a7535", "patch": "@@ -1,12 +0,0 @@\n-// REQUIRED_ARGS: -preview=dip1000\n-/*\n-TEST_OUTPUT:\n----\n-fail_compilation/fail809.d(11): Error: scope variable `dg_` may not be returned\n----\n-*/\n-int delegate() test(lazy int dg)\n-{\n-    int delegate() dg_ = &dg;\n-    return dg_;\n-}"}, {"sha": "175ade3cafcac39c597744ab570f986a346da792", "filename": "gcc/testsuite/gdc.test/fail_compilation/fob2.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffob2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffob2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffob2.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -120,7 +120,7 @@ fail_compilation/fob2.d(515): Error: variable `fob2.test52.p` has undefined stat\n }\n \n \n-@live void test52()\n+@live void test52() @safe\n {\n     int x = 5;\n     auto p = &x;"}, {"sha": "c3e8a78e98d7850f9f4eb063d4b6fe965bf6341b", "filename": "gcc/testsuite/gdc.test/fail_compilation/imports/test20023b.d", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Ftest20023b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Ftest20023b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Ftest20023b.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -0,0 +1,10 @@\n+module imports.test20023b;\n+\n+auto threw()() @safe\n+{\n+    try\n+        throw new Exception(\"Hello\");\n+    catch (Exception e)\n+        return e;\n+    assert(0);\n+}"}, {"sha": "64db4c811962eeb83834d2820f0a5a7a26cc743a", "filename": "gcc/testsuite/gdc.test/fail_compilation/retscope.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fretscope.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fretscope.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fretscope.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -14,14 +14,14 @@ fail_compilation/retscope.d(49): Error: address of struct temporary returned by\n \n \n \n-int* foo1(return scope int* p) { return p; } // ok\n+int* foo1(return scope int* p) @safe { return p; } // ok\n \n-int* foo2()(scope int* p) { return p; }  // ok, 'return' is inferred\n+int* foo2()(scope int* p) @safe { return p; }  // ok, 'return' is inferred\n alias foo2a = foo2!();\n \n-int* foo3(scope int* p) { return p; }   // error\n+int* foo3(scope int* p) @safe { return p; }   // error\n \n-int* foo4(bool b)\n+int* foo4(bool b) @safe\n {\n     int i;\n     int j;"}, {"sha": "1b3078ff05194902a6e23c3c2c08079ff4d69b79", "filename": "gcc/testsuite/gdc.test/fail_compilation/test15191.d", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15191.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15191.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15191.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -1,18 +1,52 @@\n /* TEST_OUTPUT:\n+PERMUTE_ARGS -dip1000\n ---\n-fail_compilation/test15191.d(17): Error: cannot take address of `ref return` of `foo()` in `@safe` function `bar`\n+fail_compilation/test15191.d(31): Error: returning `&identity(x)` escapes a reference to local variable `x`\n+fail_compilation/test15191.d(37): Error: returning `&identityPtr(x)` escapes a reference to local variable `x`\n+fail_compilation/test15191.d(43): Error: cannot take address of `ref return` of `identityPtr()` in `@safe` function `addrOfRefTransitive`\n+fail_compilation/test15191.d(43): Error: returning `&identityPtr(x)` escapes a reference to local variable `x`\n ---\n */\n \n-\n // https://issues.dlang.org/show_bug.cgi?id=15191\n+// https://issues.dlang.org/show_bug.cgi?id=22519\n \n-ref int foo(return ref int s)@safe\n+@safe:\n+ref int foo(return ref int s)\n {\n     return s;\n }\n \n-int* bar(return ref int s) @safe\n+int* bar(return ref int s)\n {\n     return &foo(s);\n }\n+\n+ref int identity(ref return int x) {return x;}\n+ref int* identityPtr(ref return int* x) {return x;}\n+\n+int* addrOfRefEscape()\n+{\n+\tint x;\n+\treturn &identity(x);\n+}\n+\n+int** addrOfRefSystem() @system\n+{\n+\tint* x;\n+\treturn &identityPtr(x);\n+}\n+\n+int** addrOfRefTransitive()\n+{\n+\tint* x;\n+\treturn &identityPtr(x);\n+}\n+\n+int gInt;\n+ref int getGlobalInt() {return gInt;}\n+\n+int* addrOfRefGlobal()\n+{\n+\treturn &getGlobalInt();\n+}"}, {"sha": "ff6bc1c44f4f3ede37734da97fc24de4c7edb177", "filename": "gcc/testsuite/gdc.test/fail_compilation/test17977.d", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17977.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17977.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17977.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -0,0 +1,20 @@\n+/*\n+https://issues.dlang.org/show_bug.cgi?id=15399\n+REQUIRED_ARGS: -preview=dip1000\n+TEST_OUTPUT:\n+---\n+fail_compilation/test17977.d(19): Error: address of variable `__slList3` assigned to `elem` with longer lifetime\n+---\n+*/\n+\n+@safe:\n+struct List {\n+    int* data;\n+    ~this();\n+    int* front() return;\n+}\n+\n+void test()\n+{\n+    auto elem = List().front;\n+}"}, {"sha": "909e699d3b5a50e6f570e4c88061ec1feb1e8945", "filename": "gcc/testsuite/gdc.test/fail_compilation/test20023.d", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest20023.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest20023.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest20023.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -0,0 +1,16 @@\n+// REQUIRED_ARGS: -preview=dip1000 -preview=dip1008 -Ifail_compilation/extra-files\n+// https://issues.dlang.org/show_bug.cgi?id=20023\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/imports/test20023b.d(8): Error: scope variable `e` may not be returned\n+fail_compilation/test20023.d(15): Error: template instance `imports.test20023b.threw!()` error instantiating\n+---\n+*/\n+import imports.test20023b;\n+\n+@safe:\n+void main()\n+{\n+    threw!()();\n+}"}, {"sha": "94ff80ad551737c369555084e775883e602f4147", "filename": "gcc/testsuite/gdc.test/fail_compilation/traits_initSymbol.d", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftraits_initSymbol.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftraits_initSymbol.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftraits_initSymbol.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -0,0 +1,63 @@\n+/********************************************\n+TEST_OUTPUT:\n+---\n+fail_compilation/traits_initSymbol.d(105): Error: struct / class type expected as argument to __traits(initSymbol) instead of `int`\n+fail_compilation/traits_initSymbol.d(106): Error: struct / class type expected as argument to __traits(initSymbol) instead of `S[2]`\n+fail_compilation/traits_initSymbol.d(107): Error: struct / class type expected as argument to __traits(initSymbol) instead of `123`\n+---\n+*/\n+#line 100\n+\n+struct S { int i = 4; }\n+\n+void test1()\n+{\n+    const void[] initInt   = __traits(initSymbol, int);\n+    const void[] initArray = __traits(initSymbol, S[2]);\n+    const void[] initValue = __traits(initSymbol, 123);\n+}\n+\n+/********************************************\n+TEST_OUTPUT:\n+---\n+fail_compilation/traits_initSymbol.d(203): Error: cannot determine the address of the initializer symbol during CTFE\n+fail_compilation/traits_initSymbol.d(203):        called from here: `(*function () pure nothrow @nogc @safe => S)()`\n+---\n+*/\n+#line 200\n+\n+void test2()\n+{\n+    enum initLen = (() => __traits(initSymbol, S))();\n+}\n+\n+/********************************************\n+TEST_OUTPUT:\n+---\n+fail_compilation/traits_initSymbol.d(305): Error: struct / class type expected as argument to __traits(initSymbol) instead of `traits_initSymbol.Interface`\n+---\n+*/\n+#line 300\n+\n+interface Interface {}\n+\n+void test3()\n+{\n+    const void[] initInterface = __traits(initSymbol, Interface);\n+}\n+\n+/********************************************\n+TEST_OUTPUT:\n+---\n+fail_compilation/traits_initSymbol.d(404): Error: expected 1 arguments for `initSymbol` but had 0\n+fail_compilation/traits_initSymbol.d(405): Error: expected 1 arguments for `initSymbol` but had 2\n+---\n+*/\n+#line 400\n+\n+\n+void test4()\n+{\n+    const void[] tmp = __traits(initSymbol);\n+    const void[] tmo = __traits(initSymbol, Interface, S);\n+}"}, {"sha": "5700195ccb8f68f4e5dd2e1029421b50a15a71c6", "filename": "gcc/testsuite/gdc.test/runnable/b19294.d", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fb19294.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fb19294.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fb19294.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -0,0 +1,163 @@\n+alias T = MyStruct!float;\n+\n+struct MyStruct(U)\n+{\n+    U x;\n+    U y;\n+\n+    this(U xx, U yy)\n+    {\n+        x = xx;\n+        y = yy;\n+    }\n+\n+    MyStruct!U opBinary(string op)(MyStruct!U z) const\n+    {\n+        alias C = typeof(return);\n+        auto w = C(this.x, this.y);\n+        return w.opOpAssign!(op)(z);\n+    }\n+\n+    MyStruct!U opBinaryRight(string op)(MyStruct!U z) const\n+    {\n+        return opBinary!(op)(z);\n+    }\n+\n+    ref MyStruct opOpAssign(string op, U)(const MyStruct!U z)\n+    {\n+        mixin (\"x \"~op~\"= z.x;\");\n+        mixin (\"y \"~op~\"= z.y;\");\n+        return this;\n+    }\n+\n+    MyStruct!U opBinary(string op, R)(R z) const\n+        if (is(R == int) || is(R == float))\n+    {\n+        alias C = typeof(return);\n+        auto w = C(this.x, this.y);\n+        return w.opOpAssign!(op)(z);\n+    }\n+\n+    MyStruct!U opBinaryRight(string op, R)(R z) const\n+        if (is(R == int) || is(R == float))\n+    {\n+        return opBinary!(op)(z);\n+    }\n+\n+    ref MyStruct opOpAssign(string op, R)(const R z)\n+        if (is(R == int) || is(R == float))\n+    {\n+        mixin (\"x \"~op~\"= z;\");\n+        return this;\n+    }\n+}\n+\n+void main()\n+{\n+    T c = MyStruct!float(1.0f, 1.0f);\n+    T[] arr = [T(1,1), T(2,2), T(3,3), T(4,4), T(5,5), T(6,6)];\n+    T[] result = new T[arr.length];\n+\n+    // part 2\n+\n+    result[0] = c * c;\n+    assert(result[0] == T(1, 1));\n+\n+    result[0] = arr[1] * arr[2];\n+    assert(result[0] == T(6, 6));\n+\n+    int[] intarr = [6, 5, 4, 3, 2, 1];\n+\n+    result[] = arr[] * arr[];\n+    assert(result[] == [T(1, 1), T(4, 4), T(9, 9), T(16, 16), T(25, 25), T(36, 36)]);\n+\n+    result[] = arr[] * 3;\n+    assert(result[] == [T(3, 1), T(6, 2), T(9, 3), T(12, 4), T(15, 5), T(18, 6)]);\n+    result[] = 3 * arr[];\n+    assert(result[] == [T(3, 1), T(6, 2), T(9, 3), T(12, 4), T(15, 5), T(18, 6)]);\n+\n+    result[] = arr[];\n+    result[1..3] = arr[1..3] * 2.0f;\n+    assert(result[] == [T(1, 1), T(4, 2), T(6, 3), T(4, 4), T(5, 5), T(6, 6)]);\n+    result[1..3] = 2.0f * arr[1..3];\n+    assert(result[] == [T(1, 1), T(4, 2), T(6, 3), T(4, 4), T(5, 5), T(6, 6)]);\n+\n+    result[] = arr[];\n+    result[1..$] = arr[1..$] * 2.0f;\n+    assert(result[] == [T(1, 1), T(4, 2), T(6, 3), T(8, 4), T(10, 5), T(12, 6)]);\n+    result[1..$] = 2.0f * arr[1..$];\n+    assert(result[] == [T(1, 1), T(4, 2), T(6, 3), T(8, 4), T(10, 5), T(12, 6)]);\n+\n+    result[] = intarr[] * arr[];\n+    assert(result[] == [T(6, 1), T(10, 2), T(12, 3), T(12, 4), T(10, 5), T(6, 6)]);\n+    result[] = arr[] * intarr[];\n+    assert(result[] == [T(6, 1), T(10, 2), T(12, 3), T(12, 4), T(10, 5), T(6, 6)]);\n+\n+    result[] = intarr[] * T(2,3);\n+    assert(result[] == [T(12, 3), T(10, 3), T(8, 3), T(6, 3), T(4, 3), T(2, 3)]);\n+    result[] = T(2,3) * intarr[];\n+    assert(result[] == [T(12, 3), T(10, 3), T(8, 3), T(6, 3), T(4, 3), T(2, 3)]);\n+\n+    result[] = intarr[] * c;\n+    assert(result[] == [T(6, 1), T(5, 1), T(4, 1), T(3, 1), T(2, 1), T(1, 1)]);\n+    result[] = c * intarr[];\n+    assert(result[] == [T(6, 1), T(5, 1), T(4, 1), T(3, 1), T(2, 1), T(1, 1)]);\n+\n+    result[] = arr[];\n+    result[1..3] = intarr[1..3] * c;\n+    assert(result[] == [T(1, 1), T(5, 1), T(4, 1), T(4, 4), T(5, 5), T(6, 6)]);\n+    result[1..3] = c * intarr[1..3];\n+    assert(result[] == [T(1, 1), T(5, 1), T(4, 1), T(4, 4), T(5, 5), T(6, 6)]);\n+\n+    result[1..$] = intarr[1..$] * c;\n+    assert(result[] == [T(1, 1), T(5, 1), T(4, 1), T(3, 1), T(2, 1), T(1, 1)]);\n+    result[1..$] = c * intarr[1..$];\n+    assert(result[] == [T(1, 1), T(5, 1), T(4, 1), T(3, 1), T(2, 1), T(1, 1)]);\n+\n+    result[] = arr[];\n+    result[1..3] = intarr[1..3] * arr[1..3];\n+    assert(result[] == [T(1, 1), T(10, 2), T(12, 3), T(4, 4), T(5, 5), T(6, 6)]);\n+    result[1..3] = arr[1..3] * intarr[1..3];\n+    assert(result[] == [T(1, 1), T(10, 2), T(12, 3), T(4, 4), T(5, 5), T(6, 6)]);\n+\n+    result[] = [1,2,3,4,5,6] * c;\n+    assert(result[] == [T(1, 1), T(2, 1), T(3, 1), T(4, 1), T(5, 1), T(6, 1)]);\n+    result[] = c * [1,2,3,4,5,6];\n+    assert(result[] == [T(1, 1), T(2, 1), T(3, 1), T(4, 1), T(5, 1), T(6, 1)]);\n+\n+    result[] = arr[] * [1,2,3,4,5,6];\n+    assert(result[] == [T(1, 1), T(4, 2), T(9, 3), T(16, 4), T(25, 5), T(36, 6)]);\n+    result[] = [1,2,3,4,5,6] *  arr[];\n+    assert(result[] == [T(1, 1), T(4, 2), T(9, 3), T(16, 4), T(25, 5), T(36, 6)]);\n+\n+    result[] = [c, 2 * c, 3 * c, 4 * c, 5 * c, 6 * c] * [c, 2 * c, 3 * c, 4 * c, 5 * c, 6 * c];\n+    assert(result[] == [T(1, 1), T(4, 1), T(9, 1), T(16, 1), T(25, 1), T(36, 1)]);\n+\n+    result[] = [c, 2 * c, 3 * c, 4 * c, 5 * c, 6 * c] * [1,2,3,4,5,6];\n+    assert(result[] == [T(1, 1), T(4, 1), T(9, 1), T(16, 1), T(25, 1), T(36, 1)]);\n+    result[] = [1,2,3,4,5,6] * [c, 2 * c, 3 * c, 4 * c, 5 * c, 6 * c];\n+    assert(result[] == [T(1, 1), T(4, 1), T(9, 1), T(16, 1), T(25, 1), T(36, 1)]);\n+\n+    result[] = arr[] * c;\n+    assert(result[] == [T(1, 1), T(2, 2), T(3, 3), T(4, 4), T(5, 5), T(6, 6)]);\n+    result[] = c * arr[];\n+    assert(result[] == [T(1, 1), T(2, 2), T(3, 3), T(4, 4), T(5, 5), T(6, 6)]);\n+\n+    result[] = c * 3.0f * arr[];\n+    assert(result[] == [T(3, 1), T(6, 2), T(9, 3), T(12, 4), T(15, 5), T(18, 6)]);\n+    result[] = 3.0f * c * arr[];\n+    assert(result[] == [T(3, 1), T(6, 2), T(9, 3), T(12, 4), T(15, 5), T(18, 6)]);\n+\n+    result[] = arr[] * 3.0f * c;\n+    assert(result[] == [T(3, 1), T(6, 2), T(9, 3), T(12, 4), T(15, 5), T(18, 6)]);\n+    // result[] = arr[] * c * 3.0f; //not ok\n+    // assert(result[] == [T(3, 1), T(6, 2), T(9, 3), T(12, 4), T(15, 5), T(18, 6)]);\n+\n+    result[] = 3.0f * arr[] * c;\n+    assert(result[] == [T(3, 1), T(6, 2), T(9, 3), T(12, 4), T(15, 5), T(18, 6)]);\n+    // result[] = c * arr[] * 3.0f; //not ok\n+    // assert(result[] == [T(3, 1), T(6, 2), T(9, 3), T(12, 4), T(15, 5), T(18, 6)]);\n+\n+    result[] = c * arr[] * c;\n+    assert(result[] == [T(1, 1), T(2, 2), T(3, 3), T(4, 4), T(5, 5), T(6, 6)]);\n+}"}, {"sha": "30aa9503b09caa8732dc7f18fa62934208c96854", "filename": "gcc/testsuite/gdc.test/runnable/mars1.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fmars1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fmars1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fmars1.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -1,5 +1,5 @@\n /*\n-REQUIRED_ARGS: -mcpu=native -preview=intpromote\n+REQUIRED_ARGS: -mcpu=native\n PERMUTE_ARGS: -O -inline -release\n */\n "}, {"sha": "87e25600d8b736c925c50f0631df06d8b7bee63c", "filename": "gcc/testsuite/gdc.test/runnable/test15862.d", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest15862.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest15862.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest15862.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -0,0 +1,39 @@\n+// https://issues.dlang.org/show_bug.cgi?id=15862\n+\n+/*\n+PERMUTE_ARGS:\n+REQUIRED_ARGS: -O -release\n+*/\n+\n+\n+int* p() pure nothrow {return new int;}\n+int[] a() pure nothrow {return [0];}\n+Object o() pure nothrow {return new Object;}\n+\n+auto pa() pure nothrow {return new int;}\n+\n+void main()\n+{\n+    {\n+        int* p1 = p();\n+        int* p2 = p();\n+\n+        if (p1 is p2) assert(0);\n+\n+        int[] a1 = a();\n+        int[] a2 = a();\n+\n+        if (a1 is a2) assert(0);\n+\n+        Object o1 = o();\n+        Object o2 = o();\n+\n+        if (o1 is o2) assert(0);\n+    }\n+    {\n+        auto p1 = pa();\n+        auto p2 = pa();\n+\n+        if (p1 is p2) assert(0);\n+    }\n+}"}, {"sha": "96e8d6c66d1caaade5abc57ce2389dc50200f998", "filename": "gcc/testsuite/gdc.test/runnable/test21367.d", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest21367.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest21367.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest21367.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -0,0 +1,47 @@\n+// https://issues.dlang.org/show_bug.cgi?id=21367\n+\n+string result = \"\";\n+\n+struct RCArray(T)\n+{\n+    T* data;\n+    this(this)\n+    {\n+        result ~= \"A\";\n+    }\n+    ~this()\n+    {\n+        result ~= \"B\";\n+    }\n+}\n+\n+struct Variant(T...)\n+{\n+    union\n+    {\n+        T payload;\n+    }\n+    this(this)\n+    {\n+        result ~= \"C\";\n+    }\n+\n+    ~this()\n+    {\n+        result ~= \"D\";\n+    }\n+}\n+\n+alias Ft = Variant!(RCArray!double, RCArray!int);\n+\n+void fun(Ft a) {}\n+void main()\n+{\n+    Ft a;\n+    Ft b = a;\n+}\n+\n+static ~this()\n+{\n+    assert(result == \"CDD\");\n+}"}, {"sha": "7ef53c37a60e8439a0d439b9f581041734461de3", "filename": "gcc/testsuite/gdc.test/runnable/test22227.d", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest22227.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest22227.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest22227.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -0,0 +1,16 @@\n+// REQUIRED_ARGS: -debug -O -release\n+// https://issues.dlang.org/show_bug.cgi?id=22277\n+\n+bool secret = false;\n+\n+void free(immutable void* x) pure nothrow\n+{\n+    debug secret = true;\n+}\n+\n+void main()\n+{\n+    free(null);\n+    if (!secret)\n+        assert(0);\n+}"}, {"sha": "285365eea82e36b53254a724e6a9a63f49dccbd3", "filename": "gcc/testsuite/gdc.test/runnable/testOpApply.d", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2FtestOpApply.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2FtestOpApply.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2FtestOpApply.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -1,4 +1,4 @@\n-/* PERMUTE_ARGS:\n+/* PERMUTE_ARGS: -preview=dip1000\n  */\n \n // https://issues.dlang.org/show_bug.cgi?id=15624\n@@ -140,3 +140,32 @@ void testInverseAttributes()\n     }\n     safe();\n }\n+\n+// https://issues.dlang.org/show_bug.cgi?id=20907\n+Lockstep!() lockstep()\n+{\n+    return Lockstep!()();\n+}\n+\n+struct Lockstep()\n+{\n+    int opApply(int delegate(int) callback) @system\n+    {\n+        return 0;\n+    }\n+\n+    int opApply(int delegate(int) pure nothrow @nogc @safe callback) pure nothrow @nogc @safe\n+    {\n+        return 0;\n+    }\n+}\n+\n+void foo0()\n+{\n+    foreach (x; lockstep()) {}\n+}\n+\n+void foo1()\n+{\n+    foreach (x; lockstep()) {}\n+}"}, {"sha": "617e3fb11cc058aff7b4180d5664e5a076d7fdc3", "filename": "gcc/testsuite/gdc.test/runnable/testcgelem.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestcgelem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestcgelem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestcgelem.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -1,5 +1,5 @@\n /*\n-REQUIRED_ARGS: -mcpu=native -preview=intpromote\n+REQUIRED_ARGS: -mcpu=native\n PERMUTE_ARGS: -O -inline -release\n */\n "}, {"sha": "764bb1b045e6e86fc546d40a042ca6b2c9b5a2b3", "filename": "gcc/testsuite/gdc.test/runnable/testconst.d", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestconst.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestconst.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestconst.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -2860,9 +2860,11 @@ static assert(is(S7038b == shared));\n immutable struct S7038c{ int x; }\n static assert(is(S7038c == immutable));\n \n-static assert(!is(C7038 == const));\n+// https://issues.dlang.org/show_bug.cgi?id=22515\n+// Classes fixed for consistency with structs\n+static assert(is(C7038 == const));\n const class C7038{ int x; }\n-static assert(!is(C7038 == const));\n+static assert(is(C7038 == const));\n \n void test7038()\n {\n@@ -2871,7 +2873,7 @@ void test7038()\n     static assert(is(typeof(s.x) == const int));\n \n     C7038 c;\n-    static assert(!is(typeof(c) == const));\n+    static assert(is(typeof(c) == const));\n     static assert(is(typeof(c.x) == const int));\n }\n "}, {"sha": "0385d98c8ffe4ecd18e1ef7a11c348fd8ba2913e", "filename": "gcc/testsuite/gdc.test/runnable/traits_initSymbol.d", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftraits_initSymbol.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftraits_initSymbol.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftraits_initSymbol.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -0,0 +1,119 @@\n+struct Zero\n+{\n+    int x;\n+}\n+\n+void testZero()\n+{\n+    auto zeroInit = __traits(initSymbol, Zero);\n+    static assert(is(typeof(zeroInit) == const(void[])));\n+\n+    assert(zeroInit.ptr is null);\n+    assert(zeroInit.length == Zero.sizeof);\n+}\n+\n+struct NonZero\n+{\n+    long x = 1;\n+}\n+\n+void testNonZero()\n+{\n+    auto nonZeroInit = __traits(initSymbol, NonZero);\n+    static assert(is(typeof(nonZeroInit) == const(void[])));\n+\n+    assert(nonZeroInit.ptr);\n+    assert(nonZeroInit.length == NonZero.sizeof);\n+    assert(cast(const(long[])) nonZeroInit == [1L]);\n+}\n+\n+class C\n+{\n+    short x = 123;\n+}\n+\n+void testClass()\n+{\n+    auto cInit = __traits(initSymbol, C);\n+    static assert(is(typeof(cInit) == const(void[])));\n+\n+    assert(cInit.ptr);\n+    assert(cInit.length == __traits(classInstanceSize, C));\n+\n+    scope c = new C;\n+    assert((cast(void*) c)[0 .. cInit.length] == cInit);\n+}\n+\n+struct AlignedStruct\n+{\n+    short s = 5;\n+    // 2 byte padding\n+    align(4) char c = 'c';\n+    // 3 byte padding\n+    int i = 4;\n+    // reduced alignment\n+    align(1) long l = 0xDEADBEEF;\n+}\n+\n+void testAlignedStruct()\n+{\n+    auto init = __traits(initSymbol, AlignedStruct);\n+\n+    assert(init.ptr);\n+    assert(init.length == AlignedStruct.sizeof);\n+\n+    version (GNU)\n+        AlignedStruct exp = AlignedStruct();\n+    else\n+        AlignedStruct exp;\n+    assert(init == (cast(void*) &exp)[0 .. AlignedStruct.sizeof]);\n+\n+}\n+\n+class AlignedClass : C\n+{\n+    short s = 5;\n+    // 2 byte padding\n+    align(4) char c = 'c';\n+    // 3 byte padding\n+    int i = 4;\n+    // reduced alignment\n+    align(1) long l = 0xDEADBEEF;\n+}\n+\n+void testAlignedClass()\n+{\n+    auto init = __traits(initSymbol, AlignedClass);\n+\n+    assert(init.ptr);\n+    assert(init.length == __traits(classInstanceSize, AlignedClass));\n+\n+    scope ac = new AlignedClass();\n+    assert(init == (cast(void*) ac)[0 .. init.length]);\n+}\n+\n+extern (C++) class ExternCppClass\n+{\n+    int i = 4;\n+}\n+\n+void testExternCppClass()\n+{\n+    auto init = __traits(initSymbol, ExternCppClass);\n+\n+    assert(init.ptr);\n+    assert(init.length == __traits(classInstanceSize, ExternCppClass));\n+\n+    scope ac = new ExternCppClass();\n+    assert(init == (cast(void*) ac)[0 .. init.length]);\n+}\n+\n+void main()\n+{\n+    testZero();\n+    testNonZero();\n+    testClass();\n+    testAlignedStruct();\n+    testAlignedClass();\n+    testExternCppClass();\n+}"}, {"sha": "4fe6b00eba72360f5b7f0e8922feac16b3384112", "filename": "gcc/testsuite/gdc.test/runnable/xtest46.d", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fxtest46.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fxtest46.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fxtest46.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -4903,7 +4903,7 @@ static assert(is(typeof(S5933d.x) == FuncType5933));\n \n \n class C5933a { auto x() { return 0; } }\n-static assert(is(typeof(&(new C5933b()).x) == int delegate()));\n+static assert(is(typeof(&(new C5933b()).x) == int delegate() pure nothrow @nogc @safe));\n \n class C5933b { auto x() { return 0; } }\n //static assert(is(typeof((new C5933b()).x) == FuncType5933));\n@@ -7923,8 +7923,9 @@ void test17349()\n {\n     static struct S\n     {\n-        int bar(void delegate(ref int*)) { return 1; }\n-        int bar(void delegate(ref const int*)) const { return 2; }\n+        // Specify attribute inferred for dg1/dg2\n+        int bar(void delegate(ref int*) pure nothrow @nogc @safe) { return 1; }\n+        int bar(void delegate(ref const int*) pure nothrow @nogc @safe) const { return 2; }\n     }\n \n     void dg1(ref int*) { }"}, {"sha": "f3a9a8552a941aecab9810396b0f9702b5ae0fc8", "filename": "gcc/testsuite/gdc.test/runnable_cxx/extra-files/cpp7925.cpp", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fextra-files%2Fcpp7925.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fextra-files%2Fcpp7925.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fextra-files%2Fcpp7925.cpp?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -0,0 +1,103 @@\n+#include <stdarg.h>\n+#include <assert.h>\n+\n+class C1\n+{\n+public:\n+    virtual ~C1();\n+\n+    int i;\n+\n+    int f0();\n+    int f1(int a);\n+    int f2(int a, int b);\n+    virtual int f3(int a, int b);\n+    int f4(int a, ...);\n+};\n+\n+C1::~C1()\n+{\n+}\n+\n+int C1::f0()\n+{\n+    return i;\n+}\n+\n+int C1::f1(int a)\n+{\n+    return i + a;\n+}\n+\n+int C1::f2(int a, int b)\n+{\n+    return i + a + b;\n+}\n+\n+int C1::f3(int a, int b)\n+{\n+    return i + a + b;\n+}\n+\n+int C1::f4(int a, ...)\n+{\n+    int r = i + a;\n+    int last = a;\n+\n+    va_list argp;\n+    va_start(argp, a);\n+    while (last)\n+    {\n+        last = va_arg(argp, int);\n+        r += last;\n+    }\n+    va_end(argp);\n+    return r;\n+}\n+\n+C1 *createC1()\n+{\n+    return new C1();\n+}\n+\n+class C2\n+{\n+public:\n+    virtual ~C2();\n+\n+    int i;\n+\n+    int f0();\n+    int f1(int a);\n+    int f2(int a, int b);\n+    virtual int f3(int a, int b);\n+    int f4(int a, ...);\n+};\n+\n+C2 *createC2();\n+\n+void runCPPTests()\n+{\n+    C2 *c2 = createC2();\n+    c2->i = 100;\n+    assert(c2->f0() == 100);\n+    assert(c2->f1(1) == 101);\n+    assert(c2->f2(20, 3) == 123);\n+    assert(c2->f3(20, 3) == 123);\n+    assert(c2->f4(20, 3, 0) == 123);\n+\n+    int (C2::*fp0)() = &C2::f0;\n+    int (C2::*fp1)(int) = &C2::f1;\n+    int (C2::*fp2)(int, int) = &C2::f2;\n+    int (C2::*fp3)(int, int) = &C2::f3;\n+#ifndef __DMC__\n+    int (C2::*fp4)(int, ...) = &C2::f4;\n+#endif\n+    assert((c2->*(fp0))() == 100);\n+    assert((c2->*(fp1))(1) == 101);\n+    assert((c2->*(fp2))(20, 3) == 123);\n+    assert((c2->*(fp3))(20, 3) == 123);\n+#ifndef __DMC__\n+    assert((c2->*(fp4))(20, 3, 0) == 123);\n+#endif\n+}"}, {"sha": "2f52826bc4f1721a3b20082b06eb1ffd624ae9af", "filename": "gcc/testsuite/gdc.test/runnable_cxx/test7925.d", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Ftest7925.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Ftest7925.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Ftest7925.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -0,0 +1,151 @@\n+// EXTRA_CPP_SOURCES: cpp7925.cpp\n+\n+/*\n+Exclude -O due to a codegen bug on OSX:\n+https://issues.dlang.org/show_bug.cgi?id=22556\n+\n+PERMUTE_ARGS(osx): -inline -release -g\n+*/\n+\n+import core.vararg;\n+\n+extern(C++) class C1\n+{\n+public:\n+    ~this();\n+\n+    int i;\n+\n+    final int f0();\n+    final int f1(int a);\n+    final int f2(int a, int b);\n+    int f3(int a, int b);\n+    final int f4(int a, ...);\n+};\n+\n+extern(C++) C1 createC1();\n+\n+extern(C++) class C2\n+{\n+public:\n+    ~this()\n+    {\n+    }\n+\n+    int i;\n+\n+    final int f0()\n+    {\n+        return i;\n+    }\n+\n+    final int f1(int a)\n+    {\n+        return i + a;\n+    }\n+\n+    final int f2(int a, int b)\n+    {\n+        return i + a + b;\n+    }\n+\n+    int f3(int a, int b)\n+    {\n+        return i + a + b;\n+    }\n+\n+    final int f4(int a, ...)\n+    {\n+        int r = i + a;\n+        int last = a;\n+\n+        va_list argp;\n+        va_start(argp, a);\n+        while (last)\n+        {\n+            last = va_arg!int(argp);\n+            r += last;\n+        }\n+        va_end(argp);\n+        return r;\n+    }\n+};\n+\n+extern(C++) C2 createC2()\n+{\n+    return new C2;\n+}\n+\n+auto callMember(alias F, Params...)(__traits(parent, F) obj, Params params)\n+{\n+    static if(__traits(getFunctionVariadicStyle, F) == \"stdarg\")\n+        enum varargSuffix = \", ...\";\n+    else\n+        enum varargSuffix = \"\";\n+\n+    static if(is(typeof(&F) R == return) && is(typeof(F) P == __parameters))\n+        mixin(\"extern(\" ~ __traits(getLinkage, F) ~ \") R delegate(P\" ~ varargSuffix ~ \") dg;\");\n+    dg.funcptr = &F;\n+    dg.ptr = cast(void*)obj;\n+    return dg(params);\n+}\n+\n+extern(C++) void runCPPTests();\n+\n+void main()\n+{\n+    C1 c1 = createC1();\n+    c1.i = 100;\n+    assert(c1.f0() == 100);\n+    assert(c1.f1(1) == 101);\n+    assert(c1.f2(20, 3) == 123);\n+    assert(c1.f3(20, 3) == 123);\n+    assert(c1.f4(20, 3, 0) == 123);\n+\n+    auto dg0 = &c1.f0;\n+    auto dg1 = &c1.f1;\n+    auto dg2 = &c1.f2;\n+    auto dg3 = &c1.f3;\n+    auto dg4 = &c1.f4;\n+    assert(dg0() == 100);\n+    assert(dg1(1) == 101);\n+    assert(dg2(20, 3) == 123);\n+    assert(dg3(20, 3) == 123);\n+    assert(dg4(20, 3, 0) == 123);\n+\n+    assert(callMember!(C1.f0)(c1) == 100);\n+    assert(callMember!(C1.f1)(c1, 1) == 101);\n+    assert(callMember!(C1.f2)(c1, 20, 3) == 123);\n+    assert(callMember!(C1.f3)(c1, 20, 3) == 123);\n+    assert(callMember!(C1.f4)(c1, 20, 3, 0) == 123);\n+\n+    int i;\n+    extern(C++) void delegate() lamdba1 = () {\n+        i = 5;\n+    };\n+    lamdba1();\n+    assert(i == 5);\n+\n+    extern(C++) int function(int, int) lamdba2 = (int a, int b) {\n+        return a + b;\n+    };\n+    assert(lamdba2(3, 4) == 7);\n+\n+    extern(C++) void delegate(int, ...) lamdba3 = (int a, ...) {\n+        i = a;\n+        int last = a;\n+\n+        va_list argp;\n+        va_start(argp, a);\n+        while (last)\n+        {\n+            last = va_arg!int(argp);\n+            i += last;\n+        }\n+        va_end(argp);\n+    };\n+    lamdba3(1000, 200, 30, 4, 0);\n+    assert(i == 1234);\n+\n+    runCPPTests();\n+}"}, {"sha": "edb101758b8d373a81aac6c718ec2f3c300c500d", "filename": "libphobos/libdruntime/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMERGE?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -1,4 +1,4 @@\n-178c44ff362902af589603767055cfac89215652\n+bc58b1e9ea68051af9094651a26313371297b79f\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/druntime repository."}, {"sha": "224d06e78ca7905bf349c3bd6f41994a7f8609a8", "filename": "libphobos/libdruntime/Makefile.am", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.am?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -280,9 +280,8 @@ DRUNTIME_DSOURCES_LINUX = core/sys/linux/config.d \\\n \tcore/sys/linux/sys/procfs.d core/sys/linux/sys/signalfd.d \\\n \tcore/sys/linux/sys/socket.d core/sys/linux/sys/sysinfo.d \\\n \tcore/sys/linux/sys/time.d core/sys/linux/sys/xattr.d \\\n-\tcore/sys/linux/syscalls.d core/sys/linux/termios.d \\\n-\tcore/sys/linux/time.d core/sys/linux/timerfd.d core/sys/linux/tipc.d \\\n-\tcore/sys/linux/unistd.d\n+\tcore/sys/linux/termios.d core/sys/linux/time.d \\\n+\tcore/sys/linux/timerfd.d core/sys/linux/tipc.d core/sys/linux/unistd.d\n \n DRUNTIME_DSOURCES_NETBSD = core/sys/netbsd/dlfcn.d \\\n \tcore/sys/netbsd/err.d core/sys/netbsd/execinfo.d \\"}, {"sha": "bb936ddc1fff25aeb9ff107f1a8fac6f6f421ab1", "filename": "libphobos/libdruntime/Makefile.in", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.in?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -367,9 +367,9 @@ am__objects_18 = core/sys/linux/config.lo core/sys/linux/dlfcn.lo \\\n \tcore/sys/linux/sys/procfs.lo core/sys/linux/sys/signalfd.lo \\\n \tcore/sys/linux/sys/socket.lo core/sys/linux/sys/sysinfo.lo \\\n \tcore/sys/linux/sys/time.lo core/sys/linux/sys/xattr.lo \\\n-\tcore/sys/linux/syscalls.lo core/sys/linux/termios.lo \\\n-\tcore/sys/linux/time.lo core/sys/linux/timerfd.lo \\\n-\tcore/sys/linux/tipc.lo core/sys/linux/unistd.lo\n+\tcore/sys/linux/termios.lo core/sys/linux/time.lo \\\n+\tcore/sys/linux/timerfd.lo core/sys/linux/tipc.lo \\\n+\tcore/sys/linux/unistd.lo\n @DRUNTIME_OS_LINUX_TRUE@am__objects_19 = $(am__objects_18)\n am__objects_20 = core/sys/windows/accctrl.lo \\\n \tcore/sys/windows/aclapi.lo core/sys/windows/aclui.lo \\\n@@ -944,9 +944,8 @@ DRUNTIME_DSOURCES_LINUX = core/sys/linux/config.d \\\n \tcore/sys/linux/sys/procfs.d core/sys/linux/sys/signalfd.d \\\n \tcore/sys/linux/sys/socket.d core/sys/linux/sys/sysinfo.d \\\n \tcore/sys/linux/sys/time.d core/sys/linux/sys/xattr.d \\\n-\tcore/sys/linux/syscalls.d core/sys/linux/termios.d \\\n-\tcore/sys/linux/time.d core/sys/linux/timerfd.d core/sys/linux/tipc.d \\\n-\tcore/sys/linux/unistd.d\n+\tcore/sys/linux/termios.d core/sys/linux/time.d \\\n+\tcore/sys/linux/timerfd.d core/sys/linux/tipc.d core/sys/linux/unistd.d\n \n DRUNTIME_DSOURCES_NETBSD = core/sys/netbsd/dlfcn.d \\\n \tcore/sys/netbsd/err.d core/sys/netbsd/execinfo.d \\\n@@ -1675,7 +1674,6 @@ core/sys/linux/sys/socket.lo: core/sys/linux/sys/$(am__dirstamp)\n core/sys/linux/sys/sysinfo.lo: core/sys/linux/sys/$(am__dirstamp)\n core/sys/linux/sys/time.lo: core/sys/linux/sys/$(am__dirstamp)\n core/sys/linux/sys/xattr.lo: core/sys/linux/sys/$(am__dirstamp)\n-core/sys/linux/syscalls.lo: core/sys/linux/$(am__dirstamp)\n core/sys/linux/termios.lo: core/sys/linux/$(am__dirstamp)\n core/sys/linux/time.lo: core/sys/linux/$(am__dirstamp)\n core/sys/linux/timerfd.lo: core/sys/linux/$(am__dirstamp)"}, {"sha": "1915fb0844ad5d619bb304147e47a41559d6eec3", "filename": "libphobos/libdruntime/core/demangle.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fdemangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fdemangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fdemangle.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -54,13 +54,13 @@ pure @safe:\n     enum AddType { no, yes }\n \n \n-    this( return const(char)[] buf_, return char[] dst_ = null )\n+    this( return scope const(char)[] buf_, return scope char[] dst_ = null )\n     {\n         this( buf_, AddType.yes, dst_ );\n     }\n \n \n-    this( return const(char)[] buf_, AddType addType_, return char[] dst_ = null )\n+    this( return scope const(char)[] buf_, AddType addType_, return scope char[] dst_ = null )\n     {\n         buf     = buf_;\n         addType = addType_;\n@@ -105,7 +105,7 @@ pure @safe:\n         //throw new ParseException( msg );\n         debug(info) printf( \"error: %.*s\\n\", cast(int) msg.length, msg.ptr );\n         throw __ctfe ? new ParseException(msg)\n-                     : cast(ParseException) cast(void*) typeid(ParseException).initializer;\n+                     : cast(ParseException) __traits(initSymbol, ParseException).ptr;\n \n     }\n \n@@ -116,7 +116,7 @@ pure @safe:\n \n         //throw new OverflowException( msg );\n         debug(info) printf( \"overflow: %.*s\\n\", cast(int) msg.length, msg.ptr );\n-        throw cast(OverflowException) cast(void*) typeid(OverflowException).initializer;\n+        throw cast(OverflowException) __traits(initSymbol, OverflowException).ptr;\n     }\n \n "}, {"sha": "ae71f513129ddc8c9ba027e0427c121f16b56fbb", "filename": "libphobos/libdruntime/core/internal/array/construction.d", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fconstruction.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fconstruction.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fconstruction.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -14,16 +14,27 @@ import core.internal.traits : Unqual;\n /**\n  * Does array initialization (not assignment) from another array of the same element type.\n  * Params:\n+ *  to = what array to initialize\n  *  from = what data the array should be initialized with\n+ *  makeWeaklyPure = unused; its purpose is to prevent the function from becoming\n+ *      strongly pure and risk being optimised out\n  * Returns:\n  *  The created and initialized array `to`\n  * Bugs:\n  *  This function template was ported from a much older runtime hook that bypassed safety,\n  *  purity, and throwabilty checks. To prevent breaking existing code, this function template\n  *  is temporarily declared `@trusted` until the implementation can be brought up to modern D expectations.\n+ *\n+ *  The third parameter is never used, but is necessary in order for the\n+ *  function be treated as weakly pure, instead of strongly pure.\n+ *  This is needed because constructions such as the one below can be ignored by\n+ *  the compiler if `_d_arrayctor` is believed to be pure, because purity would\n+ *  mean the call to `_d_arrayctor` has no effects (no side effects and the\n+ *  return value is ignored), despite it actually modifying the contents of `a`.\n+ *      const S[2] b;\n+ *      const S[2] a = b;  // this would get lowered to _d_arrayctor(a, b)\n  */\n-Tarr1 _d_arrayctor(Tarr1 : T1[], Tarr2 : T2[], T1, T2)(scope Tarr2 from) @trusted\n-    if (is(Unqual!T1 == Unqual!T2))\n+Tarr _d_arrayctor(Tarr : T[], T)(return scope Tarr to, scope Tarr from, char* makeWeaklyPure = null) @trusted\n {\n     pragma(inline, false);\n     import core.internal.traits : hasElaborateCopyConstructor;\n@@ -32,14 +43,12 @@ Tarr1 _d_arrayctor(Tarr1 : T1[], Tarr2 : T2[], T1, T2)(scope Tarr2 from) @truste\n     import core.stdc.stdint : uintptr_t;\n     debug(PRINTF) import core.stdc.stdio : printf;\n \n-    debug(PRINTF) printf(\"_d_arrayctor(to = %p,%d, from = %p,%d) size = %d\\n\", from.ptr, from.length, to.ptr, to.length, T1.tsize);\n+    debug(PRINTF) printf(\"_d_arrayctor(from = %p,%d) size = %d\\n\", from.ptr, from.length, T.sizeof);\n \n-    Tarr1 to = void;\n+    void[] vFrom = (cast(void*) from.ptr)[0..from.length];\n+    void[] vTo = (cast(void*) to.ptr)[0..to.length];\n \n-    void[] vFrom = (cast(void*)from.ptr)[0..from.length];\n-    void[] vTo = (cast(void*)to.ptr)[0..to.length];\n-\n-    // Force `enforceRawArraysConformable` to be `pure`\n+    // Force `enforceRawArraysConformable` to remain weakly `pure`\n     void enforceRawArraysConformable(const char[] action, const size_t elementSize,\n         const void[] a1, const void[] a2) @trusted\n     {\n@@ -50,9 +59,9 @@ Tarr1 _d_arrayctor(Tarr1 : T1[], Tarr2 : T2[], T1, T2)(scope Tarr2 from) @truste\n         (cast(Type)&enforceRawArraysConformableNogc)(action, elementSize, a1, a2, false);\n     }\n \n-    enforceRawArraysConformable(\"initialization\", T1.sizeof, vFrom, vTo);\n+    enforceRawArraysConformable(\"initialization\", T.sizeof, vFrom, vTo);\n \n-    static if (hasElaborateCopyConstructor!T1)\n+    static if (hasElaborateCopyConstructor!T)\n     {\n         size_t i;\n         try\n@@ -66,7 +75,7 @@ Tarr1 _d_arrayctor(Tarr1 : T1[], Tarr2 : T2[], T1, T2)(scope Tarr2 from) @truste\n             */\n             while (i--)\n             {\n-                auto elem = cast(Unqual!T1*)&to[i];\n+                auto elem = cast(Unqual!T*) &to[i];\n                 destroy(*elem);\n             }\n \n@@ -76,7 +85,7 @@ Tarr1 _d_arrayctor(Tarr1 : T1[], Tarr2 : T2[], T1, T2)(scope Tarr2 from) @truste\n     else\n     {\n         // blit all elements at once\n-        memcpy(cast(void*) to.ptr, from.ptr, to.length * T1.sizeof);\n+        memcpy(cast(void*) to.ptr, from.ptr, to.length * T.sizeof);\n     }\n \n     return to;\n@@ -94,7 +103,7 @@ Tarr1 _d_arrayctor(Tarr1 : T1[], Tarr2 : T2[], T1, T2)(scope Tarr2 from) @truste\n \n     S[4] arr1;\n     S[4] arr2 = [S(0), S(1), S(2), S(3)];\n-    arr1 = _d_arrayctor!(typeof(arr1))(arr2[]);\n+    _d_arrayctor(arr1[], arr2[]);\n \n     assert(counter == 4);\n     assert(arr1 == arr2);\n@@ -117,7 +126,7 @@ Tarr1 _d_arrayctor(Tarr1 : T1[], Tarr2 : T2[], T1, T2)(scope Tarr2 from) @truste\n \n     S[4] arr1;\n     S[4] arr2 = [S(0), S(1), S(2), S(3)];\n-    arr1 = _d_arrayctor!(typeof(arr1))(arr2[]);\n+    _d_arrayctor(arr1[], arr2[]);\n \n     assert(counter == 4);\n     assert(arr1 == arr2);\n@@ -143,7 +152,7 @@ Tarr1 _d_arrayctor(Tarr1 : T1[], Tarr2 : T2[], T1, T2)(scope Tarr2 from) @truste\n     {\n         Throw[4] a;\n         Throw[4] b = [Throw(1), Throw(2), Throw(3), Throw(4)];\n-        a = _d_arrayctor!(typeof(a))(b[]);\n+        _d_arrayctor(a[], b[]);\n     }\n     catch (Exception)\n     {\n@@ -168,7 +177,7 @@ Tarr1 _d_arrayctor(Tarr1 : T1[], Tarr2 : T2[], T1, T2)(scope Tarr2 from) @truste\n     {\n         NoThrow[4] a;\n         NoThrow[4] b = [NoThrow(1), NoThrow(2), NoThrow(3), NoThrow(4)];\n-        a = _d_arrayctor!(typeof(a))(b[]);\n+        _d_arrayctor(a[], b[]);\n     }\n     catch (Exception)\n     {\n@@ -274,7 +283,7 @@ void _d_arraysetctor(Tarr : T[], T)(scope Tarr p, scope ref T value) @trusted\n     {\n         Throw[4] a;\n         Throw[4] b = [Throw(1), Throw(2), Throw(3), Throw(4)];\n-        a = _d_arrayctor!(typeof(a))(b[]);\n+        _d_arrayctor(a[], b[]);\n     }\n     catch (Exception)\n     {"}, {"sha": "a876fcc537f8b740ab01cb572375792262d02dbf", "filename": "libphobos/libdruntime/core/internal/convert.d", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fconvert.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fconvert.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fconvert.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -801,7 +801,7 @@ const(ubyte)[] toUbyte(T)(const ref T val) if (is(T == delegate) || is(T : V*, V\n }\n \n @trusted pure nothrow @nogc\n-const(ubyte)[] toUbyte(T)(const ref return scope T val) if (is(T == struct) || is(T == union))\n+const(ubyte)[] toUbyte(T)(const return ref scope T val) if (is(T == struct) || is(T == union))\n {\n     if (__ctfe)\n     {\n@@ -826,7 +826,11 @@ const(ubyte)[] toUbyte(T)(const ref return scope T val) if (is(T == struct) || i\n     }\n     else\n     {\n-        return (cast(const(ubyte)*)&val)[0 .. T.sizeof];\n+        // We're escaping a reference to `val` here because we cannot express\n+        // ref return + scope, it's currently seen as ref + return scope\n+        // https://issues.dlang.org/show_bug.cgi?id=22541\n+        // Once fixed, the @system lambda should be removed\n+        return (() @system => (cast(const(ubyte)*)&val)[0 .. T.sizeof])();\n     }\n }\n "}, {"sha": "a7446debae656495e63369bd5240832750a6da95", "filename": "libphobos/libdruntime/core/internal/lifetime.d", "status": "modified", "additions": 20, "deletions": 29, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Finternal%2Flifetime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Finternal%2Flifetime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Flifetime.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -89,44 +89,35 @@ Emplaces T.init.\n In contrast to `emplaceRef(chunk)`, there are no checks for disabled default\n constructors etc.\n +/\n-template emplaceInitializer(T)\n+void emplaceInitializer(T)(scope ref T chunk) nothrow pure @trusted\n if (!is(T == const) && !is(T == immutable) && !is(T == inout))\n {\n-    import core.internal.traits : hasElaborateAssign, Unqual;\n+    import core.internal.traits : hasElaborateAssign;\n \n-    // Avoid stack allocation by hacking to get to the struct/union init symbol.\n-    static if (is(T == struct) || is(T == union))\n+    static if (__traits(isZeroInit, T))\n     {\n-        pragma(mangle, \"_D\" ~ Unqual!T.mangleof[1..$] ~ \"6__initZ\")\n-        __gshared extern immutable T initializer;\n+        import core.stdc.string : memset;\n+        memset(cast(void*) &chunk, 0, T.sizeof);\n     }\n-\n-    void emplaceInitializer(scope ref T chunk) nothrow pure @trusted\n+    else static if (__traits(isScalar, T) ||\n+                    T.sizeof <= 16 && !hasElaborateAssign!T && __traits(compiles, (){ T chunk; chunk = T.init; }))\n     {\n-        static if (__traits(isZeroInit, T))\n-        {\n-            import core.stdc.string : memset;\n-            memset(cast(void*) &chunk, 0, T.sizeof);\n-        }\n-        else static if (__traits(isScalar, T) ||\n-                        T.sizeof <= 16 && !hasElaborateAssign!T && __traits(compiles, (){ T chunk; chunk = T.init; }))\n-        {\n-            chunk = T.init;\n-        }\n-        else static if (__traits(isStaticArray, T))\n-        {\n-            // For static arrays there is no initializer symbol created. Instead, we emplace elements one-by-one.\n-            foreach (i; 0 .. T.length)\n-            {\n-                emplaceInitializer(chunk[i]);\n-            }\n-        }\n-        else\n+        chunk = T.init;\n+    }\n+    else static if (__traits(isStaticArray, T))\n+    {\n+        // For static arrays there is no initializer symbol created. Instead, we emplace elements one-by-one.\n+        foreach (i; 0 .. T.length)\n         {\n-            import core.stdc.string : memcpy;\n-            memcpy(cast(void*)&chunk, &initializer, T.sizeof);\n+            emplaceInitializer(chunk[i]);\n         }\n     }\n+    else\n+    {\n+        import core.stdc.string : memcpy;\n+        const initializer = __traits(initSymbol, T);\n+        memcpy(cast(void*)&chunk, initializer.ptr, initializer.length);\n+    }\n }\n \n @safe unittest"}, {"sha": "64a9cc92ffba8b70776bc8c5fb19dcda6be0a96c", "filename": "libphobos/libdruntime/core/internal/string.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fstring.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fstring.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fstring.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -119,7 +119,7 @@ char[] signedToTempString(uint radix = 10)(long value, return scope char[] buf)\n     if (neg)\n     {\n         // about to do a slice without a bounds check\n-        auto trustedSlice(return char[] r) @trusted { assert(r.ptr > buf.ptr); return (r.ptr-1)[0..r.length+1]; }\n+        auto trustedSlice(return scope char[] r) @trusted { assert(r.ptr > buf.ptr); return (r.ptr-1)[0..r.length+1]; }\n         r = trustedSlice(r);\n         r[0] = '-';\n     }"}, {"sha": "27bf7f2b90552ca1eb28e12314b8d105c0c703a7", "filename": "libphobos/libdruntime/core/internal/utf.d", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Finternal%2Futf.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Finternal%2Futf.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Futf.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -583,7 +583,7 @@ void validate(S)(const scope S s)\n /* =================== Conversion to UTF8 ======================= */\n \n @safe pure nothrow @nogc\n-char[] toUTF8(return char[] buf, dchar c)\n+char[] toUTF8(return scope char[] buf, dchar c)\n     in\n     {\n         assert(isValidDchar(c));\n@@ -623,7 +623,7 @@ char[] toUTF8(return char[] buf, dchar c)\n  * Encodes string s into UTF-8 and returns the encoded string.\n  */\n @safe pure nothrow\n-string toUTF8(return string s)\n+string toUTF8(return scope string s)\n     in\n     {\n         validate(s);\n@@ -692,7 +692,7 @@ string toUTF8(const scope dchar[] s)\n /* =================== Conversion to UTF16 ======================= */\n \n @safe pure nothrow @nogc\n-wchar[] toUTF16(return wchar[] buf, dchar c)\n+wchar[] toUTF16(return scope wchar[] buf, dchar c)\n     in\n     {\n         assert(isValidDchar(c));\n@@ -784,7 +784,7 @@ wptr toUTF16z(const scope char[] s)\n \n /** ditto */\n @safe pure nothrow\n-wstring toUTF16(return wstring s)\n+wstring toUTF16(return scope wstring s)\n     in\n     {\n         validate(s);\n@@ -864,7 +864,7 @@ dstring toUTF32(const scope wchar[] s)\n \n /** ditto */\n @safe pure nothrow\n-dstring toUTF32(return dstring s)\n+dstring toUTF32(return scope dstring s)\n     in\n     {\n         validate(s);"}, {"sha": "b45e95f4226e9a09d1fed262cbbded556d9e53ee", "filename": "libphobos/libdruntime/core/lifetime.d", "status": "modified", "additions": 101, "deletions": 10, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Flifetime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Flifetime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Flifetime.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -103,8 +103,8 @@ T emplace(T, Args...)(T chunk, auto ref Args args)\n         \" is abstract and it can't be emplaced\");\n \n     // Initialize the object in its pre-ctor state\n-    enum classSize = __traits(classInstanceSize, T);\n-    (() @trusted => (cast(void*) chunk)[0 .. classSize] = typeid(T).initializer[])();\n+    const initializer = __traits(initSymbol, T);\n+    (() @trusted { (cast(void*) chunk)[0 .. initializer.length] = initializer[]; })();\n \n     static if (isInnerClass!T)\n     {\n@@ -224,6 +224,31 @@ T emplace(T, Args...)(void[] chunk, auto ref Args args)\n     assert(c.i == 5);\n }\n \n+///\n+@betterC\n+@nogc pure nothrow @system unittest\n+{\n+    // works with -betterC too:\n+\n+    static extern (C++) class C\n+    {\n+        @nogc pure nothrow @safe:\n+        int i = 3;\n+        this(int i)\n+        {\n+            assert(this.i == 3);\n+            this.i = i;\n+        }\n+        int virtualGetI() { return i; }\n+    }\n+\n+    import core.internal.traits : classInstanceAlignment;\n+\n+    align(classInstanceAlignment!C) byte[__traits(classInstanceSize, C)] buffer;\n+    C c = emplace!C(buffer[], 42);\n+    assert(c.virtualGetI() == 42);\n+}\n+\n @system unittest\n {\n     class Outer\n@@ -1921,7 +1946,7 @@ private void moveImpl(T)(scope ref T target, return scope ref T source)\n \n     static if (is(T == struct))\n     {\n-        //  Unsafe when compiling without -dip1000\n+        //  Unsafe when compiling without -preview=dip1000\n         if ((() @trusted => &source == &target)()) return;\n         // Destroy target before overwriting it\n         static if (hasElaborateDestructor!T) target.__xdtor();\n@@ -2099,7 +2124,7 @@ private void moveEmplaceImpl(T)(scope ref T target, return scope ref T source)\n \n     static if (is(T == struct))\n     {\n-        //  Unsafe when compiling without -dip1000\n+        //  Unsafe when compiling without -preview=dip1000\n         assert((() @trusted => &source !is &target)(), \"source and target must not be identical\");\n \n         static if (hasElaborateAssign!T || !isAssignable!T)\n@@ -2123,12 +2148,7 @@ private void moveEmplaceImpl(T)(scope ref T target, return scope ref T source)\n             static if (__traits(isZeroInit, T))\n                 () @trusted { memset(&source, 0, sz); }();\n             else\n-            {\n-                import core.internal.lifetime : emplaceInitializer;\n-                ubyte[T.sizeof] init = void;\n-                emplaceInitializer(*(() @trusted { return cast(T*)init.ptr; }()));\n-                () @trusted { memcpy(&source, init.ptr, sz); }();\n-            }\n+                () @trusted { memcpy(&source, __traits(initSymbol, T).ptr, sz); }();\n         }\n     }\n     else static if (__traits(isStaticArray, T))\n@@ -2201,3 +2221,74 @@ pure nothrow @nogc @system unittest\n     static assert(!__traits(compiles, f(ncarray)));\n     f(move(ncarray));\n }\n+\n+/**\n+ * This is called for a delete statement where the value\n+ * being deleted is a pointer to a struct with a destructor\n+ * but doesn't have an overloaded delete operator.\n+ *\n+ * Params:\n+ *   p = pointer to the value to be deleted\n+ */\n+void _d_delstruct(T)(ref T *p)\n+{\n+    if (p)\n+    {\n+        debug(PRINTF) printf(\"_d_delstruct(%p)\\n\", p);\n+\n+        import core.memory : GC;\n+\n+        destroy(*p);\n+        GC.free(p);\n+        p = null;\n+    }\n+}\n+\n+@system unittest\n+{\n+    int dtors = 0;\n+    struct S { ~this() { ++dtors; } }\n+\n+    S *s = new S();\n+    _d_delstruct(s);\n+\n+    assert(s == null);\n+    assert(dtors == 1);\n+}\n+\n+@system unittest\n+{\n+    int innerDtors = 0;\n+    int outerDtors = 0;\n+\n+    struct Inner { ~this() { ++innerDtors; } }\n+    struct Outer\n+    {\n+        Inner *i1;\n+        Inner *i2;\n+\n+        this(int x)\n+        {\n+            i1 = new Inner();\n+            i2 = new Inner();\n+        }\n+\n+        ~this()\n+        {\n+            ++outerDtors;\n+\n+            _d_delstruct(i1);\n+            assert(i1 == null);\n+\n+            _d_delstruct(i2);\n+            assert(i2 == null);\n+        }\n+    }\n+\n+    Outer *o = new Outer(0);\n+    _d_delstruct(o);\n+\n+    assert(o == null);\n+    assert(innerDtors == 2);\n+    assert(outerDtors == 1);\n+}"}, {"sha": "c4df0f2d0dd0b822d013704c513dc5fd3c3069ce", "filename": "libphobos/libdruntime/core/memory.d", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fmemory.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fmemory.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fmemory.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -270,7 +270,7 @@ extern(C):\n      * reentrant, and must be called once for every call to disable before\n      * automatic collections are enabled.\n      */\n-    pragma(mangle, \"gc_enable\") static void enable() nothrow; /* FIXME pure */\n+    pragma(mangle, \"gc_enable\") static void enable() nothrow pure;\n \n \n     /**\n@@ -280,7 +280,7 @@ extern(C):\n      * such as during an out of memory condition.  This function is reentrant,\n      * but enable must be called once for each call to disable.\n      */\n-    pragma(mangle, \"gc_disable\") static void disable() nothrow; /* FIXME pure */\n+    pragma(mangle, \"gc_disable\") static void disable() nothrow pure;\n \n \n     /**\n@@ -290,14 +290,14 @@ extern(C):\n      * and then to reclaim free space.  This action may need to suspend all\n      * running threads for at least part of the collection process.\n      */\n-    pragma(mangle, \"gc_collect\") static void collect() nothrow; /* FIXME pure */\n+    pragma(mangle, \"gc_collect\") static void collect() nothrow pure;\n \n     /**\n      * Indicates that the managed memory space be minimized by returning free\n      * physical memory to the operating system.  The amount of free memory\n      * returned depends on the allocator design and on program behavior.\n      */\n-    pragma(mangle, \"gc_minimize\") static void minimize() nothrow; /* FIXME pure */\n+    pragma(mangle, \"gc_minimize\") static void minimize() nothrow pure;\n \n extern(D):\n \n@@ -551,7 +551,7 @@ extern(C):\n      * Throws:\n      *  `OutOfMemoryError` on allocation failure.\n      */\n-    pragma(mangle, \"gc_realloc\") static void* realloc(return void* p, size_t sz, uint ba = 0, const TypeInfo ti = null) pure nothrow;\n+    pragma(mangle, \"gc_realloc\") static void* realloc(return scope void* p, size_t sz, uint ba = 0, const TypeInfo ti = null) pure nothrow;\n \n     // https://issues.dlang.org/show_bug.cgi?id=13111\n     ///\n@@ -635,7 +635,7 @@ extern(C):\n      * Returns:\n      *  The actual number of bytes reserved or zero on error.\n      */\n-    pragma(mangle, \"gc_reserve\") static size_t reserve(size_t sz) nothrow; /* FIXME pure */\n+    pragma(mangle, \"gc_reserve\") static size_t reserve(size_t sz) nothrow pure;\n \n \n     /**\n@@ -807,7 +807,7 @@ extern(C):\n      * }\n      * ---\n      */\n-    pragma(mangle, \"gc_addRoot\") static void addRoot(const void* p) nothrow @nogc; /* FIXME pure */\n+    pragma(mangle, \"gc_addRoot\") static void addRoot(const void* p) nothrow @nogc pure;\n \n \n     /**\n@@ -818,7 +818,7 @@ extern(C):\n      * Params:\n      *  p = A pointer into a GC-managed memory block or null.\n      */\n-    pragma(mangle, \"gc_removeRoot\") static void removeRoot(const void* p) nothrow @nogc; /* FIXME pure */\n+    pragma(mangle, \"gc_removeRoot\") static void removeRoot(const void* p) nothrow @nogc pure;\n \n \n     /**\n@@ -849,7 +849,8 @@ extern(C):\n      * // rawMemory will be recognized on collection.\n      * ---\n      */\n-    pragma(mangle, \"gc_addRange\") static void addRange(const void* p, size_t sz, const TypeInfo ti = null) @nogc nothrow; /* FIXME pure */\n+    pragma(mangle, \"gc_addRange\")\n+    static void addRange(const void* p, size_t sz, const TypeInfo ti = null) @nogc nothrow pure;\n \n \n     /**\n@@ -861,7 +862,7 @@ extern(C):\n      * Params:\n      *  p  = A pointer to a valid memory address or to null.\n      */\n-    pragma(mangle, \"gc_removeRange\") static void removeRange(const void* p) nothrow @nogc; /* FIXME pure */\n+    pragma(mangle, \"gc_removeRange\") static void removeRange(const void* p) nothrow @nogc pure;\n \n \n     /**"}, {"sha": "92f8f705540878fbfad4bf2997c74c303dcb3d0c", "filename": "libphobos/libdruntime/core/stdc/stdlib.d", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fstdlib.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fstdlib.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fstdlib.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -26,6 +26,10 @@ else version (TVOS)\n else version (WatchOS)\n     version = Darwin;\n \n+version (CRuntime_Glibc)\n+    version = AlignedAllocSupported;\n+else {}\n+\n extern (C):\n @system:\n \n@@ -166,6 +170,12 @@ void*   realloc(void* ptr, size_t size);\n ///\n void    free(void* ptr);\n \n+/// since C11\n+version (AlignedAllocSupported)\n+{\n+    void* aligned_alloc(size_t alignment, size_t size);\n+}\n+\n ///\n noreturn abort() @safe;\n ///"}, {"sha": "f15ef851909a3015ae8d39541c3d1f28a1501e97", "filename": "libphobos/libdruntime/core/stdc/string.d", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fstring.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fstring.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fstring.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -35,31 +35,31 @@ nothrow:\n @nogc:\n \n ///\n-inout(void)* memchr(return inout void* s, int c, size_t n) pure;\n+inout(void)* memchr(return scope inout void* s, int c, size_t n) pure;\n ///\n int   memcmp(scope const void* s1, scope const void* s2, size_t n) pure;\n ///\n-void* memcpy(return void* s1, scope const void* s2, size_t n) pure;\n+void* memcpy(return scope void* s1, scope const void* s2, size_t n) pure;\n version (Windows)\n {\n     ///\n     int memicmp(scope const char* s1, scope const char* s2, size_t n);\n }\n ///\n-void* memmove(return void* s1, scope const void* s2, size_t n) pure;\n+void* memmove(return scope void* s1, scope const void* s2, size_t n) pure;\n ///\n-void* memset(return void* s, int c, size_t n) pure;\n+void* memset(return scope void* s, int c, size_t n) pure;\n \n ///\n-char*  strcat(return char* s1, scope const char* s2) pure;\n+char*  strcat(return scope char* s1, scope const char* s2) pure;\n ///\n-inout(char)*  strchr(return inout(char)* s, int c) pure;\n+inout(char)*  strchr(return scope inout(char)* s, int c) pure;\n ///\n int    strcmp(scope const char* s1, scope const char* s2) pure;\n ///\n int    strcoll(scope const char* s1, scope const char* s2);\n ///\n-char*  strcpy(return char* s1, scope const char* s2) pure;\n+char*  strcpy(return scope char* s1, scope const char* s2) pure;\n ///\n size_t strcspn(scope const char* s1, scope const char* s2) pure;\n ///\n@@ -70,7 +70,7 @@ char*  strerror(int errnum);\n version (ReturnStrerrorR)\n {\n     ///\n-    const(char)* strerror_r(int errnum, return char* buf, size_t buflen);\n+    const(char)* strerror_r(int errnum, return scope char* buf, size_t buflen);\n }\n // This one is\n else\n@@ -80,20 +80,20 @@ else\n ///\n size_t strlen(scope const char* s) pure;\n ///\n-char*  strncat(return char* s1, scope const char* s2, size_t n) pure;\n+char*  strncat(return scope char* s1, scope const char* s2, size_t n) pure;\n ///\n int    strncmp(scope const char* s1, scope const char* s2, size_t n) pure;\n ///\n-char*  strncpy(return char* s1, scope const char* s2, size_t n) pure;\n+char*  strncpy(return scope char* s1, scope const char* s2, size_t n) pure;\n ///\n-inout(char)*  strpbrk(return inout(char)* s1, scope const char* s2) pure;\n+inout(char)*  strpbrk(return scope inout(char)* s1, scope const char* s2) pure;\n ///\n-inout(char)*  strrchr(return inout(char)* s, int c) pure;\n+inout(char)*  strrchr(return scope inout(char)* s, int c) pure;\n ///\n size_t strspn(scope const char* s1, scope const char* s2) pure;\n ///\n-inout(char)*  strstr(return inout(char)* s1, scope const char* s2) pure;\n+inout(char)*  strstr(return scope inout(char)* s1, scope const char* s2) pure;\n ///\n-char*  strtok(return char* s1, scope const char* s2);\n+char*  strtok(return scope char* s1, scope const char* s2);\n ///\n size_t strxfrm(scope char* s1, scope const char* s2, size_t n);"}, {"sha": "e8fb94b11e6607fe94e5c1c97fff5afbbc535d7f", "filename": "libphobos/libdruntime/core/stdc/wchar_.d", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fwchar_.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fwchar_.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fwchar_.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -213,13 +213,13 @@ c_ulong wcstoul(const scope wchar_t* nptr, wchar_t** endptr, int base);\n ulong   wcstoull(const scope wchar_t* nptr, wchar_t** endptr, int base);\n \n ///\n-pure wchar_t* wcscpy(return wchar_t* s1, scope const wchar_t* s2);\n+pure wchar_t* wcscpy(return scope wchar_t* s1, scope const wchar_t* s2);\n ///\n-pure wchar_t* wcsncpy(return wchar_t* s1, scope const wchar_t* s2, size_t n);\n+pure wchar_t* wcsncpy(return scope wchar_t* s1, scope const wchar_t* s2, size_t n);\n ///\n-pure wchar_t* wcscat(return wchar_t* s1, scope const wchar_t* s2);\n+pure wchar_t* wcscat(return scope wchar_t* s1, scope const wchar_t* s2);\n ///\n-pure wchar_t* wcsncat(return wchar_t* s1, scope const wchar_t* s2, size_t n);\n+pure wchar_t* wcsncat(return scope wchar_t* s1, scope const wchar_t* s2, size_t n);\n ///\n pure int wcscmp(scope const wchar_t* s1, scope const wchar_t* s2);\n ///\n@@ -229,32 +229,32 @@ pure int wcsncmp(scope const wchar_t* s1, scope const wchar_t* s2, size_t n);\n ///\n size_t   wcsxfrm(scope wchar_t* s1, scope const wchar_t* s2, size_t n);\n ///\n-pure inout(wchar_t)* wcschr(return inout(wchar_t)* s, wchar_t c);\n+pure inout(wchar_t)* wcschr(return scope inout(wchar_t)* s, wchar_t c);\n ///\n pure size_t wcscspn(scope const wchar_t* s1, scope const wchar_t* s2);\n ///\n-pure inout(wchar_t)* wcspbrk(return inout(wchar_t)* s1, scope const wchar_t* s2);\n+pure inout(wchar_t)* wcspbrk(return scope inout(wchar_t)* s1, scope const wchar_t* s2);\n ///\n-pure inout(wchar_t)* wcsrchr(return inout(wchar_t)* s, wchar_t c);\n+pure inout(wchar_t)* wcsrchr(return scope inout(wchar_t)* s, wchar_t c);\n ///\n pure size_t wcsspn(scope const wchar_t* s1, scope const wchar_t* s2);\n ///\n-pure inout(wchar_t)* wcsstr(return inout(wchar_t)* s1, scope const wchar_t* s2);\n+pure inout(wchar_t)* wcsstr(return scope inout(wchar_t)* s1, scope const wchar_t* s2);\n ///\n-wchar_t* wcstok(return wchar_t* s1, scope const wchar_t* s2, wchar_t** ptr);\n+wchar_t* wcstok(return scope wchar_t* s1, scope const wchar_t* s2, wchar_t** ptr);\n ///\n pure size_t wcslen(scope const wchar_t* s);\n \n ///\n-pure inout(wchar_t)* wmemchr(return inout wchar_t* s, wchar_t c, size_t n);\n+pure inout(wchar_t)* wmemchr(return scope inout wchar_t* s, wchar_t c, size_t n);\n ///\n pure int      wmemcmp(scope const wchar_t* s1, scope const wchar_t* s2, size_t n);\n ///\n-pure wchar_t* wmemcpy(return wchar_t* s1, scope const wchar_t* s2, size_t n);\n+pure wchar_t* wmemcpy(return scope wchar_t* s1, scope const wchar_t* s2, size_t n);\n ///\n-pure wchar_t* wmemmove(return wchar_t* s1, scope const wchar_t* s2, size_t n);\n+pure wchar_t* wmemmove(return scope wchar_t* s1, scope const wchar_t* s2, size_t n);\n ///\n-pure wchar_t* wmemset(return wchar_t* s, wchar_t c, size_t n);\n+pure wchar_t* wmemset(return scope wchar_t* s, wchar_t c, size_t n);\n \n ///\n size_t wcsftime(wchar_t* s, size_t maxsize, const scope wchar_t* format, const scope tm* timeptr);"}, {"sha": "d65cd8d1832fa687f41b860cf8eedf1771b5749d", "filename": "libphobos/libdruntime/core/stdcpp/exception.d", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fstdcpp%2Fexception.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fstdcpp%2Fexception.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fstdcpp%2Fexception.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -19,6 +19,8 @@ version (CppRuntime_Gcc)\n     version = GenericBaseException;\n version (CppRuntime_Clang)\n     version = GenericBaseException;\n+version (CppRuntime_Sun)\n+    version = GenericBaseException;\n \n extern (C++, \"std\"):\n @nogc:"}, {"sha": "b848a1474601e376548ec60695f88c60e3892fba", "filename": "libphobos/libdruntime/core/sync/mutex.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsync%2Fmutex.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsync%2Fmutex.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsync%2Fmutex.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -189,7 +189,7 @@ class Mutex :\n             if (pthread_mutex_lock(&m_hndl) == 0)\n                 return;\n \n-            SyncError syncErr = cast(SyncError) cast(void*) typeid(SyncError).initializer;\n+            SyncError syncErr = cast(SyncError) __traits(initSymbol, SyncError).ptr;\n             syncErr.msg = \"Unable to lock mutex.\";\n             throw syncErr;\n         }\n@@ -227,7 +227,7 @@ class Mutex :\n             if (pthread_mutex_unlock(&m_hndl) == 0)\n                 return;\n \n-            SyncError syncErr = cast(SyncError) cast(void*) typeid(SyncError).initializer;\n+            SyncError syncErr = cast(SyncError) __traits(initSymbol, SyncError).ptr;\n             syncErr.msg = \"Unable to unlock mutex.\";\n             throw syncErr;\n         }"}, {"sha": "10a5610ac449ba467b70d846073eb43a6d8841c0", "filename": "libphobos/libdruntime/core/sys/bionic/string.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fbionic%2Fstring.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fbionic%2Fstring.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fbionic%2Fstring.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -14,4 +14,4 @@ extern (C):\n nothrow:\n @nogc:\n \n-pure void* memmem(return const void* haystack, size_t haystacklen, scope const void* needle, size_t needlelen);\n+pure void* memmem(return scope const void* haystack, size_t haystacklen, scope const void* needle, size_t needlelen);"}, {"sha": "4d400f207c7cf1cf996b40bc2b61aff8a65d83fe", "filename": "libphobos/libdruntime/core/sys/darwin/mach/nlist.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdarwin%2Fmach%2Fnlist.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdarwin%2Fmach%2Fnlist.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdarwin%2Fmach%2Fnlist.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -222,7 +222,7 @@ enum\n  */\n ubyte GET_LIBRARY_ORDINAL(uint n_desc) @safe { return ((n_desc) >> 8) & 0xff; }\n /// Ditto\n-ref ushort SET_LIBRARY_ORDINAL(return scope ref ushort n_desc, uint ordinal) @safe\n+ref ushort SET_LIBRARY_ORDINAL(return ref ushort n_desc, uint ordinal) @safe\n {\n     return n_desc = (((n_desc) & 0x00ff) | (((ordinal) & 0xff) << 8));\n }"}, {"sha": "ac988b58f0d40e860194fc22a89ae066a2b289de", "filename": "libphobos/libdruntime/core/sys/darwin/string.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdarwin%2Fstring.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdarwin%2Fstring.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdarwin%2Fstring.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -27,5 +27,5 @@ nothrow:\n static if (__DARWIN_C_LEVEL >= __DARWIN_C_FULL)\n {\n     // ^ __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);\n-    pure void* memmem(return const void* haystack, size_t haystacklen, scope const void* needle, size_t needlelen);\n+    pure void* memmem(return scope const void* haystack, size_t haystacklen, scope const void* needle, size_t needlelen);\n }"}, {"sha": "4b8422748b60ee2eae5bda9c42b39cd424880028", "filename": "libphobos/libdruntime/core/sys/dragonflybsd/string.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdragonflybsd%2Fstring.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdragonflybsd%2Fstring.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdragonflybsd%2Fstring.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -17,6 +17,6 @@ nothrow:\n \n static if (__BSD_VISIBLE)\n {\n-    pure void* memmem(return const void* haystack, size_t haystacklen, scope const void* needle, size_t needlelen);\n+    pure void* memmem(return scope const void* haystack, size_t haystacklen, scope const void* needle, size_t needlelen);\n }\n "}, {"sha": "459e9115878e2983d883f23ed9c58b6fa30f2a07", "filename": "libphobos/libdruntime/core/sys/freebsd/string.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Ffreebsd%2Fstring.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Ffreebsd%2Fstring.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Ffreebsd%2Fstring.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -17,5 +17,5 @@ nothrow:\n \n static if (__BSD_VISIBLE)\n {\n-    pure void* memmem(return const void* haystack, size_t haystacklen, scope const void* needle, size_t needlelen);\n+    pure void* memmem(return scope const void* haystack, size_t haystacklen, scope const void* needle, size_t needlelen);\n }"}, {"sha": "e3c94cf6a8ac655b2ed5bf7340d4a32c437ede65", "filename": "libphobos/libdruntime/core/sys/linux/string.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fstring.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fstring.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fstring.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -18,5 +18,5 @@ nothrow:\n \n static if (__USE_GNU)\n {\n-    pure void* memmem(return const void* haystack, size_t haystacklen, scope const void* needle, size_t needlelen);\n+    pure void* memmem(return scope const void* haystack, size_t haystacklen, scope const void* needle, size_t needlelen);\n }"}, {"sha": "8c653719317d8c96cbd4f6676149f690ecf2b7c0", "filename": "libphobos/libdruntime/core/sys/linux/syscalls.d", "status": "removed", "additions": 0, "deletions": 745, "changes": 745, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c60e5075f89265a560eab166d43247624a7535/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fsyscalls.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c60e5075f89265a560eab166d43247624a7535/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fsyscalls.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fsyscalls.d?ref=38c60e5075f89265a560eab166d43247624a7535", "patch": "@@ -1,745 +0,0 @@\n-module core.sys.linux.syscalls;\n-\n-version (linux):\n-extern (C):\n-@system:\n-nothrow:\n-@nogc:\n-\n-import core.stdc.config : c_long;\n-\n-version (CoreDdoc)\n-{\n-    /// Linux system call number from Linux's asm/unistd.h\n-    enum SystemCall : c_long;\n-}\n-else version (X86_64)\n-{\n-    // https://github.com/torvalds/linux/blob/v4.14/arch/sh/include/uapi/asm/unistd_64.h\n-    // https://github.com/torvalds/linux/blob/v4.14/arch/x86/entry/syscalls/syscall_64.tbl\n-    enum SystemCall : c_long\n-    {\n-        read = 0,\n-        write = 1,\n-        open = 2,\n-        close = 3,\n-        stat = 4,\n-        fstat = 5,\n-        lstat = 6,\n-        poll = 7,\n-        lseek = 8,\n-        mmap = 9,\n-        mprotect = 10,\n-        munmap = 11,\n-        brk = 12,\n-        rt_sigaction = 13,\n-        rt_sigprocmask = 14,\n-        rt_sigreturn = 15,\n-        ioctl = 16,\n-        pread64 = 17,\n-        pwrite64 = 18,\n-        readv = 19,\n-        writev = 20,\n-        access = 21,\n-        pipe = 22,\n-        select = 23,\n-        sched_yield = 24,\n-        mremap = 25,\n-        msync = 26,\n-        mincore = 27,\n-        madvise = 28,\n-        shmget = 29,\n-        shmat = 30,\n-        shmctl = 31,\n-        dup = 32,\n-        dup2 = 33,\n-        pause = 34,\n-        nanosleep = 35,\n-        getitimer = 36,\n-        alarm = 37,\n-        setitimer = 38,\n-        getpid = 39,\n-        sendfile = 40,\n-        socket = 41,\n-        connect = 42,\n-        accept = 43,\n-        sendto = 44,\n-        recvfrom = 45,\n-        sendmsg = 46,\n-        recvmsg = 47,\n-        shutdown = 48,\n-        bind = 49,\n-        listen = 50,\n-        getsockname = 51,\n-        getpeername = 52,\n-        socketpair = 53,\n-        setsockopt = 54,\n-        getsockopt = 55,\n-        clone = 56,\n-        fork = 57,\n-        vfork = 58,\n-        execve = 59,\n-        exit = 60,\n-        wait4 = 61,\n-        kill = 62,\n-        uname = 63,\n-        semget = 64,\n-        semop = 65,\n-        semctl = 66,\n-        shmdt = 67,\n-        msgget = 68,\n-        msgsnd = 69,\n-        msgrcv = 70,\n-        msgctl = 71,\n-        fcntl = 72,\n-        flock = 73,\n-        fsync = 74,\n-        fdatasync = 75,\n-        truncate = 76,\n-        ftruncate = 77,\n-        getdents = 78,\n-        getcwd = 79,\n-        chdir = 80,\n-        fchdir = 81,\n-        rename = 82,\n-        mkdir = 83,\n-        rmdir = 84,\n-        creat = 85,\n-        link = 86,\n-        unlink = 87,\n-        symlink = 88,\n-        readlink = 89,\n-        chmod = 90,\n-        fchmod = 91,\n-        chown = 92,\n-        fchown = 93,\n-        lchown = 94,\n-        umask = 95,\n-        gettimeofday = 96,\n-        getrlimit = 97,\n-        getrusage = 98,\n-        sysinfo = 99,\n-        times = 100,\n-        ptrace = 101,\n-        getuid = 102,\n-        syslog = 103,\n-        getgid = 104,\n-        setuid = 105,\n-        setgid = 106,\n-        geteuid = 107,\n-        getegid = 108,\n-        setpgid = 109,\n-        getppid = 110,\n-        getpgrp = 111,\n-        setsid = 112,\n-        setreuid = 113,\n-        setregid = 114,\n-        getgroups = 115,\n-        setgroups = 116,\n-        setresuid = 117,\n-        getresuid = 118,\n-        setresgid = 119,\n-        getresgid = 120,\n-        getpgid = 121,\n-        setfsuid = 122,\n-        setfsgid = 123,\n-        getsid = 124,\n-        capget = 125,\n-        capset = 126,\n-        rt_sigpending = 127,\n-        rt_sigtimedwait = 128,\n-        rt_sigqueueinfo = 129,\n-        rt_sigsuspend = 130,\n-        sigaltstack = 131,\n-        utime = 132,\n-        mknod = 133,\n-        uselib = 134,\n-        personality = 135,\n-        ustat = 136,\n-        statfs = 137,\n-        fstatfs = 138,\n-        sysfs = 139,\n-        getpriority = 140,\n-        setpriority = 141,\n-        sched_setparam = 142,\n-        sched_getparam = 143,\n-        sched_setscheduler = 144,\n-        sched_getscheduler = 145,\n-        sched_get_priority_max = 146,\n-        sched_get_priority_min = 147,\n-        sched_rr_get_interval = 148,\n-        mlock = 149,\n-        munlock = 150,\n-        mlockall = 151,\n-        munlockall = 152,\n-        vhangup = 153,\n-        modify_ldt = 154,\n-        pivot_root = 155,\n-        _sysctl = 156,\n-        prctl = 157,\n-        arch_prctl = 158,\n-        adjtimex = 159,\n-        setrlimit = 160,\n-        chroot = 161,\n-        sync = 162,\n-        acct = 163,\n-        settimeofday = 164,\n-        mount = 165,\n-        umount2 = 166,\n-        swapon = 167,\n-        swapoff = 168,\n-        reboot = 169,\n-        sethostname = 170,\n-        setdomainname = 171,\n-        iopl = 172,\n-        ioperm = 173,\n-        create_module = 174,\n-        init_module = 175,\n-        delete_module = 176,\n-        get_kernel_syms = 177,\n-        query_module = 178,\n-        quotactl = 179,\n-        nfsservctl = 180,\n-        getpmsg = 181,\n-        putpmsg = 182,\n-        afs_syscall = 183,\n-        tuxcall = 184,\n-        security = 185,\n-        gettid = 186,\n-        readahead = 187,\n-        setxattr = 188,\n-        lsetxattr = 189,\n-        fsetxattr = 190,\n-        getxattr = 191,\n-        lgetxattr = 192,\n-        fgetxattr = 193,\n-        listxattr = 194,\n-        llistxattr = 195,\n-        flistxattr = 196,\n-        removexattr = 197,\n-        lremovexattr = 198,\n-        fremovexattr = 199,\n-        tkill = 200,\n-        time = 201,\n-        futex = 202,\n-        sched_setaffinity = 203,\n-        sched_getaffinity = 204,\n-        set_thread_area = 205,\n-        io_setup = 206,\n-        io_destroy = 207,\n-        io_getevents = 208,\n-        io_submit = 209,\n-        io_cancel = 210,\n-        get_thread_area = 211,\n-        lookup_dcookie = 212,\n-        epoll_create = 213,\n-        epoll_ctl_old = 214,\n-        epoll_wait_old = 215,\n-        remap_file_pages = 216,\n-        getdents64 = 217,\n-        set_tid_address = 218,\n-        restart_syscall = 219,\n-        semtimedop = 220,\n-        fadvise64 = 221,\n-        timer_create = 222,\n-        timer_settime = 223,\n-        timer_gettime = 224,\n-        timer_getoverrun = 225,\n-        timer_delete = 226,\n-        clock_settime = 227,\n-        clock_gettime = 228,\n-        clock_getres = 229,\n-        clock_nanosleep = 230,\n-        exit_group = 231,\n-        epoll_wait = 232,\n-        epoll_ctl = 233,\n-        tgkill = 234,\n-        utimes = 235,\n-        vserver = 236,\n-        mbind = 237,\n-        set_mempolicy = 238,\n-        get_mempolicy = 239,\n-        mq_open = 240,\n-        mq_unlink = 241,\n-        mq_timedsend = 242,\n-        mq_timedreceive = 243,\n-        mq_notify = 244,\n-        mq_getsetattr = 245,\n-        kexec_load = 246,\n-        waitid = 247,\n-        add_key = 248,\n-        request_key = 249,\n-        keyctl = 250,\n-        ioprio_set = 251,\n-        ioprio_get = 252,\n-        inotify_init = 253,\n-        inotify_add_watch = 254,\n-        inotify_rm_watch = 255,\n-        migrate_pages = 256,\n-        openat = 257,\n-        mkdirat = 258,\n-        mknodat = 259,\n-        fchownat = 260,\n-        futimesat = 261,\n-        newfstatat = 262,\n-        unlinkat = 263,\n-        renameat = 264,\n-        linkat = 265,\n-        symlinkat = 266,\n-        readlinkat = 267,\n-        fchmodat = 268,\n-        faccessat = 269,\n-        pselect6 = 270,\n-        ppoll = 271,\n-        unshare = 272,\n-        set_robust_list = 273,\n-        get_robust_list = 274,\n-        splice = 275,\n-        tee = 276,\n-        sync_file_range = 277,\n-        vmsplice = 278,\n-        move_pages = 279,\n-        utimensat = 280,\n-        epoll_pwait = 281,\n-        signalfd = 282,\n-        timerfd_create = 283,\n-        eventfd = 284,\n-        fallocate = 285,\n-        timerfd_settime = 286,\n-        timerfd_gettime = 287,\n-        accept4 = 288,\n-        signalfd4 = 289,\n-        eventfd2 = 290,\n-        epoll_create1 = 291,\n-        dup3 = 292,\n-        pipe2 = 293,\n-        inotify_init1 = 294,\n-        preadv = 295,\n-        pwritev = 296,\n-        rt_tgsigqueueinfo = 297,\n-        perf_event_open = 298,\n-        recvmmsg = 299,\n-        fanotify_init = 300,\n-        fanotify_mark = 301,\n-        prlimit64 = 302,\n-        name_to_handle_at = 303,\n-        open_by_handle_at = 304,\n-        clock_adjtime = 305,\n-        syncfs = 306,\n-        sendmmsg = 307,\n-        setns = 308,\n-        getcpu = 309,\n-        process_vm_readv = 310,\n-        process_vm_writev = 311,\n-        kcmp = 312,\n-        finit_module = 313,\n-        sched_setattr = 314,\n-        sched_getattr = 315,\n-        renameat2 = 316,\n-        seccomp = 317,\n-        getrandom = 318,\n-        memfd_create = 319,\n-        kexec_file_load = 320,\n-        bpf = 321,\n-        execveat = 322,\n-        userfaultfd = 323,\n-        membarrier = 324,\n-        mlock2 = 325,\n-        copy_file_range = 326,\n-        preadv2 = 327,\n-        pwritev2 = 328,\n-        pkey_mprotect = 329,\n-        pkey_alloc = 330,\n-        pkey_free = 331,\n-        statx = 332,\n-    }\n-}\n-else version (X86)\n-{\n-    // https://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_32.tbl\n-    // https://github.com/torvalds/linux/blob/v4.14/arch/sh/include/uapi/asm/unistd_32.h\n-    enum SystemCall : c_long\n-    {\n-        restart_syscall = 0,\n-        exit = 1,\n-        fork = 2,\n-        read = 3,\n-        write = 4,\n-        open = 5,\n-        close = 6,\n-        waitpid = 7,\n-        creat = 8,\n-        link = 9,\n-        unlink = 10,\n-        execve = 11,\n-        chdir = 12,\n-        time = 13,\n-        mknod = 14,\n-        chmod = 15,\n-        lchown = 16,\n-        break_ = 17,\n-        oldstat = 18,\n-        lseek = 19,\n-        getpid = 20,\n-        mount = 21,\n-        umount = 22,\n-        setuid = 23,\n-        getuid = 24,\n-        stime = 25,\n-        ptrace = 26,\n-        alarm = 27,\n-        oldfstat = 28,\n-        pause = 29,\n-        utime = 30,\n-        stty = 31,\n-        gtty = 32,\n-        access = 33,\n-        nice = 34,\n-        ftime = 35,\n-        sync = 36,\n-        kill = 37,\n-        rename = 38,\n-        mkdir = 39,\n-        rmdir = 40,\n-        dup = 41,\n-        pipe = 42,\n-        times = 43,\n-        prof = 44,\n-        brk = 45,\n-        setgid = 46,\n-        getgid = 47,\n-        signal = 48,\n-        geteuid = 49,\n-        getegid = 50,\n-        acct = 51,\n-        umount2 = 52,\n-        lock = 53,\n-        ioctl = 54,\n-        fcntl = 55,\n-        mpx = 56,\n-        setpgid = 57,\n-        ulimit = 58,\n-        oldolduname = 59,\n-        umask = 60,\n-        chroot = 61,\n-        ustat = 62,\n-        dup2 = 63,\n-        getppid = 64,\n-        getpgrp = 65,\n-        setsid = 66,\n-        sigaction = 67,\n-        sgetmask = 68,\n-        ssetmask = 69,\n-        setreuid = 70,\n-        setregid = 71,\n-        sigsuspend = 72,\n-        sigpending = 73,\n-        sethostname = 74,\n-        setrlimit = 75,\n-        getrlimit = 76,\n-        getrusage = 77,\n-        gettimeofday = 78,\n-        settimeofday = 79,\n-        getgroups = 80,\n-        setgroups = 81,\n-        select = 82,\n-        symlink = 83,\n-        oldlstat = 84,\n-        readlink = 85,\n-        uselib = 86,\n-        swapon = 87,\n-        reboot = 88,\n-        readdir = 89,\n-        mmap = 90,\n-        munmap = 91,\n-        truncate = 92,\n-        ftruncate = 93,\n-        fchmod = 94,\n-        fchown = 95,\n-        getpriority = 96,\n-        setpriority = 97,\n-        profil = 98,\n-        statfs = 99,\n-        fstatfs = 100,\n-        ioperm = 101,\n-        socketcall = 102,\n-        syslog = 103,\n-        setitimer = 104,\n-        getitimer = 105,\n-        stat = 106,\n-        lstat = 107,\n-        fstat = 108,\n-        olduname = 109,\n-        iopl = 110,\n-        vhangup = 111,\n-        idle = 112,\n-        vm86old = 113,\n-        wait4 = 114,\n-        swapoff = 115,\n-        sysinfo = 116,\n-        ipc = 117,\n-        fsync = 118,\n-        sigreturn = 119,\n-        clone = 120,\n-        setdomainname = 121,\n-        uname = 122,\n-        modify_ldt = 123,\n-        adjtimex = 124,\n-        mprotect = 125,\n-        sigprocmask = 126,\n-        create_module = 127,\n-        init_module = 128,\n-        delete_module = 129,\n-        get_kernel_syms = 130,\n-        quotactl = 131,\n-        getpgid = 132,\n-        fchdir = 133,\n-        bdflush = 134,\n-        sysfs = 135,\n-        personality = 136,\n-        afs_syscall = 137,\n-        setfsuid = 138,\n-        setfsgid = 139,\n-        _llseek = 140,\n-        getdents = 141,\n-        _newselect = 142,\n-        flock = 143,\n-        msync = 144,\n-        readv = 145,\n-        writev = 146,\n-        getsid = 147,\n-        fdatasync = 148,\n-        _sysctl = 149,\n-        mlock = 150,\n-        munlock = 151,\n-        mlockall = 152,\n-        munlockall = 153,\n-        sched_setparam = 154,\n-        sched_getparam = 155,\n-        sched_setscheduler = 156,\n-        sched_getscheduler = 157,\n-        sched_yield = 158,\n-        sched_get_priority_max = 159,\n-        sched_get_priority_min = 160,\n-        sched_rr_get_interval = 161,\n-        nanosleep = 162,\n-        mremap = 163,\n-        setresuid = 164,\n-        getresuid = 165,\n-        vm86 = 166,\n-        query_module = 167,\n-        poll = 168,\n-        nfsservctl = 169,\n-        setresgid = 170,\n-        getresgid = 171,\n-        prctl = 172,\n-        rt_sigreturn = 173,\n-        rt_sigaction = 174,\n-        rt_sigprocmask = 175,\n-        rt_sigpending = 176,\n-        rt_sigtimedwait = 177,\n-        rt_sigqueueinfo = 178,\n-        rt_sigsuspend = 179,\n-        pread64 = 180,\n-        pwrite64 = 181,\n-        chown = 182,\n-        getcwd = 183,\n-        capget = 184,\n-        capset = 185,\n-        sigaltstack = 186,\n-        sendfile = 187,\n-        getpmsg = 188,\n-        putpmsg = 189,\n-        vfork = 190,\n-        ugetrlimit = 191,\n-        mmap2 = 192,\n-        truncate64 = 193,\n-        ftruncate64 = 194,\n-        stat64 = 195,\n-        lstat64 = 196,\n-        fstat64 = 197,\n-        lchown32 = 198,\n-        getuid32 = 199,\n-        getgid32 = 200,\n-        geteuid32 = 201,\n-        getegid32 = 202,\n-        setreuid32 = 203,\n-        setregid32 = 204,\n-        getgroups32 = 205,\n-        setgroups32 = 206,\n-        fchown32 = 207,\n-        setresuid32 = 208,\n-        getresuid32 = 209,\n-        setresgid32 = 210,\n-        getresgid32 = 211,\n-        chown32 = 212,\n-        setuid32 = 213,\n-        setgid32 = 214,\n-        setfsuid32 = 215,\n-        setfsgid32 = 216,\n-        pivot_root = 217,\n-        mincore = 218,\n-        madvise = 219,\n-        getdents64 = 220,\n-        fcntl64 = 221,\n-        gettid = 224,\n-        readahead = 225,\n-        setxattr = 226,\n-        lsetxattr = 227,\n-        fsetxattr = 228,\n-        getxattr = 229,\n-        lgetxattr = 230,\n-        fgetxattr = 231,\n-        listxattr = 232,\n-        llistxattr = 233,\n-        flistxattr = 234,\n-        removexattr = 235,\n-        lremovexattr = 236,\n-        fremovexattr = 237,\n-        tkill = 238,\n-        sendfile64 = 239,\n-        futex = 240,\n-        sched_setaffinity = 241,\n-        sched_getaffinity = 242,\n-        set_thread_area = 243,\n-        get_thread_area = 244,\n-        io_setup = 245,\n-        io_destroy = 246,\n-        io_getevents = 247,\n-        io_submit = 248,\n-        io_cancel = 249,\n-        fadvise64 = 250,\n-        exit_group = 252,\n-        lookup_dcookie = 253,\n-        epoll_create = 254,\n-        epoll_ctl = 255,\n-        epoll_wait = 256,\n-        remap_file_pages = 257,\n-        set_tid_address = 258,\n-        timer_create = 259,\n-        timer_settime = 260,\n-        timer_gettime = 261,\n-        timer_getoverrun = 262,\n-        timer_delete = 263,\n-        clock_settime = 264,\n-        clock_gettime = 265,\n-        clock_getres = 266,\n-        clock_nanosleep = 267,\n-        statfs64 = 268,\n-        fstatfs64 = 269,\n-        tgkill = 270,\n-        utimes = 271,\n-        fadvise64_64 = 272,\n-        vserver = 273,\n-        mbind = 274,\n-        get_mempolicy = 275,\n-        set_mempolicy = 276,\n-        mq_open = 277,\n-        mq_unlink = 278,\n-        mq_timedsend = 279,\n-        mq_timedreceive = 280,\n-        mq_notify = 281,\n-        mq_getsetattr = 282,\n-        kexec_load = 283,\n-        waitid = 284,\n-        add_key = 286,\n-        request_key = 287,\n-        keyctl = 288,\n-        ioprio_set = 289,\n-        ioprio_get = 290,\n-        inotify_init = 291,\n-        inotify_add_watch = 292,\n-        inotify_rm_watch = 293,\n-        migrate_pages = 294,\n-        openat = 295,\n-        mkdirat = 296,\n-        mknodat = 297,\n-        fchownat = 298,\n-        futimesat = 299,\n-        fstatat64 = 300,\n-        unlinkat = 301,\n-        renameat = 302,\n-        linkat = 303,\n-        symlinkat = 304,\n-        readlinkat = 305,\n-        fchmodat = 306,\n-        faccessat = 307,\n-        pselect6 = 308,\n-        ppoll = 309,\n-        unshare = 310,\n-        set_robust_list = 311,\n-        get_robust_list = 312,\n-        splice = 313,\n-        sync_file_range = 314,\n-        tee = 315,\n-        vmsplice = 316,\n-        move_pages = 317,\n-        getcpu = 318,\n-        epoll_pwait = 319,\n-        utimensat = 320,\n-        signalfd = 321,\n-        timerfd_create = 322,\n-        eventfd = 323,\n-        fallocate = 324,\n-        timerfd_settime = 325,\n-        timerfd_gettime = 326,\n-        signalfd4 = 327,\n-        eventfd2 = 328,\n-        epoll_create1 = 329,\n-        dup3 = 330,\n-        pipe2 = 331,\n-        inotify_init1 = 332,\n-        preadv = 333,\n-        pwritev = 334,\n-        rt_tgsigqueueinfo = 335,\n-        perf_event_open = 336,\n-        recvmmsg = 337,\n-        fanotify_init = 338,\n-        fanotify_mark = 339,\n-        prlimit64 = 340,\n-        name_to_handle_at = 341,\n-        open_by_handle_at = 342,\n-        clock_adjtime = 343,\n-        syncfs = 344,\n-        sendmmsg = 345,\n-        setns = 346,\n-        process_vm_readv = 347,\n-        process_vm_writev = 348,\n-        kcmp = 349,\n-        finit_module = 350,\n-        sched_setattr = 351,\n-        sched_getattr = 352,\n-        renameat2 = 353,\n-        seccomp = 354,\n-        getrandom = 355,\n-        memfd_create = 356,\n-        bpf = 357,\n-        execveat = 358,\n-        socket = 359,\n-        socketpair = 360,\n-        bind = 361,\n-        connect = 362,\n-        listen = 363,\n-        accept4 = 364,\n-        getsockopt = 365,\n-        setsockopt = 366,\n-        getsockname = 367,\n-        getpeername = 368,\n-        sendto = 369,\n-        sendmsg = 370,\n-        recvfrom = 371,\n-        recvmsg = 372,\n-        shutdown = 373,\n-        userfaultfd = 374,\n-        membarrier = 375,\n-        mlock2 = 376,\n-        copy_file_range = 377,\n-        preadv2 = 378,\n-        pwritev2 = 379,\n-        pkey_mprotect = 380,\n-        pkey_alloc = 381,\n-        pkey_free = 382,\n-        statx = 383,\n-        arch_prctl = 384,\n-    }\n-}"}, {"sha": "4845746700558f904eda7cbeff7b93f9687966cb", "filename": "libphobos/libdruntime/core/sys/linux/unistd.d", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Funistd.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Funistd.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Funistd.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -1,20 +1,16 @@\n module core.sys.linux.unistd;\n \n+public import core.sys.posix.unistd;\n+\n version (linux):\n-extern (C):\n+extern(C):\n nothrow:\n @system:\n-@nogc:\n-\n-public import core.sys.posix.unistd;\n-public import core.sys.linux.syscalls : SystemCall;\n-import core.stdc.config : c_long;\n \n // Additional seek constants for sparse file handling\n // from Linux's unistd.h, stdio.h, and linux/fs.h\n // (see http://man7.org/linux/man-pages/man2/lseek.2.html)\n-enum\n-{\n+enum {\n     /// Offset is relative to the next location containing data\n     SEEK_DATA = 3,\n     /// Offset is relative to the next hole (or EOF if file is not sparse)\n@@ -26,17 +22,3 @@ char* getpass(const(char)* prompt);\n \n // Exit all threads in a process\n void exit_group(int status);\n-\n-/**\n-Invoke system call specified by number, passing it the remaining arguments.\n-This is completely system-dependent, and not often useful.\n-\n-In Unix, `syscall' sets `errno' for all errors and most calls return -1\n-for errors; in many systems you cannot pass arguments or get return\n-values for all system calls (`pipe', `fork', and `getppid' typically\n-among them).\n-\n-In Mach, all system calls take normal arguments and always return an\n-error code (zero for success).\n-*/\n-c_long syscall(SystemCall number, ...) @nogc nothrow;"}, {"sha": "f1281da275b7ea00678e88594931bebc0f7b90ff", "filename": "libphobos/libdruntime/core/sys/netbsd/string.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fnetbsd%2Fstring.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fnetbsd%2Fstring.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fnetbsd%2Fstring.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -17,5 +17,5 @@ nothrow:\n \n static if (_NETBSD_SOURCE)\n {\n-    pure void* memmem(return const void* haystack, size_t haystacklen, scope const void* needle, size_t needlelen);\n+    pure void* memmem(return scope const void* haystack, size_t haystacklen, scope const void* needle, size_t needlelen);\n }"}, {"sha": "4480c94ac37b66d4b057a9059a82c10531dced7a", "filename": "libphobos/libdruntime/core/sys/openbsd/string.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fstring.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fstring.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fstring.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -18,7 +18,7 @@ nothrow:\n static if (__BSD_VISIBLE)\n {\n     void explicit_bzero(void*, size_t);\n-    pure void* memmem(return const void* haystack, size_t haystacklen, scope const void* needle, size_t needlelen);\n+    pure void* memmem(return scope const void* haystack, size_t haystacklen, scope const void* needle, size_t needlelen);\n     void* memrchr(scope const void*, int, size_t);\n     size_t strlcat(char*, scope const char*, size_t);\n     size_t strlcpy(char*, scope const char*, size_t);"}, {"sha": "32e51561562acd1108a6414dc5a80e7b07077c1f", "filename": "libphobos/libdruntime/core/sys/posix/signal.d", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsignal.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsignal.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsignal.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -513,15 +513,21 @@ else version (DragonFlyBSD)\n }\n else version (Solaris)\n {\n+    //SIGABRT (defined in core.stdc.signal)\n     enum SIGALRM = 14;\n     enum SIGBUS = 10;\n     enum SIGCHLD = 18;\n     enum SIGCONT = 25;\n+    //SIGFPE (defined in core.stdc.signal)\n     enum SIGHUP = 1;\n+    //SIGILL (defined in core.stdc.signal)\n+    //SIGINT (defined in core.stdc.signal)\n     enum SIGKILL = 9;\n     enum SIGPIPE = 13;\n     enum SIGQUIT = 3;\n+    //SIGSEGV (defined in core.stdc.signal)\n     enum SIGSTOP = 23;\n+    //SIGTERM (defined in core.stdc.signal)\n     enum SIGTSTP = 24;\n     enum SIGTTIN = 26;\n     enum SIGTTOU = 27;\n@@ -1339,6 +1345,10 @@ else version (Solaris)\n         uint[4] __bits;\n     }\n \n+    enum SIG_BLOCK = 1;\n+    enum SIG_UNBLOCK = 2;\n+    enum SIG_SETMASK = 3;\n+\n     struct siginfo_t\n     {\n         int si_signo;\n@@ -1427,6 +1437,18 @@ else version (Solaris)\n         ___data __data;\n     }\n \n+    enum SI_NOINFO  = 32767;\n+    enum SI_DTRACE  = 2050;\n+    enum SI_RCTL    = 2049;\n+    enum SI_USER    = 0;\n+    enum SI_LWP     = -1;\n+    enum SI_QUEUE   = -2;\n+    enum SI_TIMER   = -3;\n+    enum SI_ASYNCIO = -4;\n+    enum SI_MESGQ   = -5;\n+\n+    enum SIGIO = SIGPOLL;\n+\n     int kill(pid_t, int);\n     int sigaction(int, const scope sigaction_t*, sigaction_t*);\n     int sigaddset(sigset_t*, int);\n@@ -2833,9 +2855,9 @@ else version (Solaris)\n     enum SIGPROF = 29;\n     enum SIGSYS = 12;\n     enum SIGTRAP = 5;\n-    enum SIGVTALRM = 31;\n+    enum SIGVTALRM = 28;\n     enum SIGXCPU = 30;\n-    enum SIGXFSZ = 25;\n+    enum SIGXFSZ = 31;\n \n     enum\n     {"}, {"sha": "79d25624e2afb3bf15f47a789a08c3ae45352baa", "filename": "libphobos/libdruntime/core/sys/posix/string.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fstring.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fstring.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fstring.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -31,11 +31,11 @@ public import core.sys.posix.locale : locale_t;\n public import core.stdc.string;\n \n /// Copy string until character found\n-void*  memccpy(return void* dst, scope const void* src, int c, size_t n) pure;\n+void*  memccpy(return scope void* dst, scope const void* src, int c, size_t n) pure;\n /// Copy string (including terminating '\\0')\n-char*  stpcpy(return char* dst, scope const char* src) pure;\n+char*  stpcpy(return scope char* dst, scope const char* src) pure;\n /// Ditto\n-char*  stpncpy(return char* dst, const char* src, size_t len) pure;\n+char*  stpncpy(return scope char* dst, const char* src, size_t len) pure;\n /// Compare strings according to current collation\n int    strcoll_l(scope const char* s1, scope const char* s2, locale_t locale);\n ///\n@@ -47,6 +47,6 @@ size_t strnlen(scope const char* str, size_t maxlen) pure;\n /// System signal messages\n const(char)*  strsignal(int);\n /// Isolate sequential tokens in a null-terminated string\n-char*  strtok_r(return char* str, scope const char* sep, char** context) pure;\n+char*  strtok_r(return scope char* str, scope const char* sep, char** context) pure;\n /// Transform a string under locale\n size_t strxfrm_l(char* s1, scope const char* s2, size_t n, locale_t locale);"}, {"sha": "6e0cfd3ac3d8eb91355affc9a182451275e296b5", "filename": "libphobos/libdruntime/core/sys/posix/sys/socket.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fsocket.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fsocket.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fsocket.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -217,7 +217,7 @@ version (CRuntime_Glibc)\n     }\n     else\n     {\n-        extern (D) inout(ubyte)*   CMSG_DATA( return inout(cmsghdr)* cmsg ) pure nothrow @nogc { return cast(ubyte*)( cmsg + 1 ); }\n+        extern (D) inout(ubyte)*   CMSG_DATA( return scope inout(cmsghdr)* cmsg ) pure nothrow @nogc { return cast(ubyte*)( cmsg + 1 ); }\n     }\n \n     private inout(cmsghdr)* __cmsg_nxthdr(inout(msghdr)*, inout(cmsghdr)*) pure nothrow @nogc;"}, {"sha": "7a46d520cc3852261e6c1559a22b38a0de68ed3e", "filename": "libphobos/libdruntime/core/sys/solaris/sys/elf.d", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fsolaris%2Fsys%2Felf.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fsolaris%2Fsys%2Felf.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fsolaris%2Fsys%2Felf.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -393,7 +393,7 @@ enum SHF_LINK_ORDER       = 0x80;\n enum SHF_OS_NONCONFORMING = 0x100;\n enum SHF_GROUP            = 0x200;\n enum SHF_TLS              = 0x400;\n-\n+enum SHF_COMPRESSED       = 0x800;\n enum SHF_MASKOS = 0x0ff00000;\n \n enum SHF_MASKPROC = 0xf0000000;\n@@ -656,3 +656,6 @@ enum NT_ZONENAME   = 21;\n enum NT_FDINFO     = 22;\n enum NT_SPYMASTER  = 23;\n enum NT_NUM        = 23;\n+\n+enum SHF_ORDERED = 0x40000000;\n+enum SHF_EXCLUDE = 0x80000000;"}, {"sha": "9927b64aec9de4edcdc67c4402a5a9f295f712c1", "filename": "libphobos/libdruntime/core/sys/solaris/sys/elf_386.d", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fsolaris%2Fsys%2Felf_386.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fsolaris%2Fsys%2Felf_386.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fsolaris%2Fsys%2Felf_386.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -52,9 +52,6 @@ enum R_386_NUM          = 39;\n \n enum ELF_386_MAXPGSZ = 0x10000;\n \n-enum SHF_ORDERED = 0x40000000;\n-enum SHF_EXCLUDE = 0x80000000;\n-\n enum SHN_BEFORE = 0xff00;\n enum SHN_AFTER  = 0xff01;\n "}, {"sha": "e43bd405b8ad1da7812b58154d3192d139332137", "filename": "libphobos/libdruntime/core/sys/solaris/sys/elf_SPARC.d", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fsolaris%2Fsys%2Felf_SPARC.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fsolaris%2Fsys%2Felf_SPARC.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fsolaris%2Fsys%2Felf_SPARC.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -118,9 +118,6 @@ enum ELF_SPARCV9_MAXPGSZ = 0x100000;\n \n enum SHT_SPARC_GOTDATA = 0x70000000;\n \n-enum SHF_ORDERED = 0x40000000;\n-enum SHF_EXCLUDE = 0x80000000;\n-\n enum SHN_BEFORE = 0xff00;\n enum SHN_AFTER  =  0xff01;\n "}, {"sha": "96698e8f0f9217e9da4ddced8aae3e4711edb2a4", "filename": "libphobos/libdruntime/core/sys/windows/dbghelp.d", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fdbghelp.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fdbghelp.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fdbghelp.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -39,7 +39,8 @@ extern(Windows)\n     alias BOOL         function(HANDLE hProcess, DWORD64 Address, DWORD64 *Displacement, IMAGEHLP_SYMBOLA64 *Symbol) SymGetSymFromAddr64Func;\n     alias DWORD        function(PCSTR DecoratedName, PSTR UnDecoratedName, DWORD UndecoratedLength, DWORD Flags) UnDecorateSymbolNameFunc;\n     alias DWORD64      function(HANDLE hProcess, HANDLE hFile, PCSTR ImageName, PCSTR ModuleName, DWORD64 BaseOfDll, DWORD SizeOfDll) SymLoadModule64Func;\n-    alias BOOL         function(HANDLE HProcess, PTSTR SearchPath, DWORD SearchPathLength) SymGetSearchPathFunc;\n+    alias BOOL         function(HANDLE hProcess, PSTR SearchPath, DWORD SearchPathLength) SymGetSearchPathFunc;\n+    alias BOOL         function(HANDLE hProcess, PCSTR SearchPath) SymSetSearchPathFunc;\n     alias BOOL         function(HANDLE hProcess, DWORD64 Address) SymUnloadModule64Func;\n     alias BOOL         function(HANDLE hProcess, ULONG ActionCode, ulong CallbackContext, ulong UserContext) PSYMBOL_REGISTERED_CALLBACK64;\n     alias BOOL         function(HANDLE hProcess, PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction, ulong UserContext) SymRegisterCallback64Func;\n@@ -61,6 +62,7 @@ struct DbgHelp\n     UnDecorateSymbolNameFunc UnDecorateSymbolName;\n     SymLoadModule64Func      SymLoadModule64;\n     SymGetSearchPathFunc     SymGetSearchPath;\n+    SymSetSearchPathFunc     SymSetSearchPath;\n     SymUnloadModule64Func    SymUnloadModule64;\n     SymRegisterCallback64Func SymRegisterCallback64;\n     ImagehlpApiVersionFunc   ImagehlpApiVersion;\n@@ -84,14 +86,16 @@ struct DbgHelp\n             sm_inst.UnDecorateSymbolName     = cast(UnDecorateSymbolNameFunc) GetProcAddress(sm_hndl,\"UnDecorateSymbolName\");\n             sm_inst.SymLoadModule64          = cast(SymLoadModule64Func) GetProcAddress(sm_hndl,\"SymLoadModule64\");\n             sm_inst.SymGetSearchPath         = cast(SymGetSearchPathFunc) GetProcAddress(sm_hndl,\"SymGetSearchPath\");\n+            sm_inst.SymSetSearchPath         = cast(SymSetSearchPathFunc) GetProcAddress(sm_hndl,\"SymSetSearchPath\");\n             sm_inst.SymUnloadModule64        = cast(SymUnloadModule64Func) GetProcAddress(sm_hndl,\"SymUnloadModule64\");\n             sm_inst.SymRegisterCallback64    = cast(SymRegisterCallback64Func) GetProcAddress(sm_hndl, \"SymRegisterCallback64\");\n             sm_inst.ImagehlpApiVersion       = cast(ImagehlpApiVersionFunc) GetProcAddress(sm_hndl, \"ImagehlpApiVersion\");\n             assert( sm_inst.SymInitialize && sm_inst.SymCleanup && sm_inst.StackWalk64 && sm_inst.SymGetOptions &&\n                     sm_inst.SymSetOptions && sm_inst.SymFunctionTableAccess64 && sm_inst.SymGetLineFromAddr64 &&\n                     sm_inst.SymGetModuleBase64 && sm_inst.SymGetModuleInfo64 && sm_inst.SymGetSymFromAddr64 &&\n                     sm_inst.UnDecorateSymbolName && sm_inst.SymLoadModule64 && sm_inst.SymGetSearchPath &&\n-                    sm_inst.SymUnloadModule64 && sm_inst.SymRegisterCallback64 && sm_inst.ImagehlpApiVersion);\n+                    sm_inst.SymSetSearchPath && sm_inst.SymUnloadModule64 && sm_inst.SymRegisterCallback64 &&\n+                    sm_inst.ImagehlpApiVersion);\n \n             return &sm_inst;\n         }"}, {"sha": "fe4d24fafce5f82a886180b974cc3333f0bf58e2", "filename": "libphobos/libdruntime/core/thread/osthread.d", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fthread%2Fosthread.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fthread%2Fosthread.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fthread%2Fosthread.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -719,7 +719,7 @@ class Thread : ThreadBase\n                     // the effective maximum.\n \n                     // maxupri\n-                    result.PRIORITY_MIN = -clinfo[0];\n+                    result.PRIORITY_MIN = -cast(int)(clinfo[0]);\n                     // by definition\n                     result.PRIORITY_DEFAULT = 0;\n                 }\n@@ -2196,8 +2196,7 @@ extern (C) void thread_init() @nogc\n         status = sem_init( &suspendCount, 0, 0 );\n         assert( status == 0 );\n     }\n-    if (typeid(Thread).initializer.ptr)\n-        _mainThreadStore[] = typeid(Thread).initializer[];\n+    _mainThreadStore[] = __traits(initSymbol, Thread)[];\n     Thread.sm_main = attachThread((cast(Thread)_mainThreadStore.ptr).__ctor());\n }\n "}, {"sha": "9cee4d8d77d270520011a851f4c5210ef54879c6", "filename": "libphobos/libdruntime/core/thread/threadbase.d", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fthread%2Fthreadbase.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fcore%2Fthread%2Fthreadbase.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fthread%2Fthreadbase.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -771,10 +771,7 @@ package void thread_term_tpl(ThreadT, MainThreadStore)(ref MainThreadStore _main\n     // destruct manually as object.destroy is not @nogc\n     (cast(ThreadT) cast(void*) ThreadBase.sm_main).__dtor();\n     _d_monitordelete_nogc(ThreadBase.sm_main);\n-    if (typeid(ThreadT).initializer.ptr)\n-        _mainThreadStore[] = typeid(ThreadT).initializer[];\n-    else\n-        (cast(ubyte[])_mainThreadStore)[] = 0;\n+    _mainThreadStore[] = __traits(initSymbol, ThreadT)[];\n     ThreadBase.sm_main = null;\n \n     assert(ThreadBase.sm_tbeg && ThreadBase.sm_tlen == 1);"}, {"sha": "fee19ae65f0b7e9ac42c296f620432233ba7db8e", "filename": "libphobos/libdruntime/object.d", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fobject.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Fobject.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fobject.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -3485,7 +3485,7 @@ enum immutable(void)* rtinfoHasPointers = cast(void*)1;\n \n // Helper functions\n \n-private inout(TypeInfo) getElement(return inout TypeInfo value) @trusted pure nothrow\n+private inout(TypeInfo) getElement(return scope inout TypeInfo value) @trusted pure nothrow\n {\n     TypeInfo element = cast() value;\n     for (;;)\n@@ -4215,8 +4215,8 @@ void destroy(bool initialize = true, T)(T obj) if (is(T == class))\n \n         static if (initialize)\n         {\n-            enum classSize = __traits(classInstanceSize, T);\n-            (cast(void*)obj)[0 .. classSize] = typeid(T).initializer[];\n+            const initializer = __traits(initSymbol, T);\n+            (cast(void*)obj)[0 .. initializer.length] = initializer[];\n         }\n     }\n     else\n@@ -4651,6 +4651,8 @@ public import core.internal.array.construction : _d_arrayctor;\n public import core.internal.array.construction : _d_arraysetctor;\n public import core.internal.array.capacity: _d_arraysetlengthTImpl;\n \n+public import core.lifetime : _d_delstruct;\n+\n public import core.internal.dassert: _d_assert_fail;\n \n public import core.internal.destruction: __ArrayDtor;"}, {"sha": "0c38622a8790980d0d6641e0fafc96efd159733f", "filename": "libphobos/libdruntime/rt/aaA.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Frt%2FaaA.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Frt%2FaaA.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2FaaA.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -287,7 +287,7 @@ TypeInfo_Struct fakeEntryTI(ref Impl aa, const TypeInfo keyti, const TypeInfo va\n     void* p = GC.malloc(sizeti + (2 + rtisize) * (void*).sizeof);\n     import core.stdc.string : memcpy;\n \n-    memcpy(p, typeid(TypeInfo_Struct).initializer().ptr, sizeti);\n+    memcpy(p, __traits(initSymbol, TypeInfo_Struct).ptr, sizeti);\n \n     auto ti = cast(TypeInfo_Struct) p;\n     auto extra = cast(TypeInfo*)(p + sizeti);\n@@ -853,7 +853,7 @@ struct Range\n \n extern (C) pure nothrow @nogc @safe\n {\n-    Range _aaRange(return AA aa)\n+    Range _aaRange(return scope AA aa)\n     {\n         if (!aa)\n             return Range();"}, {"sha": "1604510b4277ebf2211f879d0206a279e90f4522", "filename": "libphobos/libdruntime/rt/cast_.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Frt%2Fcast_.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Frt%2Fcast_.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Fcast_.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -36,7 +36,7 @@ extern (D) private bool areClassInfosEqual(scope const ClassInfo a, scope const\n  *      If it is null, return null.\n  *      Else, undefined crash\n  */\n-Object _d_toObject(return void* p)\n+Object _d_toObject(return scope void* p)\n {\n     if (!p)\n         return null;"}, {"sha": "a6605f4d60374e411e0bf5e8092069f9a287b66a", "filename": "libphobos/libdruntime/rt/config.d", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Frt%2Fconfig.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Frt%2Fconfig.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Fconfig.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -101,6 +101,9 @@ string rt_cmdlineOption(string opt, scope rt_configCallBack dg) @nogc nothrow\n     {\n         foreach (a; rt_args)\n         {\n+            if (a == \"--\")\n+                break;\n+\n             if (a.length >= opt.length + 7 && a[0..6] == \"--DRT-\" &&\n                 a[6 .. 6 + opt.length] == opt && a[6 + opt.length] == '=')\n             {"}, {"sha": "1f7a81de80faf3e62d69d0fe7c8de049c71b47d2", "filename": "libphobos/libdruntime/rt/lifetime.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Frt%2Flifetime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Frt%2Flifetime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Flifetime.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -181,7 +181,7 @@ extern (C) void _d_delstruct(void** p, TypeInfo_Struct inf) @weak\n }\n \n // strip const/immutable/shared/inout from type info\n-inout(TypeInfo) unqualify(return inout(TypeInfo) cti) pure nothrow @nogc\n+inout(TypeInfo) unqualify(return scope inout(TypeInfo) cti) pure nothrow @nogc\n {\n     TypeInfo ti = cast() cti;\n     while (ti)\n@@ -381,7 +381,7 @@ size_t __arrayAllocLength(ref BlkInfo info, const TypeInfo tinext) pure nothrow\n /**\n   get the start of the array for the given block\n   */\n-void *__arrayStart(return BlkInfo info) nothrow pure\n+void *__arrayStart(return scope BlkInfo info) nothrow pure\n {\n     return info.base + ((info.size & BIGLENGTHMASK) ? LARGEPREFIX : 0);\n }"}, {"sha": "763f439282253d6f12034b9c7da21845ff85e705", "filename": "libphobos/libdruntime/rt/monitor_.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Frt%2Fmonitor_.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Flibdruntime%2Frt%2Fmonitor_.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Fmonitor_.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -264,7 +264,7 @@ struct Monitor\n \n private:\n \n-@property ref shared(Monitor*) monitor(return Object h) pure nothrow @nogc\n+@property ref shared(Monitor*) monitor(return scope Object h) pure nothrow @nogc\n {\n     return *cast(shared Monitor**)&h.__monitor;\n }"}, {"sha": "68fefcb1ae4f5b682ad85ab8639ee188ea79fabe", "filename": "libphobos/src/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMERGE?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -1,4 +1,4 @@\n-574bf883b790340fb753d6542ec48a3ba3e6cb82\n+12329adb67fb43891d6e4e543e7257bc34db0aa7\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/phobos repository."}, {"sha": "af665c41197d5fe2199ce0ccded267f33dd7be4c", "filename": "libphobos/src/std/algorithm/iteration.d", "status": "modified", "additions": 39, "deletions": 13, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fiteration.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fiteration.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fiteration.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -3595,7 +3595,6 @@ if (isInputRange!RoR && isInputRange!(ElementType!RoR)\n     assert(res.equal(\"cba\"));\n }\n \n-\n /// Ditto\n auto joiner(RoR)(RoR r)\n if (isInputRange!RoR && isInputRange!(ElementType!RoR))\n@@ -3621,14 +3620,32 @@ if (isInputRange!RoR && isInputRange!(ElementType!RoR))\n                 _currentBack = typeof(_currentBack).init;\n         }\n \n+        void replaceCurrent(typeof(_current) current) @trusted\n+        {\n+            import core.lifetime : move;\n+\n+            current.move(_current);\n+        }\n+\n+        static if (isBidirectional)\n+        {\n+            void replaceCurrentBack(typeof(_currentBack) currentBack) @trusted\n+            {\n+                import core.lifetime : move;\n+\n+                currentBack.move(_currentBack);\n+            }\n+        }\n+\n     public:\n         this(RoR r)\n         {\n             _items = r;\n+            // field _current must be initialized in constructor, because it is nested struct\n+            _current = typeof(_current).init;\n \n             static if (isBidirectional && hasNested!Result)\n                 _currentBack = typeof(_currentBack).init;\n-            // field _current must be initialized in constructor, because it is nested struct\n             mixin(popFrontEmptyElements);\n             static if (isBidirectional)\n                 mixin(popBackEmptyElements);\n@@ -3673,13 +3690,13 @@ if (isInputRange!RoR && isInputRange!(ElementType!RoR))\n                 // consumed when a .save'd copy of ourselves is iterated over. So\n                 // we need to .save each subrange we traverse.\n                 static if (isForwardRange!RoR && isForwardRange!(ElementType!RoR))\n-                    _current = _items.front.save;\n+                    replaceCurrent(_items.front.save);\n                 else\n-                    _current = _items.front;\n+                    replaceCurrent(_items.front);\n             }\n             else\n             {\n-                _current = typeof(_current).init;\n+                replaceCurrent(typeof(_current).init);\n             }\n         };\n \n@@ -3696,9 +3713,9 @@ if (isInputRange!RoR && isInputRange!(ElementType!RoR))\n                 static if (isBidirectional)\n                 {\n                     static if (is(typeof(null) : typeof(_currentBack)))\n-                        r._currentBack = _currentBack is null ? null : _currentBack.save;\n+                        r.replaceCurrentBack(_currentBack is null ? null : _currentBack.save);\n                     else\n-                        r._currentBack = _currentBack.save;\n+                        r.replaceCurrentBack(_currentBack.save);\n                     r.reachedFinalElement = reachedFinalElement;\n                 }\n                 return r;\n@@ -3784,22 +3801,22 @@ if (isInputRange!RoR && isInputRange!(ElementType!RoR))\n                     static if (isForwardRange!RoR && isForwardRange!(ElementType!RoR))\n                     {\n                         if (reachedFinalElement)\n-                            _current = _items.back.save;\n+                            replaceCurrent(_items.back.save);\n                         else\n-                            _currentBack = _items.back.save;\n+                            replaceCurrentBack(_items.back.save);\n                     }\n                     else\n                     {\n                         if (reachedFinalElement)\n-                            _current = _items.back;\n+                            replaceCurrent(_items.back);\n                         else\n-                            _currentBack = _items.back;\n+                            replaceCurrentBack(_items.back);\n                     }\n                 }\n                 else\n                 {\n-                    _current = typeof(_current).init;\n-                    _currentBack = typeof(_currentBack).init;\n+                    replaceCurrent(typeof(_current).init);\n+                    replaceCurrentBack(typeof(_currentBack).init);\n                 }\n             };\n \n@@ -4232,6 +4249,15 @@ if (isInputRange!RoR && isInputRange!(ElementType!RoR))\n     assert([[0]].joiner.save.back == 0);\n }\n \n+// https://issues.dlang.org/show_bug.cgi?id=22561\n+@safe pure unittest\n+{\n+    import std.range : only;\n+\n+    static immutable struct S { int[] array; }\n+    assert([only(S(null))].joiner.front == S(null));\n+}\n+\n /++\n Implements the homonym function (also known as `accumulate`, $(D\n compress), `inject`, or `foldl`) present in various programming"}, {"sha": "22b7b98c229e112858f4dc41cc7c96d27d89630c", "filename": "libphobos/src/std/algorithm/mutation.d", "status": "modified", "additions": 4, "deletions": 25, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fmutation.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fmutation.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fmutation.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -886,31 +886,13 @@ if (isInputRange!Range && hasLvalueElements!Range && hasAssignableElements!Range\n     static if (hasElaborateAssign!T)\n     {\n         import std.algorithm.internal : addressOf;\n-        //Elaborate opAssign. Must go the memcpy road.\n-        //We avoid calling emplace here, because our goal is to initialize to\n-        //the static state of T.init,\n-        //So we want to avoid any un-necassarilly CC'ing of T.init\n+        //Elaborate opAssign. Must go the memcpy/memset road.\n         static if (!__traits(isZeroInit, T))\n         {\n-            auto p = typeid(T).initializer();\n             for ( ; !range.empty ; range.popFront() )\n             {\n-                static if (__traits(isStaticArray, T))\n-                {\n-                    // static array initializer only contains initialization\n-                    // for one element of the static array.\n-                    auto elemp = cast(void *) addressOf(range.front);\n-                    auto endp = elemp + T.sizeof;\n-                    while (elemp < endp)\n-                    {\n-                        memcpy(elemp, p.ptr, p.length);\n-                        elemp += p.length;\n-                    }\n-                }\n-                else\n-                {\n-                    memcpy(addressOf(range.front), p.ptr, T.sizeof);\n-                }\n+                import core.internal.lifetime : emplaceInitializer;\n+                emplaceInitializer(range.front);\n             }\n         }\n         else\n@@ -1456,10 +1438,7 @@ private void moveEmplaceImpl(T)(ref scope T target, ref return scope T source)\n             static if (__traits(isZeroInit, T))\n                 () @trusted { memset(&source, 0, sz); }();\n             else\n-            {\n-                auto init = typeid(T).initializer();\n-                () @trusted { memcpy(&source, init.ptr, sz); }();\n-            }\n+                () @trusted { memcpy(&source, __traits(initSymbol, T).ptr, sz); }();\n         }\n     }\n     else static if (isStaticArray!T)"}, {"sha": "ee68b234b1510a426da714520559e85046733740", "filename": "libphobos/src/std/algorithm/sorting.d", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fsorting.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fsorting.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fsorting.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -3121,14 +3121,14 @@ if (isRandomAccessRange!R && hasLength!R && hasSwappableElements!R &&\n     else\n         static assert(false, \"`transform` returns an unsortable qualified type: \" ~ TB.stringof);\n \n-    static trustedMalloc(size_t len) @trusted\n+    static trustedMalloc()(size_t len) @trusted\n     {\n         import core.checkedint : mulu;\n-        import core.stdc.stdlib : malloc;\n+        import core.memory : pureMalloc;\n         bool overflow;\n         const nbytes = mulu(len, T.sizeof, overflow);\n         if (overflow) assert(false, \"multiplication overflowed\");\n-        T[] result = (cast(T*) malloc(nbytes))[0 .. len];\n+        T[] result = (cast(T*) pureMalloc(nbytes))[0 .. len];\n         static if (hasIndirections!T)\n         {\n             import core.memory : GC;\n@@ -3145,15 +3145,15 @@ if (isRandomAccessRange!R && hasLength!R && hasSwappableElements!R &&\n         {\n             foreach (i; 0 .. length) collectException(destroy(xform1[i]));\n         }\n-        static void trustedFree(T[] p) @trusted\n+        static void trustedFree()(T[] p) @trusted\n         {\n-            import core.stdc.stdlib : free;\n+            import core.memory : pureFree;\n             static if (hasIndirections!T)\n             {\n                 import core.memory : GC;\n                 GC.removeRange(p.ptr);\n             }\n-            free(p.ptr);\n+            pureFree(p.ptr);\n         }\n         trustedFree(xform1);\n     }\n@@ -3186,7 +3186,7 @@ if (isRandomAccessRange!R && hasLength!R && hasSwappableElements!R)\n }\n \n ///\n-@safe unittest\n+@safe pure unittest\n {\n     import std.algorithm.iteration : map;\n     import std.numeric : entropy;\n@@ -3207,7 +3207,7 @@ if (isRandomAccessRange!R && hasLength!R && hasSwappableElements!R)\n     assert(isSorted!(\"a > b\")(map!(entropy)(arr)));\n }\n \n-@safe unittest\n+@safe pure unittest\n {\n     import std.algorithm.iteration : map;\n     import std.numeric : entropy;\n@@ -3228,7 +3228,7 @@ if (isRandomAccessRange!R && hasLength!R && hasSwappableElements!R)\n     assert(isSorted!(\"a < b\")(map!(entropy)(arr)));\n }\n \n-@safe unittest\n+@safe pure unittest\n {\n     // binary transform function\n     string[] strings = [ \"one\", \"two\", \"three\" ];\n@@ -3237,31 +3237,31 @@ if (isRandomAccessRange!R && hasLength!R && hasSwappableElements!R)\n }\n \n // https://issues.dlang.org/show_bug.cgi?id=4909\n-@safe unittest\n+@safe pure unittest\n {\n     import std.typecons : Tuple;\n     Tuple!(char)[] chars;\n     schwartzSort!\"a[0]\"(chars);\n }\n \n // https://issues.dlang.org/show_bug.cgi?id=5924\n-@safe unittest\n+@safe pure unittest\n {\n     import std.typecons : Tuple;\n     Tuple!(char)[] chars;\n     schwartzSort!((Tuple!(char) c){ return c[0]; })(chars);\n }\n \n // https://issues.dlang.org/show_bug.cgi?id=13965\n-@safe unittest\n+@safe pure unittest\n {\n     import std.typecons : Tuple;\n     Tuple!(char)[] chars;\n     schwartzSort!(\"a[0]\", SwapStrategy.stable)(chars);\n }\n \n // https://issues.dlang.org/show_bug.cgi?id=13965\n-@safe unittest\n+@safe pure unittest\n {\n     import std.algorithm.iteration : map;\n     import std.numeric : entropy;"}, {"sha": "fb383ae3f2e239d654d181828101d2011b245599", "filename": "libphobos/src/std/concurrency.d", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Fconcurrency.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Fconcurrency.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fconcurrency.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -2149,14 +2149,16 @@ private\n \n                     if (msg.convertsTo!(Args))\n                     {\n-                        static if (is(ReturnType!(t) == bool))\n+                        alias RT = ReturnType!(t);\n+                        static if (is(RT == bool))\n                         {\n                             return msg.map(op);\n                         }\n                         else\n                         {\n                             msg.map(op);\n-                            return true;\n+                            static if (!is(immutable RT == immutable noreturn))\n+                                return true;\n                         }\n                     }\n                 }\n@@ -2745,7 +2747,8 @@ auto ref initOnce(alias var)(lazy typeof(var) init, shared Mutex mutex)\n             if (!atomicLoad!(MemoryOrder.raw)(flag))\n             {\n                 var = init;\n-                atomicStore!(MemoryOrder.rel)(flag, true);\n+                static if (!is(immutable typeof(var) == immutable noreturn))\n+                    atomicStore!(MemoryOrder.rel)(flag, true);\n             }\n         }\n     }\n@@ -2827,3 +2830,26 @@ auto ref initOnce(alias var)(lazy typeof(var) init, Mutex mutex)\n     immutable expected = Aggregate(42, [1, 2, 3, 4, 5]);\n     assert(result1 == expected);\n }\n+\n+// Noreturn support\n+@system unittest\n+{\n+    static noreturn foo(int) { throw new Exception(\"\"); }\n+\n+    if (false) spawn(&foo, 1);\n+    if (false) spawnLinked(&foo, 1);\n+\n+    if (false) receive(&foo);\n+    if (false) receiveTimeout(Duration.init, &foo);\n+\n+    // Wrapped in __traits(compiles) to skip codegen which crashes dmd's backend\n+    static assert(__traits(compiles, receiveOnly!noreturn()                 ));\n+    static assert(__traits(compiles, send(Tid.init, noreturn.init)          ));\n+    static assert(__traits(compiles, prioritySend(Tid.init, noreturn.init)  ));\n+    static assert(__traits(compiles, yield(noreturn.init)                   ));\n+\n+    static assert(__traits(compiles, {\n+        __gshared noreturn n;\n+        initOnce!n(noreturn.init);\n+    }));\n+}"}, {"sha": "32d56ecc73396b972d4292e5a05376cfa744ae51", "filename": "libphobos/src/std/container/dlist.d", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Fcontainer%2Fdlist.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Fcontainer%2Fdlist.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fcontainer%2Fdlist.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -196,6 +196,12 @@ struct DList(T)\n \n         T _payload = T.init;\n \n+        this (BaseNode _base, T _payload)\n+        {\n+            this._base = _base;\n+            this._payload = _payload;\n+        }\n+\n         inout(BaseNode)* asBaseNode() inout @trusted\n         {\n             return &_base;"}, {"sha": "0b0a0b2f59f5248d658f0278756fa21255fe46bd", "filename": "libphobos/src/std/container/rbtree.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Fcontainer%2Frbtree.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Fcontainer%2Frbtree.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fcontainer%2Frbtree.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -887,7 +887,7 @@ if (is(typeof(binaryFun!less(T.init, T.init))))\n      * Returns:\n      *   true if node was added\n      */\n-    private bool _add(return Elem n)\n+    private bool _add(return scope Elem n)\n     {\n         Node result;\n         static if (!allowDuplicates)"}, {"sha": "ba2a21056c74b4e41359187070cf4b2f53b73480", "filename": "libphobos/src/std/datetime/interval.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Fdatetime%2Finterval.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Fdatetime%2Finterval.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fdatetime%2Finterval.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -8349,7 +8349,7 @@ private:\n     }\n \n     {\n-        SysTime stFunc(scope const SysTime st) { return cast(SysTime) st; }\n+        SysTime stFunc(scope const SysTime st) { return SysTime.init; }\n         auto interval = Interval!SysTime(SysTime(DateTime(2010, 7, 4, 12, 1, 7)),\n                                          SysTime(DateTime(2012, 1, 7, 14, 0, 0)));\n         auto ir = IntervalRange!(SysTime, Direction.fwd)(interval, &stFunc);\n@@ -8794,7 +8794,7 @@ private:\n     }\n \n     {\n-        SysTime stFunc(scope const SysTime st) { return cast(SysTime) st; }\n+        SysTime stFunc(scope const SysTime st) { return SysTime.init; }\n         auto posInfInterval = PosInfInterval!SysTime(SysTime(DateTime(2010, 7, 4, 12, 1, 7)));\n         auto ir = PosInfIntervalRange!SysTime(posInfInterval, &stFunc);\n     }\n@@ -9076,7 +9076,7 @@ private:\n     }\n \n     {\n-        SysTime stFunc(scope const SysTime st) { return cast(SysTime)(st); }\n+        SysTime stFunc(scope const SysTime st) { return SysTime.init; }\n         auto negInfInterval = NegInfInterval!SysTime(SysTime(DateTime(2012, 1, 7, 14, 0, 0)));\n         auto ir = NegInfIntervalRange!(SysTime)(negInfInterval, &stFunc);\n     }"}, {"sha": "9b2a8443fddac427479f1cc7a2e644c2a730861c", "filename": "libphobos/src/std/datetime/systime.d", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Fdatetime%2Fsystime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Fdatetime%2Fsystime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fdatetime%2Fsystime.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -503,7 +503,7 @@ public:\n                        given $(REF DateTime,std,datetime,date) is assumed to\n                        be in the given time zone.\n       +/\n-    this(DateTime dateTime, immutable TimeZone tz = null) @safe nothrow\n+    this(DateTime dateTime, return scope immutable TimeZone tz = null) return scope @safe nothrow\n     {\n         try\n             this(dateTime, Duration.zero, tz);\n@@ -554,7 +554,7 @@ public:\n             $(REF DateTimeException,std,datetime,date) if `fracSecs` is negative or if it's\n             greater than or equal to one second.\n       +/\n-    this(DateTime dateTime, Duration fracSecs, immutable TimeZone tz = null) @safe\n+    this(DateTime dateTime, Duration fracSecs, return scope immutable TimeZone tz = null) return scope @safe\n     {\n         enforce(fracSecs >= Duration.zero, new DateTimeException(\"A SysTime cannot have negative fractional seconds.\"));\n         enforce(fracSecs < seconds(1), new DateTimeException(\"Fractional seconds must be less than one second.\"));\n@@ -611,7 +611,7 @@ public:\n                    given $(REF Date,std,datetime,date) is assumed to be in the\n                    given time zone.\n       +/\n-    this(Date date, immutable TimeZone tz = null) @safe nothrow\n+    this(Date date, return scope immutable TimeZone tz = null) return scope @safe nothrow\n     {\n         _timezone = tz is null ? LocalTime() : tz;\n \n@@ -664,7 +664,7 @@ public:\n                       $(LREF SysTime). If null,\n                       $(REF LocalTime,std,datetime,timezone) will be used.\n       +/\n-    this(long stdTime, immutable TimeZone tz = null) @safe pure nothrow\n+    this(long stdTime, return scope immutable TimeZone tz = null) return scope @safe pure nothrow\n     {\n         _stdTime = stdTime;\n         _timezone = tz is null ? LocalTime() : tz;\n@@ -693,7 +693,7 @@ public:\n \n         Returns: The `this` of this `SysTime`.\n       +/\n-    ref SysTime opAssign()(auto ref const(SysTime) rhs) return @safe pure nothrow scope\n+    ref SysTime opAssign()(auto ref const(SysTime) rhs) return scope @safe pure nothrow\n     {\n         _stdTime = rhs._stdTime;\n         _timezone = rhs._timezone;\n@@ -710,6 +710,7 @@ public:\n         st = other;\n         assert(st == other);\n \n+        version (none) // https://issues.dlang.org/show_bug.cgi?id=21175\n         static void testScope(scope ref SysTime left, const scope SysTime right) @safe\n         {\n             left = right;\n@@ -2184,7 +2185,7 @@ public:\n         hours - adjust the time to this $(LREF SysTime)'s time zone before\n         returning.\n       +/\n-    @property immutable(TimeZone) timezone() @safe const pure nothrow scope\n+    @property immutable(TimeZone) timezone() @safe const pure nothrow return scope\n     {\n         return _timezone;\n     }\n@@ -2238,7 +2239,7 @@ public:\n     /++\n         Returns whether DST is in effect for this $(LREF SysTime).\n       +/\n-    @property bool dstInEffect() @safe const nothrow scope\n+    @property bool dstInEffect() @safe const nothrow return scope\n     {\n         return _timezone.dstInEffect(_stdTime);\n     }\n@@ -2261,7 +2262,7 @@ public:\n         Returns what the offset from UTC is for this $(LREF SysTime).\n         It includes the DST offset in effect at that time (if any).\n       +/\n-    @property Duration utcOffset() @safe const nothrow scope\n+    @property Duration utcOffset() @safe const nothrow return scope\n     {\n         return _timezone.utcOffsetAt(_stdTime);\n     }\n@@ -9586,13 +9587,13 @@ private:\n \n         @property override bool hasDST() @safe const nothrow @nogc { return false; }\n \n-        override bool dstInEffect(long stdTime) @safe const nothrow @nogc { return false; }\n+        override bool dstInEffect(long stdTime) @safe const scope nothrow @nogc { return false; }\n \n-        override long utcToTZ(long stdTime) @safe const nothrow @nogc { return 0; }\n+        override long utcToTZ(long stdTime) @safe const scope nothrow @nogc { return 0; }\n \n-        override long tzToUTC(long adjTime) @safe const nothrow @nogc { return 0; }\n+        override long tzToUTC(long adjTime) @safe const scope nothrow @nogc { return 0; }\n \n-        override Duration utcOffsetAt(long stdTime) @safe const nothrow @nogc { return Duration.zero; }\n+        override Duration utcOffsetAt(long stdTime) @safe const scope nothrow @nogc { return Duration.zero; }\n \n     private:\n \n@@ -9628,7 +9629,7 @@ private:\n         return _timezoneStorage is null ? InitTimeZone() : _timezoneStorage;\n     }\n \n-    pragma(inline, true) @property void _timezone(immutable TimeZone tz) @safe pure nothrow @nogc scope\n+    pragma(inline, true) @property void _timezone(return scope immutable TimeZone tz) @safe pure nothrow @nogc scope\n     {\n         _timezoneStorage = tz;\n     }"}, {"sha": "a55411b02d5765943bb72feb847707c4af0e9894", "filename": "libphobos/src/std/datetime/timezone.d", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Fdatetime%2Ftimezone.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Fdatetime%2Ftimezone.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fdatetime%2Ftimezone.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -100,7 +100,7 @@ public:\n         However, on Windows, it may be the unabbreviated name (e.g. Pacific\n         Standard Time). Regardless, it is not the same as name.\n       +/\n-    @property string stdName() @safe const nothrow\n+    @property string stdName() @safe const scope nothrow\n     {\n         return _stdName;\n     }\n@@ -113,7 +113,7 @@ public:\n         However, on Windows, it may be the unabbreviated name (e.g. Pacific\n         Daylight Time). Regardless, it is not the same as name.\n       +/\n-    @property string dstName() @safe const nothrow\n+    @property string dstName() @safe const scope nothrow\n     {\n         return _dstName;\n     }\n@@ -137,7 +137,7 @@ public:\n             stdTime = The UTC time that needs to be checked for DST in this time\n                       zone.\n       +/\n-    abstract bool dstInEffect(long stdTime) @safe const nothrow;\n+    abstract bool dstInEffect(long stdTime) @safe const scope nothrow;\n \n \n     /++\n@@ -148,7 +148,7 @@ public:\n             stdTime = The UTC time that needs to be adjusted to this time zone's\n                       time.\n       +/\n-    abstract long utcToTZ(long stdTime) @safe const nothrow;\n+    abstract long utcToTZ(long stdTime) @safe const scope nothrow;\n \n \n     /++\n@@ -159,7 +159,7 @@ public:\n             adjTime = The time in this time zone that needs to be adjusted to\n                       UTC time.\n       +/\n-    abstract long tzToUTC(long adjTime) @safe const nothrow;\n+    abstract long tzToUTC(long adjTime) @safe const scope nothrow;\n \n \n     /++\n@@ -170,7 +170,7 @@ public:\n             stdTime = The UTC time for which to get the offset from UTC for this\n                       time zone.\n       +/\n-    Duration utcOffsetAt(long stdTime) @safe const nothrow\n+    Duration utcOffsetAt(long stdTime) @safe const scope nothrow\n     {\n         return dur!\"hnsecs\"(utcToTZ(stdTime) - stdTime);\n     }\n@@ -580,7 +580,7 @@ public:\n         dynamically rather than it being fixed like it would be with most time\n         zones.\n       +/\n-    @property override string stdName() @trusted const nothrow\n+    @property override string stdName() @trusted const scope nothrow\n     {\n         version (Posix)\n         {\n@@ -665,7 +665,7 @@ public:\n         dynamically rather than it being fixed like it would be with most time\n         zones.\n       +/\n-    @property override string dstName() @trusted const nothrow\n+    @property override string dstName() @trusted const scope nothrow\n     {\n         version (Posix)\n         {\n@@ -809,7 +809,7 @@ public:\n             stdTime = The UTC time that needs to be checked for DST in this time\n                       zone.\n       +/\n-    override bool dstInEffect(long stdTime) @trusted const nothrow\n+    override bool dstInEffect(long stdTime) @trusted const scope nothrow\n     {\n         import core.stdc.time : tm;\n \n@@ -863,7 +863,7 @@ public:\n         See_Also:\n             `TimeZone.utcToTZ`\n       +/\n-    override long utcToTZ(long stdTime) @trusted const nothrow\n+    override long utcToTZ(long stdTime) @trusted const scope nothrow\n     {\n         version (Solaris)\n             return stdTime + convert!(\"seconds\", \"hnsecs\")(tm_gmtoff(stdTime));\n@@ -904,7 +904,7 @@ public:\n             adjTime = The time in this time zone that needs to be adjusted to\n                       UTC time.\n       +/\n-    override long tzToUTC(long adjTime) @trusted const nothrow\n+    override long tzToUTC(long adjTime) @trusted const scope nothrow\n     {\n         version (Posix)\n         {\n@@ -1159,7 +1159,7 @@ public:\n     /++\n         Always returns false.\n       +/\n-    override bool dstInEffect(long stdTime) @safe const nothrow\n+    override bool dstInEffect(long stdTime) @safe const scope nothrow\n     {\n         return false;\n     }\n@@ -1175,7 +1175,7 @@ public:\n         See_Also:\n             `TimeZone.utcToTZ`\n       +/\n-    override long utcToTZ(long stdTime) @safe const nothrow\n+    override long utcToTZ(long stdTime) @safe const scope nothrow\n     {\n         return stdTime;\n     }\n@@ -1208,7 +1208,7 @@ public:\n             adjTime = The time in this time zone that needs to be adjusted to\n                       UTC time.\n       +/\n-    override long tzToUTC(long adjTime) @safe const nothrow\n+    override long tzToUTC(long adjTime) @safe const scope nothrow\n     {\n         return adjTime;\n     }\n@@ -1238,7 +1238,7 @@ public:\n             stdTime = The UTC time for which to get the offset from UTC for this\n                       time zone.\n       +/\n-    override Duration utcOffsetAt(long stdTime) @safe const nothrow\n+    override Duration utcOffsetAt(long stdTime) @safe const scope nothrow\n     {\n         return dur!\"hnsecs\"(0);\n     }\n@@ -1285,7 +1285,7 @@ public:\n     /++\n         Always returns false.\n       +/\n-    override bool dstInEffect(long stdTime) @safe const nothrow\n+    override bool dstInEffect(long stdTime) @safe const scope nothrow\n     {\n         return false;\n     }\n@@ -1299,7 +1299,7 @@ public:\n             stdTime = The UTC time that needs to be adjusted to this time zone's\n                       time.\n       +/\n-    override long utcToTZ(long stdTime) @safe const nothrow\n+    override long utcToTZ(long stdTime) @safe const scope nothrow\n     {\n         return stdTime + _utcOffset.total!\"hnsecs\";\n     }\n@@ -1326,7 +1326,7 @@ public:\n             adjTime = The time in this time zone that needs to be adjusted to\n                       UTC time.\n       +/\n-    override long tzToUTC(long adjTime) @safe const nothrow\n+    override long tzToUTC(long adjTime) @safe const scope nothrow\n     {\n         return adjTime - _utcOffset.total!\"hnsecs\";\n     }\n@@ -1352,7 +1352,7 @@ public:\n             stdTime = The UTC time for which to get the offset from UTC for this\n                       time zone.\n       +/\n-    override Duration utcOffsetAt(long stdTime) @safe const nothrow\n+    override Duration utcOffsetAt(long stdTime) @safe const scope nothrow\n     {\n         return _utcOffset;\n     }\n@@ -1919,7 +1919,7 @@ public:\n             stdTime = The UTC time that needs to be checked for DST in this time\n                       zone.\n       +/\n-    override bool dstInEffect(long stdTime) @safe const nothrow\n+    override bool dstInEffect(long stdTime) @safe const scope nothrow\n     {\n         assert(!_transitions.empty);\n \n@@ -1943,7 +1943,7 @@ public:\n             stdTime = The UTC time that needs to be adjusted to this time zone's\n                       time.\n       +/\n-    override long utcToTZ(long stdTime) @safe const nothrow\n+    override long utcToTZ(long stdTime) @safe const scope nothrow\n     {\n         assert(!_transitions.empty);\n \n@@ -1968,7 +1968,7 @@ public:\n             adjTime = The time in this time zone that needs to be adjusted to\n                       UTC time.\n       +/\n-    override long tzToUTC(long adjTime) @safe const nothrow\n+    override long tzToUTC(long adjTime) @safe const scope nothrow\n     {\n         assert(!_transitions.empty, \"UTC offset's not available\");\n \n@@ -2691,7 +2691,7 @@ private:\n     }\n \n \n-    int calculateLeapSeconds(long stdTime) @safe const pure nothrow\n+    int calculateLeapSeconds(long stdTime) @safe const scope pure nothrow\n     {\n         if (_leapSeconds.empty)\n             return 0;\n@@ -2864,7 +2864,7 @@ version (StdDdoc)\n             current dates but will still return true for `hasDST` because the\n             time zone did at some point have DST.\n           +/\n-        @property override bool hasDST() @safe const nothrow;\n+        @property override bool hasDST() @safe const scope nothrow;\n \n \n         /++\n@@ -2876,7 +2876,7 @@ version (StdDdoc)\n                 stdTime = The UTC time that needs to be checked for DST in this\n                           time zone.\n           +/\n-        override bool dstInEffect(long stdTime) @safe const nothrow;\n+        override bool dstInEffect(long stdTime) @safe const scope nothrow;\n \n \n         /++\n@@ -2888,7 +2888,7 @@ version (StdDdoc)\n                 stdTime = The UTC time that needs to be adjusted to this time\n                           zone's time.\n           +/\n-        override long utcToTZ(long stdTime) @safe const nothrow;\n+        override long utcToTZ(long stdTime) @safe const scope nothrow;\n \n \n         /++\n@@ -2900,7 +2900,7 @@ version (StdDdoc)\n                 adjTime = The time in this time zone that needs to be adjusted\n                           to UTC time.\n           +/\n-        override long tzToUTC(long adjTime) @safe const nothrow;\n+        override long tzToUTC(long adjTime) @safe const scope nothrow;\n \n \n         /++\n@@ -2945,9 +2945,9 @@ version (StdDdoc)\n         else\n             alias TIME_ZONE_INFORMATION = void*;\n \n-        static bool _dstInEffect(const TIME_ZONE_INFORMATION* tzInfo, long stdTime) nothrow;\n-        static long _utcToTZ(const TIME_ZONE_INFORMATION* tzInfo, long stdTime, bool hasDST) nothrow;\n-        static long _tzToUTC(const TIME_ZONE_INFORMATION* tzInfo, long adjTime, bool hasDST) nothrow;\n+        static bool _dstInEffect(const scope TIME_ZONE_INFORMATION* tzInfo, long stdTime) nothrow;\n+        static long _utcToTZ(const scope TIME_ZONE_INFORMATION* tzInfo, long stdTime, bool hasDST) nothrow;\n+        static long _tzToUTC(const scope TIME_ZONE_INFORMATION* tzInfo, long adjTime, bool hasDST) nothrow;\n \n         this() immutable pure\n         {\n@@ -2967,25 +2967,25 @@ else version (Windows)\n \n     public:\n \n-        @property override bool hasDST() @safe const nothrow\n+        @property override bool hasDST() @safe const scope nothrow\n         {\n             return _tzInfo.DaylightDate.wMonth != 0;\n         }\n \n \n-        override bool dstInEffect(long stdTime) @safe const nothrow\n+        override bool dstInEffect(long stdTime) @safe const scope nothrow\n         {\n             return _dstInEffect(&_tzInfo, stdTime);\n         }\n \n \n-        override long utcToTZ(long stdTime) @safe const nothrow\n+        override long utcToTZ(long stdTime) @safe const scope nothrow\n         {\n             return _utcToTZ(&_tzInfo, stdTime, hasDST);\n         }\n \n \n-        override long tzToUTC(long adjTime) @safe const nothrow\n+        override long tzToUTC(long adjTime) @safe const scope nothrow\n         {\n             return _tzToUTC(&_tzInfo, adjTime, hasDST);\n         }\n@@ -3071,7 +3071,7 @@ else version (Windows)\n \n     private:\n \n-        static bool _dstInEffect(const TIME_ZONE_INFORMATION* tzInfo, long stdTime) @trusted nothrow\n+        static bool _dstInEffect(const scope TIME_ZONE_INFORMATION* tzInfo, long stdTime) @trusted nothrow\n         {\n             try\n             {\n@@ -3155,7 +3155,7 @@ else version (Windows)\n         }\n \n \n-        static long _utcToTZ(const TIME_ZONE_INFORMATION* tzInfo, long stdTime, bool hasDST) @safe nothrow\n+        static long _utcToTZ(const scope TIME_ZONE_INFORMATION* tzInfo, long stdTime, bool hasDST) @safe nothrow\n         {\n             if (hasDST && WindowsTimeZone._dstInEffect(tzInfo, stdTime))\n                 return stdTime - convert!(\"minutes\", \"hnsecs\")(tzInfo.Bias + tzInfo.DaylightBias);\n@@ -3164,7 +3164,7 @@ else version (Windows)\n         }\n \n \n-        static long _tzToUTC(const TIME_ZONE_INFORMATION* tzInfo, long adjTime, bool hasDST) @trusted nothrow\n+        static long _tzToUTC(const scope TIME_ZONE_INFORMATION* tzInfo, long adjTime, bool hasDST) @trusted nothrow\n         {\n             if (hasDST)\n             {"}, {"sha": "315e054cbab1aa6e4c6cf6cd61a2b67ae59ee799", "filename": "libphobos/src/std/file.d", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Ffile.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Ffile.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Ffile.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -1124,7 +1124,7 @@ version (Windows) private ulong makeUlong(DWORD dwLow, DWORD dwHigh) @safe pure\n }\n \n version (Posix) private extern (C) pragma(mangle, stat.mangleof)\n-int trustedStat(const(FSChar)* namez, ref stat_t buf) @nogc nothrow @trusted;\n+int trustedStat(scope const(FSChar)* namez, ref stat_t buf) @nogc nothrow @trusted;\n \n /**\n Get size of file `name` in bytes.\n@@ -1928,7 +1928,7 @@ if (isConvertibleToString!R)\n     assert(!f.exists);\n }\n \n-private bool existsImpl(const(FSChar)* namez) @trusted nothrow @nogc\n+private bool existsImpl(scope const(FSChar)* namez) @trusted nothrow @nogc\n {\n     version (Windows)\n     {\n@@ -2010,7 +2010,7 @@ if (isInputRange!R && !isInfinite!R && isSomeChar!(ElementEncodingType!R) &&\n     version (Windows)\n     {\n         auto namez = name.tempCString!FSChar();\n-        static auto trustedGetFileAttributesW(const(FSChar)* namez) @trusted\n+        static auto trustedGetFileAttributesW(scope const(FSChar)* namez) @trusted\n         {\n             return GetFileAttributesW(namez);\n         }\n@@ -2220,7 +2220,7 @@ if (isInputRange!R && !isInfinite!R && isSomeChar!(ElementEncodingType!R) &&\n     version (Windows)\n     {\n         auto namez = name.tempCString!FSChar();\n-        static auto trustedSetFileAttributesW(const(FSChar)* namez, uint dwFileAttributes) @trusted\n+        static auto trustedSetFileAttributesW(scope const(FSChar)* namez, uint dwFileAttributes) @trusted\n         {\n             return SetFileAttributesW(namez, dwFileAttributes);\n         }\n@@ -2233,7 +2233,7 @@ if (isInputRange!R && !isInfinite!R && isSomeChar!(ElementEncodingType!R) &&\n     else version (Posix)\n     {\n         auto namez = name.tempCString!FSChar();\n-        static auto trustedChmod(const(FSChar)* namez, mode_t mode) @trusted\n+        static auto trustedChmod(scope const(FSChar)* namez, mode_t mode) @trusted\n         {\n             return chmod(namez, mode);\n         }\n@@ -2868,14 +2868,14 @@ if (isInputRange!R && !isInfinite!R && isSomeChar!(ElementEncodingType!R) &&\n \n     version (Windows)\n     {\n-        static auto trustedChdir(const(FSChar)* pathz) @trusted\n+        static auto trustedChdir(scope const(FSChar)* pathz) @trusted\n         {\n             return SetCurrentDirectoryW(pathz);\n         }\n     }\n     else version (Posix)\n     {\n-        static auto trustedChdir(const(FSChar)* pathz) @trusted\n+        static auto trustedChdir(scope const(FSChar)* pathz) @trusted\n         {\n             return core.sys.posix.unistd.chdir(pathz) == 0;\n         }\n@@ -2939,7 +2939,7 @@ if (isInputRange!R && !isInfinite!R && isSomeChar!(ElementEncodingType!R) &&\n \n     version (Windows)\n     {\n-        static auto trustedCreateDirectoryW(const(FSChar)* pathz) @trusted\n+        static auto trustedCreateDirectoryW(scope const(FSChar)* pathz) @trusted\n         {\n             return CreateDirectoryW(pathz, null);\n         }\n@@ -2953,7 +2953,7 @@ if (isInputRange!R && !isInfinite!R && isSomeChar!(ElementEncodingType!R) &&\n     {\n         import std.conv : octal;\n \n-        static auto trustedMkdir(const(FSChar)* pathz, mode_t mode) @trusted\n+        static auto trustedMkdir(scope const(FSChar)* pathz, mode_t mode) @trusted\n         {\n             return core.sys.posix.sys.stat.mkdir(pathz, mode);\n         }\n@@ -3143,14 +3143,14 @@ if (isInputRange!R && !isInfinite!R && isSomeChar!(ElementEncodingType!R) &&\n \n     version (Windows)\n     {\n-        static auto trustedRmdir(const(FSChar)* pathz) @trusted\n+        static auto trustedRmdir(scope const(FSChar)* pathz) @trusted\n         {\n             return RemoveDirectoryW(pathz);\n         }\n     }\n     else version (Posix)\n     {\n-        static auto trustedRmdir(const(FSChar)* pathz) @trusted\n+        static auto trustedRmdir(scope const(FSChar)* pathz) @trusted\n         {\n             return core.sys.posix.unistd.rmdir(pathz) == 0;\n         }\n@@ -3859,17 +3859,17 @@ else version (Windows)\n             return _size;\n         }\n \n-        @property SysTime timeCreated() const pure nothrow scope\n+        @property SysTime timeCreated() const pure nothrow return scope\n         {\n             return cast(SysTime)_timeCreated;\n         }\n \n-        @property SysTime timeLastAccessed() const pure nothrow scope\n+        @property SysTime timeLastAccessed() const pure nothrow return scope\n         {\n             return cast(SysTime)_timeLastAccessed;\n         }\n \n-        @property SysTime timeLastModified() const pure nothrow scope\n+        @property SysTime timeLastModified() const pure nothrow return scope\n         {\n             return cast(SysTime)_timeLastModified;\n         }"}, {"sha": "b21f58d602e5f268e523b6973fbe59cce6314e34", "filename": "libphobos/src/std/internal/cstring.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Finternal%2Fcstring.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Finternal%2Fcstring.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Finternal%2Fcstring.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -227,7 +227,7 @@ private struct TempCStringBuffer(To = char)\n     @disable this(this);\n     alias ptr this; /// implicitly covert to raw pointer\n \n-    @property inout(To)* buffPtr() inout\n+    @property inout(To)* buffPtr() return inout\n     {\n         return _ptr == useStack ? _buff.ptr : _ptr;\n     }"}, {"sha": "6a93e0a16b06fd23c105e35e5fd97ee2bee04abe", "filename": "libphobos/src/std/internal/math/biguintcore.d", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Finternal%2Fmath%2Fbiguintcore.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Finternal%2Fmath%2Fbiguintcore.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Finternal%2Fmath%2Fbiguintcore.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -879,7 +879,7 @@ public:\n     }\n \n     // return x / y\n-    static BigUint divInt(T)(scope return BigUint x, T y_) pure nothrow @safe\n+    static BigUint divInt(T)(return scope BigUint x, T y_) pure nothrow @safe\n     if ( is(immutable T == immutable uint) )\n     {\n         uint y = y_;\n@@ -942,7 +942,7 @@ public:\n     }\n \n     // return x / y\n-    static BigUint div(scope return BigUint x, scope BigUint y) pure nothrow @safe\n+    static BigUint div(return scope BigUint x, scope BigUint y) pure nothrow @safe\n     {\n         if (y.data.length > x.data.length)\n             return BigUint(ZERO);\n@@ -954,7 +954,7 @@ public:\n     }\n \n     // return x % y\n-    static BigUint mod(scope return BigUint x, scope BigUint y) pure nothrow @safe\n+    static BigUint mod(return scope BigUint x, scope BigUint y) pure nothrow @safe\n     {\n         if (y.data.length > x.data.length) return x;\n         if (y.data.length == 1)\n@@ -1020,7 +1020,7 @@ public:\n      * exponentiation is used.\n      * Memory allocation is minimized: at most one temporary BigUint is used.\n      */\n-    static BigUint pow(scope return BigUint x, ulong y) pure nothrow @safe\n+    static BigUint pow(return scope BigUint x, ulong y) pure nothrow @safe\n     {\n         // Deal with the degenerate cases first.\n         if (y == 0) return BigUint(ONE);\n@@ -1259,7 +1259,7 @@ public:\n }\n \n // Remove leading zeros from x, to restore the BigUint invariant\n-inout(BigDigit) [] removeLeadingZeros(scope return inout(BigDigit) [] x) pure nothrow @safe\n+inout(BigDigit) [] removeLeadingZeros(return scope inout(BigDigit) [] x) pure nothrow @safe\n {\n     size_t k = x.length;\n     while (k>1 && x[k - 1]==0) --k;\n@@ -1916,7 +1916,7 @@ pure @safe unittest\n // every 8 digits.\n // buff.length must be data.length*8 if separator is zero,\n // or data.length*9 if separator is non-zero. It will be completely filled.\n-char [] biguintToHex(scope return char [] buff, const scope BigDigit [] data, char separator=0,\n+char [] biguintToHex(return scope char [] buff, const scope BigDigit [] data, char separator=0,\n         LetterCase letterCase = LetterCase.upper) pure nothrow @safe\n {\n     int x=0;"}, {"sha": "ea22d6357660448f9f767e5566c07dd457d897c1", "filename": "libphobos/src/std/json.d", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Fjson.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Fjson.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fjson.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -159,7 +159,7 @@ struct JSONValue\n         return store.str;\n     }\n     /// ditto\n-    @property string str(return string v) pure nothrow @nogc @trusted return // TODO make @safe\n+    @property string str(return scope string v) pure nothrow @nogc @trusted return // TODO make @safe\n     {\n         assign(v);\n         return v;\n@@ -282,7 +282,7 @@ struct JSONValue\n         return store.object;\n     }\n     /// ditto\n-    @property JSONValue[string] object(return JSONValue[string] v) pure nothrow @nogc @trusted // TODO make @safe\n+    @property JSONValue[string] object(return scope JSONValue[string] v) pure nothrow @nogc @trusted // TODO make @safe\n     {\n         assign(v);\n         return v;\n@@ -321,14 +321,14 @@ struct JSONValue\n        (*a)[0] = \"world\";  // segmentation fault\n        ---\n      */\n-    @property ref inout(JSONValue[]) array() inout pure @system\n+    @property ref inout(JSONValue[]) array() return scope inout pure @system\n     {\n         enforce!JSONException(type == JSONType.array,\n                                 \"JSONValue is not an array\");\n         return store.array;\n     }\n     /// ditto\n-    @property JSONValue[] array(return JSONValue[] v) pure nothrow @nogc @trusted scope // TODO make @safe\n+    @property JSONValue[] array(return scope JSONValue[] v) pure nothrow @nogc @trusted scope // TODO make @safe\n     {\n         assign(v);\n         return v;\n@@ -635,7 +635,7 @@ struct JSONValue\n      * Hash syntax for json objects.\n      * Throws: `JSONException` if `type` is not `JSONType.object`.\n      */\n-    ref inout(JSONValue) opIndex(return string k) inout pure @safe\n+    ref inout(JSONValue) opIndex(return scope string k) inout pure @safe\n     {\n         auto o = this.objectNoRef;\n         return *enforce!JSONException(k in o,"}, {"sha": "12a29fe44c9a111bb5428b6800195e181aad0639", "filename": "libphobos/src/std/net/isemail.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Fnet%2Fisemail.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Fnet%2Fisemail.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fnet%2Fisemail.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -1893,7 +1893,7 @@ Note that only the first item of \"matchAll\" was ever used in practice\n so we can return `const(Char)[]` instead of `const(Char)[][]` using a\n zero-length string to indicate no match.\n +/\n-const(Char)[] matchIPSuffix(Char)(return const(Char)[] s) @nogc nothrow pure @safe\n+const(Char)[] matchIPSuffix(Char)(return scope const(Char)[] s) @nogc nothrow pure @safe\n {\n     size_t end = s.length;\n     if (end < 7) return null;"}, {"sha": "958f606ff523d67aefdd2f761894366f764cf853", "filename": "libphobos/src/std/process.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Fprocess.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Fprocess.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fprocess.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -276,7 +276,7 @@ static:\n     multi-threaded programs. See e.g.\n     $(LINK2 https://www.gnu.org/software/libc/manual/html_node/Environment-Access.html#Environment-Access, glibc).\n     */\n-    inout(char)[] opIndexAssign(return inout char[] value, scope const(char)[] name) @trusted\n+    inout(char)[] opIndexAssign(return scope inout char[] value, scope const(char)[] name) @trusted\n     {\n         version (Posix)\n         {\n@@ -4385,6 +4385,7 @@ else version (Posix)\n \n     void browse(scope const(char)[] url) nothrow @nogc @safe\n     {\n+        const buffer = url.tempCString(); // Retain buffer until end of scope\n         const(char)*[3] args;\n \n         // Trusted because it's called with a zero-terminated literal\n@@ -4408,7 +4409,6 @@ else version (Posix)\n             }\n         }\n \n-        const buffer = url.tempCString(); // Retain buffer until end of scope\n         args[1] = buffer;\n         args[2] = null;\n "}, {"sha": "106e51ceedb193eb62dd9a17e7cc4a5a1edd6a6d", "filename": "libphobos/src/std/random.d", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Frandom.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Frandom.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Frandom.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -166,12 +166,16 @@ version (D_InlineAsm_X86_64) version = InlineAsm_X86_Any;\n     assert(10.iota.randomSample(3, rnd2).equal([7, 8, 9]));\n \n     // Cover all elements in an array in random order\n-    version (X86_64) // https://issues.dlang.org/show_bug.cgi?id=15147\n-    assert(10.iota.randomCover(rnd2).equal([7, 4, 2, 0, 1, 6, 8, 3, 9, 5]));\n+    version (D_LP64) // https://issues.dlang.org/show_bug.cgi?id=15147\n+        assert(10.iota.randomCover(rnd2).equal([7, 4, 2, 0, 1, 6, 8, 3, 9, 5]));\n+    else\n+        assert(10.iota.randomCover(rnd2).equal([4, 8, 7, 3, 5, 9, 2, 6, 0, 1]));\n \n     // Shuffle an array\n-    version (X86_64) // https://issues.dlang.org/show_bug.cgi?id=15147\n-    assert([0, 1, 2, 4, 5].randomShuffle(rnd2).equal([2, 0, 4, 5, 1]));\n+    version (D_LP64) // https://issues.dlang.org/show_bug.cgi?id=15147\n+        assert([0, 1, 2, 4, 5].randomShuffle(rnd2).equal([2, 0, 4, 5, 1]));\n+    else\n+        assert([0, 1, 2, 4, 5].randomShuffle(rnd2).equal([4, 2, 5, 0, 1]));\n }\n \n version (StdUnittest)"}, {"sha": "f30ea80ae443abb49833eb62302a491e3ac4449d", "filename": "libphobos/src/std/stdio.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Fstdio.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Fstdio.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fstdio.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -4650,7 +4650,7 @@ if ((isInputRange!R1 && isSomeChar!(ElementEncodingType!R1) || isSomeString!R1)\n     auto namez = name.tempCString!FSChar();\n     auto modez = mode.tempCString!FSChar();\n \n-    static _fopenImpl(const(FSChar)* namez, const(FSChar)* modez) @trusted nothrow @nogc\n+    static _fopenImpl(scope const(FSChar)* namez, scope const(FSChar)* modez) @trusted nothrow @nogc\n     {\n         version (Windows)\n         {"}, {"sha": "6dee863521da87ddf20ea0420697a5cbe2767422", "filename": "libphobos/src/std/typecons.d", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Ftypecons.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Ftypecons.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Ftypecons.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -2239,7 +2239,7 @@ if (is(T == class) || is(T == interface) || isAssociativeArray!T)\n         U stripped;\n     }\n \n-    void opAssign(T another) pure nothrow @nogc\n+    void opAssign(return scope T another) pure nothrow @nogc\n     {\n         // If `T` defines `opCast` we must infer the safety\n         static if (hasMember!(T, \"opCast\"))\n@@ -2271,7 +2271,7 @@ if (is(T == class) || is(T == interface) || isAssociativeArray!T)\n         opAssign(initializer);\n     }\n \n-    @property inout(T) get() @trusted pure nothrow @nogc inout\n+    @property inout(T) get() @trusted pure nothrow @nogc return scope inout\n     {\n         return original;\n     }\n@@ -2792,6 +2792,15 @@ struct Nullable(T)\n         }\n     }\n \n+    this (ref return scope inout Nullable!T rhs) inout\n+    {\n+        _isNull = rhs._isNull;\n+        if (!_isNull)\n+            _value.payload = rhs._value.payload;\n+        else\n+            _value = DontCallDestructorT.init;\n+    }\n+\n     /**\n      * If they are both null, then they are equal. If one is null and the other\n      * is not, then they are not equal. If they are both non-null, then they are\n@@ -3284,11 +3293,11 @@ auto nullable(T)(T t)\n     static struct S2 //inspired from 9404\n     {\n         Nullable!int ni;\n-        this(S2 other)\n+        this(ref S2 other)\n         {\n             ni = other.ni;\n         }\n-        void opAssign(S2 other)\n+        void opAssign(ref S2 other)\n         {\n             ni = other.ni;\n         }\n@@ -9566,3 +9575,21 @@ unittest\n     assert((a ^ true) == Ternary.no);\n     assert((a ^ false) == Ternary.yes);\n }\n+\n+// https://issues.dlang.org/show_bug.cgi?id=22511\n+@safe unittest\n+{\n+    static struct S\n+    {\n+        int b;\n+        @disable this(this);\n+        this (ref return scope inout S rhs) inout\n+        {\n+            this.b = rhs.b + 1;\n+        }\n+    }\n+\n+    Nullable!S s1 = S(1);\n+    Nullable!S s2 = s1;\n+    assert(s2.get().b > s1.get().b);\n+}"}, {"sha": "a27cbea177b55eb6d3947aa45f7d2a2f203280d9", "filename": "libphobos/src/std/uni/package.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Funi%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Funi%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Funi%2Fpackage.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -1987,8 +1987,8 @@ pure:\n     {\n         return this[0] == val[0] && this[1] == val[1];\n     }\n-    @property ref inout(uint) a() inout { return _tuple[0]; }\n-    @property ref inout(uint) b() inout { return _tuple[1]; }\n+    @property ref inout(uint) a() return inout { return _tuple[0]; }\n+    @property ref inout(uint) b() return inout { return _tuple[1]; }\n }\n \n /**"}, {"sha": "866ec48cbdccf7bb1e5d23f5919ccf4785ba39e7", "filename": "libphobos/src/std/utf.d", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Futf.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Fsrc%2Fstd%2Futf.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Futf.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -4315,20 +4315,20 @@ if (isSomeChar!C)\n             {\n                 enum Empty = uint.max;  // range is empty or just constructed\n \n-                this(return R r)\n+                this(return scope R r)\n                 {\n                     this.r = r;\n                 }\n \n-                this(return R r, uint buff)\n+                this(return scope R r, uint buff)\n                 {\n                     this.r = r;\n                     this.buff = buff;\n                 }\n \n                 static if (isBidirectionalRange!R)\n                 {\n-                    this(return R r, uint frontBuff, uint backBuff)\n+                    this(return scope R r, uint frontBuff, uint backBuff)\n                     {\n                         this.r = r;\n                         this.buff = frontBuff;\n@@ -4436,12 +4436,12 @@ if (isSomeChar!C)\n         {\n             static struct Result\n             {\n-                this(return R r)\n+                this(return scope R r)\n                 {\n                     this.r = r;\n                 }\n \n-                this(return R r, ushort pos, ushort fill, C[4 / C.sizeof] buf)\n+                this(return scope R r, ushort pos, ushort fill, C[4 / C.sizeof] buf)\n                 {\n                     this.r = r;\n                     this.pos = pos;\n@@ -4451,7 +4451,7 @@ if (isSomeChar!C)\n \n                 static if (isBidirectionalRange!R)\n                 {\n-                    this(return R r, ushort frontPos, ushort frontFill,\n+                    this(return scope R r, ushort frontPos, ushort frontFill,\n                          ushort backPos, ushort backFill, C[4 / C.sizeof] buf)\n                     {\n                         this.r = r;"}, {"sha": "544caa204b3a0f23a55fc53f3b9d57b5f558445d", "filename": "libphobos/testsuite/libphobos.config/config.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Ftestsuite%2Flibphobos.config%2Fconfig.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Ftestsuite%2Flibphobos.config%2Fconfig.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Ftestsuite%2Flibphobos.config%2Fconfig.exp?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -22,6 +22,7 @@ set dg-output-text [list]\n set config_test_list [list \\\n     { test19433 \"--DRT-dont-eat-me\" 0 } \\\n     { test20459 \"foo bar -- --DRT-gcopts=profile:1\" 0 } \\\n+    { test22523 \"-- --DRT-testmode=run-main\" 0 } \\\n ]\n \n # Initialize dg."}, {"sha": "f3086963f2e97950d715d188fd74cc3d0e601edd", "filename": "libphobos/testsuite/libphobos.config/test22523.d", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Ftestsuite%2Flibphobos.config%2Ftest22523.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c7d5e8846edb28e5421211ee8eaad93e234de2c/libphobos%2Ftestsuite%2Flibphobos.config%2Ftest22523.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Ftestsuite%2Flibphobos.config%2Ftest22523.d?ref=9c7d5e8846edb28e5421211ee8eaad93e234de2c", "patch": "@@ -0,0 +1,11 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22523\n+\n+import core.stdc.stdio;\n+\n+int main()\n+{\n+    puts(\"Executed main although it should be skipped!\");\n+    return 1;\n+}\n+\n+unittest {}"}]}