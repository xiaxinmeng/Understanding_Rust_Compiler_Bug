{"sha": "78b76d0884d435c6e05d023db71a8b00c0f044b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhiNzZkMDg4NGQ0MzVjNmUwNWQwMjNkYjcxYThiMDBjMGYwNDRiMg==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb.gcc@gmail.com", "date": "2006-01-03T06:20:21Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2006-01-03T06:20:21Z"}, "message": "re PR rtl-optimization/25130 (miscompilation in GCSE)\n\n\t* fold-const.c (operand_equal_p): Accept a NULL operand 0 for\n\tCOMPONENT_REFs.\n\t* emit-rtl.c (mem_attrs_htab_eq): Use iterative_hash_expr for\n\thashing trees instead of a pointer hash.\n\t(mem_attrs_htab_eq): Do a deep compare instead of a pointer\n\tcompare for MEM_EXPR.\n\n\tPR rtl-optimization/25130\n\t* cse.c (exp_equiv_p): Compare MEM_ATTRS instead of MEM_ALIAS_SET\n\twhen comparing MEMs for GCSE\n\nFrom-SVN: r109264", "tree": {"sha": "0f27e072946d5679715a3b35a103656388cb972e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f27e072946d5679715a3b35a103656388cb972e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78b76d0884d435c6e05d023db71a8b00c0f044b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78b76d0884d435c6e05d023db71a8b00c0f044b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78b76d0884d435c6e05d023db71a8b00c0f044b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78b76d0884d435c6e05d023db71a8b00c0f044b2/comments", "author": null, "committer": null, "parents": [{"sha": "0884546e1b92fe109e30cca3295e6212e4b24567", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0884546e1b92fe109e30cca3295e6212e4b24567", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0884546e1b92fe109e30cca3295e6212e4b24567"}], "stats": {"total": 51, "additions": 40, "deletions": 11}, "files": [{"sha": "da0843d3467e3b638eea8712939ebb489492d83a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78b76d0884d435c6e05d023db71a8b00c0f044b2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78b76d0884d435c6e05d023db71a8b00c0f044b2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=78b76d0884d435c6e05d023db71a8b00c0f044b2", "patch": "@@ -1,3 +1,16 @@\n+2006-01-03  Steven Bosscher  <stevenb.gcc@gmail.com>\n+\n+\t* fold-const.c (operand_equal_p): Accept a NULL operand 0 for\n+\tCOMPONENT_REFs.\n+\t* emit-rtl.c (mem_attrs_htab_eq): Use iterative_hash_expr for\n+\thashing trees instead of a pointer hash.\n+\t(mem_attrs_htab_eq): Do a deep compare instead of a pointer\n+\tcompare for MEM_EXPR.\n+\n+\tPR rtl-optimization/25130\n+\t* cse.c (exp_equiv_p): Compare MEM_ATTRS instead of MEM_ALIAS_SET\n+\twhen comparing MEMs for GCSE\n+\n 2006-01-03  Ben Elliston  <bje@au.ibm.com>\n \n \t* targhooks.h (default_decimal_float_supported_p): Declare."}, {"sha": "a352c0efadf1f17ee95b23481bfc8c0979c891f7", "filename": "gcc/cse.c", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78b76d0884d435c6e05d023db71a8b00c0f044b2/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78b76d0884d435c6e05d023db71a8b00c0f044b2/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=78b76d0884d435c6e05d023db71a8b00c0f044b2", "patch": "@@ -2538,16 +2538,26 @@ exp_equiv_p (rtx x, rtx y, int validate, bool for_gcse)\n     case MEM:\n       if (for_gcse)\n \t{\n-\t  /* Can't merge two expressions in different alias sets, since we\n-\t     can decide that the expression is transparent in a block when\n-\t     it isn't, due to it being set with the different alias set.  */\n-\t  if (MEM_ALIAS_SET (x) != MEM_ALIAS_SET (y))\n-\t    return 0;\n-\n \t  /* A volatile mem should not be considered equivalent to any\n \t     other.  */\n \t  if (MEM_VOLATILE_P (x) || MEM_VOLATILE_P (y))\n \t    return 0;\n+\n+\t  /* Can't merge two expressions in different alias sets, since we\n+\t     can decide that the expression is transparent in a block when\n+\t     it isn't, due to it being set with the different alias set.\n+\n+\t     Also, can't merge two expressions with different MEM_ATTRS.\n+\t     They could e.g. be two different entities allocated into the\n+\t     same space on the stack (see e.g. PR25130).  In that case, the\n+\t     MEM addresses can be the same, even though the two MEMs are\n+\t     absolutely not equivalent.  \n+   \n+\t     But because really all MEM attributes should be the same for\n+\t     equivalent MEMs, we just use the invariant that MEMs that have\n+\t     the same attributes share the same mem_attrs data structure.  */\n+\t  if (MEM_ATTRS (x) != MEM_ATTRS (y))\n+\t    return 0;\n \t}\n       break;\n "}, {"sha": "aaab19ed4d3d1fdb2915f8d80dcd15bd0d5722da", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78b76d0884d435c6e05d023db71a8b00c0f044b2/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78b76d0884d435c6e05d023db71a8b00c0f044b2/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=78b76d0884d435c6e05d023db71a8b00c0f044b2", "patch": "@@ -254,7 +254,7 @@ mem_attrs_htab_hash (const void *x)\n   return (p->alias ^ (p->align * 1000)\n \t  ^ ((p->offset ? INTVAL (p->offset) : 0) * 50000)\n \t  ^ ((p->size ? INTVAL (p->size) : 0) * 2500000)\n-\t  ^ (size_t) p->expr);\n+\t  ^ (size_t) iterative_hash_expr (p->expr, 0));\n }\n \n /* Returns nonzero if the value represented by X (which is really a\n@@ -267,8 +267,11 @@ mem_attrs_htab_eq (const void *x, const void *y)\n   mem_attrs *p = (mem_attrs *) x;\n   mem_attrs *q = (mem_attrs *) y;\n \n-  return (p->alias == q->alias && p->expr == q->expr && p->offset == q->offset\n-\t  && p->size == q->size && p->align == q->align);\n+  return (p->alias == q->alias && p->offset == q->offset\n+\t  && p->size == q->size && p->align == q->align\n+\t  && (p->expr == q->expr\n+\t      || (p->expr != NULL_TREE && q->expr != NULL_TREE\n+\t\t  && operand_equal_p (p->expr, q->expr, 0))));\n }\n \n /* Allocate a new mem_attrs structure and insert it into the hash table if"}, {"sha": "7cab3c464beee53ecfb2793f55e8c1d637ecace6", "filename": "gcc/fold-const.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78b76d0884d435c6e05d023db71a8b00c0f044b2/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78b76d0884d435c6e05d023db71a8b00c0f044b2/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=78b76d0884d435c6e05d023db71a8b00c0f044b2", "patch": "@@ -2635,8 +2635,11 @@ operand_equal_p (tree arg0, tree arg1, unsigned int flags)\n \t\t  && OP_SAME_WITH_NULL (3));\n \n \tcase COMPONENT_REF:\n-\t  /* Handle operand 2 the same as for ARRAY_REF.  */\n-\t  return OP_SAME (0) && OP_SAME (1) && OP_SAME_WITH_NULL (2);\n+\t  /* Handle operand 2 the same as for ARRAY_REF.  Operand 0\n+\t     may be NULL when we're called to compare MEM_EXPRs.  */\n+\t  return OP_SAME_WITH_NULL (0)\n+\t\t && OP_SAME (1)\n+\t\t && OP_SAME_WITH_NULL (2);\n \n \tcase BIT_FIELD_REF:\n \t  return OP_SAME (0) && OP_SAME (1) && OP_SAME (2);"}]}