{"sha": "8fbc67c07219646fae89ab556738fe89ec3a8cda", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGZiYzY3YzA3MjE5NjQ2ZmFlODlhYjU1NjczOGZlODllYzNhOGNkYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2004-02-12T20:48:21Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-02-12T20:48:21Z"}, "message": "* function.c (update_epilogue_consts): Teach about binary operations.\n\nFrom-SVN: r77727", "tree": {"sha": "ae858341fd9a06eaed05e5227868eec8273bc89c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae858341fd9a06eaed05e5227868eec8273bc89c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8fbc67c07219646fae89ab556738fe89ec3a8cda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fbc67c07219646fae89ab556738fe89ec3a8cda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fbc67c07219646fae89ab556738fe89ec3a8cda", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fbc67c07219646fae89ab556738fe89ec3a8cda/comments", "author": null, "committer": null, "parents": [{"sha": "a90a16f329ef47c800e3627ca4c2a9d38b176bd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a90a16f329ef47c800e3627ca4c2a9d38b176bd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a90a16f329ef47c800e3627ca4c2a9d38b176bd0"}], "stats": {"total": 32, "additions": 29, "deletions": 3}, "files": [{"sha": "d252e8ca51239707ede127c3c17856cff5a0737f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc67c07219646fae89ab556738fe89ec3a8cda/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc67c07219646fae89ab556738fe89ec3a8cda/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8fbc67c07219646fae89ab556738fe89ec3a8cda", "patch": "@@ -30,6 +30,8 @@\n \n 2004-02-12  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* function.c (update_epilogue_consts): Teach about binary operations.\n+\n \t* emit-rtl.c (set_mem_attributes_minus_bitpos): Don't kill\n \tprevious MEM_VOLATILE in REF.\n \t* function.c (fixup_var_refs): Save volatile_ok and set to 1."}, {"sha": "d51edde1a1acad8c49f9afd543f741eb1ec2235e", "filename": "gcc/function.c", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc67c07219646fae89ab556738fe89ec3a8cda/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc67c07219646fae89ab556738fe89ec3a8cda/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=8fbc67c07219646fae89ab556738fe89ec3a8cda", "patch": "@@ -7654,14 +7654,38 @@ static void\n update_epilogue_consts (rtx dest, rtx x, void *data)\n {\n   struct epi_info *p = (struct epi_info *) data;\n+  rtx new;\n \n   if (GET_CODE (dest) != REG || REGNO (dest) >= FIRST_PSEUDO_REGISTER)\n     return;\n-  else if (GET_CODE (x) == CLOBBER || ! rtx_equal_p (dest, SET_DEST (x))\n-\t   || GET_CODE (SET_SRC (x)) != CONST_INT)\n+\n+  /* If we are either clobbering a register or doing a partial set,\n+     show we don't know the value.  */\n+  else if (GET_CODE (x) == CLOBBER || ! rtx_equal_p (dest, SET_DEST (x)))\n     p->const_equiv[REGNO (dest)] = 0;\n-  else\n+\n+  /* If we are setting it to a constant, record that constant.  */\n+  else if (GET_CODE (SET_SRC (x)) == CONST_INT)\n     p->const_equiv[REGNO (dest)] = SET_SRC (x);\n+\n+  /* If this is a binary operation between a register we have been tracking\n+     and a constant, see if we can compute a new constant value.  */\n+  else if ((GET_RTX_CLASS (GET_CODE (SET_SRC (x))) == 'c'\n+\t    || GET_RTX_CLASS (GET_CODE (SET_SRC (x))) == '2')\n+\t   && GET_CODE (XEXP (SET_SRC (x), 0)) == REG\n+\t   && REGNO (XEXP (SET_SRC (x), 0)) < FIRST_PSEUDO_REGISTER\n+\t   && p->const_equiv[REGNO (XEXP (SET_SRC (x), 0))] != 0\n+\t   && GET_CODE (XEXP (SET_SRC (x), 1)) == CONST_INT\n+\t   && 0 != (new = simplify_binary_operation\n+\t\t    (GET_CODE (SET_SRC (x)), GET_MODE (dest),\n+\t\t     p->const_equiv[REGNO (XEXP (SET_SRC (x), 0))],\n+\t\t     XEXP (SET_SRC (x), 1)))\n+\t   && GET_CODE (new) == CONST_INT)\n+    p->const_equiv[REGNO (dest)] = new;\n+\n+  /* Otherwise, we can't do anything with this value.  */\n+  else\n+    p->const_equiv[REGNO (dest)] = 0;\n }\n \n /* Emit an insn to do the load shown in p->equiv_reg_src, if needed.  */"}]}