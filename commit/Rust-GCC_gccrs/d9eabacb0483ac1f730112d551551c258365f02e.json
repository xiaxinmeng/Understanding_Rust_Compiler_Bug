{"sha": "d9eabacb0483ac1f730112d551551c258365f02e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDllYWJhY2IwNDgzYWMxZjczMDExMmQ1NTE1NTFjMjU4MzY1ZjAyZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-10-23T12:38:03Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-10-23T12:38:03Z"}, "message": "re PR debug/90231 (ivopts causes <optimized away> iterator in the loop)\n\n\tPR debug/90231\n\t* tree-ssa-loop-ivopts.c (get_debug_computation_at): New function.\n\t(remove_unused_ivs): Use it instead of get_computation_at.  When\n\tchoosing best candidate, only consider candidates where\n\tget_debug_computation_at actually returns non-NULL.\n\nFrom-SVN: r277321", "tree": {"sha": "cce1aacc70ec7ffcfa8236d4d76248b296e529b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cce1aacc70ec7ffcfa8236d4d76248b296e529b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9eabacb0483ac1f730112d551551c258365f02e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9eabacb0483ac1f730112d551551c258365f02e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9eabacb0483ac1f730112d551551c258365f02e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9eabacb0483ac1f730112d551551c258365f02e/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "acfdb9605f32a99dcbddff5753928dee3932b06b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acfdb9605f32a99dcbddff5753928dee3932b06b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acfdb9605f32a99dcbddff5753928dee3932b06b"}], "stats": {"total": 115, "additions": 107, "deletions": 8}, "files": [{"sha": "23a7d18b3cd03c0c541e6ecaa3800977c6495239", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9eabacb0483ac1f730112d551551c258365f02e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9eabacb0483ac1f730112d551551c258365f02e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d9eabacb0483ac1f730112d551551c258365f02e", "patch": "@@ -1,3 +1,11 @@\n+2019-10-23  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/90231\n+\t* tree-ssa-loop-ivopts.c (get_debug_computation_at): New function.\n+\t(remove_unused_ivs): Use it instead of get_computation_at.  When\n+\tchoosing best candidate, only consider candidates where\n+\tget_debug_computation_at actually returns non-NULL.\n+\n 2019-10-23  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR tree-optimization/92131"}, {"sha": "74a3ac35c8747b30e4bf9c8e9fed9c322952d89e", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 99, "deletions": 8, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9eabacb0483ac1f730112d551551c258365f02e/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9eabacb0483ac1f730112d551551c258365f02e/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=d9eabacb0483ac1f730112d551551c258365f02e", "patch": "@@ -4089,6 +4089,94 @@ get_computation_at (class loop *loop, gimple *at,\n   return fold_convert (type, aff_combination_to_tree (&aff));\n }\n \n+/* Like get_computation_at, but try harder, even if the computation\n+   is more expensive.  Intended for debug stmts.  */\n+\n+static tree\n+get_debug_computation_at (class loop *loop, gimple *at,\n+\t\t\t  struct iv_use *use, struct iv_cand *cand)\n+{\n+  if (tree ret = get_computation_at (loop, at, use, cand))\n+    return ret;\n+\n+  tree ubase = use->iv->base, ustep = use->iv->step;\n+  tree cbase = cand->iv->base, cstep = cand->iv->step;\n+  tree var;\n+  tree utype = TREE_TYPE (ubase), ctype = TREE_TYPE (cbase);\n+  widest_int rat;\n+\n+  /* We must have a precision to express the values of use.  */\n+  if (TYPE_PRECISION (utype) >= TYPE_PRECISION (ctype))\n+    return NULL_TREE;\n+\n+  /* Try to handle the case that get_computation_at doesn't,\n+     try to express\n+     use = ubase + (var - cbase) / ratio.  */\n+  if (!constant_multiple_of (cstep, fold_convert (TREE_TYPE (cstep), ustep),\n+\t\t\t     &rat))\n+    return NULL_TREE;\n+\n+  bool neg_p = false;\n+  if (wi::neg_p (rat))\n+    {\n+      if (TYPE_UNSIGNED (ctype))\n+\treturn NULL_TREE;\n+      neg_p = true;\n+      rat = wi::neg (rat);\n+    }\n+\n+  /* If both IVs can wrap around and CAND doesn't have a power of two step,\n+     it is unsafe.  Consider uint16_t CAND with step 9, when wrapping around,\n+     the values will be ... 0xfff0, 0xfff9, 2, 11 ... and when use is say\n+     uint8_t with step 3, those values divided by 3 cast to uint8_t will be\n+     ... 0x50, 0x53, 0, 3 ... rather than expected 0x50, 0x53, 0x56, 0x59.  */\n+  if (!use->iv->no_overflow\n+      && !cand->iv->no_overflow\n+      && !integer_pow2p (cstep))\n+    return NULL_TREE;\n+\n+  int bits = wi::exact_log2 (rat);\n+  if (bits == -1)\n+    bits = wi::floor_log2 (rat) + 1;\n+  if (!cand->iv->no_overflow\n+      && TYPE_PRECISION (utype) + bits > TYPE_PRECISION (ctype))\n+    return NULL_TREE;\n+\n+  var = var_at_stmt (loop, cand, at);\n+\n+  if (POINTER_TYPE_P (ctype))\n+    {\n+      ctype = unsigned_type_for (ctype);\n+      cbase = fold_convert (ctype, cbase);\n+      cstep = fold_convert (ctype, cstep);\n+      var = fold_convert (ctype, var);\n+    }\n+\n+  ubase = unshare_expr (ubase);\n+  cbase = unshare_expr (cbase);\n+  if (stmt_after_increment (loop, cand, at))\n+    var = fold_build2 (MINUS_EXPR, TREE_TYPE (var), var,\n+\t\t       unshare_expr (cstep));\n+\n+  var = fold_build2 (MINUS_EXPR, TREE_TYPE (var), var, cbase);\n+  var = fold_build2 (EXACT_DIV_EXPR, TREE_TYPE (var), var,\n+\t\t     wide_int_to_tree (TREE_TYPE (var), rat));\n+  if (POINTER_TYPE_P (utype))\n+    {\n+      var = fold_convert (sizetype, var);\n+      if (neg_p)\n+\tvar = fold_build1 (NEGATE_EXPR, sizetype, var);\n+      var = fold_build2 (POINTER_PLUS_EXPR, utype, ubase, var);\n+    }\n+  else\n+    {\n+      var = fold_convert (utype, var);\n+      var = fold_build2 (neg_p ? MINUS_EXPR : PLUS_EXPR, utype,\n+\t\t\t ubase, var);\n+    }\n+  return var;\n+}\n+\n /* Adjust the cost COST for being in loop setup rather than loop body.\n    If we're optimizing for space, the loop setup overhead is constant;\n    if we're optimizing for speed, amortize it over the per-iteration cost.\n@@ -7523,6 +7611,7 @@ remove_unused_ivs (struct ivopts_data *data, bitmap toremove)\n \t      struct iv_use dummy_use;\n \t      struct iv_cand *best_cand = NULL, *cand;\n \t      unsigned i, best_pref = 0, cand_pref;\n+\t      tree comp = NULL_TREE;\n \n \t      memset (&dummy_use, 0, sizeof (dummy_use));\n \t      dummy_use.iv = info->iv;\n@@ -7543,20 +7632,22 @@ remove_unused_ivs (struct ivopts_data *data, bitmap toremove)\n \t\t    ? 1 : 0;\n \t\t  if (best_cand == NULL || best_pref < cand_pref)\n \t\t    {\n-\t\t      best_cand = cand;\n-\t\t      best_pref = cand_pref;\n+\t\t      tree this_comp\n+\t\t\t= get_debug_computation_at (data->current_loop,\n+\t\t\t\t\t\t    SSA_NAME_DEF_STMT (def),\n+\t\t\t\t\t\t    &dummy_use, cand);\n+\t\t      if (this_comp)\n+\t\t\t{\n+\t\t\t  best_cand = cand;\n+\t\t\t  best_pref = cand_pref;\n+\t\t\t  comp = this_comp;\n+\t\t\t}\n \t\t    }\n \t\t}\n \n \t      if (!best_cand)\n \t\tcontinue;\n \n-\t      tree comp = get_computation_at (data->current_loop,\n-\t\t\t\t\t      SSA_NAME_DEF_STMT (def),\n-\t\t\t\t\t      &dummy_use, best_cand);\n-\t      if (!comp)\n-\t\tcontinue;\n-\n \t      if (count > 1)\n \t\t{\n \t\t  tree vexpr = make_node (DEBUG_EXPR_DECL);"}]}