{"sha": "f19a6894ecc2474e0de87db8b3be2fea85446a22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE5YTY4OTRlY2MyNDc0ZTBkZTg3ZGI4YjNiZTJmZWE4NTQ0NmEyMg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1997-06-20T01:17:50Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1997-06-20T01:17:50Z"}, "message": "(output_line_info): Always use DW_LNE_set_address instead of DW_LNS_fixed_advance_pc for line number addresses.\n\n(output_line_info): Always use DW_LNE_set_address instead\nof DW_LNS_fixed_advance_pc for line number addresses.\n(size_of_line_info): Adjust size calculation as per above change.\n\nFrom-SVN: r14262", "tree": {"sha": "c3327989f5319b7b5d4f935db89263389d33dc53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3327989f5319b7b5d4f935db89263389d33dc53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f19a6894ecc2474e0de87db8b3be2fea85446a22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f19a6894ecc2474e0de87db8b3be2fea85446a22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f19a6894ecc2474e0de87db8b3be2fea85446a22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f19a6894ecc2474e0de87db8b3be2fea85446a22/comments", "author": null, "committer": null, "parents": [{"sha": "809d135d888e9942a734f9ae2a6b5c3c4857f728", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/809d135d888e9942a734f9ae2a6b5c3c4857f728", "html_url": "https://github.com/Rust-GCC/gccrs/commit/809d135d888e9942a734f9ae2a6b5c3c4857f728"}], "stats": {"total": 203, "additions": 164, "deletions": 39}, "files": [{"sha": "4af09baef00b02f36c8954dd4ada451755015e0d", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 164, "deletions": 39, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19a6894ecc2474e0de87db8b3be2fea85446a22/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19a6894ecc2474e0de87db8b3be2fea85446a22/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=f19a6894ecc2474e0de87db8b3be2fea85446a22", "patch": "@@ -4280,6 +4280,10 @@ size_of_line_info ()\n   register long line_delta;\n   register unsigned long current_file;\n   register unsigned long function;\n+  unsigned long size_of_set_address;\n+\n+  /* Size of a DW_LNE_set_address instruction.  */\n+  size_of_set_address = 1 + size_of_uleb128 (1 + PTR_SIZE) + 1 + PTR_SIZE;\n \n   /* Version number.  */\n   size = 2;\n@@ -4291,7 +4295,7 @@ size_of_line_info ()\n   size += size_of_line_prolog ();\n \n   /* Set address register instruction.  */\n-  size += 1 + size_of_uleb128 (1 + PTR_SIZE) + 1 + PTR_SIZE;\n+  size += size_of_set_address;\n \n   current_file = 1;\n   current_line = 1;\n@@ -4300,7 +4304,12 @@ size_of_line_info ()\n       register dw_line_info_ref line_info;\n \n       /* Advance pc instruction.  */\n-      size += 1 + 2;\n+      /* ??? See the DW_LNS_advance_pc comment in output_line_info.  */\n+      if (0)\n+\tsize += 1 + 2;\n+      else\n+\tsize += size_of_set_address;\n+\n       line_info = &line_info_table[lt_index];\n       if (line_info->dw_file_num != current_file)\n \t{\n@@ -4330,7 +4339,10 @@ size_of_line_info ()\n     }\n \n   /* Advance pc instruction.  */\n-  size += 1 + 2;\n+  if (0)\n+    size += 1 + 2;\n+  else\n+    size += size_of_set_address;\n \n   /* End of line number info. marker.  */\n   size += 1 + size_of_uleb128 (1) + 1;\n@@ -4346,11 +4358,16 @@ size_of_line_info ()\n \t{\n \t  function = line_info->function;\n \t  /* Set address register instruction.  */\n-\t  size += 1 + size_of_uleb128 (1 + PTR_SIZE) + 1 + PTR_SIZE;\n+\t  size += size_of_set_address;\n \t}\n       else\n-\t/* Advance pc instruction.  */\n-\tsize += 1 + 2;\n+\t{\n+\t  /* Advance pc instruction.  */\n+\t  if (0)\n+\t    size += 1 + 2;\n+\t  else\n+\t    size += size_of_set_address;\n+\t}\n \n       if (line_info->dw_file_num != current_file)\n \t{\n@@ -4389,7 +4406,10 @@ size_of_line_info ()\n \t  current_line = 1;\n \n \t  /* Advance pc instruction.  */\n-\t  size += 1 + 2;\n+\t  if (0)\n+\t    size += 1 + 2;\n+\t  else\n+\t    size += size_of_set_address;\n \n \t  /* End of line number info. marker.  */\n \t  size += 1 + size_of_uleb128 (1) + 1;\n@@ -5135,7 +5155,10 @@ output_aranges ()\n }\n \n /* Output the source line number correspondence information.  This\n-   information goes into the .debug_line section.  */\n+   information goes into the .debug_line section.\n+\n+   If the format of this data changes, then the function size_of_line_info\n+   must also be adjusted the same way.  */\n \n static void\n output_line_info ()\n@@ -5276,15 +5299,48 @@ output_line_info ()\n     {\n       register dw_line_info_ref line_info;\n \n-      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_fixed_advance_pc);\n-      if (flag_verbose_asm)\n-\tfprintf (asm_out_file, \"\\t%s DW_LNS_fixed_advance_pc\",\n-\t\t ASM_COMMENT_START);\n-\n-      fputc ('\\n', asm_out_file);\n+      /* Emit debug info for the address of the current line, choosing\n+\t the encoding that uses the least amount of space.  */\n+      /* ??? Unfortunately, we have little choice here currently, and must\n+\t always use the most general form.  Gcc does not know the address\n+\t delta itself, so we can't use DW_LNS_advance_pc.  There are no known\n+\t dwarf2 aware assemblers at this time, so we can't use any special\n+\t pseudo ops that would allow the assembler to optimally encode this for\n+\t us.  Many ports do have length attributes which will give an upper\n+\t bound on the address range.  We could perhaps use length attributes\n+\t to determine when it is safe to use DW_LNS_fixed_advance_pc.  */\n       ASM_GENERATE_INTERNAL_LABEL (line_label, LINE_CODE_LABEL, lt_index);\n-      ASM_OUTPUT_DWARF_DELTA2 (asm_out_file, line_label, prev_line_label);\n-      fputc ('\\n', asm_out_file);\n+      if (0)\n+\t{\n+\t  /* This can handle deltas up to 0xffff.  This takes 3 bytes.  */\n+\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_fixed_advance_pc);\n+\t  if (flag_verbose_asm)\n+\t    fprintf (asm_out_file, \"\\t%s DW_LNS_fixed_advance_pc\",\n+\t\t     ASM_COMMENT_START);\n+\n+\t  fputc ('\\n', asm_out_file);\n+\t  ASM_OUTPUT_DWARF_DELTA2 (asm_out_file, line_label, prev_line_label);\n+\t  fputc ('\\n', asm_out_file);\n+\t}\n+      else\n+\t{\n+\t  /* This can handle any delta.  This takes 4+PTR_SIZE bytes.  */\n+\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n+\t  if (flag_verbose_asm)\n+\t    fprintf (asm_out_file, \"\\t%s DW_LNE_set_address\",\n+\t\t     ASM_COMMENT_START);\n+\t  fputc ('\\n', asm_out_file);\n+\t  output_uleb128 (1 + PTR_SIZE);\n+\t  fputc ('\\n', asm_out_file);\n+\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNE_set_address);\n+\t  fputc ('\\n', asm_out_file);\n+\t  ASM_OUTPUT_DWARF_ADDR (asm_out_file, line_label);\n+\t  fputc ('\\n', asm_out_file);\n+\t}\n+      strcpy (prev_line_label, line_label);\n+\n+      /* Emit debug info for the source file of the current line, if\n+\t different from the previous line.  */\n       line_info = &line_info_table[lt_index];\n       if (line_info->dw_file_num != current_file)\n \t{\n@@ -5301,11 +5357,16 @@ output_line_info ()\n \t  fputc ('\\n', asm_out_file);\n \t}\n \n+      /* Emit debug info for the current line number, choosing the encoding\n+\t that uses the least amount of space.  */\n       line_offset = line_info->dw_line_num - current_line;\n       line_delta = line_offset - DWARF_LINE_BASE;\n       current_line = line_info->dw_line_num;\n       if (line_delta >= 0 && line_delta < (DWARF_LINE_RANGE - 1))\n \t{\n+\t  /* This can handle deltas from -10 to 234, using the current\n+\t     definitions of DWARF_LINE_BASE and DWARF_LINE_RANGE.  This\n+\t     takes 1 byte.  */\n \t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file,\n \t\t\t\t  DWARF_LINE_OPCODE_BASE + line_delta);\n \t  if (flag_verbose_asm)\n@@ -5316,6 +5377,8 @@ output_line_info ()\n \t}\n       else\n \t{\n+\t  /* This can handle any delta.  This takes at least 4 bytes, depending\n+\t     on the value being encoded.  */\n \t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_advance_line);\n \t  if (flag_verbose_asm)\n \t    fprintf (asm_out_file, \"\\t%s advance to line %d\",\n@@ -5327,17 +5390,33 @@ output_line_info ()\n \t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_copy);\n \t  fputc ('\\n', asm_out_file);\n \t}\n-\n-      strcpy (prev_line_label, line_label);\n     }\n \n-  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_fixed_advance_pc);\n-  if (flag_verbose_asm)\n-    fprintf (asm_out_file, \"\\t%s DW_LNS_fixed_advance_pc\", ASM_COMMENT_START);\n+  /* Emit debug info for the address of the end of the function.  */\n+  if (0)\n+    {\n+      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_fixed_advance_pc);\n+      if (flag_verbose_asm)\n+\tfprintf (asm_out_file, \"\\t%s DW_LNS_fixed_advance_pc\",\n+\t\t ASM_COMMENT_START);\n \n-  fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_DELTA2 (asm_out_file, text_end_label, prev_line_label);\n-  fputc ('\\n', asm_out_file);\n+      fputc ('\\n', asm_out_file);\n+      ASM_OUTPUT_DWARF_DELTA2 (asm_out_file, text_end_label, prev_line_label);\n+      fputc ('\\n', asm_out_file);\n+    }\n+  else\n+    {\n+      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n+      if (flag_verbose_asm)\n+\tfprintf (asm_out_file, \"\\t%s DW_LNE_set_address\", ASM_COMMENT_START);\n+      fputc ('\\n', asm_out_file);\n+      output_uleb128 (1 + PTR_SIZE);\n+      fputc ('\\n', asm_out_file);\n+      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNE_set_address);\n+      fputc ('\\n', asm_out_file);\n+      ASM_OUTPUT_DWARF_ADDR (asm_out_file, text_end_label);\n+      fputc ('\\n', asm_out_file);\n+    }\n \n   /* Output the marker for the end of the line number info.  */\n   ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n@@ -5358,6 +5437,9 @@ output_line_info ()\n       register dw_separate_line_info_ref line_info\n \t= &separate_line_info_table[lt_index];\n \n+      /* Emit debug info for the address of the current line.  If this is\n+\t a new function, or the first line of a function, then we need\n+\t to handle it differently.  */\n       ASM_GENERATE_INTERNAL_LABEL (line_label, SEPARATE_LINE_CODE_LABEL,\n \t\t\t\t   lt_index);\n       if (function != line_info->function)\n@@ -5380,16 +5462,38 @@ output_line_info ()\n \t}\n       else\n \t{\n-\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_fixed_advance_pc);\n-\t  if (flag_verbose_asm)\n-\t    fprintf (asm_out_file, \"\\t%s DW_LNS_fixed_advance_pc\",\n-\t\t     ASM_COMMENT_START);\n+\t  /* ??? See the DW_LNS_advance_pc comment above.  */\n+\t  if (0)\n+\t    {\n+\t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_fixed_advance_pc);\n+\t      if (flag_verbose_asm)\n+\t\tfprintf (asm_out_file, \"\\t%s DW_LNS_fixed_advance_pc\",\n+\t\t\t ASM_COMMENT_START);\n \n-\t  fputc ('\\n', asm_out_file);\n-\t  ASM_OUTPUT_DWARF_DELTA2 (asm_out_file, line_label, prev_line_label);\n-\t  fputc ('\\n', asm_out_file);\n+\t      fputc ('\\n', asm_out_file);\n+\t      ASM_OUTPUT_DWARF_DELTA2 (asm_out_file, line_label,\n+\t\t\t\t       prev_line_label);\n+\t      fputc ('\\n', asm_out_file);\n+\t    }\n+\t  else\n+\t    {\n+\t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n+\t      if (flag_verbose_asm)\n+\t\tfprintf (asm_out_file, \"\\t%s DW_LNE_set_address\",\n+\t\t\t ASM_COMMENT_START);\n+\t      fputc ('\\n', asm_out_file);\n+\t      output_uleb128 (1 + PTR_SIZE);\n+\t      fputc ('\\n', asm_out_file);\n+\t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNE_set_address);\n+\t      fputc ('\\n', asm_out_file);\n+\t      ASM_OUTPUT_DWARF_ADDR (asm_out_file, line_label);\n+\t      fputc ('\\n', asm_out_file);\n+\t    }\n \t}\n+      strcpy (prev_line_label, line_label);\n \n+      /* Emit debug info for the source file of the current line, if\n+\t different from the previous line.  */\n       if (line_info->dw_file_num != current_file)\n \t{\n \t  current_file = line_info->dw_file_num;\n@@ -5405,6 +5509,8 @@ output_line_info ()\n \t  fputc ('\\n', asm_out_file);\n \t}\n \n+      /* Emit debug info for the current line number, choosing the encoding\n+\t that uses the least amount of space.  */\n       if (line_info->dw_line_num != current_line)\n \t{\n \t  line_offset = line_info->dw_line_num - current_line;\n@@ -5436,23 +5542,42 @@ output_line_info ()\n \t}\n \n       ++lt_index;\n-      strcpy (prev_line_label, line_label);\n \n       /* If we're done with a function, end its sequence.  */\n       if (lt_index == separate_line_info_table_in_use\n \t  || separate_line_info_table[lt_index].function != function)\n \t{\n \t  current_file = 1;\n \t  current_line = 1;\n-\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_fixed_advance_pc);\n-\t  if (flag_verbose_asm)\n-\t    fprintf (asm_out_file, \"\\t%s DW_LNS_fixed_advance_pc\",\n-\t\t     ASM_COMMENT_START);\n \n-\t  fputc ('\\n', asm_out_file);\n+\t  /* Emit debug info for the address of the end of the function.  */\n \t  ASM_GENERATE_INTERNAL_LABEL (line_label, FUNC_END_LABEL, function);\n-\t  ASM_OUTPUT_DWARF_DELTA2 (asm_out_file, line_label, prev_line_label);\n-\t  fputc ('\\n', asm_out_file);\n+\t  if (0)\n+\t    {\n+\t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_fixed_advance_pc);\n+\t      if (flag_verbose_asm)\n+\t\tfprintf (asm_out_file, \"\\t%s DW_LNS_fixed_advance_pc\",\n+\t\t\t ASM_COMMENT_START);\n+\n+\t      fputc ('\\n', asm_out_file);\n+\t      ASM_OUTPUT_DWARF_DELTA2 (asm_out_file, line_label,\n+\t\t\t\t       prev_line_label);\n+\t      fputc ('\\n', asm_out_file);\n+\t    }\n+\t  else\n+\t    {\n+\t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n+\t      if (flag_verbose_asm)\n+\t\tfprintf (asm_out_file, \"\\t%s DW_LNE_set_address\",\n+\t\t\t ASM_COMMENT_START);\n+\t      fputc ('\\n', asm_out_file);\n+\t      output_uleb128 (1 + PTR_SIZE);\n+\t      fputc ('\\n', asm_out_file);\n+\t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNE_set_address);\n+\t      fputc ('\\n', asm_out_file);\n+\t      ASM_OUTPUT_DWARF_ADDR (asm_out_file, line_label);\n+\t      fputc ('\\n', asm_out_file);\n+\t    }\n \n \t  /* Output the marker for the end of this sequence.  */\n \t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);"}]}