{"sha": "d74792629d41383f6ff4543aeed9bc6080d77809", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc0NzkyNjI5ZDQxMzgzZjZmZjQ1NDNhZWVkOWJjNjA4MGQ3NzgwOQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2015-11-24T20:15:44Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2015-11-24T20:15:44Z"}, "message": "nvptx.c (maybe_split_mode): Return new mode or VOIDmode, don't alter incoming mode.\n\n\t* config/nvptx/nvptx.c (maybe_split_mode): Return new mode or\n\tVOIDmode, don't alter incoming mode.\n\t(nvptx_split_reg_p): Delete.\n\t(write_one_arg, walk_args_for_param, nvptx_declare_function_name,\n\twrite_func_decl_from_insn, nvptx_output_call_insn): Adjust\n\tmaybe_split_mode calls.\n\t(nvptx_print_operand): Use maybe_split_mode.\n\nFrom-SVN: r230836", "tree": {"sha": "78f53a2336813b3a97e6ecfd080e01be647df756", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78f53a2336813b3a97e6ecfd080e01be647df756"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d74792629d41383f6ff4543aeed9bc6080d77809", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d74792629d41383f6ff4543aeed9bc6080d77809", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d74792629d41383f6ff4543aeed9bc6080d77809", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d74792629d41383f6ff4543aeed9bc6080d77809/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "aea50b45f5db36d77d4cf8488dd98d8a06c073a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aea50b45f5db36d77d4cf8488dd98d8a06c073a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aea50b45f5db36d77d4cf8488dd98d8a06c073a8"}], "stats": {"total": 148, "additions": 72, "deletions": 76}, "files": [{"sha": "38f71164f555fb343a2d618a1ae40b6879d504bd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74792629d41383f6ff4543aeed9bc6080d77809/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74792629d41383f6ff4543aeed9bc6080d77809/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d74792629d41383f6ff4543aeed9bc6080d77809", "patch": "@@ -1,3 +1,13 @@\n+2015-11-24  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* config/nvptx/nvptx.c (maybe_split_mode): Return new mode or\n+\tVOIDmode, don't alter incoming mode.\n+\t(nvptx_split_reg_p): Delete.\n+\t(write_one_arg, walk_args_for_param, nvptx_declare_function_name,\n+\twrite_func_decl_from_insn, nvptx_output_call_insn): Adjust\n+\tmaybe_split_mode calls.\n+\t(nvptx_print_operand): Use maybe_split_mode.\n+\n 2015-11-24  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* lto-streamer-in.c (lto_read_body_or_constructor): Set TYPE_CANONICAL"}, {"sha": "a8393bb38dedbce68f76ba72adcac2d7356a703a", "filename": "gcc/config/nvptx/nvptx.c", "status": "modified", "additions": 62, "deletions": 76, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74792629d41383f6ff4543aeed9bc6080d77809/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74792629d41383f6ff4543aeed9bc6080d77809/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=d74792629d41383f6ff4543aeed9bc6080d77809", "patch": "@@ -206,37 +206,19 @@ nvptx_ptx_type_from_mode (machine_mode mode, bool promote)\n     }\n }\n \n-/* Return the number of pieces to use when dealing with a pseudo of *PMODE.\n-   Alter *PMODE if we return a number greater than one.  */\n+/* If MODE should be treated as two registers of an inner mode, return\n+   that inner mode.  Otherwise return VOIDmode.  */\n \n-static int\n-maybe_split_mode (machine_mode *pmode)\n+static machine_mode\n+maybe_split_mode (machine_mode mode)\n {\n-  machine_mode mode = *pmode;\n-\n   if (COMPLEX_MODE_P (mode))\n-    {\n-      *pmode = GET_MODE_INNER (mode);\n-      return 2;\n-    }\n-  else if (mode == TImode)\n-    {\n-      *pmode = DImode;\n-      return 2;\n-    }\n-  return 1;\n-}\n+    return GET_MODE_INNER (mode);\n \n-/* Like maybe_split_mode, but only return whether or not the mode\n-   needs to be split.  */\n-static bool\n-nvptx_split_reg_p (machine_mode mode)\n-{\n-  if (COMPLEX_MODE_P (mode))\n-    return true;\n   if (mode == TImode)\n-    return true;\n-  return false;\n+    return DImode;\n+\n+  return VOIDmode;\n }\n \n /* Emit forking instructions for MASK.  */\n@@ -315,12 +297,11 @@ write_one_arg (std::stringstream &s, tree type, int i, machine_mode mode,\n   if (!PASS_IN_REG_P (mode, type))\n     mode = Pmode;\n \n-  int count = maybe_split_mode (&mode);\n-\n-  if (count == 2)\n+  machine_mode split = maybe_split_mode (mode);\n+  if (split != VOIDmode)\n     {\n-      write_one_arg (s, NULL_TREE, i, mode, false);\n-      write_one_arg (s, NULL_TREE, i + 1, mode, false);\n+      write_one_arg (s, NULL_TREE, i, split, false);\n+      write_one_arg (s, NULL_TREE, i + 1, split, false);\n       return i + 1;\n     }\n \n@@ -477,25 +458,25 @@ walk_args_for_param (FILE *file, tree argtypes, tree args, bool write_copy,\n     {\n       tree type = args_from_decl ? TREE_TYPE (args) : TREE_VALUE (args);\n       machine_mode mode = TYPE_MODE (type);\n+      int count = 1;\n \n       if (mode == VOIDmode)\n \tbreak;\n \n       if (!PASS_IN_REG_P (mode, type))\n \tmode = Pmode;\n \n-      int count = maybe_split_mode (&mode);\n-      if (count == 1)\n+      machine_mode split = maybe_split_mode (mode);\n+      if (split != VOIDmode)\n \t{\n-\t  if (argtypes == NULL && !AGGREGATE_TYPE_P (type))\n-\t    {\n-\t      if (mode == SFmode)\n-\t\tmode = DFmode;\n-\n-\t    }\n+\t  count = 2;\n+\t  mode = split;\n \t}\n+      else if (argtypes == NULL && !AGGREGATE_TYPE_P (type) && mode == SFmode)\n+\tmode = DFmode;\n+\n       mode = arg_promotion (mode);\n-      while (count-- > 0)\n+      while (count--)\n \t{\n \t  i++;\n \t  if (write_copy)\n@@ -662,18 +643,17 @@ nvptx_declare_function_name (FILE *file, const char *name, const_tree decl)\n       if (regno_reg_rtx[i] != const0_rtx)\n \t{\n \t  machine_mode mode = PSEUDO_REGNO_MODE (i);\n-\t  int count = maybe_split_mode (&mode);\n-\t  if (count > 1)\n+\t  machine_mode split = maybe_split_mode (mode);\n+\t  if (split != VOIDmode)\n \t    {\n-\t      while (count-- > 0)\n-\t\tfprintf (file, \"\\t.reg%s %%r%d$%d;\\n\",\n-\t\t\t nvptx_ptx_type_from_mode (mode, true),\n-\t\t\t i, count);\n+\t      fprintf (file, \"\\t.reg%s %%r%d$%d;\\n\",\n+\t\t       nvptx_ptx_type_from_mode (split, true), i, 0);\n+\t      fprintf (file, \"\\t.reg%s %%r%d$%d;\\n\",\n+\t\t       nvptx_ptx_type_from_mode (split, true), i, 1);\n \t    }\n \t  else\n \t    fprintf (file, \"\\t.reg%s %%r%d;\\n\",\n-\t\t     nvptx_ptx_type_from_mode (mode, true),\n-\t\t     i);\n+\t\t     nvptx_ptx_type_from_mode (mode, true), i);\n \t}\n     }\n \n@@ -794,7 +774,14 @@ write_func_decl_from_insn (std::stringstream &s, rtx result, rtx pat,\n \t{\n \t  rtx t = XEXP (XVECEXP (pat, 0, i), 0);\n \t  machine_mode mode = GET_MODE (t);\n-\t  int count = maybe_split_mode (&mode);\n+\t  machine_mode split = maybe_split_mode (mode);\n+\t  int count = 1;\n+\n+\t  if (split != VOIDmode)\n+\t    {\n+\t      mode = split;\n+\t      count = 2;\n+\t    }\n \n \t  while (count--)\n \t    {\n@@ -1863,32 +1850,29 @@ nvptx_output_call_insn (rtx_insn *insn, rtx result, rtx callee)\n     {\n       rtx t = XEXP (XVECEXP (pat, 0, i), 0);\n       machine_mode mode = GET_MODE (t);\n-      int count = maybe_split_mode (&mode);\n-\n-      while (count--)\n-\tfprintf (asm_out_file, \"\\t\\t.param%s %%out_arg%d%s;\\n\",\n-\t\t nvptx_ptx_type_from_mode (mode, false), argno++,\n-\t\t mode == QImode || mode == HImode ? \"[1]\" : \"\");\n-    }\n-  for (int i = 1, argno = 0; i < arg_end; i++)\n-    {\n-      rtx t = XEXP (XVECEXP (pat, 0, i), 0);\n-      gcc_assert (REG_P (t));\n-      machine_mode mode = GET_MODE (t);\n-      int count = maybe_split_mode (&mode);\n+      machine_mode split = maybe_split_mode (mode);\n+      int count = 1;\n+      \n+      if (split != VOIDmode)\n+\t{\n+\t  mode = split;\n+\t  count  = 2;\n+\t}\n \n-      if (count == 1)\n-\tfprintf (asm_out_file, \"\\t\\tst.param%s [%%out_arg%d], %%r%d;\\n\",\n-\t\t nvptx_ptx_type_from_mode (mode, false), argno++,\n-\t\t REGNO (t));\n-      else\n+      for (int n = 0; n != count; n++)\n \t{\n-\t  int n = 0;\n-\t  while (count--)\n-\t    fprintf (asm_out_file, \"\\t\\tst.param%s [%%out_arg%d], %%r%d$%d;\\n\",\n-\t\t     nvptx_ptx_type_from_mode (mode, false), argno++,\n-\t\t     REGNO (t), n++);\n+\t  fprintf (asm_out_file, \"\\t\\t.param%s %%out_arg%d%s;\\n\",\n+\t\t   nvptx_ptx_type_from_mode (mode, false), argno,\n+\t\t   mode == QImode || mode == HImode ? \"[1]\" : \"\");\n+\t  fprintf (asm_out_file, \"\\t\\tst.param%s [%%out_arg%d], %%r%d\",\n+\t\t   nvptx_ptx_type_from_mode (mode, false), argno,\n+\t\t   REGNO (t));\n+\t  if (split != VOIDmode)\n+\t    fprintf (asm_out_file, \"$%d\", n);\n+\t  fprintf (asm_out_file, \";\\n\");\n+\t  argno++;\n \t}\n+      \n     }\n \n   fprintf (asm_out_file, \"\\t\\tcall \");\n@@ -1913,13 +1897,15 @@ nvptx_output_call_insn (rtx_insn *insn, rtx result, rtx callee)\n \t{\n \t  rtx t = XEXP (XVECEXP (pat, 0, i), 0);\n \t  machine_mode mode = GET_MODE (t);\n-\t  int count = maybe_split_mode (&mode);\n+\t  machine_mode split = maybe_split_mode (mode);\n \n-\t  while (count--)\n+\t  if (split != VOIDmode)\n \t    {\n \t      fprintf (asm_out_file, \"%s%%out_arg%d\", comma, argno++);\n \t      comma = \", \";\n \t    }\n+\t  fprintf (asm_out_file, \"%s%%out_arg%d\", comma, argno++);\n+\t  comma = \", \";\n \t}\n       if (decl && DECL_STATIC_CHAIN (decl))\n \tfprintf (asm_out_file, \"%s%s\", comma,\n@@ -2155,10 +2141,10 @@ nvptx_print_operand (FILE *file, rtx x, int code)\n \t    fprintf (file, \"%s\", reg_names[REGNO (x)]);\n \t  else\n \t    fprintf (file, \"%%r%d\", REGNO (x));\n-\t  if (code != 'f' && nvptx_split_reg_p (GET_MODE (x)))\n+\t  if (code != 'f' && maybe_split_mode (GET_MODE (x)) != VOIDmode)\n \t    {\n \t      gcc_assert (GET_CODE (orig_x) == SUBREG\n-\t\t\t  && !nvptx_split_reg_p (GET_MODE (orig_x)));\n+\t\t\t  && maybe_split_mode (GET_MODE (orig_x)) == VOIDmode);\n \t      fprintf (file, \"$%d\", SUBREG_BYTE (orig_x) / UNITS_PER_WORD);\n \t    }\n \t  break;"}]}