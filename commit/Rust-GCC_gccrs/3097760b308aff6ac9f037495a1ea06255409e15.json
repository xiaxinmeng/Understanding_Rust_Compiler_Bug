{"sha": "3097760b308aff6ac9f037495a1ea06255409e15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA5Nzc2MGIzMDhhZmY2YWM5ZjAzNzQ5NWExZWEwNjI1NTQwOWUxNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2008-01-13T11:18:08Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2008-01-13T11:18:08Z"}, "message": "re PR middle-end/32135 (bogus array-ref fold triggering array overflow warning)\n\n\tPR middle-end/32135\n\t* tree-ssa-ccp.c (maybe_fold_offset_to_array_ref): Do not construct\n\treferences above array bounds.  This might trigger bounds checks for\n\tpointers to arrays.\n\nFrom-SVN: r131502", "tree": {"sha": "596610cc643347fdf39f40dd6b346e3ca41a7aab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/596610cc643347fdf39f40dd6b346e3ca41a7aab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3097760b308aff6ac9f037495a1ea06255409e15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3097760b308aff6ac9f037495a1ea06255409e15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3097760b308aff6ac9f037495a1ea06255409e15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3097760b308aff6ac9f037495a1ea06255409e15/comments", "author": null, "committer": null, "parents": [{"sha": "42b22da88490c789d74d643de6fe928e3e6ebd83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42b22da88490c789d74d643de6fe928e3e6ebd83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42b22da88490c789d74d643de6fe928e3e6ebd83"}], "stats": {"total": 47, "additions": 45, "deletions": 2}, "files": [{"sha": "6cd0af8b53239495976ca0ac4f982403ede7ab6d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3097760b308aff6ac9f037495a1ea06255409e15/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3097760b308aff6ac9f037495a1ea06255409e15/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3097760b308aff6ac9f037495a1ea06255409e15", "patch": "@@ -1,3 +1,10 @@\n+2008-01-12  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR middle-end/32135\n+\t* tree-ssa-ccp.c (maybe_fold_offset_to_array_ref): Do not construct\n+\treferences above array bounds.  This might trigger bounds checks for\n+\tpointers to arrays.\n+\n 2008-01-12  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* tree-ssa-ter.c (free_temp_expr_table): Free num_in_part and"}, {"sha": "b067970ec88dc3ae2b7dd04ab0a84ac0f81615dd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3097760b308aff6ac9f037495a1ea06255409e15/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3097760b308aff6ac9f037495a1ea06255409e15/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3097760b308aff6ac9f037495a1ea06255409e15", "patch": "@@ -1,3 +1,8 @@\n+2008-01-13  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR middle-end/32135\n+\t* gcc.dg/pr32135.c: new.\n+\n 2008-01-12  Doug Kwan  <dougkwan@google.com>\n \n \t* gcc.dg/qual-return-1.c: Add -Wignored-qualifiers."}, {"sha": "4459656441279699451eaff75273da1e5b3d49d9", "filename": "gcc/testsuite/gcc.dg/pr32135.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3097760b308aff6ac9f037495a1ea06255409e15/gcc%2Ftestsuite%2Fgcc.dg%2Fpr32135.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3097760b308aff6ac9f037495a1ea06255409e15/gcc%2Ftestsuite%2Fgcc.dg%2Fpr32135.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr32135.c?ref=3097760b308aff6ac9f037495a1ea06255409e15", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Warray-bounds -O2\" } */\n+struct PhaseEntryType\n+{\n+  char raw_field[50 + 1];\n+};\n+int\n+ParsePhase (char in_cols[15][250], struct PhaseEntryType *P)\n+{\n+  __builtin_strncpy (P->raw_field, in_cols[2], 50);\n+}"}, {"sha": "f9f1217c5fc0e7113d25888aec44b1f81b099779", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3097760b308aff6ac9f037495a1ea06255409e15/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3097760b308aff6ac9f037495a1ea06255409e15/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=3097760b308aff6ac9f037495a1ea06255409e15", "patch": "@@ -1588,6 +1588,7 @@ maybe_fold_offset_to_array_ref (tree base, tree offset, tree orig_type)\n {\n   tree min_idx, idx, idx_type, elt_offset = integer_zero_node;\n   tree array_type, elt_type, elt_size;\n+  tree domain_type;\n \n   /* If BASE is an ARRAY_REF, we can pick up another offset (this time\n      measured in units of the size of elements type) from that ARRAY_REF).\n@@ -1659,9 +1660,10 @@ maybe_fold_offset_to_array_ref (tree base, tree offset, tree orig_type)\n      low bound, if any, convert the index into that type, and add the\n      low bound.  */\n   min_idx = build_int_cst (idx_type, 0);\n-  if (TYPE_DOMAIN (array_type))\n+  domain_type = TYPE_DOMAIN (array_type);\n+  if (domain_type)\n     {\n-      idx_type = TYPE_DOMAIN (array_type);\n+      idx_type = domain_type;\n       if (TYPE_MIN_VALUE (idx_type))\n \tmin_idx = TYPE_MIN_VALUE (idx_type);\n       else\n@@ -1681,6 +1683,24 @@ maybe_fold_offset_to_array_ref (tree base, tree offset, tree orig_type)\n   /* Make sure to possibly truncate late after offsetting.  */\n   idx = fold_convert (idx_type, idx);\n \n+  /* We don't want to construct access past array bounds. For example\n+     char *(c[4]);\n+\n+     c[3][2]; should not be simplified into (*c)[14] or tree-vrp will give false\n+     warning.  */\n+  if (domain_type && TYPE_MAX_VALUE (domain_type) \n+      && TREE_CODE (TYPE_MAX_VALUE (domain_type)) == INTEGER_CST)\n+    {\n+      tree up_bound = TYPE_MAX_VALUE (domain_type);\n+\n+      if (tree_int_cst_lt (up_bound, idx)\n+\t  /* Accesses after the end of arrays of size 0 (gcc\n+\t     extension) and 1 are likely intentional (\"struct\n+\t     hack\").  */\n+\t  && compare_tree_int (up_bound, 1) > 0)\n+\treturn NULL_TREE;\n+    }\n+\n   return build4 (ARRAY_REF, elt_type, base, idx, NULL_TREE, NULL_TREE);\n }\n "}]}