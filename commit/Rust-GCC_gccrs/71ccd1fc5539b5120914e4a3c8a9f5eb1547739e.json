{"sha": "71ccd1fc5539b5120914e4a3c8a9f5eb1547739e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFjY2QxZmM1NTM5YjUxMjA5MTRlNGEzYzhhOWY1ZWIxNTQ3NzM5ZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-02-02T13:24:57Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-02-02T13:24:57Z"}, "message": "(encode_aggregate_within): New function.\n\n(encode_aggregate): Generates encodings for unions similar to those for\nstructs except surrounded by parenthesis instead of braces.\n\nFrom-SVN: r13583", "tree": {"sha": "6189e04eacd93c346bf27e6460cd86dc125d1d6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6189e04eacd93c346bf27e6460cd86dc125d1d6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71ccd1fc5539b5120914e4a3c8a9f5eb1547739e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71ccd1fc5539b5120914e4a3c8a9f5eb1547739e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71ccd1fc5539b5120914e4a3c8a9f5eb1547739e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71ccd1fc5539b5120914e4a3c8a9f5eb1547739e/comments", "author": null, "committer": null, "parents": [{"sha": "ec0bc8b600ba51ec70343cd23905aae08cd0f39f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec0bc8b600ba51ec70343cd23905aae08cd0f39f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec0bc8b600ba51ec70343cd23905aae08cd0f39f"}], "stats": {"total": 228, "additions": 108, "deletions": 120}, "files": [{"sha": "7eefa02afcaaabdb164fd2b6590938f1ece94e3b", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 108, "deletions": 120, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71ccd1fc5539b5120914e4a3c8a9f5eb1547739e/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71ccd1fc5539b5120914e4a3c8a9f5eb1547739e/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=71ccd1fc5539b5120914e4a3c8a9f5eb1547739e", "patch": "@@ -1,5 +1,5 @@\n /* Implement classes and message passing for Objective C.\n-   Copyright (C) 1992, 1993, 1994, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 1993, 1994, 1995, 1997 Free Software Foundation, Inc.\n    Contributed by Steve Naroff.\n \n This file is part of GNU CC.\n@@ -6453,151 +6453,139 @@ encode_array (type, curtype, format)\n }\n \f\n static void\n-encode_aggregate (type, curtype, format)\n+encode_aggregate_within (type, curtype, format, left, right)\n      tree type;\n      int curtype;\n      int format;\n+     char left;\n+     char right;\n {\n-  enum tree_code code = TREE_CODE (type);\n-\n-  switch (code)\n+  if (obstack_object_size (&util_obstack) > 0\n+      && *(obstack_next_free (&util_obstack) - 1) == '^')\n     {\n-    case RECORD_TYPE:\n-      {\n-\tif (obstack_object_size (&util_obstack) > 0\n-\t    && *(obstack_next_free (&util_obstack) - 1) == '^')\n-\t  {\n-\t    tree name = TYPE_NAME (type);\n+      tree name = TYPE_NAME (type);\n \n-\t    /* We have a reference; this is a NeXT extension.  */\n+      /* we have a reference; this is a NeXT extension. */\n \n-\t    if (obstack_object_size (&util_obstack) - curtype == 1\n-\t\t&& format == OBJC_ENCODE_INLINE_DEFS)\n-\t      {\n-\t\t/* Output format of struct for first level only.  */\n-\t\ttree fields = TYPE_FIELDS (type);\n+      if (obstack_object_size (&util_obstack) - curtype == 1\n+\t  && format == OBJC_ENCODE_INLINE_DEFS)\n+\t{\n+\t  /* Output format of struct for first level only. */\n+\t  tree fields = TYPE_FIELDS (type);\n \n-\t\tif (name && TREE_CODE (name) == IDENTIFIER_NODE)\n-\t\t  {\n-\t\t    obstack_1grow (&util_obstack, '{');\n-\t\t    obstack_grow (&util_obstack,\n-\t\t\t\t  IDENTIFIER_POINTER (name),\n-\t\t\t\t  strlen (IDENTIFIER_POINTER (name)));\n-\t\t    obstack_1grow (&util_obstack, '=');\n-\t\t  }\n+\t  if (name && TREE_CODE (name) == IDENTIFIER_NODE)\n+\t    {\n+\t      obstack_1grow (&util_obstack, left);\n+\t      obstack_grow (&util_obstack,\n+\t\t\t    IDENTIFIER_POINTER (name),\n+\t\t\t    strlen (IDENTIFIER_POINTER (name)));\n+\t      obstack_1grow (&util_obstack, '=');\n+\t    }\n+\t  else\n+\t    {\n+\t      obstack_1grow (&util_obstack, left);\n+\t      obstack_grow (&util_obstack, \"?=\", 2);\n+\t    }\n \n-\t\telse\n-\t\t  obstack_grow (&util_obstack, \"{?=\", 3);\n+\t  for ( ; fields; fields = TREE_CHAIN (fields))\n+\t      encode_field_decl (fields, curtype, format);\n \n-\t\tfor ( ; fields; fields = TREE_CHAIN (fields))\n-\t\t  encode_field_decl (fields, curtype, format);\n+\t  obstack_1grow (&util_obstack, right);\n+\t}\n \n-\t\tobstack_1grow (&util_obstack, '}');\n-\t      }\n+      else if (name && TREE_CODE (name) == IDENTIFIER_NODE)\n+\t{\n+\t  obstack_1grow (&util_obstack, left);\n+\t  obstack_grow (&util_obstack,\n+\t\t\tIDENTIFIER_POINTER (name),\n+\t\t\tstrlen (IDENTIFIER_POINTER (name)));\n+\t  obstack_1grow (&util_obstack, right);\n+\t}\n \n-            else if (name && TREE_CODE (name) == IDENTIFIER_NODE)\n-\t      {\n-\t\tobstack_1grow (&util_obstack, '{');\n-\t\tobstack_grow (&util_obstack,\n-\t\t\t      IDENTIFIER_POINTER (name),\n-\t\t\t      strlen (IDENTIFIER_POINTER (name)));\n-\t\tobstack_1grow (&util_obstack, '}');\n-\t      }\n+      else\n+\t{\n+\t  /* We have an untagged structure or a typedef. */\n+\t  obstack_1grow (&util_obstack, left);\n+\t  obstack_1grow (&util_obstack, '?');\n+\t  obstack_1grow (&util_obstack, right);\n+\t}\n+    }\n \n-\t    else\n-\t      /* We have an untagged structure or a typedef.  */\n-\t      obstack_grow (&util_obstack, \"{?}\", 3);\n-\t  }\n+  else\n+    {\n+      tree name = TYPE_NAME (type);\n+      tree fields = TYPE_FIELDS (type);\n \n-\telse\n-\t  {\n-\t    tree name = TYPE_NAME (type);\n-\t    tree fields = TYPE_FIELDS (type);\n+      if (format == OBJC_ENCODE_INLINE_DEFS\n+\t  || generating_instance_variables)\n+\t{\n+\t  obstack_1grow (&util_obstack, left);\n+\t  if (name && TREE_CODE (name) == IDENTIFIER_NODE)\n+\t      obstack_grow (&util_obstack,\n+\t\t\t  IDENTIFIER_POINTER (name),\n+\t\t\t  strlen (IDENTIFIER_POINTER (name)));\n+\t  else\n+\t      obstack_1grow (&util_obstack, '?');\n \n-\t    if (format == OBJC_ENCODE_INLINE_DEFS\n-\t\t|| generating_instance_variables)\n-\t      {\n-\t\tobstack_1grow (&util_obstack, '{');\n-\t\tif (name && TREE_CODE (name) == IDENTIFIER_NODE)\n-\t\t  obstack_grow (&util_obstack,\n-\t\t\t\tIDENTIFIER_POINTER (name),\n-\t\t\t\tstrlen (IDENTIFIER_POINTER (name)));\n+\t  obstack_1grow (&util_obstack, '=');\n \n-\t\telse\n-\t\t  obstack_1grow (&util_obstack, '?');\n+\t  for (; fields; fields = TREE_CHAIN (fields))\n+\t    {\n+\t      if (generating_instance_variables)\n+\t\t{\n+\t\t  tree fname = DECL_NAME (fields);\n \n-\t\tobstack_1grow (&util_obstack, '=');\n+\t\t  obstack_1grow (&util_obstack, '\"');\n+\t\t  if (fname && TREE_CODE (fname) == IDENTIFIER_NODE)\n+\t\t    {\n+\t\t      obstack_grow (&util_obstack,\n+\t\t\t\t    IDENTIFIER_POINTER (fname),\n+\t\t\t\t    strlen (IDENTIFIER_POINTER (fname)));\n+\t\t    }\n \n-\t\tfor (; fields; fields = TREE_CHAIN (fields))\n-\t\t  {\n-                  if (generating_instance_variables)\n-                    {\n-                      tree fname = DECL_NAME (fields);\n-\n-\t\t      obstack_1grow (&util_obstack, '\"');\n-\t\t      if (fname && TREE_CODE (fname) == IDENTIFIER_NODE)\n-\t\t        {\n-\t\t\t  obstack_grow (&util_obstack,\n-\t\t\t\t\tIDENTIFIER_POINTER (fname),\n-\t\t\t\t\tstrlen (IDENTIFIER_POINTER (fname)));\n-\t\t\t}\n+\t\t  obstack_1grow (&util_obstack, '\"');\n+\t\t}\n \n-\t\t      obstack_1grow (&util_obstack, '\"');\n-                    }\n+\t      encode_field_decl (fields, curtype, format);\n+\t    }\n \n-\t\t  encode_field_decl (fields, curtype, format);\n-\t\t  }\n+\t  obstack_1grow (&util_obstack, right);\n+\t}\n \n-\t\tobstack_1grow (&util_obstack, '}');\n-\t      }\n+      else\n+\t{\n+\t  obstack_1grow (&util_obstack, left);\n+\t  if (name && TREE_CODE (name) == IDENTIFIER_NODE)\n+\t      obstack_grow (&util_obstack,\n+\t\t\t    IDENTIFIER_POINTER (name),\n+\t\t\t    strlen (IDENTIFIER_POINTER (name)));\n+\t  else\n+\t      /* We have an untagged structure or a typedef. */\n+\t      obstack_1grow (&util_obstack, '?');\n \n-\t    else\n-\t      {\n-\t\tobstack_1grow (&util_obstack, '{');\n-\t\tif (name && TREE_CODE (name) == IDENTIFIER_NODE)\n-\t\t  obstack_grow (&util_obstack,\n-\t\t\t\tIDENTIFIER_POINTER (name),\n-\t\t\t\tstrlen (IDENTIFIER_POINTER (name)));\n-\t\telse\n-\t\t  /* We have an untagged structure or a typedef.  */\n-\t\t  obstack_1grow (&util_obstack, '?');\n-\n-\t\tobstack_1grow (&util_obstack, '}');\n-\t      }\n-\t  }\n+\t  obstack_1grow (&util_obstack, right);\n+\t}\n+    }\n+}\n+\n+static void\n+encode_aggregate (type, curtype, format)\n+     tree type;\n+     int curtype;\n+     int format;\n+{\n+  enum tree_code code = TREE_CODE (type);\n+\n+  switch (code)\n+    {\n+    case RECORD_TYPE:\n+      {\n+\tencode_aggregate_within(type, curtype, format, '{', '}');\n \tbreak;\n       }\n-\n     case UNION_TYPE:\n       {\n-\tif (*obstack_next_free (&util_obstack) == '^'\n-\t    || format != OBJC_ENCODE_INLINE_DEFS)\n-\t  {\n-\t    /* We have a reference (this is a NeXT extension)\n-\t       or we don't want the details.  */\n-            if (TYPE_NAME (type)\n-\t\t&& TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE)\n-\t      {\n-\t\tobstack_1grow (&util_obstack, '(');\n-\t\tobstack_grow (&util_obstack,\n-\t\t\t      IDENTIFIER_POINTER (TYPE_NAME (type)),\n-\t\t\t      strlen (IDENTIFIER_POINTER (TYPE_NAME (type))));\n-\t\tobstack_1grow (&util_obstack, ')');\n-\t      }\n-\n-\t    else\n-\t      /* We have an untagged structure or a typedef.  */\n-\t      obstack_grow (&util_obstack, \"(?)\", 3);\n-\t  }\n-\telse\n-\t  {\n-\t    tree fields = TYPE_FIELDS (type);\n-\t    obstack_1grow (&util_obstack, '(');\n-\t    for ( ; fields; fields = TREE_CHAIN (fields))\n-\t      encode_field_decl (fields, curtype, format);\n-\n-\t    obstack_1grow (&util_obstack, ')');\n-\t  }\n+\tencode_aggregate_within(type, curtype, format, '(', ')');\n \tbreak;\n       }\n "}]}