{"sha": "1ad3d8aa05a6668ddfa70fe5118626413d5087ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWFkM2Q4YWEwNWE2NjY4ZGRmYTcwZmU1MTE4NjI2NDEzZDUwODdiYQ==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-11-15T16:16:49Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-11-15T16:16:49Z"}, "message": "re PR tree-optimization/82726 (ICE in verify_ssa during GIMPLE pass: pcom)\n\n\tPR tree-optimization/82726\n\tRevert\n\t2017-01-23  Bin Cheng  <bin.cheng@arm.com>\n\n\tPR tree-optimization/70754\n\t* tree-predcom.c (stmt_combining_refs): New parameter INSERT_BEFORE.\n\t(reassociate_to_the_same_stmt): New parameter INSERT_BEFORE.  Insert\n\tcombined stmt before it if not NULL.\n\t(combine_chains): Process refs reversely and compute dominance point\n\tfor root ref.\n\n\tRevert\n\t2017-02-23  Bin Cheng  <bin.cheng@arm.com>\n\n\tPR tree-optimization/79663\n\t* tree-predcom.c (combine_chains): Process refs in reverse order\n\tonly for ZERO length chains, and add explaining comment.\n\nFrom-SVN: r254777", "tree": {"sha": "a9808ca5cd5b47ade2392e27afa99a69d1f0ecb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9808ca5cd5b47ade2392e27afa99a69d1f0ecb7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ad3d8aa05a6668ddfa70fe5118626413d5087ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ad3d8aa05a6668ddfa70fe5118626413d5087ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ad3d8aa05a6668ddfa70fe5118626413d5087ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ad3d8aa05a6668ddfa70fe5118626413d5087ba/comments", "author": null, "committer": null, "parents": [{"sha": "1ad9b03f1b21cd3c661495e6cd7f591c507d1e7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ad9b03f1b21cd3c661495e6cd7f591c507d1e7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ad9b03f1b21cd3c661495e6cd7f591c507d1e7c"}], "stats": {"total": 84, "additions": 33, "deletions": 51}, "files": [{"sha": "001614046daeba758e4f5da4965b325644c9732d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ad3d8aa05a6668ddfa70fe5118626413d5087ba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ad3d8aa05a6668ddfa70fe5118626413d5087ba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ad3d8aa05a6668ddfa70fe5118626413d5087ba", "patch": "@@ -1,3 +1,23 @@\n+2017-11-15  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/82726\n+\tRevert\n+\t2017-01-23  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/70754\n+\t* tree-predcom.c (stmt_combining_refs): New parameter INSERT_BEFORE.\n+\t(reassociate_to_the_same_stmt): New parameter INSERT_BEFORE.  Insert\n+\tcombined stmt before it if not NULL.\n+\t(combine_chains): Process refs reversely and compute dominance point\n+\tfor root ref.\n+\n+\tRevert\n+\t2017-02-23  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/79663\n+\t* tree-predcom.c (combine_chains): Process refs in reverse order\n+\tonly for ZERO length chains, and add explaining comment.\n+\n 2017-11-15  Tamar Christina  <tamar.christina@arm.com>\n \n \t* config/arm/arm-cpus.in (armv8_3, ARMv8_3a, armv8.3-a): New"}, {"sha": "6dccbc17bf5e05c47dbd7083e5956673a97c6f08", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 13, "deletions": 51, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ad3d8aa05a6668ddfa70fe5118626413d5087ba/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ad3d8aa05a6668ddfa70fe5118626413d5087ba/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=1ad3d8aa05a6668ddfa70fe5118626413d5087ba", "patch": "@@ -2527,11 +2527,10 @@ remove_name_from_operation (gimple *stmt, tree op)\n }\n \n /* Reassociates the expression in that NAME1 and NAME2 are used so that they\n-   are combined in a single statement, and returns this statement.  Note the\n-   statement is inserted before INSERT_BEFORE if it's not NULL.  */\n+   are combined in a single statement, and returns this statement.  */\n \n static gimple *\n-reassociate_to_the_same_stmt (tree name1, tree name2, gimple *insert_before)\n+reassociate_to_the_same_stmt (tree name1, tree name2)\n {\n   gimple *stmt1, *stmt2, *root1, *root2, *s1, *s2;\n   gassign *new_stmt, *tmp_stmt;\n@@ -2588,12 +2587,6 @@ reassociate_to_the_same_stmt (tree name1, tree name2, gimple *insert_before)\n   var = create_tmp_reg (type, \"predreastmp\");\n   new_name = make_ssa_name (var);\n   new_stmt = gimple_build_assign (new_name, code, name1, name2);\n-  if (insert_before && stmt_dominates_stmt_p (insert_before, s1))\n-    bsi = gsi_for_stmt (insert_before);\n-  else\n-    bsi = gsi_for_stmt (s1);\n-\n-  gsi_insert_before (&bsi, new_stmt, GSI_SAME_STMT);\n \n   var = create_tmp_reg (type, \"predreastmp\");\n   tmp_name = make_ssa_name (var);\n@@ -2610,6 +2603,7 @@ reassociate_to_the_same_stmt (tree name1, tree name2, gimple *insert_before)\n   s1 = gsi_stmt (bsi);\n   update_stmt (s1);\n \n+  gsi_insert_before (&bsi, new_stmt, GSI_SAME_STMT);\n   gsi_insert_before (&bsi, tmp_stmt, GSI_SAME_STMT);\n \n   return new_stmt;\n@@ -2618,11 +2612,10 @@ reassociate_to_the_same_stmt (tree name1, tree name2, gimple *insert_before)\n /* Returns the statement that combines references R1 and R2.  In case R1\n    and R2 are not used in the same statement, but they are used with an\n    associative and commutative operation in the same expression, reassociate\n-   the expression so that they are used in the same statement.  The combined\n-   statement is inserted before INSERT_BEFORE if it's not NULL.  */\n+   the expression so that they are used in the same statement.  */\n \n static gimple *\n-stmt_combining_refs (dref r1, dref r2, gimple *insert_before)\n+stmt_combining_refs (dref r1, dref r2)\n {\n   gimple *stmt1, *stmt2;\n   tree name1 = name_for_ref (r1);\n@@ -2633,7 +2626,7 @@ stmt_combining_refs (dref r1, dref r2, gimple *insert_before)\n   if (stmt1 == stmt2)\n     return stmt1;\n \n-  return reassociate_to_the_same_stmt (name1, name2, insert_before);\n+  return reassociate_to_the_same_stmt (name1, name2);\n }\n \n /* Tries to combine chains CH1 and CH2 together.  If this succeeds, the\n@@ -2646,7 +2639,7 @@ combine_chains (chain_p ch1, chain_p ch2)\n   enum tree_code op = ERROR_MARK;\n   bool swap = false;\n   chain_p new_chain;\n-  int i, j, num;\n+  unsigned i;\n   gimple *root_stmt;\n   tree rslt_type = NULL_TREE;\n \n@@ -2668,9 +2661,6 @@ combine_chains (chain_p ch1, chain_p ch2)\n \treturn NULL;\n     }\n \n-  ch1->combined = true;\n-  ch2->combined = true;\n-\n   if (swap)\n     std::swap (ch1, ch2);\n \n@@ -2682,45 +2672,15 @@ combine_chains (chain_p ch1, chain_p ch2)\n   new_chain->rslt_type = rslt_type;\n   new_chain->length = ch1->length;\n \n-  gimple *insert = NULL;\n-  num = ch1->refs.length ();\n-  i = (new_chain->length == 0) ? num - 1 : 0;\n-  j = (new_chain->length == 0) ? -1 : 1;\n-  /* For ZERO length chain, process refs in reverse order so that dominant\n-     position is ready when it comes to the root ref.\n-     For non-ZERO length chain, process refs in order.  See PR79663.  */\n-  for (; num > 0; num--, i += j)\n-    {\n-      r1 = ch1->refs[i];\n-      r2 = ch2->refs[i];\n+  for (i = 0; (ch1->refs.iterate (i, &r1)\n+\t       && ch2->refs.iterate (i, &r2)); i++)\n+    {\n       nw = XCNEW (struct dref_d);\n+      nw->stmt = stmt_combining_refs (r1, r2);\n       nw->distance = r1->distance;\n \n-      /* For ZERO length chain, insert combined stmt of root ref at dominant\n-\t position.  */\n-      nw->stmt = stmt_combining_refs (r1, r2, i == 0 ? insert : NULL);\n-      /* For ZERO length chain, record dominant position where combined stmt\n-\t of root ref should be inserted.  In this case, though all root refs\n-\t dominate following ones, it's possible that combined stmt doesn't.\n-\t See PR70754.  */\n-      if (new_chain->length == 0\n-\t  && (insert == NULL || stmt_dominates_stmt_p (nw->stmt, insert)))\n-\tinsert = nw->stmt;\n-\n       new_chain->refs.safe_push (nw);\n     }\n-  if (new_chain->length == 0)\n-    {\n-      /* Restore the order for ZERO length chain's refs.  */\n-      num = new_chain->refs.length () >> 1;\n-      for (i = 0, j = new_chain->refs.length () - 1; i < num; i++, j--)\n-\tstd::swap (new_chain->refs[i], new_chain->refs[j]);\n-\n-      /* For ZERO length chain, has_max_use_after must be true since root\n-\t combined stmt must dominates others.  */\n-      new_chain->has_max_use_after = true;\n-      return new_chain;\n-    }\n \n   new_chain->has_max_use_after = false;\n   root_stmt = get_chain_root (new_chain)->stmt;\n@@ -2734,6 +2694,8 @@ combine_chains (chain_p ch1, chain_p ch2)\n \t}\n     }\n \n+  ch1->combined = true;\n+  ch2->combined = true;\n   return new_chain;\n }\n "}]}