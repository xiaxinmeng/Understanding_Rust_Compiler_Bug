{"sha": "f1dedc319f5cd88b32fb105ebe73e92283e6ba3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFkZWRjMzE5ZjVjZDg4YjMyZmIxMDVlYmU3M2U5MjI4M2U2YmEzYQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-08-25T22:07:18Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-08-25T22:07:18Z"}, "message": "cp-tree.def (SUBOBJECT): New tree node.\n\n\t* cp-tree.def (SUBOBJECT): New tree node.\n\t* cp-tree.h (CLEANUP_P): New macro.\n\t(SUBOBJECT_CLEANUP): Likewise.\n\t(keep_next_level): Add parameter.\n\t(get_temp_regvar): Don't declare.\n\t(emit_base_init): Remove parameter.\n\t(expand_aggr_init): Rename to build_aggr_init.\n\t(expand_vec_init): Rename to build_vec_init.\n\t(do_pushlevel): Remove.\n\t(do_poplevel): Likewise.\n\t(finish_cleanup): New function.\n\t(finish_subobject): Likewise.\n\t(stmts_are_full_exprs_p): New variable.\n\t* decl.c (keep_next_level): Add parameter.\n\t(cp_finish_decl): Use build_aggr_init, not\n\texpand_aggr_init.  Use finish_expr_stmt to expand the code.\n\t(expand_static_init): Use tree-generating, not RTL-generating,\n\tfunctions to handle the initialization.\n\t(start_function): Remove dead code.  Always have a momentary\n\tobstack inside the function, even before hitting the first curly\n\tbrace.\n\t(cplus_expand_expr_stmt): Move calls to\n\texpand_{start,end}_target_temps into semantics.c.\n\t(cp_function): Add stmts_are_full_exprs_p.\n\t(push_cp_function_context): Save it.\n\t(pop_cp_function_context): Restore it.\n\t* decl2.c (get_temp_regvar): Move to init.c.\n\t(do_static_initialization): Use build_{aggr,vec}_init.\n\t(do_static_destruction): Fix typo in comment.\n\t* dump.c (dequeue_and_dump): Handle INIT_EXPR.\n\t* except.c (expand_throw): Use create_temporary_var.\n\t* expr.c (cplus_expand_expr): Use build_{aggr,vec}_init.\n\t* init.c (expand_vec_init_try_block): Remove.\n\t(expand_vec_init_catch_clause): Likewise.\n\t(get_temp_regvar): New function.\n\t(begin_init_stmts): Likewise.\n\t(finish_init_stmts): Likewise.\n\t(perform_member_init): Use build_{aggr,vec}_init.  Build up tree\n\tstructure here.\n\t(emit_base_init): Likewise.  Remove unused parameter.\n\t(expand_virtual_init): Likewise.\n\t(expand_cleanup_for_base): Use finish_subobject.\n\t(expand_aggr_vbase_init_1): Simplify.\n\t(construct_virtual_bases): Use tree-generating functions to build\n\tup initialization.\n\t(expand_aggr_init): Likewise.  Rename to build_aggr_init.\n\t(expand_default_init): Likewise.\n\t(expand_aggr_init_1): Likewise.\n\t(expand_vec_init): Rename to build_vec_init.\n\t* method.c (do_build_copy_constructor): Use tree-generating\n\tfunctions.  Don't call clear_last_expr.\n\t(do_build_assign_ref): Likewise.\n\t(synthesize_method): Call clear_last_expr here.\n\t* parse.y (base_init): Don't call clear_last_expr here.\n\t(nodecls): Likewise.\n\t* pt.c (tsubst_expr): Handle a TRY_BLOCK with CLEANUP_P set.\n\t* semantics.c (do_pushlevel): Move to here.\n\t(do_poplevel): Likewise.\n\t(stmts_are_full_exprs_p): New variable.\n\t(finish_expr_stmt): Handle logic for temoprary cleanup here.\n\t(finish_for_stmt): Use finish_expr_stmt.\n\t(finish_cleanup): New function.\n\t(finish_function_try_block): Fix indentation.\n\t(finish_subobject): New function.\n\t(setup_vtbl_ptr): Call keep_next_level here.\n\t(finish_stmt_expr): Handle a block with no scope inside the\n\tstatement-expression.\n\t(expand_stmt): Handle a TRY_BLOCK with CLEANUP_P set.  Handle\n\tSUBOBJECT.\n\t* tree.c (search_tree): Handle INIT_EXPR.\n\t(mapcar): Likewise.\n\t* typeck.c (build_modify_expr): Don't build an RTL_EXPR.\n\t* typeck2.c (store_init_value): Change expand_aggr_init to\n\tbuild_aggr_init in comment.\n\nFrom-SVN: r28878", "tree": {"sha": "234c56a0c0ad379c6bc647768852d1e963623dff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/234c56a0c0ad379c6bc647768852d1e963623dff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/comments", "author": null, "committer": null, "parents": [{"sha": "1d0e51ba333e93a4166ebf5a9eda333b5ca647f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d0e51ba333e93a4166ebf5a9eda333b5ca647f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d0e51ba333e93a4166ebf5a9eda333b5ca647f3"}], "stats": {"total": 2956, "additions": 1620, "deletions": 1336}, "files": [{"sha": "72cc6a5629ea2a5413e894f145cef6911f298a56", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f1dedc319f5cd88b32fb105ebe73e92283e6ba3a", "patch": "@@ -1,3 +1,80 @@\n+1999-08-25  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.def (SUBOBJECT): New tree node.\n+\t* cp-tree.h (CLEANUP_P): New macro.\n+\t(SUBOBJECT_CLEANUP): Likewise.\n+\t(keep_next_level): Add parameter.\n+\t(get_temp_regvar): Don't declare.\n+\t(emit_base_init): Remove parameter.\n+\t(expand_aggr_init): Rename to build_aggr_init.\n+\t(expand_vec_init): Rename to build_vec_init.\n+\t(do_pushlevel): Remove.\n+\t(do_poplevel): Likewise.\n+\t(finish_cleanup): New function.\n+\t(finish_subobject): Likewise.\n+\t(stmts_are_full_exprs_p): New variable.\n+\t* decl.c (keep_next_level): Add parameter.\n+\t(cp_finish_decl): Use build_aggr_init, not\n+\texpand_aggr_init.  Use finish_expr_stmt to expand the code.\n+\t(expand_static_init): Use tree-generating, not RTL-generating,\n+\tfunctions to handle the initialization.\n+\t(start_function): Remove dead code.  Always have a momentary\n+\tobstack inside the function, even before hitting the first curly\n+\tbrace.\n+\t(cplus_expand_expr_stmt): Move calls to\n+\texpand_{start,end}_target_temps into semantics.c.\n+\t(cp_function): Add stmts_are_full_exprs_p.\n+\t(push_cp_function_context): Save it.\n+\t(pop_cp_function_context): Restore it.\n+\t* decl2.c (get_temp_regvar): Move to init.c.\n+\t(do_static_initialization): Use build_{aggr,vec}_init.\n+\t(do_static_destruction): Fix typo in comment.\n+\t* dump.c (dequeue_and_dump): Handle INIT_EXPR.\n+\t* except.c (expand_throw): Use create_temporary_var.\n+\t* expr.c (cplus_expand_expr): Use build_{aggr,vec}_init.\n+\t* init.c (expand_vec_init_try_block): Remove.\n+\t(expand_vec_init_catch_clause): Likewise.\n+\t(get_temp_regvar): New function.\n+\t(begin_init_stmts): Likewise.\n+\t(finish_init_stmts): Likewise.\n+\t(perform_member_init): Use build_{aggr,vec}_init.  Build up tree\n+\tstructure here.\n+\t(emit_base_init): Likewise.  Remove unused parameter.\n+\t(expand_virtual_init): Likewise.\n+\t(expand_cleanup_for_base): Use finish_subobject.\n+\t(expand_aggr_vbase_init_1): Simplify.\n+\t(construct_virtual_bases): Use tree-generating functions to build\n+\tup initialization.\n+\t(expand_aggr_init): Likewise.  Rename to build_aggr_init.\n+\t(expand_default_init): Likewise.\n+\t(expand_aggr_init_1): Likewise.\n+\t(expand_vec_init): Rename to build_vec_init.\n+\t* method.c (do_build_copy_constructor): Use tree-generating\n+\tfunctions.  Don't call clear_last_expr.\n+\t(do_build_assign_ref): Likewise.\n+\t(synthesize_method): Call clear_last_expr here.\n+\t* parse.y (base_init): Don't call clear_last_expr here.\n+\t(nodecls): Likewise.\n+\t* pt.c (tsubst_expr): Handle a TRY_BLOCK with CLEANUP_P set.\n+\t* semantics.c (do_pushlevel): Move to here.\n+\t(do_poplevel): Likewise.\n+\t(stmts_are_full_exprs_p): New variable.\n+\t(finish_expr_stmt): Handle logic for temoprary cleanup here.\n+\t(finish_for_stmt): Use finish_expr_stmt.\n+\t(finish_cleanup): New function.\n+\t(finish_function_try_block): Fix indentation.\n+\t(finish_subobject): New function.\n+\t(setup_vtbl_ptr): Call keep_next_level here.\n+\t(finish_stmt_expr): Handle a block with no scope inside the\n+\tstatement-expression.\n+\t(expand_stmt): Handle a TRY_BLOCK with CLEANUP_P set.  Handle\n+\tSUBOBJECT.\n+\t* tree.c (search_tree): Handle INIT_EXPR.\n+\t(mapcar): Likewise.\n+\t* typeck.c (build_modify_expr): Don't build an RTL_EXPR.\n+\t* typeck2.c (store_init_value): Change expand_aggr_init to\n+\tbuild_aggr_init in comment.\n+\t\n 1999-08-25  Mark Mitchell  <mark@codesourcery.com>\n \n \t* dump.c (dequeue_and_dump): Dump TARGET_EXPRs."}, {"sha": "acd09b5a9e28e6f5f709e4ced9675ee9e2745cf8", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=f1dedc319f5cd88b32fb105ebe73e92283e6ba3a", "patch": "@@ -229,7 +229,11 @@ DEFTREECODE (CONTINUE_STMT, \"continue_stmt\", 'e', 0)\n DEFTREECODE (SWITCH_STMT, \"switch_stmt\", 'e', 2)\n DEFTREECODE (GOTO_STMT, \"goto_stmt\", 'e', 1)\n DEFTREECODE (ASM_STMT, \"asm_stmt\", 'e', 5)\n-\n+/* A SUBOBJECT statement marks the point at which a sub-object is\n+   fully constructed.  After this point, the SUBOBJECT_CLEANUP must be\n+   run if an exception is thrown before the end of the enclosing\n+   function.  */\n+DEFTREECODE (SUBOBJECT, \"subobject\", 'e', 1)\n DEFTREECODE (CTOR_INITIALIZER, \"ctor_initializer\", 'e', 2)\n DEFTREECODE (CASE_LABEL, \"case_label\", 'e', 2)\n DEFTREECODE (RETURN_INIT, \"return_init\", 'e', 2)"}, {"sha": "13f1e7d8cd7c4099f81198cf6f62f5757acd29e9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f1dedc319f5cd88b32fb105ebe73e92283e6ba3a", "patch": "@@ -35,6 +35,7 @@ Boston, MA 02111-1307, USA.  */\n       IDENTIFIER_MARKED (used by search routines).\n       LOCAL_BINDING_P (in CPLUS_BINDING)\n       ICS_USER_FLAG (in _CONV)\n+      CLEANUP_P (in TRY_BLOCK)\n    1: IDENTIFIER_VIRTUAL_P.\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n@@ -2141,6 +2142,7 @@ extern int flag_new_for_scope;\n #define GOTO_DESTINATION(NODE)  TREE_OPERAND (NODE, 0)\n #define TRY_STMTS(NODE)         TREE_OPERAND (NODE, 0)\n #define TRY_HANDLERS(NODE)      TREE_OPERAND (NODE, 1)\n+#define CLEANUP_P(NODE)         TREE_LANG_FLAG_0 (NODE)\n #define HANDLER_PARMS(NODE)     TREE_OPERAND (NODE, 0)\n #define HANDLER_BODY(NODE)      TREE_OPERAND (NODE, 1)\n #define COMPOUND_BODY(NODE)     TREE_OPERAND (NODE, 0)\n@@ -2151,6 +2153,7 @@ extern int flag_new_for_scope;\n #define ASM_CLOBBERS(NODE)      TREE_OPERAND (NODE, 4)\n #define DECL_STMT_DECL(NODE)    TREE_OPERAND (NODE, 0)\n #define STMT_EXPR_STMT(NODE)    TREE_OPERAND (NODE, 0)\n+#define SUBOBJECT_CLEANUP(NODE) TREE_OPERAND (NODE, 0)\n \n /* Nonzero for an ASM_STMT if the assembly statement is volatile.  */\n #define ASM_VOLATILE_P(NODE)\t\t\t\\\n@@ -2841,7 +2844,7 @@ extern void set_identifier_local_value\t\tPROTO((tree, tree));\n extern int global_bindings_p\t\t\tPROTO((void));\n extern int toplevel_bindings_p\t\t\tPROTO((void));\n extern int namespace_bindings_p\t\t\tPROTO((void));\n-extern void keep_next_level\t\t\tPROTO((void));\n+extern void keep_next_level\t\t\tPROTO((int));\n extern int kept_level_p\t\t\t\tPROTO((void));\n extern void declare_parm_level\t\t\tPROTO((void));\n extern void declare_pseudo_global_level\t\tPROTO((void));\n@@ -3009,7 +3012,6 @@ extern void setup_vtbl_ptr\t\t\tPROTO((void));\n extern void mark_inline_for_output\t\tPROTO((tree));\n extern void clear_temp_name\t\t\tPROTO((void));\n extern tree get_temp_name\t\t\tPROTO((tree, int));\n-extern tree get_temp_regvar\t\t\tPROTO((tree, tree));\n extern void finish_anon_union\t\t\tPROTO((tree));\n extern tree finish_table\t\t\tPROTO((tree, tree, tree, int));\n extern void finish_builtin_type\t\t\tPROTO((tree, const char *,\n@@ -3105,10 +3107,10 @@ extern tree do_friend\t\t\t\tPROTO((tree, tree, tree, tree, tree, enum overload_flag\n /* in init.c */\n extern void init_init_processing\t\tPROTO((void));\n extern void expand_direct_vtbls_init\t\tPROTO((tree, tree, int, int, tree));\n-extern void emit_base_init\t\t\tPROTO((tree, int));\n+extern void emit_base_init\t\t\tPROTO((tree));\n extern void check_base_init\t\t\tPROTO((tree));\n extern void expand_member_init\t\t\tPROTO((tree, tree, tree));\n-extern void expand_aggr_init\t\t\tPROTO((tree, tree, int));\n+extern tree build_aggr_init\t\t\tPROTO((tree, tree, int));\n extern int is_aggr_typedef\t\t\tPROTO((tree, int));\n extern int is_aggr_type\t\t\t\tPROTO((tree, int));\n extern tree get_aggr_from_typedef\t\tPROTO((tree, int));\n@@ -3119,11 +3121,12 @@ extern tree resolve_offset_ref\t\t\tPROTO((tree));\n extern tree decl_constant_value\t\t\tPROTO((tree));\n extern tree build_new\t\t\t\tPROTO((tree, tree, tree, int));\n extern tree build_new_1\t\t\t\tPROTO((tree));\n-extern tree expand_vec_init\t\t\tPROTO((tree, tree, tree, tree, int));\n+extern tree build_vec_init\t\t\tPROTO((tree, tree, tree, tree, int));\n extern tree build_x_delete\t\t\tPROTO((tree, int, tree));\n extern tree build_delete\t\t\tPROTO((tree, tree, tree, int, int));\n extern tree build_vbase_delete\t\t\tPROTO((tree, tree));\n extern tree build_vec_delete\t\t\tPROTO((tree, tree, tree, tree, int));\n+extern tree create_temporary_var                PROTO((tree));\n \n /* in input.c */\n \n@@ -3234,15 +3237,13 @@ extern void mark_class_instantiated\t\tPROTO((tree, int));\n extern void do_decl_instantiation\t\tPROTO((tree, tree, tree));\n extern void do_type_instantiation\t\tPROTO((tree, tree));\n extern tree instantiate_decl\t\t\tPROTO((tree));\n-extern tree do_poplevel\t\t\t\tPROTO((void));\n extern tree get_bindings\t\t\tPROTO((tree, tree, tree));\n extern void add_tree\t\t\t\tPROTO((tree));\n extern void begin_tree                          PROTO((void));\n extern void end_tree                            PROTO((void));\n extern void add_maybe_template\t\t\tPROTO((tree, tree));\n extern void pop_tinst_level\t\t\tPROTO((void));\n extern int more_specialized_class\t\tPROTO((tree, tree));\n-extern void do_pushlevel\t\t\tPROTO((void));\n extern int is_member_template                   PROTO((tree));\n extern int template_parms_equal                 PROTO((tree, tree));\n extern int comp_template_parms                  PROTO((tree, tree));\n@@ -3349,10 +3350,12 @@ extern void finish_function_handler_sequence    PROTO((tree));\n extern tree begin_handler                       PROTO((void));\n extern void finish_handler_parms                PROTO((tree));\n extern void finish_handler                      PROTO((tree));\n+extern void finish_cleanup                      PROTO((tree, tree));\n extern tree begin_compound_stmt                 PROTO((int));\n extern tree finish_compound_stmt                PROTO((int, tree));\n extern void finish_asm_stmt                     PROTO((tree, tree, tree, tree, tree));\n extern void finish_label_stmt                   PROTO((tree));\n+extern void finish_subobject                    PROTO((tree));\n extern tree finish_parenthesized_expr           PROTO((tree));\n extern tree begin_stmt_expr                     PROTO((void));\n extern tree finish_stmt_expr                    PROTO((tree, tree));\n@@ -3395,6 +3398,7 @@ extern void expand_body                         PROTO((tree));\n extern void begin_stmt_tree                     PROTO((tree));\n extern void finish_stmt_tree                    PROTO((tree));\n extern int expanding_p;\n+extern int stmts_are_full_exprs_p;\n extern tree last_expr_type;\n /* Non-zero if we are presently building a statement tree, rather\n    than expanding each statement as we encounter it.  */"}, {"sha": "3d165372f179b7e9b300469b5f40affdd6a67caa", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 58, "deletions": 45, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=f1dedc319f5cd88b32fb105ebe73e92283e6ba3a", "patch": "@@ -882,10 +882,15 @@ namespace_bindings_p ()\n   return b->namespace_p;\n }\n \n+/* If KEEP is non-zero, make a BLOCK node for the next binding level,\n+   unconditionally.  Otherwise, use the normal logic to decide whether\n+   or not to create a BLOCK.  */\n+\n void\n-keep_next_level ()\n+keep_next_level (keep)\n+     int keep;\n {\n-  keep_next_level_flag = 1;\n+  keep_next_level_flag = keep;\n }\n \n /* Nonzero if the current level needs to have a BLOCK made.  */\n@@ -7908,7 +7913,16 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t\t{\n \t\t  emit_line_note (DECL_SOURCE_FILE (decl),\n \t\t\t\t  DECL_SOURCE_LINE (decl));\n-\t\t  expand_aggr_init (decl, init, flags);\n+\t\t  /* We call push_momentary here so that when\n+\t\t     finish_expr_stmt clears the momentary obstack it\n+\t\t     doesn't destory any momentary expressions we may\n+\t\t     have lying around.  Although cp_finish_decl is\n+\t\t     usually called at the end of a declaration\n+\t\t     statement, it may also be called for a temporary\n+\t\t     object in the middle of an expression.  */\n+\t\t  push_momentary ();\n+\t\t  finish_expr_stmt (build_aggr_init (decl, init, flags));\n+\t\t  pop_momentary ();\n \t\t}\n \n \t      /* Set this to 0 so we can tell whether an aggregate which\n@@ -8024,6 +8038,8 @@ expand_static_init (decl, init)\n     {\n       /* Emit code to perform this initialization but once.  */\n       tree temp;\n+      tree assignment;\n+      tree temp_init;\n \n       /* Remember this information until end of file.  */\n       push_obstacks (&permanent_obstack, &permanent_obstack);\n@@ -8058,26 +8074,35 @@ expand_static_init (decl, init)\n       /* Begin the conditional initialization.  */\n       expand_start_cond (build_binary_op (EQ_EXPR, temp,\n \t\t\t\t\t  integer_zero_node), 0);\n-      expand_start_target_temps ();\n \n       /* Do the initialization itself.  */\n       if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl))\n \t  || (init && TREE_CODE (init) == TREE_LIST))\n-\t{\n-\t  expand_aggr_init (decl, init, 0);\n-\t  do_pending_stack_adjust ();\n-\t}\n+\tassignment = build_aggr_init (decl, init, 0);\n       else if (init)\n-\texpand_assignment (decl, init, 0, 0);\n-\n-      /* Set TEMP to 1.  */\n-      expand_assignment (temp, integer_one_node, 0, 0);\n-\n-      /* Cleanup any temporaries needed for the initial value.  If\n-\t destroying one of the temporaries causes an exception to be\n-\t thrown, then the object itself has still been fully\n-\t constructed.  */\n-      expand_end_target_temps ();\n+\tassignment = build_modify_expr (decl, NOP_EXPR, init);\n+      else\n+\tassignment = NULL_TREE;\n+\n+      /* Once the assignment is complete, set TEMP to 1.  Since the\n+\t construction of the static object is complete at this point,\n+\t we want to make sure TEMP is set to 1 even if a temporary\n+\t constructed during the initialization throws an exception\n+\t when it is destroyed.  So, we combine the initialization and\n+\t the assignment to TEMP into a single expression, ensuring\n+\t that when we call finish_expr_stmt the cleanups will not be\n+\t run until after TEMP is set to 1.  */\n+      temp_init = build_modify_expr (temp, NOP_EXPR, integer_one_node);\n+      if (assignment)\n+\t{\n+\t  assignment = tree_cons (NULL_TREE, assignment,\n+\t\t\t\t  build_tree_list (NULL_TREE, \n+\t\t\t\t\t\t   temp_init));\n+\t  assignment = build_compound_expr (assignment);\n+\t}\n+      else\n+\tassignment = temp_init;\n+      finish_expr_stmt (assignment);\n \n       /* Use atexit to register a function for destroying this static\n \t variable.  */\n@@ -12813,25 +12838,6 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n     {\n       decl1 = declarator;\n \n-#if 0\n-      /* What was this testing for, exactly?  */\n-      if (! DECL_ARGUMENTS (decl1)\n-\t  && !DECL_STATIC_FUNCTION_P (decl1)\n-\t  && !DECL_ARTIFICIAL (decl1)\n-\t  && DECL_CLASS_SCOPE_P (decl1)\n-\t  && TYPE_IDENTIFIER (DECL_CONTEXT (decl1))\n-\t  && IDENTIFIER_TEMPLATE (TYPE_IDENTIFIER (DECL_CONTEXT (decl1))))\n-\t{\n-\t  tree binding = binding_for_name (DECL_NAME (decl1), \n-\t\t\t\t\t   current_namespace);\n-\t  cp_error (\"redeclaration of `%#D'\", decl1);\n-\t  if (IDENTIFIER_CLASS_VALUE (DECL_NAME (decl1)))\n-\t    cp_error_at (\"previous declaration here\", IDENTIFIER_CLASS_VALUE (DECL_NAME (decl1)));\n-\t  else if (BINDING_VALUE (binding))\n-\t    cp_error_at (\"previous declaration here\", BINDING_VALUE (binding));\n-\t}\n-#endif\n-\n       fntype = TREE_TYPE (decl1);\n       if (TREE_CODE (fntype) == METHOD_TYPE)\n \tctype = TYPE_METHOD_BASETYPE (fntype);\n@@ -13161,6 +13167,10 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n      on the permanent obstack in case we need to inline it later.  */\n   if (! hack_decl_function_context (decl1))\n     temporary_allocation ();\n+  \n+  /* Make sure that we always have a momntary obstack while we're in a\n+     function body.  */\n+  push_momentary ();\n \n   if (building_stmt_tree ())\n     begin_stmt_tree (decl1);\n@@ -13856,6 +13866,9 @@ finish_function (lineno, flags, nested)\n      to the FUNCTION_DECL node itself.  */\n   BLOCK_SUPERCONTEXT (DECL_INITIAL (fndecl)) = fndecl;\n \n+  /* Undo the call to push_momentary in start_function.  */\n+  pop_momentary ();\n+\n   if (expand_p)\n     {\n       int saved_flag_keep_inline_functions =\n@@ -14261,9 +14274,6 @@ void\n cplus_expand_expr_stmt (exp)\n      tree exp;\n {\n-  /* Arrange for all temps to disappear.  */\n-  expand_start_target_temps ();\n-\n   exp = require_complete_type_in_void (exp);\n   \n   if (TREE_CODE (exp) == FUNCTION_DECL)\n@@ -14288,10 +14298,6 @@ cplus_expand_expr_stmt (exp)\n      go outside the bounds of the type.  */\n   if (exp != error_mark_node)\n     expand_expr_stmt (break_out_cleanups (exp));\n-\n-  /* Clean up any pending cleanups.  This happens when a function call\n-     returns a cleanup-needing value that nobody uses.  */\n-  expand_end_target_temps ();\n }\n \n /* When a stmt has been parsed, this function is called.  */\n@@ -14381,6 +14387,7 @@ struct cp_function\n   int static_labelno;\n   int in_function_try_handler;\n   int expanding_p;\n+  int stmts_are_full_exprs_p; \n   tree last_tree;\n   tree last_expr_type;\n };\n@@ -14429,10 +14436,15 @@ push_cp_function_context (context)\n   p->last_tree = last_tree;\n   p->last_expr_type = last_expr_type;\n   p->expanding_p = expanding_p;\n-  \n+  p->stmts_are_full_exprs_p = stmts_are_full_exprs_p;\n+\n   /* For now, we always assume we're expanding all the way to RTL\n      unless we're explicitly doing otherwise.  */\n   expanding_p = 1;\n+\n+  /* Whenever we start a new function, we destroy temporaries in the\n+     usual way.  */\n+  stmts_are_full_exprs_p = 1;\n }\n \n /* Restore the variables used during compilation of a C++ function.  */\n@@ -14479,6 +14491,7 @@ pop_cp_function_context (context)\n   last_tree = p->last_tree;\n   last_expr_type = p->last_expr_type;\n   expanding_p = p->expanding_p;\n+  stmts_are_full_exprs_p = p->stmts_are_full_exprs_p;\n \n   free (p);\n }"}, {"sha": "100f332d192971f0d8722cefc8e7d4a661680db0", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 6, "deletions": 30, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=f1dedc319f5cd88b32fb105ebe73e92283e6ba3a", "patch": "@@ -2077,31 +2077,6 @@ get_temp_name (type, staticp)\n   return decl;\n }\n \n-/* Get a variable which we can use for multiple assignments.\n-   It is not entered into current_binding_level, because\n-   that breaks things when it comes time to do final cleanups\n-   (which take place \"outside\" the binding contour of the function).  */\n-\n-tree\n-get_temp_regvar (type, init)\n-     tree type, init;\n-{\n-  tree decl;\n-\n-  decl = build_decl (VAR_DECL, NULL_TREE, type);\n-  TREE_USED (decl) = 1;\n-  DECL_REGISTER (decl) = 1;\n-  DECL_ARTIFICIAL (decl) = 1;\n-\n-  DECL_RTL (decl) = assign_temp (type, 2, 0, 1);\n-  /* We can expand these without fear, since they cannot need\n-     constructors or destructors.  */\n-  expand_expr (build_modify_expr (decl, INIT_EXPR, init),\n-\t       NULL_RTX, VOIDmode, 0);\n-\n-  return decl;\n-}\n-\n /* Hunts through the global anonymous union ANON_DECL, building\n    appropriate VAR_DECLs.  Stores cleanups on the list of ELEMS, and\n    returns a VAR_DECL whose size is the same as the size of the\n@@ -3219,11 +3194,12 @@ do_static_initialization (decl, init, sentry, priority)\n \n   if (IS_AGGR_TYPE (TREE_TYPE (decl))\n       || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n-    expand_aggr_init (decl, init, 0);\n+    expand_expr (build_aggr_init (decl, init, 0),\n+\t\t const0_rtx, VOIDmode, EXPAND_NORMAL);\n   else if (TREE_CODE (init) == TREE_VEC)\n-    expand_expr (expand_vec_init (decl, TREE_VEC_ELT (init, 0),\n-\t\t\t\t  TREE_VEC_ELT (init, 1),\n-\t\t\t\t  TREE_VEC_ELT (init, 2), 0),\n+    expand_expr (build_vec_init (decl, TREE_VEC_ELT (init, 0),\n+\t\t\t\t TREE_VEC_ELT (init, 1),\n+\t\t\t\t TREE_VEC_ELT (init, 2), 0),\n \t\t const0_rtx, VOIDmode, EXPAND_NORMAL);\n   else\n     expand_assignment (decl, init, 0, 0);\n@@ -3290,7 +3266,7 @@ do_static_destruction (decl, sentry, priority)\n \t\t\t\t\tinteger_zero_node),\n \t\t       /*exit_flag=*/0);\n   \n-  /* Actually to the destruction.  */\n+  /* Actually do the destruction.  */\n   expand_expr_stmt (build_cleanup (decl));\n \n   /* Cleanup any deferred pops from function calls.  This would be done"}, {"sha": "f42474b563c7ef1123b7127dc1c1f36936c81e4f", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=f1dedc319f5cd88b32fb105ebe73e92283e6ba3a", "patch": "@@ -768,6 +768,13 @@ dequeue_and_dump (di)\n       dump_next_stmt (di, t);\n       break;\n \n+    case SUBOBJECT:\n+      dump_stmt (di, t);\n+      if (dump_children_p)\n+\tdump_child (\"clnp\", TREE_OPERAND (t, 0));\n+      dump_next_stmt (di, t);\n+      break;\n+\n     case INTEGER_CST:\n       if (TREE_INT_CST_HIGH (t))\n \tdump_int (di, \"high\", TREE_INT_CST_HIGH (t));\n@@ -798,6 +805,7 @@ dequeue_and_dump (di)\n \n     case TRUTH_ANDIF_EXPR:\n     case TRUTH_ORIF_EXPR:\n+    case INIT_EXPR:\n     case MODIFY_EXPR:\n     case COMPONENT_REF:\n     case COMPOUND_EXPR:"}, {"sha": "3a6b9dd90afd8ef4904e573cd7ec53ac4d1456a4", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=f1dedc319f5cd88b32fb105ebe73e92283e6ba3a", "patch": "@@ -965,9 +965,7 @@ expand_throw (exp)\n \t     ourselves into expand_call.  */\n \t  if (TREE_SIDE_EFFECTS (exp))\n \t    {\n-\t      tree temp = build_decl (VAR_DECL, NULL_TREE, TREE_TYPE (exp));\n-\t      DECL_ARTIFICIAL (temp) = 1;\n-\t      DECL_RTL (temp) = assign_temp (TREE_TYPE (exp), 2, 0, 1);\n+\t      tree temp = create_temporary_var (TREE_TYPE (exp));\n \t      DECL_INITIAL (temp) = exp;\n \t      cp_finish_decl (temp, exp, NULL_TREE, 0, LOOKUP_ONLYCONVERTING);\n \t      exp = temp;"}, {"sha": "e85e08813e8fb5f77f63d482a7e79a24e80d7338", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=f1dedc319f5cd88b32fb105ebe73e92283e6ba3a", "patch": "@@ -204,7 +204,9 @@ cplus_expand_expr (exp, target, tmode, modifier)\n \t    init = convert_from_reference (init);\n \n \t    flag_access_control = 0;\n-\t    expand_aggr_init (slot, init, LOOKUP_ONLYCONVERTING);\n+\t    expand_expr (build_aggr_init (slot, init,\n+\t\t\t\t\t  LOOKUP_ONLYCONVERTING), \n+\t\t\t target, tmode, EXPAND_NORMAL);\n \t    flag_access_control = old_ac;\n \n \t    if (TYPE_NEEDS_DESTRUCTOR (type))\n@@ -237,7 +239,7 @@ cplus_expand_expr (exp, target, tmode, modifier)\n \n     case VEC_INIT_EXPR:\n       return expand_expr\n-\t(expand_vec_init\n+\t(build_vec_init\n \t (NULL_TREE, TREE_OPERAND (exp, 0),\n \t  build_binary_op (MINUS_EXPR, TREE_OPERAND (exp, 2),\n \t\t\t   integer_one_node),"}, {"sha": "eba001cfe207a5bf2c35cf0c36567b533533472a", "filename": "gcc/cp/init.c", "status": "modified", "additions": 308, "deletions": 230, "changes": 538, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=f1dedc319f5cd88b32fb105ebe73e92283e6ba3a", "patch": "@@ -57,10 +57,11 @@ static int member_init_ok_or_else PROTO((tree, tree, const char *));\n static void expand_virtual_init PROTO((tree, tree));\n static tree sort_member_init PROTO((tree));\n static tree initializing_context PROTO((tree));\n-static void expand_vec_init_try_block PROTO((tree));\n-static void expand_vec_init_catch_clause PROTO((tree, tree, tree, tree));\n static tree build_java_class_ref PROTO((tree));\n static void expand_cleanup_for_base PROTO((tree, tree));\n+static tree get_temp_regvar PROTO((tree, tree));\n+static void begin_init_stmts PROTO((tree *, tree *));\n+static tree finish_init_stmts PROTO((tree, tree));\n \n /* Cache the identifier nodes for the magic field of a new cookie.  */\n static tree nc_nelts_field_id;\n@@ -119,6 +120,7 @@ expand_direct_vtbls_init (real_binfo, binfo, init_self, can_elide, addr)\n   tree binfos = BINFO_BASETYPES (binfo);\n   int i, n_baselinks = real_binfos ? TREE_VEC_LENGTH (real_binfos) : 0;\n \n+  push_momentary ();\n   for (i = 0; i < n_baselinks; i++)\n     {\n       tree real_base_binfo = TREE_VEC_ELT (real_binfos, i);\n@@ -140,6 +142,7 @@ expand_direct_vtbls_init (real_binfo, binfo, init_self, can_elide, addr)\n       tree base_ptr = convert_pointer_to_real (binfo, addr);\n       expand_virtual_init (real_binfo, base_ptr);\n     }\n+  pop_momentary ();\n }\n \f\n /* 348 - 351 */\n@@ -153,8 +156,6 @@ perform_member_init (member, name, init, explicit)\n   tree decl;\n   tree type = TREE_TYPE (member);\n \n-  expand_start_target_temps ();\n-\n   decl = build_component_ref (current_class_ref, name, NULL_TREE, explicit);\n \n   /* Deal with this here, as we will get confused if we try to call the\n@@ -164,7 +165,7 @@ perform_member_init (member, name, init, explicit)\n     {\n       init = build (INIT_EXPR, type, decl, TREE_VALUE (init));\n       TREE_SIDE_EFFECTS (init) = 1;\n-      expand_expr_stmt (init);\n+      finish_expr_stmt (init);\n     }\n   else if (TYPE_NEEDS_CONSTRUCTING (type)\n \t   || (init && TYPE_HAS_CONSTRUCTOR (type)))\n@@ -181,11 +182,12 @@ perform_member_init (member, name, init, explicit)\n \t  && TREE_CODE (TREE_TYPE (TREE_VALUE (init))) == ARRAY_TYPE)\n \t{\n \t  /* Initialization of one array from another.  */\n-\t  expand_vec_init (TREE_OPERAND (decl, 1), decl,\n-\t\t\t   array_type_nelts (type), TREE_VALUE (init), 1);\n+\t  finish_expr_stmt \n+\t    (build_vec_init (TREE_OPERAND (decl, 1), decl,\n+\t\t\t     array_type_nelts (type), TREE_VALUE (init), 1));\n \t}\n       else\n-\texpand_aggr_init (decl, init, 0);\n+\tfinish_expr_stmt (build_aggr_init (decl, init, 0));\n     }\n   else\n     {\n@@ -205,7 +207,7 @@ perform_member_init (member, name, init, explicit)\n \t\t     for constructors and such.  */\n \t\t  tree e = build (CONSTRUCTOR, type, NULL_TREE, NULL_TREE);\n \t\t  TREE_SIDE_EFFECTS (e) = 1;\n-\t\t  expand_expr_stmt (build (INIT_EXPR, type, decl, e));\n+\t\t  finish_expr_stmt (build (INIT_EXPR, type, decl, e));\n \t\t}\n  \t      else if (TREE_CODE (type) == REFERENCE_TYPE)\n \t\tcp_error (\"default-initialization of `%#D', which has reference type\",\n@@ -231,12 +233,9 @@ perform_member_init (member, name, init, explicit)\n \t}\n \n       if (init)\n-\texpand_expr_stmt (build_modify_expr (decl, INIT_EXPR, init));\n+\tfinish_expr_stmt (build_modify_expr (decl, INIT_EXPR, init));\n     }\n \n-  expand_end_target_temps ();\n-  free_temp_slots ();\n-\n   if (TYPE_NEEDS_DESTRUCTOR (type))\n     {\n       tree expr;\n@@ -251,7 +250,7 @@ perform_member_init (member, name, init, explicit)\n \t\t\t   LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR, 0);\n \n       if (expr != error_mark_node)\n-\tadd_partial_entry (expr);\n+\tfinish_subobject (expr);\n \n       pop_obstacks ();\n     }\n@@ -508,44 +507,26 @@ sort_base_init (t, rbase_ptr, vbase_ptr)\n extern tree base_init_expr;\n \n void\n-emit_base_init (t, immediately)\n+emit_base_init (t)\n      tree t;\n-     int immediately;\n {\n   tree member;\n   tree mem_init_list;\n   tree rbase_init_list, vbase_init_list;\n   tree t_binfo = TYPE_BINFO (t);\n   tree binfos = BINFO_BASETYPES (t_binfo);\n   int i, n_baseclasses = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-  tree expr = NULL_TREE;\n-\n-  if (! immediately)\n-    {\n-      int momentary;\n-      do_pending_stack_adjust ();\n-      /* Make the RTL_EXPR node temporary, not momentary,\n-\t so that rtl_expr_chain doesn't become garbage.  */\n-      momentary = suspend_momentary ();\n-      expr = make_node (RTL_EXPR);\n-      resume_momentary (momentary);\n-      start_sequence_for_rtl_expr (expr); \n-    }\n-\n-  if (write_symbols == NO_DEBUG)\n-    /* As a matter of principle, `start_sequence' should do this.  */\n-    emit_note (0, -1);\n-  else\n-    /* Always emit a line number note so we can step into constructors.  */\n-    emit_line_note_force (DECL_SOURCE_FILE (current_function_decl),\n-\t\t\t  DECL_SOURCE_LINE (current_function_decl));\n+  tree stmt_expr;\n+  tree compound_stmt;\n \n   mem_init_list = sort_member_init (t);\n   current_member_init_list = NULL_TREE;\n \n   sort_base_init (t, &rbase_init_list, &vbase_init_list);\n   current_base_init_list = NULL_TREE;\n \n+  begin_init_stmts (&stmt_expr, &compound_stmt);\n+  \n   /* First, initialize the virtual base classes, if we are\n      constructing the most-derived object.  */\n   if (TYPE_USES_VIRTUAL_BASECLASSES (t))\n@@ -579,15 +560,10 @@ emit_base_init (t, immediately)\n \n       if (init != void_list_node)\n \t{\n-\t  expand_start_target_temps ();\n-\n \t  member = convert_pointer_to_real (base_binfo, current_class_ptr);\n \t  expand_aggr_init_1 (base_binfo, NULL_TREE,\n \t\t\t      build_indirect_ref (member, NULL_PTR), init,\n \t\t\t      LOOKUP_NORMAL);\n-\n-\t  expand_end_target_temps ();\n-\t  free_temp_slots ();\n \t}\n \n       expand_cleanup_for_base (base_binfo, NULL_TREE);\n@@ -665,36 +641,12 @@ emit_base_init (t, immediately)\n \t\tcp_error (\"field `%D' not in immediate context\", field);\n \t    }\n \n-#if 0\n-\t  /* It turns out if you have an anonymous union in the\n-\t     class, a member from it can end up not being on the\n-\t     list of fields (rather, the type is), and therefore\n-\t     won't be seen by the for loop above.  */\n-\n-\t  /* The code in this for loop is derived from a general loop\n-\t     which had this check in it.  Theoretically, we've hit\n-\t     every initialization for the list of members in T, so\n-\t     we shouldn't have anything but these left in this list.  */\n-\t  my_friendly_assert (DECL_FIELD_CONTEXT (field) != t, 351);\n-#endif\n-\n \t  perform_member_init (field, name, init, 1);\n \t}\n       mem_init_list = TREE_CHAIN (mem_init_list);\n     }\n \n-  if (! immediately)\n-    {\n-      do_pending_stack_adjust ();\n-      my_friendly_assert (base_init_expr == 0, 207);\n-      base_init_expr = expr;\n-      TREE_TYPE (expr) = void_type_node;\n-      RTL_EXPR_RTL (expr) = const0_rtx;\n-      RTL_EXPR_SEQUENCE (expr) = get_insns ();\n-      rtl_expr_chain = tree_cons (NULL_TREE, expr, rtl_expr_chain);\n-      end_sequence ();\n-      TREE_SIDE_EFFECTS (expr) = 1;\n-    }\n+  base_init_expr = finish_init_stmts (stmt_expr, compound_stmt);\n \n   /* All the implicit try blocks we built up will be zapped\n      when we come to a real binding contour boundary.  */\n@@ -745,7 +697,7 @@ expand_virtual_init (binfo, decl)\n \n   /* Have to convert VTBL since array sizes may be different.  */\n   vtbl = convert_force (TREE_TYPE (vtbl_ptr), vtbl, 0);\n-  expand_expr_stmt (build_modify_expr (vtbl_ptr, NOP_EXPR, vtbl));\n+  finish_expr_stmt (build_modify_expr (vtbl_ptr, NOP_EXPR, vtbl));\n }\n \n /* If an exception is thrown in a constructor, those base classes already\n@@ -778,7 +730,7 @@ expand_cleanup_for_base (binfo, flag)\n \t\t\texpr, integer_zero_node));\n \n   pop_obstacks ();\n-  add_partial_entry (expr);\n+  finish_subobject (expr);\n }\n \n /* Subroutine of `expand_aggr_vbase_init'.\n@@ -792,15 +744,10 @@ expand_aggr_vbase_init_1 (binfo, exp, addr, init_list)\n   tree init = purpose_member (binfo, init_list);\n   tree ref = build_indirect_ref (addr, NULL_PTR);\n \n-  expand_start_target_temps ();\n-\n   if (init)\n     init = TREE_VALUE (init);\n   /* Call constructors, but don't set up vtables.  */\n   expand_aggr_init_1 (binfo, exp, ref, init, LOOKUP_COMPLAIN);\n-\n-  expand_end_target_temps ();\n-  free_temp_slots ();\n }\n \n /* Construct the virtual base-classes of THIS_REF (whose address is\n@@ -818,24 +765,33 @@ construct_virtual_bases (type, this_ref, this_ptr, init_list, flag)\n {\n   tree vbases;\n   tree result;\n+  tree if_stmt;\n \n   /* If there are no virtual baseclasses, we shouldn't even be here.  */\n   my_friendly_assert (TYPE_USES_VIRTUAL_BASECLASSES (type), 19990621);\n \n   /* First set the pointers in our object that tell us where to find\n      our virtual baseclasses.  */\n-  expand_start_cond (flag, 0);\n+  if_stmt = begin_if_stmt ();\n+  finish_if_stmt_cond (flag, if_stmt);\n   result = init_vbase_pointers (type, this_ptr);\n+  /* The RESULT will contain entries on the momentary obstack.  They\n+     must live until the end of this function; we use them in the loop\n+     below.  */\n+  push_momentary ();\n   if (result)\n-    expand_expr_stmt (build_compound_expr (result));\n-  expand_end_cond ();\n+    finish_expr_stmt (build_compound_expr (result));\n+  finish_then_clause (if_stmt);\n+  finish_if_stmt ();\n \n   /* Now, run through the baseclasses, initializing each.  */ \n   for (vbases = CLASSTYPE_VBASECLASSES (type); vbases;\n        vbases = TREE_CHAIN (vbases))\n     {\n       tree tmp = purpose_member (vbases, result);\n-      \n+      tree inner_if_stmt;\n+      tree compound_stmt;\n+\n       /* If there are virtual base classes with destructors, we need to\n \t emit cleanups to destroy them if an exception is thrown during\n \t the construction process.  These exception regions (i.e., the\n@@ -850,14 +806,21 @@ construct_virtual_bases (type, this_ref, this_ptr, init_list, flag)\n \t in the outer block.)  We trust the back-end to figure out\n \t that the FLAG will not change across initializations, and\n \t avoid doing multiple tests.  */\n-      expand_start_cond (flag, 0);\n+      inner_if_stmt = begin_if_stmt ();\n+      finish_if_stmt_cond (flag, inner_if_stmt);\n+      compound_stmt = begin_compound_stmt (/*has_no_scope=*/1);\n       expand_aggr_vbase_init_1 (vbases, this_ref,\n \t\t\t\tTREE_OPERAND (TREE_VALUE (tmp), 0),\n \t\t\t\tinit_list);\n-      expand_end_cond ();\n+      finish_compound_stmt (/*has_no_scope=*/1, compound_stmt);\n+      finish_then_clause (if_stmt);\n+      finish_if_stmt ();\n       \n       expand_cleanup_for_base (vbases, flag);\n     }\n+\n+  /* Undo the call to push_momentary above.  */\n+  pop_momentary ();\n }\n \n /* Find the context in which this FIELD can be initialized.  */\n@@ -1035,6 +998,39 @@ expand_member_init (exp, name, init)\n     }\n }\n \n+/* We are about to generate some complex initialization code.\n+   Conceptually, it is all a single expression.  However, we may want\n+   to include conditionals, loops, and other such statement-level\n+   constructs.  Therefore, we build the initialization code inside a\n+   statement-expression.  This function starts such an expression.\n+   STMT_EXPR_P and COMPOUND_STMT_P are filled in by this function;\n+   pass them back to finish_init_stmts when the expression is\n+   complete.  */\n+\n+static void\n+begin_init_stmts (stmt_expr_p, compound_stmt_p)\n+     tree *stmt_expr_p;\n+     tree *compound_stmt_p;\n+{\n+  push_momentary ();\n+  *stmt_expr_p = begin_stmt_expr ();\n+  *compound_stmt_p = begin_compound_stmt (/*has_no_scope=*/1);\n+}\n+\n+/* Finish out the statement-expression begun by the previous call to\n+   begin_init_stmts.  Returns the statement-expression itself.  */\n+\n+static tree\n+finish_init_stmts (stmt_expr, compound_stmt)\n+     tree stmt_expr;\n+     tree compound_stmt;\n+{\n+  pop_momentary ();\n+  return finish_stmt_expr (stmt_expr,\n+\t\t\t   finish_compound_stmt (/*has_no_scope=*/1, \n+\t\t\t\t\t\t compound_stmt));\n+}\n+\n /* This is like `expand_member_init', only it stores one aggregate\n    value into another.\n \n@@ -1073,17 +1069,20 @@ expand_member_init (exp, name, init)\n    A constructor or a conversion operator may have to be used to\n    perform the initialization, but not both, as it would be ambiguous.  */\n \n-void\n-expand_aggr_init (exp, init, flags)\n+tree\n+build_aggr_init (exp, init, flags)\n      tree exp, init;\n      int flags;\n {\n+  tree stmt_expr;\n+  tree compound_stmt;\n+  int destroy_temps;\n   tree type = TREE_TYPE (exp);\n   int was_const = TREE_READONLY (exp);\n   int was_volatile = TREE_THIS_VOLATILE (exp);\n \n   if (init == error_mark_node)\n-    return;\n+    return error_mark_node;\n \n   TREE_READONLY (exp) = 0;\n   TREE_THIS_VOLATILE (exp) = 0;\n@@ -1117,38 +1116,36 @@ expand_aggr_init (exp, init, flags)\n \t     }\n \t  */\n \t  error (\"bad array initializer\");\n-\t  return;\n+\t  return error_mark_node;\n \t}\n-      expand_vec_init (exp, exp, array_type_nelts (type), init,\n-\t\t       init && same_type_p (TREE_TYPE (init),\n-\t\t\t\t\t    TREE_TYPE (exp)));\n+      stmt_expr = build_vec_init (exp, exp, array_type_nelts (type), init,\n+\t\t\t\t  init && same_type_p (TREE_TYPE (init),\n+\t\t\t\t\t\t       TREE_TYPE (exp)));\n       TREE_READONLY (exp) = was_const;\n       TREE_THIS_VOLATILE (exp) = was_volatile;\n       TREE_TYPE (exp) = type;\n       if (init)\n \tTREE_TYPE (init) = itype;\n-      return;\n+      return stmt_expr;\n     }\n \n   if (TREE_CODE (exp) == VAR_DECL || TREE_CODE (exp) == PARM_DECL)\n     /* just know that we've seen something for this node */\n     TREE_USED (exp) = 1;\n \n-#if 0\n-  /* If initializing from a GNU C CONSTRUCTOR, consider the elts in the\n-     constructor as parameters to an implicit GNU C++ constructor.  */\n-  if (init && TREE_CODE (init) == CONSTRUCTOR\n-      && TYPE_HAS_CONSTRUCTOR (type)\n-      && TREE_TYPE (init) == type)\n-    init = CONSTRUCTOR_ELTS (init);\n-#endif\n-\n   TREE_TYPE (exp) = TYPE_MAIN_VARIANT (type);\n+  begin_init_stmts (&stmt_expr, &compound_stmt);\n+  destroy_temps = stmts_are_full_exprs_p;\n+  stmts_are_full_exprs_p = 0;\n   expand_aggr_init_1 (TYPE_BINFO (type), exp, exp,\n \t\t      init, LOOKUP_NORMAL|flags);\n+  stmt_expr = finish_init_stmts (stmt_expr, compound_stmt);\n+  stmts_are_full_exprs_p = destroy_temps;\n   TREE_TYPE (exp) = type;\n   TREE_READONLY (exp) = was_const;\n   TREE_THIS_VOLATILE (exp) = was_volatile;\n+\n+  return stmt_expr;\n }\n \n static void\n@@ -1199,7 +1196,7 @@ expand_default_init (binfo, true_exp, exp, init, flags)\n       else\n \tinit = build (INIT_EXPR, TREE_TYPE (exp), exp, init);\n       TREE_SIDE_EFFECTS (init) = 1;\n-      expand_expr_stmt (init);\n+      finish_expr_stmt (init);\n       return;\n     }\n \n@@ -1225,7 +1222,7 @@ expand_default_init (binfo, true_exp, exp, init, flags)\n   rval = build_method_call (exp, ctor_identifier,\n \t\t\t    parms, binfo, flags);\n   if (TREE_SIDE_EFFECTS (rval))\n-    expand_expr_stmt (rval);\n+    finish_expr_stmt (rval);\n }\n \n /* This function is responsible for initializing EXP with INIT\n@@ -1271,15 +1268,20 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, flags)\n       && TREE_CODE (init) == CONSTRUCTOR\n       && TREE_HAS_CONSTRUCTOR (init))\n     {\n-      tree t = store_init_value (exp, init);\n-      if (!t)\n+      /* If store_init_value returns NULL_TREE, the INIT has been\n+\t record in the DECL_INITIAL for EXP.  That means there's\n+\t nothing more we have to do.  */\n+      if (!store_init_value (exp, init))\n \t{\n-\t  expand_decl_init (exp);\n-\t  return;\n+\t  if (!building_stmt_tree ())\n+\t    expand_decl_init (exp);\n+\t}\n+      else\n+\t{\n+\t  tree t = build (INIT_EXPR, type, exp, init);\n+\t  TREE_SIDE_EFFECTS (t) = 1;\n+\t  finish_expr_stmt (t);\n \t}\n-      t = build (INIT_EXPR, type, exp, init);\n-      TREE_SIDE_EFFECTS (t) = 1;\n-      expand_expr_stmt (t);\n       return;\n     }\n \n@@ -2689,88 +2691,54 @@ build_vec_delete_1 (base, maxindex, type, auto_delete_vec, auto_delete,\n     return cp_convert (void_type_node, body);\n }\n \n-/* Protect the vector initialization with a try-block so that we can\n-   destroy the first few elements if constructing a later element\n-   causes an exception to be thrown.  TYPE is the type of the array\n-   elements.  */\n-\n-static void\n-expand_vec_init_try_block (type)\n+tree\n+create_temporary_var (type)\n      tree type;\n {\n-  if (!TYPE_NEEDS_DESTRUCTOR (type) || !flag_exceptions)\n-    return;\n-\n-  /* The code we generate looks like:\n-\n-       try {\n-         // Initialize the vector.\n-       } catch (...) {\n-         // Destory the elements that need destroying.\n-\t throw;\n-       } \n-\n-     Here we're just beginning the `try'.  */\n+  tree decl;\n+ \n+  decl = build_decl (VAR_DECL, NULL_TREE, type);\n+  TREE_USED (decl) = 1;\n+  DECL_ARTIFICIAL (decl) = 1;\n+  DECL_SOURCE_FILE (decl) = input_filename;\n+  DECL_SOURCE_LINE (decl) = lineno;\n+  DECL_IGNORED_P (decl) = 1;\n+\n+  if (building_stmt_tree ())\n+    add_decl_stmt (decl);\n+  else\n+    DECL_RTL (decl) = assign_temp (type, 2, 0, 1);\n \n-  expand_eh_region_start ();\n+  return decl;\n }\n \n-/* Add code to destroy the array elements constructed so far if the\n-   construction of some element in the array causes an exception to be\n-   thrown.  RVAL is the address of the last element in the array.\n-   TYPE is the type of the array elements.  MAXINDEX is the maximum\n-   allowable index into the array.  ITERATOR is an integer variable\n-   indicating how many elements remain to be constructed.  */\n+/* Create a new temporary variable of the indicated TYPE, initialized\n+   to INIT.\n \n-static void\n-expand_vec_init_catch_clause (rval, type, maxindex, iterator)\n-     tree rval;\n-     tree type;\n-     tree maxindex;\n-     tree iterator;\n+   It is not entered into current_binding_level, because that breaks\n+   things when it comes time to do final cleanups (which take place\n+   \"outside\" the binding contour of the function).  */\n+\n+static tree\n+get_temp_regvar (type, init)\n+     tree type, init;\n {\n-  tree e;\n-  tree cleanup;\n+  tree decl;\n \n-  if (!TYPE_NEEDS_DESTRUCTOR (type) || !flag_exceptions)\n-    return;\n-    \n-  /* We have to ensure that this can live to the cleanup expansion\n-     time, since we know it is only ever needed once, generate code\n-     now.  */\n-  push_obstacks_nochange ();\n-  resume_temporary_allocation ();\n+  decl = create_temporary_var (type);\n+  DECL_REGISTER (decl) = 1;\n+  finish_expr_stmt (build_modify_expr (decl, INIT_EXPR, init));\n \n-  cleanup = make_node (RTL_EXPR);\n-  TREE_TYPE (cleanup) = void_type_node;\n-  RTL_EXPR_RTL (cleanup) = const0_rtx;\n-  TREE_SIDE_EFFECTS (cleanup) = 1;\n-  do_pending_stack_adjust ();\n-  start_sequence_for_rtl_expr (cleanup);\n-    \n-  e = build_vec_delete_1 (rval,\n-\t\t\t  build_binary_op (MINUS_EXPR, maxindex, \n-\t\t\t\t\t   iterator),\n-\t\t\t  type,\n-\t\t\t  /*auto_delete_vec=*/integer_zero_node,\n-\t\t\t  /*auto_delete=*/integer_zero_node,\n-\t\t\t  /*use_global_delete=*/0);\n-  expand_expr (e, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-  do_pending_stack_adjust ();\n-  RTL_EXPR_SEQUENCE (cleanup) = get_insns ();\n-  end_sequence ();\n-  cleanup = protect_with_terminate (cleanup);\n-  expand_eh_region_end (cleanup);\n-  pop_obstacks ();\n+  return decl;\n }\n \n-/* `expand_vec_init' performs initialization of a vector of aggregate\n-   types.\n+/* `build_vec_init' returns tree structure that performs\n+   initialization of a vector of aggregate types.\n \n    DECL is passed only for error reporting, and provides line number\n    and source file name information.\n-   BASE is the space where the vector will be.\n+   BASE is the space where the vector will be.  For a vector of Ts,\n+     the type of BASE is `T*'.\n    MAXINDEX is the maximum index of the array (one less than the\n \t    number of elements).\n    INIT is the (possibly NULL) initializer.\n@@ -2783,16 +2751,23 @@ expand_vec_init_catch_clause (rval, type, maxindex, iterator)\n    but use assignment instead of initialization.  */\n \n tree\n-expand_vec_init (decl, base, maxindex, init, from_array)\n+build_vec_init (decl, base, maxindex, init, from_array)\n      tree decl, base, maxindex, init;\n      int from_array;\n {\n   tree rval;\n   tree base2 = NULL_TREE;\n-  tree type = TREE_TYPE (TREE_TYPE (base));\n   tree size;\n   tree itype = NULL_TREE;\n   tree iterator;\n+  /* The type of an element in the array.  */\n+  tree type;\n+  /* The type of a pointer to an element in the array.  */\n+  tree ptype;\n+  tree stmt_expr;\n+  tree compound_stmt;\n+  int destroy_temps;\n+  tree try_block;\n   int num_initialized_elts = 0;\n \n   maxindex = cp_convert (ptrdiff_type_node, maxindex);\n@@ -2808,17 +2783,56 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n       return rval;\n     }\n \n+  type = TREE_TYPE (TREE_TYPE (base));\n+  ptype = build_pointer_type (type);\n   size = size_in_bytes (type);\n \n-  base = default_conversion (base);\n-  base = cp_convert (build_pointer_type (type), base);\n-  rval = get_temp_regvar (build_pointer_type (type), base);\n-  base = get_temp_regvar (build_pointer_type (type), base);\n+  /* The code we are generating looks like:\n+\n+       T* t1 = (T*) base;\n+       T* rval = base;\n+       ptrdiff_t iterator = maxindex;\n+       try {\n+         ... initializations from CONSTRUCTOR ...\n+         if (iterator != -1) {\n+\t   do {\n+\t     ... initialize *base ...\n+\t     ++base;\n+\t   } while (--iterator != -1);\n+\t }\n+       } catch (...) {\n+         ... destroy elements that were constructed ...\n+       }\n+       \n+     We can omit the try and catch blocks if we know that the\n+     initialization will never throw an exception, or if the array\n+     elements do not have destructors.  If we have a CONSTRUCTOR to\n+     give us initialization information, we emit code to initialize\n+     each of the elements before the loop in the try block, and then\n+     iterate over fewer elements.  We can omit the loop completely if\n+     the elements of the array do not have constructors.  \n+\n+     We actually wrap the entire body of the above in a STMT_EXPR, for\n+     tidiness.  \n+\n+     When copying from array to another, when the array elements have\n+     only trivial copy constructors, we should use __builtin_memcpy\n+     rather than generating a loop.  That way, we could take advantage\n+     of whatever cleverness the back-end has for dealing with copies\n+     of blocks of memory.  */\n+\n+  begin_init_stmts (&stmt_expr, &compound_stmt);\n+  destroy_temps = stmts_are_full_exprs_p;\n+  stmts_are_full_exprs_p = 0;\n+  rval = get_temp_regvar (ptype, \n+\t\t\t  cp_convert (ptype, default_conversion (base)));\n+  base = get_temp_regvar (ptype, rval);\n   iterator = get_temp_regvar (ptrdiff_type_node, maxindex);\n \n   /* Protect the entire array initialization so that we can destroy\n      the partially constructed array if an exception is thrown.  */\n-  expand_vec_init_try_block (type);\n+  if (flag_exceptions && TYPE_NEEDS_DESTRUCTOR (type))\n+    try_block = begin_try_block ();\n \n   if (init != NULL_TREE && TREE_CODE (init) == CONSTRUCTOR\n       && (!decl || same_type_p (TREE_TYPE (init), TREE_TYPE (decl))))\n@@ -2827,35 +2841,37 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n \t initializers.  */\n \n       tree elts;\n-      tree baseref = build1 (INDIRECT_REF, type, base);\n-\n       from_array = 0;\n \n       for (elts = CONSTRUCTOR_ELTS (init); elts; elts = TREE_CHAIN (elts))\n \t{\n \t  tree elt = TREE_VALUE (elts);\n+\t  tree baseref = build1 (INDIRECT_REF, type, base);\n \n \t  num_initialized_elts++;\n \n \t  if (IS_AGGR_TYPE (type) || TREE_CODE (type) == ARRAY_TYPE)\n-\t    expand_aggr_init (baseref, elt, 0);\n+\t    finish_expr_stmt (build_aggr_init (baseref, elt, 0));\n \t  else\n-\t    expand_assignment (baseref, elt, 0, 0);\n+\t    finish_expr_stmt (build_modify_expr (baseref, NOP_EXPR,\n+\t\t\t\t\t\t elt));\n \n-\t  expand_assignment (base, \n+\t  finish_expr_stmt (build_modify_expr \n+\t\t\t    (base, \n+\t\t\t     NOP_EXPR,\n \t\t\t     build (PLUS_EXPR, build_pointer_type (type),\n-\t\t\t\t    base, size),\n-\t\t\t     0, 0);\n-\t  expand_assignment (iterator,\n+\t\t\t\t    base, size)));\n+\t  finish_expr_stmt (build_modify_expr\n+\t\t\t    (iterator,\n+\t\t\t     NOP_EXPR,\n \t\t\t     build (MINUS_EXPR, ptrdiff_type_node,\n-\t\t\t\t    iterator, integer_one_node),\n-\t\t\t     0, 0);\n+\t\t\t\t    iterator, integer_one_node)));\n \t}\n \n       /* Clear out INIT so that we don't get confused below.  */\n       init = NULL_TREE;\n \n-      if (obey_regdecls)\n+      if (obey_regdecls && !building_stmt_tree ())\n \tuse_variable (DECL_RTL (base));\n     }\n   else if (from_array)\n@@ -2897,15 +2913,33 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n     {\n       /* If the ITERATOR is equal to -1, then we don't have to loop;\n \t we've already initialized all the elements.  */\n-      expand_start_cond (build (NE_EXPR, boolean_type_node,\n-\t\t\t\titerator, minus_one),\n-\t\t\t 0);\n+      tree if_stmt;\n+      tree do_stmt;\n+      tree do_body;\n+      tree elt_init;\n+\n+      if_stmt = begin_if_stmt ();\n+      finish_if_stmt_cond (build (NE_EXPR, boolean_type_node,\n+\t\t\t\t  iterator, minus_one),\n+\t\t\t   if_stmt);\n \n       /* Otherwise, loop through the elements.  */\n-      expand_start_loop_continue_elsewhere (1);\n-  \n-      /* The initialization of each array element is a full-expression.  */\n-      expand_start_target_temps ();\n+      do_stmt = begin_do_stmt ();\n+      do_body = begin_compound_stmt (/*has_no_scope=*/1);\n+\n+      /* When we're not building a statement-tree, things are a little\n+\t complicated.  If, when we recursively call build_aggr_init,\n+\t an expression containing a TARGET_EXPR is expanded, then it\n+\t may get a cleanup.  Then, the result of that expression is\n+\t passed to finish_expr_stmt, which will call\n+\t expand_start_target_temps/expand_end_target_temps.  However,\n+\t the latter call will not cause the cleanup to run because\n+\t that block will still be on the block stack.  So, we call\n+\t expand_start_target_temps here manually; the corresponding\n+\t call to expand_end_target_temps below will cause the cleanup\n+\t to be performed.  */\n+      if (!building_stmt_tree ())\n+\texpand_start_target_temps ();\n \n       if (from_array)\n \t{\n@@ -2918,68 +2952,112 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n \t    from = NULL_TREE;\n \n \t  if (from_array == 2)\n-\t    expand_expr_stmt (build_modify_expr (to, NOP_EXPR, from));\n+\t    elt_init = build_modify_expr (to, NOP_EXPR, from);\n \t  else if (TYPE_NEEDS_CONSTRUCTING (type))\n-\t    expand_aggr_init (to, from, 0);\n+\t    elt_init = build_aggr_init (to, from, 0);\n \t  else if (from)\n-\t    expand_assignment (to, from, 0, 0);\n+\t    elt_init = build_modify_expr (to, NOP_EXPR, from);\n \t  else\n \t    my_friendly_abort (57);\n \t}\n       else if (TREE_CODE (type) == ARRAY_TYPE)\n \t{\n \t  if (init != 0)\n \t    sorry (\"cannot initialize multi-dimensional array with initializer\");\n-\t  expand_vec_init (decl, \n-\t\t\t   build1 (NOP_EXPR, \n-\t\t\t\t   build_pointer_type (TREE_TYPE\n-\t\t\t\t\t\t       (type)),\n-\t\t\t\t   base),\n-\t\t\t   array_type_nelts (type), 0, 0);\n+\t  elt_init = (build_vec_init \n+\t\t      (decl, \n+\t\t       build1 (NOP_EXPR, \n+\t\t\t       build_pointer_type (TREE_TYPE (type)),\n+\t\t\t       base),\n+\t\t       array_type_nelts (type), 0, 0));\n+\t}\n+      else\n+\telt_init = build_aggr_init (build1 (INDIRECT_REF, type, base), \n+\t\t\t\t    init, 0);\n+      \n+      /* The initialization of each array element is a\n+\t full-expression.  */\n+      if (!building_stmt_tree ())\n+\t{\n+\t  finish_expr_stmt (elt_init);\n+\t  expand_end_target_temps ();\n \t}\n       else\n-\texpand_aggr_init (build1 (INDIRECT_REF, type, base), init, 0);\n+\t{\n+\t  stmts_are_full_exprs_p = 1;\n+\t  finish_expr_stmt (elt_init);\n+\t  stmts_are_full_exprs_p = 0;\n+\t}\n \n-      expand_assignment (base,\n+      finish_expr_stmt (build_modify_expr\n+\t\t\t(base,\n+\t\t\t NOP_EXPR,\n \t\t\t build (PLUS_EXPR, build_pointer_type (type), \n-\t\t\t\tbase, size), 0, 0);\n+\t\t\t\tbase, size)));\n       if (base2)\n-\texpand_assignment (base2,\n+\tfinish_expr_stmt (build_modify_expr\n+\t\t\t  (base2,\n+\t\t\t   NOP_EXPR,\n \t\t\t   build (PLUS_EXPR, build_pointer_type (type), \n-\t\t\t\t  base2, size), 0, 0);\n+\t\t\t\t  base2, size)));\n \n-      /* Cleanup any temporaries needed for the initial value.  */\n-      expand_end_target_temps ();\n-  \n-      expand_loop_continue_here ();\n-      expand_exit_loop_if_false (0, build (NE_EXPR, boolean_type_node,\n-\t\t\t\t\t   build (PREDECREMENT_EXPR, \n-\t\t\t\t\t\t  ptrdiff_type_node, \n-\t\t\t\t\t\t  iterator,\n-\t\t\t\t\t\t  integer_one_node), \n-\t\t\t\t\t   minus_one));\n-  \n-      if (obey_regdecls)\n+      if (obey_regdecls && !building_stmt_tree ())\n \t{\n \t  use_variable (DECL_RTL (base));\n \t  if (base2)\n \t    use_variable (DECL_RTL (base2));\n \t}\n \n-      expand_end_loop ();\n-      expand_end_cond ();\n+      finish_compound_stmt (/*has_no_scope=*/1, do_body);\n+      finish_do_body (do_stmt);\n+      finish_do_stmt (build (NE_EXPR, boolean_type_node,\n+\t\t\t     build (PREDECREMENT_EXPR, \n+\t\t\t\t    ptrdiff_type_node, \n+\t\t\t\t    iterator,\n+\t\t\t\t    integer_one_node), \n+\t\t\t     minus_one),\n+\t\t      do_stmt);\n+\n+      finish_then_clause (if_stmt);\n+      finish_if_stmt ();\n     }\n \n   /* Make sure to cleanup any partially constructed elements.  */\n-  expand_vec_init_catch_clause (rval, type, maxindex, iterator);\n+  if (flag_exceptions && TYPE_NEEDS_DESTRUCTOR (type))\n+    {\n+      tree e;\n \n-  if (obey_regdecls)\n+      /* Because CLEANUP will not be processed until later, it must go\n+\t on the temporary obstack.  */\n+      push_obstacks_nochange ();\n+      resume_temporary_allocation ();\n+      /* And MAXINDEX needs to be copied to the current obstack.  It's\n+\t probably on the momentary obstack now.  */\n+      maxindex = mapcar (maxindex, permanent_p);\n+      e = build_vec_delete_1 (rval,\n+\t\t\t      build_binary_op (MINUS_EXPR, maxindex, \n+\t\t\t\t\t       iterator),\n+\t\t\t      type,\n+\t\t\t      /*auto_delete_vec=*/integer_zero_node,\n+\t\t\t      /*auto_delete=*/integer_zero_node,\n+\t\t\t      /*use_global_delete=*/0);\n+      pop_obstacks ();\n+      finish_cleanup (e, try_block);\n+    }\n+\n+  if (obey_regdecls && !building_stmt_tree ())\n     {\n       use_variable (DECL_RTL (iterator));\n       use_variable (DECL_RTL (rval));\n     }\n \n-  return rval;\n+  /* The value of the array initialization is the address of the\n+     first element in the array.  */\n+  finish_expr_stmt (rval);\n+\n+  stmt_expr = finish_init_stmts (stmt_expr, compound_stmt);\n+  stmts_are_full_exprs_p = destroy_temps;\n+  return stmt_expr;\n }\n \n /* Free up storage of type TYPE, at address ADDR."}, {"sha": "ea76855372ececdd26c6e6431e4fc124703334b1", "filename": "gcc/cp/method.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=f1dedc319f5cd88b32fb105ebe73e92283e6ba3a", "patch": "@@ -2177,11 +2177,9 @@ do_build_copy_constructor (fndecl)\n      tree fndecl;\n {\n   tree parm = TREE_CHAIN (DECL_ARGUMENTS (fndecl));\n+  tree compound_stmt;\n   tree t;\n \n-  clear_last_expr ();\n-  push_momentary ();\n-\n   if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n     parm = TREE_CHAIN (parm);\n   parm = convert_from_reference (parm);\n@@ -2194,7 +2192,7 @@ do_build_copy_constructor (fndecl)\n     {\n       t = build (INIT_EXPR, void_type_node, current_class_ref, parm);\n       TREE_SIDE_EFFECTS (t) = 1;\n-      cplus_expand_expr_stmt (t);\n+      finish_expr_stmt (t);\n     }\n   else\n     {\n@@ -2257,18 +2255,18 @@ do_build_copy_constructor (fndecl)\n       setup_vtbl_ptr ();\n     }\n \n-  pop_momentary ();\n+  compound_stmt = begin_compound_stmt (/*has_no_scope=*/0);\n+  finish_compound_stmt (/*has_no_scope=*/0, compound_stmt);\n }\n \n static void\n do_build_assign_ref (fndecl)\n      tree fndecl;\n {\n   tree parm = TREE_CHAIN (DECL_ARGUMENTS (fndecl));\n+  tree compound_stmt;\n \n-  clear_last_expr ();\n-  push_momentary ();\n-\n+  compound_stmt = begin_compound_stmt (/*has_no_scope=*/0);\n   parm = convert_from_reference (parm);\n \n   if (TYPE_HAS_TRIVIAL_ASSIGN_REF (current_class_type)\n@@ -2279,7 +2277,7 @@ do_build_assign_ref (fndecl)\n     {\n       tree t = build (MODIFY_EXPR, void_type_node, current_class_ref, parm);\n       TREE_SIDE_EFFECTS (t) = 1;\n-      cplus_expand_expr_stmt (t);\n+      finish_expr_stmt (t);\n     }\n   else\n     {\n@@ -2353,7 +2351,7 @@ do_build_assign_ref (fndecl)\n \t}\n     }\n   c_expand_return (current_class_ref);\n-  pop_momentary ();\n+  finish_compound_stmt (/*has_no_scope=*/0, compound_stmt);\n }\n \n void\n@@ -2374,6 +2372,7 @@ synthesize_method (fndecl)\n   interface_unknown = 1;\n   start_function (NULL_TREE, fndecl, NULL_TREE, 1);\n   store_parm_decls ();\n+  clear_last_expr ();\n \n   if (DECL_NAME (fndecl) == ansi_opname[MODIFY_EXPR])\n     do_build_assign_ref (fndecl);"}, {"sha": "0c300caa84f9f3e5d169657b3c301f1abec80ae1", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 893, "deletions": 832, "changes": 1725, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=f1dedc319f5cd88b32fb105ebe73e92283e6ba3a"}, {"sha": "56ec7b4099640787bde948c3516a69e0d63f63aa", "filename": "gcc/cp/parse.h", "status": "modified", "additions": 85, "deletions": 85, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.h?ref=f1dedc319f5cd88b32fb105ebe73e92283e6ba3a", "patch": "@@ -1,89 +1,89 @@\n typedef union {long itype; tree ttype; char *strtype; enum tree_code code; flagged_type_tree ftype; } YYSTYPE;\n-#define\tIDENTIFIER\t258\n-#define\tTYPENAME\t259\n-#define\tSELFNAME\t260\n-#define\tPFUNCNAME\t261\n-#define\tSCSPEC\t262\n-#define\tTYPESPEC\t263\n-#define\tCV_QUALIFIER\t264\n-#define\tCONSTANT\t265\n-#define\tSTRING\t266\n-#define\tELLIPSIS\t267\n-#define\tSIZEOF\t268\n-#define\tENUM\t269\n-#define\tIF\t270\n-#define\tELSE\t271\n-#define\tWHILE\t272\n-#define\tDO\t273\n-#define\tFOR\t274\n-#define\tSWITCH\t275\n-#define\tCASE\t276\n-#define\tDEFAULT\t277\n-#define\tBREAK\t278\n-#define\tCONTINUE\t279\n-#define\tRETURN_KEYWORD\t280\n-#define\tGOTO\t281\n-#define\tASM_KEYWORD\t282\n-#define\tTYPEOF\t283\n-#define\tALIGNOF\t284\n-#define\tSIGOF\t285\n-#define\tATTRIBUTE\t286\n-#define\tEXTENSION\t287\n-#define\tLABEL\t288\n-#define\tREALPART\t289\n-#define\tIMAGPART\t290\n-#define\tVA_ARG\t291\n-#define\tAGGR\t292\n-#define\tVISSPEC\t293\n-#define\tDELETE\t294\n-#define\tNEW\t295\n-#define\tTHIS\t296\n-#define\tOPERATOR\t297\n-#define\tCXX_TRUE\t298\n-#define\tCXX_FALSE\t299\n-#define\tNAMESPACE\t300\n-#define\tTYPENAME_KEYWORD\t301\n-#define\tUSING\t302\n-#define\tLEFT_RIGHT\t303\n-#define\tTEMPLATE\t304\n-#define\tTYPEID\t305\n-#define\tDYNAMIC_CAST\t306\n-#define\tSTATIC_CAST\t307\n-#define\tREINTERPRET_CAST\t308\n-#define\tCONST_CAST\t309\n-#define\tSCOPE\t310\n-#define\tEMPTY\t311\n-#define\tPTYPENAME\t312\n-#define\tNSNAME\t313\n-#define\tTHROW\t314\n-#define\tASSIGN\t315\n-#define\tOROR\t316\n-#define\tANDAND\t317\n-#define\tMIN_MAX\t318\n-#define\tEQCOMPARE\t319\n-#define\tARITHCOMPARE\t320\n-#define\tLSHIFT\t321\n-#define\tRSHIFT\t322\n-#define\tPOINTSAT_STAR\t323\n-#define\tDOT_STAR\t324\n-#define\tUNARY\t325\n-#define\tPLUSPLUS\t326\n-#define\tMINUSMINUS\t327\n-#define\tHYPERUNARY\t328\n-#define\tPOINTSAT\t329\n-#define\tTRY\t330\n-#define\tCATCH\t331\n-#define\tPRE_PARSED_FUNCTION_DECL\t332\n-#define\tEXTERN_LANG_STRING\t333\n-#define\tALL\t334\n-#define\tPRE_PARSED_CLASS_DECL\t335\n-#define\tDEFARG\t336\n-#define\tDEFARG_MARKER\t337\n-#define\tTYPENAME_DEFN\t338\n-#define\tIDENTIFIER_DEFN\t339\n-#define\tPTYPENAME_DEFN\t340\n-#define\tEND_OF_LINE\t341\n-#define\tEND_OF_SAVED_INPUT\t342\n+#define\tIDENTIFIER\t257\n+#define\tTYPENAME\t258\n+#define\tSELFNAME\t259\n+#define\tPFUNCNAME\t260\n+#define\tSCSPEC\t261\n+#define\tTYPESPEC\t262\n+#define\tCV_QUALIFIER\t263\n+#define\tCONSTANT\t264\n+#define\tSTRING\t265\n+#define\tELLIPSIS\t266\n+#define\tSIZEOF\t267\n+#define\tENUM\t268\n+#define\tIF\t269\n+#define\tELSE\t270\n+#define\tWHILE\t271\n+#define\tDO\t272\n+#define\tFOR\t273\n+#define\tSWITCH\t274\n+#define\tCASE\t275\n+#define\tDEFAULT\t276\n+#define\tBREAK\t277\n+#define\tCONTINUE\t278\n+#define\tRETURN_KEYWORD\t279\n+#define\tGOTO\t280\n+#define\tASM_KEYWORD\t281\n+#define\tTYPEOF\t282\n+#define\tALIGNOF\t283\n+#define\tSIGOF\t284\n+#define\tATTRIBUTE\t285\n+#define\tEXTENSION\t286\n+#define\tLABEL\t287\n+#define\tREALPART\t288\n+#define\tIMAGPART\t289\n+#define\tVA_ARG\t290\n+#define\tAGGR\t291\n+#define\tVISSPEC\t292\n+#define\tDELETE\t293\n+#define\tNEW\t294\n+#define\tTHIS\t295\n+#define\tOPERATOR\t296\n+#define\tCXX_TRUE\t297\n+#define\tCXX_FALSE\t298\n+#define\tNAMESPACE\t299\n+#define\tTYPENAME_KEYWORD\t300\n+#define\tUSING\t301\n+#define\tLEFT_RIGHT\t302\n+#define\tTEMPLATE\t303\n+#define\tTYPEID\t304\n+#define\tDYNAMIC_CAST\t305\n+#define\tSTATIC_CAST\t306\n+#define\tREINTERPRET_CAST\t307\n+#define\tCONST_CAST\t308\n+#define\tSCOPE\t309\n+#define\tEMPTY\t310\n+#define\tPTYPENAME\t311\n+#define\tNSNAME\t312\n+#define\tTHROW\t313\n+#define\tASSIGN\t314\n+#define\tOROR\t315\n+#define\tANDAND\t316\n+#define\tMIN_MAX\t317\n+#define\tEQCOMPARE\t318\n+#define\tARITHCOMPARE\t319\n+#define\tLSHIFT\t320\n+#define\tRSHIFT\t321\n+#define\tPOINTSAT_STAR\t322\n+#define\tDOT_STAR\t323\n+#define\tUNARY\t324\n+#define\tPLUSPLUS\t325\n+#define\tMINUSMINUS\t326\n+#define\tHYPERUNARY\t327\n+#define\tPOINTSAT\t328\n+#define\tTRY\t329\n+#define\tCATCH\t330\n+#define\tPRE_PARSED_FUNCTION_DECL\t331\n+#define\tEXTERN_LANG_STRING\t332\n+#define\tALL\t333\n+#define\tPRE_PARSED_CLASS_DECL\t334\n+#define\tDEFARG\t335\n+#define\tDEFARG_MARKER\t336\n+#define\tTYPENAME_DEFN\t337\n+#define\tIDENTIFIER_DEFN\t338\n+#define\tPTYPENAME_DEFN\t339\n+#define\tEND_OF_LINE\t340\n+#define\tEND_OF_SAVED_INPUT\t341\n \n \n extern YYSTYPE yylval;"}, {"sha": "7f8c344142d9e837872ee8bb5e8382d3d3ed89cf", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=f1dedc319f5cd88b32fb105ebe73e92283e6ba3a", "patch": "@@ -780,10 +780,6 @@ base_init:\n \t\t  if ($3 == 0)\n \t\t    error (\"no base initializers given following ':'\");\n \t\t  setup_vtbl_ptr ();\n-\t\t  /* Always keep the BLOCK node associated with the outermost\n-\t\t     pair of curley braces of a function.  These are needed\n-\t\t     for correct operation of dwarfout.c.  */\n-\t\t  keep_next_level ();\n \t\t}\n \t;\n \n@@ -1623,10 +1619,6 @@ nodecls:\n \t\t  if (! current_function_parms_stored)\n \t\t    store_parm_decls ();\n \t\t  setup_vtbl_ptr ();\n-\t\t  /* Always keep the BLOCK node associated with the outermost\n-\t\t     pair of curley braces of a function.  These are needed\n-\t\t     for correct operation of dwarfout.c.  */\n-\t\t  keep_next_level ();\n \t\t}\n \t;\n "}, {"sha": "c8e1e60751ee928329c6462fda3e4d6c3b57c5c6", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=f1dedc319f5cd88b32fb105ebe73e92283e6ba3a", "patch": "@@ -7424,12 +7424,17 @@ tsubst_expr (t, args, complain, in_decl)\n       stmt = begin_try_block ();\n       tsubst_expr (TRY_STMTS (t), args, complain, in_decl);\n       finish_try_block (stmt);\n-      {\n-\ttree handler = TRY_HANDLERS (t);\n-\tfor (; handler; handler = TREE_CHAIN (handler))\n-\t  tsubst_expr (handler, args, complain, in_decl);\n-      }\n-      finish_handler_sequence (stmt);\n+      if (CLEANUP_P (t))\n+\tfinish_cleanup (tsubst_expr (TRY_HANDLERS (t), args,\n+\t\t\t\t     complain, in_decl),\n+\t\t\tstmt);\n+      else\n+\t{\n+\t  tree handler = TRY_HANDLERS (t);\n+\t  for (; handler; handler = TREE_CHAIN (handler))\n+\t    tsubst_expr (handler, args, complain, in_decl);\n+\t  finish_handler_sequence (stmt);\n+\t}\n       break;\n \n     case HANDLER:"}, {"sha": "f876272c0a17e346451f4a09a8855239272593c8", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 125, "deletions": 52, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=f1dedc319f5cd88b32fb105ebe73e92283e6ba3a", "patch": "@@ -42,12 +42,27 @@\n    much easier since it will be able to make use of these routines.  */\n \n static void expand_stmts PROTO((tree));\n+static void do_pushlevel PROTO((void));\n+static tree do_poplevel PROTO((void));\n \n /* Non-zero if we should generate RTL for functions that we process.\n    When this is zero, we just accumulate tree structure, without\n    interacting with the back end.  */\n int expanding_p = 1;\n \n+/* Non-zero if we should treat statements as full expressions.  In\n+   particular, this variable is no-zero if at the end of a statement\n+   we should destroy any temporaries created during that statement.\n+   Similarly, if, at the end of a block, we should destroy any local\n+   variables in this block.  Normally, this variable is non-zero,\n+   since those are the normal semantics of C++.\n+\n+   However, in order to represent aggregate initialization code as\n+   tree structure, we use statement-expressions.  The statements\n+   within the statement expression should not result in cleanups being\n+   run until the entire enclosing statement is complete.  */\n+int stmts_are_full_exprs_p = 1;\n+\n /* The type of the last expression-statement we have seen.  This is\n    required because the type of a statement-expression is the type of\n    the last expression statement.  */\n@@ -91,10 +106,18 @@ finish_expr_stmt (expr)\n \t       && lvalue_p (expr))\n \t      || TREE_CODE (TREE_TYPE (expr)) == FUNCTION_TYPE)\n \t    expr = default_conversion (expr);\n+\n+\t  if (stmts_are_full_exprs_p)\n+\t    expand_start_target_temps ();\n+\t    \n \t  cplus_expand_expr_stmt (expr);\n-\t}\n \n-      clear_momentary ();\n+\t  if (stmts_are_full_exprs_p)\n+\t    {\n+\t      expand_end_target_temps ();\n+\t      clear_momentary ();\n+\t    }\n+\t}\n     }\n \n   finish_stmt ();\n@@ -455,7 +478,7 @@ finish_for_stmt (expr, for_stmt)\n       emit_line_note (input_filename, lineno);\n       expand_loop_continue_here ();\n       if (expr) \n-\tcplus_expand_expr_stmt (expr);\n+\tfinish_expr_stmt (expr);\n       expand_end_loop ();\n     }\n \n@@ -647,11 +670,28 @@ finish_try_block (try_block)\n     expand_start_all_catch ();  \n }\n \n+/* Finish an implicitly generated try-block, with a cleanup is given\n+   by CLEANUP.  */\n+\n+void\n+finish_cleanup (cleanup, try_block)\n+     tree cleanup;\n+     tree try_block;\n+{\n+  if (building_stmt_tree ()) \n+    {\n+      TRY_HANDLERS (try_block) = copy_to_permanent (cleanup);\n+      CLEANUP_P (try_block) = 1;\n+    }\n+  else\n+    expand_eh_region_end (protect_with_terminate (cleanup));\n+}\n+\n /* Likewise, for a function-try-block.  */\n \n void\n finish_function_try_block (try_block)\n-     tree try_block;\n+     tree try_block; \n {\n   if (building_stmt_tree ())\n     RECHAIN_STMTS_FROM_LAST (try_block, TRY_STMTS (try_block));\n@@ -673,9 +713,7 @@ finish_handler_sequence (try_block)\n   if (building_stmt_tree ())\n     RECHAIN_STMTS_FROM_CHAIN (try_block, TRY_HANDLERS (try_block));\n   else\n-    {\n-      expand_end_all_catch ();\n-    }\n+    expand_end_all_catch ();\n }\n \n /* Likewise, for a function-try-block.  */\n@@ -762,6 +800,12 @@ begin_compound_stmt (has_no_scope)\n \n   if (!has_no_scope)\n     do_pushlevel ();\n+  else\n+    /* Normally, we try hard to keep the BLOCK for a\n+       statement-expression.  But, if it's a statement-expression with\n+       a scopeless block, there's nothing to keep, and we don't want\n+       to accidentally keep a block *inside* the scopeless block.  */ \n+    keep_next_level (0);\n \n   return r;\n }\n@@ -904,6 +948,23 @@ add_decl_stmt (decl)\n   add_tree (decl_stmt);\n }\n \n+/* We're in a constructor, and have just constructed a a subobject of\n+   *THIS.  CLEANUP is code to run if an exception is thrown before the\n+   end of the current function is reached.   */\n+\n+void \n+finish_subobject (cleanup)\n+     tree cleanup;\n+{\n+  if (building_stmt_tree ())\n+    {\n+      tree r = build_min_nt (SUBOBJECT, cleanup);\n+      add_tree (r);\n+    }\n+  else\n+    add_partial_entry (cleanup);\n+}\n+\n /* Bind a name and initialization to the return value of\n    the current function.  */\n \n@@ -975,36 +1036,43 @@ setup_vtbl_ptr ()\n \t\t  (CTOR_INITIALIZER,\n \t\t   current_member_init_list, current_base_init_list));\n       else\n-\temit_base_init (current_class_type, 0);\n+\temit_base_init (current_class_type);\n     }\n+\n+  /* Always keep the BLOCK node associated with the outermost pair of\n+     curley braces of a function.  These are needed for correct\n+     operation of dwarfout.c.  */\n+  keep_next_level (1);\n }\n \n /* Begin a new scope.  */\n \n-void\n+static void\n do_pushlevel ()\n {\n   if (!building_stmt_tree ())\n     {\n       emit_line_note (input_filename, lineno);\n       clear_last_expr ();\n     }\n-  pushlevel (0);\n   push_momentary ();\n-  if (!building_stmt_tree ())\n+  if (stmts_are_full_exprs_p)\n+    pushlevel (0);\n+  if (!building_stmt_tree () && stmts_are_full_exprs_p)\n     expand_start_bindings (0);\n-}  \n+}\n \n /* Finish a scope.  */\n \n-tree\n+static tree\n do_poplevel ()\n {\n   tree t;\n \n-  if (!building_stmt_tree ())\n+  if (!building_stmt_tree () && stmts_are_full_exprs_p)\n     expand_end_bindings (getdecls (), kept_level_p (), 0);\n-  t = poplevel (kept_level_p (), 1, 0);\n+  if (stmts_are_full_exprs_p)\n+    t = poplevel (kept_level_p (), 1, 0);\n   pop_momentary ();\n   return t;\n }\n@@ -1028,7 +1096,7 @@ finish_parenthesized_expr (expr)\n tree \n begin_stmt_expr ()\n {\n-  keep_next_level ();\n+  keep_next_level (1);\n   /* If we're building a statement tree, then the upcoming compound\n      statement will be chained onto the tree structure, starting at\n      last_tree.  We return last_tree so that we can later unhook the\n@@ -1055,39 +1123,35 @@ finish_stmt_expr (rtl_expr, expr)\n       TREE_SIDE_EFFECTS (rtl_expr) = 1;\n     }\n \n-  if (TREE_CODE (expr) == BLOCK)\n-    {\n-      /* Make a BIND_EXPR for the BLOCK already made.  */\n-      if (building_stmt_tree ())\n-\t{\n-\t  /* If the last thing in the statement-expression was not an\n-\t     expression-statement, then it has type `void'.  */\n-\t  if (!last_expr_type)\n-\t    last_expr_type = void_type_node;\n-\t  result = build_min (STMT_EXPR, last_expr_type, last_tree);\n-\t  /* FIXME: Do we need this?  */\n-\t  TREE_SIDE_EFFECTS (result) = 1;\n-\t}\n-      else\n-\tresult = build (BIND_EXPR, TREE_TYPE (rtl_expr),\n-\t\t\tNULL_TREE, rtl_expr, expr);\n-      \n-      /* Remove the block from the tree at this point.  It gets put\n-\t back at the proper place when the STMT_EXPR or BIND_EXPR is\n-\t expanded.  */\n-      delete_block (expr);\n-    }\n-  else\n-    result = expr;\n-\n   if (building_stmt_tree ())\n     {\n+      /* If the last thing in the statement-expression was not an\n+\t expression-statement, then it has type `void'.  */\n+      if (!last_expr_type)\n+\tlast_expr_type = void_type_node;\n+      result = build_min (STMT_EXPR, last_expr_type, last_tree);\n+      TREE_SIDE_EFFECTS (result) = 1;\n+      \n       /* Remove the compound statement from the tree structure; it is\n \t now saved in the STMT_EXPR.  */\n       last_tree = rtl_expr;\n       TREE_CHAIN (last_tree) = NULL_TREE;\n     }\n-  \n+  else if (expr && TREE_CODE (expr) == BLOCK)\n+    {\n+      result = build (BIND_EXPR, TREE_TYPE (rtl_expr),\n+\t\t      NULL_TREE, rtl_expr, expr);\n+      delete_block (expr);\n+    }\n+  else\n+    result = rtl_expr;\n+\n+  if (expr && TREE_CODE (expr) == BLOCK)\n+    /* Remove the block from the tree at this point.  It gets put back\n+       at the proper place when the STMT_EXPR or BIND_EXPR is\n+       expanded.  */\n+    delete_block (expr);\n+\n   return result;\n }\n \n@@ -2082,11 +2146,20 @@ expand_stmt (t)\n \n     case TRY_BLOCK:\n       lineno = STMT_LINENO (t);\n-      begin_try_block ();\n-      expand_stmt (TRY_STMTS (t));\n-      finish_try_block (NULL_TREE);\n-      expand_stmts (TRY_HANDLERS (t));\n-      finish_handler_sequence (NULL_TREE);\n+      if (CLEANUP_P (t))\n+\t{\n+\t  expand_eh_region_start ();\n+\t  expand_stmt (TRY_STMTS (t));\n+\t  finish_cleanup (TRY_HANDLERS (t), NULL_TREE);\n+\t}\n+      else\n+\t{\n+\t  begin_try_block ();\n+\t  expand_stmt (TRY_STMTS (t));\n+\t  finish_try_block (NULL_TREE);\n+\t  expand_stmts (TRY_HANDLERS (t));\n+\t  finish_handler_sequence (NULL_TREE);\n+\t}\n       break;\n \n     case HANDLER:\n@@ -2105,6 +2178,11 @@ expand_stmt (t)\n       finish_handler (NULL_TREE);\n       break;\n \n+    case SUBOBJECT:\n+      lineno = STMT_LINENO (t);\n+      finish_subobject (SUBOBJECT_CLEANUP (t));\n+      break;\n+\n     default:\n       my_friendly_abort (19990810);\n       break;\n@@ -2168,11 +2246,6 @@ expand_body (fn)\n      base-classes.  */\n   setup_vtbl_ptr ();\n \n-  /* Always keep the BLOCK node associated with the outermost pair of\n-     curly braces of a function.  These are needed for correct\n-     operation of dwarfout.c.  */\n-  keep_next_level ();\n-\n   /* Expand the body.  */\n   expand_stmt (t);\n "}, {"sha": "860dd0fffda3a8f9bb2b347ca79c6cc206ac9d99", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=f1dedc319f5cd88b32fb105ebe73e92283e6ba3a", "patch": "@@ -1656,6 +1656,7 @@ search_tree (t, func)\n     case CALL_EXPR:\n     case COMPOUND_EXPR:\n     case MODIFY_EXPR:\n+    case INIT_EXPR:\n       TRY (TREE_OPERAND (t, 0));\n       TRY (TREE_OPERAND (t, 1));\n       break;\n@@ -1920,6 +1921,7 @@ mapcar (t, func)\n     case WITH_CLEANUP_EXPR:\n     case COMPOUND_EXPR:\n     case MODIFY_EXPR:\n+    case INIT_EXPR:\n       t = copy_node (t);\n       TREE_OPERAND (t, 0) = mapcar (TREE_OPERAND (t, 0), func);\n       TREE_OPERAND (t, 1) = mapcar (TREE_OPERAND (t, 1), func);"}, {"sha": "a6435166fbbc03b5d8498e34bc393df09838dee7", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=f1dedc319f5cd88b32fb105ebe73e92283e6ba3a", "patch": "@@ -5989,32 +5989,11 @@ build_modify_expr (lhs, modifycode, rhs)\n       if (pedantic && ! DECL_ARTIFICIAL (current_function_decl))\n \tpedwarn (\"ANSI C++ forbids assignment of arrays\");\n \n-      /* Have to wrap this in RTL_EXPR for two cases:\n-\t in base or member initialization and if we\n-\t are a branch of a ?: operator.  Since we\n-\t can't easily know the latter, just do it always.  */\n-\n-      result = make_node (RTL_EXPR);\n-\n-      TREE_TYPE (result) = void_type_node;\n-      do_pending_stack_adjust ();\n-      start_sequence_for_rtl_expr (result);\n-\n-      /* As a matter of principle, `start_sequence' should do this.  */\n-      emit_note (0, -1);\n-\n       from_array = TREE_CODE (TREE_TYPE (newrhs)) == ARRAY_TYPE\n \t           ? 1 + (modifycode != INIT_EXPR): 0;\n-      expand_vec_init (lhs, lhs, array_type_nelts (lhstype), newrhs,\n-\t\t       from_array);\n-\n-      do_pending_stack_adjust ();\n-\n-      TREE_SIDE_EFFECTS (result) = 1;\n-      RTL_EXPR_SEQUENCE (result) = get_insns ();\n-      RTL_EXPR_RTL (result) = const0_rtx;\n-      end_sequence ();\n-      return result;\n+      return (build_vec_init\n+\t      (lhs, lhs, array_type_nelts (lhstype), newrhs,\n+\t       from_array));\n     }\n \n   if (modifycode == INIT_EXPR)"}, {"sha": "1e7c40217a6aec1b7e38117d522db10045364042", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=f1dedc319f5cd88b32fb105ebe73e92283e6ba3a", "patch": "@@ -465,7 +465,7 @@ store_init_value (decl, init)\n     ;\n   /* Other code expects that initializers for objects of types that need\n      constructing never make it into DECL_INITIAL, and passes 'init' to\n-     expand_aggr_init without checking DECL_INITIAL.  So just return.  */\n+     build_aggr_init without checking DECL_INITIAL.  So just return.  */\n   else if (TYPE_NEEDS_CONSTRUCTING (type))\n     return value;\n   else if (TREE_STATIC (decl)"}, {"sha": "b7687d3969a00e40365227a2c9729e9891d34779", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash51.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash51.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1dedc319f5cd88b32fb105ebe73e92283e6ba3a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash51.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash51.C?ref=f1dedc319f5cd88b32fb105ebe73e92283e6ba3a", "patch": "@@ -0,0 +1,13 @@\n+// Build don't link:\n+// Special g++ Options: -fno-const-strings\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+char foo[26];\n+\n+template <class T>\n+void f ()\n+{\n+  foo = \"0123456789012345678901234\";  \n+}\n+\n+template void f<int>();"}]}