{"sha": "3155d51bfd1de8b6c4645dcb2292248a8d7cc3c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE1NWQ1MWJmZDFkZThiNmM0NjQ1ZGNiMjI5MjI0OGE4ZDdjYzNjOQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2021-06-16T08:56:09Z"}, "committer": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2021-06-16T08:56:09Z"}, "message": "[PATCH] PR rtl-optimization/46235: Improved use of bt for bit tests on x86_64.\n\nThis patch tackles PR46235 to improve the code generated for bit tests\non x86_64 by making more use of the bt instruction.  Currently, GCC emits\nbt instructions when followed by condition jumps (thanks to Uros' splitters).\nThis patch adds splitters in i386.md, to catch the cases where bt is followed\nby a conditional move (as in the original report), or by a setc/setnc (as in\ncomment 5 of the Bugzilla PR).\n\nWith this patch, the function in the original PR\nint foo(int a, int x, int y) {\n    if (a & (1 << x))\n       return a;\n   return 1;\n}\n\nwhich with -O2 on mainline generates:\nfoo:\tmovl    %edi, %eax\n        movl    %esi, %ecx\n        sarl    %cl, %eax\n        testb   $1, %al\n        movl    $1, %eax\n        cmovne  %edi, %eax\n        ret\n\nnow generates:\nfoo:\tbtl     %esi, %edi\n        movl    $1, %eax\n        cmovc   %edi, %eax\n        ret\n\nLikewise, IsBitSet1 and IsBitSet2 (from comment 5)\nbool IsBitSet1(unsigned char byte, int index) {\n    return (byte & (1<<index)) != 0;\n}\nbool IsBitSet2(unsigned char byte, int index) {\n    return (byte >> index) & 1;\n}\n\nBefore:\n        movzbl  %dil, %eax\n        movl    %esi, %ecx\n        sarl    %cl, %eax\n        andl    $1, %eax\n        ret\n\nAfter:\n        movzbl  %dil, %edi\n        btl     %esi, %edi\n        setc    %al\n        ret\n\nAccording to Agner Fog, SAR/SHR r,cl takes 2 cycles on skylake,\nwhere BT r,r takes only one, so the performance improvements on\nrecent hardware may be more significant than implied by just\nthe reduced number of instructions.  I've avoided transforming cases\n(such as btsi_setcsi) where using bt sequences may not be a clear\nwin (over sarq/andl).\n\n2010-06-15  Roger Sayle  <roger@nextmovesoftware.com>\n\ngcc/ChangeLog\n\tPR rtl-optimization/46235\n\t* config/i386/i386.md: New define_split for bt followed by cmov.\n\t(*bt<mode>_setcqi): New define_insn_and_split for bt followed by setc.\n\t(*bt<mode>_setncqi): New define_insn_and_split for bt then setnc.\n\t(*bt<mode>_setnc<mode>): New define_insn_and_split for bt followed\n\tby setnc with zero extension.\n\ngcc/testsuite/ChangeLog\n\tPR rtl-optimization/46235\n\t* gcc.target/i386/bt-5.c: New test.\n\t* gcc.target/i386/bt-6.c: New test.\n\t* gcc.target/i386/bt-7.c: New test.", "tree": {"sha": "a530c589490aed14c7edac204fa34016f72f1ddd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a530c589490aed14c7edac204fa34016f72f1ddd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3155d51bfd1de8b6c4645dcb2292248a8d7cc3c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3155d51bfd1de8b6c4645dcb2292248a8d7cc3c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3155d51bfd1de8b6c4645dcb2292248a8d7cc3c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3155d51bfd1de8b6c4645dcb2292248a8d7cc3c9/comments", "author": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "041f74177072df1d66502319205990a4d970c92a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/041f74177072df1d66502319205990a4d970c92a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/041f74177072df1d66502319205990a4d970c92a"}], "stats": {"total": 276, "additions": 276, "deletions": 0}, "files": [{"sha": "48532eb7ddf924de257e8f02000afd96013d1942", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3155d51bfd1de8b6c4645dcb2292248a8d7cc3c9/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3155d51bfd1de8b6c4645dcb2292248a8d7cc3c9/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=3155d51bfd1de8b6c4645dcb2292248a8d7cc3c9", "patch": "@@ -12794,6 +12794,100 @@\n   operands[0] = shallow_copy_rtx (operands[0]);\n   PUT_CODE (operands[0], reverse_condition (GET_CODE (operands[0])));\n })\n+\n+;; Help combine recognize bt followed by cmov\n+(define_split\n+  [(set (match_operand:SWI248 0 \"register_operand\")\n+\t(if_then_else:SWI248\n+\t (ne\n+\t  (zero_extract:SWI48\n+\t   (match_operand:SWI48 1 \"register_operand\")\n+\t   (const_int 1)\n+\t   (zero_extend:SI (match_operand:QI 2 \"register_operand\")))\n+\t  (const_int 0))\n+\t (match_operand:SWI248 3 \"nonimmediate_operand\")\n+\t (match_operand:SWI248 4 \"nonimmediate_operand\")))]\n+  \"TARGET_USE_BT && TARGET_CMOVE\n+   && !(MEM_P (operands[3]) && MEM_P (operands[4]))\n+   && ix86_pre_reload_split ()\"\n+  [(set (reg:CCC FLAGS_REG)\n+\t(compare:CCC\n+\t (zero_extract:SWI48 (match_dup 1) (const_int 1) (match_dup 2))\n+\t (const_int 0)))\n+   (set (match_dup 0)\n+\t(if_then_else:SWI248 (eq (reg:CCC FLAGS_REG) (const_int 0))\n+\t\t\t     (match_dup 3)\n+\t\t\t     (match_dup 4)))]\n+{\n+  operands[2] = lowpart_subreg (SImode, operands[2], QImode);\n+})\n+\n+;; Help combine recognize bt followed by setc\n+(define_insn_and_split \"*bt<mode>_setcqi\"\n+  [(set (subreg:SWI48 (match_operand:QI 0 \"register_operand\") 0)\n+        (zero_extract:SWI48\n+         (match_operand:SWI48 1 \"register_operand\")\n+         (const_int 1)\n+         (zero_extend:SI (match_operand:QI 2 \"register_operand\"))))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_USE_BT && ix86_pre_reload_split ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (reg:CCC FLAGS_REG)\n+        (compare:CCC\n+         (zero_extract:SWI48 (match_dup 1) (const_int 1) (match_dup 2))\n+         (const_int 0)))\n+   (set (match_dup 0)\n+        (eq:QI (reg:CCC FLAGS_REG) (const_int 0)))]\n+{\n+  operands[2] = lowpart_subreg (SImode, operands[2], QImode);\n+})\n+\n+;; Help combine recognize bt followed by setnc\n+(define_insn_and_split \"*bt<mode>_setncqi\"\n+  [(set (match_operand:QI 0 \"register_operand\")\n+\t(and:QI\n+\t (not:QI\n+\t  (subreg:QI\n+\t   (lshiftrt:SWI48 (match_operand:SWI48 1 \"register_operand\")\n+\t\t\t   (match_operand:QI 2 \"register_operand\")) 0))\n+\t (const_int 1)))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_USE_BT && ix86_pre_reload_split ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (reg:CCC FLAGS_REG)\n+        (compare:CCC\n+         (zero_extract:SWI48 (match_dup 1) (const_int 1) (match_dup 2))\n+         (const_int 0)))\n+   (set (match_dup 0)\n+        (ne:QI (reg:CCC FLAGS_REG) (const_int 0)))]\n+{\n+  operands[2] = lowpart_subreg (SImode, operands[2], QImode);\n+})\n+\n+(define_insn_and_split \"*bt<mode>_setnc<mode>\"\n+  [(set (match_operand:SWI48 0 \"register_operand\")\n+\t(and:SWI48\n+\t (not:SWI48\n+\t  (lshiftrt:SWI48 (match_operand:SWI48 1 \"register_operand\")\n+\t\t\t  (match_operand:QI 2 \"register_operand\")))\n+\t (const_int 1)))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_USE_BT && ix86_pre_reload_split ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (reg:CCC FLAGS_REG)\n+        (compare:CCC\n+         (zero_extract:SWI48 (match_dup 1) (const_int 1) (match_dup 2))\n+         (const_int 0)))\n+   (set (match_dup 3)\n+        (ne:QI (reg:CCC FLAGS_REG) (const_int 0)))\n+   (set (match_dup 0) (zero_extend:SWI48 (match_dup 3)))]\n+{\n+  operands[2] = lowpart_subreg (SImode, operands[2], QImode);\n+  operands[3] = gen_reg_rtx (QImode);\n+})\n \f\n ;; Store-flag instructions.\n "}, {"sha": "73e7ed282d3c006789a86bdf9fd13847a388eef8", "filename": "gcc/testsuite/gcc.target/i386/bt-5.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3155d51bfd1de8b6c4645dcb2292248a8d7cc3c9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fbt-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3155d51bfd1de8b6c4645dcb2292248a8d7cc3c9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fbt-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fbt-5.c?ref=3155d51bfd1de8b6c4645dcb2292248a8d7cc3c9", "patch": "@@ -0,0 +1,44 @@\n+/* PR rtl-optimization/46235 */\n+/* { dg-do compile { target lp64 } } */\n+/* { dg-options \"-O2 -mtune=core2\" } */\n+\n+int foo (int a, int x, int y)\n+{\n+  if (a & (1<<x))\n+    return a;\n+  return 1;\n+}\n+\n+int bar_ww (int a, int x, int y, int z)\n+{\n+  return (a & (1<<x)) ? y : z;\n+}\n+\n+int bar_lw (long long a, int x, int y, int z)\n+{\n+  return (a & (1LL<<x)) ? y : z;\n+}\n+\n+long long bar_wl (int a, int x, long long y, long long z)\n+{\n+  return (a & (1<<x)) ? y : z;\n+}\n+\n+long long bar_ll (long long a, int x, long long y, long long z)\n+{\n+  return (a & (1LL<<x)) ? y : z;\n+}\n+\n+short bar_ws (int a, int x, short y, short z)\n+{\n+  return (a & (1<<x)) ? y : z;\n+}\n+\n+short bar_ls (long long a, int x, short y, short z)\n+{\n+  return (a & (1LL<<x)) ? y : z;\n+}\n+\n+/* { dg-final { scan-assembler-times \"bt\\[lq\\]\\[ \\t\\]\" 7 } } */\n+/* { dg-final { scan-assembler-not \"sar\\[lq\\]\\[ \\t\\]\" } } */\n+"}, {"sha": "d4ef80589f3aeeda2f3bf75c13be329727ad8519", "filename": "gcc/testsuite/gcc.target/i386/bt-6.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3155d51bfd1de8b6c4645dcb2292248a8d7cc3c9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fbt-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3155d51bfd1de8b6c4645dcb2292248a8d7cc3c9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fbt-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fbt-6.c?ref=3155d51bfd1de8b6c4645dcb2292248a8d7cc3c9", "patch": "@@ -0,0 +1,69 @@\n+/* PR rtl-optimization/46235 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mtune=core2\" } */\n+\n+unsigned char set1_bb (unsigned char x, int y)\n+{\n+  return (x & (1<<y)) != 0;\n+}\n+\n+unsigned char set2_bb (unsigned char x, int y)\n+{\n+  return (x >> y) & 1;\n+}\n+\n+unsigned char set1_wb (int x, int y)\n+{\n+  return (x & (1<<y)) != 0;\n+}\n+\n+unsigned char set2_wb (int x, int y)\n+{\n+  return (x >> y) & 1;\n+}\n+\n+unsigned char clr1_bb (unsigned char x, int y)\n+{\n+  return (x & (1<<y)) == 0;\n+}\n+\n+unsigned char clr2_bb (unsigned char x, int y)\n+{\n+  return !((x >> y) & 1);\n+}\n+\n+unsigned char clr1_wb (int x, int y)\n+{\n+  return (x & (1<<y)) == 0;\n+}\n+\n+unsigned char clr2_wb (int x, int y)\n+{\n+  return !((x >> y) & 1);\n+}\n+\n+int clr1_bw (unsigned char x, int y)\n+{\n+  return (x & (1<<y)) == 0;\n+}\n+\n+int clr2_bw (unsigned char x, int y)\n+{\n+  return !((x >> y) & 1);\n+}\n+\n+int clr1_ww (int x, int y)\n+{\n+  return (x & (1<<y)) == 0;\n+}\n+\n+int clr2_ww (int x, int y)\n+{\n+  return !((x >> y) & 1);\n+}\n+\n+/* { dg-final { scan-assembler-times \"bt\\[lq\\]\\[ \\t\\]\" 12 } } */\n+/* { dg-final { scan-assembler-not \"sar\\[lq\\]\\[ \\t\\]\" } } */\n+/* { dg-final { scan-assembler-not \"and\\[lq\\]\\[ \\t\\]\" } } */\n+/* { dg-final { scan-assembler-not \"not\\[lq\\]\\[ \\t\\]\" } } */\n+"}, {"sha": "292d7414c42a04a8a928dbd16d820b78779c78f1", "filename": "gcc/testsuite/gcc.target/i386/bt-7.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3155d51bfd1de8b6c4645dcb2292248a8d7cc3c9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fbt-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3155d51bfd1de8b6c4645dcb2292248a8d7cc3c9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fbt-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fbt-7.c?ref=3155d51bfd1de8b6c4645dcb2292248a8d7cc3c9", "patch": "@@ -0,0 +1,69 @@\n+/* PR rtl-optimization/46235 */\n+/* { dg-do compile { target lp64 } } */\n+/* { dg-options \"-O2 -mtune=core2\" } */\n+\n+unsigned char set1_lb (long long x, int y)\n+{\n+  return (x & (1LL<<y)) != 0;\n+}\n+\n+unsigned char set2_lb (long long x, int y)\n+{\n+  return (x >> y) & 1;\n+}\n+\n+unsigned char clr1_lb (long long x, int y)\n+{\n+  return (x & (1LL<<y)) == 0;\n+}\n+\n+unsigned char clr2_lb (long long x, int y)\n+{\n+  return !((x >> y) & 1);\n+}\n+\n+int clr1_lw (long long x, int y)\n+{\n+  return (x & (1LL<<y)) == 0;\n+}\n+\n+int clr2_lw (long long x, int y)\n+{\n+  return !((x >> y) & 1);\n+}\n+\n+long long clr1_bl (unsigned char x, int y)\n+{\n+  return (x & (1<<y)) == 0;\n+}\n+\n+long long clr2_bl (unsigned char x, int y)\n+{\n+  return !((x >> y) & 1);\n+}\n+\n+long long clr1_wl (int x, int y)\n+{\n+  return (x & (1<<y)) == 0;\n+}\n+\n+long long clr2_wl (int x, int y)\n+{\n+  return !((x >> y) & 1);\n+}\n+\n+long long clr1_ll (long long x, int y)\n+{\n+  return (x & (1LL<<y)) == 0;\n+}\n+\n+long long clr2_ll (long long x, int y)\n+{\n+  return !((x >> y) & 1);\n+}\n+\n+/* { dg-final { scan-assembler-times \"bt\\[lq\\]\\[ \\t\\]\" 12 } } */\n+/* { dg-final { scan-assembler-not \"sar\\[lq\\]\\[ \\t\\]\" } } */\n+/* { dg-final { scan-assembler-not \"and\\[lq\\]\\[ \\t\\]\" } } */\n+/* { dg-final { scan-assembler-not \"not\\[lq\\]\\[ \\t\\]\" } } */\n+"}]}