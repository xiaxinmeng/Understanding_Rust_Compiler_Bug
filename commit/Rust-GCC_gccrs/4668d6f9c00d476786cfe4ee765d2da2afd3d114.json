{"sha": "4668d6f9c00d476786cfe4ee765d2da2afd3d114", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDY2OGQ2ZjljMDBkNDc2Nzg2Y2ZlNGVlNzY1ZDJkYTJhZmQzZDExNA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2015-07-02T20:39:56Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2015-07-02T20:39:56Z"}, "message": "re PR fortran/52846 ([F2008] Support submodules)\n\n2015-07-02  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/52846\n\t* decl.c (get_proc_name): Make a partially populated interface\n\tsymbol to carry the characteristics of a module procedure and\n\tits result.\n\t(variable_decl): Declarations of dummies or results in the\n\tabreviated form of module procedure is an error.\n\t(gfc_match_import): IMPORT is not permitted in the interface\n\tdeclaration of module procedures.\n\t(match_attr_spec): Submodule variables have implicit save\n\tattribute for F2008 onwards.\n\t(gfc_match_prefix): Add 'module' as the a prefix and set the\n\tmodule_procedure attribute.\n\t(gfc_match_formal_arglist): For a module procedure keep the\n\tinterface formal_arglist from the interface, match new the\n\tformal arguments and then compare the number and names of each.\n\t(gfc_match_procedure): Add case COMP_SUBMODULE.\n\t(gfc_match_function_decl, gfc_match_subroutine_decl): Set the\n\tmodule_procedure attribute.\n\t(gfc_match_entry, gfc_match_end):  Add case COMP_SUBMODULE. If\n\tattr abr_modproc_decl is set, switch the message accordingly\n\tfor subroutines and functions.\n\t(gfc_match_submod_proc): New function to match the abbreviated\n\tstyle of submodule declaration.\n\t* gfortran.h : Add ST_SUBMODULE and ST_END_SUBMODULE. Add the\n\tattribute bits 'used_in_submodule' and 'module_procedure'. Add\n\tthe bit field 'abr_modproc_decl' to gfc_symbol. Add prototypes\n\tfor 'gfc_copy_dummy_sym', 'gfc_check_dummy_characteristics' and\n\t'gfc_check_result_characteristics'.\n\t* interface.c : Add the prefix 'gfc_' to the names of functions\n\t'check_dummy(result)_characteristics' and all their references.\n\t* match.h : Add prototype for 'gfc_match_submod_proc' and\n\t'gfc_match_submodule'.\n\t(check_sym_interfaces): A module procedure is not an error in\n\ta module procedure statment in a generic interface.\n\t* module.c (gfc_match_submodule): New function. Add handling\n\tfor the 'module_procedure' attribute bit.\n\t(gfc_use_module): Make sure that a submodule cannot use itself.\n\t* parse.c (decode_statement): Set attr has_'import_set' for\n\tthe interface declaration of module procedures. Handle a match\n\toccurring in 'gfc_match_submod_proc' and a match for\n\t'submodule'.\n\t(gfc_enclosing_unit): Include the state COMP_SUBMODULE.\n\t(gfc_ascii_statement): Add END SUBMODULE.\n\t(accept_statement): Add ST_SUBMODULE.\n\t(parse_spec): Disallow statement functions in a submodule\n\tspecification part.\n\t(parse_contained): Add ST_END_SUBMODULE and COMP_SUBMODULE\n\ttwice each.\n\t(get_modproc_result): Copy the result symbol of the interface.\n\t(parse_progunit): Call it.\n\t(set_syms_host_assoc): Make symbols from the ancestor module\n\tand submodules use associated, as required by the standard and\n\tset all private components public. Module procedures 'external'\n\tattribute bit is reset and the 'used_in_submodule' bit is set.\n\t(parse_module): If this is a submodule, use the ancestor module\n\tand submodules. Traverse the namespace, calling\n\t'set_syms_host_assoc'. Add ST_END_SUBMODULE and COMP_SUBMODULE.\n\t* parse.h : Add COMP_SUBMODULE.\n\t* primary.c (match_variable): Add COMP_SUBMODULE.\n\t* resolve.c (compare_fsyms): New function to compare the dummy\n\tcharacteristics of a module procedure with its interface.\n\t(resolve_fl_procedure): Compare the procedure, result and dummy\n\tcharacteristics of a module_procedure with its interface, using\n\t'compare_fsyms' for the dummy arguments.\n\t* symbol.c (gfc_add_procedure): Suppress the check for existing\n\tprocedures in the case of a module procedure.\n\t(gfc_add_explicit_interface): Skip checks that must fail for\n\tmodule procedures.\n\t(gfc_add_type): Allow a new type to be added to module\n\tprocedures, their results or their dummy arguments.\n\t(gfc_copy_dummy_sym): New function to generate new dummy args\n\tand copy the characteristics from the interface.\n\t* trans-decl.c (gfc_sym_mangled_function_id): Module procedures\n\tmust always have their names mangled as if they are symbols\n\tcoming from a declaration in a module.\n\t(gfc_get_symbol_decl): Add 'used_in_submodule' to the assert.\n\t(gfc_finish_var_decl): Symbols with the 'used_in_submodule' bit\n\tset are set DECL_EXTERNAL as if they were use associated.\n\n2015-07-02  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/52846\n\t* gfortran.dg/submodule_1.f90: New test\n\t* gfortran.dg/submodule_2.f90: New test\n\t* gfortran.dg/submodule_3.f90: New test\n\t* gfortran.dg/submodule_4.f90: New test\n\t* gfortran.dg/submodule_5.f90: New test\n\t* gfortran.dg/submodule_6.f90: New test\n\t* gfortran.dg/submodule_7.f90: New test\n\nFrom-SVN: r225354", "tree": {"sha": "5c38f5e51f3c8de697f04abf1c7745320daf2110", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c38f5e51f3c8de697f04abf1c7745320daf2110"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4668d6f9c00d476786cfe4ee765d2da2afd3d114", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4668d6f9c00d476786cfe4ee765d2da2afd3d114", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4668d6f9c00d476786cfe4ee765d2da2afd3d114", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4668d6f9c00d476786cfe4ee765d2da2afd3d114/comments", "author": null, "committer": null, "parents": [{"sha": "fbb22910cfa4e4567b46fc8b74ccfad92fa745d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbb22910cfa4e4567b46fc8b74ccfad92fa745d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbb22910cfa4e4567b46fc8b74ccfad92fa745d8"}], "stats": {"total": 1494, "additions": 1444, "deletions": 50}, "files": [{"sha": "d8edfc644ee215f2065d0e319bcc07441c70d502", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 82, "deletions": 1, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4668d6f9c00d476786cfe4ee765d2da2afd3d114", "patch": "@@ -1,3 +1,84 @@\n+2015-07-02  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/52846\n+\t* decl.c (get_proc_name): Make a partially populated interface\n+\tsymbol to carry the characteristics of a module procedure and\n+\tits result.\n+\t(variable_decl): Declarations of dummies or results in the\n+\tabreviated form of module procedure is an error.\n+\t(gfc_match_import): IMPORT is not permitted in the interface\n+\tdeclaration of module procedures.\n+\t(match_attr_spec): Submodule variables have implicit save\n+\tattribute for F2008 onwards.\n+\t(gfc_match_prefix): Add 'module' as the a prefix and set the\n+\tmodule_procedure attribute.\n+\t(gfc_match_formal_arglist): For a module procedure keep the\n+\tinterface formal_arglist from the interface, match new the\n+\tformal arguments and then compare the number and names of each.\n+\t(gfc_match_procedure): Add case COMP_SUBMODULE.\n+\t(gfc_match_function_decl, gfc_match_subroutine_decl): Set the\n+\tmodule_procedure attribute.\n+\t(gfc_match_entry, gfc_match_end):  Add case COMP_SUBMODULE. If\n+\tattr abr_modproc_decl is set, switch the message accordingly\n+\tfor subroutines and functions.\n+\t(gfc_match_submod_proc): New function to match the abbreviated\n+\tstyle of submodule declaration.\n+\t* gfortran.h : Add ST_SUBMODULE and ST_END_SUBMODULE. Add the\n+\tattribute bits 'used_in_submodule' and 'module_procedure'. Add\n+\tthe bit field 'abr_modproc_decl' to gfc_symbol. Add prototypes\n+\tfor 'gfc_copy_dummy_sym', 'gfc_check_dummy_characteristics' and\n+\t'gfc_check_result_characteristics'.\n+\t* interface.c : Add the prefix 'gfc_' to the names of functions\n+\t'check_dummy(result)_characteristics' and all their references.\n+\t* match.h : Add prototype for 'gfc_match_submod_proc' and\n+\t'gfc_match_submodule'.\n+\t(check_sym_interfaces): A module procedure is not an error in\n+\ta module procedure statment in a generic interface.\n+\t* module.c (gfc_match_submodule): New function. Add handling\n+\tfor the 'module_procedure' attribute bit.\n+\t(gfc_use_module): Make sure that a submodule cannot use itself.\n+\t* parse.c (decode_statement): Set attr has_'import_set' for\n+\tthe interface declaration of module procedures. Handle a match\n+\toccurring in 'gfc_match_submod_proc' and a match for\n+\t'submodule'.\n+\t(gfc_enclosing_unit): Include the state COMP_SUBMODULE.\n+\t(gfc_ascii_statement): Add END SUBMODULE.\n+\t(accept_statement): Add ST_SUBMODULE.\n+\t(parse_spec): Disallow statement functions in a submodule\n+\tspecification part.\n+\t(parse_contained): Add ST_END_SUBMODULE and COMP_SUBMODULE\n+\ttwice each.\n+\t(get_modproc_result): Copy the result symbol of the interface.\n+\t(parse_progunit): Call it.\n+\t(set_syms_host_assoc): Make symbols from the ancestor module\n+\tand submodules use associated, as required by the standard and\n+\tset all private components public. Module procedures 'external'\n+\tattribute bit is reset and the 'used_in_submodule' bit is set.\n+\t(parse_module): If this is a submodule, use the ancestor module\n+\tand submodules. Traverse the namespace, calling\n+\t'set_syms_host_assoc'. Add ST_END_SUBMODULE and COMP_SUBMODULE.\n+\t* parse.h : Add COMP_SUBMODULE.\n+\t* primary.c (match_variable): Add COMP_SUBMODULE.\n+\t* resolve.c (compare_fsyms): New function to compare the dummy\n+\tcharacteristics of a module procedure with its interface.\n+\t(resolve_fl_procedure): Compare the procedure, result and dummy\n+\tcharacteristics of a module_procedure with its interface, using\n+\t'compare_fsyms' for the dummy arguments.\n+\t* symbol.c (gfc_add_procedure): Suppress the check for existing\n+\tprocedures in the case of a module procedure.\n+\t(gfc_add_explicit_interface): Skip checks that must fail for\n+\tmodule procedures.\n+\t(gfc_add_type): Allow a new type to be added to module\n+\tprocedures, their results or their dummy arguments.\n+\t(gfc_copy_dummy_sym): New function to generate new dummy args\n+\tand copy the characteristics from the interface.\n+\t* trans-decl.c (gfc_sym_mangled_function_id): Module procedures\n+\tmust always have their names mangled as if they are symbols\n+\tcoming from a declaration in a module.\n+\t(gfc_get_symbol_decl): Add 'used_in_submodule' to the assert.\n+\t(gfc_finish_var_decl): Symbols with the 'used_in_submodule' bit\n+\tset are set DECL_EXTERNAL as if they were use associated.\n+\n 2015-07-02  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/56520\n@@ -98,7 +179,7 @@\n \tthe source expression is an array-constructor which is\n \tfixed to be one-based.\n \t(retrieve_last_ref): Extracted from gfc_array_allocate().\n-\t(gfc_array_allocate): Enable allocate(array, source= \n+\t(gfc_array_allocate): Enable allocate(array, source=\n \tarray_expression) as specified by F2008:C633.\n \t(gfc_conv_expr_descriptor): Add class tree expression\n \tinto the saved descriptor for class arrays."}, {"sha": "04dc7f4d13f2ad52d37df3b074c05293ad3ee77f", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 232, "deletions": 6, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=4668d6f9c00d476786cfe4ee765d2da2afd3d114", "patch": "@@ -903,7 +903,35 @@ get_proc_name (const char *name, gfc_symbol **result, bool module_fcn_entry)\n \n   sym = *result;\n \n-  if (sym && !sym->gfc_new && gfc_current_state () != COMP_INTERFACE)\n+  if (sym->attr.module_procedure\n+      && sym->attr.if_source == IFSRC_IFBODY)\n+    {\n+      /* Create a partially populated interface symbol to carry the\n+\t characteristics of the procedure and the result.  */\n+      sym->ts.interface = gfc_new_symbol (name, sym->ns);\n+      gfc_add_type (sym->ts.interface, &(sym->ts),\n+\t\t    &gfc_current_locus);\n+      gfc_copy_attr (&sym->ts.interface->attr, &sym->attr, NULL);\n+      if (sym->attr.dimension)\n+\tsym->ts.interface->as = gfc_copy_array_spec (sym->as);\n+\n+      /* Ideally, at this point, a copy would be made of the formal\n+\t arguments and their namespace. However, this does not appear\n+\t to be necessary, albeit at the expense of not being able to\n+\t use gfc_compare_interfaces directly.  */\n+\n+      if (sym->result && sym->result != sym)\n+\t{\n+\t  sym->ts.interface->result = sym->result;\n+\t  sym->result = NULL;\n+\t}\n+      else if (sym->result)\n+\t{\n+\t  sym->ts.interface->result = sym->ts.interface;\n+\t}\n+    }\n+  else if (sym && !sym->gfc_new\n+\t   && gfc_current_state () != COMP_INTERFACE)\n     {\n       /* Trap another encompassed procedure with the same name.  All\n \t these conditions are necessary to avoid picking up an entry\n@@ -1918,6 +1946,23 @@ variable_decl (int elem)\n \t}\n     }\n \n+  /* The dummy arguments and result of the abreviated form of MODULE\n+     PROCEDUREs, used in SUBMODULES should not be redefined.  */\n+  if (gfc_current_ns->proc_name\n+      && gfc_current_ns->proc_name->abr_modproc_decl)\n+    {\n+      gfc_find_symbol (name, gfc_current_ns, 1, &sym);\n+      if (sym != NULL && (sym->attr.dummy || sym->attr.result))\n+\t{\n+\t  m = MATCH_ERROR;\n+\t  gfc_error (\"'%s' at %C is a redefinition of the declaration \"\n+\t\t     \"in the corresponding interface for MODULE \"\n+\t\t     \"PROCEDURE '%s'\", sym->name,\n+\t\t     gfc_current_ns->proc_name->name);\n+\t  goto cleanup;\n+\t}\n+    }\n+\n   /*  If this symbol has already shown up in a Cray Pointer declaration,\n       and this is not a component declaration,\n       then we want to set the type & bail out.  */\n@@ -3262,6 +3307,13 @@ gfc_match_import (void)\n       return MATCH_ERROR;\n     }\n \n+  if (gfc_current_ns->proc_name->attr.module_procedure)\n+    {\n+      gfc_error (\"F2008: C1210 IMPORT statement at %C is not permitted \"\n+\t\t \"in a module procedure interface body\");\n+      return MATCH_ERROR;\n+    }\n+\n   if (!gfc_notify_std (GFC_STD_F2003, \"IMPORT statement at %C\"))\n     return MATCH_ERROR;\n \n@@ -3925,7 +3977,9 @@ match_attr_spec (void)\n     }\n \n   /* Since Fortran 2008 module variables implicitly have the SAVE attribute.  */\n-  if (gfc_current_state () == COMP_MODULE && !current_attr.save\n+  if ((gfc_current_state () == COMP_MODULE\n+       || gfc_current_state () == COMP_SUBMODULE)\n+      && !current_attr.save\n       && (gfc_option.allow_std & GFC_STD_F2008) != 0)\n     current_attr.save = SAVE_IMPLICIT;\n \n@@ -4513,6 +4567,22 @@ gfc_match_prefix (gfc_typespec *ts)\n \n   /* At this point, the next item is not a prefix.  */\n   gcc_assert (gfc_matching_prefix);\n+\n+  /* MODULE should be the last prefix before FUNCTION or SUBROUTINE.\n+     Since this is a prefix like PURE, ELEMENTAL, etc., having a\n+     corresponding attribute seems natural and distinguishes these\n+     procedures from procedure types of PROC_MODULE, which these are\n+     as well.  */\n+  if ((gfc_current_state () == COMP_INTERFACE\n+       || gfc_current_state () == COMP_CONTAINS)\n+      && gfc_match (\"module% \") == MATCH_YES)\n+    {\n+      if (!gfc_notify_std (GFC_STD_F2008, \"MODULE prefix at %C\"))\n+\tgoto error;\n+      else\n+\tcurrent_attr.module_procedure = 1;\n+    }\n+\n   gfc_matching_prefix = false;\n   return MATCH_YES;\n \n@@ -4550,9 +4620,24 @@ gfc_match_formal_arglist (gfc_symbol *progname, int st_flag, int null_flag)\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_symbol *sym;\n   match m;\n+  gfc_formal_arglist *formal = NULL;\n \n   head = tail = NULL;\n \n+  /* Keep the interface formal argument list and null it so that the\n+     matching for the new declaration can be done.  The numbers and\n+     names of the arguments are checked here. The interface formal\n+     arguments are retained in formal_arglist and the characteristics\n+     are compared in resolve.c(resolve_fl_procedure).  See the remark\n+     in get_proc_name about the eventual need to copy the formal_arglist\n+     and populate the formal namespace of the interface symbol.  */\n+  if (progname->attr.module_procedure\n+      && progname->attr.host_assoc)\n+    {\n+      formal = progname->formal;\n+      progname->formal = NULL;\n+    }\n+\n   if (gfc_match_char ('(') != MATCH_YES)\n     {\n       if (null_flag)\n@@ -4658,6 +4743,24 @@ gfc_match_formal_arglist (gfc_symbol *progname, int st_flag, int null_flag)\n       goto cleanup;\n     }\n \n+  if (formal)\n+    {\n+      for (p = formal, q = head; p && q; p = p->next, q = q->next)\n+\t{\n+\t  if ((p->next != NULL && q->next == NULL)\n+\t      || (p->next == NULL && q->next != NULL))\n+\t    gfc_error_now (\"Mismatch in number of MODULE PROCEDURE \"\n+\t\t           \"formal arguments at %C\");\n+\t  else if ((p->sym == NULL && q->sym == NULL)\n+\t\t    || strcmp (p->sym->name, q->sym->name) == 0)\n+\t    continue;\n+\t  else\n+\t    gfc_error_now (\"Mismatch in MODULE PROCEDURE formal \"\n+\t\t\t   \"argument names (%s/%s) at %C\",\n+\t\t\t   p->sym->name, q->sym->name);\n+\t}\n+    }\n+\n   return MATCH_YES;\n \n cleanup:\n@@ -5271,6 +5374,7 @@ gfc_match_procedure (void)\n     case COMP_NONE:\n     case COMP_PROGRAM:\n     case COMP_MODULE:\n+    case COMP_SUBMODULE:\n     case COMP_SUBROUTINE:\n     case COMP_FUNCTION:\n     case COMP_BLOCK:\n@@ -5309,7 +5413,8 @@ do_warn_intrinsic_shadow (const gfc_symbol* sym, bool func)\n   bool in_module;\n \n   in_module = (gfc_state_stack->previous\n-\t       && gfc_state_stack->previous->state == COMP_MODULE);\n+\t       && (gfc_state_stack->previous->state == COMP_MODULE\n+\t\t   || gfc_state_stack->previous->state == COMP_SUBMODULE));\n \n   gfc_warn_intrinsic_shadow (sym, in_module, func);\n }\n@@ -5348,12 +5453,16 @@ gfc_match_function_decl (void)\n       gfc_current_locus = old_loc;\n       return MATCH_NO;\n     }\n+\n   if (get_proc_name (name, &sym, false))\n     return MATCH_ERROR;\n \n   if (add_hidden_procptr_result (sym))\n     sym = sym->result;\n \n+  if (current_attr.module_procedure)\n+    sym->attr.module_procedure = 1;\n+\n   gfc_new_block = sym;\n \n   m = gfc_match_formal_arglist (sym, 0, 0);\n@@ -5547,6 +5656,9 @@ gfc_match_entry (void)\n \t  case COMP_MODULE:\n \t    gfc_error (\"ENTRY statement at %C cannot appear within a MODULE\");\n \t    break;\n+\t  case COMP_SUBMODULE:\n+\t    gfc_error (\"ENTRY statement at %C cannot appear within a SUBMODULE\");\n+\t    break;\n \t  case COMP_BLOCK_DATA:\n \t    gfc_error (\"ENTRY statement at %C cannot appear within \"\n \t\t       \"a BLOCK DATA\");\n@@ -5791,6 +5903,9 @@ gfc_match_subroutine (void)\n      the symbol existed before.  */\n   sym->declared_at = gfc_current_locus;\n \n+  if (current_attr.module_procedure)\n+    sym->attr.module_procedure = 1;\n+\n   if (add_hidden_procptr_result (sym))\n     sym = sym->result;\n \n@@ -6114,6 +6229,7 @@ gfc_match_end (gfc_statement *st)\n   match m;\n   gfc_namespace *parent_ns, *ns, *prev_ns;\n   gfc_namespace **nsp;\n+  bool abreviated_modproc_decl;\n \n   old_loc = gfc_current_locus;\n   if (gfc_match (\"end\") != MATCH_YES)\n@@ -6142,6 +6258,10 @@ gfc_match_end (gfc_statement *st)\n       break;\n     }\n \n+  abreviated_modproc_decl\n+\t= gfc_current_block ()\n+\t  && gfc_current_block ()->abr_modproc_decl;\n+\n   switch (state)\n     {\n     case COMP_NONE:\n@@ -6153,13 +6273,19 @@ gfc_match_end (gfc_statement *st)\n \n     case COMP_SUBROUTINE:\n       *st = ST_END_SUBROUTINE;\n+      if (!abreviated_modproc_decl)\n       target = \" subroutine\";\n+      else\n+\ttarget = \" procedure\";\n       eos_ok = !contained_procedure ();\n       break;\n \n     case COMP_FUNCTION:\n       *st = ST_END_FUNCTION;\n+      if (!abreviated_modproc_decl)\n       target = \" function\";\n+      else\n+\ttarget = \" procedure\";\n       eos_ok = !contained_procedure ();\n       break;\n \n@@ -6175,6 +6301,12 @@ gfc_match_end (gfc_statement *st)\n       eos_ok = 1;\n       break;\n \n+    case COMP_SUBMODULE:\n+      *st = ST_END_SUBMODULE;\n+      target = \" submodule\";\n+      eos_ok = 1;\n+      break;\n+\n     case COMP_INTERFACE:\n       *st = ST_END_INTERFACE;\n       target = \" interface\";\n@@ -6259,7 +6391,8 @@ gfc_match_end (gfc_statement *st)\n \t{\n \t  if (!gfc_notify_std (GFC_STD_F2008, \"END statement \"\n \t\t\t       \"instead of %s statement at %L\", \n-\t\t\t       gfc_ascii_statement(*st), &old_loc))\n+\t\t\t       abreviated_modproc_decl ? \"END PROCEDURE\"\n+\t\t\t       : gfc_ascii_statement(*st), &old_loc))\n \t    goto cleanup;\n \t}\n       else if (!eos_ok)\n@@ -6276,8 +6409,8 @@ gfc_match_end (gfc_statement *st)\n   /* Verify that we've got the sort of end-block that we're expecting.  */\n   if (gfc_match (target) != MATCH_YES)\n     {\n-      gfc_error (\"Expecting %s statement at %L\", gfc_ascii_statement (*st),\n-\t\t &old_loc);\n+      gfc_error (\"Expecting %s statement at %L\", abreviated_modproc_decl\n+\t\t ? \"END PROCEDURE\" : gfc_ascii_statement(*st), &old_loc);\n       goto cleanup;\n     }\n \n@@ -7417,6 +7550,99 @@ gfc_match_asynchronous (void)\n }\n \n \n+/* Match a module procedure statement in a submodule.  */\n+\n+match\n+gfc_match_submod_proc (void)\n+{\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n+  gfc_symbol *sym, *fsym;\n+  match m;\n+  gfc_formal_arglist *formal, *head, *tail;\n+\n+  if (gfc_current_state () != COMP_CONTAINS\n+      || !(gfc_state_stack->previous\n+\t   && gfc_state_stack->previous->state == COMP_SUBMODULE))\n+    return MATCH_NO;\n+\n+  m = gfc_match (\" module% procedure% %n\", name);\n+  if (m != MATCH_YES)\n+    return m;\n+\n+  if (!gfc_notify_std (GFC_STD_F2008, \"MODULE PROCEDURE declaration \"\n+\t\t\t\t      \"at %C\"))\n+    return MATCH_ERROR;\n+\n+  if (get_proc_name (name, &sym, false))\n+    return MATCH_ERROR;\n+\n+  /* Make sure that the result field is appropriately filled, even though\n+     the result symbol will be replaced later on.  */\n+  if (sym->ts.interface->attr.function)\n+    {\n+      if (sym->ts.interface->result\n+\t  && sym->ts.interface->result != sym->ts.interface)\n+\tsym->result= sym->ts.interface->result;\n+      else\n+\tsym->result = sym;\n+    }\n+\n+  /* Set declared_at as it might point to, e.g., a PUBLIC statement, if\n+     the symbol existed before.  */\n+  sym->declared_at = gfc_current_locus;\n+\n+  if (!sym->attr.module_procedure)\n+    return MATCH_ERROR;\n+\n+  /* Signal match_end to expect \"end procedure\".  */\n+  sym->abr_modproc_decl = 1;\n+\n+  /* Change from IFSRC_IFBODY coming from the interface declaration.  */\n+  sym->attr.if_source = IFSRC_DECL;\n+\n+  gfc_new_block = sym;\n+\n+  /* Make a new formal arglist with the symbols in the procedure\n+      namespace.  */\n+  head = tail = NULL;\n+  for (formal = sym->formal; formal && formal->sym; formal = formal->next)\n+    {\n+      if (formal == sym->formal)\n+\thead = tail = gfc_get_formal_arglist ();\n+      else\n+\t{\n+\t  tail->next = gfc_get_formal_arglist ();\n+\t  tail = tail->next;\n+\t}\n+\n+      if (gfc_copy_dummy_sym (&fsym, formal->sym, 0))\n+\tgoto cleanup;\n+\n+      tail->sym = fsym;\n+      gfc_set_sym_referenced (fsym);\n+    }\n+\n+  /* The dummy symbols get cleaned up, when the formal_namespace of the\n+     interface declaration is cleared.  This allows us to add the\n+     explicit interface as is done for other type of procedure.  */\n+  if (!gfc_add_explicit_interface (sym, IFSRC_DECL, head,\n+\t\t\t\t   &gfc_current_locus))\n+    return MATCH_ERROR;\n+\n+  if (gfc_match_eos () != MATCH_YES)\n+    {\n+      gfc_syntax_error (ST_MODULE_PROC);\n+      return MATCH_ERROR;\n+    }\n+\n+  return MATCH_YES;\n+\n+cleanup:\n+  gfc_free_formal_arglist (head);\n+  return MATCH_ERROR;\n+}\n+\n+\n /* Match a module procedure statement.  Note that we have to modify\n    symbols in the parent's namespace because the current one was there\n    to receive symbols that are in an interface's formal argument list.  */"}, {"sha": "cd0ec885b378f2074cb3360d0d425e2866d502fc", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=4668d6f9c00d476786cfe4ee765d2da2afd3d114", "patch": "@@ -201,19 +201,19 @@ typedef enum\n   ST_CALL, ST_CASE, ST_CLOSE, ST_COMMON, ST_CONTINUE, ST_CONTAINS, ST_CYCLE,\n   ST_DATA, ST_DATA_DECL, ST_DEALLOCATE, ST_DO, ST_ELSE, ST_ELSEIF,\n   ST_ELSEWHERE, ST_END_ASSOCIATE, ST_END_BLOCK, ST_END_BLOCK_DATA,\n-  ST_ENDDO, ST_IMPLIED_ENDDO,\n-  ST_END_FILE, ST_FINAL, ST_FLUSH, ST_END_FORALL, ST_END_FUNCTION, ST_ENDIF,\n-  ST_END_INTERFACE, ST_END_MODULE, ST_END_PROGRAM, ST_END_SELECT,\n-  ST_END_SUBROUTINE, ST_END_WHERE, ST_END_TYPE, ST_ENTRY, ST_EQUIVALENCE,\n-  ST_ERROR_STOP, ST_EXIT, ST_FORALL, ST_FORALL_BLOCK, ST_FORMAT, ST_FUNCTION,\n-  ST_GOTO, ST_IF_BLOCK, ST_IMPLICIT, ST_IMPLICIT_NONE, ST_IMPORT,\n-  ST_INQUIRE, ST_INTERFACE, ST_SYNC_ALL, ST_SYNC_MEMORY, ST_SYNC_IMAGES,\n-  ST_PARAMETER, ST_MODULE, ST_MODULE_PROC, ST_NAMELIST, ST_NULLIFY, ST_OPEN,\n-  ST_PAUSE, ST_PRIVATE, ST_PROGRAM, ST_PUBLIC, ST_READ, ST_RETURN, ST_REWIND,\n-  ST_STOP, ST_SUBROUTINE, ST_TYPE, ST_USE, ST_WHERE_BLOCK, ST_WHERE, ST_WAIT,\n-  ST_WRITE, ST_ASSIGNMENT, ST_POINTER_ASSIGNMENT, ST_SELECT_CASE, ST_SEQUENCE,\n-  ST_SIMPLE_IF, ST_STATEMENT_FUNCTION, ST_DERIVED_DECL, ST_LABEL_ASSIGNMENT,\n-  ST_ENUM, ST_ENUMERATOR, ST_END_ENUM, ST_SELECT_TYPE, ST_TYPE_IS, ST_CLASS_IS,\n+  ST_ENDDO, ST_IMPLIED_ENDDO, ST_END_FILE, ST_FINAL, ST_FLUSH, ST_END_FORALL,\n+  ST_END_FUNCTION, ST_ENDIF, ST_END_INTERFACE, ST_END_MODULE, ST_END_SUBMODULE,\n+  ST_END_PROGRAM, ST_END_SELECT, ST_END_SUBROUTINE, ST_END_WHERE, ST_END_TYPE,\n+  ST_ENTRY, ST_EQUIVALENCE, ST_ERROR_STOP, ST_EXIT, ST_FORALL, ST_FORALL_BLOCK,\n+  ST_FORMAT, ST_FUNCTION, ST_GOTO, ST_IF_BLOCK, ST_IMPLICIT, ST_IMPLICIT_NONE,\n+  ST_IMPORT, ST_INQUIRE, ST_INTERFACE, ST_SYNC_ALL, ST_SYNC_MEMORY,\n+  ST_SYNC_IMAGES, ST_PARAMETER, ST_MODULE, ST_SUBMODULE, ST_MODULE_PROC,\n+  ST_NAMELIST, ST_NULLIFY, ST_OPEN, ST_PAUSE, ST_PRIVATE, ST_PROGRAM, ST_PUBLIC,\n+  ST_READ, ST_RETURN, ST_REWIND, ST_STOP, ST_SUBROUTINE, ST_TYPE, ST_USE,\n+  ST_WHERE_BLOCK, ST_WHERE, ST_WAIT, ST_WRITE, ST_ASSIGNMENT,\n+  ST_POINTER_ASSIGNMENT, ST_SELECT_CASE, ST_SEQUENCE, ST_SIMPLE_IF,\n+  ST_STATEMENT_FUNCTION, ST_DERIVED_DECL, ST_LABEL_ASSIGNMENT, ST_ENUM,\n+  ST_ENUMERATOR, ST_END_ENUM, ST_SELECT_TYPE, ST_TYPE_IS, ST_CLASS_IS,\n   ST_OACC_PARALLEL_LOOP, ST_OACC_END_PARALLEL_LOOP, ST_OACC_PARALLEL,\n   ST_OACC_END_PARALLEL, ST_OACC_KERNELS, ST_OACC_END_KERNELS, ST_OACC_DATA,\n   ST_OACC_END_DATA, ST_OACC_HOST_DATA, ST_OACC_END_HOST_DATA, ST_OACC_LOOP,\n@@ -751,6 +751,9 @@ typedef struct\n   unsigned data:1,\t\t/* Symbol is named in a DATA statement.  */\n     is_protected:1,\t\t/* Symbol has been marked as protected.  */\n     use_assoc:1,\t\t/* Symbol has been use-associated.  */\n+    used_in_submodule:1,\t/* Symbol has been use-associated in a\n+\t\t\t\t   submodule. Needed since these entities must\n+\t\t\t\t   be set host associated to be compliant.  */\n     use_only:1,\t\t\t/* Symbol has been use-associated, with ONLY.  */\n     use_rename:1,\t\t/* Symbol has been use-associated and renamed.  */\n     imported:1,\t\t\t/* Symbol has been associated by IMPORT.  */\n@@ -779,6 +782,11 @@ typedef struct\n   unsigned sequence:1, elemental:1, pure:1, recursive:1;\n   unsigned unmaskable:1, masked:1, contained:1, mod_proc:1, abstract:1;\n \n+  /* Set if this is a module function or subroutine. Note that it is an\n+     attribute because it appears as a prefix in the declaration like\n+     PURE, etc..  */\n+  unsigned module_procedure:1;\n+\n   /* Set if a (public) symbol [e.g. generic name] exposes this symbol,\n      which is relevant for private module procedures.  */\n   unsigned public_used:1;\n@@ -1459,6 +1467,9 @@ typedef struct gfc_symbol\n   unsigned forall_index:1;\n   /* Used to avoid multiple resolutions of a single symbol.  */\n   unsigned resolved:1;\n+  /* Set if this is a module function or subroutine with the\n+     abreviated declaration in a submodule.  */\n+  unsigned abr_modproc_decl:1;\n \n   int refs;\n   struct gfc_namespace *ns;\t/* namespace containing this symbol */\n@@ -2786,7 +2797,7 @@ bool gfc_add_type (gfc_symbol *, gfc_typespec *, locus *);\n void gfc_clear_attr (symbol_attribute *);\n bool gfc_missing_attr (symbol_attribute *, locus *);\n bool gfc_copy_attr (symbol_attribute *, symbol_attribute *, locus *);\n-\n+int gfc_copy_dummy_sym (gfc_symbol **, gfc_symbol *, int);\n bool gfc_add_component (gfc_symbol *, const char *, gfc_component **);\n gfc_symbol *gfc_use_derived (gfc_symbol *);\n gfc_symtree *gfc_use_derived_tree (gfc_symtree *);\n@@ -3087,6 +3098,10 @@ bool gfc_ref_dimen_size (gfc_array_ref *, int dimen, mpz_t *, mpz_t *);\n void gfc_free_interface (gfc_interface *);\n int gfc_compare_derived_types (gfc_symbol *, gfc_symbol *);\n int gfc_compare_types (gfc_typespec *, gfc_typespec *);\n+bool gfc_check_dummy_characteristics (gfc_symbol *, gfc_symbol *,\n+\t\t\t\t      bool, char *, int);\n+bool gfc_check_result_characteristics (gfc_symbol *, gfc_symbol *,\n+\t\t\t\t       char *, int);\n int gfc_compare_interfaces (gfc_symbol*, gfc_symbol*, const char *, int, int,\n \t\t\t    char *, int, const char *, const char *);\n void gfc_check_interfaces (gfc_namespace *);"}, {"sha": "59569347789546b10ebd38e05e8ba362f45ace67", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=4668d6f9c00d476786cfe4ee765d2da2afd3d114", "patch": "@@ -1066,9 +1066,10 @@ symbol_rank (gfc_symbol *sym)\n /* Check if the characteristics of two dummy arguments match,\n    cf. F08:12.3.2.  */\n \n-static bool\n-check_dummy_characteristics (gfc_symbol *s1, gfc_symbol *s2,\n-\t\t\t     bool type_must_agree, char *errmsg, int err_len)\n+bool\n+gfc_check_dummy_characteristics (gfc_symbol *s1, gfc_symbol *s2,\n+\t\t\t\t bool type_must_agree, char *errmsg,\n+\t\t\t\t int err_len)\n {\n   if (s1 == NULL || s2 == NULL)\n     return s1 == s2 ? true : false;\n@@ -1275,8 +1276,8 @@ check_dummy_characteristics (gfc_symbol *s1, gfc_symbol *s2,\n /* Check if the characteristics of two function results match,\n    cf. F08:12.3.3.  */\n \n-static bool\n-check_result_characteristics (gfc_symbol *s1, gfc_symbol *s2,\n+bool\n+gfc_check_result_characteristics (gfc_symbol *s1, gfc_symbol *s2,\n \t\t\t      char *errmsg, int err_len)\n {\n   gfc_symbol *r1, *r2;\n@@ -1472,8 +1473,8 @@ gfc_compare_interfaces (gfc_symbol *s1, gfc_symbol *s2, const char *name2,\n       if (s1->attr.function && s2->attr.function)\n \t{\n \t  /* If both are functions, check result characteristics.  */\n-\t  if (!check_result_characteristics (s1, s2, errmsg, err_len)\n-\t      || !check_result_characteristics (s2, s1, errmsg, err_len))\n+\t  if (!gfc_check_result_characteristics (s1, s2, errmsg, err_len)\n+\t      || !gfc_check_result_characteristics (s2, s1, errmsg, err_len))\n \t    return 0;\n \t}\n \n@@ -1533,7 +1534,7 @@ gfc_compare_interfaces (gfc_symbol *s1, gfc_symbol *s2, const char *name2,\n \tif (strict_flag)\n \t  {\n \t    /* Check all characteristics.  */\n-\t    if (!check_dummy_characteristics (f1->sym, f2->sym, true, \n+\t    if (!gfc_check_dummy_characteristics (f1->sym, f2->sym, true,\n \t\t\t\t\t      errmsg, err_len))\n \t      return 0;\n \t  }\n@@ -1710,6 +1711,7 @@ check_sym_interfaces (gfc_symbol *sym)\n       for (p = sym->generic; p; p = p->next)\n \t{\n \t  if (p->sym->attr.mod_proc\n+\t      && !p->sym->attr.module_procedure\n \t      && (p->sym->attr.if_source != IFSRC_DECL\n \t\t  || p->sym->attr.procedure))\n \t    {\n@@ -4241,8 +4243,8 @@ gfc_check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n \t  return false;\n \t}\n \n-      if (!check_result_characteristics (proc_target, old_target, err, \n-\t\t\t\t\t sizeof(err)))\n+      if (!gfc_check_result_characteristics (proc_target, old_target,\n+\t\t\t\t\t     err, sizeof(err)))\n \t{\n \t  gfc_error (\"Result mismatch for the overriding procedure \"\n \t\t     \"%qs at %L: %s\", proc->name, &where, err);\n@@ -4293,7 +4295,7 @@ gfc_check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n \t}\n \n       check_type = proc_pass_arg != argpos && old_pass_arg != argpos;\n-      if (!check_dummy_characteristics (proc_formal->sym, old_formal->sym, \n+      if (!gfc_check_dummy_characteristics (proc_formal->sym, old_formal->sym,\n \t\t\t\t\tcheck_type, err, sizeof(err)))\n \t{\n \t  gfc_error (\"Argument mismatch for the overriding procedure \""}, {"sha": "91c9825c94d23f462ed00b2d4fb98213e9dabd49", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=4668d6f9c00d476786cfe4ee765d2da2afd3d114", "patch": "@@ -203,6 +203,7 @@ match gfc_match_generic (void);\n match gfc_match_function_decl (void);\n match gfc_match_entry (void);\n match gfc_match_subroutine (void);\n+match gfc_match_submod_proc (void);\n match gfc_match_derived_decl (void);\n match gfc_match_final_decl (void);\n \n@@ -291,6 +292,7 @@ match gfc_match_expr (gfc_expr **);\n \n /* module.c.  */\n match gfc_match_use (void);\n+match gfc_match_submodule (void);\n void gfc_use_modules (void);\n \n #endif  /* GFC_MATCH_H  */"}, {"sha": "24662f464debb42ebaea1384bb75c69bcb5acc75", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 72, "deletions": 3, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=4668d6f9c00d476786cfe4ee765d2da2afd3d114", "patch": "@@ -716,6 +716,67 @@ gfc_match_use (void)\n }\n \n \n+/* Match a SUBMODULE statement.  */\n+\n+match\n+gfc_match_submodule (void)\n+{\n+  match m;\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n+  gfc_use_list *use_list;\n+\n+  if (!gfc_notify_std (GFC_STD_F2008, \"SUBMODULE declaration at %C\"))\n+    return MATCH_ERROR;\n+\n+  gfc_new_block = NULL;\n+  gcc_assert (module_list == NULL);\n+\n+  if (gfc_match_char ('(') != MATCH_YES)\n+    goto syntax;\n+\n+  while (1)\n+    {\n+      m = gfc_match (\" %n\", name);\n+      if (m != MATCH_YES)\n+\tgoto syntax;\n+\n+      use_list = gfc_get_use_list ();\n+      use_list->module_name = gfc_get_string (name);\n+      use_list->where = gfc_current_locus;\n+\n+      if (module_list)\n+\t{\n+\t  gfc_use_list *last = module_list;\n+\t  while (last->next)\n+\t    last = last->next;\n+\t  last->next = use_list;\n+\t}\n+      else\n+\tmodule_list = use_list;\n+\n+      if (gfc_match_char (')') == MATCH_YES)\n+\tbreak;\n+\n+      if (gfc_match_char (':') != MATCH_YES)\n+\tgoto syntax;\n+    }\n+\n+  m = gfc_match (\" %s%t\", &gfc_new_block);\n+  if (m != MATCH_YES)\n+    goto syntax;\n+\n+  if (!gfc_add_flavor (&gfc_new_block->attr, FL_MODULE,\n+\t\t       gfc_new_block->name, NULL))\n+    return MATCH_ERROR;\n+\n+  return MATCH_YES;\n+\n+syntax:\n+  gfc_error (\"Syntax error in SUBMODULE statement at %C\");\n+  return MATCH_ERROR;\n+}\n+\n+\n /* Given a name and a number, inst, return the inst name\n    under which to load this symbol. Returns NULL if this\n    symbol shouldn't be loaded. If inst is zero, returns\n@@ -1887,7 +1948,7 @@ typedef enum\n   AB_IS_CLASS, AB_PROCEDURE, AB_PROC_POINTER, AB_ASYNCHRONOUS, AB_CODIMENSION,\n   AB_COARRAY_COMP, AB_VTYPE, AB_VTAB, AB_CONTIGUOUS, AB_CLASS_POINTER,\n   AB_IMPLICIT_PURE, AB_ARTIFICIAL, AB_UNLIMITED_POLY, AB_OMP_DECLARE_TARGET,\n-  AB_ARRAY_OUTER_DEPENDENCY\n+  AB_ARRAY_OUTER_DEPENDENCY, AB_MODULE_PROCEDURE\n }\n ab_attribute;\n \n@@ -1944,6 +2005,7 @@ static const mstring attr_bits[] =\n     minit (\"UNLIMITED_POLY\", AB_UNLIMITED_POLY),\n     minit (\"OMP_DECLARE_TARGET\", AB_OMP_DECLARE_TARGET),\n     minit (\"ARRAY_OUTER_DEPENDENCY\", AB_ARRAY_OUTER_DEPENDENCY),\n+    minit (\"MODULE_PROCEDURE\", AB_MODULE_PROCEDURE),\n     minit (NULL, -1)\n };\n \n@@ -2126,6 +2188,8 @@ mio_symbol_attribute (symbol_attribute *attr)\n \tMIO_NAME (ab_attribute) (AB_OMP_DECLARE_TARGET, attr_bits);\n       if (attr->array_outer_dependency)\n \tMIO_NAME (ab_attribute) (AB_ARRAY_OUTER_DEPENDENCY, attr_bits);\n+      if (attr->module_procedure)\n+\tMIO_NAME (ab_attribute) (AB_MODULE_PROCEDURE, attr_bits);\n \n       mio_rparen ();\n \n@@ -2295,6 +2359,9 @@ mio_symbol_attribute (symbol_attribute *attr)\n \t    case AB_ARRAY_OUTER_DEPENDENCY:\n \t      attr->array_outer_dependency =1;\n \t      break;\n+\t    case AB_MODULE_PROCEDURE:\n+\t      attr->module_procedure =1;\n+\t      break;\n \t    }\n \t}\n     }\n@@ -6757,8 +6824,10 @@ gfc_use_module (gfc_use_list *module)\n \n   /* Make sure we're not reading the same module that we may be building.  */\n   for (p = gfc_state_stack; p; p = p->previous)\n-    if (p->state == COMP_MODULE && strcmp (p->sym->name, module_name) == 0)\n-      gfc_fatal_error (\"Can't USE the same module we're building!\");\n+    if ((p->state == COMP_MODULE || p->state == COMP_SUBMODULE)\n+\t && strcmp (p->sym->name, module_name) == 0)\n+      gfc_fatal_error (\"Can't USE the same %smodule we're building!\",\n+\t\t       p->state == COMP_SUBMODULE ? \"sub\" : \"\");\n \n   init_pi_tree ();\n   init_true_name_tree ();"}, {"sha": "148cff94fb64092be8e81850da20665fc458ee7e", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 114, "deletions": 6, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=4668d6f9c00d476786cfe4ee765d2da2afd3d114", "patch": "@@ -369,6 +369,16 @@ decode_statement (void)\n   gfc_undo_symbols ();\n   gfc_current_locus = old_locus;\n \n+  if (gfc_match_submod_proc () == MATCH_YES)\n+    {\n+      if (gfc_new_block->attr.subroutine)\n+\treturn ST_SUBROUTINE;\n+      else if (gfc_new_block->attr.function)\n+\treturn ST_FUNCTION;\n+    }\n+  gfc_undo_symbols ();\n+  gfc_current_locus = old_locus;\n+\n   /* Check for the IF, DO, SELECT, WHERE, FORALL, CRITICAL, BLOCK and ASSOCIATE\n      statements, which might begin with a block label.  The match functions for\n      these statements are unusual in that their keyword is not seen before\n@@ -522,6 +532,7 @@ decode_statement (void)\n       match (\"sequence\", gfc_match_eos, ST_SEQUENCE);\n       match (\"stop\", gfc_match_stop, ST_STOP);\n       match (\"save\", gfc_match_save, ST_ATTR_DECL);\n+      match (\"submodule\", gfc_match_submodule, ST_SUBMODULE);\n       match (\"sync all\", gfc_match_sync_all, ST_SYNC_ALL);\n       match (\"sync images\", gfc_match_sync_images, ST_SYNC_IMAGES);\n       match (\"sync memory\", gfc_match_sync_memory, ST_SYNC_MEMORY);\n@@ -1534,8 +1545,8 @@ gfc_enclosing_unit (gfc_compile_state * result)\n \n   for (p = gfc_state_stack; p; p = p->previous)\n     if (p->state == COMP_FUNCTION || p->state == COMP_SUBROUTINE\n-\t|| p->state == COMP_MODULE || p->state == COMP_BLOCK_DATA\n-\t|| p->state == COMP_PROGRAM)\n+\t|| p->state == COMP_MODULE || p->state == COMP_SUBMODULE\n+\t|| p->state == COMP_BLOCK_DATA || p->state == COMP_PROGRAM)\n       {\n \n \tif (result != NULL)\n@@ -1660,6 +1671,9 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_END_MODULE:\n       p = \"END MODULE\";\n       break;\n+    case ST_END_SUBMODULE:\n+      p = \"END SUBMODULE\";\n+      break;\n     case ST_END_PROGRAM:\n       p = \"END PROGRAM\";\n       break;\n@@ -1742,6 +1756,9 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_MODULE:\n       p = \"MODULE\";\n       break;\n+    case ST_SUBMODULE:\n+      p = \"SUBMODULE\";\n+      break;\n     case ST_PAUSE:\n       p = \"PAUSE\";\n       break;\n@@ -2186,6 +2203,7 @@ accept_statement (gfc_statement st)\n     case ST_FUNCTION:\n     case ST_SUBROUTINE:\n     case ST_MODULE:\n+    case ST_SUBMODULE:\n       gfc_current_ns->proc_name = gfc_new_block;\n       break;\n \n@@ -2931,6 +2949,10 @@ parse_interface (void)\n \t  gfc_free_namespace (gfc_current_ns);\n \t  goto loop;\n \t}\n+      /* F2008 C1210 forbids the IMPORT statement in module procedure\n+\t interface bodies and the flag is set to import symbols.  */\n+      if (gfc_new_block->attr.module_procedure)\n+        gfc_current_ns->has_import_set = 1;\n       break;\n \n     case ST_PROCEDURE:\n@@ -3280,7 +3302,8 @@ parse_spec (gfc_statement st)\n \t  break;\n \n \tcase ST_STATEMENT_FUNCTION:\n-\t  if (gfc_current_state () == COMP_MODULE)\n+\t  if (gfc_current_state () == COMP_MODULE\n+\t      || gfc_current_state () == COMP_SUBMODULE)\n \t    {\n \t      unexpected_statement (st);\n \t      break;\n@@ -4983,6 +5006,7 @@ parse_contained (int module)\n \t/* These statements are associated with the end of the host unit.  */\n \tcase ST_END_FUNCTION:\n \tcase ST_END_MODULE:\n+\tcase ST_END_SUBMODULE:\n \tcase ST_END_PROGRAM:\n \tcase ST_END_SUBROUTINE:\n \t  accept_statement (st);\n@@ -4999,7 +5023,8 @@ parse_contained (int module)\n \t}\n     }\n   while (st != ST_END_FUNCTION && st != ST_END_SUBROUTINE\n-\t && st != ST_END_MODULE && st != ST_END_PROGRAM);\n+\t && st != ST_END_MODULE && st != ST_END_SUBMODULE\n+\t && st != ST_END_PROGRAM);\n \n   /* The first namespace in the list is guaranteed to not have\n      anything (worthwhile) in it.  */\n@@ -5019,6 +5044,35 @@ parse_contained (int module)\n }\n \n \n+/* The result variable in a MODULE PROCEDURE needs to be created and\n+    its characteristics copied from the interface since it is neither\n+    declared in the procedure declaration nor in the specification\n+    part.  */\n+\n+static void\n+get_modproc_result (void)\n+{\n+  gfc_symbol *proc;\n+  if (gfc_state_stack->previous\n+      && gfc_state_stack->previous->state == COMP_CONTAINS\n+      && gfc_state_stack->previous->previous->state == COMP_SUBMODULE)\n+    {\n+      proc = gfc_current_ns->proc_name ? gfc_current_ns->proc_name : NULL;\n+      if (proc != NULL\n+\t  && proc->attr.function\n+\t  && proc->ts.interface\n+\t  && proc->ts.interface->result\n+\t  && proc->ts.interface->result != proc->ts.interface)\n+\t{\n+\t  gfc_copy_dummy_sym (&proc->result, proc->ts.interface->result, 1);\n+\t  gfc_set_sym_referenced (proc->result);\n+\t  proc->result->attr.if_source = IFSRC_DECL;\n+\t  gfc_commit_symbol (proc->result);\n+\t}\n+    }\n+}\n+\n+\n /* Parse a PROGRAM, SUBROUTINE, FUNCTION unit or BLOCK construct.  */\n \n static void\n@@ -5027,6 +5081,11 @@ parse_progunit (gfc_statement st)\n   gfc_state_data *p;\n   int n;\n \n+  if (gfc_new_block\n+      && gfc_new_block->abr_modproc_decl\n+      && gfc_new_block->attr.function)\n+    get_modproc_result ();\n+\n   st = parse_spec (st);\n   switch (st)\n     {\n@@ -5086,7 +5145,8 @@ parse_progunit (gfc_statement st)\n     if (p->state == COMP_CONTAINS)\n       n++;\n \n-  if (gfc_find_state (COMP_MODULE) == true)\n+  if (gfc_find_state (COMP_MODULE) == true\n+      || gfc_find_state (COMP_SUBMODULE) == true)\n     n--;\n \n   if (n > 0)\n@@ -5207,6 +5267,36 @@ parse_block_data (void)\n }\n \n \n+/* Following the association of the ancestor (sub)module symbols, they\n+   must be set host rather than use associated and all must be public.\n+   They are flagged up by 'used_in_submodule' so that they can be set\n+   DECL_EXTERNAL in trans_decl.c(gfc_finish_var_decl).  Otherwise the\n+   linker chokes on multiple symbol definitions.  */\n+\n+static void\n+set_syms_host_assoc (gfc_symbol *sym)\n+{\n+  gfc_component *c;\n+\n+  if (sym == NULL)\n+    return;\n+\n+  if (sym->attr.module_procedure)\n+    sym->attr.external = 0;\n+\n+/*  sym->attr.access = ACCESS_PUBLIC;  */\n+\n+  sym->attr.use_assoc = 0;\n+  sym->attr.host_assoc = 1;\n+  sym->attr.used_in_submodule =1;\n+\n+  if (sym->attr.flavor == FL_DERIVED)\n+    {\n+      for (c = sym->components; c; c = c->next)\n+\tc->attr.access = ACCESS_PUBLIC;\n+    }\n+}\n+\n /* Parse a module subprogram.  */\n \n static void\n@@ -5226,6 +5316,15 @@ parse_module (void)\n       s->defined = 1;\n     }\n \n+  /* Something is nulling the module_list after this point. This is good\n+     since it allows us to 'USE' the parent modules that the submodule\n+     inherits and to set (most) of the symbols as host associated.  */\n+  if (gfc_current_state () == COMP_SUBMODULE)\n+    {\n+      use_modules ();\n+      gfc_traverse_ns (gfc_current_ns, set_syms_host_assoc);\n+    }\n+\n   st = parse_spec (ST_NONE);\n \n   error = false;\n@@ -5240,6 +5339,7 @@ parse_module (void)\n       break;\n \n     case ST_END_MODULE:\n+    case ST_END_SUBMODULE:\n       accept_statement (st);\n       break;\n \n@@ -5535,6 +5635,14 @@ gfc_parse_file (void)\n       parse_module ();\n       break;\n \n+    case ST_SUBMODULE:\n+      push_state (&s, COMP_SUBMODULE, gfc_new_block);\n+      accept_statement (st);\n+\n+      gfc_get_errors (NULL, &errors_before);\n+      parse_module ();\n+      break;\n+\n     /* Anything else starts a nameless main program block.  */\n     default:\n       if (seen_program)\n@@ -5559,7 +5667,7 @@ gfc_parse_file (void)\n     gfc_dump_parse_tree (gfc_current_ns, stdout);\n \n   gfc_get_errors (NULL, &errors);\n-  if (s.state == COMP_MODULE)\n+  if (s.state == COMP_MODULE || s.state == COMP_SUBMODULE)\n     {\n       gfc_dump_module (s.sym->name, errors_before == errors);\n       gfc_current_ns->derived_types = gfc_derived_types;"}, {"sha": "dcac98aac697a4fe1fdc778320d90d49edac66b8", "filename": "gcc/fortran/parse.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ffortran%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ffortran%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.h?ref=4668d6f9c00d476786cfe4ee765d2da2afd3d114", "patch": "@@ -25,9 +25,9 @@ along with GCC; see the file COPYING3.  If not see\n /* Enum for what the compiler is currently doing.  */\n typedef enum\n {\n-  COMP_NONE, COMP_PROGRAM, COMP_MODULE, COMP_SUBROUTINE, COMP_FUNCTION,\n-  COMP_BLOCK_DATA, COMP_INTERFACE, COMP_DERIVED, COMP_DERIVED_CONTAINS,\n-  COMP_BLOCK, COMP_ASSOCIATE, COMP_IF,\n+  COMP_NONE, COMP_PROGRAM, COMP_MODULE, COMP_SUBMODULE, COMP_SUBROUTINE,\n+  COMP_FUNCTION, COMP_BLOCK_DATA, COMP_INTERFACE, COMP_DERIVED,\n+  COMP_DERIVED_CONTAINS, COMP_BLOCK, COMP_ASSOCIATE, COMP_IF,\n   COMP_DO, COMP_SELECT, COMP_FORALL, COMP_WHERE, COMP_CONTAINS, COMP_ENUM,\n   COMP_SELECT_TYPE, COMP_OMP_STRUCTURED_BLOCK, COMP_CRITICAL, COMP_DO_CONCURRENT\n }"}, {"sha": "acde051cdb327e2f60a3297a7cfb0b5408f1db06", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=4668d6f9c00d476786cfe4ee765d2da2afd3d114", "patch": "@@ -2964,7 +2964,8 @@ gfc_match_rvalue (gfc_expr **result)\n \n       st = gfc_enclosing_unit (NULL);\n \n-      if (st != NULL && st->state == COMP_FUNCTION\n+      if (st != NULL\n+\t  && st->state == COMP_FUNCTION\n \t  && st->sym == sym\n \t  && !sym->attr.recursive)\n \t{\n@@ -3268,6 +3269,7 @@ match_variable (gfc_expr **result, int equiv_flag, int host_flag)\n      of keywords, such as 'end', being turned into variables by\n      failed matching to assignments for, e.g., END INTERFACE.  */\n   if (gfc_current_state () == COMP_MODULE\n+      || gfc_current_state () == COMP_SUBMODULE\n       || gfc_current_state () == COMP_INTERFACE\n       || gfc_current_state () == COMP_CONTAINS)\n     host_flag = 0;"}, {"sha": "efafabc5ac94eb08ebc270fea6a985e86f009d43", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=4668d6f9c00d476786cfe4ee765d2da2afd3d114", "patch": "@@ -11431,6 +11431,32 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n }\n \n \n+/* Compare the dummy characteristics of a module procedure interface\n+   declaration with the corresponding declaration in a submodule.  */\n+static gfc_formal_arglist *new_formal;\n+static char errmsg[200];\n+\n+static void\n+compare_fsyms (gfc_symbol *sym)\n+{\n+  gfc_symbol *fsym;\n+\n+  if (sym == NULL || new_formal == NULL)\n+    return;\n+\n+  fsym = new_formal->sym;\n+\n+  if (sym == fsym)\n+    return;\n+\n+  if (strcmp (sym->name, fsym->name) == 0)\n+    {\n+      if (!gfc_check_dummy_characteristics (fsym, sym, true, errmsg, 200))\n+\tgfc_error (\"%s at %L\", errmsg, &fsym->declared_at);\n+    }\n+}\n+\n+\n /* Resolve a procedure.  */\n \n static bool\n@@ -11695,6 +11721,71 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n   if (sym->attr.if_source != IFSRC_DECL)\n     sym->attr.array_outer_dependency = 1;\n \n+  /* Compare the characteristics of a module procedure with the\n+     interface declaration. Ideally this would be done with\n+     gfc_compare_interfaces but, at present, the formal interface\n+     cannot be copied to the ts.interface.  */\n+  if (sym->attr.module_procedure\n+      && sym->attr.if_source == IFSRC_DECL)\n+    {\n+      gfc_symbol *iface;\n+\n+      /* Stop the dummy characteristics test from using the interface\n+\t symbol instead of 'sym'.  */\n+      iface = sym->ts.interface;\n+      sym->ts.interface = NULL;\n+\n+      if (iface == NULL)\n+\tgoto check_formal;\n+\n+      /* Check the procedure characteristics.  */\n+      if (sym->attr.pure != iface->attr.pure)\n+\t{\n+\t  gfc_error (\"Mismatch in PURE attribute between MODULE \"\n+\t\t     \"PROCEDURE at %L and its interface in %s\",\n+\t\t     &sym->declared_at, iface->module);\n+\t  return false;\n+\t}\n+\n+      if (sym->attr.elemental != iface->attr.elemental)\n+\t{\n+\t  gfc_error (\"Mismatch in ELEMENTAL attribute between MODULE \"\n+\t\t     \"PROCEDURE at %L and its interface in %s\",\n+\t\t     &sym->declared_at, iface->module);\n+\t  return false;\n+\t}\n+\n+      if (sym->attr.recursive != iface->attr.recursive)\n+\t{\n+\t  gfc_error (\"Mismatch in RECURSIVE attribute between MODULE \"\n+\t\t     \"PROCEDURE at %L and its interface in %s\",\n+\t\t     &sym->declared_at, iface->module);\n+\t  return false;\n+\t}\n+\n+      /* Check the result characteristics.  */\n+      if (!gfc_check_result_characteristics (sym, iface, errmsg, 200))\n+\t{\n+\t  gfc_error (\"%s between the MODULE PROCEDURE declaration \"\n+\t\t     \"in module %s and the declaration at %L in \"\n+\t\t     \"SUBMODULE %s\", errmsg, iface->module,\n+\t\t     &sym->declared_at, sym->ns->proc_name->name);\n+\t  return false;\n+\t}\n+\n+check_formal:\n+      /* Check the charcateristics of the formal arguments.  */\n+      if (sym->formal && sym->formal_ns)\n+\t{\n+\t  for (arg = sym->formal; arg && arg->sym; arg = arg->next)\n+\t    {\n+\t      new_formal = arg;\n+\t      gfc_traverse_ns (sym->formal_ns, compare_fsyms);\n+\t    }\n+\t}\n+\n+      sym->ts.interface = iface;\n+    }\n   return true;\n }\n "}, {"sha": "b7d5b86791bbec8c5deb5ce83d8f25fe322cc6d1", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 50, "deletions": 3, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=4668d6f9c00d476786cfe4ee765d2da2afd3d114", "patch": "@@ -1539,7 +1539,7 @@ gfc_add_procedure (symbol_attribute *attr, procedure_type t,\n   if (where == NULL)\n     where = &gfc_current_locus;\n \n-  if (attr->proc != PROC_UNKNOWN)\n+  if (attr->proc != PROC_UNKNOWN && !attr->module_procedure)\n     {\n       gfc_error (\"%s procedure at %L is already declared as %s procedure\",\n \t\t gfc_code2string (procedures, t), where,\n@@ -1655,10 +1655,15 @@ bool\n gfc_add_explicit_interface (gfc_symbol *sym, ifsrc source,\n \t\t\t    gfc_formal_arglist * formal, locus *where)\n {\n-\n   if (check_used (&sym->attr, sym->name, where))\n     return false;\n \n+  /* Skip the following checks in the case of a module_procedures in a\n+     submodule since they will manifestly fail.  */\n+  if (sym->attr.module_procedure == 1\n+      && source == IFSRC_DECL)\n+    goto finish;\n+\n   if (where == NULL)\n     where = &gfc_current_locus;\n \n@@ -1677,6 +1682,7 @@ gfc_add_explicit_interface (gfc_symbol *sym, ifsrc source,\n       return false;\n     }\n \n+finish:\n   sym->formal = formal;\n   sym->attr.if_source = source;\n \n@@ -1703,7 +1709,10 @@ gfc_add_type (gfc_symbol *sym, gfc_typespec *ts, locus *where)\n   if (sym->attr.result && type == BT_UNKNOWN && sym->ns->proc_name)\n     type = sym->ns->proc_name->ts.type;\n \n-  if (type != BT_UNKNOWN && !(sym->attr.function && sym->attr.implicit_type))\n+  if (type != BT_UNKNOWN && !(sym->attr.function && sym->attr.implicit_type)\n+      && !(gfc_state_stack->previous && gfc_state_stack->previous->previous\n+\t   && gfc_state_stack->previous->previous->state == COMP_SUBMODULE)\n+      && !sym->attr.module_procedure)\n     {\n       if (sym->attr.use_assoc)\n \tgfc_error (\"Symbol %qs at %L conflicts with symbol from module %qs, \"\n@@ -1876,6 +1885,44 @@ gfc_copy_attr (symbol_attribute *dest, symbol_attribute *src, locus *where)\n }\n \n \n+/* A function to generate a dummy argument symbol using that from the\n+   interface declaration. Can be used for the result symbol as well if\n+   the flag is set.  */\n+\n+int\n+gfc_copy_dummy_sym (gfc_symbol **dsym, gfc_symbol *sym, int result)\n+{\n+  int rc;\n+\n+  rc = gfc_get_symbol (sym->name, NULL, dsym);\n+  if (rc)\n+    return rc;\n+\n+  if (!gfc_add_type (*dsym, &(sym->ts), &gfc_current_locus))\n+    return 1;\n+\n+  if (!gfc_copy_attr (&(*dsym)->attr, &(sym->attr),\n+      &gfc_current_locus))\n+    return 1;\n+\n+  if ((*dsym)->attr.dimension)\n+    (*dsym)->as = gfc_copy_array_spec (sym->as);\n+\n+  (*dsym)->attr.class_ok = sym->attr.class_ok;\n+\n+  if ((*dsym) != NULL && !result\n+      && (!gfc_add_dummy(&(*dsym)->attr, (*dsym)->name, NULL)\n+\t  || !gfc_missing_attr (&(*dsym)->attr, NULL)))\n+    return 1;\n+  else if ((*dsym) != NULL && result\n+      && (!gfc_add_result(&(*dsym)->attr, (*dsym)->name, NULL)\n+\t  || !gfc_missing_attr (&(*dsym)->attr, NULL)))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+\n /************** Component name management ************/\n \n /* Component names of a derived type form their own little namespaces"}, {"sha": "b4f75baafc98af3e6253c07d9c073a6537dcf9f3", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=4668d6f9c00d476786cfe4ee765d2da2afd3d114", "patch": "@@ -377,9 +377,10 @@ gfc_sym_mangled_function_id (gfc_symbol * sym)\n     /* use the binding label rather than the mangled name */\n     return get_identifier (sym->binding_label);\n \n-  if (sym->module == NULL || sym->attr.proc == PROC_EXTERNAL\n+  if ((sym->module == NULL || sym->attr.proc == PROC_EXTERNAL\n       || (sym->module != NULL && (sym->attr.external\n \t    || sym->attr.if_source == IFSRC_IFBODY)))\n+      && !sym->attr.module_procedure)\n     {\n       /* Main program is mangled into MAIN__.  */\n       if (sym->attr.is_main_program)\n@@ -599,7 +600,7 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)\n     }\n \n   /* If a variable is USE associated, it's always external.  */\n-  if (sym->attr.use_assoc)\n+  if (sym->attr.use_assoc || sym->attr.used_in_submodule)\n     {\n       DECL_EXTERNAL (decl) = 1;\n       TREE_PUBLIC (decl) = 1;\n@@ -1319,6 +1320,7 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n   gcc_assert (sym->attr.referenced\n \t      || sym->attr.flavor == FL_PROCEDURE\n \t      || sym->attr.use_assoc\n+\t      || sym->attr.used_in_submodule\n \t      || sym->ns->proc_name->attr.if_source == IFSRC_IFBODY\n \t      || (sym->module && sym->attr.if_source != IFSRC_DECL\n \t\t  && sym->backend_decl));"}, {"sha": "da2acd4beb34ca57f6f46bd63d52741d84aa7f6c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4668d6f9c00d476786cfe4ee765d2da2afd3d114", "patch": "@@ -1,3 +1,14 @@\n+2015-07-02  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/52846\n+\t* gfortran.dg/submodule_1.f90: New test\n+\t* gfortran.dg/submodule_2.f90: New test\n+\t* gfortran.dg/submodule_3.f90: New test\n+\t* gfortran.dg/submodule_4.f90: New test\n+\t* gfortran.dg/submodule_5.f90: New test\n+\t* gfortran.dg/submodule_6.f90: New test\n+\t* gfortran.dg/submodule_7.f90: New test\n+\n 2015-07-02  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/53690"}, {"sha": "2c5d373206ea13437d4005b7bb464fe7fd1906e3", "filename": "gcc/testsuite/gfortran.dg/submodule_1.f90", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_1.f90?ref=4668d6f9c00d476786cfe4ee765d2da2afd3d114", "patch": "@@ -0,0 +1,172 @@\n+! { dg-do run }\n+!\n+! Basic test of submodule functionality.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+ module foo_interface\n+   implicit none\n+   character(len = 100) :: message\n+   character(len = 100) :: message2\n+\n+   type foo\n+     character(len=15) :: greeting = \"Hello, world!  \"\n+     character(len=15), private :: byebye = \"adieu, world!  \"\n+   contains\n+     procedure :: greet => say_hello\n+     procedure :: farewell => bye\n+     procedure, private :: adieu => byebye\n+   end type foo\n+\n+   interface\n+     module subroutine say_hello(this)\n+       class(foo), intent(in) :: this\n+     end subroutine\n+\n+     module subroutine bye(this)\n+       class(foo), intent(in) :: this\n+     end subroutine\n+\n+     module subroutine byebye(this, that)\n+       class(foo), intent(in) :: this\n+       class(foo), intent(inOUT), allocatable :: that\n+     end subroutine\n+\n+     module function realf (arg) result (res)\n+       real :: arg, res\n+     end function\n+\n+     integer module function intf (arg)\n+       integer :: arg\n+     end function\n+\n+     real module function realg (arg)\n+       real :: arg\n+     end function\n+\n+     integer module function intg (arg)\n+       integer :: arg\n+     end function\n+\n+   end interface\n+\n+   integer :: factor = 5\n+\n+ contains\n+\n+   subroutine smurf\n+     class(foo), allocatable :: this\n+     allocate (this)\n+     message = \"say_hello from SMURF --->\"\n+     call say_hello (this)\n+   end subroutine\n+ end module\n+\n+!\n+  SUBMODULE (foo_interface) foo_interface_son\n+!\n+  contains\n+! Test module procedure with conventional specification part for dummies\n+     module subroutine say_hello(this)\n+       class(foo), intent(in) :: this\n+       class(foo), allocatable :: that\n+       allocate (that, source = this)\n+!       call this%farewell         ! NOTE WELL: This compiles and causes a crash in run-time\n+!                                               due to recursion through the call to this procedure from\n+!                                               say hello.\n+       message = that%greeting\n+\n+! Check that descendant module procedure is correctly processed\n+       if (intf (77) .ne. factor*77) call abort\n+     end subroutine\n+\n+     module function realf (arg) result (res)\n+       real :: arg, res\n+       res = 2*arg\n+     end function\n+\n+  end SUBMODULE foo_interface_son\n+\n+!\n+! Check that multiple generations of submodules are OK\n+  SUBMODULE (foo_interface:foo_interface_son) foo_interface_grandson\n+!\n+  contains\n+\n+     module procedure intf\n+       intf = factor*arg\n+     end PROCEDURE\n+\n+  end SUBMODULE foo_interface_grandson\n+\n+!\n+  SUBMODULE (foo_interface) foo_interface_daughter\n+!\n+  contains\n+! Test module procedure with abbreviated declaration and no specification of dummies\n+     module procedure bye\n+       class(foo), allocatable :: that\n+       call say_hello (this)\n+! check access to a PRIVATE procedure pointer that accesses a private component\n+       call this%adieu (that)\n+       message2 = that%greeting\n+     end PROCEDURE\n+\n+! Test module procedure pointed to by PRIVATE component of foo\n+     module procedure byebye\n+       allocate (that, source = this)\n+! Access a PRIVATE component of foo\n+       that%greeting = that%byebye\n+     end PROCEDURE\n+\n+     module procedure intg\n+       intg = 3*arg\n+     end PROCEDURE\n+\n+     module procedure realg\n+       realg = 3*arg\n+     end PROCEDURE\n+\n+  end SUBMODULE foo_interface_daughter\n+\n+!\n+ program try\n+   use foo_interface\n+   implicit none\n+   type(foo) :: bar\n+\n+   call clear_messages\n+   call bar%greet ! typebound call\n+   if (trim (message) .ne. \"Hello, world!\") call abort\n+\n+   call clear_messages\n+   bar%greeting = \"G'day, world!\"\n+   call say_hello(bar) ! Checks use association of 'say_hello'\n+   if (trim (message) .ne. \"G'day, world!\") call abort\n+\n+   call clear_messages\n+   bar%greeting = \"Hi, world!\"\n+   call bye(bar) ! Checks use association in another submodule\n+   if (trim (message) .ne. \"Hi, world!\") call abort\n+   if (trim (message2) .ne. \"adieu, world!\") call abort\n+\n+   call clear_messages\n+   call smurf ! Checks host association of 'say_hello'\n+   if (trim (message) .ne. \"Hello, world!\") call abort\n+\n+   call clear_messages\n+   bar%greeting = \"farewell     \"\n+   call bar%farewell\n+   if (trim (message) .ne. \"farewell\") call abort\n+   if (trim (message2) .ne. \"adieu, world!\") call abort\n+\n+   if (realf(2.0) .ne. 4.0) call abort ! Check module procedure with explicit result\n+   if (intf(2) .ne. 10) call abort     ! ditto\n+   if (realg(3.0) .ne. 9.0) call abort ! Check module procedure with function declaration result\n+   if (intg(3) .ne. 9) call abort      ! ditto\n+ contains\n+   subroutine clear_messages\n+     message = \"\"\n+     message2 = \"\"\n+   end subroutine\n+ end program"}, {"sha": "43456d5fc4c287b90e39b5a3eca542122af625fc", "filename": "gcc/testsuite/gfortran.dg/submodule_2.f90", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_2.f90?ref=4668d6f9c00d476786cfe4ee765d2da2afd3d114", "patch": "@@ -0,0 +1,100 @@\n+! { dg-do run }\n+!\n+! Test dummy and result arrays in module procedures\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+ module foo_interface\n+   implicit none\n+   type foo\n+     character(len=16) :: greeting = \"Hello, world!   \"\n+     character(len=16), private :: byebye = \"adieu, world!   \"\n+   end type foo\n+\n+   interface\n+     module function array1(this) result (that)\n+       type(foo), intent(in), dimension(:) :: this\n+       type(foo), allocatable, dimension(:) :: that\n+     end function\n+     character(16) module function array2(this, that)\n+       type(foo), intent(in), dimension(:) :: this\n+       type(foo), allocatable, dimension(:) :: that\n+     end function\n+     module subroutine array3(this, that)\n+       type(foo), intent(in), dimension(:) :: this\n+       type(foo), intent(inOUT), allocatable, dimension(:) :: that\n+     end subroutine\n+     module subroutine array4(this, that)\n+       type(foo), intent(in), dimension(:) :: this\n+       type(foo), intent(inOUT), allocatable, dimension(:) :: that\n+     end subroutine\n+   end interface\n+ end module\n+\n+!\n+  SUBMODULE (foo_interface) foo_interface_son\n+!\n+  contains\n+\n+! Test array characteristics for dummy and result are OK\n+     module function array1 (this) result(that)\n+       type(foo), intent(in), dimension(:) :: this\n+       type(foo), allocatable, dimension(:) :: that\n+       allocate (that(size(this)), source = this)\n+       that%greeting = that%byebye\n+     end function\n+\n+! Test array characteristics for dummy and result are OK for\n+! abbreviated module procedure declaration.\n+     module procedure array2\n+       allocate (that(size(this)), source = this)\n+       that%greeting = that%byebye\n+       array2 = trim (that(size (that))%greeting(1:5))//\", people!\"\n+     end PROCEDURE\n+\n+  end SUBMODULE foo_interface_son\n+\n+!\n+  SUBMODULE (foo_interface) foo_interface_daughter\n+!\n+  contains\n+\n+! Test array characteristics for dummies are OK\n+     module subroutine array3(this, that)\n+       type(foo), intent(in), dimension(:) :: this\n+       type(foo), intent(inOUT), allocatable, dimension(:) :: that\n+       allocate (that(size(this)), source = this)\n+       that%greeting = that%byebye\n+     end subroutine\n+\n+! Test array characteristics for dummies are OK for\n+! abbreviated module procedure declaration.\n+     module procedure array4\n+       integer :: i\n+       allocate (that(size(this)), source = this)\n+       that%greeting = that%byebye\n+       do i = 1, size (that)\n+         that(i)%greeting = trim (that(i)%greeting(1:5))//\", people!\"\n+       end do\n+     end PROCEDURE\n+  end SUBMODULE foo_interface_daughter\n+\n+!\n+ program try\n+   use foo_interface\n+   implicit none\n+   type(foo), dimension(2) :: bar\n+   type (foo), dimension(:), allocatable :: arg\n+\n+   arg = array1(bar) ! typebound call\n+   if (any (arg%greeting .ne. [\"adieu, world!   \", \"adieu, world!   \"])) call abort\n+   deallocate (arg)\n+   if (trim (array2 (bar, arg)) .ne. \"adieu, people!\") call abort\n+   deallocate (arg)\n+   call array3 (bar, arg) ! typebound call\n+   if (any (arg%greeting .ne. [\"adieu, world!   \", \"adieu, world!   \"])) call abort\n+   deallocate (arg)\n+   call array4 (bar, arg) ! typebound call\n+   if (any (arg%greeting .ne. [\"adieu, people!\", \"adieu, people!\"])) call abort\n+ contains\n+ end program"}, {"sha": "9d6c8d28e3a2ef17f2b5f8e32514d1cd010950f4", "filename": "gcc/testsuite/gfortran.dg/submodule_3.f90", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_3.f90?ref=4668d6f9c00d476786cfe4ee765d2da2afd3d114", "patch": "@@ -0,0 +1,37 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2003\" }\n+!\n+! Check enforcement of F2008 standard for MODULE PROCEDURES and SUBMODULES\n+! This is rather bare-bones to reduce the number of error messages too the\n+! essential minimum.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+ module foo_interface\n+   implicit none\n+\n+   interface\n+     module function array1(this) result (that) ! { dg-error \"MODULE prefix\" }\n+     end function ! { dg-error \"Expecting END INTERFACE\" }\n+     character(16) module function array2(this, that) ! { dg-error \"MODULE prefix\" }\n+     end function ! { dg-error \"Expecting END INTERFACE\" }\n+   end interface\n+ end module\n+\n+!\n+  SUBMODULE (foo_interface) foo_interface_son ! { dg-error \"SUBMODULE declaration\" }\n+!\n+  contains\n+\n+     module function array1 (this) result(that) ! { dg-error \"MODULE prefix\" }\n+     end function ! { dg-error \"Expecting END PROGRAM\" }\n+\n+! Test array characteristics for dummy and result are OK for\n+! abbreviated module procedure declaration.\n+     module procedure array2 ! { dg-error \"must be in a generic module interface\" }\n+     end PROCEDURE ! { dg-error \"Expecting END PROGRAM\" }\n+\n+  end SUBMODULE foo_interface_son ! { dg-error \"Expecting END PROGRAM\" }\n+\n+end ! { dg-error \"CONTAINS statement without FUNCTION or SUBROUTINE\" }\n+"}, {"sha": "fd1fe0cee82f1018001ddfb76b06e33c4569d525", "filename": "gcc/testsuite/gfortran.dg/submodule_4.f90", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_4.f90?ref=4668d6f9c00d476786cfe4ee765d2da2afd3d114", "patch": "@@ -0,0 +1,140 @@\n+! { dg-do compile }\n+!\n+! Tests comparisons of MODULE PROCEDURE characteristics and\n+! the characteristics of their dummies. Also tests the error\n+! arising from redefining dummies and results in MODULE\n+! procedures.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+ module foo_interface\n+   implicit none\n+   type foo\n+     character(len=16) :: greeting = \"Hello, world!   \"\n+     character(len=16), private :: byebye = \"adieu, world!   \"\n+   end type foo\n+\n+   interface\n+     module function array1(this) result (that)\n+       type(foo), intent(in), dimension(:) :: this\n+       type(foo), allocatable, dimension(:) :: that\n+     end function\n+     character(16) module function array2(this, that)\n+       type(foo), intent(in), dimension(:) :: this\n+       type(foo), allocatable, dimension(:) :: that\n+     end function\n+     module subroutine array3(this, that)\n+       type(foo), intent(in), dimension(:) :: this\n+       type(foo), intent(inOUT), allocatable, dimension(:) :: that\n+     end subroutine\n+     module subroutine array4(this, that)\n+       type(foo), intent(in), dimension(:) :: this\n+       type(foo), intent(inOUT), allocatable, dimension(:) :: that\n+     end subroutine\n+     integer module function scalar1 (arg)\n+        real, intent(in) :: arg\n+     end function\n+     module function scalar2 (arg) result(res)\n+        real, intent(in) :: arg\n+        real :: res\n+     end function\n+      module function scalar3 (arg) result(res)\n+        real, intent(in) :: arg\n+        real :: res\n+     end function\n+      module function scalar4 (arg) result(res)\n+        real, intent(in) :: arg\n+        complex :: res\n+     end function\n+      module function scalar5 (arg) result(res)\n+        real, intent(in) :: arg\n+        real, allocatable :: res\n+     end function\n+      module function scalar6 (arg) result(res)\n+        real, intent(in) :: arg\n+        real, allocatable :: res\n+     end function\n+      module function scalar7 (arg) result(res)\n+        real, intent(in) :: arg\n+        real, allocatable :: res\n+     end function\n+   end interface\n+ end module\n+\n+!\n+  SUBMODULE (foo_interface) foo_interface_son\n+!\n+  contains\n+\n+     module function array1 (this) result(that) ! { dg-error \"Rank mismatch in function result\" }\n+       type(foo), intent(in), dimension(:) :: this\n+       type(foo), allocatable :: that\n+     end function\n+\n+     character(16) module function array2(this) ! { dg-error \"Mismatch in number of MODULE PROCEDURE formal arguments\" }\n+       type(foo), intent(in), dimension(:) :: this\n+       type(foo), allocatable, dimension(:) :: that\n+       allocate (that(2), source = this(1))\n+       that%greeting = that%byebye\n+       array2 = trim (that(size (that))%greeting(1:5))//\", people!\"\n+     end function\n+\n+     module subroutine array3(thiss, that) ! { dg-error \"Mismatch in MODULE PROCEDURE formal argument names\" }\n+       type(foo), intent(in), dimension(:) :: thiss\n+       type(foo), intent(inOUT), allocatable, dimension(:) :: that\n+       allocate (that(size(thiss)), source = thiss)\n+       that%greeting = that%byebye\n+     end subroutine\n+\n+     module subroutine array4(this, that, the_other) ! { dg-error \"Mismatch in number of MODULE PROCEDURE formal arguments\" }\n+       type(foo), intent(in), dimension(:) :: this\n+       type(foo), intent(inOUT), allocatable, dimension(:) :: that, the_other\n+       integer :: i\n+       allocate (that(size(this)), source = this)\n+       that%greeting = that%byebye\n+       do i = 1, size (that)\n+         that(i)%greeting = trim (that(i)%greeting(1:5))//\", people!\"\n+       end do\n+     end subroutine\n+\n+     recursive module function scalar1 (arg) ! { dg-error \"Mismatch in RECURSIVE\" }\n+        real, intent(in) :: arg\n+     end function\n+\n+     pure module function scalar2 (arg) result(res) ! { dg-error \"Mismatch in PURE\" }\n+        real, intent(in) :: arg\n+        real :: res\n+     end function\n+\n+     module procedure scalar7\n+       real, intent(in) :: arg ! { dg-error \"redefinition of the declaration\" }\n+       real, allocatable :: res ! { dg-error \"redefinition of the declaration\" }\n+     end function ! { dg-error \"Expecting END PROCEDURE statement\" }\n+     end procedure ! This prevents a cascade of errors.\n+  end SUBMODULE foo_interface_son\n+\n+!\n+  SUBMODULE (foo_interface) foo_interface_daughter\n+!\n+  contains\n+\n+      module function scalar3 (arg) result(res) ! { dg-error \"Type mismatch in argument\" }\n+        integer, intent(in) :: arg\n+        real :: res\n+     end function\n+\n+      module function scalar4 (arg) result(res) ! { dg-error \"Type mismatch in function result\" }\n+        real, intent(in) :: arg\n+        real :: res\n+     end function\n+\n+      module function scalar5 (arg) result(res) ! { dg-error \"ALLOCATABLE attribute mismatch in function result \" }\n+        real, intent(in) :: arg\n+        real :: res\n+     end function\n+\n+      module function scalar6 (arg) result(res) ! { dg-error \"Rank mismatch in argument\" }\n+        real, intent(in), dimension(2) :: arg\n+        real, allocatable :: res\n+     end function\n+  end SUBMODULE foo_interface_daughter"}, {"sha": "3141c4c4c99a34475852ae2870b24df6e9aab7fc", "filename": "gcc/testsuite/gfortran.dg/submodule_5.f90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_5.f90?ref=4668d6f9c00d476786cfe4ee765d2da2afd3d114", "patch": "@@ -0,0 +1,51 @@\n+! { dg-do compile }\n+!\n+! Checks that PRIVATE/PUBLIC not allowed in submodules. Also, IMPORT\n+! is not allowed in a module procedure interface body.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+module foo_interface\n+  implicit none\n+  type foo\n+    character(len=16), private :: byebye = \"adieu, world!   \"\n+  end type foo\n+end module\n+\n+module foo_interface_brother\n+  use foo_interface\n+  implicit none\n+  interface\n+     module subroutine array3(this, that)\n+       import ! { dg-error \"not permitted in a module procedure interface body\" }\n+       type(foo), intent(in), dimension(:) :: this\n+       type(foo), intent(inOUT), allocatable, dimension(:) :: that\n+     end subroutine\n+  end interface\n+end module\n+\n+SUBMODULE (foo_interface) foo_interface_son\n+  private ! { dg-error \"PRIVATE statement\" }\n+  public ! { dg-error \"PUBLIC statement\" }\n+  integer, public :: i ! { dg-error \"PUBLIC attribute\" }\n+  integer, private :: j ! { dg-error \"PRIVATE attribute\" }\n+  type :: bar\n+    private ! { dg-error \"PRIVATE statement\" }\n+    public ! { dg-error \"PUBLIC statement\" }\n+    integer, private :: i ! { dg-error \"PRIVATE attribute\" }\n+    integer, public :: j ! { dg-error \"PUBLIC attribute\" }\n+  end type bar\n+contains\n+!\n+end submodule foo_interface_son\n+\n+SUBMODULE (foo_interface) foo_interface_daughter\n+!\n+contains\n+  subroutine foobar (arg)\n+    type(foo) :: arg\n+    arg%byebye = \"hello, world!   \" ! Access to private component is OK\n+  end subroutine\n+end SUBMODULE foo_interface_daughter\n+\n+end"}, {"sha": "b018b59f3dafba768086b45de8d96c4ec5e1d25b", "filename": "gcc/testsuite/gfortran.dg/submodule_6.f90", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_6.f90?ref=4668d6f9c00d476786cfe4ee765d2da2afd3d114", "patch": "@@ -0,0 +1,91 @@\n+! { dg-do run }\n+!\n+! Checks that the results of module procedures have the correct characteristics.\n+!\n+! Contributed by Reinhold Bader  <reinhold.bader@lrz.de>\n+!\n+module mod_a\n+  implicit none\n+  type, abstract :: t_a\n+  end type t_a\n+  interface\n+    module subroutine p_a(this, q)\n+      class(t_a), intent(inout) :: this\n+      class(*), intent(in) :: q\n+    end subroutine\n+    module function create_a() result(r)\n+      class(t_a), allocatable :: r\n+    end function\n+    module subroutine print(this)\n+      class(t_a), intent(in) :: this\n+    end subroutine\n+  end interface\n+end module mod_a\n+\n+module mod_b\n+  implicit none\n+  type t_b\n+    integer, allocatable :: I(:)\n+  end type t_b\n+  interface\n+    module function create_b(i) result(r)\n+      type(t_b) :: r\n+      integer :: i(:)\n+    end function\n+  end interface\n+end module mod_b\n+\n+submodule(mod_b) imp_create\n+contains\n+  module procedure create_b\n+    if (allocated(r%i)) deallocate(r%i)\n+    allocate(r%i, source=i)\n+  end procedure\n+end submodule imp_create\n+\n+submodule(mod_a) imp_p_a\n+  use mod_b\n+  type, extends(t_a) :: t_imp\n+    type(t_b) :: b\n+  end type t_imp\n+  integer, parameter :: ii(2) = [1,2]\n+contains\n+  module procedure create_a\n+    type(t_b) :: b\n+    b = create_b(ii)\n+    allocate(r, source=t_imp(b))\n+  end procedure\n+\n+  module procedure  p_a\n+    select type (this)\n+      type is (t_imp)\n+        select type (q)\n+          type is (t_b)\n+            this%b = q\n+          class default\n+            call abort\n+         end select\n+      class default\n+        call abort\n+      end select\n+  end procedure p_a\n+  module procedure print\n+    select type (this)\n+      type is (t_imp)\n+        if (any (this%b%i .ne. [3,4,5])) call abort\n+      class default\n+        call abort\n+    end select\n+  end procedure\n+end submodule imp_p_a\n+\n+program p\n+  use mod_a\n+  use mod_b\n+  implicit none\n+  class(t_a), allocatable :: a\n+  allocate(a, source=create_a())\n+  call p_a(a, create_b([3,4,5]))\n+  call print(a)\n+end program p\n+"}, {"sha": "fd1bee6296c229924292749a243be74e97bb6edf", "filename": "gcc/testsuite/gfortran.dg/submodule_7.f90", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4668d6f9c00d476786cfe4ee765d2da2afd3d114/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_7.f90?ref=4668d6f9c00d476786cfe4ee765d2da2afd3d114", "patch": "@@ -0,0 +1,147 @@\n+! { dg-do run }\n+!\n+! Example in F2008 C.8.4 to demonstrate submodules\n+!\n+module color_points\n+  type color_point\n+    private\n+    real :: x, y\n+    integer :: color\n+  end type color_point\n+\n+  interface\n+! Interfaces for procedures with separate\n+! bodies in the submodule color_points_a\n+    module subroutine color_point_del ( p ) ! Destroy a color_point object\n+      type(color_point), allocatable :: p\n+    end subroutine color_point_del\n+! Distance between two color_point objects\n+    real module function color_point_dist ( a, b )\n+      type(color_point), intent(in) :: a, b\n+    end function color_point_dist\n+    module subroutine color_point_draw ( p ) ! Draw a color_point object\n+      type(color_point), intent(in) :: p\n+    end subroutine color_point_draw\n+    module subroutine color_point_new ( p ) ! Create a color_point object\n+      type(color_point), allocatable :: p\n+    end subroutine color_point_new\n+    module subroutine verify_cleanup ( p1, p2 ) ! Check cleanup of color_point objects\n+      type(color_point), allocatable :: p1, p2\n+    end subroutine verify_cleanup\n+  end interface\n+end module color_points\n+\n+module palette_stuff\n+  type :: palette ;\n+!...\n+  end type palette\n+contains\n+  subroutine test_palette ( p )\n+! Draw a color wheel using procedures from the color_points module\n+    use color_points ! This does not cause a circular dependency because\n+! the \"use palette_stuff\" that is logically within\n+! color_points is in the color_points_a submodule.\n+    type(palette), intent(in) :: p\n+  end subroutine test_palette\n+end module palette_stuff\n+\n+\n+submodule ( color_points ) color_points_a ! Submodule of color_points\n+  integer :: instance_count = 0\n+  interface\n+! Interface for a procedure with a separate\n+! body in submodule color_points_b\n+    module subroutine inquire_palette ( pt, pal )\n+      use palette_stuff\n+! palette_stuff, especially submodules\n+! thereof, can reference color_points by use\n+! association without causing a circular\n+! dependence during translation because this\n+! use is not in the module. Furthermore,\n+! changes in the module palette_stuff do not\n+! affect the translation of color_points.\n+      type(color_point), intent(in) :: pt\n+      type(palette), intent(out) :: pal\n+    end subroutine inquire_palette\n+  end interface\n+contains\n+! Invisible bodies for public separate module procedures\n+! declared in the module\n+  module subroutine color_point_del ( p )\n+    type(color_point), allocatable :: p\n+    instance_count = instance_count - 1\n+    deallocate ( p )\n+  end subroutine color_point_del\n+  real module function color_point_dist ( a, b ) result ( dist )\n+    type(color_point), intent(in) :: a, b\n+    dist = sqrt( (b%x - a%x)**2 + (b%y - a%y)**2 )\n+  end function color_point_dist\n+  module subroutine color_point_new ( p )\n+    type(color_point), allocatable :: p\n+    instance_count = instance_count + 1\n+    allocate ( p )\n+! Added to example so that it does something.\n+    p%x = real (instance_count) * 1.0\n+    p%y = real (instance_count) * 2.0\n+    p%color = instance_count\n+  end subroutine color_point_new\n+end submodule color_points_a\n+\n+\n+submodule ( color_points:color_points_a ) color_points_b ! Subsidiary**2 submodule\n+\n+contains\n+! Invisible body for interface declared in the ancestor module\n+  module subroutine color_point_draw ( p )\n+    use palette_stuff, only: palette\n+    type(color_point), intent(in) :: p\n+    type(palette) :: MyPalette\n+    call inquire_palette ( p, MyPalette )\n+! Added to example so that it does something.\n+    if (abs (p%x - real (p%color) * 1.0) .gt. 1.0e-6) call abort\n+    if (abs (p%y - real (p%color) * 2.0) .gt. 1.0e-6) call abort\n+  end subroutine color_point_draw\n+! Invisible body for interface declared in the parent submodule\n+  module procedure inquire_palette\n+!... implementation of inquire_palette\n+  end procedure inquire_palette\n+  module procedure verify_cleanup\n+    if (allocated (p1) .or. allocated (p2)) call abort\n+    if (instance_count .ne. 0) call abort\n+  end procedure\n+  subroutine private_stuff ! not accessible from color_points_a\n+!...\n+  end subroutine private_stuff\n+end submodule color_points_b\n+\n+\n+program main\n+  use color_points\n+! \"instance_count\" and \"inquire_palette\" are not accessible here\n+! because they are not declared in the \"color_points\" module.\n+! \"color_points_a\" and \"color_points_b\" cannot be referenced by\n+! use association.\n+  interface draw\n+! just to demonstrate it\u2019s possible\n+    module procedure color_point_draw\n+  end interface\n+  type(color_point), allocatable :: C_1, C_2\n+  real :: RC\n+!...\n+  call color_point_new (c_1)\n+  call color_point_new (c_2)\n+! body in color_points_a, interface in color_points\n+!...\n+  call draw (c_1)\n+! body in color_points_b, specific interface\n+! in color_points, generic interface here.\n+!...\n+  rc = color_point_dist (c_1, c_2) ! body in color_points_a, interface in color_points\n+  if (abs (rc - 2.23606801) .gt. 1.0e-6) call abort\n+!...\n+  call color_point_del (c_1)\n+  call color_point_del (c_2)\n+! body in color_points_a, interface in color_points\n+  call verify_cleanup (c_1, c_2)\n+!...\n+end program main"}]}