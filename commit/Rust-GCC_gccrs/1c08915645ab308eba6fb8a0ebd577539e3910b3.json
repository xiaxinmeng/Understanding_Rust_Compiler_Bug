{"sha": "1c08915645ab308eba6fb8a0ebd577539e3910b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWMwODkxNTY0NWFiMzA4ZWJhNmZiOGEwZWJkNTc3NTM5ZTM5MTBiMw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@casey.cygnus.com", "date": "2000-03-08T09:07:36Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-03-08T09:07:36Z"}, "message": "Add initial support for '\\uNNNN' specifier.\n\n        * lex.c (read_ucs): New fn.\n        (readescape, skip_white_space): Call it.\n        (is_extended_char, is_extended_char_1): New fns.\n        (utf8_extend_token): New fn, #if 0'd out.\n        (real_yylex): Treat extended chars like letters.\n\nFrom-SVN: r32414", "tree": {"sha": "f3825b784f6f4350ee57f2d0d99203a984ff7831", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3825b784f6f4350ee57f2d0d99203a984ff7831"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c08915645ab308eba6fb8a0ebd577539e3910b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c08915645ab308eba6fb8a0ebd577539e3910b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c08915645ab308eba6fb8a0ebd577539e3910b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c08915645ab308eba6fb8a0ebd577539e3910b3/comments", "author": null, "committer": null, "parents": [{"sha": "f48d005079fcc19e695fb4d9274b68287eeaa123", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f48d005079fcc19e695fb4d9274b68287eeaa123", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f48d005079fcc19e695fb4d9274b68287eeaa123"}], "stats": {"total": 424, "additions": 419, "deletions": 5}, "files": [{"sha": "4b7c03c7ed5953d1a06a2ed544991bb871f1e5b7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c08915645ab308eba6fb8a0ebd577539e3910b3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c08915645ab308eba6fb8a0ebd577539e3910b3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1c08915645ab308eba6fb8a0ebd577539e3910b3", "patch": "@@ -1,5 +1,12 @@\n 2000-03-07  Jason Merrill  <jason@casey.cygnus.com>\n \n+\tAdd initial support for '\\uNNNN' specifier.\n+\t* lex.c (read_ucs): New fn.\n+\t(readescape, skip_white_space): Call it.\n+\t(is_extended_char, is_extended_char_1): New fns.\n+\t(utf8_extend_token): New fn, #if 0'd out.\n+\t(real_yylex): Treat extended chars like letters.\n+\n \t* search.c (note_debug_info_needed): Walk the bases even if we \n \tweren't deferring the type itself.\n "}, {"sha": "45037aa8ada075a057ad1af8429b63be1903766d", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 412, "deletions": 5, "changes": 417, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c08915645ab308eba6fb8a0ebd577539e3910b3/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c08915645ab308eba6fb8a0ebd577539e3910b3/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=1c08915645ab308eba6fb8a0ebd577539e3910b3", "patch": "@@ -90,6 +90,9 @@ static int read_line_number PARAMS ((int *));\n static int token_getch PARAMS ((void));\n static void token_put_back PARAMS ((int));\n static void mark_impl_file_chain PARAMS ((void *));\n+static int read_ucs PARAMS ((int));\n+static int is_extended_char PARAMS ((int));\n+static int is_extended_char_1 PARAMS ((int));\n \n /* Given a file name X, return the nondirectory portion.\n    Keep in mind that X can be computed more than once.  */\n@@ -2236,10 +2239,16 @@ skip_white_space (c)\n \tcase '\\\\':\n \t  c = getch ();\n \t  if (c == '\\n')\n-\t    lineno++;\n+\t    {\n+\t      lineno++;\n+\t      c = getch ();\n+\t    }\n+\t  else if (c == 'u')\n+\t    c = read_ucs (4);\n+\t  else if (c == 'U')\n+\t    c = read_ucs (8);\n \t  else\n \t    error (\"stray '\\\\' in program\");\n-\t  c = getch ();\n \t  break;\n \n \tdefault:\n@@ -2799,6 +2808,376 @@ do_pending_lang_change ()\n     pop_lang_context ();\n }\n \f\n+/* Parse a '\\uNNNN' or '\\UNNNNNNNN' sequence.\n+\n+   [lex.charset]: The character designated by the universal-character-name \n+   \\UNNNNNNNN is that character whose character short name in ISO/IEC 10646\n+   is NNNNNNNN; the character designated by the universal-character-name\n+   \\uNNNN is that character whose character short name in ISO/IEC 10646 is\n+   0000NNNN. If the hexadecimal value for a universal character name is\n+   less than 0x20 or in the range 0x7F-0x9F (inclusive), or if the\n+   universal character name designates a character in the basic source\n+   character set, then the program is ill-formed.\n+\n+   We assume that wchar_t is Unicode, so we don't need to do any\n+   mapping.  Is this ever wrong?  */\n+\n+static int\n+read_ucs (length)\n+     int length;\n+{\n+  unsigned int code = 0;\n+  int c;\n+\n+  for (; length; --length)\n+    {\n+      c = getch ();\n+      if (! ISXDIGIT (c))\n+\t{\n+\t  error (\"non hex digit '%c' in universal-character-name\", c);\n+\t  put_back (c);\n+\t  break;\n+\t}\n+      code <<= 4;\n+      if (c >= 'a' && c <= 'f')\n+\tcode += c - 'a' + 10;\n+      if (c >= 'A' && c <= 'F')\n+\tcode += c - 'A' + 10;\n+      if (c >= '0' && c <= '9')\n+\tcode += c - '0';\n+    }\n+\n+#ifdef TARGET_EBCDIC\n+  sorry (\"universal-character-name on EBCDIC target\");\n+  return 0x3F;\n+#endif\n+\n+  if (code > 0x9f && !(code & 0x80000000))\n+    /* True extended character, OK.  */;\n+  else if (code >= 0x20 && code < 0x7f)\n+    {\n+      /* ASCII printable character.  The C character set consists of all of\n+\t these except $, @ and `.  We use hex escapes so that this also\n+\t works with EBCDIC hosts.  */\n+      if (code != 0x24 && code != 0x40 && code != 0x60)\n+\terror (\"universal-character-name designates `%c', part of the basic source character set\", code);\n+    }\n+  else\n+    error (\"invalid universal-character-name\");\n+  return code;\n+}\n+\n+/* Returns nonzero if C is a universal-character-name.  Give an error if it\n+   is not one which may appear in an identifier, as per [extendid].  */\n+\n+static inline int\n+is_extended_char (c)\n+     int c;\n+{\n+#ifdef TARGET_EBCDIC\n+  return 0;\n+#else\n+  /* ASCII.  */\n+  if (c < 0x7f)\n+    return 0;\n+  \n+  return is_extended_char_1 (c);\n+#endif\n+}\n+\n+static int\n+is_extended_char_1 (c)\n+     int c;\n+{\n+  /* None of the valid chars are outside the Basic Multilingual Plane (the\n+     low 16 bits).  */\n+  if (c > 0xffff)\n+    {\n+      error (\"universal-character-name `\\\\U%08x' not valid in identifier\", c);\n+      return 1;\n+    }\n+  \n+  /* Latin */\n+  if ((c >= 0x00c0 && c <= 0x00d6)\n+      || (c >= 0x00d8 && c <= 0x00f6)\n+      || (c >= 0x00f8 && c <= 0x01f5)\n+      || (c >= 0x01fa && c <= 0x0217)\n+      || (c >= 0x0250 && c <= 0x02a8)\n+      || (c >= 0x1e00 && c <= 0x1e9a)\n+      || (c >= 0x1ea0 && c <= 0x1ef9))\n+    return 1;\n+\n+  /* Greek */\n+  if ((c == 0x0384)\n+      || (c >= 0x0388 && c <= 0x038a)\n+      || (c == 0x038c)\n+      || (c >= 0x038e && c <= 0x03a1)\n+      || (c >= 0x03a3 && c <= 0x03ce)\n+      || (c >= 0x03d0 && c <= 0x03d6)\n+      || (c == 0x03da)\n+      || (c == 0x03dc)\n+      || (c == 0x03de)\n+      || (c == 0x03e0)\n+      || (c >= 0x03e2 && c <= 0x03f3)\n+      || (c >= 0x1f00 && c <= 0x1f15)\n+      || (c >= 0x1f18 && c <= 0x1f1d)\n+      || (c >= 0x1f20 && c <= 0x1f45)\n+      || (c >= 0x1f48 && c <= 0x1f4d)\n+      || (c >= 0x1f50 && c <= 0x1f57)\n+      || (c == 0x1f59)\n+      || (c == 0x1f5b)\n+      || (c == 0x1f5d)\n+      || (c >= 0x1f5f && c <= 0x1f7d)\n+      || (c >= 0x1f80 && c <= 0x1fb4)\n+      || (c >= 0x1fb6 && c <= 0x1fbc)\n+      || (c >= 0x1fc2 && c <= 0x1fc4)\n+      || (c >= 0x1fc6 && c <= 0x1fcc)\n+      || (c >= 0x1fd0 && c <= 0x1fd3)\n+      || (c >= 0x1fd6 && c <= 0x1fdb)\n+      || (c >= 0x1fe0 && c <= 0x1fec)\n+      || (c >= 0x1ff2 && c <= 0x1ff4)\n+      || (c >= 0x1ff6 && c <= 0x1ffc))\n+    return 1;\n+\n+  /* Cyrillic */\n+  if ((c >= 0x0401 && c <= 0x040d)\n+      || (c >= 0x040f && c <= 0x044f)\n+      || (c >= 0x0451 && c <= 0x045c)\n+      || (c >= 0x045e && c <= 0x0481)\n+      || (c >= 0x0490 && c <= 0x04c4)\n+      || (c >= 0x04c7 && c <= 0x04c8)\n+      || (c >= 0x04cb && c <= 0x04cc)\n+      || (c >= 0x04d0 && c <= 0x04eb)\n+      || (c >= 0x04ee && c <= 0x04f5)\n+      || (c >= 0x04f8 && c <= 0x04f9))\n+    return 1;\n+\n+  /* Armenian */\n+  if ((c >= 0x0531 && c <= 0x0556)\n+      || (c >= 0x0561 && c <= 0x0587))\n+    return 1;\n+\n+  /* Hebrew */\n+  if ((c >= 0x05d0 && c <= 0x05ea)\n+      || (c >= 0x05f0 && c <= 0x05f4))\n+    return 1;\n+\n+  /* Arabic */\n+  if ((c >= 0x0621 && c <= 0x063a)\n+      || (c >= 0x0640 && c <= 0x0652)\n+      || (c >= 0x0670 && c <= 0x06b7)\n+      || (c >= 0x06ba && c <= 0x06be)\n+      || (c >= 0x06c0 && c <= 0x06ce)\n+      || (c >= 0x06e5 && c <= 0x06e7))\n+    return 1;\n+\n+  /* Devanagari */\n+  if ((c >= 0x0905 && c <= 0x0939)\n+      || (c >= 0x0958 && c <= 0x0962))\n+    return 1;\n+\n+  /* Bengali */\n+  if ((c >= 0x0985 && c <= 0x098c)\n+      || (c >= 0x098f && c <= 0x0990)\n+      || (c >= 0x0993 && c <= 0x09a8)\n+      || (c >= 0x09aa && c <= 0x09b0)\n+      || (c == 0x09b2)\n+      || (c >= 0x09b6 && c <= 0x09b9)\n+      || (c >= 0x09dc && c <= 0x09dd)\n+      || (c >= 0x09df && c <= 0x09e1)\n+      || (c >= 0x09f0 && c <= 0x09f1))\n+    return 1;\n+\n+  /* Gurmukhi */\n+  if ((c >= 0x0a05 && c <= 0x0a0a)\n+      || (c >= 0x0a0f && c <= 0x0a10)\n+      || (c >= 0x0a13 && c <= 0x0a28)\n+      || (c >= 0x0a2a && c <= 0x0a30)\n+      || (c >= 0x0a32 && c <= 0x0a33)\n+      || (c >= 0x0a35 && c <= 0x0a36)\n+      || (c >= 0x0a38 && c <= 0x0a39)\n+      || (c >= 0x0a59 && c <= 0x0a5c)\n+      || (c == 0x0a5e))\n+    return 1;\n+\n+  /* Gujarati */\n+  if ((c >= 0x0a85 && c <= 0x0a8b)\n+      || (c == 0x0a8d)\n+      || (c >= 0x0a8f && c <= 0x0a91)\n+      || (c >= 0x0a93 && c <= 0x0aa8)\n+      || (c >= 0x0aaa && c <= 0x0ab0)\n+      || (c >= 0x0ab2 && c <= 0x0ab3)\n+      || (c >= 0x0ab5 && c <= 0x0ab9)\n+      || (c == 0x0ae0))\n+    return 1;\n+\n+  /* Oriya */\n+  if ((c >= 0x0b05 && c <= 0x0b0c)\n+      || (c >= 0x0b0f && c <= 0x0b10)\n+      || (c >= 0x0b13 && c <= 0x0b28)\n+      || (c >= 0x0b2a && c <= 0x0b30)\n+      || (c >= 0x0b32 && c <= 0x0b33)\n+      || (c >= 0x0b36 && c <= 0x0b39)\n+      || (c >= 0x0b5c && c <= 0x0b5d)\n+      || (c >= 0x0b5f && c <= 0x0b61))\n+    return 1;\n+\n+  /* Tamil */\n+  if ((c >= 0x0b85 && c <= 0x0b8a)\n+      || (c >= 0x0b8e && c <= 0x0b90)\n+      || (c >= 0x0b92 && c <= 0x0b95)\n+      || (c >= 0x0b99 && c <= 0x0b9a)\n+      || (c == 0x0b9c)\n+      || (c >= 0x0b9e && c <= 0x0b9f)\n+      || (c >= 0x0ba3 && c <= 0x0ba4)\n+      || (c >= 0x0ba8 && c <= 0x0baa)\n+      || (c >= 0x0bae && c <= 0x0bb5)\n+      || (c >= 0x0bb7 && c <= 0x0bb9))\n+    return 1;\n+\n+  /* Telugu */\n+  if ((c >= 0x0c05 && c <= 0x0c0c)\n+      || (c >= 0x0c0e && c <= 0x0c10)\n+      || (c >= 0x0c12 && c <= 0x0c28)\n+      || (c >= 0x0c2a && c <= 0x0c33)\n+      || (c >= 0x0c35 && c <= 0x0c39)\n+      || (c >= 0x0c60 && c <= 0x0c61))\n+    return 1;\n+\n+  /* Kannada */\n+  if ((c >= 0x0c85 && c <= 0x0c8c)\n+      || (c >= 0x0c8e && c <= 0x0c90)\n+      || (c >= 0x0c92 && c <= 0x0ca8)\n+      || (c >= 0x0caa && c <= 0x0cb3)\n+      || (c >= 0x0cb5 && c <= 0x0cb9)\n+      || (c >= 0x0ce0 && c <= 0x0ce1))\n+    return 1;\n+\n+  /* Malayalam */\n+  if ((c >= 0x0d05 && c <= 0x0d0c)\n+      || (c >= 0x0d0e && c <= 0x0d10)\n+      || (c >= 0x0d12 && c <= 0x0d28)\n+      || (c >= 0x0d2a && c <= 0x0d39)\n+      || (c >= 0x0d60 && c <= 0x0d61))\n+    return 1;\n+\n+  /* Thai */\n+  if ((c >= 0x0e01 && c <= 0x0e30)\n+      || (c >= 0x0e32 && c <= 0x0e33)\n+      || (c >= 0x0e40 && c <= 0x0e46)\n+      || (c >= 0x0e4f && c <= 0x0e5b))\n+    return 1;\n+\n+  /* Lao */\n+  if ((c >= 0x0e81 && c <= 0x0e82)\n+      || (c == 0x0e84)\n+      || (c == 0x0e87)\n+      || (c == 0x0e88)\n+      || (c == 0x0e8a)\n+      || (c == 0x0e0d)\n+      || (c >= 0x0e94 && c <= 0x0e97)\n+      || (c >= 0x0e99 && c <= 0x0e9f)\n+      || (c >= 0x0ea1 && c <= 0x0ea3)\n+      || (c == 0x0ea5)\n+      || (c == 0x0ea7)\n+      || (c == 0x0eaa)\n+      || (c == 0x0eab)\n+      || (c >= 0x0ead && c <= 0x0eb0)\n+      || (c == 0x0eb2)\n+      || (c == 0x0eb3)\n+      || (c == 0x0ebd)\n+      || (c >= 0x0ec0 && c <= 0x0ec4)\n+      || (c == 0x0ec6))\n+    return 1;\n+\n+  /* Georgian */\n+  if ((c >= 0x10a0 && c <= 0x10c5)\n+      || (c >= 0x10d0 && c <= 0x10f6))\n+    return 1;\n+\n+  /* Hiragana */\n+  if ((c >= 0x3041 && c <= 0x3094)\n+      || (c >= 0x309b && c <= 0x309e))\n+    return 1;\n+\n+  /* Katakana */\n+  if ((c >= 0x30a1 && c <= 0x30fe))\n+    return 1;\n+\n+  /* Bopmofo */\n+  if ((c >= 0x3105 && c <= 0x312c))\n+    return 1;\n+\n+  /* Hangul */\n+  if ((c >= 0x1100 && c <= 0x1159)\n+      || (c >= 0x1161 && c <= 0x11a2)\n+      || (c >= 0x11a8 && c <= 0x11f9))\n+    return 1;\n+\n+  /* CJK Unified Ideographs */\n+  if ((c >= 0xf900 && c <= 0xfa2d)\n+      || (c >= 0xfb1f && c <= 0xfb36)\n+      || (c >= 0xfb38 && c <= 0xfb3c)\n+      || (c == 0xfb3e)\n+      || (c >= 0xfb40 && c <= 0xfb41)\n+      || (c >= 0xfb42 && c <= 0xfb44)\n+      || (c >= 0xfb46 && c <= 0xfbb1)\n+      || (c >= 0xfbd3 && c <= 0xfd3f)\n+      || (c >= 0xfd50 && c <= 0xfd8f)\n+      || (c >= 0xfd92 && c <= 0xfdc7)\n+      || (c >= 0xfdf0 && c <= 0xfdfb)\n+      || (c >= 0xfe70 && c <= 0xfe72)\n+      || (c == 0xfe74)\n+      || (c >= 0xfe76 && c <= 0xfefc)\n+      || (c >= 0xff21 && c <= 0xff3a)\n+      || (c >= 0xff41 && c <= 0xff5a)\n+      || (c >= 0xff66 && c <= 0xffbe)\n+      || (c >= 0xffc2 && c <= 0xffc7)\n+      || (c >= 0xffca && c <= 0xffcf)\n+      || (c >= 0xffd2 && c <= 0xffd7)\n+      || (c >= 0xffda && c <= 0xffdc)\n+      || (c >= 0x4e00 && c <= 0x9fa5))\n+    return 1;\n+\n+  error (\"universal-character-name `\\\\u%04x' not valid in identifier\", c);\n+  return 1;\n+}\n+\n+#if 0\n+/* Add the UTF-8 representation of C to the token_buffer.  */\n+\n+static void\n+utf8_extend_token (c)\n+     int c;\n+{\n+  int shift, mask;\n+\n+  if      (c <= 0x0000007f)\n+    {\n+      extend_token (c);\n+      return;\n+    }\n+  else if (c <= 0x000007ff)\n+    shift = 6, mask = 0xc0;\n+  else if (c <= 0x0000ffff)\n+    shift = 12, mask = 0xe0;\n+  else if (c <= 0x001fffff)\n+    shift = 18, mask = 0xf0;\n+  else if (c <= 0x03ffffff)\n+    shift = 24, mask = 0xf8;\n+  else\n+    shift = 30, mask = 0xfc;\n+\n+  extend_token (mask | (c >> shift));\n+  do\n+    {\n+      shift -= 6;\n+      extend_token ((unsigned char) (0x80 | (c >> shift)));\n+    }\n+  while (shift);\n+}\n+#endif\n+\f\n #define ENDFILE -1  /* token that represents end-of-file */\n \n /* Read an escape sequence, returning its equivalent as a character,\n@@ -2869,6 +3248,11 @@ readescape (ignore_ptr)\n       put_back (c);\n       return code;\n \n+    case 'U':\n+      return read_ucs (8);\n+    case 'u':\n+      return read_ucs (4);\n+\n     case '\\\\': case '\\'': case '\"':\n       return c;\n \n@@ -3542,8 +3926,8 @@ real_yylex ()\n     case 'z':\n     case '_':\n     case '$':\n-#if USE_CPPLIB\n     letter:\n+#if USE_CPPLIB\n       if (cpp_token == CPP_NAME)\n \t{\n \t  /* Note that one character has already been read from\n@@ -3561,22 +3945,43 @@ real_yylex ()\n #endif\n \t{\n \t  p = token_buffer;\n-\t  while (ISALNUM (c) || (c == '_') || c == '$')\n+\t  while (1)\n \t    {\n \t      /* Make sure this char really belongs in an identifier.  */\n-\t      if (c == '$')\n+\t      if (ISALNUM (c) || c == '_')\n+\t\t/* OK */;\n+\t      else if (c == '$')\n \t\t{\n \t\t  if (! dollars_in_ident)\n \t\t    error (\"`$' in identifier\");\n \t\t  else if (pedantic)\n \t\t    pedwarn (\"`$' in identifier\");\n \t\t}\n+\t      /* FIXME we should use some sort of multibyte character\n+\t\t encoding.  Locale-dependent?  Always UTF-8?  */\n+\t      else if (is_extended_char (c))\n+\t\t{\n+\t\t  sorry (\"universal characters in identifiers\");\n+\t\t  c = '_';\n+\t\t}\n+\t      else\n+\t\tbreak;\n \n \t      if (p >= token_buffer + maxtoken)\n \t\tp = extend_token_buffer (p);\n \n \t      *p++ = c;\n+\n+\t    idtryagain:\n \t      c = token_getch ();\n+\t      \n+\t      if (c == '\\\\')\n+\t\t{\n+\t\t  int ignore = 0;\n+\t\t  c = readescape (&ignore);\n+\t\t  if (ignore)\n+\t\t    goto idtryagain;\n+\t\t}\n \t    }\n \n \t  *p = 0;\n@@ -4634,6 +5039,8 @@ real_yylex ()\n       break;\n \n     default:\n+      if (is_extended_char (c))\n+\tgoto letter;\n       value = c;\n     }\n "}]}