{"sha": "aaec3d850a73cd951ccec98f2f55d62832ca2ee2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFlYzNkODUwYTczY2Q5NTFjY2VjOThmMmY1NWQ2MjgzMmNhMmVlMg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-11-01T16:54:49Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-11-01T16:54:49Z"}, "message": "tree.h (BLOCK_IN_COLD_SECTION_P): Define.\n\n\t* tree.h (BLOCK_IN_COLD_SECTION_P): Define.\n\t* final.c (final_scan_insn): Set BLOCK_IN_COLD_SECTION_P.\n\t* dwarf2out.c (rnglist_idx): New variable.\n\t(struct dw_ranges): Add label, idx and maybe_new_sec fields.\n\t(DEBUG_RNGLISTS_SECTION): Define.\n\t(ranges_base_label): New variable.\n\t(size_of_die) <case dw_val_class_range_list>: If using\n\tDW_FORM_rnglistx, count size of uleb128 of range list index.\n\t(value_format) <case dw_val_class_range_list>: For\n\t-gdwarf-5 -gsplit-dwarf return DW_FORM_rnglistx.\n\t(output_range_list_offset): Handle -gdwarf-5 .debug_rnglists\n\toffsets.  Multiply dwarf < 5 offsets by 2 * DWARF_ADDR_SIZE.\n\t(add_ranges_num): Remove useless prototype.  Don't multiply\n\tby 2 * DWARF2_ADDR_SIZE.  Add maybe_new_sec argument, adjust\n\tfor new fields added to dw_ranges struct.\n\t(add_ranges): Add maybe_new_sec argument and pass it\n\tthrough to add_ranges_num.\n\t(note_rnglist_head): New function.\n\t(add_ranges_by_labels): Pass true as maybe_new_sec to\n\tadd_ranges_num, call note_rnglist_head on the head of the list.\n\t(output_ranges): Add function comment.  Switch to\n\t.debug_ranges section here and emit .Ldebug_ranges0 label.\n\t(index_rnglists, output_rnglists): New functions.\n\t(gen_subprogram_die): Formatting fixes.\n\t(add_high_low_attributes): Don't divide offsets\n\tby 2 * DWARF2_ADDR_SIZE.  Call note_rnglist_head on the\n\tfirst list element or when pointing into the middle of\n\ta list.  Pass true as second argument to add_ranges on the\n\tfirst block fragment after cold/hot section switch.\n\t(init_sections_and_labels): For -gdwarf-5 use .debug_rnglists\n\tsection instead of .debug_ranges.  Initialize\n\tranges_base_label if -gdwarf-5 -gsplit-dwarf.\n\t(dwarf2out_finish): For -gdwarf-5 -gsplit-dwarf call\n\tindex_rnglists and add DW_AT_rnglists_base attr.  Don't switch\n\tto dwarf_ranges_section here or emit .Ldebug_ranges0 label.\n\tCall output_rnglists for -gdwarf-5.\n\t(dwarf2out_c_finalize): Clear rnglist_idx.\n\nFrom-SVN: r241747", "tree": {"sha": "02b07823edbab232ca49394f2171c46ac7d7ad19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02b07823edbab232ca49394f2171c46ac7d7ad19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aaec3d850a73cd951ccec98f2f55d62832ca2ee2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaec3d850a73cd951ccec98f2f55d62832ca2ee2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aaec3d850a73cd951ccec98f2f55d62832ca2ee2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaec3d850a73cd951ccec98f2f55d62832ca2ee2/comments", "author": null, "committer": null, "parents": [{"sha": "f10e37a1c18706b77559684f0ad70c8e50e4a45f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f10e37a1c18706b77559684f0ad70c8e50e4a45f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f10e37a1c18706b77559684f0ad70c8e50e4a45f"}], "stats": {"total": 396, "additions": 348, "deletions": 48}, "files": [{"sha": "e5ae00a48aba83aad1c62e68bc02e143cc611d92", "filename": "gcc/ChangeLog", "status": "modified", "additions": 48, "deletions": 8, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaec3d850a73cd951ccec98f2f55d62832ca2ee2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaec3d850a73cd951ccec98f2f55d62832ca2ee2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aaec3d850a73cd951ccec98f2f55d62832ca2ee2", "patch": "@@ -1,6 +1,46 @@\n+2016-11-01  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* tree.h (BLOCK_IN_COLD_SECTION_P): Define.\n+\t* final.c (final_scan_insn): Set BLOCK_IN_COLD_SECTION_P.\n+\t* dwarf2out.c (rnglist_idx): New variable.\n+\t(struct dw_ranges): Add label, idx and maybe_new_sec fields.\n+\t(DEBUG_RNGLISTS_SECTION): Define.\n+\t(ranges_base_label): New variable.\n+\t(size_of_die) <case dw_val_class_range_list>: If using\n+\tDW_FORM_rnglistx, count size of uleb128 of range list index.\n+\t(value_format) <case dw_val_class_range_list>: For\n+\t-gdwarf-5 -gsplit-dwarf return DW_FORM_rnglistx.\n+\t(output_range_list_offset): Handle -gdwarf-5 .debug_rnglists\n+\toffsets.  Multiply dwarf < 5 offsets by 2 * DWARF_ADDR_SIZE.\n+\t(add_ranges_num): Remove useless prototype.  Don't multiply\n+\tby 2 * DWARF2_ADDR_SIZE.  Add maybe_new_sec argument, adjust\n+\tfor new fields added to dw_ranges struct.\n+\t(add_ranges): Add maybe_new_sec argument and pass it\n+\tthrough to add_ranges_num.\n+\t(note_rnglist_head): New function.\n+\t(add_ranges_by_labels): Pass true as maybe_new_sec to\n+\tadd_ranges_num, call note_rnglist_head on the head of the list.\n+\t(output_ranges): Add function comment.  Switch to\n+\t.debug_ranges section here and emit .Ldebug_ranges0 label.\n+\t(index_rnglists, output_rnglists): New functions.\n+\t(gen_subprogram_die): Formatting fixes.\n+\t(add_high_low_attributes): Don't divide offsets\n+\tby 2 * DWARF2_ADDR_SIZE.  Call note_rnglist_head on the\n+\tfirst list element or when pointing into the middle of\n+\ta list.  Pass true as second argument to add_ranges on the\n+\tfirst block fragment after cold/hot section switch.\n+\t(init_sections_and_labels): For -gdwarf-5 use .debug_rnglists\n+\tsection instead of .debug_ranges.  Initialize\n+\tranges_base_label if -gdwarf-5 -gsplit-dwarf.\n+\t(dwarf2out_finish): For -gdwarf-5 -gsplit-dwarf call\n+\tindex_rnglists and add DW_AT_rnglists_base attr.  Don't switch\n+\tto dwarf_ranges_section here or emit .Ldebug_ranges0 label.\n+\tCall output_rnglists for -gdwarf-5.\n+\t(dwarf2out_c_finalize): Clear rnglist_idx.\n+\n 2016-11-01  Fritz Reese  <fritzoreese@gmail.com>\n \n-\t* gcc/combine.c (simplify_compare_const): Add gcc_fallthrough.\n+\t* combine.c (simplify_compare_const): Add gcc_fallthrough.\n \n 2016-11-01  Bilyan Borisov  <bilyan.borisov@arm.com>\n \t    Tamar Christina <tamar.christina@arm.com>\n@@ -2250,7 +2290,7 @@\n \n 2016-10-14  Catherine Moore  <clm@codesourcery.com>\n \n-\t* gcc/config/mips/mips.c (mips_prepare_pch_save): Initialize\n+\t* config/mips/mips.c (mips_prepare_pch_save): Initialize\n \tmicromips_globals to zero.\n \n 2016-10-14  Richard Biener  <rguenther@suse.de>\n@@ -5401,8 +5441,8 @@\n \t(arm_elf_section_type_flags): New.\n \t* config/arm/elf.h (JUMP_TABLES_IN_TEXT_SECTION): Disable\n \tfor -mpure-code.\n-\t* gcc/doc/texi (TARGET_ASM_ELF_FLAGS_NUMERIC): New.\n-\t* gcc/doc/texi.in (TARGET_ASM_ELF_FLAGS_NUMERIC): Likewise.\n+\t* doc/texi (TARGET_ASM_ELF_FLAGS_NUMERIC): New.\n+\t* doc/texi.in (TARGET_ASM_ELF_FLAGS_NUMERIC): Likewise.\n \n 2016-09-22  Jan Hubicka  <hubicka@ucw.cz>\n \n@@ -6667,7 +6707,7 @@\n \t* genmatch.c (parser::parse_expr): Increase buffer size to guarantee\n \tit fits the output of the formatted function regardless of its\n \targuments.\n-\t* gcc/genmodes.c (parser::parse_expr): Same.\n+\t* genmodes.c (parser::parse_expr): Same.\n \t* gimplify.c (gimplify_asm_expr): Same.\n \t* passes.c (pass_manager::register_one_dump_file): Same.\n \t* print-tree.c (print_node): Same.\n@@ -6878,7 +6918,7 @@\n \n 2016-08-30  Tamar Christina  <tamar.christina@arm.com>\n \n-\t* gcc/config/aarch64/aarch64-simd.md\n+\t* config/aarch64/aarch64-simd.md\n \t(aarch64_ld2<mode>_dreg_le): New.\n \t(aarch64_ld2<mode>_dreg_be): New.\n \t(aarch64_ld2<mode>_dreg): Removed.\n@@ -10344,7 +10384,7 @@\n \n 2016-07-20  Georg-Johann Lay  <avr@gjlay.de>\n \n-\t* gcc/config/avr.c (avr_legitimize_address) [AVR_TINY]: Force\n+\t* config/avr.c (avr_legitimize_address) [AVR_TINY]: Force\n \tconstant addresses outside [0,0xc0] into a register.\n \t(avr_out_movhi_r_mr_reg_no_disp_tiny): Pass insn.  And handle\n \tcases where the base address register is unused after.\n@@ -10766,7 +10806,7 @@\n \n 2016-07-14  Alan Modra  <amodra@gmail.com>\n \n-\t* gcc/config/rs6000/altivec.md (altivec_mov<mode>): Disparage\n+\t* config/rs6000/altivec.md (altivec_mov<mode>): Disparage\n \tgpr alternatives.  Correct '*' placement on Y,r alternative.\n \tAdd '*' on operand 1 of r,r alternative.\n "}, {"sha": "05c9a13fd2fb735e2767049455de7cb557023622", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 293, "deletions": 40, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaec3d850a73cd951ccec98f2f55d62832ca2ee2/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaec3d850a73cd951ccec98f2f55d62832ca2ee2/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=aaec3d850a73cd951ccec98f2f55d62832ca2ee2", "patch": "@@ -277,6 +277,9 @@ static void dwarf2out_note_section_used (void);\n    personality CFI.  */\n static GTY(()) rtx current_unit_personality;\n \n+/* .debug_rnglists next index.  */\n+static unsigned int rnglist_idx;\n+\n /* Data and reference forms for relocatable data.  */\n #define DW_FORM_data (DWARF_OFFSET_SIZE == 8 ? DW_FORM_data8 : DW_FORM_data4)\n #define DW_FORM_ref (DWARF_OFFSET_SIZE == 8 ? DW_FORM_ref8 : DW_FORM_ref4)\n@@ -2907,9 +2910,15 @@ pubname_entry;\n \n \n struct GTY(()) dw_ranges {\n+  const char *label;\n   /* If this is positive, it's a block number, otherwise it's a\n      bitwise-negated index into dw_ranges_by_label.  */\n   int num;\n+  /* Index for the range list for DW_FORM_rnglistx.  */\n+  unsigned int idx : 31;\n+  /* True if this range might be possibly in a different section\n+     from previous entry.  */\n+  unsigned int maybe_new_sec : 1;\n };\n \n /* A structure to hold a macinfo entry.  */\n@@ -3429,8 +3438,7 @@ static void add_pubname_string (const char *, dw_die_ref);\n static void add_pubtype (tree, dw_die_ref);\n static void output_pubnames (vec<pubname_entry, va_gc> *);\n static void output_aranges (void);\n-static unsigned int add_ranges_num (int);\n-static unsigned int add_ranges (const_tree);\n+static unsigned int add_ranges (const_tree, bool = false);\n static void add_ranges_by_labels (dw_die_ref, const char *, const char *,\n                                   bool *, bool);\n static void output_ranges (void);\n@@ -3714,6 +3722,9 @@ new_addr_loc_descr (rtx addr, enum dtprel_bool dtprel)\n #ifndef DEBUG_RANGES_SECTION\n #define DEBUG_RANGES_SECTION\t\".debug_ranges\"\n #endif\n+#ifndef DEBUG_RNGLISTS_SECTION\n+#define DEBUG_RNGLISTS_SECTION\t\".debug_rnglists\"\n+#endif\n #ifndef DEBUG_LINE_STR_SECTION\n #define DEBUG_LINE_STR_SECTION  \".debug_line_str\"\n #endif\n@@ -3797,6 +3808,7 @@ static char debug_skeleton_line_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n static char macinfo_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n static char loc_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n static char ranges_section_label[2 * MAX_ARTIFICIAL_LABEL_BYTES];\n+static char ranges_base_label[2 * MAX_ARTIFICIAL_LABEL_BYTES];\n \n #ifndef TEXT_END_LABEL\n #define TEXT_END_LABEL\t\t\"Letext\"\n@@ -8848,7 +8860,14 @@ size_of_die (dw_die_ref die)\n             size += DWARF_OFFSET_SIZE;\n \t  break;\n \tcase dw_val_class_range_list:\n-          size += DWARF_OFFSET_SIZE;\n+\t  if (value_format (a) == DW_FORM_rnglistx)\n+\t    {\n+\t      gcc_assert (rnglist_idx);\n+\t      dw_ranges *r = &(*ranges_table)[a->dw_attr_val.v.val_offset];\n+\t      size += size_of_uleb128 (r->idx);\n+\t    }\n+\t  else\n+\t    size += DWARF_OFFSET_SIZE;\n \t  break;\n \tcase dw_val_class_const:\n \t  size += size_of_sleb128 (AT_int (a));\n@@ -9204,6 +9223,18 @@ value_format (dw_attr_node *a)\n \treturn DW_FORM_loclistx;\n       /* FALLTHRU */\n     case dw_val_class_range_list:\n+      /* For range lists in DWARF 5, use DW_FORM_rnglistx from .debug_info.dwo\n+\t but in .debug_info use DW_FORM_sec_offset, which is shorter if we\n+\t care about sizes of .debug* sections in shared libraries and\n+\t executables and don't take into account relocations that affect just\n+\t relocatable objects - for DW_FORM_rnglistx we'd have to emit offset\n+\t table in the .debug_rnglists section.  */\n+      if (dwarf_split_debug_info\n+\t  && dwarf_version >= 5\n+\t  && AT_class (a) == dw_val_class_range_list\n+\t  && rnglist_idx\n+\t  && a->dw_attr_val.val_entry != RELOCATED_OFFSET)\n+\treturn DW_FORM_rnglistx;\n       if (dwarf_version >= 4)\n \treturn DW_FORM_sec_offset;\n       /* FALLTHRU */\n@@ -9716,9 +9747,9 @@ output_loc_list (dw_loc_list_ref list_head)\n     }\n }\n \n-/* Output a range_list offset into the debug_range section.  Emit a\n-   relocated reference if val_entry is NULL, otherwise, emit an\n-   indirect reference.  */\n+/* Output a range_list offset into the .debug_ranges or .debug_rnglists\n+   section.  Emit a relocated reference if val_entry is NULL, otherwise,\n+   emit an indirect reference.  */\n \n static void\n output_range_list_offset (dw_attr_node *a)\n@@ -9727,14 +9758,31 @@ output_range_list_offset (dw_attr_node *a)\n \n   if (a->dw_attr_val.val_entry == RELOCATED_OFFSET)\n     {\n-      char *p = strchr (ranges_section_label, '\\0');\n-      sprintf (p, \"+\" HOST_WIDE_INT_PRINT_HEX, a->dw_attr_val.v.val_offset);\n-      dw2_asm_output_offset (DWARF_OFFSET_SIZE, ranges_section_label,\n-                             debug_ranges_section, \"%s\", name);\n-      *p = '\\0';\n+      if (dwarf_version >= 5)\n+\t{\n+\t  dw_ranges *r = &(*ranges_table)[a->dw_attr_val.v.val_offset];\n+\t  dw2_asm_output_offset (DWARF_OFFSET_SIZE, r->label,\n+\t\t\t\t debug_ranges_section, \"%s\", name);\n+\t}\n+      else\n+\t{\n+\t  char *p = strchr (ranges_section_label, '\\0');\n+\t  sprintf (p, \"+\" HOST_WIDE_INT_PRINT_HEX,\n+\t\t   a->dw_attr_val.v.val_offset * 2 * DWARF2_ADDR_SIZE);\n+\t  dw2_asm_output_offset (DWARF_OFFSET_SIZE, ranges_section_label,\n+\t\t\t\t debug_ranges_section, \"%s\", name);\n+\t  *p = '\\0';\n+\t}\n+    }\n+  else if (dwarf_version >= 5)\n+    {\n+      dw_ranges *r = &(*ranges_table)[a->dw_attr_val.v.val_offset];\n+      gcc_assert (rnglist_idx);\n+      dw2_asm_output_data_uleb128 (r->idx, \"%s\", name);\n     }\n   else\n-    dw2_asm_output_data (DWARF_OFFSET_SIZE, a->dw_attr_val.v.val_offset,\n+    dw2_asm_output_data (DWARF_OFFSET_SIZE,\n+\t\t\t a->dw_attr_val.v.val_offset * 2 * DWARF2_ADDR_SIZE,\n                          \"%s (offset from %s)\", name, ranges_section_label);\n }\n \n@@ -10829,24 +10877,36 @@ output_aranges (void)\n   dw2_asm_output_data (DWARF2_ADDR_SIZE, 0, NULL);\n }\n \n-/* Add a new entry to .debug_ranges.  Return the offset at which it\n-   was placed.  */\n+/* Add a new entry to .debug_ranges.  Return its index into\n+   ranges_table vector.  */\n \n static unsigned int\n-add_ranges_num (int num)\n+add_ranges_num (int num, bool maybe_new_sec)\n {\n-  dw_ranges r = { num };\n+  dw_ranges r = { NULL, num, 0, maybe_new_sec };\n   vec_safe_push (ranges_table, r);\n-  return (vec_safe_length (ranges_table) - 1) * 2 * DWARF2_ADDR_SIZE;\n+  return vec_safe_length (ranges_table) - 1;\n }\n \n /* Add a new entry to .debug_ranges corresponding to a block, or a\n-   range terminator if BLOCK is NULL.  */\n+   range terminator if BLOCK is NULL.  MAYBE_NEW_SEC is true if\n+   this entry might be in a different section from previous range.  */\n \n static unsigned int\n-add_ranges (const_tree block)\n+add_ranges (const_tree block, bool maybe_new_sec)\n {\n-  return add_ranges_num (block ? BLOCK_NUMBER (block) : 0);\n+  return add_ranges_num (block ? BLOCK_NUMBER (block) : 0, maybe_new_sec);\n+}\n+\n+/* Note that (*rnglist_table)[offset] is either a head of a rnglist\n+   chain, or middle entry of a chain that will be directly referred to.  */\n+\n+static void\n+note_rnglist_head (unsigned int offset)\n+{\n+  if (dwarf_version < 5 || (*ranges_table)[offset].label)\n+    return;\n+  (*ranges_table)[offset].label = gen_internal_sym (\"LLRL\");\n }\n \n /* Add a new entry to .debug_ranges corresponding to a pair of labels.\n@@ -10862,14 +10922,17 @@ add_ranges_by_labels (dw_die_ref die, const char *begin, const char *end,\n   unsigned int offset;\n   dw_ranges_by_label rbl = { begin, end };\n   vec_safe_push (ranges_by_label, rbl);\n-  offset = add_ranges_num (-(int)in_use - 1);\n+  offset = add_ranges_num (-(int)in_use - 1, true);\n   if (!*added)\n     {\n       add_AT_range_list (die, DW_AT_ranges, offset, force_direct);\n       *added = true;\n+      note_rnglist_head (offset);\n     }\n }\n \n+/* Emit .debug_ranges section.  */\n+\n static void\n output_ranges (void)\n {\n@@ -10878,6 +10941,8 @@ output_ranges (void)\n   const char *fmt = start_fmt;\n   dw_ranges *r;\n \n+  switch_to_section (debug_ranges_section);\n+  ASM_OUTPUT_LABEL (asm_out_file, ranges_section_label);\n   FOR_EACH_VEC_SAFE_ELT (ranges_table, i, r)\n     {\n       int block_num = r->num;\n@@ -10965,6 +11030,177 @@ output_ranges (void)\n       for -gsplit-dwarf we should use DW_FORM_strx instead.  */\t\\\n    && !dwarf_split_debug_info)\n \n+/* Assign .debug_rnglists indexes.  */\n+\n+static void\n+index_rnglists (void)\n+{\n+  unsigned i;\n+  dw_ranges *r;\n+\n+  FOR_EACH_VEC_SAFE_ELT (ranges_table, i, r)\n+    if (r->label)\n+      r->idx = rnglist_idx++;\n+}\n+\n+/* Emit .debug_rnglists section.  */\n+\n+static void\n+output_rnglists (void)\n+{\n+  unsigned i;\n+  dw_ranges *r;\n+  char l1[MAX_ARTIFICIAL_LABEL_BYTES];\n+  char l2[MAX_ARTIFICIAL_LABEL_BYTES];\n+  char basebuf[MAX_ARTIFICIAL_LABEL_BYTES];\n+\n+  switch_to_section (debug_ranges_section);\n+  ASM_OUTPUT_LABEL (asm_out_file, ranges_section_label);\n+  ASM_GENERATE_INTERNAL_LABEL (l1, DEBUG_RANGES_SECTION_LABEL, 2);\n+  ASM_GENERATE_INTERNAL_LABEL (l2, DEBUG_RANGES_SECTION_LABEL, 3);\n+  if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)\n+    dw2_asm_output_data (4, 0xffffffff,\n+\t\t\t \"Initial length escape value indicating \"\n+\t\t\t \"64-bit DWARF extension\");\n+  dw2_asm_output_delta (DWARF_OFFSET_SIZE, l2, l1,\n+\t\t\t\"Length of Range Lists\");\n+  ASM_OUTPUT_LABEL (asm_out_file, l1);\n+  dw2_asm_output_data (2, dwarf_version, \"DWARF Version\");\n+  dw2_asm_output_data (1, DWARF2_ADDR_SIZE, \"Address Size\");\n+  dw2_asm_output_data (1, 0, \"Segment Size\");\n+  /* Emit the offset table only for -gsplit-dwarf.  If we don't care\n+     about relocation sizes and primarily care about the size of .debug*\n+     sections in linked shared libraries and executables, then\n+     the offset table plus corresponding DW_FORM_rnglistx uleb128 indexes\n+     into it are usually larger than just DW_FORM_sec_offset offsets\n+     into the .debug_rnglists section.  */\n+  dw2_asm_output_data (4, dwarf_split_debug_info ? rnglist_idx : 0,\n+\t\t       \"Offset Entry Count\");\n+  if (dwarf_split_debug_info)\n+    {\n+      ASM_OUTPUT_LABEL (asm_out_file, ranges_base_label);\n+      FOR_EACH_VEC_SAFE_ELT (ranges_table, i, r)\n+\tif (r->label)\n+\t  dw2_asm_output_delta (DWARF_OFFSET_SIZE, r->label,\n+\t\t\t\tranges_base_label, NULL);\n+    }\n+\n+  unsigned int len = vec_safe_length (ranges_table);\n+  const char *lab = \"\";\n+#ifdef HAVE_AS_LEB128\n+  const char *base = NULL;\n+#endif\n+  FOR_EACH_VEC_SAFE_ELT (ranges_table, i, r)\n+    {\n+      int block_num = r->num;\n+\n+      if (r->label)\n+\t{\n+\t  ASM_OUTPUT_LABEL (asm_out_file, r->label);\n+\t  lab = r->label;\n+\t}\n+#ifdef HAVE_AS_LEB128\n+      if (r->label || r->maybe_new_sec)\n+\tbase = NULL;\n+#endif\n+      if (block_num > 0)\n+\t{\n+\t  char blabel[MAX_ARTIFICIAL_LABEL_BYTES];\n+\t  char elabel[MAX_ARTIFICIAL_LABEL_BYTES];\n+\n+\t  ASM_GENERATE_INTERNAL_LABEL (blabel, BLOCK_BEGIN_LABEL, block_num);\n+\t  ASM_GENERATE_INTERNAL_LABEL (elabel, BLOCK_END_LABEL, block_num);\n+\n+#ifdef HAVE_AS_LEB128\n+\t  /* If all code is in the text section, then the compilation\n+\t     unit base address defaults to DW_AT_low_pc, which is the\n+\t     base of the text section.  */\n+\t  if (!have_multiple_function_sections)\n+\t    {\n+\t      dw2_asm_output_data (1, DW_RLE_offset_pair,\n+\t\t\t\t   \"DW_RLE_offset_pair (%s)\", lab);\n+\t      dw2_asm_output_delta_uleb128 (blabel, text_section_label,\n+\t\t\t\t\t    \"Range begin address (%s)\", lab);\n+\t      dw2_asm_output_delta_uleb128 (elabel, text_section_label,\n+\t\t\t\t\t    \"Range end address (%s)\", lab);\n+\t      continue;\n+\t    }\n+\t  if (base == NULL)\n+\t    {\n+\t      dw_ranges *r2 = NULL;\n+\t      if (i < len - 1)\n+\t\tr2 = &(*ranges_table)[i + 1];\n+\t      if (r2\n+\t\t  && r2->num != 0\n+\t\t  && r2->label == NULL\n+\t\t  && !r2->maybe_new_sec)\n+\t\t{\n+\t\t  dw2_asm_output_data (1, DW_RLE_base_address,\n+\t\t\t\t       \"DW_RLE_base_address (%s)\", lab);\n+\t\t  dw2_asm_output_addr (DWARF2_ADDR_SIZE, blabel,\n+\t\t\t\t       \"Base address (%s)\", lab);\n+\t\t  strcpy (basebuf, blabel);\n+\t\t  base = basebuf;\n+\t\t}\n+\t    }\n+\t  if (base)\n+\t    {\n+\t      dw2_asm_output_data (1, DW_RLE_offset_pair,\n+\t\t\t\t   \"DW_RLE_offset_pair (%s)\", lab);\n+\t      dw2_asm_output_delta_uleb128 (blabel, base,\n+\t\t\t\t\t    \"Range begin address (%s)\", lab);\n+\t      dw2_asm_output_delta_uleb128 (elabel, base,\n+\t\t\t\t\t    \"Range end address (%s)\", lab);\n+\t      continue;\n+\t    }\n+\t  dw2_asm_output_data (1, DW_RLE_start_length,\n+\t\t\t       \"DW_RLE_start_length (%s)\", lab);\n+\t  dw2_asm_output_addr (DWARF2_ADDR_SIZE, blabel,\n+\t\t\t       \"Range begin address (%s)\", lab);\n+\t  dw2_asm_output_delta_uleb128 (elabel, blabel,\n+\t\t\t\t\t\"Range length (%s)\", lab);\n+#else\n+\t  dw2_asm_output_data (1, DW_RLE_start_end,\n+\t\t\t       \"DW_RLE_start_end (%s)\", lab);\n+\t  dw2_asm_output_addr (DWARF2_ADDR_SIZE, blabel,\n+\t\t\t       \"Range begin address (%s)\", lab);\n+\t  dw2_asm_output_addr (DWARF2_ADDR_SIZE, elabel,\n+\t\t\t       \"Range end address (%s)\", lab);\n+#endif\n+\t}\n+\n+      /* Negative block_num stands for an index into ranges_by_label.  */\n+      else if (block_num < 0)\n+\t{\n+\t  int lab_idx = - block_num - 1;\n+\t  const char *blabel = (*ranges_by_label)[lab_idx].begin;\n+\t  const char *elabel = (*ranges_by_label)[lab_idx].end;\n+\n+\t  if (!have_multiple_function_sections)\n+\t    gcc_unreachable ();\n+#ifdef HAVE_AS_LEB128\n+\t  dw2_asm_output_data (1, DW_RLE_start_length,\n+\t\t\t       \"DW_RLE_start_length (%s)\", lab);\n+\t  dw2_asm_output_addr (DWARF2_ADDR_SIZE, blabel,\n+\t\t\t       \"Range begin address (%s)\", lab);\n+\t  dw2_asm_output_delta_uleb128 (elabel, blabel,\n+\t\t\t\t\t\"Range length (%s)\", lab);\n+#else\n+\t  dw2_asm_output_data (1, DW_RLE_start_end,\n+\t\t\t       \"DW_RLE_start_end (%s)\", lab);\n+\t  dw2_asm_output_addr (DWARF2_ADDR_SIZE, blabel,\n+\t\t\t       \"Range begin address (%s)\", lab);\n+\t  dw2_asm_output_addr (DWARF2_ADDR_SIZE, elabel,\n+\t\t\t       \"Range end address (%s)\", lab);\n+#endif\n+\t}\n+      else\n+\tdw2_asm_output_data (1, DW_RLE_end_of_list,\n+\t\t\t     \"DW_RLE_end_of_list (%s)\", lab);\n+    }\n+  ASM_OUTPUT_LABEL (asm_out_file, l2);\n+}\n+\n /* Data structure containing information about input files.  */\n struct file_info\n {\n@@ -21740,11 +21976,11 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t\t     alignment offset.  */\n \t\t  bool range_list_added = false;\n \t\t  add_ranges_by_labels (subr_die, fde->dw_fde_begin,\n-                                        fde->dw_fde_end, &range_list_added,\n-                                        false);\n+\t\t\t\t\tfde->dw_fde_end, &range_list_added,\n+\t\t\t\t\tfalse);\n \t\t  add_ranges_by_labels (subr_die, fde->dw_fde_second_begin,\n \t\t\t\t\tfde->dw_fde_second_end,\n-                                       &range_list_added, false);\n+\t\t\t\t\t&range_list_added, false);\n \t\t  if (range_list_added)\n \t\t    add_ranges (NULL);\n \t\t}\n@@ -22609,13 +22845,11 @@ add_high_low_attributes (tree stmt, dw_die_ref die)\n \t  superblock = BLOCK_SUPERCONTEXT (chain);\n \t}\n       if (attr != NULL\n-\t  && ((*ranges_table)[attr->dw_attr_val.v.val_offset\n-\t\t\t      / 2 / DWARF2_ADDR_SIZE].num\n+\t  && ((*ranges_table)[attr->dw_attr_val.v.val_offset].num\n \t      == BLOCK_NUMBER (superblock))\n \t  && BLOCK_FRAGMENT_CHAIN (superblock))\n \t{\n-\t  unsigned long off = attr->dw_attr_val.v.val_offset\n-\t\t\t      / 2 / DWARF2_ADDR_SIZE;\n+\t  unsigned long off = attr->dw_attr_val.v.val_offset;\n \t  unsigned long supercnt = 0, thiscnt = 0;\n \t  for (chain = BLOCK_FRAGMENT_CHAIN (superblock);\n \t       chain; chain = BLOCK_FRAGMENT_CHAIN (chain))\n@@ -22629,19 +22863,22 @@ add_high_low_attributes (tree stmt, dw_die_ref die)\n \t       chain; chain = BLOCK_FRAGMENT_CHAIN (chain))\n \t    ++thiscnt;\n \t  gcc_assert (supercnt >= thiscnt);\n-\t  add_AT_range_list (die, DW_AT_ranges,\n-                             ((off + supercnt - thiscnt)\n-                              * 2 * DWARF2_ADDR_SIZE),\n-                             false);\n+\t  add_AT_range_list (die, DW_AT_ranges, off + supercnt - thiscnt,\n+\t\t\t     false);\n+\t  note_rnglist_head (off + supercnt - thiscnt);\n \t  return;\n \t}\n \n-      add_AT_range_list (die, DW_AT_ranges, add_ranges (stmt), false);\n+      unsigned int offset = add_ranges (stmt, true);\n+      add_AT_range_list (die, DW_AT_ranges, offset, false);\n+      note_rnglist_head (offset);\n \n+      bool prev_in_cold = BLOCK_IN_COLD_SECTION_P (stmt);\n       chain = BLOCK_FRAGMENT_CHAIN (stmt);\n       do\n \t{\n-\t  add_ranges (chain);\n+\t  add_ranges (chain, prev_in_cold != BLOCK_IN_COLD_SECTION_P (chain));\n+\t  prev_in_cold = BLOCK_IN_COLD_SECTION_P (chain);\n \t  chain = BLOCK_FRAGMENT_CHAIN (chain);\n \t}\n       while (chain);\n@@ -26650,7 +26887,9 @@ init_sections_and_labels (void)\n     debug_line_str_section = get_section (DEBUG_LINE_STR_SECTION,\n \t\t\t\t\t  DEBUG_STR_SECTION_FLAGS, NULL);\n \n-  debug_ranges_section = get_section (DEBUG_RANGES_SECTION,\n+  debug_ranges_section = get_section (dwarf_version >= 5\n+\t\t\t\t      ? DEBUG_RNGLISTS_SECTION\n+\t\t\t\t      : DEBUG_RANGES_SECTION,\n \t\t\t\t      SECTION_DEBUG, NULL);\n   debug_frame_section = get_section (DEBUG_FRAME_SECTION,\n \t\t\t\t     SECTION_DEBUG, NULL);\n@@ -26663,6 +26902,9 @@ init_sections_and_labels (void)\n \t\t\t       DEBUG_LINE_SECTION_LABEL, 0);\n   ASM_GENERATE_INTERNAL_LABEL (ranges_section_label,\n \t\t\t       DEBUG_RANGES_SECTION_LABEL, 0);\n+  if (dwarf_version >= 5 && dwarf_split_debug_info)\n+    ASM_GENERATE_INTERNAL_LABEL (ranges_base_label,\n+\t\t\t\t DEBUG_RANGES_SECTION_LABEL, 1);\n   ASM_GENERATE_INTERNAL_LABEL (debug_addr_section_label,\n                                DEBUG_ADDR_SECTION_LABEL, 0);\n   ASM_GENERATE_INTERNAL_LABEL (macinfo_section_label,\n@@ -29117,6 +29359,9 @@ dwarf2out_finish (const char *)\n       int mark;\n       struct md5_ctx ctx;\n \n+      if (dwarf_version >= 5 && !vec_safe_is_empty (ranges_table))\n+\tindex_rnglists ();\n+\n       /* Compute a checksum of the comp_unit to use as the dwo_id.  */\n       md5_init_ctx (&ctx);\n       mark = 0;\n@@ -29135,8 +29380,14 @@ dwarf2out_finish (const char *)\n       /* Add the base offset of the ranges table to the skeleton\n         comp-unit DIE.  */\n       if (!vec_safe_is_empty (ranges_table))\n-        add_AT_lineptr (main_comp_unit_die, DW_AT_GNU_ranges_base,\n-                        ranges_section_label);\n+\t{\n+\t  if (dwarf_version >= 5)\n+\t    add_AT_lineptr (main_comp_unit_die, DW_AT_rnglists_base,\n+\t\t\t    ranges_base_label);\n+\t  else\n+\t    add_AT_lineptr (main_comp_unit_die, DW_AT_GNU_ranges_base,\n+\t\t\t    ranges_section_label);\n+\t}\n \n       switch_to_section (debug_addr_section);\n       ASM_OUTPUT_LABEL (asm_out_file, debug_addr_section_label);\n@@ -29212,9 +29463,10 @@ dwarf2out_finish (const char *)\n   /* Output ranges section if necessary.  */\n   if (!vec_safe_is_empty (ranges_table))\n     {\n-      switch_to_section (debug_ranges_section);\n-      ASM_OUTPUT_LABEL (asm_out_file, ranges_section_label);\n-      output_ranges ();\n+      if (dwarf_version >= 5)\n+\toutput_rnglists ();\n+      else\n+\toutput_ranges ();\n     }\n \n   /* Have to end the macro section.  */\n@@ -29453,6 +29705,7 @@ dwarf2out_c_finalize (void)\n   macinfo_table = NULL;\n   ranges_table = NULL;\n   ranges_by_label = NULL;\n+  rnglist_idx = 0;\n   have_location_lists = false;\n   loclabel_num = 0;\n   poc_label_num = 0;"}, {"sha": "71dba7c04223a7dcf01e2a070958abff950db5a8", "filename": "gcc/final.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaec3d850a73cd951ccec98f2f55d62832ca2ee2/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaec3d850a73cd951ccec98f2f55d62832ca2ee2/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=aaec3d850a73cd951ccec98f2f55d62832ca2ee2", "patch": "@@ -2323,6 +2323,7 @@ final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \n \t      /* Mark this block as output.  */\n \t      TREE_ASM_WRITTEN (NOTE_BLOCK (insn)) = 1;\n+\t      BLOCK_IN_COLD_SECTION_P (NOTE_BLOCK (insn)) = in_cold_section_p;\n \t    }\n \t  if (write_symbols == DBX_DEBUG\n \t      || write_symbols == SDB_DEBUG)\n@@ -2355,6 +2356,8 @@ final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \n \t      if (!DECL_IGNORED_P (current_function_decl))\n \t\tdebug_hooks->end_block (high_block_linenum, n);\n+\t      gcc_assert (BLOCK_IN_COLD_SECTION_P (NOTE_BLOCK (insn))\n+\t\t\t  == in_cold_section_p);\n \t    }\n \t  if (write_symbols == DBX_DEBUG\n \t      || write_symbols == SDB_DEBUG)"}, {"sha": "531bc5effb728f7cf0163497416bd67f85f9bbf5", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaec3d850a73cd951ccec98f2f55d62832ca2ee2/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaec3d850a73cd951ccec98f2f55d62832ca2ee2/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=aaec3d850a73cd951ccec98f2f55d62832ca2ee2", "patch": "@@ -1757,6 +1757,10 @@ extern void protected_set_expr_location (tree, location_t);\n /* True if BLOCK has the same ranges as its BLOCK_SUPERCONTEXT.  */\n #define BLOCK_SAME_RANGE(NODE) (BLOCK_CHECK (NODE)->base.u.bits.nameless_flag)\n \n+/* True if BLOCK appears in cold section.  */\n+#define BLOCK_IN_COLD_SECTION_P(NODE) \\\n+  (BLOCK_CHECK (NODE)->base.u.bits.atomic_flag)\n+\n /* An index number for this block.  These values are not guaranteed to\n    be unique across functions -- whether or not they are depends on\n    the debugging output format in use.  */"}]}