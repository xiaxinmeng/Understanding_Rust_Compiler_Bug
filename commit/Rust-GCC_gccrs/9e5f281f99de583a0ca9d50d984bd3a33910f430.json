{"sha": "9e5f281f99de583a0ca9d50d984bd3a33910f430", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU1ZjI4MWY5OWRlNTgzYTBjYTlkNTBkOTg0YmQzYTMzOTEwZjQzMA==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@act-europe.fr", "date": "2003-05-05T17:56:35Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2003-05-05T17:56:35Z"}, "message": "expr.c (expand_expr, [...]): Refine the test forcing usage of bitfield instructions for mode1 != BLKmode...\n\n        * expr.c (expand_expr, case BIT_FIELD_REF): Refine the test forcing\n        usage of bitfield instructions for mode1 != BLKmode, only ignoring\n        SLOW_UNALIGNED_ACCESS if the field is not byte aligned.\n        (store_field): Likewise.\n\nFrom-SVN: r66492", "tree": {"sha": "33a4fc54a6ce90abebc59cf481818d05dcdbf7ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33a4fc54a6ce90abebc59cf481818d05dcdbf7ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e5f281f99de583a0ca9d50d984bd3a33910f430", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e5f281f99de583a0ca9d50d984bd3a33910f430", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e5f281f99de583a0ca9d50d984bd3a33910f430", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e5f281f99de583a0ca9d50d984bd3a33910f430/comments", "author": null, "committer": null, "parents": [{"sha": "f5119d10faca5f15af8293286b518ef342817629", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5119d10faca5f15af8293286b518ef342817629", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5119d10faca5f15af8293286b518ef342817629"}], "stats": {"total": 19, "additions": 14, "deletions": 5}, "files": [{"sha": "0f8cad843e347c1c9be447f99d73466b508adfcd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e5f281f99de583a0ca9d50d984bd3a33910f430/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e5f281f99de583a0ca9d50d984bd3a33910f430/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e5f281f99de583a0ca9d50d984bd3a33910f430", "patch": "@@ -1,3 +1,10 @@\n+2003-05-05  Olivier Hainque  <hainque@act-europe.fr>\n+\n+        * expr.c (expand_expr, case BIT_FIELD_REF): Refine the test forcing\n+        usage of bitfield instructions for mode1 != BLKmode, only ignoring\n+        SLOW_UNALIGNED_ACCESS if the field is not byte aligned. \n+        (store_field): Likewise.\n+\n 2003-05-05  Aldy Hernandez  <aldyh@redhat.com>\n \n         * config/rs6000/rs6000.c (rs6000_expand_binop_builtin): Add"}, {"sha": "6659d61f7140ef5fa04d332ef54d317004e2f053", "filename": "gcc/expr.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e5f281f99de583a0ca9d50d984bd3a33910f430/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e5f281f99de583a0ca9d50d984bd3a33910f430/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=9e5f281f99de583a0ca9d50d984bd3a33910f430", "patch": "@@ -5626,9 +5626,10 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode, unsignedp, type,\n       /* If the field isn't aligned enough to store as an ordinary memref,\n \t store it as a bit field.  */\n       || (mode != BLKmode\n-\t  && ((SLOW_UNALIGNED_ACCESS (mode, MEM_ALIGN (target))\n-\t       && (MEM_ALIGN (target) < GET_MODE_ALIGNMENT (mode)))\n-\t      || bitpos % GET_MODE_ALIGNMENT (mode)))\n+\t  && ((((MEM_ALIGN (target) < GET_MODE_ALIGNMENT (mode))\n+\t\t|| bitpos % GET_MODE_ALIGNMENT (mode))\n+\t       && SLOW_UNALIGNED_ACCESS (mode, MEM_ALIGN (target)))\n+\t      || (bitpos % BITS_PER_UNIT != 0)))\t      \n       /* If the RHS and field are a constant size and the size of the\n \t RHS isn't the same size as the bitfield, we must use bitfield\n \t operations.  */\n@@ -7571,9 +7572,10 @@ expand_expr (exp, target, tmode, modifier)\n \t    /* If the field isn't aligned enough to fetch as a memref,\n \t       fetch it as a bit field.  */\n \t    || (mode1 != BLKmode\n-\t\t&& ((TYPE_ALIGN (TREE_TYPE (tem)) < GET_MODE_ALIGNMENT (mode)\n+\t\t&& (((TYPE_ALIGN (TREE_TYPE (tem)) < GET_MODE_ALIGNMENT (mode)\n+\t\t      || (bitpos % GET_MODE_ALIGNMENT (mode) != 0))\n \t\t     && SLOW_UNALIGNED_ACCESS (mode1, MEM_ALIGN (op0)))\n-\t\t    || (bitpos % GET_MODE_ALIGNMENT (mode) != 0)))\n+\t\t    || (bitpos % BITS_PER_UNIT != 0)))\n \t    /* If the type and the field are a constant size and the\n \t       size of the type isn't the same size as the bitfield,\n \t       we must use bitfield operations.  */"}]}