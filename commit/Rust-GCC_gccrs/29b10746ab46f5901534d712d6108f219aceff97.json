{"sha": "29b10746ab46f5901534d712d6108f219aceff97", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjliMTA3NDZhYjQ2ZjU5MDE1MzRkNzEyZDYxMDhmMjE5YWNlZmY5Nw==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-11-13T18:40:37Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-11-13T18:40:37Z"}, "message": "cpplex.c (_cpp_lex_token): CPP_COMMENT and true CPP_EOF cases return without MI check.\n\n        * cpplex.c (_cpp_lex_token): CPP_COMMENT and true CPP_EOF\n        cases return without MI check.\n        * cpplib.c (do_diagnostic): Take boolean of whether to\n        print the directive name.\n        (do_error, do_warning): Update.\n        (do_pragma_dependency): Use it.\n        * cpplib.h (VARARGS_FIRST): Delete.\n        (struct cpp_token): Delete integer.\n        * cppmacro.c (enter_macro_context): Move disabled check\n        to _cpp_get_token.\n        (_cpp_get_token): Simplify into a single loop.\n\nFrom-SVN: r37434", "tree": {"sha": "6bca53154943312d4ce1d3788de1f631c994d6c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6bca53154943312d4ce1d3788de1f631c994d6c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29b10746ab46f5901534d712d6108f219aceff97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29b10746ab46f5901534d712d6108f219aceff97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29b10746ab46f5901534d712d6108f219aceff97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29b10746ab46f5901534d712d6108f219aceff97/comments", "author": null, "committer": null, "parents": [{"sha": "eb68ad7c6025a667e77ea59e85ab37612e4593de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb68ad7c6025a667e77ea59e85ab37612e4593de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb68ad7c6025a667e77ea59e85ab37612e4593de"}], "stats": {"total": 124, "additions": 65, "deletions": 59}, "files": [{"sha": "e980c45b086c5eebeb8b54590c321cfed613ed08", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29b10746ab46f5901534d712d6108f219aceff97/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29b10746ab46f5901534d712d6108f219aceff97/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=29b10746ab46f5901534d712d6108f219aceff97", "patch": "@@ -1,3 +1,17 @@\n+2000-11-13  Neil Booth  <neilb@earthling.net>\n+\n+        * cpplex.c (_cpp_lex_token): CPP_COMMENT and true CPP_EOF\n+        cases return without MI check.\n+        * cpplib.c (do_diagnostic): Take boolean of whether to\n+        print the directive name.\n+        (do_error, do_warning): Update.\n+        (do_pragma_dependency): Use it.\n+        * cpplib.h (VARARGS_FIRST): Delete.\n+        (struct cpp_token): Delete integer.\n+        * cppmacro.c (enter_macro_context): Move disabled check\n+        to _cpp_get_token.\n+        (_cpp_get_token): Simplify into a single loop.\n+\n 2000-11-13  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* configure.in:  Use 'test -f' not '[ -e'."}, {"sha": "87171046ba18aa24bb929b7ead81a6591383ac49", "filename": "gcc/cpplex.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29b10746ab46f5901534d712d6108f219aceff97/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29b10746ab46f5901534d712d6108f219aceff97/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=29b10746ab46f5901534d712d6108f219aceff97", "patch": "@@ -876,7 +876,8 @@ _cpp_lex_token (pfile, result)\n       pfile->state.next_bol = 1;\n       pfile->skipping = 0;\t/* In case missing #endif.  */\n       result->type = CPP_EOF;\n-      break;\n+      /* Don't do MI optimisation.  */\n+      return;\n \n     case ' ': case '\\t': case '\\f': case '\\v': case '\\0':\n       skip_whitespace (pfile, c);\n@@ -1032,7 +1033,8 @@ _cpp_lex_token (pfile, result)\n \n       /* Save the comment as a token in its own right.  */\n       save_comment (pfile, result, comment_start);\n-      break;\n+      /* Don't do MI optimisation.  */\n+      return;\n \n     case '<':\n       if (pfile->state.angled_headers)\n@@ -1272,10 +1274,8 @@ _cpp_lex_token (pfile, result)\n       break;\n     }\n \n-  /* Non-comment tokens invalidate any controlling macros.  */\n-  if (result->type != CPP_COMMENT\n-      && result->type != CPP_EOF\n-      && !pfile->state.in_directive)\n+  /* If not in a directive, this token invalidates controlling macros.  */\n+  if (!pfile->state.in_directive)\n     pfile->mi_state = MI_FAILED;\n }\n "}, {"sha": "77cf6cd0c384cf58a2fcfb19578424f0ca63d76d", "filename": "gcc/cpplib.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29b10746ab46f5901534d712d6108f219aceff97/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29b10746ab46f5901534d712d6108f219aceff97/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=29b10746ab46f5901534d712d6108f219aceff97", "patch": "@@ -91,7 +91,7 @@ static void push_conditional\tPARAMS ((cpp_reader *, int, int,\n static int  read_line_number\tPARAMS ((cpp_reader *, int *));\n static int  strtoul_for_line\tPARAMS ((const U_CHAR *, unsigned int,\n \t\t\t\t\t unsigned long *));\n-static void do_diagnostic\tPARAMS ((cpp_reader *, enum error_type));\n+static void do_diagnostic\tPARAMS ((cpp_reader *, enum error_type, int));\n static cpp_hashnode *lex_macro_node\tPARAMS ((cpp_reader *));\n static void do_pragma_once\tPARAMS ((cpp_reader *));\n static void do_pragma_poison\tPARAMS ((cpp_reader *));\n@@ -792,13 +792,15 @@ do_line (pfile)\n  */\n \n static void\n-do_diagnostic (pfile, code)\n+do_diagnostic (pfile, code, print_dir)\n      cpp_reader *pfile;\n      enum error_type code;\n+     int print_dir;\n {\n   if (_cpp_begin_message (pfile, code, NULL, 0))\n     {\n-      fprintf (stderr, \"#%s \", pfile->directive->name);\n+      if (print_dir)\n+\tfprintf (stderr, \"#%s \", pfile->directive->name);\n       pfile->state.prevent_expansion++;\n       cpp_output_line (pfile, stderr);\n       pfile->state.prevent_expansion--;\n@@ -809,14 +811,14 @@ static void\n do_error (pfile)\n      cpp_reader *pfile;\n {\n-  do_diagnostic (pfile, ERROR);\n+  do_diagnostic (pfile, ERROR, 1);\n }\n \n static void\n do_warning (pfile)\n      cpp_reader *pfile;\n {\n-  do_diagnostic (pfile, WARNING);\n+  do_diagnostic (pfile, WARNING, 1);\n }\n \n /* Report program identification.  */\n@@ -1085,8 +1087,8 @@ do_pragma_dependency (pfile)\n       cpp_start_lookahead (pfile);\n       cpp_get_token (pfile, &msg);\n       cpp_stop_lookahead (pfile, msg.type == CPP_EOF);\n-      if (msg.type != CPP_EOF && _cpp_begin_message (pfile, WARNING, NULL, 0))\n-\tcpp_output_line (pfile, stderr);\n+      if (msg.type != CPP_EOF)\n+\tdo_diagnostic (pfile, WARNING, 0);\n     }\n }\n "}, {"sha": "1cda3e9caf0fc0dfbd6379cf6a860118b04106b1", "filename": "gcc/cpplib.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29b10746ab46f5901534d712d6108f219aceff97/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29b10746ab46f5901534d712d6108f219aceff97/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=29b10746ab46f5901534d712d6108f219aceff97", "patch": "@@ -170,7 +170,6 @@ struct cpp_string\n #define PASTE_LEFT\t(1 << 3) /* If on LHS of a ## operator.  */\n #define NAMED_OP\t(1 << 4) /* C++ named operators, also \"defined\".  */\n #define NO_EXPAND\t(1 << 5) /* Do not macro-expand this token.  */\n-#define VARARGS_FIRST   STRINGIFY_ARG /* First token of varargs expansion.  */\n \n /* A preprocessing token.  This has been carefully packed and should\n    occupy 12 bytes on 32-bit hosts and 16 bytes on 64-bit hosts.  */\n@@ -181,7 +180,6 @@ struct cpp_token\n \n   union\n   {\n-    HOST_WIDEST_INT integer;\t/* An integer.  */\n     struct cpp_hashnode *node;\t/* An identifier.  */\n     struct cpp_string str;\t/* A string, or number.  */\n     unsigned int arg_no;\t/* Argument no. for a CPP_MACRO_ARG.  */"}, {"sha": "3d4af7e65c16f110753f9fb0fa404ad399684273", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 36, "deletions": 44, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29b10746ab46f5901534d712d6108f219aceff97/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29b10746ab46f5901534d712d6108f219aceff97/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=29b10746ab46f5901534d712d6108f219aceff97", "patch": "@@ -60,7 +60,7 @@ struct macro_arg\n \n static void lock_pools PARAMS ((cpp_reader *));\n static void unlock_pools PARAMS ((cpp_reader *));\n-static int enter_macro_context PARAMS ((cpp_reader *, cpp_token *));\n+static int enter_macro_context PARAMS ((cpp_reader *, cpp_hashnode *));\n static void builtin_macro PARAMS ((cpp_reader *, cpp_token *));\n static cpp_context *push_arg_context PARAMS ((cpp_reader *, macro_arg *));\n static enum cpp_ttype parse_arg PARAMS ((cpp_reader *, macro_arg *, int));\n@@ -631,30 +631,22 @@ funlike_invocation_p (pfile, node, list)\n    TOKEN is replaced with the first token of the expansion, and we\n    return non-zero.  */\n static int\n-enter_macro_context (pfile, token)\n+enter_macro_context (pfile, node)\n      cpp_reader *pfile;\n-     cpp_token *token;\n+     cpp_hashnode *node;\n {\n   cpp_context *context;\n-  cpp_macro *macro;\n-  unsigned char flags;\n+  cpp_macro *macro = node->value.macro;\n   struct toklist list;\n \n-  macro = token->val.node->value.macro;\n-  if (macro->disabled)\n-    {\n-      token->flags |= NO_EXPAND;\n-      return 0;\n-    }\n-\n   /* Save the position of the outermost macro invocation.  */\n   if (!pfile->context->prev)\n     {\n       pfile->macro_pos = pfile->lexer_pos;\n       lock_pools (pfile);\n     }\n \n-  if (macro->fun_like && !funlike_invocation_p (pfile, token->val.node, &list))\n+  if (macro->fun_like && !funlike_invocation_p (pfile, node, &list))\n     {\n       if (!pfile->context->prev)\n \tunlock_pools (pfile);\n@@ -667,22 +659,16 @@ enter_macro_context (pfile, token)\n       list.limit = macro->expansion + macro->count;\n     }\n \n-  /* Temporary kludge.  */\n-  if (list.first == list.limit)\n-    return 2;\n-\n-  /* Now push its context.  */\n-  context = next_context (pfile);\n-  context->list = list;\n-  context->macro = macro;\n-\n-  /* The first expansion token inherits the PREV_WHITE of TOKEN.  */\n-  flags = token->flags & PREV_WHITE;\n-  *token = *context->list.first++;\n-  token->flags |= flags;\n+  if (list.first != list.limit)\n+    {\n+      /* Push its context.  */\n+      context = next_context (pfile);\n+      context->list = list;\n+      context->macro = macro;\n \n-  /* Disable the macro within its expansion.  */\n-  macro->disabled = 1;\n+      /* Disable the macro within its expansion.  */\n+      macro->disabled = 1;\n+    }\n \n   return 1;\n }\n@@ -895,8 +881,9 @@ _cpp_get_token (pfile, token)\n      cpp_reader *pfile;\n      cpp_token *token;\n {\n- next_token:\n-  do\n+  unsigned char flags = 0;\n+\n+  for (;;)\n     {\n       cpp_context *context = pfile->context;\n \n@@ -906,24 +893,28 @@ _cpp_get_token (pfile, token)\n       else if (!context->prev)\n \t_cpp_lex_token (pfile, token);\n       else if (context->list.first != context->list.limit)\n-\t*token = *context->list.first++;\n+\t{\n+\t  *token = *context->list.first++;\n+\t  token->flags |= flags;\n+\t  flags = 0;\n+\t}\n       else\n \t{\n \t  if (context->macro)\n \t    {\n \t      _cpp_pop_context (pfile);\n-\t      goto next_token;\n+\t      continue;\n \t    }\n \t  /* End of argument pre-expansion.  */\n \t  token->type = CPP_EOF;\n \t  token->flags = 0;\n \t  return;\n \t}\n-    }\n-  while (pfile->skipping);\n \n-  for (;;)\n-    {\n+      /* Loop until we're not skipping.  */\n+      if (pfile->skipping)\n+\tcontinue;\n+\n       if (token->flags & PASTE_LEFT)\n \tpaste_all_tokens (pfile, token);\n \n@@ -935,31 +926,32 @@ _cpp_get_token (pfile, token)\n \t  && !pfile->state.prevent_expansion\n \t  && !(token->flags & NO_EXPAND))\n \t{\n-\t  int m;\n+\t  cpp_hashnode *node = token->val.node;\n \n \t  /* Macros invalidate controlling macros.  */\n \t  pfile->mi_state = MI_FAILED;\n \n-\t  if (token->val.node->flags & NODE_BUILTIN)\n+\t  if (node->flags & NODE_BUILTIN)\n \t    {\n \t      builtin_macro (pfile, token);\n \t      break;\n \t    }\n \n-\t  m = enter_macro_context (pfile, token);\n-\t  if (m == 1)\n+\t  /* Merge PREV_WHITE of tokens.  */\n+\t  flags = token->flags & PREV_WHITE;\n+\n+\t  if (node->value.macro->disabled)\n+\t    token->flags |= NO_EXPAND;\n+\t  else if (enter_macro_context (pfile, node))\n \t    continue;\n-\t  if (m == 2)\n-\t    goto next_token;\n \t}\n \n       if (token->val.node != pfile->spec_nodes.n__Pragma)\n \tbreak;\n \n-      /* Invalidate controlling macros.  */\n+      /* Handle it, and get another token.  */\n       pfile->mi_state = MI_FAILED;\n       _cpp_do__Pragma (pfile);\n-      goto next_token;\n     }\n }\n "}]}