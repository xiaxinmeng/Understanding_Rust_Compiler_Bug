{"sha": "59011a60c01403fec67e08bc6b94bb44da920482", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTkwMTFhNjBjMDE0MDNmZWM2N2UwOGJjNmI5NGJiNDRkYTkyMDQ4Mg==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2010-03-18T02:38:17Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2010-03-18T02:38:17Z"}, "message": "re PR fortran/43265 (No EOF condition if reading with '(x)' from an empty file)\n\n2010-03-17  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libfortran/43265\n\t* io/io.h: Delete prototype for read_sf, making it static.\n\t* io/read.c (read_x): Modify to call hit_eof if PAD=\"no\".\n\t* io/transfer.c (read_sf_internal): New static function extracted from\n\tread_sf for use on internal units only. Handle empty string case.\n\t(read_sf): New factoring of this function, make it static.  Add special\n\tconditions for EOF based on ADVANCE=\"no\", PAD=\"no\", and whether any\n\tbytes have been previously read from the record.\n\t(read_block_form): Modify to call read_sf or read_sf_internal.\n\t(next_record_r): Add a done flag similar to next_record_w. Call hit_eof\n\tif internal array unit next record returns finished, meaning an EOF was\n\tfound and not done, ie not the last record expected.  For external\n\tunits call hit_eof if item_count is 1 or there are no pending spaces.\n\t(next_record): Update call to next_record_r.\n\nFrom-SVN: r157527", "tree": {"sha": "7c1839131a6afe8a4689fb882f4a40ba696bb7b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c1839131a6afe8a4689fb882f4a40ba696bb7b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59011a60c01403fec67e08bc6b94bb44da920482", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59011a60c01403fec67e08bc6b94bb44da920482", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59011a60c01403fec67e08bc6b94bb44da920482", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59011a60c01403fec67e08bc6b94bb44da920482/comments", "author": null, "committer": null, "parents": [{"sha": "5408fbe892f610330f2d06f1cbdae515c1656443", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5408fbe892f610330f2d06f1cbdae515c1656443", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5408fbe892f610330f2d06f1cbdae515c1656443"}], "stats": {"total": 134, "additions": 100, "deletions": 34}, "files": [{"sha": "af5fefe05d87e5ddd82b92010bc73a1bad5d7ffb", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59011a60c01403fec67e08bc6b94bb44da920482/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59011a60c01403fec67e08bc6b94bb44da920482/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=59011a60c01403fec67e08bc6b94bb44da920482", "patch": "@@ -1,3 +1,20 @@\n+2010-03-17  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libfortran/43265\n+\t* io/io.h: Delete prototype for read_sf, making it static.\n+\t* io/read.c (read_x): Modify to call hit_eof if PAD=\"no\".\n+\t* io/transfer.c (read_sf_internal): New static function extracted from\n+\tread_sf for use on internal units only. Handle empty string case.\n+\t(read_sf): New factoring of this function, make it static.  Add special\n+\tconditions for EOF based on ADVANCE=\"no\", PAD=\"no\", and whether any\n+\tbytes have been previously read from the record.\n+\t(read_block_form): Modify to call read_sf or read_sf_internal.\n+\t(next_record_r): Add a done flag similar to next_record_w. Call hit_eof\n+\tif internal array unit next record returns finished, meaning an EOF was\n+\tfound and not done, ie not the last record expected.  For external\n+\tunits call hit_eof if item_count is 1 or there are no pending spaces.\n+\t(next_record): Update call to next_record_r.\n+\n 2010-03-12  Kai Tietz  <kai.tietz@onevision.com>\n \n \tPR/42950"}, {"sha": "aa79eddabba2157da0277287676fe3f37d7a7707", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59011a60c01403fec67e08bc6b94bb44da920482/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59011a60c01403fec67e08bc6b94bb44da920482/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=59011a60c01403fec67e08bc6b94bb44da920482", "patch": "@@ -642,9 +642,6 @@ internal_proto(type_name);\n extern void * read_block_form (st_parameter_dt *, int *);\n internal_proto(read_block_form);\n \n-extern char *read_sf (st_parameter_dt *, int *);\n-internal_proto(read_sf);\n-\n extern void *write_block (st_parameter_dt *, int);\n internal_proto(write_block);\n "}, {"sha": "078c6e25fc827130598ed88c4ef866a59f85b9d4", "filename": "libgfortran/io/read.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59011a60c01403fec67e08bc6b94bb44da920482/libgfortran%2Fio%2Fread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59011a60c01403fec67e08bc6b94bb44da920482/libgfortran%2Fio%2Fread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fread.c?ref=59011a60c01403fec67e08bc6b94bb44da920482", "patch": "@@ -1047,11 +1047,22 @@ read_x (st_parameter_dt *dtp, int n)\n     }\n \n   p = fbuf_read (dtp->u.p.current_unit, &length);\n-  if (p == NULL || (length == 0 && dtp->u.p.item_count == 1))\n+  if (p == NULL)\n     {\n       hit_eof (dtp);\n       return;\n     }\n+  \n+  if (length == 0 && dtp->u.p.item_count == 1)\n+    {\n+      if (dtp->u.p.current_unit->pad_status == PAD_NO)\n+\t{\n+\t  hit_eof (dtp);\n+\t  return;\n+\t}\n+      else\n+\treturn;\n+    }\n \n   n = 0;\n   while (n < length)"}, {"sha": "9c87b5e4fbd79335af0b9af32184b7adc6a54dc3", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 71, "deletions": 30, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59011a60c01403fec67e08bc6b94bb44da920482/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59011a60c01403fec67e08bc6b94bb44da920482/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=59011a60c01403fec67e08bc6b94bb44da920482", "patch": "@@ -175,9 +175,7 @@ current_mode (st_parameter_dt *dtp)\n }\n \n \n-/* Mid level data transfer statements.  These subroutines do reading\n-   and writing in the style of salloc_r()/salloc_w() within the\n-   current record.  */\n+/* Mid level data transfer statements.  */\n \n /* When reading sequential formatted records we have a problem.  We\n    don't know how long the line is until we read the trailing newline,\n@@ -190,13 +188,22 @@ current_mode (st_parameter_dt *dtp)\n    we hit the newline.  For small allocations, we use a static buffer.\n    For larger allocations, we are forced to allocate memory on the\n    heap.  Hopefully this won't happen very often.  */\n+   \n+/* Read sequential file - internal unit  */\n \n char *\n-read_sf (st_parameter_dt *dtp, int * length)\n+read_sf_internal (st_parameter_dt *dtp, int * length);\n+char *\n+read_sf_internal (st_parameter_dt *dtp, int * length)\n {\n   static char *empty_string[0];\n-  char *base, *p, q;\n-  int n, lorig, memread, seen_comma;\n+  char *base;\n+  int lorig;\n+\n+  /* Zero size array gives internal unit len of 0.  Nothing to read. */\n+  if (dtp->internal_unit_len == 0\n+      && dtp->u.p.current_unit->pad_status == PAD_NO)\n+    hit_eof (dtp);\n \n   /* If we have seen an eor previously, return a length of 0.  The\n      caller is responsible for correctly padding the input field.  */\n@@ -208,17 +215,40 @@ read_sf (st_parameter_dt *dtp, int * length)\n       return (char*) empty_string;\n     }\n \n-  if (is_internal_unit (dtp))\n+  lorig = *length;\n+  base = mem_alloc_r (dtp->u.p.current_unit->s, length);\n+  if (unlikely (lorig > *length))\n     {\n-      memread = *length;\n-      base = mem_alloc_r (dtp->u.p.current_unit->s, length);\n-      if (unlikely (memread > *length))\n-\t{\n-          hit_eof (dtp);\n-\t  return NULL;\n-\t}\n-      n = *length;\n-      goto done;\n+      hit_eof (dtp);\n+      return NULL;\n+    }\n+\n+  dtp->u.p.current_unit->bytes_left -= *length;\n+\n+  if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n+    dtp->u.p.size_used += (GFC_IO_INT) *length;\n+\n+  return base;\n+\n+}\n+\n+/* Read sequential file - external unit */\n+\n+static char *\n+read_sf (st_parameter_dt *dtp, int * length)\n+{\n+  static char *empty_string[0];\n+  char *base, *p, q;\n+  int n, lorig, seen_comma;\n+\n+  /* If we have seen an eor previously, return a length of 0.  The\n+     caller is responsible for correctly padding the input field.  */\n+  if (dtp->u.p.sf_seen_eor)\n+    {\n+      *length = 0;\n+      /* Just return something that isn't a NULL pointer, otherwise the\n+         caller thinks an error occured.  */\n+      return (char*) empty_string;\n     }\n \n   n = seen_comma = 0;\n@@ -307,11 +337,14 @@ read_sf (st_parameter_dt *dtp, int * length)\n \t  else\n \t    dtp->u.p.at_eof = 1;\n \t}\n-      else\n-        {\n-          hit_eof (dtp);\n-          return NULL;\n-        }\n+      else if (dtp->u.p.advance_status == ADVANCE_NO\n+\t       || dtp->u.p.current_unit->pad_status == PAD_NO\n+\t       || dtp->u.p.current_unit->bytes_left\n+\t\t    == dtp->u.p.current_unit->recl)\n+\t{\n+\t  hit_eof (dtp);\n+\t  return NULL;\n+\t}\n     }\n \n  done:\n@@ -352,17 +385,19 @@ read_block_form (st_parameter_dt *dtp, int * nbytes)\n             dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n \t  else\n \t    {\n-\t      if (unlikely (dtp->u.p.current_unit->pad_status == PAD_NO))\n+\t      if (unlikely (dtp->u.p.current_unit->pad_status == PAD_NO)\n+\t\t  && !is_internal_unit (dtp))\n \t\t{\n \t\t  /* Not enough data left.  */\n \t\t  generate_error (&dtp->common, LIBERROR_EOR, NULL);\n \t\t  return NULL;\n \t\t}\n \t    }\n \n-\t  if (unlikely (dtp->u.p.current_unit->bytes_left == 0))\n+\t  if (unlikely (dtp->u.p.current_unit->bytes_left == 0\n+\t      && !is_internal_unit(dtp)))\n \t    {\n-              hit_eof (dtp);\n+\t      hit_eof (dtp);\n \t      return NULL;\n \t    }\n \n@@ -374,7 +409,11 @@ read_block_form (st_parameter_dt *dtp, int * nbytes)\n       (dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL ||\n        dtp->u.p.current_unit->flags.access == ACCESS_STREAM))\n     {\n-      source = read_sf (dtp, nbytes);\n+      if (is_internal_unit (dtp))\n+\tsource = read_sf_internal (dtp, nbytes);\n+      else\n+\tsource = read_sf (dtp, nbytes);\n+\n       dtp->u.p.current_unit->strm_pos +=\n \t(gfc_offset) (*nbytes + dtp->u.p.sf_seen_eor);\n       return source;\n@@ -2731,7 +2770,7 @@ min_off (gfc_offset a, gfc_offset b)\n /* Space to the next record for read mode.  */\n \n static void\n-next_record_r (st_parameter_dt *dtp)\n+next_record_r (st_parameter_dt *dtp, int done)\n {\n   gfc_offset record;\n   int bytes_left;\n@@ -2758,10 +2797,9 @@ next_record_r (st_parameter_dt *dtp)\n     case FORMATTED_SEQUENTIAL:\n       /* read_sf has already terminated input because of an '\\n', or\n          we have hit EOF.  */\n-      if (dtp->u.p.sf_seen_eor || dtp->u.p.at_eof)\n+      if (dtp->u.p.sf_seen_eor)\n \t{\n \t  dtp->u.p.sf_seen_eor = 0;\n-          dtp->u.p.at_eof = 0;\n \t  break;\n \t}\n \n@@ -2773,6 +2811,8 @@ next_record_r (st_parameter_dt *dtp)\n \n \t      record = next_array_record (dtp, dtp->u.p.current_unit->ls,\n \t\t\t\t\t  &finished);\n+\t      if (!done && finished)\n+\t\thit_eof (dtp);\n \n \t      /* Now seek to this record.  */\n \t      record = record * dtp->u.p.current_unit->recl;\n@@ -2810,7 +2850,8 @@ next_record_r (st_parameter_dt *dtp)\n \t\t{\n                   if (errno != 0)\n                     generate_error (&dtp->common, LIBERROR_OS, NULL);\n-\t\t  else if (dtp->u.p.item_count == 1)\n+\t\t  else if (dtp->u.p.item_count == 1\n+\t\t\t   || dtp->u.p.pending_spaces == 0)\n \t\t    hit_eof (dtp);\n \t\t  break;\n                 }\n@@ -3151,7 +3192,7 @@ next_record (st_parameter_dt *dtp, int done)\n   dtp->u.p.current_unit->read_bad = 0;\n \n   if (dtp->u.p.mode == READING)\n-    next_record_r (dtp);\n+    next_record_r (dtp, done);\n   else\n     next_record_w (dtp, done);\n "}]}