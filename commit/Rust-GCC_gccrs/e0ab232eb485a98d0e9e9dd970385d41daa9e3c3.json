{"sha": "e0ab232eb485a98d0e9e9dd970385d41daa9e3c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBhYjIzMmViNDg1YTk4ZDBlOWU5ZGQ5NzAzODVkNDFkYWE5ZTNjMw==", "commit": {"author": {"name": "Revital Eres", "email": "eres@il.ibm.com", "date": "2007-07-31T10:24:34Z"}, "committer": {"name": "Revital Eres", "email": "revitale@gcc.gnu.org", "date": "2007-07-31T10:24:34Z"}, "message": "SMS: Change the ddg's construction\n\nFrom-SVN: r127085", "tree": {"sha": "bf407c0e3f56f1a6a20d73681eb4bfaa7a7a351b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf407c0e3f56f1a6a20d73681eb4bfaa7a7a351b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0ab232eb485a98d0e9e9dd970385d41daa9e3c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0ab232eb485a98d0e9e9dd970385d41daa9e3c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0ab232eb485a98d0e9e9dd970385d41daa9e3c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0ab232eb485a98d0e9e9dd970385d41daa9e3c3/comments", "author": {"login": "revit13", "id": 16211463, "node_id": "MDQ6VXNlcjE2MjExNDYz", "avatar_url": "https://avatars.githubusercontent.com/u/16211463?v=4", "gravatar_id": "", "url": "https://api.github.com/users/revit13", "html_url": "https://github.com/revit13", "followers_url": "https://api.github.com/users/revit13/followers", "following_url": "https://api.github.com/users/revit13/following{/other_user}", "gists_url": "https://api.github.com/users/revit13/gists{/gist_id}", "starred_url": "https://api.github.com/users/revit13/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/revit13/subscriptions", "organizations_url": "https://api.github.com/users/revit13/orgs", "repos_url": "https://api.github.com/users/revit13/repos", "events_url": "https://api.github.com/users/revit13/events{/privacy}", "received_events_url": "https://api.github.com/users/revit13/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "80b8eb11efffd0b634b3e2ebe599c9bda0fac5ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80b8eb11efffd0b634b3e2ebe599c9bda0fac5ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80b8eb11efffd0b634b3e2ebe599c9bda0fac5ac"}], "stats": {"total": 186, "additions": 89, "deletions": 97}, "files": [{"sha": "2273fbc346c361d4e5c74a616e269c80ea67355f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0ab232eb485a98d0e9e9dd970385d41daa9e3c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0ab232eb485a98d0e9e9dd970385d41daa9e3c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e0ab232eb485a98d0e9e9dd970385d41daa9e3c3", "patch": "@@ -1,3 +1,16 @@\n+2007-07-31  Revital Eres  <eres@il.ibm.com>\n+\n+\t* ddg.c (add_deps_for_def): Rename to...\n+\t(add_cross_iteration_register_deps): This.  Change implementation\n+\tto use only reaching def and def-use chains to construct the\n+\tinter loop dependencies.\n+\t(add_deps_for_use): Remove function.\n+\t(build_inter_loop_deps): Call add_cross_iteration_register_deps\n+\tfunction to build the inter loop dependencies.\n+\t* modulo-sched.c (sms_schedule): Build only\n+\treaching def and def-use chains for the propose of the ddg\n+\tconstruction.\n+\n 2007-07-31  Julian Brown  <julian@codesourcery.com>\n \n \t* config/arm/neon.md (vec_set<mode>_internal, vec_setv2di_internal):"}, {"sha": "22ad92fc9c4e9ece4b164fcf796ea0c546f33cd4", "filename": "gcc/ddg.c", "status": "modified", "additions": 75, "deletions": 95, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0ab232eb485a98d0e9e9dd970385d41daa9e3c3/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0ab232eb485a98d0e9e9dd970385d41daa9e3c3/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=e0ab232eb485a98d0e9e9dd970385d41daa9e3c3", "patch": "@@ -223,131 +223,111 @@ create_ddg_dep_no_link (ddg_ptr g, ddg_node_ptr from, ddg_node_ptr to,\n     add_edge_to_ddg (g, e);\n }\n \n-\f\n-/* Given a downwards exposed register def RD, add inter-loop true dependences\n-   for all its uses in the next iteration, and an output dependence to the\n-   first def of the next iteration.  */\n+\n+/* Given a downwards exposed register def LAST_DEF (which is the last\n+   definition of that register in the bb), add inter-loop true dependences\n+   to all its uses in the next iteration, an output dependence to the\n+   first def of the same register (possibly itself) in the next iteration\n+   and anti-dependences from its uses in the current iteration to the\n+   first definition in the next iteration.  */\n static void\n-add_deps_for_def (ddg_ptr g, struct df_ref *rd)\n+add_cross_iteration_register_deps (ddg_ptr g, struct df_ref *last_def)\n {\n-  int regno = DF_REF_REGNO (rd);\n-  struct df_ru_bb_info *bb_info = DF_RU_BB_INFO (g->bb);\n+  int regno = DF_REF_REGNO (last_def);\n   struct df_link *r_use;\n-  int use_before_def = false;\n-  rtx def_insn = DF_REF_INSN (rd);\n-  ddg_node_ptr src_node = get_node_of_insn (g, def_insn);\n+  int has_use_in_bb_p = false;\n+  rtx def_insn = DF_REF_INSN (last_def);\n+  ddg_node_ptr last_def_node = get_node_of_insn (g, def_insn);\n+  ddg_node_ptr use_node;\n+  struct df_rd_bb_info *bb_info = DF_RD_BB_INFO (g->bb);\n+  struct df_ref *first_def = df_bb_regno_first_def_find (g->bb, regno);\n+\n+  gcc_assert (last_def_node);\n+  gcc_assert (first_def);\n \n-  /* Create and inter-loop true dependence between RD and each of its uses\n-     that is upwards exposed in RD's block.  */\n-  for (r_use = DF_REF_CHAIN (rd); r_use != NULL; r_use = r_use->next)\n+  /* Create inter-loop true dependences and anti dependences.  */\n+  for (r_use = DF_REF_CHAIN (last_def); r_use != NULL; r_use = r_use->next)\n     {\n-      if (bitmap_bit_p (bb_info->gen, r_use->ref->id))\n-\t{\n-\t  rtx use_insn = DF_REF_INSN (r_use->ref);\n-\t  ddg_node_ptr dest_node = get_node_of_insn (g, use_insn);\n+      rtx use_insn = DF_REF_INSN (r_use->ref);\n \n-\t  gcc_assert (src_node && dest_node);\n+      if (BLOCK_FOR_INSN (use_insn) != g->bb)\n+\tcontinue;\n \n-\t  /* Any such upwards exposed use appears before the rd def.  */\n-\t  use_before_def = true;\n-\t  create_ddg_dep_no_link (g, src_node, dest_node, TRUE_DEP,\n+      /* ??? Do not handle uses with DF_REF_IN_NOTE notes.  */\n+      use_node = get_node_of_insn (g, use_insn);\n+      gcc_assert (use_node);\n+      has_use_in_bb_p = true;\n+      if (use_node->cuid <= last_def_node->cuid)\n+\t{\n+\t  /* Add true deps from last_def to it's uses in the next\n+\t     iteration.  Any such upwards exposed use appears before\n+\t     the last_def def.  */\n+\t  create_ddg_dep_no_link (g, last_def_node, use_node, TRUE_DEP,\n \t\t\t\t  REG_DEP, 1);\n \t}\n+      else\n+\t{\n+\t  /* Add anti deps from last_def's uses in the current iteration\n+\t     to the first def in the next iteration.  We do not add ANTI\n+\t     dep when there is an intra-loop TRUE dep in the opposite\n+\t     direction, but use regmoves to fix such disregarded ANTI\n+\t     deps when broken.\tIf the first_def reaches the USE then\n+\t     there is such a dep.  */\n+\t  ddg_node_ptr first_def_node = get_node_of_insn (g,\n+\t\t\t\t\t\t\t  first_def->insn);\n+\n+\t  gcc_assert (first_def_node);\n+\n+          if (last_def->id != first_def->id)\n+            {\n+#ifdef ENABLE_CHECKING\n+              gcc_assert (!bitmap_bit_p (bb_info->gen, first_def->id));\n+#endif\n+              create_ddg_dep_no_link (g, use_node, first_def_node, ANTI_DEP,\n+                                      REG_DEP, 1);\n+            }\n+\t}\n     }\n-\n-  /* Create an inter-loop output dependence between RD (which is the\n-     last def in its block, being downwards exposed) and the first def\n-     in its block.  Avoid creating a self output dependence.  Avoid creating\n-     an output dependence if there is a dependence path between the two defs\n-     starting with a true dependence followed by an anti dependence (i.e. if\n-     there is a use between the two defs.  */\n-  if (! use_before_def)\n+  /* Create an inter-loop output dependence between LAST_DEF (which is the\n+     last def in its block, being downwards exposed) and the first def in\n+     its block.  Avoid creating a self output dependence.  Avoid creating\n+     an output dependence if there is a dependence path between the two\n+     defs starting with a true dependence to a use which can be in the\n+     next iteration; followed by an anti dependence of that use to the\n+     first def (i.e. if there is a use between the two defs.)  */\n+  if (!has_use_in_bb_p)\n     {\n-      struct df_ref *def = df_bb_regno_first_def_find (g->bb, regno);\n-      int i;\n       ddg_node_ptr dest_node;\n \n-      if (!def || rd->id == def->id)\n+      if (last_def->id == first_def->id)\n \treturn;\n \n-      /* Check if there are uses after RD.  */\n-      for (i = src_node->cuid + 1; i < g->num_nodes; i++)\n-\t if (df_find_use (g->nodes[i].insn, DF_REF_REG (rd)))\n-\t   return;\n-\n-      dest_node = get_node_of_insn (g, def->insn);\n-      create_ddg_dep_no_link (g, src_node, dest_node, OUTPUT_DEP, REG_DEP, 1);\n+      dest_node = get_node_of_insn (g, first_def->insn);\n+      gcc_assert (dest_node);\n+      create_ddg_dep_no_link (g, last_def_node, dest_node,\n+\t\t\t      OUTPUT_DEP, REG_DEP, 1);\n     }\n }\n-\n-/* Given a register USE, add an inter-loop anti dependence to the first\n-   (nearest BLOCK_BEGIN) def of the next iteration, unless USE is followed\n-   by a def in the block.  */\n-static void\n-add_deps_for_use (ddg_ptr g, struct df_ref *use)\n-{\n-  int i;\n-  int regno = DF_REF_REGNO (use);\n-  struct df_ref *first_def = df_bb_regno_first_def_find (g->bb, regno);\n-  ddg_node_ptr use_node;\n-  ddg_node_ptr def_node;\n-  struct df_rd_bb_info *bb_info;\n-\n-  bb_info = DF_RD_BB_INFO (g->bb);\n-\n-  if (!first_def)\n-    return;\n-\n-  use_node = get_node_of_insn (g, use->insn);\n-  def_node = get_node_of_insn (g, first_def->insn);\n-\n-  gcc_assert (use_node && def_node);\n-\n-  /* Make sure there are no defs after USE.  */\n-  for (i = use_node->cuid + 1; i < g->num_nodes; i++)\n-     if (df_find_def (g->nodes[i].insn, DF_REF_REG (use)))\n-       return;\n-  /* We must not add ANTI dep when there is an intra-loop TRUE dep in\n-     the opposite direction. If the first_def reaches the USE then there is\n-     such a dep.  */\n-  if (! bitmap_bit_p (bb_info->gen, first_def->id))\n-    create_ddg_dep_no_link (g, use_node, def_node, ANTI_DEP, REG_DEP, 1);\n-}\n-\n /* Build inter-loop dependencies, by looking at DF analysis backwards.  */\n static void\n build_inter_loop_deps (ddg_ptr g)\n {\n-  unsigned rd_num, u_num;\n+  unsigned rd_num;\n   struct df_rd_bb_info *rd_bb_info;\n-  struct df_ru_bb_info *ru_bb_info;\n   bitmap_iterator bi;\n \n   rd_bb_info = DF_RD_BB_INFO (g->bb);\n \n-  /* Find inter-loop output and true deps by connecting downward exposed defs\n-     to the first def of the BB and to upwards exposed uses.  */\n+  /* Find inter-loop register output, true and anti deps.  */\n   EXECUTE_IF_SET_IN_BITMAP (rd_bb_info->gen, 0, rd_num, bi)\n-    {\n-      struct df_ref *rd = DF_DEFS_GET (rd_num);\n-\n-      add_deps_for_def (g, rd);\n-    }\n+  {\n+    struct df_ref *rd = DF_DEFS_GET (rd_num);\n \n-  ru_bb_info = DF_RU_BB_INFO (g->bb);\n-\n-  /* Find inter-loop anti deps.  We are interested in uses of the block that\n-     appear below all defs; this implies that these uses are killed.  */\n-  EXECUTE_IF_SET_IN_BITMAP (ru_bb_info->kill, 0, u_num, bi)\n-    {\n-      struct df_ref *use = DF_USES_GET (u_num);\n-      if (!(DF_REF_FLAGS (use) & DF_REF_IN_NOTE))\n-\t/* We are interested in uses of this BB.  */\n-\tif (BLOCK_FOR_INSN (use->insn) == g->bb)\n-\t  add_deps_for_use (g, use);\n-    }\n+    add_cross_iteration_register_deps (g, rd);\n+  }\n }\n \n+\n /* Given two nodes, analyze their RTL insns and add inter-loop mem deps\n    to ddg G.  */\n static void"}, {"sha": "a85a1095628a38395537edea2cf21b79fb9df691", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0ab232eb485a98d0e9e9dd970385d41daa9e3c3/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0ab232eb485a98d0e9e9dd970385d41daa9e3c3/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=e0ab232eb485a98d0e9e9dd970385d41daa9e3c3", "patch": "@@ -913,9 +913,8 @@ sms_schedule (void)\n   /* Init Data Flow analysis, to be used in interloop dep calculation.  */\n   df_set_flags (DF_LR_RUN_DCE);\n   df_rd_add_problem ();\n-  df_ru_add_problem ();\n   df_note_add_problem ();\n-  df_chain_add_problem (DF_DU_CHAIN + DF_UD_CHAIN);\n+  df_chain_add_problem (DF_DU_CHAIN);\n   df_analyze ();\n   regstat_compute_calls_crossed ();\n   sched_init ();"}]}