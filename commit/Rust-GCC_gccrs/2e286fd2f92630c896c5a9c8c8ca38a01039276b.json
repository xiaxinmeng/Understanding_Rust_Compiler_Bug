{"sha": "2e286fd2f92630c896c5a9c8c8ca38a01039276b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmUyODZmZDJmOTI2MzBjODk2YzVhOWM4YzhjYTM4YTAxMDM5Mjc2Yg==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2010-08-11T20:27:19Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2010-08-11T20:27:19Z"}, "message": "Remove expand_scalar_variables_ hack.\n\n2010-07-15  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* graphite-clast-to-gimple.c (debug_clast_name_index): Removed.\n\t(debug_clast_name_indexes_1): Removed.\n\t(debug_clast_name_indexes): Removed.\n\t(pbb_to_depth_to_oldiv): Removed.\n\t(build_iv_mapping): Replace the use of rename_map with iv_map.\n\t(translate_clast_user): Remove uses of rename_map.  Allocate and\n\tfree iv_map.\n\t(translate_clast_for_loop): Remove uses of rename_map.\n\t(translate_clast_for): Same.\n\t(translate_clast_guard): Same.\n\t(translate_clast): Same.\n\t(gloog): Same.\n\t* graphite-clast-to-gimple.h (debug_clast_name_indexes): Removed.\n\t* graphite-sese-to-poly.c (scev_analyzable_p): Moved...\n\t* sese.c (set_rename): Now static.\n\t(rename_variables_in_stmt): Removed.\n\t(rename_uses): New.\n\t(is_parameter): Removed.\n\t(is_iv): Removed.\n\t(expand_scalar_variables_call): Removed.\n\t(expand_scalar_variables_ssa_name): Removed.\n\t(expand_scalar_variables_expr): Removed.\n\t(expand_scalar_variables_stmt): Removed.\n\t(expand_scalar_variables): Removed.\n\t(rename_variables): Removed.\n\t(remove_condition): Removed.\n\t(get_true_edge_from_guard_bb): Removed.\n\t(get_false_edge_from_guard_bb): Removed.\n\t(struct igp): Removed.\n\t(default_before_guard): Removed.\n\t(convert_for_phi_arg): Removed.\n\t(add_guard_exit_phis): Removed.\n\t(insert_guard_phis): Removed.\n\t(graphite_copy_stmts_from_block): Now also uses iv_map and a\n\tregion.  Do not copy conditions.  Do not copy induction variables.\n\tCall rename_uses.\n\t(copy_bb_and_scalar_dependences): Allocate a local rename_map for\n\tthe translated statement.  Use the iv_map for the induction\n\tvariable renaming.\n\t* sese.h (copy_bb_and_scalar_dependences): Update declaration.\n\t(set_rename): Removed declaration.\n\t(scev_analyzable_p): ...here.\n\t* tree-chrec.c (chrec_apply_map): New.\n\t* tree-chrec.h (chrec_apply_map): Declared.\n\nFrom-SVN: r163139", "tree": {"sha": "04f1178767b7f854003a42f54777ec394c4d0f0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04f1178767b7f854003a42f54777ec394c4d0f0f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e286fd2f92630c896c5a9c8c8ca38a01039276b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e286fd2f92630c896c5a9c8c8ca38a01039276b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e286fd2f92630c896c5a9c8c8ca38a01039276b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e286fd2f92630c896c5a9c8c8ca38a01039276b/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e11d25e0190f001dbe176dcaaaffccb02d7bff95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e11d25e0190f001dbe176dcaaaffccb02d7bff95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e11d25e0190f001dbe176dcaaaffccb02d7bff95"}], "stats": {"total": 950, "additions": 293, "deletions": 657}, "files": [{"sha": "f333453ff5a1bc493fbbe717be7639fcb4cc5b4c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e286fd2f92630c896c5a9c8c8ca38a01039276b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e286fd2f92630c896c5a9c8c8ca38a01039276b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2e286fd2f92630c896c5a9c8c8ca38a01039276b", "patch": "@@ -1,3 +1,50 @@\n+2010-08-02  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* graphite-clast-to-gimple.c (debug_clast_name_index): Removed.\n+\t(debug_clast_name_indexes_1): Removed.\n+\t(debug_clast_name_indexes): Removed.\n+\t(pbb_to_depth_to_oldiv): Removed.\n+\t(build_iv_mapping): Replace the use of rename_map with iv_map.\n+\t(translate_clast_user): Remove uses of rename_map.  Allocate and\n+\tfree iv_map.\n+\t(translate_clast_for_loop): Remove uses of rename_map.\n+\t(translate_clast_for): Same.\n+\t(translate_clast_guard): Same.\n+\t(translate_clast): Same.\n+\t(gloog): Same.\n+\t* graphite-clast-to-gimple.h (debug_clast_name_indexes): Removed.\n+\t* graphite-sese-to-poly.c (scev_analyzable_p): Moved...\n+\t* sese.c (set_rename): Now static.\n+\t(rename_variables_in_stmt): Removed.\n+\t(rename_uses): New.\n+\t(is_parameter): Removed.\n+\t(is_iv): Removed.\n+\t(expand_scalar_variables_call): Removed.\n+\t(expand_scalar_variables_ssa_name): Removed.\n+\t(expand_scalar_variables_expr): Removed.\n+\t(expand_scalar_variables_stmt): Removed.\n+\t(expand_scalar_variables): Removed.\n+\t(rename_variables): Removed.\n+\t(remove_condition): Removed.\n+\t(get_true_edge_from_guard_bb): Removed.\n+\t(get_false_edge_from_guard_bb): Removed.\n+\t(struct igp): Removed.\n+\t(default_before_guard): Removed.\n+\t(convert_for_phi_arg): Removed.\n+\t(add_guard_exit_phis): Removed.\n+\t(insert_guard_phis): Removed.\n+\t(graphite_copy_stmts_from_block): Now also uses iv_map and a\n+\tregion.  Do not copy conditions.  Do not copy induction variables.\n+\tCall rename_uses.\n+\t(copy_bb_and_scalar_dependences): Allocate a local rename_map for\n+\tthe translated statement.  Use the iv_map for the induction\n+\tvariable renaming.\n+\t* sese.h (copy_bb_and_scalar_dependences): Update declaration.\n+\t(set_rename): Removed declaration.\n+\t(scev_analyzable_p): ...here.\n+\t* tree-chrec.c (chrec_apply_map): New.\n+\t* tree-chrec.h (chrec_apply_map): Declared.\n+\n 2010-08-02  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* graphite-clast-to-gimple.c (translate_clast_for_loop): Do not call"}, {"sha": "3c7615b39817ad39dbd97ec572020101f7a4d0fc", "filename": "gcc/ChangeLog.graphite", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e286fd2f92630c896c5a9c8c8ca38a01039276b/gcc%2FChangeLog.graphite", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e286fd2f92630c896c5a9c8c8ca38a01039276b/gcc%2FChangeLog.graphite", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.graphite?ref=2e286fd2f92630c896c5a9c8c8ca38a01039276b", "patch": "@@ -1,3 +1,50 @@\n+2010-07-15  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* graphite-clast-to-gimple.c (debug_clast_name_index): Removed.\n+\t(debug_clast_name_indexes_1): Removed.\n+\t(debug_clast_name_indexes): Removed.\n+\t(pbb_to_depth_to_oldiv): Removed.\n+\t(build_iv_mapping): Replace the use of rename_map with iv_map.\n+\t(translate_clast_user): Remove uses of rename_map.  Allocate and\n+\tfree iv_map.\n+\t(translate_clast_for_loop): Remove uses of rename_map.\n+\t(translate_clast_for): Same.\n+\t(translate_clast_guard): Same.\n+\t(translate_clast): Same.\n+\t(gloog): Same.\n+\t* graphite-clast-to-gimple.h (debug_clast_name_indexes): Removed.\n+\t* graphite-sese-to-poly.c (scev_analyzable_p): Moved...\n+\t* sese.c (set_rename): Now static.\n+\t(rename_variables_in_stmt): Removed.\n+\t(rename_uses): New.\n+\t(is_parameter): Removed.\n+\t(is_iv): Removed.\n+\t(expand_scalar_variables_call): Removed.\n+\t(expand_scalar_variables_ssa_name): Removed.\n+\t(expand_scalar_variables_expr): Removed.\n+\t(expand_scalar_variables_stmt): Removed.\n+\t(expand_scalar_variables): Removed.\n+\t(rename_variables): Removed.\n+\t(remove_condition): Removed.\n+\t(get_true_edge_from_guard_bb): Removed.\n+\t(get_false_edge_from_guard_bb): Removed.\n+\t(struct igp): Removed.\n+\t(default_before_guard): Removed.\n+\t(convert_for_phi_arg): Removed.\n+\t(add_guard_exit_phis): Removed.\n+\t(insert_guard_phis): Removed.\n+\t(graphite_copy_stmts_from_block): Now also uses iv_map and a\n+\tregion.  Do not copy conditions.  Do not copy induction variables.\n+\tCall rename_uses.\n+\t(copy_bb_and_scalar_dependences): Allocate a local rename_map for\n+\tthe translated statement.  Use the iv_map for the induction\n+\tvariable renaming.\n+\t* sese.h (copy_bb_and_scalar_dependences): Update declaration.\n+\t(set_rename): Removed declaration.\n+\t(scev_analyzable_p): ...here.\n+\t* tree-chrec.c (chrec_apply_map): New.\n+\t* tree-chrec.h (chrec_apply_map): Declared.\n+\n 2010-07-15  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* graphite-clast-to-gimple.c (translate_clast_for_loop): Do not call"}, {"sha": "90ea43520f10d7ad6331396f82e7cec96a60d3c1", "filename": "gcc/graphite-clast-to-gimple.c", "status": "modified", "additions": 42, "deletions": 87, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e286fd2f92630c896c5a9c8c8ca38a01039276b/gcc%2Fgraphite-clast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e286fd2f92630c896c5a9c8c8ca38a01039276b/gcc%2Fgraphite-clast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-clast-to-gimple.c?ref=2e286fd2f92630c896c5a9c8c8ca38a01039276b", "patch": "@@ -130,32 +130,6 @@ save_clast_name_index (htab_t index_table, const char *name, int index)\n     }\n }\n \n-/* Print to stderr the element ELT.  */\n-\n-static inline void\n-debug_clast_name_index (clast_name_index_p elt)\n-{\n-  fprintf (stderr, \"(index = %d, name = %s)\\n\", elt->index, elt->name);\n-}\n-\n-/* Helper function for debug_rename_map.  */\n-\n-static inline int\n-debug_clast_name_indexes_1 (void **slot, void *s ATTRIBUTE_UNUSED)\n-{\n-  struct clast_name_index *entry = (struct clast_name_index *) *slot;\n-  debug_clast_name_index (entry);\n-  return 1;\n-}\n-\n-/* Print to stderr all the elements of MAP.  */\n-\n-DEBUG_FUNCTION void\n-debug_clast_name_indexes (htab_t map)\n-{\n-  htab_traverse (map, debug_clast_name_indexes_1, NULL);\n-}\n-\n /* Computes a hash function for database element ELT.  */\n \n static inline hashval_t\n@@ -175,20 +149,6 @@ eq_clast_name_indexes (const void *e1, const void *e2)\n   return (elt1->name == elt2->name);\n }\n \n-\n-/* For a given loop DEPTH in the loop nest of the original black box\n-   PBB, return the old induction variable associated to that loop.  */\n-\n-static inline tree\n-pbb_to_depth_to_oldiv (poly_bb_p pbb, int depth)\n-{\n-  gimple_bb_p gbb = PBB_BLACK_BOX (pbb);\n-  sese region = SCOP_REGION (PBB_SCOP (pbb));\n-  loop_p loop = gbb_loop_at_index (gbb, region, depth);\n-\n-  return loop->single_iv;\n-}\n-\n /* For a given scattering dimension, return the new induction variable\n    associated to it.  */\n \n@@ -820,34 +780,36 @@ graphite_create_new_loop (sese region, edge entry_edge,\n   return loop;\n }\n \n-/* Inserts in RENAME_MAP a tuple (OLD_NAME, NEW_NAME) for the induction\n-   variables of the loops around GBB in SESE.  */\n+/* Inserts in iv_map a tuple (OLD_LOOP->num, NEW_NAME) for the\n+   induction variables of the loops around GBB in SESE.  */\n \n static void\n-build_iv_mapping (htab_t rename_map, sese region,\n+build_iv_mapping (VEC (tree, heap) *iv_map, sese region,\n \t\t  VEC (tree, heap) *newivs, htab_t newivs_index,\n \t\t  struct clast_user_stmt *user_stmt,\n \t\t  htab_t params_index)\n {\n   struct clast_stmt *t;\n-  int index = 0;\n+  int depth = 0;\n   CloogStatement *cs = user_stmt->statement;\n   poly_bb_p pbb = (poly_bb_p) cloog_statement_usr (cs);\n+  gimple_bb_p gbb = PBB_BLACK_BOX (pbb);\n \n-  for (t = user_stmt->substitutions; t; t = t->next, index++)\n+  for (t = user_stmt->substitutions; t; t = t->next, depth++)\n     {\n       struct clast_expr *expr = (struct clast_expr *)\n        ((struct clast_assignment *)t)->RHS;\n       tree type = gcc_type_for_clast_expr (expr, region, newivs,\n \t\t\t\t\t   newivs_index, params_index);\n-      tree old_name = pbb_to_depth_to_oldiv (pbb, index);\n-      tree e = clast_to_gcc_expression (type, expr, region, newivs,\n-\t\t\t\t\tnewivs_index, params_index);\n-      set_rename (rename_map, old_name, e);\n+      tree new_name = clast_to_gcc_expression (type, expr, region, newivs,\n+\t\t\t\t\t       newivs_index, params_index);\n+      loop_p old_loop = gbb_loop_at_index (gbb, region, depth);\n+\n+      VEC_replace (tree, iv_map, old_loop->num, new_name);\n     }\n }\n \n-/* Construct bb_pbb_def with BB and PBB. */\n+/* Construct bb_pbb_def with BB and PBB.  */\n \n static bb_pbb_def *\n new_bb_pbb_def (basic_block bb, poly_bb_p pbb)\n@@ -930,38 +892,39 @@ dependency_in_loop_p (loop_p loop, htab_t bb_pbb_mapping, int level)\n   return false;\n }\n \n-static edge\n-translate_clast (sese, loop_p, struct clast_stmt *, edge, htab_t,\n-\t\t VEC (tree, heap) **, htab_t, htab_t, int, htab_t);\n-\n /* Translates a clast user statement STMT to gimple.\n \n    - REGION is the sese region we used to generate the scop.\n    - NEXT_E is the edge where new generated code should be attached.\n    - CONTEXT_LOOP is the loop in which the generated code will be placed\n-   - RENAME_MAP contains a set of tuples of new names associated to\n-     the original variables names.\n    - BB_PBB_MAPPING is is a basic_block and it's related poly_bb_p mapping.\n    - PARAMS_INDEX connects the cloog parameters with the gimple parameters in\n      the sese region.  */\n static edge\n translate_clast_user (sese region, struct clast_user_stmt *stmt, edge next_e,\n-\t\t      htab_t rename_map, VEC (tree, heap) **newivs,\n+\t\t      VEC (tree, heap) **newivs,\n \t\t      htab_t newivs_index, htab_t bb_pbb_mapping,\n \t\t      htab_t params_index)\n {\n-  gimple_bb_p gbb;\n+  int i, nb_loops;\n   basic_block new_bb;\n   poly_bb_p pbb = (poly_bb_p) cloog_statement_usr (stmt->statement);\n-  gbb = PBB_BLACK_BOX (pbb);\n+  gimple_bb_p gbb = PBB_BLACK_BOX (pbb);\n+  VEC (tree, heap) *iv_map;\n \n   if (GBB_BB (gbb) == ENTRY_BLOCK_PTR)\n     return next_e;\n \n-  build_iv_mapping (rename_map, region, *newivs, newivs_index, stmt,\n-\t\t    params_index);\n+  nb_loops = number_of_loops ();\n+  iv_map = VEC_alloc (tree, heap, nb_loops);\n+  for (i = 0; i < nb_loops; i++)\n+    VEC_quick_push (tree, iv_map, NULL_TREE);\n+\n+  build_iv_mapping (iv_map, region, *newivs, newivs_index, stmt, params_index);\n   next_e = copy_bb_and_scalar_dependences (GBB_BB (gbb), region,\n-\t\t\t\t\t   next_e, rename_map);\n+\t\t\t\t\t   next_e, iv_map);\n+  VEC_free (tree, heap, iv_map);\n+\n   new_bb = next_e->src;\n   mark_bb_with_pbb (pbb, new_bb, bb_pbb_mapping);\n   update_ssa (TODO_update_ssa);\n@@ -1009,20 +972,21 @@ graphite_create_new_loop_guard (sese region, edge entry_edge,\n   return exit_edge;\n }\n \n+static edge\n+translate_clast (sese, loop_p, struct clast_stmt *, edge,\n+\t\t VEC (tree, heap) **, htab_t, htab_t, int, htab_t);\n \n /* Create the loop for a clast for statement.\n \n    - REGION is the sese region we used to generate the scop.\n    - NEXT_E is the edge where new generated code should be attached.\n-   - RENAME_MAP contains a set of tuples of new names associated to\n-     the original variables names.\n    - BB_PBB_MAPPING is is a basic_block and it's related poly_bb_p mapping.\n    - PARAMS_INDEX connects the cloog parameters with the gimple parameters in\n      the sese region.  */\n static edge\n translate_clast_for_loop (sese region, loop_p context_loop,\n \t\t\t  struct clast_for *stmt, edge next_e,\n-\t\t\t  htab_t rename_map, VEC (tree, heap) **newivs,\n+\t\t\t  VEC (tree, heap) **newivs,\n \t\t\t  htab_t newivs_index, htab_t bb_pbb_mapping,\n \t\t\t  int level, htab_t params_index)\n {\n@@ -1038,7 +1002,7 @@ translate_clast_for_loop (sese region, loop_p context_loop,\n   last_e = single_succ_edge (split_edge (last_e));\n \n   /* Translate the body of the loop.  */\n-  next_e = translate_clast (region, loop, stmt->body, to_body, rename_map,\n+  next_e = translate_clast (region, loop, stmt->body, to_body,\n \t\t\t    newivs, newivs_index, bb_pbb_mapping, level + 1,\n \t\t\t    params_index);\n   redirect_edge_succ_nodup (next_e, after);\n@@ -1058,23 +1022,20 @@ translate_clast_for_loop (sese region, loop_p context_loop,\n \n    - REGION is the sese region we used to generate the scop.\n    - NEXT_E is the edge where new generated code should be attached.\n-   - RENAME_MAP contains a set of tuples of new names associated to\n-     the original variables names.\n    - BB_PBB_MAPPING is is a basic_block and it's related poly_bb_p mapping.\n    - PARAMS_INDEX connects the cloog parameters with the gimple parameters in\n      the sese region.  */\n static edge\n translate_clast_for (sese region, loop_p context_loop, struct clast_for *stmt,\n-\t\t     edge next_e, htab_t rename_map, VEC (tree, heap) **newivs,\n+\t\t     edge next_e, VEC (tree, heap) **newivs,\n \t\t     htab_t newivs_index, htab_t bb_pbb_mapping, int level,\n \t\t     htab_t params_index)\n {\n   edge last_e = graphite_create_new_loop_guard (region, next_e, stmt, *newivs,\n \t\t\t\t\t\tnewivs_index, params_index);\n   edge true_e = get_true_edge_from_guard_bb (next_e->dest);\n \n-  translate_clast_for_loop (region, context_loop, stmt, true_e,\n-\t\t\t    rename_map, newivs,\n+  translate_clast_for_loop (region, context_loop, stmt, true_e, newivs,\n \t\t\t    newivs_index, bb_pbb_mapping, level,\n \t\t\t    params_index);\n   return last_e;\n@@ -1085,15 +1046,13 @@ translate_clast_for (sese region, loop_p context_loop, struct clast_for *stmt,\n    - REGION is the sese region we used to generate the scop.\n    - NEXT_E is the edge where new generated code should be attached.\n    - CONTEXT_LOOP is the loop in which the generated code will be placed\n-   - RENAME_MAP contains a set of tuples of new names associated to\n-     the original variables names.\n    - BB_PBB_MAPPING is is a basic_block and it's related poly_bb_p mapping.\n    - PARAMS_INDEX connects the cloog parameters with the gimple parameters in\n      the sese region.  */\n static edge\n translate_clast_guard (sese region, loop_p context_loop,\n \t\t       struct clast_guard *stmt, edge next_e,\n-\t\t       htab_t rename_map, VEC (tree, heap) **newivs,\n+\t\t       VEC (tree, heap) **newivs,\n \t\t       htab_t newivs_index, htab_t bb_pbb_mapping, int level,\n \t\t       htab_t params_index)\n {\n@@ -1102,7 +1061,7 @@ translate_clast_guard (sese region, loop_p context_loop,\n   edge true_e = get_true_edge_from_guard_bb (next_e->dest);\n \n   translate_clast (region, context_loop, stmt->then, true_e,\n-\t\t   rename_map, newivs, newivs_index, bb_pbb_mapping,\n+\t\t   newivs, newivs_index, bb_pbb_mapping,\n \t\t   level, params_index);\n   return last_e;\n }\n@@ -1112,12 +1071,10 @@ translate_clast_guard (sese region, loop_p context_loop,\n \n    - NEXT_E is the edge where new generated code should be attached.\n    - CONTEXT_LOOP is the loop in which the generated code will be placed\n-   - RENAME_MAP contains a set of tuples of new names associated to\n-     the original variables names.\n    - BB_PBB_MAPPING is is a basic_block and it's related poly_bb_p mapping.  */\n static edge\n translate_clast (sese region, loop_p context_loop, struct clast_stmt *stmt,\n-\t\t edge next_e, htab_t rename_map, VEC (tree, heap) **newivs,\n+\t\t edge next_e, VEC (tree, heap) **newivs,\n \t\t htab_t newivs_index, htab_t bb_pbb_mapping, int level,\n \t\t htab_t params_index)\n {\n@@ -1129,25 +1086,25 @@ translate_clast (sese region, loop_p context_loop, struct clast_stmt *stmt,\n \n   else if (CLAST_STMT_IS_A (stmt, stmt_user))\n     next_e = translate_clast_user (region, (struct clast_user_stmt *) stmt,\n-\t\t\t\t   next_e, rename_map, newivs, newivs_index,\n+\t\t\t\t   next_e, newivs, newivs_index,\n \t\t\t\t   bb_pbb_mapping, params_index);\n \n   else if (CLAST_STMT_IS_A (stmt, stmt_for))\n     next_e = translate_clast_for (region, context_loop,\n \t\t\t\t  (struct clast_for *) stmt, next_e,\n-\t\t\t\t  rename_map, newivs, newivs_index,\n+\t\t\t\t  newivs, newivs_index,\n \t\t\t\t  bb_pbb_mapping, level, params_index);\n \n   else if (CLAST_STMT_IS_A (stmt, stmt_guard))\n     next_e = translate_clast_guard (region, context_loop,\n \t\t\t\t    (struct clast_guard *) stmt, next_e,\n-\t\t\t\t    rename_map, newivs, newivs_index,\n+\t\t\t\t    newivs, newivs_index,\n \t\t\t\t    bb_pbb_mapping, level, params_index);\n \n   else if (CLAST_STMT_IS_A (stmt, stmt_block))\n     next_e = translate_clast (region, context_loop,\n \t\t\t      ((struct clast_block *) stmt)->body,\n-\t\t\t      next_e, rename_map, newivs, newivs_index,\n+\t\t\t      next_e, newivs, newivs_index,\n \t\t\t      bb_pbb_mapping, level, params_index);\n   else\n     gcc_unreachable();\n@@ -1156,7 +1113,7 @@ translate_clast (sese region, loop_p context_loop, struct clast_stmt *stmt,\n   graphite_verify ();\n \n   return translate_clast (region, context_loop, stmt->next, next_e,\n-\t\t\t  rename_map, newivs, newivs_index,\n+\t\t\t  newivs, newivs_index,\n \t\t\t  bb_pbb_mapping, level, params_index);\n }\n \n@@ -1483,7 +1440,7 @@ gloog (scop_p scop, htab_t bb_pbb_mapping)\n   loop_p context_loop;\n   sese region = SCOP_REGION (scop);\n   ifsese if_region = NULL;\n-  htab_t rename_map, newivs_index, params_index;\n+  htab_t newivs_index, params_index;\n   cloog_prog_clast pc;\n \n   timevar_push (TV_GRAPHITE_CODE_GEN);\n@@ -1510,7 +1467,6 @@ gloog (scop_p scop, htab_t bb_pbb_mapping)\n   graphite_verify ();\n \n   context_loop = SESE_ENTRY (region)->src->loop_father;\n-  rename_map = htab_create (10, rename_map_elt_info, eq_rename_map_elts, free);\n   newivs_index = htab_create (10, clast_name_index_elt_info,\n \t\t\t      eq_clast_name_indexes, free);\n   params_index = htab_create (10, clast_name_index_elt_info,\n@@ -1520,7 +1476,7 @@ gloog (scop_p scop, htab_t bb_pbb_mapping)\n \n   translate_clast (region, context_loop, pc.stmt,\n \t\t   if_region->true_region->entry,\n-\t\t   rename_map, &newivs, newivs_index,\n+\t\t   &newivs, newivs_index,\n \t\t   bb_pbb_mapping, 1, params_index);\n   graphite_verify ();\n   scev_reset_htab ();\n@@ -1534,7 +1490,6 @@ gloog (scop_p scop, htab_t bb_pbb_mapping)\n   free (if_region->region);\n   free (if_region);\n \n-  htab_delete (rename_map);\n   htab_delete (newivs_index);\n   htab_delete (params_index);\n   VEC_free (tree, heap, newivs);"}, {"sha": "fbb4efa3f1f88cf55da53a47b6f3859376b29f70", "filename": "gcc/graphite-clast-to-gimple.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e286fd2f92630c896c5a9c8c8ca38a01039276b/gcc%2Fgraphite-clast-to-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e286fd2f92630c896c5a9c8c8ca38a01039276b/gcc%2Fgraphite-clast-to-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-clast-to-gimple.h?ref=2e286fd2f92630c896c5a9c8c8ca38a01039276b", "patch": "@@ -40,7 +40,6 @@ extern bool gloog (scop_p, htab_t);\n extern cloog_prog_clast scop_to_clast (scop_p);\n extern void debug_clast_stmt (struct clast_stmt *);\n extern void print_clast_stmt (FILE *, struct clast_stmt *);\n-extern void debug_clast_name_indexes (htab_t);\n \n /* Hash function for data base element BB_PBB.  */\n "}, {"sha": "b9bf2844a21ac9fbe957f10822f553147943ea81", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e286fd2f92630c896c5a9c8c8ca38a01039276b/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e286fd2f92630c896c5a9c8c8ca38a01039276b/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=2e286fd2f92630c896c5a9c8c8ca38a01039276b", "patch": "@@ -2333,20 +2333,6 @@ rewrite_reductions_out_of_ssa (scop_p scop)\n #endif\n }\n \n-/* Return true when DEF can be analyzed in REGION by the scalar\n-   evolution analyzer.  */\n-\n-static bool\n-scev_analyzable_p (tree def, sese region)\n-{\n-  gimple stmt = SSA_NAME_DEF_STMT (def);\n-  loop_p loop = loop_containing_stmt (stmt);\n-  tree scev = scalar_evolution_in_region (region, loop, def);\n-\n-  return !chrec_contains_undetermined (scev)\n-    && TREE_CODE (scev) != SSA_NAME;\n-}\n-\n /* Rewrite the scalar dependence of DEF used in USE_STMT with a memory\n    read from ZERO_DIM_ARRAY.  */\n "}, {"sha": "583504de2d701510c2fe758397506edb94f0b15e", "filename": "gcc/sese.c", "status": "modified", "additions": 122, "deletions": 553, "changes": 675, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e286fd2f92630c896c5a9c8c8ca38a01039276b/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e286fd2f92630c896c5a9c8c8ca38a01039276b/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=2e286fd2f92630c896c5a9c8c8ca38a01039276b", "patch": "@@ -394,6 +394,38 @@ sese_insert_phis_for_liveouts (sese region, basic_block bb,\n   update_ssa (TODO_update_ssa);\n }\n \n+/* Returns the first successor edge of BB with EDGE_TRUE_VALUE flag set.  */\n+\n+edge\n+get_true_edge_from_guard_bb (basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    if (e->flags & EDGE_TRUE_VALUE)\n+      return e;\n+\n+  gcc_unreachable ();\n+  return NULL;\n+}\n+\n+/* Returns the first successor edge of BB with EDGE_TRUE_VALUE flag cleared.  */\n+\n+edge\n+get_false_edge_from_guard_bb (basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    if (!(e->flags & EDGE_TRUE_VALUE))\n+      return e;\n+\n+  gcc_unreachable ();\n+  return NULL;\n+}\n+\n /* Returns the expression associated to OLD_NAME in RENAME_MAP.  */\n \n static tree\n@@ -409,12 +441,12 @@ get_rename (htab_t rename_map, tree old_name)\n   if (slot && *slot)\n     return ((rename_map_elt) *slot)->expr;\n \n-  return old_name;\n+  return NULL_TREE;\n }\n \n /* Register in RENAME_MAP the rename tuple (OLD_NAME, EXPR).  */\n \n-void\n+static void\n set_rename (htab_t rename_map, tree old_name, tree expr)\n {\n   struct rename_map_elt_s tmp;\n@@ -435,579 +467,101 @@ set_rename (htab_t rename_map, tree old_name, tree expr)\n   *slot = new_rename_map_elt (old_name, expr);\n }\n \n-/* Rename the SSA_NAMEs used in STMT and that appear in RENAME_MAP.  */\n+/* Renames the scalar uses of the statement COPY, using the\n+   substitution map RENAME_MAP, inserting the gimplification code at\n+   GSI_TGT, for the translation REGION, with the original copied\n+   statement in LOOP, and using the induction variable renaming map\n+   IV_MAP.  */\n \n static void\n-rename_variables_in_stmt (gimple stmt, htab_t rename_map, gimple_stmt_iterator *insert_gsi)\n+rename_uses (gimple copy, htab_t rename_map, gimple_stmt_iterator *gsi_tgt,\n+\t     sese region, loop_p loop, VEC (tree, heap) *iv_map)\n {\n-  ssa_op_iter iter;\n   use_operand_p use_p;\n+  ssa_op_iter op_iter;\n \n-  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES)\n+  FOR_EACH_SSA_USE_OPERAND (use_p, copy, op_iter, SSA_OP_ALL_USES)\n     {\n-      tree use = USE_FROM_PTR (use_p);\n-      tree expr, type_use, type_expr;\n+      tree old_name = USE_FROM_PTR (use_p);\n+      tree new_expr, scev;\n       gimple_seq stmts;\n \n-      if (TREE_CODE (use) != SSA_NAME)\n-\tcontinue;\n-\n-      expr = get_rename (rename_map, use);\n-      if (use == expr)\n+      if (TREE_CODE (old_name) != SSA_NAME\n+\t  || !is_gimple_reg (old_name)\n+\t  || SSA_NAME_IS_DEFAULT_DEF (old_name))\n \tcontinue;\n \n-      type_use = TREE_TYPE (use);\n-      type_expr = TREE_TYPE (expr);\n-\n-      if (type_use != type_expr\n-\t  || (TREE_CODE (expr) != SSA_NAME\n-\t      && is_gimple_reg (use)))\n+      new_expr = get_rename (rename_map, old_name);\n+      if (new_expr)\n \t{\n-\t  tree var;\n+\t  tree type_old_name = TREE_TYPE (old_name);\n+\t  tree type_new_expr = TREE_TYPE (new_expr);\n \n-\t  if (is_gimple_debug (stmt))\n+\t  if (type_old_name != type_new_expr\n+\t      || (TREE_CODE (new_expr) != SSA_NAME\n+\t\t  && is_gimple_reg (old_name)))\n \t    {\n-\t      if (gimple_debug_bind_p (stmt))\n-\t\tgimple_debug_bind_reset_value (stmt);\n-\t      else\n-\t\tgcc_unreachable ();\n-\n-\t      break;\n-\t    }\n-\n-\t  var = create_tmp_var (type_use, \"var\");\n-\n-\t  if (type_use != type_expr)\n-\t    expr = fold_convert (type_use, expr);\n-\n-\t  expr = build2 (MODIFY_EXPR, type_use, var, expr);\n-\t  expr = force_gimple_operand (expr, &stmts, true, NULL);\n-\t  gsi_insert_seq_before (insert_gsi, stmts, GSI_SAME_STMT);\n-\t}\n-\n-      replace_exp (use_p, expr);\n-    }\n-\n-  update_stmt (stmt);\n-}\n-\n-/* Returns true if NAME is a parameter of SESE.  */\n-\n-static bool\n-is_parameter (sese region, tree name)\n-{\n-  int i;\n-  tree p;\n-\n-  for (i = 0; VEC_iterate (tree, SESE_PARAMS (region), i, p); i++)\n-    if (p == name)\n-      return true;\n-\n-  return false;\n-}\n-\n-/* Returns true if NAME is an induction variable.  */\n-\n-static bool\n-is_iv (tree name)\n-{\n-  return gimple_code (SSA_NAME_DEF_STMT (name)) == GIMPLE_PHI;\n-}\n-\n-static void expand_scalar_variables_stmt (gimple, basic_block, sese,\n-\t\t\t\t\t  htab_t, gimple_stmt_iterator *);\n-static tree\n-expand_scalar_variables_expr (tree, tree, enum tree_code, tree, basic_block,\n-\t\t\t      sese, htab_t, gimple_stmt_iterator *);\n-\n-static tree\n-expand_scalar_variables_call (gimple stmt, basic_block bb, sese region,\n-\t\t\t      htab_t rename_map, gimple_stmt_iterator *gsi)\n-{\n-  int i, nargs = gimple_call_num_args (stmt);\n-  VEC (tree, gc) *args = VEC_alloc (tree, gc, nargs);\n-  tree fn_type = TREE_TYPE (gimple_call_fn (stmt));\n-  tree fn = gimple_call_fndecl (stmt);\n-  tree call_expr, var, lhs;\n-  gimple call;\n-\n-  for (i = 0; i < nargs; i++)\n-    {\n-      tree arg = gimple_call_arg (stmt, i);\n-      tree t = TREE_TYPE (arg);\n-\n-      var = create_tmp_var (t, \"var\");\n-      arg = expand_scalar_variables_expr (t, arg, TREE_CODE (arg), NULL,\n-\t\t\t\t\t  bb, region, rename_map, gsi);\n-      arg = build2 (MODIFY_EXPR, t, var, arg);\n-      arg = force_gimple_operand_gsi (gsi, arg, true, NULL,\n-\t\t\t\t      true, GSI_SAME_STMT);\n-      VEC_quick_push (tree, args, arg);\n-    }\n-\n-  lhs = gimple_call_lhs (stmt);\n-  var = create_tmp_var (TREE_TYPE (lhs), \"var\");\n-  call_expr = build_call_vec (fn_type, fn, args);\n-  call = gimple_build_call_from_tree (call_expr);\n-  var = make_ssa_name (var, call);\n-  gimple_call_set_lhs (call, var);\n-  gsi_insert_before (gsi, call, GSI_SAME_STMT);\n-\n-  return var;\n-}\n-\n-/* Copies at GSI all the scalar computations on which the ssa_name OP0\n-   depends on in the SESE: these are all the scalar variables used in\n-   the definition of OP0, that are defined outside BB and still in the\n-   SESE, i.e. not a parameter of the SESE.  The expression that is\n-   returned contains only induction variables from the generated code:\n-   RENAME_MAP contains the induction variables renaming mapping, and is used\n-   to translate the names of induction variables.  */\n-\n-static tree\n-expand_scalar_variables_ssa_name (tree type, tree op0, basic_block bb,\n-\t\t\t\t  sese region, htab_t rename_map,\n-\t\t\t\t  gimple_stmt_iterator *gsi)\n-{\n-  gimple def_stmt;\n-  tree new_op;\n-\n-  if (is_parameter (region, op0)\n-      || is_iv (op0))\n-    return fold_convert (type, get_rename (rename_map, op0));\n-\n-  def_stmt = SSA_NAME_DEF_STMT (op0);\n-\n-  /* Check whether we already have a rename for OP0.  */\n-  new_op = get_rename (rename_map, op0);\n-\n-  if (new_op != op0\n-      && gimple_bb (SSA_NAME_DEF_STMT (new_op)) == bb)\n-    return fold_convert (type, new_op);\n-\n-  if (gimple_bb (def_stmt) == bb)\n-    {\n-      /* If the defining statement is in the basic block already\n-\t we do not need to create a new expression for it, we\n-\t only need to ensure its operands are expanded.  */\n-      expand_scalar_variables_stmt (def_stmt, bb, region, rename_map, gsi);\n-      return fold_convert (type, new_op);\n-    }\n-  else\n-    {\n-      if (!gimple_bb (def_stmt)\n-\t  || !bb_in_sese_p (gimple_bb (def_stmt), region))\n-\treturn fold_convert (type, new_op);\n-\n-      switch (gimple_code (def_stmt))\n-\t{\n-\tcase GIMPLE_ASSIGN:\n-\t  {\n-\t    tree var0 = gimple_assign_rhs1 (def_stmt);\n-\t    enum tree_code subcode = gimple_assign_rhs_code (def_stmt);\n-\t    tree var1 = gimple_assign_rhs2 (def_stmt);\n-\t    tree type = gimple_expr_type (def_stmt);\n-\n-\t    return expand_scalar_variables_expr (type, var0, subcode, var1, bb,\n-\t\t\t\t\t\t region, rename_map, gsi);\n-\t  }\n-\n-\tcase GIMPLE_CALL:\n-\t  return expand_scalar_variables_call (def_stmt, bb, region, rename_map, gsi);\n-\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t  return new_op;\n-\t}\n-    }\n-}\n-\n-/* Copies at GSI all the scalar computations on which the expression\n-   OP0 CODE OP1 depends on in the SESE: these are all the scalar\n-   variables used in OP0 and OP1, defined outside BB and still defined\n-   in the SESE, i.e. not a parameter of the SESE.  The expression that\n-   is returned contains only induction variables from the generated\n-   code: RENAME_MAP contains the induction variables renaming mapping, and is\n-   used to translate the names of induction variables.  */\n-\n-static tree\n-expand_scalar_variables_expr (tree type, tree op0, enum tree_code code,\n-\t\t\t      tree op1, basic_block bb, sese region,\n-\t\t\t      htab_t rename_map, gimple_stmt_iterator *gsi)\n-{\n-  if (TREE_CODE_CLASS (code) == tcc_constant\n-      || TREE_CODE_CLASS (code) == tcc_declaration)\n-    return op0;\n-\n-  /* For data references we have to duplicate also its memory\n-     indexing.  */\n-  if (TREE_CODE_CLASS (code) == tcc_reference)\n-    {\n-      switch (code)\n-\t{\n-\tcase REALPART_EXPR:\n-\tcase IMAGPART_EXPR:\n-\t  {\n-\t    tree op = TREE_OPERAND (op0, 0);\n-\t    tree res = expand_scalar_variables_expr\n-\t      (type, op, TREE_CODE (op), NULL, bb, region, rename_map, gsi);\n-\t    return build1 (code, type, res);\n-\t  }\n-\n-\tcase INDIRECT_REF:\n-\t  {\n-\t    tree old_name = TREE_OPERAND (op0, 0);\n-\t    tree expr = expand_scalar_variables_ssa_name\n-\t      (type, old_name, bb, region, rename_map, gsi);\n-\n-\t    if (TREE_CODE (expr) != SSA_NAME\n-\t\t&& is_gimple_reg (old_name))\n-\t      {\n-\t\ttree type = TREE_TYPE (old_name);\n-\t\ttree var = create_tmp_var (type, \"var\");\n-\n-\t\texpr = build2 (MODIFY_EXPR, type, var, expr);\n-\t\texpr = force_gimple_operand_gsi (gsi, expr, true, NULL,\n-\t\t\t\t\t\t true, GSI_SAME_STMT);\n-\t      }\n-\n-\t    return fold_build1 (code, type, expr);\n-\t  }\n-\n-\tcase ARRAY_REF:\n-\t  {\n-\t    tree op00 = TREE_OPERAND (op0, 0);\n-\t    tree op01 = TREE_OPERAND (op0, 1);\n-\t    tree op02 = TREE_OPERAND (op0, 2);\n-\t    tree op03 = TREE_OPERAND (op0, 3);\n-\t    tree base = expand_scalar_variables_expr\n-\t      (TREE_TYPE (op00), op00, TREE_CODE (op00), NULL, bb, region,\n-\t       rename_map, gsi);\n-\t    tree subscript = expand_scalar_variables_expr\n-\t      (TREE_TYPE (op01), op01, TREE_CODE (op01), NULL, bb, region,\n-\t       rename_map, gsi);\n-\n-\t    return build4 (ARRAY_REF, type, base, subscript, op02, op03);\n-\t  }\n-\n-\tcase COMPONENT_REF:\n-\t  return op0;\n-\n-\tdefault:\n-\t  /* The above cases should catch everything.  */\n-\t  gcc_unreachable ();\n-\t}\n-    }\n-\n-  if (TREE_CODE_CLASS (code) == tcc_unary)\n-    {\n-      tree op0_type = TREE_TYPE (op0);\n-      enum tree_code op0_code = TREE_CODE (op0);\n-      tree op0_expr = expand_scalar_variables_expr (op0_type, op0, op0_code,\n-\t\t\t\t\t\t    NULL, bb, region, rename_map, gsi);\n-\n-      return fold_build1 (code, type, op0_expr);\n-    }\n-\n-  if (TREE_CODE_CLASS (code) == tcc_binary\n-      || TREE_CODE_CLASS (code) == tcc_comparison)\n-    {\n-      tree op0_type = TREE_TYPE (op0);\n-      enum tree_code op0_code = TREE_CODE (op0);\n-      tree op0_expr = expand_scalar_variables_expr (op0_type, op0, op0_code,\n-\t\t\t\t\t\t    NULL, bb, region, rename_map, gsi);\n-      tree op1_type = TREE_TYPE (op1);\n-      enum tree_code op1_code = TREE_CODE (op1);\n-      tree op1_expr = expand_scalar_variables_expr (op1_type, op1, op1_code,\n-\t\t\t\t\t\t    NULL, bb, region, rename_map, gsi);\n-\n-      return fold_build2 (code, type, op0_expr, op1_expr);\n-    }\n-\n-  if (code == SSA_NAME)\n-    return expand_scalar_variables_ssa_name (type, op0, bb, region, rename_map, gsi);\n-\n-  if (code == ADDR_EXPR)\n-    {\n-      tree op00 = TREE_OPERAND (op0, 0);\n-\n-      if (handled_component_p (op00)\n-\t  && TREE_CODE (op00) == ARRAY_REF)\n-\t{\n-\t  tree e = expand_scalar_variables_expr (TREE_TYPE (op00), op00,\n-\t\t\t\t\t\t TREE_CODE (op00),\n-\t\t\t\t\t\t NULL, bb, region, rename_map, gsi);\n-\t  return fold_build1 (code, TREE_TYPE (op0), e);\n-\t}\n-\n-      return op0;\n-    }\n-\n-  gcc_unreachable ();\n-  return NULL;\n-}\n-\n-/* Copies at the beginning of BB all the scalar computations on which\n-   STMT depends on in the SESE: these are all the scalar variables used\n-   in STMT, defined outside BB and still defined in the SESE, i.e. not a\n-   parameter of the SESE.  The expression that is returned contains\n-   only induction variables from the generated code: RENAME_MAP contains the\n-   induction variables renaming mapping, and is used to translate the\n-   names of induction variables.  */\n-\n-static void\n-expand_scalar_variables_stmt (gimple stmt, basic_block bb, sese region,\n-\t\t\t      htab_t rename_map, gimple_stmt_iterator *gsi)\n-{\n-  ssa_op_iter iter;\n-  use_operand_p use_p;\n-\n-  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES)\n-    {\n-      tree use = USE_FROM_PTR (use_p);\n-      tree type = TREE_TYPE (use);\n-      enum tree_code code = TREE_CODE (use);\n-      tree use_expr;\n-\n-      if (!is_gimple_reg (use))\n-\tcontinue;\n-\n-      /* Don't expand USE if we already have a rename for it.  */\n-      use_expr = get_rename (rename_map, use);\n-      if (use_expr != use)\n-\tcontinue;\n+\t      tree var;\n \n-      use_expr = expand_scalar_variables_expr (type, use, code, NULL, bb,\n-\t\t\t\t\t       region, rename_map, gsi);\n-      use_expr = fold_convert (type, use_expr);\n+\t      if (is_gimple_debug (copy))\n+\t\t{\n+\t\t  if (gimple_debug_bind_p (copy))\n+\t\t    gimple_debug_bind_reset_value (copy);\n+\t\t  else\n+\t\t    gcc_unreachable ();\n \n-      if (use_expr == use)\n-\tcontinue;\n+\t\t  break;\n+\t\t}\n \n-      if (is_gimple_debug (stmt))\n-\t{\n-\t  if (gimple_debug_bind_p (stmt))\n-\t    gimple_debug_bind_reset_value (stmt);\n-\t  else\n-\t    gcc_unreachable ();\n+\t      var = create_tmp_var (type_old_name, \"var\");\n \n-\t  break;\n-\t}\n+\t      if (type_old_name != type_new_expr)\n+\t\tnew_expr = fold_convert (type_old_name, new_expr);\n \n-      if (TREE_CODE (use_expr) != SSA_NAME)\n-\t{\n-\t  tree var = create_tmp_var (type, \"var\");\n+\t      new_expr = build2 (MODIFY_EXPR, type_old_name, var, new_expr);\n+\t      new_expr = force_gimple_operand (new_expr, &stmts, true, NULL);\n+\t      gsi_insert_seq_before (gsi_tgt, stmts, GSI_SAME_STMT);\n+\t    }\n \n-\t  use_expr = build2 (MODIFY_EXPR, type, var, use_expr);\n-\t  use_expr = force_gimple_operand_gsi (gsi, use_expr, true, NULL,\n-\t\t\t\t\t       true, GSI_SAME_STMT);\n+\t  replace_exp (use_p, new_expr);\n+\t  continue;\n \t}\n \n-      replace_exp (use_p, use_expr);\n-    }\n-\n-  update_stmt (stmt);\n-}\n-\n-/* Copies at the beginning of BB all the scalar computations on which\n-   BB depends on in the SESE: these are all the scalar variables used\n-   in BB, defined outside BB and still defined in the SESE, i.e. not a\n-   parameter of the SESE.  The expression that is returned contains\n-   only induction variables from the generated code: RENAME_MAP contains the\n-   induction variables renaming mapping, and is used to translate the\n-   names of induction variables.  */\n-\n-static void\n-expand_scalar_variables (basic_block bb, sese region, htab_t rename_map)\n-{\n-  gimple_stmt_iterator gsi;\n-\n-  for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi);)\n-    {\n-      gimple stmt = gsi_stmt (gsi);\n-      expand_scalar_variables_stmt (stmt, bb, region, rename_map, &gsi);\n-      gsi_next (&gsi);\n-    }\n-}\n-\n-/* Rename all the SSA_NAMEs from block BB according to the RENAME_MAP.  */\n-\n-static void\n-rename_variables (basic_block bb, htab_t rename_map)\n-{\n-  gimple_stmt_iterator gsi;\n-  gimple_stmt_iterator insert_gsi = gsi_start_bb (bb);\n-\n-  for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    rename_variables_in_stmt (gsi_stmt (gsi), rename_map, &insert_gsi);\n-}\n-\n-/* Remove condition from BB.  */\n-\n-static void\n-remove_condition (basic_block bb)\n-{\n-  gimple last = last_stmt (bb);\n-\n-  if (last && gimple_code (last) == GIMPLE_COND)\n-    {\n-      gimple_stmt_iterator gsi = gsi_last_bb (bb);\n-      gsi_remove (&gsi, true);\n-    }\n-}\n-\n-/* Returns the first successor edge of BB with EDGE_TRUE_VALUE flag set.  */\n-\n-edge\n-get_true_edge_from_guard_bb (basic_block bb)\n-{\n-  edge e;\n-  edge_iterator ei;\n-\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    if (e->flags & EDGE_TRUE_VALUE)\n-      return e;\n-\n-  gcc_unreachable ();\n-  return NULL;\n-}\n-\n-/* Returns the first successor edge of BB with EDGE_TRUE_VALUE flag cleared.  */\n-\n-edge\n-get_false_edge_from_guard_bb (basic_block bb)\n-{\n-  edge e;\n-  edge_iterator ei;\n-\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    if (!(e->flags & EDGE_TRUE_VALUE))\n-      return e;\n-\n-  gcc_unreachable ();\n-  return NULL;\n-}\n-\n-/* Helper structure for htab_traverse in insert_guard_phis.  */\n+      scev = scalar_evolution_in_region (region, loop, old_name);\n \n-struct igp {\n-  basic_block bb;\n-  edge true_edge, false_edge;\n-  htab_t before_guard;\n-};\n+      /* At this point we should know the exact scev for each\n+\t scalar SSA_NAME used in the scop: all the other scalar\n+\t SSA_NAMEs should have been translated out of SSA using\n+\t arrays with one element.  */\n+      gcc_assert (!chrec_contains_undetermined (scev));\n \n-/* Return the default name that is before the guard.  */\n+      new_expr = chrec_apply_map (scev, iv_map);\n \n-static tree\n-default_before_guard (htab_t before_guard, tree old_name)\n-{\n-  tree res = get_rename (before_guard, old_name);\n+      /* The apply should produce an expression tree containing\n+\t the uses of the new induction variables.  We should be\n+\t able to use new_expr instead of the old_name in the newly\n+\t generated loop nest.  */\n+      gcc_assert (!chrec_contains_undetermined (new_expr)\n+\t\t  && !tree_contains_chrecs (new_expr, NULL));\n \n-  if (res == old_name)\n-    {\n-      if (is_gimple_reg (res))\n-\treturn fold_convert (TREE_TYPE (res), integer_zero_node);\n-      return gimple_default_def (cfun, SSA_NAME_VAR (res));\n+      /* Replace the old_name with the new_expr.  */\n+      new_expr = force_gimple_operand (new_expr, &stmts, true, NULL);\n+      gsi_insert_seq_before (gsi_tgt, stmts, GSI_SAME_STMT);\n+      replace_exp (use_p, new_expr);\n+      set_rename (rename_map, old_name, new_expr);\n     }\n-\n-  return res;\n }\n \n-/* Prepares EXPR to be a good phi argument when the phi result is\n-   RES.  Insert needed statements on edge E.  */\n-\n-static tree\n-convert_for_phi_arg (tree expr, tree res, edge e)\n-{\n-  tree type = TREE_TYPE (res);\n-\n-  if (TREE_TYPE (expr) != type)\n-    expr = fold_convert (type, expr);\n-\n-  if (TREE_CODE (expr) != SSA_NAME\n-      && !is_gimple_min_invariant (expr))\n-    {\n-      tree var = create_tmp_var (type, \"var\");\n-      gimple_seq stmts;\n-\n-      expr = build2 (MODIFY_EXPR, type, var, expr);\n-      expr = force_gimple_operand (expr, &stmts, true, NULL);\n-      gsi_insert_seq_on_edge_immediate (e, stmts);\n-    }\n-\n-  return expr;\n-}\n-\n-/* Helper function for htab_traverse in insert_guard_phis.  */\n-\n-static int\n-add_guard_exit_phis (void **slot, void *s)\n-{\n-  struct rename_map_elt_s *entry = (struct rename_map_elt_s *) *slot;\n-  struct igp *i = (struct igp *) s;\n-  basic_block bb = i->bb;\n-  edge true_edge = i->true_edge;\n-  edge false_edge = i->false_edge;\n-  tree res = entry->old_name;\n-  tree name1 = entry->expr;\n-  tree name2 = default_before_guard (i->before_guard, res);\n-  gimple phi;\n-\n-  /* Nothing to be merged if the name before the guard is the same as\n-     the one after.  */\n-  if (name1 == name2)\n-    return 1;\n-\n-  name1 = convert_for_phi_arg (name1, res, true_edge);\n-  name2 = convert_for_phi_arg (name2, res, false_edge);\n-\n-  phi = create_phi_node (res, bb);\n-  res = create_new_def_for (gimple_phi_result (phi), phi,\n-\t\t\t    gimple_phi_result_ptr (phi));\n-\n-  add_phi_arg (phi, name1, true_edge, UNKNOWN_LOCATION);\n-  add_phi_arg (phi, name2, false_edge, UNKNOWN_LOCATION);\n-\n-  entry->expr = res;\n-  *slot = entry;\n-  return 1;\n-}\n-\n-/* Iterate over RENAME_MAP and get tuples of the form (OLD, NAME1).\n-   If there is a correspondent tuple (OLD, NAME2) in BEFORE_GUARD,\n-   with NAME1 different than NAME2, then insert in BB the phi node:\n-\n-   | RES = phi (NAME1 (on TRUE_EDGE), NAME2 (on FALSE_EDGE))\"\n-\n-   if there is no tuple for OLD in BEFORE_GUARD, insert\n-\n-   | RES = phi (NAME1 (on TRUE_EDGE),\n-   |            DEFAULT_DEFINITION of NAME1 (on FALSE_EDGE))\".\n-\n-   Finally register in RENAME_MAP the tuple (OLD, RES).  */\n-\n-void\n-insert_guard_phis (basic_block bb, edge true_edge, edge false_edge,\n-\t\t   htab_t before_guard, htab_t rename_map)\n-{\n-  struct igp i;\n-  i.bb = bb;\n-  i.true_edge = true_edge;\n-  i.false_edge = false_edge;\n-  i.before_guard = before_guard;\n-\n-  update_ssa (TODO_update_ssa);\n-  htab_traverse (rename_map, add_guard_exit_phis, &i);\n-  update_ssa (TODO_update_ssa);\n-}\n-\n-/* Create a duplicate of the basic block BB.  NOTE: This does not\n-   preserve SSA form.  */\n+/* Duplicates the statements of basic block BB into basic block NEW_BB\n+   and compute the new induction variables according to the IV_MAP.  */\n \n static void\n-graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb, htab_t rename_map)\n+graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb,\n+\t\t\t\thtab_t rename_map,\n+\t\t\t\tVEC (tree, heap) *iv_map, sese region)\n {\n   gimple_stmt_iterator gsi, gsi_tgt;\n+  loop_p loop = bb->loop_father;\n \n   gsi_tgt = gsi_start_bb (new_bb);\n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n@@ -1016,8 +570,19 @@ graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb, htab_t renam\n       ssa_op_iter op_iter;\n       gimple stmt = gsi_stmt (gsi);\n       gimple copy;\n+      tree lhs;\n+\n+      /* Do not copy labels or conditions.  */\n+      if (gimple_code (stmt) == GIMPLE_LABEL\n+\t  || gimple_code (stmt) == GIMPLE_COND)\n+\tcontinue;\n \n-      if (gimple_code (stmt) == GIMPLE_LABEL)\n+      /* Do not copy induction variables.  */\n+      if (is_gimple_assign (stmt)\n+\t  && (lhs = gimple_assign_lhs (stmt))\n+\t  && TREE_CODE (lhs) == SSA_NAME\n+\t  && is_gimple_reg (lhs)\n+\t  && scev_analyzable_p (lhs, region))\n \tcontinue;\n \n       /* Create a new copy of STMT and duplicate STMT's virtual\n@@ -1032,11 +597,15 @@ graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb, htab_t renam\n       /* Create new names for all the definitions created by COPY and\n \t add replacement mappings for each new name.  */\n       FOR_EACH_SSA_DEF_OPERAND (def_p, copy, op_iter, SSA_OP_ALL_DEFS)\n-\t{\n-\t  tree old_name = DEF_FROM_PTR (def_p);\n-\t  tree new_name = create_new_def_for (old_name, copy, def_p);\n+ \t{\n+ \t  tree old_name = DEF_FROM_PTR (def_p);\n+ \t  tree new_name = create_new_def_for (old_name, copy, def_p);\n \t  set_rename (rename_map, old_name, new_name);\n-\t}\n+ \t}\n+\n+      rename_uses (copy, rename_map, &gsi_tgt, region, loop, iv_map);\n+\n+      update_stmt (copy);\n     }\n }\n \n@@ -1046,16 +615,16 @@ graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb, htab_t renam\n \n edge\n copy_bb_and_scalar_dependences (basic_block bb, sese region,\n-\t\t\t\tedge next_e, htab_t rename_map)\n+\t\t\t\tedge next_e, VEC (tree, heap) *iv_map)\n {\n   basic_block new_bb = split_edge (next_e);\n+  htab_t rename_map = htab_create (10, rename_map_elt_info,\n+\t\t\t\t   eq_rename_map_elts, free);\n \n   next_e = single_succ_edge (new_bb);\n-  graphite_copy_stmts_from_block (bb, new_bb, rename_map);\n-  remove_condition (new_bb);\n+  graphite_copy_stmts_from_block (bb, new_bb, rename_map, iv_map, region);\n   remove_phi_nodes (new_bb);\n-  expand_scalar_variables (new_bb, region, rename_map);\n-  rename_variables (new_bb, rename_map);\n+  htab_delete (rename_map);\n \n   return next_e;\n }"}, {"sha": "1502cbe97f97a1d82514a0cb28d378771f0dbe07", "filename": "gcc/sese.h", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e286fd2f92630c896c5a9c8c8ca38a01039276b/gcc%2Fsese.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e286fd2f92630c896c5a9c8c8ca38a01039276b/gcc%2Fsese.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.h?ref=2e286fd2f92630c896c5a9c8c8ca38a01039276b", "patch": "@@ -56,7 +56,8 @@ extern sese new_sese (edge, edge);\n extern void free_sese (sese);\n extern void sese_insert_phis_for_liveouts (sese, basic_block, edge, edge);\n extern void build_sese_loop_nests (sese);\n-extern edge copy_bb_and_scalar_dependences (basic_block, sese, edge, htab_t);\n+extern edge copy_bb_and_scalar_dependences (basic_block, sese, edge,\n+\t\t\t\t\t    VEC (tree, heap) *);\n extern struct loop *outermost_loop_in_sese (sese, basic_block);\n extern void insert_loop_close_phis (htab_t, loop_p);\n extern void insert_guard_phis (basic_block, edge, edge, htab_t, htab_t);\n@@ -261,7 +262,6 @@ DEF_VEC_ALLOC_P (rename_map_elt, heap);\n extern void debug_rename_map (htab_t);\n extern hashval_t rename_map_elt_info (const void *);\n extern int eq_rename_map_elts (const void *, const void *);\n-extern void set_rename (htab_t, tree, tree);\n \n /* Constructs a new SCEV_INFO_STR structure for VAR and INSTANTIATED_BELOW.  */\n \n@@ -386,4 +386,19 @@ nb_common_loops (sese region, gimple_bb_p gbb1, gimple_bb_p gbb2)\n   return sese_loop_depth (region, common);\n }\n \n+/* Return true when DEF can be analyzed in REGION by the scalar\n+   evolution analyzer.  */\n+\n+static inline bool\n+scev_analyzable_p (tree def, sese region)\n+{\n+  gimple stmt = SSA_NAME_DEF_STMT (def);\n+  loop_p loop = loop_containing_stmt (stmt);\n+  tree scev = scalar_evolution_in_region (region, loop, def);\n+\n+  return !chrec_contains_undetermined (scev)\n+    && TREE_CODE (scev) != SSA_NAME\n+    && evolution_function_is_affine_p (scev);\n+}\n+\n #endif"}, {"sha": "c92b6b9837c7a14a8b50298b3284def2ce3753c7", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e286fd2f92630c896c5a9c8c8ca38a01039276b/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e286fd2f92630c896c5a9c8c8ca38a01039276b/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=2e286fd2f92630c896c5a9c8c8ca38a01039276b", "patch": "@@ -632,6 +632,23 @@ chrec_apply (unsigned var,\n   return res;\n }\n \n+/* For a given CHREC and an induction variable map IV_MAP that maps\n+   (loop->num, expr) for every loop number of the current_loops an\n+   expression, calls chrec_apply when the expression is not NULL.  */\n+\n+tree\n+chrec_apply_map (tree chrec, VEC (tree, heap) *iv_map)\n+{\n+  int i;\n+  tree expr;\n+\n+  for (i = 0; VEC_iterate (tree, iv_map, i, expr); i++)\n+    if (expr)\n+      chrec = chrec_apply (i, chrec, expr);\n+\n+  return chrec;\n+}\n+\n /* Replaces the initial condition in CHREC with INIT_COND.  */\n \n tree"}, {"sha": "eb60ac9460170c5849abefbd72a7bd75c0525b1e", "filename": "gcc/tree-chrec.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e286fd2f92630c896c5a9c8c8ca38a01039276b/gcc%2Ftree-chrec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e286fd2f92630c896c5a9c8c8ca38a01039276b/gcc%2Ftree-chrec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.h?ref=2e286fd2f92630c896c5a9c8c8ca38a01039276b", "patch": "@@ -64,6 +64,7 @@ extern tree chrec_convert_aggressive (tree, tree);\n \n /* Operations.  */\n extern tree chrec_apply (unsigned, tree, tree);\n+extern tree chrec_apply_map (tree, VEC (tree, heap) *);\n extern tree chrec_replace_initial_condition (tree, tree);\n extern tree initial_condition (tree);\n extern tree initial_condition_in_loop_num (tree, unsigned);"}]}