{"sha": "695e0fbfe0257a0659880d0a05a2c754660e713f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njk1ZTBmYmZlMDI1N2EwNjU5ODgwZDBhMDVhMmM3NTQ2NjBlNzEzZg==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2004-07-01T17:53:21Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-07-01T17:53:21Z"}, "message": "stl_algobase.h (__copy_trivial): Remove.\n\n2004-07-01  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/stl_algobase.h (__copy_trivial): Remove.\n\t(__copy_aux2): Rewrite as __copy_aux to use __is_pointer,\n\t__is_trivially_copyable, __are_same and __copy::copy.\n\t(__copy): Rewrite as a class template and two specializations.\n\t(__copy_ni2): Simplify, just call __copy_aux.\n\n\t* include/bits/stl_algobase.h (__copy_backward_aux): Add __are_same\n\tcheck.\n\t* testsuite/25_algorithms/copy/1.cc, 2.cc, 3.cc, 4.cc: Test also\n\tfor destination value type != source value type.\n\nFrom-SVN: r83991", "tree": {"sha": "995c20087f223c44c2f5c77cd48ea64ea0c87154", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/995c20087f223c44c2f5c77cd48ea64ea0c87154"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/695e0fbfe0257a0659880d0a05a2c754660e713f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/695e0fbfe0257a0659880d0a05a2c754660e713f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/695e0fbfe0257a0659880d0a05a2c754660e713f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/695e0fbfe0257a0659880d0a05a2c754660e713f/comments", "author": null, "committer": null, "parents": [{"sha": "9b61c47826156fe17fd5f4306470ade01e2fc4dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b61c47826156fe17fd5f4306470ade01e2fc4dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b61c47826156fe17fd5f4306470ade01e2fc4dc"}], "stats": {"total": 221, "additions": 128, "deletions": 93}, "files": [{"sha": "f981c0f1ca6e14878320ec894274243020f09639", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/695e0fbfe0257a0659880d0a05a2c754660e713f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/695e0fbfe0257a0659880d0a05a2c754660e713f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=695e0fbfe0257a0659880d0a05a2c754660e713f", "patch": "@@ -1,3 +1,16 @@\n+2004-07-01  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/stl_algobase.h (__copy_trivial): Remove.\n+\t(__copy_aux2): Rewrite as __copy_aux to use __is_pointer,\n+\t__is_trivially_copyable, __are_same and __copy::copy.\n+\t(__copy): Rewrite as a class template and two specializations.\n+\t(__copy_ni2): Simplify, just call __copy_aux.\n+\t\n+\t* include/bits/stl_algobase.h (__copy_backward_aux): Add __are_same\n+\tcheck.\n+\t* testsuite/25_algorithms/copy/1.cc, 2.cc, 3.cc, 4.cc: Test also\n+\tfor destination value type != source value type.\n+\n 2004-07-01  Benjamin Kosnik  <bkoz@redhat.com>\n             Per Bothner  <per@bothner.com>\n \t    Mohan Embar  <gnustuff@thisiscool.com>"}, {"sha": "1b441e0a6d4cedc4c775929622f7170640c1d679", "filename": "libstdc++-v3/include/bits/stl_algobase.h", "status": "modified", "additions": 59, "deletions": 69, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/695e0fbfe0257a0659880d0a05a2c754660e713f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/695e0fbfe0257a0659880d0a05a2c754660e713f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h?ref=695e0fbfe0257a0659880d0a05a2c754660e713f", "patch": "@@ -226,88 +226,76 @@ namespace std\n   // (2) If we're using random access iterators, then write the loop as\n   // a for loop with an explicit count.\n \n-  template<typename _InputIterator, typename _OutputIterator>\n-    inline _OutputIterator\n-    __copy(_InputIterator __first, _InputIterator __last,\n-\t   _OutputIterator __result, input_iterator_tag)\n+  template<bool, typename>\n+    struct __copy\n     {\n-      for (; __first != __last; ++__result, ++__first)\n-\t*__result = *__first;\n-      return __result;\n-    }\n+      template<typename _II, typename _OI>\n+        static _OI\n+        copy(_II __first, _II __last, _OI __result)\n+        {\n+\t  for (; __first != __last; ++__result, ++__first)\n+\t    *__result = *__first;\n+\t  return __result;\n+\t}\n+    };\n \n-  template<typename _RandomAccessIterator, typename _OutputIterator>\n-    inline _OutputIterator\n-    __copy(_RandomAccessIterator __first, _RandomAccessIterator __last,\n-\t   _OutputIterator __result, random_access_iterator_tag)\n+  template<bool _BoolType>\n+    struct __copy<_BoolType, random_access_iterator_tag>\n     {\n-      typedef typename iterator_traits<_RandomAccessIterator>::difference_type\n-          _Distance;\n-      for (_Distance __n = __last - __first; __n > 0; --__n)\n-\t{\n-\t  *__result = *__first;\n-\t  ++__first;\n-\t  ++__result;\n+      template<typename _II, typename _OI>\n+        static _OI\n+        copy(_II __first, _II __last, _OI __result)\n+        { \n+\t  typedef typename iterator_traits<_II>::difference_type _Distance;\n+\t  for(_Distance __n = __last - __first; __n > 0; --__n)\n+\t    {\n+\t      *__result = *__first;\n+\t      ++__first;\n+\t      ++__result;\n+\t    }\n+\t  return __result;\n \t}\n-      return __result;\n-    }\n+    };\n \n-  template<typename _Tp>\n-    inline _Tp*\n-    __copy_trivial(const _Tp* __first, const _Tp* __last, _Tp* __result)\n+  template<>\n+    struct __copy<true, random_access_iterator_tag>\n     {\n-      std::memmove(__result, __first, sizeof(_Tp) * (__last - __first));\n-      return __result + (__last - __first);\n-    }\n-\n-  template<typename _InputIterator, typename _OutputIterator>\n-    inline _OutputIterator\n-    __copy_aux2(_InputIterator __first, _InputIterator __last,\n-\t\t_OutputIterator __result, __false_type)\n-    { return std::__copy(__first, __last, __result,\n-\t\t\t std::__iterator_category(__first)); }\n-\n-  template<typename _InputIterator, typename _OutputIterator>\n-    inline _OutputIterator\n-    __copy_aux2(_InputIterator __first, _InputIterator __last,\n-\t\t_OutputIterator __result, __true_type)\n-    { return std::__copy(__first, __last, __result,\n-\t\t\t std::__iterator_category(__first)); }\n+      template<typename _Tp>\n+        static _Tp*\n+        copy(const _Tp* __first, const _Tp* __last, _Tp* __result)\n+        { \n+\t  std::memmove(__result, __first, sizeof(_Tp) * (__last - __first));\n+\t  return __result + (__last - __first);\n+\t}\n+    };\n \n-  template<typename _Tp>\n-    inline _Tp*\n-    __copy_aux2(_Tp* __first, _Tp* __last, _Tp* __result, __true_type)\n-    { return std::__copy_trivial(__first, __last, __result); }\n+  template<typename _II, typename _OI>\n+    inline _OI\n+    __copy_aux(_II __first, _II __last, _OI __result)\n+    {\n+      typedef typename iterator_traits<_II>::value_type _ValueTypeI;\n+      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;\n+      typedef typename iterator_traits<_II>::iterator_category _Category;\n+      const bool __simple = (__is_trivially_copyable<_ValueTypeO>::_M_type\n+\t                     && __is_pointer<_II>::_M_type\n+\t                     && __is_pointer<_OI>::_M_type\n+\t\t\t     && __are_same<_ValueTypeI, _ValueTypeO>::_M_type);\n \n-  template<typename _Tp>\n-    inline _Tp*\n-    __copy_aux2(const _Tp* __first, const _Tp* __last, _Tp* __result,\n-\t\t__true_type)\n-    { return std::__copy_trivial(__first, __last, __result); }\n+      return std::__copy<__simple, _Category>::copy(__first, __last, __result);\n+    }\n \n   template<typename _InputIterator, typename _OutputIterator>\n     inline _OutputIterator\n     __copy_ni2(_InputIterator __first, _InputIterator __last,\n \t       _OutputIterator __result, __true_type)\n-    {\n-      typedef typename iterator_traits<_InputIterator>::value_type\n-\t_ValueType;\n-      typedef typename __type_traits<\n-\t_ValueType>::has_trivial_assignment_operator _Trivial;\n-      return _OutputIterator(std::__copy_aux2(__first, __last, __result.base(),\n-\t\t\t\t\t      _Trivial()));\n-    }\n+    { return _OutputIterator(std::__copy_aux(__first, __last,\n+\t\t\t\t\t     __result.base())); }\n \n   template<typename _InputIterator, typename _OutputIterator>\n     inline _OutputIterator\n     __copy_ni2(_InputIterator __first, _InputIterator __last,\n \t       _OutputIterator __result, __false_type)\n-    {\n-      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;\n-      typedef typename __type_traits<\n-\t_ValueType>::has_trivial_assignment_operator _Trivial;\n-      return std::__copy_aux2(__first, __last, __result, _Trivial());\n-    }\n+    { return std::__copy_aux(__first, __last, __result); }\n \n   template<typename _InputIterator, typename _OutputIterator>\n     inline _OutputIterator\n@@ -403,14 +391,16 @@ namespace std\n     inline _BI2\n     __copy_backward_aux(_BI1 __first, _BI1 __last, _BI2 __result)\n     {\n-      typedef typename iterator_traits<_BI2>::value_type _ValueType;\n+      typedef typename iterator_traits<_BI1>::value_type _ValueType1;\n+      typedef typename iterator_traits<_BI2>::value_type _ValueType2;\n       typedef typename iterator_traits<_BI1>::iterator_category _Category;\n-      const bool __simple = (__is_trivially_copyable<_ValueType>::_M_type\n+      const bool __simple = (__is_trivially_copyable<_ValueType2>::_M_type\n \t                     && __is_pointer<_BI1>::_M_type\n-\t                     && __is_pointer<_BI2>::_M_type);\n+\t                     && __is_pointer<_BI2>::_M_type\n+\t\t\t     && __are_same<_ValueType1, _ValueType2>::_M_type);\n \n-      return __copy_backward<__simple, _Category>::copy_b(__first, __last,\n-\t\t\t\t\t\t\t  __result);\n+      return std::__copy_backward<__simple, _Category>::copy_b(__first, __last,\n+\t\t\t\t\t\t\t       __result);\n     }\n \n   template <typename _BI1, typename _BI2>"}, {"sha": "7c45db2e0e43c148b43c0b35aa7d318a339f7c1e", "filename": "libstdc++-v3/testsuite/25_algorithms/copy/1.cc", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/695e0fbfe0257a0659880d0a05a2c754660e713f/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/695e0fbfe0257a0659880d0a05a2c754660e713f/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2F1.cc?ref=695e0fbfe0257a0659880d0a05a2c754660e713f", "patch": "@@ -31,21 +31,29 @@ test01()\n   const int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};\n   const int N = sizeof(A) / sizeof(int);\n   \n-  int s1[N];\n-  copy(A, A + N, s1);\n-  VERIFY( equal(s1, s1 + N, A) );\n+  int i1[N];\n+  copy(A, A + N, i1);\n+  VERIFY( equal(i1, i1 + N, A) );\n \n   vector<int> v1(N);\n   copy(A, A + N, v1.begin());\n   VERIFY( equal(v1.begin(), v1.end(), A) );\n \n-  int s2[N];\n-  copy_backward(A, A + N, s2 + N);\n-  VERIFY( equal(s2, s2 + N, A) );\n+  short s1[N];\n+  copy(A, A + N, s1);\n+  VERIFY( equal(s1, s1 + N, A) );\n+\n+  int i2[N];\n+  copy_backward(A, A + N, i2 + N);\n+  VERIFY( equal(i2, i2 + N, A) );\n \n   vector<int> v2(N);\n   copy_backward(A, A + N, v2.end());\n   VERIFY( equal(v2.begin(), v2.end(), A) );\n+\n+  short s2[N];\n+  copy_backward(A, A + N, s2 + N);\n+  VERIFY( equal(s2, s2 + N, A) );\n }\n \n int"}, {"sha": "8fe3b3a61c8c111130dc5dce05b7e646162d9f1c", "filename": "libstdc++-v3/testsuite/25_algorithms/copy/2.cc", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/695e0fbfe0257a0659880d0a05a2c754660e713f/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/695e0fbfe0257a0659880d0a05a2c754660e713f/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2F2.cc?ref=695e0fbfe0257a0659880d0a05a2c754660e713f", "patch": "@@ -32,21 +32,29 @@ test01()\n   const int N = sizeof(A) / sizeof(int);\n   const vector<int> a(A, A + N);\n \n-  int s1[N];\n-  copy(a.begin(), a.end(), s1);\n-  VERIFY( equal(s1, s1 + N, a.begin()) );\n+  int i1[N];\n+  copy(a.begin(), a.end(), i1);\n+  VERIFY( equal(i1, i1 + N, a.begin()) );\n \n   vector<int> v1(N);\n   copy(a.begin(), a.end(), v1.begin());\n   VERIFY( equal(v1.begin(), v1.end(), a.begin()) );\n \n-  int s2[N];\n-  copy_backward(a.begin(), a.end(), s2 + N);\n-  VERIFY( equal(s2, s2 + N, a.begin()) );\n+  short s1[N];\n+  copy(a.begin(), a.end(), s1);\n+  VERIFY( equal(s1, s1 + N, a.begin()) );\n+\n+  int i2[N];\n+  copy_backward(a.begin(), a.end(), i2 + N);\n+  VERIFY( equal(i2, i2 + N, a.begin()) );\n \n   vector<int> v2(N);\n   copy_backward(a.begin(), a.end(), v2.end());\n   VERIFY( equal(v2.begin(), v2.end(), a.begin()) );\n+\n+  short s2[N];\n+  copy_backward(a.begin(), a.end(), s2 + N);\n+  VERIFY( equal(s2, s2 + N, a.begin()) );\n }\n \n int"}, {"sha": "0bf0432dccc900ddb6adf1ef326fbe997eb89775", "filename": "libstdc++-v3/testsuite/25_algorithms/copy/3.cc", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/695e0fbfe0257a0659880d0a05a2c754660e713f/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/695e0fbfe0257a0659880d0a05a2c754660e713f/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2F3.cc?ref=695e0fbfe0257a0659880d0a05a2c754660e713f", "patch": "@@ -33,21 +33,29 @@ test01()\n   const int N = sizeof(A) / sizeof(int);\n   const deque<int> a(A, A + N);\n \n-  int s1[N];\n-  copy(a.begin(), a.end(), s1);\n-  VERIFY( equal(s1, s1 + N, a.begin()) );\n+  int i1[N];\n+  copy(a.begin(), a.end(), i1);\n+  VERIFY( equal(i1, i1 + N, a.begin()) );\n \n   vector<int> v1(N);\n   copy(a.begin(), a.end(), v1.begin());\n   VERIFY( equal(v1.begin(), v1.end(), a.begin()) );\n \n-  int s2[N];\n-  copy_backward(a.begin(), a.end(), s2 + N);\n-  VERIFY( equal(s2, s2 + N, a.begin()) );\n+  short s1[N];\n+  copy(a.begin(), a.end(), s1);\n+  VERIFY( equal(s1, s1 + N, a.begin()) );\n+\n+  int i2[N];\n+  copy_backward(a.begin(), a.end(), i2 + N);\n+  VERIFY( equal(i2, i2 + N, a.begin()) );\n \n   vector<int> v2(N);\n   copy_backward(a.begin(), a.end(), v2.end());\n   VERIFY( equal(v2.begin(), v2.end(), a.begin()) );\n+\n+  short s2[N];\n+  copy_backward(a.begin(), a.end(), s2 + N);\n+  VERIFY( equal(s2, s2 + N, a.begin()) );\n }\n \n int"}, {"sha": "91818f366735a929f00fc5a81d3ef1d75950c16e", "filename": "libstdc++-v3/testsuite/25_algorithms/copy/4.cc", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/695e0fbfe0257a0659880d0a05a2c754660e713f/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/695e0fbfe0257a0659880d0a05a2c754660e713f/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2F4.cc?ref=695e0fbfe0257a0659880d0a05a2c754660e713f", "patch": "@@ -33,21 +33,29 @@ test01()\n   const int N = sizeof(A) / sizeof(int);\n   const list<int> a(A, A + N);\n   \n-  int s1[N];\n-  copy(a.begin(), a.end(), s1);\n-  VERIFY( equal(s1, s1 + N, a.begin()) );\n+  int i1[N];\n+  copy(a.begin(), a.end(), i1);\n+  VERIFY( equal(i1, i1 + N, a.begin()) );\n \n   vector<int> v1(N);\n   copy(a.begin(), a.end(), v1.begin());\n   VERIFY( equal(v1.begin(), v1.end(), a.begin()) );\n \n-  int s2[N];\n-  copy_backward(a.begin(), a.end(), s2 + N);\n-  VERIFY( equal(s2, s2 + N, a.begin()) );\n+  short s1[N];\n+  copy(a.begin(), a.end(), s1);\n+  VERIFY( equal(s1, s1 + N, a.begin()) );\n+\n+  int i2[N];\n+  copy_backward(a.begin(), a.end(), i2 + N);\n+  VERIFY( equal(i2, i2 + N, a.begin()) );\n \n   vector<int> v2(N);\n   copy_backward(a.begin(), a.end(), v2.end());\n   VERIFY( equal(v2.begin(), v2.end(), a.begin()) );\n+\n+  short s2[N];\n+  copy_backward(a.begin(), a.end(), s2 + N);\n+  VERIFY( equal(s2, s2 + N, a.begin()) );\n }\n \n int"}]}