{"sha": "02dea3ffc6e0f26963db8255ea003d0ede0918cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJkZWEzZmZjNmUwZjI2OTYzZGI4MjU1ZWEwMDNkMGVkZTA5MThjYw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2010-07-09T19:36:19Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-07-09T19:36:19Z"}, "message": "re PR c++/43120 (Virtual inheritance with covariant return type confuses GCC)\n\n\tPR c++/43120\n\t* cp-tree.h (BV_LOST_PRIMARY): New macro.\n\t* class.c (update_vtable_entry_for_fn): Fix covariant thunk logic.\n\tSet BV_LOST_PRIMARY.\n\t(build_vtbl_initializer): Check BV_LOST_PRIMARY.\n\nFrom-SVN: r162008", "tree": {"sha": "27b3670f92dc982f83cc34bdb5baecdb238472d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27b3670f92dc982f83cc34bdb5baecdb238472d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02dea3ffc6e0f26963db8255ea003d0ede0918cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02dea3ffc6e0f26963db8255ea003d0ede0918cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02dea3ffc6e0f26963db8255ea003d0ede0918cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02dea3ffc6e0f26963db8255ea003d0ede0918cc/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "59ee2304b00de03560aca9fdba6eb9ac08e0a7b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59ee2304b00de03560aca9fdba6eb9ac08e0a7b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59ee2304b00de03560aca9fdba6eb9ac08e0a7b8"}], "stats": {"total": 176, "additions": 121, "deletions": 55}, "files": [{"sha": "bdae8fc813cae65152d897dc9b07d1ce6cd3350f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02dea3ffc6e0f26963db8255ea003d0ede0918cc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02dea3ffc6e0f26963db8255ea003d0ede0918cc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=02dea3ffc6e0f26963db8255ea003d0ede0918cc", "patch": "@@ -1,3 +1,11 @@\n+2010-07-09  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/43120\n+\t* cp-tree.h (BV_LOST_PRIMARY): New macro.\n+\t* class.c (update_vtable_entry_for_fn): Fix covariant thunk logic.\n+\tSet BV_LOST_PRIMARY.\n+\t(build_vtbl_initializer): Check BV_LOST_PRIMARY.\n+\n 2010-07-08  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/43120"}, {"sha": "dfb2cd942d79e9b925c2eb7e2870816570efaf3a", "filename": "gcc/cp/class.c", "status": "modified", "additions": 40, "deletions": 48, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02dea3ffc6e0f26963db8255ea003d0ede0918cc/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02dea3ffc6e0f26963db8255ea003d0ede0918cc/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=02dea3ffc6e0f26963db8255ea003d0ede0918cc", "patch": "@@ -2205,6 +2205,40 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n     gcc_assert (DECL_INVALID_OVERRIDER_P (overrider_target) ||\n \t\t!DECL_THUNK_P (fn));\n \n+  /* If we need a covariant thunk, then we may need to adjust first_defn.\n+     The ABI specifies that the thunks emitted with a function are\n+     determined by which bases the function overrides, so we need to be\n+     sure that we're using a thunk for some overridden base; even if we\n+     know that the necessary this adjustment is zero, there may not be an\n+     appropriate zero-this-adjusment thunk for us to use since thunks for\n+     overriding virtual bases always use the vcall offset.\n+\n+     Furthermore, just choosing any base that overrides this function isn't\n+     quite right, as this slot won't be used for calls through a type that\n+     puts a covariant thunk here.  Calling the function through such a type\n+     will use a different slot, and that slot is the one that determines\n+     the thunk emitted for that base.\n+\n+     So, keep looking until we find the base that we're really overriding\n+     in this slot: the nearest primary base that doesn't use a covariant\n+     thunk in this slot.  */\n+  if (overrider_target != overrider_fn)\n+    {\n+      if (BINFO_TYPE (b) == DECL_CONTEXT (overrider_target))\n+\t/* We already know that the overrider needs a covariant thunk.  */\n+\tb = get_primary_binfo (b);\n+      for (; ; b = get_primary_binfo (b))\n+\t{\n+\t  tree main_binfo = TYPE_BINFO (BINFO_TYPE (b));\n+\t  tree bv = chain_index (ix, BINFO_VIRTUALS (main_binfo));\n+\t  if (BINFO_LOST_PRIMARY_P (b))\n+\t    lost = true;\n+\t  if (!DECL_THUNK_P (TREE_VALUE (bv)))\n+\t    break;\n+\t}\n+      first_defn = b;\n+    }\n+\n   /* Assume that we will produce a thunk that convert all the way to\n      the final overrider, and not to an intermediate virtual base.  */\n   virtual_base = NULL_TREE;\n@@ -2229,38 +2263,6 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n \t}\n     }\n \n-  if (overrider_fn != overrider_target && !virtual_base)\n-    {\n-      /* The ABI specifies that a covariant thunk includes a mangling\n-\t for a this pointer adjustment.  This-adjusting thunks that\n-\t override a function from a virtual base have a vcall\n-\t adjustment.  When the virtual base in question is a primary\n-\t virtual base, we know the adjustments are zero, (and in the\n-\t non-covariant case, we would not use the thunk).\n-\t Unfortunately we didn't notice this could happen, when\n-\t designing the ABI and so never mandated that such a covariant\n-\t thunk should be emitted.  Because we must use the ABI mandated\n-\t name, we must continue searching from the binfo where we\n-\t found the most recent definition of the function, towards the\n-\t primary binfo which first introduced the function into the\n-\t vtable.  If that enters a virtual base, we must use a vcall\n-\t this-adjusting thunk.  Bleah! */\n-      tree probe = first_defn;\n-\n-      while ((probe = get_primary_binfo (probe))\n-\t     && (unsigned) list_length (BINFO_VIRTUALS (probe)) > ix)\n-\tif (BINFO_VIRTUAL_P (probe))\n-\t  virtual_base = probe;\n-\n-      if (virtual_base)\n-\t/* OK, first_defn got this function from a (possibly lost) primary\n-\t   virtual base, so we're going to use the vcall offset for that\n-\t   primary virtual base.  But the caller is passing a first_defn*,\n-\t   not a virtual_base*, so the correct delta is the delta between\n-\t   first_defn* and itself, i.e. zero.  */\n-\tgoto virtual_covariant;\n-    }\n-\n   /* Compute the constant adjustment to the `this' pointer.  The\n      `this' pointer, when this function is called, will point at BINFO\n      (or one of its primary bases, which are at the same offset).  */\n@@ -2275,7 +2277,6 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n        entry in our vtable.  Except possibly in a constructor vtable,\n        if we happen to get our primary back.  In that case, the offset\n        will be zero, as it will be a primary base.  */\n-   virtual_covariant:\n     delta = size_zero_node;\n   else\n     /* The `this' pointer needs to be adjusted from pointing to\n@@ -2293,6 +2294,9 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n       = get_vcall_index (overrider_target, BINFO_TYPE (virtual_base));\n   else\n     BV_VCALL_INDEX (*virtuals) = NULL_TREE;\n+\n+  if (lost)\n+    BV_LOST_PRIMARY (*virtuals) = true;\n }\n \n /* Called from modify_all_vtables via dfs_walk.  */\n@@ -7648,7 +7652,7 @@ build_vtbl_initializer (tree binfo,\n \t\t\tint* non_fn_entries_p,\n \t\t\tVEC(constructor_elt,gc) **inits)\n {\n-  tree v, b;\n+  tree v;\n   vtbl_init_data vid;\n   unsigned ix, jx;\n   tree vbinfo;\n@@ -7762,20 +7766,8 @@ build_vtbl_initializer (tree binfo,\n \t zero out unused slots in ctor vtables, rather than filling them\n \t with erroneous values (though harmless, apart from relocation\n \t costs).  */\n-      for (b = binfo; ; b = get_primary_binfo (b))\n-\t{\n-\t  /* We found a defn before a lost primary; go ahead as normal.  */\n-\t  if (look_for_overrides_here (BINFO_TYPE (b), fn_original))\n-\t    break;\n-\n-\t  /* The nearest definition is from a lost primary; clear the\n-\t     slot.  */\n-\t  if (BINFO_LOST_PRIMARY_P (b))\n-\t    {\n-\t      init = size_zero_node;\n-\t      break;\n-\t    }\n-\t}\n+      if (BV_LOST_PRIMARY (v))\n+\tinit = size_zero_node;\n \n       if (! init)\n \t{"}, {"sha": "08398aa19ffc61ce22bb4a3020e622a079b2dde0", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02dea3ffc6e0f26963db8255ea003d0ede0918cc/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02dea3ffc6e0f26963db8255ea003d0ede0918cc/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=02dea3ffc6e0f26963db8255ea003d0ede0918cc", "patch": "@@ -168,6 +168,9 @@ c-common.h, not after.\n \n      The BV_FN is the declaration for the virtual function itself.\n \n+     If BV_LOST_PRIMARY is set, it means that this entry is for a lost\n+     primary virtual base and can be left null in the vtable.\n+\n    BINFO_VTABLE\n      This is an expression with POINTER_TYPE that gives the value\n      to which the vptr should be initialized.  Use get_vtbl_decl_for_binfo\n@@ -1767,6 +1770,8 @@ struct GTY((variable_size)) lang_type {\n /* The function to call.  */\n #define BV_FN(NODE) (TREE_VALUE (NODE))\n \n+/* Whether or not this entry is for a lost primary virtual base.  */\n+#define BV_LOST_PRIMARY(NODE) (TREE_LANG_FLAG_0 (NODE))\n \f\n /* For FUNCTION_TYPE or METHOD_TYPE, a list of the exceptions that\n    this type can raise.  Each TREE_VALUE is a _TYPE.  The TREE_VALUE"}, {"sha": "483e9ca46503e4632189ed38ccaa76e473026b80", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02dea3ffc6e0f26963db8255ea003d0ede0918cc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02dea3ffc6e0f26963db8255ea003d0ede0918cc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=02dea3ffc6e0f26963db8255ea003d0ede0918cc", "patch": "@@ -1,3 +1,9 @@\n+2010-07-09  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/abi/covariant6.C: New.\n+\t* g++.dg/inherit/covariant17.C: Test both bases.\n+\t* g++.dg/inherit/covariant7.C: Check vtable layout.\n+\n 2010-07-09  Tom de Vries  <tjvries@xs4all.nl>\n \n \t* gcc.dg/debug/dwarf2/pr31230.c: New testcase."}, {"sha": "ae8c5e603da70ffe862f62500a720ec8f1a65d9f", "filename": "gcc/testsuite/g++.dg/abi/covariant1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02dea3ffc6e0f26963db8255ea003d0ede0918cc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fcovariant1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02dea3ffc6e0f26963db8255ea003d0ede0918cc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fcovariant1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fcovariant1.C?ref=02dea3ffc6e0f26963db8255ea003d0ede0918cc", "patch": "@@ -1,8 +1,8 @@\n // { dg-do compile }\n // { dg-options \"-w\" }\n \n-// We don't want to use a covariant thunk to have a virtual\n-// primary base\n+// If a covariant thunk is overriding a virtual primary base, we have to\n+// use the vcall offset even though we know it will be 0.\n \n struct c4 {};\n "}, {"sha": "9dfc5ba74ab9f6a786a0e2ff98ed111ab913f877", "filename": "gcc/testsuite/g++.dg/abi/covariant6.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02dea3ffc6e0f26963db8255ea003d0ede0918cc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fcovariant6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02dea3ffc6e0f26963db8255ea003d0ede0918cc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fcovariant6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fcovariant6.C?ref=02dea3ffc6e0f26963db8255ea003d0ede0918cc", "patch": "@@ -0,0 +1,34 @@\n+struct A\n+{\n+  virtual A* f();\n+};\n+\n+struct B: virtual A\n+{\n+  virtual A* f();\n+};\n+\n+struct C: B\n+{\n+  virtual C* f();\n+};\n+\n+C* C::f() { return 0; }\n+\n+// When we emit C::f, we should emit both thunks: one for B and one for A.\n+// { dg-final { scan-assembler \"_ZTch0_v0_n16_N1C1fEv\" { target ilp32 } } }\n+// { dg-final { scan-assembler \"_ZTch0_v0_n32_N1C1fEv\" { target lp64 } } }\n+// { dg-final { scan-assembler \"_ZTcv0_n12_v0_n16_N1C1fEv\" { target ilp32 } } }\n+// { dg-final { scan-assembler \"_ZTcv0_n24_v0_n32_N1C1fEv\" { target lp64 } } }\n+\n+struct D: B\n+{\n+  virtual void dummy ();\n+  virtual D* f();\n+};\n+\n+void D::dummy() { }\n+\n+// When we emit the D vtable, it should refer to the thunk for B.\n+// { dg-final { scan-assembler \"_ZTch0_v0_n16_N1D1fEv\" { target ilp32 } } }\n+// { dg-final { scan-assembler \"_ZTch0_v0_n32_N1D1fEv\" { target lp64 } } }"}, {"sha": "b2de15f7ed6b1da27c500f3ca3fe33333f53c124", "filename": "gcc/testsuite/g++.dg/inherit/covariant17.C", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02dea3ffc6e0f26963db8255ea003d0ede0918cc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fcovariant17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02dea3ffc6e0f26963db8255ea003d0ede0918cc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fcovariant17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fcovariant17.C?ref=02dea3ffc6e0f26963db8255ea003d0ede0918cc", "patch": "@@ -18,7 +18,7 @@ struct B {\n };\n \n struct C : public virtual B {\n-  virtual B *clone() const = 0;\n+  virtual C *clone() const = 0;\n };\n \n struct E* ep;\n@@ -28,13 +28,16 @@ struct E : public A, public C {\n   virtual E *clone() const {\n     if (this != ep)\n       abort();\n-    return new E(*this);\n+    return 0;\n   }\n };\n \n int main() {\n   E *a = new E(123);\n-  B *c = a;\n-  B *d = c->clone();\n+  C *c = a;\n+  B *b = a;\n+  c->clone();\n+  b->clone();\n+  delete a;\n   return 0;\n }"}, {"sha": "4d519ed400bb6118914511e74f7ee813fc509797", "filename": "gcc/testsuite/g++.dg/inherit/covariant7.C", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02dea3ffc6e0f26963db8255ea003d0ede0918cc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fcovariant7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02dea3ffc6e0f26963db8255ea003d0ede0918cc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fcovariant7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fcovariant7.C?ref=02dea3ffc6e0f26963db8255ea003d0ede0918cc", "patch": "@@ -1,4 +1,6 @@\n // { dg-do compile }\n+// { dg-prune-output \"direct base\" }\n+// { dg-options \"-fdump-class-hierarchy\" }\n \n // Copyright (C) 2002 Free Software Foundation, Inc.\n // Contributed by Nathan Sidwell 27 Dec 2002 <nathan@codesourcery.com>\n@@ -27,7 +29,23 @@ struct c4 : virtual c3, virtual c0, virtual c1\n   int m;\n };\n \n-struct c6 : c0, c3, c4\t\t// { dg-warning \"direct base\" \"\" }\n+struct c6 : c0, c3, c4\n {\n   virtual c1 &f2() volatile;\n };\n+\n+// f2 appears four times in the c6 vtables:\n+// once in c1-in-c3-in-c6 - covariant, virtual base, uses c1 vcall offset and c0 vbase offset\n+// { dg-final { scan-tree-dump \"24    c6::_ZTcv0_n16_v0_n12_NV2c62f2Ev\" \"class\" { target ilp32 } } }\n+// { dg-final { scan-tree-dump \"48    c6::_ZTcv0_n32_v0_n24_NV2c62f2Ev\" \"class\" { target lp64 } } }\n+// once in c3-in-c6 - non-covariant, non-virtual base, calls f2 directly\n+// { dg-final { scan-tree-dump \"28    c6::f2\" \"class\" { target ilp32 } } }\n+// { dg-final { scan-tree-dump \"56    c6::f2\" \"class\" { target lp64 } } }\n+// once in c1-in-c3-in-c4-in-c6 - lost primary\n+// { dg-final { scan-tree-dump \"80    0u\" \"class\" { target ilp32 } } }\n+// { dg-final { scan-tree-dump \"160   0u\" \"class\" { target lp64 } } }\n+// once in c3-in-c4-in-c6 - c3 vcall offset\n+// { dg-final { scan-tree-dump \"84    c6::_ZTv0_n16_NV2c62f2Ev\" \"class\" { target ilp32 } } }\n+// { dg-final { scan-tree-dump \"168   c6::_ZTv0_n32_NV2c62f2Ev\" \"class\" { target lp64 } } }\n+\n+// { dg-final { cleanup-tree-dump \"class\" } }"}]}