{"sha": "b4213ffdafd1907f53c50b7bcdaa7fd269495592", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQyMTNmZmRhZmQxOTA3ZjUzYzUwYjdiY2RhYTdmZDI2OTQ5NTU5Mg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-19T13:10:35Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-19T13:10:35Z"}, "message": "[multiple changes]\n\n2016-04-19  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* checks.adb, sem_util.adb, sem_res.adb, sem_attr.adb: Minor\n\treformatting.\n\n2016-04-19  Ed Schonberg  <schonberg@adacore.com>\n\n\t* freeze.adb (Freeze_Profile): Refine predicate that checks\n\twhether a function that returns a limited view is declared in\n\tanother unit and cannot be frozen at this point.\n\n2016-04-19  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_aggr.adb (Component_Count): Handle properly superflat\n\tarrays, i.e. empty arrays where Hi < Lo - 1, to ensure that the\n\treturn value of the function is Natural, rather than leaving\n\tthe handling of such arrays to the caller of this function.\n\nFrom-SVN: r235200", "tree": {"sha": "2d79230ef6305475d4443fa77a5b880a0db98247", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d79230ef6305475d4443fa77a5b880a0db98247"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4213ffdafd1907f53c50b7bcdaa7fd269495592", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4213ffdafd1907f53c50b7bcdaa7fd269495592", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4213ffdafd1907f53c50b7bcdaa7fd269495592", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4213ffdafd1907f53c50b7bcdaa7fd269495592/comments", "author": null, "committer": null, "parents": [{"sha": "b314303784ccc313d79eadd61770225b0ec7fbfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b314303784ccc313d79eadd61770225b0ec7fbfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b314303784ccc313d79eadd61770225b0ec7fbfc"}], "stats": {"total": 105, "additions": 64, "deletions": 41}, "files": [{"sha": "3a514cd1d42349270aa8d60b11886529adfd9694", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4213ffdafd1907f53c50b7bcdaa7fd269495592/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4213ffdafd1907f53c50b7bcdaa7fd269495592/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b4213ffdafd1907f53c50b7bcdaa7fd269495592", "patch": "@@ -1,3 +1,21 @@\n+2016-04-19  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* checks.adb, sem_util.adb, sem_res.adb, sem_attr.adb: Minor\n+\treformatting.\n+\n+2016-04-19  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* freeze.adb (Freeze_Profile): Refine predicate that checks\n+\twhether a function that returns a limited view is declared in\n+\tanother unit and cannot be frozen at this point.\n+\n+2016-04-19  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_aggr.adb (Component_Count): Handle properly superflat\n+\tarrays, i.e. empty arrays where Hi < Lo - 1, to ensure that the\n+\treturn value of the function is Natural, rather than leaving\n+\tthe handling of such arrays to the caller of this function.\n+\n 2016-04-19  Arnaud Charlet  <charlet@adacore.com>\n \n \t* sem_prag.adb, sem_attr.adb, par-prag.adb, exp_aggr.adb, sem_type.adb"}, {"sha": "47fe1bfe63f7da65ff23ef8c4fafc10047ae681d", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4213ffdafd1907f53c50b7bcdaa7fd269495592/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4213ffdafd1907f53c50b7bcdaa7fd269495592/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=b4213ffdafd1907f53c50b7bcdaa7fd269495592", "patch": "@@ -2354,11 +2354,13 @@ package body Checks is\n \n       --  Local variables\n \n-      Actual_1 : Node_Id;\n-      Actual_2 : Node_Id;\n-      Check    : Node_Id;\n-      Formal_1 : Entity_Id;\n-      Formal_2 : Entity_Id;\n+      Actual_1   : Node_Id;\n+      Actual_2   : Node_Id;\n+      Check      : Node_Id;\n+      Formal_1   : Entity_Id;\n+      Formal_2   : Entity_Id;\n+      Orig_Act_1 : Node_Id;\n+      Orig_Act_2 : Node_Id;\n \n    --  Start of processing for Apply_Parameter_Aliasing_Checks\n \n@@ -2368,6 +2370,7 @@ package body Checks is\n       Actual_1 := First_Actual (Call);\n       Formal_1 := First_Formal (Subp);\n       while Present (Actual_1) and then Present (Formal_1) loop\n+         Orig_Act_1 := Original_Actual (Actual_1);\n \n          --  Ensure that the actual is an object that is not passed by value.\n          --  Elementary types are always passed by value, therefore actuals of\n@@ -2378,30 +2381,27 @@ package body Checks is\n          --  will be done in place and a subsequent read will always see the\n          --  correct value, see RM 6.2 (12/3).\n \n-         if Nkind (Original_Actual (Actual_1)) = N_Aggregate\n-           or else\n-             (Nkind (Original_Actual (Actual_1)) = N_Qualified_Expression\n-                and then Nkind (Expression (Original_Actual (Actual_1))) =\n-                           N_Aggregate)\n+         if Nkind (Orig_Act_1) = N_Aggregate\n+           or else (Nkind (Orig_Act_1) = N_Qualified_Expression\n+                     and then Nkind (Expression (Orig_Act_1)) = N_Aggregate)\n          then\n             null;\n \n-         elsif Is_Object_Reference (Original_Actual (Actual_1))\n-           and then not Is_Elementary_Type (Etype (Original_Actual (Actual_1)))\n-           and then\n-              not Is_By_Reference_Type (Etype (Original_Actual (Actual_1)))\n+         elsif Is_Object_Reference (Orig_Act_1)\n+           and then not Is_Elementary_Type (Etype (Orig_Act_1))\n+           and then not Is_By_Reference_Type (Etype (Orig_Act_1))\n          then\n             Actual_2 := Next_Actual (Actual_1);\n             Formal_2 := Next_Formal (Formal_1);\n             while Present (Actual_2) and then Present (Formal_2) loop\n+               Orig_Act_2 := Original_Actual (Actual_2);\n \n                --  The other actual we are testing against must also denote\n                --  a non pass-by-value object. Generate the check only when\n                --  the mode of the two formals may lead to aliasing.\n \n-               if Is_Object_Reference (Original_Actual (Actual_2))\n-                 and then not\n-                   Is_Elementary_Type (Etype (Original_Actual (Actual_2)))\n+               if Is_Object_Reference (Orig_Act_2)\n+                 and then not Is_Elementary_Type (Etype (Orig_Act_2))\n                  and then May_Cause_Aliasing (Formal_1, Formal_2)\n                then\n                   Overlap_Check"}, {"sha": "94f8e0745ec7039c0baa7e5e61b255301b5d13ec", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4213ffdafd1907f53c50b7bcdaa7fd269495592/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4213ffdafd1907f53c50b7bcdaa7fd269495592/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=b4213ffdafd1907f53c50b7bcdaa7fd269495592", "patch": "@@ -354,10 +354,16 @@ package body Exp_Aggr is\n                Siz : constant Nat := Component_Count (Component_Type (T));\n \n             begin\n+               --  Check for superflat arrays, i.e. arrays with such bounds\n+               --  as 4 .. 2, to insure that this function never returns a\n+               --  meaningless negative value.\n+\n                if not Compile_Time_Known_Value (Lo)\n                  or else not Compile_Time_Known_Value (Hi)\n+                 or else Expr_Value (Hi) < Expr_Value (Lo)\n                then\n                   return 0;\n+\n                else\n                   return\n                     Siz * UI_To_Int (Expr_Value (Hi) - Expr_Value (Lo) + 1);"}, {"sha": "f23e168bd2274480f064e64a31f2694b8373e02d", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4213ffdafd1907f53c50b7bcdaa7fd269495592/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4213ffdafd1907f53c50b7bcdaa7fd269495592/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=b4213ffdafd1907f53c50b7bcdaa7fd269495592", "patch": "@@ -3288,12 +3288,14 @@ package body Freeze is\n \n          if Ekind (E) = E_Function then\n \n-            --  Check whether function is declared elsewhere.\n+            --  Check whether function is declared elsewhere. Previous code\n+            --  used Get_Source_Unit on both arguments, but the values are\n+            --  equal in the case of a parent and a child unit.\n+            --  Confusion with subunits in code  ????\n \n             Late_Freezing :=\n-              Get_Source_Unit (E) /= Get_Source_Unit (N)\n-                and then Returns_Limited_View (E)\n-                and then not In_Open_Scopes (Scope (E));\n+              not In_Same_Extended_Unit (E, N)\n+                and then Returns_Limited_View (E);\n \n             --  Freeze return type\n "}, {"sha": "66c6432dddfdf73f50a9e29a4ae8a39e3cffb9f7", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4213ffdafd1907f53c50b7bcdaa7fd269495592/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4213ffdafd1907f53c50b7bcdaa7fd269495592/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=b4213ffdafd1907f53c50b7bcdaa7fd269495592", "patch": "@@ -10094,11 +10094,10 @@ package body Sem_Attr is\n                      Freeze_Before (N, Entity (P));\n                   end if;\n \n-               --    If it is a type, there is nothing to resolve.\n-               --    If it is an object, complete its resolution.\n+               --  If it is a type, there is nothing to resolve. If it is an\n+               --  object, complete its resolution.\n \n                elsif Is_Overloadable (Entity (P)) then\n-\n                   if not In_Spec_Expression then\n                      Freeze_Before (N, Entity (P));\n                   end if;"}, {"sha": "29c5612065083e4ee16e3e2742673c149c53936e", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4213ffdafd1907f53c50b7bcdaa7fd269495592/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4213ffdafd1907f53c50b7bcdaa7fd269495592/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=b4213ffdafd1907f53c50b7bcdaa7fd269495592", "patch": "@@ -6963,8 +6963,8 @@ package body Sem_Res is\n             then\n                null;\n             else\n-               Error_Msg_N (\n-                 \"deferred constant is frozen before completion\", N);\n+               Error_Msg_N\n+                 (\"deferred constant is frozen before completion\", N);\n             end if;\n          end if;\n "}, {"sha": "0d9b4d14394f76b5e191fde5c5e219da07cb7dae", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4213ffdafd1907f53c50b7bcdaa7fd269495592/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4213ffdafd1907f53c50b7bcdaa7fd269495592/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=b4213ffdafd1907f53c50b7bcdaa7fd269495592", "patch": "@@ -13103,9 +13103,9 @@ package body Sem_Util is\n \n          Par := Nod;\n          while Present (Par) loop\n-            if Nkind_In (Par, N_Function_Call,\n-                              N_Procedure_Call_Statement,\n-                              N_Entry_Call_Statement)\n+            if Nkind_In (Par, N_Entry_Call_Statement,\n+                              N_Function_Call,\n+                              N_Procedure_Call_Statement)\n             then\n                return True;\n \n@@ -15978,22 +15978,20 @@ package body Sem_Util is\n             if New_Sloc /= No_Location then\n                Set_Sloc (New_Node, New_Sloc);\n \n-               --  If we adjust the Sloc, then we are essentially making\n-               --  a completely new node, so the Comes_From_Source flag\n-               --  should be reset to the proper default value.\n-\n-               Set_Comes_From_Source (New_Node,\n-                                      Default_Node.Comes_From_Source);\n+               --  If we adjust the Sloc, then we are essentially making a\n+               --  completely new node, so the Comes_From_Source flag should\n+               --  be reset to the proper default value.\n \n+               Set_Comes_From_Source\n+                 (New_Node, Default_Node.Comes_From_Source);\n             end if;\n \n-            --  If the node is call and has named associations,\n-            --  set the corresponding links in the copy.\n+            --  If the node is a call and has named associations, set the\n+            --  corresponding links in the copy.\n \n-            if (Nkind (Old_Node) = N_Function_Call\n-                 or else Nkind (Old_Node) = N_Entry_Call_Statement\n-                 or else\n-                   Nkind (Old_Node) = N_Procedure_Call_Statement)\n+            if Nkind_In (Old_Node, N_Entry_Call_Statement,\n+                                   N_Function_Call,\n+                                   N_Procedure_Call_Statement)\n               and then Present (First_Named_Actual (Old_Node))\n             then\n                Adjust_Named_Associations (Old_Node, New_Node);"}]}