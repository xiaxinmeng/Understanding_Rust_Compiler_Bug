{"sha": "6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRjNDJlNDlkM2RhYzc1NmVjNzJlMTBmM2JmNzY4N2Y5Yzg1NDJjMg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-07T06:41:23Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-07T06:41:23Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r930", "tree": {"sha": "d583d908c670671b25c202db24844f7db39d0ad1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d583d908c670671b25c202db24844f7db39d0ad1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/comments", "author": null, "committer": null, "parents": [{"sha": "c5b7917eac14be1be0843853dd1f2a13679f25a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5b7917eac14be1be0843853dd1f2a13679f25a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5b7917eac14be1be0843853dd1f2a13679f25a7"}], "stats": {"total": 248, "additions": 125, "deletions": 123}, "files": [{"sha": "0a0813ade437cb6fac519122200647ac5bf6a551", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -3554,7 +3554,7 @@ build_compound_expr (list)\n \n   if (TREE_CHAIN (list) == 0)\n     {\n-#if 0 /* If something inside inhibited lvalueness, we shoukd not override.  */\n+#if 0 /* If something inside inhibited lvalueness, we should not override.  */\n       /* Consider (x, y+0), which is not an lvalue since y+0 is not.  */\n \n       /* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */\n@@ -4369,7 +4369,7 @@ get_spelling (errtype)\n    into the message.\n \n    If OFWHAT is null, the component name is stored on the spelling stack.\n-   If the compoment name is a null string, then LOCAL is omitted entirely.  */\n+   If the component name is a null string, then LOCAL is omitted entirely.  */\n \n void\n error_init (format, local, ofwhat)\n@@ -4395,7 +4395,7 @@ error_init (format, local, ofwhat)\n    into the message.\n \n    If OFWHAT is null, the component name is stored on the spelling stack.\n-   If the compoment name is a null string, then LOCAL is omitted entirely.  */\n+   If the component name is a null string, then LOCAL is omitted entirely.  */\n \n void\n pedwarn_init (format, local, ofwhat)"}, {"sha": "4a901dddd374927813945ed60a983c02f556bd3d", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -1815,7 +1815,7 @@\n \t  return \\\"subq%.w %2,%0\\\";\n \t}\n       /* On everything except the 68000 it is faster to use two\n-\t addqw insttuctions to add a small integer (8 < N <= 16)\n+\t addqw instructions to add a small integer (8 < N <= 16)\n \t to an address register.  Likewise for subqw. */\n       if (INTVAL (operands[2]) > 8\n \t  && INTVAL (operands[2]) <= 16\n@@ -1875,7 +1875,7 @@\n \t  return \\\"subq%.w %1,%0\\\";\n \t}\n       /* On everything except the 68000 it is faster to use two\n-\t addqw instuctions to add a small integer (8 < N <= 16)\n+\t addqw instructions to add a small integer (8 < N <= 16)\n \t to an address register.  Likewise for subqw. */\n       if (INTVAL (operands[1]) > 8\n \t  && INTVAL (operands[1]) <= 16\n@@ -1929,7 +1929,7 @@\n \t  return \\\"subq%.w %1,%0\\\";\n \t}\n       /* On everything except the 68000 it is faster to use two\n-\t addqw instuctions to add a small integer (8 < N <= 16)\n+\t addqw instructions to add a small integer (8 < N <= 16)\n \t to an address register.  Likewise for subqw. */\n       if (INTVAL (operands[1]) > 8\n \t  && INTVAL (operands[1]) <= 16"}, {"sha": "1147694f5e68e471baaf97809fe237853ca4ef81", "filename": "gcc/config/m88k/m88k.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fconfig%2Fm88k%2Fm88k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fconfig%2Fm88k%2Fm88k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -1729,7 +1729,7 @@ m88k_layout_frame ()\n       }\n \n   /* Achieve greatest use of double memory ops.  Either we end up saving\n-     r30 or we use that slot to align the regsters we do save.  */\n+     r30 or we use that slot to align the registers we do save.  */\n   if (nregs >= 2 && save_regs[1] && !save_regs[FRAME_POINTER_REGNUM])\n     sp_size += 4;\n "}, {"sha": "ec774d4629c58d69e2c1b822632f5251426021f0", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -1056,7 +1056,7 @@ output_block_move (operands, size_is_constant)\n \t    goto copy_with_loop;\n \n \t  /* Read and store using two registers, and hide latency\n-\t     by defering the stores until three instructions after\n+\t     by deferring the stores until three instructions after\n \t     the corresponding load.  The last load insn will read\n \t     the entire word were the last bytes are, possibly past\n \t     the end of the source block, but since loads are aligned,\n@@ -1144,7 +1144,7 @@ output_block_move (operands, size_is_constant)\n       output_asm_insn (\"addib,<,n -4,%2,.+16\", operands);\n     }\n \n-  /* Copying loop.  Note that the first load is in the anulled delay slot\n+  /* Copying loop.  Note that the first load is in the annulled delay slot\n      of addib.  Is it OK on PA to have a load in a delay slot, i.e. is a\n      possible page fault stopped in time?  */\n   output_asm_insn (\"ldws,ma 4(0,%1),%3\", operands);\n@@ -1170,7 +1170,7 @@ output_block_move (operands, size_is_constant)\n       output_asm_insn (\"addib,=,n 4,%2,.+16\", operands);\n \n       /* Read the entire word of the source block tail.  (Also this\n-\t load is in an anulled delay slot.)  */\n+\t load is in an annulled delay slot.)  */\n       output_asm_insn (\"ldw 0(0,%1),%3\", operands);\n \n       /* Make %0 point at the first byte after the destination block.  */"}, {"sha": "43ec22a45ddfedd0e4776d503bda6b24dbf275f9", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -1745,7 +1745,7 @@\n {\n   rtx op2 = operands[2];\n \n-  /* If constant is postive, upper bits zeroed, otherwise unchanged.\n+  /* If constant is positive, upper bits zeroed, otherwise unchanged.\n      Give the assembler a chance to pick the move instruction. */\n   if (GET_CODE (op2) == CONST_INT)\n     {"}, {"sha": "49789ae619f4e90b5c0212af1dd24af1720747e9", "filename": "gcc/dbxout.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -521,7 +521,7 @@ dbxout_continue ()\n   current_sym_nchars = 0;\n }\n \f\n-/* Subtroutine of `dbxout_type'.  Output the type fields of TYPE.\n+/* Subroutine of `dbxout_type'.  Output the type fields of TYPE.\n    This must be a separate function because anonymous unions require\n    recursive calls.  */\n \n@@ -614,7 +614,7 @@ dbxout_type_fields (type)\n     }\n }\n \f\n-/* Subtroutine of `dbxout_type_methods'.  Output debug info about the\n+/* Subroutine of `dbxout_type_methods'.  Output debug info about the\n    method described DECL.  DEBUG_NAME is an encoding of the method's\n    type signature.  ??? We may be able to do without DEBUG_NAME altogether\n    now.  */"}, {"sha": "4c32e59a416cea0ecfafaa65ecc2f5e55894f4f7", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -243,7 +243,7 @@ static unsigned pending_siblings_allocated;\n #define PENDING_SIBLINGS_INCREMENT 64\n \n /* Non-zero if we are performing our file-scope finalization pass and if\n-   we should force out Dwarf decsriptions of any and all file-scope\n+   we should force out Dwarf descriptions of any and all file-scope\n    tagged types which are still incomplete types.  */\n \n static int finalizing = 0;\n@@ -268,11 +268,11 @@ static unsigned pending_types;\n \n #define PENDING_TYPES_INCREMENT 64\n \n-/* Pointer to an artifical RECORD_TYPE which we create in dwarfout_init.\n+/* Pointer to an artificial RECORD_TYPE which we create in dwarfout_init.\n    This is used in a hack to help us get the DIEs describing types of\n    formal parameters to come *after* all of the DIEs describing the formal\n    parameters themselves.  That's necessary in order to be compatible\n-   with what the brain-dammaged svr4 SDB debugger requires.  */\n+   with what the brain-damaged svr4 SDB debugger requires.  */\n \n static tree fake_containing_scope;\n \n@@ -2405,7 +2405,7 @@ type_tag (type)\n \t does.  It always makes the TYPE_NAME for each tagged type be either\n \t NULL (signifying an anonymous tagged type) or else a pointer to an\n \t IDENTIFIER_NODE.  Obviously, we would like to generate correct Dwarf\n-\t for both C and C++, but given this inconsistancy in the TREE\n+\t for both C and C++, but given this inconsistency in the TREE\n \t representation of tagged types for C and C++ in the GNU front-ends,\n \t we cannot support both languages correctly unless we introduce some\n \t front-end specific code here, and rms objects to that, so we can\n@@ -3374,7 +3374,7 @@ output_type (type, containing_scope)\n \n       case FILE_TYPE:\n \toutput_type (TREE_TYPE (type), containing_scope);\n-\tabort ();\t/* No way to reprsent these in Dwarf yet!  */\n+\tabort ();\t/* No way to represent these in Dwarf yet!  */\n \tbreak;\n \n       case STRING_TYPE:\n@@ -4043,7 +4043,9 @@ dwarfout_file_scope_decl (decl, set_finalizing)\n       if (TREE_EXTERNAL (decl) && !TREE_USED (decl))\n \treturn;\n \n-      if (TREE_PUBLIC (decl) && ! TREE_EXTERNAL (decl))\n+      if (TREE_PUBLIC (decl)\n+\t  && ! TREE_EXTERNAL (decl)\n+\t  && GET_CODE (DECL_RTL (decl)) == MEM)\n \t{\n \t  char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n@@ -4064,7 +4066,7 @@ dwarfout_file_scope_decl (decl, set_finalizing)\n \t  if (DECL_INITIAL (decl) == NULL)\n \t    {\n \t      /* Output a .debug_aranges entry for a public variable\n-\t\t which is tenatively defined in this compilation unit.  */\n+\t\t which is tentatively defined in this compilation unit.  */\n \n \t      fputc ('\\n', asm_out_file);\n \t      ASM_OUTPUT_PUSH_SECTION (asm_out_file, ARANGES_SECTION);\n@@ -4660,7 +4662,7 @@ dwarfout_finish ()\n \n      In order to force the label `..D2' to get aligned to a 4 byte boundary,\n      the trick used is to insert extra (otherwise useless) padding bytes\n-     into the (null) DIE that we know must preceed the ..D2 label in the\n+     into the (null) DIE that we know must precede the ..D2 label in the\n      .debug section.  The amount of padding required can be anywhere between\n      0 and 3 bytes.  The length word at the start of this DIE (i.e. the one\n      with the padding) would normally contain the value 4, but now it will"}, {"sha": "331a48c6df59925af3eb19648fea548eac2e1e24", "filename": "gcc/enquire.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fenquire.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fenquire.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fenquire.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -388,7 +388,7 @@\n #include <setjmp.h>\n #endif\n \n-/* Kludge around the possiblity that <stdio.h> includes <limits.h> */\n+/* Kludge around the possibility that <stdio.h> includes <limits.h> */\n #ifdef CHAR_BIT\n #undef CHAR_BIT\n #undef CHAR_MAX"}, {"sha": "a895a5b9a6a57c027a7b55db9d98fad981ce4b78", "filename": "gcc/expr.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -1330,7 +1330,7 @@ gen_push_operand ()\n    REG must be a hard register in this case.\n \n    EXTRA is the amount in bytes of extra space to leave next to this arg.\n-   This is ignored if an argument block has already been allocted.\n+   This is ignored if an argument block has already been allocated.\n \n    On a machine that lacks real push insns, ARGS_ADDR is the address of\n    the bottom of the argument block for this call.  We use indexing off there\n@@ -2880,7 +2880,7 @@ fixed_type_p (exp)\n \n    EXPAND_INITIALIZER is much like EXPAND_SUM except that\n    it also marks a label as absolutely required (it can't be dead).\n-   This is used for outputting expressions used in intializers.  */\n+   This is used for outputting expressions used in initializers.  */\n \n rtx\n expand_expr (exp, target, tmode, modifier)\n@@ -5101,8 +5101,8 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n       target = allocate_dynamic_stack_space (op0, target, BITS_PER_UNIT);\n \n       /* Record the new stack level for nonlocal gotos.  */\n-      if (nonlocal_goto_stack_level != 0)\n-\temit_move_insn (nonlocal_goto_stack_level, stack_pointer_rtx);\n+      if (nonlocal_goto_handler_slot != 0)\n+\temit_stack_save (SAVE_NONLOCAL, &nonlocal_goto_stack_level, 0);\n       return target;\n \n     case BUILT_IN_FFS:"}, {"sha": "da440ec3472d42b539800325d2b67c00e7aaf1b9", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -442,7 +442,7 @@ extern void emit_0_to_1_insn ();\n /* Emit one rtl insn to compare two rtx's.  */\n extern void emit_cmp_insn ();\n \n-/* Generate rtl to compate two rtx's, will call emit_cmp_insn.  */\n+/* Generate rtl to compare two rtx's, will call emit_cmp_insn.  */\n extern rtx compare_from_rtx ();\n \n /* Emit some rtl insns to move data between rtx's, converting machine modes."}, {"sha": "006858391fc9008c64a68ca20b490d86b4efb01c", "filename": "gcc/fixincludes", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Ffixincludes", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Ffixincludes", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixincludes?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -182,7 +182,7 @@ EOF\n   fi\n fi\n \n-# Fix this Sun file to avoid intefering with stddef.h.\n+# Fix this Sun file to avoid interfering with stddef.h.\n file=sys/stdtypes.h\n if [ -r $file ] && [ ! -r ${LIB}/$file ]; then\n   cp $file ${LIB}/$file >/dev/null 2>&1 || echo \"Can't copy $file\"\n@@ -227,7 +227,7 @@ EOF\n   fi\n fi\n \n-# Fix this file to avoid intefering with stddef.h.\n+# Fix this file to avoid interfering with stddef.h.\n file=sys/types.h\n if [ -r $file ] && [ ! -r ${LIB}/$file ]; then\n   cp $file ${LIB}/$file >/dev/null 2>&1 || echo \"Can't copy $file\""}, {"sha": "bc9096ffff12f2141ce5f59ce504243d94308f0f", "filename": "gcc/flow.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -466,7 +466,7 @@ find_basic_blocks (f, nonlocal_label_list)\n \n \tBLOCK_NUM (insn) = i;\n \n-\t/* Don't separare a CALL_INSN from following CLOBBER insns.  This is\n+\t/* Don't separate a CALL_INSN from following CLOBBER insns.  This is\n \t   a kludge that will go away when each CALL_INSN records its\n \t   USE and CLOBBERs.  */\n "}, {"sha": "2b39c1153e5365b3d27946bdd4c88d6b1b0f0810", "filename": "gcc/fold-const.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -19,7 +19,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n /*@@ Fix lossage on folding division of big integers.  */\n \n-/*@@ This file should be rewritten to use an arbitary precision\n+/*@@ This file should be rewritten to use an arbitrary precision\n   @@ representation for \"struct tree_int_cst\" and \"struct tree_real_cst\".\n   @@ Perhaps the routines could also be used for bc/dc, and made a lib.\n   @@ The routines that translate from the ap rep should\n@@ -509,7 +509,7 @@ div_and_round_double (code, uns,\n     }\n   else {\t\t\t/* full double precision,\n \t\t\t\t   with thanks to Don Knuth's\n-\t\t\t\t   \"Semi-Numericial Algorithms\".  */\n+\t\t\t\t   \"Seminumerical Algorithms\".  */\n #define BASE 256\n     int quo_est, scale, num_hi_sig, den_hi_sig, quo_hi_sig;\n \n@@ -549,7 +549,7 @@ div_and_round_double (code, uns,\n \n     /* Main loop */\n     for (i = quo_hi_sig; i > 0; i--) {\n-      /* quess the next quotient digit, quo_est, by dividing the first\n+      /* guess the next quotient digit, quo_est, by dividing the first\n \t two remaining dividend digits by the high order quotient digit.\n \t quo_est is never low and is at most 2 high.  */\n \n@@ -2008,7 +2008,7 @@ make_bit_field_ref (inner, type, bitsize, bitpos, unsignedp)\n    COMPARE_TYPE is the type of the comparison, and LHS and RHS\n    are the left and right operands of the comparison, respectively.\n \n-   If the optimization described above can be done, we return the resuling\n+   If the optimization described above can be done, we return the resulting\n    tree.  Otherwise we return zero.  */\n \n static tree\n@@ -2239,7 +2239,7 @@ decode_field_reference (exp, pbitsize, pbitpos, pmode, punsignedp,\n   return inner;\n }\n \n-/* Return non-zero if MASK respresents a mask of SIZE ones in the low-order\n+/* Return non-zero if MASK represents a mask of SIZE ones in the low-order\n    bit positions.  */\n \n static int"}, {"sha": "602544f1fd4a42d13ca0cef5b37cc0ffa963cdb2", "filename": "gcc/function.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -372,7 +372,7 @@ find_function_data (decl)\n /* Save the current context for compilation of a nested function.\n    This is called from language-specific code.\n    The caller is responsible for saving any language-specific status,\n-   since this function knows only about language-indepedent variables.  */\n+   since this function knows only about language-independent variables.  */\n \n void\n push_function_context ()\n@@ -1178,7 +1178,7 @@ fixup_var_refs_1 (var, loc, insn, replacements)\n \t      if (GET_CODE (x) == SIGN_EXTRACT)\n \t\twanted_mode = insn_operand_mode[(int) CODE_FOR_extv][1];\n #endif\n-\t      /* If we have a narrower mode, we can do someting.  */\n+\t      /* If we have a narrower mode, we can do something.  */\n \t      if (wanted_mode != VOIDmode\n \t\t  && GET_MODE_SIZE (wanted_mode) < GET_MODE_SIZE (is_mode))\n \t\t{\n@@ -1338,7 +1338,7 @@ fixup_var_refs_1 (var, loc, insn, replacements)\n \t\tint width = INTVAL (XEXP (outerdest, 1));\n \t\tint pos = INTVAL (XEXP (outerdest, 2));\n \n-\t\t/* If we have a narrower mode, we can do someting.  */\n+\t\t/* If we have a narrower mode, we can do something.  */\n \t\tif (GET_MODE_SIZE (wanted_mode) < GET_MODE_SIZE (is_mode))\n \t\t  {\n \t\t    int offset = pos / BITS_PER_UNIT;"}, {"sha": "6a6449d679caa53361e8d0961440ab44bd0fdc37", "filename": "gcc/gcc.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -125,7 +125,7 @@ static int cross_compile = 0;\n static struct obstack obstack;\n \n /* This is the obstack to build an environment variable to pass to\n-   collect2 that describes all of the relavant switches of what to\n+   collect2 that describes all of the relevant switches of what to\n    pass the compiler in building the list of pointers to constructors\n    and destructors.  */\n \n@@ -237,7 +237,7 @@ or with constant text in a single argument.\n  %{S*:X} substitutes X if one or more switches whose names with -S are\n \tspecified to CC.  Note that the tail part of the -S option\n \t(i.e. the part matched by the `*') will be substituted for each\n-\toccurance of %* within X.\n+\toccurrence of %* within X.\n  %{S:X} substitutes X, but only if the -S switch was given to CC.\n  %{!S:X} substitutes X, but only if the -S switch was NOT given to CC.\n  %{|S:X} like %{S:X}, but if no S switch, substitute `-'.\n@@ -549,7 +549,7 @@ static char *link_command_spec = \"\\\n #endif\n \n /* A vector of options to give to the linker.\n-   These options are accumlated by %x\n+   These options are accumulated by %x\n    and substituted into the linker command with %X.  */\n static int n_linker_options;\n static char **linker_options;"}, {"sha": "7fea0f99b01b452e5459b1dd2ac91a43dd7c2683", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -18,7 +18,7 @@ You should have received a copy of the GNU General Public License\n along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n-/* This program handles insn attribues and the DEFINE_DELAY and\n+/* This program handles insn attributes and the DEFINE_DELAY and\n    DEFINE_FUNCTION_UNIT definitions.\n \n    It produces a series of functions named `get_attr_...', one for each insn\n@@ -1344,7 +1344,7 @@ get_attr_value (value, attr, insn_code)\n    Finally, for each [DEFINE_DELAY, slot #] pair, we compute an attribute that\n    tells whether a given insn can be in that delay slot.\n \n-   Normal attrbute filling and optimization expands these to contain the\n+   Normal attribute filling and optimization expands these to contain the\n    information needed to handle delay slots.  */\n \n static void\n@@ -1387,8 +1387,8 @@ expand_delays ()\n       make_internal_attr (\"*delay_type\", condexp, 1);\n     }\n \n-  /* For each delay possibility and delay slot, compute an eligability\n-     attribute for non-anulled insns and for each type of annulled (annul\n+  /* For each delay possibility and delay slot, compute an eligibility\n+     attribute for non-annulled insns and for each type of annulled (annul\n      if true and annul if false).  */\n  for (delay = delays; delay; delay = delay->next)\n    {\n@@ -2386,7 +2386,7 @@ simplify_and_tree (exp, pterm, insn_code, insn_index)\n   return exp;\n }\n \f\n-/* Similiar to `simplify_and_tree', but for IOR trees.  */\n+/* Similar to `simplify_and_tree', but for IOR trees.  */\n \n static rtx\n simplify_or_tree (exp, pterm, insn_code, insn_index)\n@@ -3238,7 +3238,7 @@ gen_unit (def)\n   struct function_unit_op *op;\n \n   /* See if we have already seen this function unit.  If so, check that\n-     the multipicity and simultaneity values are the same.  If not, make\n+     the multiplicity and simultaneity values are the same.  If not, make\n      a structure for this function unit.  */\n   for (unit = units; unit; unit = unit->next)\n     if (! strcmp (unit->name, XSTR (def, 0)))\n@@ -3913,7 +3913,7 @@ write_indent (indent)\n    the specified insn can be annulled if the branch is true, and likewise\n    for `eligible_for_annul_false'.\n \n-   KIND is a string distingushing these three cases (\"delay\", \"annul_true\",\n+   KIND is a string distinguishing these three cases (\"delay\", \"annul_true\",\n    or \"annul_false\").  */\n \n static void\n@@ -4149,7 +4149,7 @@ write_function_unit_info ()\n     }\n \n   /* Now that all functions have been written, write the table describing\n-     the function units.   The name is included for documenation purposes\n+     the function units.   The name is included for documentation purposes\n      only.  */\n \n   printf (\"struct function_unit_desc function_units[] = {\\n\");"}, {"sha": "83a6d260fc4c56168d0e661876785fcf1d8fa814", "filename": "gcc/genrecog.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -633,7 +633,7 @@ not_both_true (d1, d2, toplevel)\n \n    We would like to list nodes testing for specific codes before those\n    that test predicates to avoid unnecessary function calls.  Similarly,\n-   tests for specific modes should preceed nodes that allow any mode.\n+   tests for specific modes should precede nodes that allow any mode.\n \n    This function returns the merit (with 0 being the best) of inserting\n    a test involving the specified MODE and CODE after node P.  If P is\n@@ -991,7 +991,7 @@ static char *indents[]\n    of the same mode, we also group tests with the same code, followed by a\n    group that does not test a code.\n \n-   Occasionally, we cannot arbitarily reorder the tests so that multiple\n+   Occasionally, we cannot arbitrarily reorder the tests so that multiple\n    sequence of groups as described above are present.\n \n    We generate two nested switch statements, the outer statement for"}, {"sha": "7034f2377cc52357e061f811011b60a415bb788a", "filename": "gcc/ginclude/va-pyr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fginclude%2Fva-pyr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fginclude%2Fva-pyr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-pyr.h?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -8,7 +8,7 @@\n  * a way that is compatible with code compiled by the Pyramid Technology\n  * C compiler.\n  * As such, it depends strongly on the Pyramid conventions for\n- * parameter passing.ct and indepenent implementation. \n+ * parameter passing.ct and independent implementation. \n  * These (somewhat bizarre) parameter-passing conventions are described\n  * in the ``OSx Operating System Porting Guide''.\n  * "}, {"sha": "eee5f38e4a4822e75342c2dd1d41c193e6299e75", "filename": "gcc/ginclude/va-sparc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fginclude%2Fva-sparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fginclude%2Fva-sparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-sparc.h?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -1,5 +1,5 @@\n /* This is just like the default gvarargs.h\n-   except for differences decribed below.  */\n+   except for differences described below.  */\n \n /* Make this a macro rather than a typedef, so we can undef any other defn.  */\n #define va_list __va___list"}, {"sha": "3f9b08190290ef3ae883850fc678707c8df26825", "filename": "gcc/global.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -91,7 +91,7 @@ static int *allocno_order;\n static int *allocno_size;\n \n /* Indexed by (pseudo) reg number, gives the number of another\n-   lower-numbered pseudo reg which can share a hard reg with this peudo\n+   lower-numbered pseudo reg which can share a hard reg with this pseudo\n    *even if the two pseudos would otherwise appear to conflict*.  */\n \n static int *reg_may_share;\n@@ -1458,7 +1458,7 @@ mark_reg_live_nc (regno, mode)\n    try to set a preference.  If one of the two is a hard register and the other\n    is a pseudo-register, mark the preference.\n    \n-   Note that we are not as agressive as local-alloc in trying to tie a\n+   Note that we are not as aggressive as local-alloc in trying to tie a\n    pseudo-register to a hard register.  */\n \n static void"}, {"sha": "60d74a148a84a42274cc8f1a37111d1f6a7b6a1b", "filename": "gcc/jump.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -927,7 +927,7 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t     INSN is the conditional branch around the arithmetic.  We set:\n \n \t     TEMP is the arithmetic insn.\n-\t     TEMP1 is the SET doing the arthmetic.\n+\t     TEMP1 is the SET doing the arithmetic.\n \t     TEMP2 is the operand being incremented or decremented.\n \t     TEMP3 to the condition being tested.\n \t     TEMP4 to the earliest insn used to find the condition.  */\n@@ -1109,7 +1109,7 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \n \t     It is questionable whether we want this optimization anyways,\n \t     since if the user wrote code like this because he/she knew that\n-\t     the jump to label1 is taken most of the time, then rewritting\n+\t     the jump to label1 is taken most of the time, then rewriting\n \t     this gives slower code.  */\n \t  /* @@ This should call get_condition to find the values being\n \t     compared, instead of looking for a COMPARE insn when HAVE_cc0\n@@ -2123,7 +2123,7 @@ get_label_before (insn)\n     {\n       rtx prev = PREV_INSN (insn);\n \n-      /* Don't put a label between a CALL_INSN and USE insns that preceed\n+      /* Don't put a label between a CALL_INSN and USE insns that precede\n \t it.  */\n \n       if (GET_CODE (insn) == CALL_INSN\n@@ -3266,7 +3266,7 @@ redirect_exp (loc, olabel, nlabel, insn)\n \n    If the old jump target label (before the dispatch table) becomes unused,\n    it and the dispatch table may be deleted.  In that case, find the insn\n-   before the jump references that label and delete it and logical sucessors\n+   before the jump references that label and delete it and logical successors\n    too.  */\n \n void\n@@ -3792,7 +3792,7 @@ rtx_equal_for_thread_p (x, y, yinsn)\n       break;\n \n     case MEM:\n-      /* If memory modified or either volatile, not eqivalent.\n+      /* If memory modified or either volatile, not equivalent.\n \t Else, check address. */\n       if (modified_mem || MEM_VOLATILE_P (x) || MEM_VOLATILE_P (y))\n \treturn 0;"}, {"sha": "72e7f5122dc5755cfff614c4c3c9d81a5900b549", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -369,7 +369,7 @@ local_alloc ()\n \n   /* This sets the maximum number of quantities we can have.  Quantity\n      numbers start at zero and we can have one for each pseudo plus the\n-     number of SCRATCHs in the largest block, in the worst case.  */\n+     number of SCRATCHes in the largest block, in the worst case.  */\n   max_qty = (max_regno - FIRST_PSEUDO_REGISTER) + max_scratch;\n \n   /* Allocate vectors of temporary data.\n@@ -1114,7 +1114,7 @@ block_alloc (b)\n \n \t      if (GET_CODE (r0) == REG || GET_CODE (r0) == SUBREG)\n \t\t{\n-\t\t  /* We have two priorities for hard register preferrences.\n+\t\t  /* We have two priorities for hard register preferences.\n \t\t     If we have a move insn or an insn whose first input can\n \t\t     only be in the same register as the output, give\n \t\t     priority to an equivalence found from that insn.  */\n@@ -1372,8 +1372,8 @@ block_alloc (b)\n \f\n /* Compare two quantities' priority for getting real registers.\n    We give shorter-lived quantities higher priority.\n-   Quantities with more references are also preferred, as are quanties that\n-   require multiple registers.  This is the identical prioritorization as\n+   Quantities with more references are also preferred, as are quantities that\n+   require multiple registers.  This is the identical prioritization as\n    done by global-alloc.\n \n    We used to give preference to registers with *longer* lives, but using\n@@ -1462,7 +1462,7 @@ combine_regs (usedreg, setreg, may_save_copy, insn_number, insn, already_dead)\n   register int sqty;\n \n   /* Determine the numbers and sizes of registers being used.  If a subreg\n-     is present that does not change the entire register, don't conside\n+     is present that does not change the entire register, don't consider\n      this a copy insn.  */\n \n   while (GET_CODE (usedreg) == SUBREG)"}, {"sha": "f57b4c9a187f6967f9b2835d03557cdbcb397142", "filename": "gcc/loop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -121,7 +121,7 @@ struct iv_class {\n   rtx initial_value;\t\t/* Value of reg at loop start */\n   rtx initial_test;\t\t/* Test performed on BIV before loop */\n   struct iv_class *next;\t/* Links all class structures together */\n-  rtx init_insn;\t\t/* insn which intializes biv, 0 if none. */\n+  rtx init_insn;\t\t/* insn which initializes biv, 0 if none. */\n   rtx init_set;\t\t\t/* SET of INIT_INSN, if any. */\n   unsigned incremented : 1;\t/* 1 if somewhere incremented/decremented */\n   unsigned eliminable : 1;\t/* 1 if plausible candidate for elimination. */"}, {"sha": "3ec2bcad18a6733c424003b802130c37e84b6cf8", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -2668,7 +2668,7 @@ expand_fix (to, from, unsignedp)\n      one plus the highest signed number, convert, and add it back.\n \n      We only need to check all real modes, since we know we didn't find\n-     anything with a wider inetger mode.  */\n+     anything with a wider integer mode.  */\n \n   if (unsignedp && GET_MODE_BITSIZE (GET_MODE (to)) <= HOST_BITS_PER_INT)\n     for (fmode = GET_MODE (from); fmode != VOIDmode;"}, {"sha": "edeae33896a4de2e492894fbc5ac7e8e83cbd425", "filename": "gcc/protoize.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fprotoize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fprotoize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprotoize.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -423,12 +423,12 @@ struct def_dec_info_struct {\n #ifndef UNPROTOIZE\n   const f_list_chain_item * f_list_chain;\t/* -> chain of formals lists */\n   const def_dec_info *\tdefinition;\t/* -> def/dec containing related def */\n-  char\t        \tis_static;\t/* = 0 means visiblilty is \"extern\"  */\n+  char\t        \tis_static;\t/* = 0 means visibility is \"extern\"  */\n   char\t\t\tis_implicit;\t/* != 0 for implicit func decl's */\n   char\t\t\twritten;\t/* != 0 means written for implicit */\n #else /* !defined (UNPROTOIZE) */\n   const char *\t\tformal_names;\t/* -> to list of names of formals */\n-  const char *\t\tformal_decls;\t/* -> to string of formal declartions */\n+  const char *\t\tformal_decls;\t/* -> to string of formal declarations */\n #endif /* !defined (UNPROTOIZE) */\n };\n \n@@ -701,7 +701,7 @@ dupnstr (s, n)\n   return ret_val;\n }\n \n-/* Return a pointer to the first occurance of s2 within s1 or NULL if s2\n+/* Return a pointer to the first occurrence of s2 within s1 or NULL if s2\n    does not occur within s1.  Assume neither s1 nor s2 are null pointers.  */\n \n static const char *\n@@ -829,7 +829,7 @@ file_could_be_converted (const char *path)\n    convert and for which we don't issue the usual warnings.  */\n \n static int\n-file_normally_convertable (const char *path)\n+file_normally_convertible (const char *path)\n {\n   char *const dir_name = alloca (strlen (path) + 1);\n \n@@ -3060,7 +3060,7 @@ edit_fn_declaration (def_dec_p, clean_text_p)\n          identifier we just found.  We ignore whitespace while hunting.  If\n          the next non-whitespace byte we see is *not* an open left paren,\n          then we must assume that we have been fooled and we start over\n-         again accordingly.  Note that there is no guarrantee, that even if\n+         again accordingly.  Note that there is no guarantee, that even if\n          we do see the open paren, that we are in the right place.\n          Programmers do the strangest things sometimes!  */\n     \n@@ -4363,7 +4363,7 @@ do_processing ()\n #endif /* !defined (UNPROTOIZE) */\n \n   /* When we first read in all of the information from the aux_info files\n-     we saved in it decending line number order, because that was likely to\n+     we saved in it descending line number order, because that was likely to\n      be faster.  Now however, we want the chains of def & dec records to\n      appear in ascending line number order as we get further away from the\n      file_info record that they hang from.  The following line causes all of"}, {"sha": "94c4eca74a69a25e98ed86812ae8847559de0184", "filename": "gcc/recog.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -389,7 +389,7 @@ validate_replace_rtx_1 (loc, from, to, object)\n \t of the operand.  If we are replacing the operand with a VOIDmode\n \t constant, we lose the information.  So try to simplify the operation\n \t in that case.  If it fails, substitute in something that we know\n-\t won't be recogized.  */\n+\t won't be recognized.  */\n       if (GET_MODE (to) == VOIDmode\n \t  && (XEXP (x, 0) == from\n \t      || (GET_CODE (XEXP (x, 0)) == REG && GET_CODE (from) == REG\n@@ -465,7 +465,7 @@ validate_replace_rtx_1 (loc, from, to, object)\n \t    wanted_mode = insn_operand_mode[(int) CODE_FOR_extv][1];\n #endif\n \n-\t  /* If we have a narrower mode, we can do someting.  */\n+\t  /* If we have a narrower mode, we can do something.  */\n \t  if (wanted_mode != VOIDmode\n \t      && GET_MODE_SIZE (wanted_mode) < GET_MODE_SIZE (is_mode))\n \t    {\n@@ -745,7 +745,7 @@ find_single_use (dest, insn, ploc)\n    The main use of this function is as a predicate in match_operand\n    expressions in the machine description.\n \n-   For an explaination of this function's behavior for registers of\n+   For an explanation of this function's behavior for registers of\n    class NO_REGS, see the comment for `register_operand'.  */\n \n int"}, {"sha": "3f40732e079831678875122213e93df33484422a", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -1266,7 +1266,7 @@ find_blocks (first)\n   if (block + 1 != blocks)\n     abort ();\n \n-  /* generate all label references to the correspondending jump insn */\n+  /* generate all label references to the corresponding jump insn */\n   for (block = 0; block < blocks; block++)\n     {\n       insn = block_end[block];\n@@ -2038,12 +2038,12 @@ subst_stack_regs_pat (insn, regstack, pat)\n \f\n /* Substitute hard regnums for any stack regs in INSN, which has\n    N_INPUTS inputs and N_OUTPUTS outputs.  REGSTACK is the stack info\n-   before the insn, and is updated with changes made here.  CONSTAINTS is\n+   before the insn, and is updated with changes made here.  CONSTRAINTS is\n    an array of the constraint strings used in the asm statement.\n \n    OPERANDS is an array of the operands, and OPERANDS_LOC is a\n    parallel array of where the operands were found.  The output operands\n-   all preceed the input operands.\n+   all precede the input operands.\n \n    There are several requirements and assumptions about the use of\n    stack-like regs in asm statements.  These rules are enforced by"}, {"sha": "eda799c6406b7145e4e150785dae16c49dd76d4c", "filename": "gcc/regclass.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -359,7 +359,7 @@ static struct savings *savings;\n static char *prefclass;\n \n /* preferred_or_nothing[R] is nonzero if we should put pseudo number R\n-   in memory if we can't get its perferred class.\n+   in memory if we can't get its preferred class.\n    This is available after `regclass' is run.  */\n \n static char *preferred_or_nothing;"}, {"sha": "2095b0069c045dfa072020a518b97e6dfb10ce8b", "filename": "gcc/reload.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -1076,7 +1076,7 @@ combine_reloads ()\n   if (reload_in[output_reload] != 0)\n     return;\n \n-  /* If this reload is for an earlyclobber operand, we can't do anyting.  */\n+  /* If this reload is for an earlyclobber operand, we can't do anything.  */\n \n   for (i = 0; i < n_earlyclobbers; i++)\n     if (reload_out[output_reload] == reload_earlyclobbers[i])\n@@ -2026,7 +2026,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      RTX_UNCHANGING_P (recog_operand[i])\n \t\t= RTX_UNCHANGING_P (regno_reg_rtx[regno]);\n \t      find_reloads_address (GET_MODE (recog_operand[i]),\n-\t\t\t\t    recog_operand_loc[i],\n+\t      /* This is no longer a pseudo register.  To prevent later code\n \t\t\t\t    XEXP (recog_operand[i], 0),\n \t\t\t\t    &XEXP (recog_operand[i], 0),\n \t\t\t\t    recog_operand[i], ind_levels);\n@@ -3144,7 +3144,7 @@ alternative_allows_memconst (constraint, altnum)\n /* Scan X for memory references and scan the addresses for reloading.\n    Also checks for references to \"constant\" regs that we want to eliminate\n    and replaces them with the values they stand for.\n-   We may alter X descructively if it contains a reference to such.\n+   We may alter X destructively if it contains a reference to such.\n    If X is just a constant reg, we return the equivalent value\n    instead of X.\n "}, {"sha": "8a719d58def55d57cc11101db25246ae9cded4f7", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -2646,7 +2646,7 @@ eliminate_regs (x, mem_mode, insn)\n \t    if (ep->to_rtx == SET_DEST (x)\n \t\t&& SET_DEST (x) != frame_pointer_rtx)\n \t      {\n-\t\t/* If it is being incrememented, adjust the offset.  Otherwise,\n+\t\t/* If it is being incremented, adjust the offset.  Otherwise,\n \t\t   this elimination can't be done.  */\n \t\trtx src = SET_SRC (x);\n "}, {"sha": "ff8c24cbbc921e2eedda22aff7cac749100a236c", "filename": "gcc/reorg.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -30,7 +30,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    optimization.  It should be the last pass to run before peephole.\n    It serves primarily to fill delay slots of insns, typically branch\n    and call insns.  Other insns typically involve more complicated\n-   interractions of data dependencies and resource constraints, and\n+   interactions of data dependencies and resource constraints, and\n    are better handled by scheduling before register allocation (by the\n    function `schedule_insns').\n \n@@ -176,7 +176,7 @@ static struct resources end_of_function_needs;\n /* Points to the label before the end of the function.  */\n static rtx end_of_function_label;\n \n-/* This structure is used to record livness information at the targets or\n+/* This structure is used to record liveness information at the targets or\n    fallthrough insns of branches.  We will most likely need the information\n    at targets again, so save them in a hash table rather than recomputing them\n    each time.  */\n@@ -371,7 +371,7 @@ mark_referenced_resources (x, res, include_called_routine)\n \t    }\n \t}\n \n-      /* ... fall through to other INSN procesing ... */\n+      /* ... fall through to other INSN processing ... */\n \n     case INSN:\n     case JUMP_INSN:\n@@ -403,7 +403,7 @@ mark_referenced_resources (x, res, include_called_routine)\n \n    We never mark the insn as modifying the condition code unless it explicitly\n    SETs CC0 even though this is not totally correct.  The reason for this is\n-   that we require a SET of CC0 to immediately preceed the reference to CC0.\n+   that we require a SET of CC0 to immediately precede the reference to CC0.\n    So if some other insn sets CC0 as a side-effect, we know it cannot affect\n    our computation and thus may be placed in a delay slot.   */\n \n@@ -911,8 +911,8 @@ note_delay_statistics (slots_filled, index)\n \n    1.  When a conditional branch skips over only one instruction,\n        use an annulling branch and put that insn in the delay slot.\n-       Use either a branch that annulls when the condition if true or\n-       invert the test with a branch that annulls when the condition is\n+       Use either a branch that annuls when the condition if true or\n+       invert the test with a branch that annuls when the condition is\n        false.  This saves insns, since otherwise we must copy an insn\n        from the L1 target.\n \n@@ -3251,7 +3251,7 @@ relax_delay_slots (first)\n \t  /* If the last insn in the delay slot sets CC0 for some insn,\n \t     various code assumes that it is in a delay slot.  We could\n \t     put it back where it belonged and delete the register notes,\n-\t     but it doesn't seem worhwhile in this uncommon case.  */\n+\t     but it doesn't seem worthwhile in this uncommon case.  */\n \t  && ! find_reg_note (XVECEXP (pat, 0, XVECLEN (pat, 0) - 1),\n \t\t\t      REG_CC_USER, 0)\n #endif"}, {"sha": "dc9e2187a6f9bf5f17a1ebc519feceec3524e79d", "filename": "gcc/rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -128,7 +128,7 @@ enum machine_mode word_mode;\t/* Mode whose width is BITS_PER_WORD */\n \n /* Indexed by rtx code, gives a sequence of operand-types for\n    rtx's of that code.  The sequence is a C string in which\n-   each charcter describes one operand.  */\n+   each character describes one operand.  */\n \n char *rtx_format[] = {\n   /* \"*\" undefined."}, {"sha": "86f866190b34fb666d897eff70314e1cc8416925", "filename": "gcc/rtl.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -81,7 +81,7 @@ DEF_RTL_EXPR(EXPR_LIST, \"expr_list\", \"ee\", 'x')\n DEF_RTL_EXPR(INSN_LIST, \"insn_list\", \"ue\", 'x')\n \n /* ----------------------------------------------------------------------\n-   Expression types for machine descripions.\n+   Expression types for machine descriptions.\n    These do not appear in actual rtl code in the compiler.\n    ---------------------------------------------------------------------- */\n \n@@ -408,7 +408,7 @@ DEF_RTL_EXPR(ASM_OPERANDS, \"asm_operands\", \"ssiEEsi\", 'x')\n    or inside an expression.  */\n DEF_RTL_EXPR(UNSPEC, \"unspec\", \"Ei\", 'x')\n \n-/* Similiar, but a volatile operation and one which may trap.  */\n+/* Similar, but a volatile operation and one which may trap.  */\n DEF_RTL_EXPR(UNSPEC_VOLATILE, \"unspec_volatile\", \"Ei\", 'x')\n \n /* Vector of addresses, stored as full words.  */"}, {"sha": "e649a8dc506cfb838d0b159d76d5ac76e1924371", "filename": "gcc/rtl.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -32,9 +32,9 @@ enum rtx_code  {\n #include \"rtl.def\"\t\t/* rtl expressions are documented here */\n #undef DEF_RTL_EXPR\n \n-  LAST_AND_UNUSED_RTX_CODE};\t/* A convienent way to get a value for\n+  LAST_AND_UNUSED_RTX_CODE};\t/* A convenient way to get a value for\n \t\t\t\t   NUM_RTX_CODE.\n-\t\t\t\t   Assumes default enum value assignement.  */\n+\t\t\t\t   Assumes default enum value assignment.  */\n \n #define NUM_RTX_CODE ((int)LAST_AND_UNUSED_RTX_CODE)\n \t\t\t\t/* The cast here, saves many elsewhere.  */\n@@ -219,7 +219,7 @@ typedef struct rtvec_def{\n #define INSN_ANNULLED_BRANCH_P(INSN) ((INSN)->unchanging)\n \n /* 1 if insn is in a delay slot and is from the target of the branch.  If\n-   the branch insn has INSN_ANULLED_BRANCH_P set, this insn should only be\n+   the branch insn has INSN_ANNULLED_BRANCH_P set, this insn should only be\n    executed if the branch is taken.  For annulled branches with this bit\n    clear, the insn should be executed only if the branch is not taken.  */\n #define INSN_FROM_TARGET_P(INSN) ((INSN)->in_struct)"}, {"sha": "819008a7d9355f4c94181c37a2ed55305bb09445", "filename": "gcc/sched.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -173,7 +173,7 @@ static regset bb_live_regs;\n \n /* Regset telling whether a given register is live after the insn currently\n    being scheduled.  Before processing an insn, this is equal to bb_live_regs\n-   above.  This is used so that we can find regsiters that are newly born/dead\n+   above.  This is used so that we can find registers that are newly born/dead\n    after processing an insn.  */\n static regset old_live_regs;\n \n@@ -442,7 +442,7 @@ find_symbolic_term (x)\n \t    with addresses involving static variables.\n \t(2) static variables with different addresses cannot conflict.\n \n-   Nice to notice that varying addresses cannot confict with fp if no\n+   Nice to notice that varying addresses cannot conflict with fp if no\n    local variables had their addresses taken, but that's too hard now.  */\n \n static int\n@@ -503,15 +503,15 @@ memrefs_conflict_p (xsize, x, ysize, y, c)\n \n   if (GET_CODE (x) == PLUS)\n     {\n-      /* The fact that X is canonnicallized means that this\n-\t PLUS rtx is canonnicallized.  */\n+      /* The fact that X is canonicalized means that this\n+\t PLUS rtx is canonicalized.  */\n       rtx x0 = XEXP (x, 0);\n       rtx x1 = XEXP (x, 1);\n \n       if (GET_CODE (y) == PLUS)\n \t{\n-\t  /* The fact that Y is canonnicallized means that this\n-\t     PLUS rtx is canonnicallized.  */\n+\t  /* The fact that Y is canonicalized means that this\n+\t     PLUS rtx is canonicalized.  */\n \t  rtx y0 = XEXP (y, 0);\n \t  rtx y1 = XEXP (y, 1);\n \n@@ -543,8 +543,8 @@ memrefs_conflict_p (xsize, x, ysize, y, c)\n     }\n   else if (GET_CODE (y) == PLUS)\n     {\n-      /* The fact that Y is canonnicallized means that this\n-\t PLUS rtx is canonnicallized.  */\n+      /* The fact that Y is canonicalized means that this\n+\t PLUS rtx is canonicalized.  */\n       rtx y0 = XEXP (y, 0);\n       rtx y1 = XEXP (y, 1);\n \n@@ -1238,7 +1238,7 @@ sched_analyze_1 (x, insn)\n \t  /* Flush all pending reads and writes to prevent the pending lists\n \t     from getting any larger.  Insn scheduling runs too slowly when\n \t     these lists get long.  The number 32 was chosen because it\n-\t     seems like a resonable number.  When compiling GCC with itself,\n+\t     seems like a reasonable number.  When compiling GCC with itself,\n \t     this flush occurs 8 times for sparc, and 10 times for m88k using\n \t     the number 32.  */\n \t  flush_pending_lists (insn);\n@@ -3125,7 +3125,7 @@ schedule_block (b, file)\n \t    prev = PREV_INSN (insn);\n \t    if (LINE_NOTE (note))\n \t      {\n-\t\t/* Re-use the orignal line-number note. */\n+\t\t/* Re-use the original line-number note. */\n \t\tLINE_NOTE (note) = 0;\n \t\tPREV_INSN (note) = prev;\n \t\tNEXT_INSN (prev) = note;\n@@ -3414,7 +3414,7 @@ update_flow_info (notes, first, last, orig_insn)\n \n \t\t  /* Sometimes need to convert REG_UNUSED notes to REG_DEAD\n \t\t     notes.  */\n-\t\t  /* ??? This won't handle mutiple word registers correctly,\n+\t\t  /* ??? This won't handle multiple word registers correctly,\n \t\t     but should be good enough for now.  */\n \t\t  if (REG_NOTE_KIND (note) == REG_UNUSED\n \t\t      && ! dead_or_set_p (insn, XEXP (note, 0)))"}, {"sha": "4f6c4e599667d4b4915d0e8fd70a6458200eae4b", "filename": "gcc/sdbout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -34,7 +34,7 @@ AT&T C compiler.  From the example below I would conclude the following:\n 4. All structure .defs are emitted before the typedefs that refer to them.\n \n 5. All top level static and external variable definitions are moved to the\n-   end of file with all top level statics occuring first before externs.\n+   end of file with all top level statics occurring first before externs.\n \n 6. All undefined references are at the end of the file.\n */"}, {"sha": "a1a2267c5e36b6a9309e55e6cb2b0dc4da564566", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -3966,7 +3966,7 @@ group_case_nodes (head)\n \n /* Take an ordered list of case nodes\n    and transform them into a near optimal binary tree,\n-   on the assumtion that any target code selection value is as\n+   on the assumption that any target code selection value is as\n    likely as any other.\n \n    The transformation is performed by splitting the ordered"}, {"sha": "9a724283ab3329a445366482d1a8c0c7791478a5", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -1741,7 +1741,7 @@ compile_file (name)\n \t  TIMEVAR (symout_time, sdbout_toplevel_data (decl));\n #endif /* SDB_DEBUGGING_INFO */\n #ifdef DWARF_DEBUGGING_INFO\n-\t/* Output DWARF information for file-scope tenative data object\n+\t/* Output DWARF information for file-scope tentative data object\n \t   declarations, file-scope (extern) function declarations (which\n \t   had no corresponding body) and file-scope tagged type declarations\n \t   and definitions which have not yet been forced out.  */"}, {"sha": "544a6a0af74cc655f8f9599e9166ee47e182b8a5", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -26,7 +26,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n enum tree_code {\n #include \"tree.def\"\n \n-  LAST_AND_UNUSED_TREE_CODE\t/* A convienent way to get a value for\n+  LAST_AND_UNUSED_TREE_CODE\t/* A convenient way to get a value for\n \t\t\t\t   NUM_TREE_CODE.  */\n };\n \n@@ -225,7 +225,7 @@ struct tree_common\n /* In a VAR_DECL or FUNCTION_DECL,\n    nonzero means name is to be accessible from outside this module.\n    In an identifier node, nonzero means a external declaration\n-   accesible from outside this module was previously seen\n+   accessible from outside this module was previously seen\n    for this name in an inner scope.  */\n #define TREE_PUBLIC(NODE) ((NODE)->common.public_flag)\n "}, {"sha": "8a0b09aa62ddd390ea151dcc8764e371bd189ef0", "filename": "gcc/unroll.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -59,7 +59,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n    - On traditional architectures, unrolling a non-constant bound loop\n      is a win if there is a giv whose only use is in memory addresses, the\n-     memory addresses can be split, and hence giv incremenets can be\n+     memory addresses can be split, and hence giv increments can be\n      eliminated.\n    - It is also a win if the loop is executed many times, and preconditioning\n      can be performed for the loop.\n@@ -205,7 +205,7 @@ static rtx fold_rtx_mult_add ();\n /* Try to unroll one loop and split induction variables in the loop.\n \n    The loop is described by the arguments LOOP_END, INSN_COUNT, and\n-   LOOP_START.  END_INSERT_BEDFORE indicates where insns should be added\n+   LOOP_START.  END_INSERT_BEFORE indicates where insns should be added\n    which need to be executed when the loop falls through.  STRENGTH_REDUCTION_P\n    indicates whether information generated in the strength reduction pass\n    is available.\n@@ -688,7 +688,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \n      It is safe to do this here, since the extra registers created by the\n      preconditioning code and find_splittable_regs will never be used\n-     to accees the splittable_regs[] and addr_combined_regs[] arrays.  */\n+     to access the splittable_regs[] and addr_combined_regs[] arrays.  */\n \n   splittable_regs = (rtx *) alloca (maxregnum * sizeof (rtx));\n   bzero (splittable_regs, maxregnum * sizeof (rtx));\n@@ -1138,7 +1138,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n   if (exit_label)\n     emit_label_after (exit_label, loop_end);\n \n-  /* If debugging, we must replicate the tree nodes corresponsing to the blocks\n+  /* If debugging, we must replicate the tree nodes corresponding to the blocks\n      inside the loop, so that the original one to one mapping will remain.  */\n \n   if (write_symbols != NO_DEBUG)\n@@ -1230,7 +1230,7 @@ precondition_loop_p (initial_value, final_value, increment, loop_start,\n \n   /* Must ensure that final_value is invariant, so call invariant_p to\n      check.  Before doing so, must check regno against max_reg_before_loop\n-     to make sure that the register is in the range convered by invariant_p.\n+     to make sure that the register is in the range covered by invariant_p.\n      If it isn't, then it is most likely a biv/giv which by definition are\n      not invariant.  */\n   if ((GET_CODE (loop_final_value) == REG\n@@ -1883,7 +1883,7 @@ emit_unrolled_add (dest_reg, src_reg, increment)\n    is a backward branch in that range that branches to somewhere between\n    LOOP_START and INSN.  Returns 0 otherwise.  */\n \n-/* ??? This is quadratic algorithm.  Could be rewriten to be linear.\n+/* ??? This is quadratic algorithm.  Could be rewritten to be linear.\n    In practice, this is not a problem, because this function is seldom called,\n    and uses a negligible amount of CPU time on average.  */\n \n@@ -2926,7 +2926,7 @@ final_giv_value (v, loop_start, loop_end)\n \n \n /* Calculate the number of loop iterations.  Returns the exact number of loop\n-   iterations if it can be calculated, otherwise retusns zero.  */\n+   iterations if it can be calculated, otherwise returns zero.  */\n \n unsigned long\n loop_iterations (loop_start, loop_end)\n@@ -3069,7 +3069,7 @@ loop_iterations (loop_start, loop_end)\n      be addresses with the same base but different constant offsets.\n      Final value must be invariant for this to work.\n \n-     To do this, need someway to find the values of registers which are\n+     To do this, need some way to find the values of registers which are\n      invariant.  */\n \n   /* Final_larger is 1 if final larger, 0 if they are equal, otherwise -1.  */"}, {"sha": "4ddbff78ab6b0c86eaf93f6022ed092a875b1ca4", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -909,7 +909,7 @@ assemble_variable (decl, top_level, at_end)\n      declaration.  When something like \".stabx  \"aa:S-2\",aa,133,0\" is emitted \n      and `aa' hasn't been output yet, the assembler generates a stab entry with\n      a value of zero, in addition to creating an unnecessary external entry\n-     for `aa'.  Hence, we must pospone dbxout_symbol to here at the end.  */\n+     for `aa'.  Hence, we must postpone dbxout_symbol to here at the end.  */\n \n   /* File-scope global variables are output here.  */\n   if (write_symbols == XCOFF_DEBUG && top_level)"}, {"sha": "bdee41c9ec8ea2cd46b182f7dd2eb24b5e142352", "filename": "gcc/xcoffout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fxcoffout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc42e49d3dac756ec72e10f3bf7687f9c8542c2/gcc%2Fxcoffout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fxcoffout.c?ref=6dc42e49d3dac756ec72e10f3bf7687f9c8542c2", "patch": "@@ -433,7 +433,7 @@ xcoffout_end_epilogue (file)\n   /* We need to pass the correct function size to .function, otherwise,\n      the xas assembler can't figure out the correct size for the function\n      aux entry.  So, we emit a label after the last instruction which can\n-     be used by the .function psuedo op to calculate the function size.  */\n+     be used by the .function pseudo op to calculate the function size.  */\n \n   char *fname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n   if (*fname == '*')"}]}