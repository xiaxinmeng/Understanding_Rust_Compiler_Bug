{"sha": "c4facd483de2d5b6b4d20e6ad74c85b9f1eba41a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzRmYWNkNDgzZGUyZDViNmI0ZDIwZTZhZDc0Yzg1YjlmMWViYTQxYQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-07-13T10:41:35Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-07-13T14:50:07Z"}, "message": "tree-optimization/96163 - fix placement issue with SLP and vectors\n\nThis avoids placing stmts beyond the vectorizer region begin which\nconfuses vect_stmt_dominates_stmt_p.\n\n2020-07-13  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/96163\n\t* tree-vect-slp.c (vect_schedule_slp_instance): Put new stmts\n\tat least after region begin.\n\n\t* g++.dg/vect/pr96163.cc: New testcase.", "tree": {"sha": "d9564084235d366de34a17778253c12dbed0e6bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9564084235d366de34a17778253c12dbed0e6bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4facd483de2d5b6b4d20e6ad74c85b9f1eba41a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4facd483de2d5b6b4d20e6ad74c85b9f1eba41a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4facd483de2d5b6b4d20e6ad74c85b9f1eba41a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4facd483de2d5b6b4d20e6ad74c85b9f1eba41a/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f069011019c9df670969ea283fd4d139f34a925", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f069011019c9df670969ea283fd4d139f34a925", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f069011019c9df670969ea283fd4d139f34a925"}], "stats": {"total": 178, "additions": 166, "deletions": 12}, "files": [{"sha": "3bd376f67f683325a001d14ddad27b5a0c09a891", "filename": "gcc/testsuite/g++.dg/vect/pr96163.cc", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4facd483de2d5b6b4d20e6ad74c85b9f1eba41a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr96163.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4facd483de2d5b6b4d20e6ad74c85b9f1eba41a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr96163.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr96163.cc?ref=c4facd483de2d5b6b4d20e6ad74c85b9f1eba41a", "patch": "@@ -0,0 +1,146 @@\n+// { dg-do compile }\n+// { dg-require-effective-target c++17 }\n+\n+typedef double b __attribute__((__vector_size__(16)));\n+b c;\n+enum { d };\n+namespace e {\n+template <typename> struct g;\n+struct h {\n+  enum { i, j };\n+};\n+template <typename> struct aa;\n+} // namespace e\n+template <typename> struct k;\n+template <typename> class l;\n+template <typename, int = e::h::j> class ab;\n+template <typename, int m, int n, int = 0, int = m, int = n> class o;\n+template <typename> class ac;\n+class p;\n+namespace e {\n+template <typename> struct q { typedef ac<o<double, 2, 1>> ae; };\n+struct s {\n+  template <int, typename t> void af(double *ak, t) { *(b *)ak = c; }\n+};\n+} // namespace e\n+template <typename ad> class ab<ad, d> : public k<ad> {};\n+template <typename ad> class ab<ad> : public ab<ad, d> {\n+public:\n+  typedef typename e::g<ad>::ag ag;\n+  using ab<ad, d>::ah;\n+  ag ai() {\n+    long aj = 0;\n+    return e::aa(ah()).ai(aj);\n+  }\n+  ag operator[](long) { return ai(); }\n+};\n+template <typename ad> class ay : public ab<ad> {\n+public:\n+  enum { a, al };\n+};\n+template <typename ad> class ac : public ay<ad> {\n+public:\n+  p am();\n+};\n+template <typename> struct k {\n+  o<double, 2, 1> &ah() { return *static_cast<o<double, 2, 1> *>(this); }\n+};\n+namespace e {\n+template <typename f> struct aa { aa(f); };\n+template <typename ad> struct aa<l<ad>> {\n+  typedef ad ao;\n+  typedef typename ao::ag ag;\n+  aa(ao &ak) : ap(ak.aq()) {}\n+  ag &ai(long ak) { return ap[ak]; }\n+  ag *ap;\n+};\n+template <typename ag, int ar, int as, int at, int au, int av>\n+struct aa<o<ag, ar, as, at, au, av>> : aa<l<o<ag, ar, as>>> {\n+  typedef o<ag, ar, as> aw;\n+  aa(aw &ak) : aa<l<aw>>(ak) {}\n+};\n+template <typename ax> struct u {\n+  enum { az, ba, bb };\n+  static void bc(ax ak) { ak.template be<bb, d, typename ax::bf>(az, ba); }\n+};\n+template <typename ax> struct v {\n+  static void bc(ax ak) { u<ax>::bc(ak); }\n+};\n+template <typename bg, typename bh> class w {\n+  typedef bg bi;\n+\n+public:\n+  typedef bg bj;\n+  typedef bg bf;\n+  w(bj ak, int, bh, bi x) : bk(ak), bl(x) {}\n+  template <int bm, int, typename> void be(long, long) {\n+    bn.template af<bm>(&bk.ai(0), 0);\n+  }\n+  bj bk;\n+  bh bn;\n+  bi bl;\n+};\n+template <typename bi, typename bo, typename bh> void bp(bi &ak, bo, bh bq) {\n+  typedef aa<bi> bj;\n+  bo br;\n+  bj bs(ak);\n+  typedef w<bj, bh> ax;\n+  ax bd(bs, br, bq, ak);\n+  v<ax>::bc(bd);\n+}\n+template <typename> struct bt;\n+template <typename bu, typename bv, typename bw> void bx(bu &ak, bv by, bw bq) {\n+  bt<bw>::bc(ak, by, bq);\n+}\n+template <typename> struct bt {\n+  static void bc(o<double, 2, 1> &ak, int by, s bq) { bp(ak, by, bq); }\n+};\n+} // namespace e\n+class bz {\n+public:\n+  template <typename an> void operator*(an);\n+};\n+namespace e {\n+template <int ca> struct cb { double am[ca]; };\n+} // namespace e\n+template <int ca> class cc {\n+  e::cb<ca> ap;\n+\n+public:\n+  double *aq() { return ap.am; }\n+};\n+template <typename ad> class l : public e::q<ad>::ae {\n+public:\n+  typedef typename e::q<ad>::ae cd;\n+  typedef typename e::g<ad>::ag ag;\n+  cc<cd::al> ce;\n+  ag *aq() { return ce.aq(); }\n+  l() {}\n+  template <typename an> l(an ak) { bx(this->ah(), ak, e::s()); }\n+  template <typename cf, typename cg> void ch(cf, cg by) {\n+    ag *z, *y;\n+    { z = aq(); }\n+    y = z;\n+    y[0] = aq()[1] = by;\n+  }\n+};\n+namespace e {\n+template <typename ci, int m, int n, int cj, int ck, int cl>\n+struct g<o<ci, m, n, cj, ck, cl>> {\n+  typedef ci ag;\n+};\n+} // namespace e\n+template <typename, int m, int n, int, int, int>\n+class o : public l<o<double, m, n>> {\n+public:\n+  typedef l<o> cd;\n+  template <typename cf, typename cg> o(cf ak, cg by) { cd::ch(ak, by); }\n+  template <typename an> o(an ak) : cd(ak) {}\n+};\n+class p : public bz {};\n+double cq;\n+void cm() {\n+  o<double, 2, 1> r = 0;\n+  o cn = r;\n+  cn.am() * o<double, 2, 1>(0, r[0] / cq).am();\n+}"}, {"sha": "72192b5a8136841a49bde812a449c9da8c975843", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4facd483de2d5b6b4d20e6ad74c85b9f1eba41a/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4facd483de2d5b6b4d20e6ad74c85b9f1eba41a/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=c4facd483de2d5b6b4d20e6ad74c85b9f1eba41a", "patch": "@@ -4404,18 +4404,26 @@ vect_schedule_slp_instance (vec_info *vinfo,\n \telse\n \t  {\n \t    /* For externals we have to look at all defs since their\n-\t       insertion place is decided per vector.  */\n-\t    unsigned j;\n-\t    tree vdef;\n-\t    FOR_EACH_VEC_ELT (SLP_TREE_VEC_DEFS (child), j, vdef)\n-\t      if (TREE_CODE (vdef) == SSA_NAME\n-\t\t  && !SSA_NAME_IS_DEFAULT_DEF (vdef))\n-\t\t{\n-\t\t  gimple *vstmt = SSA_NAME_DEF_STMT (vdef);\n-\t\t  if (!last_stmt\n-\t\t      || vect_stmt_dominates_stmt_p (last_stmt, vstmt))\n-\t\t    last_stmt = vstmt;\n-\t\t}\n+\t       insertion place is decided per vector.  But beware\n+\t       of pre-existing vectors where we need to make sure\n+\t       we do not insert before the region boundary.  */\n+\t    if (SLP_TREE_SCALAR_OPS (child).is_empty ()\n+\t\t&& !vinfo->lookup_def (SLP_TREE_VEC_DEFS (child)[0]))\n+\t      last_stmt = gsi_stmt (as_a <bb_vec_info> (vinfo)->region_begin);\n+\t    else\n+\t      {\n+\t\tunsigned j;\n+\t\ttree vdef;\n+\t\tFOR_EACH_VEC_ELT (SLP_TREE_VEC_DEFS (child), j, vdef)\n+\t\t  if (TREE_CODE (vdef) == SSA_NAME\n+\t\t      && !SSA_NAME_IS_DEFAULT_DEF (vdef))\n+\t\t    {\n+\t\t      gimple *vstmt = SSA_NAME_DEF_STMT (vdef);\n+\t\t      if (!last_stmt\n+\t\t\t  || vect_stmt_dominates_stmt_p (last_stmt, vstmt))\n+\t\t\tlast_stmt = vstmt;\n+\t\t    }\n+\t      }\n \t  }\n       /* This can happen when all children are pre-existing vectors or\n \t constants.  */"}]}