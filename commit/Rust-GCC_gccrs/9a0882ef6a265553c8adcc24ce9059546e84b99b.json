{"sha": "9a0882ef6a265553c8adcc24ce9059546e84b99b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWEwODgyZWY2YTI2NTU1M2M4YWRjYzI0Y2U5MDU5NTQ2ZTg0Yjk5Yg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-12-17T00:15:01Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-12-17T00:15:01Z"}, "message": "Add an alternative splay tree implementation\n\nWe already have two splay tree implementations: the old C one in\nlibiberty and a templated reimplementation of it in typed-splay-tree.h.\nHowever, they have some drawbacks:\n\n- They hard-code the assumption that nodes should have both a key and\n  a value, which isn't always true.\n\n- They use the two-phase method of lookup, and so nodes need to store\n  a temporary back pointer.  We can avoid that overhead by using the\n  top-down method (as e.g. the bitmap tree code already does).\n\n- The tree node has to own the key and the value.  For some use cases\n  it's more convenient to embed the tree links in the value instead.\n\nAlso, a later patch wants to use splay trees to represent an\nadaptive total order: the splay tree itself records whether node N1\nis less than node N2, and (in the worst case) comparing nodes is\na splay operation.\n\nThis patch therefore adds an alternative implementation.  The main\nfeatures are:\n\n- Nodes can optionally point back to their parents.\n\n- An Accessors class abstracts accessing child nodes and (where\n  applicable) parent nodes, so that the information can be embedded\n  in larger data structures.\n\n- There is no fixed comparison function at the class level.  Instead,\n  individual functions that do comparisons take a comparison function\n  argument.\n\n- There are two styles of comparison function, optimised for different\n  use cases.  (See the comments in the patch for details.)\n\n- It's possible to do some operations directly on a given node,\n  without knowing whether it's the root.  This includes the comparison\n  use case described above.\n\nThis of course has its own set of drawbacks.  It's really providing\nsplay utility functions rather than a true ADT, and so is more low-level\nthan the existing routines.  It's mostly geared for cases in which the\nclient code wants to participate in the splay operations to some extent.\n\ngcc/\n\t* Makefile.in (OBJS): Add splay-tree-utils.o.\n\t* system.h: Include <array> when INCLUDE_ARRAY is defined.\n\t* selftest.h (splay_tree_cc_tests): Declare.\n\t* selftest-run-tests.c (selftest::run_tests): Run splay_tree_cc_tests.\n\t* splay-tree-utils.h: New file.\n\t* splay-tree-utils.tcc: Likewise.\n\t* splay-tree-utils.cc: Likewise.", "tree": {"sha": "c621a77459909b44c9b820e78d8adf9ace3a7dd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c621a77459909b44c9b820e78d8adf9ace3a7dd0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a0882ef6a265553c8adcc24ce9059546e84b99b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a0882ef6a265553c8adcc24ce9059546e84b99b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a0882ef6a265553c8adcc24ce9059546e84b99b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a0882ef6a265553c8adcc24ce9059546e84b99b/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac62dce5e5ff8e02682e2129e8fecc211c707551", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac62dce5e5ff8e02682e2129e8fecc211c707551", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac62dce5e5ff8e02682e2129e8fecc211c707551"}], "stats": {"total": 1721, "additions": 1721, "deletions": 0}, "files": [{"sha": "89353c28d3ff92b498e32f84e267aae89f8eff48", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0882ef6a265553c8adcc24ce9059546e84b99b/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0882ef6a265553c8adcc24ce9059546e84b99b/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=9a0882ef6a265553c8adcc24ce9059546e84b99b", "patch": "@@ -1546,6 +1546,7 @@ OBJS = \\\n \tsparseset.o \\\n \tspellcheck.o \\\n \tspellcheck-tree.o \\\n+\tsplay-tree-utils.o \\\n \tsreal.o \\\n \tstack-ptr-mod.o \\\n \tstatistics.o \\"}, {"sha": "c0c18ad17ca551faa3a22db705b446649c3e9ff4", "filename": "gcc/selftest-run-tests.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0882ef6a265553c8adcc24ce9059546e84b99b/gcc%2Fselftest-run-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0882ef6a265553c8adcc24ce9059546e84b99b/gcc%2Fselftest-run-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest-run-tests.c?ref=9a0882ef6a265553c8adcc24ce9059546e84b99b", "patch": "@@ -79,6 +79,7 @@ selftest::run_tests ()\n   optinfo_emit_json_cc_tests ();\n   opt_problem_cc_tests ();\n   ordered_hash_map_tests_cc_tests ();\n+  splay_tree_cc_tests ();\n \n   /* Mid-level data structures.  */\n   input_c_tests ();"}, {"sha": "b6e4345b19f7e0e3c0cf2a11869d8b20741b8e9a", "filename": "gcc/selftest.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0882ef6a265553c8adcc24ce9059546e84b99b/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0882ef6a265553c8adcc24ce9059546e84b99b/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=9a0882ef6a265553c8adcc24ce9059546e84b99b", "patch": "@@ -256,6 +256,7 @@ extern void selftest_c_tests ();\n extern void simplify_rtx_c_tests ();\n extern void spellcheck_c_tests ();\n extern void spellcheck_tree_c_tests ();\n+extern void splay_tree_cc_tests ();\n extern void sreal_c_tests ();\n extern void store_merging_c_tests ();\n extern void tree_c_tests ();"}, {"sha": "4b2007b8414eb8ef019314188415aabf3868aafb", "filename": "gcc/splay-tree-utils.cc", "status": "added", "additions": 264, "deletions": 0, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0882ef6a265553c8adcc24ce9059546e84b99b/gcc%2Fsplay-tree-utils.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0882ef6a265553c8adcc24ce9059546e84b99b/gcc%2Fsplay-tree-utils.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsplay-tree-utils.cc?ref=9a0882ef6a265553c8adcc24ce9059546e84b99b", "patch": "@@ -0,0 +1,264 @@\n+// Splay tree utilities                                             -*- C++ -*-\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+//\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+//\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#define INCLUDE_ALGORITHM\n+#define INCLUDE_ARRAY\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"pretty-print.h\"\n+#include \"splay-tree-utils.h\"\n+#include \"selftest.h\"\n+\n+#if CHECKING_P\n+namespace {\n+// A simple test node for rootless_splay_tree.\n+struct rootless_test_node\n+{\n+  int data;\n+  rootless_test_node *m_parent;\n+  rootless_test_node *m_children[2];\n+};\n+}\n+\n+namespace selftest {\n+\n+// Random input data.\n+static const size_t MAX_DATA = 32768;\n+static const int data[] = {\n+  1379, 14643, 30579, 28160, 31750, 22280, 5502, 4720, 30075, 27595,\n+  8395, 19410, 518, 19709, 29694, 19865, 25372, 11752, 15485, 21547,\n+  25153, 25072, 10146, 3341, 15625, 3038, 10189, 19943, 1322, 11762,\n+  807, 430, 11284, 11841, 23965, 32008, 4547, 8087, 13225, 23054,\n+  22284, 13756, 2182, 26450, 30482, 32502, 23348, 20265, 29509, 3290,\n+  10807, 1242, 3212, 32178, 25354, 22032, 30509, 16157, 22432, 1295,\n+  8348, 23342, 24678, 193, 31016, 10316, 3872, 13521, 19211, 30594,\n+  12229, 4794, 25083, 16098, 28144, 27896, 4801, 20689, 31450, 15614,\n+  19597, 13731, 30309, 24846, 11042, 31929, 18306, 28520, 16907, 12488,\n+  15001, 18487, 3438, 1706, 4829, 20892, 6226, 18204, 15776, 30717,\n+  19398, 2480, 19434, 2838, 2605, 3994, 22538, 12269, 6486, 1314,\n+  30301, 9919, 31405, 30847, 25000, 24013, 22196, 30220, 31415, 14630,\n+  26319, 4880, 21292, 20217, 20078, 14679, 25686, 28675, 13883, 14853,\n+  2872, 2428, 3636, 14131, 2952, 2133, 4470, 25808, 12576, 31395,\n+  5938, 28393, 14553, 4494, 14928, 24310, 17394, 17436, 23385, 22792,\n+  9785, 13118, 22338, 23320, 27059, 17663, 16434, 14954, 16962, 31088,\n+  22247, 22600, 7980, 1344, 15635, 13611, 32739, 3283, 12924, 17904,\n+  28216, 7542, 9212, 28308, 18873, 3912, 5473, 4666, 11900, 21420,\n+  20072, 27662, 16445, 29848, 24444, 31668, 30664, 14287, 13754, 29276,\n+  21462, 25517, 17632, 8105, 32510, 16677, 11162, 20734, 26873, 5097\n+};\n+\n+// Look up VALUE in TREE using the single-comparator lookup function.\n+static int\n+lookup1 (splay_tree<int> &tree, int value)\n+{\n+  auto compare = [&](splay_tree_node<int> *node)\n+    {\n+      return value - node->value ();\n+    };\n+  return tree.lookup (compare);\n+}\n+\n+// Look up VALUE in TREE using the double-comparator lookup function.\n+static int\n+lookup2 (splay_tree<int> &tree, int value)\n+{\n+  auto want_something_smaller = [&](splay_tree_node<int> *node)\n+    {\n+      return value < node->value ();\n+    };\n+  auto want_something_bigger = [&](splay_tree_node<int> *node)\n+    {\n+      return value > node->value ();\n+    };\n+  return tree.lookup (want_something_smaller, want_something_bigger);\n+}\n+\n+// Test printing TREE to a pretty printer.  Don't check the output against\n+// anything; just make sure that it doesn't crash.\n+static void\n+test_print (splay_tree<int> &tree)\n+{\n+  auto print_node = [](pretty_printer *pp, splay_tree_node<int> *node)\n+    {\n+      pp_decimal_int (pp, node->value ());\n+    };\n+  pretty_printer pp;\n+  tree.print (&pp, print_node);\n+}\n+\n+// Test various lookups on TREE using LOOKUP, where lookup returns the\n+// same kind of value as the rooted_splay_tree lookup functions.\n+static void\n+test_lookup (splay_tree<int> &tree, int (*lookup) (splay_tree<int> &, int))\n+{\n+  // Look up values that are known to exist.\n+  for (int value : data)\n+    ASSERT_EQ (lookup (tree, value), 0);\n+\n+  // Look up values that are 1 less than values that are known to exist.\n+  for (int value : data)\n+    {\n+      int result = lookup (tree, value - 1);\n+      if (result == 0)\n+\tASSERT_EQ (tree->value (), value - 1);\n+      else if (result < 0)\n+\t// VALUE - 1 is less than the root.\n+\tASSERT_EQ (tree->value (), value);\n+      else if (result > 0)\n+\t{\n+\t  // VALUE - 1 is greater than the root.\n+\t  ASSERT_TRUE (tree->value () < value - 1);\n+\t  if (tree.splay_next_node ())\n+\t    ASSERT_EQ (tree->value (), value);\n+\t}\n+    }\n+\n+  // Look up values that are 1 greater than values that are known to exist.\n+  for (int value : data)\n+    {\n+      int result = lookup (tree, value + 1);\n+      if (result == 0)\n+\tASSERT_EQ (tree->value (), value + 1);\n+      else if (result < 0)\n+\t{\n+\t  // VALUE + 1 is less than the root.\n+\t  ASSERT_TRUE (tree->value () > value + 1);\n+\t  if (tree.splay_prev_node ())\n+\t    ASSERT_EQ (tree->value (), value);\n+\t}\n+      else if (result > 0)\n+\t// VALUE + 1 is greater than the root.\n+\tASSERT_EQ (tree->value (), value);\n+    }\n+}\n+\n+// Run all tests for this module.\n+void\n+splay_tree_cc_tests ()\n+{\n+  obstack ob;\n+  gcc_obstack_init (&ob);\n+\n+  // Build up the splay tree.\n+  splay_tree<int> tree;\n+  for (int value : data)\n+    {\n+      auto *node = XOBNEW (&ob, splay_tree_node<int>);\n+      new (node) splay_tree_node<int> (value);\n+      auto compare = [&](splay_tree_node<int> *other_node)\n+\t{\n+\t  return value - other_node->value ();\n+\t};\n+      bool inserted = tree.insert (node, compare);\n+      ASSERT_TRUE (inserted);\n+    }\n+\n+  // Test the single-comparator lookup function.\n+  test_lookup (tree, lookup1);\n+\n+  // Sort the input data.\n+  std::array<int, ARRAY_SIZE (data)> sorted;\n+  std::copy (data, data + ARRAY_SIZE (data), sorted.begin ());\n+  std::sort (sorted.begin (), sorted.end ());\n+\n+  // Iterate over the tree in ascending order.\n+  tree.splay_min_node ();\n+  bool result = true;\n+  for (int value : sorted)\n+    {\n+      ASSERT_TRUE (result);\n+      ASSERT_EQ (tree->value (), value);\n+      result = tree.splay_next_node ();\n+    }\n+  ASSERT_FALSE (result);\n+  ASSERT_EQ (tree.min_node ()->value (), sorted.front ());\n+\n+  // Test the double-comparator lookup function.\n+  test_lookup (tree, lookup2);\n+\n+  // Test printing the tree now, while it's still bushy.\n+  test_print (tree);\n+\n+  // Iterate over the tree in descending order.\n+  tree.splay_max_node ();\n+  result = true;\n+  for (auto it = sorted.rbegin (); it != sorted.rend (); ++it)\n+    {\n+      ASSERT_TRUE (result);\n+      ASSERT_EQ (tree->value (), *it);\n+      result = tree.splay_prev_node ();\n+    }\n+  ASSERT_FALSE (result);\n+  ASSERT_EQ (tree.max_node ()->value (), sorted.back ());\n+\n+  // Try splitting the tree into three.\n+  int mid_min = sorted[sorted.size () / 3];\n+  int mid_max = sorted[sorted.size () * 2 / 3];\n+  ASSERT_EQ (lookup1 (tree, mid_min), 0);\n+  splay_tree<int> left = tree.split_before_root ();\n+  ASSERT_EQ (lookup1 (tree, mid_max), 0);\n+  splay_tree<int> right = tree.split_after_root ();\n+\n+  // Test removing all the nodes from their respective trees.\n+  for (int value : data)\n+    {\n+      splay_tree<int> &t = (value < mid_min ? left\n+\t\t\t    : value > mid_max ? right : tree);\n+      ASSERT_EQ (lookup1 (t, value), 0);\n+      t.remove_root ();\n+    }\n+  ASSERT_EQ (left.root (), nullptr);\n+  ASSERT_EQ (tree.root (), nullptr);\n+  ASSERT_EQ (right.root (), nullptr);\n+\n+  using rootless = default_rootless_splay_tree<rootless_test_node *>;\n+\n+  // Build a tree in ascending order with the lowest element as the root.\n+  auto *nodes = XOBNEWVEC (&ob, rootless_test_node *, MAX_DATA);\n+  rootless_test_node *parent = nullptr;\n+  for (int data : sorted)\n+    {\n+      auto *node = XOBNEW (&ob, rootless_test_node);\n+      new (node) rootless_test_node ();\n+      node->data = data;\n+      nodes[data] = node;\n+      if (parent)\n+\trootless::insert_child (parent, 1, node);\n+      parent = node;\n+    }\n+\n+  // Try comparing nodes to make sure that their order matches the data.\n+  for (size_t i = 1; i < ARRAY_SIZE (data); ++i)\n+    {\n+      int data1 = data[i - 1];\n+      int data2 = data[i];\n+      int comparison = rootless::compare_nodes (nodes[data1], nodes[data2]);\n+      if (data1 < data2)\n+\tASSERT_TRUE (comparison < 0);\n+      else if (data1 > data2)\n+\tASSERT_TRUE (comparison > 0);\n+      else\n+\tASSERT_EQ (comparison, 0);\n+    }\n+\n+  obstack_free (&ob, nullptr);\n+}\n+}\n+#endif // CHECKING_P"}, {"sha": "dfb2a4a04783252674f2b811db83e80f0e25f19f", "filename": "gcc/splay-tree-utils.h", "status": "added", "additions": 491, "deletions": 0, "changes": 491, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0882ef6a265553c8adcc24ce9059546e84b99b/gcc%2Fsplay-tree-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0882ef6a265553c8adcc24ce9059546e84b99b/gcc%2Fsplay-tree-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsplay-tree-utils.h?ref=9a0882ef6a265553c8adcc24ce9059546e84b99b", "patch": "@@ -0,0 +1,491 @@\n+// Splay tree utilities                                             -*- C++ -*-\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+//\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+//\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Implement splay tree node accessors for a class that stores its\n+// two child nodes in a member variable of the form:\n+//\n+//    Node m_children[2];\n+template<typename Node>\n+class default_splay_tree_accessors\n+{\n+public:\n+  using node_type = Node;\n+\n+  static auto\n+  child (node_type node, unsigned int index)\n+    -> decltype (node->m_children[index]) &\n+  {\n+    return node->m_children[index];\n+  }\n+};\n+\n+// Implement splay tree node accessors for a class that stores its\n+// two child nodes in a member variable of the form:\n+//\n+//    Node m_children[2];\n+//\n+// and also stores its parent node in a member variable of the form:\n+//\n+//    Node m_parent;\n+template<typename Node>\n+class default_splay_tree_accessors_with_parent\n+  : public default_splay_tree_accessors<Node>\n+{\n+public:\n+  using node_type = Node;\n+\n+  static auto\n+  parent (node_type node) -> decltype (node->m_parent) &\n+  {\n+    return node->m_parent;\n+  }\n+};\n+\n+// Base is a splay tree accessor class for nodes that have no parent field.\n+// Base therefore provides a Base::child method but does not provide a\n+// Base::parent method.  Extend Base with dummy routines for setting the\n+// parent, which is a no-op when the parent is not stored.\n+template<typename Base>\n+class splay_tree_accessors_without_parent : public Base\n+{\n+public:\n+  using typename Base::node_type;\n+\n+  static void set_parent (node_type, node_type) {}\n+};\n+\n+// Base is splay tree accessor class for nodes that have a parent field.\n+// Base therefore provides both Base::child and Base::parent methods.\n+// Extend Base with routines for setting the parent.\n+template<typename Base>\n+class splay_tree_accessors_with_parent : public Base\n+{\n+public:\n+  using typename Base::node_type;\n+\n+  // Record that NODE's parent is now NEW_PARENT.\n+  static void\n+  set_parent (node_type node, node_type new_parent)\n+  {\n+    Base::parent (node) = new_parent;\n+  }\n+};\n+\n+// A base class that provides some splay tree operations that are common\n+// to both rooted_splay_tree and rootless_splay_tree.\n+//\n+// Nodes in the splay tree have type Accessors::node_type; this is\n+// usually a pointer type.  The Accessors class provides the following\n+// static member functions for accessing nodes:\n+//\n+// - Accessors::child (NODE, INDEX)\n+//     INDEX is guaranteed to be 0 or 1.  If INDEX is 0, return a reference\n+//     to where NODE's left child is stored, otherwise return a reference\n+//     to where NODE's right child is stored.\n+//\n+// - Accessors::set_parent (NODE, PARENT)\n+//     Record that NODE's parent node is now PARENT.\n+template<typename Accessors>\n+class base_splay_tree : protected Accessors\n+{\n+public:\n+  using typename Accessors::node_type;\n+\n+  // INDEX is either 0 or 1.  If INDEX is 0, insert CHILD immediately\n+  // before NODE, otherwise insert CHILD immediately after NODE.\n+  //\n+  // Complexity: O(1).\n+  static void insert_child (node_type node, unsigned int index,\n+\t\t\t    node_type child);\n+\n+  // Print NODE and its child nodes to PP for debugging purposes,\n+  // using PRINTER (PP, N) to print the data for node N.\n+  template<typename Printer>\n+  static void print (pretty_printer *pp, node_type node, Printer printer);\n+\n+protected:\n+  using Accessors::set_parent;\n+\n+  static node_type get_child (node_type, unsigned int);\n+  static void set_child (node_type, unsigned int, node_type);\n+  static node_type promote_child (node_type, unsigned int);\n+  static void promote_child (node_type, unsigned int, node_type);\n+\n+  template<unsigned int N>\n+  static node_type splay_limit (node_type);\n+\n+  static node_type remove_node_internal (node_type);\n+\n+  template<typename Printer>\n+  static void print (pretty_printer *pp, node_type node, Printer printer,\n+\t\t     char, vec<char> &);\n+};\n+\n+// This class provides splay tree routines for cases in which the root\n+// of the splay tree is known.  It works with both nodes that store\n+// their parent node and nodes that don't.\n+//\n+// The class is lightweight: it only contains a single root node.\n+template<typename Accessors>\n+class rooted_splay_tree : public base_splay_tree<Accessors>\n+{\n+  using parent = base_splay_tree<Accessors>;\n+\n+public:\n+  using typename Accessors::node_type;\n+\n+protected:\n+  // The root of the splay tree, or node_type () if the tree is empty.\n+  node_type m_root;\n+\n+public:\n+  rooted_splay_tree () : m_root () {}\n+\n+  // Construct a tree with the specified root node.\n+  rooted_splay_tree (node_type root) : m_root (root) {}\n+\n+  // Return the root of the tree.\n+  node_type root () const { return m_root; }\n+\n+  // Return true if the tree contains any nodes.\n+  explicit operator bool () const { return m_root; }\n+\n+  // Dereference the root node.\n+  node_type operator-> () { return m_root; }\n+\n+  // Insert NEW_NODE into the splay tree, if no equivalent node already\n+  // exists.  For a given node N, COMPARE (N) should return:\n+  //\n+  // - a negative value if NEW_NODE should come before N\n+  // - zero if NEW_NODE and N are the same\n+  // - a positive value if NEW_NODE should come after N\n+  //\n+  // Return true if NEW_NODE was inserted.\n+  //\n+  // On return, NEW_NODE or its equivalent is the root of the tree.\n+  //\n+  // Complexity: amortized O(C log N), worst-cast O(C N), where C is\n+  // the complexity of the comparison.\n+  template<typename Comparator>\n+  bool insert (node_type new_node, Comparator compare);\n+\n+  // Insert NEW_NODE into the splay tree, given that NEW_NODE is the\n+  // maximum node of the new tree.  On return, NEW_NODE is also the\n+  // root of the tree.\n+  //\n+  // Complexity: O(1).\n+  void insert_max_node (node_type new_node);\n+\n+  // Splice NEXT_TREE onto this one, given that all nodes in NEXT_TREE\n+  // are greater than the maximum node in this tree.  NEXT_TREE should\n+  // not be used afterwards.\n+  //\n+  // Complexity: O(1) if the root of the splay tree is already the maximum\n+  // node.  Otherwise amortized O(log N), worst-cast O(N).\n+  void splice_next_tree (rooted_splay_tree next_tree);\n+\n+  // The root of the tree is currently the maximum node.  Replace it\n+  // with NEW_NODE.\n+  //\n+  // Complexity: O(1).\n+  void replace_max_node_at_root (node_type new_node);\n+\n+  // Remove the root node of the splay tree.\n+  //\n+  // Complexity: O(1) if removing the maximum or minimum node.\n+  // Otherwise amortized O(log N), worst-cast O(N).\n+  void remove_root ();\n+\n+  // Split the left child of the current root out into a separate tree\n+  // and return the new tree.\n+  rooted_splay_tree split_before_root ();\n+\n+  // Split the right child of the current root out into a separate tree\n+  // and return the new tree.\n+  rooted_splay_tree split_after_root ();\n+\n+  // If the root is not the minimum node of the splay tree, bring the previous\n+  // node to the root and return true, otherwise return false.\n+  //\n+  // Complexity: amortized O(log N), worst-cast O(N).\n+  bool splay_prev_node ();\n+\n+  // If the root is not the maximum node of the splay tree, bring the next\n+  // node to the root and return true, otherwise return false.\n+  //\n+  // Complexity: amortized O(log N), worst-cast O(N).\n+  bool splay_next_node ();\n+\n+  // Bring the minimum node of the splay tree to the root.\n+  //\n+  // Complexity: amortized O(log N), worst-cast O(N).\n+  void splay_min_node ();\n+\n+  // Bring the maximum node of the splay tree to the root.\n+  //\n+  // Complexity: amortized O(log N), worst-cast O(N).\n+  void splay_max_node ();\n+\n+  // Return the minimum node of the splay tree, or node_type () if the\n+  // tree is empty.  On return, the minimum node (if any) is also the\n+  // root of the tree.\n+  //\n+  // Complexity: amortized O(log N), worst-cast O(N).\n+  node_type min_node ();\n+\n+  // Return the maximum node of the splay tree, or node_type () if the\n+  // tree is empty.  On return, the maximum node (if any) is also the\n+  // root of the tree.\n+  //\n+  // Complexity: amortized O(log N), worst-cast O(N).\n+  node_type max_node ();\n+\n+  // Search the splay tree.  For a given node N, COMPARE (N) should return:\n+  //\n+  // - a negative value if N is bigger than the node being searched for\n+  // - zero if N is the node being searched for\n+  // - a positive value if N is smaller than the node being searched for\n+  //\n+  // If the node that COMPARE is looking for exists, install it as the root\n+  // node of the splay tree.  Otherwise, arbitrarily pick either:\n+  //\n+  // - the maximum node that is smaller than the node being searched for or\n+  // - the minimum node that is bigger than the node being searched for\n+  //\n+  // and install that node as the root instead.\n+  //\n+  // Return the result of COMPARE for the new root.\n+  //\n+  // This form of lookup is intended for cases in which both the following\n+  // are true:\n+  //\n+  // (a) The work that COMPARE needs to do to detect if a node is too big\n+  //     is the same as the work that COMPARE needs to do to detect if a\n+  //     node is too small.  (This is not true of range comparisons,\n+  //     for example.)\n+  //\n+  // (b) COMPARE is (or might be) relatively complex.\n+  //\n+  // This form of lookup is also useful if the items being compared naturally\n+  // provide a <=>-style comparison result, without the result having to be\n+  // forced by the equivalent of a ?: expression.\n+  //\n+  // The implementation only invokes COMPARE once per node.\n+  //\n+  // Complexity: amortized O(C log N), worst-cast O(C N), where C is\n+  // the complexity of the comparison.\n+  template<typename Comparator>\n+  auto lookup (Comparator compare) -> decltype (compare (m_root));\n+\n+  // Search the splay tree.  For a given node N, WANT_SOMETHING_SMALLER (N)\n+  // is true if N is too big and WANT_SOMETHING_BIGGER (N) is true if N\n+  // is too small.  Both functions return false if N is the node being\n+  // searched for.\n+  //\n+  // If the node that is being searched for exists, install it as the root\n+  // node of the splay tree and return 0.  Otherwise, arbitrarily choose\n+  // between these two options:\n+  //\n+  // - Install the maximum node that is smaller than the node being\n+  //   searched for as the root of the splay tree and return 1.\n+  //\n+  // - Install the minimum node that is bigger than the node being\n+  //   searched for and return -1.\n+  //\n+  // This form of lookup is intended for cases in which either of the\n+  // following are true:\n+  //\n+  // (a) WANT_SOMETHING_SMALLER and WANT_SOMETHING_BIGGER test different\n+  //     parts of the node's data.  For example, when comparing ranges,\n+  //     WANT_SOMETHING_SMALLER would test the lower limit of the given\n+  //     node's range while WANT_SOMETHING_BIGGER would test the upper\n+  //     limit of the given node's range.\n+  //\n+  // (b) There is no significant overhead to calling both\n+  //     WANT_SOMETHING_SMALLER and WANT_SOMETHING_BIGGER for the same node.\n+  //\n+  // Complexity: amortized O(C log N), worst-cast O(C N), where C is\n+  // the complexity of the comparisons.\n+  template<typename LeftPredicate, typename RightPredicate>\n+  int lookup (LeftPredicate want_something_smaller,\n+\t      RightPredicate want_something_bigger);\n+\n+  // Keep the ability to print subtrees.\n+  using parent::print;\n+\n+  // Print the tree to PP for debugging purposes, using PRINTER (PP, N)\n+  // to print the data for node N.\n+  template<typename Printer>\n+  void print (pretty_printer *pp, Printer printer) const;\n+\n+protected:\n+  using parent::get_child;\n+  using parent::set_child;\n+  using parent::promote_child;\n+\n+  using parent::set_parent;\n+\n+  template<unsigned int N>\n+  bool splay_neighbor ();\n+};\n+\n+// Provide splay tree routines for nodes of type Accessors::node_type,\n+// which doesn't have a parent field.  Use Accessors::child to access\n+// the children of a node.\n+template<typename Accessors>\n+using splay_tree_without_parent\n+  = rooted_splay_tree<splay_tree_accessors_without_parent<Accessors>>;\n+\n+// A splay tree for nodes of type Node, which is usually a pointer type.\n+// The child nodes are stored in a member variable:\n+//\n+//    Node m_children[2];\n+//\n+// Node does not have a parent field.\n+template<typename Node>\n+using default_splay_tree\n+  = splay_tree_without_parent<default_splay_tree_accessors<Node>>;\n+\n+// A simple splay tree node that stores a value of type T.\n+template<typename T>\n+class splay_tree_node\n+{\n+  friend class default_splay_tree_accessors<splay_tree_node *>;\n+\n+public:\n+  splay_tree_node () = default;\n+  splay_tree_node (T value) : m_value (value), m_children () {}\n+\n+  T &value () { return m_value; }\n+  const T &value () const { return m_value; }\n+\n+private:\n+  T m_value;\n+  splay_tree_node *m_children[2];\n+};\n+\n+// A splay tree whose nodes hold values of type T.\n+template<typename T>\n+using splay_tree = default_splay_tree<splay_tree_node<T> *>;\n+\n+// Provide splay tree routines for cases in which the root of the tree\n+// is not explicitly stored.\n+//\n+// The nodes of the tree have type Accessors::node_type, which is usually\n+// a pointer type.  The nodes have a link back to their parent.\n+//\n+// The Accessors class provides the following static member functions:\n+//\n+// - Accessors::child (NODE, INDEX)\n+//     INDEX is guaranteed to be 0 or 1.  If INDEX is 0, return a reference\n+//     to where NODE's left child is stored, otherwise return a reference\n+//     to where NODE's right child is stored.\n+//\n+// - Accessors::parent (NODE)\n+//     Return a reference to where NODE's parent is stored.\n+template<typename Accessors>\n+class rootless_splay_tree\n+  : public base_splay_tree<splay_tree_accessors_with_parent<Accessors>>\n+{\n+  using full_accessors = splay_tree_accessors_with_parent<Accessors>;\n+  using parent = base_splay_tree<full_accessors>;\n+\n+public:\n+  using rooted = rooted_splay_tree<full_accessors>;\n+\n+  using typename Accessors::node_type;\n+\n+  // Remove NODE from the splay tree.  Return the node that replaces it,\n+  // or null if NODE had no children.\n+  //\n+  // Complexity: O(1) if removing the maximum or minimum node.\n+  // Otherwise amortized O(log N), worst-cast O(N).\n+  static node_type remove_node (node_type node);\n+\n+  // Splay NODE so that it becomes the root of the splay tree.\n+  //\n+  // Complexity: amortized O(log N), worst-cast O(N).\n+  static void splay (node_type node);\n+\n+  // Like splay, but take advantage of the fact that NODE is known to be\n+  // the minimum node in the tree.\n+  //\n+  // Complexity: amortized O(log N), worst-cast O(N).\n+  static void splay_known_min_node (node_type node);\n+\n+  // Like splay, but take advantage of the fact that NODE is known to be\n+  // the maximum node in the tree.\n+  //\n+  // Complexity: amortized O(log N), worst-cast O(N).\n+  static void splay_known_max_node (node_type node);\n+\n+  // Splay NODE while looking for an ancestor node N for which PREDICATE (N)\n+  // is true.  If such an ancestor node exists, stop the splay operation\n+  // early and return PREDICATE (N).  Otherwise, complete the splay operation\n+  // and return DEFAULT_RESULT.  In the latter case, NODE is now the root of\n+  // the splay tree.\n+  //\n+  // Note that this routine only examines nodes that happen to be ancestors\n+  // of NODE.  It does not search the full tree.\n+  //\n+  // Complexity: amortized O(P log N), worst-cast O(P N), where P is the\n+  // complexity of the predicate.\n+  template<typename DefaultResult, typename Predicate>\n+  static auto splay_and_search (node_type node, DefaultResult default_result,\n+\t\t\t\tPredicate predicate)\n+    -> decltype (predicate (node, 0));\n+\n+  // NODE1 and NODE2 are known to belong to the same splay tree.  Return:\n+  //\n+  // -1 if NODE1 < NODE2\n+  // 0 if NODE1 == NODE2\n+  // 1 if NODE1 > NODE2\n+  //\n+  // Complexity: amortized O(log N), worst-cast O(N).\n+  static int compare_nodes (node_type node1, node_type node2);\n+\n+protected:\n+  using parent::get_child;\n+  using parent::set_child;\n+  using parent::promote_child;\n+\n+  static node_type get_parent (node_type);\n+  using parent::set_parent;\n+\n+  static unsigned int child_index (node_type, node_type);\n+\n+  static int compare_nodes_one_way (node_type, node_type);\n+\n+  template<unsigned int N>\n+  static void splay_known_limit (node_type);\n+};\n+\n+// Provide rootless splay tree routines for nodes of type Node.\n+// The child nodes are stored in a member variable:\n+//\n+//    Node m_children[2];\n+//\n+// and the parent node is stored in a member variable:\n+//\n+//    Node m_parent;\n+template<typename Node>\n+using default_rootless_splay_tree\n+  = rootless_splay_tree<default_splay_tree_accessors_with_parent<Node>>;\n+\n+#include \"splay-tree-utils.tcc\""}, {"sha": "5c9c859d0bdfa7cbc43366cbad1fe457827fe5d3", "filename": "gcc/splay-tree-utils.tcc", "status": "added", "additions": 960, "deletions": 0, "changes": 960, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0882ef6a265553c8adcc24ce9059546e84b99b/gcc%2Fsplay-tree-utils.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0882ef6a265553c8adcc24ce9059546e84b99b/gcc%2Fsplay-tree-utils.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsplay-tree-utils.tcc?ref=9a0882ef6a265553c8adcc24ce9059546e84b99b", "patch": "@@ -0,0 +1,960 @@\n+// Splay tree utilities                                             -*- C++ -*-\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+//\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+//\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// INDEX is either 0 or 1.  If it is 0, return NODE's left child,\n+// otherwise return NODE's right child.\n+template<typename Accessors>\n+inline typename base_splay_tree<Accessors>::node_type\n+base_splay_tree<Accessors>::get_child (node_type node, unsigned int index)\n+{\n+  return Accessors::child (node, index);\n+}\n+\n+// INDEX is either 0 or 1.  If it is 0, change NODE's left child to CHILD,\n+// otherwise change NODE's right child to CHILD.  If CHILD has a parent\n+// field, record that its parent is now NODE.\n+template<typename Accessors>\n+inline void\n+base_splay_tree<Accessors>::set_child (node_type node, unsigned int index,\n+\t\t\t\t       node_type child)\n+{\n+  Accessors::child (node, index) = child;\n+  if (child)\n+    set_parent (child, node);\n+}\n+\n+// Rotate the tree to promote child number INDEX of NODE, so that that\n+// child becomes a parent of NODE.  Return the promoted node.\n+//\n+// The caller has the responsibility of assigning a correct parent\n+// to the returned node.\n+template<typename Accessors>\n+inline typename base_splay_tree<Accessors>::node_type\n+base_splay_tree<Accessors>::promote_child (node_type node, unsigned int index)\n+{\n+  node_type promoted = get_child (node, index);\n+  set_child (node, index, get_child (promoted, 1 - index));\n+  set_child (promoted, 1 - index, node);\n+  return promoted;\n+}\n+\n+// Treat child number INDEX of NODE as being CHILD and rotate the tree\n+// so that CHILD becomes a parent of NODE.\n+//\n+// The caller has the responsibility of assigning a correct parent to CHILD.\n+template<typename Accessors>\n+inline void\n+base_splay_tree<Accessors>::promote_child (node_type node, unsigned int index,\n+\t\t\t\t\t   node_type child)\n+{\n+  set_child (node, index, get_child (child, 1 - index));\n+  set_child (child, 1 - index, node);\n+}\n+\n+// Print NODE to PP, using PRINTER (PP, N) to print the contents of node N.\n+// Prefix each new line with INDENT_STRING.  CODE is 'T' if NODE is the root\n+// node, 'L' if NODE is the left child of its parent, or 'R' if NODE is the\n+// right child of its parent.\n+template<typename Accessors>\n+template<typename Printer>\n+void\n+base_splay_tree<Accessors>::print (pretty_printer *pp, node_type node,\n+\t\t\t\t   Printer printer, char code,\n+\t\t\t\t   vec<char> &indent_string)\n+{\n+  // In the comments below, PREFIX refers to the incoming contents\n+  // of INDENT_STRING.\n+  node_type left = get_child (node, 0);\n+  node_type right = get_child (node, 1);\n+\n+  auto orig_indent_len = indent_string.length ();\n+  indent_string.safe_grow (orig_indent_len + 3);\n+  char *extra_indent = indent_string.address () + orig_indent_len;\n+\n+  // Print [T], [L], or [R].\n+  extra_indent[0] = '[';\n+  extra_indent[1] = code;\n+  extra_indent[2] = ']';\n+  pp_append_text (pp, extra_indent, indent_string.end ());\n+  pp_space (pp);\n+\n+  // Print the node itself, using PREFIX + \" | \" or PREFIX + \"   \" to indent\n+  // new lines under the \"[_]\" that we just printed.\n+  extra_indent[0] = ' ';\n+  extra_indent[1] = (left || right ? '|' : ' ');\n+  extra_indent[2] = ' ';\n+  {\n+    pretty_printer sub_pp;\n+    printer (&sub_pp, node);\n+    const char *text = pp_formatted_text (&sub_pp);\n+    while (const char *end = strchr (text, '\\n'))\n+      {\n+\tpp_append_text (pp, text, end);\n+\tpp_newline_and_indent (pp, 0);\n+\tpp_append_text (pp, indent_string.begin (), indent_string.end ());\n+\ttext = end + 1;\n+      }\n+    pp_string (pp, text);\n+  }\n+\n+  if (left)\n+    {\n+      // Print PREFIX + \" +-\" for the first line of the left subtree,\n+      // to be followed by \"[L]\".\n+      extra_indent[1] = '+';\n+      extra_indent[2] = '-';\n+      pp_newline_and_indent (pp, 0);\n+      pp_append_text (pp, indent_string.begin (), indent_string.end ());\n+\n+      // Print the left subtree, using PREFIX + \" | \" or PREFIX + \"   \"\n+      // to indent under the PREFIX + \" +-\" that we just printed.\n+      extra_indent[1] = right ? '|' : ' ';\n+      extra_indent[2] = ' ';\n+      print (pp, left, printer, 'L', indent_string);\n+      extra_indent = indent_string.address () + orig_indent_len;\n+\n+      // If LEFT is not a leaf and we also have a right subtree, use a\n+      // PREFIX + \" |\" line to separate them.\n+      if (right && (get_child (left, 0) || get_child (left, 1)))\n+\t{\n+\t  pp_newline_and_indent (pp, 0);\n+\t  pp_append_text (pp, indent_string.begin (), &extra_indent[2]);\n+\t}\n+    }\n+  if (right)\n+    {\n+      // Print PREFIX + \" +-\" for the first line of the right subtree,\n+      // to be followed by \"[R]\".\n+      extra_indent[1] = '+';\n+      extra_indent[2] = '-';\n+      pp_newline_and_indent (pp, 0);\n+      pp_append_text (pp, indent_string.begin (), indent_string.end ());\n+\n+      // Print the right subtree, using PREFIX + \"   \" to indent under the\n+      // PREFIX + \" +-\" that we just printed.\n+      extra_indent[1] = ' ';\n+      extra_indent[2] = ' ';\n+      print (pp, right, printer, 'R', indent_string);\n+    }\n+  indent_string.truncate (orig_indent_len);\n+}\n+\n+// See the comment above the declaration.\n+template<typename Accessors>\n+template<typename Printer>\n+void\n+base_splay_tree<Accessors>::print (pretty_printer *pp, node_type node,\n+\t\t\t\t   Printer printer)\n+{\n+  if (!node)\n+    {\n+      pp_string (pp, \"null\");\n+      return;\n+    }\n+  auto_vec<char, 64> indent_string;\n+  print (pp, node, printer, 'T', indent_string);\n+}\n+\n+// If N is 1, splay the last (rightmost) node reachable from START\n+// to the position that START current holds and return the splayed node.\n+// START is not itself the last node.\n+//\n+// If N is 0, splay the first (leftmost) node reachable from START\n+// to the position that START current holds and return the splayed node.\n+// START is not itself the first node.\n+//\n+// The caller has the responsibility of updating the parent of the\n+// returned node.\n+template<typename Accessors>\n+template<unsigned int N>\n+typename base_splay_tree<Accessors>::node_type\n+base_splay_tree<Accessors>::splay_limit (node_type start)\n+{\n+  // This essentially follows the simpilfied top-down method described\n+  // in Sleator and Tarjan's \"Self-adjusting Binary Search Trees\", but\n+  // specialized for the case in which the comparison result is fixed.\n+  // The first iteration is peeled to avoid the need for stack temporaries.\n+  //\n+  // The comments and names reflect the behavior for N == 1, but the\n+  // N == 0 case behaves analogously.\n+\n+  // Rotate the tree to promote the right child of START to the root.\n+  node_type node = promote_child (start, N);\n+  if (node_type right = get_child (node, N))\n+    {\n+      // Perform the link left step, which for this first iteration\n+      // means making NODE the root of the left tree.\n+      //\n+      // NODE will become left child of the final node.  For a right\n+      // spine starting at NODE of the form:\n+      //\n+      //  1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> ... -> N\n+      //  |    |    |    |    |    |    |           |\n+      //  V    V    V    V    V    V    V           V\n+      //  A    B    C    D    E    F    G           NL\n+      //\n+      // the next step is to create a subtree of N whose right spine contains\n+      // the odd-numbered nodes, as follows:\n+      //\n+      //  N\n+      //  |\n+      //  V\n+      //  1 ------> 3 ------> 5 ------> 7 -> .... -> NL\n+      //  |         |         |         |\n+      //  V         V         V         V\n+      //  A         2 -> C    4 -> E    6 -> G\n+      //            |         |         |\n+      //            V         V         V\n+      //            B         D         F\n+      //\n+      // First record 1 as the left child of the final root (N) and move\n+      // on to node 2.\n+      node_type final_child = node;\n+      node_type new_spine_end = node;\n+      node = right;\n+      while (node_type right = get_child (node, N))\n+\t{\n+\t  // Perform another rotate left step.\n+\t  //\n+\t  // We've built the tree rooted at 1 in the diagram above up to,\n+\t  // but not including, an even-numbered node NODE on the original\n+\t  // right spine.  Rotate the tree at NODE to promote the following\n+\t  // odd-numbered node.\n+\t  promote_child (node, N, right);\n+\t  node = right;\n+\t  if (node_type right = get_child (node, N))\n+\t    {\n+\t      // Perform another link left step.\n+\t      //\n+\t      // Add the promoted odd-numbered node to the right spine of the\n+\t      // tree rooted at 1 and move on to the next even-numbered node.\n+\t      set_child (new_spine_end, N, node);\n+\t      new_spine_end = node;\n+\t      node = right;\n+\t    }\n+\t}\n+      // Perform the assembly step.\n+      //\n+      // Add NL to the new spine and make N the new root.\n+      set_child (new_spine_end, N, get_child (node, 1 - N));\n+      set_child (node, 1 - N, final_child);\n+    }\n+  return node;\n+}\n+\n+// Remove NODE from its position in the splay tree.  If NODE has at least\n+// one child node, return the node that should now hold NODE's position in\n+// the splay tree.  If NODE has no children, return null.\n+//\n+// The caller has the responsibility of updating the parent of the\n+// returned node.\n+template<typename Accessors>\n+inline typename base_splay_tree<Accessors>::node_type\n+base_splay_tree<Accessors>::remove_node_internal (node_type node)\n+{\n+  node_type left = get_child (node, 0);\n+  node_type right = get_child (node, 1);\n+  if (!left)\n+    return right;\n+\n+  if (!right)\n+    return left;\n+\n+  if (get_child (left, 1))\n+    {\n+      left = splay_limit<1> (left);\n+      gcc_checking_assert (!get_child (left, 1));\n+    }\n+  set_child (left, 1, right);\n+  return left;\n+}\n+\n+// See the comment above the declaration.\n+template<typename Accessors>\n+inline void\n+base_splay_tree<Accessors>::insert_child (node_type node, unsigned int index,\n+\t\t\t\t\t  node_type child)\n+{\n+  gcc_checking_assert (!get_child (child, 0) && !get_child (child, 1));\n+  set_child (child, index, get_child (node, index));\n+  set_child (node, index, child);\n+}\n+\n+// Implement splay_next_node if N == 1 and splay_prev_node if N == 0.\n+template<typename Accessors>\n+template<unsigned int N>\n+bool\n+rooted_splay_tree<Accessors>::splay_neighbor ()\n+{\n+  node_type node = m_root;\n+  node_type new_root = get_child (node, N);\n+  if (!new_root)\n+    return false;\n+\n+  if (get_child (new_root, 1 - N))\n+    {\n+      // NEW_ROOT is not itself the required node, so splay the required\n+      // node into its place.\n+      new_root = parent::template splay_limit<1 - N> (new_root);\n+      gcc_checking_assert (!get_child (new_root, 1 - N));\n+      set_child (node, N, node_type ());\n+      set_child (new_root, 1 - N, node);\n+    }\n+  else\n+    promote_child (node, N, new_root);\n+  set_parent (new_root, node_type ());\n+  m_root = new_root;\n+  return true;\n+}\n+\n+// See the comment above the declaration.\n+template<typename Accessors>\n+template<typename Comparator>\n+bool\n+rooted_splay_tree<Accessors>::insert (node_type new_node, Comparator compare)\n+{\n+  gcc_checking_assert (!get_child (new_node, 0) && !get_child (new_node, 1));\n+  if (!m_root)\n+    {\n+      m_root = new_node;\n+      return true;\n+    }\n+\n+  int comparison = lookup (compare);\n+  if (comparison == 0)\n+    return false;\n+\n+  // Insert NEW_NODE before M_ROOT if COMPARISON < 0 and after M_ROOT\n+  // otherwise.\n+  set_child (new_node, comparison < 0, m_root);\n+  set_child (new_node, comparison > 0, get_child (m_root, comparison > 0));\n+  set_child (m_root, comparison > 0, nullptr);\n+  m_root = new_node;\n+  return true;\n+}\n+\n+// See the comment above the declaration.\n+template<typename Accessors>\n+inline void\n+rooted_splay_tree<Accessors>::insert_max_node (node_type new_node)\n+{\n+  gcc_checking_assert (!get_child (new_node, 0) && !get_child (new_node, 1));\n+  set_child (new_node, 0, m_root);\n+  m_root = new_node;\n+}\n+\n+// See the comment above the declaration.\n+template<typename Accessors>\n+inline void\n+rooted_splay_tree<Accessors>::splice_next_tree (rooted_splay_tree next_tree)\n+{\n+  splay_max_node ();\n+  set_child (m_root, 1, next_tree.m_root);\n+}\n+\n+// See the comment above the declaration.\n+template<typename Accessors>\n+inline void\n+rooted_splay_tree<Accessors>::replace_max_node_at_root (node_type new_node)\n+{\n+  node_type old_node = m_root;\n+  gcc_checking_assert (!get_child (new_node, 0)\n+\t\t       && !get_child (new_node, 1)\n+\t\t       && !get_child (old_node, 1));\n+  set_child (new_node, 0, get_child (old_node, 0));\n+  // Clear the links from OLD_NODE.  Its parent and right child are\n+  // already node_type ().\n+  set_child (old_node, 0, node_type ());\n+  m_root = new_node;\n+}\n+\n+// See the comment above the declaration.\n+template<typename Accessors>\n+inline void\n+rooted_splay_tree<Accessors>::remove_root ()\n+{\n+  node_type node = m_root;\n+  m_root = parent::remove_node_internal (node);\n+  if (m_root)\n+    set_parent (m_root, node_type ());\n+  // Clear the links from NODE.  Its parent is already node_type ().\n+  set_child (node, 0, node_type ());\n+  set_child (node, 1, node_type ());\n+}\n+\n+// See the comment above the declaration.\n+template<typename Accessors>\n+inline rooted_splay_tree<Accessors>\n+rooted_splay_tree<Accessors>::split_before_root ()\n+{\n+  node_type new_root = get_child (m_root, 0);\n+  set_child (m_root, 0, node_type ());\n+  set_parent (new_root, node_type ());\n+  return new_root;\n+}\n+\n+// See the comment above the declaration.\n+template<typename Accessors>\n+inline rooted_splay_tree<Accessors>\n+rooted_splay_tree<Accessors>::split_after_root ()\n+{\n+  node_type new_root = get_child (m_root, 1);\n+  set_child (m_root, 1, node_type ());\n+  set_parent (new_root, node_type ());\n+  return new_root;\n+}\n+\n+// See the comment above the declaration.\n+template<typename Accessors>\n+inline bool\n+rooted_splay_tree<Accessors>::splay_prev_node ()\n+{\n+  return splay_neighbor<0> ();\n+}\n+\n+// See the comment above the declaration.\n+template<typename Accessors>\n+inline bool\n+rooted_splay_tree<Accessors>::splay_next_node ()\n+{\n+  return splay_neighbor<1> ();\n+}\n+\n+// See the comment above the declaration.\n+template<typename Accessors>\n+inline void\n+rooted_splay_tree<Accessors>::splay_min_node ()\n+{\n+  if (m_root && get_child (m_root, 0))\n+    {\n+      m_root = parent::template splay_limit<0> (m_root);\n+      set_parent (m_root, node_type ());\n+    }\n+}\n+\n+// See the comment above the declaration.\n+template<typename Accessors>\n+inline void\n+rooted_splay_tree<Accessors>::splay_max_node ()\n+{\n+  if (m_root && get_child (m_root, 1))\n+    {\n+      m_root = parent::template splay_limit<1> (m_root);\n+      set_parent (m_root, node_type ());\n+    }\n+}\n+\n+// See the comment above the declaration.\n+template<typename Accessors>\n+inline typename rooted_splay_tree<Accessors>::node_type\n+rooted_splay_tree<Accessors>::min_node ()\n+{\n+  splay_min_node ();\n+  return m_root;\n+}\n+\n+// See the comment above the declaration.\n+template<typename Accessors>\n+inline typename rooted_splay_tree<Accessors>::node_type\n+rooted_splay_tree<Accessors>::max_node ()\n+{\n+  splay_max_node ();\n+  return m_root;\n+}\n+\n+// See the comment above the declaration.\n+template<typename Accessors>\n+template<typename Comparator>\n+auto\n+rooted_splay_tree<Accessors>::lookup (Comparator compare)\n+  -> decltype (compare (m_root))\n+{\n+  // This essentially follows the simpilfied top-down method described\n+  // in Sleator and Tarjan's \"Self-adjusting Binary Search Trees\", but\n+  // with the complication that the comparisons are done only once.\n+  using result_type = decltype (compare (m_root));\n+\n+  // The roots of the left and right trees.\n+  node_type link_left_root = node_type ();\n+  node_type link_right_root = node_type ();\n+\n+  // Where to add new nodes to the left and right trees.\n+  node_type *link_left_ptr = &link_left_root;\n+  node_type *link_right_ptr = &link_right_root;\n+\n+  // The nodes that contain *LINK_LEFT_PTR and *LINK_RIGHT_PTR,\n+  // once they no longer point to the roots above.\n+  node_type link_left_parent = node_type ();\n+  node_type link_right_parent = node_type ();\n+\n+  auto link_left = [&](node_type node)\n+    {\n+      *link_left_ptr = node;\n+      link_left_ptr = &Accessors::child (node, 1);\n+      set_parent (node, link_left_parent);\n+      link_left_parent = node;\n+    };\n+\n+  auto link_right = [&](node_type node)\n+    {\n+      *link_right_ptr = node;\n+      link_right_ptr = &Accessors::child (node, 0);\n+      set_parent (node, link_right_parent);\n+      link_right_parent = node;\n+    };\n+\n+  node_type node = m_root;\n+  node_type parent = node_type ();\n+  result_type result;\n+  result_type old_result = 0;\n+  while (1)\n+    {\n+      // OLD_RESULT is 0 if NODE is the root of the middle tree.\n+      // Otherwise, PARENT is the root of the middle tree and OLD_RESULT\n+      // is how it compared.\n+      //\n+      // Results are:\n+      // < 0 if we want something smaller.\n+      // = 0 if we found the right node.\n+      // > 0 if we want something bigger.\n+      result = compare (node);\n+      if (old_result < 0)\n+\t{\n+\t  if (result < 0)\n+\t    {\n+\t      // SEARCH < NODE < PARENT\n+\t      //\n+\t      // Promote NODE (rotate right).\n+\t      promote_child (parent, 0, node);\n+\t      node_type next = get_child (node, 0);\n+\t      if (!next)\n+\t\tbreak;\n+\n+\t      link_right (node);\n+\n+\t      // NEXT is now the root of the middle tree.\n+\t      node = next;\n+\t      old_result = 0;\n+\t      continue;\n+\t    }\n+\n+\t  // SEARCH >= NODE, NODE < PARENT\n+\t  link_right (parent);\n+\t}\n+      else if (old_result > 0)\n+\t{\n+\t  if (result > 0)\n+\t    {\n+\t      // SEARCH > NODE > PARENT\n+\t      //\n+\t      // Promote NODE (rotate left).\n+\t      promote_child (parent, 1, node);\n+\t      node_type next = get_child (node, 1);\n+\t      if (!next)\n+\t\tbreak;\n+\n+\t      link_left (node);\n+\n+\t      // NEXT is now the root of the middle tree.\n+\t      node = next;\n+\t      old_result = 0;\n+\t      continue;\n+\t    }\n+\n+\t  // SEARCH <= NODE, NODE > PARENT\n+\t  link_left (parent);\n+\t}\n+\n+      // Microoptimization to allow NODE to be read even if RESULT == 0.\n+      node_type next = get_child (node, result >= 0);\n+      if (result == 0 || !next)\n+\tbreak;\n+\n+      // NODE is now the root of the tree.\n+      parent = node;\n+      node = next;\n+      old_result = result;\n+    }\n+\n+  node_type new_left = link_left_root;\n+  node_type new_right = link_right_root;\n+\n+  if (new_left)\n+    {\n+      node_type old_left = get_child (node, 0);\n+      *link_left_ptr = old_left;\n+      if (old_left)\n+\tset_parent (old_left, link_left_parent);\n+      set_child (node, 0, new_left);\n+    }\n+\n+  if (new_right)\n+    {\n+      node_type old_right = get_child (node, 1);\n+      *link_right_ptr = old_right;\n+      if (old_right)\n+\tset_parent (old_right, link_right_parent);\n+      set_child (node, 1, new_right);\n+    }\n+\n+  set_parent (node, node_type ());\n+  m_root = node;\n+  return result;\n+}\n+\n+// See the comment above the declaration.\n+template<typename Accessors>\n+template<typename LeftPredicate, typename RightPredicate>\n+int\n+rooted_splay_tree<Accessors>::lookup (LeftPredicate want_something_smaller,\n+\t\t\t\t      RightPredicate want_something_bigger)\n+{\n+  // This essentially follows the simpilfied top-down method described\n+  // in Sleator and Tarjan's \"Self-adjusting Binary Search Trees\"\n+  // (and follows it more closely than the single-comparator version above).\n+\n+  // The roots of the left and right trees.\n+  node_type link_left_root = node_type ();\n+  node_type link_right_root = node_type ();\n+\n+  // Where to add new nodes to the left and right trees.\n+  node_type *link_left_ptr = &link_left_root;\n+  node_type *link_right_ptr = &link_right_root;\n+\n+  // The nodes that contain *LINK_LEFT_PTR and *LINK_RIGHT_PTR,\n+  // once they no longer point to the roots above.\n+  node_type link_left_parent = node_type ();\n+  node_type link_right_parent = node_type ();\n+\n+  node_type node = m_root;\n+  int result;\n+  for (;;)\n+    {\n+      // NODE is the root of the middle tree.\n+      if (want_something_smaller (node))\n+\t{\n+\t  result = -1;\n+\t  node_type next = get_child (node, 0);\n+\t  if (!next)\n+\t    break;\n+\n+\t  if (want_something_smaller (next))\n+\t    {\n+\t      // Promote NODE (rotate right).\n+\t      promote_child (node, 0, next);\n+\t      node = next;\n+\t      next = get_child (node, 0);\n+\t      if (!next)\n+\t\tbreak;\n+\t    }\n+\n+\t  // Add NODE to the right tree (link right).\n+\t  *link_right_ptr = node;\n+\t  link_right_ptr = &Accessors::child (node, 0);\n+\t  set_parent (node, link_right_parent);\n+\t  link_right_parent = node;\n+\n+\t  node = next;\n+\t}\n+      else if (want_something_bigger (node))\n+\t{\n+\t  result = 1;\n+\t  node_type next = get_child (node, 1);\n+\t  if (!next)\n+\t    break;\n+\n+\t  if (want_something_bigger (next))\n+\t    {\n+\t      // Promote NODE (rotate left).\n+\t      promote_child (node, 1, next);\n+\t      node = next;\n+\t      next = get_child (node, 1);\n+\t      if (!next)\n+\t\tbreak;\n+\t    }\n+\n+\t  // Add NODE to the left tree (link left).\n+\t  *link_left_ptr = node;\n+\t  link_left_ptr = &Accessors::child (node, 1);\n+\t  set_parent (node, link_left_parent);\n+\t  link_left_parent = node;\n+\n+\t  node = next;\n+\t}\n+      else\n+\t{\n+\t  result = 0;\n+\t  break;\n+\t}\n+    }\n+\n+  node_type new_left = link_left_root;\n+  node_type new_right = link_right_root;\n+\n+  if (new_left)\n+    {\n+      node_type old_left = get_child (node, 0);\n+      *link_left_ptr = old_left;\n+      if (old_left)\n+\tset_parent (old_left, link_left_parent);\n+      set_child (node, 0, new_left);\n+    }\n+\n+  if (new_right)\n+    {\n+      node_type old_right = get_child (node, 1);\n+      *link_right_ptr = old_right;\n+      if (old_right)\n+\tset_parent (old_right, link_right_parent);\n+      set_child (node, 1, new_right);\n+    }\n+\n+  set_parent (node, node_type ());\n+  m_root = node;\n+  return result;\n+}\n+\n+// See the comment above the declaration.\n+template<typename Accessors>\n+template<typename Printer>\n+inline void\n+rooted_splay_tree<Accessors>::print (pretty_printer *pp, Printer printer) const\n+{\n+  print (pp, m_root, printer);\n+}\n+\n+// Return NODE's current parent.\n+template<typename Accessors>\n+inline typename rootless_splay_tree<Accessors>::node_type\n+rootless_splay_tree<Accessors>::get_parent (node_type node)\n+{\n+  return Accessors::parent (node);\n+}\n+\n+// CHILD is known to be a child of PARENT.  Return which index it has.\n+template<typename Accessors>\n+inline unsigned int\n+rootless_splay_tree<Accessors>::child_index (node_type parent, node_type child)\n+{\n+  return get_child (parent, 1) == child;\n+}\n+\n+// If N == 1, implement splay_known_max_node, otherwise implement\n+// splay_known_min_node.\n+template<typename Accessors>\n+template<unsigned int N>\n+inline void\n+rootless_splay_tree<Accessors>::splay_known_limit (node_type node)\n+{\n+  node_type child = node;\n+  node_type parent = get_parent (child);\n+  if (!parent)\n+    return;\n+\n+  do\n+    // At this point, NODE conceptually replaces CHILD as a child of\n+    // PARENT, but we haven't yet updated PARENT accordingly.\n+    if (node_type grandparent = get_parent (parent))\n+      {\n+\tnode_type greatgrandparent = get_parent (grandparent);\n+\tpromote_child (grandparent, N, parent);\n+\tpromote_child (parent, N, node);\n+\tchild = grandparent;\n+\tparent = greatgrandparent;\n+      }\n+    else\n+      {\n+\tpromote_child (parent, N, node);\n+\tbreak;\n+      }\n+  while (parent);\n+  set_parent (node, node_type ());\n+}\n+\n+// See the comment above the declaration.\n+template<typename Accessors>\n+typename rootless_splay_tree<Accessors>::node_type\n+rootless_splay_tree<Accessors>::remove_node (node_type node)\n+{\n+  node_type replacement = parent::remove_node_internal (node);\n+  if (node_type parent = get_parent (node))\n+    set_child (parent, child_index (parent, node), replacement);\n+  else if (replacement)\n+    set_parent (replacement, node_type ());\n+  // Clear the links from NODE.\n+  set_parent (node, node_type ());\n+  set_child (node, 0, node_type ());\n+  set_child (node, 1, node_type ());\n+  return replacement;\n+}\n+\n+// See the comment above the declaration.\n+template<typename Accessors>\n+void\n+rootless_splay_tree<Accessors>::splay (node_type node)\n+{\n+  node_type child = node;\n+  node_type parent = get_parent (child);\n+  if (!parent)\n+    return;\n+\n+  do\n+    {\n+      // At this point, NODE conceptually replaces CHILD as a child of\n+      // PARENT, but we haven't yet updated PARENT accordingly.\n+      unsigned int index = child_index (parent, child);\n+      if (node_type grandparent = get_parent (parent))\n+\t{\n+\t  node_type greatgrandparent = get_parent (grandparent);\n+\t  unsigned int parent_index = child_index (grandparent, parent);\n+\t  if (index == parent_index)\n+\t    {\n+\t      promote_child (grandparent, parent_index, parent);\n+\t      promote_child (parent, index, node);\n+\t    }\n+\t  else\n+\t    {\n+\t      promote_child (parent, index, node);\n+\t      promote_child (grandparent, parent_index, node);\n+\t    }\n+\t  child = grandparent;\n+\t  parent = greatgrandparent;\n+\t}\n+      else\n+\t{\n+\t  promote_child (parent, index, node);\n+\t  break;\n+\t}\n+    }\n+  while (parent);\n+  set_parent (node, node_type ());\n+}\n+\n+// See the comment above the declaration.\n+template<typename Accessors>\n+inline void\n+rootless_splay_tree<Accessors>::splay_known_min_node (node_type node)\n+{\n+  splay_known_limit<0> (node);\n+}\n+\n+// See the comment above the declaration.\n+template<typename Accessors>\n+inline void\n+rootless_splay_tree<Accessors>::splay_known_max_node (node_type node)\n+{\n+  splay_known_limit<1> (node);\n+}\n+\n+// See the comment above the declaration.\n+template<typename Accessors>\n+template<typename DefaultResult, typename Predicate>\n+auto\n+rootless_splay_tree<Accessors>::\n+splay_and_search (node_type node, DefaultResult default_result,\n+\t\t  Predicate predicate)\n+  -> decltype (predicate (node, 0))\n+{\n+  using Result = decltype (predicate (node, 0));\n+\n+  node_type child = node;\n+  node_type parent = get_parent (child);\n+  if (!parent)\n+    return default_result;\n+\n+  do\n+    {\n+      // At this point, NODE conceptually replaces CHILD as a child of\n+      // PARENT, but we haven't yet updated PARENT accordingly.\n+      unsigned int index = child_index (parent, child);\n+      if (Result result = predicate (parent, index))\n+\t{\n+\t  set_child (parent, index, node);\n+\t  return result;\n+\t}\n+      if (node_type grandparent = get_parent (parent))\n+\t{\n+\t  node_type greatgrandparent = get_parent (grandparent);\n+\t  unsigned int parent_index = child_index (grandparent, parent);\n+\t  if (Result result = predicate (grandparent, parent_index))\n+\t    {\n+\t      set_child (parent, index, node);\n+\t      return result;\n+\t    }\n+\t  if (index == parent_index)\n+\t    {\n+\t      promote_child (grandparent, parent_index, parent);\n+\t      promote_child (parent, index, node);\n+\t    }\n+\t  else\n+\t    {\n+\t      promote_child (parent, index, node);\n+\t      promote_child (grandparent, parent_index, node);\n+\t    }\n+\t  child = grandparent;\n+\t  parent = greatgrandparent;\n+\t}\n+      else\n+\t{\n+\t  promote_child (parent, index, node);\n+\t  break;\n+\t}\n+    }\n+  while (parent);\n+  set_parent (node, node_type ());\n+  return default_result;\n+}\n+\n+// Splay NODE1 looking to see if one of its ancestors is NODE2.  If it is,\n+// return -1 if NODE1 comes before NODE2 or 1 if NODE1 comes after NODE2.\n+// Return 0 if NODE2 is not an ancestor of NODE1.\n+template<typename Accessors>\n+int\n+rootless_splay_tree<Accessors>::compare_nodes_one_way (node_type node1,\n+\t\t\t\t\t\t       node_type node2)\n+{\n+  auto compare = [&](node_type parent, unsigned int index) -> int\n+    {\n+      if (parent == node2)\n+\treturn index ? 1 : -1;\n+      return 0;\n+    };\n+  return splay_and_search (node1, 0, compare);\n+}\n+\n+// See the comment above the declaration.\n+template<typename Accessors>\n+int\n+rootless_splay_tree<Accessors>::compare_nodes (node_type node1,\n+\t\t\t\t\t       node_type node2)\n+{\n+  if (node1 == node2)\n+    return 0;\n+\n+  // Splay NODE1 looking for NODE2.\n+  int cmp = compare_nodes_one_way (node1, node2);\n+  if (cmp)\n+    return cmp;\n+\n+  // That failed, but NODE1 is now the root of the tree.  Splay NODE2\n+  // to see on which side of NODE1 it falls.\n+  cmp = compare_nodes_one_way (node2, node1);\n+  gcc_checking_assert (cmp);\n+  return -cmp;\n+}"}, {"sha": "8ec04f0876347aaba94d973416eee7042c80b1c9", "filename": "gcc/system.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0882ef6a265553c8adcc24ce9059546e84b99b/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0882ef6a265553c8adcc24ce9059546e84b99b/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=9a0882ef6a265553c8adcc24ce9059546e84b99b", "patch": "@@ -232,6 +232,9 @@ extern int errno;\n #ifdef INCLUDE_VECTOR\n # include <vector>\n #endif\n+#ifdef INCLUDE_ARRAY\n+# include <array>\n+#endif\n # include <cstring>\n # include <new>\n # include <utility>"}]}