{"sha": "9fa07b131e21a921ecc535f736882a5fb0698a9c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZhMDdiMTMxZTIxYTkyMWVjYzUzNWY3MzY4ODJhNWZiMDY5OGE5Yw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-09-15T22:48:00Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-09-15T22:48:00Z"}, "message": "re PR rtl-optimization/45593 (segfault with -Os)\n\n\tPR rtl-optimization/45593\n\t* reorg.c (relax_delay_slots): Use emit_copy_of_insn_after to re-emit\n\tinsns that were in delay slots as stand-alone insns.\n\nFrom-SVN: r164318", "tree": {"sha": "53bdda0670a317b7ee0c5d54eced29a316056e18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53bdda0670a317b7ee0c5d54eced29a316056e18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fa07b131e21a921ecc535f736882a5fb0698a9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fa07b131e21a921ecc535f736882a5fb0698a9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fa07b131e21a921ecc535f736882a5fb0698a9c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fa07b131e21a921ecc535f736882a5fb0698a9c/comments", "author": null, "committer": null, "parents": [{"sha": "06730c5d14d81a26842428dc85ff9e9849dba96f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06730c5d14d81a26842428dc85ff9e9849dba96f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06730c5d14d81a26842428dc85ff9e9849dba96f"}], "stats": {"total": 130, "additions": 112, "deletions": 18}, "files": [{"sha": "184894a0b91f5f453ee59667d3c657edce6e1e2b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fa07b131e21a921ecc535f736882a5fb0698a9c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fa07b131e21a921ecc535f736882a5fb0698a9c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9fa07b131e21a921ecc535f736882a5fb0698a9c", "patch": "@@ -1,3 +1,9 @@\n+2010-09-15  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR rtl-optimization/45593\n+\t* reorg.c (relax_delay_slots): Use emit_copy_of_insn_after to re-emit\n+\tinsns that were in delay slots as stand-alone insns.\n+\n 2010-09-15  Ian Lance Taylor  <iant@google.com>\n \n \t* incpath.c (remove_duplicates): If name is not a directory, issue"}, {"sha": "7776fa20c7ebe75543969389c6083f0080dba16f", "filename": "gcc/reorg.c", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fa07b131e21a921ecc535f736882a5fb0698a9c/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fa07b131e21a921ecc535f736882a5fb0698a9c/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=9fa07b131e21a921ecc535f736882a5fb0698a9c", "patch": "@@ -3459,23 +3459,24 @@ relax_delay_slots (rtx first)\n \t     We do this by deleting the INSN containing the SEQUENCE, then\n \t     re-emitting the insns separately, and then deleting the RETURN.\n \t     This allows the count of the jump target to be properly\n-\t     decremented.  */\n+\t     decremented.\n \n-\t  /* Clear the from target bit, since these insns are no longer\n+\t     Note that we need to change the INSN_UID of the re-emitted insns\n+\t     since it is used to hash the insns for mark_target_live_regs and\n+\t     the re-emitted insns will no longer be wrapped up in a SEQUENCE.\n+\n+\t     Clear the from target bit, since these insns are no longer\n \t     in delay slots.  */\n \t  for (i = 0; i < XVECLEN (pat, 0); i++)\n \t    INSN_FROM_TARGET_P (XVECEXP (pat, 0, i)) = 0;\n \n \t  trial = PREV_INSN (insn);\n \t  delete_related_insns (insn);\n \t  gcc_assert (GET_CODE (pat) == SEQUENCE);\n-\t  after = trial;\n-\t  for (i = 0; i < XVECLEN (pat, 0); i++)\n-\t    {\n-\t      rtx this_insn = XVECEXP (pat, 0, i);\n-\t      add_insn_after (this_insn, after, NULL);\n-\t      after = this_insn;\n-\t    }\n+\t  add_insn_after (delay_insn, trial, NULL);\n+\t  after = delay_insn;\n+\t  for (i = 1; i < XVECLEN (pat, 0); i++)\n+\t    after = emit_copy_of_insn_after (XVECEXP (pat, 0, i), after);\n \t  delete_scheduled_jump (delay_insn);\n \t  continue;\n \t}\n@@ -3580,23 +3581,24 @@ relax_delay_slots (rtx first)\n \t     We do this by deleting the INSN containing the SEQUENCE, then\n \t     re-emitting the insns separately, and then deleting the jump.\n \t     This allows the count of the jump target to be properly\n-\t     decremented.  */\n+\t     decremented.\n \n-\t  /* Clear the from target bit, since these insns are no longer\n+\t     Note that we need to change the INSN_UID of the re-emitted insns\n+\t     since it is used to hash the insns for mark_target_live_regs and\n+\t     the re-emitted insns will no longer be wrapped up in a SEQUENCE.\n+\n+\t     Clear the from target bit, since these insns are no longer\n \t     in delay slots.  */\n \t  for (i = 0; i < XVECLEN (pat, 0); i++)\n \t    INSN_FROM_TARGET_P (XVECEXP (pat, 0, i)) = 0;\n \n \t  trial = PREV_INSN (insn);\n \t  delete_related_insns (insn);\n \t  gcc_assert (GET_CODE (pat) == SEQUENCE);\n-\t  after = trial;\n-\t  for (i = 0; i < XVECLEN (pat, 0); i++)\n-\t    {\n-\t      rtx this_insn = XVECEXP (pat, 0, i);\n-\t      add_insn_after (this_insn, after, NULL);\n-\t      after = this_insn;\n-\t    }\n+\t  add_insn_after (delay_insn, trial, NULL);\n+\t  after = delay_insn;\n+\t  for (i = 1; i < XVECLEN (pat, 0); i++)\n+\t    after = emit_copy_of_insn_after (XVECEXP (pat, 0, i), after);\n \t  delete_scheduled_jump (delay_insn);\n \t  continue;\n \t}"}, {"sha": "b1f87446da02a1a73d4dff0a5f97281c5539bbaf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fa07b131e21a921ecc535f736882a5fb0698a9c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fa07b131e21a921ecc535f736882a5fb0698a9c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9fa07b131e21a921ecc535f736882a5fb0698a9c", "patch": "@@ -1,3 +1,7 @@\n+2010-09-15  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.c-torture/compile/20100915-1.c: New test.\n+\n 2010-09-15  Martin Jambor  <mjambor@suse.cz>\n \n \tPR middle-end/45644"}, {"sha": "04f6ab0fd70a7df0ad958d43734f7f1526c4a952", "filename": "gcc/testsuite/gcc.c-torture/compile/20100915-1.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fa07b131e21a921ecc535f736882a5fb0698a9c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20100915-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fa07b131e21a921ecc535f736882a5fb0698a9c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20100915-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20100915-1.c?ref=9fa07b131e21a921ecc535f736882a5fb0698a9c", "patch": "@@ -0,0 +1,82 @@\n+/* PR rtl-optimization/45593 */\n+/* Testcase by Arnaud Lacombe <lacombar@gmail.com> */\n+\n+typedef unsigned int __u32;\n+typedef __u32 __be32;\n+static inline __attribute__((always_inline)) int __attribute__((__cold__)) printk(const char *s, ...) { return 0; }\n+typedef struct journal_s journal_t;\n+typedef struct journal_header_s\n+{\n+ __be32 h_magic;\n+ __be32 h_blocktype;\n+ __be32 h_sequence;\n+} journal_header_t;\n+typedef struct journal_superblock_s\n+{\n+ journal_header_t s_header;\n+ __be32 s_blocksize;\n+ __be32 s_maxlen;\n+} journal_superblock_t;\n+struct journal_s\n+{\n+ struct buffer_head *j_sb_buffer;\n+ journal_superblock_t *j_superblock;\n+ int j_format_version;\n+ int j_blocksize;\n+ unsigned int j_maxlen;\n+};\n+static void journal_fail_superblock (journal_t *journal)\n+{\n+ journal->j_sb_buffer = ((void *)0);\n+}\n+static int journal_get_superblock(journal_t *journal)\n+{\n+ struct buffer_head *bh;\n+ journal_superblock_t *sb;\n+ int err = -100;\n+ bh = journal->j_sb_buffer;\n+ if (!buffer_uptodate(bh)) {\n+  if (!buffer_uptodate(bh)) {\n+   printk (\"JBD: IO error reading journal superblock\\n\");\n+   goto out;\n+  }\n+ }\n+ err = -101;\n+ if (sb->s_header.h_magic != (( __be32)(__u32)(0)) ||\n+     sb->s_blocksize != (( __be32)(__u32)(journal->j_blocksize))) {\n+  printk(\"JBD: no valid journal superblock found\\n\");\n+  goto out;\n+ }\n+ switch((( __u32)(__be32)(sb->s_header.h_blocktype))) {\n+ case 0:\n+ case 1:\n+  break;\n+ default:\n+  goto out;\n+ }\n+ if ((( __u32)(__be32)(sb->s_maxlen)) < journal->j_maxlen)\n+  journal->j_maxlen = (( __u32)(__be32)(sb->s_maxlen));\n+ else if ((( __u32)(__be32)(sb->s_maxlen)) > journal->j_maxlen) {\n+  printk (\"JBD: journal file too short\\n\");\n+  goto out;\n+ }\n+ return 0;\n+out:\n+ journal_fail_superblock(journal);\n+ return err;\n+}\n+static int load_superblock(journal_t *journal)\n+{\n+ journal_get_superblock(journal);\n+ return 0;\n+}\n+int jbd2_journal_update_format (journal_t *journal)\n+{\n+ journal_get_superblock(journal);\n+ return 0;\n+}\n+int jbd2_journal_wipe(journal_t *journal, int write)\n+{\n+ load_superblock(journal);\n+ return 0;\n+}"}]}