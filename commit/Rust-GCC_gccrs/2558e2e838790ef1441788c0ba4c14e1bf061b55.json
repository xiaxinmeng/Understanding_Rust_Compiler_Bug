{"sha": "2558e2e838790ef1441788c0ba4c14e1bf061b55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjU1OGUyZTgzODc5MGVmMTQ0MTc4OGMwYmE0YzE0ZTFiZjA2MWI1NQ==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2014-01-11T18:57:20Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2014-01-11T18:57:20Z"}, "message": "re PR fortran/59700 (Misleading/buggy runtime error message: Bad integer for item 0 in list input)\n\n2014-01-11  Jerry DeLisle  <jvdelisle@gcc.gnu>\n\t    Dominique d'Humieres  <dominiq@lps.ens.fr>\n\t    Steven G. Kargl  <kargl@gcc.gnu.org>\n\n\tPR libfortran/59700\n\tPR libfortran/59764\n\t* io/io.h (struct st_parameter_dt): Assign expanded_read flag to\n\tunused bit. Define new variable line_buffer_pos.\n\t* io/list_read.c (free_saved, next_char, l_push_char,\n\tread_logical, read_real): Replace use of item_count with\n\tline_buffer_pos for line_buffer look ahead.\n\t(read_logical, read_integer, parse_real, read_real, check_type):\n\tAdjust location of free_line to after generating error messages\n\tto retain the correct item count for the message.\n\nCo-Authored-By: Dominique d'Humieres <dominiq@lps.ens.fr>\nCo-Authored-By: Steven G. Kargl <kargl@gcc.gnu.org>\n\nFrom-SVN: r206553", "tree": {"sha": "7ee42a08f421ada38d46c6736afc7fd555ce17a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ee42a08f421ada38d46c6736afc7fd555ce17a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2558e2e838790ef1441788c0ba4c14e1bf061b55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2558e2e838790ef1441788c0ba4c14e1bf061b55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2558e2e838790ef1441788c0ba4c14e1bf061b55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2558e2e838790ef1441788c0ba4c14e1bf061b55/comments", "author": null, "committer": null, "parents": [{"sha": "2c4074268983c92c1c8554b591a6877b4e92d7bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c4074268983c92c1c8554b591a6877b4e92d7bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c4074268983c92c1c8554b591a6877b4e92d7bb"}], "stats": {"total": 66, "additions": 43, "deletions": 23}, "files": [{"sha": "308ae8d0023d9a8a54354d28c01fd216c5069997", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2558e2e838790ef1441788c0ba4c14e1bf061b55/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2558e2e838790ef1441788c0ba4c14e1bf061b55/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=2558e2e838790ef1441788c0ba4c14e1bf061b55", "patch": "@@ -1,3 +1,18 @@\n+2014-01-11  Jerry DeLisle  <jvdelisle@gcc.gnu>\n+\t    Dominique d'Humieres  <dominiq@lps.ens.fr>\n+\t    Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR libfortran/59700\n+\tPR libfortran/59764\n+\t* io/io.h (struct st_parameter_dt): Assign expanded_read flag to\n+\tunused bit. Define new variable line_buffer_pos.\n+\t* io/list_read.c (free_saved, next_char, l_push_char,\n+\tread_logical, read_real): Replace use of item_count with\n+\tline_buffer_pos for line_buffer look ahead.\n+\t(read_logical, read_integer, parse_real, read_real, check_type):\n+\tAdjust location of free_line to after generating error messages\n+\tto retain the correct item count for the message. \n+\n 2014-01-02  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \tUpdate copyright years"}, {"sha": "3481c83d791b79b2bc1706d3054dd007248474b3", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2558e2e838790ef1441788c0ba4c14e1bf061b55/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2558e2e838790ef1441788c0ba4c14e1bf061b55/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=2558e2e838790ef1441788c0ba4c14e1bf061b55", "patch": "@@ -430,7 +430,10 @@ typedef struct st_parameter_dt\n \t  unsigned g0_no_blanks : 1;\n \t  /* Used to signal use of free_format_data.  */\n \t  unsigned format_not_saved : 1;\n-\t  /* 14 unused bits.  */\n+\t  /* A flag used to identify when a non-standard expanded namelist read\n+\t     has occurred.  */\n+\t  unsigned expanded_read : 1;\n+\t  /* 13 unused bits.  */\n \n \t  /* Used for ungetc() style functionality. Possible values\n \t     are an unsigned char, EOF, or EOF - 1 used to mark the\n@@ -447,9 +450,8 @@ typedef struct st_parameter_dt\n \t  char *line_buffer;\n \t  struct format_data *fmt;\n \t  namelist_info *ionml;\n-\t  /* A flag used to identify when a non-standard expanded namelist read\n-\t     has occurred.  */\n-\t  int expanded_read;\n+\t  /* Current position within the look-ahead line buffer.  */\n+\t  int line_buffer_pos;\n \t  /* Storage area for values except for strings.  Must be\n \t     large enough to hold a complex value (two reals) of the\n \t     largest kind.  */"}, {"sha": "942f311410fcfb43a4f54701021c6703b22f8d51", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2558e2e838790ef1441788c0ba4c14e1bf061b55/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2558e2e838790ef1441788c0ba4c14e1bf061b55/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=2558e2e838790ef1441788c0ba4c14e1bf061b55", "patch": "@@ -118,7 +118,7 @@ free_saved (st_parameter_dt *dtp)\n static void\n free_line (st_parameter_dt *dtp)\n {\n-  dtp->u.p.item_count = 0;\n+  dtp->u.p.line_buffer_pos = 0;\n   dtp->u.p.line_buffer_enabled = 0;\n \n   if (dtp->u.p.line_buffer == NULL)\n@@ -150,15 +150,15 @@ next_char (st_parameter_dt *dtp)\n     {\n       dtp->u.p.at_eol = 0;\n \n-      c = dtp->u.p.line_buffer[dtp->u.p.item_count];\n-      if (c != '\\0' && dtp->u.p.item_count < 64)\n+      c = dtp->u.p.line_buffer[dtp->u.p.line_buffer_pos];\n+      if (c != '\\0' && dtp->u.p.line_buffer_pos < 64)\n \t{\n-\t  dtp->u.p.line_buffer[dtp->u.p.item_count] = '\\0';\n-\t  dtp->u.p.item_count++;\n+\t  dtp->u.p.line_buffer[dtp->u.p.line_buffer_pos] = '\\0';\n+\t  dtp->u.p.line_buffer_pos++;\n \t  goto done;\n \t}\n \n-      dtp->u.p.item_count = 0;\n+      dtp->u.p.line_buffer_pos = 0;\n       dtp->u.p.line_buffer_enabled = 0;\n     }    \n \n@@ -639,7 +639,7 @@ l_push_char (st_parameter_dt *dtp, char c)\n   if (dtp->u.p.line_buffer == NULL)\n     dtp->u.p.line_buffer = xcalloc (SCRATCH_SIZE, 1);\n \n-  dtp->u.p.line_buffer[dtp->u.p.item_count++] = c;\n+  dtp->u.p.line_buffer[dtp->u.p.line_buffer_pos++] = c;\n }\n \n \n@@ -749,29 +749,33 @@ read_logical (st_parameter_dt *dtp, int length)\n \t{\n \t  dtp->u.p.nml_read_error = 1;\n \t  dtp->u.p.line_buffer_enabled = 1;\n-\t  dtp->u.p.item_count = 0;\n+\t  dtp->u.p.line_buffer_pos = 0;\n \t  return;\n \t}\n       \n     }\n \n  bad_logical:\n \n-  free_line (dtp);\n-\n   if (nml_bad_return (dtp, c))\n-    return;\n+    {\n+      free_line (dtp);\n+      return;\n+    }\n+\n \n   free_saved (dtp);\n   if (c == EOF)\n     {\n+      free_line (dtp);\n       hit_eof (dtp);\n       return;\n     }\n   else if (c != '\\n')\n     eat_line (dtp);\n   snprintf (message, MSGLEN, \"Bad logical value while reading item %d\",\n \t      dtp->u.p.item_count);\n+  free_line (dtp);\n   generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n   return;\n \n@@ -912,9 +916,9 @@ read_integer (st_parameter_dt *dtp, int length)\n   else if (c != '\\n')\n     eat_line (dtp);\n \n-  free_line (dtp);\n   snprintf (message, MSGLEN, \"Bad integer for item %d in list input\",\n \t      dtp->u.p.item_count);\n+  free_line (dtp);\n   generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n \n   return;\n@@ -1297,9 +1301,9 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)\n   else if (c != '\\n')\n     eat_line (dtp);\n \n-  free_line (dtp);\n   snprintf (message, MSGLEN, \"Bad floating point number for item %d\",\n \t      dtp->u.p.item_count);\n+  free_line (dtp);\n   generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n \n   return 1;\n@@ -1405,9 +1409,9 @@ read_complex (st_parameter_dt *dtp, void * dest, int kind, size_t size)\n   else if (c != '\\n')   \n     eat_line (dtp);\n \n-  free_line (dtp);\n   snprintf (message, MSGLEN, \"Bad complex value in item %d of list input\",\n \t      dtp->u.p.item_count);\n+  free_line (dtp);\n   generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n }\n \n@@ -1769,7 +1773,7 @@ read_real (st_parameter_dt *dtp, void * dest, int length)\n     {\n       dtp->u.p.nml_read_error = 1;\n       dtp->u.p.line_buffer_enabled = 1;\n-      dtp->u.p.item_count = 0;\n+      dtp->u.p.line_buffer_pos = 0;\n       return;\n     }\n \n@@ -1788,9 +1792,9 @@ read_real (st_parameter_dt *dtp, void * dest, int length)\n   else if (c != '\\n')\n     eat_line (dtp);\n \n-  free_line (dtp);\n   snprintf (message, MSGLEN, \"Bad real number in item %d of list input\",\n \t      dtp->u.p.item_count);\n+  free_line (dtp);\n   generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n }\n \n@@ -1805,11 +1809,10 @@ check_type (st_parameter_dt *dtp, bt type, int kind)\n \n   if (dtp->u.p.saved_type != BT_UNKNOWN && dtp->u.p.saved_type != type)\n     {\n-      free_line (dtp);\n       snprintf (message, MSGLEN, \"Read type %s where %s was expected for item %d\",\n \t\t  type_name (dtp->u.p.saved_type), type_name (type),\n \t\t  dtp->u.p.item_count);\n-\n+      free_line (dtp);\n       generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n       return 1;\n     }\n@@ -1820,13 +1823,13 @@ check_type (st_parameter_dt *dtp, bt type, int kind)\n   if ((type != BT_COMPLEX && dtp->u.p.saved_length != kind)\n       || (type == BT_COMPLEX && dtp->u.p.saved_length != kind*2))\n     {\n-      free_line (dtp);\n       snprintf (message, MSGLEN,\n \t\t  \"Read kind %d %s where kind %d is required for item %d\",\n \t\t  type == BT_COMPLEX ? dtp->u.p.saved_length / 2\n \t\t\t\t     : dtp->u.p.saved_length,\n \t\t  type_name (dtp->u.p.saved_type), kind,\n \t\t  dtp->u.p.item_count);\n+      free_line (dtp);\n       generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n       return 1;\n     }"}]}