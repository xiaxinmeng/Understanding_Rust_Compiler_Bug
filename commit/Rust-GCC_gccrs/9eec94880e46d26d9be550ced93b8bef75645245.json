{"sha": "9eec94880e46d26d9be550ced93b8bef75645245", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWVlYzk0ODgwZTQ2ZDI2ZDliZTU1MGNlZDkzYjhiZWY3NTY0NTI0NQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-05-29T19:43:37Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-05-29T19:43:37Z"}, "message": "cgraph.h (struct varpool_node_set_def, [...]): Remove unused AUX pointer.\n\n\t* cgraph.h (struct varpool_node_set_def,\n\tstruct cgraph_node_set_def): Remove unused AUX pointer.\n\t(cgraph_node_set_nonempty_p, varpool_node_set_nonempty_p): Use\n\tVEC_empty macro.\n\n\t* lto.c (bitmap vector): Remove.\n\t(lto_cgraph_node_sets,  lto_varpool_node_sets): Remove.\n\t(ltrans_partition_def): New structure.\n\t(ltrans_partition): New type and VECtor.\n\t(new_partition): New function.\n\t(add_cgraph_node_to_partition): New function.\n\t(lto_1_to_1_map): Reorganize for partitions.\n\t(lto_add_inline_clones): Remove.\n\t(lto_add_all_inlinees): Remove.\n\t(lto_promote_cross_file_statics): Use partitions.\n\t(cmp_partitions): New function.\n\t(lto_wpa_write_files): Do not call lto_add_all_inlinees;\n\tuse partitions; output files sorted by size.\n\nFrom-SVN: r160034", "tree": {"sha": "a276a5c35631e03dcead6a2f1f87fbf5ef0cfeef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a276a5c35631e03dcead6a2f1f87fbf5ef0cfeef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9eec94880e46d26d9be550ced93b8bef75645245", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eec94880e46d26d9be550ced93b8bef75645245", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9eec94880e46d26d9be550ced93b8bef75645245", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eec94880e46d26d9be550ced93b8bef75645245/comments", "author": null, "committer": null, "parents": [{"sha": "eb598ce634300e2e6633769ffda6205406169281", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb598ce634300e2e6633769ffda6205406169281", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb598ce634300e2e6633769ffda6205406169281"}], "stats": {"total": 268, "additions": 119, "deletions": 149}, "files": [{"sha": "2a43737323322314ec584b93f2e978dd0c31897c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eec94880e46d26d9be550ced93b8bef75645245/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eec94880e46d26d9be550ced93b8bef75645245/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9eec94880e46d26d9be550ced93b8bef75645245", "patch": "@@ -1,3 +1,10 @@\n+2010-05-29  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.h (struct varpool_node_set_def,\n+\tstruct cgraph_node_set_def): Remove unused AUX pointer.\n+\t(cgraph_node_set_nonempty_p, varpool_node_set_nonempty_p): Use\n+\tVEC_empty macro.\n+\n 2010-05-29  Jan Hubicka  <jh@suse.cz>\n \n \tPR middle-end/44324"}, {"sha": "5b1960f819f94d54af5384a43effb842ead748e7", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eec94880e46d26d9be550ced93b8bef75645245/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eec94880e46d26d9be550ced93b8bef75645245/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=9eec94880e46d26d9be550ced93b8bef75645245", "patch": "@@ -311,7 +311,6 @@ struct GTY(()) cgraph_node_set_def\n {\n   htab_t GTY((param_is (struct cgraph_node_set_element_def))) hashtab;\n   VEC(cgraph_node_ptr, gc) *nodes;\n-  PTR GTY ((skip)) aux;\n };\n \n typedef struct varpool_node *varpool_node_ptr;\n@@ -326,7 +325,6 @@ struct GTY(()) varpool_node_set_def\n {\n   htab_t GTY((param_is (struct varpool_node_set_element_def))) hashtab;\n   VEC(varpool_node_ptr, gc) *nodes;\n-  PTR GTY ((skip)) aux;\n };\n \n typedef struct cgraph_node_set_def *cgraph_node_set;\n@@ -869,14 +867,14 @@ struct GTY(()) constant_descriptor_tree {\n static inline bool\n cgraph_node_set_nonempty_p (cgraph_node_set set)\n {\n-  return VEC_length (cgraph_node_ptr, set->nodes);\n+  return !VEC_empty (cgraph_node_ptr, set->nodes);\n }\n \n /* Return true if set is nonempty.  */\n static inline bool\n varpool_node_set_nonempty_p (varpool_node_set set)\n {\n-  return VEC_length (varpool_node_ptr, set->nodes);\n+  return !VEC_empty (varpool_node_ptr, set->nodes);\n }\n \n /* Return true when function NODE is only called directly."}, {"sha": "6c60acd2dbf2ee5161393abd8a5f6ca6e513a7c5", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eec94880e46d26d9be550ced93b8bef75645245/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eec94880e46d26d9be550ced93b8bef75645245/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=9eec94880e46d26d9be550ced93b8bef75645245", "patch": "@@ -1,3 +1,19 @@\n+2010-05-29  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (bitmap vector): Remove.\n+\t(lto_cgraph_node_sets,  lto_varpool_node_sets): Remove.\n+\t(ltrans_partition_def): New structure.\n+\t(ltrans_partition): New type and VECtor.\n+\t(new_partition): New function.\n+\t(add_cgraph_node_to_partition): New function.\n+\t(lto_1_to_1_map): Reorganize for partitions.\n+\t(lto_add_inline_clones): Remove.\n+\t(lto_add_all_inlinees): Remove.\n+\t(lto_promote_cross_file_statics): Use partitions.\n+\t(cmp_partitions): New function.\n+\t(lto_wpa_write_files): Do not call lto_add_all_inlinees;\n+\tuse partitions; output files sorted by size.\n+\n 2010-05-29  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* Make-lang.in: Replace vec.h dependency with VEC_H."}, {"sha": "8389be1e015ef44ef5fe0d384c9b7bbab70ed074", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 94, "deletions": 145, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eec94880e46d26d9be550ced93b8bef75645245/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eec94880e46d26d9be550ced93b8bef75645245/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=9eec94880e46d26d9be550ced93b8bef75645245", "patch": "@@ -58,10 +58,6 @@ along with GCC; see the file COPYING3.  If not see\n # define O_BINARY 0\n #endif\n \n-\n-DEF_VEC_P(bitmap);\n-DEF_VEC_ALLOC_P(bitmap,heap);\n-\n static GTY(()) tree first_personality_decl;\n \n \n@@ -513,10 +509,47 @@ free_section_data (struct lto_file_decl_data *file_data ATTRIBUTE_UNUSED,\n #endif\n }\n \n-/* Vector of all cgraph node sets. */\n-static GTY (()) VEC(cgraph_node_set, gc) *lto_cgraph_node_sets;\n-static GTY (()) VEC(varpool_node_set, gc) *lto_varpool_node_sets;\n+/* Structure describing ltrans partitions.  */\n+\n+struct GTY (()) ltrans_partition_def\n+{\n+  cgraph_node_set cgraph_set;\n+  varpool_node_set varpool_set;\n+  const char * GTY ((skip)) name;\n+  int insns;\n+};\n+\n+typedef struct ltrans_partition_def *ltrans_partition;\n+DEF_VEC_P(ltrans_partition);\n+DEF_VEC_ALLOC_P(ltrans_partition,gc);\n+\n+static GTY (()) VEC(ltrans_partition, gc) *ltrans_partitions;\n+\n+/* Create new partition with name NAME.  */\n+static ltrans_partition\n+new_partition (const char *name)\n+{\n+  ltrans_partition part = GGC_NEW (struct ltrans_partition_def);\n+  part->cgraph_set = cgraph_node_set_new ();\n+  part->varpool_set = varpool_node_set_new ();\n+  part->name = name;\n+  part->insns = 0;\n+  VEC_safe_push (ltrans_partition, gc, ltrans_partitions, part);\n+  return part;\n+}\n+\n+/* Add NODE to partition as well as the inline callees into partition PART. */\n \n+static void\n+add_cgraph_node_to_partition (ltrans_partition part, struct cgraph_node *node)\n+{\n+  struct cgraph_edge *e;\n+  part->insns += node->local.inline_summary.self_size;\n+  cgraph_node_set_add (part->cgraph_set, node);\n+  for (e = node->callees; e; e = e->next_callee)\n+    if (!e->inline_failed)\n+      add_cgraph_node_to_partition (part, e->callee);\n+}\n \n /* Group cgrah nodes by input files.  This is used mainly for testing\n    right now.  */\n@@ -528,18 +561,13 @@ lto_1_to_1_map (void)\n   struct varpool_node *vnode;\n   struct lto_file_decl_data *file_data;\n   struct pointer_map_t *pmap;\n-  struct pointer_map_t *vpmap;\n-  cgraph_node_set set;\n-  varpool_node_set vset;\n+  ltrans_partition partition;\n   void **slot;\n+  int npartitions = 0;\n \n   timevar_push (TV_WHOPR_WPA);\n \n-  lto_cgraph_node_sets = VEC_alloc (cgraph_node_set, gc, 1);\n-  lto_varpool_node_sets = VEC_alloc (varpool_node_set, gc, 1);\n-\n   pmap = pointer_map_create ();\n-  vpmap = pointer_map_create ();\n \n   for (node = cgraph_nodes; node; node = node->next)\n     {\n@@ -555,146 +583,47 @@ lto_1_to_1_map (void)\n \n       slot = pointer_map_contains (pmap, file_data);\n       if (slot)\n-\tset = (cgraph_node_set) *slot;\n+\tpartition = (ltrans_partition) *slot;\n       else\n \t{\n-\t  set = cgraph_node_set_new ();\n+\t  partition = new_partition (file_data->file_name);\n \t  slot = pointer_map_insert (pmap, file_data);\n-\t  *slot = set;\n-\t  VEC_safe_push (cgraph_node_set, gc, lto_cgraph_node_sets, set);\n-\t  vset = varpool_node_set_new ();\n-\t  slot = pointer_map_insert (vpmap, file_data);\n-\t  *slot = vset;\n-\t  VEC_safe_push (varpool_node_set, gc, lto_varpool_node_sets, vset);\n+\t  *slot = partition;\n+\t  npartitions++;\n \t}\n \n-      cgraph_node_set_add (set, node);\n+      add_cgraph_node_to_partition (partition, node);\n     }\n \n   for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n     {\n       if (vnode->alias || !vnode->needed)\n \tcontinue;\n-      slot = pointer_map_contains (vpmap, file_data);\n+      slot = pointer_map_contains (pmap, file_data);\n       if (slot)\n-\tvset = (varpool_node_set) *slot;\n+\tpartition = (ltrans_partition) *slot;\n       else\n \t{\n-\t  set = cgraph_node_set_new ();\n+\t  partition = new_partition (file_data->file_name);\n \t  slot = pointer_map_insert (pmap, file_data);\n-\t  *slot = set;\n-\t  VEC_safe_push (cgraph_node_set, gc, lto_cgraph_node_sets, set);\n-\t  vset = varpool_node_set_new ();\n-\t  slot = pointer_map_insert (vpmap, file_data);\n-\t  *slot = vset;\n-\t  VEC_safe_push (varpool_node_set, gc, lto_varpool_node_sets, vset);\n+\t  *slot = partition;\n+\t  npartitions++;\n \t}\n \n-      varpool_node_set_add (vset, vnode);\n+      varpool_node_set_add (partition->varpool_set, vnode);\n     }\n \n   /* If the cgraph is empty, create one cgraph node set so that there is still\n      an output file for any variables that need to be exported in a DSO.  */\n-  if (!lto_cgraph_node_sets)\n-    {\n-      set = cgraph_node_set_new ();\n-      VEC_safe_push (cgraph_node_set, gc, lto_cgraph_node_sets, set);\n-      vset = varpool_node_set_new ();\n-      VEC_safe_push (varpool_node_set, gc, lto_varpool_node_sets, vset);\n-    }\n+  if (!npartitions)\n+    new_partition (\"empty\");\n \n   pointer_map_destroy (pmap);\n-  pointer_map_destroy (vpmap);\n \n   timevar_pop (TV_WHOPR_WPA);\n \n-  lto_stats.num_cgraph_partitions += VEC_length (cgraph_node_set, \n-\t\t\t\t\t\t lto_cgraph_node_sets);\n-}\n-\n-\n-/* Add inlined clone NODE and its master clone to SET, if NODE itself has\n-   inlined callees, recursively add the callees.  */\n-\n-static void\n-lto_add_inline_clones (cgraph_node_set set, struct cgraph_node *node,\n-\t\t       bitmap original_decls)\n-{\n-   struct cgraph_node *callee;\n-   struct cgraph_edge *edge;\n-\n-   cgraph_node_set_add (set, node);\n-\n-   /* Check to see if NODE has any inlined callee.  */\n-   for (edge = node->callees; edge != NULL; edge = edge->next_callee)\n-     {\n-\tcallee = edge->callee;\n-\tif (callee->global.inlined_to != NULL)\n-\t  lto_add_inline_clones (set, callee, original_decls);\n-     }\n-}\n-\n-/* Compute the transitive closure of inlining of SET based on the\n-   information in the callgraph.  Returns a bitmap of decls that have\n-   been inlined into SET indexed by UID.  */\n-\n-static void\n-lto_add_all_inlinees (cgraph_node_set set)\n-{\n-  cgraph_node_set_iterator csi;\n-  struct cgraph_node *node;\n-  bitmap original_nodes = lto_bitmap_alloc ();\n-  bitmap original_decls = lto_bitmap_alloc ();\n-  bool changed;\n-\n-  /* We are going to iterate SET while adding to it, mark all original\n-     nodes so that we only add node inlined to original nodes.  */\n-  for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n-    {\n-      bitmap_set_bit (original_nodes, csi_node (csi)->uid);\n-      bitmap_set_bit (original_decls, DECL_UID (csi_node (csi)->decl));\n-    }\n-\n-  /* Some of the original nodes might not be needed anymore.  \n-     Remove them.  */\n-  do\n-    {\n-      changed = false;\n-      for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n-\t{\n-\t  struct cgraph_node *inlined_to;\n-\t  node = csi_node (csi);\n-\n-\t  /* NODE was not inlined.  We still need it.  */\n-\t  if (!node->global.inlined_to)\n-\t    continue;\n-\n-\t  inlined_to = node->global.inlined_to;\n-\n-\t  /* NODE should have only one caller.  */\n-\t  gcc_assert (!node->callers->next_caller);\n-\n-\t  if (!bitmap_bit_p (original_nodes, inlined_to->uid))\n-\t    {\n-\t      bitmap_clear_bit (original_nodes, node->uid);\n-\t      cgraph_node_set_remove (set, node);\n-\t      changed = true;\n-\t    }\n-\t}\n-    }\n-  while (changed);\n-\n- /* Transitively add to SET all the inline clones for every node that\n-    has been inlined.  */\n- for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n-   {\n-     node = csi_node (csi);\n-     if (bitmap_bit_p (original_nodes, node->uid))\n-      lto_add_inline_clones (set, node, original_decls);\n-   }\n-\n-  lto_bitmap_free (original_nodes);\n-  lto_bitmap_free (original_decls);\n+  lto_stats.num_cgraph_partitions += VEC_length (ltrans_partition, \n+\t\t\t\t\t\t ltrans_partitions);\n }\n \n /* Promote variable VNODE to be static.  */\n@@ -751,11 +680,12 @@ lto_promote_cross_file_statics (void)\n \n   gcc_assert (flag_wpa);\n \n-  n_sets = VEC_length (cgraph_node_set, lto_cgraph_node_sets);\n+  n_sets = VEC_length (ltrans_partition, ltrans_partitions);\n   for (i = 0; i < n_sets; i++)\n     {\n-      set = VEC_index (cgraph_node_set, lto_cgraph_node_sets, i);\n-      vset = VEC_index (varpool_node_set, lto_varpool_node_sets, i);\n+      ltrans_partition part = VEC_index (ltrans_partition, ltrans_partitions, i);\n+      set = part->cgraph_set;\n+      vset = part->varpool_set;\n \n       /* If node has either address taken (and we have no clue from where)\n \t or it is called from other partition, it needs to be globalized.  */\n@@ -847,9 +777,21 @@ lto_promote_cross_file_statics (void)\n   pointer_set_destroy (inserted);\n }\n \n-\n static lto_file *current_lto_file;\n \n+/* Helper for qsort; compare partitions and return one with smaller size.\n+   We sort from greatest to smallest so parallel build doesn't stale on the\n+   longest compilation being executed too late.  */\n+\n+static int\n+cmp_partitions (const void *a, const void *b)\n+{\n+  const struct ltrans_partition_def *pa\n+     = *(struct ltrans_partition_def *const *)a;\n+  const struct ltrans_partition_def *pb\n+     = *(struct ltrans_partition_def *const *)b;\n+  return pb->insns - pa->insns;\n+}\n \n /* Write all output files in WPA mode and the file with the list of\n    LTRANS units.  */\n@@ -861,6 +803,7 @@ lto_wpa_write_files (void)\n   lto_file *file;\n   cgraph_node_set set;\n   varpool_node_set vset;\n+  ltrans_partition part;\n   FILE *ltrans_output_list_stream;\n   char *temp_filename;\n   size_t blen;\n@@ -878,12 +821,9 @@ lto_wpa_write_files (void)\n      compiled by LTRANS.  After this loop, only those sets that\n      contain callgraph nodes from more than one file will need to be\n      compiled by LTRANS.  */\n-  for (i = 0; VEC_iterate (cgraph_node_set, lto_cgraph_node_sets, i, set); i++)\n-    {\n-      lto_add_all_inlinees (set);\n-      lto_stats.num_output_cgraph_nodes += VEC_length (cgraph_node_ptr,\n-\t\t\t\t\t\t       set->nodes);\n-    }\n+  for (i = 0; VEC_iterate (ltrans_partition, ltrans_partitions, i, part); i++)\n+    lto_stats.num_output_cgraph_nodes += VEC_length (cgraph_node_ptr,\n+\t\t\t\t\t\t     part->cgraph_set->nodes);\n \n   /* After adding all inlinees, find out statics that need to be promoted\n      to globals because of cross-file inlining.  */\n@@ -903,16 +843,16 @@ lto_wpa_write_files (void)\n     temp_filename[blen - sizeof (\".out\") + 1] = '\\0';\n   blen = strlen (temp_filename);\n \n-  n_sets = VEC_length (cgraph_node_set, lto_cgraph_node_sets);\n+  n_sets = VEC_length (ltrans_partition, ltrans_partitions);\n+  qsort (VEC_address (ltrans_partition, ltrans_partitions), n_sets,\n+\t sizeof (ltrans_partition), cmp_partitions);\n   for (i = 0; i < n_sets; i++)\n     {\n       size_t len;\n+      ltrans_partition part = VEC_index (ltrans_partition, ltrans_partitions, i);\n \n-      set = VEC_index (cgraph_node_set, lto_cgraph_node_sets, i);\n-      vset = VEC_index (varpool_node_set, lto_varpool_node_sets, i);\n-      if (!cgraph_node_set_nonempty_p (set)\n-\t  && !varpool_node_set_nonempty_p (vset))\n-\tcontinue;\n+      set = part->cgraph_set;\n+      vset = part->varpool_set;\n \n       /* Write all the nodes in SET.  */\n       sprintf (temp_filename + blen, \"%u.o\", i);\n@@ -921,7 +861,9 @@ lto_wpa_write_files (void)\n \tfatal_error (\"lto_obj_file_open() failed\");\n \n       if (!quiet_flag)\n-\tfprintf (stderr, \" %s\", temp_filename);\n+\tfprintf (stderr, \" %s (%s %i insns)\", temp_filename, part->name, part->insns);\n+      gcc_assert (cgraph_node_set_nonempty_p (set)\n+\t\t  || varpool_node_set_nonempty_p (vset) || !i);\n \n       lto_set_current_out_file (file);\n \n@@ -1427,13 +1369,20 @@ lto_read_all_file_options (void)\n \n   /* Set the hooks to read ELF sections.  */\n   lto_set_in_hooks (NULL, get_section_data, free_section_data);\n+  if (!quiet_flag)\n+    fprintf (stderr, \"Reading command line options:\");\n \n   for (i = 0; i < num_in_fnames; i++)\n     {\n       struct lto_file_decl_data *file_data;\n       lto_file *file = lto_obj_file_open (in_fnames[i], false);\n       if (!file)\n \tbreak;\n+      if (!quiet_flag)\n+\t{\n+\t  fprintf (stderr, \" %s\", in_fnames[i]);\n+\t  fflush (stderr);\n+\t}\n \n       file_data = XCNEW (struct lto_file_decl_data);\n       file_data->file_name = file->filename;"}]}