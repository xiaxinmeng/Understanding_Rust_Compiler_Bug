{"sha": "1394aabdaac22e52aec22bc95c2202cb71749b4e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTM5NGFhYmRhYWMyMmU1MmFlYzIyYmM5NWMyMjAyY2I3MTc0OWI0ZQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-12T02:56:45Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-12T02:56:45Z"}, "message": "Renamed TREE_INLINE...\n\nRenamed TREE_INLINE, TREE_NONLOCAL, TREE_REGDECL, TREE_EXTERNAL\nto DECL_INLINE, DECL_NONLOCAL, DECL_REGISTER, DECL_EXTERNAL.\n\nFrom-SVN: r1569", "tree": {"sha": "e64a8539a9959ca2bf64518552e47818c8b26be2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e64a8539a9959ca2bf64518552e47818c8b26be2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1394aabdaac22e52aec22bc95c2202cb71749b4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1394aabdaac22e52aec22bc95c2202cb71749b4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1394aabdaac22e52aec22bc95c2202cb71749b4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1394aabdaac22e52aec22bc95c2202cb71749b4e/comments", "author": null, "committer": null, "parents": [{"sha": "a82ad57075803763e50a2fc4411086132dce9c7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a82ad57075803763e50a2fc4411086132dce9c7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a82ad57075803763e50a2fc4411086132dce9c7d"}], "stats": {"total": 130, "additions": 71, "deletions": 59}, "files": [{"sha": "27dad2aba844c67126a5a820ddaea0610341e07a", "filename": "gcc/c-aux-info.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1394aabdaac22e52aec22bc95c2202cb71749b4e/gcc%2Fc-aux-info.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1394aabdaac22e52aec22bc95c2202cb71749b4e/gcc%2Fc-aux-info.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-aux-info.c?ref=1394aabdaac22e52aec22bc95c2202cb71749b4e", "patch": "@@ -126,12 +126,12 @@ affix_data_type (type_or_decl)\n \n   for (;;)\n     {\n-      if (!strncmp (p, \"volatile\", 8))\n+      if (!strncmp (p, \"volatile \", 9))\n         {\n           p += 9;\n           continue;\n         }\n-      if (!strncmp (p, \"const\", 5))\n+      if (!strncmp (p, \"const \", 6))\n         {\n           p += 6;\n           continue;\n@@ -568,7 +568,7 @@ gen_decl (decl, is_func_definition, style)\n \n   ret_val = affix_data_type (ret_val);\n \n-  if (TREE_REGDECL (decl))\n+  if (DECL_REGISTER (decl))\n     ret_val = concat (\"register \", ret_val);\n   if (TREE_PUBLIC (decl))\n     ret_val = concat (\"extern \", ret_val);"}, {"sha": "9e76fab9d98106febf293bb85d09a27d421976ef", "filename": "gcc/c-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1394aabdaac22e52aec22bc95c2202cb71749b4e/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1394aabdaac22e52aec22bc95c2202cb71749b4e/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=1394aabdaac22e52aec22bc95c2202cb71749b4e", "patch": "@@ -196,7 +196,7 @@ decl_attributes (decl, attributes)\n \tif (TREE_CODE (decl) == FIELD_DECL)\n \t  DECL_PACKED (decl) = 1;\n \t/* We can't set DECL_PACKED for a VAR_DECL, because the bit is\n-\t   used for TREE_REGDECL.  It wouldn't mean anything anyway.  */\n+\t   used for DECL_REGISTER.  It wouldn't mean anything anyway.  */\n       }\n     else if (TREE_VALUE (a) != 0\n \t     && TREE_CODE (TREE_VALUE (a)) == TREE_LIST"}, {"sha": "08c1fe8c6318b62ae357760abf1d2af638076536", "filename": "gcc/c-decl.c", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1394aabdaac22e52aec22bc95c2202cb71749b4e/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1394aabdaac22e52aec22bc95c2202cb71749b4e/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=1394aabdaac22e52aec22bc95c2202cb71749b4e", "patch": "@@ -877,7 +877,7 @@ poplevel (keep, reverse, functionbody)\n \t{\n \t  /* If the ident. was used or addressed via a local extern decl,\n \t     don't forget that fact.  */\n-\t  if (TREE_EXTERNAL (link))\n+\t  if (DECL_EXTERNAL (link))\n \t    {\n \t      if (TREE_USED (link))\n \t\tTREE_USED (DECL_NAME (link)) = 1;\n@@ -1386,12 +1386,12 @@ duplicate_decls (newdecl, olddecl)\n \t  /* Warn if function is now inline\n \t     but was previously declared not inline and has been called.  */\n \t  if (TREE_CODE (olddecl) == FUNCTION_DECL\n-\t      && ! TREE_INLINE (olddecl) && TREE_INLINE (newdecl)\n+\t      && ! DECL_INLINE (olddecl) && DECL_INLINE (newdecl)\n \t      && TREE_USED (olddecl))\n \t    warning_with_decl (newdecl,\n \t\t\t       \"`%s' declared inline after being called\");\n \t  if (TREE_CODE (olddecl) == FUNCTION_DECL\n-\t      && ! TREE_INLINE (olddecl) && TREE_INLINE (newdecl)\n+\t      && ! DECL_INLINE (olddecl) && DECL_INLINE (newdecl)\n \t      && DECL_INITIAL (olddecl) != 0)\n \t    warning_with_decl (newdecl,\n \t\t\t       \"`%s' declared inline after its definition\");\n@@ -1500,23 +1500,23 @@ duplicate_decls (newdecl, olddecl)\n       if (! TREE_PUBLIC (olddecl))\n \tTREE_PUBLIC (DECL_NAME (olddecl)) = 0;\n     }\n-  if (TREE_EXTERNAL (newdecl))\n+  if (DECL_EXTERNAL (newdecl))\n     {\n       TREE_STATIC (newdecl) = TREE_STATIC (olddecl);\n-      TREE_EXTERNAL (newdecl) = TREE_EXTERNAL (olddecl);\n+      DECL_EXTERNAL (newdecl) = DECL_EXTERNAL (olddecl);\n       /* An extern decl does not override previous storage class.  */\n       TREE_PUBLIC (newdecl) = TREE_PUBLIC (olddecl);\n     }\n   else\n     {\n       TREE_STATIC (olddecl) = TREE_STATIC (newdecl);\n-      TREE_EXTERNAL (olddecl) = 0;\n+      DECL_EXTERNAL (olddecl) = 0;\n       TREE_PUBLIC (olddecl) = TREE_PUBLIC (newdecl);\n     }\n   /* If either decl says `inline', this fn is inline,\n      unless its definition was passed already.  */\n-  if (TREE_INLINE (newdecl) && DECL_INITIAL (olddecl) == 0)\n-    TREE_INLINE (olddecl) = 1;\n+  if (DECL_INLINE (newdecl) && DECL_INITIAL (olddecl) == 0)\n+    DECL_INLINE (olddecl) = 1;\n \n   /* Get rid of any built-in function if new arg types don't match it\n      or if we have a function definition.  */\n@@ -1575,7 +1575,7 @@ pushdecl (x)\n   if (TREE_CODE (x) == FUNCTION_DECL && DECL_INITIAL (x) == 0)\n     DECL_CONTEXT (x) = 0;\n \n-  if (warn_nested_externs && TREE_EXTERNAL (x) && b != global_binding_level\n+  if (warn_nested_externs && DECL_EXTERNAL (x) && b != global_binding_level\n       && x != IDENTIFIER_IMPLICIT_DECL (name))\n     warning (\"nested extern declaration of `%s'\", IDENTIFIER_POINTER (name));\n \n@@ -1611,7 +1611,7 @@ pushdecl (x)\n \t     warn.  But don't complain if -traditional,\n \t     since traditional compilers don't complain.  */\n \t  if (!flag_traditional && TREE_PUBLIC (name)\n-\t      && ! TREE_PUBLIC (x) && ! TREE_EXTERNAL (x)\n+\t      && ! TREE_PUBLIC (x) && ! DECL_EXTERNAL (x)\n \t      /* We used to warn also for explicit extern followed by static,\n \t\t but sometimes you need to do it that way.  */\n \t      && IDENTIFIER_IMPLICIT_DECL (name) != 0)\n@@ -1695,12 +1695,12 @@ pushdecl (x)\n \n       /* Multiple external decls of the same identifier ought to match.  */\n \n-      if (TREE_EXTERNAL (x) && IDENTIFIER_GLOBAL_VALUE (name) != 0\n-\t  && (TREE_EXTERNAL (IDENTIFIER_GLOBAL_VALUE (name))\n+      if (DECL_EXTERNAL (x) && IDENTIFIER_GLOBAL_VALUE (name) != 0\n+\t  && (DECL_EXTERNAL (IDENTIFIER_GLOBAL_VALUE (name))\n \t      || TREE_PUBLIC (IDENTIFIER_GLOBAL_VALUE (name)))\n \t  /* We get warnings about inline functions where they are defined.\n \t     Avoid duplicate warnings where they are used.  */\n-\t  && !TREE_INLINE (x))\n+\t  && !DECL_INLINE (x))\n \t{\n \t  if (! comptypes (TREE_TYPE (x),\n \t\t\t   TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (name))))\n@@ -1728,7 +1728,7 @@ pushdecl (x)\n \n       /* In PCC-compatibility mode, extern decls of vars with no current decl\n \t take effect at top level no matter where they are.  */\n-      if (flag_traditional && TREE_EXTERNAL (x)\n+      if (flag_traditional && DECL_EXTERNAL (x)\n \t  && lookup_name (name) == 0)\n \t{\n \t  tree type = TREE_TYPE (x);\n@@ -1793,11 +1793,11 @@ pushdecl (x)\n \t  /* If this decl is `static' and an `extern' was seen previously,\n \t     that is erroneous.  */\n \t  if (TREE_PUBLIC (name)\n-\t      && ! TREE_PUBLIC (x) && ! TREE_EXTERNAL (x))\n+\t      && ! TREE_PUBLIC (x) && ! DECL_EXTERNAL (x))\n \t    {\n \t      /* Okay to declare an ANSI built-in as inline static.  */\n \t      if (t != 0 && DECL_BUILT_IN (t)\n-\t\t  && TREE_INLINE (x))\n+\t\t  && DECL_INLINE (x))\n \t\t;\n \t      /* Okay to declare a non-ANSI built-in as anything.  */\n \t      else if (t != 0 && DECL_BUILT_IN_NONANSI (t))\n@@ -1820,7 +1820,7 @@ pushdecl (x)\n \t  /* If this is an extern function declaration, see if we\n \t     have a global definition for the function.  */\n \t  if (oldlocal == 0\n-\t      && TREE_EXTERNAL (x) && !TREE_INLINE (x)\n+\t      && DECL_EXTERNAL (x) && !DECL_INLINE (x)\n \t      && oldglobal != 0\n \t      && TREE_CODE (x) == FUNCTION_DECL\n \t      && TREE_CODE (oldglobal) == FUNCTION_DECL)\n@@ -1830,7 +1830,7 @@ pushdecl (x)\n \t\t\t       TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (name))))\n \t\tpedwarn_with_decl (x, \"local declaration of `%s' doesn't match global one\");\n \t      /* If the global one is inline, make the local one inline.  */\n-\t      else if (TREE_INLINE (oldglobal)\n+\t      else if (DECL_INLINE (oldglobal)\n \t\t       || DECL_BUILT_IN (oldglobal)\n \t\t       || (TYPE_ARG_TYPES (TREE_TYPE (oldglobal)) != 0\n \t\t\t   && TYPE_ARG_TYPES (TREE_TYPE (x)) == 0))\n@@ -1843,7 +1843,7 @@ pushdecl (x)\n \t     have been static.  */\n \t  if (oldlocal == 0 && oldglobal != 0\n \t      && !TREE_PUBLIC (oldglobal)\n-\t      && TREE_EXTERNAL (x) && TREE_PUBLIC (x))\n+\t      && DECL_EXTERNAL (x) && TREE_PUBLIC (x))\n \t    warning (\"`%s' locally external but globally static\",\n \t\t     IDENTIFIER_POINTER (name));\n #endif\n@@ -1853,14 +1853,14 @@ pushdecl (x)\n \t     then if we later have a file-scope decl it must not be static.  */\n \t  if (oldlocal == 0\n \t      && oldglobal == 0\n-\t      && TREE_EXTERNAL (x)\n+\t      && DECL_EXTERNAL (x)\n \t      && TREE_PUBLIC (x))\n \t    {\n \t      TREE_PUBLIC (name) = 1;\n \t    }\n \n \t  /* Warn if shadowing an argument at the top level of the body.  */\n-\t  if (oldlocal != 0 && !TREE_EXTERNAL (x)\n+\t  if (oldlocal != 0 && !DECL_EXTERNAL (x)\n \t      /* This warning doesn't apply to the parms of a nested fcn.  */\n \t      && ! current_binding_level->parm_flag\n \t      /* Check that this is one level down from the parms.  */\n@@ -1878,7 +1878,7 @@ pushdecl (x)\n \t    }\n \n \t  /* Maybe warn if shadowing something else.  */\n-\t  else if (warn_shadow && !TREE_EXTERNAL (x)\n+\t  else if (warn_shadow && !DECL_EXTERNAL (x)\n \t\t   /* No shadow warnings for internally generated vars.  */\n \t\t   && !DECL_IGNORED_P (x)\n \t\t   /* No shadow warnings for vars made for inlining.  */\n@@ -1968,7 +1968,7 @@ implicitly_declare (functionid)\n   /* Warn once of an implicit declaration.  */\n   implicit_warning = (IDENTIFIER_IMPLICIT_DECL (functionid) == 0);\n \n-  TREE_EXTERNAL (decl) = 1;\n+  DECL_EXTERNAL (decl) = 1;\n   TREE_PUBLIC (decl) = 1;\n \n   /* Record that we have an implicit decl and this is it.  */\n@@ -2026,16 +2026,16 @@ redeclaration_error_message (newdecl, olddecl)\n       if (DECL_INITIAL (olddecl) != 0 && DECL_INITIAL (newdecl) != 0\n \t  /* However, defining once as extern inline and a second\n \t     time in another way is ok.  */\n-\t  && !(TREE_INLINE (olddecl) && TREE_EXTERNAL (olddecl)\n-\t       && !(TREE_INLINE (newdecl) && TREE_EXTERNAL (newdecl))))\n+\t  && !(DECL_INLINE (olddecl) && DECL_EXTERNAL (olddecl)\n+\t       && !(DECL_INLINE (newdecl) && DECL_EXTERNAL (newdecl))))\n \treturn \"redefinition of `%s'\";\n       return 0;\n     }\n   else if (current_binding_level == global_binding_level)\n     {\n       /* Objects declared at top level:  */\n       /* If at least one is a reference, it's ok.  */\n-      if (TREE_EXTERNAL (newdecl) || TREE_EXTERNAL (olddecl))\n+      if (DECL_EXTERNAL (newdecl) || DECL_EXTERNAL (olddecl))\n \treturn 0;\n       /* Reject two definitions.  */\n       if (DECL_INITIAL (olddecl) != 0 && DECL_INITIAL (newdecl) != 0)\n@@ -2054,7 +2054,7 @@ redeclaration_error_message (newdecl, olddecl)\n       /* Objects declared with block scope:  */\n       /* Reject two definitions, and reject a definition\n \t together with an external reference.  */\n-      if (!(TREE_EXTERNAL (newdecl) && TREE_EXTERNAL (olddecl)))\n+      if (!(DECL_EXTERNAL (newdecl) && DECL_EXTERNAL (olddecl)))\n \treturn \"redeclaration of `%s'\";\n       return 0;\n     }\n@@ -2754,7 +2754,7 @@ builtin_function (name, type, function_code, library_name)\n      char *library_name;\n {\n   tree decl = build_decl (FUNCTION_DECL, get_identifier (name), type);\n-  TREE_EXTERNAL (decl) = 1;\n+  DECL_EXTERNAL (decl) = 1;\n   TREE_PUBLIC (decl) = 1;\n   /* If -traditional, permit redefining a builtin function any way you like.\n      (Though really, if the program redefines these functions,\n@@ -2967,12 +2967,12 @@ start_decl (declarator, declspecs, initialized)\n     {\n #if 0  /* Seems redundant with grokdeclarator.  */\n       if (current_binding_level != global_binding_level\n-\t  && TREE_EXTERNAL (decl)\n+\t  && DECL_EXTERNAL (decl)\n \t  && TREE_CODE (decl) != FUNCTION_DECL)\n \twarning (\"declaration of `%s' has `extern' and is initialized\",\n \t\t IDENTIFIER_POINTER (DECL_NAME (decl)));\n #endif\n-      TREE_EXTERNAL (decl) = 0;\n+      DECL_EXTERNAL (decl) = 0;\n       if (current_binding_level == global_binding_level)\n \tTREE_STATIC (decl) = 1;\n \n@@ -3074,7 +3074,7 @@ finish_decl (decl, init, asmspec_tree)\n \t   /* Even if pedantic, an external linkage array\n \t      may have incomplete type at first.  */\n \t   ? pedantic && !TREE_PUBLIC (decl)\n-\t   : !TREE_EXTERNAL (decl));\n+\t   : !DECL_EXTERNAL (decl));\n       int failure\n \t= complete_array_type (type, DECL_INITIAL (decl), do_default);\n \n@@ -3089,7 +3089,7 @@ finish_decl (decl, init, asmspec_tree)\n \t  if (do_default)\n \t    error_with_decl (decl, \"array size missing in `%s'\");\n \t  else if (!pedantic && TREE_STATIC (decl))\n-\t    TREE_EXTERNAL (decl) = 1;\n+\t    DECL_EXTERNAL (decl) = 1;\n \t}\n \n       if (pedantic && TYPE_DOMAIN (type) != 0\n@@ -3111,15 +3111,15 @@ finish_decl (decl, init, asmspec_tree)\n \t  if (! (TREE_PUBLIC (decl) && DECL_INITIAL (decl) == 0))\n \t    error_with_decl (decl, \"storage size of `%s' isn't known\");\n \t}\n-      else if (!TREE_EXTERNAL (decl) && DECL_SIZE (decl) == 0)\n+      else if (!DECL_EXTERNAL (decl) && DECL_SIZE (decl) == 0)\n \t{\n \t  /* An automatic variable with an incomplete type:\n \t     that is an error.  */\n \t  error_with_decl (decl, \"storage size of `%s' isn't known\");\n \t  TREE_TYPE (decl) = error_mark_node;\n \t}\n \n-      if ((TREE_EXTERNAL (decl) || TREE_STATIC (decl))\n+      if ((DECL_EXTERNAL (decl) || TREE_STATIC (decl))\n \t  && DECL_SIZE (decl) != 0\n \t  && TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST)\n \terror_with_decl (decl, \"storage size of `%s' isn't constant\");\n@@ -3155,7 +3155,7 @@ finish_decl (decl, init, asmspec_tree)\n \t  /* Recompute the RTL of a local array now\n \t     if it used to be an incomplete type.  */\n \t  if (was_incomplete\n-\t      && ! TREE_STATIC (decl) && ! TREE_EXTERNAL (decl))\n+\t      && ! TREE_STATIC (decl) && ! DECL_EXTERNAL (decl))\n \t    {\n \t      /* If we used it already as memory, it must stay in memory.  */\n \t      TREE_ADDRESSABLE (decl) = TREE_USED (decl);\n@@ -4118,7 +4118,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t   and we use it for forward declarations for nested functions.  */\n \tif (!(specbits & (1 << (int) RID_AUTO))\n \t    || current_binding_level == global_binding_level)\n-\t  TREE_EXTERNAL (decl) = 1;\n+\t  DECL_EXTERNAL (decl) = 1;\n \t/* Record absence of global scope for `static' or `auto'.  */\n \tTREE_PUBLIC (decl)\n \t  = !(specbits & ((1 << (int) RID_STATIC) | (1 << (int) RID_AUTO)));\n@@ -4133,7 +4133,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t      warning (\"inline declaration ignored for function with `...'\");\n \t    else\n \t      /* Assume that otherwise the function can be inlined.  */\n-\t      TREE_INLINE (decl) = 1;\n+\t      DECL_INLINE (decl) = 1;\n \n \t    if (specbits & (1 << (int) RID_EXTERN))\n \t      current_extern_inline = 1;\n@@ -4162,7 +4162,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t  pedwarn_with_decl (decl, \"variable `%s' declared `inline'\");\n \n \t/* An uninitialized decl with `extern' is a reference.  */\n-\tTREE_EXTERNAL (decl)\n+\tDECL_EXTERNAL (decl)\n \t  = !initialized && (specbits & (1 << (int) RID_EXTERN));\n \t/* At top level, the presence of a `static' or `register' storage\n \t   class specifier, or the absence of all storage class specifiers\n@@ -4173,21 +4173,21 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t    TREE_PUBLIC (decl)\n \t      = !(specbits\n \t\t  & ((1 << (int) RID_STATIC) | (1 << (int) RID_REGISTER)));\n-\t    TREE_STATIC (decl) = ! TREE_EXTERNAL (decl);\n+\t    TREE_STATIC (decl) = ! DECL_EXTERNAL (decl);\n \t  }\n \t/* Not at top level, only `static' makes a static definition.  */\n \telse\n \t  {\n \t    TREE_STATIC (decl) = (specbits & (1 << (int) RID_STATIC)) != 0;\n-\t    TREE_PUBLIC (decl) = TREE_EXTERNAL (decl);\n+\t    TREE_PUBLIC (decl) = DECL_EXTERNAL (decl);\n \t  }\n       }\n \n     /* Record `register' declaration for warnings on &\n        and in case doing stupid register allocation.  */\n \n     if (specbits & (1 << (int) RID_REGISTER))\n-      TREE_REGDECL (decl) = 1;\n+      DECL_REGISTER (decl) = 1;\n \n     /* Record constancy and volatility.  */\n \n@@ -5177,10 +5177,10 @@ start_function (declspecs, declarator, nested)\n     warning_with_decl (decl1, \"`%s' was used with no prototype before its definition\");\n \n   /* This is a definition, not a reference.\n-     So normally clear TREE_EXTERNAL.\n+     So normally clear DECL_EXTERNAL.\n      However, `extern inline' acts like a declaration\n-     except for defining how to inline.  So set TREE_EXTERNAL in that case.  */\n-  TREE_EXTERNAL (decl1) = current_extern_inline;\n+     except for defining how to inline.  So set DECL_EXTERNAL in that case.  */\n+  DECL_EXTERNAL (decl1) = current_extern_inline;\n \n   /* This function exists in static storage.\n      (This does not mean `static' in the C sense!)  */"}, {"sha": "a0264ebdb46fea5d34bda44ec63c14bb133b9ca6", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1394aabdaac22e52aec22bc95c2202cb71749b4e/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1394aabdaac22e52aec22bc95c2202cb71749b4e/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=1394aabdaac22e52aec22bc95c2202cb71749b4e", "patch": "@@ -1200,7 +1200,7 @@ build_array_ref (array, index)\n \n       if (pedantic && !lvalue_p (array))\n \t{\n-\t  if (TREE_REGDECL (array))\n+\t  if (DECL_REGISTER (array))\n \t    pedwarn (\"ANSI C forbids subscripting `register' array\");\n \t  else\n \t    pedwarn (\"ANSI C forbids subscripting non-lvalue array\");\n@@ -1211,7 +1211,7 @@ build_array_ref (array, index)\n \t  tree foo = array;\n \t  while (TREE_CODE (foo) == COMPONENT_REF)\n \t    foo = TREE_OPERAND (foo, 0);\n-\t  if (TREE_CODE (foo) == VAR_DECL && TREE_REGDECL (foo))\n+\t  if (TREE_CODE (foo) == VAR_DECL && DECL_REGISTER (foo))\n \t    pedwarn (\"ANSI C forbids subscripting non-lvalue array\");\n \t}\n \n@@ -3206,7 +3206,7 @@ convert_sequence (conversions, arg)\n \n /* Return nonzero if REF is an lvalue valid for this language.\n    Lvalues can be assigned, unless their type has TYPE_READONLY.\n-   Lvalues can have their address taken, unless they have TREE_REGDECL.  */\n+   Lvalues can have their address taken, unless they have DECL_REGISTER.  */\n \n int\n lvalue_p (ref)\n@@ -3353,8 +3353,8 @@ mark_addressable (exp)\n       case CONST_DECL:\n       case PARM_DECL:\n       case RESULT_DECL:\n-\tif (TREE_REGDECL (x) && !TREE_ADDRESSABLE (x)\n-\t    && TREE_NONLOCAL (x))\n+\tif (DECL_REGISTER (x) && !TREE_ADDRESSABLE (x)\n+\t    && DECL_NONLOCAL (x))\n \t  {\n \t    if (TREE_PUBLIC (x))\n \t      {\n@@ -3365,7 +3365,7 @@ mark_addressable (exp)\n \t    pedwarn (\"register variable `%s' used in nested function\",\n \t\t     IDENTIFIER_POINTER (DECL_NAME (x)));\n \t  }\n-\telse if (TREE_REGDECL (x) && !TREE_ADDRESSABLE (x))\n+\telse if (DECL_REGISTER (x) && !TREE_ADDRESSABLE (x))\n \t  {\n \t    if (TREE_PUBLIC (x))\n \t      {\n@@ -4708,7 +4708,19 @@ digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n \t\t  \" `%s'\", ofwhat);\n \t      return error_mark_node;\n \t    }\n-\t  inside_init = element;\n+\t  else\n+\t    {\n+\t      /* Deal with extra levels of {...}.  */\n+\t      if (TREE_CODE (element) == CONSTRUCTOR\n+\t\t  && TREE_TYPE (element) == 0)\n+\t\t{\n+\t\t  error_init (\n+\t\t\t      \"initializer for scalar%s requires one element\",\n+\t\t\t      \" `%s'\", ofwhat);\n+\t\t  return error_mark_node;\n+\t\t}\n+\t      inside_init = element;\n+\t    }\n \t}\n \n #if 0  /* A non-raw constructor is an actual expression.  */"}, {"sha": "e65b2280786ef39079ed166f486d8d844c1b30aa", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1394aabdaac22e52aec22bc95c2202cb71749b4e/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1394aabdaac22e52aec22bc95c2202cb71749b4e/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=1394aabdaac22e52aec22bc95c2202cb71749b4e", "patch": "@@ -767,12 +767,12 @@ struct tree_type\n /* In a VAR_DECL or FUNCTION_DECL,\n    nonzero means external reference:\n    do not allocate storage, and refer to a definition elsewhere.  */\n-#define TREE_EXTERNAL(NODE) ((NODE)->decl.external_flag)\n+#define DECL_EXTERNAL(NODE) ((NODE)->decl.external_flag)\n \n /* In VAR_DECL and PARM_DECL nodes, nonzero means declared `register'.\n    In LABEL_DECL nodes, nonzero means that an error message about\n    jumping into such a binding contour has been printed for this label.  */\n-#define TREE_REGDECL(NODE) ((NODE)->decl.regdecl_flag)\n+#define DECL_REGISTER(NODE) ((NODE)->decl.regdecl_flag)\n /* In a FIELD_DECL, indicates this field should be bit-packed.  */\n #define DECL_PACKED(NODE) ((NODE)->decl.regdecl_flag)\n \n@@ -783,11 +783,11 @@ struct tree_type\n \n    Also set in some languages for variables, etc., outside the normal\n    lexical scope, such as class instance variables.  */\n-#define TREE_NONLOCAL(NODE) ((NODE)->decl.nonlocal_flag)\n+#define DECL_NONLOCAL(NODE) ((NODE)->decl.nonlocal_flag)\n \n /* Nonzero in a FUNCTION_DECL means this function can be substituted\n    where it is called.  */\n-#define TREE_INLINE(NODE) ((NODE)->decl.inline_flag)\n+#define DECL_INLINE(NODE) ((NODE)->decl.inline_flag)\n \n /* Nonzero in a FUNCTION_DECL means this is a built-in function\n    that is not specified by ansi C and that users are supposed to be allowed"}]}