{"sha": "82b8244c51cbf71e28f53a0e7e998aff924c36e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJiODI0NGM1MWNiZjcxZTI4ZjUzYTBlN2U5OThhZmY5MjRjMzZlNw==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2006-02-12T19:59:32Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2006-02-12T19:59:32Z"}, "message": "re PR libfortran/25949 (Unbounded I/O buffer memory usage for formatted IO)\n\n2006-02-12  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\tPR libgfortran/25949\n\t* io/io.h: Add set function pointer to struct stream.  \n\t* io/unix.c (fd_seek): Only update offset, don't seek.\n\t(fd_sset): New function.\n\t(fd_read): Call lseek directly if necessary.\n\t(fd_write): Likewise.\n\t(fd_open): Set pointer to fd_sset.\n\t(mem_set): New function.\n\t(open_internal): Set pointer to mem_set.\n\t* io/transfer.c (write_block_direct): Rename to write_buf, add\n\terror return, non-pointer length argument.\n\t(unformatted_write): Update to use write_buf.\n\t(us_write): Simplify by using swrite instead of salloc_w.\n\t(write_us_marker): New function.\n\t(new_record_w): Use sset instead of memset, use write_us_marker,\n\tsimplify by using swrite instead of salloc_w.\n\nFrom-SVN: r110895", "tree": {"sha": "ca366a0096c08065ac811e843aec247485318297", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca366a0096c08065ac811e843aec247485318297"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82b8244c51cbf71e28f53a0e7e998aff924c36e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82b8244c51cbf71e28f53a0e7e998aff924c36e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82b8244c51cbf71e28f53a0e7e998aff924c36e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82b8244c51cbf71e28f53a0e7e998aff924c36e7/comments", "author": null, "committer": null, "parents": [{"sha": "5b0b72518b76d75ad93ac95e6e05e772124085df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b0b72518b76d75ad93ac95e6e05e772124085df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b0b72518b76d75ad93ac95e6e05e772124085df"}], "stats": {"total": 225, "additions": 139, "deletions": 86}, "files": [{"sha": "0876d0dced91cfc9b066ede64606d0141ebb56d0", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b8244c51cbf71e28f53a0e7e998aff924c36e7/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b8244c51cbf71e28f53a0e7e998aff924c36e7/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=82b8244c51cbf71e28f53a0e7e998aff924c36e7", "patch": "@@ -1,3 +1,22 @@\n+2006-02-12  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\tPR libgfortran/25949\n+\t* io/io.h: Add set function pointer to struct stream.  \n+\t* io/unix.c (fd_seek): Only update offset, don't seek.\n+\t(fd_sset): New function.\n+\t(fd_read): Call lseek directly if necessary.\n+\t(fd_write): Likewise.\n+\t(fd_open): Set pointer to fd_sset.\n+\t(mem_set): New function.\n+\t(open_internal): Set pointer to mem_set.\n+\t* io/transfer.c (write_block_direct): Rename to write_buf, add\n+\terror return, non-pointer length argument.\n+\t(unformatted_write): Update to use write_buf.\n+\t(us_write): Simplify by using swrite instead of salloc_w.\n+\t(write_us_marker): New function.\n+\t(new_record_w): Use sset instead of memset, use write_us_marker,\n+\tsimplify by using swrite instead of salloc_w.\n+\n 2006-02-08  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \tPR libfortran/25425"}, {"sha": "0d2d795e1988ef4b838226187d9f7915642337d0", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b8244c51cbf71e28f53a0e7e998aff924c36e7/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b8244c51cbf71e28f53a0e7e998aff924c36e7/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=82b8244c51cbf71e28f53a0e7e998aff924c36e7", "patch": "@@ -62,6 +62,7 @@ typedef struct stream\n   try (*truncate) (struct stream *);\n   int (*read) (struct stream *, void *, size_t *);\n   int (*write) (struct stream *, const void *, size_t *);\n+  try (*set) (struct stream *, int, size_t);\n }\n stream;\n \n@@ -82,6 +83,8 @@ stream;\n #define sread(s, buf, nbytes) ((s)->read)(s, buf, nbytes)\n #define swrite(s, buf, nbytes) ((s)->write)(s, buf, nbytes)\n \n+#define sset(s, c, n) ((s)->set)(s, c, n)\n+\n /* The array_loop_spec contains the variables for the loops over index ranges\n    that are encountered.  Since the variables can be negative, ssize_t\n    is used.  */"}, {"sha": "093852a99ec7f856fc50eeff0005f475bf723c62", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 62, "deletions": 76, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b8244c51cbf71e28f53a0e7e998aff924c36e7/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b8244c51cbf71e28f53a0e7e998aff924c36e7/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=82b8244c51cbf71e28f53a0e7e998aff924c36e7", "patch": "@@ -377,22 +377,32 @@ write_block (st_parameter_dt *dtp, int length)\n }\n \n \n-/* Writes a block directly without necessarily allocating space in a\n-   buffer.  */\n+/* High level interface to swrite(), taking care of errors.  */\n \n-static void\n-write_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n+static try\n+write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n {\n-  if (dtp->u.p.current_unit->bytes_left < *nbytes)\n-    generate_error (&dtp->common, ERROR_EOR, NULL);\n+  if (dtp->u.p.current_unit->bytes_left < nbytes)\n+    {\n+      generate_error (&dtp->common, ERROR_EOR, NULL);\n+      return FAILURE;\n+    }\n \n-  dtp->u.p.current_unit->bytes_left -= (gfc_offset) *nbytes;\n+  dtp->u.p.current_unit->bytes_left -= (gfc_offset) nbytes;\n \n-  if (swrite (dtp->u.p.current_unit->s, buf, nbytes) != 0)\n-    generate_error (&dtp->common, ERROR_OS, NULL);\n+  if (swrite (dtp->u.p.current_unit->s, buf, &nbytes) != 0)\n+    {\n+      generate_error (&dtp->common, ERROR_OS, NULL);\n+      return FAILURE;\n+    }\n \n   if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n-    *dtp->size += (GFC_INTEGER_4) *nbytes;\n+    {\n+      *dtp->size += (GFC_INTEGER_4) nbytes;\n+      return FAILURE;\n+    }\n+\n+  return SUCCESS;\n }\n \n \n@@ -452,7 +462,7 @@ unformatted_write (st_parameter_dt *dtp, bt type,\n     {\n       size *= nelems;\n \n-      write_block_direct (dtp, source, &size);\n+      write_buf (dtp, source, size);\n     }\n   else\n     {\n@@ -479,7 +489,7 @@ unformatted_write (st_parameter_dt *dtp, bt type,\n \t{\n \t  reverse_memcpy(buffer, p, size);\n  \t  p+= size;\n-\t  write_block_direct (dtp, buffer, &sz);\n+\t  write_buf (dtp, buffer, sz);\n \t}\n     }\n }\n@@ -1253,25 +1263,18 @@ us_read (st_parameter_dt *dtp)\n static void\n us_write (st_parameter_dt *dtp)\n {\n-  char *p;\n-  int length;\n-\n-  length = sizeof (gfc_offset);\n-  p = salloc_w (dtp->u.p.current_unit->s, &length);\n+  size_t nbytes;\n+  gfc_offset dummy;\n \n-  if (p == NULL)\n-    {\n-      generate_error (&dtp->common, ERROR_OS, NULL);\n-      return;\n-    }\n+  dummy = 0;\n+  nbytes = sizeof (gfc_offset);\n \n-  memset (p, '\\0', sizeof (gfc_offset));\t/* Bogus value for now.  */\n-  if (sfree (dtp->u.p.current_unit->s) == FAILURE)\n+  if (swrite (dtp->u.p.current_unit->s, &dummy, &nbytes) != 0)\n     generate_error (&dtp->common, ERROR_OS, NULL);\n \n-  /* For sequential unformatted, we write until we have more bytes than\n-     can fit in the record markers. If disk space runs out first, it will\n-     error on the write.  */\n+  /* For sequential unformatted, we write until we have more bytes\n+     than can fit in the record markers. If disk space runs out first,\n+     it will error on the write.  */\n   dtp->u.p.current_unit->recl = max_offset;\n \n   dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n@@ -1766,6 +1769,24 @@ next_record_r (st_parameter_dt *dtp)\n }\n \n \n+/* Small utility function to write a record marker, taking care of\n+   byte swapping.  */\n+\n+inline static int\n+write_us_marker (st_parameter_dt *dtp, const gfc_offset buf)\n+{\n+  size_t len = sizeof (gfc_offset);\n+  /* Only CONVERT_NATIVE and CONVERT_SWAP are valid here.  */\n+  if (dtp->u.p.current_unit->flags.convert == CONVERT_NATIVE)\n+    return swrite (dtp->u.p.current_unit->s, &buf, &len);\n+  else {\n+    gfc_offset p;\n+    reverse_memcpy (&p, &buf, sizeof (gfc_offset));\n+    return swrite (dtp->u.p.current_unit->s, &p, &len);\n+  }\n+}\n+\n+\n /* Position to the next record in write mode.  */\n \n static void\n@@ -1785,15 +1806,10 @@ next_record_w (st_parameter_dt *dtp, int done)\n       if (dtp->u.p.current_unit->bytes_left == 0)\n \tbreak;\n \n-      length = dtp->u.p.current_unit->bytes_left;\n-      p = salloc_w (dtp->u.p.current_unit->s, &length);\n-\n-      if (p == NULL)\n+      if (sset (dtp->u.p.current_unit->s, ' ', \n+\t\tdtp->u.p.current_unit->bytes_left) == FAILURE)\n \tgoto io_error;\n \n-      memset (p, ' ', dtp->u.p.current_unit->bytes_left);\n-      if (sfree (dtp->u.p.current_unit->s) == FAILURE)\n-\tgoto io_error;\n       break;\n \n     case UNFORMATTED_DIRECT:\n@@ -1806,37 +1822,19 @@ next_record_w (st_parameter_dt *dtp, int done)\n       m = dtp->u.p.current_unit->recl - dtp->u.p.current_unit->bytes_left;\n       c = file_position (dtp->u.p.current_unit->s);\n \n-      length = sizeof (gfc_offset);\n-\n       /* Write the length tail.  */\n \n-      p = salloc_w (dtp->u.p.current_unit->s, &length);\n-      if (p == NULL)\n-\tgoto io_error;\n-\n-      /* Only CONVERT_NATIVE and CONVERT_SWAP are valid here.  */\n-      if (dtp->u.p.current_unit->flags.convert == CONVERT_NATIVE)\n-\tmemcpy (p, &m, sizeof (gfc_offset));\n-      else\n-\treverse_memcpy (p, &m, sizeof (gfc_offset));\n-      \n-      if (sfree (dtp->u.p.current_unit->s) == FAILURE)\n+      if (write_us_marker (dtp, m) != 0)\n \tgoto io_error;\n \n       /* Seek to the head and overwrite the bogus length with the real\n \t length.  */\n \n-      p = salloc_w_at (dtp->u.p.current_unit->s, &length, c - m - length);\n-      if (p == NULL)\n-\tgenerate_error (&dtp->common, ERROR_OS, NULL);\n+      if (sseek (dtp->u.p.current_unit->s, c - m - sizeof (gfc_offset))\n+\t\t == FAILURE)\n+\tgoto io_error;\n \n-      /* Only CONVERT_NATIVE and CONVERT_SWAP are valid here.  */\n-      if (dtp->u.p.current_unit->flags.convert == CONVERT_NATIVE)\n-\tmemcpy (p, &m, sizeof (gfc_offset));\n-      else\n-\treverse_memcpy (p, &m, sizeof (gfc_offset));\n-\t\n-      if (sfree (dtp->u.p.current_unit->s) == FAILURE)\n+      if (write_us_marker (dtp, m) != 0)\n \tgoto io_error;\n \n       /* Seek past the end of the current record.  */\n@@ -1870,13 +1868,11 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t\t  length = (int) (dtp->u.p.current_unit->recl - max_pos);\n \t\t}\n \n-\t      p = salloc_w (dtp->u.p.current_unit->s, &length);\n-\t      if (p == NULL)\n+\t      if (sset (dtp->u.p.current_unit->s, ' ', length) == FAILURE)\n \t\t{\n \t\t  generate_error (&dtp->common, ERROR_END, NULL);\n \t\t  return;\n \t\t}\n-\t      memset(p, ' ', length);\n \n \t      /* Now that the current record has been padded out,\n \t\t determine where the next record in the array is. */\n@@ -1913,13 +1909,11 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t\t  else\n \t\t    length = (int) dtp->u.p.current_unit->bytes_left;\n \t\t}\n-\t      p = salloc_w (dtp->u.p.current_unit->s, &length);\n-\t      if (p == NULL)\n+\t      if (sset (dtp->u.p.current_unit->s, ' ', length) == FAILURE)\n \t\t{\n \t\t  generate_error (&dtp->common, ERROR_END, NULL);\n \t\t  return;\n \t\t}\n-\t      memset (p, ' ', length);\n \t    }\n \t}\n       else\n@@ -1937,22 +1931,14 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t\t  p = salloc_w (dtp->u.p.current_unit->s, &length);\n \t\t}\n  \t    }\n+\t  size_t len;\n+\t  const char crlf[] = \"\\r\\n\";\n #ifdef HAVE_CRLF\n-\t  length = 2;\n-#else\n-\t  length = 1;\n-#endif\n-\t  p = salloc_w (dtp->u.p.current_unit->s, &length);\n-\t  if (p)\n-\t    {  /* No new line for internal writes.  */\n-#ifdef HAVE_CRLF\n-\t      p[0] = '\\r';\n-\t      p[1] = '\\n';\n+\t  len = 2;\n #else\n-\t      *p = '\\n';\n+\t  len = 1;\n #endif\n-\t    }\n-\t  else\n+\t  if (swrite (dtp->u.p.current_unit->s, &crlf[2-len], &len) != 0)\n \t    goto io_error;\n \t}\n "}, {"sha": "40ad2d897bb1aa95b4a4f90ad0fac7eeaf67a9e0", "filename": "libgfortran/io/unix.c", "status": "modified", "additions": 55, "deletions": 10, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b8244c51cbf71e28f53a0e7e998aff924c36e7/libgfortran%2Fio%2Funix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b8244c51cbf71e28f53a0e7e998aff924c36e7/libgfortran%2Fio%2Funix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.c?ref=82b8244c51cbf71e28f53a0e7e998aff924c36e7", "patch": "@@ -562,15 +562,9 @@ fd_sfree (unix_stream * s)\n static try\n fd_seek (unix_stream * s, gfc_offset offset)\n {\n-  if (s->physical_offset == offset) /* Are we lucky and avoid syscall?  */\n-    {\n-      s->logical_offset = offset;\n-      return SUCCESS;\n-    }\n-\n-  s->physical_offset = s->logical_offset = offset;\n+  s->logical_offset = offset;\n \n-  return (lseek (s->fd, offset, SEEK_SET) < 0) ? FAILURE : SUCCESS;\n+  return SUCCESS;\n }\n \n \n@@ -606,6 +600,34 @@ fd_truncate (unix_stream * s)\n }\n \n \n+/* Similar to memset(), but operating on a stream instead of a string.\n+   Takes care of not using too much memory.  */\n+\n+static try\n+fd_sset (unix_stream * s, int c, size_t n)\n+{\n+  size_t bytes_left;\n+  int trans;\n+  void *p;\n+\n+  bytes_left = n;\n+\n+  while (bytes_left > 0)\n+    {\n+      /* memset() in chunks of BUFFER_SIZE.  */\n+      trans = (bytes_left < BUFFER_SIZE) ? bytes_left : BUFFER_SIZE;\n+\n+      p = fd_alloc_w_at (s, &trans, -1);\n+      if (p)\n+\t  memset (p, c, trans);\n+      else\n+\treturn FAILURE;\n+\n+      bytes_left -= trans;\n+    }\n+\n+  return SUCCESS;\n+}\n \n \n /* Stream read function. Avoids using a buffer for big reads. The\n@@ -644,7 +666,8 @@ fd_read (unix_stream * s, void * buf, size_t * nbytes)\n       return errno;\n     }\n \n-  if (is_seekable ((stream *) s) && fd_seek (s, s->logical_offset) == FAILURE)\n+  if (is_seekable ((stream *) s) && s->physical_offset != s->logical_offset \n+      && lseek (s->fd, s->logical_offset, SEEK_SET) < 0)\n     {\n       *nbytes = 0;\n       return errno;\n@@ -692,7 +715,8 @@ fd_write (unix_stream * s, const void * buf, size_t * nbytes)\n       return errno;\n     }\n \n-  if (is_seekable ((stream *) s) && fd_seek (s, s->logical_offset) == FAILURE)\n+  if (is_seekable ((stream *) s) && s->physical_offset != s->logical_offset\n+      && lseek (s->fd, s->logical_offset, SEEK_SET) < 0)\n     {\n       *nbytes = 0;\n       return errno;\n@@ -739,6 +763,7 @@ fd_open (unix_stream * s)\n   s->st.truncate = (void *) fd_truncate;\n   s->st.read = (void *) fd_read;\n   s->st.write = (void *) fd_write;\n+  s->st.set = (void *) fd_sset;\n \n   s->buffer = NULL;\n }\n@@ -870,6 +895,25 @@ mem_seek (unix_stream * s, gfc_offset offset)\n }\n \n \n+static try\n+mem_set (unix_stream * s, int c, size_t n)\n+{\n+  void *p;\n+  int len;\n+\n+  len = n;\n+  \n+  p = mem_alloc_w_at (s, &len, -1);\n+  if (p)\n+    {\n+      memset (p, c, len);\n+      return SUCCESS;\n+    }\n+  else\n+    return FAILURE;\n+}\n+\n+\n static int\n mem_truncate (unix_stream * s __attribute__ ((unused)))\n {\n@@ -932,6 +976,7 @@ open_internal (char *base, int length)\n   s->st.truncate = (void *) mem_truncate;\n   s->st.read = (void *) mem_read;\n   s->st.write = (void *) mem_write;\n+  s->st.set = (void *) mem_set;\n \n   return (stream *) s;\n }"}]}