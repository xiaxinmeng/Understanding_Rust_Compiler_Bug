{"sha": "2f4675b4822f842055c3f6a5cef01bbed8d264e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY0Njc1YjQ4MjJmODQyMDU1YzNmNmE1Y2VmMDFiYmVkOGQyNjRlOA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2004-09-16T14:58:01Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-09-16T14:58:01Z"}, "message": "fold-const.c (fold): Fold difference of addresses.\n\n\t* fold-const.c (fold): Fold difference of addresses.\n\t(ptr_difference_const): Moved from tree-ssa-loop-ivopts, based on\n\tget_inner_reference.\n\t* tree-ssa-loop-ivopts.c (peel_address): Removed.\n\t(ptr_difference_const): Moved to fold-const.c.\n\t(split_address_cost): Use get_inner_reference instead of peel_address.\n\t(ptr_difference_cost): Change type of diff to HOST_WIDE_INT.\n\t* tree.h (ptr_difference_const): Export.\n\n\t* tree-ssa-loop-ivopts.c (dump_iv, dump_use, dump_cand): Add induction\n\tvariable type to the dump.  Fix indentation.\n\t(idx_find_step): Handle nonconstant array_ref_element_size and\n\tarray_ref_low_bound.\n\t(idx_record_use): Handle array_ref_element_size and\n\tarray_ref_low_bound.\n\t(find_interesting_uses_stmt): Handle memory = nontrivial_expression\n\tstatements correctly.\n\t(get_computation_at, iv_value): Do not unshare expressions here.\n\t(rewrite_use_outer): Unshare the expression before it is emitted\n\tto code.\n\t* tree-ssa-loop-niter.c (unsigned_type_for, signed_type_for):\n\tMoved to tree.c.\n\t* tree.c (unsigned_type_for, signed_type_for): Moved from\n\ttree-ssa-loop-niter.c.  Use langhooks.\n\t* tree.h (signed_type_for): Export.\n\nFrom-SVN: r87601", "tree": {"sha": "83497c6bb39910f542ef7657087dd15d1aac8289", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83497c6bb39910f542ef7657087dd15d1aac8289"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f4675b4822f842055c3f6a5cef01bbed8d264e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f4675b4822f842055c3f6a5cef01bbed8d264e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f4675b4822f842055c3f6a5cef01bbed8d264e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f4675b4822f842055c3f6a5cef01bbed8d264e8/comments", "author": null, "committer": null, "parents": [{"sha": "9c763d1957c4c86fb0d299c71c44f70962959a15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c763d1957c4c86fb0d299c71c44f70962959a15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c763d1957c4c86fb0d299c71c44f70962959a15"}], "stats": {"total": 399, "additions": 229, "deletions": 170}, "files": [{"sha": "617b26a4434606b9a127d39453471379770b8c81", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f4675b4822f842055c3f6a5cef01bbed8d264e8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f4675b4822f842055c3f6a5cef01bbed8d264e8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f4675b4822f842055c3f6a5cef01bbed8d264e8", "patch": "@@ -1,3 +1,31 @@\n+2004-09-16  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* fold-const.c (fold): Fold difference of addresses.\n+\t(ptr_difference_const): Moved from tree-ssa-loop-ivopts, based on\n+\tget_inner_reference.\n+\t* tree-ssa-loop-ivopts.c (peel_address): Removed.\n+\t(ptr_difference_const): Moved to fold-const.c.\n+\t(split_address_cost): Use get_inner_reference instead of peel_address.\n+\t(ptr_difference_cost): Change type of diff to HOST_WIDE_INT.\n+\t* tree.h (ptr_difference_const): Export.\n+\n+\t* tree-ssa-loop-ivopts.c (dump_iv, dump_use, dump_cand): Add induction\n+\tvariable type to the dump.  Fix indentation.\n+\t(idx_find_step): Handle nonconstant array_ref_element_size and\n+\tarray_ref_low_bound.\n+\t(idx_record_use): Handle array_ref_element_size and\n+\tarray_ref_low_bound.\n+\t(find_interesting_uses_stmt): Handle memory = nontrivial_expression\n+\tstatements correctly.\n+\t(get_computation_at, iv_value): Do not unshare expressions here.\n+\t(rewrite_use_outer): Unshare the expression before it is emitted\n+\tto code.\n+\t* tree-ssa-loop-niter.c (unsigned_type_for, signed_type_for):\n+\tMoved to tree.c.\n+\t* tree.c (unsigned_type_for, signed_type_for): Moved from\n+\ttree-ssa-loop-niter.c.  Use langhooks.\n+\t* tree.h (signed_type_for): Export.\n+\n 2004-09-16  David Edelsohn  <edelsohn@gnu.org>\n \n \t* config/rs6000/rs6000.c (rs6000_xcoff_asm_named_section): Update"}, {"sha": "7d8fff9d9eed76678fcbace046193fc69b00526d", "filename": "gcc/fold-const.c", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f4675b4822f842055c3f6a5cef01bbed8d264e8/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f4675b4822f842055c3f6a5cef01bbed8d264e8/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=2f4675b4822f842055c3f6a5cef01bbed8d264e8", "patch": "@@ -6966,6 +6966,18 @@ fold (tree expr)\n \t      || (INTEGRAL_TYPE_P (type) && flag_wrapv && !flag_trapv)))\n \treturn fold (build2 (PLUS_EXPR, type, arg0, negate_expr (arg1)));\n \n+      /* Try folding difference of addresses.  */\n+      {\n+\tHOST_WIDE_INT diff;\n+\n+\tif (TREE_CODE (arg0) == ADDR_EXPR\n+\t    && TREE_CODE (arg1) == ADDR_EXPR\n+\t    && ptr_difference_const (TREE_OPERAND (arg0, 0),\n+\t\t\t\t     TREE_OPERAND (arg1, 0),\n+\t\t\t\t     &diff))\n+\t  return build_int_cst_type (type, diff);\n+      }\n+\n       if (TREE_CODE (arg0) == MULT_EXPR\n \t  && TREE_CODE (arg1) == MULT_EXPR\n \t  && (INTEGRAL_TYPE_P (type) || flag_unsafe_math_optimizations))\n@@ -10668,3 +10680,51 @@ round_down (tree value, int divisor)\n \n   return value;\n }\n+\n+/* Returns true if addresses of E1 and E2 differ by a constant, false\n+   otherwise.  If they do, &E1 - &E2 is stored in *DIFF.  */\n+\n+bool\n+ptr_difference_const (tree e1, tree e2, HOST_WIDE_INT *diff)\n+{\n+  tree core1, core2;\n+  HOST_WIDE_INT bitsize1, bitsize2;\n+  HOST_WIDE_INT bitpos1, bitpos2;\n+  tree toffset1, toffset2, tdiff, type;\n+  enum machine_mode mode1, mode2;\n+  int unsignedp1, unsignedp2, volatilep1, volatilep2;\n+  \n+  core1 = get_inner_reference (e1, &bitsize1, &bitpos1, &toffset1, &mode1,\n+\t\t\t       &unsignedp1, &volatilep1);\n+  core2 = get_inner_reference (e2, &bitsize2, &bitpos2, &toffset2, &mode2,\n+\t\t\t       &unsignedp2, &volatilep2);\n+\n+  if (bitpos1 % BITS_PER_UNIT != 0\n+      || bitpos2 % BITS_PER_UNIT != 0\n+      || !operand_equal_p (core1, core2, 0))\n+    return false;\n+\n+  if (toffset1 && toffset2)\n+    {\n+      type = TREE_TYPE (toffset1);\n+      if (type != TREE_TYPE (toffset2))\n+\ttoffset2 = fold_convert (type, toffset2);\n+\n+      tdiff = fold (build2 (MINUS_EXPR, type, toffset1, toffset2));\n+      if (!host_integerp (tdiff, 0))\n+\treturn false;\n+\n+      *diff = tree_low_cst (tdiff, 0);\n+    }\n+  else if (toffset1 || toffset2)\n+    {\n+      /* If only one of the offsets is non-constant, the difference cannot\n+\t be a constant.  */\n+      return false;\n+    }\n+  else\n+    *diff = 0;\n+\n+  *diff += (bitpos1 - bitpos2) / BITS_PER_UNIT;\n+  return true;\n+}"}, {"sha": "e831b5110883718386c4d355e0f280e3fdd11241", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 122, "deletions": 154, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f4675b4822f842055c3f6a5cef01bbed8d264e8/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f4675b4822f842055c3f6a5cef01bbed8d264e8/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=2f4675b4822f842055c3f6a5cef01bbed8d264e8", "patch": "@@ -305,6 +305,10 @@ dump_iv (FILE *file, struct iv *iv)\n   print_generic_expr (file, iv->ssa_name, TDF_SLIM);\n   fprintf (file, \"\\n\");\n \n+  fprintf (file, \"  type \");\n+  print_generic_expr (file, TREE_TYPE (iv->base), TDF_SLIM);\n+  fprintf (file, \"\\n\");\n+\n   if (iv->step)\n     {\n       fprintf (file, \"  base \");\n@@ -358,34 +362,38 @@ dump_use (FILE *file, struct iv_use *use)\n       gcc_unreachable ();\n     }\n \n-   fprintf (file, \"  in statement \");\n-   print_generic_expr (file, use->stmt, TDF_SLIM);\n-   fprintf (file, \"\\n\");\n-\n-   fprintf (file, \"  at position \");\n-   if (use->op_p)\n-     print_generic_expr (file, *use->op_p, TDF_SLIM);\n-   fprintf (file, \"\\n\");\n-\n-   if (iv->step)\n-     {\n-       fprintf (file, \"  base \");\n-       print_generic_expr (file, iv->base, TDF_SLIM);\n-       fprintf (file, \"\\n\");\n-\n-       fprintf (file, \"  step \");\n-       print_generic_expr (file, iv->step, TDF_SLIM);\n-       fprintf (file, \"\\n\");\n-     }\n-   else\n-     {\n-       fprintf (file, \"  invariant \");\n-       print_generic_expr (file, iv->base, TDF_SLIM);\n-       fprintf (file, \"\\n\");\n-     }\n-\n-   fprintf (file, \"  related candidates \");\n-   dump_bitmap (file, use->related_cands);\n+  fprintf (file, \"  in statement \");\n+  print_generic_expr (file, use->stmt, TDF_SLIM);\n+  fprintf (file, \"\\n\");\n+\n+  fprintf (file, \"  at position \");\n+  if (use->op_p)\n+    print_generic_expr (file, *use->op_p, TDF_SLIM);\n+  fprintf (file, \"\\n\");\n+\n+  fprintf (file, \"  type \");\n+  print_generic_expr (file, TREE_TYPE (iv->base), TDF_SLIM);\n+  fprintf (file, \"\\n\");\n+\n+  if (iv->step)\n+    {\n+      fprintf (file, \"  base \");\n+      print_generic_expr (file, iv->base, TDF_SLIM);\n+      fprintf (file, \"\\n\");\n+\n+      fprintf (file, \"  step \");\n+      print_generic_expr (file, iv->step, TDF_SLIM);\n+      fprintf (file, \"\\n\");\n+    }\n+  else\n+    {\n+      fprintf (file, \"  invariant \");\n+      print_generic_expr (file, iv->base, TDF_SLIM);\n+      fprintf (file, \"\\n\");\n+    }\n+\n+  fprintf (file, \"  related candidates \");\n+  dump_bitmap (file, use->related_cands);\n }\n \n /* Dumps information about the uses to FILE.  */\n@@ -438,22 +446,26 @@ dump_cand (FILE *file, struct iv_cand *cand)\n       break;\n     }\n \n-   if (iv->step)\n-     {\n-       fprintf (file, \"  base \");\n-       print_generic_expr (file, iv->base, TDF_SLIM);\n-       fprintf (file, \"\\n\");\n-\n-       fprintf (file, \"  step \");\n-       print_generic_expr (file, iv->step, TDF_SLIM);\n-       fprintf (file, \"\\n\");\n-     }\n-   else\n-     {\n-       fprintf (file, \"  invariant \");\n-       print_generic_expr (file, iv->base, TDF_SLIM);\n-       fprintf (file, \"\\n\");\n-     }\n+  fprintf (file, \"  type \");\n+  print_generic_expr (file, TREE_TYPE (iv->base), TDF_SLIM);\n+  fprintf (file, \"\\n\");\n+\n+  if (iv->step)\n+    {\n+      fprintf (file, \"  base \");\n+      print_generic_expr (file, iv->base, TDF_SLIM);\n+      fprintf (file, \"\\n\");\n+\n+      fprintf (file, \"  step \");\n+      print_generic_expr (file, iv->step, TDF_SLIM);\n+      fprintf (file, \"\\n\");\n+    }\n+  else\n+    {\n+      fprintf (file, \"  invariant \");\n+      print_generic_expr (file, iv->base, TDF_SLIM);\n+      fprintf (file, \"\\n\");\n+    }\n }\n \n /* Returns the info for ssa version VER.  */\n@@ -1150,7 +1162,9 @@ idx_find_step (tree base, tree *idx, void *data)\n {\n   struct ifs_ivopts_data *dta = data;\n   struct iv *iv;\n-  tree step, type, iv_type, iv_step;\n+  tree step, type, iv_type, iv_step, lbound;\n+  basic_block def_bb;\n+  struct loop *loop = dta->ivopts_data->current_loop;\n   \n   if (TREE_CODE (*idx) != SSA_NAME)\n     return true;\n@@ -1167,7 +1181,30 @@ idx_find_step (tree base, tree *idx, void *data)\n   iv_type = TREE_TYPE (iv->base);\n   type = build_pointer_type (TREE_TYPE (base));\n   if (TREE_CODE (base) == ARRAY_REF)\n-    step = array_ref_element_size (base);\n+    {\n+      step = array_ref_element_size (base);\n+      lbound = array_ref_low_bound (base);\n+\n+      /* We only handle addresses whose step is an integer constant.  */\n+      if (TREE_CODE (step) != INTEGER_CST)\n+\treturn false;\n+\n+      /* We need the lower bound to be invariant in loop, since otherwise\n+\t we are unable to initialize a new induction variable created\n+\t in strength reduction -- we need to take the address of the\n+\t reference in front of the loop.  */\n+      if (is_gimple_min_invariant (lbound))\n+\t; /* Nothing to do.  */\n+      else if (TREE_CODE (lbound) != SSA_NAME)\n+\treturn false;\n+      else\n+\t{\n+\t  def_bb = bb_for_stmt (SSA_NAME_DEF_STMT (lbound));\n+\t  if (def_bb\n+\t      && flow_bb_inside_loop_p (loop, def_bb))\n+\t    return false;\n+\t}\n+    }\n   else\n     /* The step for pointer arithmetics already is 1 byte.  */\n     step = build_int_cst (type, 1);\n@@ -1198,10 +1235,15 @@ idx_find_step (tree base, tree *idx, void *data)\n    object is passed to it in DATA.  */\n \n static bool\n-idx_record_use (tree base ATTRIBUTE_UNUSED, tree *idx,\n+idx_record_use (tree base, tree *idx,\n \t\tvoid *data)\n {\n   find_interesting_uses_op (data, *idx);\n+  if (TREE_CODE (base) == ARRAY_REF)\n+    {\n+      find_interesting_uses_op (data, array_ref_element_size (base));\n+      find_interesting_uses_op (data, array_ref_low_bound (base));\n+    }\n   return true;\n }\n \n@@ -1318,12 +1360,22 @@ find_interesting_uses_stmt (struct ivopts_data *data, tree stmt)\n \tdefault: ;\n \t}\n \n-      if (TREE_CODE_CLASS (TREE_CODE (lhs)) == 'r')\n+      /* Handle memory = gimple_val.  */\n+      if (TREE_CODE_CLASS (TREE_CODE (lhs)) == 'r'\n+\t  && is_gimple_val (rhs))\n \t{\n \t  find_interesting_uses_address (data, stmt, &TREE_OPERAND (stmt, 0));\n \t  find_interesting_uses_op (data, rhs);\n \t  return;\n \t}\n+\n+      /* TODO -- we should also handle address uses of type\n+\n+\t memory = call (whatever);\n+\n+\t and\n+\n+\t call (memory).  */\n     }\n \n   if (TREE_CODE (stmt) == PHI_NODE\n@@ -1995,10 +2047,10 @@ static tree\n get_computation_at (struct loop *loop,\n \t\t    struct iv_use *use, struct iv_cand *cand, tree at)\n {\n-  tree ubase = unsave_expr_now (use->iv->base);\n-  tree ustep = unsave_expr_now (use->iv->step);\n-  tree cbase = unsave_expr_now (cand->iv->base);\n-  tree cstep = unsave_expr_now (cand->iv->step);\n+  tree ubase = use->iv->base;\n+  tree ustep = use->iv->step;\n+  tree cbase = cand->iv->base;\n+  tree cstep = cand->iv->step;\n   tree utype = TREE_TYPE (ubase), ctype = TREE_TYPE (cbase);\n   tree uutype;\n   tree expr, delta;\n@@ -2500,98 +2552,6 @@ force_var_cost (struct ivopts_data *data,\n   return target_spill_cost;\n }\n \n-/* Peels a single layer of ADDR.  If DIFF is not NULL, do it only if the\n-   offset is constant and add the offset to DIFF.  */\n-\n-static tree\n-peel_address (tree addr, unsigned HOST_WIDE_INT *diff)\n-{\n-  tree off, size;\n-  HOST_WIDE_INT bit_offset;\n-\n-  switch (TREE_CODE (addr))\n-    {\n-    case SSA_NAME:\n-    case INDIRECT_REF:\n-    case BIT_FIELD_REF:\n-    case VAR_DECL:\n-    case PARM_DECL:\n-    case RESULT_DECL:\n-    case STRING_CST:\n-    case REALPART_EXPR:\n-    case IMAGPART_EXPR:\n-      return NULL_TREE;\n-\n-    case COMPONENT_REF:\n-      off = DECL_FIELD_BIT_OFFSET (TREE_OPERAND (addr, 1));\n-      bit_offset = TREE_INT_CST_LOW (off);\n-\n-      gcc_assert ((bit_offset % BITS_PER_UNIT) == 0);\n-      \n-      if (diff)\n-\t*diff += bit_offset / BITS_PER_UNIT;\n-\n-      return TREE_OPERAND (addr, 0);\n-\n-    case VIEW_CONVERT_EXPR:\n-      return TREE_OPERAND (addr, 0);\n-\n-    case ARRAY_REF:\n-      off = TREE_OPERAND (addr, 1);\n-\n-      if (diff)\n-\t{\n-\t  if (!cst_and_fits_in_hwi (off))\n-\t    return NULL_TREE;\n-\n-\t  size = TYPE_SIZE_UNIT (TREE_TYPE (addr));\n-\t  if (!cst_and_fits_in_hwi (size))\n-\t    return NULL_TREE;\n-\n-\t  *diff += TREE_INT_CST_LOW (off) * TREE_INT_CST_LOW (size);\n-\t}\n-\n-      return TREE_OPERAND (addr, 0);\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-/* Checks whether E1 and E2 have constant difference, and if they do,\n-   store it in *DIFF.  */\n-\n-static bool\n-ptr_difference_const (tree e1, tree e2, unsigned HOST_WIDE_INT *diff)\n-{\n-  int d1 = 0, d2 = 0;\n-  tree x;\n-  unsigned HOST_WIDE_INT delta1 = 0, delta2 = 0;\n-\n-  /* Find depths of E1 and E2.  */\n-  for (x = e1; x; x = peel_address (x, NULL))\n-    d1++;\n-  for (x = e2; x; x = peel_address (x, NULL))\n-    d2++;\n-\n-  for (; e1 && d1 > d2; e1 = peel_address (e1, &delta1))\n-    d1--;\n-  for (; e2 && d2 > d1; e2 = peel_address (e2, &delta2))\n-    d2--;\n-\n-  while (e1 && e2 && !operand_equal_p (e1, e2, 0))\n-    {\n-      e1 = peel_address (e1, &delta1);\n-      e2 = peel_address (e2, &delta1);\n-    }\n-\n-  if (!e1 || !e2)\n-    return false;\n-\n-  *diff = delta1 - delta2;\n-  return true;\n-}\n-\n /* Estimates cost of expressing address ADDR  as var + symbol + offset.  The\n    value of offset is added to OFFSET, SYMBOL_PRESENT and VAR_PRESENT are set\n    to false if the corresponding part is missing.  DEPENDS_ON is a set of the\n@@ -2602,21 +2562,28 @@ split_address_cost (struct ivopts_data *data,\n \t\t    tree addr, bool *symbol_present, bool *var_present,\n \t\t    unsigned HOST_WIDE_INT *offset, bitmap *depends_on)\n {\n-  tree core = addr;\n-\n-  while (core\n-\t && TREE_CODE (core) != VAR_DECL)\n-    core = peel_address (core, offset);\n+  tree core;\n+  HOST_WIDE_INT bitsize;\n+  HOST_WIDE_INT bitpos;\n+  tree toffset;\n+  enum machine_mode mode;\n+  int unsignedp, volatilep;\n+  \n+  core = get_inner_reference (addr, &bitsize, &bitpos, &toffset, &mode,\n+\t\t\t      &unsignedp, &volatilep);\n \n-  if (!core)\n+  if (toffset != 0\n+      || bitpos % BITS_PER_UNIT != 0\n+      || TREE_CODE (core) != VAR_DECL)\n     {\n       *symbol_present = false;\n       *var_present = true;\n       fd_ivopts_data = data;\n       walk_tree (&addr, find_depends, depends_on, NULL);\n       return target_spill_cost;\n-    }  \n-\t  \n+    }\n+\n+  *offset += bitpos / BITS_PER_UNIT;\n   if (TREE_STATIC (core)\n       || DECL_EXTERNAL (core))\n     {\n@@ -2641,7 +2608,7 @@ ptr_difference_cost (struct ivopts_data *data,\n \t\t     tree e1, tree e2, bool *symbol_present, bool *var_present,\n \t\t     unsigned HOST_WIDE_INT *offset, bitmap *depends_on)\n {\n-  unsigned HOST_WIDE_INT diff = 0;\n+  HOST_WIDE_INT diff = 0;\n   unsigned cost;\n \n   gcc_assert (TREE_CODE (e1) == ADDR_EXPR);\n@@ -2905,7 +2872,7 @@ iv_value (struct iv *iv, tree niter)\n   tree type = TREE_TYPE (iv->base);\n \n   niter = fold_convert (type, niter);\n-  val = fold (build2 (MULT_EXPR, type, iv->step, unsave_expr_now (niter)));\n+  val = fold (build2 (MULT_EXPR, type, iv->step, niter));\n \n   return fold (build2 (PLUS_EXPR, type, iv->base, val));\n }\n@@ -4125,6 +4092,7 @@ rewrite_use_outer (struct ivopts_data *data,\n \tvalue = get_computation_at (data->current_loop,\n \t\t\t\t    use, cand, last_stmt (exit->src));\n \n+      value = unshare_expr (value);\n       op = force_gimple_operand (value, &stmts, true, SSA_NAME_VAR (tgt));\n \t  \n       /* If we will preserve the iv anyway and we would need to perform"}, {"sha": "686545bf26f2452f94277ac63e0890177ea31925", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f4675b4822f842055c3f6a5cef01bbed8d264e8/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f4675b4822f842055c3f6a5cef01bbed8d264e8/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=2f4675b4822f842055c3f6a5cef01bbed8d264e8", "patch": "@@ -84,22 +84,6 @@ inverse (tree x, tree mask)\n   return rslt;\n }\n \n-/* Returns unsigned variant of TYPE.  */\n-\n-tree\n-unsigned_type_for (tree type)\n-{\n-  return make_unsigned_type (TYPE_PRECISION (type));\n-}\n-\n-/* Returns signed variant of TYPE.  */\n-\n-static tree\n-signed_type_for (tree type)\n-{\n-  return make_signed_type (TYPE_PRECISION (type));\n-}\n-\n /* Determine the number of iterations according to condition (for staying\n    inside loop) which compares two induction variables using comparison\n    operator CODE.  The induction variable on left side of the comparison"}, {"sha": "05bbc1eaa92c9d044798435eaf17a72f50a585f4", "filename": "gcc/tree.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f4675b4822f842055c3f6a5cef01bbed8d264e8/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f4675b4822f842055c3f6a5cef01bbed8d264e8/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=2f4675b4822f842055c3f6a5cef01bbed8d264e8", "patch": "@@ -5866,4 +5866,20 @@ tree_fold_gcd (tree a, tree b)\n     }\n }\n \n+/* Returns unsigned variant of TYPE.  */\n+\n+tree\n+unsigned_type_for (tree type)\n+{\n+  return lang_hooks.types.unsigned_type (type);\n+}\n+\n+/* Returns signed variant of TYPE.  */\n+\n+tree\n+signed_type_for (tree type)\n+{\n+  return lang_hooks.types.signed_type (type);\n+}\n+\n #include \"gt-tree.h\""}, {"sha": "19ba2201b840f95d2597543708d92535b58a587a", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f4675b4822f842055c3f6a5cef01bbed8d264e8/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f4675b4822f842055c3f6a5cef01bbed8d264e8/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=2f4675b4822f842055c3f6a5cef01bbed8d264e8", "patch": "@@ -2792,6 +2792,7 @@ extern tree build_empty_stmt (void);\n \n extern tree make_signed_type (int);\n extern tree make_unsigned_type (int);\n+extern tree signed_type_for (tree);\n extern tree unsigned_type_for (tree);\n extern void initialize_sizetypes (bool);\n extern void set_sizetype (tree);\n@@ -3464,6 +3465,8 @@ extern tree constant_boolean_node (int, tree);\n extern bool tree_swap_operands_p (tree, tree, bool);\n extern enum tree_code swap_tree_comparison (enum tree_code);\n \n+extern bool ptr_difference_const (tree, tree, HOST_WIDE_INT *);\n+\n /* In builtins.c */\n extern tree fold_builtin (tree, bool);\n extern tree fold_builtin_fputs (tree, bool, bool, tree);"}]}