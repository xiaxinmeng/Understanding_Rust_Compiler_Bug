{"sha": "f1668c3d35b1031fa3ee266b6c3292e53344d315", "node_id": "C_kwDOANBUbNoAKGYxNjY4YzNkMzViMTAzMWZhM2VlMjY2YjZjMzI5MmU1MzM0NGQzMTU", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2022-10-16T19:48:53Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2022-11-08T08:35:01Z"}, "message": "ada: Enforce matching of extra formals\n\nThis patch enforces matching of extra formals in overridden subprograms,\nsubprogram renamings, and subprograms to which attributes 'Access,\n'Unchecked_Access, or 'Unrestricted_Access is applied (for these access\ncases the subprogram is checked against its corresponding subprogram\ntype). This enforcement is an internal consistency check, not an\nimplementation of some language legality rule.\n\ngcc/ada/\n\n\t* debug.adb\n\t(Debug_Flag_Underscore_XX): Switch -gnatd_X used temporarily to allow\n\tdisabling extra formal checks.\n\t* exp_attr.adb\n\t(Expand_N_Attribute_Reference [access types]): Add extra formals\n\tto the subprogram referenced in the prefix of 'Unchecked_Access,\n\t'Unrestricted_Access or 'Access; required to check that its extra\n\tformals match the extra formals of the corresponding subprogram type.\n\t* exp_ch3.adb\n\t(Stream_Operation_OK): Declaration moved to the public part of the\n\tpackage.\n\t(Validate_Tagged_Type_Extra_Formals): New subprogram.\n\t(Expand_Freeze_Record_Type): Improve the code that takes care of\n\tadding the extra formals of dispatching primitives; extended to\n\tadd also the extra formals to renamings of dispatching primitives.\n\t* exp_ch3.ads\n\t(Stream_Operation_OK): Declaration moved from the package body.\n\t* exp_ch6.adb\n\t(Check_BIP_Actuals): Complete documentation.\n\t(Has_BIP_Extra_Formal): Subprogram declaration moved to the public\n\tpart of the package. In addition, a parameter has been added to\n\tdisable an assertion that requires its use with frozen entities.\n\t(Duplicate_Params_Without_Extra_Actuals): New subprogram.\n\t(Check_Subprogram_Variant): Emit the call without duplicating the\n\textra formals since they will be added when the call is analyzed.\n\t(Expand_Call_Helper): Ensure that the called subprogram has all its\n\textra formals, enforce assertion checking extra formals on thunks,\n\tand mark calls from thunks as processed-BIP-calls to avoid adding\n\ttheir extra formals twice.\n\t(Is_Build_In_Place_Function): Return False for entities with foreign\n\tconvention.\n\t(Is_Build_In_Place_Function_Call): Return True also for not BIP functions\n\tthat have BIP formals since the extra actuals are required.\n\t(Make_Build_In_Place_Call_In_Object_Declaration): Occurrences of\n\tIs_Return_Object replaced by the local variable Is_OK_Return_Object\n\tthat evaluates to False for scopes with foreign convention.\n\t(Might_Have_Tasks): Fix check of class-wide limited record types.\n\t(Needs_BIP_Task_Actuals): Remove assertion to allow calling this\n\tfunction in more contexts; in addition it returns False for functions\n\treturning objects with foreign convention.\n\t(Needs_BIP_Finalization_Master): Likewise.\n\t(Needs_BIP_Alloc_Form): Likewise.\n\t(Validate_Subprogram_Calls): Check that the number of actuals (including\n\textra actuals) of calls in the subtree N match their corresponding\n\tformals.\n\t* exp_ch6.ads\n\t(Has_BIP_Extra_Formal): Subprogram declaration moved to the public\n\tpart of the package. In addition, a parameter has been added to\n\tdisable an assertion that requires its use with frozen entities.\n\t(Is_Build_In_Place_Function_Call): Complete documentation.\n\t(Validate_Subprogram_Calls): Check that the number of actuals (including\n\textra actuals) of calls in the subtree N match their corresponding\n\tformals.\n\t* freeze.adb\n\t(Check_Itype): Add extra formals to anonymous access subprogram itypes.\n\t(Freeze_Expression): Improve code that disables the addition of extra\n\tformals to functions with foreign convention.\n\t(Check_Extra_Formals): Moved to package Sem_Ch6 as Extra_Formals_OK.\n\t(Freeze_Subprogram): Add extra formals to non-dispatching subprograms.\n\t* frontend.adb\n\t(Frontend): Validate all the subprogram calls; it can be disabled using\n\tswitch -gnatd_X\n\t* sem_ch3.adb\n\t(Access_Subprogram_Declaration): Defer the addition of extra formals to\n\tthe freezing point so that we know the convention.\n\t(Check_Anonymous_Access_Component): Likewise.\n\t(Derive_Subprogram): Fix documentation.\n\t* sem_ch6.adb\n\t(Has_Reliable_Extra_Formals): New subprogram.\n\t(Check_Anonymous_Return): Fix check of access to class-wide limited\n\trecord types.\n\t(Check_Untagged_Equality): Placed in alphabetical order.\n\t(Extra_Formals_OK): Subprogram moved from freeze.adb.\n\t(Extra_Formals_Match_OK): New subprogram.\n\t(Has_BIP_Formals): New subprogram.\n\t(Has_Extra_Formals): New subprograms.\n\t(Needs_Accessibility_Check_Extra): New subprogram.\n\t(Parent_Subprogram): New subprogram.\n\t(Add_Extra_Formal): Minor code cleanup.\n\t(Create_Extra_Formals): Enforce matching extra formals on overridden\n\tand aliased entities.\n\t* sem_ch6.ads\n\t(Extra_Formals_Match_OK): New subprogram.\n\t(Extra_Formals_OK): Subprogram moved from freeze.adb.\n\t* sem_eval.adb\n\t(Compile_Time_Known_Value): Improve predicate to avoid assertion\n\tfailure; found working on this ticket; this change does not\n\taffect the behavior of the compiler because this subprogram\n\thas an exception handler that returns False when the assertion\n\tfails.\n\t* sem_util.adb\n\t(Needs_Result_Accessibility_Level): Do not return False for dispatching\n\toperations compiled with Ada_Version < 2012 since they they may be\n\toverridden by primitives compiled with Ada_Version >= Ada_2012.", "tree": {"sha": "f10a83c3e084122f28d6872bb1cba1993109f667", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f10a83c3e084122f28d6872bb1cba1993109f667"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1668c3d35b1031fa3ee266b6c3292e53344d315", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1668c3d35b1031fa3ee266b6c3292e53344d315", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1668c3d35b1031fa3ee266b6c3292e53344d315", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1668c3d35b1031fa3ee266b6c3292e53344d315/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a08b9393c7b36c4dca8fca9a5cda261594f61d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a08b9393c7b36c4dca8fca9a5cda261594f61d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a08b9393c7b36c4dca8fca9a5cda261594f61d6"}], "stats": {"total": 1897, "additions": 1438, "deletions": 459}, "files": [{"sha": "d84d114bef14d14cb3048d4aea5f90ad04de5159", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1668c3d35b1031fa3ee266b6c3292e53344d315/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1668c3d35b1031fa3ee266b6c3292e53344d315/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=f1668c3d35b1031fa3ee266b6c3292e53344d315", "patch": "@@ -189,7 +189,7 @@ package body Debug is\n    --  d_U  Disable prepending messages with \"error:\".\n    --  d_V  Enable verifications on the expanded tree\n    --  d_W\n-   --  d_X\n+   --  d_X  Disable assertions to check matching of extra formals\n    --  d_Y\n    --  d_Z\n \n@@ -1044,6 +1044,10 @@ package body Debug is\n    --  d_V  Enable verification of the expanded code before calling the backend\n    --       and generate error messages on each inconsistency found.\n \n+   --  d_X  Disable assertions to check matching of extra formals; switch added\n+   --       temporarily to disable these checks until this work is complete if\n+   --       they cause unexpected assertion failures.\n+\n    --  d1   Error messages have node numbers where possible. Normally error\n    --       messages have only source locations. This option is useful when\n    --       debugging errors caused by expanded code, where the source location"}, {"sha": "9c8d80ffe25e7a19b7969f4ae2a0b218485dcce8", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 31, "deletions": 10, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1668c3d35b1031fa3ee266b6c3292e53344d315/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1668c3d35b1031fa3ee266b6c3292e53344d315/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=f1668c3d35b1031fa3ee266b6c3292e53344d315", "patch": "@@ -2316,19 +2316,40 @@ package body Exp_Attr is\n             if Is_Access_Protected_Subprogram_Type (Btyp) then\n                Expand_Access_To_Protected_Op (N, Pref, Typ);\n \n-            --  If prefix is a subprogram that has class-wide preconditions and\n-            --  an indirect-call wrapper (ICW) of such subprogram is available\n-            --  then replace the prefix by the ICW.\n-\n             elsif Is_Access_Subprogram_Type (Btyp)\n               and then Is_Entity_Name (Pref)\n-              and then Present (Class_Preconditions (Entity (Pref)))\n-              and then Present (Indirect_Call_Wrapper (Entity (Pref)))\n             then\n-               Rewrite (Pref,\n-                 New_Occurrence_Of\n-                   (Indirect_Call_Wrapper (Entity (Pref)), Loc));\n-               Analyze_And_Resolve (N, Typ);\n+               --  If prefix is a subprogram that has class-wide preconditions\n+               --  and an indirect-call wrapper (ICW) of the subprogram is\n+               --  available then replace the prefix by the ICW.\n+\n+               if Present (Class_Preconditions (Entity (Pref)))\n+                 and then Present (Indirect_Call_Wrapper (Entity (Pref)))\n+               then\n+                  Rewrite (Pref,\n+                    New_Occurrence_Of\n+                      (Indirect_Call_Wrapper (Entity (Pref)), Loc));\n+                  Analyze_And_Resolve (N, Typ);\n+               end if;\n+\n+               --  Ensure the availability of the extra formals to check that\n+               --  they match.\n+\n+               if not Is_Frozen (Entity (Pref))\n+                 or else From_Limited_With (Etype (Entity (Pref)))\n+               then\n+                  Create_Extra_Formals (Entity (Pref));\n+               end if;\n+\n+               if not Is_Frozen (Btyp_DDT)\n+                 or else From_Limited_With (Etype (Btyp_DDT))\n+               then\n+                  Create_Extra_Formals (Btyp_DDT);\n+               end if;\n+\n+               pragma Assert\n+                 (Extra_Formals_Match_OK\n+                   (E => Entity (Pref), Ref_E => Btyp_DDT));\n \n             --  If prefix is a type name, this is a reference to the current\n             --  instance of the type, within its initialization procedure."}, {"sha": "90f01ca27473f757c082ff863937be03a8f14e6b", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 116, "deletions": 20, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1668c3d35b1031fa3ee266b6c3292e53344d315/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1668c3d35b1031fa3ee266b6c3292e53344d315/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=f1668c3d35b1031fa3ee266b6c3292e53344d315", "patch": "@@ -44,7 +44,6 @@ with Exp_Dist;       use Exp_Dist;\n with Exp_Put_Image;\n with Exp_Smem;       use Exp_Smem;\n with Exp_Strm;       use Exp_Strm;\n-with Exp_Tss;        use Exp_Tss;\n with Exp_Util;       use Exp_Util;\n with Freeze;         use Freeze;\n with Ghost;          use Ghost;\n@@ -408,15 +407,6 @@ package body Exp_Ch3 is\n    --  Freeze entities of all predefined primitive operations. This is needed\n    --  because the bodies of these operations do not normally do any freezing.\n \n-   function Stream_Operation_OK\n-     (Typ       : Entity_Id;\n-      Operation : TSS_Name_Type) return Boolean;\n-   --  Check whether the named stream operation must be emitted for a given\n-   --  type. The rules for inheritance of stream attributes by type extensions\n-   --  are enforced by this function. Furthermore, various restrictions prevent\n-   --  the generation of these operations, as a useful optimization or for\n-   --  certification purposes and to save unnecessary generated code.\n-\n    --------------------------\n    -- Adjust_Discriminants --\n    --------------------------\n@@ -5380,6 +5370,10 @@ package body Exp_Ch3 is\n       procedure Register_Dispatch_Table_Wrappers (Typ : Entity_Id);\n       --  Register dispatch-table wrappers in the dispatch table of Typ\n \n+      procedure Validate_Tagged_Type_Extra_Formals (Typ : Entity_Id);\n+      --  Check extra formals of dispatching primitives of tagged type Typ.\n+      --  Used in pragma Debug.\n+\n       ---------------------------------------\n       -- Build_Class_Condition_Subprograms --\n       ---------------------------------------\n@@ -5509,6 +5503,78 @@ package body Exp_Ch3 is\n          end loop;\n       end Register_Dispatch_Table_Wrappers;\n \n+      ----------------------------------------\n+      -- Validate_Tagged_Type_Extra_Formals --\n+      ----------------------------------------\n+\n+      procedure Validate_Tagged_Type_Extra_Formals (Typ : Entity_Id) is\n+         Ovr_Subp : Entity_Id;\n+         Elmt     : Elmt_Id;\n+         Subp     : Entity_Id;\n+\n+      begin\n+         pragma Assert (not Is_Class_Wide_Type (Typ));\n+\n+         --  No check required if expansion is not active since we never\n+         --  generate extra formals in such case.\n+\n+         if not Expander_Active then\n+            return;\n+         end if;\n+\n+         Elmt := First_Elmt (Primitive_Operations (Typ));\n+         while Present (Elmt) loop\n+            Subp := Node (Elmt);\n+\n+            --  Extra formals of a dispatching primitive must match:\n+\n+            --  1) The extra formals of its covered interface primitive\n+\n+            if Present (Interface_Alias (Subp)) then\n+               pragma Assert\n+                 (Extra_Formals_Match_OK\n+                   (E     => Interface_Alias (Subp),\n+                    Ref_E => Alias (Subp)));\n+            end if;\n+\n+            --  2) The extra formals of its renamed primitive\n+\n+            if Present (Alias (Subp)) then\n+               pragma Assert\n+                 (Extra_Formals_Match_OK\n+                   (E     => Subp,\n+                    Ref_E => Ultimate_Alias (Subp)));\n+            end if;\n+\n+            --  3) The extra formals of its overridden primitive\n+\n+            if Present (Overridden_Operation (Subp)) then\n+               Ovr_Subp := Overridden_Operation (Subp);\n+\n+               --  Handle controlling function wrapper\n+\n+               if Is_Wrapper (Subp)\n+                 and then Ultimate_Alias (Ovr_Subp) = Subp\n+               then\n+                  if Present (Overridden_Operation (Ovr_Subp)) then\n+                     pragma Assert\n+                       (Extra_Formals_Match_OK\n+                         (E     => Subp,\n+                          Ref_E => Overridden_Operation (Ovr_Subp)));\n+                  end if;\n+\n+               else\n+                  pragma Assert\n+                    (Extra_Formals_Match_OK\n+                      (E     => Subp,\n+                       Ref_E => Ovr_Subp));\n+               end if;\n+            end if;\n+\n+            Next_Elmt (Elmt);\n+         end loop;\n+      end Validate_Tagged_Type_Extra_Formals;\n+\n       --  Local variables\n \n       Typ      : constant Node_Id := Entity (N);\n@@ -5897,28 +5963,58 @@ package body Exp_Ch3 is\n          --  inherited functions, then add their bodies to the freeze actions.\n \n          Append_Freeze_Actions (Typ, Wrapper_Body_List);\n+      end if;\n \n-         --  Create extra formals for the primitive operations of the type.\n-         --  This must be done before analyzing the body of the initialization\n-         --  procedure, because a self-referential type might call one of these\n-         --  primitives in the body of the init_proc itself.\n+      --  Create extra formals for the primitive operations of the type.\n+      --  This must be done before analyzing the body of the initialization\n+      --  procedure, because a self-referential type might call one of these\n+      --  primitives in the body of the init_proc itself.\n+      --\n+      --  This is not needed:\n+      --    1) If expansion is disabled, because extra formals are only added\n+      --       when we are generating code.\n+      --\n+      --    2) For types with foreign convention since primitives with foreign\n+      --       convention don't have extra formals and AI95-117 requires that\n+      --       all primitives of a tagged type inherit the convention.\n \n+      if Expander_Active\n+        and then Is_Tagged_Type (Typ)\n+        and then not Has_Foreign_Convention (Typ)\n+      then\n          declare\n             Elmt : Elmt_Id;\n-            Subp : Entity_Id;\n+            E    : Entity_Id;\n \n          begin\n+            --  Add extra formals to primitive operations\n+\n             Elmt := First_Elmt (Primitive_Operations (Typ));\n             while Present (Elmt) loop\n-               Subp := Node (Elmt);\n-               if not Has_Foreign_Convention (Subp)\n-                 and then not Is_Predefined_Dispatching_Operation (Subp)\n+               Create_Extra_Formals (Node (Elmt));\n+               Next_Elmt (Elmt);\n+            end loop;\n+\n+            --  Add extra formals to renamings of primitive operations. The\n+            --  addition of extra formals is done in two steps to minimize\n+            --  the compile time required for this action; the evaluation of\n+            --  Find_Dispatching_Type() and Contains() is only done here for\n+            --  renamings that are not primitive operations.\n+\n+            E := First_Entity (Scope (Typ));\n+            while Present (E) loop\n+               if Is_Dispatching_Operation (E)\n+                 and then Present (Alias (E))\n+                 and then Find_Dispatching_Type (E) = Typ\n+                 and then not Contains (Primitive_Operations (Typ), E)\n                then\n-                  Create_Extra_Formals (Subp);\n+                  Create_Extra_Formals (E);\n                end if;\n \n-               Next_Elmt (Elmt);\n+               Next_Entity (E);\n             end loop;\n+\n+            pragma Debug (Validate_Tagged_Type_Extra_Formals (Typ));\n          end;\n       end if;\n "}, {"sha": "24e2263296d4ed6b46889be03e5e02dcb0366f7e", "filename": "gcc/ada/exp_ch3.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1668c3d35b1031fa3ee266b6c3292e53344d315/gcc%2Fada%2Fexp_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1668c3d35b1031fa3ee266b6c3292e53344d315/gcc%2Fada%2Fexp_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.ads?ref=f1668c3d35b1031fa3ee266b6c3292e53344d315", "patch": "@@ -25,9 +25,10 @@\n \n --  Expand routines for chapter 3 constructs\n \n-with Types;  use Types;\n-with Elists; use Elists;\n-with Uintp;  use Uintp;\n+with Types;   use Types;\n+with Elists;  use Elists;\n+with Exp_Tss; use Exp_Tss;\n+with Uintp;   use Uintp;\n \n package Exp_Ch3 is\n \n@@ -207,4 +208,13 @@ package Exp_Ch3 is\n    --  Make_Predefined_Primitive_Eq_Spec; see there for description of\n    --  the Renamed_Eq parameter.\n \n+   function Stream_Operation_OK\n+     (Typ       : Entity_Id;\n+      Operation : TSS_Name_Type) return Boolean;\n+   --  Check whether the named stream operation must be emitted for a given\n+   --  type. The rules for inheritance of stream attributes by type extensions\n+   --  are enforced by this function. Furthermore, various restrictions prevent\n+   --  the generation of these operations, as a useful optimization or for\n+   --  certification purposes and to save unnecessary generated code.\n+\n end Exp_Ch3;"}, {"sha": "fce7a7cebf562a3bf01b98871d06fc31129a6c39", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 277, "deletions": 37, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1668c3d35b1031fa3ee266b6c3292e53344d315/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1668c3d35b1031fa3ee266b6c3292e53344d315/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=f1668c3d35b1031fa3ee266b6c3292e53344d315", "patch": "@@ -214,7 +214,8 @@ package body Exp_Ch6 is\n      (Subp_Call : Node_Id;\n       Subp_Id   : Entity_Id) return Boolean;\n    --  Given a subprogram call to the given subprogram return True if the\n-   --  names of BIP extra actual and formal parameters match.\n+   --  names of BIP extra actual and formal parameters match, and the number\n+   --  of actuals (including extra actuals) matches the number of formals.\n \n    function Check_Number_Of_Actuals\n      (Subp_Call : Node_Id;\n@@ -314,15 +315,6 @@ package body Exp_Ch6 is\n    --  Expand simple return from function. In the case where we are returning\n    --  from a function body this is called by Expand_N_Simple_Return_Statement.\n \n-   function Has_BIP_Extra_Formal\n-     (E    : Entity_Id;\n-      Kind : BIP_Formal_Kind) return Boolean;\n-   --  Given a frozen subprogram, subprogram type, entry or entry family,\n-   --  return True if E has the BIP extra formal associated with Kind. It must\n-   --  be invoked with a frozen entity or a subprogram type of a dispatching\n-   --  call since we can only rely on the availability of the extra formals\n-   --  on these entities.\n-\n    procedure Insert_Post_Call_Actions (N : Node_Id; Post_Call : List_Id);\n    --  Insert the Post_Call list previously produced by routine Expand_Actuals\n    --  or Expand_Call_Helper into the tree.\n@@ -3342,9 +3334,53 @@ package body Exp_Ch6 is\n       ------------------------------\n \n       procedure Check_Subprogram_Variant is\n+\n+         function Duplicate_Params_Without_Extra_Actuals\n+           (Call_Node : Node_Id) return List_Id;\n+         --  Duplicate actual parameters of Call_Node into New_Call without\n+         --  extra actuals.\n+\n+         --------------------------------------------\n+         -- Duplicate_Params_Without_Extra_Actuals --\n+         --------------------------------------------\n+\n+         function Duplicate_Params_Without_Extra_Actuals\n+           (Call_Node : Node_Id) return List_Id\n+         is\n+            Proc_Id : constant Entity_Id := Entity (Name (Call_Node));\n+            Actuals : constant List_Id := Parameter_Associations (Call_Node);\n+            NL      : List_Id;\n+            Actual  : Node_Or_Entity_Id;\n+            Formal  : Entity_Id;\n+\n+         begin\n+            if Actuals = No_List then\n+               return No_List;\n+\n+            else\n+               NL     := New_List;\n+               Actual := First (Actuals);\n+               Formal := First_Formal (Proc_Id);\n+\n+               while Present (Formal)\n+                 and then Formal /= Extra_Formals (Proc_Id)\n+               loop\n+                  Append (New_Copy (Actual), NL);\n+                  Next (Actual);\n+\n+                  Next_Formal (Formal);\n+               end loop;\n+\n+               return NL;\n+            end if;\n+         end Duplicate_Params_Without_Extra_Actuals;\n+\n+         --  Local variables\n+\n          Variant_Prag : constant Node_Id :=\n            Get_Pragma (Current_Scope, Pragma_Subprogram_Variant);\n \n+         New_Call     : Node_Id;\n          Pragma_Arg1  : Node_Id;\n          Variant_Proc : Entity_Id;\n \n@@ -3373,12 +3409,17 @@ package body Exp_Ch6 is\n \n             Variant_Proc := Entity (Pragma_Arg1);\n \n-            Insert_Action (Call_Node,\n+            New_Call :=\n               Make_Procedure_Call_Statement (Loc,\n                  Name                   =>\n                    New_Occurrence_Of (Variant_Proc, Loc),\n                  Parameter_Associations =>\n-                   New_Copy_List (Parameter_Associations (Call_Node))));\n+                   Duplicate_Params_Without_Extra_Actuals (Call_Node));\n+\n+            Insert_Action (Call_Node, New_Call);\n+\n+            pragma Assert (Etype (New_Call) /= Any_Type\n+              or else Serious_Errors_Detected > 0);\n          end if;\n       end Check_Subprogram_Variant;\n \n@@ -3679,6 +3720,12 @@ package body Exp_Ch6 is\n          end if;\n       end if;\n \n+      --  Ensure that the called subprogram has all its formals\n+\n+      if not Is_Frozen (Subp) then\n+         Create_Extra_Formals (Subp);\n+      end if;\n+\n       --  Ada 2005 (AI-345): We have a procedure call as a triggering\n       --  alternative in an asynchronous select or as an entry call in\n       --  a conditional or timed select. Check whether the procedure call\n@@ -3817,7 +3864,7 @@ package body Exp_Ch6 is\n         and then Thunk_Entity (Current_Scope) = Subp\n         and then Present (Extra_Formals (Subp))\n       then\n-         pragma Assert (Present (Extra_Formals (Current_Scope)));\n+         pragma Assert (Extra_Formals_Match_OK (Current_Scope, Subp));\n \n          declare\n             Target_Formal : Entity_Id;\n@@ -3839,6 +3886,13 @@ package body Exp_Ch6 is\n                Add_Actual_Parameter (Remove_Head (Extra_Actuals));\n             end loop;\n \n+            --  Mark the call as processed build-in-place call; required\n+            --  to avoid adding the extra formals twice.\n+\n+            if Nkind (Call_Node) = N_Function_Call then\n+               Set_Is_Expanded_Build_In_Place_Call (Call_Node);\n+            end if;\n+\n             Expand_Actuals (Call_Node, Subp, Post_Call);\n             pragma Assert (Is_Empty_List (Post_Call));\n             pragma Assert (Check_Number_Of_Actuals (Call_Node, Subp));\n@@ -6401,8 +6455,13 @@ package body Exp_Ch6 is\n \n       if Nkind (Exp) = N_Function_Call then\n          pragma Assert (Ekind (Scope_Id) = E_Function);\n+\n+         --  This assertion works fine because Is_Build_In_Place_Function_Call\n+         --  returns True for BIP function calls but also for function calls\n+         --  that have BIP formals.\n+\n          pragma Assert\n-           (Is_Build_In_Place_Function (Scope_Id) =\n+           (Has_BIP_Formals (Scope_Id) =\n             Is_Build_In_Place_Function_Call (Exp));\n          null;\n       end if;\n@@ -6440,7 +6499,7 @@ package body Exp_Ch6 is\n       pragma Assert\n         (Comes_From_Extended_Return_Statement (N)\n           or else not Is_Build_In_Place_Function_Call (Exp)\n-          or else Is_Build_In_Place_Function (Scope_Id));\n+          or else Has_BIP_Formals (Scope_Id));\n \n       if not Comes_From_Extended_Return_Statement (N)\n         and then Is_Build_In_Place_Function (Scope_Id)\n@@ -7044,8 +7103,9 @@ package body Exp_Ch6 is\n    --------------------------\n \n    function Has_BIP_Extra_Formal\n-     (E    : Entity_Id;\n-      Kind : BIP_Formal_Kind) return Boolean\n+     (E              : Entity_Id;\n+      Kind           : BIP_Formal_Kind;\n+      Must_Be_Frozen : Boolean := True) return Boolean\n    is\n       Extra_Formal : Entity_Id := Extra_Formals (E);\n \n@@ -7055,7 +7115,7 @@ package body Exp_Ch6 is\n       --  extra formals are added when the target subprogram is frozen; see\n       --  Expand_Dispatching_Call).\n \n-      pragma Assert (Is_Frozen (E)\n+      pragma Assert ((Is_Frozen (E) or else not Must_Be_Frozen)\n         or else (Ekind (E) = E_Subprogram_Type\n                    and then Is_Dispatch_Table_Entity (E))\n         or else (Is_Dispatching_Operation (E)\n@@ -7684,7 +7744,7 @@ package body Exp_Ch6 is\n                or else\n              (Kind = E_Subprogram_Type and then Typ /= Standard_Void_Type))\n         and then Is_Build_In_Place_Result_Type (Typ)\n-        and then not (Is_Imported (E) and then Has_Foreign_Convention (E));\n+        and then not Has_Foreign_Convention (E);\n    end Is_Build_In_Place_Function;\n \n    -------------------------------------\n@@ -7739,12 +7799,29 @@ package body Exp_Ch6 is\n          raise Program_Error;\n       end if;\n \n-      declare\n-         Result : constant Boolean := Is_Build_In_Place_Function (Function_Id);\n-         --  So we can stop here in the debugger\n-      begin\n-         return Result;\n-      end;\n+      if Is_Build_In_Place_Function (Function_Id) then\n+         return True;\n+\n+      --  True also if the function has BIP Formals\n+\n+      else\n+         declare\n+            Kind : constant Entity_Kind := Ekind (Function_Id);\n+\n+         begin\n+            if (Kind in E_Function | E_Generic_Function\n+                  or else (Kind = E_Subprogram_Type\n+                             and then\n+                           Etype (Function_Id) /= Standard_Void_Type))\n+              and then Has_BIP_Formals (Function_Id)\n+            then\n+               --  So we can stop here in the debugger\n+               return True;\n+            else\n+               return False;\n+            end if;\n+         end;\n+      end if;\n    end Is_Build_In_Place_Function_Call;\n \n    -----------------------------------\n@@ -8413,6 +8490,11 @@ package body Exp_Ch6 is\n       --  initialization expression of the object to Empty, which would be\n       --  illegal Ada, and would cause gigi to misallocate X.\n \n+      Is_OK_Return_Object : constant Boolean :=\n+        Is_Return_Object (Obj_Def_Id)\n+          and then\n+        not Has_Foreign_Convention (Return_Applies_To (Scope (Obj_Def_Id)));\n+\n    --  Start of processing for Make_Build_In_Place_Call_In_Object_Declaration\n \n    begin\n@@ -8465,7 +8547,7 @@ package body Exp_Ch6 is\n       --  the result object is in a different (transient) scope, so won't cause\n       --  freezing.\n \n-      if Definite and then not Is_Return_Object (Obj_Def_Id) then\n+      if Definite and then not Is_OK_Return_Object then\n \n          --  The presence of an address clause complicates the build-in-place\n          --  expansion because the indicated address must be processed before\n@@ -8548,7 +8630,7 @@ package body Exp_Ch6 is\n       --  really be directly built in place in the aggregate and not in a\n       --  temporary. ???)\n \n-      if Is_Return_Object (Obj_Def_Id) then\n+      if Is_OK_Return_Object then\n          Pass_Caller_Acc := True;\n \n          --  When the enclosing function has a BIP_Alloc_Form formal then we\n@@ -8733,7 +8815,7 @@ package body Exp_Ch6 is\n       --  itself the return expression of an enclosing BIP function, then mark\n       --  the object as having no initialization.\n \n-      if Definite and then not Is_Return_Object (Obj_Def_Id) then\n+      if Definite and then not Is_OK_Return_Object then\n \n          --  The related object declaration is encased in a transient block\n          --  because the build-in-place function call contains at least one\n@@ -9090,7 +9172,7 @@ package body Exp_Ch6 is\n         and then not No_Run_Time_Mode\n         and then (Has_Task (Typ)\n                     or else (Is_Class_Wide_Type (Typ)\n-                               and then Is_Limited_Record (Typ)\n+                               and then Is_Limited_Record (Etype (Typ))\n                                and then not Has_Aspect\n                                  (Etype (Typ), Aspect_No_Task_Parts)));\n    end Might_Have_Tasks;\n@@ -9100,7 +9182,6 @@ package body Exp_Ch6 is\n    ----------------------------\n \n    function Needs_BIP_Task_Actuals (Func_Id : Entity_Id) return Boolean is\n-      pragma Assert (Is_Build_In_Place_Function (Func_Id));\n       Subp_Id  : Entity_Id;\n       Func_Typ : Entity_Id;\n \n@@ -9125,14 +9206,20 @@ package body Exp_Ch6 is\n \n       Func_Typ := Underlying_Type (Etype (Subp_Id));\n \n+      --  Functions returning types with foreign convention don't have extra\n+      --  formals.\n+\n+      if Has_Foreign_Convention (Func_Typ) then\n+         return False;\n+\n       --  At first sight, for all the following cases, we could add assertions\n       --  to ensure that if Func_Id is frozen then the computed result matches\n       --  with the availability of the task master extra formal; unfortunately\n       --  this is not feasible because we may be precisely freezing this entity\n       --  (that is, Is_Frozen has been set by Freeze_Entity but it has not\n       --  completed its work).\n \n-      if Has_Task (Func_Typ) then\n+      elsif Has_Task (Func_Typ) then\n          return True;\n \n       elsif Ekind (Func_Id) = E_Function then\n@@ -9164,8 +9251,6 @@ package body Exp_Ch6 is\n       Typ : constant Entity_Id := Underlying_Type (Etype (Func_Id));\n \n    begin\n-      pragma Assert (Is_Build_In_Place_Function (Func_Id));\n-\n       --  A formal giving the finalization master is needed for build-in-place\n       --  functions whose result type needs finalization or is a tagged type.\n       --  Tagged primitive build-in-place functions need such a formal because\n@@ -9177,7 +9262,8 @@ package body Exp_Ch6 is\n       --  such build-in-place functions, primitive or not.\n \n       return not Restriction_Active (No_Finalization)\n-        and then (Needs_Finalization (Typ) or else Is_Tagged_Type (Typ));\n+        and then (Needs_Finalization (Typ) or else Is_Tagged_Type (Typ))\n+        and then not Has_Foreign_Convention (Typ);\n    end Needs_BIP_Finalization_Master;\n \n    --------------------------\n@@ -9188,8 +9274,6 @@ package body Exp_Ch6 is\n       Typ : constant Entity_Id := Underlying_Type (Etype (Func_Id));\n \n    begin\n-      pragma Assert (Is_Build_In_Place_Function (Func_Id));\n-\n       --  A formal giving the allocation method is needed for build-in-place\n       --  functions whose result type is returned on the secondary stack or\n       --  is a tagged type. Tagged primitive build-in-place functions need\n@@ -9201,7 +9285,8 @@ package body Exp_Ch6 is\n       --  to be passed to all such build-in-place functions, primitive or not.\n \n       return not Restriction_Active (No_Secondary_Stack)\n-        and then (Needs_Secondary_Stack (Typ) or else Is_Tagged_Type (Typ));\n+        and then (Needs_Secondary_Stack (Typ) or else Is_Tagged_Type (Typ))\n+        and then not Has_Foreign_Convention (Typ);\n    end Needs_BIP_Alloc_Form;\n \n    -------------------------------------\n@@ -9496,6 +9581,161 @@ package body Exp_Ch6 is\n       return Unqual_BIP_Function_Call (Expr);\n    end Unqual_BIP_Iface_Function_Call;\n \n+   -------------------------------\n+   -- Validate_Subprogram_Calls --\n+   -------------------------------\n+\n+   procedure Validate_Subprogram_Calls (N : Node_Id) is\n+\n+      function Process_Node (Nod : Node_Id) return Traverse_Result;\n+      --  Function to traverse the subtree of N using Traverse_Proc.\n+\n+      ------------------\n+      -- Process_Node --\n+      ------------------\n+\n+      function Process_Node (Nod : Node_Id) return Traverse_Result is\n+      begin\n+         case Nkind (Nod) is\n+            when N_Entry_Call_Statement\n+               | N_Procedure_Call_Statement\n+               | N_Function_Call\n+              =>\n+               declare\n+                  Call_Node : Node_Id renames Nod;\n+                  Subp      : Entity_Id;\n+\n+               begin\n+                  --  Call using access to subprogram with explicit dereference\n+\n+                  if Nkind (Name (Call_Node)) = N_Explicit_Dereference then\n+                     Subp := Etype (Name (Call_Node));\n+\n+                  --  Prefix notation calls\n+\n+                  elsif Nkind (Name (Call_Node)) = N_Selected_Component then\n+                     Subp := Entity (Selector_Name (Name (Call_Node)));\n+\n+                  --  Call to member of entry family, where Name is an indexed\n+                  --  component, with the prefix being a selected component\n+                  --  giving the task and entry family name, and the index\n+                  --  being the entry index.\n+\n+                  elsif Nkind (Name (Call_Node)) = N_Indexed_Component then\n+                     Subp :=\n+                       Entity (Selector_Name (Prefix (Name (Call_Node))));\n+\n+                  --  Normal case\n+\n+                  else\n+                     Subp := Entity (Name (Call_Node));\n+                  end if;\n+\n+                  pragma Assert (Check_BIP_Actuals (Call_Node, Subp));\n+               end;\n+\n+            --  Skip generic bodies\n+\n+            when N_Package_Body =>\n+               if Ekind (Unique_Defining_Entity (Nod)) = E_Generic_Package then\n+                  return Skip;\n+               end if;\n+\n+            when N_Subprogram_Body =>\n+               if Ekind (Unique_Defining_Entity (Nod)) in E_Generic_Function\n+                                                        | E_Generic_Procedure\n+               then\n+                  return Skip;\n+               end if;\n+\n+            --  Nodes we want to ignore\n+\n+            --  Skip calls placed in the full declaration of record types since\n+            --  the call will be performed by their Init Proc; for example,\n+            --  calls initializing default values of discriminants or calls\n+            --  providing the initial value of record type components. Other\n+            --  full type declarations are processed because they may have\n+            --  calls that must be checked. For example:\n+\n+            --    type T is array (1 .. Some_Function_Call (...)) of Some_Type;\n+\n+            --  ??? More work needed here to handle the following case:\n+\n+            --    type Rec is record\n+            --       F : String (1 .. <some complicated expression>);\n+            --    end record;\n+\n+            when N_Full_Type_Declaration =>\n+               if Is_Record_Type (Defining_Entity (Nod)) then\n+                  return Skip;\n+               end if;\n+\n+            --  Skip calls placed in subprogram specifications since function\n+            --  calls initializing default parameter values will be processed\n+            --  when the call to the subprogram is found (if the default actual\n+            --  parameter is required), and calls found in aspects will be\n+            --  processed when their corresponding pragma is found, or in the\n+            --  specific case of class-wide pre-/postconditions, when their\n+            --  helpers are found.\n+\n+            when N_Procedure_Specification\n+               | N_Function_Specification\n+              =>\n+               return Skip;\n+\n+            when N_Abstract_Subprogram_Declaration\n+               | N_At_Clause\n+               | N_Call_Marker\n+               | N_Empty\n+               | N_Enumeration_Representation_Clause\n+               | N_Enumeration_Type_Definition\n+               | N_Function_Instantiation\n+               | N_Freeze_Generic_Entity\n+               | N_Generic_Function_Renaming_Declaration\n+               | N_Generic_Package_Renaming_Declaration\n+               | N_Generic_Procedure_Renaming_Declaration\n+               | N_Generic_Package_Declaration\n+               | N_Generic_Subprogram_Declaration\n+               | N_Itype_Reference\n+               | N_Number_Declaration\n+               | N_Package_Instantiation\n+               | N_Package_Renaming_Declaration\n+               | N_Pragma\n+               | N_Procedure_Instantiation\n+               | N_Protected_Type_Declaration\n+               | N_Record_Representation_Clause\n+               | N_Validate_Unchecked_Conversion\n+               | N_Variable_Reference_Marker\n+               | N_Use_Package_Clause\n+               | N_Use_Type_Clause\n+               | N_With_Clause\n+              =>\n+               return Skip;\n+\n+            when others =>\n+               null;\n+         end case;\n+\n+         return OK;\n+      end Process_Node;\n+\n+      procedure Check_Calls is new Traverse_Proc (Process_Node);\n+\n+   --  Start of processing for Validate_Subprogram_Calls\n+\n+   begin\n+      --  No action required if we are not generating code or compiling sources\n+      --  that have errors.\n+\n+      if Serious_Errors_Detected > 0\n+        or else Operating_Mode /= Generate_Code\n+      then\n+         return;\n+      end if;\n+\n+      Check_Calls (N);\n+   end Validate_Subprogram_Calls;\n+\n    --------------\n    -- Warn_BIP --\n    --------------"}, {"sha": "66888c51a075020688719cf227ba26a58af2ccd7", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1668c3d35b1031fa3ee266b6c3292e53344d315/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1668c3d35b1031fa3ee266b6c3292e53344d315/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=f1668c3d35b1031fa3ee266b6c3292e53344d315", "patch": "@@ -121,6 +121,18 @@ package Exp_Ch6 is\n    --  The returned node is the root of the procedure body which will replace\n    --  the original function body, which is not needed for the C program.\n \n+   function Has_BIP_Extra_Formal\n+     (E              : Entity_Id;\n+      Kind           : BIP_Formal_Kind;\n+      Must_Be_Frozen : Boolean := True) return Boolean;\n+   --  Given a subprogram, subprogram type, entry or entry family, return True\n+   --  if E has the BIP extra formal associated with Kind. In general this\n+   --  subprogram must be invoked with a frozen entity or a subprogram type of\n+   --  a dispatching call since we can only rely on the availability of extra\n+   --  formals on these entities; this requirement can be relaxed using the\n+   --  formal Must_Be_Frozen in scenarios where we know that the entity has\n+   --  the extra formals.\n+\n    procedure Install_Class_Preconditions_Check (Call_Node : Node_Id);\n    --  Install check of class-wide preconditions on the caller.\n \n@@ -137,7 +149,8 @@ package Exp_Ch6 is\n    function Is_Build_In_Place_Function_Call (N : Node_Id) return Boolean;\n    --  Ada 2005 (AI-318-02): Returns True if N denotes a call to a function\n    --  that requires handling as a build-in-place call (possibly qualified or\n-   --  converted).\n+   --  converted); that is, BIP function calls, and calls to functions with\n+   --  inherited BIP formals.\n \n    function Is_Build_In_Place_Result_Type (Typ : Entity_Id) return Boolean;\n    --  Ada 2005 (AI-318-02): Returns True if functions returning the type use\n@@ -265,6 +278,11 @@ package Exp_Ch6 is\n    --  to reference the secondary dispatch table of an interface; otherwise\n    --  return Empty.\n \n+   procedure Validate_Subprogram_Calls (N : Node_Id);\n+   --  Check that the number of actuals (including extra actuals) of calls in\n+   --  the subtree N match their corresponding formals; check also that the\n+   --  names of BIP extra actuals and formals match.\n+\n private\n    pragma Inline (Is_Build_In_Place_Return_Object);\n "}, {"sha": "032c73d3dfba6087982d037d051bad5918db806f", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 23, "deletions": 92, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1668c3d35b1031fa3ee266b6c3292e53344d315/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1668c3d35b1031fa3ee266b6c3292e53344d315/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=f1668c3d35b1031fa3ee266b6c3292e53344d315", "patch": "@@ -4984,6 +4984,7 @@ package body Freeze is\n               and then Convention (Desig) /= Convention_Protected\n             then\n                Set_Is_Frozen (Desig);\n+               Create_Extra_Formals (Desig);\n             end if;\n          end Check_Itype;\n \n@@ -7131,11 +7132,11 @@ package body Freeze is\n \n                Check_Debug_Info_Needed (E);\n \n-               --  AI-117 requires that the convention of a partial view be the\n-               --  same as the convention of the full view. Note that this is a\n-               --  recognized breach of privacy, but it's essential for logical\n-               --  consistency of representation, and the lack of a rule in\n-               --  RM95 was an oversight.\n+               --  AI95-117 requires that the convention of a partial view be\n+               --  the same as the convention of the full view. Note that this\n+               --  is a recognized breach of privacy, but it's essential for\n+               --  logical consistency of representation, and the lack of a\n+               --  rule in RM95 was an oversight.\n \n                Set_Convention (E, Convention (Full_View (E)));\n \n@@ -7360,7 +7361,7 @@ package body Freeze is\n \n          if Is_Composite_Type (E) then\n \n-            --  AI-117 requires that all new primitives of a tagged type must\n+            --  AI95-117 requires that all new primitives of a tagged type must\n             --  inherit the convention of the full view of the type. Inherited\n             --  and overriding operations are defined to inherit the convention\n             --  of their parent or overridden subprogram (also specified in\n@@ -8268,7 +8269,7 @@ package body Freeze is\n             if Present (Nam)\n               and then Ekind (Nam) = E_Function\n               and then Nkind (Parent (N)) = N_Function_Call\n-              and then Convention (Nam) = Convention_Ada\n+              and then not Has_Foreign_Convention (Nam)\n             then\n                Create_Extra_Formals (Nam);\n             end if;\n@@ -9875,77 +9876,11 @@ package body Freeze is\n    -----------------------\n \n    procedure Freeze_Subprogram (E : Entity_Id) is\n-      function Check_Extra_Formals (E : Entity_Id) return Boolean;\n-      --  Return True if the decoration of the attributes associated with extra\n-      --  formals are properly set.\n \n       procedure Set_Profile_Convention (Subp_Id : Entity_Id);\n       --  Set the conventions of all anonymous access-to-subprogram formals and\n       --  result subtype of subprogram Subp_Id to the convention of Subp_Id.\n \n-      -------------------------\n-      -- Check_Extra_Formals --\n-      -------------------------\n-\n-      function Check_Extra_Formals (E : Entity_Id) return Boolean is\n-         Last_Formal       : Entity_Id := Empty;\n-         Formal            : Entity_Id;\n-         Has_Extra_Formals : Boolean := False;\n-\n-      begin\n-         --  No check required if expansion is disabled because extra\n-         --  formals are only generated when we are generating code.\n-         --  See Create_Extra_Formals.\n-\n-         if not Expander_Active then\n-            return True;\n-         end if;\n-\n-         --  Check attribute Extra_Formal: If available, it must be set only\n-         --  on the last formal of E.\n-\n-         Formal := First_Formal (E);\n-         while Present (Formal) loop\n-            if Present (Extra_Formal (Formal)) then\n-               if Has_Extra_Formals then\n-                  return False;\n-               end if;\n-\n-               Has_Extra_Formals := True;\n-            end if;\n-\n-            Last_Formal := Formal;\n-            Next_Formal (Formal);\n-         end loop;\n-\n-         --  Check attribute Extra_Accessibility_Of_Result\n-\n-         if Ekind (E) in E_Function | E_Subprogram_Type\n-           and then Needs_Result_Accessibility_Level (E)\n-           and then No (Extra_Accessibility_Of_Result (E))\n-         then\n-            return False;\n-         end if;\n-\n-         --  Check attribute Extra_Formals: If E has extra formals, then this\n-         --  attribute must point to the first extra formal of E.\n-\n-         if Has_Extra_Formals then\n-            return Present (Extra_Formals (E))\n-              and then Present (Extra_Formal (Last_Formal))\n-              and then Extra_Formal (Last_Formal) = Extra_Formals (E);\n-\n-         --  When E has no formals, the first extra formal is available through\n-         --  the Extra_Formals attribute.\n-\n-         elsif Present (Extra_Formals (E)) then\n-            return No (First_Formal (E));\n-\n-         else\n-            return True;\n-         end if;\n-      end Check_Extra_Formals;\n-\n       ----------------------------\n       -- Set_Profile_Convention --\n       ----------------------------\n@@ -10084,30 +10019,26 @@ package body Freeze is\n       --  that we know the convention.\n \n       if not Has_Foreign_Convention (E) then\n-         if No (Extra_Formals (E)) then\n \n-            --  Extra formals are shared by derived subprograms; therefore, if\n-            --  the ultimate alias of E has been frozen before E then the extra\n-            --  formals have been added, but the attribute Extra_Formals is\n-            --  still unset (and must be set now).\n+         --  Extra formals of dispatching operations are added later by\n+         --  Expand_Freeze_Record_Type, which also adds extra formals to\n+         --  internal entities built to handle interface types.\n \n-            if Present (Alias (E))\n-              and then Is_Frozen (Ultimate_Alias (E))\n-              and then Present (Extra_Formals (Ultimate_Alias (E)))\n-              and then Last_Formal (Ultimate_Alias (E)) = Last_Formal (E)\n-            then\n-               Set_Extra_Formals (E, Extra_Formals (Ultimate_Alias (E)));\n+         if not Is_Dispatching_Operation (E) then\n+            Create_Extra_Formals (E);\n \n-               if Ekind (E) = E_Function then\n-                  Set_Extra_Accessibility_Of_Result (E,\n-                    Extra_Accessibility_Of_Result (Ultimate_Alias (E)));\n-               end if;\n-            else\n-               Create_Extra_Formals (E);\n-            end if;\n+            pragma Assert\n+              ((Ekind (E) = E_Subprogram_Type\n+                  and then Extra_Formals_OK (E))\n+               or else\n+                 (Is_Subprogram (E)\n+                   and then Extra_Formals_OK (E)\n+                   and then\n+                     (No (Overridden_Operation (E))\n+                       or else Extra_Formals_Match_OK (E,\n+                                 Ultimate_Alias (Overridden_Operation (E))))));\n          end if;\n \n-         pragma Assert (Check_Extra_Formals (E));\n          Set_Mechanisms (E);\n \n          --  If this is convention Ada and a Valued_Procedure, that's odd"}, {"sha": "cdca67bf3975e0f700f7c1a9b536c9ccddf4bc86", "filename": "gcc/ada/frontend.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1668c3d35b1031fa3ee266b6c3292e53344d315/gcc%2Fada%2Ffrontend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1668c3d35b1031fa3ee266b6c3292e53344d315/gcc%2Fada%2Ffrontend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffrontend.adb?ref=f1668c3d35b1031fa3ee266b6c3292e53344d315", "patch": "@@ -30,6 +30,7 @@ with Checks;\n with CStand;\n with Debug;          use Debug;\n with Elists;\n+with Exp_Ch6;\n with Exp_Dbug;\n with Exp_Unst;\n with Fmap;\n@@ -523,6 +524,16 @@ begin\n       VAST.Check_Tree (Cunit (Main_Unit));\n    end if;\n \n+   --  Validate all the subprogram calls; this work will be done by VAST; in\n+   --  the meantime it is done to check extra formals and it can be disabled\n+   --  using -gnatd_X (which also disables all the other assertions on extra\n+   --  formals). It is invoked using pragma Debug to avoid adding any cost\n+   --  when the compiler is built with assertions disabled.\n+\n+   if not Debug_Flag_Underscore_XX then\n+      pragma Debug (Exp_Ch6.Validate_Subprogram_Calls (Cunit (Main_Unit)));\n+   end if;\n+\n    --  Dump the source now. Note that we do this as soon as the analysis\n    --  of the tree is complete, because it is not just a dump in the case\n    --  of -gnatD, where it rewrites all source locations in the tree."}, {"sha": "dbe4d72626efb872677b21fa119e28798320a56d", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1668c3d35b1031fa3ee266b6c3292e53344d315/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1668c3d35b1031fa3ee266b6c3292e53344d315/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=f1668c3d35b1031fa3ee266b6c3292e53344d315", "patch": "@@ -1318,7 +1318,8 @@ package body Sem_Ch3 is\n \n       Check_Restriction (No_Access_Subprograms, T_Def);\n \n-      Create_Extra_Formals (Desig_Type);\n+      --  Addition of extra formals must be delayed till the freeze point so\n+      --  that we know the convention.\n    end Access_Subprogram_Declaration;\n \n    ----------------------------\n@@ -11788,11 +11789,9 @@ package body Sem_Ch3 is\n          Insert_Before (Typ_Decl, Decl);\n          Analyze (Decl);\n \n-         --  If an access to subprogram, create the extra formals\n-\n-         if Present (Acc_Def) then\n-            Create_Extra_Formals (Designated_Type (Anon_Access));\n-         end if;\n+         --  At first sight we could add here the extra formals of an access to\n+         --  subprogram; however, it must delayed till the freeze point so that\n+         --  we know the convention.\n \n          if Nkind (Comp_Def) = N_Component_Definition then\n             Rewrite (Comp_Def,\n@@ -16053,12 +16052,12 @@ package body Sem_Ch3 is\n          Next_Formal (Formal);\n       end loop;\n \n-      --  Extra formals are shared between the parent subprogram and the\n-      --  derived subprogram (implicit in the above copy of formals), unless\n-      --  the parent type is a limited interface type; hence we must inherit\n-      --  also the reference to the first extra formal. When the parent type is\n-      --  an interface the extra formals will be added when the subprogram is\n-      --  frozen (see Freeze.Freeze_Subprogram).\n+      --  Extra formals are shared between the parent subprogram and this\n+      --  internal entity built by Derive_Subprogram (implicit in the above\n+      --  copy of formals), unless the parent type is a limited interface type;\n+      --  hence we must inherit also the reference to the first extra formal.\n+      --  When the parent type is an interface, the extra formals will be added\n+      --  when the tagged type is frozen (see Expand_Freeze_Record_Type).\n \n       if not Is_Limited_Interface (Parent_Type) then\n          Set_Extra_Formals (New_Subp, Extra_Formals (Parent_Subp));\n@@ -16099,7 +16098,7 @@ package body Sem_Ch3 is\n       Copy_Strub_Mode (New_Subp, Alias (New_Subp));\n \n       --  Derived subprograms of a tagged type must inherit the convention\n-      --  of the parent subprogram (a requirement of AI-117). Derived\n+      --  of the parent subprogram (a requirement of AI95-117). Derived\n       --  subprograms of untagged types simply get convention Ada by default.\n \n       --  If the derived type is a tagged generic formal type with unknown"}, {"sha": "454db66dd2cea6ae94b8d7c5367aa16d928e7eec", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 906, "deletions": 280, "changes": 1186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1668c3d35b1031fa3ee266b6c3292e53344d315/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1668c3d35b1031fa3ee266b6c3292e53344d315/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=f1668c3d35b1031fa3ee266b6c3292e53344d315", "patch": "@@ -34,6 +34,7 @@ with Einfo.Utils;    use Einfo.Utils;\n with Elists;         use Elists;\n with Errout;         use Errout;\n with Expander;       use Expander;\n+with Exp_Ch3;        use Exp_Ch3;\n with Exp_Ch6;        use Exp_Ch6;\n with Exp_Ch9;        use Exp_Ch9;\n with Exp_Dbug;       use Exp_Dbug;\n@@ -200,6 +201,13 @@ package body Sem_Ch6 is\n    --  This procedure makes S, a new overloaded entity, into the first visible\n    --  entity with that name.\n \n+   function Has_Reliable_Extra_Formals (E : Entity_Id) return Boolean;\n+   --  E is the entity for a subprogram spec. Returns False for abstract\n+   --  predefined dispatching primitives of Root_Controlled since they\n+   --  cannot have extra formals (this is required to build the runtime);\n+   --  it also returns False for predefined stream dispatching operations\n+   --  not emitted by the frontend. Otherwise returns True.\n+\n    function Is_Non_Overriding_Operation\n      (Prev_E : Entity_Id;\n       New_E  : Entity_Id) return Boolean;\n@@ -3352,7 +3360,8 @@ package body Sem_Ch6 is\n                       or else\n                         (Is_Class_Wide_Type (Designated_Type (Etype (Scop)))\n                            and then\n-                         Is_Limited_Record (Designated_Type (Etype (Scop)))))\n+                         Is_Limited_Record\n+                           (Etype (Designated_Type (Etype (Scop))))))\n            and then Expander_Active\n          then\n             Decl := Build_Master_Declaration (Loc);\n@@ -8471,6 +8480,253 @@ package body Sem_Ch6 is\n         (New_Id, Old_Id, Type_Conformant, True, Result, Err_Loc);\n    end Check_Type_Conformant;\n \n+   -----------------------------\n+   -- Check_Untagged_Equality --\n+   -----------------------------\n+\n+   procedure Check_Untagged_Equality (Eq_Op : Entity_Id) is\n+      Eq_Decl : constant Node_Id   := Unit_Declaration_Node (Eq_Op);\n+      Typ     : constant Entity_Id := Etype (First_Formal (Eq_Op));\n+\n+      procedure Freezing_Point_Warning (N : Node_Id; S : String);\n+      --  Output a warning about the freezing point N of Typ\n+\n+      function Is_Actual_Of_Instantiation\n+        (E    : Entity_Id;\n+         Inst : Node_Id) return Boolean;\n+      --  Return True if E is an actual parameter of instantiation Inst\n+\n+      -----------------------------------\n+      -- Output_Freezing_Point_Warning --\n+      -----------------------------------\n+\n+      procedure Freezing_Point_Warning (N : Node_Id; S : String) is\n+      begin\n+         Error_Msg_String (1 .. S'Length) := S;\n+         Error_Msg_Strlen := S'Length;\n+\n+         if Ada_Version >= Ada_2012 then\n+            Error_Msg_NE (\"type& is frozen by ~??\", N, Typ);\n+            Error_Msg_N\n+              (\"\\an equality operator cannot be declared after this point??\",\n+               N);\n+\n+         else\n+            Error_Msg_NE (\"type& is frozen by ~ (Ada 2012)?y?\", N, Typ);\n+            Error_Msg_N\n+              (\"\\an equality operator cannot be declared after this point\"\n+               & \" (Ada 2012)?y?\", N);\n+         end if;\n+      end Freezing_Point_Warning;\n+\n+      --------------------------------\n+      -- Is_Actual_Of_Instantiation --\n+      --------------------------------\n+\n+      function Is_Actual_Of_Instantiation\n+        (E    : Entity_Id;\n+         Inst : Node_Id) return Boolean\n+      is\n+         Assoc : Node_Id;\n+\n+      begin\n+         if Present (Generic_Associations (Inst)) then\n+            Assoc := First (Generic_Associations (Inst));\n+\n+            while Present (Assoc) loop\n+               if Present (Explicit_Generic_Actual_Parameter (Assoc))\n+                 and then\n+                   Is_Entity_Name (Explicit_Generic_Actual_Parameter (Assoc))\n+                 and then\n+                   Entity (Explicit_Generic_Actual_Parameter (Assoc)) = E\n+               then\n+                  return True;\n+               end if;\n+\n+               Next (Assoc);\n+            end loop;\n+         end if;\n+\n+         return False;\n+      end Is_Actual_Of_Instantiation;\n+\n+      --  Local variable\n+\n+      Decl : Node_Id;\n+\n+   --  Start of processing for Check_Untagged_Equality\n+\n+   begin\n+      --  This check applies only if we have a subprogram declaration or a\n+      --  subprogram body that is not a completion, for an untagged record\n+      --  type, and that is conformant with the predefined operator.\n+\n+      if (Nkind (Eq_Decl) /= N_Subprogram_Declaration\n+           and then not (Nkind (Eq_Decl) = N_Subprogram_Body\n+                          and then Acts_As_Spec (Eq_Decl)))\n+        or else not Is_Record_Type (Typ)\n+        or else Is_Tagged_Type (Typ)\n+        or else not Is_User_Defined_Equality (Eq_Op)\n+      then\n+         return;\n+      end if;\n+\n+      --  In Ada 2012 case, we will output errors or warnings depending on\n+      --  the setting of debug flag -gnatd.E.\n+\n+      if Ada_Version >= Ada_2012 then\n+         Error_Msg_Warn := Debug_Flag_Dot_EE;\n+\n+      --  In earlier versions of Ada, nothing to do unless we are warning on\n+      --  Ada 2012 incompatibilities (Warn_On_Ada_2012_Incompatibility set).\n+\n+      else\n+         if not Warn_On_Ada_2012_Compatibility then\n+            return;\n+         end if;\n+      end if;\n+\n+      --  Cases where the type has already been frozen\n+\n+      if Is_Frozen (Typ) then\n+\n+         --  The check applies to a primitive operation, so check that type\n+         --  and equality operation are in the same scope.\n+\n+         if Scope (Typ) /= Current_Scope then\n+            return;\n+\n+         --  If the type is a generic actual (sub)type, the operation is not\n+         --  primitive either because the base type is declared elsewhere.\n+\n+         elsif Is_Generic_Actual_Type (Typ) then\n+            return;\n+\n+         --  Here we may have an error of declaration after freezing, but we\n+         --  must make sure not to flag the equality operator itself causing\n+         --  the freezing when it is a subprogram body.\n+\n+         else\n+            Decl := Next (Declaration_Node (Typ));\n+\n+            while Present (Decl) and then Decl /= Eq_Decl loop\n+\n+               --  The declaration of an object of the type\n+\n+               if Nkind (Decl) = N_Object_Declaration\n+                 and then Etype (Defining_Identifier (Decl)) = Typ\n+               then\n+                  Freezing_Point_Warning (Decl, \"declaration\");\n+                  exit;\n+\n+               --  The instantiation of a generic on the type\n+\n+               elsif Nkind (Decl) in N_Generic_Instantiation\n+                 and then Is_Actual_Of_Instantiation (Typ, Decl)\n+               then\n+                  Freezing_Point_Warning (Decl, \"instantiation\");\n+                  exit;\n+\n+               --  A noninstance proper body, body stub or entry body\n+\n+               elsif Nkind (Decl) in N_Proper_Body\n+                                   | N_Body_Stub\n+                                   | N_Entry_Body\n+                 and then not Is_Generic_Instance (Defining_Entity (Decl))\n+               then\n+                  Freezing_Point_Warning (Decl, \"body\");\n+                  exit;\n+\n+               --  If we have reached the freeze node and immediately after we\n+               --  have the body or generated code for the body, then it is the\n+               --  body that caused the freezing and this is legal.\n+\n+               elsif Nkind (Decl) = N_Freeze_Entity\n+                 and then Entity (Decl) = Typ\n+                 and then (Next (Decl) = Eq_Decl\n+                            or else\n+                           Sloc (Next (Decl)) = Sloc (Eq_Decl))\n+               then\n+                  return;\n+               end if;\n+\n+               Next (Decl);\n+            end loop;\n+\n+            --  Here we have a definite error of declaration after freezing\n+\n+            if Ada_Version >= Ada_2012 then\n+               Error_Msg_NE\n+                 (\"equality operator must be declared before type & is \"\n+                  & \"frozen (RM 4.5.2 (9.8)) (Ada 2012)<<\", Eq_Op, Typ);\n+\n+               --  In Ada 2012 mode with error turned to warning, output one\n+               --  more warning to warn that the equality operation may not\n+               --  compose. This is the consequence of ignoring the error.\n+\n+               if Error_Msg_Warn then\n+                  Error_Msg_N (\"\\equality operation may not compose??\", Eq_Op);\n+               end if;\n+\n+            else\n+               Error_Msg_NE\n+                 (\"equality operator must be declared before type& is \"\n+                  & \"frozen (RM 4.5.2 (9.8)) (Ada 2012)?y?\", Eq_Op, Typ);\n+            end if;\n+\n+            --  If we have found no freezing point and the declaration of the\n+            --  operator could not be reached from that of the type and we are\n+            --  in a package body, this must be because the type is declared\n+            --  in the spec of the package. Add a message tailored to this.\n+\n+            if No (Decl) and then In_Package_Body (Scope (Typ)) then\n+               if Ada_Version >= Ada_2012 then\n+                  if Nkind (Eq_Decl) = N_Subprogram_Body then\n+                     Error_Msg_N\n+                       (\"\\put declaration in package spec<<\", Eq_Op);\n+                  else\n+                     Error_Msg_N\n+                       (\"\\move declaration to package spec<<\", Eq_Op);\n+                  end if;\n+\n+               else\n+                  if Nkind (Eq_Decl) = N_Subprogram_Body then\n+                     Error_Msg_N\n+                       (\"\\put declaration in package spec (Ada 2012)?y?\",\n+                        Eq_Op);\n+                  else\n+                     Error_Msg_N\n+                       (\"\\move declaration to package spec (Ada 2012)?y?\",\n+                        Eq_Op);\n+                  end if;\n+               end if;\n+            end if;\n+         end if;\n+\n+      --  Now check for AI12-0352: the declaration of a user-defined primitive\n+      --  equality operation for a record type T is illegal if it occurs after\n+      --  a type has been derived from T.\n+\n+      else\n+         Decl := Next (Declaration_Node (Typ));\n+\n+         while Present (Decl) and then Decl /= Eq_Decl loop\n+            if Nkind (Decl) = N_Full_Type_Declaration\n+              and then Etype (Defining_Identifier (Decl)) = Typ\n+            then\n+               Error_Msg_N\n+                 (\"equality operator cannot appear after derivation\", Eq_Op);\n+               Error_Msg_NE\n+                 (\"an equality operator for& cannot be declared after \"\n+                  & \"this point??\",\n+                  Decl, Typ);\n+            end if;\n+\n+            Next (Decl);\n+         end loop;\n+      end if;\n+   end Check_Untagged_Equality;\n+\n    ---------------------------\n    -- Can_Override_Operator --\n    ---------------------------\n@@ -8950,6 +9206,26 @@ package body Sem_Ch6 is\n       --  BIP_xxx denotes an extra formal for a build-in-place function. See\n       --  the full list in exp_ch6.BIP_Formal_Kind.\n \n+      function Has_Extra_Formals (E : Entity_Id) return Boolean;\n+      --  Determines if E has its extra formals\n+\n+      function Needs_Accessibility_Check_Extra\n+        (E      : Entity_Id;\n+         Formal : Node_Id) return Boolean;\n+      --  Determines whether the given formal of E needs an extra formal for\n+      --  supporting accessibility checking. Returns True for both anonymous\n+      --  access formals and formals of named access types that are marked as\n+      --  controlling formals. The latter case can occur when the subprogram\n+      --  Expand_Dispatching_Call creates a subprogram-type and substitutes\n+      --  the types of access-to-class-wide actuals for the anonymous access-\n+      --  to-specific-type of controlling formals.\n+\n+      function Parent_Subprogram (Subp_Id : Entity_Id) return Entity_Id;\n+      --  Subp_Id is a subprogram of a derived type; return its parent\n+      --  subprogram if Subp_Id overrides a parent primitive or derives\n+      --  from a parent primitive, and such parent primitive can have extra\n+      --  formals. Otherwise return Empty.\n+\n       ----------------------\n       -- Add_Extra_Formal --\n       ----------------------\n@@ -8960,10 +9236,7 @@ package body Sem_Ch6 is\n          Scope        : Entity_Id;\n          Suffix       : String) return Entity_Id\n       is\n-         EF : constant Entity_Id :=\n-                Make_Defining_Identifier (Sloc (Assoc_Entity),\n-                  Chars  => New_External_Name (Chars (Assoc_Entity),\n-                                               Suffix => Suffix));\n+         EF : Entity_Id;\n \n       begin\n          --  A little optimization. Never generate an extra formal for the\n@@ -8974,6 +9247,10 @@ package body Sem_Ch6 is\n             return Empty;\n          end if;\n \n+         EF := Make_Defining_Identifier (Sloc (Assoc_Entity),\n+                 Chars => New_External_Name (Chars (Assoc_Entity),\n+                                             Suffix => Suffix));\n+\n          Mutate_Ekind        (EF, E_In_Parameter);\n          Set_Actual_Subtype  (EF, Typ);\n          Set_Etype           (EF, Typ);\n@@ -8995,49 +9272,266 @@ package body Sem_Ch6 is\n          return EF;\n       end Add_Extra_Formal;\n \n-      --  Local variables\n+      -----------------------\n+      -- Has_Extra_Formals --\n+      -----------------------\n \n-      Formal_Type : Entity_Id;\n-      P_Formal    : Entity_Id;\n+      function Has_Extra_Formals (E : Entity_Id) return Boolean is\n+      begin\n+         return Present (Extra_Formals (E))\n+           or else\n+             (Ekind (E) = E_Function\n+                and then Present (Extra_Accessibility_Of_Result (E)));\n+      end Has_Extra_Formals;\n+\n+      -------------------------------------\n+      -- Needs_Accessibility_Check_Extra --\n+      -------------------------------------\n+\n+      function Needs_Accessibility_Check_Extra\n+        (E      : Entity_Id;\n+         Formal : Node_Id) return Boolean is\n+\n+      begin\n+         --  For dispatching operations this extra formal is not suppressed\n+         --  since all the derivations must have matching formals.\n+\n+         --  For nondispatching operations it is suppressed if we specifically\n+         --  suppress accessibility checks at the package level for either the\n+         --  subprogram, or the package in which it resides. However, we do\n+         --  not suppress it simply if the scope has accessibility checks\n+         --  suppressed, since this could cause trouble when clients are\n+         --  compiled with a different suppression setting. The explicit checks\n+         --  at the package level are safe from this point of view.\n+\n+         if not Is_Dispatching_Operation (E)\n+           and then\n+             (Explicit_Suppress (E, Accessibility_Check)\n+                or else Explicit_Suppress (Scope (E), Accessibility_Check))\n+         then\n+            return False;\n+         end if;\n+\n+         --  Base_Type is applied to handle cases where there is a null\n+         --  exclusion the formal may have an access subtype.\n+\n+         return\n+           Ekind (Base_Type (Etype (Formal))) = E_Anonymous_Access_Type\n+             or else\n+               (Is_Controlling_Formal (Formal)\n+                  and then Is_Access_Type (Base_Type (Etype (Formal))));\n+      end Needs_Accessibility_Check_Extra;\n+\n+      -----------------------\n+      -- Parent_Subprogram --\n+      -----------------------\n+\n+      function Parent_Subprogram (Subp_Id : Entity_Id) return Entity_Id is\n+         pragma Assert (not Is_Thunk (Subp_Id));\n+         Ovr_E     : Entity_Id := Overridden_Operation (Subp_Id);\n+         Ovr_Alias : Entity_Id;\n+\n+      begin\n+         if Present (Ovr_E) then\n+            Ovr_Alias := Ultimate_Alias (Ovr_E);\n+\n+            --  There is no real overridden subprogram if there is a mutual\n+            --  reference between the E and its overridden operation. This\n+            --  weird scenery occurs in the following cases:\n+\n+            --  1) Controlling function wrappers internally built by\n+            --     Make_Controlling_Function_Wrappers.\n+\n+            --  2) Hidden overridden primitives of type extensions or private\n+            --     extensions (cf. Find_Hidden_Overridden_Primitive). These\n+            --     hidden primitives have suffix 'P'.\n+\n+            --  3) Overriding primitives of stub types (see the subprogram\n+            --     Add_RACW_Primitive_Declarations_And_Bodies).\n+\n+            if Ovr_Alias = Subp_Id then\n+               pragma Assert\n+                 ((Is_Wrapper (Subp_Id)\n+                     and then Has_Controlling_Result (Subp_Id))\n+                   or else Has_Suffix (Ovr_E, 'P')\n+                   or else Is_RACW_Stub_Type\n+                             (Find_Dispatching_Type (Subp_Id)));\n+\n+               if Present (Overridden_Operation (Ovr_E)) then\n+                  Ovr_E := Overridden_Operation (Ovr_E);\n+\n+               --  Ovr_E is an internal entity built by Derive_Subprogram and\n+               --  we have no direct way to climb to the corresponding parent\n+               --  subprogram but this internal entity has the extra formals\n+               --  (if any) required for the purpose of checking the extra\n+               --  formals of Subp_Id.\n+\n+               else\n+                  pragma Assert (not Comes_From_Source (Ovr_E));\n+               end if;\n+\n+            --  Use as our reference entity the ultimate renaming of the\n+            --  overridden subprogram.\n+\n+            elsif Present (Alias (Ovr_E)) then\n+               pragma Assert (No (Overridden_Operation (Ovr_Alias))\n+                 or else Overridden_Operation (Ovr_Alias) /= Ovr_E);\n+\n+               Ovr_E := Ovr_Alias;\n+            end if;\n+         end if;\n+\n+         if Present (Ovr_E) and then Has_Reliable_Extra_Formals (Ovr_E) then\n+            return Ovr_E;\n+         else\n+            return Empty;\n+         end if;\n+      end Parent_Subprogram;\n+\n+      --  Local variables\n+\n+      Formal_Type      : Entity_Id;\n+      May_Have_Alias   : Boolean;\n+      Alias_Formal     : Entity_Id := Empty;\n+      Alias_Subp       : Entity_Id := Empty;\n+      Parent_Formal    : Entity_Id := Empty;\n+      Parent_Subp      : Entity_Id := Empty;\n+      Ref_E            : Entity_Id;\n \n    --  Start of processing for Create_Extra_Formals\n \n    begin\n+      pragma Assert (Is_Subprogram_Or_Entry (E)\n+        or else Ekind (E) in E_Subprogram_Type);\n+\n       --  We never generate extra formals if expansion is not active because we\n       --  don't need them unless we are generating code.\n \n       if not Expander_Active then\n          return;\n-      end if;\n+\n+      --  Enumeration literals have no extra formal; this case occurs when\n+      --  a function renames it.\n+\n+      elsif Ekind (E) = E_Function\n+        and then Ekind (Ultimate_Alias (E)) = E_Enumeration_Literal\n+      then\n+         return;\n+\n+      --  Initialization procedures don't have extra formals\n+\n+      elsif Is_Init_Proc (E) then\n+         return;\n \n       --  No need to generate extra formals in thunks whose target has no extra\n       --  formals, but we can have two of them chained (interface and stack).\n \n-      if Is_Thunk (E) and then No (Extra_Formals (Thunk_Target (E))) then\n+      elsif Is_Thunk (E) and then No (Extra_Formals (Thunk_Target (E))) then\n          return;\n-      end if;\n \n-      --  If this is a derived subprogram then the subtypes of the parent\n-      --  subprogram's formal parameters will be used to determine the need\n-      --  for extra formals.\n+      --  If Extra_Formals were already created, don't do it again. This\n+      --  situation may arise for subprogram types created as part of\n+      --  dispatching calls (see Expand_Dispatching_Call).\n \n-      if Is_Overloadable (E) and then Present (Alias (E)) then\n-         P_Formal := First_Formal (Alias (E));\n-      else\n-         P_Formal := Empty;\n+      elsif Has_Extra_Formals (E) then\n+         return;\n+\n+      --  Extra formals of renamings of generic actual subprograms and\n+      --  renamings of instances of generic subprograms are shared. The\n+      --  check performed on the last formal is required to ensure that\n+      --  this is the renaming built by Analyze_Instance_And_Renamings\n+      --  (which shares all the formals); otherwise this would be wrong.\n+\n+      elsif Ekind (E) in E_Function | E_Procedure\n+        and then Is_Generic_Instance (E)\n+        and then Present (Alias (E))\n+        and then Last_Formal (Ultimate_Alias (E)) = Last_Formal (E)\n+      then\n+         pragma Assert (Is_Generic_Instance (E)\n+           = Is_Generic_Instance (Ultimate_Alias (E)));\n+\n+         Create_Extra_Formals (Ultimate_Alias (E));\n+\n+         --  Share the extra formals\n+\n+         Set_Extra_Formals (E, Extra_Formals (Ultimate_Alias (E)));\n+\n+         if Ekind (E) = E_Function then\n+            Set_Extra_Accessibility_Of_Result (E,\n+              Extra_Accessibility_Of_Result (Ultimate_Alias (E)));\n+         end if;\n+\n+         pragma Assert (Extra_Formals_OK (E));\n+         return;\n       end if;\n \n+      --  Locate the last formal; required by Add_Extra_Formal.\n+\n       Formal := First_Formal (E);\n       while Present (Formal) loop\n          Last_Extra := Formal;\n          Next_Formal (Formal);\n       end loop;\n \n-      --  If Extra_Formals were already created, don't do it again. This\n-      --  situation may arise for subprogram types created as part of\n-      --  dispatching calls (see Expand_Dispatching_Call).\n+      --  We rely on three entities to ensure consistency of extra formals of\n+      --  entity E:\n+      --\n+      --    1. A reference entity (Ref_E). For thunks it is their target\n+      --       primitive since this ensures that they have exactly the\n+      --       same extra formals; otherwise it is the identity.\n+      --\n+      --    2. The parent subprogram; only for derived types and references\n+      --       either the overridden subprogram or the internal entity built\n+      --       by Derive_Subprogram that has the extra formals of the parent\n+      --       subprogram; otherwise it is Empty. This entity ensures matching\n+      --       extra formals in derived types.\n+      --\n+      --    3. For renamings, their ultimate alias; this ensures taking the\n+      --       same decision in all the renamings (independently of the Ada\n+      --       mode on which they are compiled). For example:\n+      --\n+      --          pragma Ada_2012;\n+      --          function Id_A (I : access Integer) return access Integer;\n+      --\n+      --          pragma Ada_2005;\n+      --          function Id_B (I : access Integer) return access Integer\n+      --             renames Id_A;\n \n-      if Present (Last_Extra) and then Present (Extra_Formal (Last_Extra)) then\n+      if Is_Thunk (E) then\n+         Ref_E := Thunk_Target (E);\n+      else\n+         Ref_E := E;\n+      end if;\n+\n+      if Is_Subprogram (Ref_E) then\n+         Parent_Subp := Parent_Subprogram (Ref_E);\n+      end if;\n+\n+      May_Have_Alias :=\n+        (Is_Subprogram (Ref_E) or else Ekind (Ref_E) = E_Subprogram_Type);\n+\n+      --  If the parent subprogram is available then its ultimate alias of\n+      --  Ref_E is not needed since it will not be used to check its extra\n+      --  formals.\n+\n+      if No (Parent_Subp)\n+        and then May_Have_Alias\n+        and then Present (Alias (Ref_E))\n+        and then Has_Reliable_Extra_Formals (Ultimate_Alias (Ref_E))\n+      then\n+         Alias_Subp := Ultimate_Alias (Ref_E);\n+      end if;\n+\n+      --  Cannot add extra formals to subprograms and access types that have\n+      --  foreign convention nor to subprograms overriding primitives that\n+      --  have foreign convention since the foreign language does not know\n+      --  how to handle these extra formals; same for renamings of entities\n+      --  with foreign convention.\n+\n+      if Has_Foreign_Convention (Ref_E)\n+        or else (Present (Alias_Subp)\n+                   and then Has_Foreign_Convention (Alias_Subp))\n+      then\n          return;\n       end if;\n \n@@ -9052,20 +9546,74 @@ package body Sem_Ch6 is\n          goto Test_For_Func_Result_Extras;\n       end if;\n \n+      --  Process the formals relying on the formals of our reference entities:\n+      --  Parent_Formal, Alias_Formal and Formal. Notice that we don't use the\n+      --  formal of Ref_E; we must use the formal of E which is the entity to\n+      --  which we are adding the extra formals.\n+\n+      --  If this is a derived subprogram then the subtypes of the parent\n+      --  subprogram's formal parameters will be used to determine the need\n+      --  for extra formals.\n+\n+      if Present (Parent_Subp) then\n+         Parent_Formal := First_Formal (Parent_Subp);\n+\n+         --  For concurrent types, the controlling argument of a dispatching\n+         --  primitive implementing an interface primitive is implicit. For\n+         --  example:\n+         --\n+         --     type Iface is protected interface;\n+         --     function Prim\n+         --       (Obj   : Iface;\n+         --        Value : Integer) return Natural is abstract;\n+         --\n+         --     protected type PO is new Iface with\n+         --        function Prim (Value : Integer) return Natural;\n+         --     end PO;\n+\n+         if Convention (Ref_E) = Convention_Protected\n+           and then Is_Abstract_Subprogram (Parent_Subp)\n+           and then Is_Interface (Find_Dispatching_Type (Parent_Subp))\n+         then\n+            Parent_Formal := Next_Formal (Parent_Formal);\n+\n+            --  This is the nondispatching subprogram of a concurrent type\n+            --  that overrides the interface primitive; the expander will\n+            --  create the dispatching primitive (without Convention_Protected)\n+            --  with all the matching formals (see exp_ch9.Build_Wrapper_Specs)\n+\n+            pragma Assert (not Is_Dispatching_Operation (Ref_E));\n+         end if;\n+\n+      --  Ensure that the ultimate alias has all its extra formals\n+\n+      elsif Present (Alias_Subp) then\n+         Create_Extra_Formals (Alias_Subp);\n+         Alias_Formal := First_Formal (Alias_Subp);\n+      end if;\n+\n       Formal := First_Formal (E);\n       while Present (Formal) loop\n \n+         --  Here we establish our priority for deciding on the extra\n+         --  formals: 1) Parent primitive 2) Aliased primitive 3) Identity\n+\n+         if Present (Parent_Formal) then\n+            Formal_Type := Etype (Parent_Formal);\n+\n+         elsif Present (Alias_Formal) then\n+            Formal_Type := Etype (Alias_Formal);\n+\n+         else\n+            Formal_Type := Etype (Formal);\n+         end if;\n+\n          --  Create extra formal for supporting the attribute 'Constrained.\n          --  The case of a private type view without discriminants also\n          --  requires the extra formal if the underlying type has defaulted\n          --  discriminants.\n \n          if Ekind (Formal) /= E_In_Parameter then\n-            if Present (P_Formal) then\n-               Formal_Type := Etype (P_Formal);\n-            else\n-               Formal_Type := Etype (Formal);\n-            end if;\n \n             --  Do not produce extra formals for Unchecked_Union parameters.\n             --  Jump directly to the end of the loop.\n@@ -9110,66 +9658,83 @@ package body Sem_Ch6 is\n             end if;\n          end if;\n \n-         --  Create extra formal for supporting accessibility checking. This\n-         --  is done for both anonymous access formals and formals of named\n-         --  access types that are marked as controlling formals. The latter\n-         --  case can occur when Expand_Dispatching_Call creates a subprogram\n-         --  type and substitutes the types of access-to-class-wide actuals\n-         --  for the anonymous access-to-specific-type of controlling formals.\n-         --  Base_Type is applied because in cases where there is a null\n-         --  exclusion the formal may have an access subtype.\n+         --  Extra formal for supporting accessibility checking\n+\n+         if Needs_Accessibility_Check_Extra (Ref_E, Formal) then\n+            pragma Assert (No (Parent_Formal)\n+              or else Present (Extra_Accessibility (Parent_Formal)));\n+            pragma Assert (No (Alias_Formal)\n+              or else Present (Extra_Accessibility (Alias_Formal)));\n \n-         --  This is suppressed if we specifically suppress accessibility\n-         --  checks at the package level for either the subprogram, or the\n-         --  package in which it resides. However, we do not suppress it\n-         --  simply if the scope has accessibility checks suppressed, since\n-         --  this could cause trouble when clients are compiled with a\n-         --  different suppression setting. The explicit checks at the\n-         --  package level are safe from this point of view.\n-\n-         if (Ekind (Base_Type (Etype (Formal))) = E_Anonymous_Access_Type\n-              or else (Is_Controlling_Formal (Formal)\n-                        and then Is_Access_Type (Base_Type (Etype (Formal)))))\n-           and then not\n-             (Explicit_Suppress (E, Accessibility_Check)\n-               or else\n-              Explicit_Suppress (Scope (E), Accessibility_Check))\n-           and then\n-             (No (P_Formal)\n-               or else Present (Extra_Accessibility (P_Formal)))\n-         then\n             Set_Extra_Accessibility\n               (Formal, Add_Extra_Formal (Formal, Standard_Natural, E, \"L\"));\n+\n+         else\n+            pragma Assert (No (Parent_Formal)\n+              or else No (Extra_Accessibility (Parent_Formal)));\n+            pragma Assert (No (Alias_Formal)\n+              or else No (Extra_Accessibility (Alias_Formal)));\n          end if;\n \n          --  This label is required when skipping extra formal generation for\n          --  Unchecked_Union parameters.\n \n          <<Skip_Extra_Formal_Generation>>\n \n-         if Present (P_Formal) then\n-            Next_Formal (P_Formal);\n+         if Present (Parent_Formal) then\n+            Next_Formal (Parent_Formal);\n+         end if;\n+\n+         if Present (Alias_Formal) then\n+            Next_Formal (Alias_Formal);\n          end if;\n \n          Next_Formal (Formal);\n       end loop;\n \n       <<Test_For_Func_Result_Extras>>\n \n-      --  Ada 2012 (AI05-234): \"the accessibility level of the result of a\n-      --  function call is ... determined by the point of call ...\".\n+      --  Assume the worst case (Ada 2022) to evaluate this extra formal;\n+      --  required to ensure matching of extra formals between subprograms\n+      --  and access-to-subprogram types in projects with mixed Ada dialects.\n \n-      if Needs_Result_Accessibility_Level (E) then\n-         Set_Extra_Accessibility_Of_Result\n-           (E, Add_Extra_Formal (E, Standard_Natural, E, \"L\"));\n-      end if;\n+      declare\n+         Save_Ada_Version : constant Ada_Version_Type := Ada_Version;\n+\n+      begin\n+         Ada_Version := Ada_2022;\n+\n+         if Needs_Result_Accessibility_Level (Ref_E) then\n+            pragma Assert (No (Parent_Subp)\n+              or else Needs_Result_Accessibility_Level (Parent_Subp));\n+            pragma Assert (No (Alias_Subp)\n+              or else Needs_Result_Accessibility_Level (Alias_Subp));\n+\n+            Set_Extra_Accessibility_Of_Result (E,\n+              Add_Extra_Formal (E, Standard_Natural, E, \"L\"));\n+\n+         else\n+            pragma Assert (No (Parent_Subp)\n+              or else not Needs_Result_Accessibility_Level (Parent_Subp));\n+            pragma Assert (No (Alias_Subp)\n+              or else not Needs_Result_Accessibility_Level (Alias_Subp));\n+         end if;\n+\n+         Ada_Version := Save_Ada_Version;\n+      end;\n \n       --  Ada 2005 (AI-318-02): In the case of build-in-place functions, add\n       --  appropriate extra formals. See type Exp_Ch6.BIP_Formal_Kind.\n \n-      if Is_Build_In_Place_Function (E) then\n+      if (Present (Parent_Subp) and then Has_BIP_Formals (Parent_Subp))\n+            or else\n+         (Present (Alias_Subp) and then Has_BIP_Formals (Alias_Subp))\n+            or else\n+         (Is_Build_In_Place_Function (Ref_E)\n+            and then Has_Reliable_Extra_Formals (Ref_E))\n+      then\n          declare\n-            Result_Subt : constant Entity_Id := Etype (E);\n+            Result_Subt : constant Entity_Id := Etype (Ref_E);\n             Formal_Typ  : Entity_Id;\n             Subp_Decl   : Node_Id;\n             Discard     : Entity_Id;\n@@ -9187,7 +9752,14 @@ package body Sem_Ch6 is\n             --  dispatching context and such calls must be handled like calls\n             --  to a class-wide function.\n \n-            if Needs_BIP_Alloc_Form (E) then\n+            if Needs_BIP_Alloc_Form (Ref_E) then\n+               pragma Assert (No (Parent_Subp)\n+                 or else Has_BIP_Extra_Formal (Parent_Subp, BIP_Alloc_Form,\n+                           Must_Be_Frozen => False));\n+               pragma Assert (No (Alias_Subp)\n+                 or else Has_BIP_Extra_Formal (Alias_Subp, BIP_Alloc_Form,\n+                           Must_Be_Frozen => False));\n+\n                Discard :=\n                  Add_Extra_Formal\n                    (E, Standard_Natural,\n@@ -9203,23 +9775,66 @@ package body Sem_Ch6 is\n                       (E, RTE (RE_Root_Storage_Pool_Ptr),\n                        E, BIP_Formal_Suffix (BIP_Storage_Pool));\n                end if;\n+\n+            else\n+               pragma Assert (No (Parent_Subp)\n+                 or else not\n+                   Has_BIP_Extra_Formal (Parent_Subp, BIP_Alloc_Form,\n+                     Must_Be_Frozen => False));\n+               pragma Assert (No (Alias_Subp)\n+                 or else not\n+                   Has_BIP_Extra_Formal (Alias_Subp, BIP_Alloc_Form,\n+                     Must_Be_Frozen => False));\n             end if;\n \n             --  In the case of functions whose result type needs finalization,\n             --  add an extra formal which represents the finalization master.\n \n-            if Needs_BIP_Finalization_Master (E) then\n+            if Needs_BIP_Finalization_Master (Ref_E) then\n+               pragma Assert (No (Parent_Subp)\n+                 or else Has_BIP_Extra_Formal (Parent_Subp,\n+                           Kind           => BIP_Finalization_Master,\n+                           Must_Be_Frozen => False));\n+               pragma Assert (No (Alias_Subp)\n+                 or else Has_BIP_Extra_Formal (Alias_Subp,\n+                           Kind           => BIP_Finalization_Master,\n+                           Must_Be_Frozen => False));\n+\n                Discard :=\n                  Add_Extra_Formal\n                    (E, RTE (RE_Finalization_Master_Ptr),\n                     E, BIP_Formal_Suffix (BIP_Finalization_Master));\n+\n+            else\n+               pragma Assert (No (Parent_Subp)\n+                 or else not\n+                   Has_BIP_Extra_Formal (Parent_Subp,\n+                     Kind           => BIP_Finalization_Master,\n+                     Must_Be_Frozen => False));\n+               pragma Assert (No (Alias_Subp)\n+                 or else not\n+                   Has_BIP_Extra_Formal (Alias_Subp,\n+                     Kind           => BIP_Finalization_Master,\n+                     Must_Be_Frozen => False));\n             end if;\n \n             --  When the result type contains tasks, add two extra formals: the\n             --  master of the tasks to be created, and the caller's activation\n             --  chain.\n \n-            if Needs_BIP_Task_Actuals (E) then\n+            if Needs_BIP_Task_Actuals (Ref_E) then\n+               pragma Assert (No (Parent_Subp)\n+                 or else Has_BIP_Extra_Formal (Parent_Subp, BIP_Task_Master,\n+                           Must_Be_Frozen => False));\n+               pragma Assert (No (Alias_Subp)\n+                 or else Has_BIP_Extra_Formal (Alias_Subp, BIP_Task_Master,\n+                           Must_Be_Frozen => False)\n+                 or else\n+                   (Is_Abstract_Subprogram (Ref_E)\n+                      and then Is_Predefined_Dispatching_Operation (Ref_E)\n+                      and then Is_Interface\n+                                 (Find_Dispatching_Type (Alias_Subp))));\n+\n                Discard :=\n                  Add_Extra_Formal\n                    (E, Standard_Integer,\n@@ -9231,6 +9846,16 @@ package body Sem_Ch6 is\n                  Add_Extra_Formal\n                    (E, RTE (RE_Activation_Chain_Access),\n                     E, BIP_Formal_Suffix (BIP_Activation_Chain));\n+\n+            else\n+               pragma Assert (No (Parent_Subp)\n+                 or else not\n+                   Has_BIP_Extra_Formal (Parent_Subp, BIP_Task_Master,\n+                     Must_Be_Frozen => False));\n+               pragma Assert (No (Alias_Subp)\n+                 or else not\n+                   Has_BIP_Extra_Formal (Alias_Subp, BIP_Task_Master,\n+                     Must_Be_Frozen => False));\n             end if;\n \n             --  All build-in-place functions get an extra formal that will be\n@@ -9296,6 +9921,14 @@ package body Sem_Ch6 is\n       if Is_Generic_Instance (E) and then Present (Alias (E)) then\n          Set_Extra_Formals (Alias (E), Extra_Formals (E));\n       end if;\n+\n+      pragma Assert (No (Alias_Subp)\n+        or else Extra_Formals_Match_OK (E, Alias_Subp));\n+\n+      pragma Assert (No (Parent_Subp)\n+        or else Extra_Formals_Match_OK (E, Parent_Subp));\n+\n+      pragma Assert (Extra_Formals_OK (E));\n    end Create_Extra_Formals;\n \n    -----------------------------\n@@ -9526,252 +10159,162 @@ package body Sem_Ch6 is\n       end if;\n    end Enter_Overloaded_Entity;\n \n-   -----------------------------\n-   -- Check_Untagged_Equality --\n-   -----------------------------\n-\n-   procedure Check_Untagged_Equality (Eq_Op : Entity_Id) is\n-      Eq_Decl : constant Node_Id   := Unit_Declaration_Node (Eq_Op);\n-      Typ     : constant Entity_Id := Etype (First_Formal (Eq_Op));\n-\n-      procedure Freezing_Point_Warning (N : Node_Id; S : String);\n-      --  Output a warning about the freezing point N of Typ\n-\n-      function Is_Actual_Of_Instantiation\n-        (E    : Entity_Id;\n-         Inst : Node_Id) return Boolean;\n-      --  Return True if E is an actual parameter of instantiation Inst\n-\n-      -----------------------------------\n-      -- Output_Freezing_Point_Warning --\n-      -----------------------------------\n-\n-      procedure Freezing_Point_Warning (N : Node_Id; S : String) is\n-      begin\n-         Error_Msg_String (1 .. S'Length) := S;\n-         Error_Msg_Strlen := S'Length;\n-\n-         if Ada_Version >= Ada_2012 then\n-            Error_Msg_NE (\"type& is frozen by ~??\", N, Typ);\n-            Error_Msg_N\n-              (\"\\an equality operator cannot be declared after this point??\",\n-               N);\n-\n-         else\n-            Error_Msg_NE (\"type& is frozen by ~ (Ada 2012)?y?\", N, Typ);\n-            Error_Msg_N\n-              (\"\\an equality operator cannot be declared after this point\"\n-               & \" (Ada 2012)?y?\", N);\n-         end if;\n-      end Freezing_Point_Warning;\n-\n-      --------------------------------\n-      -- Is_Actual_Of_Instantiation --\n-      --------------------------------\n-\n-      function Is_Actual_Of_Instantiation\n-        (E    : Entity_Id;\n-         Inst : Node_Id) return Boolean\n-      is\n-         Assoc : Node_Id;\n-\n-      begin\n-         if Present (Generic_Associations (Inst)) then\n-            Assoc := First (Generic_Associations (Inst));\n-\n-            while Present (Assoc) loop\n-               if Present (Explicit_Generic_Actual_Parameter (Assoc))\n-                 and then\n-                   Is_Entity_Name (Explicit_Generic_Actual_Parameter (Assoc))\n-                 and then\n-                   Entity (Explicit_Generic_Actual_Parameter (Assoc)) = E\n-               then\n-                  return True;\n-               end if;\n-\n-               Next (Assoc);\n-            end loop;\n-         end if;\n-\n-         return False;\n-      end Is_Actual_Of_Instantiation;\n-\n-      --  Local variable\n-\n-      Decl : Node_Id;\n-\n-   --  Start of processing for Check_Untagged_Equality\n+   ----------------------------\n+   -- Extra_Formals_Match_OK --\n+   ----------------------------\n \n+   function Extra_Formals_Match_OK\n+     (E     : Entity_Id;\n+      Ref_E : Entity_Id) return Boolean is\n    begin\n-      --  This check applies only if we have a subprogram declaration or a\n-      --  subprogram body that is not a completion, for an untagged record\n-      --  type, and that is conformant with the predefined operator.\n+      pragma Assert (Is_Subprogram (E));\n+\n+      --  Cases where no check can be performed:\n+      --    1) When expansion is not active (since we never generate extra\n+      --       formals if expansion is not active because we don't need them\n+      --       unless we are generating code).\n+      --    2) On abstract predefined dispatching operations of Root_Controlled\n+      --       and predefined stream operations not emitted by the frontend.\n+      --    3) On renamings of abstract predefined dispatching operations of\n+      --       interface types (since limitedness is not inherited in such\n+      --       case (AI-419)).\n+      --    4) The controlling formal of the nondispatching subprogram of\n+      --       a concurrent type that overrides an interface primitive is\n+      --       implicit and hence we cannot check here if all its extra\n+      --       formals match; the expander will create the dispatching\n+      --       primitive (without Convention_Protected) with the matching\n+      --       formals (see exp_ch9.Build_Wrapper_Specs) which will be\n+      --       checked later.\n+\n+      if Debug_Flag_Underscore_XX\n+        or else not Expander_Active\n+        or else\n+          (Is_Predefined_Dispatching_Operation (E)\n+             and then (not Has_Reliable_Extra_Formals (E)\n+                         or else not Has_Reliable_Extra_Formals (Ref_E)))\n+        or else\n+          (Is_Predefined_Dispatching_Operation (E)\n+             and then Is_Abstract_Subprogram (E)\n+             and then Is_Interface (Find_Dispatching_Type (Ref_E)))\n+      then\n+         return True;\n \n-      if (Nkind (Eq_Decl) /= N_Subprogram_Declaration\n-           and then not (Nkind (Eq_Decl) = N_Subprogram_Body\n-                          and then Acts_As_Spec (Eq_Decl)))\n-        or else not Is_Record_Type (Typ)\n-        or else Is_Tagged_Type (Typ)\n-        or else not Is_User_Defined_Equality (Eq_Op)\n+      elsif Convention (E) = Convention_Protected\n+        and then not Is_Dispatching_Operation (E)\n+        and then Is_Abstract_Subprogram (Ref_E)\n+        and then Is_Interface (Find_Dispatching_Type (Ref_E))\n       then\n-         return;\n+         return True;\n       end if;\n \n-      --  In Ada 2012 case, we will output errors or warnings depending on\n-      --  the setting of debug flag -gnatd.E.\n-\n-      if Ada_Version >= Ada_2012 then\n-         Error_Msg_Warn := Debug_Flag_Dot_EE;\n+      --  Perform the checks\n \n-      --  In earlier versions of Ada, nothing to do unless we are warning on\n-      --  Ada 2012 incompatibilities (Warn_On_Ada_2012_Incompatibility set).\n-\n-      else\n-         if not Warn_On_Ada_2012_Compatibility then\n-            return;\n-         end if;\n+      if No (Extra_Formals (E)) then\n+         return No (Extra_Formals (Ref_E));\n       end if;\n \n-      --  Cases where the type has already been frozen\n-\n-      if Is_Frozen (Typ) then\n-\n-         --  The check applies to a primitive operation, so check that type\n-         --  and equality operation are in the same scope.\n-\n-         if Scope (Typ) /= Current_Scope then\n-            return;\n-\n-         --  If the type is a generic actual (sub)type, the operation is not\n-         --  primitive either because the base type is declared elsewhere.\n+      if Ekind (E) in E_Function | E_Subprogram_Type\n+        and then Present (Extra_Accessibility_Of_Result (E))\n+                   /= Present (Extra_Accessibility_Of_Result (Ref_E))\n+      then\n+         return False;\n+      end if;\n \n-         elsif Is_Generic_Actual_Type (Typ) then\n-            return;\n+      declare\n+         Formal_1 : Entity_Id := Extra_Formals (E);\n+         Formal_2 : Entity_Id := Extra_Formals (Ref_E);\n \n-         --  Here we may have an error of declaration after freezing, but we\n-         --  must make sure not to flag the equality operator itself causing\n-         --  the freezing when it is a subprogram body.\n+      begin\n+         while Present (Formal_1) and then Present (Formal_2) loop\n+            if Has_Suffix (Formal_1, 'L') then\n+               if not Has_Suffix (Formal_2, 'L') then\n+                  return False;\n+               end if;\n \n-         else\n-            Decl := Next (Declaration_Node (Typ));\n+            elsif Has_Suffix (Formal_1, 'O') then\n+               if not Has_Suffix (Formal_2, 'O') then\n+                  return False;\n+               end if;\n \n-            while Present (Decl) and then Decl /= Eq_Decl loop\n+            elsif BIP_Suffix_Kind (Formal_1) /= BIP_Suffix_Kind (Formal_2) then\n+               return False;\n+            end if;\n \n-               --  The declaration of an object of the type\n+            Formal_1 := Next_Formal_With_Extras (Formal_1);\n+            Formal_2 := Next_Formal_With_Extras (Formal_2);\n+         end loop;\n \n-               if Nkind (Decl) = N_Object_Declaration\n-                 and then Etype (Defining_Identifier (Decl)) = Typ\n-               then\n-                  Freezing_Point_Warning (Decl, \"declaration\");\n-                  exit;\n+         return No (Formal_1) and then No (Formal_2);\n+      end;\n+   end Extra_Formals_Match_OK;\n \n-               --  The instantiation of a generic on the type\n+   ----------------------\n+   -- Extra_Formals_OK --\n+   ----------------------\n \n-               elsif Nkind (Decl) in N_Generic_Instantiation\n-                 and then Is_Actual_Of_Instantiation (Typ, Decl)\n-               then\n-                  Freezing_Point_Warning (Decl, \"instantiation\");\n-                  exit;\n+   function Extra_Formals_OK (E : Entity_Id) return Boolean is\n+      Last_Formal       : Entity_Id := Empty;\n+      Formal            : Entity_Id;\n+      Has_Extra_Formals : Boolean := False;\n \n-               --  A noninstance proper body, body stub or entry body\n+   begin\n+      --  No check required if explicitly disabled\n \n-               elsif Nkind (Decl) in N_Proper_Body\n-                                   | N_Body_Stub\n-                                   | N_Entry_Body\n-                 and then not Is_Generic_Instance (Defining_Entity (Decl))\n-               then\n-                  Freezing_Point_Warning (Decl, \"body\");\n-                  exit;\n+      if Debug_Flag_Underscore_XX then\n+         return True;\n \n-               --  If we have reached the freeze node and immediately after we\n-               --  have the body or generated code for the body, then it is the\n-               --  body that caused the freezing and this is legal.\n+      --  No check required if expansion is disabled because extra\n+      --  formals are only generated when we are generating code.\n+      --  See Create_Extra_Formals.\n \n-               elsif Nkind (Decl) = N_Freeze_Entity\n-                 and then Entity (Decl) = Typ\n-                 and then (Next (Decl) = Eq_Decl\n-                            or else\n-                           Sloc (Next (Decl)) = Sloc (Eq_Decl))\n-               then\n-                  return;\n-               end if;\n+      elsif not Expander_Active then\n+         return True;\n+      end if;\n \n-               Next (Decl);\n-            end loop;\n+      --  Check attribute Extra_Formal: If available, it must be set only\n+      --  on the last formal of E.\n \n-            --  Here we have a definite error of declaration after freezing\n+      Formal := First_Formal (E);\n+      while Present (Formal) loop\n+         if Present (Extra_Formal (Formal)) then\n+            if Has_Extra_Formals then\n+               return False;\n+            end if;\n \n-            if Ada_Version >= Ada_2012 then\n-               Error_Msg_NE\n-                 (\"equality operator must be declared before type & is \"\n-                  & \"frozen (RM 4.5.2 (9.8)) (Ada 2012)<<\", Eq_Op, Typ);\n+            Has_Extra_Formals := True;\n+         end if;\n \n-               --  In Ada 2012 mode with error turned to warning, output one\n-               --  more warning to warn that the equality operation may not\n-               --  compose. This is the consequence of ignoring the error.\n+         Last_Formal := Formal;\n+         Next_Formal (Formal);\n+      end loop;\n \n-               if Error_Msg_Warn then\n-                  Error_Msg_N (\"\\equality operation may not compose??\", Eq_Op);\n-               end if;\n+      --  Check attribute Extra_Accessibility_Of_Result\n \n-            else\n-               Error_Msg_NE\n-                 (\"equality operator must be declared before type& is \"\n-                  & \"frozen (RM 4.5.2 (9.8)) (Ada 2012)?y?\", Eq_Op, Typ);\n-            end if;\n+      if Ekind (E) in E_Function | E_Subprogram_Type\n+        and then Needs_Result_Accessibility_Level (E)\n+        and then No (Extra_Accessibility_Of_Result (E))\n+      then\n+         return False;\n+      end if;\n \n-            --  If we have found no freezing point and the declaration of the\n-            --  operator could not be reached from that of the type and we are\n-            --  in a package body, this must be because the type is declared\n-            --  in the spec of the package. Add a message tailored to this.\n+      --  Check attribute Extra_Formals: If E has extra formals, then this\n+      --  attribute must point to the first extra formal of E.\n \n-            if No (Decl) and then In_Package_Body (Scope (Typ)) then\n-               if Ada_Version >= Ada_2012 then\n-                  if Nkind (Eq_Decl) = N_Subprogram_Body then\n-                     Error_Msg_N\n-                       (\"\\put declaration in package spec<<\", Eq_Op);\n-                  else\n-                     Error_Msg_N\n-                       (\"\\move declaration to package spec<<\", Eq_Op);\n-                  end if;\n+      if Has_Extra_Formals then\n+         return Present (Extra_Formals (E))\n+           and then Present (Extra_Formal (Last_Formal))\n+           and then Extra_Formal (Last_Formal) = Extra_Formals (E);\n \n-               else\n-                  if Nkind (Eq_Decl) = N_Subprogram_Body then\n-                     Error_Msg_N\n-                       (\"\\put declaration in package spec (Ada 2012)?y?\",\n-                        Eq_Op);\n-                  else\n-                     Error_Msg_N\n-                       (\"\\move declaration to package spec (Ada 2012)?y?\",\n-                        Eq_Op);\n-                  end if;\n-               end if;\n-            end if;\n-         end if;\n+      --  When E has no formals, the first extra formal is available through\n+      --  the Extra_Formals attribute.\n \n-      --  Now check for AI12-0352: the declaration of a user-defined primitive\n-      --  equality operation for a record type T is illegal if it occurs after\n-      --  a type has been derived from T.\n+      elsif Present (Extra_Formals (E)) then\n+         return No (First_Formal (E));\n \n       else\n-         Decl := Next (Declaration_Node (Typ));\n-\n-         while Present (Decl) and then Decl /= Eq_Decl loop\n-            if Nkind (Decl) = N_Full_Type_Declaration\n-              and then Etype (Defining_Identifier (Decl)) = Typ\n-            then\n-               Error_Msg_N\n-                 (\"equality operator cannot appear after derivation\", Eq_Op);\n-               Error_Msg_NE\n-                 (\"an equality operator for& cannot be declared after \"\n-                  & \"this point??\",\n-                  Decl, Typ);\n-            end if;\n-\n-            Next (Decl);\n-         end loop;\n+         return True;\n       end if;\n-   end Check_Untagged_Equality;\n+   end Extra_Formals_OK;\n \n    -----------------------------\n    -- Find_Corresponding_Spec --\n@@ -10656,6 +11199,89 @@ package body Sem_Ch6 is\n       end if;\n    end Fully_Conformant_Discrete_Subtypes;\n \n+   ---------------------\n+   -- Has_BIP_Formals --\n+   ---------------------\n+\n+   function Has_BIP_Formals (E : Entity_Id) return Boolean is\n+      Formal : Entity_Id := First_Formal_With_Extras (E);\n+\n+   begin\n+      while Present (Formal) loop\n+         if Is_Build_In_Place_Entity (Formal) then\n+            return True;\n+         end if;\n+\n+         Next_Formal_With_Extras (Formal);\n+      end loop;\n+\n+      return False;\n+   end Has_BIP_Formals;\n+\n+   --------------------------------\n+   -- Has_Reliable_Extra_Formals --\n+   --------------------------------\n+\n+   function Has_Reliable_Extra_Formals (E : Entity_Id) return Boolean is\n+      Alias_E : Entity_Id;\n+\n+   begin\n+      --  Extra formals are not added if expansion is not active (and hence if\n+      --  available they are not reliable for extra formals check).\n+\n+      if not Expander_Active then\n+         return False;\n+\n+      --  Currently the unique cases where extra formals are not reliable\n+      --  are associated with predefined dispatching operations; otherwise\n+      --  they are properly added when required.\n+\n+      elsif not Is_Predefined_Dispatching_Operation (E) then\n+         return True;\n+      end if;\n+\n+      Alias_E := Ultimate_Alias (E);\n+\n+      --  Abstract predefined primitives of Root_Controlled don't have\n+      --  extra formals; this is required to build the runtime.\n+\n+      if Ekind (Alias_E) = E_Function\n+        and then Is_Abstract_Subprogram (Alias_E)\n+        and then Is_RTE (Underlying_Type (Etype (Alias_E)),\n+                           RE_Root_Controlled)\n+      then\n+         return False;\n+\n+      --  Predefined stream dispatching operations that are not emitted by\n+      --  the frontend; they have a renaming of the corresponding primitive\n+      --  of their parent type and hence they don't have extra formals.\n+\n+      else\n+         declare\n+            Typ : constant Entity_Id :=\n+                    Underlying_Type (Find_Dispatching_Type (Alias_E));\n+\n+         begin\n+            if (Get_TSS_Name (E) = TSS_Stream_Input\n+                  and then not Stream_Operation_OK (Typ, TSS_Stream_Input))\n+              or else\n+                (Get_TSS_Name (E) = TSS_Stream_Output\n+                   and then not Stream_Operation_OK (Typ, TSS_Stream_Output))\n+              or else\n+                (Get_TSS_Name (E) = TSS_Stream_Read\n+                   and then not Stream_Operation_OK (Typ, TSS_Stream_Read))\n+              or else\n+                (Get_TSS_Name (E) = TSS_Stream_Write\n+                   and then not Stream_Operation_OK (Typ, TSS_Stream_Write))\n+            then\n+               return False;\n+            end if;\n+         end;\n+      end if;\n+\n+      return True;\n+   end Has_Reliable_Extra_Formals;\n+\n    --------------------\n    -- Install_Entity --\n    --------------------\n@@ -12527,7 +13153,7 @@ package body Sem_Ch6 is\n                   if Is_Dispatching_Operation (E) then\n \n                      --  An overriding dispatching subprogram inherits the\n-                     --  convention of the overridden subprogram (AI-117).\n+                     --  convention of the overridden subprogram (AI95-117).\n \n                      Set_Convention (S, Convention (E));\n                      Check_Dispatching_Operation (S, E);"}, {"sha": "5f0e1baa4f98b059b1402aff1baf4cb62b86f78f", "filename": "gcc/ada/sem_ch6.ads", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1668c3d35b1031fa3ee266b6c3292e53344d315/gcc%2Fada%2Fsem_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1668c3d35b1031fa3ee266b6c3292e53344d315/gcc%2Fada%2Fsem_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.ads?ref=f1668c3d35b1031fa3ee266b6c3292e53344d315", "patch": "@@ -174,6 +174,22 @@ package Sem_Ch6 is\n    --  the end of Subp's parameter list (with each subsequent extra formal\n    --  being attached to the preceding extra formal).\n \n+   function Extra_Formals_Match_OK\n+     (E     : Entity_Id;\n+      Ref_E : Entity_Id) return Boolean;\n+   --  Return True if the extra formals of the given entities match. E is a\n+   --  subprogram, and Ref_E is the reference entity that will be used to check\n+   --  the extra formals of E: a subprogram type or another subprogram. For\n+   --  example, if E is a dispatching primitive of a tagged type then Ref_E\n+   --  may be the overridden primitive of its parent type or its ultimate\n+   --  renamed entity; however, if E is a subprogram to which 'Access is\n+   --  applied then Ref_E is its corresponding subprogram type. Used in\n+   --  assertions.\n+\n+   function Extra_Formals_OK (E : Entity_Id) return Boolean;\n+   --  Return True if the decoration of the attributes associated with extra\n+   --  formals are properly set. Used in assertions.\n+\n    function Find_Corresponding_Spec\n      (N          : Node_Id;\n       Post_Error : Boolean := True) return Entity_Id;\n@@ -197,6 +213,9 @@ package Sem_Ch6 is\n    --  Determines if two subtype definitions are fully conformant. Used\n    --  for entry family conformance checks (RM 6.3.1 (24)).\n \n+   function Has_BIP_Formals (E : Entity_Id) return Boolean;\n+   --  Determines if a given entity has build-in-place formals\n+\n    procedure Install_Entity (E : Entity_Id);\n    --  Place a single entity on the visibility chain\n "}, {"sha": "5d9b2d0484df0aec41a9ba19c15a767ef5a22ef3", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1668c3d35b1031fa3ee266b6c3292e53344d315/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1668c3d35b1031fa3ee266b6c3292e53344d315/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=f1668c3d35b1031fa3ee266b6c3292e53344d315", "patch": "@@ -1823,6 +1823,7 @@ package body Sem_Eval is\n          return False;\n \n       elsif Op = Error\n+        or else Nkind (Op) not in N_Has_Etype\n         or else Etype (Op) = Any_Type\n         or else Raises_Constraint_Error (Op)\n       then"}, {"sha": "71548dcca17794f21dc986e0e6760633f02747da", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1668c3d35b1031fa3ee266b6c3292e53344d315/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1668c3d35b1031fa3ee266b6c3292e53344d315/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=f1668c3d35b1031fa3ee266b6c3292e53344d315", "patch": "@@ -23312,9 +23312,12 @@ package body Sem_Util is\n \n          return Present (Extra_Accessibility_Of_Result (Alias (Func_Id)));\n \n-      --  Remaining cases require Ada 2012 mode\n+      --  Remaining cases require Ada 2012 mode, unless they are dispatching\n+      --  operations, since they may be overridden by Ada_2012 primitives.\n \n-      elsif Ada_Version < Ada_2012 then\n+      elsif Ada_Version < Ada_2012\n+        and then not Is_Dispatching_Operation (Func_Id)\n+      then\n          return False;\n \n       --  Handle the situation where a result is an anonymous access type"}]}