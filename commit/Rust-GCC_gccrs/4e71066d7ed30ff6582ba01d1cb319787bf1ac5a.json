{"sha": "4e71066d7ed30ff6582ba01d1cb319787bf1ac5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU3MTA2NmQ3ZWQzMGZmNjU4MmJhMDFkMWNiMzE5Nzg3YmYxYWM1YQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-09-01T11:46:08Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-09-01T11:46:08Z"}, "message": "expr.c (expand_expr_real_2): Move COND_EXPR and VEC_COND_EXPR handling here, from ...\n\n2011-08-31  Richard Guenther  <rguenther@suse.de>\n\n\t* expr.c (expand_expr_real_2): Move COND_EXPR and VEC_COND_EXPR\n\thandling here, from ...\n\t(expand_expr_real_1): ... here.\n\t* gimple-pretty-print.c (dump_ternary_rhs): Handle COND_EXPR\n\tand VEC_COND_EXPR.\n\t* gimple.c (gimple_rhs_class_table): Make COND_EXPR and VEC_COND_EXPR\n\ta GIMPLE_TERNARY_RHS.\n\t* tree-cfg.c (verify_gimple_assign_ternary): Handle COND_EXPR\n\tand VEC_COND_EXPR here ...\n\t(verify_gimple_assign_single): ... not here.\n\t* gimple-fold.c (fold_gimple_assign): Move COND_EXPR folding.\n\t* tree-object-size.c (cond_expr_object_size): Adjust.\n\t(collect_object_sizes_for): Likewise.\n\t* tree-scalar-evolution.c (interpret_expr): Don't handle\n\tternary RHSs.\n\t* tree-ssa-forwprop.c (forward_propagate_into_cond): Fix and\n\tsimplify.\n\t(ssa_forward_propagate_and_combine): Adjust.\n\t* tree-ssa-loop-im.c (move_computations_stmt): Build the COND_EXPR\n\tas ternary.\n\t* tree-ssa-threadedge.c (fold_assignment_stmt): Adjust.\n\t* tree-vect-loop.c (vect_is_simple_reduction_1): Likewise.\n\t* tree-vect-stmt.c (vectorizable_condition): Likewise.\n\t* tree-vrp.c (extract_range_from_cond_expr): Likewise.\n\t(extract_range_from_assignment): Likewise.\n\nFrom-SVN: r178408", "tree": {"sha": "de79a98229582fd910a363d796804b194a844d10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de79a98229582fd910a363d796804b194a844d10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dbe36d674a7e0916981fbb8728d4c31d26e84462", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbe36d674a7e0916981fbb8728d4c31d26e84462", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbe36d674a7e0916981fbb8728d4c31d26e84462"}], "stats": {"total": 407, "additions": 220, "deletions": 187}, "files": [{"sha": "ffd2855a31bd5296a3f5f01fedac81831ee8126b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4e71066d7ed30ff6582ba01d1cb319787bf1ac5a", "patch": "@@ -1,3 +1,31 @@\n+2011-08-31  Richard Guenther  <rguenther@suse.de>\n+\n+\t* expr.c (expand_expr_real_2): Move COND_EXPR and VEC_COND_EXPR\n+\thandling here, from ...\n+\t(expand_expr_real_1): ... here.\n+\t* gimple-pretty-print.c (dump_ternary_rhs): Handle COND_EXPR\n+\tand VEC_COND_EXPR.\n+\t* gimple.c (gimple_rhs_class_table): Make COND_EXPR and VEC_COND_EXPR\n+\ta GIMPLE_TERNARY_RHS.\n+\t* tree-cfg.c (verify_gimple_assign_ternary): Handle COND_EXPR\n+\tand VEC_COND_EXPR here ...\n+\t(verify_gimple_assign_single): ... not here.\n+\t* gimple-fold.c (fold_gimple_assign): Move COND_EXPR folding.\n+\t* tree-object-size.c (cond_expr_object_size): Adjust.\n+\t(collect_object_sizes_for): Likewise.\n+\t* tree-scalar-evolution.c (interpret_expr): Don't handle\n+\tternary RHSs.\n+\t* tree-ssa-forwprop.c (forward_propagate_into_cond): Fix and\n+\tsimplify.\n+\t(ssa_forward_propagate_and_combine): Adjust.\n+\t* tree-ssa-loop-im.c (move_computations_stmt): Build the COND_EXPR\n+\tas ternary.\n+\t* tree-ssa-threadedge.c (fold_assignment_stmt): Adjust.\n+\t* tree-vect-loop.c (vect_is_simple_reduction_1): Likewise.\n+\t* tree-vect-stmt.c (vectorizable_condition): Likewise.\n+\t* tree-vrp.c (extract_range_from_cond_expr): Likewise.\n+\t(extract_range_from_assignment): Likewise.\n+\n 2011-08-31  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* config/i386/i386.md: Use (match_test ...) for attribute tests."}, {"sha": "6e35db2f2e015934c0e584abd81e4a7017e5c06d", "filename": "gcc/expr.c", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=4e71066d7ed30ff6582ba01d1cb319787bf1ac5a", "patch": "@@ -8636,6 +8636,64 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n         return temp;\n       }\n \n+    case COND_EXPR:\n+      /* A COND_EXPR with its type being VOID_TYPE represents a\n+\t conditional jump and is handled in\n+\t expand_gimple_cond_expr.  */\n+      gcc_assert (!VOID_TYPE_P (type));\n+\n+      /* Note that COND_EXPRs whose type is a structure or union\n+\t are required to be constructed to contain assignments of\n+\t a temporary variable, so that we can evaluate them here\n+\t for side effect only.  If type is void, we must do likewise.  */\n+\n+      gcc_assert (!TREE_ADDRESSABLE (type)\n+\t\t  && !ignore\n+\t\t  && TREE_TYPE (treeop1) != void_type_node\n+\t\t  && TREE_TYPE (treeop2) != void_type_node);\n+\n+      /* If we are not to produce a result, we have no target.  Otherwise,\n+\t if a target was specified use it; it will not be used as an\n+\t intermediate target unless it is safe.  If no target, use a\n+\t temporary.  */\n+\n+      if (modifier != EXPAND_STACK_PARM\n+\t  && original_target\n+\t  && safe_from_p (original_target, treeop0, 1)\n+\t  && GET_MODE (original_target) == mode\n+#ifdef HAVE_conditional_move\n+\t  && (! can_conditionally_move_p (mode)\n+\t      || REG_P (original_target))\n+#endif\n+\t  && !MEM_P (original_target))\n+\ttemp = original_target;\n+      else\n+\ttemp = assign_temp (type, 0, 0, 1);\n+\n+      do_pending_stack_adjust ();\n+      NO_DEFER_POP;\n+      op0 = gen_label_rtx ();\n+      op1 = gen_label_rtx ();\n+      jumpifnot (treeop0, op0, -1);\n+      store_expr (treeop1, temp,\n+\t\t  modifier == EXPAND_STACK_PARM,\n+\t\t  false);\n+\n+      emit_jump_insn (gen_jump (op1));\n+      emit_barrier ();\n+      emit_label (op0);\n+      store_expr (treeop2, temp,\n+\t\t  modifier == EXPAND_STACK_PARM,\n+\t\t  false);\n+\n+      emit_label (op1);\n+      OK_DEFER_POP;\n+      return temp;\n+\n+    case VEC_COND_EXPR:\n+      target = expand_vec_cond_expr (type, treeop0, treeop1, treeop2, target);\n+      return target;\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -9878,64 +9936,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n       return op0;\n \n-    case COND_EXPR:\n-      /* A COND_EXPR with its type being VOID_TYPE represents a\n-\t conditional jump and is handled in\n-\t expand_gimple_cond_expr.  */\n-      gcc_assert (!VOID_TYPE_P (type));\n-\n-        /* Note that COND_EXPRs whose type is a structure or union\n-  \t are required to be constructed to contain assignments of\n-  \t a temporary variable, so that we can evaluate them here\n-  \t for side effect only.  If type is void, we must do likewise.  */\n-\n-        gcc_assert (!TREE_ADDRESSABLE (type)\n-\t\t    && !ignore\n-\t\t    && TREE_TYPE (treeop1) != void_type_node\n-\t\t    && TREE_TYPE (treeop2) != void_type_node);\n-\n-       /* If we are not to produce a result, we have no target.  Otherwise,\n- \t if a target was specified use it; it will not be used as an\n- \t intermediate target unless it is safe.  If no target, use a\n- \t temporary.  */\n-\n-       if (modifier != EXPAND_STACK_PARM\n- \t  && original_target\n- \t  && safe_from_p (original_target, treeop0, 1)\n- \t  && GET_MODE (original_target) == mode\n-#ifdef HAVE_conditional_move\n- \t  && (! can_conditionally_move_p (mode)\n- \t      || REG_P (original_target))\n-#endif\n- \t  && !MEM_P (original_target))\n- \ttemp = original_target;\n-       else\n- \ttemp = assign_temp (type, 0, 0, 1);\n-\n-       do_pending_stack_adjust ();\n-       NO_DEFER_POP;\n-       op0 = gen_label_rtx ();\n-       op1 = gen_label_rtx ();\n-       jumpifnot (treeop0, op0, -1);\n-       store_expr (treeop1, temp,\n- \t\t  modifier == EXPAND_STACK_PARM,\n-\t\t  false);\n-\n-       emit_jump_insn (gen_jump (op1));\n-       emit_barrier ();\n-       emit_label (op0);\n-       store_expr (treeop2, temp,\n- \t\t  modifier == EXPAND_STACK_PARM,\n-\t\t  false);\n-\n-       emit_label (op1);\n-       OK_DEFER_POP;\n-       return temp;\n-\n-    case VEC_COND_EXPR:\n-      target = expand_vec_cond_expr (type, treeop0, treeop1, treeop2, target);\n-      return target;\n-\n     case MODIFY_EXPR:\n       {\n \ttree lhs = treeop0;"}, {"sha": "be5535bf113ead3f75c2934250777ee4f5fb1ac9", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 44, "deletions": 41, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=4e71066d7ed30ff6582ba01d1cb319787bf1ac5a", "patch": "@@ -294,42 +294,7 @@ fold_gimple_assign (gimple_stmt_iterator *si)\n       {\n         tree rhs = gimple_assign_rhs1 (stmt);\n \n-        /* Try to fold a conditional expression.  */\n-        if (TREE_CODE (rhs) == COND_EXPR)\n-          {\n-\t    tree op0 = COND_EXPR_COND (rhs);\n-\t    tree tem;\n-\t    bool set = false;\n-\t    location_t cond_loc = EXPR_LOCATION (rhs);\n-\n-\t    if (COMPARISON_CLASS_P (op0))\n-\t      {\n-\t\tfold_defer_overflow_warnings ();\n-\t\ttem = fold_binary_loc (cond_loc,\n-\t\t\t\t   TREE_CODE (op0), TREE_TYPE (op0),\n-\t\t\t\t   TREE_OPERAND (op0, 0),\n-\t\t\t\t   TREE_OPERAND (op0, 1));\n-\t\t/* This is actually a conditional expression, not a GIMPLE\n-\t\t   conditional statement, however, the valid_gimple_rhs_p\n-\t\t   test still applies.  */\n-\t\tset = (tem && is_gimple_condexpr (tem)\n-\t\t       && valid_gimple_rhs_p (tem));\n-\t\tfold_undefer_overflow_warnings (set, stmt, 0);\n-\t      }\n-\t    else if (is_gimple_min_invariant (op0))\n-\t      {\n-\t\ttem = op0;\n-\t\tset = true;\n-\t      }\n-\t    else\n-\t      return NULL_TREE;\n-\n-\t    if (set)\n-\t      result = fold_build3_loc (cond_loc, COND_EXPR, TREE_TYPE (rhs), tem,\n-\t\t\t\t    COND_EXPR_THEN (rhs), COND_EXPR_ELSE (rhs));\n-          }\n-\n-\telse if (REFERENCE_CLASS_P (rhs))\n+\tif (REFERENCE_CLASS_P (rhs))\n \t  return maybe_fold_reference (rhs, false);\n \n \telse if (TREE_CODE (rhs) == ADDR_EXPR)\n@@ -469,11 +434,49 @@ fold_gimple_assign (gimple_stmt_iterator *si)\n       break;\n \n     case GIMPLE_TERNARY_RHS:\n-      result = fold_ternary_loc (loc, subcode,\n-\t\t\t\t TREE_TYPE (gimple_assign_lhs (stmt)),\n-\t\t\t\t gimple_assign_rhs1 (stmt),\n-\t\t\t\t gimple_assign_rhs2 (stmt),\n-\t\t\t\t gimple_assign_rhs3 (stmt));\n+      /* Try to fold a conditional expression.  */\n+      if (gimple_assign_rhs_code (stmt) == COND_EXPR)\n+\t{\n+\t  tree op0 = gimple_assign_rhs1 (stmt);\n+\t  tree tem;\n+\t  bool set = false;\n+\t  location_t cond_loc = gimple_location (stmt);\n+\n+\t  if (COMPARISON_CLASS_P (op0))\n+\t    {\n+\t      fold_defer_overflow_warnings ();\n+\t      tem = fold_binary_loc (cond_loc,\n+\t\t\t\t     TREE_CODE (op0), TREE_TYPE (op0),\n+\t\t\t\t     TREE_OPERAND (op0, 0),\n+\t\t\t\t     TREE_OPERAND (op0, 1));\n+\t      /* This is actually a conditional expression, not a GIMPLE\n+\t\t conditional statement, however, the valid_gimple_rhs_p\n+\t\t test still applies.  */\n+\t      set = (tem && is_gimple_condexpr (tem)\n+\t\t     && valid_gimple_rhs_p (tem));\n+\t      fold_undefer_overflow_warnings (set, stmt, 0);\n+\t    }\n+\t  else if (is_gimple_min_invariant (op0))\n+\t    {\n+\t      tem = op0;\n+\t      set = true;\n+\t    }\n+\t  else\n+\t    return NULL_TREE;\n+\n+\t  if (set)\n+\t    result = fold_build3_loc (cond_loc, COND_EXPR,\n+\t\t\t\t      TREE_TYPE (gimple_assign_lhs (stmt)), tem,\n+\t\t\t\t      gimple_assign_rhs2 (stmt),\n+\t\t\t\t      gimple_assign_rhs3 (stmt));\n+\t}\n+\n+      if (!result)\n+\tresult = fold_ternary_loc (loc, subcode,\n+\t\t\t\t   TREE_TYPE (gimple_assign_lhs (stmt)),\n+\t\t\t\t   gimple_assign_rhs1 (stmt),\n+\t\t\t\t   gimple_assign_rhs2 (stmt),\n+\t\t\t\t   gimple_assign_rhs3 (stmt));\n \n       if (result)\n         {"}, {"sha": "1f6efc993f2d7c5f702059ea3e0c53887bf88ac7", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=4e71066d7ed30ff6582ba01d1cb319787bf1ac5a", "patch": "@@ -428,6 +428,24 @@ dump_ternary_rhs (pretty_printer *buffer, gimple gs, int spc, int flags)\n       pp_string (buffer, \">\");\n       break;\n \n+    case COND_EXPR:\n+      dump_generic_node (buffer, gimple_assign_rhs1 (gs), spc, flags, false);\n+      pp_string (buffer, \" ? \");\n+      dump_generic_node (buffer, gimple_assign_rhs2 (gs), spc, flags, false);\n+      pp_string (buffer, \" : \");\n+      dump_generic_node (buffer, gimple_assign_rhs3 (gs), spc, flags, false);\n+      break;\n+\n+    case VEC_COND_EXPR:\n+      pp_string (buffer, \"VEC_COND_EXPR <\");\n+      dump_generic_node (buffer, gimple_assign_rhs1 (gs), spc, flags, false);\n+      pp_string (buffer, \", \");\n+      dump_generic_node (buffer, gimple_assign_rhs2 (gs), spc, flags, false);\n+      pp_string (buffer, \", \");\n+      dump_generic_node (buffer, gimple_assign_rhs3 (gs), spc, flags, false);\n+      pp_string (buffer, \">\");\n+      break;\n+\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "75885bbb20e6e4ea9bf4d2c9f6d42dd3938b554d", "filename": "gcc/gimple.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=4e71066d7ed30ff6582ba01d1cb319787bf1ac5a", "patch": "@@ -2611,19 +2611,19 @@ get_gimple_rhs_num_ops (enum tree_code code)\n       || (SYM) == TRUTH_OR_EXPR\t\t\t\t\t\t    \\\n       || (SYM) == TRUTH_XOR_EXPR) ? GIMPLE_BINARY_RHS\t\t\t    \\\n    : (SYM) == TRUTH_NOT_EXPR ? GIMPLE_UNARY_RHS\t\t\t\t    \\\n-   : ((SYM) == WIDEN_MULT_PLUS_EXPR\t\t\t\t\t    \\\n+   : ((SYM) == COND_EXPR\t\t\t\t\t\t    \\\n+      || (SYM) == WIDEN_MULT_PLUS_EXPR\t\t\t\t\t    \\\n       || (SYM) == WIDEN_MULT_MINUS_EXPR\t\t\t\t\t    \\\n       || (SYM) == DOT_PROD_EXPR\t\t\t\t\t\t    \\\n       || (SYM) == REALIGN_LOAD_EXPR\t\t\t\t\t    \\\n+      || (SYM) == VEC_COND_EXPR\t\t\t\t\t\t    \\\n       || (SYM) == FMA_EXPR) ? GIMPLE_TERNARY_RHS\t\t\t    \\\n-   : ((SYM) == COND_EXPR\t\t\t\t\t\t    \\\n-      || (SYM) == CONSTRUCTOR\t\t\t\t\t\t    \\\n+   : ((SYM) == CONSTRUCTOR\t\t\t\t\t\t    \\\n       || (SYM) == OBJ_TYPE_REF\t\t\t\t\t\t    \\\n       || (SYM) == ASSERT_EXPR\t\t\t\t\t\t    \\\n       || (SYM) == ADDR_EXPR\t\t\t\t\t\t    \\\n       || (SYM) == WITH_SIZE_EXPR\t\t\t\t\t    \\\n-      || (SYM) == SSA_NAME\t\t\t\t\t\t    \\\n-      || (SYM) == VEC_COND_EXPR) ? GIMPLE_SINGLE_RHS\t\t\t    \\\n+      || (SYM) == SSA_NAME) ? GIMPLE_SINGLE_RHS\t\t\t\t    \\\n    : GIMPLE_INVALID_RHS),\n #define END_OF_BASE_TREE_CODES (unsigned char) GIMPLE_INVALID_RHS,\n "}, {"sha": "62e2da0c12f5004afe035dbee50de31b1dc2a91b", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=4e71066d7ed30ff6582ba01d1cb319787bf1ac5a", "patch": "@@ -3668,7 +3668,8 @@ verify_gimple_assign_ternary (gimple stmt)\n       return true;\n     }\n \n-  if (!is_gimple_val (rhs1)\n+  if (((rhs_code == VEC_COND_EXPR || rhs_code == COND_EXPR)\n+       ? !is_gimple_condexpr (rhs1) : !is_gimple_val (rhs1))\n       || !is_gimple_val (rhs2)\n       || !is_gimple_val (rhs3))\n     {\n@@ -3711,6 +3712,19 @@ verify_gimple_assign_ternary (gimple stmt)\n \t}\n       break;\n \n+    case COND_EXPR:\n+    case VEC_COND_EXPR:\n+      if (!useless_type_conversion_p (lhs_type, rhs2_type)\n+\t  || !useless_type_conversion_p (lhs_type, rhs3_type))\n+\t{\n+\t  error (\"type mismatch in conditional expression\");\n+\t  debug_generic_expr (lhs_type);\n+\t  debug_generic_expr (rhs2_type);\n+\t  debug_generic_expr (rhs3_type);\n+\t  return true;\n+\t}\n+      break;\n+\n     case DOT_PROD_EXPR:\n     case REALIGN_LOAD_EXPR:\n       /* FIXME.  */\n@@ -3827,26 +3841,10 @@ verify_gimple_assign_single (gimple stmt)\n \t}\n       return res;\n \n-    case COND_EXPR:\n-      if (!is_gimple_reg (lhs)\n-\t  || (!is_gimple_reg (TREE_OPERAND (rhs1, 0))\n-\t      && !COMPARISON_CLASS_P (TREE_OPERAND (rhs1, 0)))\n-\t  || (!is_gimple_reg (TREE_OPERAND (rhs1, 1))\n-\t      && !is_gimple_min_invariant (TREE_OPERAND (rhs1, 1)))\n-\t  || (!is_gimple_reg (TREE_OPERAND (rhs1, 2))\n-\t      && !is_gimple_min_invariant (TREE_OPERAND (rhs1, 2))))\n-\t{\n-\t  error (\"invalid COND_EXPR in gimple assignment\");\n-\t  debug_generic_stmt (rhs1);\n-\t  return true;\n-\t}\n-      return res;\n-\n     case CONSTRUCTOR:\n     case OBJ_TYPE_REF:\n     case ASSERT_EXPR:\n     case WITH_SIZE_EXPR:\n-    case VEC_COND_EXPR:\n       /* FIXME.  */\n       return res;\n "}, {"sha": "b1767584da8a3aefa3e6fe0ef3a2c84b4b5abeeb", "filename": "gcc/tree-object-size.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=4e71066d7ed30ff6582ba01d1cb319787bf1ac5a", "patch": "@@ -53,7 +53,7 @@ static void expr_object_size (struct object_size_info *, tree, tree);\n static bool merge_object_sizes (struct object_size_info *, tree, tree,\n \t\t\t\tunsigned HOST_WIDE_INT);\n static bool plus_stmt_object_size (struct object_size_info *, tree, gimple);\n-static bool cond_expr_object_size (struct object_size_info *, tree, tree);\n+static bool cond_expr_object_size (struct object_size_info *, tree, gimple);\n static unsigned int compute_object_sizes (void);\n static void init_offset_limit (void);\n static void check_for_plus_in_loops (struct object_size_info *, tree);\n@@ -827,25 +827,25 @@ plus_stmt_object_size (struct object_size_info *osi, tree var, gimple stmt)\n }\n \n \n-/* Compute object_sizes for VAR, defined to VALUE, which is\n+/* Compute object_sizes for VAR, defined at STMT, which is\n    a COND_EXPR.  Return true if the object size might need reexamination\n    later.  */\n \n static bool\n-cond_expr_object_size (struct object_size_info *osi, tree var, tree value)\n+cond_expr_object_size (struct object_size_info *osi, tree var, gimple stmt)\n {\n   tree then_, else_;\n   int object_size_type = osi->object_size_type;\n   unsigned int varno = SSA_NAME_VERSION (var);\n   bool reexamine = false;\n \n-  gcc_assert (TREE_CODE (value) == COND_EXPR);\n+  gcc_assert (gimple_assign_rhs_code (stmt) == COND_EXPR);\n \n   if (object_sizes[object_size_type][varno] == unknown[object_size_type])\n     return false;\n \n-  then_ = COND_EXPR_THEN (value);\n-  else_ = COND_EXPR_ELSE (value);\n+  then_ = gimple_assign_rhs2 (stmt);\n+  else_ = gimple_assign_rhs3 (stmt);\n \n   if (TREE_CODE (then_) == SSA_NAME)\n     reexamine |= merge_object_sizes (osi, var, then_, 0);\n@@ -932,14 +932,14 @@ collect_object_sizes_for (struct object_size_info *osi, tree var)\n \t    || (gimple_assign_rhs_code (stmt) == ADDR_EXPR\n \t\t&& TREE_CODE (TREE_OPERAND (rhs, 0)) == MEM_REF))\n           reexamine = plus_stmt_object_size (osi, var, stmt);\n+\telse if (gimple_assign_rhs_code (stmt) == COND_EXPR)\n+\t  reexamine = cond_expr_object_size (osi, var, stmt);\n         else if (gimple_assign_single_p (stmt)\n                  || gimple_assign_unary_nop_p (stmt))\n           {\n             if (TREE_CODE (rhs) == SSA_NAME\n                 && POINTER_TYPE_P (TREE_TYPE (rhs)))\n               reexamine = merge_object_sizes (osi, var, rhs, 0);\n-            else if (TREE_CODE (rhs) == COND_EXPR)\n-              reexamine = cond_expr_object_size (osi, var, rhs);\n             else\n               expr_object_size (osi, var, rhs);\n           }\n@@ -956,8 +956,6 @@ collect_object_sizes_for (struct object_size_info *osi, tree var)\n             if (TREE_CODE (arg) == SSA_NAME\n                 && POINTER_TYPE_P (TREE_TYPE (arg)))\n               reexamine = merge_object_sizes (osi, var, arg, 0);\n-            else if (TREE_CODE (arg) == COND_EXPR)\n-              reexamine = cond_expr_object_size (osi, var, arg);\n             else\n               expr_object_size (osi, var, arg);\n           }"}, {"sha": "6c32923852e8df84888b33eca2b4bcff27634e83", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=4e71066d7ed30ff6582ba01d1cb319787bf1ac5a", "patch": "@@ -1796,7 +1796,8 @@ interpret_expr (struct loop *loop, gimple at_stmt, tree expr)\n   if (automatically_generated_chrec_p (expr))\n     return expr;\n \n-  if (TREE_CODE (expr) == POLYNOMIAL_CHREC)\n+  if (TREE_CODE (expr) == POLYNOMIAL_CHREC\n+      || get_gimple_rhs_class (TREE_CODE (expr)) == GIMPLE_TERNARY_RHS)\n     return chrec_dont_know;\n \n   extract_ops_from_tree (expr, &code, &op0, &op1);"}, {"sha": "89d6239836bb754617dd1209960f8ed0b4a18379", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=4e71066d7ed30ff6582ba01d1cb319787bf1ac5a", "patch": "@@ -540,12 +540,9 @@ forward_propagate_into_gimple_cond (gimple stmt)\n \n /* Propagate from the ssa name definition statements of COND_EXPR\n    in the rhs of statement STMT into the conditional if that simplifies it.\n-   Returns zero if no statement was changed, one if there were\n-   changes and two if cfg_cleanup needs to run.\n-\n-   This must be kept in sync with forward_propagate_into_gimple_cond.  */\n+   Returns true zero if the stmt was changed.  */\n \n-static int\n+static bool\n forward_propagate_into_cond (gimple_stmt_iterator *gsi_p)\n {\n   gimple stmt = gsi_stmt (*gsi_p);\n@@ -560,15 +557,17 @@ forward_propagate_into_cond (gimple_stmt_iterator *gsi_p)\n \t\t\t\t\t       TREE_OPERAND (cond, 1));\n   else if (TREE_CODE (cond) == SSA_NAME)\n     {\n-      tree name = cond, rhs0;\n+      tree name = cond;\n       gimple def_stmt = get_prop_source_stmt (name, true, NULL);\n       if (!def_stmt || !can_propagate_from (def_stmt))\n \treturn 0;\n \n-      rhs0 = gimple_assign_rhs1 (def_stmt);\n-      tmp = combine_cond_expr_cond (stmt, NE_EXPR, boolean_type_node, rhs0,\n-\t\t\t\t    build_int_cst (TREE_TYPE (rhs0), 0),\n-\t\t\t\t    false);\n+      if (TREE_CODE_CLASS (gimple_assign_rhs_code (def_stmt)) == tcc_comparison)\n+\ttmp = fold_build2_loc (gimple_location (def_stmt),\n+\t\t\t       gimple_assign_rhs_code (def_stmt),\n+\t\t\t       boolean_type_node,\n+\t\t\t       gimple_assign_rhs1 (def_stmt),\n+\t\t\t       gimple_assign_rhs2 (def_stmt));\n     }\n \n   if (tmp)\n@@ -582,11 +581,16 @@ forward_propagate_into_cond (gimple_stmt_iterator *gsi_p)\n \t  fprintf (dump_file, \"'\\n\");\n \t}\n \n-      gimple_assign_set_rhs_from_tree (gsi_p, unshare_expr (tmp));\n+      if (integer_onep (tmp))\n+\tgimple_assign_set_rhs_from_tree (gsi_p, gimple_assign_rhs2 (stmt));\n+      else if (integer_zerop (tmp))\n+\tgimple_assign_set_rhs_from_tree (gsi_p, gimple_assign_rhs3 (stmt));\n+      else\n+\tgimple_assign_set_rhs1 (stmt, unshare_expr (tmp));\n       stmt = gsi_stmt (*gsi_p);\n       update_stmt (stmt);\n \n-      return is_gimple_min_invariant (tmp) ? 2 : 1;\n+      return true;\n     }\n \n   return 0;\n@@ -2436,12 +2440,8 @@ ssa_forward_propagate_and_combine (void)\n \t\telse if (code == COND_EXPR)\n \t\t  {\n \t\t    /* In this case the entire COND_EXPR is in rhs1. */\n-\t\t    int did_something;\n-\t\t    did_something = forward_propagate_into_cond (&gsi);\n+\t\t    changed |= forward_propagate_into_cond (&gsi);\n \t\t    stmt = gsi_stmt (gsi);\n-\t\t    if (did_something == 2)\n-\t\t      cfg_changed = true;\n-\t\t    changed = did_something != 0;\n \t\t  }\n \t\telse if (TREE_CODE_CLASS (code) == tcc_comparison)\n \t\t  {"}, {"sha": "cb527913d4f1b4d0df4001289ea2c114e4753552", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=4e71066d7ed30ff6582ba01d1cb319787bf1ac5a", "patch": "@@ -1251,11 +1251,9 @@ move_computations_stmt (struct dom_walk_data *dw_data,\n \t  gcc_assert (arg0 && arg1);\n \t  t = build2 (gimple_cond_code (cond), boolean_type_node,\n \t\t      gimple_cond_lhs (cond), gimple_cond_rhs (cond));\n-\t  t = build3 (COND_EXPR, TREE_TYPE (gimple_phi_result (stmt)),\n-\t\t      t, arg0, arg1);\n-\t  new_stmt = gimple_build_assign_with_ops (COND_EXPR,\n-\t\t\t\t\t\t   gimple_phi_result (stmt),\n-\t\t\t\t\t\t   t, NULL_TREE);\n+\t  new_stmt = gimple_build_assign_with_ops3 (COND_EXPR,\n+\t\t\t\t\t\t    gimple_phi_result (stmt),\n+\t\t\t\t\t\t    t, arg0, arg1);\n \t  SSA_NAME_DEF_STMT (gimple_phi_result (stmt)) = new_stmt;\n \t  *((unsigned int *)(dw_data->global_data)) |= TODO_cleanup_cfg;\n \t}"}, {"sha": "707c8df3ec59baf0a235749971f374b68788b211", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=4e71066d7ed30ff6582ba01d1cb319787bf1ac5a", "patch": "@@ -225,24 +225,7 @@ fold_assignment_stmt (gimple stmt)\n   switch (get_gimple_rhs_class (subcode))\n     {\n     case GIMPLE_SINGLE_RHS:\n-      {\n-        tree rhs = gimple_assign_rhs1 (stmt);\n-\n-        if (TREE_CODE (rhs) == COND_EXPR)\n-          {\n-            /* Sadly, we have to handle conditional assignments specially\n-               here, because fold expects all the operands of an expression\n-               to be folded before the expression itself is folded, but we\n-               can't just substitute the folded condition here.  */\n-            tree cond = fold (COND_EXPR_COND (rhs));\n-            if (cond == boolean_true_node)\n-              rhs = COND_EXPR_THEN (rhs);\n-            else if (cond == boolean_false_node)\n-              rhs = COND_EXPR_ELSE (rhs);\n-          }\n-\n-        return fold (rhs);\n-      }\n+      return fold (gimple_assign_rhs1 (stmt));\n \n     case GIMPLE_UNARY_RHS:\n       {\n@@ -265,6 +248,14 @@ fold_assignment_stmt (gimple stmt)\n         tree op0 = gimple_assign_rhs1 (stmt);\n         tree op1 = gimple_assign_rhs2 (stmt);\n         tree op2 = gimple_assign_rhs3 (stmt);\n+\n+\t/* Sadly, we have to handle conditional assignments specially\n+\t   here, because fold expects all the operands of an expression\n+\t   to be folded before the expression itself is folded, but we\n+\t   can't just substitute the folded condition here.  */\n+        if (gimple_assign_rhs_code (stmt) == COND_EXPR)\n+\t  op0 = fold (op0);\n+\n         return fold_ternary (subcode, TREE_TYPE (lhs), op0, op1, op2);\n       }\n "}, {"sha": "5c0b0a1c753f7533e73bb6a950f67294fa1d2f01", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=4e71066d7ed30ff6582ba01d1cb319787bf1ac5a", "patch": "@@ -2126,15 +2126,15 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n           return NULL;\n         }\n \n-      op3 = TREE_OPERAND (gimple_assign_rhs1 (def_stmt), 0);\n+      op3 = gimple_assign_rhs1 (def_stmt);\n       if (COMPARISON_CLASS_P (op3))\n         {\n           op4 = TREE_OPERAND (op3, 1);\n           op3 = TREE_OPERAND (op3, 0);\n         }\n \n-      op1 = TREE_OPERAND (gimple_assign_rhs1 (def_stmt), 1);\n-      op2 = TREE_OPERAND (gimple_assign_rhs1 (def_stmt), 2);\n+      op1 = gimple_assign_rhs2 (def_stmt);\n+      op2 = gimple_assign_rhs3 (def_stmt);\n \n       if (TREE_CODE (op1) != SSA_NAME && TREE_CODE (op2) != SSA_NAME)\n         {"}, {"sha": "2a1318195e5b719e314e5052fbb6087186b0652d", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=4e71066d7ed30ff6582ba01d1cb319787bf1ac5a", "patch": "@@ -4740,7 +4740,6 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n {\n   tree scalar_dest = NULL_TREE;\n   tree vec_dest = NULL_TREE;\n-  tree op = NULL_TREE;\n   tree cond_expr, then_clause, else_clause;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n@@ -4794,11 +4793,9 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n   if (code != COND_EXPR)\n     return false;\n \n-  gcc_assert (gimple_assign_single_p (stmt));\n-  op = gimple_assign_rhs1 (stmt);\n-  cond_expr = TREE_OPERAND (op, 0);\n-  then_clause = TREE_OPERAND (op, 1);\n-  else_clause = TREE_OPERAND (op, 2);\n+  cond_expr = gimple_assign_rhs1 (stmt);\n+  then_clause = gimple_assign_rhs2 (stmt);\n+  else_clause = gimple_assign_rhs3 (stmt);\n \n   if (!vect_is_simple_cond (cond_expr, loop_vinfo))\n     return false;\n@@ -4839,7 +4836,8 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n   if (!vec_stmt)\n     {\n       STMT_VINFO_TYPE (stmt_info) = condition_vec_info_type;\n-      return expand_vec_cond_expr_p (TREE_TYPE (op), vec_mode);\n+      return expand_vec_cond_expr_p (TREE_TYPE (gimple_assign_lhs (stmt)),\n+\t\t\t\t     vec_mode);\n     }\n \n   /* Transform */"}, {"sha": "56fc5a20b2b4a65f0773e566e4f2d9918587a7d7", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e71066d7ed30ff6582ba01d1cb319787bf1ac5a/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=4e71066d7ed30ff6582ba01d1cb319787bf1ac5a", "patch": "@@ -3190,27 +3190,27 @@ extract_range_from_unary_expr (value_range_t *vr, enum tree_code code,\n }\n \n \n-/* Extract range information from a conditional expression EXPR based on\n+/* Extract range information from a conditional expression STMT based on\n    the ranges of each of its operands and the expression code.  */\n \n static void\n-extract_range_from_cond_expr (value_range_t *vr, tree expr)\n+extract_range_from_cond_expr (value_range_t *vr, gimple stmt)\n {\n   tree op0, op1;\n   value_range_t vr0 = { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL };\n   value_range_t vr1 = { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL };\n \n   /* Get value ranges for each operand.  For constant operands, create\n      a new value range with the operand to simplify processing.  */\n-  op0 = COND_EXPR_THEN (expr);\n+  op0 = gimple_assign_rhs2 (stmt);\n   if (TREE_CODE (op0) == SSA_NAME)\n     vr0 = *(get_value_range (op0));\n   else if (is_gimple_min_invariant (op0))\n     set_value_range_to_value (&vr0, op0, NULL);\n   else\n     set_value_range_to_varying (&vr0);\n \n-  op1 = COND_EXPR_ELSE (expr);\n+  op1 = gimple_assign_rhs3 (stmt);\n   if (TREE_CODE (op1) == SSA_NAME)\n     vr1 = *(get_value_range (op1));\n   else if (is_gimple_min_invariant (op1))\n@@ -3302,7 +3302,7 @@ extract_range_from_assignment (value_range_t *vr, gimple stmt)\n \t\t\t\t   gimple_expr_type (stmt),\n \t\t\t\t   gimple_assign_rhs1 (stmt));\n   else if (code == COND_EXPR)\n-    extract_range_from_cond_expr (vr, gimple_assign_rhs1 (stmt));\n+    extract_range_from_cond_expr (vr, stmt);\n   else if (TREE_CODE_CLASS (code) == tcc_comparison)\n     extract_range_from_comparison (vr, gimple_assign_rhs_code (stmt),\n \t\t\t\t   gimple_expr_type (stmt),"}]}