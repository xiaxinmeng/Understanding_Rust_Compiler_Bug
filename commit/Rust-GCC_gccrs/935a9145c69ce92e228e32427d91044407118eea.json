{"sha": "935a9145c69ce92e228e32427d91044407118eea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTM1YTkxNDVjNjljZTkyZTIyOGUzMjQyN2Q5MTA0NDQwNzExOGVlYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-01T09:32:00Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-01T09:32:00Z"}, "message": "[multiple changes]\n\n2014-08-01  Vincent Celier  <celier@adacore.com>\n\n\t* gnatcmd.adb: Remove the VMS specific stuff.  Integrate in\n\tprocedure GNATCmd the relevant declarations from packages VMS_Cmds\n\tand VMS_Conv.\n\t* gnatcmd.ads: Update comments to remove any trace of VMS\n\n2014-08-01  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch12.adb: sem_ch12.adb (Build_Wrapper): Capture entity for\n\tdefaulted actual that is an operator, before building wrapper\n\tfor it in GNATprove mode. Restrict construction of wrapper to\n\tactuals that are operators.\n\n2014-08-01  Vincent Celier  <celier@adacore.com>\n\n\t* vms_conv.adb, vms_conv.ads, vms_data.ads, vms_cmds.ads: Remove VMS\n\tspecific packages no longer needed.\n\n2014-08-01  Pascal Obry  <obry@adacore.com>\n\n\t* s-os_lib.ads (System.CRTL): Move with clause to body.\n\t(File_Size): New type.\n\t(File_Length64): Use it.\n\t(File_Length): Restore previous spec returning a Long_Integer.\n\t* s-os_lib.adb (System.CRTL): Move with clause here.\n\n2014-08-01  Vincent Celier  <celier@adacore.com>\n\n\t* mlib-prj.adb: Update comments to remove any mention of VMS.\n\nFrom-SVN: r213430", "tree": {"sha": "80017fd93120d6e62909d4bd5349d7d628a53e0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/80017fd93120d6e62909d4bd5349d7d628a53e0c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/935a9145c69ce92e228e32427d91044407118eea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/935a9145c69ce92e228e32427d91044407118eea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/935a9145c69ce92e228e32427d91044407118eea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/935a9145c69ce92e228e32427d91044407118eea/comments", "author": null, "committer": null, "parents": [{"sha": "2422831252036d2821984173a7a22aac5518ef5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2422831252036d2821984173a7a22aac5518ef5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2422831252036d2821984173a7a22aac5518ef5c"}], "stats": {"total": 10716, "additions": 281, "deletions": 10435}, "files": [{"sha": "0c84b93ff1d33d3a1c40e04f2b3f25c988f537cd", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935a9145c69ce92e228e32427d91044407118eea/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935a9145c69ce92e228e32427d91044407118eea/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=935a9145c69ce92e228e32427d91044407118eea", "patch": "@@ -1,3 +1,34 @@\n+2014-08-01  Vincent Celier  <celier@adacore.com>\n+\n+\t* gnatcmd.adb: Remove the VMS specific stuff.  Integrate in\n+\tprocedure GNATCmd the relevant declarations from packages VMS_Cmds\n+\tand VMS_Conv.\n+\t* gnatcmd.ads: Update comments to remove any trace of VMS\n+\n+2014-08-01  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch12.adb: sem_ch12.adb (Build_Wrapper): Capture entity for\n+\tdefaulted actual that is an operator, before building wrapper\n+\tfor it in GNATprove mode. Restrict construction of wrapper to\n+\tactuals that are operators.\n+\n+2014-08-01  Vincent Celier  <celier@adacore.com>\n+\n+\t* vms_conv.adb, vms_conv.ads, vms_data.ads, vms_cmds.ads: Remove VMS\n+\tspecific packages no longer needed.\n+\n+2014-08-01  Pascal Obry  <obry@adacore.com>\n+\n+\t* s-os_lib.ads (System.CRTL): Move with clause to body.\n+\t(File_Size): New type.\n+\t(File_Length64): Use it.\n+\t(File_Length): Restore previous spec returning a Long_Integer.\n+\t* s-os_lib.adb (System.CRTL): Move with clause here.\n+\n+2014-08-01  Vincent Celier  <celier@adacore.com>\n+\n+\t* mlib-prj.adb: Update comments to remove any mention of VMS.\n+\n 2014-08-01  Arnaud Charlet  <charlet@adacore.com>\n \n \t* ug_words, xgnatugn.adb, gcc-interface/Make-lang.in: Remove"}, {"sha": "ecf961d6016a1b377661a2a8b971283e2abe88ea", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935a9145c69ce92e228e32427d91044407118eea/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935a9145c69ce92e228e32427d91044407118eea/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=935a9145c69ce92e228e32427d91044407118eea", "patch": "@@ -1326,6 +1326,14 @@ __gnat_file_length (int fd)\n   return __gnat_file_length_attr (fd, NULL, &attr);\n }\n \n+long\n+__gnat_file_length_long (int fd)\n+{\n+  struct file_attributes attr;\n+  __gnat_reset_attributes (&attr);\n+  return (long)__gnat_file_length_attr (fd, NULL, &attr);\n+}\n+\n __int64\n __gnat_named_file_length (char *name)\n {"}, {"sha": "532241269c14138c87dda3589beb0451b39d6e6a", "filename": "gcc/ada/adaint.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935a9145c69ce92e228e32427d91044407118eea/gcc%2Fada%2Fadaint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935a9145c69ce92e228e32427d91044407118eea/gcc%2Fada%2Fadaint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.h?ref=935a9145c69ce92e228e32427d91044407118eea", "patch": "@@ -160,6 +160,7 @@ extern int    __gnat_create_output_file            (char *);\n extern int    __gnat_create_output_file_new        (char *);\n \n extern int    __gnat_open_append                   (char *, int);\n+extern long   __gnat_file_length_long              (int);\n extern __int64 __gnat_file_length                  (int);\n extern __int64 __gnat_named_file_length            (char *);\n extern void   __gnat_tmp_name\t\t\t   (char *);"}, {"sha": "ffbeb951cae2a9e4b7908a8a9a97c1c26957373c", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 202, "deletions": 43, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935a9145c69ce92e228e32427d91044407118eea/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935a9145c69ce92e228e32427d91044407118eea/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=935a9145c69ce92e228e32427d91044407118eea", "patch": "@@ -26,6 +26,7 @@\n with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n \n with Csets;\n+with Gnatvsn;\n with Makeutl;  use Makeutl;\n with MLib.Tgt; use MLib.Tgt;\n with MLib.Utl;\n@@ -46,11 +47,9 @@ with Snames;   use Snames;\n with Stringt;\n with Switch;   use Switch;\n with Table;\n-with Targparm;\n+with Targparm; use Targparm;\n with Tempdir;\n with Types;    use Types;\n-with VMS_Conv; use VMS_Conv;\n-with VMS_Cmds; use VMS_Cmds;\n \n with Ada.Characters.Handling; use Ada.Characters.Handling;\n with Ada.Command_Line;        use Ada.Command_Line;\n@@ -59,14 +58,57 @@ with Ada.Text_IO;             use Ada.Text_IO;\n with GNAT.OS_Lib; use GNAT.OS_Lib;\n \n procedure GNATCmd is\n+   Normal_Exit : exception;\n+   --  Raise this exception for normal program termination\n+\n+   Error_Exit : exception;\n+   --  Raise this exception if error detected\n+\n+   type Command_Type is\n+     (Bind,\n+      Chop,\n+      Clean,\n+      Compile,\n+      Check,\n+      Sync,\n+      Elim,\n+      Find,\n+      Krunch,\n+      Link,\n+      List,\n+      Make,\n+      Metric,\n+      Name,\n+      Preprocess,\n+      Pretty,\n+      Stack,\n+      Stub,\n+      Test,\n+      Xref,\n+      Undefined);\n+\n+   subtype Real_Command_Type is Command_Type range Bind .. Xref;\n+   --  All real command types (excludes only Undefined).\n+\n+   type Alternate_Command is (Comp, Ls, Kr, Pp, Prep);\n+   --  Alternate command label\n+\n+   Corresponding_To : constant array (Alternate_Command) of Command_Type :=\n+     (Comp  => Compile,\n+      Ls    => List,\n+      Kr    => Krunch,\n+      Prep  => Preprocess,\n+      Pp    => Pretty);\n+   --  Mapping of alternate commands to commands\n+\n    Project_Node_Tree : Project_Node_Tree_Ref;\n    Project_File      : String_Access;\n    Project           : Prj.Project_Id;\n    Current_Verbosity : Prj.Verbosity := Prj.Default;\n    Tool_Package_Name : Name_Id       := No_Name;\n \n    B_Start : constant String := \"b~\";\n-   --  Prefix of binder generated file, changed to b__ for gprbuild\n+   --  Prefix of binder generated file\n \n    Project_Tree : constant Project_Tree_Ref :=\n                     new Project_Tree_Data (Is_Root_Tree => True);\n@@ -119,6 +161,14 @@ procedure GNATCmd is\n      Table_Increment      => 100,\n      Table_Name           => \"Make.Library_Path\");\n \n+   package Last_Switches is new Table.Table\n+     (Table_Component_Type => String_Access,\n+      Table_Index_Type     => Integer,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => 20,\n+      Table_Increment      => 100,\n+      Table_Name           => \"Gnatcmd.Last_Switches\");\n+\n    --  Packages of project files to pass to Prj.Pars.Parse, depending on the\n    --  tool. We allocate objects because we cannot declare aliased objects\n    --  as we are in a procedure, not a library level package.\n@@ -201,6 +251,121 @@ procedure GNATCmd is\n    --  indicate that the underlying tool (gnatcheck, gnatpp or gnatmetric)\n    --  should be invoked for all sources of all projects.\n \n+   type Command_Entry is record\n+      Cname : String_Access;\n+      --  Command name for GNAT xxx command\n+\n+      Unixcmd : String_Access;\n+      --  Corresponding Unix command\n+\n+      Unixsws : Argument_List_Access;\n+      --  List of switches to be used with the Unix command\n+   end record;\n+\n+   Command_List : constant array (Real_Command_Type) of Command_Entry :=\n+     (Bind =>\n+        (Cname    => new String'(\"BIND\"),\n+         Unixcmd  => new String'(\"gnatbind\"),\n+         Unixsws  => null),\n+\n+      Chop =>\n+        (Cname    => new String'(\"CHOP\"),\n+         Unixcmd  => new String'(\"gnatchop\"),\n+         Unixsws  => null),\n+\n+      Clean =>\n+        (Cname    => new String'(\"CLEAN\"),\n+         Unixcmd  => new String'(\"gnatclean\"),\n+         Unixsws  => null),\n+\n+      Compile =>\n+        (Cname    => new String'(\"COMPILE\"),\n+         Unixcmd  => new String'(\"gnatmake\"),\n+         Unixsws  => new Argument_List'(1 => new String'(\"-f\"),\n+                                        2 => new String'(\"-u\"),\n+                                        3 => new String'(\"-c\"))),\n+\n+      Check =>\n+        (Cname    => new String'(\"CHECK\"),\n+         Unixcmd  => new String'(\"gnatcheck\"),\n+         Unixsws  => null),\n+\n+      Sync =>\n+        (Cname    => new String'(\"SYNC\"),\n+         Unixcmd  => new String'(\"gnatsync\"),\n+         Unixsws  => null),\n+\n+      Elim =>\n+        (Cname    => new String'(\"ELIM\"),\n+         Unixcmd  => new String'(\"gnatelim\"),\n+         Unixsws  => null),\n+\n+      Find =>\n+        (Cname    => new String'(\"FIND\"),\n+         Unixcmd  => new String'(\"gnatfind\"),\n+         Unixsws  => null),\n+\n+      Krunch =>\n+        (Cname    => new String'(\"KRUNCH\"),\n+         Unixcmd  => new String'(\"gnatkr\"),\n+         Unixsws  => null),\n+\n+      Link =>\n+        (Cname    => new String'(\"LINK\"),\n+         Unixcmd  => new String'(\"gnatlink\"),\n+         Unixsws  => null),\n+\n+      List =>\n+        (Cname    => new String'(\"LIST\"),\n+         Unixcmd  => new String'(\"gnatls\"),\n+         Unixsws  => null),\n+\n+      Make =>\n+        (Cname    => new String'(\"MAKE\"),\n+         Unixcmd  => new String'(\"gnatmake\"),\n+         Unixsws  => null),\n+\n+      Metric =>\n+        (Cname    => new String'(\"METRIC\"),\n+         Unixcmd  => new String'(\"gnatmetric\"),\n+         Unixsws  => null),\n+\n+      Name =>\n+        (Cname    => new String'(\"NAME\"),\n+         Unixcmd  => new String'(\"gnatname\"),\n+         Unixsws  => null),\n+\n+      Preprocess =>\n+        (Cname    => new String'(\"PREPROCESS\"),\n+         Unixcmd  => new String'(\"gnatprep\"),\n+         Unixsws  => null),\n+\n+      Pretty =>\n+        (Cname    => new String'(\"PRETTY\"),\n+         Unixcmd  => new String'(\"gnatpp\"),\n+         Unixsws  => null),\n+\n+      Stack =>\n+        (Cname    => new String'(\"STACK\"),\n+         Unixcmd  => new String'(\"gnatstack\"),\n+         Unixsws  => null),\n+\n+      Stub =>\n+        (Cname    => new String'(\"STUB\"),\n+         Unixcmd  => new String'(\"gnatstub\"),\n+         Unixsws  => null),\n+\n+      Test =>\n+        (Cname    => new String'(\"TEST\"),\n+         Unixcmd  => new String'(\"gnattest\"),\n+         Unixsws  => null),\n+\n+      Xref =>\n+        (Cname    => new String'(\"XREF\"),\n+         Unixcmd  => new String'(\"gnatxref\"),\n+         Unixsws  => null)\n+     );\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -258,8 +423,11 @@ procedure GNATCmd is\n    --  (GNAT STUB), gnatpp (GNAT PRETTY), gnatelim (GNAT ELIM), and gnatmetric\n    --  (GNAT METRIC).\n \n-   procedure Non_VMS_Usage;\n-   --  Display usage for platforms other than VMS\n+   procedure Output_Version;\n+   --  Output the version of this program\n+\n+   procedure Usage;\n+   --  Display usage\n \n    procedure Process_Link;\n    --  Process GNAT LINK, when there is a project file specified\n@@ -854,8 +1022,7 @@ procedure GNATCmd is\n \n       Prj.Env.Create_Temp_File (Project_Tree.Shared, FD, Name, \"files\");\n \n-      --  And close it, because on VMS Spawn with a file descriptor created\n-      --  with Create_Temp_File does not redirect output.\n+      --  And close it\n \n       Close (FD);\n \n@@ -982,11 +1149,29 @@ procedure GNATCmd is\n       return Result;\n    end Mapping_File;\n \n-   -------------------\n-   -- Non_VMS_Usage --\n-   -------------------\n+   --------------------\n+   -- Output_Version --\n+   --------------------\n \n-   procedure Non_VMS_Usage is\n+   procedure Output_Version is\n+   begin\n+      if AAMP_On_Target then\n+         Put (\"GNAAMP \");\n+      else\n+         Put (\"GNAT \");\n+      end if;\n+\n+      Put_Line (Gnatvsn.Gnat_Version_String);\n+      Put_Line (\"Copyright 1996-\" &\n+                Gnatvsn.Current_Year &\n+                \", Free Software Foundation, Inc.\");\n+   end Output_Version;\n+\n+   -----------\n+   -- Usage --\n+   -----------\n+\n+   procedure Usage is\n    begin\n       Output_Version;\n       New_Line;\n@@ -997,7 +1182,7 @@ procedure GNATCmd is\n \n          --  No usage for VMS only command or for Sync\n \n-         if not Command_List (C).VMS_Only and then C /= Sync then\n+         if C /= Sync then\n             if Targparm.AAMP_On_Target then\n                Put (\"gnaampcmd \");\n             else\n@@ -1034,7 +1219,7 @@ procedure GNATCmd is\n       Put_Line (\"All commands except chop, krunch and preprocess \" &\n                 \"accept project file switches -vPx, -Pprj and -Xnam=val\");\n       New_Line;\n-   end Non_VMS_Usage;\n+   end Usage;\n \n    ------------------\n    -- Process_Link --\n@@ -1367,7 +1552,7 @@ procedure GNATCmd is\n    end Set_Library_For;\n \n    procedure Check_Version_And_Help is\n-     new Check_Version_And_Help_G (Non_VMS_Usage);\n+     new Check_Version_And_Help_G (Usage);\n \n --  Start of processing for GNATCmd\n \n@@ -1399,8 +1584,6 @@ begin\n    Rules_Switches.Init;\n    Rules_Switches.Set_Last (0);\n \n-   VMS_Conv.Initialize;\n-\n    --  Add the default search directories, to be able to find system.ads in the\n    --  subsequent call to Targparm.Get_Target_Parameters.\n \n@@ -1478,20 +1661,12 @@ begin\n       --  If there is no command, just output the usage\n \n       if Command_Arg > Argument_Count then\n-         Non_VMS_Usage;\n+         Usage;\n          return;\n       end if;\n \n       The_Command := Real_Command_Type'Value (Argument (Command_Arg));\n \n-      if Command_List (The_Command).VMS_Only then\n-         Non_VMS_Usage;\n-         Fail\n-           (\"command \"\"\"\n-            & Command_List (The_Command).Cname.all\n-            & \"\"\" can only be used on VMS\");\n-      end if;\n-\n    exception\n       when Constraint_Error =>\n \n@@ -1507,7 +1682,7 @@ begin\n \n          exception\n             when Constraint_Error =>\n-               Non_VMS_Usage;\n+               Usage;\n                Fail (\"unknown command: \" & Argument (Command_Arg));\n          end;\n    end;\n@@ -2633,22 +2808,6 @@ begin\n             The_Args (Arg_Num) := Rules_Switches.Table (J);\n          end loop;\n \n-         --  If Display_Command is on, only display the generated command\n-\n-         if Display_Command then\n-            Put (Standard_Error, \"generated command -->\");\n-            Put (Standard_Error, Exec_Path.all);\n-\n-            for Arg in The_Args'Range loop\n-               Put (Standard_Error, \" \");\n-               Put (Standard_Error, The_Args (Arg).all);\n-            end loop;\n-\n-            Put (Standard_Error, \"<--\");\n-            New_Line (Standard_Error);\n-            raise Normal_Exit;\n-         end if;\n-\n          if Verbose_Mode then\n             Output.Write_Str (Exec_Path.all);\n "}, {"sha": "13a709947a5671a47a437cc1ede2a19e04feb138", "filename": "gcc/ada/gnatcmd.ads", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935a9145c69ce92e228e32427d91044407118eea/gcc%2Fada%2Fgnatcmd.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935a9145c69ce92e228e32427d91044407118eea/gcc%2Fada%2Fgnatcmd.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.ads?ref=935a9145c69ce92e228e32427d91044407118eea", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1996-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1996-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -24,35 +24,19 @@\n ------------------------------------------------------------------------------\n \n --  This program provides a simple command interface for using GNAT and its\n---  associated utilities. The format of switches accepted is intended to\n---  be more familiar in style for VMS and DOS users than the standard Unix\n---  style switches that are accepted directly.\n+--  associated utilities.\n \n --    The program is typically called GNAT when it is installed and\n --    the two possible styles of use are:\n \n --  To call gcc:\n \n---    GNAT filename switches\n+--    GNAT compile filename switches\n \n --  To call the tool gnatxxx\n \n --    GNAT xxx filename switches\n \n---  where xxx is the command name (e.g. MAKE for gnatmake). This command name\n---  can be abbreviated by giving a prefix (e.g. GNAT MAK) as long as it\n---  remains unique.\n-\n---  In both cases, filename is in the format appropriate to the operating\n---  system in use. The individual commands give more details. In some cases\n---  a unit name may be given in place of a file name.\n-\n---  The switches start with a slash. Switch names can also be abbreviated\n---  where no ambiguity arises. The switches associated with each command\n---  are specified by the tables that can be found in the body.\n-\n---  Although by convention we use upper case for command names and switches\n---  in the documentation, all command and switch names are case insensitive\n---  and may be given in upper case or lower case or a mixture.\n+--  where xxx is the command name (e.g. MAKE for gnatmake).\n \n procedure GNATCmd;"}, {"sha": "943361fbc45993b3250ee719f333074f68f2a737", "filename": "gcc/ada/mlib-prj.adb", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935a9145c69ce92e228e32427d91044407118eea/gcc%2Fada%2Fmlib-prj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935a9145c69ce92e228e32427d91044407118eea/gcc%2Fada%2Fmlib-prj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-prj.adb?ref=935a9145c69ce92e228e32427d91044407118eea", "patch": "@@ -837,7 +837,7 @@ package body MLib.Prj is\n                Arguments := new String_List (1 .. Initial_Argument_Max);\n             end if;\n \n-            --  Add \"-n -o b~<lib>.adb (b__<lib>.adb on VMS) -L<lib>_\"\n+            --  Add \"-n -o b~<lib>.adb -L<lib>_\"\n \n             Argument_Number := 2;\n             Arguments (1) := No_Main;\n@@ -1726,10 +1726,8 @@ package body MLib.Prj is\n          Argument_Number := 0;\n \n          --  If we have a standalone library, gather all the interface ALI.\n-         --  They are passed to Build_Dynamic_Library, where they are used by\n-         --  some platforms (VMS, for example) to decide what symbols should be\n-         --  exported. They are also flagged as Interface when we copy them to\n-         --  the library directory (by Copy_ALI_Files, below).\n+         --  They are flagged as Interface when we copy them to the library\n+         --  directory (by Copy_ALI_Files, below).\n \n          if Standalone then\n             Current_Proj := For_Project;\n@@ -2400,9 +2398,8 @@ package body MLib.Prj is\n \n             --  Also ignore the shared libraries which are :\n \n-            --  UNIX / Windows    VMS\n-            --  -lgnat-<version>  -lgnat_<version>  (7 + version'length chars)\n-            --  -lgnarl-<version> -lgnarl_<version> (8 + version'length chars)\n+            --  -lgnat-<version>  (7 + version'length chars)\n+            --  -lgnarl-<version> (8 + version'length chars)\n \n             if Next_Line (1 .. Nlast) /= \"-static\" and then\n                Next_Line (1 .. Nlast) /= \"-shared\" and then"}, {"sha": "940bf514c327db39d7e115a14a2be5dcfb987073", "filename": "gcc/ada/s-os_lib.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935a9145c69ce92e228e32427d91044407118eea/gcc%2Fada%2Fs-os_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935a9145c69ce92e228e32427d91044407118eea/gcc%2Fada%2Fs-os_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-os_lib.adb?ref=935a9145c69ce92e228e32427d91044407118eea", "patch": "@@ -35,6 +35,7 @@ with Ada.Unchecked_Conversion;\n with Ada.Unchecked_Deallocation;\n with System; use System;\n with System.Case_Util;\n+with System.CRTL;\n with System.Soft_Links;\n \n package body System.OS_Lib is"}, {"sha": "b8dde283f759886c9535db2810276255359a01f8", "filename": "gcc/ada/s-os_lib.ads", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935a9145c69ce92e228e32427d91044407118eea/gcc%2Fada%2Fs-os_lib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935a9145c69ce92e228e32427d91044407118eea/gcc%2Fada%2Fs-os_lib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-os_lib.ads?ref=935a9145c69ce92e228e32427d91044407118eea", "patch": "@@ -56,8 +56,6 @@ pragma Compiler_Unit_Warning;\n with System;\n with System.Strings;\n \n-with System.CRTL;\n-\n package System.OS_Lib is\n    pragma Preelaborate;\n \n@@ -434,8 +432,13 @@ package System.OS_Lib is\n    --  to the current position (origin = SEEK_CUR), end of file (origin =\n    --  SEEK_END), or start of file (origin = SEEK_SET).\n \n-   function File_Length (FD : File_Descriptor) return CRTL.int64;\n-   pragma Import (C, File_Length, \"__gnat_file_length\");\n+   type File_Size is range -(2 ** 63) .. (2 ** 63) - 1;\n+\n+   function File_Length (FD : File_Descriptor) return Long_Integer;\n+   pragma Import (C, File_Length, \"__gnat_file_length_long\");\n+\n+   function File_Length64 (FD : File_Descriptor) return File_Size;\n+   pragma Import (C, File_Length64, \"__gnat_file_length\");\n    --  Get length of file from file descriptor FD\n \n    function File_Time_Stamp (Name : String) return OS_Time;"}, {"sha": "d1f712ad1ab46fab2c360ff1a081f90d311f1fe8", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/935a9145c69ce92e228e32427d91044407118eea/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/935a9145c69ce92e228e32427d91044407118eea/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=935a9145c69ce92e228e32427d91044407118eea", "patch": "@@ -1137,6 +1137,15 @@ package body Sem_Ch12 is\n             end if;\n          end if;\n \n+         --  Propagate visible entity to operator node, either from a\n+         --  given actual or from a default.\n+\n+         if Is_Entity_Name (Actual)\n+           and then Nkind (Expr) in N_Op\n+         then\n+            Set_Entity (Expr, Entity (Actual));\n+         end if;\n+\n          Decl :=\n            Make_Expression_Function (Loc,\n              Specification => Spec,\n@@ -1669,7 +1678,19 @@ package body Sem_Ch12 is\n                         --  If actual is an entity (function or operator),\n                         --  build wrapper for it.\n \n-                        if Present (Match) and then Is_Entity_Name (Match) then\n+                        if Present (Match)\n+                          and then Nkind (Match) = N_Operator_Symbol\n+                        then\n+\n+                           --  If the name is a default, find its visible\n+                           --  entity at the point of instantiation.\n+\n+                           if Is_Entity_Name (Match)\n+                             and then No (Entity (Match))\n+                           then\n+                              Find_Direct_Name (Match);\n+                           end if;\n+\n                            Append_To (Assoc,\n                              Build_Wrapper\n                                (Defining_Entity (Analyzed_Formal), Match));\n@@ -1679,7 +1700,6 @@ package body Sem_Ch12 is\n                         elsif Box_Present (Formal)\n                            and then Nkind (Defining_Entity (Analyzed_Formal))\n                              = N_Defining_Operator_Symbol\n-\n                         then\n                            Append_To (Assoc,\n                              Build_Wrapper"}, {"sha": "f8258af8e3dc1af33bd43705cb605f0d3534b1a2", "filename": "gcc/ada/vms_cmds.ads", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2422831252036d2821984173a7a22aac5518ef5c/gcc%2Fada%2Fvms_cmds.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2422831252036d2821984173a7a22aac5518ef5c/gcc%2Fada%2Fvms_cmds.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_cmds.ads?ref=2422831252036d2821984173a7a22aac5518ef5c", "patch": "@@ -1,56 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                            V M S _ C M D S                               --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 2010-2013, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package is part of the GNAT driver. It contains the declaration of\n---  Command_Type which list all the commands supported by the gnat driver.\n-\n-package VMS_Cmds is\n-   type Command_Type is\n-     (Bind,\n-      Chop,\n-      Clean,\n-      Compile,\n-      Check,\n-      Sync,\n-      Elim,\n-      Find,\n-      Krunch,\n-      Link,\n-      List,\n-      Make,\n-      Metric,\n-      Name,\n-      Preprocess,\n-      Pretty,\n-      Shared,\n-      Stack,\n-      Stub,\n-      Test,\n-      Xref,\n-      Undefined);\n-\n-   subtype Real_Command_Type is Command_Type range Bind .. Xref;\n-   --  All real command types (excludes only Undefined).\n-end VMS_Cmds;"}, {"sha": "fbb19e58b01a1e09c16adb7a1d5c5541be68be29", "filename": "gcc/ada/vms_conv.adb", "status": "removed", "additions": 0, "deletions": 2349, "changes": 2349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2422831252036d2821984173a7a22aac5518ef5c/gcc%2Fada%2Fvms_conv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2422831252036d2821984173a7a22aac5518ef5c/gcc%2Fada%2Fvms_conv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_conv.adb?ref=2422831252036d2821984173a7a22aac5518ef5c", "patch": "@@ -1,2349 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                            V M S _ C O N V                               --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1996-2013, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with Gnatvsn;  use Gnatvsn;\n-with Hostparm;\n-with Opt;\n-with Osint;    use Osint;\n-with Targparm; use Targparm;\n-\n-with Ada.Characters.Handling; use Ada.Characters.Handling;\n-with Ada.Command_Line;        use Ada.Command_Line;\n-with Ada.Text_IO;             use Ada.Text_IO;\n-\n-package body VMS_Conv is\n-\n-   -------------------------\n-   -- Internal Structures --\n-   -------------------------\n-\n-   --  The switches and commands are defined by strings in the previous\n-   --  section so that they are easy to modify, but internally, they are\n-   --  kept in a more conveniently accessible form described in this\n-   --  section.\n-\n-   --  Commands, command qualifiers and options have a similar common format\n-   --  so that searching for matching names can be done in a common manner.\n-\n-   type Item_Id is (Id_Command, Id_Switch, Id_Option);\n-\n-   type Translation_Type is\n-     (\n-      T_Direct,\n-      --  A qualifier with no options.\n-      --  Example: GNAT MAKE /VERBOSE\n-\n-      T_Directories,\n-      --  A qualifier followed by a list of directories\n-      --  Example: GNAT COMPILE /SEARCH=([], [.FOO], [.BAR])\n-\n-      T_Directory,\n-      --  A qualifier followed by one directory\n-      --  Example: GNAT LIBRARY /SET=[.VAXFLOATLIB]\n-\n-      T_File,\n-      --  A qualifier followed by a filename\n-      --  Example: GNAT LINK /EXECUTABLE=FOO.EXE\n-\n-      T_No_Space_File,\n-      --  A qualifier followed by a filename\n-      --  Example: GNAT MAKE /PROJECT_FILE=PRJ.GPR\n-\n-      T_Numeric,\n-      --  A qualifier followed by a numeric value.\n-      --  Example: GNAT CHOP /FILE_NAME_MAX_LENGTH=39\n-\n-      T_String,\n-      --  A qualifier followed by a quoted string. Only used by\n-      --  /IDENTIFICATION qualifier.\n-      --  Example: GNAT LINK /IDENTIFICATION=\"3.14a1 version\"\n-\n-      T_Options,\n-      --  A qualifier followed by a list of options.\n-      --  Example: GNAT COMPILE /REPRESENTATION_INFO=(ARRAYS,OBJECTS)\n-\n-      T_Commands,\n-      --  A qualifier followed by a list. Only used for\n-      --  MAKE /COMPILER_QUALIFIERS /BINDER_QUALIFIERS /LINKER_QUALIFIERS\n-      --  (gnatmake -cargs -bargs -largs )\n-      --  Example: GNAT MAKE ... /LINKER_QUALIFIERS /VERBOSE FOOBAR.OBJ\n-\n-      T_Other,\n-      --  A qualifier passed directly to the linker. Only used\n-      --  for LINK and SHARED if no other match is found.\n-      --  Example: GNAT LINK FOO.ALI /SYSSHR\n-\n-      T_Alphanumplus\n-      --  A qualifier followed by a legal linker symbol prefix. Only used\n-      --  for BIND /BUILD_LIBRARY (gnatbind -Lxyz).\n-      --  Example: GNAT BIND /BUILD_LIBRARY=foobar\n-      );\n-\n-   type Item (Id : Item_Id);\n-   type Item_Ptr is access all Item;\n-\n-   type Item (Id : Item_Id) is record\n-      Name : String_Ptr;\n-      --  Name of the command, switch (with slash) or option\n-\n-      Next : Item_Ptr;\n-      --  Pointer to next item on list, always has the same Id value\n-\n-      Command : Command_Type := Undefined;\n-\n-      Unix_String : String_Ptr := null;\n-      --  Corresponding Unix string. For a command, this is the unix command\n-      --  name and possible default switches. For a switch or option it is\n-      --  the unix switch string.\n-\n-      case Id is\n-\n-         when Id_Command =>\n-\n-            Switches : Item_Ptr;\n-            --  Pointer to list of switch items for the command, linked\n-            --  through the Next fields with null terminating the list.\n-\n-            Usage : String_Ptr;\n-            --  Usage information, used only for errors and the default\n-            --  list of commands output.\n-\n-            Params : Parameter_Ref;\n-            --  Array of parameters\n-\n-            Defext : String (1 .. 3);\n-            --  Default extension. If non-blank, then this extension is\n-            --  supplied by default as the extension for any file parameter\n-            --  which does not have an extension already.\n-\n-         when Id_Switch =>\n-\n-            Translation : Translation_Type;\n-            --  Type of switch translation. For all cases, except Options,\n-            --  this is the only field needed, since the Unix translation\n-            --  is found in Unix_String.\n-\n-            Options : Item_Ptr;\n-            --  For the Options case, this field is set to point to a list\n-            --  of options item (for this case Unix_String is null in the\n-            --  main switch item). The end of the list is marked by null.\n-\n-         when Id_Option =>\n-\n-            null;\n-            --  No special fields needed, since Name and Unix_String are\n-            --  sufficient to completely described an option.\n-\n-      end case;\n-   end record;\n-\n-   subtype Command_Item is Item (Id_Command);\n-   subtype Switch_Item  is Item (Id_Switch);\n-   subtype Option_Item  is Item (Id_Option);\n-\n-   Keep_Temps_Option : constant Item_Ptr :=\n-                         new Item'\n-                           (Id          => Id_Option,\n-                            Name        =>\n-                              new String'(\"/KEEP_TEMPORARY_FILES\"),\n-                            Next        => null,\n-                            Command     => Undefined,\n-                            Unix_String => null);\n-\n-   Param_Count : Natural := 0;\n-   --  Number of parameter arguments so far\n-\n-   Arg_Num : Natural;\n-   --  Argument number\n-\n-   Arg_File : Ada.Text_IO.File_Type;\n-   --  A file where arguments are read from\n-\n-   Commands : Item_Ptr;\n-   --  Pointer to head of list of command items, one for each command, with\n-   --  the end of the list marked by a null pointer.\n-\n-   Last_Command : Item_Ptr;\n-   --  Pointer to last item in Commands list\n-\n-   Command : Item_Ptr;\n-   --  Pointer to command item for current command\n-\n-   Make_Commands_Active : Item_Ptr := null;\n-   --  Set to point to Command entry for COMPILE, BIND, or LINK as appropriate\n-   --  if a COMMANDS_TRANSLATION switch has been encountered while processing\n-   --  a MAKE Command.\n-\n-   Output_File_Expected : Boolean := False;\n-   --  True for GNAT LINK after -o switch, so that the \".ali\" extension is\n-   --  not added to the executable file name.\n-\n-   package Buffer is new Table.Table\n-     (Table_Component_Type => Character,\n-      Table_Index_Type     => Integer,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 4096,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Buffer\");\n-   --  Table to store the command to be used\n-\n-   package Cargs_Buffer is new Table.Table\n-     (Table_Component_Type => Character,\n-      Table_Index_Type     => Integer,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 4096,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Cargs_Buffer\");\n-   --  Table to store the compiler switches for GNAT COMPILE\n-\n-   Cargs : Boolean := False;\n-   --  When True, commands should go to Cargs_Buffer instead of Buffer table\n-\n-   function Init_Object_Dirs return Argument_List;\n-   --  Get the list of the object directories\n-\n-   function Invert_Sense (S : String) return VMS_Data.String_Ptr;\n-   --  Given a unix switch string S, computes the inverse (adding or\n-   --  removing ! characters as required), and returns a pointer to\n-   --  the allocated result on the heap.\n-\n-   function Is_Extensionless (F : String) return Boolean;\n-   --  Returns true if the filename has no extension\n-\n-   function Match (S1, S2 : String) return Boolean;\n-   --  Determines whether S1 and S2 match (this is a case insensitive match)\n-\n-   function Match_Prefix (S1, S2 : String) return Boolean;\n-   --  Determines whether S1 matches a prefix of S2. This is also a case\n-   --  insensitive match (for example Match (\"AB\",\"abc\") is True).\n-\n-   function Matching_Name\n-     (S     : String;\n-      Itm   : Item_Ptr;\n-      Quiet : Boolean := False) return Item_Ptr;\n-   --  Determines if the item list headed by Itm and threaded through the\n-   --  Next fields (with null marking the end of the list), contains an\n-   --  entry that uniquely matches the given string. The match is case\n-   --  insensitive and permits unique abbreviation. If the match succeeds,\n-   --  then a pointer to the matching item is returned. Otherwise, an\n-   --  appropriate error message is written. Note that the discriminant\n-   --  of Itm is used to determine the appropriate form of this message.\n-   --  Quiet is normally False as shown, if it is set to True, then no\n-   --  error message is generated in a not found situation (null is still\n-   --  returned to indicate the not-found situation).\n-\n-   function OK_Alphanumerplus (S : String) return Boolean;\n-   --  Checks that S is a string of alphanumeric characters,\n-   --  returning True if all alphanumeric characters,\n-   --  False if empty or a non-alphanumeric character is present.\n-\n-   function OK_Integer (S : String) return Boolean;\n-   --  Checks that S is a string of digits, returning True if all digits,\n-   --  False if empty or a non-digit is present.\n-\n-   procedure Place (C : Character);\n-   --  Place a single character in the buffer, updating Ptr\n-\n-   procedure Place (S : String);\n-   --  Place a string character in the buffer, updating Ptr\n-\n-   procedure Place_Lower (S : String);\n-   --  Place string in buffer, forcing letters to lower case, updating Ptr\n-\n-   procedure Place_Unix_Switches (S : VMS_Data.String_Ptr);\n-   --  Given a unix switch string, place corresponding switches in Buffer,\n-   --  updating Ptr appropriately. Note that in the case of use of ! the\n-   --  result may be to remove a previously placed switch.\n-\n-   procedure Preprocess_Command_Data;\n-   --  Preprocess the string form of the command and options list into the\n-   --  internal form.\n-\n-   procedure Process_Argument (The_Command : in out Command_Type);\n-   --  Process one argument from the command line, or one line from\n-   --  from a command line file. For the first call, set The_Command.\n-\n-   procedure Process_Buffer (S : String);\n-   --  Process the characters in the Buffer table or the Cargs_Buffer table\n-   --  to convert these into arguments.\n-\n-   procedure Validate_Command_Or_Option (N : VMS_Data.String_Ptr);\n-   --  Check that N is a valid command or option name, i.e. that it is of the\n-   --  form of an Ada identifier with upper case letters and underscores.\n-\n-   procedure Validate_Unix_Switch (S : VMS_Data.String_Ptr);\n-   --  Check that S is a valid switch string as described in the syntax for\n-   --  the switch table item UNIX_SWITCH or else begins with a backquote.\n-\n-   ----------------------\n-   -- Init_Object_Dirs --\n-   ----------------------\n-\n-   function Init_Object_Dirs return Argument_List is\n-      Object_Dirs     : Integer;\n-      Object_Dir      : Argument_List (1 .. 256);\n-      Object_Dir_Name : String_Access;\n-\n-   begin\n-      Object_Dirs := 0;\n-      Object_Dir_Name := new String'(Object_Dir_Default_Prefix);\n-      Get_Next_Dir_In_Path_Init (Object_Dir_Name);\n-\n-      loop\n-         declare\n-            Dir : constant String_Access :=\n-                    Get_Next_Dir_In_Path (Object_Dir_Name);\n-         begin\n-            exit when Dir = null;\n-            Object_Dirs := Object_Dirs + 1;\n-            Object_Dir (Object_Dirs) :=\n-              new String'(\"-L\" &\n-                          To_Canonical_Dir_Spec\n-                            (To_Host_Dir_Spec\n-                              (Normalize_Directory_Name (Dir.all).all,\n-                               True).all, True).all);\n-         end;\n-      end loop;\n-\n-      Object_Dirs := Object_Dirs + 1;\n-      Object_Dir (Object_Dirs) := new String'(\"-lgnat\");\n-\n-      if OpenVMS_On_Target then\n-         Object_Dirs := Object_Dirs + 1;\n-         Object_Dir (Object_Dirs) := new String'(\"-ldecgnat\");\n-      end if;\n-\n-      return Object_Dir (1 .. Object_Dirs);\n-   end Init_Object_Dirs;\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   procedure Initialize is\n-   begin\n-      Command_List :=\n-        (Bind =>\n-           (Cname    => new S'(\"BIND\"),\n-            Usage    => new S'(\"GNAT BIND file[.ali] /qualifiers\"),\n-            VMS_Only => False,\n-            Unixcmd  => new S'(\"gnatbind\"),\n-            Unixsws  => null,\n-            Switches => Bind_Switches'Access,\n-            Params   => new Parameter_Array'(1 => Unlimited_Files),\n-            Defext   => \"ali\"),\n-\n-         Chop =>\n-           (Cname    => new S'(\"CHOP\"),\n-            Usage    => new S'(\"GNAT CHOP file [directory] /qualifiers\"),\n-            VMS_Only => False,\n-            Unixcmd  => new S'(\"gnatchop\"),\n-            Unixsws  => null,\n-            Switches => Chop_Switches'Access,\n-            Params   => new Parameter_Array'(1 => File, 2 => Optional_File),\n-            Defext   => \"   \"),\n-\n-         Clean =>\n-           (Cname    => new S'(\"CLEAN\"),\n-            Usage    => new S'(\"GNAT CLEAN /qualifiers files\"),\n-            VMS_Only => False,\n-            Unixcmd  => new S'(\"gnatclean\"),\n-            Unixsws  => null,\n-            Switches => Clean_Switches'Access,\n-            Params   => new Parameter_Array'(1 => File),\n-            Defext   => \"   \"),\n-\n-         Compile =>\n-           (Cname    => new S'(\"COMPILE\"),\n-            Usage    => new S'(\"GNAT COMPILE filespec[,...] /qualifiers\"),\n-            VMS_Only => False,\n-            Unixcmd  => new S'(\"gnatmake\"),\n-            Unixsws  => new Argument_List'(1 => new String'(\"-f\"),\n-                                           2 => new String'(\"-u\"),\n-                                           3 => new String'(\"-c\")),\n-            Switches => GCC_Switches'Access,\n-            Params   => new Parameter_Array'(1 => Files_Or_Wildcard),\n-            Defext   => \"   \"),\n-\n-         Check =>\n-           (Cname    => new S'(\"CHECK\"),\n-            Usage    => new S'(\"GNAT CHECK name /qualifiers\"),\n-            VMS_Only => False,\n-            Unixcmd  => new S'(\"gnatcheck\"),\n-            Unixsws  => null,\n-            Switches => Check_Switches'Access,\n-            Params   => new Parameter_Array'(1 => Unlimited_Files),\n-            Defext   => \"   \"),\n-\n-         Sync =>\n-           (Cname    => new S'(\"SYNC\"),\n-            Usage    => new S'(\"GNAT SYNC name /qualifiers\"),\n-            VMS_Only => False,\n-            Unixcmd  => new S'(\"gnatsync\"),\n-            Unixsws  => null,\n-            Switches => Sync_Switches'Access,\n-            Params   => new Parameter_Array'(1 => Unlimited_Files),\n-            Defext   => \"   \"),\n-\n-         Elim =>\n-           (Cname    => new S'(\"ELIM\"),\n-            Usage    => new S'(\"GNAT ELIM name /qualifiers\"),\n-            VMS_Only => False,\n-            Unixcmd  => new S'(\"gnatelim\"),\n-            Unixsws  => null,\n-            Switches => Elim_Switches'Access,\n-            Params   => new Parameter_Array'(1 => Other_As_Is),\n-            Defext   => \"ali\"),\n-\n-         Find =>\n-           (Cname    => new S'(\"FIND\"),\n-            Usage    => new S'(\"GNAT FIND pattern[:sourcefile[:line\"\n-                               & \"[:column]]] filespec[,...] /qualifiers\"),\n-            VMS_Only => False,\n-            Unixcmd  => new S'(\"gnatfind\"),\n-            Unixsws  => null,\n-            Switches => Find_Switches'Access,\n-            Params   => new Parameter_Array'(1 => Other_As_Is,\n-                                             2 => Files_Or_Wildcard),\n-            Defext   => \"ali\"),\n-\n-         Krunch =>\n-           (Cname    => new S'(\"KRUNCH\"),\n-            Usage    => new S'(\"GNAT KRUNCH file [/COUNT=nnn]\"),\n-            VMS_Only => False,\n-            Unixcmd  => new S'(\"gnatkr\"),\n-            Unixsws  => null,\n-            Switches => Krunch_Switches'Access,\n-            Params   => new Parameter_Array'(1 => File),\n-            Defext   => \"   \"),\n-\n-         Link =>\n-           (Cname    => new S'(\"LINK\"),\n-            Usage    => new S'(\"GNAT LINK file[.ali]\"\n-                               & \" [extra obj_&_lib_&_exe_&_opt files]\"\n-                               & \" /qualifiers\"),\n-            VMS_Only => False,\n-            Unixcmd  => new S'(\"gnatlink\"),\n-            Unixsws  => null,\n-            Switches => Link_Switches'Access,\n-            Params   => new Parameter_Array'(1 => Unlimited_Files),\n-            Defext   => \"ali\"),\n-\n-         List =>\n-           (Cname    => new S'(\"LIST\"),\n-            Usage    => new S'(\"GNAT LIST /qualifiers object_or_ali_file\"),\n-            VMS_Only => False,\n-            Unixcmd  => new S'(\"gnatls\"),\n-            Unixsws  => null,\n-            Switches => List_Switches'Access,\n-            Params   => new Parameter_Array'(1 => Unlimited_Files),\n-            Defext   => \"ali\"),\n-\n-         Make =>\n-           (Cname    => new S'(\"MAKE\"),\n-            Usage    => new S'(\"GNAT MAKE file(s) /qualifiers (includes \"\n-                               & \"COMPILE /qualifiers)\"),\n-            VMS_Only => False,\n-            Unixcmd  => new S'(\"gnatmake\"),\n-            Unixsws  => null,\n-            Switches => Make_Switches'Access,\n-            Params   => new Parameter_Array'(1 => Unlimited_Files),\n-            Defext   => \"   \"),\n-\n-         Metric =>\n-           (Cname    => new S'(\"METRIC\"),\n-            Usage    => new S'(\"GNAT METRIC /qualifiers source_file\"),\n-            VMS_Only => False,\n-            Unixcmd  => new S'(\"gnatmetric\"),\n-            Unixsws  => null,\n-            Switches => Metric_Switches'Access,\n-            Params   => new Parameter_Array'(1 => Unlimited_Files),\n-            Defext   => \"   \"),\n-\n-         Name =>\n-           (Cname    => new S'(\"NAME\"),\n-            Usage    => new S'(\"GNAT NAME /qualifiers naming-pattern \"\n-                               & \"[naming-patterns]\"),\n-            VMS_Only => False,\n-            Unixcmd  => new S'(\"gnatname\"),\n-            Unixsws  => null,\n-            Switches => Name_Switches'Access,\n-            Params   => new Parameter_Array'(1 => Unlimited_As_Is),\n-            Defext   => \"   \"),\n-\n-         Preprocess =>\n-           (Cname    => new S'(\"PREPROCESS\"),\n-            Usage    =>\n-              new S'(\"GNAT PREPROCESS ifile ofile dfile /qualifiers\"),\n-            VMS_Only => False,\n-            Unixcmd  => new S'(\"gnatprep\"),\n-            Unixsws  => null,\n-            Switches => Prep_Switches'Access,\n-            Params   => new Parameter_Array'(1 .. 3 => File),\n-            Defext   => \"   \"),\n-\n-         Pretty =>\n-           (Cname    => new S'(\"PRETTY\"),\n-            Usage    => new S'(\"GNAT PRETTY /qualifiers source_file\"),\n-            VMS_Only => False,\n-            Unixcmd  => new S'(\"gnatpp\"),\n-            Unixsws  => null,\n-            Switches => Pretty_Switches'Access,\n-            Params   => new Parameter_Array'(1 => Unlimited_Files),\n-            Defext   => \"   \"),\n-\n-         Shared =>\n-           (Cname    => new S'(\"SHARED\"),\n-            Usage    => new S'(\"GNAT SHARED [obj_&_lib_&_exe_&_opt\"\n-                               & \"files] /qualifiers\"),\n-            VMS_Only => True,\n-            Unixcmd  => new S'(\"gcc\"),\n-            Unixsws  =>\n-            new Argument_List'(new String'(\"-shared\") & Init_Object_Dirs),\n-            Switches => Shared_Switches'Access,\n-            Params   => new Parameter_Array'(1 => Unlimited_Files),\n-            Defext   => \"   \"),\n-\n-         Stack =>\n-           (Cname    => new S'(\"STACK\"),\n-            Usage    => new S'(\"GNAT STACK /qualifiers ci_files\"),\n-            VMS_Only => False,\n-            Unixcmd  => new S'(\"gnatstack\"),\n-            Unixsws  => null,\n-            Switches => Stack_Switches'Access,\n-            Params   => new Parameter_Array'(1 => Unlimited_Files),\n-            Defext   => \"ci\" & ASCII.NUL),\n-\n-         Stub =>\n-           (Cname    => new S'(\"STUB\"),\n-            Usage    => new S'(\"GNAT STUB file [directory]/qualifiers\"),\n-            VMS_Only => False,\n-            Unixcmd  => new S'(\"gnatstub\"),\n-            Unixsws  => null,\n-            Switches => Stub_Switches'Access,\n-            Params   => new Parameter_Array'(1 => File, 2 => Optional_File),\n-            Defext   => \"   \"),\n-\n-         Test =>\n-           (Cname    => new S'(\"TEST\"),\n-            Usage    => new S'(\"GNAT TEST file(s) /qualifiers\"),\n-            VMS_Only => False,\n-            Unixcmd  => new S'(\"gnattest\"),\n-            Unixsws  => null,\n-            Switches => Make_Switches'Access,\n-            Params   => new Parameter_Array'(1 => Unlimited_Files),\n-            Defext   => \"   \"),\n-\n-         Xref =>\n-           (Cname    => new S'(\"XREF\"),\n-            Usage    => new S'(\"GNAT XREF filespec[,...] /qualifiers\"),\n-            VMS_Only => False,\n-            Unixcmd  => new S'(\"gnatxref\"),\n-            Unixsws  => null,\n-            Switches => Xref_Switches'Access,\n-            Params   => new Parameter_Array'(1 => Files_Or_Wildcard),\n-            Defext   => \"ali\")\n-        );\n-   end Initialize;\n-\n-   ------------------\n-   -- Invert_Sense --\n-   ------------------\n-\n-   function Invert_Sense (S : String) return VMS_Data.String_Ptr is\n-      Sinv : String (1 .. S'Length * 2);\n-      --  Result (for sure long enough)\n-\n-      Sinvp : Natural := 0;\n-      --  Pointer to output string\n-\n-   begin\n-      for Sp in S'Range loop\n-         if Sp = S'First or else S (Sp - 1) = ',' then\n-            if S (Sp) = '!' then\n-               null;\n-            else\n-               Sinv (Sinvp + 1) := '!';\n-               Sinv (Sinvp + 2) := S (Sp);\n-               Sinvp := Sinvp + 2;\n-            end if;\n-\n-         else\n-            Sinv (Sinvp + 1) := S (Sp);\n-            Sinvp := Sinvp + 1;\n-         end if;\n-      end loop;\n-\n-      return new String'(Sinv (1 .. Sinvp));\n-   end Invert_Sense;\n-\n-   ----------------------\n-   -- Is_Extensionless --\n-   ----------------------\n-\n-   function Is_Extensionless (F : String) return Boolean is\n-   begin\n-      for J in reverse F'Range loop\n-         if F (J) = '.' then\n-            return False;\n-         elsif F (J) = '/' or else F (J) = ']' or else F (J) = ':' then\n-            return True;\n-         end if;\n-      end loop;\n-\n-      return True;\n-   end Is_Extensionless;\n-\n-   -----------\n-   -- Match --\n-   -----------\n-\n-   function Match (S1, S2 : String) return Boolean is\n-      Dif : constant Integer := S2'First - S1'First;\n-\n-   begin\n-\n-      if S1'Length /= S2'Length then\n-         return False;\n-\n-      else\n-         for J in S1'Range loop\n-            if To_Lower (S1 (J)) /= To_Lower (S2 (J + Dif)) then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end if;\n-   end Match;\n-\n-   ------------------\n-   -- Match_Prefix --\n-   ------------------\n-\n-   function Match_Prefix (S1, S2 : String) return Boolean is\n-   begin\n-      if S1'Length > S2'Length then\n-         return False;\n-      else\n-         return Match (S1, S2 (S2'First .. S2'First + S1'Length - 1));\n-      end if;\n-   end Match_Prefix;\n-\n-   -------------------\n-   -- Matching_Name --\n-   -------------------\n-\n-   function Matching_Name\n-     (S     : String;\n-      Itm   : Item_Ptr;\n-      Quiet : Boolean := False) return Item_Ptr\n-   is\n-      P1, P2 : Item_Ptr;\n-\n-      procedure Err;\n-      --  Little procedure to output command/qualifier/option as appropriate\n-      --  and bump error count.\n-\n-      ---------\n-      -- Err --\n-      ---------\n-\n-      procedure Err is\n-      begin\n-         if Quiet then\n-            return;\n-         end if;\n-\n-         Errors := Errors + 1;\n-\n-         if Itm /= null then\n-            case Itm.Id is\n-               when Id_Command =>\n-                  Put (Standard_Error, \"command\");\n-\n-               when Id_Switch =>\n-                  if Hostparm.OpenVMS then\n-                     Put (Standard_Error, \"qualifier\");\n-                  else\n-                     Put (Standard_Error, \"switch\");\n-                  end if;\n-\n-               when Id_Option =>\n-                  Put (Standard_Error, \"option\");\n-\n-            end case;\n-         else\n-            Put (Standard_Error, \"input\");\n-\n-         end if;\n-\n-         Put (Standard_Error, \": \");\n-         Put (Standard_Error, S);\n-      end Err;\n-\n-   --  Start of processing for Matching_Name\n-\n-   begin\n-      --  If exact match, that's the one we want\n-\n-      P1 := Itm;\n-      while P1 /= null loop\n-         if Match (S, P1.Name.all) then\n-            return P1;\n-         else\n-            P1 := P1.Next;\n-         end if;\n-      end loop;\n-\n-      --  Now check for prefix matches\n-\n-      P1 := Itm;\n-      while P1 /= null loop\n-         if P1.Name.all = \"/<other>\" then\n-            return P1;\n-\n-         elsif not Match_Prefix (S, P1.Name.all) then\n-            P1 := P1.Next;\n-\n-         else\n-            --  Here we have found one matching prefix, so see if there is\n-            --  another one (which is an ambiguity)\n-\n-            P2 := P1.Next;\n-            while P2 /= null loop\n-               if Match_Prefix (S, P2.Name.all) then\n-                  if not Quiet then\n-                     Put (Standard_Error, \"ambiguous \");\n-                     Err;\n-                     Put (Standard_Error, \" (matches \");\n-                     Put (Standard_Error, P1.Name.all);\n-\n-                     while P2 /= null loop\n-                        if Match_Prefix (S, P2.Name.all) then\n-                           Put (Standard_Error, ',');\n-                           Put (Standard_Error, P2.Name.all);\n-                        end if;\n-\n-                        P2 := P2.Next;\n-                     end loop;\n-\n-                     Put_Line (Standard_Error, \")\");\n-                  end if;\n-\n-                  return null;\n-               end if;\n-\n-               P2 := P2.Next;\n-            end loop;\n-\n-            --  If we fall through that loop, then there was only one match\n-\n-            return P1;\n-         end if;\n-      end loop;\n-\n-      --  If we fall through outer loop, there was no match\n-\n-      if not Quiet then\n-         Put (Standard_Error, \"unrecognized \");\n-         Err;\n-         New_Line (Standard_Error);\n-      end if;\n-\n-      return null;\n-   end Matching_Name;\n-\n-   -----------------------\n-   -- OK_Alphanumerplus --\n-   -----------------------\n-\n-   function OK_Alphanumerplus (S : String) return Boolean is\n-   begin\n-      if S'Length = 0 then\n-         return False;\n-\n-      else\n-         for J in S'Range loop\n-            if not (Is_Alphanumeric (S (J)) or else\n-                    S (J) = '_' or else S (J) = '$')\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end if;\n-   end OK_Alphanumerplus;\n-\n-   ----------------\n-   -- OK_Integer --\n-   ----------------\n-\n-   function OK_Integer (S : String) return Boolean is\n-   begin\n-      if S'Length = 0 then\n-         return False;\n-\n-      else\n-         for J in S'Range loop\n-            if not Is_Digit (S (J)) then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end if;\n-   end OK_Integer;\n-\n-   --------------------\n-   -- Output_Version --\n-   --------------------\n-\n-   procedure Output_Version is\n-   begin\n-      if AAMP_On_Target then\n-         Put (\"GNAAMP \");\n-      else\n-         Put (\"GNAT \");\n-      end if;\n-\n-      Put_Line (Gnatvsn.Gnat_Version_String);\n-      Put_Line (\"Copyright 1996-\" &\n-                Current_Year &\n-                \", Free Software Foundation, Inc.\");\n-   end Output_Version;\n-\n-   -----------\n-   -- Place --\n-   -----------\n-\n-   procedure Place (C : Character) is\n-   begin\n-      if Cargs then\n-         Cargs_Buffer.Append (C);\n-      else\n-         Buffer.Append (C);\n-      end if;\n-   end Place;\n-\n-   procedure Place (S : String) is\n-   begin\n-      for J in S'Range loop\n-         Place (S (J));\n-      end loop;\n-   end Place;\n-\n-   -----------------\n-   -- Place_Lower --\n-   -----------------\n-\n-   procedure Place_Lower (S : String) is\n-   begin\n-      for J in S'Range loop\n-         Place (To_Lower (S (J)));\n-      end loop;\n-   end Place_Lower;\n-\n-   -------------------------\n-   -- Place_Unix_Switches --\n-   -------------------------\n-\n-   procedure Place_Unix_Switches (S : VMS_Data.String_Ptr) is\n-      P1, P2, P3 : Natural;\n-      Remove     : Boolean;\n-      Slen, Sln2 : Natural;\n-      Wild_Card  : Boolean := False;\n-\n-   begin\n-      P1 := S'First;\n-      while P1 <= S'Last loop\n-         if S (P1) = '!' then\n-            P1 := P1 + 1;\n-            Remove := True;\n-         else\n-            Remove := False;\n-         end if;\n-\n-         P2 := P1;\n-         pragma Assert (S (P1) = '-' or else S (P1) = '`');\n-\n-         while P2 < S'Last and then S (P2 + 1) /= ',' loop\n-            P2 := P2 + 1;\n-         end loop;\n-\n-         --  Switch is now in S (P1 .. P2)\n-\n-         Slen := P2 - P1 + 1;\n-\n-         if Remove then\n-            Wild_Card := S (P2) = '*';\n-\n-            if Wild_Card then\n-               Slen := Slen - 1;\n-               P2   := P2 - 1;\n-            end if;\n-\n-            P3 := 1;\n-            while P3 <= Buffer.Last - Slen loop\n-               if Buffer.Table (P3) = ' '\n-                 and then String (Buffer.Table (P3 + 1 .. P3 + Slen)) =\n-                                                             S (P1 .. P2)\n-                 and then (Wild_Card\n-                             or else\n-                           P3 + Slen = Buffer.Last\n-                             or else\n-                           Buffer.Table (P3 + Slen + 1) = ' ')\n-               then\n-                  Sln2 := Slen;\n-\n-                  if Wild_Card then\n-                     while P3 + Sln2 /= Buffer.Last\n-                       and then Buffer.Table (P3 + Sln2 + 1) /= ' '\n-                     loop\n-                        Sln2 := Sln2 + 1;\n-                     end loop;\n-                  end if;\n-\n-                  Buffer.Table (P3 .. Buffer.Last - Sln2 - 1) :=\n-                    Buffer.Table (P3 + Sln2 + 1 .. Buffer.Last);\n-                  Buffer.Set_Last (Buffer.Last - Sln2 - 1);\n-\n-               else\n-                  P3 := P3 + 1;\n-               end if;\n-            end loop;\n-\n-            if Wild_Card then\n-               P2 := P2 + 1;\n-            end if;\n-\n-         else\n-            pragma Assert (S (P2) /= '*');\n-            Place (' ');\n-\n-            if S (P1) = '`' then\n-               P1 := P1 + 1;\n-            end if;\n-\n-            Place (S (P1 .. P2));\n-         end if;\n-\n-         P1 := P2 + 2;\n-      end loop;\n-   end Place_Unix_Switches;\n-\n-   -----------------------------\n-   -- Preprocess_Command_Data --\n-   -----------------------------\n-\n-   procedure Preprocess_Command_Data is\n-   begin\n-      for C in Real_Command_Type loop\n-         declare\n-            Command : constant Item_Ptr := new Command_Item;\n-\n-            Last_Switch : Item_Ptr;\n-            --  Last switch in list\n-\n-         begin\n-            --  Link new command item into list of commands\n-\n-            if Last_Command = null then\n-               Commands := Command;\n-            else\n-               Last_Command.Next := Command;\n-            end if;\n-\n-            Last_Command := Command;\n-\n-            --  Fill in fields of new command item\n-\n-            Command.Name    := Command_List (C).Cname;\n-            Command.Usage   := Command_List (C).Usage;\n-            Command.Command := C;\n-\n-            if Command_List (C).Unixsws = null then\n-               Command.Unix_String := Command_List (C).Unixcmd;\n-            else\n-               declare\n-                  Cmd  : String (1 .. 5_000);\n-                  Last : Natural := 0;\n-                  Sws  : constant Argument_List_Access :=\n-                           Command_List (C).Unixsws;\n-\n-               begin\n-                  Cmd (1 .. Command_List (C).Unixcmd'Length) :=\n-                    Command_List (C).Unixcmd.all;\n-                  Last := Command_List (C).Unixcmd'Length;\n-\n-                  for J in Sws'Range loop\n-                     Last := Last + 1;\n-                     Cmd (Last) := ' ';\n-                     Cmd (Last + 1 .. Last + Sws (J)'Length) :=\n-                       Sws (J).all;\n-                     Last := Last + Sws (J)'Length;\n-                  end loop;\n-\n-                  Command.Unix_String := new String'(Cmd (1 .. Last));\n-               end;\n-            end if;\n-\n-            Command.Params := Command_List (C).Params;\n-            Command.Defext := Command_List (C).Defext;\n-\n-            Validate_Command_Or_Option (Command.Name);\n-\n-            --  Process the switch list\n-\n-            for S in Command_List (C).Switches'Range loop\n-               declare\n-                  SS : constant VMS_Data.String_Ptr :=\n-                         Command_List (C).Switches (S);\n-                  P  : Natural := SS'First;\n-                  Sw : Item_Ptr := new Switch_Item;\n-\n-                  Last_Opt : Item_Ptr;\n-                  --  Pointer to last option\n-\n-               begin\n-                  --  Link new switch item into list of switches\n-\n-                  if Last_Switch = null then\n-                     Command.Switches := Sw;\n-                  else\n-                     Last_Switch.Next := Sw;\n-                  end if;\n-\n-                  Last_Switch := Sw;\n-\n-                  --  Process switch string, first get name\n-\n-                  while SS (P) /= ' ' and then SS (P) /= '=' loop\n-                     P := P + 1;\n-                  end loop;\n-\n-                  Sw.Name := new String'(SS (SS'First .. P - 1));\n-\n-                  --  Direct translation case\n-\n-                  if SS (P) = ' ' then\n-                     Sw.Translation := T_Direct;\n-                     Sw.Unix_String := new String'(SS (P + 1 .. SS'Last));\n-                     Validate_Unix_Switch (Sw.Unix_String);\n-\n-                     if SS (P - 1) = '>' then\n-                        Sw.Translation := T_Other;\n-\n-                     elsif SS (P + 1) = '`' then\n-                        null;\n-\n-                        --  Create the inverted case (/NO ..)\n-\n-                     elsif SS (SS'First + 1 .. SS'First + 2) /= \"NO\" then\n-                        Sw := new Switch_Item;\n-                        Last_Switch.Next := Sw;\n-                        Last_Switch := Sw;\n-\n-                        Sw.Name :=\n-                          new String'(\"/NO\" & SS (SS'First + 1 .. P - 1));\n-                        Sw.Translation := T_Direct;\n-                        Sw.Unix_String := Invert_Sense (SS (P + 1 .. SS'Last));\n-                        Validate_Unix_Switch (Sw.Unix_String);\n-                     end if;\n-\n-                  --  Directories translation case\n-\n-                  elsif SS (P + 1) = '*' then\n-                     pragma Assert (SS (SS'Last) = '*');\n-                     Sw.Translation := T_Directories;\n-                     Sw.Unix_String := new String'(SS (P + 2 .. SS'Last - 1));\n-                     Validate_Unix_Switch (Sw.Unix_String);\n-\n-                  --  Directory translation case\n-\n-                  elsif SS (P + 1) = '%' then\n-                     pragma Assert (SS (SS'Last) = '%');\n-                     Sw.Translation := T_Directory;\n-                     Sw.Unix_String := new String'(SS (P + 2 .. SS'Last - 1));\n-                     Validate_Unix_Switch (Sw.Unix_String);\n-\n-                  --  File translation case\n-\n-                  elsif SS (P + 1) = '@' then\n-                     pragma Assert (SS (SS'Last) = '@');\n-                     Sw.Translation := T_File;\n-                     Sw.Unix_String := new String'(SS (P + 2 .. SS'Last - 1));\n-                     Validate_Unix_Switch (Sw.Unix_String);\n-\n-                  --  No space file translation case\n-\n-                  elsif SS (P + 1) = '<' then\n-                     pragma Assert (SS (SS'Last) = '>');\n-                     Sw.Translation := T_No_Space_File;\n-                     Sw.Unix_String := new String'(SS (P + 2 .. SS'Last - 1));\n-                     Validate_Unix_Switch (Sw.Unix_String);\n-\n-                  --  Numeric translation case\n-\n-                  elsif SS (P + 1) = '#' then\n-                     pragma Assert (SS (SS'Last) = '#');\n-                     Sw.Translation := T_Numeric;\n-                     Sw.Unix_String := new String'(SS (P + 2 .. SS'Last - 1));\n-                     Validate_Unix_Switch (Sw.Unix_String);\n-\n-                  --  Alphanumerplus translation case\n-\n-                  elsif SS (P + 1) = '|' then\n-                     pragma Assert (SS (SS'Last) = '|');\n-                     Sw.Translation := T_Alphanumplus;\n-                     Sw.Unix_String := new String'(SS (P + 2 .. SS'Last - 1));\n-                     Validate_Unix_Switch (Sw.Unix_String);\n-\n-                  --  String translation case\n-\n-                  elsif SS (P + 1) = '\"' then\n-                     pragma Assert (SS (SS'Last) = '\"');\n-                     Sw.Translation := T_String;\n-                     Sw.Unix_String := new String'(SS (P + 2 .. SS'Last - 1));\n-                     Validate_Unix_Switch (Sw.Unix_String);\n-\n-                  --  Commands translation case\n-\n-                  elsif SS (P + 1) = '?' then\n-                     Sw.Translation := T_Commands;\n-                     Sw.Unix_String := new String'(SS (P + 2 .. SS'Last));\n-\n-                  --  Options translation case\n-\n-                  else\n-                     Sw.Translation := T_Options;\n-                     Sw.Unix_String := new String'(\"\");\n-\n-                     P := P + 1; -- bump past =\n-                     while P <= SS'Last loop\n-                        declare\n-                           Opt : constant Item_Ptr := new Option_Item;\n-                           Q   : Natural;\n-\n-                        begin\n-                           --  Link new option item into options list\n-\n-                           if Last_Opt = null then\n-                              Sw.Options := Opt;\n-                           else\n-                              Last_Opt.Next := Opt;\n-                           end if;\n-\n-                           Last_Opt := Opt;\n-\n-                           --  Fill in fields of new option item\n-\n-                           Q := P;\n-                           while SS (Q) /= ' ' loop\n-                              Q := Q + 1;\n-                           end loop;\n-\n-                           Opt.Name := new String'(SS (P .. Q - 1));\n-                           Validate_Command_Or_Option (Opt.Name);\n-\n-                           P := Q + 1;\n-                           Q := P;\n-\n-                           while Q <= SS'Last and then SS (Q) /= ' ' loop\n-                              Q := Q + 1;\n-                           end loop;\n-\n-                           Opt.Unix_String := new String'(SS (P .. Q - 1));\n-                           Validate_Unix_Switch (Opt.Unix_String);\n-                           P := Q + 1;\n-                        end;\n-                     end loop;\n-                  end if;\n-               end;\n-            end loop;\n-         end;\n-      end loop;\n-   end Preprocess_Command_Data;\n-\n-   ----------------------\n-   -- Process_Argument --\n-   ----------------------\n-\n-   procedure Process_Argument (The_Command : in out Command_Type) is\n-      Argv    : String_Access;\n-      Arg_Idx : Integer;\n-\n-      function Get_Arg_End\n-        (Argv    : String;\n-         Arg_Idx : Integer) return Integer;\n-      --  Begins looking at Arg_Idx + 1 and returns the index of the\n-      --  last character before a slash or else the index of the last\n-      --  character in the string Argv.\n-\n-      -----------------\n-      -- Get_Arg_End --\n-      -----------------\n-\n-      function Get_Arg_End\n-        (Argv    : String;\n-         Arg_Idx : Integer) return Integer\n-      is\n-      begin\n-         for J in Arg_Idx + 1 .. Argv'Last loop\n-            if Argv (J) = '/' then\n-               return J - 1;\n-            end if;\n-         end loop;\n-\n-         return Argv'Last;\n-      end Get_Arg_End;\n-\n-      --  Start of processing for Process_Argument\n-\n-   begin\n-      Cargs := False;\n-\n-      --  If an argument file is open, read the next non empty line\n-\n-      if Is_Open (Arg_File) then\n-         declare\n-            Line : String (1 .. 256);\n-            Last : Natural;\n-         begin\n-            loop\n-               Get_Line (Arg_File, Line, Last);\n-               exit when Last /= 0 or else End_Of_File (Arg_File);\n-            end loop;\n-\n-            --  If the end of the argument file has been reached, close it\n-\n-            if End_Of_File (Arg_File) then\n-               Close (Arg_File);\n-\n-               --  If the last line was empty, return after increasing Arg_Num\n-               --  to go to the next argument on the comment line.\n-\n-               if Last = 0 then\n-                  Arg_Num := Arg_Num + 1;\n-                  return;\n-               end if;\n-            end if;\n-\n-            Argv := new String'(Line (1 .. Last));\n-            Arg_Idx := 1;\n-\n-            if Argv (1) = '@' then\n-               Put_Line (Standard_Error, \"argument file cannot contain @cmd\");\n-               raise Error_Exit;\n-            end if;\n-         end;\n-\n-      else\n-         --  No argument file is open, get the argument on the command line\n-\n-         Argv := new String'(Argument (Arg_Num));\n-         Arg_Idx := Argv'First;\n-\n-         --  Check if this is the specification of an argument file\n-\n-         if Argv (Arg_Idx) = '@' then\n-            --  The first argument on the command line cannot be an argument\n-            --  file.\n-\n-            if Arg_Num = 1 then\n-               Put_Line\n-                 (Standard_Error,\n-                  \"Cannot specify argument line before command\");\n-               raise Error_Exit;\n-            end if;\n-\n-            --  Open the file, after conversion of the name to canonical form.\n-            --  Fail if file is not found.\n-\n-            declare\n-               Canonical_File_Name : String_Access :=\n-                 To_Canonical_File_Spec (Argv (Arg_Idx + 1 .. Argv'Last));\n-            begin\n-               Open (Arg_File, In_File, Canonical_File_Name.all);\n-               Free (Canonical_File_Name);\n-               return;\n-\n-            exception\n-               when others =>\n-                  Put (Standard_Error, \"Cannot open argument file \"\"\");\n-                  Put (Standard_Error, Argv (Arg_Idx + 1 .. Argv'Last));\n-                  Put_Line (Standard_Error, \"\"\"\");\n-                  raise Error_Exit;\n-            end;\n-         end if;\n-      end if;\n-\n-      <<Tryagain_After_Coalesce>>\n-      loop\n-         declare\n-            Next_Arg_Idx : Integer;\n-            Arg          : String_Access;\n-\n-         begin\n-            Next_Arg_Idx := Get_Arg_End (Argv.all, Arg_Idx);\n-            Arg := new String'(Argv (Arg_Idx .. Next_Arg_Idx));\n-\n-            --  The first one must be a command name\n-\n-            if Arg_Num = 1 and then Arg_Idx = Argv'First then\n-               Command := Matching_Name (Arg.all, Commands);\n-\n-               if Command = null then\n-                  raise Error_Exit;\n-               end if;\n-\n-               The_Command := Command.Command;\n-               Output_File_Expected := False;\n-\n-               --  Give usage information if only command given\n-\n-               if Argument_Count = 1\n-                 and then Next_Arg_Idx = Argv'Last\n-               then\n-                  Output_Version;\n-                  New_Line;\n-                  Put_Line\n-                    (\"List of available qualifiers and options\");\n-                  New_Line;\n-\n-                  Put (Command.Usage.all);\n-                  Set_Col (53);\n-                  Put_Line (Command.Unix_String.all);\n-\n-                  declare\n-                     Sw : Item_Ptr := Command.Switches;\n-\n-                  begin\n-                     while Sw /= null loop\n-                        Put (\"   \");\n-                        Put (Sw.Name.all);\n-\n-                        case Sw.Translation is\n-\n-                           when T_Other =>\n-                              Set_Col (53);\n-                              Put_Line (Sw.Unix_String.all &\n-                                        \"/<other>\");\n-\n-                           when T_Direct =>\n-                              Set_Col (53);\n-                              Put_Line (Sw.Unix_String.all);\n-\n-                           when T_Directories =>\n-                              Put (\"=(direc,direc,..direc)\");\n-                              Set_Col (53);\n-                              Put (Sw.Unix_String.all);\n-                              Put (\" direc \");\n-                              Put (Sw.Unix_String.all);\n-                              Put_Line (\" direc ...\");\n-\n-                           when T_Directory =>\n-                              Put (\"=directory\");\n-                              Set_Col (53);\n-                              Put (Sw.Unix_String.all);\n-\n-                              if Sw.Unix_String (Sw.Unix_String'Last)\n-                              /= '='\n-                              then\n-                                 Put (' ');\n-                              end if;\n-\n-                              Put_Line (\"directory \");\n-\n-                           when T_File | T_No_Space_File =>\n-                              Put (\"=file\");\n-                              Set_Col (53);\n-                              Put (Sw.Unix_String.all);\n-\n-                              if Sw.Translation = T_File\n-                                and then Sw.Unix_String\n-                                  (Sw.Unix_String'Last) /= '='\n-                              then\n-                                 Put (' ');\n-                              end if;\n-\n-                              Put_Line (\"file \");\n-\n-                           when T_Numeric =>\n-                              Put (\"=nnn\");\n-                              Set_Col (53);\n-\n-                              if Sw.Unix_String\n-                                (Sw.Unix_String'First) = '`'\n-                              then\n-                                 Put (Sw.Unix_String\n-                                        (Sw.Unix_String'First + 1\n-                                         .. Sw.Unix_String'Last));\n-                              else\n-                                 Put (Sw.Unix_String.all);\n-                              end if;\n-\n-                              Put_Line (\"nnn\");\n-\n-                           when T_Alphanumplus =>\n-                              Put (\"=xyz\");\n-                              Set_Col (53);\n-\n-                              if Sw.Unix_String\n-                                (Sw.Unix_String'First) = '`'\n-                              then\n-                                 Put (Sw.Unix_String\n-                                        (Sw.Unix_String'First + 1\n-                                         .. Sw.Unix_String'Last));\n-                              else\n-                                 Put (Sw.Unix_String.all);\n-                              end if;\n-\n-                              Put_Line (\"xyz\");\n-\n-                           when T_String =>\n-                              Put (\"=\");\n-                              Put ('\"');\n-                              Put (\"<string>\");\n-                              Put ('\"');\n-                              Set_Col (53);\n-\n-                              Put (Sw.Unix_String.all);\n-\n-                              if Sw.Unix_String\n-                                (Sw.Unix_String'Last) /= '='\n-                              then\n-                                 Put (' ');\n-                              end if;\n-\n-                              Put (\"<string>\");\n-                              New_Line;\n-\n-                           when T_Commands =>\n-                              Put (\" (switches for \");\n-                              Put (Sw.Unix_String\n-                                     (Sw.Unix_String'First + 7\n-                                      .. Sw.Unix_String'Last));\n-                              Put (')');\n-                              Set_Col (53);\n-                              Put (Sw.Unix_String\n-                                     (Sw.Unix_String'First\n-                                      .. Sw.Unix_String'First + 5));\n-                              Put_Line (\" switches\");\n-\n-                           when T_Options =>\n-                              declare\n-                                 Opt : Item_Ptr := Sw.Options;\n-\n-                              begin\n-                                 Put_Line (\"=(option,option..)\");\n-\n-                                 while Opt /= null loop\n-                                    Put (\"      \");\n-                                    Put (Opt.Name.all);\n-\n-                                    if Opt = Sw.Options then\n-                                       Put (\" (D)\");\n-                                    end if;\n-\n-                                    Set_Col (53);\n-                                    Put_Line (Opt.Unix_String.all);\n-                                    Opt := Opt.Next;\n-                                 end loop;\n-                              end;\n-\n-                        end case;\n-\n-                        Sw := Sw.Next;\n-                     end loop;\n-                  end;\n-\n-                  raise Normal_Exit;\n-               end if;\n-\n-            --  Special handling for internal debugging switch /?\n-\n-            elsif Arg.all = \"/?\" then\n-               Display_Command := True;\n-               Output_File_Expected := False;\n-\n-            --  Special handling of internal option /KEEP_TEMPORARY_FILES\n-\n-            elsif Arg'Length >= 7\n-              and then Matching_Name\n-                         (Arg.all, Keep_Temps_Option, True) /= null\n-            then\n-               Opt.Keep_Temporary_Files := True;\n-\n-            --  Copy -switch unchanged, as well as +rule\n-\n-            elsif Arg (Arg'First) = '-' or else Arg (Arg'First) = '+' then\n-               Place (' ');\n-               Place (Arg.all);\n-\n-               --  Set Output_File_Expected for the next argument\n-\n-               Output_File_Expected :=\n-                 Arg.all = \"-o\" and then The_Command = Link;\n-\n-               --  Copy quoted switch with quotes stripped\n-\n-            elsif Arg (Arg'First) = '\"' then\n-               if Arg (Arg'Last) /= '\"' then\n-                  Put (Standard_Error, \"misquoted argument: \");\n-                  Put_Line (Standard_Error, Arg.all);\n-                  Errors := Errors + 1;\n-\n-               else\n-                  Place (' ');\n-                  Place (Arg (Arg'First + 1 .. Arg'Last - 1));\n-               end if;\n-\n-               Output_File_Expected := False;\n-\n-               --  Parameter Argument\n-\n-            elsif Arg (Arg'First) /= '/'\n-              and then Make_Commands_Active = null\n-            then\n-               Param_Count := Param_Count + 1;\n-\n-               if Param_Count <= Command.Params'Length then\n-\n-                  case Command.Params (Param_Count) is\n-\n-                     when File | Optional_File =>\n-                        declare\n-                           Normal_File : constant String_Access :=\n-                             To_Canonical_File_Spec\n-                               (Arg.all);\n-\n-                        begin\n-                           Place (' ');\n-                           Place_Lower (Normal_File.all);\n-\n-                           if Is_Extensionless (Normal_File.all)\n-                             and then Command.Defext /= \"   \"\n-                           then\n-                              Place ('.');\n-                              Place (Command.Defext);\n-                           end if;\n-                        end;\n-\n-                     when Unlimited_Files =>\n-                        declare\n-                           Normal_File : constant String_Access :=\n-                             To_Canonical_File_Spec\n-                               (Arg.all);\n-\n-                           File_Is_Wild : Boolean := False;\n-                           File_List    : String_Access_List_Access;\n-\n-                        begin\n-                           for J in Arg'Range loop\n-                              if Arg (J) = '*'\n-                                or else Arg (J) = '%'\n-                              then\n-                                 File_Is_Wild := True;\n-                              end if;\n-                           end loop;\n-\n-                           if File_Is_Wild then\n-                              File_List := To_Canonical_File_List\n-                                (Arg.all, False);\n-\n-                              for J in File_List.all'Range loop\n-                                 Place (' ');\n-                                 Place_Lower (File_List.all (J).all);\n-                              end loop;\n-\n-                           else\n-                              Place (' ');\n-                              Place_Lower (Normal_File.all);\n-\n-                              --  Add extension if not present, except after\n-                              --  switch -o.\n-\n-                              if Is_Extensionless (Normal_File.all)\n-                                and then Command.Defext /= \"   \"\n-                                and then not Output_File_Expected\n-                              then\n-                                 Place ('.');\n-                                 Place (Command.Defext);\n-                              end if;\n-                           end if;\n-\n-                           Param_Count := Param_Count - 1;\n-                        end;\n-\n-                     when Other_As_Is =>\n-                        Place (' ');\n-                        Place (Arg.all);\n-\n-                     when Unlimited_As_Is =>\n-                        Place (' ');\n-                        Place (Arg.all);\n-                        Param_Count := Param_Count - 1;\n-\n-                     when Files_Or_Wildcard =>\n-\n-                        --  Remove spaces from a comma separated list\n-                        --  of file names and adjust control variables\n-                        --  accordingly.\n-\n-                        while Arg_Num < Argument_Count and then\n-                          (Argv (Argv'Last) = ',' xor\n-                             Argument (Arg_Num + 1)\n-                             (Argument (Arg_Num + 1)'First) = ',')\n-                        loop\n-                           Argv := new String'\n-                             (Argv.all & Argument (Arg_Num + 1));\n-                           Arg_Num := Arg_Num + 1;\n-                           Arg_Idx := Argv'First;\n-                           Next_Arg_Idx :=\n-                             Get_Arg_End (Argv.all, Arg_Idx);\n-                           Arg := new String'\n-                             (Argv (Arg_Idx .. Next_Arg_Idx));\n-                        end loop;\n-\n-                        --  Parse the comma separated list of VMS\n-                        --  filenames and place them on the command\n-                        --  line as space separated Unix style\n-                        --  filenames. Lower case and add default\n-                        --  extension as appropriate.\n-\n-                        declare\n-                           Arg1_Idx : Integer := Arg'First;\n-\n-                           function Get_Arg1_End\n-                             (Arg     : String;\n-                              Arg_Idx : Integer) return Integer;\n-                           --  Begins looking at Arg_Idx + 1 and\n-                           --  returns the index of the last character\n-                           --  before a comma or else the index of the\n-                           --  last character in the string Arg.\n-\n-                           ------------------\n-                           -- Get_Arg1_End --\n-                           ------------------\n-\n-                           function Get_Arg1_End\n-                             (Arg     : String;\n-                              Arg_Idx : Integer) return Integer\n-                           is\n-                           begin\n-                              for J in Arg_Idx + 1 .. Arg'Last loop\n-                                 if Arg (J) = ',' then\n-                                    return J - 1;\n-                                 end if;\n-                              end loop;\n-\n-                              return Arg'Last;\n-                           end Get_Arg1_End;\n-\n-                        begin\n-                           loop\n-                              declare\n-                                 Next_Arg1_Idx :\n-                                 constant Integer :=\n-                                   Get_Arg1_End (Arg.all, Arg1_Idx);\n-\n-                                 Arg1 :\n-                                 constant String :=\n-                                   Arg (Arg1_Idx .. Next_Arg1_Idx);\n-\n-                                 Normal_File :\n-                                 constant String_Access :=\n-                                   To_Canonical_File_Spec (Arg1);\n-\n-                              begin\n-                                 Place (' ');\n-                                 Place_Lower (Normal_File.all);\n-\n-                                 if Is_Extensionless (Normal_File.all)\n-                                   and then Command.Defext /= \"   \"\n-                                 then\n-                                    Place ('.');\n-                                    Place (Command.Defext);\n-                                 end if;\n-\n-                                 Arg1_Idx := Next_Arg1_Idx + 1;\n-                              end;\n-\n-                              exit when Arg1_Idx > Arg'Last;\n-\n-                              --  Don't allow two or more commas in\n-                              --  a row\n-\n-                              if Arg (Arg1_Idx) = ',' then\n-                                 Arg1_Idx := Arg1_Idx + 1;\n-                                 if Arg1_Idx > Arg'Last or else\n-                                   Arg (Arg1_Idx) = ','\n-                                 then\n-                                    Put_Line\n-                                      (Standard_Error,\n-                                       \"Malformed Parameter: \" &\n-                                       Arg.all);\n-                                    Put (Standard_Error, \"usage: \");\n-                                    Put_Line (Standard_Error,\n-                                              Command.Usage.all);\n-                                    raise Error_Exit;\n-                                 end if;\n-                              end if;\n-\n-                           end loop;\n-                        end;\n-                  end case;\n-               end if;\n-\n-               --  Reset Output_File_Expected, in case it was True\n-\n-               Output_File_Expected := False;\n-\n-               --  Qualifier argument\n-\n-            else\n-               Output_File_Expected := False;\n-\n-               Cargs := Command.Name.all = \"COMPILE\";\n-\n-               --  This code is too heavily nested, should be\n-               --  separated out as separate subprogram ???\n-\n-               declare\n-                  Sw   : Item_Ptr;\n-                  SwP  : Natural;\n-                  P2   : Natural;\n-                  Endp : Natural := 0; -- avoid warning\n-                  Opt  : Item_Ptr;\n-\n-               begin\n-                  SwP := Arg'First;\n-                  while SwP < Arg'Last\n-                    and then Arg (SwP + 1) /= '='\n-                  loop\n-                     SwP := SwP + 1;\n-                  end loop;\n-\n-                  --  At this point, the switch name is in\n-                  --  Arg (Arg'First..SwP) and if that is not the\n-                  --  whole switch, then there is an equal sign at\n-                  --  Arg (SwP + 1) and the rest of Arg is what comes\n-                  --  after the equal sign.\n-\n-                  --  If make commands are active, see if we have\n-                  --  another COMMANDS_TRANSLATION switch belonging\n-                  --  to gnatmake.\n-\n-                  if Make_Commands_Active /= null then\n-                     Sw :=\n-                       Matching_Name\n-                         (Arg (Arg'First .. SwP),\n-                          Command.Switches,\n-                          Quiet => True);\n-\n-                     if Sw /= null\n-                       and then Sw.Translation = T_Commands\n-                     then\n-                        null;\n-\n-                     else\n-                        Sw :=\n-                          Matching_Name\n-                            (Arg (Arg'First .. SwP),\n-                             Make_Commands_Active.Switches,\n-                             Quiet => False);\n-                     end if;\n-\n-                     --  For case of GNAT MAKE or CHOP, if we cannot\n-                     --  find the switch, then see if it is a\n-                     --  recognized compiler switch instead, and if\n-                     --  so process the compiler switch.\n-\n-                  elsif Command.Name.all = \"MAKE\"\n-                          or else\n-                        Command.Name.all = \"CHOP\"\n-                  then\n-                     Sw :=\n-                       Matching_Name\n-                         (Arg (Arg'First .. SwP),\n-                          Command.Switches,\n-                          Quiet => True);\n-\n-                     if Sw = null then\n-                        Sw :=\n-                          Matching_Name\n-                            (Arg (Arg'First .. SwP),\n-                             Matching_Name\n-                               (\"COMPILE\", Commands).Switches,\n-                             Quiet => False);\n-                     end if;\n-\n-                     --  For all other cases, just search the relevant\n-                     --  command.\n-\n-                  else\n-                     Sw :=\n-                       Matching_Name\n-                         (Arg (Arg'First .. SwP),\n-                          Command.Switches,\n-                          Quiet => False);\n-\n-                     --  Special case for GNAT COMPILE /UNCHECKED...\n-                     --  because the corresponding switch --unchecked... is\n-                     --  for gnatmake, not for the compiler.\n-\n-                     if Cargs\n-                       and then Sw.Name.all = \"/UNCHECKED_SHARED_LIB_IMPORTS\"\n-                     then\n-                        Cargs := False;\n-                     end if;\n-                  end if;\n-\n-                  if Sw /= null then\n-                     if Cargs\n-                       and then Sw.Name /= null\n-                       and then\n-                         (Sw.Name.all = \"/PROJECT_FILE\"          or else\n-                          Sw.Name.all = \"/MESSAGES_PROJECT_FILE\" or else\n-                          Sw.Name.all = \"/EXTERNAL_REFERENCE\")\n-                     then\n-                        Cargs := False;\n-                     end if;\n-\n-                     case Sw.Translation is\n-                        when T_Direct =>\n-                           Place_Unix_Switches (Sw.Unix_String);\n-\n-                           if SwP < Arg'Last\n-                             and then Arg (SwP + 1) = '='\n-                           then\n-                              Put (Standard_Error,\n-                                   \"qualifier options ignored: \");\n-                              Put_Line (Standard_Error, Arg.all);\n-                           end if;\n-\n-                        when T_Directories =>\n-                           if SwP + 1 > Arg'Last then\n-                              Put (Standard_Error,\n-                                   \"missing directories for: \");\n-                              Put_Line (Standard_Error, Arg.all);\n-                              Errors := Errors + 1;\n-\n-                           elsif Arg (SwP + 2) /= '(' then\n-                              SwP := SwP + 2;\n-                              Endp := Arg'Last;\n-\n-                           elsif Arg (Arg'Last) /= ')' then\n-\n-                              --  Remove spaces from a comma separated\n-                              --  list of file names and adjust\n-                              --  control variables accordingly.\n-\n-                              if Arg_Num < Argument_Count and then\n-                                (Argv (Argv'Last) = ',' xor\n-                                   Argument (Arg_Num + 1)\n-                                   (Argument (Arg_Num + 1)'First) = ',')\n-                              then\n-                                 Argv :=\n-                                   new String'(Argv.all\n-                                               & Argument\n-                                                 (Arg_Num + 1));\n-                                 Arg_Num := Arg_Num + 1;\n-                                 Arg_Idx := Argv'First;\n-                                 Next_Arg_Idx :=\n-                                   Get_Arg_End (Argv.all, Arg_Idx);\n-                                 Arg :=\n-                                   new String'(Argv (Arg_Idx .. Next_Arg_Idx));\n-                                 goto Tryagain_After_Coalesce;\n-                              end if;\n-\n-                              Put (Standard_Error,\n-                                   \"incorrectly parenthesized \" &\n-                                   \"or malformed argument: \");\n-                              Put_Line (Standard_Error, Arg.all);\n-                              Errors := Errors + 1;\n-\n-                           else\n-                              SwP := SwP + 3;\n-                              Endp := Arg'Last - 1;\n-                           end if;\n-\n-                           while SwP <= Endp loop\n-                              declare\n-                                 Dir_Is_Wild       : Boolean := False;\n-                                 Dir_Maybe_Is_Wild : Boolean := False;\n-\n-                                 Dir_List : String_Access_List_Access;\n-\n-                              begin\n-                                 P2 := SwP;\n-\n-                                 while P2 < Endp\n-                                   and then Arg (P2 + 1) /= ','\n-                                 loop\n-                                    --  A wildcard directory spec on VMS will\n-                                    --  contain either * or % or ...\n-\n-                                    if Arg (P2) = '*' then\n-                                       Dir_Is_Wild := True;\n-\n-                                    elsif Arg (P2) = '%' then\n-                                       Dir_Is_Wild := True;\n-\n-                                    elsif Dir_Maybe_Is_Wild\n-                                      and then Arg (P2) = '.'\n-                                      and then Arg (P2 + 1) = '.'\n-                                    then\n-                                       Dir_Is_Wild := True;\n-                                       Dir_Maybe_Is_Wild := False;\n-\n-                                    elsif Dir_Maybe_Is_Wild then\n-                                       Dir_Maybe_Is_Wild := False;\n-\n-                                    elsif Arg (P2) = '.'\n-                                      and then Arg (P2 + 1) = '.'\n-                                    then\n-                                       Dir_Maybe_Is_Wild := True;\n-\n-                                    end if;\n-\n-                                    P2 := P2 + 1;\n-                                 end loop;\n-\n-                                 if Dir_Is_Wild then\n-                                    Dir_List :=\n-                                      To_Canonical_File_List\n-                                        (Arg (SwP .. P2), True);\n-\n-                                    for J in Dir_List.all'Range loop\n-                                       Place_Unix_Switches (Sw.Unix_String);\n-                                       Place_Lower (Dir_List.all (J).all);\n-                                    end loop;\n-\n-                                 else\n-                                    Place_Unix_Switches (Sw.Unix_String);\n-                                    Place_Lower\n-                                      (To_Canonical_Dir_Spec\n-                                         (Arg (SwP .. P2), False).all);\n-                                 end if;\n-\n-                                 SwP := P2 + 2;\n-                              end;\n-                           end loop;\n-\n-                        when T_Directory =>\n-                           if SwP + 1 > Arg'Last then\n-                              Put (Standard_Error,\n-                                   \"missing directory for: \");\n-                              Put_Line (Standard_Error, Arg.all);\n-                              Errors := Errors + 1;\n-\n-                           else\n-                              Place_Unix_Switches (Sw.Unix_String);\n-\n-                              --  Some switches end in \"=\", no space here\n-\n-                              if Sw.Unix_String\n-                                      (Sw.Unix_String'Last) /= '='\n-                              then\n-                                 Place (' ');\n-                              end if;\n-\n-                              Place_Lower\n-                                (To_Canonical_Dir_Spec\n-                                   (Arg (SwP + 2 .. Arg'Last), False).all);\n-                           end if;\n-\n-                        when T_File | T_No_Space_File =>\n-                           if SwP + 2 > Arg'Last then\n-                              Put (Standard_Error, \"missing file for: \");\n-                              Put_Line (Standard_Error, Arg.all);\n-                              Errors := Errors + 1;\n-\n-                           else\n-                              Place_Unix_Switches (Sw.Unix_String);\n-\n-                              --  Some switches end in \"=\", no space here.\n-\n-                              if Sw.Translation = T_File\n-                                and then Sw.Unix_String\n-                                           (Sw.Unix_String'Last) /= '='\n-                              then\n-                                 Place (' ');\n-                              end if;\n-\n-                              Place_Lower\n-                                (To_Canonical_File_Spec\n-                                   (Arg (SwP + 2 .. Arg'Last)).all);\n-                           end if;\n-\n-                        when T_Numeric =>\n-                           if OK_Integer (Arg (SwP + 2 .. Arg'Last)) then\n-                              Place_Unix_Switches (Sw.Unix_String);\n-                              Place (Arg (SwP + 2 .. Arg'Last));\n-\n-                           else\n-                              Put (Standard_Error, \"argument for \");\n-                              Put (Standard_Error, Sw.Name.all);\n-                              Put_Line (Standard_Error, \" must be numeric\");\n-                              Errors := Errors + 1;\n-                           end if;\n-\n-                        when T_Alphanumplus =>\n-                           if OK_Alphanumerplus\n-                                (Arg (SwP + 2 .. Arg'Last))\n-                           then\n-                              Place_Unix_Switches (Sw.Unix_String);\n-                              Place (Arg (SwP + 2 .. Arg'Last));\n-\n-                           else\n-                              Put (Standard_Error, \"argument for \");\n-                              Put (Standard_Error, Sw.Name.all);\n-                              Put_Line (Standard_Error,\n-                                        \" must be alphanumeric\");\n-                              Errors := Errors + 1;\n-                           end if;\n-\n-                        when T_String =>\n-\n-                           --  A String value must be extended to the end of\n-                           --  the Argv, otherwise strings like \"foo/bar\" get\n-                           --  split at the slash.\n-\n-                           --  The beginning and ending of the string are\n-                           --  flagged with embedded nulls which are removed\n-                           --  when building the Spawn call. Nulls are use\n-                           --  because they won't show up in a /? output.\n-                           --  Quotes aren't used because that would make it\n-                           --  difficult to embed them.\n-\n-                           Place_Unix_Switches (Sw.Unix_String);\n-\n-                           if Next_Arg_Idx /= Argv'Last then\n-                              Next_Arg_Idx := Argv'Last;\n-                              Arg :=\n-                                new String'(Argv (Arg_Idx .. Next_Arg_Idx));\n-\n-                              SwP := Arg'First;\n-                              while SwP < Arg'Last\n-                                and then Arg (SwP + 1) /= '='\n-                              loop\n-                                 SwP := SwP + 1;\n-                              end loop;\n-                           end if;\n-\n-                           Place (ASCII.NUL);\n-                           Place (Arg (SwP + 2 .. Arg'Last));\n-                           Place (ASCII.NUL);\n-\n-                        when T_Commands =>\n-\n-                           --  Output -largs/-bargs/-cargs\n-\n-                           Place (' ');\n-                           Place (Sw.Unix_String\n-                                    (Sw.Unix_String'First ..\n-                                       Sw.Unix_String'First + 5));\n-\n-                           if Sw.Unix_String\n-                             (Sw.Unix_String'First + 7 ..\n-                                Sw.Unix_String'Last) = \"MAKE\"\n-                           then\n-                              Make_Commands_Active := null;\n-\n-                           else\n-                              --  Set source of new commands, also setting this\n-                              --  non-null indicates that we are in the special\n-                              --  commands mode for processing the -xargs case.\n-\n-                              Make_Commands_Active :=\n-                                Matching_Name\n-                                  (Sw.Unix_String\n-                                       (Sw.Unix_String'First + 7 ..\n-                                            Sw.Unix_String'Last),\n-                                   Commands);\n-                           end if;\n-\n-                        when T_Options =>\n-                           if SwP + 1 > Arg'Last then\n-                              Place_Unix_Switches (Sw.Options.Unix_String);\n-                              SwP := Endp + 1;\n-\n-                           elsif Arg (SwP + 2) /= '(' then\n-                              SwP := SwP + 2;\n-                              Endp := Arg'Last;\n-\n-                           elsif Arg (Arg'Last) /= ')' then\n-                              Put (Standard_Error,\n-                                   \"incorrectly parenthesized argument: \");\n-                              Put_Line (Standard_Error, Arg.all);\n-                              Errors := Errors + 1;\n-                              SwP := Endp + 1;\n-\n-                           else\n-                              SwP := SwP + 3;\n-                              Endp := Arg'Last - 1;\n-                           end if;\n-\n-                           while SwP <= Endp loop\n-                              P2 := SwP;\n-                              while P2 < Endp\n-                                and then Arg (P2 + 1) /= ','\n-                              loop\n-                                 P2 := P2 + 1;\n-                              end loop;\n-\n-                              --  Option name is in Arg (SwP .. P2)\n-\n-                              Opt := Matching_Name (Arg (SwP .. P2),\n-                                                    Sw.Options);\n-\n-                              if Opt /= null then\n-                                 Place_Unix_Switches (Opt.Unix_String);\n-                              end if;\n-\n-                              SwP := P2 + 2;\n-                           end loop;\n-\n-                        when T_Other =>\n-                           Place_Unix_Switches\n-                             (new String'(Sw.Unix_String.all & Arg.all));\n-\n-                     end case;\n-                  end if;\n-               end;\n-            end if;\n-\n-            Arg_Idx := Next_Arg_Idx + 1;\n-         end;\n-\n-         exit when Arg_Idx > Argv'Last;\n-\n-      end loop;\n-\n-      if not Is_Open (Arg_File) then\n-         Arg_Num := Arg_Num + 1;\n-      end if;\n-   end Process_Argument;\n-\n-   --------------------\n-   -- Process_Buffer --\n-   --------------------\n-\n-   procedure Process_Buffer (S : String) is\n-      P1, P2     : Natural;\n-      Inside_Nul : Boolean := False;\n-      Arg        : String (1 .. 1024);\n-      Arg_Ctr    : Natural;\n-\n-   begin\n-      P1 := 1;\n-      while P1 <= S'Last and then S (P1) = ' ' loop\n-         P1 := P1 + 1;\n-      end loop;\n-\n-      Arg_Ctr := 1;\n-      Arg (Arg_Ctr) := S (P1);\n-\n-      while P1 <= S'Last loop\n-         if S (P1) = ASCII.NUL then\n-            if Inside_Nul then\n-               Inside_Nul := False;\n-            else\n-               Inside_Nul := True;\n-            end if;\n-         end if;\n-\n-         if S (P1) = ' ' and then not Inside_Nul then\n-            P1 := P1 + 1;\n-            Arg_Ctr := Arg_Ctr + 1;\n-            Arg (Arg_Ctr) := S (P1);\n-\n-         else\n-            Last_Switches.Increment_Last;\n-            P2 := P1;\n-\n-            while P2 < S'Last\n-              and then (S (P2 + 1) /= ' ' or else\n-                        Inside_Nul)\n-            loop\n-               P2 := P2 + 1;\n-               Arg_Ctr := Arg_Ctr + 1;\n-               Arg (Arg_Ctr) := S (P2);\n-               if S (P2) = ASCII.NUL then\n-                  Arg_Ctr := Arg_Ctr - 1;\n-\n-                  if Inside_Nul then\n-                     Inside_Nul := False;\n-                  else\n-                     Inside_Nul := True;\n-                  end if;\n-               end if;\n-            end loop;\n-\n-            Last_Switches.Table (Last_Switches.Last) :=\n-              new String'(String (Arg (1 .. Arg_Ctr)));\n-            P1 := P2 + 2;\n-\n-            exit when P1 > S'Last;\n-\n-            Arg_Ctr := 1;\n-            Arg (Arg_Ctr) := S (P1);\n-         end if;\n-      end loop;\n-   end Process_Buffer;\n-\n-   --------------------------------\n-   -- Validate_Command_Or_Option --\n-   --------------------------------\n-\n-   procedure Validate_Command_Or_Option (N : VMS_Data.String_Ptr) is\n-   begin\n-      pragma Assert (N'Length > 0);\n-\n-      for J in N'Range loop\n-         if N (J) = '_' then\n-            pragma Assert (N (J - 1) /= '_');\n-            null;\n-         else\n-            pragma Assert (Is_Upper (N (J)) or else Is_Digit (N (J)));\n-            null;\n-         end if;\n-      end loop;\n-   end Validate_Command_Or_Option;\n-\n-   --------------------------\n-   -- Validate_Unix_Switch --\n-   --------------------------\n-\n-   procedure Validate_Unix_Switch (S : VMS_Data.String_Ptr) is\n-   begin\n-      if S (S'First) = '`' then\n-         return;\n-      end if;\n-\n-      pragma Assert (S (S'First) = '-' or else S (S'First) = '!');\n-\n-      for J in S'First + 1 .. S'Last loop\n-         pragma Assert (S (J) /= ' ');\n-\n-         if S (J) = '!' then\n-            pragma Assert (S (J - 1) = ',' and then S (J + 1) = '-');\n-            null;\n-         end if;\n-      end loop;\n-   end Validate_Unix_Switch;\n-\n-   --------------------\n-   -- VMS_Conversion --\n-   --------------------\n-\n-   procedure VMS_Conversion (The_Command : out Command_Type) is\n-      Result     : Command_Type := Undefined;\n-      Result_Set : Boolean      := False;\n-\n-   begin\n-      Buffer.Init;\n-\n-      --  First we must preprocess the string form of the command and options\n-      --  list into the internal form that we use.\n-\n-      Preprocess_Command_Data;\n-\n-      --  If no parameters, give complete list of commands\n-\n-      if Argument_Count = 0 then\n-         Output_Version;\n-         New_Line;\n-         Put_Line (\"List of available commands\");\n-         New_Line;\n-\n-         while Commands /= null loop\n-\n-            --  No usage for GNAT SYNC\n-\n-            if Commands.Command /= Sync then\n-               Put (Commands.Usage.all);\n-               Set_Col (53);\n-               Put_Line (Commands.Unix_String.all);\n-            end if;\n-\n-            Commands := Commands.Next;\n-         end loop;\n-\n-         raise Normal_Exit;\n-      end if;\n-\n-      --  Loop through arguments\n-\n-      Arg_Num := 1;\n-      while Arg_Num <= Argument_Count loop\n-         Process_Argument (Result);\n-\n-         if not Result_Set then\n-            The_Command := Result;\n-            Result_Set := True;\n-         end if;\n-      end loop;\n-\n-      --  Gross error checking that the number of parameters is correct.\n-      --  Not applicable to Unlimited_Files parameters.\n-\n-      if (Param_Count = Command.Params'Length - 1\n-            and then Command.Params (Param_Count + 1) = Unlimited_Files)\n-        or else Param_Count <= Command.Params'Length\n-      then\n-         null;\n-\n-      else\n-         Put_Line (Standard_Error,\n-                   \"Parameter count of \"\n-                   & Integer'Image (Param_Count)\n-                   & \" not equal to expected \"\n-                   & Integer'Image (Command.Params'Length));\n-         Put (Standard_Error, \"usage: \");\n-         Put_Line (Standard_Error, Command.Usage.all);\n-         Errors := Errors + 1;\n-      end if;\n-\n-      if Errors > 0 then\n-         raise Error_Exit;\n-      else\n-         --  Prepare arguments for a call to spawn, filtering out\n-         --  embedded nulls place there to delineate strings.\n-\n-         Process_Buffer (String (Buffer.Table (1 .. Buffer.Last)));\n-\n-         if Cargs_Buffer.Last > 1 then\n-            Last_Switches.Append (new String'(\"-cargs\"));\n-            Process_Buffer\n-              (String (Cargs_Buffer.Table (1 .. Cargs_Buffer.Last)));\n-         end if;\n-      end if;\n-   end VMS_Conversion;\n-\n-end VMS_Conv;"}, {"sha": "bba701505df6e29a4c84e63b7c13d4191880748b", "filename": "gcc/ada/vms_conv.ads", "status": "removed", "additions": 0, "deletions": 159, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2422831252036d2821984173a7a22aac5518ef5c/gcc%2Fada%2Fvms_conv.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2422831252036d2821984173a7a22aac5518ef5c/gcc%2Fada%2Fvms_conv.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_conv.ads?ref=2422831252036d2821984173a7a22aac5518ef5c", "patch": "@@ -1,159 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                            V M S _ C O N V                               --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 2003-2013, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package is part of the GNAT driver. It contains the procedure\n---  VMS_Conversion to convert a VMS command line to the equivalent command\n---  line with switches for the GNAT tools that the GNAT driver will invoke.\n---  The qualifier declarations are contained in package VMS_Data.\n-\n-with Table;\n-with VMS_Data; use VMS_Data;\n-with VMS_Cmds; use VMS_Cmds;\n-\n-with GNAT.OS_Lib; use GNAT.OS_Lib;\n-\n-package VMS_Conv is\n-\n-   --  A table to keep the switches on the command line\n-\n-   package Last_Switches is new Table.Table\n-     (Table_Component_Type => String_Access,\n-      Table_Index_Type     => Integer,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 20,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Gnatcmd.Last_Switches\");\n-\n-   Normal_Exit : exception;\n-   --  Raise this exception for normal program termination\n-\n-   Error_Exit : exception;\n-   --  Raise this exception if error detected\n-\n-   Errors : Natural := 0;\n-   --  Count errors detected\n-\n-   Display_Command : Boolean := False;\n-   --  Set true if /? switch causes display of generated command (on VMS)\n-\n-   -------------------\n-   -- Command Table --\n-   -------------------\n-\n-   --  The command table contains an entry for each command recognized by\n-   --  GNATCmd. The entries are represented by an array of records.\n-\n-   type Parameter_Type is\n-   --  A parameter is defined as a whitespace bounded string, not beginning\n-   --   with a slash. (But see note under FILES_OR_WILDCARD).\n-     (File,\n-      --  A required file or directory parameter\n-\n-      Optional_File,\n-      --  An optional file or directory parameter\n-\n-      Other_As_Is,\n-      --  A parameter that's passed through as is (not canonicalized)\n-\n-      Unlimited_Files,\n-      --  An unlimited number of whitespace separate file or directory\n-      --  parameters including wildcard specifications.\n-\n-      Unlimited_As_Is,\n-      --  An unlimited number of whitespace separated parameters that are\n-      --  passed through as is (not canonicalized).\n-\n-      Files_Or_Wildcard);\n-      --  A comma separated list of files and/or wildcard file specifications.\n-      --  A comma preceded by or followed by whitespace is considered as a\n-      --  single comma character w/o whitespace.\n-\n-   type Parameter_Array is array (Natural range <>) of Parameter_Type;\n-   type Parameter_Ref is access all Parameter_Array;\n-\n-   type Alternate_Command is (Comp, Ls, Kr, Pp, Prep);\n-   --  Alternate command label for non VMS system use\n-\n-   Corresponding_To : constant array (Alternate_Command) of Command_Type :=\n-     (Comp  => Compile,\n-      Ls    => List,\n-      Kr    => Krunch,\n-      Prep  => Preprocess,\n-      Pp    => Pretty);\n-   --  Mapping of alternate commands to commands\n-\n-   type Command_Entry is record\n-      Cname : String_Ptr;\n-      --  Command name for GNAT xxx command\n-\n-      Usage : String_Ptr;\n-      --  A usage string, used for error messages\n-\n-      Unixcmd : String_Ptr;\n-      --  Corresponding Unix command\n-\n-      Unixsws : Argument_List_Access;\n-      --  Switches for the Unix command\n-\n-      VMS_Only : Boolean;\n-      --  When True, the command can only be used on VMS\n-\n-      Switches : Switches_Ptr;\n-      --  Pointer to array of switch strings\n-\n-      Params : Parameter_Ref;\n-      --  Describes the allowable types of parameters.\n-      --  Params (1) is the type of the first parameter, etc.\n-      --  An empty parameter array means this command takes no parameters.\n-\n-      Defext : String (1 .. 3);\n-      --  Default extension. If non-blank, then this extension is supplied by\n-      --  default as the extension for any file parameter which does not have\n-      --  an extension already.\n-   end record;\n-\n-   -------------------\n-   -- Switch Tables --\n-   -------------------\n-\n-   --  The switch tables contain an entry for each switch recognized by the\n-   --  command processor. It is initialized by procedure Initialize.\n-\n-   Command_List : array (Real_Command_Type) of Command_Entry;\n-\n-   ----------------\n-   -- Procedures --\n-   ----------------\n-\n-   procedure Initialize;\n-   --  Initialized the switch table Command_List\n-\n-   procedure Output_Version;\n-   --  Output the version of this program\n-\n-   procedure VMS_Conversion (The_Command : out Command_Type);\n-   --  Converts VMS command line to equivalent Unix command line\n-\n-end VMS_Conv;"}, {"sha": "b4a19d8a9c43ef890edef61ba9776eaee52fbe2d", "filename": "gcc/ada/vms_data.ads", "status": "removed", "additions": 0, "deletions": 7794, "changes": 7794, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2422831252036d2821984173a7a22aac5518ef5c/gcc%2Fada%2Fvms_data.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2422831252036d2821984173a7a22aac5518ef5c/gcc%2Fada%2Fvms_data.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_data.ads?ref=2422831252036d2821984173a7a22aac5518ef5c"}]}