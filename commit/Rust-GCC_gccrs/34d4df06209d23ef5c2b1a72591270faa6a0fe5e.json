{"sha": "34d4df06209d23ef5c2b1a72591270faa6a0fe5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRkNGRmMDYyMDlkMjNlZjVjMmIxYTcyNTkxMjcwZmFhNmEwZmU1ZQ==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "2000-08-11T22:01:37Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2000-08-11T22:01:37Z"}, "message": "class.c (maybe_layout_super_class): Fixed indentation.\n\n2000-08-10  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n        * class.c (maybe_layout_super_class): Fixed indentation.\n        * java-tree.h (CLASS_METHOD_CHECKED_P): New macro.\n        (java_check_methods): New function declaration.\n        * jcf-parse.c (get_constant): Let `char_len' go up to 3. Use `str'\n        instead of `str_ptr'.\n        * jcf-write.c (generate_bytecode_insns): Emit number the of args\n        of a `invokeinterface' at the right time.\n        * parse.h (WFL_STRIP_BRACKET): New macro.\n        (SET_TYPE_FOR_RESOLUTION): Use it.\n        * parse.y (build_unresolved_array_type): Reuse `type_or_wfl.'\n        (check_class_interface_creation): Don't check for cross package\n        innerclass name clashes.\n        (method_header): Behave properly if MDECL is `error_mark_node.'\n        (method_declarator): Return `error_mark_node' if bogus current\n        class.\n        (resolve_class): Apply WFL_STRIP_BRACKET on `cl' if necessary.\n        (resolve_and_layout): New local `decl_type', set and used. Call\n        java_check_methods.\n        (java_check_methods): New method.\n        (java_layout_classes): Use it.\n        (resolve_qualified_expression_name): No EH check necessary in\n        access$<n>.\n        (java_complete_lhs): Use VAR_DECL's DECL_INITIAL when evaluating\n        `case' statement.\n        (patch_assignment): Set DECL_INITIAL on integral final local.\n\n(http://gcc.gnu.org/ml/gcc-patches/2000-08/msg00516.html)\n\nFrom-SVN: r35644", "tree": {"sha": "c88a7c7ce85707c22a2566ab9425e0d0382392f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c88a7c7ce85707c22a2566ab9425e0d0382392f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34d4df06209d23ef5c2b1a72591270faa6a0fe5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34d4df06209d23ef5c2b1a72591270faa6a0fe5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34d4df06209d23ef5c2b1a72591270faa6a0fe5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34d4df06209d23ef5c2b1a72591270faa6a0fe5e/comments", "author": null, "committer": null, "parents": [{"sha": "82fbe83592e43e88f8e355fc507e16eb1c761f74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82fbe83592e43e88f8e355fc507e16eb1c761f74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82fbe83592e43e88f8e355fc507e16eb1c761f74"}], "stats": {"total": 171, "additions": 134, "deletions": 37}, "files": [{"sha": "0a9465f94f431482b23f2592c8e2b385bcddfd44", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d4df06209d23ef5c2b1a72591270faa6a0fe5e/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d4df06209d23ef5c2b1a72591270faa6a0fe5e/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=34d4df06209d23ef5c2b1a72591270faa6a0fe5e", "patch": "@@ -1,3 +1,31 @@\n+2000-08-10  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* class.c (maybe_layout_super_class): Fixed indentation.\n+\t* java-tree.h (CLASS_METHOD_CHECKED_P): New macro.\n+\t(java_check_methods): New function declaration.\n+\t* jcf-parse.c (get_constant): Let `char_len' go up to 3. Use `str'\n+\tinstead of `str_ptr'.\n+\t* jcf-write.c (generate_bytecode_insns): Emit number the of args\n+\tof a `invokeinterface' at the right time.\n+\t* parse.h (WFL_STRIP_BRACKET): New macro.\n+\t(SET_TYPE_FOR_RESOLUTION): Use it.\n+\t* parse.y (build_unresolved_array_type): Reuse `type_or_wfl.'\n+\t(check_class_interface_creation): Don't check for cross package\n+\tinnerclass name clashes.\n+\t(method_header): Behave properly if MDECL is `error_mark_node.'\n+\t(method_declarator): Return `error_mark_node' if bogus current\n+\tclass.\n+\t(resolve_class): Apply WFL_STRIP_BRACKET on `cl' if necessary.\n+\t(resolve_and_layout): New local `decl_type', set and used. Call\n+\tjava_check_methods.\n+\t(java_check_methods): New method.\n+\t(java_layout_classes): Use it.\n+\t(resolve_qualified_expression_name): No EH check necessary in\n+\taccess$<n>.\n+\t(java_complete_lhs): Use VAR_DECL's DECL_INITIAL when evaluating\n+\t`case' statement.\n+\t(patch_assignment): Set DECL_INITIAL on integral final local.\n+\n 2000-08-07  Alexandre Petit-Bianco  <apbianco@cygnus.com\n \n \t* parse.y (build_dot_class_method_invocation): Changed parameter"}, {"sha": "625d8208aa5bcb8959ac3554fefd2502a6df4caf", "filename": "gcc/java/class.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d4df06209d23ef5c2b1a72591270faa6a0fe5e/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d4df06209d23ef5c2b1a72591270faa6a0fe5e/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=34d4df06209d23ef5c2b1a72591270faa6a0fe5e", "patch": "@@ -1748,8 +1748,7 @@ maybe_layout_super_class (super_class, this_class)\n {\n   if (TREE_CODE (super_class) == RECORD_TYPE)\n     {\n-      if (!CLASS_LOADED_P (super_class) \n-\t  && CLASS_FROM_SOURCE_P (super_class))\n+      if (!CLASS_LOADED_P (super_class) && CLASS_FROM_SOURCE_P (super_class))\n \tsafe_layout_class (super_class);\n       if (!CLASS_LOADED_P (super_class))\n \tload_class (super_class, 1);"}, {"sha": "7d2d74fa0bc9d0432e285d8a24852af8e0cbb3f0", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d4df06209d23ef5c2b1a72591270faa6a0fe5e/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d4df06209d23ef5c2b1a72591270faa6a0fe5e/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=34d4df06209d23ef5c2b1a72591270faa6a0fe5e", "patch": "@@ -52,6 +52,7 @@ struct JCF;\n       QUALIFIED_P (in IDENTIFIER_NODE)\n       PRIMARY_P (in EXPR_WITH_FILE_LOCATION)\n       MODIFY_EXPR_FROM_INITIALIZATION_P (in MODIFY_EXPR)\n+      CLASS_METHOD_CHECKED_P (in RECORD_TYPE) \n    3: IS_AN_IMPORT_ON_DEMAND_P (in IDENTIFIER_NODE)\n       RESOLVE_PACKAGE_NAME_P (in EXPR_WITH_FILE_LOCATION)\n       SWITCH_HAS_DEFAULT (in SWITCH_EXPR)\n@@ -788,6 +789,7 @@ extern tree get_boehm_type_descriptor PARAMS ((tree));\n extern unsigned long java_hash_hash_tree_node PARAMS ((hash_table_key));\n extern boolean java_hash_compare_tree_node PARAMS ((hash_table_key, \n \t\t\t\t\t\t    hash_table_key));\n+extern void java_check_methods PARAMS ((tree));\n \n /* We use ARGS_SIZE_RTX to indicate that gcc/expr.h has been included\n    to declare `enum expand_modifier'. */\n@@ -999,6 +1001,8 @@ extern tree *type_map;\n    initialization during its declaration */\n #define MODIFY_EXPR_FROM_INITIALIZATION_P(EXPR) TREE_LANG_FLAG_2 (EXPR)\n \n+#define CLASS_METHOD_CHECKED_P(EXPR) TREE_LANG_FLAG_2 (EXPR)\n+\n /* True if EXPR (a WFL in that case) resolves into an expression name */\n #define RESOLVE_EXPRESSION_NAME_P(WFL) TREE_LANG_FLAG_0 (WFL)\n "}, {"sha": "1962f80ecc2b62d9d5ccb4d7faeaa0a135567fc4", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d4df06209d23ef5c2b1a72591270faa6a0fe5e/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d4df06209d23ef5c2b1a72591270faa6a0fe5e/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=34d4df06209d23ef5c2b1a72591270faa6a0fe5e", "patch": "@@ -341,8 +341,8 @@ get_constant (jcf, index)\n \tfor (str_len = 0; i > 0; str_len++)\n \t  {\n \t    int char_len = UT8_CHAR_LENGTH (*str);\n-\t    if (char_len < 0 || char_len > 2 || char_len > i)\n-\t      fatal (\"bad string constant\");\n+\t    if (char_len < 0 || char_len > 3 || char_len > i)\n+ \t      fatal (\"bad string constant\");\n \t    str += char_len;\n \t    i -= char_len;\n \t  }\n@@ -368,7 +368,7 @@ get_constant (jcf, index)\n \t\tchar_value = (char_value << 6) | (*str++ & 0x3F);\n \t\tbreak;\n \t      case 3:\n-\t\tchar_value = *str_ptr++ & 0x0F;\n+\t\tchar_value = *str++ & 0x0F;\n \t\tchar_value = (char_value << 6) | (*str++ & 0x3F);\n \t\tchar_value = (char_value << 6) | (*str++ & 0x3F);\n \t\tbreak;"}, {"sha": "df50fffd80c4c89e4c9def22a898533ce3efe22c", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d4df06209d23ef5c2b1a72591270faa6a0fe5e/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d4df06209d23ef5c2b1a72591270faa6a0fe5e/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=34d4df06209d23ef5c2b1a72591270faa6a0fe5e", "patch": "@@ -2561,9 +2561,13 @@ generate_bytecode_insns (exp, target, state)\n \t\t  TREE_TYPE (TREE_TYPE (TREE_VALUE (TREE_OPERAND (exp, 1))));\n \t      }\n \t    index = find_methodref_index (&state->cpool, f);\n-\t    if (interface)\n-\t      DECL_CONTEXT (f) = saved_context;\n \t    OP2 (index);\n+\t    if (interface)\n+\t      {\n+\t\tDECL_CONTEXT (f) = saved_context;\n+\t\tOP1 (nargs);\n+\t\tOP1 (0);\n+\t      }\n \t    f = TREE_TYPE (TREE_TYPE (f));\n \t    if (TREE_CODE (f) != VOID_TYPE)\n \t      {\n@@ -2573,11 +2577,6 @@ generate_bytecode_insns (exp, target, state)\n \t\telse\n \t\t  NOTE_PUSH (size);\n \t      }\n-\t    if (interface)\n-\t      {\n-\t\tOP1 (nargs);\n-\t\tOP1 (0);\n-\t      }\n \t    break;\n \t  }\n       }"}, {"sha": "80712370d8dcff075a543f56a1e0063444810c30", "filename": "gcc/java/parse.h", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d4df06209d23ef5c2b1a72591270faa6a0fe5e/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d4df06209d23ef5c2b1a72591270faa6a0fe5e/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=34d4df06209d23ef5c2b1a72591270faa6a0fe5e", "patch": "@@ -535,27 +535,50 @@ typedef struct _jdeplist {\n    java.lang.Object.  */\n #define SET_TYPE_FOR_RESOLUTION(TYPE, SAVE, CHAIN)\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n-    tree returned_type;\t\t\t\t\t\t\t\\\n+    tree _returned_type;\t\t\t\t\t\t\\\n     (CHAIN) = 0;\t\t\t\t\t\t\t\\\n     if (TREE_TYPE (GET_CPC ()) == object_type_node\t\t\t\\\n-\t&& TREE_CODE (TYPE) == EXPR_WITH_FILE_LOCATION \t\t\t\\\n+\t&& TREE_CODE (TYPE) == EXPR_WITH_FILE_LOCATION\t\t\t\\\n \t&& EXPR_WFL_NODE (TYPE) == unqualified_object_id_node)\t\t\\\n       (TYPE) = object_type_node;\t\t\t\t\t\\\n     else\t\t\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n-\tif (unresolved_type_p (type, &returned_type))\t\t\t\\\n+\tif (unresolved_type_p (type, &_returned_type))\t\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n-\t    if (returned_type)\t\t\t\t\t\t\\\n-\t      (TYPE) = returned_type;\t\t\t\t\t\\\n+\t    if (_returned_type)\t\t\t\t\t\t\\\n+\t      (TYPE) = _returned_type;\t\t\t\t\t\\\n \t    else\t\t\t\t\t\t\t\\\n \t      {\t\t\t\t\t\t\t\t\\\n-\t\t(SAVE) = (TYPE);\t\t\t\t\t\\\n+\t        tree _type;\t\t\t\t\t\t\\\n+                WFL_STRIP_BRACKET (_type, TYPE);\t\t\t\\\n+\t\t(SAVE) = (_type);\t\t\t\t\t\\\n \t\t(TYPE) = obtain_incomplete_type (TYPE);\t\t\t\\\n \t\tCHAIN = 1;\t\t\t\t\t\t\\\n \t      }\t\t\t\t\t\t\t\t\\\n \t  }\t\t\t\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n   }\n+\n+#define WFL_STRIP_BRACKET(TARGET, TYPE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  tree __type = (TYPE);\t\t\t\t\t\t\t\\\n+  if (TYPE && TREE_CODE (TYPE) == EXPR_WITH_FILE_LOCATION)\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      tree _node = EXPR_WFL_NODE (TYPE);\t\t\t\t\\\n+      const char *_ptr = IDENTIFIER_POINTER (_node);\t\t\t\\\n+      const char *_ref = _ptr;\t\t\t\t\t\t\\\n+      while (_ptr[0] == '[')\t\t\t\t\t\t\\\n+\t  _ptr++;\t\t\t\t\t\t\t\\\n+      if (_ref != _ptr)\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  tree _new = copy_node (TYPE);\t\t\t\t\t\\\n+\t  EXPR_WFL_NODE (_new) = get_identifier (_ptr);\t\t\t\\\n+\t  __type = _new;\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  (TARGET) = __type;\t\t\t\t\t\t\t\\\n+}\n+\n /* Promote a type if it won't be registered as a patch */\n #define PROMOTE_RECORD_IF_COMPLETE(TYPE, IS_INCOMPLETE)\t\t\\\n   {\t\t\t\t\t\t\t\t\\"}, {"sha": "56edc6c0b9333bbaacc18636290c55bd50b186fa", "filename": "gcc/java/parse.y", "status": "modified", "additions": 63, "deletions": 19, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d4df06209d23ef5c2b1a72591270faa6a0fe5e/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d4df06209d23ef5c2b1a72591270faa6a0fe5e/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=34d4df06209d23ef5c2b1a72591270faa6a0fe5e", "patch": "@@ -3265,10 +3265,8 @@ build_unresolved_array_type (type_or_wfl)\n \t\t IDENTIFIER_POINTER (EXPR_WFL_NODE (type_or_wfl)),\n \t\t IDENTIFIER_LENGTH (EXPR_WFL_NODE (type_or_wfl)));\n   ptr = obstack_finish (&temporary_obstack);\n-  return build_expr_wfl (get_identifier (ptr),\n-\t\t\t EXPR_WFL_FILENAME (type_or_wfl),\n-\t\t\t EXPR_WFL_LINENO (type_or_wfl),\n-\t\t\t EXPR_WFL_COLNO (type_or_wfl));\n+  EXPR_WFL_NODE (type_or_wfl) = get_identifier (ptr);\n+  return type_or_wfl;\n }\n \n static void\n@@ -3303,7 +3301,8 @@ check_class_interface_creation (is_interface, flags, raw_name, qualified_name, d\n        - Can't be imported by a single type import\n        - Can't already exists in the package */\n   if (IS_A_SINGLE_IMPORT_CLASSFILE_NAME_P (raw_name)\n-      && (node = find_name_in_single_imports (raw_name)))\n+      && (node = find_name_in_single_imports (raw_name))\n+      && !CPC_INNER_P ())\n     {\n       parse_error_context \n \t(cl, \"%s name `%s' clashes with imported type `%s'\",\n@@ -4260,14 +4259,18 @@ method_header (flags, type, mdecl, throws)\n      int flags;\n      tree type, mdecl, throws;\n {\n-  tree meth = TREE_VALUE (mdecl);\n-  tree id = TREE_PURPOSE (mdecl);\n   tree type_wfl = NULL_TREE;\n   tree meth_name = NULL_TREE;\n   tree current, orig_arg, this_class = NULL;\n+  tree id, meth;\n   int saved_lineno;\n   int constructor_ok = 0, must_chain;\n   int count;\n+\n+  if (mdecl == error_mark_node)\n+    return error_mark_node;\n+  meth = TREE_VALUE (mdecl);\n+  id = TREE_PURPOSE (mdecl);\n   \n   check_modifiers_consistency (flags);\n \n@@ -4665,6 +4668,9 @@ method_declarator (id, list)\n \n   patch_stage = JDEP_NO_PATCH;\n \n+  if (GET_CPC () == error_mark_node)\n+    return error_mark_node;\n+\n   /* If we're dealing with an inner class constructor, we hide the\n      this$<n> decl in the name field of its parameter declaration.  We\n      also might have to hide the outer context local alias\n@@ -5391,7 +5397,10 @@ resolve_class (enclosing, class_type, decl, cl)\n   while (name[0] == '[')\n     name++;\n   if (base != name)\n-    TYPE_NAME (class_type) = get_identifier (name);\n+    {\n+      TYPE_NAME (class_type) = get_identifier (name);\n+      WFL_STRIP_BRACKET (cl, cl);\n+    }\n \n   /* 2- Resolve the bare type */\n   if (!(resolved_type_decl = do_resolve_class (enclosing, class_type, \n@@ -5562,7 +5571,7 @@ resolve_and_layout (something, cl)\n      tree something;\n      tree cl;\n {\n-  tree decl;\n+  tree decl, decl_type;\n \n   /* Don't do that on the current class */\n   if (something == current_class)\n@@ -5605,13 +5614,14 @@ resolve_and_layout (something, cl)\n     return NULL_TREE;\n \n   /* Resolve and layout if necessary */\n-  layout_class_methods (TREE_TYPE (decl));\n-  /* Check methods, but only once */\n-  if (CLASS_FROM_SOURCE_P (TREE_TYPE (decl)) \n-      && !CLASS_LOADED_P (TREE_TYPE (decl)))\n-    CHECK_METHODS (decl);\n-  if (TREE_TYPE (decl) != current_class && !CLASS_LOADED_P (TREE_TYPE (decl)))\n-    safe_layout_class (TREE_TYPE (decl));\n+  decl_type = TREE_TYPE (decl);\n+  layout_class_methods (decl_type);\n+  /* Check methods */\n+  if (CLASS_FROM_SOURCE_P (decl_type))\n+    java_check_methods (decl);\n+  /* Layout the type if necessary */ \n+  if (decl_type != current_class && !CLASS_LOADED_P (decl_type))\n+    safe_layout_class (decl_type);\n \n   return decl;\n }\n@@ -5957,6 +5967,23 @@ check_method_types_complete (decl)\n   return 1;\n }\n \n+/* Visible interface to check methods contained in CLASS_DECL */\n+\n+void\n+java_check_methods (class_decl)\n+     tree class_decl;\n+{\n+  if (CLASS_METHOD_CHECKED_P (TREE_TYPE (class_decl)))\n+    return;\n+\n+  if (CLASS_INTERFACE (class_decl))\n+    java_check_abstract_methods (class_decl);\n+  else\n+    java_check_regular_methods (class_decl);\n+  \n+  CLASS_METHOD_CHECKED_P (TREE_TYPE (class_decl)) = 1;\n+}\n+\n /* Check all the methods of CLASS_DECL. Methods are first completed\n    then checked according to regular method existance rules.  If no\n    constructor for CLASS_DECL were encountered, then build its\n@@ -7288,7 +7315,7 @@ java_layout_classes ()\n   /* Then check the methods of all parsed classes */\n   for (current = ctxp->gclass_list; current; current = TREE_CHAIN (current))\n     if (CLASS_FROM_SOURCE_P (TREE_TYPE (TREE_VALUE (current))))\n-      CHECK_METHODS (TREE_VALUE (current));\n+      java_check_methods (TREE_VALUE (current));\n   java_parse_abort_on_error ();\n \n   for (current = ctxp->gclass_list; current; current = TREE_CHAIN (current))\n@@ -8951,8 +8978,10 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t     instantiation using a primary qualified by a `new' */\n \t  RESTORE_THIS_AND_CURRENT_CLASS;\n \n-\t  /* EH check */\n-\t  if (location)\n+\t  /* EH check. No check on access$<n> functions */\n+\t  if (location \n+\t      && !OUTER_FIELD_ACCESS_IDENTIFIER_P \n+\t            (DECL_NAME (current_function_decl)))\n \t    check_thrown_exceptions (location, ret_decl);\n \n \t  /* If the previous call was static and this one is too,\n@@ -10988,6 +11017,8 @@ java_complete_lhs (node)\n       /* Multiple instance of a case label bearing the same\n \t value is checked during code generation. The case\n \t expression is allright so far. */\n+      if (TREE_CODE (cn) == VAR_DECL)\n+\tcn = DECL_INITIAL (cn);\n       TREE_OPERAND (node, 0) = cn;\n       TREE_TYPE (node) = void_type_node;\n       CAN_COMPLETE_NORMALLY (node) = 1;\n@@ -12037,6 +12068,19 @@ patch_assignment (node, wfl_op1, wfl_op2)\n \t}\n     }\n \n+  /* Final locals can be used as case values in switch\n+     statement. Prepare them for this eventuality. */\n+  if (TREE_CODE (lvalue) == VAR_DECL \n+      && LOCAL_FINAL (lvalue)\n+      && TREE_CONSTANT (new_rhs)\n+      && IDENTIFIER_LOCAL_VALUE (DECL_NAME (lvalue))\n+      && JINTEGRAL_TYPE_P (TREE_TYPE (lvalue))\n+      )\n+    {\n+      TREE_CONSTANT (lvalue) = 1;\n+      DECL_INITIAL (lvalue) = new_rhs;\n+    }\n+\n   TREE_OPERAND (node, 0) = lvalue;\n   TREE_OPERAND (node, 1) = new_rhs;\n   TREE_TYPE (node) = lhs_type;"}]}