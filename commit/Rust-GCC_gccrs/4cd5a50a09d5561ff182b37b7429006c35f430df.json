{"sha": "4cd5a50a09d5561ff182b37b7429006c35f430df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNkNWE1MGEwOWQ1NTYxZmYxODJiMzdiNzQyOTAwNmMzNWY0MzBkZg==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2009-12-02T15:49:20Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2009-12-02T15:49:20Z"}, "message": "re PR c++/29917 (%s substituted with actual words can not be translated correctly (op_error))\n\n2009-12-02  Paolo Bonzini  <bonzini@gnu.org>\n\t    Shujing Zhao  <pearly.zhao@oracle.com>\n\n\tPR c++/29917\n\t* call.c (op_error): Accept a boolean to indicate no match/ambiguous\n\tmatch, instead of a string. Callers adjusted.\n\n\tPR c++/34836\n\t* cp-tree.h (readonly_error_kind): New type.\n\t(readonly_error): Adjust prototype with new argument.\n\t* typeck2.c (readonly_error): Accept readonly_error_kind as argument\n\tand add macro ERROR_FOR_ASSIGNMENT to emit diagnostics.\n\t* semantics.c (finish_asm_stmt): Adjust readonly_error call.\n\t* typeck.c (cp_build_unary_op, cp_build_modify_expr): Likewise.\n\n\t* decl.c (grokparms, grok_op_properties): Put the diagnostics in full\n\tsentences for easy translation and wrap the diagnostics into G_() when\n\tneeded.\n\t(create_array_type_for_decl): Likewise.\n\t* pt.c (tsubst): Likewise.\n\t* typeck2.c (cp_build_unary_op): Wrap diagnostic into _().\n\t* rtti.c (build_dynamic_cast_1): Likewise.\n\nCo-Authored-By: Shujing Zhao <pearly.zhao@oracle.com>\n\nFrom-SVN: r154915", "tree": {"sha": "eb09280053de717f24d7f3580c21560495b034ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb09280053de717f24d7f3580c21560495b034ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4cd5a50a09d5561ff182b37b7429006c35f430df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cd5a50a09d5561ff182b37b7429006c35f430df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cd5a50a09d5561ff182b37b7429006c35f430df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cd5a50a09d5561ff182b37b7429006c35f430df/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2f697bc476c63bcf039cd8465b8eb9113406a712", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f697bc476c63bcf039cd8465b8eb9113406a712", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f697bc476c63bcf039cd8465b8eb9113406a712"}], "stats": {"total": 353, "additions": 267, "deletions": 86}, "files": [{"sha": "edecdaaab14fd7b684e091d917c9a96f8b1245d5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd5a50a09d5561ff182b37b7429006c35f430df/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd5a50a09d5561ff182b37b7429006c35f430df/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4cd5a50a09d5561ff182b37b7429006c35f430df", "patch": "@@ -1,3 +1,26 @@\n+2009-12-02  Paolo Bonzini  <bonzini@gnu.org>\n+\t    Shujing Zhao  <pearly.zhao@oracle.com>\n+\n+\tPR c++/29917\n+\t* call.c (op_error): Accept a boolean to indicate no match/ambiguous\n+\tmatch, instead of a string. Callers adjusted.\n+\n+\tPR c++/34836\n+\t* cp-tree.h (readonly_error_kind): New type.\n+\t(readonly_error): Adjust prototype with new argument.\n+\t* typeck2.c (readonly_error): Accept readonly_error_kind as argument\n+\tand add macro ERROR_FOR_ASSIGNMENT to emit diagnostics.\n+\t* semantics.c (finish_asm_stmt): Adjust readonly_error call.\n+\t* typeck.c (cp_build_unary_op, cp_build_modify_expr): Likewise.\n+\n+\t* decl.c (grokparms, grok_op_properties): Put the diagnostics in full\n+\tsentences for easy translation and wrap the diagnostics into G_() when\n+\tneeded.\n+\t(create_array_type_for_decl): Likewise.\n+\t* pt.c (tsubst): Likewise.\n+\t* typeck2.c (cp_build_unary_op): Wrap diagnostic into _().\n+\t* rtti.c (build_dynamic_cast_1): Likewise.\n+\n 2009-12-02  Jakub Jelinek  <jakub@redhat.com>\n \n \t* g++spec.c (lang_specific_driver): Remove unused saw_verbose_flag"}, {"sha": "913993ac36f9dbcfbf27e21e4135f8af35eaca75", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd5a50a09d5561ff182b37b7429006c35f430df/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd5a50a09d5561ff182b37b7429006c35f430df/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=4cd5a50a09d5561ff182b37b7429006c35f430df", "patch": "@@ -254,7 +254,8 @@ cp/cp-lang.o: cp/cp-lang.c $(CXX_TREE_H) $(TM_H) toplev.h debug.h langhooks.h \\\n cp/decl.o: cp/decl.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) cp/decl.h \\\n   output.h $(EXPR_H) except.h toplev.h $(HASHTAB_H) $(RTL_H) \\\n   cp/operators.def $(TM_P_H) $(TREE_INLINE_H) $(DIAGNOSTIC_H) $(C_PRAGMA_H) \\\n-  debug.h gt-cp-decl.h $(TIMEVAR_H) $(TREE_FLOW_H) $(TARGET_H) $(PLUGIN_H)\n+  debug.h gt-cp-decl.h $(TIMEVAR_H) $(TREE_FLOW_H) $(TARGET_H) $(PLUGIN_H) \\\n+  intl.h\n cp/decl2.o: cp/decl2.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) cp/decl.h $(EXPR_H) \\\n   output.h except.h toplev.h $(RTL_H) $(C_COMMON_H) gt-cp-decl2.h $(CGRAPH_H) \\\n   $(C_PRAGMA_H) $(TREE_DUMP_H) intl.h $(TARGET_H) $(GIMPLE_H) $(POINTER_SET_H)\n@@ -263,7 +264,7 @@ cp/cp-objcp-common.o : cp/cp-objcp-common.c $(CONFIG_H) $(SYSTEM_H) \\\n   langhooks.h $(LANGHOOKS_DEF_H) $(DIAGNOSTIC_H) debug.h \\\n   $(CXX_PRETTY_PRINT_H) cp/cp-objcp-common.h gt-cp-cp-objcp-common.h\n cp/typeck2.o: cp/typeck2.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) toplev.h output.h \\\n-  $(TM_P_H) $(DIAGNOSTIC_H) gt-cp-typeck2.h $(REAL_H)\n+  $(TM_P_H) $(DIAGNOSTIC_H) gt-cp-typeck2.h $(REAL_H) intl.h\n cp/typeck.o: cp/typeck.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) $(RTL_H) $(EXPR_H) \\\n   toplev.h $(DIAGNOSTIC_H) convert.h $(C_COMMON_H) $(TARGET_H)\n cp/class.o: cp/class.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) toplev.h $(RTL_H) \\\n@@ -284,7 +285,7 @@ cp/tree.o: cp/tree.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) toplev.h $(RTL_H) \\\n   $(TARGET_H) debug.h $(TREE_FLOW_H) $(CGRAPH_H)\n cp/ptree.o: cp/ptree.c $(CXX_TREE_H) $(TM_H)\n cp/rtti.o: cp/rtti.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) toplev.h convert.h \\\n-  $(TARGET_H) $(C_PRAGMA_H) gt-cp-rtti.h\n+  $(TARGET_H) $(C_PRAGMA_H) gt-cp-rtti.h intl.h\n cp/except.o: cp/except.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) $(RTL_H) except.h \\\n   toplev.h cp/cfns.h $(EXPR_H) libfuncs.h $(TREE_INLINE_H) $(TARGET_H)\n cp/expr.o: cp/expr.c $(CXX_TREE_H) $(TM_H) $(RTL_H) $(FLAGS_H) $(EXPR_H) \\"}, {"sha": "a6041f5596fbc9c9233e0341ba9da2cfbfbc3c8f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 42, "deletions": 15, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd5a50a09d5561ff182b37b7429006c35f430df/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd5a50a09d5561ff182b37b7429006c35f430df/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=4cd5a50a09d5561ff182b37b7429006c35f430df", "patch": "@@ -144,7 +144,7 @@ static tree build_java_interface_fn_ref (tree, tree);\n static tree convert_like_real (conversion *, tree, tree, int, int, bool,\n \t\t\t       bool, tsubst_flags_t);\n static void op_error (enum tree_code, enum tree_code, tree, tree,\n-\t\t      tree, const char *);\n+\t\t      tree, bool);\n static VEC(tree,gc) *resolve_args (VEC(tree,gc) *);\n static struct z_candidate *build_user_type_conversion_1 (tree, tree, int);\n static void print_z_candidate (const char *, struct z_candidate *);\n@@ -3489,7 +3489,7 @@ build_op_call (tree obj, VEC(tree,gc) **args, tsubst_flags_t complain)\n \n static void\n op_error (enum tree_code code, enum tree_code code2,\n-\t  tree arg1, tree arg2, tree arg3, const char *problem)\n+\t  tree arg1, tree arg2, tree arg3, bool match)\n {\n   const char *opname;\n \n@@ -3501,31 +3501,58 @@ op_error (enum tree_code code, enum tree_code code2,\n   switch (code)\n     {\n     case COND_EXPR:\n-      error (\"%s for ternary %<operator?:%> in %<%E ? %E : %E%>\",\n-\t     problem, arg1, arg2, arg3);\n+      if (match)\n+        error (\"ambiguous overload for ternary %<operator?:%> \"\n+               \"in %<%E ? %E : %E%>\", arg1, arg2, arg3);\n+      else\n+        error (\"no match for ternary %<operator?:%> \"\n+               \"in %<%E ? %E : %E%>\", arg1, arg2, arg3);\n       break;\n \n     case POSTINCREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n-      error (\"%s for %<operator%s%> in %<%E%s%>\", problem, opname, arg1, opname);\n+      if (match)\n+        error (\"ambiguous overload for %<operator%s%> in %<%E%s%>\",\n+               opname, arg1, opname);\n+      else\n+        error (\"no match for %<operator%s%> in %<%E%s%>\", \n+               opname, arg1, opname);\n       break;\n \n     case ARRAY_REF:\n-      error (\"%s for %<operator[]%> in %<%E[%E]%>\", problem, arg1, arg2);\n+      if (match)\n+        error (\"ambiguous overload for %<operator[]%> in %<%E[%E]%>\", \n+               arg1, arg2);\n+      else\n+        error (\"no match for %<operator[]%> in %<%E[%E]%>\", \n+               arg1, arg2);\n       break;\n \n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n-      error (\"%s for %qs in %<%s %E%>\", problem, opname, opname, arg1);\n+      if (match)\n+        error (\"ambiguous overload for %qs in %<%s %E%>\", \n+               opname, opname, arg1);\n+      else\n+        error (\"no match for %qs in %<%s %E%>\",\n+               opname, opname, arg1);\n       break;\n \n     default:\n       if (arg2)\n-\terror (\"%s for %<operator%s%> in %<%E %s %E%>\",\n-\t       problem, opname, arg1, opname, arg2);\n+        if (match)\n+          error (\"ambiguous overload for %<operator%s%> in %<%E %s %E%>\",\n+                  opname, arg1, opname, arg2);\n+        else\n+          error (\"no match for %<operator%s%> in %<%E %s %E%>\",\n+                 opname, arg1, opname, arg2);\n       else\n-\terror (\"%s for %<operator%s%> in %<%s%E%>\",\n-\t       problem, opname, opname, arg1);\n+        if (match)\n+          error (\"ambiguous overload for %<operator%s%> in %<%s%E%>\",\n+                 opname, opname, arg1);\n+        else\n+          error (\"no match for %<operator%s%> in %<%s%E%>\",\n+                 opname, opname, arg1);\n       break;\n     }\n }\n@@ -3852,7 +3879,7 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3,\n \t{\n           if (complain & tf_error)\n             {\n-              op_error (COND_EXPR, NOP_EXPR, arg1, arg2, arg3, \"no match\");\n+              op_error (COND_EXPR, NOP_EXPR, arg1, arg2, arg3, FALSE);\n               print_z_candidates (candidates);\n             }\n \t  return error_mark_node;\n@@ -3862,7 +3889,7 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3,\n \t{\n           if (complain & tf_error)\n             {\n-              op_error (COND_EXPR, NOP_EXPR, arg1, arg2, arg3, \"no match\");\n+              op_error (COND_EXPR, NOP_EXPR, arg1, arg2, arg3, FALSE);\n               print_z_candidates (candidates);\n             }\n \t  return error_mark_node;\n@@ -4330,7 +4357,7 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \t\t  {\n \t\t    /* ... Otherwise, report the more generic\n \t\t       \"no matching operator found\" error */\n-\t\t    op_error (code, code2, arg1, arg2, arg3, \"no match\");\n+\t\t    op_error (code, code2, arg1, arg2, arg3, FALSE);\n \t\t    print_z_candidates (candidates);\n \t\t  }\n \t    }\n@@ -4345,7 +4372,7 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \t{\n \t  if ((flags & LOOKUP_COMPLAIN) && (complain & tf_error))\n \t    {\n-\t      op_error (code, code2, arg1, arg2, arg3, \"ambiguous overload\");\n+\t      op_error (code, code2, arg1, arg2, arg3, TRUE);\n \t      print_z_candidates (candidates);\n \t    }\n \t  result = error_mark_node;"}, {"sha": "dc563e2c15c946552e479262bfe43b5fb26a663c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd5a50a09d5561ff182b37b7429006c35f430df/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd5a50a09d5561ff182b37b7429006c35f430df/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4cd5a50a09d5561ff182b37b7429006c35f430df", "patch": "@@ -415,6 +415,19 @@ typedef enum composite_pointer_operation\n   CPO_CONDITIONAL_EXPR\n } composite_pointer_operation;\n \n+/* The various readonly error string used by readonly_error.  */\n+typedef enum readonly_error_kind\n+{\n+  /* assignment */\n+  REK_ASSIGNMENT,\n+  /* assignment (via 'asm' output) */\n+  REK_ASSIGNMENT_ASM,\n+  /* increment */\n+  REK_INCREMENT,\n+  /* decrement */\n+  REK_DECREMENT\n+} readonly_error_kind;\n+\n /* Macros for access to language-specific slots in an identifier.  */\n \n #define IDENTIFIER_NAMESPACE_BINDINGS(NODE)\t\\\n@@ -5360,7 +5373,7 @@ extern void cxx_incomplete_type_error\t\t(const_tree, const_tree);\n   (cxx_incomplete_type_diagnostic ((V), (T), DK_ERROR))\n extern tree error_not_base_type\t\t\t(tree, tree);\n extern tree binfo_or_else\t\t\t(tree, tree);\n-extern void readonly_error\t\t\t(tree, const char *);\n+extern void readonly_error\t\t\t(tree, readonly_error_kind);\n extern void complete_type_check_abstract\t(tree);\n extern int abstract_virtuals_error\t\t(tree, tree);\n "}, {"sha": "5b37ef7e710d4b0813c398861d41d14ca416cd6a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 47, "deletions": 27, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd5a50a09d5561ff182b37b7429006c35f430df/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd5a50a09d5561ff182b37b7429006c35f430df/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=4cd5a50a09d5561ff182b37b7429006c35f430df", "patch": "@@ -39,6 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cp-tree.h\"\n #include \"tree-inline.h\"\n #include \"decl.h\"\n+#include \"intl.h\"\n #include \"output.h\"\n #include \"except.h\"\n #include \"toplev.h\"\n@@ -7431,40 +7432,46 @@ create_array_type_for_decl (tree name, tree type, tree size)\n   /* Assume that everything will go OK.  */\n   error_msg = NULL;\n \n-  /* There are some types which cannot be array elements.  */\n+  /* If there are some types which cannot be array elements,\n+     issue an error-message and return.  */\n   switch (TREE_CODE (type))\n     {\n     case VOID_TYPE:\n-      error_msg = \"array of void\";\n+      if (name)\n+        error (\"declaration of %qD as array of void\", name);\n+      else\n+        error (\"creating array of void\");\n+      return error_mark_node;\n       break;\n \n     case FUNCTION_TYPE:\n-      error_msg = \"array of functions\";\n+      if (name)\n+        error (\"declaration of %qD as array of functions\", name);\n+      else\n+        error (\"creating array of functions\");\n+      return error_mark_node;\n       break;\n \n     case REFERENCE_TYPE:\n-      error_msg = \"array of references\";\n+      if (name)\n+        error (\"declaration of %qD as array of references\", name);\n+      else\n+        error (\"creating array of references\");\n+      return error_mark_node;\n       break;\n \n     case METHOD_TYPE:\n-      error_msg = \"array of function members\";\n+      if (name)\n+        error (\"declaration of %qD as array of function members\", name);\n+      else\n+        error (\"creating array of function members\");\n+      return error_mark_node;\n       break;\n \n     default:\n       break;\n     }\n \n-  /* If something went wrong, issue an error-message and return.  */\n-  if (error_msg)\n-    {\n-      if (name)\n-\terror (\"declaration of %qD as %s\", name, error_msg);\n-      else\n-\terror (\"creating %s\", error_msg);\n-\n-      return error_mark_node;\n-    }\n-\n   /* [dcl.array]\n \n      The constant expressions that specify the bounds of the arrays\n@@ -9904,9 +9911,12 @@ grokparms (tree parmlist, tree *parms)\n \t\t  t = TREE_TYPE (t);\n \t\t}\n \t      if (TREE_CODE (t) == ARRAY_TYPE)\n-\t\terror (\"parameter %qD includes %s to array of unknown \"\n-\t\t       \"bound %qT\",\n-\t\t       decl, ptr ? \"pointer\" : \"reference\", t);\n+\t\terror (ptr\n+                       ? G_(\"parameter %qD includes pointer to array of \"\n+                            \"unknown bound %qT\")\n+                       : G_(\"parameter %qD includes reference to array of \"\n+                            \"unknown bound %qT\"),\n+                       decl, t);\n \t    }\n \n \t  if (any_error)\n@@ -10353,28 +10363,38 @@ grok_op_properties (tree decl, bool complain)\n \t{\n \t  tree t = TREE_TYPE (name);\n \t  int ref = (TREE_CODE (t) == REFERENCE_TYPE);\n-\t  const char *what = 0;\n \n \t  if (ref)\n \t    t = TYPE_MAIN_VARIANT (TREE_TYPE (t));\n \n \t  if (TREE_CODE (t) == VOID_TYPE)\n-\t    what = \"void\";\n+            warning (OPT_Wconversion,\n+                     ref\n+                     ? G_(\"conversion to a reference to void \"\n+                          \"will never use a type conversion operator\")\n+                     : G_(\"conversion to void \"\n+                          \"will never use a type conversion operator\"));\n \t  else if (class_type)\n \t    {\n \t      if (t == class_type)\n-\t\twhat = \"the same type\";\n+                warning (OPT_Wconversion,\n+                     ref\n+                     ? G_(\"conversion to a reference to the same type \"\n+                          \"will never use a type conversion operator\")\n+                     : G_(\"conversion to the same type \"\n+                          \"will never use a type conversion operator\"));\t\t\n \t      /* Don't force t to be complete here.  */\n \t      else if (MAYBE_CLASS_TYPE_P (t)\n \t\t       && COMPLETE_TYPE_P (t)\n \t\t       && DERIVED_FROM_P (t, class_type))\n-\t\twhat = \"a base class\";\n+                 warning (OPT_Wconversion,\n+                          ref\n+                          ? G_(\"conversion to a reference to a base class \"\n+                               \"will never use a type conversion operator\")\n+                          : G_(\"conversion to a base class \"\n+                               \"will never use a type conversion operator\"));\t\t\n \t    }\n \n-\t  if (what)\n-\t    warning (OPT_Wconversion, \"conversion to %s%s will never use a type \"\n-\t\t     \"conversion operator\",\n-\t\t     ref ? \"a reference to \" : \"\", what);\n \t}\n \n       if (operator_code == COND_EXPR)"}, {"sha": "97a2f807b8901200653d12b67375110aea26b52a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd5a50a09d5561ff182b37b7429006c35f430df/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd5a50a09d5561ff182b37b7429006c35f430df/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4cd5a50a09d5561ff182b37b7429006c35f430df", "patch": "@@ -10041,10 +10041,10 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t      {\n \t\tif (TREE_CODE (type) == VOID_TYPE)\n \t\t  error (\"forming reference to void\");\n-\t\telse\n-\t\t  error (\"forming %s to reference type %qT\",\n-\t\t\t (code == POINTER_TYPE) ? \"pointer\" : \"reference\",\n-\t\t\t type);\n+               else if (code == POINTER_TYPE)\n+                 error (\"forming pointer to reference type %qT\", type);\n+               else\n+\t\t  error (\"forming reference to reference type %qT\", type);\n \t\tlast_loc = input_location;\n \t      }\n "}, {"sha": "7378f89fd1aaafe227f56619d95803bd656fe75d", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd5a50a09d5561ff182b37b7429006c35f430df/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd5a50a09d5561ff182b37b7429006c35f430df/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=4cd5a50a09d5561ff182b37b7429006c35f430df", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"config.h\"\n #include \"system.h\"\n+#include \"intl.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"tree.h\"\n@@ -525,18 +526,18 @@ build_dynamic_cast_1 (tree type, tree expr, tsubst_flags_t complain)\n     case REFERENCE_TYPE:\n       if (! MAYBE_CLASS_TYPE_P (TREE_TYPE (type)))\n \t{\n-\t  errstr = \"target is not pointer or reference to class\";\n+\t  errstr = _(\"target is not pointer or reference to class\");\n \t  goto fail;\n \t}\n       if (!COMPLETE_TYPE_P (complete_type (TREE_TYPE (type))))\n \t{\n-\t  errstr = \"target is not pointer or reference to complete type\";\n+\t  errstr = _(\"target is not pointer or reference to complete type\");\n \t  goto fail;\n \t}\n       break;\n \n     default:\n-      errstr = \"target is not pointer or reference\";\n+      errstr = _(\"target is not pointer or reference\");\n       goto fail;\n     }\n \n@@ -547,17 +548,17 @@ build_dynamic_cast_1 (tree type, tree expr, tsubst_flags_t complain)\n \n       if (TREE_CODE (exprtype) != POINTER_TYPE)\n \t{\n-\t  errstr = \"source is not a pointer\";\n+\t  errstr = _(\"source is not a pointer\");\n \t  goto fail;\n \t}\n       if (! MAYBE_CLASS_TYPE_P (TREE_TYPE (exprtype)))\n \t{\n-\t  errstr = \"source is not a pointer to class\";\n+\t  errstr = _(\"source is not a pointer to class\");\n \t  goto fail;\n \t}\n       if (!COMPLETE_TYPE_P (complete_type (TREE_TYPE (exprtype))))\n \t{\n-\t  errstr = \"source is a pointer to incomplete type\";\n+\t  errstr = _(\"source is a pointer to incomplete type\");\n \t  goto fail;\n \t}\n     }\n@@ -570,12 +571,12 @@ build_dynamic_cast_1 (tree type, tree expr, tsubst_flags_t complain)\n \n       if (! MAYBE_CLASS_TYPE_P (TREE_TYPE (exprtype)))\n \t{\n-\t  errstr = \"source is not of class type\";\n+\t  errstr = _(\"source is not of class type\");\n \t  goto fail;\n \t}\n       if (!COMPLETE_TYPE_P (complete_type (TREE_TYPE (exprtype))))\n \t{\n-\t  errstr = \"source is of incomplete class type\";\n+\t  errstr = _(\"source is of incomplete class type\");\n \t  goto fail;\n \t}\n \n@@ -588,7 +589,7 @@ build_dynamic_cast_1 (tree type, tree expr, tsubst_flags_t complain)\n   if (!at_least_as_qualified_p (TREE_TYPE (type),\n \t\t\t\tTREE_TYPE (exprtype)))\n     {\n-      errstr = \"conversion casts away constness\";\n+      errstr = _(\"conversion casts away constness\");\n       goto fail;\n     }\n \n@@ -748,7 +749,7 @@ build_dynamic_cast_1 (tree type, tree expr, tsubst_flags_t complain)\n \t}\n     }\n   else\n-    errstr = \"source type is not polymorphic\";\n+    errstr = _(\"source type is not polymorphic\");\n \n  fail:\n   if (complain & tf_error)"}, {"sha": "b3821087ac79a17cf7e5066a0996e0de5ca2f030", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd5a50a09d5561ff182b37b7429006c35f430df/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd5a50a09d5561ff182b37b7429006c35f430df/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=4cd5a50a09d5561ff182b37b7429006c35f430df", "patch": "@@ -1254,7 +1254,7 @@ finish_asm_stmt (int volatile_p, tree string, tree output_operands,\n \t\t     effectively const.  */\n \t\t  || (CLASS_TYPE_P (TREE_TYPE (operand))\n \t\t      && C_TYPE_FIELDS_READONLY (TREE_TYPE (operand)))))\n-\t    readonly_error (operand, \"assignment (via 'asm' output)\");\n+\t    readonly_error (operand, REK_ASSIGNMENT_ASM);\n \n \t  constraint = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (t)));\n \t  oconstraints[i] = constraint;"}, {"sha": "36c0b8a9bf8dec8360cbc9f05de39cf67b096f30", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd5a50a09d5561ff182b37b7429006c35f430df/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd5a50a09d5561ff182b37b7429006c35f430df/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=4cd5a50a09d5561ff182b37b7429006c35f430df", "patch": "@@ -4462,8 +4462,8 @@ cp_build_unary_op (enum tree_code code, tree xarg, int noconvert,\n \targ = build_expr_type_conversion (flags, arg, true);\n \tif (!arg)\n \t  errstring = (code == NEGATE_EXPR\n-\t\t       ? \"wrong type argument to unary minus\"\n-\t\t       : \"wrong type argument to unary plus\");\n+\t\t       ? _(\"wrong type argument to unary minus\")\n+\t\t       : _(\"wrong type argument to unary plus\"));\n \telse\n \t  {\n \t    if (!noconvert && CP_INTEGRAL_TYPE_P (TREE_TYPE (arg)))\n@@ -4486,22 +4486,22 @@ cp_build_unary_op (enum tree_code code, tree xarg, int noconvert,\n       else if (!(arg = build_expr_type_conversion (WANT_INT | WANT_ENUM\n \t\t\t\t\t\t   | WANT_VECTOR,\n \t\t\t\t\t\t   arg, true)))\n-\terrstring = \"wrong type argument to bit-complement\";\n+\terrstring = _(\"wrong type argument to bit-complement\");\n       else if (!noconvert && CP_INTEGRAL_TYPE_P (TREE_TYPE (arg)))\n \targ = perform_integral_promotions (arg);\n       break;\n \n     case ABS_EXPR:\n       if (!(arg = build_expr_type_conversion (WANT_ARITH | WANT_ENUM, arg, true)))\n-\terrstring = \"wrong type argument to abs\";\n+\terrstring = _(\"wrong type argument to abs\");\n       else if (!noconvert)\n \targ = default_conversion (arg);\n       break;\n \n     case CONJ_EXPR:\n       /* Conjugating a real value is a no-op, but allow it anyway.  */\n       if (!(arg = build_expr_type_conversion (WANT_ARITH | WANT_ENUM, arg, true)))\n-\terrstring = \"wrong type argument to conjugation\";\n+\terrstring = _(\"wrong type argument to conjugation\");\n       else if (!noconvert)\n \targ = default_conversion (arg);\n       break;\n@@ -4512,7 +4512,7 @@ cp_build_unary_op (enum tree_code code, tree xarg, int noconvert,\n       val = invert_truthvalue_loc (input_location, arg);\n       if (arg != error_mark_node)\n \treturn val;\n-      errstring = \"in argument to unary !\";\n+      errstring = _(\"in argument to unary !\");\n       break;\n \n     case NOP_EXPR:\n@@ -4573,13 +4573,13 @@ cp_build_unary_op (enum tree_code code, tree xarg, int noconvert,\n \t\t\t\t\t      arg, true)))\n \t{\n \t  if (code == PREINCREMENT_EXPR)\n-\t    errstring =\"no pre-increment operator for type\";\n+\t    errstring = _(\"no pre-increment operator for type\");\n \t  else if (code == POSTINCREMENT_EXPR)\n-\t    errstring =\"no post-increment operator for type\";\n+\t    errstring = _(\"no post-increment operator for type\");\n \t  else if (code == PREDECREMENT_EXPR)\n-\t    errstring =\"no pre-decrement operator for type\";\n+\t    errstring = _(\"no pre-decrement operator for type\");\n \t  else\n-\t    errstring =\"no post-decrement operator for type\";\n+\t    errstring = _(\"no post-decrement operator for type\");\n \t  break;\n \t}\n       else if (arg == error_mark_node)\n@@ -4593,7 +4593,7 @@ cp_build_unary_op (enum tree_code code, tree xarg, int noconvert,\n           if (complain & tf_error)\n             readonly_error (arg, ((code == PREINCREMENT_EXPR\n                                    || code == POSTINCREMENT_EXPR)\n-                                  ? \"increment\" : \"decrement\"));\n+                                  ? REK_INCREMENT : REK_DECREMENT));\n           else\n             return error_mark_node;\n         }\n@@ -6327,7 +6327,7 @@ cp_build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs,\n \t      && C_TYPE_FIELDS_READONLY (lhstype))))\n     {\n       if (complain & tf_error)\n-\treadonly_error (lhs, \"assignment\");\n+\treadonly_error (lhs, REK_ASSIGNMENT);\n       else\n \treturn error_mark_node;\n     }"}, {"sha": "348c6576c111b3da24c761022e581bd6f688ae39", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 109, "deletions": 13, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd5a50a09d5561ff182b37b7429006c35f430df/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd5a50a09d5561ff182b37b7429006c35f430df/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=4cd5a50a09d5561ff182b37b7429006c35f430df", "patch": "@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"tree.h\"\n+#include \"intl.h\"\n #include \"cp-tree.h\"\n #include \"flags.h\"\n #include \"toplev.h\"\n@@ -71,41 +72,136 @@ binfo_or_else (tree base, tree type)\n    value may not be changed thereafter.  */\n \n void\n-readonly_error (tree arg, const char* string)\n+readonly_error (tree arg, readonly_error_kind errstring)\n {\n-  const char *fmt;\n+ \n+/* This macro is used to emit diagnostics to ensure that all format\n+   strings are complete sentences, visible to gettext and checked at\n+   compile time.  */\n+ \n+#define ERROR_FOR_ASSIGNMENT(AS, ASM, IN, DE, ARG)                      \\\n+  do {                                                                  \\\n+    switch (errstring)                                                  \\\n+      {                                                                 \\\n+      case REK_ASSIGNMENT:                                              \\\n+        error(AS, ARG);                                                 \\\n+        break;                                                          \\\n+      case REK_ASSIGNMENT_ASM:                                          \\\n+        error(ASM, ARG);                                                \\\n+        break;                                                          \\\n+      case REK_INCREMENT:                                               \\\n+        error (IN, ARG);                                                \\\n+        break;                                                          \\\n+      case REK_DECREMENT:                                               \\\n+        error (DE, ARG);                                                \\\n+        break;                                                          \\\n+      default:                                                          \\\n+        gcc_unreachable ();                                             \\\n+      }                                                                 \\\n+  } while (0)\n \n   if (TREE_CODE (arg) == COMPONENT_REF)\n     {\n       if (TYPE_READONLY (TREE_TYPE (TREE_OPERAND (arg, 0))))\n-\tfmt = \"%s of data-member %qD in read-only structure\";\n+        ERROR_FOR_ASSIGNMENT (G_(\"assignment of \"\n+                                 \"data-member %qD in read-only structure\"),\n+                              G_(\"assignment (via 'asm' output) of \"\n+                                 \"data-member %qD in read-only structure\"),\n+                              G_(\"increment of \"\n+                                 \"data-member %qD in read-only structure\"),\n+                              G_(\"decrement of \"\n+                                 \"data-member %qD in read-only structure\"),\n+                              TREE_OPERAND (arg, 1));\n       else\n-\tfmt = \"%s of read-only data-member %qD\";\n-      error (fmt, string, TREE_OPERAND (arg, 1));\n+        ERROR_FOR_ASSIGNMENT (G_(\"assignment of \"\n+                                 \"read-only data-member %qD\"),\n+                              G_(\"assignment (via 'asm' output) of \"\n+                                 \"read-only data-member %qD\"),\n+                              G_(\"increment of \"\n+                                 \"read-only data-member %qD\"),\n+                              G_(\"decrement of \"\n+                                 \"read-only data-member %qD\"),\n+                              TREE_OPERAND (arg, 1));\n     }\n   else if (TREE_CODE (arg) == VAR_DECL)\n     {\n       if (DECL_LANG_SPECIFIC (arg)\n \t  && DECL_IN_AGGR_P (arg)\n \t  && !TREE_STATIC (arg))\n-\tfmt = \"%s of constant field %qD\";\n+        ERROR_FOR_ASSIGNMENT (G_(\"assignment of \"\n+                              \"constant field %qD\"),\n+                              G_(\"assignment (via 'asm' output) of \"\n+                              \"constant field %qD\"),\n+                              G_(\"increment of \"\n+                              \"constant field %qD\"),\n+                              G_(\"decrement of \"\n+                              \"constant field %qD\"),\n+                              arg);\n       else\n-\tfmt = \"%s of read-only variable %qD\";\n-      error (fmt, string, arg);\n+        ERROR_FOR_ASSIGNMENT (G_(\"assignment of \"\n+                              \"read-only variable %qD\"),\n+                              G_(\"assignment (via 'asm' output) of \"\n+                              \"read-only variable %qD\"),\n+                              G_(\"increment of \"\n+                              \"read-only variable %qD\"),\n+                              G_(\"decrement of \"\n+                              \"read-only variable %qD\"),\n+                              arg);\n+\n     }\n   else if (TREE_CODE (arg) == PARM_DECL)\n-    error (\"%s of read-only parameter %qD\", string, arg);\n+    ERROR_FOR_ASSIGNMENT (G_(\"assignment of \"\n+                             \"read-only parameter %qD\"),\n+                          G_(\"assignment (via 'asm' output) of \"\n+                             \"read-only parameter %qD\"),\n+                          G_(\"increment of \"\n+                             \"read-only parameter %qD\"),\n+                          G_(\"decrement of \"\n+                             \"read-only parameter %qD\"),\n+                          arg);  \n   else if (TREE_CODE (arg) == INDIRECT_REF\n \t   && TREE_CODE (TREE_TYPE (TREE_OPERAND (arg, 0))) == REFERENCE_TYPE\n \t   && (TREE_CODE (TREE_OPERAND (arg, 0)) == VAR_DECL\n \t       || TREE_CODE (TREE_OPERAND (arg, 0)) == PARM_DECL))\n-    error (\"%s of read-only reference %qD\", string, TREE_OPERAND (arg, 0));\n+    ERROR_FOR_ASSIGNMENT (G_(\"assignment of \"\n+                             \"read-only reference %qD\"),\n+                          G_(\"assignment (via 'asm' output) of \"\n+                             \"read-only reference %qD\"), \n+                          G_(\"increment of \"\n+                             \"read-only reference %qD\"),\n+                          G_(\"decrement of \"\n+                             \"read-only reference %qD\"),\n+                          TREE_OPERAND (arg, 0));\n   else if (TREE_CODE (arg) == RESULT_DECL)\n-    error (\"%s of read-only named return value %qD\", string, arg);\n+    ERROR_FOR_ASSIGNMENT (G_(\"assignment of \"\n+                             \"read-only named return value %qD\"),\n+                          G_(\"assignment (via 'asm' output) of \"\n+                             \"read-only named return value %qD\"),\n+                          G_(\"increment of \"\n+                             \"read-only named return value %qD\"),\n+                          G_(\"decrement of \"\n+                             \"read-only named return value %qD\"),\n+                          arg);\n   else if (TREE_CODE (arg) == FUNCTION_DECL)\n-    error (\"%s of function %qD\", string, arg);\n+    ERROR_FOR_ASSIGNMENT (G_(\"assignment of \"\n+                             \"function %qD\"),\n+                          G_(\"assignment (via 'asm' output) of \"\n+                             \"function %qD\"),\n+                          G_(\"increment of \"\n+                             \"function %qD\"),\n+                          G_(\"decrement of \"\n+                             \"function %qD\"),\n+                          arg);\n   else\n-    error (\"%s of read-only location %qE\", string, arg);\n+    ERROR_FOR_ASSIGNMENT (G_(\"assignment of \"\n+                             \"read-only location %qE\"),\n+                          G_(\"assignment (via 'asm' output) of \"\n+                             \"read-only location %qE\"),\n+                          G_(\"increment of \"\n+                             \"read-only location %qE\"),\n+                          G_(\"decrement of \"\n+                             \"read-only location %qE\"),\n+                          arg);\n }\n \n \f"}]}