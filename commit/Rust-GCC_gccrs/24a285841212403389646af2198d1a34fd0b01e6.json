{"sha": "24a285841212403389646af2198d1a34fd0b01e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjRhMjg1ODQxMjEyNDAzMzg5NjQ2YWYyMTk4ZDFhMzRmZDBiMDFlNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-08-07T12:59:58Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-08-07T12:59:58Z"}, "message": "alias.c (nonlocal_mentioned_p): Rename CONST_CALL_P to CONST_OR_PURE_CALL_P\n\n\t* alias.c (nonlocal_mentioned_p):\n\tRename CONST_CALL_P to CONST_OR_PURE_CALL_P\n\t* calls.c (emit_call_1): Likewise.\n\t* cse.c (cse_insn, invalidate_skipped_block): Likewise.\n\t* cselib.c (cselib_process_insn): Likewise.\n\t* df.c (df_insns_modify): Likewise.\n\t* flow.c (need_fake_edge_p): Likewise.\n\t(propagate_one_insn): Likewise.\n\t* haifa-sched.c (reemit_notes): Likewise.\n\t* integrate.c (copy_insn_list): Likewise.\n\t* jump.c (delete_prior_computation): Likewise.\n\t* local-alloc.c (validate_equiv_mem): Likewise.\n\t* loop.c (scan_loop): Likewise.\n\t* predict.c (estimate_probability): Likewise.\n\t* reload.c (reload): Likewise.\n\t* sched-deps (sched_analyze): Likewise.\n\t* rtl.h (CONST_CALL_P): rename to CONST_OR_PURE_CALL_P.\n\t* gcse.c (compute_hash_table): Likewise.\n\t(mark_call): Likewise.\n\t(store_killed_in_insn): Likewise.\n\nFrom-SVN: r44688", "tree": {"sha": "0322c300793ed36c3e662d9a08be9ef6a9be7789", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0322c300793ed36c3e662d9a08be9ef6a9be7789"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24a285841212403389646af2198d1a34fd0b01e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24a285841212403389646af2198d1a34fd0b01e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24a285841212403389646af2198d1a34fd0b01e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24a285841212403389646af2198d1a34fd0b01e6/comments", "author": null, "committer": null, "parents": [{"sha": "0254ec9f02a56cba4779255813cf2a5d658838cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0254ec9f02a56cba4779255813cf2a5d658838cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0254ec9f02a56cba4779255813cf2a5d658838cd"}], "stats": {"total": 74, "additions": 50, "deletions": 24}, "files": [{"sha": "e3820fd857940fa7ce46876a8de6c7d47a2f519e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24a285841212403389646af2198d1a34fd0b01e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24a285841212403389646af2198d1a34fd0b01e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=24a285841212403389646af2198d1a34fd0b01e6", "patch": "@@ -1,3 +1,26 @@\n+Tue Aug  7 14:56:16 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* alias.c (nonlocal_mentioned_p):\n+\tRename CONST_CALL_P to CONST_OR_PURE_CALL_P\n+\t* calls.c (emit_call_1): Likewise.\n+\t* cse.c (cse_insn, invalidate_skipped_block): Likewise.\n+\t* cselib.c (cselib_process_insn): Likewise.\n+\t* df.c (df_insns_modify): Likewise.\n+\t* flow.c (need_fake_edge_p): Likewise.\n+\t(propagate_one_insn): Likewise.\n+\t* haifa-sched.c (reemit_notes): Likewise.\n+\t* integrate.c (copy_insn_list): Likewise.\n+\t* jump.c (delete_prior_computation): Likewise.\n+\t* local-alloc.c (validate_equiv_mem): Likewise.\n+\t* loop.c (scan_loop): Likewise.\n+\t* predict.c (estimate_probability): Likewise.\n+\t* reload.c (reload): Likewise.\n+\t* sched-deps (sched_analyze): Likewise.\n+\t* rtl.h (CONST_CALL_P): rename to CONST_OR_PURE_CALL_P.\n+\t* gcse.c (compute_hash_table): Likewise.\n+\t(mark_call): Likewise.\n+\t(store_killed_in_insn): Likewise.\n+\n 2001-08-07  Jason Merrill  <jason_merrill@redhat.com>\n \n \t* c-semantics.c (make_rtl_for_local_static): Use DECL_RTL_SET_P."}, {"sha": "e26e13c2c97cf910e4f97011c5668609d4437743", "filename": "gcc/alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=24a285841212403389646af2198d1a34fd0b01e6", "patch": "@@ -1941,7 +1941,7 @@ nonlocal_mentioned_p (x)\n     {\n       /* Constant functions can be constant if they don't use\n          scratch memory used to mark function w/o side effects.  */\n-      if (code == CALL_INSN && CONST_CALL_P (x))\n+      if (code == CALL_INSN && CONST_OR_PURE_CALL_P (x))\n         {\n \t  x = CALL_INSN_FUNCTION_USAGE (x);\n \t  if (x == 0)"}, {"sha": "e31900f33ae5303e632241a036081e490bc57c96", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=24a285841212403389646af2198d1a34fd0b01e6", "patch": "@@ -598,7 +598,7 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n \n   /* If this is a const call, then set the insn's unchanging bit.  */\n   if (ecf_flags & (ECF_CONST | ECF_PURE))\n-    CONST_CALL_P (call_insn) = 1;\n+    CONST_OR_PURE_CALL_P (call_insn) = 1;\n \n   /* If this call can't throw, attach a REG_EH_REGION reg note to that\n      effect.  */"}, {"sha": "ade5b802c77e673e682fac2e60ecf88dc8505e6b", "filename": "gcc/cse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=24a285841212403389646af2198d1a34fd0b01e6", "patch": "@@ -5956,7 +5956,7 @@ cse_insn (insn, libcall_insn)\n \n   if (GET_CODE (insn) == CALL_INSN)\n     {\n-      if (! CONST_CALL_P (insn))\n+      if (! CONST_OR_PURE_CALL_P (insn))\n \tinvalidate_memory ();\n       invalidate_for_call ();\n     }\n@@ -6636,7 +6636,7 @@ invalidate_skipped_block (start)\n \n       if (GET_CODE (insn) == CALL_INSN)\n \t{\n-\t  if (! CONST_CALL_P (insn))\n+\t  if (! CONST_OR_PURE_CALL_P (insn))\n \t    invalidate_memory ();\n \t  invalidate_for_call ();\n \t}"}, {"sha": "e6d5b2ae50f1038cc1abb26a6c7cb82cf48e3382", "filename": "gcc/cselib.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=24a285841212403389646af2198d1a34fd0b01e6", "patch": "@@ -1279,7 +1279,7 @@ cselib_process_insn (insn)\n \tif (call_used_regs[i])\n \t  cselib_invalidate_regno (i, VOIDmode);\n \n-      if (! CONST_CALL_P (insn))\n+      if (! CONST_OR_PURE_CALL_P (insn))\n \tcselib_invalidate_mem (callmem);\n     }\n "}, {"sha": "776f4feebc89e4b00a5f88c33987ea9babc895d0", "filename": "gcc/df.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=24a285841212403389646af2198d1a34fd0b01e6", "patch": "@@ -2882,7 +2882,7 @@ df_insns_modify (df, bb, first_insn, last_insn)\n \t it does, we need to create a new basic block.  Ouch.  The\n \t same applies for a label.  */\n       if ((GET_CODE (insn) == CALL_INSN\n-\t   && ! CONST_CALL_P (insn))\n+\t   && ! CONST_OR_PURE_CALL_P (insn))\n \t  || GET_CODE (insn) == CODE_LABEL)\n \tabort ();\n "}, {"sha": "b2c90877e233a41c63db0b7238fe10ef9664dfa6", "filename": "gcc/flow.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=24a285841212403389646af2198d1a34fd0b01e6", "patch": "@@ -2512,7 +2512,8 @@ need_fake_edge_p (insn)\n \n   if ((GET_CODE (insn) == CALL_INSN\n        && !SIBLING_CALL_P (insn)\n-       && !find_reg_note (insn, REG_NORETURN, NULL) && !CONST_CALL_P (insn)))\n+       && !find_reg_note (insn, REG_NORETURN, NULL)\n+       && !CONST_OR_PURE_CALL_P (insn)))\n     return true;\n \n   return ((GET_CODE (PATTERN (insn)) == ASM_OPERANDS\n@@ -5392,7 +5393,7 @@ propagate_one_insn (pbi, insn)\n \t    cond = COND_EXEC_TEST (PATTERN (insn));\n \n \t  /* Non-constant calls clobber memory.  */\n-\t  if (! CONST_CALL_P (insn))\n+\t  if (! CONST_OR_PURE_CALL_P (insn))\n \t    {\n \t      free_EXPR_LIST_list (&pbi->mem_set_list);\n \t      pbi->mem_set_list_len = 0;"}, {"sha": "f0031c093fe95fbc58230a89c510b1913e8ef699", "filename": "gcc/gcse.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=24a285841212403389646af2198d1a34fd0b01e6", "patch": "@@ -2514,8 +2514,7 @@ compute_hash_table (set_p)\n \t\tif (TEST_HARD_REG_BIT (regs_invalidated_by_call, regno))\n \t\t  record_last_reg_set_info (insn, regno);\n \n-\t      if (! CONST_CALL_P (insn))\n-\t\trecord_last_mem_set_info (insn);\n+\t      mark_call (insn);\n \t    }\n \n \t  note_stores (PATTERN (insn), record_last_set_info, insn);\n@@ -2794,7 +2793,7 @@ static void\n mark_call (insn)\n      rtx insn;\n {\n-  if (! CONST_CALL_P (insn))\n+  if (! CONST_OR_PURE_CALL_P (insn))\n     record_last_mem_set_info (insn);\n }\n \n@@ -6478,6 +6477,9 @@ find_loads (x, store_pattern)\n   int i,j;\n   int ret = 0;\n \n+  if (!x)\n+    return 0;\n+\n   if (GET_CODE (x) == SET) \n     x = SET_SRC (x);\n \n@@ -6513,7 +6515,7 @@ store_killed_in_insn (x, insn)\n   \n   if (GET_CODE (insn) == CALL_INSN)\n     {\n-      if (CONST_CALL_P (insn))\n+      if (CONST_OR_PURE_CALL_P (insn))\n \treturn 0;\n       else\n \treturn 1;"}, {"sha": "c8fb5f767d6e019d20ebfa57491c5489f7c0bc97", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=24a285841212403389646af2198d1a34fd0b01e6", "patch": "@@ -1561,7 +1561,7 @@ reemit_notes (insn, last)\n \t  if (note_type == NOTE_INSN_SETJMP)\n \t    {\n \t      retval = emit_note_after (NOTE_INSN_SETJMP, insn);\n-\t      CONST_CALL_P (retval) = CONST_CALL_P (note);\n+\t      CONST_OR_PURE_CALL_P (retval) = CONST_OR_PURE_CALL_P (note);\n \t      remove_note (insn, note);\n \t      note = XEXP (note, 1);\n \t    }"}, {"sha": "29c68094140966623922f3389d48c52a65cd3e53", "filename": "gcc/integrate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=24a285841212403389646af2198d1a34fd0b01e6", "patch": "@@ -1522,7 +1522,7 @@ copy_insn_list (insns, map, static_chain_value)\n \t  copy = emit_call_insn (pattern);\n \n \t  SIBLING_CALL_P (copy) = SIBLING_CALL_P (insn);\n-\t  CONST_CALL_P (copy) = CONST_CALL_P (insn);\n+\t  CONST_OR_PURE_CALL_P (copy) = CONST_OR_PURE_CALL_P (insn);\n \n \t  /* Because the USAGE information potentially contains objects other\n \t     than hard registers, we need to copy it.  */"}, {"sha": "9099c1f5c3a5c3ea6e6f442024cdc0931cfd8f00", "filename": "gcc/jump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=24a285841212403389646af2198d1a34fd0b01e6", "patch": "@@ -1521,7 +1521,7 @@ delete_prior_computation (note, insn)\n       /* If we reach a CALL which is not calling a const function\n \t or the callee pops the arguments, then give up.  */\n       if (GET_CODE (our_prev) == CALL_INSN\n-\t  && (! CONST_CALL_P (our_prev)\n+\t  && (! CONST_OR_PURE_CALL_P (our_prev)\n \t      || GET_CODE (pat) != SET || GET_CODE (SET_SRC (pat)) != CALL))\n \tbreak;\n "}, {"sha": "8dd3174c83d3869062d6b10dd4b1b3d0f25cd5c3", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=24a285841212403389646af2198d1a34fd0b01e6", "patch": "@@ -499,7 +499,7 @@ validate_equiv_mem (start, reg, memref)\n \treturn 1;\n \n       if (GET_CODE (insn) == CALL_INSN && ! RTX_UNCHANGING_P (memref)\n-\t  && ! CONST_CALL_P (insn))\n+\t  && ! CONST_OR_PURE_CALL_P (insn))\n \treturn 0;\n \n       note_stores (PATTERN (insn), validate_equiv_mem_from_store, NULL);"}, {"sha": "50b430d7cd876a33f26f92f5d5856a0edca2baf5", "filename": "gcc/loop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=24a285841212403389646af2198d1a34fd0b01e6", "patch": "@@ -950,7 +950,7 @@ scan_loop (loop, flags)\n       /* Past a call insn, we get to insns which might not be executed\n \t because the call might exit.  This matters for insns that trap.\n \t Constant and pure call insns always return, so they don't count.  */\n-      else if (GET_CODE (p) == CALL_INSN && ! CONST_CALL_P (p))\n+      else if (GET_CODE (p) == CALL_INSN && ! CONST_OR_PURE_CALL_P (p))\n \tcall_passed = 1;\n       /* Past a label or a jump, we get to insns for which we\n \t can't count on whether or how many times they will be\n@@ -2364,7 +2364,7 @@ prescan_loop (loop)\n \t}\n       else if (GET_CODE (insn) == CALL_INSN)\n \t{\n-\t  if (! CONST_CALL_P (insn))\n+\t  if (! CONST_OR_PURE_CALL_P (insn))\n \t    {\n \t      loop_info->unknown_address_altered = 1;\n \t      loop_info->has_nonconst_call = 1;"}, {"sha": "91a64a3fd1f9a1d7a3de8f901bdb9ddd60d80add", "filename": "gcc/predict.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=24a285841212403389646af2198d1a34fd0b01e6", "patch": "@@ -386,7 +386,7 @@ estimate_probability (loops_info)\n \t\tif (GET_CODE (insn) == CALL_INSN\n \t\t    /* Constant and pure calls are hardly used to signalize\n \t\t       something exceptional.  */\n-\t\t    && ! CONST_CALL_P (insn))\n+\t\t    && ! CONST_OR_PURE_CALL_P (insn))\n \t\t  {\n \t\t    predict_edge_def (e, PRED_CALL, NOT_TAKEN);\n \t\t    break;"}, {"sha": "86b635429b96a8bddb7f61148acd32fdc0fb5951", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=24a285841212403389646af2198d1a34fd0b01e6", "patch": "@@ -762,7 +762,7 @@ reload (first, global)\n     {\n       rtx set = single_set (insn);\n \n-      if (GET_CODE (insn) == NOTE && CONST_CALL_P (insn)\n+      if (GET_CODE (insn) == NOTE && CONST_OR_PURE_CALL_P (insn)\n \t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP)\n \tfor (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t  if (! call_used_regs[i])"}, {"sha": "9e707dade0c6a36fb4012c8ac180d3ade5d6bcac", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=24a285841212403389646af2198d1a34fd0b01e6", "patch": "@@ -393,8 +393,8 @@ extern void rtvec_check_failed_bounds PARAMS ((rtvec, int,\n /* 1 if insn has been deleted.  */\n #define INSN_DELETED_P(INSN) ((INSN)->volatil)\n \n-/* 1 if insn is a call to a const function.  */\n-#define CONST_CALL_P(INSN) ((INSN)->unchanging)\n+/* 1 if insn is a call to a const or pure function.  */\n+#define CONST_OR_PURE_CALL_P(INSN) ((INSN)->unchanging)\n \n /* 1 if insn (assumed to be a CALL_INSN) is a sibling call.  */\n #define SIBLING_CALL_P(INSN) ((INSN)->jump)"}, {"sha": "69397a9542c0ec740f7e556b0172356cf5664352", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24a285841212403389646af2198d1a34fd0b01e6/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=24a285841212403389646af2198d1a34fd0b01e6", "patch": "@@ -1343,7 +1343,7 @@ sched_analyze (deps, head, tail)\n \t     all pending reads and writes, and start new dependencies starting\n \t     from here.  But only flush writes for constant calls (which may\n \t     be passed a pointer to something we haven't written yet).  */\n-\t  flush_pending_lists (deps, insn, CONST_CALL_P (insn));\n+\t  flush_pending_lists (deps, insn, CONST_OR_PURE_CALL_P (insn));\n \n \t  /* Depend this function call (actually, the user of this\n \t     function call) on all hard register clobberage.  */\n@@ -1393,7 +1393,7 @@ sched_analyze (deps, head, tail)\n \t  loop_notes = alloc_EXPR_LIST (REG_SAVE_NOTE,\n \t\t\t\t\tGEN_INT (NOTE_LINE_NUMBER (insn)),\n \t\t\t\t\tloop_notes);\n-\t  CONST_CALL_P (loop_notes) = CONST_CALL_P (insn);\n+\t  CONST_OR_PURE_CALL_P (loop_notes) = CONST_OR_PURE_CALL_P (insn);\n \t}\n \n       if (insn == tail)"}]}