{"sha": "9b598fa08bb33d56b25fadc35545b498f26a44be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI1OThmYTA4YmIzM2Q1NmIyNWZhZGMzNTU0NWI0OThmMjZhNDRiZQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2001-01-15T18:13:26Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2001-01-15T18:13:26Z"}, "message": "arm.c (use_return_insn): Don't try to determine the function type until after reload has completed.\n\n* arm.c (use_return_insn): Don't try to determine the function type\nuntil after reload has completed.\n(arm_output_epilogue): Don't adjust the sp value recovered from the\nstack.\n(emit_multi_reg_push): Don't record dwarf information for the pc.\n* arm.md (eh_epilogue): The function type may have changed, so it\nneeds to be recalculated.\n* arm/netbsd.h (DWARF2_UNWIND_INFO): Can now use dwarf2 unwind tables\non arm/netbsd.\n\nFrom-SVN: r39046", "tree": {"sha": "11ab7e0d219e20fd67e49381e5dad1c769f0f405", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11ab7e0d219e20fd67e49381e5dad1c769f0f405"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b598fa08bb33d56b25fadc35545b498f26a44be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b598fa08bb33d56b25fadc35545b498f26a44be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b598fa08bb33d56b25fadc35545b498f26a44be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b598fa08bb33d56b25fadc35545b498f26a44be/comments", "author": null, "committer": null, "parents": [{"sha": "c2b31703ba711ffe5d95ad96319a72deccdc93d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2b31703ba711ffe5d95ad96319a72deccdc93d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2b31703ba711ffe5d95ad96319a72deccdc93d3"}], "stats": {"total": 71, "additions": 48, "deletions": 23}, "files": [{"sha": "ebda5b141dcd1d254f1701e468ff53e65b148da1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b598fa08bb33d56b25fadc35545b498f26a44be/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b598fa08bb33d56b25fadc35545b498f26a44be/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9b598fa08bb33d56b25fadc35545b498f26a44be", "patch": "@@ -1,3 +1,15 @@\n+2001-01-15  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.c (use_return_insn): Don't try to determine the function type\n+\tuntil after reload has completed.\n+\t(arm_output_epilogue): Don't adjust the sp value recovered from the\n+\tstack.\n+\t(emit_multi_reg_push): Don't record dwarf information for the pc.\n+\t* arm.md (eh_epilogue): The function type may have changed, so it\n+\tneeds to be recalculated.\n+\t* arm/netbsd.h (DWARF2_UNWIND_INFO): Delete.  Can now use dwarf2 \n+\tunwind tables on arm/netbsd.\n+\n 2001-01-15  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm.md (cbranchsi4): Correct calculation of branch ranges."}, {"sha": "0605d5feee00b1a17eb75c7e68891f8a702998c8", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b598fa08bb33d56b25fadc35545b498f26a44be/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b598fa08bb33d56b25fadc35545b498f26a44be/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=9b598fa08bb33d56b25fadc35545b498f26a44be", "patch": "@@ -820,12 +820,14 @@ use_return_insn (iscond)\n      int iscond;\n {\n   int regno;\n-  unsigned int func_type = arm_current_func_type ();\n+  unsigned int func_type;\n \n   /* Never use a return instruction before reload has run.  */\n   if (!reload_completed)\n     return 0;\n       \n+  func_type = arm_current_func_type ();\n+\n   /* Naked functions, volatile functiond and interrupt\n      functions all need special consideration.  */\n   if (func_type & (ARM_FT_INTERRUPT | ARM_FT_VOLATILE | ARM_FT_NAKED))\n@@ -7492,10 +7494,12 @@ arm_output_epilogue (really_return)\n \t}\n     }\n \n+#if 0\n   if (ARM_FUNC_TYPE (func_type) == ARM_FT_EXCEPTION_HANDLER)\n     /* Adjust the stack to remove the exception handler stuff.  */\n     asm_fprintf (f, \"\\tadd\\t%r, %r, %r\\n\", SP_REGNUM, SP_REGNUM,\n \t\t REGNO (eh_ofs));\n+#endif\n \n   if (! really_return)\n     return \"\";\n@@ -7579,6 +7583,7 @@ emit_multi_reg_push (mask)\n      int mask;\n {\n   int num_regs = 0;\n+  int num_dwarf_regs;\n   int i, j;\n   rtx par;\n   rtx dwarf;\n@@ -7592,6 +7597,11 @@ emit_multi_reg_push (mask)\n   if (num_regs == 0 || num_regs > 16)\n     abort ();\n \n+  /* We don't record the PC in the dwarf frame information.  */\n+  num_dwarf_regs = num_regs;\n+  if (mask & (1 << PC_REGNUM))\n+    num_dwarf_regs--;\n+\n   /* For the body of the insn we are going to generate an UNSPEC in\n      parallel with several USEs.  This allows the insn to be recognised\n      by the push_multi pattern in the arm.md file.  The insn looks\n@@ -7619,14 +7629,13 @@ emit_multi_reg_push (mask)\n            (set (mem:SI (plus:SI (reg:SI sp) (const_int 4))) (reg:SI fp))\n            (set (mem:SI (plus:SI (reg:SI sp) (const_int 8))) (reg:SI ip))\n            (set (mem:SI (plus:SI (reg:SI sp) (const_int 12))) (reg:SI lr))\n-           (set (mem:SI (plus:SI (reg:SI sp) (const_int 16))) (reg:SI pc))\n         ])\n \n       This sequence is used both by the code to support stack unwinding for\n       exceptions handlers and the code to generate dwarf2 frame debugging.  */\n   \n   par = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (num_regs));\n-  dwarf = gen_rtx_SEQUENCE (VOIDmode, rtvec_alloc (num_regs + 1));\n+  dwarf = gen_rtx_SEQUENCE (VOIDmode, rtvec_alloc (num_dwarf_regs + 1));\n   RTX_FRAME_RELATED_P (dwarf) = 1;\n   dwarf_par_index = 1;\n \n@@ -7643,14 +7652,17 @@ emit_multi_reg_push (mask)\n \t\t\t\t\t\t\t stack_pointer_rtx)),\n \t\t\t   gen_rtx_UNSPEC (BLKmode,\n \t\t\t\t\t   gen_rtvec (1, reg),\n-\t\t\t\t\t   2));\n+\t\t\t\t\t   UNSPEC_PUSH_MULT));\n \n-\t  tmp = gen_rtx_SET (VOIDmode,\n-\t\t\t     gen_rtx_MEM (SImode, stack_pointer_rtx),\n-\t\t\t     reg);\n-\t  RTX_FRAME_RELATED_P (tmp) = 1;\n-\t  XVECEXP (dwarf, 0, dwarf_par_index) = tmp;\n-\t  dwarf_par_index ++;\n+\t  if (i != PC_REGNUM)\n+\t    {\n+\t      tmp = gen_rtx_SET (VOIDmode,\n+\t\t\t\t gen_rtx_MEM (SImode, stack_pointer_rtx),\n+\t\t\t\t reg);\n+\t      RTX_FRAME_RELATED_P (tmp) = 1;\n+\t      XVECEXP (dwarf, 0, dwarf_par_index) = tmp;\n+\t      dwarf_par_index++;\n+\t    }\n \n \t  break;\n \t}\n@@ -7664,15 +7676,17 @@ emit_multi_reg_push (mask)\n \n \t  XVECEXP (par, 0, j) = gen_rtx_USE (VOIDmode, reg);\n \n-\t  tmp = gen_rtx_SET (VOIDmode,\n-\t\t\t     gen_rtx_MEM (SImode,\n-\t\t\t\t\t  gen_rtx_PLUS (SImode,\n-\t\t\t\t\t\t\tstack_pointer_rtx,\n-\t\t\t\t\t\t\tGEN_INT (4 * j))),\n-\t\t\t     reg);\n-\t  RTX_FRAME_RELATED_P (tmp) = 1;\n-\t  XVECEXP (dwarf, 0, dwarf_par_index ++) = tmp;\n-\t\t\t   \n+\t  if (i != PC_REGNUM)\n+\t    {\n+\t      tmp = gen_rtx_SET (VOIDmode,\n+\t\t\t\t gen_rtx_MEM (SImode,\n+\t\t\t\t\t      plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t\t     4 * j)),\n+\t\t\t\t reg);\n+\t      RTX_FRAME_RELATED_P (tmp) = 1;\n+\t      XVECEXP (dwarf, 0, dwarf_par_index++) = tmp;\n+\t    }\n+\n \t  j++;\n \t}\n     }"}, {"sha": "205dc3794c09a1054e899cd1ce15e9408b291d1b", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b598fa08bb33d56b25fadc35545b498f26a44be/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b598fa08bb33d56b25fadc35545b498f26a44be/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=9b598fa08bb33d56b25fadc35545b498f26a44be", "patch": "@@ -8802,6 +8802,9 @@\n \temit_move_insn (ra, operands[2]);\n \toperands[2] = ra;\n       }\n+    /* This is a hack -- we may have crystalized the function type too\n+       early.  */\n+    cfun->machine->func_type = 0;\n   }\"\n )\n "}, {"sha": "057c7cf08a4b42e2389813cc7498c3af42a8dafd", "filename": "gcc/config/arm/netbsd.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b598fa08bb33d56b25fadc35545b498f26a44be/gcc%2Fconfig%2Farm%2Fnetbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b598fa08bb33d56b25fadc35545b498f26a44be/gcc%2Fconfig%2Farm%2Fnetbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fnetbsd.h?ref=9b598fa08bb33d56b25fadc35545b498f26a44be", "patch": "@@ -46,10 +46,6 @@ Boston, MA 02111-1307, USA.  */\n \n #include <netbsd.h>\n \n-/* Until they use ELF or something that handles dwarf2 unwinds\n-   and initialization stuff better.  */\n-#undef DWARF2_UNWIND_INFO\n-\n /* Some defines for CPP.\n    arm32 is the NetBSD port name, so we always define arm32 and __arm32__.  */\n #undef CPP_PREDEFINES"}]}