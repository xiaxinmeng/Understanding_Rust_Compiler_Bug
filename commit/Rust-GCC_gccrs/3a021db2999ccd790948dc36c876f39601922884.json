{"sha": "3a021db2999ccd790948dc36c876f39601922884", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2EwMjFkYjI5OTljY2Q3OTA5NDhkYzM2Yzg3NmYzOTYwMTkyMjg4NA==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2004-07-21T08:57:07Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2004-07-21T08:57:07Z"}, "message": "c-common.c (vector_types_convertible_p): Use vector types' TYPE_SIZE and TREE_TYPE instead of their mode.\n\n2004-07-21  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* c-common.c (vector_types_convertible_p): Use vector types'\n\tTYPE_SIZE and TREE_TYPE instead of their mode.\n\t* convert.c (convert_to_integer): Likewise.\n\t(convert_to_vector): Likewise.\n\t* fold-const.c (fold_convert): Likewise.\n\t* varasm.c (output_constant): Likewise.\n\t* expr.c (store_constructor): Split ARRAY_TYPE and VECTOR_TYPE.\n\tAllow a VECTOR_TYPE initializer to be made of several vectors.\n\tFor ARRAY_TYPEs and VECTOR_TYPES, simplify a bit the handling\n\tof cleared and need_to_clear, and use fold_convert.\n\t* c-typeck.c (build_binary_op): Do not use RDIV_EXPR for\n\tinteger vectors.\n\ncp/ChangeLog:\n2004-07-21  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* c-typeck.c (build_binary_op): Do not use RDIV_EXPR for\n\tinteger vectors.\n\nFrom-SVN: r85002", "tree": {"sha": "04000c5f2ebc9c61790505ccc698906864ba8de9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04000c5f2ebc9c61790505ccc698906864ba8de9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a021db2999ccd790948dc36c876f39601922884", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a021db2999ccd790948dc36c876f39601922884", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a021db2999ccd790948dc36c876f39601922884", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a021db2999ccd790948dc36c876f39601922884/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4b997cc8bb5bc3c83b9bf3e7866e0f4627f4b708", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b997cc8bb5bc3c83b9bf3e7866e0f4627f4b708", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b997cc8bb5bc3c83b9bf3e7866e0f4627f4b708"}], "stats": {"total": 256, "additions": 171, "deletions": 85}, "files": [{"sha": "4d40922261573403fbad6ac727a77ff04431a906", "filename": "gcc/c-common.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a021db2999ccd790948dc36c876f39601922884/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a021db2999ccd790948dc36c876f39601922884/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=3a021db2999ccd790948dc36c876f39601922884", "patch": "@@ -965,7 +965,9 @@ vector_types_convertible_p (tree t1, tree t2)\n {\n   return targetm.vector_opaque_p (t1)\n \t || targetm.vector_opaque_p (t2)\n-\t || TYPE_MODE (t1) == TYPE_MODE (t2);\n+         || (tree_int_cst_equal (TYPE_SIZE (t1), TYPE_SIZE (t2))\n+\t     && INTEGRAL_TYPE_P (TREE_TYPE (t1))\n+\t\t== INTEGRAL_TYPE_P (TREE_TYPE (t2)));\n }\n \n /* Convert EXPR to TYPE, warning about conversion problems with constants."}, {"sha": "6e1b9281b63969e7f3501a938c11a19957dbb4e7", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a021db2999ccd790948dc36c876f39601922884/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a021db2999ccd790948dc36c876f39601922884/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=3a021db2999ccd790948dc36c876f39601922884", "patch": "@@ -6908,6 +6908,11 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t  && (code1 == INTEGER_TYPE || code1 == REAL_TYPE\n \t      || code1 == COMPLEX_TYPE || code1 == VECTOR_TYPE))\n \t{\n+\t  if (code0 == COMPLEX_TYPE || code0 == VECTOR_TYPE)\n+\t    code0 = TREE_CODE (TREE_TYPE (TREE_TYPE (op0)));\n+\t  if (code1 == COMPLEX_TYPE || code1 == VECTOR_TYPE)\n+\t    code1 = TREE_CODE (TREE_TYPE (TREE_TYPE (op1)));\n+\n \t  if (!(code0 == INTEGER_TYPE && code1 == INTEGER_TYPE))\n \t    resultcode = RDIV_EXPR;\n \t  else"}, {"sha": "9e89163e1b1386727077a34a02239e273aad1abb", "filename": "gcc/convert.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a021db2999ccd790948dc36c876f39601922884/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a021db2999ccd790948dc36c876f39601922884/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=3a021db2999ccd790948dc36c876f39601922884", "patch": "@@ -677,8 +677,7 @@ convert_to_integer (tree type, tree expr)\n \t\t\t\t    TREE_TYPE (TREE_TYPE (expr)), expr)));\n \n     case VECTOR_TYPE:\n-      if (GET_MODE_SIZE (TYPE_MODE (type))\n-\t  != GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (expr))))\n+      if (!tree_int_cst_equal (TYPE_SIZE (type), TYPE_SIZE (TREE_TYPE (expr))))\n \t{\n \t  error (\"can't convert between vector values of different size\");\n \t  return error_mark_node;\n@@ -755,8 +754,7 @@ convert_to_vector (tree type, tree expr)\n     {\n     case INTEGER_TYPE:\n     case VECTOR_TYPE:\n-      if (GET_MODE_SIZE (TYPE_MODE (type))\n-\t  != GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (expr))))\n+      if (!tree_int_cst_equal (TYPE_SIZE (type), TYPE_SIZE (TREE_TYPE (expr))))\n \t{\n \t  error (\"can't convert between vector values of different size\");\n \t  return error_mark_node;"}, {"sha": "a3d142fcda605f1fb5787f4958ac8e10a6b519c8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a021db2999ccd790948dc36c876f39601922884/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a021db2999ccd790948dc36c876f39601922884/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3a021db2999ccd790948dc36c876f39601922884", "patch": "@@ -1,3 +1,8 @@\n+2004-07-21  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* typeck.c (build_binary_op): Do not use RDIV_EXPR for\n+\tinteger vectors.\n+\n 2004-07-21  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n \n \tPR c++/14497"}, {"sha": "640f512fe7302985ce1a20718ae04198f140a5b1", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a021db2999ccd790948dc36c876f39601922884/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a021db2999ccd790948dc36c876f39601922884/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=3a021db2999ccd790948dc36c876f39601922884", "patch": "@@ -2869,15 +2869,20 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n     case ROUND_DIV_EXPR:\n     case EXACT_DIV_EXPR:\n       if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE\n-\t   || code0 == COMPLEX_TYPE)\n+\t   || code0 == COMPLEX_TYPE || code0 == VECTOR_TYPE)\n \t  && (code1 == INTEGER_TYPE || code1 == REAL_TYPE\n-\t      || code1 == COMPLEX_TYPE))\n+\t      || code1 == COMPLEX_TYPE || code1 == VECTOR_TYPE))\n \t{\n \t  if (TREE_CODE (op1) == INTEGER_CST && integer_zerop (op1))\n \t    warning (\"division by zero in `%E / 0'\", op0);\n \t  else if (TREE_CODE (op1) == REAL_CST && real_zerop (op1))\n \t    warning (\"division by zero in `%E / 0.'\", op0);\n \t      \n+\t  if (code0 == COMPLEX_TYPE || code0 == VECTOR_TYPE)\n+\t    code0 = TREE_CODE (TREE_TYPE (TREE_TYPE (op0)));\n+\t  if (code1 == COMPLEX_TYPE || code1 == VECTOR_TYPE)\n+\t    code1 = TREE_CODE (TREE_TYPE (TREE_TYPE (op1)));\n+\n \t  if (!(code0 == INTEGER_TYPE && code1 == INTEGER_TYPE))\n \t    resultcode = RDIV_EXPR;\n \t  else"}, {"sha": "9bd383463c93da60bf4db9bff705ce92927ff308", "filename": "gcc/expr.c", "status": "modified", "additions": 144, "deletions": 70, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a021db2999ccd790948dc36c876f39601922884/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a021db2999ccd790948dc36c876f39601922884/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=3a021db2999ccd790948dc36c876f39601922884", "patch": "@@ -4268,8 +4268,7 @@ count_type_elements (tree type)\n       return 2;\n \n     case VECTOR_TYPE:\n-      /* ??? This is broke.  We should encode the vector width in the tree.  */\n-      return GET_MODE_NUNITS (TYPE_MODE (type));\n+      return TYPE_VECTOR_SUBPARTS (type);\n \n     case INTEGER_TYPE:\n     case REAL_TYPE:\n@@ -4554,8 +4553,8 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t\t\t   get_alias_set (TREE_TYPE (field)));\n \t}\n     }\n-  else if (TREE_CODE (type) == ARRAY_TYPE\n-\t   || TREE_CODE (type) == VECTOR_TYPE)\n+\n+  else if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       tree elt;\n       int i;\n@@ -4565,39 +4564,8 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n       int const_bounds_p;\n       HOST_WIDE_INT minelt = 0;\n       HOST_WIDE_INT maxelt = 0;\n-      int icode = 0;\n-      rtx *vector = NULL;\n-      int elt_size = 0;\n-      unsigned n_elts = 0;\n-\n-      if (TREE_CODE (type) == ARRAY_TYPE)\n-\tdomain = TYPE_DOMAIN (type);\n-      else\n-\t/* Vectors do not have domains; look up the domain of\n-\t   the array embedded in the debug representation type.\n-\t   FIXME Would probably be more efficient to treat vectors\n-\t   separately from arrays.  */\n-\t{\n-\t  domain = TYPE_DEBUG_REPRESENTATION_TYPE (type);\n-\t  domain = TYPE_DOMAIN (TREE_TYPE (TYPE_FIELDS (domain)));\n-\t  if (REG_P (target) && VECTOR_MODE_P (GET_MODE (target)))\n-\t    {\n-\t      enum machine_mode mode = GET_MODE (target);\n-\n-\t      icode = (int) vec_init_optab->handlers[mode].insn_code;\n-\t      if (icode != CODE_FOR_nothing)\n-\t\t{\n-\t\t  unsigned int i;\n-\n-\t\t  elt_size = GET_MODE_SIZE (GET_MODE_INNER (mode));\n-\t\t  n_elts = (GET_MODE_SIZE (mode) / elt_size);\n-\t\t  vector = alloca (n_elts);\n-\t\t  for (i = 0; i < n_elts; i++)\n-\t\t    vector [i] = CONST0_RTX (GET_MODE_INNER (mode));\n-\t\t}\n-\t    }\n-\t}\n \n+      domain = TYPE_DOMAIN (type);\n       const_bounds_p = (TYPE_MIN_VALUE (domain)\n \t\t\t&& TYPE_MAX_VALUE (domain)\n \t\t\t&& host_integerp (TYPE_MIN_VALUE (domain), 0)\n@@ -4613,7 +4581,9 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n       /* If the constructor has fewer elements than the array,\n          clear the whole array first.  Similarly if this is\n          static constructor of a non-BLKmode object.  */\n-      if (cleared || (REG_P (target) && TREE_STATIC (exp)))\n+      if (cleared)\n+\tneed_to_clear = 0;\n+      else if (REG_P (target) && TREE_STATIC (exp))\n \tneed_to_clear = 1;\n       else\n \t{\n@@ -4660,18 +4630,16 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t    need_to_clear = 1;\n \t}\n \n-      if (need_to_clear && size > 0 && !vector)\n+      if (need_to_clear && size > 0)\n \t{\n-\t  if (! cleared)\n-\t    {\n-\t      if (REG_P (target))\n-\t\temit_move_insn (target,  CONST0_RTX (GET_MODE (target)));\n-\t      else\n-\t\tclear_storage (target, GEN_INT (size));\n-\t    }\n+\t  if (REG_P (target))\n+\t    emit_move_insn (target,  CONST0_RTX (GET_MODE (target)));\n+\t  else\n+\t    clear_storage (target, GEN_INT (size));\n \t  cleared = 1;\n \t}\n-      else if (REG_P (target))\n+\n+      if (!cleared && REG_P (target))\n \t/* Inform later passes that the old value is dead.  */\n \temit_insn (gen_rtx_CLOBBER (VOIDmode, target));\n \n@@ -4710,9 +4678,6 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t      HOST_WIDE_INT lo, hi, count;\n \t      tree position;\n \n-\t      if (vector)\n-\t\tabort ();\n-\n \t      /* If the range is constant and \"small\", unroll the loop.  */\n \t      if (const_bounds_p\n \t\t  && host_integerp (lo_index, 0)\n@@ -4807,16 +4772,13 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t    {\n \t      tree position;\n \n-\t      if (vector)\n-\t\tabort ();\n-\n \t      if (index == 0)\n \t\tindex = ssize_int (1);\n \n \t      if (minelt)\n-\t\tindex = convert (ssizetype,\n-\t\t\t\t fold (build (MINUS_EXPR, index,\n-\t\t\t\t\t      TYPE_MIN_VALUE (domain))));\n+\t\tindex = fold_convert (ssizetype,\n+\t\t\t\t      fold (build (MINUS_EXPR, index,\n+\t\t\t\t\t\t   TYPE_MIN_VALUE (domain))));\n \n \t      position = size_binop (MULT_EXPR, index,\n \t\t\t\t     convert (ssizetype,\n@@ -4827,16 +4789,6 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t      xtarget = adjust_address (xtarget, mode, 0);\n \t      store_expr (value, xtarget, 0);\n \t    }\n-\t  else if (vector)\n-\t    {\n-\t      int pos;\n-\n-\t      if (index != 0)\n-\t\tpos = tree_low_cst (index, 0) - minelt;\n-\t      else\n-\t\tpos = i;\n-\t      vector[pos] = expand_expr (value, NULL_RTX, VOIDmode, 0);\n-\t    }\n \t  else\n \t    {\n \t      if (index != 0)\n@@ -4856,12 +4808,128 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t\t\t       type, cleared, get_alias_set (elttype));\n \t    }\n \t}\n-      if (vector)\n+    }\n+\n+  else if (TREE_CODE (type) == VECTOR_TYPE)\n+    {\n+      tree elt;\n+      int i;\n+      int need_to_clear;\n+      int icode = 0;\n+      tree elttype = TREE_TYPE (type);\n+      int elt_size = tree_low_cst (TYPE_SIZE (elttype), 1);\n+      enum machine_mode eltmode = TYPE_MODE (elttype);\n+      HOST_WIDE_INT bitsize;\n+      HOST_WIDE_INT bitpos;\n+      rtx *vector = NULL;\n+      unsigned n_elts;\n+\n+      if (eltmode == BLKmode)\n+\tabort ();\n+\n+      n_elts = TYPE_VECTOR_SUBPARTS (type);\n+      if (REG_P (target) && VECTOR_MODE_P (GET_MODE (target)))\n \t{\n-\t  emit_insn (GEN_FCN (icode) (target,\n-\t\t\t\t      gen_rtx_PARALLEL (GET_MODE (target),\n-\t\t\t\t\t\t        gen_rtvec_v (n_elts, vector))));\n+\t  enum machine_mode mode = GET_MODE (target);\n+\t  \n+\t  icode = (int) vec_init_optab->handlers[mode].insn_code;\n+\t  if (icode != CODE_FOR_nothing)\n+\t    {\n+\t      unsigned int i;\n+\t      \n+\t      vector = alloca (n_elts);\n+\t      for (i = 0; i < n_elts; i++)\n+\t\tvector [i] = CONST0_RTX (GET_MODE_INNER (mode));\n+\t    }\n \t}\n+\n+      /* If the constructor has fewer elements than the vector,\n+         clear the whole array first.  Similarly if this is\n+         static constructor of a non-BLKmode object.  */\n+      if (cleared)\n+\tneed_to_clear = 0;\n+      else if (REG_P (target) && TREE_STATIC (exp))\n+\tneed_to_clear = 1;\n+      else\n+\t{\n+\t  unsigned HOST_WIDE_INT count = 0, zero_count = 0;\n+\n+\t  for (elt = CONSTRUCTOR_ELTS (exp);\n+\t       elt != NULL_TREE;\n+\t       elt = TREE_CHAIN (elt))\n+\t    {\n+\t      int n_elts_here =\n+\t\ttree_low_cst (\n+\t\t  int_const_binop (TRUNC_DIV_EXPR,\n+\t\t\t\t   TYPE_SIZE (TREE_TYPE (TREE_VALUE (elt))),\n+\t\t\t\t   TYPE_SIZE (elttype), 0), 1);\n+\n+\t      count += n_elts_here;\n+\t      if (mostly_zeros_p (TREE_VALUE (elt)))\n+\t        zero_count += n_elts_here;\n+\t    }\n+\n+\t  /* Clear the entire vector first if there are any missing elements,\n+\t     or if the incidence of zero elements is >= 75%.  */\n+\t  need_to_clear = (count < n_elts || 4 * zero_count >= 3 * count);\n+\t}\n+\n+      if (need_to_clear && size > 0 && !vector)\n+\t{\n+\t  if (REG_P (target))\n+\t    emit_move_insn (target,  CONST0_RTX (GET_MODE (target)));\n+\t  else\n+\t    clear_storage (target, GEN_INT (size));\n+\t  cleared = 1;\n+\t}\n+\n+      if (!cleared && REG_P (target))\n+\t/* Inform later passes that the old value is dead.  */\n+\temit_insn (gen_rtx_CLOBBER (VOIDmode, target));\n+\n+      /* Store each element of the constructor into the corresponding\n+\t element of TARGET, determined by counting the elements.  */\n+      for (elt = CONSTRUCTOR_ELTS (exp), i = 0;\n+\t   elt;\n+\t   elt = TREE_CHAIN (elt), i += bitsize / elt_size)\n+\t{\n+\t  tree value = TREE_VALUE (elt);\n+\t  tree index = TREE_PURPOSE (elt);\n+\t  HOST_WIDE_INT eltpos;\n+\n+\t  bitsize = tree_low_cst (TYPE_SIZE (TREE_TYPE (value)), 1);\n+\t  if (cleared && initializer_zerop (value))\n+\t    continue;\n+\n+\t  if (index != 0)\n+\t    eltpos = tree_low_cst (index, 1);\n+\t  else\n+\t    eltpos = i;\n+\n+\t  if (vector)\n+\t    {\n+\t      /* Vector CONSTRUCTORs should only be built from smaller\n+\t\t vectors in the case of BLKmode vectors.  */\n+\t      if (TREE_CODE (TREE_TYPE (value)) == VECTOR_TYPE)\n+\t\tabort ();\n+\t      vector[eltpos] = expand_expr (value, NULL_RTX, VOIDmode, 0);\n+\t    }\n+\t  else\n+\t    {\n+\t      enum machine_mode value_mode =\n+\t\tTREE_CODE (TREE_TYPE (value)) == VECTOR_TYPE\n+\t\t  ? TYPE_MODE (TREE_TYPE (value))\n+\t\t  : eltmode;\n+\t      bitpos = eltpos * elt_size;\n+\t      store_constructor_field (target, bitsize, bitpos, value_mode, value,\n+\t\t\t\t       type, cleared, get_alias_set (elttype));\n+\t    }\n+\t}\n+\n+      if (vector)\n+\temit_insn (GEN_FCN (icode) (target,\n+\t\t\t\t    gen_rtx_PARALLEL (GET_MODE (target),\n+\t\t\t\t\t\t      gen_rtvec_v (n_elts, vector))));\n     }\n \n   /* Set constructor assignments.  */\n@@ -6430,7 +6498,13 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       return temp;\n \n     case VECTOR_CST:\n-      return const_vector_from_tree (exp);\n+      if (GET_MODE_CLASS (TYPE_MODE (TREE_TYPE (exp))) == MODE_VECTOR_INT\n+\t  || GET_MODE_CLASS (TYPE_MODE (TREE_TYPE (exp))) == MODE_VECTOR_FLOAT)\n+\treturn const_vector_from_tree (exp);\n+      else \n+\treturn expand_expr (build1 (CONSTRUCTOR, TREE_TYPE (exp),\n+\t\t\t\t    TREE_VECTOR_CST_ELTS (exp)),\n+\t\t\t    ignore ? const0_rtx : target, tmode, modifier);\n \n     case CONST_DECL:\n       return expand_expr (DECL_INITIAL (exp), target, VOIDmode, modifier);"}, {"sha": "e976117d133a1f4a14030e0d4767c8a1f7a25416", "filename": "gcc/fold-const.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a021db2999ccd790948dc36c876f39601922884/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a021db2999ccd790948dc36c876f39601922884/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=3a021db2999ccd790948dc36c876f39601922884", "patch": "@@ -1931,8 +1931,7 @@ fold_convert (tree type, tree arg)\n \t  return fold_convert (type, tem);\n \t}\n       if (TREE_CODE (orig) == VECTOR_TYPE\n-\t  && GET_MODE_SIZE (TYPE_MODE (type))\n-\t     == GET_MODE_SIZE (TYPE_MODE (orig)))\n+\t  && tree_int_cst_equal (TYPE_SIZE (type), TYPE_SIZE (orig)))\n \treturn fold (build1 (NOP_EXPR, type, arg));\n     }\n   else if (TREE_CODE (type) == REAL_TYPE)\n@@ -1991,12 +1990,10 @@ fold_convert (tree type, tree arg)\n   else if (TREE_CODE (type) == VECTOR_TYPE)\n     {\n       if ((INTEGRAL_TYPE_P (orig) || POINTER_TYPE_P (orig))\n-\t  && GET_MODE_SIZE (TYPE_MODE (type))\n-\t     == GET_MODE_SIZE (TYPE_MODE (orig)))\n+\t  && tree_int_cst_equal (TYPE_SIZE (type), TYPE_SIZE (orig)))\n \treturn fold (build1 (NOP_EXPR, type, arg));\n       if (TREE_CODE (orig) == VECTOR_TYPE\n-\t  && GET_MODE_SIZE (TYPE_MODE (type))\n-\t     == GET_MODE_SIZE (TYPE_MODE (orig)))\n+\t  && tree_int_cst_equal (TYPE_SIZE (type), TYPE_SIZE (orig)))\n \treturn fold (build1 (NOP_EXPR, type, arg));\n     }\n   else if (VOID_TYPE_P (type))"}, {"sha": "7107c5f9a69e1f0d28911a1041cb4264eb3cc49a", "filename": "gcc/varasm.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a021db2999ccd790948dc36c876f39601922884/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a021db2999ccd790948dc36c876f39601922884/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=3a021db2999ccd790948dc36c876f39601922884", "patch": "@@ -3615,10 +3615,10 @@ output_constant (tree exp, unsigned HOST_WIDE_INT size, unsigned int align)\n \t  unsigned int nalign;\n \t  enum machine_mode inner;\n \n-\t  inner = GET_MODE_INNER (TYPE_MODE (TREE_TYPE (exp)));\n+\t  inner = TYPE_MODE (TREE_TYPE (TREE_TYPE (exp)));\n \t  nalign = MIN (align, GET_MODE_ALIGNMENT (inner));\n \n-\t  elt_size = GET_MODE_UNIT_SIZE (TYPE_MODE (TREE_TYPE (exp)));\n+\t  elt_size = GET_MODE_SIZE (inner);\n \n \t  link = TREE_VECTOR_CST_ELTS (exp);\n \t  output_constant (TREE_VALUE (link), elt_size, align);"}]}