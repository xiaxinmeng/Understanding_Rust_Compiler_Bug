{"sha": "408579c9c9b8fee20e1d8114489ce2b93872767c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDA4NTc5YzljOWI4ZmVlMjBlMWQ4MTE0NDg5Y2UyYjkzODcyNzY3Yw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2021-08-17T13:50:54Z"}, "committer": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2021-08-17T13:53:04Z"}, "message": "Improved handling of MULT_EXPR in bit CCP.\n\nThis patch allows GCC to constant fold (i | (i<<16)) | ((i<<24) | (i<<8)),\nwhere i is an unsigned char, or the equivalent (i*65537) | (i*16777472), to\ni*16843009.  The trick is to teach tree_nonzero_bits which bits may be\nset in the result of a multiplication by a constant given which bits are\npotentially set in the operands.  This allows the optimizations recently\nadded to match.pd to catch more cases.\n\nThe required mask/value pair from a multiplication may be calculated using\na classical shift-and-add algorithm, given we already have implementations\nfor both addition and shift by constant.  To keep this optimization \"cheap\",\nthis functionality is only used if the constant multiplier has a few bits\nset (unless flag_expensive_optimizations), and we provide a special case\nfast-path implementation for the common case where the (non-constant)\noperand has no bits that are guaranteed to be set.  I have no evidence\nthat this functionality causes performance issues, it's just that sparse\nmultipliers provide the largest benefit to CCP.\n\n2021-08-17  Roger Sayle  <roger@nextmovesoftware.com>\n\ngcc/ChangeLog\n\t* tree-ssa-ccp.c (bit_value_mult_const): New helper function to\n\tcalculate the mask-value pair result of a multiplication by an\n\tunsigned constant.\n\t(bit_value_binop) [MULT_EXPR]:  Call it from here for\n\tmultiplications by (sparse) non-negative constants.\n\ngcc/testsuite/ChangeLog\n\t* gcc.dg/fold-ior-5.c: New test case.", "tree": {"sha": "4283a897742f5041bb10b4778665e29420188a39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4283a897742f5041bb10b4778665e29420188a39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/408579c9c9b8fee20e1d8114489ce2b93872767c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/408579c9c9b8fee20e1d8114489ce2b93872767c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/408579c9c9b8fee20e1d8114489ce2b93872767c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/408579c9c9b8fee20e1d8114489ce2b93872767c/comments", "author": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8d535f3fec81c1cc84e22df5500e693544ec65b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8d535f3fec81c1cc84e22df5500e693544ec65b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8d535f3fec81c1cc84e22df5500e693544ec65b"}], "stats": {"total": 122, "additions": 104, "deletions": 18}, "files": [{"sha": "8de56976da9d3d15832edc2b74ba639fe5229c5e", "filename": "gcc/testsuite/gcc.dg/fold-ior-5.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/408579c9c9b8fee20e1d8114489ce2b93872767c/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-ior-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/408579c9c9b8fee20e1d8114489ce2b93872767c/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-ior-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-ior-5.c?ref=408579c9c9b8fee20e1d8114489ce2b93872767c", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+unsigned int test_ior(unsigned char i)\n+{\n+  return (i | (i<<16)) | ((i<<24) | (i<<8));\n+}\n+\n+unsigned int test_xor(unsigned char i)\n+{\n+  return (i ^ (i<<16)) ^ ((i<<24) ^ (i<<8));\n+}\n+\n+/* { dg-final { scan-tree-dump-not \" \\\\^ \" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-not \" \\\\| \" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \" \\\\* 16843009\" 2 \"optimized\" } } */\n+"}, {"sha": "8e4d8aeb69ba426d37eb7347294799a060315ad7", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 87, "deletions": 18, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/408579c9c9b8fee20e1d8114489ce2b93872767c/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/408579c9c9b8fee20e1d8114489ce2b93872767c/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=408579c9c9b8fee20e1d8114489ce2b93872767c", "patch": "@@ -1389,6 +1389,66 @@ bit_value_unop (enum tree_code code, signop type_sgn, int type_precision,\n     }\n }\n \n+/* Determine the mask pair *VAL and *MASK from multiplying the\n+   argument mask pair RVAL, RMASK by the unsigned constant C.  */\n+void\n+bit_value_mult_const (signop sgn, int width,\n+\t\t      widest_int *val, widest_int *mask,\n+\t\t      const widest_int &rval, const widest_int &rmask,\n+\t\t      widest_int c)\n+{\n+  widest_int sum_mask = 0;\n+\n+  /* Ensure rval_lo only contains known bits.  */\n+  widest_int rval_lo = wi::bit_and_not (rval, rmask);\n+\n+  if (rval_lo != 0)\n+    {\n+      /* General case (some bits of multiplicand are known set).  */\n+      widest_int sum_val = 0;\n+      while (c != 0)\n+\t{\n+\t  /* Determine the lowest bit set in the multiplier.  */\n+\t  int bitpos = wi::ctz (c);\n+\t  widest_int term_mask = rmask << bitpos;\n+\t  widest_int term_val = rval_lo << bitpos;\n+\n+\t  /* sum += term.  */\n+\t  widest_int lo = sum_val + term_val;\n+\t  widest_int hi = (sum_val | sum_mask) + (term_val | term_mask);\n+\t  sum_mask |= term_mask | (lo ^ hi);\n+\t  sum_val = lo;\n+\n+\t  /* Clear this bit in the multiplier.  */\n+\t  c ^= wi::lshift (1, bitpos);\n+\t}\n+      /* Correctly extend the result value.  */\n+      *val = wi::ext (sum_val, width, sgn);\n+    }\n+  else\n+    {\n+      /* Special case (no bits of multiplicand are known set).  */\n+      while (c != 0)\n+\t{\n+\t  /* Determine the lowest bit set in the multiplier.  */\n+\t  int bitpos = wi::ctz (c);\n+\t  widest_int term_mask = rmask << bitpos;\n+\n+\t  /* sum += term.  */\n+\t  widest_int hi = sum_mask + term_mask;\n+\t  sum_mask |= term_mask | hi;\n+\n+\t  /* Clear this bit in the multiplier.  */\n+\t  c ^= wi::lshift (1, bitpos);\n+\t}\n+      *val = 0;\n+    }\n+\n+  /* Correctly extend the result mask.  */\n+  *mask = wi::ext (sum_mask, width, sgn);\n+}\n+\n+\n /* Apply the operation CODE in type TYPE to the value, mask pairs\n    R1VAL, R1MASK and R2VAL, R2MASK representing a values of type R1TYPE\n    and R2TYPE and set the value, mask pair *VAL and *MASK to the result.  */\n@@ -1533,24 +1593,33 @@ bit_value_binop (enum tree_code code, signop sgn, int width,\n       }\n \n     case MULT_EXPR:\n-      {\n-\t/* Just track trailing zeros in both operands and transfer\n-\t   them to the other.  */\n-\tint r1tz = wi::ctz (r1val | r1mask);\n-\tint r2tz = wi::ctz (r2val | r2mask);\n-\tif (r1tz + r2tz >= width)\n-\t  {\n-\t    *mask = 0;\n-\t    *val = 0;\n-\t  }\n-\telse if (r1tz + r2tz > 0)\n-\t  {\n-\t    *mask = wi::ext (wi::mask <widest_int> (r1tz + r2tz, true),\n-\t\t\t     width, sgn);\n-\t    *val = 0;\n-\t  }\n-\tbreak;\n-      }\n+      if (r2mask == 0\n+\t  && !wi::neg_p (r2val, sgn)\n+\t  && (flag_expensive_optimizations || wi::popcount (r2val) < 8))\n+\tbit_value_mult_const (sgn, width, val, mask, r1val, r1mask, r2val);\n+      else if (r1mask == 0\n+\t       && !wi::neg_p (r1val, sgn)\n+\t       && (flag_expensive_optimizations || wi::popcount (r1val) < 8))\n+\tbit_value_mult_const (sgn, width, val, mask, r2val, r2mask, r1val);\n+      else\n+\t{\n+\t  /* Just track trailing zeros in both operands and transfer\n+\t     them to the other.  */\n+\t  int r1tz = wi::ctz (r1val | r1mask);\n+\t  int r2tz = wi::ctz (r2val | r2mask);\n+\t  if (r1tz + r2tz >= width)\n+\t    {\n+\t      *mask = 0;\n+\t      *val = 0;\n+\t    }\n+\t  else if (r1tz + r2tz > 0)\n+\t    {\n+\t      *mask = wi::ext (wi::mask <widest_int> (r1tz + r2tz, true),\n+\t\t\t       width, sgn);\n+\t      *val = 0;\n+\t    }\n+\t}\n+      break;\n \n     case EQ_EXPR:\n     case NE_EXPR:"}]}