{"sha": "4cfbc546d43ef8af69aa4597d9d8634393899402", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNmYmM1NDZkNDNlZjhhZjY5YWE0NTk3ZDlkODYzNDM5Mzg5OTQwMg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "1999-06-08T05:29:05Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "1999-06-08T05:29:05Z"}, "message": "except.c (complete_ptr_ref_or_void_ptr_p): New function, broken out of ...\n\n\t* except.c (complete_ptr_ref_or_void_ptr_p): New function, broken out\n\tof ...\n\t(build_throw): ... here. Call it.\n\t(process_start_catch_block): Call it.\n\nFrom-SVN: r27424", "tree": {"sha": "fc8a4271a3e6995a7bb54baeec33f8043ed0cd65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc8a4271a3e6995a7bb54baeec33f8043ed0cd65"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4cfbc546d43ef8af69aa4597d9d8634393899402", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cfbc546d43ef8af69aa4597d9d8634393899402", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cfbc546d43ef8af69aa4597d9d8634393899402", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cfbc546d43ef8af69aa4597d9d8634393899402/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c0a77c92721b07c404dda4101925896860de87ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0a77c92721b07c404dda4101925896860de87ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0a77c92721b07c404dda4101925896860de87ba"}], "stats": {"total": 64, "additions": 44, "deletions": 20}, "files": [{"sha": "136fd27689753b9ce1c2d67273c41266b4684d3b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cfbc546d43ef8af69aa4597d9d8634393899402/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cfbc546d43ef8af69aa4597d9d8634393899402/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4cfbc546d43ef8af69aa4597d9d8634393899402", "patch": "@@ -1,3 +1,10 @@\n+1999-06-08  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* except.c (complete_ptr_ref_or_void_ptr_p): New function, broken out\n+\tof ...\n+\t(build_throw): ... here. Call it.\n+\t(process_start_catch_block): Call it.\n+\n 1999-06-07  Mark Mitchell  <mark@codesourcery.com>\n \n \t* search.c (convert_pointer_to_single_level): Reimplement without"}, {"sha": "e24c75ea5f61b04e30e02d07aed87d14aca64314", "filename": "gcc/cp/except.c", "status": "modified", "additions": 37, "deletions": 20, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cfbc546d43ef8af69aa4597d9d8634393899402/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cfbc546d43ef8af69aa4597d9d8634393899402/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=4cfbc546d43ef8af69aa4597d9d8634393899402", "patch": "@@ -62,6 +62,7 @@ static void process_start_catch_block PROTO((tree, tree));\n static tree build_eh_type_type_ref PROTO((tree));\n static tree build_terminate_handler PROTO((void));\n static tree alloc_eh_object PROTO((tree));\n+static int complete_ptr_ref_or_void_ptr_p PROTO((tree, tree));\n \n #if 0\n /* This is the startup, and finish stuff per exception table.  */\n@@ -625,6 +626,8 @@ process_start_catch_block (declspecs, declarator)\n \n       if (decl == NULL_TREE)\n \terror (\"invalid catch parameter\");\n+      else if (!complete_ptr_ref_or_void_ptr_p (TREE_TYPE (decl), NULL_TREE))\n+        decl = NULL_TREE;\n     }\n \n   if (decl)\n@@ -1155,26 +1158,8 @@ build_throw (e)\n   \n   if (e != NULL_TREE)\n     {\n-      tree core;\n-      int is_ptr;\n-      \n-      /* Cannot throw an incomplete type. */\n-      e = require_complete_type (e);\n-      if (e == error_mark_node)\n-        return e;\n-      \n-      /* Or a pointer or ref to one, other than cv void *.  */\n-      core = TREE_TYPE (e);\n-      is_ptr = TREE_CODE (core) == POINTER_TYPE;\n-      if (is_ptr || TREE_CODE (core) == REFERENCE_TYPE)\n-        {\n-          core = TREE_TYPE (core);\n-      \n-          if (is_ptr && same_type_p (TYPE_MAIN_VARIANT (core), void_type_node))\n-            /* OK */;\n-          else if (!complete_type_or_else (core, NULL_TREE))\n-            return error_mark_node;\n-        }\n+      if (!complete_ptr_ref_or_void_ptr_p (TREE_TYPE (e), e))\n+        return error_mark_node;\n     }\n \n   e = build1 (THROW_EXPR, void_type_node, e);\n@@ -1183,3 +1168,35 @@ build_throw (e)\n \n   return e;\n }\n+\n+/* Make sure TYPE is complete, pointer to complete, reference to\n+   complete, or pointer to cv void. Issue diagnostic on failure.\n+   Return the zero on failure and non-zero on success. FROM can be\n+   the expr or decl from whence TYPE came, if available.  */\n+\n+static int\n+complete_ptr_ref_or_void_ptr_p (type, from)\n+     tree type;\n+     tree from;\n+{\n+  int is_ptr;\n+  \n+  /* Check complete.  */\n+  type = complete_type_or_else (type, from);\n+  if (!type)\n+    return 0;\n+  \n+  /* Or a pointer or ref to one, or cv void *.  */\n+  is_ptr = TREE_CODE (type) == POINTER_TYPE;\n+  if (is_ptr || TREE_CODE (type) == REFERENCE_TYPE)\n+    {\n+      tree core = TREE_TYPE (type);\n+  \n+      if (is_ptr && same_type_p (TYPE_MAIN_VARIANT (core), void_type_node))\n+        /* OK */;\n+      else if (!complete_type_or_else (core, from))\n+        return 0;\n+    }\n+  return 1;\n+}\n+"}]}