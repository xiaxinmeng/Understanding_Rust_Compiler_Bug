{"sha": "08272b85285330a9b36c2766ea91468d609aff35", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDgyNzJiODUyODUzMzBhOWIzNmMyNzY2ZWE5MTQ2OGQ2MDlhZmYzNQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2004-09-29T20:18:49Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2004-09-29T20:18:49Z"}, "message": "revert accidental checkin\n\nFrom-SVN: r88302", "tree": {"sha": "07c73627ceb28a617532526516355f252dba34ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07c73627ceb28a617532526516355f252dba34ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08272b85285330a9b36c2766ea91468d609aff35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08272b85285330a9b36c2766ea91468d609aff35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08272b85285330a9b36c2766ea91468d609aff35", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08272b85285330a9b36c2766ea91468d609aff35/comments", "author": null, "committer": null, "parents": [{"sha": "26aed92305eabb36c383c9178e01a3e0a7d1e830", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26aed92305eabb36c383c9178e01a3e0a7d1e830", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26aed92305eabb36c383c9178e01a3e0a7d1e830"}], "stats": {"total": 25, "additions": 8, "deletions": 17}, "files": [{"sha": "3e394ab43e8bb3d6ac8346ee275c312a67eb3d8a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08272b85285330a9b36c2766ea91468d609aff35/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08272b85285330a9b36c2766ea91468d609aff35/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=08272b85285330a9b36c2766ea91468d609aff35", "patch": "@@ -5239,7 +5239,7 @@ expand_static_init (tree decl, tree init)\n   if (DECL_FUNCTION_SCOPE_P (decl))\n     {\n       /* Emit code to perform this initialization but once.  */\n-      tree if_stmt = NULL_TREE, inner_if_stmt = NULL_TREE;\n+      tree if_stmt, inner_if_stmt = NULL_TREE;\n       tree then_clause, inner_then_clause = NULL_TREE;\n       tree guard, guard_addr, guard_addr_list;\n       tree acquire_fn, release_fn, abort_fn;\n@@ -5279,16 +5279,10 @@ expand_static_init (tree decl, tree init)\n       /* Create the guard variable.  */\n       guard = get_guard (decl);\n \n-      /* This optimization isn't safe on targets which can reorder loads,\n-\t via speculative execution, caching behavior or whatever.  In that\n-\t case we force synchronization in __cxa_guard_acquire.  */\n-      if (!targetm.reorders_loads || !flag_threadsafe_statics)\n-\t{\n-\t  /* Begin the conditional initialization.  */\n-\t  if_stmt = begin_if_stmt ();\n-\t  finish_if_stmt_cond (get_guard_cond (guard), if_stmt);\n-\t  then_clause = begin_compound_stmt (BCS_NO_SCOPE);\n-\t}\n+      /* Begin the conditional initialization.  */\n+      if_stmt = begin_if_stmt ();\n+      finish_if_stmt_cond (get_guard_cond (guard), if_stmt);\n+      then_clause = begin_compound_stmt (BCS_NO_SCOPE);\n \n       if (flag_threadsafe_statics)\n \t{\n@@ -5351,12 +5345,9 @@ expand_static_init (tree decl, tree init)\n \t  finish_if_stmt (inner_if_stmt);\n \t}\n \n-      if (!targetm.reorders_loads || !flag_threadsafe_statics)\n-\t{\n-\t  finish_compound_stmt (then_clause);\n-\t  finish_then_clause (if_stmt);\n-\t  finish_if_stmt (if_stmt);\n-\t}\n+      finish_compound_stmt (then_clause);\n+      finish_then_clause (if_stmt);\n+      finish_if_stmt (if_stmt);\n     }\n   else\n     static_aggregates = tree_cons (init, decl, static_aggregates);"}]}