{"sha": "938cda536019cd6a1bc0dd2346381185b420bbf8", "node_id": "C_kwDOANBUbNoAKDkzOGNkYTUzNjAxOWNkNmExYmMwZGQyMzQ2MzgxMTg1YjQyMGJiZjg", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2022-09-05T16:05:24Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2022-09-05T16:06:06Z"}, "message": "Fortran/openmp: Partial OpenMP 5.2 doacross and omp_cur_iteration support\n\nAdd the Fortran support to the ME/C/C++ commit\nr13-2388-ga651e6d59188da8992f8bfae2df1cb4e6316f9e6\n\ngcc/fortran/ChangeLog:\n\n\t* dump-parse-tree.cc (show_omp_namelist, show_omp_clauses): Handle\n\tomp_cur_iteration and distinguish doacross/depend.\n\t* gfortran.h (enum gfc_omp_depend_doacross_op): Renamed from\n\tgfc_omp_depend_op.\n\t(enum gfc_omp_depend_doacross_op): Add OMP_DOACROSS_SINK_FIRST,\n\tRename OMP_DEPEND_SINK to OMP_DOACROSS_SINK.\n\t(gfc_omp_namelist) Handle renaming, rename depend_op to\n\tdepend_doacross_op.\n\t(struct gfc_omp_clauses): Add doacross_source.\n\t* openmp.cc (gfc_match_omp_depend_sink): Renamed to ...\n\t(gfc_match_omp_doacross_sink): ... this; handle omp_all_memory.\n\t(enum omp_mask2): Add OMP_CLAUSE_DOACROSS.\n\t(gfc_match_omp_clauses): Handle 'doacross' and syntax changes to\n\tdepend.\n\t(gfc_match_omp_depobj): Simplify as sink/source are now impossible.\n\t(gfc_match_omp_ordered_depend): Request OMP_CLAUSE_DOACROSS.\n\t(resolve_omp_clauses): Update sink/source checks.\n\t(gfc_resolve_omp_directive): Resolve EXEC_OMP_ORDERED clauses.\n\t* parse.cc (decode_omp_directive): Handle 'ordered doacross'.\n\t* trans-openmp.cc (gfc_trans_omp_clauses): Handle doacross.\n\t(gfc_trans_omp_do): Fix OMP_FOR_ORIG_DECLS handling if 'ordered'\n\tclause is present.\n\t(gfc_trans_omp_depobj): Update for member name change.\n\nlibgomp/ChangeLog:\n\n\t* libgomp.texi (OpenMP 5.2): Update doacross/omp_cur_iteration status.\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/gomp/all-memory-1.f90: Update dg-error.\n\t* gfortran.dg/gomp/depend-iterator-2.f90: Likewise.\n\t* gfortran.dg/gomp/depobj-2.f90: Likewise.\n\t* gfortran.dg/gomp/doacross-5.f90: New test.\n\t* gfortran.dg/gomp/doacross-6.f90: New test.", "tree": {"sha": "78f0c5604425d3e2db0576f1a35066187750ea2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78f0c5604425d3e2db0576f1a35066187750ea2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/938cda536019cd6a1bc0dd2346381185b420bbf8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/938cda536019cd6a1bc0dd2346381185b420bbf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/938cda536019cd6a1bc0dd2346381185b420bbf8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/938cda536019cd6a1bc0dd2346381185b420bbf8/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4d8a56a4c62ba8bca55469ae2b841fb4e1334a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4d8a56a4c62ba8bca55469ae2b841fb4e1334a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4d8a56a4c62ba8bca55469ae2b841fb4e1334a4"}], "stats": {"total": 487, "additions": 370, "deletions": 117}, "files": [{"sha": "40c690c9ae8d68a68f99b5c2e6923b96aec7d572", "filename": "gcc/fortran/dump-parse-tree.cc", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/938cda536019cd6a1bc0dd2346381185b420bbf8/gcc%2Ffortran%2Fdump-parse-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/938cda536019cd6a1bc0dd2346381185b420bbf8/gcc%2Ffortran%2Fdump-parse-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.cc?ref=938cda536019cd6a1bc0dd2346381185b420bbf8", "patch": "@@ -1337,8 +1337,15 @@ show_omp_namelist (int list_type, gfc_omp_namelist *n)\n \t  if (n->u2.ns != ns_iter)\n \t    {\n \t      if (n != n2)\n-\t\tfputs (list_type == OMP_LIST_AFFINITY\n-\t\t       ? \") AFFINITY(\" : \") DEPEND(\", dumpfile);\n+\t\t{\n+\t\t  fputs (\") \", dumpfile);\n+\t\t  if (list_type == OMP_LIST_AFFINITY)\n+\t\t    fputs (\"AFFINITY (\", dumpfile);\n+\t\t  else if (n->u.depend_doacross_op == OMP_DOACROSS_SINK_FIRST)\n+\t\t    fputs (\"DOACROSS (\", dumpfile);\n+\t\t  else\n+\t\t    fputs (\"DEPEND (\", dumpfile);\n+\t\t}\n \t      if (n->u2.ns)\n \t\t{\n \t\t  fputs (\"ITERATOR(\", dumpfile);\n@@ -1374,7 +1381,7 @@ show_omp_namelist (int list_type, gfc_omp_namelist *n)\n \t  default: break;\n \t  }\n       else if (list_type == OMP_LIST_DEPEND)\n-\tswitch (n->u.depend_op)\n+\tswitch (n->u.depend_doacross_op)\n \t  {\n \t  case OMP_DEPEND_IN: fputs (\"in:\", dumpfile); break;\n \t  case OMP_DEPEND_OUT: fputs (\"out:\", dumpfile); break;\n@@ -1385,20 +1392,28 @@ show_omp_namelist (int list_type, gfc_omp_namelist *n)\n \t    fputs (\"mutexinoutset:\", dumpfile);\n \t    break;\n \t  case OMP_DEPEND_SINK_FIRST:\n+\t  case OMP_DOACROSS_SINK_FIRST:\n \t    fputs (\"sink:\", dumpfile);\n \t    while (1)\n \t      {\n-\t\tfprintf (dumpfile, \"%s\", n->sym->name);\n+\t\tif (!n->sym)\n+\t\t  fputs (\"omp_cur_iteration\", dumpfile);\n+\t\telse\n+\t\t  fprintf (dumpfile, \"%s\", n->sym->name);\n \t\tif (n->expr)\n \t\t  {\n \t\t    fputc ('+', dumpfile);\n \t\t    show_expr (n->expr);\n \t\t  }\n \t\tif (n->next == NULL)\n \t\t  break;\n-\t\telse if (n->next->u.depend_op != OMP_DEPEND_SINK)\n+\t\telse if (n->next->u.depend_doacross_op != OMP_DOACROSS_SINK)\n \t\t  {\n-\t\t    fputs (\") DEPEND(\", dumpfile);\n+\t\t    if (n->next->u.depend_doacross_op\n+\t\t\t== OMP_DOACROSS_SINK_FIRST)\n+\t\t      fputs (\") DOACROSS(\", dumpfile);\n+\t\t    else\n+\t\t      fputs (\") DEPEND(\", dumpfile);\n \t\t    break;\n \t\t  }\n \t\tfputc (',', dumpfile);\n@@ -1674,7 +1689,14 @@ show_omp_clauses (gfc_omp_clauses *omp_clauses)\n \t  case OMP_LIST_AFFINITY: type = \"AFFINITY\"; break;\n \t  case OMP_LIST_ALIGNED: type = \"ALIGNED\"; break;\n \t  case OMP_LIST_LINEAR: type = \"LINEAR\"; break;\n-\t  case OMP_LIST_DEPEND: type = \"DEPEND\"; break;\n+\t  case OMP_LIST_DEPEND:\n+\t    if (omp_clauses->lists[list_type]\n+\t\t&& (omp_clauses->lists[list_type]->u.depend_doacross_op\n+\t\t    == OMP_DOACROSS_SINK_FIRST))\n+\t      type = \"DOACROSS\";\n+\t    else\n+\t      type = \"DEPEND\";\n+\t    break;\n \t  case OMP_LIST_MAP: type = \"MAP\"; break;\n \t  case OMP_LIST_TO: type = \"TO\"; break;\n \t  case OMP_LIST_FROM: type = \"FROM\"; break;\n@@ -1894,6 +1916,8 @@ show_omp_clauses (gfc_omp_clauses *omp_clauses)\n     fputs (\" DESTROY\", dumpfile);\n   if (omp_clauses->depend_source)\n     fputs (\" DEPEND(source)\", dumpfile);\n+  if (omp_clauses->doacross_source)\n+    fputs (\" DOACROSS(source:)\", dumpfile);\n   if (omp_clauses->capture)\n     fputs (\" CAPTURE\", dumpfile);\n   if (omp_clauses->depobj_update != OMP_DEPEND_UNSET)"}, {"sha": "4babd77924b063d812737faa9f733aa4415de853", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/938cda536019cd6a1bc0dd2346381185b420bbf8/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/938cda536019cd6a1bc0dd2346381185b420bbf8/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=938cda536019cd6a1bc0dd2346381185b420bbf8", "patch": "@@ -1265,7 +1265,7 @@ enum gfc_omp_reduction_op\n   OMP_REDUCTION_USER\n };\n \n-enum gfc_omp_depend_op\n+enum gfc_omp_depend_doacross_op\n {\n   OMP_DEPEND_UNSET,\n   OMP_DEPEND_IN,\n@@ -1275,7 +1275,8 @@ enum gfc_omp_depend_op\n   OMP_DEPEND_MUTEXINOUTSET,\n   OMP_DEPEND_DEPOBJ,\n   OMP_DEPEND_SINK_FIRST,\n-  OMP_DEPEND_SINK\n+  OMP_DOACROSS_SINK_FIRST,\n+  OMP_DOACROSS_SINK\n };\n \n enum gfc_omp_map_op\n@@ -1343,7 +1344,7 @@ typedef struct gfc_omp_namelist\n   union\n     {\n       gfc_omp_reduction_op reduction_op;\n-      gfc_omp_depend_op depend_op;\n+      gfc_omp_depend_doacross_op depend_doacross_op;\n       gfc_omp_map_op map_op;\n       struct\n \t{\n@@ -1536,17 +1537,17 @@ typedef struct gfc_omp_clauses\n   unsigned nowait:1, ordered:1, untied:1, mergeable:1, ancestor:1;\n   unsigned inbranch:1, notinbranch:1, nogroup:1;\n   unsigned sched_simd:1, sched_monotonic:1, sched_nonmonotonic:1;\n-  unsigned simd:1, threads:1, depend_source:1, destroy:1, order_concurrent:1;\n+  unsigned simd:1, threads:1, doacross_source:1, depend_source:1, destroy:1;\n   unsigned order_unconstrained:1, order_reproducible:1, capture:1;\n   unsigned grainsize_strict:1, num_tasks_strict:1, compare:1, weak:1;\n-  unsigned non_rectangular:1;\n+  unsigned non_rectangular:1, order_concurrent:1;\n   ENUM_BITFIELD (gfc_omp_sched_kind) sched_kind:3;\n   ENUM_BITFIELD (gfc_omp_device_type) device_type:2;\n   ENUM_BITFIELD (gfc_omp_memorder) memorder:3;\n   ENUM_BITFIELD (gfc_omp_memorder) fail:3;\n   ENUM_BITFIELD (gfc_omp_cancel_kind) cancel:3;\n   ENUM_BITFIELD (gfc_omp_proc_bind_kind) proc_bind:3;\n-  ENUM_BITFIELD (gfc_omp_depend_op) depobj_update:4;\n+  ENUM_BITFIELD (gfc_omp_depend_doacross_op) depobj_update:4;\n   ENUM_BITFIELD (gfc_omp_bind_type) bind:2;\n   ENUM_BITFIELD (gfc_omp_at_type) at:2;\n   ENUM_BITFIELD (gfc_omp_severity_type) severity:2;"}, {"sha": "5142fd7c608f9ff47c9f6f9c3040b9c6b14da292", "filename": "gcc/fortran/openmp.cc", "status": "modified", "additions": 134, "deletions": 84, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/938cda536019cd6a1bc0dd2346381185b420bbf8/gcc%2Ffortran%2Fopenmp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/938cda536019cd6a1bc0dd2346381185b420bbf8/gcc%2Ffortran%2Fopenmp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.cc?ref=938cda536019cd6a1bc0dd2346381185b420bbf8", "patch": "@@ -575,11 +575,13 @@ gfc_match_omp_detach (gfc_expr **expr)\n \n }\n \n-/* Match depend(sink : ...) construct a namelist from it.  */\n+/* Match doacross(sink : ...) construct a namelist from it;\n+   if depend is true, match legacy 'depend(sink : ...)'.  */\n \n static match\n-gfc_match_omp_depend_sink (gfc_omp_namelist **list)\n+gfc_match_omp_doacross_sink (gfc_omp_namelist **list, bool depend)\n {\n+  char n[GFC_MAX_SYMBOL_LEN+1];\n   gfc_omp_namelist *head, *tail, *p;\n   locus old_loc, cur_loc;\n   gfc_symbol *sym;\n@@ -591,49 +593,51 @@ gfc_match_omp_depend_sink (gfc_omp_namelist **list)\n   for (;;)\n     {\n       cur_loc = gfc_current_locus;\n-      switch (gfc_match_symbol (&sym, 1))\n+\n+      if (gfc_match_name (n) != MATCH_YES)\n+\tgoto syntax;\n+      if (UNLIKELY (strcmp (n, \"omp_all_memory\") == 0))\n \t{\n-\tcase MATCH_YES:\n-\t  gfc_set_sym_referenced (sym);\n-\t  p = gfc_get_omp_namelist ();\n-\t  if (head == NULL)\n-\t    {\n-\t      head = tail = p;\n-\t      head->u.depend_op = OMP_DEPEND_SINK_FIRST;\n-\t    }\n-\t  else\n-\t    {\n-\t      tail->next = p;\n-\t      tail = tail->next;\n-\t      tail->u.depend_op = OMP_DEPEND_SINK;\n-\t    }\n-\t  tail->sym = sym;\n-\t  tail->expr = NULL;\n-\t  tail->where = cur_loc;\n-\t  if (UNLIKELY (strcmp (sym->name, \"omp_all_memory\") == 0))\n-\t    {\n-\t      gfc_error (\"%<omp_all_memory%> used with DEPEND kind \"\n-\t\t\t \"other than OUT or INOUT at %C\");\n-\t      goto cleanup;\n-\t    }\n-\t  if (gfc_match_char ('+') == MATCH_YES)\n-\t    {\n-\t      if (gfc_match_literal_constant (&tail->expr, 0) != MATCH_YES)\n-\t\tgoto syntax;\n-\t    }\n-\t  else if (gfc_match_char ('-') == MATCH_YES)\n-\t    {\n-\t      if (gfc_match_literal_constant (&tail->expr, 0) != MATCH_YES)\n-\t\tgoto syntax;\n-\t      tail->expr = gfc_uminus (tail->expr);\n-\t    }\n-\t  break;\n-\tcase MATCH_NO:\n-\t  goto syntax;\n-\tcase MATCH_ERROR:\n+\t  gfc_error (\"%<omp_all_memory%> used with dependence-type \"\n+\t\t     \"other than OUT or INOUT at %C\");\n \t  goto cleanup;\n \t}\n-\n+      sym = NULL;\n+      if (!(strcmp (n, \"omp_cur_iteration\") == 0))\n+\t{\n+\t  gfc_symtree *st;\n+\t  if (gfc_get_ha_sym_tree (n, &st))\n+\t    goto syntax;\n+\t  sym = st->n.sym;\n+\t  gfc_set_sym_referenced (sym);\n+\t}\n+      p = gfc_get_omp_namelist ();\n+      if (head == NULL)\n+\t{\n+\t  head = tail = p;\n+\t  head->u.depend_doacross_op = (depend ? OMP_DEPEND_SINK_FIRST\n+\t\t\t\t\t       : OMP_DOACROSS_SINK_FIRST);\n+\t}\n+      else\n+\t{\n+\t  tail->next = p;\n+\t  tail = tail->next;\n+\t  tail->u.depend_doacross_op = OMP_DOACROSS_SINK;\n+\t}\n+      tail->sym = sym;\n+      tail->expr = NULL;\n+      tail->where = cur_loc;\n+      if (gfc_match_char ('+') == MATCH_YES)\n+\t{\n+\t  if (gfc_match_literal_constant (&tail->expr, 0) != MATCH_YES)\n+\t    goto syntax;\n+\t}\n+      else if (gfc_match_char ('-') == MATCH_YES)\n+\t{\n+\t  if (gfc_match_literal_constant (&tail->expr, 0) != MATCH_YES)\n+\t    goto syntax;\n+\t  tail->expr = gfc_uminus (tail->expr);\n+\t}\n       if (gfc_match_char (')') == MATCH_YES)\n \tbreak;\n       if (gfc_match_char (',') != MATCH_YES)\n@@ -647,7 +651,7 @@ gfc_match_omp_depend_sink (gfc_omp_namelist **list)\n   return MATCH_YES;\n \n syntax:\n-  gfc_error (\"Syntax error in OpenMP DEPEND SINK list at %C\");\n+  gfc_error (\"Syntax error in OpenMP SINK dependence-type list at %C\");\n \n cleanup:\n   gfc_free_omp_namelist (head, false);\n@@ -987,6 +991,7 @@ enum omp_mask2\n   OMP_CLAUSE_NOHOST,\n   OMP_CLAUSE_HAS_DEVICE_ADDR,  /* OpenMP 5.1  */\n   OMP_CLAUSE_ENTER, /* OpenMP 5.2 */\n+  OMP_CLAUSE_DOACROSS, /* OpenMP 5.2 */\n   /* This must come last.  */\n   OMP_MASK2_LAST\n };\n@@ -1903,18 +1908,26 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t\t\t\t\t   OMP_MAP_RELEASE, true,\n \t\t\t\t\t   allow_derived))\n \t    continue;\n-\t  if ((mask & OMP_CLAUSE_DEPEND)\n-\t      && gfc_match (\"depend ( \") == MATCH_YES)\n+\t  /* DOACROSS: match 'doacross' and 'depend' with sink/source.\n+\t     DEPEND: match 'depend' but not sink/source.  */\n+\t  m = MATCH_NO;\n+\t  if (((mask & OMP_CLAUSE_DOACROSS)\n+\t       && gfc_match (\"doacross ( \") == MATCH_YES)\n+\t      || (((mask & OMP_CLAUSE_DEPEND) || (mask & OMP_CLAUSE_DOACROSS))\n+\t\t  && (m = gfc_match (\"depend ( \")) == MATCH_YES))\n \t    {\n \t      bool has_omp_all_memory;\n+\t      bool is_depend = m == MATCH_YES;\n \t      gfc_namespace *ns_iter = NULL, *ns_curr = gfc_current_ns;\n-\t      match m_it = gfc_match_iterator (&ns_iter, false);\n+\t      match m_it = MATCH_NO;\n+\t      if (is_depend)\n+\t\tm_it = gfc_match_iterator (&ns_iter, false);\n \t      if (m_it == MATCH_ERROR)\n \t\tbreak;\n \t      if (m_it == MATCH_YES && gfc_match (\" , \") != MATCH_YES)\n \t\tbreak;\n \t      m = MATCH_YES;\n-\t      gfc_omp_depend_op depend_op = OMP_DEPEND_OUT;\n+\t      gfc_omp_depend_doacross_op depend_op = OMP_DEPEND_OUT;\n \t      if (gfc_match (\"inoutset\") == MATCH_YES)\n \t\tdepend_op = OMP_DEPEND_INOUTSET;\n \t      else if (gfc_match (\"inout\") == MATCH_YES)\n@@ -1927,34 +1940,77 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t\tdepend_op = OMP_DEPEND_MUTEXINOUTSET;\n \t      else if (gfc_match (\"depobj\") == MATCH_YES)\n \t\tdepend_op = OMP_DEPEND_DEPOBJ;\n-\t      else if (!c->depend_source\n-\t\t       && gfc_match (\"source )\") == MATCH_YES)\n+\t      else if (gfc_match (\"source\") == MATCH_YES)\n \t\t{\n \t\t  if (m_it == MATCH_YES)\n \t\t    {\n \t\t      gfc_error (\"ITERATOR may not be combined with SOURCE \"\n \t\t\t\t \"at %C\");\n-\t\t      gfc_free_omp_clauses (c);\n-\t\t      return MATCH_ERROR;\n+\t\t      goto error;\n+\t\t    }\n+\t\t  if (!(mask & OMP_CLAUSE_DOACROSS))\n+\t\t    {\n+\t\t      gfc_error (\"SOURCE at %C not permitted as dependence-type\"\n+\t\t\t\t \" for this directive\");\n+\t\t      goto error;\n+\t\t    }\n+\t\t  if (c->doacross_source)\n+\t\t    {\n+\t\t      gfc_error (\"Duplicated clause with SOURCE dependence-type\"\n+\t\t\t\t \" at %C\");\n+\t\t      goto error;\n+\t\t    }\n+\t\t  gfc_gobble_whitespace ();\n+\t\t  m = gfc_match (\": \");\n+\t\t  if (m != MATCH_YES && !is_depend)\n+\t\t    {\n+\t\t      gfc_error (\"Expected %<:%> at %C\");\n+\t\t      goto error;\n \t\t    }\n-\t\t  c->depend_source = true;\n+\t\t  if (gfc_match (\")\") != MATCH_YES\n+\t\t      && !(m == MATCH_YES\n+\t\t\t   && gfc_match (\"omp_cur_iteration )\") == MATCH_YES))\n+\t\t    {\n+\t\t      gfc_error (\"Expected %<)%> or %<omp_cur_iteration)%> \"\n+\t\t\t\t \"at %C\");\n+\t\t      goto error;\n+\t\t    }\n+\t\t  c->doacross_source = true;\n+\t\t  c->depend_source = is_depend;\n \t\t  continue;\n \t\t}\n-\t      else if (gfc_match (\"sink : \") == MATCH_YES)\n+\t      else if (gfc_match (\"sink \") == MATCH_YES)\n \t\t{\n+\t\t  if (!(mask & OMP_CLAUSE_DOACROSS))\n+\t\t    {\n+\t\t      gfc_error (\"SINK at %C not permitted as dependence-type \"\n+\t\t\t\t \"for this directive\");\n+\t\t      goto error;\n+\t\t    }\n+\t\t  if (gfc_match (\": \") != MATCH_YES)\n+\t\t    {\n+\t\t      gfc_error (\"Expected %<:%> at %C\");\n+\t\t      goto error;\n+\t\t    }\n \t\t  if (m_it == MATCH_YES)\n \t\t    {\n \t\t      gfc_error (\"ITERATOR may not be combined with SINK \"\n \t\t\t\t \"at %C\");\n-\t\t      break;\n+\t\t      goto error;\n \t\t    }\n-\t\t  if (gfc_match_omp_depend_sink (&c->lists[OMP_LIST_DEPEND])\n-\t\t      == MATCH_YES)\n+\t\t  m = gfc_match_omp_doacross_sink (&c->lists[OMP_LIST_DEPEND],\n+\t\t\t\t\t\t   is_depend);\n+\t\t  if (m == MATCH_YES)\n \t\t    continue;\n-\t\t  m = MATCH_NO;\n+\t\t  goto error;\n \t\t}\n \t      else\n \t\tm = MATCH_NO;\n+\t      if (!(mask & OMP_CLAUSE_DEPEND))\n+\t\t{\n+\t\t  gfc_error (\"Expected dependence-type SINK or SOURCE at %C\");\n+\t\t  goto error;\n+\t\t}\n \t      head = NULL;\n \t      if (ns_iter)\n \t\tgfc_current_ns = ns_iter;\n@@ -1976,7 +2032,7 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t      gfc_omp_namelist *n;\n \t      for (n = *head; n; n = n->next)\n \t\t{\n-\t\t  n->u.depend_op = depend_op;\n+\t\t  n->u.depend_doacross_op = depend_op;\n \t\t  n->u2.ns = ns_iter;\n \t\t  if (ns_iter)\n \t\t    ns_iter->refs++;\n@@ -3971,18 +4027,15 @@ gfc_match_omp_depobj (void)\n \n   if (c->depobj_update == OMP_DEPEND_UNSET && !c->destroy)\n     {\n-      if (!c->depend_source && !c->lists[OMP_LIST_DEPEND])\n+      if (!c->doacross_source && !c->lists[OMP_LIST_DEPEND])\n \t{\n \t  gfc_error (\"Expected DEPEND, UPDATE, or DESTROY clause at %C\");\n \t  goto error;\n \t}\n-      if (c->depend_source\n-\t  || c->lists[OMP_LIST_DEPEND]->u.depend_op == OMP_DEPEND_SINK_FIRST\n-\t  || c->lists[OMP_LIST_DEPEND]->u.depend_op == OMP_DEPEND_SINK\n-\t  || c->lists[OMP_LIST_DEPEND]->u.depend_op == OMP_DEPEND_DEPOBJ)\n+      if (c->lists[OMP_LIST_DEPEND]->u.depend_doacross_op == OMP_DEPEND_DEPOBJ)\n \t{\n \t  gfc_error (\"DEPEND clause at %L of OMP DEPOBJ construct shall not \"\n-\t\t     \"have dependence-type SOURCE, SINK or DEPOBJ\",\n+\t\t     \"have dependence-type DEPOBJ\",\n \t\t     c->lists[OMP_LIST_DEPEND]\n \t\t     ? &c->lists[OMP_LIST_DEPEND]->where : &gfc_current_locus);\n \t  goto error;\n@@ -5988,7 +6041,7 @@ gfc_match_omp_nothing (void)\n match\n gfc_match_omp_ordered_depend (void)\n {\n-  return match_omp (EXEC_OMP_ORDERED, omp_mask (OMP_CLAUSE_DEPEND));\n+  return match_omp (EXEC_OMP_ORDERED, omp_mask (OMP_CLAUSE_DOACROSS));\n }\n \n \n@@ -7057,18 +7110,16 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \n \t\tif (list == OMP_LIST_DEPEND)\n \t\t  {\n-\t\t    if (n->u.depend_op == OMP_DEPEND_SINK_FIRST\n-\t\t\t|| n->u.depend_op == OMP_DEPEND_SINK)\n+\t\t    if (n->u.depend_doacross_op == OMP_DEPEND_SINK_FIRST\n+\t\t\t|| n->u.depend_doacross_op == OMP_DOACROSS_SINK_FIRST\n+\t\t\t|| n->u.depend_doacross_op == OMP_DOACROSS_SINK)\n \t\t      {\n-\t\t\tif (code->op != EXEC_OMP_ORDERED)\n-\t\t\t  gfc_error (\"SINK dependence type only allowed \"\n-\t\t\t\t     \"on ORDERED directive at %L\", &n->where);\n-\t\t\telse if (omp_clauses->depend_source)\n+\t\t\tif (omp_clauses->doacross_source)\n \t\t\t  {\n-\t\t\t    gfc_error (\"DEPEND SINK used together with \"\n-\t\t\t\t       \"DEPEND SOURCE on the same construct \"\n-\t\t\t\t       \"at %L\", &n->where);\n-\t\t\t    omp_clauses->depend_source = false;\n+\t\t\t    gfc_error (\"Dependence-type SINK used together with\"\n+\t\t\t\t       \" SOURCE on the same construct at %L\",\n+\t\t\t\t       &n->where);\n+\t\t\t    omp_clauses->doacross_source = false;\n \t\t\t  }\n \t\t\telse if (n->expr)\n \t\t\t  {\n@@ -7078,13 +7129,14 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \t\t\t      gfc_error (\"SINK addend not a constant integer \"\n \t\t\t\t\t \"at %L\", &n->where);\n \t\t\t  }\n+\t\t\tif (n->sym == NULL\n+\t\t\t    && (n->expr == NULL\n+\t\t\t\t|| mpz_cmp_si (n->expr->value.integer, -1) != 0))\n+\t\t\t  gfc_error (\"omp_cur_iteration at %L requires %<-1%> \"\n+\t\t\t\t     \"as logical offset\", &n->where);\n \t\t\tcontinue;\n \t\t      }\n-\t\t    else if (code->op == EXEC_OMP_ORDERED)\n-\t\t      gfc_error (\"Only SOURCE or SINK dependence types \"\n-\t\t\t\t \"are allowed on ORDERED directive at %L\",\n-\t\t\t\t &n->where);\n-\t\t    else if (n->u.depend_op == OMP_DEPEND_DEPOBJ\n+\t\t    else if (n->u.depend_doacross_op == OMP_DEPEND_DEPOBJ\n \t\t\t     && !n->expr\n \t\t\t     && (n->sym->ts.type != BT_INTEGER\n \t\t\t\t || n->sym->ts.kind\n@@ -7094,7 +7146,7 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \t\t\t\t \"type shall be a scalar integer of \"\n \t\t\t\t \"OMP_DEPEND_KIND kind\", n->sym->name,\n \t\t\t\t &n->where);\n-\t\t    else if (n->u.depend_op == OMP_DEPEND_DEPOBJ\n+\t\t    else if (n->u.depend_doacross_op == OMP_DEPEND_DEPOBJ\n \t\t\t     && n->expr\n \t\t\t     && (!gfc_resolve_expr (n->expr)\n \t\t\t\t || n->expr->ts.type != BT_INTEGER\n@@ -7760,9 +7812,6 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n     resolve_scalar_int_expr (el->expr, \"WAIT\");\n   if (omp_clauses->collapse && omp_clauses->tile_list)\n     gfc_error (\"Incompatible use of TILE and COLLAPSE at %L\", &code->loc);\n-  if (omp_clauses->depend_source && code->op != EXEC_OMP_ORDERED)\n-    gfc_error (\"SOURCE dependence type only allowed \"\n-\t       \"on ORDERED directive at %L\", &code->loc);\n   if (omp_clauses->message)\n     {\n       gfc_expr *expr = omp_clauses->message;\n@@ -9565,6 +9614,7 @@ gfc_resolve_omp_directive (gfc_code *code, gfc_namespace *ns)\n     case EXEC_OMP_CANCEL:\n     case EXEC_OMP_ERROR:\n     case EXEC_OMP_MASKED:\n+    case EXEC_OMP_ORDERED:\n     case EXEC_OMP_PARALLEL_WORKSHARE:\n     case EXEC_OMP_PARALLEL:\n     case EXEC_OMP_PARALLEL_MASKED:"}, {"sha": "5b13441912a062b7fbb1a5c8e0f5faa597cabb32", "filename": "gcc/fortran/parse.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/938cda536019cd6a1bc0dd2346381185b420bbf8/gcc%2Ffortran%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/938cda536019cd6a1bc0dd2346381185b420bbf8/gcc%2Ffortran%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.cc?ref=938cda536019cd6a1bc0dd2346381185b420bbf8", "patch": "@@ -1026,7 +1026,8 @@ decode_omp_directive (void)\n       matcho (\"loop\", gfc_match_omp_loop, ST_OMP_LOOP);\n       break;\n     case 'o':\n-      if (gfc_match (\"ordered depend (\") == MATCH_YES)\n+      if (gfc_match (\"ordered depend (\") == MATCH_YES\n+\t  || gfc_match (\"ordered doacross (\") == MATCH_YES)\n \t{\n \t  gfc_current_locus = old_locus;\n \t  if (!flag_openmp)"}, {"sha": "1be7d23f86bab352182427016a5b5c9a3e85b0c3", "filename": "gcc/fortran/trans-openmp.cc", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/938cda536019cd6a1bc0dd2346381185b420bbf8/gcc%2Ffortran%2Ftrans-openmp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/938cda536019cd6a1bc0dd2346381185b420bbf8/gcc%2Ffortran%2Ftrans-openmp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.cc?ref=938cda536019cd6a1bc0dd2346381185b420bbf8", "patch": "@@ -2864,15 +2864,18 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\tgfc_init_block (&iter_block);\n \t      prev = n;\n \t      if (list == OMP_LIST_DEPEND\n-\t\t  && n->u.depend_op == OMP_DEPEND_SINK_FIRST)\n+\t\t  && (n->u.depend_doacross_op == OMP_DOACROSS_SINK_FIRST\n+\t\t      || n->u.depend_doacross_op == OMP_DEPEND_SINK_FIRST))\n \t\t{\n \t\t  tree vec = NULL_TREE;\n \t\t  unsigned int i;\n+\t\t  bool is_depend\n+\t\t    = n->u.depend_doacross_op == OMP_DEPEND_SINK_FIRST;\n \t\t  for (i = 0; ; i++)\n \t\t    {\n \t\t      tree addend = integer_zero_node, t;\n \t\t      bool neg = false;\n-\t\t      if (n->expr)\n+\t\t      if (n->sym && n->expr)\n \t\t\t{\n \t\t\t  addend = gfc_conv_constant_to_tree (n->expr);\n \t\t\t  if (TREE_CODE (addend) == INTEGER_CST\n@@ -2883,7 +2886,11 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t\t\t\t\t   TREE_TYPE (addend), addend);\n \t\t\t    }\n \t\t\t}\n-\t\t      t = gfc_trans_omp_variable (n->sym, false);\n+\n+\t\t      if (n->sym == NULL)\n+\t\t\tt = null_pointer_node;  /* \"omp_cur_iteration - 1\".  */\n+\t\t      else\n+\t\t\tt = gfc_trans_omp_variable (n->sym, false);\n \t\t      if (t != error_mark_node)\n \t\t\t{\n \t\t\t  if (i < vec_safe_length (doacross_steps)\n@@ -2900,7 +2907,7 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t\t    OMP_CLAUSE_DOACROSS_SINK_NEGATIVE (vec) = 1;\n \t\t\t}\n \t\t      if (n->next == NULL\n-\t\t\t  || n->next->u.depend_op != OMP_DEPEND_SINK)\n+\t\t\t  || n->next->u.depend_doacross_op != OMP_DOACROSS_SINK)\n \t\t\tbreak;\n \t\t      n = n->next;\n \t\t    }\n@@ -2910,7 +2917,7 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t  tree node = build_omp_clause (input_location,\n \t\t\t\t\t\tOMP_CLAUSE_DOACROSS);\n \t\t  OMP_CLAUSE_DOACROSS_KIND (node) = OMP_CLAUSE_DOACROSS_SINK;\n-\t\t  OMP_CLAUSE_DOACROSS_DEPEND (node) = 1;\n+\t\t  OMP_CLAUSE_DOACROSS_DEPEND (node) = is_depend;\n \t\t  OMP_CLAUSE_DECL (node) = nreverse (vec);\n \t\t  omp_clauses = gfc_trans_add_clause (node, omp_clauses);\n \t\t  continue;\n@@ -2962,7 +2969,7 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t  OMP_CLAUSE_DECL (node) = build_fold_indirect_ref (ptr);\n \t\t}\n \t      if (list == OMP_LIST_DEPEND)\n-\t\tswitch (n->u.depend_op)\n+\t\tswitch (n->u.depend_doacross_op)\n \t\t  {\n \t\t  case OMP_DEPEND_IN:\n \t\t    OMP_CLAUSE_DEPEND_KIND (node) = OMP_CLAUSE_DEPEND_IN;\n@@ -4253,11 +4260,11 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n       omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n     }\n \n-  if (clauses->depend_source)\n+  if (clauses->doacross_source)\n     {\n       c = build_omp_clause (gfc_get_location (&where), OMP_CLAUSE_DOACROSS);\n       OMP_CLAUSE_DOACROSS_KIND (c) = OMP_CLAUSE_DOACROSS_SOURCE;\n-      OMP_CLAUSE_DOACROSS_DEPEND (c) = 1;\n+      OMP_CLAUSE_DOACROSS_DEPEND (c) = clauses->depend_source;\n       omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n     }\n \n@@ -5119,7 +5126,7 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n   init = make_tree_vec (collapse);\n   cond = make_tree_vec (collapse);\n   incr = make_tree_vec (collapse);\n-  orig_decls = clauses->orderedc ? make_tree_vec (collapse) : NULL_TREE;\n+  orig_decls = clauses->ordered ? make_tree_vec (collapse) : NULL_TREE;\n \n   if (pblock == NULL)\n     {\n@@ -5219,6 +5226,10 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n \t\t\t\t\t\t    MODIFY_EXPR,\n \t\t\t\t\t\t    type, dovar,\n \t\t\t\t\t\t    TREE_VEC_ELT (incr, i));\n+\t  if (orig_decls && !clauses->orderedc)\n+\t    orig_decls = NULL;\n+\t  else if (orig_decls)\n+\t    TREE_VEC_ELT (orig_decls, i) = dovar_decl;\n \t}\n       else\n \t{\n@@ -5259,9 +5270,9 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n \t\tvec_safe_grow_cleared (doacross_steps, clauses->orderedc, true);\n \t      (*doacross_steps)[i] = step;\n \t    }\n+\t  if (orig_decls)\n+\t    TREE_VEC_ELT (orig_decls, i) = dovar_decl;\n \t}\n-      if (orig_decls)\n-\tTREE_VEC_ELT (orig_decls, i) = dovar_decl;\n \n       if (dovar_found == 3\n \t  && op == EXEC_OMP_SIMD\n@@ -5628,7 +5639,7 @@ gfc_trans_omp_depobj (gfc_code *code)\n   int k = -1; /* omp_clauses->destroy */\n   if (!code->ext.omp_clauses->destroy)\n     switch (code->ext.omp_clauses->depobj_update != OMP_DEPEND_UNSET\n-\t    ? code->ext.omp_clauses->depobj_update : n->u.depend_op)\n+\t    ? code->ext.omp_clauses->depobj_update : n->u.depend_doacross_op)\n       {\n       case OMP_DEPEND_IN: k = GOMP_DEPEND_IN; break;\n       case OMP_DEPEND_OUT: k = GOMP_DEPEND_OUT; break;"}, {"sha": "51b5633adbab6bdd6fb4475250dac57b16c3e2b2", "filename": "gcc/testsuite/gfortran.dg/gomp/all-memory-1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/938cda536019cd6a1bc0dd2346381185b420bbf8/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fall-memory-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/938cda536019cd6a1bc0dd2346381185b420bbf8/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fall-memory-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fall-memory-1.f90?ref=938cda536019cd6a1bc0dd2346381185b420bbf8", "patch": "@@ -50,5 +50,5 @@ subroutine f6\n   !$omp target depend ( depobj : omp_all_memory)  ! { dg-error \"'omp_all_memory' used with DEPEND kind other than OUT or INOUT\" }\n   !!$omp end target\n \n-  !$omp ordered depend ( sink : omp_all_memory)  ! { dg-error \"'omp_all_memory' used with DEPEND kind other than OUT or INOUT\" }\n+  !$omp ordered depend ( sink : omp_all_memory)  ! { dg-error \"used with dependence-type other than OUT or INOUT\" }\n end"}, {"sha": "cadd9a06cfec21b44cbd5b66e89e3fd315aa4052", "filename": "gcc/testsuite/gfortran.dg/gomp/depend-iterator-2.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/938cda536019cd6a1bc0dd2346381185b420bbf8/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdepend-iterator-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/938cda536019cd6a1bc0dd2346381185b420bbf8/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdepend-iterator-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdepend-iterator-2.f90?ref=938cda536019cd6a1bc0dd2346381185b420bbf8", "patch": "@@ -34,7 +34,7 @@ program main\n       !!$omp end task\n     !$omp task depend(iterator(i=1:5), source )  ! { dg-error \"ITERATOR may not be combined with SOURCE\" }\n   !!$omp end task\n-  !$omp task affinity (iterator(i=1:5): a) depend(iterator(i=1:5), sink : x) ! { dg-error \"ITERATOR may not be combined with SINK\" }\n+  !$omp task affinity (iterator(i=1:5): a) depend(iterator(i=1:5), sink : x) ! { dg-error \"SINK at .1. not permitted as dependence-type for this directive\" }\n   !!$omp end task\n \n     end do"}, {"sha": "6e7441d8d00e19db565abe8436a45676e5c5b388", "filename": "gcc/testsuite/gfortran.dg/gomp/depobj-2.f90", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/938cda536019cd6a1bc0dd2346381185b420bbf8/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdepobj-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/938cda536019cd6a1bc0dd2346381185b420bbf8/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdepobj-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdepobj-2.f90?ref=938cda536019cd6a1bc0dd2346381185b420bbf8", "patch": "@@ -21,13 +21,13 @@ subroutine f1\n   !$omp depobj(d) depend( inout : a)                 ! { dg-error \"DEPOBJ in DEPOBJ construct at .1. shall be a scalar integer of OMP_DEPEND_KIND kind\" }\n   !$omp depobj(depobj) depend( inout : a, b)         ! { dg-error \"DEPEND clause at .1. of OMP DEPOBJ construct shall have only a single locator\" }\n   !$omp depobj(depobj) depend(mutexinoutset : a)     ! OK\n-  !$omp depobj(depobj) depend(source)                ! { dg-error \"DEPEND clause at .1. of OMP DEPOBJ construct shall not have dependence-type SOURCE, SINK or DEPOBJ\" }\n-  !$omp depobj(depobj) depend(sink : i + 1)          ! { dg-error \"DEPEND clause at .1. of OMP DEPOBJ construct shall not have dependence-type SOURCE, SINK or DEPOBJ\" }\n+  !$omp depobj(depobj) depend(source)                ! { dg-error \"SOURCE at .1. not permitted as dependence-type for this directive\" }\n+  !$omp depobj(depobj) depend(sink : i + 1)          ! { dg-error \"SINK at .1. not permitted as dependence-type for this directive\" }\n   !$omp depobj(depobj) update(source)                ! { dg-error \"Expected IN, OUT, INOUT, INOUTSET or MUTEXINOUTSET followed by '\\\\)'\" }\n   !$omp depobj(depobj) update(sink)                  ! { dg-error \"Expected IN, OUT, INOUT, INOUTSET or MUTEXINOUTSET followed by '\\\\)'\" }\n   !$omp depobj(depobj) update(depobj)                ! { dg-error \"Expected IN, OUT, INOUT, INOUTSET or MUTEXINOUTSET followed by '\\\\)'\" }\n \n   ! Valid in OpenMP 5.1:\n-  !$omp depobj(depobj5) depend(depobj: depobj3)      ! { dg-error \"DEPEND clause at .1. of OMP DEPOBJ construct shall not have dependence-type SOURCE, SINK or DEPOBJ\" }\n+  !$omp depobj(depobj5) depend(depobj: depobj3)      ! { dg-error \"DEPEND clause at .1. of OMP DEPOBJ construct shall not have dependence-type DEPOBJ\" }\n end subroutine f1\n "}, {"sha": "3a1679a1eec2dad53841a0fd3912d090d7520d0f", "filename": "gcc/testsuite/gfortran.dg/gomp/doacross-5.f90", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/938cda536019cd6a1bc0dd2346381185b420bbf8/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdoacross-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/938cda536019cd6a1bc0dd2346381185b420bbf8/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdoacross-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdoacross-5.f90?ref=938cda536019cd6a1bc0dd2346381185b420bbf8", "patch": "@@ -0,0 +1,88 @@\n+subroutine foo (n)\n+  integer i, n\n+\n+  !$omp do ordered\n+  do i = 1, 8, n\n+    !$omp ordered doacross(source:)\n+    !$omp ordered doacross(sink: i - 2)\n+  end do\n+end\n+\n+subroutine bar (n)\n+  integer :: i, j, n\n+\n+  !$omp do collapse(2) ordered(2)\n+  do i = 1, 8, n\n+    do j = 1, 8, n\n+      !$omp ordered doacross(source:omp_cur_iteration)\n+      !$omp ordered doacross(sink: i - 2, j + 2)\n+    end do\n+  end do\n+end\n+\n+subroutine baz ()\n+  integer :: i, j\n+\n+  !$omp do ordered(1)\n+  do i = 1, 64\n+    !$omp ordered\t\t\t! { dg-error \"'ordered' construct without 'doacross' or 'depend' clauses must not have the same binding region as 'ordered' construct with those clauses\" }\n+    !$omp end ordered\n+\n+    !$omp ordered doacross(source:)\n+\n+    !$omp ordered doacross(sink: i - 1)\n+  end do\n+\n+  !$omp do ordered\n+  do i = 1, 64\n+    !$omp ordered doacross(source: omp_cur_iteration )\n+\n+    !$omp ordered doacross(sink: i - 1)\n+\n+    !$omp ordered threads\t\t! { dg-error \"'ordered' construct without 'doacross' or 'depend' clauses must not have the same binding region as 'ordered' construct with those clauses\" }\n+    !$omp end ordered\n+  end do\n+  !$omp do ordered(2)\n+  do i = 1, 64\n+    do j = 1, 64\n+\t!$omp ordered\t\t\t! { dg-error \"'ordered' construct without 'doacross' or 'depend' clauses binds to loop where 'collapse' argument 1 is different from 'ordered' argument 2\" }\n+\t!$omp end ordered\n+    end do\n+  end do\n+  !$omp do ordered(2) collapse(1)\n+  do i = 1, 8\n+    do j = 1, 8\n+      !$omp ordered threads\t\t! { dg-error \"'ordered' construct without 'doacross' or 'depend' clauses binds to loop where 'collapse' argument 1 is different from 'ordered' argument 2\" }\n+      !$omp end ordered\n+    end do\n+  end do\n+end\n+\n+subroutine qux ()\n+  integer :: i, j\n+  j = 0\n+  !$omp do ordered linear(j)\n+  do i = 1, 64\n+    j = j + 1\n+    !$omp ordered\n+    !$omp end ordered\n+  end do\n+  !$omp do ordered linear(j)\t\t! { dg-error \"'linear' clause may not be specified together with 'ordered' clause if stand-alone 'ordered' construct is nested in it\" }\n+  do i = 1, 64\n+    j = j + 1\n+    !$omp ordered doacross(source:)\n+    !$omp ordered doacross(sink:i-1)\n+  end do\n+  !$omp do ordered(1) linear(j)\n+  do i = 1, 64\n+    j = j + 1\n+    !$omp ordered\n+    !$omp end ordered\n+  end do\n+  !$omp do ordered(1) linear(j)\t\t! { dg-error \"'linear' clause may not be specified together with 'ordered' clause if stand-alone 'ordered' construct is nested in it\" }\n+  do i = 1, 64\n+    j = j + 1\n+    !$omp ordered doacross(source:)\n+    !$omp ordered doacross(sink:i-1)\n+  end do\n+end"}, {"sha": "a45e1c9386cd9c56c28514c31bce3604afb32639", "filename": "gcc/testsuite/gfortran.dg/gomp/doacross-6.f90", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/938cda536019cd6a1bc0dd2346381185b420bbf8/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdoacross-6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/938cda536019cd6a1bc0dd2346381185b420bbf8/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdoacross-6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdoacross-6.f90?ref=938cda536019cd6a1bc0dd2346381185b420bbf8", "patch": "@@ -0,0 +1,77 @@\n+subroutine foo (n)\n+  integer :: i, n\n+  !$omp do ordered\n+  do i = 1, 8, n\n+    !$omp ordered doacross(source)\t\t! { dg-error \"Expected ':'\" }\n+  end do\n+\n+  !$omp do ordered\n+  do i = 1, 8, n\n+    !$omp ordered doacross(source:omp_current_iteration)\t! { dg-error \"Expected '\\\\\\)' or 'omp_cur_iteration\\\\\\)'\" }\n+  end do\n+\n+  !$omp do ordered\n+  do i = 1, 8, n\n+    !$omp ordered doacross(source:i - 2)\t! { dg-error \"Expected '\\\\\\)' or 'omp_cur_iteration\\\\\\)'\" }\n+  end do\n+\n+  !$omp do ordered\n+  do i = 1, 8, n\n+    !$omp ordered doacross(sink)\t\t! { dg-error \"Expected ':'\" }\n+  end do\n+\n+  !$omp do ordered\n+  do i = 1, 8, n\n+    !$omp ordered doacross(sink:)\t\t! { dg-error \"Syntax error in OpenMP SINK dependence-type list\" }\n+  end do\n+end\n+\n+subroutine bar (n)\n+  implicit none\n+  integer i, n\n+\n+  !$omp do ordered\n+  do i = 1, 8, n\n+    !$omp ordered doacross(sink:omp_current_iteration - 1)\t! { dg-error \"Symbol 'omp_current_iteration' at .1. has no IMPLICIT type\" }\n+  end do\n+\n+  !$omp do ordered\n+  do i = 1, 8, n\n+    !$omp ordered doacross(sink:omp_cur_iteration)\t! { dg-error \"omp_cur_iteration at .1. requires '-1' as logical offset\" }\n+  end do\n+end\n+\n+subroutine baz (n)\n+  implicit none\n+  integer i, n\n+\n+  !$omp do ordered\n+  do i = 1, 8, n\n+    !$omp ordered doacross(sink:omp_cur_iteration + 1)\t! { dg-error \"omp_cur_iteration at .1. requires '-1' as logical offset\" }\n+  end do\n+end\n+\n+subroutine qux (n)\n+  implicit none\n+  integer i, n\n+\n+  !$omp do ordered\n+  do i = 1, 8, n\n+    !$omp ordered doacross(sink:omp_cur_iteration - (2 - 1))\t! { dg-error \"Syntax error in OpenMP SINK dependence-type list\" }\n+  end do\n+end\n+\n+subroutine corge (n)\n+  implicit none\n+  integer i, n\n+\n+  !$omp do ordered\n+  do i = 1, 8, n\n+    !$omp ordered doacross(sink:omp_cur_iteration - 1)\n+  end do\n+\n+  !$omp do ordered\n+  do i = 1, 8, n\n+    !$omp ordered doacross(sink:omp_cur_iteration - 1_8)\n+  end do\n+end"}, {"sha": "3df979e170bb97d4d0208378a4bb5669b8034cb7", "filename": "libgomp/libgomp.texi", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/938cda536019cd6a1bc0dd2346381185b420bbf8/libgomp%2Flibgomp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/938cda536019cd6a1bc0dd2346381185b420bbf8/libgomp%2Flibgomp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.texi?ref=938cda536019cd6a1bc0dd2346381185b420bbf8", "patch": "@@ -394,10 +394,11 @@ to address of matching mapped list item per 5.1, Sect. 2.21.7.2 @tab N @tab\n @item Default map-type for @code{map} clause in @code{target enter/exit data}\n       @tab Y @tab\n @item New @code{doacross} clause as alias for @code{depend} with\n-      @code{source}/@code{sink} modifier @tab N @tab\n+      @code{source}/@code{sink} modifier @tab Y @tab\n @item Deprecation of @code{depend} with @code{source}/@code{sink} modifier\n       @tab N @tab\n-@item @code{omp_cur_iteration} keyword @tab N @tab\n+@item @code{omp_cur_iteration} keyword @tab P\n+      @tab @code{sink: omp_cur_iteration - 1} unsupported\n @end multitable\n \n @unnumberedsubsec Other new OpenMP 5.2 features"}]}