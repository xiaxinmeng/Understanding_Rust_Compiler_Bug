{"sha": "34fbe3f0946f88828765184ed6581bda62cdf49f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRmYmUzZjA5NDZmODg4Mjg3NjUxODRlZDY1ODFiZGE2MmNkZjQ5Zg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-12-05T18:12:51Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-12-05T18:12:51Z"}, "message": "cgraphclones.c (localize_profile): New function.\n\n\n\t* cgraphclones.c (localize_profile): New function.\n\t(cgraph_node::create_clone): Use it for partial profiles.\n\t* common.opt (fprofile-partial-training): New flag.\n\t* doc/invoke.texi (-fprofile-partial-training): Document.\n\t* ipa-cp.c (update_profiling_info): For partial profiles do not\n\tset function profile to zero.\n\t* profile.c (compute_branch_probabilities): With partial profile\n\twatch if edge count is zero and turn all probabilities to guessed.\n\t(compute_branch_probabilities): For partial profiles do not apply\n\tprofile when entry count is zero.\n\t* tree-profile.c (tree_profiling): Only do value_profile_transformations\n\twhen profile is read.\n\nFrom-SVN: r279013", "tree": {"sha": "5a3bf82ae6bb92203c6e4922a5d694198595edc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a3bf82ae6bb92203c6e4922a5d694198595edc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34fbe3f0946f88828765184ed6581bda62cdf49f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34fbe3f0946f88828765184ed6581bda62cdf49f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34fbe3f0946f88828765184ed6581bda62cdf49f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34fbe3f0946f88828765184ed6581bda62cdf49f/comments", "author": null, "committer": null, "parents": [{"sha": "8575d5925226a8f92ee644d6d59a2b1b93840d94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8575d5925226a8f92ee644d6d59a2b1b93840d94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8575d5925226a8f92ee644d6d59a2b1b93840d94"}], "stats": {"total": 103, "additions": 94, "deletions": 9}, "files": [{"sha": "3cd05387def0c69157fe87976df4393cafe54319", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fbe3f0946f88828765184ed6581bda62cdf49f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fbe3f0946f88828765184ed6581bda62cdf49f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=34fbe3f0946f88828765184ed6581bda62cdf49f", "patch": "@@ -1,3 +1,18 @@\n+2019-12-05  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* cgraphclones.c (localize_profile): New function.\n+\t(cgraph_node::create_clone): Use it for partial profiles.\n+\t* common.opt (fprofile-partial-training): New flag.\n+\t* doc/invoke.texi (-fprofile-partial-training): Document.\n+\t* ipa-cp.c (update_profiling_info): For partial profiles do not\n+\tset function profile to zero.\n+\t* profile.c (compute_branch_probabilities): With partial profile\n+\twatch if edge count is zero and turn all probabilities to guessed.\n+\t(compute_branch_probabilities): For partial profiles do not apply\n+\tprofile when entry count is zero.\n+\t* tree-profile.c (tree_profiling): Only do value_profile_transformations\n+\twhen profile is read.\n+\n 2019-12-05  Sudakshina Das  <sudi.das@arm.com>\n \n \t* tree-vect-loop.c (vect_model_reduction_cost): Remove reduction_type"}, {"sha": "f2dfb4e2d679e58e922a15ec26b3c3d9db9dff55", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fbe3f0946f88828765184ed6581bda62cdf49f/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fbe3f0946f88828765184ed6581bda62cdf49f/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=34fbe3f0946f88828765184ed6581bda62cdf49f", "patch": "@@ -307,6 +307,22 @@ dump_callgraph_transformation (const cgraph_node *original,\n     }\n }\n \n+/* Turn profile of N to local profile.   */\n+\n+static void\n+localize_profile (cgraph_node *n)\n+{\n+  n->count = n->count.guessed_local ();\n+  for (cgraph_edge *e = n->callees; e; e=e->next_callee)\n+    {\n+      e->count = e->count.guessed_local ();\n+      if (!e->inline_failed)\n+\tlocalize_profile (e->callee);\n+    }\n+  for (cgraph_edge *e = n->indirect_calls; e; e=e->next_callee)\n+    e->count = e->count.guessed_local ();\n+}\n+\n /* Create node representing clone of N executed COUNT times.  Decrease\n    the execution counts from original node too.\n    The new clone will have decl set to DECL that may or may not be the same\n@@ -340,6 +356,7 @@ cgraph_node::create_clone (tree new_decl, profile_count prof_count,\n   cgraph_edge *e;\n   unsigned i;\n   profile_count old_count = count;\n+  bool nonzero = count.ipa ().nonzero_p ();\n \n   if (new_inlined_to)\n     dump_callgraph_transformation (this, new_inlined_to, \"inlining to\");\n@@ -426,6 +443,15 @@ cgraph_node::create_clone (tree new_decl, profile_count prof_count,\n \n   if (call_duplication_hook)\n     symtab->call_cgraph_duplication_hooks (this, new_node);\n+  /* With partial train run we do not want to assume that original's\n+     count is zero whenever we redurect all executed edges to clone.\n+     Simply drop profile to local one in this case.  */\n+  if (update_original\n+      && opt_for_fn (decl, flag_profile_partial_training)\n+      && nonzero\n+      && count.ipa_p ()\n+      && !count.ipa ().nonzero_p ())\n+    localize_profile (this);\n \n   if (!new_inlined_to)\n     dump_callgraph_transformation (this, new_node, suffix);"}, {"sha": "7e47953f8dc6dec5a2fb0fbcd7d2c89579537483", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fbe3f0946f88828765184ed6581bda62cdf49f/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fbe3f0946f88828765184ed6581bda62cdf49f/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=34fbe3f0946f88828765184ed6581bda62cdf49f", "patch": "@@ -2160,6 +2160,10 @@ fprofile-generate=\n Common Joined RejectNegative\n Enable common options for generating profile info for profile feedback directed optimizations, and set -fprofile-dir=.\n \n+fprofile-partial-training\n+Common Report Var(flag_profile_partial_training) Optimization\n+Do not assume that functions never executed during the train run are cold\n+\n fprofile-use\n Common Var(flag_profile_use)\n Enable common options for performing profile feedback directed optimizations."}, {"sha": "af3c7f2b9109d4997d6313ca9a90b6fec9f5ccd7", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fbe3f0946f88828765184ed6581bda62cdf49f/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fbe3f0946f88828765184ed6581bda62cdf49f/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=34fbe3f0946f88828765184ed6581bda62cdf49f", "patch": "@@ -453,8 +453,8 @@ Objective-C and Objective-C++ Dialects}.\n -fpartial-inlining  -fpeel-loops  -fpredictive-commoning @gol\n -fprefetch-loop-arrays @gol\n -fprofile-correction @gol\n--fprofile-use  -fprofile-use=@var{path}  -fprofile-values @gol\n--fprofile-reorder-functions @gol\n+-fprofile-use  -fprofile-use=@var{path} -fprofile-partial-training @gol\n+-fprofile-values -fprofile-reorder-functions @gol\n -freciprocal-math  -free  -frename-registers  -freorder-blocks @gol\n -freorder-blocks-algorithm=@var{algorithm} @gol\n -freorder-blocks-and-partition  -freorder-functions @gol\n@@ -10634,6 +10634,19 @@ default, GCC emits an error message when an inconsistent profile is detected.\n \n This option is enabled by @option{-fauto-profile}.\n \n+@item -fprofile-partial-training\n+@opindex fprofile-use\n+With @code{-fprofile-use} all portions of programs not executed during train\n+run are optimized agressively for size rather than speed.  In some cases it is\n+not practical to train all possible hot paths in the program. (For\n+example, program may contain functions specific for a given hardware and\n+trianing may not cover all hardware configurations program is run on.)  With\n+@code{-fprofile-partial-training} profile feedback will be ignored for all\n+functions not executed during the train run leading them to be optimized as if\n+they were compiled without profile feedback. This leads to better performance\n+when train run is not representative but also leads to significantly bigger\n+code.\n+\n @item -fprofile-use\n @itemx -fprofile-use=@var{path}\n @opindex fprofile-use"}, {"sha": "14064ae0034daa53d81f85da643dd2bd12310cd8", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fbe3f0946f88828765184ed6581bda62cdf49f/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fbe3f0946f88828765184ed6581bda62cdf49f/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=34fbe3f0946f88828765184ed6581bda62cdf49f", "patch": "@@ -4295,6 +4295,15 @@ update_profiling_info (struct cgraph_node *orig_node,\n \n   remainder = orig_node_count.combine_with_ipa_count (orig_node_count.ipa ()\n \t\t\t\t\t\t      - new_sum.ipa ());\n+\n+  /* With partial train run we do not want to assume that original's\n+     count is zero whenever we redurect all executed edges to clone.\n+     Simply drop profile to local one in this case.  */\n+  if (remainder.ipa_p () && !remainder.ipa ().nonzero_p ()\n+      && orig_node->count.ipa_p () && orig_node->count.ipa ().nonzero_p ()\n+      && flag_profile_partial_training)\n+    remainder = remainder.guessed_local ();\n+\n   new_sum = orig_node_count.combine_with_ipa_count (new_sum);\n   new_node->count = new_sum;\n   orig_node->count = remainder;"}, {"sha": "7e2d7d3ca3eb68650e702b07e1b80a6ffec88a90", "filename": "gcc/profile.c", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fbe3f0946f88828765184ed6581bda62cdf49f/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fbe3f0946f88828765184ed6581bda62cdf49f/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=34fbe3f0946f88828765184ed6581bda62cdf49f", "patch": "@@ -635,9 +635,20 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n \t}\n       if (bb_gcov_count (bb))\n \t{\n+\t  bool set_to_guessed = false;\n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t    e->probability = profile_probability::probability_in_gcov_type\n-\t\t(edge_gcov_count (e), bb_gcov_count (bb));\n+\t    {\n+\t      bool prev_never = e->probability == profile_probability::never ();\n+\t      e->probability = profile_probability::probability_in_gcov_type\n+\t\t  (edge_gcov_count (e), bb_gcov_count (bb));\n+\t      if (e->probability == profile_probability::never ()\n+\t\t  && !prev_never\n+\t\t  && flag_profile_partial_training)\n+\t\tset_to_guessed = true;\n+\t    }\n+\t  if (set_to_guessed)\n+\t    FOR_EACH_EDGE (e, ei, bb->succs)\n+\t      e->probability = e->probability.guessed ();\n \t  if (bb->index >= NUM_FIXED_BLOCKS\n \t      && block_ends_with_condjump_p (bb)\n \t      && EDGE_COUNT (bb->succs) >= 2)\n@@ -697,17 +708,23 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n \t}\n     }\n \n-  if (exec_counts)\n+  if (exec_counts\n+      && (bb_gcov_count (ENTRY_BLOCK_PTR_FOR_FN (cfun))\n+\t  || !flag_profile_partial_training))\n     profile_status_for_fn (cfun) = PROFILE_READ;\n \n   /* If we have real data, use them!  */\n   if (bb_gcov_count (ENTRY_BLOCK_PTR_FOR_FN (cfun))\n       || !flag_guess_branch_prob)\n     FOR_ALL_BB_FN (bb, cfun)\n-      bb->count = profile_count::from_gcov_type (bb_gcov_count (bb));\n+      if (bb_gcov_count (bb) || !flag_profile_partial_training)\n+        bb->count = profile_count::from_gcov_type (bb_gcov_count (bb));\n+      else\n+\tbb->count = profile_count::guessed_zero ();\n   /* If function was not trained, preserve local estimates including statically\n      determined zero counts.  */\n-  else if (profile_status_for_fn (cfun) == PROFILE_READ)\n+  else if (profile_status_for_fn (cfun) == PROFILE_READ\n+\t   && !flag_profile_partial_training)\n     FOR_ALL_BB_FN (bb, cfun)\n       if (!(bb->count == profile_count::zero ()))\n         bb->count = bb->count.global0 ();\n@@ -1417,7 +1434,7 @@ branch_prob (bool thunk)\n       /* At this moment we have precise loop iteration count estimates.\n \t Record them to loop structure before the profile gets out of date. */\n       FOR_EACH_LOOP (loop, 0)\n-\tif (loop->header->count > 0)\n+\tif (loop->header->count > 0 && loop->header->count.reliable_p ())\n \t  {\n \t    gcov_type nit = expected_loop_iterations_unbounded (loop);\n \t    widest_int bound = gcov_type_to_wide_int (nit);"}, {"sha": "df60eda665df16dbedfa920cd870a1be728b5630", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fbe3f0946f88828765184ed6581bda62cdf49f/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fbe3f0946f88828765184ed6581bda62cdf49f/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=34fbe3f0946f88828765184ed6581bda62cdf49f", "patch": "@@ -785,7 +785,8 @@ tree_profiling (void)\n       if (flag_branch_probabilities\n \t  && !thunk\n \t  && flag_profile_values\n-\t  && flag_value_profile_transformations)\n+\t  && flag_value_profile_transformations\n+\t  && profile_status_for_fn (cfun) == PROFILE_READ)\n \tgimple_value_profile_transformations ();\n \n       /* The above could hose dominator info.  Currently there is"}]}