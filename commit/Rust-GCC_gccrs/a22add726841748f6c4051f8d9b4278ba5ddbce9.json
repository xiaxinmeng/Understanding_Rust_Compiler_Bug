{"sha": "a22add726841748f6c4051f8d9b4278ba5ddbce9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTIyYWRkNzI2ODQxNzQ4ZjZjNDA1MWY4ZDliNDI3OGJhNWRkYmNlOQ==", "commit": {"author": {"name": "Warren Levy", "email": "warrenl@cygnus.com", "date": "2000-11-28T03:09:22Z"}, "committer": {"name": "Warren Levy", "email": "warrenl@gcc.gnu.org", "date": "2000-11-28T03:09:22Z"}, "message": "Makefile.am: Added natTimeZone.cc.\n\n\t* Makefile.am: Added natTimeZone.cc.\n\t* Makefile.in: Rebuilt.\n\t* gnu/gcj/text/LocaleData_en.java: Added DateFormat entries.\n\t* java/text/DateFormatSymbols.java (ampms): Made package private.\n\t(eras): Made package private.\n\t(months): Made package private.\n\t(shortMonths): Made package private.\n\t(shortWeekdays): Made package private.\n\t(weekdays): Made package private.\n\t(formatPrefixes): New private field.\n\t(localPatternCharsDefault): Made private.\n\t(dateFormats): New package private field.\n\t(timeFormats): New package private field.\n\t(formatsForKey): New private method.\n\t(DateFormatSymbols(Locale)): Set dateFormats and timeFormats.\n\t(DateFormatSymbols(DateFormatSymbols)): Ditto.\n\t* java/text/SimpleDateFormat.java: Merged with Classpath.\n\t* java/util/TimeZone.java: Merged with Classpath.\n\t* java/util/natTimeZone.cc: New file.\n\nFrom-SVN: r37808", "tree": {"sha": "1662df7a9a7114295c1d93c1195edd57cd72c465", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1662df7a9a7114295c1d93c1195edd57cd72c465"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a22add726841748f6c4051f8d9b4278ba5ddbce9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a22add726841748f6c4051f8d9b4278ba5ddbce9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a22add726841748f6c4051f8d9b4278ba5ddbce9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a22add726841748f6c4051f8d9b4278ba5ddbce9/comments", "author": null, "committer": null, "parents": [{"sha": "9734e80cade2a318334a7b3f83ec787d07df80c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9734e80cade2a318334a7b3f83ec787d07df80c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9734e80cade2a318334a7b3f83ec787d07df80c4"}], "stats": {"total": 2781, "additions": 2221, "deletions": 560}, "files": [{"sha": "8176ba93e154585306ca994df08f4eab5ec6585a", "filename": "libjava/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a22add726841748f6c4051f8d9b4278ba5ddbce9/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a22add726841748f6c4051f8d9b4278ba5ddbce9/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=a22add726841748f6c4051f8d9b4278ba5ddbce9", "patch": "@@ -1,3 +1,25 @@\n+2000-11-27  Warren Levy  <warrenl@cygnus.com>\n+\n+\t* Makefile.am: Added natTimeZone.cc.\n+\t* Makefile.in: Rebuilt.\n+\t* gnu/gcj/text/LocaleData_en.java: Added DateFormat entries.\n+\t* java/text/DateFormatSymbols.java (ampms): Made package private.\n+\t(eras): Made package private.\n+\t(months): Made package private.\n+\t(shortMonths): Made package private.\n+\t(shortWeekdays): Made package private.\n+\t(weekdays): Made package private.\n+\t(formatPrefixes): New private field.\n+\t(localPatternCharsDefault): Made private.\n+\t(dateFormats): New package private field.\n+\t(timeFormats): New package private field.\n+\t(formatsForKey): New private method.\n+\t(DateFormatSymbols(Locale)): Set dateFormats and timeFormats.\n+\t(DateFormatSymbols(DateFormatSymbols)): Ditto.\n+\t* java/text/SimpleDateFormat.java: Merged with Classpath.\n+\t* java/util/TimeZone.java: Merged with Classpath.\n+\t* java/util/natTimeZone.cc: New file.\n+\n 2000-11-27  Bryce McKinlay  <bryce@albatross.co.nz>\n \n \t* java/util/Vector.java (ensureCapacity): Don't increment modCount."}, {"sha": "5cd62031e6bbe864be7dc256ee92ad25fb517bb8", "filename": "libjava/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a22add726841748f6c4051f8d9b4278ba5ddbce9/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a22add726841748f6c4051f8d9b4278ba5ddbce9/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=a22add726841748f6c4051f8d9b4278ba5ddbce9", "patch": "@@ -1229,6 +1229,7 @@ java/net/natPlainDatagramSocketImpl.cc \\\n java/net/natPlainSocketImpl.cc \\\n java/text/natCollator.cc \\\n java/util/natGregorianCalendar.cc \\\n+java/util/natTimeZone.cc \\\n java/util/zip/natDeflater.cc \\\n java/util/zip/natInflater.cc\n "}, {"sha": "da16e041f45ae06081671b84b3d4ab3023279090", "filename": "libjava/Makefile.in", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a22add726841748f6c4051f8d9b4278ba5ddbce9/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a22add726841748f6c4051f8d9b4278ba5ddbce9/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=a22add726841748f6c4051f8d9b4278ba5ddbce9", "patch": "@@ -991,6 +991,7 @@ java/net/natPlainDatagramSocketImpl.cc \\\n java/net/natPlainSocketImpl.cc \\\n java/text/natCollator.cc \\\n java/util/natGregorianCalendar.cc \\\n+java/util/natTimeZone.cc \\\n java/util/zip/natDeflater.cc \\\n java/util/zip/natInflater.cc\n \n@@ -1142,8 +1143,8 @@ java/lang/reflect/natArray.lo java/lang/reflect/natConstructor.lo \\\n java/lang/reflect/natField.lo java/lang/reflect/natMethod.lo \\\n java/net/natInetAddress.lo java/net/natPlainDatagramSocketImpl.lo \\\n java/net/natPlainSocketImpl.lo java/text/natCollator.lo \\\n-java/util/natGregorianCalendar.lo java/util/zip/natDeflater.lo \\\n-java/util/zip/natInflater.lo\n+java/util/natGregorianCalendar.lo java/util/natTimeZone.lo \\\n+java/util/zip/natDeflater.lo java/util/zip/natInflater.lo\n libgcjx_la_OBJECTS =  gnu/gcj/xlib/natClip.lo \\\n gnu/gcj/xlib/natColormap.lo gnu/gcj/xlib/natDisplay.lo \\\n gnu/gcj/xlib/natDrawable.lo gnu/gcj/xlib/natFont.lo \\\n@@ -1684,8 +1685,9 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/util/jar/JarException.P .deps/java/util/jar/JarFile.P \\\n .deps/java/util/jar/JarInputStream.P \\\n .deps/java/util/jar/JarOutputStream.P .deps/java/util/jar/Manifest.P \\\n-.deps/java/util/natGregorianCalendar.P .deps/java/util/zip/Adler32.P \\\n-.deps/java/util/zip/CRC32.P .deps/java/util/zip/CheckedInputStream.P \\\n+.deps/java/util/natGregorianCalendar.P .deps/java/util/natTimeZone.P \\\n+.deps/java/util/zip/Adler32.P .deps/java/util/zip/CRC32.P \\\n+.deps/java/util/zip/CheckedInputStream.P \\\n .deps/java/util/zip/CheckedOutputStream.P \\\n .deps/java/util/zip/Checksum.P \\\n .deps/java/util/zip/DataFormatException.P \\"}, {"sha": "c24c1121335e5d1a31d4f80e683d1202dc5db75d", "filename": "libjava/gnu/gcj/text/LocaleData_en.java", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a22add726841748f6c4051f8d9b4278ba5ddbce9/libjava%2Fgnu%2Fgcj%2Ftext%2FLocaleData_en.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a22add726841748f6c4051f8d9b4278ba5ddbce9/libjava%2Fgnu%2Fgcj%2Ftext%2FLocaleData_en.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Ftext%2FLocaleData_en.java?ref=a22add726841748f6c4051f8d9b4278ba5ddbce9", "patch": "@@ -68,6 +68,16 @@ public final class LocaleData_en extends ListResourceBundle\n     { \"shortWeekdays\", shortWeekdaysDefault },\n     { \"weekdays\", weekdaysDefault },\n \n+    // These are for DateFormat.\n+    { \"shortDateFormat\", \"M/d/yy\" },\t      // Java's Y2K bug.\n+    { \"mediumDateFormat\", \"d-MMM-yy\" },\n+    { \"longDateFormat\", \"MMMM d, yyyy\" },\n+    { \"fullDateFormat\", \"EEEE MMMM d, yyyy G\" },\n+    { \"shortTimeFormat\", \"h:mm a\" },\n+    { \"mediumTimeFormat\", \"h:mm:ss a\" },\n+    { \"longTimeFormat\", \"h:mm:ss a z\" },\n+    { \"fullTimeFormat\", \"h:mm:ss;S 'o''clock' a z\" },\n+\n     // For RuleBasedCollator.\n     // FIXME: this is nowhere near complete.\n     // In particular we must mark accents as ignorable,"}, {"sha": "c8250c9344a9b1c825cbd0095b3ae88070fdb0dc", "filename": "libjava/java/text/DateFormatSymbols.java", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a22add726841748f6c4051f8d9b4278ba5ddbce9/libjava%2Fjava%2Ftext%2FDateFormatSymbols.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a22add726841748f6c4051f8d9b4278ba5ddbce9/libjava%2Fjava%2Ftext%2FDateFormatSymbols.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FDateFormatSymbols.java?ref=a22add726841748f6c4051f8d9b4278ba5ddbce9", "patch": "@@ -24,21 +24,29 @@\n public class DateFormatSymbols extends Object\n   implements java.io.Serializable, Cloneable\n {\n-  private String[] ampms;\n-  private String[] eras;\n+  String[] ampms;\n+  String[] eras;\n   private String localPatternChars;\n-  private String[] months;\n-  private String[] shortMonths;\n-  private String[] shortWeekdays;\n-  private String[] weekdays;\n+  String[] months;\n+  String[] shortMonths;\n+  String[] shortWeekdays;\n+  String[] weekdays;\n   private String[][] zoneStrings;\n \n   private static final long serialVersionUID = -5987973545549424702L;\n \n+  // The order of these prefixes must be the same as in DateFormat\n+  // FIXME: XXX: Note that this differs from the Classpath implemention\n+  // in that there is no \"default\" entry; that is due to differing\n+  // implementations where DateFormat.DEFAULT is MEDIUM here but 4 in\n+  // Classpath (the JCL says it should be MEDIUM).  That will need to be \n+  // resolved in the merge.\n+  private static final String[] formatPrefixes = { \"full\", \"long\", \"medium\", \"short\" };\n+\n   private static final String[] ampmsDefault = {\"AM\", \"PM\" };\n   private static final String[] erasDefault = {\"BC\", \"AD\" };\n   // localPatternCharsDefault is used by SimpleDateFormat.\n-  protected static final String localPatternCharsDefault\n+  private static final String localPatternCharsDefault\n     = \"GyMdkHmsSEDFwWahKz\";\n   private static final String[] monthsDefault = {\n     \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n@@ -77,6 +85,24 @@ public class DateFormatSymbols extends Object\n       /**/   \"Alaska Daylight Time\", \"ADT\", \"Anchorage\" }\n   };\n \n+  // These are each arrays with a value for SHORT, MEDIUM, LONG, FULL,\n+  // and DEFAULT (constants defined in java.text.DateFormat).  While\n+  // not part of the official spec, we need a way to get at locale-specific\n+  // default formatting patterns.  They are declared package scope so\n+  // as to be easily accessible where needed (DateFormat, SimpleDateFormat).\n+  transient String[] dateFormats;\n+  transient String[] timeFormats;\n+\n+  private String[] formatsForKey(ResourceBundle res, String key) \n+  {\n+    String[] values = new String [formatPrefixes.length];\n+    for (int i = 0; i < formatPrefixes.length; i++)\n+      {\n+        values[i] = res.getString(formatPrefixes[i]+key);\n+      }\n+    return values;\n+  }\n+\n   private final Object safeGetResource (ResourceBundle res,\n \t\t\t\t\tString key, Object def)\n   {\n@@ -116,6 +142,9 @@ public DateFormatSymbols (Locale locale)\n     weekdays = (String[]) safeGetResource (res, \"weekdays\", weekdaysDefault);\n     zoneStrings = (String[][]) safeGetResource (res, \"zoneStrings\",\n \t\t\t\t\t\tzoneStringsDefault);\n+\n+    dateFormats = formatsForKey(res, \"DateFormat\");\n+    timeFormats = formatsForKey(res, \"TimeFormat\");\n   }\n \n   public DateFormatSymbols ()\n@@ -134,6 +163,8 @@ private DateFormatSymbols (DateFormatSymbols old)\n     shortWeekdays = old.shortWeekdays;\n     weekdays = old.weekdays;\n     zoneStrings = old.zoneStrings;\n+    dateFormats = old.dateFormats;\n+    timeFormats = old.timeFormats;\n   }\n \n   public String[] getAmPmStrings()"}, {"sha": "e2f70cddcc6648499e469e2f2435a5104c587981", "filename": "libjava/java/text/SimpleDateFormat.java", "status": "modified", "additions": 1046, "deletions": 435, "changes": 1481, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a22add726841748f6c4051f8d9b4278ba5ddbce9/libjava%2Fjava%2Ftext%2FSimpleDateFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a22add726841748f6c4051f8d9b4278ba5ddbce9/libjava%2Fjava%2Ftext%2FSimpleDateFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FSimpleDateFormat.java?ref=a22add726841748f6c4051f8d9b4278ba5ddbce9", "patch": "@@ -1,107 +1,268 @@\n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+/* SimpleDateFormat.java -- A class for parsing/formating simple \n+   date constructs\n+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.text;\n \n-import java.util.*;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.GregorianCalendar;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+import java.util.SimpleTimeZone;\n+import java.util.Vector;\n import java.io.ObjectInputStream;\n import java.io.IOException;\n \n /**\n- * @author Per Bothner <bothner@cygnus.com>\n- * @date October 25, 1998.\n+ * SimpleDateFormat provides convenient methods for parsing and formatting\n+ * dates using Gregorian calendars (see java.util.GregorianCalendar). \n  */\n-/* Written using \"Java Class Libraries\", 2nd edition, plus online\n- * API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct to 1.2.\n- */\n-\n-public class SimpleDateFormat extends DateFormat\n+public class SimpleDateFormat extends DateFormat \n {\n-  // Serialization fields.\n-  private Date defaultCenturyStart = new Date();\n-  private DateFormatSymbols formatData;\n+  /** A pair class used by SimpleDateFormat as a compiled representation\n+   *  of a format string.\n+   */\n+  private class FieldSizePair \n+  {\n+    public int field;\n+    public int size;\n+\n+    /** Constructs a pair with the given field and size values */\n+    public FieldSizePair(int f, int s) {\n+      field = f;\n+      size = s;\n+    }\n+  }\n+\n+  private transient Vector tokens;\n+  private DateFormatSymbols formatData;  // formatData\n+  private Date defaultCenturyStart = \n+    new Date(System.currentTimeMillis() - (80*365*24*60*60*1000));\n   private String pattern;\n-  private int serialVersionOnStream = 1;\n+  private int serialVersionOnStream = 1; // 0 indicates JDK1.1.3 or earlier\n   private static final long serialVersionUID = 4774881970558875024L;\n \n-  // Serialization method.\n+  // This string is specified in the JCL.  We set it here rather than\n+  // do a DateFormatSymbols(Locale.US).getLocalPatternChars() since\n+  // someone could theoretically change those values (though unlikely).\n+  private static final String standardChars = \"GyMdkHmsSEDFwWahKz\";\n+\n   private void readObject(ObjectInputStream stream)\n     throws IOException, ClassNotFoundException\n   {\n     stream.defaultReadObject();\n     if (serialVersionOnStream < 1)\n       {\n-        defaultCenturyStart = new Date();\n+        defaultCenturyStart =\n+\t  new Date(System.currentTimeMillis() - (80*365*24*60*60*1000));\n \tserialVersionOnStream = 1;\n       }\n+\n+    // Set up items normally taken care of by the constructor.\n+    tokens = new Vector();\n+    compileFormat(pattern);\n   }\n \n-  public SimpleDateFormat ()\n+  private void compileFormat(String pattern) \n   {\n-    this(\"dd/MM/yy HH:mm\", Locale.getDefault());\n-  }\n+    // Any alphabetical characters are treated as pattern characters\n+    // unless enclosed in single quotes.\n \n-  public SimpleDateFormat (String pattern)\n+    char thisChar;\n+    int pos;\n+    int field;\n+    FieldSizePair current = null;\n+\n+    for (int i=0; i<pattern.length(); i++) {\n+      thisChar = pattern.charAt(i);\n+      field = formatData.getLocalPatternChars().indexOf(thisChar);\n+      if (field == -1) {\n+\tcurrent = null;\n+\tif (Character.isLetter(thisChar)) {\n+\t  // Not a valid letter\n+\t  tokens.addElement(new FieldSizePair(-1,0));\n+\t} else if (thisChar == '\\'') {\n+\t  // Quoted text section; skip to next single quote\n+\t  pos = pattern.indexOf('\\'',i+1);\n+\t  if (pos == -1) {\n+\t    // This ought to be an exception, but spec does not\n+\t    // let us throw one.\n+\t    tokens.addElement(new FieldSizePair(-1,0));\n+\t  }\n+\t  if ((pos+1 < pattern.length()) && (pattern.charAt(pos+1) == '\\'')) {\n+\t    tokens.addElement(pattern.substring(i+1,pos+1));\n+\t  } else {\n+\t    tokens.addElement(pattern.substring(i+1,pos));\n+\t  }\n+\t  i = pos;\n+\t} else {\n+\t  // A special character\n+\t  tokens.addElement(new Character(thisChar));\n+\t}\n+      } else {\n+\t// A valid field\n+\tif ((current != null) && (field == current.field)) {\n+\t  current.size++;\n+\t} else {\n+\t  current = new FieldSizePair(field,1);\n+\t  tokens.addElement(current);\n+\t}\n+      }\n+    }\n+  }\n+    \n+  public String toString() \n   {\n-    this(pattern, Locale.getDefault());\n+    StringBuffer output = new StringBuffer();\n+    Enumeration e = tokens.elements();\n+    while (e.hasMoreElements()) {\n+      output.append(e.nextElement().toString());\n+    }\n+    return output.toString();\n   }\n-\n-  public SimpleDateFormat (String pattern, Locale locale)\n+      \n+  /**\n+   * Constructs a SimpleDateFormat using the default pattern for\n+   * the default locale.\n+   */\n+  public SimpleDateFormat() \n   {\n-    this.pattern = pattern;\n-    this.calendar = Calendar.getInstance(locale);\n-    this.numberFormat = NumberFormat.getInstance(locale);\n-    numberFormat.setGroupingUsed(false);\n-    this.formatData = new DateFormatSymbols (locale);\n+    /*\n+     * There does not appear to be a standard API for determining \n+     * what the default pattern for a locale is, so use package-scope\n+     * variables in DateFormatSymbols to encapsulate this.\n+     */\n+    super();\n+    Locale locale = Locale.getDefault();\n+    calendar = new GregorianCalendar(locale);\n+    tokens = new Vector();\n+    formatData = new DateFormatSymbols(locale);\n+    pattern = formatData.dateFormats[DEFAULT]+' '+formatData.timeFormats[DEFAULT];\n+    compileFormat(pattern);\n+    numberFormat = NumberFormat.getInstance(locale);\n   }\n-\n-  public SimpleDateFormat (String pattern, DateFormatSymbols formatData)\n+  \n+  /**\n+   * Creates a date formatter using the specified pattern, with the default\n+   * DateFormatSymbols for the default locale.\n+   */\n+  public SimpleDateFormat(String pattern) \n   {\n-    this.pattern = pattern;\n-    this.formatData = formatData;\n-    this.calendar = Calendar.getInstance();\n-    this.numberFormat = NumberFormat.getInstance();\n-    numberFormat.setGroupingUsed(false);\n+    this(pattern, Locale.getDefault());\n   }\n \n-  public Date get2DigitYearStart()\n+  /**\n+   * Creates a date formatter using the specified pattern, with the default\n+   * DateFormatSymbols for the given locale.\n+   */\n+  public SimpleDateFormat(String pattern, Locale locale) \n   {\n-    return defaultCenturyStart;\n+    super();\n+    calendar = new GregorianCalendar(locale);\n+    tokens = new Vector();\n+    formatData = new DateFormatSymbols(locale);\n+    compileFormat(pattern);\n+    this.pattern = pattern;\n+    numberFormat = NumberFormat.getInstance(locale);\n   }\n \n-  public void set2DigitYearStart(Date startDate)\n-  {\n-    defaultCenturyStart = startDate;\n+  /**\n+   * Creates a date formatter using the specified pattern. The\n+   * specified DateFormatSymbols will be used when formatting.\n+   */\n+  public SimpleDateFormat(String pattern, DateFormatSymbols formatData) {\n+    super();\n+    calendar = new GregorianCalendar();\n+    // FIXME: XXX: Is it really necessary to set the timezone?\n+    // The Calendar constructor is supposed to take care of this.\n+    calendar.setTimeZone(TimeZone.getDefault());\n+    tokens = new Vector();\n+    this.formatData = formatData;\n+    compileFormat(pattern);\n+    this.pattern = pattern;\n+    numberFormat = NumberFormat.getInstance();\n   }\n \n-  public DateFormatSymbols getDateFormatSymbols ()\n+  // What is the difference between localized and unlocalized?  The\n+  // docs don't say.\n+\n+  /**\n+   * This method returns a string with the formatting pattern being used\n+   * by this object.  This string is unlocalized.\n+   *\n+   * @return The format string.\n+   */\n+  public String toPattern()\n   {\n-    return formatData;\n+    return pattern;\n   }\n \n-  public void setDateFormatSymbols (DateFormatSymbols value)\n+  /**\n+   * This method returns a string with the formatting pattern being used\n+   * by this object.  This string is localized.\n+   *\n+   * @return The format string.\n+   */\n+  public String toLocalizedPattern()\n   {\n-    formatData = value;\n+    String localChars = formatData.getLocalPatternChars();\n+    return applyLocalizedPattern (pattern, standardChars, localChars);\n   }\n \n-  public String toPattern ()\n+  /**\n+   * This method sets the formatting pattern that should be used by this\n+   * object.  This string is not localized.\n+   *\n+   * @param pattern The new format pattern.\n+   */\n+  public void applyPattern(String pattern)\n   {\n-    return pattern;\n+    tokens = new Vector();\n+    compileFormat(pattern);\n+    this.pattern = pattern;\n   }\n \n-  public void applyPattern (String pattern)\n+  /**\n+   * This method sets the formatting pattern that should be used by this\n+   * object.  This string is localized.\n+   *\n+   * @param pattern The new format pattern.\n+   */\n+  public void applyLocalizedPattern(String pattern)\n   {\n-    this.pattern = pattern;\n+    String localChars = formatData.getLocalPatternChars();\n+    pattern = applyLocalizedPattern (pattern, localChars, standardChars);\n+    applyPattern(pattern);\n   }\n \n-  private String applyLocalizedPattern (String pattern,\n-\t\t\t\t\tString oldChars, String newChars)\n+  private String applyLocalizedPattern(String pattern,\n+\t\t\t\t       String oldChars, String newChars)\n   {\n     int len = pattern.length();\n     StringBuffer buf = new StringBuffer(len);\n@@ -122,424 +283,874 @@ private String applyLocalizedPattern (String pattern,\n     return buf.toString();\n   }\n \n-  public void applyLocalizedPattern (String pattern)\n+  /** \n+   * Returns the start of the century used for two digit years.\n+   *\n+   * @return A <code>Date</code> representing the start of the century\n+   * for two digit years.\n+   */\n+  public Date get2DigitYearStart()\n   {\n-    String localChars = formatData.getLocalPatternChars();\n-    String standardChars = DateFormatSymbols.localPatternCharsDefault;\n-    pattern = applyLocalizedPattern (pattern, localChars, standardChars);\n-    applyPattern(pattern);\n+    return defaultCenturyStart;\n   }\n \n-  public String toLocalizedPattern ()\n+  /**\n+   * Sets the start of the century used for two digit years.\n+   *\n+   * @param date A <code>Date</code> representing the start of the century for\n+   * two digit years.\n+   */\n+  public void set2DigitYearStart(Date date)\n   {\n-    String localChars = formatData.getLocalPatternChars();\n-    String standardChars = DateFormatSymbols.localPatternCharsDefault;\n-    return applyLocalizedPattern (pattern, standardChars, localChars);\n+    defaultCenturyStart = date;\n   }\n \n-  private final void append (StringBuffer buf, int value, int numDigits)\n+  /**\n+   * This method returns the format symbol information used for parsing\n+   * and formatting dates.\n+   *\n+   * @return The date format symbols.\n+   */\n+  public DateFormatSymbols getDateFormatSymbols()\n   {\n-    numberFormat.setMinimumIntegerDigits(numDigits);\n-    numberFormat.format(value, buf, null);\n+    return formatData;\n   }\n \n-  public StringBuffer format (Date date, StringBuffer buf, FieldPosition pos)\n+  /**\n+   * This method sets the format symbols information used for parsing\n+   * and formatting dates.\n+   *\n+   * @param formatData The date format symbols.\n+   */\n+   public void setDateFormatSymbols(DateFormatSymbols formatData)\n+   {\n+     this.formatData = formatData;\n+   }\n+\n+  /**\n+   * This methods tests whether the specified object is equal to this\n+   * object.  This will be true if and only if the specified object:\n+   * <p>\n+   * <ul>\n+   * <li>Is not <code>null</code>.\n+   * <li>Is an instance of <code>SimpleDateFormat</code>.\n+   * <li>Is equal to this object at the superclass (i.e., <code>DateFormat</code>)\n+   *     level.\n+   * <li>Has the same formatting pattern.\n+   * <li>Is using the same formatting symbols.\n+   * <li>Is using the same century for two digit years.\n+   * </ul>\n+   *\n+   * @param obj The object to compare for equality against.\n+   *\n+   * @return <code>true</code> if the specified object is equal to this object,\n+   * <code>false</code> otherwise.\n+   */\n+  public boolean equals(Object o)\n   {\n-    Calendar calendar = (Calendar) this.calendar.clone();\n-    calendar.setTime(date);\n-    int len = pattern.length();\n-    int quoteStart = -1;\n-    for (int i = 0;  i < len;  i++)\n-      {\n-\tchar ch = pattern.charAt(i);\n-\tif (ch == '\\'')\n-\t  {\n-\t    // We must do a little lookahead to see if we have two\n-\t    // single quotes embedded in quoted text.\n-\t    if (i < len - 1 && pattern.charAt(i + 1) == '\\'')\n-\t      {\n-\t\t++i;\n-\t\tbuf.append(ch);\n-\t      }\n-\t    else\n-\t      quoteStart = quoteStart < 0 ? i : -1;\n-\t  }\n-\t// From JCL: any characters in the pattern that are not in\n-\t// the ranges of [a..z] and [A..Z] are treated as quoted\n-\t// text.\n-\telse if (quoteStart != -1\n-\t    || ((ch < 'a' || ch > 'z')\n-\t\t&& (ch < 'A' || ch > 'Z')))\n-\t  buf.append(ch);\n-\telse\n+    if (o == null)\n+      return false;\n+\n+    if (!super.equals(o))\n+      return false;\n+\n+    if (!(o instanceof SimpleDateFormat))\n+      return false;\n+\n+    SimpleDateFormat sdf = (SimpleDateFormat)o;\n+\n+    if (!toPattern().equals(sdf.toPattern()))\n+      return false;\n+\n+    if (!get2DigitYearStart().equals(sdf.get2DigitYearStart()))\n+      return false;\n+\n+    if (!getDateFormatSymbols().equals(sdf.getDateFormatSymbols()))\n+      return false;\n+\n+    return true;\n+  }\n+\n+\n+  /**\n+   * Formats the date input according to the format string in use,\n+   * appending to the specified StringBuffer.  The input StringBuffer\n+   * is returned as output for convenience.\n+   */\n+  public StringBuffer format(Date date, StringBuffer buffer, FieldPosition pos) {\n+    String temp;\n+    Calendar theCalendar = (Calendar) calendar.clone();\n+    theCalendar.setTime(date);\n+    \n+    // go through vector, filling in fields where applicable, else toString\n+    Enumeration e = tokens.elements();\n+    while (e.hasMoreElements()) {\n+      Object o = e.nextElement();\n+      if (o instanceof FieldSizePair) {\n+\tFieldSizePair p = (FieldSizePair) o;\n+\tint beginIndex = buffer.length();\n+\tswitch (p.field) {\n+\tcase ERA_FIELD:\n+\t  buffer.append(formatData.eras[theCalendar.get(Calendar.ERA)]);\n+\t  break;\n+\tcase YEAR_FIELD:\n+\t  temp = String.valueOf(theCalendar.get(Calendar.YEAR));\n+\t  if (p.size < 4)\n+\t    buffer.append(temp.substring(temp.length()-2));\n+\t  else\n+\t    buffer.append(temp);\n+\t  break;\n+\tcase MONTH_FIELD:\n+\t  if (p.size < 3)\n+\t    withLeadingZeros(theCalendar.get(Calendar.MONTH)+1,p.size,buffer);\n+\t  else if (p.size < 4)\n+\t    buffer.append(formatData.shortMonths[theCalendar.get(Calendar.MONTH)]);\n+\t  else\n+\t    buffer.append(formatData.months[theCalendar.get(Calendar.MONTH)]);\n+\t  break;\n+\tcase DATE_FIELD:\n+\t  withLeadingZeros(theCalendar.get(Calendar.DATE),p.size,buffer);\n+\t  break;\n+\tcase HOUR_OF_DAY1_FIELD:  // 1-12\n+\t  withLeadingZeros(theCalendar.get(Calendar.HOUR),p.size,buffer);\n+\t  break;\n+\tcase HOUR_OF_DAY0_FIELD: // 0-23\n+\t  withLeadingZeros(theCalendar.get(Calendar.HOUR_OF_DAY),p.size,buffer);\n+\t  break;\n+\tcase MINUTE_FIELD:\n+\t  withLeadingZeros(theCalendar.get(Calendar.MINUTE),p.size,buffer);\n+\t  break;\n+\tcase SECOND_FIELD:\n+\t  withLeadingZeros(theCalendar.get(Calendar.SECOND),p.size,buffer);\n+\t  break;\n+\tcase MILLISECOND_FIELD:\n+\t  withLeadingZeros(theCalendar.get(Calendar.MILLISECOND),p.size,buffer);\n+\t  break;\n+\tcase DAY_OF_WEEK_FIELD:\n+\t  if (p.size < 4)\n+\t    buffer.append(formatData.shortWeekdays[theCalendar.get(Calendar.DAY_OF_WEEK)]);\n+\t  else\n+\t    buffer.append(formatData.weekdays[theCalendar.get(Calendar.DAY_OF_WEEK)]);\n+\t  break;\n+\tcase DAY_OF_YEAR_FIELD:\n+\t  withLeadingZeros(theCalendar.get(Calendar.DAY_OF_YEAR),p.size,buffer);\n+\t  break;\n+\tcase DAY_OF_WEEK_IN_MONTH_FIELD:\n+\t  withLeadingZeros(theCalendar.get(Calendar.DAY_OF_WEEK_IN_MONTH),p.size,buffer);\n+\t  break;\n+\tcase WEEK_OF_YEAR_FIELD:\n+\t  withLeadingZeros(theCalendar.get(Calendar.WEEK_OF_YEAR),p.size,buffer);\n+\t  break;\n+\tcase WEEK_OF_MONTH_FIELD:\n+\t  withLeadingZeros(theCalendar.get(Calendar.WEEK_OF_MONTH),p.size,buffer);\n+\t  break;\n+\tcase AM_PM_FIELD:\n+\t  buffer.append(formatData.ampms[theCalendar.get(Calendar.AM_PM)]);\n+\t  break;\n+\tcase HOUR1_FIELD: // 1-24\n+\t  withLeadingZeros(theCalendar.get(Calendar.HOUR_OF_DAY)+1,p.size,buffer);\n+\t  break;\n+\tcase HOUR0_FIELD: // 0-11\n+\t  withLeadingZeros(theCalendar.get(Calendar.HOUR)-1,p.size,buffer);\n+\t  break;\n+\tcase TIMEZONE_FIELD:\n+\t  // TODO\n+\t  break;\n+\tdefault:\n+\t  throw new IllegalArgumentException(\"Illegal pattern character\");\n+\t}\n+\tif (pos != null && p.field == pos.getField())\n \t  {\n-\t    int first = i;\n-\t    int value;\n-\t    while (++i < len && pattern.charAt(i) == ch) ;\n-\t    int count = i - first; // Number of repetions of ch in pattern.\n-\t    int beginIndex = buf.length();\n-\t    int field;\n-\t    i--;  // Skip all but last instance of ch in pattern.\n-\t    switch (ch)\n-\t      {\n-\t      case 'd':\n-\t\tappend(buf, calendar.get(Calendar.DATE), count);\n-\t\tfield = DateFormat.DATE_FIELD;\n-\t\tbreak;\n-\t      case 'D':\n-\t\tappend(buf, calendar.get(Calendar.DAY_OF_YEAR), count);\n-\t\tfield = DateFormat.DAY_OF_YEAR_FIELD;\n-\t\tbreak;\n-\t      case 'F':\n-\t\tappend(buf, calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH),count);\n-\t\tfield = DateFormat.DAY_OF_WEEK_IN_MONTH_FIELD;\n-\t\tbreak;\n-\t      case 'E':\n-\t\tvalue = calendar.get(calendar.DAY_OF_WEEK);\n-\t\tbuf.append(count <= 3 ? formatData.getShortWeekdays()[value]\n-\t\t\t   : formatData.getWeekdays()[value]);\n-\t\tfield = DateFormat.DAY_OF_WEEK_FIELD;\n-\t\tbreak;\n-\t      case 'w':\n-\t\tappend(buf, calendar.get(Calendar.WEEK_OF_YEAR), count); \n-\t\tfield = DateFormat.WEEK_OF_YEAR_FIELD;\n-                break;\n-\t      case 'W':\n-\t\tappend(buf, calendar.get(Calendar.WEEK_OF_MONTH), count); \n-\t\tfield = DateFormat.WEEK_OF_MONTH_FIELD;\n-                break;\n-\t      case 'M':\n-\t\tvalue = calendar.get(Calendar.MONTH);\n-\t\tif (count <= 2)\n-\t\t  append(buf, value + 1, count);\n-\t\telse\n-\t\t  buf.append(count <= 3 ? formatData.getShortMonths()[value]\n-\t\t\t   : formatData.getMonths()[value]);\n-\t\tfield = DateFormat.MONTH_FIELD;\n-\t\tbreak;\n-\t      case 'y':\n-\t\tvalue = calendar.get(Calendar.YEAR);\n-\t\tappend(buf, count <= 2 ? value % 100 : value, count);\n-\t\tfield = DateFormat.YEAR_FIELD;\n-\t\tbreak;\n-\t      case 'K':\n-\t\tappend(buf, calendar.get(Calendar.HOUR), count);\n-\t\tfield = DateFormat.HOUR0_FIELD;\n-\t\tbreak;\n-\t      case 'h':\n-\t\tvalue = ((calendar.get(Calendar.HOUR) + 11) % 12) + 1;\n-\t\tappend(buf, value, count);\n-\t\tfield = DateFormat.HOUR1_FIELD;\n-\t\tbreak;\n-\t      case 'H':\n-\t\tappend(buf, calendar.get(Calendar.HOUR_OF_DAY), count);\n-\t\tfield = DateFormat.HOUR_OF_DAY0_FIELD;\n-\t\tbreak;\n-\t      case 'k':\n-\t\tvalue = ((calendar.get(Calendar.HOUR_OF_DAY) + 23) % 24) + 1;\n-\t\tappend(buf, value, count);\n-\t\tfield = DateFormat.HOUR_OF_DAY1_FIELD;\n-\t\tbreak;\n-\t      case 'm':\n-\t\tappend(buf, calendar.get(Calendar.MINUTE), count);\n-\t\tfield = DateFormat.MINUTE_FIELD;\n-\t\tbreak;\n-\t      case 's':\n-\t\tappend(buf, calendar.get(Calendar.SECOND), count);\n-\t\tfield = DateFormat.SECOND_FIELD;\n-\t\tbreak;\n-\t      case 'S':\n-\t\tappend(buf, calendar.get(Calendar.MILLISECOND), count);\n-\t\tfield = DateFormat.MILLISECOND_FIELD;\n-\t\tbreak;\n-\t      case 'a':\n-\t\tvalue = calendar.get(calendar.AM_PM);\n-\t\tbuf.append(formatData.getAmPmStrings()[value]);\n-\t\tfield = DateFormat.AM_PM_FIELD;\n-\t\tbreak;\n-\t      case 'z':\n-\t\tString zoneID = calendar.getTimeZone().getID();\n-\t\tString[][] zoneStrings = formatData.getZoneStrings();\n-\t\tint zoneCount = zoneStrings.length;\n-\t\tfor (int j = 0;  j < zoneCount;  j++)\n-\t\t  {\n-\t\t    String[] strings = zoneStrings[j];\n-\t\t    if (zoneID.equals(strings[0]))\n-\t\t      {\n-\t\t\tj = count > 3 ? 2 : 1;\n-\t\t\tif (calendar.get(Calendar.DST_OFFSET) != 0)\n-\t\t\t  j+=2;\n-\t\t\tzoneID = strings[j];\n-\t\t\tbreak;\n-\t\t      }\n-\t\t  }\n-\t\tbuf.append(zoneID);\n-\t\tfield = DateFormat.TIMEZONE_FIELD;\n-\t\tbreak;\n-\t      default:\n-\t\t// Note that the JCL is actually somewhat\n-\t\t// contradictory here.  It defines the pattern letters\n-\t\t// to be a particular list, but also says that a\n-\t\t// pattern containing an invalid pattern letter must\n-\t\t// throw an exception.  It doesn't describe what an\n-\t\t// invalid pattern letter might be, so we just assume\n-\t\t// it is any letter in [a-zA-Z] not explicitly covered\n-\t\t// above.\n-\t\tthrow new RuntimeException(\"bad format string\");\n-\t      }\n-\t    if (pos != null && field == pos.getField())\n-\t      {\n-\t\tpos.setBeginIndex(beginIndex);\n-\t\tpos.setEndIndex(buf.length());\n-\t      }\n+\t    pos.setBeginIndex(beginIndex);\n+\t    pos.setEndIndex(buffer.length());\n \t  }\n+      } else {\n+\tbuffer.append(o.toString());\n       }\n-    return buf;\n+    }\n+    return buffer;\n+  }\n+\n+  private void withLeadingZeros(int value, int length, StringBuffer buffer) {\n+    String valStr = String.valueOf(value);\n+    for (length -= valStr.length(); length > 0; length--)\n+      buffer.append('0');\n+    buffer.append(valStr);\n+  }\n+\n+  private int indexInArray(String dateStr, int index, String[] values) {\n+    int l1 = dateStr.length()-index;\n+    int l2;\n+\n+    for (int i=0; i < values.length; i++) {\n+      if (values[i] == null)\n+        continue;\n+\n+      l2 = values[i].length();\n+      //System.err.println(values[i] + \" \" + dateStr.substring(index,index+l2));\n+      if ((l1 >= l2) && (dateStr.substring(index,index+l2).equals(values[i])))\n+\treturn i;\n+    }\n+    return -1;\n   }\n \n-  private final boolean expect (String source, ParsePosition pos,\n-\t\t\t\tchar ch)\n+  /*\n+   * Get the actual year value, converting two digit years if necessary.\n+   */\n+  private int processYear(int val)\n   {\n-    int x = pos.getIndex();\n-    boolean r = x < source.length() && source.charAt(x) == ch;\n-    if (r)\n-      pos.setIndex(x + 1);\n-    else\n-      pos.setErrorIndex(x);\n-    return r;\n+    if (val > 100)\n+      return val;\n+\n+    Date d = get2DigitYearStart();\n+    Calendar c = Calendar.getInstance();\n+    c.setTime(d);\n+    int y = c.get(YEAR_FIELD);\n+\n+    return ((y / 100) * 100) + val;\n   }\n \n-  public Date parse (String source, ParsePosition pos)\n+  /*\n+   * Ok, we ignore the format string and just try to parse what we can\n+   * out of the string.  We need, month, day, year at a minimum. The real\n+   * killer is stuff like XX/XX/XX.  How do we interpret that?  Is is the\n+   * US style MM/DD/YY or the European style DD/MM/YY. Or is it YYYY/MM/DD?\n+   * I'm an American, so I guess you know which one I'm choosing....\n+   */\n+  private Date parseLenient(String dateStr, ParsePosition pos)\n   {\n-    int fmt_index = 0;\n-    int fmt_max = pattern.length();\n+    int month = -1;\n+    int day = -1;\n+    int year = -1;\n+    int era = -1;\n+    int hour = -1;\n+    int hour24 = -1;\n+    int minute = -1;\n+    int second = -1;\n+    int millis = -1;\n+    int ampm = -1;\n+    int last = -1;\n+    TimeZone tz = null;\n+    char lastsep = ' ';\n+    char nextchar = ' ';\n+\n+    Calendar cal = (Calendar)calendar.clone();\n+    cal.clear();\n+    cal.setTime(new Date(0));\n+\n+    int index = pos.getIndex();\n+    String buf = dateStr.substring(index, dateStr.length());\n \n-    calendar.clear();\n-    int quote_start = -1;\n-    for (; fmt_index < fmt_max; ++fmt_index)\n+    top:\n+    for(;;)\n       {\n-\tchar ch = pattern.charAt(fmt_index);\n-\tif (ch == '\\'')\n-\t  {\n-\t    int index = pos.getIndex();\n-\t    if (fmt_index < fmt_max - 1\n-\t\t&& pattern.charAt(fmt_index + 1) == '\\'')\n-\t      {\n-\t\tif (! expect (source, pos, ch))\n-\t\t  return null;\n-\t\t++fmt_index;\n-\t      }\n-\t    else\n-\t      quote_start = quote_start < 0 ? fmt_index : -1;\n-\t    continue;\n-\t  }\n \n-\tif (quote_start != -1\n-\t    || ((ch < 'a' || ch > 'z')\n-\t\t&& (ch < 'A' || ch > 'Z')))\n-\t  {\n-\t    if (! expect (source, pos, ch))\n-\t      return null;\n-\t    continue;\n-\t  }\n+        // Are we at the end of the string?  If so, make sure we have\n+        // enough data and return. // FIXME: Also detect sufficient data\n+        // and return by setting buf to \"\" on an unparsible string.\n+        if (buf.equals(\"\"))\n+          {\n+            pos.setIndex(index);\n \n-\t// We've arrived at a potential pattern character in the\n-\t// pattern.\n-\tint first = fmt_index;\n-\twhile (++fmt_index < fmt_max && pattern.charAt(fmt_index) == ch)\n-\t  ;\n-\tint count = fmt_index - first;\n-\t--fmt_index;\n-\n-\t// We can handle most fields automatically: most either are\n-\t// numeric or are looked up in a string vector.  In some cases\n-\t// we need an offset.  When numeric, `offset' is added to the\n-\t// resulting value.  When doing a string lookup, offset is the\n-\t// initial index into the string array.\n-\tint calendar_field;\n-\tboolean is_numeric = true;\n-\tString[] match = null;\n-\tint offset = 0;\n-\tint zone_number = 0;\n-\tswitch (ch)\n-\t  {\n-\t  case 'd':\n-\t    calendar_field = Calendar.DATE;\n-\t    break;\n-\t  case 'D':\n-\t    calendar_field = Calendar.DAY_OF_YEAR;\n-\t    break;\n-\t  case 'F':\n-\t    calendar_field = Calendar.DAY_OF_WEEK_IN_MONTH;\n-\t    break;\n-\t  case 'E':\n-\t    is_numeric = false;\n-\t    offset = 1;\n-\t    calendar_field = Calendar.DAY_OF_WEEK;\n-\t    match = (count <= 3\n-\t\t     ? formatData.getShortWeekdays()\n-\t\t     : formatData.getWeekdays());\n-\t    break;\n-\t  case 'w':\n-\t    calendar_field = Calendar.WEEK_OF_YEAR;\n-\t    break;\n-\t  case 'W':\n-\t    calendar_field = Calendar.WEEK_OF_MONTH;\n-\t    break;\n-\t  case 'M':\n-\t    calendar_field = Calendar.MONTH;\n-\t    if (count <= 2)\n-\t      ;\n-\t    else\n-\t      {\n-\t\tis_numeric = false;\n-\t\tmatch = (count <= 3\n-\t\t\t ? formatData.getShortMonths()\n-\t\t\t : formatData.getMonths());\n-\t      }\n-\t    break;\n-\t  case 'y':\n-\t    calendar_field = Calendar.YEAR;\n-\t    if (count <= 2)\n-\t      offset = 1900;\n-\t    break;\n-\t  case 'K':\n-\t    calendar_field = Calendar.HOUR;\n-\t    break;\n-\t  case 'h':\n-\t    calendar_field = Calendar.HOUR;\n-\t    offset = -1;\n-\t    break;\n-\t  case 'H':\n-\t    calendar_field = Calendar.HOUR_OF_DAY;\n-\t    break;\n-\t  case 'k':\n-\t    calendar_field = Calendar.HOUR_OF_DAY;\n-\t    offset = -1;\n-\t    break;\n-\t  case 'm':\n-\t    calendar_field = Calendar.MINUTE;\n-\t    break;\n-\t  case 's':\n-\t    calendar_field = Calendar.SECOND;\n-\t    break;\n-\t  case 'S':\n-\t    calendar_field = Calendar.MILLISECOND;\n-\t    break;\n-\t  case 'a':\n-\t    is_numeric = false;\n-\t    calendar_field = Calendar.AM_PM;\n-\t    match = formatData.getAmPmStrings();\n-\t    break;\n-\t  case 'z':\n-\t    // We need a special case for the timezone, because it\n-\t    // uses a different data structure than the other cases.\n-\t    is_numeric = false;\n-\t    calendar_field = Calendar.DST_OFFSET;\n-\t    String[][] zoneStrings = formatData.getZoneStrings();\n-\t    int zoneCount = zoneStrings.length;\n-\t    int index = pos.getIndex();\n-\t    boolean found_zone = false;\n-\t    for (int j = 0;  j < zoneCount;  j++)\n-\t      {\n-\t\tString[] strings = zoneStrings[j];\n-\t\tint k;\n-\t\tfor (k = 1; k < strings.length; ++k)\n-\t\t  {\n-\t\t    if (source.startsWith(strings[k], index))\n-\t\t      break;\n-\t\t  }\n-\t\tif (k != strings.length)\n-\t\t  {\n-\t\t    if (k > 2)\n-\t\t      ;\t\t// FIXME: dst.\n-\t\t    zone_number = 0; // FIXME: dst.\n-\t\t    // FIXME: raw offset to SimpleTimeZone const.\n-\t\t    calendar.setTimeZone(new SimpleTimeZone (1, strings[0]));\n-\t\t    pos.setIndex(index + strings[k].length());\n-\t\t    break;\n-\t\t  }\n-\t      }\n-\t    if (! found_zone)\n-\t      {\n-\t\tpos.setErrorIndex(pos.getIndex());\n-\t\treturn null;\n-\t      }\n-\t    break;\n-\t  default:\n+            // This is the minimum we need\n+            if ((month == -1) || (day == -1) || (year == -1))\n+              {\n+                pos.setErrorIndex(index);\n+                return null;\n+              }\n+\n+             if (tz != null)\n+               cal.setTimeZone(tz);\n+\n+             cal.set(Calendar.YEAR, year);\n+             cal.set(Calendar.MONTH, month - 1);\n+             cal.set(Calendar.DATE, day);           \n+\n+             if (ampm == 0)\n+               cal.set(Calendar.AM_PM, Calendar.AM);\n+             else if (ampm == 1)\n+               cal.set(Calendar.AM_PM, Calendar.PM);\n+\n+             // If am/pm not set, we assume 24 hour day\n+             if (hour != -1)\n+               {\n+                 if (ampm == -1)\n+                   cal.set(Calendar.HOUR_OF_DAY, hour);\n+                 else\n+                   {\n+                     if (ampm == 0)\n+                       {\n+                         if (hour == 12)\n+                           hour = 0;\n+                       }\n+                     else\n+                       {\n+                         if (hour != 12)\n+                           hour += 12;\n+                       }\n+    \n+                     cal.set(Calendar.HOUR_OF_DAY, hour);\n+                   }\n+               }\n+\n+             if (minute != -1)\n+               cal.set(Calendar.MINUTE, minute);\n+\n+             if (second != -1)\n+               cal.set(Calendar.SECOND, second);\n+\n+             if (millis != -1)\n+               cal.set(Calendar.MILLISECOND, millis);\n+\n+             if (era == 0)\n+               cal.set(Calendar.ERA, GregorianCalendar.BC);\n+             else if (era == 1)\n+               cal.set(Calendar.ERA, GregorianCalendar.AD);\n+\n+             return cal.getTime();\n+          }\n+\n+        // Skip over whitespace and expected punctuation\n+        char c = buf.charAt(0);\n+        boolean comma_found = false;\n+        while(Character.isWhitespace(c) || (c == ':') || \n+              (c == ',') || (c == '.') || (c == '/'))\n+          {\n+            lastsep = c;\n+            if (c == ',') // This is a total and utter crock\n+              comma_found = true;\n+            buf = buf.substring(1);\n+            if (buf.equals(\"\"))\n+              continue;\n+            c = buf.charAt(0);\n+          }\n+\n+        if (comma_found == true)\n+          lastsep = ',';\n+\n+        // Is it a month name?\n+        for (int i = 0; i < formatData.months.length; i++)\n+          if ((formatData.months[i] != null) \n+              && buf.startsWith(formatData.months[i]))\n+            {\n+              month = i + 1;\n+              buf = buf.substring(formatData.months[i].length());\n+              index += formatData.months[i].length();\n+              last = MONTH_FIELD;\n+              continue top;\n+            }\n+\n+        // Is it a short month name?\n+        for (int i = 0; i < formatData.shortMonths.length; i++)\n+          if ((formatData.shortMonths[i] != null) \n+              && buf.startsWith(formatData.shortMonths[i]))\n+            {\n+              month = i + 1;\n+              buf = buf.substring(formatData.shortMonths[i].length());\n+              index += formatData.shortMonths[i].length();\n+              last = MONTH_FIELD;\n+              continue top;\n+            }\n+\n+        // Is it a weekday name?\n+        for (int i = 0; i < formatData.weekdays.length; i++)\n+          if ((formatData.weekdays[i] != null)\n+              && buf.startsWith(formatData.weekdays[i]))\n+            {\n+              buf = buf.substring(formatData.weekdays[i].length());\n+              index += formatData.weekdays[i].length();\n+              last = DAY_OF_WEEK_FIELD;\n+              continue top;\n+            }\n+\n+        // Is it a short weekday name?\n+        for (int i = 0; i < formatData.shortWeekdays.length; i++)\n+          if ((formatData.shortWeekdays[i] != null)\n+              && buf.startsWith(formatData.shortWeekdays[i]))\n+            {\n+              buf = buf.substring(formatData.shortWeekdays[i].length());\n+              index += formatData.shortWeekdays[i].length();\n+              last = DAY_OF_WEEK_FIELD;\n+              continue top;\n+            }\n+\n+        // Is this an am/pm string?\n+        for (int i = 0; i < formatData.ampms.length; i++) {\n+          if ((formatData.ampms[i] != null)\n+              && buf.toLowerCase().startsWith(formatData.ampms[i].toLowerCase()))\n+            {\n+              ampm = i;\n+              buf = buf.substring(formatData.ampms[i].length());\n+              index += formatData.ampms[i].length();\n+              last = AM_PM_FIELD;\n+              continue top;\n+            }\n+        }\n+\n+        // See if we have a number\n+        c = buf.charAt(0);\n+        String nbrstr = \"\";\n+        while (Character.isDigit(c))\n+          {\n+            nbrstr = nbrstr + c;\n+            buf = buf.substring(1);\n+            if (buf.equals(\"\"))\n+              break;\n+            c = buf.charAt(0);\n+          }\n+\n+        // If we didn't get a number, try for a timezone, otherwise set buf\n+        // to \"\" and loop to see if we are done.\n+        if (nbrstr.equals(\"\"))\n+          {\n+            // Ok, try for a timezone name\n+            while(!Character.isWhitespace(c) && (c != ',') && (c != '.') &&\n+                  (c != ':') && (c != '/'))\n+              {\n+                nbrstr = nbrstr + c;\n+                buf = buf.substring(1);\n+                if (buf.equals(\"\"))\n+                  break;\n+                c = buf.charAt(0);\n+              }\n+            TimeZone tmptz = TimeZone.getTimeZone(nbrstr);\n+             \n+            // We get GMT on failure, so be sure we asked for it.\n+            if (tmptz.getID().equals(\"GMT\"))\n+              {\n+                if (!nbrstr.equals(\"GMT\"))\n+                  {\n+                    buf = \"\";\n+                    continue top;\n+                  }\n+              }\n+\n+            tz = tmptz;\n+            last = TIMEZONE_FIELD;\n+            index += nbrstr.length();\n+            continue top;\n+          }\n+\n+        // Convert to integer\n+        int val = 0;\n+        try\n+          {\n+            val = Integer.parseInt(nbrstr);\n+          }\n+        catch(Exception e)\n+          {\n+            return null; // Shouldn't happen\n+          }\n+\n+        if (!buf.equals(\"\"))\n+          nextchar = buf.charAt(0);\n+        else\n+          nextchar = ' ';\n+\n+        // Figure out which value to assign to\n+        // I make bad US assumptions about MM/DD/YYYY\n+        if (last == DAY_OF_WEEK_FIELD)\n+          {\n+            day = val;\n+            last = DATE_FIELD;\n+          }\n+        else if ((last == MONTH_FIELD) && (day != -1))\n+          {\n+            year = processYear(val);\n+            last = YEAR_FIELD;\n+          }\n+        else if (last == MONTH_FIELD)\n+          {\n+            day = val;\n+            last = DATE_FIELD;\n+          }\n+        else if (last == -1)\n+          {\n+            // Assume month\n+            if ((val < 13) && (val > 0))\n+              {\n+                month = val;\n+                last = MONTH_FIELD;\n+              }\n+            // Assume year. This only works for two digit years that aren't\n+            // between 01 and 12\n+            else\n+              {\n+                year = processYear(val);\n+                last = YEAR_FIELD;\n+              } \n+          }\n+        else if ((last == YEAR_FIELD) && ((nextchar == '/') ||\n+                 (nextchar == '.')))\n+          {\n+            month = val;\n+            last = MONTH_FIELD;\n+          }\n+        else if (last == YEAR_FIELD)\n+          {\n+            hour = val;\n+            last = HOUR0_FIELD;\n+          }\n+        else if ((last == DATE_FIELD) && ((nextchar == '/') ||\n+                 (nextchar == '.') || buf.equals(\"\")))\n+          {\n+            year = processYear(val);\n+            last = YEAR_FIELD;\n+          }\n+        else if ((last == DATE_FIELD) && ((lastsep == '/') ||\n+                 (lastsep == '.') || (lastsep == ',')))\n+          {\n+            year = processYear(val);\n+            last = YEAR_FIELD;\n+          }\n+        else if (last == DATE_FIELD)\n+          {\n+            hour = val;\n+            last = HOUR0_FIELD;\n+          }\n+        else if (last == HOUR0_FIELD)\n+          {\n+            minute = val;\n+            last = MINUTE_FIELD;\n+          }\n+        else if (last == MINUTE_FIELD)\n+          {\n+            second = val;\n+            last = SECOND_FIELD;\n+          }\n+        else if (lastsep == '.') \n+          {\n+            ; // This is milliseconds or something.  Ignore it\n+            last = WEEK_OF_YEAR_FIELD; // Just a random value\n+          }\n+        else // It is year. I have spoken!\n+          {\n+            year = processYear(val);\n+            last = YEAR_FIELD;\n+          }\n+      }\n+  }\n+\n+  private int parseLeadingZeros(String dateStr, ParsePosition pos,\n+                                FieldSizePair p)\n+  {\n+    int value;\n+    int index = pos.getIndex();\n+    String buf = null;\n+\n+    if (p.size == 1)\n+      {\n+        char c = dateStr.charAt(index+1);\n+        if ((dateStr.charAt(index) == '1') && \n+             Character.isDigit(dateStr.charAt(index+1)))\n+          buf = dateStr.substring(index, index+2);\n+        else\n+          buf = dateStr.substring(index, index+1);\n+        pos.setIndex(index + buf.length());\n+      }\n+    else if (p.size == 2)\n+      {\n+        buf = dateStr.substring(index, index+2);\n+        pos.setIndex(index+2);\n+      }\n+    else if (p.size == 3)\n+      {\n+        buf = dateStr.substring(index, index+3);\n+        pos.setIndex(index+3);\n+      }\n+    else\n+      {\n+        buf = dateStr.substring(index, index+4);\n+        pos.setIndex(index+4);\n+      }\n+    try\n+      {\n+        value = Integer.parseInt(buf);\n+      }\n+    catch(NumberFormatException nfe)\n+      {\n+        pos.setIndex(index);\n+        pos.setErrorIndex(index);\n+        return -1;\n+      } \n+\n+    return value;\n+  }\n+\n+  /*\n+   * Note that this method doesn't properly protect against\n+   * StringIndexOutOfBoundsException.  FIXME\n+   */\n+  private Date parseStrict(String dateStr, ParsePosition pos)\n+  {\n+    // start looking at position pos.index\n+    Enumeration e = tokens.elements();\n+    Calendar theCalendar = (Calendar) calendar.clone();\n+    theCalendar.clear();\n+    theCalendar.setTime(new Date(0));\n+\n+    int value, index, hour = -1;\n+    String buf;\n+    while (pos.getIndex() < dateStr.length()) {\n+      Object o = e.nextElement();\n+      if (o instanceof FieldSizePair) {\n+\tFieldSizePair p = (FieldSizePair) o;\n+\tswitch (p.field) {\n+\n+\tcase ERA_FIELD:\n+\t  value = indexInArray(dateStr,pos.getIndex(),formatData.eras);\n+\t  if (value == -1) {\n \t    pos.setErrorIndex(pos.getIndex());\n \t    return null;\n \t  }\n+\t  pos.setIndex(pos.getIndex() + formatData.eras[value].length());\n+\t  theCalendar.set(Calendar.ERA,value);\n+\t  break;\n \n-\t// Compute the value we should assign to the field.\n-\tint value;\n-\tif (is_numeric)\n-\t  {\n-\t    numberFormat.setMinimumIntegerDigits(count);\n-\t    Number n = numberFormat.parse(source, pos);\n-\t    if (pos == null || ! (n instanceof Long))\n-\t      return null;\n-\t    value = n.intValue() + offset;\n-\t  }\n-\telse if (match != null)\n-\t  {\n-\t    int index = pos.getIndex();\n-\t    int i;\n-\t    for (i = offset; i < match.length; ++i)\n-\t      {\n-\t\tif (source.startsWith(match[i], index))\n-\t\t  break;\n-\t      }\n-\t    if (i == match.length)\n-\t      {\n-\t\tpos.setErrorIndex(index);\n-\t\treturn null;\n-\t      }\n-\t    pos.setIndex(index + match[i].length());\n-\t    value = i;\n-\t  }\n-\telse\n-\t  value = zone_number;\n+\tcase YEAR_FIELD:\n+          String y;\n+\t  if (p.size < 4)\n+            y = dateStr.substring(pos.getIndex(), pos.getIndex() + 2);\n+          else\n+            y = dateStr.substring(pos.getIndex(), pos.getIndex() + 4);\n+            \n+          int year;\n+          try\n+            {\n+              year = Integer.parseInt(y);\n+            }\n+          catch(NumberFormatException nfe)\n+            {\n+              pos.setErrorIndex(pos.getIndex());\n+              return null;\n+            }\n \n-\t// Assign the value and move on.\n-\ttry\n-\t  {\n-\t    calendar.set(calendar_field, value);\n+\t  if (p.size < 4)\n+            year += get2DigitYearStart().getYear();\n+\n+          theCalendar.set(Calendar.YEAR, year);\n+\t  if (p.size < 4)\n+            pos.setIndex(pos.getIndex()+2);\n+          else\n+            pos.setIndex(pos.getIndex()+4);\n+\t  break;\n+\n+\tcase MONTH_FIELD:\n+          if (p.size > 2)\n+            {\n+              index = pos.getIndex();\n+\n+\t      value = indexInArray(dateStr,pos.getIndex(),\n+                 (p.size == 3) ? formatData.shortMonths : formatData.months);\n+\t      if (value == -1) \n+                {\n+\t          pos.setErrorIndex(pos.getIndex());\n+\t          return null;\n+\t        }\n+              if (p.size == 3)\n+                pos.setIndex(index + formatData.shortMonths[value].length());\n+              else\n+                pos.setIndex(index + formatData.months[value].length());\n+              theCalendar.set(Calendar.MONTH, value);\n+              break;\n+            }\n+\n+          value = parseLeadingZeros(dateStr, pos, p);\n+          if (value == -1)\n+            return null;\n+\n+          theCalendar.set(Calendar.MONTH, value);\n+          break;\n+\n+\tcase DATE_FIELD:\n+          value = parseLeadingZeros(dateStr, pos, p);\n+          if (value == -1)\n+            return null;\n+\n+          theCalendar.set(Calendar.DATE, value);\n+\t  break;\n+\n+\tcase HOUR_OF_DAY1_FIELD:\n+\tcase HOUR_OF_DAY0_FIELD:\n+          index = pos.getIndex();\n+          buf = dateStr.substring(index, index+2);\n+          try\n+            {\n+              value = Integer.parseInt(buf);\n+            }\n+          catch(NumberFormatException nfe)\n+            {\n+              return null;\n+            }\n+          if (p.field == HOUR_OF_DAY0_FIELD)\n+           // theCalendar.set(Calendar.HOUR_OF_DAY, value);\n+            hour = value + 1;\n+          else\n+           // theCalendar.set(Calendar.HOUR_OF_DAY, value-1);\n+            hour = value;\n+          pos.setIndex(index+2);\n+\n+\t  break;\n+\n+\tcase MINUTE_FIELD:\n+          value = parseLeadingZeros(dateStr, pos, p);\n+          if (value == -1)\n+            return null;\n+\n+          theCalendar.set(Calendar.MINUTE, value);\n+\t  break;\n+\n+\tcase SECOND_FIELD:\n+          value = parseLeadingZeros(dateStr, pos, p);\n+          if (value == -1)\n+            return null;\n+\n+          theCalendar.set(Calendar.SECOND, value);\n+\t  break;\n+\n+\tcase MILLISECOND_FIELD:\n+          value = parseLeadingZeros(dateStr, pos, p);\n+          if (value == -1)\n+            return null;\n+         \n+          theCalendar.set(Calendar.MILLISECOND, value);\n+\t  break;\n+\n+\tcase DAY_OF_WEEK_FIELD:\n+\t  value = indexInArray(dateStr,pos.getIndex(),(p.size < 4) ? formatData.shortWeekdays : formatData.weekdays);\n+\t  if (value == -1) {\n+\t    pos.setErrorIndex(pos.getIndex());\n+\t    return null;\n \t  }\n-\t// FIXME: what exception is thrown on an invalid\n-\t// non-lenient set?\n-\tcatch (IllegalArgumentException x)\n-\t  {\n+\t  pos.setIndex(pos.getIndex() + ((p.size < 4) ? formatData.shortWeekdays[value].length()\n+\t    : formatData.weekdays[value].length()));\n+\t  // Note: Calendar.set(Calendar.DAY_OF_WEEK,value) does not work\n+\t  // as implemented in jdk1.1.5 (possibly DAY_OF_WEEK is meant to\n+\t  // be read-only). Instead, calculate number of days offset.\n+\t  theCalendar.add(Calendar.DATE,value \n+\t\t\t  - theCalendar.get(Calendar.DAY_OF_WEEK));\n+\t  // in JDK, this seems to clear the hours, so we'll do the same.\n+\t  theCalendar.set(Calendar.HOUR_OF_DAY,0);\n+\t  break;\n+\n+\tcase DAY_OF_YEAR_FIELD:\n+          value = parseLeadingZeros(dateStr, pos, p);\n+          if (value == -1)\n+            return null;\n+         \n+\t  theCalendar.set(Calendar.DAY_OF_YEAR, value);\n+\t  break;\n+\n+        // Just parse and ignore\n+\tcase DAY_OF_WEEK_IN_MONTH_FIELD:\n+          value = parseLeadingZeros(dateStr, pos, p);\n+          if (value == -1)\n+            return null;\n+         \n+\t  break;\n+\n+        // Just parse and ignore\n+\tcase WEEK_OF_YEAR_FIELD:\n+          value = parseLeadingZeros(dateStr, pos, p);\n+          if (value == -1)\n+            return null;\n+         \n+\t  break;\n+\n+        // Just parse and ignore\n+\tcase WEEK_OF_MONTH_FIELD:\n+          value = parseLeadingZeros(dateStr, pos, p);\n+          if (value == -1)\n+            return null;\n+\n+\t  break;\n+\n+\tcase AM_PM_FIELD:\n+\t  value = indexInArray(dateStr,pos.getIndex(),formatData.ampms);\n+\t  if (value == -1) {\n \t    pos.setErrorIndex(pos.getIndex());\n \t    return null;\n \t  }\n+\t  pos.setIndex(pos.getIndex() + formatData.ampms[value].length());\n+\t  theCalendar.set(Calendar.AM_PM,value);\n+\t  break;\n+\n+\tcase HOUR1_FIELD:\n+\tcase HOUR0_FIELD:\n+          value = parseLeadingZeros(dateStr, pos, p);\n+          if (value == -1)\n+            return null;\n+          if (p.field == HOUR1_FIELD)\n+            theCalendar.set(Calendar.HOUR, value);\n+          if (p.field == HOUR0_FIELD)\n+            theCalendar.set(Calendar.HOUR, value+1);\n+\t  break;\n+\n+\t  /*\n+\tcase TIMEZONE_FIELD:\n+\t  // TODO\n+\t  break;\n+\t  */\n+\n+\tdefault:\n+\t  throw new IllegalArgumentException(\"Illegal pattern character: \" +\n+             p.field);\n+\t} // end switch\n+      } else if (o instanceof String) {\n+\tString ostr = (String) o;\n+\tif (dateStr.substring(pos.getIndex(),pos.getIndex()+ostr.length()).equals(ostr)) {\n+\t  pos.setIndex(pos.getIndex() + ostr.length());\n+\t} else {\n+\t  pos.setErrorIndex(pos.getIndex());\n+\t  return null;\n+\t}\n+      } else if (o instanceof Character) {\n+\tCharacter ochar = (Character) o;\n+\tif (dateStr.charAt(pos.getIndex()) == ochar.charValue()) {\n+\t  pos.setIndex(pos.getIndex() + 1);\n+\t} else {\n+\t  pos.setErrorIndex(pos.getIndex());\n+\t  return null;\n+\t}\n       }\n+    }\n \n-    return calendar.getTime();\n-  }\n+    if (hour != -1)\n+      {\n+        if (theCalendar.get(Calendar.AM_PM) == Calendar.PM)\n+          {\n+            if (hour == 12)\n+              theCalendar.set(Calendar.HOUR_OF_DAY, 12);\n+            else\n+              theCalendar.set(Calendar.HOUR_OF_DAY, hour + 12);\n+          }\n+        else\n+          {\n+            if (hour == 12)\n+              theCalendar.set(Calendar.HOUR_OF_DAY, 0);\n+            else\n+              theCalendar.set(Calendar.HOUR_OF_DAY, hour);\n+          }\n+      }\n \n-  public boolean equals (Object obj)\n-  {\n-    if (! (obj instanceof SimpleDateFormat) || ! super.equals(obj) )\n-      return false;\n-    SimpleDateFormat other = (SimpleDateFormat) obj;\n-    return (DateFormatSymbols.equals(pattern, other.pattern)\n-\t    && DateFormatSymbols.equals(formatData, other.formatData)\n-\t    && DateFormatSymbols.equals(defaultCenturyStart,\n-\t\t\t\t\tother.defaultCenturyStart));\n+    return theCalendar.getTime();\n   }\n \n-  public Object clone ()\n-  {\n-    // We know the superclass just call's Object's generic cloner.\n-    return super.clone ();\n-  }\n+  /**\n+   * This method parses the specified string into a date.\n+   * \n+   * @param dateStr The date string to parse.\n+   * @param pos The input and output parse position\n+   *\n+   * @return The parsed date, or <code>null</code> if the string cannot be\n+   * parsed.\n+   */\n+  public Date parse(String dateStr, ParsePosition pos) {\n+    if (isLenient())\n+       return parseLenient(dateStr, pos);\n+    else\n+       return parseStrict(dateStr, pos);\n \n-  public int hashCode ()\n-  {\n-    int hash = super.hashCode();\n-    if (pattern != null)\n-      hash ^= pattern.hashCode();\n-    return hash;\n   }\n }\n+"}, {"sha": "45c26f6497fb98c2411409c1b7f2547444f7d1a1", "filename": "libjava/java/util/TimeZone.java", "status": "modified", "additions": 1026, "deletions": 114, "changes": 1140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a22add726841748f6c4051f8d9b4278ba5ddbce9/libjava%2Fjava%2Futil%2FTimeZone.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a22add726841748f6c4051f8d9b4278ba5ddbce9/libjava%2Fjava%2Futil%2FTimeZone.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FTimeZone.java?ref=a22add726841748f6c4051f8d9b4278ba5ddbce9", "patch": "@@ -1,189 +1,1101 @@\n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+/* java.util.TimeZone\n+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.util;\n+import java.text.DateFormatSymbols;\n \n /**\n- * @author Per Bothner <bothner@cygnus.com>\n- * @date October 24, 1998.\n- */\n-\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3.\n- * Status:  getAvailableIDs, getDefault, getTimeZone only know about GMT.\n+ * This class represents a time zone offset and handles daylight savings.\n+ * \n+ * You can get the default time zone with <code>getDefault</code>.\n+ * This represents the time zone where program is running.\n+ *\n+ * Another way to create a time zone is <code>getTimeZone</code>, where\n+ * you can give an identifier as parameter.  For instance, the identifier\n+ * of the Central European Time zone is \"CET\".\n+ *\n+ * With the <code>getAvailableIDs</code> method, you can get all the\n+ * supported time zone identifiers.\n+ *\n+ * @see Calendar\n+ * @see SimpleTimeZone\n+ * @author Jochen Hoenicke\n  */\n-\n public abstract class TimeZone implements java.io.Serializable, Cloneable\n {\n+\n+  /**\n+   * Constant used to indicate that a short timezone abbreviation should\n+   * be returned, such as \"EST\"\n+   */\n   public static final int SHORT = 0;\n+\n+  /**\n+   * Constant used to indicate that a long timezone name should be\n+   * returned, such as \"Eastern Standard Time\".\n+   */\n   public static final int LONG = 1;\n \n-  // The fields are as specified in Sun's \"Serialized Form\"\n-  // in the JDK 1.2 beta 4 API specification.\n-  String ID;\n+  /**\n+   * The time zone identifier, e.g. PST.\n+   */\n+  private String ID;\n \n-  static final TimeZone zoneGMT = new SimpleTimeZone(0, \"GMT\");\n-\n-  private static TimeZone zoneDefault;\n+  /**\n+   * The default time zone, as returned by getDefault.\n+   */\n+  private static TimeZone defaultZone;\n \n   private static final long serialVersionUID = 3581463369166924961L;\n \n-  public TimeZone ()\n+  /**\n+   * Hashtable for timezones by ID.  \n+   */\n+  private static final Hashtable timezones = new Hashtable();\n+\n+  static\n   {\n+    TimeZone tz;\n+    // Automatically generated by scripts/timezones.pl\n+    // XXX - Should we read this data from a file?\n+    tz = new SimpleTimeZone(-11000 * 3600, \"Pacific/Niue\");\n+    timezones.put(\"Pacific/Niue\", tz);\n+    timezones.put(\"Pacific/Apia\", tz);\n+    timezones.put(\"Pacific/Midway\", tz);\n+    timezones.put(\"Pacific/Pago_Pago\", tz);\n+    tz = new SimpleTimeZone\n+      (-10000 * 3600, \"America/Adak\",\n+       Calendar.APRIL, 1, Calendar.SUNDAY, 2000 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);\n+    timezones.put(\"America/Adak\", tz);\n+    tz = new SimpleTimeZone(-10000 * 3600, \"HST\");\n+    timezones.put(\"HST\", tz);\n+    timezones.put(\"Pacific/Fakaofo\", tz);\n+    timezones.put(\"Pacific/Honolulu\", tz);\n+    timezones.put(\"Pacific/Johnston\", tz);\n+    timezones.put(\"Pacific/Rarotonga\", tz);\n+    timezones.put(\"Pacific/Tahiti\", tz);\n+    tz = new SimpleTimeZone\n+      (-9000 * 3600, \"America/Juneau\",\n+       Calendar.APRIL, 1, Calendar.SUNDAY, 2000 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);\n+    timezones.put(\"America/Juneau\", tz);\n+    timezones.put(\"America/Anchorage\", tz);\n+    timezones.put(\"America/Nome\", tz);\n+    timezones.put(\"America/Yakutat\", tz);\n+    tz = new SimpleTimeZone(-9000 * 3600, \"Pacific/Gambier\");\n+    timezones.put(\"Pacific/Gambier\", tz);\n+    tz = new SimpleTimeZone(-8500 * 3600, \"Pacific/Marquesas\");\n+    timezones.put(\"Pacific/Marquesas\", tz);\n+    tz = new SimpleTimeZone\n+      (-8000 * 3600, \"PST8PDT\",\n+       Calendar.APRIL, 1, Calendar.SUNDAY, 2000 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);\n+    timezones.put(\"PST8PDT\", tz);\n+    timezones.put(\"America/Dawson\", tz);\n+    timezones.put(\"America/Los_Angeles\", tz);\n+    timezones.put(\"America/Tijuana\", tz);\n+    timezones.put(\"America/Vancouver\", tz);\n+    timezones.put(\"America/Whitehorse\", tz);\n+    timezones.put(\"US/Pacific-New\", tz);\n+    tz = new SimpleTimeZone(-8000 * 3600, \"Pacific/Pitcairn\");\n+    timezones.put(\"Pacific/Pitcairn\", tz);\n+    tz = new SimpleTimeZone(-7000 * 3600, \"MST\");\n+    timezones.put(\"MST\", tz);\n+    timezones.put(\"America/Dawson_Creek\", tz);\n+    timezones.put(\"America/Phoenix\", tz);\n+    tz = new SimpleTimeZone\n+      (-7000 * 3600, \"MST7MDT\",\n+       Calendar.APRIL, 1, Calendar.SUNDAY, 2000 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);\n+    timezones.put(\"MST7MDT\", tz);\n+    timezones.put(\"America/Boise\", tz);\n+    timezones.put(\"America/Chihuahua\", tz);\n+    timezones.put(\"America/Denver\", tz);\n+    timezones.put(\"America/Edmonton\", tz);\n+    timezones.put(\"America/Inuvik\", tz);\n+    timezones.put(\"America/Mazatlan\", tz);\n+    timezones.put(\"America/Shiprock\", tz);\n+    timezones.put(\"America/Yellowknife\", tz);\n+    tz = new SimpleTimeZone(-6000 * 3600, \"America/Regina\");\n+    timezones.put(\"America/Regina\", tz);\n+    timezones.put(\"America/Belize\", tz);\n+    timezones.put(\"America/Costa_Rica\", tz);\n+    timezones.put(\"America/El_Salvador\", tz);\n+    timezones.put(\"America/Guatemala\", tz);\n+    timezones.put(\"America/Managua\", tz);\n+    timezones.put(\"America/Swift_Current\", tz);\n+    timezones.put(\"America/Tegucigalpa\", tz);\n+    timezones.put(\"Pacific/Galapagos\", tz);\n+    tz = new SimpleTimeZone\n+      (-6000 * 3600, \"CST6CDT\",\n+       Calendar.APRIL, 1, Calendar.SUNDAY, 2000 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);\n+    timezones.put(\"CST6CDT\", tz);\n+    timezones.put(\"America/Cambridge_Bay\", tz);\n+    timezones.put(\"America/Cancun\", tz);\n+    timezones.put(\"America/Chicago\", tz);\n+    timezones.put(\"America/Iqaluit\", tz);\n+    timezones.put(\"America/Menominee\", tz);\n+    timezones.put(\"America/Mexico_City\", tz);\n+    timezones.put(\"America/Pangnirtung\", tz);\n+    timezones.put(\"America/Rainy_River\", tz);\n+    timezones.put(\"America/Rankin_Inlet\", tz);\n+    timezones.put(\"America/Winnipeg\", tz);\n+    tz = new SimpleTimeZone\n+      (-6000 * 3600, \"Pacific/Easter\",\n+       Calendar.OCTOBER, 9, -Calendar.SUNDAY, 0 * 3600,\n+       Calendar.MARCH, 9, -Calendar.SUNDAY, 0 * 3600);\n+    timezones.put(\"Pacific/Easter\", tz);\n+    tz = new SimpleTimeZone\n+      (-5000 * 3600, \"America/Grand_Turk\",\n+       Calendar.APRIL, 1, Calendar.SUNDAY, 0 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 0 * 3600);\n+    timezones.put(\"America/Grand_Turk\", tz);\n+    tz = new SimpleTimeZone\n+      (-5000 * 3600, \"America/Havana\",\n+       Calendar.APRIL, 1, 0, 0 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 0 * 3600);\n+    timezones.put(\"America/Havana\", tz);\n+    tz = new SimpleTimeZone(-5000 * 3600, \"EST\");\n+    timezones.put(\"EST\", tz);\n+    timezones.put(\"America/Bogota\", tz);\n+    timezones.put(\"America/Cayman\", tz);\n+    timezones.put(\"America/Guayaquil\", tz);\n+    timezones.put(\"America/Indiana/Indianapolis\", tz);\n+    timezones.put(\"America/Indiana/Knox\", tz);\n+    timezones.put(\"America/Indiana/Marengo\", tz);\n+    timezones.put(\"America/Indiana/Vevay\", tz);\n+    timezones.put(\"America/Indianapolis\", tz);\n+    timezones.put(\"America/Jamaica\", tz);\n+    timezones.put(\"America/Lima\", tz);\n+    timezones.put(\"America/Panama\", tz);\n+    timezones.put(\"America/Port-au-Prince\", tz);\n+    timezones.put(\"America/Porto_Acre\", tz);\n+    tz = new SimpleTimeZone\n+      (-5000 * 3600, \"EST5EDT\",\n+       Calendar.APRIL, 1, Calendar.SUNDAY, 2000 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);\n+    timezones.put(\"EST5EDT\", tz);\n+    timezones.put(\"America/Detroit\", tz);\n+    timezones.put(\"America/Louisville\", tz);\n+    timezones.put(\"America/Montreal\", tz);\n+    timezones.put(\"America/Nassau\", tz);\n+    timezones.put(\"America/New_York\", tz);\n+    timezones.put(\"America/Nipigon\", tz);\n+    timezones.put(\"America/Thunder_Bay\", tz);\n+    tz = new SimpleTimeZone(-4000 * 3600, \"America/Anguilla\");\n+    timezones.put(\"America/Anguilla\", tz);\n+    timezones.put(\"America/Antigua\", tz);\n+    timezones.put(\"America/Aruba\", tz);\n+    timezones.put(\"America/Barbados\", tz);\n+    timezones.put(\"America/Caracas\", tz);\n+    timezones.put(\"America/Curacao\", tz);\n+    timezones.put(\"America/Dominica\", tz);\n+    timezones.put(\"America/Grenada\", tz);\n+    timezones.put(\"America/Guadeloupe\", tz);\n+    timezones.put(\"America/Guyana\", tz);\n+    timezones.put(\"America/La_Paz\", tz);\n+    timezones.put(\"America/Manaus\", tz);\n+    timezones.put(\"America/Martinique\", tz);\n+    timezones.put(\"America/Montserrat\", tz);\n+    timezones.put(\"America/Port_of_Spain\", tz);\n+    timezones.put(\"America/Porto_Velho\", tz);\n+    timezones.put(\"America/Puerto_Rico\", tz);\n+    timezones.put(\"America/Santo_Domingo\", tz);\n+    timezones.put(\"America/St_Kitts\", tz);\n+    timezones.put(\"America/St_Lucia\", tz);\n+    timezones.put(\"America/St_Thomas\", tz);\n+    timezones.put(\"America/St_Vincent\", tz);\n+    timezones.put(\"America/Tortola\", tz);\n+    tz = new SimpleTimeZone\n+      (-4000 * 3600, \"America/Cuiaba\",\n+       Calendar.OCTOBER, 1, Calendar.SUNDAY, 0 * 3600,\n+       Calendar.FEBRUARY, -1, Calendar.SUNDAY, 0 * 3600);\n+    timezones.put(\"America/Cuiaba\", tz);\n+    timezones.put(\"America/Asuncion\", tz);\n+    timezones.put(\"America/Boa_Vista\", tz);\n+    tz = new SimpleTimeZone\n+      (-4000 * 3600, \"America/Thule\",\n+       Calendar.APRIL, 1, Calendar.SUNDAY, 2000 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);\n+    timezones.put(\"America/Thule\", tz);\n+    timezones.put(\"America/Glace_Bay\", tz);\n+    timezones.put(\"America/Goose_Bay\", tz);\n+    timezones.put(\"America/Halifax\", tz);\n+    timezones.put(\"Atlantic/Bermuda\", tz);\n+    tz = new SimpleTimeZone\n+      (-4000 * 3600, \"Antarctica/Palmer\",\n+       Calendar.OCTOBER, 9, -Calendar.SUNDAY, 0 * 3600,\n+       Calendar.MARCH, 9, -Calendar.SUNDAY, 0 * 3600);\n+    timezones.put(\"Antarctica/Palmer\", tz);\n+    timezones.put(\"America/Santiago\", tz);\n+    tz = new SimpleTimeZone\n+      (-4000 * 3600, \"Atlantic/Stanley\",\n+       Calendar.SEPTEMBER, 2, Calendar.SUNDAY, 0 * 3600,\n+       Calendar.APRIL, 16, -Calendar.SUNDAY, 0 * 3600);\n+    timezones.put(\"Atlantic/Stanley\", tz);\n+    tz = new SimpleTimeZone(-3000 * 3600, \"America/Buenos_Aires\");\n+    timezones.put(\"America/Buenos_Aires\", tz);\n+    timezones.put(\"America/Belem\", tz);\n+    timezones.put(\"America/Catamarca\", tz);\n+    timezones.put(\"America/Cayenne\", tz);\n+    timezones.put(\"America/Cordoba\", tz);\n+    timezones.put(\"America/Jujuy\", tz);\n+    timezones.put(\"America/Mendoza\", tz);\n+    timezones.put(\"America/Montevideo\", tz);\n+    timezones.put(\"America/Paramaribo\", tz);\n+    timezones.put(\"America/Rosario\", tz);\n+    tz = new SimpleTimeZone\n+      (-3000 * 3600, \"America/Fortaleza\",\n+       Calendar.OCTOBER, 1, Calendar.SUNDAY, 0 * 3600,\n+       Calendar.FEBRUARY, -1, Calendar.SUNDAY, 0 * 3600);\n+    timezones.put(\"America/Fortaleza\", tz);\n+    timezones.put(\"America/Araguaina\", tz);\n+    timezones.put(\"America/Maceio\", tz);\n+    timezones.put(\"America/Sao_Paulo\", tz);\n+    tz = new SimpleTimeZone\n+      (-3000 * 3600, \"America/Godthab\",\n+       Calendar.MARCH, 30, -Calendar.SATURDAY, 22000 * 3600,\n+       Calendar.OCTOBER, 30, -Calendar.SATURDAY, 22000 * 3600);\n+    timezones.put(\"America/Godthab\", tz);\n+    tz = new SimpleTimeZone\n+      (-3000 * 3600, \"America/Miquelon\",\n+       Calendar.APRIL, 1, Calendar.SUNDAY, 2000 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);\n+    timezones.put(\"America/Miquelon\", tz);\n+    tz = new SimpleTimeZone\n+      (-2500 * 3600, \"America/St_Johns\",\n+       Calendar.APRIL, 1, Calendar.SUNDAY, 2000 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);\n+    timezones.put(\"America/St_Johns\", tz);\n+    tz = new SimpleTimeZone(-2000 * 3600, \"America/Noronha\");\n+    timezones.put(\"America/Noronha\", tz);\n+    timezones.put(\"Atlantic/South_Georgia\", tz);\n+    tz = new SimpleTimeZone\n+      (-1000 * 3600, \"America/Scoresbysund\",\n+       Calendar.MARCH, -1, Calendar.SUNDAY, 0 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 0 * 3600);\n+    timezones.put(\"America/Scoresbysund\", tz);\n+    timezones.put(\"Atlantic/Azores\", tz);\n+    tz = new SimpleTimeZone(-1000 * 3600, \"Atlantic/Cape_Verde\");\n+    timezones.put(\"Atlantic/Cape_Verde\", tz);\n+    timezones.put(\"Atlantic/Jan_Mayen\", tz);\n+    tz = new SimpleTimeZone(0 * 3600, \"GMT\");\n+    timezones.put(\"GMT\", tz);\n+    timezones.put(\"Africa/Abidjan\", tz);\n+    timezones.put(\"Africa/Accra\", tz);\n+    timezones.put(\"Africa/Bamako\", tz);\n+    timezones.put(\"Africa/Banjul\", tz);\n+    timezones.put(\"Africa/Bissau\", tz);\n+    timezones.put(\"Africa/Casablanca\", tz);\n+    timezones.put(\"Africa/Conakry\", tz);\n+    timezones.put(\"Africa/Dakar\", tz);\n+    timezones.put(\"Africa/El_Aaiun\", tz);\n+    timezones.put(\"Africa/Freetown\", tz);\n+    timezones.put(\"Africa/Lome\", tz);\n+    timezones.put(\"Africa/Monrovia\", tz);\n+    timezones.put(\"Africa/Nouakchott\", tz);\n+    timezones.put(\"Africa/Ouagadougou\", tz);\n+    timezones.put(\"Africa/Sao_Tome\", tz);\n+    timezones.put(\"Africa/Timbuktu\", tz);\n+    timezones.put(\"Atlantic/Reykjavik\", tz);\n+    timezones.put(\"Atlantic/St_Helena\", tz);\n+    timezones.put(\"Europe/Belfast\", tz);\n+    timezones.put(\"Europe/Dublin\", tz);\n+    timezones.put(\"Europe/London\", tz);\n+    timezones.put(\"UTC\", tz);\n+    tz = new SimpleTimeZone\n+      (0 * 3600, \"WET\",\n+       Calendar.MARCH, -1, Calendar.SUNDAY, 1000 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 1000 * 3600);\n+    timezones.put(\"WET\", tz);\n+    timezones.put(\"Atlantic/Canary\", tz);\n+    timezones.put(\"Atlantic/Faeroe\", tz);\n+    timezones.put(\"Atlantic/Madeira\", tz);\n+    timezones.put(\"Europe/Lisbon\", tz);\n+    tz = new SimpleTimeZone(1000 * 3600, \"Africa/Algiers\");\n+    timezones.put(\"Africa/Algiers\", tz);\n+    timezones.put(\"Africa/Bangui\", tz);\n+    timezones.put(\"Africa/Brazzaville\", tz);\n+    timezones.put(\"Africa/Douala\", tz);\n+    timezones.put(\"Africa/Kinshasa\", tz);\n+    timezones.put(\"Africa/Lagos\", tz);\n+    timezones.put(\"Africa/Libreville\", tz);\n+    timezones.put(\"Africa/Luanda\", tz);\n+    timezones.put(\"Africa/Malabo\", tz);\n+    timezones.put(\"Africa/Ndjamena\", tz);\n+    timezones.put(\"Africa/Niamey\", tz);\n+    timezones.put(\"Africa/Porto-Novo\", tz);\n+    timezones.put(\"Africa/Tunis\", tz);\n+    tz = new SimpleTimeZone\n+      (1000 * 3600, \"Africa/Windhoek\",\n+       Calendar.SEPTEMBER, 1, Calendar.SUNDAY, 2000 * 3600,\n+       Calendar.APRIL, 1, Calendar.SUNDAY, 2000 * 3600);\n+    timezones.put(\"Africa/Windhoek\", tz);\n+    tz = new SimpleTimeZone\n+      (1000 * 3600, \"CET\",\n+       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);\n+    timezones.put(\"CET\", tz);\n+    timezones.put(\"Africa/Ceuta\", tz);\n+    timezones.put(\"Arctic/Longyearbyen\", tz);\n+    timezones.put(\"Europe/Amsterdam\", tz);\n+    timezones.put(\"Europe/Andorra\", tz);\n+    timezones.put(\"Europe/Belgrade\", tz);\n+    timezones.put(\"Europe/Berlin\", tz);\n+    timezones.put(\"Europe/Bratislava\", tz);\n+    timezones.put(\"Europe/Brussels\", tz);\n+    timezones.put(\"Europe/Budapest\", tz);\n+    timezones.put(\"Europe/Copenhagen\", tz);\n+    timezones.put(\"Europe/Gibraltar\", tz);\n+    timezones.put(\"Europe/Ljubljana\", tz);\n+    timezones.put(\"Europe/Luxembourg\", tz);\n+    timezones.put(\"Europe/Madrid\", tz);\n+    timezones.put(\"Europe/Malta\", tz);\n+    timezones.put(\"Europe/Monaco\", tz);\n+    timezones.put(\"Europe/Oslo\", tz);\n+    timezones.put(\"Europe/Paris\", tz);\n+    timezones.put(\"Europe/Prague\", tz);\n+    timezones.put(\"Europe/Rome\", tz);\n+    timezones.put(\"Europe/San_Marino\", tz);\n+    timezones.put(\"Europe/Sarajevo\", tz);\n+    timezones.put(\"Europe/Skopje\", tz);\n+    timezones.put(\"Europe/Stockholm\", tz);\n+    timezones.put(\"Europe/Tirane\", tz);\n+    timezones.put(\"Europe/Vaduz\", tz);\n+    timezones.put(\"Europe/Vatican\", tz);\n+    timezones.put(\"Europe/Vienna\", tz);\n+    timezones.put(\"Europe/Warsaw\", tz);\n+    timezones.put(\"Europe/Zagreb\", tz);\n+    timezones.put(\"Europe/Zurich\", tz);\n+    timezones.put(\"MET\", tz);\n+    tz = new SimpleTimeZone\n+      (2000 * 3600, \"Africa/Cairo\",\n+       Calendar.APRIL, -1, Calendar.FRIDAY, 0 * 3600,\n+       Calendar.SEPTEMBER, -1, Calendar.THURSDAY, 23000 * 3600);\n+    timezones.put(\"Africa/Cairo\", tz);\n+    tz = new SimpleTimeZone(2000 * 3600, \"Africa/Gaborone\");\n+    timezones.put(\"Africa/Gaborone\", tz);\n+    timezones.put(\"Africa/Blantyre\", tz);\n+    timezones.put(\"Africa/Bujumbura\", tz);\n+    timezones.put(\"Africa/Harare\", tz);\n+    timezones.put(\"Africa/Johannesburg\", tz);\n+    timezones.put(\"Africa/Khartoum\", tz);\n+    timezones.put(\"Africa/Kigali\", tz);\n+    timezones.put(\"Africa/Lubumbashi\", tz);\n+    timezones.put(\"Africa/Lusaka\", tz);\n+    timezones.put(\"Africa/Maputo\", tz);\n+    timezones.put(\"Africa/Maseru\", tz);\n+    timezones.put(\"Africa/Mbabane\", tz);\n+    timezones.put(\"Africa/Tripoli\", tz);\n+    timezones.put(\"Europe/Tallinn\", tz);\n+    tz = new SimpleTimeZone\n+      (2000 * 3600, \"Asia/Amman\",\n+       Calendar.APRIL, 1, 0, 0 * 3600, Calendar.OCTOBER, 1, 0, 0 * 3600);\n+    timezones.put(\"Asia/Amman\", tz);\n+    timezones.put(\"Asia/Damascus\", tz);\n+    tz = new SimpleTimeZone\n+      (2000 * 3600, \"Asia/Beirut\",\n+       Calendar.MARCH, -1, Calendar.SUNDAY, 0 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 0 * 3600);\n+    timezones.put(\"Asia/Beirut\", tz);\n+    tz = new SimpleTimeZone\n+      (2000 * 3600, \"Asia/Gaza\",\n+       Calendar.APRIL, 3, Calendar.FRIDAY, 0 * 3600,\n+       Calendar.OCTOBER, 3, Calendar.FRIDAY, 0 * 3600);\n+    timezones.put(\"Asia/Gaza\", tz);\n+    tz = new SimpleTimeZone\n+      (2000 * 3600, \"Asia/Jerusalem\",\n+       Calendar.APRIL, 1, Calendar.FRIDAY, 2000 * 3600,\n+       Calendar.SEPTEMBER, 1, Calendar.FRIDAY, 2000 * 3600);\n+    timezones.put(\"Asia/Jerusalem\", tz);\n+    tz = new SimpleTimeZone\n+      (2000 * 3600, \"EET\",\n+       Calendar.MARCH, -1, Calendar.SUNDAY, 3000 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 3000 * 3600);\n+    timezones.put(\"EET\", tz);\n+    timezones.put(\"Asia/Istanbul\", tz);\n+    timezones.put(\"Asia/Nicosia\", tz);\n+    timezones.put(\"Europe/Athens\", tz);\n+    timezones.put(\"Europe/Bucharest\", tz);\n+    timezones.put(\"Europe/Chisinau\", tz);\n+    timezones.put(\"Europe/Helsinki\", tz);\n+    timezones.put(\"Europe/Istanbul\", tz);\n+    timezones.put(\"Europe/Kiev\", tz);\n+    timezones.put(\"Europe/Riga\", tz);\n+    timezones.put(\"Europe/Simferopol\", tz);\n+    timezones.put(\"Europe/Sofia\", tz);\n+    timezones.put(\"Europe/Uzhgorod\", tz);\n+    timezones.put(\"Europe/Vilnius\", tz);\n+    timezones.put(\"Europe/Zaporozhye\", tz);\n+    tz = new SimpleTimeZone\n+      (2000 * 3600, \"Europe/Minsk\",\n+       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);\n+    timezones.put(\"Europe/Minsk\", tz);\n+    timezones.put(\"Europe/Kaliningrad\", tz);\n+    tz = new SimpleTimeZone\n+      (3000 * 3600, \"Asia/Baghdad\",\n+       Calendar.APRIL, 1, 0, 3000 * 3600,\n+       Calendar.OCTOBER, 1, 0, 3000 * 3600);\n+    timezones.put(\"Asia/Baghdad\", tz);\n+    tz = new SimpleTimeZone\n+      (3000 * 3600, \"Europe/Tiraspol\",\n+       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);\n+    timezones.put(\"Europe/Tiraspol\", tz);\n+    timezones.put(\"Europe/Moscow\", tz);\n+    tz = new SimpleTimeZone(3000 * 3600, \"Indian/Comoro\");\n+    timezones.put(\"Indian/Comoro\", tz);\n+    timezones.put(\"Africa/Addis_Ababa\", tz);\n+    timezones.put(\"Africa/Asmera\", tz);\n+    timezones.put(\"Africa/Dar_es_Salaam\", tz);\n+    timezones.put(\"Africa/Djibouti\", tz);\n+    timezones.put(\"Africa/Kampala\", tz);\n+    timezones.put(\"Africa/Mogadishu\", tz);\n+    timezones.put(\"Africa/Nairobi\", tz);\n+    timezones.put(\"Antarctica/Syowa\", tz);\n+    timezones.put(\"Asia/Aden\", tz);\n+    timezones.put(\"Asia/Bahrain\", tz);\n+    timezones.put(\"Asia/Kuwait\", tz);\n+    timezones.put(\"Asia/Qatar\", tz);\n+    timezones.put(\"Asia/Riyadh\", tz);\n+    timezones.put(\"Indian/Antananarivo\", tz);\n+    timezones.put(\"Indian/Mayotte\", tz);\n+    tz = new SimpleTimeZone(3500 * 3600, \"Asia/Tehran\");\n+    timezones.put(\"Asia/Tehran\", tz);\n+    tz = new SimpleTimeZone\n+      (4000 * 3600, \"Asia/Baku\",\n+       Calendar.MARCH, -1, Calendar.SUNDAY, 1000 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 1000 * 3600);\n+    timezones.put(\"Asia/Baku\", tz);\n+    tz = new SimpleTimeZone\n+      (4000 * 3600, \"Asia/Tbilisi\",\n+       Calendar.MARCH, -1, Calendar.SUNDAY, 0 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 0 * 3600);\n+    timezones.put(\"Asia/Tbilisi\", tz);\n+    timezones.put(\"Asia/Aqtau\", tz);\n+    tz = new SimpleTimeZone\n+      (4000 * 3600, \"Asia/Yerevan\",\n+       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);\n+    timezones.put(\"Asia/Yerevan\", tz);\n+    timezones.put(\"Europe/Samara\", tz);\n+    tz = new SimpleTimeZone(4000 * 3600, \"Indian/Mauritius\");\n+    timezones.put(\"Indian/Mauritius\", tz);\n+    timezones.put(\"Asia/Dubai\", tz);\n+    timezones.put(\"Asia/Muscat\", tz);\n+    timezones.put(\"Indian/Mahe\", tz);\n+    timezones.put(\"Indian/Reunion\", tz);\n+    tz = new SimpleTimeZone(4500 * 3600, \"Asia/Kabul\");\n+    timezones.put(\"Asia/Kabul\", tz);\n+    tz = new SimpleTimeZone\n+      (5000 * 3600, \"Asia/Aqtobe\",\n+       Calendar.MARCH, -1, Calendar.SUNDAY, 0 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 0 * 3600);\n+    timezones.put(\"Asia/Aqtobe\", tz);\n+    tz = new SimpleTimeZone\n+      (5000 * 3600, \"Asia/Bishkek\",\n+       Calendar.MARCH, -1, Calendar.SUNDAY, 2500 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2500 * 3600);\n+    timezones.put(\"Asia/Bishkek\", tz);\n+    tz = new SimpleTimeZone\n+      (5000 * 3600, \"Asia/Yekaterinburg\",\n+       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);\n+    timezones.put(\"Asia/Yekaterinburg\", tz);\n+    tz = new SimpleTimeZone(5000 * 3600, \"Indian/Kerguelen\");\n+    timezones.put(\"Indian/Kerguelen\", tz);\n+    timezones.put(\"Asia/Ashkhabad\", tz);\n+    timezones.put(\"Asia/Dushanbe\", tz);\n+    timezones.put(\"Asia/Karachi\", tz);\n+    timezones.put(\"Asia/Samarkand\", tz);\n+    timezones.put(\"Asia/Tashkent\", tz);\n+    timezones.put(\"Indian/Chagos\", tz);\n+    timezones.put(\"Indian/Maldives\", tz);\n+    tz = new SimpleTimeZone(5500 * 3600, \"Asia/Calcutta\");\n+    timezones.put(\"Asia/Calcutta\", tz);\n+    tz = new SimpleTimeZone(5750 * 3600, \"Asia/Katmandu\");\n+    timezones.put(\"Asia/Katmandu\", tz);\n+    tz = new SimpleTimeZone(6000 * 3600, \"Antarctica/Mawson\");\n+    timezones.put(\"Antarctica/Mawson\", tz);\n+    timezones.put(\"Asia/Colombo\", tz);\n+    timezones.put(\"Asia/Dacca\", tz);\n+    timezones.put(\"Asia/Thimbu\", tz);\n+    tz = new SimpleTimeZone\n+      (6000 * 3600, \"Asia/Almaty\",\n+       Calendar.MARCH, -1, Calendar.SUNDAY, 0 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 0 * 3600);\n+    timezones.put(\"Asia/Almaty\", tz);\n+    tz = new SimpleTimeZone\n+      (6000 * 3600, \"Asia/Omsk\",\n+       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);\n+    timezones.put(\"Asia/Omsk\", tz);\n+    timezones.put(\"Asia/Novosibirsk\", tz);\n+    tz = new SimpleTimeZone(6500 * 3600, \"Asia/Rangoon\");\n+    timezones.put(\"Asia/Rangoon\", tz);\n+    timezones.put(\"Indian/Cocos\", tz);\n+    tz = new SimpleTimeZone(7000 * 3600, \"Antarctica/Davis\");\n+    timezones.put(\"Antarctica/Davis\", tz);\n+    timezones.put(\"Asia/Bangkok\", tz);\n+    timezones.put(\"Asia/Jakarta\", tz);\n+    timezones.put(\"Asia/Phnom_Penh\", tz);\n+    timezones.put(\"Asia/Saigon\", tz);\n+    timezones.put(\"Asia/Vientiane\", tz);\n+    timezones.put(\"Indian/Christmas\", tz);\n+    tz = new SimpleTimeZone\n+      (7000 * 3600, \"Asia/Krasnoyarsk\",\n+       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);\n+    timezones.put(\"Asia/Krasnoyarsk\", tz);\n+    tz = new SimpleTimeZone(8000 * 3600, \"Antarctica/Casey\");\n+    timezones.put(\"Antarctica/Casey\", tz);\n+    timezones.put(\"Asia/Brunei\", tz);\n+    timezones.put(\"Asia/Chungking\", tz);\n+    timezones.put(\"Asia/Dili\", tz);\n+    timezones.put(\"Asia/Harbin\", tz);\n+    timezones.put(\"Asia/Hong_Kong\", tz);\n+    timezones.put(\"Asia/Kashgar\", tz);\n+    timezones.put(\"Asia/Kuala_Lumpur\", tz);\n+    timezones.put(\"Asia/Kuching\", tz);\n+    timezones.put(\"Asia/Macao\", tz);\n+    timezones.put(\"Asia/Manila\", tz);\n+    timezones.put(\"Asia/Shanghai\", tz);\n+    timezones.put(\"Asia/Singapore\", tz);\n+    timezones.put(\"Asia/Taipei\", tz);\n+    timezones.put(\"Asia/Ujung_Pandang\", tz);\n+    timezones.put(\"Asia/Urumqi\", tz);\n+    timezones.put(\"Australia/Perth\", tz);\n+    tz = new SimpleTimeZone\n+      (8000 * 3600, \"Asia/Irkutsk\",\n+       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);\n+    timezones.put(\"Asia/Irkutsk\", tz);\n+    tz = new SimpleTimeZone\n+      (8000 * 3600, \"Asia/Ulan_Bator\",\n+       Calendar.MARCH, -1, Calendar.SUNDAY, 0 * 3600,\n+       Calendar.SEPTEMBER, -1, Calendar.SUNDAY, 0 * 3600);\n+    timezones.put(\"Asia/Ulan_Bator\", tz);\n+    tz = new SimpleTimeZone(9000 * 3600, \"Asia/Jayapura\");\n+    timezones.put(\"Asia/Jayapura\", tz);\n+    timezones.put(\"Asia/Pyongyang\", tz);\n+    timezones.put(\"Asia/Seoul\", tz);\n+    timezones.put(\"Asia/Tokyo\", tz);\n+    timezones.put(\"Pacific/Palau\", tz);\n+    tz = new SimpleTimeZone\n+      (9000 * 3600, \"Asia/Yakutsk\",\n+       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);\n+    timezones.put(\"Asia/Yakutsk\", tz);\n+    tz = new SimpleTimeZone\n+      (9500 * 3600, \"Australia/Adelaide\",\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600,\n+       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600);\n+    timezones.put(\"Australia/Adelaide\", tz);\n+    timezones.put(\"Australia/Broken_Hill\", tz);\n+    tz = new SimpleTimeZone(9500 * 3600, \"Australia/Darwin\");\n+    timezones.put(\"Australia/Darwin\", tz);\n+    tz = new SimpleTimeZone(10000 * 3600, \"Antarctica/DumontDUrville\");\n+    timezones.put(\"Antarctica/DumontDUrville\", tz);\n+    timezones.put(\"Australia/Brisbane\", tz);\n+    timezones.put(\"Australia/Lindeman\", tz);\n+    timezones.put(\"Pacific/Guam\", tz);\n+    timezones.put(\"Pacific/Port_Moresby\", tz);\n+    timezones.put(\"Pacific/Saipan\", tz);\n+    timezones.put(\"Pacific/Truk\", tz);\n+    timezones.put(\"Pacific/Yap\", tz);\n+    tz = new SimpleTimeZone\n+      (10000 * 3600, \"Asia/Vladivostok\",\n+       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);\n+    timezones.put(\"Asia/Vladivostok\", tz);\n+    tz = new SimpleTimeZone\n+      (10000 * 3600, \"Australia/Hobart\",\n+       Calendar.OCTOBER, 1, Calendar.SUNDAY, 2000 * 3600,\n+       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600);\n+    timezones.put(\"Australia/Hobart\", tz);\n+    tz = new SimpleTimeZone\n+      (10000 * 3600, \"Australia/Melbourne\",\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600,\n+       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600);\n+    timezones.put(\"Australia/Melbourne\", tz);\n+    timezones.put(\"Australia/Sydney\", tz);\n+/******************************************************************\n+ * FIXME: XXX: Not yet available in libgcj.  Need new jdk 1.2\n+ * SimpleTimeZone constructor.\n+    tz = new SimpleTimeZone\n+      (10500 * 3600, \"Australia/Lord_Howe\",\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600,\n+       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600, 500 * 3600);\n+    timezones.put(\"Australia/Lord_Howe\", tz);\n+ ******************************************************************/\n+    tz = new SimpleTimeZone\n+      (11000 * 3600, \"Asia/Magadan\",\n+       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);\n+    timezones.put(\"Asia/Magadan\", tz);\n+    tz = new SimpleTimeZone(11000 * 3600, \"Pacific/Ponape\");\n+    timezones.put(\"Pacific/Ponape\", tz);\n+    timezones.put(\"Pacific/Efate\", tz);\n+    timezones.put(\"Pacific/Guadalcanal\", tz);\n+    timezones.put(\"Pacific/Kosrae\", tz);\n+    timezones.put(\"Pacific/Noumea\", tz);\n+    tz = new SimpleTimeZone(11500 * 3600, \"Pacific/Norfolk\");\n+    timezones.put(\"Pacific/Norfolk\", tz);\n+    tz = new SimpleTimeZone\n+      (12000 * 3600, \"Antarctica/McMurdo\",\n+       Calendar.OCTOBER, 1, Calendar.SUNDAY, 2000 * 3600,\n+       Calendar.MARCH, 3, Calendar.SUNDAY, 2000 * 3600);\n+    timezones.put(\"Antarctica/McMurdo\", tz);\n+    timezones.put(\"Antarctica/South_Pole\", tz);\n+    timezones.put(\"Pacific/Auckland\", tz);\n+    tz = new SimpleTimeZone\n+      (12000 * 3600, \"Asia/Kamchatka\",\n+       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,\n+       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);\n+    timezones.put(\"Asia/Kamchatka\", tz);\n+    timezones.put(\"Asia/Anadyr\", tz);\n+    tz = new SimpleTimeZone\n+      (12000 * 3600, \"Pacific/Fiji\",\n+       Calendar.NOVEMBER, 1, Calendar.SUNDAY, 2000 * 3600,\n+       Calendar.FEBRUARY, -1, Calendar.SUNDAY, 3000 * 3600);\n+    timezones.put(\"Pacific/Fiji\", tz);\n+    tz = new SimpleTimeZone(12000 * 3600, \"Pacific/Tarawa\");\n+    timezones.put(\"Pacific/Tarawa\", tz);\n+    timezones.put(\"Pacific/Funafuti\", tz);\n+    timezones.put(\"Pacific/Kwajalein\", tz);\n+    timezones.put(\"Pacific/Majuro\", tz);\n+    timezones.put(\"Pacific/Nauru\", tz);\n+    timezones.put(\"Pacific/Wake\", tz);\n+    timezones.put(\"Pacific/Wallis\", tz);\n+    tz = new SimpleTimeZone\n+      (12750 * 3600, \"Pacific/Chatham\",\n+       Calendar.OCTOBER, 1, Calendar.SUNDAY, 2750 * 3600,\n+       Calendar.MARCH, 3, Calendar.SUNDAY, 2750 * 3600);\n+    timezones.put(\"Pacific/Chatham\", tz);\n+    tz = new SimpleTimeZone(13000 * 3600, \"Pacific/Enderbury\");\n+    timezones.put(\"Pacific/Enderbury\", tz);\n+    tz = new SimpleTimeZone\n+      (13000 * 3600, \"Pacific/Tongatapu\",\n+       Calendar.OCTOBER, 1, Calendar.SATURDAY, 2000 * 3600,\n+       Calendar.APRIL, 16, -Calendar.SUNDAY, 2000 * 3600);\n+    timezones.put(\"Pacific/Tongatapu\", tz);\n+    tz = new SimpleTimeZone(14000 * 3600, \"Pacific/Kiritimati\");\n+    timezones.put(\"Pacific/Kiritimati\", tz);\n   }\n \n-  public abstract int getOffset (int era, int year, int month,\n-\t\t\t\t int day, int dayOfWeek, int milliseconds);\n \n-  public abstract void setRawOffset (int offsetMillis);\n+  /* Look up default timezone */\n+  static\n+  {\n+    // System.loadLibrary(\"javautil\");\n \n-  public abstract int getRawOffset ();\n+    String tzid = System.getProperty(\"user.timezone\");\n \n-  public String getID () { return ID; }\n+    if (tzid == null)\n+      tzid = getDefaultTimeZoneId();\n \n-  public void setID (String ID) { this.ID = ID; }\n+    if (tzid == null)\n+      tzid = \"GMT\";\n \n-  public final String getDisplayName()\n+    defaultZone = getTimeZone(tzid);\n+  }\n+\n+  /* This method returns us a time zone id string which is in the\n+     form <standard zone name><GMT offset><daylight time zone name>.\n+     The GMT offset is in seconds, except where it is evenly divisible\n+     by 3600, then it is in hours.  If the zone does not observe\n+     daylight time, then the daylight zone name is omitted.  Examples:\n+     in Chicago, the timezone would be CST6CDT.  In Indianapolis \n+     (which does not have Daylight Savings Time) the string would\n+     be EST5\n+   */\n+  private static native String getDefaultTimeZoneId();\n+\n+  /**\n+   * Gets the time zone offset, for current date, modified in case of \n+   * daylight savings.  This is the offset to add to UTC to get the local\n+   * time.\n+   * @param era the era of the given date\n+   * @param year the year of the given date\n+   * @param month the month of the given date, 0 for January.\n+   * @param day the day of month\n+   * @param dayOfWeek the day of week\n+   * @param milliseconds the millis in the day (in local standard time)\n+   * @return the time zone offset in milliseconds.\n+   */\n+  public abstract int getOffset(int era, int year, int month,\n+\t\t\t\tint day, int dayOfWeek, int milliseconds);\n+\n+  /**\n+   * Gets the time zone offset, ignoring daylight savings.  This is\n+   * the offset to add to UTC to get the local time.\n+   * @return the time zone offset in milliseconds.  \n+   */\n+  public abstract int getRawOffset();\n+\n+  /**\n+   * Sets the time zone offset, ignoring daylight savings.  This is\n+   * the offset to add to UTC to get the local time.\n+   * @param offsetMillis the time zone offset to GMT.\n+   */\n+  public abstract void setRawOffset(int offsetMillis);\n+\n+  /**\n+   * Gets the identifier of this time zone. For instance, PST for\n+   * Pacific Standard Time.\n+   * @returns the ID of this time zone.  \n+   */\n+  public String getID()\n   {\n-    return ID;  // FIXME\n+    return ID;\n   }\n \n-  // public final String getDisplayName (Local locale) { ... }  FIXME\n+  /**\n+   * Sets the identifier of this time zone. For instance, PST for\n+   * Pacific Standard Time.\n+   * @param id the new time zone ID.\n+   */\n+  public void setID(String id)\n+  {\n+    this.ID = id;\n+  }\n \n-  public final String getDisplayName (boolean daylight, int style)\n+  /**\n+   * This method returns a string name of the time zone suitable\n+   * for displaying to the user.  The string returned will be the long\n+   * description of the timezone in the current locale.  The name\n+   * displayed will assume daylight savings time is not in effect.\n+   *\n+   * @return The name of the time zone.\n+   */\n+  public final String getDisplayName()\n   {\n-    return ID;  // FIXME\n+    return (getDisplayName(false, LONG, Locale.getDefault()));\n   }\n \n-  /*\n-  public final String getDisplayName (boolean daylight, int style, Locale locale)\n+  /**\n+   * This method returns a string name of the time zone suitable\n+   * for displaying to the user.  The string returned will be the long\n+   * description of the timezone in the specified locale. The name\n+   * displayed will assume daylight savings time is not in effect.\n+   *\n+   * @param locale The locale for this timezone name.\n+   *\n+   * @return The name of the time zone.\n+   */\n+  public final String getDisplayName(Locale locale)\n   {\n-    return ID;  // FIXME\n+    return (getDisplayName(false, LONG, locale));\n   }\n-  */\n \n-  public abstract boolean useDaylightTime();\n+  /**\n+   * This method returns a string name of the time zone suitable\n+   * for displaying to the user.  The string returned will be of the\n+   * specified type in the current locale. \n+   *\n+   * @param dst Whether or not daylight savings time is in effect.\n+   * @param style <code>LONG</code> for a long name, <code>SHORT</code> for\n+   * a short abbreviation.\n+   *\n+   * @return The name of the time zone.\n+   */\n+  public final String getDisplayName(boolean dst, int style)\n+  {\n+    return (getDisplayName(dst, style, Locale.getDefault()));\n+  }\n \n-  public abstract boolean inDaylightTime (Date date);\n \n-  public static synchronized TimeZone getTimeZone (String ID)\n+  /**\n+   * This method returns a string name of the time zone suitable\n+   * for displaying to the user.  The string returned will be of the\n+   * specified type in the specified locale. \n+   *\n+   * @param dst Whether or not daylight savings time is in effect.\n+   * @param style <code>LONG</code> for a long name, <code>SHORT</code> for\n+   * a short abbreviation.\n+   * @param locale The locale for this timezone name.\n+   *\n+   * @return The name of the time zone.\n+   */\n+  public String getDisplayName(boolean dst, int style, Locale locale)\n   {\n-    int i;\n-    for (i = 0; i < tzIDs.length; ++i)\n+    DateFormatSymbols dfs;\n+    try\n       {\n-\tif (ID.equals(tzIDs[i]))\n-\t  break;\n-      }\n-    if (i == tzIDs.length)\n-      return null;\n+\tdfs = new DateFormatSymbols(locale);\n \n-    if (timeZones[i] == null)\n+\t// The format of the value returned is defined by us.\n+\tString[][]zoneinfo = dfs.getZoneStrings();\n+\tfor (int i = 0; i < zoneinfo.length; i++)\n+\t  {\n+\t    if (zoneinfo[i][0].equals(getID()))\n+\t      {\n+\t\tif (!dst)\n+\t\t  {\n+\t\t    if (style == SHORT)\n+\t\t      return (zoneinfo[i][2]);\n+\t\t    else\n+\t\t      return (zoneinfo[i][1]);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    if (style == SHORT)\n+\t\t      return (zoneinfo[i][4]);\n+\t\t    else\n+\t\t      return (zoneinfo[i][3]);\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n+    catch (MissingResourceException e)\n       {\n-\tif (ID.equals(\"GMT\"))\n-\t  timeZones[i] = zoneGMT;\n-\telse\n-\t  timeZones[i] = new SimpleTimeZone (rawOffsets[i], tzIDs[i]);\n       }\n \n-    return timeZones[i];\n+    return getDefaultDisplayName(dst);\n   }\n \n-  public static String[] getAvailableIDs()\n+  private String getDefaultDisplayName(boolean dst)\n   {\n-    return (String[]) tzIDs.clone();\n+    int offset = getRawOffset();\n+    if (dst && this instanceof SimpleTimeZone)\n+      {\n+\t// ugly, but this is a design failure of the API:\n+\t// getDisplayName takes a dst parameter even though\n+\t// TimeZone knows nothing about daylight saving offsets.\n+\toffset += ((SimpleTimeZone) this).getDSTSavings();\n+      }\n+\n+    StringBuffer sb = new StringBuffer(9);\n+    sb.append(\"GMT\");\n+    sb.append(offset >= 0 ? '+' : '-');\n+\n+    offset = Math.abs(offset) / (1000 * 60);\n+    int hours = offset / 60;\n+    int minutes = offset % 60;\n+\n+    sb.append('0' + hours / 10).append('0' + hours % 10).append(':');\n+    sb.append('0' + minutes / 10).append('0' + minutes % 10);\n+    return sb.toString();\n   }\n \n-  public static String[] getAvailableIDs(int rawOffset)\n-  {\n-    int first, last;\n+  /** \n+   * Returns true, if this time zone uses Daylight Savings Time.\n+   */\n+  public abstract boolean useDaylightTime();\n \n-    for (first = 0; first < rawOffsets.length; ++first)\n-      {\n-\tif (rawOffset == rawOffsets[first])\n-\t  break;\n-      }\n-    if (first == rawOffsets.length)\n-      return new String[0];\n-    for (last = first + 1; last < rawOffsets.length; ++last)\n+  /**\n+   * Returns true, if the given date is in Daylight Savings Time in this\n+   * time zone.\n+   * @param date the given Date.\n+   */\n+  public abstract boolean inDaylightTime(Date date);\n+\n+  /**\n+   * Gets the TimeZone for the given ID.\n+   * @param ID the time zone identifier.\n+   * @return The time zone for the identifier or GMT, if no such time\n+   * zone exists.\n+   */\n+  // FIXME: XXX: JCL indicates this and other methods are synchronized.\n+  public static TimeZone getTimeZone(String ID)\n+  {\n+    // First check timezones hash\n+    TimeZone tz = (TimeZone) timezones.get(ID);\n+    if (tz != null)\n       {\n-\tif (rawOffset != rawOffsets[last])\n-\t  break;\n+\tif (tz.getID().equals(ID))\n+\t  return tz;\n+\n+\t// We always return a timezone with the requested ID.\n+\t// This is the same behaviour as with JDK1.2.\n+\ttz = (TimeZone) tz.clone();\n+\ttz.setID(ID);\n+\t// We also save the alias, so that we return the same\n+\t// object again if getTimeZone is called with the same\n+\t// alias.\n+\ttimezones.put(ID, tz);\n+\treturn tz;\n       }\n \n-    String[] r = new String[last - first];\n-    for (int i = first; i < last; ++i)\n+    // See if the ID is really a GMT offset form.\n+    // Note that GMT is in the table so we know it is different.\n+    if (ID.startsWith(\"GMT\"))\n       {\n-\tr[i - first] = tzIDs[i];\n-      }\n+\tint pos = 3;\n+\tint offset_direction = 1;\n \n-    return r;\n-  }\n+\tif (ID.charAt(pos) == '-')\n+\t  {\n+\t    offset_direction = -1;\n+\t    pos++;\n+\t  }\n+\telse if (ID.charAt(pos) == '+')\n+\t  {\n+\t    pos++;\n+\t  }\n \n-  private static synchronized TimeZone setDefault()\n-  {\n-    if (zoneDefault == null)\n-      {\n \ttry\n \t  {\n-\t    String id = System.getProperty(\"user.timezone\");\n-\t    if (id != null && ! id.equals(\"GMT\"))\n-\t      zoneDefault = getTimeZone(id);\n+\t    int hour, minute;\n+\n+\t    String offset_str = ID.substring(pos);\n+\t    int idx = offset_str.indexOf(\":\");\n+\t    if (idx != -1)\n+\t      {\n+\t\thour = Integer.parseInt(offset_str.substring(0, idx));\n+\t\tminute = Integer.parseInt(offset_str.substring(idx + 1));\n+\t      }\n+\t    else\n+\t      {\n+\t\tint offset_length = offset_str.length();\n+\t\tif (offset_length <= 2)\n+\t\t  {\n+\t\t    // Only hour\n+\t\t    hour = Integer.parseInt(offset_str);\n+\t\t    minute = 0;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    // hour and minute, not separated by colon\n+\t\t    hour = Integer.parseInt\n+\t\t      (offset_str.substring(0, offset_length - 2));\n+\t\t    minute = Integer.parseInt\n+\t\t      (offset_str.substring(offset_length - 2));\n+\t\t  }\n+\t      }\n+\n+\t    return new SimpleTimeZone((hour * (60 * 60 * 1000) +\n+\t\t\t\t       minute * (60 * 1000))\n+\t\t\t\t      * offset_direction, ID);\n \t  }\n-\tcatch (Exception ex)\n+\tcatch (NumberFormatException e)\n \t  {\n \t  }\n-\tif (zoneDefault == null)\n-\t  zoneDefault = zoneGMT;\n       }\n-    return zoneDefault;\n+\n+    // Finally, return GMT per spec\n+    return getTimeZone(\"GMT\");\n   }\n \n-  public static TimeZone getDefault()\n+  /**\n+   * Gets the available IDs according to the given time zone\n+   * offset.  \n+   * @param rawOffset the given time zone GMT offset.\n+   * @return An array of IDs, where the time zone has the specified GMT\n+   * offset. For example <code>{\"Phoenix\", \"Denver\"}</code>, since both have\n+   * GMT-07:00, but differ in daylight savings behaviour.\n+   */\n+/******************************************************************\n+ * FIXME: XXX: Not yet available in libgcj.  Need jdk 1.2 Iterator and Map.\n+  public static String[] getAvailableIDs(int rawOffset)\n   {\n-    return zoneDefault == null ? setDefault() : zoneDefault;\n+    int count = 0;\n+    Iterator iter = timezones.entrySet().iterator();\n+    while (iter.hasNext())\n+      {\n+\t// Don't iterate the values, since we want to count \n+\t// doubled values (aliases)\n+\tMap.Entry entry = (Map.Entry) iter.next();\n+\tif (((TimeZone) entry.getValue()).getRawOffset() == rawOffset)\n+\t  count++;\n+      }\n+\n+    String[] ids = new String[count];\n+    count = 0;\n+    iter = timezones.entrySet().iterator();\n+    while (iter.hasNext())\n+      {\n+\tMap.Entry entry = (Map.Entry) iter.next();\n+\tif (((TimeZone) entry.getValue()).getRawOffset() == rawOffset)\n+\t  ids[count++] = (String) entry.getKey();\n+      }\n+    return ids;\n   }\n+ ******************************************************************/\n \n-  public static void setDefault (TimeZone zone) { zoneDefault = zone; }\n+  /**\n+   * Gets all available IDs.\n+   * @return An array of all supported IDs.\n+   */\n+/******************************************************************\n+ * FIXME: XXX: Not yet available in libgcj.  Need jdk 1.2 java.util.Map.\n+  public static String[] getAvailableIDs()\n+  {\n+    return (String[])\n+      timezones.keySet().toArray(new String[timezones.size()]);\n+  }\n+ ******************************************************************/\n \n-  public boolean hasSameRules (TimeZone other)\n+  /**\n+   * Returns the time zone under which the host is running.  This\n+   * can be changed with setDefault.\n+   * @return the time zone for this host.\n+   * @see #setDefault\n+   */\n+  public static TimeZone getDefault()\n   {\n-    return this == other;\n+    return defaultZone;\n   }\n \n-  public Object clone ()\n+  public static void setDefault(TimeZone zone)\n   {\n-    // Just use Object's generic cloner.\n-    return super.clone ();\n+    defaultZone = zone;\n   }\n \n-  // Names of timezones.  This array is kept in parallel with\n-  // rawOffsets.  This list comes from the JCL 1.1 book.\n-  private static final String[] tzIDs =\n+  /**\n+   * Test if the other time zone uses the same rule and only\n+   * possibly differs in ID.  This implementation for this particular\n+   * class will return true if the raw offsets are identical.  Subclasses\n+   * should override this method if they use daylight savings.\n+   * @return true if this zone has the same raw offset\n+   */\n+  public boolean hasSameRules(TimeZone other)\n   {\n-    \"MIT\", \"HST\", \"AST\", \"PST\", \"PNT\",\n-    \"MST\", \"CST\", \"EST\", \"IET\", \"PRT\",\n-    \"CNT\", \"AGT\", \"BET\", \"CAT\", \"GMT\",\n-    \"ECT\", \"EET\", \"ART\", \"EAT\", \"MET\",\n-    \"NET\", \"PLT\", \"IST\", \"BST\", \"VST\",\n-    \"CTT\", \"JST\", \"ACT\", \"AET\", \"SST\",\n-    \"NST\"\n-  };\n-  // This holds raw offsets in milliseconds.\n-  // 3600000 == 60 * 60 * 1000\n-  private static final int[] rawOffsets =\n+    return other.getRawOffset() == getRawOffset();\n+  }\n+\n+  /**\n+   * Returns a clone of this object.  I can't imagine, why this is\n+   * useful for a time zone.\n+   */\n+  public Object clone()\n   {\n-    -11 * 3600000, -10 * 3600000, -9 * 3600000, -8 * 3600000, -7 * 3600000,\n-    -7 * 3600000, -6 * 3600000, -5 * 3600000, -5 * 3600000, -4 * 3600000,\n-    -35 * 360000, -3 * 3600000, -3 * 3600000, -1 * 3600000, 0,\n-    1 * 3600000, 1 * 3600000, 2 * 3600000, 3 * 3600000, 35 * 360000,\n-    4 * 3600000, 5 * 3600000, 55 * 360000, 6 * 3600000, 7 * 3600000,\n-    8 * 3600000, 9 * 3600000, 95 * 360000, 10 * 3600000, 11 * 3600000,\n-    12 * 3600000\n-  };\n-  // This caches all the corresponding zone objects.\n-  private static TimeZone[] timeZones = new TimeZone[tzIDs.length];\n+    try\n+      {\n+\treturn super.clone();\n+      }\n+    catch (CloneNotSupportedException ex)\n+      {\n+\treturn null;\n+      }\n+  }\n+\n+  static final TimeZone zoneGMT = new SimpleTimeZone(0, \"GMT\");\n }"}, {"sha": "61128c833b60bcc9b2e05fc8fd443e4a70bb8dfb", "filename": "libjava/java/util/natTimeZone.cc", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a22add726841748f6c4051f8d9b4278ba5ddbce9/libjava%2Fjava%2Futil%2FnatTimeZone.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a22add726841748f6c4051f8d9b4278ba5ddbce9/libjava%2Fjava%2Futil%2FnatTimeZone.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FnatTimeZone.cc?ref=a22add726841748f6c4051f8d9b4278ba5ddbce9", "patch": "@@ -0,0 +1,72 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <config.h>\n+\n+#include <gcj/cni.h>\n+#include <java/util/TimeZone.h>\n+\n+#include <stdio.h>\n+#include <string.h>\n+\n+#if TIME_WITH_SYS_TIME\n+# include <sys/time.h>\n+# include <time.h>\n+#else\n+# if HAVE_SYS_TIME_H\n+#  include <sys/time.h>\n+# else\n+#  include <time.h>\n+# endif\n+#endif\n+\n+/*\n+ * This method returns a time zone string that is used by the static\n+ * initializer in java.util.TimeZone to create the default timezone\n+ * instance.  This is a key into the timezone table used by\n+ * that class.\n+ */\n+jstring\n+java::util::TimeZone::getDefaultTimeZoneId (void)\n+{\n+  time_t current_time;\n+  char **tzinfo, *tzid;\n+  long tzoffset;\n+  jstring retval;\n+\n+  current_time = time(0);\n+\n+  mktime(localtime(&current_time));\n+  tzinfo = tzname;\n+  tzoffset = timezone;\n+\n+  if ((tzoffset % 3600) == 0)\n+    tzoffset = tzoffset / 3600;\n+\n+  if (!strcmp(tzinfo[0], tzinfo[1]))  \n+    {\n+      tzid = (char*) _Jv_Malloc (strlen(tzinfo[0]) + 6);\n+      if (!tzid)\n+        return NULL;\n+\n+      sprintf(tzid, \"%s%ld\", tzinfo[0], tzoffset);\n+    }\n+  else\n+    {\n+      tzid = (char*) _Jv_Malloc (strlen(tzinfo[0]) + strlen(tzinfo[1]) + 6);\n+      if (!tzid)\n+        return NULL;\n+\n+      sprintf(tzid, \"%s%ld%s\", tzinfo[0], tzoffset, tzinfo[1]);\n+    }\n+\n+  retval = JvNewStringUTF (tzid);\n+  _Jv_Free (tzid);\n+  return retval;\n+}\n+"}]}