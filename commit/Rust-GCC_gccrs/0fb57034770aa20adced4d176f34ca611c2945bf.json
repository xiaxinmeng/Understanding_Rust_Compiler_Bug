{"sha": "0fb57034770aa20adced4d176f34ca611c2945bf", "node_id": "C_kwDOANBUbNoAKDBmYjU3MDM0NzcwYWEyMGFkY2VkNGQxNzZmMzRjYTYxMWMyOTQ1YmY", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-12-05T16:11:12Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-12-08T23:58:58Z"}, "message": "d: Merge upstream dmd 568496d5b, druntime 178c44ff, phobos 574bf883b.\n\nD front-end changes:\n\n    - Import dmd v2.098.0\n    - New ImportC module for compiling preprocessed C11 code into D.\n    - New -ftransition=in switch.\n    - Improved handling of new 'noreturn' type.\n\nDruntime changes:\n\n    - Import druntime v2.098.0\n    - Fix broken import in core.sys.linux.perf_event module (PR103558).\n\nPhobos changes:\n\n    - Import phobos v2.098.0\n    - All sources are now compiled with -fpreview=fieldwise.\n\ngcc/d/ChangeLog:\n\n\t* dmd/MERGE: Merge upstream dmd 568496d5b.\n\t* Make-lang.in (D_FRONTEND_OBJS): Add d/common-file.o,\n\td/common-outbuffer.o, d/common-string.o, d/file_manager.o,\n\td/importc.o.  Remove d/root-outbuffer.o.\n\t(d/common-%.o): New recipe.\n\t* d-builtins.cc (build_frontend_type): Update for new front-end\n\tinterface.\n\t(d_build_d_type_nodes): Set noreturn_type_node.\n\t* d-codegen.cc (d_build_call): Don't call function if one of the\n\targuments is type 'noreturn'.\n\t(build_vthis_function): Propagate TYPE_QUAL_VOLATILE from original\n\tfunction type.\n\t* d-frontend.cc (eval_builtin): Update signature.\n\t(getTypeInfoType): Likewise.\n\t(toObjFile): New function.\n\t* d-gimplify.cc (d_gimplify_call_expr): Always evaluate arguments from\n\tleft to right.\n\t* d-lang.cc (d_handle_option): Handle OPT_ftransition_in.\n\t(d_parse_file): Don't generate D main if it is declared in user code.\n\t* d-tree.h (CALL_EXPR_ARGS_ORDERED): Remove.\n\t(enum d_tree_index): Add DTI_BOTTOM_TYPE.\n\t(noreturn_type_node): New.\n\t* decl.cc (apply_pragma_crt): Remove.\n\t(DeclVisitor::visit): Update for new front-end interface.\n\t(DeclVisitor::visit (PragmaDeclaration *)): Don't handle\n\tcrt_constructor and crt_destructor pragmas.\n\t(DeclVisitor::visit (VarDeclaration *)): Don't generate declarations\n\tof type 'noreturn'.\n\t(DeclVisitor::visit (FuncDeclaration *)): Stop adding parameters when\n\t'noreturn' type has been encountered.\n\t(get_symbol_decl): Set DECL_STATIC_CONSTRUCTOR and\n\tDECL_STATIC_DESTRUCTOR on decl node if requested.\n\t(aggregate_initializer_decl): Update for new front-end interface.\n\t* expr.cc (ExprVisitor::visit (CallExp *)): Always use the 'this'\n\tobject as the result of calling any constructor function.\n\t(ExprVisitor::visit): Update for new front-end interface.\n\t* gdc.texi (Runtime Options): Document -fmain and -ftransition=in.\n\t* lang.opt (ftransition=in): New option.\n\t* modules.cc (get_internal_fn): Update for new front-end interface.\n\t* types.cc (TypeVisitor::visit): Likewise.\n\t(TypeVisitor::visit (TypeNoreturn *)): Return noreturn_type_node.\n\t(TypeVisitor::visit (TypeFunction *)): Stop adding parameters when\n\t'notreturn' type has been encountered.  Qualify function types that\n\treturn 'noreturn' as TYPE_QUAL_VOLATILE.\n\nlibphobos/ChangeLog:\n\n\tPR d/103558\n\t* libdruntime/MERGE: Merge upstream druntime 178c44ff.\n\t* libdruntime/Makefile.am (DRUNTIME_DSOURCES_LINUX): Add\n\tcore/sys/linux/syscalls.d.\n\t(DRUNTIME_DSOURCES_OPENBSD): Add core/sys/openbsd/pthread_np.d.\n\t* libdruntime/Makefile.in: Regenerate.\n\t* src/MERGE: Merge upstream phobos 574bf883b.\n\t* src/Makefile.am (D_EXTRA_DFLAGS): Add -fpreview=fieldwise.\n\t* src/Makefile.in: Regenerate.\n\t* testsuite/libphobos.exceptions/assert_fail.d: Update test.\n\t* testsuite/libphobos.betterc/test22336.d: New test.", "tree": {"sha": "1f5735c8b4f25aa4a290e5ae8124713c24f98359", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f5735c8b4f25aa4a290e5ae8124713c24f98359"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fb57034770aa20adced4d176f34ca611c2945bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fb57034770aa20adced4d176f34ca611c2945bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fb57034770aa20adced4d176f34ca611c2945bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fb57034770aa20adced4d176f34ca611c2945bf/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c15aa46cca0649b68613d3292cf71c7cc57ef78f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c15aa46cca0649b68613d3292cf71c7cc57ef78f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c15aa46cca0649b68613d3292cf71c7cc57ef78f"}], "stats": {"total": 16533, "additions": 11451, "deletions": 5082}, "files": [{"sha": "d7f714760f7aafd4f43a9e0936da85e256ef0ac1", "filename": "gcc/d/Make-lang.in", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2FMake-lang.in?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -89,6 +89,9 @@ D_FRONTEND_OBJS = \\\n \td/canthrow.o \\\n \td/chkformat.o \\\n \td/clone.o \\\n+\td/common-file.o \\\n+\td/common-outbuffer.o \\\n+\td/common-string.o \\\n \td/compiler.o \\\n \td/complex.o \\\n \td/cond.o \\\n@@ -120,6 +123,7 @@ D_FRONTEND_OBJS = \\\n \td/escape.o \\\n \td/expression.o \\\n \td/expressionsem.o \\\n+\td/file_manager.o \\\n \td/foreachvar.o \\\n \td/func.o \\\n \td/globals.o \\\n@@ -131,6 +135,7 @@ D_FRONTEND_OBJS = \\\n \td/identifier.o \\\n \td/impcnvtab.o \\\n \td/imphint.o \\\n+\td/importc.o \\\n \td/init.o \\\n \td/initsem.o \\\n \td/inline.o \\\n@@ -157,7 +162,6 @@ D_FRONTEND_OBJS = \\\n \td/root-filename.o \\\n \td/root-hash.o \\\n \td/root-longdouble.o \\\n-\td/root-outbuffer.o \\\n \td/root-port.o \\\n \td/root-region.o \\\n \td/root-rmem.o \\\n@@ -393,6 +397,10 @@ d/%.o: d/dmd/%.d\n \t$(DCOMPILE) $(D_INCLUDES) $<\n \t$(DPOSTCOMPILE)\n \n+d/common-%.o: d/dmd/common/%.d\n+\t$(DCOMPILE) $(D_INCLUDES) $<\n+\t$(DPOSTCOMPILE)\n+\n d/root-%.o: d/dmd/root/%.d\n \t$(DCOMPILE) $(D_INCLUDES) $<\n \t$(DPOSTCOMPILE)"}, {"sha": "ea8e1eda24419aef128456f4df6df8292ad1af92", "filename": "gcc/d/d-builtins.cc", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fd-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fd-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-builtins.cc?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -236,7 +236,7 @@ build_frontend_type (tree type)\n       sdecl->parent = stubmod;\n       sdecl->structsize = int_size_in_bytes (type);\n       sdecl->alignsize = TYPE_ALIGN_UNIT (type);\n-      sdecl->alignment = STRUCTALIGN_DEFAULT;\n+      sdecl->alignment.setDefault ();\n       sdecl->sizeok = Sizeok::done;\n       sdecl->type = (TypeStruct::create (sdecl))->addMod (mod);\n       sdecl->type->ctype = type;\n@@ -275,7 +275,7 @@ build_frontend_type (tree type)\n \t\t\t\t\t\t       NULL);\n \t  vd->parent = sdecl;\n \t  vd->offset = tree_to_uhwi (byte_position (field));\n-\t  vd->semanticRun = PASSsemanticdone;\n+\t  vd->semanticRun = PASS::semanticdone;\n \t  vd->csym = field;\n \t  sdecl->members->push (vd);\n \t  sdecl->fields.push (vd);\n@@ -856,6 +856,9 @@ d_build_d_type_nodes (void)\n   ireal_type_node = build_distinct_type_copy (long_double_type_node);\n   TYPE_IMAGINARY_FLOAT (ireal_type_node) = 1;\n \n+  /* Noreturn type.  */\n+  noreturn_type_node = build_distinct_type_copy (void_type_node);\n+\n   /* Calling build_ctype() links the front-end Type to the GCC node,\n      and sets the TYPE_NAME to the D language type.  */\n   for (unsigned ty = 0; ty < (unsigned) TY::TMAX; ty++)"}, {"sha": "c082ac5ab80fd73da87ff3d468a5ac178e6cc000", "filename": "gcc/d/d-codegen.cc", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fd-codegen.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fd-codegen.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-codegen.cc?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -2140,6 +2140,7 @@ d_build_call (TypeFunction *tf, tree callable, tree object,\n   /* Build the argument list for the call.  */\n   vec <tree, va_gc> *args = NULL;\n   tree saved_args = NULL_TREE;\n+  bool noreturn_call = false;\n \n   /* If this is a delegate call or a nested function being called as\n      a delegate, the object should not be NULL.  */\n@@ -2165,9 +2166,9 @@ d_build_call (TypeFunction *tf, tree callable, tree object,\n \t    }\n \t}\n \n-      size_t nparams = tf->parameterList.length ();\n+      const size_t nparams = tf->parameterList.length ();\n       /* if _arguments[] is the first argument.  */\n-      size_t varargs = tf->isDstyleVariadic ();\n+      const size_t varargs = tf->isDstyleVariadic ();\n \n       /* Assumes arguments->length <= formal_args->length if (!tf->varargs).  */\n       for (size_t i = 0; i < arguments->length; ++i)\n@@ -2206,6 +2207,11 @@ d_build_call (TypeFunction *tf, tree callable, tree object,\n \t\t\t      build_address (targ));\n \t    }\n \n+  \t  /* Type `noreturn` is a terminator, as no other arguments can possibly\n+  \t     be evaluated after it.  */\n+  \t  if (TREE_TYPE (targ) == noreturn_type_node)\n+\t    noreturn_call = true;\n+\n \t  vec_safe_push (args, targ);\n \t}\n     }\n@@ -2217,13 +2223,27 @@ d_build_call (TypeFunction *tf, tree callable, tree object,\n       saved_args = compound_expr (callee, saved_args);\n     }\n \n+  /* If we saw a `noreturn` parameter, any unreachable argument evaluations\n+     after it are discarded, as well as the function call itself.  */\n+  if (noreturn_call)\n+    {\n+      if (TREE_SIDE_EFFECTS (callee))\n+\tsaved_args = compound_expr (callee, saved_args);\n+\n+      tree arg;\n+      unsigned int ix;\n+\n+      FOR_EACH_VEC_SAFE_ELT (args, ix, arg)\n+\tsaved_args = compound_expr (saved_args, arg);\n+\n+      /* Add a stub result type for the expression.  */\n+      tree result = build_zero_cst (TREE_TYPE (ctype));\n+      return compound_expr (saved_args, result);\n+    }\n+\n   tree result = build_call_vec (TREE_TYPE (ctype), callee, args);\n   SET_EXPR_LOCATION (result, input_location);\n \n-  /* Enforce left to right evaluation.  */\n-  if (tf->linkage == LINK::d)\n-    CALL_EXPR_ARGS_ORDERED (result) = 1;\n-\n   result = maybe_expand_intrinsic (result);\n \n   /* Return the value in a temporary slot so that it can be evaluated\n@@ -2296,6 +2316,10 @@ build_vthis_function (tree basetype, tree type)\n \t\t\t     TYPE_ARG_TYPES (type));\n   tree fntype = build_function_type (TREE_TYPE (type), argtypes);\n \n+  /* Copy volatile qualifiers from the original function type.  */\n+  if (TYPE_QUALS (type) & TYPE_QUAL_VOLATILE)\n+    fntype = build_qualified_type (fntype, TYPE_QUAL_VOLATILE);\n+\n   if (RECORD_OR_UNION_TYPE_P (basetype))\n     TYPE_METHOD_BASETYPE (fntype) = TYPE_MAIN_VARIANT (basetype);\n   else"}, {"sha": "b2e52c0c5e7de04cc7dcea97401fab101574346b", "filename": "gcc/d/d-frontend.cc", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fd-frontend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fd-frontend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-frontend.cc?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic.h\"\n \n #include \"d-tree.h\"\n+#include \"d-frontend.h\"\n \n /* Implements back-end specific interfaces used by the frontend.  */\n \n@@ -51,7 +52,7 @@ isBuiltin (FuncDeclaration *fd)\n    Return result; NULL if cannot evaluate it.  */\n \n Expression *\n-eval_builtin (Loc loc, FuncDeclaration *fd, Expressions *arguments)\n+eval_builtin (const Loc &loc, FuncDeclaration *fd, Expressions *arguments)\n {\n   if (fd->builtin == BUILTIN::unimp)\n     return NULL;\n@@ -78,10 +79,16 @@ eval_builtin (Loc loc, FuncDeclaration *fd, Expressions *arguments)\n /* Build and return typeinfo type for TYPE.  */\n \n Type *\n-getTypeInfoType (Loc loc, Type *type, Scope *sc)\n+getTypeInfoType (const Loc &loc, Type *type, Scope *sc)\n {\n   gcc_assert (type->ty != TY::Terror);\n   check_typeinfo_type (loc, sc);\n   create_typeinfo (type, sc ? sc->_module->importedFrom : NULL);\n   return type->vtinfo->type;\n }\n+\n+void\n+toObjFile (Dsymbol *ds, bool)\n+{\n+  build_decl_tree (ds);\n+}"}, {"sha": "e3668815731326230030c0fe1358cbcaa52284db", "filename": "gcc/d/d-gimplify.cc", "status": "modified", "additions": 30, "deletions": 35, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fd-gimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fd-gimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-gimplify.cc?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -120,52 +120,47 @@ d_gimplify_addr_expr (tree *expr_p)\n static gimplify_status\n d_gimplify_call_expr (tree *expr_p, gimple_seq *pre_p)\n {\n-  if (CALL_EXPR_ARGS_ORDERED (*expr_p))\n-    {\n-      /* Strictly evaluate all arguments from left to right.  */\n-      int nargs = call_expr_nargs (*expr_p);\n-      location_t loc = EXPR_LOC_OR_LOC (*expr_p, input_location);\n+  /* Strictly evaluate all arguments from left to right.  */\n+  int nargs = call_expr_nargs (*expr_p);\n+  location_t loc = EXPR_LOC_OR_LOC (*expr_p, input_location);\n \n-      /* No need to enforce evaluation order if only one argument.  */\n-      if (nargs < 2)\n-\treturn GS_UNHANDLED;\n+  /* No need to enforce evaluation order if only one argument.  */\n+  if (nargs < 2)\n+    return GS_UNHANDLED;\n \n-      /* Or if all arguments are already free of side-effects.  */\n-      bool has_side_effects = false;\n-      for (int i = 0; i < nargs; i++)\n+  /* Or if all arguments are already free of side-effects.  */\n+  bool has_side_effects = false;\n+  for (int i = 0; i < nargs; i++)\n+    {\n+      if (TREE_SIDE_EFFECTS (CALL_EXPR_ARG (*expr_p, i)))\n \t{\n-\t  if (TREE_SIDE_EFFECTS (CALL_EXPR_ARG (*expr_p, i)))\n-\t    {\n-\t      has_side_effects = true;\n-\t      break;\n-\t    }\n+\t  has_side_effects = true;\n+\t  break;\n \t}\n+    }\n \n-      if (!has_side_effects)\n-\treturn GS_UNHANDLED;\n-\n-      /* Leave the last argument for gimplify_call_expr.  */\n-      for (int i = 0; i < nargs - 1; i++)\n-\t{\n-\t  tree new_arg = CALL_EXPR_ARG (*expr_p, i);\n+  if (!has_side_effects)\n+    return GS_UNHANDLED;\n \n-\t  /* If argument has a side-effect, gimplify_arg will handle it.  */\n-\t  if (gimplify_arg (&new_arg, pre_p, loc) == GS_ERROR)\n-\t    return GS_ERROR;\n+  /* Leave the last argument for gimplify_call_expr.  */\n+  for (int i = 0; i < nargs - 1; i++)\n+    {\n+      tree new_arg = CALL_EXPR_ARG (*expr_p, i);\n \n-\t  /* Even if an argument itself doesn't have any side-effects, it\n-\t     might be altered by another argument in the list.  */\n-\t  if (new_arg == CALL_EXPR_ARG (*expr_p, i)\n-\t      && !really_constant_p (new_arg))\n-\t    new_arg = get_formal_tmp_var (new_arg, pre_p);\n+      /* If argument has a side-effect, gimplify_arg will handle it.  */\n+      if (gimplify_arg (&new_arg, pre_p, loc) == GS_ERROR)\n+\treturn GS_ERROR;\n \n-\t  CALL_EXPR_ARG (*expr_p, i) = new_arg;\n-\t}\n+      /* Even if an argument itself doesn't have any side-effects, it\n+\t might be altered by another argument in the list.  */\n+      if (new_arg == CALL_EXPR_ARG (*expr_p, i)\n+\t  && !really_constant_p (new_arg))\n+\tnew_arg = get_formal_tmp_var (new_arg, pre_p);\n \n-      return GS_OK;\n+      CALL_EXPR_ARG (*expr_p, i) = new_arg;\n     }\n \n-  return GS_UNHANDLED;\n+  return GS_OK;\n }\n \n /* Gimplify an UNSIGNED_RSHIFT_EXPR node.  */"}, {"sha": "576eefcc01f21ae2cbbe99d4795cb87cc442aa2d", "filename": "gcc/d/d-lang.cc", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fd-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fd-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-lang.cc?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -674,6 +674,7 @@ d_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,\n     case OPT_ftransition_all:\n       global.params.vfield = value;\n       global.params.vgc = value;\n+      global.params.vin = value;\n       global.params.vmarkdown= value;\n       global.params.vtls = value;\n       break;\n@@ -682,6 +683,10 @@ d_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,\n       global.params.vfield = value;\n       break;\n \n+    case OPT_ftransition_in:\n+      global.params.vin = value;\n+      break;\n+\n     case OPT_ftransition_nogc:\n       global.params.vgc = value;\n       break;\n@@ -1176,6 +1181,14 @@ d_parse_file (void)\n     {\n       Module *m = modules[i];\n \n+      /* If this is the `__main` module, check that `D main` hasn't already\n+\t been declared in user code before running semantic on it.  */\n+      if (m == main_module && global.hasMainFunction)\n+\t{\n+\t  modules.remove (i);\n+\t  continue;\n+\t}\n+\n       if (global.params.verbose)\n \tmessage (\"semantic  %s\", m->toChars ());\n \n@@ -1357,6 +1370,9 @@ d_parse_file (void)\n   for (size_t i = 0; i < modules.length; i++)\n     {\n       Module *m = modules[i];\n+\n+      /* Skip generating code for header files, or when the module wasn't\n+\t specified by `-fonly=`.  */\n       if ((m->isHdrFile && m != main_module)\n \t  || (d_option.fonly && m != Module::rootModule))\n \tcontinue;"}, {"sha": "a5970d8a2e3034e07c3626a818d0deeaccf4b49e", "filename": "gcc/d/d-tree.h", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fd-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fd-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-tree.h?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -47,7 +47,6 @@ typedef Array <Expression *> Expressions;\n \n /* Usage of TREE_LANG_FLAG_?:\n    0: METHOD_CALL_EXPR\n-   1: CALL_EXPR_ARGS_ORDERED (in CALL_EXPR).\n \n    Usage of TYPE_LANG_FLAG_?:\n    0: TYPE_SHARED\n@@ -351,11 +350,6 @@ lang_tree_node\n #define METHOD_CALL_EXPR(NODE) \\\n   (TREE_LANG_FLAG_0 (NODE))\n \n-/* True if all arguments in a call expression should be evaluated in the\n-   order they are given (left to right).  */\n-#define CALL_EXPR_ARGS_ORDERED(NODE) \\\n-  (TREE_LANG_FLAG_1 (CALL_EXPR_CHECK (NODE)))\n-\n /* True if the type was declared 'shared'.  */\n #define TYPE_SHARED(NODE) \\\n   (TYPE_LANG_FLAG_0 (NODE))\n@@ -430,6 +424,7 @@ enum d_tree_index\n \n   DTI_ARRAY_TYPE,\n   DTI_NULL_ARRAY,\n+  DTI_BOTTOM_TYPE,\n \n   DTI_MAX\n };\n@@ -465,6 +460,8 @@ extern GTY(()) tree d_global_trees[DTI_MAX];\n #define array_type_node\t\t\td_global_trees[DTI_ARRAY_TYPE]\n /* Null initializer for dynamic arrays.  */\n #define null_array_node\t\t\td_global_trees[DTI_NULL_ARRAY]\n+/* The bottom type, referred to as `noreturn` in code.  */\n+#define noreturn_type_node\t\td_global_trees[DTI_BOTTOM_TYPE]\n \n /* A prefix for internal variables, which are not user-visible.  */\n #if !defined (NO_DOT_IN_LABEL)"}, {"sha": "a4976b68bf001b48135e2ec9868fd541f6a386b6", "filename": "gcc/d/decl.cc", "status": "modified", "additions": 63, "deletions": 92, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdecl.cc?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -116,59 +116,6 @@ gcc_attribute_p (Dsymbol *decl)\n   return false;\n }\n \n-/* Subroutine of pragma declaration visitor for marking the function in the\n-   defined in SYM as a global constructor or destructor.  If ISCTOR is true,\n-   then we're applying pragma(crt_constructor).  */\n-\n-static int\n-apply_pragma_crt (Dsymbol *sym, bool isctor)\n-{\n-  AttribDeclaration *ad = sym->isAttribDeclaration ();\n-  if (ad != NULL)\n-    {\n-      int nested = 0;\n-\n-      /* Walk all declarations of the attribute scope.  */\n-      Dsymbols *ds = ad->include (NULL);\n-      if (ds)\n-\t{\n-\t  for (size_t i = 0; i < ds->length; i++)\n-\t    nested += apply_pragma_crt ((*ds)[i], isctor);\n-\t}\n-\n-      return nested;\n-    }\n-\n-  FuncDeclaration *fd = sym->isFuncDeclaration ();\n-  if (fd != NULL)\n-    {\n-      tree decl = get_decl_tree (fd);\n-\n-      /* Apply flags to the function.  */\n-      if (isctor)\n-\t{\n-\t  DECL_STATIC_CONSTRUCTOR (decl) = 1;\n-\t  decl_init_priority_insert (decl, DEFAULT_INIT_PRIORITY);\n-\t}\n-      else\n-\t{\n-\t  DECL_STATIC_DESTRUCTOR (decl) = 1;\n-\t  decl_fini_priority_insert (decl, DEFAULT_INIT_PRIORITY);\n-\t}\n-\n-      if (fd->linkage != LINK::c)\n-\t{\n-\t  error_at (make_location_t (fd->loc),\n-\t\t    \"must be %<extern(C)%> for %<pragma(%s)%>\",\n-\t\t    isctor ? \"crt_constructor\" : \"crt_destructor\");\n-\t}\n-\n-      return 1;\n-    }\n-\n-  return 0;\n-}\n-\n /* Implements the visitor interface to lower all Declaration AST classes\n    emitted from the D Front-end to GCC trees.\n    All visit methods accept one parameter D, which holds the frontend AST\n@@ -210,18 +157,18 @@ class DeclVisitor : public Visitor\n \n   void visit (Module *d)\n   {\n-    if (d->semanticRun >= PASSobj)\n+    if (d->semanticRun >= PASS::obj)\n       return;\n \n     build_module_tree (d);\n-    d->semanticRun = PASSobj;\n+    d->semanticRun = PASS::obj;\n   }\n \n   /* Write the imported symbol to debug.  */\n \n   void visit (Import *d)\n   {\n-    if (d->semanticRun >= PASSobj)\n+    if (d->semanticRun >= PASS::obj)\n       return;\n \n     /* Implements import declarations by telling the debug back-end we are\n@@ -266,7 +213,7 @@ class DeclVisitor : public Visitor\n \t\t\t\t\t      false, false);\n       }\n \n-    d->semanticRun = PASSobj;\n+    d->semanticRun = PASS::obj;\n   }\n \n   /* Expand any local variables found in tuples.  */\n@@ -312,18 +259,6 @@ class DeclVisitor : public Visitor\n \t\t\t\"pragma(%s) not implemented\", d->ident->toChars ());\n \t  }\n       }\n-    else if (d->ident == Identifier::idPool (\"crt_constructor\")\n-\t     || d->ident == Identifier::idPool (\"crt_destructor\"))\n-      {\n-\t/* Handle pragma(crt_constructor) and pragma(crt_destructor).  Apply\n-\t   flag to indicate that the functions enclosed should run automatically\n-\t   at the beginning or end of execution.  */\n-\tbool isctor = (d->ident == Identifier::idPool (\"crt_constructor\"));\n-\n-\tif (apply_pragma_crt (d, isctor) > 1)\n-\t  error_at (make_location_t (d->loc),\n-\t\t    \"can only apply to a single declaration\");\n-      }\n \n     visit ((AttribDeclaration *) d);\n   }\n@@ -422,7 +357,7 @@ class DeclVisitor : public Visitor\n \n   void visit (StructDeclaration *d)\n   {\n-    if (d->semanticRun >= PASSobj)\n+    if (d->semanticRun >= PASS::obj)\n       return;\n \n     if (d->type->ty == TY::Terror)\n@@ -470,7 +405,7 @@ class DeclVisitor : public Visitor\n     if (d->xhash)\n       this->build_dsymbol (d->xhash);\n \n-    d->semanticRun = PASSobj;\n+    d->semanticRun = PASS::obj;\n   }\n \n   /* Finish semantic analysis of functions in vtbl for class CD.  */\n@@ -537,7 +472,7 @@ class DeclVisitor : public Visitor\n \n   void visit (ClassDeclaration *d)\n   {\n-    if (d->semanticRun >= PASSobj)\n+    if (d->semanticRun >= PASS::obj)\n       return;\n \n     if (d->type->ty == TY::Terror)\n@@ -603,15 +538,15 @@ class DeclVisitor : public Visitor\n     if (TYPE_NAME (ctype))\n       d_pushdecl (TYPE_NAME (ctype));\n \n-    d->semanticRun = PASSobj;\n+    d->semanticRun = PASS::obj;\n   }\n \n   /* Write out compiler generated TypeInfo and vtables for the given interface\n      declaration, walking over all static members.  */\n \n   void visit (InterfaceDeclaration *d)\n   {\n-    if (d->semanticRun >= PASSobj)\n+    if (d->semanticRun >= PASS::obj)\n       return;\n \n     if (d->type->ty == TY::Terror)\n@@ -646,15 +581,15 @@ class DeclVisitor : public Visitor\n     if (TYPE_NAME (ctype))\n       d_pushdecl (TYPE_NAME (ctype));\n \n-    d->semanticRun = PASSobj;\n+    d->semanticRun = PASS::obj;\n   }\n \n   /* Write out compiler generated TypeInfo and initializer for the given\n      enum declaration.  */\n \n   void visit (EnumDeclaration *d)\n   {\n-    if (d->semanticRun >= PASSobj)\n+    if (d->semanticRun >= PASS::obj)\n       return;\n \n     if (d->errors || d->type->ty == TY::Terror)\n@@ -685,15 +620,15 @@ class DeclVisitor : public Visitor\n     if (TYPE_NAME (ctype))\n       d_pushdecl (TYPE_NAME (ctype));\n \n-    d->semanticRun = PASSobj;\n+    d->semanticRun = PASS::obj;\n   }\n \n   /* Finish up a variable declaration and push it into the current scope.\n      This can either be a static, local or manifest constant.  */\n \n   void visit (VarDeclaration *d)\n   {\n-    if (d->semanticRun >= PASSobj)\n+    if (d->semanticRun >= PASS::obj)\n       return;\n \n     if (d->type->ty == TY::Terror)\n@@ -703,6 +638,21 @@ class DeclVisitor : public Visitor\n \treturn;\n       }\n \n+    /* Variables of type `noreturn` are just placeholders, and evaluate to\n+       `assert(0)` if ever read.  */\n+    if (d->type->isTypeNoreturn ())\n+      {\n+\tif (!d->isDataseg () && !d->isMember ()\n+\t    && d->_init && !d->_init->isVoidInitializer ())\n+\t  {\n+\t    Expression *e = d->type->defaultInitLiteral (d->loc);\n+\t    tree exp = build_expr (e);\n+\t    add_stmt (exp);\n+\t  }\n+\n+\treturn;\n+      }\n+\n     if (d->aliassym)\n       {\n \tthis->build_dsymbol (d->toAlias ());\n@@ -762,7 +712,7 @@ class DeclVisitor : public Visitor\n \n \t/* Frontend should have already caught this.  */\n \tgcc_assert (!integer_zerop (size)\n-\t\t    || d->type->toBasetype ()->ty == TY::Tsarray);\n+\t\t    || d->type->toBasetype ()->isTypeSArray ());\n \n \td_finish_decl (decl);\n \n@@ -797,15 +747,15 @@ class DeclVisitor : public Visitor\n \t  }\n       }\n \n-    d->semanticRun = PASSobj;\n+    d->semanticRun = PASS::obj;\n   }\n \n   /* Generate and compile a static TypeInfo declaration, but only if it is\n      needed in the current compilation.  */\n \n   void visit (TypeInfoDeclaration *d)\n   {\n-    if (d->semanticRun >= PASSobj)\n+    if (d->semanticRun >= PASS::obj)\n       return;\n \n     if (speculative_type_p (d->tinfo))\n@@ -814,7 +764,7 @@ class DeclVisitor : public Visitor\n     tree t = get_typeinfo_decl (d);\n     DECL_INITIAL (t) = layout_typeinfo (d);\n     d_finish_decl (t);\n-    d->semanticRun = PASSobj;\n+    d->semanticRun = PASS::obj;\n   }\n \n   /* Finish up a function declaration and compile it all the way\n@@ -823,7 +773,7 @@ class DeclVisitor : public Visitor\n   void visit (FuncDeclaration *d)\n   {\n     /* Already generated the function.  */\n-    if (d->semanticRun >= PASSobj)\n+    if (d->semanticRun >= PASS::obj)\n       return;\n \n     /* Don't emit any symbols from gcc.attribute module.  */\n@@ -861,7 +811,7 @@ class DeclVisitor : public Visitor\n       }\n \n     /* Ensure all semantic passes have run.  */\n-    if (d->semanticRun < PASSsemantic3)\n+    if (d->semanticRun < PASS::semantic3)\n       {\n \td->functionSemantic3 ();\n \tModule::runDeferredSemantic3 ();\n@@ -887,8 +837,8 @@ class DeclVisitor : public Visitor\n       message (\"function  %s\", d->toPrettyChars ());\n \n     /* Start generating code for this function.  */\n-    gcc_assert (d->semanticRun == PASSsemantic3done);\n-    d->semanticRun = PASSobj;\n+    gcc_assert (d->semanticRun == PASS::semantic3done);\n+    d->semanticRun = PASS::obj;\n \n     tree old_context = start_function (d);\n \n@@ -927,12 +877,19 @@ class DeclVisitor : public Visitor\n       }\n \n     /* formal function parameters.  */\n-    size_t n_parameters = d->parameters ? d->parameters->length : 0;\n+    const size_t n_parameters = d->parameters ? d->parameters->length : 0;\n \n     for (size_t i = 0; i < n_parameters; i++)\n       {\n \tVarDeclaration *param = (*d->parameters)[i];\n+\n \tparm_decl = get_symbol_decl (param);\n+\n+\t/* Type `noreturn` is a terminator, as no other arguments can possibly\n+\t   be evaluated after it.  */\n+\tif (TREE_TYPE (parm_decl) == noreturn_type_node)\n+\t  break;\n+\n \t/* Chain them in the correct order.  */\n \tparam_list = chainon (param_list, parm_decl);\n       }\n@@ -1136,9 +1093,9 @@ get_symbol_decl (Declaration *decl)\n \t\t\t       declaration_type (vd));\n \n       /* If any alignment was set on the declaration.  */\n-      if (vd->alignment != STRUCTALIGN_DEFAULT)\n+      if (!vd->alignment.isDefault ())\n \t{\n-\t  SET_DECL_ALIGN (decl->csym, vd->alignment * BITS_PER_UNIT);\n+\t  SET_DECL_ALIGN (decl->csym, vd->alignment.get () * BITS_PER_UNIT);\n \t  DECL_USER_ALIGN (decl->csym) = 1;\n \t}\n \n@@ -1321,6 +1278,20 @@ get_symbol_decl (Declaration *decl)\n       else if (fd->inlining == PINLINE::never)\n \tDECL_UNINLINABLE (decl->csym) = 1;\n \n+      /* In [pragma/crtctor], Annotates a function so it is run after the C\n+\t runtime library is initialized and before the D runtime library is\n+\t initialized.  */\n+      if (fd->isCrtCtorDtor == 1)\n+\t{\n+\t  DECL_STATIC_CONSTRUCTOR (decl->csym) = 1;\n+\t  decl_init_priority_insert (decl->csym, DEFAULT_INIT_PRIORITY);\n+\t}\n+      else if (fd->isCrtCtorDtor == 2)\n+\t{\n+\t  DECL_STATIC_DESTRUCTOR (decl->csym) = 1;\n+\t  decl_fini_priority_insert (decl->csym, DEFAULT_INIT_PRIORITY);\n+       \t}\n+\n       /* Function was declared `naked'.  */\n       if (fd->naked)\n \t{\n@@ -1342,7 +1313,7 @@ get_symbol_decl (Declaration *decl)\n \tDECL_FINAL_P (decl->csym) = 1;\n \n       /* Function is of type `noreturn' or `typeof(*null)'.  */\n-      if (fd->type->nextOf ()->ty == TY::Tnoreturn)\n+      if (fd->type->nextOf ()->isTypeNoreturn ())\n \tTREE_THIS_VOLATILE (decl->csym) = 1;\n \n       /* Check whether this function is expanded by the frontend.  */\n@@ -2246,9 +2217,9 @@ aggregate_initializer_decl (AggregateDeclaration *decl)\n   TREE_READONLY (sinit) = 1;\n \n   /* Honor struct alignment set by user.  */\n-  if (sd && sd->alignment != STRUCTALIGN_DEFAULT)\n+  if (sd && !sd->alignment.isDefault ())\n     {\n-      SET_DECL_ALIGN (sinit, sd->alignment * BITS_PER_UNIT);\n+      SET_DECL_ALIGN (sinit, sd->alignment.get () * BITS_PER_UNIT);\n       DECL_USER_ALIGN (sinit) = true;\n     }\n "}, {"sha": "d23e1fedba4821db9501d045e8d2af869ac6dc6b", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -1,4 +1,4 @@\n-b8384668f28741ad5884fc055a2bdb9c05fd95ec\n+568496d5b6ed02d577dfa86f73c7bb4edee05813\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "3cb7e127bb6c00cbd126f57f4d257a580b84b451", "filename": "gcc/d/dmd/README.md", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2FREADME.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2FREADME.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FREADME.md?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -20,6 +20,7 @@ this license for that file.\n |--------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n | [dmd/](https://github.com/dlang/dmd/tree/master/src/dmd)                 | The dmd driver and front-end                                                                                                                                                                                  |\n | [dmd/backend/](https://github.com/dlang/dmd/tree/master/src/dmd/backend) | Code generation for x86 or x86-64. Shared by the [Digital Mars C compiler](https://github.com/DigitalMars/Compiler/), but not [LDC](https://github.com/ldc-developers/ldc) or [GDC](https://gdcproject.org/). |\n+| [dmd/common/](https://github.com/dlang/dmd/tree/master/src/dmd/common)   | Code shared by the front-end and back-end                                                                                                                                                                     |\n | [dmd/root/](https://github.com/dlang/dmd/tree/master/src/dmd/root)       | Meant as a portable utility library, but [\"it wasn't very good and the only project left using it is dmd\"](https://github.com/dlang/dmd/pull/9844#issuecomment-498479516).                                    |\n \n DMD has a mostly flat directory structure, so this section aims to divide all source files into logical groups for easier navigation.\n@@ -126,6 +127,7 @@ Note that these groups have no strict meaning, the category assignments are a bi\n | [optimize.d](https://github.com/dlang/dmd/blob/master/src/dmd/optimize.d)     | Do constant folding more generally                                                         |\n | [dcast.d](https://github.com/dlang/dmd/blob/master/src/dmd/dcast.d)           | Implicit or explicit cast(), finding common types e.g. in `x ? a : b`, integral promotions |\n | [impcnvtab.d](https://github.com/dlang/dmd/blob/master/src/dmd/impcnvtab.d)   | Define an implicit conversion table for basic types                                        |\n+| [importc.d](https://github.com/dlang/dmd/blob/master/src/dmd/importc.d)       | Helpers specific to ImportC                                                                |\n | [sideeffect.d](https://github.com/dlang/dmd/blob/master/src/dmd/sideeffect.d) | Extract side-effects of expressions for certain lowerings.                                 |\n \n **Compile Time Function Execution (CTFE)**\n@@ -243,14 +245,14 @@ Note that these groups have no strict meaning, the category assignments are a bi\n \n Note: many other utilities are in [dmd/root](https://github.com/dlang/dmd/tree/master/src/dmd/root).\n \n-| File                                                                        | Purpose                                           |\n-|-----------------------------------------------------------------------------|---------------------------------------------------|\n-| [env.d](https://github.com/dlang/dmd/blob/master/src/dmd/env.d)             | Modify environment variables                      |\n-| [console.d](https://github.com/dlang/dmd/blob/master/src/dmd/console.d)     | Print error messages in color                     |\n-| [utf.d](https://github.com/dlang/dmd/blob/master/src/dmd/utf.d)             | Encoding/decoding Unicode text                    |\n-| [filecache.d](https://github.com/dlang/dmd/blob/master/src/dmd/filecache.d) | Keep file contents in memory                      |\n-| [utils.d](https://github.com/dlang/dmd/blob/master/src/dmd/utils.d)         | Utility functions related to files and file paths |\n-| [complex.d](https://github.com/dlang/dmd/blob/master/src/dmd/complex.d)     | A complex number type                             |\n+| File                                                                              | Purpose                                           |\n+|-----------------------------------------------------------------------------------|---------------------------------------------------|\n+| [env.d](https://github.com/dlang/dmd/blob/master/src/dmd/env.d)                   | Modify environment variables                      |\n+| [console.d](https://github.com/dlang/dmd/blob/master/src/dmd/console.d)           | Print error messages in color                     |\n+| [utf.d](https://github.com/dlang/dmd/blob/master/src/dmd/utf.d)                   | Encoding/decoding Unicode text                    |\n+| [file_manager.d](https://github.com/dlang/dmd/blob/master/src/dmd/file_manager.d) | Keep file contents in memory                      |\n+| [utils.d](https://github.com/dlang/dmd/blob/master/src/dmd/utils.d)               | Utility functions related to files and file paths |\n+| [complex.d](https://github.com/dlang/dmd/blob/master/src/dmd/complex.d)           | A complex number type                             |\n \n | File                                                                            | Purpose                                                       |\n |---------------------------------------------------------------------------------|---------------------------------------------------------------|"}, {"sha": "fa5940ed249d59ddb7b55be9f7d4a381d5251a9c", "filename": "gcc/d/dmd/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FVERSION?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -1 +1 @@\n-v2.097.2\n+v2.098.0"}, {"sha": "1fe8e809aa552d36d12eca6751d7919574ddaaf2", "filename": "gcc/d/dmd/aggregate.d", "status": "modified", "additions": 47, "deletions": 34, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Faggregate.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Faggregate.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faggregate.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -21,6 +21,7 @@ import dmd.aliasthis;\n import dmd.apply;\n import dmd.arraytypes;\n import dmd.astenums;\n+import dmd.attrib;\n import dmd.declaration;\n import dmd.dscope;\n import dmd.dstruct;\n@@ -115,11 +116,12 @@ extern (C++) abstract class AggregateDeclaration : ScopeDsymbol\n \n     AliasThis aliasthis;    /// forward unresolved lookups to aliasthis\n \n-    DtorDeclarations dtors;     /// Array of destructors\n-    DtorDeclaration dtor;       /// aggregate destructor calling dtors and member constructors\n-    DtorDeclaration primaryDtor;/// non-deleting C++ destructor, same as dtor for D\n+    DtorDeclarations userDtors; /// user-defined destructors (`~this()`) - mixins can yield multiple ones\n+    DtorDeclaration aggrDtor;   /// aggregate destructor calling userDtors and fieldDtor (and base class aggregate dtor for C++ classes)\n+    DtorDeclaration dtor;       /// the aggregate destructor exposed as `__xdtor` alias\n+                                /// (same as aggrDtor, except for C++ classes with virtual dtor on Windows)\n     DtorDeclaration tidtor;     /// aggregate destructor used in TypeInfo (must have extern(D) ABI)\n-    FuncDeclaration fieldDtor;  /// aggregate destructor for just the fields\n+    DtorDeclaration fieldDtor;  /// function destructing (non-inherited) fields\n \n     Expression getRTInfo;   /// pointer to GC info generated by object.RTInfo(this)\n \n@@ -177,7 +179,7 @@ extern (C++) abstract class AggregateDeclaration : ScopeDsymbol\n      * Returns:\n      *      false if failed to determine the size.\n      */\n-    final bool determineSize(Loc loc)\n+    final bool determineSize(const ref Loc loc)\n     {\n         //printf(\"AggregateDeclaration::determineSize() %s, sizeok = %d\\n\", toChars(), sizeok);\n \n@@ -331,7 +333,7 @@ extern (C++) abstract class AggregateDeclaration : ScopeDsymbol\n      *      false if any errors occur.\n      *      Otherwise, returns true and the missing arguments will be pushed in elements[].\n      */\n-    final bool fill(Loc loc, Expressions* elements, bool ctorinit)\n+    final bool fill(const ref Loc loc, Expressions* elements, bool ctorinit)\n     {\n         //printf(\"AggregateDeclaration::fill() %s\\n\", toChars());\n         assert(sizeok == Sizeok.done);\n@@ -482,61 +484,72 @@ extern (C++) abstract class AggregateDeclaration : ScopeDsymbol\n      * Align sizes of 0, as we may not know array sizes yet.\n      * Params:\n      *   alignment = struct alignment that is in effect\n-     *   size = alignment requirement of field\n+     *   memalignsize = natural alignment of field\n      *   poffset = pointer to offset to be aligned\n      */\n-    extern (D) static void alignmember(structalign_t alignment, uint size, uint* poffset) pure nothrow @safe\n+    extern (D) static void alignmember(structalign_t alignment, uint memalignsize, uint* poffset) pure nothrow @safe\n     {\n-        //printf(\"alignment = %d, size = %d, offset = %d\\n\",alignment,size,offset);\n-        switch (alignment)\n-        {\n-        case cast(structalign_t)1:\n-            // No alignment\n-            break;\n+        //debug printf(\"alignment = %u %d, size = %u, offset = %u\\n\", alignment.get(), alignment.isPack(), memalignsize, *poffset);\n+        uint alignvalue;\n \n-        case cast(structalign_t)STRUCTALIGN_DEFAULT:\n+        if (alignment.isDefault())\n+        {\n             // Alignment in Target::fieldalignsize must match what the\n             // corresponding C compiler's default alignment behavior is.\n-            assert(size > 0 && !(size & (size - 1)));\n-            *poffset = (*poffset + size - 1) & ~(size - 1);\n-            break;\n-\n-        default:\n+            alignvalue = memalignsize;\n+        }\n+        else if (alignment.isPack())    // #pragma pack semantics\n+        {\n+            alignvalue = alignment.get();\n+            if (memalignsize < alignvalue)\n+                alignvalue = memalignsize;      // align to min(memalignsize, alignment)\n+        }\n+        else if (alignment.get() > 1)\n+        {\n             // Align on alignment boundary, which must be a positive power of 2\n-            assert(alignment > 0 && !(alignment & (alignment - 1)));\n-            *poffset = (*poffset + alignment - 1) & ~(alignment - 1);\n-            break;\n+            alignvalue = alignment.get();\n         }\n+        else\n+            return;\n+\n+        assert(alignvalue > 0 && !(alignvalue & (alignvalue - 1)));\n+        *poffset = (*poffset + alignvalue - 1) & ~(alignvalue - 1);\n     }\n \n     /****************************************\n-     * Place a member (mem) into an aggregate (agg), which can be a struct, union or class\n+     * Place a field (mem) into an aggregate (agg), which can be a struct, union or class\n+     * Params:\n+     *    nextoffset    = location just past the end of the previous field in the aggregate.\n+     *                    Updated to be just past the end of this field to be placed, i.e. the future nextoffset\n+     *    memsize       = size of field\n+     *    memalignsize  = natural alignment of field\n+     *    alignment     = alignment in effect for this field\n+     *    paggsize      = size of aggregate (updated)\n+     *    paggalignsize = alignment of aggregate (updated)\n+     *    isunion       = the aggregate is a union\n      * Returns:\n-     *      offset to place field at\n+     *    aligned offset to place field at\n      *\n-     * nextoffset:    next location in aggregate\n-     * memsize:       size of member\n-     * memalignsize:  natural alignment of member\n-     * alignment:     alignment in effect for this member\n-     * paggsize:      size of aggregate (updated)\n-     * paggalignsize: alignment of aggregate (updated)\n-     * isunion:       the aggregate is a union\n      */\n     extern (D) static uint placeField(uint* nextoffset, uint memsize, uint memalignsize,\n         structalign_t alignment, uint* paggsize, uint* paggalignsize, bool isunion)\n     {\n         uint ofs = *nextoffset;\n \n         const uint actualAlignment =\n-            alignment == STRUCTALIGN_DEFAULT ? memalignsize : alignment;\n+            alignment.isDefault() || alignment.isPack() && memalignsize < alignment.get()\n+                        ? memalignsize : alignment.get();\n \n         // Ensure no overflow\n         bool overflow;\n         const sz = addu(memsize, actualAlignment, overflow);\n         addu(ofs, sz, overflow);\n         if (overflow) assert(0);\n \n-        alignmember(alignment, memalignsize, &ofs);\n+        // Skip no-op for noreturn without custom aligment\n+        if (memsize != 0 || !alignment.isDefault())\n+            alignmember(alignment, memalignsize, &ofs);\n+\n         uint memoffset = ofs;\n         ofs += memsize;\n         if (ofs > *paggsize)"}, {"sha": "48e5f4a806234fe19ba7ced1fd541c0f6a565c09", "filename": "gcc/d/dmd/aggregate.h", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Faggregate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Faggregate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faggregate.h?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -105,11 +105,12 @@ class AggregateDeclaration : public ScopeDsymbol\n \n     AliasThis *aliasthis;       // forward unresolved lookups to aliasthis\n \n-    DtorDeclarations dtors;     // Array of destructors\n-    DtorDeclaration *dtor;      // aggregate destructor\n-    DtorDeclaration *primaryDtor; // non-deleting C++ destructor, same as dtor for D\n+    DtorDeclarations userDtors; // user-defined destructors (`~this()`) - mixins can yield multiple ones\n+    DtorDeclaration *aggrDtor;  // aggregate destructor calling userDtors and fieldDtor (and base class aggregate dtor for C++ classes)\n+    DtorDeclaration *dtor;      // the aggregate destructor exposed as `__xdtor` alias\n+                                // (same as aggrDtor, except for C++ classes with virtual dtor on Windows)\n     DtorDeclaration *tidtor;    // aggregate destructor used in TypeInfo (must have extern(D) ABI)\n-    FuncDeclaration *fieldDtor;   // aggregate destructor for just the fields\n+    DtorDeclaration *fieldDtor; // function destructing (non-inherited) fields\n \n     Expression *getRTInfo;      // pointer to GC info generated by object.RTInfo(this)\n \n@@ -121,10 +122,10 @@ class AggregateDeclaration : public ScopeDsymbol\n     virtual Scope *newScope(Scope *sc);\n     void setScope(Scope *sc);\n     size_t nonHiddenFields();\n-    bool determineSize(Loc loc);\n+    bool determineSize(const Loc &loc);\n     virtual void finalizeSize() = 0;\n     d_uns64 size(const Loc &loc);\n-    bool fill(Loc loc, Expressions *elements, bool ctorinit);\n+    bool fill(const Loc &loc, Expressions *elements, bool ctorinit);\n     Type *getType();\n     bool isDeprecated() const;         // is aggregate deprecated?\n     void setDeprecated();\n@@ -184,7 +185,7 @@ class StructDeclaration : public AggregateDeclaration\n     // ABI-specific type(s) if the struct can be passed in registers\n     TypeTuple *argTypes;\n \n-    static StructDeclaration *create(Loc loc, Identifier *id, bool inObject);\n+    static StructDeclaration *create(const Loc &loc, Identifier *id, bool inObject);\n     StructDeclaration *syntaxCopy(Dsymbol *s);\n     Dsymbol *search(const Loc &loc, Identifier *ident, int flags = SearchLocalsOnly);\n     const char *kind() const;\n@@ -277,7 +278,7 @@ class ClassDeclaration : public AggregateDeclaration\n     ObjcClassDeclaration objc;          // Data for a class declaration that is needed for the Objective-C integration\n     Symbol *cpp_type_info_ptr_sym;      // cached instance of class Id.cpp_type_info_ptr\n \n-    static ClassDeclaration *create(Loc loc, Identifier *id, BaseClasses *baseclasses, Dsymbols *members, bool inObject);\n+    static ClassDeclaration *create(const Loc &loc, Identifier *id, BaseClasses *baseclasses, Dsymbols *members, bool inObject);\n     const char *toPrettyChars(bool QualifyTypes = false);\n     ClassDeclaration *syntaxCopy(Dsymbol *s);\n     Scope *newScope(Scope *sc);"}, {"sha": "e048cdc2e1b4a2896547585b993185b36d47054c", "filename": "gcc/d/dmd/aliasthis.d", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Faliasthis.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Faliasthis.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faliasthis.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -72,17 +72,32 @@ extern (C++) final class AliasThis : Dsymbol\n     }\n }\n \n-Expression resolveAliasThis(Scope* sc, Expression e, bool gag = false)\n+/*************************************\n+ * Find the `alias this` symbol of e's type.\n+ * Params:\n+ *      sc = context\n+ *      e = expression forming the `this`\n+ *      gag = if true do not print errors, return null instead\n+ *      findOnly = don't do further processing like resolving properties,\n+ *                 i.e. just return plain dotExp() result.\n+ * Returns:\n+ *      Expression that is `e.aliasthis`\n+ */\n+Expression resolveAliasThis(Scope* sc, Expression e, bool gag = false, bool findOnly = false)\n {\n+    import dmd.typesem : dotExp;\n     for (AggregateDeclaration ad = isAggregate(e.type); ad;)\n     {\n         if (ad.aliasthis)\n         {\n-            uint olderrors = gag ? global.startGagging() : 0;\n             Loc loc = e.loc;\n             Type tthis = (e.op == TOK.type ? e.type : null);\n-            e = new DotIdExp(loc, e, ad.aliasthis.ident);\n-            e = e.expressionSemantic(sc);\n+            const flags = DotExpFlag.noAliasThis | (gag ? DotExpFlag.gag : 0);\n+            uint olderrors = gag ? global.startGagging() : 0;\n+            e = dotExp(e.type, sc, e, ad.aliasthis.ident, flags);\n+            if (!e || findOnly)\n+                return gag && global.endGagging(olderrors) ? null : e;\n+\n             if (tthis && ad.aliasthis.sym.needThis())\n             {\n                 if (e.op == TOK.variable)"}, {"sha": "e2b33194f060417a891e3fbe222f57382ff91208", "filename": "gcc/d/dmd/arrayop.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Farrayop.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Farrayop.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Farrayop.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -26,7 +26,7 @@ import dmd.globals;\n import dmd.id;\n import dmd.identifier;\n import dmd.mtype;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.statement;\n import dmd.tokens;\n import dmd.visitor;"}, {"sha": "0bf40ef9a728d4cce3518269c3f58c49930a5ebc", "filename": "gcc/d/dmd/attrib.d", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fattrib.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fattrib.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fattrib.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -42,7 +42,7 @@ import dmd.id;\n import dmd.identifier;\n import dmd.mtype;\n import dmd.objc; // for objc.addSymbols\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.target; // for target.systemLinkage\n import dmd.tokens;\n import dmd.visitor;\n@@ -696,21 +696,17 @@ extern (C++) final class AlignDeclaration : AttribDeclaration\n {\n     Expressions* exps;                              /// Expression(s) yielding the desired alignment,\n                                                     /// the largest value wins\n-    enum structalign_t UNKNOWN = 0;                 /// alignment not yet computed\n-    static assert(STRUCTALIGN_DEFAULT != UNKNOWN);\n-\n-    /// the actual alignment, `UNKNOWN` until it's either set to the value of `ealign`\n-    /// or `STRUCTALIGN_DEFAULT` if `ealign` is null ( / an error ocurred)\n-    structalign_t salign = UNKNOWN;\n+    /// the actual alignment is Unknown until it's either set to the value of `ealign`\n+    /// or the default if `ealign` is null ( / an error ocurred)\n+    structalign_t salign;\n \n \n     extern (D) this(const ref Loc loc, Expression exp, Dsymbols* decl)\n     {\n         super(loc, null, decl);\n         if (exp)\n         {\n-            if (!exps)\n-                exps = new Expressions();\n+            exps = new Expressions();\n             exps.push(exp);\n         }\n     }\n@@ -721,6 +717,12 @@ extern (C++) final class AlignDeclaration : AttribDeclaration\n         this.exps = exps;\n     }\n \n+    extern (D) this(const ref Loc loc, structalign_t salign, Dsymbols* decl)\n+    {\n+        super(loc, null, decl);\n+        this.salign = salign;\n+    }\n+\n     override AlignDeclaration syntaxCopy(Dsymbol s)\n     {\n         assert(!s);\n@@ -1196,7 +1198,7 @@ extern (C++) final class StaticForeachDeclaration : AttribDeclaration\n \n         // expand static foreach\n         import dmd.statementsem: makeTupleForeach;\n-        Dsymbols* d = makeTupleForeach!(true,true)(_scope, sfe.aggrfe, decl, sfe.needExpansion);\n+        Dsymbols* d = makeTupleForeach!(true,true)(_scope, sfe.aggrfe, decl, sfe.needExpansion).decl;\n         if (d) // process generated declarations\n         {\n             // Add members lazily."}, {"sha": "0ecd6351f7d6181aed48000c9d226c5ac2461024", "filename": "gcc/d/dmd/blockexit.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fblockexit.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fblockexit.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fblockexit.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -108,7 +108,7 @@ int blockExit(Statement s, FuncDeclaration func, bool mustNotThrow)\n                         return;\n                     }\n                 }\n-                if (s.exp.type.toBasetype().isTypeNoreturn())\n+                if (s.exp.type && s.exp.type.toBasetype().isTypeNoreturn())\n                     result = BE.halt;\n                 if (canThrow(s.exp, func, mustNotThrow))\n                     result |= BE.throw_;\n@@ -146,7 +146,7 @@ int blockExit(Statement s, FuncDeclaration func, bool mustNotThrow)\n                             else if (sd && (!sd.statement.hasCode() || sd.statement.isCaseStatement() || sd.statement.isErrorStatement()))\n                             {\n                             }\n-                            else\n+                            else if (!func.getModule().isCFile)\n                             {\n                                 const(char)* gototype = s.isCaseStatement() ? \"case\" : \"default\";\n                                 s.deprecation(\"switch case fallthrough - use 'goto %s;' if intended\", gototype);"}, {"sha": "c4f84b129686ed0e2b81f24d9cc699beeba6d099", "filename": "gcc/d/dmd/builtin.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fbuiltin.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fbuiltin.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fbuiltin.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -30,4 +30,4 @@ public extern (C++) BUILTIN isBuiltin(FuncDeclaration fd);\n  * Evaluate builtin function.\n  * Return result; NULL if cannot evaluate it.\n  */\n-public extern (C++) Expression eval_builtin(Loc loc, FuncDeclaration fd, Expressions* arguments);\n+public extern (C++) Expression eval_builtin(const ref Loc loc, FuncDeclaration fd, Expressions* arguments);"}, {"sha": "b168b4f7e0a3be86273be255428b6d81ad5f4f00", "filename": "gcc/d/dmd/chkformat.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fchkformat.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fchkformat.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fchkformat.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -690,8 +690,8 @@ Format parsePrintfFormatSpecifier(scope const char[] format, ref size_t idx,\n                 return error();\n             while ('0' <= format[i] && format[i] <= '9')\n             {\n-               ++i;\n-               if (i == length)\n+                ++i;\n+                if (i == length)\n                     return error();\n             }\n         }\n@@ -720,8 +720,8 @@ Format parsePrintfFormatSpecifier(scope const char[] format, ref size_t idx,\n                 return error();\n             while ('0' <= format[i] && format[i] <= '9')\n             {\n-               ++i;\n-               if (i == length)\n+                ++i;\n+                if (i == length)\n                     return error();\n             }\n         }"}, {"sha": "da66812b954843c622d4053f9879015a490101bb", "filename": "gcc/d/dmd/clone.d", "status": "modified", "additions": 70, "deletions": 69, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fclone.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fclone.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fclone.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -794,6 +794,19 @@ FuncDeclaration buildXtoHash(StructDeclaration sd, Scope* sc)\n     if (!needToHash(sd))\n         return null;\n \n+    /* The trouble is that the following code relies on .tupleof, but .tupleof\n+     * is not allowed for C files. If we allow it for C files, then that turns on\n+     * the other D properties, too, such as .dup which will then conflict with allowed\n+     * field names.\n+     * One way to fix it is to replace the following foreach and .tupleof with C\n+     * statements and expressions.\n+     * But, it's debatable whether C structs should even need toHash().\n+     * Note that it would only be necessary if it has floating point fields.\n+     * For now, we'll just not generate a toHash() for C files.\n+     */\n+    if (sc.flags & SCOPE.Cfile)\n+        return null;\n+\n     //printf(\"StructDeclaration::buildXtoHash() %s\\n\", sd.toPrettyChars());\n     Loc declLoc; // loc is unnecessary so __xtoHash is never called directly\n     Loc loc; // internal code should have no loc to prevent coverage\n@@ -831,31 +844,31 @@ FuncDeclaration buildXtoHash(StructDeclaration sd, Scope* sc)\n }\n \n /*****************************************\n- * Create inclusive destructor for struct/class by aggregating\n- * all the destructors in dtors[] with the destructors for\n+ * Create aggregate destructor for struct/class by aggregating\n+ * all the destructors in userDtors[] with the destructors for\n  * all the members.\n+ * Sets ad's fieldDtor, aggrDtor, dtor and tidtor fields.\n  * Params:\n  *      ad = struct or class to build destructor for\n  *      sc = context\n- * Returns:\n- *      generated function, null if none needed\n  * Note:\n  * Close similarity with StructDeclaration::buildPostBlit(),\n  * and the ordering changes (runs backward instead of forwards).\n  */\n-DtorDeclaration buildDtor(AggregateDeclaration ad, Scope* sc)\n+void buildDtors(AggregateDeclaration ad, Scope* sc)\n {\n     //printf(\"AggregateDeclaration::buildDtor() %s\\n\", ad.toChars());\n     if (ad.isUnionDeclaration())\n-        return null;                    // unions don't have destructors\n+        return;                    // unions don't have destructors\n \n     StorageClass stc = STC.safe | STC.nothrow_ | STC.pure_ | STC.nogc;\n-    Loc declLoc = ad.dtors.dim ? ad.dtors[0].loc : ad.loc;\n+    Loc declLoc = ad.userDtors.dim ? ad.userDtors[0].loc : ad.loc;\n     Loc loc; // internal code should have no loc to prevent coverage\n     FuncDeclaration xdtor_fwd = null;\n \n-    // if the dtor is an extern(C++) prototype, then we expect it performs a full-destruction; we don't need to build a full-dtor\n-    const bool dtorIsCppPrototype = ad.dtors.dim == 1 && ad.dtors[0].linkage == LINK.cpp && !ad.dtors[0].fbody;\n+    // Build the field destructor (`ad.fieldDtor`), if needed.\n+    // If the user dtor is an extern(C++) prototype, then we expect it performs a full-destruction and skip building.\n+    const bool dtorIsCppPrototype = ad.userDtors.dim && ad.userDtors[0].linkage == LINK.cpp && !ad.userDtors[0].fbody;\n     if (!dtorIsCppPrototype)\n     {\n         Expression e = null;\n@@ -936,66 +949,52 @@ DtorDeclaration buildDtor(AggregateDeclaration ad, Scope* sc)\n             e = Expression.combine(ex, e); // combine in reverse order\n         }\n \n-        /* extern(C++) destructors call into super to destruct the full hierarchy\n-        */\n-        ClassDeclaration cldec = ad.isClassDeclaration();\n-        if (cldec && cldec.classKind == ClassKind.cpp && cldec.baseClass && cldec.baseClass.primaryDtor)\n-        {\n-            // WAIT BUT: do I need to run `cldec.baseClass.dtor` semantic? would it have been run before?\n-            cldec.baseClass.dtor.functionSemantic();\n-\n-            stc = mergeFuncAttrs(stc, cldec.baseClass.primaryDtor);\n-            if (!(stc & STC.disable))\n-            {\n-                // super.__xdtor()\n-\n-                Expression ex = new SuperExp(loc);\n-\n-                // This is a hack so we can call destructors on const/immutable objects.\n-                // Do it as a type 'paint'.\n-                ex = new CastExp(loc, ex, cldec.baseClass.type.mutableOf());\n-                if (stc & STC.safe)\n-                    stc = (stc & ~STC.safe) | STC.trusted;\n-\n-                ex = new DotVarExp(loc, ex, cldec.baseClass.primaryDtor, false);\n-                ex = new CallExp(loc, ex);\n-\n-                e = Expression.combine(e, ex); // super dtor last\n-            }\n-        }\n-\n-        /* Build our own \"destructor\" which executes e\n-         */\n         if (e || (stc & STC.disable))\n         {\n             //printf(\"Building __fieldDtor(), %s\\n\", e.toChars());\n             auto dd = new DtorDeclaration(declLoc, Loc.initial, stc, Id.__fieldDtor);\n             dd.generated = true;\n             dd.storage_class |= STC.inference;\n             dd.fbody = new ExpStatement(loc, e);\n-            ad.dtors.shift(dd);\n             ad.members.push(dd);\n             dd.dsymbolSemantic(sc);\n             ad.fieldDtor = dd;\n         }\n     }\n \n-    DtorDeclaration xdtor = null;\n-    switch (ad.dtors.dim)\n+    // Generate list of dtors to call in that order\n+    DtorDeclarations dtors;\n+    foreach_reverse (userDtor; ad.userDtors[])\n+        dtors.push(userDtor);\n+    if (ad.fieldDtor)\n+        dtors.push(ad.fieldDtor);\n+    if (!dtorIsCppPrototype)\n+    {\n+        // extern(C++) destructors call into super to destruct the full hierarchy\n+        ClassDeclaration cldec = ad.isClassDeclaration();\n+        if (cldec && cldec.classKind == ClassKind.cpp && cldec.baseClass && cldec.baseClass.aggrDtor)\n+            dtors.push(cldec.baseClass.aggrDtor);\n+    }\n+\n+    // Set/build `ad.aggrDtor`\n+    switch (dtors.dim)\n     {\n     case 0:\n         break;\n \n     case 1:\n-        xdtor = ad.dtors[0];\n+        // Use the single existing dtor directly as aggregate dtor.\n+        // Note that this might be `cldec.baseClass.aggrDtor`.\n+        ad.aggrDtor = dtors[0];\n         break;\n \n     default:\n+        // Build the aggregate destructor, calling all dtors in order.\n         assert(!dtorIsCppPrototype);\n         Expression e = null;\n         e = null;\n         stc = STC.safe | STC.nothrow_ | STC.pure_ | STC.nogc;\n-        foreach (FuncDeclaration fd; ad.dtors)\n+        foreach (FuncDeclaration fd; dtors)\n         {\n             stc = mergeFuncAttrs(stc, fd);\n             if (stc & STC.disable)\n@@ -1005,28 +1004,30 @@ DtorDeclaration buildDtor(AggregateDeclaration ad, Scope* sc)\n             }\n             Expression ex = new ThisExp(loc);\n             ex = new DotVarExp(loc, ex, fd, false);\n-            ex = new CallExp(loc, ex);\n-            e = Expression.combine(ex, e);\n+            CallExp ce = new CallExp(loc, ex);\n+            ce.directcall = true;\n+            e = Expression.combine(e, ce);\n         }\n         auto dd = new DtorDeclaration(declLoc, Loc.initial, stc, Id.__aggrDtor);\n         dd.generated = true;\n         dd.storage_class |= STC.inference;\n         dd.fbody = new ExpStatement(loc, e);\n         ad.members.push(dd);\n         dd.dsymbolSemantic(sc);\n-        xdtor = dd;\n+        ad.aggrDtor = dd;\n         break;\n     }\n \n-    ad.primaryDtor = xdtor;\n-\n-    if (xdtor && xdtor.linkage == LINK.cpp && !target.cpp.twoDtorInVtable)\n-        xdtor = buildWindowsCppDtor(ad, xdtor, sc);\n+    // Set/build `ad.dtor`.\n+    // On Windows, the dtor in the vtable is a shim with different signature.\n+    ad.dtor = (ad.aggrDtor && ad.aggrDtor.linkage == LINK.cpp && !target.cpp.twoDtorInVtable)\n+        ? buildWindowsCppDtor(ad, ad.aggrDtor, sc)\n+        : ad.aggrDtor;\n \n-    // Add an __xdtor alias to make the inclusive dtor accessible\n-    if (xdtor)\n+    // Add an __xdtor alias to make `ad.dtor` accessible\n+    if (ad.dtor)\n     {\n-        auto _alias = new AliasDeclaration(Loc.initial, Id.__xdtor, xdtor);\n+        auto _alias = new AliasDeclaration(Loc.initial, Id.__xdtor, ad.dtor);\n         _alias.dsymbolSemantic(sc);\n         ad.members.push(_alias);\n         if (xdtor_fwd)\n@@ -1035,7 +1036,8 @@ DtorDeclaration buildDtor(AggregateDeclaration ad, Scope* sc)\n             _alias.addMember(sc, ad); // add to symbol table\n     }\n \n-    return xdtor;\n+    // Set/build `ad.tidtor`\n+    ad.tidtor = buildExternDDtor(ad, sc);\n }\n \n /**\n@@ -1069,17 +1071,16 @@ private DtorDeclaration buildWindowsCppDtor(AggregateDeclaration ad, DtorDeclara\n     auto ftype = new TypeFunction(ParameterList(params), Type.tvoidptr, LINK.cpp, dtor.storage_class);\n     auto func = new DtorDeclaration(dtor.loc, dtor.loc, dtor.storage_class, Id.cppdtor);\n     func.type = ftype;\n-    if (dtor.fbody)\n-    {\n-        const loc = dtor.loc;\n-        auto stmts = new Statements;\n-        auto call = new CallExp(loc, dtor, null);\n-        call.directcall = true;\n-        stmts.push(new ExpStatement(loc, call));\n-        stmts.push(new ReturnStatement(loc, new CastExp(loc, new ThisExp(loc), Type.tvoidptr)));\n-        func.fbody = new CompoundStatement(loc, stmts);\n-        func.generated = true;\n-    }\n+\n+    // Always generate the function with body, because it is not exported from DLLs.\n+    const loc = dtor.loc;\n+    auto stmts = new Statements;\n+    auto call = new CallExp(loc, dtor, null);\n+    call.directcall = true;\n+    stmts.push(new ExpStatement(loc, call));\n+    stmts.push(new ReturnStatement(loc, new CastExp(loc, new ThisExp(loc), Type.tvoidptr)));\n+    func.fbody = new CompoundStatement(loc, stmts);\n+    func.generated = true;\n \n     auto sc2 = sc.push();\n     sc2.stc &= ~STC.static_; // not a static destructor\n@@ -1094,7 +1095,7 @@ private DtorDeclaration buildWindowsCppDtor(AggregateDeclaration ad, DtorDeclara\n }\n \n /**\n- * build a shim function around the compound dtor that translates\n+ * build a shim function around the aggregate dtor that translates\n  *  a C++ destructor to a destructor with extern(D) calling convention\n  *\n  * Params:\n@@ -1104,9 +1105,9 @@ private DtorDeclaration buildWindowsCppDtor(AggregateDeclaration ad, DtorDeclara\n  * Returns:\n  *  the shim destructor, semantically analyzed and added to the class as a member\n  */\n-DtorDeclaration buildExternDDtor(AggregateDeclaration ad, Scope* sc)\n+private DtorDeclaration buildExternDDtor(AggregateDeclaration ad, Scope* sc)\n {\n-    auto dtor = ad.primaryDtor;\n+    auto dtor = ad.aggrDtor;\n     if (!dtor)\n         return null;\n "}, {"sha": "a9b65c3dd8d7cf4f19a5a2028b588332060c09bb", "filename": "gcc/d/dmd/common/README.md", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fcommon%2FREADME.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fcommon%2FREADME.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcommon%2FREADME.md?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,7 @@\n+# Table of contents\n+\n+| File                                                                               | Purpose                                                         |\n+|------------------------------------------------------------------------------------|-----------------------------------------------------------------|\n+| [file.d](https://github.com/dlang/dmd/blob/master/src/dmd/common/file.d)           | Functions and objects dedicated to file I/O and management      |\n+| [outbuffer.d](https://github.com/dlang/dmd/blob/master/src/dmd/common/outbuffer.d) | An expandable buffer in which you can write text or binary data |\n+| [string.d](https://github.com/dlang/dmd/blob/master/src/dmd/common/string.d)       | Common string functions including filename manipulation         |"}, {"sha": "b8cde3757360a5f68d395f7fe004f398037d58ed", "filename": "gcc/d/dmd/common/file.d", "status": "added", "additions": 576, "deletions": 0, "changes": 576, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fcommon%2Ffile.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fcommon%2Ffile.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcommon%2Ffile.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,576 @@\n+/**\n+ * File utilities.\n+ *\n+ * Functions and objects dedicated to file I/O and management. TODO: Move here artifacts\n+ * from places such as root/ so both the frontend and the backend have access to them.\n+ *\n+ * Copyright: Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n+ * Authors:   Walter Bright, http://www.digitalmars.com\n+ * License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+ * Source:    $(LINK2 https://github.com/dlang/dmd/blob/master/src/dmd/common/file.d, common/_file.d)\n+ * Documentation: https://dlang.org/phobos/dmd_common_file.html\n+ * Coverage:    https://codecov.io/gh/dlang/dmd/src/master/src/dmd/common/file.d\n+ */\n+\n+module dmd.common.file;\n+\n+import core.stdc.errno : errno;\n+import core.stdc.stdio : fprintf, remove, rename, stderr;\n+import core.stdc.stdlib : exit;\n+import core.stdc.string : strerror;\n+import core.sys.windows.winbase;\n+import core.sys.windows.winnt;\n+import core.sys.posix.fcntl;\n+import core.sys.posix.unistd;\n+\n+import dmd.common.string;\n+\n+/**\n+Encapsulated management of a memory-mapped file.\n+\n+Params:\n+Datum = the mapped data type: Use a POD of size 1 for read/write mapping\n+and a `const` version thereof for read-only mapping. Other primitive types\n+should work, but have not been yet tested.\n+*/\n+struct FileMapping(Datum)\n+{\n+    static assert(__traits(isPOD, Datum) && Datum.sizeof == 1,\n+        \"Not tested with other data types yet. Add new types with care.\");\n+\n+    version(Posix) enum invalidHandle = -1;\n+    else version(Windows) enum invalidHandle = INVALID_HANDLE_VALUE;\n+\n+    // state {\n+    /// Handle of underlying file\n+    private auto handle = invalidHandle;\n+    /// File mapping object needed on Windows\n+    version(Windows) private HANDLE fileMappingObject = invalidHandle;\n+    /// Memory-mapped array\n+    private Datum[] data;\n+    /// Name of underlying file, zero-terminated\n+    private const(char)* name;\n+    // state }\n+\n+    /**\n+    Open `filename` and map it in memory. If `Datum` is `const`, opens for\n+    read-only and maps the content in memory; no error is issued if the file\n+    does not exist. This makes it easy to treat a non-existing file as empty.\n+\n+    If `Datum` is mutable, opens for read/write (creates file if it does not\n+    exist) and fails fatally on any error.\n+\n+    Due to quirks in `mmap`, if the file is empty, `handle` is valid but `data`\n+    is `null`. This state is valid and accounted for.\n+\n+    Params:\n+    filename = the name of the file to be mapped in memory\n+    */\n+    this(const char* filename)\n+    {\n+        version (Posix)\n+        {\n+            import core.sys.posix.sys.mman;\n+            import core.sys.posix.fcntl : open, O_CREAT, O_RDONLY, O_RDWR, S_IRGRP, S_IROTH, S_IRUSR, S_IWUSR;\n+\n+            handle = open(filename, is(Datum == const) ? O_RDONLY : (O_CREAT | O_RDWR),\n+                S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\n+            if (handle == invalidHandle)\n+            {\n+                static if (is(Datum == const))\n+                {\n+                    // No error, nonexisting file in read mode behaves like an empty file.\n+                    return;\n+                }\n+                else\n+                {\n+                    fprintf(stderr, \"open(\\\"%s\\\") failed: %s\\n\", filename, strerror(errno));\n+                    exit(1);\n+                }\n+            }\n+\n+            const size = fileSize(handle);\n+\n+            if (size > 0 && size != ulong.max && size <= size_t.max)\n+            {\n+                auto p = mmap(null, cast(size_t) size, is(Datum == const) ? PROT_READ : PROT_WRITE, MAP_SHARED, handle, 0);\n+                if (p == MAP_FAILED)\n+                {\n+                    fprintf(stderr, \"mmap(null, %zu) for \\\"%s\\\" failed: %s\\n\", cast(size_t) size, filename, strerror(errno));\n+                    exit(1);\n+                }\n+                // The cast below will always work because it's gated by the `size <= size_t.max` condition.\n+                data = cast(Datum[]) p[0 .. cast(size_t) size];\n+            }\n+        }\n+        else version(Windows)\n+        {\n+            static if (is(Datum == const))\n+            {\n+                enum createFileMode = GENERIC_READ;\n+                enum openFlags = OPEN_EXISTING;\n+            }\n+            else\n+            {\n+                enum createFileMode = GENERIC_READ | GENERIC_WRITE;\n+                enum openFlags = CREATE_ALWAYS;\n+            }\n+\n+            handle = filename.asDString.extendedPathThen!(p => CreateFileW(p.ptr, createFileMode, 0, null, openFlags, FILE_ATTRIBUTE_NORMAL, null));\n+            if (handle == invalidHandle)\n+            {\n+                static if (is(Datum == const))\n+                {\n+                    return;\n+                }\n+                else\n+                {\n+                    fprintf(stderr, \"CreateFileW() failed for \\\"%s\\\": %d\\n\", filename, GetLastError());\n+                    exit(1);\n+                }\n+            }\n+            createMapping(filename, fileSize(handle));\n+        }\n+        else static assert(0);\n+\n+        // Save the name for later. Technically there's no need: on Linux one can use readlink on /proc/self/fd/NNN.\n+        // On BSD and OSX one can use fcntl with F_GETPATH. On Windows one can use GetFileInformationByHandleEx.\n+        // But just saving the name is simplest, fastest, and most portable...\n+        import core.stdc.string : strlen;\n+        import core.stdc.stdlib : malloc;\n+        import core.stdc.string : memcpy;\n+        auto totalNameLength = filename.strlen() + 1;\n+        name = cast(char*) memcpy(malloc(totalNameLength), filename, totalNameLength);\n+        name || assert(0, \"FileMapping: Out of memory.\");\n+    }\n+\n+    /**\n+    Common code factored opportunistically. Windows only. Assumes `handle` is\n+    already pointing to an opened file. Initializes the `fileMappingObject`\n+    and `data` members.\n+\n+    Params:\n+    filename = the file to be mapped\n+    size = the size of the file in bytes\n+    */\n+    version(Windows) private void createMapping(const char* filename, ulong size)\n+    {\n+        assert(size <= size_t.max || size == ulong.max);\n+        assert(handle != invalidHandle);\n+        assert(data is null);\n+        assert(fileMappingObject == invalidHandle);\n+\n+        if (size == 0 || size == ulong.max)\n+            return;\n+\n+        static if (is(Datum == const))\n+        {\n+            enum fileMappingFlags = PAGE_READONLY;\n+            enum mapViewFlags = FILE_MAP_READ;\n+        }\n+        else\n+        {\n+            enum fileMappingFlags = PAGE_READWRITE;\n+            enum mapViewFlags = FILE_MAP_WRITE;\n+        }\n+\n+        fileMappingObject = CreateFileMappingW(handle, null, fileMappingFlags, 0, 0, null);\n+        if (!fileMappingObject)\n+        {\n+            fprintf(stderr, \"CreateFileMappingW(%p) failed for %llu bytes of \\\"%s\\\": %d\\n\",\n+                handle, size, filename, GetLastError());\n+            fileMappingObject = invalidHandle;  // by convention always use invalidHandle, not null\n+            exit(1);\n+        }\n+        auto p = MapViewOfFile(fileMappingObject, mapViewFlags, 0, 0, 0);\n+        if (!p)\n+        {\n+            fprintf(stderr, \"MapViewOfFile() failed for \\\"%s\\\": %d\\n\", filename, GetLastError());\n+            exit(1);\n+        }\n+        data = cast(Datum[]) p[0 .. cast(size_t) size];\n+    }\n+\n+    // Not copyable or assignable (for now).\n+    @disable this(const FileMapping!Datum rhs);\n+    @disable void opAssign(const ref FileMapping!Datum rhs);\n+\n+    /**\n+    Frees resources associated with this mapping. However, it does not deallocate the name.\n+    */\n+    ~this() pure nothrow\n+    {\n+        if (!active)\n+            return;\n+        fakePure({\n+            version (Posix)\n+            {\n+                import core.sys.posix.sys.mman : munmap;\n+                import core.sys.posix.unistd : close;\n+\n+                // Cannot call fprintf from inside a destructor, so exiting silently.\n+\n+                if (data.ptr && munmap(cast(void*) data.ptr, data.length) != 0)\n+                {\n+                    exit(1);\n+                }\n+                data = null;\n+                if (handle != invalidHandle && close(handle) != 0)\n+                {\n+                    exit(1);\n+                }\n+                handle = invalidHandle;\n+            }\n+            else version(Windows)\n+            {\n+                if (data.ptr !is null && UnmapViewOfFile(cast(void*) data.ptr) == 0)\n+                {\n+                    exit(1);\n+                }\n+                data = null;\n+                if (fileMappingObject != invalidHandle && CloseHandle(fileMappingObject) == 0)\n+                {\n+                    exit(1);\n+                }\n+                fileMappingObject = invalidHandle;\n+                if (handle != invalidHandle && CloseHandle(handle) == 0)\n+                {\n+                    exit(1);\n+                }\n+                handle = invalidHandle;\n+            }\n+            else static assert(0);\n+        });\n+    }\n+\n+    /**\n+    Returns the zero-terminated file name associated with the mapping. Can NOT\n+    be saved beyond the lifetime of `this`.\n+    */\n+    private const(char)* filename() const pure @nogc @safe nothrow { return name; }\n+\n+    /**\n+    Frees resources associated with this mapping. However, it does not deallocate the name.\n+    Reinitializes `this` as a fresh object that can be reused.\n+    */\n+    void close()\n+    {\n+        __dtor();\n+        handle = invalidHandle;\n+        version(Windows) fileMappingObject = invalidHandle;\n+        data = null;\n+        name = null;\n+    }\n+\n+    /**\n+    Deletes the underlying file and frees all resources associated.\n+    Reinitializes `this` as a fresh object that can be reused.\n+\n+    This function does not abort if the file cannot be deleted, but does print\n+    a message on `stderr` and returns `false` to the caller. The underlying\n+    rationale is to give the caller the option to continue execution if\n+    deleting the file is not important.\n+\n+    Returns: `true` iff the file was successfully deleted. If the file was not\n+    deleted, prints a message to `stderr` and returns `false`.\n+    */\n+    static if (!is(Datum == const))\n+    bool discard()\n+    {\n+        // Truncate file to zero so unflushed buffers are not flushed unnecessarily.\n+        resize(0);\n+        auto deleteme = name;\n+        close();\n+        // In-memory resource freed, now get rid of the underlying temp file.\n+        version(Posix)\n+        {\n+            import core.sys.posix.unistd : unlink;\n+            if (unlink(deleteme) != 0)\n+            {\n+                fprintf(stderr, \"unlink(\\\"%s\\\") failed: %s\\n\", filename, strerror(errno));\n+                return false;\n+            }\n+        }\n+        else version(Windows)\n+        {\n+            import core.sys.windows.winbase;\n+            if (deleteme.asDString.extendedPathThen!(p => DeleteFileW(p.ptr)) == 0)\n+            {\n+                fprintf(stderr, \"DeleteFileW error %d\\n\", GetLastError());\n+                return false;\n+            }\n+        }\n+        else static assert(0);\n+        return true;\n+    }\n+\n+    /**\n+    Queries whether `this` is currently associated with a file.\n+\n+    Returns: `true` iff there is an active mapping.\n+    */\n+    bool active() const pure @nogc nothrow\n+    {\n+        return handle !is invalidHandle;\n+    }\n+\n+    /**\n+    Queries the length of the file associated with this mapping.  If not\n+    active, returns 0.\n+\n+    Returns: the length of the file, or 0 if no file associated.\n+    */\n+    size_t length() const pure @nogc @safe nothrow { return data.length; }\n+\n+    /**\n+    Get a slice to the contents of the entire file.\n+\n+    Returns: the contents of the file. If not active, returns the `null` slice.\n+    */\n+    auto opSlice() pure @nogc @safe nothrow { return data; }\n+\n+    /**\n+    Resizes the file and mapping to the specified `size`.\n+\n+    Params:\n+    size = new length requested\n+    */\n+    static if (!is(Datum == const))\n+    void resize(size_t size) pure\n+    {\n+        assert(handle != invalidHandle);\n+        fakePure({\n+            version(Posix)\n+            {\n+                import core.sys.posix.unistd : ftruncate;\n+                import core.sys.posix.sys.mman;\n+\n+                if (data.length)\n+                {\n+                    assert(data.ptr, \"Corrupt memory mapping\");\n+                    // assert(0) here because it would indicate an internal error\n+                    munmap(cast(void*) data.ptr, data.length) == 0 || assert(0);\n+                    data = null;\n+                }\n+                if (ftruncate(handle, size) != 0)\n+                {\n+                    fprintf(stderr, \"ftruncate() failed for \\\"%s\\\": %s\\n\", filename, strerror(errno));\n+                    exit(1);\n+                }\n+                if (size > 0)\n+                {\n+                    auto p = mmap(null, size, PROT_WRITE, MAP_SHARED, handle, 0);\n+                    if (cast(ssize_t) p == -1)\n+                    {\n+                        fprintf(stderr, \"mmap() failed for \\\"%s\\\": %s\\n\", filename, strerror(errno));\n+                        exit(1);\n+                    }\n+                    data = cast(Datum[]) p[0 .. size];\n+                }\n+            }\n+            else version(Windows)\n+            {\n+                // Per documentation, must unmap first.\n+                if (data.length > 0 && UnmapViewOfFile(cast(void*) data.ptr) == 0)\n+                {\n+                    fprintf(stderr, \"UnmapViewOfFile(%p) failed for memory mapping of \\\"%s\\\": %d\\n\",\n+                        data.ptr, filename, GetLastError());\n+                    exit(1);\n+                }\n+                data = null;\n+                if (fileMappingObject != invalidHandle && CloseHandle(fileMappingObject) == 0)\n+                {\n+                    fprintf(stderr, \"CloseHandle() failed for memory mapping of \\\"%s\\\": %d\\n\", filename, GetLastError());\n+                    exit(1);\n+                }\n+                fileMappingObject = invalidHandle;\n+                LARGE_INTEGER biggie;\n+                biggie.QuadPart = size;\n+                if (SetFilePointerEx(handle, biggie, null, FILE_BEGIN) == 0 || SetEndOfFile(handle) == 0)\n+                {\n+                    fprintf(stderr, \"SetFilePointer() failed for \\\"%s\\\": %d\\n\", filename, GetLastError());\n+                    exit(1);\n+                }\n+                createMapping(name, size);\n+            }\n+            else static assert(0);\n+        });\n+    }\n+\n+    /**\n+    Unconditionally and destructively moves the underlying file to `filename`.\n+    If the operation succeeds, returns true. Upon failure, prints a message to\n+    `stderr` and returns `false`. In all cases it closes the underlying file.\n+\n+    Params: filename = zero-terminated name of the file to move to.\n+\n+    Returns: `true` iff the operation was successful.\n+    */\n+    bool moveToFile(const char* filename)\n+    {\n+        assert(name !is null);\n+\n+        // Fetch the name and then set it to `null` so it doesn't get deallocated\n+        auto oldname = name;\n+        import core.stdc.stdlib;\n+        scope(exit) free(cast(void*) oldname);\n+        name = null;\n+        close();\n+\n+        // Rename the underlying file to the target, no copy necessary.\n+        version(Posix)\n+        {\n+            if (.rename(oldname, filename) != 0)\n+            {\n+                fprintf(stderr, \"rename(\\\"%s\\\", \\\"%s\\\") failed: %s\\n\", oldname, filename, strerror(errno));\n+                return false;\n+            }\n+        }\n+        else version(Windows)\n+        {\n+            import core.sys.windows.winbase;\n+            auto r = oldname.asDString.extendedPathThen!(\n+                p1 => filename.asDString.extendedPathThen!(p2 => MoveFileExW(p1.ptr, p2.ptr, MOVEFILE_REPLACE_EXISTING))\n+            );\n+            if (r == 0)\n+            {\n+                fprintf(stderr, \"MoveFileExW(\\\"%s\\\", \\\"%s\\\") failed: %d\\n\", oldname, filename, GetLastError());\n+                return false;\n+            }\n+        }\n+        else static assert(0);\n+        return true;\n+    }\n+}\n+\n+/// Write a file, returning `true` on success.\n+extern(D) static bool writeFile(const(char)* name, const void[] data) nothrow\n+{\n+    version (Posix)\n+    {\n+        int fd = open(name, O_CREAT | O_WRONLY | O_TRUNC, (6 << 6) | (4 << 3) | 4);\n+        if (fd == -1)\n+            goto err;\n+        if (.write(fd, data.ptr, data.length) != data.length)\n+            goto err2;\n+        if (close(fd) == -1)\n+            goto err;\n+        return true;\n+    err2:\n+        close(fd);\n+        .remove(name);\n+    err:\n+        return false;\n+    }\n+    else version (Windows)\n+    {\n+        DWORD numwritten; // here because of the gotos\n+        const nameStr = name.asDString;\n+        // work around Windows file path length limitation\n+        // (see documentation for extendedPathThen).\n+        HANDLE h = nameStr.extendedPathThen!\n+            (p => CreateFileW(p.ptr,\n+                                GENERIC_WRITE,\n+                                0,\n+                                null,\n+                                CREATE_ALWAYS,\n+                                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,\n+                                null));\n+        if (h == INVALID_HANDLE_VALUE)\n+            goto err;\n+\n+        if (WriteFile(h, data.ptr, cast(DWORD)data.length, &numwritten, null) != TRUE)\n+            goto err2;\n+        if (numwritten != data.length)\n+            goto err2;\n+        if (!CloseHandle(h))\n+            goto err;\n+        return true;\n+    err2:\n+        CloseHandle(h);\n+        nameStr.extendedPathThen!(p => DeleteFileW(p.ptr));\n+    err:\n+        return false;\n+    }\n+    else\n+    {\n+        static assert(0);\n+    }\n+}\n+\n+/// Touch a file to current date\n+bool touchFile(const char* namez)\n+{\n+    version (Windows)\n+    {\n+        FILETIME ft = void;\n+        SYSTEMTIME st = void;\n+        GetSystemTime(&st);\n+        SystemTimeToFileTime(&st, &ft);\n+\n+        import core.stdc.string : strlen;\n+\n+        // get handle to file\n+        HANDLE h = namez[0 .. namez.strlen()].extendedPathThen!(p => CreateFile(p.ptr,\n+            FILE_WRITE_ATTRIBUTES, FILE_SHARE_READ | FILE_SHARE_WRITE,\n+            null, OPEN_EXISTING,\n+            FILE_ATTRIBUTE_NORMAL, null));\n+        if (h == INVALID_HANDLE_VALUE)\n+            return false;\n+\n+        const f = SetFileTime(h, null, null, &ft); // set last write time\n+\n+        if (!CloseHandle(h))\n+            return false;\n+\n+        return f != 0;\n+    }\n+    else version (Posix)\n+    {\n+        import core.sys.posix.utime;\n+        return utime(namez, null) == 0;\n+    }\n+    else\n+        static assert(0);\n+}\n+\n+// Feel free to make these public if used elsewhere.\n+/**\n+Size of a file in bytes.\n+Params: fd = file handle\n+Returns: file size in bytes, or `ulong.max` on any error.\n+*/\n+version (Posix)\n+private ulong fileSize(int fd)\n+{\n+    import core.sys.posix.sys.stat;\n+    stat_t buf;\n+    if (fstat(fd, &buf) == 0)\n+        return buf.st_size;\n+    return ulong.max;\n+}\n+\n+/// Ditto\n+version (Windows)\n+private ulong fileSize(HANDLE fd)\n+{\n+    ulong result;\n+    if (GetFileSizeEx(fd, cast(LARGE_INTEGER*) &result) == 0)\n+        return result;\n+    return ulong.max;\n+}\n+\n+/**\n+Runs a non-pure function or delegate as pure code. Use with caution.\n+\n+Params:\n+fun = the delegate to run, usually inlined: `fakePure({ ... });`\n+\n+Returns: whatever `fun` returns.\n+*/\n+private auto ref fakePure(F)(scope F fun) pure\n+{\n+    mixin(\"alias PureFun = \" ~ F.stringof ~ \" pure;\");\n+    return (cast(PureFun) fun)();\n+}"}, {"sha": "c5a84375aaaa9356a25d445b9d3f82698e68b1bf", "filename": "gcc/d/dmd/common/outbuffer.d", "status": "renamed", "additions": 211, "deletions": 32, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fcommon%2Foutbuffer.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fcommon%2Foutbuffer.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcommon%2Foutbuffer.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -9,14 +9,21 @@\n  * Coverage:    https://codecov.io/gh/dlang/dmd/src/master/src/dmd/root/outbuffer.d\n  */\n \n-module dmd.root.outbuffer;\n+module dmd.common.outbuffer;\n \n import core.stdc.stdarg;\n import core.stdc.stdio;\n import core.stdc.string;\n-import dmd.root.rmem;\n-import dmd.root.rootobject;\n-import dmd.root.string;\n+import core.stdc.stdlib;\n+\n+// In theory these functions should also restore errno, but we don't care because\n+// we abort application on error anyway.\n+extern (C) private pure @system @nogc nothrow\n+{\n+    pragma(mangle, \"malloc\") void* pureMalloc(size_t);\n+    pragma(mangle, \"realloc\") void* pureRealloc(void* ptr, size_t size);\n+    pragma(mangle, \"free\") void pureFree(void* ptr);\n+}\n \n debug\n {\n@@ -29,7 +36,7 @@ a contiguous array or a memory-mapped file.\n */\n struct OutBuffer\n {\n-    import dmd.root.file : FileMapping;\n+    import dmd.common.file : FileMapping, touchFile, writeFile;\n \n     // IMPORTANT: PLEASE KEEP STATE AND DESTRUCTOR IN SYNC WITH DEFINITION IN ./outbuffer.h.\n     // state {\n@@ -47,6 +54,14 @@ struct OutBuffer\n     int level;\n     // state }\n \n+    /**\n+    Construct given size.\n+    */\n+    this(size_t initialSize) nothrow\n+    {\n+        reserve(initialSize);\n+    }\n+\n     /**\n     Construct from filename. Will map the file into memory (or create it anew\n     if necessary) and start writing at the beginning of it.\n@@ -56,14 +71,36 @@ struct OutBuffer\n     */\n     @trusted this(const(char)* filename)\n     {\n-        fileMapping = new FileMapping!ubyte(filename);\n+        FileMapping!ubyte model;\n+        fileMapping = cast(FileMapping!ubyte*) malloc(model.sizeof);\n+        memcpy(fileMapping, &model, model.sizeof);\n+        fileMapping.__ctor(filename);\n+        //fileMapping = new FileMapping!ubyte(filename);\n         data = (*fileMapping)[];\n     }\n \n+    /**\n+    Frees resources associated.\n+    */\n+    extern (C++) void dtor() nothrow @trusted\n+    {\n+        if (fileMapping)\n+        {\n+            if (fileMapping.active)\n+                fileMapping.close();\n+            fileMapping = null;\n+        }\n+        else\n+        {\n+            debug (stomp) memset(data.ptr, 0xFF, data.length);\n+            free(data.ptr);\n+        }\n+    }\n+\n     /**\n     Frees resources associated automatically.\n     */\n-    extern (C++) ~this() pure nothrow\n+    extern (C++) ~this() pure nothrow @trusted\n     {\n         if (fileMapping)\n         {\n@@ -74,10 +111,23 @@ struct OutBuffer\n         else\n         {\n             debug (stomp) memset(data.ptr, 0xFF, data.length);\n-            mem.xfree(data.ptr);\n+            pureFree(data.ptr);\n         }\n     }\n \n+    /// For porting with ease from dmd.backend.outbuf.Outbuffer\n+    ubyte* buf() nothrow {\n+        return data.ptr;\n+    }\n+\n+    /// For porting with ease from dmd.backend.outbuf.Outbuffer\n+    ubyte** bufptr() nothrow {\n+        static struct Array { size_t length; ubyte* ptr; }\n+        auto a = cast(Array*) &data;\n+        assert(a.length == data.length && a.ptr == data.ptr);\n+        return &a.ptr;\n+    }\n+\n     extern (C++) size_t length() const pure @nogc @safe nothrow { return offset; }\n \n     /**********************\n@@ -109,7 +159,7 @@ struct OutBuffer\n         else\n         {\n             debug (stomp) memset(data.ptr, 0xFF, data.length);\n-            mem.xfree(extractData());\n+            pureFree(extractData());\n         }\n     }\n \n@@ -141,17 +191,18 @@ struct OutBuffer\n         {\n             debug (stomp)\n             {\n-                auto p = cast(ubyte*)mem.xmalloc(size);\n+                auto p = cast(ubyte*) pureMalloc(size);\n+                p || assert(0, \"OutBuffer: out of memory.\");\n                 memcpy(p, data.ptr, offset);\n                 memset(data.ptr, 0xFF, data.length);  // stomp old location\n-                mem.xfree(data.ptr);\n+                pureFree(data.ptr);\n                 memset(p + offset, 0xff, size - offset); // stomp unused data\n             }\n             else\n             {\n-                auto p = cast(ubyte*)mem.xrealloc(data.ptr, size);\n-                if (mem.isGCEnabled) // clear currently unused data to avoid false pointers\n-                    memset(p + offset + nbytes, 0xff, size - offset - nbytes);\n+                auto p = cast(ubyte*) pureRealloc(data.ptr, size);\n+                p || assert(0, \"OutBuffer: out of memory.\");\n+                memset(p + offset + nbytes, 0xff, size - offset - nbytes);\n             }\n             data = p[0 .. size];\n         }\n@@ -164,7 +215,7 @@ struct OutBuffer\n      */\n     extern (C++) void setsize(size_t size) pure nothrow @nogc @safe\n     {\n-        assert(size <= offset);\n+        assert(size <= data.length);\n         offset = size;\n     }\n \n@@ -185,6 +236,14 @@ struct OutBuffer\n         notlinehead = true;\n     }\n \n+    // Write an array to the buffer, no reserve check\n+    @trusted nothrow\n+    void writen(const void *b, size_t len)\n+    {\n+        memcpy(data.ptr + offset, b, len);\n+        offset += len;\n+    }\n+\n     extern (C++) void write(const(void)* data, size_t nbytes) pure nothrow\n     {\n         write(data[0 .. nbytes]);\n@@ -199,27 +258,90 @@ struct OutBuffer\n         offset += buf.length;\n     }\n \n-    extern (C++) void writestring(const(char)* string) pure nothrow\n+    /**\n+     * Writes a 16 bit value, no reserve check.\n+     */\n+    @trusted nothrow\n+    void write16n(int v)\n     {\n-        write(string.toDString);\n+        auto x = cast(ushort) v;\n+        data[offset] = x & 0x00FF;\n+        data[offset + 1] = x >> 8u;\n+        offset += 2;\n     }\n \n+    /**\n+     * Writes a 16 bit value.\n+     */\n+    void write16(int v) nothrow\n+    {\n+        auto u = cast(ushort) v;\n+        write(&u, u.sizeof);\n+    }\n+\n+    /**\n+     * Writes a 32 bit int.\n+     */\n+    void write32(int v) nothrow @trusted\n+    {\n+        write(&v, v.sizeof);\n+    }\n+\n+    /**\n+     * Writes a 64 bit int.\n+     */\n+    @trusted void write64(long v) nothrow\n+    {\n+        write(&v, v.sizeof);\n+    }\n+\n+    /// NOT zero-terminated\n+    extern (C++) void writestring(const(char)* s) pure nothrow\n+    {\n+        if (!s)\n+            return;\n+        import core.stdc.string : strlen;\n+        write(s[0 .. strlen(s)]);\n+    }\n+\n+    /// ditto\n     void writestring(const(char)[] s) pure nothrow\n     {\n         write(s);\n     }\n \n+    /// ditto\n     void writestring(string s) pure nothrow\n     {\n         write(s);\n     }\n \n+    /// NOT zero-terminated, followed by newline\n     void writestringln(const(char)[] s) pure nothrow\n     {\n         writestring(s);\n         writenl();\n     }\n \n+    // Zero-terminated\n+    void writeString(const(char)* s) pure nothrow @trusted\n+    {\n+        write(s[0 .. strlen(s)+1]);\n+    }\n+\n+    /// ditto\n+    void writeString(const(char)[] s) pure nothrow\n+    {\n+        write(s);\n+        writeByte(0);\n+    }\n+\n+    /// ditto\n+    void writeString(string s) pure nothrow\n+    {\n+        writeString(cast(const(char)[])(s));\n+    }\n+\n     extern (C++) void prependstring(const(char)* string) pure nothrow\n     {\n         size_t len = strlen(string);\n@@ -244,6 +366,38 @@ struct OutBuffer\n             notlinehead = false;\n     }\n \n+    // Write n zeros; return pointer to start of zeros\n+    @trusted\n+    void *writezeros(size_t n) nothrow\n+    {\n+        reserve(n);\n+        auto result = memset(data.ptr + offset, 0, n);\n+        offset += n;\n+        return result;\n+    }\n+\n+    // Position buffer to accept the specified number of bytes at offset\n+    @trusted\n+    void position(size_t where, size_t nbytes) nothrow\n+    {\n+        if (where + nbytes > data.length)\n+        {\n+            reserve(where + nbytes - offset);\n+        }\n+        offset = where;\n+\n+        debug assert(offset + nbytes <= data.length);\n+    }\n+\n+    /**\n+     * Writes an 8 bit byte, no reserve check.\n+     */\n+    extern (C++) @trusted nothrow\n+    void writeByten(int b)\n+    {\n+        this.data[offset++] = cast(ubyte) b;\n+    }\n+\n     extern (C++) void writeByte(uint b) pure nothrow\n     {\n         if (doindent && !notlinehead && b != '\\n')\n@@ -369,14 +523,6 @@ struct OutBuffer\n         }\n     }\n \n-    extern (C++) void write(RootObject obj) /*nothrow*/\n-    {\n-        if (obj)\n-        {\n-            writestring(obj.toChars());\n-        }\n-    }\n-\n     extern (C++) void fill0(size_t nbytes) pure nothrow\n     {\n         reserve(nbytes);\n@@ -428,8 +574,8 @@ struct OutBuffer\n                 break;\n         }\n         offset += count;\n-        if (mem.isGCEnabled)\n-            memset(data.ptr + offset, 0xff, psize - count);\n+        // if (mem.isGCEnabled)\n+             memset(data.ptr + offset, 0xff, psize - count);\n     }\n \n     static if (__VERSION__ < 2092)\n@@ -460,7 +606,6 @@ struct OutBuffer\n      */\n     extern (C++) void print(ulong u) pure nothrow\n     {\n-        //import core.internal.string;  // not available\n         UnsignedStringBuf buf = void;\n         writestring(unsignedToTempString(u, buf));\n     }\n@@ -558,6 +703,11 @@ struct OutBuffer\n         return extractData()[0 .. length];\n     }\n \n+    extern (D) byte[] extractUbyteSlice(bool nullTerminate = false) pure nothrow\n+    {\n+        return cast(byte[]) extractSlice(nullTerminate);\n+    }\n+\n     // Append terminating null if necessary and get view of internal buffer\n     extern (C++) char* peekChars() pure nothrow\n     {\n@@ -577,6 +727,36 @@ struct OutBuffer\n         return extractData();\n     }\n \n+    void writesLEB128(int value) pure nothrow\n+    {\n+        while (1)\n+        {\n+            ubyte b = value & 0x7F;\n+\n+            value >>= 7;            // arithmetic right shift\n+            if ((value == 0 && !(b & 0x40)) ||\n+                (value == -1 && (b & 0x40)))\n+            {\n+                 writeByte(b);\n+                 break;\n+            }\n+            writeByte(b | 0x80);\n+        }\n+    }\n+\n+    void writeuLEB128(uint value) pure nothrow\n+    {\n+        do\n+        {\n+            ubyte b = value & 0x7F;\n+\n+            value >>= 7;\n+            if (value)\n+                b |= 0x80;\n+            writeByte(b);\n+        } while (value);\n+    }\n+\n     /**\n     Destructively saves the contents of `this` to `filename`. As an\n     optimization, if the file already has identical contents with the buffer,\n@@ -591,7 +771,6 @@ struct OutBuffer\n     */\n     extern(D) bool moveToFile(const char* filename)\n     {\n-        import dmd.root.file;\n         bool result = true;\n         const bool identical = this[] == FileMapping!(const ubyte)(filename)[];\n \n@@ -615,12 +794,12 @@ struct OutBuffer\n         else\n         {\n             if (!identical)\n-                File.write(filename, this[]);\n+                writeFile(filename, this[]);\n             destroy();\n         }\n \n         return identical\n-            ? result && File.touch(filename)\n+            ? result && touchFile(filename)\n             : result;\n     }\n }\n@@ -645,7 +824,7 @@ char[] unsignedToTempString(ulong value, char[] buf, uint radix = 10) @safe pure\n         else\n         {\n             ubyte x = cast(ubyte)(value % radix);\n-            value = value / radix;\n+            value /= radix;\n             buf[--i] = cast(char)((x < 10) ? x + '0' : x - 10 + 'a');\n         }\n     } while (value);", "previous_filename": "gcc/d/dmd/root/outbuffer.d"}, {"sha": "a5e3f9c541d7d60a0dbab0583060ea5b346b309c", "filename": "gcc/d/dmd/common/outbuffer.h", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fcommon%2Foutbuffer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fcommon%2Foutbuffer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcommon%2Foutbuffer.h?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,14 +4,14 @@\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n  * http://www.boost.org/LICENSE_1_0.txt\n- * https://github.com/dlang/dmd/blob/master/src/dmd/root/outbuffer.h\n+ * https://github.com/dlang/dmd/blob/master/src/dmd/common/outbuffer.h\n  */\n \n #pragma once\n \n-#include \"dsystem.h\"\n-#include \"dcompat.h\"\n-#include \"rmem.h\"\n+#include \"../root/dsystem.h\"\n+#include \"../root/dcompat.h\"\n+#include \"../root/rmem.h\"\n \n class RootObject;\n \n@@ -22,7 +22,7 @@ struct OutBuffer\n     DArray<unsigned char> data;\n     d_size_t offset;\n     bool notlinehead;\n-    void* fileMapping;  // pointer to a file mapping object not used on the C++ side\n+    void *fileMapping;  // pointer to a file mapping object not used on the C++ side\n public:\n     bool doindent;\n     bool spaces;", "previous_filename": "gcc/d/dmd/root/outbuffer.h"}, {"sha": "026374af89deb0be633c5d612a31749018556211", "filename": "gcc/d/dmd/common/string.d", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fcommon%2Fstring.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fcommon%2Fstring.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcommon%2Fstring.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,209 @@\n+/**\n+ * Common string functions including filename manipulation.\n+ *\n+ * Copyright: Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n+ * Authors:   Walter Bright, http://www.digitalmars.com\n+ * License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+ * Source:    $(LINK2 https://github.com/dlang/dmd/blob/master/src/dmd/common/string.d, common/_string.d)\n+ * Documentation: https://dlang.org/phobos/dmd_common_string.html\n+ * Coverage:    https://codecov.io/gh/dlang/dmd/src/master/src/dmd/common/string.d\n+ */\n+module dmd.common.string;\n+\n+/**\n+Defines a temporary array using a fixed-length buffer as back store. If the length\n+of the buffer suffices, it is readily used. Otherwise, `malloc` is used to\n+allocate memory for the array and `free` is used for deallocation in the\n+destructor.\n+\n+This type is meant to use exclusively as an automatic variable. It is not\n+default constructible or copyable.\n+*/\n+struct SmallBuffer(T)\n+{\n+    import core.stdc.stdlib : malloc, free;\n+\n+    private T[] _extent;\n+    private bool needsFree;\n+\n+    @disable this(); // no default ctor\n+    @disable this(ref const SmallBuffer!T); // noncopyable, nonassignable\n+\n+    this(size_t len, T[] buffer)\n+    {\n+        if (len <= buffer.length)\n+        {\n+            _extent = buffer[0 .. len];\n+        }\n+        else\n+        {\n+            _extent = (cast(typeof(_extent.ptr)) malloc(len * _extent[0].sizeof))[0 .. len];\n+            _extent.ptr || assert(0, \"Out of memory.\");\n+            needsFree = true;\n+        }\n+        assert(this.length == len);\n+    }\n+\n+    ~this()\n+    {\n+        if (needsFree)\n+            free(_extent.ptr);\n+    }\n+\n+    void create(size_t len)\n+    {\n+        if (len <= _extent.length)\n+        {\n+            _extent = _extent[0 .. len];\n+        }\n+        else\n+        {\n+            __dtor();\n+            _extent = (cast(typeof(_extent.ptr)) malloc(len * _extent[0].sizeof))[0 .. len];\n+            _extent.ptr || assert(0, \"Out of memory.\");\n+            needsFree = true;\n+        }\n+        assert(this.length == len);\n+    }\n+\n+    // Force accesses to extent to be scoped.\n+    scope inout extent()\n+    {\n+        return _extent;\n+    }\n+\n+    alias extent this;\n+}\n+\n+/// ditto\n+unittest\n+{\n+    char[230] buf = void;\n+    auto a = SmallBuffer!char(10, buf);\n+    assert(a[] is buf[0 .. 10]);\n+    auto b = SmallBuffer!char(1000, buf);\n+    assert(b[] !is buf[]);\n+    b.create(1000);\n+    assert(b.length == 1000);\n+    assert(b[] !is buf[]);\n+}\n+\n+/**\n+Converts a zero-terminated C string to a D slice. Takes linear time and allocates no memory.\n+\n+Params:\n+stringz = the C string to be converted\n+\n+Returns:\n+a slice comprehending the string. The terminating 0 is not part of the slice.\n+*/\n+auto asDString(C)(C* stringz) pure @nogc nothrow\n+{\n+    import core.stdc.string : strlen;\n+    return stringz[0 .. strlen(stringz)];\n+}\n+\n+///\n+unittest\n+{\n+    const char* p = \"123\".ptr;\n+    assert(p.asDString == \"123\");\n+}\n+\n+/**\n+(Windows only) Converts a narrow string to a wide string using `buffer` as strorage. Returns a slice managed by\n+`buffer` containing the converted string. The terminating zero is not part of the returned slice,\n+but is guaranteed to follow it.\n+*/\n+version(Windows) wchar[] toWStringz(const(char)[] narrow, ref SmallBuffer!wchar buffer) nothrow\n+{\n+    import core.sys.windows.winnls : CP_ACP, MultiByteToWideChar;\n+    // assume filenames encoded in system default Windows ANSI code page\n+    enum CodePage = CP_ACP;\n+\n+    if (narrow is null)\n+        return null;\n+\n+    const requiredLength = MultiByteToWideChar(CodePage, 0, narrow.ptr, cast(int) narrow.length, buffer.ptr, cast(int) buffer.length);\n+    if (requiredLength < cast(int) buffer.length)\n+    {\n+        buffer[requiredLength] = 0;\n+        return buffer[0 .. requiredLength];\n+    }\n+\n+    buffer.create(requiredLength + 1);\n+    const length = MultiByteToWideChar(CodePage, 0, narrow.ptr, cast(int) narrow.length, buffer.ptr, requiredLength);\n+    assert(length == requiredLength);\n+    buffer[length] = 0;\n+    return buffer[0 .. length];\n+}\n+\n+/**************************************\n+* Converts a path to one suitable to be passed to Win32 API\n+* functions that can deal with paths longer than 248\n+* characters then calls the supplied function on it.\n+*\n+* Params:\n+*  path = The Path to call F on.\n+*\n+* Returns:\n+*  The result of calling F on path.\n+*\n+* References:\n+*  https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx\n+*/\n+version(Windows) auto extendedPathThen(alias F)(const(char)[] path)\n+{\n+    import core.sys.windows.winbase;\n+    import core.sys.windows.winnt;\n+\n+    if (!path.length)\n+        return F((wchar[]).init);\n+\n+    wchar[1024] buf = void;\n+    auto store = SmallBuffer!wchar(buf.length, buf);\n+    auto wpath = toWStringz(path, store);\n+\n+    // GetFullPathNameW expects a sized buffer to store the result in. Since we don't\n+    // know how large it has to be, we pass in null and get the needed buffer length\n+    // as the return code.\n+    const pathLength = GetFullPathNameW(&wpath[0],\n+                                        0 /*length8*/,\n+                                        null /*output buffer*/,\n+                                        null /*filePartBuffer*/);\n+    if (pathLength == 0)\n+    {\n+        return F((wchar[]).init);\n+    }\n+\n+    // wpath is the UTF16 version of path, but to be able to use\n+    // extended paths, we need to prefix with `\\\\?\\` and the absolute\n+    // path.\n+    static immutable prefix = `\\\\?\\`w;\n+\n+    // prefix only needed for long names and non-UNC names\n+    const needsPrefix = pathLength >= MAX_PATH && (wpath[0] != '\\\\' || wpath[1] != '\\\\');\n+    const prefixLength = needsPrefix ? prefix.length : 0;\n+\n+    // +1 for the null terminator\n+    const bufferLength = pathLength + prefixLength + 1;\n+\n+    wchar[1024] absBuf = void;\n+    auto absPath = SmallBuffer!wchar(bufferLength, absBuf);\n+\n+    absPath[0 .. prefixLength] = prefix[0 .. prefixLength];\n+\n+    const absPathRet = GetFullPathNameW(&wpath[0],\n+        cast(uint)(absPath.length - prefixLength - 1),\n+        &absPath[prefixLength],\n+        null /*filePartBuffer*/);\n+\n+    if (absPathRet == 0 || absPathRet > absPath.length - prefixLength)\n+    {\n+        return F((wchar[]).init);\n+    }\n+\n+    absPath[$ - 1] = '\\0';\n+    // Strip null terminator from the slice\n+    return F(absPath[0 .. $ - 1]);\n+}"}, {"sha": "05bd4bd550d1c69ab70d6a75e99d29fa2cbaaba0", "filename": "gcc/d/dmd/cond.d", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fcond.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fcond.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcond.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -28,7 +28,7 @@ import dmd.globals;\n import dmd.identifier;\n import dmd.mtype;\n import dmd.typesem;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.root.rootobject;\n import dmd.root.string;\n import dmd.tokens;\n@@ -452,7 +452,6 @@ extern (C++) final class StaticForeach : RootObject\n             sc = sc.startCTFE();\n             aggrfe.aggr = aggrfe.aggr.expressionSemantic(sc);\n             sc = sc.endCTFE();\n-            aggrfe.aggr = aggrfe.aggr.optimize(WANTvalue);\n         }\n \n         if (aggrfe && aggrfe.aggr.type.toBasetype().ty == Terror)"}, {"sha": "7d8ab67ee6acd9061e638ee9336dec73e3225a0c", "filename": "gcc/d/dmd/cparse.d", "status": "modified", "additions": 188, "deletions": 37, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fcparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fcparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcparse.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -23,7 +23,7 @@ import dmd.lexer;\n import dmd.parse;\n import dmd.errors;\n import dmd.root.filename;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.root.rmem;\n import dmd.root.rootobject;\n import dmd.root.string;\n@@ -72,6 +72,7 @@ final class CParser(AST) : Parser!AST\n     {\n         //printf(\"cparseTranslationUnit()\\n\");\n         symbols = new AST.Dsymbols();\n+        addBuiltinDeclarations();\n         while (1)\n         {\n             if (token.value == TOK.endOfFile)\n@@ -756,7 +757,6 @@ final class CParser(AST) : Parser!AST\n             switch (token.value)\n             {\n             case TOK.dot:\n-            case TOK.arrow:\n                 nextToken();\n                 if (token.value == TOK.identifier)\n                 {\n@@ -767,6 +767,19 @@ final class CParser(AST) : Parser!AST\n                 error(\"identifier expected following `.`, not `%s`\", token.toChars());\n                 break;\n \n+            case TOK.arrow:\n+                nextToken();\n+                if (token.value == TOK.identifier)\n+                {\n+                    Identifier id = token.ident;\n+                    auto die = new AST.DotIdExp(loc, e, id);\n+                    die.arrow = true;\n+                    e = die;\n+                    break;\n+                }\n+                error(\"identifier expected following `->`, not `%s`\", token.toChars());\n+                break;\n+\n             case TOK.plusPlus:\n                 e = new AST.PostExp(TOK.plusPlus, loc, e);\n                 break;\n@@ -949,6 +962,7 @@ final class CParser(AST) : Parser!AST\n                 nextToken();\n                 auto t = cparseTypeName();\n                 check(TOK.rightParenthesis);\n+                pt = &token;\n \n                 if (token.value == TOK.leftCurly)\n                 {\n@@ -957,6 +971,17 @@ final class CParser(AST) : Parser!AST\n                     auto ce = new AST.CompoundLiteralExp(loc, t, ci);\n                     return cparsePostfixOperators(ce);\n                 }\n+                else if (t.isTypeIdentifier() &&\n+                         token.value == TOK.leftParenthesis &&\n+                         !isCastExpression(pt))\n+                {\n+                    /* this might actually be a function\n+                     * call that looks like `(a)(b)` or even `(a)(b,c)`\n+                     */\n+                    auto ie = new AST.IdentifierExp(loc, t.isTypeIdentifier().ident);\n+                    ie.parens = true;    // disambiguate it from being a declaration\n+                    return new AST.CallExp(loc, ie, cparseArguments());\n+                }\n                 else\n                 {\n                     // ( type-name ) cast-expression\n@@ -1451,6 +1476,7 @@ final class CParser(AST) : Parser!AST\n \n         auto symbolsSave = symbols;\n         Specifier specifier;\n+        specifier.packalign = this.packalign;\n         auto tspec = cparseDeclarationSpecifiers(level, specifier);\n \n         /* If a declarator does not follow, it is unnamed\n@@ -1459,7 +1485,8 @@ final class CParser(AST) : Parser!AST\n         {\n             nextToken();\n             auto tt = tspec.isTypeTag();\n-            if (!tt || !tt.id)\n+            if (!tt ||\n+                !tt.id && (tt.tok == TOK.struct_ || tt.tok == TOK.union_))\n                 return; // legal but meaningless empty declaration, ignore it\n \n             /* `struct tag;` and `struct tag { ... };`\n@@ -1493,7 +1520,7 @@ final class CParser(AST) : Parser!AST\n         {\n             Identifier id;\n             AST.Expression asmname;\n-            auto dt = cparseDeclarator(DTR.xdirect, tspec, id);\n+            auto dt = cparseDeclarator(DTR.xdirect, tspec, id, specifier);\n             if (!dt)\n             {\n                 panic();\n@@ -1674,6 +1701,8 @@ final class CParser(AST) : Parser!AST\n                     return;\n \n                 case TOK.comma:\n+                    if (!symbolsSave)\n+                        symbolsSave = symbols;\n                     nextToken();\n                     break;\n \n@@ -1720,8 +1749,9 @@ final class CParser(AST) : Parser!AST\n              */\n             auto pl = ft.parameterList;\n             pl.hasIdentifierList = true;        // semantic needs to know to adjust parameter types\n-            if (pl.varargs != AST.VarArg.none)\n+            if (pl.varargs != AST.VarArg.none && pl.length)\n                 error(\"function identifier-list cannot end with `...`\");\n+            ft.parameterList.varargs = AST.VarArg.variadic;     // but C11 allows extra arguments\n             auto plLength = pl.length;\n             if (symbols.length != plLength)\n                 error(\"%d identifiers does not match %d declarations\", cast(int)plLength, cast(int)symbols.length);\n@@ -1756,7 +1786,10 @@ final class CParser(AST) : Parser!AST\n                     }\n                 }\n                 if (!p.type)\n+                {\n                     error(\"no declaration for identifier `%s`\", p.ident.toChars());\n+                    p.type = AST.Type.terror;\n+                }\n             }\n         }\n \n@@ -2240,14 +2273,14 @@ final class CParser(AST) : Parser!AST\n      *  declarator   = declarator kind\n      *  t            = base type to start with\n      *  pident       = set to Identifier if there is one, null if not\n-     *  storageClass = any storage classes seen so far that apply to a function\n+     *  specifier    = specifiers in and out\n      * Returns:\n      *  type declared. If a TypeFunction is returned, this.symbols is the\n      *  symbol table for the parameter-type-list, which will contain any\n      *  declared struct, union or enum tags.\n      */\n     private AST.Type cparseDeclarator(DTR declarator, AST.Type t,\n-        out Identifier pident, StorageClass storageClass = 0)\n+        out Identifier pident, ref Specifier specifier)\n     {\n         //printf(\"cparseDeclarator(%d)\\n\", declarator);\n         AST.Types constTypes; // all the Types that will need `const` applied to them\n@@ -2285,6 +2318,8 @@ final class CParser(AST) : Parser!AST\n                     const mod = cparseTypeQualifierList();\n                     if (mod & MOD.xconst)\n                         constTypes.push(t);\n+                    if (token.value == TOK.__attribute__)\n+                        cparseGnuAttributes(specifier);\n                     continue;\n \n                 default:\n@@ -2352,8 +2387,9 @@ final class CParser(AST) : Parser!AST\n                         }\n                         else\n                         {\n-                            // An array of unknown size, fake it with a DArray\n-                            ta = new AST.TypeDArray(t); // []\n+                            /* C11 6.7.6.2-4 An [ ] array is an incomplete array type\n+                             */\n+                            ta = new AST.TypeSArray(t);\n                         }\n                         check(TOK.rightBracket);\n \n@@ -2388,7 +2424,7 @@ final class CParser(AST) : Parser!AST\n                             /* C11 6.7.6.2-1: the element type shall not be an incomplete or\n                              * function type.\n                              */\n-                            if (ta.isTypeDArray() && !isVLA)\n+                            if (ta.isTypeSArray() && ta.isTypeSArray().isIncomplete() && !isVLA)\n                                 error(\"array type has incomplete element type `%s`\", ta.toChars());\n                         }\n \n@@ -2489,9 +2525,10 @@ final class CParser(AST) : Parser!AST\n     AST.Type cparseTypeName()\n     {\n         Specifier specifier;\n+        specifier.packalign.setDefault();\n         auto tspec = cparseSpecifierQualifierList(LVL.global, specifier);\n         Identifier id;\n-        return cparseDeclarator(DTR.xabstract, tspec, id);\n+        return cparseDeclarator(DTR.xabstract, tspec, id, specifier);\n     }\n \n     /***********************************\n@@ -2525,13 +2562,19 @@ final class CParser(AST) : Parser!AST\n         StorageClass varargsStc;\n \n         check(TOK.leftParenthesis);\n-        if (token.value == TOK.void_ && peekNext() == TOK.rightParenthesis)\n+        if (token.value == TOK.void_ && peekNext() == TOK.rightParenthesis) // func(void)\n         {\n             nextToken();\n             nextToken();\n             return AST.ParameterList(parameters, varargs, varargsStc);\n         }\n \n+        if (token.value == TOK.rightParenthesis)        // func()\n+        {\n+            nextToken();\n+            return AST.ParameterList(parameters, AST.VarArg.variadic, varargsStc);\n+        }\n+\n         /* The check for identifier-list comes later,\n          * when doing the trailing declaration-list (opt)\n          */\n@@ -2541,17 +2584,25 @@ final class CParser(AST) : Parser!AST\n                 break;\n             if (token.value == TOK.dotDotDot)\n             {\n+                if (parameters.length == 0)     // func(...)\n+                    error(\"named parameter required before `...`\");\n                 varargs = AST.VarArg.variadic;  // C-style variadics\n                 nextToken();\n                 check(TOK.rightParenthesis);\n                 return AST.ParameterList(parameters, varargs, varargsStc);\n             }\n \n             Specifier specifier;\n+            specifier.packalign.setDefault();\n             auto tspec = cparseDeclarationSpecifiers(LVL.prototype, specifier);\n+            if (tspec && specifier.mod & MOD.xconst)\n+            {\n+                tspec = toConst(tspec);\n+                specifier.mod = MOD.xnone;      // 'used' it\n+            }\n \n             Identifier id;\n-            auto t = cparseDeclarator(DTR.xparameter, tspec, id);\n+            auto t = cparseDeclarator(DTR.xparameter, tspec, id, specifier);\n             if (specifier.mod & MOD.xconst)\n                 t = toConst(t);\n             auto param = new AST.Parameter(STC.parameter, t, id, null, null);\n@@ -2920,6 +2971,7 @@ final class CParser(AST) : Parser!AST\n          *    enum gnu-attributes (opt) identifier\n          */\n         Specifier specifier;\n+        specifier.packalign.setDefault();\n         if (token.value == TOK.__attribute__)\n             cparseGnuAttributes(specifier);\n \n@@ -2950,6 +3002,16 @@ final class CParser(AST) : Parser!AST\n                 nextToken();\n                 auto mloc = token.loc;\n \n+                if (token.value == TOK.__attribute__)\n+                {\n+                    /* gnu-attributes can appear here, but just scan and ignore them\n+                     * https://gcc.gnu.org/onlinedocs/gcc/Enumerator-Attributes.html\n+                     */\n+                    Specifier specifierx;\n+                    specifierx.packalign.setDefault();\n+                    cparseGnuAttributes(specifierx);\n+                }\n+\n                 AST.Expression value;\n                 if (token.value == TOK.assign)\n                 {\n@@ -2958,6 +3020,16 @@ final class CParser(AST) : Parser!AST\n                     // TODO C11 6.7.2.2-2 value must fit into an int\n                 }\n \n+                if (token.value == TOK.__attribute__)\n+                {\n+                    /* gnu-attributes can appear here, but just scan and ignore them\n+                     * https://gcc.gnu.org/onlinedocs/gcc/Enumerator-Attributes.html\n+                     */\n+                    Specifier specifierx;\n+                    specifierx.packalign.setDefault();\n+                    cparseGnuAttributes(specifierx);\n+                }\n+\n                 auto em = new AST.EnumMember(mloc, ident, value, null, 0, null, null);\n                 members.push(em);\n \n@@ -3037,14 +3109,12 @@ final class CParser(AST) : Parser!AST\n             check(TOK.rightCurly);\n \n             if ((*members).length == 0) // C11 6.7.2.1-8\n-                /* TODO: not strict enough, should really be contains \"no named members\",\n-                 * not just \"no members\".\n-                 * I.e. an unnamed bit field, _Static_assert, etc, are not named members,\n-                 * but will pass this check.\n-                 * Be careful to detect named members that come anonymous structs.\n-                 * Correctly doing this will likely mean moving it to typesem.d.\n+            {\n+                /* allow empty structs as an extension\n+                 *  struct-declarator-list:\n+                 *    struct-declarator (opt)\n                  */\n-                error(\"empty struct-declaration-list for `%s %s`\", Token.toChars(structOrUnion), tag ? tag.toChars() : \"Anonymous\".ptr);\n+            }\n         }\n         else if (!tag)\n             error(\"missing tag `identifier` after `%s`\", Token.toChars(structOrUnion));\n@@ -3083,7 +3153,13 @@ final class CParser(AST) : Parser!AST\n \n         auto symbolsSave = symbols;\n         Specifier specifier;\n+        specifier.packalign = this.packalign;\n         auto tspec = cparseSpecifierQualifierList(LVL.member, specifier);\n+        if (tspec && specifier.mod & MOD.xconst)\n+        {\n+            tspec = toConst(tspec);\n+            specifier.mod = MOD.xnone;          // 'used' it\n+        }\n \n         /* If a declarator does not follow, it is unnamed\n          */\n@@ -3139,12 +3215,14 @@ final class CParser(AST) : Parser!AST\n                 dt = tspec;\n             }\n             else\n-                dt = cparseDeclarator(DTR.xdirect, tspec, id);\n-            if (!dt)\n             {\n-                panic();\n-                nextToken();\n-                break;          // error recovery\n+                dt = cparseDeclarator(DTR.xdirect, tspec, id, specifier);\n+                if (!dt)\n+                {\n+                    panic();\n+                    nextToken();\n+                    break;          // error recovery\n+                }\n             }\n \n             AST.Expression width;\n@@ -3155,9 +3233,6 @@ final class CParser(AST) : Parser!AST\n                 width = cparseConstantExp();\n             }\n \n-            if (specifier.mod & MOD.xconst)\n-                dt = toConst(dt);\n-\n             /* GNU Extensions\n              * struct-declarator:\n              *    declarator gnu-attributes (opt)\n@@ -3234,8 +3309,8 @@ final class CParser(AST) : Parser!AST\n      */\n     private bool isCDeclaration(ref Token* pt)\n     {\n-        //printf(\"isCDeclaration()\\n\");\n         auto t = pt;\n+        //printf(\"isCDeclaration() %s\\n\", t.toChars());\n         if (!isDeclarationSpecifiers(t))\n             return false;\n \n@@ -3360,8 +3435,8 @@ final class CParser(AST) : Parser!AST\n      */\n     private bool isAssignmentExpression(ref Token* pt)\n     {\n-        //printf(\"isAssignmentExpression()\\n\");\n         auto t = pt;\n+        //printf(\"isAssignmentExpression() %s\\n\", t.toChars());\n \n         /* This doesn't actually check for grammar matching an\n          * assignment-expression. It just matches ( ) [ ] looking for\n@@ -3384,13 +3459,27 @@ final class CParser(AST) : Parser!AST\n                 case TOK.leftParenthesis:\n                     if (!skipParens(t, &t))\n                         return false;\n+                    /*\n+                        https://issues.dlang.org/show_bug.cgi?id=22267\n+                        Fix issue 22267: If the parser encounters the following\n+                            `identifier variableName = (expression);`\n+                        the initializer is not identified as such since the parentheses\n+                        cause the parser to keep walking indefinitely\n+                        (whereas `(1) + 1` would not be affected.).\n+                    */\n+                    any = true;\n                     continue;\n \n                 case TOK.leftBracket:\n                     if (!skipBrackets(t))\n                         return false;\n                     continue;\n \n+                case TOK.leftCurly:\n+                    if (!skipBraces(t))\n+                        return false;\n+                    continue;\n+\n                 default:\n                     any = true;   // assume token was part of an a-e\n                     t = peek(t);\n@@ -3427,6 +3516,7 @@ final class CParser(AST) : Parser!AST\n \n         auto t = pt;\n \n+        bool seenType;\n         bool any;\n         while (1)\n         {\n@@ -3445,9 +3535,19 @@ final class CParser(AST) : Parser!AST\n                 case TOK._Bool:\n                 //case TOK._Imaginary:\n                 case TOK._Complex:\n-                case TOK.identifier: // typedef-name\n                     t = peek(t);\n+                    seenType = true;\n                     any = true;\n+                    continue;\n+\n+                case TOK.identifier: // typedef-name\n+                    if (!seenType)\n+                    {\n+                        t = peek(t);\n+                        seenType = true;\n+                        any = true;\n+                        continue;\n+                    }\n                     break;\n \n                 case TOK.struct_:\n@@ -3878,6 +3978,10 @@ final class CParser(AST) : Parser!AST\n                     t = tk;\n                     break;\n                 }\n+\n+                if (tk.value == TOK.leftParenthesis && peek(tk).value == TOK.rightParenthesis)\n+                    return false;    // (type-name)() is not a cast (it might be a function call)\n+\n                 if (!isCastExpression(tk, true))\n                 {\n                     if (afterParenType) // could be ( type-name ) ( unary-expression )\n@@ -4071,6 +4175,7 @@ final class CParser(AST) : Parser!AST\n         SCW scw;        /// storage-class specifiers\n         MOD mod;        /// type qualifiers\n         AST.Expressions*  alignExps;  /// alignment\n+        structalign_t packalign;  /// #pragma pack alignment value\n     }\n \n     /***********************\n@@ -4089,19 +4194,19 @@ final class CParser(AST) : Parser!AST\n             if (level == LVL.global)\n             {\n                 if (specifier.scw & SCW.xextern)\n-                   stc = AST.STC.extern_;\n+                    stc = AST.STC.extern_;\n             }\n             else if (level == LVL.local)\n             {\n                 if (specifier.scw & SCW.xextern)\n-                   stc = AST.STC.extern_;\n+                    stc = AST.STC.extern_;\n                 else if (specifier.scw & SCW.xstatic)\n                     stc = AST.STC.static_;\n             }\n             else if (level == LVL.member)\n             {\n                 if (specifier.scw & SCW.xextern)\n-                   stc = AST.STC.extern_;\n+                    stc = AST.STC.extern_;\n                 else if (specifier.scw & SCW.xstatic)\n                     stc = AST.STC.static_;\n             }\n@@ -4111,21 +4216,23 @@ final class CParser(AST) : Parser!AST\n             if (level == LVL.global)\n             {\n                 if (specifier.scw & SCW.xextern)\n-                   stc = AST.STC.extern_ | AST.STC.gshared;\n+                    stc = AST.STC.extern_ | AST.STC.gshared;\n+                else if (specifier.scw & SCW.xstatic)\n+                    stc = AST.STC.gshared | AST.STC.static_;\n                 else\n                     stc = AST.STC.gshared;\n             }\n             else if (level == LVL.local)\n             {\n                 if (specifier.scw & SCW.xextern)\n-                   stc = AST.STC.extern_ | AST.STC.gshared;\n+                    stc = AST.STC.extern_ | AST.STC.gshared;\n                 else if (specifier.scw & SCW.xstatic)\n                     stc = AST.STC.gshared;\n             }\n             else if (level == LVL.member)\n             {\n                 if (specifier.scw & SCW.xextern)\n-                   stc = AST.STC.extern_ | AST.STC.gshared;\n+                    stc = AST.STC.extern_ | AST.STC.gshared;\n                 else if (specifier.scw & SCW.xstatic)\n                     stc = AST.STC.gshared;\n             }\n@@ -4235,15 +4342,59 @@ final class CParser(AST) : Parser!AST\n      */\n     private AST.Dsymbol applySpecifier(AST.Dsymbol s, ref Specifier specifier)\n     {\n+        //printf(\"applySpecifier() %s\\n\", s.toChars());\n         if (specifier.alignExps)\n         {\n+            //printf(\"  applying _Alignas %s, packalign %d\\n\", (*specifier.alignExps)[0].toChars(), cast(int)specifier.packalign);\n             // Wrap declaration in an AlignDeclaration\n             auto decls = new AST.Dsymbols(1);\n             (*decls)[0] = s;\n             s = new AST.AlignDeclaration(s.loc, specifier.alignExps, decls);\n         }\n+        else if (!specifier.packalign.isDefault())\n+        {\n+            //printf(\"  applying packalign %d\\n\", cast(int)specifier.packalign);\n+            // Wrap #pragma pack in an AlignDeclaration\n+            auto decls = new AST.Dsymbols(1);\n+            (*decls)[0] = s;\n+            s = new AST.AlignDeclaration(s.loc, specifier.packalign, decls);\n+        }\n         return s;\n     }\n \n+    /***********************************\n+     * Add global target-dependent builtin declarations.\n+     */\n+    private void addBuiltinDeclarations()\n+    {\n+        void genBuiltinFunc(Identifier id, AST.VarArg va)\n+        {\n+            auto tva_list = new AST.TypeIdentifier(Loc.initial, Id.builtin_va_list);\n+            auto parameters = new AST.Parameters();\n+            parameters.push(new AST.Parameter(STC.parameter | STC.ref_, tva_list, null, null, null));\n+            auto pl = AST.ParameterList(parameters, va, 0);\n+            auto tf = new AST.TypeFunction(pl, AST.Type.tvoid, LINK.c, 0);\n+            auto s = new AST.FuncDeclaration(Loc.initial, Loc.initial, id, AST.STC.static_, tf, false);\n+            symbols.push(s);\n+        }\n+\n+        /* void __builtin_va_start(__builtin_va_list, ...);\n+         * The second argument is supposed to be of any type, so fake it with the ...\n+         */\n+        genBuiltinFunc(Id.builtin_va_start, AST.VarArg.variadic);\n+\n+        /* void __builtin_va_end(__builtin_va_list);\n+         */\n+        genBuiltinFunc(Id.builtin_va_end, AST.VarArg.none);\n+\n+        /* struct __va_list_tag\n+         * {\n+         *    uint, uint, void*, void*\n+         * }\n+         */\n+        auto s = new AST.StructDeclaration(Loc.initial, Id.va_list_tag, false);\n+        symbols.push(s);\n+    }\n+\n     //}\n }"}, {"sha": "df742c0bd8f7f814ccc8585463e0a0a0505ef88f", "filename": "gcc/d/dmd/cppmangle.d", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fcppmangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fcppmangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcppmangle.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -41,7 +41,7 @@ import dmd.identifier;\n import dmd.mtype;\n import dmd.nspace;\n import dmd.root.array;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.root.rootobject;\n import dmd.root.string;\n import dmd.target;\n@@ -98,21 +98,20 @@ extern(C++) const(char)* cppThunkMangleItanium(FuncDeclaration fd, int offset)\n }\n \n /******************************\n- * Determine if sym is the 'primary' destructor, that is,\n- * the most-aggregate destructor (the one that is defined as __xdtor)\n+ * Determine if sym is a full aggregate destructor.\n  * Params:\n  *      sym = Dsymbol\n  * Returns:\n- *      true if sym is the primary destructor for an aggregate\n+ *      true if sym is an aggregate destructor\n  */\n-bool isPrimaryDtor(const Dsymbol sym)\n+bool isAggregateDtor(const Dsymbol sym)\n {\n     const dtor = sym.isDtorDeclaration();\n     if (!dtor)\n         return false;\n     const ad = dtor.isMember();\n     assert(ad);\n-    return dtor == ad.primaryDtor;\n+    return dtor == ad.aggrDtor;\n }\n \n /// Context used when processing pre-semantic AST\n@@ -1069,7 +1068,7 @@ private final class CppMangleVisitor : Visitor\n \n             if (auto ctor = d.isCtorDeclaration())\n                 buf.writestring(ctor.isCpCtor ? \"C2\" : \"C1\");\n-            else if (d.isPrimaryDtor())\n+            else if (d.isAggregateDtor())\n                 buf.writestring(\"D1\");\n             else if (d.ident && d.ident == Id.assign)\n                 buf.writestring(\"aS\");\n@@ -1184,7 +1183,7 @@ private final class CppMangleVisitor : Visitor\n             mangleFunctionParameters(tf.parameterList);\n             return;\n         }\n-        else if (d.isPrimaryDtor())\n+        else if (d.isAggregateDtor())\n         {\n             buf.writestring(\"D1\");\n             mangleFunctionParameters(tf.parameterList);"}, {"sha": "7f76d7565e0d0db834b6c208720843017cddab68", "filename": "gcc/d/dmd/ctfeexpr.d", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fctfeexpr.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fctfeexpr.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fctfeexpr.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -685,6 +685,11 @@ bool isSafePointerCast(Type srcPointee, Type destPointee)\n     // It's OK if both are the same (modulo const)\n     if (srcPointee.constConv(destPointee))\n         return true;\n+\n+    // It's ok to cast from/to shared because CTFE is single threaded anyways\n+    if (srcPointee.unSharedOf() == destPointee.unSharedOf())\n+        return true;\n+\n     // It's OK if function pointers differ only in safe/pure/nothrow\n     if (srcPointee.ty == Tfunction && destPointee.ty == Tfunction)\n         return srcPointee.covariant(destPointee) == Covariant.yes ||"}, {"sha": "87c3adae9e60ef90ceaee4a0038b576b7b2c1b5e", "filename": "gcc/d/dmd/dcast.d", "status": "modified", "additions": 103, "deletions": 33, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdcast.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdcast.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdcast.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -31,12 +31,13 @@ import dmd.func;\n import dmd.globals;\n import dmd.impcnvtab;\n import dmd.id;\n+import dmd.importc;\n import dmd.init;\n import dmd.intrange;\n import dmd.mtype;\n import dmd.opover;\n import dmd.root.ctfloat;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.root.rmem;\n import dmd.tokens;\n import dmd.typesem;\n@@ -1445,6 +1446,29 @@ MATCH implicitConvTo(Expression e, Type t)\n             if (tb.ty == Tpointer && e.e1.op == TOK.string_)\n                 e.e1.accept(this);\n         }\n+\n+        override void visit(TupleExp e)\n+        {\n+            result = e.type.implicitConvTo(t);\n+            if (result != MATCH.nomatch)\n+                return;\n+\n+            /* If target type is a tuple of same length, test conversion of\n+             * each expression to the corresponding type in the tuple.\n+             */\n+            TypeTuple totuple = t.isTypeTuple();\n+            if (totuple && e.exps.length == totuple.arguments.length)\n+            {\n+                result = MATCH.exact;\n+                foreach (i, ex; *e.exps)\n+                {\n+                    auto to = (*totuple.arguments)[i].type;\n+                    MATCH mi = ex.implicitConvTo(to);\n+                    if (mi < result)\n+                        result = mi;\n+                }\n+            }\n+        }\n     }\n \n     scope ImplicitConvTo v = new ImplicitConvTo(t);\n@@ -1476,12 +1500,8 @@ MATCH cimplicitConvTo(Expression e, Type t)\n         return MATCH.convert;\n     if (tb.isintegral() && typeb.ty == Tpointer) // C11 6.3.2.3-6\n         return MATCH.convert;\n-    if (tb.ty == Tpointer && typeb.ty == Tpointer)\n-    {\n-        if (tb.isTypePointer().next.ty == Tvoid ||\n-            typeb.isTypePointer().next.ty == Tvoid)\n-            return MATCH.convert;       // convert to/from void* C11 6.3.2.3-1\n-    }\n+    if (tb.ty == Tpointer && typeb.ty == Tpointer) // C11 6.3.2.3-7\n+        return MATCH.convert;\n \n     return implicitConvTo(e, t);\n }\n@@ -2189,13 +2209,20 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n                 return;\n             }\n \n+            /* If target type is a tuple of same length, cast each expression to\n+             * the corresponding type in the tuple.\n+             */\n+            TypeTuple totuple;\n+            if (auto tt = t.isTypeTuple())\n+                totuple = e.exps.length == tt.arguments.length ? tt : null;\n+\n             TupleExp te = e.copy().isTupleExp();\n             te.e0 = e.e0 ? e.e0.copy() : null;\n             te.exps = e.exps.copy();\n             for (size_t i = 0; i < te.exps.dim; i++)\n             {\n                 Expression ex = (*te.exps)[i];\n-                ex = ex.castTo(sc, t);\n+                ex = ex.castTo(sc, totuple ? (*totuple.arguments)[i].type : t);\n                 (*te.exps)[i] = ex;\n             }\n             result = te;\n@@ -2821,6 +2848,13 @@ Type typeMerge(Scope* sc, TOK op, ref Expression pe1, ref Expression pe2)\n     Expression e1 = pe1;\n     Expression e2 = pe2;\n \n+    // ImportC: do array/function conversions\n+    if (sc)\n+    {\n+        e1 = e1.arrayFuncConv(sc);\n+        e2 = e2.arrayFuncConv(sc);\n+    }\n+\n     Type Lret(Type result)\n     {\n         pe1 = e1;\n@@ -2838,7 +2872,7 @@ Type typeMerge(Scope* sc, TOK op, ref Expression pe1, ref Expression pe2)\n         return result;\n     }\n \n-    /// Converts one of the expression too the other\n+    /// Converts one of the expression to the other\n     Type convert(ref Expression from, Type to)\n     {\n         from = from.castTo(sc, to);\n@@ -2856,6 +2890,22 @@ Type typeMerge(Scope* sc, TOK op, ref Expression pe1, ref Expression pe2)\n     Type t1b = e1.type.toBasetype();\n     Type t2b = e2.type.toBasetype();\n \n+    if (sc && sc.flags & SCOPE.Cfile)\n+    {\n+        // Integral types can be implicitly converted to pointers\n+        if ((t1b.ty == Tpointer) != (t2b.ty == Tpointer))\n+        {\n+            if (t1b.isintegral())\n+            {\n+                return convert(e1, t2b);\n+            }\n+            else if (t2b.isintegral())\n+            {\n+                return convert(e2, t1b);\n+            }\n+        }\n+    }\n+\n     if (op != TOK.question || t1b.ty != t2b.ty && (t1b.isTypeBasic() && t2b.isTypeBasic()))\n     {\n         if (op == TOK.question && t1b.ty.isSomeChar() && t2b.ty.isSomeChar())\n@@ -3132,6 +3182,14 @@ Lagain:\n     Lcc:\n         while (1)\n         {\n+            MATCH i1woat = MATCH.exact;\n+            MATCH i2woat = MATCH.exact;\n+\n+            if (auto t2c = t2.isTypeClass())\n+                i1woat = t2c.implicitConvToWithoutAliasThis(t1);\n+            if (auto t1c = t1.isTypeClass())\n+                i2woat = t1c.implicitConvToWithoutAliasThis(t2);\n+\n             MATCH i1 = e2.implicitConvTo(t1);\n             MATCH i2 = e1.implicitConvTo(t2);\n \n@@ -3144,11 +3202,26 @@ Lagain:\n                     i2 = MATCH.nomatch;\n             }\n \n-            if (i2)\n+            // Match but without 'alias this' on classes\n+            if (i2 && i2woat)\n                 return coerce(t2);\n-            if (i1)\n+            if (i1 && i1woat)\n                 return coerce(t1);\n \n+            // Here use implicitCastTo() instead of castTo() to try 'alias this' on classes\n+            Type coerceImplicit(Type towards)\n+            {\n+                e1 = e1.implicitCastTo(sc, towards);\n+                e2 = e2.implicitCastTo(sc, towards);\n+                return Lret(towards);\n+            }\n+\n+            // Implicit conversion with 'alias this'\n+            if (i2)\n+                return coerceImplicit(t2);\n+            if (i1)\n+                return coerceImplicit(t1);\n+\n             if (t1.ty == Tclass && t2.ty == Tclass)\n             {\n                 TypeClass tc1 = t1.isTypeClass();\n@@ -3257,29 +3330,26 @@ Lagain:\n         }\n     }\n \n-    if (t1.ty == Tstruct || t2.ty == Tstruct)\n+    if (t1.ty == Tstruct && t1.isTypeStruct().sym.aliasthis)\n     {\n-        if (t1.ty == Tstruct && t1.isTypeStruct().sym.aliasthis)\n-        {\n-            if (isRecursiveAliasThis(att1, e1.type))\n-                return null;\n-            //printf(\"att tmerge(s || s) e1 = %s\\n\", e1.type.toChars());\n-            e1 = resolveAliasThis(sc, e1);\n-            t1 = e1.type;\n-            t = t1;\n-            goto Lagain;\n-        }\n-        if (t2.ty == Tstruct && t2.isTypeStruct().sym.aliasthis)\n-        {\n-            if (isRecursiveAliasThis(att2, e2.type))\n-                return null;\n-            //printf(\"att tmerge(s || s) e2 = %s\\n\", e2.type.toChars());\n-            e2 = resolveAliasThis(sc, e2);\n-            t2 = e2.type;\n-            t = t2;\n-            goto Lagain;\n-        }\n-        return null;\n+        if (isRecursiveAliasThis(att1, e1.type))\n+            return null;\n+        //printf(\"att tmerge(s || s) e1 = %s\\n\", e1.type.toChars());\n+        e1 = resolveAliasThis(sc, e1);\n+        t1 = e1.type;\n+        t = t1;\n+        goto Lagain;\n+    }\n+\n+    if (t2.ty == Tstruct && t2.isTypeStruct().sym.aliasthis)\n+    {\n+        if (isRecursiveAliasThis(att2, e2.type))\n+            return null;\n+        //printf(\"att tmerge(s || s) e2 = %s\\n\", e2.type.toChars());\n+        e2 = resolveAliasThis(sc, e2);\n+        t2 = e2.type;\n+        t = t2;\n+        goto Lagain;\n     }\n \n     if ((e1.op == TOK.string_ || e1.op == TOK.null_) && e1.implicitConvTo(t2))"}, {"sha": "34a236ba26e7a5661d124a005afc69633b3208b2", "filename": "gcc/d/dmd/dclass.d", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdclass.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdclass.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdclass.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -20,6 +20,7 @@ import dmd.aggregate;\n import dmd.apply;\n import dmd.arraytypes;\n import dmd.astenums;\n+import dmd.attrib;\n import dmd.gluelayer;\n import dmd.declaration;\n import dmd.dscope;\n@@ -367,7 +368,7 @@ extern (C++) class ClassDeclaration : AggregateDeclaration\n         baseok = Baseok.none;\n     }\n \n-    static ClassDeclaration create(Loc loc, Identifier id, BaseClasses* baseclasses, Dsymbols* members, bool inObject)\n+    static ClassDeclaration create(const ref Loc loc, Identifier id, BaseClasses* baseclasses, Dsymbols* members, bool inObject)\n     {\n         return new ClassDeclaration(loc, id, baseclasses, members, inObject);\n     }\n@@ -607,7 +608,7 @@ extern (C++) class ClassDeclaration : AggregateDeclaration\n \n                 if (!b.sym.alignsize)\n                     b.sym.alignsize = target.ptrsize;\n-                alignmember(b.sym.alignsize, b.sym.alignsize, &offset);\n+                alignmember(structalign_t(cast(ushort)b.sym.alignsize), b.sym.alignsize, &offset);\n                 assert(bi < vtblInterfaces.dim);\n \n                 BaseClass* bv = (*vtblInterfaces)[bi];\n@@ -725,6 +726,7 @@ extern (C++) class ClassDeclaration : AggregateDeclaration\n \n         void searchVtbl(ref Dsymbols vtbl)\n         {\n+            bool seenInterfaceVirtual;\n             foreach (s; vtbl)\n             {\n                 auto fd = s.isFuncDeclaration();\n@@ -748,6 +750,23 @@ extern (C++) class ClassDeclaration : AggregateDeclaration\n                 if (fd == fdmatch)\n                     continue;\n \n+                /* Functions overriding interface functions for extern(C++) with VC++\n+                 * are not in the normal vtbl, but in vtblFinal. If the implementation\n+                 * is again overridden in a child class, both would be found here.\n+                 * The function in the child class should override the function\n+                 * in the base class, which is done here, because searchVtbl is first\n+                 * called for the child class. Checking seenInterfaceVirtual makes\n+                 * sure, that the compared functions are not in the same vtbl.\n+                 */\n+                if (fd.interfaceVirtual &&\n+                    fd.interfaceVirtual is fdmatch.interfaceVirtual &&\n+                    !seenInterfaceVirtual &&\n+                    fdmatch.type.covariant(fd.type) == Covariant.yes)\n+                {\n+                    seenInterfaceVirtual = true;\n+                    continue;\n+                }\n+\n                 {\n                 // Function type matching: exact > covariant\n                 MATCH m1 = tf.equals(fd.type) ? MATCH.exact : MATCH.nomatch;"}, {"sha": "e3f135a03d8b8bbc93da86d63a694c0458c1a117", "filename": "gcc/d/dmd/declaration.d", "status": "modified", "additions": 132, "deletions": 29, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdeclaration.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdeclaration.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -16,6 +16,7 @@ import core.stdc.stdio;\n import dmd.aggregate;\n import dmd.arraytypes;\n import dmd.astenums;\n+import dmd.attrib;\n import dmd.ctorflow;\n import dmd.dclass;\n import dmd.delegatize;\n@@ -34,7 +35,7 @@ import dmd.init;\n import dmd.initsem;\n import dmd.intrange;\n import dmd.mtype;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.root.rootobject;\n import dmd.target;\n import dmd.tokens;\n@@ -705,7 +706,7 @@ extern (C++) final class AliasDeclaration : Declaration\n         assert(s);\n     }\n \n-    static AliasDeclaration create(Loc loc, Identifier id, Type type)\n+    static AliasDeclaration create(const ref Loc loc, Identifier id, Type type)\n     {\n         return new AliasDeclaration(loc, id, type);\n     }\n@@ -1192,14 +1193,7 @@ extern (C++) class VarDeclaration : Declaration\n         /* If coming after a bit field in progress,\n          * advance past the field\n          */\n-        if (fieldState.inFlight)\n-        {\n-            fieldState.inFlight = false;\n-            if (0 && target.os & Target.OS.Posix)\n-                fieldState.offset += (fieldState.bitOffset + 7) / 8;\n-            else if (0 &&target.os == Target.OS.Windows)\n-                fieldState.offset += fieldState.fieldSize;\n-        }\n+        fieldState.inFlight = false;\n \n         const sz = t.size(loc);\n         assert(sz != SIZE_INVALID && sz < uint.max);\n@@ -1743,13 +1737,23 @@ extern (C++) class BitFieldDeclaration : VarDeclaration\n \n     override final void setFieldOffset(AggregateDeclaration ad, ref FieldState fieldState, bool isunion)\n     {\n-        //printf(\"BitFieldDeclaration::setFieldOffset(ad = %s) %s\\n\", ad.toChars(), toChars());\n+        //printf(\"BitFieldDeclaration::setFieldOffset(ad: %s, field: %s)\\n\", ad.toChars(), toChars());\n+        static void print(const ref FieldState fieldState)\n+        {\n+            printf(\"FieldState.offset      = %d bytes\\n\",   fieldState.offset);\n+            printf(\"          .fieldOffset = %d bytes\\n\",   fieldState.fieldOffset);\n+            printf(\"          .bitOffset   = %d bits\\n\",    fieldState.bitOffset);\n+            printf(\"          .fieldSize   = %d bytes\\n\",   fieldState.fieldSize);\n+            printf(\"          .inFlight    = %d\\n\\n\", fieldState.inFlight);\n+        }\n+        //print(fieldState);\n \n         Type t = type.toBasetype();\n+        const bool anon = isAnonymous();\n \n         // List in ad.fields. Even if the type is error, it's necessary to avoid\n         // pointless error diagnostic \"more initializers than fields\" on struct literal.\n-        if (!isAnonymous())\n+        if (!anon)\n             ad.fields.push(this);\n \n         if (t.ty == Terror)\n@@ -1760,17 +1764,36 @@ extern (C++) class BitFieldDeclaration : VarDeclaration\n         uint memsize = cast(uint)sz;                // size of member\n         uint memalignsize = target.fieldalign(t);   // size of member for alignment purposes\n \n-        if (fieldWidth == 0 && !isAnonymous())\n+        if (fieldWidth == 0 && !anon)\n             error(loc, \"named bit fields cannot have 0 width\");\n         if (fieldWidth > memsize * 8)\n             error(loc, \"bit field width %d is larger than type\", fieldWidth);\n \n+        const style = target.c.bitFieldStyle;\n+\n         void startNewField()\n         {\n+            uint alignsize;\n+            if (style == TargetC.BitFieldStyle.Gcc_Clang)\n+            {\n+                if (fieldWidth > 32)\n+                    alignsize = memalignsize;\n+                else if (fieldWidth > 16)\n+                    alignsize = 4;\n+                else if (fieldWidth > 8)\n+                    alignsize = 2;\n+                else\n+                    alignsize = 1;\n+            }\n+            else\n+                alignsize = memsize; // not memalignsize\n+\n+            uint dummy;\n             offset = AggregateDeclaration.placeField(\n                 &fieldState.offset,\n-                memsize, memalignsize, alignment,\n-                &ad.structsize, &ad.alignsize,\n+                memsize, alignsize, alignment,\n+                &ad.structsize,\n+                (anon && style == TargetC.BitFieldStyle.Gcc_Clang) ? &dummy : &ad.alignsize,\n                 isunion);\n \n             fieldState.inFlight = true;\n@@ -1779,42 +1802,122 @@ extern (C++) class BitFieldDeclaration : VarDeclaration\n             fieldState.fieldSize = memsize;\n         }\n \n-        if (!fieldState.inFlight || fieldWidth == 0)\n+        if (style == TargetC.BitFieldStyle.Gcc_Clang)\n         {\n-            startNewField();\n+            if (fieldWidth == 0)\n+            {\n+                if (!isunion)\n+                {\n+                    // Use type of zero width field to align to next field\n+                    fieldState.offset = (fieldState.offset + memalignsize - 1) & ~(memalignsize - 1);\n+                    ad.structsize = fieldState.offset;\n+                }\n+\n+                fieldState.inFlight = false;\n+                return;\n+            }\n+\n+            if (ad.alignsize == 0)\n+                ad.alignsize = 1;\n+            if (!anon &&\n+                  ad.alignsize < memalignsize)\n+                ad.alignsize = memalignsize;\n+        }\n+        else if (style == TargetC.BitFieldStyle.MS)\n+        {\n+            if (ad.alignsize == 0)\n+                ad.alignsize = 1;\n+            if (fieldWidth == 0)\n+            {\n+                if (fieldState.inFlight && !isunion)\n+                {\n+                    // documentation says align to next int\n+                    //const alsz = cast(uint)Type.tint32.size();\n+                    const alsz = memsize; // but it really does this\n+                    fieldState.offset = (fieldState.offset + alsz - 1) & ~(alsz - 1);\n+                    ad.structsize = fieldState.offset;\n+                }\n+\n+                fieldState.inFlight = false;\n+                return;\n+            }\n+        }\n+        else if (style == TargetC.BitFieldStyle.DM)\n+        {\n+            if (anon && fieldWidth && (!fieldState.inFlight || fieldState.bitOffset == 0))\n+                return;  // this probably should be a bug in DMC\n+            if (ad.alignsize == 0)\n+                ad.alignsize = 1;\n+            if (fieldWidth == 0)\n+            {\n+                if (fieldState.inFlight && !isunion)\n+                {\n+                    const alsz = memsize;\n+                    fieldState.offset = (fieldState.offset + alsz - 1) & ~(alsz - 1);\n+                    ad.structsize = fieldState.offset;\n+                }\n+\n+                fieldState.inFlight = false;\n+                return;\n+            }\n         }\n \n-        if (0 && target.os & Target.OS.Posix)\n+        if (!fieldState.inFlight)\n+        {\n+            startNewField();\n+        }\n+        else if (style == TargetC.BitFieldStyle.Gcc_Clang)\n         {\n-            if ((fieldState.offset%4 * 8) + fieldState.bitOffset + fieldWidth > int.sizeof * 8)\n+            if (fieldState.bitOffset + fieldWidth > memsize * 8)\n             {\n+                //printf(\"start1 fieldState.bitOffset:%u fieldWidth:%u memsize:%u\\n\", fieldState.bitOffset, fieldWidth, memsize);\n                 startNewField();\n             }\n+            else\n+            {\n+                // if alignment boundary is crossed\n+                uint start = fieldState.fieldOffset * 8 + fieldState.bitOffset;\n+                uint end   = start + fieldWidth;\n+                //printf(\"%s start: %d end: %d memalignsize: %d\\n\", ad.toChars(), start, end, memalignsize);\n+                if (start / (memalignsize * 8) != (end - 1) / (memalignsize * 8))\n+                {\n+                    //printf(\"alignment is crossed\\n\");\n+                    startNewField();\n+                }\n+            }\n         }\n-        else if (1 || target.os == Target.OS.Windows)\n+        else if (style == TargetC.BitFieldStyle.DM ||\n+                 style == TargetC.BitFieldStyle.MS)\n         {\n             if (memsize != fieldState.fieldSize ||\n                 fieldState.bitOffset + fieldWidth > fieldState.fieldSize * 8)\n             {\n                 startNewField();\n             }\n         }\n+        else\n+            assert(0);\n \n         offset = fieldState.fieldOffset;\n         bitOffset = fieldState.bitOffset;\n-        if (0 && target.os & Target.OS.Posix)\n+\n+        const pastField = bitOffset + fieldWidth;\n+        if (style == TargetC.BitFieldStyle.Gcc_Clang)\n         {\n-            while (bitOffset > memsize * 8)\n-            {\n-                bitOffset -= 8;\n-                offset += 1;\n-            }\n+            auto size = (pastField + 7) / 8;\n+            fieldState.fieldSize = size;\n+            //printf(\" offset: %d, size: %d\\n\", offset, size);\n+            ad.structsize = offset + size;\n         }\n+        else\n+            fieldState.fieldSize = memsize;\n+        //printf(\"at end: ad.structsize = %d\\n\", cast(int)ad.structsize);\n+        //print(fieldState);\n \n-        //fieldState.fieldSize = memsize;\n         if (!isunion)\n         {\n-            fieldState.bitOffset += fieldWidth;\n+            fieldState.offset = offset + fieldState.fieldSize;\n+            fieldState.bitOffset = pastField;\n         }\n \n         //printf(\"\\t%s: memalignsize = %d\\n\", toChars(), memalignsize);\n@@ -1861,7 +1964,7 @@ extern (C++) class TypeInfoDeclaration : VarDeclaration\n         storage_class = STC.static_ | STC.gshared;\n         visibility = Visibility(Visibility.Kind.public_);\n         linkage = LINK.c;\n-        alignment = target.ptrsize;\n+        alignment.set(target.ptrsize);\n     }\n \n     static TypeInfoDeclaration create(Type tinfo)"}, {"sha": "4a4c35304177c3a62b84f3281ec9353165a86e19", "filename": "gcc/d/dmd/declaration.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdeclaration.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdeclaration.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.h?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -188,7 +188,7 @@ class AliasDeclaration : public Declaration\n     Dsymbol *overnext;          // next in overload list\n     Dsymbol *_import;           // !=NULL if unresolved internal alias for selective import\n \n-    static AliasDeclaration *create(Loc loc, Identifier *id, Type *type);\n+    static AliasDeclaration *create(const Loc &loc, Identifier *id, Type *type);\n     AliasDeclaration *syntaxCopy(Dsymbol *);\n     bool overloadInsert(Dsymbol *s);\n     const char *kind() const;\n@@ -511,7 +511,7 @@ enum class BUILTIN : unsigned char\n     toPrecReal\n };\n \n-Expression *eval_builtin(Loc loc, FuncDeclaration *fd, Expressions *arguments);\n+Expression *eval_builtin(const Loc &loc, FuncDeclaration *fd, Expressions *arguments);\n BUILTIN isBuiltin(FuncDeclaration *fd);\n \n class FuncDeclaration : public Declaration\n@@ -535,6 +535,8 @@ class FuncDeclaration : public Declaration\n     VarDeclaration *vresult;            // result variable for out contracts\n     LabelDsymbol *returnLabel;          // where the return goes\n \n+    void *isTypeIsolatedCache;          // An AA on the D side to cache an expensive check result\n+\n     // used to prevent symbols in different\n     // scopes from having the same name\n     DsymbolTable *localsymtab;\n@@ -839,9 +841,6 @@ class UnitTestDeclaration : public FuncDeclaration\n class NewDeclaration : public FuncDeclaration\n {\n public:\n-    Parameters *parameters;\n-    VarArg varargs;\n-\n     NewDeclaration *syntaxCopy(Dsymbol *);\n     const char *kind() const;\n     bool isVirtual() const;"}, {"sha": "a1f36c0c48f9259e9f7a8a8bde479d65ec1ec9a1", "filename": "gcc/d/dmd/dinterpret.d", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdinterpret.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdinterpret.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdinterpret.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -42,6 +42,7 @@ import dmd.mtype;\n import dmd.printast;\n import dmd.root.rmem;\n import dmd.root.array;\n+import dmd.root.ctfloat;\n import dmd.root.region;\n import dmd.root.rootobject;\n import dmd.statement;\n@@ -75,6 +76,7 @@ public Expression ctfeInterpret(Expression e)\n         case TOK.template_:              // non-eponymous template/instance\n         case TOK.scope_:                 // ditto\n         case TOK.dotTemplateDeclaration: // ditto, e.e1 doesn't matter here\n+        case TOK.dotTemplateInstance:    // ditto\n         case TOK.dot:                    // ditto\n              if (e.type.ty == Terror)\n                 return ErrorExp.get();\n@@ -2167,26 +2169,20 @@ public:\n             return;\n         }\n \n-        // Note: This is a workaround for\n-        // https://issues.dlang.org/show_bug.cgi?id=17351\n-        // The aforementioned bug triggers when passing manifest constant by `ref`.\n-        // If there was not a previous reference to them, they are\n-        // not cached and trigger a \"cannot be read at compile time\".\n-        // This fix is a crude solution to get it to work. A more proper\n-        // approach would be to resolve the forward reference, but that is\n-        // much more involved.\n-        if (goal == CTFEGoal.LValue && e.var.type.isMutable())\n+        if (goal == CTFEGoal.LValue)\n         {\n             if (auto v = e.var.isVarDeclaration())\n             {\n-                if (!v.isDataseg() && !v.isCTFE() && !istate)\n-                {\n-                    e.error(\"variable `%s` cannot be read at compile time\", v.toChars());\n-                    result = CTFEExp.cantexp;\n-                    return;\n-                }\n                 if (!hasValue(v))\n                 {\n+                    // Compile-time known non-CTFE variable from an outer context\n+                    // e.g. global or from a ref argument\n+                    if (v.isConst() || v.isImmutable())\n+                    {\n+                        result = getVarExp(e.loc, istate, v, goal);\n+                        return;\n+                    }\n+\n                     if (!v.isCTFE() && v.isDataseg())\n                         e.error(\"static variable `%s` cannot be read at compile time\", v.toChars());\n                     else // CTFE initiated from inside a function\n@@ -2201,7 +2197,7 @@ public:\n                     Expression ev = getValue(v);\n                     if (ev.op == TOK.variable ||\n                         ev.op == TOK.index ||\n-                        ev.op == TOK.slice ||\n+                        (ev.op == TOK.slice && ev.type.toBasetype().ty == Tsarray) ||\n                         ev.op == TOK.dotVariable)\n                     {\n                         result = interpret(pue, ev, istate, goal);\n@@ -2836,8 +2832,7 @@ public:\n             auto se = ctfeEmplaceExp!StructLiteralExp(e.loc, cast(StructDeclaration)cd, elems, e.newtype);\n             se.origin = se;\n             se.ownedByCtfe = OwnedBy.ctfe;\n-            emplaceExp!(ClassReferenceExp)(pue, e.loc, se, e.type);\n-            Expression eref = pue.exp();\n+            Expression eref = ctfeEmplaceExp!ClassReferenceExp(e.loc, se, e.type);\n             if (e.member)\n             {\n                 // Call constructor\n@@ -6024,12 +6019,23 @@ public:\n         }\n         if (e.to.ty == Tsarray)\n             e1 = resolveSlice(e1);\n-        if (e.to.toBasetype().ty == Tbool && e1.type.ty == Tpointer)\n+\n+        auto tobt = e.to.toBasetype();\n+        if (tobt.ty == Tbool && e1.type.ty == Tpointer)\n         {\n             emplaceExp!(IntegerExp)(pue, e.loc, e1.op != TOK.null_, e.to);\n             result = pue.exp();\n             return;\n         }\n+        else if (tobt.isTypeBasic() && e1.op == TOK.null_)\n+        {\n+            if (tobt.isintegral())\n+                emplaceExp!(IntegerExp)(pue, e.loc, 0, e.to);\n+            else if (tobt.isreal())\n+                emplaceExp!(RealExp)(pue, e.loc, CTFloat.zero, e.to);\n+            result = pue.exp();\n+            return;\n+        }\n         result = ctfeCast(pue, e.loc, e.type, e.to, e1);\n     }\n \n@@ -6306,7 +6312,7 @@ public:\n             auto tsa = cast(TypeSArray)v.type;\n             auto len = cast(size_t)tsa.dim.toInteger();\n             UnionExp ue = void;\n-            result = createBlockDuplicatedArrayLiteral(&ue, ex.loc, v.type, ex, len);\n+            result = createBlockDuplicatedArrayLiteral(&ue, e.loc, v.type, result, len);\n             if (result == ue.exp())\n                 result = ue.copy();\n             (*se.elements)[i] = result;"}, {"sha": "357f7bdcd9fda4b400093d54997cfd9a7dfbbcdb", "filename": "gcc/d/dmd/dmacro.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdmacro.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdmacro.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmacro.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -16,7 +16,7 @@ import core.stdc.string;\n import dmd.doc;\n import dmd.errors;\n import dmd.globals;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.root.rmem;\n \n extern (C++) struct MacroTable"}, {"sha": "c417f93c353b9dd2c71a658359aff4b6c0dea3bf", "filename": "gcc/d/dmd/dmangle.d", "status": "modified", "additions": 44, "deletions": 9, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdmangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdmangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmangle.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -139,7 +139,7 @@ import dmd.id;\n import dmd.identifier;\n import dmd.mtype;\n import dmd.root.ctfloat;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.root.aav;\n import dmd.root.string;\n import dmd.root.stringtable;\n@@ -1259,14 +1259,49 @@ public:\n \n     override void visit(Parameter p)\n     {\n-        if (p.storageClass & STC.scope_ && !(p.storageClass & STC.scopeinferred))\n-            buf.writeByte('M');\n+        // https://dlang.org/spec/abi.html#Parameter\n+\n+        auto stc = p.storageClass;\n+\n+        // Inferred storage classes don't get mangled in\n+        if (stc & STC.scopeinferred)\n+            stc &= ~(STC.scope_ | STC.scopeinferred);\n+        if (stc & STC.returninferred)\n+            stc &= ~(STC.return_ | STC.returninferred);\n \n         // 'return inout ref' is the same as 'inout ref'\n-        if ((p.storageClass & (STC.return_ | STC.wild)) == STC.return_ &&\n-            !(p.storageClass & STC.returninferred))\n-            buf.writestring(\"Nk\");\n-        switch (p.storageClass & (STC.IOR | STC.lazy_))\n+        if ((stc & (STC.return_ | STC.wild)) == (STC.return_ | STC.wild))\n+            stc &= ~STC.return_;\n+\n+        // much like hdrgen.stcToBuffer()\n+        string rrs;\n+        const isout = (stc & STC.out_) != 0;\n+        final switch (buildScopeRef(stc))\n+        {\n+            case ScopeRef.None:\n+            case ScopeRef.Scope:\n+            case ScopeRef.Ref:\n+            case ScopeRef.Return:\n+            case ScopeRef.RefScope:\n+                break;\n+\n+            case ScopeRef.ReturnScope:     rrs = \"NkM\";                  goto L1;  // return scope\n+            case ScopeRef.ReturnRef:       rrs = isout ? \"NkJ\"  : \"NkK\"; goto L1;  // return ref\n+            case ScopeRef.ReturnRef_Scope: rrs = isout ? \"MNkJ\" : \"MNkK\"; goto L1; // scope return ref\n+            case ScopeRef.Ref_ReturnScope: rrs = isout ? \"NkMJ\" : \"NkMK\"; goto L1; // return scope ref\n+            L1:\n+                buf.writestring(rrs);\n+                stc &= ~(STC.out_ | STC.scope_ | STC.ref_ | STC.return_);\n+                break;\n+        }\n+\n+        if (stc & STC.scope_)\n+            buf.writeByte('M');  // scope\n+\n+        if (stc & STC.return_)\n+            buf.writestring(\"Nk\"); // return\n+\n+        switch (stc & (STC.IOR | STC.lazy_))\n         {\n         case 0:\n             break;\n@@ -1288,10 +1323,10 @@ public:\n         default:\n             debug\n             {\n-                printf(\"storageClass = x%llx\\n\", p.storageClass & (STC.IOR | STC.lazy_));\n+                printf(\"storageClass = x%llx\\n\", stc & (STC.IOR | STC.lazy_));\n             }\n             assert(0);\n         }\n-        visitWithMask(p.type, (p.storageClass & STC.in_) ? MODFlags.const_ : 0);\n+        visitWithMask(p.type, (stc & STC.in_) ? MODFlags.const_ : 0);\n     }\n }"}, {"sha": "4e0071304e4dd590e76f20733986e0f821355e4c", "filename": "gcc/d/dmd/dmodule.d", "status": "modified", "additions": 26, "deletions": 116, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdmodule.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdmodule.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmodule.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -31,6 +31,7 @@ import dmd.dsymbolsem;\n import dmd.errors;\n import dmd.expression;\n import dmd.expressionsem;\n+import dmd.file_manager;\n import dmd.globals;\n import dmd.id;\n import dmd.identifier;\n@@ -39,7 +40,7 @@ import dmd.cparse;\n import dmd.root.array;\n import dmd.root.file;\n import dmd.root.filename;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.root.port;\n import dmd.root.rmem;\n import dmd.root.rootobject;\n@@ -50,113 +51,6 @@ import dmd.target;\n import dmd.utils;\n import dmd.visitor;\n \n-enum package_d  = \"package.\" ~ mars_ext;\n-enum package_di = \"package.\" ~ hdr_ext;\n-\n-/********************************************\n- * Look for the source file if it's different from filename.\n- * Look for .di, .d, directory, and along global.path.\n- * Does not open the file.\n- * Params:\n- *      filename = as supplied by the user\n- *      path = path to look for filename\n- * Returns:\n- *      the found file name or\n- *      `null` if it is not different from filename.\n- */\n-private const(char)[] lookForSourceFile(const char[] filename, const char*[] path)\n-{\n-    //printf(\"lookForSourceFile(`%.*s`)\\n\", cast(int)filename.length, filename.ptr);\n-    /* Search along path[] for .di file, then .d file, then .i file, then .c file.\n-     */\n-    const sdi = FileName.forceExt(filename, hdr_ext);\n-    if (FileName.exists(sdi) == 1)\n-        return sdi;\n-    scope(exit) FileName.free(sdi.ptr);\n-\n-    const sd = FileName.forceExt(filename, mars_ext);\n-    if (FileName.exists(sd) == 1)\n-        return sd;\n-    scope(exit) FileName.free(sd.ptr);\n-\n-    const si = FileName.forceExt(filename, i_ext);\n-    if (FileName.exists(si) == 1)\n-        return si;\n-    scope(exit) FileName.free(si.ptr);\n-\n-    const sc = FileName.forceExt(filename, c_ext);\n-    if (FileName.exists(sc) == 1)\n-        return sc;\n-    scope(exit) FileName.free(sc.ptr);\n-\n-    if (FileName.exists(filename) == 2)\n-    {\n-        /* The filename exists and it's a directory.\n-         * Therefore, the result should be: filename/package.d\n-         * iff filename/package.d is a file\n-         */\n-        const ni = FileName.combine(filename, package_di);\n-        if (FileName.exists(ni) == 1)\n-            return ni;\n-        FileName.free(ni.ptr);\n-\n-        const n = FileName.combine(filename, package_d);\n-        if (FileName.exists(n) == 1)\n-            return n;\n-        FileName.free(n.ptr);\n-    }\n-    if (FileName.absolute(filename))\n-        return null;\n-    if (!path.length)\n-        return null;\n-    foreach (entry; path)\n-    {\n-        const p = entry.toDString();\n-\n-        const(char)[] n = FileName.combine(p, sdi);\n-        if (FileName.exists(n) == 1) {\n-            return n;\n-        }\n-        FileName.free(n.ptr);\n-\n-        n = FileName.combine(p, sd);\n-        if (FileName.exists(n) == 1) {\n-            return n;\n-        }\n-        FileName.free(n.ptr);\n-\n-        n = FileName.combine(p, si);\n-        if (FileName.exists(n) == 1) {\n-            return n;\n-        }\n-        FileName.free(n.ptr);\n-\n-        n = FileName.combine(p, sc);\n-        if (FileName.exists(n) == 1) {\n-            return n;\n-        }\n-        FileName.free(n.ptr);\n-\n-        const b = FileName.removeExt(filename);\n-        n = FileName.combine(p, b);\n-        FileName.free(b.ptr);\n-        if (FileName.exists(n) == 2)\n-        {\n-            const n2i = FileName.combine(n, package_di);\n-            if (FileName.exists(n2i) == 1)\n-                return n2i;\n-            FileName.free(n2i.ptr);\n-            const n2 = FileName.combine(n, package_d);\n-            if (FileName.exists(n2) == 1) {\n-                return n2;\n-            }\n-            FileName.free(n2.ptr);\n-        }\n-        FileName.free(n.ptr);\n-    }\n-    return null;\n-}\n-\n // function used to call semantic3 on a module's dependencies\n void semantic3OnDependencies(Module m)\n {\n@@ -414,8 +308,8 @@ extern (C++) class Package : ScopeDsymbol\n             packages ~= s.ident;\n         reverse(packages);\n \n-        if (lookForSourceFile(getFilename(packages, ident), global.path ? (*global.path)[] : null))\n-            Module.load(Loc(), packages, this.ident);\n+        if (FileManager.lookForSourceFile(getFilename(packages, ident), global.path ? (*global.path)[] : null))\n+            Module.load(Loc.initial, packages, this.ident);\n         else\n             isPkgMod = PKG.package_;\n     }\n@@ -598,12 +492,12 @@ extern (C++) final class Module : Package\n         return new Module(Loc.initial, filename, ident, doDocComment, doHdrGen);\n     }\n \n-    extern (C++) static Module load(Loc loc, Identifiers* packages, Identifier ident)\n+    extern (C++) static Module load(const ref Loc loc, Identifiers* packages, Identifier ident)\n     {\n         return load(loc, packages ? (*packages)[] : null, ident);\n     }\n \n-    extern (D) static Module load(Loc loc, Identifier[] packages, Identifier ident)\n+    extern (D) static Module load(const ref Loc loc, Identifier[] packages, Identifier ident)\n     {\n         //printf(\"Module::load(ident = '%s')\\n\", ident.toChars());\n         // Build module filename by turning:\n@@ -612,7 +506,7 @@ extern (C++) final class Module : Package\n         //  foo\\bar\\baz\n         const(char)[] filename = getFilename(packages, ident);\n         // Look for the source file\n-        if (const result = lookForSourceFile(filename, global.path ? (*global.path)[] : null))\n+        if (const result = FileManager.lookForSourceFile(filename, global.path ? (*global.path)[] : null))\n             filename = result; // leaks\n \n         auto m = new Module(loc, filename, ident, 0, 0);\n@@ -737,7 +631,12 @@ extern (C++) final class Module : Package\n             if (isPackageMod)\n                 .error(loc, \"importing package '%s' requires a 'package.d' file which cannot be found in '%s'\", toChars(), srcfile.toChars());\n             else\n-                error(loc, \"is in file '%s' which cannot be read\", srcfile.toChars());\n+            {\n+                .error(loc, \"unable to read module `%s`\", toChars());\n+                const pkgfile = FileName.combine(FileName.removeExt(srcfile.toString()), package_d);\n+                .errorSupplemental(loc, \"Expected '%s' or '%s' in one of the following import paths:\",\n+                    srcfile.toChars(), pkgfile.ptr);\n+            }\n         }\n         if (!global.gag)\n         {\n@@ -776,14 +675,25 @@ extern (C++) final class Module : Package\n             return true; // already read\n \n         //printf(\"Module::read('%s') file '%s'\\n\", toChars(), srcfile.toChars());\n-        auto readResult = File.read(srcfile.toChars());\n \n         if (global.params.emitMakeDeps)\n         {\n             global.params.makeDeps.push(srcfile.toChars());\n         }\n \n-        return loadSourceBuffer(loc, readResult);\n+        if (auto readResult = FileManager.fileManager.lookup(srcfile))\n+        {\n+            srcBuffer = readResult;\n+            return true;\n+        }\n+\n+        auto readResult = File.read(srcfile.toChars());\n+        if (loadSourceBuffer(loc, readResult))\n+        {\n+            FileManager.fileManager.add(srcfile, srcBuffer);\n+            return true;\n+        }\n+        return false;\n     }\n \n     /// syntactic parse"}, {"sha": "f9b765c521cb945169d1efe8581107d9a1ca6cf8", "filename": "gcc/d/dmd/doc.d", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdoc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdoc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdoc.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -45,7 +45,7 @@ import dmd.mtype;\n import dmd.root.array;\n import dmd.root.file;\n import dmd.root.filename;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.root.port;\n import dmd.root.rmem;\n import dmd.root.string;\n@@ -3995,8 +3995,8 @@ private size_t startTable(ref OutBuffer buf, size_t iStart, size_t iEnd, const r\n     const iDelimiterRowEnd = parseTableDelimiterRow(buf, iEnd + 1, inQuote, columnAlignments);\n     if (iDelimiterRowEnd)\n     {\n-        const delta = replaceTableRow(buf, iStart, iEnd, loc, inlineDelimiters, columnAlignments, true);\n-        if (delta)\n+        size_t delta;\n+        if (replaceTableRow(buf, iStart, iEnd, loc, inlineDelimiters, columnAlignments, true, delta))\n         {\n             buf.remove(iEnd + delta, iDelimiterRowEnd - iEnd);\n             buf.insert(iEnd + delta, \"$(TBODY \");\n@@ -4023,12 +4023,15 @@ private size_t startTable(ref OutBuffer buf, size_t iStart, size_t iEnd, const r\n  *  headerRow = if `true` then the number of columns will be enforced to match\n  *              `columnAlignments.length` and the row will be surrounded by a\n  *              `THEAD` macro\n- * Returns: the number of characters added by replacing the row, or `0` if unchanged\n+ *  delta     = the number of characters added by replacing the row, or `0` if unchanged\n+ * Returns: `true` if a table row was found and replaced\n  */\n-private size_t replaceTableRow(ref OutBuffer buf, size_t iStart, size_t iEnd, const ref Loc loc, ref MarkdownDelimiter[] inlineDelimiters, TableColumnAlignment[] columnAlignments, bool headerRow)\n+private bool replaceTableRow(ref OutBuffer buf, size_t iStart, size_t iEnd, const ref Loc loc, ref MarkdownDelimiter[] inlineDelimiters, TableColumnAlignment[] columnAlignments, bool headerRow, out size_t delta)\n {\n+    delta = 0;\n+\n     if (!columnAlignments.length || iStart == iEnd)\n-        return 0;\n+        return false;\n \n     iStart = skipChars(buf, iStart, \" \\t\");\n     int cellCount = 0;\n@@ -4045,16 +4048,14 @@ private size_t replaceTableRow(ref OutBuffer buf, size_t iStart, size_t iEnd, co\n         ++cellCount;\n \n     if (headerRow && cellCount != columnAlignments.length)\n-        return 0;\n+        return false;\n \n     if (headerRow && global.params.vmarkdown)\n     {\n         const s = buf[][iStart..iEnd];\n         message(loc, \"Ddoc: formatting table '%.*s'\", cast(int)s.length, s.ptr);\n     }\n \n-    size_t delta = 0;\n-\n     void replaceTableCell(size_t iCellStart, size_t iCellEnd, int cellIndex, int di)\n     {\n         const eDelta = replaceMarkdownEmphasis(buf, loc, inlineDelimiters, di);\n@@ -4146,7 +4147,7 @@ private size_t replaceTableRow(ref OutBuffer buf, size_t iStart, size_t iEnd, co\n         delta += 9;\n     }\n \n-    return delta;\n+    return true;\n }\n \n /****************************************************\n@@ -4182,7 +4183,8 @@ private size_t endTable(ref OutBuffer buf, size_t i, ref TableColumnAlignment[]\n  */\n private size_t endRowAndTable(ref OutBuffer buf, size_t iStart, size_t iEnd, const ref Loc loc, ref MarkdownDelimiter[] inlineDelimiters, ref TableColumnAlignment[] columnAlignments)\n {\n-    size_t delta = replaceTableRow(buf, iStart, iEnd, loc, inlineDelimiters, columnAlignments, false);\n+    size_t delta;\n+    replaceTableRow(buf, iStart, iEnd, loc, inlineDelimiters, columnAlignments, false, delta);\n     delta += endTable(buf, iEnd + delta, columnAlignments);\n     return delta;\n }\n@@ -4263,8 +4265,8 @@ private void highlightText(Scope* sc, Dsymbols* a, Loc loc, ref OutBuffer buf, s\n                 i += startTable(buf, iLineStart, i, loc, lineQuoted, inlineDelimiters, columnAlignments);\n             else if (columnAlignments.length)\n             {\n-                const delta = replaceTableRow(buf, iLineStart, i, loc, inlineDelimiters, columnAlignments, false);\n-                if (delta)\n+                size_t delta;\n+                if (replaceTableRow(buf, iLineStart, i, loc, inlineDelimiters, columnAlignments, false, delta))\n                     i += delta;\n                 else\n                     i += endTable(buf, i, columnAlignments);"}, {"sha": "42c0d18b2dbe0db06e2c1b08aecc26c0ab52cf9b", "filename": "gcc/d/dmd/dscope.d", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdscope.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdscope.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdscope.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -33,7 +33,7 @@ import dmd.func;\n import dmd.globals;\n import dmd.id;\n import dmd.identifier;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.root.rmem;\n import dmd.root.speller;\n import dmd.statement;\n@@ -730,12 +730,21 @@ struct Scope\n         }\n     }\n \n+    /******************************\n+     */\n     structalign_t alignment()\n     {\n         if (aligndecl)\n-            return aligndecl.getAlignment(&this);\n+        {\n+            auto ad = aligndecl.getAlignment(&this);\n+            return ad.salign;\n+        }\n         else\n-            return STRUCTALIGN_DEFAULT;\n+        {\n+            structalign_t sa;\n+            sa.setDefault();\n+            return sa;\n+        }\n     }\n \n     /**********************************"}, {"sha": "0925e7cd38a2d1510a9d05599e9ee26d1a68f7c0", "filename": "gcc/d/dmd/dstruct.d", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdstruct.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdstruct.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdstruct.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -16,6 +16,7 @@ module dmd.dstruct;\n import dmd.aggregate;\n import dmd.arraytypes;\n import dmd.astenums;\n+import dmd.attrib;\n import dmd.declaration;\n import dmd.dmodule;\n import dmd.dscope;\n@@ -127,7 +128,7 @@ extern (C++) void semanticTypeInfo(Scope* sc, Type t)\n          */\n         if (!sd.members)\n             return; // opaque struct\n-        if (!sd.xeq && !sd.xcmp && !sd.postblit && !sd.dtor && !sd.xhash && !search_toString(sd))\n+        if (!sd.xeq && !sd.xcmp && !sd.postblit && !sd.tidtor && !sd.xhash && !search_toString(sd))\n             return; // none of TypeInfo-specific members\n \n         // If the struct is in a non-root module, run semantic3 to get\n@@ -232,7 +233,7 @@ extern (C++) class StructDeclaration : AggregateDeclaration\n         }\n     }\n \n-    static StructDeclaration create(Loc loc, Identifier id, bool inObject)\n+    static StructDeclaration create(const ref Loc loc, Identifier id, bool inObject)\n     {\n         return new StructDeclaration(loc, id, inObject);\n     }\n@@ -297,22 +298,46 @@ extern (C++) class StructDeclaration : AggregateDeclaration\n             return;\n         }\n \n-        // 0 sized struct's are set to 1 byte\n         if (structsize == 0)\n         {\n             hasNoFields = true;\n             alignsize = 1;\n-            if (classKind != classKind.c) // C gets a struct size of 0\n-                structsize = 1;\n+\n+            // A fine mess of what size a zero sized struct should be\n+            final switch (classKind)\n+            {\n+                case ClassKind.d:\n+                case ClassKind.cpp:\n+                    structsize = 1;\n+                    break;\n+\n+                case ClassKind.c:\n+                case ClassKind.objc:\n+                    if (target.c.bitFieldStyle == TargetC.BitFieldStyle.MS)\n+                    {\n+                        /* Undocumented MS behavior for:\n+                         *   struct S { int :0; };\n+                         */\n+                        structsize = 4;\n+                    }\n+                    else if (target.c.bitFieldStyle == TargetC.BitFieldStyle.DM)\n+                    {\n+                        structsize = 0;\n+                        alignsize = 0;\n+                    }\n+                    else\n+                        structsize = 0;\n+                    break;\n+            }\n         }\n \n         // Round struct size up to next alignsize boundary.\n         // This will ensure that arrays of structs will get their internals\n         // aligned properly.\n-        if (alignment == STRUCTALIGN_DEFAULT)\n+        if (alignment.isDefault() || alignment.isPack())\n             structsize = (structsize + alignsize - 1) & ~(alignsize - 1);\n         else\n-            structsize = (structsize + alignment - 1) & ~(alignment - 1);\n+            structsize = (structsize + alignment.get() - 1) & ~(alignment.get() - 1);\n \n         sizeok = Sizeok.done;\n "}, {"sha": "9aa435d646381eea4c2ad874ebe247d9e107eda2", "filename": "gcc/d/dmd/dsymbol.d", "status": "modified", "additions": 104, "deletions": 6, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdsymbol.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdsymbol.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -187,7 +187,7 @@ struct Visibility\n     }\n }\n \n-enum PASS : int\n+enum PASS : ubyte\n {\n     init,           // initial state\n     semantic,       // semantic() started\n@@ -225,11 +225,13 @@ enum : int\n  */\n struct FieldState\n {\n-    uint offset;        /// offset for next field\n+    uint offset;        /// byte offset for next field\n \n-    uint fieldOffset;   /// offset for the start of the bit field\n+    uint fieldOffset;   /// byte offset for the start of the bit field\n+    uint fieldSize;     /// byte size of field\n+    uint fieldAlign;    /// byte alignment of field\n     uint bitOffset;     /// bit offset for field\n-    uint fieldSize;     /// size of field in bytes\n+\n     bool inFlight;      /// bit field is in flight\n }\n \n@@ -793,10 +795,18 @@ extern (C++) class Dsymbol : ASTNode\n             Dsymbol s2 = sds.symtabLookup(this,ident);\n \n             // If using C tag/prototype/forward declaration rules\n-            if (sc.flags & SCOPE.Cfile &&\n-                handleTagSymbols(*sc, this, s2, sds))\n+            if (sc.flags & SCOPE.Cfile)\n+            {\n+                if (handleTagSymbols(*sc, this, s2, sds))\n+                    return;\n+                if (handleSymbolRedeclarations(*sc, this, s2, sds))\n                     return;\n \n+                sds.multiplyDefined(Loc.initial, this, s2);  // ImportC doesn't allow overloading\n+                errors = true;\n+                return;\n+            }\n+\n             if (!s2.overloadInsert(this))\n             {\n                 sds.multiplyDefined(Loc.initial, this, s2);\n@@ -2384,3 +2394,91 @@ Dsymbol handleTagSymbols(ref Scope sc, Dsymbol s, Dsymbol s2, ScopeDsymbol sds)\n }\n \n \n+/**********************************************\n+ * ImportC allows redeclarations of C variables, functions and typedefs.\n+ *    extern int x;\n+ *    int x = 3;\n+ * and:\n+ *    extern void f();\n+ *    void f() { }\n+ * Attempt to merge them.\n+ * Params:\n+ *      sc = context\n+ *      s = symbol to add to symbol table\n+ *      s2 = existing declaration\n+ *      sds = symbol table\n+ * Returns:\n+ *      if s and s2 are successfully put in symbol table then return the merged symbol,\n+ *      null if they conflict\n+ */\n+Dsymbol handleSymbolRedeclarations(ref Scope sc, Dsymbol s, Dsymbol s2, ScopeDsymbol sds)\n+{\n+    enum log = false;\n+    if (log) printf(\"handleSymbolRedeclarations('%s')\\n\", s.toChars());\n+\n+    static Dsymbol collision()\n+    {\n+        if (log) printf(\" collision\\n\");\n+        return null;\n+    }\n+\n+    auto vd = s.isVarDeclaration(); // new declaration\n+    auto vd2 = s2.isVarDeclaration(); // existing declaration\n+    if (vd && vd2)\n+    {\n+        // if one is `static` and the other isn't\n+        if ((vd.storage_class ^ vd2.storage_class) & STC.static_)\n+            return collision();\n+\n+        const i1 =  vd._init && ! vd._init.isVoidInitializer();\n+        const i2 = vd2._init && !vd2._init.isVoidInitializer();\n+\n+        if (i1 && i2)\n+            return collision();         // can't both have initializers\n+\n+        if (i1)\n+            return vd;\n+\n+        /* BUG: the types should match, which needs semantic() to be run on it\n+         *    extern int x;\n+         *    int x;  // match\n+         *    typedef int INT;\n+         *    INT x;  // match\n+         *    long x; // collision\n+         * We incorrectly ignore these collisions\n+         */\n+        return vd2;\n+    }\n+\n+    auto fd = s.isFuncDeclaration(); // new declaration\n+    auto fd2 = s2.isFuncDeclaration(); // existing declaration\n+    if (fd && fd2)\n+    {\n+        // if one is `static` and the other isn't\n+        if ((fd.storage_class ^ fd2.storage_class) & STC.static_)\n+            return collision();\n+\n+        if (fd.fbody && fd2.fbody)\n+            return collision();         // can't both have bodies\n+\n+        if (fd.fbody)\n+            return fd;\n+\n+        /* BUG: just like with VarDeclaration, the types should match, which needs semantic() to be run on it.\n+         * FuncDeclaration::semantic2() can detect this, but it relies overnext being set.\n+         */\n+        return fd2;\n+    }\n+\n+    auto td  = s.isAliasDeclaration();  // new declaration\n+    auto td2 = s2.isAliasDeclaration(); // existing declaration\n+    if (td && td2)\n+    {\n+        /* BUG: just like with variables and functions, the types should match, which needs semantic() to be run on it.\n+         * FuncDeclaration::semantic2() can detect this, but it relies overnext being set.\n+         */\n+        return td2;\n+    }\n+\n+    return collision();\n+}"}, {"sha": "02252fd13e590eaf7f2ad453604256b1e81b86bb", "filename": "gcc/d/dmd/dsymbol.h", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdsymbol.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdsymbol.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.h?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -108,7 +108,21 @@ struct Visibility\n \n /* State of symbol in winding its way through the passes of the compiler\n  */\n-enum PASS\n+enum class PASS : uint8_t\n+{\n+    init,           // initial state\n+    semantic,       // semantic() started\n+    semanticdone,   // semantic() done\n+    semantic2,      // semantic2() started\n+    semantic2done,  // semantic2() done\n+    semantic3,      // semantic3() started\n+    semantic3done,  // semantic3() done\n+    inline_,         // inline started\n+    inlinedone,     // inline done\n+    obj             // toObjFile() run\n+};\n+\n+enum\n {\n     PASSinit,           // initial state\n     PASSsemantic,       // semantic() started\n@@ -145,8 +159,10 @@ struct FieldState\n     unsigned offset;\n \n     unsigned fieldOffset;\n+    unsigned fieldSize;\n+    unsigned fieldAlign;\n     unsigned bitOffset;\n-    unsigned fieldSice;\n+\n     bool inFlight;\n };\n "}, {"sha": "047c1eb6f69ffdadc54e994915050b58b013948b", "filename": "gcc/d/dmd/dsymbolsem.d", "status": "modified", "additions": 126, "deletions": 41, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbolsem.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -56,7 +56,7 @@ import dmd.objc;\n import dmd.opover;\n import dmd.parse;\n import dmd.root.filename;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.root.rmem;\n import dmd.root.rootobject;\n import dmd.semantic2;\n@@ -109,17 +109,18 @@ extern(C++) void dsymbolSemantic(Dsymbol dsym, Scope* sc)\n  *      ad = AlignmentDeclaration\n  *      sc = context\n  * Returns:\n- *      alignment as numerical value that is never 0.\n- *      STRUCTALIGN_DEFAULT is used instead.\n- *      STRUCTALIGN_DEFAULT is returned for errors\n+ *      ad with alignment value determined\n  */\n-structalign_t getAlignment(AlignDeclaration ad, Scope* sc)\n+AlignDeclaration getAlignment(AlignDeclaration ad, Scope* sc)\n {\n-    if (ad.salign != ad.UNKNOWN)   // UNKNOWN is 0\n-        return ad.salign;\n+    if (!ad.salign.isUnknown())   // UNKNOWN is 0\n+        return ad;\n \n     if (!ad.exps)\n-        return ad.salign = STRUCTALIGN_DEFAULT;\n+    {\n+        ad.salign.setDefault();\n+        return ad;\n+    }\n \n     dinteger_t strictest = 0;   // strictest alignment\n     bool errors;\n@@ -140,7 +141,7 @@ structalign_t getAlignment(AlignDeclaration ad, Scope* sc)\n             if (sc.flags & SCOPE.Cfile && n == 0)       // C11 6.7.5-6 allows 0 for alignment\n                 continue;\n \n-            if (n < 1 || n & (n - 1) || structalign_t.max < n || !e.type.isintegral())\n+            if (n < 1 || n & (n - 1) || ushort.max < n || !e.type.isintegral())\n             {\n                 error(ad.loc, \"alignment must be an integer positive power of 2, not 0x%llx\", cast(ulong)n);\n                 errors = true;\n@@ -150,10 +151,12 @@ structalign_t getAlignment(AlignDeclaration ad, Scope* sc)\n         }\n     }\n \n-    ad.salign = (errors || strictest == 0)  // C11 6.7.5-6 says alignment of 0 means no effect\n-                ? STRUCTALIGN_DEFAULT\n-                : cast(structalign_t) strictest;\n-    return ad.salign;\n+    if (errors || strictest == 0)  // C11 6.7.5-6 says alignment of 0 means no effect\n+        ad.salign.setDefault();\n+    else\n+        ad.salign.set(cast(uint) strictest);\n+\n+    return ad;\n }\n \n const(char)* getMessage(DeprecatedDeclaration dd)\n@@ -365,16 +368,31 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n         dsym.semanticRun = PASS.semantic;\n \n-        /* Pick up storage classes from context, but except synchronized,\n-         * override, abstract, and final.\n-         */\n-        dsym.storage_class |= (sc.stc & ~(STC.synchronized_ | STC.override_ | STC.abstract_ | STC.final_));\n+        // 'static foreach' variables should not inherit scope properties\n+        // https://issues.dlang.org/show_bug.cgi?id=19482\n+        if ((dsym.storage_class & (STC.foreach_ | STC.local)) == (STC.foreach_ | STC.local))\n+        {\n+            dsym.linkage = LINK.d;\n+            dsym.visibility = Visibility(Visibility.Kind.public_);\n+            dsym.overlapped = false; // unset because it is modified early on this function\n+            dsym.userAttribDecl = null; // unset because it is set by Dsymbol.setScope()\n+        }\n+        else\n+        {\n+            /* Pick up storage classes from context, but except synchronized,\n+             * override, abstract, and final.\n+             */\n+            dsym.storage_class |= (sc.stc & ~(STC.synchronized_ | STC.override_ | STC.abstract_ | STC.final_));\n+            dsym.userAttribDecl = sc.userAttribDecl;\n+            dsym.cppnamespace = sc.namespace;\n+            dsym.linkage = sc.linkage;\n+            dsym.visibility = sc.visibility;\n+            dsym.alignment = sc.alignment();\n+        }\n+\n         if (dsym.storage_class & STC.extern_ && dsym._init)\n             dsym.error(\"extern symbols cannot have initializers\");\n \n-        dsym.userAttribDecl = sc.userAttribDecl;\n-        dsym.cppnamespace = sc.namespace;\n-\n         AggregateDeclaration ad = dsym.isThis();\n         if (ad)\n             dsym.storage_class |= ad.storage_class & STC.TYPECTOR;\n@@ -431,16 +449,13 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             dsym.errors = true;\n \n         dsym.type.checkDeprecated(dsym.loc, sc);\n-        dsym.linkage = sc.linkage;\n         dsym.parent = sc.parent;\n         //printf(\"this = %p, parent = %p, '%s'\\n\", dsym, dsym.parent, dsym.parent.toChars());\n-        dsym.visibility = sc.visibility;\n \n         /* If scope's alignment is the default, use the type's alignment,\n          * otherwise the scope overrrides.\n          */\n-        dsym.alignment = sc.alignment();\n-        if (dsym.alignment == STRUCTALIGN_DEFAULT)\n+        if (dsym.alignment.isDefault())\n             dsym.alignment = dsym.type.alignment(); // use type's alignment\n \n         //printf(\"sc.stc = %x\\n\", sc.stc);\n@@ -935,6 +950,15 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             sc = sc.push();\n             sc.stc &= ~(STC.TYPECTOR | STC.pure_ | STC.nothrow_ | STC.nogc | STC.ref_ | STC.disable);\n \n+            if (sc.flags & SCOPE.Cfile &&\n+                dsym.type.isTypeSArray() &&\n+                dsym.type.isTypeSArray().isIncomplete() &&\n+                dsym._init.isVoidInitializer() &&\n+                !(dsym.storage_class & STC.field))\n+            {\n+                dsym.error(\"incomplete array type must have initializer\");\n+            }\n+\n             ExpInitializer ei = dsym._init.isExpInitializer();\n \n             if (ei) // https://issues.dlang.org/show_bug.cgi?id=13424\n@@ -971,6 +995,13 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                         ei = new ExpInitializer(dsym._init.loc, e);\n                         dsym._init = ei;\n                     }\n+                    else if (sc.flags & SCOPE.Cfile && dsym.type.isTypeSArray() &&\n+                             dsym.type.isTypeSArray().isIncomplete())\n+                    {\n+                        // C11 6.7.9-22 determine the size of the incomplete array,\n+                        // or issue an error that the initializer is invalid.\n+                        dsym._init = dsym._init.initializerSemantic(sc, dsym.type, INITinterpret);\n+                    }\n \n                     Expression exp = ei.exp;\n                     Expression e1 = new VarExp(dsym.loc, dsym);\n@@ -1056,18 +1087,29 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                     // could crash (inf. recursion) on a mod/pkg referencing itself\n                     if (ei && (ei.exp.op != TOK.scope_ ? true : !ei.exp.isScopeExp().sds.isPackage()))\n                     {\n-                        Expression exp = ei.exp.syntaxCopy();\n-\n-                        bool needctfe = dsym.isDataseg() || (dsym.storage_class & STC.manifest);\n-                        if (needctfe)\n-                            sc = sc.startCTFE();\n-                        exp = exp.expressionSemantic(sc);\n-                        exp = resolveProperties(sc, exp);\n-                        if (needctfe)\n-                            sc = sc.endCTFE();\n+                        if (ei.exp.type)\n+                        {\n+                            // If exp is already resolved we are done, our original init exp\n+                            // could have a type painting that we need to respect\n+                            // e.g.  ['a'] typed as string, or [['z'], \"\"] as string[]\n+                            // See https://issues.dlang.org/show_bug.cgi?id=15711\n+                        }\n+                        else\n+                        {\n+                            Expression exp = ei.exp.syntaxCopy();\n+\n+                            bool needctfe = dsym.isDataseg() || (dsym.storage_class & STC.manifest);\n+                            if (needctfe)\n+                                sc = sc.startCTFE();\n+                            exp = exp.expressionSemantic(sc);\n+                            exp = resolveProperties(sc, exp);\n+                            if (needctfe)\n+                                sc = sc.endCTFE();\n+                            ei.exp = exp;\n+                        }\n \n                         Type tb2 = dsym.type.toBasetype();\n-                        Type ti = exp.type.toBasetype();\n+                        Type ti = ei.exp.type.toBasetype();\n \n                         /* The problem is the following code:\n                          *  struct CopyTest {\n@@ -1091,11 +1133,10 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                             if (sd.postblit && tb2.toDsymbol(null) == sd)\n                             {\n                                 // The only allowable initializer is a (non-copy) constructor\n-                                if (exp.isLvalue())\n+                                if (ei.exp.isLvalue())\n                                     dsym.error(\"of type struct `%s` uses `this(this)`, which is not allowed in static initialization\", tb2.toChars());\n                             }\n                         }\n-                        ei.exp = exp;\n                     }\n \n                     dsym._init = dsym._init.initializerSemantic(sc, dsym.type, INITinterpret);\n@@ -1708,6 +1749,36 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         {\n             if (pd.args && pd.args.dim != 0)\n                 pd.error(\"takes no argument\");\n+            else\n+            {\n+                immutable isCtor = pd.ident == Id.crt_constructor;\n+\n+                static uint recurse(Dsymbol s, bool isCtor)\n+                {\n+                    if (auto ad = s.isAttribDeclaration())\n+                    {\n+                        uint nestedCount;\n+                        auto decls = ad.include(null);\n+                        if (decls)\n+                        {\n+                            for (size_t i = 0; i < decls.dim; ++i)\n+                                nestedCount += recurse((*decls)[i], isCtor);\n+                        }\n+                        return nestedCount;\n+                    }\n+                    else if (auto f = s.isFuncDeclaration())\n+                    {\n+                        f.isCrtCtorDtor |= isCtor ? 1 : 2;\n+                        return 1;\n+                    }\n+                    else\n+                        return 0;\n+                    assert(0);\n+                }\n+\n+                if (recurse(pd, isCtor) > 1)\n+                    pd.error(\"can only apply to a single declaration\");\n+            }\n             return declarations();\n         }\n         else if (pd.ident == Id.printf || pd.ident == Id.scanf)\n@@ -2445,6 +2516,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n         tempdecl.parent = sc.parent;\n         tempdecl.visibility = sc.visibility;\n+        tempdecl.userAttribDecl = sc.userAttribDecl;\n         tempdecl.cppnamespace = sc.namespace;\n         tempdecl.isstatic = tempdecl.toParent().isModule() || (tempdecl._scope.stc & STC.static_);\n         tempdecl.deprecated_ = !!(sc.stc & STC.deprecated_);\n@@ -2973,6 +3045,16 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         if (auto pragmadecl = sc.inlining)\n             funcdecl.inlining = pragmadecl.evalPragmaInline(sc);\n \n+        // check pragma(crt_constructor)\n+        if (funcdecl.isCrtCtorDtor)\n+        {\n+            if (funcdecl.linkage != LINK.c)\n+            {\n+                funcdecl.error(\"must be `extern(C)` for `pragma(%s)`\",\n+                    funcdecl.isCrtCtorDtor == 1 ? \"crt_constructor\".ptr : \"crt_destructor\".ptr);\n+            }\n+        }\n+\n         funcdecl.visibility = sc.visibility;\n         funcdecl.userAttribDecl = sc.userAttribDecl;\n         UserAttributeDeclaration.checkGNUABITag(funcdecl, funcdecl.linkage);\n@@ -3799,6 +3881,10 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             }\n         }\n \n+        if (funcdecl.fbody && sc._module.isRoot() &&\n+            (funcdecl.isMain() || funcdecl.isWinMain() || funcdecl.isDllMain() || funcdecl.isCMain()))\n+            global.hasMainFunction = true;\n+\n         if (funcdecl.fbody && funcdecl.isMain() && sc._module.isRoot())\n         {\n             // check if `_d_cmain` is defined\n@@ -3995,7 +4081,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             return;\n         }\n         if (dd.ident == Id.dtor && dd.semanticRun < PASS.semantic)\n-            ad.dtors.push(dd);\n+            ad.userDtors.push(dd);\n         if (!dd.type)\n         {\n             dd.type = new TypeFunction(ParameterList(), Type.tvoid, LINK.d, dd.storage_class);\n@@ -4417,8 +4503,8 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         // Look for the constructor\n         sd.ctor = sd.searchCtor();\n \n-        sd.dtor = buildDtor(sd, sc2);\n-        sd.tidtor = buildExternDDtor(sd, sc2);\n+        buildDtors(sd, sc2);\n+\n         sd.hasCopyCtor = buildCopyCtor(sd, sc2);\n         sd.postblit = buildPostBlit(sd, sc2);\n \n@@ -5057,8 +5143,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             }\n         }\n \n-        cldec.dtor = buildDtor(cldec, sc2);\n-        cldec.tidtor = buildExternDDtor(cldec, sc2);\n+        buildDtors(cldec, sc2);\n \n         if (cldec.classKind == ClassKind.cpp && cldec.cppDtorVtblIndex != -1)\n         {"}, {"sha": "9d7957a975d3a18a8dbca03dd7371ebfcce6867c", "filename": "gcc/d/dmd/dtemplate.d", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdtemplate.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdtemplate.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtemplate.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -67,7 +67,7 @@ import dmd.initsem;\n import dmd.mtype;\n import dmd.opover;\n import dmd.root.array;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.root.rootobject;\n import dmd.semantic2;\n import dmd.semantic3;\n@@ -985,9 +985,9 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n                 buf.writenl();\n                 buf.writestring(\"       \");\n             }\n-            buf.write((*parameters)[i]);\n+            write(buf, (*parameters)[i]);\n             buf.writestring(\" = \");\n-            buf.write(tiargs[i]);\n+            write(buf, tiargs[i]);\n         }\n         // write remaining variadic arguments on the last line\n         if (variadic)\n@@ -998,16 +998,16 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n                 buf.writenl();\n                 buf.writestring(\"       \");\n             }\n-            buf.write((*parameters)[end]);\n+            write(buf, (*parameters)[end]);\n             buf.writestring(\" = \");\n             buf.writeByte('(');\n             if (cast(int)tiargs.length - end > 0)\n             {\n-                buf.write(tiargs[end]);\n+                write(buf, tiargs[end]);\n                 foreach (j; parameters.length .. tiargs.length)\n                 {\n                     buf.writestring(\", \");\n-                    buf.write(tiargs[j]);\n+                    write(buf, tiargs[j]);\n                 }\n             }\n             buf.writeByte(')');\n@@ -1919,8 +1919,15 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n                             /* If a semantic error occurs while doing alias this,\n                              * eg purity(https://issues.dlang.org/show_bug.cgi?id=7295),\n                              * just regard it as not a match.\n-                             */\n-                            if (auto e = resolveAliasThis(sc, farg, true))\n+                             *\n+                             * We also save/restore sc.func.flags to avoid messing up\n+                             * attribute inference in the evaluation.\n+                            */\n+                            const oldflags = sc.func ? sc.func.flags : 0;\n+                            auto e = resolveAliasThis(sc, farg, true);\n+                            if (sc.func)\n+                                sc.func.flags = oldflags;\n+                            if (e)\n                             {\n                                 farg = e;\n                                 goto Lretry;\n@@ -5340,7 +5347,7 @@ extern (C++) class TemplateParameter : ASTNode\n \n     abstract RootObject specialization();\n \n-    abstract RootObject defaultArg(Loc instLoc, Scope* sc);\n+    abstract RootObject defaultArg(const ref Loc instLoc, Scope* sc);\n \n     abstract bool hasDefaultArg();\n \n@@ -5422,7 +5429,7 @@ extern (C++) class TemplateTypeParameter : TemplateParameter\n         return specType;\n     }\n \n-    override final RootObject defaultArg(Loc instLoc, Scope* sc)\n+    override final RootObject defaultArg(const ref Loc instLoc, Scope* sc)\n     {\n         Type t = defaultType;\n         if (t)\n@@ -5541,7 +5548,7 @@ extern (C++) final class TemplateValueParameter : TemplateParameter\n         return specValue;\n     }\n \n-    override RootObject defaultArg(Loc instLoc, Scope* sc)\n+    override RootObject defaultArg(const ref Loc instLoc, Scope* sc)\n     {\n         Expression e = defaultValue;\n         if (e)\n@@ -5640,7 +5647,7 @@ extern (C++) final class TemplateAliasParameter : TemplateParameter\n         return specAlias;\n     }\n \n-    override RootObject defaultArg(Loc instLoc, Scope* sc)\n+    override RootObject defaultArg(const ref Loc instLoc, Scope* sc)\n     {\n         RootObject da = defaultAlias;\n         Type ta = isType(defaultAlias);\n@@ -5741,7 +5748,7 @@ extern (C++) final class TemplateTupleParameter : TemplateParameter\n         return null;\n     }\n \n-    override RootObject defaultArg(Loc instLoc, Scope* sc)\n+    override RootObject defaultArg(const ref Loc instLoc, Scope* sc)\n     {\n         return null;\n     }\n@@ -8413,3 +8420,11 @@ private struct MATCHpair\n         this.mfa = mfa;\n     }\n }\n+\n+private void write(ref OutBuffer buf, RootObject obj)\n+{\n+    if (obj)\n+    {\n+        buf.writestring(obj.toChars());\n+    }\n+}"}, {"sha": "e19adfc4b149729bc976b21cf4f042c862d0d27d", "filename": "gcc/d/dmd/dtoh.d", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdtoh.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdtoh.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtoh.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -17,6 +17,7 @@ import core.stdc.ctype;\n \n import dmd.astcodegen;\n import dmd.arraytypes;\n+import dmd.attrib;\n import dmd.dsymbol;\n import dmd.errors;\n import dmd.globals;\n@@ -25,7 +26,7 @@ import dmd.root.filename;\n import dmd.visitor;\n import dmd.tokens;\n \n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.utils;\n \n //debug = Debug_DtoH;\n@@ -254,7 +255,7 @@ public:\n         Identifier ident;\n \n         /// Original type of the currently visited declaration\n-        AST.Type* origType;\n+        AST.Type origType;\n \n         /// Last written visibility level applying to the current scope\n         AST.Visibility.Kind currentVisibility;\n@@ -706,6 +707,10 @@ public:\n         // printf(\"FuncDeclaration %s %s\\n\", fd.toPrettyChars(), fd.type.toChars());\n         visited[cast(void*)fd] = true;\n \n+        // silently ignore non-user-defined destructors\n+        if (fd.generated && fd.isDtorDeclaration())\n+            return;\n+\n         // Note that tf might be null for templated (member) functions\n         auto tf = cast(AST.TypeFunction)fd.type;\n         if ((tf && tf.linkage != LINK.c && tf.linkage != LINK.cpp) || (!tf && fd.isPostBlitDeclaration()))\n@@ -841,12 +846,12 @@ public:\n             return;\n \n         if (vd.originalType && vd.type == AST.Type.tsize_t)\n-            origType = &vd.originalType;\n+            origType = vd.originalType;\n         scope(exit) origType = null;\n \n-        if (vd.alignment != STRUCTALIGN_DEFAULT)\n+        if (!vd.alignment.isDefault())\n         {\n-            buf.printf(\"// Ignoring var %s alignment %u\", vd.toChars(), vd.alignment);\n+            buf.printf(\"// Ignoring var %s alignment %d\", vd.toChars(), vd.alignment.get());\n             buf.writenl();\n         }\n \n@@ -1008,12 +1013,12 @@ public:\n             if (ad.originalType && ad.type.ty == AST.Tpointer &&\n                 (cast(AST.TypePointer)t).nextOf.ty == AST.Tfunction)\n             {\n-                origType = &ad.originalType;\n+                origType = ad.originalType;\n             }\n             scope(exit) origType = null;\n \n             buf.writestring(\"typedef \");\n-            typeToBuffer(origType ? *origType : t, ad);\n+            typeToBuffer(origType !is null ? origType : t, ad);\n             writeDeclEnd();\n             return;\n         }\n@@ -1346,28 +1351,28 @@ public:\n \n     /// Starts a custom alignment section using `#pragma pack` if\n     /// `alignment` specifies a custom alignment\n-    private void pushAlignToBuffer(uint alignment)\n+    private void pushAlignToBuffer(structalign_t alignment)\n     {\n         // DMD ensures alignment is a power of two\n         //assert(alignment > 0 && ((alignment & (alignment - 1)) == 0),\n         //       \"Invalid alignment size\");\n \n         // When no alignment is specified, `uint.max` is the default\n         // FIXME: alignment is 0 for structs templated members\n-        if (alignment == STRUCTALIGN_DEFAULT || (tdparent && alignment == 0))\n+        if (alignment.isDefault() || (tdparent && alignment.isUnknown()))\n         {\n             return;\n         }\n \n-        buf.printf(\"#pragma pack(push, %d)\", alignment);\n+        buf.printf(\"#pragma pack(push, %d)\", alignment.get());\n         buf.writenl();\n     }\n \n     /// Ends a custom alignment section using `#pragma pack` if\n     /// `alignment` specifies a custom alignment\n-    private void popAlignToBuffer(uint alignment)\n+    private void popAlignToBuffer(structalign_t alignment)\n     {\n-        if (alignment == STRUCTALIGN_DEFAULT || (tdparent && alignment == 0))\n+        if (alignment.isDefault() || (tdparent && alignment.isUnknown()))\n             return;\n \n         buf.writestringln(\"#pragma pack(pop)\");\n@@ -1645,7 +1650,7 @@ public:\n         }\n \n         this.ident = s.ident;\n-        auto type = origType ? *origType : t;\n+        auto type = origType !is null ? origType : t;\n         AST.Dsymbol customLength;\n \n         // Check for quirks that are usually resolved during semantic"}, {"sha": "49ee4b3b3ecc1a8d7011b9e444438fde3326b69d", "filename": "gcc/d/dmd/dversion.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdversion.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fdversion.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdversion.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -22,7 +22,7 @@ import dmd.dsymbol;\n import dmd.dsymbolsem;\n import dmd.globals;\n import dmd.identifier;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.visitor;\n \n /***********************************************************"}, {"sha": "2a6233244547a5f5a178695e3b0c52ced8992f71", "filename": "gcc/d/dmd/expression.d", "status": "modified", "additions": 69, "deletions": 35, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fexpression.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fexpression.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -59,7 +59,7 @@ import dmd.opover;\n import dmd.optimize;\n import dmd.root.ctfloat;\n import dmd.root.filename;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.root.rmem;\n import dmd.root.rootobject;\n import dmd.root.string;\n@@ -1201,20 +1201,14 @@ extern (C++) abstract class Expression : ASTNode\n         // DtorDeclaration without parents should fail at an earlier stage\n         auto ad = cast(AggregateDeclaration) f.toParent2();\n         assert(ad);\n-        assert(ad.dtors.length);\n \n-        // Search for the user-defined destructor (if any)\n-        foreach(dtor; ad.dtors)\n+        if (ad.userDtors.dim)\n         {\n-            if (dtor.generated)\n-                continue;\n-\n-            if (!check(dtor)) // doesn't match check (e.g. is impure as well)\n+            if (!check(ad.userDtors[0])) // doesn't match check (e.g. is impure as well)\n                 return;\n \n             // Sanity check\n-            assert(!check(cast(DtorDeclaration) ad.fieldDtor));\n-            break;\n+            assert(!check(ad.fieldDtor));\n         }\n \n         dd.loc.errorSupplemental(\"%s`%s.~this` is %.*s because of the following field's destructors:\",\n@@ -1781,13 +1775,13 @@ extern (C++) final class IntegerExp : Expression\n         this.value = cast(d_int32)value;\n     }\n \n-    static IntegerExp create(Loc loc, dinteger_t value, Type type)\n+    static IntegerExp create(const ref Loc loc, dinteger_t value, Type type)\n     {\n         return new IntegerExp(loc, value, type);\n     }\n \n     // Same as create, but doesn't allocate memory.\n-    static void emplace(UnionExp* pue, Loc loc, dinteger_t value, Type type)\n+    static void emplace(UnionExp* pue, const ref Loc loc, dinteger_t value, Type type)\n     {\n         emplaceExp!(IntegerExp)(pue, loc, value, type);\n     }\n@@ -2052,13 +2046,13 @@ extern (C++) final class RealExp : Expression\n         this.type = type;\n     }\n \n-    static RealExp create(Loc loc, real_t value, Type type)\n+    static RealExp create(const ref Loc loc, real_t value, Type type)\n     {\n         return new RealExp(loc, value, type);\n     }\n \n     // Same as create, but doesn't allocate memory.\n-    static void emplace(UnionExp* pue, Loc loc, real_t value, Type type)\n+    static void emplace(UnionExp* pue, const ref Loc loc, real_t value, Type type)\n     {\n         emplaceExp!(RealExp)(pue, loc, value, type);\n     }\n@@ -2127,13 +2121,13 @@ extern (C++) final class ComplexExp : Expression\n         //printf(\"ComplexExp::ComplexExp(%s)\\n\", toChars());\n     }\n \n-    static ComplexExp create(Loc loc, complex_t value, Type type)\n+    static ComplexExp create(const ref Loc loc, complex_t value, Type type)\n     {\n         return new ComplexExp(loc, value, type);\n     }\n \n     // Same as create, but doesn't allocate memory.\n-    static void emplace(UnionExp* pue, Loc loc, complex_t value, Type type)\n+    static void emplace(UnionExp* pue, const ref Loc loc, complex_t value, Type type)\n     {\n         emplaceExp!(ComplexExp)(pue, loc, value, type);\n     }\n@@ -2203,7 +2197,7 @@ extern (C++) class IdentifierExp : Expression\n         this.ident = ident;\n     }\n \n-    static IdentifierExp create(Loc loc, Identifier ident)\n+    static IdentifierExp create(const ref Loc loc, Identifier ident)\n     {\n         return new IdentifierExp(loc, ident);\n     }\n@@ -2421,28 +2415,28 @@ extern (C++) final class StringExp : Expression\n         this.postfix = postfix;\n     }\n \n-    static StringExp create(Loc loc, char* s)\n+    static StringExp create(const ref Loc loc, const(char)* s)\n     {\n         return new StringExp(loc, s.toDString());\n     }\n \n-    static StringExp create(Loc loc, void* string, size_t len)\n+    static StringExp create(const ref Loc loc, const(void)* string, size_t len)\n     {\n         return new StringExp(loc, string[0 .. len]);\n     }\n \n     // Same as create, but doesn't allocate memory.\n-    static void emplace(UnionExp* pue, Loc loc, char* s)\n+    static void emplace(UnionExp* pue, const ref Loc loc, const(char)* s)\n     {\n         emplaceExp!(StringExp)(pue, loc, s.toDString());\n     }\n \n-    extern (D) static void emplace(UnionExp* pue, Loc loc, const(void)[] string)\n+    extern (D) static void emplace(UnionExp* pue, const ref Loc loc, const(void)[] string)\n     {\n         emplaceExp!(StringExp)(pue, loc, string);\n     }\n \n-    extern (D) static void emplace(UnionExp* pue, Loc loc, const(void)[] string, size_t len, ubyte sz, char postfix)\n+    extern (D) static void emplace(UnionExp* pue, const ref Loc loc, const(void)[] string, size_t len, ubyte sz, char postfix)\n     {\n         emplaceExp!(StringExp)(pue, loc, string, len, sz, postfix);\n     }\n@@ -2863,7 +2857,7 @@ extern (C++) final class TupleExp : Expression\n         }\n     }\n \n-    static TupleExp create(Loc loc, Expressions* exps)\n+    static TupleExp create(const ref Loc loc, Expressions* exps)\n     {\n         return new TupleExp(loc, exps);\n     }\n@@ -2946,13 +2940,13 @@ extern (C++) final class ArrayLiteralExp : Expression\n         this.elements = elements;\n     }\n \n-    static ArrayLiteralExp create(Loc loc, Expressions* elements)\n+    static ArrayLiteralExp create(const ref Loc loc, Expressions* elements)\n     {\n         return new ArrayLiteralExp(loc, null, elements);\n     }\n \n     // Same as create, but doesn't allocate memory.\n-    static void emplace(UnionExp* pue, Loc loc, Expressions* elements)\n+    static void emplace(UnionExp* pue, const ref Loc loc, Expressions* elements)\n     {\n         emplaceExp!(ArrayLiteralExp)(pue, loc, null, elements);\n     }\n@@ -3188,7 +3182,7 @@ extern (C++) final class StructLiteralExp : Expression\n         //printf(\"StructLiteralExp::StructLiteralExp(%s)\\n\", toChars());\n     }\n \n-    static StructLiteralExp create(Loc loc, StructDeclaration sd, void* elements, Type stype = null)\n+    static StructLiteralExp create(const ref Loc loc, StructDeclaration sd, void* elements, Type stype = null)\n     {\n         return new StructLiteralExp(loc, sd, cast(Expressions*)elements, stype);\n     }\n@@ -3532,7 +3526,7 @@ extern (C++) final class NewExp : Expression\n         this.arguments = arguments;\n     }\n \n-    static NewExp create(Loc loc, Expression thisexp, Expressions* newargs, Type newtype, Expressions* arguments)\n+    static NewExp create(const ref Loc loc, Expression thisexp, Expressions* newargs, Type newtype, Expressions* arguments)\n     {\n         return new NewExp(loc, thisexp, newargs, newtype, arguments);\n     }\n@@ -3653,7 +3647,7 @@ extern (C++) final class VarExp : SymbolExp\n         this.type = var.type;\n     }\n \n-    static VarExp create(Loc loc, Declaration var, bool hasOverloads = true)\n+    static VarExp create(const ref Loc loc, Declaration var, bool hasOverloads = true)\n     {\n         return new VarExp(loc, var, hasOverloads);\n     }\n@@ -3965,6 +3959,7 @@ extern (C++) final class FuncExp : Expression\n             auto tfy = new TypeFunction(tfx.parameterList, tof.next,\n                         tfx.linkage, STC.undefined_);\n             tfy.mod = tfx.mod;\n+            tfy.trust = tfx.trust;\n             tfy.isnothrow = tfx.isnothrow;\n             tfy.isnogc = tfx.isnogc;\n             tfy.purity = tfx.purity;\n@@ -4688,14 +4683,15 @@ extern (C++) final class DotIdExp : UnaExp\n     Identifier ident;\n     bool noderef;       // true if the result of the expression will never be dereferenced\n     bool wantsym;       // do not replace Symbol with its initializer during semantic()\n+    bool arrow;         // ImportC: if -> instead of .\n \n     extern (D) this(const ref Loc loc, Expression e, Identifier ident)\n     {\n         super(loc, TOK.dotIdentifier, __traits(classInstanceSize, DotIdExp), e);\n         this.ident = ident;\n     }\n \n-    static DotIdExp create(Loc loc, Expression e, Identifier ident)\n+    static DotIdExp create(const ref Loc loc, Expression e, Identifier ident)\n     {\n         return new DotIdExp(loc, e, ident);\n     }\n@@ -4889,6 +4885,31 @@ extern (C++) final class DotTemplateInstanceExp : UnaExp\n         return ti.updateTempDecl(sc, s);\n     }\n \n+    override bool checkType()\n+    {\n+        // Same logic as ScopeExp.checkType()\n+        if (ti.tempdecl &&\n+            ti.semantictiargsdone &&\n+            ti.semanticRun == PASS.init)\n+        {\n+            error(\"partial %s `%s` has no type\", ti.kind(), toChars());\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    override bool checkValue()\n+    {\n+        if (ti.tempdecl &&\n+            ti.semantictiargsdone &&\n+            ti.semanticRun == PASS.init)\n+\n+            error(\"partial %s `%s` has no value\", ti.kind(), toChars());\n+        else\n+            error(\"%s `%s` has no value\", ti.kind(), ti.toChars());\n+        return true;\n+    }\n+\n     override void accept(Visitor v)\n     {\n         v.visit(this);\n@@ -4987,17 +5008,17 @@ extern (C++) final class CallExp : UnaExp\n         this.f = fd;\n     }\n \n-    static CallExp create(Loc loc, Expression e, Expressions* exps)\n+    static CallExp create(const ref Loc loc, Expression e, Expressions* exps)\n     {\n         return new CallExp(loc, e, exps);\n     }\n \n-    static CallExp create(Loc loc, Expression e)\n+    static CallExp create(const ref Loc loc, Expression e)\n     {\n         return new CallExp(loc, e);\n     }\n \n-    static CallExp create(Loc loc, Expression e, Expression earg1)\n+    static CallExp create(const ref Loc loc, Expression e, Expression earg1)\n     {\n         return new CallExp(loc, e, earg1);\n     }\n@@ -5009,7 +5030,7 @@ extern (C++) final class CallExp : UnaExp\n     *       fd    = the declaration of the function to call\n     *       earg1 = the function argument\n     */\n-    static CallExp create(Loc loc, FuncDeclaration fd, Expression earg1)\n+    static CallExp create(const ref Loc loc, FuncDeclaration fd, Expression earg1)\n     {\n         return new CallExp(loc, fd, earg1);\n     }\n@@ -5167,6 +5188,19 @@ extern (C++) final class PtrExp : UnaExp\n     override Expression modifiableLvalue(Scope* sc, Expression e)\n     {\n         //printf(\"PtrExp::modifiableLvalue() %s, type %s\\n\", toChars(), type.toChars());\n+        Declaration var;\n+        if (auto se = e1.isSymOffExp())\n+            var = se.var;\n+        else if (auto ve = e1.isVarExp())\n+            var = ve.var;\n+        if (var && var.type.isFunction_Delegate_PtrToFunction())\n+        {\n+            if (var.type.isTypeFunction())\n+                error(\"function `%s` is not an lvalue and cannot be modified\", var.toChars());\n+            else\n+                error(\"function pointed to by `%s` is not an lvalue and cannot be modified\", var.toChars());\n+            return ErrorExp.get();\n+        }\n         return Expression.modifiableLvalue(sc, e);\n     }\n \n@@ -5331,13 +5365,13 @@ extern (C++) final class VectorExp : UnaExp\n         to = cast(TypeVector)t;\n     }\n \n-    static VectorExp create(Loc loc, Expression e, Type t)\n+    static VectorExp create(const ref Loc loc, Expression e, Type t)\n     {\n         return new VectorExp(loc, e, t);\n     }\n \n     // Same as create, but doesn't allocate memory.\n-    static void emplace(UnionExp* pue, Loc loc, Expression e, Type type)\n+    static void emplace(UnionExp* pue, const ref Loc loc, Expression e, Type type)\n     {\n         emplaceExp!(VectorExp)(pue, loc, e, type);\n     }"}, {"sha": "691364cb265de0fc3db6b41304b21b85858cb742", "filename": "gcc/d/dmd/expression.h", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fexpression.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fexpression.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.h?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -57,6 +57,9 @@ enum\n     OWNEDcache      // constant value cached for CTFE\n };\n \n+#define WANTvalue  0 // default\n+#define WANTexpand 1 // expand const/immutable variables if possible\n+\n /**\n  * Specifies how the checkModify deals with certain situations\n  */\n@@ -239,8 +242,8 @@ class IntegerExp : public Expression\n public:\n     dinteger_t value;\n \n-    static IntegerExp *create(Loc loc, dinteger_t value, Type *type);\n-    static void emplace(UnionExp *pue, Loc loc, dinteger_t value, Type *type);\n+    static IntegerExp *create(const Loc &loc, dinteger_t value, Type *type);\n+    static void emplace(UnionExp *pue, const Loc &loc, dinteger_t value, Type *type);\n     bool equals(const RootObject *o) const;\n     dinteger_t toInteger();\n     real_t toReal();\n@@ -269,8 +272,8 @@ class RealExp : public Expression\n public:\n     real_t value;\n \n-    static RealExp *create(Loc loc, real_t value, Type *type);\n-    static void emplace(UnionExp *pue, Loc loc, real_t value, Type *type);\n+    static RealExp *create(const Loc &loc, real_t value, Type *type);\n+    static void emplace(UnionExp *pue, const Loc &loc, real_t value, Type *type);\n     bool equals(const RootObject *o) const;\n     dinteger_t toInteger();\n     uinteger_t toUInteger();\n@@ -286,8 +289,8 @@ class ComplexExp : public Expression\n public:\n     complex_t value;\n \n-    static ComplexExp *create(Loc loc, complex_t value, Type *type);\n-    static void emplace(UnionExp *pue, Loc loc, complex_t value, Type *type);\n+    static ComplexExp *create(const Loc &loc, complex_t value, Type *type);\n+    static void emplace(UnionExp *pue, const Loc &loc, complex_t value, Type *type);\n     bool equals(const RootObject *o) const;\n     dinteger_t toInteger();\n     uinteger_t toUInteger();\n@@ -303,7 +306,7 @@ class IdentifierExp : public Expression\n public:\n     Identifier *ident;\n \n-    static IdentifierExp *create(Loc loc, Identifier *ident);\n+    static IdentifierExp *create(const Loc &loc, Identifier *ident);\n     bool isLvalue();\n     Expression *toLvalue(Scope *sc, Expression *e);\n     void accept(Visitor *v) { v->visit(this); }\n@@ -365,10 +368,9 @@ class StringExp : public Expression\n     utf8_t postfix;      // 'c', 'w', 'd'\n     OwnedBy ownedByCtfe;\n \n-    static StringExp *create(Loc loc, char *s);\n-    static StringExp *create(Loc loc, void *s, size_t len);\n-    static void emplace(UnionExp *pue, Loc loc, char *s);\n-    static void emplace(UnionExp *pue, Loc loc, void *s, size_t len);\n+    static StringExp *create(const Loc &loc, const char *s);\n+    static StringExp *create(const Loc &loc, const void *s, size_t len);\n+    static void emplace(UnionExp *pue, const Loc &loc, const char *s);\n     bool equals(const RootObject *o) const;\n     StringExp *toStringExp();\n     StringExp *toUTF8(Scope *sc);\n@@ -397,7 +399,7 @@ class TupleExp : public Expression\n      */\n     Expressions *exps;\n \n-    static TupleExp *create(Loc loc, Expressions *exps);\n+    static TupleExp *create(const Loc &loc, Expressions *exps);\n     TupleExp *toTupleExp();\n     TupleExp *syntaxCopy();\n     bool equals(const RootObject *o) const;\n@@ -412,8 +414,8 @@ class ArrayLiteralExp : public Expression\n     Expressions *elements;\n     OwnedBy ownedByCtfe;\n \n-    static ArrayLiteralExp *create(Loc loc, Expressions *elements);\n-    static void emplace(UnionExp *pue, Loc loc, Expressions *elements);\n+    static ArrayLiteralExp *create(const Loc &loc, Expressions *elements);\n+    static void emplace(UnionExp *pue, const Loc &loc, Expressions *elements);\n     ArrayLiteralExp *syntaxCopy();\n     bool equals(const RootObject *o) const;\n     Expression *getElement(d_size_t i); // use opIndex instead\n@@ -468,7 +470,7 @@ class StructLiteralExp : public Expression\n     bool isOriginal;            // used when moving instances to indicate `this is this.origin`\n     OwnedBy ownedByCtfe;\n \n-    static StructLiteralExp *create(Loc loc, StructDeclaration *sd, void *elements, Type *stype = NULL);\n+    static StructLiteralExp *create(const Loc &loc, StructDeclaration *sd, void *elements, Type *stype = NULL);\n     bool equals(const RootObject *o) const;\n     StructLiteralExp *syntaxCopy();\n     Expression *getField(Type *type, unsigned offset);\n@@ -528,7 +530,7 @@ class NewExp : public Expression\n     bool onstack;               // allocate on stack\n     bool thrownew;              // this NewExp is the expression of a ThrowStatement\n \n-    static NewExp *create(Loc loc, Expression *thisexp, Expressions *newargs, Type *newtype, Expressions *arguments);\n+    static NewExp *create(const Loc &loc, Expression *thisexp, Expressions *newargs, Type *newtype, Expressions *arguments);\n     NewExp *syntaxCopy();\n \n     void accept(Visitor *v) { v->visit(this); }\n@@ -576,7 +578,7 @@ class VarExp : public SymbolExp\n {\n public:\n     bool delegateWasExtracted;\n-    static VarExp *create(Loc loc, Declaration *var, bool hasOverloads = true);\n+    static VarExp *create(const Loc &loc, Declaration *var, bool hasOverloads = true);\n     bool equals(const RootObject *o) const;\n     bool isLvalue();\n     Expression *toLvalue(Scope *sc, Expression *e);\n@@ -746,8 +748,9 @@ class DotIdExp : public UnaExp\n     Identifier *ident;\n     bool noderef;       // true if the result of the expression will never be dereferenced\n     bool wantsym;       // do not replace Symbol with its initializer during semantic()\n+    bool arrow;         // ImportC: if -> instead of .\n \n-    static DotIdExp *create(Loc loc, Expression *e, Identifier *ident);\n+    static DotIdExp *create(const Loc &loc, Expression *e, Identifier *ident);\n     void accept(Visitor *v) { v->visit(this); }\n };\n \n@@ -780,6 +783,8 @@ class DotTemplateInstanceExp : public UnaExp\n \n     DotTemplateInstanceExp *syntaxCopy();\n     bool findTempDecl(Scope *sc);\n+    bool checkType();\n+    bool checkValue();\n     void accept(Visitor *v) { v->visit(this); }\n };\n \n@@ -812,10 +817,10 @@ class CallExp : public UnaExp\n     bool ignoreAttributes;      // don't enforce attributes (e.g. call @gc function in @nogc code)\n     VarDeclaration *vthis2;     // container for multi-context\n \n-    static CallExp *create(Loc loc, Expression *e, Expressions *exps);\n-    static CallExp *create(Loc loc, Expression *e);\n-    static CallExp *create(Loc loc, Expression *e, Expression *earg1);\n-    static CallExp *create(Loc loc, FuncDeclaration *fd, Expression *earg1);\n+    static CallExp *create(const Loc &loc, Expression *e, Expressions *exps);\n+    static CallExp *create(const Loc &loc, Expression *e);\n+    static CallExp *create(const Loc &loc, Expression *e, Expression *earg1);\n+    static CallExp *create(const Loc &loc, FuncDeclaration *fd, Expression *earg1);\n \n     CallExp *syntaxCopy();\n     bool isLvalue();\n@@ -893,8 +898,8 @@ class VectorExp : public UnaExp\n     unsigned dim;               // number of elements in the vector\n     OwnedBy ownedByCtfe;\n \n-    static VectorExp *create(Loc loc, Expression *e, Type *t);\n-    static void emplace(UnionExp *pue, Loc loc, Expression *e, Type *t);\n+    static VectorExp *create(const Loc &loc, Expression *e, Type *t);\n+    static void emplace(UnionExp *pue, const Loc &loc, Expression *e, Type *t);\n     VectorExp *syntaxCopy();\n     void accept(Visitor *v) { v->visit(this); }\n };\n@@ -1272,7 +1277,7 @@ class CondExp : public BinExp\n \n class GenericExp : Expression\n {\n-    Expression cntlExp;\n+    Expression *cntlExp;\n     Types *types;\n     Expressions *exps;\n "}, {"sha": "8e152d6a1fcce2a81362f49ddcfcbcbe7f1869a6", "filename": "gcc/d/dmd/expressionsem.d", "status": "modified", "additions": 275, "deletions": 151, "changes": 426, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -43,12 +43,14 @@ import dmd.dtemplate;\n import dmd.errors;\n import dmd.escape;\n import dmd.expression;\n+import dmd.file_manager;\n import dmd.func;\n import dmd.globals;\n import dmd.hdrgen;\n import dmd.id;\n import dmd.identifier;\n import dmd.imphint;\n+import dmd.importc;\n import dmd.init;\n import dmd.initsem;\n import dmd.inline;\n@@ -62,7 +64,7 @@ import dmd.printast;\n import dmd.root.ctfloat;\n import dmd.root.file;\n import dmd.root.filename;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.root.rootobject;\n import dmd.root.string;\n import dmd.semantic2;\n@@ -1239,6 +1241,10 @@ private Expression resolvePropertiesX(Scope* sc, Expression e1, Expression e2 =\n         tthis = dve.e1.type;\n         goto Lfd;\n     }\n+    else if (sc && sc.flags & SCOPE.Cfile && e1.op == TOK.variable && !e2)\n+    {\n+        // ImportC: do not implicitly call function if no ( ) are present\n+    }\n     else if (e1.op == TOK.variable && e1.type && (e1.type.toBasetype().ty == Tfunction || (cast(VarExp)e1).var.isOverDeclaration()))\n     {\n         s = (cast(VarExp)e1).var;\n@@ -1388,7 +1394,6 @@ private Type arrayExpressionToCommonType(Scope* sc, ref Expressions exps)\n \n     Type t0 = null;\n     Expression e0 = null;\n-    size_t j0 = ~0;\n     bool foundType;\n \n     for (size_t i = 0; i < exps.dim; i++)\n@@ -1441,17 +1446,16 @@ private Type arrayExpressionToCommonType(Scope* sc, ref Expressions exps)\n             {\n                 // https://issues.dlang.org/show_bug.cgi?id=21285\n                 // Functions and delegates don't convert correctly with castTo below\n-                exps[j0] = condexp.e1;\n+                exps[i] = condexp.e1;\n                 e = condexp.e2;\n             }\n             else\n             {\n                 // Convert to common type\n-                exps[j0] = condexp.e1.castTo(sc, condexp.type);\n+                exps[i] = condexp.e1.castTo(sc, condexp.type);\n                 e = condexp.e2.castTo(sc, condexp.type);\n             }\n         }\n-        j0 = i;\n         e0 = e;\n         t0 = e.type;\n         if (e.op != TOK.error)\n@@ -1599,6 +1603,7 @@ private bool preFunctionParameters(Scope* sc, Expressions* exps, const bool repo\n         {\n             Expression arg = (*exps)[i];\n             arg = resolveProperties(sc, arg);\n+            arg = arg.arrayFuncConv(sc);\n             if (arg.op == TOK.type)\n             {\n                 // for static alias this: https://issues.dlang.org/show_bug.cgi?id=17684\n@@ -4297,7 +4302,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n          *  expr.foo!(tiargs)(funcargs)\n          */\n     Ldotti:\n-        if (exp.e1.op == TOK.dotTemplateInstance && !exp.e1.type)\n+        if (exp.e1.op == TOK.dotTemplateInstance)\n         {\n             DotTemplateInstanceExp se = cast(DotTemplateInstanceExp)exp.e1;\n             TemplateInstance ti = se.ti;\n@@ -4352,7 +4357,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                  * We handle such earlier, so go back.\n                  * Note that in the rewrite, we carefully did not run semantic() on e1\n                  */\n-                if (exp.e1.op == TOK.dotTemplateInstance && !exp.e1.type)\n+                if (exp.e1.op == TOK.dotTemplateInstance)\n                 {\n                     goto Ldotti;\n                 }\n@@ -4419,14 +4424,34 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             }\n             else if (exp.e1.op == TOK.type && (sc && sc.flags & SCOPE.Cfile))\n             {\n+                const numArgs = exp.arguments ? exp.arguments.length : 0;\n+                if (e1org.parens && numArgs >= 1)\n+                {\n+                    /* Ambiguous cases arise from CParser where there is not enough\n+                     * information to determine if we have a function call or a cast.\n+                     *   ( type-name ) ( identifier ) ;\n+                     *   ( identifier ) ( identifier ) ;\n+                     * If exp.e1 is a type-name, then this is a cast.\n+                     */\n+                    Expression arg;\n+                    foreach (a; (*exp.arguments)[])\n+                    {\n+                        arg = arg ? new CommaExp(a.loc, arg, a) : a;\n+                    }\n+                    auto t = exp.e1.isTypeExp().type;\n+                    auto e = new CastExp(exp.loc, arg, t);\n+                    result = e.expressionSemantic(sc);\n+                    return;\n+                }\n+\n                 /* Ambiguous cases arise from CParser where there is not enough\n                  * information to determine if we have a function call or declaration.\n                  *   type-name ( identifier ) ;\n                  *   identifier ( identifier ) ;\n                  * If exp.e1 is a type-name, then this is a declaration. C11 does not\n                  * have type construction syntax, so don't convert this to a cast().\n                  */\n-                if (exp.arguments && exp.arguments.dim == 1)\n+                if (numArgs == 1)\n                 {\n                     Expression arg = (*exp.arguments)[0];\n                     if (auto ie = (*exp.arguments)[0].isIdentifierExp())\n@@ -4638,15 +4663,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         {\n             UnaExp ue = cast(UnaExp)exp.e1;\n \n-            Expression ue1 = ue.e1;\n-            Expression ue1old = ue1; // need for 'right this' check\n-            VarDeclaration v;\n-            if (ue1.op == TOK.variable && (v = (cast(VarExp)ue1).var.isVarDeclaration()) !is null && v.needThis())\n-            {\n-                ue.e1 = new TypeExp(ue1.loc, ue1.type);\n-                ue1 = null;\n-            }\n-\n+            Expression ue1old = ue.e1; // need for 'right this' check\n             DotVarExp dve;\n             DotTemplateExp dte;\n             Dsymbol s;\n@@ -4665,7 +4682,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             }\n \n             // Do overload resolution\n-            exp.f = resolveFuncCall(exp.loc, sc, s, tiargs, ue1 ? ue1.type : null, exp.arguments, FuncResolveFlag.standard);\n+            exp.f = resolveFuncCall(exp.loc, sc, s, tiargs, ue.e1.type, exp.arguments, FuncResolveFlag.standard);\n             if (!exp.f || exp.f.errors || exp.f.type.ty == Terror)\n                 return setError();\n \n@@ -4677,7 +4694,6 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 auto ad2 = b.sym;\n                 ue.e1 = ue.e1.castTo(sc, ad2.type.addMod(ue.e1.type.mod));\n                 ue.e1 = ue.e1.expressionSemantic(sc);\n-                ue1 = ue.e1;\n                 auto vi = exp.f.findVtblIndex(&ad2.vtbl, cast(int)ad2.vtbl.dim);\n                 assert(vi >= 0);\n                 exp.f = ad2.vtbl[vi].isFuncDeclaration();\n@@ -6036,17 +6052,29 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         }\n \n         {\n-            auto readResult = File.read(name);\n-            if (!readResult.success)\n+            auto fileName = FileName(name.toDString);\n+            if (auto fmResult = FileManager.fileManager.lookup(fileName))\n             {\n-                e.error(\"cannot read file `%s`\", name);\n-                return setError();\n+                se = new StringExp(e.loc, fmResult.data);\n             }\n             else\n             {\n-                // take ownership of buffer (probably leaking)\n-                auto data = readResult.extractSlice();\n-                se = new StringExp(e.loc, data);\n+                auto readResult = File.read(name);\n+                if (!readResult.success)\n+                {\n+                    e.error(\"cannot read file `%s`\", name);\n+                    return setError();\n+                }\n+                else\n+                {\n+                    // take ownership of buffer (probably leaking)\n+                    auto data = readResult.extractSlice();\n+                    se = new StringExp(e.loc, data);\n+\n+                    FileBuffer* fileBuffer = FileBuffer.create();\n+                    fileBuffer.data = data;\n+                    FileManager.fileManager.add(fileName, fileBuffer);\n+                }\n             }\n         }\n         result = se.expressionSemantic(sc);\n@@ -6357,7 +6385,11 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 result = e;\n                 return;\n             }\n-            exp.type = Type.tnoreturn;\n+\n+            // Only override the type when it isn't already some flavour of noreturn,\n+            // e.g. when this assert was generated by defaultInitLiteral\n+            if (!exp.type || !exp.type.isTypeNoreturn())\n+                exp.type = Type.tnoreturn;\n         }\n         else\n             exp.type = Type.tvoid;\n@@ -6374,12 +6406,53 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             printf(\"DotIdExp::semantic(this = %p, '%s')\\n\", exp, exp.toChars());\n             //printf(\"e1.op = %d, '%s'\\n\", e1.op, Token::toChars(e1.op));\n         }\n+        if (exp.arrow) // ImportC only\n+            exp.e1 = exp.e1.expressionSemantic(sc).arrayFuncConv(sc);\n+\n+        if (sc.flags & SCOPE.Cfile)\n+        {\n+            if (exp.ident == Id.__xalignof && exp.e1.isTypeExp())\n+            {\n+                // C11 6.5.3 says _Alignof only applies to types\n+                Expression e;\n+                Type t;\n+                Dsymbol s;\n+                dmd.typesem.resolve(exp.e1.type, exp.e1.loc, sc, e, t, s, true);\n+                if (e)\n+                {\n+                    exp.e1.error(\"argument to `_Alignof` must be a type\");\n+                    return setError();\n+                }\n+                else if (t)\n+                {\n+                    result = new IntegerExp(exp.loc, t.alignsize, Type.tsize_t);\n+                }\n+                else if (s)\n+                {\n+                    exp.e1.error(\"argument to `_Alignof` must be a type\");\n+                    return setError();\n+                }\n+                else\n+                    assert(0);\n+                return;\n+            }\n+        }\n+\n+        if (sc.flags & SCOPE.Cfile && exp.ident != Id.__sizeof)\n+        {\n+            result = fieldLookup(exp.e1, sc, exp.ident);\n+            return;\n+        }\n+\n         Expression e = exp.semanticY(sc, 1);\n+\n         if (e && isDotOpDispatch(e))\n         {\n+            auto ode = e;\n             uint errors = global.startGagging();\n             e = resolvePropertiesX(sc, e);\n-            if (global.endGagging(errors))\n+            // Any error or if 'e' is not resolved, go to UFCS\n+            if (global.endGagging(errors) || e is ode)\n                 e = null; /* fall down to UFCS */\n             else\n             {\n@@ -6580,10 +6653,17 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         {\n             printf(\"DotTemplateInstanceExp::semantic('%s')\\n\", exp.toChars());\n         }\n+        if (exp.type)\n+        {\n+            result = exp;\n+            return;\n+        }\n         // Indicate we need to resolve by UFCS.\n         Expression e = exp.semanticY(sc, 1);\n         if (!e)\n             e = resolveUFCSProperties(sc, exp);\n+        if (e is exp)\n+            e.type = Type.tvoid; // Unresolved type, because it needs inference\n         result = e;\n     }\n \n@@ -7908,6 +7988,16 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                     dinteger_t length = el.toInteger();\n                     auto bounds = IntRange(SignExtendedNumber(0), SignExtendedNumber(length));\n                     exp.upperIsInBounds = bounds.contains(uprRange);\n+                    if (exp.lwr.op == TOK.int64 && exp.upr.op == TOK.int64 && exp.lwr.toInteger() > exp.upr.toInteger())\n+                    {\n+                        exp.error(\"in slice `%s[%llu .. %llu]`, lower bound is greater than upper bound\", exp.e1.toChars, exp.lwr.toInteger(), exp.upr.toInteger());\n+                        return setError();\n+                    }\n+                    if (exp.upr.op == TOK.int64 && exp.upr.toInteger() > length)\n+                    {\n+                        exp.error(\"in slice `%s[%llu .. %llu]`, upper bound is greater than array length `%llu`\", exp.e1.toChars, exp.lwr.toInteger(), exp.upr.toInteger(), length);\n+                        return setError();\n+                    }\n                 }\n                 else if (exp.upr.op == TOK.int64 && exp.upr.toInteger() == 0)\n                 {\n@@ -7965,6 +8055,11 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             printf(\"ArrayExp::semantic('%s')\\n\", exp.toChars());\n         }\n         assert(!exp.type);\n+\n+        result = exp.carraySemantic(sc);  // C semantics\n+        if (result)\n+            return;\n+\n         Expression e = exp.op_overload(sc);\n         if (e)\n         {\n@@ -8019,6 +8114,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n \n     override void visit(CommaExp e)\n     {\n+        //printf(\"Semantic.CommaExp() %s\\n\", e.toChars());\n         if (e.type)\n         {\n             result = e;\n@@ -8042,10 +8138,13 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         if (checkNonAssignmentArrayOp(e.e1))\n             return setError();\n \n+        // Comma expressions trigger this conversion\n+        e.e2 = e.e2.arrayFuncConv(sc);\n+\n         e.type = e.e2.type;\n         if (e.type is Type.tvoid)\n             discardValue(e.e1);\n-        else if (!e.allowCommaExp && !e.isGenerated)\n+        else if (!e.allowCommaExp && !e.isGenerated && !(sc.flags & SCOPE.Cfile))\n             e.error(\"Using the result of a comma expression is not allowed\");\n         result = e;\n     }\n@@ -8143,7 +8242,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n \n         // operator overloading should be handled in ArrayExp already.\n         if (!exp.e1.type)\n-            exp.e1 = exp.e1.expressionSemantic(sc);\n+            exp.e1 = exp.e1.expressionSemantic(sc).arrayFuncConv(sc);\n         assert(exp.e1.type); // semantic() should already be run on it\n         if (exp.e1.op == TOK.type && exp.e1.type.ty != Ttuple)\n         {\n@@ -8191,7 +8290,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         }\n         if (t1b.ty == Ttuple)\n             sc = sc.startCTFE();\n-        exp.e2 = exp.e2.expressionSemantic(sc);\n+        exp.e2 = exp.e2.expressionSemantic(sc).arrayFuncConv(sc);\n         exp.e2 = resolveProperties(sc, exp.e2);\n         if (t1b.ty == Ttuple)\n             sc = sc.endCTFE();\n@@ -8515,7 +8614,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n \n         if (auto e2comma = exp.e2.isCommaExp())\n         {\n-            if (!e2comma.isGenerated)\n+            if (!e2comma.isGenerated && !(sc.flags & SCOPE.Cfile))\n                 exp.error(\"Using the result of a comma expression is not allowed\");\n \n             /* Rewrite to get rid of the comma from rvalue\n@@ -8659,6 +8758,11 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n \n                 e1x = e;\n             }\n+            else if (sc.flags & SCOPE.Cfile && e1x.isDotIdExp())\n+            {\n+                auto die = e1x.isDotIdExp();\n+                e1x = fieldLookup(die.e1, sc, die.ident);\n+            }\n             else if (auto die = e1x.isDotIdExp())\n             {\n                 Expression e = die.semanticY(sc, 1);\n@@ -8672,10 +8776,12 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                      * In order to make sure that UFCS is tried with correct parameters, e2\n                      * needs to have semantic ran on it.\n                      */\n+                    auto ode = e;\n                     exp.e2 = exp.e2.expressionSemantic(sc);\n                     uint errors = global.startGagging();\n                     e = resolvePropertiesX(sc, e, exp.e2);\n-                    if (global.endGagging(errors))\n+                    // Any error or if 'e' is not resolved, go to UFCS\n+                    if (global.endGagging(errors) || e is ode)\n                         e = null; /* fall down to UFCS */\n                     else\n                         return setResult(e);\n@@ -8717,12 +8823,14 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         {\n             Expression e2x = inferType(exp.e2, t1.baseElemOf());\n             e2x = e2x.expressionSemantic(sc);\n+            if (!t1.isTypeSArray())\n+                e2x = e2x.arrayFuncConv(sc);\n             e2x = resolveProperties(sc, e2x);\n             if (e2x.op == TOK.type)\n                 e2x = resolveAliasThis(sc, e2x); //https://issues.dlang.org/show_bug.cgi?id=17684\n             if (e2x.op == TOK.error)\n                 return setResult(e2x);\n-            // We skip checking the value for structs/classes as these might have\n+            // We delay checking the value for structs/classes as these might have\n             // an opAssign defined.\n             if ((t1.ty != Tstruct && t1.ty != Tclass && e2x.checkValue()) ||\n                 e2x.checkSharedAccess(sc))\n@@ -9208,6 +9316,9 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             else\n                 assert(exp.op == TOK.blit);\n \n+            if (e2x.checkValue())\n+                return setError();\n+\n             exp.e1 = e1x;\n             exp.e2 = e2x;\n         }\n@@ -9223,6 +9334,8 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                     return;\n                 }\n             }\n+            if (exp.e2.checkValue())\n+                return setError();\n         }\n         else if (t1.ty == Tsarray)\n         {\n@@ -9672,7 +9785,13 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         exp.type = exp.e1.type;\n         assert(exp.type);\n         auto res = exp.op == TOK.assign ? exp.reorderSettingAAElem(sc) : exp;\n-        checkAssignEscape(sc, res, false);\n+        Expression tmp;\n+        /* https://issues.dlang.org/show_bug.cgi?id=22366\n+         *\n+         * `reorderSettingAAElem` creates a tree of comma expressions, however,\n+         * `checkAssignExp` expects only AssignExps.\n+         */\n+        checkAssignEscape(sc, Expression.extractLast(res, tmp), false);\n         return setResult(res);\n     }\n \n@@ -9944,6 +10063,11 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             return;\n         }\n \n+        /* ImportC: convert arrays to pointers, functions to pointers to functions\n+         */\n+        exp.e1 = exp.e1.arrayFuncConv(sc);\n+        exp.e2 = exp.e2.arrayFuncConv(sc);\n+\n         Type tb1 = exp.e1.type.toBasetype();\n         Type tb2 = exp.e2.type.toBasetype();\n \n@@ -10045,6 +10169,11 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             return;\n         }\n \n+        /* ImportC: convert arrays to pointers, functions to pointers to functions\n+         */\n+        exp.e1 = exp.e1.arrayFuncConv(sc);\n+        exp.e2 = exp.e2.arrayFuncConv(sc);\n+\n         Type t1 = exp.e1.type.toBasetype();\n         Type t2 = exp.e2.type.toBasetype();\n \n@@ -11539,12 +11668,12 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         ec = ec.toBoolean(sc);\n \n         CtorFlow ctorflow_root = sc.ctorflow.clone();\n-        Expression e1x = exp.e1.expressionSemantic(sc);\n+        Expression e1x = exp.e1.expressionSemantic(sc).arrayFuncConv(sc);\n         e1x = resolveProperties(sc, e1x);\n \n         CtorFlow ctorflow1 = sc.ctorflow;\n         sc.ctorflow = ctorflow_root;\n-        Expression e2x = exp.e2.expressionSemantic(sc);\n+        Expression e2x = exp.e2.expressionSemantic(sc).arrayFuncConv(sc);\n         e2x = resolveProperties(sc, e2x);\n \n         sc.merge(exp.loc, ctorflow1);\n@@ -11894,95 +12023,84 @@ Expression semanticX(DotIdExp exp, Scope* sc)\n     if (exp.ident == Id._mangleof)\n     {\n         // symbol.mangleof\n-        Dsymbol ds;\n-        switch (exp.e1.op)\n+\n+        // return mangleof as an Expression\n+        static Expression dotMangleof(const ref Loc loc, Scope* sc, Dsymbol ds)\n         {\n-        case TOK.scope_:\n-            ds = (cast(ScopeExp)exp.e1).sds;\n-            goto L1;\n-        case TOK.variable:\n-            ds = (cast(VarExp)exp.e1).var;\n-            goto L1;\n-        case TOK.dotVariable:\n-            ds = (cast(DotVarExp)exp.e1).var;\n-            goto L1;\n-        case TOK.overloadSet:\n-            ds = (cast(OverExp)exp.e1).vars;\n-            goto L1;\n-        case TOK.template_:\n-            {\n-                TemplateExp te = cast(TemplateExp)exp.e1;\n-                ds = te.fd ? cast(Dsymbol)te.fd : te.td;\n-            }\n-        L1:\n+            assert(ds);\n+            if (auto f = ds.isFuncDeclaration())\n             {\n-                assert(ds);\n-                if (auto f = ds.isFuncDeclaration())\n+                if (f.checkForwardRef(loc))\n+                    return ErrorExp.get();\n+\n+                if (f.flags & (FUNCFLAG.purityInprocess | FUNCFLAG.safetyInprocess |\n+                               FUNCFLAG.nothrowInprocess | FUNCFLAG.nogcInprocess))\n                 {\n-                    if (f.checkForwardRef(exp.loc))\n-                    {\n-                        return ErrorExp.get();\n-                    }\n-                    if (f.flags & (FUNCFLAG.purityInprocess | FUNCFLAG.safetyInprocess |\n-                                   FUNCFLAG.nothrowInprocess | FUNCFLAG.nogcInprocess))\n-                    {\n-                        f.error(exp.loc, \"cannot retrieve its `.mangleof` while inferring attributes\");\n-                        return ErrorExp.get();\n-                    }\n+                    f.error(loc, \"cannot retrieve its `.mangleof` while inferring attributes\");\n+                    return ErrorExp.get();\n                 }\n-                OutBuffer buf;\n-                mangleToBuffer(ds, &buf);\n-                Expression e = new StringExp(exp.loc, buf.extractSlice());\n-                e = e.expressionSemantic(sc);\n-                return e;\n             }\n-        default:\n-            break;\n+            OutBuffer buf;\n+            mangleToBuffer(ds, &buf);\n+            Expression e = new StringExp(loc, buf.extractSlice());\n+            return e.expressionSemantic(sc);\n+        }\n+\n+        Dsymbol ds;\n+        switch (exp.e1.op)\n+        {\n+            case TOK.scope_:      return dotMangleof(exp.loc, sc, exp.e1.isScopeExp().sds);\n+            case TOK.variable:    return dotMangleof(exp.loc, sc, exp.e1.isVarExp().var);\n+            case TOK.dotVariable: return dotMangleof(exp.loc, sc, exp.e1.isDotVarExp().var);\n+            case TOK.overloadSet: return dotMangleof(exp.loc, sc, exp.e1.isOverExp().vars);\n+            case TOK.template_:\n+            {\n+                TemplateExp te = exp.e1.isTemplateExp();\n+                return dotMangleof(exp.loc, sc, ds = te.fd ? te.fd.isDsymbol() : te.td);\n+            }\n+\n+            default:\n+                break;\n         }\n     }\n \n-    if (exp.e1.op == TOK.variable && exp.e1.type.toBasetype().ty == Tsarray && exp.ident == Id.length)\n+    if (exp.e1.isVarExp() && exp.e1.type.toBasetype().isTypeSArray() && exp.ident == Id.length)\n     {\n         // bypass checkPurity\n         return exp.e1.type.dotExp(sc, exp.e1, exp.ident, exp.noderef ? DotExpFlag.noDeref : 0);\n     }\n \n-    if (exp.e1.op == TOK.dot)\n-    {\n-    }\n-    else\n+    if (!exp.e1.isDotExp())\n     {\n         exp.e1 = resolvePropertiesX(sc, exp.e1);\n     }\n-    if (exp.e1.op == TOK.tuple && exp.ident == Id.offsetof)\n+\n+    if (auto te = exp.e1.isTupleExp())\n     {\n-        /* 'distribute' the .offsetof to each of the tuple elements.\n-         */\n-        TupleExp te = cast(TupleExp)exp.e1;\n-        auto exps = new Expressions(te.exps.dim);\n-        for (size_t i = 0; i < exps.dim; i++)\n+        if (exp.ident == Id.offsetof)\n         {\n-            Expression e = (*te.exps)[i];\n+            /* 'distribute' the .offsetof to each of the tuple elements.\n+             */\n+            auto exps = new Expressions(te.exps.dim);\n+            foreach (i, e; (*te.exps)[])\n+            {\n+                (*exps)[i] = new DotIdExp(e.loc, e, Id.offsetof);\n+            }\n+            // Don't evaluate te.e0 in runtime\n+            Expression e = new TupleExp(exp.loc, null, exps);\n             e = e.expressionSemantic(sc);\n-            e = new DotIdExp(e.loc, e, Id.offsetof);\n-            (*exps)[i] = e;\n+            return e;\n+        }\n+        if (exp.ident == Id.length)\n+        {\n+            // Don't evaluate te.e0 in runtime\n+            return new IntegerExp(exp.loc, te.exps.dim, Type.tsize_t);\n         }\n-        // Don't evaluate te.e0 in runtime\n-        Expression e = new TupleExp(exp.loc, null, exps);\n-        e = e.expressionSemantic(sc);\n-        return e;\n-    }\n-    if (exp.e1.op == TOK.tuple && exp.ident == Id.length)\n-    {\n-        TupleExp te = cast(TupleExp)exp.e1;\n-        // Don't evaluate te.e0 in runtime\n-        Expression e = new IntegerExp(exp.loc, te.exps.dim, Type.tsize_t);\n-        return e;\n     }\n \n     // https://issues.dlang.org/show_bug.cgi?id=14416\n     // Template has no built-in properties except for 'stringof'.\n-    if ((exp.e1.op == TOK.dotTemplateDeclaration || exp.e1.op == TOK.template_) && exp.ident != Id.stringof)\n+    if ((exp.e1.isDotTemplateExp() || exp.e1.isTemplateExp()) && exp.ident != Id.stringof)\n     {\n         exp.error(\"template `%s` does not have property `%s`\", exp.e1.toChars(), exp.ident.toChars());\n         return ErrorExp.get();\n@@ -11996,8 +12114,15 @@ Expression semanticX(DotIdExp exp, Scope* sc)\n     return exp;\n }\n \n-// Resolve e1.ident without seeing UFCS.\n-// If flag == 1, stop \"not a property\" error and return NULL.\n+/******************************\n+ * Resolve properties, i.e. `e1.ident`, without seeing UFCS.\n+ * Params:\n+ *      exp = expression to resolve\n+ *      sc = context\n+ *      flag = if 1 then do not emit error messages, just return null\n+ * Returns:\n+ *      resolved expression, null if error\n+ */\n Expression semanticY(DotIdExp exp, Scope* sc, int flag)\n {\n     //printf(\"DotIdExp::semanticY(this = %p, '%s')\\n\", exp, exp.toChars());\n@@ -12008,32 +12133,35 @@ Expression semanticY(DotIdExp exp, Scope* sc, int flag)\n      * to be classtype.id and baseclasstype.id\n      * if we have no this pointer.\n      */\n-    if ((exp.e1.op == TOK.this_ || exp.e1.op == TOK.super_) && !hasThis(sc))\n+    if ((exp.e1.isThisExp() || exp.e1.isSuperExp()) && !hasThis(sc))\n     {\n         if (AggregateDeclaration ad = sc.getStructClassScope())\n         {\n-            if (exp.e1.op == TOK.this_)\n+            if (exp.e1.isThisExp())\n             {\n                 exp.e1 = new TypeExp(exp.e1.loc, ad.type);\n             }\n             else\n             {\n-                ClassDeclaration cd = ad.isClassDeclaration();\n-                if (cd && cd.baseClass)\n-                    exp.e1 = new TypeExp(exp.e1.loc, cd.baseClass.type);\n+                if (auto cd = ad.isClassDeclaration())\n+                {\n+                    if (cd.baseClass)\n+                        exp.e1 = new TypeExp(exp.e1.loc, cd.baseClass.type);\n+                }\n             }\n         }\n     }\n \n-    Expression e = semanticX(exp, sc);\n-    if (e != exp)\n-        return e;\n+    {\n+        Expression e = semanticX(exp, sc);\n+        if (e != exp)\n+            return e;\n+    }\n \n     Expression eleft;\n     Expression eright;\n-    if (exp.e1.op == TOK.dot)\n+    if (auto de = exp.e1.isDotExp())\n     {\n-        DotExp de = cast(DotExp)exp.e1;\n         eleft = de.e1;\n         eright = de.e2;\n     }\n@@ -12045,11 +12173,9 @@ Expression semanticY(DotIdExp exp, Scope* sc, int flag)\n \n     Type t1b = exp.e1.type.toBasetype();\n \n-    if (eright.op == TOK.scope_) // also used for template alias's\n+    if (auto ie = eright.isScopeExp()) // also used for template alias's\n     {\n-        ScopeExp ie = cast(ScopeExp)eright;\n-\n-        int flags = SearchLocalsOnly;\n+        auto flags = SearchLocalsOnly;\n         /* Disable access to another module's private imports.\n          * The check for 'is sds our current module' is because\n          * the current module should have access to its own imports.\n@@ -12082,13 +12208,11 @@ Expression semanticY(DotIdExp exp, Scope* sc, int flag)\n             exp.checkDeprecated(sc, s);\n             exp.checkDisabled(sc, s);\n \n-            EnumMember em = s.isEnumMember();\n-            if (em)\n+            if (auto em = s.isEnumMember())\n             {\n                 return em.getVarExp(exp.loc, sc);\n             }\n-            VarDeclaration v = s.isVarDeclaration();\n-            if (v)\n+            if (auto v = s.isVarDeclaration())\n             {\n                 //printf(\"DotIdExp:: Identifier '%s' is a variable, type '%s'\\n\", toChars(), v.type.toChars());\n                 if (!v.type ||\n@@ -12100,7 +12224,7 @@ Expression semanticY(DotIdExp exp, Scope* sc, int flag)\n                         exp.error(\"forward reference to %s `%s`\", v.kind(), v.toPrettyChars());\n                     return ErrorExp.get();\n                 }\n-                if (v.type.ty == Terror)\n+                if (v.type.isTypeError())\n                     return ErrorExp.get();\n \n                 if ((v.storage_class & STC.manifest) && v._init && !exp.wantsym)\n@@ -12114,13 +12238,14 @@ Expression semanticY(DotIdExp exp, Scope* sc, int flag)\n                         error(exp.loc, \"circular initialization of %s `%s`\", v.kind(), v.toPrettyChars());\n                         return ErrorExp.get();\n                     }\n-                    e = v.expandInitializer(exp.loc);\n+                    auto e = v.expandInitializer(exp.loc);\n                     v.inuse++;\n                     e = e.expressionSemantic(sc);\n                     v.inuse--;\n                     return e;\n                 }\n \n+                Expression e;\n                 if (v.needThis())\n                 {\n                     if (!eleft)\n@@ -12141,12 +12266,12 @@ Expression semanticY(DotIdExp exp, Scope* sc, int flag)\n                 return e.expressionSemantic(sc);\n             }\n \n-            FuncDeclaration f = s.isFuncDeclaration();\n-            if (f)\n+            if (auto f = s.isFuncDeclaration())\n             {\n                 //printf(\"it's a function\\n\");\n                 if (!f.functionSemantic())\n                     return ErrorExp.get();\n+                Expression e;\n                 if (f.needThis())\n                 {\n                     if (!eleft)\n@@ -12167,6 +12292,7 @@ Expression semanticY(DotIdExp exp, Scope* sc, int flag)\n             }\n             if (auto td = s.isTemplateDeclaration())\n             {\n+                Expression e;\n                 if (eleft)\n                     e = new DotTemplateExp(exp.loc, eleft, td);\n                 else\n@@ -12176,16 +12302,15 @@ Expression semanticY(DotIdExp exp, Scope* sc, int flag)\n             }\n             if (OverDeclaration od = s.isOverDeclaration())\n             {\n-                e = new VarExp(exp.loc, od, true);\n+                Expression e = new VarExp(exp.loc, od, true);\n                 if (eleft)\n                 {\n                     e = new CommaExp(exp.loc, eleft, e);\n                     e.type = Type.tvoid; // ambiguous type?\n                 }\n                 return e;\n             }\n-            OverloadSet o = s.isOverloadSet();\n-            if (o)\n+            if (auto o = s.isOverloadSet())\n             {\n                 //printf(\"'%s' is an overload set\\n\", o.toChars());\n                 return new OverExp(exp.loc, o);\n@@ -12196,36 +12321,33 @@ Expression semanticY(DotIdExp exp, Scope* sc, int flag)\n                 return (new TypeExp(exp.loc, t)).expressionSemantic(sc);\n             }\n \n-            TupleDeclaration tup = s.isTupleDeclaration();\n-            if (tup)\n+            if (auto tup = s.isTupleDeclaration())\n             {\n                 if (eleft)\n                 {\n-                    e = new DotVarExp(exp.loc, eleft, tup);\n+                    Expression e = new DotVarExp(exp.loc, eleft, tup);\n                     e = e.expressionSemantic(sc);\n                     return e;\n                 }\n-                e = new TupleExp(exp.loc, tup);\n+                Expression e = new TupleExp(exp.loc, tup);\n                 e = e.expressionSemantic(sc);\n                 return e;\n             }\n \n-            ScopeDsymbol sds = s.isScopeDsymbol();\n-            if (sds)\n+            if (auto sds = s.isScopeDsymbol())\n             {\n                 //printf(\"it's a ScopeDsymbol %s\\n\", ident.toChars());\n-                e = new ScopeExp(exp.loc, sds);\n+                Expression e = new ScopeExp(exp.loc, sds);\n                 e = e.expressionSemantic(sc);\n                 if (eleft)\n                     e = new DotExp(exp.loc, eleft, e);\n                 return e;\n             }\n \n-            Import imp = s.isImport();\n-            if (imp)\n+            if (auto imp = s.isImport())\n             {\n-                ie = new ScopeExp(exp.loc, imp.pkg);\n-                return ie.expressionSemantic(sc);\n+                Expression se = new ScopeExp(exp.loc, imp.pkg);\n+                return se.expressionSemantic(sc);\n             }\n             // BUG: handle other cases like in IdentifierExp::semantic()\n             debug\n@@ -12236,7 +12358,7 @@ Expression semanticY(DotIdExp exp, Scope* sc, int flag)\n         }\n         else if (exp.ident == Id.stringof)\n         {\n-            e = new StringExp(exp.loc, ie.toString());\n+            Expression e = new StringExp(exp.loc, ie.toString());\n             e = e.expressionSemantic(sc);\n             return e;\n         }\n@@ -12263,9 +12385,11 @@ Expression semanticY(DotIdExp exp, Scope* sc, int flag)\n         Type t1bn = t1b.nextOf();\n         if (flag)\n         {\n-            AggregateDeclaration ad = isAggregate(t1bn);\n-            if (ad && !ad.members) // https://issues.dlang.org/show_bug.cgi?id=11312\n-                return null;\n+            if (AggregateDeclaration ad = isAggregate(t1bn))\n+            {\n+                if (!ad.members) // https://issues.dlang.org/show_bug.cgi?id=11312\n+                    return null;\n+            }\n         }\n \n         /* Rewrite:\n@@ -12275,27 +12399,27 @@ Expression semanticY(DotIdExp exp, Scope* sc, int flag)\n          */\n         if (flag && t1bn.ty == Tvoid)\n             return null;\n-        e = new PtrExp(exp.loc, exp.e1);\n+        Expression e = new PtrExp(exp.loc, exp.e1);\n         e = e.expressionSemantic(sc);\n         return e.type.dotExp(sc, e, exp.ident, flag | (exp.noderef ? DotExpFlag.noDeref : 0));\n     }\n     else if (exp.ident == Id.__xalignof &&\n              exp.e1.isVarExp() &&\n              exp.e1.isVarExp().var.isVarDeclaration() &&\n-             exp.e1.isVarExp().var.isVarDeclaration().alignment)\n+             !exp.e1.isVarExp().var.isVarDeclaration().alignment.isUnknown())\n     {\n         // For `x.alignof` get the alignment of the variable, not the alignment of its type\n         const explicitAlignment = exp.e1.isVarExp().var.isVarDeclaration().alignment;\n         const naturalAlignment = exp.e1.type.alignsize();\n-        const actualAlignment = (explicitAlignment == STRUCTALIGN_DEFAULT ? naturalAlignment : explicitAlignment);\n-        e = new IntegerExp(exp.loc, actualAlignment, Type.tsize_t);\n+        const actualAlignment = explicitAlignment.isDefault() ? naturalAlignment : explicitAlignment.get();\n+        Expression e = new IntegerExp(exp.loc, actualAlignment, Type.tsize_t);\n         return e;\n     }\n     else\n     {\n-        if (exp.e1.op == TOK.type || exp.e1.op == TOK.template_)\n+        if (exp.e1.isTypeExp() || exp.e1.isTemplateExp())\n             flag = 0;\n-        e = exp.e1.type.dotExp(sc, exp.e1, exp.ident, flag | (exp.noderef ? DotExpFlag.noDeref : 0));\n+        Expression e = exp.e1.type.dotExp(sc, exp.e1, exp.ident, flag | (exp.noderef ? DotExpFlag.noDeref : 0));\n         if (e)\n             e = e.expressionSemantic(sc);\n         return e;\n@@ -12875,7 +12999,7 @@ private bool fit(StructDeclaration sd, const ref Loc loc, Scope* sc, Expressions\n         const hasPointers = tb.hasPointers();\n         if (hasPointers)\n         {\n-            if ((stype.alignment() < target.ptrsize ||\n+            if ((!stype.alignment.isDefault() && stype.alignment.get() < target.ptrsize ||\n                  (v.offset & (target.ptrsize - 1))) &&\n                 (sc.func && sc.func.setUnsafe()))\n             {"}, {"sha": "05aeb7df5dc9bc8e79abab1ff02a9ae3cbfe7a09", "filename": "gcc/d/dmd/file_manager.d", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Ffile_manager.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Ffile_manager.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffile_manager.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,301 @@\n+/**\n+ * Read a file from disk and store it in memory.\n+ *\n+ * Copyright: Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+ * Source:    $(LINK2 https://github.com/dlang/dmd/blob/master/src/dmd/file_manager.d, _file_manager.d)\n+ * Documentation:  https://dlang.org/phobos/dmd_file_manager.html\n+ * Coverage:    https://codecov.io/gh/dlang/dmd/src/master/src/dmd/file_manager.d\n+ */\n+\n+module dmd.file_manager;\n+\n+import dmd.root.stringtable : StringTable;\n+import dmd.root.file : File, FileBuffer;\n+import dmd.root.filename : FileName;\n+import dmd.root.string : toDString;\n+import dmd.globals;\n+import dmd.identifier;\n+\n+enum package_d  = \"package.\" ~ mars_ext;\n+enum package_di = \"package.\" ~ hdr_ext;\n+\n+extern(C++) struct FileManager\n+{\n+    private StringTable!(FileBuffer*) files;\n+    private __gshared bool initialized = false;\n+\n+nothrow:\n+    extern(D) private FileBuffer* readToFileBuffer(const(char)[] filename)\n+    {\n+        if (!initialized)\n+            FileManager._init();\n+\n+        auto readResult = File.read(filename);\n+        if (readResult.success)\n+        {\n+            FileBuffer* fb;\n+            if (auto val = files.lookup(filename))\n+                fb = val.value;\n+\n+            if (!fb)\n+                fb = FileBuffer.create();\n+\n+            fb.data = readResult.extractSlice();\n+\n+            return files.insert(filename, fb) == null ? null : fb;\n+        }\n+        else\n+        {\n+            return null;\n+        }\n+\n+    }\n+\n+    /********************************************\n+    * Look for the source file if it's different from filename.\n+    * Look for .di, .d, directory, and along global.path.\n+    * Does not open the file.\n+    * Params:\n+    *      filename = as supplied by the user\n+    *      path = path to look for filename\n+    * Returns:\n+    *      the found file name or\n+    *      `null` if it is not different from filename.\n+    */\n+    extern(D) static const(char)[] lookForSourceFile(const char[] filename, const char*[] path)\n+    {\n+        //printf(\"lookForSourceFile(`%.*s`)\\n\", cast(int)filename.length, filename.ptr);\n+        /* Search along path[] for .di file, then .d file, then .i file, then .c file.\n+        */\n+        const sdi = FileName.forceExt(filename, hdr_ext);\n+        if (FileName.exists(sdi) == 1)\n+            return sdi;\n+        scope(exit) FileName.free(sdi.ptr);\n+\n+        const sd = FileName.forceExt(filename, mars_ext);\n+        if (FileName.exists(sd) == 1)\n+            return sd;\n+        scope(exit) FileName.free(sd.ptr);\n+\n+        const si = FileName.forceExt(filename, i_ext);\n+        if (FileName.exists(si) == 1)\n+            return si;\n+        scope(exit) FileName.free(si.ptr);\n+\n+        const sc = FileName.forceExt(filename, c_ext);\n+        if (FileName.exists(sc) == 1)\n+            return sc;\n+        scope(exit) FileName.free(sc.ptr);\n+\n+        if (FileName.exists(filename) == 2)\n+        {\n+            /* The filename exists and it's a directory.\n+            * Therefore, the result should be: filename/package.d\n+            * iff filename/package.d is a file\n+            */\n+            const ni = FileName.combine(filename, package_di);\n+            if (FileName.exists(ni) == 1)\n+                return ni;\n+            FileName.free(ni.ptr);\n+\n+            const n = FileName.combine(filename, package_d);\n+            if (FileName.exists(n) == 1)\n+                return n;\n+            FileName.free(n.ptr);\n+        }\n+        if (FileName.absolute(filename))\n+            return null;\n+        if (!path.length)\n+            return null;\n+        foreach (entry; path)\n+        {\n+            const p = entry.toDString();\n+\n+            const(char)[] n = FileName.combine(p, sdi);\n+            if (FileName.exists(n) == 1) {\n+                return n;\n+            }\n+            FileName.free(n.ptr);\n+\n+            n = FileName.combine(p, sd);\n+            if (FileName.exists(n) == 1) {\n+                return n;\n+            }\n+            FileName.free(n.ptr);\n+\n+            n = FileName.combine(p, si);\n+            if (FileName.exists(n) == 1) {\n+                return n;\n+            }\n+            FileName.free(n.ptr);\n+\n+            n = FileName.combine(p, sc);\n+            if (FileName.exists(n) == 1) {\n+                return n;\n+            }\n+            FileName.free(n.ptr);\n+\n+            const b = FileName.removeExt(filename);\n+            n = FileName.combine(p, b);\n+            FileName.free(b.ptr);\n+            if (FileName.exists(n) == 2)\n+            {\n+                const n2i = FileName.combine(n, package_di);\n+                if (FileName.exists(n2i) == 1)\n+                    return n2i;\n+                FileName.free(n2i.ptr);\n+                const n2 = FileName.combine(n, package_d);\n+                if (FileName.exists(n2) == 1) {\n+                    return n2;\n+                }\n+                FileName.free(n2.ptr);\n+            }\n+            FileName.free(n.ptr);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Looks up the given filename from the internal file buffer table.\n+     * If the file does not already exist within the table, it will be read from the filesystem.\n+     * If it has been read before,\n+     *\n+     * Returns: the loaded source file if it was found in memory,\n+     *      otherwise `null`\n+     */\n+    extern(D) FileBuffer* lookup(FileName filename)\n+    {\n+        if (!initialized)\n+            FileManager._init();\n+\n+        if (auto val = files.lookup(filename.toString))\n+        {\n+            // There is a chance that the buffer could've been\n+            // stolen by a reader with extractSlice, so we should\n+            // try and do our reading logic if that happens.\n+            if (val !is null && val.value.data !is null)\n+            {\n+                return val.value;\n+            }\n+        }\n+\n+        const name = filename.toString;\n+        auto res = FileName.exists(name);\n+        if (res == 1)\n+            return readToFileBuffer(name);\n+\n+        const fullName = lookForSourceFile(name, global.path ? (*global.path)[] : null);\n+        if (!fullName)\n+            return null;\n+\n+        return readToFileBuffer(fullName);\n+    }\n+\n+    extern(C++) FileBuffer* lookup(const(char)* filename)\n+    {\n+        return lookup(FileName(filename.toDString));\n+    }\n+\n+    /**\n+     * Looks up the given filename from the internal file buffer table, and returns the lines within the file.\n+     * If the file does not already exist within the table, it will be read from the filesystem.\n+     * If it has been read before,\n+     *\n+     * Returns: the loaded source file if it was found in memory,\n+     *      otherwise `null`\n+     */\n+    extern(D) const(char)[][] getLines(FileName file)\n+    {\n+        if (!initialized)\n+            FileManager._init();\n+\n+        const(char)[][] lines;\n+        if (FileBuffer* buffer = lookup(file))\n+        {\n+            ubyte[] slice = buffer.data[0 .. buffer.data.length];\n+            size_t start, end;\n+            ubyte c;\n+            for (auto i = 0; i < slice.length; i++)\n+            {\n+                c = slice[i];\n+                if (c == '\\n' || c == '\\r')\n+                {\n+                    if (i != 0)\n+                    {\n+                        end = i;\n+                        lines ~= cast(const(char)[])slice[start .. end];\n+                    }\n+                    // Check for Windows-style CRLF newlines\n+                    if (c == '\\r')\n+                    {\n+                        if (slice.length > i + 1 && slice[i + 1] == '\\n')\n+                        {\n+                            // This is a CRLF sequence, skip over two characters\n+                            start = i + 2;\n+                            i++;\n+                        }\n+                        else\n+                        {\n+                            // Just a CR sequence\n+                            start = i + 1;\n+                        }\n+                    }\n+                    else\n+                    {\n+                        // The next line should start after the LF sequence\n+                        start = i + 1;\n+                    }\n+                }\n+            }\n+\n+            if (slice[$ - 1] != '\\r' && slice[$ - 1] != '\\n')\n+            {\n+                end = slice.length;\n+                lines ~= cast(const(char)[])slice[start .. end];\n+            }\n+        }\n+\n+        return lines;\n+    }\n+\n+    /**\n+     * Adds a FileBuffer to the table.\n+     *\n+     * Returns: The FileBuffer added, or null\n+     */\n+    extern(D) FileBuffer* add(FileName filename, FileBuffer* filebuffer)\n+    {\n+        if (!initialized)\n+            FileManager._init();\n+\n+        auto val = files.insert(filename.toString, filebuffer);\n+        return val == null ? null : val.value;\n+    }\n+\n+    extern(C++) FileBuffer* add(const(char)* filename, FileBuffer* filebuffer)\n+    {\n+        if (!initialized)\n+            FileManager._init();\n+\n+        auto val = files.insert(filename.toDString, filebuffer);\n+        return val == null ? null : val.value;\n+    }\n+\n+    __gshared fileManager = FileManager();\n+\n+    // Initialize the global FileManager singleton\n+    extern(C++) static __gshared void _init()\n+    {\n+        if (!initialized)\n+        {\n+            fileManager.initialize();\n+            initialized = true;\n+        }\n+    }\n+\n+    void initialize()\n+    {\n+        files._init();\n+    }\n+}"}, {"sha": "7488fab17fc23fefce2c906389bba2a40385d8fa", "filename": "gcc/d/dmd/file_manager.h", "status": "renamed", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Ffile_manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Ffile_manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffile_manager.h?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,17 +4,16 @@\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n  * http://www.boost.org/LICENSE_1_0.txt\n- * https://github.com/dlang/dmd/blob/master/src/dmd/root/root.h\n+ * https://github.com/dlang/dmd/blob/master/src/dmd/file_manager.h\n  */\n \n #pragma once\n \n-#include \"object.h\"\n+#include \"root/file.h\"\n \n-#include \"filename.h\"\n-\n-#include \"file.h\"\n-\n-#include \"outbuffer.h\"\n-\n-#include \"array.h\"\n+struct FileManager\n+{\n+    static void _init();\n+    FileBuffer* lookup(const char* filename);\n+    FileBuffer* add(const char* filename, FileBuffer* filebuffer);\n+};", "previous_filename": "gcc/d/dmd/root/root.h"}, {"sha": "2d6a756178e9322c20ae46fc4c24837b7aa68a40", "filename": "gcc/d/dmd/func.d", "status": "modified", "additions": 46, "deletions": 30, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Ffunc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Ffunc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffunc.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -45,7 +45,8 @@ import dmd.identifier;\n import dmd.init;\n import dmd.mtype;\n import dmd.objc;\n-import dmd.root.outbuffer;\n+import dmd.root.aav;\n+import dmd.common.outbuffer;\n import dmd.root.rootobject;\n import dmd.root.string;\n import dmd.root.stringtable;\n@@ -261,6 +262,8 @@ extern (C++) class FuncDeclaration : Declaration\n     VarDeclaration vresult;             /// result variable for out contracts\n     LabelDsymbol returnLabel;           /// where the return goes\n \n+    bool[size_t] isTypeIsolatedCache;   /// cache for the potentially very expensive isTypeIsolated check\n+\n     // used to prevent symbols in different\n     // scopes from having the same name\n     DsymbolTable localsymtab;\n@@ -740,7 +743,7 @@ extern (C++) class FuncDeclaration : Declaration\n      */\n     final BaseClass* overrideInterface()\n     {\n-        if (ClassDeclaration cd = toParent2().isClassDeclaration())\n+        for (ClassDeclaration cd = toParent2().isClassDeclaration(); cd; cd = cd.baseClass)\n         {\n             foreach (b; cd.interfaces)\n             {\n@@ -1529,8 +1532,23 @@ extern (C++) class FuncDeclaration : Declaration\n     extern (D) final bool isTypeIsolated(Type t)\n     {\n         StringTable!Type parentTypes;\n-        parentTypes._init();\n-        return isTypeIsolated(t, parentTypes);\n+        const uniqueTypeID = t.getUniqueID();\n+        if (uniqueTypeID)\n+        {\n+            const cacheResultPtr = uniqueTypeID in isTypeIsolatedCache;\n+            if (cacheResultPtr !is null)\n+                return *cacheResultPtr;\n+\n+            parentTypes._init();\n+            const isIsolated = isTypeIsolated(t, parentTypes);\n+            isTypeIsolatedCache[uniqueTypeID] = isIsolated;\n+            return isIsolated;\n+        }\n+        else\n+        {\n+            parentTypes._init();\n+            return isTypeIsolated(t, parentTypes);\n+        }\n     }\n \n     ///ditto\n@@ -2593,9 +2611,10 @@ extern (C++) class FuncDeclaration : Declaration\n         }\n \n         if (!tf.nextOf())\n-            error(\"must return `int` or `void`\");\n-        else if (tf.nextOf().ty != Tint32 && tf.nextOf().ty != Tvoid)\n-            error(\"must return `int` or `void`, not `%s`\", tf.nextOf().toChars());\n+            // auto main(), check after semantic\n+            assert(this.inferRetType);\n+        else if (tf.nextOf().ty != Tint32 && tf.nextOf().ty != Tvoid && tf.nextOf().ty != Tnoreturn)\n+            error(\"must return `int`, `void` or `noreturn`, not `%s`\", tf.nextOf().toChars());\n         else if (tf.parameterList.varargs || nparams >= 2 || argerr)\n             error(\"parameters must be `main()` or `main(string[] args)`\");\n     }\n@@ -3054,7 +3073,11 @@ FuncDeclaration resolveFuncCall(const ref Loc loc, Scope* sc, Dsymbol s,\n         return null;\n \n     bool hasOverloads = fd.overnext !is null;\n-    auto tf = fd.type.toTypeFunction();\n+    auto tf = fd.type.isTypeFunction();\n+    // if type is an error, the original type should be there for better diagnostics\n+    if (!tf)\n+        tf = fd.originalType.toTypeFunction();\n+\n     if (tthis && !MODimplicitConv(tthis.mod, tf.mod)) // modifier mismatch\n     {\n         OutBuffer thisBuf, funcBuf;\n@@ -3253,17 +3276,7 @@ private bool traverseIndirections(Type ta, Type tb)\n {\n     //printf(\"traverseIndirections(%s, %s)\\n\", ta.toChars(), tb.toChars());\n \n-    /* Threaded list of aggregate types already examined,\n-     * used to break cycles.\n-     * Cycles in type graphs can only occur with aggregates.\n-     */\n-    static struct Ctxt\n-    {\n-        Ctxt* prev;\n-        Type type;      // an aggregate type\n-    }\n-\n-    static bool traverse(Type ta, Type tb, Ctxt* ctxt, bool reversePass)\n+    static bool traverse(Type ta, Type tb, ref scope AssocArray!(const(char)*, bool) table, bool reversePass)\n     {\n         //printf(\"traverse(%s, %s)\\n\", ta.toChars(), tb.toChars());\n         ta = ta.baseElemOf();\n@@ -3293,28 +3306,27 @@ private bool traverseIndirections(Type ta, Type tb)\n \n         if (tb.ty == Tclass || tb.ty == Tstruct)\n         {\n-            for (Ctxt* c = ctxt; c; c = c.prev)\n-                if (tb == c.type)\n-                    return true;\n-            Ctxt c;\n-            c.prev = ctxt;\n-            c.type = tb;\n-\n             /* Traverse the type of each field of the aggregate\n              */\n+            bool* found = table.getLvalue(tb.deco);\n+            if (*found == true)\n+                return true; // We have already seen this symbol, break the cycle\n+            else\n+                *found = true;\n+\n             AggregateDeclaration sym = tb.toDsymbol(null).isAggregateDeclaration();\n             foreach (v; sym.fields)\n             {\n                 Type tprmi = v.type.addMod(tb.mod);\n                 //printf(\"\\ttb = %s, tprmi = %s\\n\", tb.toChars(), tprmi.toChars());\n-                if (!traverse(ta, tprmi, &c, reversePass))\n+                if (!traverse(ta, tprmi, table, reversePass))\n                     return false;\n             }\n         }\n         else if (tb.ty == Tarray || tb.ty == Taarray || tb.ty == Tpointer)\n         {\n             Type tind = tb.nextOf();\n-            if (!traverse(ta, tind, ctxt, reversePass))\n+            if (!traverse(ta, tind, table, reversePass))\n                 return false;\n         }\n         else if (tb.hasPointers())\n@@ -3325,15 +3337,19 @@ private bool traverseIndirections(Type ta, Type tb)\n \n         // Still no match, so try breaking up ta if we have not done so yet.\n         if (!reversePass)\n-            return traverse(tb, ta, ctxt, true);\n+        {\n+            scope newTable = AssocArray!(const(char)*, bool)();\n+            return traverse(tb, ta, newTable, true);\n+        }\n \n         return true;\n     }\n \n     // To handle arbitrary levels of indirections in both parameters, we\n     // recursively descend into aggregate members/levels of indirection in both\n     // `ta` and `tb` while avoiding cycles. Start with the original types.\n-    const result = traverse(ta, tb, null, false);\n+    scope table = AssocArray!(const(char)*, bool)();\n+    const result = traverse(ta, tb, table, false);\n     //printf(\"  returns %d\\n\", result);\n     return result;\n }"}, {"sha": "747a1138905aed6c2268b21b85bb69e9dbbfbd61", "filename": "gcc/d/dmd/globals.d", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fglobals.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fglobals.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fglobals.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -14,7 +14,7 @@ module dmd.globals;\n import core.stdc.stdint;\n import dmd.root.array;\n import dmd.root.filename;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.identifier;\n \n /// Defines a setting for how compiler warnings and deprecations are handled\n@@ -118,6 +118,7 @@ extern (C++) struct Param\n     bool vgc;               // identify gc usage\n     bool vfield;            // identify non-mutable field variables\n     bool vcomplex = true;   // identify complex/imaginary type usage\n+    bool vin;               // identify 'in' parameters\n     ubyte symdebug;         // insert debug symbolic information\n     bool symdebugref;       // insert debug information for all referenced types, too\n     bool optimize;          // run optimizer\n@@ -261,11 +262,29 @@ extern (C++) struct Param\n     const(char)[] mapfile;\n }\n \n-alias structalign_t = uint;\n+extern (C++) struct structalign_t\n+{\n+  private:\n+    ushort value = 0;  // unknown\n+    enum STRUCTALIGN_DEFAULT = 1234;   // default = match whatever the corresponding C compiler does\n+    bool pack;         // use #pragma pack semantics\n+\n+  public:\n+  pure @safe @nogc nothrow:\n+    bool isDefault() const { return value == STRUCTALIGN_DEFAULT; }\n+    void setDefault()      { value = STRUCTALIGN_DEFAULT; }\n+    bool isUnknown() const { return value == 0; }  // value is not set\n+    void setUnknown()      { value = 0; }\n+    void set(uint value)   { this.value = cast(ushort)value; }\n+    uint get() const       { return value; }\n+    bool isPack() const    { return pack; }\n+    void setPack(bool pack) { this.pack = pack; }\n+}\n+//alias structalign_t = uint;\n \n // magic value means \"match whatever the underlying C compiler does\"\n // other values are all powers of 2\n-enum STRUCTALIGN_DEFAULT = (cast(structalign_t)~0);\n+//enum STRUCTALIGN_DEFAULT = (cast(structalign_t)~0);\n \n enum mars_ext = \"d\";        // for D source files\n enum doc_ext  = \"html\";     // for Ddoc generated files\n@@ -307,6 +326,8 @@ extern (C++) struct Global\n     Array!Identifier* versionids; /// command line versions and predefined versions\n     Array!Identifier* debugids;   /// command line debug versions and predefined versions\n \n+    bool hasMainFunction; /// Whether a main function has already been compiled in (for -main switch)\n+\n     enum recursionLimit = 500; /// number of recursive template expansions before abort\n \n   nothrow:"}, {"sha": "2275ec517e51c59f6f157bb1d71a38aaa8efef54", "filename": "gcc/d/dmd/globals.h", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fglobals.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fglobals.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fglobals.h?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -12,7 +12,7 @@\n \n #include \"root/dcompat.h\"\n #include \"root/ctfloat.h\"\n-#include \"root/outbuffer.h\"\n+#include \"common/outbuffer.h\"\n #include \"root/filename.h\"\n #include \"compiler.h\"\n \n@@ -107,6 +107,7 @@ struct Param\n     bool vgc;           // identify gc usage\n     bool vfield;        // identify non-mutable field variables\n     bool vcomplex;      // identify complex/imaginary type usage\n+    bool vin;           // identify 'in' parameters\n     unsigned char symdebug;  // insert debug symbolic information\n     bool symdebugref;   // insert debug information for all referenced types, too\n     bool optimize;      // run optimizer\n@@ -238,10 +239,24 @@ struct Param\n     DString mapfile;\n };\n \n-typedef unsigned structalign_t;\n+struct structalign_t\n+{\n+    unsigned short value;\n+    bool pack;\n+\n+    bool isDefault() const;\n+    void setDefault();\n+    bool isUnknown() const;\n+    void setUnknown();\n+    void set(unsigned value);\n+    unsigned get() const;\n+    bool isPack() const;\n+    void setPack(bool pack);\n+};\n+\n // magic value means \"match whatever the underlying C compiler does\"\n // other values are all powers of 2\n-#define STRUCTALIGN_DEFAULT ((structalign_t) ~0)\n+//#define STRUCTALIGN_DEFAULT ((structalign_t) ~0)\n \n const DString mars_ext = \"d\";\n const DString doc_ext  = \"html\";     // for Ddoc generated files\n@@ -274,6 +289,8 @@ struct Global\n     Array<class Identifier*>* versionids; // command line versions and predefined versions\n     Array<class Identifier*>* debugids;   // command line debug versions and predefined versions\n \n+    bool hasMainFunction;\n+\n     /* Start gagging. Return the current number of gagged errors\n      */\n     unsigned startGagging();"}, {"sha": "4018126cb262898212b111e86c6350f9af3dad2c", "filename": "gcc/d/dmd/gluelayer.d", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fgluelayer.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fgluelayer.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fgluelayer.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -78,6 +78,7 @@ else version (IN_GCC)\n     extern (C++)\n     {\n         Statement asmSemantic(AsmStatement s, Scope* sc);\n+        void toObjFile(Dsymbol ds, bool multiobj);\n     }\n \n     // stubs"}, {"sha": "4ff07b5de329231275d8889a99974d36c233c272", "filename": "gcc/d/dmd/hdrgen.d", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fhdrgen.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fhdrgen.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fhdrgen.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -44,7 +44,7 @@ import dmd.mtype;\n import dmd.nspace;\n import dmd.parse;\n import dmd.root.ctfloat;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.root.rootobject;\n import dmd.root.string;\n import dmd.statement;\n@@ -909,6 +909,12 @@ public:\n \n     override void visit(AttribDeclaration d)\n     {\n+        bool hasSTC;\n+        if (auto stcd = d.isStorageClassDeclaration)\n+        {\n+            hasSTC = stcToBuffer(buf, stcd.stc);\n+        }\n+\n         if (!d.decl)\n         {\n             buf.writeByte(';');\n@@ -918,10 +924,12 @@ public:\n         if (d.decl.dim == 0 || (hgs.hdrgen && d.decl.dim == 1 && (*d.decl)[0].isUnitTestDeclaration()))\n         {\n             // hack for bugzilla 8081\n+            if (hasSTC) buf.writeByte(' ');\n             buf.writestring(\"{}\");\n         }\n         else if (d.decl.dim == 1)\n         {\n+            if (hasSTC) buf.writeByte(' ');\n             (*d.decl)[0].accept(this);\n             return;\n         }\n@@ -941,8 +949,6 @@ public:\n \n     override void visit(StorageClassDeclaration d)\n     {\n-        if (stcToBuffer(buf, d.stc))\n-            buf.writeByte(' ');\n         visit(cast(AttribDeclaration)d);\n     }\n \n@@ -1324,11 +1330,10 @@ public:\n         if (d.ident)\n         {\n             buf.writestring(d.ident.toString());\n-            buf.writeByte(' ');\n         }\n         if (d.memtype)\n         {\n-            buf.writestring(\": \");\n+            buf.writestring(\" : \");\n             typeToBuffer(d.memtype, null, buf, hgs);\n         }\n         if (!d.members)\n@@ -2362,7 +2367,10 @@ public:\n     override void visit(DotIdExp e)\n     {\n         expToBuffer(e.e1, PREC.primary, buf, hgs);\n-        buf.writeByte('.');\n+        if (e.arrow)\n+            buf.writestring(\"->\");\n+        else\n+            buf.writeByte('.');\n         buf.writestring(e.ident.toString());\n     }\n "}, {"sha": "3ff0e894e2ac2f04c9b40d9e41ae8eeb3a883373", "filename": "gcc/d/dmd/iasmgcc.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fiasmgcc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fiasmgcc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fiasmgcc.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -300,7 +300,7 @@ Ldone:\n  * Returns:\n  *      the completed gcc asm statement, or null if errors occurred\n  */\n-public Statement gccAsmSemantic(GccAsmStatement s, Scope *sc)\n+extern (C++) public Statement gccAsmSemantic(GccAsmStatement s, Scope *sc)\n {\n     //printf(\"GccAsmStatement.semantic()\\n\");\n     scope p = new Parser!ASTCodegen(sc._module, \";\", false);"}, {"sha": "1ee51533b53176e70b307bfbe40e14838f342c90", "filename": "gcc/d/dmd/id.d", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fid.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fid.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fid.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -500,6 +500,17 @@ immutable Msgtable[] msgtable =\n     { \"vector_size\" },\n     { \"__func__\" },\n     { \"noreturn\" },\n+    { \"__pragma\", \"pragma\" },\n+    { \"builtin_va_list\", \"__builtin_va_list\" },\n+    { \"builtin_va_start\", \"__builtin_va_start\" },\n+    { \"builtin_va_arg\", \"__builtin_va_arg\" },\n+    { \"builtin_va_copy\", \"__builtin_va_copy\" },\n+    { \"builtin_va_end\", \"__builtin_va_end\" },\n+    { \"va_list_tag\", \"__va_list_tag\" },\n+    { \"pack\" },\n+    { \"show\" },\n+    { \"push\" },\n+    { \"pop\" },\n ];\n \n "}, {"sha": "8add74a14277703fb9b9530cbd028bb40f69141b", "filename": "gcc/d/dmd/identifier.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fidentifier.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fidentifier.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fidentifier.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -16,7 +16,7 @@ import core.stdc.stdio;\n import core.stdc.string;\n import dmd.globals;\n import dmd.id;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.root.rootobject;\n import dmd.root.string;\n import dmd.root.stringtable;"}, {"sha": "0dad1a83a8bc2471206f2bf2a7266388987e13ae", "filename": "gcc/d/dmd/importc.d", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fimportc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fimportc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fimportc.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,171 @@\n+/**\n+ * Contains semantic routines specific to ImportC\n+ *\n+ * Specification: C11\n+ *\n+ * Copyright:   Copyright (C) 2021 by The D Language Foundation, All Rights Reserved\n+ * Authors:     $(LINK2 http://www.digitalmars.com, Walter Bright)\n+ * License:     $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+ * Source:      $(LINK2 https://github.com/dlang/dmd/blob/master/src/dmd/importc.d, _importc.d)\n+ * Documentation:  https://dlang.org/phobos/dmd_importc.html\n+ * Coverage:    https://codecov.io/gh/dlang/dmd/src/master/src/dmd/importc.d\n+ */\n+\n+module dmd.importc;\n+\n+import core.stdc.stdio;\n+\n+import dmd.dcast;\n+import dmd.dscope;\n+import dmd.dsymbol;\n+import dmd.expression;\n+import dmd.expressionsem;\n+import dmd.identifier;\n+import dmd.mtype;\n+\n+/**************************************\n+ * C11 does not allow array or function parameters.\n+ * Hence, adjust those types per C11 6.7.6.3 rules.\n+ * Params:\n+ *      t = parameter type to adjust\n+ *      sc = context\n+ * Returns:\n+ *      adjusted type\n+ */\n+Type cAdjustParamType(Type t, Scope* sc)\n+{\n+    if (!(sc.flags & SCOPE.Cfile))\n+        return t;\n+\n+    Type tb = t.toBasetype();\n+\n+    /* C11 6.7.6.3-7 array of T is converted to pointer to T\n+     */\n+    if (auto ta = tb.isTypeDArray())\n+    {\n+        t = ta.next.pointerTo();\n+    }\n+    else if (auto ts = tb.isTypeSArray())\n+    {\n+        t = ts.next.pointerTo();\n+    }\n+    /* C11 6.7.6.3-8 function is converted to pointer to function\n+     */\n+    else if (tb.isTypeFunction())\n+    {\n+        t = tb.pointerTo();\n+    }\n+    return t;\n+}\n+\n+/***********************************************\n+ * C11 6.3.2.1-3 Convert expression that is an array of type to a pointer to type.\n+ * C11 6.3.2.1-4 Convert expression that is a function to a pointer to a function.\n+ * Params:\n+ *  e = ImportC expression to possibly convert\n+ *  sc = context\n+ * Returns:\n+ *  converted expression\n+ */\n+Expression arrayFuncConv(Expression e, Scope* sc)\n+{\n+    //printf(\"arrayFuncConv() %s\\n\", e.toChars());\n+    if (!(sc.flags & SCOPE.Cfile))\n+        return e;\n+\n+    auto t = e.type.toBasetype();\n+    if (auto ta = t.isTypeDArray())\n+    {\n+        e = e.castTo(sc, ta.next.pointerTo());\n+    }\n+    else if (auto ts = t.isTypeSArray())\n+    {\n+        e = e.castTo(sc, ts.next.pointerTo());\n+    }\n+    else if (t.isTypeFunction())\n+    {\n+        e = e.addressOf();\n+    }\n+    else\n+        return e;\n+    return e.expressionSemantic(sc);\n+}\n+\n+/****************************************\n+ * Run semantic on `e`.\n+ * Expression `e` evaluates to an instance of a struct.\n+ * Look up `ident` as a field of that struct.\n+ * Params:\n+ *   e = evaluates to an instance of a struct\n+ *   sc = context\n+ *   id = identifier of a field in that struct\n+ * Returns:\n+ *   if successful `e.ident`\n+ *   if not then `ErrorExp` and message is printed\n+ */\n+Expression fieldLookup(Expression e, Scope* sc, Identifier id)\n+{\n+    e = e.expressionSemantic(sc);\n+    if (e.isErrorExp())\n+        return e;\n+\n+    Dsymbol s;\n+    auto t = e.type;\n+    if (t.isTypePointer())\n+    {\n+        t = t.isTypePointer().next;\n+        e = new PtrExp(e.loc, e);\n+    }\n+    if (auto ts = t.isTypeStruct())\n+        s = ts.sym.search(e.loc, id, 0);\n+    if (!s)\n+    {\n+        e.error(\"`%s` is not a member of `%s`\", id.toChars(), t.toChars());\n+        return ErrorExp.get();\n+    }\n+    Expression ef = new DotVarExp(e.loc, e, s.isDeclaration());\n+    return ef.expressionSemantic(sc);\n+}\n+\n+/****************************************\n+ * C11 6.5.2.1-2\n+ * Apply C semantics to `E[I]` expression.\n+ * E1[E2] is lowered to *(E1 + E2)\n+ * Params:\n+ *      ae = ArrayExp to run semantics on\n+ *      sc = context\n+ * Returns:\n+ *      Expression if this was a C expression with completed semantic, null if not\n+ */\n+Expression carraySemantic(ArrayExp ae, Scope* sc)\n+{\n+    if (!(sc.flags & SCOPE.Cfile))\n+        return null;\n+\n+    auto e1 = ae.e1.expressionSemantic(sc);\n+\n+    assert(ae.arguments.length == 1);\n+    Expression e2 = (*ae.arguments)[0];\n+\n+    /* CTFE cannot do pointer arithmetic, but it can index arrays.\n+     * So, rewrite as an IndexExp if we can.\n+     */\n+    auto t1 = e1.type.toBasetype();\n+    if (t1.isTypeDArray() || t1.isTypeSArray())\n+    {\n+        e2 = e2.expressionSemantic(sc).arrayFuncConv(sc);\n+        return new IndexExp(ae.loc, e1, e2).expressionSemantic(sc);\n+    }\n+\n+    e1 = e1.arrayFuncConv(sc);   // e1 might still be a function call\n+    e2 = e2.expressionSemantic(sc);\n+    auto t2 = e2.type.toBasetype();\n+    if (t2.isTypeDArray() || t2.isTypeSArray())\n+    {\n+        return new IndexExp(ae.loc, e2, e1).expressionSemantic(sc); // swap operands\n+    }\n+\n+    e2 = e2.arrayFuncConv(sc);\n+    auto ep = new PtrExp(ae.loc, new AddExp(ae.loc, e1, e2));\n+    return ep.expressionSemantic(sc);\n+}"}, {"sha": "d036ee1635bbcd05080ca58643211e7a1681061a", "filename": "gcc/d/dmd/init.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Finit.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Finit.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finit.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -23,7 +23,7 @@ import dmd.globals;\n import dmd.hdrgen;\n import dmd.identifier;\n import dmd.mtype;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.root.rootobject;\n import dmd.tokens;\n import dmd.visitor;"}, {"sha": "5828486c6fe43caa5fe0e288551662db13d033ea", "filename": "gcc/d/dmd/initsem.d", "status": "modified", "additions": 95, "deletions": 33, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Finitsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Finitsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finitsem.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -31,6 +31,7 @@ import dmd.func;\n import dmd.globals;\n import dmd.id;\n import dmd.identifier;\n+import dmd.importc;\n import dmd.init;\n import dmd.mtype;\n import dmd.opover;\n@@ -176,30 +177,35 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n                             break;\n                     }\n                 }\n-                else if (fieldi >= nfields)\n+                if (j >= nfields)\n                 {\n-                    error(i.loc, \"too many initializers for `%s`\", sd.toChars());\n+                    error(i.value[j].loc, \"too many initializers for `%s`\", sd.toChars());\n                     return err();\n                 }\n \n                 VarDeclaration vd = sd.fields[fieldi];\n                 if (elems[fieldi])\n                 {\n-                    error(i.loc, \"duplicate initializer for field `%s`\", vd.toChars());\n+                    error(i.value[j].loc, \"duplicate initializer for field `%s`\", vd.toChars());\n                     errors = true;\n+                    elems[fieldi] = ErrorExp.get(); // for better diagnostics on multiple errors\n+                    ++fieldi;\n                     continue;\n                 }\n \n                 // Check for @safe violations\n                 if (vd.type.hasPointers)\n                 {\n-                    if ((t.alignment() < target.ptrsize ||\n+                    if ((!t.alignment.isDefault() && t.alignment.get() < target.ptrsize ||\n                          (vd.offset & (target.ptrsize - 1))) &&\n                         sc.func && sc.func.setUnsafe())\n                     {\n-                        error(i.loc, \"field `%s.%s` cannot assign to misaligned pointers in `@safe` code\",\n+                        error(i.value[j].loc, \"field `%s.%s` cannot assign to misaligned pointers in `@safe` code\",\n                             sd.toChars(), vd.toChars());\n                         errors = true;\n+                        elems[fieldi] = ErrorExp.get(); // for better diagnostics on multiple errors\n+                        ++fieldi;\n+                        continue;\n                     }\n                 }\n \n@@ -208,7 +214,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n                 {\n                     if (vd.isOverlappedWith(v2) && elems[k])\n                     {\n-                        error(i.loc, \"overlapping initialization for field `%s` and `%s`\", v2.toChars(), vd.toChars());\n+                        error(elems[k].loc, \"overlapping initialization for field `%s` and `%s`\", v2.toChars(), vd.toChars());\n                         errors = true;\n                         continue;\n                     }\n@@ -222,6 +228,8 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n                 if (ex.op == TOK.error)\n                 {\n                     errors = true;\n+                    elems[fieldi] = ErrorExp.get(); // for better diagnostics on multiple errors\n+                    ++fieldi;\n                     continue;\n                 }\n \n@@ -363,10 +371,10 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n             if (length > i.dim)\n                 i.dim = length;\n         }\n-        if (t.ty == Tsarray)\n+        if (auto tsa = t.isTypeSArray())\n         {\n-            uinteger_t edim = (cast(TypeSArray)t).dim.toInteger();\n-            if (i.dim > edim)\n+            uinteger_t edim = tsa.dim.toInteger();\n+            if (i.dim > edim && !(tsa.isIncomplete() && (sc.flags & SCOPE.Cfile)))\n             {\n                 error(i.loc, \"array initializer has %u elements, but array length is %llu\", i.dim, edim);\n                 return err();\n@@ -398,6 +406,13 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n         if (i.exp.op == TOK.error)\n             return err();\n         uint olderrors = global.errors;\n+\n+        /* ImportC: convert arrays to pointers, functions to pointers to functions\n+         */\n+        Type tb = t.toBasetype();\n+        if (tb.isTypePointer())\n+            i.exp = i.exp.arrayFuncConv(sc);\n+\n         /* Save the expression before ctfe\n          * Otherwise the error message would contain for example \"&[0][0]\" instead of \"new int\"\n          * Regression: https://issues.dlang.org/show_bug.cgi?id=21687\n@@ -408,14 +423,19 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n             // If the result will be implicitly cast, move the cast into CTFE\n             // to avoid premature truncation of polysemous types.\n             // eg real [] x = [1.1, 2.2]; should use real precision.\n-            if (i.exp.implicitConvTo(t))\n+            if (i.exp.implicitConvTo(t) && !(sc.flags & SCOPE.Cfile))\n             {\n                 i.exp = i.exp.implicitCastTo(sc, t);\n             }\n             if (!global.gag && olderrors != global.errors)\n             {\n                 return i;\n             }\n+            if (sc.flags & SCOPE.Cfile)\n+                /* the interpreter turns (char*)\"string\" into &\"string\"[0] which then\n+                 * it cannot interpret. Resolve that case by doing optimize() first\n+                 */\n+                i.exp = i.exp.optimize(WANTvalue);\n             i.exp = i.exp.ctfeInterpret();\n             if (i.exp.op == TOK.voidExpression)\n                 error(i.loc, \"variables cannot be initialized with an expression of type `void`. Use `void` initialization instead.\");\n@@ -424,6 +444,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n         {\n             i.exp = i.exp.optimize(WANTvalue);\n         }\n+\n         if (!global.gag && olderrors != global.errors)\n         {\n             return i; // Failed, suppress duplicate error messages\n@@ -445,7 +466,6 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n             i.exp.error(\"cannot use non-constant CTFE pointer in an initializer `%s`\", currExp.toChars());\n             return err();\n         }\n-        Type tb = t.toBasetype();\n         Type ti = i.exp.type.toBasetype();\n         if (i.exp.op == TOK.tuple && i.expandTuples && !i.exp.implicitConvTo(t))\n         {\n@@ -470,13 +490,12 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n                 goto L1;\n             }\n         }\n-\n         /* C11 6.7.9-14..15\n          * Initialize an array of unknown size with a string.\n-         * ImportC regards Tarray as an array of unknown size.\n          * Change to static array of known size\n          */\n-        if (sc.flags & SCOPE.Cfile && i.exp.op == TOK.string_ && tb.ty == Tarray)\n+        if (sc.flags & SCOPE.Cfile && i.exp.isStringExp() &&\n+            tb.isTypeSArray() && tb.isTypeSArray().isIncomplete())\n         {\n             StringExp se = i.exp.isStringExp();\n             auto ts = new TypeSArray(tb.nextOf(), new IntegerExp(Loc.initial, se.len + 1, Type.tsize_t));\n@@ -683,8 +702,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n         }\n \n         auto tsa = t.isTypeSArray();\n-        auto ta = t.isTypeDArray();\n-        if (!(tsa || ta))\n+        if (!tsa)\n         {\n             /* Not an array. See if it is `{ exp }` which can be\n              * converted to an ExpInitializer\n@@ -722,19 +740,32 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n         {\n             //printf(\" type %s i %d dim %d dil.length = %d\\n\", t.toChars(), cast(int)i, cast(int)dim, cast(int)dil.length);\n             auto tn = t.nextOf().toBasetype();\n-            if (auto tna = tn.isTypeDArray())\n+            auto tnsa = tn.isTypeSArray();\n+            if (tnsa && tnsa.isIncomplete())\n             {\n                 // C11 6.2.5-20 \"element type shall be complete whenever the array type is specified\"\n-                error(ci.loc, \"incomplete element type `%s` not allowed\", tna.toChars());\n+                error(ci.loc, \"incomplete element type `%s` not allowed\", tnsa.toChars());\n                 errors = true;\n                 return 1;\n             }\n             if (i == dil.length)\n                 return 0;\n             size_t n;\n-            auto tnsa = tn.isTypeSArray();\n             const nelems = tnsa ? cast(size_t)tnsa.dim.toInteger() : 0;\n \n+            /* Run initializerSemantic on a single element.\n+             */\n+            Initializer elem(Initializer ie)\n+            {\n+                ++i;\n+                auto tnx = tn; // in case initializerSemantic tries to change it\n+                ie = ie.initializerSemantic(sc, tnx, needInterpret);\n+                if (ie.isErrorInitializer())\n+                    errors = true;\n+                assert(tnx == tn); // sub-types should not be modified\n+                return ie;\n+            }\n+\n             foreach (j; 0 .. dim)\n             {\n                 auto di = dil[i];\n@@ -751,16 +782,17 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n                 }\n                 else if (auto tns = tn.isTypeStruct())\n                 {\n-                    dil[n].initializer = structs(tns);\n+                    if (di.initializer.isExpInitializer())\n+                    {\n+                        // no braces enclosing struct initializer\n+                        dil[n].initializer = structs(tns);\n+                    }\n+                    else\n+                        dil[n].initializer = elem(di.initializer);\n                 }\n                 else\n                 {\n-                    ++i;\n-                    auto tnx = tn; // in case initializerSemantic tries to change it\n-                    di.initializer = di.initializer.initializerSemantic(sc, tnx, needInterpret);\n-                    if (di.initializer.isErrorInitializer())\n-                        errors = true;\n-                    assert(tnx == tn); // sub-types should not be modified\n+                    di.initializer = elem(di.initializer);\n                 }\n                 ++n;\n                 if (i == dil.length)\n@@ -770,16 +802,16 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n             return n;\n         }\n \n-        size_t dim = ta ? dil.length : cast(size_t)tsa.dim.toInteger();\n-        auto n = array(t, dim);\n+        size_t dim = tsa.isIncomplete() ? dil.length : cast(size_t)tsa.dim.toInteger();\n+        auto newdim = array(t, dim);\n \n         if (errors)\n             return err();\n \n-        if (ta) // array of unknown length\n+        if (tsa.isIncomplete()) // array of unknown length\n         {\n             // Change to array of known length\n-            tsa = new TypeSArray(tn, new IntegerExp(Loc.initial, n, Type.tsize_t));\n+            tsa = new TypeSArray(tn, new IntegerExp(Loc.initial, newdim, Type.tsize_t));\n             tx = tsa;       // rewrite caller's type\n             ci.type = tsa;  // remember for later passes\n         }\n@@ -799,6 +831,39 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n             return err();\n         }\n \n+        /* If an array of simple elements, replace with an ArrayInitializer\n+         */\n+        auto tnb = tn.toBasetype();\n+        if (!(tnb.isTypeSArray() || tnb.isTypeStruct()))\n+        {\n+            auto ai = new ArrayInitializer(ci.loc);\n+            ai.dim = cast(uint) dil.length;\n+            ai.index.setDim(dil.length);\n+            ai.value.setDim(dil.length);\n+            foreach (const j; 0 .. dil.length)\n+            {\n+                ai.index[j] = null;\n+                ai.value[j] = dil[j].initializer;\n+            }\n+            auto ty = tx;\n+            return ai.initializerSemantic(sc, ty, needInterpret);\n+        }\n+\n+        if (newdim < ci.initializerList.length && tnb.isTypeStruct())\n+        {\n+            // https://issues.dlang.org/show_bug.cgi?id=22375\n+            // initializerList can be bigger than the number of actual elements\n+            // to initialize for array of structs because it is not required\n+            // for values to have proper bracing.\n+            // i.e: These are all valid initializers for `struct{int a,b;}[3]`:\n+            //      {1,2,3,4}, {{1,2},3,4}, {1,2,{3,4}}, {{1,2},{3,4}}\n+            // In all examples above, the new length of the initializer list\n+            // has been shortened from four elements to two. This is important,\n+            // because `dil` is written back to directly, making the lowered\n+            // initializer `{{1,2},{3,4}}` and not `{{1,2},{3,4},3,4}`.\n+            ci.initializerList.length = newdim;\n+        }\n+\n         return ci;\n     }\n \n@@ -1263,6 +1328,3 @@ private bool hasNonConstPointers(Expression e)\n     }\n     return false;\n }\n-\n-\n-"}, {"sha": "fd6153205c91e3da847164da00298fd46a6a9488", "filename": "gcc/d/dmd/intrange.h", "status": "removed", "additions": 0, "deletions": 177, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Fd%2Fdmd%2Fintrange.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Fd%2Fdmd%2Fintrange.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fintrange.h?ref=c15aa46cca0649b68613d3292cf71c7cc57ef78f", "patch": "@@ -1,177 +0,0 @@\n-\n-/* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n- * written by KennyTM\n- * http://www.digitalmars.com\n- * Distributed under the Boost Software License, Version 1.0.\n- * http://www.boost.org/LICENSE_1_0.txt\n- * https://github.com/dlang/dmd/blob/master/src/intrange.h\n- */\n-\n-#pragma once\n-\n-#include \"globals.h\"   // for uinteger_t\n-class Type;\n-class Expression;\n-\n-/**\n-This class represents a \"sign-extended number\", i.e. a 65-bit number, which can\n-represent all built-in integer types in D. This class is mainly used for\n-performing value-range propagation only, therefore all arithmetic are done with\n-saturation, not wrapping as usual.\n-*/\n-struct SignExtendedNumber\n-{\n-    /// The lower 64-bit of the number.\n-    uinteger_t value;\n-    /// The sign (i.e. the most significant bit) of the number.\n-    bool negative;\n-\n-    /// Create an uninitialized sign-extended number.\n-    SignExtendedNumber() {}\n-\n-    /// Create a sign-extended number from an unsigned 64-bit number.\n-    SignExtendedNumber(uinteger_t value_)\n-        : value(value_), negative(false) {}\n-    /// Create a sign-extended number from the lower 64-bit and the sign bit.\n-    SignExtendedNumber(uinteger_t value_, bool negative_)\n-        : value(value_), negative(negative_) {}\n-\n-    /// Create a sign-extended number from a signed 64-bit number.\n-    static SignExtendedNumber fromInteger(uinteger_t value_);\n-\n-    /// Get the minimum or maximum value of a sign-extended number.\n-    static SignExtendedNumber extreme(bool minimum);\n-\n-    // These names probably shouldn't be used anyway, as they are common macros\n-#undef max\n-#undef min\n-    static SignExtendedNumber max();\n-    static SignExtendedNumber min() { return SignExtendedNumber(0, true); }\n-\n-    /// Check if the sign-extended number is minimum or zero.\n-    bool isMinimum() const { return negative && value == 0; }\n-\n-    /// Compare two sign-extended number.\n-    bool operator==(const SignExtendedNumber&) const;\n-    bool operator!=(const SignExtendedNumber& a) const { return !(*this == a); }\n-    bool operator<(const SignExtendedNumber&) const;\n-    bool operator>(const SignExtendedNumber& a) const { return a < *this; }\n-    bool operator<=(const SignExtendedNumber& a) const { return !(a < *this); }\n-    bool operator>=(const SignExtendedNumber& a) const { return !(*this < a); }\n-\n-    /// Increase the sign-extended number by 1 (saturated).\n-    SignExtendedNumber& operator++();\n-    /// Compute the saturated complement of a sign-extended number.\n-    SignExtendedNumber operator~() const;\n-    /// Compute the saturated negation of a sign-extended number.\n-    SignExtendedNumber operator-() const;\n-\n-    /// Compute the saturated binary and of two sign-extended number.\n-    SignExtendedNumber operator&(const SignExtendedNumber&) const;\n-    /// Compute the saturated binary or of two sign-extended number.\n-    SignExtendedNumber operator|(const SignExtendedNumber&) const;\n-    /// Compute the saturated binary xor of two sign-extended number.\n-    SignExtendedNumber operator^(const SignExtendedNumber&) const;\n-    /// Compute the saturated sum of two sign-extended number.\n-    SignExtendedNumber operator+(const SignExtendedNumber&) const;\n-    /// Compute the saturated difference of two sign-extended number.\n-    SignExtendedNumber operator-(const SignExtendedNumber&) const;\n-    /// Compute the saturated product of two sign-extended number.\n-    SignExtendedNumber operator*(const SignExtendedNumber&) const;\n-    /// Compute the saturated quotient of two sign-extended number.\n-    SignExtendedNumber operator/(const SignExtendedNumber&) const;\n-    /// Compute the saturated modulus of two sign-extended number.\n-    SignExtendedNumber operator%(const SignExtendedNumber&) const;\n-\n-    /// Compute the saturated shifts of two sign-extended number.\n-    SignExtendedNumber operator<<(const SignExtendedNumber&) const;\n-    SignExtendedNumber operator>>(const SignExtendedNumber&) const;\n-};\n-\n-/**\n-This class represents a range of integers, denoted by its lower and upper bounds\n-(inclusive).\n-*/\n-struct IntRange\n-{\n-    SignExtendedNumber imin, imax;\n-\n-    /// Create an uninitialized range.\n-    IntRange() {}\n-\n-    /// Create a range consisting of a single number.\n-    IntRange(const SignExtendedNumber& a)\n-        : imin(a), imax(a) {}\n-    /// Create a range with the lower and upper bounds.\n-    IntRange(const SignExtendedNumber& lower, const SignExtendedNumber& upper)\n-        : imin(lower), imax(upper) {}\n-\n-    /// Create the tightest range containing all valid integers in the specified\n-    /// type.\n-    static IntRange fromType(Type *type);\n-    /// Create the tightest range containing all valid integers in the type with\n-    /// a forced signedness.\n-    static IntRange fromType(Type *type, bool isUnsigned);\n-\n-\n-    /// Create the tightest range containing all specified numbers.\n-    static IntRange fromNumbers2(const SignExtendedNumber numbers[2]);\n-    static IntRange fromNumbers4(const SignExtendedNumber numbers[4]);\n-\n-    /// Create the widest range possible.\n-    static IntRange widest();\n-\n-    /// Cast the integer range to a signed type with the given size mask.\n-    IntRange& castSigned(uinteger_t mask);\n-    /// Cast the integer range to an unsigned type with the given size mask.\n-    IntRange& castUnsigned(uinteger_t mask);\n-    /// Cast the integer range to the dchar type.\n-    IntRange& castDchar();\n-\n-    /// Cast the integer range to a specific type.\n-    IntRange& cast(Type *type);\n-    /// Cast the integer range to a specific type, forcing it to be unsigned.\n-    IntRange& castUnsigned(Type *type);\n-\n-    /// Check if this range contains another range.\n-    bool contains(const IntRange& a) const;\n-\n-    /// Check if this range contains 0.\n-    bool containsZero() const;\n-\n-    /// Compute the range of the negated absolute values of the original range.\n-    IntRange absNeg() const;\n-\n-    /// Compute the union of two ranges.\n-    IntRange unionWith(const IntRange& other) const;\n-    void unionOrAssign(const IntRange& other, bool& union_);\n-\n-    /// Dump the content of the integer range to the console.\n-    const IntRange& dump(const char* funcName, Expression *e) const;\n-\n-    /// Split the range into two nonnegative- and negative-only subintervals.\n-    void splitBySign(IntRange& negRange, bool& hasNegRange,\n-                     IntRange& nonNegRange, bool& hasNonNegRange) const;\n-\n-    /// Credits to Timon Gehr maxOr, minOr, maxAnd, minAnd\n-    /// https://github.com/tgehr/d-compiler/blob/master/vrange.d\n-    static SignExtendedNumber maxOr(const IntRange&, const IntRange&);\n-    static SignExtendedNumber minOr(const IntRange&, const IntRange&);\n-    static SignExtendedNumber maxAnd(const IntRange&, const IntRange&);\n-    static SignExtendedNumber minAnd(const IntRange&, const IntRange&);\n-    static void swap(IntRange&, IntRange&);\n-\n-    IntRange operator~() const;\n-    IntRange operator-() const;\n-    IntRange operator&(const IntRange&) const;\n-    IntRange operator|(const IntRange&) const;\n-    IntRange operator^(const IntRange&) const;\n-    IntRange operator+(const IntRange&) const;\n-    IntRange operator-(const IntRange&) const;\n-    IntRange operator*(const IntRange&) const;\n-    IntRange operator/(const IntRange&) const;\n-    IntRange operator%(const IntRange&) const;\n-    IntRange operator<<(const IntRange&) const;\n-    IntRange operator>>(const IntRange&) const;\n-};"}, {"sha": "fef515071f9922a6a76d3669672639ca25d62a6a", "filename": "gcc/d/dmd/json.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fjson.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fjson.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fjson.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -33,7 +33,7 @@ import dmd.hdrgen;\n import dmd.id;\n import dmd.identifier;\n import dmd.mtype;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.root.rootobject;\n import dmd.root.string;\n import dmd.target;\n@@ -794,8 +794,8 @@ public:\n             property(\"init\", d._init.toString());\n         if (d.isField())\n             property(\"offset\", d.offset);\n-        if (d.alignment && d.alignment != STRUCTALIGN_DEFAULT)\n-            property(\"align\", d.alignment);\n+        if (!d.alignment.isUnknown() && !d.alignment.isDefault())\n+            property(\"align\", d.alignment.get());\n         objectEnd();\n     }\n "}, {"sha": "44a6c0665070fb20a7292ed6040512371f83a06f", "filename": "gcc/d/dmd/lambdacomp.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Flambdacomp.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Flambdacomp.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Flambdacomp.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -27,7 +27,7 @@ import dmd.expression;\n import dmd.func;\n import dmd.dmangle;\n import dmd.mtype;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.root.rmem;\n import dmd.root.stringtable;\n import dmd.dscope;"}, {"sha": "e2b4199b80a23952120bd5c9ff82df8862325580", "filename": "gcc/d/dmd/lexer.d", "status": "modified", "additions": 233, "deletions": 4, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Flexer.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Flexer.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Flexer.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -26,8 +26,9 @@ import dmd.errors;\n import dmd.globals;\n import dmd.id;\n import dmd.identifier;\n+import dmd.root.array;\n import dmd.root.ctfloat;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.root.port;\n import dmd.root.rmem;\n import dmd.root.string;\n@@ -229,6 +230,8 @@ class Lexer\n     ubyte long_doublesize;      /// size of C long double, 8 or D real.sizeof\n     ubyte wchar_tsize;          /// size of C wchar_t, 2 or 4\n \n+    structalign_t packalign;    /// current state of #pragma pack alignment (ImportC)\n+\n     private\n     {\n         const(char)* base;      // pointer to start of buffer\n@@ -242,6 +245,10 @@ class Lexer\n         int lastDocLine;        // last line of previous doc comment\n \n         Token* tokenFreelist;\n+\n+        // ImportC #pragma pack stack\n+        Array!Identifier* records;      // identifers (or null)\n+        Array!structalign_t* packs;     // parallel alignment values\n     }\n \n   nothrow:\n@@ -273,6 +280,7 @@ class Lexer\n         this.commentToken = commentToken;\n         this.inTokenStringConstant = 0;\n         this.lastDocLine = 0;\n+        this.packalign.setDefault();\n         //initKeywords();\n         /* If first line starts with '#!', ignore the line\n          */\n@@ -1146,6 +1154,11 @@ class Lexer\n                             poundLine(n, false);\n                             continue;\n                         }\n+                        else if (n.ident == Id.__pragma && Ccompile)\n+                        {\n+                            pragmaDirective(scanloc);\n+                            continue;\n+                        }\n                         else\n                         {\n                             const locx = loc();\n@@ -2162,7 +2175,7 @@ class Lexer\n             case '.':\n                 if (p[1] == '.')\n                     goto Ldone; // if \"..\"\n-                if (base == 10 && (isalpha(p[1]) || p[1] == '_' || p[1] & 0x80))\n+                if (base <= 10 && n > 0 && (isalpha(p[1]) || p[1] == '_' || p[1] & 0x80))\n                     goto Ldone; // if \".identifier\" or \".unicode\"\n                 if (base == 16 && (!ishex(p[1]) || p[1] == '_' || p[1] & 0x80))\n                     goto Ldone; // if \".identifier\" or \".unicode\"\n@@ -2911,6 +2924,220 @@ class Lexer\n             error(loc, \"#line integer [\\\"filespec\\\"]\\\\n expected\");\n     }\n \n+    /*********************************************\n+     * C11 6.10.6 Pragma directive\n+     * # pragma pp-tokens(opt) new-line\n+     * The C preprocessor sometimes leaves pragma directives in\n+     * the preprocessed output. Ignore them.\n+     * Upon return, p is at start of next line.\n+     */\n+    private void pragmaDirective(const ref Loc loc)\n+    {\n+        Token n;\n+        scan(&n);\n+        if (n.value == TOK.identifier && n.ident == Id.pack)\n+            return pragmaPack(loc);\n+        skipToNextLine();\n+    }\n+\n+    /*********\n+     * ImportC\n+     * # pragma pack\n+     * https://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Structure_002dPacking-Pragmas.html\n+     * https://docs.microsoft.com/en-us/cpp/preprocessor/pack\n+     * Scanner is on the `pack`\n+     * Params:\n+     *  startloc = location to use for error messages\n+     */\n+    private void pragmaPack(const ref Loc startloc)\n+    {\n+        const loc = startloc;\n+        Token n;\n+        scan(&n);\n+        if (n.value != TOK.leftParenthesis)\n+        {\n+            error(loc, \"left parenthesis expected to follow `#pragma pack`\");\n+            skipToNextLine();\n+            return;\n+        }\n+\n+        void closingParen()\n+        {\n+            if (n.value != TOK.rightParenthesis)\n+            {\n+                error(loc, \"right parenthesis expected to close `#pragma pack(`\");\n+            }\n+            skipToNextLine();\n+        }\n+\n+        void setPackAlign(ref const Token t)\n+        {\n+            const n = t.unsvalue;\n+            if (n < 1 || n & (n - 1) || ushort.max < n)\n+                error(loc, \"pack must be an integer positive power of 2, not 0x%llx\", cast(ulong)n);\n+            packalign.set(cast(uint)n);\n+            packalign.setPack(true);\n+        }\n+\n+        scan(&n);\n+\n+        if (!records)\n+        {\n+            records = new Array!Identifier;\n+            packs = new Array!structalign_t;\n+        }\n+\n+        /* # pragma pack ( show )\n+         */\n+        if (n.value == TOK.identifier && n.ident == Id.show)\n+        {\n+            if (packalign.isDefault())\n+                warning(startloc, \"current pack attribute is default\");\n+            else\n+                warning(startloc, \"current pack attribute is %d\", packalign.get());\n+            scan(&n);\n+            return closingParen();\n+        }\n+        /* # pragma pack ( push )\n+         * # pragma pack ( push , identifier )\n+         * # pragma pack ( push , integer )\n+         * # pragma pack ( push , identifier , integer )\n+         */\n+        if (n.value == TOK.identifier && n.ident == Id.push)\n+        {\n+            scan(&n);\n+            Identifier record = null;\n+            if (n.value == TOK.comma)\n+            {\n+                scan(&n);\n+                if (n.value == TOK.identifier)\n+                {\n+                    record = n.ident;\n+                    scan(&n);\n+                    if (n.value == TOK.comma)\n+                    {\n+                        scan(&n);\n+                        if (n.value == TOK.int32Literal)\n+                        {\n+                            setPackAlign(n);\n+                            scan(&n);\n+                        }\n+                        else\n+                            error(loc, \"alignment value expected, not `%s`\", n.toChars());\n+                    }\n+                }\n+                else if (n.value == TOK.int32Literal)\n+                {\n+                    setPackAlign(n);\n+                    scan(&n);\n+                }\n+                else\n+                    error(loc, \"alignment value expected, not `%s`\", n.toChars());\n+            }\n+            this.records.push(record);\n+            this.packs.push(packalign);\n+            return closingParen();\n+        }\n+        /* # pragma pack ( pop )\n+         * # pragma pack ( pop PopList )\n+         * PopList :\n+         *    , IdentifierOrInteger\n+         *    , IdentifierOrInteger PopList\n+         * IdentifierOrInteger:\n+         *      identifier\n+         *      integer\n+         */\n+        if (n.value == TOK.identifier && n.ident == Id.pop)\n+        {\n+            scan(&n);\n+            while (n.value == TOK.comma)\n+            {\n+                scan(&n);\n+                if (n.value == TOK.identifier)\n+                {\n+                    for (size_t len = this.records.length; len; --len)\n+                    {\n+                        if ((*this.records)[len - 1] == n.ident)\n+                        {\n+                            packalign = (*this.packs)[len - 1];\n+                            this.records.setDim(len - 1);\n+                            this.packs.setDim(len - 1);\n+                            break;\n+                        }\n+                    }\n+                    scan(&n);\n+                }\n+                else if (n.value == TOK.int32Literal)\n+                {\n+                    setPackAlign(n);\n+                    this.records.push(null);\n+                    this.packs.push(packalign);\n+                    scan(&n);\n+                }\n+            }\n+            return closingParen();\n+        }\n+        /* # pragma pack ( integer )\n+         */\n+        if (n.value == TOK.int32Literal)\n+        {\n+            setPackAlign(n);\n+            scan(&n);\n+            return closingParen();\n+        }\n+        /* # pragma pack ( )\n+         */\n+        if (n.value == TOK.rightParenthesis)\n+        {\n+            packalign.setDefault();\n+            return closingParen();\n+        }\n+\n+        error(loc, \"unrecognized `#pragma pack(%s)`\", n.toChars());\n+        skipToNextLine();\n+    }\n+\n+    /***************************************\n+     * Scan forward to start of next line.\n+     */\n+    private void skipToNextLine()\n+    {\n+        while (1)\n+        {\n+            switch (*p)\n+            {\n+            case 0:\n+            case 0x1A:\n+                return; // do not advance p\n+\n+            case '\\n':\n+                ++p;\n+                break;\n+\n+            case '\\r':\n+                ++p;\n+                if (p[0] == '\\n')\n+                   ++p;\n+                break;\n+\n+            default:\n+                if (*p & 0x80)\n+                {\n+                    const u = decodeUTF();\n+                    if (u == PS || u == LS)\n+                    {\n+                        ++p;\n+                        break;\n+                    }\n+                }\n+                ++p;\n+                continue;\n+            }\n+            break;\n+        }\n+        endOfLine();\n+    }\n+\n     /********************************************\n      * Decode UTF character.\n      * Issue error messages for invalid sequences.\n@@ -3106,8 +3333,10 @@ class Lexer\n         return p;\n     }\n \n-private:\n-    void endOfLine() pure @nogc @safe\n+    /**************************\n+     * `p` should be at start of next line\n+     */\n+    private void endOfLine() pure @nogc @safe\n     {\n         scanloc.linnum++;\n         line = p;"}, {"sha": "b36e7f7bdaf3dbc527085f4fa1db499160b9cd33", "filename": "gcc/d/dmd/lexer.h", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Fd%2Fdmd%2Flexer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Fd%2Fdmd%2Flexer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Flexer.h?ref=c15aa46cca0649b68613d3292cf71c7cc57ef78f", "patch": "@@ -1,75 +0,0 @@\n-\n-/* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n- * written by Walter Bright\n- * http://www.digitalmars.com\n- * Distributed under the Boost Software License, Version 1.0.\n- * http://www.boost.org/LICENSE_1_0.txt\n- * https://github.com/D-Programming-Language/dmd/blob/master/src/lexer.h\n- */\n-\n-#pragma once\n-\n-#include \"root/root.h\"\n-#include \"globals.h\"\n-#include \"tokens.h\"\n-\n-struct StringTable;\n-class Identifier;\n-\n-class Lexer\n-{\n-public:\n-    static OutBuffer stringbuffer;\n-\n-    Loc scanloc;                // for error messages\n-\n-    const utf8_t *base;        // pointer to start of buffer\n-    const utf8_t *end;         // past end of buffer\n-    const utf8_t *p;           // current character\n-    const utf8_t *line;        // start of current line\n-    Token token;\n-    bool doDocComment;          // collect doc comment information\n-    bool anyToken;              // !=0 means seen at least one token\n-    bool commentToken;          // !=0 means comments are TOKcomment's\n-    bool errors;                // errors occurred during lexing or parsing\n-\n-    Lexer(const char *filename,\n-        const utf8_t *base, size_t begoffset, size_t endoffset,\n-        bool doDocComment, bool commentToken);\n-\n-    TOK nextToken();\n-    TOK peekNext();\n-    TOK peekNext2();\n-    void scan(Token *t);\n-    Token *peek(Token *t);\n-    Token *peekPastParen(Token *t);\n-    unsigned escapeSequence();\n-    TOK wysiwygStringConstant(Token *t, int tc);\n-    TOK hexStringConstant(Token *t);\n-    TOK delimitedStringConstant(Token *t);\n-    TOK tokenStringConstant(Token *t);\n-    TOK escapeStringConstant(Token *t);\n-    TOK charConstant(Token *t);\n-    void stringPostfix(Token *t);\n-    TOK number(Token *t);\n-    TOK inreal(Token *t);\n-\n-    Loc loc()\n-    {\n-        scanloc.charnum = (unsigned)(1 + p-line);\n-        return scanloc;\n-    }\n-\n-    void error(const char *format, ...);\n-    void error(Loc loc, const char *format, ...);\n-    void deprecation(const char *format, ...);\n-    void poundLine();\n-    unsigned decodeUTF();\n-    void getDocComment(Token *t, unsigned lineComment);\n-\n-    static const utf8_t *combineComments(const utf8_t *c1, const utf8_t *c2);\n-\n-private:\n-    void endOfLine();\n-};"}, {"sha": "80ec36e00e6b5303cf3817b964257cecb5122128", "filename": "gcc/d/dmd/macro.h", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Fd%2Fdmd%2Fmacro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Fd%2Fdmd%2Fmacro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmacro.h?ref=c15aa46cca0649b68613d3292cf71c7cc57ef78f", "patch": "@@ -1,38 +0,0 @@\n-\n-/* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n- * written by Walter Bright\n- * http://www.digitalmars.com\n- * Distributed under the Boost Software License, Version 1.0.\n- * http://www.boost.org/LICENSE_1_0.txt\n- * https://github.com/D-Programming-Language/dmd/blob/master/src/macro.h\n- */\n-\n-#pragma once\n-\n-#include \"root/dsystem.h\"\n-#include \"root/port.h\"\n-\n-\n-struct Macro\n-{\n-  private:\n-    Macro *next;                // next in list\n-\n-    const utf8_t *name;        // macro name\n-    size_t namelen;             // length of macro name\n-\n-    const utf8_t *text;        // macro replacement text\n-    size_t textlen;             // length of replacement text\n-\n-    int inuse;                  // macro is in use (don't expand)\n-\n-    Macro(const utf8_t *name, size_t namelen, const utf8_t *text, size_t textlen);\n-    Macro *search(const utf8_t *name, size_t namelen);\n-\n-  public:\n-    static Macro *define(Macro **ptable, const utf8_t *name, size_t namelen, const utf8_t *text, size_t textlen);\n-\n-    void expand(OutBuffer *buf, size_t start, size_t *pend,\n-        const utf8_t *arg, size_t arglen);\n-};"}, {"sha": "9b9c278c8a78842d50f96ce6ec0e04171006ca5a", "filename": "gcc/d/dmd/mars.h", "status": "removed", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Fd%2Fdmd%2Fmars.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Fd%2Fdmd%2Fmars.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmars.h?ref=c15aa46cca0649b68613d3292cf71c7cc57ef78f", "patch": "@@ -1,93 +0,0 @@\n-\n-/* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n- * written by Walter Bright\n- * http://www.digitalmars.com\n- * Distributed under the Boost Software License, Version 1.0.\n- * http://www.boost.org/LICENSE_1_0.txt\n- * https://github.com/dlang/dmd/blob/master/src/dmd/mars.h\n- */\n-\n-#pragma once\n-\n-/*\n-It is very important to use version control macros correctly - the\n-idea is that host and target are independent. If these are done\n-correctly, cross compilers can be built.\n-The host compiler and host operating system are also different,\n-and are predefined by the host compiler. The ones used in\n-dmd are:\n-\n-Macros defined by the compiler, not the code:\n-\n-    Compiler:\n-        __DMC__         Digital Mars compiler\n-        _MSC_VER        Microsoft compiler\n-        __GNUC__        Gnu compiler\n-        __clang__       Clang compiler\n-\n-    Host operating system:\n-        _WIN32          Microsoft NT, Windows 95, Windows 98, Win32s,\n-                        Windows 2000, Win XP, Vista\n-        _WIN64          Windows for AMD64\n-        __linux__       Linux\n-        __APPLE__       Mac OSX\n-        __FreeBSD__     FreeBSD\n-        __OpenBSD__     OpenBSD\n-        __sun           Solaris, OpenSolaris, SunOS, OpenIndiana, etc\n-\n-For the target systems, there are the target operating system and\n-the target object file format:\n-\n-    Target operating system:\n-        TARGET_WINDOS   Covers 32 bit windows and 64 bit windows\n-        TARGET_LINUX    Covers 32 and 64 bit linux\n-        TARGET_OSX      Covers 32 and 64 bit Mac OSX\n-        TARGET_FREEBSD  Covers 32 and 64 bit FreeBSD\n-        TARGET_OPENBSD  Covers 32 and 64 bit OpenBSD\n-        TARGET_SOLARIS  Covers 32 and 64 bit Solaris\n-\n-    It is expected that the compiler for each platform will be able\n-    to generate 32 and 64 bit code from the same compiler binary.\n-\n-    There are currently no macros for byte endianness order.\n- */\n-\n-\n-#include \"root/dsystem.h\"\n-\n-#ifdef __DMC__\n-#ifdef DEBUG\n-#undef assert\n-#define assert(e) (static_cast<void>((e) || (printf(\"assert %s(%d) %s\\n\", __FILE__, __LINE__, #e), halt())))\n-#endif\n-#endif\n-\n-void unittests();\n-\n-struct OutBuffer;\n-\n-#include \"globals.h\"\n-\n-#include \"root/ctfloat.h\"\n-\n-#include \"complex_t.h\"\n-\n-#include \"errors.h\"\n-\n-class Dsymbol;\n-class Library;\n-struct File;\n-void obj_start(char *srcfile);\n-void obj_end(Library *library, File *objfile);\n-void obj_append(Dsymbol *s);\n-void obj_write_deferred(Library *library);\n-\n-/// Utility functions used by both main and frontend.\n-void readFile(Loc loc, File *f);\n-void writeFile(Loc loc, File *f);\n-void ensurePathToNameExists(Loc loc, const char *name);\n-\n-const char *importHint(const char *s);\n-/// Little helper function for writing out deps.\n-void escapePath(OutBuffer *buf, const char *fname);"}, {"sha": "fe4c73a021cd05e10d03849d30cd3191fe72c0ad", "filename": "gcc/d/dmd/module.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fmodule.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fmodule.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmodule.h?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -119,7 +119,7 @@ class Module : public Package\n \n     static Module* create(const char *arg, Identifier *ident, int doDocComment, int doHdrGen);\n \n-    static Module *load(Loc loc, Identifiers *packages, Identifier *ident);\n+    static Module *load(const Loc &loc, Identifiers *packages, Identifier *ident);\n \n     const char *kind() const;\n     bool read(const Loc &loc); // read file, returns 'true' if succeed, 'false' otherwise."}, {"sha": "a21924b3aacb5ad77345b42af9b56bb46a4f3bae", "filename": "gcc/d/dmd/mtype.d", "status": "modified", "additions": 135, "deletions": 76, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fmtype.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fmtype.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -43,7 +43,7 @@ import dmd.identifier;\n import dmd.init;\n import dmd.opover;\n import dmd.root.ctfloat;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.root.rmem;\n import dmd.root.rootobject;\n import dmd.root.stringtable;\n@@ -237,6 +237,7 @@ enum DotExpFlag\n {\n     gag     = 1,    // don't report \"not a property\" error and just return null\n     noDeref = 2,    // the use of the expression will not attempt a dereference\n+    noAliasThis = 4, // don't do 'alias this' resolution\n }\n \n /// Result of a check whether two types are covariant\n@@ -426,6 +427,13 @@ extern (C++) abstract class Type : ASTNode\n         return DYNCAST.type;\n     }\n \n+    /// Returns a non-zero unique ID for this Type, or returns 0 if the Type does not (yet) have a unique ID.\n+    /// If `semantic()` has not been run, 0 is returned.\n+    final size_t getUniqueID() const\n+    {\n+        return cast(size_t) deco;\n+    }\n+\n     extern (D)\n     final Mcache* getMcache()\n     {\n@@ -2298,7 +2306,9 @@ extern (C++) abstract class Type : ASTNode\n      */\n     structalign_t alignment()\n     {\n-        return STRUCTALIGN_DEFAULT;\n+        structalign_t s;\n+        s.setDefault();\n+        return s;\n     }\n \n     /***************************************\n@@ -3532,6 +3542,13 @@ extern (C++) final class TypeSArray : TypeArray\n         this.dim = dim;\n     }\n \n+    extern (D) this(Type t)  // for incomplete type\n+    {\n+        super(Tsarray, t);\n+        //printf(\"TypeSArray()\\n\");\n+        this.dim = new IntegerExp(0);\n+    }\n+\n     override const(char)* kind() const\n     {\n         return \"sarray\";\n@@ -3546,6 +3563,15 @@ extern (C++) final class TypeSArray : TypeArray\n         return result;\n     }\n \n+    /***\n+     * C11 6.7.6.2-4 incomplete array type\n+     * Returns: true if incomplete type\n+     */\n+    bool isIncomplete()\n+    {\n+        return dim.isIntegerExp() && dim.isIntegerExp().getInteger() == 0;\n+    }\n+\n     override d_uns64 size(const ref Loc loc)\n     {\n         //printf(\"TypeSArray::size()\\n\");\n@@ -3952,65 +3978,37 @@ extern (C++) final class TypePointer : TypeNext\n         if (equals(to))\n             return MATCH.exact;\n \n-        if (next.ty == Tfunction)\n-        {\n-            if (auto tp = to.isTypePointer())\n-            {\n-                if (tp.next.ty == Tfunction)\n-                {\n-                    if (next.equals(tp.next))\n-                        return MATCH.constant;\n-\n-                    if (next.covariant(tp.next) == Covariant.yes)\n-                    {\n-                        Type tret = this.next.nextOf();\n-                        Type toret = tp.next.nextOf();\n-                        if (tret.ty == Tclass && toret.ty == Tclass)\n-                        {\n-                            /* https://issues.dlang.org/show_bug.cgi?id=10219\n-                             * Check covariant interface return with offset tweaking.\n-                             * interface I {}\n-                             * class C : Object, I {}\n-                             * I function() dg = function C() {}    // should be error\n-                             */\n-                            int offset = 0;\n-                            if (toret.isBaseOf(tret, &offset) && offset != 0)\n-                                return MATCH.nomatch;\n-                        }\n-                        return MATCH.convert;\n-                    }\n-                }\n-                else if (tp.next.ty == Tvoid)\n-                {\n-                    // Allow conversions to void*\n-                    return MATCH.convert;\n-                }\n-            }\n+        // Only convert between pointers\n+        auto tp = to.isTypePointer();\n+        if (!tp)\n             return MATCH.nomatch;\n-        }\n-        else if (auto tp = to.isTypePointer())\n+\n+        assert(this.next);\n+        assert(tp.next);\n+\n+        // Conversion to void*\n+        if (tp.next.ty == Tvoid)\n         {\n-            assert(tp.next);\n+            // Function pointer conversion doesn't check constness?\n+            if (this.next.ty == Tfunction)\n+                return MATCH.convert;\n \n             if (!MODimplicitConv(next.mod, tp.next.mod))\n                 return MATCH.nomatch; // not const-compatible\n \n-            /* Alloc conversion to void*\n-             */\n-            if (next.ty != Tvoid && tp.next.ty == Tvoid)\n-            {\n-                return MATCH.convert;\n-            }\n-\n-            MATCH m = next.constConv(tp.next);\n-            if (m > MATCH.nomatch)\n-            {\n-                if (m == MATCH.exact && mod != to.mod)\n-                    m = MATCH.constant;\n-                return m;\n-            }\n+            return this.next.ty == Tvoid ? MATCH.constant : MATCH.convert;\n         }\n-        return MATCH.nomatch;\n+\n+        // Conversion between function pointers\n+        if (auto thisTf = this.next.isTypeFunction())\n+            return thisTf.implicitPointerConv(tp.next);\n+\n+        // Default, no implicit conversion between the pointer targets\n+        MATCH m = next.constConv(tp.next);\n+\n+        if (m == MATCH.exact && mod != to.mod)\n+            m = MATCH.constant;\n+        return m;\n     }\n \n     override MATCH constConv(Type to)\n@@ -4760,7 +4758,10 @@ extern (C++) final class TypeFunction : TypeNext\n                             }\n                         }\n                         else\n-                            m = arg.implicitConvTo(tprm);\n+                        {\n+                            import dmd.dcast : cimplicitConvTo;\n+                            m = (sc && sc.flags & SCOPE.Cfile) ? arg.cimplicitConvTo(tprm) : arg.implicitConvTo(tprm);\n+                        }\n                     }\n                     //printf(\"match %d\\n\", m);\n                 }\n@@ -4971,6 +4972,47 @@ extern (C++) final class TypeFunction : TypeNext\n         return MATCH.nomatch;\n     }\n \n+    /+\n+     + Checks whether this function type is convertible to ` to`\n+     + when used in a function pointer / delegate.\n+     +\n+     + Params:\n+     +   to = target type\n+     +\n+     + Returns:\n+     +   MATCH.nomatch: `to` is not a covaraint function\n+     +   MATCH.convert: `to` is a covaraint function\n+     +   MATCH.exact:   `to` is identical to this function\n+     +/\n+    private MATCH implicitPointerConv(Type to)\n+    {\n+        assert(to);\n+\n+        if (this == to)\n+            return MATCH.constant;\n+\n+        if (this.covariant(to) == Covariant.yes)\n+        {\n+            Type tret = this.nextOf();\n+            Type toret = to.nextOf();\n+            if (tret.ty == Tclass && toret.ty == Tclass)\n+            {\n+                /* https://issues.dlang.org/show_bug.cgi?id=10219\n+                 * Check covariant interface return with offset tweaking.\n+                 * interface I {}\n+                 * class C : Object, I {}\n+                 * I function() dg = function C() {}    // should be error\n+                 */\n+                int offset = 0;\n+                if (toret.isBaseOf(tret, &offset) && offset != 0)\n+                    return MATCH.nomatch;\n+            }\n+            return MATCH.convert;\n+        }\n+\n+        return MATCH.nomatch;\n+    }\n+\n     /** Extends TypeNext.constConv by also checking for matching attributes **/\n     override MATCH constConv(Type to)\n     {\n@@ -5262,27 +5304,16 @@ extern (C++) final class TypeDelegate : TypeNext\n         if (this == to)\n             return MATCH.exact;\n \n-        version (all)\n+        if (auto toDg = to.isTypeDelegate())\n         {\n-            // not allowing covariant conversions because it interferes with overriding\n-            if (to.ty == Tdelegate && this.nextOf().covariant(to.nextOf()) == Covariant.yes)\n-            {\n-                Type tret = this.next.nextOf();\n-                Type toret = (cast(TypeDelegate)to).next.nextOf();\n-                if (tret.ty == Tclass && toret.ty == Tclass)\n-                {\n-                    /* https://issues.dlang.org/show_bug.cgi?id=10219\n-                     * Check covariant interface return with offset tweaking.\n-                     * interface I {}\n-                     * class C : Object, I {}\n-                     * I delegate() dg = delegate C() {}    // should be error\n-                     */\n-                    int offset = 0;\n-                    if (toret.isBaseOf(tret, &offset) && offset != 0)\n-                        return MATCH.nomatch;\n-                }\n-                return MATCH.convert;\n-            }\n+            MATCH m = this.next.isTypeFunction().implicitPointerConv(toDg.next);\n+\n+            // Retain the old behaviour for this refactoring\n+            // Should probably be changed to constant to match function pointers\n+            if (m > MATCH.convert)\n+                m = MATCH.convert;\n+\n+            return m;\n         }\n \n         return MATCH.nomatch;\n@@ -5516,6 +5547,11 @@ extern (C++) final class TypeIdentifier : TypeQualified\n         this.ident = ident;\n     }\n \n+    static TypeIdentifier create(const ref Loc loc, Identifier ident)\n+    {\n+        return new TypeIdentifier(loc, ident);\n+    }\n+\n     override const(char)* kind() const\n     {\n         return \"identifier\";\n@@ -5737,7 +5773,7 @@ extern (C++) final class TypeStruct : Type\n \n     override structalign_t alignment()\n     {\n-        if (sym.alignment == 0)\n+        if (sym.alignment.isUnknown())\n             sym.size(sym.loc);\n         return sym.alignment;\n     }\n@@ -6519,6 +6555,29 @@ extern (C++) final class TypeTuple : Type\n         return false;\n     }\n \n+    override MATCH implicitConvTo(Type to)\n+    {\n+        if (this == to)\n+            return MATCH.exact;\n+        if (auto tt = to.isTypeTuple())\n+        {\n+            if (arguments.dim == tt.arguments.dim)\n+            {\n+                MATCH m = MATCH.exact;\n+                for (size_t i = 0; i < tt.arguments.dim; i++)\n+                {\n+                    Parameter arg1 = (*arguments)[i];\n+                    Parameter arg2 = (*tt.arguments)[i];\n+                    MATCH mi = arg1.type.implicitConvTo(arg2.type);\n+                    if (mi < m)\n+                        m = mi;\n+                }\n+                return m;\n+            }\n+        }\n+        return MATCH.nomatch;\n+    }\n+\n     override void accept(Visitor v)\n     {\n         v.visit(this);"}, {"sha": "430b39b205c94fbf6f12c66548fedaba1a3e7eb9", "filename": "gcc/d/dmd/mtype.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fmtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fmtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.h?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -224,6 +224,7 @@ class Type : public ASTNode\n     bool equivalent(Type *t);\n     // kludge for template.isType()\n     DYNCAST dyncast() const { return DYNCAST_TYPE; }\n+    size_t getUniqueID() const;\n     Covariant covariant(Type *t, StorageClass *pstc = NULL);\n     const char *toChars() const;\n     char *toPrettyChars(bool QualifyTypes = false);\n@@ -446,6 +447,7 @@ class TypeSArray : public TypeArray\n \n     const char *kind();\n     TypeSArray *syntaxCopy();\n+    bool isIncomplete();\n     d_uns64 size(const Loc &loc);\n     unsigned alignsize();\n     bool isString();\n@@ -582,6 +584,7 @@ struct ParameterList\n     Parameters* parameters;\n     StorageClass stc;\n     VarArg varargs;\n+    bool hasIdentifierList; // true if C identifier-list style\n \n     size_t length();\n     Parameter *operator[](size_t i) { return Parameter::getNth(parameters, i); }\n@@ -711,6 +714,7 @@ class TypeIdentifier : public TypeQualified\n     Identifier *ident;\n     Dsymbol *originalSymbol; // The symbol representing this identifier, before alias resolution\n \n+    static TypeIdentifier *create(const Loc &loc, Identifier *ident);\n     const char *kind();\n     TypeIdentifier *syntaxCopy();\n     Dsymbol *toDsymbol(Scope *sc);"}, {"sha": "605e9f3bfdd94ba55f7c07aa336b32bc2e47cda8", "filename": "gcc/d/dmd/ob.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fob.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fob.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fob.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -43,7 +43,7 @@ import dmd.tokens;\n import dmd.visitor;\n \n import dmd.root.bitarray;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n \n /**********************************\n  * Perform ownership/borrowing checks for funcdecl."}, {"sha": "eb4ba1db20de663d55e35387e8ac54115e1f97e3", "filename": "gcc/d/dmd/objc.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fobjc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fobjc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fobjc.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -38,7 +38,7 @@ import dmd.id;\n import dmd.identifier;\n import dmd.mtype;\n import dmd.root.array;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.root.stringtable;\n import dmd.target;\n import dmd.tokens;"}, {"sha": "ff03a6e0d3cc0b6ced3a6c51398453d2d4a19e40", "filename": "gcc/d/dmd/opover.d", "status": "modified", "additions": 34, "deletions": 9, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fopover.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fopover.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fopover.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -213,9 +213,13 @@ private Expression checkAliasThisForLhs(AggregateDeclaration ad, Scope* sc, BinE\n     if (isRecursiveAliasThis(e.att1, e.e1.type))\n         return null;\n     //printf(\"att %s e1 = %s\\n\", Token::toChars(e.op), e.e1.type.toChars());\n-    Expression e1 = new DotIdExp(e.loc, e.e1, ad.aliasthis.ident);\n     BinExp be = cast(BinExp)e.copy();\n-    be.e1 = e1;\n+    // Resolve 'alias this' but in case of assigment don't resolve properties yet\n+    // because 'e1 = e2' could mean 'e1(e2)' or 'e1() = e2'\n+    bool findOnly = (e.op == TOK.assign);\n+    be.e1 = resolveAliasThis(sc, e.e1, true, findOnly);\n+    if (!be.e1)\n+        return null;\n \n     Expression result;\n     if (be.op == TOK.concatenateAssign)\n@@ -237,9 +241,10 @@ private Expression checkAliasThisForRhs(AggregateDeclaration ad, Scope* sc, BinE\n     if (isRecursiveAliasThis(e.att2, e.e2.type))\n         return null;\n     //printf(\"att %s e2 = %s\\n\", Token::toChars(e.op), e.e2.type.toChars());\n-    Expression e2 = new DotIdExp(e.loc, e.e2, ad.aliasthis.ident);\n     BinExp be = cast(BinExp)e.copy();\n-    be.e2 = e2;\n+    be.e2 = resolveAliasThis(sc, e.e2, true);\n+    if (!be.e2)\n+        return null;\n \n     Expression result;\n     if (be.op == TOK.concatenateAssign)\n@@ -1744,11 +1749,31 @@ private FuncDeclaration findBestOpApplyMatch(Expression ethis, FuncDeclaration f\n         else if (m == match && m > MATCH.nomatch)\n         {\n             assert(fd_best);\n-            /* Ignore covariant matches, as later on it can be redone\n-             * after the opApply delegate has its attributes inferred.\n-             */\n-            if (tf.covariant(fd_best.type) != Covariant.yes &&\n-                fd_best.type.covariant(tf) != Covariant.yes)\n+            auto bestTf = fd_best.type.isTypeFunction();\n+            assert(bestTf);\n+\n+            // Found another overload with different attributes?\n+            // e.g. @system vs. @safe opApply\n+            bool ambig = tf.attributesEqual(bestTf);\n+\n+            // opApplies with identical attributes could still accept\n+            // different function bodies as delegate\n+            // => different parameters or attributes\n+            if (ambig)\n+            {\n+                // Fetch the delegates that receive the function body\n+                auto tfBody = tf.parameterList[0].type.isTypeDelegate().next;\n+                assert(tfBody);\n+\n+                auto bestBody = bestTf.parameterList[0].type.isTypeDelegate().next;\n+                assert(bestBody);\n+\n+                // Ignore covariant matches, as later on it can be redone\n+                // after the opApply delegate has its attributes inferred.\n+                ambig = !(tfBody.covariant(bestBody) == Covariant.yes || bestBody.covariant(tfBody) == Covariant.yes);\n+            }\n+\n+            if (ambig)\n                 fd_ambig = f;                           // not covariant, so ambiguous\n         }\n         return 0;               // continue"}, {"sha": "9f116fe850968e4767a54931bd7f11628f2308ea", "filename": "gcc/d/dmd/optimize.d", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Foptimize.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Foptimize.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Foptimize.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -697,6 +697,8 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n                 // See if we can remove an unnecessary cast\n                 ClassDeclaration cdfrom = e.e1.type.isClassHandle();\n                 ClassDeclaration cdto = e.type.isClassHandle();\n+                if (cdfrom.errors || cdto.errors)\n+                    return error();\n                 if (cdto == ClassDeclaration.object && !cdfrom.isInterfaceDeclaration())\n                     goto L1;    // can always convert a class to Object\n                 // Need to determine correct offset before optimizing away the cast."}, {"sha": "f00ceb6cc937f806f4ad87cbdb0d2f92a1190646", "filename": "gcc/d/dmd/parse.d", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -22,7 +22,7 @@ import dmd.identifier;\n import dmd.lexer;\n import dmd.errors;\n import dmd.root.filename;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.root.rmem;\n import dmd.root.rootobject;\n import dmd.root.string;\n@@ -556,6 +556,9 @@ class Parser(AST) : Lexer\n                     {\n                     case TOK.leftParenthesis:\n                         {\n+                            // MixinType\n+                            if (isDeclaration(&token, NeedDeclaratorId.mustIfDstyle, TOK.reserved, null))\n+                                goto Ldeclaration;\n                             // mixin(string)\n                             nextToken();\n                             auto exps = parseArguments();\n@@ -2954,6 +2957,8 @@ class Parser(AST) : Lexer\n                         // Don't call nextToken again.\n                     }\n                 case TOK.in_:\n+                    if (global.params.vin)\n+                        message(scanloc, \"Usage of 'in' on parameter\");\n                     stc = STC.in_;\n                     goto L2;\n \n@@ -5408,6 +5413,11 @@ class Parser(AST) : Lexer\n                     stc = STC.scope_;\n                     goto Lagain;\n \n+                case TOK.out_:\n+                    error(\"cannot declare `out` loop variable, use `ref` instead\");\n+                    stc = STC.out_;\n+                    goto Lagain;\n+\n                 case TOK.enum_:\n                     stc = STC.manifest;\n                     goto Lagain;"}, {"sha": "a2ad47882eff45a9e38c8d6b6dc4899600b2b297", "filename": "gcc/d/dmd/parse.h", "status": "removed", "additions": 0, "deletions": 192, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Fd%2Fdmd%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Fd%2Fdmd%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.h?ref=c15aa46cca0649b68613d3292cf71c7cc57ef78f", "patch": "@@ -1,192 +0,0 @@\n-\n-/* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n- * written by Walter Bright\n- * http://www.digitalmars.com\n- * Distributed under the Boost Software License, Version 1.0.\n- * http://www.boost.org/LICENSE_1_0.txt\n- * https://github.com/D-Programming-Language/dmd/blob/master/src/parse.h\n- */\n-\n-#pragma once\n-\n-#include \"arraytypes.h\"\n-#include \"lexer.h\"\n-#include \"enum.h\"\n-\n-class Type;\n-class TypeQualified;\n-class Expression;\n-class Declaration;\n-class Statement;\n-class Import;\n-class Initializer;\n-class FuncDeclaration;\n-class CtorDeclaration;\n-class PostBlitDeclaration;\n-class DtorDeclaration;\n-class StaticCtorDeclaration;\n-class StaticDtorDeclaration;\n-class SharedStaticCtorDeclaration;\n-class SharedStaticDtorDeclaration;\n-class ConditionalDeclaration;\n-class InvariantDeclaration;\n-class UnitTestDeclaration;\n-class NewDeclaration;\n-class DeleteDeclaration;\n-class Condition;\n-class Module;\n-struct ModuleDeclaration;\n-class TemplateDeclaration;\n-class TemplateInstance;\n-class StaticAssert;\n-struct PrefixAttributes;\n-\n-/************************************\n- * These control how parseStatement() works.\n- */\n-\n-enum ParseStatementFlags\n-{\n-    PSsemi = 1,         // empty ';' statements are allowed, but deprecated\n-    PSscope = 2,        // start a new scope\n-    PScurly = 4,        // { } statement is required\n-    PScurlyscope = 8,   // { } starts a new scope\n-    PSsemi_ok = 0x10    // empty ';' are really ok\n-};\n-\n-\n-class Parser : public Lexer\n-{\n-public:\n-    Module *mod;\n-    ModuleDeclaration *md;\n-    LINK linkage;\n-    CPPMANGLE cppmangle;\n-    Loc endloc;                 // set to location of last right curly\n-    int inBrackets;             // inside [] of array index or slice\n-    Loc lookingForElse;         // location of lonely if looking for an else\n-\n-    Parser(Loc loc, Module *module, const utf8_t *base, size_t length, bool doDocComment);\n-    Parser(Module *module, const utf8_t *base, size_t length, bool doDocComment);\n-\n-    Dsymbols *parseModule();\n-    Dsymbols *parseDeclDefs(int once, Dsymbol **pLastDecl = NULL, PrefixAttributes *pAttrs = NULL);\n-    Dsymbols *parseAutoDeclarations(StorageClass storageClass, const utf8_t *comment);\n-    Dsymbols *parseBlock(Dsymbol **pLastDecl, PrefixAttributes *pAttrs = NULL);\n-    StorageClass appendStorageClass(StorageClass storageClass, StorageClass stc, bool deprec = false);\n-    StorageClass parseAttribute(Expressions **pexps);\n-    StorageClass parsePostfix(StorageClass storageClass, Expressions **pudas);\n-    StorageClass parseTypeCtor();\n-    Expression *parseConstraint();\n-    TemplateDeclaration *parseTemplateDeclaration(bool ismixin = false);\n-    TemplateParameters *parseTemplateParameterList(int flag = 0);\n-    Dsymbol *parseMixin();\n-    Objects *parseTemplateArguments();\n-    RootObject *parseTypeOrAssignExp(TOK endtoken = TOKreserved);\n-    Objects *parseTemplateArgumentList();\n-    Objects *parseTemplateSingleArgument();\n-    StaticAssert *parseStaticAssert();\n-    TypeQualified *parseTypeof();\n-    Type *parseVector();\n-    LINK parseLinkage(Identifiers **, CPPMANGLE *, bool *);\n-    Identifiers *parseQualifiedIdentifier(const char *entity);\n-    Condition *parseDebugCondition();\n-    Condition *parseVersionCondition();\n-    Condition *parseStaticIfCondition();\n-    Dsymbol *parseCtor(PrefixAttributes *pAttrs);\n-    Dsymbol *parseDtor(PrefixAttributes *pAttrs);\n-    Dsymbol *parseStaticCtor(PrefixAttributes *pAttrs);\n-    Dsymbol *parseStaticDtor(PrefixAttributes *pAttrs);\n-    Dsymbol *parseSharedStaticCtor(PrefixAttributes *pAttrs);\n-    Dsymbol *parseSharedStaticDtor(PrefixAttributes *pAttrs);\n-    Dsymbol *parseInvariant(PrefixAttributes *pAttrs);\n-    Dsymbol *parseUnitTest(PrefixAttributes *pAttrs);\n-    Dsymbol *parseNew(PrefixAttributes *pAttrs);\n-    Dsymbol *parseDelete(PrefixAttributes *pAttrs);\n-    Parameters *parseParameters(VarArg *pvarargs, TemplateParameters **tpl = NULL);\n-    EnumDeclaration *parseEnum();\n-    Dsymbol *parseAggregate();\n-    BaseClasses *parseBaseClasses();\n-    Dsymbols *parseImport();\n-    Type *parseType(Identifier **pident = NULL, TemplateParameters **ptpl = NULL);\n-    Type *parseBasicType(bool dontLookDotIdents = false);\n-    Type *parseBasicTypeStartingAt(TypeQualified *tid, bool dontLookDotIdents);\n-    Type *parseBasicType2(Type *t);\n-    Type *parseDeclarator(Type *t, int *alt, Identifier **pident,\n-        TemplateParameters **tpl = NULL, StorageClass storage_class = 0, int *pdisable = NULL, Expressions **pudas = NULL);\n-    void parseStorageClasses(StorageClass &storage_class, LINK &link, bool &setAlignment, Expression *&ealign, Expressions *&udas);\n-    Dsymbols *parseDeclarations(bool autodecl, PrefixAttributes *pAttrs, const utf8_t *comment);\n-    Dsymbol *parseFunctionLiteral();\n-    FuncDeclaration *parseContracts(FuncDeclaration *f);\n-    void checkDanglingElse(Loc elseloc);\n-    void checkCstyleTypeSyntax(Loc loc, Type *t, int alt, Identifier *ident);\n-    Statement *parseForeach(Loc loc, bool *isRange, bool isDecl);\n-    Dsymbol *parseForeachStaticDecl(Loc loc, Dsymbol **pLastDecl);\n-    Statement *parseForeachStatic(Loc loc);\n-    /** endPtr used for documented unittests */\n-    Statement *parseStatement(int flags, const utf8_t** endPtr = NULL, Loc *pEndloc = NULL);\n-    Initializer *parseInitializer();\n-    Expression *parseDefaultInitExp();\n-    void check(Loc loc, TOK value);\n-    void check(TOK value);\n-    void check(TOK value, const char *string);\n-    void checkParens(TOK value, Expression *e);\n-    bool isDeclaration(Token *t, int needId, TOK endtok, Token **pt);\n-    bool isBasicType(Token **pt);\n-    bool isDeclarator(Token **pt, int *haveId, int *haveTpl, TOK endtok, bool allowAltSyntax = true);\n-    bool isParameters(Token **pt);\n-    bool isExpression(Token **pt);\n-    bool skipParens(Token *t, Token **pt);\n-    bool skipParensIf(Token *t, Token **pt);\n-    bool skipAttributes(Token *t, Token **pt);\n-\n-    Expression *parseExpression();\n-    Expression *parsePrimaryExp();\n-    Expression *parseUnaryExp();\n-    Expression *parsePostExp(Expression *e);\n-    Expression *parseMulExp();\n-    Expression *parseAddExp();\n-    Expression *parseShiftExp();\n-    Expression *parseCmpExp();\n-    Expression *parseAndExp();\n-    Expression *parseXorExp();\n-    Expression *parseOrExp();\n-    Expression *parseAndAndExp();\n-    Expression *parseOrOrExp();\n-    Expression *parseCondExp();\n-    Expression *parseAssignExp();\n-\n-    Expressions *parseArguments();\n-\n-    Expression *parseNewExp(Expression *thisexp);\n-\n-    void addComment(Dsymbol *s, const utf8_t *blockComment);\n-};\n-\n-// Operator precedence - greater values are higher precedence\n-\n-enum PREC\n-{\n-    PREC_zero,\n-    PREC_expr,\n-    PREC_assign,\n-    PREC_cond,\n-    PREC_oror,\n-    PREC_andand,\n-    PREC_or,\n-    PREC_xor,\n-    PREC_and,\n-    PREC_equal,\n-    PREC_rel,\n-    PREC_shift,\n-    PREC_add,\n-    PREC_mul,\n-    PREC_pow,\n-    PREC_unary,\n-    PREC_primary\n-};\n-\n-extern PREC precedence[TOKMAX];\n-\n-void initPrecedence();"}, {"sha": "414d6f665f53f8fd8094bb16cfd1865714e14d73", "filename": "gcc/d/dmd/printast.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fprintast.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fprintast.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fprintast.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -59,7 +59,7 @@ extern (C++) final class PrintASTVisitor : Visitor\n         printIndent(indent);\n \n         import dmd.hdrgen : floatToBuffer;\n-        import dmd.root.outbuffer : OutBuffer;\n+        import dmd.common.outbuffer : OutBuffer;\n         OutBuffer buf;\n         floatToBuffer(e.type, e.value, &buf, false);\n         printf(\"Real %s %s\\n\", buf.peekChars(), e.type ? e.type.toChars() : \"\");"}, {"sha": "e062d93da46dde2378066f48a55780b0845d3d31", "filename": "gcc/d/dmd/root/README.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Froot%2FREADME.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Froot%2FREADME.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2FREADME.md?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -11,7 +11,6 @@\n | [hash.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/hash.d)               | Calculate a hash for a byte array                                                          |\n | [longdouble.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/longdouble.d)   | 80-bit floating point number implementation in case they are not natively supported        |\n | [man.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/man.d)                 | Opens an online manual page                                                                |\n-| [outbuffer.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/outbuffer.d)     | An expandable buffer in which you can write text or binary data.                           |\n | [port.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/port.d)               | Portable routines for functions that have different implementations on different platforms |\n | [region.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/region.d)           | A region allocator                                                                         |\n | [response.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/response.d)       | Parse command line arguments from response files                                           |"}, {"sha": "c65b674a7f51da80d365512224de6a18970fd224", "filename": "gcc/d/dmd/root/aav.h", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Fd%2Fdmd%2Froot%2Faav.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Fd%2Fdmd%2Froot%2Faav.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Faav.h?ref=c15aa46cca0649b68613d3292cf71c7cc57ef78f", "patch": "@@ -1,22 +0,0 @@\n-\n-/* Copyright (C) 2010-2021 by The D Language Foundation, All Rights Reserved\n- * http://www.digitalmars.com\n- * Distributed under the Boost Software License, Version 1.0.\n- * (See accompanying file LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)\n- * https://github.com/D-Programming-Language/dmd/blob/master/src/root/aav.h\n- */\n-\n-#pragma once\n-\n-#include \"dsystem.h\"\n-\n-typedef void* Value;\n-typedef void* Key;\n-\n-struct AA;\n-\n-size_t dmd_aaLen(AA* aa);\n-Value* dmd_aaGet(AA** aa, Key key);\n-Value dmd_aaGetRvalue(AA* aa, Key key);\n-void dmd_aaRehash(AA** paa);\n-"}, {"sha": "8a7d9c90d9f4b57f520fa8d8111e15f6215ad80e", "filename": "gcc/d/dmd/root/checkedint.h", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Fd%2Fdmd%2Froot%2Fcheckedint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Fd%2Fdmd%2Froot%2Fcheckedint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fcheckedint.h?ref=c15aa46cca0649b68613d3292cf71c7cc57ef78f", "patch": "@@ -1,30 +0,0 @@\n-\n-/* Compiler implementation of the D programming language\n- * Copyright (C) 2003-2021 by The D Language Foundation, All Rights Reserved\n- * written by Walter Bright\n- * http://www.digitalmars.com\n- * Distributed under the Boost Software License, Version 1.0.\n- * http://www.boost.org/LICENSE_1_0.txt\n- * https://github.com/D-Programming-Language/dmd/blob/master/src/root/checkedint.h\n- */\n-\n-#include \"dsystem.h\"\n-\n-\n-int adds(int x, int y, bool& overflow);\n-int64_t adds(int64_t x, int64_t y, bool& overflow);\n-unsigned addu(unsigned x, unsigned y, bool& overflow);\n-uint64_t addu(uint64_t x, uint64_t y, bool& overflow);\n-\n-int subs(int x, int y, bool& overflow);\n-int64_t subs(int64_t x, int64_t y, bool& overflow);\n-unsigned subu(unsigned x, unsigned y, bool& overflow);\n-uint64_t subu(uint64_t x, uint64_t y, bool& overflow);\n-\n-int negs(int x, bool& overflow);\n-int64_t negs(int64_t x, bool& overflow);\n-\n-int muls(int x, int y, bool& overflow);\n-int64_t muls(int64_t x, int64_t y, bool& overflow);\n-unsigned mulu(unsigned x, unsigned y, bool& overflow);\n-uint64_t mulu(uint64_t x, uint64_t y, bool& overflow);"}, {"sha": "64e9571632282a4d502d9d261598960aee251214", "filename": "gcc/d/dmd/root/file.d", "status": "modified", "additions": 4, "deletions": 525, "changes": 529, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Froot%2Ffile.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Froot%2Ffile.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Ffile.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -23,410 +23,8 @@ import dmd.root.filename;\n import dmd.root.rmem;\n import dmd.root.string;\n \n-/**\n-Encapsulated management of a memory-mapped file.\n-\n-Params:\n-Datum = the mapped data type: Use a POD of size 1 for read/write mapping\n-and a `const` version thereof for read-only mapping. Other primitive types\n-should work, but have not been yet tested.\n-*/\n-struct FileMapping(Datum)\n-{\n-    static assert(__traits(isPOD, Datum) && Datum.sizeof == 1,\n-        \"Not tested with other data types yet. Add new types with care.\");\n-\n-    version(Posix) enum invalidHandle = -1;\n-    else version(Windows) enum invalidHandle = INVALID_HANDLE_VALUE;\n-\n-    // state {\n-    /// Handle of underlying file\n-    private auto handle = invalidHandle;\n-    /// File mapping object needed on Windows\n-    version(Windows) private HANDLE fileMappingObject = invalidHandle;\n-    /// Memory-mapped array\n-    private Datum[] data;\n-    /// Name of underlying file, zero-terminated\n-    private const(char)* name;\n-    // state }\n-\n-    /**\n-    Open `filename` and map it in memory. If `Datum` is `const`, opens for\n-    read-only and maps the content in memory; no error is issued if the file\n-    does not exist. This makes it easy to treat a non-existing file as empty.\n-\n-    If `Datum` is mutable, opens for read/write (creates file if it does not\n-    exist) and fails fatally on any error.\n-\n-    Due to quirks in `mmap`, if the file is empty, `handle` is valid but `data`\n-    is `null`. This state is valid and accounted for.\n-\n-    Params:\n-    filename = the name of the file to be mapped in memory\n-    */\n-    this(const char* filename)\n-    {\n-        version (Posix)\n-        {\n-            import core.sys.posix.sys.mman;\n-            import core.sys.posix.fcntl;\n-\n-            handle = .open(filename, is(Datum == const) ? O_RDONLY : (O_CREAT | O_RDWR),\n-                S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n-\n-            if (handle == invalidHandle)\n-            {\n-                static if (is(Datum == const))\n-                {\n-                    // No error, nonexisting file in read mode behaves like an empty file.\n-                    return;\n-                }\n-                else\n-                {\n-                    fprintf(stderr, \"open(\\\"%s\\\") failed: %s\\n\", filename, strerror(errno));\n-                    exit(1);\n-                }\n-            }\n-\n-            const size = File.size(handle);\n-\n-            if (size > 0 && size != ulong.max && size <= size_t.max)\n-            {\n-                auto p = mmap(null, cast(size_t) size, is(Datum == const) ? PROT_READ : PROT_WRITE, MAP_SHARED, handle, 0);\n-                if (p == MAP_FAILED)\n-                {\n-                    fprintf(stderr, \"mmap(null, %zu) for \\\"%s\\\" failed: %s\\n\", cast(size_t) size, filename, strerror(errno));\n-                    exit(1);\n-                }\n-                // The cast below will always work because it's gated by the `size <= size_t.max` condition.\n-                data = cast(Datum[]) p[0 .. cast(size_t) size];\n-            }\n-        }\n-        else version(Windows)\n-        {\n-            static if (is(Datum == const))\n-            {\n-                enum createFileMode = GENERIC_READ;\n-                enum openFlags = OPEN_EXISTING;\n-            }\n-            else\n-            {\n-                enum createFileMode = GENERIC_READ | GENERIC_WRITE;\n-                enum openFlags = CREATE_ALWAYS;\n-            }\n-\n-            handle = CreateFileA(filename, createFileMode, 0, null, openFlags, FILE_ATTRIBUTE_NORMAL, null);\n-            if (handle == invalidHandle)\n-            {\n-                static if (is(Datum == const))\n-                {\n-                    return;\n-                }\n-                else\n-                {\n-                    fprintf(stderr, \"CreateFileA() failed for \\\"%s\\\": %d\\n\", filename, GetLastError());\n-                    exit(1);\n-                }\n-            }\n-            createMapping(filename, File.size(handle));\n-        }\n-        else static assert(0);\n-\n-        // Save the name for later. Technically there's no need: on Linux one can use readlink on /proc/self/fd/NNN.\n-        // On BSD and OSX one can use fcntl with F_GETPATH. On Windows one can use GetFileInformationByHandleEx.\n-        // But just saving the name is simplest, fastest, and most portable...\n-        import core.stdc.string : strlen;\n-        name = filename[0 .. filename.strlen() + 1].idup.ptr;\n-    }\n-\n-    /**\n-    Common code factored opportunistically. Windows only. Assumes `handle` is\n-    already pointing to an opened file. Initializes the `fileMappingObject`\n-    and `data` members.\n-\n-    Params:\n-    filename = the file to be mapped\n-    size = the size of the file in bytes\n-    */\n-    version(Windows) private void createMapping(const char* filename, ulong size)\n-    {\n-        assert(size <= size_t.max || size == ulong.max);\n-        assert(handle != invalidHandle);\n-        assert(data is null);\n-        assert(fileMappingObject == invalidHandle);\n-\n-        if (size == 0 || size == ulong.max)\n-            return;\n-\n-        static if (is(Datum == const))\n-        {\n-            enum fileMappingFlags = PAGE_READONLY;\n-            enum mapViewFlags = FILE_MAP_READ;\n-        }\n-        else\n-        {\n-            enum fileMappingFlags = PAGE_READWRITE;\n-            enum mapViewFlags = FILE_MAP_WRITE;\n-        }\n-\n-        fileMappingObject = CreateFileMappingA(handle, null, fileMappingFlags, 0, 0, null);\n-        if (!fileMappingObject)\n-        {\n-            fprintf(stderr, \"CreateFileMappingA(%p) failed for %llu bytes of \\\"%s\\\": %d\\n\",\n-                handle, size, filename, GetLastError());\n-            fileMappingObject = invalidHandle;  // by convention always use invalidHandle, not null\n-            exit(1);\n-        }\n-        auto p = MapViewOfFile(fileMappingObject, mapViewFlags, 0, 0, 0);\n-        if (!p)\n-        {\n-            fprintf(stderr, \"MapViewOfFile() failed for \\\"%s\\\": %d\\n\", filename, GetLastError());\n-            exit(1);\n-        }\n-        data = cast(Datum[]) p[0 .. cast(size_t) size];\n-    }\n-\n-    // Not copyable or assignable (for now).\n-    @disable this(const FileMapping!Datum rhs);\n-    @disable void opAssign(const ref FileMapping!Datum rhs);\n-\n-    /**\n-    Frees resources associated with this mapping. However, it does not deallocate the name.\n-    */\n-    ~this() pure nothrow\n-    {\n-        if (!active)\n-            return;\n-        fakePure({\n-            version (Posix)\n-            {\n-                import core.sys.posix.sys.mman : munmap;\n-\n-                // Cannot call fprintf from inside a destructor, so exiting silently.\n-\n-                if (data.ptr && munmap(cast(void*) data.ptr, data.length) != 0)\n-                {\n-                    exit(1);\n-                }\n-                data = null;\n-                if (handle != invalidHandle && .close(handle) != 0)\n-                {\n-                    exit(1);\n-                }\n-                handle = invalidHandle;\n-            }\n-            else version(Windows)\n-            {\n-                if (data.ptr !is null && UnmapViewOfFile(cast(void*) data.ptr) == 0)\n-                {\n-                    exit(1);\n-                }\n-                data = null;\n-                if (fileMappingObject != invalidHandle && CloseHandle(fileMappingObject) == 0)\n-                {\n-                    exit(1);\n-                }\n-                fileMappingObject = invalidHandle;\n-                if (handle != invalidHandle && CloseHandle(handle) == 0)\n-                {\n-                    exit(1);\n-                }\n-                handle = invalidHandle;\n-            }\n-            else static assert(0);\n-        });\n-    }\n-\n-    /**\n-    Returns the zero-terminated file name associated with the mapping. Can\n-    be saved beyond the lifetime of `this`.\n-    */\n-    const(char)* filename() const pure @nogc @safe nothrow { return name; }\n-\n-    /**\n-    Frees resources associated with this mapping. However, it does not deallocate the name.\n-    Reinitializes `this` as a fresh object that can be reused.\n-    */\n-    void close()\n-    {\n-        __dtor();\n-        handle = invalidHandle;\n-        version(Windows) fileMappingObject = invalidHandle;\n-        data = null;\n-        name = null;\n-    }\n-\n-    /**\n-    Deletes the underlying file and frees all resources associated.\n-    Reinitializes `this` as a fresh object that can be reused.\n-\n-    This function does not abort if the file cannot be deleted, but does print\n-    a message on `stderr` and returns `false` to the caller. The underlying\n-    rationale is to give the caller the option to continue execution if\n-    deleting the file is not important.\n-\n-    Returns: `true` iff the file was successfully deleted. If the file was not\n-    deleted, prints a message to `stderr` and returns `false`.\n-    */\n-    static if (!is(Datum == const))\n-    bool discard()\n-    {\n-        // Truncate file to zero so unflushed buffers are not flushed unnecessarily.\n-        resize(0);\n-        auto deleteme = name;\n-        close();\n-        // In-memory resource freed, now get rid of the underlying temp file.\n-        version(Posix)\n-        {\n-            import core.sys.posix.unistd;\n-            if (unlink(deleteme) != 0)\n-            {\n-                fprintf(stderr, \"unlink(\\\"%s\\\") failed: %s\\n\", filename, strerror(errno));\n-                return false;\n-            }\n-        }\n-        else version(Windows)\n-        {\n-            import core.sys.windows.winbase;\n-            if (DeleteFileA(deleteme) == 0)\n-            {\n-                fprintf(stderr, \"DeleteFileA error %d\\n\", GetLastError());\n-                return false;\n-            }\n-        }\n-        else static assert(0);\n-        return true;\n-    }\n-\n-    /**\n-    Queries whether `this` is currently associated with a file.\n-\n-    Returns: `true` iff there is an active mapping.\n-    */\n-    bool active() const pure @nogc nothrow\n-    {\n-        return handle !is invalidHandle;\n-    }\n-\n-    /**\n-    Queries the length of the file associated with this mapping.  If not\n-    active, returns 0.\n-\n-    Returns: the length of the file, or 0 if no file associated.\n-    */\n-    size_t length() const pure @nogc @safe nothrow { return data.length; }\n-\n-    /**\n-    Get a slice to the contents of the entire file.\n-\n-    Returns: the contents of the file. If not active, returns the `null` slice.\n-    */\n-    auto opSlice() pure @nogc @safe nothrow { return data; }\n-\n-    /**\n-    Resizes the file and mapping to the specified `size`.\n-\n-    Params:\n-    size = new length requested\n-    */\n-    static if (!is(Datum == const))\n-    void resize(size_t size) pure\n-    {\n-        assert(handle != invalidHandle);\n-        fakePure({\n-            version(Posix)\n-            {\n-                import core.sys.posix.unistd : ftruncate;\n-                import core.sys.posix.sys.mman;\n-\n-                if (data.length)\n-                {\n-                    assert(data.ptr, \"Corrupt memory mapping\");\n-                    // assert(0) here because it would indicate an internal error\n-                    munmap(cast(void*) data.ptr, data.length) == 0 || assert(0);\n-                    data = null;\n-                }\n-                if (ftruncate(handle, size) != 0)\n-                {\n-                    fprintf(stderr, \"ftruncate() failed for \\\"%s\\\": %s\\n\", filename, strerror(errno));\n-                    exit(1);\n-                }\n-                if (size > 0)\n-                {\n-                    auto p = mmap(null, size, PROT_WRITE, MAP_SHARED, handle, 0);\n-                    if (cast(ssize_t) p == -1)\n-                    {\n-                        fprintf(stderr, \"mmap() failed for \\\"%s\\\": %s\\n\", filename, strerror(errno));\n-                        exit(1);\n-                    }\n-                    data = cast(Datum[]) p[0 .. size];\n-                }\n-            }\n-            else version(Windows)\n-            {\n-                // Per documentation, must unmap first.\n-                if (data.length > 0 && UnmapViewOfFile(cast(void*) data.ptr) == 0)\n-                {\n-                    fprintf(stderr, \"UnmapViewOfFile(%p) failed for memory mapping of \\\"%s\\\": %d\\n\",\n-                        data.ptr, filename, GetLastError());\n-                    exit(1);\n-                }\n-                data = null;\n-                if (fileMappingObject != invalidHandle && CloseHandle(fileMappingObject) == 0)\n-                {\n-                    fprintf(stderr, \"CloseHandle() failed for memory mapping of \\\"%s\\\": %d\\n\", filename, GetLastError());\n-                    exit(1);\n-                }\n-                fileMappingObject = invalidHandle;\n-                LARGE_INTEGER biggie;\n-                biggie.QuadPart = size;\n-                if (SetFilePointerEx(handle, biggie, null, FILE_BEGIN) == 0 || SetEndOfFile(handle) == 0)\n-                {\n-                    fprintf(stderr, \"SetFilePointer() failed for \\\"%s\\\": %d\\n\", filename, GetLastError());\n-                    exit(1);\n-                }\n-                createMapping(name, size);\n-            }\n-            else static assert(0);\n-        });\n-    }\n-\n-    /**\n-    Unconditionally and destructively moves the underlying file to `filename`.\n-    If the operation succeds, returns true. Upon failure, prints a message to\n-    `stderr` and returns `false`.\n-\n-    Params: filename = zero-terminated name of the file to move to.\n-\n-    Returns: `true` iff the operation was successful.\n-    */\n-    bool moveToFile(const char* filename)\n-    {\n-        auto oldname = name;\n-\n-        close();\n-        // Rename the underlying file to the target, no copy necessary.\n-        version(Posix)\n-        {\n-            if (.rename(oldname, filename) != 0)\n-            {\n-                fprintf(stderr, \"rename(\\\"%s\\\", \\\"%s\\\") failed: %s\\n\", oldname, filename, strerror(errno));\n-                return false;\n-            }\n-        }\n-        else version(Windows)\n-        {\n-            import core.sys.windows.winbase;\n-            if (MoveFileExA(oldname, filename, MOVEFILE_REPLACE_EXISTING) == 0)\n-            {\n-                fprintf(stderr, \"MoveFileExA(\\\"%s\\\", \\\"%s\\\") failed: %d\\n\", oldname, filename, GetLastError());\n-                return false;\n-            }\n-        }\n-        else static assert(0);\n-        return true;\n-    }\n-}\n+import dmd.common.file;\n+import dmd.common.string;\n \n /// Owns a (rmem-managed) file buffer.\n struct FileBuffer\n@@ -585,58 +183,8 @@ nothrow:\n     /// Write a file, returning `true` on success.\n     extern (D) static bool write(const(char)* name, const void[] data)\n     {\n-        version (Posix)\n-        {\n-            ssize_t numwritten;\n-            int fd = open(name, O_CREAT | O_WRONLY | O_TRUNC, (6 << 6) | (4 << 3) | 4);\n-            if (fd == -1)\n-                goto err;\n-            numwritten = .write(fd, data.ptr, data.length);\n-            if (numwritten != data.length)\n-                goto err2;\n-            if (close(fd) == -1)\n-                goto err;\n-            return true;\n-        err2:\n-            close(fd);\n-            .remove(name);\n-        err:\n-            return false;\n-        }\n-        else version (Windows)\n-        {\n-            DWORD numwritten; // here because of the gotos\n-            const nameStr = name.toDString;\n-            // work around Windows file path length limitation\n-            // (see documentation for extendedPathThen).\n-            HANDLE h = nameStr.extendedPathThen!\n-                (p => CreateFileW(p.ptr,\n-                                  GENERIC_WRITE,\n-                                  0,\n-                                  null,\n-                                  CREATE_ALWAYS,\n-                                  FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,\n-                                  null));\n-            if (h == INVALID_HANDLE_VALUE)\n-                goto err;\n-\n-            if (WriteFile(h, data.ptr, cast(DWORD)data.length, &numwritten, null) != TRUE)\n-                goto err2;\n-            if (numwritten != data.length)\n-                goto err2;\n-            if (!CloseHandle(h))\n-                goto err;\n-            return true;\n-        err2:\n-            CloseHandle(h);\n-            nameStr.extendedPathThen!(p => DeleteFileW(p.ptr));\n-        err:\n-            return false;\n-        }\n-        else\n-        {\n-            static assert(0);\n-        }\n+        import dmd.common.file : writeFile;\n+        return writeFile(name, data);\n     }\n \n     ///ditto\n@@ -717,42 +265,6 @@ nothrow:\n         return update(name, data[0 .. size]);\n     }\n \n-    /// Touch a file to current date\n-    static bool touch(const char* namez)\n-    {\n-        version (Windows)\n-        {\n-            FILETIME ft = void;\n-            SYSTEMTIME st = void;\n-            GetSystemTime(&st);\n-            SystemTimeToFileTime(&st, &ft);\n-\n-            import core.stdc.string : strlen;\n-\n-            // get handle to file\n-            HANDLE h = namez[0 .. namez.strlen()].extendedPathThen!(p => CreateFile(p.ptr,\n-                FILE_WRITE_ATTRIBUTES, FILE_SHARE_READ | FILE_SHARE_WRITE,\n-                null, OPEN_EXISTING,\n-                FILE_ATTRIBUTE_NORMAL, null));\n-            if (h == INVALID_HANDLE_VALUE)\n-                return false;\n-\n-            const f = SetFileTime(h, null, null, &ft); // set last write time\n-\n-            if (!CloseHandle(h))\n-                return false;\n-\n-            return f != 0;\n-        }\n-        else version (Posix)\n-        {\n-            import core.sys.posix.utime;\n-            return utime(namez, null) == 0;\n-        }\n-        else\n-            static assert(0);\n-    }\n-\n     /// Size of a file in bytes.\n     /// Params: namez = null-terminated filename\n     /// Returns: `ulong.max` on any error, the length otherwise.\n@@ -777,38 +289,5 @@ nothrow:\n         // Error cases go here.\n         return ulong.max;\n     }\n-\n-    /// Ditto\n-    version (Posix)\n-    static ulong size(int fd)\n-    {\n-        stat_t buf;\n-        if (fstat(fd, &buf) == 0)\n-            return buf.st_size;\n-        return ulong.max;\n-    }\n-\n-    /// Ditto\n-    version (Windows)\n-    static ulong size(HANDLE fd)\n-    {\n-        ulong result;\n-        if (GetFileSizeEx(fd, cast(LARGE_INTEGER*) &result) == 0)\n-            return result;\n-        return ulong.max;\n-    }\n }\n \n-/**\n-Runs a non-pure function or delegate as pure code. Use with caution.\n-\n-Params:\n-fun = the delegate to run, usually inlined: `fakePure({ ... });`\n-\n-Returns: whatever `fun` returns.\n-*/\n-private auto ref fakePure(F)(scope F fun) pure\n-{\n-    mixin(\"alias PureFun = \" ~ F.stringof ~ \" pure;\");\n-    return (cast(PureFun) fun)();\n-}"}, {"sha": "d1500c8953b38f2673ac5f68642c5e410a9fd0d5", "filename": "gcc/d/dmd/root/filename.d", "status": "modified", "additions": 7, "deletions": 95, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Froot%2Ffilename.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Froot%2Ffilename.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Ffilename.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -16,7 +16,8 @@ import core.stdc.errno;\n import core.stdc.string;\n import dmd.root.array;\n import dmd.root.file;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n+import dmd.common.file;\n import dmd.root.port;\n import dmd.root.rmem;\n import dmd.root.rootobject;\n@@ -1123,78 +1124,13 @@ version(Windows)\n      */\n     private int _mkdir(const(char)[] path) nothrow\n     {\n+        import dmd.common.string : extendedPathThen;\n         const createRet = path.extendedPathThen!(\n             p => CreateDirectoryW(&p[0], null /*securityAttributes*/));\n         // different conventions for CreateDirectory and mkdir\n         return createRet == 0 ? 1 : 0;\n     }\n \n-    /**************************************\n-     * Converts a path to one suitable to be passed to Win32 API\n-     * functions that can deal with paths longer than 248\n-     * characters then calls the supplied function on it.\n-     *\n-     * Params:\n-     *  path = The Path to call F on.\n-     *\n-     * Returns:\n-     *  The result of calling F on path.\n-     *\n-     * References:\n-     *  https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx\n-     */\n-    package auto extendedPathThen(alias F)(const(char)[] path)\n-    {\n-        if (!path.length)\n-            return F((wchar[]).init);\n-        return path.toWStringzThen!((wpath)\n-        {\n-            // GetFullPathNameW expects a sized buffer to store the result in. Since we don't\n-            // know how large it has to be, we pass in null and get the needed buffer length\n-            // as the return code.\n-            const pathLength = GetFullPathNameW(&wpath[0],\n-                                                0 /*length8*/,\n-                                                null /*output buffer*/,\n-                                                null /*filePartBuffer*/);\n-            if (pathLength == 0)\n-            {\n-                return F((wchar[]).init);\n-            }\n-\n-            // wpath is the UTF16 version of path, but to be able to use\n-            // extended paths, we need to prefix with `\\\\?\\` and the absolute\n-            // path.\n-            static immutable prefix = `\\\\?\\`w;\n-\n-            // prefix only needed for long names and non-UNC names\n-            const needsPrefix = pathLength >= MAX_PATH && (wpath[0] != '\\\\' || wpath[1] != '\\\\');\n-            const prefixLength = needsPrefix ? prefix.length : 0;\n-\n-            // +1 for the null terminator\n-            const bufferLength = pathLength + prefixLength + 1;\n-\n-            wchar[1024] absBuf = void;\n-            wchar[] absPath = bufferLength > absBuf.length\n-                ? new wchar[bufferLength] : absBuf[0 .. bufferLength];\n-\n-            absPath[0 .. prefixLength] = prefix[0 .. prefixLength];\n-\n-            const absPathRet = GetFullPathNameW(&wpath[0],\n-                cast(uint)(absPath.length - prefixLength - 1),\n-                &absPath[prefixLength],\n-                null /*filePartBuffer*/);\n-\n-            if (absPathRet == 0 || absPathRet > absPath.length - prefixLength)\n-            {\n-                return F((wchar[]).init);\n-            }\n-\n-            absPath[$ - 1] = '\\0';\n-            // Strip null terminator from the slice\n-            return F(absPath[0 .. $ - 1]);\n-        });\n-    }\n-\n     /**********************************\n      * Converts a UTF-16 string to a (null-terminated) narrow string.\n      * Returns:\n@@ -1222,33 +1158,6 @@ version(Windows)\n         return newBuffer[0 .. length];\n     }\n \n-    /**********************************\n-     * Converts a narrow string to a (null-terminated) UTF-16 string.\n-     * Returns:\n-     *  If `buffer` is specified and the result fits, a slice of that buffer,\n-     *  otherwise a new buffer which can be released via `mem.xfree()`.\n-     *  Nulls are propagated, i.e., if `narrow` is null, the returned slice is\n-     *  null too.\n-     */\n-    wchar[] toWStringz(const(char)[] narrow, wchar[] buffer = null) nothrow\n-    {\n-        if (narrow is null)\n-            return null;\n-\n-        const requiredLength = MultiByteToWideChar(CodePage, 0, narrow.ptr, cast(int) narrow.length, buffer.ptr, cast(int) buffer.length);\n-        if (requiredLength < buffer.length)\n-        {\n-            buffer[requiredLength] = 0;\n-            return buffer[0 .. requiredLength];\n-        }\n-\n-        wchar* newBuffer = cast(wchar*) mem.xmalloc_noscan((requiredLength + 1) * wchar.sizeof);\n-        const length = MultiByteToWideChar(CodePage, 0, narrow.ptr, cast(int) narrow.length, newBuffer, requiredLength);\n-        assert(length == requiredLength);\n-        newBuffer[length] = 0;\n-        return newBuffer[0 .. length];\n-    }\n-\n     /**********************************\n      * Converts a slice of UTF-8 characters to an array of wchar that's null\n      * terminated so it can be passed to Win32 APIs then calls the supplied\n@@ -1262,9 +1171,12 @@ version(Windows)\n      */\n     private auto toWStringzThen(alias F)(const(char)[] str) nothrow\n     {\n+        import dmd.common.string : SmallBuffer, toWStringz;\n+\n         if (!str.length) return F(\"\"w.ptr);\n \n-        wchar[1024] buf = void;\n+        wchar[1024] support = void;\n+        auto buf = SmallBuffer!wchar(support.length, support);\n         wchar[] wide = toWStringz(str, buf);\n         scope(exit) wide.ptr != buf.ptr && mem.xfree(wide.ptr);\n "}, {"sha": "6a3220062132cdf7154bb8e354e4f453936d4de2", "filename": "gcc/d/dmd/root/hash.h", "status": "removed", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Fd%2Fdmd%2Froot%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Fd%2Fdmd%2Froot%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fhash.h?ref=c15aa46cca0649b68613d3292cf71c7cc57ef78f", "patch": "@@ -1,76 +0,0 @@\n-/**\n- * Compiler implementation of the D programming language\n- * http://dlang.org\n- *\n- * Copyright: Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n- * Authors:   Martin Nowak, Walter Bright, http://www.digitalmars.com\n- * License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source:    $(DMDSRC root/_hash.h)\n- */\n-\n-#pragma once\n-\n-#include \"dsystem.h\"                    // uint{8|16|32}_t\n-\n-// MurmurHash2 was written by Austin Appleby, and is placed in the public\n-// domain. The author hereby disclaims copyright to this source code.\n-// https://sites.google.com/site/murmurhash/\n-static inline uint32_t calcHash(const uint8_t *data, size_t len)\n-{\n-    // 'm' and 'r' are mixing constants generated offline.\n-    // They're not really 'magic', they just happen to work well.\n-\n-    const uint32_t m = 0x5bd1e995;\n-    const int r = 24;\n-\n-    // Initialize the hash to a 'random' value\n-\n-    uint32_t h = (uint32_t)len;\n-\n-    // Mix 4 bytes at a time into the hash\n-\n-    while(len >= 4)\n-    {\n-        uint32_t k = data[3] << 24 | data[2] << 16 | data[1] << 8 | data[0];\n-\n-        k *= m;\n-        k ^= k >> r;\n-        k *= m;\n-\n-        h *= m;\n-        h ^= k;\n-\n-        data += 4;\n-        len -= 4;\n-    }\n-\n-    // Handle the last few bytes of the input array\n-\n-    switch(len & 3)\n-    {\n-    case 3: h ^= data[2] << 16; /* fall through */\n-    case 2: h ^= data[1] << 8;  /* fall through */\n-    case 1: h ^= data[0];\n-        h *= m;\n-    }\n-\n-    // Do a few final mixes of the hash to ensure the last few\n-    // bytes are well-incorporated.\n-\n-    h ^= h >> 13;\n-    h *= m;\n-    h ^= h >> 15;\n-\n-    return h;\n-}\n-\n-static inline uint32_t calcHash(const char *data, size_t len)\n-{\n-    return calcHash((const uint8_t *)data, len);\n-}\n-\n-// combine and mix two words (boost::hash_combine)\n-static inline size_t mixHash(size_t h, size_t k)\n-{\n-    return h ^ (k + 0x9e3779b9 + (h << 6) + (h >> 2));\n-}"}, {"sha": "64104b823d1f0c36a3449c7837304e3f0583c8ec", "filename": "gcc/d/dmd/root/rootobject.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Froot%2Frootobject.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Froot%2Frootobject.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Frootobject.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -13,7 +13,7 @@ module dmd.root.rootobject;\n \n import core.stdc.stdio;\n \n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n \n /***********************************************************\n  */"}, {"sha": "bd53fc452c9e7d2825c2335cbb066c9edecabbd6", "filename": "gcc/d/dmd/root/speller.h", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Fd%2Fdmd%2Froot%2Fspeller.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Fd%2Fdmd%2Froot%2Fspeller.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fspeller.h?ref=c15aa46cca0649b68613d3292cf71c7cc57ef78f", "patch": "@@ -1,16 +0,0 @@\n-\n-/* Copyright (C) 2010-2021 by The D Language Foundation, All Rights Reserved\n- * http://www.digitalmars.com\n- * Distributed under the Boost Software License, Version 1.0.\n- * (See accompanying file LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)\n- * https://github.com/D-Programming-Language/dmd/blob/master/src/root/speller.h\n- */\n-\n-#pragma once\n-\n-typedef void *(fp_speller_t)(void *, const char *, int*);\n-\n-extern const char idchars[];\n-\n-void *speller(const char *seed, fp_speller_t fp, void *fparg, const char *charset);\n-"}, {"sha": "51304d32c3f041fe6aa13a5783082f67c52d6b61", "filename": "gcc/d/dmd/root/stringtable.h", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Fd%2Fdmd%2Froot%2Fstringtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Fd%2Fdmd%2Froot%2Fstringtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fstringtable.h?ref=c15aa46cca0649b68613d3292cf71c7cc57ef78f", "patch": "@@ -1,56 +0,0 @@\n-\n-/* Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n- * http://www.digitalmars.com\n- * Distributed under the Boost Software License, Version 1.0.\n- * http://www.boost.org/LICENSE_1_0.txt\n- * https://github.com/dlang/dmd/blob/master/src/dmd/root/stringtable.h\n- */\n-\n-#pragma once\n-\n-#include \"root.h\"\n-\n-struct StringEntry;\n-\n-// StringValue is a variable-length structure. It has neither proper c'tors nor a\n-// factory method because the only thing which should be creating these is StringTable.\n-struct StringValue\n-{\n-    void *ptrvalue;\n-    size_t length;\n-    char *lstring() { return (char *)(this + 1); }\n-\n-    size_t len() const { return length; }\n-    const char *toDchars() const { return (const char *)(this + 1); }\n-\n-    StringValue();  // not constructible\n-};\n-\n-struct StringTable\n-{\n-private:\n-    StringEntry *table;\n-    size_t tabledim;\n-\n-    uint8_t **pools;\n-    size_t npools;\n-    size_t nfill;\n-\n-    size_t count;\n-\n-public:\n-    void _init(size_t size = 0);\n-    void reset(size_t size = 0);\n-    ~StringTable();\n-\n-    StringValue *lookup(const char *s, size_t len);\n-    StringValue *insert(const char *s, size_t len, void *ptrvalue);\n-    StringValue *update(const char *s, size_t len);\n-    int apply(int (*fp)(StringValue *));\n-\n-private:\n-    uint32_t allocValue(const char *p, size_t length, void *ptrvalue);\n-    StringValue *getValue(uint32_t validx);\n-    size_t findSlot(hash_t hash, const char *s, size_t len);\n-    void grow();\n-};"}, {"sha": "89049599dacdfd1988372c202af2016948c2f639", "filename": "gcc/d/dmd/safe.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fsafe.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fsafe.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsafe.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -89,7 +89,7 @@ bool checkUnsafeAccess(Scope* sc, Expression e, bool readonly, bool printmsg)\n \n         if (hasPointers && v.type.toBasetype().ty != Tstruct)\n         {\n-            if ((ad.type.alignment() < target.ptrsize ||\n+            if ((!ad.type.alignment.isDefault() && ad.type.alignment.get() < target.ptrsize ||\n                  (v.offset & (target.ptrsize - 1))) &&\n                 sc.func.setUnsafe())\n             {"}, {"sha": "993db90552343247efb504908ae2e3cbe06fb629", "filename": "gcc/d/dmd/semantic2.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fsemantic2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fsemantic2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsemantic2.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -53,7 +53,7 @@ import dmd.objc;\n import dmd.opover;\n import dmd.parse;\n import dmd.root.filename;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.root.rmem;\n import dmd.root.rootobject;\n import dmd.sideeffect;\n@@ -363,7 +363,7 @@ private extern(C++) final class Semantic2Visitor : Visitor\n         assert(fd.semanticRun <= PASS.semantic2);\n         fd.semanticRun = PASS.semantic2;\n \n-        //printf(\"FuncDeclaration::semantic2 [%s] fd0 = %s %s\\n\", loc.toChars(), toChars(), type.toChars());\n+        //printf(\"FuncDeclaration::semantic2 [%s] fd: %s type: %s\\n\", fd.loc.toChars(), fd.toChars(), fd.type ? fd.type.toChars() : \"\".ptr);\n \n         // Only check valid functions which have a body to avoid errors\n         // for multiple declarations, e.g."}, {"sha": "3852d0b26934e90584475ef6b1b35e011bc9df52", "filename": "gcc/d/dmd/semantic3.d", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fsemantic3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fsemantic3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsemantic3.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -55,7 +55,7 @@ import dmd.objc;\n import dmd.opover;\n import dmd.parse;\n import dmd.root.filename;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.root.rmem;\n import dmd.root.rootobject;\n import dmd.sideeffect;\n@@ -407,7 +407,8 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                     sc2.insert(_arguments);\n                     _arguments.parent = funcdecl;\n                 }\n-                if (f.linkage == LINK.d || f.parameterList.length)\n+                if ((f.linkage == LINK.d || f.parameterList.length) &&\n+                    !(sc.flags & SCOPE.Cfile))  // don't want to require importing stdarg for C files\n                 {\n                     // Declare _argptr\n                     Type t = target.va_listType(funcdecl.loc, sc);\n@@ -598,7 +599,10 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                         f.next = Type.tvoid;\n                     if (f.checkRetType(funcdecl.loc))\n                         funcdecl.fbody = new ErrorStatement();\n+                    else if (funcdecl.isMain())\n+                        funcdecl.checkDmain();       // Check main() parameters and return type\n                 }\n+\n                 if (global.params.vcomplex && f.next !is null)\n                     f.next.checkComplexTransition(funcdecl.loc, sc);\n \n@@ -777,8 +781,14 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                     }\n                     assert(!funcdecl.returnLabel);\n                 }\n-                else if (f.next.ty == Tnoreturn)\n+                else if (f.next.toBasetype().ty == Tnoreturn)\n                 {\n+                    // Fallthrough despite being declared as noreturn? return is already rejected when evaluating the ReturnStatement\n+                    if (blockexit & BE.fallthru)\n+                    {\n+                        funcdecl.error(\"is typed as `%s` but does return\", f.next.toChars());\n+                        funcdecl.loc.errorSupplemental(\"`noreturn` functions must either throw, abort or loop indefinitely\");\n+                    }\n                 }\n                 else\n                 {\n@@ -1571,7 +1581,7 @@ private struct FuncDeclSem3\n     }\n }\n \n-private void semanticTypeInfoMembers(StructDeclaration sd)\n+extern (C++) void semanticTypeInfoMembers(StructDeclaration sd)\n {\n     if (sd.xeq &&\n         sd.xeq._scope &&"}, {"sha": "91e3fe7bfebc8c4b780a0981fb12bf01668aa842", "filename": "gcc/d/dmd/statement.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fstatement.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fstatement.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatement.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -39,7 +39,7 @@ import dmd.id;\n import dmd.identifier;\n import dmd.dinterpret;\n import dmd.mtype;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.root.rootobject;\n import dmd.sapply;\n import dmd.sideeffect;\n@@ -463,7 +463,7 @@ extern (C++) class ExpStatement : Statement\n         this.exp = new DeclarationExp(loc, declaration);\n     }\n \n-    static ExpStatement create(Loc loc, Expression exp)\n+    static ExpStatement create(const ref Loc loc, Expression exp)\n     {\n         return new ExpStatement(loc, exp);\n     }\n@@ -577,7 +577,7 @@ extern (C++) class CompoundStatement : Statement\n             statements.push(s);\n     }\n \n-    static CompoundStatement create(Loc loc, Statement s1, Statement s2)\n+    static CompoundStatement create(const ref Loc loc, Statement s1, Statement s2)\n     {\n         return new CompoundStatement(loc, s1, s2);\n     }\n@@ -1635,7 +1635,7 @@ extern (C++) final class TryFinallyStatement : Statement\n         this.bodyFallsThru = true;      // assume true until statementSemantic()\n     }\n \n-    static TryFinallyStatement create(Loc loc, Statement _body, Statement finalbody)\n+    static TryFinallyStatement create(const ref Loc loc, Statement _body, Statement finalbody)\n     {\n         return new TryFinallyStatement(loc, _body, finalbody);\n     }"}, {"sha": "98b7bd318eb478e4cc19f87da2ffc046b2dab900", "filename": "gcc/d/dmd/statement.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fstatement.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fstatement.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatement.h?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -186,7 +186,7 @@ class ExpStatement : public Statement\n public:\n     Expression *exp;\n \n-    static ExpStatement *create(Loc loc, Expression *exp);\n+    static ExpStatement *create(const Loc &loc, Expression *exp);\n     ExpStatement *syntaxCopy();\n \n     void accept(Visitor *v) { v->visit(this); }\n@@ -218,7 +218,7 @@ class CompoundStatement : public Statement\n public:\n     Statements *statements;\n \n-    static CompoundStatement *create(Loc loc, Statement *s1, Statement *s2);\n+    static CompoundStatement *create(const Loc &loc, Statement *s1, Statement *s2);\n     CompoundStatement *syntaxCopy();\n     ReturnStatement *endsWithReturnStatement();\n     Statement *last();\n@@ -615,7 +615,7 @@ class TryFinallyStatement : public Statement\n     Statement *tryBody;   // set to enclosing TryCatchStatement or TryFinallyStatement if in _body portion\n     bool bodyFallsThru;   // true if _body falls through to finally\n \n-    static TryFinallyStatement *create(Loc loc, Statement *body, Statement *finalbody);\n+    static TryFinallyStatement *create(const Loc &loc, Statement *body, Statement *finalbody);\n     TryFinallyStatement *syntaxCopy();\n     bool hasBreak() const;\n     bool hasContinue() const;"}, {"sha": "28a930a28bc63e68407a78dce3950d9fe5e9396d", "filename": "gcc/d/dmd/statement_rewrite_walker.h", "status": "removed", "additions": 0, "deletions": 172, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Fd%2Fdmd%2Fstatement_rewrite_walker.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Fd%2Fdmd%2Fstatement_rewrite_walker.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatement_rewrite_walker.h?ref=c15aa46cca0649b68613d3292cf71c7cc57ef78f", "patch": "@@ -1,172 +0,0 @@\n-\n-/* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n- * written by Walter Bright\n- * http://www.digitalmars.com\n- * Distributed under the Boost Software License, Version 1.0.\n- * http://www.boost.org/LICENSE_1_0.txt\n- */\n-\n-#include \"statement.h\"\n-#include \"visitor.h\"\n-\n-/* A visitor to walk entire statements and provides ability to replace any sub-statements.\n- */\n-class StatementRewriteWalker : public Visitor\n-{\n-    /* Point the currently visited statement.\n-     * By using replaceCurrent() method, you can replace AST during walking.\n-     */\n-    Statement **ps;\n-public:\n-    void visitStmt(Statement *&s) { ps = &s; s->accept(this); }\n-    void replaceCurrent(Statement *s) { *ps = s; }\n-\n-    void visit(ErrorStatement *) {  }\n-    void visit(PeelStatement *s)\n-    {\n-        if (s->s)\n-            visitStmt(s->s);\n-    }\n-    void visit(ExpStatement *) {  }\n-    void visit(DtorExpStatement *) {  }\n-    void visit(CompileStatement *) {  }\n-    void visit(CompoundStatement *s)\n-    {\n-        if (s->statements && s->statements->length)\n-        {\n-            for (size_t i = 0; i < s->statements->length; i++)\n-            {\n-                if ((*s->statements)[i])\n-                    visitStmt((*s->statements)[i]);\n-            }\n-        }\n-    }\n-    void visit(CompoundDeclarationStatement *s) { visit((CompoundStatement *)s); }\n-    void visit(UnrolledLoopStatement *s)\n-    {\n-        if (s->statements && s->statements->length)\n-        {\n-            for (size_t i = 0; i < s->statements->length; i++)\n-            {\n-                if ((*s->statements)[i])\n-                    visitStmt((*s->statements)[i]);\n-            }\n-        }\n-    }\n-    void visit(ScopeStatement *s)\n-    {\n-        if (s->statement)\n-            visitStmt(s->statement);\n-    }\n-    void visit(WhileStatement *s)\n-    {\n-        if (s->_body)\n-            visitStmt(s->_body);\n-    }\n-    void visit(DoStatement *s)\n-    {\n-        if (s->_body)\n-            visitStmt(s->_body);\n-    }\n-    void visit(ForStatement *s)\n-    {\n-        if (s->_init)\n-            visitStmt(s->_init);\n-        if (s->_body)\n-            visitStmt(s->_body);\n-    }\n-    void visit(ForeachStatement *s)\n-    {\n-        if (s->_body)\n-            visitStmt(s->_body);\n-    }\n-    void visit(ForeachRangeStatement *s)\n-    {\n-        if (s->_body)\n-            visitStmt(s->_body);\n-    }\n-    void visit(IfStatement *s)\n-    {\n-        if (s->ifbody)\n-            visitStmt(s->ifbody);\n-        if (s->elsebody)\n-            visitStmt(s->elsebody);\n-    }\n-    void visit(ConditionalStatement *) {  }\n-    void visit(PragmaStatement *) {  }\n-    void visit(StaticAssertStatement *) {  }\n-    void visit(SwitchStatement *s)\n-    {\n-        if (s->_body)\n-            visitStmt(s->_body);\n-    }\n-    void visit(CaseStatement *s)\n-    {\n-        if (s->statement)\n-            visitStmt(s->statement);\n-    }\n-    void visit(CaseRangeStatement *s)\n-    {\n-        if (s->statement)\n-            visitStmt(s->statement);\n-    }\n-    void visit(DefaultStatement *s)\n-    {\n-        if (s->statement)\n-            visitStmt(s->statement);\n-    }\n-    void visit(GotoDefaultStatement *) {  }\n-    void visit(GotoCaseStatement *) {  }\n-    void visit(SwitchErrorStatement *) {  }\n-    void visit(ReturnStatement *) {  }\n-    void visit(BreakStatement *) {  }\n-    void visit(ContinueStatement *) {  }\n-    void visit(SynchronizedStatement *s)\n-    {\n-        if (s->_body)\n-            visitStmt(s->_body);\n-    }\n-    void visit(WithStatement *s)\n-    {\n-        if (s->_body)\n-            visitStmt(s->_body);\n-    }\n-    void visit(TryCatchStatement *s)\n-    {\n-        if (s->_body)\n-            visitStmt(s->_body);\n-        if (s->catches && s->catches->length)\n-        {\n-            for (size_t i = 0; i < s->catches->length; i++)\n-            {\n-                Catch *c = (*s->catches)[i];\n-                if (c && c->handler)\n-                    visitStmt(c->handler);\n-            }\n-        }\n-    }\n-    void visit(TryFinallyStatement *s)\n-    {\n-        if (s->_body)\n-            visitStmt(s->_body);\n-        if (s->finalbody)\n-            visitStmt(s->finalbody);\n-    }\n-    void visit(ScopeGuardStatement *) {  }\n-    void visit(ThrowStatement *) {  }\n-    void visit(DebugStatement *s)\n-    {\n-        if (s->statement)\n-            visitStmt(s->statement);\n-    }\n-    void visit(GotoStatement *) {  }\n-    void visit(LabelStatement *s)\n-    {\n-        if (s->statement)\n-            visitStmt(s->statement);\n-    }\n-    void visit(AsmStatement *) {  }\n-    void visit(ImportStatement *) {  }\n-};\n-"}, {"sha": "9eba2ffaed206a32151e90a122440af9303d8f20", "filename": "gcc/d/dmd/statementsem.d", "status": "modified", "additions": 63, "deletions": 97, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fstatementsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fstatementsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatementsem.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -54,7 +54,7 @@ import dmd.nogc;\n import dmd.opover;\n import dmd.parse;\n import dmd.printast;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.root.string;\n import dmd.semantic2;\n import dmd.sideeffect;\n@@ -659,20 +659,6 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n         result = fs;\n     }\n \n-    /*******************\n-     * Determines the return type of makeTupleForeach.\n-     */\n-    private static template MakeTupleForeachRet(bool isDecl)\n-    {\n-        static if(isDecl)\n-        {\n-            alias MakeTupleForeachRet = Dsymbols*;\n-        }\n-        else\n-        {\n-            alias MakeTupleForeachRet = void;\n-        }\n-    }\n \n     /*******************\n      * Type check and unroll `foreach` over an expression tuple as well\n@@ -696,29 +682,24 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n      * expands the tuples into multiple `STC.local` `static foreach`\n      * variables.\n      */\n-    MakeTupleForeachRet!isDecl makeTupleForeach(bool isStatic, bool isDecl)(ForeachStatement fs, TupleForeachArgs!(isStatic, isDecl) args)\n+    auto makeTupleForeach(bool isStatic, bool isDecl)(ForeachStatement fs, Dsymbols* dbody, bool needExpansion)\n     {\n-        auto returnEarly()\n-        {\n-            static if (isDecl)\n-            {\n-                return null;\n-            }\n-            else\n-            {\n-                result = new ErrorStatement();\n-                return;\n-            }\n-        }\n-        static if(isDecl)\n+        // Voldemort return type\n+        union U\n         {\n-            static assert(isStatic);\n-            auto dbody = args[0];\n+            Statement statement;\n+            Dsymbols* decl;\n         }\n-        static if(isStatic)\n+\n+        U result;\n+\n+        auto returnEarly()\n         {\n-            auto needExpansion = args[$-1];\n-            assert(sc);\n+            if (isDecl)\n+                result.decl = null;\n+            else\n+                result.statement = new ErrorStatement();\n+            return result;\n         }\n \n         auto loc = fs.loc;\n@@ -827,7 +808,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n                 }\n                 Initializer ie = new ExpInitializer(Loc.initial, new IntegerExp(k));\n                 auto var = new VarDeclaration(loc, p.type, p.ident, ie);\n-                var.storage_class |= STC.manifest;\n+                var.storage_class |= STC.foreach_ | STC.manifest;\n                 static if(isStatic) var.storage_class |= STC.local;\n                 static if(!isDecl)\n                 {\n@@ -919,8 +900,9 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n                         e = resolveProperties(sc, e);\n                         Initializer ie = new ExpInitializer(Loc.initial, e);\n                         auto v = new VarDeclaration(loc, type, ident, ie, storageClass);\n+                        v.storage_class |= STC.foreach_;\n                         if (storageClass & STC.ref_)\n-                            v.storage_class |= STC.ref_ | STC.foreach_;\n+                            v.storage_class |= STC.ref_;\n                         if (isStatic || storageClass&STC.manifest || e.isConst() ||\n                             e.op == TOK.string_ ||\n                             e.op == TOK.structLiteral ||\n@@ -1057,23 +1039,17 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n                 ls.gotoTarget = res;\n             if (te && te.e0)\n                 res = new CompoundStatement(loc, new ExpStatement(te.e0.loc, te.e0), res);\n+            result.statement = res;\n         }\n         else static if (!isDecl)\n         {\n-            Statement res = new CompoundStatement(loc, statements);\n-        }\n-        else\n-        {\n-            auto res = declarations;\n-        }\n-        static if (!isDecl)\n-        {\n-            result = res;\n+            result.statement = new CompoundStatement(loc, statements);\n         }\n         else\n         {\n-            return res;\n+            result.decl = declarations;\n         }\n+        return result;\n     }\n \n     override void visit(ForeachStatement fs)\n@@ -1202,10 +1178,10 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n \n         if (tab.ty == Ttuple) // don't generate new scope for tuple loops\n         {\n-            makeTupleForeach!(false,false)(fs);\n+            Statement s = makeTupleForeach!(false,false)(fs, null, false).statement;\n             if (vinit)\n-                result = new CompoundStatement(loc, new ExpStatement(loc, vinit), result);\n-            result = result.statementSemantic(sc);\n+                s = new CompoundStatement(loc, new ExpStatement(loc, vinit), s);\n+            result = s.statementSemantic(sc);\n             return;\n         }\n \n@@ -2727,7 +2703,8 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n                 needswitcherror = true;\n         }\n \n-        if (!sc.sw.sdefault && (!ss.isFinal || needswitcherror || global.params.useAssert == CHECKENABLE.on))\n+        if (!sc.sw.sdefault && !(sc.flags & SCOPE.Cfile) &&\n+            (!ss.isFinal || needswitcherror || global.params.useAssert == CHECKENABLE.on))\n         {\n             ss.hasNoDefault = 1;\n \n@@ -3061,7 +3038,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n \n         if (lval - fval > 256)\n         {\n-            crs.error(\"had %llu cases which is more than 256 cases in case range\", lval - fval);\n+            crs.error(\"had %llu cases which is more than 257 cases in case range\", 1 + lval - fval);\n             errors = true;\n             lval = fval + 256;\n         }\n@@ -3295,12 +3272,14 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n             if (e0)\n                 e0 = e0.optimize(WANTvalue);\n \n-            /* Void-return function can have void typed expression\n+            /* Void-return function can have void / noreturn typed expression\n              * on return statement.\n              */\n-            if (tbret && tbret.ty == Tvoid || rs.exp.type.ty == Tvoid)\n+            const convToVoid = rs.exp.type.ty == Tvoid || rs.exp.type.ty == Tnoreturn;\n+\n+            if (tbret && tbret.ty == Tvoid || convToVoid)\n             {\n-                if (rs.exp.type.ty != Tvoid)\n+                if (!convToVoid)\n                 {\n                     rs.error(\"cannot return non-void from `void` function\");\n                     errors = true;\n@@ -3345,7 +3324,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n                     }\n                     else if (rs.exp.op != TOK.error)\n                     {\n-                        rs.error(\"Expected return type of `%s`, not `%s`:\",\n+                        rs.error(\"expected return type of `%s`, not `%s`:\",\n                                  tret.toChars(),\n                                  rs.exp.type.toChars());\n                         errorSupplemental((fd.returns) ? (*fd.returns)[0].loc : fd.loc,\n@@ -3409,10 +3388,20 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n         }\n         else\n         {\n+            // Type of the returned expression (if any), might've been moved to e0\n+            auto resType = e0 ? e0.type : Type.tvoid;\n+\n             // infer return type\n             if (fd.inferRetType)\n             {\n-                if (tf.next && tf.next.ty != Tvoid)\n+                // 1. First `return <noreturn exp>?`\n+                // 2. Potentially found a returning branch, update accordingly\n+                if (!tf.next || tf.next.toBasetype().isTypeNoreturn())\n+                {\n+                    tf.next = resType; // infer void or noreturn\n+                }\n+                // Found an actual return value before\n+                else if (tf.next.ty != Tvoid && !resType.toBasetype().isTypeNoreturn())\n                 {\n                     if (tf.next.ty != Terror)\n                     {\n@@ -3421,20 +3410,23 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n                     errors = true;\n                     tf.next = Type.terror;\n                 }\n-                else\n-                    tf.next = Type.tvoid;\n \n-                    tret = tf.next;\n+                tret = tf.next;\n                 tbret = tret.toBasetype();\n             }\n \n             if (inferRef) // deduce 'auto ref'\n                 tf.isref = false;\n \n-            if (tbret.ty != Tvoid) // if non-void return\n+            if (tbret.ty != Tvoid && !resType.isTypeNoreturn()) // if non-void return\n             {\n                 if (tbret.ty != Terror)\n-                    rs.error(\"`return` expression expected\");\n+                {\n+                    if (e0)\n+                        rs.error(\"expected return type of `%s`, not `%s`\", tret.toChars(), resType.toChars());\n+                    else\n+                        rs.error(\"`return` expression expected\");\n+                }\n                 errors = true;\n             }\n             else if (fd.isMain())\n@@ -3522,7 +3514,12 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n             }\n             else\n             {\n-                result = new CompoundStatement(rs.loc, new ExpStatement(rs.loc, e0), rs);\n+                auto es = new ExpStatement(rs.loc, e0);\n+                if (e0.type.isTypeNoreturn())\n+                    result = es; // Omit unreachable return;\n+                else\n+                    result = new CompoundStatement(rs.loc, es, rs);\n+\n                 return;\n             }\n         }\n@@ -4014,7 +4011,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n                 /* If catch exception type is derived from Exception\n                  */\n                 if (c.type.toBasetype().implicitConvTo(ClassDeclaration.exception.type) &&\n-                    (!c.handler || !c.handler.comeFrom()))\n+                    (!c.handler || !c.handler.comeFrom()) && !(sc.flags & SCOPE.debug_))\n                 {\n                     // Remove c from the array of catches\n                     tcs.catches.remove(i);\n@@ -4569,45 +4566,14 @@ Statement scopeCode(Statement statement, Scope* sc, out Statement sentry, out St\n }\n \n \n-/*******************\n- * Determines additional argument types for makeTupleForeach.\n- */\n-static template TupleForeachArgs(bool isStatic, bool isDecl)\n-{\n-    alias Seq(T...)=T;\n-    static if(isStatic) alias T = Seq!(bool);\n-    else alias T = Seq!();\n-    static if(!isDecl) alias TupleForeachArgs = T;\n-    else alias TupleForeachArgs = Seq!(Dsymbols*,T);\n-}\n-\n-/*******************\n- * Determines the return type of makeTupleForeach.\n- */\n-static template TupleForeachRet(bool isStatic, bool isDecl)\n-{\n-    alias Seq(T...)=T;\n-    static if(!isDecl) alias TupleForeachRet = Statement;\n-    else alias TupleForeachRet = Dsymbols*;\n-}\n-\n-\n /*******************\n  * See StatementSemanticVisitor.makeTupleForeach.  This is a simple\n  * wrapper that returns the generated statements/declarations.\n  */\n-TupleForeachRet!(isStatic, isDecl) makeTupleForeach(bool isStatic, bool isDecl)(Scope* sc, ForeachStatement fs, TupleForeachArgs!(isStatic, isDecl) args)\n+auto makeTupleForeach(bool isStatic, bool isDecl)(Scope* sc, ForeachStatement fs, Dsymbols* dbody, bool needExpansion)\n {\n     scope v = new StatementSemanticVisitor(sc);\n-    static if(!isDecl)\n-    {\n-        v.makeTupleForeach!(isStatic, isDecl)(fs, args);\n-        return v.result;\n-    }\n-    else\n-    {\n-        return v.makeTupleForeach!(isStatic, isDecl)(fs, args);\n-    }\n+    return v.makeTupleForeach!(isStatic, isDecl)(fs, dbody, needExpansion);\n }\n \n /*********************************\n@@ -4731,7 +4697,7 @@ private Statements* flatten(Statement statement, Scope* sc)\n             sfs.sfe.prepare(sc);\n             if (sfs.sfe.ready())\n             {\n-                auto s = makeTupleForeach!(true, false)(sc, sfs.sfe.aggrfe, sfs.sfe.needExpansion);\n+                Statement s = makeTupleForeach!(true, false)(sc, sfs.sfe.aggrfe, null, sfs.sfe.needExpansion).statement;\n                 auto result = s.flatten(sc);\n                 if (result)\n                 {"}, {"sha": "d1578ec3a121d67452441d30e313dc57b016e53f", "filename": "gcc/d/dmd/staticcond.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fstaticcond.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Fstaticcond.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstaticcond.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -22,7 +22,7 @@ import dmd.globals;\n import dmd.identifier;\n import dmd.mtype;\n import dmd.root.array;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.tokens;\n \n "}, {"sha": "16739addf57355b2a5b70f52f2638bd4040bae27", "filename": "gcc/d/dmd/target.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Ftarget.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Ftarget.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftarget.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -316,7 +316,8 @@ struct TargetC\n     enum BitFieldStyle : ubyte\n     {\n         Unspecified,\n-        Dm_Ms,                /// Digital Mars and Microsoft C compilers\n+        DM,                   /// Digital Mars 32 bit C compiler\n+        MS,                   /// Microsoft 32 and 64 bit C compilers\n                               /// https://docs.microsoft.com/en-us/cpp/c-language/c-bit-fields?view=msvc-160\n                               /// https://docs.microsoft.com/en-us/cpp/cpp/cpp-bit-fields?view=msvc-160\n         Gcc_Clang,            /// gcc and clang"}, {"sha": "6a75ccc5ebd8d60d98c4f4476954f8f8c16d4978", "filename": "gcc/d/dmd/target.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftarget.h?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -63,7 +63,8 @@ struct TargetC\n     enum class BitFieldStyle : unsigned char\n     {\n         Unspecified,\n-        Dm_Ms,                // Digital Mars and Microsoft C compilers\n+        DM,                   // Digital Mars 32 bit C compiler\n+        MS,                   // Microsoft 32 and 64 bit C compilers\n                               // https://docs.microsoft.com/en-us/cpp/c-language/c-bit-fields?view=msvc-160\n                               // https://docs.microsoft.com/en-us/cpp/cpp/cpp-bit-fields?view=msvc-160\n         Gcc_Clang,            // gcc and clang"}, {"sha": "69cc84f6573cf8d7de9118bf2eeb280dacddedd2", "filename": "gcc/d/dmd/template.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Ftemplate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Ftemplate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftemplate.h?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -131,7 +131,7 @@ class TemplateParameter : public ASTNode\n     virtual bool declareParameter(Scope *sc) = 0;\n     virtual void print(RootObject *oarg, RootObject *oded) = 0;\n     virtual RootObject *specialization() = 0;\n-    virtual RootObject *defaultArg(Loc instLoc, Scope *sc) = 0;\n+    virtual RootObject *defaultArg(const Loc &instLoc, Scope *sc) = 0;\n     virtual bool hasDefaultArg() = 0;\n \n     /* Create dummy argument based on parameter.\n@@ -154,7 +154,7 @@ class TemplateTypeParameter : public TemplateParameter\n     bool declareParameter(Scope *sc);\n     void print(RootObject *oarg, RootObject *oded);\n     RootObject *specialization();\n-    RootObject *defaultArg(Loc instLoc, Scope *sc);\n+    RootObject *defaultArg(const Loc &instLoc, Scope *sc);\n     bool hasDefaultArg();\n     RootObject *dummyArg();\n     void accept(Visitor *v) { v->visit(this); }\n@@ -186,7 +186,7 @@ class TemplateValueParameter : public TemplateParameter\n     bool declareParameter(Scope *sc);\n     void print(RootObject *oarg, RootObject *oded);\n     RootObject *specialization();\n-    RootObject *defaultArg(Loc instLoc, Scope *sc);\n+    RootObject *defaultArg(const Loc &instLoc, Scope *sc);\n     bool hasDefaultArg();\n     RootObject *dummyArg();\n     void accept(Visitor *v) { v->visit(this); }\n@@ -207,7 +207,7 @@ class TemplateAliasParameter : public TemplateParameter\n     bool declareParameter(Scope *sc);\n     void print(RootObject *oarg, RootObject *oded);\n     RootObject *specialization();\n-    RootObject *defaultArg(Loc instLoc, Scope *sc);\n+    RootObject *defaultArg(const Loc &instLoc, Scope *sc);\n     bool hasDefaultArg();\n     RootObject *dummyArg();\n     void accept(Visitor *v) { v->visit(this); }\n@@ -224,7 +224,7 @@ class TemplateTupleParameter : public TemplateParameter\n     bool declareParameter(Scope *sc);\n     void print(RootObject *oarg, RootObject *oded);\n     RootObject *specialization();\n-    RootObject *defaultArg(Loc instLoc, Scope *sc);\n+    RootObject *defaultArg(const Loc &instLoc, Scope *sc);\n     bool hasDefaultArg();\n     RootObject *dummyArg();\n     void accept(Visitor *v) { v->visit(this); }"}, {"sha": "1ea51a89bff7a9634bc49d14390f20a000ffc8fa", "filename": "gcc/d/dmd/tokens.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Ftokens.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Ftokens.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftokens.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -19,7 +19,7 @@ import core.stdc.string;\n import dmd.globals;\n import dmd.identifier;\n import dmd.root.ctfloat;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.root.rmem;\n import dmd.utf;\n "}, {"sha": "d14d0aab5939ea46337906b210ad58cca29a8af8", "filename": "gcc/d/dmd/tokens.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Ftokens.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Ftokens.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftokens.h?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -187,6 +187,7 @@ enum\n         TOKarrow,\n         TOKcolonColon,\n         TOKwchar_tLiteral,\n+        TOKcompoundLiteral,\n \n         TOKinline,\n         TOKregister,"}, {"sha": "cc1d2e351e634cfef1b9753aa1d654d658d6d9c9", "filename": "gcc/d/dmd/traits.d", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Ftraits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Ftraits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftraits.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -49,7 +49,7 @@ import dmd.tokens;\n import dmd.typesem;\n import dmd.visitor;\n import dmd.root.rootobject;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.root.string;\n \n enum LOGSEMANTIC = false;\n@@ -1410,19 +1410,30 @@ Expression semanticTraits(TraitsExp e, Scope* sc)\n         auto o = (*e.args)[0];\n         auto o1 = (*e.args)[1];\n \n-        FuncDeclaration fd;\n-        TypeFunction tf = toTypeFunction(o, fd);\n-\n         ParameterList fparams;\n-        if (tf)\n-            fparams = tf.parameterList;\n-        else if (fd)\n-            fparams = fd.getParameterList();\n+\n+        CallExp ce;\n+        if (auto exp = isExpression(o))\n+            ce = exp.isCallExp();\n+\n+        if (ce)\n+        {\n+            fparams = ce.f.getParameterList();\n+        }\n         else\n         {\n-            e.error(\"first argument to `__traits(getParameterStorageClasses, %s, %s)` is not a function\",\n-                o.toChars(), o1.toChars());\n-            return ErrorExp.get();\n+            FuncDeclaration fd;\n+            auto tf = toTypeFunction(o, fd);\n+            if (tf)\n+                fparams = tf.parameterList;\n+            else if (fd)\n+                fparams = fd.getParameterList();\n+            else\n+            {\n+                e.error(\"first argument to `__traits(getParameterStorageClasses, %s, %s)` is not a function or a function call\",\n+                    o.toChars(), o1.toChars());\n+                return ErrorExp.get();\n+            }\n         }\n \n         // Avoid further analysis for invalid functions leading to misleading error messages"}, {"sha": "f75ae0e0b5af9ab203f4f8afe0424e1b746c15b1", "filename": "gcc/d/dmd/typesem.d", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Ftypesem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Ftypesem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftypesem.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -44,6 +44,7 @@ import dmd.hdrgen;\n import dmd.id;\n import dmd.identifier;\n import dmd.imphint;\n+import dmd.importc;\n import dmd.init;\n import dmd.initsem;\n import dmd.visitor;\n@@ -53,7 +54,7 @@ import dmd.opover;\n import dmd.parse;\n import dmd.root.ctfloat;\n import dmd.root.rmem;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.root.rootobject;\n import dmd.root.string;\n import dmd.root.stringtable;\n@@ -1334,6 +1335,8 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                         continue;\n                 }\n \n+                fparam.type = fparam.type.cAdjustParamType(sc); // adjust C array and function parameter types\n+\n                 Type t = fparam.type.toBasetype();\n \n                 /* If fparam after semantic() turns out to be a tuple, the number of parameters may\n@@ -1378,6 +1381,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                                 stc, narg.type, narg.ident, narg.defaultArg, narg.userAttribDecl);\n                         }\n                         fparam.type = new TypeTuple(newparams);\n+                        fparam.type = fparam.type.typeSemantic(loc, argsc);\n                     }\n                     fparam.storageClass = STC.parameter;\n \n@@ -1627,7 +1631,8 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n             errors = true;\n         }\n \n-        if (tf.parameterList.varargs == VarArg.variadic && tf.linkage != LINK.d && tf.parameterList.length == 0)\n+        if (tf.parameterList.varargs == VarArg.variadic && tf.linkage != LINK.d && tf.parameterList.length == 0 &&\n+            !(sc.flags & SCOPE.Cfile))\n         {\n             .error(loc, \"variadic functions with non-D linkage must have at least one parameter\");\n             errors = true;\n@@ -1750,10 +1755,10 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n             {\n                 // if there was an error evaluating the symbol, it might actually\n                 // be a type. Avoid misleading error messages.\n-               .error(loc, \"`%s` had previous errors\", mtype.toChars());\n+                .error(loc, \"`%s` had previous errors\", mtype.toChars());\n             }\n             else\n-               .error(loc, \"`%s` is used as a type\", mtype.toChars());\n+                .error(loc, \"`%s` is used as a type\", mtype.toChars());\n             return error();\n         }\n         return t;\n@@ -2133,6 +2138,15 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                      * struct S { int a; } *s;\n                      */\n                     sd.members = mtype.members;\n+                    if (sd.semanticRun == PASS.semanticdone)\n+                    {\n+                        /* The first semantic pass marked `sd` as an opaque struct.\n+                         * Re-run semantic so that all newly assigned members are\n+                         * picked up and added to the symtab.\n+                         */\n+                        sd.semanticRun = PASS.semantic;\n+                        sd.dsymbolSemantic(sc);\n+                    }\n                 }\n                 else\n                 {\n@@ -2264,7 +2278,7 @@ RootObject compileTypeMixin(TypeMixin tm, Loc loc, Scope* sc)\n  * Returns:\n  *      the type that was merged\n  */\n-Type merge(Type type)\n+extern (C++) Type merge(Type type)\n {\n     switch (type.ty)\n     {\n@@ -2361,7 +2375,7 @@ Expression getProperty(Type t, Scope* scope_, const ref Loc loc, Identifier iden\n         {\n             const explicitAlignment = mt.alignment();\n             const naturalAlignment = mt.alignsize();\n-            const actualAlignment = (explicitAlignment == STRUCTALIGN_DEFAULT ? naturalAlignment : explicitAlignment);\n+            const actualAlignment = (explicitAlignment.isDefault() ? naturalAlignment : explicitAlignment.get());\n             e = new IntegerExp(loc, actualAlignment, Type.tsize_t);\n         }\n         else if (ident == Id._init)\n@@ -3734,10 +3748,18 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n     }\n \n     /***************************************\n-     * Figures out what to do with an undefined member reference\n-     * for classes and structs.\n-     *\n-     * If flag & 1, don't report \"not a property\" error and just return NULL.\n+     * `ident` was not found as a member of `mt`.\n+     * Attempt to use overloaded opDot(), overloaded opDispatch(), or `alias this`.\n+     * If that fails, forward to visitType().\n+     * Params:\n+     *  mt = class or struct\n+     *  sc = context\n+     *  e = `this` for `ident`\n+     *  ident = name of member\n+     *  flag = flag & 1, don't report \"not a property\" error and just return NULL.\n+     *         flag & DotExpFlag.noAliasThis, don't do 'alias this' resolution.\n+     * Returns:\n+     *  resolved expression if found, otherwise null\n      */\n     Expression noMember(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n     {\n@@ -3828,7 +3850,8 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n \n             /* See if we should forward to the alias this.\n              */\n-            auto alias_e = resolveAliasThis(sc, e, gagError);\n+            auto alias_e = flag & DotExpFlag.noAliasThis ? null\n+                                                         : resolveAliasThis(sc, e, gagError);\n             if (alias_e && alias_e != e)\n             {\n                 /* Rewrite e.ident as:\n@@ -4611,7 +4634,7 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n  * Returns:\n  *  The initialization expression for the type.\n  */\n-Expression defaultInit(Type mt, const ref Loc loc)\n+extern (C++) Expression defaultInit(Type mt, const ref Loc loc)\n {\n     Expression visitBasic(TypeBasic mt)\n     {\n@@ -4744,6 +4767,7 @@ Expression defaultInit(Type mt, const ref Loc loc)\n         }\n         auto cond = IntegerExp.createBool(false);\n         auto msg = new StringExp(loc, \"Accessed expression of type `noreturn`\");\n+        msg.type = Type.tstring;\n         auto ae = new AssertExp(loc, cond, msg);\n         ae.type = mt;\n         return ae;"}, {"sha": "d05af61ce6fd12153f3a6d3690f38d3275f84076", "filename": "gcc/d/dmd/typinf.d", "status": "modified", "additions": 236, "deletions": 2, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Ftypinf.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Ftypinf.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftypinf.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -1,5 +1,5 @@\n /**\n- * Generate `TypeInfo` objects, which are needed for run-time introspection of classes.\n+ * Generate `TypeInfo` objects, which are needed for run-time introspection of types.\n  *\n  * Copyright:   Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * Authors:     $(LINK2 http://www.digitalmars.com, Walter Bright)\n@@ -11,9 +11,87 @@\n \n module dmd.typinf;\n \n+import dmd.astenums;\n+import dmd.declaration;\n+import dmd.dmodule;\n import dmd.dscope;\n+import dmd.dclass;\n+import dmd.dstruct;\n+import dmd.errors;\n import dmd.globals;\n+import dmd.gluelayer;\n import dmd.mtype;\n+import dmd.visitor;\n+import core.stdc.stdio;\n+\n+/****************************************************\n+ * Generates the `TypeInfo` object associated with `torig` if it\n+ * hasn't already been generated\n+ * Params:\n+ *      loc   = the location for reporting line numbers in errors\n+ *      torig = the type to generate the `TypeInfo` object for\n+ *      sc    = the scope\n+ */\n+extern (C++) void genTypeInfo(const ref Loc loc, Type torig, Scope* sc)\n+{\n+    // printf(\"genTypeInfo() %s\\n\", torig.toChars());\n+\n+    // Even when compiling without `useTypeInfo` (e.g. -betterC) we should\n+    // still be able to evaluate `TypeInfo` at compile-time, just not at runtime.\n+    // https://issues.dlang.org/show_bug.cgi?id=18472\n+    if (!sc || !(sc.flags & SCOPE.ctfe))\n+    {\n+        if (!global.params.useTypeInfo)\n+        {\n+            .error(loc, \"`TypeInfo` cannot be used with -betterC\");\n+            fatal();\n+        }\n+    }\n+\n+    if (!Type.dtypeinfo)\n+    {\n+        .error(loc, \"`object.TypeInfo` could not be found, but is implicitly used\");\n+        fatal();\n+    }\n+\n+    Type t = torig.merge2(); // do this since not all Type's are merge'd\n+    if (!t.vtinfo)\n+    {\n+        if (t.isShared()) // does both 'shared' and 'shared const'\n+            t.vtinfo = TypeInfoSharedDeclaration.create(t);\n+        else if (t.isConst())\n+            t.vtinfo = TypeInfoConstDeclaration.create(t);\n+        else if (t.isImmutable())\n+            t.vtinfo = TypeInfoInvariantDeclaration.create(t);\n+        else if (t.isWild())\n+            t.vtinfo = TypeInfoWildDeclaration.create(t);\n+        else\n+            t.vtinfo = getTypeInfoDeclaration(t);\n+        assert(t.vtinfo);\n+\n+        // ClassInfos are generated as part of ClassDeclaration codegen\n+        const isUnqualifiedClassInfo = (t.ty == Tclass && !t.mod);\n+\n+        // generate a COMDAT for other TypeInfos not available as builtins in\n+        // druntime\n+        if (!isUnqualifiedClassInfo && !builtinTypeInfo(t))\n+        {\n+            if (sc) // if in semantic() pass\n+            {\n+                // Find module that will go all the way to an object file\n+                Module m = sc._module.importedFrom;\n+                m.members.push(t.vtinfo);\n+            }\n+            else // if in obj generation pass\n+            {\n+                toObjFile(t.vtinfo, global.params.multiobj);\n+            }\n+        }\n+    }\n+    if (!torig.vtinfo)\n+        torig.vtinfo = t.vtinfo; // Types aren't merged, but we can share the vtinfo's\n+    assert(torig.vtinfo);\n+}\n \n /****************************************************\n  * Gets the type of the `TypeInfo` object associated with `t`\n@@ -24,5 +102,161 @@ import dmd.mtype;\n  * Returns:\n  *      The type of the `TypeInfo` object associated with `t`\n  */\n-extern (C++) Type getTypeInfoType(Loc loc, Type t, Scope* sc);\n+extern (C++) Type getTypeInfoType(const ref Loc loc, Type t, Scope* sc);\n+\n+private TypeInfoDeclaration getTypeInfoDeclaration(Type t)\n+{\n+    //printf(\"Type::getTypeInfoDeclaration() %s\\n\", t.toChars());\n+    switch (t.ty)\n+    {\n+    case Tpointer:\n+        return TypeInfoPointerDeclaration.create(t);\n+    case Tarray:\n+        return TypeInfoArrayDeclaration.create(t);\n+    case Tsarray:\n+        return TypeInfoStaticArrayDeclaration.create(t);\n+    case Taarray:\n+        return TypeInfoAssociativeArrayDeclaration.create(t);\n+    case Tstruct:\n+        return TypeInfoStructDeclaration.create(t);\n+    case Tvector:\n+        return TypeInfoVectorDeclaration.create(t);\n+    case Tenum:\n+        return TypeInfoEnumDeclaration.create(t);\n+    case Tfunction:\n+        return TypeInfoFunctionDeclaration.create(t);\n+    case Tdelegate:\n+        return TypeInfoDelegateDeclaration.create(t);\n+    case Ttuple:\n+        return TypeInfoTupleDeclaration.create(t);\n+    case Tclass:\n+        if ((cast(TypeClass)t).sym.isInterfaceDeclaration())\n+            return TypeInfoInterfaceDeclaration.create(t);\n+        else\n+            return TypeInfoClassDeclaration.create(t);\n+\n+    default:\n+        return TypeInfoDeclaration.create(t);\n+    }\n+}\n+\n+/**************************************************\n+ * Returns:\n+ *      true if any part of type t is speculative.\n+ *      if t is null, returns false.\n+ */\n+bool isSpeculativeType(Type t)\n+{\n+    static bool visitVector(TypeVector t)\n+    {\n+        return isSpeculativeType(t.basetype);\n+    }\n+\n+    static bool visitAArray(TypeAArray t)\n+    {\n+        return isSpeculativeType(t.index) ||\n+               isSpeculativeType(t.next);\n+    }\n+\n+    static bool visitStruct(TypeStruct t)\n+    {\n+        StructDeclaration sd = t.sym;\n+        if (auto ti = sd.isInstantiated())\n+        {\n+            if (!ti.needsCodegen())\n+            {\n+                if (ti.minst || sd.requestTypeInfo)\n+                    return false;\n+\n+                /* https://issues.dlang.org/show_bug.cgi?id=14425\n+                 * TypeInfo_Struct would refer the members of\n+                 * struct (e.g. opEquals via xopEquals field), so if it's instantiated\n+                 * in speculative context, TypeInfo creation should also be\n+                 * stopped to avoid 'unresolved symbol' linker errors.\n+                 */\n+                /* When -debug/-unittest is specified, all of non-root instances are\n+                 * automatically changed to speculative, and here is always reached\n+                 * from those instantiated non-root structs.\n+                 * Therefore, if the TypeInfo is not auctually requested,\n+                 * we have to elide its codegen.\n+                 */\n+                return true;\n+            }\n+        }\n+        else\n+        {\n+            //assert(!sd.inNonRoot() || sd.requestTypeInfo);    // valid?\n+        }\n+        return false;\n+    }\n+\n+    static bool visitClass(TypeClass t)\n+    {\n+        ClassDeclaration sd = t.sym;\n+        if (auto ti = sd.isInstantiated())\n+        {\n+            if (!ti.needsCodegen() && !ti.minst)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n \n+\n+    static bool visitTuple(TypeTuple t)\n+    {\n+        if (t.arguments)\n+        {\n+            foreach (arg; *t.arguments)\n+            {\n+                if (isSpeculativeType(arg.type))\n+                    return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    if (!t)\n+        return false;\n+    Type tb = t.toBasetype();\n+    switch (tb.ty)\n+    {\n+        case Tvector:   return visitVector(tb.isTypeVector());\n+        case Taarray:   return visitAArray(tb.isTypeAArray());\n+        case Tstruct:   return visitStruct(tb.isTypeStruct());\n+        case Tclass:    return visitClass(tb.isTypeClass());\n+        case Ttuple:    return visitTuple(tb.isTypeTuple());\n+        case Tenum:     return false;\n+        default:\n+        return isSpeculativeType(tb.nextOf());\n+\n+        /* For TypeFunction, TypeInfo_Function doesn't store parameter types,\n+         * so only the .next (the return type) is checked here.\n+         */\n+    }\n+}\n+\n+/* ========================================================================= */\n+\n+/* Indicates whether druntime already contains an appropriate TypeInfo instance\n+ * for the specified type (in module rt.util.typeinfo).\n+ */\n+extern (C++) bool builtinTypeInfo(Type t)\n+{\n+    if (!t.mod) // unqualified types only\n+    {\n+        // unqualified basic types + typeof(null)\n+        if (t.isTypeBasic() || t.ty == Tnull)\n+            return true;\n+        // some unqualified arrays\n+        if (t.ty == Tarray)\n+        {\n+            Type next = t.nextOf();\n+            return (next.isTypeBasic() && !next.mod)                     // of unqualified basic types\n+                || (next.ty == Tchar && next.mod == MODFlags.immutable_) // string\n+                || (next.ty == Tchar && next.mod == MODFlags.const_);    // const(char)[]\n+        }\n+    }\n+    return false;\n+}"}, {"sha": "b3782afe78b0fc9f4d518376f024c2c1b025c883", "filename": "gcc/d/dmd/utf.h", "status": "removed", "additions": 0, "deletions": 117, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Fd%2Fdmd%2Futf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Fd%2Fdmd%2Futf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Futf.h?ref=c15aa46cca0649b68613d3292cf71c7cc57ef78f", "patch": "@@ -1,117 +0,0 @@\n-\n-/* Compiler implementation of the D programming language\n- * Copyright (C) 2003-2021 by The D Language Foundation, All Rights Reserved\n- * written by Walter Bright\n- * http://www.digitalmars.com\n- * Distributed under the Boost Software License, Version 1.0.\n- * http://www.boost.org/LICENSE_1_0.txt\n- * https://github.com/D-Programming-Language/dmd/blob/master/src/utf.h\n- */\n-\n-#pragma once\n-\n-#include \"root/dsystem.h\"\n-\n-/// A UTF-8 code unit\n-typedef unsigned char   utf8_t;\n-/// A UTF-16 code unit\n-typedef unsigned short  utf16_t;\n-/// A UTF-32 code unit\n-typedef unsigned int    utf32_t;\n-typedef utf32_t         dchar_t;\n-\n-#define ALPHA_TABLE_LENGTH 245\n-static utf16_t const ALPHA_TABLE[ALPHA_TABLE_LENGTH][2] =\n-{\n-    { 0x00AA, 0x00AA }, { 0x00B5, 0x00B5 }, { 0x00B7, 0x00B7 }, { 0x00BA, 0x00BA },\n-    { 0x00C0, 0x00D6 }, { 0x00D8, 0x00F6 }, { 0x00F8, 0x01F5 }, { 0x01FA, 0x0217 },\n-    { 0x0250, 0x02A8 }, { 0x02B0, 0x02B8 }, { 0x02BB, 0x02BB }, { 0x02BD, 0x02C1 },\n-    { 0x02D0, 0x02D1 }, { 0x02E0, 0x02E4 }, { 0x037A, 0x037A }, { 0x0386, 0x0386 },\n-    { 0x0388, 0x038A }, { 0x038C, 0x038C }, { 0x038E, 0x03A1 }, { 0x03A3, 0x03CE },\n-    { 0x03D0, 0x03D6 }, { 0x03DA, 0x03DA }, { 0x03DC, 0x03DC }, { 0x03DE, 0x03DE },\n-    { 0x03E0, 0x03E0 }, { 0x03E2, 0x03F3 }, { 0x0401, 0x040C }, { 0x040E, 0x044F },\n-    { 0x0451, 0x045C }, { 0x045E, 0x0481 }, { 0x0490, 0x04C4 }, { 0x04C7, 0x04C8 },\n-    { 0x04CB, 0x04CC }, { 0x04D0, 0x04EB }, { 0x04EE, 0x04F5 }, { 0x04F8, 0x04F9 },\n-    { 0x0531, 0x0556 }, { 0x0559, 0x0559 }, { 0x0561, 0x0587 }, { 0x05B0, 0x05B9 },\n-    { 0x05BB, 0x05BD }, { 0x05BF, 0x05BF }, { 0x05C1, 0x05C2 }, { 0x05D0, 0x05EA },\n-    { 0x05F0, 0x05F2 }, { 0x0621, 0x063A }, { 0x0640, 0x0652 }, { 0x0660, 0x0669 },\n-    { 0x0670, 0x06B7 }, { 0x06BA, 0x06BE }, { 0x06C0, 0x06CE }, { 0x06D0, 0x06DC },\n-    { 0x06E5, 0x06E8 }, { 0x06EA, 0x06ED }, { 0x06F0, 0x06F9 }, { 0x0901, 0x0903 },\n-    { 0x0905, 0x0939 }, { 0x093D, 0x094D }, { 0x0950, 0x0952 }, { 0x0958, 0x0963 },\n-    { 0x0966, 0x096F }, { 0x0981, 0x0983 }, { 0x0985, 0x098C }, { 0x098F, 0x0990 },\n-    { 0x0993, 0x09A8 }, { 0x09AA, 0x09B0 }, { 0x09B2, 0x09B2 }, { 0x09B6, 0x09B9 },\n-    { 0x09BE, 0x09C4 }, { 0x09C7, 0x09C8 }, { 0x09CB, 0x09CD }, { 0x09DC, 0x09DD },\n-    { 0x09DF, 0x09E3 }, { 0x09E6, 0x09F1 }, { 0x0A02, 0x0A02 }, { 0x0A05, 0x0A0A },\n-    { 0x0A0F, 0x0A10 }, { 0x0A13, 0x0A28 }, { 0x0A2A, 0x0A30 }, { 0x0A32, 0x0A33 },\n-    { 0x0A35, 0x0A36 }, { 0x0A38, 0x0A39 }, { 0x0A3E, 0x0A42 }, { 0x0A47, 0x0A48 },\n-    { 0x0A4B, 0x0A4D }, { 0x0A59, 0x0A5C }, { 0x0A5E, 0x0A5E }, { 0x0A66, 0x0A6F },\n-    { 0x0A74, 0x0A74 }, { 0x0A81, 0x0A83 }, { 0x0A85, 0x0A8B }, { 0x0A8D, 0x0A8D },\n-    { 0x0A8F, 0x0A91 }, { 0x0A93, 0x0AA8 }, { 0x0AAA, 0x0AB0 }, { 0x0AB2, 0x0AB3 },\n-    { 0x0AB5, 0x0AB9 }, { 0x0ABD, 0x0AC5 }, { 0x0AC7, 0x0AC9 }, { 0x0ACB, 0x0ACD },\n-    { 0x0AD0, 0x0AD0 }, { 0x0AE0, 0x0AE0 }, { 0x0AE6, 0x0AEF }, { 0x0B01, 0x0B03 },\n-    { 0x0B05, 0x0B0C }, { 0x0B0F, 0x0B10 }, { 0x0B13, 0x0B28 }, { 0x0B2A, 0x0B30 },\n-    { 0x0B32, 0x0B33 }, { 0x0B36, 0x0B39 }, { 0x0B3D, 0x0B43 }, { 0x0B47, 0x0B48 },\n-    { 0x0B4B, 0x0B4D }, { 0x0B5C, 0x0B5D }, { 0x0B5F, 0x0B61 }, { 0x0B66, 0x0B6F },\n-    { 0x0B82, 0x0B83 }, { 0x0B85, 0x0B8A }, { 0x0B8E, 0x0B90 }, { 0x0B92, 0x0B95 },\n-    { 0x0B99, 0x0B9A }, { 0x0B9C, 0x0B9C }, { 0x0B9E, 0x0B9F }, { 0x0BA3, 0x0BA4 },\n-    { 0x0BA8, 0x0BAA }, { 0x0BAE, 0x0BB5 }, { 0x0BB7, 0x0BB9 }, { 0x0BBE, 0x0BC2 },\n-    { 0x0BC6, 0x0BC8 }, { 0x0BCA, 0x0BCD }, { 0x0BE7, 0x0BEF }, { 0x0C01, 0x0C03 },\n-    { 0x0C05, 0x0C0C }, { 0x0C0E, 0x0C10 }, { 0x0C12, 0x0C28 }, { 0x0C2A, 0x0C33 },\n-    { 0x0C35, 0x0C39 }, { 0x0C3E, 0x0C44 }, { 0x0C46, 0x0C48 }, { 0x0C4A, 0x0C4D },\n-    { 0x0C60, 0x0C61 }, { 0x0C66, 0x0C6F }, { 0x0C82, 0x0C83 }, { 0x0C85, 0x0C8C },\n-    { 0x0C8E, 0x0C90 }, { 0x0C92, 0x0CA8 }, { 0x0CAA, 0x0CB3 }, { 0x0CB5, 0x0CB9 },\n-    { 0x0CBE, 0x0CC4 }, { 0x0CC6, 0x0CC8 }, { 0x0CCA, 0x0CCD }, { 0x0CDE, 0x0CDE },\n-    { 0x0CE0, 0x0CE1 }, { 0x0CE6, 0x0CEF }, { 0x0D02, 0x0D03 }, { 0x0D05, 0x0D0C },\n-    { 0x0D0E, 0x0D10 }, { 0x0D12, 0x0D28 }, { 0x0D2A, 0x0D39 }, { 0x0D3E, 0x0D43 },\n-    { 0x0D46, 0x0D48 }, { 0x0D4A, 0x0D4D }, { 0x0D60, 0x0D61 }, { 0x0D66, 0x0D6F },\n-    { 0x0E01, 0x0E3A }, { 0x0E40, 0x0E5B }, { 0x0E81, 0x0E82 },\n-    { 0x0E84, 0x0E84 }, { 0x0E87, 0x0E88 }, { 0x0E8A, 0x0E8A }, { 0x0E8D, 0x0E8D },\n-    { 0x0E94, 0x0E97 }, { 0x0E99, 0x0E9F }, { 0x0EA1, 0x0EA3 }, { 0x0EA5, 0x0EA5 },\n-    { 0x0EA7, 0x0EA7 }, { 0x0EAA, 0x0EAB }, { 0x0EAD, 0x0EAE }, { 0x0EB0, 0x0EB9 },\n-    { 0x0EBB, 0x0EBD }, { 0x0EC0, 0x0EC4 }, { 0x0EC6, 0x0EC6 }, { 0x0EC8, 0x0ECD },\n-    { 0x0ED0, 0x0ED9 }, { 0x0EDC, 0x0EDD }, { 0x0F00, 0x0F00 }, { 0x0F18, 0x0F19 },\n-    { 0x0F20, 0x0F33 }, { 0x0F35, 0x0F35 }, { 0x0F37, 0x0F37 }, { 0x0F39, 0x0F39 },\n-    { 0x0F3E, 0x0F47 }, { 0x0F49, 0x0F69 }, { 0x0F71, 0x0F84 }, { 0x0F86, 0x0F8B },\n-    { 0x0F90, 0x0F95 }, { 0x0F97, 0x0F97 }, { 0x0F99, 0x0FAD }, { 0x0FB1, 0x0FB7 },\n-    { 0x0FB9, 0x0FB9 }, { 0x10A0, 0x10C5 }, { 0x10D0, 0x10F6 }, { 0x1E00, 0x1E9B },\n-    { 0x1EA0, 0x1EF9 }, { 0x1F00, 0x1F15 }, { 0x1F18, 0x1F1D }, { 0x1F20, 0x1F45 },\n-    { 0x1F48, 0x1F4D }, { 0x1F50, 0x1F57 }, { 0x1F59, 0x1F59 }, { 0x1F5B, 0x1F5B },\n-    { 0x1F5D, 0x1F5D }, { 0x1F5F, 0x1F7D }, { 0x1F80, 0x1FB4 }, { 0x1FB6, 0x1FBC },\n-    { 0x1FBE, 0x1FBE }, { 0x1FC2, 0x1FC4 }, { 0x1FC6, 0x1FCC }, { 0x1FD0, 0x1FD3 },\n-    { 0x1FD6, 0x1FDB }, { 0x1FE0, 0x1FEC }, { 0x1FF2, 0x1FF4 }, { 0x1FF6, 0x1FFC },\n-    { 0x203F, 0x2040 }, { 0x207F, 0x207F }, { 0x2102, 0x2102 }, { 0x2107, 0x2107 },\n-    { 0x210A, 0x2113 }, { 0x2115, 0x2115 }, { 0x2118, 0x211D }, { 0x2124, 0x2124 },\n-    { 0x2126, 0x2126 }, { 0x2128, 0x2128 }, { 0x212A, 0x2131 }, { 0x2133, 0x2138 },\n-    { 0x2160, 0x2182 }, { 0x3005, 0x3007 }, { 0x3021, 0x3029 }, { 0x3041, 0x3093 },\n-    { 0x309B, 0x309C }, { 0x30A1, 0x30F6 }, { 0x30FB, 0x30FC }, { 0x3105, 0x312C },\n-    { 0x4E00, 0x9FA5 }, { 0xAC00, 0xD7A3 },\n-};\n-\n-char const *const UTF8_DECODE_OK = NULL;\n-extern char const UTF8_DECODE_OUTSIDE_CODE_SPACE[];\n-extern char const UTF8_DECODE_TRUNCATED_SEQUENCE[];\n-extern char const UTF8_DECODE_OVERLONG[];\n-extern char const UTF8_DECODE_INVALID_TRAILER[];\n-extern char const UTF8_DECODE_INVALID_CODE_POINT[];\n-\n-char const *const UTF16_DECODE_OK = NULL;\n-extern char const UTF16_DECODE_TRUNCATED_SEQUENCE[];\n-extern char const UTF16_DECODE_INVALID_SURROGATE[];\n-extern char const UTF16_DECODE_UNPAIRED_SURROGATE[];\n-extern char const UTF16_DECODE_INVALID_CODE_POINT[];\n-\n-/// \\return true if \\a c is a valid, non-private UTF-32 code point\n-bool utf_isValidDchar(dchar_t c);\n-\n-bool isUniAlpha(dchar_t c);\n-\n-int utf_codeLengthChar(dchar_t c);\n-int utf_codeLengthWchar(dchar_t c);\n-int utf_codeLength(int sz, dchar_t c);\n-\n-void utf_encodeChar(utf8_t *s, dchar_t c);\n-void utf_encodeWchar(utf16_t *s, dchar_t c);\n-void utf_encode(int sz, void *s, dchar_t c);\n-\n-const char *utf_decodeChar(utf8_t const *s, size_t len, size_t *pidx, dchar_t *presult);\n-const char *utf_decodeWchar(utf16_t const *s, size_t len, size_t *pidx, dchar_t *presult);"}, {"sha": "6cd5d20f6f78d8ed6e997d5e85d795c7a5a265c0", "filename": "gcc/d/dmd/utils.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Futils.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fdmd%2Futils.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Futils.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -16,7 +16,7 @@ import dmd.errors;\n import dmd.globals;\n import dmd.root.file;\n import dmd.root.filename;\n-import dmd.root.outbuffer;\n+import dmd.common.outbuffer;\n import dmd.root.string;\n \n "}, {"sha": "2831eefc4ba6469a368cc89ab3ad238603b1cc3d", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -1757,7 +1757,7 @@ class ExprVisitor : public Visitor\n \t\t/* C++ constructors return void, even though front-end semantic\n \t\t   treats them as implicitly returning `this'.  Set returnvalue\n \t\t   to override the result of this expression.  */\n-\t\tif (fd->isCtorDeclaration () && fd->linkage == LINK::cpp)\n+\t\tif (fd->isCtorDeclaration ())\n \t\t  {\n \t\t    thisexp = d_save_expr (thisexp);\n \t\t    returnvalue = thisexp;\n@@ -1846,6 +1846,11 @@ class ExprVisitor : public Visitor\n       {\n \ttree init = TARGET_EXPR_INITIAL (cleanup);\n \tTARGET_EXPR_INITIAL (cleanup) = compound_expr (init, exp);\n+\n+\t/* Keep the return value outside the TARGET_EXPR.  */\n+\tif (returnvalue != NULL_TREE)\n+\t  cleanup = compound_expr (cleanup, TREE_OPERAND (exp, 1));\n+\n \texp = cleanup;\n       }\n \n@@ -1856,7 +1861,7 @@ class ExprVisitor : public Visitor\n \n   void visit (DelegateExp *e)\n   {\n-    if (e->func->semanticRun == PASSsemantic3done)\n+    if (e->func->semanticRun == PASS::semantic3done)\n       {\n \t/* Add the function as nested function if it belongs to this module.\n \t   ie: it is a member of this module, or it is a template instance.  */"}, {"sha": "d37d205e870fe123029b4f6b34e6b966ba2cc7b8", "filename": "gcc/d/gdc.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fgdc.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fgdc.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fgdc.texi?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -283,6 +283,13 @@ Sets @code{__traits(getTargetInfo \"cppStd\")} to @code{202002}.\n @cindex @option{-fno-invariants}\n Turns off code generation for class @code{invariant} contracts.\n \n+@item -fmain\n+@cindex @option{-fmain}\n+Generates a default @code{main()} function when compiling.  This is useful when\n+unittesting a library, as it enables running the unittests in a library without\n+having to manually define an entry-point function.  This option does nothing\n+when @code{main} is already defined in user code.\n+\n @item -fno-moduleinfo\n @cindex @option{-fmoduleinfo}\n @cindex @option{-fno-moduleinfo}\n@@ -742,6 +749,8 @@ List information on all D language transitions.\n List all usages of complex or imaginary types.\n @item field\n List all non-mutable fields which occupy an object instance.\n+@item in\n+List all usages of @code{in} on parameter.\n @item nogc\n List all hidden GC allocations.\n @item templates"}, {"sha": "d0a5e2f685966c22981c37fa35b4b40a80372ceb", "filename": "gcc/d/lang.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Flang.opt?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -436,6 +436,10 @@ ftransition=field\n D RejectNegative\n List all non-mutable fields which occupy an object instance.\n \n+ftransition=in\n+D RejectNegative\n+List all usages of 'in' on parameter.\n+\n ftransition=nogc\n D RejectNegative\n List all hidden GC allocations."}, {"sha": "cb5c4a7b1e78665fea6eb78a2bf00af2508ad39f", "filename": "gcc/d/modules.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fmodules.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Fmodules.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fmodules.cc?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -145,7 +145,7 @@ get_internal_fn (tree ident, const Visibility &visibility)\n   fd->loc = Loc (mod->srcfile.toChars (), 1, 0);\n   fd->parent = mod;\n   fd->visibility = visibility;\n-  fd->semanticRun = PASSsemantic3done;\n+  fd->semanticRun = PASS::semantic3done;\n \n   return fd;\n }"}, {"sha": "b39b92eb822668ce08657ba1194d58b060dbca22", "filename": "gcc/d/types.cc", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Fd%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftypes.cc?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -610,7 +610,8 @@ class TypeVisitor : public Visitor\n \n   void visit (TypeNoreturn *t)\n   {\n-    t->ctype = void_type_node;\n+    t->ctype = noreturn_type_node;\n+    TYPE_NAME (t->ctype) = get_identifier (t->toChars ());\n   }\n \n   /* Basic Data Types.  */\n@@ -770,11 +771,17 @@ class TypeVisitor : public Visitor\n \tfnparams = chainon (fnparams, build_tree_list (0, type));\n       }\n \n-    size_t n_args = t->parameterList.length ();\n+    const size_t n_args = t->parameterList.length ();\n \n     for (size_t i = 0; i < n_args; i++)\n       {\n \ttree type = parameter_type (t->parameterList[i]);\n+\n+\t/* Type `noreturn` is a terminator, as no other arguments can possibly\n+\t   be evaluated after it.  */\n+\tif (type == noreturn_type_node)\n+\t  break;\n+\n \tfnparams = chainon (fnparams, build_tree_list (0, type));\n       }\n \n@@ -797,6 +804,10 @@ class TypeVisitor : public Visitor\n     TYPE_LANG_SPECIFIC (t->ctype) = build_lang_type (t);\n     d_keep (t->ctype);\n \n+    /* Qualify function types that have the type `noreturn` as volatile.  */\n+    if (fntype == noreturn_type_node)\n+      t->ctype = build_qualified_type (t->ctype, TYPE_QUAL_VOLATILE);\n+\n     /* Handle any special support for calling conventions.  */\n     switch (t->linkage)\n       {\n@@ -995,8 +1006,8 @@ class TypeVisitor : public Visitor\n \t   the context or laying out fields as those types may make\n \t   recursive references to this type.  */\n \tunsigned structsize = t->sym->structsize;\n-\tunsigned alignsize = (t->sym->alignment != STRUCTALIGN_DEFAULT)\n-\t  ? t->sym->alignment : t->sym->alignsize;\n+\tunsigned alignsize = t->sym->alignment.isDefault ()\n+\t  ? t->sym->alignsize : t->sym->alignment.get ();\n \n \tTYPE_SIZE (t->ctype) = bitsize_int (structsize * BITS_PER_UNIT);\n \tTYPE_SIZE_UNIT (t->ctype) = size_int (structsize);"}, {"sha": "063a9df152a1c902059984d251ff25234abe1330", "filename": "gcc/testsuite/gdc.test/compilable/b19294.d", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fb19294.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fb19294.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fb19294.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,69 @@\n+alias MT = MyStruct!int;\n+\n+struct MyStruct(T)\n+{\n+    T x;\n+\n+    this(T y)\n+    {\n+        x = y;\n+    }\n+\n+    MyStruct!T opBinary(string op)(MyStruct!T y) const\n+    {\n+        alias C = typeof(return);\n+        auto w = C(this.x);\n+        return w.opOpAssign!(op)(y);\n+    }\n+\n+    MyStruct!T opBinaryRight(string op)(MyStruct!T y) const\n+    {\n+        return opBinary!(op)(y);\n+    }\n+\n+    ref MyStruct opOpAssign(string op, T)(const MyStruct!T z)\n+    {\n+        mixin (\"x \"~op~\"= z.x;\");\n+        return this;\n+    }\n+\n+    MyStruct!T opBinary(string op)(T y) const\n+    {\n+        alias C = typeof(return);\n+        auto w = C(this.x);\n+        return w.opOpAssign!(op)(y);\n+    }\n+\n+    MyStruct!T opBinaryRight(string op)(T y) const\n+    {\n+        return opBinary!(op)(y);\n+    }\n+\n+    ref MyStruct opOpAssign(string op, T)(const T z)\n+    {\n+        mixin (\"x \"~op~\"= z;\");\n+        return this;\n+    }\n+}\n+\n+void test()\n+{\n+    MT s = MyStruct!int(1);\n+    MT[] arr = [s, 2 * s, 3 * s, 4 * s, 5 * s, 6 * s];\n+    MT[] result = new MT[arr.length];\n+    \n+    result[] = arr[] + s;\n+    result[] = s + arr[];\n+    \n+    result[] = arr[] - s;\n+    result[] = s - arr[];\n+    \n+    result[] = arr[] * s;\n+    result[] = s * arr[];\n+    \n+    result[] = arr[] / s;\n+    result[] = s / arr[];\n+    \n+    result[] = arr[] ^^ s;\n+    result[] = s ^^ arr[];\n+}"}, {"sha": "424881867172fcce4d071028e47623a18331a5b3", "filename": "gcc/testsuite/gdc.test/compilable/cdcmp.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcdcmp.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcdcmp.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcdcmp.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -2,7 +2,7 @@\n // REQUIRED_ARGS: -O\n // POST_SCRIPT: compilable/extra-files/objdump-postscript.sh\n // only testing on SYSV-ABI, but backend code is identical across platforms\n-// DISABLED: win32 win64 osx linux32 freebsd32 freebsd64\n+// DISABLED: win32 win64 osx linux32 freebsd32 freebsd64 openbsd32 openbsd64\n \n bool test_ltz(ubyte x) { return x <  0; }\n bool test_lez(ubyte x) { return x <= 0; }"}, {"sha": "5e8836d78ad65fc77040785e3455d0f4fd4c76a9", "filename": "gcc/testsuite/gdc.test/compilable/ddoc_markdown_tables_22285.d", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc_markdown_tables_22285.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc_markdown_tables_22285.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc_markdown_tables_22285.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,15 @@\n+// PERMUTE_ARGS:\n+// REQUIRED_ARGS: -D -Dd${RESULTS_DIR}/compilable -o-\n+// TEST_OUTPUT_FILE: extra-files/ddoc_markdown_tables_22285.html\n+// OUTPUT_FILES: ${RESULTS_DIR}/compilable/ddoc_markdown_tables_22285.html\n+\n+module test.compilable.ddoc_markdown_tables_22285;\n+\n+/**\n+| A | B | C |\n+|---|---|---|\n+| a | 0 |   |\n+| b | 1 1 1   |              |\n+| c | 2 |   |\n+*/\n+enum _ = 0;"}, {"sha": "47c0172009dfcb294986fcc57b70ee29e5be3c80", "filename": "gcc/testsuite/gdc.test/compilable/dtoh_ignored.d", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_ignored.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_ignored.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_ignored.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -144,4 +144,7 @@ __gshared void function(ifloat) onVariableFunctionParam;\n \n __gshared ifloat delegate() onVariableDelegate;\n \n-noreturn myExit() {}\n+noreturn myExit()\n+{\n+    assert(false);\n+}"}, {"sha": "f6aaf3b2a4ae193bfaea86daab9358deae2f9ce1", "filename": "gcc/testsuite/gdc.test/compilable/imports/cstuff3.c", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fcstuff3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fcstuff3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fcstuff3.c?ref=c15aa46cca0649b68613d3292cf71c7cc57ef78f", "patch": "@@ -1,6 +0,0 @@\n-// check bugs in importing C files\n-\n-int squared(int a)\n-{\n-    return a * a;\n-}"}, {"sha": "d160bd410ad16511f8b0d5ec7f251210a96786b7", "filename": "gcc/testsuite/gdc.test/compilable/mixintype2.d", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmixintype2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmixintype2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmixintype2.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -66,3 +66,52 @@ static assert(is(T8 == const(ubyte*)));\n alias T8 = mixin(q{immutable(__traits(getMember, S, \"T\"))})*;\n static assert(is(T8 == immutable(float*)*));\n */\n+\n+/**************************************************/\n+// https://issues.dlang.org/show_bug.cgi?id=22356\n+\n+mixin(\"void\") func22356(int) { }\n+static assert(is(typeof(&func22356) == void function(int)));\n+\n+static mixin(\"void\") func22356_s(char) { }\n+static assert(is(typeof(&func22356_s) == void function(char)));\n+\n+mixin(\"int\")[2] func22356_2(int) { return [1, 2]; }\n+static assert(is(typeof(&func22356_2) == int[2] function(int)));\n+\n+mixin(\"int\") func22356tp(S, T)(S, T) { return 1; }\n+static assert(is(typeof(&func22356tp!(char, float)) == int function(char, float) pure nothrow @nogc @safe));\n+\n+mixin(\"int\") x22356;\n+static assert(is(typeof(x22356) == int));\n+\n+mixin(\"int\")** xpp22356;\n+static assert(is(typeof(xpp22356) == int**));\n+\n+mixin(\"int\") y22356, z22356;\n+static assert(is(typeof(y22356) == int) && is(typeof(z22356) == int));\n+\n+// Already working but for completeness\n+void test_statements_22356()\n+{\n+    mixin(\"void\") func22356(int) { }\n+    static assert(is(typeof(&func22356) == void delegate(int) pure nothrow @nogc @safe));\n+\n+    static mixin(\"void\") func22356_s(char) { }\n+    static assert(is(typeof(&func22356_s) == void function(char) pure nothrow @nogc @safe));\n+\n+    mixin(\"int\")[2] func22356_2(int) { return [1, 2]; }\n+    static assert(is(typeof(&func22356_2) == int[2] delegate(int) pure nothrow @nogc @safe));\n+\n+    mixin(\"int\") func22356tp(S, T)(S, T) { return 1; }\n+    static assert(is(typeof(&func22356tp!(char, float)) == int delegate(char, float) pure nothrow @nogc @safe));\n+\n+    mixin(\"int\") x22356;\n+    static assert(is(typeof(x22356) == int));\n+\n+    mixin(\"int\")** xpp22356;\n+    static assert(is(typeof(xpp22356) == int**));\n+\n+    mixin(\"int\") y22356, z22356;\n+    static assert(is(typeof(y22356) == int) && is(typeof(z22356) == int));\n+}"}, {"sha": "b041e072e9c2cb0833f904423768ec00a4fb5410", "filename": "gcc/testsuite/gdc.test/compilable/noreturn1.d", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fnoreturn1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fnoreturn1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fnoreturn1.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -49,18 +49,65 @@ static assert(noreturn.alignof == 0);\n static assert((noreturn*).sizeof == (int*).sizeof);\n static assert((noreturn[]).sizeof == (int[]).sizeof);\n \n+static assert(is(typeof(noreturn.init) == noreturn));\n+static assert(is(typeof((const noreturn).init) == const noreturn));\n+static assert(is(typeof((immutable noreturn).init) == immutable noreturn));\n+static assert(is(typeof((shared noreturn).init) == shared noreturn));\n+\n version (DigitalMars)\n-    noreturn exits(int* p) { *p = 3; }\n+    noreturn exits(int* p)\n+    {\n+        *p = 3;\n+        assert(false); // *p could be valid\n+    }\n \n noreturn exit();\n \n noreturn pureexits() @nogc nothrow pure @safe { assert(0); }\n \n noreturn callpureexits() { pureexits(); }\n \n+noreturn returnExits()\n+{\n+    return pureexits();\n+}\n+\n+void alsoExits()\n+{\n+    return assert(0);\n+}\n+\n+int thisAlsoExits()\n+{\n+    return assert(0);\n+}\n+\n+void cast_()\n+{\n+    noreturn n;\n+    int i = n;\n+}\n+\n int test1(int i)\n {\n     if (exit())\n         return i + 1;\n     return i - 1;\n }\n+\n+noreturn tlsNoreturn;\n+__gshared noreturn globalNoreturn;\n+\n+template CreateTLS(A)\n+{\n+    A a;\n+}\n+\n+void* useTls()\n+{\n+    alias Tnr = CreateTLS!noreturn;\n+    void* a1 = &Tnr.a;\n+    void* a2 = &tlsNoreturn;\n+    void* a3 = &globalNoreturn;\n+    return a1 < a2 ? a2 : a3;\n+}"}, {"sha": "e5ed7a8bafb2c3421e276d1678f9a13af2028ab5", "filename": "gcc/testsuite/gdc.test/compilable/previewall.d", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fpreviewall.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fpreviewall.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fpreviewall.d?ref=c15aa46cca0649b68613d3292cf71c7cc57ef78f", "patch": "@@ -1,10 +0,0 @@\n-// ARG_SETS: -preview=all\n-// ARG_SETS: -transition=all\n-// ARG_SETS: -revert=all\n-import core.stdc.stdio;\n-\n-void main (string[] args)\n-{\n-    if (args.length == 42)\n-        printf(\"Hello World\\n\");\n-}"}, {"sha": "9a4db353e0a20a635c2d7f5c5a0f324977532262", "filename": "gcc/testsuite/gdc.test/compilable/reinterpretctfe.d", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Freinterpretctfe.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Freinterpretctfe.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Freinterpretctfe.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -1,5 +1,11 @@\n // https://issues.dlang.org/show_bug.cgi?id=21997\n \n+struct Strukt\n+{\n+    int i;\n+    string s;\n+}\n+\n int nonPureFunc(int i)\n {\n     return 2 * i;\n@@ -28,6 +34,14 @@ int mainCtfe()\n     auto baseDel = cast(int delegate(int)) pureDel;\n     assert(baseDel(4) == 20);\n     */\n+\n+    {\n+        shared Strukt shStr;\n+        Strukt str = *cast(Strukt*) &shStr;\n+\n+        shared(Strukt)* ptr = cast(shared(Strukt)*) &str;\n+    }\n+\n     return 0;\n }\n "}, {"sha": "8ea515c164a56b6e24fa8702903fc9b13c6ecfec", "filename": "gcc/testsuite/gdc.test/compilable/sroa.d", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fsroa.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fsroa.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fsroa.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,55 @@\n+/* REQUIRED_ARGS: -O -release -inline\n+This compares two different ways to do a for loop. The range\n+version should SROA the VecRange struct into two register variables.\n+*/\n+\n+extern (C):\n+\n+nothrow:\n+@nogc:\n+@safe:\n+\n+alias vec_base_t = size_t;                     // base type of vector\n+alias vec_t = vec_base_t*;\n+\n+@trusted\n+pure\n+size_t vec_index(size_t b, const vec_t vec);\n+\n+@trusted\n+pure ref inout(vec_base_t) vec_numbits(inout vec_t v) { return v[-1]; }\n+@trusted\n+pure ref inout(vec_base_t) vec_dim(inout vec_t v) { return v[-2]; }\n+\n+struct VecRange\n+{\n+    size_t i;\n+    const vec_t v;\n+\n+  @nogc @safe nothrow pure:\n+    this(const vec_t v) { this.v = v; i = vec_index(0, v); }\n+    bool empty() const { return i == vec_numbits(v); }\n+    size_t front() const { return i; }\n+    void popFront() { i = vec_index(i + 1, v); }\n+}\n+\n+@safe\n+pure\n+uint vec_numBitsSet(const vec_t vec)\n+{\n+    uint n = 0;\n+    size_t length = vec_numbits(vec);\n+    for (size_t i = 0; (i = vec_index(i, vec)) < length; ++i)\n+        ++n;\n+    return n;\n+}\n+\n+@safe\n+pure\n+uint vec_numBitsSet2(const vec_t vec)\n+{\n+    uint n = 0;\n+    foreach (j; VecRange(vec))\n+        ++n;\n+    return n;\n+}"}, {"sha": "c5c4e5f0ac0a501fce1e29b7bc9880603febad4e", "filename": "gcc/testsuite/gdc.test/compilable/stc_traits.d", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fstc_traits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fstc_traits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fstc_traits.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,172 @@\n+// REQUIRED_ARGS: -preview=dip1000 -preview=in\n+/*\n+TEST_OUTPUT:\n+---\n+100 tuple()\n+101 tuple(\"return\", \"ref\")\n+102 tuple(\"ref\")\n+103 tuple()\n+104 tuple(\"ref\")\n+105 tuple()\n+106 tuple()\n+107 tuple(\"ref\")\n+108 tuple(\"ref\")\n+109 tuple(\"ref\")\n+110 tuple(\"ref\")\n+111 tuple()\n+112 tuple(\"ref\")\n+113 tuple(\"ref\")\n+114 tuple(\"ref\")\n+115 tuple(\"ref\")\n+116 tuple()\n+117 tuple(\"ref\")\n+118 tuple(\"ref\")\n+119 tuple()\n+120 tuple(\"ref\")\n+121 tuple()\n+122 tuple(\"ref\")\n+123 tuple(\"in\")\n+124 tuple(\"in\")\n+m       tuple(\"ref\")\n+m-mixin tuple(\"ref\")\n+m       tuple(\"ref\")\n+m-mixin tuple(\"ref\")\n+m       tuple(\"ref\")\n+m-mixin tuple(\"ref\")\n+m       tuple(\"return\", \"ref\")\n+m-mixin tuple(\"return\", \"ref\")\n+m       tuple(\"ref\")\n+m-mixin tuple(\"ref\")\n+m       tuple(\"ref\")\n+m-mixin tuple(\"ref\")\n+m       tuple()\n+m-mixin tuple()\n+m       tuple(\"ref\")\n+m-mixin tuple(\"ref\")\n+m       tuple(\"ref\")\n+m-mixin tuple(\"ref\")\n+m       tuple(\"ref\")\n+m-mixin tuple(\"ref\")\n+m       tuple(\"ref\")\n+m-mixin tuple(\"ref\")\n+m       tuple(\"ref\")\n+m-mixin tuple(\"ref\")\n+m       tuple(\"ref\")\n+m-mixin tuple(\"ref\")\n+m       tuple(\"in\")\n+m-mixin tuple(\"in\")\n+---\n+*/\n+\n+void func(int i) {}\n+void func(return ref bool i) {}\n+void func(ref float a, int b) {}\n+void get(T : int)(ref T t) {}\n+void get()(float t) {}\n+void get(T)(ref T[] t) {}\n+void funcautoi()(auto ref int i) {}\n+void funcauto(T)(auto ref T a) {}\n+void funcin(in int i) {}\n+\n+struct Foo {\n+\tvoid foo(int i) {}\n+\tvoid foo(ref bool i) {}\n+\tstatic void sfoo(ref int i) {}\n+}\n+\n+struct FooT(T) {\n+\tvoid foo(ref T i) {}\n+\tstatic void sfoo(ref T i) {}\n+}\n+\n+class Bar {\n+\tvoid bar(int i) {}\n+\tvoid bar(ref bool i) {}\n+\tstatic void sbar(ref int i) {}\n+}\n+\n+class BarT(T) {\n+\tvoid bar(ref T i) {}\n+\tstatic void sbar(ref T i) {}\n+}\n+\n+int i;\n+\n+template match(handlers...)\n+{\n+\tstatic foreach(h; handlers)\n+\t{\n+\t\t// should give the same result\n+\t\tpragma(msg, \"m       \", __traits(getParameterStorageClasses, h(i), 0));\n+\t\tpragma(msg, \"m-mixin \", __traits(getParameterStorageClasses, mixin(\"h(i)\"), 0));\n+\t}\n+\n+\tenum match = (){};\n+}\n+\n+void funcT(T)(ref T t) {}\n+\n+void main() {\n+\tint i;\n+\tbool b;\n+\tfloat f;\n+\tint[] ia;\n+\tFoo foo;\n+\tFooT!int foot;\n+\tBar bar = new Bar;\n+\tBarT!int bart = new BarT!int;\n+\n+\tref int _foo(return ref const int* p, scope int* a, out int b, lazy int c);\n+\n+\t// From SPEC_RUNNABLE_EXAMPLE_COMPILE:\n+\tint* p, a;\n+\tint _b, c;\n+\n+\tstatic assert(__traits(getParameterStorageClasses, _foo(p, a, _b, c), 1)[0] == \"scope\");\n+\tstatic assert(__traits(getParameterStorageClasses, _foo(p, a, _b, c), 2)[0] == \"out\");\n+\tstatic assert(__traits(getParameterStorageClasses, _foo(p, a, _b, c), 3)[0] == \"lazy\");\n+\n+#line 100\n+\tpragma(msg, __LINE__, \" \", __traits(getParameterStorageClasses, func(0), 0));\n+\tpragma(msg, __LINE__, \" \", __traits(getParameterStorageClasses, func(b), 0));\n+\tpragma(msg, __LINE__, \" \", __traits(getParameterStorageClasses, func(f, i), 0));\n+\tpragma(msg, __LINE__, \" \", __traits(getParameterStorageClasses, func(f, i), 1));\n+\tpragma(msg, __LINE__, \" \", __traits(getParameterStorageClasses, get(i), 0));\n+\tpragma(msg, __LINE__, \" \", __traits(getParameterStorageClasses, get(0.0), 0));\n+\tpragma(msg, __LINE__, \" \", __traits(getParameterStorageClasses, get(f), 0));\n+\tpragma(msg, __LINE__, \" \", __traits(getParameterStorageClasses, get(ia), 0));\n+\tpragma(msg, __LINE__, \" \", __traits(getParameterStorageClasses, mixin(\"get(i)\"), 0));\n+\tpragma(msg, __LINE__, \" \", __traits(getParameterStorageClasses, Foo.sfoo(i), 0));\n+\tpragma(msg, __LINE__, \" \", __traits(getParameterStorageClasses, FooT!int.sfoo(i), 0));\n+\tpragma(msg, __LINE__, \" \", __traits(getParameterStorageClasses, foo.foo(0), 0));\n+\tpragma(msg, __LINE__, \" \", __traits(getParameterStorageClasses, foo.foo(b), 0));\n+\tpragma(msg, __LINE__, \" \", __traits(getParameterStorageClasses, foot.foo(i), 0));\n+\tpragma(msg, __LINE__, \" \", __traits(getParameterStorageClasses, Bar.sbar(i), 0));\n+\tpragma(msg, __LINE__, \" \", __traits(getParameterStorageClasses, BarT!int.sbar(i), 0));\n+\tpragma(msg, __LINE__, \" \", __traits(getParameterStorageClasses, bar.bar(0), 0));\n+\tpragma(msg, __LINE__, \" \", __traits(getParameterStorageClasses, bar.bar(b), 0));\n+\tpragma(msg, __LINE__, \" \", __traits(getParameterStorageClasses, bart.bar(i), 0));\n+\tpragma(msg, __LINE__, \" \", __traits(getParameterStorageClasses, funcautoi(10), 0));\n+\tpragma(msg, __LINE__, \" \", __traits(getParameterStorageClasses, funcautoi(i), 0));\n+\tpragma(msg, __LINE__, \" \", __traits(getParameterStorageClasses, funcauto(10), 0));\n+\tpragma(msg, __LINE__, \" \", __traits(getParameterStorageClasses, funcauto(i), 0));\n+\tpragma(msg, __LINE__, \" \", __traits(getParameterStorageClasses, funcin(1), 0));\n+\tpragma(msg, __LINE__, \" \", __traits(getParameterStorageClasses, funcin(i), 0));\n+\n+\tcast(void) match!(\n+\t\tfunction(ref int i) => true,\n+\t\tdelegate(ref int i) => true,\n+\t\t(ref int i) => true,\n+\t\t(return ref int i) => &i,\n+\t\tget,\n+\t\tfuncT,\n+\t\t(int i) => true,\n+\t\tFooT!int.sfoo,\n+\t\tFoo.sfoo,\n+\t\tBarT!int.sbar,\n+\t\tBar.sbar,\n+\t\tfuncautoi,\n+\t\tfuncauto,\n+\t\tfuncin,\n+\t);\n+}"}, {"sha": "ba7a93d930cc4337f6fad5f21ebb24648fdbc6ae", "filename": "gcc/testsuite/gdc.test/compilable/test15711.d", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest15711.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest15711.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest15711.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,31 @@\n+// https://issues.dlang.org/show_bug.cgi?id=15711\n+\n+struct Quu {\n+    string val;\n+}\n+\n+string[] result = foo!(0, [Quu(['z']), Quu(\"\")]);\n+\n+template foo(size_t i, Quu[] data, string[] results = []) {\n+    static if (i < data.length) {\n+        enum def = data[i];\n+        enum foo = foo!(i+1, data, results ~ def.val);\n+    }\n+    else {\n+        enum foo = results;\n+    }\n+}\n+\n+// Run-time version already works\n+\n+string[] result_rt = foo_rt(0, [Quu(['z']), Quu(\"\")]);\n+\n+string[] foo_rt(size_t i, Quu[] data, string[] results = []) {\n+    if (i < data.length) {\n+        auto def = data[i];\n+        return foo_rt(i+1, data, results ~ def.val);\n+    }\n+    else {\n+        return results;\n+    }\n+}"}, {"sha": "833be1d8cf3fdb6dda95e49e10b1f3ef38f5277b", "filename": "gcc/testsuite/gdc.test/compilable/test16492.d", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest16492.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest16492.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest16492.d?ref=c15aa46cca0649b68613d3292cf71c7cc57ef78f", "patch": "@@ -1,87 +0,0 @@\n-// ARG_SETS: -debug; -o-; -debug -preview=dip1000\n-// https://issues.dlang.org/show_bug.cgi?id=16492\n-\n-void mayCallGC();\n-\n-void test() @nogc pure\n-{\n-    debug new int(1);\n-    debug\n-    {\n-        mayCallGC();\n-        auto b = [1, 2, 3];\n-        b ~= 4;\n-    }\n-}\n-\n-void debugSafe() @safe\n-{\n-    debug unsafeSystem();\n-    debug unsafeTemplated();\n-}\n-\n-void unsafeSystem() @system {}\n-void unsafeTemplated()() {\n-    int[] arr;\n-    auto b = arr.ptr;\n-}\n-\n-void debugSafe2() @safe\n-{\n-    char[] arr1, arr2;\n-    debug unsafeDIP1000Lifetime(arr1, arr2);\n-\n-    char* ptr;\n-    char[] arr;\n-    debug ptr = arr.ptr;\n-}\n-\n-void unsafeDIP1000Lifetime()(ref char[] p, scope char[] s)\n-{\n-    p = s;\n-}\n-\n-\n-void test2() nothrow\n-{\n-    debug throw new Exception(\"\");\n-}\n-\n-void test3() nothrow\n-{\n-    debug {\n-        foreach (_; 0 .. 10) {\n-            if (1) {\n-                throw new Exception(\"\");\n-            }\n-        }\n-    }\n-}\n-\n-void test4() nothrow\n-{\n-    debug throwException();\n-}\n-\n-void test5() nothrow\n-{\n-    debug willThrowException();\n-}\n-\n-void willThrowException()()\n-{\n-    throwException();\n-}\n-\n-void throwException()\n-{\n-    throw new Exception(\"\");\n-}\n-\n-void test6() nothrow\n-{\n-    debug\n-    {\n-        () {throw new Exception(\"\");}();\n-    }\n-}"}, {"sha": "09485a3098af34acfa04f3517f1f8d1315013894", "filename": "gcc/testsuite/gdc.test/compilable/test19482.d", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest19482.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest19482.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest19482.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,68 @@\n+// https://issues.dlang.org/show_bug.cgi?id=19482\n+\n+alias AliasSeq(T...) = T;\n+\n+extern (C++, \"cppns\")\n+@(\"asd\", 123)\n+private\n+deprecated\n+immutable\n+static foreach (i; 0 .. 1)\n+{\n+    static assert(is(typeof(i) == int));\n+    static assert(__traits(getLinkage, i) == \"D\");\n+    static assert(__traits(isDeprecated, i) == false);\n+    static assert(__traits(getAttributes, i).length == 0);\n+    static assert(__traits(getCppNamespaces, i).length == 0);\n+    static assert(__traits(getVisibility, i) == \"public\");\n+\n+    extern int x;\n+    static assert(is(typeof(x) == immutable int));\n+    static assert(__traits(getLinkage, x) == \"C++\");\n+    static assert(__traits(isDeprecated, x) == true);\n+    static assert(__traits(getAttributes, x) == AliasSeq!(\"asd\", 123));\n+    static assert(__traits(getCppNamespaces, x) == AliasSeq!(\"cppns\"));\n+    static assert(__traits(getVisibility, x) == \"private\");\n+}\n+\n+struct S\n+{\n+    @disable static foreach (j; 0 .. 1)\n+    {\n+        int y;\n+        static assert(__traits(isDisabled, j) == false);\n+        static assert(__traits(isDisabled, S.y) == true);\n+    }\n+}\n+\n+const\n+static foreach (i, v; ['a'])\n+{\n+    static assert(is(typeof(i) == size_t));\n+    static assert(is(typeof(v) == char));\n+}\n+\n+const\n+static foreach (i, s, f; Range())\n+{\n+    static assert(is(typeof(i) == int));\n+    static assert(is(typeof(s) == string));\n+    static assert(is(typeof(f) == float));\n+}\n+\n+struct Range\n+{\n+    int i;\n+    auto front()\n+    {\n+        return Tup!(int, string, float)(123, \"asd\", 3.14f);\n+    }\n+    bool empty() { return i > 0; }\n+    void popFront() { ++i; }\n+}\n+\n+struct Tup(T...)\n+{\n+    T fields;\n+    alias fields this;\n+}"}, {"sha": "02e2d8d640324cb4e3b24af3368c060fadda5c5f", "filename": "gcc/testsuite/gdc.test/compilable/test21438.d", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21438.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21438.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21438.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,15 @@\n+// https://issues.dlang.org/show_bug.cgi?id=21438\n+\n+int genGBPLookup() {\n+    static struct Table {\n+        int[1] entries;\n+    }\n+\n+    auto table = new Table;\n+    auto x = table.entries[0];\n+\n+    static assert(is(typeof(x) == int));\n+    return 0;\n+}\n+\n+enum x = genGBPLookup;"}, {"sha": "68e504bce5606822aba4088a9be7c54973bb18d8", "filename": "gcc/testsuite/gdc.test/compilable/test21794.d", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21794.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21794.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21794.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,52 @@\n+// https://issues.dlang.org/show_bug.cgi?id=21794\n+/*\n+TEST_OUTPUT:\n+---\n+0\n+0u\n+0L\n+0LU\n+0.0F\n+0.0\n+0.0L\n+---\n+*/\n+\n+bool fun(void* p) {\n+    const x = cast(ulong)p;\n+    return 1;\n+}\n+\n+static assert(fun(null));\n+\n+T fun2(T)(void* p) {\n+    const x = cast(T)p;\n+    return x;\n+}\n+\n+// These were an error before, they were returning a NullExp instead of IntegerExp/RealExp\n+\n+static assert(fun2!int(null)    == 0);\n+static assert(fun2!uint(null)   == 0);\n+static assert(fun2!long(null)   == 0);\n+static assert(fun2!ulong(null)  == 0);\n+static assert(fun2!float(null)  == 0);\n+static assert(fun2!double(null) == 0);\n+static assert(fun2!real(null)   == 0);\n+\n+// These were printing 'null' instead of the corresponding number\n+\n+const i = cast(int)null;\n+const ui = cast(uint)null;\n+const l = cast(long)null;\n+const ul = cast(ulong)null;\n+const f = cast(float)null;\n+const d = cast(double)null;\n+const r = cast(real)null;\n+pragma(msg, i);\n+pragma(msg, ui);\n+pragma(msg, l);\n+pragma(msg, ul);\n+pragma(msg, f);\n+pragma(msg, d);\n+pragma(msg, r);"}, {"sha": "e7fe2d4d12540dfa1b8e18cd6088c1d4a1c97008", "filename": "gcc/testsuite/gdc.test/compilable/test21850.d", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21850.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21850.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21850.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,35 @@\n+// https://issues.dlang.org/show_bug.cgi?id=21850\n+\n+struct Strukt2 {\n+    this(int* _block) {  }\n+}\n+\n+struct Strukt {\n+    int* block;\n+    Strukt2 foo() { return Strukt2(null); }\n+    alias foo this;\n+}\n+\n+bool wrapper(T)(ref T a, ref T b)\n+{\n+    return doesPointTo(a, b);\n+}\n+\n+void johan() pure {\n+    Strukt a;\n+    Strukt b;\n+    assert(wrapper(a, b));         // error wrapper is not pure\n+    assert(doesPointTo(a, b));     // fine\n+}\n+\n+bool doesPointTo(S, T)(S , T) {\n+    return false;\n+}\n+\n+bool doesPointTo(S)(shared S) {\n+    return false;\n+}\n+\n+bool mayPointTo(){\n+    return false;\n+}"}, {"sha": "d21812588ad18cd5776f17ddf714680eaf6bb7fe", "filename": "gcc/testsuite/gdc.test/compilable/test22214.d", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22214.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22214.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22214.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,16 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22214\n+\n+struct S\n+{\n+    struct T\n+    {\n+    }\n+}\n+\n+void main() {\n+    const S s;\n+    static if (__traits(compiles, { auto t = s.T; }))\n+    {\n+        auto t = s.T;\n+    }\n+}"}, {"sha": "d16b2f4023d551da65adc508c3be53c7890c7778", "filename": "gcc/testsuite/gdc.test/compilable/test22224.d", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22224.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22224.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22224.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,4 @@\n+// REQUIRED_ARGS: -profile -c\n+\n+import core.stdc.stdarg; \n+void error(...) { }"}, {"sha": "ef31b4badcae692f81a8a965549a6602d08ae581", "filename": "gcc/testsuite/gdc.test/compilable/test22228.d", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22228.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22228.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22228.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,11 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22228\n+// Note: fixed by reverting pull #11545\n+\n+auto f()\n+{   immutable int i;\n+    auto p = (() => &i)();\n+\n+    return 0;\n+}\n+\n+enum ctfeInvocation = f;"}, {"sha": "945dffb6b2f39e64fb7de15f4b25d43339d5d062", "filename": "gcc/testsuite/gdc.test/compilable/test22292.d", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22292.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22292.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22292.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,155 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22292\n+\n+// Original case\n+\n+class C1\n+{\n+    C1 c1;\n+    this () pure\n+    {\n+        c1 = this;\n+    }\n+}\n+immutable x = cast(immutable)r;\n+\n+auto r()\n+{\n+    C1 c1 = new C1;\n+    return c1;\n+}\n+\n+// Reference stored in another class\n+\n+template Test2()\n+{\n+    class C1\n+    {\n+        C2 c2;\n+        this () pure\n+        {\n+            C1 a = this;\n+            c2 = new C2(a);\n+        }\n+    }\n+    class C2\n+    {\n+        C1 c1;\n+        this (C1 c) pure\n+        {\n+            c1 = c;\n+        }\n+    }\n+    immutable x = cast(immutable)r;\n+\n+    auto r()\n+    {\n+        C1 c1 = new C1();\n+        return c1;\n+    }\n+}\n+\n+alias test2 = Test2!();\n+\n+// Ditto but using a struct in the middle\n+\n+template Test3()\n+{\n+    class C0\n+    {\n+        S1 s1;\n+\n+        this()\n+        {\n+            s1 = S1(this);\n+        }\n+    }\n+    struct S1\n+    {\n+        C1 c1;\n+        this (C0 c)\n+        {\n+            c1 = new C1(c);\n+        }\n+    }\n+    class C1\n+    {\n+        C0 c0;\n+        this(C0 c)\n+        {\n+            c0 = c;\n+        }\n+    }\n+    immutable x = cast(immutable)r;\n+\n+    auto r()\n+    {\n+        C0 c0 = new C0();\n+        return c0;\n+    }\n+}\n+\n+alias test3 = Test3!();\n+\n+// From https://issues.dlang.org/show_bug.cgi?id=22114\n+\n+template Test4()\n+{\n+    public class Test1(T)\n+    {\n+        private Test2!T val;\n+\n+        this()\n+        {\n+            val = new Test2!T(this);\n+        }\n+\n+        private class Test2(T)\n+        {\n+            private Test1!(T) m_source;\n+\n+            this(Test1!T source)\n+            {\n+                m_source = source;\n+            }\n+        }\n+    }\n+\n+    public class Demo\n+    {\n+        auto val = new Test1!int();\n+    }\n+}\n+\n+alias test4 = Test4!();\n+\n+// ditto\n+\n+template Test5()\n+{\n+    public @nogc class TestA(T)\n+    {\n+        private TestB!T valA;\n+        private TestB!T valB;\n+        this()\n+        {\n+            valB = valA = new TestB!T(this);\n+        }\n+\n+        private @nogc class TestB(T)\n+        {\n+            private TestA!(T) m_source;\n+\n+            this(TestA!T source)\n+            {\n+                m_source = source;\n+            }\n+        }\n+    }\n+\n+    public class Demo\n+    {\n+        auto val = new TestA!int();\n+    }\n+}\n+\n+alias test5 = Test5!();"}, {"sha": "cf8c3fc767718b78df631556b7724be9d211613e", "filename": "gcc/testsuite/gdc.test/compilable/test22388.d", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22388.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22388.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22388.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,22 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22388\n+\n+void setTimer(void delegate()) @system;\n+void setTimer(void delegate() @safe) @safe;\n+\n+void setTimer2(void delegate() @safe) @safe;\n+void setTimer2(void delegate()) @system;\n+\n+void main() @safe\n+{\n+    setTimer(() => assert(false));\n+\n+    alias lambda = () => assert(false);\n+    setTimer(lambda);\n+\n+    // Reversed order\n+\n+    setTimer2(() => assert(false));\n+\n+    alias lambda2 = () => assert(false);\n+    setTimer2(lambda2);\n+}"}, {"sha": "7e631b7e78987b99e16aa61a6c696a275e9a202d", "filename": "gcc/testsuite/gdc.test/compilable/test22410.d", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22410.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22410.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22410.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,59 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22410\n+\n+alias A(T...) = T;\n+\n+void fun0(const A!(int, string) x = A!(1, \"asdf\"))\n+{\n+    static assert(is(typeof(x) == A!(const int, const string)));\n+}\n+\n+void fun1(const A!(immutable int, string) x = A!(1, \"asdf\"))\n+{\n+    static assert(is(typeof(x) == A!(immutable int, const string)));\n+}\n+\n+void fun2(shared A!(int, string) x = A!(1, \"asdf\"))\n+{\n+    static assert(is(typeof(x) == A!(shared int, shared string)));\n+}\n+\n+void fun3(shared const A!(int, string) x = A!(1, \"asdf\"))\n+{\n+    static assert(is(typeof(x) == A!(shared const int, shared const string)));\n+}\n+\n+void fun4(inout A!(int, const string) x = A!(1, \"asdf\"))\n+{\n+    static assert(is(typeof(x) == A!(inout int, inout const string)));\n+}\n+\n+void fun5(ref const A!(int, string) x = A!(1, \"asdf\"))\n+{\n+    static assert(is(typeof(x) == A!(const int, const string)));\n+    static assert(__traits(isRef, x[0]) && __traits(isRef, x[1]));\n+}\n+\n+// Implicitly conversion is also fixed, for example:\n+// from (ulong, double) to (int, float)\n+\n+// Integral narrowing here, ulong(uint.max + 1UL) would fail.\n+void fun10(A!(uint, float) x = A!(ulong(uint.max), 3.14))\n+{\n+    static assert(is(typeof(x) == A!(uint, float)));\n+}\n+\n+void fun11(A!(int, double) x = A!(byte(1), 2.5f))\n+{\n+    static assert(is(typeof(x) == A!(int, double)));\n+}\n+\n+void fun12(A!(byte, float) x = A!(1, 'a'))\n+{\n+    static assert(is(typeof(x) == A!(byte, float)));\n+}\n+\n+A!(const int, shared char) tup = A!(1, 'a');\n+void fun13(A!(byte, float) x = tup)\n+{\n+    static assert(is(typeof(x) == A!(byte, float)));\n+}"}, {"sha": "c18d0a9b20d7df88bb4b435d6f03896147db332d", "filename": "gcc/testsuite/gdc.test/compilable/test22420.d", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22420.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22420.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22420.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,88 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22420\n+\n+struct File\n+{\n+    ~this()\n+    {\n+    }\n+    File impl()\n+    {\n+        return File.init;\n+    }\n+    alias impl this;\n+}\n+struct Variable\n+{\n+    this(File)(File) { }\n+    this(File)(File[]) { }\n+}\n+Variable wrapFunctionReturn(alias handler)(Variable params)\n+{\n+    return Variable(handler(params));\n+}\n+void registerFile()\n+{\n+    wrapFunctionReturn!((Variable) {\n+            return File.init;\n+        })(Variable.init);\n+}\n+\n+// Reduction from an 'automem' test\n+\n+struct Issue156 {}\n+\n+void test2()\n+{\n+    RefCounted!Issue156 s;\n+    auto r1 = repeat(s);\n+    zip(r1);\n+}\n+\n+struct RefCounted(RefCountedType)\n+{\n+    ~this() {}\n+    alias _impl this;\n+\n+    struct Impl {}\n+    alias ImplType = Impl;\n+\n+    private ImplType* _impl;\n+\n+}\n+template Tuple(Specs)\n+{\n+    struct Tuple\n+    {\n+        this(U)(U) {}\n+        this()(int) {}\n+    }\n+}\n+\n+template ElementType(R)\n+{\n+    static if (is(typeof(R.init) T))\n+        alias ElementType = T;\n+}\n+\n+struct Repeat(T)\n+{\n+    inout(T) front() inout {assert(0);}\n+}\n+\n+Repeat!T repeat(T)(T ) {assert(0);}\n+\n+auto zip(Ranges)(Ranges )\n+{\n+    return ZipShortest!Ranges();\n+}\n+\n+struct ZipShortest(Ranges...)\n+{\n+    Ranges ranges;\n+    alias ElementType = Tuple!(.ElementType!(Ranges[0]));\n+\n+    ElementType front()\n+    {\n+        return typeof(return)(ranges[0].front);\n+    }\n+}"}, {"sha": "902646d323bc2bd535c35ddc9c1ec5cffc742078", "filename": "gcc/testsuite/gdc.test/compilable/test22421.d", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22421.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22421.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22421.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,19 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22421\n+\n+alias AliasSeq(T...) = T;\n+\n+template staticMap(alias fun, args...)\n+{\n+    alias staticMap = AliasSeq!();\n+    static foreach(arg; args)\n+        staticMap = AliasSeq!(staticMap, fun!arg);\n+}\n+\n+template id(alias what)\n+{\n+    enum id = __traits(identifier, what);\n+}\n+\n+enum A { a }\n+\n+static assert(staticMap!(id, A.a) == AliasSeq!(\"a\"));"}, {"sha": "fd3cabeaea364774c2386aabbfed61d264c8c956", "filename": "gcc/testsuite/gdc.test/compilable/test318.d", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest318.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest318.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest318.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,19 @@\n+// LINK:\n+// PERMUTE_ARGS: -version=C_Main\n+\n+version (C_Main)\n+{\n+    // Fine, infers int\n+    extern(C) auto main(int argc, const char** argv)\n+    {\n+        return argc;\n+    }\n+}\n+else\n+{\n+    // Fine, infers void\n+    auto main()\n+    {\n+\n+    }\n+}"}, {"sha": "0e785cf21c969dfbcc61f0aca932321214faedf9", "filename": "gcc/testsuite/gdc.test/compilable/test4090.d", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest4090.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest4090.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest4090.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -12,9 +12,6 @@ void test4090a()\n         // inference + qualifier + ref\n         foreach (          ref x; arr) static assert(is(typeof(x) == int));\n         foreach (    const ref x; arr) static assert(is(typeof(x) == const int));\n-      static assert(!__traits(compiles, {\n-        foreach (immutable ref x; arr) {}\n-      }));\n \n         // with exact type + qualifier\n         foreach (          int x; arr) static assert(is(typeof(x) == int));\n@@ -24,25 +21,11 @@ void test4090a()\n         // with exact type + qualifier + ref\n         foreach (          ref int x; arr) static assert(is(typeof(x) == int));\n         foreach (    const ref int x; arr) static assert(is(typeof(x) == const int));\n-      static assert(!__traits(compiles, {\n-        foreach (immutable ref int x; arr) {}\n-      }));\n \n         // convertible type + qualifier\n         foreach (          double x; arr) static assert(is(typeof(x) == double));\n         foreach (    const double x; arr) static assert(is(typeof(x) == const double));\n         foreach (immutable double x; arr) static assert(is(typeof(x) == immutable double));\n-\n-        // convertible type + qualifier + ref\n-      static assert(!__traits(compiles, {\n-        foreach (          ref double x; arr) {}\n-      }));\n-      static assert(!__traits(compiles, {\n-        foreach (    const ref double x; arr) {}\n-      }));\n-      static assert(!__traits(compiles, {\n-        foreach (immutable ref double x; arr) {}\n-      }));\n     }\n     // for the immutable elements\n     {"}, {"sha": "aaceb7d95e144989b06451c57b3bcdca33201b03", "filename": "gcc/testsuite/gdc.test/compilable/test9766.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest9766.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest9766.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest9766.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -69,9 +69,9 @@ static assert(U9766.var4.offsetof == 40);\n \n struct TestMaxAlign\n {\n-align(1u << 31):\n+align(1u << 15):\n     ubyte a;\n     ubyte b;\n }\n \n-static assert(TestMaxAlign.b.offsetof == 2147483648u);\n+static assert(TestMaxAlign.b.offsetof == (1 << 15));"}, {"sha": "89228a9bc4ab96082872f87db15e3dd059e0a182", "filename": "gcc/testsuite/gdc.test/compilable/testcstuff3.d", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftestcstuff3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftestcstuff3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftestcstuff3.d?ref=c15aa46cca0649b68613d3292cf71c7cc57ef78f", "patch": "@@ -1,4 +0,0 @@\n-// EXTRA_FILES: imports/cstuff3.c\n-import imports.cstuff3;\n-\n-static assert(squared(4) == 16);"}, {"sha": "cc492a747fdd7507f564fbff035933904d632e59", "filename": "gcc/testsuite/gdc.test/compilable/transition_in.d", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftransition_in.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftransition_in.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftransition_in.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,26 @@\n+// REQUIRED_ARGS: -transition=in\n+/*\n+TRANSFORM_OUTPUT: remove_lines(druntime)\n+TEST_OUTPUT:\n+---\n+compilable/transition_in.d(3): Usage of 'in' on parameter\n+compilable/transition_in.d(3): Usage of 'in' on parameter\n+compilable/transition_in.d(8): Usage of 'in' on parameter\n+compilable/transition_in.d(13): Usage of 'in' on parameter\n+---\n+*/\n+#line 1\n+struct Foobar\n+{\n+    void bar (in int a, in Object c);\n+}\n+\n+version (none)\n+{\n+    void barfoo (in string arg);\n+}\n+\n+void main ()\n+{\n+    void nested (in char c) {}\n+}"}, {"sha": "6e26deb5490c7695ceca37ab1e622d98ccd69b69", "filename": "gcc/testsuite/gdc.test/compilable/zerosize.d", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fzerosize.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fzerosize.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fzerosize.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -1,12 +1,17 @@\n \n extern (C) struct S { }\n \n-static assert(S.sizeof == 0);\n-static assert(S.alignof == 1);\n+version (CRuntime_Microsoft)\n+    static assert(S.sizeof == 4);\n+else\n+    static assert(S.sizeof == 0);\n+\n+version (CRuntime_DigitalMars)\n+    static assert(S.alignof == 0);\n+else\n+    static assert(S.alignof == 1);\n \n extern (C++) struct T { }\n \n static assert(T.sizeof == 1);\n static assert(T.alignof == 1);\n-\n-"}, {"sha": "1366882edeb88055fee00731fc254e76f8a410c7", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag10327.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag10327.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag10327.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag10327.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -1,7 +1,8 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/diag10327.d(11): Error: module `test10327` is in file 'imports/test10327.d' which cannot be read\n+fail_compilation/diag10327.d(12): Error: unable to read module `test10327`\n+fail_compilation/diag10327.d(12):        Expected 'imports/test10327.d' or 'imports/test10327/package.d' in one of the following import paths:\n import path[0] = fail_compilation\n import path[1] = $p:druntime/import$\n import path[2] = $p:phobos$"}, {"sha": "2c8063a243011b95b460963689a4bf62b26ae507", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag20059.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag20059.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag20059.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag20059.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/diag20059.d(15): Error: Expected return type of `string`, not `string[]`:\n+fail_compilation/diag20059.d(15): Error: expected return type of `string`, not `string[]`:\n fail_compilation/diag20059.d(13):        Return type of `string` inferred here.\n ---\n */"}, {"sha": "ac6b33a3a9cd7d119d3c8f2c91bb1e515b39b3e2", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail20618.d", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail20618.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail20618.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail20618.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,16 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail20618.d(13): Error: in slice `a[1 .. 12]`, upper bound is greater than array length `10`\n+fail_compilation/fail20618.d(14): Error: in slice `a[4 .. 3]`, lower bound is greater than upper bound\n+fail_compilation/fail20618.d(15): Error: in slice `a[0 .. 11]`, upper bound is greater than array length `10`\n+---\n+*/\n+\n+void main()\n+{\n+    int[10] a;\n+    auto b = a[1..12];\n+    auto c = a[4..3];\n+    auto d = a[0..$ + 1];\n+}"}, {"sha": "c2bbe4d59e4d99b25d779621297a206d0494fcbd", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail21091a.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail21091a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail21091a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail21091a.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -3,7 +3,8 @@\n /*\n TEST_OUTPUT:\n ----\n-fail_compilation/fail21091a.d(15): Error: module `Ternary` is in file 'Ternary.d' which cannot be read\n+fail_compilation/fail21091a.d(16): Error: unable to read module `Ternary`\n+fail_compilation/fail21091a.d(16):        Expected 'Ternary.d' or 'Ternary/package.d' in one of the following import paths:\n import path[0] = fail_compilation\n import path[1] = $p:druntime/import$\n import path[2] = $p:phobos$"}, {"sha": "3d7d6001bd2a9fbc04844224d419676f43089b16", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail21091b.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail21091b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail21091b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail21091b.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -3,7 +3,8 @@\n /*\n TEST_OUTPUT:\n ----\n-fail_compilation/fail21091b.d(15): Error: module `Tid` is in file 'Tid.d' which cannot be read\n+fail_compilation/fail21091b.d(16): Error: unable to read module `Tid`\n+fail_compilation/fail21091b.d(16):        Expected 'Tid.d' or 'Tid/package.d' in one of the following import paths:\n import path[0] = fail_compilation\n import path[1] = $p:druntime/import$\n import path[2] = $p:phobos$"}, {"sha": "bd11832adebb54fc51dcc3e88a935d0efd2bf899", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail22084.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22084.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22084.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22084.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -18,6 +18,6 @@ struct Destructor\n \n void test()\n {\n-    auto a0 = Destructor;\n+    auto a0 = Destructor();\n     testVariadic(1, a0);\n }"}, {"sha": "c6c3b1b742b640bfb1a7298d1b088952a83ff54f", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail22151.d", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22151.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22151.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22151.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,24 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22151\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail22151.d(14): Error: function `test` is not an lvalue and cannot be modified\n+fail_compilation/fail22151.d(15): Error: function `test2` is not an lvalue and cannot be modified\n+fail_compilation/fail22151.d(18): Error: function pointed to by `fp` is not an lvalue and cannot be modified\n+fail_compilation/fail22151.d(21): Error: function pointed to by `ff` is not an lvalue and cannot be modified\n+---\n+*/\n+\n+void test()\n+{\n+    *&test = *&test;\n+    *&test2 = *&test;\n+\n+    void function() fp;\n+    *fp = *fp;\n+\n+    auto ff = &test2;\n+    *ff = *&test2;\n+}\n+\n+void test2();"}, {"sha": "3a2469f5fe10dd93ae20a35360b6af684b485501", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail22366.d", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22366.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22366.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22366.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,15 @@\n+// REQUIRED_ARGS: -dip1000\n+\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail22366.d(13): Error: scope variable `__aaval2` assigned to non-scope `aa[0]`\n+---\n+*/\n+\n+int* fun(scope int* x) @safe\n+{\n+    int*[int] aa;\n+    aa[0] = x; // should give an error\n+    return aa[0];\n+}"}, {"sha": "dee9a543b6ec188f38b04f9c296c9c20cba88f25", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail225.d", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail225.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail225.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail225.d?ref=c15aa46cca0649b68613d3292cf71c7cc57ef78f", "patch": "@@ -1,17 +0,0 @@\n-/*\n-TEST_OUTPUT:\n----\n-fail_compilation/fail225.d(15): Error: cannot implicitly convert expression `1` of type `int` to `immutable(char*)`\n-fail_compilation/fail225.d(15): Error: cannot implicitly convert expression `& ch` of type `char*` to `immutable(char*)`\n----\n-*/\n-struct Struct { \n-        char* chptr; \n-}\n-\n-void main()\n-{\n-        char ch = 'd';\n-        immutable Struct iStruct = {1, &ch};\n-}\n-"}, {"sha": "e5b1a79bb048e73e3bad08059852d2d1f9c7ee28", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail287.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail287.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail287.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail287.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail287.d(14): Error: had 299 cases which is more than 256 cases in case range\n+fail_compilation/fail287.d(14): Error: had 300 cases which is more than 257 cases in case range\n ---\n */\n "}, {"sha": "d99175e6effcde82a42fb4fd9713d0333612ad14", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail318.d", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail318.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail318.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail318.d?ref=c15aa46cca0649b68613d3292cf71c7cc57ef78f", "patch": "@@ -1,8 +0,0 @@\n-/*\n-TEST_OUTPUT:\n----\n-fail_compilation/fail318.d(8): Error: function `D main` must return `int` or `void`\n----\n-*/\n-\n-auto main() { }"}, {"sha": "efbf45bdc2e9800caa71479e876ad13fcd3979d5", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail318_b.d", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail318_b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail318_b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail318_b.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,11 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail318_b.d(8): Error: function `D main` must return `int`, `void` or `noreturn`, not `string`\n+---\n+*/\n+\n+auto main()\n+{\n+    return \"\";\n+}"}, {"sha": "05ba7f9fc0a4da496a05482addacfc24e80853bb", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail7173.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail7173.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail7173.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail7173.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail7173.d(23): Error: cannot implicitly convert expression `b1._a.opBinary(b2._a).fun()` of type `void` to `B`\n+fail_compilation/fail7173.d(23): Error: expression `b1._a.opBinary(b2._a).fun()` is `void` and has no value\n ---\n */\n struct A{"}, {"sha": "9a1c7c8ddb0eff5c709773713c052565856cfe5b", "filename": "gcc/testsuite/gdc.test/fail_compilation/foreach.d", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fforeach.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fforeach.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fforeach.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,14 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/foreach.d(12): Error: cannot declare `out` loop variable, use `ref` instead\n+fail_compilation/foreach.d(13): Error: cannot declare `out` loop variable, use `ref` instead\n+fail_compilation/foreach.d(13): Error: cannot declare `out` loop variable, use `ref` instead\n+---\n+*/\n+void main ()\n+{\n+    int[] array;\n+    foreach (out val; array) {}\n+    foreach (out idx, out val; array) {}\n+}"}, {"sha": "8bd4893b3fb96bc28f8dd3b1f8e5f29b2e4724c4", "filename": "gcc/testsuite/gdc.test/fail_compilation/foreach2.d", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fforeach2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fforeach2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fforeach2.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,22 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/foreach2.d(15): Error: argument type mismatch, `int` to `ref immutable(int)`\n+fail_compilation/foreach2.d(16): Error: argument type mismatch, `int` to `ref immutable(int)`\n+fail_compilation/foreach2.d(19): Error: argument type mismatch, `int` to `ref double`\n+fail_compilation/foreach2.d(20): Error: argument type mismatch, `int` to `ref const(double)`\n+fail_compilation/foreach2.d(21): Error: argument type mismatch, `int` to `ref immutable(double)`\n+---\n+*/\n+void test4090 ()\n+{\n+    // From https://issues.dlang.org/show_bug.cgi?id=4090\n+    int[] arr = [1,2,3];\n+    foreach (immutable ref x; arr) {}\n+    foreach (immutable ref int x; arr) {}\n+\n+    // convertible type + qualifier + ref\n+    foreach (          ref double x; arr) {}\n+    foreach (    const ref double x; arr) {}\n+    foreach (immutable ref double x; arr) {}\n+}"}, {"sha": "99fe1edf3e0e5e50bb6a205cfd27a38bf4c9e0c1", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice10212.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice10212.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice10212.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice10212.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/ice10212.d(13): Error: Expected return type of `int`, not `int function() pure nothrow @nogc @safe`:\n+fail_compilation/ice10212.d(13): Error: expected return type of `int`, not `int function() pure nothrow @nogc @safe`:\n fail_compilation/ice10212.d(13):        Return type of `int` inferred here.\n ---\n */"}, {"sha": "4616f99212a36084be272e2b1ed2863c103fcdec", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice22377.d", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice22377.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice22377.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice22377.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,8 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/ice22377.d(8): Error: Internal Compiler Error: type `string` cannot be mapped to C++\n+---\n+*/\n+\n+extern(C++) void foo(string a) {}"}, {"sha": "551933b382d242405cda3f5aefa7b04c17b6ec02", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice7782.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice7782.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice7782.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice7782.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -2,7 +2,8 @@\n EXTRA_FILES: imports/ice7782algorithm.d imports/ice7782range.d\n TEST_OUTPUT:\n ----\n-fail_compilation/ice7782.d(13): Error: module `ice7782math` is in file 'imports/ice7782range/imports/ice7782math.d' which cannot be read\n+fail_compilation/ice7782.d(14): Error: unable to read module `ice7782math`\n+fail_compilation/ice7782.d(14):        Expected 'imports/ice7782range/imports/ice7782math.d' or 'imports/ice7782range/imports/ice7782math/package.d' in one of the following import paths:\n import path[0] = fail_compilation\n import path[1] = $p:druntime/import$\n import path[2] = $p:phobos$"}, {"sha": "9dc3c8efa0693acfa4861ba62a9eeb956e7b5784", "filename": "gcc/testsuite/gdc.test/fail_compilation/imports/imp22329.d", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fimp22329.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fimp22329.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fimp22329.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,4 @@\n+void func(T)(T arg)\n+{\n+    auto a = arg + 1;\n+}"}, {"sha": "4a588b4c00d2e8660a18fa3b4a0817810537deff", "filename": "gcc/testsuite/gdc.test/fail_compilation/noreturn.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnoreturn.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnoreturn.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnoreturn.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -72,7 +72,7 @@ noreturn casting(int i)\n             return cast() n;\n         }\n     }\n-\n+    assert(false);\n }\n \n enum forceCasting0 = casting(0);"}, {"sha": "e7d28dc3aaff46da11f5820d98583e1cd506cc83", "filename": "gcc/testsuite/gdc.test/fail_compilation/noreturn2.d", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnoreturn2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnoreturn2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnoreturn2.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,90 @@\n+/*\n+REQUIRED_ARGS: -w -o-\n+\n+TEST_OUTPUT:\n+---\n+fail_compilation/noreturn2.d(18): Error: expected return type of `noreturn`, not `void`\n+---\n+\n+https://github.com/dlang/DIPs/blob/master/DIPs/accepted/DIP1034.md\n+*/\n+\n+alias noreturn = typeof(*null);\n+\n+void doStuff();\n+\n+noreturn returnVoid()\n+{\n+    return doStuff();\n+}\n+\n+\n+/+\n+TEST_OUTPUT:\n+---\n+fail_compilation/noreturn2.d(37): Error: expected return type of `int`, not `string`:\n+fail_compilation/noreturn2.d(35):        Return type of `int` inferred here.\n+---\n++/\n+\n+auto missmatch(int i)\n+{\n+    if (i < 0)\n+        return assert(false);\n+    if (i == 0)\n+        return i;\n+    if (i > 0)\n+        return \"\";\n+}\n+\n+/+\n+TEST_OUTPUT:\n+---\n+fail_compilation/noreturn2.d(50): Error: function `noreturn2.returns` is typed as `NR` but does return\n+fail_compilation/noreturn2.d(50):        `noreturn` functions must either throw, abort or loop indefinitely\n+---\n++/\n+\n+enum NR : noreturn;\n+\n+NR returns()\n+{\n+    // Fallthrough despite noreturn\n+}\n+\n+/+\n+TEST_OUTPUT:\n+---\n+fail_compilation/noreturn2.d(64): Error: cannot implicitly convert expression `1` of type `int` to `noreturn`\n+---\n++/\n+\n+noreturn returnsValue()\n+{\n+    return 1;\n+}\n+\n+/+\n+TEST_OUTPUT:\n+---\n+fail_compilation/noreturn2.d(75): Error: expected return type of `int`, not `void`\n+---\n++/\n+int returnVoid2()\n+{\n+    return doStuff();\n+}\n+\n+/+\n+TEST_OUTPUT:\n+---\n+fail_compilation/noreturn2.d(89): Error: mismatched function return type inference of `void` and `int`\n+---\n++/\n+auto returnVoid3(int i)\n+{\n+    if (i > 0)\n+        return i;\n+    else\n+        return doStuff();\n+}"}, {"sha": "43998b9f47cb2a35d03a7e2b3c1efbe052b078a0", "filename": "gcc/testsuite/gdc.test/fail_compilation/reserved_version.d", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Freserved_version.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Freserved_version.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Freserved_version.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -113,6 +113,8 @@ fail_compilation/reserved_version.d(214): Error: version identifier `CppRuntime_\n fail_compilation/reserved_version.d(215): Error: version identifier `CppRuntime_Sun` is reserved and cannot be set\n fail_compilation/reserved_version.d(216): Error: version identifier `D_PIE` is reserved and cannot be set\n fail_compilation/reserved_version.d(217): Error: version identifier `AVR` is reserved and cannot be set\n+fail_compilation/reserved_version.d(218): Error: version identifier `D_PreConditions` is reserved and cannot be set\n+fail_compilation/reserved_version.d(219): Error: version identifier `D_PostConditions` is reserved and cannot be set\n ---\n */\n \n@@ -232,6 +234,8 @@ version = CppRuntime_Microsoft;\n version = CppRuntime_Sun;\n version = D_PIE;\n version = AVR;\n+version = D_PreConditions;\n+version = D_PostConditions;\n \n // This should work though\n debug = DigitalMars;\n@@ -340,3 +344,5 @@ debug = none;\n debug = D_P16;\n debug = MSP430;\n debug = AVR;\n+debug = D_PreConditions;\n+debug = D_PostConditions;"}, {"sha": "633330908c8e6394902886c3d6371c8be5d96695", "filename": "gcc/testsuite/gdc.test/fail_compilation/reserved_version_switch.d", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Freserved_version_switch.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Freserved_version_switch.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Freserved_version_switch.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -103,6 +103,8 @@\n // REQUIRED_ARGS: -version=assert\n // REQUIRED_ARGS: -version=all\n // REQUIRED_ARGS: -version=none\n+// REQUIRED_ARGS: -version=D_PreConditions\n+// REQUIRED_ARGS: -version=D_PostConditions\n // REQUIRED_ARGS: -debug=DigitalMars\n // REQUIRED_ARGS: -debug=GNU\n // REQUIRED_ARGS: -debug=LDC\n@@ -203,6 +205,8 @@\n // REQUIRED_ARGS: -debug=assert\n // REQUIRED_ARGS: -debug=all\n // REQUIRED_ARGS: -debug=none\n+// REQUIRED_ARGS: -debug=D_PreConditions\n+// REQUIRED_ARGS: -debug=D_PostConditions\n /*\n TEST_OUTPUT:\n ---\n@@ -309,5 +313,7 @@ Error: version identifier `unittest` is reserved and cannot be set\n Error: version identifier `assert` is reserved and cannot be set\n Error: version identifier `all` is reserved and cannot be set\n Error: version identifier `none` is reserved and cannot be set\n+Error: version identifier `D_PreConditions` is reserved and cannot be set\n+Error: version identifier `D_PostConditions` is reserved and cannot be set\n ---\n */"}, {"sha": "77c49567e47e9ed244cce81f7741954da54a834e", "filename": "gcc/testsuite/gdc.test/fail_compilation/test17425.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17425.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17425.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17425.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -1,7 +1,7 @@\n /* TEST_OUTPUT:\n ---\n fail_compilation/test17425.d(24): Error: parameter index must be in range 0..4 not 4\n-fail_compilation/test17425.d(27): Error: first argument to `__traits(getParameterStorageClasses, i, 4)` is not a function\n+fail_compilation/test17425.d(27): Error: first argument to `__traits(getParameterStorageClasses, i, 4)` is not a function or a function call\n fail_compilation/test17425.d(29): Error: expression expected as second argument of `__traits(getParameterStorageClasses, foo, int)`\n fail_compilation/test17425.d(31): Error: expected 2 arguments for `getParameterStorageClasses` but had 3\n ---"}, {"sha": "7833b61a9495da8ed110ea7edf37a5a732d218ee", "filename": "gcc/testsuite/gdc.test/fail_compilation/test17868b.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17868b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17868b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17868b.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -1,9 +1,9 @@\n /*\n TEST_OUTPUT:\n ----\n+fail_compilation/test17868b.d(9): Error: pragma `crt_constructor` can only apply to a single declaration\n fail_compilation/test17868b.d(10): Error: function `test17868b.foo` must be `extern(C)` for `pragma(crt_constructor)`\n fail_compilation/test17868b.d(14): Error: function `test17868b.bar` must be `extern(C)` for `pragma(crt_constructor)`\n-fail_compilation/test17868b.d(9): Error: pragma `crt_constructor` can only apply to a single declaration\n ----\n  */\n pragma(crt_constructor):"}, {"sha": "16eb02622d8dc3433f04707dc83689b978c3b833", "filename": "gcc/testsuite/gdc.test/fail_compilation/test20998.d", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest20998.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest20998.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest20998.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,120 @@\n+// https://issues.dlang.org/show_bug.cgi?id=20998\n+/*\n+REQUIRED_ARGS: -verrors=context\n+TEST_OUTPUT:\n+---\n+fail_compilation/test20998.d(76): Error: undefined identifier `invalid`\n+X x = { invalid, 2, \"asd\" };\n+        ^\n+fail_compilation/test20998.d(76): Error: too many initializers for `X`\n+X x = { invalid, 2, \"asd\" };\n+                    ^\n+fail_compilation/test20998.d(83): Error: cannot implicitly convert expression `\"a\"` of type `string` to `int`\n+X2 x2 = { ptr: null, \"a\", ptr: 2, 444 };\n+                     ^\n+fail_compilation/test20998.d(83): Error: duplicate initializer for field `ptr`\n+X2 x2 = { ptr: null, \"a\", ptr: 2, 444 };\n+                               ^\n+fail_compilation/test20998.d(83): Error: too many initializers for `X2`\n+X2 x2 = { ptr: null, \"a\", ptr: 2, 444 };\n+                                  ^\n+fail_compilation/test20998.d(90): Error: overlapping initialization for field `ptr` and `x`\n+X3 x3 = { ptr: null, \"a\", ptr: 2, 444 };\n+               ^\n+fail_compilation/test20998.d(90): Error: cannot implicitly convert expression `\"a\"` of type `string` to `int`\n+X3 x3 = { ptr: null, \"a\", ptr: 2, 444 };\n+                     ^\n+fail_compilation/test20998.d(90): Error: duplicate initializer for field `ptr`\n+X3 x3 = { ptr: null, \"a\", ptr: 2, 444 };\n+                               ^\n+fail_compilation/test20998.d(90): Error: too many initializers for `X3`\n+X3 x3 = { ptr: null, \"a\", ptr: 2, 444 };\n+                                  ^\n+fail_compilation/test20998.d(98): Error: field `X4.ptr` cannot assign to misaligned pointers in `@safe` code\n+    X4 x4 = { ptr: null, \"a\", 444, ptr: 2, true };\n+                   ^\n+fail_compilation/test20998.d(98): Error: cannot implicitly convert expression `\"a\"` of type `string` to `int`\n+    X4 x4 = { ptr: null, \"a\", 444, ptr: 2, true };\n+                         ^\n+fail_compilation/test20998.d(98): Error: too many initializers for `X4`\n+    X4 x4 = { ptr: null, \"a\", 444, ptr: 2, true };\n+                              ^\n+fail_compilation/test20998.d(102):        called from here: `test()`\n+auto e = test();\n+             ^\n+fail_compilation/test20998.d(104): Error: cannot implicitly convert expression `1` of type `int` to `void*`\n+X2 a5 = { ptr: 1, ptr: 2, ptr: 444, ptr: 555 };\n+               ^\n+fail_compilation/test20998.d(104): Error: duplicate initializer for field `ptr`\n+X2 a5 = { ptr: 1, ptr: 2, ptr: 444, ptr: 555 };\n+                       ^\n+fail_compilation/test20998.d(104): Error: duplicate initializer for field `ptr`\n+X2 a5 = { ptr: 1, ptr: 2, ptr: 444, ptr: 555 };\n+                               ^\n+fail_compilation/test20998.d(104): Error: too many initializers for `X2`\n+X2 a5 = { ptr: 1, ptr: 2, ptr: 444, ptr: 555 };\n+                                         ^\n+fail_compilation/test20998.d(107): Error: too many initializers for `X2`\n+X2 c6 = { null, 2, true, null };\n+                         ^\n+fail_compilation/test20998.d(116): Error: cannot implicitly convert expression `1` of type `int` to `immutable(char*)`\n+    immutable Struct iStruct = {1, &ch};\n+                                ^\n+fail_compilation/test20998.d(116): Error: too many initializers for `Struct`\n+    immutable Struct iStruct = {1, &ch};\n+                                   ^\n+fail_compilation/test20998.d(120):        called from here: `test2()`\n+auto t = test2();\n+              ^\n+---\n+*/\n+\n+struct X {\n+\tvoid* ptr;\n+\tint x;\n+}\n+X x = { invalid, 2, \"asd\" };\n+\n+struct X2 {\n+\tvoid* ptr;\n+\tint x;\n+\tbool y;\n+}\n+X2 x2 = { ptr: null, \"a\", ptr: 2, 444 };\n+\n+union X3 {\n+    void* ptr;\n+    int x;\n+    bool y;\n+}\n+X3 x3 = { ptr: null, \"a\", ptr: 2, 444 };\n+\n+int test() @safe\n+{\n+    align (1) struct X4 {\n+        void* ptr;\n+        int x;\n+    }\n+    X4 x4 = { ptr: null, \"a\", 444, ptr: 2, true };\n+    return 0;\n+}\n+\n+auto e = test();\n+\n+X2 a5 = { ptr: 1, ptr: 2, ptr: 444, ptr: 555 };\n+X2 b5 = { ptr: null, y: true };\n+X2 c5 = { x: 2, true, ptr: null };\n+X2 c6 = { null, 2, true, null };\n+\n+struct Struct {\n+        char* chptr;\n+}\n+\n+int test2()\n+{\n+    char ch = 'd';\n+    immutable Struct iStruct = {1, &ch};\n+    return 0;\n+}\n+\n+auto t = test2();"}, {"sha": "b85d0c36c3fc6c95ab438eda3a936b9922e1dd58", "filename": "gcc/testsuite/gdc.test/fail_compilation/test21093.d", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21093.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21093.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21093.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,56 @@\n+// https://issues.dlang.org/show_bug.cgi?id=21093\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/test21093.d(24): Error: function `test21093.LocalTime.hasDST` does not override any function\n+fail_compilation/test21093.d(32): Error: class `test21093.LocalTime2` cannot implicitly generate a default constructor when base class `test21093.TimeZone2` is missing a default constructor\n+fail_compilation/test21093.d(44): Error: function `test21093.LocalTime3.string` does not override any function\n+fail_compilation/test21093.d(55): Error: cannot implicitly override base class method `test21093.TimeZone4.hasDST` with `test21093.LocalTime4.hasDST`; add `override` attribute\n+---\n+*/\n+\n+void fromUnixTime(immutable TimeZone tz = LocalTime()) { }\n+void fromUnixTime(immutable TimeZone2 tz = LocalTime2()) { }\n+void fromUnixTime(immutable TimeZone3 tz = LocalTime3()) { }\n+void fromUnixTime(immutable TimeZone4 tz = LocalTime4()) { }\n+\n+class TimeZone\n+{\n+}\n+\n+class LocalTime : TimeZone\n+{\n+    static immutable(LocalTime) opCall() { }\n+    override hasDST() { }\n+}\n+\n+class TimeZone2\n+{\n+    this(string) { }\n+}\n+\n+class LocalTime2 : TimeZone2\n+{\n+    static immutable(LocalTime2) opCall() { }\n+}\n+\n+class TimeZone3\n+{\n+}\n+\n+class LocalTime3 : TimeZone3\n+{\n+    static immutable(LocalTime3) opCall() { }\n+    override string () { }\n+}\n+\n+class TimeZone4\n+{\n+    bool hasDST();\n+}\n+\n+class LocalTime4 : TimeZone4\n+{\n+    static immutable(LocalTime4) opCall() { }\n+    bool hasDST() { }\n+}"}, {"sha": "6a2da1b2132bb899fa6c0448e8952d3cf1e5bc75", "filename": "gcc/testsuite/gdc.test/fail_compilation/test21380.d", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21380.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21380.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21380.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,46 @@\n+// https://issues.dlang.org/show_bug.cgi?id=21380\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/test21380.d(39): Error: partial template instance `MySerializer().serializeSinkType!int` has no value\n+fail_compilation/test21380.d(44): Error: template instance `test21380.SupportSinkTypeSer!(MySerializer!int)` error instantiating\n+---\n+*/\n+\n+template isSomeFunction(T...)\n+if (T.length == 1)\n+{\n+    static if (is(typeof(& T[0]) U : U*) && is(U == function) || is(typeof(& T[0]) U == delegate))\n+    {\n+        // T is a (nested) function symbol.\n+        enum bool isSomeFunction = true;\n+    }\n+    else static if (is(T[0] W) || is(typeof(T[0]) W))\n+    {\n+        // T is an expression or a type.  Take the type of it and examine.\n+        static if (is(W F : F*) && is(F == function))\n+            enum bool isSomeFunction = true; // function pointer\n+        else\n+            enum bool isSomeFunction = is(W == function) || is(W == delegate);\n+    }\n+    else\n+        enum bool isSomeFunction = false;\n+}\n+\n+struct MySerializer (T)\n+{\n+\tvoid serializeSinkType(T2) (scope auto ref T2 record) {}\n+}\n+\n+template SupportSinkTypeSer(SerT)\n+{\n+    /* Note: Partial template instance because it needs inference, in this case\n+       it cannot infer 'auto ref' parameter */\n+\tenum SupportSinkTypeSer = isSomeFunction!(SerT.init.serializeSinkType!int);\n+}\n+\n+int main()\n+{\n+\tenum x = SupportSinkTypeSer!(MySerializer!int);\n+\treturn 0;\n+}"}, {"sha": "6c932435b0102929dfa22ede9c3f5a8f3be6a6a5", "filename": "gcc/testsuite/gdc.test/fail_compilation/test21930.d", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21930.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21930.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21930.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,27 @@\n+// https://issues.dlang.org/show_bug.cgi?id=21930\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/test21930.d(21): Error: variable `string` is used as a type\n+fail_compilation/test21930.d(15):        variable `string` is declared here\n+fail_compilation/test21930.d(26): Error: constructor `test21930.R.this(string)` is not callable using argument types `()`\n+---\n+*/\n+\n+alias AliasSeq(T...) = T;\n+\n+alias TP(alias name) = AliasSeq!name;\n+\n+int string; // 'string' declared as a variable\n+\n+alias a = TP!(main);\n+\n+class R\n+{\n+    this(string) { } // so constructor have errors\n+}\n+\n+@system main()\n+{\n+    new R;\n+}"}, {"sha": "237f9c76667f5b38696c890fca55fb626baf6802", "filename": "gcc/testsuite/gdc.test/fail_compilation/test22329.d", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22329.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22329.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22329.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,21 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22329\n+// EXTRA_FILES: imports/imp22329.d\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/imports/imp22329.d(3): Error: no property `values` for type `test22329.Foo`\n+fail_compilation/imports/imp22329.d(3): Error: incompatible types for `(arg) + (1)`: `Foo` and `int`\n+fail_compilation/test22329.d(20): Error: template instance `imp22329.func!(Foo)` error instantiating\n+---\n+*/\n+\n+public struct Foo {\n+    private int values;\n+    alias values this;\n+}\n+\n+void main()\n+{\n+    import imports.imp22329 : func;\n+    func(Foo());\n+}"}, {"sha": "11255ff1f1b092512c1902677553075af11efbca", "filename": "gcc/testsuite/gdc.test/fail_compilation/test22361.d", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22361.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22361.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22361.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,11 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/test22361.d(11): Error: unable to read module `this_module_does_not_exist`\n+fail_compilation/test22361.d(11):        Expected 'this_module_does_not_exist.d' or 'this_module_does_not_exist/package.d' in one of the following import paths:\n+import path[0] = fail_compilation\n+import path[1] = $p:druntime/import$\n+import path[2] = $p:phobos$\n+---\n+*/\n+import this_module_does_not_exist;"}, {"sha": "9203685fdc8a45ba8446087679043eb5d00ad61d", "filename": "gcc/testsuite/gdc.test/fail_compilation/testOpApply.d", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2FtestOpApply.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2FtestOpApply.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2FtestOpApply.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,161 @@\n+/+\n+TEST_OUTPUT:\n+---\n+fail_compilation/testOpApply.d(27): Error: `testOpApply.SameAttr.opApply` called with argument types `(int delegate(int i) pure nothrow @nogc @safe)` matches both:\n+fail_compilation/testOpApply.d(13):     `testOpApply.SameAttr.opApply(int delegate(int) @system dg)`\n+and:\n+fail_compilation/testOpApply.d(18):     `testOpApply.SameAttr.opApply(int delegate(int) @system dg)`\n+---\n++/\n+\n+struct SameAttr\n+{\n+    int opApply(int delegate(int) @system dg) @system\n+    {\n+        return 0;\n+    }\n+\n+    int opApply(int delegate(int) @system dg) @safe\n+    {\n+        return 0;\n+    }\n+}\n+\n+void testSameAttr() @safe\n+{\n+    SameAttr sa;\n+    foreach (int i; sa) {}\n+}\n+\n+/+\n+TEST_OUTPUT:\n+---\n+fail_compilation/testOpApply.d(104): Error: `testOpApply.SameAttr.opApply` called with argument types `(int delegate(int i) pure nothrow @nogc @system)` matches both:\n+fail_compilation/testOpApply.d(13):     `testOpApply.SameAttr.opApply(int delegate(int) @system dg)`\n+and:\n+fail_compilation/testOpApply.d(18):     `testOpApply.SameAttr.opApply(int delegate(int) @system dg)`\n+---\n++/\n+#line 100\n+\n+void testSameAttr() @system\n+{\n+    SameAttr sa;\n+    foreach (int i; sa) {}\n+}\n+\n+/+\n+TEST_OUTPUT:\n+---\n+fail_compilation/testOpApply.d(217): Error: `sa.opApply` matches more than one declaration:\n+`fail_compilation/testOpApply.d(203)`:     `int(int delegate(int) dg)`\n+and:\n+`fail_compilation/testOpApply.d(208)`:     `int(int delegate(string) dg)`\n+fail_compilation/testOpApply.d(217): Error: cannot uniquely infer `foreach` argument types\n+---\n++/\n+#line 200\n+\n+struct DifferentTypes\n+{\n+    int opApply(int delegate(int) dg)\n+    {\n+        return 0;\n+    }\n+\n+    int opApply(int delegate(string) dg)\n+    {\n+        return 0;\n+    }\n+}\n+\n+void testDifferentTypes()\n+{\n+    DifferentTypes sa;\n+    foreach (i; sa) {}\n+}\n+\n+/+\n+TEST_OUTPUT:\n+---\n+fail_compilation/testOpApply.d(317): Error: `sa.opApply` matches more than one declaration:\n+`fail_compilation/testOpApply.d(303)`:     `int(int delegate(int) dg)`\n+and:\n+`fail_compilation/testOpApply.d(308)`:     `int(int delegate(long) dg)`\n+fail_compilation/testOpApply.d(317): Error: cannot uniquely infer `foreach` argument types\n+---\n++/\n+#line 300\n+\n+struct CovariantTypes\n+{\n+    int opApply(int delegate(int) dg)\n+    {\n+        return 0;\n+    }\n+\n+    int opApply(int delegate(long) dg)\n+    {\n+        return 0;\n+    }\n+}\n+\n+void testCovariantTypes()\n+{\n+    CovariantTypes sa;\n+    foreach (i; sa) {}\n+}\n+\n+/+\n+See https://issues.dlang.org/show_bug.cgi?id=21683\n+\n+TEST_OUTPUT:\n+---\n+fail_compilation/testOpApply.d(420): Error: `sa.opApply` matches more than one declaration:\n+`fail_compilation/testOpApply.d(404)`:     `int(int delegate(int) dg)`\n+and:\n+`fail_compilation/testOpApply.d(410)`:     `int(int delegate(ref int) dg)`\n+fail_compilation/testOpApply.d(420): Error: cannot uniquely infer `foreach` argument types\n+---\n++/\n+#line 400\n+\n+struct DifferentQualifiers\n+{\n+    int x;\n+    int opApply(int delegate(int) dg)\n+    {\n+        x = 1;\n+        return 0;\n+    }\n+\n+    int opApply(int delegate(ref int) dg)\n+    {\n+        x = 2;\n+        return 0;\n+    }\n+}\n+\n+void testDifferentQualifiers()\n+{\n+    DifferentQualifiers sa;\n+    foreach (i; sa) {}\n+}\n+\n+/+\n+TEST_OUTPUT:\n+---\n+fail_compilation/testOpApply.d(504): Error: `sa.opApply` matches more than one declaration:\n+`fail_compilation/testOpApply.d(404)`:     `int(int delegate(int) dg)`\n+and:\n+`fail_compilation/testOpApply.d(410)`:     `int(int delegate(ref int) dg)`\n+fail_compilation/testOpApply.d(504): Error: cannot uniquely infer `foreach` argument types\n+---\n++/\n+#line 500\n+\n+void testDifferentQualifiersRef()\n+{\n+    DifferentQualifiers sa;\n+    foreach (ref i; sa) {}\n+}"}, {"sha": "db5913c83899897719a5e124ae2925ae06abb428", "filename": "gcc/testsuite/gdc.test/runnable/aliasthis.d", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Faliasthis.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Faliasthis.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Faliasthis.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -2102,6 +2102,42 @@ void test16633()\n     root.populate;\n }\n \n+/***************************************************/\n+// https://issues.dlang.org/show_bug.cgi?id=13009\n+\n+struct RefCounted13009_2(T)\n+{\n+    ref T refCountedPayload()\n+    {\n+        assert(false);\n+    }\n+\n+    ref inout(T) refCountedPayload() inout\n+    {\n+        assert(false);\n+    }\n+\n+    alias refCountedPayload this;\n+}\n+\n+struct S13009_2\n+{\n+    struct Payload\n+    {\n+        int[] data;\n+    }\n+\n+    RefCounted13009_2!Payload payload;\n+    alias X = typeof(payload.data[0]);\n+\n+    void foo()\n+    {\n+        payload.data[0] = 0;\n+    }\n+}\n+\n+/***************************************************/\n+\n int main()\n {\n     test1();"}, {"sha": "1eb463ce8cc1138d4aff05d07ec01604091dca30", "filename": "gcc/testsuite/gdc.test/runnable/dhry.d", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fdhry.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fdhry.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fdhry.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -929,3 +929,19 @@ version (NetBSD)\n      return q;\n     }\n }\n+\n+version (OpenBSD)\n+{\n+    import core.sys.posix.sys.time;\n+\n+    double dtime()\n+    {\n+     double q;\n+     timeval tv;\n+\n+     gettimeofday(&tv,null);\n+     q = cast(double)tv.tv_sec + cast(double)tv.tv_usec * 1.0e-6;\n+\n+     return q;\n+    }\n+}"}, {"sha": "55864a0cf0f459a0ade6ffb3cfafe8cbced77396", "filename": "gcc/testsuite/gdc.test/runnable/fix22372.d", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ffix22372.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ffix22372.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ffix22372.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,38 @@\n+/* PERMUTE_ARGS: -O\n+ */\n+\n+// https://issues.dlang.org/show_bug.cgi?id=22104\n+\n+struct S { int a1, a2, a3; }\n+\n+version (none)\n+void throws2ndCall(ref S x);\n+else\n+{\n+void throws2ndCall(ref S x)\n+{\n+    __gshared bool b;\n+    if (b)\n+        throw new Exception(\"n == 1\");\n+    b = true;\n+}\n+}\n+\n+void main() { foo(); }\n+\n+void foo()\n+{\n+    S[] arr = [S(), S()];\n+    size_t i;\n+    try\n+    {\n+        for (i = 0; i < 2; i++)\n+            throws2ndCall(arr[i]);\n+    }\n+    catch (Exception o)\n+    {\n+        //printf(\"Exception: i = %lu\\n\", i);\n+        assert(i == 1);  // this fails\n+    }\n+}\n+"}, {"sha": "989fb2e1e908203f7241a5b7911faab0868c69ae", "filename": "gcc/testsuite/gdc.test/runnable/interpret.d", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Finterpret.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Finterpret.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Finterpret.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -3604,6 +3604,62 @@ void test21878()\n     ctfeFunc21878(); // succeeds at runtime\n }\n \n+/************************************************/\n+// https://issues.dlang.org/show_bug.cgi?id=20133\n+\n+void bar20133(ref string text)\n+{\n+    text = text[1 .. $];\n+    assert(text.length < 3);\n+    if (text.length == 2) assert(text == \"oo\");\n+    if (text.length == 1) assert(text == \"o\");\n+    if (text.length == 0) assert(text == \"\");\n+    string tcopy = text;\n+    if (tcopy.length > 0)\n+        bar20133(tcopy);\n+    assert(tcopy.length < 2);\n+    if (tcopy.length == 1) assert(tcopy == \"o\");\n+    if (tcopy.length == 0) assert(tcopy == \"\");\n+}\n+\n+void bar20133_2(ref string text)\n+{\n+    auto ptext = &text;\n+    *ptext = text[1 .. $];\n+    assert(text.length < 3);\n+    if (text.length == 2) assert(text == \"oo\");\n+    if (text.length == 1) assert(text == \"o\");\n+    if (text.length == 0) assert(text == \"\");\n+    string tcopy = text;\n+    if (tcopy.length > 0)\n+        bar20133_2(tcopy);\n+    assert(tcopy.length < 2);\n+    if (tcopy.length == 1) assert(tcopy == \"o\");\n+    if (tcopy.length == 0) assert(tcopy == \"\");\n+}\n+\n+alias fun20133 = {\n+    string input = \"foo\";\n+    bar20133(input);\n+    assert(input == \"oo\");\n+    return input;\n+};\n+\n+alias fun20133_2 = {\n+    string input = \"foo\";\n+    bar20133_2(input);\n+    assert(input == \"oo\");\n+    return input;\n+};\n+\n+void test20133()\n+{\n+    enum ctest = fun20133();\n+    enum ctest2 = fun20133_2();\n+    auto rtest = fun20133();\n+    auto rtest2 = fun20133_2();\n+}\n+\n /************************************************/\n \n int main()\n@@ -3732,6 +3788,7 @@ int main()\n     test20366();\n     test20400();\n     test21878();\n+    test20133();\n \n     printf(\"Success\\n\");\n     return 0;"}, {"sha": "1da0479d9f6eb583063a7b4355c1dde779e8f436", "filename": "gcc/testsuite/gdc.test/runnable/noreturn1.d", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fnoreturn1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fnoreturn1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fnoreturn1.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -66,9 +66,56 @@ void test2()\n \n /*****************************************/\n \n+struct BasicStruct\n+{\n+\tint firstInt;\n+\tnoreturn noRet;\n+\tlong lastLong;\n+}\n+\n+struct AlignedStruct\n+{\n+\tint firstInt;\n+\talign(16) noreturn noRet;\n+\tlong lastLong;\n+}\n+\n+void takeBasic(BasicStruct bs)\n+{\n+    assert(bs.firstInt == 13);\n+    assert(bs.lastLong == 42);\n+\n+    assert(&bs.noRet == (&bs.firstInt + 1));\n+}\n+\n+void takeAligned(AlignedStruct as)\n+{\n+    assert(as.firstInt == 99);\n+    assert(as.lastLong == 0xDEADBEEF);\n+\n+    assert(&as.noRet == &as.lastLong);\n+}\n+\n+void test3()\n+{\n+    {\n+        BasicStruct bs;\n+        bs.firstInt = 13;\n+        bs.lastLong = 42;\n+        takeBasic(bs);\n+    }\n+    {\n+        AlignedStruct as;\n+        as.firstInt = 99;\n+        as.lastLong = 0xDEADBEEF;\n+        takeAligned(as);\n+    }\n+}\n+\n int main()\n {\n     test1();\n     test2();\n+    test3();\n     return 0;\n }"}, {"sha": "1d3d362e107bf9176efaf6c86d07945f29e32aca", "filename": "gcc/testsuite/gdc.test/runnable/noreturn2.d", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fnoreturn2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fnoreturn2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fnoreturn2.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,220 @@\n+/*\n+PERMUTE_ARGS: -O -inline\n+RUN_OUTPUT:\n+---\n+getAndPrintS\n+---\n+*/\n+\n+import core.stdc.stdio;\n+import core.exception : AssertError;\n+\n+/*****************************************/\n+\n+// noreturn is inferred for functions that always throw\n+// The code must not strip the destructor when calling a noreturn function\n+\n+struct WithDtor\n+{\n+    __gshared int destroyed;\n+\n+    int num;\n+\n+    int acceptNoreturn(int a, int b, int c)\n+    {\n+        puts(\"unreachable\");\n+        return num + a + b + c;\n+    }\n+\n+    ~this()\n+    {\n+        destroyed += num;\n+    }\n+}\n+\n+noreturn doesThrow()\n+{\n+    WithDtor wd = WithDtor(1);\n+    throw new Exception(\"\");\n+}\n+\n+noreturn callDoesThrow()\n+{\n+    WithDtor wd = WithDtor(2);\n+    doesThrow();\n+}\n+\n+\n+void testDtors()\n+{\n+    try\n+    {\n+        callDoesThrow();\n+        assert(0);\n+    } catch (Exception e) {}\n+\n+    assert(WithDtor.destroyed == 3);\n+}\n+\n+/*****************************************************************************/\n+\n+/// Verifies that `func` throws a `Throwable` with `message` at `line`\n+void testAssertFailure(size_t expLine, string expMsg, void function() func, size_t callLine = __LINE__)\n+{\n+    void enforce(bool check, string error)\n+    {\n+        if (!check)\n+            throw new AssertError(error, __FILE__, callLine);\n+    }\n+\n+    bool caught;\n+    try\n+    {\n+        func();\n+    }\n+    catch (Throwable t)\n+    {\n+        // Save members because t might be overwritten by an Assertion failure below\n+        string actFile = t.file;\n+        size_t actLine = t.line;\n+        string actMsg = t.msg;\n+        caught = true;\n+\n+        scope (failure)\n+        {\n+            printf(\"\\nfile = \\\"%.*s\\\"\\nline = %zu\\nmsg = \\\"%.*s\\\"\\n\\n\",\n+                cast(int) actFile.length, actFile.ptr,\n+                actLine,\n+                cast(int) actMsg.length, actMsg.ptr\n+            );\n+            fflush(stdout);\n+        }\n+\n+        enforce(actFile == __FILE__, \"Wrong file\");\n+        enforce(actLine == expLine, \"Wrong line\");\n+        enforce(actMsg == expMsg, \"Wrong message\");\n+    }\n+\n+    enforce(caught, \"No Throwable was thrown!\");\n+}\n+\n+void testAccess()\n+{\n+    enum msg = \"Accessed expression of type `noreturn`\";\n+\n+    // FIXME: Another assertion failure in the backend trying to generate noreturn.sizeof = 0 byte assignment\n+    version (FIXME)\n+    testAssertFailure(__LINE__ + 3, msg, function noreturn()\n+    {\n+        noreturn a;\n+        noreturn b = a;\n+    });\n+\n+    if (false) // read does not assert!\n+    testAssertFailure(__LINE__ + 3, msg, function noreturn()\n+    {\n+        noreturn a;\n+        int b = a;\n+        assert(false, \"Unreachable!\"); // Statement above not detected as noreturn\n+    });\n+\n+    testAssertFailure(__LINE__ + 2, msg, function noreturn()\n+    {\n+        cast(noreturn) 1;\n+    });\n+\n+    version (FIXME)\n+    testAssertFailure(__LINE__ + 3, msg, function noreturn()\n+    {\n+        noreturn a;\n+        noreturn b = cast(noreturn) 1;\n+    });\n+\n+    if (false) // Read does not assert\n+    testAssertFailure(__LINE__ + 3, msg, function noreturn()\n+    {\n+        noreturn a;\n+        return a;\n+    });\n+\n+    if (false) // Read does not assert\n+    testAssertFailure(__LINE__ + 4, msg, function noreturn()\n+    {\n+        static void foo(noreturn) {}\n+        noreturn a;\n+        foo(a);\n+        assert(false, \"Unreachable!\"); // Ditto\n+    });\n+}\n+\n+/*****************************************/\n+\n+void testFuncCall()\n+{\n+    enum msg = \"Called abort()\";\n+    enum line = __LINE__ + 1;\n+    static noreturn abort() { assert(0, msg); }\n+\n+    // Canaries to check for side effects\n+    __gshared int countLeft, countRight;\n+\n+    scope (failure) printf(\"countLeft = %d\\ncountRight = %d\\n\", countLeft, countRight);\n+\n+\n+    // D function arguments are evaluated left to right\n+    testAssertFailure(line, msg, function()\n+    {\n+        static void acceptNoreturnD(int, int, int) { puts(\"unreachable\"); }\n+\n+        acceptNoreturnD(countLeft++, abort(), countRight++);\n+    });\n+\n+    assert(countLeft == 1);\n+    assert(countRight == 0);\n+\n+//     // C function arguments are still evaluated left to right\n+//     // Despite them being push in reverse order\n+    testAssertFailure(line, msg, function()\n+    {\n+        static extern(C) void acceptNoreturnC(int, int, int) { puts(\"unreachable\"); }\n+\n+        acceptNoreturnC(countLeft++, abort(), countRight++);\n+\n+        assert(false);\n+    });\n+\n+    assert(countLeft == 2);\n+    assert(countRight == 0);\n+\n+    WithDtor.destroyed = 0;\n+\n+    testAssertFailure(__LINE__ + 2, \"Error\", function()\n+    {\n+        static WithDtor getS() { assert(false, \"Error\"); }\n+\n+        getS().acceptNoreturn(countLeft++, abort(), countRight++);\n+    });\n+\n+    assert(countLeft == 2); // No changes\n+    assert(countRight == 0);\n+    assert(WithDtor.destroyed == 0); // No temporary to destruct\n+\n+    testAssertFailure(line, msg, function()\n+    {\n+        static WithDtor getAndPrintS() { puts(\"getAndPrintS\"); return WithDtor(1); }\n+\n+        getAndPrintS().acceptNoreturn(countLeft++, abort(), countRight++);\n+    });\n+\n+    assert(countLeft == 3);\n+    assert(countRight == 0);\n+    assert(WithDtor.destroyed == 1);\n+}\n+\n+int main()\n+{\n+    testDtors();\n+    testAccess();\n+    testFuncCall();\n+    return 0;\n+}"}, {"sha": "2cec6665a331483f507d2e1b34df8df2fa85f199", "filename": "gcc/testsuite/gdc.test/runnable/sroa13220.d", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fsroa13220.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fsroa13220.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fsroa13220.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,103 @@\n+/* REQUIRED_ARGS: -O -inline -noboundscheck\n+ */\n+// https://github.com/dlang/pull/13220\n+\n+version (D_SIMD)\n+{\n+\n+mixin template VectorOps(VectorType, ArrayType: BaseType[N], BaseType, size_t N)\n+{\n+    enum Count = N;\n+    alias Base = BaseType;\n+\n+    BaseType* ptr() return pure nothrow @nogc\n+    {\n+        return array.ptr;\n+    }\n+\n+    // Unary operators\n+    VectorType opUnary(string op)() pure nothrow @safe @nogc\n+    {\n+        VectorType res = void;\n+        mixin(\"res.array[] = \" ~ op ~ \"array[];\");\n+        return res;\n+    }\n+\n+    // Binary operators\n+    VectorType opBinary(string op)(VectorType other) pure const nothrow @safe @nogc\n+    {\n+        VectorType res = void;\n+        mixin(\"res.array[] = array[] \" ~ op ~ \" other.array[];\");\n+        return res;\n+    }\n+\n+    // Assigning a BaseType value\n+    void opAssign(BaseType e) pure nothrow @safe @nogc\n+    {\n+        array[] = e;\n+    }\n+\n+    // Assigning a static array\n+    void opAssign(ArrayType v) pure nothrow @safe @nogc\n+    {\n+        array[] = v[];\n+    }\n+\n+    void opOpAssign(string op)(VectorType other) pure nothrow @safe @nogc\n+    {\n+        mixin(\"array[] \"  ~ op ~ \"= other.array[];\");\n+    }\n+\n+    // Assigning a dyn array\n+    this(ArrayType v) pure nothrow @safe @nogc\n+    {\n+        array[] = v[];\n+    }\n+\n+    // Broadcast constructor\n+    this(BaseType x) pure nothrow @safe @nogc\n+    {\n+        array[] = x;\n+    }\n+\n+    ref inout(BaseType) opIndex(size_t i) inout pure nothrow @safe @nogc\n+    {\n+        return array[i];\n+    }\n+}\n+\n+// Note: can't be @safe with this signature\n+Vec loadUnaligned(Vec)(const(BaseType!Vec)* pvec) @trusted\n+{\n+    // Since this vector is emulated, it doesn't have alignement constraints\n+    // and as such we can just cast it.\n+    return *cast(Vec*)(pvec);\n+}\n+\n+private template BaseType(V)\n+{\n+    alias typeof( ( { V v; return v; }()).array[0]) BaseType;\n+}\n+\n+struct int4\n+{\n+    int[4] array;\n+    mixin VectorOps!(int4, int[4]);\n+}\n+\n+alias __m128i = int4;\n+}\n+\n+int main()\n+{\n+  version (D_SIMD)\n+  {\n+    int4 A = [1, 2, 3, 4];\n+    int4 ia = A;\n+    ia.ptr[2] = 5;\n+    int4 C = ia;\n+    int[4] result = [1, 2, 5, 4];\n+    assert(C.array == result);\n+  }\n+    return 0;\n+}"}, {"sha": "792757932e4be4b7d45b80dc2aae9268183c3a10", "filename": "gcc/testsuite/gdc.test/runnable/test15624.d", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest15624.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c15aa46cca0649b68613d3292cf71c7cc57ef78f/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest15624.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest15624.d?ref=c15aa46cca0649b68613d3292cf71c7cc57ef78f", "patch": "@@ -1,51 +0,0 @@\n-/* PERMUTE_ARGS:\n- */\n-\n-// https://issues.dlang.org/show_bug.cgi?id=15624\n-\n-struct Foo {\n-        int x;\n-        int opApply(int delegate(int, string, string) @safe dg) @safe {\n-                x = 1;\n-                return 0;\n-        }\n-        int opApply(int delegate(int, string, string) @system dg) @system {\n-                x = 2;\n-                return 0;\n-        }\n-}\n-\n-void testSafe() @safe {\n-        Foo foo;\n-        foreach (i, k, v; foo) {\n-        }\n-        assert(foo.x == 1);\n-}\n-\n-void testSystem() @system {\n-        Foo foo;\n-        foreach (i, k, v; foo) {\n-        }\n-        assert(foo.x == 2);\n-}\n-\n-void test() @system\n-{\n-    Foo f;\n-\n-    int dgsafe  (int x, string s, string t) @safe   { return 1; }\n-    int dgsystem(int x, string s, string t) @system { return 1; }\n-\n-    f.opApply(&dgsafe);\n-    assert(f.x == 1);\n-    f.opApply(&dgsystem);\n-    assert(f.x == 2);\n-}\n-\n-int main()\n-{\n-    testSafe();\n-    testSystem();\n-    test();\n-    return 0;\n-}"}, {"sha": "c58600f8da094ec2126c113802dc74259d2f26ab", "filename": "gcc/testsuite/gdc.test/runnable/test21039.d", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest21039.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest21039.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest21039.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,27 @@\n+// https://issues.dlang.org/show_bug.cgi?id=21039\n+\n+class Inner {}\n+\n+class Outer {\n+    Inner inner;\n+    alias inner this;\n+    this(Inner i) { inner = i; }\n+}\n+\n+void main() {\n+  auto inner = new Inner;\n+  auto outer = new Outer(new Inner);\n+\n+  // implicit cast goes through 'alias this'\n+\n+  Inner inner1 = outer;  // Already does it\n+  assert(inner1);\n+\n+  Inner[] inners = [inner, outer]; // Fixed\n+\n+  assert(inners[0], \"first element is null\");\n+  assert(inners[1], \"second element is null\");\n+\n+  Inner inner2 = 1 ? outer : inner; // Fixed\n+  assert(inner2);\n+}"}, {"sha": "78abf2ff658e22235e98e153006d1c515c4d9a9b", "filename": "gcc/testsuite/gdc.test/runnable/test22205.d", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest22205.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest22205.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest22205.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,17 @@\n+// REQUIRED_ARGS: -debug\n+\n+void main() nothrow\n+{\n+    debug\n+    {\n+        try\n+        {\n+            throw new Exception(\"2\");\n+        }\n+        catch (Exception) {}\n+        catch (Throwable)\n+        {\n+            assert(0);\n+        }\n+    }\n+}"}, {"sha": "72332a45561193b6d2a6574dbb5f3fc580ee6ba0", "filename": "gcc/testsuite/gdc.test/runnable/test22278.d", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest22278.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest22278.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest22278.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,24 @@\n+/*\n+REQUIRED_ARGS: -release\n+PERMUTE_ARGS:  -check=in=on -check=out=on\n+*/\n+\n+// https://issues.dlang.org/show_bug.cgi?id=22278\n+\n+bool resultIn;\n+bool resultOut;\n+\n+void foo22278()\n+    in { resultIn = true; }\n+    out { resultOut = true; }\n+do {}\n+\n+int main()\n+{\n+    foo22278();\n+\n+    version(D_PreConditions)  assert(resultIn);  else assert(!resultIn);\n+    version(D_PostConditions) assert(resultOut); else assert(!resultOut);\n+\n+    return 0;\n+}"}, {"sha": "7b884e5857cde1767f6bf7167dfc2725582e1ea6", "filename": "gcc/testsuite/gdc.test/runnable/testOpApply.d", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2FtestOpApply.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2FtestOpApply.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2FtestOpApply.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,142 @@\n+/* PERMUTE_ARGS:\n+ */\n+\n+// https://issues.dlang.org/show_bug.cgi?id=15624\n+\n+struct Foo {\n+        int x;\n+        int opApply(int delegate(int, string, string) @safe dg) @safe {\n+                x = 1;\n+                return 0;\n+        }\n+        int opApply(int delegate(int, string, string) @system dg) @system {\n+                x = 2;\n+                return 0;\n+        }\n+}\n+\n+void testSafe() @safe {\n+        Foo foo;\n+        foreach (i, k, v; foo) {\n+        }\n+        assert(foo.x == 1);\n+}\n+\n+void testSystem() @system {\n+        Foo foo;\n+        foreach (i, k, v; foo) {\n+        }\n+        assert(foo.x == 2);\n+}\n+\n+void test() @system\n+{\n+    Foo f;\n+\n+    int dgsafe  (int x, string s, string t) @safe   { return 1; }\n+    int dgsystem(int x, string s, string t) @system { return 1; }\n+\n+    f.opApply(&dgsafe);\n+    assert(f.x == 1);\n+    f.opApply(&dgsystem);\n+    assert(f.x == 2);\n+}\n+\n+int main()\n+{\n+    testSafe();\n+    testSystem();\n+    test();\n+    testDifferentTypes();\n+    testSameAttributes();\n+    testInverseAttributes();\n+    return 0;\n+}\n+\n+void testDifferentTypes()\n+{\n+    static struct DifferentTypes\n+    {\n+        int x;\n+        int opApply(int delegate(int) dg) @safe {\n+            x = 1;\n+            return 0;\n+        }\n+        int opApply(int delegate(long) dg) @safe {\n+            x = 2;\n+            return 0;\n+        }\n+    }\n+\n+    DifferentTypes dt;\n+    foreach (int i; dt) {}\n+    assert(dt.x == 1);\n+\n+    foreach (long i; dt) {}\n+    assert(dt.x == 2);\n+}\n+\n+void testSameAttributes()\n+{\n+    static struct SameAttributes\n+    {\n+        int x;\n+        int opApply(int delegate(int) @system dg) @safe {\n+            x = 1;\n+            return 0;\n+        }\n+        int opApply(int delegate(int) @safe dg) @safe {\n+            x = 2;\n+            return 0;\n+        }\n+    }\n+\n+    static void safe() @safe\n+    {\n+        SameAttributes sa;\n+        foreach (i; sa) {}\n+        assert(sa.x == 2);\n+    }\n+    safe();\n+\n+    static void system() @system\n+    {\n+        SameAttributes sa;\n+        foreach (i; sa) {}\n+        assert(sa.x == 1);\n+    }\n+    system();\n+}\n+\n+// Not useful but enabled by the associated patch\n+void testInverseAttributes()\n+{\n+    static struct InverseAttributes\n+    {\n+        int x;\n+        int opApply(int delegate(int) @system dg) @safe {\n+            x = 1;\n+            return 0;\n+        }\n+        int opApply(int delegate(int) @safe dg) @system {\n+            x = 2;\n+            return 0;\n+        }\n+    }\n+\n+    static void system() @system\n+    {\n+        InverseAttributes sa;\n+        foreach (i; sa) {}\n+        assert(sa.x == 1);\n+    }\n+    system();\n+\n+    static void safe() @safe\n+    {\n+        InverseAttributes sa;\n+        (() @trusted { foreach (i; sa) {} })();\n+        assert(sa.x == 2);\n+    }\n+    safe();\n+}"}, {"sha": "d6452ecb17fb1c9cf41ae0837ea3e20dc1eb1f4c", "filename": "gcc/testsuite/gdc.test/runnable/testmainb.d", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestmainb.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestmainb.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestmainb.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,15 @@\n+/*\n+Test that -main does nothing when main is already defined\n+\n+REQUIRED_ARGS: -main\n+RUN_OUTPUT:\n+---\n+Success\n+---\n+*/\n+extern(C) int printf(const char*, ...);\n+\n+void main()\n+{\n+    printf(\"Success\\n\");\n+}"}, {"sha": "1d01098964613b870bb12b4463fc5b64df647a6c", "filename": "gcc/testsuite/gdc.test/runnable/uda.d", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fuda.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fuda.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fuda.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -697,6 +697,54 @@ static if(is(typeof(foo20831) Params20831 == __parameters))\n \n /************************************************/\n \n+/************************************************/\n+// https://issues.dlang.org/show_bug.cgi?id=15804\n+\n+template test15804()\n+{\n+    alias AliasSeq(T...) = T;\n+\n+    @(42) struct Foo(D) {}\n+    auto fooFac(T)()\n+    {\n+        static assert(__traits(getAttributes, Foo) == AliasSeq!42);\n+        static assert(__traits(getAttributes, Foo!int) == AliasSeq!42);\n+        return Foo!T();\n+    }\n+\n+    auto booFac(T)()\n+    {\n+        @(43) struct Boo {}\n+        static assert(__traits(getAttributes, Boo) == AliasSeq!43);\n+        return Boo();\n+    }\n+\n+    auto barFac(T)()\n+    {\n+        @(44) struct Bar(D) {}\n+        static assert(__traits(getAttributes, Bar) == AliasSeq!44); // Fixed\n+        static assert(__traits(getAttributes, Bar!int) == AliasSeq!44);\n+        return Bar!T();\n+    }\n+\n+    auto bazFac(T)()\n+    {\n+        @(45) static struct Baz(D) {}\n+        static assert(__traits(getAttributes, Baz) == AliasSeq!45); // Fixed\n+        static assert(__traits(getAttributes, Baz!int) == AliasSeq!45);\n+        return Baz!T();\n+    }\n+\n+    auto foo = fooFac!int;\n+    auto boo = booFac!int;\n+    auto bar = barFac!int;\n+    auto baz = bazFac!int;\n+}\n+\n+alias a15804 = test15804!();\n+\n+/************************************************/\n+\n int main()\n {\n     test1();"}, {"sha": "8fd7bb2fba246254b3a01aac638dd214910e76a7", "filename": "gcc/testsuite/gdc.test/runnable/ufcs.d", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fufcs.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fufcs.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fufcs.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -196,6 +196,7 @@ void test5()\n     {\n         // f5_1 .. f5_5 are symbols which declared in module scope\n         assert(100.f5_1() == 1);\n+        assert(001.f5_1() == 1); // https://issues.dlang.org/show_bug.cgi?id=8346\n         assert(\"s\".f5_2() == 2);\n         assert(1.4.f5_3() == 3);\n         assert(100.f5_4() == 1);"}, {"sha": "ba7b25aef137a2bdbfb321d7d056d706c7c477f6", "filename": "gcc/testsuite/gdc.test/runnable_cxx/extra-files/cpp22287.cpp", "status": "added", "additions": 337, "deletions": 0, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fextra-files%2Fcpp22287.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fextra-files%2Fcpp22287.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fextra-files%2Fcpp22287.cpp?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,337 @@\n+#include <assert.h>\n+\n+class X\n+{\n+public:\n+    virtual ~X();\n+    int i;\n+};\n+\n+X::~X()\n+{\n+}\n+\n+class Y : public X\n+{\n+};\n+\n+class A\n+{\n+public:\n+    virtual ~A();\n+    virtual int f1() const;\n+\n+    int i;\n+};\n+\n+class I\n+{\n+public:\n+    virtual int f2() const = 0;\n+    virtual X *f4() = 0;\n+};\n+\n+class B : public A, public I\n+{\n+public:\n+    virtual int f1() const;\n+    virtual int f2() const;\n+    virtual int f3() const;\n+    virtual X *f4();\n+};\n+\n+class C : public B\n+{\n+public:\n+    virtual int f1() const;\n+    virtual int f2() const;\n+    virtual int f3() const;\n+    virtual Y *f4();\n+};\n+\n+#ifdef _WIN32\n+class D : public B\n+{\n+public:\n+    virtual int f1() const;\n+    virtual int f2() const;\n+    virtual int f3() const;\n+    virtual Y *f4();\n+};\n+\n+class E : public B\n+{\n+public:\n+    virtual int f1() const;\n+    virtual int f2() const;\n+    virtual int f3() const;\n+    virtual Y *f4();\n+};\n+#endif\n+\n+A::~A()\n+{\n+}\n+\n+int A::f1() const\n+{\n+    return i + 11;\n+}\n+\n+int B::f1() const\n+{\n+    return i + 21;\n+}\n+\n+int B::f2() const\n+{\n+    return i + 22;\n+}\n+\n+int B::f3() const\n+{\n+    return i + 23;\n+}\n+\n+X *B::f4()\n+{\n+    X *r = new X;\n+    r->i = i + 24;\n+    return r;\n+}\n+\n+int C::f1() const\n+{\n+    return i + 31;\n+}\n+\n+int C::f2() const\n+{\n+    return i + 32;\n+}\n+\n+int C::f3() const\n+{\n+    return i + 33;\n+}\n+\n+Y *C::f4()\n+{\n+    Y *r = new Y;\n+    r->i = i + 34;\n+    return r;\n+}\n+\n+I *createIFromCPP(char type, int i)\n+{\n+    switch (type)\n+    {\n+    case 'B':\n+    {\n+        B *b = new B();\n+        b->i = i;\n+        return b;\n+    }\n+    case 'C':\n+    {\n+        C *c = new C();\n+        c->i = i;\n+        return c;\n+    }\n+#ifdef _WIN32\n+    case 'D':\n+    {\n+        D *d = new D();\n+        d->i = i;\n+        return d;\n+    }\n+    case 'E':\n+    {\n+        E *e = new E();\n+        e->i = i;\n+        return e;\n+    }\n+#endif\n+    default:\n+        return 0;\n+    }\n+}\n+\n+B *createBFromCPP(char type, int i)\n+{\n+    switch (type)\n+    {\n+    case 'B':\n+    {\n+        B *b = new B();\n+        b->i = i;\n+        return b;\n+    }\n+    case 'C':\n+    {\n+        C *c = new C();\n+        c->i = i;\n+        return c;\n+    }\n+#ifdef _WIN32\n+    case 'D':\n+    {\n+        D *d = new D();\n+        d->i = i;\n+        return d;\n+    }\n+    case 'E':\n+    {\n+        E *e = new E();\n+        e->i = i;\n+        return e;\n+    }\n+#endif\n+    default:\n+        return 0;\n+    }\n+}\n+\n+C *createCFromCPP(int i)\n+{\n+    C *c = new C();\n+    c->i = i;\n+    return c;\n+}\n+\n+#ifdef _WIN32\n+D *createDFromCPP(int i)\n+{\n+    D *d = new D();\n+    d->i = i;\n+    return d;\n+}\n+\n+E *createEFromCPP(int i)\n+{\n+    E *e = new E();\n+    e->i = i;\n+    return e;\n+}\n+#endif\n+\n+I *createIFromD(char type, int i);\n+B *createBFromD(char type, int i);\n+C *createCFromD(int i);\n+#ifdef _WIN32\n+D *createDFromD(int i);\n+E *createEFromD(int i);\n+#endif\n+\n+void runCPPTests()\n+{\n+    {\n+        B *b = new B();\n+        b->i = 100;\n+        assert(b->f1() == 121);\n+        assert(b->f2() == 122);\n+        assert(b->f3() == 123);\n+        assert(b->f4()->i == 124);\n+    }\n+    {\n+        C *c = new C();\n+        c->i = 100;\n+        assert(c->f1() == 131);\n+        assert(c->f2() == 132);\n+        assert(c->f3() == 133);\n+        assert(c->f4()->i == 134);\n+    }\n+#ifdef _WIN32\n+    {\n+        D *d = new D();\n+        d->i = 100;\n+        assert(d->f1() == 141);\n+        assert(d->f2() == 142);\n+        assert(d->f3() == 143);\n+        assert(d->f4()->i == 144);\n+    }\n+    {\n+        E *e = new E();\n+        e->i = 100;\n+        assert(e->f1() == 151);\n+        assert(e->f2() == 152);\n+        assert(e->f3() == 153);\n+        assert(e->f4()->i == 154);\n+    }\n+#endif\n+    {\n+        I *i = createIFromD('B', 100);\n+        assert(i->f2() == 122);\n+        assert(i->f4()->i == 124);\n+    }\n+    {\n+        I *i = createIFromD('C', 100);\n+        assert(i->f2() == 132);\n+        assert(i->f4()->i == 134);\n+    }\n+#ifdef _WIN32\n+    {\n+        I *i = createIFromD('D', 100);\n+        assert(i->f2() == 142);\n+        assert(i->f4()->i == 144);\n+    }\n+    {\n+        I *i = createIFromD('E', 100);\n+        assert(i->f2() == 152);\n+        assert(i->f4()->i == 154);\n+    }\n+#endif\n+    {\n+        B *b = createBFromD('B', 100);\n+        assert(b->f1() == 121);\n+        assert(b->f2() == 122);\n+        assert(b->f3() == 123);\n+        assert(b->f4()->i == 124);\n+    }\n+    {\n+        B *b = createBFromD('C', 100);\n+        assert(b->f1() == 131);\n+        assert(b->f2() == 132);\n+        assert(b->f3() == 133);\n+        assert(b->f4()->i == 134);\n+    }\n+#ifdef _WIN32\n+    {\n+        B *b = createBFromD('D', 100);\n+        assert(b->f1() == 141);\n+        assert(b->f2() == 142);\n+        assert(b->f3() == 143);\n+        assert(b->f4()->i == 144);\n+    }\n+    {\n+        B *b = createBFromD('E', 100);\n+        assert(b->f1() == 151);\n+        assert(b->f2() == 152);\n+        assert(b->f3() == 153);\n+        assert(b->f4()->i == 154);\n+    }\n+#endif\n+    {\n+        C *c = createCFromD(100);\n+        assert(c->f1() == 131);\n+        assert(c->f2() == 132);\n+        assert(c->f3() == 133);\n+        assert(c->f4()->i == 134);\n+    }\n+#ifdef _WIN32\n+    {\n+        D *d = createDFromD(100);\n+        assert(d->f1() == 141);\n+        assert(d->f2() == 142);\n+        assert(d->f3() == 143);\n+        assert(d->f4()->i == 144);\n+    }\n+    {\n+        E *e = createEFromD(100);\n+        assert(e->f1() == 151);\n+        assert(e->f2() == 152);\n+        assert(e->f3() == 153);\n+        assert(e->f4()->i == 154);\n+    }\n+#endif\n+}"}, {"sha": "a0c74752ff1228282a822e263bc583ebcde03842", "filename": "gcc/testsuite/gdc.test/runnable_cxx/test22287.d", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Ftest22287.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Ftest22287.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Ftest22287.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,327 @@\n+// EXTRA_CPP_SOURCES: cpp22287.cpp\n+\n+extern(C++):\n+\n+class X\n+{\n+public:\n+    ~this();\n+    int i;\n+}\n+\n+class Y : X\n+{\n+}\n+\n+class A\n+{\n+    ~this();\n+    int f1() const;\n+\n+    int i;\n+}\n+\n+interface I\n+{\n+    int f2() const;\n+    X f4();\n+}\n+\n+class B : A, I\n+{\n+    override int f1() const;\n+    override int f2() const;\n+    int f3() const;\n+    override X f4();\n+}\n+\n+class C : B\n+{\n+    override int f1() const;\n+    override int f2() const;\n+    override int f3() const;\n+    override Y f4();\n+}\n+\n+version(Windows)\n+{\n+class D : B\n+{\n+    override int f1() const\n+    {\n+        return i + 41;\n+    }\n+\n+    override int f2() const\n+    {\n+        return i + 42;\n+    }\n+\n+    override int f3() const\n+    {\n+        return i + 43;\n+    }\n+\n+    override Y f4()\n+    {\n+        Y r = new Y;\n+        r.i = i + 44;\n+        return r;\n+    }\n+}\n+\n+mixin template MixinE()\n+{\n+    override int f1() const\n+    {\n+        return i + 51;\n+    }\n+\n+    override int f2() const\n+    {\n+        return i + 52;\n+    }\n+\n+    override int f3() const\n+    {\n+        return i + 53;\n+    }\n+\n+    override Y f4()\n+    {\n+        Y r = new Y;\n+        r.i = i + 54;\n+        return r;\n+    }\n+}\n+\n+class E : B\n+{\n+    mixin MixinE;\n+}\n+}\n+\n+I createIFromCPP(char type, int i);\n+B createBFromCPP(char type, int i);\n+C createCFromCPP(int i);\n+version(Windows)\n+{\n+D createDFromCPP(int i);\n+E createEFromCPP(int i);\n+}\n+\n+I createIFromD(char type, int i)\n+{\n+    switch (type)\n+    {\n+    case 'B':\n+    {\n+        B b = new B();\n+        b.i = i;\n+        return b;\n+    }\n+    case 'C':\n+    {\n+        C c = new C();\n+        c.i = i;\n+        return c;\n+    }\n+    version(Windows)\n+    {\n+    case 'D':\n+    {\n+        D d = new D();\n+        d.i = i;\n+        return d;\n+    }\n+    case 'E':\n+    {\n+        E e = new E();\n+        e.i = i;\n+        return e;\n+    }\n+    }\n+    default:\n+        return null;\n+    }\n+}\n+\n+B createBFromD(char type, int i)\n+{\n+    switch (type)\n+    {\n+    case 'B':\n+    {\n+        B b = new B();\n+        b.i = i;\n+        return b;\n+    }\n+    case 'C':\n+    {\n+        C c = new C();\n+        c.i = i;\n+        return c;\n+    }\n+    version(Windows)\n+    {\n+    case 'D':\n+    {\n+        D d = new D();\n+        d.i = i;\n+        return d;\n+    }\n+    case 'E':\n+    {\n+        E e = new E();\n+        e.i = i;\n+        return e;\n+    }\n+    }\n+    default:\n+        return null;\n+    }\n+}\n+\n+C createCFromD(int i)\n+{\n+    C c = new C();\n+    c.i = i;\n+    return c;\n+}\n+\n+version(Windows)\n+{\n+D createDFromD(int i)\n+{\n+    D d = new D();\n+    d.i = i;\n+    return d;\n+}\n+\n+E createEFromD(int i)\n+{\n+    E e = new E();\n+    e.i = i;\n+    return e;\n+}\n+}\n+\n+void runCPPTests();\n+\n+extern(D) void main()\n+{\n+    {\n+        B b = new B();\n+        b.i = 100;\n+        assert(b.f1() == 121);\n+        assert(b.f2() == 122);\n+        assert(b.f3() == 123);\n+        assert(b.f4().i == 124);\n+    }\n+    {\n+        C c = new C();\n+        c.i = 100;\n+        assert(c.f1() == 131);\n+        assert(c.f2() == 132);\n+        assert(c.f3() == 133);\n+        assert(c.f4().i == 134);\n+    }\n+    version(Windows)\n+    {\n+    {\n+        D d = new D();\n+        d.i = 100;\n+        assert(d.f1() == 141);\n+        assert(d.f2() == 142);\n+        assert(d.f3() == 143);\n+        assert(d.f4().i == 144);\n+    }\n+    {\n+        E e = new E();\n+        e.i = 100;\n+        assert(e.f1() == 151);\n+        assert(e.f2() == 152);\n+        assert(e.f3() == 153);\n+        assert(e.f4().i == 154);\n+    }\n+    }\n+    {\n+        I i = createIFromCPP('B', 100);\n+        assert(i.f2() == 122);\n+        assert(i.f4().i == 124);\n+    }\n+    {\n+        I i = createIFromCPP('C', 100);\n+        assert(i.f2() == 132);\n+        assert(i.f4().i == 134);\n+    }\n+    version(Windows)\n+    {\n+    {\n+        I i = createIFromCPP('D', 100);\n+        assert(i.f2() == 142);\n+        assert(i.f4().i == 144);\n+    }\n+    {\n+        I i = createIFromCPP('E', 100);\n+        assert(i.f2() == 152);\n+        assert(i.f4().i == 154);\n+    }\n+    }\n+    {\n+        B b = createBFromCPP('B', 100);\n+        assert(b.f1() == 121);\n+        assert(b.f2() == 122);\n+        assert(b.f3() == 123);\n+        assert(b.f4().i == 124);\n+    }\n+    {\n+        B b = createBFromCPP('C', 100);\n+        assert(b.f1() == 131);\n+        assert(b.f2() == 132);\n+        assert(b.f3() == 133);\n+        assert(b.f4().i == 134);\n+    }\n+    version(Windows)\n+    {\n+    {\n+        B b = createBFromCPP('D', 100);\n+        assert(b.f1() == 141);\n+        assert(b.f2() == 142);\n+        assert(b.f3() == 143);\n+        assert(b.f4().i == 144);\n+    }\n+    {\n+        B b = createBFromCPP('E', 100);\n+        assert(b.f1() == 151);\n+        assert(b.f2() == 152);\n+        assert(b.f3() == 153);\n+        assert(b.f4().i == 154);\n+    }\n+    }\n+    {\n+        C c = createCFromCPP(100);\n+        assert(c.f1() == 131);\n+        assert(c.f2() == 132);\n+        assert(c.f3() == 133);\n+        assert(c.f4().i == 134);\n+    }\n+    version(Windows)\n+    {\n+    {\n+        D d = createDFromCPP(100);\n+        assert(d.f1() == 141);\n+        assert(d.f2() == 142);\n+        assert(d.f3() == 143);\n+        assert(d.f4().i == 144);\n+    }\n+    {\n+        E e = createEFromCPP(100);\n+        assert(e.f1() == 151);\n+        assert(e.f2() == 152);\n+        assert(e.f3() == 153);\n+        assert(e.f4().i == 154);\n+    }\n+    }\n+    runCPPTests();\n+}"}, {"sha": "d0d3a25ad1e85b133404ea99ad3cbbff14cc6b58", "filename": "libphobos/libdruntime/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMERGE?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -1,4 +1,4 @@\n-e6caaab9d359198b760c698dcb6d253afb3f81f6\n+178c44ff362902af589603767055cfac89215652\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/druntime repository."}, {"sha": "44d4fe16be0cbe0e21824cc169240079badfac6b", "filename": "libphobos/libdruntime/Makefile.am", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.am?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -280,8 +280,9 @@ DRUNTIME_DSOURCES_LINUX = core/sys/linux/config.d \\\n \tcore/sys/linux/sys/procfs.d core/sys/linux/sys/signalfd.d \\\n \tcore/sys/linux/sys/socket.d core/sys/linux/sys/sysinfo.d \\\n \tcore/sys/linux/sys/time.d core/sys/linux/sys/xattr.d \\\n-\tcore/sys/linux/termios.d core/sys/linux/time.d \\\n-\tcore/sys/linux/timerfd.d core/sys/linux/tipc.d core/sys/linux/unistd.d\n+\tcore/sys/linux/syscalls.d core/sys/linux/termios.d \\\n+\tcore/sys/linux/time.d core/sys/linux/timerfd.d core/sys/linux/tipc.d \\\n+\tcore/sys/linux/unistd.d\n \n DRUNTIME_DSOURCES_NETBSD = core/sys/netbsd/dlfcn.d \\\n \tcore/sys/netbsd/err.d core/sys/netbsd/execinfo.d \\\n@@ -294,12 +295,13 @@ DRUNTIME_DSOURCES_NETBSD = core/sys/netbsd/dlfcn.d \\\n \n DRUNTIME_DSOURCES_OPENBSD = core/sys/openbsd/dlfcn.d \\\n \tcore/sys/openbsd/err.d core/sys/openbsd/execinfo.d \\\n-\tcore/sys/openbsd/stdlib.d core/sys/openbsd/string.d \\\n-\tcore/sys/openbsd/sys/cdefs.d core/sys/openbsd/sys/elf.d \\\n-\tcore/sys/openbsd/sys/elf32.d core/sys/openbsd/sys/elf64.d \\\n-\tcore/sys/openbsd/sys/elf_common.d core/sys/openbsd/sys/link_elf.d \\\n-\tcore/sys/openbsd/sys/mman.d core/sys/openbsd/sys/sysctl.d \\\n-\tcore/sys/openbsd/time.d core/sys/openbsd/unistd.d\n+\tcore/sys/openbsd/pthread_np.d core/sys/openbsd/stdlib.d \\\n+\tcore/sys/openbsd/string.d core/sys/openbsd/sys/cdefs.d \\\n+\tcore/sys/openbsd/sys/elf.d core/sys/openbsd/sys/elf32.d \\\n+\tcore/sys/openbsd/sys/elf64.d core/sys/openbsd/sys/elf_common.d \\\n+\tcore/sys/openbsd/sys/link_elf.d core/sys/openbsd/sys/mman.d \\\n+\tcore/sys/openbsd/sys/sysctl.d core/sys/openbsd/time.d \\\n+\tcore/sys/openbsd/unistd.d\n \n DRUNTIME_DSOURCES_POSIX = core/sys/posix/aio.d \\\n \tcore/sys/posix/arpa/inet.d core/sys/posix/config.d \\"}, {"sha": "84be8082f7a4c7644aa8b2b2e3fa0424a9695ef9", "filename": "libphobos/libdruntime/Makefile.in", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.in?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -343,10 +343,10 @@ am__objects_14 = core/sys/netbsd/dlfcn.lo core/sys/netbsd/err.lo \\\n \tcore/sys/netbsd/sys/sysctl.lo core/sys/netbsd/time.lo\n @DRUNTIME_OS_NETBSD_TRUE@am__objects_15 = $(am__objects_14)\n am__objects_16 = core/sys/openbsd/dlfcn.lo core/sys/openbsd/err.lo \\\n-\tcore/sys/openbsd/execinfo.lo core/sys/openbsd/stdlib.lo \\\n-\tcore/sys/openbsd/string.lo core/sys/openbsd/sys/cdefs.lo \\\n-\tcore/sys/openbsd/sys/elf.lo core/sys/openbsd/sys/elf32.lo \\\n-\tcore/sys/openbsd/sys/elf64.lo \\\n+\tcore/sys/openbsd/execinfo.lo core/sys/openbsd/pthread_np.lo \\\n+\tcore/sys/openbsd/stdlib.lo core/sys/openbsd/string.lo \\\n+\tcore/sys/openbsd/sys/cdefs.lo core/sys/openbsd/sys/elf.lo \\\n+\tcore/sys/openbsd/sys/elf32.lo core/sys/openbsd/sys/elf64.lo \\\n \tcore/sys/openbsd/sys/elf_common.lo \\\n \tcore/sys/openbsd/sys/link_elf.lo core/sys/openbsd/sys/mman.lo \\\n \tcore/sys/openbsd/sys/sysctl.lo core/sys/openbsd/time.lo \\\n@@ -367,9 +367,9 @@ am__objects_18 = core/sys/linux/config.lo core/sys/linux/dlfcn.lo \\\n \tcore/sys/linux/sys/procfs.lo core/sys/linux/sys/signalfd.lo \\\n \tcore/sys/linux/sys/socket.lo core/sys/linux/sys/sysinfo.lo \\\n \tcore/sys/linux/sys/time.lo core/sys/linux/sys/xattr.lo \\\n-\tcore/sys/linux/termios.lo core/sys/linux/time.lo \\\n-\tcore/sys/linux/timerfd.lo core/sys/linux/tipc.lo \\\n-\tcore/sys/linux/unistd.lo\n+\tcore/sys/linux/syscalls.lo core/sys/linux/termios.lo \\\n+\tcore/sys/linux/time.lo core/sys/linux/timerfd.lo \\\n+\tcore/sys/linux/tipc.lo core/sys/linux/unistd.lo\n @DRUNTIME_OS_LINUX_TRUE@am__objects_19 = $(am__objects_18)\n am__objects_20 = core/sys/windows/accctrl.lo \\\n \tcore/sys/windows/aclapi.lo core/sys/windows/aclui.lo \\\n@@ -944,8 +944,9 @@ DRUNTIME_DSOURCES_LINUX = core/sys/linux/config.d \\\n \tcore/sys/linux/sys/procfs.d core/sys/linux/sys/signalfd.d \\\n \tcore/sys/linux/sys/socket.d core/sys/linux/sys/sysinfo.d \\\n \tcore/sys/linux/sys/time.d core/sys/linux/sys/xattr.d \\\n-\tcore/sys/linux/termios.d core/sys/linux/time.d \\\n-\tcore/sys/linux/timerfd.d core/sys/linux/tipc.d core/sys/linux/unistd.d\n+\tcore/sys/linux/syscalls.d core/sys/linux/termios.d \\\n+\tcore/sys/linux/time.d core/sys/linux/timerfd.d core/sys/linux/tipc.d \\\n+\tcore/sys/linux/unistd.d\n \n DRUNTIME_DSOURCES_NETBSD = core/sys/netbsd/dlfcn.d \\\n \tcore/sys/netbsd/err.d core/sys/netbsd/execinfo.d \\\n@@ -958,12 +959,13 @@ DRUNTIME_DSOURCES_NETBSD = core/sys/netbsd/dlfcn.d \\\n \n DRUNTIME_DSOURCES_OPENBSD = core/sys/openbsd/dlfcn.d \\\n \tcore/sys/openbsd/err.d core/sys/openbsd/execinfo.d \\\n-\tcore/sys/openbsd/stdlib.d core/sys/openbsd/string.d \\\n-\tcore/sys/openbsd/sys/cdefs.d core/sys/openbsd/sys/elf.d \\\n-\tcore/sys/openbsd/sys/elf32.d core/sys/openbsd/sys/elf64.d \\\n-\tcore/sys/openbsd/sys/elf_common.d core/sys/openbsd/sys/link_elf.d \\\n-\tcore/sys/openbsd/sys/mman.d core/sys/openbsd/sys/sysctl.d \\\n-\tcore/sys/openbsd/time.d core/sys/openbsd/unistd.d\n+\tcore/sys/openbsd/pthread_np.d core/sys/openbsd/stdlib.d \\\n+\tcore/sys/openbsd/string.d core/sys/openbsd/sys/cdefs.d \\\n+\tcore/sys/openbsd/sys/elf.d core/sys/openbsd/sys/elf32.d \\\n+\tcore/sys/openbsd/sys/elf64.d core/sys/openbsd/sys/elf_common.d \\\n+\tcore/sys/openbsd/sys/link_elf.d core/sys/openbsd/sys/mman.d \\\n+\tcore/sys/openbsd/sys/sysctl.d core/sys/openbsd/time.d \\\n+\tcore/sys/openbsd/unistd.d\n \n DRUNTIME_DSOURCES_POSIX = core/sys/posix/aio.d \\\n \tcore/sys/posix/arpa/inet.d core/sys/posix/config.d \\\n@@ -1616,6 +1618,7 @@ core/sys/openbsd/$(am__dirstamp):\n core/sys/openbsd/dlfcn.lo: core/sys/openbsd/$(am__dirstamp)\n core/sys/openbsd/err.lo: core/sys/openbsd/$(am__dirstamp)\n core/sys/openbsd/execinfo.lo: core/sys/openbsd/$(am__dirstamp)\n+core/sys/openbsd/pthread_np.lo: core/sys/openbsd/$(am__dirstamp)\n core/sys/openbsd/stdlib.lo: core/sys/openbsd/$(am__dirstamp)\n core/sys/openbsd/string.lo: core/sys/openbsd/$(am__dirstamp)\n core/sys/openbsd/sys/$(am__dirstamp):\n@@ -1672,6 +1675,7 @@ core/sys/linux/sys/socket.lo: core/sys/linux/sys/$(am__dirstamp)\n core/sys/linux/sys/sysinfo.lo: core/sys/linux/sys/$(am__dirstamp)\n core/sys/linux/sys/time.lo: core/sys/linux/sys/$(am__dirstamp)\n core/sys/linux/sys/xattr.lo: core/sys/linux/sys/$(am__dirstamp)\n+core/sys/linux/syscalls.lo: core/sys/linux/$(am__dirstamp)\n core/sys/linux/termios.lo: core/sys/linux/$(am__dirstamp)\n core/sys/linux/time.lo: core/sys/linux/$(am__dirstamp)\n core/sys/linux/timerfd.lo: core/sys/linux/$(am__dirstamp)"}, {"sha": "33ca0ddc7bd64fff667d54974389adbf48d5567b", "filename": "libphobos/libdruntime/core/demangle.d", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fdemangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fdemangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fdemangle.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -346,6 +346,13 @@ pure @safe:\n     }\n \n \n+    void popFront(int i)\n+    {\n+        while (i--)\n+            popFront();\n+    }\n+\n+\n     void match( char val )\n     {\n         test( val );\n@@ -636,6 +643,7 @@ pure @safe:\n         TypeDelegate\n         TypeNone\n         TypeVoid\n+        TypeNoreturn\n         TypeByte\n         TypeUbyte\n         TypeShort\n@@ -715,6 +723,9 @@ pure @safe:\n     TypeVoid:\n         v\n \n+    TypeNoreturn\n+        Nn\n+\n     TypeByte:\n         g\n \n@@ -873,6 +884,10 @@ pure @safe:\n             popFront();\n             switch ( front )\n             {\n+            case 'n': // Noreturn\n+                popFront();\n+                put(\"noreturn\");\n+                return dst[beg .. len];\n             case 'g': // Wild (Ng Type)\n                 popFront();\n                 // TODO: Anything needed here?\n@@ -1164,9 +1179,11 @@ pure @safe:\n             case 'g':\n             case 'h':\n             case 'k':\n+            case 'n':\n                 // NOTE: The inout parameter type is represented as \"Ng\".\n                 //       The vector parameter type is represented as \"Nh\".\n                 //       The return parameter type is represented as \"Nk\".\n+                //       The noreturn parameter type is represented as \"Nn\".\n                 //       These make it look like a FuncAttr, but infact\n                 //       if we see these, then we know we're really in\n                 //       the parameter list.  Rewind and break.\n@@ -1217,6 +1234,59 @@ pure @safe:\n                 break;\n             }\n             putComma(n);\n+\n+            /* Do special return, scope, ref, out combinations\n+             */\n+            int npops;\n+            if ( 'M' == front && peek(1) == 'N' && peek(2) == 'k')\n+            {\n+                const c3 = peek(3);\n+                if (c3 == 'J')\n+                {\n+                    put(\"scope return out \");   // MNkJ\n+                    npops = 4;\n+                }\n+                else if (c3 == 'K')\n+                {\n+                    put(\"scope return ref \");   // MNkK\n+                    npops = 4;\n+                }\n+            }\n+            else if ('N' == front && peek(1) == 'k')\n+            {\n+                const c2 = peek(2);\n+                if (c2 == 'J')\n+                {\n+                    put(\"return out \");         // NkJ\n+                    npops = 3;\n+                }\n+                else if (c2 == 'K')\n+                {\n+                    put(\"return ref \");         // NkK\n+                    npops = 3;\n+                }\n+                else if (c2 == 'M')\n+                {\n+                    const c3 = peek(3);\n+                    if (c3 == 'J')\n+                    {\n+                        put(\"return scope out \");       // NkMJ\n+                        npops = 4;\n+                    }\n+                    else if (c3 == 'K')\n+                    {\n+                        put(\"return scope ref \");       // NkMK\n+                        npops = 4;\n+                    }\n+                    else\n+                    {\n+                        put(\"return scope \");           // NkM\n+                        npops = 3;\n+                    }\n+                }\n+            }\n+            popFront(npops);\n+\n             if ( 'M' == front )\n             {\n                 popFront();\n@@ -2558,6 +2628,15 @@ else\n          `nothrow @trusted ulong std.algorithm.iteration.FilterResult!(std.typecons.Tuple!(int, \"a\", int, \"b\", int, \"c\").`\n         ~`Tuple.rename!([0:\"c\", 2:\"a\"]).rename().__lambda1, int[]).FilterResult.__xtoHash(ref const(std.algorithm.iteration.`\n         ~`FilterResult!(std.typecons.Tuple!(int, \"a\", int, \"b\", int, \"c\").Tuple.rename!([0:\"c\", 2:\"a\"]).rename().__lambda1, int[]).FilterResult))`],\n+\n+        [\"_D4test4rrs1FKPiZv\",    \"void test.rrs1(ref int*)\"],\n+        [\"_D4test4rrs1FMNkJPiZv\", \"void test.rrs1(scope return out int*)\"],\n+        [\"_D4test4rrs1FMNkKPiZv\", \"void test.rrs1(scope return ref int*)\"],\n+        [\"_D4test4rrs1FNkJPiZv\",  \"void test.rrs1(return out int*)\"],\n+        [\"_D4test4rrs1FNkKPiZv\",  \"void test.rrs1(return ref int*)\"],\n+        [\"_D4test4rrs1FNkMJPiZv\", \"void test.rrs1(return scope out int*)\"],\n+        [\"_D4test4rrs1FNkMKPiZv\", \"void test.rrs1(return scope ref int*)\"],\n+        [\"_D4test4rrs1FNkMPiZv\",  \"void test.rrs1(return scope int*)\"],\n     ];\n \n \n@@ -2621,6 +2700,25 @@ unittest\n     assert(s.demangle == expected);\n }\n \n+// https://issues.dlang.org/show_bug.cgi?id=22235\n+unittest\n+{\n+    enum parent = __MODULE__ ~ '.' ~ __traits(identifier, __traits(parent, {}));\n+\n+    static noreturn abort() { assert(false); }\n+    assert(demangle(abort.mangleof) == \"pure nothrow @nogc @safe noreturn \" ~ parent ~ \"().abort()\");\n+\n+    static void accept(noreturn) {}\n+    assert(demangle(accept.mangleof) == \"pure nothrow @nogc @safe void \" ~ parent ~ \"().accept(noreturn)\");\n+\n+    static void templ(T)(T, T) {}\n+    assert(demangle(templ!noreturn.mangleof) == \"pure nothrow @nogc @safe void \" ~ parent ~ \"().templ!(noreturn).templ(noreturn, noreturn)\");\n+\n+    static struct S(T) {}\n+    static void aggr(S!noreturn) { assert(0); }\n+    assert(demangle(aggr.mangleof) == \"pure nothrow @nogc @safe void \" ~ parent ~ \"().aggr(\" ~ parent ~ \"().S!(noreturn).S)\");\n+}\n+\n /*\n  *\n  */"}, {"sha": "a69286607737d7b01f1b671827548d33b02a1815", "filename": "libphobos/libdruntime/core/exception.d", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fexception.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fexception.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fexception.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -97,7 +97,7 @@ class ArrayIndexError : RangeError\n         this.length = length;\n \n         // Constructing the message is a bit clumsy:\n-        // It's essentially `printf(\"index [%zu] exceeds array of length [%zu]\", index, length)`,\n+        // It's essentially `printf(\"index [%zu] is out of bounds for array of length [%zu]\", index, length)`,\n         // but even `snprintf` isn't `pure`.\n         // Also string concatenation isn't `@nogc`, and casting to/from immutable isn't `@safe`\n         import core.internal.string : unsignedToTempString;\n@@ -106,8 +106,7 @@ class ArrayIndexError : RangeError\n         char[] sink = buf[];\n         sink.rangeMsgPut(\"index [\");\n         sink.rangeMsgPut(unsignedToTempString!10(index, tmpBuf));\n-        sink.rangeMsgPut(\"]\");\n-        sink.rangeMsgPut(\" exceeds array of length \");\n+        sink.rangeMsgPut(\"] is out of bounds for array of length \");\n         sink.rangeMsgPut(unsignedToTempString!10(length, tmpBuf));\n         this.msgBuf = buf;\n         super(msgBuf[0..$-sink.length], file, line, next);\n@@ -116,7 +115,7 @@ class ArrayIndexError : RangeError\n \n @safe pure unittest\n {\n-    assert(new ArrayIndexError(900, 700).msg == \"index [900] exceeds array of length 700\");\n+    assert(new ArrayIndexError(900, 700).msg == \"index [900] is out of bounds for array of length 700\");\n     // Ensure msg buffer doesn't overflow on large numbers\n     assert(new ArrayIndexError(size_t.max, size_t.max-1).msg);\n }\n@@ -836,12 +835,24 @@ extern (C)\n         onArraySliceError(lower, upper, length, file[0 .. strlen(file)], line);\n     }\n \n+    /// ditto\n+    void _d_arraybounds_slice(string file, uint line, size_t lower, size_t upper, size_t length)\n+    {\n+        onArraySliceError(lower, upper, length, file, line);\n+    }\n+\n     /// Called when an out of range array index is accessed\n     void _d_arraybounds_indexp(immutable(char*) file, uint line, size_t index, size_t length)\n     {\n         import core.stdc.string : strlen;\n         onArrayIndexError(index, length, file[0 .. strlen(file)], line);\n     }\n+\n+    /// ditto\n+    void _d_arraybounds_index(string file, uint line, size_t index, size_t length)\n+    {\n+        onArrayIndexError(index, length, file, line);\n+    }\n }\n \n // TLS storage shared for all errors, chaining might create circular reference"}, {"sha": "9c8223767e1cef77e543ffbaff3458d512d573c4", "filename": "libphobos/libdruntime/core/internal/array/construction.d", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fconstruction.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fconstruction.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fconstruction.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -9,44 +9,50 @@\n */\n module core.internal.array.construction;\n \n+import core.internal.traits : Unqual;\n+\n /**\n  * Does array initialization (not assignment) from another array of the same element type.\n  * Params:\n- *  to = what array to initialize\n  *  from = what data the array should be initialized with\n  * Returns:\n- *  The constructed `to`\n+ *  The created and initialized array `to`\n  * Bugs:\n  *  This function template was ported from a much older runtime hook that bypassed safety,\n  *  purity, and throwabilty checks. To prevent breaking existing code, this function template\n  *  is temporarily declared `@trusted` until the implementation can be brought up to modern D expectations.\n  */\n-Tarr _d_arrayctor(Tarr : T[], T)(return scope Tarr to, scope Tarr from) @trusted\n+Tarr1 _d_arrayctor(Tarr1 : T1[], Tarr2 : T2[], T1, T2)(scope Tarr2 from) @trusted\n+    if (is(Unqual!T1 == Unqual!T2))\n {\n     pragma(inline, false);\n-    import core.internal.traits : hasElaborateCopyConstructor, Unqual;\n+    import core.internal.traits : hasElaborateCopyConstructor;\n     import core.lifetime : copyEmplace;\n     import core.stdc.string : memcpy;\n-    debug(PRINTF) import core.stdc.stdio;\n+    import core.stdc.stdint : uintptr_t;\n+    debug(PRINTF) import core.stdc.stdio : printf;\n+\n+    debug(PRINTF) printf(\"_d_arrayctor(to = %p,%d, from = %p,%d) size = %d\\n\", from.ptr, from.length, to.ptr, to.length, T1.tsize);\n+\n+    Tarr1 to = void;\n+\n+    void[] vFrom = (cast(void*)from.ptr)[0..from.length];\n+    void[] vTo = (cast(void*)to.ptr)[0..to.length];\n \n     // Force `enforceRawArraysConformable` to be `pure`\n-    void enforceRawArraysConformable(const char[] action, const size_t elementSize, const void[] a1, const void[] a2, in bool allowOverlap = false) @trusted\n+    void enforceRawArraysConformable(const char[] action, const size_t elementSize,\n+        const void[] a1, const void[] a2) @trusted\n     {\n-        import core.internal.util.array : enforceRawArraysConformable;\n+        import core.internal.util.array : enforceRawArraysConformableNogc;\n \n-        alias Type = void function(const char[] action, const size_t elementSize, const void[] a1, const void[] a2, in bool allowOverlap = false) pure nothrow;\n-        (cast(Type)&enforceRawArraysConformable)(action, elementSize, a1, a2, allowOverlap);\n+        alias Type = void function(const char[] action, const size_t elementSize,\n+            const void[] a1, const void[] a2, in bool allowOverlap = false) @nogc pure nothrow;\n+        (cast(Type)&enforceRawArraysConformableNogc)(action, elementSize, a1, a2, false);\n     }\n \n-    debug(PRINTF) printf(\"_d_arrayctor(to = %p,%d, from = %p,%d) size = %d\\n\", from.ptr, from.length, to.ptr, to.length, T.tsize);\n-\n-    auto element_size = T.sizeof;\n-\n-    void[] vFrom = (cast(void*)from.ptr)[0..from.length];\n-    void[] vTo = (cast(void*)to.ptr)[0..to.length];\n-    enforceRawArraysConformable(\"initialization\", element_size, vFrom, vTo, false);\n+    enforceRawArraysConformable(\"initialization\", T1.sizeof, vFrom, vTo);\n \n-    static if (hasElaborateCopyConstructor!T)\n+    static if (hasElaborateCopyConstructor!T1)\n     {\n         size_t i;\n         try\n@@ -60,7 +66,7 @@ Tarr _d_arrayctor(Tarr : T[], T)(return scope Tarr to, scope Tarr from) @trusted\n             */\n             while (i--)\n             {\n-                auto elem = cast(Unqual!T*)&to[i];\n+                auto elem = cast(Unqual!T1*)&to[i];\n                 destroy(*elem);\n             }\n \n@@ -70,7 +76,7 @@ Tarr _d_arrayctor(Tarr : T[], T)(return scope Tarr to, scope Tarr from) @trusted\n     else\n     {\n         // blit all elements at once\n-        memcpy(cast(void*) to.ptr, from.ptr, to.length * T.sizeof);\n+        memcpy(cast(void*) to.ptr, from.ptr, to.length * T1.sizeof);\n     }\n \n     return to;\n@@ -88,7 +94,7 @@ Tarr _d_arrayctor(Tarr : T[], T)(return scope Tarr to, scope Tarr from) @trusted\n \n     S[4] arr1;\n     S[4] arr2 = [S(0), S(1), S(2), S(3)];\n-    _d_arrayctor(arr1[], arr2[]);\n+    arr1 = _d_arrayctor!(typeof(arr1))(arr2[]);\n \n     assert(counter == 4);\n     assert(arr1 == arr2);\n@@ -111,7 +117,7 @@ Tarr _d_arrayctor(Tarr : T[], T)(return scope Tarr to, scope Tarr from) @trusted\n \n     S[4] arr1;\n     S[4] arr2 = [S(0), S(1), S(2), S(3)];\n-    _d_arrayctor(arr1[], arr2[]);\n+    arr1 = _d_arrayctor!(typeof(arr1))(arr2[]);\n \n     assert(counter == 4);\n     assert(arr1 == arr2);\n@@ -137,7 +143,7 @@ Tarr _d_arrayctor(Tarr : T[], T)(return scope Tarr to, scope Tarr from) @trusted\n     {\n         Throw[4] a;\n         Throw[4] b = [Throw(1), Throw(2), Throw(3), Throw(4)];\n-        _d_arrayctor(a[], b[]);\n+        a = _d_arrayctor!(typeof(a))(b[]);\n     }\n     catch (Exception)\n     {\n@@ -162,7 +168,7 @@ Tarr _d_arrayctor(Tarr : T[], T)(return scope Tarr to, scope Tarr from) @trusted\n     {\n         NoThrow[4] a;\n         NoThrow[4] b = [NoThrow(1), NoThrow(2), NoThrow(3), NoThrow(4)];\n-        _d_arrayctor(a[], b[]);\n+        a = _d_arrayctor!(typeof(a))(b[]);\n     }\n     catch (Exception)\n     {\n@@ -186,7 +192,6 @@ Tarr _d_arrayctor(Tarr : T[], T)(return scope Tarr to, scope Tarr from) @trusted\n void _d_arraysetctor(Tarr : T[], T)(scope Tarr p, scope ref T value) @trusted\n {\n     pragma(inline, false);\n-    import core.internal.traits : Unqual;\n     import core.lifetime : copyEmplace;\n \n     size_t i;\n@@ -269,7 +274,7 @@ void _d_arraysetctor(Tarr : T[], T)(scope Tarr p, scope ref T value) @trusted\n     {\n         Throw[4] a;\n         Throw[4] b = [Throw(1), Throw(2), Throw(3), Throw(4)];\n-        _d_arrayctor(a[], b[]);\n+        a = _d_arrayctor!(typeof(a))(b[]);\n     }\n     catch (Exception)\n     {"}, {"sha": "5daab89a3876a777a7e798e0d8374d46f9e88a83", "filename": "libphobos/libdruntime/core/internal/atomic.d", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fatomic.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fatomic.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fatomic.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -104,7 +104,7 @@ version (DigitalMars)\n                             pop RBX;\n                             ret;\n                         }\n-                    }, SrcPtr, RetPtr));\n+                    }, [SrcPtr, RetPtr]));\n                 }\n                 else\n                 {\n@@ -139,7 +139,7 @@ version (DigitalMars)\n                         mov %0, src;\n                         lock; cmpxchg [%0], %1;\n                     }\n-                }, SrcReg, ZeroReg, ResReg));\n+                }, [SrcReg, ZeroReg, ResReg]));\n             }\n             else version (D_InlineAsm_X86_64)\n             {\n@@ -159,7 +159,7 @@ version (DigitalMars)\n                         lock; cmpxchg [%0], %1;\n                         ret;\n                     }\n-                }, SrcReg, ZeroReg, ResReg));\n+                }, [SrcReg, ZeroReg, ResReg]));\n             }\n         }\n         else\n@@ -252,7 +252,7 @@ version (DigitalMars)\n                     mov %0, dest;\n                     lock; xadd[%0], %1;\n                 }\n-            }, DestReg, ValReg));\n+            }, [DestReg, ValReg]));\n         }\n         else version (D_InlineAsm_X86_64)\n         {\n@@ -276,7 +276,7 @@ version (DigitalMars)\n     ?2                mov %2, %1;\n                     ret;\n                 }\n-            }, DestReg, ValReg, ResReg));\n+            }, [DestReg, ValReg, ResReg]));\n         }\n         else\n             static assert (false, \"Unsupported architecture.\");\n@@ -305,7 +305,7 @@ version (DigitalMars)\n                     mov %0, dest;\n                     xchg [%0], %1;\n                 }\n-            }, DestReg, ValReg));\n+            }, [DestReg, ValReg]));\n         }\n         else version (D_InlineAsm_X86_64)\n         {\n@@ -329,7 +329,7 @@ version (DigitalMars)\n     ?2                mov %2, %1;\n                     ret;\n                 }\n-            }, DestReg, ValReg, ResReg));\n+            }, [DestReg, ValReg, ResReg]));\n         }\n         else\n             static assert (false, \"Unsupported architecture.\");\n@@ -362,7 +362,7 @@ version (DigitalMars)\n                         setz AL;\n                         pop %1;\n                     }\n-                }, DestAddr, CmpAddr, Val, Cmp));\n+                }, [DestAddr, CmpAddr, Val, Cmp]));\n             }\n             else static if (T.sizeof == 8)\n             {\n@@ -421,7 +421,7 @@ version (DigitalMars)\n                         xor AL, AL;\n                         ret;\n                     }\n-                }, DestAddr, CmpAddr, Val, Res));\n+                }, [DestAddr, CmpAddr, Val, Res]));\n             }\n             else\n             {\n@@ -500,7 +500,7 @@ version (DigitalMars)\n                         lock; cmpxchg [%0], %2;\n                         setz AL;\n                     }\n-                }, DestAddr, Cmp, Val));\n+                }, [DestAddr, Cmp, Val]));\n             }\n             else static if (T.sizeof == 8)\n             {\n@@ -551,7 +551,7 @@ version (DigitalMars)\n                         setz AL;\n                         ret;\n                     }\n-                }, DestAddr, Cmp, Val, AXReg));\n+                }, [DestAddr, Cmp, Val, AXReg]));\n             }\n             else\n             {\n@@ -1094,7 +1094,7 @@ template needsStoreBarrier( MemoryOrder ms )\n }\n \n // this is a helper to build asm blocks\n-string simpleFormat(string format, string[] args...)\n+string simpleFormat(string format, scope string[] args)\n {\n     string result;\n     outer: while (format.length)"}, {"sha": "2c51b8641ae1373c585ff2f592424a998e05bf89", "filename": "libphobos/libdruntime/core/internal/dassert.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fdassert.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fdassert.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fdassert.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -191,7 +191,7 @@ private string miniFormat(V)(const scope ref V v)\n         }\n \n         // Fall back to a simple cast - we're violating the type system anyways\n-        return miniFormat(__ctfe ? cast(const T) v : *cast(const T*) &v);\n+        return miniFormat(*cast(const T*) &v);\n     }\n     // Format enum members using their name\n     else static if (is(V BaseType == enum))"}, {"sha": "a731d6f7ae429247dbc6ede8e2f6204fbdfc4192", "filename": "libphobos/libdruntime/core/internal/gc/impl/conservative/gc.d", "status": "modified", "additions": 250, "deletions": 29, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fgc%2Fimpl%2Fconservative%2Fgc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fgc%2Fimpl%2Fconservative%2Fgc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fgc%2Fimpl%2Fconservative%2Fgc.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -150,14 +150,24 @@ class ConservativeGC : GC\n     static bool _inFinalizer;\n     __gshared bool isPrecise = false;\n \n-    // lock GC, throw InvalidMemoryOperationError on recursive locking during finalization\n+    /*\n+     * Lock the GC.\n+     *\n+     * Throws: InvalidMemoryOperationError on recursive locking during finalization.\n+     */\n     static void lockNR() @nogc nothrow\n     {\n         if (_inFinalizer)\n             onInvalidMemoryOperationError();\n         gcLock.lock();\n     }\n \n+    /*\n+     * Initialize the GC based on command line configuration.\n+     *\n+     * Throws:\n+     *  OutOfMemoryError if failed to initialize GC due to not enough memory.\n+     */\n     this()\n     {\n         //config is assumed to have already been initialized\n@@ -194,6 +204,10 @@ class ConservativeGC : GC\n     }\n \n \n+    /**\n+     * Enables the GC if disable() was previously called. Must be called\n+     * for each time disable was called in order to enable the GC again.\n+     */\n     void enable()\n     {\n         static void go(Gcx* gcx) nothrow\n@@ -205,6 +219,9 @@ class ConservativeGC : GC\n     }\n \n \n+    /**\n+     * Disable the GC. The GC may still run if it deems necessary.\n+     */\n     void disable()\n     {\n         static void go(Gcx* gcx) nothrow\n@@ -216,6 +233,13 @@ class ConservativeGC : GC\n \n     debug (GC_RECURSIVE_LOCK) static bool lockedOnThisThread;\n \n+    /**\n+     * Run a function inside a lock/unlock set.\n+     *\n+     * Params:\n+     *  func = The function to run.\n+     *  args = The function arguments.\n+     */\n     auto runLocked(alias func, Args...)(auto ref Args args)\n     {\n         debug(PROFILE_API) immutable tm = (config.profile > 1 ? currTime.ticks : 0);\n@@ -248,7 +272,17 @@ class ConservativeGC : GC\n             return res;\n     }\n \n-\n+    /**\n+     * Run a function in an lock/unlock set that keeps track of\n+     * how much time was spend inside this function (in ticks)\n+     * and how many times this fuction was called.\n+     *\n+     * Params:\n+     *  func = The function to run.\n+     *  time = The variable keeping track of the time (in ticks).\n+     *  count = The variable keeping track of how many times this fuction was called.\n+     *  args = The function arguments.\n+     */\n     auto runLocked(alias func, alias time, alias count, Args...)(auto ref Args args)\n     {\n         debug(PROFILE_API) immutable tm = (config.profile > 1 ? currTime.ticks : 0);\n@@ -287,6 +321,17 @@ class ConservativeGC : GC\n     }\n \n \n+    /**\n+     * Returns a bit field representing all block attributes set for the memory\n+     * referenced by p.\n+     *\n+     * Params:\n+     *  p = A pointer to the base of a valid memory block or to null.\n+     *\n+     * Returns:\n+     *  A bit field containing any bits set for the memory block referenced by\n+     *  p or zero on error.\n+     */\n     uint getAttr(void* p) nothrow\n     {\n         if (!p)\n@@ -314,7 +359,20 @@ class ConservativeGC : GC\n         return runLocked!(go, otherTime, numOthers)(gcx, p);\n     }\n \n-\n+    /**\n+     * Sets the specified bits for the memory references by p.\n+     *\n+     * If p was not allocated by the GC, points inside a block, or is null, no\n+     * action will be taken.\n+     *\n+     * Params:\n+     *  p = A pointer to the base of a valid memory block or to null.\n+     *  mask = A bit field containing any bits to set for this memory block.\n+     *\n+     * Returns:\n+     *  The result of a call to getAttr after the specified bits have been\n+     *  set.\n+     */\n     uint setAttr(void* p, uint mask) nothrow\n     {\n         if (!p)\n@@ -344,6 +402,20 @@ class ConservativeGC : GC\n     }\n \n \n+    /**\n+     * Clears the specified bits for the memory references by p.\n+     *\n+     * If p was not allocated by the GC, points inside a block, or is null, no\n+     * action will be taken.\n+     *\n+     * Params:\n+     *  p = A pointer to the base of a valid memory block or to null.\n+     *  mask = A bit field containing any bits to clear for this memory block.\n+     *\n+     * Returns:\n+     *  The result of a call to getAttr after the specified bits have been\n+     *  cleared\n+     */\n     uint clrAttr(void* p, uint mask) nothrow\n     {\n         if (!p)\n@@ -372,8 +444,21 @@ class ConservativeGC : GC\n         return runLocked!(go, otherTime, numOthers)(gcx, p, mask);\n     }\n \n-\n-    void *malloc(size_t size, uint bits, const TypeInfo ti) nothrow\n+    /**\n+     * Requests an aligned block of managed memory from the garbage collector.\n+     *\n+     * Params:\n+     *  size = The desired allocation size in bytes.\n+     *  bits = A bitmask of the attributes to set on this block.\n+     *  ti = TypeInfo to describe the memory.\n+     *\n+     * Returns:\n+     *  A reference to the allocated memory or null if no memory was requested.\n+     *\n+     * Throws:\n+     *  OutOfMemoryError on allocation failure\n+     */\n+    void *malloc(size_t size, uint bits = 0, const TypeInfo ti = null) nothrow\n     {\n         if (!size)\n         {\n@@ -394,7 +479,7 @@ class ConservativeGC : GC\n \n \n     //\n-    //\n+    // Implementation for malloc and calloc.\n     //\n     private void *mallocNoSync(size_t size, uint bits, ref size_t alloc_size, const TypeInfo ti = null) nothrow\n     {\n@@ -423,7 +508,6 @@ class ConservativeGC : GC\n         return p;\n     }\n \n-\n     BlkInfo qalloc( size_t size, uint bits, const scope TypeInfo ti) nothrow\n     {\n \n@@ -446,7 +530,22 @@ class ConservativeGC : GC\n     }\n \n \n-    void *calloc(size_t size, uint bits, const TypeInfo ti) nothrow\n+    /**\n+     * Requests an aligned block of managed memory from the garbage collector,\n+     * which is initialized with all bits set to zero.\n+     *\n+     * Params:\n+     *  size = The desired allocation size in bytes.\n+     *  bits = A bitmask of the attributes to set on this block.\n+     *  ti = TypeInfo to describe the memory.\n+     *\n+     * Returns:\n+     *  A reference to the allocated memory or null if no memory was requested.\n+     *\n+     * Throws:\n+     *  OutOfMemoryError on allocation failure.\n+     */\n+    void *calloc(size_t size, uint bits = 0, const TypeInfo ti = null) nothrow\n     {\n         if (!size)\n         {\n@@ -466,8 +565,27 @@ class ConservativeGC : GC\n         return p;\n     }\n \n-\n-    void *realloc(void *p, size_t size, uint bits, const TypeInfo ti) nothrow\n+    /**\n+     * Request that the GC reallocate a block of memory, attempting to adjust\n+     * the size in place if possible. If size is 0, the memory will be freed.\n+     *\n+     * If p was not allocated by the GC, points inside a block, or is null, no\n+     * action will be taken.\n+     *\n+     * Params:\n+     *  p = A pointer to the root of a valid memory block or to null.\n+     *  size = The desired allocation size in bytes.\n+     *  bits = A bitmask of the attributes to set on this block.\n+     *  ti = TypeInfo to describe the memory.\n+     *\n+     * Returns:\n+     *  A reference to the allocated memory on success or null if size is\n+     *  zero.\n+     *\n+     * Throws:\n+     *  OutOfMemoryError on allocation failure.\n+     */\n+    void *realloc(void *p, size_t size, uint bits = 0, const TypeInfo ti = null) nothrow\n     {\n         size_t localAllocSize = void;\n         auto oldp = p;\n@@ -483,6 +601,8 @@ class ConservativeGC : GC\n     }\n \n \n+    //\n+    // The implementation of realloc.\n     //\n     // bits will be set to the resulting bits of the new block\n     //\n@@ -624,7 +744,7 @@ class ConservativeGC : GC\n \n \n     //\n-    //\n+    // Implementation of extend.\n     //\n     private size_t extendNoSync(void* p, size_t minsize, size_t maxsize, const TypeInfo ti = null) nothrow\n     in\n@@ -678,6 +798,16 @@ class ConservativeGC : GC\n     }\n \n \n+    /**\n+     * Requests that at least size bytes of memory be obtained from the operating\n+     * system and marked as free.\n+     *\n+     * Params:\n+     *  size = The desired size in bytes.\n+     *\n+     * Returns:\n+     *  The actual number of bytes reserved or zero on error.\n+     */\n     size_t reserve(size_t size) nothrow\n     {\n         if (!size)\n@@ -690,7 +820,7 @@ class ConservativeGC : GC\n \n \n     //\n-    //\n+    // Implementation of reserve\n     //\n     private size_t reserveNoSync(size_t size) nothrow\n     {\n@@ -701,7 +831,16 @@ class ConservativeGC : GC\n     }\n \n \n-    void free(void *p) nothrow @nogc\n+    /**\n+     * Deallocates the memory referenced by p.\n+     *\n+     * If p was not allocated by the GC, points inside a block, is null, or\n+     * if free is called from a finalizer, no action will be taken.\n+     *\n+     * Params:\n+     *  p = A pointer to the root of a valid memory block or to null.\n+     */\n+    void free(void *p) nothrow\n     {\n         if (!p || _inFinalizer)\n         {\n@@ -713,7 +852,7 @@ class ConservativeGC : GC\n \n \n     //\n-    //\n+    // Implementation of free.\n     //\n     private void freeNoSync(void *p) nothrow @nogc\n     {\n@@ -792,7 +931,18 @@ class ConservativeGC : GC\n     }\n \n \n-    void* addrOf(void *p) nothrow @nogc\n+    /**\n+     * Determine the base address of the block containing p.  If p is not a gc\n+     * allocated pointer, return null.\n+     *\n+     * Params:\n+     *  p = A pointer to the root or the interior of a valid memory block or to\n+     *      null.\n+     *\n+     * Returns:\n+     *  The base address of the memory block referenced by p or null on error.\n+     */\n+    void* addrOf(void *p) nothrow\n     {\n         if (!p)\n         {\n@@ -804,7 +954,7 @@ class ConservativeGC : GC\n \n \n     //\n-    //\n+    // Implementation of addrOf.\n     //\n     void* addrOfNoSync(void *p) nothrow @nogc\n     {\n@@ -820,7 +970,17 @@ class ConservativeGC : GC\n     }\n \n \n-    size_t sizeOf(void *p) nothrow @nogc\n+    /**\n+     * Determine the allocated size of pointer p.  If p is an interior pointer\n+     * or not a gc allocated pointer, return 0.\n+     *\n+     * Params:\n+     *  p = A pointer to the root of a valid memory block or to null.\n+     *\n+     * Returns:\n+     *  The size in bytes of the memory block referenced by p or zero on error.\n+     */\n+    size_t sizeOf(void *p) nothrow\n     {\n         if (!p)\n         {\n@@ -832,7 +992,7 @@ class ConservativeGC : GC\n \n \n     //\n-    //\n+    // Implementation of sizeOf.\n     //\n     private size_t sizeOfNoSync(void *p) nothrow @nogc\n     {\n@@ -852,6 +1012,18 @@ class ConservativeGC : GC\n     }\n \n \n+    /**\n+     * Determine the base address of the block containing p.  If p is not a gc\n+     * allocated pointer, return null.\n+     *\n+     * Params:\n+     *  p = A pointer to the root or the interior of a valid memory block or to\n+     *      null.\n+     *\n+     * Returns:\n+     *  Information regarding the memory block referenced by p or BlkInfo.init\n+     *  on error.\n+     */\n     BlkInfo query(void *p) nothrow\n     {\n         if (!p)\n@@ -864,7 +1036,7 @@ class ConservativeGC : GC\n     }\n \n     //\n-    //\n+    // Implementation of query\n     //\n     BlkInfo queryNoSync(void *p) nothrow\n     {\n@@ -884,10 +1056,14 @@ class ConservativeGC : GC\n \n \n     /**\n-     * Verify that pointer p:\n-     *  1) belongs to this memory pool\n-     *  2) points to the start of an allocated piece of memory\n-     *  3) is not on a free list\n+     * Performs certain checks on a pointer. These checks will cause asserts to\n+     * fail unless the following conditions are met:\n+     *  1) The poiinter belongs to this memory pool.\n+     *  2) The pointer points to the start of an allocated piece of memory.\n+     *  3) The pointer is not on a free list.\n+     *\n+     * Params:\n+     *  p = The pointer to be checked.\n      */\n     void check(void *p) nothrow\n     {\n@@ -901,7 +1077,7 @@ class ConservativeGC : GC\n \n \n     //\n-    //\n+    // Implementation of check\n     //\n     private void checkNoSync(void *p) nothrow\n     {\n@@ -939,6 +1115,12 @@ class ConservativeGC : GC\n     }\n \n \n+    /**\n+     * Add p to list of roots. If p is null, no operation is performed.\n+     *\n+     * Params:\n+     *  p = A pointer into a GC-managed memory block or null.\n+     */\n     void addRoot(void *p) nothrow @nogc\n     {\n         if (!p)\n@@ -950,6 +1132,13 @@ class ConservativeGC : GC\n     }\n \n \n+    /**\n+     * Remove p from list of roots. If p is null or is not a value\n+     * previously passed to addRoot() then no operation is performed.\n+     *\n+     * Params:\n+     *  p = A pointer into a GC-managed memory block or null.\n+     */\n     void removeRoot(void *p) nothrow @nogc\n     {\n         if (!p)\n@@ -960,13 +1149,23 @@ class ConservativeGC : GC\n         gcx.removeRoot(p);\n     }\n \n-\n+    /**\n+     * Returns an iterator allowing roots to be traversed via a foreach loop.\n+     */\n     @property RootIterator rootIter() @nogc\n     {\n         return &gcx.rootsApply;\n     }\n \n \n+    /**\n+     * Add range to scan for roots. If p is null or sz is 0, no operation is performed.\n+     *\n+     * Params:\n+     *  p  = A pointer to a valid memory address or to null.\n+     *  sz = The size in bytes of the block to add.\n+     *  ti = TypeInfo to describe the memory.\n+     */\n     void addRange(void *p, size_t sz, const TypeInfo ti = null) nothrow @nogc\n     {\n         if (!p || !sz)\n@@ -978,6 +1177,14 @@ class ConservativeGC : GC\n     }\n \n \n+    /**\n+     * Remove range from list of ranges. If p is null or does not represent\n+     * a value previously passed to addRange() then no operation is\n+     * performed.\n+     *\n+     * Params:\n+     *  p  = A pointer to a valid memory address or to null.\n+     */\n     void removeRange(void *p) nothrow @nogc\n     {\n         if (!p)\n@@ -989,12 +1196,21 @@ class ConservativeGC : GC\n     }\n \n \n+    /**\n+     * Returns an iterator allowing ranges to be traversed via a foreach loop.\n+     */\n     @property RangeIterator rangeIter() @nogc\n     {\n         return &gcx.rangesApply;\n     }\n \n \n+    /**\n+     * Run all finalizers in the code segment.\n+     *\n+     * Params:\n+     *  segment = address range of a code segment\n+     */\n     void runFinalizers(const scope void[] segment) nothrow\n     {\n         static void go(Gcx* gcx, const scope void[] segment) nothrow\n@@ -1024,8 +1240,10 @@ class ConservativeGC : GC\n \n \n     /**\n-     * Do full garbage collection.\n-     * Return number of pages free'd.\n+     * Begins a full collection, scanning all stack segments for roots.\n+     *\n+     * Returns:\n+     *  The number of pages freed.\n      */\n     size_t fullCollect() nothrow\n     {\n@@ -1054,7 +1272,7 @@ class ConservativeGC : GC\n \n \n     /**\n-     * do full garbage collection ignoring roots\n+     * Begins a full collection while ignoring all stack segments for roots.\n      */\n     void fullCollectNoStack() nothrow\n     {\n@@ -1068,6 +1286,9 @@ class ConservativeGC : GC\n     }\n \n \n+    /**\n+     * Minimize free space usage.\n+     */\n     void minimize() nothrow\n     {\n         static void go(Gcx* gcx) nothrow\n@@ -1109,7 +1330,7 @@ class ConservativeGC : GC\n \n \n     //\n-    //\n+    // Implementation of getStats\n     //\n     private void getStatsNoSync(out core.memory.GC.Stats stats) nothrow\n     {"}, {"sha": "64f12033c95a185a298b788459348aab423797fa", "filename": "libphobos/libdruntime/core/internal/gc/os.d", "status": "modified", "additions": 18, "deletions": 26, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fgc%2Fos.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fgc%2Fos.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fgc%2Fos.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -213,46 +213,38 @@ else\n    Returns:\n        true if memory is scarce\n */\n-// TOOD: get virtual mem sizes and current usage from OS\n+// TODO: get virtual mem sizes and current usage from OS\n // TODO: compare current RSS and avail. physical memory\n-version (Windows)\n+bool isLowOnMem(size_t mapped) nothrow @nogc\n {\n-    bool isLowOnMem(size_t mapped) nothrow @nogc\n+    version (Windows)\n     {\n-        version (D_LP64)\n+        import core.sys.windows.winbase : GlobalMemoryStatusEx, MEMORYSTATUSEX;\n+\n+        MEMORYSTATUSEX stat;\n+        stat.dwLength = stat.sizeof;\n+        const success = GlobalMemoryStatusEx(&stat) != 0;\n+        assert(success, \"GlobalMemoryStatusEx() failed\");\n+        if (!success)\n             return false;\n-        else\n-        {\n-            import core.sys.windows.winbase : GlobalMemoryStatus, MEMORYSTATUS;\n-            MEMORYSTATUS stat;\n-            GlobalMemoryStatus(&stat);\n-            // Less than 5 % of virtual address space available\n-            return stat.dwAvailVirtual < stat.dwTotalVirtual / 20;\n-        }\n+\n+        // dwMemoryLoad is the 'approximate percentage of physical memory that is in use'\n+        // https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/ns-sysinfoapi-memorystatusex\n+        const percentPhysicalRAM = stat.ullTotalPhys / 100;\n+        return (stat.dwMemoryLoad >= 95 && mapped > percentPhysicalRAM)\n+            || (stat.dwMemoryLoad >= 90 && mapped > 10 * percentPhysicalRAM);\n     }\n-}\n-else version (Darwin)\n-{\n-    bool isLowOnMem(size_t mapped) nothrow @nogc\n+    else\n     {\n         enum GB = 2 ^^ 30;\n         version (D_LP64)\n             return false;\n-        else\n+        else version (Darwin)\n         {\n             // 80 % of available 4GB is used for GC (excluding malloc and mmap)\n             enum size_t limit = 4UL * GB * 8 / 10;\n             return mapped > limit;\n         }\n-    }\n-}\n-else\n-{\n-    bool isLowOnMem(size_t mapped) nothrow @nogc\n-    {\n-        enum GB = 2 ^^ 30;\n-        version (D_LP64)\n-            return false;\n         else\n         {\n             // be conservative and assume 3GB"}, {"sha": "ef9f1e525c0022ca9cbb4b98b4182243b6443099", "filename": "libphobos/libdruntime/core/internal/hash.d", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fhash.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fhash.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fhash.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -646,13 +646,8 @@ size_t hashOf(T)(T aa) if (!is(T == enum) && __traits(isAssociativeArray, T))\n     size_t h = 0;\n \n     // The computed hash is independent of the foreach traversal order.\n-    foreach (key, ref val; aa)\n-    {\n-        size_t[2] hpair;\n-        hpair[0] = key.hashOf();\n-        hpair[1] = val.hashOf();\n-        h += hpair.hashOf();\n-    }\n+    foreach (ref key, ref val; aa)\n+        h += hashOf(hashOf(val), hashOf(key));\n     return h;\n }\n "}, {"sha": "99204432374e2d5329955062940db697f94d64dd", "filename": "libphobos/libdruntime/core/internal/parseoptions.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fparseoptions.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fparseoptions.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fparseoptions.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n * Copyright: Copyright Digital Mars 2017\n * License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n *\n-* Source: $(DRUNTIMESRC src/core/internal/parseoptions.d)\n+* Source: $(DRUNTIMESRC core/internal/parseoptions.d)\n */\n \n module core.internal.parseoptions;"}, {"sha": "60d9be3ac9bb1c7356af16c05378c07ff13f5f16", "filename": "libphobos/libdruntime/core/internal/traits.d", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Finternal%2Ftraits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Finternal%2Ftraits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Ftraits.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -14,7 +14,7 @@ template Fields(T)\n {\n     static if (is(T == struct) || is(T == union))\n         alias Fields = typeof(T.tupleof[0 .. $ - __traits(isNested, T)]);\n-    else static if (is(T == class))\n+    else static if (is(T == class) || is(T == interface))\n         alias Fields = typeof(T.tupleof);\n     else\n         alias Fields = AliasSeq!T;\n@@ -326,7 +326,7 @@ template hasElaborateAssign(S)\n template hasIndirections(T)\n {\n     static if (is(T == struct) || is(T == union))\n-        enum hasIndirections = anySatisfy!(.hasIndirections, Fields!T);\n+        enum hasIndirections = anySatisfy!(.hasIndirections, typeof(T.tupleof));\n     else static if (is(T == E[N], E, size_t N))\n         enum hasIndirections = T.sizeof && is(E == void) ? true : hasIndirections!(BaseElemOf!E);\n     else static if (isFunctionPointer!T)\n@@ -367,6 +367,10 @@ unittest\n     static assert( hasUnsharedIndirections!(Foo*));\n     static assert(!hasUnsharedIndirections!(shared(Foo)*));\n     static assert(!hasUnsharedIndirections!(immutable(Foo)*));\n+\n+    int local;\n+    struct HasContextPointer { int opCall() { return ++local; } }\n+    static assert(hasIndirections!HasContextPointer);\n }\n \n enum bool isAggregateType(T) = is(T == struct) || is(T == union) ||"}, {"sha": "6136cfef17d2f20a1d2d268df3d60030907ba8ee", "filename": "libphobos/libdruntime/core/internal/util/array.d", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Finternal%2Futil%2Farray.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Finternal%2Futil%2Farray.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Futil%2Farray.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -13,6 +13,17 @@ import core.internal.string;\n import core.stdc.stdint;\n \n \n+// TLS storage shared for all error messages.\n+private align(2 * size_t.sizeof) char[256] _store;\n+\n+private char[] errorMessage(Args...)(scope const(char*) format,\n+    const char[] action, Args args) @trusted\n+{\n+    import core.stdc.stdio : snprintf;\n+    snprintf(&_store[0], _store.sizeof, format, &action[0], args);\n+    return _store;\n+}\n+\n @safe /* pure dmd @@@BUG11461@@@ */ nothrow:\n \n void enforceTypedArraysConformable(T)(const char[] action,\n@@ -65,6 +76,44 @@ private void _enforceNoOverlap(const char[] action,\n     assert(0, msg);\n }\n \n+void enforceTypedArraysConformableNogc(T)(const char[] action,\n+    const T[] a1, const T[] a2, const bool allowOverlap = false)\n+{\n+    _enforceSameLengthNogc(action, a1.length, a2.length);\n+    if (!allowOverlap)\n+        _enforceNoOverlapNogc(action, arrayToPtr(a1), arrayToPtr(a2), T.sizeof * a1.length);\n+}\n+\n+void enforceRawArraysConformableNogc(const char[] action, const size_t elementSize,\n+    const void[] a1, const void[] a2, const bool allowOverlap = false)\n+{\n+    _enforceSameLengthNogc(action, a1.length, a2.length);\n+    if (!allowOverlap)\n+        _enforceNoOverlapNogc(action, arrayToPtr(a1), arrayToPtr(a2), elementSize * a1.length);\n+}\n+\n+private void _enforceNoOverlapNogc(const ref char[] action,\n+    uintptr_t ptr1, uintptr_t ptr2, const size_t bytes)\n+{\n+    const d = ptr1 > ptr2 ? ptr1 - ptr2 : ptr2 - ptr1;\n+    if (d >= bytes)\n+        return;\n+    const overlappedBytes = bytes - d;\n+\n+    assert(0, errorMessage(\"Overlapping arrays in %s: %zu byte(s) overlap of %zu\",\n+        action, overlappedBytes, bytes));\n+}\n+\n+private void _enforceSameLengthNogc(const ref char[] action,\n+    const size_t length1, const size_t length2)\n+{\n+    if (length1 == length2)\n+        return;\n+\n+    assert(0, errorMessage(\"Array lengths don't match for %s: %zu != %zu\",\n+        action, length1, length2));\n+}\n+\n private uintptr_t arrayToPtr(const void[] array) @trusted\n {\n     // Ok because the user will never dereference the pointer"}, {"sha": "d93b891226ce0b403ebb85dba57b3589f7c42143", "filename": "libphobos/libdruntime/core/lifetime.d", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Flifetime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Flifetime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Flifetime.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -2124,7 +2124,9 @@ private void moveEmplaceImpl(T)(scope ref T target, return scope ref T source)\n                 () @trusted { memset(&source, 0, sz); }();\n             else\n             {\n-                auto init = typeid(T).initializer();\n+                import core.internal.lifetime : emplaceInitializer;\n+                ubyte[T.sizeof] init = void;\n+                emplaceInitializer(*(() @trusted { return cast(T*)init.ptr; }()));\n                 () @trusted { memcpy(&source, init.ptr, sz); }();\n             }\n         }"}, {"sha": "b08ec52a246fd83db056f89347a0dbce1aef7746", "filename": "libphobos/libdruntime/core/runtime.d", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fruntime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fruntime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fruntime.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -848,6 +848,7 @@ else static if (hasExecinfo) private class DefaultTraceInfo : Throwable.TraceInf\n         version (linux) enum enableDwarf = true;\n         else version (FreeBSD) enum enableDwarf = true;\n         else version (DragonFlyBSD) enum enableDwarf = true;\n+        else version (OpenBSD) enum enableDwarf = true;\n         else version (Darwin) enum enableDwarf = true;\n         else enum enableDwarf = false;\n "}, {"sha": "2f11a663eb540edbf3d974d54d7d5bb9191441a9", "filename": "libphobos/libdruntime/core/stdc/stdlib.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fstdlib.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fstdlib.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fstdlib.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -9,7 +9,7 @@\n  *    (See accompanying file LICENSE)\n  * Authors:   Sean Kelly\n  * Standards: ISO/IEC 9899:1999 (E)\n- * Source: $(DRUNTIMESRC src/core/stdc/_stdlib.d)\n+ * Source: $(DRUNTIMESRC core/stdc/_stdlib.d)\n  */\n \n module core.stdc.stdlib;"}, {"sha": "07c5bdbe360660d14e099a8b12a3b1abba798460", "filename": "libphobos/libdruntime/core/sync/rwmutex.d", "status": "modified", "additions": 403, "deletions": 15, "changes": 418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsync%2Frwmutex.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsync%2Frwmutex.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsync%2Frwmutex.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -86,7 +86,7 @@ class ReadWriteMutex\n      * Throws:\n      *  SyncError on error.\n      */\n-    this( Policy policy = Policy.PREFER_WRITERS )\n+    this( Policy policy = Policy.PREFER_WRITERS ) @safe nothrow\n     {\n         m_commonMutex = new Mutex;\n         if ( !m_commonMutex )\n@@ -105,6 +105,26 @@ class ReadWriteMutex\n         m_writer = new Writer;\n     }\n \n+    /// ditto\n+    shared this( Policy policy = Policy.PREFER_WRITERS ) @safe nothrow\n+    {\n+        m_commonMutex = new shared Mutex;\n+        if ( !m_commonMutex )\n+            throw new SyncError( \"Unable to initialize mutex\" );\n+\n+        m_readerQueue = new shared Condition( m_commonMutex );\n+        if ( !m_readerQueue )\n+            throw new SyncError( \"Unable to initialize mutex\" );\n+\n+        m_writerQueue = new shared Condition( m_commonMutex );\n+        if ( !m_writerQueue )\n+            throw new SyncError( \"Unable to initialize mutex\" );\n+\n+        m_policy = policy;\n+        m_reader = new shared Reader;\n+        m_writer = new shared Writer;\n+    }\n+\n     ////////////////////////////////////////////////////////////////////////////\n     // General Properties\n     ////////////////////////////////////////////////////////////////////////////\n@@ -116,11 +136,16 @@ class ReadWriteMutex\n      * Returns:\n      *  The policy used by this mutex.\n      */\n-    @property Policy policy()\n+    @property Policy policy() @safe nothrow\n     {\n         return m_policy;\n     }\n \n+    ///ditto\n+    @property Policy policy() shared @safe nothrow\n+    {\n+        return m_policy;\n+    }\n \n     ////////////////////////////////////////////////////////////////////////////\n     // Reader/Writer Handles\n@@ -133,19 +158,30 @@ class ReadWriteMutex\n      * Returns:\n      *  A reader sub-mutex.\n      */\n-    @property Reader reader()\n+    @property Reader reader() @safe nothrow\n     {\n         return m_reader;\n     }\n \n+    ///ditto\n+    @property shared(Reader) reader() shared @safe nothrow\n+    {\n+        return m_reader;\n+    }\n \n     /**\n      * Gets an object representing the writer lock for the associated mutex.\n      *\n      * Returns:\n      *  A writer sub-mutex.\n      */\n-    @property Writer writer()\n+    @property Writer writer() @safe nothrow\n+    {\n+        return m_writer;\n+    }\n+\n+    ///ditto\n+    @property shared(Writer) writer() shared @safe nothrow\n     {\n         return m_writer;\n     }\n@@ -166,13 +202,13 @@ class ReadWriteMutex\n         /**\n          * Initializes a read/write mutex reader proxy object.\n          */\n-        this()\n+        this(this Q)() @trusted nothrow\n+            if (is(Q == Reader) || is(Q == shared Reader))\n         {\n             m_proxy.link = this;\n-            this.__monitor = &m_proxy;\n+            this.__monitor = cast(void*) &m_proxy;\n         }\n \n-\n         /**\n          * Acquires a read lock on the enclosing mutex.\n          */\n@@ -189,6 +225,19 @@ class ReadWriteMutex\n             }\n         }\n \n+        /// ditto\n+        @trusted void lock() shared\n+        {\n+            synchronized( m_commonMutex )\n+            {\n+                ++(cast()m_numQueuedReaders);\n+                scope(exit) --(cast()m_numQueuedReaders);\n+\n+                while ( shouldQueueReader )\n+                    m_readerQueue.wait();\n+                ++(cast()m_numActiveReaders);\n+            }\n+        }\n \n         /**\n          * Releases a read lock on the enclosing mutex.\n@@ -205,6 +254,18 @@ class ReadWriteMutex\n             }\n         }\n \n+        /// ditto\n+        @trusted void unlock() shared\n+        {\n+            synchronized( m_commonMutex )\n+            {\n+                if ( --(cast()m_numActiveReaders) < 1 )\n+                {\n+                    if ( m_numQueuedWriters > 0 )\n+                        m_writerQueue.notify();\n+                }\n+            }\n+        }\n \n         /**\n          * Attempts to acquire a read lock on the enclosing mutex.  If one can\n@@ -214,7 +275,7 @@ class ReadWriteMutex\n          * Returns:\n          *  true if the lock was acquired and false if not.\n          */\n-        bool tryLock()\n+        @trusted bool tryLock()\n         {\n             synchronized( m_commonMutex )\n             {\n@@ -225,6 +286,18 @@ class ReadWriteMutex\n             }\n         }\n \n+        /// ditto\n+        @trusted bool tryLock() shared\n+        {\n+            synchronized( m_commonMutex )\n+            {\n+                if ( shouldQueueReader )\n+                    return false;\n+                ++(cast()m_numActiveReaders);\n+                return true;\n+            }\n+        }\n+\n         /**\n          * Attempts to acquire a read lock on the enclosing mutex. If one can\n          * be obtained without blocking, the lock is acquired and true is\n@@ -237,7 +310,7 @@ class ReadWriteMutex\n          * Returns:\n          *  true if the lock was acquired and false if not.\n          */\n-        bool tryLock(Duration timeout)\n+        @trusted bool tryLock(Duration timeout)\n         {\n             synchronized( m_commonMutex )\n             {\n@@ -270,9 +343,34 @@ class ReadWriteMutex\n             }\n         }\n \n+        /// ditto\n+        @trusted bool tryLock(Duration timeout) shared\n+        {\n+            const initialTime = MonoTime.currTime;\n+            synchronized( m_commonMutex )\n+            {\n+                ++(cast()m_numQueuedReaders);\n+                scope(exit) --(cast()m_numQueuedReaders);\n+\n+                while (shouldQueueReader)\n+                {\n+                    const timeElapsed = MonoTime.currTime - initialTime;\n+                    if (timeElapsed >= timeout)\n+                        return false;\n+                    auto nextWait = timeout - timeElapsed;\n+                    // Avoid problems calling wait(Duration) with huge arguments.\n+                    enum maxWaitPerCall = dur!\"hours\"(24 * 365);\n+                    m_readerQueue.wait(nextWait < maxWaitPerCall ? nextWait : maxWaitPerCall);\n+                }\n+                ++(cast()m_numActiveReaders);\n+                return true;\n+            }\n+        }\n+\n \n     private:\n-        @property bool shouldQueueReader()\n+        @property bool shouldQueueReader(this Q)() nothrow @safe @nogc\n+            if (is(Q == Reader) || is(Q == shared Reader))\n         {\n             if ( m_numActiveWriters > 0 )\n                 return true;\n@@ -314,10 +412,11 @@ class ReadWriteMutex\n         /**\n          * Initializes a read/write mutex writer proxy object.\n          */\n-        this()\n+        this(this Q)() @trusted nothrow\n+            if (is(Q == Writer) || is(Q == shared Writer))\n         {\n             m_proxy.link = this;\n-            this.__monitor = &m_proxy;\n+            this.__monitor = cast(void*) &m_proxy;\n         }\n \n \n@@ -337,6 +436,20 @@ class ReadWriteMutex\n             }\n         }\n \n+        /// ditto\n+        @trusted void lock() shared\n+        {\n+            synchronized( m_commonMutex )\n+            {\n+                ++(cast()m_numQueuedWriters);\n+                scope(exit) --(cast()m_numQueuedWriters);\n+\n+                while ( shouldQueueWriter )\n+                    m_writerQueue.wait();\n+                ++(cast()m_numActiveWriters);\n+            }\n+        }\n+\n \n         /**\n          * Releases a write lock on the enclosing mutex.\n@@ -366,6 +479,32 @@ class ReadWriteMutex\n             }\n         }\n \n+        /// ditto\n+        @trusted void unlock() shared\n+        {\n+            synchronized( m_commonMutex )\n+            {\n+                if ( --(cast()m_numActiveWriters) < 1 )\n+                {\n+                    switch ( m_policy )\n+                    {\n+                    default:\n+                    case Policy.PREFER_READERS:\n+                        if ( m_numQueuedReaders > 0 )\n+                            m_readerQueue.notifyAll();\n+                        else if ( m_numQueuedWriters > 0 )\n+                            m_writerQueue.notify();\n+                        break;\n+                    case Policy.PREFER_WRITERS:\n+                        if ( m_numQueuedWriters > 0 )\n+                            m_writerQueue.notify();\n+                        else if ( m_numQueuedReaders > 0 )\n+                            m_readerQueue.notifyAll();\n+                    }\n+                }\n+            }\n+        }\n+\n \n         /**\n          * Attempts to acquire a write lock on the enclosing mutex.  If one can\n@@ -375,7 +514,7 @@ class ReadWriteMutex\n          * Returns:\n          *  true if the lock was acquired and false if not.\n          */\n-        bool tryLock()\n+        @trusted bool tryLock()\n         {\n             synchronized( m_commonMutex )\n             {\n@@ -386,6 +525,18 @@ class ReadWriteMutex\n             }\n         }\n \n+        /// ditto\n+        @trusted bool tryLock() shared\n+        {\n+            synchronized( m_commonMutex )\n+            {\n+                if ( shouldQueueWriter )\n+                    return false;\n+                ++(cast()m_numActiveWriters);\n+                return true;\n+            }\n+        }\n+\n         /**\n          * Attempts to acquire a write lock on the enclosing mutex. If one can\n          * be obtained without blocking, the lock is acquired and true is\n@@ -398,7 +549,7 @@ class ReadWriteMutex\n          * Returns:\n          *  true if the lock was acquired and false if not.\n          */\n-        bool tryLock(Duration timeout)\n+        @trusted bool tryLock(Duration timeout)\n         {\n             synchronized( m_commonMutex )\n             {\n@@ -431,8 +582,33 @@ class ReadWriteMutex\n             }\n         }\n \n+        /// ditto\n+        @trusted bool tryLock(Duration timeout) shared\n+        {\n+            const initialTime = MonoTime.currTime;\n+            synchronized( m_commonMutex )\n+            {\n+                ++(cast()m_numQueuedWriters);\n+                scope(exit) --(cast()m_numQueuedWriters);\n+\n+                while (shouldQueueWriter)\n+                {\n+                    const timeElapsed = MonoTime.currTime - initialTime;\n+                    if (timeElapsed >= timeout)\n+                        return false;\n+                    auto nextWait = timeout - timeElapsed;\n+                    // Avoid problems calling wait(Duration) with huge arguments.\n+                    enum maxWaitPerCall = dur!\"hours\"(24 * 365);\n+                    m_writerQueue.wait(nextWait < maxWaitPerCall ? nextWait : maxWaitPerCall);\n+                }\n+                ++(cast()m_numActiveWriters);\n+                return true;\n+            }\n+        }\n+\n     private:\n-        @property bool shouldQueueWriter()\n+        @property bool shouldQueueWriter(this Q)()\n+            if (is(Q == Writer) || is(Q == shared Writer))\n         {\n             if ( m_numActiveWriters > 0 ||\n                 m_numActiveReaders > 0 )\n@@ -691,3 +867,215 @@ unittest\n         otherThread.join;\n     }\n }\n+\n+unittest\n+{\n+    import core.atomic, core.thread, core.sync.semaphore;\n+\n+    static void runTest(ReadWriteMutex.Policy policy)\n+    {\n+        shared scope mutex = new shared ReadWriteMutex(policy);\n+        scope rdSemA = new Semaphore, rdSemB = new Semaphore,\n+              wrSemA = new Semaphore, wrSemB = new Semaphore;\n+        shared size_t numReaders, numWriters;\n+\n+        void readerFn()\n+        {\n+            synchronized (mutex.reader)\n+            {\n+                atomicOp!\"+=\"(numReaders, 1);\n+                rdSemA.notify();\n+                rdSemB.wait();\n+                atomicOp!\"-=\"(numReaders, 1);\n+            }\n+        }\n+\n+        void writerFn()\n+        {\n+            synchronized (mutex.writer)\n+            {\n+                atomicOp!\"+=\"(numWriters, 1);\n+                wrSemA.notify();\n+                wrSemB.wait();\n+                atomicOp!\"-=\"(numWriters, 1);\n+            }\n+        }\n+\n+        void waitQueued(size_t queuedReaders, size_t queuedWriters)\n+        {\n+            for (;;)\n+            {\n+                synchronized (mutex.m_commonMutex)\n+                {\n+                    if (mutex.m_numQueuedReaders == queuedReaders &&\n+                        mutex.m_numQueuedWriters == queuedWriters)\n+                        break;\n+                }\n+                Thread.yield();\n+            }\n+        }\n+\n+        scope group = new ThreadGroup;\n+\n+        // 2 simultaneous readers\n+        group.create(&readerFn); group.create(&readerFn);\n+        rdSemA.wait(); rdSemA.wait();\n+        assert(numReaders == 2);\n+        rdSemB.notify(); rdSemB.notify();\n+        group.joinAll();\n+        assert(numReaders == 0);\n+        foreach (t; group) group.remove(t);\n+\n+        // 1 writer at a time\n+        group.create(&writerFn); group.create(&writerFn);\n+        wrSemA.wait();\n+        assert(!wrSemA.tryWait());\n+        assert(numWriters == 1);\n+        wrSemB.notify();\n+        wrSemA.wait();\n+        assert(numWriters == 1);\n+        wrSemB.notify();\n+        group.joinAll();\n+        assert(numWriters == 0);\n+        foreach (t; group) group.remove(t);\n+\n+        // reader and writer are mutually exclusive\n+        group.create(&readerFn);\n+        rdSemA.wait();\n+        group.create(&writerFn);\n+        waitQueued(0, 1);\n+        assert(!wrSemA.tryWait());\n+        assert(numReaders == 1 && numWriters == 0);\n+        rdSemB.notify();\n+        wrSemA.wait();\n+        assert(numReaders == 0 && numWriters == 1);\n+        wrSemB.notify();\n+        group.joinAll();\n+        assert(numReaders == 0 && numWriters == 0);\n+        foreach (t; group) group.remove(t);\n+\n+        // writer and reader are mutually exclusive\n+        group.create(&writerFn);\n+        wrSemA.wait();\n+        group.create(&readerFn);\n+        waitQueued(1, 0);\n+        assert(!rdSemA.tryWait());\n+        assert(numReaders == 0 && numWriters == 1);\n+        wrSemB.notify();\n+        rdSemA.wait();\n+        assert(numReaders == 1 && numWriters == 0);\n+        rdSemB.notify();\n+        group.joinAll();\n+        assert(numReaders == 0 && numWriters == 0);\n+        foreach (t; group) group.remove(t);\n+\n+        // policy determines whether queued reader or writers progress first\n+        group.create(&writerFn);\n+        wrSemA.wait();\n+        group.create(&readerFn);\n+        group.create(&writerFn);\n+        waitQueued(1, 1);\n+        assert(numReaders == 0 && numWriters == 1);\n+        wrSemB.notify();\n+\n+        if (policy == ReadWriteMutex.Policy.PREFER_READERS)\n+        {\n+            rdSemA.wait();\n+            assert(numReaders == 1 && numWriters == 0);\n+            rdSemB.notify();\n+            wrSemA.wait();\n+            assert(numReaders == 0 && numWriters == 1);\n+            wrSemB.notify();\n+        }\n+        else if (policy == ReadWriteMutex.Policy.PREFER_WRITERS)\n+        {\n+            wrSemA.wait();\n+            assert(numReaders == 0 && numWriters == 1);\n+            wrSemB.notify();\n+            rdSemA.wait();\n+            assert(numReaders == 1 && numWriters == 0);\n+            rdSemB.notify();\n+        }\n+        group.joinAll();\n+        assert(numReaders == 0 && numWriters == 0);\n+        foreach (t; group) group.remove(t);\n+    }\n+    runTest(ReadWriteMutex.Policy.PREFER_READERS);\n+    runTest(ReadWriteMutex.Policy.PREFER_WRITERS);\n+}\n+\n+unittest\n+{\n+    import core.atomic, core.thread;\n+    shared static ReadWriteMutex rwmutex;\n+    shared static bool threadTriedOnceToGetLock;\n+    shared static bool threadFinallyGotLock;\n+\n+    rwmutex = new shared ReadWriteMutex();\n+    atomicFence;\n+    const maxTimeAllowedForTest = dur!\"seconds\"(20);\n+    // Test ReadWriteMutex.Reader.tryLock(Duration).\n+    {\n+        static void testReaderTryLock()\n+        {\n+            assert(!rwmutex.reader.tryLock(Duration.min));\n+            threadTriedOnceToGetLock.atomicStore(true);\n+            assert(rwmutex.reader.tryLock(Duration.max));\n+            threadFinallyGotLock.atomicStore(true);\n+            rwmutex.reader.unlock;\n+        }\n+        assert(rwmutex.writer.tryLock(Duration.zero), \"should have been able to obtain lock without blocking\");\n+        auto otherThread = new Thread(&testReaderTryLock).start;\n+        const failIfThisTimeisReached = MonoTime.currTime + maxTimeAllowedForTest;\n+        Thread.yield;\n+        // We started otherThread with the writer lock held so otherThread's\n+        // first rwlock.reader.tryLock with timeout Duration.min should fail.\n+        while (!threadTriedOnceToGetLock.atomicLoad)\n+        {\n+            assert(MonoTime.currTime < failIfThisTimeisReached, \"timed out\");\n+            Thread.yield;\n+        }\n+        rwmutex.writer.unlock;\n+        // Soon after we release the writer lock otherThread's second\n+        // rwlock.reader.tryLock with timeout Duration.max should succeed.\n+        while (!threadFinallyGotLock.atomicLoad)\n+        {\n+            assert(MonoTime.currTime < failIfThisTimeisReached, \"timed out\");\n+            Thread.yield;\n+        }\n+        otherThread.join;\n+    }\n+    threadTriedOnceToGetLock.atomicStore(false); // Reset.\n+    threadFinallyGotLock.atomicStore(false); // Reset.\n+    // Test ReadWriteMutex.Writer.tryLock(Duration).\n+    {\n+        static void testWriterTryLock()\n+        {\n+            assert(!rwmutex.writer.tryLock(Duration.min));\n+            threadTriedOnceToGetLock.atomicStore(true);\n+            assert(rwmutex.writer.tryLock(Duration.max));\n+            threadFinallyGotLock.atomicStore(true);\n+            rwmutex.writer.unlock;\n+        }\n+        assert(rwmutex.reader.tryLock(Duration.zero), \"should have been able to obtain lock without blocking\");\n+        auto otherThread = new Thread(&testWriterTryLock).start;\n+        const failIfThisTimeisReached = MonoTime.currTime + maxTimeAllowedForTest;\n+        Thread.yield;\n+        // We started otherThread with the reader lock held so otherThread's\n+        // first rwlock.writer.tryLock with timeout Duration.min should fail.\n+        while (!threadTriedOnceToGetLock.atomicLoad)\n+        {\n+            assert(MonoTime.currTime < failIfThisTimeisReached, \"timed out\");\n+            Thread.yield;\n+        }\n+        rwmutex.reader.unlock;\n+        // Soon after we release the reader lock otherThread's second\n+        // rwlock.writer.tryLock with timeout Duration.max should succeed.\n+        while (!threadFinallyGotLock.atomicLoad)\n+        {\n+            assert(MonoTime.currTime < failIfThisTimeisReached, \"timed out\");\n+            Thread.yield;\n+        }\n+        otherThread.join;\n+    }\n+}"}, {"sha": "5e3129e2422291f1dc758724f293b6b03be1bf66", "filename": "libphobos/libdruntime/core/sys/freebsd/config.d", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Ffreebsd%2Fconfig.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Ffreebsd%2Fconfig.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Ffreebsd%2Fconfig.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -13,7 +13,9 @@ public import core.sys.posix.config;\n // __FreeBSD_version numbers are documented in the Porter's Handbook.\n // NOTE: When adding newer versions of FreeBSD, verify all current versioned\n // bindings are still compatible with the release.\n-     version (FreeBSD_12) enum __FreeBSD_version = 1202000;\n+\n+     version (FreeBSD_13) enum __FreeBSD_version = 1300000;\n+else version (FreeBSD_12) enum __FreeBSD_version = 1202000;\n else version (FreeBSD_11) enum __FreeBSD_version = 1104000;\n else version (FreeBSD_10) enum __FreeBSD_version = 1004000;\n else version (FreeBSD_9)  enum __FreeBSD_version = 903000;"}, {"sha": "c55250669691a486db57c3442368f48cc6732455", "filename": "libphobos/libdruntime/core/sys/linux/fs.d", "status": "modified", "additions": 33, "deletions": 30, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Ffs.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Ffs.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Ffs.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -154,39 +154,42 @@ enum {\n     S_XFLAG_HASATTR = 0x80000000, /// no DIFLAG for this\n }\n \n-enum BLKROSET = _IO(0x12, 93); /// set device read-only\n-enum BLKROGET = _IO(0x12, 94); /// get read-only status\n-enum BLKRRPART = _IO(0x12, 95); /// re-read partition table\n-enum BLKGETSIZE = _IO(0x12, 96); /// return device size\n-enum BLKFLSBUF = _IO(0x12, 97); /// flush buffer cache\n-enum BLKRASET = _IO(0x12, 98); /// set read ahead for block device\n-enum BLKRAGET = _IO(0x12, 99); /// get current read ahead setting\n-enum BLKFRASET = _IO(0x12, 100); /// set filesystem\n-enum BLKFRAGET = _IO(0x12, 101); /// get filesystem\n-enum BLKSECTSET = _IO(0x12, 102); /// set max sectors per request\n-enum BLKSECTGET = _IO(0x12, 103); /// get max sectors per request\n-enum BLKSSZGET = _IO(0x12, 104); /// get block device sector size\n+static if (__traits(compiles, _IO(1, 2)))\n+{\n+    enum BLKROSET = _IO(0x12, 93); /// set device read-only\n+    enum BLKROGET = _IO(0x12, 94); /// get read-only status\n+    enum BLKRRPART = _IO(0x12, 95); /// re-read partition table\n+    enum BLKGETSIZE = _IO(0x12, 96); /// return device size\n+    enum BLKFLSBUF = _IO(0x12, 97); /// flush buffer cache\n+    enum BLKRASET = _IO(0x12, 98); /// set read ahead for block device\n+    enum BLKRAGET = _IO(0x12, 99); /// get current read ahead setting\n+    enum BLKFRASET = _IO(0x12, 100); /// set filesystem\n+    enum BLKFRAGET = _IO(0x12, 101); /// get filesystem\n+    enum BLKSECTSET = _IO(0x12, 102); /// set max sectors per request\n+    enum BLKSECTGET = _IO(0x12, 103); /// get max sectors per request\n+    enum BLKSSZGET = _IO(0x12, 104); /// get block device sector size\n \n \n-enum BLKBSZGET = _IOR!size_t(0x12, 112);\n-enum BLKBSZSET = _IOW!size_t(0x12, 113);\n-enum BLKGETSIZE64 = _IOR!size_t(0x12, 114);\n-enum BLKTRACESTART = _IO(0x12, 116);\n-enum BLKTRACESTOP = _IO(0x12, 117);\n-enum BLKTRACETEARDOWN = _IO(0x12, 118);\n-enum BLKDISCARD = _IO(0x12, 119);\n-enum BLKIOMIN = _IO(0x12, 120);\n-enum BLKIOOPT = _IO(0x12, 121);\n-enum BLKALIGNOFF = _IO(0x12, 122);\n-enum BLKPBSZGET = _IO(0x12, 123);\n-enum BLKDISCARDZEROES = _IO(0x12, 124);\n-enum BLKSECDISCARD = _IO(0x12, 125);\n-enum BLKROTATIONAL = _IO(0x12, 126);\n-enum BLKZEROOUT = _IO(0x12, 127);\n+    enum BLKBSZGET = _IOR!size_t(0x12, 112);\n+    enum BLKBSZSET = _IOW!size_t(0x12, 113);\n+    enum BLKGETSIZE64 = _IOR!size_t(0x12, 114);\n+    enum BLKTRACESTART = _IO(0x12, 116);\n+    enum BLKTRACESTOP = _IO(0x12, 117);\n+    enum BLKTRACETEARDOWN = _IO(0x12, 118);\n+    enum BLKDISCARD = _IO(0x12, 119);\n+    enum BLKIOMIN = _IO(0x12, 120);\n+    enum BLKIOOPT = _IO(0x12, 121);\n+    enum BLKALIGNOFF = _IO(0x12, 122);\n+    enum BLKPBSZGET = _IO(0x12, 123);\n+    enum BLKDISCARDZEROES = _IO(0x12, 124);\n+    enum BLKSECDISCARD = _IO(0x12, 125);\n+    enum BLKROTATIONAL = _IO(0x12, 126);\n+    enum BLKZEROOUT = _IO(0x12, 127);\n \n-enum BMAP_IOCTL = 1; /// obsolete - kept for compatibility\n-enum FIBMAP = _IO(0x00, 1); /// bmap access\n-enum FIGETBSZ = _IO(0x00, 2); /// get the block size used for bmap\n+    enum BMAP_IOCTL = 1; /// obsolete - kept for compatibility\n+    enum FIBMAP = _IO(0x00, 1); /// bmap access\n+    enum FIGETBSZ = _IO(0x00, 2); /// get the block size used for bmap\n+}\n \n enum FSLABEL_MAX = 256; /// Max chars for the interface; each fs may differ\n "}, {"sha": "9e96a7f5f4350b3a9b87738f0792ed36a89b9909", "filename": "libphobos/libdruntime/core/sys/linux/perf_event.d", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fperf_event.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fperf_event.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fperf_event.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -2073,8 +2073,6 @@ else\n \n                 struct\n                 {\n-                        import std.bitmanip : bitfields;\n-\n                         /* mixin(bitfields!(ulong, \"mem_rsvd\", 24, ulong, \"mem_snoopx\", 2, ulong,\n                     \"mem_remote\", 1, ulong, \"mem_lvl_num\", 4, ulong, \"mem_dtlb\", 7, ulong,\n                     \"mem_lock\", 2, ulong, \"mem_snoop\", 5, ulong, \"mem_lvl\","}, {"sha": "a6548a7802c0e2702af260c375606f9cc3f595ea", "filename": "libphobos/libdruntime/core/sys/linux/sys/mman.d", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fsys%2Fmman.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fsys%2Fmman.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fsys%2Fmman.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -32,7 +32,7 @@ public import core.sys.posix.sys.mman;\n import core.sys.linux.config;\n \n // <bits/mman.h>\n-// http://sourceware.org/git/?p=glibc.git;a=blob;hb=51e945a8f950a6695754b11c1e6fba8bb750e100;f=sysdeps/unix/sysv/linux/powerpc/bits/mman.h\n+// http://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/powerpc/bits/mman.h\n version (PPC_Any)\n {\n     enum PROT_SAO = 0x10;\n@@ -57,7 +57,7 @@ version (PPC_Any)\n     //     MCL_FUTURE = 0x4000,\n     // }\n }\n-// https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/riscv/bits/mman.h\n+// http://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/riscv/bits/mman.h\n else version (RISCV_Any)\n {\n     static if (__USE_MISC) enum\n@@ -82,7 +82,7 @@ else version (RISCV_Any)\n     //     MCL_FUTURE = 0x4000,\n     // }\n }\n-// http://sourceware.org/git/?p=glibc.git;a=blob;hb=51e945a8f950a6695754b11c1e6fba8bb750e100;f=sysdeps/unix/sysv/linux/s390/bits/mman.h\n+// http://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/s390/bits/mman.h\n else version (IBMZ_Any)\n {\n     static if (__USE_MISC) enum\n@@ -98,7 +98,7 @@ else version (IBMZ_Any)\n         MAP_HUGETLB = 0x40000,\n     }\n }\n-// http://sourceware.org/git/?p=glibc.git;a=blob;hb=51e945a8f950a6695754b11c1e6fba8bb750e100;f=sysdeps/unix/sysv/linux/sh/bits/mman.h\n+// http://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/sh/bits/mman.h\n else version (SH)\n {\n     static if (__USE_MISC) enum\n@@ -114,7 +114,7 @@ else version (SH)\n         MAP_HUGETLB = 0x40000,\n     }\n }\n-// http://sourceware.org/git/?p=glibc.git;a=blob;hb=51e945a8f950a6695754b11c1e6fba8bb750e100;f=sysdeps/unix/sysv/linux/sparc/bits/mman.h\n+// http://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/sparc/bits/mman.h\n else version (SPARC_Any)\n {\n     static if (__USE_MISC) enum\n@@ -138,7 +138,7 @@ else version (SPARC_Any)\n     //     MCL_FUTURE = 0x4000,\n     // }\n }\n-// http://sourceware.org/git/?p=glibc.git;a=blob;hb=51e945a8f950a6695754b11c1e6fba8bb750e100;f=sysdeps/unix/sysv/linux/x86/bits/mman.h\n+// http://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/x86/bits/mman.h\n else version (X86_Any)\n {\n     static if (__USE_MISC) enum MAP_32BIT = 0x40;\n@@ -156,7 +156,7 @@ else version (X86_Any)\n         MAP_HUGETLB = 0x40000,\n     }\n }\n-// http://sourceware.org/git/?p=glibc.git;a=blob;hb=51e945a8f950a6695754b11c1e6fba8bb750e100;f=sysdeps/unix/sysv/linux/aarch64/bits/mman.h\n+// http://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/aarch64/bits/mman.h\n else version (AArch64)\n {\n     static if (__USE_MISC) enum\n@@ -172,7 +172,7 @@ else version (AArch64)\n         MAP_HUGETLB = 0x40000,\n     }\n }\n-// http://sourceware.org/git/?p=glibc.git;a=blob;hb=51e945a8f950a6695754b11c1e6fba8bb750e100;f=sysdeps/unix/sysv/linux/alpha/bits/mman.h\n+// http://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/alpha/bits/mman.h\n else version (Alpha)\n {\n     enum\n@@ -264,7 +264,7 @@ else version (Alpha)\n     //         POSIX_MADV_DONTNEED = 6,\n     // }\n }\n-// http://sourceware.org/git/?p=glibc.git;a=blob;hb=51e945a8f950a6695754b11c1e6fba8bb750e100;f=sysdeps/unix/sysv/linux/arm/bits/mman.h\n+// http://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/arm/bits/mman.h\n else version (ARM)\n {\n     static if (__USE_MISC) enum\n@@ -280,7 +280,7 @@ else version (ARM)\n         MAP_HUGETLB = 0x40000,\n     }\n }\n-// http://sourceware.org/git/?p=glibc.git;a=blob;hb=51e945a8f950a6695754b11c1e6fba8bb750e100;f=sysdeps/unix/sysv/linux/hppa/bits/mman.h\n+// http://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/hppa/bits/mman.h\n else version (HPPA_Any)\n {\n     enum\n@@ -384,7 +384,7 @@ else version (HPPA_Any)\n     //     POSIX_MADV_DONTNEED = 4,\n     // }\n }\n-// http://sourceware.org/git/?p=glibc.git;a=blob;hb=51e945a8f950a6695754b11c1e6fba8bb750e100;f=sysdeps/unix/sysv/linux/ia64/bits/mman.h\n+// http://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/ia64/bits/mman.h\n else version (IA64)\n {\n     static if (__USE_MISC) enum\n@@ -401,7 +401,7 @@ else version (IA64)\n         MAP_HUGETLB = 0x40000,\n     }\n }\n-// http://sourceware.org/git/?p=glibc.git;a=blob;hb=51e945a8f950a6695754b11c1e6fba8bb750e100;f=sysdeps/unix/sysv/linux/m68k/bits/mman.h\n+// http://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/m68k/bits/mman.h\n else version (M68K)\n {\n     static if (__USE_MISC) enum\n@@ -417,7 +417,7 @@ else version (M68K)\n         MAP_HUGETLB = 0x40000,\n     }\n }\n-// http://sourceware.org/git/?p=glibc.git;a=blob;hb=51e945a8f950a6695754b11c1e6fba8bb750e100;f=sysdeps/unix/sysv/linux/mips/bits/mman.h\n+// http://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/mips/bits/mman.h\n else version (MIPS_Any)\n {\n     static if (__USE_MISC) enum\n@@ -440,7 +440,7 @@ else\n \n \n // <bits/mman-linux.h>\n-// https://sourceware.org/git/?p=glibc.git;a=blob;hb=51e945a8f950a6695754b11c1e6fba8bb750e100;f=bits/mman-linux.h\n+// https://sourceware.org/git/?p=glibc.git;a=blob;f=bits/mman-linux.h\n version (Alpha)\n {\n }\n@@ -527,12 +527,12 @@ else\n }\n \n // Workaround https://issues.dlang.org/show_bug.cgi?id=17883\n-// http://sourceware.org/git/?p=glibc.git;a=blob;hb=51e945a8f950a6695754b11c1e6fba8bb750e100;f=sysdeps/unix/sysv/linux/sparc/bits/mman.h\n+// http://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/sparc/bits/mman.h\n version (SPARC_Any)\n {\n     static if (__USE_MISC) enum MAP_RENAME = MAP_ANONYMOUS;\n }\n-// http://sourceware.org/git/?p=glibc.git;a=blob;hb=51e945a8f950a6695754b11c1e6fba8bb750e100;f=sysdeps/unix/sysv/linux/mips/bits/mman.h\n+// http://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/mips/bits/mman.h\n else version (MIPS_Any)\n {\n     static if (__USE_MISC) enum MAP_RENAME = MAP_ANONYMOUS;"}, {"sha": "8c653719317d8c96cbd4f6676149f690ecf2b7c0", "filename": "libphobos/libdruntime/core/sys/linux/syscalls.d", "status": "added", "additions": 745, "deletions": 0, "changes": 745, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fsyscalls.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fsyscalls.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fsyscalls.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,745 @@\n+module core.sys.linux.syscalls;\n+\n+version (linux):\n+extern (C):\n+@system:\n+nothrow:\n+@nogc:\n+\n+import core.stdc.config : c_long;\n+\n+version (CoreDdoc)\n+{\n+    /// Linux system call number from Linux's asm/unistd.h\n+    enum SystemCall : c_long;\n+}\n+else version (X86_64)\n+{\n+    // https://github.com/torvalds/linux/blob/v4.14/arch/sh/include/uapi/asm/unistd_64.h\n+    // https://github.com/torvalds/linux/blob/v4.14/arch/x86/entry/syscalls/syscall_64.tbl\n+    enum SystemCall : c_long\n+    {\n+        read = 0,\n+        write = 1,\n+        open = 2,\n+        close = 3,\n+        stat = 4,\n+        fstat = 5,\n+        lstat = 6,\n+        poll = 7,\n+        lseek = 8,\n+        mmap = 9,\n+        mprotect = 10,\n+        munmap = 11,\n+        brk = 12,\n+        rt_sigaction = 13,\n+        rt_sigprocmask = 14,\n+        rt_sigreturn = 15,\n+        ioctl = 16,\n+        pread64 = 17,\n+        pwrite64 = 18,\n+        readv = 19,\n+        writev = 20,\n+        access = 21,\n+        pipe = 22,\n+        select = 23,\n+        sched_yield = 24,\n+        mremap = 25,\n+        msync = 26,\n+        mincore = 27,\n+        madvise = 28,\n+        shmget = 29,\n+        shmat = 30,\n+        shmctl = 31,\n+        dup = 32,\n+        dup2 = 33,\n+        pause = 34,\n+        nanosleep = 35,\n+        getitimer = 36,\n+        alarm = 37,\n+        setitimer = 38,\n+        getpid = 39,\n+        sendfile = 40,\n+        socket = 41,\n+        connect = 42,\n+        accept = 43,\n+        sendto = 44,\n+        recvfrom = 45,\n+        sendmsg = 46,\n+        recvmsg = 47,\n+        shutdown = 48,\n+        bind = 49,\n+        listen = 50,\n+        getsockname = 51,\n+        getpeername = 52,\n+        socketpair = 53,\n+        setsockopt = 54,\n+        getsockopt = 55,\n+        clone = 56,\n+        fork = 57,\n+        vfork = 58,\n+        execve = 59,\n+        exit = 60,\n+        wait4 = 61,\n+        kill = 62,\n+        uname = 63,\n+        semget = 64,\n+        semop = 65,\n+        semctl = 66,\n+        shmdt = 67,\n+        msgget = 68,\n+        msgsnd = 69,\n+        msgrcv = 70,\n+        msgctl = 71,\n+        fcntl = 72,\n+        flock = 73,\n+        fsync = 74,\n+        fdatasync = 75,\n+        truncate = 76,\n+        ftruncate = 77,\n+        getdents = 78,\n+        getcwd = 79,\n+        chdir = 80,\n+        fchdir = 81,\n+        rename = 82,\n+        mkdir = 83,\n+        rmdir = 84,\n+        creat = 85,\n+        link = 86,\n+        unlink = 87,\n+        symlink = 88,\n+        readlink = 89,\n+        chmod = 90,\n+        fchmod = 91,\n+        chown = 92,\n+        fchown = 93,\n+        lchown = 94,\n+        umask = 95,\n+        gettimeofday = 96,\n+        getrlimit = 97,\n+        getrusage = 98,\n+        sysinfo = 99,\n+        times = 100,\n+        ptrace = 101,\n+        getuid = 102,\n+        syslog = 103,\n+        getgid = 104,\n+        setuid = 105,\n+        setgid = 106,\n+        geteuid = 107,\n+        getegid = 108,\n+        setpgid = 109,\n+        getppid = 110,\n+        getpgrp = 111,\n+        setsid = 112,\n+        setreuid = 113,\n+        setregid = 114,\n+        getgroups = 115,\n+        setgroups = 116,\n+        setresuid = 117,\n+        getresuid = 118,\n+        setresgid = 119,\n+        getresgid = 120,\n+        getpgid = 121,\n+        setfsuid = 122,\n+        setfsgid = 123,\n+        getsid = 124,\n+        capget = 125,\n+        capset = 126,\n+        rt_sigpending = 127,\n+        rt_sigtimedwait = 128,\n+        rt_sigqueueinfo = 129,\n+        rt_sigsuspend = 130,\n+        sigaltstack = 131,\n+        utime = 132,\n+        mknod = 133,\n+        uselib = 134,\n+        personality = 135,\n+        ustat = 136,\n+        statfs = 137,\n+        fstatfs = 138,\n+        sysfs = 139,\n+        getpriority = 140,\n+        setpriority = 141,\n+        sched_setparam = 142,\n+        sched_getparam = 143,\n+        sched_setscheduler = 144,\n+        sched_getscheduler = 145,\n+        sched_get_priority_max = 146,\n+        sched_get_priority_min = 147,\n+        sched_rr_get_interval = 148,\n+        mlock = 149,\n+        munlock = 150,\n+        mlockall = 151,\n+        munlockall = 152,\n+        vhangup = 153,\n+        modify_ldt = 154,\n+        pivot_root = 155,\n+        _sysctl = 156,\n+        prctl = 157,\n+        arch_prctl = 158,\n+        adjtimex = 159,\n+        setrlimit = 160,\n+        chroot = 161,\n+        sync = 162,\n+        acct = 163,\n+        settimeofday = 164,\n+        mount = 165,\n+        umount2 = 166,\n+        swapon = 167,\n+        swapoff = 168,\n+        reboot = 169,\n+        sethostname = 170,\n+        setdomainname = 171,\n+        iopl = 172,\n+        ioperm = 173,\n+        create_module = 174,\n+        init_module = 175,\n+        delete_module = 176,\n+        get_kernel_syms = 177,\n+        query_module = 178,\n+        quotactl = 179,\n+        nfsservctl = 180,\n+        getpmsg = 181,\n+        putpmsg = 182,\n+        afs_syscall = 183,\n+        tuxcall = 184,\n+        security = 185,\n+        gettid = 186,\n+        readahead = 187,\n+        setxattr = 188,\n+        lsetxattr = 189,\n+        fsetxattr = 190,\n+        getxattr = 191,\n+        lgetxattr = 192,\n+        fgetxattr = 193,\n+        listxattr = 194,\n+        llistxattr = 195,\n+        flistxattr = 196,\n+        removexattr = 197,\n+        lremovexattr = 198,\n+        fremovexattr = 199,\n+        tkill = 200,\n+        time = 201,\n+        futex = 202,\n+        sched_setaffinity = 203,\n+        sched_getaffinity = 204,\n+        set_thread_area = 205,\n+        io_setup = 206,\n+        io_destroy = 207,\n+        io_getevents = 208,\n+        io_submit = 209,\n+        io_cancel = 210,\n+        get_thread_area = 211,\n+        lookup_dcookie = 212,\n+        epoll_create = 213,\n+        epoll_ctl_old = 214,\n+        epoll_wait_old = 215,\n+        remap_file_pages = 216,\n+        getdents64 = 217,\n+        set_tid_address = 218,\n+        restart_syscall = 219,\n+        semtimedop = 220,\n+        fadvise64 = 221,\n+        timer_create = 222,\n+        timer_settime = 223,\n+        timer_gettime = 224,\n+        timer_getoverrun = 225,\n+        timer_delete = 226,\n+        clock_settime = 227,\n+        clock_gettime = 228,\n+        clock_getres = 229,\n+        clock_nanosleep = 230,\n+        exit_group = 231,\n+        epoll_wait = 232,\n+        epoll_ctl = 233,\n+        tgkill = 234,\n+        utimes = 235,\n+        vserver = 236,\n+        mbind = 237,\n+        set_mempolicy = 238,\n+        get_mempolicy = 239,\n+        mq_open = 240,\n+        mq_unlink = 241,\n+        mq_timedsend = 242,\n+        mq_timedreceive = 243,\n+        mq_notify = 244,\n+        mq_getsetattr = 245,\n+        kexec_load = 246,\n+        waitid = 247,\n+        add_key = 248,\n+        request_key = 249,\n+        keyctl = 250,\n+        ioprio_set = 251,\n+        ioprio_get = 252,\n+        inotify_init = 253,\n+        inotify_add_watch = 254,\n+        inotify_rm_watch = 255,\n+        migrate_pages = 256,\n+        openat = 257,\n+        mkdirat = 258,\n+        mknodat = 259,\n+        fchownat = 260,\n+        futimesat = 261,\n+        newfstatat = 262,\n+        unlinkat = 263,\n+        renameat = 264,\n+        linkat = 265,\n+        symlinkat = 266,\n+        readlinkat = 267,\n+        fchmodat = 268,\n+        faccessat = 269,\n+        pselect6 = 270,\n+        ppoll = 271,\n+        unshare = 272,\n+        set_robust_list = 273,\n+        get_robust_list = 274,\n+        splice = 275,\n+        tee = 276,\n+        sync_file_range = 277,\n+        vmsplice = 278,\n+        move_pages = 279,\n+        utimensat = 280,\n+        epoll_pwait = 281,\n+        signalfd = 282,\n+        timerfd_create = 283,\n+        eventfd = 284,\n+        fallocate = 285,\n+        timerfd_settime = 286,\n+        timerfd_gettime = 287,\n+        accept4 = 288,\n+        signalfd4 = 289,\n+        eventfd2 = 290,\n+        epoll_create1 = 291,\n+        dup3 = 292,\n+        pipe2 = 293,\n+        inotify_init1 = 294,\n+        preadv = 295,\n+        pwritev = 296,\n+        rt_tgsigqueueinfo = 297,\n+        perf_event_open = 298,\n+        recvmmsg = 299,\n+        fanotify_init = 300,\n+        fanotify_mark = 301,\n+        prlimit64 = 302,\n+        name_to_handle_at = 303,\n+        open_by_handle_at = 304,\n+        clock_adjtime = 305,\n+        syncfs = 306,\n+        sendmmsg = 307,\n+        setns = 308,\n+        getcpu = 309,\n+        process_vm_readv = 310,\n+        process_vm_writev = 311,\n+        kcmp = 312,\n+        finit_module = 313,\n+        sched_setattr = 314,\n+        sched_getattr = 315,\n+        renameat2 = 316,\n+        seccomp = 317,\n+        getrandom = 318,\n+        memfd_create = 319,\n+        kexec_file_load = 320,\n+        bpf = 321,\n+        execveat = 322,\n+        userfaultfd = 323,\n+        membarrier = 324,\n+        mlock2 = 325,\n+        copy_file_range = 326,\n+        preadv2 = 327,\n+        pwritev2 = 328,\n+        pkey_mprotect = 329,\n+        pkey_alloc = 330,\n+        pkey_free = 331,\n+        statx = 332,\n+    }\n+}\n+else version (X86)\n+{\n+    // https://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_32.tbl\n+    // https://github.com/torvalds/linux/blob/v4.14/arch/sh/include/uapi/asm/unistd_32.h\n+    enum SystemCall : c_long\n+    {\n+        restart_syscall = 0,\n+        exit = 1,\n+        fork = 2,\n+        read = 3,\n+        write = 4,\n+        open = 5,\n+        close = 6,\n+        waitpid = 7,\n+        creat = 8,\n+        link = 9,\n+        unlink = 10,\n+        execve = 11,\n+        chdir = 12,\n+        time = 13,\n+        mknod = 14,\n+        chmod = 15,\n+        lchown = 16,\n+        break_ = 17,\n+        oldstat = 18,\n+        lseek = 19,\n+        getpid = 20,\n+        mount = 21,\n+        umount = 22,\n+        setuid = 23,\n+        getuid = 24,\n+        stime = 25,\n+        ptrace = 26,\n+        alarm = 27,\n+        oldfstat = 28,\n+        pause = 29,\n+        utime = 30,\n+        stty = 31,\n+        gtty = 32,\n+        access = 33,\n+        nice = 34,\n+        ftime = 35,\n+        sync = 36,\n+        kill = 37,\n+        rename = 38,\n+        mkdir = 39,\n+        rmdir = 40,\n+        dup = 41,\n+        pipe = 42,\n+        times = 43,\n+        prof = 44,\n+        brk = 45,\n+        setgid = 46,\n+        getgid = 47,\n+        signal = 48,\n+        geteuid = 49,\n+        getegid = 50,\n+        acct = 51,\n+        umount2 = 52,\n+        lock = 53,\n+        ioctl = 54,\n+        fcntl = 55,\n+        mpx = 56,\n+        setpgid = 57,\n+        ulimit = 58,\n+        oldolduname = 59,\n+        umask = 60,\n+        chroot = 61,\n+        ustat = 62,\n+        dup2 = 63,\n+        getppid = 64,\n+        getpgrp = 65,\n+        setsid = 66,\n+        sigaction = 67,\n+        sgetmask = 68,\n+        ssetmask = 69,\n+        setreuid = 70,\n+        setregid = 71,\n+        sigsuspend = 72,\n+        sigpending = 73,\n+        sethostname = 74,\n+        setrlimit = 75,\n+        getrlimit = 76,\n+        getrusage = 77,\n+        gettimeofday = 78,\n+        settimeofday = 79,\n+        getgroups = 80,\n+        setgroups = 81,\n+        select = 82,\n+        symlink = 83,\n+        oldlstat = 84,\n+        readlink = 85,\n+        uselib = 86,\n+        swapon = 87,\n+        reboot = 88,\n+        readdir = 89,\n+        mmap = 90,\n+        munmap = 91,\n+        truncate = 92,\n+        ftruncate = 93,\n+        fchmod = 94,\n+        fchown = 95,\n+        getpriority = 96,\n+        setpriority = 97,\n+        profil = 98,\n+        statfs = 99,\n+        fstatfs = 100,\n+        ioperm = 101,\n+        socketcall = 102,\n+        syslog = 103,\n+        setitimer = 104,\n+        getitimer = 105,\n+        stat = 106,\n+        lstat = 107,\n+        fstat = 108,\n+        olduname = 109,\n+        iopl = 110,\n+        vhangup = 111,\n+        idle = 112,\n+        vm86old = 113,\n+        wait4 = 114,\n+        swapoff = 115,\n+        sysinfo = 116,\n+        ipc = 117,\n+        fsync = 118,\n+        sigreturn = 119,\n+        clone = 120,\n+        setdomainname = 121,\n+        uname = 122,\n+        modify_ldt = 123,\n+        adjtimex = 124,\n+        mprotect = 125,\n+        sigprocmask = 126,\n+        create_module = 127,\n+        init_module = 128,\n+        delete_module = 129,\n+        get_kernel_syms = 130,\n+        quotactl = 131,\n+        getpgid = 132,\n+        fchdir = 133,\n+        bdflush = 134,\n+        sysfs = 135,\n+        personality = 136,\n+        afs_syscall = 137,\n+        setfsuid = 138,\n+        setfsgid = 139,\n+        _llseek = 140,\n+        getdents = 141,\n+        _newselect = 142,\n+        flock = 143,\n+        msync = 144,\n+        readv = 145,\n+        writev = 146,\n+        getsid = 147,\n+        fdatasync = 148,\n+        _sysctl = 149,\n+        mlock = 150,\n+        munlock = 151,\n+        mlockall = 152,\n+        munlockall = 153,\n+        sched_setparam = 154,\n+        sched_getparam = 155,\n+        sched_setscheduler = 156,\n+        sched_getscheduler = 157,\n+        sched_yield = 158,\n+        sched_get_priority_max = 159,\n+        sched_get_priority_min = 160,\n+        sched_rr_get_interval = 161,\n+        nanosleep = 162,\n+        mremap = 163,\n+        setresuid = 164,\n+        getresuid = 165,\n+        vm86 = 166,\n+        query_module = 167,\n+        poll = 168,\n+        nfsservctl = 169,\n+        setresgid = 170,\n+        getresgid = 171,\n+        prctl = 172,\n+        rt_sigreturn = 173,\n+        rt_sigaction = 174,\n+        rt_sigprocmask = 175,\n+        rt_sigpending = 176,\n+        rt_sigtimedwait = 177,\n+        rt_sigqueueinfo = 178,\n+        rt_sigsuspend = 179,\n+        pread64 = 180,\n+        pwrite64 = 181,\n+        chown = 182,\n+        getcwd = 183,\n+        capget = 184,\n+        capset = 185,\n+        sigaltstack = 186,\n+        sendfile = 187,\n+        getpmsg = 188,\n+        putpmsg = 189,\n+        vfork = 190,\n+        ugetrlimit = 191,\n+        mmap2 = 192,\n+        truncate64 = 193,\n+        ftruncate64 = 194,\n+        stat64 = 195,\n+        lstat64 = 196,\n+        fstat64 = 197,\n+        lchown32 = 198,\n+        getuid32 = 199,\n+        getgid32 = 200,\n+        geteuid32 = 201,\n+        getegid32 = 202,\n+        setreuid32 = 203,\n+        setregid32 = 204,\n+        getgroups32 = 205,\n+        setgroups32 = 206,\n+        fchown32 = 207,\n+        setresuid32 = 208,\n+        getresuid32 = 209,\n+        setresgid32 = 210,\n+        getresgid32 = 211,\n+        chown32 = 212,\n+        setuid32 = 213,\n+        setgid32 = 214,\n+        setfsuid32 = 215,\n+        setfsgid32 = 216,\n+        pivot_root = 217,\n+        mincore = 218,\n+        madvise = 219,\n+        getdents64 = 220,\n+        fcntl64 = 221,\n+        gettid = 224,\n+        readahead = 225,\n+        setxattr = 226,\n+        lsetxattr = 227,\n+        fsetxattr = 228,\n+        getxattr = 229,\n+        lgetxattr = 230,\n+        fgetxattr = 231,\n+        listxattr = 232,\n+        llistxattr = 233,\n+        flistxattr = 234,\n+        removexattr = 235,\n+        lremovexattr = 236,\n+        fremovexattr = 237,\n+        tkill = 238,\n+        sendfile64 = 239,\n+        futex = 240,\n+        sched_setaffinity = 241,\n+        sched_getaffinity = 242,\n+        set_thread_area = 243,\n+        get_thread_area = 244,\n+        io_setup = 245,\n+        io_destroy = 246,\n+        io_getevents = 247,\n+        io_submit = 248,\n+        io_cancel = 249,\n+        fadvise64 = 250,\n+        exit_group = 252,\n+        lookup_dcookie = 253,\n+        epoll_create = 254,\n+        epoll_ctl = 255,\n+        epoll_wait = 256,\n+        remap_file_pages = 257,\n+        set_tid_address = 258,\n+        timer_create = 259,\n+        timer_settime = 260,\n+        timer_gettime = 261,\n+        timer_getoverrun = 262,\n+        timer_delete = 263,\n+        clock_settime = 264,\n+        clock_gettime = 265,\n+        clock_getres = 266,\n+        clock_nanosleep = 267,\n+        statfs64 = 268,\n+        fstatfs64 = 269,\n+        tgkill = 270,\n+        utimes = 271,\n+        fadvise64_64 = 272,\n+        vserver = 273,\n+        mbind = 274,\n+        get_mempolicy = 275,\n+        set_mempolicy = 276,\n+        mq_open = 277,\n+        mq_unlink = 278,\n+        mq_timedsend = 279,\n+        mq_timedreceive = 280,\n+        mq_notify = 281,\n+        mq_getsetattr = 282,\n+        kexec_load = 283,\n+        waitid = 284,\n+        add_key = 286,\n+        request_key = 287,\n+        keyctl = 288,\n+        ioprio_set = 289,\n+        ioprio_get = 290,\n+        inotify_init = 291,\n+        inotify_add_watch = 292,\n+        inotify_rm_watch = 293,\n+        migrate_pages = 294,\n+        openat = 295,\n+        mkdirat = 296,\n+        mknodat = 297,\n+        fchownat = 298,\n+        futimesat = 299,\n+        fstatat64 = 300,\n+        unlinkat = 301,\n+        renameat = 302,\n+        linkat = 303,\n+        symlinkat = 304,\n+        readlinkat = 305,\n+        fchmodat = 306,\n+        faccessat = 307,\n+        pselect6 = 308,\n+        ppoll = 309,\n+        unshare = 310,\n+        set_robust_list = 311,\n+        get_robust_list = 312,\n+        splice = 313,\n+        sync_file_range = 314,\n+        tee = 315,\n+        vmsplice = 316,\n+        move_pages = 317,\n+        getcpu = 318,\n+        epoll_pwait = 319,\n+        utimensat = 320,\n+        signalfd = 321,\n+        timerfd_create = 322,\n+        eventfd = 323,\n+        fallocate = 324,\n+        timerfd_settime = 325,\n+        timerfd_gettime = 326,\n+        signalfd4 = 327,\n+        eventfd2 = 328,\n+        epoll_create1 = 329,\n+        dup3 = 330,\n+        pipe2 = 331,\n+        inotify_init1 = 332,\n+        preadv = 333,\n+        pwritev = 334,\n+        rt_tgsigqueueinfo = 335,\n+        perf_event_open = 336,\n+        recvmmsg = 337,\n+        fanotify_init = 338,\n+        fanotify_mark = 339,\n+        prlimit64 = 340,\n+        name_to_handle_at = 341,\n+        open_by_handle_at = 342,\n+        clock_adjtime = 343,\n+        syncfs = 344,\n+        sendmmsg = 345,\n+        setns = 346,\n+        process_vm_readv = 347,\n+        process_vm_writev = 348,\n+        kcmp = 349,\n+        finit_module = 350,\n+        sched_setattr = 351,\n+        sched_getattr = 352,\n+        renameat2 = 353,\n+        seccomp = 354,\n+        getrandom = 355,\n+        memfd_create = 356,\n+        bpf = 357,\n+        execveat = 358,\n+        socket = 359,\n+        socketpair = 360,\n+        bind = 361,\n+        connect = 362,\n+        listen = 363,\n+        accept4 = 364,\n+        getsockopt = 365,\n+        setsockopt = 366,\n+        getsockname = 367,\n+        getpeername = 368,\n+        sendto = 369,\n+        sendmsg = 370,\n+        recvfrom = 371,\n+        recvmsg = 372,\n+        shutdown = 373,\n+        userfaultfd = 374,\n+        membarrier = 375,\n+        mlock2 = 376,\n+        copy_file_range = 377,\n+        preadv2 = 378,\n+        pwritev2 = 379,\n+        pkey_mprotect = 380,\n+        pkey_alloc = 381,\n+        pkey_free = 382,\n+        statx = 383,\n+        arch_prctl = 384,\n+    }\n+}"}, {"sha": "1ef16c12689c151935a41a7dd02341befe0d52d4", "filename": "libphobos/libdruntime/core/sys/linux/unistd.d", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Funistd.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Funistd.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Funistd.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -1,16 +1,20 @@\n module core.sys.linux.unistd;\n \n-public import core.sys.posix.unistd;\n-\n version (linux):\n-extern(C):\n+extern (C):\n nothrow:\n @system:\n+@nogc:\n+\n+public import core.sys.posix.unistd;\n+public import core.sys.linux.syscalls : SystemCall;\n+import core.stdc.config : c_long;\n \n // Additional seek constants for sparse file handling\n // from Linux's unistd.h, stdio.h, and linux/fs.h\n // (see http://man7.org/linux/man-pages/man2/lseek.2.html)\n-enum {\n+enum\n+{\n     /// Offset is relative to the next location containing data\n     SEEK_DATA = 3,\n     /// Offset is relative to the next hole (or EOF if file is not sparse)\n@@ -22,3 +26,17 @@ char* getpass(const(char)* prompt);\n \n // Exit all threads in a process\n void exit_group(int status);\n+\n+/**\n+Invoke system call specified by number, passing it the remaining arguments.\n+This is completely system-dependent, and not often useful.\n+\n+In Unix, `syscall' sets `errno' for all errors and most calls return -1\n+for errors; in many systems you cannot pass arguments or get return\n+values for all system calls (`pipe', `fork', and `getppid' typically\n+among them).\n+\n+In Mach, all system calls take normal arguments and always return an\n+error code (zero for success).\n+*/\n+c_long syscall(SystemCall number, ...) @nogc nothrow;"}, {"sha": "b28dc63d5c72dc302e4b6cccc26a64f4d036f3c6", "filename": "libphobos/libdruntime/core/sys/openbsd/dlfcn.d", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fdlfcn.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fdlfcn.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fdlfcn.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -1,7 +1,7 @@\n /**\n  * D header file for OpenBSD.\n  *\n- * $(LINK2 http://cvsweb.openbsd.org/cgi-bin/cvsweb/src/include/link_elf.h?rev=1.6&content-type=text/x-cvsweb-markup, dlfcn.h)\n+ * $(LINK2 https://cvsweb.openbsd.org/cgi-bin/cvsweb/~checkout~/src/include/dlfcn.h?rev=1.15&content-type=text/plain, dlfcn.h)\n  */\n module core.sys.openbsd.dlfcn;\n \n@@ -16,6 +16,7 @@ static assert(RTLD_NOW    == 2);\n static assert(RTLD_GLOBAL == 0x100);\n static assert(RTLD_LOCAL  == 0);\n enum RTLD_TRACE           =  0x200;\n+enum RTLD_NODELETE        =  0x400;\n \n enum RTLD_NEXT    = cast(void *)-1;\n enum RTLD_DEFAULT = cast(void *)-2;\n@@ -24,6 +25,7 @@ enum RTLD_SELF    = cast(void *)-3;\n enum DL_GETERRNO     = 1;\n enum DL_SETTHREADLCK = 2;\n enum DL_SETBINDLCK   = 3;\n+enum DL_REFERENCE    = 4;\n \n enum DL_LAZY         = RTLD_LAZY;\n "}, {"sha": "8344df239500693865f0bffcf9c23d00fa64dea2", "filename": "libphobos/libdruntime/core/sys/openbsd/pthread_np.d", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fpthread_np.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fpthread_np.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fpthread_np.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -0,0 +1,23 @@\n+/**\n+  * D header file for OpenBSD pthread_np.h.\n+  *\n+  * Copyright: Copyright \u00a9 2021, The D Language Foundation\n+  * License: <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\n+  * Authors: Brian Callahan\n+  */\n+module core.sys.openbsd.pthread_np;\n+\n+version (OpenBSD):\n+extern (C):\n+nothrow:\n+@nogc:\n+\n+public import core.sys.posix.sys.types;\n+import core.sys.posix.signal : stack_t;\n+\n+int pthread_mutexattr_getkind_np(pthread_mutexattr_t);\n+int pthread_mutexattr_setkind_np(pthread_mutexattr_t*, int);\n+void pthread_get_name_np(pthread_t, char*, size_t);\n+void pthread_set_name_np(pthread_t, const(char)*);\n+int pthread_stackseg_np(pthread_t, stack_t*);\n+int pthread_main_np();"}, {"sha": "c8c2b1b659fd17680df21f5216f8f6f077c86701", "filename": "libphobos/libdruntime/core/sys/openbsd/stdlib.d", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fstdlib.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fstdlib.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fstdlib.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -13,5 +13,11 @@ extern (C):\n nothrow:\n @nogc:\n \n+void freezero(void*, size_t);\n+void* calloc_conceal(size_t, size_t);\n+void* malloc_conceal(size_t);\n+void* reallocarray(void*, size_t, size_t);\n+void* recallocarray(void*, size_t, size_t, size_t);\n+\n const(char)* getprogname();\n-void setprogname(scope const char* name);\n+void setprogname(scope const char*);"}, {"sha": "131e67727e8de37fa6c389ee4f92946662d1a96f", "filename": "libphobos/libdruntime/core/sys/openbsd/string.d", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fstring.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fstring.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fstring.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -17,7 +17,13 @@ nothrow:\n \n static if (__BSD_VISIBLE)\n {\n+    void explicit_bzero(void*, size_t);\n     pure void* memmem(return const void* haystack, size_t haystacklen, scope const void* needle, size_t needlelen);\n+    void* memrchr(scope const void*, int, size_t);\n+    size_t strlcat(char*, scope const char*, size_t);\n+    size_t strlcpy(char*, scope const char*, size_t);\n+    void strmode(int, char*);\n+    char* strsep(char**, scope const char*);\n     pure int timingsafe_bcmp(scope const void*, scope const void*, size_t);\n     pure int timingsafe_memcmp(scope const void*, scope const void*, size_t);\n }"}, {"sha": "765483436ac55b973d226e9f6a192ebee42c280b", "filename": "libphobos/libdruntime/core/sys/openbsd/sys/mman.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fsys%2Fmman.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fsys%2Fmman.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fsys%2Fmman.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -19,11 +19,12 @@ import core.sys.posix.sys.types;\n // enum MAP_PRIVATE = 0x0002;\n // enum MAP_FIXED = 0x0010;\n // enum MAP_ANON = 0x1000;\n+// enum MAP_STACK = 0x4000;\n \n alias MAP_ANONYMOUS = MAP_ANON;\n-enum MAP_STACK = 0x4000;\n+enum MAP_CONCEAL = 0x8000;\n \n-enum MAP_FLAGMASK = 0x7ff7;\n+enum MAP_FLAGMASK = 0xfff7;\n \n alias MAP_COPY = MAP_PRIVATE;\n enum MAP_FILE = 0;\n@@ -45,7 +46,6 @@ static if (__BSD_VISIBLE)\n     enum MADV_FREE = 6;\n \n     int madvise(void *, size_t, int);\n-    int mincore(const(void) *, size_t, char *);\n     int minherit(void *, size_t, int);\n     void* mquery(void *, size_t, int, int, int, off_t);\n }"}, {"sha": "3a4524245aab19410d353f902e9fefd2542aeb5e", "filename": "libphobos/libdruntime/core/sys/openbsd/sys/sysctl.d", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fsys%2Fsysctl.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fsys%2Fsysctl.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fsys%2Fsysctl.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -250,5 +250,4 @@ enum\n }\n \n ///\n-int sysctl(const int* name, uint namelen, void* oldp, size_t* oldlenp,\n-           const void* newp, size_t newlen);\n+int sysctl(const int*, uint, void*, size_t*, void*, size_t);"}, {"sha": "0b8580fb86090022ea46a701731ee2939521e013", "filename": "libphobos/libdruntime/core/sys/openbsd/unistd.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Funistd.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Funistd.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Funistd.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -6,12 +6,12 @@\n   * Authors: Brian Callahan\n   */\n module core.sys.openbsd.unistd;\n-public import core.sys.posix.unistd;\n \n version (OpenBSD):\n extern (C):\n nothrow:\n @nogc:\n \n+int getentropy(void*, size_t);\n int pledge(const scope char*, const scope char*);\n int unveil(const scope char*, const scope char*);"}, {"sha": "d1411ea8afbaadc4923d1dbc7c30edf808b2b88f", "filename": "libphobos/libdruntime/core/sys/posix/netdb.d", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fnetdb.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fnetdb.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fnetdb.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -567,6 +567,7 @@ else version (OpenBSD)\n     enum AI_NUMERICHOST     = 0x4;\n     enum AI_EXT             = 0x8;\n     enum AI_NUMERICSERV     = 0x10;\n+    enum AI_V4MAPPED        = 0; // Not supported\n     enum AI_FQDN            = 0x20;\n     enum AI_ADDRCONFIG      = 0x40;\n     enum AI_MASK            = AI_PASSIVE | AI_CANONNAME | AI_NUMERICHOST | AI_NUMERICSERV | AI_FQDN | AI_ADDRCONFIG;"}, {"sha": "a8d837c52b675f814a7805347166f9879da7b4b6", "filename": "libphobos/libdruntime/core/sys/posix/sys/filio.d", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Ffilio.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Ffilio.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Ffilio.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -34,3 +34,15 @@ version (Darwin)\n     enum uint FIOGETOWN = _IOR!(int)('f', 123); // get owner\n     enum uint FIODTYPE  = _IOR!(int)('f', 122); // get d_type\n }\n+\n+version (OpenBSD)\n+{\n+    // File-descriptor ioctl's\n+    enum uint FIOCLEX   = _IO('f', 1);         // set close on exec on fd\n+    enum uint FIONCLEX  = _IO('f', 2);         // remove close on exec\n+    enum uint FIONREAD  = _IOR!(int)('f', 127); // get # bytes to read\n+    enum uint FIONBIO   = _IOW!(int)('f', 126); // set/clear non-blocking i/o\n+    enum uint FIOASYNC  = _IOW!(int)('f', 125); // set/clear async i/o\n+    enum uint FIOSETOWN = _IOW!(int)('f', 124); // set owner\n+    enum uint FIOGETOWN = _IOR!(int)('f', 123); // get owner\n+}"}, {"sha": "4a0e96b3ea9af3a1af6d8a2fb497f12583de3a6d", "filename": "libphobos/libdruntime/core/sys/posix/sys/ioccom.d", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fioccom.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fioccom.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fioccom.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -137,3 +137,59 @@ else version (FreeBSD)\n         return _IOC(IOC_INOUT, cast(uint)g, cast(uint)n, T.sizeof);\n     }\n }\n+else version (OpenBSD)\n+{\n+    /* OpenBSD ioctl's encode the command in the lower 16-bits\n+     * and the size of any in/out parameters in the lower 13 bits of the upper\n+     * 16-bits of a 32 bit unsigned integer. The high 3 bits of the upper\n+     * 16-bits encode the in/out status of the parameter.\n+     */\n+    enum uint IOCPARM_MASK = 0x1fff; // parameter length mask\n+    uint IOCPARM_LEN(uint x) // to extract the encoded parameter length\n+    {\n+        return ((x >> 16) & IOCPARM_MASK);\n+    }\n+    uint IOCBASECMD(uint x) // to extract the encoded command\n+    {\n+        return (x & ~(IOCPARM_MASK << 16));\n+    }\n+    uint IOCGROUP(uint x) // to extract the encoded group\n+    {\n+        return ((x >> 8) & 0xff);\n+    }\n+\n+    enum uint IOCPARM_MAX = (1 << 12); // max size of ioctl args\n+\n+    enum uint IOC_VOID = 0x20000000; // no parameters\n+    enum uint IOC_OUT = 0x40000000; // copy parameters back\n+    enum uint IOC_IN = 0x80000000; // copy parameters into\n+    enum uint IOC_INOUT = (IOC_IN | IOC_OUT);\n+    enum uint IOC_DIRMASK = 0xe0000000;\n+\n+    // encode the ioctl info into 32 bits\n+    uint _IOC(uint inorout, uint group, uint num, size_t len)\n+    {\n+        return (inorout | ((len & IOCPARM_MASK) << 16) | (group << 8) | num);\n+    }\n+\n+    // encode a command with no parameters\n+    uint _IO(char g, int n)\n+    {\n+        return _IOC(IOC_VOID, cast(uint)g, cast(uint)n, cast(size_t)0);\n+    }\n+    // encode a command that returns info\n+    uint _IOR(T)(char g, int n)\n+    {\n+        return _IOC(IOC_OUT, cast(uint)g, cast(uint)n, T.sizeof);\n+    }\n+    // encode a command that takes info\n+    uint _IOW(T)(char g, int n)\n+    {\n+        return _IOC(IOC_IN, cast(uint)g, cast(uint)n, T.sizeof);\n+    }\n+    // encode a command that takes info and returns info\n+    uint _IOWR(T)(char g, int n)\n+    {\n+        return _IOC(IOC_INOUT, cast(uint)g, cast(uint)n, T.sizeof);\n+    }\n+}"}, {"sha": "c6f21d6cd0a87093b334c388984aafe56b5ab680", "filename": "libphobos/libdruntime/core/sys/posix/sys/ioctl.d", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fioctl.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fioctl.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fioctl.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -375,6 +375,11 @@ else version (NetBSD)\n }\n else version (OpenBSD)\n {\n+    import core.sys.posix.termios; // termios\n+    import core.sys.posix.sys.time; // timeval\n+\n+    public import core.sys.posix.sys.ttycom; // Terminal related ioctls\n+\n     struct winsize\n     {\n         ushort ws_row;\n@@ -383,6 +388,8 @@ else version (OpenBSD)\n         ushort ws_ypixel;\n     }\n \n+    public import core.sys.posix.sys.filio; // File related ioctls\n+\n     int ioctl(int, c_ulong, ...);\n }\n else version (DragonFlyBSD)"}, {"sha": "18da10246e4957b359de5e3080f024cc4d023331", "filename": "libphobos/libdruntime/core/sys/posix/sys/mman.d", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fmman.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fmman.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fmman.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -460,6 +460,7 @@ else version (OpenBSD)\n     enum MAP_PRIVATE    = 0x0002;\n     enum MAP_FIXED      = 0x0010;\n     enum MAP_ANON       = 0x1000;\n+    enum MAP_STACK      = 0x4000;\n \n     enum MAP_FAILED     = cast(void*)-1;\n "}, {"sha": "de51c6a474671f4ae5fb4a34532073aeaabaf41c", "filename": "libphobos/libdruntime/core/sys/posix/sys/socket.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fsocket.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fsocket.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fsocket.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -536,7 +536,8 @@ version (CRuntime_Glibc)\n \n     enum\n     {\n-        SOMAXCONN       = 128\n+        // https://sourceware.org/git/?p=glibc.git;a=commit;f=sysdeps/unix/sysv/linux/bits/socket.h;h=96958e2700f5b4f4d1183a0606b2b9848a53ea44\n+        SOMAXCONN       = 4096\n     }\n \n     enum : uint"}, {"sha": "0cc2d9cdc8424203c2656fe31f0e867ca3f0b049", "filename": "libphobos/libdruntime/core/sys/posix/sys/ttycom.d", "status": "modified", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fttycom.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fttycom.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fttycom.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -214,3 +214,104 @@ else version (FreeBSD)\n     enum uint NETGRAPHDISC = 6;   // Netgraph tty node discipline\n     enum uint H4DISC   = 7;       // Netgraph Blutooth H4 discipline\n }\n+else version (OpenBSD)\n+{\n+    struct winsize {\n+        ushort  ws_row;     // rows, in characters\n+        ushort  ws_col;     // columns, in characters\n+        ushort  ws_xpixel;  // horizontal size, pixels\n+        ushort  ws_ypixel;  // vertical size, pixels\n+    }\n+\n+    struct tstamps {\n+        int ts_set;         // TIOCM_CAR and/or TIOCM_CTS\n+        int ts_clr;\n+    }\n+\n+    // Serial/TTY ioctl's\n+                                               // 0-2 compat\n+                                               // 3-7 unused\n+                                               // 8-10 compat\n+                                               // 11-12 unused\n+    enum uint TIOCEXCL  = _IO('t', 13);        // set exclusive use of tty\n+    enum uint TIOCNXCL  = _IO('t', 14);        // reset exclusive use of tty\n+    enum uint TIOCFLUSH = _IOW!(int)('t', 16); // flush buffers\n+                            // 17-18 compat\n+    enum uint TIOCGETA  = _IOR!(termios)('t', 19); // get termios struct\n+    enum uint TIOCSETA  = _IOW!(termios)('t', 20); // set termios struct\n+    enum uint TIOCSETAW = _IOW!(termios)('t', 21); // drain output, set\n+    enum uint TIOCSETAF = _IOW!(termios)('t', 22); // drn out, fls in, set\n+                            // 23-25 unused\n+    enum uint TIOCGETD  = _IOR!(int)('t', 26); // get line discipline\n+    enum uint TIOCSETD  = _IOW!(int)('t', 27); // set line discipline\n+    enum uint TIOCSETVERAUTH = _IOW!(int)('t', 28);     // set verified auth\n+    enum uint TIOCCLRVERAUTH = _IO('t', 29);     // clear verified auth\n+    enum uint TIOCCHKVERAUTH = _IO('t', 30);     // check verified auth\n+                            // 31-89 unused\n+    enum uint TIOCSTSTAMP = _IOW!(tstamps)('t', 90); // timestamp reasons\n+    enum uint TIOCGTSTAMP = _IOR!(timeval)('t', 91); // get timestamp\n+                            // 92-93 device flags\n+    enum uint TIOCSFLAGS = _IOW!(int)('t', 92); // set device flags\n+    enum uint TIOCGFLAGS = _IOR!(int)('t', 93); // get device flags\n+                            // 94-97 conflicts: tun and tap\n+    enum uint TIOCDRAIN = _IO('t', 94); // wait till output drained\n+    enum uint TIOCSIG   = _IOW!(int)('t', 95); // pty: generate signal\n+    enum uint TIOCEXT   = _IOW!(int)('t', 96); // pty: external processing\n+    enum uint TIOCSCTTY = _IO('t', 97);        // become controlling tty\n+    enum uint TIOCCONS  = _IOW!(int)('t', 98); // become virtual console\n+    enum uint TIOCGSID  = _IOR!(int)('t', 99); // get session id\n+                            // 100 unused\n+    enum uint TIOCSTAT  = _IO('t', 101);       // simulate ^T status message\n+    enum uint TIOCUCNTL = _IOW!(int)('t', 102); // pty: set/clr usr cntl mode\n+    enum uint   UIOCCMD(n) = _IO('u', n);       // usr cntl op \"n\"\n+    enum uint TIOCSWINSZ = _IOW!(winsize)('t', 103); // set window size\n+    enum uint TIOCGWINSZ = _IOR!(winsize)('t', 104); // get window size\n+    enum uint TIOCREMOTE = _IOW!(int)('t', 105); // remote input editing\n+    enum uint TIOCMGET  = _IOR!(int)('t', 106); // get all modem bits\n+    enum uint   TIOCM_LE  = 0x01;               // line enable\n+    enum uint   TIOCM_DTR = 0x02;               // data terminal ready\n+    enum uint   TIOCM_RTS = 0x04;               // request to send\n+    enum uint   TIOCM_ST  = 0x08;               // secondary transmit\n+    enum uint   TIOCM_SR  = 0x10;               // secondary receive\n+    enum uint   TIOCM_CTS = 0x20;               // clear to send\n+    enum uint   TIOCM_CAR = 0x40;               // carrier detect\n+    enum uint   TIOCM_RNG = 0x80;               // ring\n+    enum uint   TIOCM_DSR = 0x100;              // data set ready\n+    enum uint   TIOCM_CD  = TIOCM_CAR;\n+    enum uint   TIOCM_RI = TIOCM_RNG;\n+    enum uint TIOCMBIC  = _IOW!(int)('t', 107); // bic modem bits\n+    enum uint TIOCMBIS  = _IOW!(int)('t', 108); // bis modem bits\n+    enum uint TIOCMSET  = _IOW!(int)('t', 109); // set all modem bits\n+    enum uint TIOCSTART = _IO('t', 110);        // start output like ^Q\n+    enum uint TIOCSTOP  = _IO('t', 111);        // stop output like ^S\n+    enum uint TIOCPKT   = _IOW!(int)('t', 112); // pty: set/clr packet mode\n+    enum uint TIOCPKT_DATA       = 0x00;        // data packet\n+    enum uint TIOCPKT_FLUSHREAD  = 0x01;        // flush packet\n+    enum uint TIOCPKT_FLUSHWRITE = 0x02;        // flush packet\n+    enum uint TIOCPKT_STOP       = 0x04;        // stop output\n+    enum uint TIOCPKT_START      = 0x08;        // start output\n+    enum uint TIOCPKT_NOSTOP     = 0x10;        // no more ^S, ^Q\n+    enum uint TIOCPKT_DOSTOP     = 0x20;        // now do ^S, ^Q\n+    enum uint TIOCPKT_IOCTL      = 0x40;        // state change of pty driver\n+    enum uint TIOCNOTTY = _IO('t', 113);        // void tty association\n+                             // 114 unused\n+    enum uint TIOCOUTQ  = _IOR!(int)('t', 115); // output queue size\n+                             // 116-117 compat\n+    enum uint TIOCSPGRP = _IOW!(int)('t', 118); // set pgrp of tty\n+    enum uint TIOCGPGRP = _IOR!(int)('t', 119); // get pgrp of tty\n+\n+    enum uint TIOCCDTR  = _IO('t', 120);       // clear data terminal ready\n+    enum uint TIOCSDTR  = _IO('t', 121);       // set data terminal ready\n+    enum uint TIOCCBRK  = _IO('t', 122);       // clear break bit\n+    enum uint TIOCSBRK  = _IO('t', 123);       // set break bit\n+                            // 124-127 compat\n+\n+    enum uint TTYDISC  = 0;       // termios tty line discipline\n+    enum uint TABLDISC = 3;       // tablet description\n+    enum uint SLIPDISC = 4;       // serial IP discipline\n+    enum uint PPPDISC  = 5;       // PPP discipline\n+    enum uint STRIPDISC = 6;      // metricom wireless IP discipline\n+    enum uint NMEADISC = 7;       // NMEA0183 discipline\n+    enum uint MSTSDISC = 8;       // Meinberg time string discipline\n+    enum uint ENDRUNDISC = 9;     // Endrun time format discipline\n+}"}, {"sha": "a9be87c859797df64f6d76e01aafbf408d1eeb77", "filename": "libphobos/libdruntime/core/sys/posix/time.d", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Ftime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Ftime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Ftime.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -341,11 +341,6 @@ else version (OpenBSD)\n     int clock_gettime(clockid_t, timespec*);\n     int clock_settime(clockid_t, const scope timespec*);\n     int nanosleep(const scope timespec*, timespec*);\n-    int timer_create(clockid_t, sigevent*, timer_t*);\n-    int timer_delete(timer_t);\n-    int timer_gettime(timer_t, itimerspec*);\n-    int timer_getoverrun(timer_t);\n-    int timer_settime(timer_t, int, const scope itimerspec*, itimerspec*);\n }\n else version (Solaris)\n {"}, {"sha": "e967da6ed63b8e5252cc7104116710e5182f6e01", "filename": "libphobos/libdruntime/core/sys/windows/accctrl.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Faccctrl.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Faccctrl.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Faccctrl.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Stewart Gordon\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_accctrl.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_accctrl.d)\n  */\n module core.sys.windows.accctrl;\n version (Windows):"}, {"sha": "f145ac26af028d2dc141b7c720b102cb0739961a", "filename": "libphobos/libdruntime/core/sys/windows/aclapi.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Faclapi.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Faclapi.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Faclapi.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Stewart Gordon\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_aclapi.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_aclapi.d)\n  */\n module core.sys.windows.aclapi;\n version (Windows):"}, {"sha": "c5a28992631728a3642f7318c4bf1129a314b598", "filename": "libphobos/libdruntime/core/sys/windows/aclui.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Faclui.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Faclui.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Faclui.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Stewart Gordon\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_aclui.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_aclui.d)\n  */\n module core.sys.windows.aclui;\n version (Windows):"}, {"sha": "0c689024aaaeaa71325513a93d6958a2481ad29f", "filename": "libphobos/libdruntime/core/sys/windows/basetsd.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fbasetsd.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fbasetsd.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fbasetsd.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Stewart Gordon\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_basetsd.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_basetsd.d)\n  */\n module core.sys.windows.basetsd;\n version (Windows):"}, {"sha": "086e6ab30e32ba0679462ae40fa117aa05ed372c", "filename": "libphobos/libdruntime/core/sys/windows/basetyps.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fbasetyps.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fbasetyps.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fbasetyps.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW API for MS-Windows 3.10\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_basetyps.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_basetyps.d)\n  */\n module core.sys.windows.basetyps;\n version (Windows):"}, {"sha": "afcdf272743533bef8ea4c4b90aaef5ac19b67b9", "filename": "libphobos/libdruntime/core/sys/windows/cderr.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcderr.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcderr.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcderr.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW Windows headers\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_cderr.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_cderr.d)\n  */\n module core.sys.windows.cderr;\n version (Windows):"}, {"sha": "0afbc42e8b03f394186e7fae63b01b9a4938d078", "filename": "libphobos/libdruntime/core/sys/windows/cguid.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcguid.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcguid.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcguid.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW Windows headers\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_cguid.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_cguid.d)\n  */\n module core.sys.windows.cguid;\n version (Windows):"}, {"sha": "3018c64d7f078486d7045afb21bc05951b35f956", "filename": "libphobos/libdruntime/core/sys/windows/comcat.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcomcat.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcomcat.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcomcat.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Stewart Gordon\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_comcat.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_comcat.d)\n  */\n module core.sys.windows.comcat;\n version (Windows):"}, {"sha": "4bc60b1fd8b3a7a5223e54deb1c5f0e5a4d82ca2", "filename": "libphobos/libdruntime/core/sys/windows/commctrl.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcommctrl.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcommctrl.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcommctrl.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW API for MS-Windows 3.12\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_commctrl.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_commctrl.d)\n  */\n module core.sys.windows.commctrl;\n version (Windows):"}, {"sha": "b49d2fba6feb177571b0793e7c2858eb76e5cfc3", "filename": "libphobos/libdruntime/core/sys/windows/commdlg.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcommdlg.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcommdlg.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcommdlg.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW API for MS-Windows 3.12\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_commdlg.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_commdlg.d)\n  */\n module core.sys.windows.commdlg;\n version (Windows):"}, {"sha": "e8bc4a7bcc81a8791274ed4078ab1c9685ceb204", "filename": "libphobos/libdruntime/core/sys/windows/core.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcore.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcore.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcore.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -2,7 +2,7 @@\n  * Helper module for the Windows API\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_core.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_core.d)\n  */\n module core.sys.windows.core;\n version (Windows):"}, {"sha": "49ebb208c74eaa051ad848d8056ab20fb1a47f85", "filename": "libphobos/libdruntime/core/sys/windows/cpl.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcpl.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcpl.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcpl.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Stewart Gordon\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_cpl.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_cpl.d)\n  */\n module core.sys.windows.cpl;\n version (Windows):"}, {"sha": "e13316bcec959bcd6809e86adb8f5a6692e8e75c", "filename": "libphobos/libdruntime/core/sys/windows/cplext.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcplext.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcplext.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcplext.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Stewart Gordon\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_cplext.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_cplext.d)\n  */\n module core.sys.windows.cplext;\n version (Windows):"}, {"sha": "c736cb31a9cc51af5a25d81d9f38a21a0b15f365", "filename": "libphobos/libdruntime/core/sys/windows/custcntl.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcustcntl.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcustcntl.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcustcntl.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Stewart Gordon\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_custcntl.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_custcntl.d)\n  */\n module core.sys.windows.custcntl;\n version (Windows):"}, {"sha": "308c609a9ba20c8d73cee6b31b4f2f5dce458da8", "filename": "libphobos/libdruntime/core/sys/windows/dbt.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fdbt.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fdbt.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fdbt.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Vladimir Vlasov\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_dbt.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_dbt.d)\n  */\n module core.sys.windows.dbt;\n version (Windows):"}, {"sha": "bec339c223c590395c829f46c9636d710b1e50b8", "filename": "libphobos/libdruntime/core/sys/windows/dde.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fdde.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fdde.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fdde.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Stewart Gordon\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_dde.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_dde.d)\n  */\n module core.sys.windows.dde;\n version (Windows):"}, {"sha": "22b330cfc47f473ba7611e9db2881f8ecb7ae7e8", "filename": "libphobos/libdruntime/core/sys/windows/ddeml.d", "status": "modified", "additions": 43, "deletions": 33, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fddeml.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fddeml.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fddeml.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Stewart Gordon\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_ddeml.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_ddeml.d)\n  */\n module core.sys.windows.ddeml;\n version (Windows):\n@@ -16,6 +16,11 @@ pragma(lib, \"user32\");\n \n import core.sys.windows.basetsd, core.sys.windows.windef, core.sys.windows.winnt;\n \n+mixin DECLARE_HANDLE!(\"HCONVLIST\");\n+mixin DECLARE_HANDLE!(\"HCONV\");\n+mixin DECLARE_HANDLE!(\"HSZ\");\n+mixin DECLARE_HANDLE!(\"HDDEDATA\");\n+\n enum : int {\n     CP_WINANSI    = 1004,\n     CP_WINUNICODE = 1200\n@@ -76,10 +81,13 @@ enum : UINT {\n     XTYP_SHIFT           = 4\n }\n \n-/+\n-#define TIMEOUT_ASYNC  0xFFFFFFFF\n-#define QID_SYNC       0xFFFFFFFF\n-+/\n+enum : UINT {\n+    TIMEOUT_ASYNC = 0xFFFFFFFF\n+}\n+\n+enum : UINT {\n+    QID_SYNC      = 0xFFFFFFFF\n+}\n \n enum : UINT {\n     ST_CONNECTED  =   1,\n@@ -93,9 +101,9 @@ enum : UINT {\n     ST_ISSELF     = 256\n }\n \n-/+\n-#define CADV_LATEACK 0xFFFF\n-+/\n+enum : UINT {\n+    CADV_LATEACK  = 0xFFFF\n+}\n \n enum : UINT {\n     DMLERR_NO_ERROR      = 0,\n@@ -121,22 +129,26 @@ enum : UINT {\n     DMLERR_LAST          = DMLERR_UNFOUND_QUEUE_ID\n }\n \n-/+\n-#define DDE_FACK    0x8000\n-#define DDE_FBUSY   0x4000\n-#define DDE_FDEFERUPD   0x4000\n-#define DDE_FACKREQ 0x8000\n-#define DDE_FRELEASE    0x2000\n-#define DDE_FREQUESTED  0x1000\n-#define DDE_FAPPSTATUS  0x00ff\n-#define DDE_FNOTPROCESSED   0\n-#define DDE_FACKRESERVED    (~(DDE_FACK|DDE_FBUSY|DDE_FAPPSTATUS))\n-#define DDE_FADVRESERVED    (~(DDE_FACKREQ|DDE_FDEFERUPD))\n-#define DDE_FDATRESERVED    (~(DDE_FACKREQ|DDE_FRELEASE|DDE_FREQUESTED))\n-#define DDE_FPOKRESERVED    (~DDE_FRELEASE)\n-#define MSGF_DDEMGR 0x8001\n-#define CBR_BLOCK   ((HDDEDATA)0xffffffff)\n-+/\n+enum : UINT {\n+    DDE_FACK            = 0x8000,\n+    DDE_FBUSY           = 0x4000,\n+    DDE_FDEFERUPD       = 0x4000,\n+    DDE_FACKREQ         = 0x8000,\n+    DDE_FRELEASE        = 0x2000,\n+    DDE_FREQUESTED      = 0x1000,\n+    DDE_FAPPSTATUS      = 0x00ff,\n+    DDE_FNOTPROCESSED   = 0,\n+    DDE_FACKRESERVED    = (~(DDE_FACK|DDE_FBUSY|DDE_FAPPSTATUS)),\n+    DDE_FADVRESERVED    = (~(DDE_FACKREQ|DDE_FDEFERUPD)),\n+    DDE_FDATRESERVED    = (~(DDE_FACKREQ|DDE_FRELEASE|DDE_FREQUESTED)),\n+    DDE_FPOKRESERVED    = (~DDE_FRELEASE)\n+}\n+\n+enum : UINT {\n+    MSGF_DDEMGR         = 0x8001\n+}\n+\n+enum CBR_BLOCK = cast(HDDEDATA)-1;\n \n enum DWORD\n     APPCLASS_STANDARD         = 0,\n@@ -180,10 +192,13 @@ enum : UINT {\n     DNS_FILTEROFF  = 8\n }\n \n-/+\n-#define HDATA_APPOWNED  1\n-#define MAX_MONITORS    4\n-+/\n+enum : UINT {\n+    HDATA_APPOWNED = 1\n+}\n+\n+enum : UINT {\n+    MAX_MONITORS   = 4\n+}\n \n enum : int {\n     MH_CREATE  = 1,\n@@ -192,11 +207,6 @@ enum : int {\n     MH_CLEANUP = 4\n }\n \n-mixin DECLARE_HANDLE!(\"HCONVLIST\");\n-mixin DECLARE_HANDLE!(\"HCONV\");\n-mixin DECLARE_HANDLE!(\"HSZ\");\n-mixin DECLARE_HANDLE!(\"HDDEDATA\");\n-\n extern (Windows) alias HDDEDATA\n   function(UINT, UINT, HCONV, HSZ, HSZ, HDDEDATA, ULONG_PTR, ULONG_PTR) PFNCALLBACK;\n "}, {"sha": "0d3d71690b8ac0b75141ec52c746f8e18d9f6a78", "filename": "libphobos/libdruntime/core/sys/windows/dhcpcsdk.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fdhcpcsdk.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fdhcpcsdk.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fdhcpcsdk.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Stewart Gordon\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_dhcpcsdk.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_dhcpcsdk.d)\n  */\n module core.sys.windows.dhcpcsdk;\n version (Windows):"}, {"sha": "34cab9bea2aec9b30d328a92f07b37d26963699e", "filename": "libphobos/libdruntime/core/sys/windows/dlgs.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fdlgs.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fdlgs.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fdlgs.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Stewart Gordon\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_dlgs.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_dlgs.d)\n  */\n module core.sys.windows.dlgs;\n version (Windows):"}, {"sha": "d602347f2a3d0554ecad00fca7cc38022f5d8620", "filename": "libphobos/libdruntime/core/sys/windows/dll.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fdll.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fdll.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fdll.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -6,7 +6,7 @@\n  *      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).\n  *    (See accompanying file LICENSE)\n  * Authors:   Rainer Schuetze\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_dll.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_dll.d)\n  */\n \n /* NOTE: This file has been patched from the original DMD distribution to\n@@ -573,10 +573,10 @@ bool dll_thread_detach( bool detach_thread = true, bool exitTls = true )\n /// ---\n mixin template SimpleDllMain()\n {\n-    import core.sys.windows.windef : HINSTANCE;\n+    import core.sys.windows.windef : HINSTANCE, BOOL, DWORD, LPVOID;\n \n     extern(Windows)\n-    bool DllMain(HINSTANCE hInstance, uint ulReason, void* reserved)\n+    BOOL DllMain(HINSTANCE hInstance, DWORD ulReason, LPVOID reserved)\n     {\n         import core.sys.windows.winnt;\n         import core.sys.windows.dll :"}, {"sha": "4e45693eb3da4677a36f4ec631aadc0aedc69d69", "filename": "libphobos/libdruntime/core/sys/windows/docobj.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fdocobj.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fdocobj.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fdocobj.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW Windows headers\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_docobj.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_docobj.d)\n  */\n module core.sys.windows.docobj;\n version (Windows):"}, {"sha": "63ec8d75746235bd94674da0590ee6cd6926842d", "filename": "libphobos/libdruntime/core/sys/windows/errorrep.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Ferrorrep.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Ferrorrep.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Ferrorrep.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Stewart Gordon\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_errorrep.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_errorrep.d)\n  */\n module core.sys.windows.errorrep;\n version (Windows):"}, {"sha": "8ee3c26737172740857e63d977b639773b6fa6e4", "filename": "libphobos/libdruntime/core/sys/windows/exdisp.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fexdisp.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fexdisp.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fexdisp.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW Windows headers\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_exdisp.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_exdisp.d)\n  */\n module core.sys.windows.exdisp;\n version (Windows):"}, {"sha": "8257476cf551c766b3a128dc56e829006dc23f2b", "filename": "libphobos/libdruntime/core/sys/windows/exdispid.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fexdispid.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fexdispid.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fexdispid.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Stewart Gordon\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_exdispid.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_exdispid.d)\n  */\n module core.sys.windows.exdispid;\n version (Windows):"}, {"sha": "4e07c6aa15c71f080f1c6a25bcb4f2c8778682eb", "filename": "libphobos/libdruntime/core/sys/windows/httpext.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fhttpext.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fhttpext.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fhttpext.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW Windows headers\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_httpext.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_httpext.d)\n  */\n module core.sys.windows.httpext;\n version (Windows):"}, {"sha": "c2d5becd8f3b27d00335e9f5ea5adf1e17921dc3", "filename": "libphobos/libdruntime/core/sys/windows/idispids.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fidispids.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fidispids.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fidispids.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Stewart Gordon\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_idispids.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_idispids.d)\n  */\n module core.sys.windows.idispids;\n version (Windows):"}, {"sha": "ed93746d7f6b2ff39cd52baa9158dbb14fdbbe10", "filename": "libphobos/libdruntime/core/sys/windows/imagehlp.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fimagehlp.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fimagehlp.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fimagehlp.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Stewart Gordon\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_imagehlp.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_imagehlp.d)\n  */\n module core.sys.windows.imagehlp;\n version (Windows):"}, {"sha": "128fd56e87ceff38392d6937b79e2f3f40c90ef2", "filename": "libphobos/libdruntime/core/sys/windows/imm.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fimm.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fimm.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fimm.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW Windows headers\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_imm.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_imm.d)\n  */\n module core.sys.windows.imm;\n version (Windows):"}, {"sha": "eab7a8dafe24c4821fce74c01c442a9c67a4c0d9", "filename": "libphobos/libdruntime/core/sys/windows/intshcut.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fintshcut.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fintshcut.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fintshcut.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Stewart Gordon\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_intshcut.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_intshcut.d)\n  */\n module core.sys.windows.intshcut;\n version (Windows):"}, {"sha": "dbb4a0eb5ff65e72c19d903b9d9593f0d66cca5a", "filename": "libphobos/libdruntime/core/sys/windows/ipexport.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fipexport.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fipexport.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fipexport.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Stewart Gordon\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_ipexport.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_ipexport.d)\n  */\n module core.sys.windows.ipexport;\n version (Windows):"}, {"sha": "f95e79909356714398a9c10c60ab5510ad6ffebd", "filename": "libphobos/libdruntime/core/sys/windows/iphlpapi.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fiphlpapi.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fiphlpapi.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fiphlpapi.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Stewart Gordon\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_iphlpapi.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_iphlpapi.d)\n  */\n module core.sys.windows.iphlpapi;\n version (Windows):"}, {"sha": "09606f5d53379f8dbef87296276ce1d41adfca12", "filename": "libphobos/libdruntime/core/sys/windows/ipifcons.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fipifcons.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fipifcons.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fipifcons.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Stewart Gordon\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_ipifcons.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_ipifcons.d)\n  */\n module core.sys.windows.ipifcons;\n version (Windows):"}, {"sha": "3db453908a18da16c01b4b93b6eed11d32384b92", "filename": "libphobos/libdruntime/core/sys/windows/iprtrmib.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fiprtrmib.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fiprtrmib.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fiprtrmib.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Stewart Gordon\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_iprtrmib.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_iprtrmib.d)\n  */\n module core.sys.windows.iprtrmib;\n version (Windows):"}, {"sha": "7cce34b0ebeea2603d5b52b0b11a55d668e40f65", "filename": "libphobos/libdruntime/core/sys/windows/iptypes.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fiptypes.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fiptypes.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fiptypes.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Stewart Gordon\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_iptypes.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_iptypes.d)\n  */\n module core.sys.windows.iptypes;\n version (Windows):"}, {"sha": "b166c39cabcbffc623dd9e8492961dd7f7d4415a", "filename": "libphobos/libdruntime/core/sys/windows/isguids.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fisguids.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fisguids.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fisguids.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Stewart Gordon\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_isguids.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_isguids.d)\n  */\n module core.sys.windows.isguids;\n version (Windows):"}, {"sha": "3d488564e575a6f13dc0b4038fa8501e9966d02b", "filename": "libphobos/libdruntime/core/sys/windows/lm.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flm.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flm.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flm.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW Windows headers\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_lm.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_lm.d)\n  */\n module core.sys.windows.lm;\n version (Windows):"}, {"sha": "b23e52ed6f9bfa2fb60db3a14568c27351f91bdf", "filename": "libphobos/libdruntime/core/sys/windows/lmaccess.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmaccess.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmaccess.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmaccess.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW Windows headers\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_lmaccess.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_lmaccess.d)\n  */\n module core.sys.windows.lmaccess;\n version (Windows):"}, {"sha": "5ddd6d0988c7b12b0da591151cfa2190cc718feb", "filename": "libphobos/libdruntime/core/sys/windows/lmalert.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmalert.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmalert.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmalert.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW Windows headers\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_lmalert.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_lmalert.d)\n  */\n module core.sys.windows.lmalert;\n version (Windows):"}, {"sha": "e8559543f3eafb51810fabd8b259549800c4a8c7", "filename": "libphobos/libdruntime/core/sys/windows/lmapibuf.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmapibuf.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmapibuf.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmapibuf.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW Windows headers\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_lmapibuf.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_lmapibuf.d)\n  */\n module core.sys.windows.lmapibuf;\n version (Windows):"}, {"sha": "3e1468a0e83f15400129ff0fb7d5a14e748faf91", "filename": "libphobos/libdruntime/core/sys/windows/lmat.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmat.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmat.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmat.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW Windows headers\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_lmat.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_lmat.d)\n  */\n module core.sys.windows.lmat;\n version (Windows):"}, {"sha": "f4a7ca243e843b3ff59ca0bf4fce8c6c61286a36", "filename": "libphobos/libdruntime/core/sys/windows/lmaudit.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmaudit.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmaudit.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmaudit.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW Windows headers\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_lmaudit.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_lmaudit.d)\n  */\n // COMMENT: This file may be deprecated.\n module core.sys.windows.lmaudit;"}, {"sha": "ea0e0f38ced3bc59ed35b6bf7ec8018d6f5b4ff1", "filename": "libphobos/libdruntime/core/sys/windows/lmbrowsr.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmbrowsr.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmbrowsr.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmbrowsr.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW Windows headers\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_lmbrowsr.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_lmbrowsr.d)\n  */\n module core.sys.windows.lmbrowsr;\n version (Windows):"}, {"sha": "00aaafcf50dac908f9c1cac5b12e25a2a4f02fbc", "filename": "libphobos/libdruntime/core/sys/windows/lmchdev.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmchdev.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmchdev.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmchdev.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW Windows headers\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_lmchdev.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_lmchdev.d)\n  */\n module core.sys.windows.lmchdev;\n version (Windows):"}, {"sha": "57d3ed938fbd683ab80fc220f2fd1add568095cf", "filename": "libphobos/libdruntime/core/sys/windows/lmconfig.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmconfig.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmconfig.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmconfig.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW Windows headers\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_lmconfig.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_lmconfig.d)\n  */\n module core.sys.windows.lmconfig;\n version (Windows):"}, {"sha": "69a63df0f195d1207bdd9e14ccd14d04175c60dd", "filename": "libphobos/libdruntime/core/sys/windows/lmcons.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmcons.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmcons.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmcons.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW Windows headers\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_lmcons.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_lmcons.d)\n  */\n module core.sys.windows.lmcons;\n version (Windows):"}, {"sha": "d50ec49dcb87a6c3ef26aca391da36556a49edcd", "filename": "libphobos/libdruntime/core/sys/windows/lmerr.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmerr.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmerr.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmerr.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW Windows headers\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_lmerr.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_lmerr.d)\n  */\n module core.sys.windows.lmerr;\n version (Windows):"}, {"sha": "a49b49888250055e7aec776886fba92a2f8dbb3b", "filename": "libphobos/libdruntime/core/sys/windows/lmerrlog.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmerrlog.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmerrlog.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmerrlog.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW Windows headers\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_lmerrlog.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_lmerrlog.d)\n  */\n module core.sys.windows.lmerrlog;\n version (Windows):"}, {"sha": "c87f1e00ed39d999604f18e9885926c7f4606f8f", "filename": "libphobos/libdruntime/core/sys/windows/lmmsg.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmmsg.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmmsg.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmmsg.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW Windows headers\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_lmmsg.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_lmmsg.d)\n  */\n module core.sys.windows.lmmsg;\n version (Windows):"}, {"sha": "d0f3b41cc38886fd12a30110cc895b3f9db2971b", "filename": "libphobos/libdruntime/core/sys/windows/lmremutl.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmremutl.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmremutl.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmremutl.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW Windows headers\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_lmremutl.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_lmremutl.d)\n  */\n module core.sys.windows.lmremutl;\n version (Windows):"}, {"sha": "093588ca84e935526154a6eb8d92ca5609e54a99", "filename": "libphobos/libdruntime/core/sys/windows/lmrepl.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmrepl.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmrepl.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmrepl.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW Windows headers\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_lmrepl.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_lmrepl.d)\n  */\n module core.sys.windows.lmrepl;\n version (Windows):"}, {"sha": "fad5bc509c4d2a60e81264e179e495670d11ab8a", "filename": "libphobos/libdruntime/core/sys/windows/lmserver.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmserver.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmserver.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmserver.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW Windows headers\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_lmserver.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_lmserver.d)\n  */\n module core.sys.windows.lmserver;\n version (Windows):"}, {"sha": "d81080edda1b7a474dac59f877f366d3c350cd27", "filename": "libphobos/libdruntime/core/sys/windows/lmshare.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmshare.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmshare.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmshare.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW Windows headers\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_lmshare.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_lmshare.d)\n  */\n module core.sys.windows.lmshare;\n version (Windows):"}, {"sha": "09b1b00cb6d5063da0a7ec7d218fd8bac9b03887", "filename": "libphobos/libdruntime/core/sys/windows/lmsname.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmsname.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmsname.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmsname.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW Windows headers\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_lmsname.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_lmsname.d)\n  */\n module core.sys.windows.lmsname;\n version (Windows):"}, {"sha": "4baa3903b158bc82922cea4882cc5b5f8b772b10", "filename": "libphobos/libdruntime/core/sys/windows/lmstats.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmstats.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmstats.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmstats.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW Windows headers\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_lmstats.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_lmstats.d)\n  */\n module core.sys.windows.lmstats;\n version (Windows):"}, {"sha": "c0df69902e02fd7d70c3b48623e98ed892b21383", "filename": "libphobos/libdruntime/core/sys/windows/lmsvc.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmsvc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmsvc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmsvc.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW Windows headers\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_lmsvc.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_lmsvc.d)\n  */\n module core.sys.windows.lmsvc;\n version (Windows):"}, {"sha": "03e153abea87ea0a090814e23935f66f9d01e028", "filename": "libphobos/libdruntime/core/sys/windows/lmuse.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmuse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmuse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmuse.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW Windows headers\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_lmuse.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_lmuse.d)\n  */\n module core.sys.windows.lmuse;\n version (Windows):"}, {"sha": "06276c3e44486efebbaacf1809023637f522b1ba", "filename": "libphobos/libdruntime/core/sys/windows/lmuseflg.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmuseflg.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmuseflg.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmuseflg.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW API for MS-Windows 3.10\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_lmuseflg.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_lmuseflg.d)\n  */\n module core.sys.windows.lmuseflg;\n version (Windows):"}, {"sha": "cdd3a0703658e80f1d0111794282d15a0f6964f0", "filename": "libphobos/libdruntime/core/sys/windows/lmwksta.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmwksta.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmwksta.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flmwksta.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW Windows headers\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_lmwksta.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_lmwksta.d)\n  */\n module core.sys.windows.lmwksta;\n version (Windows):"}, {"sha": "a01489bef57ed0cbf1796ce6d2ff7230b79ac20e", "filename": "libphobos/libdruntime/core/sys/windows/lzexpand.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flzexpand.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flzexpand.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Flzexpand.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW Windows headers\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_lzexpand.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_lzexpand.d)\n  */\n module core.sys.windows.lzexpand;\n version (Windows):"}, {"sha": "06fd955611caa6091301a58f78dc6ae3015dfa07", "filename": "libphobos/libdruntime/core/sys/windows/mapi.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fmapi.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fmapi.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fmapi.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Stewart Gordon\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_mapi.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_mapi.d)\n  */\n module core.sys.windows.mapi;\n version (Windows):"}, {"sha": "4e3d14e0b6a346b82fb8cc47fc1f2bd91541cc45", "filename": "libphobos/libdruntime/core/sys/windows/mciavi.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fmciavi.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fmciavi.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fmciavi.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Stewart Gordon\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_mciavi.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_mciavi.d)\n  */\n module core.sys.windows.mciavi;\n version (Windows):"}, {"sha": "0322413013702566c22c8bac99405c7207ffea7f", "filename": "libphobos/libdruntime/core/sys/windows/mcx.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fmcx.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fmcx.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fmcx.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Stewart Gordon\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_mcx.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_mcx.d)\n  */\n module core.sys.windows.mcx;\n version (Windows):"}, {"sha": "d9fb6b72a9c09fd0a12f82c5a42f55b0f978aa36", "filename": "libphobos/libdruntime/core/sys/windows/mgmtapi.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fmgmtapi.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fmgmtapi.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fmgmtapi.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Stewart Gordon\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_mgmtapi.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_mgmtapi.d)\n  */\n module core.sys.windows.mgmtapi;\n version (Windows):"}, {"sha": "5c3d92071181f15be55733282376c1bd9824e633", "filename": "libphobos/libdruntime/core/sys/windows/mmsystem.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fmmsystem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fmmsystem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fmmsystem.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW Windows headers\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_mmsystem.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_mmsystem.d)\n  */\n module core.sys.windows.mmsystem;\n version (Windows):"}, {"sha": "47263282fb19793da546177da56ca7ff908ab193", "filename": "libphobos/libdruntime/core/sys/windows/msacm.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fmsacm.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fmsacm.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fmsacm.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Stewart Gordon\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_msacm.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_msacm.d)\n  */\n module core.sys.windows.msacm;\n version (Windows):"}, {"sha": "d5cf7cbc012fca836cea7ad5c89ec855f06a3965", "filename": "libphobos/libdruntime/core/sys/windows/mshtml.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fmshtml.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fmshtml.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fmshtml.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -4,7 +4,7 @@\n  * Translated from MinGW Windows headers\n  *\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_mshtml.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_mshtml.d)\n  */\n module core.sys.windows.mshtml;\n version (Windows):"}, {"sha": "27c0cdb5bb2f792561d4beff2334efb55478dd80", "filename": "libphobos/libdruntime/core/sys/windows/mswsock.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fmswsock.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fmswsock.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fmswsock.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Daniel Keep\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_mswsock.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_mswsock.d)\n  */\n module core.sys.windows.mswsock;\n version (Windows):"}, {"sha": "8f92eddba1789b37c5213d25063248e1fec0c081", "filename": "libphobos/libdruntime/core/sys/windows/nb30.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fnb30.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fnb30.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fnb30.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Stewart Gordon\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_nb30.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_nb30.d)\n  */\n module core.sys.windows.nb30;\n version (Windows):"}, {"sha": "dc3890c61181780dc45ee338377e24645aec4657", "filename": "libphobos/libdruntime/core/sys/windows/nddeapi.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fnddeapi.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fnddeapi.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fnddeapi.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Stewart Gordon\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_nddeapi.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_nddeapi.d)\n  */\n module core.sys.windows.nddeapi;\n version (Windows):"}, {"sha": "79c9fceb45c9ef0fb72de35a55dff6356b718fcb", "filename": "libphobos/libdruntime/core/sys/windows/nspapi.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fnspapi.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb57034770aa20adced4d176f34ca611c2945bf/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fnspapi.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fnspapi.d?ref=0fb57034770aa20adced4d176f34ca611c2945bf", "patch": "@@ -5,7 +5,7 @@\n  *\n  * Authors: Stewart Gordon\n  * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source: $(DRUNTIMESRC src/core/sys/windows/_nspapi.d)\n+ * Source: $(DRUNTIMESRC core/sys/windows/_nspapi.d)\n  */\n module core.sys.windows.nspapi;\n version (Windows):"}]}