{"sha": "a995e389c4aed94fbfc35bd283ade7dd775add7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTk5NWUzODljNGFlZDk0ZmJmYzM1YmQyODNhZGU3ZGQ3NzVhZGQ3Yw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-09-12T12:46:08Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-09-12T12:46:08Z"}, "message": "Replace insn_foo with insn_data.foo.\n\nFrom-SVN: r29358", "tree": {"sha": "c2582159a30e1f83f4d7b7bcd2806fb8331123b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2582159a30e1f83f4d7b7bcd2806fb8331123b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a995e389c4aed94fbfc35bd283ade7dd775add7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a995e389c4aed94fbfc35bd283ade7dd775add7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a995e389c4aed94fbfc35bd283ade7dd775add7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a995e389c4aed94fbfc35bd283ade7dd775add7c/comments", "author": null, "committer": null, "parents": [{"sha": "ddf16f18413b904c1b524e9d385aabd394fa5d7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddf16f18413b904c1b524e9d385aabd394fa5d7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddf16f18413b904c1b524e9d385aabd394fa5d7b"}], "stats": {"total": 1554, "additions": 864, "deletions": 690}, "files": [{"sha": "4ba402ee2cda8e724eb79283509eb8f670eec606", "filename": "gcc/ChangeLog", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -1,3 +1,87 @@\n+Sun Sep 12 05:00:24 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* recog.h (insn_template, insn_outfun, insn_n_operands, insn_n_dups,\n+\tinsn_n_alternatives, insn_operand_constraint, insn_operand_address_p,\n+\tinsn_operand_mode, insn_operand_strict_low, insn_operand_predicate,\n+\tinsn_name): Delete and consolidate into new structures.\n+\t(insn_operand_predicate_fn): New.\n+\t(insn_output_fn): New.\n+\t(insn_gen_fn): New.\n+\t(struct insn_operand_data): New.\n+\t(struct insn_data): New.\n+\t(insn_data): New.\n+\t(OUT_FCN): Update for insn_data change.\n+\t* builtins.c (expand_builtin_strlen): Likewise.\n+\t(expand_builtin_memcmp): Likewise.\n+\t* combine.c (make_extraction, simplify_comparison): Likewise.\n+\t* cse.c (canon_reg, cse_insn): Likewise.\n+\t* explow.c (allocate_dynamic_stack_space, probe_stack_range): Likewise.\n+\t* expmed.c (store_bit_field, extract_bit_field): Likewise.\n+\t(emit_store_flag): Likewise.\n+\t* expr.c (convert_move, emit_block_move): Likewise.\n+\t(clear_storage, emit_push_insn, expand_increment): Likewise.\n+\t(do_store_flag): Likewise.\n+\t* expr.h (GEN_FCN): Likewise.\n+\t(insn_gen_function): Die.\n+\t* final.c (final_scan_insn): Update for insn_data change.\n+\t(output_asm_name): Likewise.\n+\t* function.c (fixup_var_refs_1): Likewise.\n+\t* loop.c (check_dbra_loop): Likewise.\n+\t* optabs.c (expand_binop, expand_twoval_binop): Likewise.\n+\t(expand_unop, expand_complex_abs, emit_unop_insn): Likewise.\n+\t(prepare_cmp_insn, prepare_operand, emit_indirect_jump): Likewise.\n+\t(emit_conditional_move, gen_add2_insn, gen_sub2_insn): Likewise.\n+\t* recog.c (validate_replace_rtx_1, extract_insn): Likewise.\n+\t* regmove.c (gen_add3_insn): Likewise.\n+\t* reload.c (push_secondary_reload, combine_reloads): Likewise.\n+\t(find_reloads, find_reloads_address_1): Likewise.\n+\t(debug_reload_to_stream): Likewise.\n+\t* reload1.c (emit_reload_insns, gen_reload): Likewise.\n+\t* stmt.c (expand_end_case): Likewise.\n+\t* toplev.c (compile_file): Likewise.\n+\n+\t* c4x/c4x.c (c4x_process_after_reload): Likewise.\n+\t* i860/i860.c (output_delayed_branch, output_delay_insn): Likewise.\n+\n+\t* print-rtl.c (insn_name_ptr): Remove declaration.\n+\t(get_insn_name): Declare.\n+\t(print_rtx): Use it.\n+\t* genoutput.c (insn_name_ptr): Remove.\n+\t(next_operand_number): New.\n+\t(struct operand_data): New.\n+\t(null_operand, odata, odata_end): New.\n+\t(struct data): Use struct operand_data.\n+\t(idata, idata_end): Renamed from insn_data and end_of_insn_data.\n+\t(get_insn_name): Renamed from name_for_index.\n+\t(output_prologue): Define NO_MD_PROTOTYPES.\n+\t(output_predicate_decls): Break out from output_epilogue.\n+\tIterate over the operands list.\n+\t(output_operand_data): Break out from output_epilogue.  Emit\n+\tjust the operands list.\n+\t(output_insn_data): Break out from output_epilogue.  Emit just\n+\tthe insn data.\n+\t(output_epilogue): Remove.\n+\t(output_get_insn_name): New.\n+\t(constraints, op_n_alternatives, predicates, address_p): Die.\n+\t(modes, strict_low, seen): Die.\n+\t(scan_operands): Take new param `d' instead of writing to \n+\tseven global variables.\n+\t(compare_operands): New.\n+\t(place_operands): New.\n+\t(validate_insn_alternatives): Update for struct data change.\n+\t(gen_insn): Don't zero or copy 7 global arrays.  Update for\n+\tscan_operands; call place_operands.\n+\t(gen_peephole, gen_expand, gen_split): Likewise.\n+\t(main): Update for new output routines.\n+\n+\t* genattr.c (insn_name_ptr): Remove.\n+\t(get_insn_name): New function.\n+\t* genattrtab.c, gencodes.c, genconfig.c, genemit.c: Likewise.\n+\t* genextract.c, genflags.c, genopinit.c, genpeep.c: Likewise.\n+\t* genrecog.c: Likewise.\n+\n+\t* alpha.md (adddi3): Make `pattern' array static.\n+\n Sun Sep 12 22:05:21 1999  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* config/c4x/c4x.h (c4x_rpts_cycles_string,"}, {"sha": "2d211f9c1a51dbe3f386fbf137ac1fc62ac05039", "filename": "gcc/builtins.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -1334,13 +1334,13 @@ expand_builtin_strlen (exp, target, mode)\n \n       /* Make sure the operands are acceptable to the predicates.  */\n \n-      if (! (*insn_operand_predicate[(int)icode][0]) (result, insn_mode))\n+      if (! (*insn_data[(int)icode].operand[0].predicate) (result, insn_mode))\n \tresult = gen_reg_rtx (insn_mode);\n       src_rtx = memory_address (BLKmode,\n \t\t\t\texpand_expr (src, NULL_RTX, ptr_mode,\n \t\t\t\t\t     EXPAND_NORMAL));\n \n-      if (! (*insn_operand_predicate[(int)icode][1]) (src_rtx, Pmode))\n+      if (! (*insn_data[(int)icode].operand[1].predicate) (src_rtx, Pmode))\n \tsrc_rtx = copy_to_mode_reg (Pmode, src_rtx);\n \n       /* Check the string is readable and has an end.  */\n@@ -1351,8 +1351,8 @@ expand_builtin_strlen (exp, target, mode)\n \t\t\t   TYPE_MODE (integer_type_node));\n \n       char_rtx = const0_rtx;\n-      char_mode = insn_operand_mode[(int)icode][2];\n-      if (! (*insn_operand_predicate[(int)icode][2]) (char_rtx, char_mode))\n+      char_mode = insn_data[(int)icode].operand[2].mode;\n+      if (! (*insn_data[(int)icode].operand[2].predicate) (char_rtx, char_mode))\n \tchar_rtx = copy_to_mode_reg (char_mode, char_rtx);\n \n       emit_insn (GEN_FCN (icode) (result,\n@@ -1572,7 +1572,7 @@ expand_builtin_memcmp (exp, arglist, target)\n     int arg2_align\n       = get_pointer_alignment (arg2, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n     enum machine_mode insn_mode\n-      = insn_operand_mode[(int) CODE_FOR_cmpstrsi][0];\n+      = insn_data[(int) CODE_FOR_cmpstrsi].operand[0].mode;\n \n     /* If we don't have POINTER_TYPE, call the function.  */\n     if (arg1_align == 0 || arg2_align == 0)"}, {"sha": "56a373b3805baa7a58cf0fe12e8a155cedcdf68c", "filename": "gcc/combine.c", "status": "modified", "additions": 34, "deletions": 25, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -5752,44 +5752,53 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n   if (in_dest)\n     {\n       wanted_inner_reg_mode\n-\t= (insn_operand_mode[(int) CODE_FOR_insv][0] == VOIDmode\n-\t   ? word_mode\n-\t   : insn_operand_mode[(int) CODE_FOR_insv][0]);\n-      pos_mode = (insn_operand_mode[(int) CODE_FOR_insv][2] == VOIDmode\n-\t\t  ? word_mode : insn_operand_mode[(int) CODE_FOR_insv][2]);\n-      extraction_mode = (insn_operand_mode[(int) CODE_FOR_insv][3] == VOIDmode\n-\t\t\t ? word_mode\n-\t\t\t : insn_operand_mode[(int) CODE_FOR_insv][3]);\n+\t= insn_data[(int) CODE_FOR_insv].operand[0].mode;\n+      if (wanted_inner_reg_mode == VOIDmode)\n+\twanted_inner_reg_mode = word_mode;\n+\n+      pos_mode = insn_data[(int) CODE_FOR_insv].operand[2].mode;\n+      if (pos_mode == VOIDmode)\n+\tpos_mode = word_mode;\n+\n+      extraction_mode = insn_data[(int) CODE_FOR_insv].operand[3].mode;\n+      if (extraction_mode == VOIDmode)\n+\textraction_mode = word_mode;\n     }\n #endif\n \n #ifdef HAVE_extzv\n   if (! in_dest && unsignedp)\n     {\n       wanted_inner_reg_mode\n-\t= (insn_operand_mode[(int) CODE_FOR_extzv][1] == VOIDmode\n-\t   ? word_mode\n-\t   : insn_operand_mode[(int) CODE_FOR_extzv][1]);\n-      pos_mode = (insn_operand_mode[(int) CODE_FOR_extzv][3] == VOIDmode\n-\t\t  ? word_mode : insn_operand_mode[(int) CODE_FOR_extzv][3]);\n-      extraction_mode = (insn_operand_mode[(int) CODE_FOR_extzv][0] == VOIDmode\n-\t\t\t ? word_mode\n-\t\t\t : insn_operand_mode[(int) CODE_FOR_extzv][0]);\n+\t= insn_data[(int) CODE_FOR_extzv].operand[1].mode;\n+      if (wanted_inner_reg_mode == VOIDmode)\n+\twanted_inner_reg_mode = word_mode;\n+\n+      pos_mode = insn_data[(int) CODE_FOR_extzv].operand[3].mode;\n+      if (pos_mode == VOIDmode)\n+\tpos_mode = word_mode;\n+\n+      extraction_mode = insn_data[(int) CODE_FOR_extzv].operand[0].mode;\n+      if (extraction_mode == VOIDmode)\n+\textraction_mode = word_mode;\n     }\n #endif\n \n #ifdef HAVE_extv\n   if (! in_dest && ! unsignedp)\n     {\n       wanted_inner_reg_mode\n-\t= (insn_operand_mode[(int) CODE_FOR_extv][1] == VOIDmode\n-\t   ? word_mode\n-\t   : insn_operand_mode[(int) CODE_FOR_extv][1]);\n-      pos_mode = (insn_operand_mode[(int) CODE_FOR_extv][3] == VOIDmode\n-\t\t  ? word_mode : insn_operand_mode[(int) CODE_FOR_extv][3]);\n-      extraction_mode = (insn_operand_mode[(int) CODE_FOR_extv][0] == VOIDmode\n-\t\t\t ? word_mode\n-\t\t\t : insn_operand_mode[(int) CODE_FOR_extv][0]);\n+\t= insn_data[(int) CODE_FOR_extv].operand[1].mode;\n+      if (wanted_inner_reg_mode == VOIDmode)\n+\twanted_inner_reg_mode = word_mode;\n+\n+      pos_mode = insn_data[(int) CODE_FOR_extv].operand[3].mode;\n+      if (pos_mode == VOIDmode)\n+\tpos_mode = word_mode;\n+\n+      extraction_mode = insn_data[(int) CODE_FOR_extv].operand[0].mode;\n+      if (extraction_mode == VOIDmode)\n+\textraction_mode = word_mode;\n     }\n #endif\n \n@@ -9901,7 +9910,7 @@ simplify_comparison (code, pop0, pop1)\n \t      if (BITS_BIG_ENDIAN)\n \t\t{\n #ifdef HAVE_extzv\n-\t\t  mode = insn_operand_mode[(int) CODE_FOR_extzv][1];\n+\t\t  mode = insn_data[(int) CODE_FOR_extzv].operand[1].mode;\n \t\t  if (mode == VOIDmode)\n \t\t    mode = word_mode;\n \t\t  i = (GET_MODE_BITSIZE (mode) - 1 - i);"}, {"sha": "b3f5a54345eda6609e16c7b174f3f036b913ee08", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -2196,7 +2196,7 @@ c4x_process_after_reload (first)\n \t    {\n \t      const char *template;\n \n-\t      template = insn_template[insn_code_number];\n+\t      template = insn_data[insn_code_number].template;\n \t      if (template && template[0] == '#' && template[1] == '\\0')\n \t\t{\n \t\t  rtx new = try_split (PATTERN(insn), insn, 0);"}, {"sha": "a6e9458a8b928046bddaf49c56bd1db4694c9e70", "filename": "gcc/config/i860/i860.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fconfig%2Fi860%2Fi860.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fconfig%2Fi860%2Fi860.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.c?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -1446,7 +1446,7 @@ output_delayed_branch (template, operands, insn)\n       if (insn_code_number == -1)\n \tabort ();\n \n-      for (i = 0; i < insn_n_operands[insn_code_number]; i++)\n+      for (i = 0; i < insn_data[insn_code_number].n_operands; i++)\n \t{\n \t  if (GET_CODE (recog_data.operand[i]) == SUBREG)\n \t    recog_data.operand[i] = alter_subreg (recog_data.operand[i]);\n@@ -1456,9 +1456,9 @@ output_delayed_branch (template, operands, insn)\n       if (! constrain_operands (1))\n \tfatal_insn_not_found (delay_insn);\n \n-      template = insn_template[insn_code_number];\n+      template = insn_data[insn_code_number].template;\n       if (template == 0)\n-\ttemplate = ((*insn_outfun[insn_code_number])\n+\ttemplate = ((*insn_data[insn_code_number].outfun)\n \t\t    (recog_data.operand, delay_insn));\n       output_asm_insn (template, recog_data.operand);\n     }\n@@ -1490,7 +1490,7 @@ output_delay_insn (delay_insn)\n      yet.  If this insn's operands don't appear in the peephole's\n      actual operands, then they won't be fixed up by final, so we\n      make sure they get fixed up here.  -- This is a kludge.  */\n-  for (i = 0; i < insn_n_operands[insn_code_number]; i++)\n+  for (i = 0; i < insn_data[insn_code_number].n_operands; i++)\n     {\n       if (GET_CODE (recog_data.operand[i]) == SUBREG)\n \trecog_data.operand[i] = alter_subreg (recog_data.operand[i]);\n@@ -1513,9 +1513,9 @@ output_delay_insn (delay_insn)\n   /* Now get the template for what this insn would\n      have been, without the branch.  */\n \n-  template = insn_template[insn_code_number];\n+  template = insn_data[insn_code_number].template;\n   if (template == 0)\n-    template = ((*insn_outfun[insn_code_number])\n+    template = ((*insn_data[insn_code_number].outfun)\n \t\t(recog_data.operand, delay_insn));\n   output_asm_insn (template, recog_data.operand);\n   return \"\";"}, {"sha": "75952b0e128b9cf51c6645a0716c4c3dd3df0180", "filename": "gcc/cse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -2783,7 +2783,7 @@ canon_reg (x, insn)\n \t      && (((REGNO (new) < FIRST_PSEUDO_REGISTER)\n \t\t   != (REGNO (XEXP (x, i)) < FIRST_PSEUDO_REGISTER))\n \t\t  || (insn_code = recog_memoized (insn)) < 0\n-\t\t  || insn_n_dups[insn_code] > 0))\n+\t\t  || insn_data[insn_code].n_dups > 0))\n \t    validate_change (insn, &XEXP (x, i), new, 1);\n \t  else\n \t    XEXP (x, i) = new;\n@@ -6568,7 +6568,7 @@ cse_insn (insn, libcall_insn)\n \t   && ((REGNO (new) < FIRST_PSEUDO_REGISTER)\n \t       != (REGNO (src) < FIRST_PSEUDO_REGISTER)))\n \t  || (insn_code = recog_memoized (insn)) < 0\n-\t  || insn_n_dups[insn_code] > 0)\n+\t  || insn_data[insn_code].n_dups > 0)\n \tvalidate_change (insn, &SET_SRC (sets[i].rtl), new, 1);\n       else\n \tSET_SRC (sets[i].rtl) = new;"}, {"sha": "573c5295ede332bc06c9d4b544ac917ea6ee3583", "filename": "gcc/explow.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -1305,10 +1305,10 @@ allocate_dynamic_stack_space (size, target, known_align)\n   if (HAVE_allocate_stack)\n     {\n       enum machine_mode mode = STACK_SIZE_MODE;\n+      insn_operand_predicate_fn pred;\n \n-      if (insn_operand_predicate[(int) CODE_FOR_allocate_stack][0]\n-\t  && ! ((*insn_operand_predicate[(int) CODE_FOR_allocate_stack][0])\n-\t\t(target, Pmode)))\n+      pred = insn_data[(int) CODE_FOR_allocate_stack].operand[0].predicate;\n+      if (pred && ! ((*pred) (target, Pmode)))\n #ifdef POINTERS_EXTEND_UNSIGNED\n \ttarget = convert_memory_address (Pmode, target);\n #else\n@@ -1319,9 +1319,8 @@ allocate_dynamic_stack_space (size, target, known_align)\n \tmode = Pmode;\n \n       size = convert_modes (mode, ptr_mode, size, 1);\n-      if (insn_operand_predicate[(int) CODE_FOR_allocate_stack][1]\n-\t  && ! ((*insn_operand_predicate[(int) CODE_FOR_allocate_stack][1])\n-\t\t(size, mode)))\n+      pred = insn_data[(int) CODE_FOR_allocate_stack].operand[1].predicate;\n+      if (pred && ! ((*pred) (size, mode)))\n \tsize = copy_to_mode_reg (mode, size);\n \n       emit_insn (gen_allocate_stack (target, size));\n@@ -1416,15 +1415,15 @@ probe_stack_range (first, size)\n #ifdef HAVE_check_stack\n   if (HAVE_check_stack)\n     {\n+      insn_operand_predicate_fn pred;\n       rtx last_addr\n \t= force_operand (gen_rtx_STACK_GROW_OP (Pmode,\n \t\t\t\t\t\tstack_pointer_rtx,\n \t\t\t\t\t\tplus_constant (size, first)),\n \t\t\t NULL_RTX);\n \n-      if (insn_operand_predicate[(int) CODE_FOR_check_stack][0]\n-\t  && ! ((*insn_operand_predicate[(int) CODE_FOR_check_stack][0])\n-\t\t(last_addr, Pmode)))\n+      pred = insn_data[(int) CODE_FOR_check_stack].operand[0].predicate;\n+      if (pred && ! ((*pred) (last_addr, Pmode)))\n \tlast_addr = copy_to_mode_reg (Pmode, last_addr);\n \n       emit_insn (gen_check_stack (last_addr));"}, {"sha": "1ac3272e80a54e56f9e3fc0999c577e116aea6e9", "filename": "gcc/expmed.c", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -234,11 +234,12 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n   register rtx op0 = str_rtx;\n #ifdef HAVE_insv\n   int insv_bitsize;\n+  enum machine_mode op_mode;\n \n-  if (insn_operand_mode[(int) CODE_FOR_insv][3] == VOIDmode)\n-    insv_bitsize = GET_MODE_BITSIZE (word_mode);\n-  else\n-    insv_bitsize = GET_MODE_BITSIZE (insn_operand_mode[(int) CODE_FOR_insv][3]);\n+  op_mode = insn_data[(int) CODE_FOR_insv].operand[3].mode;\n+  if (op_mode == VOIDmode)\n+    op_mode = word_mode;\n+  insv_bitsize = GET_MODE_BITSIZE (op_mode);\n #endif\n \n   if (GET_CODE (str_rtx) == MEM && ! MEM_IN_STRUCT_P (str_rtx))\n@@ -349,7 +350,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n       else\n \t{\n \t  int icode = movstrict_optab->handlers[(int) fieldmode].insn_code;\n-\t  if (! (*insn_operand_predicate[icode][1]) (value, fieldmode))\n+\t  if (! (*insn_data[icode].operand[1].predicate) (value, fieldmode))\n \t    value = copy_to_mode_reg (fieldmode, value);\n \n \t  if (GET_CODE (op0) == SUBREG)\n@@ -478,7 +479,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n       enum machine_mode maxmode;\n       int save_volatile_ok = volatile_ok;\n \n-      maxmode = insn_operand_mode[(int) CODE_FOR_insv][3];\n+      maxmode = insn_data[(int) CODE_FOR_insv].operand[3].mode;\n       if (maxmode == VOIDmode)\n \tmaxmode = word_mode;\n \n@@ -489,7 +490,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n       /* This used to check flag_force_mem, but that was a serious\n \t de-optimization now that flag_force_mem is enabled by -O2.  */\n       if (GET_CODE (op0) == MEM\n-\t  && ! ((*insn_operand_predicate[(int) CODE_FOR_insv][0])\n+\t  && ! ((*insn_data[(int) CODE_FOR_insv].operand[0].predicate)\n \t\t(op0, VOIDmode)))\n \t{\n \t  rtx tempreg;\n@@ -586,7 +587,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n \n       /* If this machine's insv insists on a register,\n \t get VALUE1 into a register.  */\n-      if (! ((*insn_operand_predicate[(int) CODE_FOR_insv][3])\n+      if (! ((*insn_data[(int) CODE_FOR_insv].operand[3].predicate)\n \t     (value1, maxmode)))\n \tvalue1 = force_reg (maxmode, value1);\n \n@@ -963,24 +964,25 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n   rtx spec_target_subreg = 0;\n #ifdef HAVE_extv\n   int extv_bitsize;\n+  enum machine_mode extv_mode;\n #endif\n #ifdef HAVE_extzv\n   int extzv_bitsize;\n+  enum machine_mode extzv_mode;\n #endif\n \n #ifdef HAVE_extv\n-  if (insn_operand_mode[(int) CODE_FOR_extv][0] == VOIDmode)\n-    extv_bitsize = GET_MODE_BITSIZE (word_mode);\n-  else\n-    extv_bitsize = GET_MODE_BITSIZE (insn_operand_mode[(int) CODE_FOR_extv][0]);\n+  extv_mode = insn_data[(int) CODE_FOR_extv].operand[0].mode;\n+  if (extv_mode == VOIDmode)\n+    extv_mode = word_mode;\n+  extv_bitsize = GET_MODE_BITSIZE (extv_mode);\n #endif\n \n #ifdef HAVE_extzv\n-  if (insn_operand_mode[(int) CODE_FOR_extzv][0] == VOIDmode)\n-    extzv_bitsize = GET_MODE_BITSIZE (word_mode);\n-  else\n-    extzv_bitsize\n-      = GET_MODE_BITSIZE (insn_operand_mode[(int) CODE_FOR_extzv][0]);\n+  extzv_mode = insn_data[(int) CODE_FOR_extzv].operand[0].mode;\n+  if (extzv_mode == VOIDmode)\n+    extzv_mode = word_mode;\n+  extzv_bitsize = GET_MODE_BITSIZE (extzv_mode);\n #endif\n \n   /* Discount the part of the structure before the desired byte.\n@@ -1210,7 +1212,7 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t  rtx pat;\n \t  enum machine_mode maxmode;\n \n-\t  maxmode = insn_operand_mode[(int) CODE_FOR_extzv][0];\n+\t  maxmode = insn_data[(int) CODE_FOR_extzv].operand[0].mode;\n \t  if (maxmode == VOIDmode)\n \t    maxmode = word_mode;\n \n@@ -1220,7 +1222,7 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t      volatile_ok = 1;\n \n \t      /* Is the memory operand acceptable?  */\n-\t      if (! ((*insn_operand_predicate[(int) CODE_FOR_extzv][1])\n+\t      if (! ((*insn_data[(int) CODE_FOR_extzv].operand[1].predicate)\n \t\t     (xop0, GET_MODE (xop0))))\n \t\t{\n \t\t  /* No, load into a reg and extract from there.  */\n@@ -1304,7 +1306,7 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \n \t  /* If this machine's extzv insists on a register target,\n \t     make sure we have one.  */\n-\t  if (! ((*insn_operand_predicate[(int) CODE_FOR_extzv][0])\n+\t  if (! ((*insn_data[(int) CODE_FOR_extzv].operand[0].predicate)\n \t\t (xtarget, maxmode)))\n \t    xtarget = gen_reg_rtx (maxmode);\n \n@@ -1350,14 +1352,14 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t  rtx pat;\n \t  enum machine_mode maxmode;\n \n-\t  maxmode = insn_operand_mode[(int) CODE_FOR_extv][0];\n+\t  maxmode = insn_data[(int) CODE_FOR_extv].operand[0].mode;\n \t  if (maxmode == VOIDmode)\n \t    maxmode = word_mode;\n \n \t  if (GET_CODE (xop0) == MEM)\n \t    {\n \t      /* Is the memory operand acceptable?  */\n-\t      if (! ((*insn_operand_predicate[(int) CODE_FOR_extv][1])\n+\t      if (! ((*insn_data[(int) CODE_FOR_extv].operand[1].predicate)\n \t\t     (xop0, GET_MODE (xop0))))\n \t\t{\n \t\t  /* No, load into a reg and extract from there.  */\n@@ -1440,7 +1442,7 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \n \t  /* If this machine's extv insists on a register target,\n \t     make sure we have one.  */\n-\t  if (! ((*insn_operand_predicate[(int) CODE_FOR_extv][0])\n+\t  if (! ((*insn_data[(int) CODE_FOR_extv].operand[0].predicate)\n \t\t (xtarget, maxmode)))\n \t    xtarget = gen_reg_rtx (maxmode);\n \n@@ -4210,6 +4212,8 @@ emit_store_flag (target, code, op0, op1, mode, unsignedp, normalizep)\n \n   if (icode != CODE_FOR_nothing)\n     {\n+      insn_operand_predicate_fn pred;\n+\n       /* We think we may be able to do this with a scc insn.  Emit the\n \t comparison and then the scc insn.\n \n@@ -4235,10 +4239,11 @@ emit_store_flag (target, code, op0, op1, mode, unsignedp, normalizep)\n \tabort ();\n \n       /* Get a reference to the target in the proper mode for this insn.  */\n-      compare_mode = insn_operand_mode[(int) icode][0];\n+      compare_mode = insn_data[(int) icode].operand[0].mode;\n       subtarget = target;\n+      pred = insn_data[(int) icode].operand[0].predicate;\n       if (preserve_subexpressions_p ()\n-\t  || ! (*insn_operand_predicate[(int) icode][0]) (subtarget, compare_mode))\n+\t  || ! (*pred) (subtarget, compare_mode))\n \tsubtarget = gen_reg_rtx (compare_mode);\n \n       pattern = GEN_FCN (icode) (subtarget);"}, {"sha": "c4d0f143fe823ace687e800b8888097df26295c2", "filename": "gcc/expr.c", "status": "modified", "additions": 34, "deletions": 39, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -818,7 +818,7 @@ convert_move (to, from, unsignedp)\n \t{\n #ifdef HAVE_slt\n \t  if (HAVE_slt\n-\t      && insn_operand_mode[(int) CODE_FOR_slt][0] == word_mode\n+\t      && insn_data[(int) CODE_FOR_slt].operand[0].mode == word_mode\n \t      && STORE_FLAG_VALUE == -1)\n \t    {\n \t      emit_cmp_insn (lowfrom, const0_rtx, NE, NULL_RTX,\n@@ -1591,6 +1591,7 @@ emit_block_move (x, y, size, align)\n \t   mode = GET_MODE_WIDER_MODE (mode))\n \t{\n \t  enum insn_code code = movstr_optab[(int) mode];\n+\t  insn_operand_predicate_fn pred;\n \n \t  if (code != CODE_FOR_nothing\n \t      /* We don't need MODE to be narrower than BITS_PER_HOST_WIDE_INT\n@@ -1601,21 +1602,20 @@ emit_block_move (x, y, size, align)\n \t\t   && ((unsigned HOST_WIDE_INT) INTVAL (size)\n \t\t       <= (GET_MODE_MASK (mode) >> 1)))\n \t\t  || GET_MODE_BITSIZE (mode) >= BITS_PER_WORD)\n-\t      && (insn_operand_predicate[(int) code][0] == 0\n-\t\t  || (*insn_operand_predicate[(int) code][0]) (x, BLKmode))\n-\t      && (insn_operand_predicate[(int) code][1] == 0\n-\t\t  || (*insn_operand_predicate[(int) code][1]) (y, BLKmode))\n-\t      && (insn_operand_predicate[(int) code][3] == 0\n-\t\t  || (*insn_operand_predicate[(int) code][3]) (opalign,\n-\t\t\t\t\t\t\t       VOIDmode)))\n+\t      && ((pred = insn_data[(int) code].operand[0].predicate) == 0\n+\t\t  || (*pred) (x, BLKmode))\n+\t      && ((pred = insn_data[(int) code].operand[1].predicate) == 0\n+\t\t  || (*pred) (y, BLKmode))\n+\t      && ((pred = insn_data[(int) code].operand[3].predicate) == 0\n+\t\t  || (*pred) (opalign, VOIDmode)))\n \t    {\n \t      rtx op2;\n \t      rtx last = get_last_insn ();\n \t      rtx pat;\n \n \t      op2 = convert_to_mode (mode, size, 1);\n-\t      if (insn_operand_predicate[(int) code][2] != 0\n-\t\t  && ! (*insn_operand_predicate[(int) code][2]) (op2, mode))\n+\t      pred = insn_data[(int) code].operand[2].predicate;\n+\t      if (pred != 0 && ! (*pred) (op2, mode))\n \t\top2 = copy_to_mode_reg (mode, op2);\n \n \t      pat = GEN_FCN ((int) code) (x, y, op2, opalign);\n@@ -2365,6 +2365,7 @@ clear_storage (object, size, align)\n \t       mode = GET_MODE_WIDER_MODE (mode))\n \t    {\n \t      enum insn_code code = clrstr_optab[(int) mode];\n+\t      insn_operand_predicate_fn pred;\n \n \t      if (code != CODE_FOR_nothing\n \t\t  /* We don't need MODE to be narrower than\n@@ -2375,21 +2376,18 @@ clear_storage (object, size, align)\n \t\t       && ((unsigned HOST_WIDE_INT) INTVAL (size)\n \t\t\t   <= (GET_MODE_MASK (mode) >> 1)))\n \t\t      || GET_MODE_BITSIZE (mode) >= BITS_PER_WORD)\n-\t\t  && (insn_operand_predicate[(int) code][0] == 0\n-\t\t      || (*insn_operand_predicate[(int) code][0]) (object,\n-\t\t\t\t\t\t\t\t   BLKmode))\n-\t\t  && (insn_operand_predicate[(int) code][2] == 0\n-\t\t      || (*insn_operand_predicate[(int) code][2]) (opalign,\n-\t\t\t\t\t\t\t\t   VOIDmode)))\n+\t\t  && ((pred = insn_data[(int) code].operand[0].predicate) == 0\n+\t\t      || (*pred) (object, BLKmode))\n+\t\t  && ((pred = insn_data[(int) code].operand[2].predicate) == 0\n+\t\t      || (*pred) (opalign, VOIDmode)))\n \t\t{\n \t\t  rtx op1;\n \t\t  rtx last = get_last_insn ();\n \t\t  rtx pat;\n \n \t\t  op1 = convert_to_mode (mode, size, 1);\n-\t\t  if (insn_operand_predicate[(int) code][1] != 0\n-\t\t      && ! (*insn_operand_predicate[(int) code][1]) (op1,\n-\t\t\t\t\t\t\t\t     mode))\n+\t\t  pred = insn_data[(int) code].operand[1].predicate;\n+\t\t  if (pred != 0 && ! (*pred) (op1, mode))\n \t\t    op1 = copy_to_mode_reg (mode, op1);\n \n \t\t  pat = GEN_FCN ((int) code) (object, op1, opalign);\n@@ -2984,29 +2982,26 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t\t   mode = GET_MODE_WIDER_MODE (mode))\n \t\t{\n \t\t  enum insn_code code = movstr_optab[(int) mode];\n+\t\t  insn_operand_predicate_fn pred;\n \n \t\t  if (code != CODE_FOR_nothing\n \t\t      && ((GET_CODE (size) == CONST_INT\n \t\t\t   && ((unsigned HOST_WIDE_INT) INTVAL (size)\n \t\t\t       <= (GET_MODE_MASK (mode) >> 1)))\n \t\t\t  || GET_MODE_BITSIZE (mode) >= BITS_PER_WORD)\n-\t\t      && (insn_operand_predicate[(int) code][0] == 0\n-\t\t\t  || ((*insn_operand_predicate[(int) code][0])\n-\t\t\t      (target, BLKmode)))\n-\t\t      && (insn_operand_predicate[(int) code][1] == 0\n-\t\t\t  || ((*insn_operand_predicate[(int) code][1])\n-\t\t\t      (xinner, BLKmode)))\n-\t\t      && (insn_operand_predicate[(int) code][3] == 0\n-\t\t\t  || ((*insn_operand_predicate[(int) code][3])\n-\t\t\t      (opalign, VOIDmode))))\n+\t\t      && (!(pred = insn_data[(int) code].operand[0].predicate)\n+\t\t\t  || ((*pred) (target, BLKmode)))\n+\t\t      && (!(pred = insn_data[(int) code].operand[1].predicate)\n+\t\t\t  || ((*pred) (xinner, BLKmode)))\n+\t\t      && (!(pred = insn_data[(int) code].operand[3].predicate)\n+\t\t\t  || ((*pred) (opalign, VOIDmode))))\n \t\t    {\n \t\t      rtx op2 = convert_to_mode (mode, size, 1);\n \t\t      rtx last = get_last_insn ();\n \t\t      rtx pat;\n \n-\t\t      if (insn_operand_predicate[(int) code][2] != 0\n-\t\t\t  && ! ((*insn_operand_predicate[(int) code][2])\n-\t\t\t\t(op2, mode)))\n+\t\t      pred = insn_data[(int) code].operand[2].predicate;\n+\t\t      if (pred != 0 && ! (*pred) (op2, mode))\n \t\t\top2 = copy_to_mode_reg (mode, op2);\n \n \t\t      pat = GEN_FCN ((int) code) (target, xinner,\n@@ -8373,9 +8368,9 @@ expand_increment (exp, post, ignore)\n       if (icode != (int) CODE_FOR_nothing\n \t  /* Make sure that OP0 is valid for operands 0 and 1\n \t     of the insn we want to queue.  */\n-\t  && (*insn_operand_predicate[icode][0]) (op0, mode)\n-\t  && (*insn_operand_predicate[icode][1]) (op0, mode)\n-\t  && (*insn_operand_predicate[icode][2]) (op1, mode))\n+\t  && (*insn_data[icode].operand[0].predicate) (op0, mode)\n+\t  && (*insn_data[icode].operand[1].predicate) (op0, mode)\n+\t  && (*insn_data[icode].operand[2].predicate) (op1, mode))\n \tsingle_insn = 1;\n     }\n \n@@ -8429,10 +8424,10 @@ expand_increment (exp, post, ignore)\n       if (icode != (int) CODE_FOR_nothing\n \t  /* Make sure that OP0 is valid for operands 0 and 1\n \t     of the insn we want to queue.  */\n-\t  && (*insn_operand_predicate[icode][0]) (op0, mode)\n-\t  && (*insn_operand_predicate[icode][1]) (op0, mode))\n+\t  && (*insn_data[icode].operand[0].predicate) (op0, mode)\n+\t  && (*insn_data[icode].operand[1].predicate) (op0, mode))\n \t{\n-\t  if (! (*insn_operand_predicate[icode][2]) (op1, mode))\n+\t  if (! (*insn_data[icode].operand[2].predicate) (op1, mode))\n \t    op1 = force_reg (mode, op1);\n \n \t  return enqueue_insn (op0, GEN_FCN (icode) (op0, op0, op1));\n@@ -8446,7 +8441,7 @@ expand_increment (exp, post, ignore)\n \n \t  op0 = change_address (op0, VOIDmode, addr);\n \t  temp = force_reg (GET_MODE (op0), op0);\n-\t  if (! (*insn_operand_predicate[icode][2]) (op1, mode))\n+\t  if (! (*insn_data[icode].operand[2].predicate) (op1, mode))\n \t    op1 = force_reg (mode, op1);\n \n \t  /* The increment queue is LIFO, thus we have to `queue'\n@@ -9590,7 +9585,7 @@ do_store_flag (exp, target, mode, only_cheap)\n     return 0;\n   icode = setcc_gen_code[(int) code];\n   if (icode == CODE_FOR_nothing\n-      || (only_cheap && insn_operand_mode[(int) icode][0] != mode))\n+      || (only_cheap && insn_data[(int) icode].operand[0].mode != mode))\n     {\n       /* We can only do this if it is one of the special cases that\n \t can be handled without an scc insn.  */"}, {"sha": "53cb9a9bd67f244d803ed23816fa65f70b128b87", "filename": "gcc/expr.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -286,13 +286,11 @@ typedef struct optab\n    So produce the pointer-to-function directly.\n    Luckily, these compilers seem to work properly when you\n    call the pointer-to-function.  */\n-#define GEN_FCN(CODE) (insn_gen_function[(int) (CODE)])\n+#define GEN_FCN(CODE) (insn_data[(int) (CODE)].genfun)\n #else\n-#define GEN_FCN(CODE) (*insn_gen_function[(int) (CODE)])\n+#define GEN_FCN(CODE) (*insn_data[(int) (CODE)].genfun)\n #endif\n \n-extern rtx (*const insn_gen_function[]) PROTO ((rtx, ...));\n-\n /* Enumeration of valid indexes into optab_table.  */\n enum optab_index\n {"}, {"sha": "e81895bd3bcc9a244dbf918799da85b5557236dc", "filename": "gcc/final.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -2898,10 +2898,10 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t/* If the proper template needs to be chosen by some C code,\n \t   run that code and get the real template.  */\n \n-\ttemplate = insn_template[insn_code_number];\n+\ttemplate = insn_data[insn_code_number].template;\n \tif (template == 0)\n \t  {\n-\t    template = ((*insn_outfun[insn_code_number])\n+\t    template = ((*insn_data[insn_code_number].outfun)\n \t\t\t(recog_data.operand, insn));\n \n \t    /* If the C code returns 0, it means that it is a jump insn\n@@ -3359,11 +3359,13 @@ output_asm_name ()\n \t{\n \t  register int num = INSN_CODE (debug_insn);\n \t  fprintf (asm_out_file, \"\\t%s %d\\t%s\", \n-\t\t   ASM_COMMENT_START, INSN_UID (debug_insn), insn_name[num]);\n-\t  if (insn_n_alternatives[num] > 1)\n+\t\t   ASM_COMMENT_START, INSN_UID (debug_insn),\n+\t\t   insn_data[num].name);\n+\t  if (insn_data[num].n_alternatives > 1)\n \t    fprintf (asm_out_file, \"/%d\", which_alternative + 1);\n #ifdef HAVE_ATTR_length\n-\t  fprintf (asm_out_file, \"\\t[length = %d]\", get_attr_length (debug_insn));\n+\t  fprintf (asm_out_file, \"\\t[length = %d]\",\n+\t\t   get_attr_length (debug_insn));\n #endif\n \t  /* Clear this so only the first assembler insn\n \t     of any rtl insn will get the special comment for -dp.  */"}, {"sha": "d12dd3336f5dbf3db7eaaaffda5cda2c485289f7", "filename": "gcc/function.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -1831,15 +1831,16 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n #ifdef HAVE_extzv\n \t      if (GET_CODE (x) == ZERO_EXTRACT)\n \t\t{\n-\t\t  wanted_mode = insn_operand_mode[(int) CODE_FOR_extzv][1];\n+\t\t  wanted_mode\n+\t\t    = insn_data[(int) CODE_FOR_extzv].operand[1].mode;\n \t\t  if (wanted_mode == VOIDmode)\n \t\t    wanted_mode = word_mode;\n \t\t}\n #endif\n #ifdef HAVE_extv\n \t      if (GET_CODE (x) == SIGN_EXTRACT)\n \t\t{\n-\t\t  wanted_mode = insn_operand_mode[(int) CODE_FOR_extv][1];\n+\t\t  wanted_mode = insn_data[(int) CODE_FOR_extv].operand[1].mode;\n \t\t  if (wanted_mode == VOIDmode)\n \t\t    wanted_mode = word_mode;\n \t\t}\n@@ -2034,7 +2035,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t\tenum machine_mode is_mode = GET_MODE (tem);\n \t\tHOST_WIDE_INT pos = INTVAL (XEXP (outerdest, 2));\n \n-\t\twanted_mode = insn_operand_mode[(int) CODE_FOR_insv][0];\n+\t\twanted_mode = insn_data[(int) CODE_FOR_insv].operand[0].mode;\n \t\tif (wanted_mode == VOIDmode)\n \t\t  wanted_mode = word_mode;\n "}, {"sha": "71b2dc0f0b083e988a4126863ecbed4d77d3c51e", "filename": "gcc/genattr.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fgenattr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fgenattr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattr.c?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -32,9 +32,6 @@ struct obstack *rtl_obstack = &obstack;\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n-/* Define this so we can link with print-rtl.o to get debug_rtx function.  */\n-char **insn_name_ptr = 0;\n-\n /* A range of values.  */\n \n struct range\n@@ -411,3 +408,11 @@ from the machine description file `md'.  */\\n\\n\");\n   /* NOTREACHED */\n   return 0;\n }\n+\n+/* Define this so we can link with print-rtl.o to get debug_rtx function.  */\n+const char *\n+get_insn_name (code)\n+     int code;\n+{\n+  return NULL;\n+}"}, {"sha": "e5a405d610b56037166feac3c620c14cc6940c9a", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -118,9 +118,6 @@ struct obstack *temp_obstack = &obstack2;\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n-/* Define this so we can link with print-rtl.o to get debug_rtx function.  */\n-char **insn_name_ptr = 0;\n-\n /* enough space to reserve for printing out ints */\n #define MAX_DIGITS (HOST_BITS_PER_INT * 3 / 10 + 3)\n \n@@ -6152,3 +6149,11 @@ from the machine description file `md'.  */\\n\\n\");\n   /* NOTREACHED */\n   return 0;\n }\n+\n+/* Define this so we can link with print-rtl.o to get debug_rtx function.  */\n+const char *\n+get_insn_name (code)\n+     int code;\n+{\n+  return NULL;\n+}"}, {"sha": "87f93ab6fb318ca65aec9b0b6b343014548dd20c", "filename": "gcc/gencodes.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fgencodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fgencodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgencodes.c?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -33,9 +33,6 @@ struct obstack *rtl_obstack = &obstack;\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n-/* Define this so we can link with print-rtl.o to get debug_rtx function.  */\n-char **insn_name_ptr = 0;\n-\n static int insn_code_number;\n \n static void gen_insn PROTO((rtx));\n@@ -142,3 +139,11 @@ from the machine description file `md'.  */\\n\\n\");\n   /* NOTREACHED */\n   return 0;\n }\n+\n+/* Define this so we can link with print-rtl.o to get debug_rtx function.  */\n+const char *\n+get_insn_name (code)\n+     int code;\n+{\n+  return NULL;\n+}"}, {"sha": "94e2653a3925fbe4bab5f2b27f86e40e80488eb4", "filename": "gcc/genconfig.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fgenconfig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fgenconfig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconfig.c?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -32,9 +32,6 @@ struct obstack *rtl_obstack = &obstack;\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n-/* Define this so we can link with print-rtl.o to get debug_rtx function.  */\n-char **insn_name_ptr = 0;\n-\n /* flags to determine output of machine description dependent #define's.  */\n static int max_recog_operands;  /* Largest operand number seen.  */\n static int max_dup_operands;    /* Largest number of match_dup in any insn.  */\n@@ -372,3 +369,11 @@ from the machine description file `md'.  */\\n\\n\");\n   /* NOTREACHED */\n   return 0;\n }\n+\n+/* Define this so we can link with print-rtl.o to get debug_rtx function.  */\n+const char *\n+get_insn_name (code)\n+     int code;\n+{\n+  return NULL;\n+}"}, {"sha": "6aec54a2d55ad7812649d83d94fbb7443552fa4a", "filename": "gcc/genemit.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -31,9 +31,6 @@ struct obstack *rtl_obstack = &obstack;\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n-/* Define this so we can link with print-rtl.o to get debug_rtx function.  */\n-char **insn_name_ptr = 0;\n-\n static int max_opno;\n static int max_dup_opno;\n static int max_scratch_opno;\n@@ -867,3 +864,11 @@ from the machine description file `md'.  */\\n\\n\");\n   /* NOTREACHED */\n   return 0;\n }\n+\n+/* Define this so we can link with print-rtl.o to get debug_rtx function.  */\n+const char *\n+get_insn_name (code)\n+     int code;\n+{\n+  return NULL;\n+}"}, {"sha": "eeaf52b197a3f79edf38f3d15993d5bc60df4e4c", "filename": "gcc/genextract.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fgenextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fgenextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenextract.c?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -32,9 +32,6 @@ struct obstack *rtl_obstack = &obstack;\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n-/* Names for patterns.  Need to allow linking with print-rtl.  */\n-char **insn_name_ptr;\n-\n /* This structure contains all the information needed to describe one\n    set of extractions methods.  Each method may be used by more than \n    one pattern if the operands are in the same place.\n@@ -527,3 +524,11 @@ from the machine description file `md'.  */\\n\\n\");\n   /* NOTREACHED */\n   return 0;\n }\n+\n+/* Define this so we can link with print-rtl.o to get debug_rtx function.  */\n+const char *\n+get_insn_name (code)\n+     int code;\n+{\n+  return NULL;\n+}"}, {"sha": "bd3a983fbfda48710cc47267f1a92e834adfdd61", "filename": "gcc/genflags.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fgenflags.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fgenflags.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenflags.c?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -33,9 +33,6 @@ struct obstack *rtl_obstack = &obstack;\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n-/* Names for patterns.  Need to allow linking with print-rtl.  */\n-char **insn_name_ptr;\n-\n /* Obstacks to remember normal, and call insns.  */\n static struct obstack call_obstack, normal_obstack;\n \n@@ -278,3 +275,11 @@ from the machine description file `md'.  */\\n\\n\");\n   /* NOTREACHED */\n   return 0;\n }\n+\n+/* Define this so we can link with print-rtl.o to get debug_rtx function.  */\n+const char *\n+get_insn_name (code)\n+     int code;\n+{\n+  return NULL;\n+}"}, {"sha": "ac4a5883e606bd8cc5a6569ddc829f693669aaf6", "filename": "gcc/genopinit.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -118,9 +118,6 @@ const char *optabs[] =\n   \"movstr_optab[(int) %A] = CODE_FOR_%(movstr%a%)\",\n   \"clrstr_optab[(int) %A] = CODE_FOR_%(clrstr%a%)\" };\n \n-/* Allow linking with print-rtl.c.  */\n-char **insn_name_ptr;\n-\n static void gen_insn PROTO((rtx));\n \n static void\n@@ -363,3 +360,11 @@ from the machine description file `md'.  */\\n\\n\");\n   /* NOTREACHED */\n   return 0;\n }\n+\n+/* Define this so we can link with print-rtl.o to get debug_rtx function.  */\n+const char *\n+get_insn_name (code)\n+     int code;\n+{\n+  return NULL;\n+}"}, {"sha": "9c44d7e6475cfe7061a07c7bac33a9d7488c8f80", "filename": "gcc/genoutput.c", "status": "modified", "additions": 409, "deletions": 410, "changes": 819, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -1,5 +1,6 @@\n /* Generate code from to output assembler insns as recognized from rtl.\n-   Copyright (C) 1987, 88, 92, 94-95, 97-98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 92, 94-95, 97-98, 1999\n+   Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -22,83 +23,76 @@ Boston, MA 02111-1307, USA.  */\n /* This program reads the machine description for the compiler target machine\n    and produces a file containing these things:\n \n-   1. An array of strings `insn_template' which is indexed by insn code number\n-   and contains the template for output of that insn,\n+   1. An array of `struct insn_data', which is indexed by insn code number,\n+   which contains:\n \n-   2. An array of functions `insn_outfun' which, indexed by the insn code\n-   number, gives the function that returns a template to use for output of\n-   that insn.  This is used only in the cases where the template is not\n-   constant.  These cases are specified by a * or @ at the beginning of the\n-   template string in the machine description.  They are identified for the\n-   sake of other parts of the compiler by a zero element in `insn_template'.\n+     a. `name' is the name for that pattern.  Nameless patterns are\n+     given a name.\n+\n+     b. `template' is the template for output of that insn,\n+\n+     c. `outfun' is the function that returns a template to use for output of\n+     that insn.  This is used only in the cases where the template is not\n+     constant.  These cases are specified by a * or @ at the beginning of the\n+     template string in the machine description.  They are identified for the\n+     sake of other parts of the compiler by a zero element in `template'.\n   \n-   3. An array of functions `insn_gen_function' which, indexed\n-   by insn code number, gives the function to generate a body\n-   for that pattern, given operands as arguments.\n+     d. `genfun' is the function to generate a body for that pattern,\n+     given operands as arguments.\n+\n+     e. `n_operands' is the number of distinct operands in the pattern\n+     for that insn,\n \n-   4. An array of strings `insn_name' which, indexed by insn code number,\n-   gives the name for that pattern.  Nameless patterns are given a name.\n+     f. `n_dups' is the number of match_dup's that appear in the insn's\n+     pattern.  This says how many elements of `recog_data.dup_loc' are\n+     significant after an insn has been recognized.\n \n-   5. An array of ints `insn_n_operands' which is indexed by insn code number\n-   and contains the number of distinct operands in the pattern for that insn,\n+     g. `n_alternatives' is the number of alternatives in the constraints\n+     of each pattern.\n \n-   6. An array of ints `insn_n_dups' which is indexed by insn code number\n-   and contains the number of match_dup's that appear in the insn's pattern.\n-   This says how many elements of `recog_data.dup_loc' are significant\n-   after an insn has been recognized.\n+     h. `operand' is the base of an array of operand data for the insn.\n \n-   7. An array of arrays of operand constraint strings,\n-   `insn_operand_constraint',\n-   indexed first by insn code number and second by operand number,\n-   containing the constraint for that operand.\n+   2. An array of `struct insn_operand data', used by `operand' above.\n \n-   This array is generated only if register constraints appear in \n-   match_operand rtx's.\n+     a. `predicate', an int-valued function, is the match_operand predicate\n+     for this operand.\n \n-   8. An array of arrays of chars which indicate which operands of\n-   which insn patterns appear within ADDRESS rtx's.  This array is\n-   called `insn_operand_address_p' and is generated only if there\n-   are *no* register constraints in the match_operand rtx's.\n+     b. `constraint' is the constraint for this operand.  This exists\n+     only if register constraints appear in match_operand rtx's.\n \n-   9. An array of arrays of machine modes, `insn_operand_mode',\n-   indexed first by insn code number and second by operand number,\n-   containing the machine mode that that operand is supposed to have.\n-   Also `insn_operand_strict_low', which is nonzero for operands\n-   contained in a STRICT_LOW_PART.\n+     c. `address_p' indicates that the operand appears within ADDRESS\n+     rtx's.  This exists only if there are *no* register constraints\n+     in the match_operand rtx's.\n \n-   10. An array of arrays of int-valued functions, `insn_operand_predicate',\n-   indexed first by insn code number and second by operand number,\n-   containing the match_operand predicate for this operand.\n+     d. `mode' is the machine mode that that operand is supposed to have.\n \n-   11. An array of ints, `insn_n_alternatives', that gives the number\n-   of alternatives in the constraints of each pattern.\n+     e. `strict_low', is nonzero for operands contained in a STRICT_LOW_PART.\n \n-The code number of an insn is simply its position in the machine description;\n-code numbers are assigned sequentially to entries in the description,\n-starting with code number 0.\n+  The code number of an insn is simply its position in the machine\n+  description; code numbers are assigned sequentially to entries in\n+  the description, starting with code number 0.\n \n-Thus, the following entry in the machine description\n+  Thus, the following entry in the machine description\n \n     (define_insn \"clrdf\"\n       [(set (match_operand:DF 0 \"general_operand\" \"\")\n \t    (const_int 0))]\n       \"\"\n       \"clrd %0\")\n \n-assuming it is the 25th entry present, would cause\n-insn_template[24] to be \"clrd %0\", and insn_n_operands[24] to be 1.\n-It would not make an case in output_insn_hairy because the template\n-given in the entry is a constant (it does not start with `*').  */\n+  assuming it is the 25th entry present, would cause\n+  insn_data[24].template to be \"clrd %0\", and\n+  insn_data[24].n_operands to be 1.  */\n \f\n #include \"hconfig.h\"\n #include \"system.h\"\n #include \"rtl.h\"\n #include \"obstack.h\"\n #include \"errors.h\"\n \n-/* No instruction can have more operands than this.\n-   Sorry for this arbitrary limit, but what machine will\n-   have an instruction with this many operands?  */\n+/* No instruction can have more operands than this.  Sorry for this\n+   arbitrary limit, but what machine will have an instruction with\n+   this many operands?  */\n \n #define MAX_MAX_OPERANDS 40\n \n@@ -110,9 +104,6 @@ struct obstack *rtl_obstack = &obstack;\n \n static int n_occurrences PROTO((int, char *));\n \n-/* Define this so we can link with print-rtl.o to get debug_rtx function.  */\n-char **insn_name_ptr = 0;\n-\n /* insns in the machine description are assigned sequential code numbers\n    that are used by insn-recog.c (produced by genrecog) to communicate\n    to insn-output.c (produced by this program).  */\n@@ -124,49 +115,73 @@ static int next_code_number;\n \n static int next_index_number;\n \n+/* This counts all operands used in the md file.  The first is null.  */\n+\n+static int next_operand_number = 1;\n+\n+/* Record in this chain all information about the operands we will output.  */\n+\n+struct operand_data\n+{\n+  struct operand_data *next;\n+  int index;\n+  char *predicate;\n+  char *constraint;\n+  enum machine_mode mode;\n+  unsigned char n_alternatives;\n+  char address_p;\n+  char strict_low;\n+  char seen;\n+};\n+\n+/* Begin with a null operand at index 0.  */\n+\n+static struct operand_data null_operand =\n+{\n+  0, 0, \"\", \"\", VOIDmode, 0, 0, 0, 0\n+};\n+\n+static struct operand_data *odata = &null_operand;\n+static struct operand_data **odata_end = &null_operand.next;\n+\n /* Record in this chain all information that we will output,\n    associated with the code number of the insn.  */\n \n struct data\n {\n-  int code_number;\n-  int index_number;\n+  struct data *next;\n   char *name;\n   char *template;\t\t/* string such as \"movl %1,%0\" */\n+  int code_number;\n+  int index_number;\n   int n_operands;\t\t/* Number of operands this insn recognizes */\n   int n_dups;\t\t\t/* Number times match_dup appears in pattern */\n   int n_alternatives;\t\t/* Number of alternatives in each constraint */\n-  struct data *next;\n-  char *constraints[MAX_MAX_OPERANDS];\n-  /* Number of alternatives in constraints of operand N.  */\n-  int op_n_alternatives[MAX_MAX_OPERANDS];\n-  char *predicates[MAX_MAX_OPERANDS];\n-  char address_p[MAX_MAX_OPERANDS];\n-  enum machine_mode modes[MAX_MAX_OPERANDS];\n-  char strict_low[MAX_MAX_OPERANDS];\n   char outfun;\t\t\t/* Nonzero means this has an output function */\n+  int operand_number;\t\t/* Operand index in the big array.  */\n+  struct operand_data operand[MAX_MAX_OPERANDS];\n };\n \n-/* This variable points to the first link in the chain.  */\n-\n-struct data *insn_data;\n+/* This variable points to the first link in the insn chain.  */\n \n-/* Pointer to the last link in the chain, so new elements\n-   can be added at the end.  */\n+static struct data *idata, **idata_end = &idata;\n \n-struct data *end_of_insn_data;\n+/* Nonzero if any match_operand has a constraint string; implies that\n+   REGISTER_CONSTRAINTS will be defined for this machine description.  */\n \n-/* Nonzero if any match_operand has a constraint string;\n-   implies that REGISTER_CONSTRAINTS will be defined\n-   for this machine description.  */\n-\n-int have_constraints;\n+static int have_constraints;\n \n \f\n static char * name_for_index PROTO((int));\n static void output_prologue PROTO((void));\n-static void output_epilogue PROTO((void));\n-static void scan_operands PROTO((rtx, int, int));\n+static void output_predicate_decls PROTO((void));\n+static void output_operand_data PROTO((void));\n+static void output_insn_data PROTO((void));\n+static void output_get_insn_name PROTO((void));\n+static void scan_operands PROTO((struct data *, rtx, int, int));\n+static int compare_operands PROTO((struct operand_data *,\n+\t\t\t\t   struct operand_data *));\n+static void place_operands PROTO((struct data *));\n static void process_template PROTO((struct data *, char *));\n static void validate_insn_alternatives PROTO((struct data *));\n static void gen_insn PROTO((rtx));\n@@ -175,14 +190,14 @@ static void gen_expand PROTO((rtx));\n static void gen_split PROTO((rtx));\n static int n_occurrences PROTO((int, char *));\n \f\n-static char *\n-name_for_index (index)\n+const char *\n+get_insn_name (index)\n      int index;\n {\n   static char buf[100];\n \n   struct data *i, *last_named = NULL;\n-  for (i = insn_data; i ; i = i->next)\n+  for (i = idata; i ; i = i->next)\n     {\n       if (i->index_number == index)\n \treturn i->name;\n@@ -204,6 +219,7 @@ output_prologue ()\n   printf (\"/* Generated automatically by the program `genoutput'\\n\\\n from the machine description file `md'.  */\\n\\n\");\n \n+  printf (\"#define NO_MD_PROTOTYPES\\n\");\n   printf (\"#include \\\"config.h\\\"\\n\");\n   printf (\"#include \\\"system.h\\\"\\n\");\n   printf (\"#include \\\"flags.h\\\"\\n\");\n@@ -222,224 +238,171 @@ from the machine description file `md'.  */\\n\\n\");\n   printf (\"#include \\\"output.h\\\"\\n\");\n }\n \n+\n+/* We need to define all predicates used.  Keep a list of those we\n+   have defined so far.  There normally aren't very many predicates\n+   used, so a linked list should be fast enough.  */\n+\n static void\n-output_epilogue ()\n+output_predicate_decls ()\n {\n-  register struct data *d;\n+  struct predicate { char *name; struct predicate *next; } *predicates = 0;\n+  register struct operand_data *d;\n+  struct predicate *p;\n \n-  printf (\"\\nconst char * const insn_template[] =\\n  {\\n\");\n-  for (d = insn_data; d; d = d->next)\n-    {\n-      if (d->template)\n-\tprintf (\"    \\\"%s\\\",\\n\", d->template);\n-      else\n-\tprintf (\"    0,\\n\");\n-    }\n-  printf (\"  };\\n\");\n+  for (d = odata; d; d = d->next)\n+    if (d->predicate && d->predicate[0])\n+      {\n+\tfor (p = predicates; p; p = p->next)\n+\t  if (strcmp (p->name, d->predicate) == 0)\n+\t    break;\n \n-  printf (\"\\nconst char *(*const insn_outfun[]) PROTO((rtx *, rtx)) =\\n  {\\n\");\n-  for (d = insn_data; d; d = d->next)\n-    {\n-      if (d->outfun)\n-\tprintf (\"    output_%d,\\n\", d->code_number);\n-      else\n-\tprintf (\"    0,\\n\");\n-    }\n-  printf (\"  };\\n\");\n+\tif (p == 0)\n+\t  {\n+\t    printf (\"extern int %s PROTO ((rtx, enum machine_mode));\\n\",\n+\t\t    d->predicate);\n+\t    p = (struct predicate *) alloca (sizeof (struct predicate));\n+\t    p->name = d->predicate;\n+\t    p->next = predicates;\n+\t    predicates = p;\n+\t  }\n+      }\n+\n+  printf (\"\\n\\n\");\n+}\n \n-  printf (\"\\nrtx (*const insn_gen_function[]) () =\\n  {\\n\");\n-  for (d = insn_data; d; d = d->next)\n+static void\n+output_operand_data ()\n+{\n+  register struct operand_data *d;\n+\n+  printf (\"\\nstatic const struct insn_operand_data operand_data[] = \\n{\\n\");\n+\n+  for (d = odata; d; d = d->next)\n     {\n-      if (d->name && d->name[0] != '*')\n-\tprintf (\"    gen_%s,\\n\", d->name);\n-      else\n-\tprintf (\"    0,\\n\");\n-    }\n-  printf (\"  };\\n\");\n-\n-  printf (\"\\nconst char *insn_name[] =\\n  {\\n\");\n-  {\n-    int offset = 0;\n-    int next;\n-    char * last_name = 0;\n-    char * next_name = 0;\n-    register struct data *n;\n-\n-    for (n = insn_data, next = 1; n; n = n->next, next++)\n-      if (n->name)\n+      printf (\"  {\\n\");\n+\n+      printf (\"    %s,\\n\",\n+\t      d->predicate && d->predicate[0] ? d->predicate : \"0\");\n+\n+      if (have_constraints)\n \t{\n-\t  next_name = n->name;\n-\t  break;\n+\t  printf (\"    \\\"%s\\\",\\n\",\n+\t\t  d->constraint ? d->constraint : \"\");\n \t}\n \n-    for (d = insn_data; d; d = d->next)\n+      printf (\"    %smode,\\n\", GET_MODE_NAME (d->mode));\n+\n+      if (! have_constraints)\n+\tprintf (\"    %d,\\n\", d->address_p);\n+\n+      printf (\"    %d\\n\", d->strict_low);\n+\n+      printf(\"  },\\n\");\n+    }\n+  printf(\"};\\n\\n\\n\");\n+}\n+\n+static void\n+output_insn_data ()\n+{\n+  register struct data *d;\n+  int name_offset = 0;\n+  int next_name_offset;\n+  const char * last_name = 0;\n+  const char * next_name = 0;\n+  register struct data *n;\n+\n+  for (n = idata, next_name_offset = 1; n; n = n->next, next_name_offset++)\n+    if (n->name)\n       {\n-\tif (d->name)\n-\t  {\n-\t    printf (\"    \\\"%s\\\",\\n\", d->name);\n-\t    offset = 0;\n-\t    last_name = d->name;\n-\t    next_name = 0;\n-\t    for (n = d->next, next = 1; n; n = n->next, next++)\n-\t      if (n->name)\n-\t\t{\n-\t\t  next_name = n->name;\n-\t\t  break;\n-\t\t}\n-\t  }\n-\telse\n-\t  {\n-\t    offset++;\n-\t    if (next_name && (last_name == 0 || offset > next / 2))\n-\t      printf (\"    \\\"%s-%d\\\",\\n\", next_name, next - offset);\n-\t    else\n-\t      printf (\"    \\\"%s+%d\\\",\\n\", last_name, offset);\n-\t  }\n+\tnext_name = n->name;\n+\tbreak;\n       }\n-  }\n-  printf (\"  };\\n\");\n-  printf (\"const char **insn_name_ptr = insn_name;\\n\");\n-\n-  printf (\"\\nconst int insn_n_operands[] =\\n  {\\n\");\n-  for (d = insn_data; d; d = d->next)\n-    printf (\"    %d,\\n\", d->n_operands);\n-  printf (\"  };\\n\");\n \n-  printf (\"\\nconst int insn_n_dups[] =\\n  {\\n\");\n-  for (d = insn_data; d; d = d->next)\n-    printf (\"    %d,\\n\", d->n_dups);\n-  printf (\"  };\\n\");\n+  printf (\"\\nconst struct insn_data insn_data[] = \\n{\\n\");\n \n-  if (have_constraints)\n+  for (d = idata; d; d = d->next)\n     {\n-      printf (\"\\nconst char *const insn_operand_constraint[][MAX_RECOG_OPERANDS] =\\n  {\\n\");\n-      for (d = insn_data; d; d = d->next)\n+      printf (\"  {\\n\");\n+\n+      if (d->name)\n \t{\n-\t  register int i;\n-\t  printf (\"    {\");\n-\t  for (i = 0; i < d->n_operands; i++)\n+\t  printf (\"    \\\"%s\\\",\\n\", d->name);\n+\t  name_offset = 0;\n+\t  last_name = d->name;\n+\t  next_name = 0;\n+\t  for (n = d->next, next_name_offset = 1; n;\n+\t       n = n->next, next_name_offset++)\n \t    {\n-\t      if (d->constraints[i] == 0)\n-\t\tprintf (\" \\\"\\\",\");\n-\t      else\n-\t\tprintf (\" \\\"%s\\\",\", d->constraints[i]);\n+\t      if (n->name)\n+\t\t{\n+\t\t  next_name = n->name;\n+\t\t  break;\n+\t\t}\n \t    }\n-\t  if (d->n_operands == 0)\n-\t    printf (\" 0\");\n-\t  printf (\" },\\n\");\n \t}\n-      printf (\"  };\\n\");\n-    }\n-  else\n-    {\n-      printf (\"\\nconst char insn_operand_address_p[][MAX_RECOG_OPERANDS] =\\n  {\\n\");\n-      for (d = insn_data; d; d = d->next)\n+      else\n \t{\n-\t  register int i;\n-\t  printf (\"    {\");\n-\t  for (i = 0; i < d->n_operands; i++)\n-\t    printf (\" %d,\", d->address_p[i]);\n-\t  if (d->n_operands == 0)\n-\t    printf (\" 0\");\n-\t  printf (\" },\\n\");\n+\t  name_offset++;\n+\t  if (next_name && (last_name == 0\n+\t\t\t    || name_offset > next_name_offset / 2))\n+\t    printf (\"    \\\"%s-%d\\\",\\n\", next_name,\n+\t\t    next_name_offset - name_offset);\n+\t  else\n+\t    printf (\"    \\\"%s+%d\\\",\\n\", last_name, name_offset);\n \t}\n-      printf (\"  };\\n\");\n-    }\n \n-  printf (\"\\nconst enum machine_mode insn_operand_mode[][MAX_RECOG_OPERANDS] =\\n  {\\n\");\n-  for (d = insn_data; d; d = d->next)\n-    {\n-      register int i;\n-      printf (\"    {\");\n-      for (i = 0; i < d->n_operands; i++)\n-\tprintf (\" %smode,\", GET_MODE_NAME (d->modes[i]));\n-      if (d->n_operands == 0)\n-\tprintf (\" VOIDmode\");\n-      printf (\" },\\n\");\n-    }\n-  printf (\"  };\\n\");\n+      if (d->template)\n+\tprintf (\"    \\\"%s\\\",\\n\", d->template);\n+      else\n+\tprintf (\"    0,\\n\");\n \n-  printf (\"\\nconst char insn_operand_strict_low[][MAX_RECOG_OPERANDS] =\\n  {\\n\");\n-  for (d = insn_data; d; d = d->next)\n-    {\n-      register int i;\n-      printf (\"    {\");\n-      for (i = 0; i < d->n_operands; i++)\n-\tprintf (\" %d,\", d->strict_low[i]);\n-      if (d->n_operands == 0)\n-\tprintf (\" 0\");\n-      printf (\" },\\n\");\n+      if (d->outfun)\n+\tprintf (\"    output_%d,\\n\", d->code_number);\n+      else\n+\tprintf (\"    0,\\n\");\n+\n+      if (d->name && d->name[0] != '*')\n+\tprintf (\"    gen_%s,\\n\", d->name);\n+      else\n+\tprintf (\"    0,\\n\");\n+\n+      printf (\"    &operand_data[%d],\\n\", d->operand_number);\n+      printf (\"    %d,\\n\", d->n_operands);\n+      printf (\"    %d,\\n\", d->n_dups);\n+      printf (\"    %d\\n\", d->n_alternatives);\n+\n+      printf(\"  },\\n\");\n     }\n-  printf (\"  };\\n\");\n-\n-  {\n-    /* We need to define all predicates used.  Keep a list of those we\n-       have defined so far.  There normally aren't very many predicates used,\n-       so a linked list should be fast enough.  */\n-    struct predicate { char *name; struct predicate *next; } *predicates = 0;\n-    struct predicate *p;\n-    int i;\n-\n-    printf (\"\\n\");\n-    for (d = insn_data; d; d = d->next)\n-      for (i = 0; i < d->n_operands; i++)\n-\tif (d->predicates[i] && d->predicates[i][0])\n-\t  {\n-\t    for (p = predicates; p; p = p->next)\n-\t      if (! strcmp (p->name, d->predicates[i]))\n-\t\tbreak;\n-\n-\t    if (p == 0)\n-\t      {\n-\t\tprintf (\"extern int %s PROTO ((rtx, enum machine_mode));\\n\",\n-\t\t\td->predicates[i]);\n-\t\tp = (struct predicate *) alloca (sizeof (struct predicate));\n-\t\tp->name = d->predicates[i];\n-\t\tp->next = predicates;\n-\t\tpredicates = p;\n-\t      }\n-\t  }\n-    \n-    printf (\"\\nint (*const insn_operand_predicate[][MAX_RECOG_OPERANDS]) PROTO ((rtx, enum machine_mode)) =\\n  {\\n\");\n-    for (d = insn_data; d; d = d->next)\n-      {\n-\tprintf (\"    {\");\n-\tfor (i = 0; i < d->n_operands; i++)\n-\t  printf (\" %s,\", ((d->predicates[i] && d->predicates[i][0])\n-\t\t\t   ? d->predicates[i] : \"0\"));\n-\tif (d->n_operands == 0)\n-\t  printf (\" 0\");\n-\tprintf (\" },\\n\");\n-      }\n-    printf (\"  };\\n\");\n-  }\n+  printf (\"};\\n\\n\\n\");\n+}\n \n-  printf (\"\\nconst int insn_n_alternatives[] =\\n  {\\n\");\n-  for (d = insn_data; d; d = d->next)\n-    printf (\"    %d,\\n\", d->n_alternatives);\n-  printf(\"  };\\n\");\n+static void\n+output_get_insn_name ()\n+{\n+  printf (\"const char *\\n\");\n+  printf (\"get_insn_name (code)\\n\");\n+  printf (\"     int code;\\n\");\n+  printf (\"{\\n\");\n+  printf (\"  return insn_data[code].name;\\n\");\n+  printf (\"}\\n\");\n }\n+\n \f\n-/* scan_operands (X) stores in max_opno the largest operand\n-   number present in X, if that is larger than the previous\n-   value of max_opno.  It stores all the constraints in `constraints'\n-   and all the machine modes in `modes'.\n+/* Stores in max_opno the largest operand number present in `part', if\n+   that is larger than the previous value of max_opno, and the rest of\n+   the operand data into `d->operand[i]'.\n \n    THIS_ADDRESS_P is nonzero if the containing rtx was an ADDRESS.\n    THIS_STRICT_LOW is nonzero if the containing rtx was a STRICT_LOW_PART.  */\n \n static int max_opno;\n static int num_dups;\n-static char *constraints[MAX_MAX_OPERANDS];\n-static int op_n_alternatives[MAX_MAX_OPERANDS];\n-static const char *predicates[MAX_MAX_OPERANDS];\n-static char address_p[MAX_MAX_OPERANDS];\n-static enum machine_mode modes[MAX_MAX_OPERANDS];\n-static char strict_low[MAX_MAX_OPERANDS];\n-static char seen[MAX_MAX_OPERANDS];\n \n static void\n-scan_operands (part, this_address_p, this_strict_low)\n+scan_operands (d, part, this_address_p, this_strict_low)\n+     struct data *d;\n      rtx part;\n      int this_address_p;\n      int this_strict_low;\n@@ -460,23 +423,24 @@ scan_operands (part, this_address_p, this_strict_low)\n       if (max_opno >= MAX_MAX_OPERANDS)\n \t{\n \t  error (\"Too many operands (%d) in definition %s.\\n\",\n-\t\t max_opno + 1, name_for_index (next_index_number));\n+\t\t max_opno + 1, get_insn_name (next_index_number));\n \t  return;\n \t}\n-      if (seen[opno])\n+      if (d->operand[opno].seen)\n \terror (\"Definition %s specified operand number %d more than once.\\n\",\n-\t       name_for_index (next_index_number), opno);\n-      seen[opno] = 1;\n-      modes[opno] = GET_MODE (part);\n-      strict_low[opno] = this_strict_low;\n-      predicates[opno] = XSTR (part, 1);\n-      constraints[opno] = XSTR (part, 2);\n+\t       get_insn_name (next_index_number), opno);\n+      d->operand[opno].seen = 1;\n+      d->operand[opno].mode = GET_MODE (part);\n+      d->operand[opno].strict_low = this_strict_low;\n+      d->operand[opno].predicate = XSTR (part, 1);\n+      d->operand[opno].constraint = XSTR (part, 2);\n       if (XSTR (part, 2) != 0 && *XSTR (part, 2) != 0)\n \t{\n-\t  op_n_alternatives[opno] = n_occurrences (',', XSTR (part, 2)) + 1;\n+\t  d->operand[opno].n_alternatives\n+\t    = n_occurrences (',', XSTR (part, 2)) + 1;\n \t  have_constraints = 1;\n \t}\n-      address_p[opno] = this_address_p;\n+      d->operand[opno].address_p = this_address_p;\n       return;\n \n     case MATCH_SCRATCH:\n@@ -486,23 +450,24 @@ scan_operands (part, this_address_p, this_strict_low)\n       if (max_opno >= MAX_MAX_OPERANDS)\n \t{\n \t  error (\"Too many operands (%d) in definition %s.\\n\",\n-\t\t max_opno + 1, name_for_index (next_index_number));\n+\t\t max_opno + 1, get_insn_name (next_index_number));\n \t  return;\n \t}\n-      if (seen[opno])\n+      if (d->operand[opno].seen)\n \terror (\"Definition %s specified operand number %d more than once.\\n\",\n-\t       name_for_index (next_index_number), opno);\n-      seen[opno] = 1;\n-      modes[opno] = GET_MODE (part);\n-      strict_low[opno] = 0;\n-      predicates[opno] = \"scratch_operand\";\n-      constraints[opno] = XSTR (part, 1);\n+\t       get_insn_name (next_index_number), opno);\n+      d->operand[opno].seen = 1;\n+      d->operand[opno].mode = GET_MODE (part);\n+      d->operand[opno].strict_low = 0;\n+      d->operand[opno].predicate = \"scratch_operand\";\n+      d->operand[opno].constraint = XSTR (part, 1);\n       if (XSTR (part, 1) != 0 && *XSTR (part, 1) != 0)\n \t{\n-\t  op_n_alternatives[opno] = n_occurrences (',', XSTR (part, 1)) + 1;\n+\t  d->operand[opno].n_alternatives\n+\t    = n_occurrences (',', XSTR (part, 1)) + 1;\n \t  have_constraints = 1;\n \t}\n-      address_p[opno] = 0;\n+      d->operand[opno].address_p = 0;\n       return;\n \n     case MATCH_OPERATOR:\n@@ -513,20 +478,20 @@ scan_operands (part, this_address_p, this_strict_low)\n       if (max_opno >= MAX_MAX_OPERANDS)\n \t{\n \t  error (\"Too many operands (%d) in definition %s.\\n\",\n-\t\t max_opno + 1, name_for_index (next_index_number));\n+\t\t max_opno + 1, get_insn_name (next_index_number));\n \t  return;\n \t}\n-      if (seen[opno])\n+      if (d->operand[opno].seen)\n \terror (\"Definition %s specified operand number %d more than once.\\n\",\n-\t       name_for_index (next_index_number), opno);\n-      seen[opno] = 1;\n-      modes[opno] = GET_MODE (part);\n-      strict_low[opno] = 0;\n-      predicates[opno] = XSTR (part, 1);\n-      constraints[opno] = 0;\n-      address_p[opno] = 0;\n+\t       get_insn_name (next_index_number), opno);\n+      d->operand[opno].seen = 1;\n+      d->operand[opno].mode = GET_MODE (part);\n+      d->operand[opno].strict_low = 0;\n+      d->operand[opno].predicate = XSTR (part, 1);\n+      d->operand[opno].constraint = 0;\n+      d->operand[opno].address_p = 0;\n       for (i = 0; i < XVECLEN (part, 2); i++)\n-\tscan_operands (XVECEXP (part, 2, i), 0, 0);\n+\tscan_operands (d, XVECEXP (part, 2, i), 0, 0);\n       return;\n \n     case MATCH_DUP:\n@@ -536,11 +501,11 @@ scan_operands (part, this_address_p, this_strict_low)\n       return;\n \n     case ADDRESS:\n-      scan_operands (XEXP (part, 0), 1, 0);\n+      scan_operands (d, XEXP (part, 0), 1, 0);\n       return;\n \n     case STRICT_LOW_PART:\n-      scan_operands (XEXP (part, 0), 0, 1);\n+      scan_operands (d, XEXP (part, 0), 0, 1);\n       return;\n       \n     default:\n@@ -554,15 +519,111 @@ scan_operands (part, this_address_p, this_strict_low)\n       {\n       case 'e':\n       case 'u':\n-\tscan_operands (XEXP (part, i), 0, 0);\n+\tscan_operands (d, XEXP (part, i), 0, 0);\n \tbreak;\n       case 'E':\n \tif (XVEC (part, i) != NULL)\n \t  for (j = 0; j < XVECLEN (part, i); j++)\n-\t    scan_operands (XVECEXP (part, i, j), 0, 0);\n+\t    scan_operands (d, XVECEXP (part, i, j), 0, 0);\n \tbreak;\n       }\n }\n+\n+/* Compare two operands for content equality.  */\n+\n+static int\n+compare_operands (d0, d1)\n+     struct operand_data *d0, *d1;\n+{\n+  char *p0, *p1;\n+\n+  p0 = d0->predicate;\n+  if (!p0)\n+    p0 = \"\";\n+  p1 = d1->predicate;\n+  if (!p1)\n+    p1 = \"\";\n+  if (strcmp (p0, p1) != 0)\n+    return 0;\n+\n+  if (have_constraints)\n+    {\n+      p0 = d0->constraint;\n+      if (!p0)\n+\tp0 = \"\";\n+      p1 = d1->constraint;\n+      if (!p1)\n+\tp1 = \"\";\n+      if (strcmp (p0, p1) != 0)\n+\treturn 0;\n+    }\n+\n+  if (d0->mode != d1->mode)\n+    return 0;\n+\n+  if (!have_constraints)\n+    if (d0->address_p != d1->address_p)\n+      return 0;\n+\n+  if (d0->strict_low != d1->strict_low)\n+    return 0;\n+\n+  return 1;\n+}\n+\n+/* Scan the list of operands we've already committed to output and either\n+   find a subsequence that is the same, or allocate a new one at the end.  */\n+\n+static void\n+place_operands (d)\n+     struct data *d;\n+{\n+  struct operand_data *od, *od2;\n+  int i;\n+\n+  if (d->n_operands == 0)\n+    {\n+      d->operand_number = 0;\n+      return;\n+    }\n+\n+  /* Brute force substring search.  */\n+  for (od = odata, i = 0; od; od = od->next, i = 0)\n+    if (compare_operands (od, &d->operand[0]))\n+      {\n+\tod2 = od->next;\n+\ti = 1;\n+\twhile (1)\n+\t  {\n+\t    if (i == d->n_operands)\n+\t      goto full_match;\n+\t    if (od2 == NULL)\n+\t      goto partial_match;\n+\t    if (! compare_operands (od2, &d->operand[i]))\n+\t      break;\n+\t    ++i, od2 = od2->next;\n+\t  }\n+      }\n+\n+  /* Either partial match at the end of the list, or no match.  In either\n+     case, we tack on what operands are remaining to the end of the list.  */\n+ partial_match:\n+  d->operand_number = next_operand_number - i;\n+  for (; i < d->n_operands; ++i)\n+    {\n+      od2 = &d->operand[i];\n+      *odata_end = od2;\n+      odata_end = &od2->next;\n+      od2->index = next_operand_number++;\n+    }\n+  *odata_end = NULL;\n+  return;\n+\n+ full_match:\n+  d->operand_number = od->index;\n+  return;\n+}\n+\n \f\n /* Process an assembler template from a define_insn or a define_peephole.\n    It is either the assembler code template, a list of assembler code\n@@ -634,9 +695,9 @@ process_template (d, template)\n     }\n   else\n     {\n-       /* The following is done in a funny way to get around problems in\n-\t  VAX-11 \"C\" on VMS.  It is the equivalent of:\n-\t\tprintf (\"%s\\n\", &template[1])); */\n+      /* The following is done in a funny way to get around problems in\n+\t VAX-11 \"C\" on VMS.  It is the equivalent of:\n+\t printf (\"%s\\n\", &template[1])); */\n       cp = &template[1];\n       while (*cp)\n \t{\n@@ -656,25 +717,26 @@ validate_insn_alternatives (d)\n      struct data *d;\n {\n   register int n = 0, start;\n-  /* Make sure all the operands have the same number of\n-     alternatives in their constraints.\n-     Let N be that number.  */\n+\n+  /* Make sure all the operands have the same number of alternatives\n+     in their constraints.  Let N be that number.  */\n   for (start = 0; start < d->n_operands; start++)\n-    if (d->op_n_alternatives[start] > 0)\n+    if (d->operand[start].n_alternatives > 0)\n       {\n \tif (n == 0)\n-\t  n = d->op_n_alternatives[start];\n-\telse if (n != d->op_n_alternatives[start])\n+\t  n = d->operand[start].n_alternatives;\n+\telse if (n != d->operand[start].n_alternatives)\n \t  error (\"wrong number of alternatives in operand %d of insn %s\",\n-\t\t start, name_for_index (d->index_number));\n+\t\t start, get_insn_name (d->index_number));\n       }\n+\n   /* Record the insn's overall number of alternatives.  */\n   d->n_alternatives = n;\n }\n \f\n-/* Look at a define_insn just read.  Assign its code number.\n-   Record on insn_data the template and the number of arguments.\n-   If the insn has a hairy output action, output a function for now.  */\n+/* Look at a define_insn just read.  Assign its code number.  Record\n+   on idata the template and the number of arguments.  If the insn has\n+   a hairy output action, output a function for now.  */\n \n static void\n gen_insn (insn)\n@@ -693,43 +755,26 @@ gen_insn (insn)\n   /* Build up the list in the same order as the insns are seen\n      in the machine description.  */\n   d->next = 0;\n-  if (end_of_insn_data)\n-    end_of_insn_data->next = d;\n-  else\n-    insn_data = d;\n-\n-  end_of_insn_data = d;\n+  *idata_end = d;\n+  idata_end = &d->next;\n \n   max_opno = -1;\n   num_dups = 0;\n-\n-  memset (constraints, 0, sizeof constraints);\n-  memset (op_n_alternatives, 0, sizeof op_n_alternatives);\n-  memset (predicates, 0, sizeof predicates);\n-  memset (address_p, 0, sizeof address_p);\n-  memset (modes, 0, sizeof modes);\n-  memset (strict_low, 0, sizeof strict_low);\n-  memset (seen, 0, sizeof seen);\n+  memset (d->operand, 0, sizeof (d->operand));\n \n   for (i = 0; i < XVECLEN (insn, 1); i++)\n-    scan_operands (XVECEXP (insn, 1, i), 0, 0);\n+    scan_operands (d, XVECEXP (insn, 1, i), 0, 0);\n \n   d->n_operands = max_opno + 1;\n   d->n_dups = num_dups;\n \n-  memcpy (d->constraints, constraints, sizeof constraints);\n-  memcpy (d->op_n_alternatives, op_n_alternatives, sizeof op_n_alternatives);\n-  memcpy (d->predicates, predicates, sizeof predicates);\n-  memcpy (d->address_p, address_p, sizeof address_p);\n-  memcpy (d->modes, modes, sizeof modes);\n-  memcpy (d->strict_low, strict_low, sizeof strict_low);\n-\n   validate_insn_alternatives (d);\n+  place_operands (d);\n   process_template (d, XSTR (insn, 3));\n }\n \f\n /* Look at a define_peephole just read.  Assign its code number.\n-   Record on insn_data the template and the number of arguments.\n+   Record on idata the template and the number of arguments.\n    If the insn has a hairy output action, output it now.  */\n \n static void\n@@ -746,39 +791,24 @@ gen_peephole (peep)\n   /* Build up the list in the same order as the insns are seen\n      in the machine description.  */\n   d->next = 0;\n-  if (end_of_insn_data)\n-    end_of_insn_data->next = d;\n-  else\n-    insn_data = d;\n-\n-  end_of_insn_data = d;\n+  *idata_end = d;\n+  idata_end = &d->next;\n \n   max_opno = -1;\n-  memset (constraints, 0, sizeof constraints);\n-  memset (op_n_alternatives, 0, sizeof op_n_alternatives);\n-  memset (predicates, 0, sizeof predicates);\n-  memset (address_p, 0, sizeof address_p);\n-  memset (modes, 0, sizeof modes);\n-  memset (strict_low, 0, sizeof strict_low);\n-  memset (seen, 0, sizeof seen);\n-\n-  /* Get the number of operands by scanning all the\n-     patterns of the peephole optimizer.\n-     But ignore all the rest of the information thus obtained.  */\n+  num_dups = 0;\n+  memset (d->operand, 0, sizeof (d->operand));\n+\n+  /* Get the number of operands by scanning all the patterns of the\n+     peephole optimizer.  But ignore all the rest of the information\n+     thus obtained.  */\n   for (i = 0; i < XVECLEN (peep, 0); i++)\n-    scan_operands (XVECEXP (peep, 0, i), 0, 0);\n+    scan_operands (d, XVECEXP (peep, 0, i), 0, 0);\n \n   d->n_operands = max_opno + 1;\n   d->n_dups = 0;\n \n-  memcpy (d->constraints, constraints, sizeof constraints);\n-  memcpy (d->op_n_alternatives, op_n_alternatives, sizeof op_n_alternatives);\n-  memset (d->predicates, 0, sizeof predicates);\n-  memset (d->address_p, 0, sizeof address_p);\n-  memset (d->modes, 0, sizeof modes);\n-  memset (d->strict_low, 0, sizeof strict_low);\n-\n   validate_insn_alternatives (d);\n+  place_operands (d);\n   process_template (d, XSTR (peep, 2));\n }\n \f\n@@ -802,50 +832,32 @@ gen_expand (insn)\n   /* Build up the list in the same order as the insns are seen\n      in the machine description.  */\n   d->next = 0;\n-  if (end_of_insn_data)\n-    end_of_insn_data->next = d;\n-  else\n-    insn_data = d;\n-\n-  end_of_insn_data = d;\n+  *idata_end = d;\n+  idata_end = &d->next;\n \n   max_opno = -1;\n   num_dups = 0;\n+  memset (d->operand, 0, sizeof (d->operand));\n \n   /* Scan the operands to get the specified predicates and modes,\n      since expand_binop needs to know them.  */\n \n-  memset (constraints, 0, sizeof constraints);\n-  memset (op_n_alternatives, 0, sizeof op_n_alternatives);\n-  memset (predicates, 0, sizeof predicates);\n-  memset (address_p, 0, sizeof address_p);\n-  memset (modes, 0, sizeof modes);\n-  memset (strict_low, 0, sizeof strict_low);\n-  memset (seen, 0, sizeof seen);\n-\n   if (XVEC (insn, 1))\n     for (i = 0; i < XVECLEN (insn, 1); i++)\n-      scan_operands (XVECEXP (insn, 1, i), 0, 0);\n+      scan_operands (d, XVECEXP (insn, 1, i), 0, 0);\n \n   d->n_operands = max_opno + 1;\n   d->n_dups = num_dups;\n-\n-  memcpy (d->constraints, constraints, sizeof constraints);\n-  memcpy (d->op_n_alternatives, op_n_alternatives, sizeof op_n_alternatives);\n-  memcpy (d->predicates, predicates, sizeof predicates);\n-  memcpy (d->address_p, address_p, sizeof address_p);\n-  memcpy (d->modes, modes, sizeof modes);\n-  memcpy (d->strict_low, strict_low, sizeof strict_low);\n-\n   d->template = 0;\n   d->outfun = 0;\n+\n   validate_insn_alternatives (d);\n+  place_operands (d);\n }\n \f\n /* Process a define_split just read.  Assign its code number,\n    only for reasons of consistency and to simplify genrecog.  */\n \n-\n static void\n gen_split (split)\n      rtx split;\n@@ -860,43 +872,26 @@ gen_split (split)\n   /* Build up the list in the same order as the insns are seen\n      in the machine description.  */\n   d->next = 0;\n-  if (end_of_insn_data)\n-    end_of_insn_data->next = d;\n-  else\n-    insn_data = d;\n-\n-  end_of_insn_data = d;\n+  *idata_end = d;\n+  idata_end = &d->next;\n \n   max_opno = -1;\n   num_dups = 0;\n+  memset (d->operand, 0, sizeof (d->operand));\n \n-  memset (constraints, 0, sizeof constraints);\n-  memset (op_n_alternatives, 0, sizeof op_n_alternatives);\n-  memset (predicates, 0, sizeof predicates);\n-  memset (address_p, 0, sizeof address_p);\n-  memset (modes, 0, sizeof modes);\n-  memset (strict_low, 0, sizeof strict_low);\n-  memset (seen, 0, sizeof seen);\n-\n-  /* Get the number of operands by scanning all the\n-     patterns of the split patterns.\n-     But ignore all the rest of the information thus obtained.  */\n+  /* Get the number of operands by scanning all the patterns of the\n+     split patterns.  But ignore all the rest of the information thus\n+     obtained.  */\n   for (i = 0; i < XVECLEN (split, 0); i++)\n-    scan_operands (XVECEXP (split, 0, i), 0, 0);\n+    scan_operands (d, XVECEXP (split, 0, i), 0, 0);\n \n   d->n_operands = max_opno + 1;\n-\n-  memset (d->constraints, 0, sizeof constraints);\n-  memset (d->op_n_alternatives, 0, sizeof op_n_alternatives);\n-  memset (d->predicates, 0, sizeof predicates);\n-  memset (d->address_p, 0, sizeof address_p);\n-  memset (d->modes, 0, sizeof modes);\n-  memset (d->strict_low, 0, sizeof strict_low);\n-\n   d->n_dups = 0;\n   d->n_alternatives = 0;\n   d->template = 0;\n   d->outfun = 0;\n+\n+  place_operands (d);\n }\n \f\n PTR\n@@ -974,7 +969,11 @@ main (argc, argv)\n       next_index_number++;\n     }\n \n-  output_epilogue ();\n+  printf(\"\\n\\n\");\n+  output_predicate_decls ();\n+  output_operand_data ();\n+  output_insn_data ();\n+  output_get_insn_name ();\n \n   fflush (stdout);\n   exit (ferror (stdout) != 0 || have_error"}, {"sha": "b9dae533f0a2f81e3ce5aa84c34c2cedca032696", "filename": "gcc/genpeep.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fgenpeep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fgenpeep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpeep.c?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -31,9 +31,6 @@ struct obstack *rtl_obstack = &obstack;\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n-/* Define this so we can link with print-rtl.o to get debug_rtx function.  */\n-char **insn_name_ptr = 0;\n-\n /* While tree-walking an instruction pattern, we keep a chain\n    of these `struct link's to record how to get down to the\n    current position.  In each one, POS is the operand number,\n@@ -493,3 +490,11 @@ from the machine description file `md'.  */\\n\\n\");\n   /* NOTREACHED */\n   return 0;\n }\n+\n+/* Define this so we can link with print-rtl.o to get debug_rtx function.  */\n+const char *\n+get_insn_name (code)\n+     int code;\n+{\n+  return NULL;\n+}"}, {"sha": "0ee656fa8bb274382cb3d02b92603e7e141de5fc", "filename": "gcc/genrecog.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -62,8 +62,8 @@ struct obstack *rtl_obstack = &obstack;\n #define obstack_chunk_free free\n \n /* Holds an array of names indexed by insn_code_number.  */\n-char **insn_name_ptr = 0;\n-int insn_name_ptr_size = 0;\n+static char **insn_name_ptr = 0;\n+static int insn_name_ptr_size = 0;\n \n /* Data structure for a listhead of decision trees.  The alternatives\n    to a node are kept in a doublely-linked list so we can easily add nodes\n@@ -1991,3 +1991,14 @@ from the machine description file `md'.  */\\n\\n\");\n   /* NOTREACHED */\n   return 0;\n }\n+\n+/* Define this so we can link with print-rtl.o to get debug_rtx function.  */\n+const char *\n+get_insn_name (code)\n+     int code;\n+{\n+  if (code < insn_name_ptr_size)\n+    return insn_name_ptr[code];\n+  else\n+    return NULL;\n+}"}, {"sha": "ea1a3d57b01d0084a792f39bd25314cda9a3250a", "filename": "gcc/loop.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -8132,10 +8132,12 @@ check_dbra_loop (loop_end, insn_count, loop_start, loop_info)\n \t\t  enum machine_mode mode = GET_MODE (reg);\n \t\t  enum insn_code icode\n \t\t    = add_optab->handlers[(int) mode].insn_code;\n-\t\t  if (! (*insn_operand_predicate[icode][0]) (reg, mode)\n-\t\t      || ! ((*insn_operand_predicate[icode][1])\n+\n+\t\t  if (! (*insn_data[icode].operand[0].predicate) (reg, mode)\n+\t\t      || ! ((*insn_data[icode].operand[1].predicate)\n \t\t\t    (comparison_value, mode))\n-\t\t      || ! (*insn_operand_predicate[icode][2]) (offset, mode))\n+\t\t      || ! ((*insn_data[icode].operand[2].predicate)\n+\t\t\t    (offset, mode)))\n \t\t    return 0;\n \t\t  start_value\n \t\t    = gen_rtx_PLUS (mode, comparison_value, offset);\n@@ -8151,10 +8153,10 @@ check_dbra_loop (loop_end, insn_count, loop_start, loop_info)\n \t\t  enum machine_mode mode = GET_MODE (reg);\n \t\t  enum insn_code icode\n \t\t    = sub_optab->handlers[(int) mode].insn_code;\n-\t\t  if (! (*insn_operand_predicate[icode][0]) (reg, mode)\n-\t\t      || ! ((*insn_operand_predicate[icode][1])\n+\t\t  if (! (*insn_data[icode].operand[0].predicate) (reg, mode)\n+\t\t      || ! ((*insn_data[icode].operand[1].predicate)\n \t\t\t    (comparison_value, mode))\n-\t\t      || ! ((*insn_operand_predicate[icode][2])\n+\t\t      || ! ((*insn_data[icode].operand[2].predicate)\n \t\t\t    (initial_value, mode)))\n \t\t    return 0;\n \t\t  start_value"}, {"sha": "558be7d12b5fce14f3aaa52b4d26906d47dad689", "filename": "gcc/optabs.c", "status": "modified", "additions": 48, "deletions": 42, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -677,8 +677,8 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n       && binoptab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n     {\n       int icode = (int) binoptab->handlers[(int) mode].insn_code;\n-      enum machine_mode mode0 = insn_operand_mode[icode][1];\n-      enum machine_mode mode1 = insn_operand_mode[icode][2];\n+      enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n+      enum machine_mode mode1 = insn_data[icode].operand[2].mode;\n       rtx pat;\n       rtx xop0 = op0, xop1 = op1;\n \n@@ -717,15 +717,15 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n       /* Now, if insn's predicates don't allow our operands, put them into\n \t pseudo regs.  */\n \n-      if (! (*insn_operand_predicate[icode][1]) (xop0, mode0)\n+      if (! (*insn_data[icode].operand[1].predicate) (xop0, mode0)\n \t  && mode0 != VOIDmode)\n \txop0 = copy_to_mode_reg (mode0, xop0);\n \n-      if (! (*insn_operand_predicate[icode][2]) (xop1, mode1)\n+      if (! (*insn_data[icode].operand[2].predicate) (xop1, mode1)\n \t  && mode1 != VOIDmode)\n \txop1 = copy_to_mode_reg (mode1, xop1);\n \n-      if (! (*insn_operand_predicate[icode][0]) (temp, mode))\n+      if (! (*insn_data[icode].operand[0].predicate) (temp, mode))\n \ttemp = gen_reg_rtx (mode);\n \n       pat = GEN_FCN (icode) (temp, xop0, xop1);\n@@ -1899,8 +1899,8 @@ expand_twoval_binop (binoptab, op0, op1, targ0, targ1, unsignedp)\n   if (binoptab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n     {\n       int icode = (int) binoptab->handlers[(int) mode].insn_code;\n-      enum machine_mode mode0 = insn_operand_mode[icode][1];\n-      enum machine_mode mode1 = insn_operand_mode[icode][2];\n+      enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n+      enum machine_mode mode1 = insn_data[icode].operand[2].mode;\n       rtx pat;\n       rtx xop0 = op0, xop1 = op1;\n \n@@ -1913,16 +1913,16 @@ expand_twoval_binop (binoptab, op0, op1, targ0, targ1, unsignedp)\n \txop1 = convert_to_mode (mode1, xop1, unsignedp);\n \n       /* Now, if insn doesn't accept these operands, put them into pseudos.  */\n-      if (! (*insn_operand_predicate[icode][1]) (xop0, mode0))\n+      if (! (*insn_data[icode].operand[1].predicate) (xop0, mode0))\n \txop0 = copy_to_mode_reg (mode0, xop0);\n \n-      if (! (*insn_operand_predicate[icode][2]) (xop1, mode1))\n+      if (! (*insn_data[icode].operand[2].predicate) (xop1, mode1))\n \txop1 = copy_to_mode_reg (mode1, xop1);\n \n       /* We could handle this, but we should always be called with a pseudo\n \t for our targets and all insns should take them as outputs.  */\n-      if (! (*insn_operand_predicate[icode][0]) (targ0, mode)\n-\t  || ! (*insn_operand_predicate[icode][3]) (targ1, mode))\n+      if (! (*insn_data[icode].operand[0].predicate) (targ0, mode)\n+\t  || ! (*insn_data[icode].operand[3].predicate) (targ1, mode))\n \tabort ();\n \t\n       pat = GEN_FCN (icode) (targ0, xop0, xop1, targ1);\n@@ -2009,7 +2009,7 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n   if (unoptab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n     {\n       int icode = (int) unoptab->handlers[(int) mode].insn_code;\n-      enum machine_mode mode0 = insn_operand_mode[icode][1];\n+      enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n       rtx xop0 = op0;\n \n       if (target)\n@@ -2023,10 +2023,10 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n \n       /* Now, if insn doesn't accept our operand, put it into a pseudo.  */\n \n-      if (! (*insn_operand_predicate[icode][1]) (xop0, mode0))\n+      if (! (*insn_data[icode].operand[1].predicate) (xop0, mode0))\n \txop0 = copy_to_mode_reg (mode0, xop0);\n \n-      if (! (*insn_operand_predicate[icode][0]) (temp, mode))\n+      if (! (*insn_data[icode].operand[0].predicate) (temp, mode))\n \ttemp = gen_reg_rtx (mode);\n \n       pat = GEN_FCN (icode) (temp, xop0);\n@@ -2370,7 +2370,7 @@ expand_complex_abs (mode, op0, target, unsignedp)\n   if (abs_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n     {\n       int icode = (int) abs_optab->handlers[(int) mode].insn_code;\n-      enum machine_mode mode0 = insn_operand_mode[icode][1];\n+      enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n       rtx xop0 = op0;\n \n       if (target)\n@@ -2384,10 +2384,10 @@ expand_complex_abs (mode, op0, target, unsignedp)\n \n       /* Now, if insn doesn't accept our operand, put it into a pseudo.  */\n \n-      if (! (*insn_operand_predicate[icode][1]) (xop0, mode0))\n+      if (! (*insn_data[icode].operand[1].predicate) (xop0, mode0))\n \txop0 = copy_to_mode_reg (mode0, xop0);\n \n-      if (! (*insn_operand_predicate[icode][0]) (temp, submode))\n+      if (! (*insn_data[icode].operand[0].predicate) (temp, submode))\n \ttemp = gen_reg_rtx (submode);\n \n       pat = GEN_FCN (icode) (temp, xop0);\n@@ -2534,7 +2534,7 @@ emit_unop_insn (icode, target, op0, code)\n      enum rtx_code code;\n {\n   register rtx temp;\n-  enum machine_mode mode0 = insn_operand_mode[icode][1];\n+  enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n   rtx pat;\n \n   temp = target = protect_from_queue (target, 1);\n@@ -2549,10 +2549,10 @@ emit_unop_insn (icode, target, op0, code)\n \n   /* Now, if insn does not accept our operands, put them into pseudos.  */\n \n-  if (! (*insn_operand_predicate[icode][1]) (op0, mode0))\n+  if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n     op0 = copy_to_mode_reg (mode0, op0);\n \n-  if (! (*insn_operand_predicate[icode][0]) (temp, GET_MODE (temp))\n+  if (! (*insn_data[icode].operand[0].predicate) (temp, GET_MODE (temp))\n       || (flag_force_mem && GET_CODE (temp) == MEM))\n     temp = gen_reg_rtx (GET_MODE (temp));\n \n@@ -2924,7 +2924,7 @@ prepare_cmp_insn (px, py, pcomparison, size, pmode, punsignedp, align)\n \t  && GET_CODE (size) == CONST_INT\n \t  && INTVAL (size) < (1 << GET_MODE_BITSIZE (QImode)))\n \t{\n-\t  result_mode = insn_operand_mode[(int) CODE_FOR_cmpstrqi][0];\n+\t  result_mode = insn_data[(int) CODE_FOR_cmpstrqi].operand[0].mode;\n \t  result = gen_reg_rtx (result_mode);\n \t  emit_insn (gen_cmpstrqi (result, x, y, size, GEN_INT (align)));\n \t}\n@@ -2935,7 +2935,7 @@ prepare_cmp_insn (px, py, pcomparison, size, pmode, punsignedp, align)\n \t  && GET_CODE (size) == CONST_INT\n \t  && INTVAL (size) < (1 << GET_MODE_BITSIZE (HImode)))\n \t{\n-\t  result_mode = insn_operand_mode[(int) CODE_FOR_cmpstrhi][0];\n+\t  result_mode = insn_data[(int) CODE_FOR_cmpstrhi].operand[0].mode;\n \t  result = gen_reg_rtx (result_mode);\n \t  emit_insn (gen_cmpstrhi (result, x, y, size, GEN_INT (align)));\n \t}\n@@ -2944,7 +2944,7 @@ prepare_cmp_insn (px, py, pcomparison, size, pmode, punsignedp, align)\n #ifdef HAVE_cmpstrsi\n       if (HAVE_cmpstrsi)\n \t{\n-\t  result_mode = insn_operand_mode[(int) CODE_FOR_cmpstrsi][0];\n+\t  result_mode = insn_data[(int) CODE_FOR_cmpstrsi].operand[0].mode;\n \t  result = gen_reg_rtx (result_mode);\n \t  size = protect_from_queue (size, 0);\n \t  emit_insn (gen_cmpstrsi (result, x, y,\n@@ -3044,9 +3044,9 @@ prepare_operand (icode, x, opnum, mode, wider_mode, unsignedp)\n   if (mode != wider_mode)\n     x = convert_modes (wider_mode, mode, x, unsignedp);\n \n-  if (! (*insn_operand_predicate[icode][opnum])\n-      (x, insn_operand_mode[icode][opnum]))\n-    x = copy_to_mode_reg (insn_operand_mode[icode][opnum], x);\n+  if (! (*insn_data[icode].operand[opnum].predicate)\n+      (x, insn_data[icode].operand[opnum].mode))\n+    x = copy_to_mode_reg (insn_data[icode].operand[opnum].mode, x);\n   return x;\n }\n \n@@ -3413,7 +3413,7 @@ void\n emit_indirect_jump (loc)\n      rtx loc;\n {\n-  if (! ((*insn_operand_predicate[(int)CODE_FOR_indirect_jump][0])\n+  if (! ((*insn_data[(int)CODE_FOR_indirect_jump].operand[0].predicate)\n \t (loc, Pmode)))\n     loc = copy_to_mode_reg (Pmode, loc);\n \n@@ -3513,17 +3513,17 @@ emit_conditional_move (target, code, op0, op1, cmode, op2, op3, mode,\n \n   /* If the insn doesn't accept these operands, put them in pseudos.  */\n \n-  if (! (*insn_operand_predicate[icode][0])\n-      (subtarget, insn_operand_mode[icode][0]))\n-    subtarget = gen_reg_rtx (insn_operand_mode[icode][0]);\n+  if (! (*insn_data[icode].operand[0].predicate)\n+      (subtarget, insn_data[icode].operand[0].mode))\n+    subtarget = gen_reg_rtx (insn_data[icode].operand[0].mode);\n \n-  if (! (*insn_operand_predicate[icode][2])\n-      (op2, insn_operand_mode[icode][2]))\n-    op2 = copy_to_mode_reg (insn_operand_mode[icode][2], op2);\n+  if (! (*insn_data[icode].operand[2].predicate)\n+      (op2, insn_data[icode].operand[2].mode))\n+    op2 = copy_to_mode_reg (insn_data[icode].operand[2].mode, op2);\n \n-  if (! (*insn_operand_predicate[icode][3])\n-      (op3, insn_operand_mode[icode][3]))\n-    op3 = copy_to_mode_reg (insn_operand_mode[icode][3], op3);\n+  if (! (*insn_data[icode].operand[3].predicate)\n+      (op3, insn_data[icode].operand[3].mode))\n+    op3 = copy_to_mode_reg (insn_data[icode].operand[3].mode, op3);\n \n   /* Everything should now be in the suitable form, so emit the compare insn\n      and then the conditional move.  */\n@@ -3585,9 +3585,12 @@ gen_add2_insn (x, y)\n {\n   int icode = (int) add_optab->handlers[(int) GET_MODE (x)].insn_code; \n \n-  if (! (*insn_operand_predicate[icode][0]) (x, insn_operand_mode[icode][0])\n-      || ! (*insn_operand_predicate[icode][1]) (x, insn_operand_mode[icode][1])\n-      || ! (*insn_operand_predicate[icode][2]) (y, insn_operand_mode[icode][2]))\n+  if (! ((*insn_data[icode].operand[0].predicate)\n+\t (x, insn_data[icode].operand[0].mode))\n+      || ! ((*insn_data[icode].operand[1].predicate)\n+\t    (x, insn_data[icode].operand[1].mode))\n+      || ! ((*insn_data[icode].operand[2].predicate)\n+\t    (y, insn_data[icode].operand[2].mode)))\n     abort ();\n \n   return (GEN_FCN (icode) (x, x, y));\n@@ -3608,9 +3611,12 @@ gen_sub2_insn (x, y)\n {\n   int icode = (int) sub_optab->handlers[(int) GET_MODE (x)].insn_code; \n \n-  if (! (*insn_operand_predicate[icode][0]) (x, insn_operand_mode[icode][0])\n-      || ! (*insn_operand_predicate[icode][1]) (x, insn_operand_mode[icode][1])\n-      || ! (*insn_operand_predicate[icode][2]) (y, insn_operand_mode[icode][2]))\n+  if (! ((*insn_data[icode].operand[0].predicate)\n+\t (x, insn_data[icode].operand[0].mode))\n+      || ! ((*insn_data[icode].operand[1].predicate)\n+\t    (x, insn_data[icode].operand[1].mode))\n+      || ! ((*insn_data[icode].operand[2].predicate)\n+\t    (y, insn_data[icode].operand[2].mode)))\n     abort ();\n \n   return (GEN_FCN (icode) (x, x, y));"}, {"sha": "59193f4c7ebdc3972bc75fb31285358fc04c2927", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -52,9 +52,9 @@ static int sawclose = 0;\n \n static int indent;\n \n-/* Names for patterns.  Non-zero only when linked with insn-output.c.  */\n+/* Names for patterns.  */\n \n-extern char **insn_name_ptr;\n+extern const char *get_insn_name PROTO ((int));\n \n static void print_rtx\t\tPROTO ((rtx));\n \n@@ -246,6 +246,7 @@ print_rtx (in_rtx)\n       case 'i':\n \t{\n \t  register int value = XINT (in_rtx, i);\n+\t  const char *name;\n \n \t  if (GET_CODE (in_rtx) == REG && value < FIRST_PSEUDO_REGISTER)\n \t    {\n@@ -273,12 +274,13 @@ print_rtx (in_rtx)\n \t    fputc ('#', outfile);\n \t  else\n \t    fprintf (outfile, \" %d\", value);\n+\n+\t  if (is_insn && &INSN_CODE (in_rtx) == &XINT (in_rtx, i)\n+\t      && XINT (in_rtx, i) >= 0\n+\t      && (name = get_insn_name (XINT (in_rtx, i))) != NULL)\n+\t    fprintf (outfile, \" {%s}\", name);\n+\t  sawclose = 0;\n \t}\n-\tif (is_insn && &INSN_CODE (in_rtx) == &XINT (in_rtx, i)\n-\t    && insn_name_ptr\n-\t    && XINT (in_rtx, i) >= 0)\n-\t  fprintf (outfile, \" {%s}\", insn_name_ptr[XINT (in_rtx, i)]);\n-\tsawclose = 0;\n \tbreak;\n \n       /* Print NOTE_INSN names rather than integer codes.  */"}, {"sha": "1d4014ba1ec0273fbcdecb2681d6791bb204cf18", "filename": "gcc/recog.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -543,15 +543,15 @@ validate_replace_rtx_1 (loc, from, to, object)\n #ifdef HAVE_extzv\n \t  if (code == ZERO_EXTRACT)\n \t    {\n-\t      wanted_mode = insn_operand_mode[(int) CODE_FOR_extzv][1];\n+\t      wanted_mode = insn_data[(int) CODE_FOR_extzv].operand[1].mode;\n \t      if (wanted_mode == VOIDmode)\n \t\twanted_mode = word_mode;\n \t    }\n #endif\n #ifdef HAVE_extv\n \t  if (code == SIGN_EXTRACT)\n \t    {\n-\t      wanted_mode = insn_operand_mode[(int) CODE_FOR_extv][1];\n+\t      wanted_mode = insn_data[(int) CODE_FOR_extv].operand[1].mode;\n \t      if (wanted_mode == VOIDmode)\n \t\twanted_mode = word_mode;\n \t    }\n@@ -2027,20 +2027,21 @@ extract_insn (insn)\n       if (icode < 0)\n \tfatal_insn_not_found (insn);\n \n-      recog_data.n_operands = noperands = insn_n_operands[icode];\n-      recog_data.n_alternatives = insn_n_alternatives[icode];\n-      recog_data.n_dups = insn_n_dups[icode];\n+      recog_data.n_operands = noperands = insn_data[icode].n_operands;\n+      recog_data.n_alternatives = insn_data[icode].n_alternatives;\n+      recog_data.n_dups = insn_data[icode].n_dups;\n \n       insn_extract (insn);\n \n       for (i = 0; i < noperands; i++)\n \t{\n #ifdef REGISTER_CONSTRAINTS\n-\t  recog_data.constraints[i] = insn_operand_constraint[icode][i];\n+\t  recog_data.constraints[i] = insn_data[icode].operand[i].constraint;\n #else\n-\t  recog_data.operand_address_p[i] = insn_operand_address_p[icode][i];\n+\t  recog_data.operand_address_p[i]\n+\t    = insn_data[icode].operand[i].address_p;\n #endif\n-\t  recog_data.operand_mode[i] = insn_operand_mode[icode][i];\n+\t  recog_data.operand_mode[i] = insn_data[icode].operand[i].mode;\n \t}\n     }\n   for (i = 0; i < noperands; i++)"}, {"sha": "0d4cc977cf57e0ab6dc681f01ab327caece9650f", "filename": "gcc/recog.h", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -181,40 +181,47 @@ extern struct operand_alternative recog_op_alt[MAX_RECOG_OPERANDS][MAX_RECOG_ALT\n \n /* Access the output function for CODE.  */\n \n-#define OUT_FCN(CODE) (*insn_outfun[(int) (CODE)])\n+#define OUT_FCN(CODE) (*insn_data[(int) (CODE)].outfun)\n \n-/* Tables defined in insn-output.c that give information about\n+/* A table defined in insn-output.c that give information about\n    each insn-code value.  */\n \n-/* These are vectors indexed by insn-code.  Details in genoutput.c.  */\n-\n-extern const char *const insn_template[];\n-\n-extern const char *(*const insn_outfun[]) PROTO ((rtx *, rtx));\n-\n-extern const int insn_n_operands[];\n-\n-extern const int insn_n_dups[];\n-\n-/* Indexed by insn code number, gives # of constraint alternatives.  */\n-\n-extern const int insn_n_alternatives[];\n+typedef int (*insn_operand_predicate_fn) PROTO ((rtx, enum machine_mode));\n+typedef const char * (*insn_output_fn) PROTO ((rtx *, rtx));\n+#ifndef NO_MD_PROTOTYPES\n+typedef rtx (*insn_gen_fn) PROTO ((rtx, ...));\n+#else\n+typedef rtx (*insn_gen_fn) ();\n+#endif\n \n-/* These are two-dimensional arrays indexed first by the insn-code\n-   and second by the operand number.  Details in genoutput.c.  */\n+struct insn_operand_data\n+{\n+  insn_operand_predicate_fn predicate;\n \n-#ifdef REGISTER_CONSTRAINTS  /* Avoid undef sym in certain broken linkers.  */\n-extern const char *const insn_operand_constraint[][MAX_RECOG_OPERANDS];\n+#ifdef REGISTER_CONSTRAINTS\n+  const char *constraint;\n #endif\n \n-#ifndef REGISTER_CONSTRAINTS  /* Avoid undef sym in certain broken linkers.  */\n-extern const char insn_operand_address_p[][MAX_RECOG_OPERANDS];\n+  enum machine_mode mode;\n+\n+#ifndef REGISTER_CONSTRAINTS\n+  char address_p;\n #endif\n \n-extern const enum machine_mode insn_operand_mode[][MAX_RECOG_OPERANDS];\n+  char strict_low;\n+};\n \n-extern const char insn_operand_strict_low[][MAX_RECOG_OPERANDS];\n+struct insn_data\n+{\n+  const char *name;\n+  const char *template;\n+  insn_output_fn outfun;\n+  insn_gen_fn genfun;\n+  const struct insn_operand_data *operand;\n \n-extern int (*const insn_operand_predicate[][MAX_RECOG_OPERANDS]) PROTO ((rtx, enum machine_mode));\n+  unsigned char n_operands;\n+  unsigned char n_dups;\n+  unsigned char n_alternatives;\n+};\n \n-extern const char * insn_name[];\n+extern const struct insn_data insn_data[];"}, {"sha": "9a7a191ea7f53d5a0108e20da58ae000e631606c", "filename": "gcc/regmove.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -89,9 +89,12 @@ gen_add3_insn (r0, r1, c)\n   int icode = (int) add_optab->handlers[(int) GET_MODE (r0)].insn_code;\n \n     if (icode == CODE_FOR_nothing\n-      || ! (*insn_operand_predicate[icode][0]) (r0, insn_operand_mode[icode][0])\n-      || ! (*insn_operand_predicate[icode][1]) (r1, insn_operand_mode[icode][1])\n-      || ! (*insn_operand_predicate[icode][2]) (c, insn_operand_mode[icode][2]))\n+      || ! ((*insn_data[icode].operand[0].predicate)\n+\t    (r0, insn_data[icode].operand[0].mode))\n+      || ! ((*insn_data[icode].operand[1].predicate)\n+\t    (r1, insn_data[icode].operand[1].mode))\n+      || ! ((*insn_data[icode].operand[2].predicate)\n+\t    (c, insn_data[icode].operand[2].mode)))\n     return NULL_RTX;\n \n   return (GEN_FCN (icode) (r0, r1, c));"}, {"sha": "ac186331df95620458d3572a9987a25c92480376", "filename": "gcc/reload.c", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -427,8 +427,8 @@ push_secondary_reload (in_p, x, opnum, optional, reload_class, reload_mode,\n \t   : reload_out_optab[(int) reload_mode]);\n \n   if (icode != CODE_FOR_nothing\n-      && insn_operand_predicate[(int) icode][in_p]\n-      && (! (insn_operand_predicate[(int) icode][in_p]) (x, reload_mode)))\n+      && insn_data[(int) icode].operand[in_p].predicate\n+      && (! (insn_data[(int) icode].operand[in_p].predicate) (x, reload_mode)))\n     icode = CODE_FOR_nothing;\n \n   /* If we will be using an insn, see if it can directly handle the reload\n@@ -444,25 +444,27 @@ push_secondary_reload (in_p, x, opnum, optional, reload_class, reload_mode,\n \t in operand 1.  Outputs should have an initial \"=\", which we must\n \t skip.  */\n \n-      char insn_letter = insn_operand_constraint[(int) icode][!in_p][in_p];\n+      char insn_letter\n+\t= insn_data[(int) icode].operand[!in_p].constraint[in_p];\n       enum reg_class insn_class\n \t= (insn_letter == 'r' ? GENERAL_REGS\n \t   : REG_CLASS_FROM_LETTER ((unsigned char) insn_letter));\n \n       if (insn_class == NO_REGS\n-\t  || (in_p && insn_operand_constraint[(int) icode][!in_p][0] != '=')\n+\t  || (in_p\n+\t      && insn_data[(int) icode].operand[!in_p].constraint[0] != '=')\n \t  /* The scratch register's constraint must start with \"=&\".  */\n-\t  || insn_operand_constraint[(int) icode][2][0] != '='\n-\t  || insn_operand_constraint[(int) icode][2][1] != '&')\n+\t  || insn_data[(int) icode].operand[2].constraint[0] != '='\n+\t  || insn_data[(int) icode].operand[2].constraint[1] != '&')\n \tabort ();\n \n       if (reg_class_subset_p (reload_class, insn_class))\n-\tmode = insn_operand_mode[(int) icode][2];\n+\tmode = insn_data[(int) icode].operand[2].mode;\n       else\n \t{\n-\t  char t_letter = insn_operand_constraint[(int) icode][2][2];\n+\t  char t_letter = insn_data[(int) icode].operand[2].constraint[2];\n \t  class = insn_class;\n-\t  t_mode = insn_operand_mode[(int) icode][2];\n+\t  t_mode = insn_data[(int) icode].operand[2].mode;\n \t  t_class = (t_letter == 'r' ? GENERAL_REGS\n \t\t     : REG_CLASS_FROM_LETTER ((unsigned char) t_letter));\n \t  t_icode = icode;\n@@ -1785,9 +1787,9 @@ combine_reloads ()\n   if (INSN_CODE (this_insn) == -1)\n     return;\n \n-  for (i = 1; i < insn_n_operands[INSN_CODE (this_insn)]; i++)\n-    if (insn_operand_constraint[INSN_CODE (this_insn)][i][0] == '='\n-\t|| insn_operand_constraint[INSN_CODE (this_insn)][i][0] == '+')\n+  for (i = 1; i < insn_data[INSN_CODE (this_insn)].n_operands; i++)\n+    if (insn_data[INSN_CODE (this_insn)].operand[i].constraint[0] == '='\n+\t|| insn_data[INSN_CODE (this_insn)].operand[i].constraint[0] == '+')\n       return;\n \n   /* See if some hard register that dies in this insn and is not used in\n@@ -3700,7 +3702,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t     (modified[i] == RELOAD_READ\n \t\t\t      ? VOIDmode : operand_mode[i]),\n \t\t\t     (insn_code_number < 0 ? 0\n-\t\t\t      : insn_operand_strict_low[insn_code_number][i]),\n+\t\t\t      : insn_data[insn_code_number].operand[i].strict_low),\n \t\t\t     0, i, operand_type[i]);\n \t  }\n \t/* In a matching pair of operands, one must be input only\n@@ -3790,7 +3792,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t   (modified[i] == RELOAD_READ\n \t\t\t    ? VOIDmode : operand_mode[i]),\n \t\t\t   (insn_code_number < 0 ? 0\n-\t\t\t    : insn_operand_strict_low[insn_code_number][i]),\n+\t\t\t    : insn_data[insn_code_number].operand[i].strict_low),\n \t\t\t   1, i, operand_type[i]);\n \t/* If a memory reference remains (either as a MEM or a pseudo that\n \t   did not get a hard register), yet we can't make an optional\n@@ -3886,13 +3888,13 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n      it doesn't expect.  */\n \n   if (insn_code_number >= 0 && replace)\n-    for (i = insn_n_dups[insn_code_number] - 1; i >= 0; i--)\n+    for (i = insn_data[insn_code_number].n_dups - 1; i >= 0; i--)\n       {\n \tint opno = recog_data.dup_num[i];\n \t*recog_data.dup_loc[i] = *recog_data.operand_loc[opno];\n \tif (operand_reloadnum[opno] >= 0)\n \t  push_replacement (recog_data.dup_loc[i], operand_reloadnum[opno],\n-\t\t\t    insn_operand_mode[insn_code_number][opno]);\n+\t\t\t    insn_data[insn_code_number].operand[opno].mode);\n       }\n \n #if 0\n@@ -4274,7 +4276,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n       int is_set_dest = GET_CODE (body) == SET && (i == 0);\n \n       if (insn_code_number >= 0)\n-\tif (insn_operand_address_p[insn_code_number][i])\n+\tif (insn_data[insn_code_number].operand[i].address_p)\n \t  find_reloads_address (VOIDmode, NULL_PTR,\n \t\t\t\trecog_data.operand[i],\n \t\t\t\trecog_data.operand_loc[i],\n@@ -5333,8 +5335,10 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t\t  && ! sets_cc0_p (PATTERN (insn))\n #endif\n \t\t  && ! (icode != CODE_FOR_nothing\n-\t\t\t&& (*insn_operand_predicate[icode][0]) (equiv, Pmode)\n-\t\t\t&& (*insn_operand_predicate[icode][1]) (equiv, Pmode)))\n+\t\t\t&& ((*insn_data[icode].operand[0].predicate)\n+\t\t\t    (equiv, Pmode))\n+\t\t\t&& ((*insn_data[icode].operand[1].predicate)\n+\t\t\t    (equiv, Pmode))))\n \t\t{\n \t\t  loc = &XEXP (x, 0);\n \t\t  x = XEXP (x, 0);\n@@ -6730,13 +6734,13 @@ debug_reload_to_stream (f)\n       if (reload_secondary_in_icode[r] != CODE_FOR_nothing)\n \t{\n \t  fprintf (stderr, \"%ssecondary_in_icode = %s\", prefix,\n-\t\t   insn_name[reload_secondary_in_icode[r]]);\n+\t\t   insn_data[reload_secondary_in_icode[r]].name);\n \t  prefix = \", \";\n \t}\n \n       if (reload_secondary_out_icode[r] != CODE_FOR_nothing)\n \tfprintf (stderr, \"%ssecondary_out_icode = %s\", prefix,\n-\t\t insn_name[reload_secondary_out_icode[r]]);\n+\t\t insn_data[reload_secondary_out_icode[r]].name);\n \n       fprintf (f, \"\\n\");\n     }"}, {"sha": "fdbc9459375e56a0c33c4b7b1e5af6c8b0c9d283", "filename": "gcc/reload1.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -6816,7 +6816,7 @@ emit_reload_insns (chain)\n \t\t  /* Make sure we can access insn_operand_constraint.  */\n \t\t  && asm_noperands (PATTERN (temp)) < 0\n \t\t  /* This is unsafe if prev insn rejects our reload reg.  */\n-\t\t  && constraint_accepts_reg_p (insn_operand_constraint[recog_memoized (temp)][0],\n+\t\t  && constraint_accepts_reg_p (insn_data[recog_memoized (temp)].operand[0].constraint,\n \t\t\t\t\t       reloadreg)\n \t\t  /* This is unsafe if operand occurs more than once in current\n \t\t     insn.  Perhaps some occurrences aren't reloaded.  */\n@@ -6945,18 +6945,18 @@ emit_reload_insns (chain)\n \t\t\t    {\n \t\t\t      new_icode = reload_in_optab[(int) mode];\n \t\t\t      if (new_icode != CODE_FOR_nothing\n-\t\t\t\t  && ((insn_operand_predicate[(int) new_icode][0]\n-\t\t\t\t       && ! ((*insn_operand_predicate[(int) new_icode][0])\n+\t\t\t\t  && ((insn_data[(int) new_icode].operand[0].predicate\n+\t\t\t\t       && ! ((*insn_data[(int) new_icode].operand[0].predicate)\n \t\t\t\t\t     (reloadreg, mode)))\n-\t\t\t\t      || (insn_operand_predicate[(int) new_icode][1]\n-\t\t\t\t\t  && ! ((*insn_operand_predicate[(int) new_icode][1])\n+\t\t\t\t      || (insn_data[(int) new_icode].operand[1].predicate\n+\t\t\t\t\t  && ! ((*insn_data[(int) new_icode].operand[1].predicate)\n \t\t\t\t\t\t(real_oldequiv, mode)))))\n \t\t\t\tnew_icode = CODE_FOR_nothing;\n \n \t\t\t      if (new_icode == CODE_FOR_nothing)\n \t\t\t\tnew_mode = mode;\n \t\t\t      else\n-\t\t\t\tnew_mode = insn_operand_mode[(int) new_icode][2];\n+\t\t\t\tnew_mode = insn_data[(int) new_icode].operand[2].mode;\n \n \t\t\t      if (GET_MODE (second_reload_reg) != new_mode)\n \t\t\t\t{\n@@ -7840,7 +7840,8 @@ gen_reload (out, in, opnum, type)\n \t  || (GET_CODE (op1) == REG\n \t      && REGNO (op1) >= FIRST_PSEUDO_REGISTER)\n \t  || (code != CODE_FOR_nothing\n-\t      && ! (*insn_operand_predicate[code][2]) (op1, insn_operand_mode[code][2])))\n+\t      && ! ((*insn_data[code].operand[2].predicate)\n+\t\t    (op1, insn_data[code].operand[2].mode))))\n \ttem = op0, op0 = op1, op1 = tem;\n \n       gen_reload (out, op0, opnum, type);"}, {"sha": "107735f359d2648a34450fe87fca0b79fc5370dc", "filename": "gcc/stmt.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -5442,22 +5442,22 @@ expand_end_case (orig_index)\n \t      index = protect_from_queue (index, 0);\n \t      do_pending_stack_adjust ();\n \n-\t      op_mode = insn_operand_mode[(int)CODE_FOR_casesi][0];\n-\t      if (! (*insn_operand_predicate[(int)CODE_FOR_casesi][0])\n+\t      op_mode = insn_data[(int)CODE_FOR_casesi].operand[0].mode;\n+\t      if (! (*insn_data[(int)CODE_FOR_casesi].operand[0].predicate)\n \t\t  (index, op_mode))\n \t\tindex = copy_to_mode_reg (op_mode, index);\n \n \t      op1 = expand_expr (minval, NULL_RTX, VOIDmode, 0);\n \n-\t      op_mode = insn_operand_mode[(int)CODE_FOR_casesi][1];\n-\t      if (! (*insn_operand_predicate[(int)CODE_FOR_casesi][1])\n+\t      op_mode = insn_data[(int)CODE_FOR_casesi].operand[1].mode;\n+\t      if (! (*insn_data[(int)CODE_FOR_casesi].operand[1].predicate)\n \t\t  (op1, op_mode))\n \t\top1 = copy_to_mode_reg (op_mode, op1);\n \n \t      op2 = expand_expr (range, NULL_RTX, VOIDmode, 0);\n \n-\t      op_mode = insn_operand_mode[(int)CODE_FOR_casesi][2];\n-\t      if (! (*insn_operand_predicate[(int)CODE_FOR_casesi][2])\n+\t      op_mode = insn_data[(int)CODE_FOR_casesi].operand[2].mode;\n+\t      if (! (*insn_data[(int)CODE_FOR_casesi].operand[2].predicate)\n \t\t  (op2, op_mode))\n \t\top2 = copy_to_mode_reg (op_mode, op2);\n "}, {"sha": "b1b3b8fa318cfa87d81b9ffb7d621e9c7569d394", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a995e389c4aed94fbfc35bd283ade7dd775add7c/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=a995e389c4aed94fbfc35bd283ade7dd775add7c", "patch": "@@ -3171,8 +3171,8 @@ compile_file (name)\n     {\n       /* It's best if we can write a nop here since some\n \t assemblers don't tolerate zeros in the text section.  */\n-      if (insn_template[CODE_FOR_nop] != 0)\n-\toutput_asm_insn (insn_template[CODE_FOR_nop], NULL_PTR);\n+      if (insn_data[CODE_FOR_nop].template != 0)\n+\toutput_asm_insn (insn_data[CODE_FOR_nop].template, NULL_PTR);\n       else\n \tassemble_zeros (UNITS_PER_WORD);\n     }"}]}