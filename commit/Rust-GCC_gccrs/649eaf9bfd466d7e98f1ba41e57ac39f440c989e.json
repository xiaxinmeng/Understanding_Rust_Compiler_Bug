{"sha": "649eaf9bfd466d7e98f1ba41e57ac39f440c989e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ5ZWFmOWJmZDQ2NmQ3ZTk4ZjFiYTQxZTU3YWMzOWY0NDBjOTg5ZQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-03-21T17:10:02Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-03-21T17:10:02Z"}, "message": "javaop.h (jfloat, jdouble): Make them structures mirroring the bit fields of IEEE float and double respectively.\n\n\t* javaop.h (jfloat, jdouble): Make them structures mirroring\n\tthe bit fields of IEEE float and double respectively.\n\t(JFLOAT_FINITE, JFLOAT_QNAN_MASK, JFLOAT_EXP_BIAS,\n\tJDOUBLE_FINITE, JDOUBLE_QNAN_MASK, JDOUBLE_EXP_BIAS): New.\n\t(union Word, union DWord): Delete.\n\t(WORD_TO_FLOAT, WORDS_TO_DOUBLE): Update to match.\n\n\t* gjavah.c (java_float_finite, java_double_finite, F_NAN_MASK,\n\tD_NAN_MASK): Delete.\n\t(jni_print_float, jni_print_double): New.  Generate\n\thexadecimal floating constants.\n\t(print_field_info): Use jni_print_float/double.\n\n\t* jcf-dump.c: Include math.h.  Use ldexp/frexp to assemble\n\tfinite floating point numbers for output; special case\n\tnon-finite floats.\n\nFrom-SVN: r64671", "tree": {"sha": "f92bcd0dd5b17043f1634195bcbf18c4df1df8da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f92bcd0dd5b17043f1634195bcbf18c4df1df8da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/649eaf9bfd466d7e98f1ba41e57ac39f440c989e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/649eaf9bfd466d7e98f1ba41e57ac39f440c989e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/649eaf9bfd466d7e98f1ba41e57ac39f440c989e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/649eaf9bfd466d7e98f1ba41e57ac39f440c989e/comments", "author": null, "committer": null, "parents": [{"sha": "c0510d84b7e1e57f475d27a3390b7177a1cf9d27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0510d84b7e1e57f475d27a3390b7177a1cf9d27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0510d84b7e1e57f475d27a3390b7177a1cf9d27"}], "stats": {"total": 276, "additions": 188, "deletions": 88}, "files": [{"sha": "1b980aea61052f723e2ac392c30d95f4ef6ed43c", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649eaf9bfd466d7e98f1ba41e57ac39f440c989e/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649eaf9bfd466d7e98f1ba41e57ac39f440c989e/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=649eaf9bfd466d7e98f1ba41e57ac39f440c989e", "patch": "@@ -1,3 +1,22 @@\n+2003-03-21  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* javaop.h (jfloat, jdouble): Make them structures mirroring\n+\tthe bit fields of IEEE float and double respectively.\n+\t(JFLOAT_FINITE, JFLOAT_QNAN_MASK, JFLOAT_EXP_BIAS,\n+\tJDOUBLE_FINITE, JDOUBLE_QNAN_MASK, JDOUBLE_EXP_BIAS): New.\n+\t(union Word, union DWord): Delete.\n+\t(WORD_TO_FLOAT, WORDS_TO_DOUBLE): Update to match.\n+\n+\t* gjavah.c (java_float_finite, java_double_finite, F_NAN_MASK,\n+\tD_NAN_MASK): Delete.\n+\t(jni_print_float, jni_print_double): New.  Generate\n+\thexadecimal floating constants.\n+\t(print_field_info): Use jni_print_float/double.\n+\n+\t* jcf-dump.c: Include math.h.  Use ldexp/frexp to assemble\n+\tfinite floating point numbers for output; special case\n+\tnon-finite floats.\n+\n 2003-03-19  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n \t* lang.c (java_dump_tree): Change return type from 'int' to 'bool'.\n@@ -16,10 +35,10 @@\n \n 2003-03-04  Andrew Haley  <aph@redhat.com>\n \n-        * gjavah.c (is_first_data_member): New global variable.\n-        (print_c_decl): If it's the first data member, align it as the\n-        superclass.\n-        (process_file): Set is_first_data_member.\n+\t* gjavah.c (is_first_data_member): New global variable.\n+\t(print_c_decl): If it's the first data member, align it as the\n+\tsuperclass.\n+\t(process_file): Set is_first_data_member.\n \n 2003-03-11  Tom Tromey  <tromey@redhat.com>\n \n@@ -57,7 +76,7 @@\n \t\"strcmp\" to compare file name components.\n \tUse IS_DIR_SEPARATOR instead of comparing directly against\n \tDIR_SEPARATOR.\n-\t(jcf_path_extdirs_arg): Use IS_DIR_SEPARATOR instead of \n+\t(jcf_path_extdirs_arg): Use IS_DIR_SEPARATOR instead of\n \tcomparing directly against DIR_SEPARATOR.\n \n 2003-03-04  Tom Tromey  <tromey@redhat.com>\n@@ -91,7 +110,7 @@\n \n \t* java/decl.c (java_init_decl_processing): Get soft_fmod_node from\n \tbuilt_in_decls[BUILT_IN_FMOD] rather than define it ourselves.\n- \n+\n 2003-02-23  Tom Tromey  <tromey@redhat.com>\n \n \t* lang-options.h: Added -Wdeprecated.\n@@ -133,12 +152,12 @@\n \n 2003-02-12  Ranjit Mathew  <rmathew@hotmail.com>\n \n-\t* decl.c (java_init_decl_processing): Change \n+\t* decl.c (java_init_decl_processing): Change\n \tsoft_lookupjnimethod_node to reflect the change in\n \tsignature of _Jv_LookupJNIMethod in libjava/jni.cc\n \t* expr.c (build_jni_stub): Calculate and pass the size\n \ton the stack of the arguments to a JNI function. Use\n-\tnew target macro MODIFY_JNI_METHOD_CALL to allow a \n+\tnew target macro MODIFY_JNI_METHOD_CALL to allow a\n \ttarget to modify the call to a JNI method.\n \n 2003-02-08  Roger Sayle  <roger@eyesopen.com>\n@@ -324,7 +343,7 @@\n 2003-01-14  Andrew Haley  <aph@redhat.com>\n \n \t* decl.c (java_init_decl_processing): _Jv_NewMultiArray is a\n-        varargs function -- correct.\n+\tvarargs function -- correct.\n \n 2003-01-14  Andrew Haley  <aph@redhat.com>\n \n@@ -571,7 +590,7 @@\n \t* gcj.texi: Change version number to 3.4.\n \n 2002-12-05  Ranjit Mathew <rmathew@hotmail.com>\n-        Andrew Haley <aph@redhat.com>\n+\tAndrew Haley <aph@redhat.com>\n \n \t* parse.y (source_end_java_method): Remove custom encoding of line\n \tnumbers for a function decl before passing it to the back end."}, {"sha": "51cfe7cffbc5a46244fe594b98472cc6588186b9", "filename": "gcc/java/gjavah.c", "status": "modified", "additions": 48, "deletions": 36, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649eaf9bfd466d7e98f1ba41e57ac39f440c989e/gcc%2Fjava%2Fgjavah.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649eaf9bfd466d7e98f1ba41e57ac39f440c989e/gcc%2Fjava%2Fgjavah.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgjavah.c?ref=649eaf9bfd466d7e98f1ba41e57ac39f440c989e", "patch": "@@ -134,8 +134,6 @@ static void print_full_cxx_name (FILE*, JCF*, int, int, int, const char *, int);\n static void decompile_method (FILE*, JCF*, int);\n static void add_class_decl (FILE*, JCF*, JCF_u2);\n \n-static int java_float_finite (jfloat);\n-static int java_double_finite (jdouble);\n static void print_name (FILE *, JCF *, int);\n static void print_base_classname (FILE *, JCF *, int);\n static int utf8_cmp (const unsigned char *, int, const char *);\n@@ -158,6 +156,8 @@ static void version (void) ATTRIBUTE_NORETURN;\n static int overloaded_jni_method_exists_p (const unsigned char *, int,\n \t\t\t\t\t   const char *, int);\n static void jni_print_char (FILE *, int);\n+static void jni_print_float (FILE *, jfloat);\n+static void jni_print_double (FILE *, jdouble);\n static void decompile_return_statement (FILE *, JCF *, int, int, int);\n \n JCF_u2 current_field_name;\n@@ -247,36 +247,54 @@ static int decompiled = 0;\n \n #include \"jcf-reader.c\"\n \n-/* Some useful constants.  */\n-#define F_NAN_MASK 0x7f800000\n-#if (1 == HOST_FLOAT_WORDS_BIG_ENDIAN) && ! defined (HOST_WORDS_BIG_ENDIAN)\n-#define D_NAN_MASK 0x000000007ff00000LL\n-#else\n-#define D_NAN_MASK 0x7ff0000000000000LL\n-#endif\n-\n-/* Return 1 if F is not Inf or NaN.  */\n-static int\n-java_float_finite (jfloat f)\n+/* Print a single-precision float, suitable for parsing by g++.  */\n+static void\n+jni_print_float (FILE *stream, jfloat f)\n {\n-  union Word u;\n-  u.f = f;\n-\n-  /* We happen to know that F_NAN_MASK will match all NaN values, and\n-     also positive and negative infinity.  That's why we only need one\n-     test here.  See The Java Language Specification, section 20.9.  */\n-  return (u.i & F_NAN_MASK) != F_NAN_MASK;\n+  /* It'd be nice to use __builtin_nan/__builtin_inf here but they don't\n+     work in data initializers.  FIXME.  */\n+  if (JFLOAT_FINITE (f))\n+    {\n+      fputs (\" = \", stream);\n+      if (f.negative)\n+\tputc ('-', stream);\n+      if (f.exponent)\n+\tfprintf (stream, \"0x1.%.6xp%+df\",\n+\t\t ((unsigned int)f.mantissa) << 1,\n+\t\t f.exponent - JFLOAT_EXP_BIAS);\n+      else\n+\t/* Exponent of 0x01 is -125; exponent of 0x00 is *also* -125,\n+\t   because the implicit leading 1 bit is no longer present.  */\n+\tfprintf (stream, \"0x0.%.6xp%+df\",\n+\t\t ((unsigned int)f.mantissa) << 1,\n+\t\t f.exponent + 1 - JFLOAT_EXP_BIAS);\n+    }\n+  fputs (\";\\n\", stream);\n }\n \n-/* Return 1 if D is not Inf or NaN.  */\n-static int\n-java_double_finite (jdouble d)\n+/* Print a double-precision float, suitable for parsing by g++.  */\n+static void\n+jni_print_double (FILE *stream, jdouble f)\n {\n-  union DWord u;\n-  u.d = d;\n-\n-  /* Now check for all NaNs.  */\n-  return (u.l & D_NAN_MASK) != D_NAN_MASK;\n+  /* It'd be nice to use __builtin_nan/__builtin_inf here but they don't\n+     work in data initializers.  FIXME.  */\n+  if (JDOUBLE_FINITE (f))\n+    {\n+      fputs (\" = \", stream);\n+      if (f.negative)\n+\tputc ('-', stream);\n+      if (f.exponent)\n+\tfprintf (stream, \"0x1.%.5x%.8xp%+d\",\n+\t\t f.mantissa0, f.mantissa1,\n+\t\t f.exponent - JDOUBLE_EXP_BIAS);\n+      else\n+\t/* Exponent of 0x001 is -1022; exponent of 0x000 is *also* -1022,\n+\t   because the implicit leading 1 bit is no longer present.  */\n+\tfprintf (stream, \"0x0.%.5x%.8xp%+d\",\n+\t\t f.mantissa0, f.mantissa1,\n+\t\t f.exponent + 1 - JDOUBLE_EXP_BIAS);\n+    }\n+  fputs (\";\\n\", stream);\n }\n \n /* Print a character, appropriately mangled for JNI.  */\n@@ -732,21 +750,15 @@ print_field_info (FILE *stream, JCF* jcf, int name_index, int sig_index,\n \t\tjfloat fnum = JPOOL_FLOAT (jcf, current_field_value);\n \t\tfputs (\"const jfloat \", out);\n \t\tprint_field_name (out, jcf, name_index, 0);\n-\t\tif (! java_float_finite (fnum))\n-\t\t  fputs (\";\\n\", out);\n-\t\telse\n-\t\t  fprintf (out, \" = %.10g;\\n\",  fnum);\n+\t\tjni_print_float (out, fnum);\n \t      }\n \t      break;\n \t    case CONSTANT_Double:\n \t      {\n \t\tjdouble dnum = JPOOL_DOUBLE (jcf, current_field_value);\n \t\tfputs (\"const jdouble \", out);\n \t\tprint_field_name (out, jcf, name_index, 0);\n-\t\tif (! java_double_finite (dnum))\n-\t\t  fputs (\";\\n\", out);\n-\t\telse\n-\t\t  fprintf (out, \" = %.17g;\\n\",  dnum);\n+\t\tjni_print_double (out, dnum);\n \t      }\n \t      break;\n \t    default:"}, {"sha": "bdf3fa6e41f911a8730d0b3812be8087be50639a", "filename": "gcc/java/javaop.h", "status": "modified", "additions": 37, "deletions": 31, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649eaf9bfd466d7e98f1ba41e57ac39f440c989e/gcc%2Fjava%2Fjavaop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649eaf9bfd466d7e98f1ba41e57ac39f440c989e/gcc%2Fjava%2Fjavaop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjavaop.h?ref=649eaf9bfd466d7e98f1ba41e57ac39f440c989e", "patch": "@@ -55,21 +55,26 @@ typedef int32                   jint;\n typedef int64                   jlong;\n typedef void*                   jref;\n \n-/* A 32-bit IEEE single-precision float. */\n-#ifndef jfloat \n-#define jfloat float\n-#endif\n-\n-/* A 32-bit IEEE double-precision float. */\n-#ifndef jdouble\n-#define jdouble double\n-#endif\n-\n-union Word {\n-  jint i;\n-  jfloat f;\n-  void *p;\n-};\n+/* A 32-bit big-endian IEEE single-precision float. */\n+typedef struct _jfloat {\n+  unsigned int negative : 1;\n+  unsigned int exponent : 8;\n+  unsigned int mantissa : 23;\n+} jfloat;\n+#define JFLOAT_FINITE(f) ((f).exponent != 0xFF)\n+#define JFLOAT_QNAN_MASK 0x400000\n+#define JFLOAT_EXP_BIAS 0x7f\n+\n+/* A 32-bit big-endian IEEE double-precision float. */\n+typedef struct _jdouble {\n+  unsigned int negative : 1;\n+  unsigned int exponent : 11;\n+  unsigned int mantissa0: 20;\n+  unsigned int mantissa1: 32;\n+} jdouble;\n+#define JDOUBLE_FINITE(f) ((f).exponent != 0x7FF)\n+#define JDOUBLE_QNAN_MASK 0x80000  /* apply to mantissa0 */\n+#define JDOUBLE_EXP_BIAS 0x3ff\n \n /* A jword is an unsigned integral type big enough for a 32-bit jint\n    or jfloat *or* a pointer.  It is the type appropriate for stack\n@@ -102,9 +107,14 @@ union Word {\n \n static inline jfloat\n WORD_TO_FLOAT(jword w)\n-{ union Word wu;\n-  wu.i = w;\n-  return wu.f;\n+{\n+  jfloat f;\n+\n+  f.negative = (w & 0x80000000) >> 31;\n+  f.exponent = (w & 0x7f800000) >> 23;\n+  f.mantissa = (w & 0x007fffff);\n+\n+  return f;\n } \n \n /* Sign extend w.  If the host on which this cross-compiler runs uses\n@@ -126,21 +136,17 @@ WORDS_TO_LONG(jword hi, jword lo)\n   return ((jlong) hi << 32) | ((jlong)lo & (((jlong)1 << 32) -1));\n }\n \n-union DWord {\n-  jdouble d;\n-  jlong l;\n-  jword w[2];\n-};\n-\n static inline jdouble\n WORDS_TO_DOUBLE(jword hi, jword lo)\n-{ union DWord wu;\n-#if (1 == HOST_FLOAT_WORDS_BIG_ENDIAN)\n-  wu.l = WORDS_TO_LONG(lo, hi);\n-#else\n-  wu.l = WORDS_TO_LONG(hi, lo);\n-#endif\n-  return wu.d;\n+{\n+  jdouble d;\n+\n+  d.negative  = (hi & 0x80000000) >> 31;\n+  d.exponent  = (hi & 0x7ff00000) >> 20;\n+  d.mantissa0 = (hi & 0x000fffff);\n+  d.mantissa1 = lo;\n+\n+  return d;\n } \n \n /* If PREFIX_CHAR is the first character of the Utf8 encoding of a character,"}, {"sha": "a87dd401e0fc6287bc2752ac3fd041e27f5fe95c", "filename": "gcc/java/jcf-dump.c", "status": "modified", "additions": 74, "deletions": 11, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/649eaf9bfd466d7e98f1ba41e57ac39f440c989e/gcc%2Fjava%2Fjcf-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/649eaf9bfd466d7e98f1ba41e57ac39f440c989e/gcc%2Fjava%2Fjcf-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-dump.c?ref=649eaf9bfd466d7e98f1ba41e57ac39f440c989e", "patch": "@@ -62,6 +62,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"version.h\"\n \n #include <getopt.h>\n+#include <math.h>\n \n /* Outout file. */\n FILE *out;\n@@ -504,24 +505,86 @@ print_constant (FILE *out, JCF *jcf, int index, int verbosity)\n       break;\n     case CONSTANT_Float:\n       {\n-\tunion\n-\t{\n-\t  jfloat f;\n-\t  int32 i;\n-\t} pun;\n-\t\n-\tpun.f = JPOOL_FLOAT (jcf, index);\n-\tfprintf (out, \"%s%.10g\",\n-\t\t verbosity > 0 ? \"Float \" : \"\", (double) pun.f);\n+\tjfloat fnum = JPOOL_FLOAT (jcf, index);\n+\n+\tif (verbosity > 0)\n+\t  fputs (\"Float \", out);\n+\n+\tif (fnum.negative)\n+\t  putc ('-', out);\n+\n+\tif (JFLOAT_FINITE (fnum))\n+\t  {\n+\t    int dummy;\n+\t    int exponent = fnum.exponent - JFLOAT_EXP_BIAS;\n+\t    double f;\n+\t    uint32 mantissa = fnum.mantissa;\n+\t    if (fnum.exponent == 0)\n+\t      /* Denormal.  */\n+\t      exponent++;\n+\t    else\n+\t      /* Normal; add the implicit bit.  */\n+\t      mantissa |= ((uint32)1 << 23);\n+\t    \n+\t    f = frexp (mantissa, &dummy);\n+\t    f = ldexp (f, exponent + 1);\n+\t    fprintf (out, \"%.10g\", f);\n+\t  }\n+\telse\n+\t  {\n+\t    if (fnum.mantissa == 0)\n+\t      fputs (\"Inf\", out);\n+\t    else if (fnum.mantissa & JFLOAT_QNAN_MASK)\n+\t      fprintf (out, \"QNaN(%u)\", (fnum.mantissa & ~JFLOAT_QNAN_MASK));\n+\t    else\n+\t      fprintf (out, \"SNaN(%u)\", (fnum.mantissa & ~JFLOAT_QNAN_MASK));\n+\t  }\n+\n \tif (verbosity > 1)\n-\t  fprintf (out, \", bits = 0x%08lx\", (long) pun.i);\n+\t  fprintf (out, \", bits = 0x%08lx\", JPOOL_UINT (jcf, index));\n \t\n \tbreak;\n       }\n     case CONSTANT_Double:\n       {\n \tjdouble dnum = JPOOL_DOUBLE (jcf, index);\n-\tfprintf (out, \"%s%.20g\", verbosity > 0 ? \"Double \" : \"\", dnum);\n+\n+\tif (verbosity > 0)\n+\t  fputs (\"Double \", out);\n+\n+\tif (dnum.negative)\n+\t  putc ('-', out);\n+\n+\tif (JDOUBLE_FINITE (dnum))\n+\t  {\n+\t    int dummy;\n+\t    int exponent = dnum.exponent - JDOUBLE_EXP_BIAS;\n+\t    double d;\n+\t    uint64 mantissa = ((((uint64) dnum.mantissa0) << 32)\n+\t\t\t       + dnum.mantissa1);\n+\t    if (dnum.exponent == 0)\n+\t      /* Denormal.  */\n+\t      exponent++;\n+\t    else\n+\t      /* Normal; add the implicit bit.  */\n+\t      mantissa |= ((uint64)1 << 52);\n+\n+\t    d = frexp (mantissa, &dummy);\n+\t    d = ldexp (d, exponent + 1);\n+\t    fprintf (out, \"%.20g\", d);\n+\t  }\n+\telse\n+\t  {\n+\t    uint64 mantissa = dnum.mantissa0 & ~JDOUBLE_QNAN_MASK;\n+\t    mantissa = (mantissa << 32) + dnum.mantissa1;\n+\n+\t    if (dnum.mantissa0 == 0 && dnum.mantissa1 == 0)\n+\t      fputs (\"Inf\", out);\n+\t    else if (dnum.mantissa0 & JDOUBLE_QNAN_MASK)\n+\t      fprintf (out, \"QNaN(%llu)\", (unsigned long long)mantissa);\n+\t    else\n+\t      fprintf (out, \"SNaN(%llu)\", (unsigned long long)mantissa);\n+\t  }\n \tif (verbosity > 1)\n \t  {\n \t    int32 hi, lo;"}]}