{"sha": "0c7bce0ac184c057bacad9c8e615ce82923835fd", "node_id": "C_kwDOANBUbNoAKDBjN2JjZTBhYzE4NGMwNTdiYWNhZDljOGU2MTVjZTgyOTIzODM1ZmQ", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-05-09T13:53:27Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-05-09T13:53:27Z"}, "message": "c++: constexpr init of union sub-aggr w/ base [PR105491]\n\nHere ever since r10-7313-gb599bf9d6d1e18, reduced_constant_expression_p\nin C++11/14 is rejecting the marked sub-aggregate initializer (of type S)\n\n  W w = {.D.2445={.s={.D.2387={.m=0}, .b=0}}};\n                     ^\nultimately because said initializer has CONSTRUCTOR_NO_CLEARING set,\nhence the function must verify that all fields of S are initialized.\nAnd before C++17 it doesn't expect to see base class fields (since\nnext_initializable_field skips over them), so the presence thereof\ncauses r_c_e_p to return false.\n\nThe reason r10-7313-gb599bf9d6d1e18 causes this is because in that\ncommit we began using CONSTRUCTOR_NO_CLEARING to precisely track whether\nwe're in middle of activating a union member.  This ends up affecting\nclear_no_implicit_zero, which recurses into sub-aggregate initializers\nonly if the outer initializer has CONSTRUCTOR_NO_CLEARING set.  After\nthat commit, the outer union initializer above no longer has the flag\nset at this point and so clear_no_implicit_zero no longer recurses into\nthe marked inner initializer.\n\nBut arguably r_c_e_p should be able to accept the marked initializer\nregardless of whether CONSTRUCTOR_NO_CLEARING is set.  The primary bug\ntherefore seems to be that r_c_e_p relies on next_initializable_field\nwhich skips over base class fields in C++11/14.  To fix this, this patch\nintroduces a new helper function next_subobject_field which is like\nnext_initializable_field except that it never skips base class fields,\nand makes r_c_e_p use it.  This patch then renames next_initializable_field\nto next_aggregate_field (and makes it skip over vptr fields again).\n\n\tPR c++/105491\n\ngcc/cp/ChangeLog:\n\n\t* call.cc (field_in_pset): Adjust after next_initializable_field\n\trenaming.\n\t(build_aggr_conv): Likewise.\n\t(convert_like_internal): Likewise.\n\t(type_has_extended_temps): Likewise.\n\t* class.cc (default_init_uninitialized_part): Likewise.\n\t(finish_struct): Likewise.\n\t* constexpr.cc (cx_check_missing_mem_inits): Likewise.\n\t(reduced_constant_expression_p): Use next_subobject_field\n\tinstead.\n\t* cp-gimplify.cc (get_source_location_impl_type): Adjust after\n\tnext_initializable_field renaming.\n\t(fold_builtin_source_location): Likewise.\n\t* cp-tree.h (next_initializable_field): Rename to ...\n\t(next_aggregate_field): ... this.\n\t(next_subobject_field): Declare.\n\t* decl.cc (next_aggregate_field): Renamed from ...\n\t(next_initializable_field): ... this.  Skip over vptr fields\n\tagain.\n\t(next_subobject_field): Define.\n\t(reshape_init_class): Adjust after next_initializable_field\n\trenaming.\n\t* init.cc (build_value_init_noctor): Likewise.\n\t(emit_mem_initializers): Likewise.\n\t* lambda.cc (build_capture_proxy): Likewise.\n\t* method.cc (build_comparison_op): Likewise.\n\t* pt.cc (maybe_aggr_guide): Likewise.\n\t* tree.cc (structural_type_p): Likewise.\n\t* typeck2.cc (split_nonconstant_init_1): Likewise.\n\t(digest_init_r): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/constexpr-union7.C: New test.\n\t* g++.dg/cpp0x/constexpr-union7a.C: New test.\n\t* g++.dg/cpp2a/constinit17.C: New test.", "tree": {"sha": "0d9ce377d64297ac2850a6089423a6476efd7187", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d9ce377d64297ac2850a6089423a6476efd7187"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c7bce0ac184c057bacad9c8e615ce82923835fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c7bce0ac184c057bacad9c8e615ce82923835fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c7bce0ac184c057bacad9c8e615ce82923835fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c7bce0ac184c057bacad9c8e615ce82923835fd/comments", "author": null, "committer": null, "parents": [{"sha": "fcda0efccad41eba9134c1bd9d024a93d93fb82f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcda0efccad41eba9134c1bd9d024a93d93fb82f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcda0efccad41eba9134c1bd9d024a93d93fb82f"}], "stats": {"total": 159, "additions": 116, "deletions": 43}, "files": [{"sha": "0240e364324bc30ecbbcae5a34c8c6cb732085fc", "filename": "gcc/cp/call.cc", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c7bce0ac184c057bacad9c8e615ce82923835fd/gcc%2Fcp%2Fcall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c7bce0ac184c057bacad9c8e615ce82923835fd/gcc%2Fcp%2Fcall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.cc?ref=0c7bce0ac184c057bacad9c8e615ce82923835fd", "patch": "@@ -948,7 +948,7 @@ field_in_pset (hash_set<tree, true> &pset, tree field)\n     for (field = TYPE_FIELDS (TREE_TYPE (field));\n \t field; field = DECL_CHAIN (field))\n       {\n-\tfield = next_initializable_field (field);\n+\tfield = next_aggregate_field (field);\n \tif (field == NULL_TREE)\n \t  break;\n \tif (field_in_pset (pset, field))\n@@ -965,7 +965,7 @@ build_aggr_conv (tree type, tree ctor, int flags, tsubst_flags_t complain)\n {\n   unsigned HOST_WIDE_INT i = 0;\n   conversion *c;\n-  tree field = next_initializable_field (TYPE_FIELDS (type));\n+  tree field = next_aggregate_field (TYPE_FIELDS (type));\n   tree empty_ctor = NULL_TREE;\n   hash_set<tree, true> pset;\n \n@@ -1011,7 +1011,7 @@ build_aggr_conv (tree type, tree ctor, int flags, tsubst_flags_t complain)\n \t}\n     }\n \n-  for (; field; field = next_initializable_field (DECL_CHAIN (field)))\n+  for (; field; field = next_aggregate_field (DECL_CHAIN (field)))\n     {\n       tree ftype = TREE_TYPE (field);\n       tree val;\n@@ -8098,10 +8098,10 @@ convert_like_internal (conversion *convs, tree expr, tree fn, int argnum,\n \ttotype = complete_type_or_maybe_complain (totype, NULL_TREE, complain);\n \tif (!totype)\n \t  return error_mark_node;\n-\ttree field = next_initializable_field (TYPE_FIELDS (totype));\n+\ttree field = next_aggregate_field (TYPE_FIELDS (totype));\n \tvec<constructor_elt, va_gc> *vec = NULL;\n \tCONSTRUCTOR_APPEND_ELT (vec, field, array);\n-\tfield = next_initializable_field (DECL_CHAIN (field));\n+\tfield = next_aggregate_field (DECL_CHAIN (field));\n \tCONSTRUCTOR_APPEND_ELT (vec, field, size_int (len));\n \ttree new_ctor = build_constructor (totype, vec);\n \treturn get_target_expr_sfinae (new_ctor, complain);\n@@ -13267,8 +13267,8 @@ type_has_extended_temps (tree type)\n     {\n       if (is_std_init_list (type))\n \treturn true;\n-      for (tree f = next_initializable_field (TYPE_FIELDS (type));\n-\t   f; f = next_initializable_field (DECL_CHAIN (f)))\n+      for (tree f = next_aggregate_field (TYPE_FIELDS (type));\n+\t   f; f = next_aggregate_field (DECL_CHAIN (f)))\n \tif (type_has_extended_temps (TREE_TYPE (f)))\n \t  return true;\n     }"}, {"sha": "3c195b35396e71cc01d25f2de22c9467e9120871", "filename": "gcc/cp/class.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c7bce0ac184c057bacad9c8e615ce82923835fd/gcc%2Fcp%2Fclass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c7bce0ac184c057bacad9c8e615ce82923835fd/gcc%2Fcp%2Fclass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.cc?ref=0c7bce0ac184c057bacad9c8e615ce82923835fd", "patch": "@@ -5494,8 +5494,8 @@ default_init_uninitialized_part (tree type)\n       if (r)\n \treturn r;\n     }\n-  for (t = next_initializable_field (TYPE_FIELDS (type)); t;\n-       t = next_initializable_field (DECL_CHAIN (t)))\n+  for (t = next_aggregate_field (TYPE_FIELDS (type)); t;\n+       t = next_aggregate_field (DECL_CHAIN (t)))\n     if (!DECL_INITIAL (t) && !DECL_ARTIFICIAL (t))\n       {\n \tr = default_init_uninitialized_part (TREE_TYPE (t));\n@@ -7781,10 +7781,10 @@ finish_struct (tree t, tree attributes)\n       bool ok = false;\n       if (processing_template_decl)\n \t{\n-\t  tree f = next_initializable_field (TYPE_FIELDS (t));\n+\t  tree f = next_aggregate_field (TYPE_FIELDS (t));\n \t  if (f && TYPE_PTR_P (TREE_TYPE (f)))\n \t    {\n-\t      f = next_initializable_field (DECL_CHAIN (f));\n+\t      f = next_aggregate_field (DECL_CHAIN (f));\n \t      if (f && same_type_p (TREE_TYPE (f), size_type_node))\n \t\tok = true;\n \t    }"}, {"sha": "e560d842e8c03e7ac594456913be5d4789b33663", "filename": "gcc/cp/constexpr.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c7bce0ac184c057bacad9c8e615ce82923835fd/gcc%2Fcp%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c7bce0ac184c057bacad9c8e615ce82923835fd/gcc%2Fcp%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.cc?ref=0c7bce0ac184c057bacad9c8e615ce82923835fd", "patch": "@@ -784,7 +784,7 @@ cx_check_missing_mem_inits (tree ctype, tree body, bool complain)\n \n   if (TREE_CODE (ctype) == UNION_TYPE)\n     {\n-      if (nelts == 0 && next_initializable_field (field))\n+      if (nelts == 0 && next_aggregate_field (field))\n \t{\n \t  if (complain)\n \t    error (\"%<constexpr%> constructor for union %qT must \"\n@@ -3053,7 +3053,7 @@ reduced_constant_expression_p (tree t)\n \t      field = NULL_TREE;\n \t    }\n \t  else\n-\t    field = next_initializable_field (TYPE_FIELDS (TREE_TYPE (t)));\n+\t    field = next_subobject_field (TYPE_FIELDS (TREE_TYPE (t)));\n \t}\n       else\n \tfield = NULL_TREE;\n@@ -3065,15 +3065,15 @@ reduced_constant_expression_p (tree t)\n \t    return false;\n \t  /* Empty class field may or may not have an initializer.  */\n \t  for (; field && e.index != field;\n-\t       field = next_initializable_field (DECL_CHAIN (field)))\n+\t       field = next_subobject_field (DECL_CHAIN (field)))\n \t    if (!is_really_empty_class (TREE_TYPE (field),\n \t\t\t\t\t/*ignore_vptr*/false))\n \t      return false;\n \t  if (field)\n-\t    field = next_initializable_field (DECL_CHAIN (field));\n+\t    field = next_subobject_field (DECL_CHAIN (field));\n \t}\n       /* There could be a non-empty field at the end.  */\n-      for (; field; field = next_initializable_field (DECL_CHAIN (field)))\n+      for (; field; field = next_subobject_field (DECL_CHAIN (field)))\n \tif (!is_really_empty_class (TREE_TYPE (field), /*ignore_vptr*/false))\n \t  return false;\n ok:"}, {"sha": "6f84d157c98d34f933e910ac282283df2768073a", "filename": "gcc/cp/cp-gimplify.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c7bce0ac184c057bacad9c8e615ce82923835fd/gcc%2Fcp%2Fcp-gimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c7bce0ac184c057bacad9c8e615ce82923835fd/gcc%2Fcp%2Fcp-gimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.cc?ref=0c7bce0ac184c057bacad9c8e615ce82923835fd", "patch": "@@ -3106,7 +3106,7 @@ get_source_location_impl_type (location_t loc)\n \n   int cnt = 0;\n   for (tree field = TYPE_FIELDS (type);\n-       (field = next_initializable_field (field)) != NULL_TREE;\n+       (field = next_aggregate_field (field)) != NULL_TREE;\n        field = DECL_CHAIN (field))\n     {\n       if (DECL_NAME (field) != NULL_TREE)\n@@ -3281,7 +3281,7 @@ fold_builtin_source_location (location_t loc)\n       vec<constructor_elt, va_gc> *v = NULL;\n       vec_alloc (v, 4);\n       for (tree field = TYPE_FIELDS (source_location_impl);\n-\t   (field = next_initializable_field (field)) != NULL_TREE;\n+\t   (field = next_aggregate_field (field)) != NULL_TREE;\n \t   field = DECL_CHAIN (field))\n \t{\n \t  const char *n = IDENTIFIER_POINTER (DECL_NAME (field));"}, {"sha": "7e50db0e35a0aaa2ae0ffd7e42762bbeca5617a6", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c7bce0ac184c057bacad9c8e615ce82923835fd/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c7bce0ac184c057bacad9c8e615ce82923835fd/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=0c7bce0ac184c057bacad9c8e615ce82923835fd", "patch": "@@ -6870,7 +6870,8 @@ extern bool is_direct_enum_init\t\t\t(tree, tree);\n extern void initialize_artificial_var\t\t(tree, vec<constructor_elt, va_gc> *);\n extern tree check_var_type\t\t\t(tree, tree, location_t);\n extern tree reshape_init                        (tree, tree, tsubst_flags_t);\n-extern tree next_initializable_field (tree);\n+extern tree next_aggregate_field\t\t(tree);\n+extern tree next_subobject_field\t\t(tree);\n extern tree first_field\t\t\t\t(const_tree);\n extern tree fndecl_declared_return_type\t\t(tree);\n extern bool undeduced_auto_decl\t\t\t(tree);"}, {"sha": "872b02d55bdce569201a1879afe6017fc95db2a6", "filename": "gcc/cp/decl.cc", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c7bce0ac184c057bacad9c8e615ce82923835fd/gcc%2Fcp%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c7bce0ac184c057bacad9c8e615ce82923835fd/gcc%2Fcp%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.cc?ref=0c7bce0ac184c057bacad9c8e615ce82923835fd", "patch": "@@ -6384,20 +6384,36 @@ static tree reshape_init_r (tree, reshape_iter *, tree, tsubst_flags_t);\n \n /* FIELD is an element of TYPE_FIELDS or NULL.  In the former case, the value\n    returned is the next FIELD_DECL (possibly FIELD itself) that can be\n-   initialized.  If there are no more such fields, the return value\n-   will be NULL.  */\n+   initialized as if for an aggregate class.  If there are no more such fields,\n+   the return value will be NULL.  */\n \n tree\n-next_initializable_field (tree field)\n+next_aggregate_field (tree field)\n {\n   while (field\n \t && (TREE_CODE (field) != FIELD_DECL\n \t     || DECL_UNNAMED_BIT_FIELD (field)\n \t     || (DECL_ARTIFICIAL (field)\n-\t\t /* In C++17, don't skip base class fields.  */\n-\t\t && !(cxx_dialect >= cxx17 && DECL_FIELD_IS_BASE (field))\n-\t\t /* Don't skip vptr fields.  We might see them when we're\n-\t\t    called from reduced_constant_expression_p.  */\n+\t\t /* In C++17, aggregates can have bases.  */\n+\t\t && !(cxx_dialect >= cxx17 && DECL_FIELD_IS_BASE (field)))))\n+    field = DECL_CHAIN (field);\n+\n+  return field;\n+}\n+\n+/* FIELD is an element of TYPE_FIELDS or NULL.  In the former case, the value\n+   returned is the next FIELD_DECL (possibly FIELD itself) that corresponds\n+   to a subobject.  If there are no more such fields, the return value will be\n+   NULL.  */\n+\n+tree\n+next_subobject_field (tree field)\n+{\n+  while (field\n+\t && (TREE_CODE (field) != FIELD_DECL\n+\t     || DECL_UNNAMED_BIT_FIELD (field)\n+\t     || (DECL_ARTIFICIAL (field)\n+\t\t && !DECL_FIELD_IS_BASE (field)\n \t\t && !DECL_VIRTUAL_P (field))))\n     field = DECL_CHAIN (field);\n \n@@ -6595,7 +6611,7 @@ reshape_init_class (tree type, reshape_iter *d, bool first_initializer_p,\n   if (base_binfo)\n     field = base_binfo;\n   else\n-    field = next_initializable_field (TYPE_FIELDS (type));\n+    field = next_aggregate_field (TYPE_FIELDS (type));\n \n   if (!field)\n     {\n@@ -6762,10 +6778,10 @@ reshape_init_class (tree type, reshape_iter *d, bool first_initializer_p,\n \t  if (BINFO_BASE_ITERATE (binfo, ++binfo_idx, base_binfo))\n \t    field = base_binfo;\n \t  else\n-\t    field = next_initializable_field (TYPE_FIELDS (type));\n+\t    field = next_aggregate_field (TYPE_FIELDS (type));\n \t}\n       else\n-\tfield = next_initializable_field (DECL_CHAIN (field));\n+\tfield = next_aggregate_field (DECL_CHAIN (field));\n     }\n \n   /* A trailing aggregate element that is a pack expansion is assumed to"}, {"sha": "f1ed9336dc96207f2a9743974584edb8a923a75e", "filename": "gcc/cp/init.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c7bce0ac184c057bacad9c8e615ce82923835fd/gcc%2Fcp%2Finit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c7bce0ac184c057bacad9c8e615ce82923835fd/gcc%2Fcp%2Finit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.cc?ref=0c7bce0ac184c057bacad9c8e615ce82923835fd", "patch": "@@ -422,7 +422,7 @@ build_value_init_noctor (tree type, tsubst_flags_t complain)\n \t\t  && !COMPLETE_TYPE_P (ftype)\n \t\t  && !TYPE_DOMAIN (ftype)\n \t\t  && COMPLETE_TYPE_P (TREE_TYPE (ftype))\n-\t\t  && (next_initializable_field (DECL_CHAIN (field))\n+\t\t  && (next_aggregate_field (DECL_CHAIN (field))\n \t\t      == NULL_TREE))\n \t\tcontinue;\n \n@@ -1477,9 +1477,9 @@ emit_mem_initializers (tree mem_inits)\n \n   /* Initially that is all of them.  */\n   if (warn_uninitialized)\n-    for (tree f = next_initializable_field (TYPE_FIELDS (current_class_type));\n+    for (tree f = next_aggregate_field (TYPE_FIELDS (current_class_type));\n \t f != NULL_TREE;\n-\t f = next_initializable_field (DECL_CHAIN (f)))\n+\t f = next_aggregate_field (DECL_CHAIN (f)))\n       if (!DECL_ARTIFICIAL (f)\n \t  && !is_really_empty_class (TREE_TYPE (f), /*ignore_vptr*/false))\n \tuninitialized.add (f);"}, {"sha": "3fb98a9805787747635f9aa05ce75971bee5e026", "filename": "gcc/cp/lambda.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c7bce0ac184c057bacad9c8e615ce82923835fd/gcc%2Fcp%2Flambda.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c7bce0ac184c057bacad9c8e615ce82923835fd/gcc%2Fcp%2Flambda.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.cc?ref=0c7bce0ac184c057bacad9c8e615ce82923835fd", "patch": "@@ -425,9 +425,9 @@ build_capture_proxy (tree member, tree init)\n   if (DECL_VLA_CAPTURE_P (member))\n     {\n       /* Rebuild the VLA type from the pointer and maxindex.  */\n-      tree field = next_initializable_field (TYPE_FIELDS (type));\n+      tree field = next_aggregate_field (TYPE_FIELDS (type));\n       tree ptr = build_simple_component_ref (object, field);\n-      field = next_initializable_field (DECL_CHAIN (field));\n+      field = next_aggregate_field (DECL_CHAIN (field));\n       tree max = build_simple_component_ref (object, field);\n       type = build_cplus_array_type (TREE_TYPE (TREE_TYPE (ptr)),\n \t\t\t\t     build_index_type (max));"}, {"sha": "0dffd648b0ba3475adf89e0739d3797ddcb52550", "filename": "gcc/cp/method.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c7bce0ac184c057bacad9c8e615ce82923835fd/gcc%2Fcp%2Fmethod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c7bce0ac184c057bacad9c8e615ce82923835fd/gcc%2Fcp%2Fmethod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.cc?ref=0c7bce0ac184c057bacad9c8e615ce82923835fd", "patch": "@@ -1465,7 +1465,7 @@ build_comparison_op (tree fndecl, bool defining, tsubst_flags_t complain)\n   /* A defaulted comparison operator function for class C is defined as\n      deleted if ... C has variant members.  */\n   if (TREE_CODE (ctype) == UNION_TYPE\n-      && next_initializable_field (TYPE_FIELDS (ctype)))\n+      && next_aggregate_field (TYPE_FIELDS (ctype)))\n     {\n       if (complain & tf_error)\n \tinform (info.loc, \"cannot default compare union %qT\", ctype);\n@@ -1518,9 +1518,9 @@ build_comparison_op (tree fndecl, bool defining, tsubst_flags_t complain)\n \t}\n \n       /* Now compare the field subobjects.  */\n-      for (tree field = next_initializable_field (TYPE_FIELDS (ctype));\n+      for (tree field = next_aggregate_field (TYPE_FIELDS (ctype));\n \t   field;\n-\t   field = next_initializable_field (DECL_CHAIN (field)))\n+\t   field = next_aggregate_field (DECL_CHAIN (field)))\n \t{\n \t  if (DECL_VIRTUAL_P (field) || DECL_FIELD_IS_BASE (field))\n \t    /* We ignore the vptr, and we already handled bases.  */\n@@ -1542,7 +1542,7 @@ build_comparison_op (tree fndecl, bool defining, tsubst_flags_t complain)\n \t      continue;\n \t    }\n \t  else if (ANON_UNION_TYPE_P (expr_type)\n-\t\t   && next_initializable_field (TYPE_FIELDS (expr_type)))\n+\t\t   && next_aggregate_field (TYPE_FIELDS (expr_type)))\n \t    {\n \t      if (complain & tf_error)\n \t\tinform (field_loc, \"cannot default compare \""}, {"sha": "6e666c2cde3d43eeb5afbcd591b8457a40192517", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c7bce0ac184c057bacad9c8e615ce82923835fd/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c7bce0ac184c057bacad9c8e615ce82923835fd/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=0c7bce0ac184c057bacad9c8e615ce82923835fd", "patch": "@@ -29586,7 +29586,7 @@ maybe_aggr_guide (tree tmpl, tree init, vec<tree,va_gc> *args)\n \t   len;\n \t   --len, field = DECL_CHAIN (field))\n \t{\n-\t  field = next_initializable_field (field);\n+\t  field = next_aggregate_field (field);\n \t  if (!field)\n \t    return NULL_TREE;\n \t  tree ftype = finish_decltype_type (field, true, complain);"}, {"sha": "633cc164a3ad73f9ae770b63687779e05d017d24", "filename": "gcc/cp/tree.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c7bce0ac184c057bacad9c8e615ce82923835fd/gcc%2Fcp%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c7bce0ac184c057bacad9c8e615ce82923835fd/gcc%2Fcp%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.cc?ref=0c7bce0ac184c057bacad9c8e615ce82923835fd", "patch": "@@ -4852,8 +4852,8 @@ structural_type_p (tree t, bool explain)\n \texplain_non_literal_class (t);\n       return false;\n     }\n-  for (tree m = next_initializable_field (TYPE_FIELDS (t)); m;\n-       m = next_initializable_field (DECL_CHAIN (m)))\n+  for (tree m = next_aggregate_field (TYPE_FIELDS (t)); m;\n+       m = next_aggregate_field (DECL_CHAIN (m)))\n     {\n       if (TREE_PRIVATE (m) || TREE_PROTECTED (m))\n \t{"}, {"sha": "1d92310edd01005344f4e2fd4644d62e589ab860", "filename": "gcc/cp/typeck2.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c7bce0ac184c057bacad9c8e615ce82923835fd/gcc%2Fcp%2Ftypeck2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c7bce0ac184c057bacad9c8e615ce82923835fd/gcc%2Fcp%2Ftypeck2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.cc?ref=0c7bce0ac184c057bacad9c8e615ce82923835fd", "patch": "@@ -606,7 +606,7 @@ split_nonconstant_init_1 (tree dest, tree init, bool last,\n \t\t\t\t  : TYPE_FIELDS (type));\n \t\t     ; prev = DECL_CHAIN (prev))\n \t\t  {\n-\t\t    prev = next_initializable_field (prev);\n+\t\t    prev = next_aggregate_field (prev);\n \t\t    if (prev == field_index)\n \t\t      break;\n \t\t    tree ptype = TREE_TYPE (prev);\n@@ -1304,7 +1304,7 @@ digest_init_r (tree type, tree init, int nested, int flags,\n \t    the first element of d, which is the B base subobject.  The base\n \t    of type B is copy-initialized from the D temporary, causing\n \t    object slicing.  */\n-\t  tree field = next_initializable_field (TYPE_FIELDS (type));\n+\t  tree field = next_aggregate_field (TYPE_FIELDS (type));\n \t  if (field && DECL_FIELD_IS_BASE (field))\n \t    {\n \t      if (warning_at (loc, 0, \"initializing a base class of type %qT \""}, {"sha": "b3147d9db50281254ede298b76f2fb3c71a6897e", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-union7.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c7bce0ac184c057bacad9c8e615ce82923835fd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-union7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c7bce0ac184c057bacad9c8e615ce82923835fd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-union7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-union7.C?ref=0c7bce0ac184c057bacad9c8e615ce82923835fd", "patch": "@@ -0,0 +1,17 @@\n+// PR c++/105491\n+// { dg-do compile { target c++11 } }\n+\n+struct V {\n+  int m = 0;\n+};\n+struct S : V {\n+  constexpr S(int) : b() { }\n+  bool b;\n+};\n+struct W {\n+  constexpr W() : s(0) { }\n+  union {\n+    S s;\n+  };\n+};\n+constexpr W w;"}, {"sha": "b676e7d17488050f1356d32e13517617fc03aff6", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-union7a.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c7bce0ac184c057bacad9c8e615ce82923835fd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-union7a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c7bce0ac184c057bacad9c8e615ce82923835fd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-union7a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-union7a.C?ref=0c7bce0ac184c057bacad9c8e615ce82923835fd", "patch": "@@ -0,0 +1,15 @@\n+// PR c++/105491\n+// { dg-do compile { target c++11 } }\n+\n+struct V {\n+  int m = 0;\n+};\n+struct S : V {\n+  constexpr S(int) : b() { }\n+  bool b;\n+};\n+union W {\n+  constexpr W() : s(0) { }\n+  S s;\n+};\n+constexpr W w;"}, {"sha": "6431654ac854bc452c70066979c345b420f183a3", "filename": "gcc/testsuite/g++.dg/cpp2a/constinit17.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c7bce0ac184c057bacad9c8e615ce82923835fd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstinit17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c7bce0ac184c057bacad9c8e615ce82923835fd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstinit17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstinit17.C?ref=0c7bce0ac184c057bacad9c8e615ce82923835fd", "patch": "@@ -0,0 +1,24 @@\n+// PR c++/105491\n+// { dg-do compile { target c++11 } }\n+\n+class Message {\n+  virtual int GetMetadata();\n+};\n+class ProtobufCFileOptions : Message {\n+public:\n+  constexpr ProtobufCFileOptions(int);\n+  bool no_generate_;\n+  bool const_strings_;\n+  bool use_oneof_field_name_;\n+  bool gen_pack_helpers_;\n+  bool gen_init_helpers_;\n+};\n+constexpr ProtobufCFileOptions::ProtobufCFileOptions(int)\n+    : no_generate_(), const_strings_(), use_oneof_field_name_(),\n+      gen_pack_helpers_(), gen_init_helpers_() {}\n+struct ProtobufCFileOptionsDefaultTypeInternal {\n+  constexpr ProtobufCFileOptionsDefaultTypeInternal() : _instance({}) {}\n+  union {\n+    ProtobufCFileOptions _instance;\n+  };\n+} __constinit _ProtobufCFileOptions_default_instance_;"}]}