{"sha": "d6be0d7f2d0a6ca4cd75c7d303fb5b51f79f7ee6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZiZTBkN2YyZDBhNmNhNGNkNzVjN2QzMDNmYjViNTFmNzlmN2VlNg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2004-11-17T21:10:00Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2004-11-17T21:10:00Z"}, "message": "tree-cfg.c (edge_to_cases): Renamed from edge_to_case_leader.\n\n\n\t* tree-cfg.c (edge_to_cases): Renamed from edge_to_case_leader.\n\t(edge_to_cases_elt): Renamed from edge_to_case_leader.\n\t(edge_to_cases_hash): Renamed from edge_to_case_leader_hash.\n\t(edge_to_cases_eq): Renamed from edge_to_case_leader_eq.\n\t(edge_to_cases_cleanup, recording_case_labels_p): New functions.\n\t(get_cases_for_edge): New function.\n\t(start_recording_case_labels, end_recording_case_labels): Similarly.\n\t(record_switch_edge): Don't muck with the CASE_LABEL.  Instead\n\tchain equivalent CASE_LABEL_EXPRs together.\n\t(get_case_leader_for_edge, get_case_leader_for_edge_hash): Kill.\n\t(make_switch_expr_edges): Do not record edge/cases here.\n\t(cleanup_tree_cfg): Record cases around the call to thread_jumps.\n\t(split_critical_edges): Record cases around the edge splitting code.\n\t(cleanup_dead_labels): Use CASE_LABEL again.\n\t(tree_redirect_edge_and_branch): If we have a mapping from edge\n\tto cases, use it to handle redirections.  Else do it the slow way.\n\t* tree.h (CASE_LEADER_OR_LABEL): Kill.\n\t(CASE_LABEL): Revert to just looking at the tree's second operand.\n\t* tree.c (get_case_label): Kill.\n\nFrom-SVN: r90817", "tree": {"sha": "da3118a0605edeaeaf002f07f16b80921e72497e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da3118a0605edeaeaf002f07f16b80921e72497e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6be0d7f2d0a6ca4cd75c7d303fb5b51f79f7ee6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6be0d7f2d0a6ca4cd75c7d303fb5b51f79f7ee6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6be0d7f2d0a6ca4cd75c7d303fb5b51f79f7ee6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6be0d7f2d0a6ca4cd75c7d303fb5b51f79f7ee6/comments", "author": null, "committer": null, "parents": [{"sha": "730bddf26ca4e5222b4130535b6bc705943f5d8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/730bddf26ca4e5222b4130535b6bc705943f5d8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/730bddf26ca4e5222b4130535b6bc705943f5d8b"}], "stats": {"total": 303, "additions": 181, "deletions": 122}, "files": [{"sha": "12dfd42cfa285ad43bd3cb8d62df374d00383a23", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6be0d7f2d0a6ca4cd75c7d303fb5b51f79f7ee6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6be0d7f2d0a6ca4cd75c7d303fb5b51f79f7ee6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d6be0d7f2d0a6ca4cd75c7d303fb5b51f79f7ee6", "patch": "@@ -1,3 +1,25 @@\n+2004-11-17  Jeff Law  <law@redhat.com>\n+\n+\t* tree-cfg.c (edge_to_cases): Renamed from edge_to_case_leader.\n+\t(edge_to_cases_elt): Renamed from edge_to_case_leader.\n+\t(edge_to_cases_hash): Renamed from edge_to_case_leader_hash.\n+\t(edge_to_cases_eq): Renamed from edge_to_case_leader_eq.\n+\t(edge_to_cases_cleanup, recording_case_labels_p): New functions.\n+\t(get_cases_for_edge): New function.\n+\t(start_recording_case_labels, end_recording_case_labels): Similarly.\n+\t(record_switch_edge): Don't muck with the CASE_LABEL.  Instead\n+\tchain equivalent CASE_LABEL_EXPRs together.\n+\t(get_case_leader_for_edge, get_case_leader_for_edge_hash): Kill.\n+\t(make_switch_expr_edges): Do not record edge/cases here.\n+\t(cleanup_tree_cfg): Record cases around the call to thread_jumps.\n+\t(split_critical_edges): Record cases around the edge splitting code.\n+\t(cleanup_dead_labels): Use CASE_LABEL again.\n+\t(tree_redirect_edge_and_branch): If we have a mapping from edge\n+\tto cases, use it to handle redirections.  Else do it the slow way.\n+\t* tree.h (CASE_LEADER_OR_LABEL): Kill.\n+\t(CASE_LABEL): Revert to just looking at the tree's second operand.\n+\t* tree.c (get_case_label): Kill.\n+\n 2004-11-17  Diego Novillo  <dnovillo@redhat.com>\n \n \tPR tree-optimization/18307"}, {"sha": "d77199549b538c5d795fa6e60d736067de99cd5c", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 158, "deletions": 100, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6be0d7f2d0a6ca4cd75c7d303fb5b51f79f7ee6/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6be0d7f2d0a6ca4cd75c7d303fb5b51f79f7ee6/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=d6be0d7f2d0a6ca4cd75c7d303fb5b51f79f7ee6", "patch": "@@ -58,29 +58,32 @@ static const int initial_cfg_capacity = 20;\n    building of the CFG in code with lots of gotos.  */\n static GTY(()) varray_type label_to_block_map;\n \n-/* This hash table allows us to efficiently lookup the one and only one\n-   CASE_LABEL_EXPR which contains the LABEL_DECL for the target block\n-   of one or more case statements.  Efficient access to this node\n-   allows us to efficiently update the case vector in response to\n-   edge redirections and similar operations. \n+/* This hash table allows us to efficiently lookup all CASE_LABEL_EXPRs\n+   which use a particular edge.  The CASE_LABEL_EXPRs are chained together\n+   via their TREE_CHAIN field, which we clear after we're done with the\n+   hash table to prevent problems with duplication of SWITCH_EXPRs.\n \n-   Right now this is only used to set up case label leaders.  In the\n-   future we hope to make this table more persistent and use it to\n-   more efficiently update case labels.  */\n+   Access to this list of CASE_LABEL_EXPRs allows us to efficiently\n+   update the case vector in response to edge redirections.\n \n-struct edge_to_case_leader_elt\n+   Right now this table is set up and torn down at key points in the\n+   compilation process.  It would be nice if we could make the table\n+   more persistent.  The key is getting notification of changes to\n+   the CFG (particularly edge removal, creation and redirection).  */\n+\n+struct edge_to_cases_elt\n {\n   /* The edge itself.  Necessary for hashing and equality tests.  */\n   edge e;\n \n-  /* The \"leader\" for all the CASE_LABEL_EXPRs which transfer control\n-     to E->dest.  When we change the destination of E, we will need to\n-     update the CASE_LEADER_OR_LABEL of this CASE_LABEL_EXPR (and no\n-     others).  */\n-  tree case_label;\n+  /* The case labels associated with this edge.  We link these up via\n+     their TREE_CHAIN field, then we wipe out the TREE_CHAIN fields\n+     when we destroy the hash table.  This prevents problems when copying\n+     SWITCH_EXPRs.  */\n+  tree case_labels;\n };\n \n-static htab_t edge_to_case_leader;\n+static htab_t edge_to_cases;\n \n /* CFG statistics.  */\n struct cfg_stats_d\n@@ -601,44 +604,95 @@ make_cond_expr_edges (basic_block bb)\n   make_edge (bb, else_bb, EDGE_FALSE_VALUE);\n }\n \n-/* Hashing routine for EDGE_TO_CASE_LEADER.  */\n+/* Hashing routine for EDGE_TO_CASES.  */\n \n static hashval_t\n-edge_to_case_leader_hash (const void *p)\n+edge_to_cases_hash (const void *p)\n {\n-  edge e = ((struct edge_to_case_leader_elt *)p)->e;\n+  edge e = ((struct edge_to_cases_elt *)p)->e;\n \n   /* Hash on the edge itself (which is a pointer).  */\n   return htab_hash_pointer (e);\n }\n \n-/* Equality routine for EDGE_TO_CASE_LEADER, edges are unique, so testing\n+/* Equality routine for EDGE_TO_CASES, edges are unique, so testing\n    for equality is just a pointer comparison.  */\n \n static int\n-edge_to_case_leader_eq (const void *p1, const void *p2)\n+edge_to_cases_eq (const void *p1, const void *p2)\n {\n-  edge e1 = ((struct edge_to_case_leader_elt *)p1)->e;\n-  edge e2 = ((struct edge_to_case_leader_elt *)p2)->e;\n+  edge e1 = ((struct edge_to_cases_elt *)p1)->e;\n+  edge e2 = ((struct edge_to_cases_elt *)p2)->e;\n \n   return e1 == e2;\n }\n \n+/* Called for each element in the hash table (P) as we delete the\n+   edge to cases hash table.\n+\n+   Clear all the TREE_CHAINs to prevent problems with copying of \n+   SWITCH_EXPRs and structure sharing rules, then free the hash table\n+   element.  */\n+\n+static void\n+edge_to_cases_cleanup (void *p)\n+{\n+  struct edge_to_cases_elt *elt = p;\n+  tree t, next;\n+\n+  for (t = elt->case_labels; t; t = next)\n+    {\n+      next = TREE_CHAIN (t);\n+      TREE_CHAIN (t) = NULL;\n+    }\n+  free (p);\n+}\n+\n+/* Start recording information mapping edges to case labels.  */\n+\n+static void\n+start_recording_case_labels (void)\n+{\n+  gcc_assert (edge_to_cases == NULL);\n+\n+  edge_to_cases = htab_create (37,\n+\t\t\t       edge_to_cases_hash,\n+\t\t\t       edge_to_cases_eq,\n+\t\t\t       edge_to_cases_cleanup);\n+}\n+\n+/* Return nonzero if we are recording information for case labels.  */\n+\n+static bool\n+recording_case_labels_p (void)\n+{\n+  return (edge_to_cases != NULL);\n+}\n+\n+/* Stop recording information mapping edges to case labels and\n+   remove any information we have recorded.  */\n+static void\n+end_recording_case_labels (void)\n+{\n+  htab_delete (edge_to_cases);\n+  edge_to_cases = NULL;\n+}\n+\n /* Record that CASE_LABEL (a CASE_LABEL_EXPR) references edge E.  */\n \n static void\n record_switch_edge (edge e, tree case_label)\n {\n-  struct edge_to_case_leader_elt *elt;\n+  struct edge_to_cases_elt *elt;\n   void **slot;\n \n   /* Build a hash table element so we can see if E is already\n      in the table.  */\n-  elt = xmalloc (sizeof (struct edge_to_case_leader_elt));\n+  elt = xmalloc (sizeof (struct edge_to_cases_elt));\n   elt->e = e;\n-  elt->case_label = case_label;\n+  elt->case_labels = case_label;\n \n-  slot = htab_find_slot (edge_to_case_leader, elt, INSERT);\n+  slot = htab_find_slot (edge_to_cases, elt, INSERT);\n \n   if (*slot == NULL)\n     {\n@@ -652,70 +706,56 @@ record_switch_edge (edge e, tree case_label)\n       free (elt);\n \n       /* Get the entry stored in the hash table.  */\n-      elt = (struct edge_to_case_leader_elt *) *slot;\n+      elt = (struct edge_to_cases_elt *) *slot;\n \n-      /* Make ELT->case_label the leader for CASE_LABEL.  */\n-      CASE_LEADER_OR_LABEL (case_label) = elt->case_label;\n+      /* Add it to the chain of CASE_LABEL_EXPRs referencing E.  */\n+      TREE_CHAIN (case_label) = elt->case_labels;\n+      elt->case_labels = case_label;\n     }\n }\n \n-/* Subroutine of get_case_leader_for_edge; returns the case leader for the\n-   chain of CASE_LABEL_EXPRs associated with E using a hash table lookup.  */\n+/* If we are inside a {start,end}_recording_cases block, then return\n+   a chain of CASE_LABEL_EXPRs from T which reference E.\n+\n+   Otherwise return NULL.  */\n \n static tree\n-get_case_leader_for_edge_hash (edge e)\n+get_cases_for_edge (edge e, tree t)\n {\n-  struct edge_to_case_leader_elt elt, *elt_p;\n+  struct edge_to_cases_elt elt, *elt_p;\n   void **slot;\n+  size_t i, n;\n+  tree vec;\n \n+  /* If we are not recording cases, then we do not have CASE_LABEL_EXPR\n+     chains available.  Return NULL so the caller can detect this case.  */\n+  if (!recording_case_labels_p ())\n+    return NULL;\n+  \n+restart:\n   elt.e = e;\n-  elt.case_label = NULL;\n-  slot = htab_find_slot (edge_to_case_leader, &elt, NO_INSERT);\n+  elt.case_labels = NULL;\n+  slot = htab_find_slot (edge_to_cases, &elt, NO_INSERT);\n \n   if (slot)\n     {\n-      tree t;\n-\n-      elt_p = (struct edge_to_case_leader_elt *)*slot;\n-      t = elt_p->case_label;\n-\n-      while (TREE_CODE (CASE_LEADER_OR_LABEL (t)) == CASE_LABEL_EXPR)\n-\tt = CASE_LEADER_OR_LABEL (t);\n-      return t;\n+      elt_p = (struct edge_to_cases_elt *)*slot;\n+      return elt_p->case_labels;\n     }\n \n-  return NULL;\n-}\n-\n-/* Given an edge E, return the case leader for the chain of CASE_LABEL_EXPRs\n-   which use E.  */\n+  /* If we did not find E in the hash table, then this must be the first\n+     time we have been queried for information about E & T.  Add all the\n+     elements from T to the hash table then perform the query again.  */\n \n-static tree\n-get_case_leader_for_edge (edge e)\n-{\n-  tree vec, stmt;\n-  size_t i, n;\n-\n-  /* If we have a hash table, then use it as it's significantly faster.  */\n-  if (edge_to_case_leader)\n-    return get_case_leader_for_edge_hash (e);\n-\n-  /* No hash table.  We have to walk the case vector.  */\n-  stmt = bsi_stmt (bsi_last (e->src));\n-  vec = SWITCH_LABELS (stmt);\n+  vec = SWITCH_LABELS (t);\n   n = TREE_VEC_LENGTH (vec);\n-\n   for (i = 0; i < n; i++)\n     {\n-      tree elt = TREE_VEC_ELT (vec, i);\n-      tree t = CASE_LEADER_OR_LABEL (elt);\n-\n-      if (TREE_CODE (t) == LABEL_DECL\n-\t  && label_to_block (t) == e->dest)\n-\treturn elt;\n+      tree lab = CASE_LABEL (TREE_VEC_ELT (vec, i));\n+      basic_block label_bb = label_to_block (lab);\n+      record_switch_edge (find_edge (e->src, label_bb), TREE_VEC_ELT (vec, i));\n     }\n-\n-  abort ();\n+  goto restart;\n }\n \n /* Create the edges for a SWITCH_EXPR starting at block BB.\n@@ -732,22 +772,12 @@ make_switch_expr_edges (basic_block bb)\n   vec = SWITCH_LABELS (entry);\n   n = TREE_VEC_LENGTH (vec);\n \n-  edge_to_case_leader\n-    = htab_create (n, edge_to_case_leader_hash, edge_to_case_leader_eq, free);\n-\n   for (i = 0; i < n; ++i)\n     {\n       tree lab = CASE_LABEL (TREE_VEC_ELT (vec, i));\n       basic_block label_bb = label_to_block (lab);\n-      edge e = make_edge (bb, label_bb, 0);\n-\n-      if (!e)\n-\te = find_edge (bb, label_bb);\n-\n-      record_switch_edge (e, TREE_VEC_ELT (vec, i));\n+      make_edge (bb, label_bb, 0);\n     }\n-  htab_delete (edge_to_case_leader);\n-  edge_to_case_leader = NULL;\n }\n \n \n@@ -869,7 +899,13 @@ cleanup_tree_cfg (void)\n \n   retval = cleanup_control_flow ();\n   retval |= delete_unreachable_blocks ();\n+\n+  /* thread_jumps can redirect edges out of SWITCH_EXPRs, which can get\n+     expensive.  So we want to enable recording of edge to CASE_LABEL_EXPR\n+     mappings around the call to thread_jumps.  */\n+  start_recording_case_labels ();\n   retval |= thread_jumps ();\n+  end_recording_case_labels ();\n \n #ifdef ENABLE_CHECKING\n   if (retval)\n@@ -1019,7 +1055,7 @@ cleanup_dead_labels (void)\n \t      {\n \t\ttree elt = TREE_VEC_ELT (vec, i);\n \t\ttree label = main_block_label (CASE_LABEL (elt));\n-\t\tCASE_LEADER_OR_LABEL (elt) = label;\n+\t\tCASE_LABEL (elt) = label;\n \t      }\n \t    break;\n \t  }\n@@ -4281,30 +4317,47 @@ tree_redirect_edge_and_branch (edge e, basic_block dest)\n \n     case SWITCH_EXPR:\n       {\n-\tedge e2;\n-\n-        /* We need to update the LABEL_DECL in the switch vector to\n-\t   reflect the edge redirection.\n+        tree cases = get_cases_for_edge (e, stmt);\n+\tedge e2 = find_edge (e->src, dest);\n \n-\t   There is precisely one CASE_LABEL_EXPR in the switch vector\n-\t   which needs updating.  Either its label needs to be updated\n-\t   or it needs to be directed to a new case leader.  */\n-\te2 = find_edge (e->src, dest);\n-\tif (e2)\n+\t/* If we have a list of cases associated with E, then use it\n+\t   as it's a lot faster than walking the entire case vector.  */\n+\tif (cases)\n \t  {\n-\t    /* In this case we need to change the case leader for the\n-\t       current leader of E to be the case leader for E2.  */\n-\t    tree e_leader = get_case_leader_for_edge (e);\n-\t    tree e2_leader = get_case_leader_for_edge (e2);\n-\t    CASE_LEADER_OR_LABEL (e_leader) = e2_leader;\n+\t    tree last, first;\n+\n+\t    first = cases;\n+\t    while (cases)\n+\t      {\n+\t\tlast = cases;\n+\t\tCASE_LABEL (cases) = label;\n+\t\tcases = TREE_CHAIN (cases);\n+\t      }\n+\n+\t    /* If there was already an edge in the CFG, then we need\n+\t       to move all the cases associated with E to E2.  */\n+\t    if (e2)\n+\t      {\n+\t\ttree cases2 = get_cases_for_edge (e2, stmt);\n+\n+\t\tTREE_CHAIN (last) = TREE_CHAIN (cases2);\n+\t\tTREE_CHAIN (cases2) = first;\n+\t      }\n \t  }\n \telse\n \t  {\n-\t    /* No edge exists from E->src to DEST, so we will simply\n-\t       change E->dest.  The case leader does not change, but\n-\t       the LABEL_DECL for the leader does change.  */\n-\t    CASE_LEADER_OR_LABEL (get_case_leader_for_edge (e)) = label;\n+\t    tree vec = SWITCH_LABELS (stmt);\n+\t    size_t i, n = TREE_VEC_LENGTH (vec);\n+\n+\t    for (i = 0; i < n; i++)\n+\t      {\n+\t\ttree elt = TREE_VEC_ELT (vec, i);\n+\n+\t\tif (label_to_block (CASE_LABEL (elt)) == e->dest)\n+\t\t  CASE_LABEL (elt) = label;\n+\t      }\n \t  }\n+\n \tbreak;\n       }\n \n@@ -5320,6 +5373,10 @@ split_critical_edges (void)\n   edge e;\n   edge_iterator ei;\n \n+  /* split_edge can redirect edges out of SWITCH_EXPRs, which can get\n+     expensive.  So we want to enable recording of edge to CASE_LABEL_EXPR\n+     mappings around the calls to split_edge.  */\n+  start_recording_case_labels ();\n   FOR_ALL_BB (bb)\n     {\n       FOR_EACH_EDGE (e, ei, bb->succs)\n@@ -5328,6 +5385,7 @@ split_critical_edges (void)\n \t    split_edge (e);\n \t  }\n     }\n+  end_recording_case_labels ();\n }\n \n struct tree_opt_pass pass_split_crit_edges = "}, {"sha": "32ec8a54911e21b1eac86bf6a224ca221e54ee5c", "filename": "gcc/tree.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6be0d7f2d0a6ca4cd75c7d303fb5b51f79f7ee6/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6be0d7f2d0a6ca4cd75c7d303fb5b51f79f7ee6/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=d6be0d7f2d0a6ca4cd75c7d303fb5b51f79f7ee6", "patch": "@@ -6061,19 +6061,6 @@ signed_type_for (tree type)\n   return lang_hooks.types.signed_type (type);\n }\n \n-/* Return the LABEL_DECL associated with T, which must be a \n-   CASE_LABEL_EXPR.  This will walk through any CASE_LABEL_EXPRs\n-   appearing in operand 2 until it finds a CASE_LABEL_EXPR with\n-   a LABEL_DECL in operand 2.  */\n-\n-tree\n-get_case_label (tree t)\n-{\n-  while (TREE_CODE (CASE_LEADER_OR_LABEL (t)) == CASE_LABEL_EXPR)\n-    t = CASE_LEADER_OR_LABEL (t);\n-  return CASE_LEADER_OR_LABEL (t);\n-}\n-\n /* Returns the largest value obtainable by casting something in INNER type to\n    OUTER type.  */\n "}, {"sha": "83dd4ca0a1d8ac73bf3926b8c7fa21fc4056d463", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6be0d7f2d0a6ca4cd75c7d303fb5b51f79f7ee6/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6be0d7f2d0a6ca4cd75c7d303fb5b51f79f7ee6/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=d6be0d7f2d0a6ca4cd75c7d303fb5b51f79f7ee6", "patch": "@@ -1231,15 +1231,7 @@ struct tree_vec GTY(())\n    of a case label, respectively.  */\n #define CASE_LOW(NODE)          \tTREE_OPERAND ((NODE), 0)\n #define CASE_HIGH(NODE)         \tTREE_OPERAND ((NODE), 1)\n-\n-/* Operand 2 has two uses, it may either be a LABEL_DECL node or a\n-   another CASE_LABEL_EXPR node.  This accessor gets direct access\n-   to that operand.  Use it when you want to assign a value to\n-   operand 2 or when you want to conditionalize actions based on\n-   whether operand 2 is a LABEL_DECL or CASE_LABEL_EXPR.  */\n-#define CASE_LEADER_OR_LABEL(NODE)\tTREE_OPERAND ((NODE), 2)\n-\n-#define CASE_LABEL(NODE) get_case_label (NODE)\n+#define CASE_LABEL(NODE)\t\tTREE_OPERAND ((NODE), 2)\n \n /* The operands of a BIND_EXPR.  */\n #define BIND_EXPR_VARS(NODE) (TREE_OPERAND (BIND_EXPR_CHECK (NODE), 0))"}]}