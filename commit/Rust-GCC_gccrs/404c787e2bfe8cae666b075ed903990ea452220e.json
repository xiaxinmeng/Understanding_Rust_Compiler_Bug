{"sha": "404c787e2bfe8cae666b075ed903990ea452220e", "node_id": "C_kwDOANBUbNoAKDQwNGM3ODdlMmJmZThjYWU2NjZiMDc1ZWQ5MDM5OTBlYTQ1MjIyMGU", "commit": {"author": {"name": "Siddhesh Poyarekar", "email": "siddhesh@gotplt.org", "date": "2022-01-10T23:57:51Z"}, "committer": {"name": "Siddhesh Poyarekar", "email": "siddhesh@gotplt.org", "date": "2022-01-11T14:46:55Z"}, "message": "tree-object-size: Support dynamic sizes in conditions\n\nHandle GIMPLE_PHI and conditionals specially for dynamic objects,\nreturning PHI/conditional expressions instead of just a MIN/MAX\nestimate.\n\nThis makes the returned object size variable for loops and conditionals,\nso tests need to be adjusted to look for precise size in some cases.\nbuiltin-dynamic-object-size-5.c had to be modified to only look for\nsuccess in maximum object size case and skip over the minimum object\nsize tests because the result is no longer a compile time constant.\n\nI also added some simple tests to exercise conditionals with dynamic\nobject sizes.\n\ngcc/ChangeLog:\n\n\tPR middle-end/70090\n\t* builtins.c (fold_builtin_object_size): Adjust for dynamic size\n\texpressions.\n\t* tree-object-size.c: Include gimplify-me.h.\n\t(struct object_size_info): New member UNKNOWNS.\n\t(size_initval_p, size_usable_p, object_sizes_get_raw): New\n\tfunctions.\n\t(object_sizes_get): Return suitable gimple variable for\n\tobject size.\n\t(bundle_sizes): New function.\n\t(object_sizes_set): Use it and handle dynamic object size\n\texpressions.\n\t(object_sizes_set_temp): New function.\n\t(size_for_offset): Adjust for dynamic size expressions.\n\t(emit_phi_nodes, propagate_unknowns, gimplify_size_expressions):\n\tNew functions.\n\t(compute_builtin_object_size): Call gimplify_size_expressions\n\tfor OST_DYNAMIC.\n\t(dynamic_object_size): New function.\n\t(cond_expr_object_size): Use it.\n\t(phi_dynamic_object_size): New function.\n\t(collect_object_sizes_for): Call it for OST_DYNAMIC.  Adjust to\n\taccommodate dynamic object sizes.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/70090\n\t* gcc.dg/builtin-dynamic-object-size-0.c: New tests.\n\t* gcc.dg/builtin-dynamic-object-size-10.c: Add comment.\n\t* gcc.dg/builtin-dynamic-object-size-5-main.c: New file.\n\t* gcc.dg/builtin-dynamic-object-size-5.c: Use it and change test\n\tto dg-do run.\n\t* gcc.dg/builtin-object-size-5.c [!N]: Define N.\n\t(test1, test2, test3, test4) [__builtin_object_size]: Expect\n\texact result for __builtin_dynamic_object_size.\n\t* gcc.dg/builtin-object-size-1.c [__builtin_object_size]: Expect\n\texact size expressions for __builtin_dynamic_object_size.\n\t* gcc.dg/builtin-object-size-2.c [__builtin_object_size]:\n\tLikewise.\n\t* gcc.dg/builtin-object-size-3.c [__builtin_object_size]:\n\tLikewise.\n\t* gcc.dg/builtin-object-size-4.c [__builtin_object_size]:\n\tLikewise.\n\nSigned-off-by: Siddhesh Poyarekar <siddhesh@gotplt.org>", "tree": {"sha": "61a286b541c75333e0b9110a5c6fa1fec842ab14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61a286b541c75333e0b9110a5c6fa1fec842ab14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/404c787e2bfe8cae666b075ed903990ea452220e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/404c787e2bfe8cae666b075ed903990ea452220e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/404c787e2bfe8cae666b075ed903990ea452220e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/404c787e2bfe8cae666b075ed903990ea452220e/comments", "author": {"login": "siddhesh", "id": 158582, "node_id": "MDQ6VXNlcjE1ODU4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/158582?v=4", "gravatar_id": "", "url": "https://api.github.com/users/siddhesh", "html_url": "https://github.com/siddhesh", "followers_url": "https://api.github.com/users/siddhesh/followers", "following_url": "https://api.github.com/users/siddhesh/following{/other_user}", "gists_url": "https://api.github.com/users/siddhesh/gists{/gist_id}", "starred_url": "https://api.github.com/users/siddhesh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/siddhesh/subscriptions", "organizations_url": "https://api.github.com/users/siddhesh/orgs", "repos_url": "https://api.github.com/users/siddhesh/repos", "events_url": "https://api.github.com/users/siddhesh/events{/privacy}", "received_events_url": "https://api.github.com/users/siddhesh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "siddhesh", "id": 158582, "node_id": "MDQ6VXNlcjE1ODU4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/158582?v=4", "gravatar_id": "", "url": "https://api.github.com/users/siddhesh", "html_url": "https://github.com/siddhesh", "followers_url": "https://api.github.com/users/siddhesh/followers", "following_url": "https://api.github.com/users/siddhesh/following{/other_user}", "gists_url": "https://api.github.com/users/siddhesh/gists{/gist_id}", "starred_url": "https://api.github.com/users/siddhesh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/siddhesh/subscriptions", "organizations_url": "https://api.github.com/users/siddhesh/orgs", "repos_url": "https://api.github.com/users/siddhesh/repos", "events_url": "https://api.github.com/users/siddhesh/events{/privacy}", "received_events_url": "https://api.github.com/users/siddhesh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "026d44cbbd42653908f9faf6b80773f03e1bb1a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/026d44cbbd42653908f9faf6b80773f03e1bb1a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/026d44cbbd42653908f9faf6b80773f03e1bb1a0"}], "stats": {"total": 1058, "additions": 1022, "deletions": 36}, "files": [{"sha": "c780340ed327a6ed09cf492821f8cce4197f294c", "filename": "gcc/builtins.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/404c787e2bfe8cae666b075ed903990ea452220e/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/404c787e2bfe8cae666b075ed903990ea452220e/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=404c787e2bfe8cae666b075ed903990ea452220e", "patch": "@@ -10306,7 +10306,8 @@ fold_builtin_object_size (tree ptr, tree ost, enum built_in_function fcode)\n   if (TREE_CODE (ptr) == ADDR_EXPR)\n     {\n       compute_builtin_object_size (ptr, object_size_type, &bytes);\n-      if (int_fits_type_p (bytes, size_type_node))\n+      if ((object_size_type & OST_DYNAMIC)\n+\t  || int_fits_type_p (bytes, size_type_node))\n \treturn fold_convert (size_type_node, bytes);\n     }\n   else if (TREE_CODE (ptr) == SSA_NAME)\n@@ -10315,7 +10316,8 @@ fold_builtin_object_size (tree ptr, tree ost, enum built_in_function fcode)\n        later.  Maybe subsequent passes will help determining\n        it.  */\n       if (compute_builtin_object_size (ptr, object_size_type, &bytes)\n-\t  && int_fits_type_p (bytes, size_type_node))\n+\t  && ((object_size_type & OST_DYNAMIC)\n+\t      || int_fits_type_p (bytes, size_type_node)))\n \treturn fold_convert (size_type_node, bytes);\n     }\n "}, {"sha": "b1013e19fd0a20365c670ef2e6698254ea454a97", "filename": "gcc/testsuite/gcc.dg/builtin-dynamic-object-size-0.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/404c787e2bfe8cae666b075ed903990ea452220e/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-dynamic-object-size-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/404c787e2bfe8cae666b075ed903990ea452220e/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-dynamic-object-size-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-dynamic-object-size-0.c?ref=404c787e2bfe8cae666b075ed903990ea452220e", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+#define abort __builtin_abort\n+\n+size_t\n+__attribute__ ((noinline))\n+test_builtin_malloc_condphi (int cond)\n+{\n+  void *ch;\n+ \n+  if (cond)\n+    ch = __builtin_malloc (32);\n+  else\n+    ch = __builtin_malloc (64);\n+\n+  size_t ret = __builtin_dynamic_object_size (ch, 0);\n+\n+  __builtin_free (ch);\n+  return ret;\n+}\n+\n+size_t\n+__attribute__ ((noinline))\n+test_deploop (size_t sz, size_t cond)\n+{\n+  char *bin = __builtin_alloca (32);\n+\n+  for (size_t i = 0; i < sz; i++)\n+    if (i == cond)\n+      bin = __builtin_alloca (64);\n+\n+  return __builtin_dynamic_object_size (bin, 0);\n+}\n+\n+unsigned nfails = 0;\n+\n+#define FAIL() ({ \\\n+  __builtin_printf (\"Failure at line: %d\\n\", __LINE__);\t\t\t      \\\n+  nfails++;\t\t\t\t\t\t\t\t      \\\n+})\n+\n+int\n+main ()\n+{\n+  if (test_builtin_malloc_condphi (1) != 32)\n+    FAIL ();\n+  if (test_builtin_malloc_condphi (0) != 64)\n+    FAIL ();\n+  if (test_deploop (128, 129) != 32)\n+    FAIL ();\n+\n+  if (nfails > 0)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "3a2d9821a44e25bb5150f52c7533ff17dcef4300", "filename": "gcc/testsuite/gcc.dg/builtin-dynamic-object-size-10.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/404c787e2bfe8cae666b075ed903990ea452220e/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-dynamic-object-size-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/404c787e2bfe8cae666b075ed903990ea452220e/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-dynamic-object-size-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-dynamic-object-size-10.c?ref=404c787e2bfe8cae666b075ed903990ea452220e", "patch": "@@ -5,5 +5,7 @@\n #define __builtin_object_size __builtin_dynamic_object_size\n #include \"builtin-object-size-10.c\"\n \n+/* early_objsz should resolve __builtin_dynamic_object_size like\n+   __builtin_object_size.  */\n /* { dg-final { scan-tree-dump \"maximum object size 21\" \"early_objsz\" } } */\n /* { dg-final { scan-tree-dump \"maximum subobject size 16\" \"early_objsz\" } } */"}, {"sha": "49f459b8cf2b498ecc744bc4f4a94df0fbc0338d", "filename": "gcc/testsuite/gcc.dg/builtin-dynamic-object-size-5-main.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/404c787e2bfe8cae666b075ed903990ea452220e/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-dynamic-object-size-5-main.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/404c787e2bfe8cae666b075ed903990ea452220e/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-dynamic-object-size-5-main.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-dynamic-object-size-5-main.c?ref=404c787e2bfe8cae666b075ed903990ea452220e", "patch": "@@ -0,0 +1,32 @@\n+#ifdef N\n+typedef __SIZE_TYPE__ size_t;\n+\n+char buf[N];\n+\n+void test1 (size_t);\n+void test2 (size_t);\n+void test3 (size_t);\n+void test4 (size_t);\n+void test5 (size_t);\n+void test6 (size_t);\n+void test7 (size_t);\n+\n+int\n+main (void)\n+{\n+  test1 (42);\n+  test2 (42);\n+  test3 (42);\n+  test4 (42);\n+  test5 (42);\n+  test6 (42);\n+  test7 (42);\n+  return 0;\n+}\n+#else\n+int\n+main (void)\n+{\n+  return 0;\n+}\n+#endif"}, {"sha": "80b77dd524996ad04f9c39ab18f9a682ca0ff2dc", "filename": "gcc/testsuite/gcc.dg/builtin-dynamic-object-size-5.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/404c787e2bfe8cae666b075ed903990ea452220e/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-dynamic-object-size-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/404c787e2bfe8cae666b075ed903990ea452220e/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-dynamic-object-size-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-dynamic-object-size-5.c?ref=404c787e2bfe8cae666b075ed903990ea452220e", "patch": "@@ -1,7 +1,6 @@\n-/* { dg-do compile { target i?86-*-linux* i?86-*-gnu* x86_64-*-linux* } } */\n-/* { dg-options \"-O2\" } */\n+/* { dg-do run { target i?86-*-linux* i?86-*-gnu* x86_64-*-linux* } } */\n+/* { dg-options \"-O2 -DN=0x4000000\" } */\n+/* { dg-additional-sources \"builtin-dynamic-object-size-5-main.c\" } */\n \n #define __builtin_object_size __builtin_dynamic_object_size\n #include \"builtin-object-size-5.c\"\n-\n-/* { dg-final { scan-assembler-not \"abort\" } } */"}, {"sha": "265c87ed6fb9a82b351476a408793bb28451e950", "filename": "gcc/testsuite/gcc.dg/builtin-object-size-1.c", "status": "modified", "additions": 117, "deletions": 2, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/404c787e2bfe8cae666b075ed903990ea452220e/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/404c787e2bfe8cae666b075ed903990ea452220e/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-1.c?ref=404c787e2bfe8cae666b075ed903990ea452220e", "patch": "@@ -42,9 +42,17 @@ test1 (void *q, int x)\n     abort ();\n   if (__builtin_object_size (q, 0) != (size_t) -1)\n     abort ();\n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (r, 0)\n+      != (x < 0\n+\t  ? sizeof (a) - __builtin_offsetof (struct A, a) - 9\n+\t  : sizeof (a) - __builtin_offsetof (struct A, c) - 1))\n+    abort ();\n+#else\n   if (__builtin_object_size (r, 0)\n       != sizeof (a) - __builtin_offsetof (struct A, a) - 9)\n     abort ();\n+#endif\n   if (x < 6)\n     r = &w[2].a[1];\n   else\n@@ -58,9 +66,17 @@ test1 (void *q, int x)\n   if (__builtin_object_size (&y.b, 0)\n       != sizeof (a) - __builtin_offsetof (struct A, b))\n     abort ();\n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (r, 0)\n+      != (x < 6\n+\t  ? 2 * sizeof (w[0]) - __builtin_offsetof (struct A, a) - 1\n+\t  : sizeof (a) - __builtin_offsetof (struct A, a) - 6))\n+    abort ();\n+#else\n   if (__builtin_object_size (r, 0)\n       != 2 * sizeof (w[0]) - __builtin_offsetof (struct A, a) - 1)\n     abort ();\n+#endif\n   if (x < 20)\n     r = malloc (30);\n   else\n@@ -165,6 +181,7 @@ test2 (void)\n   struct B { char buf1[10]; char buf2[10]; } a;\n   char *r, buf3[20];\n   int i;\n+  size_t res;\n \n   if (sizeof (a) != 20)\n     return;\n@@ -181,7 +198,24 @@ test2 (void)\n       else if (i == l1 + 2)\n \tr = &a.buf1[9];\n     }\n-  if (__builtin_object_size (r, 0) != 20)\n+#ifdef __builtin_object_size\n+  res = sizeof (buf3);\n+\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+        res = sizeof (a) - __builtin_offsetof (struct B, buf1) - 1;\n+      else if (i == l1)\n+        res = sizeof (a) - __builtin_offsetof (struct B, buf2) - 7;\n+      else if (i == l1 + 1)\n+        res = sizeof (buf3) - 5;\n+      else if (i == l1 + 2)\n+        res = sizeof (a) - __builtin_offsetof (struct B, buf1) - 9;\n+    }\n+#else\n+  res = 20;\n+#endif\n+  if (__builtin_object_size (r, 0) != res)\n     abort ();\n   r = &buf3[20];\n   for (i = 0; i < 4; ++i)\n@@ -195,13 +229,45 @@ test2 (void)\n       else if (i == l1 + 2)\n \tr = &a.buf1[9];\n     }\n-  if (__builtin_object_size (r, 0) != 15)\n+#ifdef __builtin_object_size\n+  res = sizeof (buf3) - 20;\n+\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+        res = sizeof (a) - __builtin_offsetof (struct B, buf1) - 7;\n+      else if (i == l1)\n+        res = sizeof (a) - __builtin_offsetof (struct B, buf2) - 7;\n+      else if (i == l1 + 1)\n+        res = sizeof (buf3) - 5;\n+      else if (i == l1 + 2)\n+        res = sizeof (a) - __builtin_offsetof (struct B, buf1) - 9;\n+    }\n+  if (__builtin_object_size (r, 0) != res)\n+    abort ();\n+#else\n+  res = 15;\n+#endif\n+  if (__builtin_object_size (r, 0) != res)\n     abort ();\n   r += 8;\n+#ifdef __builtin_object_size\n+  res -= 8;\n+  if (__builtin_object_size (r, 0) != res)\n+    abort ();\n+  if (res >= 6)\n+    {\n+      if (__builtin_object_size (r + 6, 0) != res - 6)\n+        abort ();\n+    }\n+  else if (__builtin_object_size (r + 6, 0) != 0)\n+    abort ();\n+#else\n   if (__builtin_object_size (r, 0) != 7)\n     abort ();\n   if (__builtin_object_size (r + 6, 0) != 1)\n     abort ();\n+#endif\n   r = &buf3[18];\n   for (i = 0; i < 4; ++i)\n     {\n@@ -214,8 +280,31 @@ test2 (void)\n       else if (i == l1 + 2)\n \tr = &a.buf1[4];\n     }\n+#ifdef __builtin_object_size\n+  res = sizeof (buf3) - 18;\n+\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+          res = sizeof (a) - __builtin_offsetof (struct B, buf1) - 9;\n+      else if (i == l1)\n+        res = sizeof (a) - __builtin_offsetof (struct B, buf2) - 9;\n+      else if (i == l1 + 1)\n+        res = sizeof (buf3) - 5;\n+      else if (i == l1 + 2)\n+        res = sizeof (a) - __builtin_offsetof (struct B, buf1) - 4;\n+    }\n+  if (res >= 12)\n+    {\n+      if (__builtin_object_size (r + 12, 0) != res - 12)\n+        abort ();\n+    }\n+  else if (__builtin_object_size (r + 12, 0) != 0)\n+    abort ();\n+#else\n   if (__builtin_object_size (r + 12, 0) != 4)\n     abort ();\n+#endif\n }\n \n void\n@@ -358,6 +447,10 @@ test5 (size_t x)\n \n   for (i = 0; i < x; ++i)\n     p = p + 4;\n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (p, 0) != sizeof (buf) - 8 - 4 * x)\n+    abort ();\n+#else\n   /* My understanding of ISO C99 6.5.6 is that a conforming\n      program will not end up with p equal to &buf[0]\n      through &buf[7], i.e. calling this function with say\n@@ -367,6 +460,7 @@ test5 (size_t x)\n      it would be 64 (or conservative (size_t) -1 == unknown).  */\n   if (__builtin_object_size (p, 0) != sizeof (buf) - 8)\n     abort ();\n+#endif\n   memset (p, ' ', sizeof (buf) - 8 - 4 * 4);\n }\n \n@@ -380,8 +474,13 @@ test6 (size_t x)\n \n   for (i = 0; i < x; ++i)\n     p = p + 4;\n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (p, 0) != sizeof (t) - 8 - 4 * x)\n+    abort ();\n+#else\n   if (__builtin_object_size (p, 0) != sizeof (t) - 8)\n     abort ();\n+#endif\n   memset (p, ' ', sizeof (t) - 8 - 4 * 4);\n }\n \n@@ -436,21 +535,37 @@ test9 (unsigned cond)\n   else\n     p = &buf2[4];\n \n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (&p[-4], 0) != (cond ? 6 : 10))\n+    abort ();\n+#else\n   if (__builtin_object_size (&p[-4], 0) != 10)\n     abort ();\n+#endif\n \n   for (unsigned i = cond; i > 0; i--)\n     p--;\n \n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (p, 0) != ((cond ? 2 : 6) + cond))\n+    abort ();\n+#else\n   if (__builtin_object_size (p, 0) != 10)\n     abort ();\n+#endif\n \n   p = &y.c[8];\n   for (unsigned i = cond; i > 0; i--)\n     p--;\n \n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (p, 0)\n+      != sizeof (y) - __builtin_offsetof (struct A, c) - 8 + cond)\n+    abort ();\n+#else\n   if (__builtin_object_size (p, 0) != sizeof (y))\n     abort ();\n+#endif\n }\n \n int"}, {"sha": "5051fea47c30acfe95f765cf0756ee9e20f51c9c", "filename": "gcc/testsuite/gcc.dg/builtin-object-size-2.c", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/404c787e2bfe8cae666b075ed903990ea452220e/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/404c787e2bfe8cae666b075ed903990ea452220e/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-2.c?ref=404c787e2bfe8cae666b075ed903990ea452220e", "patch": "@@ -43,8 +43,15 @@ test1 (void *q, int x)\n     abort ();\n   if (__builtin_object_size (q, 1) != (size_t) -1)\n     abort ();\n+#ifdef __builtin_object_size\n+  if (x < 0\n+      ? __builtin_object_size (r, 1) != sizeof (a.a) - 9\n+      : __builtin_object_size (r, 1) != sizeof (a.c) - 1)\n+    abort ();\n+#else\n   if (__builtin_object_size (r, 1) != sizeof (a.c) - 1)\n     abort ();\n+#endif\n   if (x < 6)\n     r = &w[2].a[1];\n   else\n@@ -55,8 +62,15 @@ test1 (void *q, int x)\n     abort ();\n   if (__builtin_object_size (&y.b, 1) != sizeof (a.b))\n     abort ();\n+#ifdef __builtin_object_size\n+  if (x < 6\n+      ? __builtin_object_size (r, 1) != sizeof (a.a) - 1\n+      : __builtin_object_size (r, 1) != sizeof (a.a) - 6)\n+    abort ();\n+#else\n   if (__builtin_object_size (r, 1) != sizeof (a.a) - 1)\n     abort ();\n+#endif\n   if (x < 20)\n     r = malloc (30);\n   else\n@@ -185,6 +199,9 @@ test2 (void)\n   struct B { char buf1[10]; char buf2[10]; } a;\n   char *r, buf3[20];\n   int i;\n+#ifdef __builtin_object_size\n+  size_t dyn_res;\n+#endif\n \n   if (sizeof (a) != 20)\n     return;\n@@ -201,8 +218,26 @@ test2 (void)\n       else if (i == l1 + 2)\n \tr = &a.buf1[9];\n     }\n+#ifdef __builtin_object_size\n+  dyn_res = sizeof (buf3);\n+\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tdyn_res = sizeof (a.buf1) - 1;\n+      else if (i == l1)\n+\tdyn_res = sizeof (a.buf2) - 7;\n+      else if (i == l1 + 1)\n+\tdyn_res = sizeof (buf3) - 5;\n+      else if (i == l1 + 2)\n+\tdyn_res = sizeof (a.buf1) - 9;\n+    }\n+  if (__builtin_object_size (r, 1) != dyn_res)\n+    abort ();\n+#else\n   if (__builtin_object_size (r, 1) != sizeof (buf3))\n     abort ();\n+#endif\n   r = &buf3[20];\n   for (i = 0; i < 4; ++i)\n     {\n@@ -215,13 +250,50 @@ test2 (void)\n       else if (i == l1 + 2)\n \tr = &a.buf1[9];\n     }\n+#ifdef __builtin_object_size\n+  dyn_res = sizeof (buf3) - 20;\n+\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+        dyn_res = sizeof (a.buf1) - 7;\n+      else if (i == l1)\n+        dyn_res = sizeof (a.buf2) - 7;\n+      else if (i == l1 + 1)\n+        dyn_res = sizeof (buf3) - 5;\n+      else if (i == l1 + 2)\n+        dyn_res = sizeof (a.buf1) - 9;\n+    }\n+  if (__builtin_object_size (r, 1) != dyn_res)\n+    abort ();\n+#else\n   if (__builtin_object_size (r, 1) != sizeof (buf3) - 5)\n     abort ();\n+#endif\n   r += 8;\n+#ifdef __builtin_object_size\n+  if (dyn_res >= 8)\n+    {\n+      dyn_res -= 8;\n+      if (__builtin_object_size (r, 1) != dyn_res)\n+\tabort ();\n+\n+      if (dyn_res >= 6)\n+\t{\n+\t  if (__builtin_object_size (r + 6, 1) != dyn_res - 6)\n+\t    abort ();\n+\t}\n+      else if (__builtin_object_size (r + 6, 1) != 0)\n+\tabort ();\n+    }\n+  else if (__builtin_object_size (r, 1) != 0)\n+    abort ();\n+#else\n   if (__builtin_object_size (r, 1) != sizeof (buf3) - 13)\n     abort ();\n   if (__builtin_object_size (r + 6, 1) != sizeof (buf3) - 19)\n     abort ();\n+#endif\n }\n \n void\n@@ -339,8 +411,13 @@ test5 (size_t x)\n \n   for (i = 0; i < x; ++i)\n     p = p + 4;\n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (p, 1) != sizeof (t.buf) - 8 - 4 * x)\n+    abort ();\n+#else\n   if (__builtin_object_size (p, 1) != sizeof (t.buf) - 8)\n     abort ();\n+#endif\n   memset (p, ' ', sizeof (t.buf) - 8 - 4 * 4);\n }\n \n@@ -394,21 +471,36 @@ test8 (unsigned cond)\n   else\n     p = &buf2[4];\n \n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (&p[-4], 1) != (cond ? 6 : 10))\n+    abort ();\n+#else\n   if (__builtin_object_size (&p[-4], 1) != 10)\n     abort ();\n+#endif\n \n   for (unsigned i = cond; i > 0; i--)\n     p--;\n \n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (p, 1) != ((cond ? 2 : 6) + cond))\n+    abort ();\n+#else\n   if (__builtin_object_size (p, 1) != 10)\n     abort ();\n+#endif\n \n   p = &y.c[8];\n   for (unsigned i = cond; i > 0; i--)\n     p--;\n \n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (p, 1) != sizeof (y.c) - 8 + cond)\n+    abort ();\n+#else\n   if (__builtin_object_size (p, 1) != sizeof (y.c))\n     abort ();\n+#endif\n }\n \n int"}, {"sha": "1d92627266bf3bd862161917ae5120f955a6f47b", "filename": "gcc/testsuite/gcc.dg/builtin-object-size-3.c", "status": "modified", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/404c787e2bfe8cae666b075ed903990ea452220e/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/404c787e2bfe8cae666b075ed903990ea452220e/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-3.c?ref=404c787e2bfe8cae666b075ed903990ea452220e", "patch": "@@ -71,23 +71,45 @@ test1 (void *q, int x)\n     r = malloc (30);\n   else\n     r = calloc (2, 14);\n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (r, 2) != (x < 20 ? 30 : 2 * 14))\n+    abort ();\n+#else\n   if (__builtin_object_size (r, 2) != 2 * 14)\n     abort ();\n+#endif\n   if (x < 30)\n     r = malloc (sizeof (a));\n   else\n     r = &a.a[3];\n+#ifdef __builtin_object_size\n+  size_t objsz = (x < 30 ? sizeof (a)\n+                  : sizeof (a) - __builtin_offsetof (struct A, a) - 3);\n+  if (__builtin_object_size (r, 2) != objsz)\n+    abort ();\n+#else\n   if (__builtin_object_size (r, 2)\n       != sizeof (a) - __builtin_offsetof (struct A, a) - 3)\n     abort ();\n+#endif\n   r = memcpy (r, \"a\", 2);\n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (r, 2) != objsz)\n+    abort ();\n+#else\n   if (__builtin_object_size (r, 2)\n       != sizeof (a) - __builtin_offsetof (struct A, a) - 3)\n     abort ();\n+#endif\n   r = memcpy (r + 2, \"b\", 2) + 2;\n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (r, 2) != objsz - 4)\n+    abort ();\n+#else\n   if (__builtin_object_size (r, 2)\n       != sizeof (a) - __builtin_offsetof (struct A, a) - 3 - 4)\n     abort ();\n+#endif\n   r = &a.a[4];\n   r = memset (r, 'a', 2);\n   if (__builtin_object_size (r, 2)\n@@ -164,6 +186,9 @@ test2 (void)\n   struct B { char buf1[10]; char buf2[10]; } a;\n   char *r, buf3[20];\n   int i;\n+#ifdef __builtin_object_size\n+  size_t dyn_res;\n+#endif\n \n   if (sizeof (a) != 20)\n     return;\n@@ -180,8 +205,26 @@ test2 (void)\n       else if (i == l1 + 2)\n \tr = &a.buf1[9];\n     }\n+#ifdef __builtin_object_size\n+  dyn_res = sizeof (buf3);\n+\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tdyn_res = sizeof (a) - __builtin_offsetof (struct B, buf1) - 1;\n+      else if (i == l1)\n+\tdyn_res = sizeof (a) - __builtin_offsetof (struct B, buf2) - 7;\n+      else if (i == l1 + 1)\n+\tdyn_res = sizeof (buf3) - 5;\n+      else if (i == l1 + 2)\n+\tdyn_res = sizeof (a) - __builtin_offsetof (struct B, buf1) - 9;\n+    }\n+  if (__builtin_object_size (r, 2) != dyn_res)\n+    abort ();\n+#else\n   if (__builtin_object_size (r, 2) != 3)\n     abort ();\n+#endif\n   r = &buf3[20];\n   for (i = 0; i < 4; ++i)\n     {\n@@ -208,13 +251,44 @@ test2 (void)\n       else if (i == l1 + 2)\n \tr = &a.buf1[4];\n     }\n+#ifdef __builtin_object_size\n+  dyn_res = sizeof (buf3) - 2;\n+\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tdyn_res = sizeof (a) - __builtin_offsetof (struct B, buf1) - 1;\n+      else if (i == l1)\n+\tdyn_res = sizeof (a) - __builtin_offsetof (struct B, buf1) - 2;\n+      else if (i == l1 + 1)\n+\tdyn_res = sizeof (buf3) - 5;\n+      else if (i == l1 + 2)\n+\tdyn_res = sizeof (a) - __builtin_offsetof (struct B, buf1) - 4;\n+    }\n+  if (__builtin_object_size (r, 2) != dyn_res)\n+    abort ();\n+#else\n   if (__builtin_object_size (r, 2) != 15)\n     abort ();\n+#endif\n   r += 8;\n+#ifdef __builtin_object_size\n+  dyn_res -= 8;\n+  if (__builtin_object_size (r, 2) != dyn_res)\n+    abort ();\n+  if (dyn_res >= 6)\n+    {\n+      if (__builtin_object_size (r + 6, 2) != dyn_res - 6)\n+\tabort ();\n+    }\n+  else if (__builtin_object_size (r + 6, 2) != 0)\n+    abort ();\n+#else\n   if (__builtin_object_size (r, 2) != 7)\n     abort ();\n   if (__builtin_object_size (r + 6, 2) != 1)\n     abort ();\n+#endif\n   r = &buf3[18];\n   for (i = 0; i < 4; ++i)\n     {\n@@ -227,8 +301,31 @@ test2 (void)\n       else if (i == l1 + 2)\n \tr = &a.buf1[4];\n     }\n+#ifdef __builtin_object_size\n+  dyn_res = sizeof (buf3) - 18;\n+\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tdyn_res = sizeof (a) - __builtin_offsetof (struct B, buf1) - 9;\n+      else if (i == l1)\n+\tdyn_res = sizeof (a) - __builtin_offsetof (struct B, buf2) - 9;\n+      else if (i == l1 + 1)\n+\tdyn_res = sizeof (buf3) - 5;\n+      else if (i == l1 + 2)\n+\tdyn_res = sizeof (a) - __builtin_offsetof (struct B, buf1) - 4;\n+    }\n+  if (dyn_res >= 12)\n+    {\n+      if (__builtin_object_size (r + 12, 2) != dyn_res - 12)\n+\tabort ();\n+    }\n+  else if (__builtin_object_size (r + 12, 2) != 0)\n+    abort ();\n+#else\n   if (__builtin_object_size (r + 12, 2) != 0)\n     abort ();\n+#endif\n }\n \n void\n@@ -371,7 +468,11 @@ test5 (size_t x)\n \n   for (i = 0; i < x; ++i)\n     p = p + 4;\n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (p, 2) != sizeof (buf) - 8 - 4 * x)\n+#else\n   if (__builtin_object_size (p, 2) != 0)\n+#endif\n     abort ();\n   memset (p, ' ', sizeof (buf) - 8 - 4 * 4);\n }\n@@ -386,7 +487,11 @@ test6 (size_t x)\n \n   for (i = 0; i < x; ++i)\n     p = p + 4;\n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (p, 2) != sizeof (t) - 8 - 4 * x)\n+#else\n   if (__builtin_object_size (p, 2) != 0)\n+#endif\n     abort ();\n   memset (p, ' ', sizeof (t) - 8 - 4 * 4);\n }\n@@ -442,22 +547,38 @@ test9 (unsigned cond)\n   else\n     p = &buf2[4];\n \n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (&p[-4], 2) != (cond ? 6 : 10))\n+    abort ();\n+#else\n   if (__builtin_object_size (&p[-4], 2) != 6)\n     abort ();\n+#endif\n \n   for (unsigned i = cond; i > 0; i--)\n     p--;\n \n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (p, 2) != ((cond ? 2 : 6) + cond))\n+    abort ();\n+#else\n   if (__builtin_object_size (p, 2) != 2)\n     abort ();\n+#endif\n \n   p = &y.c[8];\n   for (unsigned i = cond; i > 0; i--)\n     p--;\n \n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (p, 2)\n+      != sizeof (y) - __builtin_offsetof (struct A, c) - 8 + cond)\n+    abort ();\n+#else\n   if (__builtin_object_size (p, 2)\n       != sizeof (y) - __builtin_offsetof (struct A, c) - 8)\n     abort ();\n+#endif\n }\n \n int"}, {"sha": "9da3537a5f76679ca2ee3bcab049ed44b69d8f38", "filename": "gcc/testsuite/gcc.dg/builtin-object-size-4.c", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/404c787e2bfe8cae666b075ed903990ea452220e/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/404c787e2bfe8cae666b075ed903990ea452220e/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-4.c?ref=404c787e2bfe8cae666b075ed903990ea452220e", "patch": "@@ -43,7 +43,12 @@ test1 (void *q, int x)\n     abort ();\n   if (__builtin_object_size (q, 3) != 0)\n     abort ();\n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (r, 3)\n+      != (x < 0 ? sizeof (a.a) - 9 : sizeof (a.c) - 1))\n+#else\n   if (__builtin_object_size (r, 3) != sizeof (a.a) - 9)\n+#endif\n     abort ();\n   if (x < 6)\n     r = &w[2].a[1];\n@@ -55,31 +60,57 @@ test1 (void *q, int x)\n     abort ();\n   if (__builtin_object_size (&y.b, 3) != sizeof (a.b))\n     abort ();\n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (r, 3)\n+      != (x < 6 ? sizeof (w[2].a) - 1 : sizeof (a.a) - 6))\n+#else\n   if (__builtin_object_size (r, 3) != sizeof (a.a) - 6)\n+#endif\n     abort ();\n   if (x < 20)\n     r = malloc (30);\n   else\n     r = calloc (2, 16);\n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (r, 3) != (x < 20 ? 30 : 2 * 16))\n+#else\n   if (__builtin_object_size (r, 3) != 30)\n+#endif\n     abort ();\n   if (x < 20)\n     r = malloc (30);\n   else\n     r = calloc (2, 14);\n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (r, 3) != (x < 20 ? 30 : 2 * 14))\n+#else\n   if (__builtin_object_size (r, 3) != 2 * 14)\n+#endif\n     abort ();\n   if (x < 30)\n     r = malloc (sizeof (a));\n   else\n     r = &a.a[3];\n+#ifdef __builtin_object_size\n+  size_t objsz = x < 30 ? sizeof (a) : sizeof (a.a) - 3;\n+  if (__builtin_object_size (r, 3) != objsz)\n+#else\n   if (__builtin_object_size (r, 3) != sizeof (a.a) - 3)\n+#endif\n     abort ();\n   r = memcpy (r, \"a\", 2);\n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (r, 3) != objsz)\n+#else\n   if (__builtin_object_size (r, 3) != sizeof (a.a) - 3)\n+#endif\n     abort ();\n   r = memcpy (r + 2, \"b\", 2) + 2;\n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (r, 3) != objsz - 4)\n+#else\n   if (__builtin_object_size (r, 3) != sizeof (a.a) - 3 - 4)\n+#endif\n     abort ();\n   r = &a.a[4];\n   r = memset (r, 'a', 2);\n@@ -184,6 +215,9 @@ test2 (void)\n   struct B { char buf1[10]; char buf2[10]; } a;\n   char *r, buf3[20];\n   int i;\n+#ifdef __builtin_object_size\n+  size_t dyn_res = 0;\n+#endif\n \n   if (sizeof (a) != 20)\n     return;\n@@ -228,13 +262,38 @@ test2 (void)\n       else if (i == l1 + 2)\n \tr = &a.buf1[2];\n     }\n+#ifdef __builtin_object_size\n+  dyn_res = sizeof (buf3) - 1;\n+\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+        dyn_res = sizeof (a.buf1) - 6;\n+      else if (i == l1)\n+        dyn_res = sizeof (a.buf2) - 4;\n+      else if (i == l1 + 1)\n+        dyn_res = sizeof (buf3) - 5;\n+      else if (i == l1 + 2)\n+        dyn_res = sizeof (a.buf1) - 2;\n+    }\n+  if (__builtin_object_size (r, 3) != dyn_res)\n+    abort ();\n+#else\n   if (__builtin_object_size (r, 3) != sizeof (a.buf1) - 6)\n     abort ();\n+#endif\n   r += 2;\n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (r, 3) != dyn_res - 2)\n+    abort ();\n+  if (__builtin_object_size (r + 1, 3) != dyn_res - 3)\n+    abort ();\n+#else\n   if (__builtin_object_size (r, 3) != sizeof (a.buf1) - 6 - 2)\n     abort ();\n   if (__builtin_object_size (r + 1, 3) != sizeof (a.buf1) - 6 - 3)\n     abort ();\n+#endif\n }\n \n void\n@@ -352,7 +411,11 @@ test5 (size_t x)\n \n   for (i = 0; i < x; ++i)\n     p = p + 4;\n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (p, 3) != sizeof (t.buf) - 8 - 4 * x)\n+#else\n   if (__builtin_object_size (p, 3) != 0)\n+#endif\n     abort ();\n   memset (p, ' ', sizeof (t.buf) - 8 - 4 * 4);\n }\n@@ -407,21 +470,36 @@ test8 (unsigned cond)\n   else\n     p = &buf2[4];\n \n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (&p[-4], 3) != (cond ? 6 : 10))\n+    abort ();\n+#else\n   if (__builtin_object_size (&p[-4], 3) != 6)\n     abort ();\n+#endif\n \n   for (unsigned i = cond; i > 0; i--)\n     p--;\n \n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (p, 3) != ((cond ? 2 : 6) + cond))\n+    abort ();\n+#else\n   if (__builtin_object_size (p, 3) != 2)\n     abort ();\n+#endif\n \n   p = &y.c[8];\n   for (unsigned i = cond; i > 0; i--)\n     p--;\n \n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (p, 3) != sizeof (y.c) - 8 + cond)\n+    abort ();\n+#else\n   if (__builtin_object_size (p, 3) != sizeof (y.c) - 8)\n     abort ();\n+#endif\n }\n \n int"}, {"sha": "cb8f753b03936ca949e5f1b9ba3ecbecfb15da3c", "filename": "gcc/testsuite/gcc.dg/builtin-object-size-5.c", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/404c787e2bfe8cae666b075ed903990ea452220e/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/404c787e2bfe8cae666b075ed903990ea452220e/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-5.c?ref=404c787e2bfe8cae666b075ed903990ea452220e", "patch": "@@ -1,9 +1,13 @@\n /* { dg-do compile { target i?86-*-linux* i?86-*-gnu* x86_64-*-linux* } } */\n /* { dg-options \"-O2\" } */\n \n+#ifndef N\n+# define N 0x40000000\n+#endif\n+\n typedef __SIZE_TYPE__ size_t;\n extern void abort (void);\n-extern char buf[0x40000000];\n+extern char buf[N];\n \n void\n test1 (size_t x)\n@@ -13,7 +17,11 @@ test1 (size_t x)\n \n   for (i = 0; i < x; ++i)\n     p = p + 4;\n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (p, 0) != sizeof (buf) - 8 - 4 * x)\n+#else\n   if (__builtin_object_size (p, 0) != sizeof (buf) - 8)\n+#endif\n     abort ();\n }\n \n@@ -25,7 +33,11 @@ test2 (size_t x)\n \n   for (i = 0; i < x; ++i)\n     p = p + 4;\n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (p, 1) != sizeof (buf) - 8 - 4 * x)\n+#else\n   if (__builtin_object_size (p, 1) != sizeof (buf) - 8)\n+#endif\n     abort ();\n }\n \n@@ -37,7 +49,11 @@ test3 (size_t x)\n \n   for (i = 0; i < x; ++i)\n     p = p + 4;\n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (p, 2) != sizeof (buf) - 8 - 4 * x)\n+#else\n   if (__builtin_object_size (p, 2) != 0)\n+#endif\n     abort ();\n }\n \n@@ -49,7 +65,11 @@ test4 (size_t x)\n \n   for (i = 0; i < x; ++i)\n     p = p + 4;\n+#ifdef __builtin_object_size\n+  if (__builtin_object_size (p, 3) != sizeof (buf) - 8 - 4 * x)\n+#else\n   if (__builtin_object_size (p, 3) != 0)\n+#endif\n     abort ();\n }\n "}, {"sha": "a2df4a2af0af4707d39479a9bf4ab9b6fd33ede8", "filename": "gcc/tree-object-size.c", "status": "modified", "additions": 494, "deletions": 27, "changes": 521, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/404c787e2bfe8cae666b075ed903990ea452220e/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/404c787e2bfe8cae666b075ed903990ea452220e/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=404c787e2bfe8cae666b075ed903990ea452220e", "patch": "@@ -35,13 +35,14 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"builtins.h\"\n+#include \"gimplify-me.h\"\n \n struct object_size_info\n {\n   int object_size_type;\n   unsigned char pass;\n   bool changed;\n-  bitmap visited, reexamine;\n+  bitmap visited, reexamine, unknowns;\n   unsigned int *depths;\n   unsigned int *stack, *tos;\n };\n@@ -74,7 +75,11 @@ static void check_for_plus_in_loops_1 (struct object_size_info *, tree,\n    object_sizes[1] is upper bound for the object size and number of bytes till\n    the end of the subobject (innermost array or field with address taken).\n    object_sizes[2] is lower bound for the object size and number of bytes till\n-   the end of the object and object_sizes[3] lower bound for subobject.  */\n+   the end of the object and object_sizes[3] lower bound for subobject.\n+\n+   For static object sizes, the object size and the bytes till the end of the\n+   object are both INTEGER_CST.  In the dynamic case, they are finally either a\n+   gimple variable or an INTEGER_CST.  */\n static vec<object_size> object_sizes[OST_END];\n \n /* Bitmaps what object sizes have been computed already.  */\n@@ -83,7 +88,16 @@ static bitmap computed[OST_END];\n /* Maximum value of offset we consider to be addition.  */\n static unsigned HOST_WIDE_INT offset_limit;\n \n-/* Return true if VAL is represents an unknown size for OBJECT_SIZE_TYPE.  */\n+/* Return true if VAL represents an initial size for OBJECT_SIZE_TYPE.  */\n+\n+static inline bool\n+size_initval_p (tree val, int object_size_type)\n+{\n+  return ((object_size_type & OST_MINIMUM)\n+\t  ? integer_all_onesp (val) : integer_zerop (val));\n+}\n+\n+/* Return true if VAL represents an unknown size for OBJECT_SIZE_TYPE.  */\n \n static inline bool\n size_unknown_p (tree val, int object_size_type)\n@@ -92,6 +106,15 @@ size_unknown_p (tree val, int object_size_type)\n \t  ? integer_zerop (val) : integer_all_onesp (val));\n }\n \n+/* Return true if VAL is usable as an object size in the object_sizes\n+   vectors.  */\n+\n+static inline bool\n+size_usable_p (tree val)\n+{\n+  return TREE_CODE (val) == SSA_NAME || TREE_CODE (val) == INTEGER_CST;\n+}\n+\n /* Return a tree with initial value for OBJECT_SIZE_TYPE.  */\n \n static inline tree\n@@ -136,17 +159,43 @@ object_sizes_unknown_p (int object_size_type, unsigned varno)\n \t\t\t object_size_type);\n }\n \n-/* Return size for VARNO corresponding to OSI.  If WHOLE is true, return the\n-   whole object size.  */\n+/* Return the raw size expression for VARNO corresponding to OSI.  This returns\n+   the TREE_VEC as is and should only be used during gimplification.  */\n+\n+static inline object_size\n+object_sizes_get_raw (struct object_size_info *osi, unsigned varno)\n+{\n+  gcc_assert (osi->pass != 0);\n+  return object_sizes[osi->object_size_type][varno];\n+}\n+\n+/* Return a size tree for VARNO corresponding to OSI.  If WHOLE is true, return\n+   the whole object size.  Use this for building size expressions based on size\n+   of VARNO.  */\n \n static inline tree\n object_sizes_get (struct object_size_info *osi, unsigned varno,\n \t\t  bool whole = false)\n {\n+  tree ret;\n+  int object_size_type = osi->object_size_type;\n+\n   if (whole)\n-    return object_sizes[osi->object_size_type][varno].wholesize;\n+    ret = object_sizes[object_size_type][varno].wholesize;\n   else\n-    return object_sizes[osi->object_size_type][varno].size;\n+    ret = object_sizes[object_size_type][varno].size;\n+\n+  if (object_size_type & OST_DYNAMIC)\n+    {\n+      if (TREE_CODE (ret) == MODIFY_EXPR)\n+\treturn TREE_OPERAND (ret, 0);\n+      else if (TREE_CODE (ret) == TREE_VEC)\n+\treturn TREE_VEC_ELT (ret, TREE_VEC_LENGTH (ret) - 1);\n+      else\n+\tgcc_checking_assert (size_usable_p (ret));\n+    }\n+\n+  return ret;\n }\n \n /* Set size for VARNO corresponding to OSI to VAL.  */\n@@ -161,28 +210,116 @@ object_sizes_initialize (struct object_size_info *osi, unsigned varno,\n   object_sizes[object_size_type][varno].wholesize = wholeval;\n }\n \n+/* Return a MODIFY_EXPR for cases where SSA and EXPR have the same type.  The\n+   TREE_VEC is returned only in case of PHI nodes.  */\n+\n+static tree\n+bundle_sizes (tree name, tree expr)\n+{\n+  gcc_checking_assert (TREE_TYPE (name) == sizetype);\n+\n+  if (TREE_CODE (expr) == TREE_VEC)\n+    {\n+      TREE_VEC_ELT (expr, TREE_VEC_LENGTH (expr) - 1) = name;\n+      return expr;\n+    }\n+\n+  gcc_checking_assert (types_compatible_p (TREE_TYPE (expr), sizetype));\n+  return build2 (MODIFY_EXPR, sizetype, name, expr);\n+}\n+\n /* Set size for VARNO corresponding to OSI to VAL if it is the new minimum or\n-   maximum.  */\n+   maximum.  For static sizes, each element of TREE_VEC is always INTEGER_CST\n+   throughout the computation.  For dynamic sizes, each element may either be a\n+   gimple variable, a MODIFY_EXPR or a TREE_VEC.  The MODIFY_EXPR is for\n+   expressions that need to be gimplified.  TREE_VECs are special, they're\n+   emitted only for GIMPLE_PHI and the PHI result variable is the last element\n+   of the vector.  */\n \n-static inline bool\n+static bool\n object_sizes_set (struct object_size_info *osi, unsigned varno, tree val,\n \t\t  tree wholeval)\n {\n   int object_size_type = osi->object_size_type;\n   object_size osize = object_sizes[object_size_type][varno];\n+  bool changed = true;\n \n   tree oldval = osize.size;\n   tree old_wholeval = osize.wholesize;\n \n-  enum tree_code code = object_size_type & OST_MINIMUM ? MIN_EXPR : MAX_EXPR;\n+  if (object_size_type & OST_DYNAMIC)\n+    {\n+      if (bitmap_bit_p (osi->reexamine, varno))\n+\t{\n+\t  if (size_unknown_p (val, object_size_type))\n+\t    {\n+\t      oldval = object_sizes_get (osi, varno);\n+\t      old_wholeval = object_sizes_get (osi, varno, true);\n+\t      bitmap_set_bit (osi->unknowns, SSA_NAME_VERSION (oldval));\n+\t      bitmap_set_bit (osi->unknowns, SSA_NAME_VERSION (old_wholeval));\n+\t      bitmap_clear_bit (osi->reexamine, varno);\n+\t    }\n+\t  else\n+\t    {\n+\t      val = bundle_sizes (oldval, val);\n+\t      wholeval = bundle_sizes (old_wholeval, wholeval);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  gcc_checking_assert (size_initval_p (oldval, object_size_type));\n+\t  gcc_checking_assert (size_initval_p (old_wholeval,\n+\t\t\t\t\t       object_size_type));\n+\t  /* For dynamic object sizes, all object sizes that are not gimple\n+\t     variables will need to be gimplified.  */\n+\t  if (wholeval != val && !size_usable_p (wholeval))\n+\t    {\n+\t      bitmap_set_bit (osi->reexamine, varno);\n+\t      wholeval = bundle_sizes (make_ssa_name (sizetype), wholeval);\n+\t    }\n+\t  if (!size_usable_p (val))\n+\t    {\n+\t      bitmap_set_bit (osi->reexamine, varno);\n+\t      tree newval = bundle_sizes (make_ssa_name (sizetype), val);\n+\t      if (val == wholeval)\n+\t\twholeval = newval;\n+\t      val = newval;\n+\t    }\n+\t  /* If the new value is a temporary variable, mark it for\n+\t     reexamination.  */\n+\t  else if (TREE_CODE (val) == SSA_NAME && !SSA_NAME_DEF_STMT (val))\n+\t    bitmap_set_bit (osi->reexamine, varno);\n+\t}\n+    }\n+  else\n+    {\n+      enum tree_code code = (object_size_type & OST_MINIMUM\n+\t\t\t     ? MIN_EXPR : MAX_EXPR);\n \n-  val = size_binop (code, val, oldval);\n-  wholeval = size_binop (code, wholeval, old_wholeval);\n+      val = size_binop (code, val, oldval);\n+      wholeval = size_binop (code, wholeval, old_wholeval);\n+      changed = (tree_int_cst_compare (val, oldval) != 0\n+\t\t || tree_int_cst_compare (old_wholeval, wholeval) != 0);\n+    }\n \n   object_sizes[object_size_type][varno].size = val;\n   object_sizes[object_size_type][varno].wholesize = wholeval;\n-  return (tree_int_cst_compare (oldval, val) != 0\n-\t  || tree_int_cst_compare (old_wholeval, wholeval) != 0);\n+\n+  return changed;\n+}\n+\n+/* Set temporary SSA names for object size and whole size to resolve dependency\n+   loops in dynamic size computation.  */\n+\n+static inline void\n+object_sizes_set_temp (struct object_size_info *osi, unsigned varno)\n+{\n+  tree val = object_sizes_get (osi, varno);\n+\n+  if (size_initval_p (val, osi->object_size_type))\n+    object_sizes_set (osi, varno,\n+\t\t      make_ssa_name (sizetype),\n+\t\t      make_ssa_name (sizetype));\n }\n \n /* Initialize OFFSET_LIMIT variable.  */\n@@ -204,14 +341,15 @@ static tree\n size_for_offset (tree sz, tree offset, tree wholesize = NULL_TREE)\n {\n   gcc_checking_assert (TREE_CODE (offset) == INTEGER_CST);\n-  gcc_checking_assert (TREE_CODE (sz) == INTEGER_CST);\n   gcc_checking_assert (types_compatible_p (TREE_TYPE (sz), sizetype));\n \n   /* For negative offsets, if we have a distinct WHOLESIZE, use it to get a net\n      offset from the whole object.  */\n-  if (wholesize && tree_int_cst_compare (sz, wholesize))\n+  if (wholesize && wholesize != sz\n+      && (TREE_CODE (sz) != INTEGER_CST\n+\t  || TREE_CODE (wholesize) != INTEGER_CST\n+\t  || tree_int_cst_compare (sz, wholesize)))\n     {\n-      gcc_checking_assert (TREE_CODE (wholesize) == INTEGER_CST);\n       gcc_checking_assert (types_compatible_p (TREE_TYPE (wholesize),\n \t\t\t\t\t       sizetype));\n \n@@ -228,13 +366,16 @@ size_for_offset (tree sz, tree offset, tree wholesize = NULL_TREE)\n   if (!types_compatible_p (TREE_TYPE (offset), sizetype))\n     fold_convert (sizetype, offset);\n \n-  if (integer_zerop (offset))\n-    return sz;\n+  if (TREE_CODE (offset) == INTEGER_CST)\n+    {\n+      if (integer_zerop (offset))\n+\treturn sz;\n \n-  /* Negative or too large offset even after adjustment, cannot be within\n-     bounds of an object.  */\n-  if (compare_tree_int (offset, offset_limit) > 0)\n-    return size_zero_node;\n+      /* Negative or too large offset even after adjustment, cannot be within\n+\t bounds of an object.  */\n+      if (compare_tree_int (offset, offset_limit) > 0)\n+\treturn size_zero_node;\n+    }\n \n   return size_binop (MINUS_EXPR, size_binop (MAX_EXPR, sz, offset), offset);\n }\n@@ -671,6 +812,201 @@ pass_through_call (const gcall *call)\n   return NULL_TREE;\n }\n \n+/* Emit PHI nodes for size expressions fo.  */\n+\n+static void\n+emit_phi_nodes (gimple *stmt, tree size, tree wholesize)\n+{\n+  tree phires;\n+  gphi *wholephi = NULL;\n+\n+  if (wholesize != size)\n+    {\n+      phires = TREE_VEC_ELT (wholesize, TREE_VEC_LENGTH (wholesize) - 1);\n+      wholephi = create_phi_node (phires, gimple_bb (stmt));\n+    }\n+\n+  phires = TREE_VEC_ELT (size, TREE_VEC_LENGTH (size) - 1);\n+  gphi *phi = create_phi_node (phires, gimple_bb (stmt));\n+  gphi *obj_phi = as_a <gphi *> (stmt);\n+\n+  gcc_checking_assert (TREE_CODE (wholesize) == TREE_VEC);\n+  gcc_checking_assert (TREE_CODE (size) == TREE_VEC);\n+\n+  for (unsigned i = 0; i < gimple_phi_num_args (stmt); i++)\n+    {\n+      gimple_seq seq = NULL;\n+      tree wsz = TREE_VEC_ELT (wholesize, i);\n+      tree sz = TREE_VEC_ELT (size, i);\n+\n+      /* If we built an expression, we will need to build statements\n+\t and insert them on the edge right away.  */\n+      if (TREE_CODE (wsz) != SSA_NAME)\n+\twsz = force_gimple_operand (wsz, &seq, true, NULL);\n+      if (TREE_CODE (sz) != SSA_NAME)\n+\t{\n+\t  gimple_seq s;\n+\t  sz = force_gimple_operand (sz, &s, true, NULL);\n+\t  gimple_seq_add_seq (&seq, s);\n+\t}\n+\n+      if (seq)\n+\tgsi_insert_seq_on_edge (gimple_phi_arg_edge (obj_phi, i), seq);\n+\n+      if (wholephi)\n+\tadd_phi_arg (wholephi, wsz,\n+\t\t     gimple_phi_arg_edge (obj_phi, i),\n+\t\t     gimple_phi_arg_location (obj_phi, i));\n+\n+      add_phi_arg (phi, sz,\n+\t\t   gimple_phi_arg_edge (obj_phi, i),\n+\t\t   gimple_phi_arg_location (obj_phi, i));\n+    }\n+}\n+\n+/* Descend through EXPR and return size_unknown if it uses any SSA variable\n+   object_size_set or object_size_set_temp generated, which turned out to be\n+   size_unknown, as noted in UNKNOWNS.  */\n+\n+static tree\n+propagate_unknowns (object_size_info *osi, tree expr)\n+{\n+  int object_size_type = osi->object_size_type;\n+\n+  switch (TREE_CODE (expr))\n+    {\n+    case SSA_NAME:\n+      if (bitmap_bit_p (osi->unknowns, SSA_NAME_VERSION (expr)))\n+\treturn size_unknown (object_size_type);\n+      return expr;\n+\n+    case MIN_EXPR:\n+    case MAX_EXPR:\n+\t{\n+\t  tree res = propagate_unknowns (osi, TREE_OPERAND (expr, 0));\n+\t  if (size_unknown_p (res, object_size_type))\n+\t    return res;\n+\n+\t  res = propagate_unknowns (osi, TREE_OPERAND (expr, 1));\n+\t  if (size_unknown_p (res, object_size_type))\n+\t    return res;\n+\n+\t  return expr;\n+\t}\n+    case MODIFY_EXPR:\n+\t{\n+\t  tree res = propagate_unknowns (osi, TREE_OPERAND (expr, 1));\n+\t  if (size_unknown_p (res, object_size_type))\n+\t    return res;\n+\t  return expr;\n+\t}\n+    case TREE_VEC:\n+      for (int i = 0; i < TREE_VEC_LENGTH (expr); i++)\n+\t{\n+\t  tree res = propagate_unknowns (osi, TREE_VEC_ELT (expr, i));\n+\t  if (size_unknown_p (res, object_size_type))\n+\t    return res;\n+\t}\n+      return expr;\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+\t{\n+\t  tree res = propagate_unknowns (osi, TREE_OPERAND (expr, 0));\n+\t  if (size_unknown_p (res, object_size_type))\n+\t    return res;\n+\n+\t  return expr;\n+\t}\n+    default:\n+      return expr;\n+    }\n+}\n+\n+/* Walk through size expressions that need reexamination and generate\n+   statements for them.  */\n+\n+static void\n+gimplify_size_expressions (object_size_info *osi)\n+{\n+  int object_size_type = osi->object_size_type;\n+  bitmap_iterator bi;\n+  unsigned int i;\n+  bool changed;\n+\n+  /* Step 1: Propagate unknowns into expressions.  */\n+  bitmap reexamine = BITMAP_ALLOC (NULL);\n+  bitmap_copy (reexamine, osi->reexamine);\n+  do\n+    {\n+      changed = false;\n+      EXECUTE_IF_SET_IN_BITMAP (reexamine, 0, i, bi)\n+\t{\n+\t  object_size cur = object_sizes_get_raw (osi, i);\n+\n+\t  if (size_unknown_p (propagate_unknowns (osi, cur.size),\n+\t\t\t      object_size_type)\n+\t      || size_unknown_p (propagate_unknowns (osi, cur.wholesize),\n+\t\t\t\t object_size_type))\n+\t    {\n+\t      object_sizes_set (osi, i,\n+\t\t\t\tsize_unknown (object_size_type),\n+\t\t\t\tsize_unknown (object_size_type));\n+\t      changed = true;\n+\t    }\n+\t}\n+      bitmap_copy (reexamine, osi->reexamine);\n+    }\n+  while (changed);\n+\n+  /* Release all unknowns.  */\n+  EXECUTE_IF_SET_IN_BITMAP (osi->unknowns, 0, i, bi)\n+    release_ssa_name (ssa_name (i));\n+\n+  /* Expand all size expressions to put their definitions close to the objects\n+     for which size is being computed.  */\n+  EXECUTE_IF_SET_IN_BITMAP (osi->reexamine, 0, i, bi)\n+    {\n+      gimple_seq seq = NULL;\n+      object_size osize = object_sizes_get_raw (osi, i);\n+\n+      gimple *stmt = SSA_NAME_DEF_STMT (ssa_name (i));\n+      enum gimple_code code = gimple_code (stmt);\n+\n+      /* PHI nodes need special attention.  */\n+      if (code == GIMPLE_PHI)\n+\temit_phi_nodes (stmt, osize.size, osize.wholesize);\n+      else\n+\t{\n+\t  tree size_expr = NULL_TREE;\n+\n+\t  /* Bundle wholesize in with the size to gimplify if needed.  */\n+\t  if (osize.wholesize != osize.size\n+\t      && !size_usable_p (osize.wholesize))\n+\t    size_expr = size_binop (COMPOUND_EXPR,\n+\t\t\t\t    osize.wholesize,\n+\t\t\t\t    osize.size);\n+\t  else if (!size_usable_p (osize.size))\n+\t    size_expr = osize.size;\n+\n+\t  if (size_expr)\n+\t    {\n+\t      gimple_stmt_iterator gsi;\n+\t      if (code == GIMPLE_NOP)\n+\t\tgsi = gsi_start_bb (single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n+\t      else\n+\t\tgsi = gsi_for_stmt (stmt);\n+\n+\t      force_gimple_operand (size_expr, &seq, true, NULL);\n+\t      gsi_insert_seq_before (&gsi, seq, GSI_CONTINUE_LINKING);\n+\t    }\n+\t}\n+\n+      /* We're done, so replace the MODIFY_EXPRs with the SSA names.  */\n+      object_sizes_initialize (osi, i,\n+\t\t\t       object_sizes_get (osi, i),\n+\t\t\t       object_sizes_get (osi, i, true));\n+    }\n+}\n \n /* Compute __builtin_object_size value for PTR and set *PSIZE to\n    the resulting value.  If the declared object is known and PDECL\n@@ -749,9 +1085,15 @@ compute_builtin_object_size (tree ptr, int object_size_type,\n \n       osi.visited = BITMAP_ALLOC (NULL);\n       osi.reexamine = BITMAP_ALLOC (NULL);\n-      osi.depths = NULL;\n-      osi.stack = NULL;\n-      osi.tos = NULL;\n+\n+      if (object_size_type & OST_DYNAMIC)\n+\tosi.unknowns = BITMAP_ALLOC (NULL);\n+      else\n+\t{\n+\t  osi.depths = NULL;\n+\t  osi.stack = NULL;\n+\t  osi.tos = NULL;\n+\t}\n \n       /* First pass: walk UD chains, compute object sizes that\n \t can be computed.  osi.reexamine bitmap at the end will\n@@ -761,6 +1103,14 @@ compute_builtin_object_size (tree ptr, int object_size_type,\n       osi.changed = false;\n       collect_object_sizes_for (&osi, ptr);\n \n+      if (object_size_type & OST_DYNAMIC)\n+\t{\n+\t  osi.pass = 1;\n+\t  gimplify_size_expressions (&osi);\n+\t  BITMAP_FREE (osi.unknowns);\n+\t  bitmap_clear (osi.reexamine);\n+\t}\n+\n       /* Second pass: keep recomputing object sizes of variables\n \t that need reexamination, until no object sizes are\n \t increased or all object sizes are computed.  */\n@@ -1004,6 +1354,28 @@ plus_stmt_object_size (struct object_size_info *osi, tree var, gimple *stmt)\n   return reexamine;\n }\n \n+/* Compute the dynamic object size for VAR.  Return the result in SIZE and\n+   WHOLESIZE.  */\n+\n+static void\n+dynamic_object_size (struct object_size_info *osi, tree var,\n+\t\t     tree *size, tree *wholesize)\n+{\n+  int object_size_type = osi->object_size_type;\n+\n+  if (TREE_CODE (var) == SSA_NAME)\n+    {\n+      unsigned varno = SSA_NAME_VERSION (var);\n+\n+      collect_object_sizes_for (osi, var);\n+      *size = object_sizes_get (osi, varno);\n+      *wholesize = object_sizes_get (osi, varno, true);\n+    }\n+  else if (TREE_CODE (var) == ADDR_EXPR)\n+    addr_object_size (osi, var, object_size_type, size, wholesize);\n+  else\n+    *size = *wholesize = size_unknown (object_size_type);\n+}\n \n /* Compute object_sizes for VAR, defined at STMT, which is\n    a COND_EXPR.  Return true if the object size might need reexamination\n@@ -1025,6 +1397,33 @@ cond_expr_object_size (struct object_size_info *osi, tree var, gimple *stmt)\n   then_ = gimple_assign_rhs2 (stmt);\n   else_ = gimple_assign_rhs3 (stmt);\n \n+  if (object_size_type & OST_DYNAMIC)\n+    {\n+      tree then_size, then_wholesize, else_size, else_wholesize;\n+\n+      dynamic_object_size (osi, then_, &then_size, &then_wholesize);\n+      if (!size_unknown_p (then_size, object_size_type))\n+\tdynamic_object_size (osi, else_, &else_size, &else_wholesize);\n+\n+      tree cond_size, cond_wholesize;\n+      if (size_unknown_p (then_size, object_size_type)\n+\t  || size_unknown_p (else_size, object_size_type))\n+\tcond_size = cond_wholesize = size_unknown (object_size_type);\n+      else\n+\t{\n+\t  cond_size = fold_build3 (COND_EXPR, sizetype,\n+\t\t\t\t   gimple_assign_rhs1 (stmt),\n+\t\t\t\t   then_size, else_size);\n+\t  cond_wholesize = fold_build3 (COND_EXPR, sizetype,\n+\t\t\t\t\tgimple_assign_rhs1 (stmt),\n+\t\t\t\t\tthen_wholesize, else_wholesize);\n+\t}\n+\n+      object_sizes_set (osi, varno, cond_size, cond_wholesize);\n+\n+      return false;\n+    }\n+\n   if (TREE_CODE (then_) == SSA_NAME)\n     reexamine |= merge_object_sizes (osi, var, then_);\n   else\n@@ -1041,6 +1440,64 @@ cond_expr_object_size (struct object_size_info *osi, tree var, gimple *stmt)\n   return reexamine;\n }\n \n+/* Compute an object size expression for VAR, which is the result of a PHI\n+   node.  */\n+\n+static void\n+phi_dynamic_object_size (struct object_size_info *osi, tree var)\n+{\n+  int object_size_type = osi->object_size_type;\n+  unsigned int varno = SSA_NAME_VERSION (var);\n+  gimple *stmt = SSA_NAME_DEF_STMT (var);\n+  unsigned i, num_args = gimple_phi_num_args (stmt);\n+  bool wholesize_needed = false;\n+\n+  /* The extra space is for the PHI result at the end, which object_sizes_set\n+     sets for us.  */\n+  tree sizes = make_tree_vec (num_args + 1);\n+  tree wholesizes = make_tree_vec (num_args + 1);\n+\n+  /* Bail out if the size of any of the PHI arguments cannot be\n+     determined.  */\n+  for (i = 0; i < num_args; i++)\n+    {\n+      edge e = gimple_phi_arg_edge (as_a <gphi *> (stmt), i);\n+      if (e->flags & EDGE_COMPLEX)\n+\tbreak;\n+\n+      tree rhs = gimple_phi_arg_def (stmt, i);\n+      tree size, wholesize;\n+\n+      dynamic_object_size (osi, rhs, &size, &wholesize);\n+\n+      if (size_unknown_p (size, object_size_type))\n+       break;\n+\n+      if (size != wholesize)\n+\twholesize_needed = true;\n+\n+      TREE_VEC_ELT (sizes, i) = size;\n+      TREE_VEC_ELT (wholesizes, i) = wholesize;\n+    }\n+\n+  if (i < num_args)\n+    {\n+      ggc_free (sizes);\n+      ggc_free (wholesizes);\n+      sizes = wholesizes = size_unknown (object_size_type);\n+    }\n+\n+  /* Point to the same TREE_VEC so that we can avoid emitting two PHI\n+     nodes.  */\n+  else if (!wholesize_needed)\n+    {\n+      ggc_free (wholesizes);\n+      wholesizes = sizes;\n+    }\n+\n+  object_sizes_set (osi, varno, sizes, wholesizes);\n+}\n+\n /* Compute object sizes for VAR.\n    For ADDR_EXPR an object size is the number of remaining bytes\n    to the end of the object (where what is considered an object depends on\n@@ -1086,6 +1543,9 @@ collect_object_sizes_for (struct object_size_info *osi, tree var)\n \t{\n \t  /* Found a dependency loop.  Mark the variable for later\n \t     re-examination.  */\n+\t  if (object_size_type & OST_DYNAMIC)\n+\t    object_sizes_set_temp (osi, varno);\n+\n \t  bitmap_set_bit (osi->reexamine, varno);\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n@@ -1167,6 +1627,12 @@ collect_object_sizes_for (struct object_size_info *osi, tree var)\n       {\n \tunsigned i;\n \n+\tif (object_size_type & OST_DYNAMIC)\n+\t  {\n+\t    phi_dynamic_object_size (osi, var);\n+\t    break;\n+\t  }\n+\n \tfor (i = 0; i < gimple_phi_num_args (stmt); i++)\n \t  {\n \t    tree rhs = gimple_phi_arg (stmt, i)->def;\n@@ -1189,7 +1655,8 @@ collect_object_sizes_for (struct object_size_info *osi, tree var)\n   if (! reexamine || object_sizes_unknown_p (object_size_type, varno))\n     {\n       bitmap_set_bit (computed[object_size_type], varno);\n-      bitmap_clear_bit (osi->reexamine, varno);\n+      if (!(object_size_type & OST_DYNAMIC))\n+\tbitmap_clear_bit (osi->reexamine, varno);\n     }\n   else\n     {"}]}