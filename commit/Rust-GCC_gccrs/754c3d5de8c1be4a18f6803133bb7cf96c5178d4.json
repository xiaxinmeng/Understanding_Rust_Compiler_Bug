{"sha": "754c3d5de8c1be4a18f6803133bb7cf96c5178d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzU0YzNkNWRlOGMxYmU0YTE4ZjY4MDMxMzNiYjdjZjk2YzUxNzhkNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2011-07-19T17:44:58Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-07-19T17:44:58Z"}, "message": "rtl.h (mem_attrs): Turn offset and size fields into HOST_WIDE_INTs.\n\ngcc/\n\t* rtl.h (mem_attrs): Turn offset and size fields into HOST_WIDE_INTs.\n\tAdd offset_known_p and size_known_p fields.\n\t(MEM_OFFSET_KNOWN_P): Update accordingly.\n\t(MEM_OFFSET, MEM_SIZE_KNOWN_P, MEM_SIZE): Likewise.\n\t* emit-rtl.c (mem_attrs_htab_hash): Update after mem_attrs changes.\n\t(mem_attrs_eq_p, set_mem_attributes_minus_bitpos, set_mem_offset)\n\t(clear_mem_offset, set_mem_size, clear_mem_size, change_address)\n\t(adjust_address_1, widen_memory_access, set_mem_attrs_for_spill)\n\t(init_emit_regs): Likewise.\n\nFrom-SVN: r176478", "tree": {"sha": "d5541d2f60d952f830fd9c2da9eeb264480a0d0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5541d2f60d952f830fd9c2da9eeb264480a0d0f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/754c3d5de8c1be4a18f6803133bb7cf96c5178d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/754c3d5de8c1be4a18f6803133bb7cf96c5178d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/754c3d5de8c1be4a18f6803133bb7cf96c5178d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/754c3d5de8c1be4a18f6803133bb7cf96c5178d4/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "527210c448c692264cebb61acf3a2c6aef3073ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/527210c448c692264cebb61acf3a2c6aef3073ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/527210c448c692264cebb61acf3a2c6aef3073ad"}], "stats": {"total": 188, "additions": 124, "deletions": 64}, "files": [{"sha": "992486da4e1f9a207170d9e234d460988142ce64", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754c3d5de8c1be4a18f6803133bb7cf96c5178d4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754c3d5de8c1be4a18f6803133bb7cf96c5178d4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=754c3d5de8c1be4a18f6803133bb7cf96c5178d4", "patch": "@@ -1,3 +1,15 @@\n+2011-07-19  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* rtl.h (mem_attrs): Turn offset and size fields into HOST_WIDE_INTs.\n+\tAdd offset_known_p and size_known_p fields.\n+\t(MEM_OFFSET_KNOWN_P): Update accordingly.\n+\t(MEM_OFFSET, MEM_SIZE_KNOWN_P, MEM_SIZE): Likewise.\n+\t* emit-rtl.c (mem_attrs_htab_hash): Update after mem_attrs changes.\n+\t(mem_attrs_eq_p, set_mem_attributes_minus_bitpos, set_mem_offset)\n+\t(clear_mem_offset, set_mem_size, clear_mem_size, change_address)\n+\t(adjust_address_1, widen_memory_access, set_mem_attrs_for_spill)\n+\t(init_emit_regs): Likewise.\n+\n 2011-07-19  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* doc/rtl.texi (MEM_OFFSET_KNOWN_P): Document."}, {"sha": "c34e6d52ad4639096fb7a43466fa5dd397f92d73", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 78, "deletions": 49, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754c3d5de8c1be4a18f6803133bb7cf96c5178d4/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754c3d5de8c1be4a18f6803133bb7cf96c5178d4/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=754c3d5de8c1be4a18f6803133bb7cf96c5178d4", "patch": "@@ -256,8 +256,8 @@ mem_attrs_htab_hash (const void *x)\n \n   return (p->alias ^ (p->align * 1000)\n \t  ^ (p->addrspace * 4000)\n-\t  ^ ((p->offset ? INTVAL (p->offset) : 0) * 50000)\n-\t  ^ ((p->size ? INTVAL (p->size) : 0) * 2500000)\n+\t  ^ ((p->offset_known_p ? p->offset : 0) * 50000)\n+\t  ^ ((p->size_known_p ? p->size : 0) * 2500000)\n \t  ^ (size_t) iterative_hash_expr (p->expr, 0));\n }\n \n@@ -266,8 +266,12 @@ mem_attrs_htab_hash (const void *x)\n static bool\n mem_attrs_eq_p (const struct mem_attrs *p, const struct mem_attrs *q)\n {\n-  return (p->alias == q->alias && p->offset == q->offset\n-\t  && p->size == q->size && p->align == q->align\n+  return (p->alias == q->alias\n+\t  && p->offset_known_p == q->offset_known_p\n+\t  && (!p->offset_known_p || p->offset == q->offset)\n+\t  && p->size_known_p == q->size_known_p\n+\t  && (!p->size_known_p || p->size == q->size)\n+\t  && p->align == q->align\n \t  && p->addrspace == q->addrspace\n \t  && (p->expr == q->expr\n \t      || (p->expr != NULL_TREE && q->expr != NULL_TREE\n@@ -1585,7 +1589,9 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n       /* ??? Can this ever happen?  Calling this routine on a MEM that\n \t already carries memory attributes should probably be invalid.  */\n       attrs.expr = refattrs->expr;\n+      attrs.offset_known_p = refattrs->offset_known_p;\n       attrs.offset = refattrs->offset;\n+      attrs.size_known_p = refattrs->size_known_p;\n       attrs.size = refattrs->size;\n       attrs.align = refattrs->align;\n     }\n@@ -1595,9 +1601,10 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n     {\n       defattrs = mode_mem_attrs[(int) GET_MODE (ref)];\n       gcc_assert (!defattrs->expr);\n-      gcc_assert (!defattrs->offset);\n+      gcc_assert (!defattrs->offset_known_p);\n \n       /* Respect mode size.  */\n+      attrs.size_known_p = defattrs->size_known_p;\n       attrs.size = defattrs->size;\n       /* ??? Is this really necessary?  We probably should always get\n \t the size from the type below.  */\n@@ -1656,7 +1663,10 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \n   /* If the size is known, we can set that.  */\n   if (TYPE_SIZE_UNIT (type) && host_integerp (TYPE_SIZE_UNIT (type), 1))\n-    attrs.size = GEN_INT (tree_low_cst (TYPE_SIZE_UNIT (type), 1));\n+    {\n+      attrs.size_known_p = true;\n+      attrs.size = tree_low_cst (TYPE_SIZE_UNIT (type), 1);\n+    }\n \n   /* If T is not a type, we may be able to deduce some more information about\n      the expression.  */\n@@ -1694,11 +1704,16 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n       if (DECL_P (t))\n \t{\n \t  attrs.expr = t;\n-\t  attrs.offset = const0_rtx;\n+\t  attrs.offset_known_p = true;\n+\t  attrs.offset = 0;\n \t  apply_bitpos = bitpos;\n-\t  attrs.size = (DECL_SIZE_UNIT (t)\n-\t\t\t&& host_integerp (DECL_SIZE_UNIT (t), 1)\n-\t\t\t? GEN_INT (tree_low_cst (DECL_SIZE_UNIT (t), 1)) : 0);\n+\t  if (DECL_SIZE_UNIT (t) && host_integerp (DECL_SIZE_UNIT (t), 1))\n+\t    {\n+\t      attrs.size_known_p = true;\n+\t      attrs.size = tree_low_cst (DECL_SIZE_UNIT (t), 1);\n+\t    }\n+\t  else\n+\t    attrs.size_known_p = false;\n \t  attrs.align = DECL_ALIGN (t);\n \t  align_computed = true;\n \t}\n@@ -1721,7 +1736,8 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t       && ! DECL_BIT_FIELD (TREE_OPERAND (t, 1)))\n \t{\n \t  attrs.expr = t;\n-\t  attrs.offset = const0_rtx;\n+\t  attrs.offset_known_p = true;\n+\t  attrs.offset = 0;\n \t  apply_bitpos = bitpos;\n \t  /* ??? Any reason the field size would be different than\n \t     the size we got from the type?  */\n@@ -1762,7 +1778,7 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t  if (DECL_P (t2))\n \t    {\n \t      attrs.expr = t2;\n-\t      attrs.offset = NULL;\n+\t      attrs.offset_known_p = false;\n \t      if (host_integerp (off_tree, 1))\n \t\t{\n \t\t  HOST_WIDE_INT ioff = tree_low_cst (off_tree, 1);\n@@ -1771,17 +1787,19 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t\t  if (aoff && (unsigned HOST_WIDE_INT) aoff < attrs.align)\n \t            attrs.align = aoff;\n \t\t  align_computed = true;\n-\t\t  attrs.offset = GEN_INT (ioff);\n+\t\t  attrs.offset_known_p = true;\n+\t\t  attrs.offset = ioff;\n \t\t  apply_bitpos = bitpos;\n \t\t}\n \t    }\n \t  else if (TREE_CODE (t2) == COMPONENT_REF)\n \t    {\n \t      attrs.expr = t2;\n-\t      attrs.offset = NULL;\n+\t      attrs.offset_known_p = false;\n \t      if (host_integerp (off_tree, 1))\n \t\t{\n-\t\t  attrs.offset = GEN_INT (tree_low_cst (off_tree, 1));\n+\t\t  attrs.offset_known_p = true;\n+\t\t  attrs.offset = tree_low_cst (off_tree, 1);\n \t\t  apply_bitpos = bitpos;\n \t\t}\n \t      /* ??? Any reason the field size would be different than\n@@ -1792,7 +1810,8 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t  else if (TREE_CODE (t) == MEM_REF)\n \t    {\n \t      attrs.expr = t;\n-\t      attrs.offset = const0_rtx;\n+\t      attrs.offset_known_p = true;\n+\t      attrs.offset = 0;\n \t      apply_bitpos = bitpos;\n \t    }\n \t}\n@@ -1802,7 +1821,8 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t       || TREE_CODE (t) == TARGET_MEM_REF)\n \t{\n \t  attrs.expr = t;\n-\t  attrs.offset = const0_rtx;\n+\t  attrs.offset_known_p = true;\n+\t  attrs.offset = 0;\n \t  apply_bitpos = bitpos;\n \t}\n \n@@ -1818,10 +1838,10 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n      object to contain the negative offset.  */\n   if (apply_bitpos)\n     {\n-      attrs.offset = plus_constant (attrs.offset,\n-\t\t\t\t    -(apply_bitpos / BITS_PER_UNIT));\n-      if (attrs.size)\n-\tattrs.size = plus_constant (attrs.size, apply_bitpos / BITS_PER_UNIT);\n+      gcc_assert (attrs.offset_known_p);\n+      attrs.offset -= apply_bitpos / BITS_PER_UNIT;\n+      if (attrs.size_known_p)\n+\tattrs.size += apply_bitpos / BITS_PER_UNIT;\n     }\n \n   /* Now set the attributes we computed above.  */\n@@ -1903,7 +1923,8 @@ set_mem_offset (rtx mem, HOST_WIDE_INT offset)\n   struct mem_attrs attrs;\n \n   attrs = *get_mem_attrs (mem);\n-  attrs.offset = GEN_INT (offset);\n+  attrs.offset_known_p = true;\n+  attrs.offset = offset;\n   set_mem_attrs (mem, &attrs);\n }\n \n@@ -1915,7 +1936,7 @@ clear_mem_offset (rtx mem)\n   struct mem_attrs attrs;\n \n   attrs = *get_mem_attrs (mem);\n-  attrs.offset = NULL_RTX;\n+  attrs.offset_known_p = false;\n   set_mem_attrs (mem, &attrs);\n }\n \n@@ -1927,7 +1948,8 @@ set_mem_size (rtx mem, HOST_WIDE_INT size)\n   struct mem_attrs attrs;\n \n   attrs = *get_mem_attrs (mem);\n-  attrs.size = GEN_INT (size);\n+  attrs.size_known_p = true;\n+  attrs.size = size;\n   set_mem_attrs (mem, &attrs);\n }\n \n@@ -1939,7 +1961,7 @@ clear_mem_size (rtx mem)\n   struct mem_attrs attrs;\n \n   attrs = *get_mem_attrs (mem);\n-  attrs.size = NULL_RTX;\n+  attrs.size_known_p = false;\n   set_mem_attrs (mem, &attrs);\n }\n \f\n@@ -1993,8 +2015,9 @@ change_address (rtx memref, enum machine_mode mode, rtx addr)\n \n   attrs = *get_mem_attrs (memref);\n   defattrs = mode_mem_attrs[(int) mmode];\n-  attrs.expr = defattrs->expr;\n-  attrs.offset = defattrs->offset;\n+  attrs.expr = NULL_TREE;\n+  attrs.offset_known_p = false;\n+  attrs.size_known_p = defattrs->size_known_p;\n   attrs.size = defattrs->size;\n   attrs.align = defattrs->align;\n \n@@ -2076,8 +2099,8 @@ adjust_address_1 (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset,\n \n   /* Compute the new values of the memory attributes due to this adjustment.\n      We add the offsets and update the alignment.  */\n-  if (attrs.offset)\n-    attrs.offset = GEN_INT (offset + INTVAL (attrs.offset));\n+  if (attrs.offset_known_p)\n+    attrs.offset += offset;\n \n   /* Compute the new alignment by taking the MIN of the alignment and the\n      lowest-order set bit in OFFSET, but don't change the alignment if OFFSET\n@@ -2090,10 +2113,13 @@ adjust_address_1 (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset,\n \n   /* We can compute the size in a number of ways.  */\n   defattrs = mode_mem_attrs[(int) GET_MODE (new_rtx)];\n-  if (defattrs->size)\n-    attrs.size = defattrs->size;\n-  else if (attrs.size)\n-    attrs.size = plus_constant (attrs.size, -offset);\n+  if (defattrs->size_known_p)\n+    {\n+      attrs.size_known_p = true;\n+      attrs.size = defattrs->size;\n+    }\n+  else if (attrs.size_known_p)\n+    attrs.size -= offset;\n \n   set_mem_attrs (new_rtx, &attrs);\n \n@@ -2124,7 +2150,7 @@ offset_address (rtx memref, rtx offset, unsigned HOST_WIDE_INT pow2)\n {\n   rtx new_rtx, addr = XEXP (memref, 0);\n   enum machine_mode address_mode;\n-  struct mem_attrs attrs;\n+  struct mem_attrs attrs, *defattrs;\n \n   attrs = *get_mem_attrs (memref);\n   address_mode = targetm.addr_space.address_mode (attrs.addrspace);\n@@ -2155,8 +2181,10 @@ offset_address (rtx memref, rtx offset, unsigned HOST_WIDE_INT pow2)\n \n   /* Update the alignment to reflect the offset.  Reset the offset, which\n      we don't know.  */\n-  attrs.offset = 0;\n-  attrs.size = mode_mem_attrs[(int) GET_MODE (new_rtx)]->size;\n+  defattrs = mode_mem_attrs[(int) GET_MODE (new_rtx)];\n+  attrs.offset_known_p = false;\n+  attrs.size_known_p = defattrs->size_known_p;\n+  attrs.size = defattrs->size;\n   attrs.align = MIN (attrs.align, pow2 * BITS_PER_UNIT);\n   set_mem_attrs (new_rtx, &attrs);\n   return new_rtx;\n@@ -2204,7 +2232,7 @@ widen_memory_access (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset)\n \n   /* If we don't know what offset we were at within the expression, then\n      we can't know if we've overstepped the bounds.  */\n-  if (! attrs.offset)\n+  if (! attrs.offset_known_p)\n     attrs.expr = NULL_TREE;\n \n   while (attrs.expr)\n@@ -2224,7 +2252,7 @@ widen_memory_access (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset)\n \t     otherwise strip back to the containing structure.  */\n \t  if (TREE_CODE (DECL_SIZE_UNIT (field)) == INTEGER_CST\n \t      && compare_tree_int (DECL_SIZE_UNIT (field), size) >= 0\n-\t      && INTVAL (attrs.offset) >= 0)\n+\t      && attrs.offset >= 0)\n \t    break;\n \n \t  if (! host_integerp (offset, 1))\n@@ -2234,18 +2262,16 @@ widen_memory_access (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset)\n \t    }\n \n \t  attrs.expr = TREE_OPERAND (attrs.expr, 0);\n-\t  attrs.offset\n-\t    = (GEN_INT (INTVAL (attrs.offset)\n-\t\t\t+ tree_low_cst (offset, 1)\n-\t\t\t+ (tree_low_cst (DECL_FIELD_BIT_OFFSET (field), 1)\n-\t\t\t   / BITS_PER_UNIT)));\n+\t  attrs.offset += tree_low_cst (offset, 1);\n+\t  attrs.offset += (tree_low_cst (DECL_FIELD_BIT_OFFSET (field), 1)\n+\t\t\t   / BITS_PER_UNIT);\n \t}\n       /* Similarly for the decl.  */\n       else if (DECL_P (attrs.expr)\n \t       && DECL_SIZE_UNIT (attrs.expr)\n \t       && TREE_CODE (DECL_SIZE_UNIT (attrs.expr)) == INTEGER_CST\n \t       && compare_tree_int (DECL_SIZE_UNIT (attrs.expr), size) >= 0\n-\t       && (! attrs.offset || INTVAL (attrs.offset) >= 0))\n+\t       && (! attrs.offset_known_p || attrs.offset >= 0))\n \tbreak;\n       else\n \t{\n@@ -2257,12 +2283,13 @@ widen_memory_access (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset)\n     }\n \n   if (! attrs.expr)\n-    attrs.offset = NULL_RTX;\n+    attrs.offset_known_p = false;\n \n   /* The widened memory may alias other stuff, so zap the alias set.  */\n   /* ??? Maybe use get_alias_set on any remaining expression.  */\n   attrs.alias = 0;\n-  attrs.size = GEN_INT (size);\n+  attrs.size_known_p = true;\n+  attrs.size = size;\n   set_mem_attrs (new_rtx, &attrs);\n   return new_rtx;\n }\n@@ -2319,10 +2346,11 @@ set_mem_attrs_for_spill (rtx mem)\n \t(mem:MODE (plus (reg sfp) (const_int offset)))\n      with perhaps the plus missing for offset = 0.  */\n   addr = XEXP (mem, 0);\n-  attrs.offset = const0_rtx;\n+  attrs.offset_known_p = true;\n+  attrs.offset = 0;\n   if (GET_CODE (addr) == PLUS\n       && CONST_INT_P (XEXP (addr, 1)))\n-    attrs.offset = XEXP (addr, 1);\n+    attrs.offset = INTVAL (XEXP (addr, 1));\n \n   set_mem_attrs (mem, &attrs);\n   MEM_NOTRAP_P (mem) = 1;\n@@ -5522,7 +5550,8 @@ init_emit_regs (void)\n       attrs->addrspace = ADDR_SPACE_GENERIC;\n       if (mode != BLKmode)\n \t{\n-\t  attrs->size = GEN_INT (GET_MODE_SIZE (mode));\n+\t  attrs->size_known_p = true;\n+\t  attrs->size = GET_MODE_SIZE (mode);\n \t  if (STRICT_ALIGNMENT)\n \t    attrs->align = GET_MODE_ALIGNMENT (mode);\n \t}"}, {"sha": "1490bfe432ca1214f6c6791523606d7054dfffde", "filename": "gcc/rtl.h", "status": "modified", "additions": 34, "deletions": 15, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754c3d5de8c1be4a18f6803133bb7cf96c5178d4/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754c3d5de8c1be4a18f6803133bb7cf96c5178d4/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=754c3d5de8c1be4a18f6803133bb7cf96c5178d4", "patch": "@@ -136,19 +136,38 @@ typedef struct\n \n /* Structure used to describe the attributes of a MEM.  These are hashed\n    so MEMs that the same attributes share a data structure.  This means\n-   they cannot be modified in place.  If any element is nonzero, it means\n-   the value of the corresponding attribute is unknown.  */\n-/* ALIGN and SIZE are the alignment and size of the MEM itself,\n-   while EXPR can describe a larger underlying object, which might have a\n-   stricter alignment; OFFSET is the offset of the MEM within that object.  */\n+   they cannot be modified in place.  */\n typedef struct GTY(()) mem_attrs\n {\n-  tree expr;\t\t\t/* expr corresponding to MEM.  */\n-  rtx offset;\t\t\t/* Offset from start of DECL, as CONST_INT.  */\n-  rtx size;\t\t\t/* Size in bytes, as a CONST_INT.  */\n-  alias_set_type alias;\t\t/* Memory alias set.  */\n-  unsigned int align;\t\t/* Alignment of MEM in bits.  */\n-  unsigned char addrspace;\t/* Address space (0 for generic).  */\n+  /* The expression that the MEM accesses, or null if not known.\n+     This expression might be larger than the memory reference itself.\n+     (In other words, the MEM might access only part of the object.)  */\n+  tree expr;\n+\n+  /* The offset of the memory reference from the start of EXPR.\n+     Only valid if OFFSET_KNOWN_P.  */\n+  HOST_WIDE_INT offset;\n+\n+  /* The size of the memory reference in bytes.  Only valid if\n+     SIZE_KNOWN_P.  */\n+  HOST_WIDE_INT size;\n+\n+  /* The alias set of the memory reference.  */\n+  alias_set_type alias;\n+\n+  /* The alignment of the reference in bits.  Always a multiple of\n+     BITS_PER_UNIT.  Note that EXPR may have a stricter alignment\n+     than the memory reference itself.  */\n+  unsigned int align;\n+\n+  /* The address space that the memory reference uses.  */\n+  unsigned char addrspace;\n+\n+  /* True if OFFSET is known.  */\n+  bool offset_known_p;\n+\n+  /* True if SIZE is known.  */\n+  bool size_known_p;\n } mem_attrs;\n \n /* Structure used to describe the attributes of a REG in similar way as\n@@ -1303,19 +1322,19 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define MEM_EXPR(RTX) (get_mem_attrs (RTX)->expr)\n \n /* For a MEM rtx, true if its MEM_OFFSET is known.  */\n-#define MEM_OFFSET_KNOWN_P(RTX) (get_mem_attrs (RTX)->offset != NULL_RTX)\n+#define MEM_OFFSET_KNOWN_P(RTX) (get_mem_attrs (RTX)->offset_known_p)\n \n /* For a MEM rtx, the offset from the start of MEM_EXPR.  */\n-#define MEM_OFFSET(RTX) INTVAL (get_mem_attrs (RTX)->offset)\n+#define MEM_OFFSET(RTX) (get_mem_attrs (RTX)->offset)\n \n /* For a MEM rtx, the address space.  */\n #define MEM_ADDR_SPACE(RTX) (get_mem_attrs (RTX)->addrspace)\n \n /* For a MEM rtx, true if its MEM_SIZE is known.  */\n-#define MEM_SIZE_KNOWN_P(RTX) (get_mem_attrs (RTX)->size != NULL_RTX)\n+#define MEM_SIZE_KNOWN_P(RTX) (get_mem_attrs (RTX)->size_known_p)\n \n /* For a MEM rtx, the size in bytes of the MEM.  */\n-#define MEM_SIZE(RTX) INTVAL (get_mem_attrs (RTX)->size)\n+#define MEM_SIZE(RTX) (get_mem_attrs (RTX)->size)\n \n /* For a MEM rtx, the alignment in bits.  We can use the alignment of the\n    mode as a default when STRICT_ALIGNMENT, but not if not.  */"}]}