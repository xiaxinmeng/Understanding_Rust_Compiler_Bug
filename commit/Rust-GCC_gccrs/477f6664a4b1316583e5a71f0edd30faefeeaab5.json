{"sha": "477f6664a4b1316583e5a71f0edd30faefeeaab5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc3ZjY2NjRhNGIxMzE2NTgzZTVhNzFmMGVkZDMwZmFlZmVlYWFiNQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2000-12-21T17:50:10Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-12-21T17:50:10Z"}, "message": "pt.c (tsubst_decl): A FUNCTION_DECL has DECL_RESULT, not DECL_TEMPLATE_RESULT.\n\n        * pt.c (tsubst_decl): A FUNCTION_DECL has DECL_RESULT, not\n        DECL_TEMPLATE_RESULT.\n\n        * search.c (lookup_field_r): Call lookup_fnfields_1, not\n        lookup_fnfields_here.\n\n        * parse.y (typename_sub2): Return the TYPE_DECL, not the type.\n\n        * call.c (build_object_call): Also allow conversions that return\n        reference to pointer to function.\n        (add_conv_candidate): Handle totype being ref to ptr to fn.\n        (build_field_call): Also allow members of type reference to function.\n        Lose support for calling pointer to METHOD_TYPE fields.\n\n        * error.c (dump_expr): Handle *_CAST_EXPR.\n\n        * typeck2.c (build_scoped_ref): Always convert to the naming class.\n\n        * tree.c (break_out_cleanups): Lose.\n        * cp-tree.h: Remove prototype.\n        * typeck.c (build_component_ref): Don't break_out_cleanups.\n        (build_compound_expr): Likewise.\n        * semantics.c (finish_expr_stmt): Likewise.\n\nFrom-SVN: r38417", "tree": {"sha": "e6f13c06ffc9b6aad95c7ae50d1a868b3a9baa9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6f13c06ffc9b6aad95c7ae50d1a868b3a9baa9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/477f6664a4b1316583e5a71f0edd30faefeeaab5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/477f6664a4b1316583e5a71f0edd30faefeeaab5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/477f6664a4b1316583e5a71f0edd30faefeeaab5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/477f6664a4b1316583e5a71f0edd30faefeeaab5/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e98df22a4f27fe43b61cbb7b3f29d9e4c9691a2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e98df22a4f27fe43b61cbb7b3f29d9e4c9691a2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e98df22a4f27fe43b61cbb7b3f29d9e4c9691a2d"}], "stats": {"total": 245, "additions": 164, "deletions": 81}, "files": [{"sha": "0dd5b81f85682ff2f04969bdb7e79e229b75ebd6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=477f6664a4b1316583e5a71f0edd30faefeeaab5", "patch": "@@ -1,3 +1,29 @@\n+2000-12-20  Jason Merrill  <jason@redhat.com>\n+\n+\t* pt.c (tsubst_decl): A FUNCTION_DECL has DECL_RESULT, not\n+\tDECL_TEMPLATE_RESULT.\n+\n+\t* search.c (lookup_field_r): Call lookup_fnfields_1, not\n+\tlookup_fnfields_here.\n+\n+\t* parse.y (typename_sub2): Return the TYPE_DECL, not the type.\n+\n+\t* call.c (build_object_call): Also allow conversions that return\n+\treference to pointer to function.\n+\t(add_conv_candidate): Handle totype being ref to ptr to fn.\n+\t(build_field_call): Also allow members of type reference to function.\n+\tLose support for calling pointer to METHOD_TYPE fields.\n+\n+\t* error.c (dump_expr): Handle *_CAST_EXPR.\n+\n+\t* typeck2.c (build_scoped_ref): Always convert to the naming class.\n+\n+\t* tree.c (break_out_cleanups): Lose.\n+\t* cp-tree.h: Remove prototype.\n+\t* typeck.c (build_component_ref): Don't break_out_cleanups.\n+\t(build_compound_expr): Likewise.\n+\t* semantics.c (finish_expr_stmt): Likewise.\n+\n 2000-12-20  Richard Henderson  <rth@redhat.com>\n \n \t* cp-tree.h: Update declarations."}, {"sha": "e7de1bab367ec618cf8f334f3c1974aa3deb24b4", "filename": "gcc/cp/call.c", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=477f6664a4b1316583e5a71f0edd30faefeeaab5", "patch": "@@ -156,15 +156,11 @@ build_field_call (basetype_path, instance_ptr, name, parms)\n       if (IS_AGGR_TYPE (TREE_TYPE (instance)))\n \treturn build_opfncall (CALL_EXPR, LOOKUP_NORMAL,\n \t\t\t       instance, parms, NULL_TREE);\n-      else if (TREE_CODE (TREE_TYPE (instance)) == POINTER_TYPE)\n-\t{\n-\t  if (TREE_CODE (TREE_TYPE (TREE_TYPE (instance))) == FUNCTION_TYPE)\n-\t    return build_function_call (instance, parms);\n-\t  else if (TREE_CODE (TREE_TYPE (TREE_TYPE (instance)))\n-\t\t   == METHOD_TYPE)\n-\t    return build_function_call\n-\t      (instance, tree_cons (NULL_TREE, instance_ptr, parms));\n-\t}\n+      else if (TREE_CODE (TREE_TYPE (instance)) == FUNCTION_TYPE\n+\t       || (TREE_CODE (TREE_TYPE (instance)) == POINTER_TYPE\n+\t\t   && (TREE_CODE (TREE_TYPE (TREE_TYPE (instance)))\n+\t\t       == FUNCTION_TYPE)))\n+\treturn build_function_call (instance, parms);\n     }\n \n   return NULL_TREE;\n@@ -1422,13 +1418,19 @@ add_conv_candidate (candidates, fn, obj, arglist)\n      tree fn, obj, arglist;\n {\n   tree totype = TREE_TYPE (TREE_TYPE (fn));\n-  tree parmlist = TYPE_ARG_TYPES (TREE_TYPE (totype));\n-  int i, len = list_length (arglist) + 1;\n-  tree convs = make_tree_vec (len);\n-  tree parmnode = parmlist;\n-  tree argnode = arglist;\n-  int viable = 1;\n-  int flags = LOOKUP_NORMAL;\n+  int i, len, viable, flags;\n+  tree parmlist, convs, parmnode, argnode;\n+\n+  for (parmlist = totype; TREE_CODE (parmlist) != FUNCTION_TYPE; )\n+    parmlist = TREE_TYPE (parmlist);\n+  parmlist = TYPE_ARG_TYPES (parmlist);\n+\n+  len = list_length (arglist) + 1;\n+  convs = make_tree_vec (len);\n+  parmnode = parmlist;\n+  argnode = arglist;\n+  viable = 1;\n+  flags = LOOKUP_NORMAL;\n \n   /* Don't bother looking up the same type twice.  */\n   if (candidates && candidates->fn == totype)\n@@ -2659,8 +2661,12 @@ build_object_call (obj, args)\n       tree totype = TREE_TYPE (TREE_TYPE (OVL_CURRENT (fns)));\n \n       if ((TREE_CODE (totype) == POINTER_TYPE\n-\t   || TREE_CODE (totype) == REFERENCE_TYPE)\n-\t  && TREE_CODE (TREE_TYPE (totype)) == FUNCTION_TYPE)\n+\t   && TREE_CODE (TREE_TYPE (totype)) == FUNCTION_TYPE)\n+\t  || (TREE_CODE (totype) == REFERENCE_TYPE\n+\t      && TREE_CODE (TREE_TYPE (totype)) == FUNCTION_TYPE)\n+\t  || (TREE_CODE (totype) == REFERENCE_TYPE\n+\t      && TREE_CODE (TREE_TYPE (totype)) == POINTER_TYPE\n+\t      && TREE_CODE (TREE_TYPE (TREE_TYPE (totype))) == FUNCTION_TYPE))\n \tfor (; fns; fns = OVL_NEXT (fns))\n \t  {\n \t    tree fn = OVL_CURRENT (fns);"}, {"sha": "7c3dce43e3db27af4db28480356ea95e4b34e1ed", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=477f6664a4b1316583e5a71f0edd30faefeeaab5", "patch": "@@ -4401,7 +4401,6 @@ extern int lvalue_p\t\t\t\tPARAMS ((tree));\n extern int lvalue_or_else\t\t\tPARAMS ((tree, const char *));\n extern tree build_cplus_new\t\t\tPARAMS ((tree, tree));\n extern tree get_target_expr\t\t\tPARAMS ((tree));\n-extern tree break_out_cleanups\t\t\tPARAMS ((tree));\n extern tree break_out_calls\t\t\tPARAMS ((tree));\n extern tree build_cplus_method_type\t\tPARAMS ((tree, tree, tree));\n extern tree build_cplus_staticfn_type\t\tPARAMS ((tree, tree, tree));"}, {"sha": "ce11ae1eda82f113e12ec2edb5a0253f7fcd2825", "filename": "gcc/cp/error.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=477f6664a4b1316583e5a71f0edd30faefeeaab5", "patch": "@@ -2051,6 +2051,24 @@ dump_expr (t, flags)\n \t}\n       break;\n \n+    case STATIC_CAST_EXPR:\n+      output_add_string (scratch_buffer, \"static_cast<\");\n+      goto cast;\n+    case REINTERPRET_CAST_EXPR:\n+      output_add_string (scratch_buffer, \"reinterpret_cast<\");\n+      goto cast;\n+    case CONST_CAST_EXPR:\n+      output_add_string (scratch_buffer, \"const_cast<\");\n+      goto cast;\n+    case DYNAMIC_CAST_EXPR:\n+      output_add_string (scratch_buffer, \"dynamic_cast<\");\n+    cast:\n+      dump_type (TREE_TYPE (t), flags);\n+      output_add_string (scratch_buffer, \">(\");\n+      dump_expr (TREE_OPERAND (t, 0), flags);\n+      print_right_paren (scratch_buffer);\n+      break;\n+\n     case LOOKUP_EXPR:\n       print_tree_identifier (scratch_buffer, TREE_OPERAND (t, 0));\n       break;"}, {"sha": "4e763941fc6b97aeb2afd67f9db1d7263adea576", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=477f6664a4b1316583e5a71f0edd30faefeeaab5", "patch": "@@ -3056,6 +3056,8 @@ typename_sub1:\n \t\t{\n \t\t  if (TREE_CODE ($1) == IDENTIFIER_NODE)\n \t\t    cp_error (\"`%T' is not a class or namespace\", $1);\n+\t\t  else if (TREE_CODE ($1) == TYPE_DECL)\n+\t\t    $$ = TREE_TYPE ($1);\n \t\t}\n \t| typename_sub1 typename_sub2\n \t\t{\n@@ -3078,24 +3080,26 @@ typename_sub1:\n \t\t    = make_typename_type ($1, $3, /*complain=*/1); }\n \t;\n \n+/* This needs to return a TYPE_DECL for simple names so that we don't\n+   forget what name was used.  */\n typename_sub2:\n \t  TYPENAME SCOPE\n \t\t{\n-\t\t  if (TREE_CODE ($1) != IDENTIFIER_NODE)\n-\t\t    $1 = lastiddecl;\n+\t\t  if (TREE_CODE ($1) != TYPE_DECL)\n+\t\t    $$ = lastiddecl;\n \n \t\t  /* Retrieve the type for the identifier, which might involve\n \t\t     some computation. */\n-\t\t  got_scope = $$ = complete_type (IDENTIFIER_TYPE_VALUE ($1));\n+\t\t  got_scope = complete_type (TREE_TYPE ($$));\n \n \t\t  if ($$ == error_mark_node)\n \t\t    cp_error (\"`%T' is not a class or namespace\", $1);\n \t\t}\n \t| SELFNAME SCOPE\n \t\t{\n-\t\t  if (TREE_CODE ($1) != IDENTIFIER_NODE)\n+\t\t  if (TREE_CODE ($1) != TYPE_DECL)\n \t\t    $$ = lastiddecl;\n-\t\t  got_scope = $$ = complete_type (TREE_TYPE ($$));\n+\t\t  got_scope = complete_type (TREE_TYPE ($$));\n \t\t}\n \t| template_type SCOPE\n \t\t{ got_scope = $$ = complete_type (TREE_TYPE ($$)); }"}, {"sha": "50e7ddf9da9192857257934b4d334974be2fd6bc", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=477f6664a4b1316583e5a71f0edd30faefeeaab5", "patch": "@@ -5715,7 +5715,7 @@ tsubst_decl (t, args, type, in_decl)\n \n \tDECL_ARGUMENTS (r) = tsubst (DECL_ARGUMENTS (t), args,\n \t\t\t\t     /*complain=*/1, t);\n-\tDECL_TEMPLATE_RESULT (r) = NULL_TREE;\n+\tDECL_RESULT (r) = NULL_TREE;\n \n \tTREE_STATIC (r) = 0;\n \tTREE_PUBLIC (r) = TREE_PUBLIC (t);"}, {"sha": "2f4a3e94671471a217886c56a1c5e505b99977c9", "filename": "gcc/cp/search.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=477f6664a4b1316583e5a71f0edd30faefeeaab5", "patch": "@@ -1251,7 +1251,9 @@ is_subobject_of_p (parent, binfo, most_derived)\n \n /* Very similar to lookup_fnfields_1 but it ensures that at least one\n    function was declared inside the class given by TYPE.  It really should\n-   only return functions that match the given TYPE.  */\n+   only return functions that match the given TYPE.  Therefore, it should\n+   only be called for situations that ignore using-declarations, such as\n+   determining overrides.  */\n \n static int\n lookup_fnfields_here (type, name)\n@@ -1359,7 +1361,7 @@ lookup_field_r (binfo, data)\n      with the same name, the type is hidden by the function.  */\n   if (!lfi->want_type)\n     {\n-      int idx = lookup_fnfields_here (type, lfi->name);\n+      int idx = lookup_fnfields_1 (type, lfi->name);\n       if (idx >= 0)\n \tnval = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), idx);\n     }"}, {"sha": "28bf1ccb684212f80be6b8e7eace7e60e3273761", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=477f6664a4b1316583e5a71f0edd30faefeeaab5", "patch": "@@ -214,9 +214,6 @@ finish_expr_stmt (expr)\n       if (stmts_are_full_exprs_p ())\n \texpr = convert_to_void (expr, \"statement\");\n       \n-      if (!processing_template_decl)\n-\texpr = break_out_cleanups (expr);\n-      \n       r = add_stmt (build_stmt (EXPR_STMT, expr));\n     }\n "}, {"sha": "a1089ce40187495bb8303550df75c053cd9f81cf", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=477f6664a4b1316583e5a71f0edd30faefeeaab5", "patch": "@@ -317,37 +317,6 @@ get_target_expr (init)\n   return build_target_expr_with_type (init, TREE_TYPE (init));\n }\n \n-/* Recursively search EXP for CALL_EXPRs that need cleanups and replace\n-   these CALL_EXPRs with tree nodes that will perform the cleanups.  */\n-\n-tree\n-break_out_cleanups (exp)\n-     tree exp;\n-{\n-  tree tmp = exp;\n-\n-  if (TREE_CODE (tmp) == CALL_EXPR\n-      && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (tmp)))\n-    return build_cplus_new (TREE_TYPE (tmp), tmp);\n-\n-  while (TREE_CODE (tmp) == NOP_EXPR\n-\t || TREE_CODE (tmp) == CONVERT_EXPR\n-\t || TREE_CODE (tmp) == NON_LVALUE_EXPR)\n-    {\n-      if (TREE_CODE (TREE_OPERAND (tmp, 0)) == CALL_EXPR\n-\t  && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (TREE_OPERAND (tmp, 0))))\n-\t{\n-\t  TREE_OPERAND (tmp, 0)\n-\t    = build_cplus_new (TREE_TYPE (TREE_OPERAND (tmp, 0)),\n-\t\t\t       TREE_OPERAND (tmp, 0));\n-\t  break;\n-\t}\n-      else\n-\ttmp = TREE_OPERAND (tmp, 0);\n-    }\n-  return exp;\n-}\n-\n /* Recursively perform a preorder search EXP for CALL_EXPRs, making\n    copies where they are found.  Returns a deep copy all nodes transitively\n    containing CALL_EXPRs.  */"}, {"sha": "8de99f6d3abce036ba6bb5e003da8847bc890d69", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=477f6664a4b1316583e5a71f0edd30faefeeaab5", "patch": "@@ -2278,8 +2278,7 @@ build_component_ref (datum, component, basetype_path, protect)\n       field_type = cp_build_qualified_type (field_type, type_quals);\n     }\n \n-  ref = fold (build (COMPONENT_REF, field_type,\n-\t\t     break_out_cleanups (datum), field));\n+  ref = fold (build (COMPONENT_REF, field_type, datum, field));\n \n   /* Mark the expression const or volatile, as appropriate.  Even\n      though we've dealt with the type above, we still have to mark the\n@@ -5039,8 +5038,7 @@ build_compound_expr (list)\n   if (! TREE_SIDE_EFFECTS (first) && ! pedantic)\n     return rest;\n \n-  return build (COMPOUND_EXPR, TREE_TYPE (rest),\n-\t\tbreak_out_cleanups (first), rest);\n+  return build (COMPOUND_EXPR, TREE_TYPE (rest), first, rest);\n }\n \n tree"}, {"sha": "c40b81cc6c5d2f52e61e30084def099b48981c63", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=477f6664a4b1316583e5a71f0edd30faefeeaab5", "patch": "@@ -957,26 +957,21 @@ process_init_constructor (type, init, elts)\n    the A part of the C object named by X.  In this case,\n    DATUM would be x, and BASETYPE would be A.\n \n-   Note that this is nonconformant; the standard specifies that first\n-   we look up ii in A, then convert x to an L& and pull out the ii part.\n-   But narrowing seems to be standard practice, so let's do it anyway.  */\n+   I used to think that this was nonconformant, that the standard specified\n+   that first we look up ii in A, then convert x to an L& and pull out the\n+   ii part.  But in fact, it does say that we convert x to an A&; A here\n+   is known as the \"naming class\".  (jason 2000-12-19) */\n \n tree\n build_scoped_ref (datum, basetype)\n      tree datum;\n      tree basetype;\n {\n   tree ref;\n-  tree type = TREE_TYPE (datum);\n \n   if (datum == error_mark_node)\n     return error_mark_node;\n \n-  /* Don't do this if it would cause an error or if we're being pedantic.  */\n-  if (! ACCESSIBLY_UNIQUELY_DERIVED_P (basetype, type)\n-      || pedantic)\n-    return datum;\n-\n   ref = build_unary_op (ADDR_EXPR, datum, 0);\n   ref = convert_pointer_to (basetype, ref);\n "}, {"sha": "a834f4f49561ac74517e9e0ca6cb0f5d82a62592", "filename": "gcc/testsuite/g++.old-deja/g++.benjamin/scope01.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Fscope01.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Fscope01.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Fscope01.C?ref=477f6664a4b1316583e5a71f0edd30faefeeaab5", "patch": "@@ -19,8 +19,8 @@ class C : public A, public B {};\n void foo() {\n   // straight call\n   C x;\n-  x.A::ii = 5;\t\t\t// ERROR - L is ambiguous base\n-  x.A::foo(x.A::ii);\t\t// ERROR - L is ambiguous base\n+  x.A::ii = 5;\n+  x.A::foo(x.A::ii);\n   \n   // 5.1 Primary expressions\n   // p 8 "}, {"sha": "a294e4f7e49c3d9f326dd5836f40cfe40e8b3406", "filename": "gcc/testsuite/g++.old-deja/g++.brendan/misc15.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fmisc15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fmisc15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fmisc15.C?ref=477f6664a4b1316583e5a71f0edd30faefeeaab5", "patch": "@@ -9,5 +9,5 @@ struct B : public A {\n struct C : public A {\n };\n struct D : public C, public B {\n-        void fun() { C::aa = 10; } // ERROR - conversion to A is ambiguous\n+        void fun() { C::aa = 10; }\n };"}, {"sha": "7341488d94905204ab8d3c65e5449b1b9288fc4c", "filename": "gcc/testsuite/g++.old-deja/g++.other/call1.C", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcall1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcall1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcall1.C?ref=477f6664a4b1316583e5a71f0edd30faefeeaab5", "patch": "@@ -0,0 +1,51 @@\n+// Test that various calls to non-functions work.\n+\n+void f () { }\n+\n+typedef void (*fptr)();\n+typedef void (&fref)();\n+fptr p = f;\n+fref r = f;\n+const fptr &pr = p;\n+\n+struct A {\n+  fptr p;\n+\n+  A (fptr n): p(n) { }\n+  operator fptr () { return p; }\n+};\n+\n+struct B {\n+  fref r;\n+\n+  B (fptr n): r(*n) { }\n+  operator const fref () { return r; }\n+};\n+\n+struct C {\n+  const fptr &pr;\n+\n+  C (fptr n): pr(n) { }\n+  operator const fptr& () { return pr; }\n+};\n+\n+int main ()\n+{\n+  f();\n+\n+  p();\n+  r();\n+  pr();\n+\n+  A a (f);\n+  a();\n+  a.p();\n+\n+  B b (f);\n+  b();\n+  b.r();\n+\n+  C c (f);\n+  c();\n+  c.pr();\n+}"}, {"sha": "09549f7828c4d1bee921e5967a9f855bac42ba66", "filename": "gcc/testsuite/g++.old-deja/g++.other/lookup18.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Flookup18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Flookup18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Flookup18.C?ref=477f6664a4b1316583e5a71f0edd30faefeeaab5", "patch": "@@ -1,5 +1,5 @@\n-// Test that referring to an ambiguous base in name lookup does not\n-// interfere with accessing the field, which is not ambiguous.\n+// Test that referring to an ambiguous base in name lookup prevents\n+// access to the field, even though the field is not ambiguous.\n \n // Build don't link:\n \n@@ -14,10 +14,10 @@ struct E: public C, public D {\n };\n \n void E::f() {\n-  B::i = 0;\n+  B::i = 0;\t\t\t// ERROR - B is ambiguous\n }\n \n void f () {\n   E e;\n-  e.B::i = 0;\n+  e.B::i = 0;\t\t\t// ERROR - B is ambiguous\n }"}, {"sha": "930c9ab7ada161bfb9f86e4ab09fce7e31fe3529", "filename": "gcc/testsuite/g++.old-deja/g++.other/lookup20.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Flookup20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Flookup20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Flookup20.C?ref=477f6664a4b1316583e5a71f0edd30faefeeaab5", "patch": "@@ -0,0 +1,10 @@\n+// Bug: typename_sub2 returned the type, so we tried to look up \"A\" in B.\n+// Build don't link:\n+\n+struct A { struct A1 { }; };\n+\n+struct B {\n+  typedef A Q;\n+};\n+\n+struct C: public B::Q::A1 { };"}, {"sha": "031f3d649123f830d0dceed6ecd09fe6b28cf905", "filename": "gcc/testsuite/g++.old-deja/g++.pt/parms3.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fparms3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/477f6664a4b1316583e5a71f0edd30faefeeaab5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fparms3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fparms3.C?ref=477f6664a4b1316583e5a71f0edd30faefeeaab5", "patch": "@@ -0,0 +1,8 @@\n+// Test that we can represent static_casts in template arg lists.\n+// Build don't link:\n+\n+template <int I> struct A { };\n+\n+template <class T> struct B {\n+  A<static_cast<T>(3.14)> a;\n+};"}]}