{"sha": "b1760f7f915a36ee9b4636fb54719c9b3ae59356", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE3NjBmN2Y5MTVhMzZlZTliNDYzNmZiNTQ3MTljOWIzYWU1OTM1Ng==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2015-01-12T16:19:59Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2015-01-12T16:19:59Z"}, "message": "Merge libffi to upstream commit c82cc159426d8d4402375fa1ae3f045b9cf82e16\n\nFrom-SVN: r219477", "tree": {"sha": "1a64d747b069bdebf651d856989dd40a54daf0cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a64d747b069bdebf651d856989dd40a54daf0cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1760f7f915a36ee9b4636fb54719c9b3ae59356", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1760f7f915a36ee9b4636fb54719c9b3ae59356", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1760f7f915a36ee9b4636fb54719c9b3ae59356", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1760f7f915a36ee9b4636fb54719c9b3ae59356/comments", "author": null, "committer": null, "parents": [{"sha": "62e22fcb7985349b93646b86351033e1fb09c46c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62e22fcb7985349b93646b86351033e1fb09c46c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62e22fcb7985349b93646b86351033e1fb09c46c"}], "stats": {"total": 39071, "additions": 23080, "deletions": 15991}, "files": [{"sha": "741679386a4b476e173949d88545ed7668fcc4a0", "filename": "libffi/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -1,3 +1,7 @@\n+2015-01-12  Richard Henderson  <rth@redhat.com>\n+\n+\tMerge to upstream commit c82cc159426d8d4402375fa1ae3f045b9cf82e16.\n+\n 2014-11-21  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR bootstrap/63784"}, {"sha": "a66fab4f25a05b6b7d2ac8b438e86214c02135b8", "filename": "libffi/LICENSE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2FLICENSE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2FLICENSE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FLICENSE?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -1,4 +1,4 @@\n-libffi - Copyright (c) 1996-2012  Anthony Green, Red Hat, Inc and others.\n+libffi - Copyright (c) 1996-2014  Anthony Green, Red Hat, Inc and others.\n See source files for details.\n \n Permission is hereby granted, free of charge, to any person obtaining"}, {"sha": "64ff1c1e530159f6dcbe47bc0b15b6fd091b7888", "filename": "libffi/Makefile.am", "status": "modified", "additions": 130, "deletions": 164, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.am?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -1,46 +1,19 @@\n ## Process this with automake to create Makefile.in\n \n AUTOMAKE_OPTIONS = foreign subdir-objects\n+\n ACLOCAL_AMFLAGS = -I .. -I ../config\n \n SUBDIRS = include testsuite man\n \n-EXTRA_DIST = LICENSE ChangeLog.v1 ChangeLog.libgcj configure.host\t\\\n-\t src/aarch64/ffi.c src/aarch64/ffitarget.h\t\t\t\\\n-\t src/alpha/ffi.c src/alpha/osf.S src/alpha/ffitarget.h\t\t\\\n-\t src/arm/ffi.c src/arm/sysv.S src/arm/ffitarget.h\t\t\\\n-\t src/avr32/ffi.c src/avr32/sysv.S src/avr32/ffitarget.h\t\t\\\n-\t src/cris/ffi.c src/cris/sysv.S src/cris/ffitarget.h\t\t\\\n-\t src/ia64/ffi.c src/ia64/ffitarget.h src/ia64/ia64_flags.h\t\\\n-\t src/ia64/unix.S src/mips/ffi.c src/mips/n32.S src/mips/o32.S\t\\\n-\t src/mips/ffitarget.h src/m32r/ffi.c src/m32r/sysv.S\t\t\\\n-\t src/m32r/ffitarget.h src/m68k/ffi.c src/m68k/sysv.S\t\t\\\n-\t src/m68k/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/powerpc/ffi.c src/powerpc/ffi_powerpc.h\t\t\t\\\n-\tsrc/powerpc/ffi_sysv.c src/powerpc/ffi_linux64.c\t\t\\\n-\tsrc/powerpc/sysv.S src/powerpc/linux64.S\t\t\t\\\n-\tsrc/powerpc/linux64_closure.S src/powerpc/ppc_closure.S\t\t\\\n-\tsrc/powerpc/asm.h src/powerpc/aix.S src/powerpc/darwin.S\t\\\n-\tsrc/powerpc/aix_closure.S src/powerpc/darwin_closure.S\t\t\\\n-\tsrc/powerpc/ffi_darwin.c src/powerpc/ffitarget.h\t\t\\\n-\tsrc/s390/ffi.c src/s390/sysv.S src/s390/ffitarget.h\t\t\\\n-\tsrc/sh/ffi.c src/sh/sysv.S src/sh/ffitarget.h src/sh64/ffi.c\t\\\n-\tsrc/sh64/sysv.S src/sh64/ffitarget.h src/sparc/v8.S\t\t\\\n-\tsrc/sparc/v9.S src/sparc/ffitarget.h src/sparc/ffi.c\t\t\\\n-\tsrc/x86/darwin64.S src/x86/ffi.c src/x86/sysv.S\t\t\t\\\n-\tsrc/x86/win32.S src/x86/darwin.S src/x86/win64.S\t\t\\\n-\tsrc/x86/freebsd.S src/x86/ffi64.c src/x86/unix64.S\t\t\\\n-\tsrc/x86/ffitarget.h src/pa/ffitarget.h src/pa/ffi.c\t\t\\\n-\tsrc/pa/linux.S src/pa/hpux32.S src/frv/ffi.c src/bfin/ffi.c\t\\\n-\tsrc/bfin/ffitarget.h src/bfin/sysv.S src/frv/eabi.S\t\t\\\n-\tsrc/frv/ffitarget.h src/dlmalloc.c src/tile/ffi.c\t\t\\\n-\tsrc/tile/ffitarget.h src/tile/tile.S libtool-version\t\t\\\n-\t ChangeLog.libffi m4/libtool.m4 m4/lt~obsolete.m4\t\t\\\n+EXTRA_DIST = LICENSE ChangeLog.v1 ChangeLog.libgcj\t\t\t\\\n+\tChangeLog.libffi ChangeLog.libffi-3.1\t\t\t\t\\\n+\tm4/libtool.m4 m4/lt~obsolete.m4\t\t\t\t\t\\\n \t m4/ltoptions.m4 m4/ltsugar.m4 m4/ltversion.m4\t\t\t\\\n-\t m4/ltversion.m4 src/arm/gentramp.sh src/debug.c msvcc.sh\t\\\n-\tgenerate-ios-source-and-headers.py\t\t\t\t\\\n-\t generate-osx-source-and-headers.py\t\t\t\t\\\n-\t libffi.xcodeproj/project.pbxproj src/arm/trampoline.S\n+\t m4/ltversion.m4 src/debug.c msvcc.sh\t\t\t\t\\\n+\tgenerate-darwin-source-and-headers.py\t\t\t\t\\\n+\tlibffi.xcodeproj/project.pbxproj\t\t\t\t\\\n+\tlibtool-ldflags\n \n # Automake Documentation:\n # If your package has Texinfo files in many directories, you can use the\n@@ -79,7 +52,6 @@ stamp-build-info: doc/libffi.texi $(srcdir)/doc/version.texi doc/$(am__dirstamp)\n \t$(MAKEINFO) $(AM_MAKEINFOFLAGS) $(MAKEINFOFLAGS) -I $(srcdir)/doc -o doc/libffi.info $(srcdir)/doc/libffi.texi\n \t@touch $@\n \n-\n CLEANFILES = $(STAMP_GENINSRC) $(STAMP_BUILD_INFO) doc/libffi.info\n MAINTAINERCLEANFILES = $(srcdir)/doc/libffi.info\n \n@@ -93,153 +65,147 @@ MAINTAINERCLEANFILES = $(srcdir)/doc/libffi.info\n # values defined in terms of make variables, as is the case for CC and\n # friends when we are called from the top level Makefile.\n AM_MAKEFLAGS = \\\n-\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n-\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n-\t\"CFLAGS=$(CFLAGS)\" \\\n-\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n-\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n-\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n-\t\"INSTALL=$(INSTALL)\" \\\n-\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n-\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n-\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n-\t\"JC1FLAGS=$(JC1FLAGS)\" \\\n-\t\"LDFLAGS=$(LDFLAGS)\" \\\n-\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n-\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n-\t\"MAKE=$(MAKE)\" \\\n-\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n-\t\"PICFLAG=$(PICFLAG)\" \\\n-\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n-\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n-\t\"SHELL=$(SHELL)\" \\\n-\t\"exec_prefix=$(exec_prefix)\" \\\n-\t\"infodir=$(infodir)\" \\\n-\t\"libdir=$(libdir)\" \\\n-\t\"mandir=$(mandir)\" \\\n-\t\"prefix=$(prefix)\" \\\n-\t\"AR=$(AR)\" \\\n-\t\"AS=$(AS)\" \\\n-\t\"CC=$(CC)\" \\\n-\t\"CXX=$(CXX)\" \\\n-\t\"LD=$(LD)\" \\\n-\t\"NM=$(NM)\" \\\n-\t\"RANLIB=$(RANLIB)\" \\\n-\t\"DESTDIR=$(DESTDIR)\"\n+\t'AR_FLAGS=$(AR_FLAGS)' \\\n+\t'CC_FOR_BUILD=$(CC_FOR_BUILD)' \\\n+\t'CFLAGS=$(CFLAGS)' \\\n+\t'CXXFLAGS=$(CXXFLAGS)' \\\n+\t'CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)' \\\n+\t'CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)' \\\n+\t'INSTALL=$(INSTALL)' \\\n+\t'INSTALL_DATA=$(INSTALL_DATA)' \\\n+\t'INSTALL_PROGRAM=$(INSTALL_PROGRAM)' \\\n+\t'INSTALL_SCRIPT=$(INSTALL_SCRIPT)' \\\n+\t'JC1FLAGS=$(JC1FLAGS)' \\\n+\t'LDFLAGS=$(LDFLAGS)' \\\n+\t'LIBCFLAGS=$(LIBCFLAGS)' \\\n+\t'LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)' \\\n+\t'MAKE=$(MAKE)' \\\n+\t'MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)' \\\n+\t'PICFLAG=$(PICFLAG)' \\\n+\t'PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)' \\\n+\t'RUNTESTFLAGS=$(RUNTESTFLAGS)' \\\n+\t'SHELL=$(SHELL)' \\\n+\t'exec_prefix=$(exec_prefix)' \\\n+\t'infodir=$(infodir)' \\\n+\t'libdir=$(libdir)' \\\n+\t'mandir=$(mandir)' \\\n+\t'prefix=$(prefix)' \\\n+\t'AR=$(AR)' \\\n+\t'AS=$(AS)' \\\n+\t'CC=$(CC)' \\\n+\t'CXX=$(CXX)' \\\n+\t'LD=$(LD)' \\\n+\t'NM=$(NM)' \\\n+\t'RANLIB=$(RANLIB)' \\\n+\t'DESTDIR=$(DESTDIR)'\n \n # Subdir rules rely on $(FLAGS_TO_PASS)\n FLAGS_TO_PASS = $(AM_MAKEFLAGS)\n \n MAKEOVERRIDES=\n \n+pkgconfigdir = $(libdir)/pkgconfig\n+pkgconfig_DATA = libffi.pc\n+\n toolexeclib_LTLIBRARIES = libffi.la\n noinst_LTLIBRARIES = libffi_convenience.la\n \n libffi_la_SOURCES = src/prep_cif.c src/types.c \\\n \t\tsrc/raw_api.c src/java_raw_api.c src/closures.c\n \n-nodist_libffi_la_SOURCES =\n-\n if FFI_DEBUG\n-nodist_libffi_la_SOURCES += src/debug.c\n-endif\n-\n-if MIPS\n-nodist_libffi_la_SOURCES += src/mips/ffi.c src/mips/o32.S src/mips/n32.S\n-endif\n-if BFIN\n-nodist_libffi_la_SOURCES += src/bfin/ffi.c src/bfin/sysv.S\n-endif\n-if X86\n-nodist_libffi_la_SOURCES += src/x86/ffi.c src/x86/sysv.S\n-endif\n-if X86_FREEBSD\n-nodist_libffi_la_SOURCES += src/x86/ffi.c src/x86/freebsd.S\n-endif\n-if X86_WIN32\n-nodist_libffi_la_SOURCES += src/x86/ffi.c src/x86/win32.S\n-endif\n-if X86_WIN64\n-nodist_libffi_la_SOURCES += src/x86/ffi.c src/x86/win64.S\n-endif\n-if X86_DARWIN\n-nodist_libffi_la_SOURCES += src/x86/ffi.c src/x86/darwin.S src/x86/ffi64.c src/x86/darwin64.S\n-endif\n-if SPARC\n-nodist_libffi_la_SOURCES += src/sparc/ffi.c src/sparc/v8.S src/sparc/v9.S\n-endif\n-if ALPHA\n-nodist_libffi_la_SOURCES += src/alpha/ffi.c src/alpha/osf.S\n-endif\n-if IA64\n-nodist_libffi_la_SOURCES += src/ia64/ffi.c src/ia64/unix.S\n-endif\n-if M32R\n-nodist_libffi_la_SOURCES += src/m32r/sysv.S src/m32r/ffi.c\n-endif\n-if M68K\n-nodist_libffi_la_SOURCES += src/m68k/ffi.c src/m68k/sysv.S\n-endif\n-if POWERPC\n-nodist_libffi_la_SOURCES += src/powerpc/ffi.c src/powerpc/ffi_sysv.c src/powerpc/ffi_linux64.c src/powerpc/sysv.S src/powerpc/ppc_closure.S src/powerpc/linux64.S src/powerpc/linux64_closure.S\n-endif\n-if POWERPC_AIX\n-nodist_libffi_la_SOURCES += src/powerpc/ffi_darwin.c src/powerpc/aix.S src/powerpc/aix_closure.S\n-endif\n-if POWERPC_DARWIN\n-nodist_libffi_la_SOURCES += src/powerpc/ffi_darwin.c src/powerpc/darwin.S src/powerpc/darwin_closure.S\n-endif\n-if POWERPC_FREEBSD\n-nodist_libffi_la_SOURCES += src/powerpc/ffi.c src/powerpc/ffi_sysv.c src/powerpc/sysv.S src/powerpc/ppc_closure.S\n-endif\n-if AARCH64\n-nodist_libffi_la_SOURCES += src/aarch64/sysv.S src/aarch64/ffi.c\n-endif\n-if ARM\n-nodist_libffi_la_SOURCES += src/arm/sysv.S src/arm/ffi.c\n-if FFI_EXEC_TRAMPOLINE_TABLE\n-nodist_libffi_la_SOURCES += src/arm/trampoline.S\n-endif\n-endif\n-if AVR32\n-nodist_libffi_la_SOURCES += src/avr32/sysv.S src/avr32/ffi.c\n-endif\n-if LIBFFI_CRIS\n-nodist_libffi_la_SOURCES += src/cris/sysv.S src/cris/ffi.c\n-endif\n-if FRV\n-nodist_libffi_la_SOURCES += src/frv/eabi.S src/frv/ffi.c\n-endif\n-if S390\n-nodist_libffi_la_SOURCES += src/s390/sysv.S src/s390/ffi.c\n-endif\n-if X86_64\n-nodist_libffi_la_SOURCES += src/x86/ffi64.c src/x86/unix64.S src/x86/ffi.c src/x86/sysv.S\n-endif\n-if SH\n-nodist_libffi_la_SOURCES += src/sh/sysv.S src/sh/ffi.c\n-endif\n-if SH64\n-nodist_libffi_la_SOURCES += src/sh64/sysv.S src/sh64/ffi.c\n-endif\n-if PA_LINUX\n-nodist_libffi_la_SOURCES += src/pa/linux.S src/pa/ffi.c\n-endif\n-if PA_HPUX\n-nodist_libffi_la_SOURCES += src/pa/hpux32.S src/pa/ffi.c\n-endif\n-if TILE\n-nodist_libffi_la_SOURCES += src/tile/tile.S src/tile/ffi.c\n-endif\n+libffi_la_SOURCES += src/debug.c\n+endif\n+\n+noinst_HEADERS = \\\n+\tsrc/aarch64/ffitarget.h src/aarch64/internal.h\t\t\t\\\n+\tsrc/alpha/ffitarget.h src/alpha/internal.h\t\t\t\\\n+\tsrc/arc/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/arm/ffitarget.h src/arm/internal.h\t\t\t\t\\\n+\tsrc/avr32/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/bfin/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/cris/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/frv/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/ia64/ffitarget.h src/ia64/ia64_flags.h\t\t\t\\\n+\tsrc/m32r/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/m68k/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/m88k/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/metag/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/microblaze/ffitarget.h\t\t\t\t\t\\\n+\tsrc/mips/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/moxie/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/nios2/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/or1k/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/pa/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/powerpc/ffitarget.h src/powerpc/asm.h src/powerpc/ffi_powerpc.h \\\n+\tsrc/s390/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/sh/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/sh64/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/sparc/ffitarget.h src/sparc/internal.h\t\t\t\\\n+\tsrc/tile/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/vax/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/x86/ffitarget.h src/x86/internal.h src/x86/internal64.h\t\\\n+\tsrc/xtensa/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/dlmalloc.c\n+\n+EXTRA_libffi_la_SOURCES = \\\n+\tsrc/aarch64/ffi.c src/aarch64/sysv.S\t\t\t\t\\\n+\tsrc/alpha/ffi.c src/alpha/osf.S\t\t\t\t\t\\\n+\tsrc/arc/ffi.c src/arc/arcompact.S\t\t\t\t\\\n+\tsrc/arm/ffi.c src/arm/sysv.S\t\t\t\t\t\\\n+\tsrc/avr32/ffi.c src/avr32/sysv.S\t\t\t\t\\\n+\tsrc/bfin/ffi.c src/bfin/sysv.S\t\t\t\t\t\\\n+\tsrc/cris/ffi.c src/cris/sysv.S\t\t\t\t\t\\\n+\tsrc/frv/ffi.c src/frv/eabi.S\t\t\t\t\t\\\n+\tsrc/ia64/ffi.c src/ia64/unix.S\t\t\t\t\t\\\n+\tsrc/m32r/ffi.c src/m32r/sysv.S\t\t\t\t\t\\\n+\tsrc/m68k/ffi.c src/m68k/sysv.S\t\t\t\t\t\\\n+\tsrc/m88k/ffi.c src/m88k/obsd.S\t\t\t\t\t\\\n+\tsrc/metag/ffi.c src/metag/sysv.S\t\t\t\t\\\n+\tsrc/microblaze/ffi.c src/microblaze/sysv.S\t\t\t\\\n+\tsrc/mips/ffi.c src/mips/o32.S src/mips/n32.S\t\t\t\\\n+\tsrc/moxie/ffi.c src/moxie/eabi.S\t\t\t\t\\\n+\tsrc/nios2/ffi.c src/nios2/sysv.S\t\t\t\t\\\n+\tsrc/or1k/ffi.c src/or1k/sysv.S\t\t\t\t\t\\\n+\tsrc/pa/ffi.c src/pa/linux.S src/pa/hpux32.S\t\t\t\\\n+\tsrc/powerpc/ffi.c src/powerpc/ffi_sysv.c src/powerpc/ffi_linux64.c \\\n+\t src/powerpc/sysv.S src/powerpc/linux64.S\t\t\t\\\n+\t src/powerpc/linux64_closure.S src/powerpc/ppc_closure.S\t\\\n+\t src/powerpc/aix.S src/powerpc/darwin.S src/powerpc/aix_closure.S \\\n+\t src/powerpc/darwin_closure.S src/powerpc/ffi_darwin.c\t\t\\\n+\tsrc/s390/ffi.c src/s390/sysv.S\t\t\t\t\t\\\n+\tsrc/sh/ffi.c src/sh/sysv.S\t\t\t\t\t\\\n+\tsrc/sh64/ffi.c src/sh64/sysv.S\t\t\t\t\t\\\n+\tsrc/sparc/ffi.c src/sparc/ffi64.c src/sparc/v8.S src/sparc/v9.S\t\\\n+\tsrc/tile/ffi.c src/tile/tile.S\t\t\t\t\t\\\n+\tsrc/vax/ffi.c src/vax/elfbsd.S\t\t\t\t\t\\\n+\tsrc/x86/ffi.c src/x86/sysv.S\t\t\t\t\t\\\n+\t src/x86/ffiw64.c src/x86/win64.S \t\t\t\t\\\n+\t src/x86/ffi64.c src/x86/unix64.S\t\t\t\t\\\n+\t src/x86/darwin64.S src/x86/darwin.S\t\t\t\t\\\n+\t src/x86/darwin64_c.c src/x86/darwin_c.c\t\t\t\\\n+\tsrc/xtensa/ffi.c src/xtensa/sysv.S\n+\n+TARGET_OBJ = @TARGET_OBJ@\n+libffi_la_LIBADD = $(TARGET_OBJ)\n+libffi_la_DEPENDENCIES = $(TARGET_OBJ)\n \n libffi_convenience_la_SOURCES = $(libffi_la_SOURCES)\n+EXTRA_libffi_convenience_la_SOURCES = $(EXTRA_libffi_la_SOURCES)\n+libffi_convenience_la_LIBADD = $(libffi_la_LIBADD)\n+libffi_convenience_la_DEPENDENCIES = $(libffi_la_DEPENDENCIES)\n nodist_libffi_convenience_la_SOURCES = $(nodist_libffi_la_SOURCES)\n \n-AM_CFLAGS = -Wall -g -fexceptions\n-\n LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS))\n \n-libffi_la_LDFLAGS = -version-info `grep -v '^\\#' $(srcdir)/libtool-version` $(LTLDFLAGS) $(AM_LTLDFLAGS)\n+AM_CFLAGS = -Wall -g -fexceptions\n+if FFI_DEBUG\n+# Build debug. Define FFI_DEBUG on the commandline so that, when building with\n+# MSVC, it can link against the debug CRT.\n+AM_CFLAGS += -DFFI_DEBUG\n+endif\n+\n+libffi_la_LDFLAGS = -no-undefined -version-info `grep -v '^\\#' $(srcdir)/libtool-version` $(LTLDFLAGS) $(AM_LTLDFLAGS)\n \n AM_CPPFLAGS = -I. -I$(top_srcdir)/include -Iinclude -I$(top_srcdir)/src\n AM_CCASFLAGS = $(AM_CPPFLAGS)"}, {"sha": "80ad274cef30590431038db714c129bd4e829d52", "filename": "libffi/Makefile.in", "status": "modified", "additions": 501, "deletions": 347, "changes": 848, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.in?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -15,6 +15,8 @@\n \n @SET_MAKE@\n \n+\n+\n VPATH = @srcdir@\n pkgdatadir = $(datadir)/@PACKAGE@\n pkgincludedir = $(includedir)/@PACKAGE@\n@@ -36,41 +38,16 @@ build_triplet = @build@\n host_triplet = @host@\n target_triplet = @target@\n @FFI_DEBUG_TRUE@am__append_1 = src/debug.c\n-@MIPS_TRUE@am__append_2 = src/mips/ffi.c src/mips/o32.S src/mips/n32.S\n-@BFIN_TRUE@am__append_3 = src/bfin/ffi.c src/bfin/sysv.S\n-@X86_TRUE@am__append_4 = src/x86/ffi.c src/x86/sysv.S\n-@X86_FREEBSD_TRUE@am__append_5 = src/x86/ffi.c src/x86/freebsd.S\n-@X86_WIN32_TRUE@am__append_6 = src/x86/ffi.c src/x86/win32.S\n-@X86_WIN64_TRUE@am__append_7 = src/x86/ffi.c src/x86/win64.S\n-@X86_DARWIN_TRUE@am__append_8 = src/x86/ffi.c src/x86/darwin.S src/x86/ffi64.c src/x86/darwin64.S\n-@SPARC_TRUE@am__append_9 = src/sparc/ffi.c src/sparc/v8.S src/sparc/v9.S\n-@ALPHA_TRUE@am__append_10 = src/alpha/ffi.c src/alpha/osf.S\n-@IA64_TRUE@am__append_11 = src/ia64/ffi.c src/ia64/unix.S\n-@M32R_TRUE@am__append_12 = src/m32r/sysv.S src/m32r/ffi.c\n-@M68K_TRUE@am__append_13 = src/m68k/ffi.c src/m68k/sysv.S\n-@POWERPC_TRUE@am__append_14 = src/powerpc/ffi.c src/powerpc/ffi_sysv.c src/powerpc/ffi_linux64.c src/powerpc/sysv.S src/powerpc/ppc_closure.S src/powerpc/linux64.S src/powerpc/linux64_closure.S\n-@POWERPC_AIX_TRUE@am__append_15 = src/powerpc/ffi_darwin.c src/powerpc/aix.S src/powerpc/aix_closure.S\n-@POWERPC_DARWIN_TRUE@am__append_16 = src/powerpc/ffi_darwin.c src/powerpc/darwin.S src/powerpc/darwin_closure.S\n-@POWERPC_FREEBSD_TRUE@am__append_17 = src/powerpc/ffi.c src/powerpc/ffi_sysv.c src/powerpc/sysv.S src/powerpc/ppc_closure.S\n-@AARCH64_TRUE@am__append_18 = src/aarch64/sysv.S src/aarch64/ffi.c\n-@ARM_TRUE@am__append_19 = src/arm/sysv.S src/arm/ffi.c\n-@ARM_TRUE@@FFI_EXEC_TRAMPOLINE_TABLE_TRUE@am__append_20 = src/arm/trampoline.S\n-@AVR32_TRUE@am__append_21 = src/avr32/sysv.S src/avr32/ffi.c\n-@LIBFFI_CRIS_TRUE@am__append_22 = src/cris/sysv.S src/cris/ffi.c\n-@FRV_TRUE@am__append_23 = src/frv/eabi.S src/frv/ffi.c\n-@S390_TRUE@am__append_24 = src/s390/sysv.S src/s390/ffi.c\n-@X86_64_TRUE@am__append_25 = src/x86/ffi64.c src/x86/unix64.S src/x86/ffi.c src/x86/sysv.S\n-@SH_TRUE@am__append_26 = src/sh/sysv.S src/sh/ffi.c\n-@SH64_TRUE@am__append_27 = src/sh64/sysv.S src/sh64/ffi.c\n-@PA_LINUX_TRUE@am__append_28 = src/pa/linux.S src/pa/ffi.c\n-@PA_HPUX_TRUE@am__append_29 = src/pa/hpux32.S src/pa/ffi.c\n-@TILE_TRUE@am__append_30 = src/tile/tile.S src/tile/ffi.c\n+# Build debug. Define FFI_DEBUG on the commandline so that, when building with\n+# MSVC, it can link against the debug CRT.\n+@FFI_DEBUG_TRUE@am__append_2 = -DFFI_DEBUG\n subdir = .\n DIST_COMMON = README ChangeLog $(srcdir)/Makefile.in \\\n \t$(srcdir)/Makefile.am $(top_srcdir)/configure \\\n \t$(am__configure_deps) $(srcdir)/fficonfig.h.in \\\n-\t$(srcdir)/../mkinstalldirs $(srcdir)/../depcomp mdate-sh \\\n-\t$(srcdir)/doc/version.texi $(srcdir)/doc/stamp-vti\n+\t$(srcdir)/../mkinstalldirs $(srcdir)/libffi.pc.in \\\n+\t$(srcdir)/../depcomp mdate-sh $(srcdir)/doc/version.texi \\\n+\t$(srcdir)/doc/stamp-vti $(noinst_HEADERS)\n ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \\\n \t$(top_srcdir)/../config/asmcfi.m4 \\\n@@ -88,7 +65,7 @@ am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \\\n  configure.lineno config.status.lineno\n mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n CONFIG_HEADER = fficonfig.h\n-CONFIG_CLEAN_FILES =\n+CONFIG_CLEAN_FILES = libffi.pc\n CONFIG_CLEAN_VPATH_FILES =\n am__vpath_adj_setup = srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`;\n am__vpath_adj = case $$p in \\\n@@ -111,89 +88,23 @@ am__nobase_list = $(am__nobase_strip_setup); \\\n am__base_list = \\\n   sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\\n/ /g' | \\\n   sed '$$!N;$$!N;$$!N;$$!N;s/\\n/ /g'\n-am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(infodir)\"\n+am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(infodir)\" \\\n+\t\"$(DESTDIR)$(pkgconfigdir)\"\n LTLIBRARIES = $(noinst_LTLIBRARIES) $(toolexeclib_LTLIBRARIES)\n-libffi_la_LIBADD =\n+am__DEPENDENCIES_1 =\n am__dirstamp = $(am__leading_dot)dirstamp\n-am_libffi_la_OBJECTS = src/prep_cif.lo src/types.lo src/raw_api.lo \\\n-\tsrc/java_raw_api.lo src/closures.lo\n @FFI_DEBUG_TRUE@am__objects_1 = src/debug.lo\n-@MIPS_TRUE@am__objects_2 = src/mips/ffi.lo src/mips/o32.lo \\\n-@MIPS_TRUE@\tsrc/mips/n32.lo\n-@BFIN_TRUE@am__objects_3 = src/bfin/ffi.lo src/bfin/sysv.lo\n-@X86_TRUE@am__objects_4 = src/x86/ffi.lo src/x86/sysv.lo\n-@X86_FREEBSD_TRUE@am__objects_5 = src/x86/ffi.lo src/x86/freebsd.lo\n-@X86_WIN32_TRUE@am__objects_6 = src/x86/ffi.lo src/x86/win32.lo\n-@X86_WIN64_TRUE@am__objects_7 = src/x86/ffi.lo src/x86/win64.lo\n-@X86_DARWIN_TRUE@am__objects_8 = src/x86/ffi.lo src/x86/darwin.lo \\\n-@X86_DARWIN_TRUE@\tsrc/x86/ffi64.lo src/x86/darwin64.lo\n-@SPARC_TRUE@am__objects_9 = src/sparc/ffi.lo src/sparc/v8.lo \\\n-@SPARC_TRUE@\tsrc/sparc/v9.lo\n-@ALPHA_TRUE@am__objects_10 = src/alpha/ffi.lo src/alpha/osf.lo\n-@IA64_TRUE@am__objects_11 = src/ia64/ffi.lo src/ia64/unix.lo\n-@M32R_TRUE@am__objects_12 = src/m32r/sysv.lo src/m32r/ffi.lo\n-@M68K_TRUE@am__objects_13 = src/m68k/ffi.lo src/m68k/sysv.lo\n-@POWERPC_TRUE@am__objects_14 = src/powerpc/ffi.lo \\\n-@POWERPC_TRUE@\tsrc/powerpc/ffi_sysv.lo \\\n-@POWERPC_TRUE@\tsrc/powerpc/ffi_linux64.lo src/powerpc/sysv.lo \\\n-@POWERPC_TRUE@\tsrc/powerpc/ppc_closure.lo \\\n-@POWERPC_TRUE@\tsrc/powerpc/linux64.lo \\\n-@POWERPC_TRUE@\tsrc/powerpc/linux64_closure.lo\n-@POWERPC_AIX_TRUE@am__objects_15 = src/powerpc/ffi_darwin.lo \\\n-@POWERPC_AIX_TRUE@\tsrc/powerpc/aix.lo \\\n-@POWERPC_AIX_TRUE@\tsrc/powerpc/aix_closure.lo\n-@POWERPC_DARWIN_TRUE@am__objects_16 = src/powerpc/ffi_darwin.lo \\\n-@POWERPC_DARWIN_TRUE@\tsrc/powerpc/darwin.lo \\\n-@POWERPC_DARWIN_TRUE@\tsrc/powerpc/darwin_closure.lo\n-@POWERPC_FREEBSD_TRUE@am__objects_17 = src/powerpc/ffi.lo \\\n-@POWERPC_FREEBSD_TRUE@\tsrc/powerpc/ffi_sysv.lo \\\n-@POWERPC_FREEBSD_TRUE@\tsrc/powerpc/sysv.lo \\\n-@POWERPC_FREEBSD_TRUE@\tsrc/powerpc/ppc_closure.lo\n-@AARCH64_TRUE@am__objects_18 = src/aarch64/sysv.lo src/aarch64/ffi.lo\n-@ARM_TRUE@am__objects_19 = src/arm/sysv.lo src/arm/ffi.lo\n-@ARM_TRUE@@FFI_EXEC_TRAMPOLINE_TABLE_TRUE@am__objects_20 = src/arm/trampoline.lo\n-@AVR32_TRUE@am__objects_21 = src/avr32/sysv.lo src/avr32/ffi.lo\n-@LIBFFI_CRIS_TRUE@am__objects_22 = src/cris/sysv.lo src/cris/ffi.lo\n-@FRV_TRUE@am__objects_23 = src/frv/eabi.lo src/frv/ffi.lo\n-@S390_TRUE@am__objects_24 = src/s390/sysv.lo src/s390/ffi.lo\n-@X86_64_TRUE@am__objects_25 = src/x86/ffi64.lo src/x86/unix64.lo \\\n-@X86_64_TRUE@\tsrc/x86/ffi.lo src/x86/sysv.lo\n-@SH_TRUE@am__objects_26 = src/sh/sysv.lo src/sh/ffi.lo\n-@SH64_TRUE@am__objects_27 = src/sh64/sysv.lo src/sh64/ffi.lo\n-@PA_LINUX_TRUE@am__objects_28 = src/pa/linux.lo src/pa/ffi.lo\n-@PA_HPUX_TRUE@am__objects_29 = src/pa/hpux32.lo src/pa/ffi.lo\n-@TILE_TRUE@am__objects_30 = src/tile/tile.lo src/tile/ffi.lo\n-nodist_libffi_la_OBJECTS = $(am__objects_1) $(am__objects_2) \\\n-\t$(am__objects_3) $(am__objects_4) $(am__objects_5) \\\n-\t$(am__objects_6) $(am__objects_7) $(am__objects_8) \\\n-\t$(am__objects_9) $(am__objects_10) $(am__objects_11) \\\n-\t$(am__objects_12) $(am__objects_13) $(am__objects_14) \\\n-\t$(am__objects_15) $(am__objects_16) $(am__objects_17) \\\n-\t$(am__objects_18) $(am__objects_19) $(am__objects_20) \\\n-\t$(am__objects_21) $(am__objects_22) $(am__objects_23) \\\n-\t$(am__objects_24) $(am__objects_25) $(am__objects_26) \\\n-\t$(am__objects_27) $(am__objects_28) $(am__objects_29) \\\n-\t$(am__objects_30)\n-libffi_la_OBJECTS = $(am_libffi_la_OBJECTS) \\\n-\t$(nodist_libffi_la_OBJECTS)\n+am_libffi_la_OBJECTS = src/prep_cif.lo src/types.lo src/raw_api.lo \\\n+\tsrc/java_raw_api.lo src/closures.lo $(am__objects_1)\n+libffi_la_OBJECTS = $(am_libffi_la_OBJECTS)\n libffi_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \\\n \t$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \\\n \t$(libffi_la_LDFLAGS) $(LDFLAGS) -o $@\n-libffi_convenience_la_LIBADD =\n-am__objects_31 = src/prep_cif.lo src/types.lo src/raw_api.lo \\\n-\tsrc/java_raw_api.lo src/closures.lo\n-am_libffi_convenience_la_OBJECTS = $(am__objects_31)\n-am__objects_32 = $(am__objects_1) $(am__objects_2) $(am__objects_3) \\\n-\t$(am__objects_4) $(am__objects_5) $(am__objects_6) \\\n-\t$(am__objects_7) $(am__objects_8) $(am__objects_9) \\\n-\t$(am__objects_10) $(am__objects_11) $(am__objects_12) \\\n-\t$(am__objects_13) $(am__objects_14) $(am__objects_15) \\\n-\t$(am__objects_16) $(am__objects_17) $(am__objects_18) \\\n-\t$(am__objects_19) $(am__objects_20) $(am__objects_21) \\\n-\t$(am__objects_22) $(am__objects_23) $(am__objects_24) \\\n-\t$(am__objects_25) $(am__objects_26) $(am__objects_27) \\\n-\t$(am__objects_28) $(am__objects_29) $(am__objects_30)\n-nodist_libffi_convenience_la_OBJECTS = $(am__objects_32)\n+am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)\n+am__objects_2 = src/prep_cif.lo src/types.lo src/raw_api.lo \\\n+\tsrc/java_raw_api.lo src/closures.lo $(am__objects_1)\n+am_libffi_convenience_la_OBJECTS = $(am__objects_2)\n+nodist_libffi_convenience_la_OBJECTS =\n libffi_convenience_la_OBJECTS = $(am_libffi_convenience_la_OBJECTS) \\\n \t$(nodist_libffi_convenience_la_OBJECTS)\n DEFAULT_INCLUDES = -I.@am__isrc@\n@@ -214,8 +125,9 @@ CCLD = $(CC)\n LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n \t--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n \t$(LDFLAGS) -o $@\n-SOURCES = $(libffi_la_SOURCES) $(nodist_libffi_la_SOURCES) \\\n+SOURCES = $(libffi_la_SOURCES) $(EXTRA_libffi_la_SOURCES) \\\n \t$(libffi_convenience_la_SOURCES) \\\n+\t$(EXTRA_libffi_convenience_la_SOURCES) \\\n \t$(nodist_libffi_convenience_la_SOURCES)\n MULTISRCTOP = \n MULTIBUILDTOP = \n@@ -242,6 +154,8 @@ RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \\\n \tinstall-pdf-recursive install-ps-recursive install-recursive \\\n \tinstallcheck-recursive installdirs-recursive pdf-recursive \\\n \tps-recursive uninstall-recursive\n+DATA = $(pkgconfig_DATA)\n+HEADERS = $(noinst_HEADERS)\n RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive\t\\\n   distclean-recursive maintainer-clean-recursive\n AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \\\n@@ -267,6 +181,10 @@ CCDEPMODE = @CCDEPMODE@\n CFLAGS = @CFLAGS@\n CPP = @CPP@\n CPPFLAGS = @CPPFLAGS@\n+CXX = @CXX@\n+CXXCPP = @CXXCPP@\n+CXXDEPMODE = @CXXDEPMODE@\n+CXXFLAGS = @CXXFLAGS@\n CYGPATH_W = @CYGPATH_W@\n DEFS = @DEFS@\n DEPDIR = @DEPDIR@\n@@ -319,12 +237,14 @@ SHELL = @SHELL@\n STRIP = @STRIP@\n TARGET = @TARGET@\n TARGETDIR = @TARGETDIR@\n+TARGET_OBJ = @TARGET_OBJ@\n VERSION = @VERSION@\n abs_builddir = @abs_builddir@\n abs_srcdir = @abs_srcdir@\n abs_top_builddir = @abs_top_builddir@\n abs_top_srcdir = @abs_top_srcdir@\n ac_ct_CC = @ac_ct_CC@\n+ac_ct_CXX = @ac_ct_CXX@\n ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n am__include = @am__include@\n am__leading_dot = @am__leading_dot@\n@@ -381,42 +301,14 @@ top_srcdir = @top_srcdir@\n AUTOMAKE_OPTIONS = foreign subdir-objects\n ACLOCAL_AMFLAGS = -I .. -I ../config\n SUBDIRS = include testsuite man\n-EXTRA_DIST = LICENSE ChangeLog.v1 ChangeLog.libgcj configure.host\t\\\n-\t src/aarch64/ffi.c src/aarch64/ffitarget.h\t\t\t\\\n-\t src/alpha/ffi.c src/alpha/osf.S src/alpha/ffitarget.h\t\t\\\n-\t src/arm/ffi.c src/arm/sysv.S src/arm/ffitarget.h\t\t\\\n-\t src/avr32/ffi.c src/avr32/sysv.S src/avr32/ffitarget.h\t\t\\\n-\t src/cris/ffi.c src/cris/sysv.S src/cris/ffitarget.h\t\t\\\n-\t src/ia64/ffi.c src/ia64/ffitarget.h src/ia64/ia64_flags.h\t\\\n-\t src/ia64/unix.S src/mips/ffi.c src/mips/n32.S src/mips/o32.S\t\\\n-\t src/mips/ffitarget.h src/m32r/ffi.c src/m32r/sysv.S\t\t\\\n-\t src/m32r/ffitarget.h src/m68k/ffi.c src/m68k/sysv.S\t\t\\\n-\t src/m68k/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/powerpc/ffi.c src/powerpc/ffi_powerpc.h\t\t\t\\\n-\tsrc/powerpc/ffi_sysv.c src/powerpc/ffi_linux64.c\t\t\\\n-\tsrc/powerpc/sysv.S src/powerpc/linux64.S\t\t\t\\\n-\tsrc/powerpc/linux64_closure.S src/powerpc/ppc_closure.S\t\t\\\n-\tsrc/powerpc/asm.h src/powerpc/aix.S src/powerpc/darwin.S\t\\\n-\tsrc/powerpc/aix_closure.S src/powerpc/darwin_closure.S\t\t\\\n-\tsrc/powerpc/ffi_darwin.c src/powerpc/ffitarget.h\t\t\\\n-\tsrc/s390/ffi.c src/s390/sysv.S src/s390/ffitarget.h\t\t\\\n-\tsrc/sh/ffi.c src/sh/sysv.S src/sh/ffitarget.h src/sh64/ffi.c\t\\\n-\tsrc/sh64/sysv.S src/sh64/ffitarget.h src/sparc/v8.S\t\t\\\n-\tsrc/sparc/v9.S src/sparc/ffitarget.h src/sparc/ffi.c\t\t\\\n-\tsrc/x86/darwin64.S src/x86/ffi.c src/x86/sysv.S\t\t\t\\\n-\tsrc/x86/win32.S src/x86/darwin.S src/x86/win64.S\t\t\\\n-\tsrc/x86/freebsd.S src/x86/ffi64.c src/x86/unix64.S\t\t\\\n-\tsrc/x86/ffitarget.h src/pa/ffitarget.h src/pa/ffi.c\t\t\\\n-\tsrc/pa/linux.S src/pa/hpux32.S src/frv/ffi.c src/bfin/ffi.c\t\\\n-\tsrc/bfin/ffitarget.h src/bfin/sysv.S src/frv/eabi.S\t\t\\\n-\tsrc/frv/ffitarget.h src/dlmalloc.c src/tile/ffi.c\t\t\\\n-\tsrc/tile/ffitarget.h src/tile/tile.S libtool-version\t\t\\\n-\t ChangeLog.libffi m4/libtool.m4 m4/lt~obsolete.m4\t\t\\\n+EXTRA_DIST = LICENSE ChangeLog.v1 ChangeLog.libgcj\t\t\t\\\n+\tChangeLog.libffi ChangeLog.libffi-3.1\t\t\t\t\\\n+\tm4/libtool.m4 m4/lt~obsolete.m4\t\t\t\t\t\\\n \t m4/ltoptions.m4 m4/ltsugar.m4 m4/ltversion.m4\t\t\t\\\n-\t m4/ltversion.m4 src/arm/gentramp.sh src/debug.c msvcc.sh\t\\\n-\tgenerate-ios-source-and-headers.py\t\t\t\t\\\n-\t generate-osx-source-and-headers.py\t\t\t\t\\\n-\t libffi.xcodeproj/project.pbxproj src/arm/trampoline.S\n+\t m4/ltversion.m4 src/debug.c msvcc.sh\t\t\t\t\\\n+\tgenerate-darwin-source-and-headers.py\t\t\t\t\\\n+\tlibffi.xcodeproj/project.pbxproj\t\t\t\t\\\n+\tlibtool-ldflags\n \n \n # Automake Documentation:\n@@ -444,65 +336,129 @@ MAINTAINERCLEANFILES = $(srcdir)/doc/libffi.info\n # values defined in terms of make variables, as is the case for CC and\n # friends when we are called from the top level Makefile.\n AM_MAKEFLAGS = \\\n-\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n-\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n-\t\"CFLAGS=$(CFLAGS)\" \\\n-\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n-\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n-\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n-\t\"INSTALL=$(INSTALL)\" \\\n-\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n-\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n-\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n-\t\"JC1FLAGS=$(JC1FLAGS)\" \\\n-\t\"LDFLAGS=$(LDFLAGS)\" \\\n-\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n-\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n-\t\"MAKE=$(MAKE)\" \\\n-\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n-\t\"PICFLAG=$(PICFLAG)\" \\\n-\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n-\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n-\t\"SHELL=$(SHELL)\" \\\n-\t\"exec_prefix=$(exec_prefix)\" \\\n-\t\"infodir=$(infodir)\" \\\n-\t\"libdir=$(libdir)\" \\\n-\t\"mandir=$(mandir)\" \\\n-\t\"prefix=$(prefix)\" \\\n-\t\"AR=$(AR)\" \\\n-\t\"AS=$(AS)\" \\\n-\t\"CC=$(CC)\" \\\n-\t\"CXX=$(CXX)\" \\\n-\t\"LD=$(LD)\" \\\n-\t\"NM=$(NM)\" \\\n-\t\"RANLIB=$(RANLIB)\" \\\n-\t\"DESTDIR=$(DESTDIR)\"\n+\t'AR_FLAGS=$(AR_FLAGS)' \\\n+\t'CC_FOR_BUILD=$(CC_FOR_BUILD)' \\\n+\t'CFLAGS=$(CFLAGS)' \\\n+\t'CXXFLAGS=$(CXXFLAGS)' \\\n+\t'CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)' \\\n+\t'CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)' \\\n+\t'INSTALL=$(INSTALL)' \\\n+\t'INSTALL_DATA=$(INSTALL_DATA)' \\\n+\t'INSTALL_PROGRAM=$(INSTALL_PROGRAM)' \\\n+\t'INSTALL_SCRIPT=$(INSTALL_SCRIPT)' \\\n+\t'JC1FLAGS=$(JC1FLAGS)' \\\n+\t'LDFLAGS=$(LDFLAGS)' \\\n+\t'LIBCFLAGS=$(LIBCFLAGS)' \\\n+\t'LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)' \\\n+\t'MAKE=$(MAKE)' \\\n+\t'MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)' \\\n+\t'PICFLAG=$(PICFLAG)' \\\n+\t'PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)' \\\n+\t'RUNTESTFLAGS=$(RUNTESTFLAGS)' \\\n+\t'SHELL=$(SHELL)' \\\n+\t'exec_prefix=$(exec_prefix)' \\\n+\t'infodir=$(infodir)' \\\n+\t'libdir=$(libdir)' \\\n+\t'mandir=$(mandir)' \\\n+\t'prefix=$(prefix)' \\\n+\t'AR=$(AR)' \\\n+\t'AS=$(AS)' \\\n+\t'CC=$(CC)' \\\n+\t'CXX=$(CXX)' \\\n+\t'LD=$(LD)' \\\n+\t'NM=$(NM)' \\\n+\t'RANLIB=$(RANLIB)' \\\n+\t'DESTDIR=$(DESTDIR)'\n \n \n # Subdir rules rely on $(FLAGS_TO_PASS)\n FLAGS_TO_PASS = $(AM_MAKEFLAGS)\n MAKEOVERRIDES = \n+pkgconfigdir = $(libdir)/pkgconfig\n+pkgconfig_DATA = libffi.pc\n toolexeclib_LTLIBRARIES = libffi.la\n noinst_LTLIBRARIES = libffi_convenience.la\n-libffi_la_SOURCES = src/prep_cif.c src/types.c \\\n-\t\tsrc/raw_api.c src/java_raw_api.c src/closures.c\n-\n-nodist_libffi_la_SOURCES = $(am__append_1) $(am__append_2) \\\n-\t$(am__append_3) $(am__append_4) $(am__append_5) \\\n-\t$(am__append_6) $(am__append_7) $(am__append_8) \\\n-\t$(am__append_9) $(am__append_10) $(am__append_11) \\\n-\t$(am__append_12) $(am__append_13) $(am__append_14) \\\n-\t$(am__append_15) $(am__append_16) $(am__append_17) \\\n-\t$(am__append_18) $(am__append_19) $(am__append_20) \\\n-\t$(am__append_21) $(am__append_22) $(am__append_23) \\\n-\t$(am__append_24) $(am__append_25) $(am__append_26) \\\n-\t$(am__append_27) $(am__append_28) $(am__append_29) \\\n-\t$(am__append_30)\n+libffi_la_SOURCES = src/prep_cif.c src/types.c src/raw_api.c \\\n+\tsrc/java_raw_api.c src/closures.c $(am__append_1)\n+noinst_HEADERS = \\\n+\tsrc/aarch64/ffitarget.h src/aarch64/internal.h\t\t\t\\\n+\tsrc/alpha/ffitarget.h src/alpha/internal.h\t\t\t\\\n+\tsrc/arc/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/arm/ffitarget.h src/arm/internal.h\t\t\t\t\\\n+\tsrc/avr32/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/bfin/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/cris/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/frv/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/ia64/ffitarget.h src/ia64/ia64_flags.h\t\t\t\\\n+\tsrc/m32r/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/m68k/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/m88k/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/metag/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/microblaze/ffitarget.h\t\t\t\t\t\\\n+\tsrc/mips/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/moxie/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/nios2/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/or1k/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/pa/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/powerpc/ffitarget.h src/powerpc/asm.h src/powerpc/ffi_powerpc.h \\\n+\tsrc/s390/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/sh/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/sh64/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/sparc/ffitarget.h src/sparc/internal.h\t\t\t\\\n+\tsrc/tile/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/vax/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/x86/ffitarget.h src/x86/internal.h src/x86/internal64.h\t\\\n+\tsrc/xtensa/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/dlmalloc.c\n+\n+EXTRA_libffi_la_SOURCES = \\\n+\tsrc/aarch64/ffi.c src/aarch64/sysv.S\t\t\t\t\\\n+\tsrc/alpha/ffi.c src/alpha/osf.S\t\t\t\t\t\\\n+\tsrc/arc/ffi.c src/arc/arcompact.S\t\t\t\t\\\n+\tsrc/arm/ffi.c src/arm/sysv.S\t\t\t\t\t\\\n+\tsrc/avr32/ffi.c src/avr32/sysv.S\t\t\t\t\\\n+\tsrc/bfin/ffi.c src/bfin/sysv.S\t\t\t\t\t\\\n+\tsrc/cris/ffi.c src/cris/sysv.S\t\t\t\t\t\\\n+\tsrc/frv/ffi.c src/frv/eabi.S\t\t\t\t\t\\\n+\tsrc/ia64/ffi.c src/ia64/unix.S\t\t\t\t\t\\\n+\tsrc/m32r/ffi.c src/m32r/sysv.S\t\t\t\t\t\\\n+\tsrc/m68k/ffi.c src/m68k/sysv.S\t\t\t\t\t\\\n+\tsrc/m88k/ffi.c src/m88k/obsd.S\t\t\t\t\t\\\n+\tsrc/metag/ffi.c src/metag/sysv.S\t\t\t\t\\\n+\tsrc/microblaze/ffi.c src/microblaze/sysv.S\t\t\t\\\n+\tsrc/mips/ffi.c src/mips/o32.S src/mips/n32.S\t\t\t\\\n+\tsrc/moxie/ffi.c src/moxie/eabi.S\t\t\t\t\\\n+\tsrc/nios2/ffi.c src/nios2/sysv.S\t\t\t\t\\\n+\tsrc/or1k/ffi.c src/or1k/sysv.S\t\t\t\t\t\\\n+\tsrc/pa/ffi.c src/pa/linux.S src/pa/hpux32.S\t\t\t\\\n+\tsrc/powerpc/ffi.c src/powerpc/ffi_sysv.c src/powerpc/ffi_linux64.c \\\n+\t src/powerpc/sysv.S src/powerpc/linux64.S\t\t\t\\\n+\t src/powerpc/linux64_closure.S src/powerpc/ppc_closure.S\t\\\n+\t src/powerpc/aix.S src/powerpc/darwin.S src/powerpc/aix_closure.S \\\n+\t src/powerpc/darwin_closure.S src/powerpc/ffi_darwin.c\t\t\\\n+\tsrc/s390/ffi.c src/s390/sysv.S\t\t\t\t\t\\\n+\tsrc/sh/ffi.c src/sh/sysv.S\t\t\t\t\t\\\n+\tsrc/sh64/ffi.c src/sh64/sysv.S\t\t\t\t\t\\\n+\tsrc/sparc/ffi.c src/sparc/ffi64.c src/sparc/v8.S src/sparc/v9.S\t\\\n+\tsrc/tile/ffi.c src/tile/tile.S\t\t\t\t\t\\\n+\tsrc/vax/ffi.c src/vax/elfbsd.S\t\t\t\t\t\\\n+\tsrc/x86/ffi.c src/x86/sysv.S\t\t\t\t\t\\\n+\t src/x86/ffiw64.c src/x86/win64.S \t\t\t\t\\\n+\t src/x86/ffi64.c src/x86/unix64.S\t\t\t\t\\\n+\t src/x86/darwin64.S src/x86/darwin.S\t\t\t\t\\\n+\t src/x86/darwin64_c.c src/x86/darwin_c.c\t\t\t\\\n+\tsrc/xtensa/ffi.c src/xtensa/sysv.S\n+\n+libffi_la_LIBADD = $(TARGET_OBJ)\n+libffi_la_DEPENDENCIES = $(TARGET_OBJ)\n libffi_convenience_la_SOURCES = $(libffi_la_SOURCES)\n+EXTRA_libffi_convenience_la_SOURCES = $(EXTRA_libffi_la_SOURCES)\n+libffi_convenience_la_LIBADD = $(libffi_la_LIBADD)\n+libffi_convenience_la_DEPENDENCIES = $(libffi_la_DEPENDENCIES)\n nodist_libffi_convenience_la_SOURCES = $(nodist_libffi_la_SOURCES)\n-AM_CFLAGS = -Wall -g -fexceptions\n LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS))\n-libffi_la_LDFLAGS = -version-info `grep -v '^\\#' $(srcdir)/libtool-version` $(LTLDFLAGS) $(AM_LTLDFLAGS)\n+AM_CFLAGS = -Wall -g -fexceptions $(am__append_2)\n+libffi_la_LDFLAGS = -no-undefined -version-info `grep -v '^\\#' $(srcdir)/libtool-version` $(LTLDFLAGS) $(AM_LTLDFLAGS)\n AM_CPPFLAGS = -I. -I$(top_srcdir)/include -Iinclude -I$(top_srcdir)/src\n AM_CCASFLAGS = $(AM_CPPFLAGS)\n all: fficonfig.h\n@@ -561,6 +517,8 @@ $(srcdir)/fficonfig.h.in: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n \n distclean-hdr:\n \t-rm -f fficonfig.h stamp-h1\n+libffi.pc: $(top_builddir)/config.status $(srcdir)/libffi.pc.in\n+\tcd $(top_builddir) && $(SHELL) ./config.status $@\n \n clean-noinstLTLIBRARIES:\n \t-test -z \"$(noinst_LTLIBRARIES)\" || rm -f $(noinst_LTLIBRARIES)\n@@ -613,62 +571,16 @@ src/raw_api.lo: src/$(am__dirstamp) src/$(DEPDIR)/$(am__dirstamp)\n src/java_raw_api.lo: src/$(am__dirstamp) src/$(DEPDIR)/$(am__dirstamp)\n src/closures.lo: src/$(am__dirstamp) src/$(DEPDIR)/$(am__dirstamp)\n src/debug.lo: src/$(am__dirstamp) src/$(DEPDIR)/$(am__dirstamp)\n-src/mips/$(am__dirstamp):\n-\t@$(MKDIR_P) src/mips\n-\t@: > src/mips/$(am__dirstamp)\n-src/mips/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/mips/$(DEPDIR)\n-\t@: > src/mips/$(DEPDIR)/$(am__dirstamp)\n-src/mips/ffi.lo: src/mips/$(am__dirstamp) \\\n-\tsrc/mips/$(DEPDIR)/$(am__dirstamp)\n-src/mips/o32.lo: src/mips/$(am__dirstamp) \\\n-\tsrc/mips/$(DEPDIR)/$(am__dirstamp)\n-src/mips/n32.lo: src/mips/$(am__dirstamp) \\\n-\tsrc/mips/$(DEPDIR)/$(am__dirstamp)\n-src/bfin/$(am__dirstamp):\n-\t@$(MKDIR_P) src/bfin\n-\t@: > src/bfin/$(am__dirstamp)\n-src/bfin/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/bfin/$(DEPDIR)\n-\t@: > src/bfin/$(DEPDIR)/$(am__dirstamp)\n-src/bfin/ffi.lo: src/bfin/$(am__dirstamp) \\\n-\tsrc/bfin/$(DEPDIR)/$(am__dirstamp)\n-src/bfin/sysv.lo: src/bfin/$(am__dirstamp) \\\n-\tsrc/bfin/$(DEPDIR)/$(am__dirstamp)\n-src/x86/$(am__dirstamp):\n-\t@$(MKDIR_P) src/x86\n-\t@: > src/x86/$(am__dirstamp)\n-src/x86/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/x86/$(DEPDIR)\n-\t@: > src/x86/$(DEPDIR)/$(am__dirstamp)\n-src/x86/ffi.lo: src/x86/$(am__dirstamp) \\\n-\tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n-src/x86/sysv.lo: src/x86/$(am__dirstamp) \\\n-\tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n-src/x86/freebsd.lo: src/x86/$(am__dirstamp) \\\n-\tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n-src/x86/win32.lo: src/x86/$(am__dirstamp) \\\n-\tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n-src/x86/win64.lo: src/x86/$(am__dirstamp) \\\n-\tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n-src/x86/darwin.lo: src/x86/$(am__dirstamp) \\\n-\tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n-src/x86/ffi64.lo: src/x86/$(am__dirstamp) \\\n-\tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n-src/x86/darwin64.lo: src/x86/$(am__dirstamp) \\\n-\tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n-src/sparc/$(am__dirstamp):\n-\t@$(MKDIR_P) src/sparc\n-\t@: > src/sparc/$(am__dirstamp)\n-src/sparc/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/sparc/$(DEPDIR)\n-\t@: > src/sparc/$(DEPDIR)/$(am__dirstamp)\n-src/sparc/ffi.lo: src/sparc/$(am__dirstamp) \\\n-\tsrc/sparc/$(DEPDIR)/$(am__dirstamp)\n-src/sparc/v8.lo: src/sparc/$(am__dirstamp) \\\n-\tsrc/sparc/$(DEPDIR)/$(am__dirstamp)\n-src/sparc/v9.lo: src/sparc/$(am__dirstamp) \\\n-\tsrc/sparc/$(DEPDIR)/$(am__dirstamp)\n+src/aarch64/$(am__dirstamp):\n+\t@$(MKDIR_P) src/aarch64\n+\t@: > src/aarch64/$(am__dirstamp)\n+src/aarch64/$(DEPDIR)/$(am__dirstamp):\n+\t@$(MKDIR_P) src/aarch64/$(DEPDIR)\n+\t@: > src/aarch64/$(DEPDIR)/$(am__dirstamp)\n+src/aarch64/ffi.lo: src/aarch64/$(am__dirstamp) \\\n+\tsrc/aarch64/$(DEPDIR)/$(am__dirstamp)\n+src/aarch64/sysv.lo: src/aarch64/$(am__dirstamp) \\\n+\tsrc/aarch64/$(DEPDIR)/$(am__dirstamp)\n src/alpha/$(am__dirstamp):\n \t@$(MKDIR_P) src/alpha\n \t@: > src/alpha/$(am__dirstamp)\n@@ -679,6 +591,66 @@ src/alpha/ffi.lo: src/alpha/$(am__dirstamp) \\\n \tsrc/alpha/$(DEPDIR)/$(am__dirstamp)\n src/alpha/osf.lo: src/alpha/$(am__dirstamp) \\\n \tsrc/alpha/$(DEPDIR)/$(am__dirstamp)\n+src/arc/$(am__dirstamp):\n+\t@$(MKDIR_P) src/arc\n+\t@: > src/arc/$(am__dirstamp)\n+src/arc/$(DEPDIR)/$(am__dirstamp):\n+\t@$(MKDIR_P) src/arc/$(DEPDIR)\n+\t@: > src/arc/$(DEPDIR)/$(am__dirstamp)\n+src/arc/ffi.lo: src/arc/$(am__dirstamp) \\\n+\tsrc/arc/$(DEPDIR)/$(am__dirstamp)\n+src/arc/arcompact.lo: src/arc/$(am__dirstamp) \\\n+\tsrc/arc/$(DEPDIR)/$(am__dirstamp)\n+src/arm/$(am__dirstamp):\n+\t@$(MKDIR_P) src/arm\n+\t@: > src/arm/$(am__dirstamp)\n+src/arm/$(DEPDIR)/$(am__dirstamp):\n+\t@$(MKDIR_P) src/arm/$(DEPDIR)\n+\t@: > src/arm/$(DEPDIR)/$(am__dirstamp)\n+src/arm/ffi.lo: src/arm/$(am__dirstamp) \\\n+\tsrc/arm/$(DEPDIR)/$(am__dirstamp)\n+src/arm/sysv.lo: src/arm/$(am__dirstamp) \\\n+\tsrc/arm/$(DEPDIR)/$(am__dirstamp)\n+src/avr32/$(am__dirstamp):\n+\t@$(MKDIR_P) src/avr32\n+\t@: > src/avr32/$(am__dirstamp)\n+src/avr32/$(DEPDIR)/$(am__dirstamp):\n+\t@$(MKDIR_P) src/avr32/$(DEPDIR)\n+\t@: > src/avr32/$(DEPDIR)/$(am__dirstamp)\n+src/avr32/ffi.lo: src/avr32/$(am__dirstamp) \\\n+\tsrc/avr32/$(DEPDIR)/$(am__dirstamp)\n+src/avr32/sysv.lo: src/avr32/$(am__dirstamp) \\\n+\tsrc/avr32/$(DEPDIR)/$(am__dirstamp)\n+src/bfin/$(am__dirstamp):\n+\t@$(MKDIR_P) src/bfin\n+\t@: > src/bfin/$(am__dirstamp)\n+src/bfin/$(DEPDIR)/$(am__dirstamp):\n+\t@$(MKDIR_P) src/bfin/$(DEPDIR)\n+\t@: > src/bfin/$(DEPDIR)/$(am__dirstamp)\n+src/bfin/ffi.lo: src/bfin/$(am__dirstamp) \\\n+\tsrc/bfin/$(DEPDIR)/$(am__dirstamp)\n+src/bfin/sysv.lo: src/bfin/$(am__dirstamp) \\\n+\tsrc/bfin/$(DEPDIR)/$(am__dirstamp)\n+src/cris/$(am__dirstamp):\n+\t@$(MKDIR_P) src/cris\n+\t@: > src/cris/$(am__dirstamp)\n+src/cris/$(DEPDIR)/$(am__dirstamp):\n+\t@$(MKDIR_P) src/cris/$(DEPDIR)\n+\t@: > src/cris/$(DEPDIR)/$(am__dirstamp)\n+src/cris/ffi.lo: src/cris/$(am__dirstamp) \\\n+\tsrc/cris/$(DEPDIR)/$(am__dirstamp)\n+src/cris/sysv.lo: src/cris/$(am__dirstamp) \\\n+\tsrc/cris/$(DEPDIR)/$(am__dirstamp)\n+src/frv/$(am__dirstamp):\n+\t@$(MKDIR_P) src/frv\n+\t@: > src/frv/$(am__dirstamp)\n+src/frv/$(DEPDIR)/$(am__dirstamp):\n+\t@$(MKDIR_P) src/frv/$(DEPDIR)\n+\t@: > src/frv/$(DEPDIR)/$(am__dirstamp)\n+src/frv/ffi.lo: src/frv/$(am__dirstamp) \\\n+\tsrc/frv/$(DEPDIR)/$(am__dirstamp)\n+src/frv/eabi.lo: src/frv/$(am__dirstamp) \\\n+\tsrc/frv/$(DEPDIR)/$(am__dirstamp)\n src/ia64/$(am__dirstamp):\n \t@$(MKDIR_P) src/ia64\n \t@: > src/ia64/$(am__dirstamp)\n@@ -695,10 +667,10 @@ src/m32r/$(am__dirstamp):\n src/m32r/$(DEPDIR)/$(am__dirstamp):\n \t@$(MKDIR_P) src/m32r/$(DEPDIR)\n \t@: > src/m32r/$(DEPDIR)/$(am__dirstamp)\n-src/m32r/sysv.lo: src/m32r/$(am__dirstamp) \\\n-\tsrc/m32r/$(DEPDIR)/$(am__dirstamp)\n src/m32r/ffi.lo: src/m32r/$(am__dirstamp) \\\n \tsrc/m32r/$(DEPDIR)/$(am__dirstamp)\n+src/m32r/sysv.lo: src/m32r/$(am__dirstamp) \\\n+\tsrc/m32r/$(DEPDIR)/$(am__dirstamp)\n src/m68k/$(am__dirstamp):\n \t@$(MKDIR_P) src/m68k\n \t@: > src/m68k/$(am__dirstamp)\n@@ -709,6 +681,89 @@ src/m68k/ffi.lo: src/m68k/$(am__dirstamp) \\\n \tsrc/m68k/$(DEPDIR)/$(am__dirstamp)\n src/m68k/sysv.lo: src/m68k/$(am__dirstamp) \\\n \tsrc/m68k/$(DEPDIR)/$(am__dirstamp)\n+src/m88k/$(am__dirstamp):\n+\t@$(MKDIR_P) src/m88k\n+\t@: > src/m88k/$(am__dirstamp)\n+src/m88k/$(DEPDIR)/$(am__dirstamp):\n+\t@$(MKDIR_P) src/m88k/$(DEPDIR)\n+\t@: > src/m88k/$(DEPDIR)/$(am__dirstamp)\n+src/m88k/ffi.lo: src/m88k/$(am__dirstamp) \\\n+\tsrc/m88k/$(DEPDIR)/$(am__dirstamp)\n+src/m88k/obsd.lo: src/m88k/$(am__dirstamp) \\\n+\tsrc/m88k/$(DEPDIR)/$(am__dirstamp)\n+src/metag/$(am__dirstamp):\n+\t@$(MKDIR_P) src/metag\n+\t@: > src/metag/$(am__dirstamp)\n+src/metag/$(DEPDIR)/$(am__dirstamp):\n+\t@$(MKDIR_P) src/metag/$(DEPDIR)\n+\t@: > src/metag/$(DEPDIR)/$(am__dirstamp)\n+src/metag/ffi.lo: src/metag/$(am__dirstamp) \\\n+\tsrc/metag/$(DEPDIR)/$(am__dirstamp)\n+src/metag/sysv.lo: src/metag/$(am__dirstamp) \\\n+\tsrc/metag/$(DEPDIR)/$(am__dirstamp)\n+src/microblaze/$(am__dirstamp):\n+\t@$(MKDIR_P) src/microblaze\n+\t@: > src/microblaze/$(am__dirstamp)\n+src/microblaze/$(DEPDIR)/$(am__dirstamp):\n+\t@$(MKDIR_P) src/microblaze/$(DEPDIR)\n+\t@: > src/microblaze/$(DEPDIR)/$(am__dirstamp)\n+src/microblaze/ffi.lo: src/microblaze/$(am__dirstamp) \\\n+\tsrc/microblaze/$(DEPDIR)/$(am__dirstamp)\n+src/microblaze/sysv.lo: src/microblaze/$(am__dirstamp) \\\n+\tsrc/microblaze/$(DEPDIR)/$(am__dirstamp)\n+src/mips/$(am__dirstamp):\n+\t@$(MKDIR_P) src/mips\n+\t@: > src/mips/$(am__dirstamp)\n+src/mips/$(DEPDIR)/$(am__dirstamp):\n+\t@$(MKDIR_P) src/mips/$(DEPDIR)\n+\t@: > src/mips/$(DEPDIR)/$(am__dirstamp)\n+src/mips/ffi.lo: src/mips/$(am__dirstamp) \\\n+\tsrc/mips/$(DEPDIR)/$(am__dirstamp)\n+src/mips/o32.lo: src/mips/$(am__dirstamp) \\\n+\tsrc/mips/$(DEPDIR)/$(am__dirstamp)\n+src/mips/n32.lo: src/mips/$(am__dirstamp) \\\n+\tsrc/mips/$(DEPDIR)/$(am__dirstamp)\n+src/moxie/$(am__dirstamp):\n+\t@$(MKDIR_P) src/moxie\n+\t@: > src/moxie/$(am__dirstamp)\n+src/moxie/$(DEPDIR)/$(am__dirstamp):\n+\t@$(MKDIR_P) src/moxie/$(DEPDIR)\n+\t@: > src/moxie/$(DEPDIR)/$(am__dirstamp)\n+src/moxie/ffi.lo: src/moxie/$(am__dirstamp) \\\n+\tsrc/moxie/$(DEPDIR)/$(am__dirstamp)\n+src/moxie/eabi.lo: src/moxie/$(am__dirstamp) \\\n+\tsrc/moxie/$(DEPDIR)/$(am__dirstamp)\n+src/nios2/$(am__dirstamp):\n+\t@$(MKDIR_P) src/nios2\n+\t@: > src/nios2/$(am__dirstamp)\n+src/nios2/$(DEPDIR)/$(am__dirstamp):\n+\t@$(MKDIR_P) src/nios2/$(DEPDIR)\n+\t@: > src/nios2/$(DEPDIR)/$(am__dirstamp)\n+src/nios2/ffi.lo: src/nios2/$(am__dirstamp) \\\n+\tsrc/nios2/$(DEPDIR)/$(am__dirstamp)\n+src/nios2/sysv.lo: src/nios2/$(am__dirstamp) \\\n+\tsrc/nios2/$(DEPDIR)/$(am__dirstamp)\n+src/or1k/$(am__dirstamp):\n+\t@$(MKDIR_P) src/or1k\n+\t@: > src/or1k/$(am__dirstamp)\n+src/or1k/$(DEPDIR)/$(am__dirstamp):\n+\t@$(MKDIR_P) src/or1k/$(DEPDIR)\n+\t@: > src/or1k/$(DEPDIR)/$(am__dirstamp)\n+src/or1k/ffi.lo: src/or1k/$(am__dirstamp) \\\n+\tsrc/or1k/$(DEPDIR)/$(am__dirstamp)\n+src/or1k/sysv.lo: src/or1k/$(am__dirstamp) \\\n+\tsrc/or1k/$(DEPDIR)/$(am__dirstamp)\n+src/pa/$(am__dirstamp):\n+\t@$(MKDIR_P) src/pa\n+\t@: > src/pa/$(am__dirstamp)\n+src/pa/$(DEPDIR)/$(am__dirstamp):\n+\t@$(MKDIR_P) src/pa/$(DEPDIR)\n+\t@: > src/pa/$(DEPDIR)/$(am__dirstamp)\n+src/pa/ffi.lo: src/pa/$(am__dirstamp) src/pa/$(DEPDIR)/$(am__dirstamp)\n+src/pa/linux.lo: src/pa/$(am__dirstamp) \\\n+\tsrc/pa/$(DEPDIR)/$(am__dirstamp)\n+src/pa/hpux32.lo: src/pa/$(am__dirstamp) \\\n+\tsrc/pa/$(DEPDIR)/$(am__dirstamp)\n src/powerpc/$(am__dirstamp):\n \t@$(MKDIR_P) src/powerpc\n \t@: > src/powerpc/$(am__dirstamp)\n@@ -723,126 +778,121 @@ src/powerpc/ffi_linux64.lo: src/powerpc/$(am__dirstamp) \\\n \tsrc/powerpc/$(DEPDIR)/$(am__dirstamp)\n src/powerpc/sysv.lo: src/powerpc/$(am__dirstamp) \\\n \tsrc/powerpc/$(DEPDIR)/$(am__dirstamp)\n-src/powerpc/ppc_closure.lo: src/powerpc/$(am__dirstamp) \\\n-\tsrc/powerpc/$(DEPDIR)/$(am__dirstamp)\n src/powerpc/linux64.lo: src/powerpc/$(am__dirstamp) \\\n \tsrc/powerpc/$(DEPDIR)/$(am__dirstamp)\n src/powerpc/linux64_closure.lo: src/powerpc/$(am__dirstamp) \\\n \tsrc/powerpc/$(DEPDIR)/$(am__dirstamp)\n-src/powerpc/ffi_darwin.lo: src/powerpc/$(am__dirstamp) \\\n+src/powerpc/ppc_closure.lo: src/powerpc/$(am__dirstamp) \\\n \tsrc/powerpc/$(DEPDIR)/$(am__dirstamp)\n src/powerpc/aix.lo: src/powerpc/$(am__dirstamp) \\\n \tsrc/powerpc/$(DEPDIR)/$(am__dirstamp)\n-src/powerpc/aix_closure.lo: src/powerpc/$(am__dirstamp) \\\n-\tsrc/powerpc/$(DEPDIR)/$(am__dirstamp)\n src/powerpc/darwin.lo: src/powerpc/$(am__dirstamp) \\\n \tsrc/powerpc/$(DEPDIR)/$(am__dirstamp)\n+src/powerpc/aix_closure.lo: src/powerpc/$(am__dirstamp) \\\n+\tsrc/powerpc/$(DEPDIR)/$(am__dirstamp)\n src/powerpc/darwin_closure.lo: src/powerpc/$(am__dirstamp) \\\n \tsrc/powerpc/$(DEPDIR)/$(am__dirstamp)\n-src/aarch64/$(am__dirstamp):\n-\t@$(MKDIR_P) src/aarch64\n-\t@: > src/aarch64/$(am__dirstamp)\n-src/aarch64/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/aarch64/$(DEPDIR)\n-\t@: > src/aarch64/$(DEPDIR)/$(am__dirstamp)\n-src/aarch64/sysv.lo: src/aarch64/$(am__dirstamp) \\\n-\tsrc/aarch64/$(DEPDIR)/$(am__dirstamp)\n-src/aarch64/ffi.lo: src/aarch64/$(am__dirstamp) \\\n-\tsrc/aarch64/$(DEPDIR)/$(am__dirstamp)\n-src/arm/$(am__dirstamp):\n-\t@$(MKDIR_P) src/arm\n-\t@: > src/arm/$(am__dirstamp)\n-src/arm/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/arm/$(DEPDIR)\n-\t@: > src/arm/$(DEPDIR)/$(am__dirstamp)\n-src/arm/sysv.lo: src/arm/$(am__dirstamp) \\\n-\tsrc/arm/$(DEPDIR)/$(am__dirstamp)\n-src/arm/ffi.lo: src/arm/$(am__dirstamp) \\\n-\tsrc/arm/$(DEPDIR)/$(am__dirstamp)\n-src/arm/trampoline.lo: src/arm/$(am__dirstamp) \\\n-\tsrc/arm/$(DEPDIR)/$(am__dirstamp)\n-src/avr32/$(am__dirstamp):\n-\t@$(MKDIR_P) src/avr32\n-\t@: > src/avr32/$(am__dirstamp)\n-src/avr32/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/avr32/$(DEPDIR)\n-\t@: > src/avr32/$(DEPDIR)/$(am__dirstamp)\n-src/avr32/sysv.lo: src/avr32/$(am__dirstamp) \\\n-\tsrc/avr32/$(DEPDIR)/$(am__dirstamp)\n-src/avr32/ffi.lo: src/avr32/$(am__dirstamp) \\\n-\tsrc/avr32/$(DEPDIR)/$(am__dirstamp)\n-src/cris/$(am__dirstamp):\n-\t@$(MKDIR_P) src/cris\n-\t@: > src/cris/$(am__dirstamp)\n-src/cris/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/cris/$(DEPDIR)\n-\t@: > src/cris/$(DEPDIR)/$(am__dirstamp)\n-src/cris/sysv.lo: src/cris/$(am__dirstamp) \\\n-\tsrc/cris/$(DEPDIR)/$(am__dirstamp)\n-src/cris/ffi.lo: src/cris/$(am__dirstamp) \\\n-\tsrc/cris/$(DEPDIR)/$(am__dirstamp)\n-src/frv/$(am__dirstamp):\n-\t@$(MKDIR_P) src/frv\n-\t@: > src/frv/$(am__dirstamp)\n-src/frv/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/frv/$(DEPDIR)\n-\t@: > src/frv/$(DEPDIR)/$(am__dirstamp)\n-src/frv/eabi.lo: src/frv/$(am__dirstamp) \\\n-\tsrc/frv/$(DEPDIR)/$(am__dirstamp)\n-src/frv/ffi.lo: src/frv/$(am__dirstamp) \\\n-\tsrc/frv/$(DEPDIR)/$(am__dirstamp)\n+src/powerpc/ffi_darwin.lo: src/powerpc/$(am__dirstamp) \\\n+\tsrc/powerpc/$(DEPDIR)/$(am__dirstamp)\n src/s390/$(am__dirstamp):\n \t@$(MKDIR_P) src/s390\n \t@: > src/s390/$(am__dirstamp)\n src/s390/$(DEPDIR)/$(am__dirstamp):\n \t@$(MKDIR_P) src/s390/$(DEPDIR)\n \t@: > src/s390/$(DEPDIR)/$(am__dirstamp)\n-src/s390/sysv.lo: src/s390/$(am__dirstamp) \\\n-\tsrc/s390/$(DEPDIR)/$(am__dirstamp)\n src/s390/ffi.lo: src/s390/$(am__dirstamp) \\\n \tsrc/s390/$(DEPDIR)/$(am__dirstamp)\n-src/x86/unix64.lo: src/x86/$(am__dirstamp) \\\n-\tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n+src/s390/sysv.lo: src/s390/$(am__dirstamp) \\\n+\tsrc/s390/$(DEPDIR)/$(am__dirstamp)\n src/sh/$(am__dirstamp):\n \t@$(MKDIR_P) src/sh\n \t@: > src/sh/$(am__dirstamp)\n src/sh/$(DEPDIR)/$(am__dirstamp):\n \t@$(MKDIR_P) src/sh/$(DEPDIR)\n \t@: > src/sh/$(DEPDIR)/$(am__dirstamp)\n+src/sh/ffi.lo: src/sh/$(am__dirstamp) src/sh/$(DEPDIR)/$(am__dirstamp)\n src/sh/sysv.lo: src/sh/$(am__dirstamp) \\\n \tsrc/sh/$(DEPDIR)/$(am__dirstamp)\n-src/sh/ffi.lo: src/sh/$(am__dirstamp) src/sh/$(DEPDIR)/$(am__dirstamp)\n src/sh64/$(am__dirstamp):\n \t@$(MKDIR_P) src/sh64\n \t@: > src/sh64/$(am__dirstamp)\n src/sh64/$(DEPDIR)/$(am__dirstamp):\n \t@$(MKDIR_P) src/sh64/$(DEPDIR)\n \t@: > src/sh64/$(DEPDIR)/$(am__dirstamp)\n-src/sh64/sysv.lo: src/sh64/$(am__dirstamp) \\\n-\tsrc/sh64/$(DEPDIR)/$(am__dirstamp)\n src/sh64/ffi.lo: src/sh64/$(am__dirstamp) \\\n \tsrc/sh64/$(DEPDIR)/$(am__dirstamp)\n-src/pa/$(am__dirstamp):\n-\t@$(MKDIR_P) src/pa\n-\t@: > src/pa/$(am__dirstamp)\n-src/pa/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/pa/$(DEPDIR)\n-\t@: > src/pa/$(DEPDIR)/$(am__dirstamp)\n-src/pa/linux.lo: src/pa/$(am__dirstamp) \\\n-\tsrc/pa/$(DEPDIR)/$(am__dirstamp)\n-src/pa/ffi.lo: src/pa/$(am__dirstamp) src/pa/$(DEPDIR)/$(am__dirstamp)\n-src/pa/hpux32.lo: src/pa/$(am__dirstamp) \\\n-\tsrc/pa/$(DEPDIR)/$(am__dirstamp)\n+src/sh64/sysv.lo: src/sh64/$(am__dirstamp) \\\n+\tsrc/sh64/$(DEPDIR)/$(am__dirstamp)\n+src/sparc/$(am__dirstamp):\n+\t@$(MKDIR_P) src/sparc\n+\t@: > src/sparc/$(am__dirstamp)\n+src/sparc/$(DEPDIR)/$(am__dirstamp):\n+\t@$(MKDIR_P) src/sparc/$(DEPDIR)\n+\t@: > src/sparc/$(DEPDIR)/$(am__dirstamp)\n+src/sparc/ffi.lo: src/sparc/$(am__dirstamp) \\\n+\tsrc/sparc/$(DEPDIR)/$(am__dirstamp)\n+src/sparc/ffi64.lo: src/sparc/$(am__dirstamp) \\\n+\tsrc/sparc/$(DEPDIR)/$(am__dirstamp)\n+src/sparc/v8.lo: src/sparc/$(am__dirstamp) \\\n+\tsrc/sparc/$(DEPDIR)/$(am__dirstamp)\n+src/sparc/v9.lo: src/sparc/$(am__dirstamp) \\\n+\tsrc/sparc/$(DEPDIR)/$(am__dirstamp)\n src/tile/$(am__dirstamp):\n \t@$(MKDIR_P) src/tile\n \t@: > src/tile/$(am__dirstamp)\n src/tile/$(DEPDIR)/$(am__dirstamp):\n \t@$(MKDIR_P) src/tile/$(DEPDIR)\n \t@: > src/tile/$(DEPDIR)/$(am__dirstamp)\n-src/tile/tile.lo: src/tile/$(am__dirstamp) \\\n-\tsrc/tile/$(DEPDIR)/$(am__dirstamp)\n src/tile/ffi.lo: src/tile/$(am__dirstamp) \\\n \tsrc/tile/$(DEPDIR)/$(am__dirstamp)\n+src/tile/tile.lo: src/tile/$(am__dirstamp) \\\n+\tsrc/tile/$(DEPDIR)/$(am__dirstamp)\n+src/vax/$(am__dirstamp):\n+\t@$(MKDIR_P) src/vax\n+\t@: > src/vax/$(am__dirstamp)\n+src/vax/$(DEPDIR)/$(am__dirstamp):\n+\t@$(MKDIR_P) src/vax/$(DEPDIR)\n+\t@: > src/vax/$(DEPDIR)/$(am__dirstamp)\n+src/vax/ffi.lo: src/vax/$(am__dirstamp) \\\n+\tsrc/vax/$(DEPDIR)/$(am__dirstamp)\n+src/vax/elfbsd.lo: src/vax/$(am__dirstamp) \\\n+\tsrc/vax/$(DEPDIR)/$(am__dirstamp)\n+src/x86/$(am__dirstamp):\n+\t@$(MKDIR_P) src/x86\n+\t@: > src/x86/$(am__dirstamp)\n+src/x86/$(DEPDIR)/$(am__dirstamp):\n+\t@$(MKDIR_P) src/x86/$(DEPDIR)\n+\t@: > src/x86/$(DEPDIR)/$(am__dirstamp)\n+src/x86/ffi.lo: src/x86/$(am__dirstamp) \\\n+\tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n+src/x86/sysv.lo: src/x86/$(am__dirstamp) \\\n+\tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n+src/x86/ffiw64.lo: src/x86/$(am__dirstamp) \\\n+\tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n+src/x86/win64.lo: src/x86/$(am__dirstamp) \\\n+\tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n+src/x86/ffi64.lo: src/x86/$(am__dirstamp) \\\n+\tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n+src/x86/unix64.lo: src/x86/$(am__dirstamp) \\\n+\tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n+src/x86/darwin64.lo: src/x86/$(am__dirstamp) \\\n+\tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n+src/x86/darwin.lo: src/x86/$(am__dirstamp) \\\n+\tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n+src/x86/darwin64_c.lo: src/x86/$(am__dirstamp) \\\n+\tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n+src/x86/darwin_c.lo: src/x86/$(am__dirstamp) \\\n+\tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n+src/xtensa/$(am__dirstamp):\n+\t@$(MKDIR_P) src/xtensa\n+\t@: > src/xtensa/$(am__dirstamp)\n+src/xtensa/$(DEPDIR)/$(am__dirstamp):\n+\t@$(MKDIR_P) src/xtensa/$(DEPDIR)\n+\t@: > src/xtensa/$(DEPDIR)/$(am__dirstamp)\n+src/xtensa/ffi.lo: src/xtensa/$(am__dirstamp) \\\n+\tsrc/xtensa/$(DEPDIR)/$(am__dirstamp)\n+src/xtensa/sysv.lo: src/xtensa/$(am__dirstamp) \\\n+\tsrc/xtensa/$(DEPDIR)/$(am__dirstamp)\n libffi.la: $(libffi_la_OBJECTS) $(libffi_la_DEPENDENCIES) \n \t$(libffi_la_LINK) -rpath $(toolexeclibdir) $(libffi_la_OBJECTS) $(libffi_la_LIBADD) $(LIBS)\n libffi_convenience.la: $(libffi_convenience_la_OBJECTS) $(libffi_convenience_la_DEPENDENCIES) \n@@ -858,12 +908,14 @@ mostlyclean-compile:\n \t-rm -f src/alpha/ffi.lo\n \t-rm -f src/alpha/osf.$(OBJEXT)\n \t-rm -f src/alpha/osf.lo\n+\t-rm -f src/arc/arcompact.$(OBJEXT)\n+\t-rm -f src/arc/arcompact.lo\n+\t-rm -f src/arc/ffi.$(OBJEXT)\n+\t-rm -f src/arc/ffi.lo\n \t-rm -f src/arm/ffi.$(OBJEXT)\n \t-rm -f src/arm/ffi.lo\n \t-rm -f src/arm/sysv.$(OBJEXT)\n \t-rm -f src/arm/sysv.lo\n-\t-rm -f src/arm/trampoline.$(OBJEXT)\n-\t-rm -f src/arm/trampoline.lo\n \t-rm -f src/avr32/ffi.$(OBJEXT)\n \t-rm -f src/avr32/ffi.lo\n \t-rm -f src/avr32/sysv.$(OBJEXT)\n@@ -898,12 +950,36 @@ mostlyclean-compile:\n \t-rm -f src/m68k/ffi.lo\n \t-rm -f src/m68k/sysv.$(OBJEXT)\n \t-rm -f src/m68k/sysv.lo\n+\t-rm -f src/m88k/ffi.$(OBJEXT)\n+\t-rm -f src/m88k/ffi.lo\n+\t-rm -f src/m88k/obsd.$(OBJEXT)\n+\t-rm -f src/m88k/obsd.lo\n+\t-rm -f src/metag/ffi.$(OBJEXT)\n+\t-rm -f src/metag/ffi.lo\n+\t-rm -f src/metag/sysv.$(OBJEXT)\n+\t-rm -f src/metag/sysv.lo\n+\t-rm -f src/microblaze/ffi.$(OBJEXT)\n+\t-rm -f src/microblaze/ffi.lo\n+\t-rm -f src/microblaze/sysv.$(OBJEXT)\n+\t-rm -f src/microblaze/sysv.lo\n \t-rm -f src/mips/ffi.$(OBJEXT)\n \t-rm -f src/mips/ffi.lo\n \t-rm -f src/mips/n32.$(OBJEXT)\n \t-rm -f src/mips/n32.lo\n \t-rm -f src/mips/o32.$(OBJEXT)\n \t-rm -f src/mips/o32.lo\n+\t-rm -f src/moxie/eabi.$(OBJEXT)\n+\t-rm -f src/moxie/eabi.lo\n+\t-rm -f src/moxie/ffi.$(OBJEXT)\n+\t-rm -f src/moxie/ffi.lo\n+\t-rm -f src/nios2/ffi.$(OBJEXT)\n+\t-rm -f src/nios2/ffi.lo\n+\t-rm -f src/nios2/sysv.$(OBJEXT)\n+\t-rm -f src/nios2/sysv.lo\n+\t-rm -f src/or1k/ffi.$(OBJEXT)\n+\t-rm -f src/or1k/ffi.lo\n+\t-rm -f src/or1k/sysv.$(OBJEXT)\n+\t-rm -f src/or1k/sysv.lo\n \t-rm -f src/pa/ffi.$(OBJEXT)\n \t-rm -f src/pa/ffi.lo\n \t-rm -f src/pa/hpux32.$(OBJEXT)\n@@ -952,6 +1028,8 @@ mostlyclean-compile:\n \t-rm -f src/sh64/sysv.lo\n \t-rm -f src/sparc/ffi.$(OBJEXT)\n \t-rm -f src/sparc/ffi.lo\n+\t-rm -f src/sparc/ffi64.$(OBJEXT)\n+\t-rm -f src/sparc/ffi64.lo\n \t-rm -f src/sparc/v8.$(OBJEXT)\n \t-rm -f src/sparc/v8.lo\n \t-rm -f src/sparc/v9.$(OBJEXT)\n@@ -962,24 +1040,34 @@ mostlyclean-compile:\n \t-rm -f src/tile/tile.lo\n \t-rm -f src/types.$(OBJEXT)\n \t-rm -f src/types.lo\n+\t-rm -f src/vax/elfbsd.$(OBJEXT)\n+\t-rm -f src/vax/elfbsd.lo\n+\t-rm -f src/vax/ffi.$(OBJEXT)\n+\t-rm -f src/vax/ffi.lo\n \t-rm -f src/x86/darwin.$(OBJEXT)\n \t-rm -f src/x86/darwin.lo\n \t-rm -f src/x86/darwin64.$(OBJEXT)\n \t-rm -f src/x86/darwin64.lo\n+\t-rm -f src/x86/darwin64_c.$(OBJEXT)\n+\t-rm -f src/x86/darwin64_c.lo\n+\t-rm -f src/x86/darwin_c.$(OBJEXT)\n+\t-rm -f src/x86/darwin_c.lo\n \t-rm -f src/x86/ffi.$(OBJEXT)\n \t-rm -f src/x86/ffi.lo\n \t-rm -f src/x86/ffi64.$(OBJEXT)\n \t-rm -f src/x86/ffi64.lo\n-\t-rm -f src/x86/freebsd.$(OBJEXT)\n-\t-rm -f src/x86/freebsd.lo\n+\t-rm -f src/x86/ffiw64.$(OBJEXT)\n+\t-rm -f src/x86/ffiw64.lo\n \t-rm -f src/x86/sysv.$(OBJEXT)\n \t-rm -f src/x86/sysv.lo\n \t-rm -f src/x86/unix64.$(OBJEXT)\n \t-rm -f src/x86/unix64.lo\n-\t-rm -f src/x86/win32.$(OBJEXT)\n-\t-rm -f src/x86/win32.lo\n \t-rm -f src/x86/win64.$(OBJEXT)\n \t-rm -f src/x86/win64.lo\n+\t-rm -f src/xtensa/ffi.$(OBJEXT)\n+\t-rm -f src/xtensa/ffi.lo\n+\t-rm -f src/xtensa/sysv.$(OBJEXT)\n+\t-rm -f src/xtensa/sysv.lo\n \n distclean-compile:\n \t-rm -f *.tab.c\n@@ -994,9 +1082,10 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@src/aarch64/$(DEPDIR)/sysv.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/alpha/$(DEPDIR)/ffi.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/alpha/$(DEPDIR)/osf.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@src/arc/$(DEPDIR)/arcompact.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@src/arc/$(DEPDIR)/ffi.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/arm/$(DEPDIR)/ffi.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/arm/$(DEPDIR)/sysv.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/arm/$(DEPDIR)/trampoline.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/avr32/$(DEPDIR)/ffi.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/avr32/$(DEPDIR)/sysv.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/bfin/$(DEPDIR)/ffi.Plo@am__quote@\n@@ -1011,9 +1100,21 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@src/m32r/$(DEPDIR)/sysv.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/m68k/$(DEPDIR)/ffi.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/m68k/$(DEPDIR)/sysv.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@src/m88k/$(DEPDIR)/ffi.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@src/m88k/$(DEPDIR)/obsd.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@src/metag/$(DEPDIR)/ffi.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@src/metag/$(DEPDIR)/sysv.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@src/microblaze/$(DEPDIR)/ffi.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@src/microblaze/$(DEPDIR)/sysv.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/mips/$(DEPDIR)/ffi.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/mips/$(DEPDIR)/n32.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/mips/$(DEPDIR)/o32.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@src/moxie/$(DEPDIR)/eabi.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@src/moxie/$(DEPDIR)/ffi.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@src/nios2/$(DEPDIR)/ffi.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@src/nios2/$(DEPDIR)/sysv.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@src/or1k/$(DEPDIR)/ffi.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@src/or1k/$(DEPDIR)/sysv.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/pa/$(DEPDIR)/ffi.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/pa/$(DEPDIR)/hpux32.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/pa/$(DEPDIR)/linux.Plo@am__quote@\n@@ -1036,19 +1137,25 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@src/sh64/$(DEPDIR)/ffi.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/sh64/$(DEPDIR)/sysv.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/sparc/$(DEPDIR)/ffi.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@src/sparc/$(DEPDIR)/ffi64.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/sparc/$(DEPDIR)/v8.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/sparc/$(DEPDIR)/v9.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/tile/$(DEPDIR)/ffi.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/tile/$(DEPDIR)/tile.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@src/vax/$(DEPDIR)/elfbsd.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@src/vax/$(DEPDIR)/ffi.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/darwin.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/darwin64.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/darwin64_c.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/darwin_c.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/ffi.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/ffi64.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/freebsd.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/ffiw64.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/sysv.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/unix64.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/win32.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/win64.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@src/xtensa/$(DEPDIR)/ffi.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@src/xtensa/$(DEPDIR)/sysv.Plo@am__quote@\n \n .S.o:\n @am__fastdepCCAS_TRUE@\tdepbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\\.o$$||'`;\\\n@@ -1106,6 +1213,7 @@ clean-libtool:\n \t-rm -rf src/.libs src/_libs\n \t-rm -rf src/aarch64/.libs src/aarch64/_libs\n \t-rm -rf src/alpha/.libs src/alpha/_libs\n+\t-rm -rf src/arc/.libs src/arc/_libs\n \t-rm -rf src/arm/.libs src/arm/_libs\n \t-rm -rf src/avr32/.libs src/avr32/_libs\n \t-rm -rf src/bfin/.libs src/bfin/_libs\n@@ -1114,15 +1222,23 @@ clean-libtool:\n \t-rm -rf src/ia64/.libs src/ia64/_libs\n \t-rm -rf src/m32r/.libs src/m32r/_libs\n \t-rm -rf src/m68k/.libs src/m68k/_libs\n+\t-rm -rf src/m88k/.libs src/m88k/_libs\n+\t-rm -rf src/metag/.libs src/metag/_libs\n+\t-rm -rf src/microblaze/.libs src/microblaze/_libs\n \t-rm -rf src/mips/.libs src/mips/_libs\n+\t-rm -rf src/moxie/.libs src/moxie/_libs\n+\t-rm -rf src/nios2/.libs src/nios2/_libs\n+\t-rm -rf src/or1k/.libs src/or1k/_libs\n \t-rm -rf src/pa/.libs src/pa/_libs\n \t-rm -rf src/powerpc/.libs src/powerpc/_libs\n \t-rm -rf src/s390/.libs src/s390/_libs\n \t-rm -rf src/sh/.libs src/sh/_libs\n \t-rm -rf src/sh64/.libs src/sh64/_libs\n \t-rm -rf src/sparc/.libs src/sparc/_libs\n \t-rm -rf src/tile/.libs src/tile/_libs\n+\t-rm -rf src/vax/.libs src/vax/_libs\n \t-rm -rf src/x86/.libs src/x86/_libs\n+\t-rm -rf src/xtensa/.libs src/xtensa/_libs\n \n distclean-libtool:\n \t-rm -f libtool config.lt\n@@ -1286,6 +1402,26 @@ maintainer-clean-aminfo:\n \t  echo \" rm -f $$i $$i-[0-9] $$i-[0-9][0-9] $$i_i[0-9] $$i_i[0-9][0-9]\"; \\\n \t  rm -f $$i $$i-[0-9] $$i-[0-9][0-9] $$i_i[0-9] $$i_i[0-9][0-9]; \\\n \tdone\n+install-pkgconfigDATA: $(pkgconfig_DATA)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(pkgconfigdir)\" || $(MKDIR_P) \"$(DESTDIR)$(pkgconfigdir)\"\n+\t@list='$(pkgconfig_DATA)'; test -n \"$(pkgconfigdir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  echo \"$$d$$p\"; \\\n+\tdone | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(pkgconfigdir)'\"; \\\n+\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(pkgconfigdir)\" || exit $$?; \\\n+\tdone\n+\n+uninstall-pkgconfigDATA:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(pkgconfig_DATA)'; test -n \"$(pkgconfigdir)\" || list=; \\\n+\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n+\ttest -n \"$$files\" || exit 0; \\\n+\techo \" ( cd '$(DESTDIR)$(pkgconfigdir)' && rm -f\" $$files \")\"; \\\n+\tcd \"$(DESTDIR)$(pkgconfigdir)\" && rm -f $$files\n \n # This directory's subdirectories are mostly independent; you can cd\n # into them and run `make' without going through this Makefile.\n@@ -1423,11 +1559,11 @@ distclean-tags:\n \t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n check-am: all-am\n check: check-recursive\n-all-am: Makefile $(INFO_DEPS) $(LTLIBRARIES) all-multi fficonfig.h \\\n-\t\tall-local\n+all-am: Makefile $(INFO_DEPS) $(LTLIBRARIES) all-multi $(DATA) \\\n+\t\t$(HEADERS) fficonfig.h all-local\n installdirs: installdirs-recursive\n installdirs-am:\n-\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(infodir)\"; do \\\n+\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(infodir)\" \"$(DESTDIR)$(pkgconfigdir)\"; do \\\n \t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n \tdone\n install: install-recursive\n@@ -1459,6 +1595,8 @@ distclean-generic:\n \t-rm -f src/aarch64/$(am__dirstamp)\n \t-rm -f src/alpha/$(DEPDIR)/$(am__dirstamp)\n \t-rm -f src/alpha/$(am__dirstamp)\n+\t-rm -f src/arc/$(DEPDIR)/$(am__dirstamp)\n+\t-rm -f src/arc/$(am__dirstamp)\n \t-rm -f src/arm/$(DEPDIR)/$(am__dirstamp)\n \t-rm -f src/arm/$(am__dirstamp)\n \t-rm -f src/avr32/$(DEPDIR)/$(am__dirstamp)\n@@ -1475,8 +1613,20 @@ distclean-generic:\n \t-rm -f src/m32r/$(am__dirstamp)\n \t-rm -f src/m68k/$(DEPDIR)/$(am__dirstamp)\n \t-rm -f src/m68k/$(am__dirstamp)\n+\t-rm -f src/m88k/$(DEPDIR)/$(am__dirstamp)\n+\t-rm -f src/m88k/$(am__dirstamp)\n+\t-rm -f src/metag/$(DEPDIR)/$(am__dirstamp)\n+\t-rm -f src/metag/$(am__dirstamp)\n+\t-rm -f src/microblaze/$(DEPDIR)/$(am__dirstamp)\n+\t-rm -f src/microblaze/$(am__dirstamp)\n \t-rm -f src/mips/$(DEPDIR)/$(am__dirstamp)\n \t-rm -f src/mips/$(am__dirstamp)\n+\t-rm -f src/moxie/$(DEPDIR)/$(am__dirstamp)\n+\t-rm -f src/moxie/$(am__dirstamp)\n+\t-rm -f src/nios2/$(DEPDIR)/$(am__dirstamp)\n+\t-rm -f src/nios2/$(am__dirstamp)\n+\t-rm -f src/or1k/$(DEPDIR)/$(am__dirstamp)\n+\t-rm -f src/or1k/$(am__dirstamp)\n \t-rm -f src/pa/$(DEPDIR)/$(am__dirstamp)\n \t-rm -f src/pa/$(am__dirstamp)\n \t-rm -f src/powerpc/$(DEPDIR)/$(am__dirstamp)\n@@ -1491,8 +1641,12 @@ distclean-generic:\n \t-rm -f src/sparc/$(am__dirstamp)\n \t-rm -f src/tile/$(DEPDIR)/$(am__dirstamp)\n \t-rm -f src/tile/$(am__dirstamp)\n+\t-rm -f src/vax/$(DEPDIR)/$(am__dirstamp)\n+\t-rm -f src/vax/$(am__dirstamp)\n \t-rm -f src/x86/$(DEPDIR)/$(am__dirstamp)\n \t-rm -f src/x86/$(am__dirstamp)\n+\t-rm -f src/xtensa/$(DEPDIR)/$(am__dirstamp)\n+\t-rm -f src/xtensa/$(am__dirstamp)\n \n maintainer-clean-generic:\n \t@echo \"This command is intended for maintainers to use\"\n@@ -1506,7 +1660,7 @@ clean-am: clean-aminfo clean-generic clean-libtool \\\n \n distclean: distclean-multi distclean-recursive\n \t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n-\t-rm -rf src/$(DEPDIR) src/aarch64/$(DEPDIR) src/alpha/$(DEPDIR) src/arm/$(DEPDIR) src/avr32/$(DEPDIR) src/bfin/$(DEPDIR) src/cris/$(DEPDIR) src/frv/$(DEPDIR) src/ia64/$(DEPDIR) src/m32r/$(DEPDIR) src/m68k/$(DEPDIR) src/mips/$(DEPDIR) src/pa/$(DEPDIR) src/powerpc/$(DEPDIR) src/s390/$(DEPDIR) src/sh/$(DEPDIR) src/sh64/$(DEPDIR) src/sparc/$(DEPDIR) src/tile/$(DEPDIR) src/x86/$(DEPDIR)\n+\t-rm -rf src/$(DEPDIR) src/aarch64/$(DEPDIR) src/alpha/$(DEPDIR) src/arc/$(DEPDIR) src/arm/$(DEPDIR) src/avr32/$(DEPDIR) src/bfin/$(DEPDIR) src/cris/$(DEPDIR) src/frv/$(DEPDIR) src/ia64/$(DEPDIR) src/m32r/$(DEPDIR) src/m68k/$(DEPDIR) src/m88k/$(DEPDIR) src/metag/$(DEPDIR) src/microblaze/$(DEPDIR) src/mips/$(DEPDIR) src/moxie/$(DEPDIR) src/nios2/$(DEPDIR) src/or1k/$(DEPDIR) src/pa/$(DEPDIR) src/powerpc/$(DEPDIR) src/s390/$(DEPDIR) src/sh/$(DEPDIR) src/sh64/$(DEPDIR) src/sparc/$(DEPDIR) src/tile/$(DEPDIR) src/vax/$(DEPDIR) src/x86/$(DEPDIR) src/xtensa/$(DEPDIR)\n \t-rm -f Makefile\n distclean-am: clean-am distclean-compile distclean-generic \\\n \tdistclean-hdr distclean-libtool distclean-tags\n@@ -1523,7 +1677,7 @@ info: info-recursive\n \n info-am: $(INFO_DEPS)\n \n-install-data-am: install-info-am\n+install-data-am: install-info-am install-pkgconfigDATA\n \n install-dvi: install-dvi-recursive\n \n@@ -1630,7 +1784,7 @@ installcheck-am:\n maintainer-clean: maintainer-clean-multi maintainer-clean-recursive\n \t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n \t-rm -rf $(top_srcdir)/autom4te.cache\n-\t-rm -rf src/$(DEPDIR) src/aarch64/$(DEPDIR) src/alpha/$(DEPDIR) src/arm/$(DEPDIR) src/avr32/$(DEPDIR) src/bfin/$(DEPDIR) src/cris/$(DEPDIR) src/frv/$(DEPDIR) src/ia64/$(DEPDIR) src/m32r/$(DEPDIR) src/m68k/$(DEPDIR) src/mips/$(DEPDIR) src/pa/$(DEPDIR) src/powerpc/$(DEPDIR) src/s390/$(DEPDIR) src/sh/$(DEPDIR) src/sh64/$(DEPDIR) src/sparc/$(DEPDIR) src/tile/$(DEPDIR) src/x86/$(DEPDIR)\n+\t-rm -rf src/$(DEPDIR) src/aarch64/$(DEPDIR) src/alpha/$(DEPDIR) src/arc/$(DEPDIR) src/arm/$(DEPDIR) src/avr32/$(DEPDIR) src/bfin/$(DEPDIR) src/cris/$(DEPDIR) src/frv/$(DEPDIR) src/ia64/$(DEPDIR) src/m32r/$(DEPDIR) src/m68k/$(DEPDIR) src/m88k/$(DEPDIR) src/metag/$(DEPDIR) src/microblaze/$(DEPDIR) src/mips/$(DEPDIR) src/moxie/$(DEPDIR) src/nios2/$(DEPDIR) src/or1k/$(DEPDIR) src/pa/$(DEPDIR) src/powerpc/$(DEPDIR) src/s390/$(DEPDIR) src/sh/$(DEPDIR) src/sh64/$(DEPDIR) src/sparc/$(DEPDIR) src/tile/$(DEPDIR) src/vax/$(DEPDIR) src/x86/$(DEPDIR) src/xtensa/$(DEPDIR)\n \t-rm -f Makefile\n maintainer-clean-am: distclean-am maintainer-clean-aminfo \\\n \tmaintainer-clean-generic maintainer-clean-vti\n@@ -1649,7 +1803,7 @@ ps: ps-recursive\n ps-am: $(PSS)\n \n uninstall-am: uninstall-dvi-am uninstall-html-am uninstall-info-am \\\n-\tuninstall-pdf-am uninstall-ps-am \\\n+\tuninstall-pdf-am uninstall-pkgconfigDATA uninstall-ps-am \\\n \tuninstall-toolexeclibLTLIBRARIES\n \n .MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) all all-multi \\\n@@ -1668,7 +1822,7 @@ uninstall-am: uninstall-dvi-am uninstall-html-am uninstall-info-am \\\n \tinstall-dvi install-dvi-am install-exec install-exec-am \\\n \tinstall-html install-html-am install-info install-info-am \\\n \tinstall-man install-multi install-pdf install-pdf-am \\\n-\tinstall-ps install-ps-am install-strip \\\n+\tinstall-pkgconfigDATA install-ps install-ps-am install-strip \\\n \tinstall-toolexeclibLTLIBRARIES installcheck installcheck-am \\\n \tinstalldirs installdirs-am maintainer-clean \\\n \tmaintainer-clean-aminfo maintainer-clean-generic \\\n@@ -1677,7 +1831,7 @@ uninstall-am: uninstall-dvi-am uninstall-html-am uninstall-info-am \\\n \tmostlyclean-libtool mostlyclean-multi mostlyclean-vti pdf \\\n \tpdf-am ps ps-am tags tags-recursive uninstall uninstall-am \\\n \tuninstall-dvi-am uninstall-html-am uninstall-info-am \\\n-\tuninstall-pdf-am uninstall-ps-am \\\n+\tuninstall-pdf-am uninstall-pkgconfigDATA uninstall-ps-am \\\n \tuninstall-toolexeclibLTLIBRARIES\n \n "}, {"sha": "c072101789172f89c84ed9a7fc24fc1607fc0634", "filename": "libffi/README", "status": "modified", "additions": 143, "deletions": 63, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FREADME?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -1,8 +1,8 @@\n Status\n ======\n \n-libffi-3.0.12 was released on XXXXXXX.  Check the libffi web page for\n-updates: <URL:http://sourceware.org/libffi/>.\n+libffi-4?? was released on TBD.  Check the libffi web\n+page for updates: <URL:http://sourceware.org/libffi/>.\n \n \n What is libffi?\n@@ -43,57 +43,78 @@ Libffi has been ported to many different platforms.\n For specific configuration details and testing status, please\n refer to the wiki page here:\n \n- http://www.moxielogic.org/wiki/index.php?title=Libffi_3.0.11\n+ http://www.moxielogic.org/wiki/index.php?title=Libffi_3.2\n \n At the time of release, the following basic configurations have been\n tested:\n \n-|-----------------+------------------|\n-| Architecture    | Operating System |\n-|-----------------+------------------|\n-| AArch64         | Linux            |\n-| Alpha           | Linux            |\n-| Alpha           | Tru64            |\n-| ARM             | Linux            |\n-| ARM             | iOS              |\n-| AVR32           | Linux            |\n-| Blackfin        | uClinux          |\n-| HPPA            | HPUX             |\n-| IA-64           | Linux            |\n-| M68K            | FreeMiNT         |\n-| M68K            | RTEMS            |\n-| MIPS            | IRIX             |\n-| MIPS            | Linux            |\n-| MIPS            | RTEMS            |\n-| MIPS64          | Linux            |\n-| PowerPC         | AMIGA            |\n-| PowerPC         | Linux            |\n-| PowerPC         | Mac OSX          |\n-| PowerPC         | FreeBSD          |\n-| PowerPC64       | Linux            |\n-| S390            | Linux            |\n-| S390X           | Linux            |\n-| SPARC           | Linux            |\n-| SPARC           | Solaris          |\n-| SPARC64         | Linux            |\n-| SPARC64         | FreeBSD          |\n-| TILE-Gx/TILEPro | Linux            |\n-| X86             | FreeBSD          |\n-| X86             | Interix          |\n-| X86             | kFreeBSD         |\n-| X86             | Linux            |\n-| X86             | Mac OSX          |\n-| X86             | OpenBSD          |\n-| X86             | OS/2             |\n-| X86             | Solaris          |\n-| X86             | Windows/Cygwin   |\n-| X86             | Windows/MingW    |\n-| X86-64          | FreeBSD          |\n-| X86-64          | Linux            |\n-| X86-64          | Linux/x32        |\n-| X86-64          | OpenBSD          |\n-| X86-64          | Windows/MingW    |\n-|-----------------+------------------|\n+|-----------------+------------------+-------------------------|\n+| Architecture    | Operating System | Compiler                |\n+|-----------------+------------------+-------------------------|\n+| AArch64 (ARM64) | iOS              | Clang                   |\n+| AArch64         | Linux            | GCC                     |\n+| Alpha           | Linux            | GCC                     |\n+| Alpha           | Tru64            | GCC                     |\n+| ARC             | Linux            | GCC                     |\n+| ARM             | Linux            | GCC                     |\n+| ARM             | iOS              | GCC                     |\n+| AVR32           | Linux            | GCC                     |\n+| Blackfin        | uClinux          | GCC                     |\n+| HPPA            | HPUX             | GCC                     |\n+| IA-64           | Linux            | GCC                     |\n+| M68K            | FreeMiNT         | GCC                     |\n+| M68K            | Linux            | GCC                     |\n+| M68K            | RTEMS            | GCC                     |\n+| M88K            | OpenBSD/mvme88k  | GCC                     |\n+| Meta            | Linux            | GCC                     |\n+| MicroBlaze      | Linux            | GCC                     |\n+| MIPS            | IRIX             | GCC                     |\n+| MIPS            | Linux            | GCC                     |\n+| MIPS            | RTEMS            | GCC                     |\n+| MIPS64          | Linux            | GCC                     |\n+| Moxie           | Bare metal       | GCC                     |\n+| Nios II         | Linux            | GCC                     |\n+| OpenRISC        | Linux            | GCC                     |\n+| PowerPC 32-bit  | AIX              | IBM XL C                |\n+| PowerPC 64-bit  | AIX              | IBM XL C                |\n+| PowerPC         | AMIGA            | GCC                     |\n+| PowerPC         | Linux            | GCC                     |\n+| PowerPC         | Mac OSX          | GCC                     |\n+| PowerPC         | FreeBSD          | GCC                     |\n+| PowerPC 64-bit  | FreeBSD          | GCC                     |\n+| PowerPC 64-bit  | Linux ELFv1      | GCC                     |\n+| PowerPC 64-bit  | Linux ELFv2      | GCC                     |\n+| S390            | Linux            | GCC                     |\n+| S390X           | Linux            | GCC                     |\n+| SPARC           | Linux            | GCC                     |\n+| SPARC           | Solaris          | GCC                     |\n+| SPARC           | Solaris          | Oracle Solaris Studio C |\n+| SPARC64         | Linux            | GCC                     |\n+| SPARC64         | FreeBSD          | GCC                     |\n+| SPARC64         | Solaris          | Oracle Solaris Studio C |\n+| TILE-Gx/TILEPro | Linux            | GCC                     |\n+| VAX             | OpenBSD/vax      | GCC                     |\n+| X86             | FreeBSD          | GCC                     |\n+| X86             | GNU HURD         | GCC                     |\n+| X86             | Interix          | GCC                     |\n+| X86             | kFreeBSD         | GCC                     |\n+| X86             | Linux            | GCC                     |\n+| X86             | Mac OSX          | GCC                     |\n+| X86             | OpenBSD          | GCC                     |\n+| X86             | OS/2             | GCC                     |\n+| X86             | Solaris          | GCC                     |\n+| X86             | Solaris          | Oracle Solaris Studio C |\n+| X86             | Windows/Cygwin   | GCC                     |\n+| X86             | Windows/MingW    | GCC                     |\n+| X86-64          | FreeBSD          | GCC                     |\n+| X86-64          | Linux            | GCC                     |\n+| X86-64          | Linux/x32        | GCC                     |\n+| X86-64          | OpenBSD          | GCC                     |\n+| X86-64          | Solaris          | Oracle Solaris Studio C |\n+| X86-64          | Windows/Cygwin   | GCC                     |\n+| X86-64          | Windows/MingW    | GCC                     |\n+| Xtensa          | Linux            | GCC                     |\n+|-----------------+------------------+-------------------------|\n \n Please send additional platform test results to\n libffi-discuss@sourceware.org and feel free to update the wiki page\n@@ -107,6 +128,9 @@ system. Go to the directory you wish to build libffi in and run the\n \"configure\" program found in the root directory of the libffi source\n distribution.\n \n+If you're building libffi directly from version control, configure won't\n+exist yet; run ./autogen.sh first.\n+\n You may want to tell configure where to install the libffi library and\n header files. To do that, use the --prefix configure switch.  Libffi\n will install under /usr/local by default. \n@@ -124,20 +148,28 @@ It's also possible to build libffi on Windows platforms with\n Microsoft's Visual C++ compiler.  In this case, use the msvcc.sh\n wrapper script during configuration like so:\n \n-path/to/configure CC=path/to/msvcc.sh LD=link CPP=\\\"cl -nologo -EP\\\"\n+path/to/configure CC=path/to/msvcc.sh CXX=path/to/msvcc.sh LD=link CPP=\"cl -nologo -EP\"\n+\n+For 64-bit Windows builds, use CC=\"path/to/msvcc.sh -m64\" and\n+CXX=\"path/to/msvcc.sh -m64\".  You may also need to specify --build\n+appropriately.\n+\n+It is also possible to build libffi on Windows platforms with the LLVM\n+project's clang-cl compiler, like below:\n+\n+path/to/configure CC=\"path/to/msvcc.sh -clang-cl\" CXX=\"path/to/msvcc.sh -clang-cl\" LD=link CPP=\"clang-cl -EP\"\n \n-For 64-bit Windows builds, use CC=\"path/to/msvcc.sh -m64\".\n-You may also need to specify --build appropriately. When building with MSVC\n-under a MingW environment, you may need to remove the line in configure\n-that sets 'fix_srcfile_path' to a 'cygpath' command. ('cygpath' is not\n-present in MingW, and is not required when using MingW-style paths.)\n+When building with MSVC under a MingW environment, you may need to\n+remove the line in configure that sets 'fix_srcfile_path' to a 'cygpath'\n+command.  ('cygpath' is not present in MingW, and is not required when\n+using MingW-style paths.)\n \n For iOS builds, the 'libffi.xcodeproj' Xcode project is available.\n \n Configure has many other options. Use \"configure --help\" to see them all.\n \n Once configure has finished, type \"make\". Note that you must be using\n-GNU make.  You can ftp GNU make from prep.ai.mit.edu:/pub/gnu.\n+GNU make.  You can ftp GNU make from ftp.gnu.org:/pub/gnu/make .\n \n To ensure that libffi is working as advertised, type \"make check\".\n This will require that you have DejaGNU installed.\n@@ -148,17 +180,59 @@ To install the library and header files, type \"make install\".\n History\n =======\n \n-See the ChangeLog files for details.\n-\n-3.0.12 XXX-XX-XX\n+See the git log for details at http://github.com/atgreen/libffi.\n+\n+4.0 TBD\n+        New API in support of GO closures.\n+\n+3.2.1 Nov-12-14\n+        Build fix for non-iOS AArch64 targets.\n+\n+3.2 Nov-11-14\n+        Add C99 Complex Type support (currently only supported on\n+          s390).\n+\tAdd support for PASCAL and REGISTER calling conventions on x86\n+\t  Windows/Linux.\n+\tAdd OpenRISC and Cygwin-64 support.\n+        Bug fixes.\n+\n+3.1 May-19-14\n+        Add AArch64 (ARM64) iOS support.\n+        Add Nios II support.\n+        Add m88k and DEC VAX support.\n+\tAdd support for stdcall, thiscall, and fastcall on non-Windows\n+\t  32-bit x86 targets such as Linux.\n+\tVarious Android, MIPS N32, x86, FreeBSD and UltraSPARC IIi\n+\t  fixes.\n+\tMake the testsuite more robust: eliminate several spurious\n+\t  failures, and respect the $CC and $CXX environment variables.\n+\tArchive off the manually maintained ChangeLog in favor of git\n+\t  log.\n+\n+3.0.13 Mar-17-13\n+\tAdd Meta support.\n+\tAdd missing Moxie bits.\n+\tFix stack alignment bug on 32-bit x86.\n+\tBuild fix for m68000 targets.\n+\tBuild fix for soft-float Power targets.\n+\tFix the install dir location for some platforms when building\n+\t  with GCC (OS X, Solaris).\n+\tFix Cygwin regression.\n+\n+3.0.12 Feb-11-13\n+        Add Moxie support.\n+\tAdd AArch64 support.\n \tAdd Blackfin support.\n \tAdd TILE-Gx/TILEPro support.\n-\tAdd AArch64 support.\n+\tAdd MicroBlaze support.\n+\tAdd Xtensa support.\n \tAdd support for PaX enabled kernels with MPROTECT.\n+\tAdd support for native vendor compilers on\n+\t  Solaris and AIX.\n+\tWork around LLVM/GCC interoperability issue on x86_64.\n \n 3.0.11 Apr-11-12\n         Lots of build fixes.\n-\tAdd Amiga newer MacOS support.\n \tAdd support for variadic functions (ffi_prep_cif_var).\n \tAdd Linux/x32 support.\n \tAdd thiscall, fastcall and MSVC cdecl support on Windows.\n@@ -167,7 +241,6 @@ See the ChangeLog files for details.\n \tIntegration with iOS' xcode build tools.\n \tFix Octeon and MC68881 support.\n \tFix code pessimizations.\n-\tLots of build fixes.\n \n 3.0.10 Aug-23-11\n         Add support for Apple's iOS.\n@@ -311,7 +384,7 @@ See the ChangeLog files for details.\n Authors & Credits\n =================\n \n-libffi was originally written by Anthony Green <green@redhat.com>.\n+libffi was originally written by Anthony Green <green@moxielogic.com>.\n \n The developers of the GNU Compiler Collection project have made\n innumerable valuable contributions.  See the ChangeLog file for\n@@ -335,8 +408,13 @@ frv\t\tAnthony Green\n ia64\t\tHans Boehm\n m32r\t\tKazuhiro Inaoka\n m68k\t\tAndreas Schwab\n+m88k\t\tMiod Vallat\n+microblaze\tNathan Rossi\n mips\t\tAnthony Green, Casey Marshall\n mips64\t\tDavid Daney\n+moxie\t\tAnthony Green\n+nios ii\t\tSandra Loosemore\n+openrisc        Sebastian Macke\n pa\t\tRandolph Chung, Dave Anglin, Andreas Tobler\n powerpc\t\tGeoffrey Keating, Andreas Tobler, \n \t\t\t David Edelsohn, John Hornkvist\n@@ -346,8 +424,10 @@ sh\t\tKaz Kojima\n sh64\t\tKaz Kojima\n sparc\t\tAnthony Green, Gordon Irlam\n tile-gx/tilepro Walter Lee\n+vax\t\tMiod Vallat\n x86\t\tAnthony Green, Jon Beniston\n x86-64\t\tBo Thorsen\n+xtensa\t\tChris Zankel\n \n Jesper Skov and Andrew Haley both did more than their fair share of\n stepping through the code and tracking down bugs."}, {"sha": "3dea242255ee90d0fafbdf200977457755b0c56e", "filename": "libffi/build-ios.sh", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e22fcb7985349b93646b86351033e1fb09c46c/libffi%2Fbuild-ios.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e22fcb7985349b93646b86351033e1fb09c46c/libffi%2Fbuild-ios.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fbuild-ios.sh?ref=62e22fcb7985349b93646b86351033e1fb09c46c", "patch": "@@ -1,67 +0,0 @@\n-#!/bin/sh\n-\n-PLATFORM_IOS=/Developer/Platforms/iPhoneOS.platform/\n-PLATFORM_IOS_SIM=/Developer/Platforms/iPhoneSimulator.platform/\n-SDK_IOS_VERSION=\"4.2\"\n-MIN_IOS_VERSION=\"3.0\"\n-OUTPUT_DIR=\"universal-ios\"\n-\n-build_target () {\n-    local platform=$1\n-    local sdk=$2\n-    local arch=$3\n-    local triple=$4\n-    local builddir=$5\n-\n-    mkdir -p \"${builddir}\"\n-    pushd \"${builddir}\"\n-    export CC=\"${platform}\"/Developer/usr/bin/gcc-4.2\n-    export CFLAGS=\"-arch ${arch} -isysroot ${sdk} -miphoneos-version-min=${MIN_IOS_VERSION}\"\n-    ../configure --host=${triple} && make\n-    popd\n-}\n-\n-# Build all targets\n-build_target \"${PLATFORM_IOS}\" \"${PLATFORM_IOS}/Developer/SDKs/iPhoneOS${SDK_IOS_VERSION}.sdk/\" armv6 arm-apple-darwin10 armv6-ios\n-build_target \"${PLATFORM_IOS}\" \"${PLATFORM_IOS}/Developer/SDKs/iPhoneOS${SDK_IOS_VERSION}.sdk/\" armv7 arm-apple-darwin10 armv7-ios\n-build_target \"${PLATFORM_IOS_SIM}\" \"${PLATFORM_IOS_SIM}/Developer/SDKs/iPhoneSimulator${SDK_IOS_VERSION}.sdk/\" i386 i386-apple-darwin10 i386-ios-sim\n-\n-# Create universal output directories\n-mkdir -p \"${OUTPUT_DIR}\"\n-mkdir -p \"${OUTPUT_DIR}/include\"\n-mkdir -p \"${OUTPUT_DIR}/include/armv6\"\n-mkdir -p \"${OUTPUT_DIR}/include/armv7\"\n-mkdir -p \"${OUTPUT_DIR}/include/i386\"\n-\n-# Create the universal binary\n-lipo -create armv6-ios/.libs/libffi.a armv7-ios/.libs/libffi.a i386-ios-sim/.libs/libffi.a -output \"${OUTPUT_DIR}/libffi.a\"\n-\n-# Copy in the headers\n-copy_headers () {\n-    local src=$1\n-    local dest=$2\n-\n-    # Fix non-relative header reference\n-    sed 's/<ffitarget.h>/\"ffitarget.h\"/' < \"${src}/include/ffi.h\" > \"${dest}/ffi.h\"\n-    cp \"${src}/include/ffitarget.h\" \"${dest}\"\n-}\n-\n-copy_headers armv6-ios \"${OUTPUT_DIR}/include/armv6\"\n-copy_headers armv7-ios \"${OUTPUT_DIR}/include/armv7\"\n-copy_headers i386-ios-sim \"${OUTPUT_DIR}/include/i386\"\n-\n-# Create top-level header\n-(\n-cat << EOF\n-#ifdef __arm__\n-  #include <arm/arch.h>\n-  #ifdef _ARM_ARCH_6\n-    #include \"include/armv6/ffi.h\"\n-  #elif _ARM_ARCH_7\n-    #include \"include/armv7/ffi.h\"\n-  #endif\n-#elif defined(__i386__)\n-  #include \"include/i386/ffi.h\"\n-#endif\n-EOF\n-) > \"${OUTPUT_DIR}/ffi.h\""}, {"sha": "f580af0f69bc0350580b8e4924164429e429c512", "filename": "libffi/configure", "status": "modified", "additions": 4155, "deletions": 839, "changes": 4994, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "07ec10d42e7221547ef4d3a7bcfaf2a97d2b1886", "filename": "libffi/configure.ac", "status": "modified", "additions": 81, "deletions": 238, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure.ac?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -2,16 +2,14 @@ dnl Process this with autoconf to create configure\n \n AC_PREREQ(2.64)\n \n-AC_INIT([libffi], [3.0.11], [http://gcc.gnu.org/bugs.html])\n+AC_INIT([libffi], [3.99999], [http://github.com/atgreen/libffi/issues])\n AC_CONFIG_HEADERS([fficonfig.h])\n \n AM_ENABLE_MULTILIB(, ..)\n \n AC_CANONICAL_SYSTEM\n target_alias=${target_alias-$host_alias}\n \n-. ${srcdir}/configure.host\n-\n AM_INIT_AUTOMAKE([no-dist])\n \n # See if makeinfo has been installed and is modern enough\n@@ -43,10 +41,16 @@ AM_CONDITIONAL(GENINSRC, test \"$enable_generated_files_in_srcdir\" = yes)\n # We must force CC to /not/ be precious variables; otherwise\n # the wrong, non-multilib-adjusted value will be used in multilibs.\n # As a side effect, we have to subst CFLAGS ourselves.\n+# Also save and restore CFLAGS, since AC_PROG_CC will come up with\n+# defaults of its own if none are provided.\n \n m4_rename([_AC_ARG_VAR_PRECIOUS],[real_PRECIOUS])\n m4_define([_AC_ARG_VAR_PRECIOUS],[])\n+save_CFLAGS=$CFLAGS\n AC_PROG_CC\n+AC_PROG_CXX\n+CFLAGS=$save_CFLAGS\n+m4_undefine([_AC_ARG_VAR_PRECIOUS])\n m4_rename_force([real_PRECIOUS],[_AC_ARG_VAR_PRECIOUS])\n \n AC_SUBST(CFLAGS)\n@@ -55,216 +59,29 @@ AM_PROG_AS\n AM_PROG_CC_C_O\n AC_PROG_LIBTOOL\n \n+# Test for 64-bit build.\n+AC_CHECK_SIZEOF([size_t])\n+\n AM_MAINTAINER_MODE\n \n AC_CHECK_HEADERS(sys/mman.h)\n-AC_CHECK_FUNCS(mmap)\n+AC_CHECK_FUNCS([mmap mkostemp])\n AC_FUNC_MMAP_BLACKLIST\n \n dnl The -no-testsuite modules omit the test subdir.\n AM_CONDITIONAL(TESTSUBDIR, test -d $srcdir/testsuite)\n \n TARGETDIR=\"unknown\"\n HAVE_LONG_DOUBLE_VARIANT=0\n-case \"$host\" in\n-  aarch64*-*-*)\n-\tTARGET=AARCH64; TARGETDIR=aarch64\n-\t;;\n-\n-  alpha*-*-*)\n-\tTARGET=ALPHA; TARGETDIR=alpha;\n-\t# Support 128-bit long double, changeable via command-line switch.\n-\tHAVE_LONG_DOUBLE='defined(__LONG_DOUBLE_128__)'\n-\t;;\n-\n-  arm*-*-*)\n-\tTARGET=ARM; TARGETDIR=arm\n-\t;;\n-\n-  amd64-*-freebsd* | amd64-*-openbsd*)\n-\tTARGET=X86_64; TARGETDIR=x86\n-  \t;;\n-\n-  amd64-*-freebsd*)\n-\tTARGET=X86_64; TARGETDIR=x86\n-\t;;\n-\n-  avr32*-*-*)\n-\tTARGET=AVR32; TARGETDIR=avr32\n-\t;;\n-\n-  bfin*)\n-  \tTARGET=BFIN; TARGETDIR=bfin\n-  \t;;\n-\n-  cris-*-*)\n-\tTARGET=LIBFFI_CRIS; TARGETDIR=cris\n-\t;;\n-\n-  frv-*-*)\n-\tTARGET=FRV; TARGETDIR=frv\n-\t;;\n-\n-  hppa*-*-linux* | parisc*-*-linux* | hppa*-*-openbsd*)\n-\tTARGET=PA_LINUX; TARGETDIR=pa\n-\t;;\n-  hppa*64-*-hpux*)\n-\tTARGET=PA64_HPUX; TARGETDIR=pa\n-\t;;\n-  hppa*-*-hpux*)\n-\tTARGET=PA_HPUX; TARGETDIR=pa\n-\t;;\n-\n-  i?86-*-freebsd* | i?86-*-openbsd*)\n-\tTARGET=X86_FREEBSD; TARGETDIR=x86\n-\t;;\n-  i?86-win32* | i?86-*-cygwin* | i?86-*-mingw* | i?86-*-os2* | i?86-*-interix*)\n-\tTARGET=X86_WIN32; TARGETDIR=x86\n-\t# All mingw/cygwin/win32 builds require -no-undefined for sharedlib.\n-\t# We must also check with_cross_host to decide if this is a native\n-\t# or cross-build and select where to install dlls appropriately.\n-\tif test -n \"$with_cross_host\" &&\n-\t   test x\"$with_cross_host\" != x\"no\"; then\n-\t  AM_LTLDFLAGS='-no-undefined -bindir \"$(toolexeclibdir)\"';\n-\telse\n-\t  AM_LTLDFLAGS='-no-undefined -bindir \"$(bindir)\"';\n-\tfi\n-\t;;\n-  i?86-*-darwin*)\n-\tTARGET=X86_DARWIN; TARGETDIR=x86\n-\t;;\n-  i?86-*-solaris2.1[[0-9]]*)\n-\tTARGET=X86_64; TARGETDIR=x86\n-\t;;\n-  i?86-*-*)\n-\tTARGET=X86_64; TARGETDIR=x86\n-\t;;\n-\n-  ia64*-*-*)\n-\tTARGET=IA64; TARGETDIR=ia64\n-\t;;\n-\n-  m32r*-*-*)\n-\tTARGET=M32R; TARGETDIR=m32r\n-\t;;\n-\n-  m68k-*-*)\n-\tTARGET=M68K; TARGETDIR=m68k\n-\t;;\n-\n-  mips-sgi-irix5.* | mips-sgi-irix6.* | mips*-*-rtems*)\n-\tTARGET=MIPS; TARGETDIR=mips\n-\t;;\n-  mips*-*-linux* | mips*-*-openbsd*)\n-\t# Support 128-bit long double for NewABI.\n-\tHAVE_LONG_DOUBLE='defined(__mips64)'\n-\tTARGET=MIPS; TARGETDIR=mips\n-\t;;\n-\n-  powerpc*-*-linux* | powerpc-*-sysv*)\n-\tTARGET=POWERPC; TARGETDIR=powerpc\n-\tHAVE_LONG_DOUBLE_VARIANT=1\n-\t;;\n-  powerpc-*-amigaos*)\n-\tTARGET=POWERPC; TARGETDIR=powerpc\n-\t;;\n-  powerpc-*-beos*)\n-\tTARGET=POWERPC; TARGETDIR=powerpc\n-\t;;\n-  powerpc-*-darwin* | powerpc64-*-darwin*)\n-\tTARGET=POWERPC_DARWIN; TARGETDIR=powerpc\n-\t;;\n-  powerpc-*-aix* | rs6000-*-aix*)\n-\tTARGET=POWERPC_AIX; TARGETDIR=powerpc\n-\t;;\n-  powerpc-*-freebsd* | powerpc-*-openbsd*)\n-\tTARGET=POWERPC_FREEBSD; TARGETDIR=powerpc\n-\tHAVE_LONG_DOUBLE_VARIANT=1\n-\t;;\n-  powerpc64-*-freebsd*)\n-\tTARGET=POWERPC; TARGETDIR=powerpc\n-\t;;\n-  powerpc*-*-rtems*)\n-\tTARGET=POWERPC; TARGETDIR=powerpc\n-\t;;\n-\n-  s390-*-* | s390x-*-*)\n-\tTARGET=S390; TARGETDIR=s390\n-\t;;\n-\n-  sh-*-* | sh[[34]]*-*-*)\n-\tTARGET=SH; TARGETDIR=sh\n-\t;;\n-  sh64-*-* | sh5*-*-*)\n-\tTARGET=SH64; TARGETDIR=sh64\n-\t;;\n-\n-  sparc*-*-*)\n-\tTARGET=SPARC; TARGETDIR=sparc\n-\t;;\n-\n-  tile*-*)\n-        TARGET=TILE; TARGETDIR=tile\n-        ;;\n-\n-  x86_64-*-darwin*)\n-\tTARGET=X86_DARWIN; TARGETDIR=x86\n-\t;;\n-\n-  x86_64-*-cygwin* | x86_64-*-mingw*)\n-\tTARGET=X86_WIN64; TARGETDIR=x86\n-\t# All mingw/cygwin/win32 builds require -no-undefined for sharedlib.\n-\t# We must also check with_cross_host to decide if this is a native\n-\t# or cross-build and select where to install dlls appropriately.\n-\tif test -n \"$with_cross_host\" &&\n-\t   test x\"$with_cross_host\" != x\"no\"; then\n-\t  AM_LTLDFLAGS='-no-undefined -bindir \"$(toolexeclibdir)\"';\n-\telse\n-\t  AM_LTLDFLAGS='-no-undefined -bindir \"$(bindir)\"';\n-\tfi\n-\t;;\n-\n-  x86_64-*-*)\n-\tTARGET=X86_64; TARGETDIR=x86\n-\t;;\n-esac\n \n-AC_SUBST(AM_RUNTESTFLAGS)\n-AC_SUBST(AM_LTLDFLAGS)\n+. ${srcdir}/configure.host\n \n-if test $TARGETDIR = unknown; then\n+if test -n \"${UNSUPPORTED}\"; then\n   AC_MSG_ERROR([\"libffi has not been ported to $host.\"])\n fi\n \n-AM_CONDITIONAL(MIPS, test x$TARGET = xMIPS)\n-AM_CONDITIONAL(BFIN, test x$TARGET = xBFIN)\n-AM_CONDITIONAL(SPARC, test x$TARGET = xSPARC)\n-AM_CONDITIONAL(X86, test x$TARGET = xX86)\n-AM_CONDITIONAL(X86_FREEBSD, test x$TARGET = xX86_FREEBSD)\n-AM_CONDITIONAL(X86_WIN32, test x$TARGET = xX86_WIN32)\n-AM_CONDITIONAL(X86_WIN64, test x$TARGET = xX86_WIN64)\n-AM_CONDITIONAL(X86_DARWIN, test x$TARGET = xX86_DARWIN)\n-AM_CONDITIONAL(ALPHA, test x$TARGET = xALPHA)\n-AM_CONDITIONAL(IA64, test x$TARGET = xIA64)\n-AM_CONDITIONAL(M32R, test x$TARGET = xM32R)\n-AM_CONDITIONAL(M68K, test x$TARGET = xM68K)\n-AM_CONDITIONAL(POWERPC, test x$TARGET = xPOWERPC)\n-AM_CONDITIONAL(POWERPC_AIX, test x$TARGET = xPOWERPC_AIX)\n-AM_CONDITIONAL(POWERPC_DARWIN, test x$TARGET = xPOWERPC_DARWIN)\n-AM_CONDITIONAL(POWERPC_FREEBSD, test x$TARGET = xPOWERPC_FREEBSD)\n-AM_CONDITIONAL(AARCH64, test x$TARGET = xAARCH64)\n-AM_CONDITIONAL(ARM, test x$TARGET = xARM)\n-AM_CONDITIONAL(AVR32, test x$TARGET = xAVR32)\n-AM_CONDITIONAL(LIBFFI_CRIS, test x$TARGET = xLIBFFI_CRIS)\n-AM_CONDITIONAL(FRV, test x$TARGET = xFRV)\n-AM_CONDITIONAL(S390, test x$TARGET = xS390)\n-AM_CONDITIONAL(X86_64, test x$TARGET = xX86_64)\n-AM_CONDITIONAL(SH, test x$TARGET = xSH)\n-AM_CONDITIONAL(SH64, test x$TARGET = xSH64)\n-AM_CONDITIONAL(PA_LINUX, test x$TARGET = xPA_LINUX)\n-AM_CONDITIONAL(PA_HPUX, test x$TARGET = xPA_HPUX)\n-AM_CONDITIONAL(PA64_HPUX, test x$TARGET = xPA64_HPUX)\n-AM_CONDITIONAL(TILE, test x$TARGET = xTILE)\n+AC_SUBST(AM_RUNTESTFLAGS)\n+AC_SUBST(AM_LTLDFLAGS)\n \n AC_HEADER_STDC\n AC_CHECK_FUNCS(memcpy)\n@@ -295,15 +112,6 @@ AC_C_BIGENDIAN\n \n GCC_AS_CFI_PSEUDO_OP\n \n-AC_CACHE_CHECK([if compiler supports -Qunused-arguments],\n-[libffi_cv_c_unused_arguments],\n-[CFLAGS_hold=$CFLAGS\n-CFLAGS=\"$CFLAGS -Qunused-arguments\"\n-AC_COMPILE_IFELSE([[int i;]],\n-[libffi_cv_c_unused_arguments=yes],\n-[libffi_cv_c_unused_arguments=no])\n-CFLAGS=$CFLAGS_hold])\n-\n if test x$TARGET = xSPARC; then\n     AC_CACHE_CHECK([assembler and linker support unaligned pc related relocs],\n \tlibffi_cv_as_sparc_ua_pcrel, [\n@@ -325,7 +133,7 @@ if test x$TARGET = xSPARC; then\n        libffi_cv_as_register_pseudo_op, [\n        libffi_cv_as_register_pseudo_op=unknown\n        # Check if we have .register\n-       AC_TRY_COMPILE([asm (\".register %g2, #scratch\");],,\n+       AC_TRY_COMPILE(,[asm (\".register %g2, #scratch\");],\n \t\t       [libffi_cv_as_register_pseudo_op=yes],\n \t\t       [libffi_cv_as_register_pseudo_op=no])\n     ])\n@@ -338,16 +146,11 @@ fi\n if test x$TARGET = xX86 || test x$TARGET = xX86_WIN32 || test x$TARGET = xX86_64; then\n     AC_CACHE_CHECK([assembler supports pc related relocs],\n \tlibffi_cv_as_x86_pcrel, [\n-\tlibffi_cv_as_x86_pcrel=yes\n+\tlibffi_cv_as_x86_pcrel=no\n \techo '.text; foo: nop; .data; .long foo-.; .text' > conftest.s\n-\tCFLAGS_hold=$CFLAGS\n-\tif test \"$libffi_cv_c_unused_arguments\" = yes; then\n-\t    CFLAGS=\"$CFLAGS -Qunused-arguments\"\n-\tfi\n-\tif $CC $CFLAGS -c conftest.s 2>&1 | $EGREP -i 'illegal|warning' > /dev/null; then\n-\t    libffi_cv_as_x86_pcrel=no\n+\tif $CC $CFLAGS -c conftest.s > /dev/null 2>&1; then\n+\t    libffi_cv_as_x86_pcrel=yes\n \tfi\n-\tCFLAGS=$CFLAGS_hold\n \t])\n     if test \"x$libffi_cv_as_x86_pcrel\" = xyes; then\n \tAC_DEFINE(HAVE_AS_X86_PCREL, 1,\n@@ -358,7 +161,7 @@ if test x$TARGET = xX86 || test x$TARGET = xX86_WIN32 || test x$TARGET = xX86_64\n        libffi_cv_as_ascii_pseudo_op, [\n        libffi_cv_as_ascii_pseudo_op=unknown\n        # Check if we have .ascii\n-       AC_TRY_COMPILE([asm (\".ascii \\\\\"string\\\\\"\");],,\n+       AC_TRY_COMPILE(,[asm (\".ascii \\\\\"string\\\\\"\");],\n \t\t       [libffi_cv_as_ascii_pseudo_op=yes],\n \t\t       [libffi_cv_as_ascii_pseudo_op=no])\n     ])\n@@ -371,7 +174,7 @@ if test x$TARGET = xX86 || test x$TARGET = xX86_WIN32 || test x$TARGET = xX86_64\n        libffi_cv_as_string_pseudo_op, [\n        libffi_cv_as_string_pseudo_op=unknown\n        # Check if we have .string\n-       AC_TRY_COMPILE([asm (\".string \\\\\"string\\\\\"\");],,\n+       AC_TRY_COMPILE(,[asm (\".string \\\\\"string\\\\\"\");],\n \t\t       [libffi_cv_as_string_pseudo_op=yes],\n \t\t       [libffi_cv_as_string_pseudo_op=no])\n     ])\n@@ -381,6 +184,23 @@ if test x$TARGET = xX86 || test x$TARGET = xX86_WIN32 || test x$TARGET = xX86_64\n     fi\n fi\n \n+if test x$TARGET = xS390; then\n+    AC_CACHE_CHECK([compiler uses zarch features],\n+\tlibffi_cv_as_s390_zarch, [\n+\tlibffi_cv_as_s390_zarch=no\n+\techo 'void foo(void) { bar(); bar(); }' > conftest.c\n+\tif $CC $CFLAGS -S conftest.c > /dev/null 2>&1; then\n+\t    if grep -q brasl conftest.s; then\n+\t        libffi_cv_as_s390_zarch=yes\n+\t    fi\n+\tfi\n+\t])\n+    if test \"x$libffi_cv_as_s390_zarch\" = xyes; then\n+\tAC_DEFINE(HAVE_AS_S390_ZARCH, 1,\n+\t\t  [Define if the compiler uses zarch features.])\n+    fi\n+fi\n+\n # On PaX enable kernels that have MPROTECT enable we can't use PROT_EXEC.\n AC_ARG_ENABLE(pax_emutramp,\n   [  --enable-pax_emutramp       enable pax emulated trampolines, for we can't use PROT_EXEC],\n@@ -407,18 +227,29 @@ AM_CONDITIONAL(FFI_EXEC_TRAMPOLINE_TABLE, test x$FFI_EXEC_TRAMPOLINE_TABLE = x1)\n AC_SUBST(FFI_EXEC_TRAMPOLINE_TABLE)\n \n if test x$TARGET = xX86_64; then\n-    AC_CACHE_CHECK([assembler supports unwind section type],\n+    AC_CACHE_CHECK([toolchain supports unwind section type],\n \tlibffi_cv_as_x86_64_unwind_section_type, [\n-\tlibffi_cv_as_x86_64_unwind_section_type=yes\n-\techo '.section .eh_frame,\"a\",@unwind' > conftest.s\n-\tCFLAGS_hold=$CFLAGS\n-\tif test \"$libffi_cv_c_unused_arguments\" = yes; then\n-\t    CFLAGS=\"$CFLAGS -Qunused-arguments\"\n-\tfi\n-\tif $CC $CFLAGS -c conftest.s 2>&1 | grep -i warning > /dev/null; then\n-\t    libffi_cv_as_x86_64_unwind_section_type=no\n+        cat  > conftest1.s << EOF\n+.text\n+.globl foo\n+foo:\n+jmp bar\n+.section .eh_frame,\"a\",@unwind\n+bar:\n+EOF\n+\n+        cat > conftest2.c  << EOF\n+extern void foo();\n+int main(){foo();}\n+EOF\n+\n+\tlibffi_cv_as_x86_64_unwind_section_type=no\n+\t# we ensure that we can compile _and_ link an assembly file containing an @unwind section\n+\t# since the compiler can support it and not the linker (ie old binutils)\n+\tif $CC -Wa,--fatal-warnings $CFLAGS -c conftest1.s > /dev/null 2>&1 && \\\n+           $CC conftest2.c conftest1.o > /dev/null 2>&1 ; then\n+\t    libffi_cv_as_x86_64_unwind_section_type=yes\n \tfi\n-\tCFLAGS=$CFLAGS_hold\n \t])\n     if test \"x$libffi_cv_as_x86_64_unwind_section_type\" = xyes; then\n \tAC_DEFINE(HAVE_AS_X86_64_UNWIND_SECTION_TYPE, 1,\n@@ -431,13 +262,16 @@ if test \"x$GCC\" = \"xyes\"; then\n       libffi_cv_ro_eh_frame, [\n   \tlibffi_cv_ro_eh_frame=no\n   \techo 'extern void foo (void); void bar (void) { foo (); foo (); }' > conftest.c\n-  \tif $CC $CFLAGS -S -fpic -fexceptions -o conftest.s conftest.c > /dev/null 2>&1; then\n-  \t    if grep '.section.*eh_frame.*\"a\"' conftest.s > /dev/null; then\n-  \t\tlibffi_cv_ro_eh_frame=yes\n-  \t    elif grep '.section.*eh_frame.*#alloc' conftest.c \\\n-  \t\t | grep -v '#write' > /dev/null; then\n-  \t\tlibffi_cv_ro_eh_frame=yes\n-  \t    fi\n+  \tif $CC $CFLAGS -c -fpic -fexceptions -o conftest.o conftest.c > /dev/null 2>&1; then\n+\t    objdump -h conftest.o > conftest.dump 2>&1\n+\t    libffi_eh_frame_line=`grep -n eh_frame conftest.dump | cut -d: -f 1`\n+\t    if test \"x$libffi_eh_frame_line\" != \"x\"; then\n+\t        libffi_test_line=`expr $libffi_eh_frame_line + 1`p\n+\t        sed -n $libffi_test_line conftest.dump > conftest.line\n+\t        if grep READONLY conftest.line > /dev/null; then\n+\t            libffi_cv_ro_eh_frame=yes\n+\t        fi\n+\t    fi\n   \tfi\n   \trm -f conftest.*\n       ])\n@@ -487,6 +321,14 @@ AH_BOTTOM([\n AC_SUBST(TARGET)\n AC_SUBST(TARGETDIR)\n \n+changequote(<,>)\n+TARGET_OBJ=\n+for i in $SOURCES; do\n+  TARGET_OBJ=\"${TARGET_OBJ} src/${TARGETDIR}/\"`echo $i | sed 's/[cS]$/lo/'`\n+done\n+changequote([,])\n+AC_SUBST(TARGET_OBJ)\n+\n AC_SUBST(SHELL)\n \n AC_ARG_ENABLE(debug,\n@@ -499,13 +341,14 @@ AM_CONDITIONAL(FFI_DEBUG, test \"$enable_debug\" = \"yes\")\n AC_ARG_ENABLE(structs,\n [  --disable-structs       omit code for struct support],\n   if test \"$enable_structs\" = \"no\"; then\n-    AC_DEFINE(FFI_NO_STRUCTS, 1, [Define this is you do not want support for aggregate types.])\n+    AC_DEFINE(FFI_NO_STRUCTS, 1, [Define this if you do not want support for aggregate types.])\n   fi)\n+AM_CONDITIONAL(FFI_DEBUG, test \"$enable_debug\" = \"yes\")\n \n AC_ARG_ENABLE(raw-api,\n [  --disable-raw-api       make the raw api unavailable],\n   if test \"$enable_raw_api\" = \"no\"; then\n-    AC_DEFINE(FFI_NO_RAW_API, 1, [Define this is you do not want support for the raw API.])\n+    AC_DEFINE(FFI_NO_RAW_API, 1, [Define this if you do not want support for the raw API.])\n   fi)\n \n AC_ARG_ENABLE(purify-safety,\n@@ -544,6 +387,6 @@ test -d src/$TARGETDIR || mkdir src/$TARGETDIR\n \n AC_CONFIG_LINKS(include/ffitarget.h:src/$TARGETDIR/ffitarget.h)\n \n-AC_CONFIG_FILES(include/Makefile include/ffi.h Makefile testsuite/Makefile man/Makefile)\n+AC_CONFIG_FILES(include/Makefile include/ffi.h Makefile testsuite/Makefile man/Makefile libffi.pc)\n \n AC_OUTPUT"}, {"sha": "90de638b30cbb6352cb181af3a6e0df8d673ec9e", "filename": "libffi/configure.host", "status": "modified", "additions": 258, "deletions": 4, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fconfigure.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fconfigure.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure.host?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -1,11 +1,265 @@\n # configure.host\n #\n # This shell script handles all host based configuration for libffi.\n-# \n+#\n \n # THIS TABLE IS SORTED.  KEEP IT THAT WAY.\n+# Most of the time we can define all the variables all at once...\n case \"${host}\" in\n-  frv*-elf)\n-    LDFLAGS=`echo $LDFLAGS | sed \"s/\\-B[^ ]*libgloss\\/frv\\///\"`\\ -B`pwd`/../libgloss/frv/\n-    ;;\n+  aarch64*-*-*)\n+\tTARGET=AARCH64; TARGETDIR=aarch64\n+\tSOURCES=\"ffi.c sysv.S\"\n+\t;;\n+\n+  alpha*-*-*)\n+\tTARGET=ALPHA; TARGETDIR=alpha;\n+\t# Support 128-bit long double, changeable via command-line switch.\n+\tHAVE_LONG_DOUBLE='defined(__LONG_DOUBLE_128__)'\n+\tSOURCES=\"ffi.c osf.S\"\n+\t;;\n+\n+  arc*-*-*)\n+\tTARGET=ARC; TARGETDIR=arc\n+\tSOURCES=\"ffi.c arcompact.S\"\n+\t;;\n+\n+  arm*-*-*)\n+\tTARGET=ARM; TARGETDIR=arm\n+\tSOURCES=\"ffi.c sysv.S\"\n+\t;;\n+\n+  avr32*-*-*)\n+\tTARGET=AVR32; TARGETDIR=avr32\n+\tSOURCES=\"ffi.c sysv.S\"\n+\t;;\n+\n+  bfin*)\n+\tTARGET=BFIN; TARGETDIR=bfin\n+\tSOURCES=\"ffi.c sysv.S\"\n+\t;;\n+\n+  cris-*-*)\n+\tTARGET=LIBFFI_CRIS; TARGETDIR=cris\n+\tSOURCES=\"ffi.c sysv.S\"\n+\t;;\n+\n+  frv-*-*)\n+\tTARGET=FRV; TARGETDIR=frv\n+\tSOURCES=\"ffi.c eabi.S\"\n+\t;;\n+\n+  hppa*-*-linux* | parisc*-*-linux* | hppa*-*-openbsd*)\n+\tTARGET=PA_LINUX; TARGETDIR=pa\n+\tSOURCES=\"ffi.c linux.S\"\n+\t;;\n+  hppa*64-*-hpux*)\n+\tTARGET=PA64_HPUX; TARGETDIR=pa\n+\t;;\n+  hppa*-*-hpux*)\n+\tTARGET=PA_HPUX; TARGETDIR=pa\n+\tSOURCES=\"ffi.c hpux32.S\"\n+\t;;\n+\n+  i?86-*-freebsd* | i?86-*-openbsd*)\n+\tTARGET=X86_FREEBSD; TARGETDIR=x86\n+\t;;\n+\n+  i?86-win32* | i?86-*-cygwin* | i?86-*-mingw* | i?86-*-os2* | i?86-*-interix* \\\n+  | x86_64-*-cygwin* | x86_64-*-mingw*)\n+\tTARGETDIR=x86\n+\tif test $ac_cv_sizeof_size_t = 4; then\n+\t  TARGET=X86_WIN32\n+\telse\n+\t  TARGET=X86_WIN64\n+\tfi\n+\t# All mingw/cygwin/win32 builds require -no-undefined for sharedlib.\n+\t# We must also check with_cross_host to decide if this is a native\n+\t# or cross-build and select where to install dlls appropriately.\n+\tif test -n \"$with_cross_host\" &&\n+\t   test x\"$with_cross_host\" != x\"no\"; then\n+\t  AM_LTLDFLAGS='-no-undefined -bindir \"$(toolexeclibdir)\"';\n+\telse\n+\t  AM_LTLDFLAGS='-no-undefined -bindir \"$(bindir)\"';\n+\tfi\n+\t;;\n+\n+  i?86-*-darwin* | x86_64-*-darwin*)\n+\tTARGETDIR=x86\n+\tif test $ac_cv_sizeof_size_t = 4; then\n+\t  TARGET=X86_DARWIN\n+\telse\n+\t  TARGET=X86_64_DARWIN\n+\tfi\n+\t;;\n+\n+  i?86-*-* | x86_64-*-* | amd64-*)\n+\tTARGETDIR=x86\n+\tif test $ac_cv_sizeof_size_t = 4; then\n+\t  case \"$host\" in\n+\t    *-gnux32)\n+\t      TARGET=X86_64\n+\t      ;;\n+\t    *)\n+\t      TARGET=X86\n+\t      ;;\n+          esac\n+\telse\n+\t  TARGET=X86_64;\n+\tfi\n+\t;;\n+\n+  ia64*-*-*)\n+\tTARGET=IA64; TARGETDIR=ia64\n+\tSOURCES=\"ffi.c unix.S\"\n+\t;;\n+\n+  m32r*-*-*)\n+\tTARGET=M32R; TARGETDIR=m32r\n+\tSOURCES=\"ffi.c sysv.S\"\n+\t;;\n+\n+  m68k-*-*)\n+\tTARGET=M68K; TARGETDIR=m68k\n+\tSOURCES=\"ffi.c sysv.S\"\n+\t;;\n+\n+  m88k-*-*)\n+\tTARGET=M88K; TARGETDIR=m88k\n+\tSOURCES=\"ffi.c obsd.S\"\n+\t;;\n+\n+  microblaze*-*-*)\n+\tTARGET=MICROBLAZE; TARGETDIR=microblaze\n+\tSOURCES=\"ffi.c sysv.S\"\n+\t;;\n+\n+  moxie-*-*)\n+\tTARGET=MOXIE; TARGETDIR=moxie\n+\tSOURCES=\"ffi.c eabi.S\"\n+\t;;\n+\n+  metag-*-*)\n+\tTARGET=METAG; TARGETDIR=metag\n+\tSOURCES=\"ffi.c sysv.S\"\n+\t;;\n+\n+  mips-sgi-irix5.* | mips-sgi-irix6.* | mips*-*-rtems*)\n+\tTARGET=MIPS; TARGETDIR=mips\n+\t;;\n+  mips*-*linux* | mips*-*-openbsd*)\n+\t# Support 128-bit long double for NewABI.\n+\tHAVE_LONG_DOUBLE='defined(__mips64)'\n+\tTARGET=MIPS; TARGETDIR=mips\n+\t;;\n+\n+  nios2*-linux*)\n+\tTARGET=NIOS2; TARGETDIR=nios2\n+\tSOURCES=\"ffi.c sysv.S\"\n+\t;;\n+\n+  or1k*-linux*)\n+\tTARGET=OR1K; TARGETDIR=or1k\n+\tSOURCES=\"ffi.c sysv.S\"\n+\t;;\n+\n+  powerpc*-*-linux* | powerpc-*-sysv*)\n+\tTARGET=POWERPC; TARGETDIR=powerpc\n+\tHAVE_LONG_DOUBLE_VARIANT=1\n+\t;;\n+  powerpc-*-amigaos*)\n+\tTARGET=POWERPC; TARGETDIR=powerpc\n+\t;;\n+  powerpc-*-beos*)\n+\tTARGET=POWERPC; TARGETDIR=powerpc\n+\t;;\n+  powerpc-*-darwin* | powerpc64-*-darwin*)\n+\tTARGET=POWERPC_DARWIN; TARGETDIR=powerpc\n+\t;;\n+  powerpc-*-aix* | rs6000-*-aix*)\n+\tTARGET=POWERPC_AIX; TARGETDIR=powerpc\n+\t;;\n+  powerpc-*-freebsd* | powerpc-*-openbsd*)\n+\tTARGET=POWERPC_FREEBSD; TARGETDIR=powerpc\n+\tHAVE_LONG_DOUBLE_VARIANT=1\n+\t;;\n+  powerpc64-*-freebsd*)\n+\tTARGET=POWERPC; TARGETDIR=powerpc\n+\t;;\n+  powerpc*-*-rtems*)\n+\tTARGET=POWERPC; TARGETDIR=powerpc\n+\t;;\n+\n+  s390-*-* | s390x-*-*)\n+\tTARGET=S390; TARGETDIR=s390\n+\tSOURCES=\"ffi.c sysv.S\"\n+\t;;\n+\n+  sh-*-* | sh[[34]]*-*-*)\n+\tTARGET=SH; TARGETDIR=sh\n+\tSOURCES=\"ffi.c sysv.S\"\n+\t;;\n+  sh64-*-* | sh5*-*-*)\n+\tTARGET=SH64; TARGETDIR=sh64\n+\tSOURCES=\"ffi.c sysv.S\"\n+\t;;\n+\n+  sparc*-*-*)\n+\tTARGET=SPARC; TARGETDIR=sparc\n+\tSOURCES=\"ffi.c ffi64.c v8.S v9.S\"\n+\t;;\n+\n+  tile*-*)\n+        TARGET=TILE; TARGETDIR=tile\n+\tSOURCES=\"ffi.c tile.S\"\n+        ;;\n+\n+  vax-*-*)\n+\tTARGET=VAX; TARGETDIR=vax\n+\tSOURCES=\"ffi.c elfbsd.S\"\n+\t;;\n+\n+  xtensa*-*)\n+\tTARGET=XTENSA; TARGETDIR=xtensa\n+\tSOURCES=\"ffi.c sysv.S\"\n+\t;;\n+esac\n+\n+# ... but some of the cases above share configury.\n+case \"${TARGET}\" in\n+  MIPS)\n+\tSOURCES=\"ffi.c o32.S n32.S\"\n+\t;;\n+  POWERPC)\n+\tSOURCES=\"ffi.c ffi_sysv.c ffi_linux64.c sysv.S ppc_closure.S\"\n+\tSOURCES=\"${SOURCES} linux64.S linux64_closure.S\"\n+\t;;\n+  POWERPC_AIX)\n+\tSOURCES=\"ffi_darwin.c aix.S aix_closure.S\"\n+\t;;\n+  POWERPC_DARWIN)\n+\tSOURCES=\"ffi_darwin.c darwin.S darwin_closure.S\"\n+\t;;\n+  POWERPC_FREEBSD)\n+\tSOURCES=\"ffi.c ffi_sysv.c sysv.S ppc_closure.S\"\n+\t;;\n+  X86 | X86_FREEBSD | X86_WIN32)\n+\tSOURCES=\"ffi.c sysv.S\"\n+\t;;\n+  X86_64)\n+\tSOURCES=\"ffi64.c unix64.S\"\n+\t;;\n+  X86_WIN64)\n+\tSOURCES=\"ffiw64.c win64.S\"\n+\t;;\n+  X86_DARWIN)\n+\tSOURCES=\"darwin_c.c darwin.S\"\n+\t;;\n+  X86_64_DARWIN)\n+\tSOURCES=\"darwin64_c.c darwin64.S\"\n+\t;;\n esac\n+\n+# If we failed to configure SOURCES, we can't do anything.\n+if test -z \"${SOURCES}\"; then\n+  UNSUPPORTED=1\n+fi"}, {"sha": "b1c9bc367bb9d9bcfc11a2a477f0e984bc2f3f11", "filename": "libffi/doc/libffi.texi", "status": "modified", "additions": 149, "deletions": 4, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fdoc%2Flibffi.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fdoc%2Flibffi.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fdoc%2Flibffi.texi?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -63,14 +63,14 @@ section entitled ``GNU General Public License''.\n @node Introduction\n @chapter What is libffi?\n \n-Compilers for high-level languages generate code that follow certain\n+Compilers for high level languages generate code that follow certain\n conventions.  These conventions are necessary, in part, for separate\n compilation to work.  One such convention is the @dfn{calling\n convention}.  The calling convention is a set of assumptions made by\n the compiler about where function arguments will be found on entry to\n a function.  A calling convention also specifies where the return\n-value for a function is found.  The calling convention is part of\n-what is called the @dfn{ABI} or @dfn{Application Binary Interface}.\n+value for a function is found.  The calling convention is also\n+sometimes called the @dfn{ABI} or @dfn{Application Binary Interface}.\n @cindex calling convention\n @cindex ABI\n @cindex Application Binary Interface\n@@ -247,6 +247,8 @@ int main()\n * Primitive Types::             Built-in types.\n * Structures::                  Structure types.\n * Type Example::                Structure type example.\n+* Complex::                     Complex types.\n+* Complex Type Example::        Complex type example.\n @end menu\n \n @node Primitive Types\n@@ -345,6 +347,20 @@ On other platforms, it is not.\n @tindex ffi_type_pointer\n A generic @code{void *} pointer.  You should use this for all\n pointers, regardless of their real type.\n+\n+@item ffi_type_complex_float\n+@tindex ffi_type_complex_float\n+The C @code{_Complex float} type.\n+\n+@item ffi_type_complex_double\n+@tindex ffi_type_complex_double\n+The C @code{_Complex double} type.\n+\n+@item ffi_type_complex_longdouble\n+@tindex ffi_type_complex_longdouble\n+The C @code{_Complex long double} type.\n+On platforms that have a C @code{long double} type, this is defined.\n+On other platforms, it is not.\n @end table\n \n Each of these is of type @code{ffi_type}, so you must take the address\n@@ -429,6 +445,135 @@ Here is the corresponding code to describe this struct to\n     @}\n @end example\n \n+@node Complex\n+@subsection Complex Types\n+\n+@samp{libffi} supports the complex types defined by the C99\n+standard (@code{_Complex float}, @code{_Complex double} and\n+@code{_Complex long double} with the built-in type descriptors\n+@code{ffi_type_complex_float}, @code{ffi_type_complex_double} and\n+@code{ffi_type_complex_longdouble}.\n+\n+Custom complex types like @code{_Complex int} can also be used.\n+An @code{ffi_type} object has to be defined to describe the\n+complex type to @samp{libffi}.\n+\n+@tindex ffi_type\n+@deftp {Data type} ffi_type\n+@table @code\n+@item size_t size\n+This must be manually set to the size of the complex type.\n+\n+@item unsigned short alignment\n+This must be manually set to the alignment of the complex type.\n+\n+@item unsigned short type\n+For a complex type, this must be set to @code{FFI_TYPE_COMPLEX}.\n+\n+@item ffi_type **elements\n+\n+This is a @samp{NULL}-terminated array of pointers to\n+@code{ffi_type} objects.  The first element is set to the\n+@code{ffi_type} of the complex's base type.  The second element\n+must be set to @code{NULL}.\n+@end table\n+@end deftp\n+\n+The section @ref{Complex Type Example} shows a way to determine\n+the @code{size} and @code{alignment} members in a platform\n+independent way.\n+\n+For platforms that have no complex support in @code{libffi} yet,\n+the functions @code{ffi_prep_cif} and @code{ffi_prep_args} abort\n+the program if they encounter a complex type.\n+\n+@node Complex Type Example\n+@subsection Complex Type Example\n+\n+This example demonstrates how to use complex types:\n+\n+@example\n+#include <stdio.h>\n+#include <ffi.h>\n+#include <complex.h>\n+\n+void complex_fn(_Complex float cf,\n+                _Complex double cd,\n+                _Complex long double cld)\n+@{\n+  printf(\"cf=%f+%fi\\ncd=%f+%fi\\ncld=%f+%fi\\n\",\n+         (float)creal (cf), (float)cimag (cf),\n+         (float)creal (cd), (float)cimag (cd),\n+         (float)creal (cld), (float)cimag (cld));\n+@}\n+\n+int main()\n+@{\n+  ffi_cif cif;\n+  ffi_type *args[3];\n+  void *values[3];\n+  _Complex float cf;\n+  _Complex double cd;\n+  _Complex long double cld;\n+\n+  /* Initialize the argument info vectors */\n+  args[0] = &ffi_type_complex_float;\n+  args[1] = &ffi_type_complex_double;\n+  args[2] = &ffi_type_complex_longdouble;\n+  values[0] = &cf;\n+  values[1] = &cd;\n+  values[2] = &cld;\n+\n+  /* Initialize the cif */\n+  if (ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 3,\n+                   &ffi_type_void, args) == FFI_OK)\n+    @{\n+      cf = 1.0 + 20.0 * I;\n+      cd = 300.0 + 4000.0 * I;\n+      cld = 50000.0 + 600000.0 * I;\n+      /* Call the function */\n+      ffi_call(&cif, (void (*)(void))complex_fn, 0, values);\n+    @}\n+\n+  return 0;\n+@}\n+@end example\n+\n+This is an example for defining a custom complex type descriptor\n+for compilers that support them:\n+\n+@example\n+/*\n+ * This macro can be used to define new complex type descriptors\n+ * in a platform independent way.\n+ *\n+ * name: Name of the new descriptor is ffi_type_complex_<name>.\n+ * type: The C base type of the complex type.\n+ */\n+#define FFI_COMPLEX_TYPEDEF(name, type, ffitype)             \\\n+  static ffi_type *ffi_elements_complex_##name [2] = @{      \\\n+    (ffi_type *)(&ffitype), NULL                             \\\n+  @};                                                        \\\n+  struct struct_align_complex_##name @{                      \\\n+    char c;                                                  \\\n+    _Complex type x;                                         \\\n+  @};                                                        \\\n+  ffi_type ffi_type_complex_##name = @{                      \\\n+    sizeof(_Complex type),                                   \\\n+    offsetof(struct struct_align_complex_##name, x),         \\\n+    FFI_TYPE_COMPLEX,                                        \\\n+    (ffi_type **)ffi_elements_complex_##name                 \\\n+  @}\n+\n+/* Define new complex type descriptors using the macro: */\n+/* ffi_type_complex_sint */\n+FFI_COMPLEX_TYPEDEF(sint, int, ffi_type_sint);\n+/* ffi_type_complex_uchar */\n+FFI_COMPLEX_TYPEDEF(uchar, unsigned char, ffi_type_uint8);\n+@end example\n+\n+The new type descriptors can then be used like one of the built-in\n+type descriptors in the previous example.\n \n @node Multiple ABIs\n @section Multiple ABIs\n@@ -534,7 +679,7 @@ writable and executable addresses.\n @section Closure Example\n \n A trivial example that creates a new @code{puts} by binding \n-@code{fputs} with @code{stdin}.\n+@code{fputs} with @code{stdout}.\n \n @example\n #include <stdio.h>"}, {"sha": "b9b21311f09cde2717dd7737a08c3ba872d18bc7", "filename": "libffi/doc/stamp-vti", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e22fcb7985349b93646b86351033e1fb09c46c/libffi%2Fdoc%2Fstamp-vti", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e22fcb7985349b93646b86351033e1fb09c46c/libffi%2Fdoc%2Fstamp-vti", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fdoc%2Fstamp-vti?ref=62e22fcb7985349b93646b86351033e1fb09c46c", "patch": "@@ -1,4 +0,0 @@\n-@set UPDATED 6 March 2012\n-@set UPDATED-MONTH March 2012\n-@set EDITION 3.0.11\n-@set VERSION 3.0.11"}, {"sha": "ccef70f4931366583c4d4865681fbc4930eeaa3e", "filename": "libffi/doc/version.texi", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fdoc%2Fversion.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fdoc%2Fversion.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fdoc%2Fversion.texi?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -1,4 +1,4 @@\n-@set UPDATED 6 March 2012\n-@set UPDATED-MONTH March 2012\n-@set EDITION 3.0.11\n-@set VERSION 3.0.11\n+@set UPDATED 8 November 2014\n+@set UPDATED-MONTH November 2014\n+@set EDITION 3.2.1\n+@set VERSION 3.2.1"}, {"sha": "f245ce00da260c6019d1ee6bc878ed41d2679374", "filename": "libffi/fficonfig.h.in", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ffficonfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ffficonfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ffficonfig.h.in?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -26,10 +26,10 @@\n /* Cannot use malloc on this target, so, we revert to alternative means */\n #undef FFI_MMAP_EXEC_WRIT\n \n-/* Define this is you do not want support for the raw API. */\n+/* Define this if you do not want support for the raw API. */\n #undef FFI_NO_RAW_API\n \n-/* Define this is you do not want support for aggregate types. */\n+/* Define this if you do not want support for aggregate types. */\n #undef FFI_NO_STRUCTS\n \n /* Define to 1 if you have `alloca', as a function or macro. */\n@@ -48,6 +48,9 @@\n /* Define if your assembler supports .register. */\n #undef HAVE_AS_REGISTER_PSEUDO_OP\n \n+/* Define if the compiler uses zarch features. */\n+#undef HAVE_AS_S390_ZARCH\n+\n /* Define if your assembler and linker support unaligned PC relative relocs.\n    */\n #undef HAVE_AS_SPARC_UA_PCREL\n@@ -82,6 +85,9 @@\n /* Define to 1 if you have the <memory.h> header file. */\n #undef HAVE_MEMORY_H\n \n+/* Define to 1 if you have the `mkostemp' function. */\n+#undef HAVE_MKOSTEMP\n+\n /* Define to 1 if you have the `mmap' function. */\n #undef HAVE_MMAP\n \n@@ -155,6 +161,9 @@\n /* The size of `long double', as computed by sizeof. */\n #undef SIZEOF_LONG_DOUBLE\n \n+/* The size of `size_t', as computed by sizeof. */\n+#undef SIZEOF_SIZE_T\n+\n /* If using the C implementation of alloca, define if you know the\n    direction of stack growth for your system; otherwise it will be\n    automatically deduced at runtime."}, {"sha": "306136fe44694b2bc224dcf2aedd6891a923b800", "filename": "libffi/generate-darwin-source-and-headers.py", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fgenerate-darwin-source-and-headers.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fgenerate-darwin-source-and-headers.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fgenerate-darwin-source-and-headers.py?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -0,0 +1,209 @@\n+#!/usr/bin/env python\n+import subprocess\n+import os\n+import errno\n+import collections\n+import glob\n+import argparse\n+\n+class Platform(object):\n+    pass\n+\n+class simulator_platform(Platform):\n+    directory = 'darwin_ios'\n+    sdk = 'iphonesimulator'\n+    arch = 'i386'\n+    triple = 'i386-apple-darwin11'\n+    version_min = '-miphoneos-version-min=7.0'\n+\n+    prefix = \"#ifdef __i386__\\n\\n\"\n+    suffix = \"\\n\\n#endif\"\n+    src_dir = 'x86'\n+    src_files = ['darwin.S', 'win32.S', 'ffi.c']\n+\n+\n+class simulator64_platform(Platform):\n+    directory = 'darwin_ios'\n+    sdk = 'iphonesimulator'\n+    arch = 'x86_64'\n+    triple = 'x86_64-apple-darwin13'\n+    version_min = '-miphoneos-version-min=7.0'\n+\n+    prefix = \"#ifdef __x86_64__\\n\\n\"\n+    suffix = \"\\n\\n#endif\"\n+    src_dir = 'x86'\n+    src_files = ['darwin64.S', 'ffi64.c']\n+\n+\n+class device_platform(Platform):\n+    directory = 'darwin_ios'\n+    sdk = 'iphoneos'\n+    arch = 'armv7'\n+    triple = 'arm-apple-darwin11'\n+    version_min = '-miphoneos-version-min=7.0'\n+\n+    prefix = \"#ifdef __arm__\\n\\n\"\n+    suffix = \"\\n\\n#endif\"\n+    src_dir = 'arm'\n+    src_files = ['sysv.S', 'trampoline.S', 'ffi.c']\n+\n+\n+class device64_platform(Platform):\n+    directory = 'darwin_ios'\n+    sdk = 'iphoneos'\n+    arch = 'arm64'\n+    triple = 'aarch64-apple-darwin13'\n+    version_min = '-miphoneos-version-min=7.0'\n+\n+    prefix = \"#ifdef __arm64__\\n\\n\"\n+    suffix = \"\\n\\n#endif\"\n+    src_dir = 'aarch64'\n+    src_files = ['sysv.S', 'ffi.c']\n+\n+\n+class desktop32_platform(Platform):\n+    directory = 'darwin_osx'\n+    sdk = 'macosx'\n+    arch = 'i386'\n+    triple = 'i386-apple-darwin10'\n+    version_min = '-mmacosx-version-min=10.6'\n+    src_dir = 'x86'\n+    src_files = ['darwin.S', 'win32.S', 'ffi.c']\n+\n+    prefix = \"#ifdef __i386__\\n\\n\"\n+    suffix = \"\\n\\n#endif\"\n+\n+\n+class desktop64_platform(Platform):\n+    directory = 'darwin_osx'\n+    sdk = 'macosx'\n+    arch = 'x86_64'\n+    triple = 'x86_64-apple-darwin10'\n+    version_min = '-mmacosx-version-min=10.6'\n+\n+    prefix = \"#ifdef __x86_64__\\n\\n\"\n+    suffix = \"\\n\\n#endif\"\n+    src_dir = 'x86'\n+    src_files = ['darwin64.S', 'ffi64.c']\n+\n+\n+def mkdir_p(path):\n+    try:\n+        os.makedirs(path)\n+    except OSError as exc:  # Python >2.5\n+        if exc.errno == errno.EEXIST:\n+            pass\n+        else:\n+            raise\n+\n+\n+def move_file(src_dir, dst_dir, filename, file_suffix=None, prefix='', suffix=''):\n+    mkdir_p(dst_dir)\n+    out_filename = filename\n+\n+    if file_suffix:\n+        split_name = os.path.splitext(filename)\n+        out_filename = \"%s_%s%s\" % (split_name[0], file_suffix, split_name[1])\n+\n+    with open(os.path.join(src_dir, filename)) as in_file:\n+        with open(os.path.join(dst_dir, out_filename), 'w') as out_file:\n+            if prefix:\n+                out_file.write(prefix)\n+\n+            out_file.write(in_file.read())\n+\n+            if suffix:\n+                out_file.write(suffix)\n+\n+\n+def list_files(src_dir, pattern=None, filelist=None):\n+    if pattern: filelist = glob.iglob(os.path.join(src_dir, pattern))\n+    for file in filelist:\n+        yield os.path.basename(file)\n+\n+\n+def copy_files(src_dir, dst_dir, pattern=None, filelist=None, file_suffix=None, prefix=None, suffix=None):\n+    for filename in list_files(src_dir, pattern=pattern, filelist=filelist):\n+        move_file(src_dir, dst_dir, filename, file_suffix=file_suffix, prefix=prefix, suffix=suffix)\n+\n+\n+def copy_src_platform_files(platform):\n+    src_dir = os.path.join('src', platform.src_dir)\n+    dst_dir = os.path.join(platform.directory, 'src', platform.src_dir)\n+    copy_files(src_dir, dst_dir, filelist=platform.src_files, file_suffix=platform.arch, prefix=platform.prefix, suffix=platform.suffix)\n+\n+\n+def build_target(platform, platform_headers):\n+    def xcrun_cmd(cmd):\n+        return 'xcrun -sdk %s %s -arch %s' % (platform.sdk, cmd, platform.arch)\n+\n+    tag='%s-%s' % (platform.sdk, platform.arch)\n+    build_dir = 'build_%s' % tag\n+    mkdir_p(build_dir)\n+    env = dict(CC=xcrun_cmd('clang'),\n+               LD=xcrun_cmd('ld'),\n+               CFLAGS='%s' % (platform.version_min))\n+    working_dir = os.getcwd()\n+    try:\n+        os.chdir(build_dir)\n+        subprocess.check_call(['../configure', '-host', platform.triple], env=env)\n+    finally:\n+        os.chdir(working_dir)\n+\n+    for src_dir in [build_dir, os.path.join(build_dir, 'include')]:\n+        copy_files(src_dir,\n+                   os.path.join(platform.directory, 'include'),\n+                   pattern='*.h',\n+                   file_suffix=platform.arch,\n+                   prefix=platform.prefix,\n+                   suffix=platform.suffix)\n+\n+        for filename in list_files(src_dir, pattern='*.h'):\n+            platform_headers[filename].add((platform.prefix, platform.arch, platform.suffix))\n+\n+\n+def make_tramp():\n+    with open('src/arm/trampoline.S', 'w') as tramp_out:\n+        p = subprocess.Popen(['bash', 'src/arm/gentramp.sh'], stdout=tramp_out)\n+        p.wait()\n+\n+\n+def generate_source_and_headers(generate_osx=True, generate_ios=True):\n+    copy_files('src', 'darwin_common/src', pattern='*.c')\n+    copy_files('include', 'darwin_common/include', pattern='*.h')\n+\n+    if generate_ios:\n+        make_tramp()\n+        copy_src_platform_files(simulator_platform)\n+        copy_src_platform_files(simulator64_platform)\n+        copy_src_platform_files(device_platform)\n+        copy_src_platform_files(device64_platform)\n+    if generate_osx:\n+        copy_src_platform_files(desktop32_platform)\n+        copy_src_platform_files(desktop64_platform)\n+\n+    platform_headers = collections.defaultdict(set)\n+\n+    if generate_ios:\n+        build_target(simulator_platform, platform_headers)\n+        build_target(simulator64_platform, platform_headers)\n+        build_target(device_platform, platform_headers)\n+        build_target(device64_platform, platform_headers)\n+    if generate_osx:\n+        build_target(desktop32_platform, platform_headers)\n+        build_target(desktop64_platform, platform_headers)\n+\n+    mkdir_p('darwin_common/include')\n+    for header_name, tag_tuples in platform_headers.iteritems():\n+        basename, suffix = os.path.splitext(header_name)\n+        with open(os.path.join('darwin_common/include', header_name), 'w') as header:\n+            for tag_tuple in tag_tuples:\n+                header.write('%s#include <%s_%s%s>\\n%s\\n' % (tag_tuple[0], basename, tag_tuple[1], suffix, tag_tuple[2]))\n+\n+if __name__ == '__main__':\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument('--only-ios', action='store_true', default=False)\n+    parser.add_argument('--only-osx', action='store_true', default=False)\n+    args = parser.parse_args()\n+\n+    generate_source_and_headers(generate_osx=not args.only_ios, generate_ios=not args.only_osx)"}, {"sha": "c2bca734ef17e111b963e7f59a745f98d124cc22", "filename": "libffi/generate-ios-source-and-headers.py", "status": "removed", "additions": 0, "deletions": 160, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e22fcb7985349b93646b86351033e1fb09c46c/libffi%2Fgenerate-ios-source-and-headers.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e22fcb7985349b93646b86351033e1fb09c46c/libffi%2Fgenerate-ios-source-and-headers.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fgenerate-ios-source-and-headers.py?ref=62e22fcb7985349b93646b86351033e1fb09c46c", "patch": "@@ -1,160 +0,0 @@\n-#!/usr/bin/env python\n-\n-import subprocess\n-import re\n-import os\n-import errno\n-import collections\n-import sys\n-\n-class Platform(object):\n-    pass\n-\n-sdk_re = re.compile(r'.*-sdk ([a-zA-Z0-9.]*)')\n-\n-def sdkinfo(sdkname):\n-    ret = {}\n-    for line in subprocess.Popen(['xcodebuild', '-sdk', sdkname, '-version'], stdout=subprocess.PIPE).stdout:\n-        kv = line.strip().split(': ', 1)\n-        if len(kv) == 2:\n-            k,v = kv\n-            ret[k] = v\n-    return ret\n-\n-sim_sdk_info = sdkinfo('iphonesimulator')\n-device_sdk_info = sdkinfo('iphoneos')\n-\n-def latest_sdks():\n-    latest_sim = None\n-    latest_device = None\n-    for line in subprocess.Popen(['xcodebuild', '-showsdks'], stdout=subprocess.PIPE).stdout:\n-        match = sdk_re.match(line)\n-        if match:\n-            if 'Simulator' in line:\n-                latest_sim = match.group(1)\n-            elif 'iOS' in line:\n-                latest_device = match.group(1)\n-\n-    return latest_sim, latest_device\n-\n-sim_sdk, device_sdk = latest_sdks()\n-\n-class simulator_platform(Platform):\n-    sdk='iphonesimulator'\n-    arch = 'i386'\n-    name = 'simulator'\n-    triple = 'i386-apple-darwin10'\n-    sdkroot = sim_sdk_info['Path']\n-\n-    prefix = \"#if !defined(__arm__) && defined(__i386__)\\n\\n\"\n-    suffix = \"\\n\\n#endif\"\n-\n-class device_platform(Platform):\n-    sdk='iphoneos'\n-    name = 'ios'\n-    arch = 'armv7'\n-    triple = 'arm-apple-darwin10'\n-    sdkroot = device_sdk_info['Path']\n-\n-    prefix = \"#ifdef __arm__\\n\\n\"\n-    suffix = \"\\n\\n#endif\"\n-\n-\n-def move_file(src_dir, dst_dir, filename, file_suffix=None, prefix='', suffix=''):\n-    if not os.path.exists(dst_dir):\n-        os.makedirs(dst_dir)\n-\n-    out_filename = filename\n-\n-    if file_suffix:\n-        split_name = os.path.splitext(filename)\n-        out_filename =  \"%s_%s%s\" % (split_name[0], file_suffix, split_name[1])\n-\n-    with open(os.path.join(src_dir, filename)) as in_file:\n-        with open(os.path.join(dst_dir, out_filename), 'w') as out_file:\n-            if prefix:\n-                out_file.write(prefix)\n-\n-            out_file.write(in_file.read())\n-\n-            if suffix:\n-                out_file.write(suffix)\n-\n-headers_seen = collections.defaultdict(set)\n-\n-def move_source_tree(src_dir, dest_dir, dest_include_dir, arch=None, prefix=None, suffix=None):\n-    for root, dirs, files in os.walk(src_dir, followlinks=True):\n-        relroot = os.path.relpath(root,src_dir)\n-\n-        def move_dir(arch, prefix='', suffix='', files=[]):\n-            for file in files:\n-                file_suffix = None\n-                if file.endswith('.h'):\n-                    if dest_include_dir:\n-                        file_suffix = arch\n-                        if arch:\n-                            headers_seen[file].add(arch)\n-                        move_file(root, dest_include_dir, file, arch, prefix=prefix, suffix=suffix)\n-\n-                elif dest_dir:\n-                    outroot = os.path.join(dest_dir, relroot)\n-                    move_file(root, outroot, file, prefix=prefix, suffix=suffix)\n-\n-        if relroot == '.':\n-            move_dir(arch=arch,\n-                     files=files,\n-                     prefix=prefix,\n-                     suffix=suffix)\n-        elif relroot == 'arm':\n-            move_dir(arch='arm',\n-                     prefix=\"#ifdef __arm__\\n\\n\",\n-                     suffix=\"\\n\\n#endif\",\n-                     files=files)\n-        elif relroot == 'x86':\n-            move_dir(arch='i386',\n-                     prefix=\"#if !defined(__arm__) && defined(__i386__)\\n\\n\",\n-                     suffix=\"\\n\\n#endif\",\n-                     files=files)\n-\n-def build_target(platform):\n-    def xcrun_cmd(cmd):\n-        return subprocess.check_output(['xcrun', '-sdk', platform.sdkroot, '-find', cmd]).strip()\n-\n-    build_dir = 'build_' + platform.name\n-    if not os.path.exists(build_dir):\n-        os.makedirs(build_dir)\n-        env = dict(CC=xcrun_cmd('clang'),\n-                   LD=xcrun_cmd('ld'),\n-                   CFLAGS='-arch %s -isysroot %s -miphoneos-version-min=4.0' % (platform.arch, platform.sdkroot))\n-        working_dir=os.getcwd()\n-        try:\n-            os.chdir(build_dir)\n-            subprocess.check_call(['../configure', '-host', platform.triple], env=env)\n-            move_source_tree('.', None, '../ios/include',\n-                             arch=platform.arch,\n-                             prefix=platform.prefix,\n-                             suffix=platform.suffix)\n-            move_source_tree('./include', None, '../ios/include',\n-                            arch=platform.arch,\n-                            prefix=platform.prefix,\n-                            suffix=platform.suffix)\n-        finally:\n-            os.chdir(working_dir)\n-\n-        for header_name, archs in headers_seen.iteritems():\n-            basename, suffix = os.path.splitext(header_name)\n-\n-def main():\n-    move_source_tree('src', 'ios/src', 'ios/include')\n-    move_source_tree('include', None, 'ios/include')\n-    build_target(simulator_platform)\n-    build_target(device_platform)\n-\n-    for header_name, archs in headers_seen.iteritems():\n-        basename, suffix = os.path.splitext(header_name)\n-        with open(os.path.join('ios/include', header_name), 'w') as header:\n-            for arch in archs:\n-                header.write('#include <%s_%s%s>\\n' % (basename, arch, suffix))\n-\n-if __name__ == '__main__':\n-    main()"}, {"sha": "64313c1a3640db66e0718f4cf0b917eb09ecd613", "filename": "libffi/generate-osx-source-and-headers.py", "status": "removed", "additions": 0, "deletions": 153, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e22fcb7985349b93646b86351033e1fb09c46c/libffi%2Fgenerate-osx-source-and-headers.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e22fcb7985349b93646b86351033e1fb09c46c/libffi%2Fgenerate-osx-source-and-headers.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fgenerate-osx-source-and-headers.py?ref=62e22fcb7985349b93646b86351033e1fb09c46c", "patch": "@@ -1,153 +0,0 @@\n-#!/usr/bin/env python\n-import subprocess\n-import re\n-import os\n-import errno\n-import collections\n-import sys\n-\n-class Platform(object):\n-    pass\n-\n-sdk_re = re.compile(r'.*-sdk ([a-zA-Z0-9.]*)')\n-\n-def sdkinfo(sdkname):\n-    ret = {}\n-    for line in subprocess.Popen(['xcodebuild', '-sdk', sdkname, '-version'], stdout=subprocess.PIPE).stdout:\n-        kv = line.strip().split(': ', 1)\n-        if len(kv) == 2:\n-            k,v = kv\n-            ret[k] = v\n-    return ret\n-\n-desktop_sdk_info = sdkinfo('macosx')\n-\n-def latest_sdks():\n-    latest_desktop = None\n-    for line in subprocess.Popen(['xcodebuild', '-showsdks'], stdout=subprocess.PIPE).stdout:\n-        match = sdk_re.match(line)\n-        if match:\n-            if 'OS X' in line:\n-                latest_desktop = match.group(1)\n-\n-    return latest_desktop\n-\n-desktop_sdk = latest_sdks()\n-\n-class desktop_platform_32(Platform):\n-    sdk='macosx'\n-    arch = 'i386'\n-    name = 'mac32'\n-    triple = 'i386-apple-darwin10'\n-    sdkroot = desktop_sdk_info['Path']\n-\n-    prefix = \"#if defined(__i386__) && !defined(__x86_64__)\\n\\n\"\n-    suffix = \"\\n\\n#endif\"\n-\n-class desktop_platform_64(Platform):\n-    sdk='macosx'\n-    arch = 'x86_64'\n-    name = 'mac'\n-    triple = 'x86_64-apple-darwin10'\n-    sdkroot = desktop_sdk_info['Path']\n-\n-    prefix = \"#if !defined(__i386__) && defined(__x86_64__)\\n\\n\"\n-    suffix = \"\\n\\n#endif\"\n-\n-def move_file(src_dir, dst_dir, filename, file_suffix=None, prefix='', suffix=''):\n-    if not os.path.exists(dst_dir):\n-        os.makedirs(dst_dir)\n-\n-    out_filename = filename\n-\n-    if file_suffix:\n-        split_name = os.path.splitext(filename)\n-        out_filename =  \"%s_%s%s\" % (split_name[0], file_suffix, split_name[1])\n-\n-    with open(os.path.join(src_dir, filename)) as in_file:\n-        with open(os.path.join(dst_dir, out_filename), 'w') as out_file:\n-            if prefix:\n-                out_file.write(prefix)\n-\n-            out_file.write(in_file.read())\n-\n-            if suffix:\n-                out_file.write(suffix)\n-\n-headers_seen = collections.defaultdict(set)\n-\n-def move_source_tree(src_dir, dest_dir, dest_include_dir, arch=None, prefix=None, suffix=None):\n-    for root, dirs, files in os.walk(src_dir, followlinks=True):\n-        relroot = os.path.relpath(root,src_dir)\n-\n-        def move_dir(arch, prefix='', suffix='', files=[]):\n-            for file in files:\n-                file_suffix = None\n-                if file.endswith('.h'):\n-                    if dest_include_dir:\n-                        file_suffix = arch\n-                        if arch:\n-                            headers_seen[file].add(arch)\n-                        move_file(root, dest_include_dir, file, arch, prefix=prefix, suffix=suffix)\n-\n-                elif dest_dir:\n-                    outroot = os.path.join(dest_dir, relroot)\n-                    move_file(root, outroot, file, prefix=prefix, suffix=suffix)\n-\n-        if relroot == '.':\n-            move_dir(arch=arch,\n-                     files=files,\n-                     prefix=prefix,\n-                     suffix=suffix)\n-        elif relroot == 'x86':\n-            move_dir(arch='i386',\n-                     prefix=\"#if defined(__i386__) && !defined(__x86_64__)\\n\\n\",\n-                     suffix=\"\\n\\n#endif\",\n-                     files=files)\n-            move_dir(arch='x86_64',\n-                     prefix=\"#if !defined(__i386__) && defined(__x86_64__)\\n\\n\",\n-                     suffix=\"\\n\\n#endif\",\n-                     files=files)\n-\n-def build_target(platform):\n-    def xcrun_cmd(cmd):\n-        return subprocess.check_output(['xcrun', '-sdk', platform.sdkroot, '-find', cmd]).strip()\n-\n-    build_dir = 'build_' + platform.name\n-    if not os.path.exists(build_dir):\n-        os.makedirs(build_dir)\n-        env = dict(CC=xcrun_cmd('clang'),\n-                   LD=xcrun_cmd('ld'),\n-                   CFLAGS='-arch %s -isysroot %s -mmacosx-version-min=10.6' % (platform.arch, platform.sdkroot))\n-        working_dir=os.getcwd()\n-        try:\n-            os.chdir(build_dir)\n-            subprocess.check_call(['../configure', '-host', platform.triple], env=env)\n-            move_source_tree('.', None, '../osx/include',\n-                             arch=platform.arch,\n-                             prefix=platform.prefix,\n-                             suffix=platform.suffix)\n-            move_source_tree('./include', None, '../osx/include',\n-                             arch=platform.arch,\n-                             prefix=platform.prefix,\n-                             suffix=platform.suffix)\n-        finally:\n-            os.chdir(working_dir)\n-\n-        for header_name, archs in headers_seen.iteritems():\n-            basename, suffix = os.path.splitext(header_name)\n-\n-def main():\n-    move_source_tree('src', 'osx/src', 'osx/include')\n-    move_source_tree('include', None, 'osx/include')\n-    build_target(desktop_platform_32)\n-    build_target(desktop_platform_64)\n-\n-    for header_name, archs in headers_seen.iteritems():\n-        basename, suffix = os.path.splitext(header_name)\n-        with open(os.path.join('osx/include', header_name), 'w') as header:\n-            for arch in archs:\n-                header.write('#include <%s_%s%s>\\n' % (basename, arch, suffix))\n-\n-if __name__ == '__main__':\n-    main()"}, {"sha": "79f222c482ce63912245fe368215e533ab82f6e7", "filename": "libffi/include/Makefile.am", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2FMakefile.am?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -3,7 +3,8 @@\n AUTOMAKE_OPTIONS=foreign\n \n DISTCLEANFILES=ffitarget.h\n-EXTRA_DIST=ffi.h.in ffi_common.h\n+noinst_HEADERS=ffi_common.h ffi_cfi.h\n+EXTRA_DIST=ffi.h.in\n \n # Where generated headers like ffitarget.h get installed.\n gcc_version   := $(shell cat $(top_srcdir)/../gcc/BASE-VER)"}, {"sha": "d8d17f1daef11b70a96e85aff0ace948987e2765", "filename": "libffi/include/Makefile.in", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2FMakefile.in?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -37,7 +37,7 @@ host_triplet = @host@\n target_triplet = @target@\n subdir = include\n DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \\\n-\t$(srcdir)/ffi.h.in $(toollibffi_HEADERS)\n+\t$(srcdir)/ffi.h.in $(noinst_HEADERS) $(toollibffi_HEADERS)\n ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \\\n \t$(top_srcdir)/../config/asmcfi.m4 \\\n@@ -78,7 +78,7 @@ am__base_list = \\\n   sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\\n/ /g' | \\\n   sed '$$!N;$$!N;$$!N;$$!N;s/\\n/ /g'\n am__installdirs = \"$(DESTDIR)$(toollibffidir)\"\n-HEADERS = $(toollibffi_HEADERS)\n+HEADERS = $(noinst_HEADERS) $(toollibffi_HEADERS)\n ETAGS = etags\n CTAGS = ctags\n ACLOCAL = @ACLOCAL@\n@@ -99,6 +99,10 @@ CCDEPMODE = @CCDEPMODE@\n CFLAGS = @CFLAGS@\n CPP = @CPP@\n CPPFLAGS = @CPPFLAGS@\n+CXX = @CXX@\n+CXXCPP = @CXXCPP@\n+CXXDEPMODE = @CXXDEPMODE@\n+CXXFLAGS = @CXXFLAGS@\n CYGPATH_W = @CYGPATH_W@\n DEFS = @DEFS@\n DEPDIR = @DEPDIR@\n@@ -151,12 +155,14 @@ SHELL = @SHELL@\n STRIP = @STRIP@\n TARGET = @TARGET@\n TARGETDIR = @TARGETDIR@\n+TARGET_OBJ = @TARGET_OBJ@\n VERSION = @VERSION@\n abs_builddir = @abs_builddir@\n abs_srcdir = @abs_srcdir@\n abs_top_builddir = @abs_top_builddir@\n abs_top_srcdir = @abs_top_srcdir@\n ac_ct_CC = @ac_ct_CC@\n+ac_ct_CXX = @ac_ct_CXX@\n ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n am__include = @am__include@\n am__leading_dot = @am__leading_dot@\n@@ -212,7 +218,8 @@ top_builddir = @top_builddir@\n top_srcdir = @top_srcdir@\n AUTOMAKE_OPTIONS = foreign\n DISTCLEANFILES = ffitarget.h\n-EXTRA_DIST = ffi.h.in ffi_common.h\n+noinst_HEADERS = ffi_common.h ffi_cfi.h\n+EXTRA_DIST = ffi.h.in\n \n # Where generated headers like ffitarget.h get installed.\n gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)"}, {"sha": "c43d52fd51faf0e9c68805675d3846821109395e", "filename": "libffi/include/ffi.h.in", "status": "modified", "additions": 74, "deletions": 19, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Finclude%2Fffi.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Finclude%2Fffi.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2Fffi.h.in?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -1,5 +1,5 @@\n /* -----------------------------------------------------------------*-C-*-\n-   libffi @VERSION@ - Copyright (c) 2011 Anthony Green\n+   libffi @VERSION@ - Copyright (c) 2011, 2014 Anthony Green\n                     - Copyright (c) 1996-2003, 2007, 2008 Red Hat, Inc.\n \n    Permission is hereby granted, free of charge, to any person\n@@ -68,7 +68,7 @@ extern \"C\" {\n \n #ifndef LIBFFI_ASM\n \n-#ifdef _MSC_VER\n+#if defined(_MSC_VER) && !defined(__clang__)\n #define __attribute__(X)\n #endif\n \n@@ -166,25 +166,49 @@ typedef struct _ffi_type\n  #error \"long size not supported\"\n #endif\n \n+/* Need minimal decorations for DLLs to works on Windows. */\n+/* GCC has autoimport and autoexport.  Rely on Libtool to */\n+/* help MSVC export from a DLL, but always declare data   */\n+/* to be imported for MSVC clients.  This costs an extra  */\n+/* indirection for MSVC clients using the static version  */\n+/* of the library, but don't worry about that.  Besides,  */\n+/* as a workaround, they can define FFI_BUILDING if they  */\n+/* *know* they are going to link with the static library. */\n+#if defined _MSC_VER && !defined FFI_BUILDING\n+#define FFI_EXTERN extern __declspec(dllimport)\n+#else\n+#define FFI_EXTERN extern\n+#endif\n+\n /* These are defined in types.c */\n-extern ffi_type ffi_type_void;\n-extern ffi_type ffi_type_uint8;\n-extern ffi_type ffi_type_sint8;\n-extern ffi_type ffi_type_uint16;\n-extern ffi_type ffi_type_sint16;\n-extern ffi_type ffi_type_uint32;\n-extern ffi_type ffi_type_sint32;\n-extern ffi_type ffi_type_uint64;\n-extern ffi_type ffi_type_sint64;\n-extern ffi_type ffi_type_float;\n-extern ffi_type ffi_type_double;\n-extern ffi_type ffi_type_pointer;\n+FFI_EXTERN ffi_type ffi_type_void;\n+FFI_EXTERN ffi_type ffi_type_uint8;\n+FFI_EXTERN ffi_type ffi_type_sint8;\n+FFI_EXTERN ffi_type ffi_type_uint16;\n+FFI_EXTERN ffi_type ffi_type_sint16;\n+FFI_EXTERN ffi_type ffi_type_uint32;\n+FFI_EXTERN ffi_type ffi_type_sint32;\n+FFI_EXTERN ffi_type ffi_type_uint64;\n+FFI_EXTERN ffi_type ffi_type_sint64;\n+FFI_EXTERN ffi_type ffi_type_float;\n+FFI_EXTERN ffi_type ffi_type_double;\n+FFI_EXTERN ffi_type ffi_type_pointer;\n \n #if @HAVE_LONG_DOUBLE@\n-extern ffi_type ffi_type_longdouble;\n+FFI_EXTERN ffi_type ffi_type_longdouble;\n #else\n #define ffi_type_longdouble ffi_type_double\n #endif\n+\n+#ifdef FFI_TARGET_HAS_COMPLEX_TYPE\n+FFI_EXTERN ffi_type ffi_type_complex_float;\n+FFI_EXTERN ffi_type ffi_type_complex_double;\n+#if @HAVE_LONG_DOUBLE@\n+FFI_EXTERN ffi_type ffi_type_complex_longdouble;\n+#else\n+#define ffi_type_complex_longdouble ffi_type_complex_double\n+#endif\n+#endif\n #endif /* LIBFFI_HIDE_BASIC_TYPES */\n \n typedef enum {\n@@ -207,10 +231,10 @@ typedef struct {\n #endif\n } ffi_cif;\n \n-#if HAVE_LONG_DOUBLE_VARIANT\n+#if @HAVE_LONG_DOUBLE_VARIANT@\n /* Used to adjust size/alignment of ffi types.  */\n void ffi_prep_types (ffi_abi abi);\n-# endif\n+#endif\n \n /* Used internally, but overridden by some architectures */\n ffi_status ffi_prep_cif_core(ffi_cif *cif,\n@@ -288,7 +312,12 @@ size_t ffi_java_raw_size (ffi_cif *cif);\n __declspec(align(8))\n #endif\n typedef struct {\n+#if @FFI_EXEC_TRAMPOLINE_TABLE@\n+  void *trampoline_table;\n+  void *trampoline_table_entry;\n+#else\n   char tramp[FFI_TRAMPOLINE_SIZE];\n+#endif\n   ffi_cif   *cif;\n   void     (*fun)(ffi_cif*,void*,void**,void*);\n   void      *user_data;\n@@ -321,8 +350,12 @@ ffi_prep_closure_loc (ffi_closure*,\n # pragma pack 8\n #endif\n typedef struct {\n+#if @FFI_EXEC_TRAMPOLINE_TABLE@\n+  void *trampoline_table;\n+  void *trampoline_table_entry;\n+#else\n   char tramp[FFI_TRAMPOLINE_SIZE];\n-\n+#endif\n   ffi_cif   *cif;\n \n #if !FFI_NATIVE_RAW_API\n@@ -342,7 +375,12 @@ typedef struct {\n } ffi_raw_closure;\n \n typedef struct {\n+#if @FFI_EXEC_TRAMPOLINE_TABLE@\n+  void *trampoline_table;\n+  void *trampoline_table_entry;\n+#else\n   char tramp[FFI_TRAMPOLINE_SIZE];\n+#endif\n \n   ffi_cif   *cif;\n \n@@ -390,6 +428,22 @@ ffi_prep_java_raw_closure_loc (ffi_java_raw_closure*,\n \n #endif /* FFI_CLOSURES */\n \n+#if FFI_GO_CLOSURES\n+\n+typedef struct {\n+  void      *tramp;\n+  ffi_cif   *cif;\n+  void     (*fun)(ffi_cif*,void*,void**,void*);\n+} ffi_go_closure;\n+\n+ffi_status ffi_prep_go_closure (ffi_go_closure*, ffi_cif *,\n+\t\t\t\tvoid (*fun)(ffi_cif*,void*,void**,void*));\n+\n+void ffi_call_go (ffi_cif *cif, void (*fn)(void), void *rvalue,\n+\t\t  void **avalue, void *closure);\n+\n+#endif /* FFI_GO_CLOSURES */\n+\n /* ---- Public interface definition -------------------------------------- */\n \n ffi_status ffi_prep_cif(ffi_cif *cif,\n@@ -437,9 +491,10 @@ void ffi_call(ffi_cif *cif,\n #define FFI_TYPE_SINT64     12\n #define FFI_TYPE_STRUCT     13\n #define FFI_TYPE_POINTER    14\n+#define FFI_TYPE_COMPLEX    15\n \n /* This should always refer to the last type code (for sanity checks) */\n-#define FFI_TYPE_LAST       FFI_TYPE_POINTER\n+#define FFI_TYPE_LAST       FFI_TYPE_COMPLEX\n \n #ifdef __cplusplus\n }"}, {"sha": "244ce572be740e79b87d98229ef85d9c643cd3e5", "filename": "libffi/include/ffi_cfi.h", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Finclude%2Fffi_cfi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Finclude%2Fffi_cfi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2Fffi_cfi.h?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -0,0 +1,55 @@\n+/* -----------------------------------------------------------------------\n+   ffi_cfi.h - Copyright (c) 2014  Red Hat, Inc.\n+\n+   Conditionally assemble cfi directives. Only necessary for building libffi.\n+   ----------------------------------------------------------------------- */\n+\n+#ifndef FFI_CFI_H\n+#define FFI_CFI_H\n+\n+#ifdef HAVE_AS_CFI_PSEUDO_OP\n+\n+# define cfi_startproc\t\t\t.cfi_startproc\n+# define cfi_endproc\t\t\t.cfi_endproc\n+# define cfi_def_cfa(reg, off)\t\t.cfi_def_cfa reg, off\n+# define cfi_def_cfa_register(reg)\t.cfi_def_cfa_register reg\n+# define cfi_def_cfa_offset(off)\t.cfi_def_cfa_offset off\n+# define cfi_adjust_cfa_offset(off)\t.cfi_adjust_cfa_offset off\n+# define cfi_offset(reg, off)\t\t.cfi_offset reg, off\n+# define cfi_rel_offset(reg, off)\t.cfi_rel_offset reg, off\n+# define cfi_register(r1, r2)\t\t.cfi_register r1, r2\n+# define cfi_return_column(reg)\t\t.cfi_return_column reg\n+# define cfi_restore(reg)\t\t.cfi_restore reg\n+# define cfi_same_value(reg)\t\t.cfi_same_value reg\n+# define cfi_undefined(reg)\t\t.cfi_undefined reg\n+# define cfi_remember_state\t\t.cfi_remember_state\n+# define cfi_restore_state\t\t.cfi_restore_state\n+# define cfi_window_save\t\t.cfi_window_save\n+# define cfi_personality(enc, exp)\t.cfi_personality enc, exp\n+# define cfi_lsda(enc, exp)\t\t.cfi_lsda enc, exp\n+# define cfi_escape(...)\t\t.cfi_escape __VA_ARGS__\n+\n+#else\n+\n+# define cfi_startproc\n+# define cfi_endproc\n+# define cfi_def_cfa(reg, off)\n+# define cfi_def_cfa_register(reg)\n+# define cfi_def_cfa_offset(off)\n+# define cfi_adjust_cfa_offset(off)\n+# define cfi_offset(reg, off)\n+# define cfi_rel_offset(reg, off)\n+# define cfi_register(r1, r2)\n+# define cfi_return_column(reg)\n+# define cfi_restore(reg)\n+# define cfi_same_value(reg)\n+# define cfi_undefined(reg)\n+# define cfi_remember_state\n+# define cfi_restore_state\n+# define cfi_window_save\n+# define cfi_personality(enc, exp)\n+# define cfi_lsda(enc, exp)\n+# define cfi_escape(...)\n+\n+#endif /* HAVE_AS_CFI_PSEUDO_OP */\n+#endif /* FFI_CFI_H */"}, {"sha": "37f5a9e92494d555530aed7cc9381806d3b2e0f8", "filename": "libffi/include/ffi_common.h", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Finclude%2Fffi_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Finclude%2Fffi_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2Fffi_common.h?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -1,5 +1,5 @@\n /* -----------------------------------------------------------------------\n-   ffi_common.h - Copyright (C) 2011, 2012  Anthony Green\n+   ffi_common.h - Copyright (C) 2011, 2012, 2013  Anthony Green\n                   Copyright (C) 2007  Free Software Foundation, Inc\n                   Copyright (c) 1996  Red Hat, Inc.\n                   \n@@ -19,28 +19,32 @@ extern \"C\" {\n /* Do not move this. Some versions of AIX are very picky about where\n    this is positioned. */\n #ifdef __GNUC__\n-/* mingw64 defines this already in malloc.h. */\n-#ifndef alloca\n-# define alloca __builtin_alloca\n-#endif\n+# if HAVE_ALLOCA_H\n+#  include <alloca.h>\n+# else\n+  /* mingw64 defines this already in malloc.h. */\n+#  ifndef alloca\n+#    define alloca __builtin_alloca\n+#  endif\n+# endif\n # define MAYBE_UNUSED __attribute__((__unused__))\n #else\n # define MAYBE_UNUSED\n # if HAVE_ALLOCA_H\n #  include <alloca.h>\n # else\n #  ifdef _AIX\n- #pragma alloca\n+#   pragma alloca\n #  else\n #   ifndef alloca /* predefined by HP cc +Olibcalls */\n #    ifdef _MSC_VER\n #     define alloca _alloca\n #    else\n char *alloca ();\n-#    endif\n #   endif\n #  endif\n # endif\n+# endif\n #endif\n \n /* Check for the existence of memcpy. */\n@@ -87,7 +91,7 @@ typedef struct\n } extended_cif;\n \n /* Terse sized type definitions.  */\n-#if defined(_MSC_VER) || defined(__sgi)\n+#if defined(_MSC_VER) || defined(__sgi) || defined(__SUNPRO_C)\n typedef unsigned char UINT8;\n typedef signed char   SINT8;\n typedef unsigned short UINT16;"}, {"sha": "edf6fde5e2be6d624a78f40b8b29b26cdbf475f8", "filename": "libffi/libffi.pc.in", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Flibffi.pc.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Flibffi.pc.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Flibffi.pc.in?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -0,0 +1,11 @@\n+prefix=@prefix@\n+exec_prefix=@exec_prefix@\n+libdir=@libdir@\n+toolexeclibdir=@toolexeclibdir@\n+includedir=${libdir}/@PACKAGE_NAME@-@PACKAGE_VERSION@/include\n+\n+Name: @PACKAGE_NAME@\n+Description: Library supporting Foreign Function Interfaces\n+Version: @PACKAGE_VERSION@\n+Libs: -L${toolexeclibdir} -lffi\n+Cflags: -I${includedir}"}, {"sha": "1cf396ffa1e42bfdf0c55d9d20f4c29a68f03490", "filename": "libffi/libffi.xcodeproj/project.pbxproj", "status": "modified", "additions": 388, "deletions": 330, "changes": 718, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Flibffi.xcodeproj%2Fproject.pbxproj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Flibffi.xcodeproj%2Fproject.pbxproj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Flibffi.xcodeproj%2Fproject.pbxproj?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -7,473 +7,448 @@\n \tobjects = {\n \n /* Begin PBXBuildFile section */\n-\t\t6C43CBDC1534F76F00162364 /* ffi.c in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CBBD1534F76F00162364 /* ffi.c */; };\n-\t\t6C43CBDD1534F76F00162364 /* sysv.S in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CBBF1534F76F00162364 /* sysv.S */; };\n-\t\t6C43CBDE1534F76F00162364 /* trampoline.S in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CBC01534F76F00162364 /* trampoline.S */; };\n-\t\t6C43CBE61534F76F00162364 /* darwin.S in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CBC91534F76F00162364 /* darwin.S */; };\n-\t\t6C43CBE81534F76F00162364 /* ffi.c in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CBCB1534F76F00162364 /* ffi.c */; };\n-\t\t6C43CC1F1534F77800162364 /* darwin.S in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CC051534F77800162364 /* darwin.S */; };\n-\t\t6C43CC201534F77800162364 /* darwin64.S in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CC061534F77800162364 /* darwin64.S */; };\n-\t\t6C43CC211534F77800162364 /* ffi.c in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CC071534F77800162364 /* ffi.c */; };\n-\t\t6C43CC221534F77800162364 /* ffi64.c in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CC081534F77800162364 /* ffi64.c */; };\n-\t\t6C43CC2F1534F7BE00162364 /* closures.c in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CC281534F7BE00162364 /* closures.c */; };\n-\t\t6C43CC301534F7BE00162364 /* closures.c in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CC281534F7BE00162364 /* closures.c */; };\n-\t\t6C43CC351534F7BE00162364 /* java_raw_api.c in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CC2B1534F7BE00162364 /* java_raw_api.c */; };\n-\t\t6C43CC361534F7BE00162364 /* java_raw_api.c in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CC2B1534F7BE00162364 /* java_raw_api.c */; };\n-\t\t6C43CC371534F7BE00162364 /* prep_cif.c in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CC2C1534F7BE00162364 /* prep_cif.c */; };\n-\t\t6C43CC381534F7BE00162364 /* prep_cif.c in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CC2C1534F7BE00162364 /* prep_cif.c */; };\n-\t\t6C43CC391534F7BE00162364 /* raw_api.c in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CC2D1534F7BE00162364 /* raw_api.c */; };\n-\t\t6C43CC3A1534F7BE00162364 /* raw_api.c in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CC2D1534F7BE00162364 /* raw_api.c */; };\n-\t\t6C43CC3B1534F7BE00162364 /* types.c in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CC2E1534F7BE00162364 /* types.c */; };\n-\t\t6C43CC3C1534F7BE00162364 /* types.c in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CC2E1534F7BE00162364 /* types.c */; };\n-\t\t6C43CC971535032600162364 /* ffi.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CC8D1535032600162364 /* ffi.h */; settings = {ATTRIBUTES = (Public, ); }; };\n-\t\t6C43CC981535032600162364 /* ffi_common.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CC8E1535032600162364 /* ffi_common.h */; settings = {ATTRIBUTES = (Public, ); }; };\n-\t\t6C43CC991535032600162364 /* ffi_i386.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CC8F1535032600162364 /* ffi_i386.h */; settings = {ATTRIBUTES = (Public, ); }; };\n-\t\t6C43CC9A1535032600162364 /* ffi_x86_64.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CC901535032600162364 /* ffi_x86_64.h */; settings = {ATTRIBUTES = (Public, ); }; };\n-\t\t6C43CC9B1535032600162364 /* fficonfig.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CC911535032600162364 /* fficonfig.h */; };\n-\t\t6C43CC9C1535032600162364 /* fficonfig_i386.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CC921535032600162364 /* fficonfig_i386.h */; };\n-\t\t6C43CC9D1535032600162364 /* fficonfig_x86_64.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CC931535032600162364 /* fficonfig_x86_64.h */; };\n-\t\t6C43CC9E1535032600162364 /* ffitarget.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CC941535032600162364 /* ffitarget.h */; settings = {ATTRIBUTES = (Public, ); }; };\n-\t\t6C43CC9F1535032600162364 /* ffitarget_i386.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CC951535032600162364 /* ffitarget_i386.h */; settings = {ATTRIBUTES = (Public, ); }; };\n-\t\t6C43CCA01535032600162364 /* ffitarget_x86_64.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CC961535032600162364 /* ffitarget_x86_64.h */; settings = {ATTRIBUTES = (Public, ); }; };\n-\t\t6C43CCAD1535039600162364 /* ffi.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CCA21535039600162364 /* ffi.h */; settings = {ATTRIBUTES = (Public, ); }; };\n-\t\t6C43CCAE1535039600162364 /* ffi_armv7.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CCA31535039600162364 /* ffi_armv7.h */; settings = {ATTRIBUTES = (Public, ); }; };\n-\t\t6C43CCAF1535039600162364 /* ffi_common.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CCA41535039600162364 /* ffi_common.h */; settings = {ATTRIBUTES = (Public, ); }; };\n-\t\t6C43CCB01535039600162364 /* ffi_i386.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CCA51535039600162364 /* ffi_i386.h */; settings = {ATTRIBUTES = (Public, ); }; };\n-\t\t6C43CCB11535039600162364 /* fficonfig.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CCA61535039600162364 /* fficonfig.h */; };\n-\t\t6C43CCB21535039600162364 /* fficonfig_armv7.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CCA71535039600162364 /* fficonfig_armv7.h */; };\n-\t\t6C43CCB31535039600162364 /* fficonfig_i386.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CCA81535039600162364 /* fficonfig_i386.h */; };\n-\t\t6C43CCB41535039600162364 /* ffitarget.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CCA91535039600162364 /* ffitarget.h */; settings = {ATTRIBUTES = (Public, ); }; };\n-\t\t6C43CCB51535039600162364 /* ffitarget_arm.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CCAA1535039600162364 /* ffitarget_arm.h */; settings = {ATTRIBUTES = (Public, ); }; };\n-\t\t6C43CCB61535039600162364 /* ffitarget_armv7.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CCAB1535039600162364 /* ffitarget_armv7.h */; settings = {ATTRIBUTES = (Public, ); }; };\n-\t\t6C43CCB71535039600162364 /* ffitarget_i386.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CCAC1535039600162364 /* ffitarget_i386.h */; settings = {ATTRIBUTES = (Public, ); }; };\n+\t\tDBFA714A187F1D8600A76262 /* ffi.h in Headers */ = {isa = PBXBuildFile; fileRef = DBFA713E187F1D8600A76262 /* ffi.h */; };\n+\t\tDBFA714B187F1D8600A76262 /* ffi_common.h in Headers */ = {isa = PBXBuildFile; fileRef = DBFA713F187F1D8600A76262 /* ffi_common.h */; };\n+\t\tDBFA714C187F1D8600A76262 /* fficonfig.h in Headers */ = {isa = PBXBuildFile; fileRef = DBFA7140187F1D8600A76262 /* fficonfig.h */; };\n+\t\tDBFA714D187F1D8600A76262 /* ffitarget.h in Headers */ = {isa = PBXBuildFile; fileRef = DBFA7141187F1D8600A76262 /* ffitarget.h */; };\n+\t\tDBFA714E187F1D8600A76262 /* closures.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7143187F1D8600A76262 /* closures.c */; };\n+\t\tDBFA714F187F1D8600A76262 /* closures.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7143187F1D8600A76262 /* closures.c */; };\n+\t\tDBFA7156187F1D8600A76262 /* prep_cif.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7147187F1D8600A76262 /* prep_cif.c */; };\n+\t\tDBFA7157187F1D8600A76262 /* prep_cif.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7147187F1D8600A76262 /* prep_cif.c */; };\n+\t\tDBFA7158187F1D8600A76262 /* raw_api.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7148187F1D8600A76262 /* raw_api.c */; };\n+\t\tDBFA7159187F1D8600A76262 /* raw_api.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7148187F1D8600A76262 /* raw_api.c */; };\n+\t\tDBFA715A187F1D8600A76262 /* types.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7149187F1D8600A76262 /* types.c */; };\n+\t\tDBFA715B187F1D8600A76262 /* types.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7149187F1D8600A76262 /* types.c */; };\n+\t\tDBFA7177187F1D9B00A76262 /* ffi_arm64.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA716C187F1D9B00A76262 /* ffi_arm64.c */; };\n+\t\tDBFA7178187F1D9B00A76262 /* sysv_arm64.S in Sources */ = {isa = PBXBuildFile; fileRef = DBFA716D187F1D9B00A76262 /* sysv_arm64.S */; };\n+\t\tDBFA7179187F1D9B00A76262 /* ffi_armv7.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA716F187F1D9B00A76262 /* ffi_armv7.c */; };\n+\t\tDBFA717A187F1D9B00A76262 /* sysv_armv7.S in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7170187F1D9B00A76262 /* sysv_armv7.S */; };\n+\t\tDBFA717B187F1D9B00A76262 /* trampoline_armv7.S in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7171187F1D9B00A76262 /* trampoline_armv7.S */; };\n+\t\tDBFA717C187F1D9B00A76262 /* darwin64_x86_64.S in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7173187F1D9B00A76262 /* darwin64_x86_64.S */; };\n+\t\tDBFA717D187F1D9B00A76262 /* darwin_i386.S in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7174187F1D9B00A76262 /* darwin_i386.S */; };\n+\t\tDBFA717E187F1D9B00A76262 /* ffi64_x86_64.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7175187F1D9B00A76262 /* ffi64_x86_64.c */; };\n+\t\tDBFA717F187F1D9B00A76262 /* ffi_i386.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7176187F1D9B00A76262 /* ffi_i386.c */; };\n+\t\tDBFA718E187F1DA100A76262 /* ffi_i386.h in Headers */ = {isa = PBXBuildFile; fileRef = DBFA7182187F1DA100A76262 /* ffi_i386.h */; };\n+\t\tDBFA718F187F1DA100A76262 /* ffi_x86_64.h in Headers */ = {isa = PBXBuildFile; fileRef = DBFA7183187F1DA100A76262 /* ffi_x86_64.h */; };\n+\t\tDBFA7190187F1DA100A76262 /* fficonfig_i386.h in Headers */ = {isa = PBXBuildFile; fileRef = DBFA7184187F1DA100A76262 /* fficonfig_i386.h */; };\n+\t\tDBFA7191187F1DA100A76262 /* fficonfig_x86_64.h in Headers */ = {isa = PBXBuildFile; fileRef = DBFA7185187F1DA100A76262 /* fficonfig_x86_64.h */; };\n+\t\tDBFA7192187F1DA100A76262 /* ffitarget_i386.h in Headers */ = {isa = PBXBuildFile; fileRef = DBFA7186187F1DA100A76262 /* ffitarget_i386.h */; };\n+\t\tDBFA7193187F1DA100A76262 /* ffitarget_x86_64.h in Headers */ = {isa = PBXBuildFile; fileRef = DBFA7187187F1DA100A76262 /* ffitarget_x86_64.h */; };\n+\t\tDBFA7194187F1DA100A76262 /* darwin64_x86_64.S in Sources */ = {isa = PBXBuildFile; fileRef = DBFA718A187F1DA100A76262 /* darwin64_x86_64.S */; };\n+\t\tDBFA7195187F1DA100A76262 /* darwin_i386.S in Sources */ = {isa = PBXBuildFile; fileRef = DBFA718B187F1DA100A76262 /* darwin_i386.S */; };\n+\t\tDBFA7196187F1DA100A76262 /* ffi64_x86_64.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA718C187F1DA100A76262 /* ffi64_x86_64.c */; };\n+\t\tDBFA7197187F1DA100A76262 /* ffi_i386.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA718D187F1DA100A76262 /* ffi_i386.c */; };\n /* End PBXBuildFile section */\n \n+/* Begin PBXCopyFilesBuildPhase section */\n+\t\tDB13B1641849DF1E0010F42D /* CopyFiles */ = {\n+\t\t\tisa = PBXCopyFilesBuildPhase;\n+\t\t\tbuildActionMask = 8;\n+\t\t\tdstPath = \"include/$(PRODUCT_NAME)\";\n+\t\t\tdstSubfolderSpec = 16;\n+\t\t\tfiles = (\n+\t\t\t);\n+\t\t\trunOnlyForDeploymentPostprocessing = 1;\n+\t\t};\n+/* End PBXCopyFilesBuildPhase section */\n+\n /* Begin PBXFileReference section */\n-\t\t6C43CB3D1534E9D100162364 /* libffi.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = libffi.a; sourceTree = BUILT_PRODUCTS_DIR; };\n-\t\t6C43CBBD1534F76F00162364 /* ffi.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ffi.c; sourceTree = \"<group>\"; };\n-\t\t6C43CBBF1534F76F00162364 /* sysv.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = sysv.S; sourceTree = \"<group>\"; };\n-\t\t6C43CBC01534F76F00162364 /* trampoline.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = trampoline.S; sourceTree = \"<group>\"; };\n-\t\t6C43CBC91534F76F00162364 /* darwin.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = darwin.S; sourceTree = \"<group>\"; };\n-\t\t6C43CBCB1534F76F00162364 /* ffi.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ffi.c; sourceTree = \"<group>\"; };\n-\t\t6C43CC051534F77800162364 /* darwin.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = darwin.S; sourceTree = \"<group>\"; };\n-\t\t6C43CC061534F77800162364 /* darwin64.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = darwin64.S; sourceTree = \"<group>\"; };\n-\t\t6C43CC071534F77800162364 /* ffi.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ffi.c; sourceTree = \"<group>\"; };\n-\t\t6C43CC081534F77800162364 /* ffi64.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ffi64.c; sourceTree = \"<group>\"; };\n-\t\t6C43CC281534F7BE00162364 /* closures.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = closures.c; path = src/closures.c; sourceTree = SOURCE_ROOT; };\n-\t\t6C43CC2B1534F7BE00162364 /* java_raw_api.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = java_raw_api.c; path = src/java_raw_api.c; sourceTree = SOURCE_ROOT; };\n-\t\t6C43CC2C1534F7BE00162364 /* prep_cif.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = prep_cif.c; path = src/prep_cif.c; sourceTree = SOURCE_ROOT; };\n-\t\t6C43CC2D1534F7BE00162364 /* raw_api.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = raw_api.c; path = src/raw_api.c; sourceTree = SOURCE_ROOT; };\n-\t\t6C43CC2E1534F7BE00162364 /* types.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = types.c; path = src/types.c; sourceTree = SOURCE_ROOT; };\n-\t\t6C43CC8D1535032600162364 /* ffi.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi.h; sourceTree = \"<group>\"; };\n-\t\t6C43CC8E1535032600162364 /* ffi_common.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi_common.h; sourceTree = \"<group>\"; };\n-\t\t6C43CC8F1535032600162364 /* ffi_i386.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi_i386.h; sourceTree = \"<group>\"; };\n-\t\t6C43CC901535032600162364 /* ffi_x86_64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi_x86_64.h; sourceTree = \"<group>\"; };\n-\t\t6C43CC911535032600162364 /* fficonfig.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = fficonfig.h; sourceTree = \"<group>\"; };\n-\t\t6C43CC921535032600162364 /* fficonfig_i386.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = fficonfig_i386.h; sourceTree = \"<group>\"; };\n-\t\t6C43CC931535032600162364 /* fficonfig_x86_64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = fficonfig_x86_64.h; sourceTree = \"<group>\"; };\n-\t\t6C43CC941535032600162364 /* ffitarget.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget.h; sourceTree = \"<group>\"; };\n-\t\t6C43CC951535032600162364 /* ffitarget_i386.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget_i386.h; sourceTree = \"<group>\"; };\n-\t\t6C43CC961535032600162364 /* ffitarget_x86_64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget_x86_64.h; sourceTree = \"<group>\"; };\n-\t\t6C43CCA21535039600162364 /* ffi.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi.h; sourceTree = \"<group>\"; };\n-\t\t6C43CCA31535039600162364 /* ffi_armv7.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi_armv7.h; sourceTree = \"<group>\"; };\n-\t\t6C43CCA41535039600162364 /* ffi_common.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi_common.h; sourceTree = \"<group>\"; };\n-\t\t6C43CCA51535039600162364 /* ffi_i386.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi_i386.h; sourceTree = \"<group>\"; };\n-\t\t6C43CCA61535039600162364 /* fficonfig.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = fficonfig.h; sourceTree = \"<group>\"; };\n-\t\t6C43CCA71535039600162364 /* fficonfig_armv7.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = fficonfig_armv7.h; sourceTree = \"<group>\"; };\n-\t\t6C43CCA81535039600162364 /* fficonfig_i386.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = fficonfig_i386.h; sourceTree = \"<group>\"; };\n-\t\t6C43CCA91535039600162364 /* ffitarget.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget.h; sourceTree = \"<group>\"; };\n-\t\t6C43CCAA1535039600162364 /* ffitarget_arm.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget_arm.h; sourceTree = \"<group>\"; };\n-\t\t6C43CCAB1535039600162364 /* ffitarget_armv7.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget_armv7.h; sourceTree = \"<group>\"; };\n-\t\t6C43CCAC1535039600162364 /* ffitarget_i386.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget_i386.h; sourceTree = \"<group>\"; };\n-\t\tF6F980BA147386130008F121 /* libffi.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = libffi.a; sourceTree = BUILT_PRODUCTS_DIR; };\n+\t\tDB13B1661849DF1E0010F42D /* libffi.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = libffi.a; sourceTree = BUILT_PRODUCTS_DIR; };\n+\t\tDB13B1911849DF510010F42D /* ffi.dylib */ = {isa = PBXFileReference; explicitFileType = \"compiled.mach-o.dylib\"; includeInIndex = 0; path = ffi.dylib; sourceTree = BUILT_PRODUCTS_DIR; };\n+\t\tDBFA713E187F1D8600A76262 /* ffi.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi.h; sourceTree = \"<group>\"; };\n+\t\tDBFA713F187F1D8600A76262 /* ffi_common.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi_common.h; sourceTree = \"<group>\"; };\n+\t\tDBFA7140187F1D8600A76262 /* fficonfig.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = fficonfig.h; sourceTree = \"<group>\"; };\n+\t\tDBFA7141187F1D8600A76262 /* ffitarget.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget.h; sourceTree = \"<group>\"; };\n+\t\tDBFA7143187F1D8600A76262 /* closures.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = closures.c; sourceTree = \"<group>\"; };\n+\t\tDBFA7145187F1D8600A76262 /* dlmalloc.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = dlmalloc.c; sourceTree = \"<group>\"; };\n+\t\tDBFA7147187F1D8600A76262 /* prep_cif.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = prep_cif.c; sourceTree = \"<group>\"; };\n+\t\tDBFA7148187F1D8600A76262 /* raw_api.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = raw_api.c; sourceTree = \"<group>\"; };\n+\t\tDBFA7149187F1D8600A76262 /* types.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = types.c; sourceTree = \"<group>\"; };\n+\t\tDBFA715E187F1D9B00A76262 /* ffi_arm64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi_arm64.h; sourceTree = \"<group>\"; };\n+\t\tDBFA715F187F1D9B00A76262 /* ffi_armv7.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi_armv7.h; sourceTree = \"<group>\"; };\n+\t\tDBFA7160187F1D9B00A76262 /* ffi_i386.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi_i386.h; sourceTree = \"<group>\"; };\n+\t\tDBFA7161187F1D9B00A76262 /* ffi_x86_64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi_x86_64.h; sourceTree = \"<group>\"; };\n+\t\tDBFA7162187F1D9B00A76262 /* fficonfig_arm64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = fficonfig_arm64.h; sourceTree = \"<group>\"; };\n+\t\tDBFA7163187F1D9B00A76262 /* fficonfig_armv7.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = fficonfig_armv7.h; sourceTree = \"<group>\"; };\n+\t\tDBFA7164187F1D9B00A76262 /* fficonfig_i386.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = fficonfig_i386.h; sourceTree = \"<group>\"; };\n+\t\tDBFA7165187F1D9B00A76262 /* fficonfig_x86_64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = fficonfig_x86_64.h; sourceTree = \"<group>\"; };\n+\t\tDBFA7166187F1D9B00A76262 /* ffitarget_arm64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget_arm64.h; sourceTree = \"<group>\"; };\n+\t\tDBFA7167187F1D9B00A76262 /* ffitarget_armv7.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget_armv7.h; sourceTree = \"<group>\"; };\n+\t\tDBFA7168187F1D9B00A76262 /* ffitarget_i386.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget_i386.h; sourceTree = \"<group>\"; };\n+\t\tDBFA7169187F1D9B00A76262 /* ffitarget_x86_64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget_x86_64.h; sourceTree = \"<group>\"; };\n+\t\tDBFA716C187F1D9B00A76262 /* ffi_arm64.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ffi_arm64.c; sourceTree = \"<group>\"; };\n+\t\tDBFA716D187F1D9B00A76262 /* sysv_arm64.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = sysv_arm64.S; sourceTree = \"<group>\"; };\n+\t\tDBFA716F187F1D9B00A76262 /* ffi_armv7.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ffi_armv7.c; sourceTree = \"<group>\"; };\n+\t\tDBFA7170187F1D9B00A76262 /* sysv_armv7.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = sysv_armv7.S; sourceTree = \"<group>\"; };\n+\t\tDBFA7171187F1D9B00A76262 /* trampoline_armv7.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = trampoline_armv7.S; sourceTree = \"<group>\"; };\n+\t\tDBFA7173187F1D9B00A76262 /* darwin64_x86_64.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = darwin64_x86_64.S; sourceTree = \"<group>\"; };\n+\t\tDBFA7174187F1D9B00A76262 /* darwin_i386.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = darwin_i386.S; sourceTree = \"<group>\"; };\n+\t\tDBFA7175187F1D9B00A76262 /* ffi64_x86_64.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ffi64_x86_64.c; sourceTree = \"<group>\"; };\n+\t\tDBFA7176187F1D9B00A76262 /* ffi_i386.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ffi_i386.c; sourceTree = \"<group>\"; };\n+\t\tDBFA7182187F1DA100A76262 /* ffi_i386.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi_i386.h; sourceTree = \"<group>\"; };\n+\t\tDBFA7183187F1DA100A76262 /* ffi_x86_64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi_x86_64.h; sourceTree = \"<group>\"; };\n+\t\tDBFA7184187F1DA100A76262 /* fficonfig_i386.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = fficonfig_i386.h; sourceTree = \"<group>\"; };\n+\t\tDBFA7185187F1DA100A76262 /* fficonfig_x86_64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = fficonfig_x86_64.h; sourceTree = \"<group>\"; };\n+\t\tDBFA7186187F1DA100A76262 /* ffitarget_i386.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget_i386.h; sourceTree = \"<group>\"; };\n+\t\tDBFA7187187F1DA100A76262 /* ffitarget_x86_64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget_x86_64.h; sourceTree = \"<group>\"; };\n+\t\tDBFA718A187F1DA100A76262 /* darwin64_x86_64.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = darwin64_x86_64.S; sourceTree = \"<group>\"; };\n+\t\tDBFA718B187F1DA100A76262 /* darwin_i386.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = darwin_i386.S; sourceTree = \"<group>\"; };\n+\t\tDBFA718C187F1DA100A76262 /* ffi64_x86_64.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ffi64_x86_64.c; sourceTree = \"<group>\"; };\n+\t\tDBFA718D187F1DA100A76262 /* ffi_i386.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ffi_i386.c; sourceTree = \"<group>\"; };\n /* End PBXFileReference section */\n \n-/* Begin PBXFrameworksBuildPhase section */\n-\t\t6C43CB3A1534E9D100162364 /* Frameworks */ = {\n-\t\t\tisa = PBXFrameworksBuildPhase;\n-\t\t\tbuildActionMask = 2147483647;\n-\t\t\tfiles = (\n+/* Begin PBXGroup section */\n+\t\tDB13B15B1849DEB70010F42D = {\n+\t\t\tisa = PBXGroup;\n+\t\t\tchildren = (\n+\t\t\t\tDBFA713C187F1D8600A76262 /* darwin_common */,\n+\t\t\t\tDBFA715C187F1D9B00A76262 /* darwin_ios */,\n+\t\t\t\tDBFA7180187F1DA100A76262 /* darwin_osx */,\n+\t\t\t\tDB13B1671849DF1E0010F42D /* Products */,\n \t\t\t);\n-\t\t\trunOnlyForDeploymentPostprocessing = 0;\n+\t\t\tsourceTree = \"<group>\";\n \t\t};\n-\t\tF6F980B7147386130008F121 /* Frameworks */ = {\n-\t\t\tisa = PBXFrameworksBuildPhase;\n-\t\t\tbuildActionMask = 2147483647;\n-\t\t\tfiles = (\n+\t\tDB13B1671849DF1E0010F42D /* Products */ = {\n+\t\t\tisa = PBXGroup;\n+\t\t\tchildren = (\n+\t\t\t\tDB13B1661849DF1E0010F42D /* libffi.a */,\n+\t\t\t\tDB13B1911849DF510010F42D /* ffi.dylib */,\n \t\t\t);\n-\t\t\trunOnlyForDeploymentPostprocessing = 0;\n+\t\t\tname = Products;\n+\t\t\tsourceTree = \"<group>\";\n \t\t};\n-/* End PBXFrameworksBuildPhase section */\n-\n-/* Begin PBXGroup section */\n-\t\t6C43CBAF1534F76F00162364 /* iOS */ = {\n+\t\tDBFA713C187F1D8600A76262 /* darwin_common */ = {\n \t\t\tisa = PBXGroup;\n \t\t\tchildren = (\n-\t\t\t\t6C43CCA11535039600162364 /* include */,\n-\t\t\t\t6C43CBBB1534F76F00162364 /* src */,\n+\t\t\t\tDBFA713D187F1D8600A76262 /* include */,\n+\t\t\t\tDBFA7142187F1D8600A76262 /* src */,\n \t\t\t);\n-\t\t\tname = iOS;\n-\t\t\tpath = ios;\n+\t\t\tpath = \"darwin_common\";\n \t\t\tsourceTree = \"<group>\";\n \t\t};\n-\t\t6C43CBBB1534F76F00162364 /* src */ = {\n+\t\tDBFA713D187F1D8600A76262 /* include */ = {\n \t\t\tisa = PBXGroup;\n \t\t\tchildren = (\n-\t\t\t\t6C43CBC81534F76F00162364 /* x86 */,\n-\t\t\t\t6C43CBBC1534F76F00162364 /* arm */,\n+\t\t\t\tDBFA713E187F1D8600A76262 /* ffi.h */,\n+\t\t\t\tDBFA713F187F1D8600A76262 /* ffi_common.h */,\n+\t\t\t\tDBFA7140187F1D8600A76262 /* fficonfig.h */,\n+\t\t\t\tDBFA7141187F1D8600A76262 /* ffitarget.h */,\n \t\t\t);\n-\t\t\tpath = src;\n+\t\t\tpath = include;\n \t\t\tsourceTree = \"<group>\";\n \t\t};\n-\t\t6C43CBBC1534F76F00162364 /* arm */ = {\n+\t\tDBFA7142187F1D8600A76262 /* src */ = {\n \t\t\tisa = PBXGroup;\n \t\t\tchildren = (\n-\t\t\t\t6C43CBBD1534F76F00162364 /* ffi.c */,\n-\t\t\t\t6C43CBBF1534F76F00162364 /* sysv.S */,\n-\t\t\t\t6C43CBC01534F76F00162364 /* trampoline.S */,\n+\t\t\t\tDBFA7143187F1D8600A76262 /* closures.c */,\n+\t\t\t\tDBFA7145187F1D8600A76262 /* dlmalloc.c */,\n+\t\t\t\tDBFA7147187F1D8600A76262 /* prep_cif.c */,\n+\t\t\t\tDBFA7148187F1D8600A76262 /* raw_api.c */,\n+\t\t\t\tDBFA7149187F1D8600A76262 /* types.c */,\n \t\t\t);\n-\t\t\tpath = arm;\n+\t\t\tpath = src;\n \t\t\tsourceTree = \"<group>\";\n \t\t};\n-\t\t6C43CBC81534F76F00162364 /* x86 */ = {\n+\t\tDBFA715C187F1D9B00A76262 /* darwin_ios */ = {\n \t\t\tisa = PBXGroup;\n \t\t\tchildren = (\n-\t\t\t\t6C43CBC91534F76F00162364 /* darwin.S */,\n-\t\t\t\t6C43CBCB1534F76F00162364 /* ffi.c */,\n+\t\t\t\tDBFA715D187F1D9B00A76262 /* include */,\n+\t\t\t\tDBFA716A187F1D9B00A76262 /* src */,\n \t\t\t);\n-\t\t\tpath = x86;\n+\t\t\tpath = \"darwin_ios\";\n \t\t\tsourceTree = \"<group>\";\n \t\t};\n-\t\t6C43CBF01534F77800162364 /* OS X */ = {\n+\t\tDBFA715D187F1D9B00A76262 /* include */ = {\n \t\t\tisa = PBXGroup;\n \t\t\tchildren = (\n-\t\t\t\t6C43CC8C1535032600162364 /* include */,\n-\t\t\t\t6C43CBFC1534F77800162364 /* src */,\n+\t\t\t\tDBFA715E187F1D9B00A76262 /* ffi_arm64.h */,\n+\t\t\t\tDBFA715F187F1D9B00A76262 /* ffi_armv7.h */,\n+\t\t\t\tDBFA7160187F1D9B00A76262 /* ffi_i386.h */,\n+\t\t\t\tDBFA7161187F1D9B00A76262 /* ffi_x86_64.h */,\n+\t\t\t\tDBFA7162187F1D9B00A76262 /* fficonfig_arm64.h */,\n+\t\t\t\tDBFA7163187F1D9B00A76262 /* fficonfig_armv7.h */,\n+\t\t\t\tDBFA7164187F1D9B00A76262 /* fficonfig_i386.h */,\n+\t\t\t\tDBFA7165187F1D9B00A76262 /* fficonfig_x86_64.h */,\n+\t\t\t\tDBFA7166187F1D9B00A76262 /* ffitarget_arm64.h */,\n+\t\t\t\tDBFA7167187F1D9B00A76262 /* ffitarget_armv7.h */,\n+\t\t\t\tDBFA7168187F1D9B00A76262 /* ffitarget_i386.h */,\n+\t\t\t\tDBFA7169187F1D9B00A76262 /* ffitarget_x86_64.h */,\n \t\t\t);\n-\t\t\tname = \"OS X\";\n-\t\t\tpath = osx;\n+\t\t\tpath = include;\n \t\t\tsourceTree = \"<group>\";\n \t\t};\n-\t\t6C43CBFC1534F77800162364 /* src */ = {\n+\t\tDBFA716A187F1D9B00A76262 /* src */ = {\n \t\t\tisa = PBXGroup;\n \t\t\tchildren = (\n-\t\t\t\t6C43CC041534F77800162364 /* x86 */,\n+\t\t\t\tDBFA716B187F1D9B00A76262 /* aarch64 */,\n+\t\t\t\tDBFA716E187F1D9B00A76262 /* arm */,\n+\t\t\t\tDBFA7172187F1D9B00A76262 /* x86 */,\n \t\t\t);\n \t\t\tpath = src;\n \t\t\tsourceTree = \"<group>\";\n \t\t};\n-\t\t6C43CC041534F77800162364 /* x86 */ = {\n+\t\tDBFA716B187F1D9B00A76262 /* aarch64 */ = {\n \t\t\tisa = PBXGroup;\n \t\t\tchildren = (\n-\t\t\t\t6C43CC051534F77800162364 /* darwin.S */,\n-\t\t\t\t6C43CC061534F77800162364 /* darwin64.S */,\n-\t\t\t\t6C43CC071534F77800162364 /* ffi.c */,\n-\t\t\t\t6C43CC081534F77800162364 /* ffi64.c */,\n+\t\t\t\tDBFA716C187F1D9B00A76262 /* ffi_arm64.c */,\n+\t\t\t\tDBFA716D187F1D9B00A76262 /* sysv_arm64.S */,\n \t\t\t);\n-\t\t\tpath = x86;\n+\t\t\tpath = aarch64;\n \t\t\tsourceTree = \"<group>\";\n \t\t};\n-\t\t6C43CC3D1534F7C400162364 /* src */ = {\n+\t\tDBFA716E187F1D9B00A76262 /* arm */ = {\n \t\t\tisa = PBXGroup;\n \t\t\tchildren = (\n-\t\t\t\t6C43CC281534F7BE00162364 /* closures.c */,\n-\t\t\t\t6C43CC2B1534F7BE00162364 /* java_raw_api.c */,\n-\t\t\t\t6C43CC2C1534F7BE00162364 /* prep_cif.c */,\n-\t\t\t\t6C43CC2D1534F7BE00162364 /* raw_api.c */,\n-\t\t\t\t6C43CC2E1534F7BE00162364 /* types.c */,\n-\t\t\t);\n-\t\t\tname = src;\n-\t\t\tpath = ios;\n+\t\t\t\tDBFA716F187F1D9B00A76262 /* ffi_armv7.c */,\n+\t\t\t\tDBFA7170187F1D9B00A76262 /* sysv_armv7.S */,\n+\t\t\t\tDBFA7171187F1D9B00A76262 /* trampoline_armv7.S */,\n+\t\t\t);\n+\t\t\tpath = arm;\n \t\t\tsourceTree = \"<group>\";\n \t\t};\n-\t\t6C43CC8C1535032600162364 /* include */ = {\n+\t\tDBFA7172187F1D9B00A76262 /* x86 */ = {\n \t\t\tisa = PBXGroup;\n \t\t\tchildren = (\n-\t\t\t\t6C43CC8D1535032600162364 /* ffi.h */,\n-\t\t\t\t6C43CC8E1535032600162364 /* ffi_common.h */,\n-\t\t\t\t6C43CC8F1535032600162364 /* ffi_i386.h */,\n-\t\t\t\t6C43CC901535032600162364 /* ffi_x86_64.h */,\n-\t\t\t\t6C43CC911535032600162364 /* fficonfig.h */,\n-\t\t\t\t6C43CC921535032600162364 /* fficonfig_i386.h */,\n-\t\t\t\t6C43CC931535032600162364 /* fficonfig_x86_64.h */,\n-\t\t\t\t6C43CC941535032600162364 /* ffitarget.h */,\n-\t\t\t\t6C43CC951535032600162364 /* ffitarget_i386.h */,\n-\t\t\t\t6C43CC961535032600162364 /* ffitarget_x86_64.h */,\n+\t\t\t\tDBFA7173187F1D9B00A76262 /* darwin64_x86_64.S */,\n+\t\t\t\tDBFA7174187F1D9B00A76262 /* darwin_i386.S */,\n+\t\t\t\tDBFA7175187F1D9B00A76262 /* ffi64_x86_64.c */,\n+\t\t\t\tDBFA7176187F1D9B00A76262 /* ffi_i386.c */,\n \t\t\t);\n-\t\t\tpath = include;\n+\t\t\tpath = x86;\n+\t\t\tsourceTree = \"<group>\";\n+\t\t};\n+\t\tDBFA7180187F1DA100A76262 /* darwin_osx */ = {\n+\t\t\tisa = PBXGroup;\n+\t\t\tchildren = (\n+\t\t\t\tDBFA7181187F1DA100A76262 /* include */,\n+\t\t\t\tDBFA7188187F1DA100A76262 /* src */,\n+\t\t\t);\n+\t\t\tpath = \"darwin_osx\";\n \t\t\tsourceTree = \"<group>\";\n \t\t};\n-\t\t6C43CCA11535039600162364 /* include */ = {\n+\t\tDBFA7181187F1DA100A76262 /* include */ = {\n \t\t\tisa = PBXGroup;\n \t\t\tchildren = (\n-\t\t\t\t6C43CCA21535039600162364 /* ffi.h */,\n-\t\t\t\t6C43CCA31535039600162364 /* ffi_armv7.h */,\n-\t\t\t\t6C43CCA41535039600162364 /* ffi_common.h */,\n-\t\t\t\t6C43CCA51535039600162364 /* ffi_i386.h */,\n-\t\t\t\t6C43CCA61535039600162364 /* fficonfig.h */,\n-\t\t\t\t6C43CCA71535039600162364 /* fficonfig_armv7.h */,\n-\t\t\t\t6C43CCA81535039600162364 /* fficonfig_i386.h */,\n-\t\t\t\t6C43CCA91535039600162364 /* ffitarget.h */,\n-\t\t\t\t6C43CCAA1535039600162364 /* ffitarget_arm.h */,\n-\t\t\t\t6C43CCAB1535039600162364 /* ffitarget_armv7.h */,\n-\t\t\t\t6C43CCAC1535039600162364 /* ffitarget_i386.h */,\n+\t\t\t\tDBFA7182187F1DA100A76262 /* ffi_i386.h */,\n+\t\t\t\tDBFA7183187F1DA100A76262 /* ffi_x86_64.h */,\n+\t\t\t\tDBFA7184187F1DA100A76262 /* fficonfig_i386.h */,\n+\t\t\t\tDBFA7185187F1DA100A76262 /* fficonfig_x86_64.h */,\n+\t\t\t\tDBFA7186187F1DA100A76262 /* ffitarget_i386.h */,\n+\t\t\t\tDBFA7187187F1DA100A76262 /* ffitarget_x86_64.h */,\n \t\t\t);\n \t\t\tpath = include;\n \t\t\tsourceTree = \"<group>\";\n \t\t};\n-\t\tF6B0839514721EE50031D8A1 = {\n+\t\tDBFA7188187F1DA100A76262 /* src */ = {\n \t\t\tisa = PBXGroup;\n \t\t\tchildren = (\n-\t\t\t\t6C43CC3D1534F7C400162364 /* src */,\n-\t\t\t\t6C43CBAF1534F76F00162364 /* iOS */,\n-\t\t\t\t6C43CBF01534F77800162364 /* OS X */,\n-\t\t\t\tF6F980C6147386260008F121 /* Products */,\n+\t\t\t\tDBFA7189187F1DA100A76262 /* x86 */,\n \t\t\t);\n+\t\t\tpath = src;\n \t\t\tsourceTree = \"<group>\";\n \t\t};\n-\t\tF6F980C6147386260008F121 /* Products */ = {\n+\t\tDBFA7189187F1DA100A76262 /* x86 */ = {\n \t\t\tisa = PBXGroup;\n \t\t\tchildren = (\n-\t\t\t\tF6F980BA147386130008F121 /* libffi.a */,\n-\t\t\t\t6C43CB3D1534E9D100162364 /* libffi.a */,\n+\t\t\t\tDBFA718A187F1DA100A76262 /* darwin64_x86_64.S */,\n+\t\t\t\tDBFA718B187F1DA100A76262 /* darwin_i386.S */,\n+\t\t\t\tDBFA718C187F1DA100A76262 /* ffi64_x86_64.c */,\n+\t\t\t\tDBFA718D187F1DA100A76262 /* ffi_i386.c */,\n \t\t\t);\n-\t\t\tname = Products;\n-\t\t\tpath = ../..;\n-\t\t\tsourceTree = BUILT_PRODUCTS_DIR;\n+\t\t\tpath = x86;\n+\t\t\tsourceTree = \"<group>\";\n \t\t};\n /* End PBXGroup section */\n \n /* Begin PBXHeadersBuildPhase section */\n-\t\t6C43CB3B1534E9D100162364 /* Headers */ = {\n+\t\tDB13B18F1849DF510010F42D /* Headers */ = {\n \t\t\tisa = PBXHeadersBuildPhase;\n \t\t\tbuildActionMask = 2147483647;\n \t\t\tfiles = (\n-\t\t\t\t6C43CC971535032600162364 /* ffi.h in Headers */,\n-\t\t\t\t6C43CC981535032600162364 /* ffi_common.h in Headers */,\n-\t\t\t\t6C43CC991535032600162364 /* ffi_i386.h in Headers */,\n-\t\t\t\t6C43CC9A1535032600162364 /* ffi_x86_64.h in Headers */,\n-\t\t\t\t6C43CC9E1535032600162364 /* ffitarget.h in Headers */,\n-\t\t\t\t6C43CC9F1535032600162364 /* ffitarget_i386.h in Headers */,\n-\t\t\t\t6C43CCA01535032600162364 /* ffitarget_x86_64.h in Headers */,\n-\t\t\t\t6C43CC9B1535032600162364 /* fficonfig.h in Headers */,\n-\t\t\t\t6C43CC9C1535032600162364 /* fficonfig_i386.h in Headers */,\n-\t\t\t\t6C43CC9D1535032600162364 /* fficonfig_x86_64.h in Headers */,\n-\t\t\t);\n-\t\t\trunOnlyForDeploymentPostprocessing = 0;\n-\t\t};\n-\t\tF6F980B8147386130008F121 /* Headers */ = {\n-\t\t\tisa = PBXHeadersBuildPhase;\n-\t\t\tbuildActionMask = 2147483647;\n-\t\t\tfiles = (\n-\t\t\t\t6C43CCAD1535039600162364 /* ffi.h in Headers */,\n-\t\t\t\t6C43CCAE1535039600162364 /* ffi_armv7.h in Headers */,\n-\t\t\t\t6C43CCAF1535039600162364 /* ffi_common.h in Headers */,\n-\t\t\t\t6C43CCB01535039600162364 /* ffi_i386.h in Headers */,\n-\t\t\t\t6C43CCB41535039600162364 /* ffitarget.h in Headers */,\n-\t\t\t\t6C43CCB51535039600162364 /* ffitarget_arm.h in Headers */,\n-\t\t\t\t6C43CCB61535039600162364 /* ffitarget_armv7.h in Headers */,\n-\t\t\t\t6C43CCB71535039600162364 /* ffitarget_i386.h in Headers */,\n-\t\t\t\t6C43CCB11535039600162364 /* fficonfig.h in Headers */,\n-\t\t\t\t6C43CCB21535039600162364 /* fficonfig_armv7.h in Headers */,\n-\t\t\t\t6C43CCB31535039600162364 /* fficonfig_i386.h in Headers */,\n+\t\t\t\tDBFA714C187F1D8600A76262 /* fficonfig.h in Headers */,\n+\t\t\t\tDBFA714D187F1D8600A76262 /* ffitarget.h in Headers */,\n+\t\t\t\tDBFA714A187F1D8600A76262 /* ffi.h in Headers */,\n+\t\t\t\tDBFA718F187F1DA100A76262 /* ffi_x86_64.h in Headers */,\n+\t\t\t\tDBFA7191187F1DA100A76262 /* fficonfig_x86_64.h in Headers */,\n+\t\t\t\tDBFA718E187F1DA100A76262 /* ffi_i386.h in Headers */,\n+\t\t\t\tDBFA7190187F1DA100A76262 /* fficonfig_i386.h in Headers */,\n+\t\t\t\tDBFA714B187F1D8600A76262 /* ffi_common.h in Headers */,\n+\t\t\t\tDBFA7193187F1DA100A76262 /* ffitarget_x86_64.h in Headers */,\n+\t\t\t\tDBFA7192187F1DA100A76262 /* ffitarget_i386.h in Headers */,\n \t\t\t);\n \t\t\trunOnlyForDeploymentPostprocessing = 0;\n \t\t};\n /* End PBXHeadersBuildPhase section */\n \n /* Begin PBXNativeTarget section */\n-\t\t6C43CB3C1534E9D100162364 /* libffi OS X */ = {\n+\t\tDB13B1651849DF1E0010F42D /* libffi-iOS */ = {\n \t\t\tisa = PBXNativeTarget;\n-\t\t\tbuildConfigurationList = 6C43CB4A1534E9D100162364 /* Build configuration list for PBXNativeTarget \"libffi OS X\" */;\n+\t\t\tbuildConfigurationList = DB13B18B1849DF1E0010F42D /* Build configuration list for PBXNativeTarget \"libffi-iOS\" */;\n \t\t\tbuildPhases = (\n-\t\t\t\t6C43CC401534FF3B00162364 /* Generate Source and Headers */,\n-\t\t\t\t6C43CB391534E9D100162364 /* Sources */,\n-\t\t\t\t6C43CB3A1534E9D100162364 /* Frameworks */,\n-\t\t\t\t6C43CB3B1534E9D100162364 /* Headers */,\n+\t\t\t\tDB13B3051849E01C0010F42D /* ShellScript */,\n+\t\t\t\tDB13B1621849DF1E0010F42D /* Sources */,\n+\t\t\t\tDB13B1641849DF1E0010F42D /* CopyFiles */,\n \t\t\t);\n \t\t\tbuildRules = (\n \t\t\t);\n \t\t\tdependencies = (\n \t\t\t);\n-\t\t\tname = \"libffi OS X\";\n-\t\t\tproductName = \"ffi OS X\";\n-\t\t\tproductReference = 6C43CB3D1534E9D100162364 /* libffi.a */;\n+\t\t\tname = \"libffi-iOS\";\n+\t\t\tproductName = ffi;\n+\t\t\tproductReference = DB13B1661849DF1E0010F42D /* libffi.a */;\n \t\t\tproductType = \"com.apple.product-type.library.static\";\n \t\t};\n-\t\tF6F980B9147386130008F121 /* libffi iOS */ = {\n+\t\tDB13B1901849DF510010F42D /* libffi-Mac */ = {\n \t\t\tisa = PBXNativeTarget;\n-\t\t\tbuildConfigurationList = F6F980C4147386130008F121 /* Build configuration list for PBXNativeTarget \"libffi iOS\" */;\n+\t\t\tbuildConfigurationList = DB13B1B01849DF520010F42D /* Build configuration list for PBXNativeTarget \"libffi-Mac\" */;\n \t\t\tbuildPhases = (\n-\t\t\t\t6C43CC3E1534F8E200162364 /* Generate Trampoline */,\n-\t\t\t\t6C43CC3F1534FF1B00162364 /* Generate Source and Headers */,\n-\t\t\t\tF6F980B6147386130008F121 /* Sources */,\n-\t\t\t\tF6F980B7147386130008F121 /* Frameworks */,\n-\t\t\t\tF6F980B8147386130008F121 /* Headers */,\n+\t\t\t\tDB13B3061849E0490010F42D /* ShellScript */,\n+\t\t\t\tDB13B18D1849DF510010F42D /* Sources */,\n+\t\t\t\tDB13B18F1849DF510010F42D /* Headers */,\n \t\t\t);\n \t\t\tbuildRules = (\n \t\t\t);\n \t\t\tdependencies = (\n \t\t\t);\n-\t\t\tname = \"libffi iOS\";\n+\t\t\tname = \"libffi-Mac\";\n \t\t\tproductName = ffi;\n-\t\t\tproductReference = F6F980BA147386130008F121 /* libffi.a */;\n-\t\t\tproductType = \"com.apple.product-type.library.static\";\n+\t\t\tproductReference = DB13B1911849DF510010F42D /* ffi.dylib */;\n+\t\t\tproductType = \"com.apple.product-type.library.dynamic\";\n \t\t};\n /* End PBXNativeTarget section */\n \n /* Begin PBXProject section */\n-\t\tF6B0839714721EE50031D8A1 /* Project object */ = {\n+\t\tDB13B15C1849DEB70010F42D /* Project object */ = {\n \t\t\tisa = PBXProject;\n \t\t\tattributes = {\n-\t\t\t\tLastUpgradeCheck = 0430;\n+\t\t\t\tLastUpgradeCheck = 0510;\n \t\t\t};\n-\t\t\tbuildConfigurationList = F6B0839A14721EE50031D8A1 /* Build configuration list for PBXProject \"libffi\" */;\n+\t\t\tbuildConfigurationList = DB13B15F1849DEB70010F42D /* Build configuration list for PBXProject \"libffi\" */;\n \t\t\tcompatibilityVersion = \"Xcode 3.2\";\n \t\t\tdevelopmentRegion = English;\n \t\t\thasScannedForEncodings = 0;\n \t\t\tknownRegions = (\n \t\t\t\ten,\n \t\t\t);\n-\t\t\tmainGroup = F6B0839514721EE50031D8A1;\n-\t\t\tproductRefGroup = F6B0839514721EE50031D8A1;\n+\t\t\tmainGroup = DB13B15B1849DEB70010F42D;\n+\t\t\tproductRefGroup = DB13B1671849DF1E0010F42D /* Products */;\n \t\t\tprojectDirPath = \"\";\n \t\t\tprojectRoot = \"\";\n \t\t\ttargets = (\n-\t\t\t\tF6F980B9147386130008F121 /* libffi iOS */,\n-\t\t\t\t6C43CB3C1534E9D100162364 /* libffi OS X */,\n+\t\t\t\tDB13B1651849DF1E0010F42D /* libffi-iOS */,\n+\t\t\t\tDB13B1901849DF510010F42D /* libffi-Mac */,\n \t\t\t);\n \t\t};\n /* End PBXProject section */\n \n /* Begin PBXShellScriptBuildPhase section */\n-\t\t6C43CC3E1534F8E200162364 /* Generate Trampoline */ = {\n-\t\t\tisa = PBXShellScriptBuildPhase;\n-\t\t\tbuildActionMask = 2147483647;\n-\t\t\tfiles = (\n-\t\t\t);\n-\t\t\tinputPaths = (\n-\t\t\t);\n-\t\t\tname = \"Generate Trampoline\";\n-\t\t\toutputPaths = (\n-\t\t\t);\n-\t\t\trunOnlyForDeploymentPostprocessing = 0;\n-\t\t\tshellPath = /usr/bin/python;\n-\t\t\tshellScript = \"import subprocess\\nimport re\\nimport os\\nimport errno\\nimport sys\\n\\ndef main():\\n    with open('src/arm/trampoline.S', 'w') as tramp_out:\\n        p = subprocess.Popen(['bash', 'src/arm/gentramp.sh'], stdout=tramp_out)\\n        p.wait()\\n\\nif __name__ == '__main__':\\n    main()\";\n-\t\t};\n-\t\t6C43CC3F1534FF1B00162364 /* Generate Source and Headers */ = {\n+\t\tDB13B3051849E01C0010F42D /* ShellScript */ = {\n \t\t\tisa = PBXShellScriptBuildPhase;\n \t\t\tbuildActionMask = 2147483647;\n \t\t\tfiles = (\n \t\t\t);\n \t\t\tinputPaths = (\n \t\t\t);\n-\t\t\tname = \"Generate Source and Headers\";\n \t\t\toutputPaths = (\n \t\t\t);\n \t\t\trunOnlyForDeploymentPostprocessing = 0;\n \t\t\tshellPath = /bin/sh;\n-\t\t\tshellScript = \"/usr/bin/python generate-ios-source-and-headers.py\";\n+\t\t\tshellScript = \"/usr/bin/python generate-darwin-source-and-headers.py --only-ios\";\n \t\t};\n-\t\t6C43CC401534FF3B00162364 /* Generate Source and Headers */ = {\n+\t\tDB13B3061849E0490010F42D /* ShellScript */ = {\n \t\t\tisa = PBXShellScriptBuildPhase;\n \t\t\tbuildActionMask = 2147483647;\n \t\t\tfiles = (\n \t\t\t);\n \t\t\tinputPaths = (\n \t\t\t);\n-\t\t\tname = \"Generate Source and Headers\";\n \t\t\toutputPaths = (\n \t\t\t);\n \t\t\trunOnlyForDeploymentPostprocessing = 0;\n \t\t\tshellPath = /bin/sh;\n-\t\t\tshellScript = \"/usr/bin/python generate-osx-source-and-headers.py\";\n+\t\t\tshellScript = \"/usr/bin/python generate-darwin-source-and-headers.py --only-osx\";\n \t\t};\n /* End PBXShellScriptBuildPhase section */\n \n /* Begin PBXSourcesBuildPhase section */\n-\t\t6C43CB391534E9D100162364 /* Sources */ = {\n+\t\tDB13B1621849DF1E0010F42D /* Sources */ = {\n \t\t\tisa = PBXSourcesBuildPhase;\n \t\t\tbuildActionMask = 2147483647;\n \t\t\tfiles = (\n-\t\t\t\t6C43CC1F1534F77800162364 /* darwin.S in Sources */,\n-\t\t\t\t6C43CC201534F77800162364 /* darwin64.S in Sources */,\n-\t\t\t\t6C43CC211534F77800162364 /* ffi.c in Sources */,\n-\t\t\t\t6C43CC221534F77800162364 /* ffi64.c in Sources */,\n-\t\t\t\t6C43CC301534F7BE00162364 /* closures.c in Sources */,\n-\t\t\t\t6C43CC361534F7BE00162364 /* java_raw_api.c in Sources */,\n-\t\t\t\t6C43CC381534F7BE00162364 /* prep_cif.c in Sources */,\n-\t\t\t\t6C43CC3A1534F7BE00162364 /* raw_api.c in Sources */,\n-\t\t\t\t6C43CC3C1534F7BE00162364 /* types.c in Sources */,\n+\t\t\t\tDBFA717E187F1D9B00A76262 /* ffi64_x86_64.c in Sources */,\n+\t\t\t\tDBFA7179187F1D9B00A76262 /* ffi_armv7.c in Sources */,\n+\t\t\t\tDBFA717B187F1D9B00A76262 /* trampoline_armv7.S in Sources */,\n+\t\t\t\tDBFA714E187F1D8600A76262 /* closures.c in Sources */,\n+\t\t\t\tDBFA717A187F1D9B00A76262 /* sysv_armv7.S in Sources */,\n+\t\t\t\tDBFA717D187F1D9B00A76262 /* darwin_i386.S in Sources */,\n+\t\t\t\tDBFA7156187F1D8600A76262 /* prep_cif.c in Sources */,\n+\t\t\t\tDBFA717F187F1D9B00A76262 /* ffi_i386.c in Sources */,\n+\t\t\t\tDBFA7158187F1D8600A76262 /* raw_api.c in Sources */,\n+\t\t\t\tDBFA7178187F1D9B00A76262 /* sysv_arm64.S in Sources */,\n+\t\t\t\tDBFA717C187F1D9B00A76262 /* darwin64_x86_64.S in Sources */,\n+\t\t\t\tDBFA715A187F1D8600A76262 /* types.c in Sources */,\n+\t\t\t\tDBFA7177187F1D9B00A76262 /* ffi_arm64.c in Sources */,\n \t\t\t);\n \t\t\trunOnlyForDeploymentPostprocessing = 0;\n \t\t};\n-\t\tF6F980B6147386130008F121 /* Sources */ = {\n+\t\tDB13B18D1849DF510010F42D /* Sources */ = {\n \t\t\tisa = PBXSourcesBuildPhase;\n \t\t\tbuildActionMask = 2147483647;\n \t\t\tfiles = (\n-\t\t\t\t6C43CBDC1534F76F00162364 /* ffi.c in Sources */,\n-\t\t\t\t6C43CBDD1534F76F00162364 /* sysv.S in Sources */,\n-\t\t\t\t6C43CBDE1534F76F00162364 /* trampoline.S in Sources */,\n-\t\t\t\t6C43CBE61534F76F00162364 /* darwin.S in Sources */,\n-\t\t\t\t6C43CBE81534F76F00162364 /* ffi.c in Sources */,\n-\t\t\t\t6C43CC2F1534F7BE00162364 /* closures.c in Sources */,\n-\t\t\t\t6C43CC351534F7BE00162364 /* java_raw_api.c in Sources */,\n-\t\t\t\t6C43CC371534F7BE00162364 /* prep_cif.c in Sources */,\n-\t\t\t\t6C43CC391534F7BE00162364 /* raw_api.c in Sources */,\n-\t\t\t\t6C43CC3B1534F7BE00162364 /* types.c in Sources */,\n+\t\t\t\tDBFA7196187F1DA100A76262 /* ffi64_x86_64.c in Sources */,\n+\t\t\t\tDBFA7195187F1DA100A76262 /* darwin_i386.S in Sources */,\n+\t\t\t\tDBFA7157187F1D8600A76262 /* prep_cif.c in Sources */,\n+\t\t\t\tDBFA7197187F1DA100A76262 /* ffi_i386.c in Sources */,\n+\t\t\t\tDBFA715B187F1D8600A76262 /* types.c in Sources */,\n+\t\t\t\tDBFA7159187F1D8600A76262 /* raw_api.c in Sources */,\n+\t\t\t\tDBFA714F187F1D8600A76262 /* closures.c in Sources */,\n+\t\t\t\tDBFA7194187F1DA100A76262 /* darwin64_x86_64.S in Sources */,\n \t\t\t);\n \t\t\trunOnlyForDeploymentPostprocessing = 0;\n \t\t};\n /* End PBXSourcesBuildPhase section */\n \n /* Begin XCBuildConfiguration section */\n-\t\t6C43CB4B1534E9D100162364 /* Debug */ = {\n+\t\tDB13B1601849DEB70010F42D /* Debug */ = {\n \t\t\tisa = XCBuildConfiguration;\n \t\t\tbuildSettings = {\n-\t\t\t\tARCHS = \"$(ARCHS_STANDARD_32_64_BIT)\";\n-\t\t\t\tDSTROOT = /tmp/ffi.dst;\n-\t\t\t\tFRAMEWORK_SEARCH_PATHS = (\n+\t\t\t\tHEADER_SEARCH_PATHS = (\n \t\t\t\t\t\"$(inherited)\",\n-\t\t\t\t\t\"\\\"$(SYSTEM_APPS_DIR)/Xcode.app/Contents/Developer/Library/Frameworks\\\"\",\n+\t\t\t\t\t\"darwin_common/include\",\n \t\t\t\t);\n-\t\t\t\tGCC_ENABLE_OBJC_EXCEPTIONS = YES;\n-\t\t\t\tGCC_VERSION = com.apple.compilers.llvm.clang.1_0;\n-\t\t\t\tGCC_WARN_64_TO_32_BIT_CONVERSION = YES;\n-\t\t\t\tGCC_WARN_UNINITIALIZED_AUTOS = YES;\n-\t\t\t\tMACOSX_DEPLOYMENT_TARGET = 10.6;\n \t\t\t\tONLY_ACTIVE_ARCH = YES;\n-\t\t\t\tPRODUCT_NAME = ffi;\n-\t\t\t\tSDKROOT = macosx;\n \t\t\t};\n \t\t\tname = Debug;\n \t\t};\n-\t\t6C43CB4C1534E9D100162364 /* Release */ = {\n+\t\tDB13B1611849DEB70010F42D /* Release */ = {\n \t\t\tisa = XCBuildConfiguration;\n \t\t\tbuildSettings = {\n-\t\t\t\tARCHS = \"$(ARCHS_STANDARD_32_64_BIT)\";\n-\t\t\t\tDEBUG_INFORMATION_FORMAT = \"dwarf-with-dsym\";\n-\t\t\t\tDSTROOT = /tmp/ffi.dst;\n-\t\t\t\tFRAMEWORK_SEARCH_PATHS = (\n+\t\t\t\tHEADER_SEARCH_PATHS = (\n \t\t\t\t\t\"$(inherited)\",\n-\t\t\t\t\t\"\\\"$(SYSTEM_APPS_DIR)/Xcode.app/Contents/Developer/Library/Frameworks\\\"\",\n+\t\t\t\t\t\"darwin_common/include\",\n \t\t\t\t);\n-\t\t\t\tGCC_ENABLE_OBJC_EXCEPTIONS = YES;\n-\t\t\t\tGCC_VERSION = com.apple.compilers.llvm.clang.1_0;\n-\t\t\t\tGCC_WARN_64_TO_32_BIT_CONVERSION = YES;\n-\t\t\t\tGCC_WARN_UNINITIALIZED_AUTOS = YES;\n-\t\t\t\tMACOSX_DEPLOYMENT_TARGET = 10.6;\n-\t\t\t\tPRODUCT_NAME = ffi;\n-\t\t\t\tSDKROOT = macosx;\n \t\t\t};\n \t\t\tname = Release;\n \t\t};\n-\t\tF6B083AB14721EE50031D8A1 /* Debug */ = {\n+\t\tDB13B1871849DF1E0010F42D /* Debug */ = {\n \t\t\tisa = XCBuildConfiguration;\n \t\t\tbuildSettings = {\n \t\t\t\tALWAYS_SEARCH_USER_PATHS = NO;\n-\t\t\t\tARCHS = \"$(ARCHS_STANDARD_32_BIT)\";\n+\t\t\t\tARCHS = \"$(ARCHS_STANDARD_INCLUDING_64_BIT)\";\n+\t\t\t\tCLANG_CXX_LANGUAGE_STANDARD = \"gnu++0x\";\n+\t\t\t\tCLANG_CXX_LIBRARY = \"libc++\";\n+\t\t\t\tCLANG_ENABLE_MODULES = YES;\n+\t\t\t\tCLANG_ENABLE_OBJC_ARC = YES;\n+\t\t\t\tCLANG_WARN_BOOL_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_CONSTANT_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;\n+\t\t\t\tCLANG_WARN_EMPTY_BODY = YES;\n+\t\t\t\tCLANG_WARN_ENUM_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_INT_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;\n+\t\t\t\tCLANG_WARN__DUPLICATE_METHOD_MATCH = YES;\n \t\t\t\tCOPY_PHASE_STRIP = NO;\n+\t\t\t\tDSTROOT = /tmp/ffi.dst;\n \t\t\t\tGCC_C_LANGUAGE_STANDARD = gnu99;\n \t\t\t\tGCC_DYNAMIC_NO_PIC = NO;\n \t\t\t\tGCC_OPTIMIZATION_LEVEL = 0;\n@@ -482,98 +457,181 @@\n \t\t\t\t\t\"$(inherited)\",\n \t\t\t\t);\n \t\t\t\tGCC_SYMBOLS_PRIVATE_EXTERN = NO;\n-\t\t\t\tGCC_WARN_ABOUT_MISSING_PROTOTYPES = NO;\n-\t\t\t\tGCC_WARN_ABOUT_RETURN_TYPE = YES;\n-\t\t\t\tGCC_WARN_UNUSED_VALUE = NO;\n+\t\t\t\tGCC_WARN_64_TO_32_BIT_CONVERSION = YES;\n+\t\t\t\tGCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;\n+\t\t\t\tGCC_WARN_UNDECLARED_SELECTOR = YES;\n+\t\t\t\tGCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;\n+\t\t\t\tGCC_WARN_UNUSED_FUNCTION = YES;\n \t\t\t\tGCC_WARN_UNUSED_VARIABLE = YES;\n-\t\t\t\tHEADER_SEARCH_PATHS = ios/include;\n+\t\t\t\tHEADER_SEARCH_PATHS = (\n+\t\t\t\t\t\"$(inherited)\",\n+\t\t\t\t\t\"darwin_ios/include\",\n+\t\t\t\t);\n+\t\t\t\tIPHONEOS_DEPLOYMENT_TARGET = 5.0;\n+\t\t\t\t\"IPHONEOS_DEPLOYMENT_TARGET[arch=arm64]\" = 7.0;\n+\t\t\t\tOTHER_LDFLAGS = \"-ObjC\";\n+\t\t\t\tPRODUCT_NAME = ffi;\n \t\t\t\tSDKROOT = iphoneos;\n+\t\t\t\tSKIP_INSTALL = YES;\n \t\t\t};\n \t\t\tname = Debug;\n \t\t};\n-\t\tF6B083AC14721EE50031D8A1 /* Release */ = {\n+\t\tDB13B1881849DF1E0010F42D /* Release */ = {\n \t\t\tisa = XCBuildConfiguration;\n \t\t\tbuildSettings = {\n \t\t\t\tALWAYS_SEARCH_USER_PATHS = NO;\n-\t\t\t\tARCHS = \"$(ARCHS_STANDARD_32_BIT)\";\n+\t\t\t\tARCHS = \"$(ARCHS_STANDARD_INCLUDING_64_BIT)\";\n+\t\t\t\tCLANG_CXX_LANGUAGE_STANDARD = \"gnu++0x\";\n+\t\t\t\tCLANG_CXX_LIBRARY = \"libc++\";\n+\t\t\t\tCLANG_ENABLE_MODULES = YES;\n+\t\t\t\tCLANG_ENABLE_OBJC_ARC = YES;\n+\t\t\t\tCLANG_WARN_BOOL_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_CONSTANT_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;\n+\t\t\t\tCLANG_WARN_EMPTY_BODY = YES;\n+\t\t\t\tCLANG_WARN_ENUM_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_INT_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;\n+\t\t\t\tCLANG_WARN__DUPLICATE_METHOD_MATCH = YES;\n \t\t\t\tCOPY_PHASE_STRIP = YES;\n+\t\t\t\tDSTROOT = /tmp/ffi.dst;\n+\t\t\t\tENABLE_NS_ASSERTIONS = NO;\n \t\t\t\tGCC_C_LANGUAGE_STANDARD = gnu99;\n-\t\t\t\tGCC_PREPROCESSOR_DEFINITIONS = \"\";\n-\t\t\t\tGCC_WARN_ABOUT_MISSING_PROTOTYPES = NO;\n-\t\t\t\tGCC_WARN_ABOUT_RETURN_TYPE = YES;\n-\t\t\t\tGCC_WARN_UNUSED_VALUE = NO;\n+\t\t\t\tGCC_WARN_64_TO_32_BIT_CONVERSION = YES;\n+\t\t\t\tGCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;\n+\t\t\t\tGCC_WARN_UNDECLARED_SELECTOR = YES;\n+\t\t\t\tGCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;\n+\t\t\t\tGCC_WARN_UNUSED_FUNCTION = YES;\n \t\t\t\tGCC_WARN_UNUSED_VARIABLE = YES;\n-\t\t\t\tHEADER_SEARCH_PATHS = ios/include;\n+\t\t\t\tHEADER_SEARCH_PATHS = (\n+\t\t\t\t\t\"$(inherited)\",\n+\t\t\t\t\t\"darwin_ios/include\",\n+\t\t\t\t);\n+\t\t\t\tIPHONEOS_DEPLOYMENT_TARGET = 5.0;\n+\t\t\t\t\"IPHONEOS_DEPLOYMENT_TARGET[arch=arm64]\" = 7.0;\n+\t\t\t\tOTHER_LDFLAGS = \"-ObjC\";\n+\t\t\t\tPRODUCT_NAME = ffi;\n \t\t\t\tSDKROOT = iphoneos;\n+\t\t\t\tSKIP_INSTALL = YES;\n \t\t\t\tVALIDATE_PRODUCT = YES;\n \t\t\t};\n \t\t\tname = Release;\n \t\t};\n-\t\tF6F980C2147386130008F121 /* Debug */ = {\n+\t\tDB13B1B11849DF520010F42D /* Debug */ = {\n \t\t\tisa = XCBuildConfiguration;\n \t\t\tbuildSettings = {\n-\t\t\t\tARCHS = (\n-\t\t\t\t\tarmv6,\n-\t\t\t\t\tarmv7,\n+\t\t\t\tALWAYS_SEARCH_USER_PATHS = NO;\n+\t\t\t\tCLANG_CXX_LANGUAGE_STANDARD = \"gnu++0x\";\n+\t\t\t\tCLANG_CXX_LIBRARY = \"libc++\";\n+\t\t\t\tCLANG_ENABLE_OBJC_ARC = YES;\n+\t\t\t\tCLANG_WARN_BOOL_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_CONSTANT_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;\n+\t\t\t\tCLANG_WARN_EMPTY_BODY = YES;\n+\t\t\t\tCLANG_WARN_ENUM_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_INT_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;\n+\t\t\t\tCLANG_WARN__DUPLICATE_METHOD_MATCH = YES;\n+\t\t\t\tCOPY_PHASE_STRIP = NO;\n+\t\t\t\tDYLIB_COMPATIBILITY_VERSION = 1;\n+\t\t\t\tDYLIB_CURRENT_VERSION = 1;\n+\t\t\t\tGCC_C_LANGUAGE_STANDARD = gnu99;\n+\t\t\t\tGCC_DYNAMIC_NO_PIC = NO;\n+\t\t\t\tGCC_ENABLE_OBJC_EXCEPTIONS = YES;\n+\t\t\t\tGCC_OPTIMIZATION_LEVEL = 0;\n+\t\t\t\tGCC_PREPROCESSOR_DEFINITIONS = (\n+\t\t\t\t\t\"DEBUG=1\",\n+\t\t\t\t\t\"$(inherited)\",\n \t\t\t\t);\n-\t\t\t\tDSTROOT = /tmp/ffi.dst;\n-\t\t\t\tGCC_PRECOMPILE_PREFIX_HEADER = YES;\n-\t\t\t\tGCC_THUMB_SUPPORT = NO;\n-\t\t\t\tIPHONEOS_DEPLOYMENT_TARGET = 4.0;\n-\t\t\t\tOTHER_LDFLAGS = \"-ObjC\";\n+\t\t\t\tGCC_SYMBOLS_PRIVATE_EXTERN = NO;\n+\t\t\t\tGCC_WARN_64_TO_32_BIT_CONVERSION = YES;\n+\t\t\t\tGCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;\n+\t\t\t\tGCC_WARN_UNDECLARED_SELECTOR = YES;\n+\t\t\t\tGCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;\n+\t\t\t\tGCC_WARN_UNUSED_FUNCTION = YES;\n+\t\t\t\tGCC_WARN_UNUSED_VARIABLE = YES;\n+\t\t\t\tHEADER_SEARCH_PATHS = (\n+\t\t\t\t\t\"$(inherited)\",\n+\t\t\t\t\t\"darwin_osx/include\",\n+\t\t\t\t);\n+\t\t\t\tMACOSX_DEPLOYMENT_TARGET = 10.6;\n+\t\t\t\tONLY_ACTIVE_ARCH = YES;\n+\t\t\t\tOTHER_LDFLAGS = \"-Wl,-no_compact_unwind\";\n \t\t\t\tPRODUCT_NAME = ffi;\n-\t\t\t\tSKIP_INSTALL = YES;\n+\t\t\t\tSDKROOT = macosx;\n \t\t\t};\n \t\t\tname = Debug;\n \t\t};\n-\t\tF6F980C3147386130008F121 /* Release */ = {\n+\t\tDB13B1B21849DF520010F42D /* Release */ = {\n \t\t\tisa = XCBuildConfiguration;\n \t\t\tbuildSettings = {\n-\t\t\t\tARCHS = (\n-\t\t\t\t\tarmv6,\n-\t\t\t\t\tarmv7,\n+\t\t\t\tALWAYS_SEARCH_USER_PATHS = NO;\n+\t\t\t\tCLANG_CXX_LANGUAGE_STANDARD = \"gnu++0x\";\n+\t\t\t\tCLANG_CXX_LIBRARY = \"libc++\";\n+\t\t\t\tCLANG_ENABLE_OBJC_ARC = YES;\n+\t\t\t\tCLANG_WARN_BOOL_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_CONSTANT_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;\n+\t\t\t\tCLANG_WARN_EMPTY_BODY = YES;\n+\t\t\t\tCLANG_WARN_ENUM_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_INT_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;\n+\t\t\t\tCLANG_WARN__DUPLICATE_METHOD_MATCH = YES;\n+\t\t\t\tCOPY_PHASE_STRIP = YES;\n+\t\t\t\tDEBUG_INFORMATION_FORMAT = \"dwarf-with-dsym\";\n+\t\t\t\tDYLIB_COMPATIBILITY_VERSION = 1;\n+\t\t\t\tDYLIB_CURRENT_VERSION = 1;\n+\t\t\t\tENABLE_NS_ASSERTIONS = NO;\n+\t\t\t\tGCC_C_LANGUAGE_STANDARD = gnu99;\n+\t\t\t\tGCC_ENABLE_OBJC_EXCEPTIONS = YES;\n+\t\t\t\tGCC_WARN_64_TO_32_BIT_CONVERSION = YES;\n+\t\t\t\tGCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;\n+\t\t\t\tGCC_WARN_UNDECLARED_SELECTOR = YES;\n+\t\t\t\tGCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;\n+\t\t\t\tGCC_WARN_UNUSED_FUNCTION = YES;\n+\t\t\t\tGCC_WARN_UNUSED_VARIABLE = YES;\n+\t\t\t\tHEADER_SEARCH_PATHS = (\n+\t\t\t\t\t\"$(inherited)\",\n+\t\t\t\t\t\"darwin_osx/include\",\n \t\t\t\t);\n-\t\t\t\tDSTROOT = /tmp/ffi.dst;\n-\t\t\t\tGCC_PRECOMPILE_PREFIX_HEADER = YES;\n-\t\t\t\tGCC_THUMB_SUPPORT = NO;\n-\t\t\t\tIPHONEOS_DEPLOYMENT_TARGET = 4.0;\n-\t\t\t\tOTHER_LDFLAGS = \"-ObjC\";\n+\t\t\t\tMACOSX_DEPLOYMENT_TARGET = 10.6;\n+\t\t\t\tOTHER_LDFLAGS = \"-Wl,-no_compact_unwind\";\n \t\t\t\tPRODUCT_NAME = ffi;\n-\t\t\t\tSKIP_INSTALL = YES;\n+\t\t\t\tSDKROOT = macosx;\n \t\t\t};\n \t\t\tname = Release;\n \t\t};\n /* End XCBuildConfiguration section */\n \n /* Begin XCConfigurationList section */\n-\t\t6C43CB4A1534E9D100162364 /* Build configuration list for PBXNativeTarget \"libffi OS X\" */ = {\n+\t\tDB13B15F1849DEB70010F42D /* Build configuration list for PBXProject \"libffi\" */ = {\n \t\t\tisa = XCConfigurationList;\n \t\t\tbuildConfigurations = (\n-\t\t\t\t6C43CB4B1534E9D100162364 /* Debug */,\n-\t\t\t\t6C43CB4C1534E9D100162364 /* Release */,\n+\t\t\t\tDB13B1601849DEB70010F42D /* Debug */,\n+\t\t\t\tDB13B1611849DEB70010F42D /* Release */,\n \t\t\t);\n \t\t\tdefaultConfigurationIsVisible = 0;\n \t\t\tdefaultConfigurationName = Release;\n \t\t};\n-\t\tF6B0839A14721EE50031D8A1 /* Build configuration list for PBXProject \"libffi\" */ = {\n+\t\tDB13B18B1849DF1E0010F42D /* Build configuration list for PBXNativeTarget \"libffi-iOS\" */ = {\n \t\t\tisa = XCConfigurationList;\n \t\t\tbuildConfigurations = (\n-\t\t\t\tF6B083AB14721EE50031D8A1 /* Debug */,\n-\t\t\t\tF6B083AC14721EE50031D8A1 /* Release */,\n+\t\t\t\tDB13B1871849DF1E0010F42D /* Debug */,\n+\t\t\t\tDB13B1881849DF1E0010F42D /* Release */,\n \t\t\t);\n \t\t\tdefaultConfigurationIsVisible = 0;\n \t\t\tdefaultConfigurationName = Release;\n \t\t};\n-\t\tF6F980C4147386130008F121 /* Build configuration list for PBXNativeTarget \"libffi iOS\" */ = {\n+\t\tDB13B1B01849DF520010F42D /* Build configuration list for PBXNativeTarget \"libffi-Mac\" */ = {\n \t\t\tisa = XCConfigurationList;\n \t\t\tbuildConfigurations = (\n-\t\t\t\tF6F980C2147386130008F121 /* Debug */,\n-\t\t\t\tF6F980C3147386130008F121 /* Release */,\n+\t\t\t\tDB13B1B11849DF520010F42D /* Debug */,\n+\t\t\t\tDB13B1B21849DF520010F42D /* Release */,\n \t\t\t);\n \t\t\tdefaultConfigurationIsVisible = 0;\n \t\t\tdefaultConfigurationName = Release;\n \t\t};\n /* End XCConfigurationList section */\n \t};\n-\trootObject = F6B0839714721EE50031D8A1 /* Project object */;\n+\trootObject = DB13B15C1849DEB70010F42D /* Project object */;\n }"}, {"sha": "39f6cbf89f735aa109c5cb0e96bfdb608bf66e7b", "filename": "libffi/man/Makefile.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fman%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fman%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fman%2FMakefile.in?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -97,6 +97,10 @@ CCDEPMODE = @CCDEPMODE@\n CFLAGS = @CFLAGS@\n CPP = @CPP@\n CPPFLAGS = @CPPFLAGS@\n+CXX = @CXX@\n+CXXCPP = @CXXCPP@\n+CXXDEPMODE = @CXXDEPMODE@\n+CXXFLAGS = @CXXFLAGS@\n CYGPATH_W = @CYGPATH_W@\n DEFS = @DEFS@\n DEPDIR = @DEPDIR@\n@@ -149,12 +153,14 @@ SHELL = @SHELL@\n STRIP = @STRIP@\n TARGET = @TARGET@\n TARGETDIR = @TARGETDIR@\n+TARGET_OBJ = @TARGET_OBJ@\n VERSION = @VERSION@\n abs_builddir = @abs_builddir@\n abs_srcdir = @abs_srcdir@\n abs_top_builddir = @abs_top_builddir@\n abs_top_srcdir = @abs_top_srcdir@\n ac_ct_CC = @ac_ct_CC@\n+ac_ct_CXX = @ac_ct_CXX@\n ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n am__include = @am__include@\n am__leading_dot = @am__leading_dot@"}, {"sha": "ab2be8adc17a19af2507c495887fce1c31c7a4e7", "filename": "libffi/man/ffi_prep_cif.3", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fman%2Fffi_prep_cif.3", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fman%2Fffi_prep_cif.3", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fman%2Fffi_prep_cif.3?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -61,10 +61,8 @@ does not refer to a valid ABI,\n .Nm FFI_BAD_ABI\n will be returned. Available ABIs are\n defined in\n-.Nm <ffitarget.h>\n-.\n+.Nm <ffitarget.h> .\n .Sh SEE ALSO\n .Xr ffi 3 ,\n .Xr ffi_call 3 ,\n .Xr ffi_prep_cif_var 3\n-"}, {"sha": "65fbfef7e35b88ebab245112e19d229b43241bf2", "filename": "libffi/msvcc.sh", "status": "modified", "additions": 69, "deletions": 9, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fmsvcc.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fmsvcc.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fmsvcc.sh?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -42,8 +42,10 @@\n # format and translated into something sensible for cl or ml.\n #\n \n+args_orig=$@\n args=\"-nologo -W3\"\n-md=-MD\n+static_crt=\n+debug_crt=\n cl=\"cl\"\n ml=\"ml\"\n safeseh=\"-safeseh\"\n@@ -62,31 +64,65 @@ do\n       shift 1\n     ;;\n     -m64)\n-      cl=\"cl\"   # \"$MSVC/x86_amd64/cl\"\n       ml=\"ml64\" # \"$MSVC/x86_amd64/ml64\"\n       safeseh=\n       shift 1\n     ;;\n+    -clang-cl)\n+      cl=\"clang-cl\"\n+      safeseh=\n+      shift 1\n+    ;;\n     -O0)\n       args=\"$args -Od\"\n       shift 1\n     ;;\n     -O*)\n-      # If we're optimizing, make sure we explicitly turn on some optimizations\n-      # that are implicitly disabled by debug symbols (-Zi).\n-      args=\"$args $1 -OPT:REF -OPT:ICF -INCREMENTAL:NO\"\n+      # Runtime error checks (enabled by setting -RTC1 in the -DFFI_DEBUG\n+      # case below) are not compatible with optimization flags and will\n+      # cause the build to fail. Therefore, drop the optimization flag if\n+      # -DFFI_DEBUG is also set.\n+      case $args_orig in\n+        *-DFFI_DEBUG*)\n+          args=\"$args\"\n+        ;;\n+        *)\n+          # The ax_cc_maxopt.m4 macro from the upstream autoconf-archive\n+          # project doesn't support MSVC and therefore ends up trying to\n+          # use -O3. Use the equivalent \"max optimization\" flag for MSVC\n+          # instead of erroring out.\n+          case $1 in\n+            -O3)\n+              args=\"$args -O2\"\n+            ;;\n+            *)\n+              args=\"$args $1\"\n+            ;;\n+          esac\n+          opt=\"true\"\n+        ;;\n+      esac\n       shift 1\n     ;;\n     -g)\n       # Enable debug symbol generation.\n-      args=\"$args -Zi -DEBUG\"\n+      args=\"$args -Zi\"\n       shift 1\n     ;;\n     -DFFI_DEBUG)\n-      # Link against debug CRT and enable runtime error checks.\n+      # Enable runtime error checks.\n       args=\"$args -RTC1\"\n       defines=\"$defines $1\"\n-      md=-MDd\n+      shift 1\n+    ;;\n+    -DUSE_STATIC_RTL)\n+      # Link against static CRT.\n+      static_crt=1\n+      shift 1\n+    ;;\n+    -DUSE_DEBUG_RTL)\n+      # Link against debug CRT.\n+      debug_crt=1\n       shift 1\n     ;;\n     -c)\n@@ -126,6 +162,10 @@ do\n       # to do here.\n       shift 1\n     ;;\n+    -pedantic)\n+      # libffi tests -pedantic with -Wall, so drop it also.\n+      shift 1\n+    ;;\n     -Werror)\n       args=\"$args -WX\"\n       shift 1\n@@ -170,6 +210,23 @@ do\n   esac\n done\n \n+# If -Zi is specified, certain optimizations are implicitly disabled\n+# by MSVC. Add back those optimizations if this is an optimized build.\n+# NOTE: These arguments must come after all others.\n+if [ -n \"$opt\" ]; then\n+    args=\"$args -link -OPT:REF -OPT:ICF -INCREMENTAL:NO\"\n+fi\n+\n+if [ -n \"$static_crt\" ]; then\n+    md=-MT\n+else\n+    md=-MD\n+fi\n+\n+if [ -n \"$debug_crt\" ]; then\n+    md=\"${md}d\"\n+fi\n+\n if [ -n \"$assembly\" ]; then\n     if [ -z \"$outdir\" ]; then\n       outdir=\".\"\n@@ -189,7 +246,10 @@ if [ -n \"$assembly\" ]; then\n else\n     args=\"$md $args\"\n     echo \"$cl $args\"\n-    eval \"\\\"$cl\\\" $args\"\n+    # Return an error code of 1 if an invalid command line parameter is passed\n+    # instead of just ignoring it.\n+    eval \"(\\\"$cl\\\" $args 2>&1 1>&3 | \\\n+          awk '{print \\$0} /D9002/ {error=1} END{exit error}' >&2) 3>&1\"\n     result=$?\n fi\n "}, {"sha": "0cace9d8e7c38b6c6f68e26bc4b8c8c738e06f5a", "filename": "libffi/src/aarch64/ffi.c", "status": "modified", "additions": 638, "deletions": 804, "changes": 1442, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Faarch64%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Faarch64%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Faarch64%2Fffi.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -20,341 +20,207 @@ TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */\n \n #include <stdio.h>\n-\n+#include <stdlib.h>\n+#include <stdint.h>\n #include <ffi.h>\n #include <ffi_common.h>\n-\n-#include <stdlib.h>\n-\n-/* Stack alignment requirement in bytes */\n-#define AARCH64_STACK_ALIGN 16\n-\n-#define N_X_ARG_REG 8\n-#define N_V_ARG_REG 8\n-\n-#define AARCH64_FFI_WITH_V (1 << AARCH64_FFI_WITH_V_BIT)\n+#include \"internal.h\"\n+\n+/* Force FFI_TYPE_LONGDOUBLE to be different than FFI_TYPE_DOUBLE;\n+   all further uses in this file will refer to the 128-bit type.  */\n+#if FFI_TYPE_DOUBLE != FFI_TYPE_LONGDOUBLE\n+# if FFI_TYPE_LONGDOUBLE != 4\n+#  error FFI_TYPE_LONGDOUBLE out of date\n+# endif\n+#else\n+# undef FFI_TYPE_LONGDOUBLE\n+# define FFI_TYPE_LONGDOUBLE 4\n+#endif\n \n union _d\n {\n   UINT64 d;\n   UINT32 s[2];\n };\n \n-struct call_context\n+struct _v\n {\n-  UINT64 x [AARCH64_N_XREG];\n-  struct\n-  {\n-    union _d d[2];\n-  } v [AARCH64_N_VREG];\n+  union _d d[2] __attribute__((aligned(16)));\n };\n \n-static void *\n-get_x_addr (struct call_context *context, unsigned n)\n+struct call_context\n {\n-  return &context->x[n];\n-}\n+  struct _v v[N_V_ARG_REG];\n+  UINT64 x[N_X_ARG_REG];\n+};\n \n-static void *\n-get_s_addr (struct call_context *context, unsigned n)\n-{\n-#if defined __AARCH64EB__\n-  return &context->v[n].d[1].s[1];\n-#else\n-  return &context->v[n].d[0].s[0];\n+#if defined (__clang__) && defined (__APPLE__)\n+extern void sys_icache_invalidate (void *start, size_t len);\n #endif\n-}\n \n-static void *\n-get_d_addr (struct call_context *context, unsigned n)\n+static inline void\n+ffi_clear_cache (void *start, void *end)\n {\n-#if defined __AARCH64EB__\n-  return &context->v[n].d[1];\n+#if defined (__clang__) && defined (__APPLE__)\n+  sys_icache_invalidate (start, (char *)end - (char *)start);\n+#elif defined (__GNUC__)\n+  __builtin___clear_cache (start, end);\n #else\n-  return &context->v[n].d[0];\n+#error \"Missing builtin to flush instruction cache\"\n #endif\n }\n \n-static void *\n-get_v_addr (struct call_context *context, unsigned n)\n-{\n-  return &context->v[n];\n-}\n-\n-/* Return the memory location at which a basic type would reside\n-   were it to have been stored in register n.  */\n-\n-static void *\n-get_basic_type_addr (unsigned short type, struct call_context *context,\n-\t\t     unsigned n)\n-{\n-  switch (type)\n-    {\n-    case FFI_TYPE_FLOAT:\n-      return get_s_addr (context, n);\n-    case FFI_TYPE_DOUBLE:\n-      return get_d_addr (context, n);\n-    case FFI_TYPE_LONGDOUBLE:\n-      return get_v_addr (context, n);\n-    case FFI_TYPE_UINT8:\n-    case FFI_TYPE_SINT8:\n-    case FFI_TYPE_UINT16:\n-    case FFI_TYPE_SINT16:\n-    case FFI_TYPE_UINT32:\n-    case FFI_TYPE_SINT32:\n-    case FFI_TYPE_INT:\n-    case FFI_TYPE_POINTER:\n-    case FFI_TYPE_UINT64:\n-    case FFI_TYPE_SINT64:\n-      return get_x_addr (context, n);\n-    default:\n-      FFI_ASSERT (0);\n-      return NULL;\n-    }\n-}\n-\n-/* Return the alignment width for each of the basic types.  */\n-\n-static size_t\n-get_basic_type_alignment (unsigned short type)\n-{\n-  switch (type)\n-    {\n-    case FFI_TYPE_FLOAT:\n-    case FFI_TYPE_DOUBLE:\n-      return sizeof (UINT64);\n-    case FFI_TYPE_LONGDOUBLE:\n-      return sizeof (long double);\n-    case FFI_TYPE_UINT8:\n-    case FFI_TYPE_SINT8:\n-    case FFI_TYPE_UINT16:\n-    case FFI_TYPE_SINT16:\n-    case FFI_TYPE_UINT32:\n-    case FFI_TYPE_INT:\n-    case FFI_TYPE_SINT32:\n-    case FFI_TYPE_POINTER:\n-    case FFI_TYPE_UINT64:\n-    case FFI_TYPE_SINT64:\n-      return sizeof (UINT64);\n-\n-    default:\n-      FFI_ASSERT (0);\n-      return 0;\n-    }\n-}\n-\n-/* Return the size in bytes for each of the basic types.  */\n+/* A subroutine of is_vfp_type.  Given a structure type, return the type code\n+   of the first non-structure element.  Recurse for structure elements.\n+   Return -1 if the structure is in fact empty, i.e. no nested elements.  */\n \n-static size_t\n-get_basic_type_size (unsigned short type)\n+static int\n+is_hfa0 (const ffi_type *ty)\n {\n-  switch (type)\n-    {\n-    case FFI_TYPE_FLOAT:\n-      return sizeof (UINT32);\n-    case FFI_TYPE_DOUBLE:\n-      return sizeof (UINT64);\n-    case FFI_TYPE_LONGDOUBLE:\n-      return sizeof (long double);\n-    case FFI_TYPE_UINT8:\n-      return sizeof (UINT8);\n-    case FFI_TYPE_SINT8:\n-      return sizeof (SINT8);\n-    case FFI_TYPE_UINT16:\n-      return sizeof (UINT16);\n-    case FFI_TYPE_SINT16:\n-      return sizeof (SINT16);\n-    case FFI_TYPE_UINT32:\n-      return sizeof (UINT32);\n-    case FFI_TYPE_INT:\n-    case FFI_TYPE_SINT32:\n-      return sizeof (SINT32);\n-    case FFI_TYPE_POINTER:\n-    case FFI_TYPE_UINT64:\n-      return sizeof (UINT64);\n-    case FFI_TYPE_SINT64:\n-      return sizeof (SINT64);\n-\n-    default:\n-      FFI_ASSERT (0);\n-      return 0;\n-    }\n-}\n-\n-extern void\n-ffi_call_SYSV (unsigned (*)(struct call_context *context, unsigned char *,\n-\t\t\t    extended_cif *),\n-               struct call_context *context,\n-               extended_cif *,\n-               unsigned,\n-               void (*fn)(void));\n+  ffi_type **elements = ty->elements;\n+  int i, ret = -1;\n \n-extern void\n-ffi_closure_SYSV (ffi_closure *);\n-\n-/* Test for an FFI floating point representation.  */\n+  if (elements != NULL)\n+    for (i = 0; elements[i]; ++i)\n+      {\n+        ret = elements[i]->type;\n+        if (ret == FFI_TYPE_STRUCT || ret == FFI_TYPE_COMPLEX)\n+          {\n+            ret = is_hfa0 (elements[i]);\n+            if (ret < 0)\n+              continue;\n+          }\n+        break;\n+      }\n \n-static unsigned\n-is_floating_type (unsigned short type)\n-{\n-  return (type == FFI_TYPE_FLOAT || type == FFI_TYPE_DOUBLE\n-\t  || type == FFI_TYPE_LONGDOUBLE);\n+  return ret;\n }\n \n-/* Test for a homogeneous structure.  */\n+/* A subroutine of is_vfp_type.  Given a structure type, return true if all\n+   of the non-structure elements are the same as CANDIDATE.  */\n \n-static unsigned short\n-get_homogeneous_type (ffi_type *ty)\n+static int\n+is_hfa1 (const ffi_type *ty, int candidate)\n {\n-  if (ty->type == FFI_TYPE_STRUCT && ty->elements)\n-    {\n-      unsigned i;\n-      unsigned short candidate_type\n-\t= get_homogeneous_type (ty->elements[0]);\n-      for (i =1; ty->elements[i]; i++)\n-\t{\n-\t  unsigned short iteration_type = 0;\n-\t  /* If we have a nested struct, we must find its homogeneous type.\n-\t     If that fits with our candidate type, we are still\n-\t     homogeneous.  */\n-\t  if (ty->elements[i]->type == FFI_TYPE_STRUCT\n-\t      && ty->elements[i]->elements)\n-\t    {\n-\t      iteration_type = get_homogeneous_type (ty->elements[i]);\n-\t    }\n-\t  else\n-\t    {\n-\t      iteration_type = ty->elements[i]->type;\n-\t    }\n+  ffi_type **elements = ty->elements;\n+  int i;\n \n-\t  /* If we are not homogeneous, return FFI_TYPE_STRUCT.  */\n-\t  if (candidate_type != iteration_type)\n-\t    return FFI_TYPE_STRUCT;\n-\t}\n-      return candidate_type;\n-    }\n+  if (elements != NULL)\n+    for (i = 0; elements[i]; ++i)\n+      {\n+        int t = elements[i]->type;\n+        if (t == FFI_TYPE_STRUCT || t == FFI_TYPE_COMPLEX)\n+          {\n+            if (!is_hfa1 (elements[i], candidate))\n+              return 0;\n+          }\n+        else if (t != candidate)\n+          return 0;\n+      }\n \n-  /* Base case, we have no more levels of nesting, so we\n-     are a basic type, and so, trivially homogeneous in that type.  */\n-  return ty->type;\n+  return 1;\n }\n \n-/* Determine the number of elements within a STRUCT.\n-\n-   Note, we must handle nested structs.\n+/* Determine if TY may be allocated to the FP registers.  This is both an\n+   fp scalar type as well as an homogenous floating point aggregate (HFA).\n+   That is, a structure consisting of 1 to 4 members of all the same type,\n+   where that type is an fp scalar.\n \n-   If ty is not a STRUCT this function will return 0.  */\n+   Returns non-zero iff TY is an HFA.  The result is the AARCH64_RET_*\n+   constant for the type.  */\n \n-static unsigned\n-element_count (ffi_type *ty)\n+static int\n+is_vfp_type (const ffi_type *ty)\n {\n-  if (ty->type == FFI_TYPE_STRUCT && ty->elements)\n+  ffi_type **elements;\n+  int candidate, i;\n+  size_t size, ele_count;\n+\n+  /* Quickest tests first.  */\n+  candidate = ty->type;\n+  switch (candidate)\n     {\n-      unsigned n;\n-      unsigned elems = 0;\n-      for (n = 0; ty->elements[n]; n++)\n+    default:\n+      return 0;\n+    case FFI_TYPE_FLOAT:\n+    case FFI_TYPE_DOUBLE:\n+    case FFI_TYPE_LONGDOUBLE:\n+      ele_count = 1;\n+      goto done;\n+    case FFI_TYPE_COMPLEX:\n+      candidate = ty->elements[0]->type;\n+      switch (candidate)\n \t{\n-\t  if (ty->elements[n]->type == FFI_TYPE_STRUCT\n-\t      && ty->elements[n]->elements)\n-\t    elems += element_count (ty->elements[n]);\n-\t  else\n-\t    elems++;\n+\tcase FFI_TYPE_FLOAT:\n+\tcase FFI_TYPE_DOUBLE:\n+\tcase FFI_TYPE_LONGDOUBLE:\n+\t  ele_count = 2;\n+\t  goto done;\n \t}\n-      return elems;\n+      return 0;\n+    case FFI_TYPE_STRUCT:\n+      break;\n     }\n-  return 0;\n-}\n-\n-/* Test for a homogeneous floating point aggregate.\n \n-   A homogeneous floating point aggregate is a homogeneous aggregate of\n-   a half- single- or double- precision floating point type with one\n-   to four elements.  Note that this includes nested structs of the\n-   basic type.  */\n+  /* No HFA types are smaller than 4 bytes, or larger than 64 bytes.  */\n+  size = ty->size;\n+  if (size < 4 || size > 64)\n+    return 0;\n \n-static int\n-is_hfa (ffi_type *ty)\n-{\n-  if (ty->type == FFI_TYPE_STRUCT\n-      && ty->elements[0]\n-      && is_floating_type (get_homogeneous_type (ty)))\n+  /* Find the type of the first non-structure member.  */\n+  elements = ty->elements;\n+  candidate = elements[0]->type;\n+  if (candidate == FFI_TYPE_STRUCT || candidate == FFI_TYPE_COMPLEX)\n     {\n-      unsigned n = element_count (ty);\n-      return n >= 1 && n <= 4;\n+      for (i = 0; ; ++i)\n+        {\n+          candidate = is_hfa0 (elements[i]);\n+          if (candidate >= 0)\n+            break;\n+        }\n     }\n-  return 0;\n-}\n-\n-/* Test if an ffi_type is a candidate for passing in a register.\n-\n-   This test does not check that sufficient registers of the\n-   appropriate class are actually available, merely that IFF\n-   sufficient registers are available then the argument will be passed\n-   in register(s).\n \n-   Note that an ffi_type that is deemed to be a register candidate\n-   will always be returned in registers.\n-\n-   Returns 1 if a register candidate else 0.  */\n-\n-static int\n-is_register_candidate (ffi_type *ty)\n-{\n-  switch (ty->type)\n+  /* If the first member is not a floating point type, it's not an HFA.\n+     Also quickly re-check the size of the structure.  */\n+  switch (candidate)\n     {\n-    case FFI_TYPE_VOID:\n     case FFI_TYPE_FLOAT:\n+      ele_count = size / sizeof(float);\n+      if (size != ele_count * sizeof(float))\n+        return 0;\n+      break;\n     case FFI_TYPE_DOUBLE:\n+      ele_count = size / sizeof(double);\n+      if (size != ele_count * sizeof(double))\n+        return 0;\n+      break;\n     case FFI_TYPE_LONGDOUBLE:\n-    case FFI_TYPE_UINT8:\n-    case FFI_TYPE_UINT16:\n-    case FFI_TYPE_UINT32:\n-    case FFI_TYPE_UINT64:\n-    case FFI_TYPE_POINTER:\n-    case FFI_TYPE_SINT8:\n-    case FFI_TYPE_SINT16:\n-    case FFI_TYPE_SINT32:\n-    case FFI_TYPE_INT:\n-    case FFI_TYPE_SINT64:\n-      return 1;\n-\n-    case FFI_TYPE_STRUCT:\n-      if (is_hfa (ty))\n-        {\n-          return 1;\n-        }\n-      else if (ty->size > 16)\n-        {\n-          /* Too large. Will be replaced with a pointer to memory. The\n-             pointer MAY be passed in a register, but the value will\n-             not. This test specifically fails since the argument will\n-             never be passed by value in registers. */\n-          return 0;\n-        }\n-      else\n-        {\n-          /* Might be passed in registers depending on the number of\n-             registers required. */\n-          return (ty->size + 7) / 8 < N_X_ARG_REG;\n-        }\n+      ele_count = size / sizeof(long double);\n+      if (size != ele_count * sizeof(long double))\n+        return 0;\n       break;\n-\n     default:\n-      FFI_ASSERT (0);\n-      break;\n+      return 0;\n     }\n+  if (ele_count > 4)\n+    return 0;\n \n-  return 0;\n-}\n-\n-/* Test if an ffi_type argument or result is a candidate for a vector\n-   register.  */\n+  /* Finally, make sure that all scalar elements are the same type.  */\n+  for (i = 0; elements[i]; ++i)\n+    {\n+      int t = elements[i]->type;\n+      if (t == FFI_TYPE_STRUCT || t == FFI_TYPE_COMPLEX)\n+        {\n+          if (!is_hfa1 (elements[i], candidate))\n+            return 0;\n+        }\n+      else if (t != candidate)\n+        return 0;\n+    }\n \n-static int\n-is_v_register_candidate (ffi_type *ty)\n-{\n-  return is_floating_type (ty->type)\n-\t   || (ty->type == FFI_TYPE_STRUCT && is_hfa (ty));\n+  /* All tests succeeded.  Encode the result.  */\n+ done:\n+  return candidate * 4 + (4 - ele_count);\n }\n \n /* Representation of the procedure call argument marshalling\n@@ -367,485 +233,558 @@ struct arg_state\n {\n   unsigned ngrn;                /* Next general-purpose register number. */\n   unsigned nsrn;                /* Next vector register number. */\n-  unsigned nsaa;                /* Next stack offset. */\n+  size_t nsaa;                  /* Next stack offset. */\n+\n+#if defined (__APPLE__)\n+  unsigned allocating_variadic;\n+#endif\n };\n \n /* Initialize a procedure call argument marshalling state.  */\n static void\n-arg_init (struct arg_state *state, unsigned call_frame_size)\n+arg_init (struct arg_state *state)\n {\n   state->ngrn = 0;\n   state->nsrn = 0;\n   state->nsaa = 0;\n-}\n-\n-/* Return the number of available consecutive core argument\n-   registers.  */\n-\n-static unsigned\n-available_x (struct arg_state *state)\n-{\n-  return N_X_ARG_REG - state->ngrn;\n-}\n-\n-/* Return the number of available consecutive vector argument\n-   registers.  */\n-\n-static unsigned\n-available_v (struct arg_state *state)\n-{\n-  return N_V_ARG_REG - state->nsrn;\n-}\n-\n-static void *\n-allocate_to_x (struct call_context *context, struct arg_state *state)\n-{\n-  FFI_ASSERT (state->ngrn < N_X_ARG_REG)\n-  return get_x_addr (context, (state->ngrn)++);\n-}\n-\n-static void *\n-allocate_to_s (struct call_context *context, struct arg_state *state)\n-{\n-  FFI_ASSERT (state->nsrn < N_V_ARG_REG)\n-  return get_s_addr (context, (state->nsrn)++);\n-}\n-\n-static void *\n-allocate_to_d (struct call_context *context, struct arg_state *state)\n-{\n-  FFI_ASSERT (state->nsrn < N_V_ARG_REG)\n-  return get_d_addr (context, (state->nsrn)++);\n-}\n-\n-static void *\n-allocate_to_v (struct call_context *context, struct arg_state *state)\n-{\n-  FFI_ASSERT (state->nsrn < N_V_ARG_REG)\n-  return get_v_addr (context, (state->nsrn)++);\n+#if defined (__APPLE__)\n+  state->allocating_variadic = 0;\n+#endif\n }\n \n /* Allocate an aligned slot on the stack and return a pointer to it.  */\n static void *\n-allocate_to_stack (struct arg_state *state, void *stack, unsigned alignment,\n-\t\t   unsigned size)\n+allocate_to_stack (struct arg_state *state, void *stack,\n+\t\t   size_t alignment, size_t size)\n {\n-  void *allocation;\n+  size_t nsaa = state->nsaa;\n \n   /* Round up the NSAA to the larger of 8 or the natural\n      alignment of the argument's type.  */\n-  state->nsaa = ALIGN (state->nsaa, alignment);\n-  state->nsaa = ALIGN (state->nsaa, alignment);\n-  state->nsaa = ALIGN (state->nsaa, 8);\n-\n-  allocation = stack + state->nsaa;\n+#if defined (__APPLE__)\n+  if (state->allocating_variadic && alignment < 8)\n+    alignment = 8;\n+#else\n+  if (alignment < 8)\n+    alignment = 8;\n+#endif\n+    \n+  nsaa = ALIGN (nsaa, alignment);\n+  state->nsaa = nsaa + size;\n \n-  state->nsaa += size;\n-  return allocation;\n+  return (char *)stack + nsaa;\n }\n \n-static void\n-copy_basic_type (void *dest, void *source, unsigned short type)\n+static ffi_arg\n+extend_integer_type (void *source, int type)\n {\n-  /* This is neccessary to ensure that basic types are copied\n-     sign extended to 64-bits as libffi expects.  */\n   switch (type)\n     {\n-    case FFI_TYPE_FLOAT:\n-      *(float *) dest = *(float *) source;\n-      break;\n-    case FFI_TYPE_DOUBLE:\n-      *(double *) dest = *(double *) source;\n-      break;\n-    case FFI_TYPE_LONGDOUBLE:\n-      *(long double *) dest = *(long double *) source;\n-      break;\n     case FFI_TYPE_UINT8:\n-      *(ffi_arg *) dest = *(UINT8 *) source;\n-      break;\n+      return *(UINT8 *) source;\n     case FFI_TYPE_SINT8:\n-      *(ffi_sarg *) dest = *(SINT8 *) source;\n-      break;\n+      return *(SINT8 *) source;\n     case FFI_TYPE_UINT16:\n-      *(ffi_arg *) dest = *(UINT16 *) source;\n-      break;\n+      return *(UINT16 *) source;\n     case FFI_TYPE_SINT16:\n-      *(ffi_sarg *) dest = *(SINT16 *) source;\n-      break;\n+      return *(SINT16 *) source;\n     case FFI_TYPE_UINT32:\n-      *(ffi_arg *) dest = *(UINT32 *) source;\n-      break;\n+      return *(UINT32 *) source;\n     case FFI_TYPE_INT:\n     case FFI_TYPE_SINT32:\n-      *(ffi_sarg *) dest = *(SINT32 *) source;\n-      break;\n-    case FFI_TYPE_POINTER:\n+      return *(SINT32 *) source;\n     case FFI_TYPE_UINT64:\n-      *(ffi_arg *) dest = *(UINT64 *) source;\n-      break;\n     case FFI_TYPE_SINT64:\n-      *(ffi_sarg *) dest = *(SINT64 *) source;\n+      return *(UINT64 *) source;\n       break;\n-\n+    case FFI_TYPE_POINTER:\n+      return *(uintptr_t *) source;\n     default:\n-      FFI_ASSERT (0);\n+      abort();\n     }\n }\n \n static void\n-copy_hfa_to_reg_or_stack (void *memory,\n-\t\t\t  ffi_type *ty,\n-\t\t\t  struct call_context *context,\n-\t\t\t  unsigned char *stack,\n-\t\t\t  struct arg_state *state)\n+extend_hfa_type (void *dest, void *src, int h)\n+{\n+  int f = h - AARCH64_RET_S4;\n+  void *x0;\n+\n+  asm volatile (\n+\t\"adr\t%0, 0f\\n\"\n+\"\tadd\t%0, %0, %1\\n\"\n+\"\tbr\t%0\\n\"\n+\"0:\tldp\ts16, s17, [%3]\\n\"\t/* S4 */\n+\"\tldp\ts18, s19, [%3, #8]\\n\"\n+\"\tb\t4f\\n\"\n+\"\tldp\ts16, s17, [%3]\\n\"\t/* S3 */\n+\"\tldr\ts18, [%3, #8]\\n\"\n+\"\tb\t3f\\n\"\n+\"\tldp\ts16, s17, [%3]\\n\"\t/* S2 */\n+\"\tb\t2f\\n\"\n+\"\tnop\\n\"\n+\"\tldr\ts16, [%3]\\n\"\t\t/* S1 */\n+\"\tb\t1f\\n\"\n+\"\tnop\\n\"\n+\"\tldp\td16, d17, [%3]\\n\"\t/* D4 */\n+\"\tldp\td18, d19, [%3, #16]\\n\"\n+\"\tb\t4f\\n\"\n+\"\tldp\td16, d17, [%3]\\n\"\t/* D3 */\n+\"\tldr\td18, [%3, #16]\\n\"\n+\"\tb\t3f\\n\"\n+\"\tldp\td16, d17, [%3]\\n\"\t/* D2 */\n+\"\tb\t2f\\n\"\n+\"\tnop\\n\"\n+\"\tldr\td16, [%3]\\n\"\t\t/* D1 */\n+\"\tb\t1f\\n\"\n+\"\tnop\\n\"\n+\"\tldp\tq16, q17, [%3]\\n\"\t/* Q4 */\n+\"\tldp\tq18, q19, [%3, #16]\\n\"\n+\"\tb\t4f\\n\"\n+\"\tldp\tq16, q17, [%3]\\n\"\t/* Q3 */\n+\"\tldr\tq18, [%3, #16]\\n\"\n+\"\tb\t3f\\n\"\n+\"\tldp\tq16, q17, [%3]\\n\"\t/* Q2 */\n+\"\tb\t2f\\n\"\n+\"\tnop\\n\"\n+\"\tldr\tq16, [%3]\\n\"\t\t/* Q1 */\n+\"\tb\t1f\\n\"\n+\"4:\tstr\tq19, [%2, #48]\\n\"\n+\"3:\tstr\tq18, [%2, #32]\\n\"\n+\"2:\tstr\tq17, [%2, #16]\\n\"\n+\"1:\tstr\tq16, [%2]\"\n+    : \"=&r\"(x0)\n+    : \"r\"(f * 12), \"r\"(dest), \"r\"(src)\n+    : \"memory\", \"v16\", \"v17\", \"v18\", \"v19\");\n+}\n+\n+static void *\n+compress_hfa_type (void *dest, void *reg, int h)\n {\n-  unsigned elems = element_count (ty);\n-  if (available_v (state) < elems)\n-    {\n-      /* There are insufficient V registers. Further V register allocations\n-\t are prevented, the NSAA is adjusted (by allocate_to_stack ())\n-\t and the argument is copied to memory at the adjusted NSAA.  */\n-      state->nsrn = N_V_ARG_REG;\n-      memcpy (allocate_to_stack (state, stack, ty->alignment, ty->size),\n-\t      memory,\n-\t      ty->size);\n-    }\n-  else\n+  switch (h)\n     {\n-      int i;\n-      unsigned short type = get_homogeneous_type (ty);\n-      unsigned elems = element_count (ty);\n-      for (i = 0; i < elems; i++)\n+    case AARCH64_RET_S1:\n+      if (dest == reg)\n+\t{\n+#ifdef __AARCH64EB__\n+\t  dest += 12;\n+#endif\n+\t}\n+      else\n+\t*(float *)dest = *(float *)reg;\n+      break;\n+    case AARCH64_RET_S2:\n+      asm (\"ldp q16, q17, [%1]\\n\\t\"\n+\t   \"st2 { v16.s, v17.s }[0], [%0]\"\n+\t   : : \"r\"(dest), \"r\"(reg) : \"memory\", \"v16\", \"v17\");\n+      break;\n+    case AARCH64_RET_S3:\n+      asm (\"ldp q16, q17, [%1]\\n\\t\"\n+\t   \"ldr q18, [%1, #32]\\n\\t\"\n+\t   \"st3 { v16.s, v17.s, v18.s }[0], [%0]\"\n+\t   : : \"r\"(dest), \"r\"(reg) : \"memory\", \"v16\", \"v17\", \"v18\");\n+      break;\n+    case AARCH64_RET_S4:\n+      asm (\"ldp q16, q17, [%1]\\n\\t\"\n+\t   \"ldp q18, q19, [%1, #32]\\n\\t\"\n+\t   \"st4 { v16.s, v17.s, v18.s, v19.s }[0], [%0]\"\n+\t   : : \"r\"(dest), \"r\"(reg) : \"memory\", \"v16\", \"v17\", \"v18\", \"v19\");\n+      break;\n+\n+    case AARCH64_RET_D1:\n+      if (dest == reg)\n \t{\n-\t  void *reg = allocate_to_v (context, state);\n-\t  copy_basic_type (reg, memory, type);\n-\t  memory += get_basic_type_size (type);\n+#ifdef __AARCH64EB__\n+\t  dest += 8;\n+#endif\n \t}\n+      else\n+\t*(double *)dest = *(double *)reg;\n+      break;\n+    case AARCH64_RET_D2:\n+      asm (\"ldp q16, q17, [%1]\\n\\t\"\n+\t   \"st2 { v16.d, v17.d }[0], [%0]\"\n+\t   : : \"r\"(dest), \"r\"(reg) : \"memory\", \"v16\", \"v17\");\n+      break;\n+    case AARCH64_RET_D3:\n+      asm (\"ldp q16, q17, [%1]\\n\\t\"\n+\t   \"ldr q18, [%1, #32]\\n\\t\"\n+\t   \"st3 { v16.d, v17.d, v18.d }[0], [%0]\"\n+\t   : : \"r\"(dest), \"r\"(reg) : \"memory\", \"v16\", \"v17\", \"v18\");\n+      break;\n+    case AARCH64_RET_D4:\n+      asm (\"ldp q16, q17, [%1]\\n\\t\"\n+\t   \"ldp q18, q19, [%1, #32]\\n\\t\"\n+\t   \"st4 { v16.d, v17.d, v18.d, v19.d }[0], [%0]\"\n+\t   : : \"r\"(dest), \"r\"(reg) : \"memory\", \"v16\", \"v17\", \"v18\", \"v19\");\n+      break;\n+\n+    default:\n+      if (dest != reg)\n+\treturn memcpy (dest, reg, 16 * (4 - (h & 3)));\n+      break;\n     }\n+  return dest;\n }\n \n /* Either allocate an appropriate register for the argument type, or if\n    none are available, allocate a stack slot and return a pointer\n    to the allocated space.  */\n \n static void *\n-allocate_to_register_or_stack (struct call_context *context,\n-\t\t\t       unsigned char *stack,\n-\t\t\t       struct arg_state *state,\n-\t\t\t       unsigned short type)\n+allocate_int_to_reg_or_stack (struct call_context *context,\n+\t\t\t      struct arg_state *state,\n+\t\t\t      void *stack, size_t size)\n {\n-  size_t alignment = get_basic_type_alignment (type);\n-  size_t size = alignment;\n-  switch (type)\n+  if (state->ngrn < N_X_ARG_REG)\n+    return &context->x[state->ngrn++];\n+\n+  state->ngrn = N_X_ARG_REG;\n+  return allocate_to_stack (state, stack, size, size);\n+}\n+\n+ffi_status\n+ffi_prep_cif_machdep (ffi_cif *cif)\n+{\n+  ffi_type *rtype = cif->rtype;\n+  size_t bytes = cif->bytes;\n+  int flags, i, n;\n+\n+  switch (rtype->type)\n     {\n-    case FFI_TYPE_FLOAT:\n-      /* This is the only case for which the allocated stack size\n-\t should not match the alignment of the type.  */\n-      size = sizeof (UINT32);\n-      /* Fall through.  */\n-    case FFI_TYPE_DOUBLE:\n-      if (state->nsrn < N_V_ARG_REG)\n-\treturn allocate_to_d (context, state);\n-      state->nsrn = N_V_ARG_REG;\n-      break;\n-    case FFI_TYPE_LONGDOUBLE:\n-      if (state->nsrn < N_V_ARG_REG)\n-\treturn allocate_to_v (context, state);\n-      state->nsrn = N_V_ARG_REG;\n+    case FFI_TYPE_VOID:\n+      flags = AARCH64_RET_VOID;\n       break;\n     case FFI_TYPE_UINT8:\n-    case FFI_TYPE_SINT8:\n+      flags = AARCH64_RET_UINT8;\n+      break;\n     case FFI_TYPE_UINT16:\n-    case FFI_TYPE_SINT16:\n+      flags = AARCH64_RET_UINT16;\n+      break;\n     case FFI_TYPE_UINT32:\n-    case FFI_TYPE_SINT32:\n+      flags = AARCH64_RET_UINT32;\n+      break;\n+    case FFI_TYPE_SINT8:\n+      flags = AARCH64_RET_SINT8;\n+      break;\n+    case FFI_TYPE_SINT16:\n+      flags = AARCH64_RET_SINT16;\n+      break;\n     case FFI_TYPE_INT:\n-    case FFI_TYPE_POINTER:\n-    case FFI_TYPE_UINT64:\n+    case FFI_TYPE_SINT32:\n+      flags = AARCH64_RET_SINT32;\n+      break;\n     case FFI_TYPE_SINT64:\n-      if (state->ngrn < N_X_ARG_REG)\n-\treturn allocate_to_x (context, state);\n-      state->ngrn = N_X_ARG_REG;\n+    case FFI_TYPE_UINT64:\n+      flags = AARCH64_RET_INT64;\n       break;\n+    case FFI_TYPE_POINTER:\n+      flags = (sizeof(void *) == 4 ? AARCH64_RET_UINT32 : AARCH64_RET_INT64);\n+      break;\n+\n+    case FFI_TYPE_FLOAT:\n+    case FFI_TYPE_DOUBLE:\n+    case FFI_TYPE_LONGDOUBLE:\n+    case FFI_TYPE_STRUCT:\n+    case FFI_TYPE_COMPLEX:\n+      flags = is_vfp_type (rtype);\n+      if (flags == 0)\n+\t{\n+\t  size_t s = rtype->size;\n+\t  if (s > 16)\n+\t    {\n+\t      flags = AARCH64_RET_VOID | AARCH64_RET_IN_MEM;\n+\t      bytes += 8;\n+\t    }\n+\t  else if (s == 16)\n+\t    flags = AARCH64_RET_INT128;\n+\t  else if (s == 8)\n+\t    flags = AARCH64_RET_INT64;\n+\t  else\n+\t    flags = AARCH64_RET_INT128 | AARCH64_RET_NEED_COPY;\n+\t}\n+      break;\n+\n     default:\n-      FFI_ASSERT (0);\n+      abort();\n     }\n \n-    return allocate_to_stack (state, stack, alignment, size);\n-}\n+  for (i = 0, n = cif->nargs; i < n; i++)\n+    if (is_vfp_type (cif->arg_types[i]))\n+      {\n+\tflags |= AARCH64_FLAG_ARG_V;\n+\tbreak;\n+      }\n \n-/* Copy a value to an appropriate register, or if none are\n-   available, to the stack.  */\n+  /* Round the stack up to a multiple of the stack alignment requirement. */\n+  cif->bytes = ALIGN(bytes, 16);\n+  cif->flags = flags;\n+#if defined (__APPLE__)\n+  cif->aarch64_nfixedargs = 0;\n+#endif\n \n-static void\n-copy_to_register_or_stack (struct call_context *context,\n-\t\t\t   unsigned char *stack,\n-\t\t\t   struct arg_state *state,\n-\t\t\t   void *value,\n-\t\t\t   unsigned short type)\n+  return FFI_OK;\n+}\n+\n+#if defined (__APPLE__)\n+/* Perform Apple-specific cif processing for variadic calls */\n+ffi_status ffi_prep_cif_machdep_var(ffi_cif *cif,\n+\t\t\t\t    unsigned int nfixedargs,\n+\t\t\t\t    unsigned int ntotalargs)\n {\n-  copy_basic_type (\n-\t  allocate_to_register_or_stack (context, stack, state, type),\n-\t  value,\n-\t  type);\n+  ffi_status status = ffi_prep_cif_machdep (cif);\n+  cif->aarch64_nfixedargs = nfixedargs;\n+  return status;\n }\n+#endif /* __APPLE__ */\n \n-/* Marshall the arguments from FFI representation to procedure call\n-   context and stack.  */\n+extern void ffi_call_SYSV (struct call_context *context, void *frame,\n+\t\t\t   void (*fn)(void), void *rvalue, int flags,\n+\t\t\t   void *closure) FFI_HIDDEN;\n \n-static unsigned\n-aarch64_prep_args (struct call_context *context, unsigned char *stack,\n-\t\t   extended_cif *ecif)\n+/* Call a function with the provided arguments and capture the return\n+   value.  */\n+static void\n+ffi_call_int (ffi_cif *cif, void (*fn)(void), void *orig_rvalue,\n+\t      void **avalue, void *closure)\n {\n-  int i;\n+  struct call_context *context;\n+  void *stack, *frame, *rvalue;\n   struct arg_state state;\n-\n-  arg_init (&state, ALIGN(ecif->cif->bytes, 16));\n-\n-  for (i = 0; i < ecif->cif->nargs; i++)\n+  size_t stack_bytes, rtype_size, rsize;\n+  int i, nargs, flags;\n+  ffi_type *rtype;\n+\n+  flags = cif->flags;\n+  rtype = cif->rtype;\n+  rtype_size = rtype->size;\n+  stack_bytes = cif->bytes;\n+\n+  /* If the target function returns a structure via hidden pointer,\n+     then we cannot allow a null rvalue.  Otherwise, mash a null\n+     rvalue to void return type.  */\n+  rsize = 0;\n+  if (flags & AARCH64_RET_IN_MEM)\n+    {\n+      if (orig_rvalue == NULL)\n+\trsize = rtype_size;\n+    }\n+  else if (orig_rvalue == NULL)\n+    flags &= AARCH64_FLAG_ARG_V;\n+  else if (flags & AARCH64_RET_NEED_COPY)\n+    rsize = 16;\n+\n+  /* Allocate consectutive stack for everything we'll need.  */\n+  context = alloca (sizeof(struct call_context) + stack_bytes + 32 + rsize);\n+  stack = context + 1;\n+  frame = stack + stack_bytes;\n+  rvalue = (rsize ? frame + 32 : orig_rvalue);\n+\n+  arg_init (&state);\n+  for (i = 0, nargs = cif->nargs; i < nargs; i++)\n     {\n-      ffi_type *ty = ecif->cif->arg_types[i];\n-      switch (ty->type)\n+      ffi_type *ty = cif->arg_types[i];\n+      size_t s = ty->size;\n+      void *a = avalue[i];\n+      int h, t;\n+\n+      t = ty->type;\n+      switch (t)\n \t{\n \tcase FFI_TYPE_VOID:\n \t  FFI_ASSERT (0);\n \t  break;\n \n \t/* If the argument is a basic type the argument is allocated to an\n \t   appropriate register, or if none are available, to the stack.  */\n-\tcase FFI_TYPE_FLOAT:\n-\tcase FFI_TYPE_DOUBLE:\n-\tcase FFI_TYPE_LONGDOUBLE:\n+\tcase FFI_TYPE_INT:\n \tcase FFI_TYPE_UINT8:\n \tcase FFI_TYPE_SINT8:\n \tcase FFI_TYPE_UINT16:\n \tcase FFI_TYPE_SINT16:\n \tcase FFI_TYPE_UINT32:\n-\tcase FFI_TYPE_INT:\n \tcase FFI_TYPE_SINT32:\n-\tcase FFI_TYPE_POINTER:\n \tcase FFI_TYPE_UINT64:\n \tcase FFI_TYPE_SINT64:\n-\t  copy_to_register_or_stack (context, stack, &state,\n-\t\t\t\t     ecif->avalue[i], ty->type);\n+\tcase FFI_TYPE_POINTER:\n+\tdo_pointer:\n+\t  {\n+\t    ffi_arg ext = extend_integer_type (a, t);\n+\t    if (state.ngrn < N_X_ARG_REG)\n+\t      context->x[state.ngrn++] = ext;\n+\t    else\n+\t      {\n+\t\tvoid *d = allocate_to_stack (&state, stack, ty->alignment, s);\n+\t\tstate.ngrn = N_X_ARG_REG;\n+\t\t/* Note that the default abi extends each argument\n+\t\t   to a full 64-bit slot, while the iOS abi allocates\n+\t\t   only enough space. */\n+#ifdef __APPLE__\n+\t\tmemcpy(d, a, s);\n+#else\n+\t\t*(ffi_arg *)d = ext;\n+#endif\n+\t      }\n+\t  }\n \t  break;\n \n+\tcase FFI_TYPE_FLOAT:\n+\tcase FFI_TYPE_DOUBLE:\n+\tcase FFI_TYPE_LONGDOUBLE:\n \tcase FFI_TYPE_STRUCT:\n-\t  if (is_hfa (ty))\n-\t    {\n-\t      copy_hfa_to_reg_or_stack (ecif->avalue[i], ty, context,\n-\t\t\t\t\tstack, &state);\n-\t    }\n-\t  else if (ty->size > 16)\n-\t    {\n-\t      /* If the argument is a composite type that is larger than 16\n-\t\t bytes, then the argument has been copied to memory, and\n-\t\t the argument is replaced by a pointer to the copy.  */\n+\tcase FFI_TYPE_COMPLEX:\n+\t  {\n+\t    void *dest;\n \n-\t      copy_to_register_or_stack (context, stack, &state,\n-\t\t\t\t\t &(ecif->avalue[i]), FFI_TYPE_POINTER);\n-\t    }\n-\t  else if (available_x (&state) >= (ty->size + 7) / 8)\n-\t    {\n-\t      /* If the argument is a composite type and the size in\n-\t\t double-words is not more than the number of available\n-\t\t X registers, then the argument is copied into consecutive\n-\t\t X registers.  */\n-\t      int j;\n-\t      for (j = 0; j < (ty->size + 7) / 8; j++)\n-\t\t{\n-\t\t  memcpy (allocate_to_x (context, &state),\n-\t\t\t  &(((UINT64 *) ecif->avalue[i])[j]),\n-\t\t\t  sizeof (UINT64));\n+\t    h = is_vfp_type (ty);\n+\t    if (h)\n+\t      {\n+\t\tint elems = 4 - (h & 3);\n+\t        if (state.nsrn + elems <= N_V_ARG_REG)\n+\t\t  {\n+\t\t    dest = &context->v[state.nsrn];\n+\t\t    state.nsrn += elems;\n+\t\t    extend_hfa_type (dest, a, h);\n+\t\t    break;\n+\t\t  }\n+\t\tstate.nsrn = N_V_ARG_REG;\n+\t\tdest = allocate_to_stack (&state, stack, ty->alignment, s);\n+\t      }\n+\t    else if (s > 16)\n+\t      {\n+\t\t/* If the argument is a composite type that is larger than 16\n+\t\t   bytes, then the argument has been copied to memory, and\n+\t\t   the argument is replaced by a pointer to the copy.  */\n+\t\ta = &avalue[i];\n+\t\tt = FFI_TYPE_POINTER;\n+\t\tgoto do_pointer;\n+\t      }\n+\t    else\n+\t      {\n+\t\tsize_t n = (s + 7) / 8;\n+\t\tif (state.ngrn + n <= N_X_ARG_REG)\n+\t\t  {\n+\t\t    /* If the argument is a composite type and the size in\n+\t\t       double-words is not more than the number of available\n+\t\t       X registers, then the argument is copied into\n+\t\t       consecutive X registers.  */\n+\t\t    dest = &context->x[state.ngrn];\n+\t\t    state.ngrn += n;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    /* Otherwise, there are insufficient X registers. Further\n+\t\t       X register allocations are prevented, the NSAA is\n+\t\t       adjusted and the argument is copied to memory at the\n+\t\t       adjusted NSAA.  */\n+\t\t    state.ngrn = N_X_ARG_REG;\n+\t\t    dest = allocate_to_stack (&state, stack, ty->alignment, s);\n+\t\t  }\n \t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Otherwise, there are insufficient X registers. Further X\n-\t\t register allocations are prevented, the NSAA is adjusted\n-\t\t (by allocate_to_stack ()) and the argument is copied to\n-\t\t memory at the adjusted NSAA.  */\n-\t      state.ngrn = N_X_ARG_REG;\n-\n-\t      memcpy (allocate_to_stack (&state, stack, ty->alignment,\n-\t\t\t\t\t ty->size), ecif->avalue + i, ty->size);\n+\t      memcpy (dest, a, s);\n \t    }\n \t  break;\n \n \tdefault:\n-\t  FFI_ASSERT (0);\n-\t  break;\n+\t  abort();\n \t}\n+\n+#if defined (__APPLE__)\n+      if (i + 1 == cif->aarch64_nfixedargs)\n+\t{\n+\t  state.ngrn = N_X_ARG_REG;\n+\t  state.nsrn = N_V_ARG_REG;\n+\t  state.allocating_variadic = 1;\n+\t}\n+#endif\n     }\n \n-  return ecif->cif->aarch64_flags;\n+  ffi_call_SYSV (context, frame, fn, rvalue, flags, closure);\n+\n+  if (flags & AARCH64_RET_NEED_COPY)\n+    memcpy (orig_rvalue, rvalue, rtype_size);\n }\n \n-ffi_status\n-ffi_prep_cif_machdep (ffi_cif *cif)\n+void\n+ffi_call (ffi_cif *cif, void (*fn) (void), void *rvalue, void **avalue)\n {\n-  /* Round the stack up to a multiple of the stack alignment requirement. */\n-  cif->bytes =\n-    (cif->bytes + (AARCH64_STACK_ALIGN - 1)) & ~ (AARCH64_STACK_ALIGN - 1);\n-\n-  /* Initialize our flags. We are interested if this CIF will touch a\n-     vector register, if so we will enable context save and load to\n-     those registers, otherwise not. This is intended to be friendly\n-     to lazy float context switching in the kernel.  */\n-  cif->aarch64_flags = 0;\n-\n-  if (is_v_register_candidate (cif->rtype))\n-    {\n-      cif->aarch64_flags |= AARCH64_FFI_WITH_V;\n-    }\n-  else\n-    {\n-      int i;\n-      for (i = 0; i < cif->nargs; i++)\n-        if (is_v_register_candidate (cif->arg_types[i]))\n-          {\n-            cif->aarch64_flags |= AARCH64_FFI_WITH_V;\n-            break;\n-          }\n-    }\n-\n-  return FFI_OK;\n+  ffi_call_int (cif, fn, rvalue, avalue, NULL);\n }\n \n-/* Call a function with the provided arguments and capture the return\n-   value.  */\n+#ifdef FFI_GO_CLOSURES\n void\n-ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n+ffi_call_go (ffi_cif *cif, void (*fn) (void), void *rvalue,\n+\t     void **avalue, void *closure)\n {\n-  extended_cif ecif;\n+  ffi_call_int (cif, fn, rvalue, avalue, closure);\n+}\n+#endif /* FFI_GO_CLOSURES */\n \n-  ecif.cif = cif;\n-  ecif.avalue = avalue;\n-  ecif.rvalue = rvalue;\n+/* Build a trampoline.  */\n \n-  switch (cif->abi)\n-    {\n-    case FFI_SYSV:\n-      {\n-        struct call_context context;\n-\tunsigned stack_bytes;\n+extern void ffi_closure_SYSV (void) FFI_HIDDEN;\n+extern void ffi_closure_SYSV_V (void) FFI_HIDDEN;\n \n-\t/* Figure out the total amount of stack space we need, the\n-\t   above call frame space needs to be 16 bytes aligned to\n-\t   ensure correct alignment of the first object inserted in\n-\t   that space hence the ALIGN applied to cif->bytes.*/\n-\tstack_bytes = ALIGN(cif->bytes, 16);\n+ffi_status\n+ffi_prep_closure_loc (ffi_closure *closure,\n+                      ffi_cif* cif,\n+                      void (*fun)(ffi_cif*,void*,void**,void*),\n+                      void *user_data,\n+                      void *codeloc)\n+{\n+  static const unsigned char trampoline[16] = {\n+    0x90, 0x00, 0x00, 0x58,\t/* ldr\tx16, tramp+16\t*/\n+    0xf1, 0xff, 0xff, 0x10,\t/* adr\tx17, tramp+0\t*/\n+    0x00, 0x02, 0x1f, 0xd6\t/* br\tx16\t\t*/\n+  };\n+  char *tramp = closure->tramp;\n+  void (*start)(void);\n \n-\tmemset (&context, 0, sizeof (context));\n-        if (is_register_candidate (cif->rtype))\n-          {\n-            ffi_call_SYSV (aarch64_prep_args, &context, &ecif, stack_bytes, fn);\n-            switch (cif->rtype->type)\n-              {\n-              case FFI_TYPE_VOID:\n-              case FFI_TYPE_FLOAT:\n-              case FFI_TYPE_DOUBLE:\n-              case FFI_TYPE_LONGDOUBLE:\n-              case FFI_TYPE_UINT8:\n-              case FFI_TYPE_SINT8:\n-              case FFI_TYPE_UINT16:\n-              case FFI_TYPE_SINT16:\n-              case FFI_TYPE_UINT32:\n-              case FFI_TYPE_SINT32:\n-              case FFI_TYPE_POINTER:\n-              case FFI_TYPE_UINT64:\n-              case FFI_TYPE_INT:\n-              case FFI_TYPE_SINT64:\n-\t\t{\n-\t\t  void *addr = get_basic_type_addr (cif->rtype->type,\n-\t\t\t\t\t\t    &context, 0);\n-\t\t  copy_basic_type (rvalue, addr, cif->rtype->type);\n-\t\t  break;\n-\t\t}\n+  if (cif->abi != FFI_SYSV)\n+    return FFI_BAD_ABI;\n \n-              case FFI_TYPE_STRUCT:\n-                if (is_hfa (cif->rtype))\n-\t\t  {\n-\t\t    int j;\n-\t\t    unsigned short type = get_homogeneous_type (cif->rtype);\n-\t\t    unsigned elems = element_count (cif->rtype);\n-\t\t    for (j = 0; j < elems; j++)\n-\t\t      {\n-\t\t\tvoid *reg = get_basic_type_addr (type, &context, j);\n-\t\t\tcopy_basic_type (rvalue, reg, type);\n-\t\t\trvalue += get_basic_type_size (type);\n-\t\t      }\n-\t\t  }\n-                else if ((cif->rtype->size + 7) / 8 < N_X_ARG_REG)\n-                  {\n-                    unsigned size = ALIGN (cif->rtype->size, sizeof (UINT64));\n-                    memcpy (rvalue, get_x_addr (&context, 0), size);\n-                  }\n-                else\n-                  {\n-                    FFI_ASSERT (0);\n-                  }\n-                break;\n-\n-              default:\n-                FFI_ASSERT (0);\n-                break;\n-              }\n-          }\n-        else\n-          {\n-            memcpy (get_x_addr (&context, 8), &rvalue, sizeof (UINT64));\n-            ffi_call_SYSV (aarch64_prep_args, &context, &ecif,\n-\t\t\t   stack_bytes, fn);\n-          }\n-        break;\n-      }\n+  closure->cif = cif;\n+  closure->fun = fun;\n+  closure->user_data = user_data;\n \n-    default:\n-      FFI_ASSERT (0);\n-      break;\n-    }\n-}\n+  memcpy (tramp, trampoline, sizeof(trampoline));\n \n-static unsigned char trampoline [] =\n-{ 0x70, 0x00, 0x00, 0x58,\t/* ldr\tx16, 1f\t*/\n-  0x91, 0x00, 0x00, 0x10,\t/* adr\tx17, 2f\t*/\n-  0x00, 0x02, 0x1f, 0xd6\t/* br\tx16\t*/\n-};\n+  if (cif->flags & AARCH64_FLAG_ARG_V)\n+    start = ffi_closure_SYSV_V;\n+  else\n+    start = ffi_closure_SYSV;\n+  *(UINT64 *)(tramp + 16) = (uintptr_t)start;\n \n-/* Build a trampoline.  */\n+  ffi_clear_cache(tramp, tramp + FFI_TRAMPOLINE_SIZE);\n+\n+  return FFI_OK;\n+}\n \n-#define FFI_INIT_TRAMPOLINE(TRAMP,FUN,CTX,FLAGS)\t\t\t\\\n-  ({unsigned char *__tramp = (unsigned char*)(TRAMP);\t\t\t\\\n-    UINT64  __fun = (UINT64)(FUN);\t\t\t\t\t\\\n-    UINT64  __ctx = (UINT64)(CTX);\t\t\t\t\t\\\n-    UINT64  __flags = (UINT64)(FLAGS);\t\t\t\t\t\\\n-    memcpy (__tramp, trampoline, sizeof (trampoline));\t\t\t\\\n-    memcpy (__tramp + 12, &__fun, sizeof (__fun));\t\t\t\\\n-    memcpy (__tramp + 20, &__ctx, sizeof (__ctx));\t\t\t\\\n-    memcpy (__tramp + 28, &__flags, sizeof (__flags));\t\t\t\\\n-    __clear_cache(__tramp, __tramp + FFI_TRAMPOLINE_SIZE);\t\t\\\n-  })\n+#ifdef FFI_GO_CLOSURES\n+extern void ffi_go_closure_SYSV (void) FFI_HIDDEN;\n+extern void ffi_go_closure_SYSV_V (void) FFI_HIDDEN;\n \n ffi_status\n-ffi_prep_closure_loc (ffi_closure* closure,\n-                      ffi_cif* cif,\n-                      void (*fun)(ffi_cif*,void*,void**,void*),\n-                      void *user_data,\n-                      void *codeloc)\n+ffi_prep_go_closure (ffi_go_closure *closure, ffi_cif* cif,\n+                     void (*fun)(ffi_cif*,void*,void**,void*))\n {\n+  void (*start)(void);\n+\n   if (cif->abi != FFI_SYSV)\n     return FFI_BAD_ABI;\n \n-  FFI_INIT_TRAMPOLINE (&closure->tramp[0], &ffi_closure_SYSV, codeloc,\n-\t\t       cif->aarch64_flags);\n+  if (cif->flags & AARCH64_FLAG_ARG_V)\n+    start = ffi_go_closure_SYSV_V;\n+  else\n+    start = ffi_go_closure_SYSV;\n \n-  closure->cif  = cif;\n-  closure->user_data = user_data;\n-  closure->fun  = fun;\n+  closure->tramp = start;\n+  closure->cif = cif;\n+  closure->fun = fun;\n \n   return FFI_OK;\n }\n+#endif /* FFI_GO_CLOSURES */\n \n /* Primary handler to setup and invoke a function within a closure.\n \n@@ -857,220 +796,115 @@ ffi_prep_closure_loc (ffi_closure* closure,\n    the stack at the point ffi_closure_SYSV() was invoked.\n \n    On the return path the assembler wrapper will reload call context\n-   regsiters.\n+   registers.\n \n    ffi_closure_SYSV_inner() marshalls the call context into ffi value\n-   desriptors, invokes the wrapped function, then marshalls the return\n+   descriptors, invokes the wrapped function, then marshalls the return\n    value back into the call context.  */\n \n-void\n-ffi_closure_SYSV_inner (ffi_closure *closure, struct call_context *context,\n-\t\t\tvoid *stack)\n+int FFI_HIDDEN\n+ffi_closure_SYSV_inner (ffi_cif *cif,\n+\t\t\tvoid (*fun)(ffi_cif*,void*,void**,void*),\n+\t\t\tvoid *user_data,\n+\t\t\tstruct call_context *context,\n+\t\t\tvoid *stack, void *rvalue, void *struct_rvalue)\n {\n-  ffi_cif *cif = closure->cif;\n   void **avalue = (void**) alloca (cif->nargs * sizeof (void*));\n-  void *rvalue = NULL;\n-  int i;\n+  int i, h, nargs, flags;\n   struct arg_state state;\n \n-  arg_init (&state, ALIGN(cif->bytes, 16));\n+  arg_init (&state);\n \n-  for (i = 0; i < cif->nargs; i++)\n+  for (i = 0, nargs = cif->nargs; i < nargs; i++)\n     {\n       ffi_type *ty = cif->arg_types[i];\n+      int t = ty->type;\n+      size_t n, s = ty->size;\n \n-      switch (ty->type)\n+      switch (t)\n \t{\n \tcase FFI_TYPE_VOID:\n \t  FFI_ASSERT (0);\n \t  break;\n \n+\tcase FFI_TYPE_INT:\n \tcase FFI_TYPE_UINT8:\n \tcase FFI_TYPE_SINT8:\n \tcase FFI_TYPE_UINT16:\n \tcase FFI_TYPE_SINT16:\n \tcase FFI_TYPE_UINT32:\n \tcase FFI_TYPE_SINT32:\n-\tcase FFI_TYPE_INT:\n-\tcase FFI_TYPE_POINTER:\n \tcase FFI_TYPE_UINT64:\n \tcase FFI_TYPE_SINT64:\n-\tcase  FFI_TYPE_FLOAT:\n-\tcase  FFI_TYPE_DOUBLE:\n-\tcase  FFI_TYPE_LONGDOUBLE:\n-\t  avalue[i] = allocate_to_register_or_stack (context, stack,\n-\t\t\t\t\t\t     &state, ty->type);\n+\tcase FFI_TYPE_POINTER:\n+\t  avalue[i] = allocate_int_to_reg_or_stack (context, &state, stack, s);\n \t  break;\n \n+\tcase FFI_TYPE_FLOAT:\n+\tcase FFI_TYPE_DOUBLE:\n+\tcase FFI_TYPE_LONGDOUBLE:\n \tcase FFI_TYPE_STRUCT:\n-\t  if (is_hfa (ty))\n+\tcase FFI_TYPE_COMPLEX:\n+\t  h = is_vfp_type (ty);\n+\t  if (h)\n \t    {\n-\t      unsigned n = element_count (ty);\n-\t      if (available_v (&state) < n)\n+\t      n = 4 - (h & 3);\n+\t      if (state.nsrn + n <= N_V_ARG_REG)\n \t\t{\n-\t\t  state.nsrn = N_V_ARG_REG;\n-\t\t  avalue[i] = allocate_to_stack (&state, stack, ty->alignment,\n-\t\t\t\t\t\t ty->size);\n+\t\t  void *reg = &context->v[state.nsrn];\n+\t\t  state.nsrn += n;\n+\n+\t\t  /* Eeek! We need a pointer to the structure, however the\n+\t\t     homogeneous float elements are being passed in individual\n+\t\t     registers, therefore for float and double the structure\n+\t\t     is not represented as a contiguous sequence of bytes in\n+\t\t     our saved register context.  We don't need the original\n+\t\t     contents of the register storage, so we reformat the\n+\t\t     structure into the same memory.  */\n+\t\t  avalue[i] = compress_hfa_type (reg, reg, h);\n \t\t}\n \t      else\n \t\t{\n-\t\t  switch (get_homogeneous_type (ty))\n-\t\t    {\n-\t\t    case FFI_TYPE_FLOAT:\n-\t\t      {\n-\t\t\t/* Eeek! We need a pointer to the structure,\n-\t\t\t   however the homogeneous float elements are\n-\t\t\t   being passed in individual S registers,\n-\t\t\t   therefore the structure is not represented as\n-\t\t\t   a contiguous sequence of bytes in our saved\n-\t\t\t   register context. We need to fake up a copy\n-\t\t\t   of the structure layed out in memory\n-\t\t\t   correctly. The fake can be tossed once the\n-\t\t\t   closure function has returned hence alloca()\n-\t\t\t   is sufficient. */\n-\t\t\tint j;\n-\t\t\tUINT32 *p = avalue[i] = alloca (ty->size);\n-\t\t\tfor (j = 0; j < element_count (ty); j++)\n-\t\t\t  memcpy (&p[j],\n-\t\t\t\t  allocate_to_s (context, &state),\n-\t\t\t\t  sizeof (*p));\n-\t\t\tbreak;\n-\t\t      }\n-\n-\t\t    case FFI_TYPE_DOUBLE:\n-\t\t      {\n-\t\t\t/* Eeek! We need a pointer to the structure,\n-\t\t\t   however the homogeneous float elements are\n-\t\t\t   being passed in individual S registers,\n-\t\t\t   therefore the structure is not represented as\n-\t\t\t   a contiguous sequence of bytes in our saved\n-\t\t\t   register context. We need to fake up a copy\n-\t\t\t   of the structure layed out in memory\n-\t\t\t   correctly. The fake can be tossed once the\n-\t\t\t   closure function has returned hence alloca()\n-\t\t\t   is sufficient. */\n-\t\t\tint j;\n-\t\t\tUINT64 *p = avalue[i] = alloca (ty->size);\n-\t\t\tfor (j = 0; j < element_count (ty); j++)\n-\t\t\t  memcpy (&p[j],\n-\t\t\t\t  allocate_to_d (context, &state),\n-\t\t\t\t  sizeof (*p));\n-\t\t\tbreak;\n-\t\t      }\n-\n-\t\t    case FFI_TYPE_LONGDOUBLE:\n-\t\t\t  memcpy (&avalue[i],\n-\t\t\t\t  allocate_to_v (context, &state),\n-\t\t\t\t  sizeof (*avalue));\n-\t\t      break;\n-\n-\t\t    default:\n-\t\t      FFI_ASSERT (0);\n-\t\t      break;\n-\t\t    }\n+\t\t  state.nsrn = N_V_ARG_REG;\n+\t\t  avalue[i] = allocate_to_stack (&state, stack,\n+\t\t\t\t\t\t ty->alignment, s);\n \t\t}\n \t    }\n-\t  else if (ty->size > 16)\n+\t  else if (s > 16)\n \t    {\n \t      /* Replace Composite type of size greater than 16 with a\n \t\t pointer.  */\n-\t      memcpy (&avalue[i],\n-\t\t      allocate_to_register_or_stack (context, stack,\n-\t\t\t\t\t\t     &state, FFI_TYPE_POINTER),\n-\t\t      sizeof (avalue[i]));\n-\t    }\n-\t  else if (available_x (&state) >= (ty->size + 7) / 8)\n-\t    {\n-\t      avalue[i] = get_x_addr (context, state.ngrn);\n-\t      state.ngrn += (ty->size + 7) / 8;\n+\t      avalue[i] = *(void **)\n+\t\tallocate_int_to_reg_or_stack (context, &state, stack,\n+\t\t\t\t\t      sizeof (void *));\n \t    }\n \t  else\n \t    {\n-\t      state.ngrn = N_X_ARG_REG;\n-\n-\t      avalue[i] = allocate_to_stack (&state, stack, ty->alignment,\n-\t\t\t\t\t     ty->size);\n+\t      n = (s + 7) / 8;\n+\t      if (state.ngrn + n <= N_X_ARG_REG)\n+\t\t{\n+\t\t  avalue[i] = &context->x[state.ngrn];\n+\t\t  state.ngrn += n;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  state.ngrn = N_X_ARG_REG;\n+\t\t  avalue[i] = allocate_to_stack (&state, stack,\n+\t\t\t\t\t\t ty->alignment, s);\n+\t\t}\n \t    }\n \t  break;\n \n \tdefault:\n-\t  FFI_ASSERT (0);\n-\t  break;\n+\t  abort();\n \t}\n     }\n \n-  /* Figure out where the return value will be passed, either in\n-     registers or in a memory block allocated by the caller and passed\n-     in x8.  */\n+  flags = cif->flags;\n+  if (flags & AARCH64_RET_IN_MEM)\n+    rvalue = struct_rvalue;\n \n-  if (is_register_candidate (cif->rtype))\n-    {\n-      /* Register candidates are *always* returned in registers. */\n-\n-      /* Allocate a scratchpad for the return value, we will let the\n-         callee scrible the result into the scratch pad then move the\n-         contents into the appropriate return value location for the\n-         call convention.  */\n-      rvalue = alloca (cif->rtype->size);\n-      (closure->fun) (cif, rvalue, avalue, closure->user_data);\n-\n-      /* Copy the return value into the call context so that it is returned\n-         as expected to our caller.  */\n-      switch (cif->rtype->type)\n-        {\n-        case FFI_TYPE_VOID:\n-          break;\n-\n-        case FFI_TYPE_UINT8:\n-        case FFI_TYPE_UINT16:\n-        case FFI_TYPE_UINT32:\n-        case FFI_TYPE_POINTER:\n-        case FFI_TYPE_UINT64:\n-        case FFI_TYPE_SINT8:\n-        case FFI_TYPE_SINT16:\n-        case FFI_TYPE_INT:\n-        case FFI_TYPE_SINT32:\n-        case FFI_TYPE_SINT64:\n-        case FFI_TYPE_FLOAT:\n-        case FFI_TYPE_DOUBLE:\n-        case FFI_TYPE_LONGDOUBLE:\n-\t  {\n-\t    void *addr = get_basic_type_addr (cif->rtype->type, context, 0);\n-\t    copy_basic_type (addr, rvalue, cif->rtype->type);\n-            break;\n-\t  }\n-        case FFI_TYPE_STRUCT:\n-          if (is_hfa (cif->rtype))\n-\t    {\n-\t      int i;\n-\t      unsigned short type = get_homogeneous_type (cif->rtype);\n-\t      unsigned elems = element_count (cif->rtype);\n-\t      for (i = 0; i < elems; i++)\n-\t\t{\n-\t\t  void *reg = get_basic_type_addr (type, context, i);\n-\t\t  copy_basic_type (reg, rvalue, type);\n-\t\t  rvalue += get_basic_type_size (type);\n-\t\t}\n-\t    }\n-          else if ((cif->rtype->size + 7) / 8 < N_X_ARG_REG)\n-            {\n-              unsigned size = ALIGN (cif->rtype->size, sizeof (UINT64)) ;\n-              memcpy (get_x_addr (context, 0), rvalue, size);\n-            }\n-          else\n-            {\n-              FFI_ASSERT (0);\n-            }\n-          break;\n-        default:\n-          FFI_ASSERT (0);\n-          break;\n-        }\n-    }\n-  else\n-    {\n-      memcpy (&rvalue, get_x_addr (context, 8), sizeof (UINT64));\n-      (closure->fun) (cif, rvalue, avalue, closure->user_data);\n-    }\n-}\n+  fun (cif, rvalue, avalue, user_data);\n \n+  return flags;\n+}"}, {"sha": "80d09af16812f754cf4270e565216a205b214908", "filename": "libffi/src/aarch64/ffitarget.h", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Faarch64%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Faarch64%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Faarch64%2Fffitarget.h?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -42,18 +42,20 @@ typedef enum ffi_abi\n /* ---- Definitions for closures ----------------------------------------- */\n \n #define FFI_CLOSURES 1\n-#define FFI_TRAMPOLINE_SIZE 36\n+#define FFI_TRAMPOLINE_SIZE 24\n #define FFI_NATIVE_RAW_API 0\n \n /* ---- Internal ---- */\n \n+#if defined (__APPLE__)\n+#define FFI_TARGET_SPECIFIC_VARIADIC\n+#define FFI_EXTRA_CIF_FIELDS unsigned aarch64_nfixedargs\n+#else\n+/* iOS reserves x18 for the system.  Disable Go closures until\n+   a new static chain is chosen.  */\n+#define FFI_GO_CLOSURES 1\n+#endif\n \n-#define FFI_EXTRA_CIF_FIELDS unsigned aarch64_flags\n-\n-#define AARCH64_FFI_WITH_V_BIT 0\n-\n-#define AARCH64_N_XREG 32\n-#define AARCH64_N_VREG 32\n-#define AARCH64_CALL_CONTEXT_SIZE (AARCH64_N_XREG * 8 + AARCH64_N_VREG * 16)\n+#define FFI_TARGET_HAS_COMPLEX_TYPE\n \n #endif"}, {"sha": "9c3e07725a0583e472fd4e72c2f909cc837da429", "filename": "libffi/src/aarch64/internal.h", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Faarch64%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Faarch64%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Faarch64%2Finternal.h?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -0,0 +1,67 @@\n+/* \n+Permission is hereby granted, free of charge, to any person obtaining\n+a copy of this software and associated documentation files (the\n+``Software''), to deal in the Software without restriction, including\n+without limitation the rights to use, copy, modify, merge, publish,\n+distribute, sublicense, and/or sell copies of the Software, and to\n+permit persons to whom the Software is furnished to do so, subject to\n+the following conditions:\n+\n+The above copyright notice and this permission notice shall be\n+included in all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */\n+\n+#define AARCH64_RET_VOID\t0\n+#define AARCH64_RET_INT64\t1\n+#define AARCH64_RET_INT128\t2\n+\n+#define AARCH64_RET_UNUSED3\t3\n+#define AARCH64_RET_UNUSED4\t4\n+#define AARCH64_RET_UNUSED5\t5\n+#define AARCH64_RET_UNUSED6\t6\n+#define AARCH64_RET_UNUSED7\t7\n+\n+/* Note that FFI_TYPE_FLOAT == 2, _DOUBLE == 3, _LONGDOUBLE == 4,\n+   so _S4 through _Q1 are layed out as (TYPE * 4) + (4 - COUNT).  */\n+#define AARCH64_RET_S4\t\t8\n+#define AARCH64_RET_S3\t\t9\n+#define AARCH64_RET_S2\t\t10\n+#define AARCH64_RET_S1\t\t11\n+\n+#define AARCH64_RET_D4\t\t12\n+#define AARCH64_RET_D3\t\t13\n+#define AARCH64_RET_D2\t\t14\n+#define AARCH64_RET_D1\t\t15\n+\n+#define AARCH64_RET_Q4\t\t16\n+#define AARCH64_RET_Q3\t\t17\n+#define AARCH64_RET_Q2\t\t18\n+#define AARCH64_RET_Q1\t\t19\n+\n+/* Note that each of the sub-64-bit integers gets two entries.  */\n+#define AARCH64_RET_UINT8\t20\n+#define AARCH64_RET_UINT16\t22\n+#define AARCH64_RET_UINT32\t24\n+\n+#define AARCH64_RET_SINT8\t26\n+#define AARCH64_RET_SINT16\t28\n+#define AARCH64_RET_SINT32\t30\n+\n+#define AARCH64_RET_MASK\t31\n+\n+#define AARCH64_RET_IN_MEM\t(1 << 5)\n+#define AARCH64_RET_NEED_COPY\t(1 << 6)\n+\n+#define AARCH64_FLAG_ARG_V_BIT\t7\n+#define AARCH64_FLAG_ARG_V\t(1 << AARCH64_FLAG_ARG_V_BIT)\n+\n+#define N_X_ARG_REG\t\t8\n+#define N_V_ARG_REG\t\t8\n+#define CALL_CONTEXT_SIZE\t(N_V_ARG_REG * 16 + N_X_ARG_REG * 8)"}, {"sha": "5c9cdda18c5e1173821e839c8a17beeb01f00c57", "filename": "libffi/src/aarch64/sysv.S", "status": "modified", "additions": 358, "deletions": 262, "changes": 620, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Faarch64%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Faarch64%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Faarch64%2Fsysv.S?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -22,286 +22,382 @@ SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */\n #define LIBFFI_ASM\n #include <fficonfig.h>\n #include <ffi.h>\n-\n-#define cfi_adjust_cfa_offset(off)\t.cfi_adjust_cfa_offset off\n-#define cfi_rel_offset(reg, off)\t.cfi_rel_offset reg, off\n-#define cfi_restore(reg)\t\t.cfi_restore reg\n-#define cfi_def_cfa_register(reg)\t.cfi_def_cfa_register reg\n-\n-        .text\n-        .globl ffi_call_SYSV\n-        .type ffi_call_SYSV, #function\n-\n-/* ffi_call_SYSV()\n-\n-   Create a stack frame, setup an argument context, call the callee\n-   and extract the result.\n-\n-   The maximum required argument stack size is provided,\n-   ffi_call_SYSV() allocates that stack space then calls the\n-   prepare_fn to populate register context and stack.  The\n-   argument passing registers are loaded from the register\n-   context and the callee called, on return the register passing\n-   register are saved back to the context.  Our caller will\n-   extract the return value from the final state of the saved\n-   register context.\n-\n-   Prototype:\n-\n-   extern unsigned\n-   ffi_call_SYSV (void (*)(struct call_context *context, unsigned char *,\n-\t\t\t   extended_cif *),\n-                  struct call_context *context,\n-                  extended_cif *,\n-                  unsigned required_stack_size,\n-                  void (*fn)(void));\n+#include <ffi_cfi.h>\n+#include \"internal.h\"\n+\n+#ifdef HAVE_MACHINE_ASM_H\n+#include <machine/asm.h>\n+#else\n+#ifdef __USER_LABEL_PREFIX__\n+#define CONCAT1(a, b) CONCAT2(a, b)\n+#define CONCAT2(a, b) a ## b\n+\n+/* Use the right prefix for global labels.  */\n+#define CNAME(x) CONCAT1 (__USER_LABEL_PREFIX__, x)\n+#else\n+#define CNAME(x) x\n+#endif\n+#endif\n+\n+#ifdef __AARCH64EB__\n+# define BE(X)\tX\n+#else\n+# define BE(X)\t0\n+#endif\n+\n+\t.text\n+\t.align 4\n+\n+/* ffi_call_SYSV\n+   extern void ffi_call_SYSV (void *stack, void *frame,\n+\t\t\t      void (*fn)(void), void *rvalue,\n+\t\t\t      int flags, void *closure);\n \n    Therefore on entry we have:\n \n-   x0 prepare_fn\n-   x1 &context\n-   x2 &ecif\n-   x3 bytes\n-   x4 fn\n-\n-   This function uses the following stack frame layout:\n-\n-   ==\n-                saved x30(lr)\n-   x29(fp)->    saved x29(fp)\n-                saved x24\n-                saved x23\n-                saved x22\n-   sp'    ->    saved x21\n-                ...\n-   sp     ->    (constructed callee stack arguments)\n-   ==\n-\n-   Voila! */\n-\n-#define ffi_call_SYSV_FS (8 * 4)\n-\n-        .cfi_startproc\n-ffi_call_SYSV:\n-        stp     x29, x30, [sp, #-16]!\n-\tcfi_adjust_cfa_offset (16)\n-        cfi_rel_offset (x29, 0)\n-        cfi_rel_offset (x30, 8)\n-\n-        mov     x29, sp\n-\tcfi_def_cfa_register (x29)\n-        sub     sp, sp, #ffi_call_SYSV_FS\n-\n-        stp     x21, x22, [sp, 0]\n-        cfi_rel_offset (x21, 0 - ffi_call_SYSV_FS)\n-        cfi_rel_offset (x22, 8 - ffi_call_SYSV_FS)\n-\n-        stp     x23, x24, [sp, 16]\n-        cfi_rel_offset (x23, 16 - ffi_call_SYSV_FS)\n-        cfi_rel_offset (x24, 24 - ffi_call_SYSV_FS)\n-\n-        mov     x21, x1\n-        mov     x22, x2\n-        mov     x24, x4\n-\n-        /* Allocate the stack space for the actual arguments, many\n-           arguments will be passed in registers, but we assume\n-           worst case and allocate sufficient stack for ALL of\n-           the arguments.  */\n-        sub     sp, sp, x3\n-\n-        /* unsigned (*prepare_fn) (struct call_context *context,\n-\t\t\t\t   unsigned char *stack, extended_cif *ecif);\n-\t */\n-        mov     x23, x0\n-        mov     x0, x1\n-        mov     x1, sp\n-        /* x2 already in place */\n-        blr     x23\n-\n-        /* Preserve the flags returned.  */\n-        mov     x23, x0\n-\n-        /* Figure out if we should touch the vector registers.  */\n-        tbz     x23, #AARCH64_FFI_WITH_V_BIT, 1f\n-\n-        /* Load the vector argument passing registers.  */\n-        ldp     q0, q1, [x21, #8*32 +  0]\n-        ldp     q2, q3, [x21, #8*32 + 32]\n-        ldp     q4, q5, [x21, #8*32 + 64]\n-        ldp     q6, q7, [x21, #8*32 + 96]\n+   x0 stack\n+   x1 frame\n+   x2 fn\n+   x3 rvalue\n+   x4 flags\n+   x5 closure\n+*/\n+\n+\tcfi_startproc\n+CNAME(ffi_call_SYSV):\n+\t/* Use a stack frame allocated by our caller.  */\n+\tcfi_def_cfa(x1, 32);\n+\tstp\tx29, x30, [x1]\n+\tmov\tx29, x1\n+\tmov\tsp, x0\n+\tcfi_def_cfa_register(x29)\n+\tcfi_rel_offset (x29, 0)\n+\tcfi_rel_offset (x30, 8)\n+\n+\tmov\tx9, x2\t\t\t/* save fn */\n+\tmov\tx8, x3\t\t\t/* install structure return */\n+#ifdef FFI_GO_CLOSURES\n+\tmov\tx18, x5\t\t\t/* install static chain */\n+#endif\n+\tstp\tx3, x4, [x29, #16]\t/* save rvalue and flags */\n+\n+\t/* Load the vector argument passing registers, if necessary.  */\n+\ttbz\tw4, #AARCH64_FLAG_ARG_V_BIT, 1f\n+\tldp     q0, q1, [sp, #0]\n+\tldp     q2, q3, [sp, #32]\n+\tldp     q4, q5, [sp, #64]\n+\tldp     q6, q7, [sp, #96]\n 1:\n-        /* Load the core argument passing registers.  */\n-        ldp     x0, x1, [x21,  #0]\n-        ldp     x2, x3, [x21, #16]\n-        ldp     x4, x5, [x21, #32]\n-        ldp     x6, x7, [x21, #48]\n-\n-        /* Don't forget x8 which may be holding the address of a return buffer.\n-\t */\n-        ldr     x8,     [x21, #8*8]\n-\n-        blr     x24\n-\n-        /* Save the core argument passing registers.  */\n-        stp     x0, x1, [x21,  #0]\n-        stp     x2, x3, [x21, #16]\n-        stp     x4, x5, [x21, #32]\n-        stp     x6, x7, [x21, #48]\n-\n-        /* Note nothing useful ever comes back in x8!  */\n-\n-        /* Figure out if we should touch the vector registers.  */\n-        tbz     x23, #AARCH64_FFI_WITH_V_BIT, 1f\n-\n-        /* Save the vector argument passing registers.  */\n-        stp     q0, q1, [x21, #8*32 + 0]\n-        stp     q2, q3, [x21, #8*32 + 32]\n-        stp     q4, q5, [x21, #8*32 + 64]\n-        stp     q6, q7, [x21, #8*32 + 96]\n-1:\n-        /* All done, unwind our stack frame.  */\n-        ldp     x21, x22, [x29,  # - ffi_call_SYSV_FS]\n-        cfi_restore (x21)\n-        cfi_restore (x22)\n-\n-        ldp     x23, x24, [x29,  # - ffi_call_SYSV_FS + 16]\n-        cfi_restore (x23)\n-        cfi_restore (x24)\n-\n-        mov     sp, x29\n-\tcfi_def_cfa_register (sp)\n+\t/* Load the core argument passing registers, including\n+\t   the structure return pointer.  */\n+\tldp     x0, x1, [sp, #16*N_V_ARG_REG + 0]\n+\tldp     x2, x3, [sp, #16*N_V_ARG_REG + 16]\n+\tldp     x4, x5, [sp, #16*N_V_ARG_REG + 32]\n+\tldp     x6, x7, [sp, #16*N_V_ARG_REG + 48]\n \n-        ldp     x29, x30, [sp], #16\n-\tcfi_adjust_cfa_offset (-16)\n-        cfi_restore (x29)\n-        cfi_restore (x30)\n+\t/* Deallocate the context, leaving the stacked arguments.  */\n+\tadd\tsp, sp, #CALL_CONTEXT_SIZE\n \n-        ret\n+\tblr     x9\t\t\t/* call fn */\n \n-        .cfi_endproc\n-        .size ffi_call_SYSV, .-ffi_call_SYSV\n+\tldp\tx3, x4, [x29, #16]\t/* reload rvalue and flags */\n \n-#define ffi_closure_SYSV_FS (8 * 2 + AARCH64_CALL_CONTEXT_SIZE)\n+\t/* Partially deconstruct the stack frame.  */\n+\tmov     sp, x29\n+\tcfi_def_cfa_register (sp)\n+\tldp     x29, x30, [x29]\n+\n+\t/* Save the return value as directed.  */\n+\tadr\tx5, 0f\n+\tand\tw4, w4, #AARCH64_RET_MASK\n+\tadd\tx5, x5, x4, lsl #3\n+\tbr\tx5\n+\n+\t/* Note that each table entry is 2 insns, and thus 8 bytes.\n+\t   For integer data, note that we're storing into ffi_arg\n+\t   and therefore we want to extend to 64 bits; these types\n+\t   have two consecutive entries allocated for them.  */\n+\t.align\t4\n+0:\tret\t\t\t\t/* VOID */\n+\tnop\n+1:\tstr\tx0, [x3]\t\t/* INT64 */\n+\tret\n+2:\tstp\tx0, x1, [x3]\t\t/* INT128 */\n+\tret\n+3:\tbrk\t#1000\t\t\t/* UNUSED */\n+\tret\n+4:\tbrk\t#1000\t\t\t/* UNUSED */\n+\tret\n+5:\tbrk\t#1000\t\t\t/* UNUSED */\n+\tret\n+6:\tbrk\t#1000\t\t\t/* UNUSED */\n+\tret\n+7:\tbrk\t#1000\t\t\t/* UNUSED */\n+\tret\n+8:\tst4\t{ v0.s-v3.s }[0], [x3]\t/* S4 */\n+\tret\n+9:\tst3\t{ v0.s-v2.s }[0], [x3]\t/* S3 */\n+\tret\n+10:\tstp\ts0, s1, [x3]\t\t/* S2 */\n+\tret\n+11:\tstr\ts0, [x3]\t\t/* S1 */\n+\tret\n+12:\tst4\t{ v0.d-v3.d }[0], [x3]\t/* D4 */\n+\tret\n+13:\tst3\t{ v0.d-v2.d }[0], [x3]\t/* D3 */\n+\tret\n+14:\tstp\td0, d1, [x3]\t\t/* D2 */\n+\tret\n+15:\tstr\td0, [x3]\t\t/* D1 */\n+\tret\n+16:\tstr\tq3, [x3, #48]\t\t/* Q4 */\n+\tnop\n+17:\tstr\tq2, [x3, #32]\t\t/* Q3 */\n+\tnop\n+18:\tstp\tq0, q1, [x3]\t\t/* Q2 */\n+\tret\n+19:\tstr\tq0, [x3]\t\t/* Q1 */\n+\tret\n+20:\tuxtb\tw0, w0\t\t\t/* UINT8 */\n+\tstr\tx0, [x3]\n+21:\tret\t\t\t\t/* reserved */\n+\tnop\n+22:\tuxth\tw0, w0\t\t\t/* UINT16 */\n+\tstr\tx0, [x3]\n+23:\tret\t\t\t\t/* reserved */\n+\tnop\n+24:\tmov\tw0, w0\t\t\t/* UINT32 */\n+\tstr\tx0, [x3]\n+25:\tret\t\t\t\t/* reserved */\n+\tnop\n+26:\tsxtb\tx0, w0\t\t\t/* SINT8 */\n+\tstr\tx0, [x3]\n+27:\tret\t\t\t\t/* reserved */\n+\tnop\n+28:\tsxth\tx0, w0\t\t\t/* SINT16 */\n+\tstr\tx0, [x3]\n+29:\tret\t\t\t\t/* reserved */\n+\tnop\n+30:\tsxtw\tx0, w0\t\t\t/* SINT32 */\n+\tstr\tx0, [x3]\n+31:\tret\t\t\t\t/* reserved */\n+\tnop\n+\n+\tcfi_endproc\n+\n+\t.globl\tCNAME(ffi_call_SYSV)\n+#ifdef __ELF__\n+\t.type\tCNAME(ffi_call_SYSV), #function\n+\t.hidden\tCNAME(ffi_call_SYSV)\n+\t.size CNAME(ffi_call_SYSV), .-CNAME(ffi_call_SYSV)\n+#endif\n \n /* ffi_closure_SYSV\n \n    Closure invocation glue. This is the low level code invoked directly by\n    the closure trampoline to setup and call a closure.\n \n-   On entry x17 points to a struct trampoline_data, x16 has been clobbered\n+   On entry x17 points to a struct ffi_closure, x16 has been clobbered\n    all other registers are preserved.\n \n    We allocate a call context and save the argument passing registers,\n    then invoked the generic C ffi_closure_SYSV_inner() function to do all\n    the real work, on return we load the result passing registers back from\n    the call context.\n+*/\n+\n+#define ffi_closure_SYSV_FS (8*2 + CALL_CONTEXT_SIZE + 64)\n+\n+\t.align 4\n+CNAME(ffi_closure_SYSV_V):\n+\tcfi_startproc\n+\tstp     x29, x30, [sp, #-ffi_closure_SYSV_FS]!\n+\tcfi_adjust_cfa_offset (ffi_closure_SYSV_FS)\n+\tcfi_rel_offset (x29, 0)\n+\tcfi_rel_offset (x30, 8)\n+\n+\t/* Save the argument passing vector registers.  */\n+\tstp     q0, q1, [sp, #16 + 0]\n+\tstp     q2, q3, [sp, #16 + 32]\n+\tstp     q4, q5, [sp, #16 + 64]\n+\tstp     q6, q7, [sp, #16 + 96]\n+\tb\t0f\n+\tcfi_endproc\n+\n+\t.globl\tCNAME(ffi_closure_SYSV_V)\n+#ifdef __ELF__\n+\t.type\tCNAME(ffi_closure_SYSV_V), #function\n+\t.hidden\tCNAME(ffi_closure_SYSV_V)\n+\t.size\tCNAME(ffi_closure_SYSV_V), . - CNAME(ffi_closure_SYSV_V)\n+#endif\n+\n+\t.align\t4\n+\tcfi_startproc\n+CNAME(ffi_closure_SYSV):\n+\tstp     x29, x30, [sp, #-ffi_closure_SYSV_FS]!\n+\tcfi_adjust_cfa_offset (ffi_closure_SYSV_FS)\n+\tcfi_rel_offset (x29, 0)\n+\tcfi_rel_offset (x30, 8)\n+0:\n+\tmov     x29, sp\n+\n+\t/* Save the argument passing core registers.  */\n+\tstp     x0, x1, [sp, #16 + 16*N_V_ARG_REG + 0]\n+\tstp     x2, x3, [sp, #16 + 16*N_V_ARG_REG + 16]\n+\tstp     x4, x5, [sp, #16 + 16*N_V_ARG_REG + 32]\n+\tstp     x6, x7, [sp, #16 + 16*N_V_ARG_REG + 48]\n+\n+\t/* Load ffi_closure_inner arguments.  */\n+\tldp\tx0, x1, [x17, #FFI_TRAMPOLINE_SIZE]\t/* load cif, fn */\n+\tldr\tx2, [x17, #FFI_TRAMPOLINE_SIZE+16]\t/* load user_data */\n+.Ldo_closure:\n+\tadd\tx3, sp, #16\t\t\t\t/* load context */\n+\tadd\tx4, sp, #ffi_closure_SYSV_FS\t\t/* load stack */\n+\tadd\tx5, sp, #16+CALL_CONTEXT_SIZE\t\t/* load rvalue */\n+\tmov\tx6, x8\t\t\t\t\t/* load struct_rval */\n+\tbl      CNAME(ffi_closure_SYSV_inner)\n+\n+\t/* Load the return value as directed.  */\n+\tadr\tx1, 0f\n+\tand\tw0, w0, #AARCH64_RET_MASK\n+\tadd\tx1, x1, x0, lsl #3\n+\tadd\tx3, sp, #16+CALL_CONTEXT_SIZE\n+\tbr\tx1\n+\n+\t/* Note that each table entry is 2 insns, and thus 8 bytes.  */\n+\t.align\t4\n+0:\tb\t99f\t\t\t/* VOID */\n+\tnop\n+1:\tldr\tx0, [x3]\t\t/* INT64 */\n+\tb\t99f\n+2:\tldp\tx0, x1, [x3]\t\t/* INT128 */\n+\tb\t99f\n+3:\tbrk\t#1000\t\t\t/* UNUSED */\n+\tnop\n+4:\tbrk\t#1000\t\t\t/* UNUSED */\n+\tnop\n+5:\tbrk\t#1000\t\t\t/* UNUSED */\n+\tnop\n+6:\tbrk\t#1000\t\t\t/* UNUSED */\n+\tnop\n+7:\tbrk\t#1000\t\t\t/* UNUSED */\n+\tnop\n+8:\tldr\ts3, [x3, #12]\t\t/* S4 */\n+\tnop\n+9:\tldr\ts2, [x2, #8]\t\t/* S3 */\n+\tnop\n+10:\tldp\ts0, s1, [x3]\t\t/* S2 */\n+\tb\t99f\n+11:\tldr\ts0, [x3]\t\t/* S1 */\n+\tb\t99f\n+12:\tldr\td3, [x3, #24]\t\t/* D4 */\n+\tnop\n+13:\tldr\td2, [x3, #16]\t\t/* D3 */\n+\tnop\n+14:\tldp\td0, d1, [x3]\t\t/* D2 */\n+\tb\t99f\n+15:\tldr\td0, [x3]\t\t/* D1 */\n+\tb\t99f\n+16:\tldr\tq3, [x3, #48]\t\t/* Q4 */\n+\tnop\n+17:\tldr\tq2, [x3, #32]\t\t/* Q3 */\n+\tnop\n+18:\tldp\tq0, q1, [x3]\t\t/* Q2 */\n+\tb\t99f\n+19:\tldr\tq0, [x3]\t\t/* Q1 */\n+\tb\t99f\n+20:\tldrb\tw0, [x3, #BE(7)]\t/* UINT8 */\n+\tb\t99f\n+21:\tbrk\t#1000\t\t\t/* reserved */\n+\tnop\n+22:\tldrh\tw0, [x3, #BE(6)]\t/* UINT16 */\n+\tb\t99f\n+23:\tbrk\t#1000\t\t\t/* reserved */\n+\tnop\n+24:\tldr\tw0, [x3, #BE(4)]\t/* UINT32 */\n+\tb\t99f\n+25:\tbrk\t#1000\t\t\t/* reserved */\n+\tnop\n+26:\tldrsb\tx0, [x3, #BE(7)]\t/* SINT8 */\n+\tb\t99f\n+27:\tbrk\t#1000\t\t\t/* reserved */\n+\tnop\n+28:\tldrsh\tx0, [x3, #BE(6)]\t/* SINT16 */\n+\tb\t99f\n+29:\tbrk\t#1000\t\t\t/* reserved */\n+\tnop\n+30:\tldrsw\tx0, [x3, #BE(4)]\t/* SINT32 */\n+\tnop\n+31:\t\t\t\t\t/* reserved */\n+99:\tldp     x29, x30, [sp], #ffi_closure_SYSV_FS\n+\tcfi_adjust_cfa_offset (-ffi_closure_SYSV_FS)\n+\tcfi_restore (x29)\n+\tcfi_restore (x30)\n+\tret\n+\tcfi_endproc\n+\n+\t.globl\tCNAME(ffi_closure_SYSV)\n+#ifdef __ELF__\n+\t.type\tCNAME(ffi_closure_SYSV), #function\n+\t.hidden\tCNAME(ffi_closure_SYSV)\n+\t.size\tCNAME(ffi_closure_SYSV), . - CNAME(ffi_closure_SYSV)\n+#endif\n+\n+#ifdef FFI_GO_CLOSURES\n+\t.align 4\n+CNAME(ffi_go_closure_SYSV_V):\n+\tcfi_startproc\n+\tstp     x29, x30, [sp, #-ffi_closure_SYSV_FS]!\n+\tcfi_adjust_cfa_offset (ffi_closure_SYSV_FS)\n+\tcfi_rel_offset (x29, 0)\n+\tcfi_rel_offset (x30, 8)\n+\n+\t/* Save the argument passing vector registers.  */\n+\tstp     q0, q1, [sp, #16 + 0]\n+\tstp     q2, q3, [sp, #16 + 32]\n+\tstp     q4, q5, [sp, #16 + 64]\n+\tstp     q6, q7, [sp, #16 + 96]\n+\tb\t0f\n+\tcfi_endproc\n+\n+\t.globl\tCNAME(ffi_go_closure_SYSV_V)\n+#ifdef __ELF__\n+\t.type\tCNAME(ffi_go_closure_SYSV_V), #function\n+\t.hidden\tCNAME(ffi_go_closure_SYSV_V)\n+\t.size\tCNAME(ffi_go_closure_SYSV_V), . - CNAME(ffi_go_closure_SYSV_V)\n+#endif\n+\n+\t.align\t4\n+\tcfi_startproc\n+CNAME(ffi_go_closure_SYSV):\n+\tstp     x29, x30, [sp, #-ffi_closure_SYSV_FS]!\n+\tcfi_adjust_cfa_offset (ffi_closure_SYSV_FS)\n+\tcfi_rel_offset (x29, 0)\n+\tcfi_rel_offset (x30, 8)\n+0:\n+\tmov     x29, sp\n+\n+\t/* Save the argument passing core registers.  */\n+\tstp     x0, x1, [sp, #16 + 16*N_V_ARG_REG + 0]\n+\tstp     x2, x3, [sp, #16 + 16*N_V_ARG_REG + 16]\n+\tstp     x4, x5, [sp, #16 + 16*N_V_ARG_REG + 32]\n+\tstp     x6, x7, [sp, #16 + 16*N_V_ARG_REG + 48]\n+\n+\t/* Load ffi_closure_inner arguments.  */\n+\tldp\tx0, x1, [x18, #8]\t\t\t/* load cif, fn */\n+\tmov\tx2, x18\t\t\t\t\t/* load user_data */\n+\tb\t.Ldo_closure\n+\tcfi_endproc\n+\n+\t.globl\tCNAME(ffi_go_closure_SYSV)\n+#ifdef __ELF__\n+\t.type\tCNAME(ffi_go_closure_SYSV), #function\n+\t.hidden\tCNAME(ffi_go_closure_SYSV)\n+\t.size\tCNAME(ffi_go_closure_SYSV), . - CNAME(ffi_go_closure_SYSV)\n+#endif\n+#endif /* FFI_GO_CLOSURES */\n+\n+#if defined __ELF__ && defined __linux__\n+\t.section .note.GNU-stack,\"\",%progbits\n+#endif\n \n-   On entry\n-\n-   extern void\n-   ffi_closure_SYSV (struct trampoline_data *);\n-\n-   struct trampoline_data\n-   {\n-        UINT64 *ffi_closure;\n-        UINT64 flags;\n-   };\n-\n-   This function uses the following stack frame layout:\n-\n-   ==\n-                saved x30(lr)\n-   x29(fp)->    saved x29(fp)\n-                saved x22\n-                saved x21\n-                ...\n-   sp     ->    call_context\n-   ==\n-\n-   Voila!  */\n-\n-        .text\n-        .globl ffi_closure_SYSV\n-        .cfi_startproc\n-ffi_closure_SYSV:\n-        stp     x29, x30, [sp, #-16]!\n-\tcfi_adjust_cfa_offset (16)\n-        cfi_rel_offset (x29, 0)\n-        cfi_rel_offset (x30, 8)\n-\n-        mov     x29, sp\n-        cfi_def_cfa_register (x29)\n-\n-        sub     sp, sp, #ffi_closure_SYSV_FS\n-\n-        stp     x21, x22, [x29, #-16]\n-        cfi_rel_offset (x21, -16)\n-        cfi_rel_offset (x22, -8)\n-\n-        /* Load x21 with &call_context.  */\n-        mov     x21, sp\n-        /* Preserve our struct trampoline_data *  */\n-        mov     x22, x17\n-\n-        /* Save the rest of the argument passing registers.  */\n-        stp     x0, x1, [x21, #0]\n-        stp     x2, x3, [x21, #16]\n-        stp     x4, x5, [x21, #32]\n-        stp     x6, x7, [x21, #48]\n-        /* Don't forget we may have been given a result scratch pad address.\n-\t */\n-        str     x8,     [x21, #64]\n-\n-        /* Figure out if we should touch the vector registers.  */\n-        ldr     x0, [x22, #8]\n-        tbz     x0, #AARCH64_FFI_WITH_V_BIT, 1f\n-\n-        /* Save the argument passing vector registers.  */\n-        stp     q0, q1, [x21, #8*32 + 0]\n-        stp     q2, q3, [x21, #8*32 + 32]\n-        stp     q4, q5, [x21, #8*32 + 64]\n-        stp     q6, q7, [x21, #8*32 + 96]\n-1:\n-        /* Load &ffi_closure..  */\n-        ldr     x0, [x22, #0]\n-        mov     x1, x21\n-        /* Compute the location of the stack at the point that the\n-           trampoline was called.  */\n-        add     x2, x29, #16\n-\n-        bl      ffi_closure_SYSV_inner\n-\n-        /* Figure out if we should touch the vector registers.  */\n-        ldr     x0, [x22, #8]\n-        tbz     x0, #AARCH64_FFI_WITH_V_BIT, 1f\n-\n-        /* Load the result passing vector registers.  */\n-        ldp     q0, q1, [x21, #8*32 + 0]\n-        ldp     q2, q3, [x21, #8*32 + 32]\n-        ldp     q4, q5, [x21, #8*32 + 64]\n-        ldp     q6, q7, [x21, #8*32 + 96]\n-1:\n-        /* Load the result passing core registers.  */\n-        ldp     x0, x1, [x21,  #0]\n-        ldp     x2, x3, [x21, #16]\n-        ldp     x4, x5, [x21, #32]\n-        ldp     x6, x7, [x21, #48]\n-        /* Note nothing usefull is returned in x8.  */\n-\n-        /* We are done, unwind our frame.  */\n-        ldp     x21, x22, [x29,  #-16]\n-        cfi_restore (x21)\n-        cfi_restore (x22)\n-\n-        mov     sp, x29\n-        cfi_def_cfa_register (sp)\n-\n-        ldp     x29, x30, [sp], #16\n-\tcfi_adjust_cfa_offset (-16)\n-        cfi_restore (x29)\n-        cfi_restore (x30)\n-\n-        ret\n-        .cfi_endproc\n-        .size ffi_closure_SYSV, .-ffi_closure_SYSV"}, {"sha": "efae4cc3d671a549852130ae57515e94f043bb00", "filename": "libffi/src/alpha/ffi.c", "status": "modified", "additions": 333, "deletions": 99, "changes": 432, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Falpha%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Falpha%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Falpha%2Fffi.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -1,8 +1,8 @@\n /* -----------------------------------------------------------------------\n    ffi.c - Copyright (c) 2012  Anthony Green\n-           Copyright (c) 1998, 2001, 2007, 2008  Red Hat, Inc.\n-   \n-   Alpha Foreign Function Interface \n+\t   Copyright (c) 1998, 2001, 2007, 2008  Red Hat, Inc.\n+\n+   Alpha Foreign Function Interface\n \n    Permission is hereby granted, free of charge, to any person obtaining\n    a copy of this software and associated documentation files (the\n@@ -27,6 +27,8 @@\n \n #include <ffi.h>\n #include <ffi_common.h>\n+#include <stdlib.h>\n+#include \"internal.h\"\n \n /* Force FFI_TYPE_LONGDOUBLE to be different than FFI_TYPE_DOUBLE;\n    all further uses in this file will refer to the 128-bit type.  */\n@@ -39,135 +41,286 @@\n # define FFI_TYPE_LONGDOUBLE 4\n #endif\n \n-extern void ffi_call_osf(void *, unsigned long, unsigned, void *, void (*)(void))\n-  FFI_HIDDEN;\n+extern void ffi_call_osf(void *stack, void *frame, unsigned flags,\n+\t\t\t void *raddr, void (*fn)(void), void *closure)\n+\tFFI_HIDDEN;\n extern void ffi_closure_osf(void) FFI_HIDDEN;\n+extern void ffi_go_closure_osf(void) FFI_HIDDEN;\n \n+/* Promote a float value to its in-register double representation.\n+   Unlike actually casting to double, this does not trap on NaN.  */\n+static inline UINT64 lds(void *ptr)\n+{\n+  UINT64 ret;\n+  asm(\"lds %0,%1\" : \"=f\"(ret) : \"m\"(*(UINT32 *)ptr));\n+  return ret;\n+}\n \n-ffi_status\n+/* And the reverse.  */\n+static inline void sts(void *ptr, UINT64 val)\n+{\n+  asm(\"sts %1,%0\" : \"=m\"(*(UINT32 *)ptr) : \"f\"(val));\n+}\n+\n+ffi_status FFI_HIDDEN\n ffi_prep_cif_machdep(ffi_cif *cif)\n {\n-  /* Adjust cif->bytes to represent a minimum 6 words for the temporary\n-     register argument loading area.  */\n-  if (cif->bytes < 6*FFI_SIZEOF_ARG)\n-    cif->bytes = 6*FFI_SIZEOF_ARG;\n+  size_t bytes = 0;\n+  int flags, i, avn;\n+  ffi_type *rtype, *itype;\n+\n+  if (cif->abi != FFI_OSF)\n+    return FFI_BAD_ABI;\n+\n+  /* Compute the size of the argument area.  */\n+  for (i = 0, avn = cif->nargs; i < avn; i++)\n+    {\n+      itype = cif->arg_types[i];\n+      switch (itype->type)\n+\t{\n+\tcase FFI_TYPE_INT:\n+\tcase FFI_TYPE_SINT8:\n+\tcase FFI_TYPE_UINT8:\n+\tcase FFI_TYPE_SINT16:\n+\tcase FFI_TYPE_UINT16:\n+\tcase FFI_TYPE_SINT32:\n+\tcase FFI_TYPE_UINT32:\n+\tcase FFI_TYPE_SINT64:\n+\tcase FFI_TYPE_UINT64:\n+\tcase FFI_TYPE_POINTER:\n+\tcase FFI_TYPE_FLOAT:\n+\tcase FFI_TYPE_DOUBLE:\n+\tcase FFI_TYPE_LONGDOUBLE:\n+\t  /* All take one 8 byte slot.  */\n+\t  bytes += 8;\n+\t  break;\n+\n+\tcase FFI_TYPE_VOID:\n+\tcase FFI_TYPE_STRUCT:\n+\t  /* Passed by value in N slots.  */\n+\t  bytes += ALIGN(itype->size, FFI_SIZEOF_ARG);\n+\t  break;\n+\n+\tcase FFI_TYPE_COMPLEX:\n+\t  /* _Complex long double passed by reference; others in 2 slots.  */\n+\t  if (itype->elements[0]->type == FFI_TYPE_LONGDOUBLE)\n+\t    bytes += 8;\n+\t  else\n+\t    bytes += 16;\n+\t  break;\n+\n+\tdefault:\n+\t  abort();\n+\t}\n+    }\n \n   /* Set the return type flag */\n-  switch (cif->rtype->type)\n+  rtype = cif->rtype;\n+  switch (rtype->type)\n     {\n-    case FFI_TYPE_STRUCT:\n+    case FFI_TYPE_VOID:\n+      flags = ALPHA_FLAGS(ALPHA_ST_VOID, ALPHA_LD_VOID);\n+      break;\n+    case FFI_TYPE_INT:\n+    case FFI_TYPE_UINT32:\n+    case FFI_TYPE_SINT32:\n+      flags = ALPHA_FLAGS(ALPHA_ST_INT, ALPHA_LD_INT32);\n+      break;\n     case FFI_TYPE_FLOAT:\n+      flags = ALPHA_FLAGS(ALPHA_ST_FLOAT, ALPHA_LD_FLOAT);\n+      break;\n     case FFI_TYPE_DOUBLE:\n-      cif->flags = cif->rtype->type;\n+      flags = ALPHA_FLAGS(ALPHA_ST_DOUBLE, ALPHA_LD_DOUBLE);\n+      break;\n+    case FFI_TYPE_UINT8:\n+      flags = ALPHA_FLAGS(ALPHA_ST_INT, ALPHA_LD_UINT8);\n+      break;\n+    case FFI_TYPE_SINT8:\n+      flags = ALPHA_FLAGS(ALPHA_ST_INT, ALPHA_LD_SINT8);\n+      break;\n+    case FFI_TYPE_UINT16:\n+      flags = ALPHA_FLAGS(ALPHA_ST_INT, ALPHA_LD_UINT16);\n+      break;\n+    case FFI_TYPE_SINT16:\n+      flags = ALPHA_FLAGS(ALPHA_ST_INT, ALPHA_LD_SINT16);\n+      break;\n+    case FFI_TYPE_UINT64:\n+    case FFI_TYPE_SINT64:\n+    case FFI_TYPE_POINTER:\n+      flags = ALPHA_FLAGS(ALPHA_ST_INT, ALPHA_LD_INT64);\n       break;\n-\n     case FFI_TYPE_LONGDOUBLE:\n-      /* 128-bit long double is returned in memory, like a struct.  */\n-      cif->flags = FFI_TYPE_STRUCT;\n+    case FFI_TYPE_STRUCT:\n+      /* Passed in memory, with a hidden pointer.  */\n+      flags = ALPHA_RET_IN_MEM;\n       break;\n-\n-    default:\n-      cif->flags = FFI_TYPE_INT;\n+    case FFI_TYPE_COMPLEX:\n+      itype = rtype->elements[0];\n+      switch (itype->type)\n+\t{\n+\tcase FFI_TYPE_FLOAT:\n+\t  flags = ALPHA_FLAGS(ALPHA_ST_CPLXF, ALPHA_LD_CPLXF);\n+\t  break;\n+\tcase FFI_TYPE_DOUBLE:\n+\t  flags = ALPHA_FLAGS(ALPHA_ST_CPLXD, ALPHA_LD_CPLXD);\n+\t  break;\n+\tdefault:\n+\t  if (rtype->size <= 8)\n+\t    flags = ALPHA_FLAGS(ALPHA_ST_INT, ALPHA_LD_INT64);\n+\t  else\n+\t    flags = ALPHA_RET_IN_MEM;\n+\t  break;\n+\t}\n       break;\n+    default:\n+      abort();\n     }\n-  \n+  cif->flags = flags;\n+\n+  /* Include the hidden structure pointer in args requirement.  */\n+  if (flags == ALPHA_RET_IN_MEM)\n+    bytes += 8;\n+  /* Minimum size is 6 slots, so that ffi_call_osf can pop them.  */\n+  if (bytes < 6*8)\n+    bytes = 6*8;\n+  cif->bytes = bytes;\n+\n   return FFI_OK;\n }\n \n+static unsigned long\n+extend_basic_type(void *valp, int type, int argn)\n+{\n+  switch (type)\n+    {\n+    case FFI_TYPE_SINT8:\n+      return *(SINT8 *)valp;\n+    case FFI_TYPE_UINT8:\n+      return *(UINT8 *)valp;\n+    case FFI_TYPE_SINT16:\n+      return *(SINT16 *)valp;\n+    case FFI_TYPE_UINT16:\n+      return *(UINT16 *)valp;\n+\n+    case FFI_TYPE_FLOAT:\n+      if (argn < 6)\n+\treturn lds(valp);\n+      /* FALLTHRU */\n+\n+    case FFI_TYPE_INT:\n+    case FFI_TYPE_SINT32:\n+    case FFI_TYPE_UINT32:\n+      /* Note that unsigned 32-bit quantities are sign extended.  */\n+      return *(SINT32 *)valp;\n+\n+    case FFI_TYPE_SINT64:\n+    case FFI_TYPE_UINT64:\n+    case FFI_TYPE_POINTER:\n+    case FFI_TYPE_DOUBLE:\n+      return *(UINT64 *)valp;\n \n-void\n-ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n+    default:\n+      abort();\n+    }\n+}\n+\n+static void\n+ffi_call_int (ffi_cif *cif, void (*fn)(void), void *rvalue,\n+\t      void **avalue, void *closure)\n {\n-  unsigned long *stack, *argp;\n-  long i, avn;\n+  unsigned long *argp;\n+  long i, avn, argn, flags = cif->flags;\n   ffi_type **arg_types;\n-  \n+  void *frame;\n+\n   /* If the return value is a struct and we don't have a return\n      value address then we need to make one.  */\n-  if (rvalue == NULL && cif->flags == FFI_TYPE_STRUCT)\n+  if (rvalue == NULL && flags == ALPHA_RET_IN_MEM)\n     rvalue = alloca(cif->rtype->size);\n \n   /* Allocate the space for the arguments, plus 4 words of temp\n      space for ffi_call_osf.  */\n-  argp = stack = alloca(cif->bytes + 4*FFI_SIZEOF_ARG);\n+  argp = frame = alloca(cif->bytes + 4*FFI_SIZEOF_ARG);\n+  frame += cif->bytes;\n \n-  if (cif->flags == FFI_TYPE_STRUCT)\n-    *(void **) argp++ = rvalue;\n+  argn = 0;\n+  if (flags == ALPHA_RET_IN_MEM)\n+    argp[argn++] = (unsigned long)rvalue;\n \n-  i = 0;\n   avn = cif->nargs;\n   arg_types = cif->arg_types;\n \n-  while (i < avn)\n+  for (i = 0, avn = cif->nargs; i < avn; i++)\n     {\n-      size_t size = (*arg_types)->size;\n+      ffi_type *ty = arg_types[i];\n+      void *valp = avalue[i];\n+      int type = ty->type;\n+      size_t size;\n \n-      switch ((*arg_types)->type)\n+      switch (type)\n \t{\n+\tcase FFI_TYPE_INT:\n \tcase FFI_TYPE_SINT8:\n-\t  *(SINT64 *) argp = *(SINT8 *)(* avalue);\n-\t  break;\n-\t\t  \n \tcase FFI_TYPE_UINT8:\n-\t  *(SINT64 *) argp = *(UINT8 *)(* avalue);\n-\t  break;\n-\t\t  \n \tcase FFI_TYPE_SINT16:\n-\t  *(SINT64 *) argp = *(SINT16 *)(* avalue);\n-\t  break;\n-\t\t  \n \tcase FFI_TYPE_UINT16:\n-\t  *(SINT64 *) argp = *(UINT16 *)(* avalue);\n-\t  break;\n-\t\t  \n \tcase FFI_TYPE_SINT32:\n \tcase FFI_TYPE_UINT32:\n-\t  /* Note that unsigned 32-bit quantities are sign extended.  */\n-\t  *(SINT64 *) argp = *(SINT32 *)(* avalue);\n-\t  break;\n-\t\t  \n \tcase FFI_TYPE_SINT64:\n \tcase FFI_TYPE_UINT64:\n \tcase FFI_TYPE_POINTER:\n-\t  *(UINT64 *) argp = *(UINT64 *)(* avalue);\n-\t  break;\n-\n \tcase FFI_TYPE_FLOAT:\n-\t  if (argp - stack < 6)\n-\t    {\n-\t      /* Note the conversion -- all the fp regs are loaded as\n-\t\t doubles.  The in-register format is the same.  */\n-\t      *(double *) argp = *(float *)(* avalue);\n-\t    }\n-\t  else\n-\t    *(float *) argp = *(float *)(* avalue);\n-\t  break;\n-\n \tcase FFI_TYPE_DOUBLE:\n-\t  *(double *) argp = *(double *)(* avalue);\n+\t  argp[argn] = extend_basic_type(valp, type, argn);\n+\t  argn++;\n \t  break;\n \n \tcase FFI_TYPE_LONGDOUBLE:\n-\t  /* 128-bit long double is passed by reference.  */\n-\t  *(long double **) argp = (long double *)(* avalue);\n-\t  size = sizeof (long double *);\n+\tby_reference:\n+\t  /* Note that 128-bit long double is passed by reference.  */\n+\t  argp[argn++] = (unsigned long)valp;\n \t  break;\n \n+\tcase FFI_TYPE_VOID:\n \tcase FFI_TYPE_STRUCT:\n-\t  memcpy(argp, *avalue, (*arg_types)->size);\n+\t  size = ty->size;\n+\t  memcpy(argp + argn, valp, size);\n+\t  argn += ALIGN(size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n+\t  break;\n+\n+\tcase FFI_TYPE_COMPLEX:\n+\t  type = ty->elements[0]->type;\n+\t  if (type == FFI_TYPE_LONGDOUBLE)\n+\t    goto by_reference;\n+\n+\t  /* Most complex types passed as two separate arguments.  */\n+\t  size = ty->elements[0]->size;\n+\t  argp[argn] = extend_basic_type(valp, type, argn);\n+\t  argp[argn + 1] = extend_basic_type(valp + size, type, argn + 1);\n+\t  argn += 2;\n \t  break;\n \n \tdefault:\n-\t  FFI_ASSERT(0);\n+\t  abort();\n \t}\n-\n-      argp += ALIGN(size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n-      i++, arg_types++, avalue++;\n     }\n \n-  ffi_call_osf(stack, cif->bytes, cif->flags, rvalue, fn);\n+  flags = (flags >> ALPHA_ST_SHIFT) & 0xff;\n+  ffi_call_osf(argp, frame, flags, rvalue, fn, closure);\n+}\n+\n+void\n+ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n+{\n+  ffi_call_int(cif, fn, rvalue, avalue, NULL);\n }\n \n+void\n+ffi_call_go (ffi_cif *cif, void (*fn)(void), void *rvalue,\n+\t     void **avalue, void *closure)\n+{\n+  ffi_call_int(cif, fn, rvalue, avalue, closure);\n+}\n \n ffi_status\n ffi_prep_closure_loc (ffi_closure* closure,\n@@ -203,39 +356,56 @@ ffi_prep_closure_loc (ffi_closure* closure,\n   return FFI_OK;\n }\n \n+ffi_status\n+ffi_prep_go_closure (ffi_go_closure* closure,\n+\t\t     ffi_cif* cif,\n+\t\t     void (*fun)(ffi_cif*, void*, void**, void*))\n+{\n+  if (cif->abi != FFI_OSF)\n+    return FFI_BAD_ABI;\n+\n+  closure->tramp = (void *)ffi_go_closure_osf;\n+  closure->cif = cif;\n+  closure->fun = fun;\n+\n+  return FFI_OK;\n+}\n \n long FFI_HIDDEN\n-ffi_closure_osf_inner(ffi_closure *closure, void *rvalue, unsigned long *argp)\n+ffi_closure_osf_inner (ffi_cif *cif,\n+\t\t       void (*fun)(ffi_cif*, void*, void**, void*),\n+\t\t       void *user_data,\n+\t\t       void *rvalue, unsigned long *argp)\n {\n-  ffi_cif *cif;\n   void **avalue;\n   ffi_type **arg_types;\n-  long i, avn, argn;\n+  long i, avn, argn, flags;\n \n-  cif = closure->cif;\n   avalue = alloca(cif->nargs * sizeof(void *));\n-\n+  flags = cif->flags;\n   argn = 0;\n \n   /* Copy the caller's structure return address to that the closure\n      returns the data directly to the caller.  */\n-  if (cif->flags == FFI_TYPE_STRUCT)\n+  if (flags == ALPHA_RET_IN_MEM)\n     {\n       rvalue = (void *) argp[0];\n       argn = 1;\n     }\n \n-  i = 0;\n-  avn = cif->nargs;\n   arg_types = cif->arg_types;\n-  \n+\n   /* Grab the addresses of the arguments from the stack frame.  */\n-  while (i < avn)\n+  for (i = 0, avn = cif->nargs; i < avn; i++)\n     {\n-      size_t size = arg_types[i]->size;\n+      ffi_type *ty = arg_types[i];\n+      int type = ty->type;\n+      void *valp = &argp[argn];\n+      size_t size;\n \n-      switch (arg_types[i]->type)\n+      switch (type)\n \t{\n+\tcase FFI_TYPE_INT:\n \tcase FFI_TYPE_SINT8:\n \tcase FFI_TYPE_UINT8:\n \tcase FFI_TYPE_SINT16:\n@@ -245,43 +415,107 @@ ffi_closure_osf_inner(ffi_closure *closure, void *rvalue, unsigned long *argp)\n \tcase FFI_TYPE_SINT64:\n \tcase FFI_TYPE_UINT64:\n \tcase FFI_TYPE_POINTER:\n+\t  argn += 1;\n+\t  break;\n+\n+\tcase FFI_TYPE_VOID:\n \tcase FFI_TYPE_STRUCT:\n-\t  avalue[i] = &argp[argn];\n+\t  size = ty->size;\n+\t  argn += ALIGN(size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n \t  break;\n \n \tcase FFI_TYPE_FLOAT:\n+\t  /* Floats coming from registers need conversion from double\n+\t     back to float format.  */\n \t  if (argn < 6)\n \t    {\n-\t      /* Floats coming from registers need conversion from double\n-\t         back to float format.  */\n-\t      *(float *)&argp[argn - 6] = *(double *)&argp[argn - 6];\n-\t      avalue[i] = &argp[argn - 6];\n+\t      valp = &argp[argn - 6];\n+\t      sts(valp, argp[argn - 6]);\n \t    }\n-\t  else\n-\t    avalue[i] = &argp[argn];\n+\t  argn += 1;\n \t  break;\n \n \tcase FFI_TYPE_DOUBLE:\n-\t  avalue[i] = &argp[argn - (argn < 6 ? 6 : 0)];\n+\t  if (argn < 6)\n+\t    valp = &argp[argn - 6];\n+\t  argn += 1;\n \t  break;\n \n \tcase FFI_TYPE_LONGDOUBLE:\n+\tby_reference:\n \t  /* 128-bit long double is passed by reference.  */\n-\t  avalue[i] = (long double *) argp[argn];\n-\t  size = sizeof (long double *);\n+\t  valp = (void *)argp[argn];\n+\t  argn += 1;\n+\t  break;\n+\n+\tcase FFI_TYPE_COMPLEX:\n+\t  type = ty->elements[0]->type;\n+\t  switch (type)\n+\t    {\n+\t    case FFI_TYPE_SINT64:\n+\t    case FFI_TYPE_UINT64:\n+\t      /* Passed as separate arguments, but they wind up sequential.  */\n+\t      break;\n+\n+\t    case FFI_TYPE_INT:\n+\t    case FFI_TYPE_SINT8:\n+\t    case FFI_TYPE_UINT8:\n+\t    case FFI_TYPE_SINT16:\n+\t    case FFI_TYPE_UINT16:\n+\t    case FFI_TYPE_SINT32:\n+\t    case FFI_TYPE_UINT32:\n+\t      /* Passed as separate arguments.  Disjoint, but there's room\n+\t\t enough in one slot to hold the pair.  */\n+\t      size = ty->elements[0]->size;\n+\t      memcpy(valp + size, valp + 8, size);\n+\t      break;\n+\n+\t    case FFI_TYPE_FLOAT:\n+\t      /* Passed as separate arguments.  Disjoint, and each piece\n+\t\t may need conversion back to float.  */\n+\t      if (argn < 6)\n+\t\t{\n+\t\t  valp = &argp[argn - 6];\n+\t\t  sts(valp, argp[argn - 6]);\n+\t\t}\n+\t      if (argn + 1 < 6)\n+\t\tsts(valp + 4, argp[argn + 1 - 6]);\n+\t      else\n+\t\t*(UINT32 *)(valp + 4) = argp[argn + 1];\n+\t      break;\n+\n+\t    case FFI_TYPE_DOUBLE:\n+\t      /* Passed as separate arguments.  Only disjoint if one part\n+\t\t is in fp regs and the other is on the stack.  */\n+\t      if (argn < 5)\n+\t\tvalp = &argp[argn - 6];\n+\t      else if (argn == 5)\n+\t\t{\n+\t\t  valp = alloca(16);\n+\t\t  ((UINT64 *)valp)[0] = argp[5 - 6];\n+\t\t  ((UINT64 *)valp)[1] = argp[6];\n+\t\t}\n+\t      break;\n+\n+\t    case FFI_TYPE_LONGDOUBLE:\n+\t      goto by_reference;\n+\n+\t    default:\n+\t      abort();\n+\t    }\n+\t  argn += 2;\n \t  break;\n \n \tdefault:\n-\t  FFI_ASSERT (0);\n+\t  abort ();\n \t}\n \n-      argn += ALIGN(size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n-      i++;\n+      avalue[i] = valp;\n     }\n \n   /* Invoke the closure.  */\n-  closure->fun (cif, rvalue, avalue, closure->user_data);\n+  fun (cif, rvalue, avalue, user_data);\n \n   /* Tell ffi_closure_osf how to perform return type promotions.  */\n-  return cif->rtype->type;\n+  return (flags >> ALPHA_LD_SHIFT) & 0xff;\n }"}, {"sha": "a02dbd04f6df303448cfed370f5dd963330d0006", "filename": "libffi/src/alpha/ffitarget.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Falpha%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Falpha%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Falpha%2Fffitarget.h?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -44,9 +44,13 @@ typedef enum ffi_abi {\n } ffi_abi;\n #endif\n \n+#define FFI_TARGET_SPECIFIC_STACK_SPACE_ALLOCATION\n+#define FFI_TARGET_HAS_COMPLEX_TYPE\n+\n /* ---- Definitions for closures ----------------------------------------- */\n \n #define FFI_CLOSURES 1\n+#define FFI_GO_CLOSURES 1\n #define FFI_TRAMPOLINE_SIZE 24\n #define FFI_NATIVE_RAW_API 0\n "}, {"sha": "44da1922bb9fed46f45aec80eba4bfe495db109b", "filename": "libffi/src/alpha/internal.h", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Falpha%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Falpha%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Falpha%2Finternal.h?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -0,0 +1,23 @@\n+#define ALPHA_ST_VOID\t0\n+#define ALPHA_ST_INT\t1\n+#define ALPHA_ST_FLOAT\t2\n+#define ALPHA_ST_DOUBLE\t3\n+#define ALPHA_ST_CPLXF\t4\n+#define ALPHA_ST_CPLXD\t5\n+\n+#define ALPHA_LD_VOID\t0\n+#define ALPHA_LD_INT64\t1\n+#define ALPHA_LD_INT32\t2\n+#define ALPHA_LD_UINT16\t3\n+#define ALPHA_LD_SINT16\t4\n+#define ALPHA_LD_UINT8\t5\n+#define ALPHA_LD_SINT8\t6\n+#define ALPHA_LD_FLOAT\t7\n+#define ALPHA_LD_DOUBLE\t8\n+#define ALPHA_LD_CPLXF\t9\n+#define ALPHA_LD_CPLXD\t10\n+\n+#define ALPHA_ST_SHIFT\t\t0\n+#define ALPHA_LD_SHIFT\t\t8\n+#define ALPHA_RET_IN_MEM\t0x10000\n+#define ALPHA_FLAGS(S, L)\t(((L) << ALPHA_LD_SHIFT) | (S))"}, {"sha": "b0318282a015ac2802a7dc0fcbe313c4ce4a082e", "filename": "libffi/src/alpha/osf.S", "status": "modified", "additions": 161, "deletions": 266, "changes": 427, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Falpha%2Fosf.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Falpha%2Fosf.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Falpha%2Fosf.S?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -1,7 +1,7 @@\n /* -----------------------------------------------------------------------\n-   osf.S - Copyright (c) 1998, 2001, 2007, 2008, 2011 Red Hat\n-   \n-   Alpha/OSF Foreign Function Interface \n+   osf.S - Copyright (c) 1998, 2001, 2007, 2008, 2011, 2014 Red Hat\n+\n+   Alpha/OSF Foreign Function Interface\n \n    Permission is hereby granted, free of charge, to any person obtaining\n    a copy of this software and associated documentation files (the\n@@ -24,40 +24,49 @@\n    DEALINGS IN THE SOFTWARE.\n    ----------------------------------------------------------------------- */\n \n-#define LIBFFI_ASM\t\n+#define LIBFFI_ASM\n #include <fficonfig.h>\n #include <ffi.h>\n+#include <ffi_cfi.h>\n+#include \"internal.h\"\n \n \t.arch ev6\n \t.text\n \n-/* ffi_call_osf (void *args, unsigned long bytes, unsigned flags,\n-\t\t void *raddr, void (*fnaddr)(void));\n+/* Aid in building a direct addressed jump table, 4 insns per entry.  */\n+.macro E index\n+\t.align\t4\n+\t.org\t99b + \\index * 16\n+.endm\n+\n+/* ffi_call_osf (void *stack, void *frame, unsigned flags,\n+\t\t void *raddr, void (*fnaddr)(void), void *closure)\n \n-   Bit o trickiness here -- ARGS+BYTES is the base of the stack frame\n+   Bit o trickiness here -- FRAME is the base of the stack frame\n    for this function.  This has been allocated by ffi_call.  We also\n    deallocate some of the stack that has been alloca'd.  */\n \n-\t.align\t3\n+\t.align\t4\n \t.globl\tffi_call_osf\n \t.ent\tffi_call_osf\n \tFFI_HIDDEN(ffi_call_osf)\n \n ffi_call_osf:\n-\t.frame\t$15, 32, $26, 0\n-\t.mask   0x4008000, -32\n-$LFB1:\n-\taddq\t$16,$17,$1\n+\tcfi_startproc\n+\tcfi_def_cfa($17, 32)\n \tmov\t$16, $30\n-\tstq\t$26, 0($1)\n-\tstq\t$15, 8($1)\n-\tstq\t$18, 16($1)\n-\tmov\t$1, $15\n-$LCFI1:\n+\tstq\t$26, 0($17)\n+\tstq\t$15, 8($17)\n+\tmov\t$17, $15\n \t.prologue 0\n+\tcfi_def_cfa_register($15)\n+\tcfi_rel_offset($26, 0)\n+\tcfi_rel_offset($15, 8)\n \n-\tstq\t$19, 24($1)\n-\tmov\t$20, $27\n+\tstq\t$18, 16($17)\t\t# save flags into frame\n+\tstq\t$19, 24($17)\t\t# save rvalue into frame\n+\tmov\t$20, $27\t\t# fn into place for call\n+\tmov\t$21, $1\t\t\t# closure into static chain\n \n \t# Load up all of the (potential) argument registers.\n \tldq\t$16, 0($30)\n@@ -77,311 +86,197 @@ $LCFI1:\n \tlda\t$30, 48($30)\n \n \tjsr\t$26, ($27), 0\n-\tldgp\t$29, 0($26)\n-\n-\t# If the return value pointer is NULL, assume no return value.\n-\tldq\t$19, 24($15)\n-\tldq\t$18, 16($15)\n+0:\n+\tldah\t$29, 0($26)\t\t!gpdisp!1\n+\tldq\t$2, 24($15)\t\t# reload rvalue\n+\tlda\t$29, 0($29)\t\t!gpdisp!1\n+\tldq\t$3, 16($15)\t\t# reload flags\n+\tlda\t$1, 99f-0b($26)\n \tldq\t$26, 0($15)\n-$LCFI2:\n-\tbeq\t$19, $noretval\n-\n-\t# Store the return value out in the proper type.\n-\tcmpeq\t$18, FFI_TYPE_INT, $1\n-\tbne\t$1, $retint\n-\tcmpeq\t$18, FFI_TYPE_FLOAT, $2\n-\tbne\t$2, $retfloat\n-\tcmpeq\t$18, FFI_TYPE_DOUBLE, $3\n-\tbne\t$3, $retdouble\n-\n-\t.align\t3\n-$noretval:\n \tldq\t$15, 8($15)\n-\tret\n+\tcfi_restore($26)\n+\tcfi_restore($15)\n+\tcfi_def_cfa($sp, 0)\n+\tcmoveq\t$2, ALPHA_ST_VOID, $3\t# mash null rvalue to void\n+\taddq\t$3, $3, $3\n+\ts8addq\t$3, $1, $1\t\t# 99f + stcode * 16\n+\tjmp\t$31, ($1), $st_int\n \n \t.align\t4\n-$retint:\n-\tstq\t$0, 0($19)\n-\tnop\n-\tldq\t$15, 8($15)\n+99:\n+E ALPHA_ST_VOID\n \tret\n-\n-\t.align\t4\n-$retfloat:\n-\tsts\t$f0, 0($19)\n-\tnop\n-\tldq\t$15, 8($15)\n+E ALPHA_ST_INT\n+$st_int:\n+\tstq\t$0, 0($2)\n \tret\n-\n-\t.align\t4\n-$retdouble:\n-\tstt\t$f0, 0($19)\n-\tnop\n-\tldq\t$15, 8($15)\n+E ALPHA_ST_FLOAT\n+\tsts\t$f0, 0($2)\n+\tret\n+E ALPHA_ST_DOUBLE\n+\tstt\t$f0, 0($2)\n+\tret\n+E ALPHA_ST_CPLXF\n+\tsts\t$f0, 0($2)\n+\tsts\t$f1, 4($2)\n+\tret\n+E ALPHA_ST_CPLXD\n+\tstt\t$f0, 0($2)\n+\tstt\t$f1, 8($2)\n \tret\n-$LFE1:\n \n+\tcfi_endproc\n \t.end\tffi_call_osf\n \n /* ffi_closure_osf(...)\n \n    Receives the closure argument in $1.   */\n \n-\t.align\t3\n+#define CLOSURE_FS\t(16*8)\n+\n+\t.align\t4\n+\t.globl\tffi_go_closure_osf\n+\t.ent\tffi_go_closure_osf\n+\tFFI_HIDDEN(ffi_go_closure_osf)\n+\n+ffi_go_closure_osf:\n+\tcfi_startproc\n+\tldgp\t$29, 0($27)\n+\tsubq\t$30, CLOSURE_FS, $30\n+\tcfi_adjust_cfa_offset(CLOSURE_FS)\n+\tstq\t$26, 0($30)\n+\t.prologue 1\n+\tcfi_rel_offset($26, 0)\n+\n+\tstq\t$16, 10*8($30)\n+\tstq\t$17, 11*8($30)\n+\tstq\t$18, 12*8($30)\n+\n+\tldq\t$16, 8($1)\t\t\t# load cif\n+\tldq\t$17, 16($1)\t\t\t# load fun\n+\tmov\t$1, $18\t\t\t\t# closure is user_data\n+\tbr\t$do_closure\n+\n+\tcfi_endproc\n+\t.end\tffi_go_closure_osf\n+\n+\t.align\t4\n \t.globl\tffi_closure_osf\n \t.ent\tffi_closure_osf\n \tFFI_HIDDEN(ffi_closure_osf)\n \n ffi_closure_osf:\n-\t.frame\t$30, 16*8, $26, 0\n-\t.mask\t0x4000000, -16*8\n-$LFB2:\n+\tcfi_startproc\n \tldgp\t$29, 0($27)\n-\tsubq\t$30, 16*8, $30\n-$LCFI5:\n+\tsubq\t$30, CLOSURE_FS, $30\n+\tcfi_adjust_cfa_offset(CLOSURE_FS)\n \tstq\t$26, 0($30)\n-$LCFI6:\n \t.prologue 1\n+\tcfi_rel_offset($26, 0)\n \n \t# Store all of the potential argument registers in va_list format.\n-\tstt\t$f16, 4*8($30)\n-\tstt\t$f17, 5*8($30)\n-\tstt\t$f18, 6*8($30)\n-\tstt\t$f19, 7*8($30)\n-\tstt\t$f20, 8*8($30)\n-\tstt\t$f21, 9*8($30)\n \tstq\t$16, 10*8($30)\n \tstq\t$17, 11*8($30)\n \tstq\t$18, 12*8($30)\n+\n+\tldq\t$16, 24($1)\t\t\t# load cif\n+\tldq\t$17, 32($1)\t\t\t# load fun\n+\tldq\t$18, 40($1)\t\t\t# load user_data\n+\n+$do_closure:\n \tstq\t$19, 13*8($30)\n \tstq\t$20, 14*8($30)\n \tstq\t$21, 15*8($30)\n+\tstt\t$f16, 4*8($30)\n+\tstt\t$f17, 5*8($30)\n+\tstt\t$f18, 6*8($30)\n+\tstt\t$f19, 7*8($30)\n+\tstt\t$f20, 8*8($30)\n+\tstt\t$f21, 9*8($30)\n \n \t# Call ffi_closure_osf_inner to do the bulk of the work.\n-\tmov\t$1, $16\n-\tlda\t$17, 2*8($30)\n-\tlda\t$18, 10*8($30)\n+\tlda\t$19, 2*8($30)\n+\tlda\t$20, 10*8($30)\n \tjsr\t$26, ffi_closure_osf_inner\n-\tldgp\t$29, 0($26)\n+0:\n+\tldah\t$29, 0($26)\t\t\t!gpdisp!2\n+\tlda\t$2, 99f-0b($26)\n+\ts4addq\t$0, 0, $1\t\t\t# ldcode * 4\n+\tldq\t$0, 16($30)\t\t\t# preload return value\n+\ts4addq\t$1, $2, $1\t\t\t# 99f + ldcode * 16\n+\tlda\t$29, 0($29)\t\t\t!gpdisp!2\n \tldq\t$26, 0($30)\n-\n-\t# Load up the return value in the proper type.\n-\tlda\t$1, $load_table\n-\ts4addq\t$0, $1, $1\n-\tldl\t$1, 0($1)\n-\taddq\t$1, $29, $1\n+\tcfi_restore($26)\n \tjmp\t$31, ($1), $load_32\n \n-\t.align 4\n-$load_none:\n-\taddq\t$30, 16*8, $30\n+.macro epilogue\n+\taddq\t$30, CLOSURE_FS, $30\n+\tcfi_adjust_cfa_offset(-CLOSURE_FS)\n \tret\n+\t.align\t4\n+\tcfi_adjust_cfa_offset(CLOSURE_FS)\n+.endm\n \n \t.align 4\n-$load_float:\n-\tlds\t$f0, 16($30)\n-\tnop\n-\taddq\t$30, 16*8, $30\n-\tret\n+99:\n+E ALPHA_LD_VOID\n+\tepilogue\n \n-\t.align 4\n-$load_double:\n-\tldt\t$f0, 16($30)\n-\tnop\n-\taddq\t$30, 16*8, $30\n-\tret\n+E ALPHA_LD_INT64\n+\tepilogue\n \n-\t.align 4\n-$load_u8:\n+E ALPHA_LD_INT32\n+$load_32:\n+\tsextl\t$0, $0\n+\tepilogue\n+\n+E ALPHA_LD_UINT16\n+\tzapnot\t$0, 3, $0\n+\tepilogue\n+\n+E ALPHA_LD_SINT16\n #ifdef __alpha_bwx__\n-\tldbu\t$0, 16($30)\n-\tnop\n+\tsextw\t$0, $0\n #else\n-\tldq\t$0, 16($30)\n-\tand\t$0, 255, $0\n+\tsll\t$0, 48, $0\n+\tsra\t$0, 48, $0\n #endif\n-\taddq\t$30, 16*8, $30\n-\tret\n+\tepilogue\n \n-\t.align 4\n-$load_s8:\n+E ALPHA_LD_UINT8\n+\tand\t$0, 0xff, $0\n+\tepilogue\n+\n+E ALPHA_LD_SINT8\n #ifdef __alpha_bwx__\n-\tldbu\t$0, 16($30)\n \tsextb\t$0, $0\n #else\n-\tldq\t$0, 16($30)\n \tsll\t$0, 56, $0\n \tsra\t$0, 56, $0\n #endif\n-\taddq\t$30, 16*8, $30\n-\tret\n+\tepilogue\n \n-\t.align 4\n-$load_u16:\n-#ifdef __alpha_bwx__\n-\tldwu\t$0, 16($30)\n-\tnop\n-#else\n-\tldq\t$0, 16($30)\n-\tzapnot\t$0, 3, $0\n-#endif\n-\taddq\t$30, 16*8, $30\n-\tret\n+E ALPHA_LD_FLOAT\n+\tlds\t$f0, 16($sp)\n+\tepilogue\n \n-\t.align 4\n-$load_s16:\n-#ifdef __alpha_bwx__\n-\tldwu\t$0, 16($30)\n-\tsextw\t$0, $0\n-#else\n-\tldq\t$0, 16($30)\n-\tsll\t$0, 48, $0\n-\tsra\t$0, 48, $0\n-#endif\n-\taddq\t$30, 16*8, $30\n-\tret\n+E ALPHA_LD_DOUBLE\n+\tldt\t$f0, 16($sp)\n+\tepilogue\n \n-\t.align 4\n-$load_32:\n-\tldl\t$0, 16($30)\n-\tnop\n-\taddq\t$30, 16*8, $30\n-\tret\n+E ALPHA_LD_CPLXF\n+\tlds\t$f0, 16($sp)\n+\tlds\t$f1, 20($sp)\n+\tepilogue\n \n-\t.align 4\n-$load_64:\n-\tldq\t$0, 16($30)\n-\tnop\n-\taddq\t$30, 16*8, $30\n-\tret\n-$LFE2:\n+E ALPHA_LD_CPLXD\n+\tldt\t$f0, 16($sp)\n+\tldt\t$f1, 24($sp)\n+\tepilogue\n \n+\tcfi_endproc\n \t.end\tffi_closure_osf\n \n-#ifdef __ELF__\n-.section .rodata\n-#else\n-.rdata\n-#endif\n-$load_table:\n-\t.gprel32 $load_none\t# FFI_TYPE_VOID\n-\t.gprel32 $load_32\t# FFI_TYPE_INT\n-\t.gprel32 $load_float\t# FFI_TYPE_FLOAT\n-\t.gprel32 $load_double\t# FFI_TYPE_DOUBLE\n-\t.gprel32 $load_none\t# FFI_TYPE_LONGDOUBLE\n-\t.gprel32 $load_u8\t# FFI_TYPE_UINT8\n-\t.gprel32 $load_s8\t# FFI_TYPE_SINT8\n-\t.gprel32 $load_u16\t# FFI_TYPE_UINT16\n-\t.gprel32 $load_s16\t# FFI_TYPE_SINT16\n-\t.gprel32 $load_32\t# FFI_TYPE_UINT32\n-\t.gprel32 $load_32\t# FFI_TYPE_SINT32\n-\t.gprel32 $load_64\t# FFI_TYPE_UINT64\n-\t.gprel32 $load_64\t# FFI_TYPE_SINT64\n-\t.gprel32 $load_none\t# FFI_TYPE_STRUCT\n-\t.gprel32 $load_64\t# FFI_TYPE_POINTER\n-\n-/* Assert that the table above is in sync with ffi.h.  */\n-\n-#if\t   FFI_TYPE_FLOAT != 2\t\t\\\n-\t|| FFI_TYPE_DOUBLE != 3\t\t\\\n-\t|| FFI_TYPE_UINT8 != 5\t\t\\\n-\t|| FFI_TYPE_SINT8 != 6\t\t\\\n-\t|| FFI_TYPE_UINT16 != 7\t\t\\\n-\t|| FFI_TYPE_SINT16 != 8\t\t\\\n-\t|| FFI_TYPE_UINT32 != 9\t\t\\\n-\t|| FFI_TYPE_SINT32 != 10\t\\\n-\t|| FFI_TYPE_UINT64 != 11\t\\\n-\t|| FFI_TYPE_SINT64 != 12\t\\\n-\t|| FFI_TYPE_STRUCT != 13\t\\\n-\t|| FFI_TYPE_POINTER != 14\t\\\n-\t|| FFI_TYPE_LAST != 14\n-#error \"osf.S out of sync with ffi.h\"\n-#endif\n-\n-#ifdef __ELF__\n-# define UA_SI\t\t.4byte\n-# define FDE_ENCODING\t0x1b\t/* pcrel sdata4 */\n-# define FDE_ENCODE(X)\t.4byte X-.\n-# define FDE_ARANGE(X)\t.4byte X\n-#elif defined __osf__\n-# define UA_SI\t\t.align 0; .long\n-# define FDE_ENCODING\t0x50\t/* aligned absolute */\n-# define FDE_ENCODE(X)\t.align 3; .quad X\n-# define FDE_ARANGE(X)\t.align 0; .quad X\n-#endif\n-\n-#ifdef __ELF__\n-\t.section\t.eh_frame,EH_FRAME_FLAGS,@progbits\n-#elif defined __osf__\n-\t.data\n-\t.align 3\n-\t.globl _GLOBAL__F_ffi_call_osf\n-_GLOBAL__F_ffi_call_osf:\n-#endif\n-__FRAME_BEGIN__:\n-\tUA_SI\t$LECIE1-$LSCIE1\t# Length of Common Information Entry\n-$LSCIE1:\n-\tUA_SI\t0x0\t\t# CIE Identifier Tag\n-\t.byte\t0x1\t\t# CIE Version\n-\t.ascii \"zR\\0\"\t\t# CIE Augmentation\n-\t.byte\t0x1\t\t# uleb128 0x1; CIE Code Alignment Factor\n-\t.byte\t0x78\t\t# sleb128 -8; CIE Data Alignment Factor\n-\t.byte\t26\t\t# CIE RA Column\n-\t.byte\t0x1\t\t# uleb128 0x1; Augmentation size\n-\t.byte\tFDE_ENCODING\t# FDE Encoding\n-\t.byte\t0xc\t\t# DW_CFA_def_cfa\n-\t.byte\t30\t\t# uleb128 column 30\n-\t.byte\t0\t\t# uleb128 offset 0\n-\t.align 3\n-$LECIE1:\n-$LSFDE1:\n-\tUA_SI\t$LEFDE1-$LASFDE1\t\t# FDE Length\n-$LASFDE1:\n-\tUA_SI\t$LASFDE1-__FRAME_BEGIN__\t# FDE CIE offset\n-\tFDE_ENCODE($LFB1)\t\t\t# FDE initial location\n-\tFDE_ARANGE($LFE1-$LFB1)\t\t\t# FDE address range\n-\t.byte\t0x0\t\t# uleb128 0x0; Augmentation size\n-\n-\t.byte\t0x4\t\t# DW_CFA_advance_loc4\n-\tUA_SI\t$LCFI1-$LFB1\n-\t.byte\t0x9a\t\t# DW_CFA_offset, column 26\n-\t.byte\t4\t\t# uleb128 4*-8\n-\t.byte\t0x8f\t\t# DW_CFA_offset, column 15\n-\t.byte\t0x3\t\t# uleb128 3*-8\n-\t.byte\t0xc\t\t# DW_CFA_def_cfa\n-\t.byte\t15\t\t# uleb128 column 15\n-\t.byte\t32\t\t# uleb128 offset 32\n-\n-\t.byte\t0x4\t\t# DW_CFA_advance_loc4\n-\tUA_SI\t$LCFI2-$LCFI1\n-\t.byte\t0xda\t\t# DW_CFA_restore, column 26\n-\t.align 3\n-$LEFDE1:\n-\n-$LSFDE3:\n-\tUA_SI\t$LEFDE3-$LASFDE3\t\t# FDE Length\n-$LASFDE3:\n-\tUA_SI\t$LASFDE3-__FRAME_BEGIN__\t# FDE CIE offset\n-\tFDE_ENCODE($LFB2)\t\t\t# FDE initial location\n-\tFDE_ARANGE($LFE2-$LFB2)\t\t\t# FDE address range\n-\t.byte\t0x0\t\t# uleb128 0x0; Augmentation size\n-\n-\t.byte\t0x4\t\t# DW_CFA_advance_loc4\n-\tUA_SI\t$LCFI5-$LFB2\n-\t.byte\t0xe\t\t# DW_CFA_def_cfa_offset\n-\t.byte\t0x80,0x1\t# uleb128 128\n-\n-\t.byte\t0x4\t\t# DW_CFA_advance_loc4\n-\tUA_SI\t$LCFI6-$LCFI5\n-\t.byte\t0x9a\t\t# DW_CFA_offset, column 26\n-\t.byte\t16\t\t# uleb128 offset 16*-8\n-\t.align 3\n-$LEFDE3:\n-#if defined __osf__\n-\t.align 0\n-\t.long\t0\t\t# End of Table\n-#endif\n-\n #if defined __ELF__ && defined __linux__\n \t.section\t.note.GNU-stack,\"\",@progbits\n #endif"}, {"sha": "03715fde49f7a1ff02c82be3b09362cf0b871e17", "filename": "libffi/src/arc/arcompact.S", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Farc%2Farcompact.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Farc%2Farcompact.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farc%2Farcompact.S?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -0,0 +1,135 @@\n+/* -----------------------------------------------------------------------\n+   arcompact.S - Copyright (c) 2013 Synposys, Inc. (www.synopsys.com)\n+   \n+   ARCompact Foreign Function Interface \n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL RENESAS TECHNOLOGY BE LIABLE FOR ANY CLAIM, DAMAGES OR\n+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+   OTHER DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#define LIBFFI_ASM\n+#include <fficonfig.h>\n+#include <ffi.h>\n+#ifdef HAVE_MACHINE_ASM_H\n+#include <machine/asm.h>\n+#else\n+#define CNAME(x) x\n+#define ENTRY(x) .globl CNAME(x)` .type CNAME(x),%function` CNAME(x):\n+#endif\n+\n+.text\n+\n+        /* R0:   ffi_prep_args */\n+        /* R1:   &ecif */\n+        /* R2:   cif->bytes */\n+        /* R3:   fig->flags */\n+        /* R4:   ecif.rvalue */\n+        /* R5:   fn */\n+ENTRY(ffi_call_ARCompact)\n+        /* Save registers.  */\n+        st.a       fp, [sp, -4]        /* fp + 20, fp */\n+        push_s     blink               /* fp + 16, blink */\n+        st.a       r4, [sp, -4]        /* fp + 12, ecif.rvalue */\n+        push_s     r3                  /* fp +  8, fig->flags */\n+        st.a       r5, [sp, -4]        /* fp +  4, fn */\n+        push_s     r2                  /* fp +  0, cif->bytes */\n+        mov        fp, sp\n+\n+        /* Make room for all of the new args.  */\n+        sub        sp, sp, r2\n+\n+        /* Place all of the ffi_prep_args in position.  */\n+        /* ffi_prep_args(char *stack, extended_cif *ecif) */\n+        /* R1 already set.  */\n+\n+        /* And call.  */\n+        jl_s.d     [r0]\n+        mov_s      r0, sp\n+\n+        ld.ab      r12, [fp, 4]        /* cif->bytes */\n+        ld.ab      r11, [fp, 4]        /* fn */\n+\n+        /* Move first 8 parameters in registers...  */\n+        ld_s       r0, [sp]\n+        ld_s       r1, [sp, 4]\n+        ld_s       r2, [sp, 8]\n+        ld_s       r3, [sp, 12]\n+        ld         r4, [sp, 16]\n+        ld         r5, [sp, 20]\n+        ld         r6, [sp, 24]\n+        ld         r7, [sp, 28]\n+\n+        /* ...and adjust the stack.  */\n+        min        r12, r12, 32\n+\n+        /* Call the function.  */\n+        jl.d       [r11]\n+        add        sp, sp, r12 \n+\n+        mov        sp, fp        \n+        pop_s      r3        /* fig->flags, return type */\n+        pop_s      r2        /* ecif.rvalue, pointer for return value */\n+\n+        /* If the return value pointer is NULL, assume no return value.  */\n+        breq.d     r2, 0, epilogue\n+        pop_s      blink\n+\n+        /* Return INT.  */\n+        brne       r3, FFI_TYPE_INT, return_double\n+        b.d        epilogue\n+        st_s       r0, [r2]        \n+\n+return_double:\n+        brne       r3, FFI_TYPE_DOUBLE, epilogue\n+        st_s       r0, [r2]        \n+        st_s       r1, [r2,4]\n+\n+epilogue:\n+        j_s.d      [blink]\n+        ld.ab      fp, [sp, 4]\n+\n+ENTRY(ffi_closure_ARCompact)\n+        st.a       r0, [sp, -32]\n+        st_s       r1, [sp, 4]\n+        st_s       r2, [sp, 8]\n+        st_s       r3, [sp, 12]\n+        st         r4, [sp, 16]\n+        st         r5, [sp, 20]\n+        st         r6, [sp, 24]\n+        st         r7, [sp, 28]\n+\n+        /* pointer to arguments */\n+        mov_s      r2, sp\n+\n+        /* return value goes here */\n+        sub        sp, sp, 8\n+        mov_s      r1, sp\n+\n+        push_s     blink\n+        \n+        bl.d       ffi_closure_inner_ARCompact\n+        mov_s      r0, r8                /* codeloc, set by trampoline */\n+\n+        pop_s      blink\n+\n+        /* set return value to r1:r0 */\n+        pop_s      r0\n+        pop_s      r1\n+        j_s.d      [blink]\n+        add_s      sp, sp, 32"}, {"sha": "32f82a7d5bb54fcb674c43590f4d9bfa646e69ad", "filename": "libffi/src/arc/ffi.c", "status": "added", "additions": 268, "deletions": 0, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Farc%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Farc%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farc%2Fffi.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -0,0 +1,268 @@\n+/* -----------------------------------------------------------------------\n+   ffi.c - Copyright (c) 2013  Synopsys, Inc. (www.synopsys.com)\n+   \n+   ARC Foreign Function Interface \n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL RENESAS TECHNOLOGY BE LIABLE FOR ANY CLAIM, DAMAGES OR\n+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+   OTHER DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#include <ffi.h>\n+#include <ffi_common.h>\n+\n+#include <stdlib.h>\n+#include <stdint.h>\n+\n+#include <sys/cachectl.h>\n+\n+/* for little endian ARC, the code is in fact stored as mixed endian for\n+   performance reasons */\n+#if __BIG_ENDIAN__\n+#define CODE_ENDIAN(x) (x)\n+#else\n+#define CODE_ENDIAN(x) ( (((uint32_t) (x)) << 16) | (((uint32_t) (x)) >> 16))\n+#endif\n+\n+/* ffi_prep_args is called by the assembly routine once stack\n+   space has been allocated for the function's arguments.  */\n+\n+void\n+ffi_prep_args (char *stack, extended_cif * ecif)\n+{\n+  unsigned int i;\n+  int tmp;\n+  void **p_argv;\n+  char *argp;\n+  ffi_type **p_arg;\n+\n+  tmp = 0;\n+  argp = stack;\n+\n+  if (ecif->cif->rtype->type == FFI_TYPE_STRUCT)\n+    {\n+      *(void **) argp = ecif->rvalue;\n+      argp += 4;\n+    }\n+\n+  p_argv = ecif->avalue;\n+\n+  for (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types;\n+       (i != 0); i--, p_arg++)\n+    {\n+      size_t z;\n+      int alignment;\n+\n+      /* align alignment to 4 */\n+      alignment = (((*p_arg)->alignment - 1) | 3) + 1;\n+\n+      /* Align if necessary.  */\n+      if ((alignment - 1) & (unsigned) argp)\n+\targp = (char *) ALIGN (argp, alignment);\n+\n+      z = (*p_arg)->size;\n+      if (z < sizeof (int))\n+\t{\n+\t  z = sizeof (int);\n+\n+\t  switch ((*p_arg)->type)\n+\t    {\n+\t    case FFI_TYPE_SINT8:\n+\t      *(signed int *) argp = (signed int) *(SINT8 *) (*p_argv);\n+\t      break;\n+\n+\t    case FFI_TYPE_UINT8:\n+\t      *(unsigned int *) argp = (unsigned int) *(UINT8 *) (*p_argv);\n+\t      break;\n+\n+\t    case FFI_TYPE_SINT16:\n+\t      *(signed int *) argp = (signed int) *(SINT16 *) (*p_argv);\n+\t      break;\n+\n+\t    case FFI_TYPE_UINT16:\n+\t      *(unsigned int *) argp = (unsigned int) *(UINT16 *) (*p_argv);\n+\t      break;\n+\n+\t    case FFI_TYPE_STRUCT:\n+\t      memcpy (argp, *p_argv, (*p_arg)->size);\n+\t      break;\n+\n+\t    default:\n+\t      FFI_ASSERT (0);\n+\t    }\n+\t}\n+      else if (z == sizeof (int))\n+\t{\n+\t  *(unsigned int *) argp = (unsigned int) *(UINT32 *) (*p_argv);\n+\t}\n+      else\n+\t{\n+\t  if ((*p_arg)->type == FFI_TYPE_STRUCT)\n+\t    {\n+\t      memcpy (argp, *p_argv, z);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Double or long long 64bit.  */\n+\t      memcpy (argp, *p_argv, z);\n+\t    }\n+\t}\n+      p_argv++;\n+      argp += z;\n+    }\n+\n+  return;\n+}\n+\n+/* Perform machine dependent cif processing.  */\n+ffi_status\n+ffi_prep_cif_machdep (ffi_cif * cif)\n+{\n+  /* Set the return type flag.  */\n+  switch (cif->rtype->type)\n+    {\n+    case FFI_TYPE_VOID:\n+      cif->flags = (unsigned) cif->rtype->type;\n+      break;\n+\n+    case FFI_TYPE_STRUCT:\n+      cif->flags = (unsigned) cif->rtype->type;\n+      break;\n+\n+    case FFI_TYPE_SINT64:\n+    case FFI_TYPE_UINT64:\n+    case FFI_TYPE_DOUBLE:\n+      cif->flags = FFI_TYPE_DOUBLE;\n+      break;\n+\n+    case FFI_TYPE_FLOAT:\n+    default:\n+      cif->flags = FFI_TYPE_INT;\n+      break;\n+    }\n+\n+  return FFI_OK;\n+}\n+\n+extern void ffi_call_ARCompact (void (*)(char *, extended_cif *),\n+\t\t\t\textended_cif *, unsigned, unsigned,\n+\t\t\t\tunsigned *, void (*fn) (void));\n+\n+void\n+ffi_call (ffi_cif * cif, void (*fn) (void), void *rvalue, void **avalue)\n+{\n+  extended_cif ecif;\n+\n+  ecif.cif = cif;\n+  ecif.avalue = avalue;\n+\n+  /* If the return value is a struct and we don't have\n+     a return value address then we need to make one.  */\n+  if ((rvalue == NULL) && (cif->rtype->type == FFI_TYPE_STRUCT))\n+    {\n+      ecif.rvalue = alloca (cif->rtype->size);\n+    }\n+  else\n+    ecif.rvalue = rvalue;\n+\n+  switch (cif->abi)\n+    {\n+    case FFI_ARCOMPACT:\n+      ffi_call_ARCompact (ffi_prep_args, &ecif, cif->bytes,\n+\t\t\t  cif->flags, ecif.rvalue, fn);\n+      break;\n+\n+    default:\n+      FFI_ASSERT (0);\n+      break;\n+    }\n+}\n+\n+int\n+ffi_closure_inner_ARCompact (ffi_closure * closure, void *rvalue,\n+\t\t\t     ffi_arg * args)\n+{\n+  void **arg_area, **p_argv;\n+  ffi_cif *cif = closure->cif;\n+  char *argp = (char *) args;\n+  ffi_type **p_argt;\n+  int i;\n+\n+  arg_area = (void **) alloca (cif->nargs * sizeof (void *));\n+\n+  /* handle hidden argument */\n+  if (cif->flags == FFI_TYPE_STRUCT)\n+    {\n+      rvalue = *(void **) argp;\n+      argp += 4;\n+    }\n+\n+  p_argv = arg_area;\n+\n+  for (i = 0, p_argt = cif->arg_types; i < cif->nargs;\n+       i++, p_argt++, p_argv++)\n+    {\n+      size_t z;\n+      int alignment;\n+\n+      /* align alignment to 4 */\n+      alignment = (((*p_argt)->alignment - 1) | 3) + 1;\n+\n+      /* Align if necessary.  */\n+      if ((alignment - 1) & (unsigned) argp)\n+\targp = (char *) ALIGN (argp, alignment);\n+\n+      z = (*p_argt)->size;\n+      *p_argv = (void *) argp;\n+      argp += z;\n+    }\n+\n+  (closure->fun) (cif, rvalue, arg_area, closure->user_data);\n+\n+  return cif->flags;\n+}\n+\n+extern void ffi_closure_ARCompact (void);\n+\n+ffi_status\n+ffi_prep_closure_loc (ffi_closure * closure, ffi_cif * cif,\n+\t\t      void (*fun) (ffi_cif *, void *, void **, void *),\n+\t\t      void *user_data, void *codeloc)\n+{\n+  uint32_t *tramp = (uint32_t *) & (closure->tramp[0]);\n+\n+  switch (cif->abi)\n+    {\n+    case FFI_ARCOMPACT:\n+      FFI_ASSERT (tramp == codeloc);\n+      tramp[0] = CODE_ENDIAN (0x200a1fc0);\t/* mov r8, pcl  */\n+      tramp[1] = CODE_ENDIAN (0x20200f80);\t/* j [long imm] */\n+      tramp[2] = CODE_ENDIAN (ffi_closure_ARCompact);\n+      break;\n+\n+    default:\n+      return FFI_BAD_ABI;\n+    }\n+\n+  closure->cif = cif;\n+  closure->fun = fun;\n+  closure->user_data = user_data;\n+  cacheflush (codeloc, FFI_TRAMPOLINE_SIZE, BCACHE);\n+\n+  return FFI_OK;\n+}"}, {"sha": "bf8311bc832c52a64c31784c496c49e820d041d8", "filename": "libffi/src/arc/ffitarget.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Farc%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Farc%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farc%2Fffitarget.h?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -0,0 +1,53 @@\n+/* -----------------------------------------------------------------------\n+   ffitarget.h - Copyright (c) 2012  Anthony Green\n+                 Copyright (c) 2013  Synopsys, Inc. (www.synopsys.com)\n+   Target configuration macros for ARC.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL RENESAS TECHNOLOGY BE LIABLE FOR ANY CLAIM, DAMAGES OR\n+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+   OTHER DEALINGS IN THE SOFTWARE.\n+\n+   ----------------------------------------------------------------------- */\n+\n+#ifndef LIBFFI_TARGET_H\n+#define LIBFFI_TARGET_H\n+\n+#ifndef LIBFFI_H\n+#error \"Please do not include ffitarget.h directly into your source.  Use ffi.h instead.\"\n+#endif\n+\n+/* ---- Generic type definitions ----------------------------------------- */\n+\n+#ifndef LIBFFI_ASM\n+typedef unsigned long ffi_arg;\n+typedef signed long ffi_sarg;\n+\n+typedef enum ffi_abi\n+{\n+  FFI_FIRST_ABI = 0,\n+  FFI_ARCOMPACT,\n+  FFI_LAST_ABI,\n+  FFI_DEFAULT_ABI = FFI_ARCOMPACT\n+} ffi_abi;\n+#endif\n+\n+#define FFI_CLOSURES \t\t1\n+#define FFI_TRAMPOLINE_SIZE\t12\n+#define FFI_NATIVE_RAW_API \t0\n+\n+#endif"}, {"sha": "9c8732d158cd1573544e095cd5e568e7c4a1e9f3", "filename": "libffi/src/arm/ffi.c", "status": "modified", "additions": 714, "deletions": 427, "changes": 1141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Farm%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Farm%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farm%2Fffi.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -4,8 +4,8 @@\n            Copyright (c) 2011 Anthony Green\n \t   Copyright (c) 2011 Free Software Foundation\n            Copyright (c) 1998, 2008, 2011  Red Hat, Inc.\n-\t   \n-   ARM Foreign Function Interface \n+\n+   ARM Foreign Function Interface\n \n    Permission is hereby granted, free of charge, to any person obtaining\n    a copy of this software and associated documentation files (the\n@@ -30,343 +30,505 @@\n \n #include <ffi.h>\n #include <ffi_common.h>\n-\n #include <stdlib.h>\n+#include \"internal.h\"\n \n /* Forward declares. */\n-static int vfp_type_p (ffi_type *);\n+static int vfp_type_p (const ffi_type *);\n static void layout_vfp_args (ffi_cif *);\n \n-/* ffi_prep_args is called by the assembly routine once stack space\n-   has been allocated for the function's arguments\n-   \n+static void *\n+ffi_align (ffi_type *ty, void *p)\n+{\n+  /* Align if necessary */\n+  size_t alignment;\n+#ifdef _WIN32_WCE\n+  alignment = 4;\n+#else\n+  alignment = ty->alignment;\n+  if (alignment < 4)\n+    alignment = 4;\n+#endif\n+  return (void *) ALIGN (p, alignment);\n+}\n+\n+static size_t\n+ffi_put_arg (ffi_type *ty, void *src, void *dst)\n+{\n+  size_t z = ty->size;\n+\n+  switch (ty->type)\n+    {\n+    case FFI_TYPE_SINT8:\n+      *(UINT32 *)dst = *(SINT8 *)src;\n+      break;\n+    case FFI_TYPE_UINT8:\n+      *(UINT32 *)dst = *(UINT8 *)src;\n+      break;\n+    case FFI_TYPE_SINT16:\n+      *(UINT32 *)dst = *(SINT16 *)src;\n+      break;\n+    case FFI_TYPE_UINT16:\n+      *(UINT32 *)dst = *(UINT16 *)src;\n+      break;\n+\n+    case FFI_TYPE_INT:\n+    case FFI_TYPE_SINT32:\n+    case FFI_TYPE_UINT32:\n+    case FFI_TYPE_POINTER:\n+    case FFI_TYPE_FLOAT:\n+      *(UINT32 *)dst = *(UINT32 *)src;\n+      break;\n+\n+    case FFI_TYPE_SINT64:\n+    case FFI_TYPE_UINT64:\n+    case FFI_TYPE_DOUBLE:\n+      *(UINT64 *)dst = *(UINT64 *)src;\n+      break;\n+\n+    case FFI_TYPE_STRUCT:\n+    case FFI_TYPE_COMPLEX:\n+      memcpy (dst, src, z);\n+      break;\n+\n+    default:\n+      abort();\n+    }\n+\n+  return ALIGN (z, 4);\n+}\n+\n+/* ffi_prep_args is called once stack space has been allocated\n+   for the function's arguments.\n+\n    The vfp_space parameter is the load area for VFP regs, the return\n    value is cif->vfp_used (word bitset of VFP regs used for passing\n    arguments). These are only used for the VFP hard-float ABI.\n */\n-int ffi_prep_args(char *stack, extended_cif *ecif, float *vfp_space)\n+static void\n+ffi_prep_args_SYSV (ffi_cif *cif, int flags, void *rvalue,\n+\t\t    void **avalue, char *argp)\n {\n-  register unsigned int i, vi = 0;\n-  register void **p_argv;\n-  register char *argp;\n-  register ffi_type **p_arg;\n+  ffi_type **arg_types = cif->arg_types;\n+  int i, n;\n \n-  argp = stack;\n+  if (flags == ARM_TYPE_STRUCT)\n+    {\n+      *(void **) argp = rvalue;\n+      argp += 4;\n+    }\n \n-  if ( ecif->cif->flags == FFI_TYPE_STRUCT ) {\n-    *(void **) argp = ecif->rvalue;\n-    argp += 4;\n-  }\n+  for (i = 0, n = cif->nargs; i < n; i++)\n+    {\n+      ffi_type *ty = arg_types[i];\n+      argp = ffi_align (ty, argp);\n+      argp += ffi_put_arg (ty, avalue[i], argp);\n+    }\n+}\n \n-  p_argv = ecif->avalue;\n+static void\n+ffi_prep_args_VFP (ffi_cif *cif, int flags, void *rvalue,\n+                   void **avalue, char *stack, char *vfp_space)\n+{\n+  ffi_type **arg_types = cif->arg_types;\n+  int i, n, vi = 0;\n+  char *argp, *regp, *eo_regp;\n+  char stack_used = 0;\n+  char done_with_regs = 0;\n+\n+  /* The first 4 words on the stack are used for values\n+     passed in core registers.  */\n+  regp = stack;\n+  eo_regp = argp = regp + 16;\n+\n+  /* If the function returns an FFI_TYPE_STRUCT in memory,\n+     that address is passed in r0 to the function.  */\n+  if (flags == ARM_TYPE_STRUCT)\n+    {\n+      *(void **) regp = rvalue;\n+      regp += 4;\n+    }\n \n-  for (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types;\n-       (i != 0);\n-       i--, p_arg++)\n+  for (i = 0, n = cif->nargs; i < n; i++)\n     {\n-      size_t z;\n-      size_t alignment;\n+      ffi_type *ty = arg_types[i];\n+      void *a = avalue[i];\n+      int is_vfp_type = vfp_type_p (ty);\n \n       /* Allocated in VFP registers. */\n-      if (ecif->cif->abi == FFI_VFP\n-\t  && vi < ecif->cif->vfp_nargs && vfp_type_p (*p_arg))\n+      if (vi < cif->vfp_nargs && is_vfp_type)\n \t{\n-\t  float* vfp_slot = vfp_space + ecif->cif->vfp_args[vi++];\n-\t  if ((*p_arg)->type == FFI_TYPE_FLOAT)\n-\t    *((float*)vfp_slot) = *((float*)*p_argv);\n-\t  else if ((*p_arg)->type == FFI_TYPE_DOUBLE)\n-\t    *((double*)vfp_slot) = *((double*)*p_argv);\n-\t  else\n-\t    memcpy(vfp_slot, *p_argv, (*p_arg)->size);\n-\t  p_argv++;\n+\t  char *vfp_slot = vfp_space + cif->vfp_args[vi++] * 4;\n+\t  ffi_put_arg (ty, a, vfp_slot);\n \t  continue;\n \t}\n-\n-      /* Align if necessary */\n-      alignment = (*p_arg)->alignment;\n-#ifdef _WIN32_WCE\n-      if (alignment > 4)\n-\talignment = 4;\n-#endif\n-      if ((alignment - 1) & (unsigned) argp) {\n-\targp = (char *) ALIGN(argp, alignment);\n-      }\n-\n-      if ((*p_arg)->type == FFI_TYPE_STRUCT)\n-\targp = (char *) ALIGN(argp, 4);\n-\n-\t  z = (*p_arg)->size;\n-\t  if (z < sizeof(int))\n-\t    {\n-\t      z = sizeof(int);\n-\t      switch ((*p_arg)->type)\n-\t\t{\n-\t\tcase FFI_TYPE_SINT8:\n-\t\t  *(signed int *) argp = (signed int)*(SINT8 *)(* p_argv);\n-\t\t  break;\n-\t\t  \n-\t\tcase FFI_TYPE_UINT8:\n-\t\t  *(unsigned int *) argp = (unsigned int)*(UINT8 *)(* p_argv);\n-\t\t  break;\n-\t\t  \n-\t\tcase FFI_TYPE_SINT16:\n-\t\t  *(signed int *) argp = (signed int)*(SINT16 *)(* p_argv);\n-\t\t  break;\n-\t\t  \n-\t\tcase FFI_TYPE_UINT16:\n-\t\t  *(unsigned int *) argp = (unsigned int)*(UINT16 *)(* p_argv);\n-\t\t  break;\n-\t\t  \n-\t\tcase FFI_TYPE_STRUCT:\n-\t\t  memcpy(argp, *p_argv, (*p_arg)->size);\n-\t\t  break;\n-\n-\t\tdefault:\n-\t\t  FFI_ASSERT(0);\n-\t\t}\n-\t    }\n-\t  else if (z == sizeof(int))\n+      /* Try allocating in core registers. */\n+      else if (!done_with_regs && !is_vfp_type)\n+\t{\n+\t  char *tregp = ffi_align (ty, regp);\n+\t  size_t size = ty->size;\n+\t  size = (size < 4) ? 4 : size;\t// pad\n+\t  /* Check if there is space left in the aligned register\n+\t     area to place the argument.  */\n+\t  if (tregp + size <= eo_regp)\n \t    {\n-\t      *(unsigned int *) argp = (unsigned int)*(UINT32 *)(* p_argv);\n+\t      regp = tregp + ffi_put_arg (ty, a, tregp);\n+\t      done_with_regs = (regp == argp);\n+\t      // ensure we did not write into the stack area\n+\t      FFI_ASSERT (regp <= argp);\n+\t      continue;\n \t    }\n-\t  else\n+\t  /* In case there are no arguments in the stack area yet,\n+\t     the argument is passed in the remaining core registers\n+\t     and on the stack.  */\n+\t  else if (!stack_used)\n \t    {\n-\t      memcpy(argp, *p_argv, z);\n+\t      stack_used = 1;\n+\t      done_with_regs = 1;\n+\t      argp = tregp + ffi_put_arg (ty, a, tregp);\n+\t      FFI_ASSERT (eo_regp < argp);\n+\t      continue;\n \t    }\n-\t  p_argv++;\n-\t  argp += z;\n+\t}\n+      /* Base case, arguments are passed on the stack */\n+      stack_used = 1;\n+      argp = ffi_align (ty, argp);\n+      argp += ffi_put_arg (ty, a, argp);\n     }\n-\n-  /* Indicate the VFP registers used. */\n-  return ecif->cif->vfp_used;\n }\n \n /* Perform machine dependent cif processing */\n-ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n+ffi_status\n+ffi_prep_cif_machdep (ffi_cif *cif)\n {\n-  int type_code;\n-  /* Round the stack up to a multiple of 8 bytes.  This isn't needed \n-     everywhere, but it is on some platforms, and it doesn't harm anything\n-     when it isn't needed.  */\n-  cif->bytes = (cif->bytes + 7) & ~7;\n+  int flags = 0, cabi = cif->abi;\n+  size_t bytes = cif->bytes;\n+\n+  /* Map out the register placements of VFP register args.  The VFP\n+     hard-float calling conventions are slightly more sophisticated\n+     than the base calling conventions, so we do it here instead of\n+     in ffi_prep_args(). */\n+  if (cabi == FFI_VFP)\n+    layout_vfp_args (cif);\n \n   /* Set the return type flag */\n   switch (cif->rtype->type)\n     {\n     case FFI_TYPE_VOID:\n-    case FFI_TYPE_FLOAT:\n-    case FFI_TYPE_DOUBLE:\n-      cif->flags = (unsigned) cif->rtype->type;\n+      flags = ARM_TYPE_VOID;\n+      break;\n+\n+    case FFI_TYPE_INT:\n+    case FFI_TYPE_UINT8:\n+    case FFI_TYPE_SINT8:\n+    case FFI_TYPE_UINT16:\n+    case FFI_TYPE_SINT16:\n+    case FFI_TYPE_UINT32:\n+    case FFI_TYPE_SINT32:\n+    case FFI_TYPE_POINTER:\n+      flags = ARM_TYPE_INT;\n       break;\n \n     case FFI_TYPE_SINT64:\n     case FFI_TYPE_UINT64:\n-      cif->flags = (unsigned) FFI_TYPE_SINT64;\n+      flags = ARM_TYPE_INT64;\n+      break;\n+\n+    case FFI_TYPE_FLOAT:\n+      flags = (cabi == FFI_VFP ? ARM_TYPE_VFP_S : ARM_TYPE_INT);\n+      break;\n+    case FFI_TYPE_DOUBLE:\n+      flags = (cabi == FFI_VFP ? ARM_TYPE_VFP_D : ARM_TYPE_INT64);\n       break;\n \n     case FFI_TYPE_STRUCT:\n-      if (cif->abi == FFI_VFP\n-\t  && (type_code = vfp_type_p (cif->rtype)) != 0)\n+    case FFI_TYPE_COMPLEX:\n+      if (cabi == FFI_VFP)\n \t{\n-\t  /* A Composite Type passed in VFP registers, either\n-\t     FFI_TYPE_STRUCT_VFP_FLOAT or FFI_TYPE_STRUCT_VFP_DOUBLE. */\n-\t  cif->flags = (unsigned) type_code;\n+\t  int h = vfp_type_p (cif->rtype);\n+\n+\t  flags = ARM_TYPE_VFP_N;\n+\t  if (h == 0x100 + FFI_TYPE_FLOAT)\n+\t    flags = ARM_TYPE_VFP_S;\n+\t  if (h == 0x100 + FFI_TYPE_DOUBLE)\n+\t    flags = ARM_TYPE_VFP_D;\n+\t  if (h != 0)\n+\t      break;\n \t}\n-      else if (cif->rtype->size <= 4)\n-\t/* A Composite Type not larger than 4 bytes is returned in r0.  */\n-\tcif->flags = (unsigned)FFI_TYPE_INT;\n+\n+      /* A Composite Type not larger than 4 bytes is returned in r0.\n+\t A Composite Type larger than 4 bytes, or whose size cannot\n+\t be determined statically ... is stored in memory at an\n+\t address passed [in r0].  */\n+      if (cif->rtype->size <= 4)\n+\tflags = ARM_TYPE_INT;\n       else\n-\t/* A Composite Type larger than 4 bytes, or whose size cannot\n-\t   be determined statically ... is stored in memory at an\n-\t   address passed [in r0].  */\n-\tcif->flags = (unsigned)FFI_TYPE_STRUCT;\n+\t{\n+\t  flags = ARM_TYPE_STRUCT;\n+\t  bytes += 4;\n+\t}\n       break;\n \n     default:\n-      cif->flags = FFI_TYPE_INT;\n-      break;\n+      abort();\n     }\n \n-  /* Map out the register placements of VFP register args.\n-     The VFP hard-float calling conventions are slightly more sophisticated than\n-     the base calling conventions, so we do it here instead of in ffi_prep_args(). */\n-  if (cif->abi == FFI_VFP)\n-    layout_vfp_args (cif);\n+  /* Round the stack up to a multiple of 8 bytes.  This isn't needed\n+     everywhere, but it is on some platforms, and it doesn't harm anything\n+     when it isn't needed.  */\n+  bytes = ALIGN (bytes, 8);\n+\n+  /* Minimum stack space is the 4 register arguments that we pop.  */\n+  if (bytes < 4*4)\n+    bytes = 4*4;\n+\n+  cif->bytes = bytes;\n+  cif->flags = flags;\n \n   return FFI_OK;\n }\n \n /* Perform machine dependent cif processing for variadic calls */\n-ffi_status ffi_prep_cif_machdep_var(ffi_cif *cif,\n-\t\t\t\t    unsigned int nfixedargs,\n-\t\t\t\t    unsigned int ntotalargs)\n+ffi_status\n+ffi_prep_cif_machdep_var (ffi_cif * cif,\n+\t\t\t  unsigned int nfixedargs, unsigned int ntotalargs)\n {\n   /* VFP variadic calls actually use the SYSV ABI */\n   if (cif->abi == FFI_VFP)\n-\tcif->abi = FFI_SYSV;\n+    cif->abi = FFI_SYSV;\n \n-  return ffi_prep_cif_machdep(cif);\n+  return ffi_prep_cif_machdep (cif);\n }\n \n-/* Prototypes for assembly functions, in sysv.S */\n-extern void ffi_call_SYSV (void (*fn)(void), extended_cif *, unsigned, unsigned, unsigned *);\n-extern void ffi_call_VFP (void (*fn)(void), extended_cif *, unsigned, unsigned, unsigned *);\n+/* Prototypes for assembly functions, in sysv.S.  */\n \n-void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n+struct call_frame\n {\n-  extended_cif ecif;\n-\n-  int small_struct = (cif->flags == FFI_TYPE_INT \n-\t\t      && cif->rtype->type == FFI_TYPE_STRUCT);\n-  int vfp_struct = (cif->flags == FFI_TYPE_STRUCT_VFP_FLOAT\n-\t\t    || cif->flags == FFI_TYPE_STRUCT_VFP_DOUBLE);\n-\n-  ecif.cif = cif;\n-  ecif.avalue = avalue;\n+  void *fp;\n+  void *lr;\n+  void *rvalue;\n+  int flags;\n+  void *closure;\n+};\n \n-  unsigned int temp;\n-  \n-  /* If the return value is a struct and we don't have a return\t*/\n-  /* value address then we need to make one\t\t        */\n+extern void ffi_call_SYSV (void *stack, struct call_frame *,\n+\t\t\t   void (*fn) (void)) FFI_HIDDEN;\n+extern void ffi_call_VFP (void *vfp_space, struct call_frame *,\n+\t\t\t   void (*fn) (void), unsigned vfp_used) FFI_HIDDEN;\n \n-  if ((rvalue == NULL) && \n-      (cif->flags == FFI_TYPE_STRUCT))\n+static void\n+ffi_call_int (ffi_cif * cif, void (*fn) (void), void *rvalue,\n+\t      void **avalue, void *closure)\n+{\n+  int flags = cif->flags;\n+  ffi_type *rtype = cif->rtype;\n+  size_t bytes, rsize, vfp_size;\n+  char *stack, *vfp_space, *new_rvalue;\n+  struct call_frame *frame;\n+\n+  rsize = 0;\n+  if (rvalue == NULL)\n     {\n-      ecif.rvalue = alloca(cif->rtype->size);\n+      /* If the return value is a struct and we don't have a return\n+\t value address then we need to make one.  Otherwise the return\n+\t value is in registers and we can ignore them.  */\n+      if (flags == ARM_TYPE_STRUCT)\n+\trsize = rtype->size;\n+      else\n+\tflags = ARM_TYPE_VOID;\n     }\n-  else if (small_struct)\n-    ecif.rvalue = &temp;\n-  else if (vfp_struct)\n+  else if (flags == ARM_TYPE_VFP_N)\n     {\n       /* Largest case is double x 4. */\n-      ecif.rvalue = alloca(32);\n+      rsize = 32;\n     }\n-  else\n-    ecif.rvalue = rvalue;\n+  else if (flags == ARM_TYPE_INT && rtype->type == FFI_TYPE_STRUCT)\n+    rsize = 4;\n \n-  switch (cif->abi) \n-    {\n-    case FFI_SYSV:\n-      ffi_call_SYSV (fn, &ecif, cif->bytes, cif->flags, ecif.rvalue);\n-      break;\n+  /* Largest case.  */\n+  vfp_size = (cif->abi == FFI_VFP && cif->vfp_used ? 8*8: 0);\n \n-    case FFI_VFP:\n-#ifdef __ARM_EABI__\n-      ffi_call_VFP (fn, &ecif, cif->bytes, cif->flags, ecif.rvalue);\n-      break;\n-#endif\n+  bytes = cif->bytes;\n+  stack = alloca (vfp_size + bytes + sizeof(struct call_frame) + rsize);\n \n-    default:\n-      FFI_ASSERT(0);\n-      break;\n+  vfp_space = NULL;\n+  if (vfp_size)\n+    {\n+      vfp_space = stack;\n+      stack += vfp_size;\n     }\n-  if (small_struct)\n-    memcpy (rvalue, &temp, cif->rtype->size);\n-  else if (vfp_struct)\n-    memcpy (rvalue, ecif.rvalue, cif->rtype->size);\n-}\n \n-/** private members **/\n+  frame = (struct call_frame *)(stack + bytes);\n \n-static void ffi_prep_incoming_args_SYSV (char *stack, void **ret,\n-\t\t\t\t\t void** args, ffi_cif* cif, float *vfp_stack);\n+  new_rvalue = rvalue;\n+  if (rsize)\n+    new_rvalue = (void *)(frame + 1);\n \n-void ffi_closure_SYSV (ffi_closure *);\n+  frame->rvalue = new_rvalue;\n+  frame->flags = flags;\n+  frame->closure = closure;\n \n-void ffi_closure_VFP (ffi_closure *);\n+  if (vfp_space)\n+    {\n+      ffi_prep_args_VFP (cif, flags, new_rvalue, avalue, stack, vfp_space);\n+      ffi_call_VFP (vfp_space, frame, fn, cif->vfp_used);\n+    }\n+  else\n+    {\n+      ffi_prep_args_SYSV (cif, flags, new_rvalue, avalue, stack);\n+      ffi_call_SYSV (stack, frame, fn);\n+    }\n \n-/* This function is jumped to by the trampoline */\n+  if (rvalue && rvalue != new_rvalue)\n+    memcpy (rvalue, new_rvalue, rtype->size);\n+}\n \n-unsigned int\n-ffi_closure_SYSV_inner (closure, respp, args, vfp_args)\n-     ffi_closure *closure;\n-     void **respp;\n-     void *args;\n-     void *vfp_args;\n+void\n+ffi_call (ffi_cif *cif, void (*fn) (void), void *rvalue, void **avalue)\n {\n-  // our various things...\n-  ffi_cif       *cif;\n-  void         **arg_area;\n+  ffi_call_int (cif, fn, rvalue, avalue, NULL);\n+}\n \n-  cif         = closure->cif;\n-  arg_area    = (void**) alloca (cif->nargs * sizeof (void*));  \n+void\n+ffi_call_go (ffi_cif *cif, void (*fn) (void), void *rvalue,\n+\t     void **avalue, void *closure)\n+{\n+  ffi_call_int (cif, fn, rvalue, avalue, closure);\n+}\n \n-  /* this call will initialize ARG_AREA, such that each\n-   * element in that array points to the corresponding \n-   * value on the stack; and if the function returns\n-   * a structure, it will re-set RESP to point to the\n-   * structure return address.  */\n+static void *\n+ffi_prep_incoming_args_SYSV (ffi_cif *cif, void *rvalue,\n+\t\t\t     char *argp, void **avalue)\n+{\n+  ffi_type **arg_types = cif->arg_types;\n+  int i, n;\n \n-  ffi_prep_incoming_args_SYSV(args, respp, arg_area, cif, vfp_args);\n+  if (cif->flags == ARM_TYPE_STRUCT)\n+    {\n+      rvalue = *(void **) argp;\n+      argp += 4;\n+    }\n \n-  (closure->fun) (cif, *respp, arg_area, closure->user_data);\n+  for (i = 0, n = cif->nargs; i < n; i++)\n+    {\n+      ffi_type *ty = arg_types[i];\n+      size_t z = ty->size;\n \n-  return cif->flags;\n+      argp = ffi_align (ty, argp);\n+      avalue[i] = (void *) argp;\n+      argp += z;\n+    }\n+\n+  return rvalue;\n }\n \n-/*@-exportheader@*/\n-static void \n-ffi_prep_incoming_args_SYSV(char *stack, void **rvalue,\n-\t\t\t    void **avalue, ffi_cif *cif,\n-\t\t\t    /* Used only under VFP hard-float ABI. */\n-\t\t\t    float *vfp_stack)\n-/*@=exportheader@*/\n+static void *\n+ffi_prep_incoming_args_VFP (ffi_cif *cif, void *rvalue, char *stack,\n+\t\t\t    char *vfp_space, void **avalue)\n {\n-  register unsigned int i, vi = 0;\n-  register void **p_argv;\n-  register char *argp;\n-  register ffi_type **p_arg;\n+  ffi_type **arg_types = cif->arg_types;\n+  int i, n, vi = 0;\n+  char *argp, *regp, *eo_regp;\n+  char done_with_regs = 0;\n+  char stack_used = 0;\n \n-  argp = stack;\n+  regp = stack;\n+  eo_regp = argp = regp + 16;\n \n-  if ( cif->flags == FFI_TYPE_STRUCT ) {\n-    *rvalue = *(void **) argp;\n-    argp += 4;\n-  }\n-\n-  p_argv = avalue;\n+  if (cif->flags == ARM_TYPE_STRUCT)\n+    {\n+      rvalue = *(void **) regp;\n+      regp += 4;\n+    }\n \n-  for (i = cif->nargs, p_arg = cif->arg_types; (i != 0); i--, p_arg++)\n+  for (i = 0, n = cif->nargs; i < n; i++)\n     {\n-      size_t z;\n-      size_t alignment;\n-  \n-      if (cif->abi == FFI_VFP\n-\t  && vi < cif->vfp_nargs && vfp_type_p (*p_arg))\n+      ffi_type *ty = arg_types[i];\n+      int is_vfp_type = vfp_type_p (ty);\n+      size_t z = ty->size;\n+\n+      if (vi < cif->vfp_nargs && is_vfp_type)\n \t{\n-\t  *p_argv++ = (void*)(vfp_stack + cif->vfp_args[vi++]);\n+\t  avalue[i] = vfp_space + cif->vfp_args[vi++] * 4;\n \t  continue;\n \t}\n+      else if (!done_with_regs && !is_vfp_type)\n+\t{\n+\t  char *tregp = ffi_align (ty, regp);\n \n-      alignment = (*p_arg)->alignment;\n-      if (alignment < 4)\n-\talignment = 4;\n-#ifdef _WIN32_WCE\n-      else\n-\tif (alignment > 4)\n-\t  alignment = 4;\n-#endif\n-      /* Align if necessary */\n-      if ((alignment - 1) & (unsigned) argp) {\n-\targp = (char *) ALIGN(argp, alignment);\n-      }\n-\n-      z = (*p_arg)->size;\n-\n-      /* because we're little endian, this is what it turns into.   */\n+\t  z = (z < 4) ? 4 : z;\t// pad\n \n-      *p_argv = (void*) argp;\n+\t  /* If the arguments either fits into the registers or uses registers\n+\t     and stack, while we haven't read other things from the stack */\n+\t  if (tregp + z <= eo_regp || !stack_used)\n+\t    {\n+\t      /* Because we're little endian, this is what it turns into.  */\n+\t      avalue[i] = (void *) tregp;\n+\t      regp = tregp + z;\n+\n+\t      /* If we read past the last core register, make sure we\n+\t\t have not read from the stack before and continue\n+\t\t reading after regp.  */\n+\t      if (regp > eo_regp)\n+\t\t{\n+\t\t  FFI_ASSERT (!stack_used);\n+\t\t  argp = regp;\n+\t\t}\n+\t      if (regp >= eo_regp)\n+\t\t{\n+\t\t  done_with_regs = 1;\n+\t\t  stack_used = 1;\n+\t\t}\n+\t      continue;\n+\t    }\n+\t}\n \n-      p_argv++;\n+      stack_used = 1;\n+      argp = ffi_align (ty, argp);\n+      avalue[i] = (void *) argp;\n       argp += z;\n     }\n-  \n-  return;\n+\n+  return rvalue;\n }\n \n-/* How to make a trampoline.  */\n+struct closure_frame\n+{\n+  char vfp_space[8*8] __attribute__((aligned(8)));\n+  char result[8*4];\n+  char argp[];\n+};\n+\n+int FFI_HIDDEN\n+ffi_closure_inner_SYSV (ffi_cif *cif,\n+\t\t        void (*fun) (ffi_cif *, void *, void **, void *),\n+\t\t        void *user_data,\n+\t\t        struct closure_frame *frame)\n+{\n+  void **avalue = (void **) alloca (cif->nargs * sizeof (void *));\n+  void *rvalue = ffi_prep_incoming_args_SYSV (cif, frame->result,\n+\t\t\t\t\t      frame->argp, avalue);\n+  fun (cif, rvalue, avalue, user_data);\n+  return cif->flags;\n+}\n+\n+int FFI_HIDDEN\n+ffi_closure_inner_VFP (ffi_cif *cif,\n+\t\t       void (*fun) (ffi_cif *, void *, void **, void *),\n+\t\t       void *user_data,\n+\t\t       struct closure_frame *frame)\n+{\n+  void **avalue = (void **) alloca (cif->nargs * sizeof (void *));\n+  void *rvalue = ffi_prep_incoming_args_VFP (cif, frame->result, frame->argp,\n+\t\t\t\t\t     frame->vfp_space, avalue);\n+  fun (cif, rvalue, avalue, user_data);\n+  return cif->flags;\n+}\n \n-extern unsigned int ffi_arm_trampoline[3];\n+void ffi_closure_SYSV (void) FFI_HIDDEN;\n+void ffi_closure_VFP (void) FFI_HIDDEN;\n+void ffi_go_closure_SYSV (void) FFI_HIDDEN;\n+void ffi_go_closure_VFP (void) FFI_HIDDEN;\n \n #if FFI_EXEC_TRAMPOLINE_TABLE\n \n@@ -380,8 +542,9 @@ extern void *ffi_closure_trampoline_table_page;\n typedef struct ffi_trampoline_table ffi_trampoline_table;\n typedef struct ffi_trampoline_table_entry ffi_trampoline_table_entry;\n \n-struct ffi_trampoline_table {\n-  /* contigious writable and executable pages */\n+struct ffi_trampoline_table\n+{\n+  /* contiguous writable and executable pages */\n   vm_address_t config_page;\n   vm_address_t trampoline_page;\n \n@@ -394,8 +557,9 @@ struct ffi_trampoline_table {\n   ffi_trampoline_table *next;\n };\n \n-struct ffi_trampoline_table_entry {\n-  void *(*trampoline)();\n+struct ffi_trampoline_table_entry\n+{\n+  void *(*trampoline) ();\n   ffi_trampoline_table_entry *next;\n };\n \n@@ -421,101 +585,120 @@ ffi_trampoline_table_alloc ()\n {\n   ffi_trampoline_table *table = NULL;\n \n-  /* Loop until we can allocate two contigious pages */\n-  while (table == NULL) {\n-    vm_address_t config_page = 0x0;\n-    kern_return_t kt;\n+  /* Loop until we can allocate two contiguous pages */\n+  while (table == NULL)\n+    {\n+      vm_address_t config_page = 0x0;\n+      kern_return_t kt;\n+\n+      /* Try to allocate two pages */\n+      kt =\n+\tvm_allocate (mach_task_self (), &config_page, PAGE_SIZE * 2,\n+\t\t     VM_FLAGS_ANYWHERE);\n+      if (kt != KERN_SUCCESS)\n+\t{\n+\t  fprintf (stderr, \"vm_allocate() failure: %d at %s:%d\\n\", kt,\n+\t\t   __FILE__, __LINE__);\n+\t  break;\n+\t}\n \n-    /* Try to allocate two pages */\n-    kt = vm_allocate (mach_task_self (), &config_page, PAGE_SIZE*2, VM_FLAGS_ANYWHERE);\n-    if (kt != KERN_SUCCESS) {\n-      fprintf(stderr, \"vm_allocate() failure: %d at %s:%d\\n\", kt, __FILE__, __LINE__);\n-      break;\n-    }\n+      /* Now drop the second half of the allocation to make room for the trampoline table */\n+      vm_address_t trampoline_page = config_page + PAGE_SIZE;\n+      kt = vm_deallocate (mach_task_self (), trampoline_page, PAGE_SIZE);\n+      if (kt != KERN_SUCCESS)\n+\t{\n+\t  fprintf (stderr, \"vm_deallocate() failure: %d at %s:%d\\n\", kt,\n+\t\t   __FILE__, __LINE__);\n+\t  break;\n+\t}\n \n-    /* Now drop the second half of the allocation to make room for the trampoline table */\n-    vm_address_t trampoline_page = config_page+PAGE_SIZE;\n-    kt = vm_deallocate (mach_task_self (), trampoline_page, PAGE_SIZE);\n-    if (kt != KERN_SUCCESS) {\n-      fprintf(stderr, \"vm_deallocate() failure: %d at %s:%d\\n\", kt, __FILE__, __LINE__);\n-      break;\n-    }\n+      /* Remap the trampoline table to directly follow the config page */\n+      vm_prot_t cur_prot;\n+      vm_prot_t max_prot;\n \n-    /* Remap the trampoline table to directly follow the config page */\n-    vm_prot_t cur_prot;\n-    vm_prot_t max_prot;\n+      kt =\n+\tvm_remap (mach_task_self (), &trampoline_page, PAGE_SIZE, 0x0, FALSE,\n+\t\t  mach_task_self (),\n+\t\t  (vm_address_t) & ffi_closure_trampoline_table_page, FALSE,\n+\t\t  &cur_prot, &max_prot, VM_INHERIT_SHARE);\n \n-    kt = vm_remap (mach_task_self (), &trampoline_page, PAGE_SIZE, 0x0, FALSE, mach_task_self (), (vm_address_t) &ffi_closure_trampoline_table_page, FALSE, &cur_prot, &max_prot, VM_INHERIT_SHARE);\n+      /* If we lost access to the destination trampoline page, drop our config allocation mapping and retry */\n+      if (kt != KERN_SUCCESS)\n+\t{\n+\t  /* Log unexpected failures */\n+\t  if (kt != KERN_NO_SPACE)\n+\t    {\n+\t      fprintf (stderr, \"vm_remap() failure: %d at %s:%d\\n\", kt,\n+\t\t       __FILE__, __LINE__);\n+\t    }\n \n-    /* If we lost access to the destination trampoline page, drop our config allocation mapping and retry */\n-    if (kt != KERN_SUCCESS) {\n-      /* Log unexpected failures */\n-      if (kt != KERN_NO_SPACE) {\n-        fprintf(stderr, \"vm_remap() failure: %d at %s:%d\\n\", kt, __FILE__, __LINE__);\n-      }\n+\t  vm_deallocate (mach_task_self (), config_page, PAGE_SIZE);\n+\t  continue;\n+\t}\n \n-      vm_deallocate (mach_task_self (), config_page, PAGE_SIZE);\n-      continue;\n-    }\n+      /* We have valid trampoline and config pages */\n+      table = calloc (1, sizeof (ffi_trampoline_table));\n+      table->free_count = FFI_TRAMPOLINE_COUNT;\n+      table->config_page = config_page;\n+      table->trampoline_page = trampoline_page;\n \n-    /* We have valid trampoline and config pages */\n-    table = calloc (1, sizeof(ffi_trampoline_table));\n-    table->free_count = FFI_TRAMPOLINE_COUNT;\n-    table->config_page = config_page;\n-    table->trampoline_page = trampoline_page;\n+      /* Create and initialize the free list */\n+      table->free_list_pool =\n+\tcalloc (FFI_TRAMPOLINE_COUNT, sizeof (ffi_trampoline_table_entry));\n \n-    /* Create and initialize the free list */\n-    table->free_list_pool = calloc(FFI_TRAMPOLINE_COUNT, sizeof(ffi_trampoline_table_entry));\n+      uint16_t i;\n+      for (i = 0; i < table->free_count; i++)\n+\t{\n+\t  ffi_trampoline_table_entry *entry = &table->free_list_pool[i];\n+\t  entry->trampoline =\n+\t    (void *) (table->trampoline_page + (i * FFI_TRAMPOLINE_SIZE));\n \n-    uint16_t i;\n-    for (i = 0; i < table->free_count; i++) {\n-      ffi_trampoline_table_entry *entry = &table->free_list_pool[i];\n-      entry->trampoline = (void *) (table->trampoline_page + (i * FFI_TRAMPOLINE_SIZE));\n+\t  if (i < table->free_count - 1)\n+\t    entry->next = &table->free_list_pool[i + 1];\n+\t}\n \n-      if (i < table->free_count - 1)\n-        entry->next = &table->free_list_pool[i+1];\n+      table->free_list = table->free_list_pool;\n     }\n \n-    table->free_list = table->free_list_pool;\n-  }\n-\n   return table;\n }\n \n void *\n ffi_closure_alloc (size_t size, void **code)\n {\n   /* Create the closure */\n-  ffi_closure *closure = malloc(size);\n+  ffi_closure *closure = malloc (size);\n   if (closure == NULL)\n     return NULL;\n \n-  pthread_mutex_lock(&ffi_trampoline_lock);\n+  pthread_mutex_lock (&ffi_trampoline_lock);\n \n   /* Check for an active trampoline table with available entries. */\n   ffi_trampoline_table *table = ffi_trampoline_tables;\n-  if (table == NULL || table->free_list == NULL) {\n-    table = ffi_trampoline_table_alloc ();\n-    if (table == NULL) {\n-      free(closure);\n-      return NULL;\n-    }\n+  if (table == NULL || table->free_list == NULL)\n+    {\n+      table = ffi_trampoline_table_alloc ();\n+      if (table == NULL)\n+\t{\n+\t  free (closure);\n+\t  return NULL;\n+\t}\n \n-    /* Insert the new table at the top of the list */\n-    table->next = ffi_trampoline_tables;\n-    if (table->next != NULL)\n-        table->next->prev = table;\n+      /* Insert the new table at the top of the list */\n+      table->next = ffi_trampoline_tables;\n+      if (table->next != NULL)\n+\ttable->next->prev = table;\n \n-    ffi_trampoline_tables = table;\n-  }\n+      ffi_trampoline_tables = table;\n+    }\n \n   /* Claim the free entry */\n   ffi_trampoline_table_entry *entry = ffi_trampoline_tables->free_list;\n   ffi_trampoline_tables->free_list = entry->next;\n   ffi_trampoline_tables->free_count--;\n   entry->next = NULL;\n \n-  pthread_mutex_unlock(&ffi_trampoline_lock);\n+  pthread_mutex_unlock (&ffi_trampoline_lock);\n \n   /* Initialize the return values */\n   *code = entry->trampoline;\n@@ -530,7 +713,7 @@ ffi_closure_free (void *ptr)\n {\n   ffi_closure *closure = ptr;\n \n-  pthread_mutex_lock(&ffi_trampoline_lock);\n+  pthread_mutex_lock (&ffi_trampoline_lock);\n \n   /* Fetch the table and entry references */\n   ffi_trampoline_table *table = closure->trampoline_table;\n@@ -543,36 +726,43 @@ ffi_closure_free (void *ptr)\n \n   /* If all trampolines within this table are free, and at least one other table exists, deallocate\n    * the table */\n-  if (table->free_count == FFI_TRAMPOLINE_COUNT && ffi_trampoline_tables != table) {\n-    /* Remove from the list */\n-    if (table->prev != NULL)\n-      table->prev->next = table->next;\n-\n-    if (table->next != NULL)\n-      table->next->prev = table->prev;\n-\n-    /* Deallocate pages */\n-    kern_return_t kt;\n-    kt = vm_deallocate (mach_task_self (), table->config_page, PAGE_SIZE);\n-    if (kt != KERN_SUCCESS)\n-      fprintf(stderr, \"vm_deallocate() failure: %d at %s:%d\\n\", kt, __FILE__, __LINE__);\n-\n-    kt = vm_deallocate (mach_task_self (), table->trampoline_page, PAGE_SIZE);\n-    if (kt != KERN_SUCCESS)\n-      fprintf(stderr, \"vm_deallocate() failure: %d at %s:%d\\n\", kt, __FILE__, __LINE__);\n-\n-    /* Deallocate free list */\n-    free (table->free_list_pool);\n-    free (table);\n-  } else if (ffi_trampoline_tables != table) {\n-    /* Otherwise, bump this table to the top of the list */\n-    table->prev = NULL;\n-    table->next = ffi_trampoline_tables;\n-    if (ffi_trampoline_tables != NULL)\n-      ffi_trampoline_tables->prev = table;\n-\n-    ffi_trampoline_tables = table;\n-  }\n+  if (table->free_count == FFI_TRAMPOLINE_COUNT\n+      && ffi_trampoline_tables != table)\n+    {\n+      /* Remove from the list */\n+      if (table->prev != NULL)\n+\ttable->prev->next = table->next;\n+\n+      if (table->next != NULL)\n+\ttable->next->prev = table->prev;\n+\n+      /* Deallocate pages */\n+      kern_return_t kt;\n+      kt = vm_deallocate (mach_task_self (), table->config_page, PAGE_SIZE);\n+      if (kt != KERN_SUCCESS)\n+\tfprintf (stderr, \"vm_deallocate() failure: %d at %s:%d\\n\", kt,\n+\t\t __FILE__, __LINE__);\n+\n+      kt =\n+\tvm_deallocate (mach_task_self (), table->trampoline_page, PAGE_SIZE);\n+      if (kt != KERN_SUCCESS)\n+\tfprintf (stderr, \"vm_deallocate() failure: %d at %s:%d\\n\", kt,\n+\t\t __FILE__, __LINE__);\n+\n+      /* Deallocate free list */\n+      free (table->free_list_pool);\n+      free (table);\n+    }\n+  else if (ffi_trampoline_tables != table)\n+    {\n+      /* Otherwise, bump this table to the top of the list */\n+      table->prev = NULL;\n+      table->next = ffi_trampoline_tables;\n+      if (ffi_trampoline_tables != NULL)\n+\tffi_trampoline_tables->prev = table;\n+\n+      ffi_trampoline_tables = table;\n+    }\n \n   pthread_mutex_unlock (&ffi_trampoline_lock);\n \n@@ -582,133 +772,225 @@ ffi_closure_free (void *ptr)\n \n #else\n \n-#define FFI_INIT_TRAMPOLINE(TRAMP,FUN,CTX)\t\t\t\t\\\n-({ unsigned char *__tramp = (unsigned char*)(TRAMP);\t\t\t\\\n-   unsigned int  __fun = (unsigned int)(FUN);\t\t\t\t\\\n-   unsigned int  __ctx = (unsigned int)(CTX);\t\t\t\t\\\n-   unsigned char *insns = (unsigned char *)(CTX);                       \\\n-   memcpy (__tramp, ffi_arm_trampoline, sizeof ffi_arm_trampoline);     \\\n-   *(unsigned int*) &__tramp[12] = __ctx;\t\t\t\t\\\n-   *(unsigned int*) &__tramp[16] = __fun;\t\t\t\t\\\n-   __clear_cache((&__tramp[0]), (&__tramp[19])); /* Clear data mapping.  */ \\\n-   __clear_cache(insns, insns + 3 * sizeof (unsigned int));             \\\n-                                                 /* Clear instruction   \\\n-                                                    mapping.  */        \\\n- })\n+extern unsigned int ffi_arm_trampoline[2] FFI_HIDDEN;\n \n #endif\n \n /* the cif must already be prep'ed */\n \n ffi_status\n-ffi_prep_closure_loc (ffi_closure* closure,\n-\t\t      ffi_cif* cif,\n-\t\t      void (*fun)(ffi_cif*,void*,void**,void*),\n-\t\t      void *user_data,\n-\t\t      void *codeloc)\n+ffi_prep_closure_loc (ffi_closure * closure,\n+\t\t      ffi_cif * cif,\n+\t\t      void (*fun) (ffi_cif *, void *, void **, void *),\n+\t\t      void *user_data, void *codeloc)\n {\n-  void (*closure_func)(ffi_closure*) = NULL;\n+  void (*closure_func) (void) = ffi_closure_SYSV;\n \n-  if (cif->abi == FFI_SYSV)\n-    closure_func = &ffi_closure_SYSV;\n-#ifdef __ARM_EABI__\n-  else if (cif->abi == FFI_VFP)\n-    closure_func = &ffi_closure_VFP;\n-#endif\n-  else\n+  if (cif->abi == FFI_VFP)\n+    {\n+      /* We only need take the vfp path if there are vfp arguments.  */\n+      if (cif->vfp_used)\n+\tclosure_func = ffi_closure_VFP;\n+    }\n+  else if (cif->abi != FFI_SYSV)\n     return FFI_BAD_ABI;\n-    \n+\n #if FFI_EXEC_TRAMPOLINE_TABLE\n-  void **config = FFI_TRAMPOLINE_CODELOC_CONFIG(codeloc);\n+  void **config = FFI_TRAMPOLINE_CODELOC_CONFIG (codeloc);\n   config[0] = closure;\n   config[1] = closure_func;\n #else\n-  FFI_INIT_TRAMPOLINE (&closure->tramp[0], \\\n-\t\t       closure_func,  \\\n-\t\t       codeloc);\n+  memcpy (closure->tramp, ffi_arm_trampoline, 8);\n+  __clear_cache(closure->tramp, closure->tramp + 8);\t/* clear data map */\n+  __clear_cache(codeloc, codeloc + 8);\t\t\t/* clear insn map */\n+  *(void (**)(void))(closure->tramp + 8) = closure_func;\n #endif\n \n-  closure->cif  = cif;\n+  closure->cif = cif;\n+  closure->fun = fun;\n   closure->user_data = user_data;\n-  closure->fun  = fun;\n+\n+  return FFI_OK;\n+}\n+\n+ffi_status\n+ffi_prep_go_closure (ffi_go_closure *closure, ffi_cif *cif,\n+\t\t     void (*fun) (ffi_cif *, void *, void **, void *))\n+{\n+  void (*closure_func) (void) = ffi_go_closure_SYSV;\n+\n+  if (cif->abi == FFI_VFP)\n+    {\n+      /* We only need take the vfp path if there are vfp arguments.  */\n+      if (cif->vfp_used)\n+\tclosure_func = ffi_go_closure_VFP;\n+    }\n+  else if (cif->abi != FFI_SYSV)\n+    return FFI_BAD_ABI;\n+\n+  closure->tramp = closure_func;\n+  closure->cif = cif;\n+  closure->fun = fun;\n \n   return FFI_OK;\n }\n \n /* Below are routines for VFP hard-float support. */\n \n-static int rec_vfp_type_p (ffi_type *t, int *elt, int *elnum)\n+/* A subroutine of vfp_type_p.  Given a structure type, return the type code\n+   of the first non-structure element.  Recurse for structure elements.\n+   Return -1 if the structure is in fact empty, i.e. no nested elements.  */\n+\n+static int\n+is_hfa0 (const ffi_type *ty)\n {\n-  switch (t->type)\n-    {\n-    case FFI_TYPE_FLOAT:\n-    case FFI_TYPE_DOUBLE:\n-      *elt = (int) t->type;\n-      *elnum = 1;\n-      return 1;\n+  ffi_type **elements = ty->elements;\n+  int i, ret = -1;\n+\n+  if (elements != NULL)\n+    for (i = 0; elements[i]; ++i)\n+      {\n+        ret = elements[i]->type;\n+        if (ret == FFI_TYPE_STRUCT || ret == FFI_TYPE_COMPLEX)\n+          {\n+            ret = is_hfa0 (elements[i]);\n+            if (ret < 0)\n+              continue;\n+          }\n+        break;\n+      }\n \n-    case FFI_TYPE_STRUCT_VFP_FLOAT:\n-      *elt = FFI_TYPE_FLOAT;\n-      *elnum = t->size / sizeof (float);\n-      return 1;\n+  return ret;\n+}\n \n-    case FFI_TYPE_STRUCT_VFP_DOUBLE:\n-      *elt = FFI_TYPE_DOUBLE;\n-      *elnum = t->size / sizeof (double);\n-      return 1;\n+/* A subroutine of vfp_type_p.  Given a structure type, return true if all\n+   of the non-structure elements are the same as CANDIDATE.  */\n \n-    case FFI_TYPE_STRUCT:;\n+static int\n+is_hfa1 (const ffi_type *ty, int candidate)\n+{\n+  ffi_type **elements = ty->elements;\n+  int i;\n+\n+  if (elements != NULL)\n+    for (i = 0; elements[i]; ++i)\n       {\n-\tint base_elt = 0, total_elnum = 0;\n-\tffi_type **el = t->elements;\n-\twhile (*el)\n-\t  {\n-\t    int el_elt = 0, el_elnum = 0;\n-\t    if (! rec_vfp_type_p (*el, &el_elt, &el_elnum)\n-\t\t|| (base_elt && base_elt != el_elt)\n-\t\t|| total_elnum + el_elnum > 4)\n-\t      return 0;\n-\t    base_elt = el_elt;\n-\t    total_elnum += el_elnum;\n-\t    el++;\n-\t  }\n-\t*elnum = total_elnum;\n-\t*elt = base_elt;\n-\treturn 1;\n+        int t = elements[i]->type;\n+        if (t == FFI_TYPE_STRUCT || t == FFI_TYPE_COMPLEX)\n+          {\n+            if (!is_hfa1 (elements[i], candidate))\n+              return 0;\n+          }\n+        else if (t != candidate)\n+          return 0;\n       }\n-    default: ;\n-    }\n-  return 0;\n+\n+  return 1;\n }\n \n-static int vfp_type_p (ffi_type *t)\n+/* Determine if TY is an homogenous floating point aggregate (HFA).\n+   That is, a structure consisting of 1 to 4 members of all the same type,\n+   where that type is a floating point scalar.\n+\n+   Returns non-zero iff TY is an HFA.  The result is an encoded value where\n+   bits 0-7 contain the type code, and bits 8-10 contain the element count.  */\n+\n+static int\n+vfp_type_p (const ffi_type *ty)\n {\n-  int elt, elnum;\n-  if (rec_vfp_type_p (t, &elt, &elnum))\n+  ffi_type **elements;\n+  int candidate, i;\n+  size_t size, ele_count;\n+\n+  /* Quickest tests first.  */\n+  candidate = ty->type;\n+  switch (ty->type)\n     {\n-      if (t->type == FFI_TYPE_STRUCT)\n-\t{\n-\t  if (elnum == 1)\n-\t    t->type = elt;\n-\t  else\n-\t    t->type = (elt == FFI_TYPE_FLOAT\n-\t\t       ? FFI_TYPE_STRUCT_VFP_FLOAT\n-\t\t       : FFI_TYPE_STRUCT_VFP_DOUBLE);\n-\t}\n-      return (int) t->type;\n+    default:\n+      return 0;\n+    case FFI_TYPE_FLOAT:\n+    case FFI_TYPE_DOUBLE:\n+      ele_count = 1;\n+      goto done;\n+    case FFI_TYPE_COMPLEX:\n+      candidate = ty->elements[0]->type;\n+      if (candidate != FFI_TYPE_FLOAT && candidate != FFI_TYPE_DOUBLE)\n+\treturn 0;\n+      ele_count = 2;\n+      goto done;\n+    case FFI_TYPE_STRUCT:\n+      break;\n     }\n-  return 0;\n+\n+  /* No HFA types are smaller than 4 bytes, or larger than 32 bytes.  */\n+  size = ty->size;\n+  if (size < 4 || size > 32)\n+    return 0;\n+\n+  /* Find the type of the first non-structure member.  */\n+  elements = ty->elements;\n+  candidate = elements[0]->type;\n+  if (candidate == FFI_TYPE_STRUCT || candidate == FFI_TYPE_COMPLEX)\n+    {\n+      for (i = 0; ; ++i)\n+        {\n+          candidate = is_hfa0 (elements[i]);\n+          if (candidate >= 0)\n+            break;\n+        }\n+    }\n+\n+  /* If the first member is not a floating point type, it's not an HFA.\n+     Also quickly re-check the size of the structure.  */\n+  switch (candidate)\n+    {\n+    case FFI_TYPE_FLOAT:\n+      ele_count = size / sizeof(float);\n+      if (size != ele_count * sizeof(float))\n+        return 0;\n+      break;\n+    case FFI_TYPE_DOUBLE:\n+      ele_count = size / sizeof(double);\n+      if (size != ele_count * sizeof(double))\n+        return 0;\n+      break;\n+    default:\n+      return 0;\n+    }\n+  if (ele_count > 4)\n+    return 0;\n+\n+  /* Finally, make sure that all scalar elements are the same type.  */\n+  for (i = 0; elements[i]; ++i)\n+    {\n+      int t = elements[i]->type;\n+      if (t == FFI_TYPE_STRUCT || t == FFI_TYPE_COMPLEX)\n+        {\n+          if (!is_hfa1 (elements[i], candidate))\n+            return 0;\n+        }\n+      else if (t != candidate)\n+        return 0;\n+    }\n+\n+  /* All tests succeeded.  Encode the result.  */\n+ done:\n+  return (ele_count << 8) | candidate;\n }\n \n-static void place_vfp_arg (ffi_cif *cif, ffi_type *t)\n+static int\n+place_vfp_arg (ffi_cif *cif, int h)\n {\n-  int reg = cif->vfp_reg_free;\n-  int nregs = t->size / sizeof (float);\n-  int align = ((t->type == FFI_TYPE_STRUCT_VFP_FLOAT\n-\t\t|| t->type == FFI_TYPE_FLOAT) ? 1 : 2);\n+  unsigned short reg = cif->vfp_reg_free;\n+  int align = 1, nregs = h >> 8;\n+\n+  if ((h & 0xff) == FFI_TYPE_DOUBLE)\n+    align = 2, nregs *= 2;\n+\n   /* Align register number. */\n   if ((reg & 1) && align == 2)\n     reg++;\n+\n   while (reg + nregs <= 16)\n     {\n       int s, new_used = 0;\n@@ -733,24 +1015,29 @@ static void place_vfp_arg (ffi_cif *cif, ffi_type *t)\n \t    reg += 1;\n \t  cif->vfp_reg_free = reg;\n \t}\n-      return;\n-    next_reg: ;\n+      return 0;\n+    next_reg:;\n     }\n+  // done, mark all regs as used\n+  cif->vfp_reg_free = 16;\n+  cif->vfp_used = 0xFFFF;\n+  return 1;\n }\n \n-static void layout_vfp_args (ffi_cif *cif)\n+static void\n+layout_vfp_args (ffi_cif * cif)\n {\n   int i;\n   /* Init VFP fields */\n   cif->vfp_used = 0;\n   cif->vfp_nargs = 0;\n   cif->vfp_reg_free = 0;\n-  memset (cif->vfp_args, -1, 16); /* Init to -1. */\n+  memset (cif->vfp_args, -1, 16);\t/* Init to -1. */\n \n   for (i = 0; i < cif->nargs; i++)\n     {\n-      ffi_type *t = cif->arg_types[i];\n-      if (vfp_type_p (t))\n-\tplace_vfp_arg (cif, t);\n+      int h = vfp_type_p (cif->arg_types[i]);\n+      if (h && place_vfp_arg (cif, h) == 1)\n+\tbreak;\n     }\n }"}, {"sha": "4f473f929b4f4cea1b3e7dac71251c3b6e5d1bee", "filename": "libffi/src/arm/ffitarget.h", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Farm%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Farm%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farm%2Fffitarget.h?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -53,19 +53,17 @@ typedef enum ffi_abi {\n \n #define FFI_EXTRA_CIF_FIELDS\t\t\t\\\n   int vfp_used;\t\t\t\t\t\\\n-  short vfp_reg_free, vfp_nargs;\t\t\\\n+  unsigned short vfp_reg_free, vfp_nargs;\t\\\n   signed char vfp_args[16]\t\t\t\\\n \n-/* Internally used. */\n-#define FFI_TYPE_STRUCT_VFP_FLOAT  (FFI_TYPE_LAST + 1)\n-#define FFI_TYPE_STRUCT_VFP_DOUBLE (FFI_TYPE_LAST + 2)\n-\n #define FFI_TARGET_SPECIFIC_VARIADIC\n+#define FFI_TARGET_HAS_COMPLEX_TYPE\n \n /* ---- Definitions for closures ----------------------------------------- */\n \n #define FFI_CLOSURES 1\n-#define FFI_TRAMPOLINE_SIZE 20\n+#define FFI_GO_CLOSURES 1\n+#define FFI_TRAMPOLINE_SIZE 12\n #define FFI_NATIVE_RAW_API 0\n \n #endif"}, {"sha": "74f0b867daec8f08c52f312850cc698a809962fc", "filename": "libffi/src/arm/gentramp.sh", "status": "removed", "additions": 0, "deletions": 118, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e22fcb7985349b93646b86351033e1fb09c46c/libffi%2Fsrc%2Farm%2Fgentramp.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e22fcb7985349b93646b86351033e1fb09c46c/libffi%2Fsrc%2Farm%2Fgentramp.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farm%2Fgentramp.sh?ref=62e22fcb7985349b93646b86351033e1fb09c46c", "patch": "@@ -1,118 +0,0 @@\n-#!/bin/sh\n-\n-# -----------------------------------------------------------------------\n-#  gentramp.sh - Copyright (c) 2010, Plausible Labs Cooperative, Inc.\n-#  \n-#  ARM Trampoline Page Generator\n-#\n-#  Permission is hereby granted, free of charge, to any person obtaining\n-#  a copy of this software and associated documentation files (the\n-#  ``Software''), to deal in the Software without restriction, including\n-#  without limitation the rights to use, copy, modify, merge, publish,\n-#  distribute, sublicense, and/or sell copies of the Software, and to\n-#  permit persons to whom the Software is furnished to do so, subject to\n-#  the following conditions:\n-#\n-#  The above copyright notice and this permission notice shall be included\n-#  in all copies or substantial portions of the Software.\n-#\n-#  THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n-#  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n-#  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n-#  NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n-#  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n-#  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n-#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n-#  DEALINGS IN THE SOFTWARE.\n-#  -----------------------------------------------------------------------\n-\n-PROGNAME=$0\n-\n-# Each trampoline is exactly 3 instructions, or 12 bytes. If any of these values change,\n-# the entire arm trampoline implementation must be updated to match, too.\n-\n-# Size of an individual trampoline, in bytes\n-TRAMPOLINE_SIZE=12\n-\n-# Page size, in bytes\n-PAGE_SIZE=4096\n-\n-# Compute the size of the reachable config page; The first 16 bytes of the config page\n-# are unreachable due to our maximum pc-relative ldr offset.\n-PAGE_AVAIL=`expr $PAGE_SIZE - 16`\n-\n-# Compute the number of of available trampolines. \n-TRAMPOLINE_COUNT=`expr $PAGE_AVAIL / $TRAMPOLINE_SIZE`\n-\n-header () {\n-    echo \"# GENERATED CODE - DO NOT EDIT\"\n-    echo \"# This file was generated by $PROGNAME\"\n-    echo \"\"\n-\n-    # Write out the license header\n-cat << EOF\n-#  Copyright (c) 2010, Plausible Labs Cooperative, Inc.\n-#  \n-#  Permission is hereby granted, free of charge, to any person obtaining\n-#  a copy of this software and associated documentation files (the\n-#  ``Software''), to deal in the Software without restriction, including\n-#  without limitation the rights to use, copy, modify, merge, publish,\n-#  distribute, sublicense, and/or sell copies of the Software, and to\n-#  permit persons to whom the Software is furnished to do so, subject to\n-#  the following conditions:\n-#\n-#  The above copyright notice and this permission notice shall be included\n-#  in all copies or substantial portions of the Software.\n-#\n-#  THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n-#  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n-#  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n-#  NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n-#  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n-#  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n-#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n-#  DEALINGS IN THE SOFTWARE.\n-#  -----------------------------------------------------------------------\n-\n-EOF\n-\n-    # Write out the trampoline table, aligned to the page boundary\n-    echo \".text\"\n-    echo \".align 12\"\n-    echo \".globl _ffi_closure_trampoline_table_page\"\n-    echo \"_ffi_closure_trampoline_table_page:\"\n-}\n-\n-\n-# WARNING - Don't modify the trampoline code size without also updating the relevent libffi code\n-trampoline () {\n-    cat << END\n-\n-    // trampoline\n-    // Save to stack\n-    stmfd sp!, {r0-r3}\n-\n-    // Load the context argument from the config page.\n-    // This places the first usable config value at _ffi_closure_trampoline_table-4080\n-    // This accounts for the above 4-byte stmfd instruction, plus 8 bytes constant when loading from pc.\n-    ldr r0, [pc, #-4092]\n-\n-    // Load the jump address from the config page.\n-    ldr pc, [pc, #-4092]\n-\n-END\n-}\n-\n-main () {\n-    # Write out the header\n-    header\n-\n-    # Write out the trampolines\n-    local i=0\n-    while [ $i -lt ${TRAMPOLINE_COUNT} ]; do\n-        trampoline\n-        local i=`expr $i + 1`\n-    done\n-}\n-\n-main"}, {"sha": "6cf0b2ae5dab8105ca110af96d668958b69abed3", "filename": "libffi/src/arm/internal.h", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Farm%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Farm%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farm%2Finternal.h?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -0,0 +1,7 @@\n+#define ARM_TYPE_VFP_S\t0\n+#define ARM_TYPE_VFP_D\t1\n+#define ARM_TYPE_VFP_N\t2\n+#define ARM_TYPE_INT64\t3\n+#define ARM_TYPE_INT\t4\n+#define ARM_TYPE_VOID\t5\n+#define ARM_TYPE_STRUCT\t6"}, {"sha": "fd165890e02cbe73da7915419b0edc268abe543f", "filename": "libffi/src/arm/sysv.S", "status": "modified", "additions": 267, "deletions": 437, "changes": 704, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Farm%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Farm%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farm%2Fsysv.S?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -1,8 +1,8 @@\n /* -----------------------------------------------------------------------\n    sysv.S - Copyright (c) 1998, 2008, 2011 Red Hat, Inc.\n \t    Copyright (c) 2011 Plausible Labs Cooperative, Inc.\n-   \n-   ARM Foreign Function Interface \n+\n+   ARM Foreign Function Interface\n \n    Permission is hereby granted, free of charge, to any person obtaining\n    a copy of this software and associated documentation files (the\n@@ -28,477 +28,307 @@\n #define LIBFFI_ASM\t\n #include <fficonfig.h>\n #include <ffi.h>\n-#ifdef HAVE_MACHINE_ASM_H\n-#include <machine/asm.h>\n-#else\n-#ifdef __USER_LABEL_PREFIX__\n-#define CONCAT1(a, b) CONCAT2(a, b)\n-#define CONCAT2(a, b) a ## b\n-\n-/* Use the right prefix for global labels.  */\n-#define CNAME(x) CONCAT1 (__USER_LABEL_PREFIX__, x)\n-#else\n-#define CNAME(x) x\n-#endif\n-#ifdef __APPLE__\n-#define ENTRY(x) .globl _##x; _##x:\n-#else\n-#define ENTRY(x) .globl CNAME(x); .type CNAME(x),%function; CNAME(x):\n-#endif /* __APPLE__ */\n-#endif\n-\n-#ifdef __ELF__\n-#define LSYM(x) .x\n-#else\n-#define LSYM(x) x\n-#endif\n-\n-/* Use the SOFTFP return value ABI on Mac OS X, as per the iOS ABI\n-  Function Call Guide */\n-#ifdef __APPLE__\n-#define __SOFTFP__\n-#endif\n-\n-/* We need a better way of testing for this, but for now, this is all \n-   we can do.  */\n-@ This selects the minimum architecture level required.\n-#define __ARM_ARCH__ 3\n-\n-#if defined(__ARM_ARCH_4__) || defined(__ARM_ARCH_4T__)\n-# undef __ARM_ARCH__\n-# define __ARM_ARCH__ 4\n-#endif\n-        \n-#if defined(__ARM_ARCH_5__) || defined(__ARM_ARCH_5T__) \\\n-\t|| defined(__ARM_ARCH_5E__) || defined(__ARM_ARCH_5TE__) \\\n-\t|| defined(__ARM_ARCH_5TEJ__)\n-# undef __ARM_ARCH__\n-# define __ARM_ARCH__ 5\n-#endif\n-\n-#if defined(__ARM_ARCH_6__) || defined(__ARM_ARCH_6J__) \\\n+#include <ffi_cfi.h>\n+#include \"internal.h\"\n+\n+/* GCC 4.8 provides __ARM_ARCH; construct it otherwise.  */\n+#ifndef __ARM_ARCH\n+# if defined(__ARM_ARCH_7__) || defined(__ARM_ARCH_7A__) \\\n+     || defined(__ARM_ARCH_7R__) || defined(__ARM_ARCH_7M__) \\\n+     || defined(__ARM_ARCH_7EM__)\n+#  define __ARM_ARCH 7\n+# elif defined(__ARM_ARCH_6__) || defined(__ARM_ARCH_6J__) \\\n         || defined(__ARM_ARCH_6K__) || defined(__ARM_ARCH_6Z__) \\\n         || defined(__ARM_ARCH_6ZK__) || defined(__ARM_ARCH_6T2__) \\\n \t|| defined(__ARM_ARCH_6M__)\n-# undef __ARM_ARCH__\n-# define __ARM_ARCH__ 6\n-#endif\n-\n-#if defined(__ARM_ARCH_7__) || defined(__ARM_ARCH_7A__) \\\n-        || defined(__ARM_ARCH_7R__) || defined(__ARM_ARCH_7M__) \\\n-\t|| defined(__ARM_ARCH_7EM__)\n-# undef __ARM_ARCH__\n-# define __ARM_ARCH__ 7\n-#endif\n-\n-#if __ARM_ARCH__ >= 5\n-# define call_reg(x)\tblx\tx\n-#elif defined (__ARM_ARCH_4T__)\n-# define call_reg(x)\tmov\tlr, pc ; bx\tx\n-# if defined(__thumb__) || defined(__THUMB_INTERWORK__)\n-#  define __INTERWORKING__\n+#  define __ARM_ARCH 6\n+# elif defined(__ARM_ARCH_5__) || defined(__ARM_ARCH_5T__) \\\n+\t|| defined(__ARM_ARCH_5E__) || defined(__ARM_ARCH_5TE__) \\\n+\t|| defined(__ARM_ARCH_5TEJ__)\n+#  define __ARM_ARCH 5\n+# else\n+#  define __ARM_ARCH 4\n # endif\n-#else\n-# define call_reg(x)\tmov\tlr, pc ; mov\tpc, x\n #endif\n \n /* Conditionally compile unwinder directives.  */\n+.macro UNWIND text:vararg\n #ifdef __ARM_EABI__\n-#define UNWIND\n-#else\n-#define UNWIND @\n+\t\\text\n #endif\t\n-\n-\t\n-#if defined(__thumb__) && !defined(__THUMB_INTERWORK__)\n-.macro\tARM_FUNC_START name\n-\t.text\n-\t.align 0\n-\t.thumb\n-\t.thumb_func\n-#ifdef __APPLE__\n-\tENTRY($0)\n-#else\n-\tENTRY(\\name)\n-#endif\n-\tbx\tpc\n-\tnop\n-\t.arm\n-\tUNWIND .fnstart\n-/* A hook to tell gdb that we've switched to ARM mode.  Also used to call\n-   directly from other local arm routines.  */\n-#ifdef __APPLE__\n-_L__$0:\n-#else\n-_L__\\name:\n-#endif\n-.endm\n-#else\n-.macro\tARM_FUNC_START name\n-\t.text\n-\t.align 0\n-\t.arm\n-#ifdef __APPLE__\n-\tENTRY($0)\n-#else\n-\tENTRY(\\name)\n-#endif\n-\tUNWIND .fnstart\n .endm\n+#if defined(HAVE_AS_CFI_PSEUDO_OP) && defined(__ARM_EABI__)\n+\t.cfi_sections\t.debug_frame\n #endif\n \n-.macro\tRETLDM\tregs=, cond=, dirn=ia\n-#if defined (__INTERWORKING__)\n-\t.ifc \"\\regs\",\"\"\n-\tldr\\cond\tlr, [sp], #4\n-\t.else\n-\tldm\\cond\\dirn\tsp!, {\\regs, lr}\n-\t.endif\n-\tbx\\cond\tlr\n+#define CONCAT(a, b)\tCONCAT2(a, b)\n+#define CONCAT2(a, b)\ta ## b\n+\n+#ifdef __USER_LABEL_PREFIX__\n+# define CNAME(X)\tCONCAT (__USER_LABEL_PREFIX__, X)\n #else\n-\t.ifc \"\\regs\",\"\"\n-\tldr\\cond\tpc, [sp], #4\n-\t.else\n-\tldm\\cond\\dirn\tsp!, {\\regs, pc}\n-\t.endif\n+# define CNAME(X)\tX\n+#endif\n+#ifdef __ELF__\n+# define SIZE(X)\t.size CNAME(X), . - CNAME(X)\n+# define TYPE(X, Y)\t.type CNAME(X), Y\n+#else\n+# define SIZE(X)\n+# define TYPE(X, Y)\n #endif\n-.endm\n-\n-\t@ r0:   ffi_prep_args\n-\t@ r1:   &ecif\n-\t@ r2:   cif->bytes\n-\t@ r3:   fig->flags\n-\t@ sp+0: ecif.rvalue\n-\n-\t@ This assumes we are using gas.\n-ARM_FUNC_START ffi_call_SYSV\n-\t@ Save registers\n-        stmfd\tsp!, {r0-r3, fp, lr}\n-\tUNWIND .save\t{r0-r3, fp, lr}\n-\tmov\tfp, sp\n-\n-\tUNWIND .setfp\tfp, sp\n-\n-\t@ Make room for all of the new args.\n-\tsub\tsp, fp, r2\n-\n-\t@ Place all of the ffi_prep_args in position\n-\tmov\tr0, sp\n-\t@     r1 already set\n-\n-\t@ Call ffi_prep_args(stack, &ecif)\n-\tbl\tCNAME(ffi_prep_args)\n-\n-\t@ move first 4 parameters in registers\n-\tldmia\tsp, {r0-r3}\n-\n-\t@ and adjust stack\n-\tsub\tlr, fp, sp\t@ cif->bytes == fp - sp\n-\tldr\tip, [fp]\t@ load fn() in advance\n-\tcmp\tlr, #16\n-\tmovhs\tlr, #16\n-\tadd\tsp, sp, lr\n-\n-\t@ call (fn) (...)\n-\tcall_reg(ip)\n-\t\n-\t@ Remove the space we pushed for the args\n-\tmov\tsp, fp\n-\n-\t@ Load r2 with the pointer to storage for the return value\n-\tldr\tr2, [sp, #24]\n \n-\t@ Load r3 with the return type code \n-\tldr\tr3, [sp, #12]\n+#define ARM_FUNC_START(name, gl) \\\n+\t.align\t3; \\\n+\t.ifne gl; .globl CNAME(name); FFI_HIDDEN(CNAME(name)); .endif; \\\n+\tTYPE(name, %function); \\\n+\tCNAME(name):\n \n-\t@ If the return value pointer is NULL, assume no return value.\n-\tcmp\tr2, #0\n-\tbeq\tLSYM(Lepilogue)\n+#define ARM_FUNC_END(name) \\\n+\tSIZE(name)\n \n-@ return INT\n-\tcmp\tr3, #FFI_TYPE_INT\n-#if defined(__SOFTFP__) || defined(__ARM_EABI__)\n-\tcmpne\tr3, #FFI_TYPE_FLOAT\n-#endif\n-\tstreq\tr0, [r2]\n-\tbeq\tLSYM(Lepilogue)\n+/* Aid in defining a jump table with 8 bytes between entries.  */\n+.macro E index\n+\t.if . - 0b - 8*\\index\n+\t.error \"type table out of sync\"\n+\t.endif\n+.endm\n \n-\t@ return INT64\n-\tcmp\tr3, #FFI_TYPE_SINT64\n-#if defined(__SOFTFP__) || defined(__ARM_EABI__)\n-\tcmpne\tr3, #FFI_TYPE_DOUBLE\n-#endif\n-\tstmeqia\tr2, {r0, r1}\n+\t.text\n+\t.syntax unified\n+\t.arm\n \n-#if !defined(__SOFTFP__) && !defined(__ARM_EABI__)\n-\tbeq\tLSYM(Lepilogue)\n+\t/* We require interworking on LDM, which implies ARMv5T,\n+\t   which implies the existance of BLX.  */\n+\t.arch\tarmv5t\n+\n+\t/* Note that we use STC and LDC to encode VFP instructions,\n+\t   so that we do not need \".fpu vfp\", nor get that added to\n+\t   the object file attributes.  These will not be executed\n+\t   unless the FFI_VFP abi is used.  */\n+\n+\t@ r0:   stack\n+\t@ r1:   frame\n+\t@ r2:   fn\n+\t@ r3:\tvfp_used\n+\n+ARM_FUNC_START(ffi_call_VFP, 1)\n+\tUNWIND\t.fnstart\n+\tcfi_startproc\n+\n+\tcmp\tr3, #3\t\t\t@ load only d0 if possible\n+\tldcle\tp11, cr0, [r0]\t\t@ vldrle d0, [sp]\n+\tldcgt\tp11, cr0, [r0], {16}\t@ vldmgt sp, {d0-d7}\n+\tadd\tr0, r0, #64\t\t@ discard the vfp register args\n+\t/* FALLTHRU */\n+ARM_FUNC_END(ffi_call_VFP)\n+\n+ARM_FUNC_START(ffi_call_SYSV, 1)\n+\tstm\tr1, {fp, lr}\n+\tmov\tfp, r1\n+\n+\t@ This is a bit of a lie wrt the origin of the unwind info, but\n+\t@ now we've got the usual frame pointer and two saved registers.\n+\tUNWIND\t.save {fp,lr}\n+\tUNWIND\t.setfp fp, sp\n+\tcfi_def_cfa(fp, 8)\n+\tcfi_rel_offset(fp, 0)\n+\tcfi_rel_offset(lr, 4)\n+\n+\tmov\tsp, r0\t\t@ install the stack pointer\n+\tmov\tlr, r2\t\t@ move the fn pointer out of the way\n+\tldr\tip, [fp, #16]\t@ install the static chain\n+\tldmia\tsp!, {r0-r3}\t@ move first 4 parameters in registers.\n+\tblx\tlr\t\t@ call fn\n \n-@ return FLOAT\n-\tcmp\tr3, #FFI_TYPE_FLOAT\n-\tstfeqs\tf0, [r2]\n-\tbeq\tLSYM(Lepilogue)\n+\t@ Load r2 with the pointer to storage for the return value\n+\t@ Load r3 with the return type code\n+\tldr\tr2, [fp, #8]\n+\tldr\tr3, [fp, #12]\n \n-@ return DOUBLE or LONGDOUBLE\n-\tcmp\tr3, #FFI_TYPE_DOUBLE\n-\tstfeqd\tf0, [r2]\n-#endif\n+\t@ Deallocate the stack with the arguments.\n+\tmov\tsp, fp\n+\tcfi_def_cfa_register(sp)\n \n-LSYM(Lepilogue):\n-#if defined (__INTERWORKING__)\n-\tldmia   sp!, {r0-r3,fp, lr}\n-\tbx\tlr\n-#else\n-\tldmia   sp!, {r0-r3,fp, pc}\n-#endif\n+\t@ Store values stored in registers.\n+\t.align\t3\n+\tadd\tpc, pc, r3, lsl #3\n+\tnop\n+0:\n+E ARM_TYPE_VFP_S\n+\tstc\tp10, cr0, [r2]\t\t@ vstr s0, [r2]\n+\tpop\t{fp,pc}\n+E ARM_TYPE_VFP_D\n+\tstc\tp11, cr0, [r2]\t\t@ vstr d0, [r2]\n+\tpop\t{fp,pc}\n+E ARM_TYPE_VFP_N\n+\tstc\tp11, cr0, [r2], {8}\t@ vstm r2, {d0-d3}\n+\tpop\t{fp,pc}\n+E ARM_TYPE_INT64\n+\tstr\tr1, [r2, #4]\n+\tnop\n+E ARM_TYPE_INT\n+\tstr\tr0, [r2]\n+\tpop\t{fp,pc}\n+E ARM_TYPE_VOID\n+\tpop\t{fp,pc}\n+\tnop\n+E ARM_TYPE_STRUCT\n+\tpop\t{fp,pc}\n \n-.ffi_call_SYSV_end:\n-\tUNWIND .fnend\n-#ifdef __ELF__\n-        .size    CNAME(ffi_call_SYSV),.ffi_call_SYSV_end-CNAME(ffi_call_SYSV)\n-#endif\n+\tcfi_endproc\n+\tUNWIND\t.fnend\n+ARM_FUNC_END(ffi_call_SYSV)\n \n \n /*\n-\tunsigned int FFI_HIDDEN\n-\tffi_closure_SYSV_inner (closure, respp, args)\n-\t     ffi_closure *closure;\n-\t     void **respp;\n-  \t     void *args;\n+\tint ffi_closure_inner_* (cif, fun, user_data, frame)\n */\n \n-ARM_FUNC_START ffi_closure_SYSV\n-\tUNWIND .pad #16\n+ARM_FUNC_START(ffi_go_closure_SYSV, 1)\n+\tcfi_startproc\n+\tstmdb\tsp!, {r0-r3}\t\t\t@ save argument regs\n+\tcfi_adjust_cfa_offset(16)\n+\tldr\tr0, [ip, #4]\t\t\t@ load cif\n+\tldr\tr1, [ip, #8]\t\t\t@ load fun\n+\tmov\tr2, ip\t\t\t\t@ load user_data\n+\tb\t0f\n+\tcfi_endproc\n+ARM_FUNC_END(ffi_go_closure_SYSV)\n+\n+ARM_FUNC_START(ffi_closure_SYSV, 1)\n+\tUNWIND\t.fnstart\n+\tcfi_startproc\n+\tstmdb\tsp!, {r0-r3}\t\t\t@ save argument regs\n+\tcfi_adjust_cfa_offset(16)\n+\tldr\tr0, [ip, #FFI_TRAMPOLINE_SIZE]\t  @ load cif\n+\tldr\tr1, [ip, #FFI_TRAMPOLINE_SIZE+4]  @ load fun\n+\tldr\tr2, [ip, #FFI_TRAMPOLINE_SIZE+8]  @ load user_data\n+0:\n+\tadd\tip, sp, #16\t\t\t@ compute entry sp\n+\tsub\tsp, sp, #64+32\t\t\t@ allocate frame\n+\tcfi_adjust_cfa_offset(64+32)\n+\tstmdb\tsp!, {ip,lr}\n+\n+\t/* Remember that EABI unwind info only applies at call sites.\n+\t   We need do nothing except note the save of the stack pointer\n+\t   and the link registers.  */\n+\tUNWIND\t.save {sp,lr}\n+\tcfi_adjust_cfa_offset(8)\n+\tcfi_rel_offset(lr, 4)\n+\n+\tadd\tr3, sp, #8\t\t\t@ load frame\n+\tbl\tCNAME(ffi_closure_inner_SYSV)\n+\n+\t@ Load values returned in registers.\n+\tadd\tr2, sp, #8+64\t\t\t@ load result\n+\tadr\tr3, CNAME(ffi_closure_ret)\n+\tadd\tpc, r3, r0, lsl #3\n+\tcfi_endproc\n+\tUNWIND\t.fnend\n+ARM_FUNC_END(ffi_closure_SYSV)\n+\n+ARM_FUNC_START(ffi_go_closure_VFP, 1)\n+\tcfi_startproc\n+\tstmdb\tsp!, {r0-r3}\t\t\t@ save argument regs\n+\tcfi_adjust_cfa_offset(16)\n+\tldr\tr0, [ip, #4]\t\t\t@ load cif\n+\tldr\tr1, [ip, #8]\t\t\t@ load fun\n+\tmov\tr2, ip\t\t\t\t@ load user_data\n+\tb\t0f\n+\tcfi_endproc\n+ARM_FUNC_END(ffi_go_closure_VFP)\n+\n+ARM_FUNC_START(ffi_closure_VFP, 1)\n+\tUNWIND\t.fnstart\n+\tcfi_startproc\n+\tstmdb\tsp!, {r0-r3}\t\t\t@ save argument regs\n+\tcfi_adjust_cfa_offset(16)\n+\tldr\tr0, [ip, #FFI_TRAMPOLINE_SIZE]\t  @ load cif\n+\tldr\tr1, [ip, #FFI_TRAMPOLINE_SIZE+4]  @ load fun\n+\tldr\tr2, [ip, #FFI_TRAMPOLINE_SIZE+8]  @ load user_data\n+0:\n \tadd\tip, sp, #16\n-\tstmfd\tsp!, {ip, lr}\n-\tUNWIND .save\t{r0, lr}\n-\tadd\tr2, sp, #8\n-\tUNWIND .pad #16\n-\tsub\tsp, sp, #16\n-\tstr\tsp, [sp, #8]\n-\tadd\tr1, sp, #8\n-\tbl\tCNAME(ffi_closure_SYSV_inner)\n-\tcmp\tr0, #FFI_TYPE_INT\n-\tbeq\t.Lretint\n-\n-\tcmp\tr0, #FFI_TYPE_FLOAT\n-#if defined(__SOFTFP__) || defined(__ARM_EABI__)\n-\tbeq\t.Lretint\n-#else\n-\tbeq\t.Lretfloat\n-#endif\n-\n-\tcmp\tr0, #FFI_TYPE_DOUBLE\n-#if defined(__SOFTFP__) || defined(__ARM_EABI__)\n-\tbeq\t.Lretlonglong\n-#else\n-\tbeq\t.Lretdouble\n-#endif\n+\tsub\tsp, sp, #64+32\t\t\t@ allocate frame\n+\tcfi_adjust_cfa_offset(64+32)\n+\tstc\tp11, cr0, [sp], {16}\t\t@ vstm sp, {d0-d7}\n+\tstmdb\tsp!, {ip,lr}\n+\n+\t/* See above.  */\n+\tUNWIND\t.save {sp,lr}\n+\tcfi_adjust_cfa_offset(8)\n+\tcfi_rel_offset(lr, 4)\n+\n+\tadd\tr3, sp, #8\t\t\t@ load frame\n+\tbl\tCNAME(ffi_closure_inner_VFP)\n+\n+\t@ Load values returned in registers.\n+\tadd\tr2, sp, #8+64\t\t\t@ load result\n+\tadr\tr3, CNAME(ffi_closure_ret)\n+\tadd\tpc, r3, r0, lsl #3\n+\tcfi_endproc\n+\tUNWIND\t.fnend\n+ARM_FUNC_END(ffi_closure_VFP)\n+\n+/* Load values returned in registers for both closure entry points.\n+   Note that we use LDM with SP in the register set.  This is deprecated\n+   by ARM, but not yet unpredictable.  */\n+\n+ARM_FUNC_START(ffi_closure_ret, 0)\n+\tcfi_startproc\n+\tcfi_rel_offset(sp, 0)\n+\tcfi_rel_offset(lr, 4)\n+0:\n+E ARM_TYPE_VFP_S\n+\tldc\tp10, cr0, [r2]\t\t\t@ vldr s0, [r2]\n+\tldm\tsp, {sp,pc}\n+E ARM_TYPE_VFP_D\n+\tldc\tp11, cr0, [r2]\t\t\t@ vldr d0, [r2]\n+\tldm\tsp, {sp,pc}\n+E ARM_TYPE_VFP_N\n+\tldc\tp11, cr0, [r2], {8}\t\t@ vldm r2, {d0-d3}\n+\tldm\tsp, {sp,pc}\n+E ARM_TYPE_INT64\n+\tldr\tr1, [r2, #4]\n+\tnop\n+E ARM_TYPE_INT\n+\tldr\tr0, [r2]\n+\tldm\tsp, {sp,pc}\n+E ARM_TYPE_VOID\n+\tldm\tsp, {sp,pc}\n+\tnop\n+E ARM_TYPE_STRUCT\n+\tldm\tsp, {sp,pc}\n+\tcfi_endproc\n+ARM_FUNC_END(ffi_closure_ret)\n \n-\tcmp\tr0, #FFI_TYPE_LONGDOUBLE\n-#if defined(__SOFTFP__) || defined(__ARM_EABI__)\n-\tbeq\t.Lretlonglong\n-#else\n-\tbeq\t.Lretlongdouble\n-#endif\n+#if FFI_EXEC_TRAMPOLINE_TABLE\n \n-\tcmp\tr0, #FFI_TYPE_SINT64\n-\tbeq\t.Lretlonglong\n-.Lclosure_epilogue:\n-\tadd\tsp, sp, #16\n-\tldmfd\tsp, {sp, pc}\n-.Lretint:\n-\tldr\tr0, [sp]\n-\tb\t.Lclosure_epilogue\n-.Lretlonglong:\n-\tldr\tr0, [sp]\n-\tldr\tr1, [sp, #4]\n-\tb\t.Lclosure_epilogue\n-\n-#if !defined(__SOFTFP__) && !defined(__ARM_EABI__)\n-.Lretfloat:\n-\tldfs\tf0, [sp]\n-\tb\t.Lclosure_epilogue\n-.Lretdouble:\n-\tldfd\tf0, [sp]\n-\tb\t.Lclosure_epilogue\n-.Lretlongdouble:\n-\tldfd\tf0, [sp]\n-\tb\t.Lclosure_epilogue\n-#endif\n+/* ??? The iOS support should be updated.  The first insn used to\n+   be STMFD, but that's been moved into ffi_closure_SYSV.  If the\n+   writable page is put after this one we can make use of the\n+   pc+8 feature of the architecture.  We can also reduce the size\n+   of the thunk to 8 and pack more of these into the page.\n \n-.ffi_closure_SYSV_end:\n-\tUNWIND .fnend\n-#ifdef __ELF__\n-        .size    CNAME(ffi_closure_SYSV),.ffi_closure_SYSV_end-CNAME(ffi_closure_SYSV)\n-#endif\n+   In the meantime, simply replace the STMFD with a NOP so as to\n+   keep all the magic numbers the same within ffi.c.  */\n \n+\t.align\t12\n+ARM_FUNC_START(ffi_closure_trampoline_table_page)\n+.rept\t4096 / 12\n+\tnop\n+\tldr\tip, [pc, #-4092]\n+\tldr\tpc, [pc, #-4092]\n+.endr\n \n-/* Below are VFP hard-float ABI call and closure implementations.\n-   Add VFP FPU directive here. This is only compiled into the library\n-   under EABI.  */\n-#ifdef __ARM_EABI__\n-\t.fpu\tvfp\n-\n-\t@ r0:   fn\n-\t@ r1:   &ecif\n-\t@ r2:   cif->bytes\n-\t@ r3:   fig->flags\n-\t@ sp+0: ecif.rvalue\n-\n-ARM_FUNC_START ffi_call_VFP\n-\t@ Save registers\n-        stmfd\tsp!, {r0-r3, fp, lr}\n-\tUNWIND .save\t{r0-r3, fp, lr}\n-\tmov\tfp, sp\n-\tUNWIND .setfp\tfp, sp\n-\n-\t@ Make room for all of the new args.\n-\tsub\tsp, sp, r2\n-\n-\t@ Make room for loading VFP args\n-\tsub\tsp, sp, #64\n-\n-\t@ Place all of the ffi_prep_args in position\n-\tmov\tr0, sp\n-\t@     r1 already set\n-\tsub\tr2, fp, #64   @ VFP scratch space\n-\n-\t@ Call ffi_prep_args(stack, &ecif, vfp_space)\n-\tbl\tCNAME(ffi_prep_args)\n-\n-\t@ Load VFP register args if needed\n-\tcmp\tr0, #0\n-\tbeq\tLSYM(Lbase_args)\n-\n-\t@ Load only d0 if possible\n-\tcmp\tr0, #3\n-\tsub\tip, fp, #64\n-\tflddle\td0, [ip]\n-\tfldmiadgt\tip, {d0-d7}\n-\n-LSYM(Lbase_args):\n-\t@ move first 4 parameters in registers\n-\tldmia\tsp, {r0-r3}\n-\n-\t@ and adjust stack\n-\tsub\tlr, ip, sp\t@ cif->bytes == (fp - 64) - sp\n-\tldr\tip, [fp]\t@ load fn() in advance\n-        cmp\tlr, #16\n-\tmovhs\tlr, #16\n-        add\tsp, sp, lr\n-\n-\t@ call (fn) (...)\n-\tcall_reg(ip)\n-\n-\t@ Remove the space we pushed for the args\n-\tmov\tsp, fp\n+#else\n \n-\t@ Load r2 with the pointer to storage for\n-\t@ the return value\n-\tldr\tr2, [sp, #24]\n-\n-\t@ Load r3 with the return type code \n-\tldr\tr3, [sp, #12]\n-\n-\t@ If the return value pointer is NULL,\n-\t@ assume no return value.\n-\tcmp\tr2, #0\n-\tbeq\tLSYM(Lepilogue_vfp)\n-\n-\tcmp\tr3, #FFI_TYPE_INT\n-\tstreq\tr0, [r2]\n-\tbeq\tLSYM(Lepilogue_vfp)\n-\n-\tcmp\tr3, #FFI_TYPE_SINT64\n-\tstmeqia\tr2, {r0, r1}\n-\tbeq\tLSYM(Lepilogue_vfp)\n-\n-\tcmp\tr3, #FFI_TYPE_FLOAT\n-\tfstseq\ts0, [r2]\n-\tbeq\tLSYM(Lepilogue_vfp)\n-\t\n-\tcmp\tr3, #FFI_TYPE_DOUBLE\n-\tfstdeq\td0, [r2]\n-\tbeq\tLSYM(Lepilogue_vfp)\n-\n-\tcmp\tr3, #FFI_TYPE_STRUCT_VFP_FLOAT\n-\tcmpne\tr3, #FFI_TYPE_STRUCT_VFP_DOUBLE\n-\tfstmiadeq\tr2, {d0-d3}\n-\n-LSYM(Lepilogue_vfp):\n-\tRETLDM\t\"r0-r3,fp\"\n-\n-.ffi_call_VFP_end:\n-\tUNWIND .fnend\n-        .size    CNAME(ffi_call_VFP),.ffi_call_VFP_end-CNAME(ffi_call_VFP)\n-\n-\n-ARM_FUNC_START ffi_closure_VFP\n-\tfstmfdd\tsp!, {d0-d7}\n-\t@ r0-r3, then d0-d7\n-\tUNWIND .pad #80\n-\tadd\tip, sp, #80\n-\tstmfd\tsp!, {ip, lr}\n-\tUNWIND .save\t{r0, lr}\n-\tadd\tr2, sp, #72\n-\tadd\tr3, sp, #8\n-\tUNWIND .pad #72\n-\tsub\tsp, sp, #72\n-\tstr\tsp, [sp, #64]\n-\tadd\tr1, sp, #64\n-\tbl\tCNAME(ffi_closure_SYSV_inner)\n-\n-\tcmp\tr0, #FFI_TYPE_INT\n-\tbeq\t.Lretint_vfp\n-\n-\tcmp\tr0, #FFI_TYPE_FLOAT\n-\tbeq\t.Lretfloat_vfp\n-\n-\tcmp\tr0, #FFI_TYPE_DOUBLE\n-\tcmpne\tr0, #FFI_TYPE_LONGDOUBLE\n-\tbeq\t.Lretdouble_vfp\n-\n-\tcmp\tr0, #FFI_TYPE_SINT64\n-\tbeq\t.Lretlonglong_vfp\n-\n-\tcmp\tr0, #FFI_TYPE_STRUCT_VFP_FLOAT\n-\tbeq\t.Lretfloat_struct_vfp\n-\n-\tcmp\tr0, #FFI_TYPE_STRUCT_VFP_DOUBLE\n-\tbeq\t.Lretdouble_struct_vfp\n-\t\n-.Lclosure_epilogue_vfp:\n-\tadd\tsp, sp, #72\n-\tldmfd\tsp, {sp, pc}\n-\n-.Lretfloat_vfp:\n-\tflds\ts0, [sp]\n-\tb\t.Lclosure_epilogue_vfp\n-.Lretdouble_vfp:\n-\tfldd\td0, [sp]\n-\tb\t.Lclosure_epilogue_vfp\n-.Lretint_vfp:\n-\tldr\tr0, [sp]\n-\tb\t.Lclosure_epilogue_vfp\n-.Lretlonglong_vfp:\n-\tldmia\tsp, {r0, r1}\n-\tb\t.Lclosure_epilogue_vfp\n-.Lretfloat_struct_vfp:\n-\tfldmiad\tsp, {d0-d1}\n-\tb\t.Lclosure_epilogue_vfp\n-.Lretdouble_struct_vfp:\n-\tfldmiad\tsp, {d0-d3}\n-\tb\t.Lclosure_epilogue_vfp\n-\n-.ffi_closure_VFP_end:\n-\tUNWIND .fnend\n-        .size    CNAME(ffi_closure_VFP),.ffi_closure_VFP_end-CNAME(ffi_closure_VFP)\n-#endif\n+ARM_FUNC_START(ffi_arm_trampoline, 1)\n+0:\tadr\tip, 0b\n+\tldr\tpc, 1f\n+1:\t.long\t0\n+ARM_FUNC_END(ffi_arm_trampoline)\n \n-ENTRY(ffi_arm_trampoline)\n-\tstmfd sp!, {r0-r3}\n-\tldr r0, [pc]\n-\tldr pc, [pc]\n+#endif /* FFI_EXEC_TRAMPOLINE_TABLE */\n \n #if defined __ELF__ && defined __linux__\n \t.section\t.note.GNU-stack,\"\",%progbits"}, {"sha": "935e8de179547ec64263237692aec2d6824f4b6f", "filename": "libffi/src/arm/trampoline.S", "status": "removed", "additions": 0, "deletions": 4450, "changes": 4450, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e22fcb7985349b93646b86351033e1fb09c46c/libffi%2Fsrc%2Farm%2Ftrampoline.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e22fcb7985349b93646b86351033e1fb09c46c/libffi%2Fsrc%2Farm%2Ftrampoline.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farm%2Ftrampoline.S?ref=62e22fcb7985349b93646b86351033e1fb09c46c"}, {"sha": "22a2acdac192c1b912a51c962aefc02dac1ae8ee", "filename": "libffi/src/bfin/ffi.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fbfin%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fbfin%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fbfin%2Fffi.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -1,5 +1,6 @@\n /* -----------------------------------------------------------------------\n-   ffi.c - Copyright (c) 2012  Alexandre K. I. de Mendonca <alexandre.keunecke@gmail.com>\n+   ffi.c - Copyright (c) 2012  Alexandre K. I. de Mendonca <alexandre.keunecke@gmail.com>,\n+\t\t\t\t\t\t\t   Paulo Pizarro <paulo.pizarro@gmail.com>\n \n    Blackfin Foreign Function Interface\n "}, {"sha": "f4278be2426d2540b26cbef1f1bf0d0d32e3fd38", "filename": "libffi/src/bfin/sysv.S", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fbfin%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fbfin%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fbfin%2Fsysv.S?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -1,5 +1,6 @@\n /* -----------------------------------------------------------------------\n-   sysv.S - Copyright (c) 2012  Alexandre K. I. de Mendonca <alexandre.keunecke@gmail.com>\n+   sysv.S - Copyright (c) 2012  Alexandre K. I. de Mendonca <alexandre.keunecke@gmail.com>,\n+                                Paulo Pizarro <paulo.pizarro@gmail.com>\n \n    Blackfin Foreign Function Interface\n \n@@ -32,33 +33,34 @@\n .align 4\n \n \t/*\n-\t There is a \"feature\" in the bfin toolchain that it puts a _ before funcion names\n+\t There is a \"feature\" in the bfin toolchain that it puts a _ before function names\n \t that's why the function here it's called _ffi_call_SYSV and not ffi_call_SYSV\n \t */\n \t.global _ffi_call_SYSV;\n \t.type _ffi_call_SYSV, STT_FUNC;\n \t.func ffi_call_SYSV\n \n \t/*\n-\tcif->bytes  \t= R0\t(fp+8)\n-\t&ecif\t\t\t= R1\t(fp+12)\n-\tffi_prep_args\t= R2\t(fp+16)\n-\tret_type\t\t= stack (fp+20)\n-\tecif.rvalue\t\t= stack (fp+24)\n-\tfn\t\t\t\t= stack\t(fp+28)\n-\t\t\t\t\t  got\t(fp+32)\n-    There is room for improvement here (we can use temporary registers\n+         cif->bytes    = R0    (fp+8)\n+         &ecif         = R1    (fp+12)\n+         ffi_prep_args = R2    (fp+16)\n+         ret_type      = stack (fp+20)\n+         ecif.rvalue   = stack (fp+24)\n+         fn            = stack (fp+28)\n+                           got (fp+32)\n+\n+        There is room for improvement here (we can use temporary registers\n         instead of saving the values in the memory)\n-\tREGS:\n-\t\tP5 => Stack pointer (function arguments)\n-\t\tR5 => cif->bytes\n-\t\tR4 => ret->type\n-\n-\t\tFP-20 = P3\n-\t\tFP-16 = SP (parameters area)\n-\t\tFP-12 = SP (temp)\n-\t\tFP-08 = function return part 1 [R0]\n-\t\tFP-04 = function return part 2 [R1]\n+        REGS:\n+        P5 => Stack pointer (function arguments)\n+        R5 => cif->bytes\n+        R4 => ret->type\n+\n+        FP-20 = P3\n+        FP-16 = SP (parameters area)\n+        FP-12 = SP (temp)\n+        FP-08 = function return part 1 [R0]\n+        FP-04 = function return part 2 [R1]\n \t*/\n \n _ffi_call_SYSV:"}, {"sha": "721ff00ea43bce8decb67d9fef6a233d55ddd6ba", "filename": "libffi/src/closures.c", "status": "modified", "additions": 54, "deletions": 10, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fclosures.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fclosures.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fclosures.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -34,7 +34,7 @@\n #include <ffi_common.h>\n \n #if !FFI_MMAP_EXEC_WRIT && !FFI_EXEC_TRAMPOLINE_TABLE\n-# if __gnu_linux__\n+# if __gnu_linux__ && !defined(__ANDROID__)\n /* This macro indicates it may be forbidden to map anonymous memory\n    with both write and execute permission.  Code compiled when this\n    option is defined will attempt to map such pages once, but if it\n@@ -181,10 +181,26 @@ static int emutramp_enabled = -1;\n static int\n emutramp_enabled_check (void)\n {\n-  if (getenv (\"FFI_DISABLE_EMUTRAMP\") == NULL)\n-    return 1;\n-  else\n+  char *buf = NULL;\n+  size_t len = 0;\n+  FILE *f;\n+  int ret;\n+  f = fopen (\"/proc/self/status\", \"r\");\n+  if (f == NULL)\n     return 0;\n+  ret = 0;\n+\n+  while (getline (&buf, &len, f) != -1)\n+    if (!strncmp (buf, \"PaX:\", 4))\n+      {\n+        char emutramp;\n+        if (sscanf (buf, \"%*s %*c%c\", &emutramp) == 1)\n+          ret = (emutramp == 'E');\n+        break;\n+      }\n+  free (buf);\n+  fclose (f);\n+  return ret;\n }\n \n #define is_emutramp_enabled() (emutramp_enabled >= 0 ? emutramp_enabled \\\n@@ -249,9 +265,15 @@ static size_t execsize = 0;\n \n /* Open a temporary file name, and immediately unlink it.  */\n static int\n-open_temp_exec_file_name (char *name)\n+open_temp_exec_file_name (char *name, int flags)\n {\n-  int fd = mkstemp (name);\n+  int fd;\n+\n+#ifdef HAVE_MKOSTEMP\n+  fd = mkostemp (name, flags);\n+#else\n+  fd = mkstemp (name);\n+#endif\n \n   if (fd != -1)\n     unlink (name);\n@@ -264,16 +286,38 @@ static int\n open_temp_exec_file_dir (const char *dir)\n {\n   static const char suffix[] = \"/ffiXXXXXX\";\n-  int lendir = strlen (dir);\n-  char *tempname = __builtin_alloca (lendir + sizeof (suffix));\n+  int lendir, flags;\n+  char *tempname;\n+#ifdef O_TMPFILE\n+  int fd;\n+#endif\n+\n+#ifdef O_CLOEXEC\n+  flags = O_CLOEXEC;\n+#else\n+  flags = 0;\n+#endif\n+\n+#ifdef O_TMPFILE\n+  fd = open (dir, flags | O_RDWR | O_EXCL | O_TMPFILE, 0700);\n+  /* If the running system does not support the O_TMPFILE flag then retry without it. */\n+  if (fd != -1 || (errno != EINVAL && errno != EISDIR && errno != EOPNOTSUPP)) {\n+    return fd;\n+  } else {\n+    errno = 0;\n+  }\n+#endif\n+\n+  lendir = strlen (dir);\n+  tempname = __builtin_alloca (lendir + sizeof (suffix));\n \n   if (!tempname)\n     return -1;\n \n   memcpy (tempname, dir, lendir);\n   memcpy (tempname + lendir, suffix, sizeof (suffix));\n \n-  return open_temp_exec_file_name (tempname);\n+  return open_temp_exec_file_name (tempname, flags);\n }\n \n /* Open a temporary file in the directory in the named environment\n@@ -382,7 +426,7 @@ open_temp_exec_file_opts_next (void)\n }\n \n /* Return a file descriptor of a temporary zero-sized file in a\n-   writable and exexutable filesystem.  */\n+   writable and executable filesystem.  */\n static int\n open_temp_exec_file (void)\n {"}, {"sha": "f3172b1ef6c9a9f04870cc76815984091de95da9", "filename": "libffi/src/debug.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fdebug.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fdebug.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fdebug.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -54,6 +54,11 @@ void ffi_type_test(ffi_type *a, char *file, int line)\n   FFI_ASSERT_AT(a->type <= FFI_TYPE_LAST, file, line);\n   FFI_ASSERT_AT(a->type == FFI_TYPE_VOID || a->size > 0, file, line);\n   FFI_ASSERT_AT(a->type == FFI_TYPE_VOID || a->alignment > 0, file, line);\n-  FFI_ASSERT_AT(a->type != FFI_TYPE_STRUCT || a->elements != NULL, file, line);\n+  FFI_ASSERT_AT((a->type != FFI_TYPE_STRUCT && a->type != FFI_TYPE_COMPLEX)\n+\t\t|| a->elements != NULL, file, line);\n+  FFI_ASSERT_AT(a->type != FFI_TYPE_COMPLEX\n+\t\t|| (a->elements != NULL\n+\t\t    && a->elements[0] != NULL && a->elements[1] == NULL),\n+\t\tfile, line);\n \n }"}, {"sha": "7e4ea83b7d2beac958d49311bc8ff9e05fa64684", "filename": "libffi/src/dlmalloc.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fdlmalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fdlmalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fdlmalloc.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -1255,7 +1255,7 @@ extern void*     sbrk(ptrdiff_t);\n #define SIZE_T_BITSIZE      (sizeof(size_t) << 3)\n \n /* Some constants coerced to size_t */\n-/* Annoying but necessary to avoid errors on some plaftorms */\n+/* Annoying but necessary to avoid errors on some platforms */\n #define SIZE_T_ZERO         ((size_t)0)\n #define SIZE_T_ONE          ((size_t)1)\n #define SIZE_T_TWO          ((size_t)2)\n@@ -1409,7 +1409,7 @@ static int win32munmap(void* ptr, size_t size) {\n #define CALL_MORECORE(S)     MFAIL\n #endif /* HAVE_MORECORE */\n \n-/* mstate bit set if continguous morecore disabled or failed */\n+/* mstate bit set if contiguous morecore disabled or failed */\n #define USE_NONCONTIGUOUS_BIT (4U)\n \n /* segment bit set in create_mspace_with_base */\n@@ -1661,7 +1661,7 @@ struct malloc_chunk {\n typedef struct malloc_chunk  mchunk;\n typedef struct malloc_chunk* mchunkptr;\n typedef struct malloc_chunk* sbinptr;  /* The type of bins of chunks */\n-typedef unsigned int bindex_t;         /* Described below */\n+typedef size_t bindex_t;               /* Described below */\n typedef unsigned int binmap_t;         /* Described below */\n typedef unsigned int flag_t;           /* The type of various bit flag sets */\n \n@@ -2291,7 +2291,7 @@ static size_t traverse_and_check(mstate m);\n #define treebin_at(M,i)     (&((M)->treebins[i]))\n \n /* assign tree index for size S to variable I */\n-#if defined(__GNUC__) && defined(i386)\n+#if defined(__GNUC__) && defined(__i386__)\n #define compute_tree_index(S, I)\\\n {\\\n   size_t X = S >> TREEBIN_SHIFT;\\\n@@ -2356,7 +2356,7 @@ static size_t traverse_and_check(mstate m);\n \n /* index corresponding to given bit */\n \n-#if defined(__GNUC__) && defined(i386)\n+#if defined(__GNUC__) && defined(__i386__)\n #define compute_bit2idx(X, I)\\\n {\\\n   unsigned int J;\\\n@@ -3090,8 +3090,8 @@ static void internal_malloc_stats(mstate m) {\n      and choose its bk node as its replacement.\n   2. If x was the last node of its size, but not a leaf node, it must\n      be replaced with a leaf node (not merely one with an open left or\n-     right), to make sure that lefts and rights of descendents\n-     correspond properly to bit masks.  We use the rightmost descendent\n+     right), to make sure that lefts and rights of descendants\n+     correspond properly to bit masks.  We use the rightmost descendant\n      of x.  We could use any other leaf, but this is easy to locate and\n      tends to counteract removal of leftmosts elsewhere, and so keeps\n      paths shorter than minimally guaranteed.  This doesn't loop much\n@@ -3388,7 +3388,7 @@ static void add_segment(mstate m, char* tbase, size_t tsize, flag_t mmapped) {\n   *ss = m->seg; /* Push current record */\n   m->seg.base = tbase;\n   m->seg.size = tsize;\n-  set_segment_flags(&m->seg, mmapped);\n+  (void)set_segment_flags(&m->seg, mmapped);\n   m->seg.next = ss;\n \n   /* Insert trailing fenceposts */\n@@ -3548,7 +3548,7 @@ static void* sys_alloc(mstate m, size_t nb) {\n     if (!is_initialized(m)) { /* first-time initialization */\n       m->seg.base = m->least_addr = tbase;\n       m->seg.size = tsize;\n-      set_segment_flags(&m->seg, mmap_flag);\n+      (void)set_segment_flags(&m->seg, mmap_flag);\n       m->magic = mparams.magic;\n       init_bins(m);\n       if (is_global(m)) \n@@ -5091,10 +5091,10 @@ int mspace_mallopt(int param_number, int value) {\n         Wolfram Gloger (Gloger@lrz.uni-muenchen.de).\n       * Use last_remainder in more cases.\n       * Pack bins using idea from  colin@nyx10.cs.du.edu\n-      * Use ordered bins instead of best-fit threshhold\n+      * Use ordered bins instead of best-fit threshold\n       * Eliminate block-local decls to simplify tracing and debugging.\n       * Support another case of realloc via move into top\n-      * Fix error occuring when initial sbrk_base not word-aligned.\n+      * Fix error occurring when initial sbrk_base not word-aligned.\n       * Rely on page size for units instead of SBRK_UNIT to\n         avoid surprises about sbrk alignment conventions.\n       * Add mallinfo, mallopt. Thanks to Raymond Nijssen"}, {"sha": "b77a836ddcf7d9c16bbb3bc386d78536a32f973e", "filename": "libffi/src/ia64/ffi.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fia64%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fia64%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fia64%2Fffi.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -401,7 +401,7 @@ ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n    the closure (in the \"trampoline\" area), but we replace the gp\n    pointer with a pointer to the closure itself.  We also add the real\n    gp pointer to the closure.  This allows the function entry code to\n-   both retrieve the user data, and to restire the correct gp pointer.  */\n+   both retrieve the user data, and to restore the correct gp pointer.  */\n \n extern void ffi_closure_unix ();\n "}, {"sha": "127123d5bc3a09b99116f264b88bd38769a86c2c", "filename": "libffi/src/java_raw_api.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fjava_raw_api.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fjava_raw_api.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fjava_raw_api.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -60,6 +60,9 @@ ffi_java_raw_size (ffi_cif *cif)\n \tcase FFI_TYPE_STRUCT:\n \t  /* No structure parameters in Java.\t*/\n \t  abort();\n+\tcase FFI_TYPE_COMPLEX:\n+\t  /* Not supported yet.  */\n+\t  abort();\n \tdefault:\n \t  result += FFI_SIZEOF_JAVA_RAW;\n       }\n@@ -104,6 +107,10 @@ ffi_java_raw_to_ptrarray (ffi_cif *cif, ffi_java_raw *raw, void **args)\n \t  *args = (void*) &(raw++)->ptr;\n \t  break;\n \n+\tcase FFI_TYPE_COMPLEX:\n+\t  /* Not supported yet.  */\n+\t  abort();\n+\n \tdefault:\n \t  *args = raw;\n \t  raw +=\n@@ -126,6 +133,9 @@ ffi_java_raw_to_ptrarray (ffi_cif *cif, ffi_java_raw *raw, void **args)\n \t  *args = (void*) raw;\n \t  raw += 2;\n \t  break;\n+\tcase FFI_TYPE_COMPLEX:\n+\t  /* Not supported yet.  */\n+\t  abort();\n \tdefault:\n \t  *args = (void*) raw++;\n       }\n@@ -254,6 +264,10 @@ ffi_java_rvalue_to_raw (ffi_cif *cif, void *rvalue)\n       *(SINT64 *)rvalue <<= 32;\n       break;\n \n+    case FFI_TYPE_COMPLEX:\n+      /* Not supported yet.  */\n+      abort();\n+\n     default:\n       break;\n     }\n@@ -279,6 +293,10 @@ ffi_java_raw_to_rvalue (ffi_cif *cif, void *rvalue)\n       *(SINT64 *)rvalue >>= 32;\n       break;\n \n+    case FFI_TYPE_COMPLEX:\n+      /* Not supported yet.  */\n+      abort();\n+\n     default:\n       break;\n     }"}, {"sha": "0dee9383a8d88778d36f2a594ba37ef04c9cd035", "filename": "libffi/src/m68k/ffi.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fm68k%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fm68k%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fm68k%2Fffi.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -123,6 +123,8 @@ ffi_prep_args (void *stack, extended_cif *ecif)\n #define CIF_FLAGS_POINTER\t32\n #define CIF_FLAGS_STRUCT1\t64\n #define CIF_FLAGS_STRUCT2\t128\n+#define CIF_FLAGS_SINT8\t\t256\n+#define CIF_FLAGS_SINT16\t512\n \n /* Perform machine dependent cif processing */\n ffi_status\n@@ -200,6 +202,14 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n       cif->flags = CIF_FLAGS_DINT;\n       break;\n \n+    case FFI_TYPE_SINT16:\n+      cif->flags = CIF_FLAGS_SINT16;\n+      break;\n+\n+    case FFI_TYPE_SINT8:\n+      cif->flags = CIF_FLAGS_SINT8;\n+      break;\n+\n     default:\n       cif->flags = CIF_FLAGS_INT;\n       break;"}, {"sha": "ec2b14f3d9817daf396b5dcb4cd80fc5c48d51d4", "filename": "libffi/src/m68k/sysv.S", "status": "modified", "additions": 51, "deletions": 6, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fm68k%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fm68k%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fm68k%2Fsysv.S?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -2,9 +2,10 @@\n \t\n    sysv.S - Copyright (c) 2012 Alan Hourihane\n \t    Copyright (c) 1998, 2012 Andreas Schwab\n-\t    Copyright (c) 2008 Red Hat, Inc. \n-   \n-   m68k Foreign Function Interface \n+\t    Copyright (c) 2008 Red Hat, Inc.\n+\t    Copyright (c) 2012 Thorsten Glaser\n+\n+   m68k Foreign Function Interface\n \n    Permission is hereby granted, free of charge, to any person obtaining\n    a copy of this software and associated documentation files (the\n@@ -168,8 +169,28 @@ retstruct1:\n \n retstruct2:\n \tbtst\t#7,%d2\n-\tjbeq\tnoretval\n+\tjbeq\tretsint8\n \tmove.w\t%d0,(%a1)\n+\tjbra\tepilogue\n+\n+retsint8:\n+\tbtst\t#8,%d2\n+\tjbeq\tretsint16\n+\t| NOTE: On the mc68000, extb is not supported. 8->16, then 16->32.\n+#if !defined(__mc68020__) && !defined(__mc68030__) && !defined(__mc68040__) && !defined(__mc68060__) && !defined(__mcoldfire__)\n+\text.w\t%d0\n+\text.l\t%d0\n+#else\n+\textb.l\t%d0\n+#endif\n+\tmove.l\t%d0,(%a1)\n+\tjbra\tepilogue\n+\n+retsint16:\n+\tbtst\t#9,%d2\n+\tjbeq\tnoretval\n+\text.l\t%d0\n+\tmove.l\t%d0,(%a1)\n \n noretval:\n epilogue:\n@@ -201,15 +222,18 @@ CALLFUNC(ffi_closure_SYSV):\n \tlsr.l\t#1,%d0\n \tjne\t1f\n \tjcc\t.Lcls_epilogue\n+\t| CIF_FLAGS_INT\n \tmove.l\t-12(%fp),%d0\n .Lcls_epilogue:\n+\t| no CIF_FLAGS_*\n \tunlk\t%fp\n \trts\n 1:\n \tlea\t-12(%fp),%a0\n \tlsr.l\t#2,%d0\n \tjne\t1f\n \tjcs\t.Lcls_ret_float\n+\t| CIF_FLAGS_DINT\n \tmove.l\t(%a0)+,%d0\n \tmove.l\t(%a0),%d1\n \tjra\t.Lcls_epilogue\n@@ -224,6 +248,7 @@ CALLFUNC(ffi_closure_SYSV):\n \tlsr.l\t#2,%d0\n \tjne\t1f\n \tjcs\t.Lcls_ret_ldouble\n+\t| CIF_FLAGS_DOUBLE\n #if defined(__MC68881__) || defined(__HAVE_68881__)\n \tfmove.d\t(%a0),%fp0\n #else\n@@ -242,17 +267,37 @@ CALLFUNC(ffi_closure_SYSV):\n \tjra\t.Lcls_epilogue\n 1:\n \tlsr.l\t#2,%d0\n-\tjne\t.Lcls_ret_struct2\n+\tjne\t1f\n \tjcs\t.Lcls_ret_struct1\n+\t| CIF_FLAGS_POINTER\n \tmove.l\t(%a0),%a0\n \tmove.l\t%a0,%d0\n \tjra\t.Lcls_epilogue\n .Lcls_ret_struct1:\n \tmove.b\t(%a0),%d0\n \tjra\t.Lcls_epilogue\n-.Lcls_ret_struct2:\n+1:\n+\tlsr.l\t#2,%d0\n+\tjne\t1f\n+\tjcs\t.Lcls_ret_sint8\n+\t| CIF_FLAGS_STRUCT2\n \tmove.w\t(%a0),%d0\n \tjra\t.Lcls_epilogue\n+.Lcls_ret_sint8:\n+\tmove.l\t(%a0),%d0\n+\t| NOTE: On the mc68000, extb is not supported. 8->16, then 16->32.\n+#if !defined(__mc68020__) && !defined(__mc68030__) && !defined(__mc68040__) && !defined(__mc68060__) && !defined(__mcoldfire__)\n+\text.w\t%d0\n+\text.l\t%d0\n+#else\n+\textb.l\t%d0\n+#endif\n+\tjra\t.Lcls_epilogue\n+1:\n+\t| CIF_FLAGS_SINT16\n+\tmove.l\t(%a0),%d0\n+\text.l\t%d0\n+\tjra\t.Lcls_epilogue\n \tCFI_ENDPROC()\n \n \t.size\tCALLFUNC(ffi_closure_SYSV),.-CALLFUNC(ffi_closure_SYSV)"}, {"sha": "68df494955e49f3b2c6c2e60e311c4bca495226e", "filename": "libffi/src/m88k/ffi.c", "status": "added", "additions": 400, "deletions": 0, "changes": 400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fm88k%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fm88k%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fm88k%2Fffi.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -0,0 +1,400 @@\n+/*\n+ * Copyright (c) 2013 Miodrag Vallat.  <miod@openbsd.org>\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining\n+ * a copy of this software and associated documentation files (the\n+ * ``Software''), to deal in the Software without restriction, including\n+ * without limitation the rights to use, copy, modify, merge, publish,\n+ * distribute, sublicense, and/or sell copies of the Software, and to\n+ * permit persons to whom the Software is furnished to do so, subject to\n+ * the following conditions:\n+ * \n+ * The above copyright notice and this permission notice shall be included\n+ * in all copies or substantial portions of the Software.\n+ * \n+ * THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n+ */\n+\n+/*\n+ * m88k Foreign Function Interface\n+ *\n+ * This file attempts to provide all the FFI entry points which can reliably\n+ * be implemented in C.\n+ *\n+ * Only OpenBSD/m88k is currently supported; other platforms (such as\n+ * Motorola's SysV/m88k) could be supported with the following tweaks:\n+ *\n+ * - non-OpenBSD systems use an `outgoing parameter area' as part of the\n+ *   88BCS calling convention, which is not supported under OpenBSD from\n+ *   release 3.6 onwards.  Supporting it should be as easy as taking it\n+ *   into account when adjusting the stack, in the assembly code.\n+ *\n+ * - the logic deciding whether a function argument gets passed through\n+ *   registers, or on the stack, has changed several times in OpenBSD in\n+ *   edge cases (especially for structs larger than 32 bytes being passed\n+ *   by value). The code below attemps to match the logic used by the\n+ *   system compiler of OpenBSD 5.3, i.e. gcc 3.3.6 with many m88k backend\n+ *   fixes.\n+ */\n+\n+#include <ffi.h>\n+#include <ffi_common.h>\n+\n+#include <stdlib.h>\n+#include <unistd.h>\n+\n+void ffi_call_OBSD (unsigned int, extended_cif *, unsigned int, void *,\n+\t\t    void (*fn) ());\n+void *ffi_prep_args (void *, extended_cif *);\n+void ffi_closure_OBSD (ffi_closure *);\n+void ffi_closure_struct_OBSD (ffi_closure *);\n+unsigned int ffi_closure_OBSD_inner (ffi_closure *, void *, unsigned int *,\n+\t\t\t\t     char *);\n+void ffi_cacheflush_OBSD (unsigned int, unsigned int);\n+\n+#define CIF_FLAGS_INT\t\t(1 << 0)\n+#define CIF_FLAGS_DINT\t\t(1 << 1)\n+\n+/*\n+ * Foreign Function Interface API\n+ */\n+\n+/* ffi_prep_args is called by the assembly routine once stack space has\n+   been allocated for the function's arguments.  */\n+\n+void *\n+ffi_prep_args (void *stack, extended_cif *ecif)\n+{\n+  unsigned int i;\n+  void **p_argv;\n+  char *argp, *stackp;\n+  unsigned int *regp;\n+  unsigned int regused;\n+  ffi_type **p_arg;\n+  void *struct_value_ptr;\n+\n+  regp = (unsigned int *)stack;\n+  stackp = (char *)(regp + 8);\n+  regused = 0;\n+\n+  if (ecif->cif->rtype->type == FFI_TYPE_STRUCT\n+      && !ecif->cif->flags)\n+    struct_value_ptr = ecif->rvalue;\n+  else\n+    struct_value_ptr = NULL;\n+\n+  p_argv = ecif->avalue;\n+\n+  for (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types; i != 0; i--, p_arg++)\n+    {\n+      size_t z;\n+      unsigned short t, a;\n+\n+      z = (*p_arg)->size;\n+      t = (*p_arg)->type;\n+      a = (*p_arg)->alignment;\n+\n+      /*\n+       * Figure out whether the argument can be passed through registers\n+       * or on the stack.\n+       * The rule is that registers can only receive simple types not larger\n+       * than 64 bits, or structs the exact size of a register and aligned to\n+       * the size of a register.\n+       */\n+      if (t == FFI_TYPE_STRUCT)\n+\t{\n+\t  if (z == sizeof (int) && a == sizeof (int) && regused < 8)\n+\t    argp = (char *)regp;\n+\t  else\n+\t    argp = stackp;\n+\t}\n+      else\n+\t{\n+\t  if (z > sizeof (int) && regused < 8 - 1)\n+\t    {\n+\t      /* align to an even register pair */\n+\t      if (regused & 1)\n+\t\t{\n+\t\t  regp++;\n+\t\t  regused++;\n+\t\t}\n+\t    }\n+\t  if (regused < 8)\n+\t    argp = (char *)regp;\n+\t  else\n+\t    argp = stackp;\n+\t}\n+\n+      /* Enforce proper stack alignment of 64-bit types */\n+      if (argp == stackp && a > sizeof (int))\n+\t{\n+\t  stackp = (char *) ALIGN(stackp, a);\n+\t  argp = stackp;\n+\t}\n+\n+      switch (t)\n+\t{\n+\tcase FFI_TYPE_SINT8:\n+\t  *(signed int *) argp = (signed int) *(SINT8 *) *p_argv;\n+\t  break;\n+\n+\tcase FFI_TYPE_UINT8:\n+\t  *(unsigned int *) argp = (unsigned int) *(UINT8 *) *p_argv;\n+\t  break;\n+\n+\tcase FFI_TYPE_SINT16:\n+\t  *(signed int *) argp = (signed int) *(SINT16 *) *p_argv;\n+\t  break;\n+\n+\tcase FFI_TYPE_UINT16:\n+\t  *(unsigned int *) argp = (unsigned int) *(UINT16 *) *p_argv;\n+\t  break;\n+\n+\tcase FFI_TYPE_INT:\n+\tcase FFI_TYPE_FLOAT:\n+\tcase FFI_TYPE_UINT32:\n+\tcase FFI_TYPE_SINT32:\n+\tcase FFI_TYPE_POINTER:\n+\t  *(unsigned int *) argp = *(unsigned int *) *p_argv;\n+\t  break;\n+\n+\tcase FFI_TYPE_DOUBLE:\n+\tcase FFI_TYPE_UINT64:\n+\tcase FFI_TYPE_SINT64:\n+\tcase FFI_TYPE_STRUCT:\n+\t  memcpy (argp, *p_argv, z);\n+\t  break;\n+\n+\tdefault:\n+\t  FFI_ASSERT (0);\n+\t}\n+\n+      /* Align if necessary.  */\n+      if ((sizeof (int) - 1) & z)\n+\tz = ALIGN(z, sizeof (int));\n+\n+      p_argv++;\n+\n+      /* Be careful, once all registers are filled, and about to continue\n+         on stack, regp == stackp.  Therefore the check for regused as well. */\n+      if (argp == (char *)regp && regused < 8)\n+\t{\n+\t  regp += z / sizeof (int);\n+\t  regused += z / sizeof (int);\n+\t}\n+      else\n+\tstackp += z;\n+    }\n+\n+  return struct_value_ptr;\n+}\n+\n+/* Perform machine dependent cif processing */\n+ffi_status\n+ffi_prep_cif_machdep (ffi_cif *cif)\n+{\n+  /* Set the return type flag */\n+  switch (cif->rtype->type)\n+    {\n+    case FFI_TYPE_VOID:\n+      cif->flags = 0;\n+      break;\n+\n+    case FFI_TYPE_STRUCT:\n+      if (cif->rtype->size == sizeof (int) &&\n+\t  cif->rtype->alignment == sizeof (int))\n+\tcif->flags = CIF_FLAGS_INT;\n+      else\n+\tcif->flags = 0;\n+      break;\n+\n+    case FFI_TYPE_DOUBLE:\n+    case FFI_TYPE_SINT64:\n+    case FFI_TYPE_UINT64:\n+      cif->flags = CIF_FLAGS_DINT;\n+      break;\n+\n+    default:\n+      cif->flags = CIF_FLAGS_INT;\n+      break;\n+    }\n+\n+  return FFI_OK;\n+}\n+\n+void\n+ffi_call (ffi_cif *cif, void (*fn) (), void *rvalue, void **avalue)\n+{\n+  extended_cif ecif;\n+\n+  ecif.cif = cif;\n+  ecif.avalue = avalue;\n+\n+  /* If the return value is a struct and we don't have a return value\n+     address then we need to make one.  */\n+\n+  if (rvalue == NULL\n+      && cif->rtype->type == FFI_TYPE_STRUCT\n+      && (cif->rtype->size != sizeof (int)\n+\t  || cif->rtype->alignment != sizeof (int)))\n+    ecif.rvalue = alloca (cif->rtype->size);\n+  else\n+    ecif.rvalue = rvalue;\n+\n+  switch (cif->abi)\n+    {\n+    case FFI_OBSD:\n+      ffi_call_OBSD (cif->bytes, &ecif, cif->flags, ecif.rvalue, fn);\n+      break;\n+\n+    default:\n+      FFI_ASSERT (0);\n+      break;\n+    }\n+}\n+\n+/*\n+ * Closure API\n+ */\n+\n+static void\n+ffi_prep_closure_args_OBSD (ffi_cif *cif, void **avalue, unsigned int *regp,\n+\t\t\t    char *stackp)\n+{\n+  unsigned int i;\n+  void **p_argv;\n+  char *argp;\n+  unsigned int regused;\n+  ffi_type **p_arg;\n+\n+  regused = 0;\n+\n+  p_argv = avalue;\n+\n+  for (i = cif->nargs, p_arg = cif->arg_types; i != 0; i--, p_arg++)\n+    {\n+      size_t z;\n+      unsigned short t, a;\n+\n+      z = (*p_arg)->size;\n+      t = (*p_arg)->type;\n+      a = (*p_arg)->alignment;\n+\n+      /*\n+       * Figure out whether the argument has been passed through registers\n+       * or on the stack.\n+       * The rule is that registers can only receive simple types not larger\n+       * than 64 bits, or structs the exact size of a register and aligned to\n+       * the size of a register.\n+       */\n+      if (t == FFI_TYPE_STRUCT)\n+\t{\n+\t  if (z == sizeof (int) && a == sizeof (int) && regused < 8)\n+\t    argp = (char *)regp;\n+\t  else\n+\t    argp = stackp;\n+\t}\n+      else\n+\t{\n+\t  if (z > sizeof (int) && regused < 8 - 1)\n+\t    {\n+\t      /* align to an even register pair */\n+\t      if (regused & 1)\n+\t\t{\n+\t\t  regp++;\n+\t\t  regused++;\n+\t\t}\n+\t    }\n+\t  if (regused < 8)\n+\t    argp = (char *)regp;\n+\t  else\n+\t    argp = stackp;\n+\t}\n+\n+      /* Enforce proper stack alignment of 64-bit types */\n+      if (argp == stackp && a > sizeof (int))\n+\t{\n+\t  stackp = (char *) ALIGN(stackp, a);\n+\t  argp = stackp;\n+\t}\n+\n+      if (z < sizeof (int) && t != FFI_TYPE_STRUCT)\n+\t*p_argv = (void *) (argp + sizeof (int) - z);\n+      else\n+\t*p_argv = (void *) argp;\n+\n+      /* Align if necessary */\n+      if ((sizeof (int) - 1) & z)\n+\tz = ALIGN(z, sizeof (int));\n+\n+      p_argv++;\n+\n+      /* Be careful, once all registers are exhausted, and about to fetch from\n+\t stack, regp == stackp.  Therefore the check for regused as well. */\n+      if (argp == (char *)regp && regused < 8)\n+\t{\n+\t  regp += z / sizeof (int);\n+\t  regused += z / sizeof (int);\n+\t}\n+      else\n+\tstackp += z;\n+    }\n+}\n+\n+unsigned int\n+ffi_closure_OBSD_inner (ffi_closure *closure, void *resp, unsigned int *regp,\n+\t\t\tchar *stackp)\n+{\n+  ffi_cif *cif;\n+  void **arg_area;\n+\n+  cif = closure->cif;\n+  arg_area = (void**) alloca (cif->nargs * sizeof (void *));\n+\n+  ffi_prep_closure_args_OBSD(cif, arg_area, regp, stackp);\n+\n+  (closure->fun) (cif, resp, arg_area, closure->user_data);\n+\n+  return cif->flags;\n+}\n+\n+ffi_status\n+ffi_prep_closure_loc (ffi_closure* closure, ffi_cif* cif,\n+\t\t      void (*fun)(ffi_cif*,void*,void**,void*),\n+\t\t      void *user_data, void *codeloc)\n+{\n+  unsigned int *tramp = (unsigned int *) codeloc;\n+  void *fn;\n+\n+  FFI_ASSERT (cif->abi == FFI_OBSD);\n+\n+  if (cif->rtype->type == FFI_TYPE_STRUCT && !cif->flags)\n+    fn = &ffi_closure_struct_OBSD;\n+  else\n+    fn = &ffi_closure_OBSD;\n+\n+  /* or.u %r10, %r0, %hi16(fn) */\n+  tramp[0] = 0x5d400000 | (((unsigned int)fn) >> 16);\n+  /* or.u %r13, %r0, %hi16(closure) */\n+  tramp[1] = 0x5da00000 | ((unsigned int)closure >> 16);\n+  /* or %r10, %r10, %lo16(fn) */\n+  tramp[2] = 0x594a0000 | (((unsigned int)fn) & 0xffff);\n+  /* jmp.n %r10 */\n+  tramp[3] = 0xf400c40a;\n+  /* or %r13, %r13, %lo16(closure) */\n+  tramp[4] = 0x59ad0000 | ((unsigned int)closure & 0xffff);\n+\n+  ffi_cacheflush_OBSD((unsigned int)codeloc, FFI_TRAMPOLINE_SIZE);\n+\n+  closure->cif  = cif;\n+  closure->user_data = user_data;\n+  closure->fun  = fun;\n+\n+  return FFI_OK;\n+}"}, {"sha": "e52bf9fa30a487468013fce1f2005f63a194fe89", "filename": "libffi/src/m88k/ffitarget.h", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fm88k%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fm88k%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fm88k%2Fffitarget.h?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright (c) 2013 Miodrag Vallat.  <miod@openbsd.org>\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining\n+ * a copy of this software and associated documentation files (the\n+ * ``Software''), to deal in the Software without restriction, including\n+ * without limitation the rights to use, copy, modify, merge, publish,\n+ * distribute, sublicense, and/or sell copies of the Software, and to\n+ * permit persons to whom the Software is furnished to do so, subject to\n+ * the following conditions:\n+ * \n+ * The above copyright notice and this permission notice shall be included\n+ * in all copies or substantial portions of the Software.\n+ * \n+ * THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n+ */\n+\n+/*\n+ * m88k Foreign Function Interface\n+ */\n+\n+#ifndef LIBFFI_TARGET_H\n+#define LIBFFI_TARGET_H\n+\n+#ifndef LIBFFI_ASM\n+typedef unsigned long ffi_arg;\n+typedef signed long ffi_sarg;\n+\n+typedef enum ffi_abi {\n+  FFI_FIRST_ABI = 0,\n+  FFI_OBSD,\n+  FFI_DEFAULT_ABI = FFI_OBSD,\n+  FFI_LAST_ABI = FFI_DEFAULT_ABI + 1\n+} ffi_abi;\n+#endif\n+\n+/* ---- Definitions for closures ----------------------------------------- */\n+\n+#define FFI_CLOSURES 1\n+#define FFI_TRAMPOLINE_SIZE 0x14\n+#define FFI_NATIVE_RAW_API 0\n+\n+#endif"}, {"sha": "1944a23de424594a92cb39b4258357f6a4a1e789", "filename": "libffi/src/m88k/obsd.S", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fm88k%2Fobsd.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fm88k%2Fobsd.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fm88k%2Fobsd.S?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -0,0 +1,209 @@\n+/*\n+ * Copyright (c) 2013 Miodrag Vallat.  <miod@openbsd.org>\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining\n+ * a copy of this software and associated documentation files (the\n+ * ``Software''), to deal in the Software without restriction, including\n+ * without limitation the rights to use, copy, modify, merge, publish,\n+ * distribute, sublicense, and/or sell copies of the Software, and to\n+ * permit persons to whom the Software is furnished to do so, subject to\n+ * the following conditions:\n+ * \n+ * The above copyright notice and this permission notice shall be included\n+ * in all copies or substantial portions of the Software.\n+ * \n+ * THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n+ */\n+\n+/*\n+ * m88k Foreign Function Interface\n+ */\n+\n+#define LIBFFI_ASM\t\n+#include <fficonfig.h>\n+#include <ffi.h>\n+\n+\t.text\n+\n+/*\n+ * ffi_cacheflush_OBSD(unsigned int addr,\t%r2\n+ *\t\t       unsigned int size);\t%r3\n+ */\n+\t.align\t4\n+\t.globl\tffi_cacheflush_OBSD\n+\t.type\tffi_cacheflush_OBSD,@function\n+ffi_cacheflush_OBSD:\n+\ttb0\t0,   %r0, 451\n+\tor\t%r0, %r0, %r0\n+\tjmp\t%r1\n+\t.size\tffi_cacheflush_OBSD, . - ffi_cacheflush_OBSD\n+\n+/*\n+ * ffi_call_OBSD(unsigned bytes,\t\t%r2\n+ *\t\t extended_cif *ecif,\t\t%r3\n+ *\t\t unsigned flags,\t\t%r4\n+ *\t\t void *rvalue,\t\t\t%r5\n+ *\t\t void (*fn)());\t\t\t%r6\n+ */\n+\t.align\t4\n+\t.globl\tffi_call_OBSD\n+\t.type\tffi_call_OBSD,@function\n+ffi_call_OBSD:\n+\tsubu\t%r31, %r31, 32\n+\tst\t%r30, %r31, 4\n+\tst\t%r1,  %r31, 0\n+\taddu\t%r30, %r31, 32\n+\n+\t| Save the few arguments we'll need after ffi_prep_args()\n+\tst.d\t%r4, %r31, 8\n+\tst\t%r6, %r31, 16\n+\n+\t| Allocate room for the image of r2-r9, and the stack space for\n+\t| the args (rounded to a 16-byte boundary)\n+\taddu\t%r2,  %r2,  (8 * 4) + 15\n+\tclr\t%r2,  %r2,  4<0>\n+\tsubu\t%r31, %r31, %r2\n+\n+\t| Fill register and stack image\n+\tor\t%r2, %r31, %r0\n+#ifdef PIC\n+\tbsr\tffi_prep_args#plt\n+#else\n+\tbsr\tffi_prep_args\n+#endif\n+\n+\t| Save pointer to return struct address, if any\n+\tor\t%r12, %r2, %r0\n+\n+\t| Get function pointer\n+\tsubu\t%r4,  %r30, 32\n+\tld\t%r1,  %r4,  16\n+\n+\t| Fetch the register arguments\n+\tld.d\t%r2, %r31, (0 * 4)\n+\tld.d\t%r4, %r31, (2 * 4)\n+\tld.d\t%r6, %r31, (4 * 4)\n+\tld.d\t%r8, %r31, (6 * 4)\n+\taddu\t%r31, %r31, (8 * 4)\n+\n+\t| Invoke the function\n+\tjsr\t%r1\n+\n+\t| Restore stack now that we don't need the args anymore\n+\tsubu\t%r31, %r30, 32\n+\n+\t| Figure out what to return as the function's return value\n+\tld\t%r5, %r31, 12\t\t| rvalue\n+\tld\t%r4, %r31, 8\t\t| flags\n+\n+\tbcnd\teq0, %r5, 9f\n+\n+\tbb0\t0, %r4, 1f\t\t| CIF_FLAGS_INT\n+\tst\t%r2, %r5, 0\n+\tbr\t9f\n+\n+1:\n+\tbb0\t1, %r4, 1f\t\t| CIF_FLAGS_DINT\n+\tst.d\t%r2, %r5, 0\n+\tbr\t9f\n+\n+1:\n+9:\n+\tld\t%r1,  %r31, 0\n+\tld\t%r30, %r31, 4\n+\tjmp.n\t%r1\n+\t addu\t%r31, %r31, 32\n+\t.size\tffi_call_OBSD, . - ffi_call_OBSD\n+\n+/*\n+ * ffi_closure_OBSD(ffi_closure *closure);\t%r13\n+ */\n+\t.align\t4\n+\t.globl\tffi_closure_OBSD\n+\t.type\tffi_closure_OBSD, @function\n+ffi_closure_OBSD:\n+\tsubu\t%r31, %r31, 16\n+\tst\t%r30, %r31, 4\n+\tst\t%r1,  %r31, 0\n+\taddu\t%r30, %r31, 16\n+\n+\t| Make room on the stack for saved register arguments and return\n+\t| value\n+\tsubu\t%r31, %r31, (8 * 4) + (2 * 4)\n+\tst.d\t%r2,  %r31, (0 * 4)\n+\tst.d\t%r4,  %r31, (2 * 4)\n+\tst.d\t%r6,  %r31, (4 * 4)\n+\tst.d\t%r8,  %r31, (6 * 4)\n+\n+\t| Invoke the closure function\n+\tor\t%r5,  %r30, 0\t\t\t| calling stack\n+\taddu\t%r4,  %r31, 0\t\t\t| saved registers\n+\taddu\t%r3,  %r31, (8 * 4)\t\t| return value\n+\tor\t%r2,  %r13, %r0\t\t\t| closure\n+#ifdef PIC\n+\tbsr\tffi_closure_OBSD_inner#plt\n+#else\n+\tbsr\tffi_closure_OBSD_inner\n+#endif\n+\n+\t| Figure out what to return as the function's return value\n+\tbb0\t0, %r2, 1f\t\t| CIF_FLAGS_INT\n+\tld\t%r2, %r31, (8 * 4)\n+\tbr\t9f\n+\n+1:\n+\tbb0\t1, %r2, 1f\t\t| CIF_FLAGS_DINT\n+\tld.d\t%r2, %r31, (8 * 4)\n+\tbr\t9f\n+\n+1:\n+9:\n+\tsubu\t%r31, %r30, 16\n+\tld\t%r1,  %r31, 0\n+\tld\t%r30, %r31, 4\n+\tjmp.n\t%r1\n+\t addu\t%r31, %r31, 16\n+\t.size\tffi_closure_OBSD,.-ffi_closure_OBSD\n+\n+/*\n+ * ffi_closure_struct_OBSD(ffi_closure *closure);\t%r13\n+ */\n+\t.align\t4\n+\t.globl\tffi_closure_struct_OBSD\n+\t.type\tffi_closure_struct_OBSD, @function\n+ffi_closure_struct_OBSD:\n+\tsubu\t%r31, %r31, 16\n+\tst\t%r30, %r31, 4\n+\tst\t%r1,  %r31, 0\n+\taddu\t%r30, %r31, 16\n+\n+\t| Make room on the stack for saved register arguments\n+\tsubu\t%r31, %r31, (8 * 4)\n+\tst.d\t%r2,  %r31, (0 * 4)\n+\tst.d\t%r4,  %r31, (2 * 4)\n+\tst.d\t%r6,  %r31, (4 * 4)\n+\tst.d\t%r8,  %r31, (6 * 4)\n+\n+\t| Invoke the closure function\n+\tor\t%r5,  %r30, 0\t\t\t| calling stack\n+\taddu\t%r4,  %r31, 0\t\t\t| saved registers\n+\tor\t%r3,  %r12, 0\t\t\t| return value\n+\tor\t%r2,  %r13, %r0\t\t\t| closure\n+#ifdef PIC\n+\tbsr\tffi_closure_OBSD_inner#plt\n+#else\n+\tbsr\tffi_closure_OBSD_inner\n+#endif\n+\n+\tsubu\t%r31, %r30, 16\n+\tld\t%r1,  %r31, 0\n+\tld\t%r30, %r31, 4\n+\tjmp.n\t%r1\n+\t addu\t%r31, %r31, 16\n+\t.size\tffi_closure_struct_OBSD,.-ffi_closure_struct_OBSD"}, {"sha": "46b383e7a3c4486d466916abeccf4b3ba30be148", "filename": "libffi/src/metag/ffi.c", "status": "added", "additions": 330, "deletions": 0, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fmetag%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fmetag%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmetag%2Fffi.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -0,0 +1,330 @@\n+/* ----------------------------------------------------------------------\n+  ffi.c - Copyright (c) 2013 Imagination Technologies\n+\n+  Meta Foreign Function Interface\n+  Permission is hereby granted, free of charge, to any person obtaining\n+  a copy of this software and associated documentation files (the\n+  `Software''), to deal in the Software without restriction, including\n+  without limitation the rights to use, copy, modify, merge, publish,\n+  distribute, sublicense, and/or sell copies of the Software, and to\n+  permit persons to whom the Software is furnished to do so, subject to\n+  the following conditions:\n+\n+  The above copyright notice and this permission notice shall be included\n+  in all copies or substantial portions of the Software.\n+\n+  THE SOFTWARE IS PROVIDED `AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+  IN NO EVENT SHALL SIMON POSNJAK BE LIABLE FOR ANY CLAIM, DAMAGES OR\n+  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n+  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+  OTHER DEALINGS IN THE SOFTWARE.\n+----------------------------------------------------------------------- */\n+\n+#include <ffi.h>\n+#include <ffi_common.h>\n+\n+#include <stdlib.h>\n+\n+#define MIN(a,b) (((a) < (b)) ? (a) : (b))\n+\n+/*\n+ * ffi_prep_args is called by the assembly routine once stack space has been\n+ * allocated for the function's arguments\n+ */\n+\n+unsigned int ffi_prep_args(char *stack, extended_cif *ecif)\n+{\n+\tregister unsigned int i;\n+\tregister void **p_argv;\n+\tregister char *argp;\n+\tregister ffi_type **p_arg;\n+\n+\targp = stack;\n+\n+\t/* Store return value */\n+\tif ( ecif->cif->flags == FFI_TYPE_STRUCT ) {\n+\t\targp -= 4;\n+\t\t*(void **) argp = ecif->rvalue;\n+\t}\n+\n+\tp_argv = ecif->avalue;\n+\n+\t/* point to next location */\n+\tfor (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types; (i != 0); i--, p_arg++, p_argv++)\n+\t{\n+\t\tsize_t z;\n+\n+\t\t/* Move argp to address of argument */\n+\t\tz = (*p_arg)->size;\n+\t\targp -= z;\n+\n+\t\t/* Align if necessary */\n+\t\targp = (char *) ALIGN_DOWN(ALIGN_DOWN(argp, (*p_arg)->alignment), 4);\n+\n+\t\tif (z < sizeof(int)) {\n+\t\t\tz = sizeof(int);\n+\t\t\tswitch ((*p_arg)->type)\n+\t\t\t{\n+\t\t\tcase FFI_TYPE_SINT8:\n+\t\t\t\t*(signed int *) argp = (signed int)*(SINT8 *)(* p_argv);\n+\t\t\t\tbreak;\n+\t\t\tcase FFI_TYPE_UINT8:\n+\t\t\t\t*(unsigned int *) argp = (unsigned int)*(UINT8 *)(* p_argv);\n+\t\t\t\tbreak;\n+\t\t\tcase FFI_TYPE_SINT16:\n+\t\t\t\t*(signed int *) argp = (signed int)*(SINT16 *)(* p_argv);\n+\t\t\t\tbreak;\n+\t\t\tcase FFI_TYPE_UINT16:\n+\t\t\t\t*(unsigned int *) argp = (unsigned int)*(UINT16 *)(* p_argv);\n+\t\t\tcase FFI_TYPE_STRUCT:\n+\t\t\t\tmemcpy(argp, *p_argv, (*p_arg)->size);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tFFI_ASSERT(0);\n+\t\t\t}\n+\t\t} else if ( z == sizeof(int)) {\n+\t\t\t*(unsigned int *) argp = (unsigned int)*(UINT32 *)(* p_argv);\n+\t\t} else {\n+\t\t\tmemcpy(argp, *p_argv, z);\n+\t\t}\n+\t}\n+\n+\t/* return the size of the arguments to be passed in registers,\n+\t   padded to an 8 byte boundary to preserve stack alignment */\n+\treturn ALIGN(MIN(stack - argp, 6*4), 8);\n+}\n+\n+/* Perform machine dependent cif processing */\n+ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n+{\n+\tffi_type **ptr;\n+\tunsigned i, bytes = 0;\n+\n+\tfor (ptr = cif->arg_types, i = cif->nargs; i > 0; i--, ptr++) {\n+\t\tif ((*ptr)->size == 0)\n+\t\t\treturn FFI_BAD_TYPEDEF;\n+\n+\t\t/* Perform a sanity check on the argument type, do this\n+\t\t   check after the initialization.  */\n+\t\tFFI_ASSERT_VALID_TYPE(*ptr);\n+\n+\t\t/* Add any padding if necessary */\n+\t\tif (((*ptr)->alignment - 1) & bytes)\n+\t\t\tbytes = ALIGN(bytes, (*ptr)->alignment);\n+\n+\t\tbytes += ALIGN((*ptr)->size, 4);\n+\t}\n+\n+\t/* Ensure arg space is aligned to an 8-byte boundary */\n+\tbytes = ALIGN(bytes, 8);\n+\n+\t/* Make space for the return structure pointer */\n+\tif (cif->rtype->type == FFI_TYPE_STRUCT) {\n+\t\tbytes += sizeof(void*);\n+\n+\t\t/* Ensure stack is aligned to an 8-byte boundary */\n+\t\tbytes = ALIGN(bytes, 8);\n+\t}\n+\n+\tcif->bytes = bytes;\n+\n+\t/* Set the return type flag */\n+\tswitch (cif->rtype->type) {\n+\tcase FFI_TYPE_VOID:\n+\tcase FFI_TYPE_FLOAT:\n+\tcase FFI_TYPE_DOUBLE:\n+\t\tcif->flags = (unsigned) cif->rtype->type;\n+\t\tbreak;\n+\tcase FFI_TYPE_SINT64:\n+\tcase FFI_TYPE_UINT64:\n+\t\tcif->flags = (unsigned) FFI_TYPE_SINT64;\n+\t\tbreak;\n+\tcase FFI_TYPE_STRUCT:\n+\t\t/* Meta can store return values which are <= 64 bits */\n+\t\tif (cif->rtype->size <= 4)\n+\t\t\t/* Returned to D0Re0 as 32-bit value */\n+\t\t\tcif->flags = (unsigned)FFI_TYPE_INT;\n+\t\telse if ((cif->rtype->size > 4) && (cif->rtype->size <= 8))\n+\t\t\t/* Returned valued is stored to D1Re0|R0Re0 */\n+\t\t\tcif->flags = (unsigned)FFI_TYPE_DOUBLE;\n+\t\telse\n+\t\t\t/* value stored in memory */\n+\t\t\tcif->flags = (unsigned)FFI_TYPE_STRUCT;\n+\t\tbreak;\n+\tdefault:\n+\t\tcif->flags = (unsigned)FFI_TYPE_INT;\n+\t\tbreak;\n+\t}\n+\treturn FFI_OK;\n+}\n+\n+extern void ffi_call_SYSV(void (*fn)(void), extended_cif *, unsigned, unsigned, double *);\n+\n+/*\n+ * Exported in API. Entry point\n+ * cif -> ffi_cif object\n+ * fn -> function pointer\n+ * rvalue -> pointer to return value\n+ * avalue -> vector of void * pointers pointing to memory locations holding the\n+ * arguments\n+ */\n+void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n+{\n+\textended_cif ecif;\n+\n+\tint small_struct = (((cif->flags == FFI_TYPE_INT) || (cif->flags == FFI_TYPE_DOUBLE)) && (cif->rtype->type == FFI_TYPE_STRUCT));\n+\tecif.cif = cif;\n+\tecif.avalue = avalue;\n+\n+\tdouble temp;\n+\n+\t/*\n+\t * If the return value is a struct and we don't have a return value address\n+\t * then we need to make one\n+\t */\n+\n+\tif ((rvalue == NULL ) && (cif->flags == FFI_TYPE_STRUCT))\n+\t\tecif.rvalue = alloca(cif->rtype->size);\n+\telse if (small_struct)\n+\t\tecif.rvalue = &temp;\n+\telse\n+\t\tecif.rvalue = rvalue;\n+\n+\tswitch (cif->abi) {\n+\tcase FFI_SYSV:\n+\t\tffi_call_SYSV(fn, &ecif, cif->bytes, cif->flags, ecif.rvalue);\n+\t\tbreak;\n+\tdefault:\n+\t\tFFI_ASSERT(0);\n+\t\tbreak;\n+\t}\n+\n+\tif (small_struct)\n+\t\tmemcpy (rvalue, &temp, cif->rtype->size);\n+}\n+\n+/* private members */\n+\n+static void ffi_prep_incoming_args_SYSV (char *, void **, void **,\n+\tffi_cif*, float *);\n+\n+void ffi_closure_SYSV (ffi_closure *);\n+\n+/* Do NOT change that without changing the FFI_TRAMPOLINE_SIZE */\n+extern unsigned int ffi_metag_trampoline[10]; /* 10 instructions */\n+\n+/* end of private members */\n+\n+/*\n+ * __tramp: trampoline memory location\n+ * __fun: assembly routine\n+ * __ctx: memory location for wrapper\n+ *\n+ * At this point, tramp[0] == __ctx !\n+ */\n+void ffi_init_trampoline(unsigned char *__tramp, unsigned int __fun, unsigned int __ctx) {\n+\tmemcpy (__tramp, ffi_metag_trampoline, sizeof(ffi_metag_trampoline));\n+\t*(unsigned int*) &__tramp[40] = __ctx;\n+\t*(unsigned int*) &__tramp[44] = __fun;\n+\t/* This will flush the instruction cache */\n+\t__builtin_meta2_cachewd(&__tramp[0], 1);\n+\t__builtin_meta2_cachewd(&__tramp[47], 1);\n+}\n+\n+\n+\n+/* the cif must already be prepared */\n+\n+ffi_status\n+ffi_prep_closure_loc (ffi_closure *closure,\n+\tffi_cif* cif,\n+\tvoid (*fun)(ffi_cif*,void*,void**,void*),\n+\tvoid *user_data,\n+\tvoid *codeloc)\n+{\n+\tvoid (*closure_func)(ffi_closure*) = NULL;\n+\n+\tif (cif->abi == FFI_SYSV)\n+\t\tclosure_func = &ffi_closure_SYSV;\n+\telse\n+\t\treturn FFI_BAD_ABI;\n+\n+\tffi_init_trampoline(\n+\t\t(unsigned char*)&closure->tramp[0],\n+\t\t(unsigned int)closure_func,\n+\t\t(unsigned int)codeloc);\n+\n+\tclosure->cif = cif;\n+\tclosure->user_data = user_data;\n+\tclosure->fun = fun;\n+\n+\treturn FFI_OK;\n+}\n+\n+\n+/* This function is jumped to by the trampoline */\n+unsigned int ffi_closure_SYSV_inner (closure, respp, args, vfp_args)\n+\tffi_closure *closure;\n+\tvoid **respp;\n+\tvoid *args;\n+\tvoid *vfp_args;\n+{\n+\tffi_cif *cif;\n+\tvoid **arg_area;\n+\n+\tcif = closure->cif;\n+\targ_area = (void**) alloca (cif->nargs * sizeof (void*));\n+\n+\t/*\n+\t * This call will initialize ARG_AREA, such that each\n+\t * element in that array points to the corresponding\n+\t * value on the stack; and if the function returns\n+\t * a structure, it will re-set RESP to point to the\n+\t * structure return address.\n+\t */\n+\tffi_prep_incoming_args_SYSV(args, respp, arg_area, cif, vfp_args);\n+\n+\t(closure->fun) ( cif, *respp, arg_area, closure->user_data);\n+\n+\treturn cif->flags;\n+}\n+\n+static void ffi_prep_incoming_args_SYSV(char *stack, void **rvalue,\n+\tvoid **avalue, ffi_cif *cif,\n+\tfloat *vfp_stack)\n+{\n+\tregister unsigned int i;\n+\tregister void **p_argv;\n+\tregister char *argp;\n+\tregister ffi_type **p_arg;\n+\n+\t/* stack points to original arguments */\n+\targp = stack;\n+\n+\t/* Store return value */\n+\tif ( cif->flags == FFI_TYPE_STRUCT ) {\n+\t\targp -= 4;\n+\t\t*rvalue = *(void **) argp;\n+\t}\n+\n+\tp_argv = avalue;\n+\n+\tfor (i = cif->nargs, p_arg = cif->arg_types; (i != 0); i--, p_arg++) {\n+\t\tsize_t z;\n+\t\tsize_t alignment;\n+\n+\t\talignment = (*p_arg)->alignment;\n+\t\tif (alignment < 4)\n+\t\t\talignment = 4;\n+\t\tif ((alignment - 1) & (unsigned)argp)\n+\t\t\targp = (char *) ALIGN(argp, alignment);\n+\n+\t\tz = (*p_arg)->size;\n+\t\t*p_argv = (void*) argp;\n+\t\tp_argv++;\n+\t\targp -= z;\n+\t}\n+\treturn;\n+}"}, {"sha": "7b9dbebca86919d20f0c7901343d5279b4a642ca", "filename": "libffi/src/metag/ffitarget.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fmetag%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fmetag%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmetag%2Fffitarget.h?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -0,0 +1,53 @@\n+/* -----------------------------------------------------------------*-C-*-\n+   ffitarget.h - Copyright (c) 2013 Imagination Technologies Ltd.\n+   Target configuration macros for Meta\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+\n+   ----------------------------------------------------------------------- */\n+\n+#ifndef LIBFFI_TARGET_H\n+#define LIBFFI_TARGET_H\n+\n+#ifndef LIBFFI_H\n+#error \"Please do not include ffitarget.h directly into your source.  Use ffi.h instead.\"\n+#endif\n+\n+#ifndef LIBFFI_ASM\n+typedef unsigned long          ffi_arg;\n+typedef signed long            ffi_sarg;\n+\n+typedef enum ffi_abi {\n+  FFI_FIRST_ABI = 0,\n+  FFI_SYSV,\n+  FFI_DEFAULT_ABI = FFI_SYSV,\n+  FFI_LAST_ABI = FFI_DEFAULT_ABI + 1,\n+} ffi_abi;\n+#endif\n+\n+/* ---- Definitions for closures ----------------------------------------- */\n+\n+#define FFI_CLOSURES 1\n+#define FFI_TRAMPOLINE_SIZE 48\n+#define FFI_NATIVE_RAW_API 0\n+\n+#endif\n+"}, {"sha": "b4b2a3b26bbfbdcdc9cf5ffb6c69d4388598feab", "filename": "libffi/src/metag/sysv.S", "status": "added", "additions": 311, "deletions": 0, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fmetag%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fmetag%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmetag%2Fsysv.S?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -0,0 +1,311 @@\n+/* -----------------------------------------------------------------------\n+   sysv.S - Copyright (c) 2013 Imagination Technologies Ltd.\n+\n+   Meta Foreign Function Interface\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#define LIBFFI_ASM\n+#include <fficonfig.h>\n+#include <ffi.h>\n+#ifdef HAVE_MACHINE_ASM_H\n+#include <machine/asm.h>\n+#else\n+#ifdef __USER_LABEL_PREFIX__\n+#define CONCAT1(a, b) CONCAT2(a, b)\n+#define CONCAT2(a, b) a ## b\n+\n+/* Use the right prefix for global labels. */\n+#define CNAME(x) CONCAT1 (__USER_LABEL_PREFIX__, x)\n+#else\n+#define CNAME(x) x\n+#endif\n+#define ENTRY(x) .globl CNAME(x); .type CNAME(x), %function; CNAME(x):\n+#endif\n+\n+#ifdef __ELF__\n+#define LSYM(x) .x\n+#else\n+#define LSYM(x) x\n+#endif\n+\n+.macro call_reg x=\n+\t.text\n+\t.balign 4\n+\tmov D1RtP, \\x\n+\tswap D1RtP, PC\n+.endm\n+\n+! Save register arguments\n+.macro SAVE_ARGS\n+\t.text\n+\t.balign 4\n+\tsetl\t[A0StP++], D0Ar6, D1Ar5\n+\tsetl\t[A0StP++], D0Ar4, D1Ar3\n+\tsetl\t[A0StP++], D0Ar2, D1Ar1\n+.endm\n+\n+! Save retrun, frame pointer and other regs\n+.macro SAVE_REGS regs=\n+\t.text\n+\t.balign 4\n+\tsetl\t[A0StP++], D0FrT, D1RtP\n+\t! Needs to be a pair of regs\n+\t.ifnc \"\\regs\",\"\"\n+\tsetl\t[A0StP++], \\regs\n+\t.endif\n+.endm\n+\n+! Declare a global function\n+.macro METAG_FUNC_START name\n+\t.text\n+\t.balign 4\n+\tENTRY(\\name)\n+.endm\n+\n+! Return registers from the stack. Reverse SAVE_REGS operation\n+.macro RET_REGS regs=, cond=\n+\t.ifnc \"\\regs\", \"\"\n+\tgetl\t\\regs, [--A0StP]\n+\t.endif\n+\tgetl\tD0FrT, D1RtP, [--A0StP]\n+.endm\n+\n+! Return arguments\n+.macro RET_ARGS\n+\tgetl\tD0Ar2, D1Ar1, [--A0StP]\n+\tgetl\tD0Ar4, D1Ar3, [--A0StP]\n+\tgetl\tD0Ar6, D1Ar5, [--A0StP]\n+.endm\n+\n+\n+\t! D1Ar1:\tfn\n+\t! D0Ar2:\t&ecif\n+\t! D1Ar3:\tcif->bytes\n+\t! D0Ar4:\tfig->flags\n+\t! D1Ar5:\tecif.rvalue\n+\n+\t! This assumes we are using GNU as\n+METAG_FUNC_START ffi_call_SYSV\n+\t! Save argument registers\n+\n+\tSAVE_ARGS\n+\n+\t! new frame\n+\tmov\tD0FrT, A0FrP\n+\tadd     A0FrP, A0StP, #0\n+\n+\t! Preserve the old frame pointer\n+\tSAVE_REGS \"D1.5, D0.5\"\n+\n+\t! Make room for new args. cifs->bytes is the total space for input\n+\t! and return arguments\n+\n+\tadd\tA0StP, A0StP, D1Ar3\n+\n+\t! Preserve cifs->bytes & fn\n+\tmov\tD0.5, D1Ar3\n+\tmov\tD1.5, D1Ar1\n+\n+\t! Place all of the ffi_prep_args in position\n+\tmov\tD1Ar1, A0StP\n+\n+\t! Call ffi_prep_args(stack, &ecif)\n+#ifdef __PIC__\n+\tcallr  D1RtP, CNAME(ffi_prep_args@PLT)\n+#else\n+\tcallr  D1RtP, CNAME(ffi_prep_args)\n+#endif\n+\n+\t! Restore fn pointer\n+\n+\t! The foreign stack should look like this\n+\t! XXXXX XXXXXX <--- stack pointer\n+\t! FnArgN rvalue\n+\t! FnArgN+2 FnArgN+1\n+\t! FnArgN+4 FnArgN+3\n+\t! ....\n+\t!\n+\n+\t! A0StP now points to the first (or return) argument + 4\n+\n+\t! Preserve cif->bytes\n+\tgetl\tD0Ar2, D1Ar1, [--A0StP]\n+\tgetl\tD0Ar4, D1Ar3, [--A0StP]\n+\tgetl\tD0Ar6, D1Ar5, [--A0StP]\n+\n+\t! Place A0StP to the first argument again\n+\tadd\tA0StP, A0StP, #24 ! That's because we loaded 6 regs x 4 byte each\n+\n+\t! A0FrP points to the initial stack without the reserved space for the\n+\t! cifs->bytes, whilst A0StP points to the stack after the space allocation\n+\n+\t! fn was the first argument of ffi_call_SYSV.\n+\t! The stack at this point looks like this:\n+\t!\n+\t! A0StP(on entry to _SYSV) ->\tArg6\tArg5     | low\n+\t!\t\t\t\tArg4\tArg3     |\n+\t! \t\t\t\tArg2\tArg1     |\n+\t! A0FrP ---->\t\t\tD0FrtP\tD1RtP    |\n+\t!\t\t\t\tD1.5\tD0.5\t |\n+\t! A0StP(bf prep_args) ->\tFnArgn\tFnArgn-1 |\n+\t!\t\t\t\tFnArgn-2FnArgn-3 |\n+\t!\t\t\t\t................ | <= cifs->bytes\n+\t!\t\t\t\tFnArg4  FnArg3\t |\n+\t! A0StP (prv_A0StP+cifs->bytes) FnArg2  FnArg1   | high\n+\t!\n+\t! fn was in Arg1 so it's located in in A0FrP+#-0xC\n+\t!\n+\n+\t! D0Re0 contains the size of arguments stored in registers\n+\tsub\tA0StP, A0StP, D0Re0\n+\n+\t! Arg1 is the function pointer for the foreign call. This has been\n+\t! preserved in D1.5\n+\n+\t! Time to call (fn). Arguments should be like this:\n+\t! Arg1-Arg6 are loaded to regs\n+\t! The rest of the arguments are stored in stack pointed by A0StP\n+\n+\tcall_reg D1.5\n+\n+\t! Reset stack.\n+\n+\tmov\tA0StP, A0FrP\n+\n+\t! Load Arg1 with the pointer to storage for the return type\n+\t! This was stored in Arg5\n+\n+\tgetd\tD1Ar1, [A0FrP+#-20]\n+\n+\t! Load D0Ar2 with the return type code. This was stored in Arg4 (flags)\n+\n+\tgetd\tD0Ar2, [A0FrP+#-16]\n+\n+\t! We are ready to start processing the return value\n+\t! D0Re0 (and D1Re0) hold the return value\n+\n+\t! If the return value is NULL, assume no return value\n+\tcmp\tD1Ar1, #0\n+\tbeq\tLSYM(Lepilogue)\n+\n+\t! return INT\n+\tcmp\t\tD0Ar2, #FFI_TYPE_INT\n+\t! Sadly, there is no setd{cc} instruction so we need to workaround that\n+\tbne\t.INT64\n+\tsetd\t[D1Ar1], D0Re0\n+\tb\tLSYM(Lepilogue)\n+\n+\t! return INT64\n+.INT64:\n+\tcmp\tD0Ar2, #FFI_TYPE_SINT64\n+\tsetleq\t[D1Ar1], D0Re0, D1Re0\n+\n+\t! return DOUBLE\n+\tcmp\tD0Ar2, #FFI_TYPE_DOUBLE\n+\tsetl\t[D1AR1++], D0Re0, D1Re0\n+\n+LSYM(Lepilogue):\n+\t! At this point, the stack pointer points right after the argument\n+\t! saved area. We need to restore 4 regs, therefore we need to move\n+\t! 16 bytes ahead.\n+\tadd     A0StP, A0StP, #16\n+\tRET_REGS \"D1.5, D0.5\"\n+\tRET_ARGS\n+\tgetd\tD0Re0, [A0StP]\n+\tmov     A0FrP, D0FrT\n+\tswap\tD1RtP, PC\n+\n+.ffi_call_SYSV_end:\n+       .size   CNAME(ffi_call_SYSV),.ffi_call_SYSV_end-CNAME(ffi_call_SYSV)\n+\n+\n+/*\n+\t(called by ffi_metag_trampoline)\n+\tvoid ffi_closure_SYSV (ffi_closure*)\n+\n+\t(called by ffi_closure_SYSV)\n+\tunsigned int FFI_HIDDEN\n+\tffi_closure_SYSV_inner (closure,respp, args)\n+\t\tffi_closure *closure;\n+\t\tvoid **respp;\n+\t\tvoid *args;\n+*/\n+\n+METAG_FUNC_START ffi_closure_SYSV\n+\t! We assume that D1Ar1 holds the address of the\n+\t! ffi_closure struct. We will use that to fetch the\n+\t! arguments. The stack pointer points to an empty space\n+\t! and it is ready to store more data.\n+\n+\t! D1Ar1 is ready\n+\t! Allocate stack space for return value\n+\tadd A0StP, A0StP, #8\n+\t! Store it to D0Ar2\n+\tsub D0Ar2, A0StP, #8\n+\n+\tsub D1Ar3, A0FrP, #4\n+\n+\t! D1Ar3 contains the address of the original D1Ar1 argument\n+\t! We need to subtract #4 later on\n+\n+\t! Preverve D0Ar2\n+\tmov D0.5, D0Ar2\n+\n+#ifdef __PIC__\n+\tcallr D1RtP, CNAME(ffi_closure_SYSV_inner@PLT)\n+#else\n+\tcallr D1RtP, CNAME(ffi_closure_SYSV_inner)\n+#endif\n+\n+\t! Check the return value and store it to D0.5\n+\tcmp D0Re0, #FFI_TYPE_INT\n+\tbeq .Lretint\n+\tcmp D0Re0, #FFI_TYPE_DOUBLE\n+\tbeq .Lretdouble\n+.Lclosure_epilogue:\n+\tsub A0StP, A0StP, #8\n+\tRET_REGS \"D1.5, D0.5\"\n+\tRET_ARGS\n+\tswap\tD1RtP, PC\n+\n+.Lretint:\n+\tsetd [D0.5], D0Re0\n+\tb .Lclosure_epilogue\n+.Lretdouble:\n+\tsetl [D0.5++], D0Re0, D1Re0\n+\tb .Lclosure_epilogue\n+.ffi_closure_SYSV_end:\n+.size CNAME(ffi_closure_SYSV),.ffi_closure_SYSV_end-CNAME(ffi_closure_SYSV)\n+\n+\n+ENTRY(ffi_metag_trampoline)\n+\tSAVE_ARGS\n+\t! New frame\n+\tmov A0FrP, A0StP\n+\tSAVE_REGS \"D1.5, D0.5\"\n+\tmov D0.5, PC\n+\t! Load D1Ar1 the value of ffi_metag_trampoline\n+\tgetd D1Ar1, [D0.5 + #8]\n+\t! Jump to ffi_closure_SYSV\n+\tgetd PC, [D0.5 + #12]"}, {"sha": "ea962ea4837d76693f7e6e85787a573bbfe90374", "filename": "libffi/src/microblaze/ffi.c", "status": "added", "additions": 321, "deletions": 0, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fmicroblaze%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fmicroblaze%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmicroblaze%2Fffi.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -0,0 +1,321 @@\n+/* -----------------------------------------------------------------------\n+   ffi.c - Copyright (c) 2012, 2013 Xilinx, Inc\n+\n+   MicroBlaze Foreign Function Interface\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#include <ffi.h>\n+#include <ffi_common.h>\n+\n+extern void ffi_call_SYSV(void (*)(void*, extended_cif*), extended_cif*,\n+\t\tunsigned int, unsigned int, unsigned int*, void (*fn)(void),\n+\t\tunsigned int, unsigned int);\n+\n+extern void ffi_closure_SYSV(void);\n+\n+#define WORD_SIZE\t\t\tsizeof(unsigned int)\n+#define ARGS_REGISTER_SIZE\t(WORD_SIZE * 6)\n+#define WORD_ALIGN(x)\t\tALIGN(x, WORD_SIZE)\n+\n+/* ffi_prep_args is called by the assembly routine once stack space\n+   has been allocated for the function's arguments */\n+void ffi_prep_args(void* stack, extended_cif* ecif)\n+{\n+\tunsigned int i;\n+\tffi_type** p_arg;\n+\tvoid** p_argv;\n+\tvoid* stack_args_p = stack;\n+\n+\tp_argv = ecif->avalue;\n+\n+\tif (ecif == NULL || ecif->cif == NULL) {\n+\t\treturn; /* no description to prepare */\n+\t}\n+\n+\tif ((ecif->cif->rtype != NULL) &&\n+\t\t\t(ecif->cif->rtype->type == FFI_TYPE_STRUCT))\n+\t{\n+\t\t/* if return type is a struct which is referenced on the stack/reg5,\n+\t\t * by a pointer. Stored the return value pointer in r5.\n+\t\t */\n+\t\tchar* addr = stack_args_p;\n+\t\tmemcpy(addr, &(ecif->rvalue), WORD_SIZE);\n+\t\tstack_args_p += WORD_SIZE;\n+\t}\n+\n+\tif (ecif->avalue == NULL) {\n+\t\treturn; /* no arguments to prepare */\n+\t}\n+\n+\tfor (i = 0, p_arg = ecif->cif->arg_types; i < ecif->cif->nargs;\n+\t\t\ti++, p_arg++)\n+\t{\n+\t\tsize_t size = (*p_arg)->size;\n+\t\tint type = (*p_arg)->type;\n+\t\tvoid* value = p_argv[i];\n+\t\tchar* addr = stack_args_p;\n+\t\tint aligned_size = WORD_ALIGN(size);\n+\n+\t\t/* force word alignment on the stack */\n+\t\tstack_args_p += aligned_size;\n+\t\t\n+\t\tswitch (type)\n+\t\t{\n+\t\t\tcase FFI_TYPE_UINT8:\n+\t\t\t\t*(unsigned int *)addr = (unsigned int)*(UINT8*)(value);\n+\t\t\t\tbreak;\n+\t\t\tcase FFI_TYPE_SINT8:\n+\t\t\t\t*(signed int *)addr = (signed int)*(SINT8*)(value);\n+\t\t\t\tbreak;\n+\t\t\tcase FFI_TYPE_UINT16:\n+\t\t\t\t*(unsigned int *)addr = (unsigned int)*(UINT16*)(value);\n+\t\t\t\tbreak;\n+\t\t\tcase FFI_TYPE_SINT16:\n+\t\t\t\t*(signed int *)addr = (signed int)*(SINT16*)(value);\n+\t\t\t\tbreak;\n+\t\t\tcase FFI_TYPE_STRUCT:\n+#if __BIG_ENDIAN__\n+\t\t\t\t/*\n+\t\t\t\t * MicroBlaze toolchain appears to emit:\n+\t\t\t\t * bsrli r5, r5, 8 (caller)\n+\t\t\t\t * ...\n+\t\t\t\t * <branch to callee>\n+\t\t\t\t * ...\n+\t\t\t\t * bslli r5, r5, 8 (callee)\n+\t\t\t\t * \n+\t\t\t\t * For structs like \"struct a { uint8_t a[3]; };\", when passed\n+\t\t\t\t * by value.\n+\t\t\t\t *\n+\t\t\t\t * Structs like \"struct b { uint16_t a; };\" are also expected\n+\t\t\t\t * to be packed strangely in registers.\n+\t\t\t\t *\n+\t\t\t\t * This appears to be because the microblaze toolchain expects\n+\t\t\t\t * \"struct b == uint16_t\", which is only any issue for big\n+\t\t\t\t * endian.\n+\t\t\t\t *\n+\t\t\t\t * The following is a work around for big-endian only, for the\n+\t\t\t\t * above mentioned case, it will re-align the contents of a\n+\t\t\t\t * <= 3-byte struct value.\n+\t\t\t\t */\n+\t\t\t\tif (size < WORD_SIZE)\n+\t\t\t\t{\n+\t\t\t\t  memcpy (addr + (WORD_SIZE - size), value, size);\n+\t\t\t\t  break;\n+\t\t\t\t}\n+#endif\n+\t\t\tcase FFI_TYPE_SINT32:\n+\t\t\tcase FFI_TYPE_UINT32:\n+\t\t\tcase FFI_TYPE_FLOAT:\n+\t\t\tcase FFI_TYPE_SINT64:\n+\t\t\tcase FFI_TYPE_UINT64:\n+\t\t\tcase FFI_TYPE_DOUBLE:\n+\t\t\tdefault:\n+\t\t\t\tmemcpy(addr, value, aligned_size);\n+\t\t}\n+\t}\n+}\n+\n+ffi_status ffi_prep_cif_machdep(ffi_cif* cif)\n+{\n+\t/* check ABI */\n+\tswitch (cif->abi)\n+\t{\n+\t\tcase FFI_SYSV:\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\treturn FFI_BAD_ABI;\n+\t}\n+\treturn FFI_OK;\n+}\n+\n+void ffi_call(ffi_cif* cif, void (*fn)(void), void* rvalue, void** avalue)\n+{\n+\textended_cif ecif;\n+\tecif.cif = cif;\n+\tecif.avalue = avalue;\n+\n+\t/* If the return value is a struct and we don't have a return */\n+\t/* value address then we need to make one */\n+\tif ((rvalue == NULL) && (cif->rtype->type == FFI_TYPE_STRUCT)) {\n+\t\tecif.rvalue = alloca(cif->rtype->size);\n+\t} else {\n+\t\tecif.rvalue = rvalue;\n+\t}\n+\n+\tswitch (cif->abi)\n+\t{\n+\tcase FFI_SYSV:\n+\t\tffi_call_SYSV(ffi_prep_args, &ecif, cif->bytes, cif->flags,\n+\t\t\t\tecif.rvalue, fn, cif->rtype->type, cif->rtype->size);\n+\t\tbreak;\n+\tdefault:\n+\t\tFFI_ASSERT(0);\n+\t\tbreak;\n+\t}\n+}\n+\n+void ffi_closure_call_SYSV(void* register_args, void* stack_args,\n+\t\t\tffi_closure* closure, void* rvalue,\n+\t\t\tunsigned int* rtype, unsigned int* rsize)\n+{\n+\t/* prepare arguments for closure call */\n+\tffi_cif* cif = closure->cif;\n+\tffi_type** arg_types = cif->arg_types;\n+\n+\t/* re-allocate data for the args. This needs to be done in order to keep\n+\t * multi-word objects (e.g. structs) in contiguous memory. Callers are not\n+\t * required to store the value of args in the lower 6 words in the stack\n+\t * (although they are allocated in the stack).\n+\t */\n+\tchar* stackclone = alloca(cif->bytes);\n+\tvoid** avalue = alloca(cif->nargs * sizeof(void*));\n+\tvoid* struct_rvalue = NULL;\n+\tchar* ptr = stackclone;\n+\tint i;\n+\n+\t/* copy registers into stack clone */\n+\tint registers_used = cif->bytes;\n+\tif (registers_used > ARGS_REGISTER_SIZE) {\n+\t\tregisters_used = ARGS_REGISTER_SIZE;\n+\t}\n+\tmemcpy(stackclone, register_args, registers_used);\n+\n+\t/* copy stack allocated args into stack clone */\n+\tif (cif->bytes > ARGS_REGISTER_SIZE) {\n+\t\tint stack_used = cif->bytes - ARGS_REGISTER_SIZE;\n+\t\tmemcpy(stackclone + ARGS_REGISTER_SIZE, stack_args, stack_used);\n+\t}\n+\n+\t/* preserve struct type return pointer passing */\n+\tif ((cif->rtype != NULL) && (cif->rtype->type == FFI_TYPE_STRUCT)) {\n+\t\tstruct_rvalue = *((void**)ptr);\n+\t\tptr += WORD_SIZE;\n+\t}\n+\n+\t/* populate arg pointer list */\n+\tfor (i = 0; i < cif->nargs; i++)\n+\t{\n+\t\tswitch (arg_types[i]->type)\n+\t\t{\n+\t\t\tcase FFI_TYPE_SINT8:\n+\t\t\tcase FFI_TYPE_UINT8:\n+#ifdef __BIG_ENDIAN__\n+\t\t\t\tavalue[i] = ptr + 3;\n+#else\n+\t\t\t\tavalue[i] = ptr;\n+#endif\n+\t\t\t\tbreak;\n+\t\t\tcase FFI_TYPE_SINT16:\n+\t\t\tcase FFI_TYPE_UINT16:\n+#ifdef __BIG_ENDIAN__\n+\t\t\t\tavalue[i] = ptr + 2;\n+#else\n+\t\t\t\tavalue[i] = ptr;\n+#endif\n+\t\t\t\tbreak;\n+\t\t\tcase FFI_TYPE_STRUCT:\n+#if __BIG_ENDIAN__\n+\t\t\t\t/*\n+\t\t\t\t * Work around strange ABI behaviour.\n+\t\t\t\t * (see info in ffi_prep_args)\n+\t\t\t\t */\n+\t\t\t\tif (arg_types[i]->size < WORD_SIZE)\n+\t\t\t\t{\n+\t\t\t\t  memcpy (ptr, ptr + (WORD_SIZE - arg_types[i]->size), arg_types[i]->size);\n+\t\t\t\t}\n+#endif\n+\t\t\t\tavalue[i] = (void*)ptr;\n+\t\t\t\tbreak;\n+\t\t\tcase FFI_TYPE_UINT64:\n+\t\t\tcase FFI_TYPE_SINT64:\n+\t\t\tcase FFI_TYPE_DOUBLE:\n+\t\t\t\tavalue[i] = ptr;\n+\t\t\t\tbreak;\n+\t\t\tcase FFI_TYPE_SINT32:\n+\t\t\tcase FFI_TYPE_UINT32:\n+\t\t\tcase FFI_TYPE_FLOAT:\n+\t\t\tdefault:\n+\t\t\t\t/* default 4-byte argument */\n+\t\t\t\tavalue[i] = ptr;\n+\t\t\t\tbreak;\n+\t\t}\n+\t\tptr += WORD_ALIGN(arg_types[i]->size);\n+\t}\n+\n+\t/* set the return type info passed back to the wrapper */\n+\t*rsize = cif->rtype->size;\n+\t*rtype = cif->rtype->type;\n+\tif (struct_rvalue != NULL) {\n+\t\tclosure->fun(cif, struct_rvalue, avalue, closure->user_data);\n+\t\t/* copy struct return pointer value into function return value */\n+\t\t*((void**)rvalue) = struct_rvalue;\n+\t} else {\n+\t\tclosure->fun(cif, rvalue, avalue, closure->user_data);\n+\t}\n+}\n+\n+ffi_status ffi_prep_closure_loc(\n+\t\tffi_closure* closure, ffi_cif* cif,\n+\t\tvoid (*fun)(ffi_cif*, void*, void**, void*),\n+\t\tvoid* user_data, void* codeloc)\n+{\n+\tunsigned long* tramp = (unsigned long*)&(closure->tramp[0]);\n+\tunsigned long cls = (unsigned long)codeloc;\n+\tunsigned long fn = 0;\n+\tunsigned long fn_closure_call_sysv = (unsigned long)ffi_closure_call_SYSV;\n+\n+\tclosure->cif = cif;\n+\tclosure->fun = fun;\n+\tclosure->user_data = user_data;\n+\n+\tswitch (cif->abi)\n+\t{\n+\tcase FFI_SYSV:\n+\t\tfn = (unsigned long)ffi_closure_SYSV;\n+\n+\t\t/* load r11 (temp) with fn */\n+\t\t/* imm fn(upper) */\n+\t\ttramp[0] = 0xb0000000 | ((fn >> 16) & 0xffff);\n+\t\t/* addik r11, r0, fn(lower) */\n+\t\ttramp[1] = 0x31600000 | (fn & 0xffff);\n+\n+\t\t/* load r12 (temp) with cls */\n+\t\t/* imm cls(upper) */\n+\t\ttramp[2] = 0xb0000000 | ((cls >> 16) & 0xffff);\n+\t\t/* addik r12, r0, cls(lower) */\n+\t\ttramp[3] = 0x31800000 | (cls & 0xffff);\n+\n+\t\t/* load r3 (temp) with ffi_closure_call_SYSV */\n+\t\t/* imm fn_closure_call_sysv(upper) */\n+\t\ttramp[4] = 0xb0000000 | ((fn_closure_call_sysv >> 16) & 0xffff);\n+\t\t/* addik r3, r0, fn_closure_call_sysv(lower) */\n+\t\ttramp[5] = 0x30600000 | (fn_closure_call_sysv & 0xffff);\n+\t\t/* branch/jump to address stored in r11 (fn) */\n+\t\ttramp[6] = 0x98085800; /* bra r11 */\n+\n+\t\tbreak;\n+\tdefault:\n+\t\treturn FFI_BAD_ABI;\n+\t}\n+\treturn FFI_OK;\n+}"}, {"sha": "c6fa5a4115d9806a0e68808c98f5be8635a80ccf", "filename": "libffi/src/microblaze/ffitarget.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fmicroblaze%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fmicroblaze%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmicroblaze%2Fffitarget.h?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -0,0 +1,53 @@\n+/* -----------------------------------------------------------------------\n+   ffitarget.h - Copyright (c) 2012, 2013 Xilinx, Inc\n+\n+   Target configuration macros for MicroBlaze.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#ifndef LIBFFI_TARGET_H\n+#define LIBFFI_TARGET_H\n+\n+#ifndef LIBFFI_H\n+#error \"Please do not include ffitarget.h directly into your source.  Use ffi.h instead.\"\n+#endif\n+\n+#ifndef LIBFFI_ASM\n+typedef unsigned long\t\t\tffi_arg;\n+typedef signed long\t\t\tffi_sarg;\n+\n+typedef enum ffi_abi {\n+\tFFI_FIRST_ABI = 0,\n+\tFFI_SYSV,\n+\tFFI_LAST_ABI,\n+\tFFI_DEFAULT_ABI = FFI_SYSV\n+} ffi_abi;\n+#endif\n+\n+/* Definitions for closures */\n+\n+#define FFI_CLOSURES 1\n+#define FFI_NATIVE_RAW_API 0\n+\n+#define FFI_TRAMPOLINE_SIZE (4*8)\n+\n+#endif"}, {"sha": "ea43e9d5453943297be18372efcb2b958fcb333e", "filename": "libffi/src/microblaze/sysv.S", "status": "added", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fmicroblaze%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fmicroblaze%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmicroblaze%2Fsysv.S?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -0,0 +1,302 @@\n+/* -----------------------------------------------------------------------\n+   sysv.S - Copyright (c) 2012, 2013 Xilinx, Inc\n+\n+   MicroBlaze Foreign Function Interface\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#define LIBFFI_ASM\n+#include <fficonfig.h>\n+#include <ffi.h>\n+\n+\t/*\n+\t * arg[0] (r5)  = ffi_prep_args,\n+\t * arg[1] (r6)  = &ecif,\n+\t * arg[2] (r7)  = cif->bytes,\n+\t * arg[3] (r8)  = cif->flags,\n+\t * arg[4] (r9)  = ecif.rvalue,\n+\t * arg[5] (r10) = fn\n+\t * arg[6] (sp[0]) = cif->rtype->type\n+\t * arg[7] (sp[4]) = cif->rtype->size\n+\t */\n+\t.text\n+\t.globl ffi_call_SYSV\n+\t.type ffi_call_SYSV, @function\n+ffi_call_SYSV:\n+\t/* push callee saves */\n+\taddik r1, r1, -20\n+\tswi r19, r1, 0 /* Frame Pointer */\n+\tswi r20, r1, 4 /* PIC register */\n+\tswi r21, r1, 8 /* PIC register */\n+\tswi r22, r1, 12 /* save for locals */\n+\tswi r23, r1, 16 /* save for locals */\n+\t\n+\t/* save the r5-r10 registers in the stack */\n+\taddik r1, r1, -24 /* increment sp to store 6x 32-bit words */\n+\tswi r5, r1, 0\n+\tswi r6, r1, 4\n+\tswi r7, r1, 8\n+\tswi r8, r1, 12\n+\tswi r9, r1, 16\n+\tswi r10, r1, 20\n+\n+\t/* save function pointer */\n+\taddik r3, r5, 0 /* copy ffi_prep_args into r3 */\n+\taddik r22, r1, 0 /* save sp for unallocated args into r22 (callee-saved) */\n+\taddik r23, r10, 0 /* save function address into r23 (callee-saved) */\n+\n+\t/* prepare stack with allocation for n (bytes = r7) args */\n+\trsub r1, r7, r1 /* subtract bytes from sp */\n+\n+\t/* prep args for ffi_prep_args call */\n+\taddik r5, r1, 0 /* store stack pointer into arg[0] */\n+\t/* r6 still holds ecif for arg[1] */\n+\n+\t/* Call ffi_prep_args(stack, &ecif). */\n+\taddik r1, r1, -4\n+\tswi r15, r1, 0 /* store the link register in the frame */\n+\tbrald r15, r3\n+\tnop /* branch has delay slot */\n+\tlwi r15, r1, 0\n+\taddik r1, r1, 4 /* restore the link register from the frame */\n+\t/* returns calling stack pointer location */\n+\n+\t/* prepare args for fn call, prep_args populates them onto the stack */\n+\tlwi r5, r1, 0 /* arg[0] */\n+\tlwi r6, r1, 4 /* arg[1] */\n+\tlwi r7, r1, 8 /* arg[2] */\n+\tlwi r8, r1, 12 /* arg[3] */\n+\tlwi r9, r1, 16 /* arg[4] */\n+\tlwi r10, r1, 20 /* arg[5] */\n+\n+\t/* call (fn) (...). */\n+\taddik r1, r1, -4\n+\tswi r15, r1, 0 /* store the link register in the frame */\n+\tbrald r15, r23\n+\tnop /* branch has delay slot */\n+\tlwi r15, r1, 0\n+\taddik r1, r1, 4 /* restore the link register from the frame */\n+\n+\t/* Remove the space we pushed for the args. */\n+\taddik r1, r22, 0 /* restore old SP */\n+\n+\t/* restore this functions parameters */\n+\tlwi r5, r1, 0 /* arg[0] */\n+\tlwi r6, r1, 4 /* arg[1] */\n+\tlwi r7, r1, 8 /* arg[2] */\n+\tlwi r8, r1, 12 /* arg[3] */\n+\tlwi r9, r1, 16 /* arg[4] */\n+\tlwi r10, r1, 20 /* arg[5] */\n+\taddik r1, r1, 24 /* decrement sp to de-allocate 6x 32-bit words */\n+\n+\t/* If the return value pointer is NULL, assume no return value. */\n+\tbeqi r9, ffi_call_SYSV_end\n+\n+\tlwi r22, r1, 48 /* get return type (20 for locals + 28 for arg[6]) */\n+\tlwi r23, r1, 52 /* get return size (20 for locals + 32 for arg[7])  */\n+\t\n+\t/* Check if return type is actually a struct, do nothing */\n+\trsubi r11, r22, FFI_TYPE_STRUCT\n+\tbeqi r11, ffi_call_SYSV_end\n+\n+\t/* Return 8bit */\n+\trsubi r11, r23, 1\n+\tbeqi r11, ffi_call_SYSV_store8\n+\n+\t/* Return 16bit */\n+\trsubi r11, r23, 2\n+\tbeqi r11, ffi_call_SYSV_store16\n+\n+\t/* Return 32bit */\n+\trsubi r11, r23, 4\n+\tbeqi r11, ffi_call_SYSV_store32\n+\n+\t/* Return 64bit */\n+\trsubi r11, r23, 8\n+\tbeqi r11, ffi_call_SYSV_store64\n+\n+\t/* Didn't match anything */\n+\tbri ffi_call_SYSV_end\n+\n+ffi_call_SYSV_store64:\n+\tswi r3, r9, 0 /* store word r3 into return value */\n+\tswi r4, r9, 4 /* store word r4 into return value */\n+\tbri ffi_call_SYSV_end\n+\n+ffi_call_SYSV_store32:\n+\tswi r3, r9, 0 /* store word r3 into return value */\n+\tbri ffi_call_SYSV_end\n+\n+ffi_call_SYSV_store16:\n+#ifdef __BIG_ENDIAN__\n+\tshi r3, r9, 2 /* store half-word r3 into return value */\n+#else\n+\tshi r3, r9, 0 /* store half-word r3 into return value */\n+#endif\n+\tbri ffi_call_SYSV_end\n+\n+ffi_call_SYSV_store8:\n+#ifdef __BIG_ENDIAN__\n+\tsbi r3, r9, 3 /* store byte r3 into return value */\n+#else\n+\tsbi r3, r9, 0 /* store byte r3 into return value */\n+#endif\n+\tbri ffi_call_SYSV_end\n+\n+ffi_call_SYSV_end:\n+\t/* callee restores */\n+\tlwi r19, r1, 0 /* frame pointer */\n+\tlwi r20, r1, 4 /* PIC register */\n+\tlwi r21, r1, 8 /* PIC register */\n+\tlwi r22, r1, 12\n+\tlwi r23, r1, 16\n+\taddik r1, r1, 20\n+\n+\t/* return from sub-routine (with delay slot) */\n+\trtsd r15, 8\n+\tnop\n+\n+\t.size ffi_call_SYSV, . - ffi_call_SYSV\n+\n+/* ------------------------------------------------------------------------- */\n+\n+\t/*\n+\t * args passed into this function, are passed down to the callee.\n+\t * this function is the target of the closure trampoline, as such r12 is \n+\t * a pointer to the closure object.\n+\t */\n+\t.text\n+\t.globl ffi_closure_SYSV\n+\t.type ffi_closure_SYSV, @function\n+ffi_closure_SYSV:\n+\t/* push callee saves */\n+\taddik r11, r1, 28 /* save stack args start location (excluding regs/link) */\n+\taddik r1, r1, -12\n+\tswi r19, r1, 0 /* Frame Pointer */\n+\tswi r20, r1, 4 /* PIC register */\n+\tswi r21, r1, 8 /* PIC register */\n+\n+\t/* store register args on stack */\n+\taddik r1, r1, -24\n+\tswi r5, r1, 0\n+\tswi r6, r1, 4\n+\tswi r7, r1, 8\n+\tswi r8, r1, 12\n+\tswi r9, r1, 16\n+\tswi r10, r1, 20\n+\n+\t/* setup args */\n+\taddik r5, r1, 0 /* register_args */\n+\taddik r6, r11, 0 /* stack_args */\n+\taddik r7, r12, 0 /* closure object */\n+\taddik r1, r1, -8 /* allocate return value */\n+\taddik r8, r1, 0 /* void* rvalue */\n+\taddik r1, r1, -8 /* allocate for return type/size values */\n+\taddik r9, r1, 0 /* void* rtype */\n+\taddik r10, r1, 4 /* void* rsize */\n+\n+\t/* call the wrap_call function */\n+\taddik r1, r1, -28 /* allocate args + link reg */\n+\tswi r15, r1, 0 /* store the link register in the frame */\n+\tbrald r15, r3\n+\tnop /* branch has delay slot */\n+\tlwi r15, r1, 0\n+\taddik r1, r1, 28 /* restore the link register from the frame */\n+\n+ffi_closure_SYSV_prepare_return:\n+\tlwi r9, r1, 0 /* rtype */\n+\tlwi r10, r1, 4 /* rsize */\n+\taddik r1, r1, 8 /* de-allocate return info values */\n+\n+\t/* Check if return type is actually a struct, store 4 bytes */\n+\trsubi r11, r9, FFI_TYPE_STRUCT\n+\tbeqi r11, ffi_closure_SYSV_store32\n+\n+\t/* Return 8bit */\n+\trsubi r11, r10, 1\n+\tbeqi r11, ffi_closure_SYSV_store8\n+\n+\t/* Return 16bit */\n+\trsubi r11, r10, 2\n+\tbeqi r11, ffi_closure_SYSV_store16\n+\n+\t/* Return 32bit */\n+\trsubi r11, r10, 4\n+\tbeqi r11, ffi_closure_SYSV_store32\n+\n+\t/* Return 64bit */\n+\trsubi r11, r10, 8\n+\tbeqi r11, ffi_closure_SYSV_store64\n+\n+\t/* Didn't match anything */\n+\tbri ffi_closure_SYSV_end\n+\n+ffi_closure_SYSV_store64:\n+\tlwi r3, r1, 0 /* store word r3 into return value */\n+\tlwi r4, r1, 4 /* store word r4 into return value */\n+\t/* 64 bits == 2 words, no sign extend occurs */\n+\tbri ffi_closure_SYSV_end\n+\n+ffi_closure_SYSV_store32:\n+\tlwi r3, r1, 0 /* store word r3 into return value */\n+\t/* 32 bits == 1 word, no sign extend occurs */\n+\tbri ffi_closure_SYSV_end\n+\n+ffi_closure_SYSV_store16:\n+#ifdef __BIG_ENDIAN__\n+\tlhui r3, r1, 2 /* store half-word r3 into return value */\n+#else\n+\tlhui r3, r1, 0 /* store half-word r3 into return value */\n+#endif\n+\trsubi r11, r9, FFI_TYPE_SINT16\n+\tbnei r11, ffi_closure_SYSV_end\n+\tsext16 r3, r3 /* fix sign extend of sint8 */\n+\tbri ffi_closure_SYSV_end\n+\n+ffi_closure_SYSV_store8:\n+#ifdef __BIG_ENDIAN__\n+\tlbui r3, r1, 3 /* store byte r3 into return value */\n+#else\n+\tlbui r3, r1, 0 /* store byte r3 into return value */\n+#endif\n+\trsubi r11, r9, FFI_TYPE_SINT8\n+\tbnei r11, ffi_closure_SYSV_end\n+\tsext8 r3, r3 /* fix sign extend of sint8 */\n+\tbri ffi_closure_SYSV_end\n+\n+ffi_closure_SYSV_end:\n+\taddik r1, r1, 8 /* de-allocate return value */\n+\n+\t/* de-allocate stored args */\n+\taddik r1, r1, 24\n+\n+\t/* callee restores */\n+\tlwi r19, r1, 0 /* frame pointer */\n+\tlwi r20, r1, 4 /* PIC register */\n+\tlwi r21, r1, 8 /* PIC register */\n+\taddik r1, r1, 12\n+\n+\t/* return from sub-routine (with delay slot) */\n+\trtsd r15, 8\n+\tnop\n+\n+\t.size ffi_closure_SYSV, . - ffi_closure_SYSV"}, {"sha": "5d0dd70cb32884a838d1855f8232a8f64d13113a", "filename": "libffi/src/mips/ffi.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fmips%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fmips%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmips%2Fffi.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -170,7 +170,14 @@ static void ffi_prep_args(char *stack,\n \t\tbreak;\n \t\t  \n \t      case FFI_TYPE_UINT32:\n+#ifdef FFI_MIPS_N32\n+\t\t/* The N32 ABI requires that 32-bit integers\n+\t\t   be sign-extended to 64-bits, regardless of\n+\t\t   whether they are signed or unsigned. */\n+\t\t*(ffi_arg *)argp = *(SINT32 *)(* p_argv);\n+#else\n \t\t*(ffi_arg *)argp = *(UINT32 *)(* p_argv);\n+#endif\n \t\tbreak;\n \n \t      /* This can only happen with 64bit slots.  */"}, {"sha": "c6985d30a6f6402edf83d0d548d2a3b9261106d9", "filename": "libffi/src/mips/n32.S", "status": "modified", "additions": 8, "deletions": 24, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fmips%2Fn32.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fmips%2Fn32.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmips%2Fn32.S?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -108,10 +108,8 @@ loadregs:\n \tREG_L\tt6, 3*FFI_SIZEOF_ARG($fp)  # load the flags word into t6.\n \n \tand\tt4, t6, ((1<<FFI_FLAG_BITS)-1)\n-\tbnez\tt4, arg1_floatp\n \tREG_L\ta0, 0*FFI_SIZEOF_ARG(t9)\n-\tb\targ1_next\n-arg1_floatp:\t\n+\tbeqz\tt4, arg1_next\n \tbne\tt4, FFI_TYPE_FLOAT, arg1_doublep\n \tl.s\t$f12, 0*FFI_SIZEOF_ARG(t9)\n \tb\targ1_next\n@@ -121,10 +119,8 @@ arg1_next:\n \t\n \tSRL\tt4, t6, 1*FFI_FLAG_BITS\n \tand\tt4, ((1<<FFI_FLAG_BITS)-1)\n-\tbnez\tt4, arg2_floatp\n \tREG_L\ta1, 1*FFI_SIZEOF_ARG(t9)\n-\tb\targ2_next\n-arg2_floatp:\n+\tbeqz\tt4, arg2_next\n \tbne\tt4, FFI_TYPE_FLOAT, arg2_doublep\n \tl.s\t$f13, 1*FFI_SIZEOF_ARG(t9)\t\n \tb\targ2_next\n@@ -134,10 +130,8 @@ arg2_next:\n \t\n \tSRL\tt4, t6, 2*FFI_FLAG_BITS\n \tand\tt4, ((1<<FFI_FLAG_BITS)-1)\n-\tbnez\tt4, arg3_floatp\n \tREG_L\ta2, 2*FFI_SIZEOF_ARG(t9)\n-\tb\targ3_next\n-arg3_floatp:\n+\tbeqz\tt4, arg3_next\n \tbne\tt4, FFI_TYPE_FLOAT, arg3_doublep\n \tl.s\t$f14, 2*FFI_SIZEOF_ARG(t9)\t\n \tb\targ3_next\n@@ -147,10 +141,8 @@ arg3_next:\n \t\n \tSRL\tt4, t6, 3*FFI_FLAG_BITS\n \tand\tt4, ((1<<FFI_FLAG_BITS)-1)\n-\tbnez\tt4, arg4_floatp\n \tREG_L\ta3, 3*FFI_SIZEOF_ARG(t9)\n-\tb\targ4_next\n-arg4_floatp:\n+\tbeqz\tt4, arg4_next\n \tbne\tt4, FFI_TYPE_FLOAT, arg4_doublep\n \tl.s\t$f15, 3*FFI_SIZEOF_ARG(t9)\t\n \tb\targ4_next\n@@ -160,10 +152,8 @@ arg4_next:\n \t\n \tSRL\tt4, t6, 4*FFI_FLAG_BITS\n \tand\tt4, ((1<<FFI_FLAG_BITS)-1)\n-\tbnez\tt4, arg5_floatp\n \tREG_L\ta4, 4*FFI_SIZEOF_ARG(t9)\n-\tb\targ5_next\n-arg5_floatp:\n+\tbeqz\tt4, arg5_next\n \tbne\tt4, FFI_TYPE_FLOAT, arg5_doublep\n \tl.s\t$f16, 4*FFI_SIZEOF_ARG(t9)\t\n \tb\targ5_next\n@@ -173,10 +163,8 @@ arg5_next:\n \t\n \tSRL\tt4, t6, 5*FFI_FLAG_BITS\n \tand\tt4, ((1<<FFI_FLAG_BITS)-1)\n-\tbnez\tt4, arg6_floatp\n \tREG_L\ta5, 5*FFI_SIZEOF_ARG(t9)\n-\tb\targ6_next\n-arg6_floatp:\n+\tbeqz\tt4, arg6_next\n \tbne\tt4, FFI_TYPE_FLOAT, arg6_doublep\n \tl.s\t$f17, 5*FFI_SIZEOF_ARG(t9)\t\n \tb\targ6_next\n@@ -186,10 +174,8 @@ arg6_next:\n \t\n \tSRL\tt4, t6, 6*FFI_FLAG_BITS\n \tand\tt4, ((1<<FFI_FLAG_BITS)-1)\n-\tbnez\tt4, arg7_floatp\n \tREG_L\ta6, 6*FFI_SIZEOF_ARG(t9)\n-\tb\targ7_next\n-arg7_floatp:\n+\tbeqz\tt4, arg7_next\n \tbne\tt4, FFI_TYPE_FLOAT, arg7_doublep\n \tl.s\t$f18, 6*FFI_SIZEOF_ARG(t9)\t\n \tb\targ7_next\n@@ -199,10 +185,8 @@ arg7_next:\n \t\n \tSRL\tt4, t6, 7*FFI_FLAG_BITS\n \tand\tt4, ((1<<FFI_FLAG_BITS)-1)\n-\tbnez\tt4, arg8_floatp\n \tREG_L\ta7, 7*FFI_SIZEOF_ARG(t9)\n-\tb\targ8_next\n-arg8_floatp:\n+\tbeqz\tt4, arg8_next\n \tbne\tt4, FFI_TYPE_FLOAT, arg8_doublep\n  \tl.s\t$f19, 7*FFI_SIZEOF_ARG(t9)\t\n \tb\targ8_next"}, {"sha": "ac7aceb1a6bb12ff2e4994ccb6ab930793e1bf8c", "filename": "libffi/src/moxie/eabi.S", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fmoxie%2Feabi.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fmoxie%2Feabi.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmoxie%2Feabi.S?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -0,0 +1,101 @@\n+/* -----------------------------------------------------------------------\n+   eabi.S - Copyright (c) 2012, 2013  Anthony Green\n+   \n+   Moxie Assembly glue.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR\n+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+   OTHER DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#define LIBFFI_ASM\t\n+#include <fficonfig.h>\n+#include <ffi.h>\n+\n+\t.globl ffi_prep_args_EABI\n+\n+\t.text\n+\t.p2align 4\n+\t.globl ffi_call_EABI\n+\t.type ffi_call_EABI, @function\n+\n+\t# $r0 :   ffi_prep_args\n+\t# $r1 :   &ecif\n+\t# $r2 :   cif->bytes\n+\t# $r3 :   fig->flags\n+\t# $r4 :   ecif.rvalue\n+\t# $r5 :   fn\n+\t\n+ffi_call_EABI:\n+\tpush\t$sp, $r6\n+\tpush\t$sp, $r7\n+\tpush\t$sp, $r8\n+\tdec\t$sp, 24\n+\n+\t/* Store incoming args on stack.  */\n+\tsto.l\t0($sp), $r0 /* ffi_prep_args */\n+\tsto.l\t4($sp), $r1 /* ecif */\n+\tsto.l\t8($sp), $r2 /* bytes */\n+\tsto.l\t12($sp), $r3 /* flags */\n+\tsto.l\t16($sp), $r4 /* &rvalue */\n+\tsto.l\t20($sp), $r5 /* fn */\n+\t\n+\t/* Call ffi_prep_args.  */\n+\tmov \t$r6, $r4 /* Save result buffer */\n+\tmov\t$r7, $r5 /* Save the target fn */\n+\tmov\t$r8, $r3 /* Save the flags */\n+\tsub.l\t$sp, $r2 /* Allocate stack space */\n+\tmov\t$r0, $sp /* We can stomp over $r0 */\n+\t/* $r1 is already set up */\n+\tjsra \tffi_prep_args\n+\n+\t/* Load register arguments.  */\n+\tldo.l\t$r0, 0($sp)\n+\tldo.l\t$r1, 4($sp)\n+\tldo.l\t$r2, 8($sp)\n+\tldo.l\t$r3, 12($sp)\n+\tldo.l\t$r4, 16($sp)\n+\tldo.l\t$r5, 20($sp)\n+\t\n+\t/* Call the target function.  */\n+\tjsr\t$r7\n+\n+\tldi.l\t$r7, 0xffffffff\n+\tcmp\t$r8, $r7\n+\tbeq\tretstruct\n+\n+\tldi.l\t$r7, 4\n+\tcmp\t$r8, $r7\n+\tbgt\tret2reg\n+\n+\tst.l\t($r6), $r0\n+\tjmpa\tretdone\n+\n+ret2reg:\t\n+\tst.l\t($r6), $r0\n+\tsto.l\t4($r6), $r1\n+\n+retstruct:\n+retdone:\t\n+\t/* Return.  */\n+\tldo.l\t$r6, -4($fp)\n+\tldo.l\t$r7, -8($fp)\n+\tldo.l\t$r8, -12($fp)\n+\tret\n+\t.size ffi_call_EABI, .-ffi_call_EABI\n+\t"}, {"sha": "540a042996f5f672819f62d983d2b78f40cc333d", "filename": "libffi/src/moxie/ffi.c", "status": "added", "additions": 272, "deletions": 0, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fmoxie%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fmoxie%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmoxie%2Fffi.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -0,0 +1,272 @@\n+/* -----------------------------------------------------------------------\n+   ffi.c - Copyright (C) 2012, 2013  Anthony Green\n+   \n+   Moxie Foreign Function Interface \n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#include <ffi.h>\n+#include <ffi_common.h>\n+\n+#include <stdlib.h>\n+\n+/* ffi_prep_args is called by the assembly routine once stack space\n+   has been allocated for the function's arguments */\n+\n+void *ffi_prep_args(char *stack, extended_cif *ecif)\n+{\n+  register unsigned int i;\n+  register void **p_argv;\n+  register char *argp;\n+  register ffi_type **p_arg;\n+  register int count = 0;\n+\n+  p_argv = ecif->avalue;\n+  argp = stack;\n+\n+  if (ecif->cif->rtype->type == FFI_TYPE_STRUCT)\n+    {\n+      *(void **) argp = ecif->rvalue;\n+      argp += 4;\n+    }\n+\n+  for (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types;\n+       (i != 0);\n+       i--, p_arg++)\n+    {\n+      size_t z;\n+      \n+      z = (*p_arg)->size;\n+\n+      if ((*p_arg)->type == FFI_TYPE_STRUCT)\n+\t{\n+\t  z = sizeof(void*);\n+\t  *(void **) argp = *p_argv;\n+\t} \n+      else if (z < sizeof(int))\n+\t{\n+\t  z = sizeof(int);\n+\t  switch ((*p_arg)->type)\n+\t    {\n+\t    case FFI_TYPE_SINT8:\n+\t      *(signed int *) argp = (signed int)*(SINT8 *)(* p_argv);\n+\t      break;\n+\t      \n+\t    case FFI_TYPE_UINT8:\n+\t      *(unsigned int *) argp = (unsigned int)*(UINT8 *)(* p_argv);\n+\t      break;\n+\t      \n+\t    case FFI_TYPE_SINT16:\n+\t      *(signed int *) argp = (signed int)*(SINT16 *)(* p_argv);\n+\t      break;\n+\t\t  \n+\t    case FFI_TYPE_UINT16:\n+\t      *(unsigned int *) argp = (unsigned int)*(UINT16 *)(* p_argv);\n+\t      break;\n+\t\t  \n+\t    default:\n+\t      FFI_ASSERT(0);\n+\t    }\n+\t}\n+      else if (z == sizeof(int))\n+\t{\n+\t  *(unsigned int *) argp = (unsigned int)*(UINT32 *)(* p_argv);\n+\t}\n+      else\n+\t{\n+\t  memcpy(argp, *p_argv, z);\n+\t}\n+      p_argv++;\n+      argp += z;\n+      count += z;\n+    }\n+\n+  return (stack + ((count > 24) ? 24 : ALIGN_DOWN(count, 8)));\n+}\n+\n+/* Perform machine dependent cif processing */\n+ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n+{\n+  if (cif->rtype->type == FFI_TYPE_STRUCT)\n+    cif->flags = -1;\n+  else\n+    cif->flags = cif->rtype->size;\n+\n+  cif->bytes = ALIGN (cif->bytes, 8);\n+\n+  return FFI_OK;\n+}\n+\n+extern void ffi_call_EABI(void *(*)(char *, extended_cif *), \n+\t\t\t  extended_cif *, \n+\t\t\t  unsigned, unsigned, \n+\t\t\t  unsigned *, \n+\t\t\t  void (*fn)(void));\n+\n+void ffi_call(ffi_cif *cif, \n+\t      void (*fn)(void), \n+\t      void *rvalue, \n+\t      void **avalue)\n+{\n+  extended_cif ecif;\n+\n+  ecif.cif = cif;\n+  ecif.avalue = avalue;\n+  \n+  /* If the return value is a struct and we don't have a return\t*/\n+  /* value address then we need to make one\t\t        */\n+\n+  if ((rvalue == NULL) && \n+      (cif->rtype->type == FFI_TYPE_STRUCT))\n+    {\n+      ecif.rvalue = alloca(cif->rtype->size);\n+    }\n+  else\n+    ecif.rvalue = rvalue;\n+\n+  switch (cif->abi) \n+    {\n+    case FFI_EABI:\n+      ffi_call_EABI(ffi_prep_args, &ecif, cif->bytes, \n+\t\t    cif->flags, ecif.rvalue, fn);\n+      break;\n+    default:\n+      FFI_ASSERT(0);\n+      break;\n+    }\n+}\n+\n+void ffi_closure_eabi (unsigned arg1, unsigned arg2, unsigned arg3,\n+\t\t       unsigned arg4, unsigned arg5, unsigned arg6)\n+{\n+  /* This function is called by a trampoline.  The trampoline stows a\n+     pointer to the ffi_closure object in $r7.  We must save this\n+     pointer in a place that will persist while we do our work.  */\n+  register ffi_closure *creg __asm__ (\"$r12\");\n+  ffi_closure *closure = creg;\n+\n+  /* Arguments that don't fit in registers are found on the stack\n+     at a fixed offset above the current frame pointer.  */\n+  register char *frame_pointer __asm__ (\"$fp\");\n+\n+  /* Pointer to a struct return value.  */\n+  void *struct_rvalue = (void *) arg1;\n+\n+  /* 6 words reserved for register args + 3 words from jsr */\n+  char *stack_args = frame_pointer + 9*4; \n+\n+  /* Lay the register arguments down in a continuous chunk of memory.  */\n+  unsigned register_args[6] =\n+    { arg1, arg2, arg3, arg4, arg5, arg6 };\n+  char *register_args_ptr = (char *) register_args;\n+\n+  ffi_cif *cif = closure->cif;\n+  ffi_type **arg_types = cif->arg_types;\n+  void **avalue = alloca (cif->nargs * sizeof(void *));\n+  char *ptr = (char *) register_args;\n+  int i;\n+\n+  /* preserve struct type return pointer passing */\n+  if ((cif->rtype != NULL) && (cif->rtype->type == FFI_TYPE_STRUCT)) {\n+    ptr += 4;\n+    register_args_ptr = (char *)&register_args[1];\n+  }\n+\n+  /* Find the address of each argument.  */\n+  for (i = 0; i < cif->nargs; i++)\n+    {\n+      switch (arg_types[i]->type)\n+\t{\n+\tcase FFI_TYPE_SINT8:\n+\tcase FFI_TYPE_UINT8:\n+\t  avalue[i] = ptr + 3;\n+\t  break;\n+\tcase FFI_TYPE_SINT16:\n+\tcase FFI_TYPE_UINT16:\n+\t  avalue[i] = ptr + 2;\n+\t  break;\n+\tcase FFI_TYPE_SINT32:\n+\tcase FFI_TYPE_UINT32:\n+\tcase FFI_TYPE_FLOAT:\n+\tcase FFI_TYPE_POINTER:\n+\t  avalue[i] = ptr;\n+\t  break;\n+\tcase FFI_TYPE_STRUCT:\n+\t  avalue[i] = *(void**)ptr;\n+\t  break;\n+\tdefault:\n+\t  /* This is an 8-byte value.  */\n+\t  avalue[i] = ptr;\n+\t  ptr += 4;\n+\t  break;\n+\t}\n+      ptr += 4;\n+\n+      /* If we've handled more arguments than fit in registers,\n+\t start looking at the those passed on the stack.  */\n+      if (ptr == &register_args[6])\n+\tptr = stack_args;\n+    }\n+\n+  /* Invoke the closure.  */\n+  if (cif->rtype && (cif->rtype->type == FFI_TYPE_STRUCT))\n+    {\n+      (closure->fun) (cif, struct_rvalue, avalue, closure->user_data);\n+    }\n+  else\n+    {\n+      /* Allocate space for the return value and call the function.  */\n+      long long rvalue;\n+      (closure->fun) (cif, &rvalue, avalue, closure->user_data);\n+      asm (\"mov $r12, %0\\n ld.l $r0, ($r12)\\n ldo.l $r1, 4($r12)\" : : \"r\" (&rvalue));\n+    }\n+}\n+\n+ffi_status\n+ffi_prep_closure_loc (ffi_closure* closure,\n+\t\t      ffi_cif* cif,\n+\t\t      void (*fun)(ffi_cif*, void*, void**, void*),\n+\t\t      void *user_data,\n+\t\t      void *codeloc)\n+{\n+  unsigned short *tramp = (unsigned short *) &closure->tramp[0];\n+  unsigned long fn = (long) ffi_closure_eabi;\n+  unsigned long cls = (long) codeloc;\n+\n+  if (cif->abi != FFI_EABI)\n+    return FFI_BAD_ABI;\n+\n+  fn = (unsigned long) ffi_closure_eabi;\n+\n+  tramp[0] = 0x01e0; /* ldi.l $r7, .... */\n+  tramp[1] = cls >> 16;\n+  tramp[2] = cls & 0xffff;\n+  tramp[3] = 0x1a00; /* jmpa .... */\n+  tramp[4] = fn >> 16;\n+  tramp[5] = fn & 0xffff;\n+\n+  closure->cif = cif;\n+  closure->fun = fun;\n+  closure->user_data = user_data;\n+\n+  return FFI_OK;\n+}"}, {"sha": "623e3ece57d56facd1894a8ae92d063a341849bd", "filename": "libffi/src/moxie/ffitarget.h", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fmoxie%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fmoxie%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmoxie%2Fffitarget.h?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -0,0 +1,52 @@\n+/* -----------------------------------------------------------------*-C-*-\n+   ffitarget.h - Copyright (c) 2012, 2013  Anthony Green\n+   Target configuration macros for Moxie\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+\n+   ----------------------------------------------------------------------- */\n+\n+#ifndef LIBFFI_TARGET_H\n+#define LIBFFI_TARGET_H\n+\n+/* ---- System specific configurations ----------------------------------- */\n+\n+#ifndef LIBFFI_ASM\n+typedef unsigned long          ffi_arg;\n+typedef signed long            ffi_sarg;\n+\n+typedef enum ffi_abi {\n+  FFI_FIRST_ABI = 0,\n+  FFI_EABI,\n+  FFI_DEFAULT_ABI = FFI_EABI,\n+  FFI_LAST_ABI = FFI_DEFAULT_ABI + 1\n+} ffi_abi;\n+#endif\n+\n+/* ---- Definitions for closures ----------------------------------------- */\n+\n+#define FFI_CLOSURES 1\n+#define FFI_NATIVE_RAW_API 0\n+\n+/* Trampolines are 12-bytes long.  See ffi_prep_closure_loc.  */\n+#define FFI_TRAMPOLINE_SIZE (12)\n+\n+#endif"}, {"sha": "2efa033f9cd61f15164f3f45230bed715e486492", "filename": "libffi/src/nios2/ffi.c", "status": "added", "additions": 304, "deletions": 0, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fnios2%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fnios2%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fnios2%2Fffi.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -0,0 +1,304 @@\n+/* libffi support for Altera Nios II.\n+\n+   Copyright (c) 2013 Mentor Graphics.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+   \n+   The above copyright notice and this permission notice shall be\n+   included in all copies or substantial portions of the Software.\n+   \n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n+   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n+   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */\n+\n+\n+#include <ffi.h>\n+#include <ffi_common.h>\n+\n+#include <stdlib.h>\n+\n+/* The Nios II Processor Reference Handbook defines the procedure call\n+   ABI as follows.\n+\n+   Arguments are passed as if a structure containing the types of\n+   the arguments were constructed.  The first 16 bytes are passed in r4\n+   through r7, the remainder on the stack.  The first 16 bytes of a function\n+   taking variable arguments are passed in r4-r7 in the same way.\n+\n+   Return values of types up to 8 bytes are returned in r2 and r3.  For\n+   return values greater than 8 bytes, the caller must allocate memory for\n+   the result and pass the address as if it were argument 0.  \n+\n+   While this isn't specified explicitly in the ABI documentation, GCC\n+   promotes integral arguments smaller than int size to 32 bits.\n+\n+   Also of note, the ABI specifies that all structure objects are\n+   aligned to 32 bits even if all their fields have a smaller natural\n+   alignment.  See FFI_AGGREGATE_ALIGNMENT.  */\n+\n+\n+/* Declare the assembly language hooks.  */\n+\n+extern UINT64 ffi_call_sysv (void (*) (char *, extended_cif *),\n+\t\t\t     extended_cif *,\n+\t\t\t     unsigned, \n+\t\t\t     void (*fn) (void));\n+extern void ffi_closure_sysv (void);\n+\n+/* Perform machine-dependent cif processing.  */\n+\n+ffi_status ffi_prep_cif_machdep (ffi_cif *cif)\n+{\n+  /* We always want at least 16 bytes in the parameter block since it\n+     simplifies the low-level call function.  Also round the parameter\n+     block size up to a multiple of 4 bytes to preserve\n+     32-bit alignment of the stack pointer.  */\n+  if (cif->bytes < 16)\n+    cif->bytes = 16;\n+  else\n+    cif->bytes = (cif->bytes + 3) & ~3;\n+\n+  return FFI_OK;\n+}\n+\n+\n+/* ffi_prep_args is called by the assembly routine to transfer arguments\n+   to the stack using the pointers in the ecif array.\n+   Note that the stack buffer is big enough to fit all the arguments,\n+   but the first 16 bytes will be copied to registers for the actual\n+   call.  */\n+\n+void ffi_prep_args (char *stack, extended_cif *ecif)\n+{\n+  char *argp = stack;\n+  unsigned int i;\n+\n+  /* The implicit return value pointer is passed as if it were a hidden\n+     first argument.  */\n+  if (ecif->cif->rtype->type == FFI_TYPE_STRUCT\n+      && ecif->cif->rtype->size > 8)\n+    {\n+      (*(void **) argp) = ecif->rvalue;\n+      argp += 4;\n+    }\n+\n+  for (i = 0; i < ecif->cif->nargs; i++)\n+    {\n+      void *avalue = ecif->avalue[i];\n+      ffi_type *atype = ecif->cif->arg_types[i];\n+      size_t size = atype->size;\n+      size_t alignment = atype->alignment;\n+\n+      /* Align argp as appropriate for the argument type.  */\n+      if ((alignment - 1) & (unsigned) argp)\n+\targp = (char *) ALIGN (argp, alignment);\n+\n+      /* Copy the argument, promoting integral types smaller than a\n+\t word to word size.  */\n+      if (size < sizeof (int))\n+\t{\n+\t  size = sizeof (int);\n+\t  switch (atype->type)\n+\t    {\n+\t    case FFI_TYPE_SINT8:\n+\t      *(signed int *) argp = (signed int) *(SINT8 *) avalue;\n+\t      break;\n+\t\t  \n+\t    case FFI_TYPE_UINT8:\n+\t      *(unsigned int *) argp = (unsigned int) *(UINT8 *) avalue;\n+\t      break;\n+\t\t  \n+\t    case FFI_TYPE_SINT16:\n+\t      *(signed int *) argp = (signed int) *(SINT16 *) avalue;\n+\t      break;\n+\t\t  \n+\t    case FFI_TYPE_UINT16:\n+\t      *(unsigned int *) argp = (unsigned int) *(UINT16 *) avalue;\n+\t      break;\n+\n+\t    case FFI_TYPE_STRUCT:\n+\t      memcpy (argp, avalue, atype->size);\n+\t      break;\n+\n+\t    default:\n+\t      FFI_ASSERT(0);\n+\t    }\n+\t}\n+      else if (size == sizeof (int))\n+\t*(unsigned int *) argp = (unsigned int) *(UINT32 *) avalue;\n+      else\n+\tmemcpy (argp, avalue, size);\n+      argp += size;\n+    }\n+}\n+\n+\n+/* Call FN using the prepared CIF.  RVALUE points to space allocated by\n+   the caller for the return value, and AVALUE is an array of argument\n+   pointers.  */\n+\n+void ffi_call (ffi_cif *cif, void (*fn) (void), void *rvalue, void **avalue)\n+{\n+\n+  extended_cif ecif;\n+  UINT64 result;\n+\n+  /* If bigret is true, this is the case where a return value of larger\n+     than 8 bytes is handled by being passed by reference as an implicit\n+     argument.  */\n+  int bigret = (cif->rtype->type == FFI_TYPE_STRUCT\n+\t\t&& cif->rtype->size > 8);\n+\n+  ecif.cif = cif;\n+  ecif.avalue = avalue;\n+\n+  /* Allocate space for return value if this is the pass-by-reference case\n+     and the caller did not provide a buffer.  */\n+  if (rvalue == NULL && bigret)\n+    ecif.rvalue = alloca (cif->rtype->size);\n+  else\n+    ecif.rvalue = rvalue;\n+\n+  result = ffi_call_sysv (ffi_prep_args, &ecif, cif->bytes, fn);\n+\n+  /* Now result contains the 64 bit contents returned from fn in\n+     r2 and r3.  Copy the value of the appropriate size to the user-provided\n+     rvalue buffer.  */\n+  if (rvalue && !bigret)\n+    switch (cif->rtype->size)\n+      {\n+      case 1:\n+\t*(UINT8 *)rvalue = (UINT8) result;\n+\tbreak;\n+      case 2:\n+\t*(UINT16 *)rvalue = (UINT16) result;\n+\tbreak;\n+      case 4:\n+\t*(UINT32 *)rvalue = (UINT32) result;\n+\tbreak;\n+      case 8:\n+\t*(UINT64 *)rvalue = (UINT64) result;\n+\tbreak;\n+      default:\n+\tmemcpy (rvalue, (void *)&result, cif->rtype->size);\n+\tbreak;\n+      }\n+}\n+\n+/* This function is invoked from the closure trampoline to invoke\n+   CLOSURE with argument block ARGS.  Parse ARGS according to\n+   CLOSURE->cfi and invoke CLOSURE->fun.  */\n+\n+static UINT64\n+ffi_closure_helper (unsigned char *args,\n+\t\t    ffi_closure *closure)\n+{\n+  ffi_cif *cif = closure->cif;\n+  unsigned char *argp = args;\n+  void **parsed_args = alloca (cif->nargs * sizeof (void *));\n+  UINT64 result;\n+  void *retptr;\n+  unsigned int i;\n+\n+  /* First figure out what to do about the return type.  If this is the\n+     big-structure-return case, the first arg is the hidden return buffer\n+     allocated by the caller.  */\n+  if (cif->rtype->type == FFI_TYPE_STRUCT\n+      && cif->rtype->size > 8)\n+    {\n+      retptr = *((void **) argp);\n+      argp += 4;\n+    }\n+  else\n+    retptr = (void *) &result;\n+\n+  /* Fill in the array of argument pointers.  */\n+  for (i = 0; i < cif->nargs; i++)\n+    {\n+      size_t size = cif->arg_types[i]->size;\n+      size_t alignment = cif->arg_types[i]->alignment;\n+\n+      /* Align argp as appropriate for the argument type.  */\n+      if ((alignment - 1) & (unsigned) argp)\n+\targp = (char *) ALIGN (argp, alignment);\n+\n+      /* Arguments smaller than an int are promoted to int.  */\n+      if (size < sizeof (int))\n+\tsize = sizeof (int);\n+\n+      /* Store the pointer.  */\n+      parsed_args[i] = argp;\n+      argp += size;\n+    }\n+\n+  /* Call the user-supplied function.  */\n+  (closure->fun) (cif, retptr, parsed_args, closure->user_data);\n+  return result;\n+}\n+\n+\n+/* Initialize CLOSURE with a trampoline to call FUN with\n+   CIF and USER_DATA.  */\n+ffi_status\n+ffi_prep_closure_loc (ffi_closure* closure,\n+\t\t      ffi_cif* cif,\n+\t\t      void (*fun) (ffi_cif*, void*, void**, void*),\n+\t\t      void *user_data,\n+\t\t      void *codeloc)\n+{\n+  unsigned int *tramp = (unsigned int *) &closure->tramp[0];\n+  int i;\n+\n+  if (cif->abi != FFI_SYSV)\n+    return FFI_BAD_ABI;\n+\n+  /* The trampoline looks like:\n+       movhi r8, %hi(ffi_closure_sysv)\n+       ori r8, r8, %lo(ffi_closure_sysv)\n+       movhi r9, %hi(ffi_closure_helper)\n+       ori r0, r9, %lo(ffi_closure_helper)\n+       movhi r10, %hi(closure)\n+       ori r10, r10, %lo(closure)\n+       jmp r8\n+     and then ffi_closure_sysv retrieves the closure pointer out of r10\n+     in addition to the arguments passed in the normal way for the call,\n+     and invokes ffi_closure_helper.  We encode the pointer to\n+     ffi_closure_helper in the trampoline because making a PIC call\n+     to it in ffi_closure_sysv would be messy (it would have to indirect\n+     through the GOT).  */\n+\n+#define HI(x) ((((unsigned int) (x)) >> 16) & 0xffff)\n+#define LO(x) (((unsigned int) (x)) & 0xffff)\n+  tramp[0] = (0 << 27) | (8 << 22) | (HI (ffi_closure_sysv) << 6) | 0x34;\n+  tramp[1] = (8 << 27) | (8 << 22) | (LO (ffi_closure_sysv) << 6) | 0x14;\n+  tramp[2] = (0 << 27) | (9 << 22) | (HI (ffi_closure_helper) << 6) | 0x34;\n+  tramp[3] = (9 << 27) | (9 << 22) | (LO (ffi_closure_helper) << 6) | 0x14;\n+  tramp[4] = (0 << 27) | (10 << 22) | (HI (closure) << 6) | 0x34;\n+  tramp[5] = (10 << 27) | (10 << 22) | (LO (closure) << 6) | 0x14;\n+  tramp[6] = (8 << 27) | (0x0d << 11) | 0x3a;\n+#undef HI\n+#undef LO\n+\n+  /* Flush the caches.\n+     See Example 9-4 in the Nios II Software Developer's Handbook.  */\n+  for (i = 0; i < 7; i++)\n+    asm volatile (\"flushd 0(%0); flushi %0\" :: \"r\"(tramp + i) : \"memory\");\n+  asm volatile (\"flushp\" ::: \"memory\");\n+\n+  closure->cif = cif;\n+  closure->fun = fun;\n+  closure->user_data = user_data;\n+\n+  return FFI_OK;\n+}\n+"}, {"sha": "134d118c12a2fcd95941f482d9c074b2516e7276", "filename": "libffi/src/nios2/ffitarget.h", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fnios2%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fnios2%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fnios2%2Fffitarget.h?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -0,0 +1,52 @@\n+/* libffi target includes for Altera Nios II.\n+\n+   Copyright (c) 2013 Mentor Graphics.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+   \n+   The above copyright notice and this permission notice shall be\n+   included in all copies or substantial portions of the Software.\n+   \n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n+   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n+   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */\n+\n+\n+#ifndef LIBFFI_TARGET_H\n+#define LIBFFI_TARGET_H\n+\n+#ifndef LIBFFI_H\n+#error \"Please do not include ffitarget.h directly into your source.  Use ffi.h instead.\"\n+#endif\n+\n+#ifndef LIBFFI_ASM\n+typedef unsigned long          ffi_arg;\n+typedef signed long            ffi_sarg;\n+\n+typedef enum ffi_abi {\n+  FFI_FIRST_ABI = 0,\n+  FFI_SYSV,\n+  FFI_LAST_ABI,\n+  FFI_DEFAULT_ABI = FFI_SYSV\n+} ffi_abi;\n+#endif\n+\n+/* Structures have a 4-byte alignment even if all the fields have lesser\n+   alignment requirements.  */\n+#define FFI_AGGREGATE_ALIGNMENT 4\n+\n+#define FFI_CLOSURES 1\n+#define FFI_TRAMPOLINE_SIZE 28   /* 7 instructions */\n+#define FFI_NATIVE_RAW_API 0\n+\n+#endif"}, {"sha": "75f442bbeeb9bb9d2f5b3cb40b617ecface12263", "filename": "libffi/src/nios2/sysv.S", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fnios2%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fnios2%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fnios2%2Fsysv.S?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -0,0 +1,136 @@\n+/* Low-level libffi support for Altera Nios II.\n+\n+   Copyright (c) 2013 Mentor Graphics.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+   \n+   The above copyright notice and this permission notice shall be\n+   included in all copies or substantial portions of the Software.\n+   \n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n+   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n+   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */\n+\n+/* This function is declared on the C side as \n+\n+   extern UINT64 ffi_call_sysv (void (*arghook) (char *, extended_cif *),\n+\t  \t\t        extended_cif *ecif,\n+\t\t\t\tunsigned nbytes, \n+\t\t\t\tvoid (*fn) (void));\n+\t\n+   On input, the arguments appear as\n+\tr4 = arghook\n+\tr5 = ecif\n+\tr6 = nbytes\n+\tr7 = fn\n+*/\n+\n+\t.section\t.text\n+\t.align\t2\n+\t.global\tffi_call_sysv\n+\t.type\tffi_call_sysv, @function\n+\n+ffi_call_sysv:\n+\t.cfi_startproc\n+\n+\t/* Create the stack frame, saving r16 so we can use it locally.  */\n+\taddi\tsp, sp, -12\n+\t.cfi_def_cfa_offset 12\n+\tstw\tra, 8(sp)\n+\tstw\tfp, 4(sp)\n+\tstw\tr16, 0(sp)\n+\t.cfi_offset 31, -4\n+\t.cfi_offset 28, -8\n+\t.cfi_offset 16, -12\n+\tmov\tfp, sp\n+\t.cfi_def_cfa_register 28\n+\tmov\tr16, r7\n+\n+\t/* Adjust the stack pointer to create the argument buffer\n+\t   nbytes long.  */\n+\tsub\tsp, sp, r6\n+\n+\t/* Call the arghook function.  */\n+\tmov\tr2, r4\t\t/* fn */\n+\tmov\tr4, sp\t\t/* argbuffer */\n+\tcallr\tr2\t\t/* r5 already contains ecif */\n+\n+\t/* Pop off the first 16 bytes of the argument buffer on the stack,\n+\t   transferring the contents to the argument registers.  */\n+\tldw\tr4, 0(sp)\n+\tldw\tr5, 4(sp)\n+\tldw\tr6, 8(sp)\n+\tldw\tr7, 12(sp)\n+\taddi\tsp, sp, 16\n+\n+\t/* Call the user function, which leaves its result in r2 and r3.  */\n+\tcallr\tr16\n+\n+\t/* Pop off the stack frame.  */\n+\tmov\tsp, fp\n+\tldw\tra, 8(sp)\n+\tldw\tfp, 4(sp)\n+\tldw\tr16, 0(sp)\n+\taddi\tsp, sp, 12\n+\tret\n+\t.cfi_endproc\n+\t.size\tffi_call_sysv, .-ffi_call_sysv\n+\n+\n+/* Closure trampolines jump here after putting the C helper address\n+   in r9 and the closure pointer in r10.  The user-supplied arguments\n+   to the closure are in the normal places, in r4-r7 and on the\n+   stack.  Push the register arguments on the stack too and then call the\n+   C helper function to deal with them.  */\n+   \n+\t.section\t.text\n+\t.align\t2\n+\t.global\tffi_closure_sysv\n+\t.type\tffi_closure_sysv, @function\n+\n+ffi_closure_sysv:\n+\t.cfi_startproc\n+\n+\t/* Create the stack frame, pushing the register args on the stack\n+\t   just below the stack args.  This is the same trick illustrated\n+\t   in Figure 7-3 in the Nios II Processor Reference Handbook, used\n+\t   for variable arguments and structures passed by value.  */\n+\taddi\tsp, sp, -20\n+\t.cfi_def_cfa_offset 20\n+\tstw\tra, 0(sp)\n+\t.cfi_offset 31, -20\n+\tstw\tr4, 4(sp)\n+\t.cfi_offset 4, -16\n+\tstw\tr5, 8(sp)\n+\t.cfi_offset 5, -12\n+\tstw\tr6, 12(sp)\n+\t.cfi_offset 6, -8\n+\tstw\tr7, 16(sp)\n+\t.cfi_offset 7, -4\n+\n+\t/* Call the helper.\n+\t   r4 = pointer to arguments on stack\n+\t   r5 = closure pointer (loaded in r10 by the trampoline)\n+\t   r9 = address of helper function (loaded by trampoline) */\n+\taddi\tr4, sp, 4\n+\tmov\tr5, r10\n+\tcallr\tr9\n+\t\n+\t/* Pop the stack and return.  */\n+\tldw\tra, 0(sp)\n+\taddi\tsp, sp, 20\n+\t.cfi_def_cfa_offset -20\n+\tret\n+\t.cfi_endproc\n+\t.size\tffi_closure_sysv, .-ffi_closure_sysv\n+"}, {"sha": "2bad938a29f75ccfc61f680ba0686c247254159a", "filename": "libffi/src/or1k/ffi.c", "status": "added", "additions": 328, "deletions": 0, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2For1k%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2For1k%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2For1k%2Fffi.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -0,0 +1,328 @@\n+/* -----------------------------------------------------------------------\n+   ffi.c - Copyright (c) 2014 Sebastian Macke <sebastian@macke.de>\n+\n+   OpenRISC Foreign Function Interface\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#include <ffi.h>\n+#include \"ffi_common.h\"\n+\n+/* ffi_prep_args is called by the assembly routine once stack space\n+   has been allocated for the function's arguments */\n+\n+void* ffi_prep_args(char *stack, extended_cif *ecif)\n+{\n+  char *stacktemp = stack;\n+  int i, s;\n+  ffi_type **arg;\n+  int count = 0;\n+  int nfixedargs;\n+  \n+  nfixedargs = ecif->cif->nfixedargs;\n+  arg = ecif->cif->arg_types;\n+  void **argv = ecif->avalue;\n+\n+  if (ecif->cif->rtype->type == FFI_TYPE_STRUCT)\n+    {\n+      *(void **) stack = ecif->rvalue;\n+      stack += 4;\n+      count = 4;\n+    } \n+  for(i=0; i<ecif->cif->nargs; i++)\n+  {\n+\n+    /* variadic args are saved on stack */\n+    if ((nfixedargs == 0) && (count < 24))\n+      {\n+        count = 24;\n+        stack = stacktemp + 24;        \n+      }\n+    nfixedargs--;\n+\n+    s = 4;\n+    switch((*arg)->type) \n+      {\n+      case FFI_TYPE_STRUCT:\n+        *(void **)stack = *argv;\n+        break;\n+\n+      case FFI_TYPE_SINT8:\n+        *(signed int *) stack = (signed int)*(SINT8 *)(* argv);\n+        break;\n+\n+      case FFI_TYPE_UINT8:\n+        *(unsigned int *) stack = (unsigned int)*(UINT8 *)(* argv);\n+        break;\n+\n+      case FFI_TYPE_SINT16:\n+        *(signed int *) stack = (signed int)*(SINT16 *)(* argv);\n+        break;\n+\n+      case FFI_TYPE_UINT16:\n+        *(unsigned int *) stack = (unsigned int)*(UINT16 *)(* argv);\n+        break;\n+\n+      case FFI_TYPE_SINT32:\n+      case FFI_TYPE_UINT32:\n+      case FFI_TYPE_FLOAT:\n+      case FFI_TYPE_POINTER:\n+        *(int *)stack = *(int*)(*argv);\n+        break;\n+\n+      default: /* 8 byte types */\n+        if (count == 20) /* never split arguments */\n+          {\n+            stack += 4;\n+            count += 4;\n+          }  \n+        s = (*arg)->size;\n+        memcpy(stack, *argv, s);\n+        break;\n+      }\n+\n+    stack += s;\n+    count += s;\n+    argv++;\n+    arg++;\n+  }\n+  return stacktemp + ((count>24)?24:0);\n+}\n+\n+extern void ffi_call_SYSV(unsigned,\n+                          extended_cif *,\n+                          void *(*)(int *, extended_cif *),\n+                          unsigned *,\n+                          void (*fn)(void),\n+                          unsigned);\n+\n+\n+void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n+{\n+  int i;\n+  int size;\n+  ffi_type **arg;\n+\n+  /* Calculate size to allocate on stack */\n+\n+  for(i = 0, arg = cif->arg_types, size=0; i < cif->nargs; i++, arg++)\n+    {\n+      if ((*arg)->type == FFI_TYPE_STRUCT)\n+        size += 4;\n+      else\n+      if ((*arg)->size <= 4)\n+        size += 4;\n+      else\n+        size += 8;\n+    }\n+\n+  /* for variadic functions more space is needed on the stack */\n+  if (cif->nargs != cif->nfixedargs)\n+    size += 24;\n+\n+  if (cif->rtype->type == FFI_TYPE_STRUCT)\n+    size += 4;\n+\n+\n+  extended_cif ecif;\n+  ecif.cif = cif;\n+  ecif.avalue = avalue;\n+  ecif.rvalue = rvalue;\n+\n+  switch (cif->abi) \n+  {\n+    case FFI_SYSV:\n+      ffi_call_SYSV(size, &ecif, ffi_prep_args, rvalue, fn, cif->flags);\n+      break;\n+    default:\n+      FFI_ASSERT(0);\n+      break;\n+  }\n+}\n+\n+\n+void ffi_closure_SYSV(unsigned long r3, unsigned long r4, unsigned long r5, \n+                      unsigned long r6, unsigned long r7, unsigned long r8)\n+{\n+  register int *sp __asm__ (\"r17\");\n+  register int *r13 __asm__ (\"r13\");\n+\n+  ffi_closure* closure = (ffi_closure*) r13;\n+  char *stack_args = sp;\n+\n+  /* Lay the register arguments down in a continuous chunk of memory.  */\n+  unsigned register_args[6] =\n+    { r3, r4, r5, r6, r7, r8 };\n+\n+  /* Pointer to a struct return value.  */\n+  void *struct_rvalue = (void *) r3;\n+\n+  ffi_cif *cif = closure->cif;\n+  ffi_type **arg_types = cif->arg_types;\n+  void **avalue = alloca (cif->nargs * sizeof(void *));\n+  char *ptr = (char *) register_args;\n+  int count = 0;\n+  int nfixedargs = cif->nfixedargs;\n+  int i;\n+\n+  /* preserve struct type return pointer passing */\n+\n+  if ((cif->rtype != NULL) && (cif->rtype->type == FFI_TYPE_STRUCT)) \n+  {\n+    ptr += 4;\n+    count = 4;\n+  }\n+\n+  /* Find the address of each argument.  */\n+  for (i = 0; i < cif->nargs; i++)\n+    {\n+\n+      /* variadic args are saved on stack */\n+      if ((nfixedargs == 0) && (count < 24))\n+        {\n+          ptr = stack_args;\n+          count = 24;\n+        }\n+      nfixedargs--;\n+\n+      switch (arg_types[i]->type)\n+        {\n+        case FFI_TYPE_SINT8:\n+        case FFI_TYPE_UINT8:\n+          avalue[i] = ptr + 3;\n+          break;\n+\n+        case FFI_TYPE_SINT16:\n+        case FFI_TYPE_UINT16:\n+          avalue[i] = ptr + 2;\n+          break;\n+\n+        case FFI_TYPE_SINT32:\n+        case FFI_TYPE_UINT32:\n+        case FFI_TYPE_FLOAT:\n+        case FFI_TYPE_POINTER:\n+          avalue[i] = ptr;\n+          break;\n+\n+        case FFI_TYPE_STRUCT:\n+          avalue[i] = *(void**)ptr;\n+          break;\n+\n+        default:\n+          /* 8-byte values  */\n+\n+          /* arguments are never splitted */\n+          if (ptr == &register_args[5])\n+            ptr = stack_args;\n+          avalue[i] = ptr;\n+          ptr += 4;\n+          count += 4;\n+          break;\n+        }\n+      ptr += 4;\n+      count += 4;\n+\n+      /* If we've handled more arguments than fit in registers,\n+         start looking at the those passed on the stack.  */\n+\n+      if (count == 24)\n+        ptr = stack_args;\n+    }\n+\n+  if (cif->rtype && (cif->rtype->type == FFI_TYPE_STRUCT))\n+    {\n+      (closure->fun) (cif, struct_rvalue, avalue, closure->user_data);\n+    } else\n+    {\n+      long long rvalue;\n+      (closure->fun) (cif, &rvalue, avalue, closure->user_data);\n+      if (cif->rtype)\n+        asm (\"l.ori r12, %0, 0x0\\n l.lwz r11, 0(r12)\\n l.lwz r12, 4(r12)\" : : \"r\" (&rvalue));      \n+    }\n+}\n+\n+\n+ffi_status\n+ffi_prep_closure_loc (ffi_closure* closure,\n+                      ffi_cif* cif,\n+                      void (*fun)(ffi_cif*,void*,void**,void*),\n+                      void *user_data,\n+                      void *codeloc)\n+{\n+  unsigned short *tramp = (unsigned short *) closure->tramp;\n+  unsigned long fn = (unsigned long) ffi_closure_SYSV;\n+  unsigned long cls = (unsigned long) codeloc;\n+\n+  if (cif->abi != FFI_SYSV)\n+    return FFI_BAD_ABI;\n+\n+  closure->cif = cif;\n+  closure->user_data = user_data;\n+  closure->fun = fun;\n+\n+  /* write pointers to temporary registers */\n+  tramp[0] = (0x6 << 10) | (13 << 5); /* l.movhi r13, ... */\n+  tramp[1] = cls >> 16;\n+  tramp[2] = (0x2a << 10) | (13 << 5) | 13; /* l.ori r13, r13, ... */\n+  tramp[3] = cls & 0xFFFF;\n+\n+  tramp[4] = (0x6 << 10) | (15 << 5); /* l.movhi r15, ... */\n+  tramp[5] = fn >> 16;\n+  tramp[6] = (0x2a << 10) | (15 << 5) | 15; /* l.ori r15, r15 ... */\n+  tramp[7] = fn & 0xFFFF;\n+\n+  tramp[8] = (0x11 << 10); /* l.jr r15 */\n+  tramp[9] = 15 << 11;\n+\n+  tramp[10] = (0x2a << 10) | (17 << 5) | 1; /* l.ori r17, r1, ... */\n+  tramp[11] = 0x0;\n+\n+  return FFI_OK;\n+}\n+\n+\n+ffi_status ffi_prep_cif_machdep (ffi_cif *cif)\n+{\n+  cif->flags = 0;\n+\t\n+  /* structures are returned as pointers */\n+  if (cif->rtype->type == FFI_TYPE_STRUCT)\n+    cif->flags = FFI_TYPE_STRUCT;\n+  else \n+  if (cif->rtype->size > 4)\n+    cif->flags = FFI_TYPE_UINT64;\n+\n+  cif->nfixedargs = cif->nargs;\n+\n+  return FFI_OK;\n+}\n+\n+\n+ffi_status ffi_prep_cif_machdep_var(ffi_cif *cif,\n+         unsigned int nfixedargs, unsigned int ntotalargs)\n+{\n+  ffi_status status;\n+\n+  status = ffi_prep_cif_machdep (cif);\n+  cif->nfixedargs = nfixedargs;\n+  return status;\n+} "}, {"sha": "e55da286185a108cbea2459a05b67519eee3d334", "filename": "libffi/src/or1k/ffitarget.h", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2For1k%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2For1k%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2For1k%2Fffitarget.h?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -0,0 +1,58 @@\n+/* -----------------------------------------------------------------------\n+   ffitarget.h - Copyright (c) 2014 Sebastian Macke <sebastian@macke.de>\n+\n+   OpenRISC Target configuration macros\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#ifndef LIBFFI_TARGET_H\n+#define LIBFFI_TARGET_H\n+\n+#ifndef LIBFFI_H\n+#error \"Please do not include ffitarget.h directly into your source. Use ffi.h instead.\"\n+#endif\n+\n+/* ---- System specific configurations ----------------------------------- */\n+\n+#ifndef LIBFFI_ASM\n+typedef unsigned long          ffi_arg;\n+typedef signed long            ffi_sarg;\n+\n+typedef enum ffi_abi {\n+  FFI_FIRST_ABI = 0,\n+  FFI_SYSV,\n+  FFI_LAST_ABI,\n+  FFI_DEFAULT_ABI = FFI_SYSV\n+} ffi_abi;\n+#endif\n+\n+/* ---- Definitions for closures ----------------------------------------- */\n+\n+#define FFI_CLOSURES 1\n+#define FFI_NATIVE_RAW_API 0\n+#define FFI_TRAMPOLINE_SIZE (24)\n+\n+#define FFI_TARGET_SPECIFIC_VARIADIC 1\n+#define FFI_EXTRA_CIF_FIELDS unsigned nfixedargs;\n+\n+#endif\n+"}, {"sha": "df6570ba9d3e7c90e00b2e6ae2283cb1fb12bb82", "filename": "libffi/src/or1k/sysv.S", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2For1k%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2For1k%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2For1k%2Fsysv.S?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -0,0 +1,107 @@\n+/* -----------------------------------------------------------------------\n+   sysv.S - Copyright (c) 2014 Sebastian Macke <sebastian@macke.de>\n+\n+   OpenRISC Foreign Function Interface\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#define LIBFFI_ASM\n+#include <fficonfig.h>\n+#include <ffi.h>\n+\n+.text\n+\t.globl ffi_call_SYSV\n+\t.type ffi_call_SYSV, @function\n+/*\n+  r3: size to allocate on stack\n+  r4: extended cif structure\n+  r5: function pointer ffi_prep_args\n+  r6: ret address\n+  r7: function to call\n+  r8: flag for return type\n+*/\n+\n+ffi_call_SYSV:\n+\t/* Store registers used on stack */\n+\tl.sw -4(r1), r9 /* return address */\n+\tl.sw -8(r1), r1 /* stack address */\n+\tl.sw -12(r1), r14 /* callee saved registers */\n+\tl.sw -16(r1), r16\n+\tl.sw -20(r1), r18 \n+\tl.sw -24(r1), r20\n+\n+\tl.ori r14, r1, 0x0 /* save stack pointer */\n+\tl.addi r1, r1, -24\n+\n+\tl.ori r16, r7, 0x0 /* save function address */\n+\tl.ori r18, r6, 0x0 /* save ret address */\n+\tl.ori r20, r8, 0x0 /* save flag */\n+\n+\tl.sub r1, r1, r3 /* reserve space on stack */\n+\n+\t/* Call ffi_prep_args */\n+\tl.ori r3, r1, 0x0  /* first argument stack address, second already ecif */\n+\tl.jalr r5\n+\tl.nop\n+\n+\t/* Load register arguments and call*/\n+\n+\tl.lwz r3, 0(r1)\n+\tl.lwz r4, 4(r1)\n+\tl.lwz r5, 8(r1)\n+\tl.lwz r6, 12(r1)\n+\tl.lwz r7, 16(r1)\n+\tl.lwz r8, 20(r1)\n+\tl.ori r1, r11, 0x0 /* new stack pointer */\n+\tl.jalr r16\n+\tl.nop\n+\t\n+\t/* handle return values */\n+\n+\tl.sfeqi r20, FFI_TYPE_STRUCT\n+\tl.bf ret  /* structs don't return an rvalue */\n+\tl.nop\n+\n+\t/* copy ret address */\n+\n+\tl.sfeqi r20, FFI_TYPE_UINT64\n+\tl.bnf four_byte_ret  /* 8 byte value is returned */\n+\tl.nop\n+\n+\tl.sw 4(r18), r12\n+\n+four_byte_ret:\n+\tl.sw 0(r18), r11\n+\n+ret:\n+\t/* return */\n+\tl.ori r1, r14, 0x0 /* reset stack pointer */\n+\tl.lwz r9, -4(r1)\n+\tl.lwz r1, -8(r1)\n+\tl.lwz r14, -12(r1)\n+\tl.lwz r16, -16(r1)\n+\tl.lwz r18, -20(r1)\n+\tl.lwz r20, -24(r1)\n+\tl.jr r9\n+\tl.nop\n+\n+.size ffi_call_SYSV, .-ffi_call_SYSV"}, {"sha": "fff4c6b382e54cf1d0001883db258e849a4e5440", "filename": "libffi/src/pa/ffitarget.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fpa%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fpa%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpa%2Fffitarget.h?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -62,6 +62,8 @@ typedef enum ffi_abi {\n } ffi_abi;\n #endif\n \n+#define FFI_TARGET_SPECIFIC_STACK_SPACE_ALLOCATION\n+\n /* ---- Definitions for closures ----------------------------------------- */\n \n #define FFI_CLOSURES 1"}, {"sha": "349e78c266e406f47f04c5a34e001fce54dea2ad", "filename": "libffi/src/powerpc/aix.S", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fpowerpc%2Faix.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fpowerpc%2Faix.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Faix.S?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -137,7 +137,7 @@ ffi_call_AIX:\n \tmtcrf\t0x40, r31\n \tmtctr\tr0\n \t/* Load all those argument registers.  */\n-\t// We have set up a nice stack frame, just load it into registers.\n+\t/* We have set up a nice stack frame, just load it into registers. */\n \tld\tr3, 40+(1*8)(r1)\n \tld\tr4, 40+(2*8)(r1)\n \tld\tr5, 40+(3*8)(r1)\n@@ -150,7 +150,7 @@ ffi_call_AIX:\n \n L1:\n \t/* Load all the FP registers.  */\n-\tbf\t6,L2 // 2f + 0x18\n+\tbf\t6,L2 /* 2f + 0x18 */\n \tlfd\tf1,-32-(13*8)(r28)\n \tlfd\tf2,-32-(12*8)(r28)\n \tlfd\tf3,-32-(11*8)(r28)\n@@ -239,7 +239,7 @@ L(float_return_value):\n \tmtcrf\t0x40, r31\n \tmtctr\tr0\n \t/* Load all those argument registers.  */\n-\t// We have set up a nice stack frame, just load it into registers.\n+\t/* We have set up a nice stack frame, just load it into registers. */\n \tlwz\tr3, 20+(1*4)(r1)\n \tlwz\tr4, 20+(2*4)(r1)\n \tlwz\tr5, 20+(3*4)(r1)\n@@ -252,7 +252,7 @@ L(float_return_value):\n \n L1:\n \t/* Load all the FP registers.  */\n-\tbf\t6,L2 // 2f + 0x18\n+\tbf\t6,L2 /* 2f + 0x18 */\n \tlfd\tf1,-16-(13*8)(r28)\n \tlfd\tf2,-16-(12*8)(r28)\n \tlfd\tf3,-16-(11*8)(r28)\n@@ -307,7 +307,7 @@ L(float_return_value):\n #endif\n \t.long 0\n \t.byte 0,0,0,1,128,4,0,0\n-//END(ffi_call_AIX)\n+/* END(ffi_call_AIX) */\n \n .csect .text[PR]\n \t.align 2\n@@ -325,4 +325,4 @@ ffi_call_DARWIN:\n \tblr\n \t.long 0\n \t.byte 0,0,0,0,0,0,0,0\n-//END(ffi_call_DARWIN)\n+/* END(ffi_call_DARWIN) */"}, {"sha": "066eb82efe9381fd2b2e0af37582ac453ebba27c", "filename": "libffi/src/powerpc/darwin.S", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fpowerpc%2Fdarwin.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fpowerpc%2Fdarwin.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fdarwin.S?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -318,11 +318,6 @@ _ffi_call_AIX:\n \n #define EH_DATA_ALIGN_FACT MODE_CHOICE(0x7c,0x78)\n \n-\t.static_data\n-\t.align LOG2_GPR_BYTES\n-LLFB0$non_lazy_ptr:\n-\t.g_long Lstartcode\n-\n \t.section __TEXT,__eh_frame,coalesced,no_toc+strip_static_syms+live_support\n EH_frame1:\n \t.set\tL$set$0,LECIE1-LSCIE1\n@@ -335,7 +330,7 @@ LSCIE1:\n \t.byte\tEH_DATA_ALIGN_FACT ; sleb128 -4; CIE Data Alignment Factor\n \t.byte\t0x41\t; CIE RA Column\n \t.byte\t0x1\t; uleb128 0x1; Augmentation size\n-\t.byte\t0x10\t; FDE Encoding (indirect pcrel)\n+\t.byte\t0x10\t; FDE Encoding (pcrel)\n \t.byte\t0xc\t; DW_CFA_def_cfa\n \t.byte\t0x1\t; uleb128 0x1\n \t.byte\t0x0\t; uleb128 0x0\n@@ -349,7 +344,7 @@ LSFDE1:\n \t.long\tL$set$1\t; FDE Length\n LASFDE1:\n \t.long\tLASFDE1-EH_frame1 ; FDE CIE offset\n-\t.g_long\tLLFB0$non_lazy_ptr-.\t; FDE initial location\n+\t.g_long\tLstartcode-.\t; FDE initial location\n \t.set\tL$set$3,LFE1-Lstartcode\n \t.g_long\tL$set$3\t; FDE address range\n \t.byte   0x0     ; uleb128 0x0; Augmentation size"}, {"sha": "c7734d419861064e39336c457d4046d32b2adf83", "filename": "libffi/src/powerpc/darwin_closure.S", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fpowerpc%2Fdarwin_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fpowerpc%2Fdarwin_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fdarwin_closure.S?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -192,7 +192,7 @@ LCFI1:\n \tlg\tr0,0(r3)\t\t; size => r0\n \tlhz\tr3,FFI_TYPE_TYPE(r3)\t; type => r3\n \n-\t/* The helper will have intercepted struture returns and inserted\n+\t/* The helper will have intercepted structure returns and inserted\n \t   the caller`s destination address for structs returned by ref.  */\n \n \t/* r3 contains the return type  so use it to look up in a table\n@@ -467,11 +467,6 @@ Lendcode:\n #define EH_FRAME_OFFSETA MODE_CHOICE(176,0x90)\n #define EH_FRAME_OFFSETB MODE_CHOICE(1,3)\n \n-\t.static_data\n-\t.align LOG2_GPR_BYTES\n-LLFB1$non_lazy_ptr:\n-\t.g_long Lstartcode\n-\n \t.section __TEXT,__eh_frame,coalesced,no_toc+strip_static_syms+live_support\n EH_frame1:\n \t.set\tL$set$0,LECIE1-LSCIE1\n@@ -484,7 +479,7 @@ LSCIE1:\n \t.byte\tEH_DATA_ALIGN_FACT ; sleb128 -4; CIE Data Alignment Factor\n \t.byte\t0x41\t; CIE RA Column\n \t.byte\t0x1\t; uleb128 0x1; Augmentation size\n-\t.byte\t0x10\t; FDE Encoding (indirect pcrel)\n+\t.byte\t0x10\t; FDE Encoding (pcrel)\n \t.byte\t0xc\t; DW_CFA_def_cfa\n \t.byte\t0x1\t; uleb128 0x1\n \t.byte\t0x0\t; uleb128 0x0\n@@ -498,7 +493,7 @@ LSFDE1:\n \n LASFDE1:\n \t.long\tLASFDE1-EH_frame1\t; FDE CIE offset\n-\t.g_long\tLLFB1$non_lazy_ptr-.\t; FDE initial location\n+\t.g_long\tLstartcode-.\t; FDE initial location\n \t.set\tL$set$3,LFE1-Lstartcode\n \t.g_long\tL$set$3\t; FDE address range\n \t.byte   0x0     ; uleb128 0x0; Augmentation size\n@@ -523,12 +518,12 @@ LEFDE1:\n L_ffi_closure_helper_DARWIN$stub:\n \t.indirect_symbol _ffi_closure_helper_DARWIN\n \tmflr r0\n-\tbcl 20,31,\"L00000000001$spb\"\n-\"L00000000001$spb\":\n+\tbcl 20,31,\"L1$spb\"\n+\"L1$spb\":\n \tmflr r11\n-\taddis r11,r11,ha16(L_ffi_closure_helper_DARWIN$lazy_ptr-\"L00000000001$spb\")\n+\taddis r11,r11,ha16(L_ffi_closure_helper_DARWIN$lazy_ptr-\"L1$spb\")\n \tmtlr r0\n-\tlwzu r12,lo16(L_ffi_closure_helper_DARWIN$lazy_ptr-\"L00000000001$spb\")(r11)\n+\tlwzu r12,lo16(L_ffi_closure_helper_DARWIN$lazy_ptr-\"L1$spb\")(r11)\n \tmtctr r12\n \tbctr\n \t.lazy_symbol_pointer\n@@ -542,12 +537,12 @@ L_ffi_closure_helper_DARWIN$lazy_ptr:\n L_darwin64_struct_ret_by_value_p$stub:\n \t.indirect_symbol _darwin64_struct_ret_by_value_p\n \tmflr r0\n-\tbcl 20,31,\"L00000000002$spb\"\n-\"L00000000002$spb\":\n+\tbcl 20,31,\"L2$spb\"\n+\"L2$spb\":\n \tmflr r11\n-\taddis r11,r11,ha16(L_darwin64_struct_ret_by_value_p$lazy_ptr-\"L00000000002$spb\")\n+\taddis r11,r11,ha16(L_darwin64_struct_ret_by_value_p$lazy_ptr-\"L2$spb\")\n \tmtlr r0\n-\tlwzu r12,lo16(L_darwin64_struct_ret_by_value_p$lazy_ptr-\"L00000000002$spb\")(r11)\n+\tlwzu r12,lo16(L_darwin64_struct_ret_by_value_p$lazy_ptr-\"L2$spb\")(r11)\n \tmtctr r12\n \tbctr\n \t.lazy_symbol_pointer\n@@ -560,12 +555,12 @@ L_darwin64_struct_ret_by_value_p$lazy_ptr:\n L_darwin64_pass_struct_floats$stub:\n \t.indirect_symbol _darwin64_pass_struct_floats\n \tmflr r0\n-\tbcl 20,31,\"L00000000003$spb\"\n-\"L00000000003$spb\":\n+\tbcl 20,31,\"L3$spb\"\n+\"L3$spb\":\n \tmflr r11\n-\taddis r11,r11,ha16(L_darwin64_pass_struct_floats$lazy_ptr-\"L00000000003$spb\")\n+\taddis r11,r11,ha16(L_darwin64_pass_struct_floats$lazy_ptr-\"L3$spb\")\n \tmtlr r0\n-\tlwzu r12,lo16(L_darwin64_pass_struct_floats$lazy_ptr-\"L00000000003$spb\")(r11)\n+\tlwzu r12,lo16(L_darwin64_pass_struct_floats$lazy_ptr-\"L3$spb\")(r11)\n \tmtctr r12\n \tbctr\n \t.lazy_symbol_pointer"}, {"sha": "7eb543e4b3b78976579d0dfa9c907944e2826ad8", "filename": "libffi/src/powerpc/ffi.c", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fpowerpc%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fpowerpc%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -70,8 +70,12 @@ ffi_prep_cif_machdep_var (ffi_cif *cif,\n #endif\n }\n \n-void\n-ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n+static void\n+ffi_call_int (ffi_cif *cif,\n+\t      void (*fn) (void),\n+\t      void *rvalue,\n+\t      void **avalue,\n+\t      void *closure)\n {\n   /* The final SYSV ABI says that structures smaller or equal 8 bytes\n      are returned in r3/r4.  A draft ABI used by linux instead returns\n@@ -97,9 +101,10 @@ ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n     ecif.rvalue = alloca (cif->rtype->size);\n \n #ifdef POWERPC64\n-  ffi_call_LINUX64 (&ecif, -(long) cif->bytes, cif->flags, ecif.rvalue, fn);\n+  ffi_call_LINUX64 (&ecif, fn, ecif.rvalue, cif->flags, closure,\n+\t\t    -(long) cif->bytes);\n #else\n-  ffi_call_SYSV (&ecif, -cif->bytes, cif->flags, ecif.rvalue, fn);\n+  ffi_call_SYSV (&ecif, fn, ecif.rvalue, cif->flags, closure, -cif->bytes);\n #endif\n \n   /* Check for a bounce-buffered return value */\n@@ -125,6 +130,18 @@ ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n     }\n }\n \n+void\n+ffi_call (ffi_cif *cif, void (*fn) (void), void *rvalue, void **avalue)\n+{\n+  ffi_call_int (cif, fn, rvalue, avalue, NULL);\n+}\n+\n+void\n+ffi_call_go (ffi_cif *cif, void (*fn) (void), void *rvalue, void **avalue,\n+\t     void *closure)\n+{\n+  ffi_call_int (cif, fn, rvalue, avalue, closure);\n+}\n \n ffi_status\n ffi_prep_closure_loc (ffi_closure *closure,\n@@ -139,3 +156,18 @@ ffi_prep_closure_loc (ffi_closure *closure,\n   return ffi_prep_closure_loc_sysv (closure, cif, fun, user_data, codeloc);\n #endif\n }\n+\n+ffi_status\n+ffi_prep_go_closure (ffi_go_closure *closure,\n+\t\t     ffi_cif *cif,\n+\t\t     void (*fun) (ffi_cif *, void *, void **, void *))\n+{\n+#ifdef POWERPC64\n+  closure->tramp = ffi_go_closure_linux64;\n+#else\n+  closure->tramp = ffi_go_closure_sysv;\n+#endif\n+  closure->cif = cif;\n+  closure->fun = fun;\n+  return FFI_OK;\n+}"}, {"sha": "cf6fb6d4b7ca024af84d25f66c82740229b0ac42", "filename": "libffi/src/powerpc/ffi_darwin.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -302,10 +302,10 @@ ffi_prep_args (extended_cif *ecif, unsigned long *const stack)\n     }\n \n   /* Check that we didn't overrun the stack...  */\n-  //FFI_ASSERT(gpr_base <= stacktop - ASM_NEEDS_REGISTERS);\n-  //FFI_ASSERT((unsigned *)fpr_base\n-  //\t     <= stacktop - ASM_NEEDS_REGISTERS - NUM_GPR_ARG_REGISTERS);\n-  //FFI_ASSERT(flags & FLAG_4_GPR_ARGUMENTS || intarg_count <= 4);\n+  /* FFI_ASSERT(gpr_base <= stacktop - ASM_NEEDS_REGISTERS);\n+     FFI_ASSERT((unsigned *)fpr_base\n+     \t     <= stacktop - ASM_NEEDS_REGISTERS - NUM_GPR_ARG_REGISTERS);\n+     FFI_ASSERT(flags & FLAG_4_GPR_ARGUMENTS || intarg_count <= 4);  */\n }\n \n #if defined(POWERPC_DARWIN64)\n@@ -593,7 +593,7 @@ darwin_adjust_aggregate_sizes (ffi_type *s)\n       /* Natural alignment for all items.  */\n       align = p->alignment;\n #else\n-      /* Natrual alignment for the first item... */\n+      /* Natural alignment for the first item... */\n       if (i == 0)\n \talign = p->alignment;\n       else if (p->alignment == 16 || p->alignment < 4)"}, {"sha": "b84b91fb237d1f2fa3cfd12c2612174d4394ac5c", "filename": "libffi/src/powerpc/ffi_linux64.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fpowerpc%2Fffi_linux64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fpowerpc%2Fffi_linux64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi_linux64.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -667,7 +667,8 @@ flush_icache (char *wraddr, char *xaddr, int size)\n }\n #endif\n \n-ffi_status\n+\n+ffi_status FFI_HIDDEN\n ffi_prep_closure_loc_linux64 (ffi_closure *closure,\n \t\t\t      ffi_cif *cif,\n \t\t\t      void (*fun) (ffi_cif *, void *, void **, void *),\n@@ -688,16 +689,17 @@ ffi_prep_closure_loc_linux64 (ffi_closure *closure,\n \t\t\t\t/* 2:\t.quad\tcontext\t\t*/\n   *(void **) &tramp[4] = (void *) ffi_closure_LINUX64;\n   *(void **) &tramp[6] = codeloc;\n-  flush_icache ((char *)tramp, (char *)codeloc, FFI_TRAMPOLINE_SIZE);\n+  flush_icache ((char *) tramp, (char *) codeloc, 4 * 4);\n #else\n   void **tramp = (void **) &closure->tramp[0];\n \n   if (cif->abi < FFI_LINUX || cif->abi >= FFI_LAST_ABI)\n     return FFI_BAD_ABI;\n \n-  /* Copy function address and TOC from ffi_closure_LINUX64.  */\n-  memcpy (tramp, (char *) ffi_closure_LINUX64, 16);\n-  tramp[2] = codeloc;\n+  /* Copy function address and TOC from ffi_closure_LINUX64 OPD.  */\n+  memcpy (&tramp[0], (void **) ffi_closure_LINUX64, sizeof (void *));\n+  tramp[1] = codeloc;\n+  memcpy (&tramp[2], (void **) ffi_closure_LINUX64 + 1, sizeof (void *));\n #endif\n \n   closure->cif = cif;\n@@ -709,8 +711,12 @@ ffi_prep_closure_loc_linux64 (ffi_closure *closure,\n \n \n int FFI_HIDDEN\n-ffi_closure_helper_LINUX64 (ffi_closure *closure, void *rvalue,\n-\t\t\t    unsigned long *pst, ffi_dblfl *pfr)\n+ffi_closure_helper_LINUX64 (ffi_cif *cif,\n+\t\t\t    void (*fun) (ffi_cif *, void *, void **, void *),\n+\t\t\t    void *user_data,\n+\t\t\t    void *rvalue,\n+\t\t\t    unsigned long *pst,\n+\t\t\t    ffi_dblfl *pfr)\n {\n   /* rvalue is the pointer to space for return value in closure assembly */\n   /* pst is the pointer to parameter save area\n@@ -720,11 +726,9 @@ ffi_closure_helper_LINUX64 (ffi_closure *closure, void *rvalue,\n   void **avalue;\n   ffi_type **arg_types;\n   unsigned long i, avn, nfixedargs;\n-  ffi_cif *cif;\n   ffi_dblfl *end_pfr = pfr + NUM_FPR_ARG_REGISTERS64;\n   unsigned long align;\n \n-  cif = closure->cif;\n   avalue = alloca (cif->nargs * sizeof (void *));\n \n   /* Copy the caller's structure return value address so that the\n@@ -924,8 +928,7 @@ ffi_closure_helper_LINUX64 (ffi_closure *closure, void *rvalue,\n       i++;\n     }\n \n-\n-  (closure->fun) (cif, rvalue, avalue, closure->user_data);\n+  (*fun) (cif, rvalue, avalue, user_data);\n \n   /* Tell ffi_closure_LINUX64 how to perform return type promotions.  */\n   if ((cif->flags & FLAG_RETURNS_SMST) != 0)"}, {"sha": "3dcd6b57175dd36af3047c220e193362d6001658", "filename": "libffi/src/powerpc/ffi_powerpc.h", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fpowerpc%2Fffi_powerpc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fpowerpc%2Fffi_powerpc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi_powerpc.h?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -56,22 +56,39 @@ typedef union\n } ffi_dblfl;\n \n void FFI_HIDDEN ffi_closure_SYSV (void);\n-void FFI_HIDDEN ffi_call_SYSV(extended_cif *, unsigned, unsigned, unsigned *,\n-\t\t\t      void (*)(void));\n+void FFI_HIDDEN ffi_go_closure_sysv (void);\n+void FFI_HIDDEN ffi_call_SYSV(extended_cif *, void (*)(void), void *,\n+\t\t\t      unsigned, void *, int);\n \n void FFI_HIDDEN ffi_prep_types_sysv (ffi_abi);\n ffi_status FFI_HIDDEN ffi_prep_cif_sysv (ffi_cif *);\n-int FFI_HIDDEN ffi_closure_helper_SYSV (ffi_closure *, void *, unsigned long *,\n+ffi_status FFI_HIDDEN ffi_prep_closure_loc_sysv (ffi_closure *,\n+\t\t\t\t\t\t ffi_cif *,\n+\t\t\t\t\t\t void (*) (ffi_cif *, void *,\n+\t\t\t\t\t\t\t   void **, void *),\n+\t\t\t\t\t\t void *, void *);\n+int FFI_HIDDEN ffi_closure_helper_SYSV (ffi_cif *,\n+\t\t\t\t\tvoid (*) (ffi_cif *, void *,\n+\t\t\t\t\t\t  void **, void *),\n+\t\t\t\t\tvoid *, void *, unsigned long *,\n \t\t\t\t\tffi_dblfl *, unsigned long *);\n \n-void FFI_HIDDEN ffi_call_LINUX64(extended_cif *, unsigned long, unsigned long,\n-\t\t\t\t unsigned long *, void (*)(void));\n+void FFI_HIDDEN ffi_call_LINUX64(extended_cif *, void (*) (void), void *,\n+\t\t\t\t unsigned long, void *, long);\n void FFI_HIDDEN ffi_closure_LINUX64 (void);\n+void FFI_HIDDEN ffi_go_closure_linux64 (void);\n \n void FFI_HIDDEN ffi_prep_types_linux64 (ffi_abi);\n ffi_status FFI_HIDDEN ffi_prep_cif_linux64 (ffi_cif *);\n ffi_status FFI_HIDDEN ffi_prep_cif_linux64_var (ffi_cif *, unsigned int,\n \t\t\t\t\t\tunsigned int);\n void FFI_HIDDEN ffi_prep_args64 (extended_cif *, unsigned long *const);\n-int FFI_HIDDEN ffi_closure_helper_LINUX64 (ffi_closure *, void *,\n+ffi_status FFI_HIDDEN ffi_prep_closure_loc_linux64 (ffi_closure *, ffi_cif *,\n+\t\t\t\t\t\t    void (*) (ffi_cif *, void *,\n+\t\t\t\t\t\t\t      void **, void *),\n+\t\t\t\t\t\t    void *, void *);\n+int FFI_HIDDEN ffi_closure_helper_LINUX64 (ffi_cif *,\n+\t\t\t\t\t   void (*) (ffi_cif *, void *,\n+\t\t\t\t\t\t     void **, void *),\n+\t\t\t\t\t   void *, void *,\n \t\t\t\t\t   unsigned long *, ffi_dblfl *);"}, {"sha": "646c340d5ad93da41ca1b5a9c8235ee94277b6cb", "filename": "libffi/src/powerpc/ffi_sysv.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fpowerpc%2Fffi_sysv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fpowerpc%2Fffi_sysv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi_sysv.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -36,7 +36,7 @@\n \n \n /* About the SYSV ABI.  */\n-#define ASM_NEEDS_REGISTERS 4\n+#define ASM_NEEDS_REGISTERS 6\n #define NUM_GPR_ARG_REGISTERS 8\n #define NUM_FPR_ARG_REGISTERS 8\n \n@@ -654,18 +654,18 @@ ffi_prep_closure_loc_sysv (ffi_closure *closure,\n \n   tramp = (unsigned int *) &closure->tramp[0];\n   tramp[0] = 0x7c0802a6;  /*   mflr    r0 */\n-  tramp[1] = 0x4800000d;  /*   bl      10 <trampoline_initial+0x10> */\n-  tramp[4] = 0x7d6802a6;  /*   mflr    r11 */\n-  tramp[5] = 0x7c0803a6;  /*   mtlr    r0 */\n-  tramp[6] = 0x800b0000;  /*   lwz     r0,0(r11) */\n-  tramp[7] = 0x816b0004;  /*   lwz     r11,4(r11) */\n-  tramp[8] = 0x7c0903a6;  /*   mtctr   r0 */\n-  tramp[9] = 0x4e800420;  /*   bctr */\n-  *(void **) &tramp[2] = (void *) ffi_closure_SYSV; /* function */\n-  *(void **) &tramp[3] = codeloc;                   /* context */\n+  tramp[1] = 0x429f0005;  /*   bcl     20,31,.+4 */\n+  tramp[2] = 0x7d6802a6;  /*   mflr    r11 */\n+  tramp[3] = 0x7c0803a6;  /*   mtlr    r0 */\n+  tramp[4] = 0x800b0018;  /*   lwz     r0,24(r11) */\n+  tramp[5] = 0x816b001c;  /*   lwz     r11,28(r11) */\n+  tramp[6] = 0x7c0903a6;  /*   mtctr   r0 */\n+  tramp[7] = 0x4e800420;  /*   bctr */\n+  *(void **) &tramp[8] = (void *) ffi_closure_SYSV; /* function */\n+  *(void **) &tramp[9] = codeloc;                   /* context */\n \n   /* Flush the icache.  */\n-  flush_icache ((char *)tramp, (char *)codeloc, FFI_TRAMPOLINE_SIZE);\n+  flush_icache ((char *)tramp, (char *)codeloc, 8 * 4);\n \n   closure->cif = cif;\n   closure->fun = fun;\n@@ -682,8 +682,12 @@ ffi_prep_closure_loc_sysv (ffi_closure *closure,\n    following helper function to do most of the work.  */\n \n int\n-ffi_closure_helper_SYSV (ffi_closure *closure, void *rvalue,\n-\t\t\t unsigned long *pgr, ffi_dblfl *pfr,\n+ffi_closure_helper_SYSV (ffi_cif *cif,\n+\t\t\t void (*fun) (ffi_cif *, void *, void **, void *),\n+\t\t\t void *user_data,\n+\t\t\t void *rvalue,\n+\t\t\t unsigned long *pgr,\n+\t\t\t ffi_dblfl *pfr,\n \t\t\t unsigned long *pst)\n {\n   /* rvalue is the pointer to space for return value in closure assembly */\n@@ -699,7 +703,6 @@ ffi_closure_helper_SYSV (ffi_closure *closure, void *rvalue,\n #endif\n   long             ng = 0;   /* number of general registers already used */\n \n-  ffi_cif *cif = closure->cif;\n   unsigned       size     = cif->rtype->size;\n   unsigned short rtypenum = cif->rtype->type;\n \n@@ -915,7 +918,7 @@ ffi_closure_helper_SYSV (ffi_closure *closure, void *rvalue,\n     i++;\n   }\n \n-  (closure->fun) (cif, rvalue, avalue, closure->user_data);\n+  (*fun) (cif, rvalue, avalue, user_data);\n \n   /* Tell ffi_closure_SYSV how to perform return type promotions.\n      Because the FFI_SYSV ABI returns the structures <= 8 bytes in"}, {"sha": "0f66d319c778da653aca29a5db34e94e9d81e6ba", "filename": "libffi/src/powerpc/ffitarget.h", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -138,23 +138,35 @@ typedef enum ffi_abi {\n #define FFI_CLOSURES 1\n #define FFI_NATIVE_RAW_API 0\n #if defined (POWERPC) || defined (POWERPC_FREEBSD)\n+# define FFI_GO_CLOSURES 1\n # define FFI_TARGET_SPECIFIC_VARIADIC 1\n # define FFI_EXTRA_CIF_FIELDS unsigned nfixedargs\n #endif\n \n-/* For additional types like the below, take care about the order in\n-   ppc_closures.S. They must follow after the FFI_TYPE_LAST.  */\n+/* ppc_closure.S and linux64_closure.S expect this.  */\n+#define FFI_PPC_TYPE_LAST FFI_TYPE_POINTER\n+\n+/* We define additional types below.  If generic types are added that\n+   must be supported by powerpc libffi then it is likely that\n+   FFI_PPC_TYPE_LAST needs increasing *and* the jump tables in\n+   ppc_closure.S and linux64_closure.S be extended.  */\n+\n+#if !(FFI_TYPE_LAST == FFI_PPC_TYPE_LAST\t\t\\\n+      || (FFI_TYPE_LAST == FFI_TYPE_COMPLEX\t\t\\\n+\t  && !defined FFI_TARGET_HAS_COMPLEX_TYPE))\n+# error \"You likely have a broken powerpc libffi\"\n+#endif\n \n /* Needed for soft-float long-double-128 support.  */\n-#define FFI_TYPE_UINT128 (FFI_TYPE_LAST + 1)\n+#define FFI_TYPE_UINT128 (FFI_PPC_TYPE_LAST + 1)\n \n /* Needed for FFI_SYSV small structure returns.  */\n-#define FFI_SYSV_TYPE_SMALL_STRUCT (FFI_TYPE_LAST + 2)\n+#define FFI_SYSV_TYPE_SMALL_STRUCT (FFI_PPC_TYPE_LAST + 2)\n \n /* Used by ELFv2 for homogenous structure returns.  */\n-#define FFI_V2_TYPE_FLOAT_HOMOG\t\t(FFI_TYPE_LAST + 1)\n-#define FFI_V2_TYPE_DOUBLE_HOMOG\t(FFI_TYPE_LAST + 2)\n-#define FFI_V2_TYPE_SMALL_STRUCT\t(FFI_TYPE_LAST + 3)\n+#define FFI_V2_TYPE_FLOAT_HOMOG\t\t(FFI_PPC_TYPE_LAST + 1)\n+#define FFI_V2_TYPE_DOUBLE_HOMOG\t(FFI_PPC_TYPE_LAST + 2)\n+#define FFI_V2_TYPE_SMALL_STRUCT\t(FFI_PPC_TYPE_LAST + 3)\n \n #if _CALL_ELF == 2\n # define FFI_TRAMPOLINE_SIZE 32"}, {"sha": "b2ae60ead6e13b309fd547d6bb84c37518769e06", "filename": "libffi/src/powerpc/linux64.S", "status": "modified", "additions": 20, "deletions": 53, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fpowerpc%2Flinux64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fpowerpc%2Flinux64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Flinux64.S?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -32,8 +32,9 @@\n #ifdef POWERPC64\n \t.hidden\tffi_call_LINUX64\n \t.globl\tffi_call_LINUX64\n-# if _CALL_ELF == 2\n \t.text\n+\t.cfi_startproc\n+# if _CALL_ELF == 2\n ffi_call_LINUX64:\n \taddis\t%r2, %r12, .TOC.-ffi_call_LINUX64@ha\n \taddi\t%r2, %r2, .TOC.-ffi_call_LINUX64@l\n@@ -57,20 +58,26 @@ ffi_call_LINUX64:\n .ffi_call_LINUX64:\n #  endif\n # endif\n-.LFB1:\n \tmflr\t%r0\n \tstd\t%r28, -32(%r1)\n \tstd\t%r29, -24(%r1)\n \tstd\t%r30, -16(%r1)\n \tstd\t%r31, -8(%r1)\n+\tstd\t%r7, 8(%r1)\t/* closure, saved in cr field.  */\n \tstd\t%r0, 16(%r1)\n \n \tmr\t%r28, %r1\t/* our AP.  */\n-.LCFI0:\n-\tstdux\t%r1, %r1, %r4\n-\tmr\t%r31, %r5\t/* flags, */\n-\tmr\t%r30, %r6\t/* rvalue, */\n-\tmr\t%r29, %r7\t/* function address.  */\n+\t.cfi_def_cfa_register 28\n+\t.cfi_offset 65, 16\n+\t.cfi_offset 31, -8\n+\t.cfi_offset 30, -16\n+\t.cfi_offset 29, -24\n+\t.cfi_offset 28, -32\n+\n+\tstdux\t%r1, %r1, %r8\n+\tmr\t%r31, %r6\t/* flags, */\n+\tmr\t%r30, %r5\t/* rvalue, */\n+\tmr\t%r29, %r4\t/* function address.  */\n /* Save toc pointer, not for the ffi_prep_args64 call, but for the later\n    bctrl function call.  */\n # if _CALL_ELF == 2\n@@ -92,7 +99,6 @@ ffi_call_LINUX64:\n # else\n \tld\t%r12, 0(%r29)\n \tld\t%r2, 8(%r29)\n-\tld\t%r11, 16(%r29)\n # endif\n \t/* Now do the call.  */\n \t/* Set up cr1 with bits 4-7 of the flags.  */\n@@ -130,6 +136,7 @@ ffi_call_LINUX64:\n 2:\n \n \t/* Make the call.  */\n+\tld\t%r11, 8(%r28)\n \tbctrl\n \n \t/* This must follow the call immediately, the unwinder\n@@ -151,6 +158,7 @@ ffi_call_LINUX64:\n .Ldone_return_value:\n \t/* Restore the registers we used and return.  */\n \tmr\t%r1, %r28\n+\t.cfi_def_cfa_register 1\n \tld\t%r0, 16(%r28)\n \tld\t%r28, -32(%r28)\n \tmtlr\t%r0\n@@ -160,6 +168,7 @@ ffi_call_LINUX64:\n \tblr\n \n .Lfp_return_value:\n+\t.cfi_def_cfa_register 28\n \tbf\t28, .Lfloat_return_value\n \tstfd\t%f1, 0(%r30)\n \tmtcrf\t0x02, %r31 /* cr6  */\n@@ -199,61 +208,19 @@ ffi_call_LINUX64:\n \tstd\t%r4, 8(%r30)\n \tb\t.Ldone_return_value\n \n-.LFE1:\n-\t.long\t0\n-\t.byte\t0,12,0,1,128,4,0,0\n+\t.cfi_endproc\n # if _CALL_ELF == 2\n \t.size\tffi_call_LINUX64,.-ffi_call_LINUX64\n # else\n #  ifdef _CALL_LINUX\n \t.size\tffi_call_LINUX64,.-.L.ffi_call_LINUX64\n #  else\n+\t.long\t0\n+\t.byte\t0,12,0,1,128,4,0,0\n \t.size\t.ffi_call_LINUX64,.-.ffi_call_LINUX64\n #  endif\n # endif\n \n-\t.section\t.eh_frame,EH_FRAME_FLAGS,@progbits\n-.Lframe1:\n-\t.4byte\t.LECIE1-.LSCIE1\t # Length of Common Information Entry\n-.LSCIE1:\n-\t.4byte\t0x0\t # CIE Identifier Tag\n-\t.byte\t0x1\t # CIE Version\n-\t.ascii \"zR\\0\"\t # CIE Augmentation\n-\t.uleb128 0x1\t # CIE Code Alignment Factor\n-\t.sleb128 -8\t # CIE Data Alignment Factor\n-\t.byte\t0x41\t # CIE RA Column\n-\t.uleb128 0x1\t # Augmentation size\n-\t.byte\t0x14\t # FDE Encoding (pcrel udata8)\n-\t.byte\t0xc\t # DW_CFA_def_cfa\n-\t.uleb128 0x1\n-\t.uleb128 0x0\n-\t.align 3\n-.LECIE1:\n-.LSFDE1:\n-\t.4byte\t.LEFDE1-.LASFDE1\t # FDE Length\n-.LASFDE1:\n-\t.4byte\t.LASFDE1-.Lframe1\t # FDE CIE offset\n-\t.8byte\t.LFB1-.\t # FDE initial location\n-\t.8byte\t.LFE1-.LFB1\t # FDE address range\n-\t.uleb128 0x0\t # Augmentation size\n-\t.byte\t0x2\t # DW_CFA_advance_loc1\n-\t.byte\t.LCFI0-.LFB1\n-\t.byte\t0xd\t # DW_CFA_def_cfa_register\n-\t.uleb128 0x1c\n-\t.byte\t0x11\t # DW_CFA_offset_extended_sf\n-\t.uleb128 0x41\n-\t.sleb128 -2\n-\t.byte\t0x9f\t # DW_CFA_offset, column 0x1f\n-\t.uleb128 0x1\n-\t.byte\t0x9e\t # DW_CFA_offset, column 0x1e\n-\t.uleb128 0x2\n-\t.byte\t0x9d\t # DW_CFA_offset, column 0x1d\n-\t.uleb128 0x3\n-\t.byte\t0x9c\t # DW_CFA_offset, column 0x1c\n-\t.uleb128 0x4\n-\t.align 3\n-.LEFDE1:\n-\n #endif\n \n #if (defined __ELF__ && defined __linux__) || _CALL_ELF == 2"}, {"sha": "6487d2a2970a11a6d71d8b2759a0b490d194ba87", "filename": "libffi/src/powerpc/linux64_closure.S", "status": "modified", "additions": 151, "deletions": 51, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fpowerpc%2Flinux64_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fpowerpc%2Flinux64_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Flinux64_closure.S?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -33,8 +33,9 @@\n #ifdef POWERPC64\n \tFFI_HIDDEN (ffi_closure_LINUX64)\n \t.globl  ffi_closure_LINUX64\n-# if _CALL_ELF == 2\n \t.text\n+\t.cfi_startproc\n+# if _CALL_ELF == 2\n ffi_closure_LINUX64:\n \taddis\t%r2, %r12, .TOC.-ffi_closure_LINUX64@ha\n \taddi\t%r2, %r2, .TOC.-ffi_closure_LINUX64@l\n@@ -73,20 +74,18 @@ ffi_closure_LINUX64:\n #  define RETVAL PARMSAVE+64\n # endif\n \n-.LFB1:\n # if _CALL_ELF == 2\n \tld\t%r12, FFI_TRAMPOLINE_SIZE(%r11)\t\t# closure->cif\n \tmflr\t%r0\n \tlwz\t%r12, 28(%r12)\t\t\t\t# cif->flags\n \tmtcrf\t0x40, %r12\n \taddi\t%r12, %r1, PARMSAVE\n-\tbt\t7, .Lparmsave\n+\tbt\t7, 0f\n \t# Our caller has not allocated a parameter save area.\n \t# We need to allocate one here and use it to pass gprs to\n \t# ffi_closure_helper_LINUX64.\n \taddi\t%r12, %r1, -STACKFRAME+PARMSAVE\n-.Lparmsave:\n-\tstd\t%r0, 16(%r1)\n+0:\n \t# Save general regs into parm save area\n \tstd\t%r3, 0(%r12)\n \tstd\t%r4, 8(%r12)\n@@ -98,8 +97,12 @@ ffi_closure_LINUX64:\n \tstd\t%r10, 56(%r12)\n \n \t# load up the pointer to the parm save area\n-\tmr\t%r5, %r12\n+\tmr\t%r7, %r12\n # else\n+\t# copy r2 to r11 and load TOC into r2\n+\tmr\t%r11, %r2\n+\tld\t%r2, 16(%r2)\n+\n \tmflr\t%r0\n \t# Save general regs into parm save area\n \t# This is the parameter save area set up by our caller.\n@@ -112,12 +115,19 @@ ffi_closure_LINUX64:\n \tstd\t%r9, PARMSAVE+48(%r1)\n \tstd\t%r10, PARMSAVE+56(%r1)\n \n-\tstd\t%r0, 16(%r1)\n-\n \t# load up the pointer to the parm save area\n-\taddi\t%r5, %r1, PARMSAVE\n+\taddi\t%r7, %r1, PARMSAVE\n # endif\n+\tstd\t%r0, 16(%r1)\n \n+\t# closure->cif\n+\tld\t%r3, FFI_TRAMPOLINE_SIZE(%r11)\n+\t# closure->fun\n+\tld\t%r4, FFI_TRAMPOLINE_SIZE+8(%r11)\n+\t# closure->user_data\n+\tld\t%r5, FFI_TRAMPOLINE_SIZE+16(%r11)\n+\n+.Ldoclosure:\n \t# next save fpr 1 to fpr 13\n \tstfd\t%f1, -104+(0*8)(%r1)\n \tstfd\t%f2, -104+(1*8)(%r1)\n@@ -134,16 +144,14 @@ ffi_closure_LINUX64:\n \tstfd\t%f13, -104+(12*8)(%r1)\n \n \t# load up the pointer to the saved fpr registers */\n-\taddi\t%r6, %r1, -104\n+\taddi\t%r8, %r1, -104\n \n \t# load up the pointer to the result storage\n-\taddi\t%r4, %r1, -STACKFRAME+RETVAL\n+\taddi\t%r6, %r1, -STACKFRAME+RETVAL\n \n \tstdu\t%r1, -STACKFRAME(%r1)\n-.LCFI0:\n-\n-\t# get the context pointer from the trampoline\n-\tmr\t%r3, %r11\n+\t.cfi_def_cfa_offset STACKFRAME\n+\t.cfi_offset 65, 16\n \n \t# make the call\n # if defined _CALL_LINUX || _CALL_ELF == 2\n@@ -178,7 +186,9 @@ ffi_closure_LINUX64:\n # case FFI_TYPE_VOID\n \tmtlr %r0\n \taddi %r1, %r1, STACKFRAME\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset STACKFRAME\n \tnop\n # case FFI_TYPE_INT\n # ifdef __LITTLE_ENDIAN__\n@@ -188,17 +198,23 @@ ffi_closure_LINUX64:\n # endif\n \tmtlr %r0\n \taddi %r1, %r1, STACKFRAME\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset STACKFRAME\n # case FFI_TYPE_FLOAT\n \tlfs %f1, RETVAL+0(%r1)\n \tmtlr %r0\n \taddi %r1, %r1, STACKFRAME\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset STACKFRAME\n # case FFI_TYPE_DOUBLE\n \tlfd %f1, RETVAL+0(%r1)\n \tmtlr %r0\n \taddi %r1, %r1, STACKFRAME\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset STACKFRAME\n # case FFI_TYPE_LONGDOUBLE\n \tlfd %f1, RETVAL+0(%r1)\n \tmtlr %r0\n@@ -212,7 +228,9 @@ ffi_closure_LINUX64:\n # endif\n \tmtlr %r0\n \taddi %r1, %r1, STACKFRAME\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset STACKFRAME\n # case FFI_TYPE_SINT8\n # ifdef __LITTLE_ENDIAN__\n \tlbz %r3, RETVAL+0(%r1)\n@@ -231,7 +249,9 @@ ffi_closure_LINUX64:\n \tmtlr %r0\n .Lfinish:\n \taddi %r1, %r1, STACKFRAME\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset STACKFRAME\n # case FFI_TYPE_SINT16\n # ifdef __LITTLE_ENDIAN__\n \tlha %r3, RETVAL+0(%r1)\n@@ -240,7 +260,9 @@ ffi_closure_LINUX64:\n # endif\n \tmtlr %r0\n \taddi %r1, %r1, STACKFRAME\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset STACKFRAME\n # case FFI_TYPE_UINT32\n # ifdef __LITTLE_ENDIAN__\n \tlwz %r3, RETVAL+0(%r1)\n@@ -249,7 +271,9 @@ ffi_closure_LINUX64:\n # endif\n \tmtlr %r0\n \taddi %r1, %r1, STACKFRAME\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset STACKFRAME\n # case FFI_TYPE_SINT32\n # ifdef __LITTLE_ENDIAN__\n \tlwa %r3, RETVAL+0(%r1)\n@@ -258,27 +282,37 @@ ffi_closure_LINUX64:\n # endif\n \tmtlr %r0\n \taddi %r1, %r1, STACKFRAME\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset STACKFRAME\n # case FFI_TYPE_UINT64\n \tld %r3, RETVAL+0(%r1)\n \tmtlr %r0\n \taddi %r1, %r1, STACKFRAME\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset STACKFRAME\n # case FFI_TYPE_SINT64\n \tld %r3, RETVAL+0(%r1)\n \tmtlr %r0\n \taddi %r1, %r1, STACKFRAME\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset STACKFRAME\n # case FFI_TYPE_STRUCT\n \tmtlr %r0\n \taddi %r1, %r1, STACKFRAME\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset STACKFRAME\n \tnop\n # case FFI_TYPE_POINTER\n \tld %r3, RETVAL+0(%r1)\n \tmtlr %r0\n \taddi %r1, %r1, STACKFRAME\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset STACKFRAME\n # case FFI_V2_TYPE_FLOAT_HOMOG\n \tlfs %f1, RETVAL+0(%r1)\n \tlfs %f2, RETVAL+4(%r1)\n@@ -295,7 +329,9 @@ ffi_closure_LINUX64:\n \tlfd %f7, RETVAL+48(%r1)\n \tlfd %f8, RETVAL+56(%r1)\n \taddi %r1, %r1, STACKFRAME\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset STACKFRAME\n .Lmorefloat:\n \tlfs %f4, RETVAL+12(%r1)\n \tmtlr %r0\n@@ -304,13 +340,16 @@ ffi_closure_LINUX64:\n \tlfs %f7, RETVAL+24(%r1)\n \tlfs %f8, RETVAL+28(%r1)\n \taddi %r1, %r1, STACKFRAME\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset STACKFRAME\n .Lsmall:\n # ifdef __LITTLE_ENDIAN__\n \tld %r3,RETVAL+0(%r1)\n \tmtlr %r0\n \tld %r4,RETVAL+8(%r1)\n \taddi %r1, %r1, STACKFRAME\n+\t.cfi_def_cfa_offset 0\n \tblr\n # else\n \t# A struct smaller than a dword is returned in the low bits of r3\n@@ -324,63 +363,124 @@ ffi_closure_LINUX64:\n \tmtlr %r0\n \tld %r4,RETVAL+8(%r1)\n \taddi %r1, %r1, STACKFRAME\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset STACKFRAME\n .Lsmalldown:\n \taddi %r5, %r5, FFI_V2_TYPE_SMALL_STRUCT + 7\n \tmtlr %r0\n \tsldi %r5, %r5, 3\n \taddi %r1, %r1, STACKFRAME\n+\t.cfi_def_cfa_offset 0\n \tsrd %r3, %r3, %r5\n \tblr\n # endif\n \n-.LFE1:\n-\t.long\t0\n-\t.byte\t0,12,0,1,128,0,0,0\n+\t.cfi_endproc\n # if _CALL_ELF == 2\n \t.size\tffi_closure_LINUX64,.-ffi_closure_LINUX64\n # else\n #  ifdef _CALL_LINUX\n \t.size\tffi_closure_LINUX64,.-.L.ffi_closure_LINUX64\n #  else\n+\t.long\t0\n+\t.byte\t0,12,0,1,128,0,0,0\n \t.size\t.ffi_closure_LINUX64,.-.ffi_closure_LINUX64\n #  endif\n # endif\n \n-\t.section\t.eh_frame,EH_FRAME_FLAGS,@progbits\n-.Lframe1:\n-\t.4byte\t.LECIE1-.LSCIE1\t # Length of Common Information Entry\n-.LSCIE1:\n-\t.4byte\t0x0\t # CIE Identifier Tag\n-\t.byte\t0x1\t # CIE Version\n-\t.ascii \"zR\\0\"\t # CIE Augmentation\n-\t.uleb128 0x1\t # CIE Code Alignment Factor\n-\t.sleb128 -8\t # CIE Data Alignment Factor\n-\t.byte\t0x41\t # CIE RA Column\n-\t.uleb128 0x1\t # Augmentation size\n-\t.byte\t0x14\t # FDE Encoding (pcrel udata8)\n-\t.byte\t0xc\t # DW_CFA_def_cfa\n-\t.uleb128 0x1\n-\t.uleb128 0x0\n-\t.align 3\n-.LECIE1:\n-.LSFDE1:\n-\t.4byte\t.LEFDE1-.LASFDE1\t # FDE Length\n-.LASFDE1:\n-\t.4byte\t.LASFDE1-.Lframe1\t # FDE CIE offset\n-\t.8byte\t.LFB1-.\t # FDE initial location\n-\t.8byte\t.LFE1-.LFB1\t # FDE address range\n-\t.uleb128 0x0\t # Augmentation size\n-\t.byte\t0x2\t # DW_CFA_advance_loc1\n-\t.byte\t.LCFI0-.LFB1\n-\t.byte\t0xe\t # DW_CFA_def_cfa_offset\n-\t.uleb128 STACKFRAME\n-\t.byte\t0x11\t # DW_CFA_offset_extended_sf\n-\t.uleb128 0x41\n-\t.sleb128 -2\n-\t.align 3\n-.LEFDE1:\n \n+\tFFI_HIDDEN (ffi_go_closure_linux64)\n+\t.globl  ffi_go_closure_linux64\n+\t.text\n+\t.cfi_startproc\n+# if _CALL_ELF == 2\n+ffi_go_closure_linux64:\n+\taddis\t%r2, %r12, .TOC.-ffi_go_closure_linux64@ha\n+\taddi\t%r2, %r2, .TOC.-ffi_go_closure_linux64@l\n+\t.localentry ffi_go_closure_linux64, . - ffi_go_closure_linux64\n+# else\n+\t.section        \".opd\",\"aw\"\n+\t.align  3\n+ffi_go_closure_linux64:\n+#  ifdef _CALL_LINUX\n+\t.quad   .L.ffi_go_closure_linux64,.TOC.@tocbase,0\n+\t.type   ffi_go_closure_linux64,@function\n+\t.text\n+.L.ffi_go_closure_linux64:\n+#  else\n+\tFFI_HIDDEN (.ffi_go_closure_linux64)\n+\t.globl  .ffi_go_closure_linux64\n+\t.quad   .ffi_go_closure_linux64,.TOC.@tocbase,0\n+\t.size   ffi_go_closure_linux64,24\n+\t.type   .ffi_go_closure_linux64,@function\n+\t.text\n+.ffi_go_closure_linux64:\n+#  endif\n+# endif\n+\n+# if _CALL_ELF == 2\n+\tld\t%r12, 8(%r11)\t\t\t\t# closure->cif\n+\tmflr\t%r0\n+\tlwz\t%r12, 28(%r12)\t\t\t\t# cif->flags\n+\tmtcrf\t0x40, %r12\n+\taddi\t%r12, %r1, PARMSAVE\n+\tbt\t7, 0f\n+\t# Our caller has not allocated a parameter save area.\n+\t# We need to allocate one here and use it to pass gprs to\n+\t# ffi_closure_helper_LINUX64.\n+\taddi\t%r12, %r1, -STACKFRAME+PARMSAVE\n+0:\n+\t# Save general regs into parm save area\n+\tstd\t%r3, 0(%r12)\n+\tstd\t%r4, 8(%r12)\n+\tstd\t%r5, 16(%r12)\n+\tstd\t%r6, 24(%r12)\n+\tstd\t%r7, 32(%r12)\n+\tstd\t%r8, 40(%r12)\n+\tstd\t%r9, 48(%r12)\n+\tstd\t%r10, 56(%r12)\n+\n+\t# load up the pointer to the parm save area\n+\tmr\t%r7, %r12\n+# else\n+\tmflr\t%r0\n+\t# Save general regs into parm save area\n+\t# This is the parameter save area set up by our caller.\n+\tstd\t%r3, PARMSAVE+0(%r1)\n+\tstd\t%r4, PARMSAVE+8(%r1)\n+\tstd\t%r5, PARMSAVE+16(%r1)\n+\tstd\t%r6, PARMSAVE+24(%r1)\n+\tstd\t%r7, PARMSAVE+32(%r1)\n+\tstd\t%r8, PARMSAVE+40(%r1)\n+\tstd\t%r9, PARMSAVE+48(%r1)\n+\tstd\t%r10, PARMSAVE+56(%r1)\n+\n+\t# load up the pointer to the parm save area\n+\taddi\t%r7, %r1, PARMSAVE\n+# endif\n+\tstd\t%r0, 16(%r1)\n+\n+\t# closure->cif\n+\tld\t%r3, 8(%r11)\n+\t# closure->fun\n+\tld\t%r4, 16(%r11)\n+\t# user_data\n+\tmr\t%r5, %r11\n+\tb\t.Ldoclosure\n+\n+\t.cfi_endproc\n+# if _CALL_ELF == 2\n+\t.size\tffi_go_closure_linux64,.-ffi_go_closure_linux64\n+# else\n+#  ifdef _CALL_LINUX\n+\t.size\tffi_go_closure_linux64,.-.L.ffi_go_closure_linux64\n+#  else\n+\t.long\t0\n+\t.byte\t0,12,0,1,128,0,0,0\n+\t.size\t.ffi_go_closure_linux64,.-.ffi_go_closure_linux64\n+#  endif\n+# endif\n #endif\n \n #if (defined __ELF__ && defined __linux__) || _CALL_ELF == 2"}, {"sha": "b6d209de8635c59f06767ac7f1da083816ceea76", "filename": "libffi/src/powerpc/ppc_closure.S", "status": "modified", "additions": 89, "deletions": 76, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fpowerpc%2Fppc_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fpowerpc%2Fppc_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fppc_closure.S?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -33,13 +33,14 @@\n \n #ifndef POWERPC64\n \n+FFI_HIDDEN(ffi_closure_SYSV)\n ENTRY(ffi_closure_SYSV)\n-.LFB1:\n+\t.cfi_startproc\n \tstwu %r1,-144(%r1)\n-.LCFI0:\n+\t.cfi_def_cfa_offset 144\n \tmflr %r0\n-.LCFI1:\n \tstw %r0,148(%r1)\n+\t.cfi_offset 65, 4\n \n # we want to build up an areas for the parameters passed\n # in registers (both floating point and integer)\n@@ -48,6 +49,17 @@ ENTRY(ffi_closure_SYSV)\n \tstw   %r3, 16(%r1)\n \tstw   %r4, 20(%r1)\n \tstw   %r5, 24(%r1)\n+\n+\t# set up registers for the routine that does the work\n+\n+\t# closure->cif\n+\tlwz %r3,FFI_TRAMPOLINE_SIZE(%r11)\n+\t# closure->fun\n+\tlwz %r4,FFI_TRAMPOLINE_SIZE+4(%r11)\n+\t# closure->user_data\n+\tlwz %r5,FFI_TRAMPOLINE_SIZE+8(%r11)\n+\n+.Ldoclosure:\n \tstw   %r6, 28(%r1)\n \tstw   %r7, 32(%r1)\n \tstw   %r8, 36(%r1)\n@@ -66,23 +78,18 @@ ENTRY(ffi_closure_SYSV)\n \tstfd  %f8, 104(%r1)\n #endif\n \n-\t# set up registers for the routine that actually does the work\n-\t# get the context pointer from the trampoline\n-\tmr %r3,%r11\n+\t# pointer to the result storage\n+\taddi %r6,%r1,112\n \n-\t# now load up the pointer to the result storage\n-\taddi %r4,%r1,112\n+\t# pointer to the saved gpr registers\n+\taddi %r7,%r1,16\n \n-\t# now load up the pointer to the saved gpr registers\n-\taddi %r5,%r1,16\n+\t# pointer to the saved fpr registers\n+\taddi %r8,%r1,48\n \n-\t# now load up the pointer to the saved fpr registers */\n-\taddi %r6,%r1,48\n-\n-\t# now load up the pointer to the outgoing parameter\n-\t# stack in the previous frame\n+\t# pointer to the outgoing parameter save area in the previous frame\n \t# i.e. the previous frame pointer + 8\n-\taddi %r7,%r1,152\n+\taddi %r9,%r1,152\n \n \t# make the call\n \tbl ffi_closure_helper_SYSV@local\n@@ -101,7 +108,6 @@ ENTRY(ffi_closure_SYSV)\n \tadd %r3,%r3,%r4\t\t# add contents of table to table address\n \tmtctr %r3\n \tbctr\t\t\t# jump to it\n-.LFE1:\n \n # Each of the ret_typeX code fragments has to be exactly 16 bytes long\n # (4 instructions). For cache effectiveness we align to a 16 byte boundary\n@@ -111,39 +117,43 @@ ENTRY(ffi_closure_SYSV)\n .Lret_type0:\n \tmtlr %r0\n \taddi %r1,%r1,144\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset 144\n \tnop\n \n # case FFI_TYPE_INT\n \tlwz %r3,112+0(%r1)\n \tmtlr %r0\n .Lfinish:\n \taddi %r1,%r1,144\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset 144\n \n # case FFI_TYPE_FLOAT\n #ifndef __NO_FPRS__\n \tlfs %f1,112+0(%r1)\n-\tmtlr %r0\n-\taddi %r1,%r1,144\n #else\n \tnop\n-\tnop\n-\tnop\n #endif\n+\tmtlr %r0\n+\taddi %r1,%r1,144\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset 144\n \n # case FFI_TYPE_DOUBLE\n #ifndef __NO_FPRS__\n \tlfd %f1,112+0(%r1)\n-\tmtlr %r0\n-\taddi %r1,%r1,144\n #else\n \tnop\n-\tnop\n-\tnop\n #endif\n+\tmtlr %r0\n+\taddi %r1,%r1,144\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset 144\n \n # case FFI_TYPE_LONGDOUBLE\n #ifndef __NO_FPRS__\n@@ -152,10 +162,12 @@ ENTRY(ffi_closure_SYSV)\n \tmtlr %r0\n \tb .Lfinish\n #else\n-\tnop\n-\tnop\n-\tnop\n+\tmtlr %r0\n+\taddi %r1,%r1,144\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset 144\n+\tnop\n #endif\n \n # case FFI_TYPE_UINT8\n@@ -166,7 +178,9 @@ ENTRY(ffi_closure_SYSV)\n #endif\n \tmtlr %r0\n \taddi %r1,%r1,144\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset 144\n \n # case FFI_TYPE_SINT8\n #ifdef __LITTLE_ENDIAN__\n@@ -186,7 +200,9 @@ ENTRY(ffi_closure_SYSV)\n #endif\n \tmtlr %r0\n \taddi %r1,%r1,144\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset 144\n \n # case FFI_TYPE_SINT16\n #ifdef __LITTLE_ENDIAN__\n@@ -196,19 +212,25 @@ ENTRY(ffi_closure_SYSV)\n #endif\n \tmtlr %r0\n \taddi %r1,%r1,144\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset 144\n \n # case FFI_TYPE_UINT32\n \tlwz %r3,112+0(%r1)\n \tmtlr %r0\n \taddi %r1,%r1,144\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset 144\n \n # case FFI_TYPE_SINT32\n \tlwz %r3,112+0(%r1)\n \tmtlr %r0\n \taddi %r1,%r1,144\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset 144\n \n # case FFI_TYPE_UINT64\n \tlwz %r3,112+0(%r1)\n@@ -225,14 +247,18 @@ ENTRY(ffi_closure_SYSV)\n # case FFI_TYPE_STRUCT\n \tmtlr %r0\n \taddi %r1,%r1,144\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset 144\n \tnop\n \n # case FFI_TYPE_POINTER\n \tlwz %r3,112+0(%r1)\n \tmtlr %r0\n \taddi %r1,%r1,144\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset 144\n \n # case FFI_TYPE_UINT128\n \tlwz %r3,112+0(%r1)\n@@ -245,20 +271,26 @@ ENTRY(ffi_closure_SYSV)\n \tlbz %r3,112+0(%r1)\n \tmtlr %r0\n \taddi %r1,%r1,144\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset 144\n \n # case FFI_SYSV_TYPE_SMALL_STRUCT + 2. Two byte struct.\n \tlhz %r3,112+0(%r1)\n \tmtlr %r0\n \taddi %r1,%r1,144\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset 144\n \n # case FFI_SYSV_TYPE_SMALL_STRUCT + 3. Three byte struct.\n \tlwz %r3,112+0(%r1)\n #ifdef __LITTLE_ENDIAN__\n \tmtlr %r0\n \taddi %r1,%r1,144\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset 144\n #else\n \tsrwi %r3,%r3,8\n \tmtlr %r0\n@@ -269,7 +301,9 @@ ENTRY(ffi_closure_SYSV)\n \tlwz %r3,112+0(%r1)\n \tmtlr %r0\n \taddi %r1,%r1,144\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset 144\n \n # case FFI_SYSV_TYPE_SMALL_STRUCT + 5. Five byte struct.\n \tlwz %r3,112+0(%r1)\n@@ -319,64 +353,43 @@ ENTRY(ffi_closure_SYSV)\n \tor %r4,%r6,%r4\n \tmtlr %r0\n \taddi %r1,%r1,144\n+\t.cfi_def_cfa_offset 0\n \tblr\n+\t.cfi_def_cfa_offset 144\n #endif\n \n .Luint128:\n \tlwz %r6,112+12(%r1)\n \tmtlr %r0\n \taddi %r1,%r1,144\n+\t.cfi_def_cfa_offset 0\n \tblr\n-\n+\t.cfi_endproc\n END(ffi_closure_SYSV)\n \n-\t.section\t\".eh_frame\",EH_FRAME_FLAGS,@progbits\n-.Lframe1:\n-\t.4byte\t.LECIE1-.LSCIE1\t # Length of Common Information Entry\n-.LSCIE1:\n-\t.4byte\t0x0\t # CIE Identifier Tag\n-\t.byte\t0x1\t # CIE Version\n-#if defined _RELOCATABLE || defined __PIC__\n-\t.ascii \"zR\\0\"\t # CIE Augmentation\n-#else\n-\t.ascii \"\\0\"\t # CIE Augmentation\n-#endif\n-\t.uleb128 0x1\t # CIE Code Alignment Factor\n-\t.sleb128 -4\t # CIE Data Alignment Factor\n-\t.byte\t0x41\t # CIE RA Column\n-#if defined _RELOCATABLE || defined __PIC__\n-\t.uleb128 0x1\t # Augmentation size\n-\t.byte\t0x1b\t # FDE Encoding (pcrel sdata4)\n-#endif\n-\t.byte\t0xc\t # DW_CFA_def_cfa\n-\t.uleb128 0x1\n-\t.uleb128 0x0\n-\t.align 2\n-.LECIE1:\n-.LSFDE1:\n-\t.4byte\t.LEFDE1-.LASFDE1\t # FDE Length\n-.LASFDE1:\n-\t.4byte\t.LASFDE1-.Lframe1\t # FDE CIE offset\n-#if defined _RELOCATABLE || defined __PIC__\n-\t.4byte\t.LFB1-.\t # FDE initial location\n-#else\n-\t.4byte\t.LFB1\t # FDE initial location\n-#endif\n-\t.4byte\t.LFE1-.LFB1\t # FDE address range\n-#if defined _RELOCATABLE || defined __PIC__\n-\t.uleb128 0x0\t # Augmentation size\n-#endif\n-\t.byte\t0x4\t # DW_CFA_advance_loc4\n-\t.4byte\t.LCFI0-.LFB1\n-\t.byte\t0xe\t # DW_CFA_def_cfa_offset\n-\t.uleb128 144\n-\t.byte\t0x4\t # DW_CFA_advance_loc4\n-\t.4byte\t.LCFI1-.LCFI0\n-\t.byte\t0x11\t # DW_CFA_offset_extended_sf\n-\t.uleb128 0x41\n-\t.sleb128 -1\n-\t.align 2\n-.LEFDE1:\n+\n+FFI_HIDDEN(ffi_go_closure_sysv)\n+ENTRY(ffi_go_closure_sysv)\n+\t.cfi_startproc\n+\tstwu %r1,-144(%r1)\n+\t.cfi_def_cfa_offset 144\n+\tmflr %r0\n+\tstw %r0,148(%r1)\n+\t.cfi_offset 65, 4\n+\n+\tstw   %r3, 16(%r1)\n+\tstw   %r4, 20(%r1)\n+\tstw   %r5, 24(%r1)\n+\n+\t# closure->cif\n+\tlwz %r3,4(%r11)\n+\t# closure->fun\n+\tlwz %r4,8(%r11)\n+\t# user_data\n+\tmr %r5,%r11\n+\tb .Ldoclosure\n+\t.cfi_endproc\n+END(ffi_go_closure_sysv)\n \n #if defined __ELF__ && defined __linux__\n \t.section\t.note.GNU-stack,\"\",@progbits"}, {"sha": "1474ce702b388e19f67890111a0a6ede27330669", "filename": "libffi/src/powerpc/sysv.S", "status": "modified", "additions": 52, "deletions": 97, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fpowerpc%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fpowerpc%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fsysv.S?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -31,34 +31,35 @@\n #include <powerpc/asm.h>\n \n #ifndef POWERPC64\n-\t.globl ffi_prep_args_SYSV\n+FFI_HIDDEN(ffi_call_SYSV)\n ENTRY(ffi_call_SYSV)\n-.LFB1:\n+\t.cfi_startproc\n \t/* Save the old stack pointer as AP.  */\n-\tmr\t%r8,%r1\n+\tmr\t%r10,%r1\n+\t.cfi_def_cfa_register 10\n \n-.LCFI0:\n \t/* Allocate the stack space we need.  */\n-\tstwux\t%r1,%r1,%r4\n+\tstwux\t%r1,%r1,%r8\n \t/* Save registers we use.  */\n \tmflr\t%r9\n-\tstw\t%r28,-16(%r8)\n-.LCFI1:\n-\tstw\t%r29,-12(%r8)\n-.LCFI2:\n-\tstw\t%r30, -8(%r8)\n-.LCFI3:\n-\tstw\t%r31, -4(%r8)\n-.LCFI4:\n-\tstw\t%r9,   4(%r8)\n-.LCFI5:\n+\tstw\t%r28,-16(%r10)\n+\tstw\t%r29,-12(%r10)\n+\tstw\t%r30, -8(%r10)\n+\tstw\t%r31, -4(%r10)\n+\tstw\t%r9,   4(%r10)\n+\t.cfi_offset 65, 4\n+\t.cfi_offset 31, -4\n+\t.cfi_offset 30, -8\n+\t.cfi_offset 29, -12\n+\t.cfi_offset 28, -16\n \n \t/* Save arguments over call...  */\n-\tmr\t%r31,%r5\t/* flags, */\n-\tmr\t%r30,%r6\t/* rvalue, */\n-\tmr\t%r29,%r7\t/* function address, */\n-\tmr\t%r28,%r8\t/* our AP. */\n-.LCFI6:\n+\tstw\t%r7,   -20(%r10)\t/* closure, */\n+\tmr\t%r31,%r6\t\t/* flags, */\n+\tmr\t%r30,%r5\t\t/* rvalue, */\n+\tmr\t%r29,%r4\t\t/* function address, */\n+\tmr\t%r28,%r10\t\t/* our AP. */\n+\t.cfi_def_cfa_register 28\n \n \t/* Call ffi_prep_args_SYSV.  */\n \tmr\t%r4,%r1\n@@ -70,35 +71,36 @@ ENTRY(ffi_call_SYSV)\n \t/* Get the address to call into CTR.  */\n \tmtctr\t%r29\n \t/* Load all those argument registers.  */\n-\tlwz\t%r3,-16-(8*4)(%r28)\n-\tlwz\t%r4,-16-(7*4)(%r28)\n-\tlwz\t%r5,-16-(6*4)(%r28)\n-\tlwz\t%r6,-16-(5*4)(%r28)\n+\tlwz\t%r3,-24-(8*4)(%r28)\n+\tlwz\t%r4,-24-(7*4)(%r28)\n+\tlwz\t%r5,-24-(6*4)(%r28)\n+\tlwz\t%r6,-24-(5*4)(%r28)\n \tbf-\t5,1f\n \tnop\n-\tlwz\t%r7,-16-(4*4)(%r28)\n-\tlwz\t%r8,-16-(3*4)(%r28)\n-\tlwz\t%r9,-16-(2*4)(%r28)\n-\tlwz\t%r10,-16-(1*4)(%r28)\n+\tlwz\t%r7,-24-(4*4)(%r28)\n+\tlwz\t%r8,-24-(3*4)(%r28)\n+\tlwz\t%r9,-24-(2*4)(%r28)\n+\tlwz\t%r10,-24-(1*4)(%r28)\n \tnop\n 1:\n \n #ifndef __NO_FPRS__\n \t/* Load all the FP registers.  */\n \tbf-\t6,2f\n-\tlfd\t%f1,-16-(8*4)-(8*8)(%r28)\n-\tlfd\t%f2,-16-(8*4)-(7*8)(%r28)\n-\tlfd\t%f3,-16-(8*4)-(6*8)(%r28)\n-\tlfd\t%f4,-16-(8*4)-(5*8)(%r28)\n+\tlfd\t%f1,-24-(8*4)-(8*8)(%r28)\n+\tlfd\t%f2,-24-(8*4)-(7*8)(%r28)\n+\tlfd\t%f3,-24-(8*4)-(6*8)(%r28)\n+\tlfd\t%f4,-24-(8*4)-(5*8)(%r28)\n \tnop\n-\tlfd\t%f5,-16-(8*4)-(4*8)(%r28)\n-\tlfd\t%f6,-16-(8*4)-(3*8)(%r28)\n-\tlfd\t%f7,-16-(8*4)-(2*8)(%r28)\n-\tlfd\t%f8,-16-(8*4)-(1*8)(%r28)\n+\tlfd\t%f5,-24-(8*4)-(4*8)(%r28)\n+\tlfd\t%f6,-24-(8*4)-(3*8)(%r28)\n+\tlfd\t%f7,-24-(8*4)-(2*8)(%r28)\n+\tlfd\t%f8,-24-(8*4)-(1*8)(%r28)\n #endif\n 2:\n \n \t/* Make the call.  */\n+\tlwz\t%r11, -20(%r28)\n \tbctrl\n \n \t/* Now, deal with the return value.  */\n@@ -125,11 +127,24 @@ L(done_return_value):\n \tlwz\t%r30, -8(%r28)\n \tlwz\t%r29,-12(%r28)\n \tlwz\t%r28,-16(%r28)\n+\t.cfi_remember_state\n+\t/* At this point we don't have a cfa register.  Say all our\n+\t   saved regs have been restored.  */\n+\t.cfi_same_value 65\n+\t.cfi_same_value 31\n+\t.cfi_same_value 30\n+\t.cfi_same_value 29\n+\t.cfi_same_value 28\n+\t/* Hopefully this works..  */\n+\t.cfi_def_cfa_register 1\n+\t.cfi_offset 1, 0\n \tlwz\t%r1,0(%r1)\n+\t.cfi_same_value 1\n \tblr\n \n #ifndef __NO_FPRS__\n L(fp_return_value):\n+\t.cfi_restore_state\n \tbf\t28,L(float_return_value)\n \tstfd\t%f1,0(%r30)\n \tmtcrf   0x02,%r31 /* cr6  */\n@@ -150,70 +165,10 @@ L(small_struct_return_value):\n \tstw %r3, 0(%r30)\n \tstw %r4, 4(%r30)\n \tb L(done_return_value)\n+\t.cfi_endproc\n \n-.LFE1:\n END(ffi_call_SYSV)\n \n-      .section\t\".eh_frame\",EH_FRAME_FLAGS,@progbits\n-.Lframe1:\n-      .4byte    .LECIE1-.LSCIE1  /*  Length of Common Information Entry */\n-.LSCIE1:\n-      .4byte    0x0      /*  CIE Identifier Tag */\n-      .byte     0x1      /*  CIE Version */\n-#if defined _RELOCATABLE || defined __PIC__\n-      .ascii\t\"zR\\0\"   /*  CIE Augmentation */\n-#else\n-      .ascii\t\"\\0\"\t /*  CIE Augmentation */\n-#endif\n-      .uleb128  0x1      /*  CIE Code Alignment Factor */\n-      .sleb128  -4\t /*  CIE Data Alignment Factor */\n-      .byte     0x41     /*  CIE RA Column */\n-#if defined _RELOCATABLE || defined __PIC__\n-      .uleb128  0x1      /*  Augmentation size */\n-      .byte\t0x1b\t /*  FDE Encoding (pcrel sdata4) */\n-#endif\n-      .byte     0xc      /*  DW_CFA_def_cfa */\n-      .uleb128  0x1\n-      .uleb128  0x0\n-      .align 2\n-.LECIE1:\n-.LSFDE1:\n-      .4byte    .LEFDE1-.LASFDE1         /*  FDE Length */\n-.LASFDE1:\n-      .4byte    .LASFDE1-.Lframe1         /*  FDE CIE offset */\n-#if defined _RELOCATABLE || defined __PIC__\n-      .4byte    .LFB1-.  /*  FDE initial location */\n-#else\n-      .4byte    .LFB1    /*  FDE initial location */\n-#endif\n-      .4byte    .LFE1-.LFB1      /*  FDE address range */\n-#if defined _RELOCATABLE || defined __PIC__\n-      .uleb128  0x0\t /*  Augmentation size */\n-#endif\n-      .byte     0x4      /*  DW_CFA_advance_loc4 */\n-      .4byte    .LCFI0-.LFB1\n-      .byte     0xd      /*  DW_CFA_def_cfa_register */\n-      .uleb128  0x08\n-      .byte     0x4      /*  DW_CFA_advance_loc4 */\n-      .4byte    .LCFI5-.LCFI0\n-      .byte     0x11     /*  DW_CFA_offset_extended_sf */\n-      .uleb128  0x41\n-      .sleb128  -1\n-      .byte     0x9f     /*  DW_CFA_offset, column 0x1f */\n-      .uleb128  0x1\n-      .byte     0x9e     /*  DW_CFA_offset, column 0x1e */\n-      .uleb128  0x2\n-      .byte     0x9d     /*  DW_CFA_offset, column 0x1d */\n-      .uleb128  0x3\n-      .byte     0x9c     /*  DW_CFA_offset, column 0x1c */\n-      .uleb128  0x4\n-      .byte     0x4      /*  DW_CFA_advance_loc4 */\n-      .4byte    .LCFI6-.LCFI5\n-      .byte     0xd      /*  DW_CFA_def_cfa_register */\n-      .uleb128  0x1c\n-      .align 2\n-.LEFDE1:\n-\n #if defined __ELF__ && defined __linux__\n \t.section\t.note.GNU-stack,\"\",@progbits\n #endif"}, {"sha": "5881cebd784c2bcf4c59a6ed822d84e1733b5610", "filename": "libffi/src/prep_cif.c", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fprep_cif.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fprep_cif.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fprep_cif.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -76,6 +76,13 @@ static ffi_status initialize_aggregate(ffi_type *arg)\n      total size of 3*sizeof(long).  */\n   arg->size = ALIGN (arg->size, arg->alignment);\n \n+  /* On some targets, the ABI defines that structures have an additional\n+     alignment beyond the \"natural\" one based on their elements.  */\n+#ifdef FFI_AGGREGATE_ALIGNMENT\n+  if (FFI_AGGREGATE_ALIGNMENT > arg->alignment)\n+    arg->alignment = FFI_AGGREGATE_ALIGNMENT;\n+#endif\n+\n   if (arg->size == 0)\n     return FFI_BAD_TYPEDEF;\n   else\n@@ -111,13 +118,8 @@ ffi_status FFI_HIDDEN ffi_prep_cif_core(ffi_cif *cif, ffi_abi abi,\n   FFI_ASSERT((!isvariadic) || (nfixedargs >= 1));\n   FFI_ASSERT(nfixedargs <= ntotalargs);\n \n-#ifndef X86_WIN32\n   if (! (abi > FFI_FIRST_ABI && abi < FFI_LAST_ABI))\n     return FFI_BAD_ABI;\n-#else\n-  if (! (abi > FFI_FIRST_ABI && abi < FFI_LAST_ABI || abi == FFI_THISCALL))\n-    return FFI_BAD_ABI;\n-#endif\n \n   cif->abi = abi;\n   cif->arg_types = atypes;\n@@ -134,18 +136,25 @@ ffi_status FFI_HIDDEN ffi_prep_cif_core(ffi_cif *cif, ffi_abi abi,\n   if ((cif->rtype->size == 0) && (initialize_aggregate(cif->rtype) != FFI_OK))\n     return FFI_BAD_TYPEDEF;\n \n+#ifndef FFI_TARGET_HAS_COMPLEX_TYPE\n+  if (rtype->type == FFI_TYPE_COMPLEX)\n+    abort();\n+#endif\n   /* Perform a sanity check on the return type */\n   FFI_ASSERT_VALID_TYPE(cif->rtype);\n \n   /* x86, x86-64 and s390 stack space allocation is handled in prep_machdep. */\n-#if !defined M68K && !defined X86_ANY && !defined S390 && !defined PA\n+#if !defined FFI_TARGET_SPECIFIC_STACK_SPACE_ALLOCATION\n   /* Make space for the return structure pointer */\n   if (cif->rtype->type == FFI_TYPE_STRUCT\n-#ifdef SPARC\n-      && (cif->abi != FFI_V9 || cif->rtype->size > 32)\n-#endif\n #ifdef TILE\n       && (cif->rtype->size > 10 * FFI_SIZEOF_ARG)\n+#endif\n+#ifdef XTENSA\n+      && (cif->rtype->size > 16)\n+#endif\n+#ifdef NIOS2\n+      && (cif->rtype->size > 8)\n #endif\n      )\n     bytes = STACK_ARG_SIZE(sizeof(void*));\n@@ -158,23 +167,19 @@ ffi_status FFI_HIDDEN ffi_prep_cif_core(ffi_cif *cif, ffi_abi abi,\n       if (((*ptr)->size == 0) && (initialize_aggregate((*ptr)) != FFI_OK))\n \treturn FFI_BAD_TYPEDEF;\n \n+#ifndef FFI_TARGET_HAS_COMPLEX_TYPE\n+      if ((*ptr)->type == FFI_TYPE_COMPLEX)\n+\tabort();\n+#endif\n       /* Perform a sanity check on the argument type, do this\n \t check after the initialization.  */\n       FFI_ASSERT_VALID_TYPE(*ptr);\n \n-#if !defined X86_ANY && !defined S390 && !defined PA\n-#ifdef SPARC\n-      if (((*ptr)->type == FFI_TYPE_STRUCT\n-\t   && ((*ptr)->size > 16 || cif->abi != FFI_V9))\n-\t  || ((*ptr)->type == FFI_TYPE_LONGDOUBLE\n-\t      && cif->abi != FFI_V9))\n-\tbytes += sizeof(void*);\n-      else\n-#endif\n+#if !defined FFI_TARGET_SPECIFIC_STACK_SPACE_ALLOCATION\n \t{\n \t  /* Add any padding if necessary */\n \t  if (((*ptr)->alignment - 1) & bytes)\n-\t    bytes = ALIGN(bytes, (*ptr)->alignment);\n+\t    bytes = (unsigned)ALIGN(bytes, (*ptr)->alignment);\n \n #ifdef TILE\n \t  if (bytes < 10 * FFI_SIZEOF_ARG &&\n@@ -185,6 +190,10 @@ ffi_status FFI_HIDDEN ffi_prep_cif_core(ffi_cif *cif, ffi_abi abi,\n \t      bytes = 10 * FFI_SIZEOF_ARG;\n \t    }\n #endif\n+#ifdef XTENSA\n+\t  if (bytes <= 6*4 && bytes + STACK_ARG_SIZE((*ptr)->size) > 6*4)\n+\t    bytes = 6*4;\n+#endif\n \n \t  bytes += STACK_ARG_SIZE((*ptr)->size);\n \t}"}, {"sha": "276cb22807a5965d8d9fb0eca7bfaa204daf6390", "filename": "libffi/src/raw_api.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fraw_api.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fraw_api.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fraw_api.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -88,6 +88,10 @@ ffi_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args)\n \t  break;\n #endif\n \n+\tcase FFI_TYPE_COMPLEX:\n+\t  *args = (raw++)->ptr;\n+\t  break;\n+\n \tcase FFI_TYPE_POINTER:\n \t  *args = (void*) &(raw++)->ptr;\n \t  break;\n@@ -112,6 +116,11 @@ ffi_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args)\n \t}\n       else\n #endif\n+      if ((*tp)->type == FFI_TYPE_COMPLEX)\n+\t{\n+\t  *args = (raw++)->ptr;\n+\t}\n+      else\n \t{\n \t  *args = (void*) raw;\n \t  raw += ALIGN ((*tp)->size, sizeof (void*)) / sizeof (void*);\n@@ -167,6 +176,10 @@ ffi_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_raw *raw)\n \t  break;\n #endif\n \n+\tcase FFI_TYPE_COMPLEX:\n+\t  (raw++)->ptr = *args;\n+\t  break;\n+\n \tcase FFI_TYPE_POINTER:\n \t  (raw++)->ptr = **(void***) args;\n \t  break;"}, {"sha": "4035b6e366e6655ea263dfcf8df6a678455d1293", "filename": "libffi/src/s390/ffi.c", "status": "modified", "additions": 293, "deletions": 318, "changes": 611, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fs390%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fs390%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fs390%2Fffi.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -1,20 +1,20 @@\n /* -----------------------------------------------------------------------\n    ffi.c - Copyright (c) 2000, 2007 Software AG\n            Copyright (c) 2008 Red Hat, Inc\n- \n+\n    S390 Foreign Function Interface\n- \n+\n    Permission is hereby granted, free of charge, to any person obtaining\n    a copy of this software and associated documentation files (the\n    ``Software''), to deal in the Software without restriction, including\n    without limitation the rights to use, copy, modify, merge, publish,\n    distribute, sublicense, and/or sell copies of the Software, and to\n    permit persons to whom the Software is furnished to do so, subject to\n    the following conditions:\n- \n+\n    The above copyright notice and this permission notice shall be included\n    in all copies or substantial portions of the Software.\n- \n+\n    THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS\n    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n@@ -27,24 +27,23 @@\n /*                          Includes                                  */\n /*                          --------                                  */\n /*====================================================================*/\n- \n+\n #include <ffi.h>\n #include <ffi_common.h>\n- \n-#include <stdlib.h>\n-#include <stdio.h>\n- \n+#include <stdint.h>\n+#include \"internal.h\"\n+\n /*====================== End of Includes =============================*/\n- \n+\n /*====================================================================*/\n /*                           Defines                                  */\n /*                           -------                                  */\n /*====================================================================*/\n \n-/* Maximum number of GPRs available for argument passing.  */ \n+/* Maximum number of GPRs available for argument passing.  */\n #define MAX_GPRARGS 5\n \n-/* Maximum number of FPRs available for argument passing.  */ \n+/* Maximum number of FPRs available for argument passing.  */\n #ifdef __s390x__\n #define MAX_FPRARGS 4\n #else\n@@ -54,47 +53,30 @@\n /* Round to multiple of 16.  */\n #define ROUND_SIZE(size) (((size) + 15) & ~15)\n \n-/* If these values change, sysv.S must be adapted!  */\n-#define FFI390_RET_VOID\t\t0\n-#define FFI390_RET_STRUCT\t1\n-#define FFI390_RET_FLOAT\t2\n-#define FFI390_RET_DOUBLE\t3\n-#define FFI390_RET_INT32\t4\n-#define FFI390_RET_INT64\t5\n-\n /*===================== End of Defines ===============================*/\n- \n-/*====================================================================*/\n-/*                          Prototypes                                */\n-/*                          ----------                                */\n-/*====================================================================*/\n- \n-static void ffi_prep_args (unsigned char *, extended_cif *);\n-void\n-#if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 2)\n-__attribute__ ((visibility (\"hidden\")))\n-#endif\n-ffi_closure_helper_SYSV (ffi_closure *, unsigned long *, \n-\t\t\t unsigned long long *, unsigned long *);\n \n-/*====================== End of Prototypes ===========================*/\n- \n /*====================================================================*/\n /*                          Externals                                 */\n /*                          ---------                                 */\n /*====================================================================*/\n- \n-extern void ffi_call_SYSV(unsigned,\n-\t\t\t  extended_cif *,\n-\t\t\t  void (*)(unsigned char *, extended_cif *),\n-\t\t\t  unsigned,\n-\t\t\t  void *,\n-\t\t\t  void (*fn)(void));\n+\n+struct call_frame\n+{\n+  void *back_chain;\n+  void *eos;\n+  unsigned long gpr_args[5];\n+  unsigned long gpr_save[9];\n+  unsigned long long fpr_args[4];\n+};\n+\n+extern void FFI_HIDDEN ffi_call_SYSV(struct call_frame *, unsigned, void *,\n+\t\t\t             void (*fn)(void), void *);\n \n extern void ffi_closure_SYSV(void);\n- \n+extern void ffi_go_closure_SYSV(void);\n+\n /*====================== End of Externals ============================*/\n- \n+\n /*====================================================================*/\n /*                                                                    */\n /* Name     - ffi_check_struct_type.                                  */\n@@ -103,15 +85,15 @@ extern void ffi_closure_SYSV(void);\n /*            general purpose or floating point register.             */\n /*                                                                    */\n /*====================================================================*/\n- \n+\n static int\n ffi_check_struct_type (ffi_type *arg)\n {\n   size_t size = arg->size;\n \n   /* If the struct has just one element, look at that element\n      to find out whether to consider the struct as floating point.  */\n-  while (arg->type == FFI_TYPE_STRUCT \n+  while (arg->type == FFI_TYPE_STRUCT\n          && arg->elements[0] && !arg->elements[1])\n     arg = arg->elements[0];\n \n@@ -144,199 +126,18 @@ ffi_check_struct_type (ffi_type *arg)\n   /* Other structs are passed via a pointer to the data.  */\n   return FFI_TYPE_POINTER;\n }\n- \n-/*======================== End of Routine ============================*/\n- \n-/*====================================================================*/\n-/*                                                                    */\n-/* Name     - ffi_prep_args.                                          */\n-/*                                                                    */\n-/* Function - Prepare parameters for call to function.                */\n-/*                                                                    */\n-/* ffi_prep_args is called by the assembly routine once stack space   */\n-/* has been allocated for the function's arguments.                   */\n-/*                                                                    */\n-/*====================================================================*/\n- \n-static void\n-ffi_prep_args (unsigned char *stack, extended_cif *ecif)\n-{\n-  /* The stack space will be filled with those areas:\n-\n-\tFPR argument register save area     (highest addresses)\n-\tGPR argument register save area\n-\ttemporary struct copies\n-\toverflow argument area              (lowest addresses)\n-\n-     We set up the following pointers:\n-\n-        p_fpr: bottom of the FPR area (growing upwards)\n-\tp_gpr: bottom of the GPR area (growing upwards)\n-\tp_ov: bottom of the overflow area (growing upwards)\n-\tp_struct: top of the struct copy area (growing downwards)\n-\n-     All areas are kept aligned to twice the word size.  */\n-\n-  int gpr_off = ecif->cif->bytes;\n-  int fpr_off = gpr_off + ROUND_SIZE (MAX_GPRARGS * sizeof (long));\n-\n-  unsigned long long *p_fpr = (unsigned long long *)(stack + fpr_off);\n-  unsigned long *p_gpr = (unsigned long *)(stack + gpr_off);\n-  unsigned char *p_struct = (unsigned char *)p_gpr;\n-  unsigned long *p_ov = (unsigned long *)stack;\n-\n-  int n_fpr = 0;\n-  int n_gpr = 0;\n-  int n_ov = 0;\n-\n-  ffi_type **ptr;\n-  void **p_argv = ecif->avalue;\n-  int i;\n- \n-  /* If we returning a structure then we set the first parameter register\n-     to the address of where we are returning this structure.  */\n-\n-  if (ecif->cif->flags == FFI390_RET_STRUCT)\n-    p_gpr[n_gpr++] = (unsigned long) ecif->rvalue;\n-\n-  /* Now for the arguments.  */\n- \n-  for (ptr = ecif->cif->arg_types, i = ecif->cif->nargs;\n-       i > 0;\n-       i--, ptr++, p_argv++)\n-    {\n-      void *arg = *p_argv;\n-      int type = (*ptr)->type;\n-\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-      /* 16-byte long double is passed like a struct.  */\n-      if (type == FFI_TYPE_LONGDOUBLE)\n-\ttype = FFI_TYPE_STRUCT;\n-#endif\n-\n-      /* Check how a structure type is passed.  */\n-      if (type == FFI_TYPE_STRUCT)\n-\t{\n-\t  type = ffi_check_struct_type (*ptr);\n-\n-\t  /* If we pass the struct via pointer, copy the data.  */\n-\t  if (type == FFI_TYPE_POINTER)\n-\t    {\n-\t      p_struct -= ROUND_SIZE ((*ptr)->size);\n-\t      memcpy (p_struct, (char *)arg, (*ptr)->size);\n-\t      arg = &p_struct;\n-\t    }\n-\t}\n-\n-      /* Now handle all primitive int/pointer/float data types.  */\n-      switch (type) \n-\t{\n-\t  case FFI_TYPE_DOUBLE:\n-\t    if (n_fpr < MAX_FPRARGS)\n-\t      p_fpr[n_fpr++] = *(unsigned long long *) arg;\n-\t    else\n-#ifdef __s390x__\n-\t      p_ov[n_ov++] = *(unsigned long *) arg;\n-#else\n-\t      p_ov[n_ov++] = ((unsigned long *) arg)[0],\n-\t      p_ov[n_ov++] = ((unsigned long *) arg)[1];\n-#endif\n-\t    break;\n-\t\n-\t  case FFI_TYPE_FLOAT:\n-\t    if (n_fpr < MAX_FPRARGS)\n-\t      p_fpr[n_fpr++] = (long long) *(unsigned int *) arg << 32;\n-\t    else\n-\t      p_ov[n_ov++] = *(unsigned int *) arg;\n-\t    break;\n-\n-\t  case FFI_TYPE_POINTER:\n-\t    if (n_gpr < MAX_GPRARGS)\n-\t      p_gpr[n_gpr++] = (unsigned long)*(unsigned char **) arg;\n-\t    else\n-\t      p_ov[n_ov++] = (unsigned long)*(unsigned char **) arg;\n-\t    break;\n- \n-\t  case FFI_TYPE_UINT64:\n-\t  case FFI_TYPE_SINT64:\n-#ifdef __s390x__\n-\t    if (n_gpr < MAX_GPRARGS)\n-\t      p_gpr[n_gpr++] = *(unsigned long *) arg;\n-\t    else\n-\t      p_ov[n_ov++] = *(unsigned long *) arg;\n-#else\n-\t    if (n_gpr == MAX_GPRARGS-1)\n-\t      n_gpr = MAX_GPRARGS;\n-\t    if (n_gpr < MAX_GPRARGS)\n-\t      p_gpr[n_gpr++] = ((unsigned long *) arg)[0],\n-\t      p_gpr[n_gpr++] = ((unsigned long *) arg)[1];\n-\t    else\n-\t      p_ov[n_ov++] = ((unsigned long *) arg)[0],\n-\t      p_ov[n_ov++] = ((unsigned long *) arg)[1];\n-#endif\n-\t    break;\n- \n-\t  case FFI_TYPE_UINT32:\n-\t    if (n_gpr < MAX_GPRARGS)\n-\t      p_gpr[n_gpr++] = *(unsigned int *) arg;\n-\t    else\n-\t      p_ov[n_ov++] = *(unsigned int *) arg;\n-\t    break;\n- \n-\t  case FFI_TYPE_INT:\n-\t  case FFI_TYPE_SINT32:\n-\t    if (n_gpr < MAX_GPRARGS)\n-\t      p_gpr[n_gpr++] = *(signed int *) arg;\n-\t    else\n-\t      p_ov[n_ov++] = *(signed int *) arg;\n-\t    break;\n- \n-\t  case FFI_TYPE_UINT16:\n-\t    if (n_gpr < MAX_GPRARGS)\n-\t      p_gpr[n_gpr++] = *(unsigned short *) arg;\n-\t    else\n-\t      p_ov[n_ov++] = *(unsigned short *) arg;\n-\t    break;\n- \n-\t  case FFI_TYPE_SINT16:\n-\t    if (n_gpr < MAX_GPRARGS)\n-\t      p_gpr[n_gpr++] = *(signed short *) arg;\n-\t    else\n-\t      p_ov[n_ov++] = *(signed short *) arg;\n-\t    break;\n-\n-\t  case FFI_TYPE_UINT8:\n-\t    if (n_gpr < MAX_GPRARGS)\n-\t      p_gpr[n_gpr++] = *(unsigned char *) arg;\n-\t    else\n-\t      p_ov[n_ov++] = *(unsigned char *) arg;\n-\t    break;\n- \n-\t  case FFI_TYPE_SINT8:\n-\t    if (n_gpr < MAX_GPRARGS)\n-\t      p_gpr[n_gpr++] = *(signed char *) arg;\n-\t    else\n-\t      p_ov[n_ov++] = *(signed char *) arg;\n-\t    break;\n- \n-\t  default:\n-\t    FFI_ASSERT (0);\n-\t    break;\n-        }\n-    }\n-}\n \n /*======================== End of Routine ============================*/\n- \n+\n /*====================================================================*/\n /*                                                                    */\n /* Name     - ffi_prep_cif_machdep.                                   */\n /*                                                                    */\n /* Function - Perform machine dependent CIF processing.               */\n /*                                                                    */\n /*====================================================================*/\n- \n-ffi_status\n+\n+ffi_status FFI_HIDDEN\n ffi_prep_cif_machdep(ffi_cif *cif)\n {\n   size_t struct_size = 0;\n@@ -347,7 +148,7 @@ ffi_prep_cif_machdep(ffi_cif *cif)\n   ffi_type **ptr;\n   int i;\n \n-  /* Determine return value handling.  */ \n+  /* Determine return value handling.  */\n \n   switch (cif->rtype->type)\n     {\n@@ -356,11 +157,12 @@ ffi_prep_cif_machdep(ffi_cif *cif)\n \tcif->flags = FFI390_RET_VOID;\n \tbreak;\n \n-      /* Structures are returned via a hidden pointer.  */\n+      /* Structures and complex are returned via a hidden pointer.  */\n       case FFI_TYPE_STRUCT:\n+      case FFI_TYPE_COMPLEX:\n \tcif->flags = FFI390_RET_STRUCT;\n \tn_gpr++;  /* We need one GPR to pass the pointer.  */\n-\tbreak; \n+\tbreak;\n \n       /* Floating point values are returned in fpr 0.  */\n       case FFI_TYPE_FLOAT:\n@@ -399,14 +201,14 @@ ffi_prep_cif_machdep(ffi_cif *cif)\n \tcif->flags = FFI390_RET_INT32;\n #endif\n \tbreak;\n- \n+\n       default:\n         FFI_ASSERT (0);\n         break;\n     }\n \n   /* Now for the arguments.  */\n- \n+\n   for (ptr = cif->arg_types, i = cif->nargs;\n        i > 0;\n        i--, ptr++)\n@@ -420,9 +222,12 @@ ffi_prep_cif_machdep(ffi_cif *cif)\n #endif\n \n       /* Check how a structure type is passed.  */\n-      if (type == FFI_TYPE_STRUCT)\n+      if (type == FFI_TYPE_STRUCT || type == FFI_TYPE_COMPLEX)\n \t{\n-\t  type = ffi_check_struct_type (*ptr);\n+\t  if (type == FFI_TYPE_COMPLEX)\n+\t    type = FFI_TYPE_POINTER;\n+\t  else\n+\t    type = ffi_check_struct_type (*ptr);\n \n \t  /* If we pass the struct via pointer, we must reserve space\n \t     to copy its data for proper call-by-value semantics.  */\n@@ -431,7 +236,7 @@ ffi_prep_cif_machdep(ffi_cif *cif)\n \t}\n \n       /* Now handle all primitive int/float data types.  */\n-      switch (type) \n+      switch (type)\n \t{\n \t  /* The first MAX_FPRARGS floating point arguments\n \t     go in FPRs, the rest overflow to the stack.  */\n@@ -442,7 +247,7 @@ ffi_prep_cif_machdep(ffi_cif *cif)\n \t    else\n \t      n_ov += sizeof (double) / sizeof (long);\n \t    break;\n-\t\n+\n \t  case FFI_TYPE_FLOAT:\n \t    if (n_fpr < MAX_FPRARGS)\n \t      n_fpr++;\n@@ -452,9 +257,9 @@ ffi_prep_cif_machdep(ffi_cif *cif)\n \n \t  /* On 31-bit machines, 64-bit integers are passed in GPR pairs,\n \t     if one is still available, or else on the stack.  If only one\n-\t     register is free, skip the register (it won't be used for any \n+\t     register is free, skip the register (it won't be used for any\n \t     subsequent argument either).  */\n-\t      \n+\n #ifndef __s390x__\n \t  case FFI_TYPE_UINT64:\n \t  case FFI_TYPE_SINT64:\n@@ -470,7 +275,7 @@ ffi_prep_cif_machdep(ffi_cif *cif)\n \t  /* Everything else is passed in GPRs (until MAX_GPRARGS\n \t     have been used) or overflows to the stack.  */\n \n-\t  default: \n+\t  default:\n \t    if (n_gpr < MAX_GPRARGS)\n \t      n_gpr++;\n \t    else\n@@ -483,55 +288,208 @@ ffi_prep_cif_machdep(ffi_cif *cif)\n      and temporary structure copies.  */\n \n   cif->bytes = ROUND_SIZE (n_ov * sizeof (long)) + struct_size;\n- \n+\n   return FFI_OK;\n }\n- \n+\n /*======================== End of Routine ============================*/\n- \n+\n /*====================================================================*/\n /*                                                                    */\n /* Name     - ffi_call.                                               */\n /*                                                                    */\n /* Function - Call the FFI routine.                                   */\n /*                                                                    */\n /*====================================================================*/\n- \n-void\n-ffi_call(ffi_cif *cif,\n-\t void (*fn)(void),\n-\t void *rvalue,\n-\t void **avalue)\n+\n+static void\n+ffi_call_int(ffi_cif *cif,\n+\t     void (*fn)(void),\n+\t     void *rvalue,\n+\t     void **avalue,\n+\t     void *closure)\n {\n   int ret_type = cif->flags;\n-  extended_cif ecif;\n- \n-  ecif.cif    = cif;\n-  ecif.avalue = avalue;\n-  ecif.rvalue = rvalue;\n+  size_t rsize = 0, bytes = cif->bytes;\n+  unsigned char *stack, *p_struct;\n+  struct call_frame *frame;\n+  unsigned long *p_ov, *p_gpr;\n+  unsigned long long *p_fpr;\n+  int n_fpr, n_gpr, n_ov, i, n;\n+  ffi_type **arg_types;\n+\n+  FFI_ASSERT (cif->abi == FFI_SYSV);\n \n   /* If we don't have a return value, we need to fake one.  */\n   if (rvalue == NULL)\n     {\n-      if (ret_type == FFI390_RET_STRUCT)\n-\tecif.rvalue = alloca (cif->rtype->size);\n+      if (ret_type & FFI390_RET_IN_MEM)\n+\trsize = cif->rtype->size;\n       else\n \tret_type = FFI390_RET_VOID;\n-    } \n+    }\n \n-  switch (cif->abi)\n+  /* The stack space will be filled with those areas:\n+\n+\tdummy structure return\t\t    (highest addresses)\n+\t  FPR argument register save area\n+\t  GPR argument register save area\n+\tstack frame for ffi_call_SYSV\n+\ttemporary struct copies\n+\toverflow argument area              (lowest addresses)\n+\n+     We set up the following pointers:\n+\n+        p_fpr: bottom of the FPR area (growing upwards)\n+\tp_gpr: bottom of the GPR area (growing upwards)\n+\tp_ov: bottom of the overflow area (growing upwards)\n+\tp_struct: top of the struct copy area (growing downwards)\n+\n+     All areas are kept aligned to twice the word size.\n+\n+     Note that we're going to create the stack frame for both\n+     ffi_call_SYSV _and_ the target function right here.  This\n+     works because we don't make any function calls with more\n+     than 5 arguments (indeed only memcpy and ffi_call_SYSV),\n+     and thus we don't have any stacked outgoing parameters.  */\n+\n+  stack = alloca (bytes + sizeof(struct call_frame) + rsize);\n+  frame = (struct call_frame *)(stack + bytes);\n+  if (rsize)\n+    rvalue = frame + 1;\n+\n+  /* Link the new frame back to the one from this function.  */\n+  frame->back_chain = __builtin_frame_address (0);\n+\n+  /* Fill in all of the argument stuff.  */\n+  p_ov = (unsigned long *)stack;\n+  p_struct = (unsigned char *)frame;\n+  p_gpr = frame->gpr_args;\n+  p_fpr = frame->fpr_args;\n+  n_fpr = n_gpr = n_ov = 0;\n+\n+  /* If we returning a structure then we set the first parameter register\n+     to the address of where we are returning this structure.  */\n+  if (cif->flags & FFI390_RET_IN_MEM)\n+    p_gpr[n_gpr++] = (uintptr_t) rvalue;\n+\n+  /* Now for the arguments.  */\n+  arg_types = cif->arg_types;\n+  for (i = 0, n = cif->nargs; i < n; ++i)\n     {\n-      case FFI_SYSV:\n-        ffi_call_SYSV (cif->bytes, &ecif, ffi_prep_args,\n-\t\t       ret_type, ecif.rvalue, fn);\n-        break;\n- \n-      default:\n-        FFI_ASSERT (0);\n-        break;\n+      ffi_type *ty = arg_types[i];\n+      void *arg = avalue[i];\n+      int type = ty->type;\n+      ffi_arg val;\n+\n+    restart:\n+      switch (type)\n+\t{\n+\tcase FFI_TYPE_SINT8:\n+\t  val = *(SINT8 *)arg;\n+\t  goto do_int;\n+\tcase FFI_TYPE_UINT8:\n+\t  val = *(UINT8 *)arg;\n+\t  goto do_int;\n+\tcase FFI_TYPE_SINT16:\n+\t  val = *(SINT16 *)arg;\n+\t  goto do_int;\n+\tcase FFI_TYPE_UINT16:\n+\t  val = *(UINT16 *)arg;\n+\t  goto do_int;\n+\tcase FFI_TYPE_INT:\n+\tcase FFI_TYPE_SINT32:\n+\t  val = *(SINT32 *)arg;\n+\t  goto do_int;\n+\tcase FFI_TYPE_UINT32:\n+\t  val = *(UINT32 *)arg;\n+\t  goto do_int;\n+\tcase FFI_TYPE_POINTER:\n+\t  val = *(uintptr_t *)arg;\n+\tdo_int:\n+\t  *(n_gpr < MAX_GPRARGS ? p_gpr + n_gpr++ : p_ov + n_ov++) = val;\n+\t  break;\n+\n+\tcase FFI_TYPE_UINT64:\n+\tcase FFI_TYPE_SINT64:\n+#ifdef __s390x__\n+\t  val = *(UINT64 *)arg;\n+\t  goto do_int;\n+#else\n+\t  if (n_gpr == MAX_GPRARGS-1)\n+\t    n_gpr = MAX_GPRARGS;\n+\t  if (n_gpr < MAX_GPRARGS)\n+\t    p_gpr[n_gpr++] = ((UINT32 *) arg)[0],\n+\t    p_gpr[n_gpr++] = ((UINT32 *) arg)[1];\n+\t  else\n+\t    p_ov[n_ov++] = ((UINT32 *) arg)[0],\n+\t    p_ov[n_ov++] = ((UINT32 *) arg)[1];\n+#endif\n+\t  break;\n+\n+\tcase FFI_TYPE_DOUBLE:\n+\t  if (n_fpr < MAX_FPRARGS)\n+\t    p_fpr[n_fpr++] = *(UINT64 *) arg;\n+\t  else\n+\t    {\n+#ifdef __s390x__\n+\t      p_ov[n_ov++] = *(UINT64 *) arg;\n+#else\n+\t      p_ov[n_ov++] = ((UINT32 *) arg)[0],\n+\t      p_ov[n_ov++] = ((UINT32 *) arg)[1];\n+#endif\n+\t    }\n+\t  break;\n+\n+\tcase FFI_TYPE_FLOAT:\n+\t  val = *(UINT32 *)arg;\n+\t  if (n_fpr < MAX_FPRARGS)\n+\t    p_fpr[n_fpr++] = (UINT64)val << 32;\n+\t  else\n+\t    p_ov[n_ov++] = val;\n+\t  break;\n+\n+\tcase FFI_TYPE_STRUCT:\n+          /* Check how a structure type is passed.  */\n+\t  type = ffi_check_struct_type (ty);\n+\t  /* Some structures are passed via a type they contain.  */\n+\t  if (type != FFI_TYPE_POINTER)\n+\t    goto restart;\n+\t  /* ... otherwise, passed by reference.  fallthru.  */\n+\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\tcase FFI_TYPE_LONGDOUBLE:\n+\t  /* 16-byte long double is passed via reference.  */\n+#endif\n+\tcase FFI_TYPE_COMPLEX:\n+\t  /* Complex types are passed via reference.  */\n+\t  p_struct -= ROUND_SIZE (ty->size);\n+\t  memcpy (p_struct, arg, ty->size);\n+\t  val = (uintptr_t)p_struct;\n+\t  goto do_int;\n+\n+\tdefault:\n+\t  FFI_ASSERT (0);\n+\t  break;\n+        }\n     }\n+\n+  ffi_call_SYSV (frame, ret_type & FFI360_RET_MASK, rvalue, fn, closure);\n+}\n+\n+void\n+ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n+{\n+  ffi_call_int(cif, fn, rvalue, avalue, NULL);\n }\n- \n+\n+void\n+ffi_call_go (ffi_cif *cif, void (*fn)(void), void *rvalue,\n+\t     void **avalue, void *closure)\n+{\n+  ffi_call_int(cif, fn, rvalue, avalue, closure);\n+}\n+\n /*======================== End of Routine ============================*/\n \n /*====================================================================*/\n@@ -541,9 +499,11 @@ ffi_call(ffi_cif *cif,\n /* Function - Call a FFI closure target function.                     */\n /*                                                                    */\n /*====================================================================*/\n- \n-void\n-ffi_closure_helper_SYSV (ffi_closure *closure,\n+\n+void FFI_HIDDEN\n+ffi_closure_helper_SYSV (ffi_cif *cif,\n+\t\t\t void (*fun)(ffi_cif*,void*,void**,void*),\n+\t\t\t void *user_data,\n \t\t\t unsigned long *p_gpr,\n \t\t\t unsigned long long *p_fpr,\n \t\t\t unsigned long *p_ov)\n@@ -562,21 +522,16 @@ ffi_closure_helper_SYSV (ffi_closure *closure,\n   int i;\n \n   /* Allocate buffer for argument list pointers.  */\n+  p_arg = avalue = alloca (cif->nargs * sizeof (void *));\n \n-  p_arg = avalue = alloca (closure->cif->nargs * sizeof (void *));\n-\n-  /* If we returning a structure, pass the structure address \n-     directly to the target function.  Otherwise, have the target \n+  /* If we returning a structure, pass the structure address\n+     directly to the target function.  Otherwise, have the target\n      function store the return value to the GPR save area.  */\n-\n-  if (closure->cif->flags == FFI390_RET_STRUCT)\n+  if (cif->flags & FFI390_RET_IN_MEM)\n     rvalue = (void *) p_gpr[n_gpr++];\n \n   /* Now for the arguments.  */\n-\n-  for (ptr = closure->cif->arg_types, i = closure->cif->nargs;\n-       i > 0;\n-       i--, p_arg++, ptr++)\n+  for (ptr = cif->arg_types, i = cif->nargs; i > 0; i--, p_arg++, ptr++)\n     {\n       int deref_struct_pointer = 0;\n       int type = (*ptr)->type;\n@@ -588,42 +543,47 @@ ffi_closure_helper_SYSV (ffi_closure *closure,\n #endif\n \n       /* Check how a structure type is passed.  */\n-      if (type == FFI_TYPE_STRUCT)\n+      if (type == FFI_TYPE_STRUCT || type == FFI_TYPE_COMPLEX)\n \t{\n-\t  type = ffi_check_struct_type (*ptr);\n+\t  if (type == FFI_TYPE_COMPLEX)\n+\t    type = FFI_TYPE_POINTER;\n+\t  else\n+\t    type = ffi_check_struct_type (*ptr);\n \n-\t  /* If we pass the struct via pointer, remember to \n+\t  /* If we pass the struct via pointer, remember to\n \t     retrieve the pointer later.  */\n \t  if (type == FFI_TYPE_POINTER)\n \t    deref_struct_pointer = 1;\n \t}\n \n       /* Pointers are passed like UINTs of the same size.  */\n       if (type == FFI_TYPE_POINTER)\n+\t{\n #ifdef __s390x__\n-\ttype = FFI_TYPE_UINT64;\n+\t  type = FFI_TYPE_UINT64;\n #else\n-\ttype = FFI_TYPE_UINT32;\n+\t  type = FFI_TYPE_UINT32;\n #endif\n+\t}\n \n       /* Now handle all primitive int/float data types.  */\n-      switch (type) \n+      switch (type)\n \t{\n \t  case FFI_TYPE_DOUBLE:\n \t    if (n_fpr < MAX_FPRARGS)\n \t      *p_arg = &p_fpr[n_fpr++];\n \t    else\n-\t      *p_arg = &p_ov[n_ov], \n+\t      *p_arg = &p_ov[n_ov],\n \t      n_ov += sizeof (double) / sizeof (long);\n \t    break;\n-\t\n+\n \t  case FFI_TYPE_FLOAT:\n \t    if (n_fpr < MAX_FPRARGS)\n \t      *p_arg = &p_fpr[n_fpr++];\n \t    else\n \t      *p_arg = (char *)&p_ov[n_ov++] + sizeof (long) - 4;\n \t    break;\n- \n+\n \t  case FFI_TYPE_UINT64:\n \t  case FFI_TYPE_SINT64:\n #ifdef __s390x__\n@@ -640,7 +600,7 @@ ffi_closure_helper_SYSV (ffi_closure *closure,\n \t      *p_arg = &p_ov[n_ov], n_ov += 2;\n #endif\n \t    break;\n- \n+\n \t  case FFI_TYPE_INT:\n \t  case FFI_TYPE_UINT32:\n \t  case FFI_TYPE_SINT32:\n@@ -649,7 +609,7 @@ ffi_closure_helper_SYSV (ffi_closure *closure,\n \t    else\n \t      *p_arg = (char *)&p_ov[n_ov++] + sizeof (long) - 4;\n \t    break;\n- \n+\n \t  case FFI_TYPE_UINT16:\n \t  case FFI_TYPE_SINT16:\n \t    if (n_gpr < MAX_GPRARGS)\n@@ -665,7 +625,7 @@ ffi_closure_helper_SYSV (ffi_closure *closure,\n \t    else\n \t      *p_arg = (char *)&p_ov[n_ov++] + sizeof (long) - 1;\n \t    break;\n- \n+\n \t  default:\n \t    FFI_ASSERT (0);\n \t    break;\n@@ -679,14 +639,15 @@ ffi_closure_helper_SYSV (ffi_closure *closure,\n \n \n   /* Call the target function.  */\n-  (closure->fun) (closure->cif, rvalue, avalue, closure->user_data);\n+  (fun) (cif, rvalue, avalue, user_data);\n \n   /* Convert the return value.  */\n-  switch (closure->cif->rtype->type)\n+  switch (cif->rtype->type)\n     {\n       /* Void is easy, and so is struct.  */\n       case FFI_TYPE_VOID:\n       case FFI_TYPE_STRUCT:\n+      case FFI_TYPE_COMPLEX:\n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n       case FFI_TYPE_LONGDOUBLE:\n #endif\n@@ -732,7 +693,7 @@ ffi_closure_helper_SYSV (ffi_closure *closure,\n         break;\n     }\n }\n- \n+\n /*======================== End of Routine ============================*/\n \n /*====================================================================*/\n@@ -742,40 +703,54 @@ ffi_closure_helper_SYSV (ffi_closure *closure,\n /* Function - Prepare a FFI closure.                                  */\n /*                                                                    */\n /*====================================================================*/\n- \n+\n ffi_status\n ffi_prep_closure_loc (ffi_closure *closure,\n \t\t      ffi_cif *cif,\n \t\t      void (*fun) (ffi_cif *, void *, void **, void *),\n \t\t      void *user_data,\n \t\t      void *codeloc)\n {\n+  static unsigned short const template[] = {\n+    0x0d10,\t\t\t/* basr %r1,0 */\n+#ifndef __s390x__\n+    0x9801, 0x1006,\t\t/* lm %r0,%r1,6(%r1) */\n+#else\n+    0xeb01, 0x100e, 0x0004,\t/* lmg %r0,%r1,14(%r1) */\n+#endif\n+    0x07f1\t\t\t/* br %r1 */\n+  };\n+\n+  unsigned long *tramp = (unsigned long *)&closure->tramp;\n+\n   if (cif->abi != FFI_SYSV)\n     return FFI_BAD_ABI;\n \n-#ifndef __s390x__\n-  *(short *)&closure->tramp [0] = 0x0d10;   /* basr %r1,0 */\n-  *(short *)&closure->tramp [2] = 0x9801;   /* lm %r0,%r1,6(%r1) */\n-  *(short *)&closure->tramp [4] = 0x1006;\n-  *(short *)&closure->tramp [6] = 0x07f1;   /* br %r1 */\n-  *(long  *)&closure->tramp [8] = (long)codeloc;\n-  *(long  *)&closure->tramp[12] = (long)&ffi_closure_SYSV;\n-#else\n-  *(short *)&closure->tramp [0] = 0x0d10;   /* basr %r1,0 */\n-  *(short *)&closure->tramp [2] = 0xeb01;   /* lmg %r0,%r1,14(%r1) */\n-  *(short *)&closure->tramp [4] = 0x100e;\n-  *(short *)&closure->tramp [6] = 0x0004;\n-  *(short *)&closure->tramp [8] = 0x07f1;   /* br %r1 */\n-  *(long  *)&closure->tramp[16] = (long)codeloc;\n-  *(long  *)&closure->tramp[24] = (long)&ffi_closure_SYSV;\n-#endif \n- \n+  memcpy (tramp, template, sizeof(template));\n+  tramp[2] = (unsigned long)codeloc;\n+  tramp[3] = (unsigned long)&ffi_closure_SYSV;\n+\n   closure->cif = cif;\n-  closure->user_data = user_data;\n   closure->fun = fun;\n- \n+  closure->user_data = user_data;\n+\n   return FFI_OK;\n }\n \n /*======================== End of Routine ============================*/\n- \n+\n+/* Build a Go language closure.  */\n+\n+ffi_status\n+ffi_prep_go_closure (ffi_go_closure *closure, ffi_cif *cif,\n+\t\t     void (*fun)(ffi_cif*,void*,void**,void*))\n+{\n+  if (cif->abi != FFI_SYSV)\n+    return FFI_BAD_ABI;\n+\n+  closure->tramp = ffi_go_closure_SYSV;\n+  closure->cif = cif;\n+  closure->fun = fun;\n+\n+  return FFI_OK;\n+}"}, {"sha": "d8a4ee4bf1036022cdb173315219760b3da7a820", "filename": "libffi/src/s390/ffitarget.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fs390%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fs390%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fs390%2Fffitarget.h?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -52,10 +52,13 @@ typedef enum ffi_abi {\n } ffi_abi;\n #endif\n \n+#define FFI_TARGET_SPECIFIC_STACK_SPACE_ALLOCATION\n+#define FFI_TARGET_HAS_COMPLEX_TYPE\n \n /* ---- Definitions for closures ----------------------------------------- */\n \n #define FFI_CLOSURES 1\n+#define FFI_GO_CLOSURES 1\n #ifdef S390X\n #define FFI_TRAMPOLINE_SIZE 32\n #else"}, {"sha": "b8755786f9e4f5e0d9a2d9d52ffb40a22aaae5d0", "filename": "libffi/src/s390/internal.h", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fs390%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fs390%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fs390%2Finternal.h?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -0,0 +1,11 @@\n+/* If these values change, sysv.S must be adapted!  */\n+#define FFI390_RET_DOUBLE\t0\n+#define FFI390_RET_FLOAT\t1\n+#define FFI390_RET_INT64\t2\n+#define FFI390_RET_INT32\t3\n+#define FFI390_RET_VOID\t\t4\n+\n+#define FFI360_RET_MASK\t\t7\n+#define FFI390_RET_IN_MEM\t8\n+\n+#define FFI390_RET_STRUCT\t(FFI390_RET_VOID | FFI390_RET_IN_MEM)"}, {"sha": "c4b5006aed07454aba41870f4bc2bb1bac65a88e", "filename": "libffi/src/s390/sysv.S", "status": "modified", "additions": 257, "deletions": 366, "changes": 623, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fs390%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fs390%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fs390%2Fsysv.S?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -1,20 +1,20 @@\n /* -----------------------------------------------------------------------\n    sysv.S - Copyright (c) 2000 Software AG\n             Copyright (c) 2008 Red Hat, Inc.\n- \n+\n    S390 Foreign Function Interface\n- \n+\n    Permission is hereby granted, free of charge, to any person obtaining\n    a copy of this software and associated documentation files (the\n    ``Software''), to deal in the Software without restriction, including\n    without limitation the rights to use, copy, modify, merge, publish,\n    distribute, sublicense, and/or sell copies of the Software, and to\n    permit persons to whom the Software is furnished to do so, subject to\n    the following conditions:\n- \n+\n    The above copyright notice and this permission notice shall be included\n    in all copies or substantial portions of the Software.\n- \n+\n    THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n@@ -29,405 +29,296 @@\n #include <fficonfig.h>\n #include <ffi.h>\n \n+\t.text\n+\n #ifndef __s390x__\n- \n-.text\n-\n-\t# r2:\tcif->bytes\n-\t# r3:\t&ecif\n-\t# r4:\tffi_prep_args\n-\t# r5:\tret_type\n-\t# r6:\tecif.rvalue\n-\t# ov:\tfn \n- \n+\n+\t# r2:\tframe\n+\t# r3:\tret_type\n+\t# r4:\tret_addr\n+\t# r5:\tfun\n+\t# r6:\tclosure\n+\n \t# This assumes we are using gas.\n+\t.balign\t8\n \t.globl\tffi_call_SYSV\n+\tFFI_HIDDEN(ffi_call_SYSV)\n \t.type\tffi_call_SYSV,%function\n ffi_call_SYSV:\n-.LFB1:\n-\tstm\t%r6,%r15,24(%r15)\t\t# Save registers\n-.LCFI0:\n-\tbasr\t%r13,0\t\t\t\t# Set up base register\n-.Lbase:\n-\tlr\t%r11,%r15\t\t\t# Set up frame pointer\n-.LCFI1:\n-\tsr\t%r15,%r2\n-\tahi\t%r15,-96-48\t\t\t# Allocate stack\n-\tlr\t%r8,%r6\t\t\t\t# Save ecif.rvalue\n-\tsr\t%r9,%r9\n-\tic\t%r9,.Ltable-.Lbase(%r13,%r5)\t# Load epilog address\n-\tl\t%r7,96(%r11)\t\t\t# Load function address\n-\tst\t%r11,0(%r15)\t\t\t# Set up back chain\n-\tahi\t%r11,-48\t\t\t# Register save area\n-.LCFI2:\n-\n-\tla\t%r2,96(%r15)\t\t\t# Save area\n-\t\t\t\t\t\t# r3 already holds &ecif\n-\tbasr\t%r14,%r4\t\t\t# Call ffi_prep_args\n-\n-\tlm\t%r2,%r6,0(%r11)\t\t\t# Load arguments\n-\tld\t%f0,32(%r11)\n-\tld\t%f2,40(%r11)\n-\tla\t%r14,0(%r13,%r9)\t\t# Set return address\n-\tbr\t%r7\t\t\t\t# ... and call function\n-\n-.LretNone:\t\t\t\t\t# Return void\n-\tl\t%r4,48+56(%r11)\n-\tlm\t%r6,%r15,48+24(%r11)\n-\tbr\t%r4\n-\n-.LretFloat:\n-\tl\t%r4,48+56(%r11)\n-\tste\t%f0,0(%r8)\t\t\t# Return float\n-\tlm\t%r6,%r15,48+24(%r11)\n-\tbr\t%r4\n- \n-.LretDouble:\n-\tl\t%r4,48+56(%r11)\n-\tstd\t%f0,0(%r8)\t\t\t# Return double\n-\tlm\t%r6,%r15,48+24(%r11)\n-\tbr\t%r4\n-\n-.LretInt32:\n-\tl\t%r4,48+56(%r11)\n-\tst\t%r2,0(%r8)\t\t\t# Return int\n-\tlm\t%r6,%r15,48+24(%r11)\n-\tbr\t%r4\n- \n-.LretInt64:\n-\tl\t%r4,48+56(%r11)\n-\tstm\t%r2,%r3,0(%r8)\t\t\t# Return long long\n-\tlm\t%r6,%r15,48+24(%r11)\n-\tbr\t%r4\n- \n+\t.cfi_startproc\n+\tst\t%r6,44(%r2)\t\t\t# Save registers\n+\tstm\t%r12,%r14,48(%r2)\n+\tlr\t%r13,%r2\t\t\t# Install frame pointer\n+\t.cfi_rel_offset r6, 44\n+\t.cfi_rel_offset r12, 48\n+\t.cfi_rel_offset r13, 52\n+\t.cfi_rel_offset r14, 56\n+\t.cfi_def_cfa_register r13\n+\tst\t%r2,0(%r15)\t\t\t# Set up back chain\n+\tsla\t%r3,3\t\t\t\t# ret_type *= 8\n+\tlr\t%r12,%r4\t\t\t# Save ret_addr\n+\tlr\t%r1,%r5\t\t\t\t# Save fun\n+\tlr\t%r0,%r6\t\t\t\t# Install static chain\n+\n+\t# Set return address, so that there is only one indirect jump.\n+#ifdef HAVE_AS_S390_ZARCH\n+\tlarl\t%r14,.Ltable\n+\tar\t%r14,%r3\n+#else\n+\tbasr\t%r14,0\n+0:\tla\t%r14,.Ltable-0b(%r14,%r3)\n+#endif\n+\n+\tlm\t%r2,%r6,8(%r13)\t\t\t# Load arguments\n+\tld\t%f0,64(%r13)\n+\tld\t%f2,72(%r13)\n+\tbr\t%r1\t\t\t\t# ... and call function\n+\n+\t.balign\t8\n .Ltable:\n-\t.byte\t.LretNone-.Lbase\t\t# FFI390_RET_VOID\n-\t.byte\t.LretNone-.Lbase\t\t# FFI390_RET_STRUCT\n-\t.byte\t.LretFloat-.Lbase\t\t# FFI390_RET_FLOAT\n-\t.byte\t.LretDouble-.Lbase\t\t# FFI390_RET_DOUBLE\n-\t.byte\t.LretInt32-.Lbase\t\t# FFI390_RET_INT32\n-\t.byte\t.LretInt64-.Lbase\t\t# FFI390_RET_INT64\n+# FFI390_RET_DOUBLE\n+\tstd\t%f0,0(%r12)\n+\tj\t.Ldone\n+\n+\t.balign\t8\n+# FFI390_RET_FLOAT\n+\tste\t%f0,0(%r12)\n+\tj\t.Ldone\n+\n+\t.balign\t8\n+# FFI390_RET_INT64\n+\tst\t%r3,4(%r12)\n+\tnop\n+\t# fallthru\n+\n+\t.balign\t8\n+# FFI390_RET_INT32\n+\tst\t%r2,0(%r12)\n+\tnop\n+\t# fallthru\n+\n+\t.balign\t8\n+# FFI390_RET_VOID\n+.Ldone:\n+\tl\t%r14,56(%r13)\n+\tl\t%r12,48(%r13)\n+\tl\t%r6,44(%r13)\n+\tl\t%r13,52(%r13)\n+\t.cfi_restore 14\n+\t.cfi_restore 13\n+\t.cfi_restore 12\n+\t.cfi_restore 6\n+\t.cfi_def_cfa r15, 96\n+\tbr\t%r14\n+\t.cfi_endproc\n+\t.size\t ffi_call_SYSV,.-ffi_call_SYSV\n \n-.LFE1: \n-.ffi_call_SYSV_end:\n-\t.size\t ffi_call_SYSV,.ffi_call_SYSV_end-ffi_call_SYSV\n \n+\t.balign\t8\n+\t.globl\tffi_go_closure_SYSV\n+\tFFI_HIDDEN(ffi_go_closure_SYSV)\n+\t.type\tffi_go_closure_SYSV,%function\n+ffi_go_closure_SYSV:\n+\t.cfi_startproc\n+\tstm\t%r2,%r6,8(%r15)\t\t\t# Save arguments\n+\tlr\t%r4,%r0\t\t\t\t# Load closure -> user_data\n+\tl\t%r2,4(%r4)\t\t\t#   ->cif\n+\tl\t%r3,8(%r4)\t\t\t#   ->fun\n+\tj\t.Ldoclosure\n+\t.cfi_endproc\n \n+\t.balign\t8\n \t.globl\tffi_closure_SYSV\n+\tFFI_HIDDEN(ffi_closure_SYSV)\n \t.type\tffi_closure_SYSV,%function\n ffi_closure_SYSV:\n-.LFB2:\n+\t.cfi_startproc\n+\tstm\t%r2,%r6,8(%r15)\t\t\t# Save arguments\n+\tlr\t%r4,%r0\t\t\t\t# Closure\n+\tl\t%r2,16(%r4)\t\t\t#   ->cif\n+\tl\t%r3,20(%r4)\t\t\t#   ->fun\n+\tl\t%r4,24(%r4)\t\t\t#   ->user_data\n+.Ldoclosure:\n \tstm\t%r12,%r15,48(%r15)\t\t# Save registers\n-.LCFI10:\n+\tlr\t%r12,%r15\n+\t.cfi_def_cfa_register r12\n+\t.cfi_rel_offset r6, 24\n+\t.cfi_rel_offset r12, 48\n+\t.cfi_rel_offset r13, 52\n+\t.cfi_rel_offset r14, 56\n+\t.cfi_rel_offset r15, 60\n+#ifndef HAVE_AS_S390_ZARCH\n \tbasr\t%r13,0\t\t\t\t# Set up base register\n .Lcbase:\n-\tstm\t%r2,%r6,8(%r15)\t\t\t# Save arguments\n-\tstd\t%f0,64(%r15)\n-\tstd\t%f2,72(%r15)\n-\tlr\t%r1,%r15\t\t\t# Set up stack frame\n-\tahi\t%r15,-96\n-.LCFI11:\n-\tl\t%r12,.Lchelper-.Lcbase(%r13)\t# Get helper function\n-\tlr\t%r2,%r0\t\t\t\t# Closure\n-\tla\t%r3,8(%r1)\t\t\t# GPRs\n-\tla\t%r4,64(%r1)\t\t\t# FPRs\n-\tla\t%r5,96(%r1)\t\t\t# Overflow\n-\tst\t%r1,0(%r15)\t\t\t# Set up back chain\n-\n-\tbas\t%r14,0(%r12,%r13)\t\t# Call helper\n-\n-\tl\t%r4,96+56(%r15)\n-\tld\t%f0,96+64(%r15)\t\t\t# Load return registers\n-\tlm\t%r2,%r3,96+8(%r15)\n-\tlm\t%r12,%r15,96+48(%r15)\n-\tbr\t%r4\n+\tl\t%r1,.Lchelper-.Lcbase(%r13)\t# Get helper function\n+#endif\n+\tahi\t%r15,-96-8\t\t\t# Set up stack frame\n+\tst\t%r12,0(%r15)\t\t\t# Set up back chain\n+\n+\tstd\t%f0,64(%r12)\t\t\t# Save fp arguments\n+\tstd\t%f2,72(%r12)\n+\n+\tla\t%r5,96(%r12)\t\t\t# Overflow\n+\tst\t%r5,96(%r15)\n+\tla\t%r6,64(%r12)\t\t\t# FPRs\n+\tla\t%r5,8(%r12)\t\t\t# GPRs\n+#ifdef HAVE_AS_S390_ZARCH\n+\tbrasl\t%r14,ffi_closure_helper_SYSV\n+#else\n+\tbas\t%r14,0(%r1,%r13)\t\t# Call helper\n+#endif\n \n+\tlr\t%r15,%r12\n+\t.cfi_def_cfa_register r15\n+\tlm\t%r12,%r14,48(%r12)\t\t# Restore saved registers\n+\tl\t%r6,24(%r15)\n+\tld\t%f0,64(%r15)\t\t\t# Load return registers\n+\tlm\t%r2,%r3,8(%r15)\n+\tbr\t%r14\n+\t.cfi_endproc\n+\n+#ifndef HAVE_AS_S390_ZARCH\n \t.align 4\n .Lchelper:\n \t.long\tffi_closure_helper_SYSV-.Lcbase\n+#endif\n \n-.LFE2: \n-\n-.ffi_closure_SYSV_end:\n-\t.size\t ffi_closure_SYSV,.ffi_closure_SYSV_end-ffi_closure_SYSV\n-\n-\n-\t.section\t.eh_frame,EH_FRAME_FLAGS,@progbits\n-.Lframe1:\n-\t.4byte\t.LECIE1-.LSCIE1\t# Length of Common Information Entry\n-.LSCIE1:\n-\t.4byte\t0x0\t# CIE Identifier Tag\n-\t.byte\t0x1\t# CIE Version\n-\t.ascii \"zR\\0\"\t# CIE Augmentation\n-\t.uleb128 0x1\t# CIE Code Alignment Factor\n-\t.sleb128 -4\t# CIE Data Alignment Factor\n-\t.byte\t0xe\t# CIE RA Column\n-\t.uleb128 0x1\t# Augmentation size\n-\t.byte\t0x1b\t# FDE Encoding (pcrel sdata4)\n-\t.byte\t0xc\t# DW_CFA_def_cfa\n-\t.uleb128 0xf\n-\t.uleb128 0x60\n-\t.align\t4\n-.LECIE1:\n-.LSFDE1:\n-\t.4byte\t.LEFDE1-.LASFDE1\t# FDE Length\n-.LASFDE1:\n-\t.4byte\t.LASFDE1-.Lframe1\t# FDE CIE offset\n-\t.4byte\t.LFB1-.\t# FDE initial location\n-\t.4byte\t.LFE1-.LFB1\t# FDE address range\n-\t.uleb128 0x0\t# Augmentation size\n-\t.byte\t0x4\t# DW_CFA_advance_loc4\n-\t.4byte\t.LCFI0-.LFB1\n-\t.byte\t0x8f\t# DW_CFA_offset, column 0xf\n-\t.uleb128 0x9\n-\t.byte\t0x8e\t# DW_CFA_offset, column 0xe\n-\t.uleb128 0xa\n-\t.byte\t0x8d\t# DW_CFA_offset, column 0xd\n-\t.uleb128 0xb\n-\t.byte\t0x8c\t# DW_CFA_offset, column 0xc\n-\t.uleb128 0xc\n-\t.byte\t0x8b\t# DW_CFA_offset, column 0xb\n-\t.uleb128 0xd\n-\t.byte\t0x8a\t# DW_CFA_offset, column 0xa\n-\t.uleb128 0xe\n-\t.byte\t0x89\t# DW_CFA_offset, column 0x9\n-\t.uleb128 0xf\n-\t.byte\t0x88\t# DW_CFA_offset, column 0x8\n-\t.uleb128 0x10\n-\t.byte\t0x87\t# DW_CFA_offset, column 0x7\n-\t.uleb128 0x11\n-\t.byte\t0x86\t# DW_CFA_offset, column 0x6\n-\t.uleb128 0x12\n-\t.byte\t0x4\t# DW_CFA_advance_loc4\n-\t.4byte\t.LCFI1-.LCFI0\n-\t.byte\t0xd\t# DW_CFA_def_cfa_register\n-\t.uleb128 0xb\n-\t.byte\t0x4\t# DW_CFA_advance_loc4\n-\t.4byte\t.LCFI2-.LCFI1\n-\t.byte\t0xe\t# DW_CFA_def_cfa_offset\n-\t.uleb128 0x90\n-\t.align\t4\n-.LEFDE1:\n-.LSFDE2:\n-\t.4byte\t.LEFDE2-.LASFDE2\t# FDE Length\n-.LASFDE2:\n-\t.4byte\t.LASFDE2-.Lframe1\t# FDE CIE offset\n-\t.4byte\t.LFB2-.\t# FDE initial location\n-\t.4byte\t.LFE2-.LFB2\t# FDE address range\n-\t.uleb128 0x0\t# Augmentation size\n-\t.byte\t0x4\t# DW_CFA_advance_loc4\n-\t.4byte\t.LCFI10-.LFB2\n-\t.byte\t0x8f\t# DW_CFA_offset, column 0xf\n-\t.uleb128 0x9\n-\t.byte\t0x8e\t# DW_CFA_offset, column 0xe\n-\t.uleb128 0xa\n-\t.byte\t0x8d\t# DW_CFA_offset, column 0xd\n-\t.uleb128 0xb\n-\t.byte\t0x8c\t# DW_CFA_offset, column 0xc\n-\t.uleb128 0xc\n-\t.byte\t0x4\t# DW_CFA_advance_loc4\n-\t.4byte\t.LCFI11-.LCFI10\n-\t.byte\t0xe\t# DW_CFA_def_cfa_offset\n-\t.uleb128 0xc0\n-\t.align\t4\n-.LEFDE2:\n+\t.size\t ffi_closure_SYSV,.-ffi_closure_SYSV\n \n #else\n- \n-.text\n- \n-\t# r2:\tcif->bytes\n-\t# r3:\t&ecif\n-\t# r4:\tffi_prep_args\n-\t# r5:\tret_type\n-\t# r6:\tecif.rvalue\n-\t# ov:\tfn \n- \n+\n+\t# r2:\tframe\n+\t# r3:\tret_type\n+\t# r4:\tret_addr\n+\t# r5:\tfun\n+\t# r6:\tclosure\n+\n \t# This assumes we are using gas.\n+\t.balign\t8\n \t.globl\tffi_call_SYSV\n+\tFFI_HIDDEN(ffi_call_SYSV)\n \t.type\tffi_call_SYSV,%function\n ffi_call_SYSV:\n-.LFB1:\n-\tstmg\t%r6,%r15,48(%r15)\t\t# Save registers\n-.LCFI0:\n-\tlarl\t%r13,.Lbase\t\t\t# Set up base register\n-\tlgr\t%r11,%r15\t\t\t# Set up frame pointer\n-.LCFI1:\n-\tsgr\t%r15,%r2\n-\taghi\t%r15,-160-80\t\t\t# Allocate stack\n-\tlgr\t%r8,%r6\t\t\t\t# Save ecif.rvalue\n-\tllgc\t%r9,.Ltable-.Lbase(%r13,%r5)\t# Load epilog address\n-\tlg\t%r7,160(%r11)\t\t\t# Load function address\n-\tstg\t%r11,0(%r15)\t\t\t# Set up back chain\n-\taghi\t%r11,-80\t\t\t# Register save area\n-.LCFI2:\n-\n-\tla\t%r2,160(%r15)\t\t\t# Save area\n-\t\t\t\t\t\t# r3 already holds &ecif\n-\tbasr\t%r14,%r4\t\t\t# Call ffi_prep_args\n-\n-\tlmg\t%r2,%r6,0(%r11)\t\t\t# Load arguments\n-\tld\t%f0,48(%r11)\n-\tld\t%f2,56(%r11)\n-\tld\t%f4,64(%r11)\n-\tld\t%f6,72(%r11)\n-\tla\t%r14,0(%r13,%r9)\t\t# Set return address\n-\tbr\t%r7\t\t\t\t# ... and call function\n-\n-.Lbase:\n-.LretNone:\t\t\t\t\t# Return void\n-\tlg\t%r4,80+112(%r11)\n-\tlmg\t%r6,%r15,80+48(%r11)\n-\tbr\t%r4\n-\n-.LretFloat:\n-\tlg\t%r4,80+112(%r11)\n-\tste\t%f0,0(%r8)\t\t\t# Return float\n-\tlmg\t%r6,%r15,80+48(%r11)\n-\tbr\t%r4\n- \n-.LretDouble:\n-\tlg\t%r4,80+112(%r11)\n-\tstd\t%f0,0(%r8)\t\t\t# Return double\n-\tlmg\t%r6,%r15,80+48(%r11)\n-\tbr\t%r4\n-\n-.LretInt32:\n-\tlg\t%r4,80+112(%r11)\n-\tst\t%r2,0(%r8)\t\t\t# Return int\n-\tlmg\t%r6,%r15,80+48(%r11)\n-\tbr\t%r4\n- \n-.LretInt64:\n-\tlg\t%r4,80+112(%r11)\n-\tstg\t%r2,0(%r8)\t\t\t# Return long\n-\tlmg\t%r6,%r15,80+48(%r11)\n-\tbr\t%r4\n- \n+\t.cfi_startproc\n+\tstg\t%r6,88(%r2)\t\t\t# Save registers\n+\tstmg\t%r12,%r14,96(%r2)\n+\tlgr\t%r13,%r2\t\t\t# Install frame pointer\n+\t.cfi_rel_offset r6, 88\n+\t.cfi_rel_offset r12, 96\n+\t.cfi_rel_offset r13, 104\n+\t.cfi_rel_offset r14, 112\n+\t.cfi_def_cfa_register r13\n+\tstg\t%r2,0(%r15)\t\t\t# Set up back chain\n+\tlarl\t%r14,.Ltable\t\t\t# Set up return address\n+\tslag\t%r3,%r3,3\t\t\t# ret_type *= 8\n+\tlgr\t%r12,%r4\t\t\t# Save ret_addr\n+\tlgr\t%r1,%r5\t\t\t\t# Save fun\n+\tlgr\t%r0,%r6\t\t\t\t# Install static chain\n+\tagr\t%r14,%r3\n+\tlmg\t%r2,%r6,16(%r13)\t\t# Load arguments\n+\tld\t%f0,128(%r13)\n+\tld\t%f2,136(%r13)\n+\tld\t%f4,144(%r13)\n+\tld\t%f6,152(%r13)\n+\tbr\t%r1\t\t\t\t# ... and call function\n+\n+\t.balign\t8\n .Ltable:\n-\t.byte\t.LretNone-.Lbase\t\t# FFI390_RET_VOID\n-\t.byte\t.LretNone-.Lbase\t\t# FFI390_RET_STRUCT\n-\t.byte\t.LretFloat-.Lbase\t\t# FFI390_RET_FLOAT\n-\t.byte\t.LretDouble-.Lbase\t\t# FFI390_RET_DOUBLE\n-\t.byte\t.LretInt32-.Lbase\t\t# FFI390_RET_INT32\n-\t.byte\t.LretInt64-.Lbase\t\t# FFI390_RET_INT64\n+# FFI390_RET_DOUBLE\n+\tstd\t%f0,0(%r12)\n+\tj\t.Ldone\n+\n+\t.balign\t8\n+# FFI390_RET_DOUBLE\n+\tste\t%f0,0(%r12)\n+\tj\t.Ldone\n+\n+\t.balign\t8\n+# FFI390_RET_INT64\n+\tstg\t%r2,0(%r12)\n+\n+\t.balign\t8\n+# FFI390_RET_INT32\n+\t# Never used, as we always store type ffi_arg.\n+\t# But the stg above is 6 bytes and we cannot\n+\t# jump around this case, so fall through.\n+\tnop\n+\tnop\n+\n+\t.balign\t8\n+# FFI390_RET_VOID\n+.Ldone:\n+\tlg\t%r14,112(%r13)\n+\tlg\t%r12,96(%r13)\n+\tlg\t%r6,88(%r13)\n+\tlg\t%r13,104(%r13)\n+\t.cfi_restore r14\n+\t.cfi_restore r13\n+\t.cfi_restore r12\n+\t.cfi_restore r6\n+\t.cfi_def_cfa r15, 160\n+\tbr\t%r14\n+\t.cfi_endproc\n+\t.size\t ffi_call_SYSV,.-ffi_call_SYSV\n \n-.LFE1: \n-.ffi_call_SYSV_end:\n-\t.size\t ffi_call_SYSV,.ffi_call_SYSV_end-ffi_call_SYSV\n+\n+\t.balign\t8\n+\t.globl\tffi_go_closure_SYSV\n+\tFFI_HIDDEN(ffi_go_closure_SYSV)\n+\t.type\tffi_go_closure_SYSV,%function\n+ffi_go_closure_SYSV:\n+\t.cfi_startproc\n+\tstmg\t%r2,%r6,16(%r15)\t\t# Save arguments\n+\tlgr\t%r4,%r0\t\t\t\t# Load closure -> user_data\n+\tlg\t%r2,8(%r4)\t\t\t#   ->cif\n+\tlg\t%r3,16(%r4)\t\t\t#   ->fun\n+\tj\t.Ldoclosure\n+\t.cfi_endproc\n+\t.size\t ffi_go_closure_SYSV,.-ffi_go_closure_SYSV\n \n \n+\t.balign\t8\n \t.globl\tffi_closure_SYSV\n+\tFFI_HIDDEN(ffi_closure_SYSV)\n \t.type\tffi_closure_SYSV,%function\n ffi_closure_SYSV:\n-.LFB2:\n-\tstmg\t%r14,%r15,112(%r15)\t\t# Save registers\n-.LCFI10:\n+\t.cfi_startproc\n \tstmg\t%r2,%r6,16(%r15)\t\t# Save arguments\n-\tstd\t%f0,128(%r15)\n-\tstd\t%f2,136(%r15)\n-\tstd\t%f4,144(%r15)\n-\tstd\t%f6,152(%r15)\n-\tlgr\t%r1,%r15\t\t\t# Set up stack frame\n-\taghi\t%r15,-160\n-.LCFI11:\n-\tlgr\t%r2,%r0\t\t\t\t# Closure\n-\tla\t%r3,16(%r1)\t\t\t# GPRs\n-\tla\t%r4,128(%r1)\t\t\t# FPRs\n-\tla\t%r5,160(%r1)\t\t\t# Overflow\n-\tstg\t%r1,0(%r15)\t\t\t# Set up back chain\n-\n+\tlgr\t%r4,%r0\t\t\t\t# Load closure\n+\tlg\t%r2,32(%r4)\t\t\t#   ->cif\n+\tlg\t%r3,40(%r4)\t\t\t#   ->fun\n+\tlg\t%r4,48(%r4)\t\t\t#   ->user_data\n+.Ldoclosure:\n+\tstmg\t%r13,%r15,104(%r15)\t\t# Save registers\n+\tlgr\t%r13,%r15\n+\t.cfi_def_cfa_register r13\n+\t.cfi_rel_offset r6, 48\n+\t.cfi_rel_offset r13, 104\n+\t.cfi_rel_offset r14, 112\n+\t.cfi_rel_offset r15, 120\n+\taghi\t%r15,-160-16\t\t\t# Set up stack frame\n+\tstg\t%r13,0(%r15)\t\t\t# Set up back chain\n+\n+\tstd\t%f0,128(%r13)\t\t\t# Save fp arguments\n+\tstd\t%f2,136(%r13)\n+\tstd\t%f4,144(%r13)\n+\tstd\t%f6,152(%r13)\n+\tla\t%r5,160(%r13)\t\t\t# Overflow\n+\tstg\t%r5,160(%r15)\n+\tla\t%r6,128(%r13)\t\t\t# FPRs\n+\tla\t%r5,16(%r13)\t\t\t# GPRs\n \tbrasl\t%r14,ffi_closure_helper_SYSV\t# Call helper\n \n-\tlg\t%r14,160+112(%r15)\n-\tld\t%f0,160+128(%r15)\t\t# Load return registers\n-\tlg\t%r2,160+16(%r15)\n-\tla\t%r15,160(%r15)\n+\tlgr\t%r15,%r13\n+\t.cfi_def_cfa_register r15\n+\tlmg\t%r13,%r14,104(%r13)\t\t# Restore saved registers\n+\tlg\t%r6,48(%r15)\n+\tld\t%f0,128(%r15)\t\t\t# Load return registers\n+\tlg\t%r2,16(%r15)\n \tbr\t%r14\n-.LFE2: \n-\n-.ffi_closure_SYSV_end:\n-\t.size\t ffi_closure_SYSV,.ffi_closure_SYSV_end-ffi_closure_SYSV\n-\n-\n-\n-\t.section\t.eh_frame,EH_FRAME_FLAGS,@progbits\n-.Lframe1:\n-\t.4byte\t.LECIE1-.LSCIE1\t# Length of Common Information Entry\n-.LSCIE1:\n-\t.4byte\t0x0\t# CIE Identifier Tag\n-\t.byte\t0x1\t# CIE Version\n-\t.ascii \"zR\\0\"\t# CIE Augmentation\n-\t.uleb128 0x1\t# CIE Code Alignment Factor\n-\t.sleb128 -8\t# CIE Data Alignment Factor\n-\t.byte\t0xe\t# CIE RA Column\n-\t.uleb128 0x1\t# Augmentation size\n-\t.byte\t0x1b\t# FDE Encoding (pcrel sdata4)\n-\t.byte\t0xc\t# DW_CFA_def_cfa\n-\t.uleb128 0xf\n-\t.uleb128 0xa0\n-\t.align\t8\n-.LECIE1:\n-.LSFDE1:\n-\t.4byte\t.LEFDE1-.LASFDE1\t# FDE Length\n-.LASFDE1:\n-\t.4byte\t.LASFDE1-.Lframe1\t# FDE CIE offset\n-\t.4byte\t.LFB1-.\t# FDE initial location\n-\t.4byte\t.LFE1-.LFB1\t# FDE address range\n-\t.uleb128 0x0\t# Augmentation size\n-\t.byte\t0x4\t# DW_CFA_advance_loc4\n-\t.4byte\t.LCFI0-.LFB1\n-\t.byte\t0x8f\t# DW_CFA_offset, column 0xf\n-\t.uleb128 0x5\n-\t.byte\t0x8e\t# DW_CFA_offset, column 0xe\n-\t.uleb128 0x6\n-\t.byte\t0x8d\t# DW_CFA_offset, column 0xd\n-\t.uleb128 0x7\n-\t.byte\t0x8c\t# DW_CFA_offset, column 0xc\n-\t.uleb128 0x8\n-\t.byte\t0x8b\t# DW_CFA_offset, column 0xb\n-\t.uleb128 0x9\n-\t.byte\t0x8a\t# DW_CFA_offset, column 0xa\n-\t.uleb128 0xa\n-\t.byte\t0x89\t# DW_CFA_offset, column 0x9\n-\t.uleb128 0xb\n-\t.byte\t0x88\t# DW_CFA_offset, column 0x8\n-\t.uleb128 0xc\n-\t.byte\t0x87\t# DW_CFA_offset, column 0x7\n-\t.uleb128 0xd\n-\t.byte\t0x86\t# DW_CFA_offset, column 0x6\n-\t.uleb128 0xe\n-\t.byte\t0x4\t# DW_CFA_advance_loc4\n-\t.4byte\t.LCFI1-.LCFI0\n-\t.byte\t0xd\t# DW_CFA_def_cfa_register\n-\t.uleb128 0xb\n-\t.byte\t0x4\t# DW_CFA_advance_loc4\n-\t.4byte\t.LCFI2-.LCFI1\n-\t.byte\t0xe\t# DW_CFA_def_cfa_offset\n-\t.uleb128 0xf0\n-\t.align\t8\n-.LEFDE1:\n-.LSFDE2:\n-\t.4byte\t.LEFDE2-.LASFDE2\t# FDE Length\n-.LASFDE2:\n-\t.4byte\t.LASFDE2-.Lframe1\t# FDE CIE offset\n-\t.4byte\t.LFB2-.\t# FDE initial location\n-\t.4byte\t.LFE2-.LFB2\t# FDE address range\n-\t.uleb128 0x0\t# Augmentation size\n-\t.byte\t0x4\t# DW_CFA_advance_loc4\n-\t.4byte\t.LCFI10-.LFB2\n-\t.byte\t0x8f\t# DW_CFA_offset, column 0xf\n-\t.uleb128 0x5\n-\t.byte\t0x8e\t# DW_CFA_offset, column 0xe\n-\t.uleb128 0x6\n-\t.byte\t0x4\t# DW_CFA_advance_loc4\n-\t.4byte\t.LCFI11-.LCFI10\n-\t.byte\t0xe\t# DW_CFA_def_cfa_offset\n-\t.uleb128 0x140\n-\t.align\t8\n-.LEFDE2:\n-\n-#endif\n+\t.cfi_endproc\n+\t.size\t ffi_closure_SYSV,.-ffi_closure_SYSV\n+#endif /* !s390x */\n \n #if defined __ELF__ && defined __linux__\n \t.section\t.note.GNU-stack,\"\",@progbits"}, {"sha": "9ec86bfb205c8f7b8c6251ea4715c6c781b9502d", "filename": "libffi/src/sh/ffi.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fsh%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fsh%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsh%2Fffi.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -41,7 +41,7 @@\n #define STRUCT_VALUE_ADDRESS_WITH_ARG 0\n #endif\n \n-/* If the structure has essentialy an unique element, return its type.  */\n+/* If the structure has essentially an unique element, return its type.  */\n static int\n simple_type (ffi_type *arg)\n {"}, {"sha": "d5212d86e419f4b961d13c808ab48e4cf2934342", "filename": "libffi/src/sparc/ffi.c", "status": "modified", "additions": 329, "deletions": 584, "changes": 913, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fsparc%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fsparc%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsparc%2Fffi.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "patch": "@@ -1,7 +1,7 @@\n /* -----------------------------------------------------------------------\n-   ffi.c - Copyright (c) 2011 Anthony Green\n+   ffi.c - Copyright (c) 2011, 2013 Anthony Green\n            Copyright (c) 1996, 2003-2004, 2007-2008 Red Hat, Inc.\n-\n+   \n    SPARC Foreign Function Interface \n \n    Permission is hereby granted, free of charge, to any person obtaining\n@@ -27,697 +27,442 @@\n \n #include <ffi.h>\n #include <ffi_common.h>\n-\n #include <stdlib.h>\n+#include \"internal.h\"\n \n+#ifndef SPARC64\n \n-/* ffi_prep_args is called by the assembly routine once stack space\n-   has been allocated for the function's arguments */\n-\n-#ifdef SPARC64\n-\n-int\n-ffi_prep_args_v9(char *stack, extended_cif *ecif)\n-{\n-  int i, ret = 0;\n-  int tmp;\n-  void **p_argv;\n-  char *argp;\n-  ffi_type **p_arg;\n-\n-  tmp = 0;\n-\n-  /* Skip 16 words for the window save area */\n-  argp = stack + 16*sizeof(long long);\n-\n-#ifdef USING_PURIFY\n-  /* Purify will probably complain in our assembly routine, unless we\n-     zero out this memory. */\n-\n-  ((long long*)argp)[0] = 0;\n-  ((long long*)argp)[1] = 0;\n-  ((long long*)argp)[2] = 0;\n-  ((long long*)argp)[3] = 0;\n-  ((long long*)argp)[4] = 0;\n-  ((long long*)argp)[5] = 0;\n+/* Force FFI_TYPE_LONGDOUBLE to be different than FFI_TYPE_DOUBLE;\n+   all further uses in this file will refer to the 128-bit type.  */\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+# if FFI_TYPE_LONGDOUBLE != 4\n+#  error FFI_TYPE_LONGDOUBLE out of date\n+# endif\n+#else\n+# undef FFI_TYPE_LONGDOUBLE\n+# define FFI_TYPE_LONGDOUBLE 4\n #endif\n \n-  p_argv = ecif->avalue;\n+/* Perform machine dependent cif processing */\n+ffi_status FFI_HIDDEN\n+ffi_prep_cif_machdep(ffi_cif *cif)\n+{\n+  ffi_type *rtype = cif->rtype;\n+  int rtt = rtype->type;\n+  size_t bytes;\n+  int i, n, flags;\n \n-  if (ecif->cif->rtype->type == FFI_TYPE_STRUCT &&\n-      ecif->cif->rtype->size > 32)\n+  /* Set the return type flag */\n+  switch (rtt)\n     {\n-      *(unsigned long long *) argp = (unsigned long)ecif->rvalue;\n-      argp += sizeof(long long);\n-      tmp = 1;\n+    case FFI_TYPE_VOID:\n+      flags = SPARC_RET_VOID;\n+      break;\n+    case FFI_TYPE_FLOAT:\n+      flags = SPARC_RET_F_1;\n+      break;\n+    case FFI_TYPE_DOUBLE:\n+      flags = SPARC_RET_F_2;\n+      break;\n+    case FFI_TYPE_LONGDOUBLE:\n+    case FFI_TYPE_STRUCT:\n+      flags = (rtype->size & 0xfff) << SPARC_SIZEMASK_SHIFT;\n+      flags |= SPARC_RET_STRUCT;\n+      break;\n+    case FFI_TYPE_SINT8:\n+      flags = SPARC_RET_SINT8;\n+      break;\n+    case FFI_TYPE_UINT8:\n+      flags = SPARC_RET_UINT8;\n+      break;\n+    case FFI_TYPE_SINT16:\n+      flags = SPARC_RET_SINT16;\n+      break;\n+    case FFI_TYPE_UINT16:\n+      flags = SPARC_RET_UINT16;\n+      break;\n+    case FFI_TYPE_INT:\n+    case FFI_TYPE_SINT32:\n+    case FFI_TYPE_UINT32:\n+    case FFI_TYPE_POINTER:\n+      flags = SPARC_RET_UINT32;\n+      break;\n+    case FFI_TYPE_SINT64:\n+    case FFI_TYPE_UINT64:\n+      flags = SPARC_RET_INT64;\n+      break;\n+    case FFI_TYPE_COMPLEX:\n+      rtt = rtype->elements[0]->type;\n+      switch (rtt)\n+\t{\n+\tcase FFI_TYPE_FLOAT:\n+\t  flags = SPARC_RET_F_2;\n+\t  break;\n+\tcase FFI_TYPE_DOUBLE:\n+\t  flags = SPARC_RET_F_4;\n+\t  break;\n+\tcase FFI_TYPE_LONGDOUBLE:\n+\t  flags = SPARC_RET_F_8;\n+\t  break;\n+\tcase FFI_TYPE_SINT64:\n+\tcase FFI_TYPE_UINT64:\n+\t  flags = SPARC_RET_INT128;\n+\t  break;\n+\tcase FFI_TYPE_INT:\n+\tcase FFI_TYPE_SINT32:\n+\tcase FFI_TYPE_UINT32:\n+\t  flags = SPARC_RET_INT64;\n+\t  break;\n+\tcase FFI_TYPE_SINT16:\n+\tcase FFI_TYPE_UINT16:\n+\t  flags = SP_V8_RET_CPLX16;\n+\t  break;\n+\tcase FFI_TYPE_SINT8:\n+\tcase FFI_TYPE_UINT8:\n+\t  flags = SP_V8_RET_CPLX8;\n+\t  break;\n+\tdefault:\n+\t  abort();\n+\t}\n+      break;\n+    default:\n+      abort();\n     }\n+  cif->flags = flags;\n \n-  for (i = 0, p_arg = ecif->cif->arg_types; i < ecif->cif->nargs;\n-       i++, p_arg++)\n+  bytes = 0;\n+  for (i = 0, n = cif->nargs; i < n; ++i)\n     {\n-      size_t z;\n+      ffi_type *ty = cif->arg_types[i];\n+      size_t z = ty->size;\n+      int tt = ty->type;\n \n-      z = (*p_arg)->size;\n-      switch ((*p_arg)->type)\n+      switch (tt)\n \t{\n \tcase FFI_TYPE_STRUCT:\n-\t  if (z > 16)\n-\t    {\n-\t      /* For structures larger than 16 bytes we pass reference.  */\n-\t      *(unsigned long long *) argp = (unsigned long)* p_argv;\n-\t      argp += sizeof(long long);\n-\t      tmp++;\n-\t      p_argv++;\n-\t      continue;\n-\t    }\n-\t  /* FALLTHROUGH */\n-\tcase FFI_TYPE_FLOAT:\n-\tcase FFI_TYPE_DOUBLE:\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n \tcase FFI_TYPE_LONGDOUBLE:\n-#endif\n-\t  ret = 1; /* We should promote into FP regs as well as integer.  */\n+\tby_reference:\n+\t  /* Passed by reference.  */\n+\t  z = 4;\n \t  break;\n+\n+\tcase FFI_TYPE_COMPLEX:\n+\t  tt = ty->elements[0]->type;\n+\t  if (tt == FFI_TYPE_FLOAT || z > 8)\n+\t    goto by_reference;\n+\t  /* FALLTHRU */\n+\n+\tdefault:\n+\t  z = ALIGN(z, 4);\n \t}\n-      if (z < sizeof(long long))\n-\t{\n-\t  switch ((*p_arg)->type)\n-\t    {\n-\t    case FFI_TYPE_SINT8:\n-\t      *(signed long long *) argp = *(SINT8 *)(* p_argv);\n-\t      break;\n+      bytes += z;\n+    }\n \n-\t    case FFI_TYPE_UINT8:\n-\t      *(unsigned long long *) argp = *(UINT8 *)(* p_argv);\n-\t      break;\n+  /* Sparc call frames require that space is allocated for 6 args,\n+     even if they aren't used. Make that space if necessary.  */\n+  if (bytes < 6 * 4)\n+    bytes = 6 * 4;\n \n-\t    case FFI_TYPE_SINT16:\n-\t      *(signed long long *) argp = *(SINT16 *)(* p_argv);\n-\t      break;\n+  /* The ABI always requires space for the struct return pointer.  */\n+  bytes += 4;\n \n-\t    case FFI_TYPE_UINT16:\n-\t      *(unsigned long long *) argp = *(UINT16 *)(* p_argv);\n-\t      break;\n+  /* The stack must be 2 word aligned, so round bytes up appropriately. */\n+  bytes = ALIGN(bytes, 2 * 4);\n \n-\t    case FFI_TYPE_SINT32:\n-\t      *(signed long long *) argp = *(SINT32 *)(* p_argv);\n-\t      break;\n+  /* Include the call frame to prep_args.  */\n+  bytes += 4*16 + 4*8;\n+  cif->bytes = bytes;\n \n-\t    case FFI_TYPE_UINT32:\n-\t      *(unsigned long long *) argp = *(UINT32 *)(* p_argv);\n-\t      break;\n+  return FFI_OK;\n+}\n \n-\t    case FFI_TYPE_FLOAT:\n-\t      *(float *) (argp + 4) = *(FLOAT32 *)(* p_argv); /* Right justify */\n-\t      break;\n+extern void ffi_call_v8(ffi_cif *cif, void (*fn)(void), void *rvalue,\n+\t\t\tvoid **avalue, size_t bytes, void *closure) FFI_HIDDEN;\n \n-\t    case FFI_TYPE_STRUCT:\n-\t      memcpy(argp, *p_argv, z);\n-\t      break;\n+int FFI_HIDDEN\n+ffi_prep_args_v8(ffi_cif *cif, unsigned long *argp, void *rvalue, void **avalue)\n+{\n+  ffi_type **p_arg;\n+  int flags = cif->flags;\n+  int i, nargs;\n \n-\t    default:\n-\t      FFI_ASSERT(0);\n-\t    }\n-\t  z = sizeof(long long);\n-\t  tmp++;\n-\t}\n-      else if (z == sizeof(long long))\n+  if (rvalue == NULL)\n+    {\n+      if ((flags & SPARC_FLAG_RET_MASK) == SPARC_RET_STRUCT)\n \t{\n-\t  memcpy(argp, *p_argv, z);\n-\t  z = sizeof(long long);\n-\t  tmp++;\n+\t  /* Since we pass the pointer to the callee, we need a value.\n+\t     We allowed for this space in ffi_call, before ffi_call_v8\n+\t     alloca'd the space.  */\n+\t  rvalue = (char *)argp + cif->bytes;\n \t}\n       else\n \t{\n-\t  if ((tmp & 1) && (*p_arg)->alignment > 8)\n-\t    {\n-\t      tmp++;\n-\t      argp += sizeof(long long);\n-\t    }\n-\t  memcpy(argp, *p_argv, z);\n-\t  z = 2 * sizeof(long long);\n-\t  tmp += 2;\n+\t  /* Otherwise, we can ignore the return value.  */\n+\t  flags = SPARC_RET_VOID;\n \t}\n-      p_argv++;\n-      argp += z;\n     }\n \n-  return ret;\n-}\n-\n-#else\n-\n-void\n-ffi_prep_args_v8(char *stack, extended_cif *ecif)\n-{\n-  int i;\n-  void **p_argv;\n-  char *argp;\n-  ffi_type **p_arg;\n-\n-  /* Skip 16 words for the window save area */\n-  argp = stack + 16*sizeof(int);\n-\n-  /* This should only really be done when we are returning a structure,\n-     however, it's faster just to do it all the time...\n-\n-  if ( ecif->cif->rtype->type == FFI_TYPE_STRUCT ) */\n-  *(int *) argp = (long)ecif->rvalue;\n-\n-  /* And 1 word for the  structure return value. */\n-  argp += sizeof(int);\n+  /* This could only really be done when we are returning a structure.\n+     However, the space is reserved so we can do it unconditionally.  */\n+  *argp++ = (unsigned long)rvalue;\n \n #ifdef USING_PURIFY\n-  /* Purify will probably complain in our assembly routine, unless we\n-     zero out this memory. */\n-\n-  ((int*)argp)[0] = 0;\n-  ((int*)argp)[1] = 0;\n-  ((int*)argp)[2] = 0;\n-  ((int*)argp)[3] = 0;\n-  ((int*)argp)[4] = 0;\n-  ((int*)argp)[5] = 0;\n+  /* Purify will probably complain in our assembly routine,\n+     unless we zero out this memory. */\n+  memset(argp, 0, 6*4);\n #endif\n \n-  p_argv = ecif->avalue;\n-\n-  for (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types; i; i--, p_arg++)\n+  p_arg = cif->arg_types;\n+  for (i = 0, nargs = cif->nargs; i < nargs; i++)\n     {\n+      ffi_type *ty = p_arg[i];\n+      void *a = avalue[i];\n+      int tt = ty->type;\n       size_t z;\n \n-\t  if ((*p_arg)->type == FFI_TYPE_STRUCT\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\t      || (*p_arg)->type == FFI_TYPE_LONGDOUBLE\n-#endif\n-\t      )\n+      switch (tt)\n+\t{\n+\tcase FFI_TYPE_STRUCT:\n+\tcase FFI_TYPE_LONGDOUBLE:\n+\tby_reference:\n+\t  *argp++ = (unsigned long)a;\n+\t  break;\n+\n+\tcase FFI_TYPE_DOUBLE:\n+\tcase FFI_TYPE_UINT64:\n+\tcase FFI_TYPE_SINT64:\n+\t  memcpy(argp, a, 8);\n+\t  argp += 2;\n+\t  break;\n+\n+\tcase FFI_TYPE_INT:\n+\tcase FFI_TYPE_FLOAT:\n+\tcase FFI_TYPE_UINT32:\n+\tcase FFI_TYPE_SINT32:\n+\tcase FFI_TYPE_POINTER:\n+\t  *argp++ = *(unsigned *)a;\n+\t  break;\n+\n+\tcase FFI_TYPE_UINT8:\n+\t  *argp++ = *(UINT8 *)a;\n+\t  break;\n+\tcase FFI_TYPE_SINT8:\n+\t  *argp++ = *(SINT8 *)a;\n+\t  break;\n+\tcase FFI_TYPE_UINT16:\n+\t  *argp++ = *(UINT16 *)a;\n+\t  break;\n+\tcase FFI_TYPE_SINT16:\n+\t  *argp++ = *(SINT16 *)a;\n+\t  break;\n+\n+        case FFI_TYPE_COMPLEX:\n+\t  tt = ty->elements[0]->type;\n+\t  z = ty->size;\n+\t  if (tt == FFI_TYPE_FLOAT || z > 8)\n+\t    goto by_reference;\n+\t  if (z < 4)\n \t    {\n-\t      *(unsigned int *) argp = (unsigned long)(* p_argv);\n-\t      z = sizeof(int);\n+\t      memcpy((char *)argp + 4 - z, a, z);\n+\t      argp++;\n \t    }\n \t  else\n \t    {\n-\t      z = (*p_arg)->size;\n-\t      if (z < sizeof(int))\n-\t\t{\n-\t\t  z = sizeof(int);\n-\t\t  switch ((*p_arg)->type)\n-\t\t    {\n-\t\t    case FFI_TYPE_SINT8:\n-\t\t      *(signed int *) argp = *(SINT8 *)(* p_argv);\n-\t\t      break;\n-\t\t      \n-\t\t    case FFI_TYPE_UINT8:\n-\t\t      *(unsigned int *) argp = *(UINT8 *)(* p_argv);\n-\t\t      break;\n-\t\t      \n-\t\t    case FFI_TYPE_SINT16:\n-\t\t      *(signed int *) argp = *(SINT16 *)(* p_argv);\n-\t\t      break;\n-\t\t      \n-\t\t    case FFI_TYPE_UINT16:\n-\t\t      *(unsigned int *) argp = *(UINT16 *)(* p_argv);\n-\t\t      break;\n-\n-\t\t    default:\n-\t\t      FFI_ASSERT(0);\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  memcpy(argp, *p_argv, z);\n-\t\t}\n+\t      memcpy(argp, a, z);\n+\t      argp += z / 4;\n \t    }\n-\t  p_argv++;\n-\t  argp += z;\n-    }\n-  \n-  return;\n-}\n-\n-#endif\n-\n-/* Perform machine dependent cif processing */\n-\n-static\n-ffi_status ffi_prep_cif_machdep_core(ffi_cif *cif)\n-{\n-  int wordsize;\n-\n-  if (!V9_ABI_P (cif->abi))\n-    {\n-      wordsize = 4;\n-\n-      /* If we are returning a struct, this will already have been added.\n-\t Otherwise we need to add it because it's always got to be there! */\n-\n-      if (cif->rtype->type != FFI_TYPE_STRUCT)\n-\tcif->bytes += wordsize;\n-\n-      /* sparc call frames require that space is allocated for 6 args,\n-\t even if they aren't used. Make that space if necessary. */\n-  \n-      if (cif->bytes < 4*6+4)\n-\tcif->bytes = 4*6+4;\n-    }\n-  else\n-    {\n-      wordsize = 8;\n+\t  break;\n \n-      /* sparc call frames require that space is allocated for 6 args,\n-\t even if they aren't used. Make that space if necessary. */\n-  \n-      if (cif->bytes < 8*6)\n-\tcif->bytes = 8*6;\n+\tdefault:\n+\t  abort();\n+\t}\n     }\n \n-  /* Adjust cif->bytes. to include 16 words for the window save area,\n-     and maybe the struct/union return pointer area, */\n-\n-  cif->bytes += 16 * wordsize;\n-\n-  /* The stack must be 2 word aligned, so round bytes up\n-     appropriately. */\n-\n-  cif->bytes = ALIGN(cif->bytes, 2 * wordsize);\n+  return flags;\n+}\n \n-  /* Set the return type flag */\n-  switch (cif->rtype->type)\n-    {\n-    case FFI_TYPE_VOID:\n-    case FFI_TYPE_FLOAT:\n-    case FFI_TYPE_DOUBLE:\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-    case FFI_TYPE_LONGDOUBLE:\n-#endif\n-      cif->flags = cif->rtype->type;\n-      break;\n+static void\n+ffi_call_int (ffi_cif *cif, void (*fn)(void), void *rvalue,\n+\t      void **avalue, void *closure)\n+{\n+  size_t bytes = cif->bytes;\n \n-    case FFI_TYPE_STRUCT:\n-      if (V9_ABI_P (cif->abi) && cif->rtype->size > 32)\n-\tcif->flags = FFI_TYPE_VOID;\n-      else\n-\tcif->flags = FFI_TYPE_STRUCT;\n-      break;\n+  FFI_ASSERT (cif->abi == FFI_V8);\n \n-    case FFI_TYPE_SINT8:\n-    case FFI_TYPE_UINT8:\n-    case FFI_TYPE_SINT16:\n-    case FFI_TYPE_UINT16:\n-      if (V9_ABI_P (cif->abi))\n-\tcif->flags = FFI_TYPE_INT;\n-      else\n-\tcif->flags = cif->rtype->type;\n-      break;\n+  /* If we've not got a return value, we need to create one if we've\n+     got to pass the return value to the callee.  Otherwise ignore it.  */\n+  if (rvalue == NULL\n+      && (cif->flags & SPARC_FLAG_RET_MASK) == SPARC_RET_STRUCT)\n+    bytes += ALIGN (cif->rtype->size, 8);\n \n-    case FFI_TYPE_SINT64:\n-    case FFI_TYPE_UINT64:\n-      if (V9_ABI_P (cif->abi))\n-\tcif->flags = FFI_TYPE_INT;\n-      else\n-\tcif->flags = FFI_TYPE_SINT64;\n-      break;\n-\n-    default:\n-      cif->flags = FFI_TYPE_INT;\n-      break;\n-    }\n-  return FFI_OK;\n+  ffi_call_v8(cif, fn, rvalue, avalue, -bytes, closure);\n }\n \n-ffi_status\n-ffi_prep_cif_machdep(ffi_cif *cif)\n+void\n+ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n {\n-#ifdef SPARC64\n-  if (cif->abi != FFI_COMPAT_V9)\n-    cif->nfixedargs = cif->nargs;\n-#endif\n-  return ffi_prep_cif_machdep_core (cif);\n+  ffi_call_int (cif, fn, rvalue, avalue, NULL);\n }\n \n-ffi_status\n-ffi_prep_cif_machdep_var(ffi_cif *cif, unsigned int nfixedargs,\n-\t\t\t unsigned int ntotalargs)\n+void\n+ffi_call_go (ffi_cif *cif, void (*fn)(void), void *rvalue,\n+\t     void **avalue, void *closure)\n {\n-#ifdef SPARC64\n-  if (cif->abi != FFI_COMPAT_V9)\n-    cif->nfixedargs = nfixedargs;\n-#endif\n-  return ffi_prep_cif_machdep_core (cif);\n+  ffi_call_int (cif, fn, rvalue, avalue, closure);\n }\n \n-#ifdef SPARC64\n-\n-int\n-ffi_v9_layout_struct(ffi_type *arg, int off, char *ret, char *intg, char *flt)\n+#ifdef __GNUC__\n+static inline void\n+ffi_flush_icache (void *p)\n {\n-  ffi_type **ptr = &arg->elements[0];\n-\n-  while (*ptr != NULL)\n-    {\n-      if (off & ((*ptr)->alignment - 1))\n-\toff = ALIGN(off, (*ptr)->alignment);\n-\n-      switch ((*ptr)->type)\n-\t{\n-\tcase FFI_TYPE_STRUCT:\n-\t  off = ffi_v9_layout_struct(*ptr, off, ret, intg, flt);\n-\t  off = ALIGN(off, FFI_SIZEOF_ARG);\n-\t  break;\n-\tcase FFI_TYPE_FLOAT:\n-\tcase FFI_TYPE_DOUBLE:\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\tcase FFI_TYPE_LONGDOUBLE:\n-#endif\n-\t  memmove(ret + off, flt + off, (*ptr)->size);\n-\t  off += (*ptr)->size;\n-\t  break;\n-\tdefault:\n-\t  memmove(ret + off, intg + off, (*ptr)->size);\n-\t  off += (*ptr)->size;\n-\t  break;\n-\t}\n-      ptr++;\n-    }\n-  return off;\n+  /* SPARC v8 requires 5 instructions for flush to be visible */\n+  asm volatile (\"iflush\t%0; iflush %0+8; nop; nop; nop; nop; nop\"\n+\t\t: : \"r\" (p) : \"memory\");\n }\n-\n-#endif\n-\n-#ifdef SPARC64\n-extern int ffi_call_v9(void *, extended_cif *, unsigned, \n-\t\t       unsigned, unsigned *, void (*fn)(void));\n-#else\n-extern int ffi_call_v8(void *, extended_cif *, unsigned, \n-\t\t       unsigned, unsigned *, void (*fn)(void));\n-#endif\n-\n-void\n-ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n-{\n-  extended_cif ecif;\n-#ifdef SPARC64\n-  void *rval = rvalue;\n-#endif\n-\n-  ecif.cif = cif;\n-  ecif.avalue = avalue;\n-  ecif.rvalue = rvalue;\n-\n-  /* If the return value is a struct and we don't have a return value address,\n-     then we need to make one.  */\n-  if (cif->rtype->type == FFI_TYPE_STRUCT)\n-    {\n-      if (ecif.rvalue == NULL)\n-\tecif.rvalue = alloca(cif->rtype->size);\n-\n-#ifdef SPARC64\n-      if (cif->rtype->size <= 32)\n-\trval = alloca(64);\n-      else\n-\trval = NULL;\n-#endif\n-    }\n-\n-  switch (cif->abi) \n-    {\n-    case FFI_V8:\n-    case FFI_V8PLUS:\n-#ifdef SPARC64\n-      /* We don't yet support calling 32bit code from 64bit */\n-      FFI_ASSERT(0);\n #else\n-      if (rvalue && (cif->rtype->type == FFI_TYPE_STRUCT\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\t  || cif->flags == FFI_TYPE_LONGDOUBLE\n+extern void ffi_flush_icache (void *) FFI_HIDDEN;\n #endif\n-\t  ))\n-\t{\n-\t  /* For v8, we need an \"unimp\" with size of returning struct */\n-\t  /* behind \"call\", so we alloc some executable space for it. */\n-\t  /* l7 is used, we need to make sure v8.S doesn't use %l7.   */\n-\t  unsigned int *call_struct = NULL;\n-\t  ffi_closure_alloc(32, (void **)&call_struct);\n-\t  if (call_struct)\n-\t    {\n-\t      unsigned long f = (unsigned long)fn;\n-\t      call_struct[0] = 0xae10001f;\t\t /* mov   %i7, %l7\t */\n-\t      call_struct[1] = 0xbe10000f;\t\t /* mov   %o7, %i7\t */\n-\t      call_struct[2] = 0x03000000 | f >> 10;     /* sethi %hi(fn), %g1\t */\n-\t      call_struct[3] = 0x9fc06000 | (f & 0x3ff); /* jmp %g1+%lo(fn), %o7 */\n-\t      call_struct[4] = 0x01000000;\t\t /* nop\t\t\t */\n-\t      if (cif->rtype->size < 0x7f)\n-\t\tcall_struct[5] = cif->rtype->size;\t /* unimp\t\t */\n-\t      else\n-\t\tcall_struct[5] = 0x01000000;\t     \t /* nop\t\t\t */\n-\t      call_struct[6] = 0x81c7e008;\t\t /* ret\t\t\t */\n-\t      call_struct[7] = 0xbe100017;\t\t /* mov   %l7, %i7\t */\n-\t      asm volatile (\"iflush %0; iflush %0+8; iflush %0+16; iflush %0+24\" : :\n-\t\t\t    \"r\" (call_struct) : \"memory\");\n-\t      /* SPARC v8 requires 5 instructions for flush to be visible */\n-\t      asm volatile (\"nop; nop; nop; nop; nop\");\n-\t      ffi_call_v8(ffi_prep_args_v8, &ecif, cif->bytes,\n-\t\t\t  cif->flags, rvalue, (void (*)(void)) call_struct);\n-\t      ffi_closure_free(call_struct);\n-\t    }\n-\t  else\n-\t    {\n-\t      ffi_call_v8(ffi_prep_args_v8, &ecif, cif->bytes,\n-\t\t\t  cif->flags, rvalue, fn);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  ffi_call_v8(ffi_prep_args_v8, &ecif, cif->bytes,\n-\t\t      cif->flags, rvalue, fn);\n-\t}\n-#endif\n-      break;\n-    case FFI_COMPAT_V9:\n-    case FFI_V9:\n-#ifdef SPARC64\n-      ffi_call_v9(ffi_prep_args_v9, &ecif, cif->bytes, cif->flags, rval, fn);\n-      if (rvalue && rval && cif->rtype->type == FFI_TYPE_STRUCT)\n-\tffi_v9_layout_struct(cif->rtype, 0, (char *)rvalue, (char *)rval,\n-\t\t\t     ((char *)rval)+32);\n-#else\n-      /* And vice versa */\n-      FFI_ASSERT(0);\n-#endif\n-      break;\n-    default:\n-      FFI_ASSERT(0);\n-      break;\n-    }\n-}\n \n-\n-#ifdef SPARC64\n-extern void ffi_closure_v9(void);\n-#else\n-extern void ffi_closure_v8(void);\n-#endif\n+extern void ffi_closure_v8(void) FFI_HIDDEN;\n+extern void ffi_go_closure_v8(void) FFI_HIDDEN;\n \n ffi_status\n-ffi_prep_closure_loc (ffi_closure* closure,\n-\t\t      ffi_cif* cif,\n+ffi_prep_closure_loc (ffi_closure *closure,\n+\t\t      ffi_cif *cif,\n \t\t      void (*fun)(ffi_cif*, void*, void**, void*),\n \t\t      void *user_data,\n \t\t      void *codeloc)\n {\n   unsigned int *tramp = (unsigned int *) &closure->tramp[0];\n-  unsigned long fn;\n-#ifdef SPARC64\n-  /* Trampoline address is equal to the closure address.  We take advantage\n-     of that to reduce the trampoline size by 8 bytes. */\n-  if (!V9_ABI_P (cif->abi))\n-    return FFI_BAD_ABI;\n-  fn = (unsigned long) ffi_closure_v9;\n-  tramp[0] = 0x83414000;\t/* rd\t%pc, %g1\t*/\n-  tramp[1] = 0xca586010;\t/* ldx\t[%g1+16], %g5\t*/\n-  tramp[2] = 0x81c14000;\t/* jmp\t%g5\t\t*/\n-  tramp[3] = 0x01000000;\t/* nop\t\t\t*/\n-  *((unsigned long *) &tramp[4]) = fn;\n-#else\n-  unsigned long ctx = (unsigned long) codeloc;\n-  if (!V8_ABI_P (cif->abi))\n+  unsigned long ctx = (unsigned long) closure;\n+  unsigned long fn = (unsigned long) ffi_closure_v8;\n+\n+  if (cif->abi != FFI_V8)\n     return FFI_BAD_ABI;\n-  fn = (unsigned long) ffi_closure_v8;\n+\n   tramp[0] = 0x03000000 | fn >> 10;\t/* sethi %hi(fn), %g1\t*/\n   tramp[1] = 0x05000000 | ctx >> 10;\t/* sethi %hi(ctx), %g2\t*/\n   tramp[2] = 0x81c06000 | (fn & 0x3ff);\t/* jmp   %g1+%lo(fn)\t*/\n   tramp[3] = 0x8410a000 | (ctx & 0x3ff);/* or    %g2, %lo(ctx)\t*/\n-#endif\n \n   closure->cif = cif;\n   closure->fun = fun;\n   closure->user_data = user_data;\n \n-  /* Flush the Icache.  closure is 8 bytes aligned.  */\n-#ifdef SPARC64\n-  asm volatile (\"flush\t%0; flush %0+8\" : : \"r\" (closure) : \"memory\");\n-#else\n-  asm volatile (\"iflush\t%0; iflush %0+8\" : : \"r\" (closure) : \"memory\");\n-  /* SPARC v8 requires 5 instructions for flush to be visible */\n-  asm volatile (\"nop; nop; nop; nop; nop\");\n-#endif\n+  ffi_flush_icache (closure);\n \n   return FFI_OK;\n }\n \n-#ifdef SPARC64\n+ffi_status\n+ffi_prep_go_closure (ffi_go_closure *closure, ffi_cif *cif,\n+\t\t     void (*fun)(ffi_cif*, void*, void**, void*))\n+{\n+  if (cif->abi != FFI_V8)\n+    return FFI_BAD_ABI;\n \n-int\n-ffi_closure_sparc_inner_v9(ffi_closure *closure, void *rvalue,\n-\t\t\t   unsigned long *gpr, double *fpr)\n+  closure->tramp = ffi_go_closure_v8;\n+  closure->cif = cif;\n+  closure->fun = fun;\n+\n+  return FFI_OK;\n+}\n+\n+int FFI_HIDDEN\n+ffi_closure_sparc_inner_v8(ffi_cif *cif, \n+\t\t\t   void (*fun)(ffi_cif*, void*, void**, void*),\n+\t\t\t   void *user_data, void *rvalue,\n+\t\t\t   unsigned long *argp)\n {\n-  ffi_cif *cif;\n   ffi_type **arg_types;\n   void **avalue;\n-  int i, argn, fp_slot_max;\n+  int i, nargs, flags;\n \n-  cif = closure->cif;\n   arg_types = cif->arg_types;\n-  avalue = alloca(cif->nargs * sizeof(void *));\n+  nargs = cif->nargs;\n+  flags = cif->flags;\n+  avalue = alloca(nargs * sizeof(void *));\n \n   /* Copy the caller's structure return address so that the closure\n-     returns the data directly to the caller.  */\n-  if (cif->flags == FFI_TYPE_VOID && cif->rtype->type == FFI_TYPE_STRUCT)\n+     returns the data directly to the caller.  Also install it so we\n+     can return the address in %o0.  */\n+  if ((flags & SPARC_FLAG_RET_MASK) == SPARC_RET_STRUCT)\n     {\n-      rvalue = (void *) gpr[0];\n-      /* Skip the structure return address.  */\n-      argn = 1;\n+      void *new_rvalue = (void *)*argp;\n+      *(void **)rvalue = new_rvalue;\n+      rvalue = new_rvalue;\n     }\n-  else\n-    argn = 0;\n \n-  fp_slot_max = 16 - argn;\n+  /* Always skip the structure return address.  */\n+  argp++;\n \n   /* Grab the addresses of the arguments from the stack frame.  */\n-  for (i = 0; i < cif->nargs; i++)\n+  for (i = 0; i < nargs; i++)\n     {\n-      /* If the function is variadic, FP arguments are passed in FP\n-\t registers only if the corresponding parameter is named.  */\n-      const int named\n-\t= (cif->abi == FFI_COMPAT_V9 ? 1 : i < cif->nfixedargs);\n+      ffi_type *ty = arg_types[i];\n+      int tt = ty->type;\n+      void *a = argp;\n+      size_t z;\n \n-      if (arg_types[i]->type == FFI_TYPE_STRUCT)\n+      switch (tt)\n \t{\n-\t  if (arg_types[i]->size > 16)\n-\t    {\n-\t      /* Straight copy of invisible reference.  */\n-\t      avalue[i] = (void *)gpr[argn++];\n-\t    }\n-\t  else\n+\tcase FFI_TYPE_STRUCT:\n+\tcase FFI_TYPE_LONGDOUBLE:\n+\tby_reference:\n+\t  /* Straight copy of invisible reference.  */\n+\t  a = (void *)*argp;\n+\t  break;\n+\n+\tcase FFI_TYPE_DOUBLE:\n+\tcase FFI_TYPE_SINT64:\n+\tcase FFI_TYPE_UINT64:\n+\t  if ((unsigned long)a & 7)\n \t    {\n-\t      /* Left-justify.  */\n-\t      ffi_v9_layout_struct(arg_types[i],\n-\t\t\t\t   0,\n-\t\t\t\t   (char *) &gpr[argn],\n-\t\t\t\t   (char *) &gpr[argn],\n-\t\t\t\t   named\n-\t\t\t\t   ? (char *) &fpr[argn]\n-\t\t\t\t   : (char *) &gpr[argn]);\n-\t      avalue[i] = &gpr[argn];\n-\t      argn\n-\t        += ALIGN(arg_types[i]->size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n+\t      /* Align on a 8-byte boundary.  */\n+\t      UINT64 *tmp = alloca(8);\n+\t      *tmp = ((UINT64)argp[0] << 32) | argp[1];\n+\t      a = tmp;\n \t    }\n-\t}\n-      else\n-\t{\n-\t  /* Right-justify.  */\n-\t  argn += ALIGN(arg_types[i]->size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n-\n-\t  /* Align on a 16-byte boundary.  */\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\t  if (arg_types[i]->type == FFI_TYPE_LONGDOUBLE && (argn % 2) != 0)\n-\t    argn++;\n-#endif\n-\t  if (i < fp_slot_max\n-\t      && named\n-\t      && (arg_types[i]->type == FFI_TYPE_FLOAT\n-\t\t  || arg_types[i]->type == FFI_TYPE_DOUBLE\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\t\t  || arg_types[i]->type == FFI_TYPE_LONGDOUBLE\n-#endif\n-\t\t  ))\n-\t    avalue[i] = ((char *) &fpr[argn]) - arg_types[i]->size;\n-\t  else\n-\t    avalue[i] = ((char *) &gpr[argn]) - arg_types[i]->size;\n-\t}\n-    }\n-\n-  /* Invoke the closure.  */\n-  closure->fun (cif, rvalue, avalue, closure->user_data);\n-\n-  /* Tell ffi_closure_sparc how to perform return type promotions.  */\n-  return cif->rtype->type;\n-}\n-\n-#else\n-\n-int\n-ffi_closure_sparc_inner_v8(ffi_closure *closure, void *rvalue,\n-\t\t\t   unsigned long *gpr, unsigned long *scratch)\n-{\n-  ffi_cif *cif;\n-  ffi_type **arg_types;\n-  void **avalue;\n-  int i, argn;\n-\n-  cif = closure->cif;\n-  arg_types = cif->arg_types;\n-  avalue = alloca(cif->nargs * sizeof(void *));\n+\t  argp++;\n+\t  break;\n \n-  /* Copy the caller's structure return address so that the closure\n-     returns the data directly to the caller.  */\n-  if (cif->flags == FFI_TYPE_STRUCT\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE  \n-      || cif->flags == FFI_TYPE_LONGDOUBLE\n-#endif\n-     )\n-    rvalue = (void *) gpr[0];\n+\tcase FFI_TYPE_INT:\n+\tcase FFI_TYPE_FLOAT:\n+\tcase FFI_TYPE_UINT32:\n+\tcase FFI_TYPE_SINT32:\n+\tcase FFI_TYPE_POINTER:\n+\t  break;\n+        case FFI_TYPE_UINT16:\n+        case FFI_TYPE_SINT16:\n+\t  a += 2;\n+\t  break;\n+        case FFI_TYPE_UINT8:\n+        case FFI_TYPE_SINT8:\n+\t  a += 3;\n+\t  break;\n \n-  /* Always skip the structure return address.  */\n-  argn = 1;\n+        case FFI_TYPE_COMPLEX:\n+\t  tt = ty->elements[0]->type;\n+\t  z = ty->size;\n+\t  if (tt == FFI_TYPE_FLOAT || z > 8)\n+\t    goto by_reference;\n+\t  if (z < 4)\n+\t    a += 4 - z;\n+\t  else if (z > 4)\n+\t    argp++;\n+\t  break;\n \n-  /* Grab the addresses of the arguments from the stack frame.  */\n-  for (i = 0; i < cif->nargs; i++)\n-    {\n-      if (arg_types[i]->type == FFI_TYPE_STRUCT\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\t  || arg_types[i]->type == FFI_TYPE_LONGDOUBLE\n-#endif\n-         )\n-\t{\n-\t  /* Straight copy of invisible reference.  */\n-\t  avalue[i] = (void *)gpr[argn++];\n-\t}\n-      else if ((arg_types[i]->type == FFI_TYPE_DOUBLE\n-\t       || arg_types[i]->type == FFI_TYPE_SINT64\n-\t       || arg_types[i]->type == FFI_TYPE_UINT64)\n-\t       /* gpr is 8-byte aligned.  */\n-\t       && (argn % 2) != 0)\n-\t{\n-\t  /* Align on a 8-byte boundary.  */\n-\t  scratch[0] = gpr[argn];\n-\t  scratch[1] = gpr[argn+1];\n-\t  avalue[i] = scratch;\n-\t  scratch -= 2;\n-\t  argn += 2;\n-\t}\n-      else\n-\t{\n-\t  /* Always right-justify.  */\n-\t  argn += ALIGN(arg_types[i]->size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n-\t  avalue[i] = ((char *) &gpr[argn]) - arg_types[i]->size;\n+\tdefault:\n+\t  abort();\n \t}\n+      argp++;\n+      avalue[i] = a;\n     }\n \n   /* Invoke the closure.  */\n-  closure->fun (cif, rvalue, avalue, closure->user_data);\n+  fun (cif, rvalue, avalue, user_data);\n \n   /* Tell ffi_closure_sparc how to perform return type promotions.  */\n-  return cif->rtype->type;\n+  return flags;\n }\n-\n-#endif\n+#endif /* !SPARC64 */"}, {"sha": "340b19823211d973d9ecf5a76dc8d273e2f92cc5", "filename": "libffi/src/sparc/ffi64.c", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fsparc%2Fffi64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fsparc%2Fffi64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsparc%2Fffi64.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "2f4cd9a7a93369d0bc6984193f7960c911aeebb2", "filename": "libffi/src/sparc/ffitarget.h", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fsparc%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fsparc%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsparc%2Fffitarget.h?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "0a66472bade87c84f49428ba2464c4548f6c2e08", "filename": "libffi/src/sparc/internal.h", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fsparc%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fsparc%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsparc%2Finternal.h?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "3a811efe05f42d887ec763ff990868082e4cab09", "filename": "libffi/src/sparc/v8.S", "status": "modified", "additions": 290, "deletions": 245, "changes": 535, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fsparc%2Fv8.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fsparc%2Fv8.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsparc%2Fv8.S?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "52732d364ea2d97aa9190f3886d4ad29b98e1608", "filename": "libffi/src/sparc/v9.S", "status": "modified", "additions": 288, "deletions": 216, "changes": 504, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fsparc%2Fv9.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fsparc%2Fv9.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsparc%2Fv9.S?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "d1f82cb3dbfa8559db679ea2ac63b8fe2193a112", "filename": "libffi/src/tile/tile.S", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Ftile%2Ftile.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Ftile%2Ftile.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Ftile%2Ftile.S?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "7e80aec6eb4b66da2a583cbb159da450dff6cd50", "filename": "libffi/src/types.c", "status": "modified", "additions": 41, "deletions": 27, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Ftypes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Ftypes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Ftypes.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "01ca313402b20e2f5b7aff45d2c08995b78da2d6", "filename": "libffi/src/vax/elfbsd.S", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fvax%2Felfbsd.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fvax%2Felfbsd.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fvax%2Felfbsd.S?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "f4d6bbb4f404667a0defe88c9b2e4765e008aa37", "filename": "libffi/src/vax/ffi.c", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fvax%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fvax%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fvax%2Fffi.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "2fc94881abbc3533bb94aa2c928b263abb633ced", "filename": "libffi/src/vax/ffitarget.h", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fvax%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fvax%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fvax%2Fffitarget.h?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "1daa1c0b6fd84ea47acd27a1d16047265ee980eb", "filename": "libffi/src/x86/darwin64_c.c", "status": "added", "additions": 643, "deletions": 0, "changes": 643, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fx86%2Fdarwin64_c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fx86%2Fdarwin64_c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fdarwin64_c.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "6338de2a0f227b261fc6bce737b509c21c4ebe22", "filename": "libffi/src/x86/darwin_c.c", "status": "added", "additions": 843, "deletions": 0, "changes": 843, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fx86%2Fdarwin_c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fx86%2Fdarwin_c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fdarwin_c.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "3885e3995016aa7c0f825a7f8846ed0344b8ce5d", "filename": "libffi/src/x86/ffi.c", "status": "modified", "additions": 580, "deletions": 698, "changes": 1278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fx86%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fx86%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fffi.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "131b5e3d14864130b7eef16896fadf07680617b3", "filename": "libffi/src/x86/ffi64.c", "status": "modified", "additions": 291, "deletions": 110, "changes": 401, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fx86%2Fffi64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fx86%2Fffi64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fffi64.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "8c1dcac2a24d6e8b80e940821029b6021371c868", "filename": "libffi/src/x86/ffitarget.h", "status": "modified", "additions": 40, "deletions": 41, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fx86%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fx86%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fffitarget.h?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "8a33a6c478568f99b6f109c2e21ba5424678982a", "filename": "libffi/src/x86/ffiw64.c", "status": "added", "additions": 281, "deletions": 0, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fx86%2Fffiw64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fx86%2Fffiw64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fffiw64.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "afde513164e4b5ebbf0bd2acc426a32d2d7a9652", "filename": "libffi/src/x86/freebsd.S", "status": "removed", "additions": 0, "deletions": 458, "changes": 458, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e22fcb7985349b93646b86351033e1fb09c46c/libffi%2Fsrc%2Fx86%2Ffreebsd.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e22fcb7985349b93646b86351033e1fb09c46c/libffi%2Fsrc%2Fx86%2Ffreebsd.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Ffreebsd.S?ref=62e22fcb7985349b93646b86351033e1fb09c46c"}, {"sha": "09771ba8cfb279e3f4b8bf60e7da89e5726f722e", "filename": "libffi/src/x86/internal.h", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fx86%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fx86%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Finternal.h?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "512e95523e92a7e8a3b75d7d328ad706ad5ee8bd", "filename": "libffi/src/x86/internal64.h", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fx86%2Finternal64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fx86%2Finternal64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Finternal64.h?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "ebbea5d1110215c5d30fe2fcb39ed2a12f5deb1d", "filename": "libffi/src/x86/sysv.S", "status": "modified", "additions": 970, "deletions": 400, "changes": 1370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fx86%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fx86%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fsysv.S?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "f9f916312c5c511ac196094d8774bf8f78e8226c", "filename": "libffi/src/x86/unix64.S", "status": "modified", "additions": 419, "deletions": 299, "changes": 718, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fx86%2Funix64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fx86%2Funix64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Funix64.S?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "24b7bbd04235b6aa6c79848343aa8b21ad1a9078", "filename": "libffi/src/x86/win32.S", "status": "removed", "additions": 0, "deletions": 1201, "changes": 1201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e22fcb7985349b93646b86351033e1fb09c46c/libffi%2Fsrc%2Fx86%2Fwin32.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e22fcb7985349b93646b86351033e1fb09c46c/libffi%2Fsrc%2Fx86%2Fwin32.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fwin32.S?ref=62e22fcb7985349b93646b86351033e1fb09c46c"}, {"sha": "a5a20b6437c1cb260ba8394f323f54e5121e863c", "filename": "libffi/src/x86/win64.S", "status": "modified", "additions": 196, "deletions": 497, "changes": 693, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fx86%2Fwin64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fx86%2Fwin64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fwin64.S?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "fd94dafbe30349e7e557e3a870333656288ba234", "filename": "libffi/src/xtensa/ffi.c", "status": "added", "additions": 298, "deletions": 0, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fxtensa%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fxtensa%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fxtensa%2Fffi.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "0ba728bc948c8abe34c288b327ed9c2b41de5b9b", "filename": "libffi/src/xtensa/ffitarget.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fxtensa%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fxtensa%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fxtensa%2Fffitarget.h?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "64e6a0918d0248d9d19177769ccf8fc91c6cb872", "filename": "libffi/src/xtensa/sysv.S", "status": "added", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fxtensa%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Fsrc%2Fxtensa%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fxtensa%2Fsysv.S?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "209e8976635e0384612e4fbb1b88f82d93052a5b", "filename": "libffi/testsuite/Makefile.am", "status": "modified", "additions": 79, "deletions": 70, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2FMakefile.am?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "cbfe35bafb47fe58c0cbd412faf52c5e8b0200d8", "filename": "libffi/testsuite/Makefile.in", "status": "modified", "additions": 85, "deletions": 70, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2FMakefile.in?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "b9ef4f10b69ce596ea79bc0aab34de2e1221985a", "filename": "libffi/testsuite/lib/libffi.exp", "status": "modified", "additions": 78, "deletions": 6, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flib%2Flibffi.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flib%2Flibffi.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flib%2Flibffi.exp?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "6b7beba93516a99582c1b42bc5c8ef29ee9f922f", "filename": "libffi/testsuite/lib/target-libpath.exp", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flib%2Ftarget-libpath.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flib%2Ftarget-libpath.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flib%2Ftarget-libpath.exp?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "4e5ae435a13eb99b1c74c341e19c1839de2b90f4", "filename": "libffi/testsuite/lib/wrapper.exp", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flib%2Fwrapper.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flib%2Fwrapper.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flib%2Fwrapper.exp?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "46fb1ebb75f86637a6fd0338ff5fadeda976e72b", "filename": "libffi/testsuite/libffi.call/call.exp", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fcall.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fcall.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcall.exp?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "5a4e728d4a42a72ff4d5f1dfdabc35880c44cd9d", "filename": "libffi/testsuite/libffi.call/closure_simple.c", "status": "renamed", "additions": 7, "deletions": 24, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_simple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_simple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_simple.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "previous_filename": "libffi/testsuite/libffi.call/closure_stdcall.c"}, {"sha": "0f93649ff752de1e97ba30e8c46ed282f12753e9", "filename": "libffi/testsuite/libffi.call/closure_thiscall.c", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e22fcb7985349b93646b86351033e1fb09c46c/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_thiscall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e22fcb7985349b93646b86351033e1fb09c46c/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_thiscall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_thiscall.c?ref=62e22fcb7985349b93646b86351033e1fb09c46c"}, {"sha": "cc1c43b8ca45a857b3287c8be9a9858457143b29", "filename": "libffi/testsuite/libffi.call/cls_align_longdouble_split.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_longdouble_split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_longdouble_split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_longdouble_split.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "5d3bec071968701c32f2b24c5ed937166a3940d6", "filename": "libffi/testsuite/libffi.call/cls_align_longdouble_split2.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_longdouble_split2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_longdouble_split2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_longdouble_split2.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "d24e72e4aed3c48b73a1acc53e4220c523e3b682", "filename": "libffi/testsuite/libffi.call/cls_longdouble.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fcls_longdouble.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fcls_longdouble.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_longdouble.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "7fd6c8207ac756dd7c5583be805d5b8d6b358b15", "filename": "libffi/testsuite/libffi.call/cls_many_mixed_args.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fcls_many_mixed_args.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fcls_many_mixed_args.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_many_mixed_args.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "62b0697ac01c9b7009744478dcc25f4ad03d939a", "filename": "libffi/testsuite/libffi.call/cls_many_mixed_float_double.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fcls_many_mixed_float_double.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fcls_many_mixed_float_double.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_many_mixed_float_double.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "d82a87a71b6168414fdcd35bdc973ad2b1c75561", "filename": "libffi/testsuite/libffi.call/cls_pointer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fcls_pointer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fcls_pointer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_pointer.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "1f1d9157b9d967ee82a49cc721230e6d0203cf3e", "filename": "libffi/testsuite/libffi.call/cls_pointer_stack.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fcls_pointer_stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fcls_pointer_stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_pointer_stack.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "6d1fdaeb606ac90f09cdd1ec2408e67a846d0681", "filename": "libffi/testsuite/libffi.call/cls_struct_va1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fcls_struct_va1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fcls_struct_va1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_struct_va1.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "62f2cae63a9b48d9a2c46c148ed5864f23b5ea1c", "filename": "libffi/testsuite/libffi.call/cls_ulonglong.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fcls_ulonglong.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fcls_ulonglong.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_ulonglong.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "15d5e44123481942d4dbd59960620f7f9d243c55", "filename": "libffi/testsuite/libffi.call/ffitest.h", "status": "modified", "additions": 13, "deletions": 48, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fffitest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fffitest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fffitest.h?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "c48493c6b22755b8f4a67543bc845e5839f24c25", "filename": "libffi/testsuite/libffi.call/float1.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Ffloat1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Ffloat1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Ffloat1.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "20a8c402ba4680d1fab53ede572ad8cf436a1485", "filename": "libffi/testsuite/libffi.call/float2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Ffloat2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Ffloat2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Ffloat2.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "bab3206a174fb84366638c13516d25d179666c4d", "filename": "libffi/testsuite/libffi.call/float3.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Ffloat3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Ffloat3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Ffloat3.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "5acff91f66333839f536c2c05cc08df2f03b0513", "filename": "libffi/testsuite/libffi.call/float_va.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Ffloat_va.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Ffloat_va.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Ffloat_va.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "187c42cc33492dd7f1a37f2f534c44c05f770373", "filename": "libffi/testsuite/libffi.call/huge_struct.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fhuge_struct.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fhuge_struct.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fhuge_struct.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "336968c77a2be7dc3fba3177122ba882e294312d", "filename": "libffi/testsuite/libffi.call/many.c", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fmany.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fmany.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fmany.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "1c85746e4c4bc6488f8726a1efa8a15dccdddc04", "filename": "libffi/testsuite/libffi.call/many2.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fmany2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fmany2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fmany2.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "4adbe4d705f88a982fdb5ab9ba7be7d0e408e1b7", "filename": "libffi/testsuite/libffi.call/many2_win32.c", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e22fcb7985349b93646b86351033e1fb09c46c/libffi%2Ftestsuite%2Flibffi.call%2Fmany2_win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e22fcb7985349b93646b86351033e1fb09c46c/libffi%2Ftestsuite%2Flibffi.call%2Fmany2_win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fmany2_win32.c?ref=62e22fcb7985349b93646b86351033e1fb09c46c"}, {"sha": "4ef8c8ab28b0de3e404520b9aad2d09256f3d8c3", "filename": "libffi/testsuite/libffi.call/many_double.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fmany_double.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fmany_double.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fmany_double.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "85ec36ecbefaa952594f5c20bceba49638c442ce", "filename": "libffi/testsuite/libffi.call/many_mixed.c", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fmany_mixed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fmany_mixed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fmany_mixed.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "1b2633227ad9e6dd159e4cc9f0aef01540b629aa", "filename": "libffi/testsuite/libffi.call/many_win32.c", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e22fcb7985349b93646b86351033e1fb09c46c/libffi%2Ftestsuite%2Flibffi.call%2Fmany_win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e22fcb7985349b93646b86351033e1fb09c46c/libffi%2Ftestsuite%2Flibffi.call%2Fmany_win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fmany_win32.c?ref=62e22fcb7985349b93646b86351033e1fb09c46c"}, {"sha": "6e2f26fc100e1a74dbcc8c41bd7acf030d90c9bf", "filename": "libffi/testsuite/libffi.call/negint.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fnegint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fnegint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnegint.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "477a6b9bdee2cdb2b775b4eb678dec12b0a0ab33", "filename": "libffi/testsuite/libffi.call/nested_struct1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct1.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "351049382c620224d544f49d3bc57564d2cc0310", "filename": "libffi/testsuite/libffi.call/nested_struct11.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct11.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "fd07e501794d8e43bfd171bc8343261052a5c6fe", "filename": "libffi/testsuite/libffi.call/return_dbl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Freturn_dbl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Freturn_dbl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Freturn_dbl.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "52a92fe0711cfde8b918525309fa12f13eab1e83", "filename": "libffi/testsuite/libffi.call/return_ldl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Freturn_ldl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Freturn_ldl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Freturn_ldl.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "6fe554619d522fe481c4970c32ac3c011e6277c0", "filename": "libffi/testsuite/libffi.call/return_uc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Freturn_uc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Freturn_uc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Freturn_uc.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "71c2469e1c4dc6995fafe9e34533a356cc9bd6d3", "filename": "libffi/testsuite/libffi.call/stret_large.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fstret_large.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fstret_large.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstret_large.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "d9c750ee1c040928c86ab9f7193caaba57bbddd1", "filename": "libffi/testsuite/libffi.call/stret_large2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fstret_large2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fstret_large2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstret_large2.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "35b70ea4e2e1cfb191d7030e777dfb1c734ad8b2", "filename": "libffi/testsuite/libffi.call/strlen.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fstrlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fstrlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstrlen.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "96282bc0a1fa45d8d8cdaf59ee855fdd63785cf3", "filename": "libffi/testsuite/libffi.call/strlen2.c", "status": "renamed", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fstrlen2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fstrlen2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstrlen2.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "previous_filename": "libffi/testsuite/libffi.call/fastthis1_win32.c"}, {"sha": "0d81061e75852ceb11c2c88eaf45f254b9a8c35a", "filename": "libffi/testsuite/libffi.call/strlen2_win32.c", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e22fcb7985349b93646b86351033e1fb09c46c/libffi%2Ftestsuite%2Flibffi.call%2Fstrlen2_win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e22fcb7985349b93646b86351033e1fb09c46c/libffi%2Ftestsuite%2Flibffi.call%2Fstrlen2_win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstrlen2_win32.c?ref=62e22fcb7985349b93646b86351033e1fb09c46c"}, {"sha": "beba86e9eacf4910fc416b7ec6f443153a66536b", "filename": "libffi/testsuite/libffi.call/strlen3.c", "status": "renamed", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fstrlen3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fstrlen3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstrlen3.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "previous_filename": "libffi/testsuite/libffi.call/fastthis2_win32.c"}, {"sha": "d5d42b4f6ddff4d3181eafebe20c9489c5859e98", "filename": "libffi/testsuite/libffi.call/strlen4.c", "status": "renamed", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fstrlen4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fstrlen4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstrlen4.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356", "previous_filename": "libffi/testsuite/libffi.call/fastthis3_win32.c"}, {"sha": "6fbcc87400a6c00bc2645342f08d1ab4b22e95cd", "filename": "libffi/testsuite/libffi.call/strlen_win32.c", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e22fcb7985349b93646b86351033e1fb09c46c/libffi%2Ftestsuite%2Flibffi.call%2Fstrlen_win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e22fcb7985349b93646b86351033e1fb09c46c/libffi%2Ftestsuite%2Flibffi.call%2Fstrlen_win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstrlen_win32.c?ref=62e22fcb7985349b93646b86351033e1fb09c46c"}, {"sha": "c13e23f872734ebc70cba1fb47796e722ddac0e0", "filename": "libffi/testsuite/libffi.call/struct1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fstruct1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fstruct1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct1.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "b756f5ad8b52f8d2e0e9596fc12a7b494926c323", "filename": "libffi/testsuite/libffi.call/struct1_win32.c", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e22fcb7985349b93646b86351033e1fb09c46c/libffi%2Ftestsuite%2Flibffi.call%2Fstruct1_win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e22fcb7985349b93646b86351033e1fb09c46c/libffi%2Ftestsuite%2Flibffi.call%2Fstruct1_win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct1_win32.c?ref=62e22fcb7985349b93646b86351033e1fb09c46c"}, {"sha": "5077a5ee45a5fe6f1658c0aa498450026a616f02", "filename": "libffi/testsuite/libffi.call/struct2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fstruct2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fstruct2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct2.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "5d022855c574ac62916de93b4a733b4e7094dd87", "filename": "libffi/testsuite/libffi.call/struct2_win32.c", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e22fcb7985349b93646b86351033e1fb09c46c/libffi%2Ftestsuite%2Flibffi.call%2Fstruct2_win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e22fcb7985349b93646b86351033e1fb09c46c/libffi%2Ftestsuite%2Flibffi.call%2Fstruct2_win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct2_win32.c?ref=62e22fcb7985349b93646b86351033e1fb09c46c"}, {"sha": "7eba0ead6d6a8964263a7df59a52d7d28ec27a83", "filename": "libffi/testsuite/libffi.call/struct3.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fstruct3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fstruct3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct3.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "66a9551dd65032cd1124fe4758ff1134cebd2b7b", "filename": "libffi/testsuite/libffi.call/struct4.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fstruct4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fstruct4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct4.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "23e2a3f745c8b7a85df0c3bfd37f79808e855a78", "filename": "libffi/testsuite/libffi.call/struct5.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fstruct5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fstruct5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct5.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "173c66eb4d2bf07aba628896d51e3e8b28dde586", "filename": "libffi/testsuite/libffi.call/struct6.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fstruct6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fstruct6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct6.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "badc7e055609387bf6c09e32b7916919a5320aa1", "filename": "libffi/testsuite/libffi.call/struct7.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fstruct7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fstruct7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct7.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "ef204ecbbce5074389f51b192243cf25b9a75ecc", "filename": "libffi/testsuite/libffi.call/struct8.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fstruct8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fstruct8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct8.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "4a13b818c4ee0693604a6d41eb00c10067ee4273", "filename": "libffi/testsuite/libffi.call/struct9.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fstruct9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.call%2Fstruct9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct9.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "4a812edf055e9b7d1c230e21e2c724a0a067e38a", "filename": "libffi/testsuite/libffi.complex/cls_align_complex.inc", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_align_complex.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_align_complex.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_align_complex.inc?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "0dff23ae47c35fe4eb50a388468547e63bd416c4", "filename": "libffi/testsuite/libffi.complex/cls_align_complex_double.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_align_complex_double.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_align_complex_double.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_align_complex_double.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "0affbd07e53d6f842a4bd524d3faf7d291df4474", "filename": "libffi/testsuite/libffi.complex/cls_align_complex_float.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_align_complex_float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_align_complex_float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_align_complex_float.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "7889ba859b54f68d2e17788ff14f813e5149aaa7", "filename": "libffi/testsuite/libffi.complex/cls_align_complex_longdouble.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_align_complex_longdouble.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_align_complex_longdouble.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_align_complex_longdouble.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "f9374044e8781a4b6f8ff2a685bb43a7199420d9", "filename": "libffi/testsuite/libffi.complex/cls_complex.inc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex.inc?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "05e35340e08d9f8b7c95297dc9125b74cfe60a53", "filename": "libffi/testsuite/libffi.complex/cls_complex_double.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_double.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_double.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_double.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "5df7849d4c97d70aade6bdcb16855302e2a1793b", "filename": "libffi/testsuite/libffi.complex/cls_complex_float.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_float.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "2b1c320a20a852f97548d7dd8fd7cc390374851c", "filename": "libffi/testsuite/libffi.complex/cls_complex_longdouble.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_longdouble.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_longdouble.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_longdouble.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "df8708d1c4f98ddbaceb7a337921fef0ceee4eed", "filename": "libffi/testsuite/libffi.complex/cls_complex_struct.inc", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_struct.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_struct.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_struct.inc?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "ec71346a3fb6bfcd349bb296388e4f936660f8fb", "filename": "libffi/testsuite/libffi.complex/cls_complex_struct_double.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_struct_double.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_struct_double.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_struct_double.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "96fdf750430605ba1c34f9811e0b2c5309041335", "filename": "libffi/testsuite/libffi.complex/cls_complex_struct_float.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_struct_float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_struct_float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_struct_float.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "005b467398f202ff62ed5062cfaa006a9919f0dd", "filename": "libffi/testsuite/libffi.complex/cls_complex_struct_longdouble.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_struct_longdouble.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_struct_longdouble.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_struct_longdouble.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "8a3e15f0f6af6609cb033b52b4d04571b5ca0cae", "filename": "libffi/testsuite/libffi.complex/cls_complex_va.inc", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_va.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_va.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_va.inc?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "879ccf3b81f8a520b850c9c1a36ba633063d55dc", "filename": "libffi/testsuite/libffi.complex/cls_complex_va_double.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_va_double.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_va_double.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_va_double.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "2b17826045aad88915ec03a2a0e03c8523a4bc86", "filename": "libffi/testsuite/libffi.complex/cls_complex_va_float.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_va_float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_va_float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_va_float.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "6eca9656eac5a6dfb254b4083bf3b809fa6dc8ab", "filename": "libffi/testsuite/libffi.complex/cls_complex_va_longdouble.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_va_longdouble.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_va_longdouble.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Fcls_complex_va_longdouble.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "4631db285a240745178a5e6daf52d794a0beb710", "filename": "libffi/testsuite/libffi.complex/complex.exp", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcomplex.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcomplex.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Fcomplex.exp?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "515ae3e60deab8ff012a3adf516d67fcaf637338", "filename": "libffi/testsuite/libffi.complex/complex.inc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcomplex.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcomplex.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Fcomplex.inc?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "3583e166d662796246b151bd7830364b8034d1e7", "filename": "libffi/testsuite/libffi.complex/complex_defs_double.inc", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcomplex_defs_double.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcomplex_defs_double.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Fcomplex_defs_double.inc?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "bbd9375cbfafab361742b26b83e86b6f158aead8", "filename": "libffi/testsuite/libffi.complex/complex_defs_float.inc", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcomplex_defs_float.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcomplex_defs_float.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Fcomplex_defs_float.inc?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "14b9f243f480ab9e72d2e9d827db71f7c7202f65", "filename": "libffi/testsuite/libffi.complex/complex_defs_longdouble.inc", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcomplex_defs_longdouble.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcomplex_defs_longdouble.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Fcomplex_defs_longdouble.inc?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "8a3297b2a24f35f5ef80e2029f10c61cb375ffe2", "filename": "libffi/testsuite/libffi.complex/complex_double.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcomplex_double.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcomplex_double.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Fcomplex_double.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "5044ebbcaae1c94cef350a9f4cf3a5e0c73dc645", "filename": "libffi/testsuite/libffi.complex/complex_float.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcomplex_float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcomplex_float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Fcomplex_float.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "bac319081e61389ff40bf51fa56a3010eccff6c4", "filename": "libffi/testsuite/libffi.complex/complex_int.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcomplex_int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcomplex_int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Fcomplex_int.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "7e783660930a62403ef3a13bc8e92dfe817a89fb", "filename": "libffi/testsuite/libffi.complex/complex_longdouble.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcomplex_longdouble.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fcomplex_longdouble.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Fcomplex_longdouble.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "d27d362d6a6e7e99787be66a5ccbb6c2f487c3a5", "filename": "libffi/testsuite/libffi.complex/ffitest.h", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fffitest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fffitest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Fffitest.h?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "e37a77439765fe8357d0b092489f231bbd4d8883", "filename": "libffi/testsuite/libffi.complex/many_complex.inc", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fmany_complex.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fmany_complex.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Fmany_complex.inc?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "3fd53c3354d9d736007ad2e2fbc5ffe9ee645486", "filename": "libffi/testsuite/libffi.complex/many_complex_double.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fmany_complex_double.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fmany_complex_double.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Fmany_complex_double.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "c43d21cd9e1215ac3a886604ca033a96261ada61", "filename": "libffi/testsuite/libffi.complex/many_complex_float.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fmany_complex_float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fmany_complex_float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Fmany_complex_float.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "dbab723969c1253c8eb2619238624ebb247ed222", "filename": "libffi/testsuite/libffi.complex/many_complex_longdouble.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fmany_complex_longdouble.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Fmany_complex_longdouble.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Fmany_complex_longdouble.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "8bf0c1fbab8502005801aefcef93177c3dc9c131", "filename": "libffi/testsuite/libffi.complex/return_complex.inc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex.inc?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "7cecc0fefa52c7c90c2ed49c4df23e50f5c0c06a", "filename": "libffi/testsuite/libffi.complex/return_complex1.inc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex1.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex1.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex1.inc?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "727410d563da91f88258bb83eaba650fc9a284af", "filename": "libffi/testsuite/libffi.complex/return_complex1_double.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex1_double.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex1_double.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex1_double.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "a2aeada84763cebf2092c3f5e6e5d2c580329e8d", "filename": "libffi/testsuite/libffi.complex/return_complex1_float.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex1_float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex1_float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex1_float.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "103504bf64e11bc96b9eee22cbc83c5c14297df0", "filename": "libffi/testsuite/libffi.complex/return_complex1_longdouble.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex1_longdouble.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex1_longdouble.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex1_longdouble.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "265170bf718285c6d65fc551e341e9fc5b1f02d9", "filename": "libffi/testsuite/libffi.complex/return_complex2.inc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex2.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex2.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex2.inc?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "ab9efacb4a856aa76773a158b67530bcc09b1f55", "filename": "libffi/testsuite/libffi.complex/return_complex2_double.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex2_double.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex2_double.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex2_double.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "d7f22c2a0c78816a0d02a2d6dfb3b1de48dd4f1f", "filename": "libffi/testsuite/libffi.complex/return_complex2_float.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex2_float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex2_float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex2_float.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "3edea629df0b0c73d366755cece310ff9cb80542", "filename": "libffi/testsuite/libffi.complex/return_complex2_longdouble.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex2_longdouble.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex2_longdouble.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex2_longdouble.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "e2497cc84aa048a3ea242ee765e74ac1427e9e70", "filename": "libffi/testsuite/libffi.complex/return_complex_double.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex_double.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex_double.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex_double.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "a35528ff9356b1f41af0c101491cba88277f4af0", "filename": "libffi/testsuite/libffi.complex/return_complex_float.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex_float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex_float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex_float.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "142d7becbace62a36e1ce12d4029ae9ee886a7a8", "filename": "libffi/testsuite/libffi.complex/return_complex_longdouble.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex_longdouble.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex_longdouble.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.complex%2Freturn_complex_longdouble.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "b00c404ab353afaff3a75eb8582bc5e82c54b573", "filename": "libffi/testsuite/libffi.go/aa-direct.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.go%2Faa-direct.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.go%2Faa-direct.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.go%2Faa-direct.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "7b34afc88c8f3ce0f7260b7f53e4083143ff2c4f", "filename": "libffi/testsuite/libffi.go/closure1.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.go%2Fclosure1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.go%2Fclosure1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.go%2Fclosure1.c?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "d27d362d6a6e7e99787be66a5ccbb6c2f487c3a5", "filename": "libffi/testsuite/libffi.go/ffitest.h", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.go%2Fffitest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.go%2Fffitest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.go%2Fffitest.h?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "100c5e75b4091522110934a68713dd295fdd7c00", "filename": "libffi/testsuite/libffi.go/go.exp", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.go%2Fgo.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.go%2Fgo.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.go%2Fgo.exp?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}, {"sha": "3675b40a54c844358369bc8720818efe3843339f", "filename": "libffi/testsuite/libffi.go/static-chain.h", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.go%2Fstatic-chain.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1760f7f915a36ee9b4636fb54719c9b3ae59356/libffi%2Ftestsuite%2Flibffi.go%2Fstatic-chain.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.go%2Fstatic-chain.h?ref=b1760f7f915a36ee9b4636fb54719c9b3ae59356"}]}