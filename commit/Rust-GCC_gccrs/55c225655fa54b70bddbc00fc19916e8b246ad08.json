{"sha": "55c225655fa54b70bddbc00fc19916e8b246ad08", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTVjMjI1NjU1ZmE1NGI3MGJkZGJjMDBmYzE5OTE2ZThiMjQ2YWQwOA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-03-15T12:28:39Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-03-15T12:28:39Z"}, "message": "Include expr.h.\n\n(find_reloads_address, find_reloads_address_1): New argument INSN.\n(find_reloads_address_1): Reload inside of p{re,ost}_{in,de}c\ninstead of entire p{re,ost}_{in,de}c where appropriate.\n\nFrom-SVN: r13706", "tree": {"sha": "a39b801adc2b7553ca6b041443450e89049f9b09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a39b801adc2b7553ca6b041443450e89049f9b09"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55c225655fa54b70bddbc00fc19916e8b246ad08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55c225655fa54b70bddbc00fc19916e8b246ad08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55c225655fa54b70bddbc00fc19916e8b246ad08", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55c225655fa54b70bddbc00fc19916e8b246ad08/comments", "author": null, "committer": null, "parents": [{"sha": "fa1610e95b31962667db9ac4c2553227bd236c52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa1610e95b31962667db9ac4c2553227bd236c52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa1610e95b31962667db9ac4c2553227bd236c52"}], "stats": {"total": 148, "additions": 95, "deletions": 53}, "files": [{"sha": "802ede68daeaffee18841de98872b89d8e3cc706", "filename": "gcc/reload.c", "status": "modified", "additions": 95, "deletions": 53, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55c225655fa54b70bddbc00fc19916e8b246ad08/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55c225655fa54b70bddbc00fc19916e8b246ad08/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=55c225655fa54b70bddbc00fc19916e8b246ad08", "patch": "@@ -99,6 +99,7 @@ a register with any other reload.  */\n #include \"flags.h\"\n #include \"real.h\"\n #include \"output.h\"\n+#include \"expr.h\"\n \n #ifndef REGISTER_MOVE_COST\n #define REGISTER_MOVE_COST(x, y) 2\n@@ -325,11 +326,11 @@ static int alternative_allows_memconst PROTO((char *, int));\n static rtx find_reloads_toplev\tPROTO((rtx, int, enum reload_type, int, int));\n static rtx make_memloc\t\tPROTO((rtx, int));\n static int find_reloads_address\tPROTO((enum machine_mode, rtx *, rtx, rtx *,\n-\t\t\t\t       int, enum reload_type, int));\n+\t\t\t\t       int, enum reload_type, int, rtx));\n static rtx subst_reg_equivs\tPROTO((rtx));\n static rtx subst_indexed_address PROTO((rtx));\n static int find_reloads_address_1 PROTO((enum machine_mode, rtx, int, rtx *,\n-\t\t\t\t\t int, enum reload_type,int));\n+\t\t\t\t\t int, enum reload_type,int, rtx));\n static void find_reloads_address_part PROTO((rtx, rtx *, enum reg_class,\n \t\t\t\t\t     enum machine_mode, int,\n \t\t\t\t\t     enum reload_type, int));\n@@ -693,7 +694,7 @@ get_secondary_mem (x, mode, opnum, type)\n \t       : RELOAD_OTHER);\n \n       find_reloads_address (mode, NULL_PTR, XEXP (loc, 0), &XEXP (loc, 0),\n-\t\t\t    opnum, type, 0);\n+\t\t\t    opnum, type, 0, 0);\n     }\n \n   secondary_memlocs_elim[(int) mode][opnum] = loc;\n@@ -2538,7 +2539,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t{\n \t  find_reloads_address (VOIDmode, NULL_PTR,\n \t\t\t\trecog_operand[i], recog_operand_loc[i],\n-\t\t\t\ti, operand_type[i], ind_levels);\n+\t\t\t\ti, operand_type[i], ind_levels, insn);\n \n \t  /* If we now have a simple operand where we used to have a \n \t     PLUS or MULT, re-recognize and try again.  */\n@@ -2561,7 +2562,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t\t    recog_operand_loc[i],\n \t\t\t\t    XEXP (recog_operand[i], 0),\n \t\t\t\t    &XEXP (recog_operand[i], 0),\n-\t\t\t\t    i, address_type[i], ind_levels))\n+\t\t\t\t    i, address_type[i], ind_levels, insn))\n \t    address_reloaded[i] = 1;\n \t  substed_operand[i] = recog_operand[i] = *recog_operand_loc[i];\n \t}\n@@ -2629,7 +2630,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t\t    recog_operand_loc[i],\n \t\t\t\t    XEXP (recog_operand[i], 0),\n \t\t\t\t    &XEXP (recog_operand[i], 0),\n-\t\t\t\t    i, address_type[i], ind_levels);\n+\t\t\t\t    i, address_type[i], ind_levels, insn);\n \t      substed_operand[i] = recog_operand[i] = *recog_operand_loc[i];\n \t    }\n \t}\n@@ -3950,7 +3951,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \tif (insn_operand_address_p[insn_code_number][i])\n \t  find_reloads_address (VOIDmode, NULL_PTR,\n \t\t\t\trecog_operand[i], recog_operand_loc[i],\n-\t\t\t\ti, RELOAD_FOR_INPUT, ind_levels);\n+\t\t\t\ti, RELOAD_FOR_INPUT, ind_levels, insn);\n \n       /* In these cases, we can't tell if the operand is an input\n \t or an output, so be conservative.  In practice it won't be\n@@ -3961,7 +3962,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t      recog_operand_loc[i],\n \t\t\t      XEXP (recog_operand[i], 0),\n \t\t\t      &XEXP (recog_operand[i], 0),\n-\t\t\t      i, RELOAD_OTHER, ind_levels);\n+\t\t\t      i, RELOAD_OTHER, ind_levels, insn);\n       if (code == SUBREG)\n \trecog_operand[i] = *recog_operand_loc[i]\n \t  = find_reloads_toplev (recog_operand[i], i, RELOAD_OTHER,\n@@ -4067,15 +4068,15 @@ find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest)\n \t  RTX_UNCHANGING_P (x) = RTX_UNCHANGING_P (regno_reg_rtx[regno]);\n \t  find_reloads_address (GET_MODE (x), NULL_PTR,\n \t\t\t\tXEXP (x, 0),\n-\t\t\t\t&XEXP (x, 0), opnum, type, ind_levels);\n+\t\t\t\t&XEXP (x, 0), opnum, type, ind_levels, 0);\n \t}\n       return x;\n     }\n   if (code == MEM)\n     {\n       rtx tem = x;\n       find_reloads_address (GET_MODE (x), &tem, XEXP (x, 0), &XEXP (x, 0),\n-\t\t\t    opnum, type, ind_levels);\n+\t\t\t    opnum, type, ind_levels, 0);\n       return tem;\n     }\n \n@@ -4156,7 +4157,7 @@ find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest)\n \t  RTX_UNCHANGING_P (x) = RTX_UNCHANGING_P (regno_reg_rtx[regno]);\n \t  find_reloads_address (GET_MODE (x), NULL_PTR,\n \t\t\t\tXEXP (x, 0),\n-\t\t\t\t&XEXP (x, 0), opnum, type, ind_levels);\n+\t\t\t\t&XEXP (x, 0), opnum, type, ind_levels, 0);\n \t}\n \n     }\n@@ -4216,6 +4217,9 @@ make_memloc (ad, regno)\n    IND_LEVELS says how many levels of indirect addressing this machine\n    supports.\n \n+   INSN, if nonzero, is the insn in which we do the reload.  It is used\n+   to determine if we may generate output reloads.\n+\n    Value is nonzero if this address is reloaded or replaced as a whole.\n    This is interesting to the caller if the address is an autoincrement.\n \n@@ -4226,14 +4230,15 @@ make_memloc (ad, regno)\n    to a hard register, and frame pointer elimination.  */\n \n static int\n-find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels)\n+find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n      enum machine_mode mode;\n      rtx *memrefloc;\n      rtx ad;\n      rtx *loc;\n      int opnum;\n      enum reload_type type;\n      int ind_levels;\n+     rtx insn;\n {\n   register int regno;\n   rtx tem;\n@@ -4258,7 +4263,7 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels)\n \t  tem = make_memloc (ad, regno);\n \t  find_reloads_address (GET_MODE (tem), NULL_PTR, XEXP (tem, 0),\n \t\t\t\t&XEXP (tem, 0), opnum, ADDR_TYPE (type),\n-\t\t\t\tind_levels);\n+\t\t\t\tind_levels, insn);\n \t  push_reload (tem, NULL_RTX, loc, NULL_PTR,\n \t\t       reload_address_base_reg_class,\n \t\t       GET_MODE (ad), VOIDmode, 0, 0,\n@@ -4334,7 +4339,7 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels)\n       tem = ad;\n       find_reloads_address (GET_MODE (ad), &tem, XEXP (ad, 0), &XEXP (ad, 0),\n \t\t\t    opnum, ADDR_TYPE (type),\n-\t\t\t    ind_levels == 0 ? 0 : ind_levels - 1);\n+\t\t\t    ind_levels == 0 ? 0 : ind_levels - 1, insn);\n \n       /* If tem was changed, then we must create a new memory reference to\n \t hold it and store it back into memrefloc.  */\n@@ -4456,7 +4461,7 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels)\n \t\t\t\t reload_address_base_reg_class,\n \t\t\t\t GET_MODE (ad), opnum, type, ind_levels);\n       find_reloads_address_1 (mode, XEXP (ad, 1), 1, &XEXP (ad, 1), opnum,\n-\t\t\t      type, 0);\n+\t\t\t      type, 0, insn);\n \n       return 1;\n     }\n@@ -4481,7 +4486,7 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels)\n \t\t\t\t reload_address_base_reg_class,\n \t\t\t\t GET_MODE (ad), opnum, type, ind_levels);\n       find_reloads_address_1 (mode, XEXP (ad, 0), 1, &XEXP (ad, 0), opnum,\n-\t\t\t      type, 0);\n+\t\t\t      type, 0, insn);\n \n       return 1;\n     }\n@@ -4528,7 +4533,8 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels)\n       return 1;\n     }\n \n-  return find_reloads_address_1 (mode, ad, 0, loc, opnum, type, ind_levels);\n+  return find_reloads_address_1 (mode, ad, 0, loc, opnum, type, ind_levels,\n+\t\t\t\t insn);\n }\n \f\n /* Find all pseudo regs appearing in AD\n@@ -4704,6 +4710,9 @@ subst_indexed_address (addr)\n    IND_LEVELS says how many levels of indirect addressing are\n    supported at this point in the address.\n \n+   INSN, if nonzero, is the insn in which we do the reload.  It is used\n+   to determine if we may generate output reloads.\n+\n    We return nonzero if X, as a whole, is reloaded or replaced.  */\n \n /* Note that we take shortcuts assuming that no multi-reg machine mode\n@@ -4713,14 +4722,15 @@ subst_indexed_address (addr)\n    could have addressing modes that this does not handle right.  */\n \n static int\n-find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels)\n+find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n      enum machine_mode mode;\n      rtx x;\n      int context;\n      rtx *loc;\n      int opnum;\n      enum reload_type type;\n      int ind_levels;\n+     rtx insn;\n {\n   register RTX_CODE code = GET_CODE (x);\n \n@@ -4757,29 +4767,29 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels)\n \t    || code0 == ZERO_EXTEND || code1 == MEM)\n \t  {\n \t    find_reloads_address_1 (mode, orig_op0, 1, &XEXP (x, 0), opnum,\n-\t\t\t\t    type, ind_levels);\n+\t\t\t\t    type, ind_levels, insn);\n \t    find_reloads_address_1 (mode, orig_op1, 0, &XEXP (x, 1), opnum,\n-\t\t\t\t    type, ind_levels);\n+\t\t\t\t    type, ind_levels, insn);\n \t  }\n \n \telse if (code1 == MULT || code1 == SIGN_EXTEND || code1 == TRUNCATE\n \t\t || code1 == ZERO_EXTEND || code0 == MEM)\n \t  {\n \t    find_reloads_address_1 (mode, orig_op0, 0, &XEXP (x, 0), opnum,\n-\t\t\t\t    type, ind_levels);\n+\t\t\t\t    type, ind_levels, insn);\n \t    find_reloads_address_1 (mode, orig_op1, 1, &XEXP (x, 1), opnum,\n-\t\t\t\t    type, ind_levels);\n+\t\t\t\t    type, ind_levels, insn);\n \t  }\n \n \telse if (code0 == CONST_INT || code0 == CONST\n \t\t || code0 == SYMBOL_REF || code0 == LABEL_REF)\n \t  find_reloads_address_1 (mode, orig_op1, 0, &XEXP (x, 1), opnum,\n-\t\t\t\t  type, ind_levels);\n+\t\t\t\t  type, ind_levels, insn);\n \n \telse if (code1 == CONST_INT || code1 == CONST\n \t\t || code1 == SYMBOL_REF || code1 == LABEL_REF)\n \t  find_reloads_address_1 (mode, orig_op0, 0, &XEXP (x, 0), opnum,\n-\t\t\t\t  type, ind_levels);\n+\t\t\t\t  type, ind_levels, insn);\n \n \telse if (code0 == REG && code1 == REG)\n \t  {\n@@ -4791,39 +4801,39 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels)\n \t      return 0;\n \t    else if (REG_MODE_OK_FOR_BASE_P (op1, mode))\n \t      find_reloads_address_1 (mode, orig_op0, 1, &XEXP (x, 0), opnum,\n-\t\t\t\t      type, ind_levels);\n+\t\t\t\t      type, ind_levels, insn);\n \t    else if (REG_MODE_OK_FOR_BASE_P (op0, mode))\n \t      find_reloads_address_1 (mode, orig_op1, 1, &XEXP (x, 1), opnum,\n-\t\t\t\t      type, ind_levels);\n+\t\t\t\t      type, ind_levels, insn);\n \t    else if (REG_OK_FOR_INDEX_P (op1))\n \t      find_reloads_address_1 (mode, orig_op0, 0, &XEXP (x, 0), opnum,\n-\t\t\t\t      type, ind_levels);\n+\t\t\t\t      type, ind_levels, insn);\n \t    else if (REG_OK_FOR_INDEX_P (op0))\n \t      find_reloads_address_1 (mode, orig_op1, 0, &XEXP (x, 1), opnum,\n-\t\t\t\t      type, ind_levels);\n+\t\t\t\t      type, ind_levels, insn);\n \t    else\n \t      {\n \t\tfind_reloads_address_1 (mode, orig_op0, 1, &XEXP (x, 0), opnum,\n-\t\t\t\t\ttype, ind_levels);\n+\t\t\t\t\ttype, ind_levels, insn);\n \t\tfind_reloads_address_1 (mode, orig_op1, 0, &XEXP (x, 1), opnum,\n-\t\t\t\t\ttype, ind_levels);\n+\t\t\t\t\ttype, ind_levels, insn);\n \t      }\n \t  }\n \n \telse if (code0 == REG)\n \t  {\n \t    find_reloads_address_1 (mode, orig_op0, 1, &XEXP (x, 0), opnum,\n-\t\t\t\t    type, ind_levels);\n+\t\t\t\t    type, ind_levels, insn);\n \t    find_reloads_address_1 (mode, orig_op1, 0, &XEXP (x, 1), opnum,\n-\t\t\t\t    type, ind_levels);\n+\t\t\t\t    type, ind_levels, insn);\n \t  }\n \n \telse if (code1 == REG)\n \t  {\n \t    find_reloads_address_1 (mode, orig_op1, 1, &XEXP (x, 1), opnum,\n-\t\t\t\t    type, ind_levels);\n+\t\t\t\t    type, ind_levels, insn);\n \t    find_reloads_address_1 (mode, orig_op0, 0, &XEXP (x, 0), opnum,\n-\t\t\t\t    type, ind_levels);\n+\t\t\t\t    type, ind_levels, insn);\n \t  }\n       }\n \n@@ -4855,7 +4865,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels)\n \t\t need two registers.  */\n \t      find_reloads_address (GET_MODE (tem), 0, XEXP (tem, 0),\n \t\t\t\t    &XEXP (tem, 0), opnum, type,\n-\t\t\t\t    ind_levels);\n+\t\t\t\t    ind_levels, insn);\n \t      /* Put this inside a new increment-expression.  */\n \t      x = gen_rtx (GET_CODE (x), GET_MODE (x), tem);\n \t      /* Proceed to reload that, as if it contained a register.  */\n@@ -4879,18 +4889,50 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels)\n \t\t    : REGNO_MODE_OK_FOR_BASE_P (regno, mode))))\n \t    {\n \t      register rtx link;\n-\n-\t      int reloadnum\n-\t\t= push_reload (x, NULL_RTX, loc, NULL_PTR,\n-\t\t\t       (context\n-\t\t\t\t? reload_address_index_reg_class\n-\t\t\t\t: reload_address_base_reg_class),\n-\t\t\t       GET_MODE (x), GET_MODE (x), VOIDmode, 0,\n-\t\t\t       opnum, type);\n-\t      reload_inc[reloadnum]\n-\t\t= find_inc_amount (PATTERN (this_insn), XEXP (x_orig, 0));\n-\n-\t      value = 1;\n+\t      int reloadnum;\n+\n+\t      /* If we can output the register afterwards, do so, this\n+\t\t saves the extra update.\n+\t\t We can do so if we have an INSN - i.e. no JUMP_INSN nor\n+\t\t CALL_INSN - and it does not set CC0.\n+\t\t But don't do this if we cannot directly address the\n+\t\t memory location, since this will make it harder to\n+\t\t reuse address reloads, and increses register pressure.\n+\t\t Also don't do this if we can probably update x directly.  */\n+\t      rtx equiv = reg_equiv_mem[regno];\n+\t      int icode = (int) add_optab->handlers[(int) Pmode].insn_code;\n+\t      if (insn && GET_CODE (insn) == INSN && equiv\n+#ifdef HAVE_cc0\n+\t\t  && ! sets_cc0_p (PATTERN (insn))\n+#endif\n+\t\t  && ! (icode != CODE_FOR_nothing\n+\t\t\t&& (*insn_operand_predicate[icode][0]) (equiv, Pmode)\n+\t\t\t&& (*insn_operand_predicate[icode][1]) (equiv, Pmode)))\n+\t\t{\n+\t\t  loc = &XEXP (x, 0);\n+\t\t  x = XEXP (x, 0);\n+\t\t  reloadnum\n+\t\t    = push_reload (x, x, loc, loc,\n+\t\t\t\t   (context\n+\t\t\t\t    ? reload_address_index_reg_class\n+\t\t\t\t    : reload_address_base_reg_class),\n+\t\t\t\t    GET_MODE (x), GET_MODE (x), VOIDmode, 0,\n+\t\t\t\t    opnum, RELOAD_OTHER);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  reloadnum\n+\t\t    = push_reload (x, NULL_RTX, loc, NULL_PTR,\n+\t\t\t\t   (context\n+\t\t\t\t    ? reload_address_index_reg_class\n+\t\t\t\t    : reload_address_base_reg_class),\n+\t\t\t\t   GET_MODE (x), GET_MODE (x), VOIDmode, 0,\n+\t\t\t\t   opnum, type);\n+\t\t  reload_inc[reloadnum]\n+\t\t    = find_inc_amount (PATTERN (this_insn), XEXP (x_orig, 0));\n+    \n+\t\t  value = 1;\n+\t\t}\n \n #ifdef AUTO_INC_DEC\n \t      /* Update the REG_INC notes.  */\n@@ -4926,7 +4968,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels)\n \t     need two registers.  */\n \t  find_reloads_address (GET_MODE (x), &XEXP (x, 0),\n \t\t\t\tXEXP (XEXP (x, 0), 0), &XEXP (XEXP (x, 0), 0),\n-\t\t\t\topnum, type, ind_levels);\n+\t\t\t\topnum, type, ind_levels, insn);\n \n \t  reloadnum = push_reload (x, NULL_RTX, loc, NULL_PTR,\n \t\t\t\t   (context\n@@ -4958,7 +5000,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels)\n \t reload1.c here.  */\n \n       find_reloads_address (GET_MODE (x), loc, XEXP (x, 0), &XEXP (x, 0),\n-\t\t\t    opnum, ADDR_TYPE (type), ind_levels);\n+\t\t\t    opnum, ADDR_TYPE (type), ind_levels, insn);\n       push_reload (*loc, NULL_RTX, loc, NULL_PTR,\n \t\t   (context ? reload_address_index_reg_class\n \t\t    : reload_address_base_reg_class),\n@@ -4996,7 +5038,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels)\n \t  {\n \t    x = make_memloc (x, regno);\n \t    find_reloads_address (GET_MODE (x), 0, XEXP (x, 0), &XEXP (x, 0),\n-\t\t\t\t  opnum, ADDR_TYPE (type), ind_levels);\n+\t\t\t\t  opnum, ADDR_TYPE (type), ind_levels, insn);\n \t  }\n \n \tif (reg_renumber[regno] >= 0)\n@@ -5078,7 +5120,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels)\n       {\n \tif (fmt[i] == 'e')\n \t  find_reloads_address_1 (mode, XEXP (x, i), context, &XEXP (x, i),\n-\t\t\t\t  opnum, type, ind_levels);\n+\t\t\t\t  opnum, type, ind_levels, insn);\n       }\n   }\n \n@@ -5116,7 +5158,7 @@ find_reloads_address_part (x, loc, class, mode, opnum, type, ind_levels)\n     {\n       rtx tem = x = force_const_mem (mode, x);\n       find_reloads_address (mode, &tem, XEXP (tem, 0), &XEXP (tem, 0),\n-\t\t\t    opnum, type, ind_levels);\n+\t\t\t    opnum, type, ind_levels, 0);\n     }\n \n   else if (GET_CODE (x) == PLUS\n@@ -5128,7 +5170,7 @@ find_reloads_address_part (x, loc, class, mode, opnum, type, ind_levels)\n \n       x = gen_rtx (PLUS, GET_MODE (x), XEXP (x, 0), tem);\n       find_reloads_address (mode, &tem, XEXP (tem, 0), &XEXP (tem, 0),\n-\t\t\t    opnum, type, ind_levels);\n+\t\t\t    opnum, type, ind_levels, 0);\n     }\n \n   push_reload (x, NULL_RTX, loc, NULL_PTR, class,"}]}