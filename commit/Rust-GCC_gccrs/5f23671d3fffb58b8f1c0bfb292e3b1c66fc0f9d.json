{"sha": "5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWYyMzY3MWQzZmZmYjU4YjhmMWMwYmZiMjkyZTNiMWM2NmZjMGY5ZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2014-06-06T07:24:38Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-06-06T07:24:38Z"}, "message": "dump-parse-tree.c (show_omp_namelist): Dump reduction id in each list item.\n\ngcc/fortran/\n\t* dump-parse-tree.c (show_omp_namelist): Dump reduction\n\tid in each list item.\n\t(show_omp_node): Only handle OMP_LIST_REDUCTION, not\n\tOMP_LIST_REDUCTION_FIRST .. OMP_LIST_REDUCTION_LAST.  Don't\n\tdump reduction id here.\n\t* frontend-passes.c (dummy_code_callback): Renamed to...\n\t(gfc_dummy_code_callback): ... this.  No longer static.\n\t(optimize_reduction): Use gfc_dummy_code_callback instead of\n\tdummy_code_callback.\n\t* gfortran.h (gfc_statement): Add ST_OMP_DECLARE_REDUCTION.\n\t(symbol_attribute): Add omp_udr_artificial_var bitfield.\n\t(gfc_omp_reduction_op): New enum.\n\t(gfc_omp_namelist): Add rop and udr fields.\n\t(OMP_LIST_PLUS, OMP_LIST_REDUCTION_FIRST, OMP_LIST_MULT,\n\tOMP_LIST_SUB, OMP_LIST_AND, OMP_LIST_OR, OMP_LIST_EQV,\n\tOMP_LIST_NEQV, OMP_LIST_MAX, OMP_LIST_MIN, OMP_LIST_IAND,\n\tOMP_LIST_IOR, OMP_LIST_IEOR, OMP_LIST_REDUCTION_LAST): Removed.\n\t(OMP_LIST_REDUCTION): New.\n\t(gfc_omp_udr): New type.\n\t(gfc_get_omp_udr): Define.\n\t(gfc_symtree): Add n.omp_udr field.\n\t(gfc_namespace): Add omp_udr_root field, add omp_udr_ns bitfield.\n\t(gfc_free_omp_udr, gfc_omp_udr_find, gfc_resolve_omp_udrs,\n\tgfc_dummy_code_callback): New prototypes.\n\t* match.h (gfc_match_omp_declare_reduction): New prototype.\n\t* module.c (MOD_VERSION): Increase to 13.\n\t(omp_declare_reduction_stmt): New array.\n\t(mio_omp_udr_expr, write_omp_udr, write_omp_udrs, load_omp_udrs):\n\tNew functions.\n\t(read_module): Read OpenMP user defined reductions.\n\t(write_module): Write OpenMP user defined reductions.\n\t* openmp.c: Include arith.h.\n\t(gfc_free_omp_udr, gfc_find_omp_udr): New functions.\n\t(gfc_match_omp_clauses): Handle user defined reductions.\n\tStore reduction kind into gfc_omp_namelist instead of using\n\tseveral OMP_LIST_* entries.\n\t(match_udr_expr, gfc_omp_udr_predef, gfc_omp_udr_find,\n\tgfc_match_omp_declare_reduction): New functions.\n\t(resolve_omp_clauses): Adjust for reduction clauses being only\n\tin OMP_LIST_REDUCTION list.  Diagnose missing UDRs.\n\t(struct omp_udr_callback_data): New type.\n\t(omp_udr_callback, gfc_resolve_omp_udr, gfc_resolve_omp_udrs): New\n\tfunctions.\n\t* parse.c (decode_omp_directive): Handle !$omp declare reduction.\n\t(case_decl): Add ST_OMP_DECLARE_REDUCTION.\n\t(gfc_ascii_statement): Print ST_OMP_DECLARE_REDUCTION.\n\t* resolve.c (resolve_fl_variable): Allow len=: or len=* on\n\tsym->attr.omp_udr_artificial_var symbols.\n\t(resolve_types): Call gfc_resolve_omp_udrs.\n\t* symbol.c (gfc_get_uop): If gfc_current_ns->omp_udr_ns,\n\tuse parent ns instead of gfc_current_ns.\n\t(gfc_get_sym_tree): Don't insert symbols into\n\tnamespaces with omp_udr_ns set.\n\t(free_omp_udr_tree): New function.\n\t(gfc_free_namespace): Call it.\n\t* trans-openmp.c (struct omp_udr_find_orig_data): New type.\n\t(omp_udr_find_orig, gfc_trans_omp_udr_expr): New functions.\n\t(gfc_trans_omp_array_reduction): Renamed to...\n\t(gfc_trans_omp_array_reduction_or_udr): ... this.  Remove SYM\n\targument, instead pass gfc_omp_namelist pointer N.  Handle\n\tuser defined reductions.\n\t(gfc_trans_omp_reduction_list): Remove REDUCTION_CODE argument.\n\tHandle user defined reductions and reduction ops in gfc_omp_namelist.\n\t(gfc_trans_omp_clauses): Adjust for just a single OMP_LIST_REDUCTION\n\tlist.\n\t(gfc_split_omp_clauses): Likewise.\ngcc/testsuite/\n\t* gfortran.dg/gomp/allocatable_components_1.f90: Adjust for\n\treduction clause diagnostic changes.\n\t* gfortran.dg/gomp/appendix-a/a.31.3.f90: Likewise.\n\t* gfortran.dg/gomp/reduction1.f90: Likewise.\n\t* gfortran.dg/gomp/reduction3.f90: Likewise.\n\t* gfortran.dg/gomp/udr1.f90: New test.\n\t* gfortran.dg/gomp/udr2.f90: New test.\n\t* gfortran.dg/gomp/udr3.f90: New test.\n\t* gfortran.dg/gomp/udr4.f90: New test.\n\t* gfortran.dg/gomp/udr5.f90: New test.\n\t* gfortran.dg/gomp/udr6.f90: New test.\n\t* gfortran.dg/gomp/udr7.f90: New test.\nlibgomp/\n\t* testsuite/libgomp.fortran/simd1.f90: New test.\n\t* testsuite/libgomp.fortran/udr1.f90: New test.\n\t* testsuite/libgomp.fortran/udr2.f90: New test.\n\t* testsuite/libgomp.fortran/udr3.f90: New test.\n\t* testsuite/libgomp.fortran/udr4.f90: New test.\n\t* testsuite/libgomp.fortran/udr5.f90: New test.\n\t* testsuite/libgomp.fortran/udr6.f90: New test.\n\t* testsuite/libgomp.fortran/udr7.f90: New test.\n\t* testsuite/libgomp.fortran/udr8.f90: New test.\n\t* testsuite/libgomp.fortran/udr9.f90: New test.\n\t* testsuite/libgomp.fortran/udr10.f90: New test.\n\t* testsuite/libgomp.fortran/udr11.f90: New test.\n\nFrom-SVN: r211303", "tree": {"sha": "fc4518c90e2e87be67f21020636439c7c6122b66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc4518c90e2e87be67f21020636439c7c6122b66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d969f3c163ea9397c9b0e4a9dad2c1238f003b50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d969f3c163ea9397c9b0e4a9dad2c1238f003b50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d969f3c163ea9397c9b0e4a9dad2c1238f003b50"}], "stats": {"total": 3141, "additions": 2846, "deletions": 295}, "files": [{"sha": "a62e8a7425396ff801fc8a08051843f3f03e88ae", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -1,3 +1,72 @@\n+2014-06-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* dump-parse-tree.c (show_omp_namelist): Dump reduction\n+\tid in each list item.\n+\t(show_omp_node): Only handle OMP_LIST_REDUCTION, not\n+\tOMP_LIST_REDUCTION_FIRST .. OMP_LIST_REDUCTION_LAST.  Don't\n+\tdump reduction id here.\n+\t* frontend-passes.c (dummy_code_callback): Renamed to...\n+\t(gfc_dummy_code_callback): ... this.  No longer static.\n+\t(optimize_reduction): Use gfc_dummy_code_callback instead of\n+\tdummy_code_callback.\n+\t* gfortran.h (gfc_statement): Add ST_OMP_DECLARE_REDUCTION.\n+\t(symbol_attribute): Add omp_udr_artificial_var bitfield.\n+\t(gfc_omp_reduction_op): New enum.\n+\t(gfc_omp_namelist): Add rop and udr fields.\n+\t(OMP_LIST_PLUS, OMP_LIST_REDUCTION_FIRST, OMP_LIST_MULT,\n+\tOMP_LIST_SUB, OMP_LIST_AND, OMP_LIST_OR, OMP_LIST_EQV,\n+\tOMP_LIST_NEQV, OMP_LIST_MAX, OMP_LIST_MIN, OMP_LIST_IAND,\n+\tOMP_LIST_IOR, OMP_LIST_IEOR, OMP_LIST_REDUCTION_LAST): Removed.\n+\t(OMP_LIST_REDUCTION): New.\n+\t(gfc_omp_udr): New type.\n+\t(gfc_get_omp_udr): Define.\n+\t(gfc_symtree): Add n.omp_udr field.\n+\t(gfc_namespace): Add omp_udr_root field, add omp_udr_ns bitfield.\n+\t(gfc_free_omp_udr, gfc_omp_udr_find, gfc_resolve_omp_udrs,\n+\tgfc_dummy_code_callback): New prototypes.\n+\t* match.h (gfc_match_omp_declare_reduction): New prototype.\n+\t* module.c (MOD_VERSION): Increase to 13.\n+\t(omp_declare_reduction_stmt): New array.\n+\t(mio_omp_udr_expr, write_omp_udr, write_omp_udrs, load_omp_udrs):\n+\tNew functions.\n+\t(read_module): Read OpenMP user defined reductions.\n+\t(write_module): Write OpenMP user defined reductions.\n+\t* openmp.c: Include arith.h.\n+\t(gfc_free_omp_udr, gfc_find_omp_udr): New functions.\n+\t(gfc_match_omp_clauses): Handle user defined reductions.\n+\tStore reduction kind into gfc_omp_namelist instead of using\n+\tseveral OMP_LIST_* entries.\n+\t(match_udr_expr, gfc_omp_udr_predef, gfc_omp_udr_find,\n+\tgfc_match_omp_declare_reduction): New functions.\n+\t(resolve_omp_clauses): Adjust for reduction clauses being only\n+\tin OMP_LIST_REDUCTION list.  Diagnose missing UDRs.\n+\t(struct omp_udr_callback_data): New type.\n+\t(omp_udr_callback, gfc_resolve_omp_udr, gfc_resolve_omp_udrs): New\n+\tfunctions.\n+\t* parse.c (decode_omp_directive): Handle !$omp declare reduction.\n+\t(case_decl): Add ST_OMP_DECLARE_REDUCTION.\n+\t(gfc_ascii_statement): Print ST_OMP_DECLARE_REDUCTION.\n+\t* resolve.c (resolve_fl_variable): Allow len=: or len=* on\n+\tsym->attr.omp_udr_artificial_var symbols.\n+\t(resolve_types): Call gfc_resolve_omp_udrs.\n+\t* symbol.c (gfc_get_uop): If gfc_current_ns->omp_udr_ns,\n+\tuse parent ns instead of gfc_current_ns.\n+\t(gfc_get_sym_tree): Don't insert symbols into\n+\tnamespaces with omp_udr_ns set.\n+\t(free_omp_udr_tree): New function.\n+\t(gfc_free_namespace): Call it.\n+\t* trans-openmp.c (struct omp_udr_find_orig_data): New type.\n+\t(omp_udr_find_orig, gfc_trans_omp_udr_expr): New functions.\n+\t(gfc_trans_omp_array_reduction): Renamed to...\n+\t(gfc_trans_omp_array_reduction_or_udr): ... this.  Remove SYM\n+\targument, instead pass gfc_omp_namelist pointer N.  Handle\n+\tuser defined reductions.\n+\t(gfc_trans_omp_reduction_list): Remove REDUCTION_CODE argument.\n+\tHandle user defined reductions and reduction ops in gfc_omp_namelist.\n+\t(gfc_trans_omp_clauses): Adjust for just a single OMP_LIST_REDUCTION\n+\tlist.\n+\t(gfc_split_omp_clauses): Likewise.\n+\n 2014-06-05  Richard Biener  <rguenther@suse.de>\n \n \tPR fortran/61418"}, {"sha": "5a9611923d8582ec942a9b00b9b85051202a718c", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 42, "deletions": 43, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -1020,6 +1020,28 @@ show_omp_namelist (gfc_omp_namelist *n)\n {\n   for (; n; n = n->next)\n     {\n+      switch (n->rop)\n+\t{\n+\tcase OMP_REDUCTION_PLUS:\n+\tcase OMP_REDUCTION_TIMES:\n+\tcase OMP_REDUCTION_MINUS:\n+\tcase OMP_REDUCTION_AND:\n+\tcase OMP_REDUCTION_OR:\n+\tcase OMP_REDUCTION_EQV:\n+\tcase OMP_REDUCTION_NEQV:\n+\t  fprintf (dumpfile, \"%s:\", gfc_op2string ((gfc_intrinsic_op) n->rop));\n+\t  break;\n+\tcase OMP_REDUCTION_MAX: fputs (\"max:\", dumpfile); break;\n+\tcase OMP_REDUCTION_MIN: fputs (\"min:\", dumpfile); break;\n+\tcase OMP_REDUCTION_IAND: fputs (\"iand:\", dumpfile); break;\n+\tcase OMP_REDUCTION_IOR: fputs (\"ior:\", dumpfile); break;\n+\tcase OMP_REDUCTION_IEOR: fputs (\"ieor:\", dumpfile); break;\n+\tcase OMP_REDUCTION_USER:\n+\t  if (n->udr)\n+\t    fprintf (dumpfile, \"%s:\", n->udr->name);\n+\t  break;\n+\tdefault: break;\n+\t}\n       fprintf (dumpfile, \"%s\", n->sym->name);\n       if (n->expr)\n \t{\n@@ -1193,51 +1215,28 @@ show_omp_node (int level, gfc_code *c)\n \t    && list_type != OMP_LIST_COPYPRIVATE)\n \t  {\n \t    const char *type = NULL;\n-\t    if (list_type >= OMP_LIST_REDUCTION_FIRST)\n-\t      {\n-\t\tswitch (list_type)\n-\t\t  {\n-\t\t  case OMP_LIST_PLUS: type = \"+\"; break;\n-\t\t  case OMP_LIST_MULT: type = \"*\"; break;\n-\t\t  case OMP_LIST_SUB: type = \"-\"; break;\n-\t\t  case OMP_LIST_AND: type = \".AND.\"; break;\n-\t\t  case OMP_LIST_OR: type = \".OR.\"; break;\n-\t\t  case OMP_LIST_EQV: type = \".EQV.\"; break;\n-\t\t  case OMP_LIST_NEQV: type = \".NEQV.\"; break;\n-\t\t  case OMP_LIST_MAX: type = \"MAX\"; break;\n-\t\t  case OMP_LIST_MIN: type = \"MIN\"; break;\n-\t\t  case OMP_LIST_IAND: type = \"IAND\"; break;\n-\t\t  case OMP_LIST_IOR: type = \"IOR\"; break;\n-\t\t  case OMP_LIST_IEOR: type = \"IEOR\"; break;\n-\t\t  default:\n-\t\t    gcc_unreachable ();\n-\t\t  }\n-\t\tfprintf (dumpfile, \" REDUCTION(%s:\", type);\n-\t      }\n-\t    else\n+\t    switch (list_type)\n \t      {\n-\t\tswitch (list_type)\n-\t\t  {\n-\t\t  case OMP_LIST_PRIVATE: type = \"PRIVATE\"; break;\n-\t\t  case OMP_LIST_FIRSTPRIVATE: type = \"FIRSTPRIVATE\"; break;\n-\t\t  case OMP_LIST_LASTPRIVATE: type = \"LASTPRIVATE\"; break;\n-\t\t  case OMP_LIST_SHARED: type = \"SHARED\"; break;\n-\t\t  case OMP_LIST_COPYIN: type = \"COPYIN\"; break;\n-\t\t  case OMP_LIST_UNIFORM: type = \"UNIFORM\"; break;\n-\t\t  case OMP_LIST_ALIGNED: type = \"ALIGNED\"; break;\n-\t\t  case OMP_LIST_LINEAR: type = \"LINEAR\"; break;\n-\t\t  case OMP_LIST_DEPEND_IN:\n-\t\t    fprintf (dumpfile, \" DEPEND(IN:\");\n-\t\t    break;\n-\t\t  case OMP_LIST_DEPEND_OUT:\n-\t\t    fprintf (dumpfile, \" DEPEND(OUT:\");\n-\t\t    break;\n-\t\t  default:\n-\t\t    gcc_unreachable ();\n-\t\t  }\n-\t\tif (type)\n-\t\t  fprintf (dumpfile, \" %s(\", type);\n+\t      case OMP_LIST_PRIVATE: type = \"PRIVATE\"; break;\n+\t      case OMP_LIST_FIRSTPRIVATE: type = \"FIRSTPRIVATE\"; break;\n+\t      case OMP_LIST_LASTPRIVATE: type = \"LASTPRIVATE\"; break;\n+\t      case OMP_LIST_SHARED: type = \"SHARED\"; break;\n+\t      case OMP_LIST_COPYIN: type = \"COPYIN\"; break;\n+\t      case OMP_LIST_UNIFORM: type = \"UNIFORM\"; break;\n+\t      case OMP_LIST_ALIGNED: type = \"ALIGNED\"; break;\n+\t      case OMP_LIST_LINEAR: type = \"LINEAR\"; break;\n+\t      case OMP_LIST_REDUCTION: type = \"REDUCTION\"; break;\n+\t      case OMP_LIST_DEPEND_IN:\n+\t\tfprintf (dumpfile, \" DEPEND(IN:\");\n+\t\tbreak;\n+\t      case OMP_LIST_DEPEND_OUT:\n+\t\tfprintf (dumpfile, \" DEPEND(OUT:\");\n+\t\tbreak;\n+\t      default:\n+\t\tgcc_unreachable ();\n \t      }\n+\t    if (type)\n+\t      fprintf (dumpfile, \" %s(\", type);\n \t    show_omp_namelist (omp_clauses->lists[list_type]);\n \t    fputc (')', dumpfile);\n \t  }"}, {"sha": "c69bd0cf1797a2ae9484744538f29630522c0ec1", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -676,10 +676,10 @@ dummy_expr_callback (gfc_expr **e ATTRIBUTE_UNUSED, int *walk_subtrees,\n \n /* Dummy function for code callback, for use when we really\n    don't want to do anything.  */\n-static int\n-dummy_code_callback (gfc_code **e ATTRIBUTE_UNUSED,\n-\t\t     int *walk_subtrees ATTRIBUTE_UNUSED,\n-\t\t     void *data ATTRIBUTE_UNUSED)\n+int\n+gfc_dummy_code_callback (gfc_code **e ATTRIBUTE_UNUSED,\n+\t\t\t int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t\t\t void *data ATTRIBUTE_UNUSED)\n {\n   return 0;\n }\n@@ -844,7 +844,8 @@ static void\n optimize_reduction (gfc_namespace *ns)\n {\n   current_ns = ns;\n-  gfc_code_walker (&ns->code, dummy_code_callback, callback_reduction, NULL);\n+  gfc_code_walker (&ns->code, gfc_dummy_code_callback,\n+\t\t   callback_reduction, NULL);\n \n /* BLOCKs are handled in the expression walker below.  */\n   for (ns = ns->contained; ns; ns = ns->sibling)"}, {"sha": "7ff8a34f18afc566917b7d684403a70a3488777d", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 58, "deletions": 17, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -214,9 +214,9 @@ typedef enum\n   ST_OMP_TASKWAIT, ST_OMP_TASKYIELD, ST_OMP_CANCEL, ST_OMP_CANCELLATION_POINT,\n   ST_OMP_TASKGROUP, ST_OMP_END_TASKGROUP, ST_OMP_SIMD, ST_OMP_END_SIMD,\n   ST_OMP_DO_SIMD, ST_OMP_END_DO_SIMD, ST_OMP_PARALLEL_DO_SIMD,\n-  ST_OMP_END_PARALLEL_DO_SIMD, ST_OMP_DECLARE_SIMD, ST_PROCEDURE, ST_GENERIC,\n-  ST_CRITICAL, ST_END_CRITICAL, ST_GET_FCN_CHARACTERISTICS, ST_LOCK,\n-  ST_UNLOCK, ST_NONE\n+  ST_OMP_END_PARALLEL_DO_SIMD, ST_OMP_DECLARE_SIMD, ST_OMP_DECLARE_REDUCTION,\n+  ST_PROCEDURE, ST_GENERIC, ST_CRITICAL, ST_END_CRITICAL,\n+  ST_GET_FCN_CHARACTERISTICS, ST_LOCK, ST_UNLOCK, ST_NONE\n }\n gfc_statement;\n \n@@ -817,6 +817,10 @@ typedef struct\n      variable for SELECT_TYPE or ASSOCIATE.  */\n   unsigned select_type_temporary:1, associate_var:1;\n \n+  /* This is omp_{out,in,priv,orig} artificial variable in\n+     !$OMP DECLARE REDUCTION.  */\n+  unsigned omp_udr_artificial_var:1;\n+\n   /* Attributes set by compiler extensions (!GCC$ ATTRIBUTES).  */\n   unsigned ext_attr:EXT_ATTR_NUM;\n \n@@ -1037,13 +1041,34 @@ gfc_namelist;\n \n #define gfc_get_namelist() XCNEW (gfc_namelist)\n \n+typedef enum\n+{\n+  OMP_REDUCTION_NONE = -1,\n+  OMP_REDUCTION_PLUS = INTRINSIC_PLUS,\n+  OMP_REDUCTION_MINUS = INTRINSIC_MINUS,\n+  OMP_REDUCTION_TIMES = INTRINSIC_TIMES,\n+  OMP_REDUCTION_AND = INTRINSIC_AND,\n+  OMP_REDUCTION_OR = INTRINSIC_OR,\n+  OMP_REDUCTION_EQV = INTRINSIC_EQV,\n+  OMP_REDUCTION_NEQV = INTRINSIC_NEQV,\n+  OMP_REDUCTION_MAX = GFC_INTRINSIC_END,\n+  OMP_REDUCTION_MIN,\n+  OMP_REDUCTION_IAND,\n+  OMP_REDUCTION_IOR,\n+  OMP_REDUCTION_IEOR,\n+  OMP_REDUCTION_USER\n+}\n+gfc_omp_reduction_op;\n+\n /* For use in OpenMP clauses in case we need extra information\n    (aligned clause alignment, linear clause step, etc.).  */\n \n typedef struct gfc_omp_namelist\n {\n   struct gfc_symbol *sym;\n   struct gfc_expr *expr;\n+  gfc_omp_reduction_op rop;\n+  struct gfc_omp_udr *udr;\n   struct gfc_omp_namelist *next;\n }\n gfc_omp_namelist;\n@@ -1063,20 +1088,7 @@ enum\n   OMP_LIST_LINEAR,\n   OMP_LIST_DEPEND_IN,\n   OMP_LIST_DEPEND_OUT,\n-  OMP_LIST_PLUS,\n-  OMP_LIST_REDUCTION_FIRST = OMP_LIST_PLUS,\n-  OMP_LIST_MULT,\n-  OMP_LIST_SUB,\n-  OMP_LIST_AND,\n-  OMP_LIST_OR,\n-  OMP_LIST_EQV,\n-  OMP_LIST_NEQV,\n-  OMP_LIST_MAX,\n-  OMP_LIST_MIN,\n-  OMP_LIST_IAND,\n-  OMP_LIST_IOR,\n-  OMP_LIST_IEOR,\n-  OMP_LIST_REDUCTION_LAST = OMP_LIST_IEOR,\n+  OMP_LIST_REDUCTION,\n   OMP_LIST_NUM\n };\n \n@@ -1155,6 +1167,25 @@ typedef struct gfc_omp_declare_simd\n gfc_omp_declare_simd;\n #define gfc_get_omp_declare_simd() XCNEW (gfc_omp_declare_simd)\n \n+typedef struct gfc_omp_udr\n+{\n+  struct gfc_omp_udr *next;\n+  locus where; /* Where the !$omp declare reduction construct occurred.  */\n+\n+  const char *name;\n+  gfc_typespec ts;\n+  gfc_omp_reduction_op rop;\n+\n+  struct gfc_symbol *omp_out;\n+  struct gfc_symbol *omp_in;\n+  struct gfc_namespace *combiner_ns;\n+\n+  struct gfc_symbol *omp_priv;\n+  struct gfc_symbol *omp_orig;\n+  struct gfc_namespace *initializer_ns;\n+}\n+gfc_omp_udr;\n+#define gfc_get_omp_udr() XCNEW (gfc_omp_udr)\n \n /* The gfc_st_label structure is a BBT attached to a namespace that\n    records the usage of statement labels within that space.  */\n@@ -1432,6 +1463,7 @@ typedef struct gfc_symtree\n     gfc_user_op *uop;\n     gfc_common_head *common;\n     gfc_typebound_proc *tb;\n+    gfc_omp_udr *omp_udr;\n   }\n   n;\n }\n@@ -1462,6 +1494,8 @@ typedef struct gfc_namespace\n   gfc_symtree *uop_root;\n   /* Tree containing all the common blocks.  */\n   gfc_symtree *common_root;\n+  /* Tree containing all the OpenMP user defined reductions.  */\n+  gfc_symtree *omp_udr_root;\n \n   /* Tree containing type-bound procedures.  */\n   gfc_symtree *tb_sym_root;\n@@ -1547,6 +1581,9 @@ typedef struct gfc_namespace\n   /* Set to 1 if symbols in this namespace should be 'construct entities',\n      i.e. for BLOCK local variables.  */\n   unsigned construct_entities:1;\n+\n+  /* Set to 1 for !$OMP DECLARE REDUCTION namespaces.  */\n+  unsigned omp_udr_ns:1;\n }\n gfc_namespace;\n \n@@ -2814,11 +2851,14 @@ struct gfc_omp_saved_state { void *ptrs[2]; int ints[1]; };\n void gfc_free_omp_clauses (gfc_omp_clauses *);\n void gfc_free_omp_declare_simd (gfc_omp_declare_simd *);\n void gfc_free_omp_declare_simd_list (gfc_omp_declare_simd *);\n+void gfc_free_omp_udr (gfc_omp_udr *);\n+gfc_omp_udr *gfc_omp_udr_find (gfc_symtree *, gfc_typespec *);\n void gfc_resolve_omp_directive (gfc_code *, gfc_namespace *);\n void gfc_resolve_do_iterator (gfc_code *, gfc_symbol *);\n void gfc_resolve_omp_parallel_blocks (gfc_code *, gfc_namespace *);\n void gfc_resolve_omp_do_blocks (gfc_code *, gfc_namespace *);\n void gfc_resolve_omp_declare_simd (gfc_namespace *);\n+void gfc_resolve_omp_udrs (gfc_symtree *);\n void gfc_omp_save_and_clear_state (struct gfc_omp_saved_state *);\n void gfc_omp_restore_state (struct gfc_omp_saved_state *);\n \n@@ -3094,6 +3134,7 @@ void gfc_run_passes (gfc_namespace *);\n typedef int (*walk_code_fn_t) (gfc_code **, int *, void *);\n typedef int (*walk_expr_fn_t) (gfc_expr **, int *, void *);\n \n+int gfc_dummy_code_callback (gfc_code **, int *, void *);\n int gfc_expr_walker (gfc_expr **, walk_expr_fn_t, void *);\n int gfc_code_walker (gfc_code **, walk_code_fn_t, walk_expr_fn_t, void *);\n "}, {"sha": "86c2d1bd46dbcb523b495ee7c0f9e8fec53a9c41", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -129,6 +129,7 @@ match gfc_match_omp_barrier (void);\n match gfc_match_omp_cancel (void);\n match gfc_match_omp_cancellation_point (void);\n match gfc_match_omp_critical (void);\n+match gfc_match_omp_declare_reduction (void);\n match gfc_match_omp_declare_simd (void);\n match gfc_match_omp_do (void);\n match gfc_match_omp_do_simd (void);"}, {"sha": "261c904433210506ab3655fa55886cfb6e84b7c7", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 295, "deletions": 2, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -82,7 +82,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Don't put any single quote (') in MOD_VERSION, if you want it to be\n    recognized.  */\n-#define MOD_VERSION \"12\"\n+#define MOD_VERSION \"13\"\n \n \n /* Structure that describes a position within a module file.  */\n@@ -3896,6 +3896,98 @@ mio_omp_declare_simd (gfc_namespace *ns, gfc_omp_declare_simd **odsp)\n }\n \n \n+static const mstring omp_declare_reduction_stmt[] =\n+{\n+    minit (\"ASSIGN\", 0),\n+    minit (\"CALL\", 1),\n+    minit (NULL, -1)\n+};\n+\n+\n+static void\n+mio_omp_udr_expr (gfc_omp_udr *udr, gfc_symbol **sym1, gfc_symbol **sym2,\n+\t\t  gfc_namespace *ns, bool is_initializer)\n+{\n+  if (iomode == IO_OUTPUT)\n+    {\n+      if ((*sym1)->module == NULL)\n+\t{\n+\t  (*sym1)->module = module_name;\n+\t  (*sym2)->module = module_name;\n+\t}\n+      mio_symbol_ref (sym1);\n+      mio_symbol_ref (sym2);\n+      if (ns->code->op == EXEC_ASSIGN)\n+\t{\n+\t  mio_name (0, omp_declare_reduction_stmt);\n+\t  mio_expr (&ns->code->expr1);\n+\t  mio_expr (&ns->code->expr2);\n+\t}\n+      else\n+\t{\n+\t  int flag;\n+\t  mio_name (1, omp_declare_reduction_stmt);\n+\t  mio_symtree_ref (&ns->code->symtree);\n+\t  mio_actual_arglist (&ns->code->ext.actual);\n+\n+\t  flag = ns->code->resolved_isym != NULL;\n+\t  mio_integer (&flag);\n+\t  if (flag)\n+\t    write_atom (ATOM_STRING, ns->code->resolved_isym->name);\n+\t  else\n+\t    mio_symbol_ref (&ns->code->resolved_sym);\n+\t}\n+    }\n+  else\n+    {\n+      pointer_info *p1 = mio_symbol_ref (sym1);\n+      pointer_info *p2 = mio_symbol_ref (sym2);\n+      gfc_symbol *sym;\n+      gcc_assert (p1->u.rsym.ns == p2->u.rsym.ns);\n+      gcc_assert (p1->u.rsym.sym == NULL);\n+      /* Add hidden symbols to the symtree.  */\n+      pointer_info *q = get_integer (p1->u.rsym.ns);\n+      q->u.pointer = (void *) ns;\n+      sym = gfc_new_symbol (is_initializer ? \"omp_priv\" : \"omp_out\", ns);\n+      sym->ts = udr->ts;\n+      sym->module = gfc_get_string (p1->u.rsym.module);\n+      associate_integer_pointer (p1, sym);\n+      sym->attr.omp_udr_artificial_var = 1;\n+      gcc_assert (p2->u.rsym.sym == NULL);\n+      sym = gfc_new_symbol (is_initializer ? \"omp_orig\" : \"omp_in\", ns);\n+      sym->ts = udr->ts;\n+      sym->module = gfc_get_string (p2->u.rsym.module);\n+      associate_integer_pointer (p2, sym);\n+      sym->attr.omp_udr_artificial_var = 1;\n+      if (mio_name (0, omp_declare_reduction_stmt) == 0)\n+\t{\n+\t  ns->code = gfc_get_code (EXEC_ASSIGN);\n+\t  mio_expr (&ns->code->expr1);\n+\t  mio_expr (&ns->code->expr2);\n+\t}\n+      else\n+\t{\n+\t  int flag;\n+\t  ns->code = gfc_get_code (EXEC_CALL);\n+\t  mio_symtree_ref (&ns->code->symtree);\n+\t  mio_actual_arglist (&ns->code->ext.actual);\n+\n+\t  mio_integer (&flag);\n+\t  if (flag)\n+\t    {\n+\t      require_atom (ATOM_STRING);\n+\t      ns->code->resolved_isym = gfc_find_subroutine (atom_string);\n+\t      free (atom_string);\n+\t    }\n+\t  else\n+\t    mio_symbol_ref (&ns->code->resolved_sym);\n+\t}\n+      ns->code->loc = gfc_current_locus;\n+      ns->omp_udr_ns = 1;\n+    }\n+}\n+\n+\n /* Unlike most other routines, the address of the symbol node is already\n    fixed on input and the name/module has already been filled in.\n    If you update the symbol format here, don't forget to update read_module\n@@ -4453,6 +4545,119 @@ load_derived_extensions (void)\n }\n \n \n+/* This function loads OpenMP user defined reductions.  */\n+static void\n+load_omp_udrs (void)\n+{\n+  mio_lparen ();\n+  while (peek_atom () != ATOM_RPAREN)\n+    {\n+      const char *name, *newname;\n+      char *altname;\n+      gfc_typespec ts;\n+      gfc_symtree *st;\n+      gfc_omp_reduction_op rop = OMP_REDUCTION_USER;\n+\n+      mio_lparen ();\n+      mio_pool_string (&name);\n+      mio_typespec (&ts);\n+      if (strncmp (name, \"operator \", sizeof (\"operator \") - 1) == 0)\n+\t{\n+\t  const char *p = name + sizeof (\"operator \") - 1;\n+\t  if (strcmp (p, \"+\") == 0)\n+\t    rop = OMP_REDUCTION_PLUS;\n+\t  else if (strcmp (p, \"*\") == 0)\n+\t    rop = OMP_REDUCTION_TIMES;\n+\t  else if (strcmp (p, \"-\") == 0)\n+\t    rop = OMP_REDUCTION_MINUS;\n+\t  else if (strcmp (p, \".and.\") == 0)\n+\t    rop = OMP_REDUCTION_AND;\n+\t  else if (strcmp (p, \".or.\") == 0)\n+\t    rop = OMP_REDUCTION_OR;\n+\t  else if (strcmp (p, \".eqv.\") == 0)\n+\t    rop = OMP_REDUCTION_EQV;\n+\t  else if (strcmp (p, \".neqv.\") == 0)\n+\t    rop = OMP_REDUCTION_NEQV;\n+\t}\n+      altname = NULL;\n+      if (rop == OMP_REDUCTION_USER && name[0] == '.')\n+\t{\n+\t  size_t len = strlen (name + 1);\n+\t  altname = XALLOCAVEC (char, len);\n+\t  gcc_assert (name[len] == '.');\n+\t  memcpy (altname, name + 1, len - 1);\n+\t  altname[len - 1] = '\\0';\n+\t}\n+      newname = name;\n+      if (rop == OMP_REDUCTION_USER)\n+\tnewname = find_use_name (altname ? altname : name, !!altname);\n+      else if (only_flag && find_use_operator ((gfc_intrinsic_op) rop) == NULL)\n+\tnewname = NULL;\n+      if (newname == NULL)\n+\t{\n+\t  skip_list (1);\n+\t  continue;\n+\t}\n+      if (altname && newname != altname)\n+\t{\n+\t  size_t len = strlen (newname);\n+\t  altname = XALLOCAVEC (char, len + 3);\n+\t  altname[0] = '.';\n+\t  memcpy (altname + 1, newname, len);\n+\t  altname[len + 1] = '.';\n+\t  altname[len + 2] = '\\0';\n+\t  name = gfc_get_string (altname);\n+\t}\n+      st = gfc_find_symtree (gfc_current_ns->omp_udr_root, name);\n+      gfc_omp_udr *udr = gfc_omp_udr_find (st, &ts);\n+      if (udr)\n+\t{\n+\t  require_atom (ATOM_INTEGER);\n+\t  pointer_info *p = get_integer (atom_int);\n+\t  if (strcmp (p->u.rsym.module, udr->omp_out->module))\n+\t    {\n+\t      gfc_error (\"Ambiguous !$OMP DECLARE REDUCTION from \"\n+\t\t\t \"module %s at %L\",\n+\t\t\t p->u.rsym.module, &gfc_current_locus);\n+\t      gfc_error (\"Previous !$OMP DECLARE REDUCTION from module \"\n+\t\t\t \"%s at %L\",\n+\t\t\t udr->omp_out->module, &udr->where);\n+\t    }\n+\t  skip_list (1);\n+\t  continue;\n+\t}\n+      udr = gfc_get_omp_udr ();\n+      udr->name = name;\n+      udr->rop = rop;\n+      udr->ts = ts;\n+      udr->where = gfc_current_locus;\n+      udr->combiner_ns = gfc_get_namespace (gfc_current_ns, 1);\n+      udr->combiner_ns->proc_name = gfc_current_ns->proc_name;\n+      mio_omp_udr_expr (udr, &udr->omp_out, &udr->omp_in, udr->combiner_ns,\n+\t\t\tfalse);\n+      if (peek_atom () != ATOM_RPAREN)\n+\t{\n+\t  udr->initializer_ns = gfc_get_namespace (gfc_current_ns, 1);\n+\t  udr->initializer_ns->proc_name = gfc_current_ns->proc_name;\n+\t  mio_omp_udr_expr (udr, &udr->omp_priv, &udr->omp_orig,\n+\t\t\t    udr->initializer_ns, true);\n+\t}\n+      if (st)\n+\t{\n+\t  udr->next = st->n.omp_udr;\n+\t  st->n.omp_udr = udr;\n+\t}\n+      else\n+\t{\n+\t  st = gfc_new_symtree (&gfc_current_ns->omp_udr_root, name);\n+\t  st->n.omp_udr = udr;\n+\t}\n+      mio_rparen ();\n+    }\n+  mio_rparen ();\n+}\n+\n+\n /* Recursive function to traverse the pointer_info tree and load a\n    needed symbol.  We return nonzero if we load a symbol and stop the\n    traversal, because the act of loading can alter the tree.  */\n@@ -4640,7 +4845,7 @@ check_for_ambiguous (gfc_symbol *st_sym, pointer_info *info)\n static void\n read_module (void)\n {\n-  module_locus operator_interfaces, user_operators, extensions;\n+  module_locus operator_interfaces, user_operators, extensions, omp_udrs;\n   const char *p;\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   int i;\n@@ -4664,6 +4869,10 @@ read_module (void)\n   get_module_locus (&extensions);\n   skip_list ();\n \n+  /* Skip OpenMP UDRs.  */\n+  get_module_locus (&omp_udrs);\n+  skip_list ();\n+\n   mio_lparen ();\n \n   /* Create the fixup nodes for all the symbols.  */\n@@ -4929,6 +5138,10 @@ read_module (void)\n   load_commons ();\n   load_equiv ();\n \n+  /* Load OpenMP user defined reductions.  */\n+  set_module_locus (&omp_udrs);\n+  load_omp_udrs ();\n+\n   /* At this point, we read those symbols that are needed but haven't\n      been loaded yet.  If one symbol requires another, the other gets\n      marked as NEEDED if its previous state was UNUSED.  */\n@@ -5307,6 +5520,80 @@ write_symbol0 (gfc_symtree *st)\n }\n \n \n+static void\n+write_omp_udr (gfc_omp_udr *udr)\n+{\n+  switch (udr->rop)\n+    {\n+    case OMP_REDUCTION_USER:\n+      /* Non-operators can't be used outside of the module.  */\n+      if (udr->name[0] != '.')\n+\treturn;\n+      else\n+\t{\n+\t  gfc_symtree *st;\n+\t  size_t len = strlen (udr->name + 1);\n+\t  char *name = XALLOCAVEC (char, len);\n+\t  memcpy (name, udr->name, len - 1);\n+\t  name[len - 1] = '\\0';\n+\t  st = gfc_find_symtree (gfc_current_ns->uop_root, name);\n+\t  /* If corresponding user operator is private, don't write\n+\t     the UDR.  */\n+\t  if (st != NULL)\n+\t    {\n+\t      gfc_user_op *uop = st->n.uop;\n+\t      if (!check_access (uop->access, uop->ns->default_access))\n+\t\treturn;\n+\t    }\n+\t}\n+      break;\n+    case OMP_REDUCTION_PLUS:\n+    case OMP_REDUCTION_MINUS:\n+    case OMP_REDUCTION_TIMES:\n+    case OMP_REDUCTION_AND:\n+    case OMP_REDUCTION_OR:\n+    case OMP_REDUCTION_EQV:\n+    case OMP_REDUCTION_NEQV:\n+      /* If corresponding operator is private, don't write the UDR.  */\n+      if (!check_access (gfc_current_ns->operator_access[udr->rop],\n+\t\t\t gfc_current_ns->default_access))\n+\treturn;\n+      break;\n+    default:\n+      break;\n+    }\n+  if (udr->ts.type == BT_DERIVED || udr->ts.type == BT_CLASS)\n+    {\n+      /* If derived type is private, don't write the UDR.  */\n+      if (!gfc_check_symbol_access (udr->ts.u.derived))\n+\treturn;\n+    }\n+\n+  mio_lparen ();\n+  mio_pool_string (&udr->name);\n+  mio_typespec (&udr->ts);\n+  mio_omp_udr_expr (udr, &udr->omp_out, &udr->omp_in, udr->combiner_ns, false);\n+  if (udr->initializer_ns)\n+    mio_omp_udr_expr (udr, &udr->omp_priv, &udr->omp_orig,\n+\t\t      udr->initializer_ns, true);\n+  mio_rparen ();\n+}\n+\n+\n+static void\n+write_omp_udrs (gfc_symtree *st)\n+{\n+  if (st == NULL)\n+    return;\n+\n+  write_omp_udrs (st->left);\n+  gfc_omp_udr *udr;\n+  for (udr = st->n.omp_udr; udr; udr = udr->next)\n+    write_omp_udr (udr);\n+  write_omp_udrs (st->right);\n+}\n+\n+\n /* Type for the temporary tree used when writing secondary symbols.  */\n \n struct sorted_pointer_info\n@@ -5555,6 +5842,12 @@ write_module (void)\n   write_char ('\\n');\n   write_char ('\\n');\n \n+  mio_lparen ();\n+  write_omp_udrs (gfc_current_ns->omp_udr_root);\n+  mio_rparen ();\n+  write_char ('\\n');\n+  write_char ('\\n');\n+\n   /* Write symbol information.  First we traverse all symbols in the\n      primary namespace, writing those that need to be written.\n      Sometimes writing one symbol will cause another to need to be"}, {"sha": "4d92575da0df1a78e3fad695de74d73fc4b3fafe", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 759, "deletions": 79, "changes": 838, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"flags.h\"\n #include \"gfortran.h\"\n+#include \"arith.h\"\n #include \"match.h\"\n #include \"parse.h\"\n #include \"pointer-set.h\"\n@@ -99,6 +100,66 @@ gfc_free_omp_declare_simd_list (gfc_omp_declare_simd *list)\n     }\n }\n \n+/* Free an !$omp declare reduction.  */\n+\n+void\n+gfc_free_omp_udr (gfc_omp_udr *omp_udr)\n+{\n+  if (omp_udr)\n+    {\n+      gfc_free_omp_udr (omp_udr->next);\n+      gfc_free_namespace (omp_udr->combiner_ns);\n+      if (omp_udr->initializer_ns)\n+\tgfc_free_namespace (omp_udr->initializer_ns);\n+      free (omp_udr);\n+    }\n+}\n+\n+\n+static gfc_omp_udr *\n+gfc_find_omp_udr (gfc_namespace *ns, const char *name, gfc_typespec *ts)\n+{\n+  gfc_symtree *st;\n+\n+  if (ns == NULL)\n+    ns = gfc_current_ns;\n+  do\n+    {\n+      gfc_omp_udr *omp_udr;\n+\n+      st = gfc_find_symtree (ns->omp_udr_root, name);\n+      if (st != NULL)\n+\tfor (omp_udr = st->n.omp_udr; omp_udr; omp_udr = omp_udr->next)\n+\t  if (ts == NULL)\n+\t    return omp_udr;\n+\t  else if (gfc_compare_types (&omp_udr->ts, ts))\n+\t    {\n+\t      if (ts->type == BT_CHARACTER)\n+\t\t{\n+\t\t  if (omp_udr->ts.u.cl->length == NULL)\n+\t\t    return omp_udr;\n+\t\t  if (ts->u.cl->length == NULL)\n+\t\t    continue;\n+\t\t  if (gfc_compare_expr (omp_udr->ts.u.cl->length,\n+\t\t\t\t\tts->u.cl->length,\n+\t\t\t\t\tINTRINSIC_EQ) != 0)\n+\t\t    continue;\n+\t\t}\n+\t      return omp_udr;\n+\t    }\n+\n+      /* Don't escape an interface block.  */\n+      if (ns && !ns->has_import_set\n+\t  && ns->proc_name && ns->proc_name->attr.if_source == IFSRC_IFBODY)\n+\tbreak;\n+\n+      ns = ns->parent;\n+    }\n+  while (ns != NULL);\n+\n+  return NULL;\n+}\n+\n \n /* Match a variable/common block list and construct a namelist from it.  */\n \n@@ -313,22 +374,30 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, int mask, bool first = true,\n       if ((mask & OMP_CLAUSE_REDUCTION)\n \t  && gfc_match (\"reduction ( \") == MATCH_YES)\n \t{\n-\t  int reduction = OMP_LIST_NUM;\n-\t  char buffer[GFC_MAX_SYMBOL_LEN + 1];\n+\t  gfc_omp_reduction_op rop = OMP_REDUCTION_NONE;\n+\t  char buffer[GFC_MAX_SYMBOL_LEN + 3];\n \t  if (gfc_match_char ('+') == MATCH_YES)\n-\t    reduction = OMP_LIST_PLUS;\n+\t    rop = OMP_REDUCTION_PLUS;\n \t  else if (gfc_match_char ('*') == MATCH_YES)\n-\t    reduction = OMP_LIST_MULT;\n+\t    rop = OMP_REDUCTION_TIMES;\n \t  else if (gfc_match_char ('-') == MATCH_YES)\n-\t    reduction = OMP_LIST_SUB;\n+\t    rop = OMP_REDUCTION_MINUS;\n \t  else if (gfc_match (\".and.\") == MATCH_YES)\n-\t    reduction = OMP_LIST_AND;\n+\t    rop = OMP_REDUCTION_AND;\n \t  else if (gfc_match (\".or.\") == MATCH_YES)\n-\t    reduction = OMP_LIST_OR;\n+\t    rop = OMP_REDUCTION_OR;\n \t  else if (gfc_match (\".eqv.\") == MATCH_YES)\n-\t    reduction = OMP_LIST_EQV;\n+\t    rop = OMP_REDUCTION_EQV;\n \t  else if (gfc_match (\".neqv.\") == MATCH_YES)\n-\t    reduction = OMP_LIST_NEQV;\n+\t    rop = OMP_REDUCTION_NEQV;\n+\t  if (rop != OMP_REDUCTION_NONE)\n+\t    snprintf (buffer, sizeof buffer,\n+\t\t      \"operator %s\", gfc_op2string ((gfc_intrinsic_op) rop));\n+\t  else if (gfc_match_defined_op_name (buffer + 1, 1) == MATCH_YES)\n+\t    {\n+\t      buffer[0] = '.';\n+\t      strcat (buffer, \".\");\n+\t    }\n \t  else if (gfc_match_name (buffer) == MATCH_YES)\n \t    {\n \t      gfc_symbol *sym;\n@@ -356,40 +425,60 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, int mask, bool first = true,\n \t\t\t   || sym->attr.if_source != IFSRC_UNKNOWN\n \t\t\t   || sym == sym->ns->proc_name)\n \t\t    {\n-\t\t      gfc_error_now (\"%s is not INTRINSIC procedure name \"\n-\t\t\t\t     \"at %C\", buffer);\n \t\t      sym = NULL;\n+\t\t      n = NULL;\n \t\t    }\n \t\t  else\n \t\t    n = sym->name;\n \t\t}\n-\t      if (strcmp (n, \"max\") == 0)\n-\t\treduction = OMP_LIST_MAX;\n+\t      if (n == NULL)\n+\t\trop = OMP_REDUCTION_NONE;\n+\t      else if (strcmp (n, \"max\") == 0)\n+\t\trop = OMP_REDUCTION_MAX;\n \t      else if (strcmp (n, \"min\") == 0)\n-\t\treduction = OMP_LIST_MIN;\n+\t\trop = OMP_REDUCTION_MIN;\n \t      else if (strcmp (n, \"iand\") == 0)\n-\t\treduction = OMP_LIST_IAND;\n+\t\trop = OMP_REDUCTION_IAND;\n \t      else if (strcmp (n, \"ior\") == 0)\n-\t\treduction = OMP_LIST_IOR;\n+\t\trop = OMP_REDUCTION_IOR;\n \t      else if (strcmp (n, \"ieor\") == 0)\n-\t\treduction = OMP_LIST_IEOR;\n-\t      if (reduction != OMP_LIST_NUM\n+\t\trop = OMP_REDUCTION_IEOR;\n+\t      if (rop != OMP_REDUCTION_NONE\n \t\t  && sym != NULL\n \t\t  && ! sym->attr.intrinsic\n \t\t  && ! sym->attr.use_assoc\n \t\t  && ((sym->attr.flavor == FL_UNKNOWN\n-\t\t       && !gfc_add_flavor (&sym->attr, FL_PROCEDURE, sym->name, NULL))\n+\t\t       && !gfc_add_flavor (&sym->attr, FL_PROCEDURE,\n+\t\t\t\t\t   sym->name, NULL))\n \t\t      || !gfc_add_intrinsic (&sym->attr, NULL)))\n+\t\trop = OMP_REDUCTION_NONE;\n+\t    }\n+\t  gfc_omp_udr *udr = gfc_find_omp_udr (gfc_current_ns, buffer, NULL);\n+\t  gfc_omp_namelist **head = NULL;\n+\t  if (rop == OMP_REDUCTION_NONE && udr)\n+\t    rop = OMP_REDUCTION_USER;\n+\n+\t  if (gfc_match_omp_variable_list (\" :\",\n+\t\t\t\t\t   &c->lists[OMP_LIST_REDUCTION],\n+\t\t\t\t\t   false, NULL, &head) == MATCH_YES)\n+\t    {\n+\t      gfc_omp_namelist *n;\n+\t      if (rop == OMP_REDUCTION_NONE)\n \t\t{\n-\t\t  gfc_free_omp_clauses (c);\n-\t\t  return MATCH_ERROR;\n+\t\t  n = *head;\n+\t\t  *head = NULL;\n+\t\t  gfc_error_now (\"!$OMP DECLARE REDUCTION %s not found \"\n+\t\t\t\t \"at %L\", buffer, &old_loc);\n+\t\t  gfc_free_omp_namelist (n);\n \t\t}\n+\t      else\n+\t\tfor (n = *head; n; n = n->next)\n+\t\t  {\n+\t\t    n->rop = rop;\n+\t\t    n->udr = udr;\n+\t\t  }\n+\t      continue;\n \t    }\n-\t  if (reduction != OMP_LIST_NUM\n-\t      && gfc_match_omp_variable_list (\" :\", &c->lists[reduction],\n-\t\t\t\t\t      false)\n-\t\t == MATCH_YES)\n-\t    continue;\n \t  else\n \t    gfc_current_locus = old_loc;\n \t}\n@@ -777,6 +866,382 @@ gfc_match_omp_declare_simd (void)\n }\n \n \n+static bool\n+match_udr_expr (gfc_symtree *omp_sym1, gfc_symtree *omp_sym2)\n+{\n+  match m;\n+  locus old_loc = gfc_current_locus;\n+  char sname[GFC_MAX_SYMBOL_LEN + 1];\n+  gfc_symbol *sym;\n+  gfc_namespace *ns = gfc_current_ns;\n+  gfc_expr *lvalue = NULL, *rvalue = NULL;\n+  gfc_symtree *st;\n+  gfc_actual_arglist *arglist;\n+\n+  m = gfc_match (\" %v =\", &lvalue);\n+  if (m != MATCH_YES)\n+    gfc_current_locus = old_loc;\n+  else\n+    {\n+      m = gfc_match (\" %e )\", &rvalue);\n+      if (m == MATCH_YES)\n+\t{\n+\t  ns->code = gfc_get_code (EXEC_ASSIGN);\n+\t  ns->code->expr1 = lvalue;\n+\t  ns->code->expr2 = rvalue;\n+\t  ns->code->loc = old_loc;\n+\t  return true;\n+\t}\n+\n+      gfc_current_locus = old_loc;\n+      gfc_free_expr (lvalue);\n+    }\n+\n+  m = gfc_match (\" %n\", sname);\n+  if (m != MATCH_YES)\n+    return false;\n+\n+  if (strcmp (sname, omp_sym1->name) == 0\n+      || strcmp (sname, omp_sym2->name) == 0)\n+    return false;\n+\n+  gfc_current_ns = ns->parent;\n+  if (gfc_get_ha_sym_tree (sname, &st))\n+    return false;\n+\n+  sym = st->n.sym;\n+  if (sym->attr.flavor != FL_PROCEDURE\n+      && sym->attr.flavor != FL_UNKNOWN)\n+    return false;\n+\n+  if (!sym->attr.generic\n+      && !sym->attr.subroutine\n+      && !sym->attr.function)\n+    {\n+      if (!(sym->attr.external && !sym->attr.referenced))\n+\t{\n+\t  /* ...create a symbol in this scope...  */\n+\t  if (sym->ns != gfc_current_ns\n+\t      && gfc_get_sym_tree (sname, NULL, &st, false) == 1)\n+\t    return false;\n+\n+\t  if (sym != st->n.sym)\n+\t    sym = st->n.sym;\n+\t}\n+\n+      /* ...and then to try to make the symbol into a subroutine.  */\n+      if (!gfc_add_subroutine (&sym->attr, sym->name, NULL))\n+\treturn false;\n+    }\n+\n+  gfc_set_sym_referenced (sym);\n+  gfc_gobble_whitespace ();\n+  if (gfc_peek_ascii_char () != '(')\n+    return false;\n+\n+  gfc_current_ns = ns;\n+  m = gfc_match_actual_arglist (1, &arglist);\n+  if (m != MATCH_YES)\n+    return false;\n+\n+  if (gfc_match_char (')') != MATCH_YES)\n+    return false;\n+\n+  ns->code = gfc_get_code (EXEC_CALL);\n+  ns->code->symtree = st;\n+  ns->code->ext.actual = arglist;\n+  ns->code->loc = old_loc;\n+  return true;\n+}\n+\n+static bool\n+gfc_omp_udr_predef (gfc_omp_reduction_op rop, const char *name,\n+\t\t    gfc_typespec *ts, const char **n)\n+{\n+  if (!gfc_numeric_ts (ts) && ts->type != BT_LOGICAL)\n+    return false;\n+\n+  switch (rop)\n+    {\n+    case OMP_REDUCTION_PLUS:\n+    case OMP_REDUCTION_MINUS:\n+    case OMP_REDUCTION_TIMES:\n+      return ts->type != BT_LOGICAL;\n+    case OMP_REDUCTION_AND:\n+    case OMP_REDUCTION_OR:\n+    case OMP_REDUCTION_EQV:\n+    case OMP_REDUCTION_NEQV:\n+      return ts->type == BT_LOGICAL;\n+    case OMP_REDUCTION_USER:\n+      if (name[0] != '.' && (ts->type == BT_INTEGER || ts->type == BT_REAL))\n+\t{\n+\t  gfc_symbol *sym;\n+\n+\t  gfc_find_symbol (name, NULL, 1, &sym);\n+\t  if (sym != NULL)\n+\t    {\n+\t      if (sym->attr.intrinsic)\n+\t\t*n = sym->name;\n+\t      else if ((sym->attr.flavor != FL_UNKNOWN\n+\t\t\t&& sym->attr.flavor != FL_PROCEDURE)\n+\t\t       || sym->attr.external\n+\t\t       || sym->attr.generic\n+\t\t       || sym->attr.entry\n+\t\t       || sym->attr.result\n+\t\t       || sym->attr.dummy\n+\t\t       || sym->attr.subroutine\n+\t\t       || sym->attr.pointer\n+\t\t       || sym->attr.target\n+\t\t       || sym->attr.cray_pointer\n+\t\t       || sym->attr.cray_pointee\n+\t\t       || (sym->attr.proc != PROC_UNKNOWN\n+\t\t\t   && sym->attr.proc != PROC_INTRINSIC)\n+\t\t       || sym->attr.if_source != IFSRC_UNKNOWN\n+\t\t       || sym == sym->ns->proc_name)\n+\t\t*n = NULL;\n+\t      else\n+\t\t*n = sym->name;\n+\t    }\n+\t  else\n+\t    *n = name;\n+\t  if (*n\n+\t      && (strcmp (*n, \"max\") == 0 || strcmp (*n, \"min\") == 0))\n+\t    return true;\n+\t  else if (*n\n+\t\t   && ts->type == BT_INTEGER\n+\t\t   && (strcmp (*n, \"iand\") == 0\n+\t\t       || strcmp (*n, \"ior\") == 0\n+\t\t       || strcmp (*n, \"ieor\") == 0))\n+\t    return true;\n+\t}\n+      break;\n+    default:\n+      break;\n+    }\n+  return false;\n+}\n+\n+gfc_omp_udr *\n+gfc_omp_udr_find (gfc_symtree *st, gfc_typespec *ts)\n+{\n+  gfc_omp_udr *omp_udr;\n+\n+  if (st == NULL)\n+    return NULL;\n+\n+  for (omp_udr = st->n.omp_udr; omp_udr; omp_udr = omp_udr->next)\n+    if (omp_udr->ts.type == ts->type\n+\t|| ((omp_udr->ts.type == BT_DERIVED || omp_udr->ts.type == BT_CLASS)\n+\t    && (ts->type == BT_DERIVED && ts->type == BT_CLASS)))\n+      {\n+\tif (omp_udr->ts.type == BT_DERIVED || omp_udr->ts.type == BT_CLASS)\n+\t  {\n+\t    if (strcmp (omp_udr->ts.u.derived->name, ts->u.derived->name) == 0)\n+\t      return omp_udr;\n+\t  }\n+\telse if (omp_udr->ts.kind == ts->kind)\n+\t  {\n+\t    if (omp_udr->ts.type == BT_CHARACTER)\n+\t      {\n+\t\tif (omp_udr->ts.u.cl->length == NULL\n+\t\t    || ts->u.cl->length == NULL)\n+\t\t  return omp_udr;\n+\t\tif (omp_udr->ts.u.cl->length->expr_type != EXPR_CONSTANT)\n+\t\t  return omp_udr;\n+\t\tif (ts->u.cl->length->expr_type != EXPR_CONSTANT)\n+\t\t  return omp_udr;\n+\t\tif (omp_udr->ts.u.cl->length->ts.type != BT_INTEGER)\n+\t\t  return omp_udr;\n+\t\tif (ts->u.cl->length->ts.type != BT_INTEGER)\n+\t\t  return omp_udr;\n+\t\tif (gfc_compare_expr (omp_udr->ts.u.cl->length,\n+\t\t\t\t      ts->u.cl->length, INTRINSIC_EQ) != 0)\n+\t\t  continue;\n+\t      }\n+\t    return omp_udr;\n+\t  }\n+      }\n+  return NULL;\n+}\n+\n+match\n+gfc_match_omp_declare_reduction (void)\n+{\n+  match m;\n+  gfc_intrinsic_op op;\n+  char name[GFC_MAX_SYMBOL_LEN + 3];\n+  auto_vec<gfc_typespec, 5> tss;\n+  gfc_typespec ts;\n+  unsigned int i;\n+  gfc_symtree *st;\n+  locus where = gfc_current_locus;\n+  locus end_loc = gfc_current_locus;\n+  bool end_loc_set = false;\n+  gfc_omp_reduction_op rop = OMP_REDUCTION_NONE;\n+\n+  if (gfc_match_char ('(') != MATCH_YES)\n+    return MATCH_ERROR;\n+\n+  m = gfc_match (\" %o : \", &op);\n+  if (m == MATCH_ERROR)\n+    return MATCH_ERROR;\n+  if (m == MATCH_YES)\n+    {\n+      snprintf (name, sizeof name, \"operator %s\", gfc_op2string (op));\n+      rop = (gfc_omp_reduction_op) op;\n+    }\n+  else\n+    {\n+      m = gfc_match_defined_op_name (name + 1, 1);\n+      if (m == MATCH_ERROR)\n+\treturn MATCH_ERROR;\n+      if (m == MATCH_YES)\n+\t{\n+\t  name[0] = '.';\n+\t  strcat (name, \".\");\n+\t  if (gfc_match (\" : \") != MATCH_YES)\n+\t    return MATCH_ERROR;\n+\t}\n+      else\n+\t{\n+\t  if (gfc_match (\" %n : \", name) != MATCH_YES)\n+\t    return MATCH_ERROR;\n+\t}\n+      rop = OMP_REDUCTION_USER;\n+    }\n+\n+  m = gfc_match_type_spec (&ts);\n+  if (m != MATCH_YES)\n+    return MATCH_ERROR;\n+  tss.safe_push (ts);\n+\n+  while (gfc_match_char (',') == MATCH_YES)\n+    {\n+      m = gfc_match_type_spec (&ts);\n+      if (m != MATCH_YES)\n+\treturn MATCH_ERROR;\n+      tss.safe_push (ts);\n+    }\n+  if (gfc_match_char (':') != MATCH_YES)\n+    return MATCH_ERROR;\n+\n+  st = gfc_find_symtree (gfc_current_ns->omp_udr_root, name);\n+  for (i = 0; i < tss.length (); i++)\n+    {\n+      gfc_symtree *omp_out, *omp_in;\n+      gfc_symtree *omp_priv = NULL, *omp_orig = NULL;\n+      gfc_namespace *combiner_ns, *initializer_ns = NULL;\n+      gfc_omp_udr *prev_udr, *omp_udr;\n+      const char *predef_name = NULL;\n+\n+      omp_udr = gfc_get_omp_udr ();\n+      omp_udr->name = gfc_get_string (name);\n+      omp_udr->rop = rop;\n+      omp_udr->ts = tss[i];\n+      omp_udr->where = where;\n+\n+      gfc_current_ns = combiner_ns = gfc_get_namespace (gfc_current_ns, 1);\n+      combiner_ns->proc_name = combiner_ns->parent->proc_name;\n+\n+      gfc_get_sym_tree (\"omp_out\", combiner_ns, &omp_out, false);\n+      gfc_get_sym_tree (\"omp_in\", combiner_ns, &omp_in, false);\n+      combiner_ns->omp_udr_ns = 1;\n+      omp_out->n.sym->ts = tss[i];\n+      omp_in->n.sym->ts = tss[i];\n+      omp_out->n.sym->attr.omp_udr_artificial_var = 1;\n+      omp_in->n.sym->attr.omp_udr_artificial_var = 1;\n+      gfc_commit_symbols ();\n+      omp_udr->combiner_ns = combiner_ns;\n+      omp_udr->omp_out = omp_out->n.sym;\n+      omp_udr->omp_in = omp_in->n.sym;\n+\n+      locus old_loc = gfc_current_locus;\n+\n+      if (!match_udr_expr (omp_out, omp_in))\n+\t{\n+\t syntax:\n+\t  gfc_current_locus = old_loc;\n+\t  gfc_current_ns = combiner_ns->parent;\n+\t  gfc_free_omp_udr (omp_udr);\n+\t  return MATCH_ERROR;\n+\t}\n+\n+      if (gfc_match (\" initializer ( \") == MATCH_YES)\n+\t{\n+\t  gfc_current_ns = combiner_ns->parent;\n+\t  initializer_ns = gfc_get_namespace (gfc_current_ns, 1);\n+\t  gfc_current_ns = initializer_ns;\n+\t  initializer_ns->proc_name = initializer_ns->parent->proc_name;\n+\n+\t  gfc_get_sym_tree (\"omp_priv\", initializer_ns, &omp_priv, false);\n+\t  gfc_get_sym_tree (\"omp_orig\", initializer_ns, &omp_orig, false);\n+\t  initializer_ns->omp_udr_ns = 1;\n+\t  omp_priv->n.sym->ts = tss[i];\n+\t  omp_orig->n.sym->ts = tss[i];\n+\t  omp_priv->n.sym->attr.omp_udr_artificial_var = 1;\n+\t  omp_orig->n.sym->attr.omp_udr_artificial_var = 1;\n+\t  gfc_commit_symbols ();\n+\t  omp_udr->initializer_ns = initializer_ns;\n+\t  omp_udr->omp_priv = omp_priv->n.sym;\n+\t  omp_udr->omp_orig = omp_orig->n.sym;\n+\n+\t  if (!match_udr_expr (omp_priv, omp_orig))\n+\t    goto syntax;\n+\t}\n+\n+      gfc_current_ns = combiner_ns->parent;\n+      if (!end_loc_set)\n+\t{\n+\t  end_loc_set = true;\n+\t  end_loc = gfc_current_locus;\n+\t}\n+      gfc_current_locus = old_loc;\n+\n+      prev_udr = gfc_omp_udr_find (st, &tss[i]);\n+      if (gfc_omp_udr_predef (rop, name, &tss[i], &predef_name)\n+\t  /* Don't error on !$omp declare reduction (min : integer : ...)\n+\t     just yet, there could be integer :: min afterwards,\n+\t     making it valid.  When the UDR is resolved, we'll get\n+\t     to it again.  */\n+\t  && (rop != OMP_REDUCTION_USER || name[0] == '.'))\n+\t{\n+\t  if (predef_name)\n+\t    gfc_error_now (\"Redefinition of predefined %s \"\n+\t\t\t   \"!$OMP DECLARE REDUCTION at %L\",\n+\t\t\t   predef_name, &where);\n+\t  else\n+\t    gfc_error_now (\"Redefinition of predefined \"\n+\t\t\t   \"!$OMP DECLARE REDUCTION at %L\", &where);\n+\t}\n+      else if (prev_udr)\n+\t{\n+\t  gfc_error_now (\"Redefinition of !$OMP DECLARE REDUCTION at %L\",\n+\t\t\t &where);\n+\t  gfc_error_now (\"Previous !$OMP DECLARE REDUCTION at %L\",\n+\t\t\t &prev_udr->where);\n+\t}\n+      else if (st)\n+\t{\n+\t  omp_udr->next = st->n.omp_udr;\n+\t  st->n.omp_udr = omp_udr;\n+\t}\n+      else\n+\t{\n+\t  st = gfc_new_symtree (&gfc_current_ns->omp_udr_root, name);\n+\t  st->n.omp_udr = omp_udr;\n+\t}\n+    }\n+\n+  if (end_loc_set)\n+    {\n+      gfc_current_locus = end_loc;\n+      return MATCH_YES;\n+    }\n+  gfc_clear_error ();\n+  return MATCH_ERROR;\n+}\n+\n+\n match\n gfc_match_omp_threadprivate (void)\n {\n@@ -1285,10 +1750,8 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n       {\n \tconst char *name;\n \n-\tif (list < OMP_LIST_REDUCTION_FIRST)\n+\tif (list < OMP_LIST_NUM)\n \t  name = clause_names[list];\n-\telse if (list <= OMP_LIST_REDUCTION_LAST)\n-\t  name = clause_names[OMP_LIST_REDUCTION_FIRST];\n \telse\n \t  gcc_unreachable ();\n \n@@ -1409,6 +1872,7 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t  default:\n \t    for (; n != NULL; n = n->next)\n \t      {\n+\t\tbool bad = false;\n \t\tif (n->sym->attr.threadprivate)\n \t\t  gfc_error (\"THREADPRIVATE object '%s' in %s clause at %L\",\n \t\t\t     n->sym->name, name, where);\n@@ -1417,74 +1881,113 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t\t\t    n->sym->name, name, where);\n \t\tif (list != OMP_LIST_PRIVATE)\n \t\t  {\n-\t\t    if (n->sym->attr.pointer\n-\t\t\t&& list >= OMP_LIST_REDUCTION_FIRST\n-\t\t\t&& list <= OMP_LIST_REDUCTION_LAST)\n+\t\t    if (n->sym->attr.pointer && list == OMP_LIST_REDUCTION)\n \t\t      gfc_error (\"POINTER object '%s' in %s clause at %L\",\n \t\t\t\t n->sym->name, name, where);\n \t\t    /* Variables in REDUCTION-clauses must be of intrinsic type (flagged below).  */\n-\t\t    if ((list < OMP_LIST_REDUCTION_FIRST || list > OMP_LIST_REDUCTION_LAST)\n+\t\t    if (list != OMP_LIST_REDUCTION\n \t\t\t && n->sym->ts.type == BT_DERIVED\n \t\t\t && n->sym->ts.u.derived->attr.alloc_comp)\n \t\t      gfc_error (\"%s clause object '%s' has ALLOCATABLE components at %L\",\n \t\t\t\t name, n->sym->name, where);\n-\t\t    if (n->sym->attr.cray_pointer\n-\t\t\t&& list >= OMP_LIST_REDUCTION_FIRST\n-\t\t\t&& list <= OMP_LIST_REDUCTION_LAST)\n+\t\t    if (n->sym->attr.cray_pointer && list == OMP_LIST_REDUCTION)\n \t\t      gfc_error (\"Cray pointer '%s' in %s clause at %L\",\n \t\t\t\t n->sym->name, name, where);\n \t\t  }\n \t\tif (n->sym->as && n->sym->as->type == AS_ASSUMED_SIZE)\n \t\t  gfc_error (\"Assumed size array '%s' in %s clause at %L\",\n \t\t\t     n->sym->name, name, where);\n-\t\tif (n->sym->attr.in_namelist\n-\t\t    && (list < OMP_LIST_REDUCTION_FIRST\n-\t\t\t|| list > OMP_LIST_REDUCTION_LAST))\n+\t\tif (n->sym->attr.in_namelist && list != OMP_LIST_REDUCTION)\n \t\t  gfc_error (\"Variable '%s' in %s clause is used in \"\n \t\t\t     \"NAMELIST statement at %L\",\n \t\t\t     n->sym->name, name, where);\n \t\tswitch (list)\n \t\t  {\n-\t\t  case OMP_LIST_PLUS:\n-\t\t  case OMP_LIST_MULT:\n-\t\t  case OMP_LIST_SUB:\n-\t\t    if (!gfc_numeric_ts (&n->sym->ts))\n-\t\t      gfc_error (\"%c REDUCTION variable '%s' at %L must be of numeric type, got %s\",\n-\t\t\t\t list == OMP_LIST_PLUS ? '+'\n-\t\t\t\t : list == OMP_LIST_MULT ? '*' : '-',\n-\t\t\t\t n->sym->name, where,\n-\t\t\t\t gfc_typename (&n->sym->ts));\n-\t\t    break;\n-\t\t  case OMP_LIST_AND:\n-\t\t  case OMP_LIST_OR:\n-\t\t  case OMP_LIST_EQV:\n-\t\t  case OMP_LIST_NEQV:\n-\t\t    if (n->sym->ts.type != BT_LOGICAL)\n-\t\t      gfc_error (\"%s REDUCTION variable '%s' must be LOGICAL \"\n-\t\t\t\t \"at %L\",\n-\t\t\t\t list == OMP_LIST_AND ? \".AND.\"\n-\t\t\t\t : list == OMP_LIST_OR ? \".OR.\"\n-\t\t\t\t : list == OMP_LIST_EQV ? \".EQV.\" : \".NEQV.\",\n-\t\t\t\t n->sym->name, where);\n-\t\t    break;\n-\t\t  case OMP_LIST_MAX:\n-\t\t  case OMP_LIST_MIN:\n-\t\t    if (n->sym->ts.type != BT_INTEGER\n-\t\t\t&& n->sym->ts.type != BT_REAL)\n-\t\t      gfc_error (\"%s REDUCTION variable '%s' must be \"\n-\t\t\t\t \"INTEGER or REAL at %L\",\n-\t\t\t\t list == OMP_LIST_MAX ? \"MAX\" : \"MIN\",\n-\t\t\t\t n->sym->name, where);\n-\t\t    break;\n-\t\t  case OMP_LIST_IAND:\n-\t\t  case OMP_LIST_IOR:\n-\t\t  case OMP_LIST_IEOR:\n-\t\t    if (n->sym->ts.type != BT_INTEGER)\n-\t\t      gfc_error (\"%s REDUCTION variable '%s' must be INTEGER \"\n-\t\t\t\t \"at %L\",\n-\t\t\t\t list == OMP_LIST_IAND ? \"IAND\"\n-\t\t\t\t : list == OMP_LIST_MULT ? \"IOR\" : \"IEOR\",\n-\t\t\t\t n->sym->name, where);\n+\t\t  case OMP_LIST_REDUCTION:\n+\t\t    switch (n->rop)\n+\t\t      {\n+\t\t      case OMP_REDUCTION_PLUS:\n+\t\t      case OMP_REDUCTION_TIMES:\n+\t\t      case OMP_REDUCTION_MINUS:\n+\t\t\tif (!gfc_numeric_ts (&n->sym->ts))\n+\t\t\t  bad = true;\n+\t\t\tbreak;\n+\t\t      case OMP_REDUCTION_AND:\n+\t\t      case OMP_REDUCTION_OR:\n+\t\t      case OMP_REDUCTION_EQV:\n+\t\t      case OMP_REDUCTION_NEQV:\n+\t\t\tif (n->sym->ts.type != BT_LOGICAL)\n+\t\t\t  bad = true;\n+\t\t\tbreak;\n+\t\t      case OMP_REDUCTION_MAX:\n+\t\t      case OMP_REDUCTION_MIN:\n+\t\t\tif (n->sym->ts.type != BT_INTEGER\n+\t\t\t    && n->sym->ts.type != BT_REAL)\n+\t\t\t  bad = true;\n+\t\t\tbreak;\n+\t\t      case OMP_REDUCTION_IAND:\n+\t\t      case OMP_REDUCTION_IOR:\n+\t\t      case OMP_REDUCTION_IEOR:\n+\t\t\tif (n->sym->ts.type != BT_INTEGER)\n+\t\t\t  bad = true;\n+\t\t\tbreak;\n+\t\t      case OMP_REDUCTION_USER:\n+\t\t\tbad = true;\n+\t\t\tbreak;\n+\t\t      default:\n+\t\t\tbreak;\n+\t\t      }\n+\t\t    if (!bad)\n+\t\t      n->udr = NULL;\n+\t\t    else\n+\t\t      {\n+\t\t\tconst char *udr_name = NULL;\n+\t\t\tif (n->udr)\n+\t\t\t  {\n+\t\t\t    udr_name = n->udr->name;\n+\t\t\t    n->udr = gfc_find_omp_udr (NULL, udr_name,\n+\t\t\t\t\t\t       &n->sym->ts);\n+\t\t\t  }\n+\t\t\tif (n->udr == NULL)\n+\t\t\t  {\n+\t\t\t    if (udr_name == NULL)\n+\t\t\t      switch (n->rop)\n+\t\t\t\t{\n+\t\t\t\tcase OMP_REDUCTION_PLUS:\n+\t\t\t\tcase OMP_REDUCTION_TIMES:\n+\t\t\t\tcase OMP_REDUCTION_MINUS:\n+\t\t\t\tcase OMP_REDUCTION_AND:\n+\t\t\t\tcase OMP_REDUCTION_OR:\n+\t\t\t\tcase OMP_REDUCTION_EQV:\n+\t\t\t\tcase OMP_REDUCTION_NEQV:\n+\t\t\t\t  udr_name = gfc_op2string ((gfc_intrinsic_op)\n+\t\t\t\t\t\t\t    n->rop);\n+\t\t\t\t  break;\n+\t\t\t\tcase OMP_REDUCTION_MAX:\n+\t\t\t\t  udr_name = \"max\";\n+\t\t\t\t  break;\n+\t\t\t\tcase OMP_REDUCTION_MIN:\n+\t\t\t\t  udr_name = \"min\";\n+\t\t\t\t  break;\n+\t\t\t\tcase OMP_REDUCTION_IAND:\n+\t\t\t\t  udr_name = \"iand\";\n+\t\t\t\t  break;\n+\t\t\t\tcase OMP_REDUCTION_IOR:\n+\t\t\t\t  udr_name = \"ior\";\n+\t\t\t\t  break;\n+\t\t\t\tcase OMP_REDUCTION_IEOR:\n+\t\t\t\t  udr_name = \"ieor\";\n+\t\t\t\t  break;\n+\t\t\t\tdefault:\n+\t\t\t\t  gcc_unreachable ();\n+\t\t\t\t}\n+\t\t\t    gfc_error (\"!$OMP DECLARE REDUCTION %s not found \"\n+\t\t\t\t       \"for type %s at %L\", udr_name,\n+\t\t\t\t       gfc_typename (&n->sym->ts), where);\n+\t\t\t  }\n+\t\t\telse\n+\t\t\t  n->rop = OMP_REDUCTION_USER;\n+\t\t      }\n \t\t    break;\n \t\t  case OMP_LIST_LINEAR:\n \t\t    if (n->sym->ts.type != BT_INTEGER)\n@@ -2312,3 +2815,180 @@ gfc_resolve_omp_declare_simd (gfc_namespace *ns)\n \tresolve_omp_clauses (NULL, &ods->where, ods->clauses, ns);\n     }\n }\n+\n+struct omp_udr_callback_data\n+{\n+  gfc_omp_udr *omp_udr;\n+  bool is_initializer;\n+};\n+\n+static int\n+omp_udr_callback (gfc_expr **e, int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t\t  void *data)\n+{\n+  struct omp_udr_callback_data *cd = (struct omp_udr_callback_data *) data;\n+  if ((*e)->expr_type == EXPR_VARIABLE)\n+    {\n+      if (cd->is_initializer)\n+\t{\n+\t  if ((*e)->symtree->n.sym != cd->omp_udr->omp_priv\n+\t      && (*e)->symtree->n.sym != cd->omp_udr->omp_orig)\n+\t    gfc_error (\"Variable other than OMP_PRIV or OMP_ORIG used in \"\n+\t\t       \"INITIALIZER clause of !$OMP DECLARE REDUCTION at %L\",\n+\t\t       &(*e)->where);\n+\t}\n+      else\n+\t{\n+\t  if ((*e)->symtree->n.sym != cd->omp_udr->omp_out\n+\t      && (*e)->symtree->n.sym != cd->omp_udr->omp_in)\n+\t    gfc_error (\"Variable other than OMP_OUT or OMP_IN used in \"\n+\t\t       \"combiner of !$OMP DECLARE REDUCTION at %L\",\n+\t\t       &(*e)->where);\n+\t}\n+    }\n+  else if ((*e)->expr_type == EXPR_FUNCTION\n+\t   && (*e)->value.function.isym == NULL)\n+    {\n+      gfc_symbol *sym = (*e)->symtree->n.sym;\n+      if (!sym->attr.intrinsic\n+\t  && sym->attr.if_source == IFSRC_UNKNOWN)\n+\tgfc_error (\"Implicitly declared function %s used in \"\n+\t\t   \"!$OMP DECLARE REDUCTION at %L \", sym->name, &(*e)->where);\n+    }\n+  return 0;\n+}\n+\n+/* Resolve !$omp declare reduction constructs.  */\n+\n+static void\n+gfc_resolve_omp_udr (gfc_omp_udr *omp_udr)\n+{\n+  gfc_actual_arglist *a;\n+  const char *predef_name = NULL;\n+\n+  gfc_resolve (omp_udr->combiner_ns);\n+  if (omp_udr->initializer_ns)\n+    gfc_resolve (omp_udr->initializer_ns);\n+  switch (omp_udr->rop)\n+    {\n+    case OMP_REDUCTION_PLUS:\n+    case OMP_REDUCTION_TIMES:\n+    case OMP_REDUCTION_MINUS:\n+    case OMP_REDUCTION_AND:\n+    case OMP_REDUCTION_OR:\n+    case OMP_REDUCTION_EQV:\n+    case OMP_REDUCTION_NEQV:\n+    case OMP_REDUCTION_MAX:\n+    case OMP_REDUCTION_USER:\n+      break;\n+    default:\n+      gfc_error (\"Invalid operator for !$OMP DECLARE REDUCTION %s at %L\",\n+\t\t omp_udr->name, &omp_udr->where);\n+      return;\n+    }\n+\n+  if (gfc_omp_udr_predef (omp_udr->rop, omp_udr->name,\n+\t\t\t  &omp_udr->ts, &predef_name))\n+    {\n+      if (predef_name)\n+\tgfc_error_now (\"Redefinition of predefined %s \"\n+\t\t       \"!$OMP DECLARE REDUCTION at %L\",\n+\t\t       predef_name, &omp_udr->where);\n+      else\n+\tgfc_error_now (\"Redefinition of predefined \"\n+\t\t       \"!$OMP DECLARE REDUCTION at %L\", &omp_udr->where);\n+      return;\n+    }\n+\n+  if (omp_udr->ts.type == BT_CHARACTER\n+      && omp_udr->ts.u.cl->length\n+      && omp_udr->ts.u.cl->length->expr_type != EXPR_CONSTANT)\n+    {\n+      gfc_error (\"CHARACTER length in !$OMP DECLARE REDUCTION %s not \"\n+\t\t \"constant at %L\", omp_udr->name, &omp_udr->where);\n+      return;\n+    }\n+\n+  struct omp_udr_callback_data cd;\n+  cd.omp_udr = omp_udr;\n+  cd.is_initializer = false;\n+  gfc_code_walker (&omp_udr->combiner_ns->code, gfc_dummy_code_callback,\n+\t\t   omp_udr_callback, &cd);\n+  if (omp_udr->combiner_ns->code->op == EXEC_CALL)\n+    {\n+      for (a = omp_udr->combiner_ns->code->ext.actual; a; a = a->next)\n+\tif (a->expr == NULL)\n+\t  break;\n+      if (a)\n+\tgfc_error (\"Subroutine call with alternate returns in combiner \"\n+\t\t   \"of !$OMP DECLARE REDUCTION at %L\",\n+\t\t   &omp_udr->combiner_ns->code->loc);\n+      if (omp_udr->combiner_ns->code->resolved_isym == NULL)\n+\t{\n+\t  gfc_symbol *sym = omp_udr->combiner_ns->code->resolved_sym;\n+\t  if (sym\n+\t      && !sym->attr.intrinsic\n+\t      && sym->attr.if_source == IFSRC_UNKNOWN)\n+\t    gfc_error (\"Implicitly declared subroutine %s used in \"\n+\t\t       \"!$OMP DECLARE REDUCTION at %L \", sym->name,\n+\t\t       &omp_udr->combiner_ns->code->loc);\n+\t}\n+    }\n+  if (omp_udr->initializer_ns)\n+    {\n+      cd.is_initializer = true;\n+      gfc_code_walker (&omp_udr->initializer_ns->code, gfc_dummy_code_callback,\n+\t\t       omp_udr_callback, &cd);\n+      if (omp_udr->initializer_ns->code->op == EXEC_CALL)\n+\t{\n+\t  for (a = omp_udr->initializer_ns->code->ext.actual; a; a = a->next)\n+\t    if (a->expr == NULL)\n+\t      break;\n+\t  if (a)\n+\t    gfc_error (\"Subroutine call with alternate returns in \"\n+\t\t       \"INITIALIZER clause of !$OMP DECLARE REDUCTION \"\n+\t\t       \"at %L\", &omp_udr->initializer_ns->code->loc);\n+\t  for (a = omp_udr->initializer_ns->code->ext.actual; a; a = a->next)\n+\t    if (a->expr\n+\t\t&& a->expr->expr_type == EXPR_VARIABLE\n+\t\t&& a->expr->symtree->n.sym == omp_udr->omp_priv\n+\t\t&& a->expr->ref == NULL)\n+\t      break;\n+\t  if (a == NULL)\n+\t    gfc_error (\"One of actual subroutine arguments in INITIALIZER \"\n+\t\t       \"clause of !$OMP DECLARE REDUCTION must be OMP_PRIV \"\n+\t\t       \"at %L\", &omp_udr->initializer_ns->code->loc);\n+\t  if (omp_udr->initializer_ns->code->resolved_isym == NULL)\n+\t    {\n+\t      gfc_symbol *sym = omp_udr->initializer_ns->code->resolved_sym;\n+\t      if (sym\n+\t\t  && !sym->attr.intrinsic\n+\t\t  && sym->attr.if_source == IFSRC_UNKNOWN)\n+\t\tgfc_error (\"Implicitly declared subroutine %s used in \"\n+\t\t\t   \"!$OMP DECLARE REDUCTION at %L \", sym->name,\n+\t\t\t   &omp_udr->initializer_ns->code->loc);\n+\t    }\n+\t}\n+    }\n+  else if (omp_udr->ts.type == BT_DERIVED\n+\t   && !gfc_has_default_initializer (omp_udr->ts.u.derived))\n+    {\n+      gfc_error (\"Missing INITIALIZER clause for !$OMP DECLARE REDUCTION \"\n+\t\t \"of derived type without default initializer at %L\",\n+\t\t &omp_udr->where);\n+      return;\n+    }\n+}\n+\n+void\n+gfc_resolve_omp_udrs (gfc_symtree *st)\n+{\n+  gfc_omp_udr *omp_udr;\n+\n+  if (st == NULL)\n+    return;\n+  gfc_resolve_omp_udrs (st->left);\n+  gfc_resolve_omp_udrs (st->right);\n+  for (omp_udr = st->n.omp_udr; omp_udr; omp_udr = omp_udr->next)\n+    gfc_resolve_omp_udr (omp_udr);\n+}"}, {"sha": "b7c42731750478761f4fb8eac90aced512bb0d3d", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -575,6 +575,8 @@ decode_omp_directive (void)\n       match (\"critical\", gfc_match_omp_critical, ST_OMP_CRITICAL);\n       break;\n     case 'd':\n+      match (\"declare reduction\", gfc_match_omp_declare_reduction,\n+\t     ST_OMP_DECLARE_REDUCTION);\n       match (\"declare simd\", gfc_match_omp_declare_simd,\n \t     ST_OMP_DECLARE_SIMD);\n       match (\"do simd\", gfc_match_omp_do_simd, ST_OMP_DO_SIMD);\n@@ -1050,7 +1052,7 @@ next_statement (void)\n #define case_decl case ST_ATTR_DECL: case ST_COMMON: case ST_DATA_DECL: \\\n   case ST_EQUIVALENCE: case ST_NAMELIST: case ST_STATEMENT_FUNCTION: \\\n   case ST_TYPE: case ST_INTERFACE: case ST_OMP_THREADPRIVATE: \\\n-  case ST_PROCEDURE: case ST_OMP_DECLARE_SIMD\n+  case ST_PROCEDURE: case ST_OMP_DECLARE_SIMD: case ST_OMP_DECLARE_REDUCTION\n \n /* Block end statements.  Errors associated with interchanging these\n    are detected in gfc_match_end().  */\n@@ -1550,6 +1552,9 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_OMP_CRITICAL:\n       p = \"!$OMP CRITICAL\";\n       break;\n+    case ST_OMP_DECLARE_REDUCTION:\n+      p = \"!$OMP DECLARE REDUCTION\";\n+      break;\n     case ST_OMP_DECLARE_SIMD:\n       p = \"!$OMP DECLARE SIMD\";\n       break;"}, {"sha": "0e4c1812372c28419fe10b7b581c5f08b57d9013", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -10866,7 +10866,10 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n     }\n \n   /* Constraints on deferred type parameter.  */\n-  if (sym->ts.deferred && !(sym->attr.pointer || sym->attr.allocatable))\n+  if (sym->ts.deferred\n+      && !(sym->attr.pointer\n+\t   || sym->attr.allocatable\n+\t   || sym->attr.omp_udr_artificial_var))\n     {\n       gfc_error (\"Entity '%s' at %L has a deferred type parameter and \"\n \t\t \"requires either the pointer or allocatable attribute\",\n@@ -10881,7 +10884,8 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n \t dummy arguments.  */\n       e = sym->ts.u.cl->length;\n       if (e == NULL && !sym->attr.dummy && !sym->attr.result\n-\t  && !sym->ts.deferred && !sym->attr.select_type_temporary)\n+\t  && !sym->ts.deferred && !sym->attr.select_type_temporary\n+\t  && !sym->attr.omp_udr_artificial_var)\n \t{\n \t  gfc_error (\"Entity with assumed character length at %L must be a \"\n \t\t     \"dummy argument or a PARAMETER\", &sym->declared_at);\n@@ -14696,6 +14700,8 @@ resolve_types (gfc_namespace *ns)\n \n   gfc_resolve_omp_declare_simd (ns);\n \n+  gfc_resolve_omp_udrs (ns->omp_udr_root);\n+\n   gfc_current_ns = old_ns;\n }\n "}, {"sha": "a0995b51ccebaac311c1a08b1a98ce2c92fe08fe", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -2450,17 +2450,20 @@ gfc_get_uop (const char *name)\n {\n   gfc_user_op *uop;\n   gfc_symtree *st;\n+  gfc_namespace *ns = gfc_current_ns;\n \n-  st = gfc_find_symtree (gfc_current_ns->uop_root, name);\n+  if (ns->omp_udr_ns)\n+    ns = ns->parent;\n+  st = gfc_find_symtree (ns->uop_root, name);\n   if (st != NULL)\n     return st->n.uop;\n \n-  st = gfc_new_symtree (&gfc_current_ns->uop_root, name);\n+  st = gfc_new_symtree (&ns->uop_root, name);\n \n   uop = st->n.uop = XCNEW (gfc_user_op);\n   uop->name = gfc_get_string (name);\n   uop->access = ACCESS_UNKNOWN;\n-  uop->ns = gfc_current_ns;\n+  uop->ns = ns;\n \n   return uop;\n }\n@@ -2771,6 +2774,12 @@ gfc_get_sym_tree (const char *name, gfc_namespace *ns, gfc_symtree **result,\n   /* Try to find the symbol in ns.  */\n   st = gfc_find_symtree (ns->sym_root, name);\n \n+  if (st == NULL && ns->omp_udr_ns)\n+    {\n+      ns = ns->parent;\n+      st = gfc_find_symtree (ns->sym_root, name);\n+    }\n+\n   if (st == NULL)\n     {\n       /* If not there, create a new symbol.  */\n@@ -3269,6 +3278,23 @@ free_common_tree (gfc_symtree * common_tree)\n }  \n \n \n+/* Recursive function that deletes an entire tree and all the common\n+   head structures it points to.  */\n+\n+static void\n+free_omp_udr_tree (gfc_symtree * omp_udr_tree)\n+{\n+  if (omp_udr_tree == NULL)\n+    return;\n+\n+  free_omp_udr_tree (omp_udr_tree->left);\n+  free_omp_udr_tree (omp_udr_tree->right);\n+\n+  gfc_free_omp_udr (omp_udr_tree->n.omp_udr);\n+  free (omp_udr_tree);\n+}\n+\n+\n /* Recursive function that deletes an entire tree and all the user\n    operator nodes that it contains.  */\n \n@@ -3465,6 +3491,7 @@ gfc_free_namespace (gfc_namespace *ns)\n   free_sym_tree (ns->sym_root);\n   free_uop_tree (ns->uop_root);\n   free_common_tree (ns->common_root);\n+  free_omp_udr_tree (ns->omp_udr_root);\n   free_tb_tree (ns->tb_sym_root);\n   free_tb_tree (ns->tb_uop_root);\n   gfc_free_finalizer_list (ns->finalizers);"}, {"sha": "3851a4e522d8a2fabeec43a02b504c646ffbdab5", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 319, "deletions": 99, "changes": 418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -525,12 +525,104 @@ gfc_trans_omp_variable_list (enum omp_clause_code code,\n   return list;\n }\n \n+struct omp_udr_find_orig_data\n+{\n+  gfc_omp_udr *omp_udr;\n+  bool omp_orig_seen;\n+};\n+\n+static int\n+omp_udr_find_orig (gfc_expr **e, int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t\t   void *data)\n+{\n+  struct omp_udr_find_orig_data *cd = (struct omp_udr_find_orig_data *) data;\n+  if ((*e)->expr_type == EXPR_VARIABLE\n+      && (*e)->symtree->n.sym == cd->omp_udr->omp_orig)\n+    cd->omp_orig_seen = true;\n+\n+  return 0;\n+}\n+\n+static tree\n+gfc_trans_omp_udr_expr (gfc_omp_namelist *n, bool is_initializer,\n+\t\t\tgfc_expr *syme, gfc_expr *outere)\n+{\n+  gfc_se symse, outerse;\n+  gfc_ss *symss, *outerss;\n+  gfc_loopinfo loop;\n+  stmtblock_t block, body;\n+  tree tem;\n+  int i;\n+  gfc_namespace *ns = (is_initializer\n+\t\t       ? n->udr->initializer_ns : n->udr->combiner_ns);\n+\n+  syme = gfc_copy_expr (syme);\n+  outere = gfc_copy_expr (outere);\n+  gfc_init_se (&symse, NULL);\n+  gfc_init_se (&outerse, NULL);\n+  gfc_start_block (&block);\n+  gfc_init_loopinfo (&loop);\n+  symss = gfc_walk_expr (syme);\n+  outerss = gfc_walk_expr (outere);\n+  gfc_add_ss_to_loop (&loop, symss);\n+  gfc_add_ss_to_loop (&loop, outerss);\n+  gfc_conv_ss_startstride (&loop);\n+  /* Enable loop reversal.  */\n+  for (i = 0; i < GFC_MAX_DIMENSIONS; i++)\n+    loop.reverse[i] = GFC_ENABLE_REVERSE;\n+  gfc_conv_loop_setup (&loop, &ns->code->loc);\n+  gfc_copy_loopinfo_to_se (&symse, &loop);\n+  gfc_copy_loopinfo_to_se (&outerse, &loop);\n+  symse.ss = symss;\n+  outerse.ss = outerss;\n+  gfc_mark_ss_chain_used (symss, 1);\n+  gfc_mark_ss_chain_used (outerss, 1);\n+  gfc_start_scalarized_body (&loop, &body);\n+  gfc_conv_expr (&symse, syme);\n+  gfc_conv_expr (&outerse, outere);\n+\n+  if (is_initializer)\n+    {\n+      n->udr->omp_priv->backend_decl = symse.expr;\n+      n->udr->omp_orig->backend_decl = outerse.expr;\n+    }\n+  else\n+    {\n+      n->udr->omp_out->backend_decl = outerse.expr;\n+      n->udr->omp_in->backend_decl = symse.expr;\n+    }\n+\n+  if (ns->code->op == EXEC_ASSIGN)\n+    tem = gfc_trans_assignment (ns->code->expr1, ns->code->expr2,\n+\t\t\t\tfalse, false);\n+  else\n+    tem = gfc_trans_call (ns->code, false, NULL_TREE, NULL_TREE, false);\n+  gfc_add_expr_to_block (&body, tem);\n+\n+  gcc_assert (symse.ss == gfc_ss_terminator\n+\t      && outerse.ss == gfc_ss_terminator);\n+  /* Generate the copying loops.  */\n+  gfc_trans_scalarizing_loops (&loop, &body);\n+\n+  /* Wrap the whole thing up.  */\n+  gfc_add_block_to_block (&block, &loop.pre);\n+  gfc_add_block_to_block (&block, &loop.post);\n+\n+  gfc_cleanup_loop (&loop);\n+  gfc_free_expr (syme);\n+  gfc_free_expr (outere);\n+\n+  return gfc_finish_block (&block);\n+}\n+\n static void\n-gfc_trans_omp_array_reduction (tree c, gfc_symbol *sym, locus where)\n+gfc_trans_omp_array_reduction_or_udr (tree c, gfc_omp_namelist *n, locus where)\n {\n+  gfc_symbol *sym = n->sym;\n   gfc_symtree *root1 = NULL, *root2 = NULL, *root3 = NULL, *root4 = NULL;\n   gfc_symtree *symtree1, *symtree2, *symtree3, *symtree4 = NULL;\n   gfc_symbol init_val_sym, outer_sym, intrinsic_sym;\n+  gfc_symbol omp_var_copy[4];\n   gfc_expr *e1, *e2, *e3, *e4;\n   gfc_ref *ref;\n   tree decl, backend_decl, stmt, type, outer_decl;\n@@ -559,12 +651,29 @@ gfc_trans_omp_array_reduction (tree c, gfc_symbol *sym, locus where)\n   init_val_sym.attr.referenced = 1;\n   init_val_sym.declared_at = where;\n   init_val_sym.attr.flavor = FL_VARIABLE;\n-  backend_decl = omp_reduction_init (c, gfc_sym_type (&init_val_sym));\n+  if (OMP_CLAUSE_REDUCTION_CODE (c) != ERROR_MARK)\n+    backend_decl = omp_reduction_init (c, gfc_sym_type (&init_val_sym));\n+  else if (n->udr->initializer_ns)\n+    backend_decl = NULL;\n+  else\n+    switch (sym->ts.type)\n+      {\n+      case BT_LOGICAL:\n+      case BT_INTEGER:\n+      case BT_REAL:\n+      case BT_COMPLEX:\n+\tbackend_decl = build_zero_cst (gfc_sym_type (&init_val_sym));\n+\tbreak;\n+      default:\n+\tbackend_decl = NULL_TREE;\n+\tbreak;\n+      }\n   init_val_sym.backend_decl = backend_decl;\n \n   /* Create a fake symbol for the outer array reference.  */\n   outer_sym = *sym;\n-  outer_sym.as = gfc_copy_array_spec (sym->as);\n+  if (sym->as)\n+    outer_sym.as = gfc_copy_array_spec (sym->as);\n   outer_sym.attr.dummy = 0;\n   outer_sym.attr.result = 0;\n   outer_sym.attr.flavor = FL_VARIABLE;\n@@ -585,35 +694,102 @@ gfc_trans_omp_array_reduction (tree c, gfc_symbol *sym, locus where)\n   symtree3->n.sym = &outer_sym;\n   gcc_assert (symtree3 == root3);\n \n+  memset (omp_var_copy, 0, sizeof omp_var_copy);\n+  if (n->udr)\n+    {\n+      omp_var_copy[0] = *n->udr->omp_out;\n+      omp_var_copy[1] = *n->udr->omp_in;\n+      if (sym->attr.dimension)\n+\t{\n+\t  n->udr->omp_out->ts = sym->ts;\n+\t  n->udr->omp_in->ts = sym->ts;\n+\t}\n+      else\n+\t{\n+\t  *n->udr->omp_out = outer_sym;\n+\t  *n->udr->omp_in = *sym;\n+\t}\n+      if (n->udr->initializer_ns)\n+\t{\n+\t  omp_var_copy[2] = *n->udr->omp_priv;\n+\t  omp_var_copy[3] = *n->udr->omp_orig;\n+\t  if (sym->attr.dimension)\n+\t    {\n+\t      n->udr->omp_priv->ts = sym->ts;\n+\t      n->udr->omp_orig->ts = sym->ts;\n+\t    }\n+\t  else\n+\t    {\n+\t      *n->udr->omp_priv = *sym;\n+\t      *n->udr->omp_orig = outer_sym;\n+\t    }\n+\t}\n+    }\n+\n   /* Create expressions.  */\n   e1 = gfc_get_expr ();\n   e1->expr_type = EXPR_VARIABLE;\n   e1->where = where;\n   e1->symtree = symtree1;\n   e1->ts = sym->ts;\n-  e1->ref = ref = gfc_get_ref ();\n-  ref->type = REF_ARRAY;\n-  ref->u.ar.where = where;\n-  ref->u.ar.as = sym->as;\n-  ref->u.ar.type = AR_FULL;\n-  ref->u.ar.dimen = 0;\n+  if (sym->attr.dimension)\n+    {\n+      e1->ref = ref = gfc_get_ref ();\n+      ref->type = REF_ARRAY;\n+      ref->u.ar.where = where;\n+      ref->u.ar.as = sym->as;\n+      ref->u.ar.type = AR_FULL;\n+      ref->u.ar.dimen = 0;\n+    }\n   t = gfc_resolve_expr (e1);\n   gcc_assert (t);\n \n-  e2 = gfc_get_expr ();\n-  e2->expr_type = EXPR_VARIABLE;\n-  e2->where = where;\n-  e2->symtree = symtree2;\n-  e2->ts = sym->ts;\n-  t = gfc_resolve_expr (e2);\n-  gcc_assert (t);\n+  e2 = NULL;\n+  if (backend_decl != NULL_TREE)\n+    {\n+      e2 = gfc_get_expr ();\n+      e2->expr_type = EXPR_VARIABLE;\n+      e2->where = where;\n+      e2->symtree = symtree2;\n+      e2->ts = sym->ts;\n+      t = gfc_resolve_expr (e2);\n+      gcc_assert (t);\n+    }\n+  else if (n->udr->initializer_ns == NULL)\n+    {\n+      gcc_assert (sym->ts.type == BT_DERIVED);\n+      e2 = gfc_default_initializer (&sym->ts);\n+      gcc_assert (e2);\n+      t = gfc_resolve_expr (e2);\n+      gcc_assert (t);\n+    }\n+  else if (n->udr->initializer_ns->code->op == EXEC_ASSIGN)\n+    {\n+      if (!sym->attr.dimension)\n+\t{\n+\t  e2 = gfc_copy_expr (n->udr->initializer_ns->code->expr2);\n+\t  t = gfc_resolve_expr (e2);\n+\t  gcc_assert (t);\n+\t}\n+    }\n+  if (n->udr && n->udr->initializer_ns)\n+    {\n+      struct omp_udr_find_orig_data cd;\n+      cd.omp_udr = n->udr;\n+      cd.omp_orig_seen = false;\n+      gfc_code_walker (&n->udr->initializer_ns->code,\n+\t\t       gfc_dummy_code_callback, omp_udr_find_orig, &cd);\n+      if (cd.omp_orig_seen)\n+\tOMP_CLAUSE_REDUCTION_OMP_ORIG_REF (c) = 1;\n+    }\n \n   e3 = gfc_copy_expr (e1);\n   e3->symtree = symtree3;\n   t = gfc_resolve_expr (e3);\n   gcc_assert (t);\n \n   iname = NULL;\n+  e4 = NULL;\n   switch (OMP_CLAUSE_REDUCTION_CODE (c))\n     {\n     case PLUS_EXPR:\n@@ -650,6 +826,21 @@ gfc_trans_omp_array_reduction (tree c, gfc_symbol *sym, locus where)\n     case BIT_XOR_EXPR:\n       iname = \"ieor\";\n       break;\n+    case ERROR_MARK:\n+      if (n->udr->combiner_ns->code->op == EXEC_ASSIGN)\n+\t{\n+\t  if (!sym->attr.dimension)\n+\t    {\n+\t      gfc_free_expr (e3);\n+\t      e3 = gfc_copy_expr (n->udr->combiner_ns->code->expr1);\n+\t      e4 = gfc_copy_expr (n->udr->combiner_ns->code->expr2);\n+\t      t = gfc_resolve_expr (e3);\n+\t      gcc_assert (t);\n+\t      t = gfc_resolve_expr (e4);\n+\t      gcc_assert (t);\n+\t    }\n+\t}\n+      break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -679,15 +870,19 @@ gfc_trans_omp_array_reduction (tree c, gfc_symbol *sym, locus where)\n       e4->value.function.actual->next = gfc_get_actual_arglist ();\n       e4->value.function.actual->next->expr = e1;\n     }\n-  /* e1 and e3 have been stored as arguments of e4, avoid sharing.  */\n-  e1 = gfc_copy_expr (e1);\n-  e3 = gfc_copy_expr (e3);\n-  t = gfc_resolve_expr (e4);\n-  gcc_assert (t);\n+  if (OMP_CLAUSE_REDUCTION_CODE (c) != ERROR_MARK)\n+    {\n+      /* e1 and e3 have been stored as arguments of e4, avoid sharing.  */\n+      e1 = gfc_copy_expr (e1);\n+      e3 = gfc_copy_expr (e3);\n+      t = gfc_resolve_expr (e4);\n+      gcc_assert (t);\n+    }\n \n   /* Create the init statement list.  */\n   pushlevel ();\n-  if (GFC_DESCRIPTOR_TYPE_P (type)\n+  if (sym->attr.dimension\n+      && GFC_DESCRIPTOR_TYPE_P (type)\n       && GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ALLOCATABLE)\n     {\n       /* If decl is an allocatable array, it needs to be allocated\n@@ -719,12 +914,20 @@ gfc_trans_omp_array_reduction (tree c, gfc_symbol *sym, locus where)\n       gfc_allocate_using_malloc (&block, ptr, size, NULL_TREE);\n       gfc_conv_descriptor_data_set (&block, decl, ptr);\n \n-      gfc_add_expr_to_block (&block, gfc_trans_assignment (e1, e2, false,\n-\t\t\t     false));\n+      if (e2)\n+\tstmt = gfc_trans_assignment (e1, e2, false, false);\n+      else\n+\tstmt = gfc_trans_omp_udr_expr (n, true, e1, e3);\n+      gfc_add_expr_to_block (&block, stmt);\n       stmt = gfc_finish_block (&block);\n     }\n-  else\n+  else if (e2)\n     stmt = gfc_trans_assignment (e1, e2, false, false);\n+  else if (sym->attr.dimension)\n+    stmt = gfc_trans_omp_udr_expr (n, true, e1, e3);\n+  else\n+    stmt = gfc_trans_call (n->udr->initializer_ns->code, false,\n+\t\t\t   NULL_TREE, NULL_TREE, false);\n   if (TREE_CODE (stmt) != BIND_EXPR)\n     stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0));\n   else\n@@ -733,22 +936,31 @@ gfc_trans_omp_array_reduction (tree c, gfc_symbol *sym, locus where)\n \n   /* Create the merge statement list.  */\n   pushlevel ();\n-  if (GFC_DESCRIPTOR_TYPE_P (type)\n+  if (sym->attr.dimension\n+      && GFC_DESCRIPTOR_TYPE_P (type)\n       && GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ALLOCATABLE)\n     {\n       /* If decl is an allocatable array, it needs to be deallocated\n \t afterwards.  */\n       stmtblock_t block;\n \n       gfc_start_block (&block);\n-      gfc_add_expr_to_block (&block, gfc_trans_assignment (e3, e4, false,\n-\t\t\t     true));\n+      if (e4)\n+\tstmt = gfc_trans_assignment (e3, e4, false, true);\n+      else\n+\tstmt = gfc_trans_omp_udr_expr (n, false, e1, e3);\n+      gfc_add_expr_to_block (&block, stmt);\n       gfc_add_expr_to_block (&block, gfc_trans_dealloc_allocated (decl, false,\n \t\t\t\t\t\t\t\t  NULL));\n       stmt = gfc_finish_block (&block);\n     }\n-  else\n+  else if (e4)\n     stmt = gfc_trans_assignment (e3, e4, false, true);\n+  else if (sym->attr.dimension)\n+    stmt = gfc_trans_omp_udr_expr (n, false, e1, e3);\n+  else\n+    stmt = gfc_trans_call (n->udr->combiner_ns->code, false,\n+\t\t\t   NULL_TREE, NULL_TREE, false);\n   if (TREE_CODE (stmt) != BIND_EXPR)\n     stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0));\n   else\n@@ -761,19 +973,33 @@ gfc_trans_omp_array_reduction (tree c, gfc_symbol *sym, locus where)\n   gfc_current_locus = old_loc;\n \n   gfc_free_expr (e1);\n-  gfc_free_expr (e2);\n+  if (e2)\n+    gfc_free_expr (e2);\n   gfc_free_expr (e3);\n-  gfc_free_expr (e4);\n+  if (e4)\n+    gfc_free_expr (e4);\n   free (symtree1);\n   free (symtree2);\n   free (symtree3);\n   free (symtree4);\n-  gfc_free_array_spec (outer_sym.as);\n+  if (outer_sym.as)\n+    gfc_free_array_spec (outer_sym.as);\n+\n+  if (n->udr)\n+    {\n+      *n->udr->omp_out = omp_var_copy[0];\n+      *n->udr->omp_in = omp_var_copy[1];\n+      if (n->udr->initializer_ns)\n+\t{\n+\t  *n->udr->omp_priv = omp_var_copy[2];\n+\t  *n->udr->omp_orig = omp_var_copy[3];\n+\t}\n+    }\n }\n \n static tree\n gfc_trans_omp_reduction_list (gfc_omp_namelist *namelist, tree list,\n-\t\t\t      enum tree_code reduction_code, locus where)\n+\t\t\t      locus where)\n {\n   for (; namelist != NULL; namelist = namelist->next)\n     if (namelist->sym->attr.referenced)\n@@ -784,9 +1010,53 @@ gfc_trans_omp_reduction_list (gfc_omp_namelist *namelist, tree list,\n \t    tree node = build_omp_clause (where.lb->location,\n \t\t\t\t\t  OMP_CLAUSE_REDUCTION);\n \t    OMP_CLAUSE_DECL (node) = t;\n-\t    OMP_CLAUSE_REDUCTION_CODE (node) = reduction_code;\n-\t    if (namelist->sym->attr.dimension)\n-\t      gfc_trans_omp_array_reduction (node, namelist->sym, where);\n+\t    switch (namelist->rop)\n+\t      {\n+\t      case OMP_REDUCTION_PLUS:\n+\t\tOMP_CLAUSE_REDUCTION_CODE (node) = PLUS_EXPR;\n+\t\tbreak;\n+\t      case OMP_REDUCTION_MINUS:\n+\t\tOMP_CLAUSE_REDUCTION_CODE (node) = MINUS_EXPR;\n+\t\tbreak;\n+\t      case OMP_REDUCTION_TIMES:\n+\t\tOMP_CLAUSE_REDUCTION_CODE (node) = MULT_EXPR;\n+\t\tbreak;\n+\t      case OMP_REDUCTION_AND:\n+\t\tOMP_CLAUSE_REDUCTION_CODE (node) = TRUTH_ANDIF_EXPR;\n+\t\tbreak;\n+\t      case OMP_REDUCTION_OR:\n+\t\tOMP_CLAUSE_REDUCTION_CODE (node) = TRUTH_ORIF_EXPR;\n+\t\tbreak;\n+\t      case OMP_REDUCTION_EQV:\n+\t\tOMP_CLAUSE_REDUCTION_CODE (node) = EQ_EXPR;\n+\t\tbreak;\n+\t      case OMP_REDUCTION_NEQV:\n+\t\tOMP_CLAUSE_REDUCTION_CODE (node) = NE_EXPR;\n+\t\tbreak;\n+\t      case OMP_REDUCTION_MAX:\n+\t\tOMP_CLAUSE_REDUCTION_CODE (node) = MAX_EXPR;\n+\t\tbreak;\n+\t      case OMP_REDUCTION_MIN:\n+\t\tOMP_CLAUSE_REDUCTION_CODE (node) = MIN_EXPR;\n+\t\tbreak;\n+ \t      case OMP_REDUCTION_IAND:\n+\t\tOMP_CLAUSE_REDUCTION_CODE (node) = BIT_AND_EXPR;\n+\t\tbreak;\n+ \t      case OMP_REDUCTION_IOR:\n+\t\tOMP_CLAUSE_REDUCTION_CODE (node) = BIT_IOR_EXPR;\n+\t\tbreak;\n+ \t      case OMP_REDUCTION_IEOR:\n+\t\tOMP_CLAUSE_REDUCTION_CODE (node) = BIT_XOR_EXPR;\n+\t\tbreak;\n+\t      case OMP_REDUCTION_USER:\n+\t\tOMP_CLAUSE_REDUCTION_CODE (node) = ERROR_MARK;\n+\t\tbreak;\n+\t      default:\n+\t\tgcc_unreachable ();\n+\t      }\n+\t    if (namelist->sym->attr.dimension\n+\t\t|| namelist->rop == OMP_REDUCTION_USER)\n+\t      gfc_trans_omp_array_reduction_or_udr (node, namelist, where);\n \t    list = gfc_trans_add_clause (node, list);\n \t  }\n       }\n@@ -811,58 +1081,11 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \n       if (n == NULL)\n \tcontinue;\n-      if (list >= OMP_LIST_REDUCTION_FIRST\n-\t  && list <= OMP_LIST_REDUCTION_LAST)\n-\t{\n-\t  enum tree_code reduction_code;\n-\t  switch (list)\n-\t    {\n-\t    case OMP_LIST_PLUS:\n-\t      reduction_code = PLUS_EXPR;\n-\t      break;\n-\t    case OMP_LIST_MULT:\n-\t      reduction_code = MULT_EXPR;\n-\t      break;\n-\t    case OMP_LIST_SUB:\n-\t      reduction_code = MINUS_EXPR;\n-\t      break;\n-\t    case OMP_LIST_AND:\n-\t      reduction_code = TRUTH_ANDIF_EXPR;\n-\t      break;\n-\t    case OMP_LIST_OR:\n-\t      reduction_code = TRUTH_ORIF_EXPR;\n-\t      break;\n-\t    case OMP_LIST_EQV:\n-\t      reduction_code = EQ_EXPR;\n-\t      break;\n-\t    case OMP_LIST_NEQV:\n-\t      reduction_code = NE_EXPR;\n-\t      break;\n-\t    case OMP_LIST_MAX:\n-\t      reduction_code = MAX_EXPR;\n-\t      break;\n-\t    case OMP_LIST_MIN:\n-\t      reduction_code = MIN_EXPR;\n-\t      break;\n-\t    case OMP_LIST_IAND:\n-\t      reduction_code = BIT_AND_EXPR;\n-\t      break;\n-\t    case OMP_LIST_IOR:\n-\t      reduction_code = BIT_IOR_EXPR;\n-\t      break;\n-\t    case OMP_LIST_IEOR:\n-\t      reduction_code = BIT_XOR_EXPR;\n-\t      break;\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\t  omp_clauses\n-\t    = gfc_trans_omp_reduction_list (n, omp_clauses, reduction_code,\n-\t\t\t\t\t    where);\n-\t  continue;\n-\t}\n       switch (list)\n \t{\n+\tcase OMP_LIST_REDUCTION:\n+\t  omp_clauses = gfc_trans_omp_reduction_list (n, omp_clauses, where);\n+\t  break;\n \tcase OMP_LIST_PRIVATE:\n \t  clause_code = OMP_CLAUSE_PRIVATE;\n \t  goto add_clause;\n@@ -1923,7 +2146,7 @@ static void\n gfc_split_omp_clauses (gfc_code *code,\n \t\t       gfc_omp_clauses clausesa[GFC_OMP_SPLIT_NUM])\n {\n-  int mask = 0, innermost = 0, i;\n+  int mask = 0, innermost = 0;\n   memset (clausesa, 0, GFC_OMP_SPLIT_NUM * sizeof (gfc_omp_clauses));\n   switch (code->op)\n     {\n@@ -2021,18 +2244,15 @@ gfc_split_omp_clauses (gfc_code *code,\n       /* Reduction is allowed on simd, do, parallel and teams.\n \t Duplicate it on all of them, but omit on do if\n \t parallel is present.  */\n-      for (i = OMP_LIST_REDUCTION_FIRST; i <= OMP_LIST_REDUCTION_LAST; i++)\n-\t{\n-\t  if (mask & GFC_OMP_MASK_PARALLEL)\n-\t    clausesa[GFC_OMP_SPLIT_PARALLEL].lists[i]\n-\t      = code->ext.omp_clauses->lists[i];\n-\t  else if (mask & GFC_OMP_MASK_DO)\n-\t    clausesa[GFC_OMP_SPLIT_DO].lists[i]\n-\t      = code->ext.omp_clauses->lists[i];\n-\t  if (mask & GFC_OMP_MASK_SIMD)\n-\t    clausesa[GFC_OMP_SPLIT_SIMD].lists[i]\n-\t      = code->ext.omp_clauses->lists[i];\n-\t}\n+      if (mask & GFC_OMP_MASK_PARALLEL)\n+\tclausesa[GFC_OMP_SPLIT_PARALLEL].lists[OMP_LIST_REDUCTION]\n+\t  = code->ext.omp_clauses->lists[OMP_LIST_REDUCTION];\n+      else if (mask & GFC_OMP_MASK_DO)\n+\tclausesa[GFC_OMP_SPLIT_DO].lists[OMP_LIST_REDUCTION]\n+\t  = code->ext.omp_clauses->lists[OMP_LIST_REDUCTION];\n+      if (mask & GFC_OMP_MASK_SIMD)\n+\tclausesa[GFC_OMP_SPLIT_SIMD].lists[OMP_LIST_REDUCTION]\n+\t  = code->ext.omp_clauses->lists[OMP_LIST_REDUCTION];\n     }\n   if ((mask & (GFC_OMP_MASK_PARALLEL | GFC_OMP_MASK_DO))\n       == (GFC_OMP_MASK_PARALLEL | GFC_OMP_MASK_DO))"}, {"sha": "69264e37fc77aab3dbe3b306843858e31ad4bc03", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -1,3 +1,18 @@\n+2014-06-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gfortran.dg/gomp/allocatable_components_1.f90: Adjust for\n+\treduction clause diagnostic changes.\n+\t* gfortran.dg/gomp/appendix-a/a.31.3.f90: Likewise.\n+\t* gfortran.dg/gomp/reduction1.f90: Likewise.\n+\t* gfortran.dg/gomp/reduction3.f90: Likewise.\n+\t* gfortran.dg/gomp/udr1.f90: New test.\n+\t* gfortran.dg/gomp/udr2.f90: New test.\n+\t* gfortran.dg/gomp/udr3.f90: New test.\n+\t* gfortran.dg/gomp/udr4.f90: New test.\n+\t* gfortran.dg/gomp/udr5.f90: New test.\n+\t* gfortran.dg/gomp/udr6.f90: New test.\n+\t* gfortran.dg/gomp/udr7.f90: New test.\n+\n 2014-06-06  Christian Bruel  <christian.bruel@st.com>\n \n \tPR tree-optimization/43934"}, {"sha": "8e4e5390d11170aaf6d843531519eda1d6e609a6", "filename": "gcc/testsuite/gfortran.dg/gomp/allocatable_components_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fallocatable_components_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fallocatable_components_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fallocatable_components_1.f90?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -49,7 +49,7 @@ SUBROUTINE test_reduction\n     TYPE(t) :: a(10)\n     INTEGER :: i\n \n-    !$omp parallel do reduction(+: a)   ! { dg-error \"must be of numeric type\" }\n+    !$omp parallel do reduction(+: a)   ! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n     DO i = 1, SIZE(a)\n     END DO\n     !$omp end parallel do"}, {"sha": "598c904206e82c1129b44567e78274851846211e", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.31.3.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.31.3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.31.3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.31.3.f90?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -5,7 +5,7 @@ PROGRAM A31_3_WRONG\n         !$OMP PARALLEL DO REDUCTION(MAX: M) ! MAX is no longer the\n                                             ! intrinsic so this\n                                             ! is non-conforming\n-! { dg-error \"is not INTRINSIC procedure name\" \"\" { target *-*-* } 5 } */\n+! { dg-error \"OMP DECLARE REDUCTION max not found\" \"\" { target *-*-* } 5 } */\n         DO I = 1, 100\n         CALL SUB(M,I)\n         END DO"}, {"sha": "cdc530bf0f254d5479348f7de22ad0ee10ca0326", "filename": "gcc/testsuite/gfortran.dg/gomp/reduction1.f90", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Freduction1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Freduction1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Freduction1.f90?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -60,73 +60,73 @@ subroutine foo (ia1)\n !$omp end parallel\n !$omp parallel reduction (*:ia1)\t! { dg-error \"Assumed size\" }\n !$omp end parallel\n-!$omp parallel reduction (+:l1)\t\t! { dg-error \"must be of numeric type, got LOGICAL\" }\n+!$omp parallel reduction (+:l1)\t\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (*:la1)\t! { dg-error \"must be of numeric type, got LOGICAL\" }\n+!$omp parallel reduction (*:la1)\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (-:a1)\t\t! { dg-error \"must be of numeric type, got CHARACTER\" }\n+!$omp parallel reduction (-:a1)\t\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (+:t1)\t\t! { dg-error \"must be of numeric type, got TYPE\" }\n+!$omp parallel reduction (+:t1)\t\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (*:ta1)\t! { dg-error \"must be of numeric type, got TYPE\" }\n+!$omp parallel reduction (*:ta1)\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (.and.:i3)\t! { dg-error \"must be LOGICAL\" }\n+!$omp parallel reduction (.and.:i3)\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (.or.:ia2)\t! { dg-error \"must be LOGICAL\" }\n+!$omp parallel reduction (.or.:ia2)\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (.eqv.:r1)\t! { dg-error \"must be LOGICAL\" }\n+!$omp parallel reduction (.eqv.:r1)\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (.neqv.:ra1)\t! { dg-error \"must be LOGICAL\" }\n+!$omp parallel reduction (.neqv.:ra1)\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (.and.:d1)\t! { dg-error \"must be LOGICAL\" }\n+!$omp parallel reduction (.and.:d1)\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (.or.:da1)\t! { dg-error \"must be LOGICAL\" }\n+!$omp parallel reduction (.or.:da1)\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (.eqv.:c1)\t! { dg-error \"must be LOGICAL\" }\n+!$omp parallel reduction (.eqv.:c1)\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (.neqv.:ca1)\t! { dg-error \"must be LOGICAL\" }\n+!$omp parallel reduction (.neqv.:ca1)\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (.and.:a1)\t! { dg-error \"must be LOGICAL\" }\n+!$omp parallel reduction (.and.:a1)\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (.or.:t1)\t! { dg-error \"must be LOGICAL\" }\n+!$omp parallel reduction (.or.:t1)\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (.eqv.:ta1)\t! { dg-error \"must be LOGICAL\" }\n+!$omp parallel reduction (.eqv.:ta1)\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (min:c1)\t! { dg-error \"must be INTEGER or REAL\" }\n+!$omp parallel reduction (min:c1)\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (max:ca1)\t! { dg-error \"must be INTEGER or REAL\" }\n+!$omp parallel reduction (max:ca1)\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (max:l1)\t! { dg-error \"must be INTEGER or REAL\" }\n+!$omp parallel reduction (max:l1)\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (min:la1)\t! { dg-error \"must be INTEGER or REAL\" }\n+!$omp parallel reduction (min:la1)\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (max:a1)\t! { dg-error \"must be INTEGER or REAL\" }\n+!$omp parallel reduction (max:a1)\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (min:t1)\t! { dg-error \"must be INTEGER or REAL\" }\n+!$omp parallel reduction (min:t1)\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (max:ta1)\t! { dg-error \"must be INTEGER or REAL\" }\n+!$omp parallel reduction (max:ta1)\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (iand:r1)\t! { dg-error \"must be INTEGER\" }\n+!$omp parallel reduction (iand:r1)\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (ior:ra1)\t! { dg-error \"must be INTEGER\" }\n+!$omp parallel reduction (ior:ra1)\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (ieor:d1)\t! { dg-error \"must be INTEGER\" }\n+!$omp parallel reduction (ieor:d1)\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (ior:da1)\t! { dg-error \"must be INTEGER\" }\n+!$omp parallel reduction (ior:da1)\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (iand:c1)\t! { dg-error \"must be INTEGER\" }\n+!$omp parallel reduction (iand:c1)\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (ior:ca1)\t! { dg-error \"must be INTEGER\" }\n+!$omp parallel reduction (ior:ca1)\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (ieor:l1)\t! { dg-error \"must be INTEGER\" }\n+!$omp parallel reduction (ieor:l1)\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (iand:la1)\t! { dg-error \"must be INTEGER\" }\n+!$omp parallel reduction (iand:la1)\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (ior:a1)\t! { dg-error \"must be INTEGER\" }\n+!$omp parallel reduction (ior:a1)\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (ieor:t1)\t! { dg-error \"must be INTEGER\" }\n+!$omp parallel reduction (ieor:t1)\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n-!$omp parallel reduction (iand:ta1)\t! { dg-error \"must be INTEGER\" }\n+!$omp parallel reduction (iand:ta1)\t! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found for type\" }\n !$omp end parallel\n \n end subroutine"}, {"sha": "9cab6d57d07a91bafd2d5f292de378b5a7029d7a", "filename": "gcc/testsuite/gfortran.dg/gomp/reduction3.f90", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Freduction3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Freduction3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Freduction3.f90?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -16,7 +16,7 @@ subroutine f1\n   integer :: i, ior\n   ior = 6\n   i = 6\n-!$omp parallel reduction (ior:i) ! { dg-error \"is not INTRINSIC procedure name\" }\n+!$omp parallel reduction (ior:i) ! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found\" }\n !$omp end parallel\n end subroutine f1\n subroutine f2\n@@ -27,7 +27,7 @@ function ior (a, b)\n     end function\n   end interface\n   i = 6\n-!$omp parallel reduction (ior:i) ! { dg-error \"is not INTRINSIC procedure name\" }\n+!$omp parallel reduction (ior:i) ! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found\" }\n   i = ior (i, 3)\n !$omp end parallel\n end subroutine f2\n@@ -50,15 +50,15 @@ subroutine f5\n   use mreduction3\n   integer :: i\n   i = 6\n-!$omp parallel reduction (ior:i) ! { dg-error \"is not INTRINSIC procedure name\" }\n+!$omp parallel reduction (ior:i) ! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found\" }\n   i = ior (i, 7)\n !$omp end parallel\n end subroutine f5\n subroutine f6\n   use mreduction3\n   integer :: i\n   i = 6\n-!$omp parallel reduction (iand:i) ! { dg-error \"is not INTRINSIC procedure name\" }\n+!$omp parallel reduction (iand:i) ! { dg-error \"OMP DECLARE REDUCTION\\[^\\n\\r\\]*not found\" }\n   i = iand (i, 18)\n !$omp end parallel\n end subroutine f6"}, {"sha": "84601310c45c1b9692b13a8bc384ef996545ba16", "filename": "gcc/testsuite/gfortran.dg/gomp/udr1.f90", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr1.f90?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -0,0 +1,41 @@\n+! { dg-do compile }\n+\n+subroutine f1\n+!$omp declare reduction (.le.:integer:omp_out = omp_out + omp_in) ! { dg-error \"Invalid operator for\" }\n+end subroutine f1\n+subroutine f2\n+!$omp declare reduction (bar:real(kind=4):omp_out = omp_out + omp_in)\n+  real(kind=4) :: r\n+  integer :: i\n+  r = 0.0\n+!$omp parallel do reduction (bar:r)\n+  do i = 1, 10\n+    r = r + i\n+  end do\n+!$omp parallel do reduction (foo:r) ! { dg-error \"foo not found\" }\n+  do i = 1, 10\n+    r = r + i\n+  end do\n+!$omp parallel do reduction (.gt.:r) ! { dg-error \"cannot be used as a defined operator\" }\n+  do i = 1, 10\n+    r = r + i\n+  end do\n+end subroutine f2\n+subroutine f3\n+!$omp declare reduction (foo:blah:omp_out=omp_out + omp_in) ! { dg-error \"Unclassifiable OpenMP directive\" }\n+end subroutine f3\n+subroutine f4\n+!$omp declare reduction (foo:integer:a => null()) ! { dg-error \"Invalid character in name\" }\n+!$omp declare reduction (foo:integer:omp_out = omp_in + omp_out) &\n+!$omp & initializer(a => null()) ! { dg-error \"Invalid character in name\" }\n+end subroutine f4\n+subroutine f5\n+  integer :: a, b\n+!$omp declare reduction (foo:integer:a = b + 1) ! { dg-error \"Variable other than OMP_OUT or OMP_IN used in combiner\" }\n+!$omp declare reduction (bar:integer:omp_out = omp_out * omp_in) &\n+!$omp & initializer(b = a + 1) ! { dg-error \"Variable other than OMP_PRIV or OMP_ORIG used in INITIALIZER clause\" }\n+end subroutine f5\n+subroutine f6\n+!$omp declare reduction (foo:integer:omp_out=omp_out+omp_in) &\n+!$omp & initializer(omp_orig=omp_priv)\n+end subroutine f6"}, {"sha": "83fe6bd911c08fda57338b00bc7c4f4b26ce3d66", "filename": "gcc/testsuite/gfortran.dg/gomp/udr2.f90", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr2.f90?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -0,0 +1,43 @@\n+! { dg-do compile }\n+\n+subroutine f6\n+!$omp declare reduction (foo:real:omp_out (omp_in)) ! { dg-error \"Unclassifiable OpenMP directive\" }\n+!$omp declare reduction (bar:real:omp_out = omp_in * omp_out) & ! { dg-error \"Unclassifiable OpenMP directive\" }\n+!$omp & initializer (omp_priv (omp_orig))\n+end subroutine f6\n+subroutine f7\n+  integer :: a\n+!$omp declare reduction (foo:integer:a (omp_out, omp_in)) ! { dg-error \"Unclassifiable OpenMP directive\" }\n+!$omp declare reduction (bar:real:omp_out = omp_out.or.omp_in) ! { dg-error \"Operands of logical operator\" }\n+!$omp declare reduction (baz:real:omp_out = omp_out + omp_in)\n+!$omp & initializer (a (omp_priv, omp_orig)) ! { dg-error \"Unclassifiable OpenMP directive\" }\n+end subroutine f7\n+subroutine f8\n+  interface\n+    subroutine f8a (x)\n+      integer :: x\n+    end subroutine f8a\n+  end interface\n+!$omp declare reduction (baz:integer:omp_out = omp_out + omp_in) &\n+!$omp & initializer (f8a (omp_orig)) ! { dg-error \"One of actual subroutine arguments in INITIALIZER clause\" }\n+!$omp declare reduction (foo:integer:f8a) ! { dg-error \"is not a variable\" }\n+!$omp declare reduction (bar:integer:omp_out = omp_out - omp_in) &\n+!$omp & initializer (f8a) ! { dg-error \"is not a variable\" }\n+end subroutine f8\n+subroutine f9\n+  type dt\t! { dg-error \"which is not consistent with the CALL\" }\n+    integer :: x = 0\n+    integer :: y = 0\n+  end type dt\n+!$omp declare reduction (foo:integer:dt (omp_out, omp_in)) ! { dg-error \"which is not consistent with the CALL\" }\n+!$omp declare reduction (bar:integer:omp_out = omp_out + omp_in) &\n+!$omp & initializer (dt (omp_priv, omp_orig)) ! { dg-error \"which is not consistent with the CALL\" }\n+end subroutine f9\n+subroutine f10\n+  integer :: a, b\n+!$omp declare reduction(foo:character(len=64) &\n+!$omp & :omp_out(a:b) = omp_in(a:b)) ! { dg-error \"Variable other than OMP_OUT or OMP_IN used in combiner\" }\n+!$omp declare reduction(bar:character(len=16) &\n+!$omp & :omp_out = trim(omp_out) // omp_in) &\n+!$omp & initializer (omp_priv(a:b) = ' ') ! { dg-error \"Variable other than OMP_PRIV or OMP_ORIG used in INITIALIZER clause\" }\n+end subroutine f10"}, {"sha": "a4feaddd1a2a458285bc3b7ca526183652414510", "filename": "gcc/testsuite/gfortran.dg/gomp/udr3.f90", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr3.f90?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -0,0 +1,75 @@\n+! { dg-do compile }\n+\n+subroutine f1\n+  type dt\n+    logical :: l = .false.\n+  end type\n+  type dt2\n+    logical :: l = .false.\n+  end type\n+!$omp declare reduction (foo:integer(kind = 4) & ! { dg-error \"Previous !.OMP DECLARE REDUCTION\" }\n+!$omp & :omp_out = omp_out + omp_in)\n+!$omp declare reduction (foo:integer(kind = 4) : & ! { dg-error \"Redefinition of !.OMP DECLARE REDUCTION\" }\n+!$omp & omp_out = omp_out + omp_in)\n+!$omp declare reduction (bar:integer, &\n+!$omp & real:omp_out = omp_out + omp_in)\n+!$omp declare reduction (baz:integer,real,integer & ! { dg-error \"Redefinition of !.OMP DECLARE REDUCTION|Previous\" }\n+!$omp & : omp_out = omp_out + omp_in)\n+!$omp declare reduction (id1:dt,dt2:omp_out%l=omp_out%l &\n+!$omp & .or.omp_in%l)\n+!$omp declare reduction (id2:dt,dt:omp_out%l=omp_out%l & ! { dg-error \"Redefinition of !.OMP DECLARE REDUCTION|Previous\" }\n+!$omp & .or.omp_in%l)\n+!$omp declare reduction (id3:dt2,dt:omp_out%l=omp_out%l & ! { dg-error \"Previous !.OMP DECLARE REDUCTION\" }\n+!$omp & .or.omp_in%l)\n+!$omp declare reduction (id3:dt2:omp_out%l=omp_out%l & ! { dg-error \"Redefinition of !.OMP DECLARE REDUCTION\" }\n+!$omp & .or.omp_in%l)\n+end subroutine f1\n+subroutine f2\n+  interface\n+    subroutine f2a (x, y, z)\n+      character (len = *) :: x, y\n+      logical :: z\n+    end subroutine\n+  end interface\n+  interface f2b\n+    subroutine f2b (x, y, z)\n+      character (len = *, kind = 1) :: x, y\n+      logical :: z\n+    end subroutine\n+    subroutine f2c (x, y, z)\n+      character (kind = 4, len = *) :: x, y\n+      logical :: z\n+    end subroutine\n+  end interface\n+!$omp declare reduction (foo:character(len=*): &\n+!$omp & f2a (omp_out, omp_in, .false.)) &\n+!$omp & initializer (f2a (omp_priv, omp_orig, .true.))\n+!$omp declare reduction (bar:character(len=:): &\n+!$omp & f2a (omp_out, omp_in, .false.)) &\n+!$omp & initializer (f2a (omp_priv, omp_orig, .true.))\n+!$omp declare reduction (baz:character(len=4): &\n+!$omp & f2a (omp_out, omp_in, .false.)) &\n+!$omp & initializer (f2a (omp_priv, omp_orig, .true.))\n+!$omp declare reduction (baz:character(len=5): &\n+!$omp & f2a (omp_out, omp_in, .false.)) &\n+!$omp & initializer (f2a (omp_priv, omp_orig, .true.))\n+!$omp declare reduction (baz:character(len=6): &\n+!$omp & f2a (omp_out, omp_in, .false.)) &\n+!$omp & initializer (f2a (omp_priv, omp_orig, .true.))\n+!$omp declare reduction (id:character(len=*): & ! { dg-error \"Previous !.OMP DECLARE REDUCTION\" }\n+!$omp & f2a (omp_out, omp_in, .false.)) &\n+!$omp & initializer (f2a (omp_priv, omp_orig, .true.))\n+!$omp declare reduction (id: & ! { dg-error \"Redefinition of !.OMP DECLARE REDUCTION\" }\n+!$omp & character(len=:) : f2a (omp_out, omp_in, .false.)) &\n+!$omp & initializer (f2a (omp_priv, omp_orig, .true.))\n+!$omp declare reduction & ! { dg-error \"Redefinition of !.OMP DECLARE REDUCTION|Previous\" }\n+!$omp (id2:character(len=*), character(len=:): &\n+!$omp f2a (omp_out, omp_in, .false.)) &\n+!$omp & initializer (f2a (omp_priv, omp_orig, .true.))\n+!$omp declare reduction (id3:character(len=*, kind = 1), character(kind=4, len=:): &\n+!$omp f2b (omp_out, omp_in, .false.)) &\n+!$omp & initializer (f2b (omp_priv, omp_orig, .true.))\n+!$omp declare reduction (id4:character(kind=4, len=4), character(kind =1, len=4): &\n+!$omp f2b (omp_out, omp_in, .false.)) &\n+!$omp & initializer (f2b (omp_priv, omp_orig, .true.))\n+end subroutine f2"}, {"sha": "223dfd04cd20426e048950b2b9802c1a52074cb9", "filename": "gcc/testsuite/gfortran.dg/gomp/udr4.f90", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr4.f90?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -0,0 +1,64 @@\n+! { dg-do compile }\n+\n+subroutine f3\n+!$omp declare reduction ! { dg-error \"Unclassifiable OpenMP directive\" }\n+!$omp declare reduction foo ! { dg-error \"Unclassifiable OpenMP directive\" }\n+!$omp declare reduction (foo) ! { dg-error \"Unclassifiable OpenMP directive\" }\n+!$omp declare reduction (foo:integer) ! { dg-error \"Unclassifiable OpenMP directive\" }\n+!$omp declare reduction (foo:integer:omp_out=omp_out+omp_in) &\n+!$omp & initializer(omp_priv=0) initializer(omp_priv=0) ! { dg-error \"Unclassifiable statement\" }\n+end subroutine f3\n+subroutine f4\n+  implicit integer (o)\n+  implicit real (b)\n+!$omp declare reduction (foo:integer:omp_priv(omp_out,omp_in)) ! { dg-error \"Implicitly declared subroutine omp_priv\" }\n+!$omp declare reduction (foo:real:bar(omp_out,omp_in)) ! { dg-error \"Implicitly declared subroutine bar used\" }\n+!$omp declare reduction (bar:integer:omp_out=omp_out+omp_in) &\n+!$omp & initializer(omp_out (omp_priv)) ! { dg-error \"Implicitly declared subroutine omp_out used\" }\n+!$omp declare reduction (bar:real:omp_out=omp_out+omp_in) &\n+!$omp & initializer(bar (omp_priv, omp_orig)) ! { dg-error \"Implicitly declared subroutine bar used\" }\n+!$omp declare reduction (id1:integer:omp_out=omp_orig(omp_out,omp_in)) ! { dg-error \"Implicitly declared function omp_orig used\" }\n+!$omp declare reduction (id1:real:omp_out=foo(omp_out,omp_in)) ! { dg-error \"Implicitly declared function foo used\" }\n+!$omp declare reduction (id2:integer:omp_out=omp_out+omp_in) &\n+!$omp & initializer(omp_priv = omp_in (omp_orig)) ! { dg-error \"Implicitly declared function omp_in used\" }\n+!$omp declare reduction (id2:real:omp_out=omp_out+omp_in) &\n+!$omp & initializer(omp_priv = baz (omp_orig)) ! { dg-error \"Implicitly declared function baz used\" }\n+end subroutine f4\n+subroutine f5\n+  interface\n+    subroutine f5a (x, *, y)\n+      double precision :: x, y\n+    end subroutine f5a\n+  end interface\n+!$omp declare reduction (foo:double precision: & ! { dg-error \"Subroutine call with alternate returns in combiner\" }\n+!$omp & f5a (omp_out, *10, omp_in))\n+!$omp declare reduction (bar:double precision: &\n+!$omp omp_out = omp_in + omp_out) &\n+!$omp & initializer (f5a (omp_priv, *20, omp_orig)) ! { dg-error \"Subroutine call with alternate returns in INITIALIZER clause\" }\n+10 continue\n+20 continue\n+! { dg-error \"Label\\[^\\n\\r]* is never defined\" \"\" { target *-*-* } 0 }\n+! { dg-prune-output \"<During initialization>\" }\n+end subroutine f5\n+subroutine f6\n+  integer :: a\n+!$omp declare reduction(foo:character(len=a*2) & ! { dg-error \"cannot appear in the expression|not constant\" }\n+!$omp & :omp_out=trim(omp_out)//omp_in) &\n+!$omp & initializer(omp_priv=' ')\n+end subroutine f6\n+subroutine f7\n+  type dt1\n+    integer :: a = 1\n+    integer :: b\n+  end type\n+  type dt2\n+    integer :: a = 2\n+    integer :: b = 3\n+  end type\n+  type dt3\n+    integer :: a\n+    integer :: b\n+  end type dt3\n+!$omp declare reduction(foo:dt1,dt2:omp_out%a=omp_out%a+omp_in%a)\n+!$omp declare reduction(foo:dt3:omp_out%a=omp_out%a+omp_in%a) ! { dg-error \"Missing INITIALIZER clause for !.OMP DECLARE REDUCTION of derived type without default initializer\" }\n+end subroutine f7"}, {"sha": "aebeee3a2430abf8d4c522ea3e8817b4f8cf4ef5", "filename": "gcc/testsuite/gfortran.dg/gomp/udr5.f90", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr5.f90?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -0,0 +1,59 @@\n+! { dg-do compile }\n+\n+module udr5m1\n+  type dt\n+    real :: r\n+  end type dt\n+end module udr5m1\n+module udr5m2\n+  use udr5m1\n+  interface operator(+)\n+    module procedure addm2\n+  end interface\n+!$omp declare reduction(+:dt:omp_out=omp_out+omp_in) &\n+!$omp & initializer(omp_priv=dt(0.0))\n+!$omp declare reduction(.myadd.:dt:omp_out=omp_out.myadd.omp_in) &\n+!$omp & initializer(omp_priv=dt(0.0))\n+  interface operator(.myadd.)\n+    module procedure addm2\n+  end interface\n+contains\n+  type(dt) function addm2 (x, y)\n+    type(dt), intent (in):: x, y\n+    addm2%r = x%r + y%r\n+  end function\n+end module udr5m2\n+module udr5m3\n+  use udr5m1\n+  interface operator(.myadd.)\n+    module procedure addm3\n+  end interface\n+!$omp declare reduction(+:dt:omp_out=omp_out+omp_in) &\n+!$omp & initializer(omp_priv=dt(0.0))\n+!$omp declare reduction(.myadd.:dt:omp_out=omp_out.myadd.omp_in) &\n+!$omp & initializer(omp_priv=dt(0.0))\n+  interface operator(+)\n+    module procedure addm3\n+  end interface\n+contains\n+  type(dt) function addm3 (x, y)\n+    type(dt), intent (in):: x, y\n+    addm3%r = x%r + y%r\n+  end function\n+end module udr5m3\n+subroutine f1\n+  use udr5m2\n+  type(dt) :: d, e\n+  integer :: i\n+  d=dt(0.0)\n+  e = dt (0.0)\n+!$omp parallel do reduction (+ : d) reduction ( .myadd. : e)\n+  do i=1,100\n+    d=d+dt(i)\n+    e=e+dt(i)\n+  end do\n+end subroutine f1\n+subroutine f2\n+  use udr5m3\t! { dg-error \"Previous !.OMP DECLARE REDUCTION|Ambiguous interfaces\" }\n+  use udr5m2\t! { dg-error \"Ambiguous !.OMP DECLARE REDUCTION\" }\n+end subroutine f2"}, {"sha": "ae2a4854e45387574f23a02701a3591b84cbff4f", "filename": "gcc/testsuite/gfortran.dg/gomp/udr6.f90", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr6.f90?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -0,0 +1,205 @@\n+! { dg-do compile }\n+! { dg-options \"-fmax-errors=1000 -fopenmp -ffree-line-length-160\" }\n+\n+module udr6\n+  type dt\n+    integer :: i\n+  end type\n+end module udr6\n+subroutine f1\n+  use udr6, only : dt\n+!$omp declare reduction (+:integer:omp_out = omp_out + omp_in) ! { dg-error \"Redefinition of predefined\" }\n+!$omp declare reduction (+:real(kind=4):omp_out = omp_out + omp_in) ! { dg-error \"Redefinition of predefined\" }\n+!$omp declare reduction (+:double precision:omp_out = omp_out + omp_in) ! { dg-error \"Redefinition of predefined\" }\n+!$omp declare reduction (+:integer(kind=8),integer(kind=1) & ! { dg-error \"Redefinition of predefined\" }\n+!$omp & :omp_out = omp_out + omp_in)\n+!$omp declare reduction (+:complex:omp_out = omp_out + omp_in) ! { dg-error \"Redefinition of predefined\" }\n+!$omp declare reduction (+:complex(kind=16):omp_out = omp_out + omp_in) ! { dg-error \"Redefinition of predefined\" }\n+  interface operator(+)\n+    function addf1 (x, y)\n+      use udr6, only : dt\n+      type(dt), intent (in) :: x, y\n+      type(dt) :: addf1\n+    end function\n+  end interface\n+end subroutine f1\n+subroutine f2\n+  use udr6, only : dt\n+  interface operator(-)\n+    function subf2 (x, y)\n+      use udr6, only : dt\n+      type(dt), intent (in) :: x, y\n+      type(dt) :: subf2\n+    end function\n+  end interface\n+!$omp declare reduction (-:integer:omp_out = omp_out + omp_in) ! { dg-error \"Redefinition of predefined\" }\n+!$omp declare reduction (-:real(kind=4):omp_out = omp_out + omp_in) ! { dg-error \"Redefinition of predefined\" }\n+!$omp declare reduction (-:double precision:omp_out = omp_out + omp_in) ! { dg-error \"Redefinition of predefined\" }\n+!$omp declare reduction (-:integer(kind=8),integer(kind=1) & ! { dg-error \"Redefinition of predefined\" }\n+!$omp & :omp_out = omp_out + omp_in)\n+!$omp declare reduction (-:complex:omp_out = omp_out + omp_in) ! { dg-error \"Redefinition of predefined\" }\n+!$omp declare reduction (-:complex(kind=16):omp_out = omp_out + omp_in) ! { dg-error \"Redefinition of predefined\" }\n+end subroutine f2\n+subroutine f3\n+  use udr6, only : dt\n+  interface operator(*)\n+    function mulf3 (x, y)\n+      use udr6, only : dt\n+      type(dt), intent (in) :: x, y\n+      type(dt) :: mulf3\n+    end function\n+  end interface\n+!$omp declare reduction (*:integer:omp_out = omp_out * omp_in) ! { dg-error \"Redefinition of predefined\" }\n+!$omp declare reduction (*:real(kind=4):omp_out = omp_out * omp_in) ! { dg-error \"Redefinition of predefined\" }\n+!$omp declare reduction (*:double precision:omp_out = omp_out * omp_in) ! { dg-error \"Redefinition of predefined\" }\n+!$omp declare reduction (*:integer(kind=8),integer(kind=1) & ! { dg-error \"Redefinition of predefined\" }\n+!$omp & :omp_out = omp_out * omp_in)\n+!$omp declare reduction (*:complex:omp_out = omp_out * omp_in) ! { dg-error \"Redefinition of predefined\" }\n+!$omp declare reduction (*:complex(kind=16):omp_out = omp_out * omp_in) ! { dg-error \"Redefinition of predefined\" }\n+end subroutine f3\n+subroutine f4\n+  use udr6, only : dt\n+  interface operator(.and.)\n+    function andf4 (x, y)\n+      use udr6, only : dt\n+      type(dt), intent (in) :: x, y\n+      type(dt) :: andf4\n+    end function\n+  end interface\n+!$omp declare reduction (.neqv.:logical:omp_out = omp_out .or. omp_in) ! { dg-error \"Redefinition of predefined\" }\n+  interface operator(.or.)\n+    function orf4 (x, y)\n+      use udr6, only : dt\n+      type(dt), intent (in) :: x, y\n+      type(dt) :: orf4\n+    end function\n+  end interface\n+!$omp declare reduction (.eqv.:logical:omp_out = omp_out .or. omp_in) ! { dg-error \"Redefinition of predefined\" }\n+  interface operator(.eqv.)\n+    function eqvf4 (x, y)\n+      use udr6, only : dt\n+      type(dt), intent (in) :: x, y\n+      type(dt) :: eqvf4\n+    end function\n+  end interface\n+!$omp declare reduction (.or.:logical:omp_out = omp_out .or. omp_in) ! { dg-error \"Redefinition of predefined\" }\n+  interface operator(.neqv.)\n+    function neqvf4 (x, y)\n+      use udr6, only : dt\n+      type(dt), intent (in) :: x, y\n+      type(dt) :: neqvf4\n+    end function\n+  end interface\n+!$omp declare reduction (.and.:logical:omp_out = omp_out .and. omp_in) ! { dg-error \"Redefinition of predefined\" }\n+end subroutine f4\n+subroutine f5\n+  use udr6, only : dt\n+  interface operator(.and.)\n+    function andf5 (x, y)\n+      use udr6, only : dt\n+      type(dt), intent (in) :: x, y\n+      type(dt) :: andf5\n+    end function\n+  end interface\n+!$omp declare reduction (.neqv.:logical(kind =4):omp_out = omp_out .neqv. omp_in) ! { dg-error \"Redefinition of predefined\" }\n+  interface operator(.or.)\n+    function orf5 (x, y)\n+      use udr6, only : dt\n+      type(dt), intent (in) :: x, y\n+      type(dt) :: orf5\n+    end function\n+  end interface\n+!$omp declare reduction (.eqv.:logical(kind= 4):omp_out = omp_out .eqv. omp_in) ! { dg-error \"Redefinition of predefined\" }\n+  interface operator(.eqv.)\n+    function eqvf5 (x, y)\n+      use udr6, only : dt\n+      type(dt), intent (in) :: x, y\n+      type(dt) :: eqvf5\n+    end function\n+  end interface\n+!$omp declare reduction (.or.:logical(kind=4):omp_out = omp_out .or. omp_in) ! { dg-error \"Redefinition of predefined\" }\n+  interface operator(.neqv.)\n+    function neqvf5 (x, y)\n+      use udr6, only : dt\n+      type(dt), intent (in) :: x, y\n+      type(dt) :: neqvf5\n+    end function\n+  end interface\n+!$omp declare reduction (.and.:logical(kind = 4):omp_out = omp_out .and. omp_in) ! { dg-error \"Redefinition of predefined\" }\n+end subroutine f5\n+subroutine f6\n+!$omp declare reduction (min:integer:omp_out = min (omp_out, omp_in)) ! { dg-error \"Redefinition of predefined\" }\n+!$omp declare reduction (max:integer:omp_out = max (omp_out, omp_in)) ! { dg-error \"Redefinition of predefined\" }\n+!$omp declare reduction (iand:integer:omp_out = iand (omp_out, omp_in)) ! { dg-error \"Redefinition of predefined\" }\n+!$omp declare reduction (ior:integer:omp_out = ior (omp_out, omp_in)) ! { dg-error \"Redefinition of predefined\" }\n+!$omp declare reduction (ieor:integer:omp_out = ieor (omp_out, omp_in)) ! { dg-error \"Redefinition of predefined\" }\n+!$omp declare reduction (min:real:omp_out = min (omp_out, omp_in)) ! { dg-error \"Redefinition of predefined\" }\n+!$omp declare reduction (max:real:omp_out = max (omp_out, omp_in)) ! { dg-error \"Redefinition of predefined\" }\n+!$omp declare reduction (min:double precision:omp_out = min (omp_out, omp_in)) ! { dg-error \"Redefinition of predefined\" }\n+!$omp declare reduction (max:double precision:omp_out = max (omp_out, omp_in)) ! { dg-error \"Redefinition of predefined\" }\n+end subroutine f6\n+subroutine f7\n+!$omp declare reduction (min:integer(kind=2):omp_out = min (omp_out, omp_in)) ! { dg-error \"Redefinition of predefined\" }\n+!$omp declare reduction (max:integer(kind=4):omp_out = max (omp_out, omp_in)) ! { dg-error \"Redefinition of predefined\" }\n+!$omp declare reduction (iand:integer(kind=1):omp_out = iand (omp_out, omp_in)) ! { dg-error \"Redefinition of predefined\" }\n+!$omp declare reduction (ior:integer(kind=8):omp_out = ior (omp_out, omp_in)) ! { dg-error \"Redefinition of predefined\" }\n+!$omp declare reduction (ieor:integer(kind=4):omp_out = ieor (omp_out, omp_in)) ! { dg-error \"Redefinition of predefined\" }\n+!$omp declare reduction (min:real(kind=4):omp_out = min (omp_out, omp_in)) ! { dg-error \"Redefinition of predefined\" }\n+!$omp declare reduction (max:real(kind=4):omp_out = max (omp_out, omp_in)) ! { dg-error \"Redefinition of predefined\" }\n+!$omp declare reduction (min:double precision:omp_out = min (omp_out, omp_in)) ! { dg-error \"Redefinition of predefined\" }\n+!$omp declare reduction (max:double precision:omp_out = max (omp_out, omp_in)) ! { dg-error \"Redefinition of predefined\" }\n+end subroutine f7\n+subroutine f8\n+  integer :: min\n+!$omp declare reduction (min:integer:omp_out = omp_out + omp_in)\n+!$omp declare reduction (min:real:omp_out = omp_out + omp_in)\n+!$omp declare reduction (min:double precision:omp_out = omp_out + omp_in)\n+end subroutine f8\n+subroutine f9\n+  integer :: max\n+!$omp declare reduction (max:integer:omp_out = omp_out + omp_in)\n+!$omp declare reduction (max:real:omp_out = omp_out + omp_in)\n+!$omp declare reduction (max:double precision:omp_out = omp_out + omp_in)\n+end subroutine f9\n+subroutine f10\n+  integer :: iand\n+!$omp declare reduction (iand:integer:omp_out = omp_out + omp_in)\n+!$omp declare reduction (iand:real:omp_out = omp_out + omp_in)\n+end subroutine f10\n+subroutine f11\n+  integer :: ior\n+!$omp declare reduction (ior:integer:omp_out = omp_out + omp_in)\n+!$omp declare reduction (ior:real:omp_out = omp_out + omp_in)\n+end subroutine f11\n+subroutine f12\n+  integer :: ieor\n+!$omp declare reduction (ieor:integer:omp_out = omp_out + omp_in)\n+!$omp declare reduction (ieor:real:omp_out = omp_out + omp_in)\n+end subroutine f12\n+subroutine f13\n+!$omp declare reduction (min:integer:omp_out = omp_out + omp_in)\n+!$omp declare reduction (min:real:omp_out = omp_out + omp_in)\n+!$omp declare reduction (min:double precision:omp_out = omp_out + omp_in)\n+  integer :: min\n+end subroutine f13\n+subroutine f14\n+!$omp declare reduction (max:integer:omp_out = omp_out + omp_in)\n+!$omp declare reduction (max:real:omp_out = omp_out + omp_in)\n+!$omp declare reduction (max:double precision:omp_out = omp_out + omp_in)\n+  integer :: max\n+end subroutine f14\n+subroutine f15\n+!$omp declare reduction (iand:integer:omp_out = omp_out + omp_in)\n+!$omp declare reduction (iand:real:omp_out = omp_out + omp_in)\n+  integer :: iand\n+end subroutine f15\n+subroutine f16\n+!$omp declare reduction (ior:integer:omp_out = omp_out + omp_in)\n+!$omp declare reduction (ior:real:omp_out = omp_out + omp_in)\n+  integer :: ior\n+end subroutine f16\n+subroutine f17\n+!$omp declare reduction (ieor:integer:omp_out = omp_out + omp_in)\n+!$omp declare reduction (ieor:real:omp_out = omp_out + omp_in)\n+  integer :: ieor\n+end subroutine f17"}, {"sha": "230a3fc44dd967a7d1562971a721439534eaa4f1", "filename": "gcc/testsuite/gfortran.dg/gomp/udr7.f90", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fudr7.f90?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -0,0 +1,90 @@\n+! { dg-do compile }\n+\n+module udr7m1\n+  type dt\n+    real :: r\n+  end type dt\n+end module udr7m1\n+module udr7m2\n+  use udr7m1\n+  interface operator(+)\n+    module procedure addm2\n+  end interface\n+!$omp declare reduction(+:dt:omp_out=omp_out+omp_in) &\n+!$omp & initializer(omp_priv=dt(0.0))\n+!$omp declare reduction(.myadd.:dt:omp_out=omp_out.myadd.omp_in) &\n+!$omp & initializer(omp_priv=dt(0.0))\n+  interface operator(.myadd.)\n+    module procedure addm2\n+  end interface\n+  private\n+  public :: operator(+), operator(.myadd.), dt\n+contains\n+  type(dt) function addm2 (x, y)\n+    type(dt), intent (in):: x, y\n+    addm2%r = x%r + y%r\n+  end function\n+end module udr7m2\n+module udr7m3\n+  use udr7m1\n+  private\n+  public :: operator(.myadd.), operator(+), dt\n+  interface operator(.myadd.)\n+    module procedure addm3\n+  end interface\n+!$omp declare reduction(+:dt:omp_out=omp_out+omp_in) &\n+!$omp & initializer(omp_priv=dt(0.0))\n+!$omp declare reduction(.myadd.:dt:omp_out=omp_out.myadd.omp_in) &\n+!$omp & initializer(omp_priv=dt(0.0))\n+  interface operator(+)\n+    module procedure addm3\n+  end interface\n+contains\n+  type(dt) function addm3 (x, y)\n+    type(dt), intent (in):: x, y\n+    addm3%r = x%r + y%r\n+  end function\n+end module udr7m3\n+module udr7m4\n+  use udr7m1\n+  private\n+  interface operator(.myadd.)\n+    module procedure addm4\n+  end interface\n+!$omp declare reduction(+:dt:omp_out=omp_out+omp_in) &\n+!$omp & initializer(omp_priv=dt(0.0))\n+!$omp declare reduction(.myadd.:dt:omp_out=omp_out.myadd.omp_in) &\n+!$omp & initializer(omp_priv=dt(0.0))\n+  interface operator(+)\n+    module procedure addm4\n+  end interface\n+contains\n+  type(dt) function addm4 (x, y)\n+    type(dt), intent (in):: x, y\n+    addm4%r = x%r + y%r\n+  end function\n+end module udr7m4\n+subroutine f1\n+  use udr7m2\n+  type(dt) :: d, e\n+  integer :: i\n+  d=dt(0.0)\n+  e = dt (0.0)\n+!$omp parallel do reduction (+ : d) reduction ( .myadd. : e)\n+  do i=1,100\n+    d=d+dt(i)\n+    e=e+dt(i)\n+  end do\n+end subroutine f1\n+subroutine f2\n+  use udr7m3\t! { dg-error \"Previous !.OMP DECLARE REDUCTION|Ambiguous interfaces\" }\n+  use udr7m2\t! { dg-error \"Ambiguous !.OMP DECLARE REDUCTION\" }\n+end subroutine f2\n+subroutine f3\n+  use udr7m4\n+  use udr7m2\n+end subroutine f3\n+subroutine f4\n+  use udr7m3\n+  use udr7m4\n+end subroutine f4"}, {"sha": "ff389bc08a1464b8fd12db74f41c776d578143a5", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -1,3 +1,18 @@\n+2014-06-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.fortran/simd1.f90: New test.\n+\t* testsuite/libgomp.fortran/udr1.f90: New test.\n+\t* testsuite/libgomp.fortran/udr2.f90: New test.\n+\t* testsuite/libgomp.fortran/udr3.f90: New test.\n+\t* testsuite/libgomp.fortran/udr4.f90: New test.\n+\t* testsuite/libgomp.fortran/udr5.f90: New test.\n+\t* testsuite/libgomp.fortran/udr6.f90: New test.\n+\t* testsuite/libgomp.fortran/udr7.f90: New test.\n+\t* testsuite/libgomp.fortran/udr8.f90: New test.\n+\t* testsuite/libgomp.fortran/udr9.f90: New test.\n+\t* testsuite/libgomp.fortran/udr10.f90: New test.\n+\t* testsuite/libgomp.fortran/udr11.f90: New test.\n+\n 2014-05-27  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* testsuite/libgomp.fortran/declare-simd-1.f90: Require"}, {"sha": "b97d27f8dc50e72000ba867877f246a2f0350a93", "filename": "libgomp/testsuite/libgomp.fortran/simd1.f90", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fsimd1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fsimd1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fsimd1.f90?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -2,22 +2,34 @@\n ! { dg-additional-options \"-msse2\" { target sse2_runtime } }\n ! { dg-additional-options \"-mavx\" { target avx_runtime } }\n \n-  integer :: i, j, k, l, r, a(30)\n+  type dt\n+    integer :: x = 0\n+  end type\n+  type (dt) :: t\n+  integer :: i, j, k, l, r, s, a(30)\n   integer, target :: q(30)\n   integer, pointer :: p(:)\n+  !$omp declare reduction (foo : integer : &\n+  !$omp & omp_out = omp_out + omp_in) initializer (omp_priv = 0)\n+  !$omp declare reduction (+ : dt : omp_out%x = omp_out%x &\n+  !$omp & + omp_in%x)\n   a(:) = 1\n   q(:) = 1\n   p => q\n   r = 0\n   j = 10\n   k = 20\n-  !$omp simd safelen (8) reduction(+:r) linear(j, k : 2) &\n-  !$omp& private (l) aligned(p : 4)\n+  s = 0\n+  !$omp simd safelen (8) reduction(+:r, t) linear(j, k : 2) &\n+  !$omp& private (l) aligned(p : 4) reduction(foo:s)\n   do i = 1, 30\n     l = j + k + a(i) + p(i)\n     r = r + l\n     j = j + 2\n     k = k + 2\n+    s = s + l\n+    t%x = t%x + l\n   end do\n-  if (r.ne.2700.or.j.ne.70.or.k.ne.80) call abort\n+  if (r.ne.2700.or.j.ne.70.or.k.ne.80.or.s.ne.2700) call abort\n+  if (t%x.ne.2700) call abort\n end"}, {"sha": "5b8044fbe75bed136cc31036cd6ecf27d675b5e5", "filename": "libgomp/testsuite/libgomp.fortran/udr1.f90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr1.f90?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -0,0 +1,51 @@\n+! { dg-do run }\n+\n+module udr1\n+  type dt\n+    integer :: x = 7\n+    integer :: y = 9\n+  end type\n+end module udr1\n+  use udr1, only : dt\n+!$omp declare reduction (foo : integer : omp_out = omp_out + omp_in)\n+  integer :: i, j\n+!$omp declare reduction (bar : integer : &\n+!$omp & omp_out = omp_out + iand (omp_in, -4)) initializer (omp_priv = 3)\n+  type (dt) :: d\n+!$omp declare reduction (+ : dt : omp_out%x = omp_out%x &\n+!$omp & + iand (omp_in%x, -8))\n+!$omp declare reduction (foo : dt : omp_out%x = iand (omp_in%x, -8) &\n+!$omp & + omp_out%x) initializer (omp_priv = dt (5, 21))\n+  interface operator (+)\n+    function notdefined(x, y)\n+      use udr1, only : dt\n+      type(dt), intent (in) :: x, y\n+      type(dt) :: notdefined\n+    end function\n+  end interface\n+  j = 0\n+!$omp parallel do reduction (foo : j)\n+  do i = 1, 100\n+    j = j + i\n+  end do\n+  if (j .ne. 5050) call abort\n+  j = 3\n+!$omp parallel do reduction (bar : j)\n+  do i = 1, 100\n+    j = j + 4 * i\n+  end do\n+  if (j .ne. (5050 * 4 + 3)) call abort\n+!$omp parallel do reduction (+ : d)\n+  do i = 1, 100\n+    if (d%y .ne. 9) call abort\n+    d%x = d%x + 8 * i\n+  end do\n+  if (d%x .ne. (5050 * 8 + 7) .or. d%y .ne. 9) call abort\n+  d = dt (5, 21)\n+!$omp parallel do reduction (foo : d)\n+  do i = 1, 100\n+    if (d%y .ne. 21) call abort\n+    d%x = d%x + 8 * i\n+  end do\n+  if (d%x .ne. (5050 * 8 + 5) .or. d%y .ne. 21) call abort\n+end"}, {"sha": "b64b4f48800c5bcf6c12a2e8addbb690cedd380d", "filename": "libgomp/testsuite/libgomp.fortran/udr10.f90", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr10.f90?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -0,0 +1,32 @@\n+! { dg-do run }\n+\n+module udr10m\n+  type dt\n+    integer :: x = 0\n+  end type\n+!$omp declare reduction(.add.:dt:omp_out=omp_out.add.omp_in)\n+!$omp declare reduction(+:dt:omp_out=omp_out+omp_in)\n+  interface operator(+)\n+    module procedure addme\n+  end interface\n+  interface operator(.add.)\n+    module procedure addme\n+  end interface\n+contains\n+  type(dt) function addme (x, y)\n+    type (dt), intent (in) :: x, y\n+    addme%x = x%x + y%x\n+  end function addme\n+end module udr10m\n+program udr10\n+  use udr10m, only : operator(.localadd.) => operator(.add.), &\n+& operator(+), dl => dt\n+  type(dl) :: j, k\n+  integer :: i\n+!$omp parallel do reduction(+:j) reduction(.localadd.:k)\n+  do i = 1, 100\n+    j = j .localadd. dl(i)\n+    k = k + dl(i * 2)\n+  end do\n+  if (j%x /= 5050 .or. k%x /= 10100) call abort\n+end"}, {"sha": "61fb196105d5057b2e209f5260056527bbadbfd4", "filename": "libgomp/testsuite/libgomp.fortran/udr11.f90", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr11.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr11.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr11.f90?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -0,0 +1,95 @@\n+! { dg-do run }\n+\n+module udr11\n+  type dt\n+    integer :: x = 0\n+  end type\n+end module udr11\n+  use udr11, only : dt\n+!$omp declare reduction(+:dt:omp_out%x=omp_out%x+omp_in%x)\n+!$omp declare reduction(-:dt:omp_out%x=omp_out%x+omp_in%x)\n+!$omp declare reduction(*:dt:omp_out%x=omp_out%x+omp_in%x)\n+!$omp declare reduction(.and.:dt:omp_out%x=omp_out%x+omp_in%x)\n+!$omp declare reduction(.or.:dt:omp_out%x=omp_out%x+3*omp_in%x)\n+!$omp declare reduction(.eqv.:dt:omp_out%x=omp_out%x+omp_in%x)\n+!$omp declare reduction(.neqv.:dt:omp_out%x=omp_out%x+omp_in%x)\n+!$omp declare reduction(min:dt:omp_out%x=omp_out%x+omp_in%x)\n+!$omp declare reduction(max:dt:omp_out%x=omp_out%x+omp_in%x)\n+!$omp declare reduction(iand:dt:omp_out%x=omp_out%x+omp_in%x)\n+!$omp declare reduction(ior:dt:omp_out%x=omp_out%x+omp_in%x)\n+!$omp declare reduction(ieor:dt:omp_out%x=omp_out%x+omp_in%x)\n+  interface operator(.and.)\n+    function addme1 (x, y)\n+      use udr11, only : dt\n+      type (dt), intent (in) :: x, y\n+      type(dt) :: addme1\n+    end function addme1\n+  end interface\n+  interface operator(.or.)\n+    function addme2 (x, y)\n+      use udr11, only : dt\n+      type (dt), intent (in) :: x, y\n+      type(dt) :: addme2\n+    end function addme2\n+  end interface\n+  interface operator(.eqv.)\n+    function addme3 (x, y)\n+      use udr11, only : dt\n+      type (dt), intent (in) :: x, y\n+      type(dt) :: addme3\n+    end function addme3\n+  end interface\n+  interface operator(.neqv.)\n+    function addme4 (x, y)\n+      use udr11, only : dt\n+      type (dt), intent (in) :: x, y\n+      type(dt) :: addme4\n+    end function addme4\n+  end interface\n+  interface operator(+)\n+    function addme5 (x, y)\n+      use udr11, only : dt\n+      type (dt), intent (in) :: x, y\n+      type(dt) :: addme5\n+    end function addme5\n+  end interface\n+  interface operator(-)\n+    function addme6 (x, y)\n+      use udr11, only : dt\n+      type (dt), intent (in) :: x, y\n+      type(dt) :: addme6\n+    end function addme6\n+  end interface\n+  interface operator(*)\n+    function addme7 (x, y)\n+      use udr11, only : dt\n+      type (dt), intent (in) :: x, y\n+      type(dt) :: addme7\n+    end function addme7\n+  end interface\n+  type(dt) :: j, k, l, m, n, o, p, q, r, s, t, u\n+  integer :: i\n+!$omp parallel do reduction(.and.:j) reduction(.or.:k) &\n+!$omp & reduction(.eqv.:l) reduction(.neqv.:m) &\n+!$omp & reduction(min:n) reduction(max:o) &\n+!$omp & reduction(iand:p) reduction(ior:q) reduction (ieor:r) &\n+!$omp & reduction(+:s) reduction(-:t) reduction(*:u)\n+  do i = 1, 100\n+    j%x = j%x + i\n+    k%x = k%x + 2 * i\n+    l%x = l%x + 3 * i\n+    m%x = m%x + i\n+    n%x = n%x + 2 * i\n+    o%x = o%x + 3 * i\n+    p%x = p%x + i\n+    q%x = q%x + 2 * i\n+    r%x = r%x + 3 * i\n+    s%x = s%x + i\n+    t%x = t%x + 2 * i\n+    u%x = u%x + 3 * i\n+  end do\n+  if (j%x /= 5050 .or. k%x /= 30300 .or. l%x /= 15150) call abort\n+  if (m%x /= 5050 .or. n%x /= 10100 .or. o%x /= 15150) call abort\n+  if (p%x /= 5050 .or. q%x /= 10100 .or. r%x /= 15150) call abort\n+  if (s%x /= 5050 .or. t%x /= 10100 .or. u%x /= 15150) call abort\n+end"}, {"sha": "861a4b2702287a774ea0a368504fc6ff002d33fc", "filename": "libgomp/testsuite/libgomp.fortran/udr2.f90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr2.f90?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -0,0 +1,51 @@\n+! { dg-do run }\n+\n+module udr2\n+  type dt\n+    integer :: x = 7\n+    integer :: y = 9\n+  end type\n+end module udr2\n+  use udr2, only : dt\n+!$omp declare reduction (foo : integer : omp_out = omp_out + omp_in)\n+  integer :: i, j(2:4,3:5)\n+!$omp declare reduction (bar : integer : &\n+!$omp & omp_out = omp_out + iand (omp_in, -4)) initializer (omp_priv = 3)\n+  interface operator (+)\n+    function notdefined(x, y)\n+      use udr2, only : dt\n+      type(dt), intent (in) :: x, y\n+      type(dt) :: notdefined\n+    end function\n+  end interface\n+  type (dt) :: d(2:4,3:5)\n+!$omp declare reduction (+ : dt : omp_out%x = omp_out%x &\n+!$omp & + iand (omp_in%x, -8))\n+!$omp declare reduction (foo : dt : omp_out%x = iand (omp_in%x, -8) &\n+!$omp & + omp_out%x) initializer (omp_priv = dt (5, 21))\n+  j = 0\n+!$omp parallel do reduction (foo : j)\n+  do i = 1, 100\n+    j = j + i\n+  end do\n+  if (any(j .ne. 5050)) call abort\n+  j = 3\n+!$omp parallel do reduction (bar : j)\n+  do i = 1, 100\n+    j = j + 4 * i\n+  end do\n+  if (any(j .ne. (5050 * 4 + 3))) call abort\n+!$omp parallel do reduction (+ : d)\n+  do i = 1, 100\n+    if (any(d%y .ne. 9)) call abort\n+    d%x = d%x + 8 * i\n+  end do\n+  if (any(d%x .ne. (5050 * 8 + 7)) .or. any(d%y .ne. 9)) call abort\n+  d = dt (5, 21)\n+!$omp parallel do reduction (foo : d)\n+  do i = 1, 100\n+    if (any(d%y .ne. 21)) call abort\n+    d%x = d%x + 8 * i\n+  end do\n+  if (any(d%x .ne. (5050 * 8 + 5)) .or. any(d%y .ne. 21)) call abort\n+end"}, {"sha": "258b6722000e5cd6e62406502ceedf235589ad07", "filename": "libgomp/testsuite/libgomp.fortran/udr3.f90", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr3.f90?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -0,0 +1,38 @@\n+! { dg-do run }\n+\n+!$omp declare reduction (foo : character(kind=1, len=*) &\n+!$omp & : omp_out = trim(omp_out) // omp_in) initializer (omp_priv = '')\n+!$omp declare reduction (bar : character(kind=1, len=:) &\n+!$omp & : omp_out = trim(omp_in) // omp_out) initializer (omp_priv = '')\n+!$omp declare reduction (baz : character(kind=1, len=1) &\n+!$omp & : omp_out = char (ichar (omp_out) + ichar (omp_in) &\n+!$omp & - ichar ('0'))) initializer (omp_priv = '0')\n+!$omp declare reduction (baz : character(kind=1, len=2) &\n+!$omp & : omp_out = char (ichar (omp_out(1:1)) + ichar (omp_in(1:1)) &\n+!$omp & - ichar ('0')) // char (ichar (omp_out(2:2)) + &\n+!$omp & ichar (omp_in(2:2)) - ichar ('0'))) initializer (omp_priv = '00')\n+  character(kind=1, len=64) :: c, d\n+  character(kind = 1, len=1) :: e\n+  character(kind = 1, len=1+1) :: f\n+  integer :: i\n+  c = ''\n+  d = ''\n+  e = '0'\n+  f = '00'\n+!$omp parallel do reduction (foo : c) reduction (bar : d) &\n+!$omp & reduction (baz : e, f)\n+  do i = 1, 64\n+    c = trim(c) // char (ichar ('0') + i)\n+    d = char (ichar ('0') + i) // d\n+    e = char (ichar (e) + mod (i, 3))\n+    f = char (ichar (f(1:1)) + mod (i, 2)) &\n+&\t// char (ichar (f(2:2)) + mod (i, 3))\n+  end do\n+  do i = 1, 64\n+    if (index (c, char (ichar ('0') + i)) .eq. 0) call abort\n+    if (index (d, char (ichar ('0') + i)) .eq. 0) call abort\n+  end do\n+  if (e.ne.char (ichar ('0') + 64)) call abort\n+  if (f(1:1).ne.char (ichar ('0') + 32)) call abort\n+  if (f(2:2).ne.char (ichar ('0') + 64)) call abort\n+end"}, {"sha": "50f69005e3eefb0ce27b3aea3a5a2781aaef2520", "filename": "libgomp/testsuite/libgomp.fortran/udr4.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr4.f90?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do run }\n+\n+!$omp declare reduction (foo : character(kind=1, len=*) &\n+!$omp & : omp_out = trim(omp_out) // omp_in) initializer (omp_priv = '')\n+!$omp declare reduction (bar : character(kind=1, len=:) &\n+!$omp & : omp_out = trim(omp_in) // omp_out) initializer (omp_priv = '')\n+!$omp declare reduction (baz : character(kind=1, len=1) &\n+!$omp & : omp_out = char (ichar (omp_out) + ichar (omp_in) &\n+!$omp & - ichar ('0'))) initializer (omp_priv = '0')\n+!$omp declare reduction (baz : character(kind=1, len=2) &\n+!$omp & : omp_out = char (ichar (omp_out(1:1)) + ichar (omp_in(1:1)) &\n+!$omp & - ichar ('0')) // char (ichar (omp_out(2:2)) + &\n+!$omp & ichar (omp_in(2:2)) - ichar ('0'))) initializer (omp_priv = '00')\n+  character(kind=1, len=64) :: c(-3:-2,1:1,7:8), d(2:3,-7:-5)\n+  character(kind = 1, len=1) :: e(2:4)\n+  character(kind = 1, len=1+1) :: f(8:10,9:10)\n+  integer :: i, j, k\n+  c = ''\n+  d = ''\n+  e = '0'\n+  f = '00'\n+!$omp parallel do reduction (foo : c) reduction (bar : d) &\n+!$omp & reduction (baz : e, f) private (j, k)\n+  do i = 1, 64\n+    forall (j = -3:-2, k = 7:8) &\n+      c(j,1,k) = trim(c(j,1,k)) // char (ichar ('0') + i)\n+    d = char (ichar ('0') + i) // d\n+    e = char (ichar (e) + mod (i, 3))\n+    f = char (ichar (f(:,:)(1:1)) + mod (i, 2)) &\n+&\t// char (ichar (f(:,:)(2:2)) + mod (i, 3))\n+  end do\n+  do i = 1, 64\n+    if (any (index (c, char (ichar ('0') + i)) .eq. 0)) call abort\n+    if (any (index (d, char (ichar ('0') + i)) .eq. 0)) call abort\n+  end do\n+  if (any (e.ne.char (ichar ('0') + 64))) call abort\n+  if (any (f(:,:)(1:1).ne.char (ichar ('0') + 32))) call abort\n+  if (any (f(:,:)(2:2).ne.char (ichar ('0') + 64))) call abort\n+end"}, {"sha": "6dae9b9b81642e810571ff9dc26942940582ccd1", "filename": "libgomp/testsuite/libgomp.fortran/udr5.f90", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr5.f90?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -0,0 +1,57 @@\n+! { dg-do run }\n+\n+module m\n+  interface operator(.add.)\n+    module procedure do_add\n+  end interface\n+  type dt\n+    real :: r = 0.0\n+  end type\n+contains\n+  function do_add(x, y)\n+    type (dt), intent (in) :: x, y\n+    type (dt) :: do_add\n+    do_add%r = x%r + y%r\n+  end function\n+  subroutine dp_add(x, y)\n+    double precision :: x, y\n+    x = x + y\n+  end subroutine\n+  subroutine dp_init(x)\n+    double precision :: x\n+    x = 0.0\n+  end subroutine\n+end module\n+\n+program udr5\n+  use m, only : operator(.add.), dt, dp_add, dp_init\n+  type(dt) :: xdt, one\n+  real :: r\n+  integer (kind = 4) :: i4\n+  integer (kind = 8) :: i8\n+  real (kind = 4) :: r4\n+  double precision :: dp\n+!$omp declare reduction(.add.:dt:omp_out=omp_out.add.omp_in)\n+!$omp declare reduction(foo:integer(4),integer(kind=8),real (kind = 4) &\n+!$omp & :omp_out = omp_out + omp_in) initializer (omp_priv = 0)\n+!$omp declare reduction(foo:double precision:dp_add (omp_out, omp_in)) &\n+!$omp & initializer (dp_init (omp_priv))\n+\n+  one%r = 1.0\n+  r = 0.0\n+  i4 = 0\n+  i8 = 0\n+  r4 = 0.0\n+  call dp_init (dp)\n+!$omp parallel reduction(.add.: xdt) reduction(+: r) &\n+!$omp & reduction(foo: i4, i8, r4, dp)\n+  xdt = xdt.add.one\n+  r = r + 1.0\n+  i4 = i4 + 1\n+  i8 = i8 + 1\n+  r4 = r4 + 1.0\n+  call dp_add (dp, 1.0d0)\n+!$omp end parallel\n+  if (xdt%r .ne. r) call abort\n+  if (i4.ne.r.or.i8.ne.r.or.r4.ne.r.or.dp.ne.r) call abort\n+end program udr5"}, {"sha": "7fb3ee5122e4876dbae106a6119c41edf13b7fd9", "filename": "libgomp/testsuite/libgomp.fortran/udr6.f90", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr6.f90?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -0,0 +1,68 @@\n+! { dg-do run }\n+\n+module m\n+  interface operator(.add.)\n+    module procedure do_add\n+  end interface\n+  type dt\n+    real :: r = 0.0\n+  end type\n+contains\n+  function do_add(x, y)\n+    type (dt), intent (in) :: x, y\n+    type (dt) :: do_add\n+    do_add%r = x%r + y%r\n+  end function\n+  subroutine dp_add(x, y)\n+    double precision :: x, y\n+    x = x + y\n+  end subroutine\n+  subroutine dp_init(x)\n+    double precision :: x\n+    x = 0.0\n+  end subroutine\n+end module\n+\n+program udr6\n+  use m, only : operator(.add.), dt, dp_add, dp_init\n+  type(dt), allocatable :: xdt(:)\n+  type(dt) :: one\n+  real :: r\n+  integer (kind = 4), allocatable, dimension(:) :: i4\n+  integer (kind = 8), allocatable, dimension(:,:) :: i8\n+  integer :: i\n+  real (kind = 4), allocatable :: r4(:,:)\n+  double precision, allocatable :: dp(:)\n+!$omp declare reduction(.add.:dt:omp_out=omp_out.add.omp_in)\n+!$omp declare reduction(foo:integer(4),integer(kind=8),real (kind = 4) &\n+!$omp & :omp_out = omp_out + omp_in) initializer (omp_priv = 0)\n+!$omp declare reduction(foo:double precision:dp_add (omp_out, omp_in)) &\n+!$omp & initializer (dp_init (omp_priv))\n+\n+  one%r = 1.0\n+  allocate (xdt(4), i4 (3), i8(-5:-2,2:3), r4(2:5,1:1), dp(7))\n+  r = 0.0\n+  i4 = 0\n+  i8 = 0\n+  r4 = 0.0\n+  do i = 1, 7\n+    call dp_init (dp(i))\n+  end do\n+!$omp parallel reduction(.add.: xdt) reduction(+: r) &\n+!$omp & reduction(foo: i4, i8, r4, dp) private(i)\n+  do i = 1, 4\n+    xdt(i) = xdt(i).add.one\n+  end do\n+  r = r + 1.0\n+  i4 = i4 + 1\n+  i8 = i8 + 1\n+  r4 = r4 + 1.0\n+  do i = 1, 7\n+    call dp_add (dp(i), 1.0d0)\n+  end do\n+!$omp end parallel\n+  if (any (xdt%r .ne. r)) call abort\n+  if (any (i4.ne.r).or.any(i8.ne.r)) call abort\n+  if (any(r4.ne.r).or.any(dp.ne.r)) call abort\n+  deallocate (xdt, i4, i8, r4, dp)\n+end program udr6"}, {"sha": "5253dd7d086da7b51d40995ecb0e371e427849a6", "filename": "libgomp/testsuite/libgomp.fortran/udr7.f90", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr7.f90?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -0,0 +1,48 @@\n+! { dg-do run }\n+\n+program udr7\n+  implicit none\n+  interface\n+    subroutine omp_priv (x, y, z)\n+      real, intent (in) :: x\n+      real, intent (inout) :: y\n+      real, intent (in) :: z(:)\n+    end subroutine omp_priv\n+    real function omp_orig (x)\n+      real, intent (in) :: x\n+    end function omp_orig\n+  end interface\n+!$omp declare reduction (omp_priv : real : &\n+!$omp & omp_priv (omp_orig (omp_in), omp_out, (/ 1.0, 2.0, 3.0 /))) &\n+!$omp & initializer (omp_out (omp_priv, omp_in (omp_orig)))\n+  real :: x (2:4, 1:1, -2:0)\n+  integer :: i\n+  x = 0\n+!$omp parallel do reduction (omp_priv : x)\n+  do i = 1, 64\n+    x = x + i\n+  end do\n+  if (any (x /= 2080.0)) call abort\n+contains\n+  subroutine omp_out (x, y)\n+    real, intent (out) :: x\n+    real, intent (in) :: y\n+    if (y /= 4.0) call abort\n+    x = 0.0\n+  end subroutine omp_out\n+  real function omp_in (x)\n+    real, intent (in) :: x\n+    omp_in = x + 4.0\n+  end function omp_in\n+end program udr7\n+subroutine omp_priv (x, y, z)\n+  real, intent (in) :: x\n+  real, intent (inout) :: y\n+  real, intent (in) :: z(:)\n+  if (any (z .ne. (/ 1.0, 2.0, 3.0 /))) call abort\n+  y = y + (x - 4.0)\n+end subroutine omp_priv\n+real function omp_orig (x)\n+  real, intent (in) :: x\n+  omp_orig = x + 4.0\n+end function omp_orig"}, {"sha": "9ef48a5c78727bcad993f2f7277ee420546abb08", "filename": "libgomp/testsuite/libgomp.fortran/udr8.f90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr8.f90?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -0,0 +1,46 @@\n+! { dg-do run }\n+\n+module udr8m1\n+  integer, parameter :: a = 6\n+  integer :: b\n+!$omp declare reduction (foo : integer : omp_out = omp_out + omp_in)\n+!$omp declare reduction (.add. : integer : &\n+!$omp & omp_out = omp_out .add. iand (omp_in, -4)) &\n+!$omp & initializer (omp_priv = 3)\n+  interface operator (.add.)\n+    module procedure f1\n+  end interface\n+contains\n+  integer function f1 (x, y)\n+    integer, intent (in) :: x, y\n+    f1 = x + y\n+  end function f1\n+end module udr8m1\n+module udr8m2\n+  use udr8m1\n+  type dt\n+    integer :: x\n+  end type\n+!$omp declare reduction (+ : dt : omp_out = omp_out + omp_in) &\n+!$omp & initializer (omp_priv = dt (0))\n+  interface operator (+)\n+    module procedure f2\n+  end interface\n+contains\n+  type(dt) function f2 (x, y)\n+    type(dt), intent (in) :: x, y\n+    f2%x = x%x + y%x\n+  end function f2\n+end module udr8m2\n+  use udr8m2\n+  integer :: i, j\n+  type(dt) :: d\n+  j = 3\n+  d%x = 0\n+!$omp parallel do reduction (.add.: j) reduction (+ : d)\n+  do i = 1, 100\n+    j = j.add.iand (i, -4)\n+    d = d + dt(i)\n+  end do\n+  if (d%x /= 5050 .or. j /= 4903) call abort\n+end"}, {"sha": "a4fec1337c2e49d44fd71f234dc14a745831b818", "filename": "libgomp/testsuite/libgomp.fortran/udr9.f90", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fudr9.f90?ref=5f23671d3fffb58b8f1c0bfb292e3b1c66fc0f9d", "patch": "@@ -0,0 +1,65 @@\n+! { dg-do run }\n+\n+module udr9m1\n+  integer, parameter :: a = 6\n+  integer :: b\n+!$omp declare reduction (foo : integer : combiner1 (omp_out, omp_in)) &\n+!$omp & initializer (initializer1 (omp_priv, omp_orig))\n+!$omp declare reduction (.add. : integer : &\n+!$omp & combiner1 (omp_out, omp_in)) &\n+!$omp & initializer (initializer1 (omp_priv, omp_orig))\n+  interface operator (.add.)\n+    module procedure f1\n+  end interface\n+contains\n+  integer function f1 (x, y)\n+    integer, intent (in) :: x, y\n+    f1 = x + y\n+  end function f1\n+  elemental subroutine combiner1 (x, y)\n+    integer, intent (inout) :: x\n+    integer, intent (in) :: y\n+    x = x + iand (y, -4)\n+  end subroutine\n+  subroutine initializer1 (x, y)\n+    integer :: x, y\n+    if (y .ne. 3) call abort\n+    x = y\n+  end subroutine\n+end module udr9m1\n+module udr9m2\n+  use udr9m1\n+  type dt\n+    integer :: x\n+  end type\n+!$omp declare reduction (+ : dt : combiner2 (omp_in, omp_out)) &\n+!$omp & initializer (initializer2 (omp_priv))\n+  interface operator (+)\n+    module procedure f2\n+  end interface\n+contains\n+  type(dt) function f2 (x, y)\n+    type(dt), intent (in) :: x, y\n+    f2%x = x%x + y%x\n+  end function f2\n+  subroutine combiner2 (x, y)\n+    type(dt) :: x, y\n+    y = y + x\n+  end subroutine combiner2\n+  subroutine initializer2 (x)\n+    type(dt), intent(out) :: x\n+    x%x = 0\n+  end subroutine initializer2\n+end module udr9m2\n+  use udr9m2\n+  integer :: i, j\n+  type(dt) :: d\n+  j = 3\n+  d%x = 0\n+!$omp parallel do reduction (.add.: j) reduction (+ : d)\n+  do i = 1, 100\n+    j = j.add.iand (i, -4)\n+    d = d + dt(i)\n+  end do\n+  if (d%x /= 5050 .or. j /= 4903) call abort\n+end"}]}