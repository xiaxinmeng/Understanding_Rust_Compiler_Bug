{"sha": "5affca016a4adb37602d69049ac81ddd01cba12c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFmZmNhMDE2YTRhZGIzNzYwMmQ2OTA0OWFjODFkZGQwMWNiYTEyYw==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2004-08-25T12:31:01Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2004-08-25T12:31:01Z"}, "message": "cse.c (cse_around_loop, [...]): Remove.\n\n\t* cse.c (cse_around_loop, cse_check_loop_start,\n\tcse_set_around_loop): Remove.\n\t(cse_basic_block): Remove the around_loop argument.\n\t(cse_end_of_basic_block): Remove the after_loop argument.\n\t(cse_main): Likewise.\n\t* rtl.h (cse_main): Update prototype.\n\t* passes.c (rest_of_handle_cse, rest_of_handle_cse2,\n\trest_of_handle_gcse): Update cse_main calls.\n\nFrom-SVN: r86546", "tree": {"sha": "b28bab4d93887fff2c55374a244e786bbfefd510", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b28bab4d93887fff2c55374a244e786bbfefd510"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5affca016a4adb37602d69049ac81ddd01cba12c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5affca016a4adb37602d69049ac81ddd01cba12c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5affca016a4adb37602d69049ac81ddd01cba12c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5affca016a4adb37602d69049ac81ddd01cba12c/comments", "author": null, "committer": null, "parents": [{"sha": "15793d0cdb54a8e5239dfaa4527401223d317c85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15793d0cdb54a8e5239dfaa4527401223d317c85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15793d0cdb54a8e5239dfaa4527401223d317c85"}], "stats": {"total": 308, "additions": 25, "deletions": 283}, "files": [{"sha": "b61c3f9a12d8d5c29f9fe26fdfed836dde11f319", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5affca016a4adb37602d69049ac81ddd01cba12c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5affca016a4adb37602d69049ac81ddd01cba12c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5affca016a4adb37602d69049ac81ddd01cba12c", "patch": "@@ -1,3 +1,14 @@\n+2004-08-25  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* cse.c (cse_around_loop, cse_check_loop_start,\n+\tcse_set_around_loop): Remove.\n+\t(cse_basic_block): Remove the around_loop argument.\n+\t(cse_end_of_basic_block): Remove the after_loop argument.\n+\t(cse_main): Likewise.\n+\t* rtl.h (cse_main): Update prototype.\n+\t* passes.c (rest_of_handle_cse, rest_of_handle_cse2,\n+\trest_of_handle_gcse): Update cse_main calls.\n+\n 2004-08-25  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* tree.h  (build_int_cst): New, sign extended constant."}, {"sha": "bf025824cb31142511d475ab56a8ed8111230c94", "filename": "gcc/cse.c", "status": "modified", "additions": 9, "deletions": 278, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5affca016a4adb37602d69049ac81ddd01cba12c/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5affca016a4adb37602d69049ac81ddd01cba12c/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=5affca016a4adb37602d69049ac81ddd01cba12c", "patch": "@@ -564,12 +564,6 @@ static int n_elements_made;\n \n static int max_elements_made;\n \n-/* Surviving equivalence class when two equivalence classes are merged\n-   by recording the effects of a jump in the last insn.  Zero if the\n-   last insn was not a conditional jump.  */\n-\n-static struct table_elt *last_jump_equiv_class;\n-\n /* Set to the cost of a constant pool reference if one was found for a\n    symbolic constant.  If this was found, it means we should try to\n    convert constants into constant pool entries if they don't fit in\n@@ -648,16 +642,13 @@ static void record_jump_cond (enum rtx_code, enum machine_mode, rtx, rtx,\n \t\t\t      int);\n static void cse_insn (rtx, rtx);\n static void cse_end_of_basic_block (rtx, struct cse_basic_block_data *,\n-\t\t\t\t    int, int, int);\n+\t\t\t\t    int, int);\n static int addr_affects_sp_p (rtx);\n static void invalidate_from_clobbers (rtx);\n static rtx cse_process_notes (rtx, rtx);\n-static void cse_around_loop (rtx);\n static void invalidate_skipped_set (rtx, rtx, void *);\n static void invalidate_skipped_block (rtx);\n-static void cse_check_loop_start (rtx, rtx, void *);\n-static void cse_set_around_loop (rtx, rtx, rtx);\n-static rtx cse_basic_block (rtx, rtx, struct branch_path *, int);\n+static rtx cse_basic_block (rtx, rtx, struct branch_path *);\n static void count_reg_usage (rtx, int *, int);\n static int check_for_label_ref (rtx *, void *);\n extern void dump_class (struct table_elt*);\n@@ -4540,7 +4531,6 @@ record_jump_cond (enum rtx_code code, enum machine_mode mode, rtx op0,\n     }\n \n   merge_equiv_classes (op0_elt, op1_elt);\n-  last_jump_equiv_class = op0_elt;\n }\n \f\n /* CSE processing for one instruction.\n@@ -6172,7 +6162,6 @@ cse_insn (rtx insn, rtx libcall_insn)\n   /* If this is a conditional jump insn, record any known equivalences due to\n      the condition being tested.  */\n \n-  last_jump_equiv_class = 0;\n   if (JUMP_P (insn)\n       && n_sets == 1 && GET_CODE (x) == SET\n       && GET_CODE (SET_SRC (x)) == IF_THEN_ELSE)\n@@ -6368,88 +6357,6 @@ cse_process_notes (rtx x, rtx object)\n   return x;\n }\n \f\n-/* Find common subexpressions between the end test of a loop and the beginning\n-   of the loop.  LOOP_START is the CODE_LABEL at the start of a loop.\n-\n-   Often we have a loop where an expression in the exit test is used\n-   in the body of the loop.  For example \"while (*p) *q++ = *p++;\".\n-   Because of the way we duplicate the loop exit test in front of the loop,\n-   however, we don't detect that common subexpression.  This will be caught\n-   when global cse is implemented, but this is a quite common case.\n-\n-   This function handles the most common cases of these common expressions.\n-   It is called after we have processed the basic block ending with the\n-   NOTE_INSN_LOOP_END note that ends a loop and the previous JUMP_INSN\n-   jumps to a label used only once.  */\n-\n-static void\n-cse_around_loop (rtx loop_start)\n-{\n-  rtx insn;\n-  int i;\n-  struct table_elt *p;\n-\n-  /* If the jump at the end of the loop doesn't go to the start, we don't\n-     do anything.  */\n-  for (insn = PREV_INSN (loop_start);\n-       insn && (NOTE_P (insn) && NOTE_LINE_NUMBER (insn) >= 0);\n-       insn = PREV_INSN (insn))\n-    ;\n-\n-  if (insn == 0\n-      || !NOTE_P (insn)\n-      || NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_BEG)\n-    return;\n-\n-  /* If the last insn of the loop (the end test) was an NE comparison,\n-     we will interpret it as an EQ comparison, since we fell through\n-     the loop.  Any equivalences resulting from that comparison are\n-     therefore not valid and must be invalidated.  */\n-  if (last_jump_equiv_class)\n-    for (p = last_jump_equiv_class->first_same_value; p;\n-\t p = p->next_same_value)\n-      {\n-\tif (MEM_P (p->exp) || REG_P (p->exp)\n-\t    || (GET_CODE (p->exp) == SUBREG\n-\t\t&& REG_P (SUBREG_REG (p->exp))))\n-\t  invalidate (p->exp, VOIDmode);\n-\telse if (GET_CODE (p->exp) == STRICT_LOW_PART\n-\t\t || GET_CODE (p->exp) == ZERO_EXTRACT)\n-\t  invalidate (XEXP (p->exp, 0), GET_MODE (p->exp));\n-      }\n-\n-  /* Process insns starting after LOOP_START until we hit a CALL_INSN or\n-     a CODE_LABEL (we could handle a CALL_INSN, but it isn't worth it).\n-\n-     The only thing we do with SET_DEST is invalidate entries, so we\n-     can safely process each SET in order.  It is slightly less efficient\n-     to do so, but we only want to handle the most common cases.\n-\n-     The gen_move_insn call in cse_set_around_loop may create new pseudos.\n-     These pseudos won't have valid entries in any of the tables indexed\n-     by register number, such as reg_qty.  We avoid out-of-range array\n-     accesses by not processing any instructions created after cse started.  */\n-\n-  for (insn = NEXT_INSN (loop_start);\n-       !CALL_P (insn) && !LABEL_P (insn)\n-       && INSN_UID (insn) < max_insn_uid\n-       && ! (NOTE_P (insn)\n-\t     && NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END);\n-       insn = NEXT_INSN (insn))\n-    {\n-      if (INSN_P (insn)\n-\t  && (GET_CODE (PATTERN (insn)) == SET\n-\t      || GET_CODE (PATTERN (insn)) == CLOBBER))\n-\tcse_set_around_loop (PATTERN (insn), insn, loop_start);\n-      else if (INSN_P (insn) && GET_CODE (PATTERN (insn)) == PARALLEL)\n-\tfor (i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n-\t  if (GET_CODE (XVECEXP (PATTERN (insn), 0, i)) == SET\n-\t      || GET_CODE (XVECEXP (PATTERN (insn), 0, i)) == CLOBBER)\n-\t    cse_set_around_loop (XVECEXP (PATTERN (insn), 0, i), insn,\n-\t\t\t\t loop_start);\n-    }\n-}\n-\f\n /* Process one SET of an insn that was skipped.  We ignore CLOBBERs\n    since they are done elsewhere.  This function is called via note_stores.  */\n \n@@ -6510,146 +6417,6 @@ invalidate_skipped_block (rtx start)\n     }\n }\n \f\n-/* If modifying X will modify the value in *DATA (which is really an\n-   `rtx *'), indicate that fact by setting the pointed to value to\n-   NULL_RTX.  */\n-\n-static void\n-cse_check_loop_start (rtx x, rtx set ATTRIBUTE_UNUSED, void *data)\n-{\n-  rtx *cse_check_loop_start_value = (rtx *) data;\n-\n-  if (*cse_check_loop_start_value == NULL_RTX\n-      || GET_CODE (x) == CC0 || GET_CODE (x) == PC)\n-    return;\n-\n-  if ((MEM_P (x) && MEM_P (*cse_check_loop_start_value))\n-      || reg_overlap_mentioned_p (x, *cse_check_loop_start_value))\n-    *cse_check_loop_start_value = NULL_RTX;\n-}\n-\n-/* X is a SET or CLOBBER contained in INSN that was found near the start of\n-   a loop that starts with the label at LOOP_START.\n-\n-   If X is a SET, we see if its SET_SRC is currently in our hash table.\n-   If so, we see if it has a value equal to some register used only in the\n-   loop exit code (as marked by jump.c).\n-\n-   If those two conditions are true, we search backwards from the start of\n-   the loop to see if that same value was loaded into a register that still\n-   retains its value at the start of the loop.\n-\n-   If so, we insert an insn after the load to copy the destination of that\n-   load into the equivalent register and (try to) replace our SET_SRC with that\n-   register.\n-\n-   In any event, we invalidate whatever this SET or CLOBBER modifies.  */\n-\n-static void\n-cse_set_around_loop (rtx x, rtx insn, rtx loop_start)\n-{\n-  struct table_elt *src_elt;\n-\n-  /* If this is a SET, see if we can replace SET_SRC, but ignore SETs that\n-     are setting PC or CC0 or whose SET_SRC is already a register.  */\n-  if (GET_CODE (x) == SET\n-      && GET_CODE (SET_DEST (x)) != PC && GET_CODE (SET_DEST (x)) != CC0\n-      && !REG_P (SET_SRC (x)))\n-    {\n-      src_elt = lookup (SET_SRC (x),\n-\t\t\tHASH (SET_SRC (x), GET_MODE (SET_DEST (x))),\n-\t\t\tGET_MODE (SET_DEST (x)));\n-\n-      if (src_elt)\n-\tfor (src_elt = src_elt->first_same_value; src_elt;\n-\t     src_elt = src_elt->next_same_value)\n-\t  if (REG_P (src_elt->exp) && REG_LOOP_TEST_P (src_elt->exp)\n-\t      && COST (src_elt->exp) < COST (SET_SRC (x)))\n-\t    {\n-\t      rtx p, set;\n-\n-\t      /* Look for an insn in front of LOOP_START that sets\n-\t\t something in the desired mode to SET_SRC (x) before we hit\n-\t\t a label or CALL_INSN.  */\n-\n-\t      for (p = prev_nonnote_insn (loop_start);\n-\t\t   p && !CALL_P (p)\n-\t\t   && !LABEL_P (p);\n-\t\t   p = prev_nonnote_insn  (p))\n-\t\tif ((set = single_set (p)) != 0\n-\t\t    && REG_P (SET_DEST (set))\n-\t\t    && GET_MODE (SET_DEST (set)) == src_elt->mode\n-\t\t    && rtx_equal_p (SET_SRC (set), SET_SRC (x)))\n-\t\t  {\n-\t\t    /* We now have to ensure that nothing between P\n-\t\t       and LOOP_START modified anything referenced in\n-\t\t       SET_SRC (x).  We know that nothing within the loop\n-\t\t       can modify it, or we would have invalidated it in\n-\t\t       the hash table.  */\n-\t\t    rtx q;\n-\t\t    rtx cse_check_loop_start_value = SET_SRC (x);\n-\t\t    for (q = p; q != loop_start; q = NEXT_INSN (q))\n-\t\t      if (INSN_P (q))\n-\t\t\tnote_stores (PATTERN (q),\n-\t\t\t\t     cse_check_loop_start,\n-\t\t\t\t     &cse_check_loop_start_value);\n-\n-\t\t    /* If nothing was changed and we can replace our\n-\t\t       SET_SRC, add an insn after P to copy its destination\n-\t\t       to what we will be replacing SET_SRC with.  */\n-\t\t    if (cse_check_loop_start_value\n-\t\t\t&& single_set (p)\n-\t\t\t&& !can_throw_internal (insn)\n-\t\t\t&& validate_change (insn, &SET_SRC (x),\n-\t\t\t\t\t    src_elt->exp, 0))\n-\t\t      {\n-\t\t\t/* If this creates new pseudos, this is unsafe,\n-\t\t\t   because the regno of new pseudo is unsuitable\n-\t\t\t   to index into reg_qty when cse_insn processes\n-\t\t\t   the new insn.  Therefore, if a new pseudo was\n-\t\t\t   created, discard this optimization.  */\n-\t\t\tint nregs = max_reg_num ();\n-\t\t\trtx move\n-\t\t\t  = gen_move_insn (src_elt->exp, SET_DEST (set));\n-\t\t\tif (nregs != max_reg_num ())\n-\t\t\t  {\n-\t\t\t    if (! validate_change (insn, &SET_SRC (x),\n-\t\t\t\t\t\t   SET_SRC (set), 0))\n-\t\t\t      abort ();\n-\t\t\t  }\n-\t\t\telse\n-\t\t\t  {\n-\t\t\t    if (CONSTANT_P (SET_SRC (set))\n-\t\t\t\t&& ! find_reg_equal_equiv_note (insn))\n-\t\t\t      set_unique_reg_note (insn, REG_EQUAL,\n-\t\t\t\t\t\t   SET_SRC (set));\n-\t\t\t    if (control_flow_insn_p (p))\n-\t\t\t      /* p can cause a control flow transfer so it\n-\t\t\t\t is the last insn of a basic block.  We can't\n-\t\t\t\t therefore use emit_insn_after.  */\n-\t\t\t      emit_insn_before (move, next_nonnote_insn (p));\n-\t\t\t    else\n-\t\t\t      emit_insn_after (move, p);\n-\t\t\t  }\n-\t\t      }\n-\t\t    break;\n-\t\t  }\n-\t    }\n-    }\n-\n-  /* Deal with the destination of X affecting the stack pointer.  */\n-  addr_affects_sp_p (SET_DEST (x));\n-\n-  /* See comment on similar code in cse_insn for explanation of these\n-     tests.  */\n-  if (REG_P (SET_DEST (x)) || GET_CODE (SET_DEST (x)) == SUBREG\n-      || MEM_P (SET_DEST (x)))\n-    invalidate (SET_DEST (x), VOIDmode);\n-  else if (GET_CODE (SET_DEST (x)) == STRICT_LOW_PART\n-\t   || GET_CODE (SET_DEST (x)) == ZERO_EXTRACT)\n-    invalidate (XEXP (SET_DEST (x), 0), GET_MODE (SET_DEST (x)));\n-}\n-\f\n /* Find the end of INSN's basic block and return its range,\n    the total number of SETs in all the insns of the block, the last insn of the\n    block, and the branch path.\n@@ -6666,7 +6433,7 @@ cse_set_around_loop (rtx x, rtx insn, rtx loop_start)\n \n static void\n cse_end_of_basic_block (rtx insn, struct cse_basic_block_data *data,\n-\t\t\tint follow_jumps, int after_loop, int skip_blocks)\n+\t\t\tint follow_jumps, int skip_blocks)\n {\n   rtx p = insn, q;\n   int nsets = 0;\n@@ -6704,23 +6471,6 @@ cse_end_of_basic_block (rtx insn, struct cse_basic_block_data *data,\n   /* Scan to end of this basic block.  */\n   while (p && !LABEL_P (p))\n     {\n-      /* Don't cse out the end of a loop.  This makes a difference\n-\t only for the unusual loops that always execute at least once;\n-\t all other loops have labels there so we will stop in any case.\n-\t Cse'ing out the end of the loop is dangerous because it\n-\t might cause an invariant expression inside the loop\n-\t to be reused after the end of the loop.  This would make it\n-\t hard to move the expression out of the loop in loop.c,\n-\t especially if it is one of several equivalent expressions\n-\t and loop.c would like to eliminate it.\n-\n-\t If we are running after loop.c has finished, we can ignore\n-\t the NOTE_INSN_LOOP_END.  */\n-\n-      if (! after_loop && NOTE_P (p)\n-\t  && NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_END)\n-\tbreak;\n-\n       /* Don't cse over a call to setjmp; on some machines (eg VAX)\n \t the regs restored by the longjmp come from\n \t a later time than the setjmp.  */\n@@ -6877,14 +6627,11 @@ cse_end_of_basic_block (rtx insn, struct cse_basic_block_data *data,\n    F is the first instruction.\n    NREGS is one plus the highest pseudo-reg number used in the instruction.\n \n-   AFTER_LOOP is 1 if this is the cse call done after loop optimization\n-   (only if -frerun-cse-after-loop).\n-\n    Returns 1 if jump_optimize should be redone due to simplifications\n    in conditional jump instructions.  */\n \n int\n-cse_main (rtx f, int nregs, int after_loop, FILE *file)\n+cse_main (rtx f, int nregs, FILE *file)\n {\n   struct cse_basic_block_data val;\n   rtx insn = f;\n@@ -6950,7 +6697,7 @@ cse_main (rtx f, int nregs, int after_loop, FILE *file)\n   while (insn)\n     {\n       cse_altered = 0;\n-      cse_end_of_basic_block (insn, &val, flag_cse_follow_jumps, after_loop,\n+      cse_end_of_basic_block (insn, &val, flag_cse_follow_jumps,\n \t\t\t      flag_cse_skip_blocks);\n \n       /* If this basic block was already processed or has no sets, skip it.  */\n@@ -6982,7 +6729,7 @@ cse_main (rtx f, int nregs, int after_loop, FILE *file)\n          (see `cse_end_of_basic_block'), we reprocess the code from the start.\n          Otherwise, we start after this basic block.  */\n       if (val.path_size > 0)\n-\tcse_basic_block (insn, val.last, val.path, 0);\n+\tcse_basic_block (insn, val.last, val.path);\n       else\n \t{\n \t  int old_cse_jumps_altered = cse_jumps_altered;\n@@ -6992,7 +6739,7 @@ cse_main (rtx f, int nregs, int after_loop, FILE *file)\n \t     jump, we want to reprocess the block, since it will give\n \t     us a new branch path to investigate.  */\n \t  cse_jumps_altered = 0;\n-\t  temp = cse_basic_block (insn, val.last, val.path, ! after_loop);\n+\t  temp = cse_basic_block (insn, val.last, val.path);\n \t  if (cse_jumps_altered == 0\n \t      || (flag_cse_follow_jumps == 0 && flag_cse_skip_blocks == 0))\n \t    insn = temp;\n@@ -7032,8 +6779,7 @@ cse_main (rtx f, int nregs, int after_loop, FILE *file)\n    block and this CSE pass is before loop.c.  */\n \n static rtx\n-cse_basic_block (rtx from, rtx to, struct branch_path *next_branch,\n-\t\t int around_loop)\n+cse_basic_block (rtx from, rtx to, struct branch_path *next_branch)\n {\n   rtx insn;\n   int to_usage = 0;\n@@ -7210,7 +6956,7 @@ cse_basic_block (rtx from, rtx to, struct branch_path *next_branch,\n \t  val.path_size = 0;\n \t  val.path = xmalloc (sizeof (struct branch_path)\n \t\t\t      * PARAM_VALUE (PARAM_MAX_CSE_PATH_LENGTH));\n-\t  cse_end_of_basic_block (insn, &val, 0, 0, 0);\n+\t  cse_end_of_basic_block (insn, &val, 0, 0);\n \t  free (val.path);\n \n \t  /* If the tables we allocated have enough space left\n@@ -7236,21 +6982,6 @@ cse_basic_block (rtx from, rtx to, struct branch_path *next_branch,\n   if (next_qty > max_qty)\n     abort ();\n \n-  /* If we are running before loop.c, we stopped on a NOTE_INSN_LOOP_END, and\n-     the previous insn is the only insn that branches to the head of a loop,\n-     we can cse into the loop.  Don't do this if we changed the jump\n-     structure of a loop unless we aren't going to be following jumps.  */\n-\n-  insn = prev_nonnote_insn (to);\n-  if ((cse_jumps_altered == 0\n-       || (flag_cse_follow_jumps == 0 && flag_cse_skip_blocks == 0))\n-      && around_loop && to != 0\n-      && NOTE_P (to) && NOTE_LINE_NUMBER (to) == NOTE_INSN_LOOP_END\n-      && JUMP_P (insn)\n-      && JUMP_LABEL (insn) != 0\n-      && LABEL_NUSES (JUMP_LABEL (insn)) == 1)\n-    cse_around_loop (JUMP_LABEL (insn));\n-\n   free (qty_table + max_reg);\n \n   return to ? NEXT_INSN (to) : 0;"}, {"sha": "7f0aeb6d138b5e951b3ea7f0274493497afe5669", "filename": "gcc/passes.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5affca016a4adb37602d69049ac81ddd01cba12c/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5affca016a4adb37602d69049ac81ddd01cba12c/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=5affca016a4adb37602d69049ac81ddd01cba12c", "patch": "@@ -1146,7 +1146,7 @@ rest_of_handle_cse (void)\n \n   reg_scan (get_insns (), max_reg_num (), 1);\n \n-  tem = cse_main (get_insns (), max_reg_num (), 0, dump_file);\n+  tem = cse_main (get_insns (), max_reg_num (), dump_file);\n   if (tem)\n     rebuild_jump_labels (get_insns ());\n   if (purge_all_dead_edges (0))\n@@ -1178,7 +1178,7 @@ rest_of_handle_cse2 (void)\n   if (dump_file)\n     dump_flow_info (dump_file);\n   /* CFG is no longer maintained up-to-date.  */\n-  tem = cse_main (get_insns (), max_reg_num (), 1, dump_file);\n+  tem = cse_main (get_insns (), max_reg_num (), dump_file);\n \n   /* Run a pass to eliminate duplicated assignments to condition code\n      registers.  We have to run this after bypass_jumps, because it\n@@ -1227,7 +1227,7 @@ rest_of_handle_gcse (void)\n     {\n       timevar_push (TV_CSE);\n       reg_scan (get_insns (), max_reg_num (), 1);\n-      tem2 = cse_main (get_insns (), max_reg_num (), 0, dump_file);\n+      tem2 = cse_main (get_insns (), max_reg_num (), dump_file);\n       purge_all_dead_edges (0);\n       delete_trivially_dead_insns (get_insns (), max_reg_num ());\n       timevar_pop (TV_CSE);\n@@ -1248,7 +1248,7 @@ rest_of_handle_gcse (void)\n \t{\n \t  timevar_push (TV_CSE);\n \t  reg_scan (get_insns (), max_reg_num (), 1);\n-\t  tem2 = cse_main (get_insns (), max_reg_num (), 0, dump_file);\n+\t  tem2 = cse_main (get_insns (), max_reg_num (), dump_file);\n \t  purge_all_dead_edges (0);\n \t  delete_trivially_dead_insns (get_insns (), max_reg_num ());\n \t  timevar_pop (TV_CSE);"}, {"sha": "99cb3cf7aa99860cc47a0d46e5d89cc49997f79b", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5affca016a4adb37602d69049ac81ddd01cba12c/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5affca016a4adb37602d69049ac81ddd01cba12c/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=5affca016a4adb37602d69049ac81ddd01cba12c", "patch": "@@ -1914,7 +1914,7 @@ extern int rtx_to_tree_code (enum rtx_code);\n \n /* In cse.c */\n extern int delete_trivially_dead_insns (rtx, int);\n-extern int cse_main (rtx, int, int, FILE *);\n+extern int cse_main (rtx, int, FILE *);\n extern void cse_condition_code_reg (void);\n extern int exp_equiv_p (rtx, rtx, int, bool);\n extern unsigned hash_rtx (rtx x, enum machine_mode, int *, int *, bool);"}]}