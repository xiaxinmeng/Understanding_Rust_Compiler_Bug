{"sha": "8088a33df5f62fd6416fb8cb158b791e639aa707", "node_id": "C_kwDOANBUbNoAKDgwODhhMzNkZjVmNjJmZDY0MTZmYjhjYjE1OGI3OTFlNjM5YWE3MDc", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-09-25T21:18:53Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-09-30T13:07:19Z"}, "message": "libphobos: Select the appropriate exception handler in getClassInfo\n\nThis is analogous to __gdc_personality, which ignores in-flight\nexceptions that we haven't collided with yet.\n\nlibphobos/ChangeLog:\n\n\t* libdruntime/gcc/deh.d (ExceptionHeader.getClassInfo): Move to...\n\t(getClassInfo): ...here as free function.  Add lsda parameter.\n\t(scanLSDA): Pass lsda to actionTableLookup.\n\t(actionTableLookup): Add lsda parameter, pass to getClassInfo.\n\t(__gdc_personality): Remove currentCfa variable.", "tree": {"sha": "5fb9d1c8bd0e552010f86971d057b92cac056014", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5fb9d1c8bd0e552010f86971d057b92cac056014"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8088a33df5f62fd6416fb8cb158b791e639aa707", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8088a33df5f62fd6416fb8cb158b791e639aa707", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8088a33df5f62fd6416fb8cb158b791e639aa707", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8088a33df5f62fd6416fb8cb158b791e639aa707/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed3ec7343b7d104a3285336fbfc1e4719719f9b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed3ec7343b7d104a3285336fbfc1e4719719f9b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed3ec7343b7d104a3285336fbfc1e4719719f9b6"}], "stats": {"total": 74, "additions": 44, "deletions": 30}, "files": [{"sha": "ba57fed38dcb8e28d69ff2b310c74075eef768e8", "filename": "libphobos/libdruntime/gcc/deh.d", "status": "modified", "additions": 44, "deletions": 30, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8088a33df5f62fd6416fb8cb158b791e639aa707/libphobos%2Flibdruntime%2Fgcc%2Fdeh.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8088a33df5f62fd6416fb8cb158b791e639aa707/libphobos%2Flibdruntime%2Fgcc%2Fdeh.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fgcc%2Fdeh.d?ref=8088a33df5f62fd6416fb8cb158b791e639aa707", "patch": "@@ -279,26 +279,6 @@ struct ExceptionHeader\n         }\n     }\n \n-    /**\n-     * Look at the chain of inflight exceptions and pick the class type that'll\n-     * be looked for in catch clauses.\n-     */\n-    static ClassInfo getClassInfo(_Unwind_Exception* unwindHeader) @nogc\n-    {\n-        ExceptionHeader* eh = toExceptionHeader(unwindHeader);\n-        // The first thrown Exception at the top of the stack takes precedence\n-        // over others that are inflight, unless an Error was thrown, in which\n-        // case, we search for error handlers instead.\n-        Throwable ehobject = eh.object;\n-        for (ExceptionHeader* ehn = eh.next; ehn; ehn = ehn.next)\n-        {\n-            Error e = cast(Error)ehobject;\n-            if (e is null || (cast(Error)ehn.object) !is null)\n-                ehobject = ehn.object;\n-        }\n-        return ehobject.classinfo;\n-    }\n-\n     /**\n      * Convert from pointer to unwindHeader to pointer to ExceptionHeader\n      * that it is embedded inside of.\n@@ -666,7 +646,7 @@ _Unwind_Reason_Code scanLSDA(const(ubyte)* lsda, _Unwind_Exception_Class excepti\n     {\n         // Otherwise we have a catch handler or exception specification.\n         handler = actionTableLookup(actions, unwindHeader, actionRecord,\n-                                    exceptionClass, TTypeBase,\n+                                    lsda, exceptionClass, TTypeBase,\n                                     TType, TTypeEncoding,\n                                     saw_handler, saw_cleanup);\n     }\n@@ -694,15 +674,16 @@ _Unwind_Reason_Code scanLSDA(const(ubyte)* lsda, _Unwind_Exception_Class excepti\n  * Look up and return the handler index of the classType in Action Table.\n  */\n int actionTableLookup(_Unwind_Action actions, _Unwind_Exception* unwindHeader,\n-                      const(ubyte)* actionRecord, _Unwind_Exception_Class exceptionClass,\n+                      const(ubyte)* actionRecord, const(ubyte)* lsda,\n+                      _Unwind_Exception_Class exceptionClass,\n                       _Unwind_Ptr TTypeBase, const(ubyte)* TType,\n                       ubyte TTypeEncoding,\n                       out bool saw_handler, out bool saw_cleanup)\n {\n     ClassInfo thrownType;\n     if (isGdcExceptionClass(exceptionClass))\n     {\n-        thrownType = ExceptionHeader.getClassInfo(unwindHeader);\n+        thrownType = getClassInfo(unwindHeader, lsda);\n     }\n \n     while (1)\n@@ -778,6 +759,41 @@ int actionTableLookup(_Unwind_Action actions, _Unwind_Exception* unwindHeader,\n     return 0;\n }\n \n+/**\n+ * Look at the chain of inflight exceptions and pick the class type that'll\n+ * be looked for in catch clauses.\n+ */\n+ClassInfo getClassInfo(_Unwind_Exception* unwindHeader,\n+                       const(ubyte)* currentLsd) @nogc\n+{\n+    ExceptionHeader* eh = ExceptionHeader.toExceptionHeader(unwindHeader);\n+    // The first thrown Exception at the top of the stack takes precedence\n+    // over others that are inflight, unless an Error was thrown, in which\n+    // case, we search for error handlers instead.\n+    Throwable ehobject = eh.object;\n+    for (ExceptionHeader* ehn = eh.next; ehn; ehn = ehn.next)\n+    {\n+        const(ubyte)* nextLsd = void;\n+        _Unwind_Ptr nextLandingPad = void;\n+        _Unwind_Word nextCfa = void;\n+        int nextHandler = void;\n+\n+        ExceptionHeader.restore(&ehn.unwindHeader, nextHandler, nextLsd, nextLandingPad, nextCfa);\n+\n+        // Don't combine when the exceptions are from different functions.\n+        if (currentLsd != nextLsd)\n+            break;\n+\n+        Error e = cast(Error)ehobject;\n+        if (e is null || (cast(Error)ehn.object) !is null)\n+        {\n+            currentLsd = nextLsd;\n+            ehobject = ehn.object;\n+        }\n+    }\n+    return ehobject.classinfo;\n+}\n+\n /**\n  * Called when the personality function has found neither a cleanup or handler.\n  * To support ARM EABI personality routines, that must also unwind the stack.\n@@ -934,16 +950,15 @@ private _Unwind_Reason_Code __gdc_personality(_Unwind_Action actions,\n         // current object onto the end of the prevous object.\n         ExceptionHeader* eh = ExceptionHeader.toExceptionHeader(unwindHeader);\n         auto currentLsd = lsda;\n-        auto currentCfa = cfa;\n         bool bypassed = false;\n \n         while (eh.next)\n         {\n             ExceptionHeader* ehn = eh.next;\n-            const(ubyte)* nextLsd;\n-            _Unwind_Ptr nextLandingPad;\n-            _Unwind_Word nextCfa;\n-            int nextHandler;\n+            const(ubyte)* nextLsd = void;\n+            _Unwind_Ptr nextLandingPad = void;\n+            _Unwind_Word nextCfa = void;\n+            int nextHandler = void;\n \n             ExceptionHeader.restore(&ehn.unwindHeader, nextHandler, nextLsd, nextLandingPad, nextCfa);\n \n@@ -952,14 +967,13 @@ private _Unwind_Reason_Code __gdc_personality(_Unwind_Action actions,\n             {\n                 // We found an Error, bypass the exception chain.\n                 currentLsd = nextLsd;\n-                currentCfa = nextCfa;\n                 eh = ehn;\n                 bypassed = true;\n                 continue;\n             }\n \n             // Don't combine when the exceptions are from different functions.\n-            if (currentLsd != nextLsd && currentCfa != nextCfa)\n+            if (currentLsd != nextLsd)\n                 break;\n \n             // Add our object onto the end of the existing chain."}]}