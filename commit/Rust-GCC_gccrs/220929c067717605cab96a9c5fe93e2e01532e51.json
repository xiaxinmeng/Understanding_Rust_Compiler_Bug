{"sha": "220929c067717605cab96a9c5fe93e2e01532e51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjIwOTI5YzA2NzcxNzYwNWNhYjk2YTljNWZlOTNlMmUwMTUzMmU1MQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2020-11-02T18:06:46Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2020-11-03T15:17:39Z"}, "message": "Tweaks to ranger cache\n\nAdd some bounds checking to ssa_block_ranges, and privatize the\nranges block cache and global cache, adding API points for accessing them.\n\n\t* gimple-range-cache.h (block_range_cache): Add new entry point.\n\t(ranger_cache): Privatize global abnd block cache members.\n\t* gimple-range-cache.cc (ssa_block_ranges::set_bb_range): Add bounds\n\tcheck.\n\t(ssa_block_ranges::set_bb_varying): Ditto.\n\t(ssa_block_ranges::get_bb_range): Ditto.\n\t(ssa_block_ranges::bb_range_p): Ditto.\n\t(block_range_cache::get_block_ranges): Fix formatting.\n\t(block_range_cache::query_block_ranges): New.\n\t(block_range_cache::get_bb_range): Use Query_block_ranges.\n\t(block_range_cache::bb_range_p): Ditto.\n\t(ranger_cache::dump): New.\n\t(ranger_cache::get_global_range): New.\n\t(ranger_cache::set_global_range): New.\n\t* gimple-range.cc (gimple_ranger::range_of_expr): Use new API.\n\t(gimple_ranger::range_of_stmt): Ditto.\n\t(gimple_ranger::export_global_ranges): Ditto.\n\t(gimple_ranger::dump): Ditto.", "tree": {"sha": "8c765d51a3957f50fe64638e064b3a5a9eb23f69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c765d51a3957f50fe64638e064b3a5a9eb23f69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/220929c067717605cab96a9c5fe93e2e01532e51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/220929c067717605cab96a9c5fe93e2e01532e51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/220929c067717605cab96a9c5fe93e2e01532e51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/220929c067717605cab96a9c5fe93e2e01532e51/comments", "author": null, "committer": null, "parents": [{"sha": "c2856ceec2e7542fe9b0bf104afeeeeb57d6996d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2856ceec2e7542fe9b0bf104afeeeeb57d6996d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2856ceec2e7542fe9b0bf104afeeeeb57d6996d"}], "stats": {"total": 111, "additions": 86, "deletions": 25}, "files": [{"sha": "574debbc166e1b254bee514e755ad27dc4c9a3c5", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 69, "deletions": 7, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/220929c067717605cab96a9c5fe93e2e01532e51/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/220929c067717605cab96a9c5fe93e2e01532e51/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=220929c067717605cab96a9c5fe93e2e01532e51", "patch": "@@ -165,6 +165,7 @@ ssa_block_ranges::~ssa_block_ranges ()\n void\n ssa_block_ranges::set_bb_range (const basic_block bb, const irange &r)\n {\n+  gcc_checking_assert ((unsigned) bb->index < m_tab.length ());\n   irange *m = m_irange_allocator->allocate (r);\n   m_tab[bb->index] = m;\n }\n@@ -174,6 +175,7 @@ ssa_block_ranges::set_bb_range (const basic_block bb, const irange &r)\n void\n ssa_block_ranges::set_bb_varying (const basic_block bb)\n {\n+  gcc_checking_assert ((unsigned) bb->index < m_tab.length ());\n   m_tab[bb->index] = m_type_range;\n }\n \n@@ -183,6 +185,7 @@ ssa_block_ranges::set_bb_varying (const basic_block bb)\n bool\n ssa_block_ranges::get_bb_range (irange &r, const basic_block bb)\n {\n+  gcc_checking_assert ((unsigned) bb->index < m_tab.length ());\n   irange *m = m_tab[bb->index];\n   if (m)\n     {\n@@ -197,6 +200,7 @@ ssa_block_ranges::get_bb_range (irange &r, const basic_block bb)\n bool\n ssa_block_ranges::bb_range_p (const basic_block bb)\n {\n+  gcc_checking_assert ((unsigned) bb->index < m_tab.length ());\n   return m_tab[bb->index] != NULL;\n }\n \n@@ -244,8 +248,8 @@ block_range_cache::~block_range_cache ()\n   m_ssa_ranges.release ();\n }\n \n-// Return a reference to the m_block_cache for NAME.  If it has not been\n-// accessed yet, allocate it.\n+// Return a reference to the ssa_block_cache for NAME.  If it has not been\n+// accessed yet, allocate it first.\n \n ssa_block_ranges &\n block_range_cache::get_block_ranges (tree name)\n@@ -255,11 +259,24 @@ block_range_cache::get_block_ranges (tree name)\n     m_ssa_ranges.safe_grow_cleared (num_ssa_names + 1);\n \n   if (!m_ssa_ranges[v])\n-    m_ssa_ranges[v] = new ssa_block_ranges (TREE_TYPE (name), m_irange_allocator);\n-\n+    m_ssa_ranges[v] = new ssa_block_ranges (TREE_TYPE (name),\n+\t\t\t\t\t    m_irange_allocator);\n   return *(m_ssa_ranges[v]);\n }\n \n+\n+// Return a pointer to the ssa_block_cache for NAME.  If it has not been\n+// accessed yet, return NULL.\n+\n+ssa_block_ranges *\n+block_range_cache::query_block_ranges (tree name)\n+{\n+  unsigned v = SSA_NAME_VERSION (name);\n+  if (v >= m_ssa_ranges.length () || !m_ssa_ranges[v])\n+    return NULL;\n+  return m_ssa_ranges[v];\n+}\n+\n // Set the range for NAME on entry to block BB to R.\n \n void\n@@ -283,15 +300,21 @@ block_range_cache::set_bb_varying (tree name, const basic_block bb)\n bool\n block_range_cache::get_bb_range (irange &r, tree name, const basic_block bb)\n {\n-  return get_block_ranges (name).get_bb_range (r, bb);\n+  ssa_block_ranges *ptr = query_block_ranges (name);\n+  if (ptr)\n+    return ptr->get_bb_range (r, bb);\n+  return false;\n }\n \n // Return true if NAME has a range set in block BB.\n \n bool\n block_range_cache::bb_range_p (tree name, const basic_block bb)\n {\n-  return get_block_ranges (name).bb_range_p (bb);\n+  ssa_block_ranges *ptr = query_block_ranges (name);\n+  if (ptr)\n+    return ptr->bb_range_p (bb);\n+  return false;\n }\n \n // Print all known block caches to file F.\n@@ -472,6 +495,46 @@ ranger_cache::~ranger_cache ()\n   m_update_list.release ();\n }\n \n+// Dump the global caches to file F.  if GORI_DUMP is true, dump the\n+// gori map as well.\n+\n+void\n+ranger_cache::dump (FILE *f, bool gori_dump)\n+{\n+  m_globals.dump (f);\n+  if (gori_dump)\n+    {\n+      fprintf (f, \"\\nDUMPING GORI MAP\\n\");\n+      gori_compute::dump (f);\n+    }\n+  fprintf (f, \"\\n\");\n+}\n+\n+// Dump the caches for basic block BB to file F.\n+\n+void\n+ranger_cache::dump (FILE *f, basic_block bb)\n+{\n+  m_on_entry.dump (f, bb);\n+}\n+\n+// Get the global range for NAME, and return in R.  Return false if the\n+// global range is not set.\n+\n+bool\n+ranger_cache::get_global_range (irange &r, tree name) const\n+{\n+  return m_globals.get_global_range (r, name);\n+}\n+\n+//  Set the global range of NAME to R.\n+\n+void\n+ranger_cache::set_global_range (tree name, const irange &r)\n+{\n+  m_globals.set_global_range (name, r);\n+}\n+\n // Push a request for a new lookup in block BB of name.  Return true if\n // the request is actually made (ie, isn't a duplicate).\n \n@@ -869,5 +932,4 @@ ranger_cache::fill_block_cache (tree name, basic_block bb, basic_block def_bb)\n \t  iterative_cache_update (name);\n \t}\n     }\n- \n }"}, {"sha": "599a2926b53598251ac4d95a7ca621e513264f9f", "filename": "gcc/gimple-range-cache.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/220929c067717605cab96a9c5fe93e2e01532e51/gcc%2Fgimple-range-cache.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/220929c067717605cab96a9c5fe93e2e01532e51/gcc%2Fgimple-range-cache.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.h?ref=220929c067717605cab96a9c5fe93e2e01532e51", "patch": "@@ -60,6 +60,7 @@ class block_range_cache\n private:\n   vec<class ssa_block_ranges *> m_ssa_ranges;\n   ssa_block_ranges &get_block_ranges (tree name);\n+  ssa_block_ranges *query_block_ranges (tree name);\n   irange_allocator *m_irange_allocator;\n };\n \n@@ -95,10 +96,16 @@ class ranger_cache : public gori_compute_cache\n   virtual void ssa_range_in_bb (irange &r, tree name, basic_block bb);\n   bool block_range (irange &r, basic_block bb, tree name, bool calc = true);\n \n-  ssa_global_cache m_globals;\n-  block_range_cache m_on_entry;\n+  bool get_global_range (irange &r, tree name) const;\n+  void set_global_range (tree name, const irange &r);\n+\n   non_null_ref m_non_null;\n+\n+  void dump (FILE *f, bool dump_gori = true);\n+  void dump (FILE *f, basic_block bb);\n private:\n+  ssa_global_cache m_globals;\n+  block_range_cache m_on_entry;\n   void add_to_update (basic_block bb);\n   void fill_block_cache (tree name, basic_block bb, basic_block def_bb);\n   void iterative_cache_update (tree name);"}, {"sha": "8fdcc310111448b833824f90eed937ebf39ea29b", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/220929c067717605cab96a9c5fe93e2e01532e51/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/220929c067717605cab96a9c5fe93e2e01532e51/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=220929c067717605cab96a9c5fe93e2e01532e51", "patch": "@@ -897,7 +897,7 @@ gimple_ranger::range_of_expr (irange &r, tree expr, gimple *stmt)\n   // If there is no statement, just get the global value.\n   if (!stmt)\n     {\n-      if (!m_cache.m_globals.get_global_range (r, expr))\n+      if (!m_cache.get_global_range (r, expr))\n         r = gimple_range_global (expr);\n       return true;\n     }\n@@ -1010,18 +1010,18 @@ gimple_ranger::range_of_stmt (irange &r, gimple *s, tree name)\n     return false;\n \n   // If this STMT has already been processed, return that value.\n-  if (m_cache.m_globals.get_global_range (r, name))\n+  if (m_cache.get_global_range (r, name))\n     return true;\n \n   // Avoid infinite recursion by initializing global cache\n   int_range_max tmp = gimple_range_global (name);\n-  m_cache.m_globals.set_global_range (name, tmp);\n+  m_cache.set_global_range (name, tmp);\n \n   calc_stmt (r, s, name);\n \n   if (is_a<gphi *> (s))\n     r.intersect (tmp);\n-  m_cache.m_globals.set_global_range (name, r);\n+  m_cache.set_global_range (name, r);\n   return true;\n }\n \n@@ -1044,7 +1044,7 @@ gimple_ranger::export_global_ranges ()\n       tree name = ssa_name (x);\n       if (name && !SSA_NAME_IN_FREE_LIST (name)\n \t  && gimple_range_ssa_p (name)\n-\t  && m_cache.m_globals.get_global_range (r, name)\n+\t  && m_cache.get_global_range (r, name)\n \t  && !r.varying_p())\n \t{\n \t  // Make sure the new range is a subset of the old range.\n@@ -1088,7 +1088,7 @@ gimple_ranger::dump (FILE *f)\n       edge e;\n       int_range_max range;\n       fprintf (f, \"\\n=========== BB %d ============\\n\", bb->index);\n-      m_cache.m_on_entry.dump (f, bb);\n+      m_cache.dump (f, bb);\n \n       dump_bb (f, bb, 4, TDF_NONE);\n \n@@ -1098,7 +1098,7 @@ gimple_ranger::dump (FILE *f)\n \t  tree name = ssa_name (x);\n \t  if (gimple_range_ssa_p (name) && SSA_NAME_DEF_STMT (name) &&\n \t      gimple_bb (SSA_NAME_DEF_STMT (name)) == bb &&\n-\t      m_cache.m_globals.get_global_range (range, name))\n+\t      m_cache.get_global_range (range, name))\n \t    {\n \t      if (!range.varying_p ())\n \t       {\n@@ -1150,15 +1150,7 @@ gimple_ranger::dump (FILE *f)\n \t}\n     }\n \n-  m_cache.m_globals.dump (dump_file);\n-  fprintf (f, \"\\n\");\n-\n-  if (dump_flags & TDF_DETAILS)\n-    {\n-      fprintf (f, \"\\nDUMPING GORI MAP\\n\");\n-      m_cache.dump (f);\n-      fprintf (f, \"\\n\");\n-    }\n+  m_cache.dump (dump_file, (dump_flags & TDF_DETAILS) != 0);\n }\n \n // If SCEV has any information about phi node NAME, return it as a range in R."}]}