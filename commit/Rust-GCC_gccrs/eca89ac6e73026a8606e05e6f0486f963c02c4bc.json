{"sha": "eca89ac6e73026a8606e05e6f0486f963c02c4bc", "node_id": "C_kwDOANBUbNoAKGVjYTg5YWM2ZTczMDI2YTg2MDZlMDVlNmYwNDg2Zjk2M2MwMmM0YmM", "commit": {"author": {"name": "Piotr Trojanek", "email": "trojanek@adacore.com", "date": "2021-11-22T18:01:33Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-12-02T16:26:24Z"}, "message": "[Ada] Enable expansion of dispatching equality for GNATprove\n\ngcc/ada/\n\n\t* exp_ch13.ads (Expand_N_Freeze_Entity): Add note about a SPARK\n\ttwin.\n\t* exp_ch3.ads (Freeze_Type): Likewise.\n\t* exp_spark.adb (Expand_SPARK_N_Freeze_Entity): Mimic what is\n\tdone in Freeze_Entity.\n\t(SPARK_Freeze_Type): Mimic what is done in Freeze_Type; add call\n\tto Make_Predefined_Primitive_Eq_Spec.", "tree": {"sha": "7f13f9a33da568abdb00528fd77e8c7bbf85d0b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f13f9a33da568abdb00528fd77e8c7bbf85d0b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eca89ac6e73026a8606e05e6f0486f963c02c4bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eca89ac6e73026a8606e05e6f0486f963c02c4bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eca89ac6e73026a8606e05e6f0486f963c02c4bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eca89ac6e73026a8606e05e6f0486f963c02c4bc/comments", "author": {"login": "ptroja", "id": 161602, "node_id": "MDQ6VXNlcjE2MTYwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/161602?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ptroja", "html_url": "https://github.com/ptroja", "followers_url": "https://api.github.com/users/ptroja/followers", "following_url": "https://api.github.com/users/ptroja/following{/other_user}", "gists_url": "https://api.github.com/users/ptroja/gists{/gist_id}", "starred_url": "https://api.github.com/users/ptroja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ptroja/subscriptions", "organizations_url": "https://api.github.com/users/ptroja/orgs", "repos_url": "https://api.github.com/users/ptroja/repos", "events_url": "https://api.github.com/users/ptroja/events{/privacy}", "received_events_url": "https://api.github.com/users/ptroja/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ae5ba7ab10f9cc4d897f0553c472f33875453e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ae5ba7ab10f9cc4d897f0553c472f33875453e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ae5ba7ab10f9cc4d897f0553c472f33875453e0"}], "stats": {"total": 295, "additions": 280, "deletions": 15}, "files": [{"sha": "f5dcfe097e276e0c717e29b94253839a9a6a0e9d", "filename": "gcc/ada/exp_ch13.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eca89ac6e73026a8606e05e6f0486f963c02c4bc/gcc%2Fada%2Fexp_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eca89ac6e73026a8606e05e6f0486f963c02c4bc/gcc%2Fada%2Fexp_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.ads?ref=eca89ac6e73026a8606e05e6f0486f963c02c4bc", "patch": "@@ -32,6 +32,9 @@ package Exp_Ch13 is\n    procedure Expand_N_Attribute_Definition_Clause  (N : Node_Id);\n    procedure Expand_N_Free_Statement               (N : Node_Id);\n    procedure Expand_N_Freeze_Entity                (N : Node_Id);\n+   --  Note: for GNATprove we have a minimal variant of this routine in\n+   --  Exp_SPARK.Expand_SPARK_N_Freeze_Entity. They need to be kept in sync.\n+\n    procedure Expand_N_Record_Representation_Clause (N : Node_Id);\n \n end Exp_Ch13;"}, {"sha": "c7648e6f419d00e727a13acbe84a3daf14693689", "filename": "gcc/ada/exp_ch3.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eca89ac6e73026a8606e05e6f0486f963c02c4bc/gcc%2Fada%2Fexp_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eca89ac6e73026a8606e05e6f0486f963c02c4bc/gcc%2Fada%2Fexp_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.ads?ref=eca89ac6e73026a8606e05e6f0486f963c02c4bc", "patch": "@@ -114,6 +114,9 @@ package Exp_Ch3 is\n    --  delete the node if it is present just for front end purpose and we don't\n    --  want Gigi to see the node. This function can't delete the node itself\n    --  since it would confuse any remaining processing of the freeze node.\n+   --\n+   --  Note: for GNATprove we have a minimal variant of this routine in\n+   --  Exp_SPARK.SPARK_Freeze_Type. They need to be kept in sync.\n \n    function Get_Simple_Init_Val\n      (Typ  : Entity_Id;"}, {"sha": "84927f8509cd150011ca3b811de00f3c1866aa9d", "filename": "gcc/ada/exp_spark.adb", "status": "modified", "additions": 274, "deletions": 15, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eca89ac6e73026a8606e05e6f0486f963c02c4bc/gcc%2Fada%2Fexp_spark.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eca89ac6e73026a8606e05e6f0486f963c02c4bc/gcc%2Fada%2Fexp_spark.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_spark.adb?ref=eca89ac6e73026a8606e05e6f0486f963c02c4bc", "patch": "@@ -29,15 +29,22 @@ with Einfo;          use Einfo;\n with Einfo.Entities; use Einfo.Entities;\n with Einfo.Utils;    use Einfo.Utils;\n with Exp_Attr;\n+with Exp_Ch3;\n with Exp_Ch4;\n with Exp_Ch5;        use Exp_Ch5;\n with Exp_Dbug;       use Exp_Dbug;\n with Exp_Util;       use Exp_Util;\n+with Ghost;          use Ghost;\n with Namet;          use Namet;\n with Nlists;         use Nlists;\n with Nmake;          use Nmake;\n+with Opt;            use Opt;\n+with Restrict;       use Restrict;\n+with Rident;         use Rident;\n with Rtsfind;        use Rtsfind;\n with Sem;            use Sem;\n+with Sem_Aux;        use Sem_Aux;\n+with Sem_Ch7;        use Sem_Ch7;\n with Sem_Ch8;        use Sem_Ch8;\n with Sem_Prag;       use Sem_Prag;\n with Sem_Res;        use Sem_Res;\n@@ -62,8 +69,10 @@ package body Exp_SPARK is\n    procedure Expand_SPARK_N_Delta_Aggregate (N : Node_Id);\n    --  Perform delta-aggregate-specific expansion\n \n-   procedure Expand_SPARK_N_Freeze_Type (E : Entity_Id);\n-   --  Build the DIC procedure of a type when needed, if not already done\n+   procedure Expand_SPARK_N_Freeze_Entity (N : Node_Id);\n+   --  Do a minimal expansion of freeze entities required by GNATprove. It is\n+   --  a subset of what is done for GNAT in Exp_Ch13.Expand_N_Freeze_Entity.\n+   --  Those two routines should be kept in sync.\n \n    procedure Expand_SPARK_N_Loop_Statement (N : Node_Id);\n    --  Perform loop-statement-specific expansion\n@@ -80,6 +89,20 @@ package body Exp_SPARK is\n    procedure Expand_SPARK_Delta_Or_Update (Typ : Entity_Id; Aggr : Node_Id);\n    --  Common expansion for attribute Update and delta aggregates\n \n+   procedure SPARK_Freeze_Type (N : Node_Id);\n+   --  Do a minimal type freezing required by GNATprove. It is a subset of what\n+   --  is done for GNAT in Exp_Ch3.Freeze_Type. Those two routines should be\n+   --  kept in sync.\n+   --\n+   --  Currently in freezing we build the spec of dispatching equality. This\n+   --  spec is needed to properly resolve references to the equality operator.\n+   --  The body is not needed, because proof knows how to directly synthesize a\n+   --  logical meaning for it. Also, for tagged types with extension the\n+   --  expanded body would compare the _parent component, which is\n+   --  intentionally not generated in the GNATprove mode.\n+   --\n+   --  We build the DIC procedure body here as well.\n+\n    ------------------\n    -- Expand_SPARK --\n    ------------------\n@@ -140,8 +163,12 @@ package body Exp_SPARK is\n             Expand_SPARK_N_Op_Ne (N);\n \n          when N_Freeze_Entity =>\n+            --  Currently we only expand type freeze entities, so ignore other\n+            --  freeze entites, because it is expensive to create a suitable\n+            --  freezing environment.\n+\n             if Is_Type (Entity (N)) then\n-               Expand_SPARK_N_Freeze_Type (Entity (N));\n+               Expand_SPARK_N_Freeze_Entity (N);\n             end if;\n \n          --  In SPARK mode, no other constructs require expansion\n@@ -350,23 +377,176 @@ package body Exp_SPARK is\n       end if;\n    end Expand_SPARK_Delta_Or_Update;\n \n-   --------------------------------\n-   -- Expand_SPARK_N_Freeze_Type --\n-   --------------------------------\n+   ----------------------------------\n+   -- Expand_SPARK_N_Freeze_Entity --\n+   ----------------------------------\n+\n+   procedure Expand_SPARK_N_Freeze_Entity (N : Entity_Id) is\n+      E : constant Entity_Id := Entity (N);\n+\n+      Action         : Node_Id;\n+      E_Scope        : Entity_Id;\n+      In_Other_Scope : Boolean;\n+      In_Outer_Scope : Boolean;\n \n-   procedure Expand_SPARK_N_Freeze_Type (E : Entity_Id) is\n    begin\n-      --  When a DIC is inherited by a tagged type, it may need to be\n-      --  specialized to the descendant type, hence build a separate DIC\n-      --  procedure for it as done during regular expansion for compilation.\n+      --  Here E is a type or a subprogram\n \n-      if Has_DIC (E) and then Is_Tagged_Type (E) then\n-         --  Why is this needed for DIC, but not for other aspects (such as\n-         --  Type_Invariant)???\n+      E_Scope := Scope (E);\n+\n+      --  This is an error protection against previous errors\n+\n+      if No (E_Scope) then\n+         Check_Error_Detected;\n+         return;\n+      end if;\n+\n+      --  The entity may be a subtype declared for a constrained record\n+      --  component, in which case the relevant scope is the scope of\n+      --  the record. This happens for class-wide subtypes created for\n+      --  a constrained type extension with inherited discriminants.\n+\n+      if Is_Type (E_Scope)\n+        and then not Is_Concurrent_Type (E_Scope)\n+      then\n+         E_Scope := Scope (E_Scope);\n+\n+      --  The entity may be a subtype declared for an iterator\n+\n+      elsif Ekind (E_Scope) = E_Loop then\n+         E_Scope := Scope (E_Scope);\n+      end if;\n+\n+      --  If we are freezing entities defined in protected types, they belong\n+      --  in the enclosing scope, given that the original type has been\n+      --  expanded away. The same is true for entities in task types, in\n+      --  particular the parameter records of entries (Entities in bodies are\n+      --  all frozen within the body). If we are in the task body, this is a\n+      --  proper scope. If we are within a subprogram body, the proper scope\n+      --  is the corresponding spec. This may happen for itypes generated in\n+      --  the bodies of protected operations.\n+\n+      if Ekind (E_Scope) = E_Protected_Type\n+        or else (Ekind (E_Scope) = E_Task_Type\n+                  and then not Has_Completion (E_Scope))\n+      then\n+         E_Scope := Scope (E_Scope);\n \n-         Build_DIC_Procedure_Body (E);\n+      elsif Ekind (E_Scope) = E_Subprogram_Body then\n+         E_Scope := Corresponding_Spec (Unit_Declaration_Node (E_Scope));\n       end if;\n-   end Expand_SPARK_N_Freeze_Type;\n+\n+      --  If the scope of the entity is in open scopes, it is the current one\n+      --  or an enclosing one, including a loop, a block, or a subprogram.\n+\n+      if In_Open_Scopes (E_Scope) then\n+         In_Other_Scope := False;\n+         In_Outer_Scope := E_Scope /= Current_Scope;\n+\n+      --  Otherwise it is a local package or a different compilation unit\n+\n+      else\n+         In_Other_Scope := True;\n+         In_Outer_Scope := False;\n+      end if;\n+\n+      --  If the entity being frozen is defined in a scope that is not\n+      --  currently on the scope stack, we must establish the proper\n+      --  visibility before freezing the entity and related subprograms.\n+\n+      if In_Other_Scope then\n+         Push_Scope (E_Scope);\n+\n+         --  Finalizers are little odd in terms of freezing. The spec of the\n+         --  procedure appears in the declarations while the body appears in\n+         --  the statement part of a single construct. Since the finalizer must\n+         --  be called by the At_End handler of the construct, the spec is\n+         --  manually frozen right after its declaration. The only side effect\n+         --  of this action appears in contexts where the construct is not in\n+         --  its final resting place. These contexts are:\n+\n+         --    * Entry bodies - The declarations and statements are moved to\n+         --      the procedure equivalen of the entry.\n+         --    * Protected subprograms - The declarations and statements are\n+         --      moved to the non-protected version of the subprogram.\n+         --    * Task bodies - The declarations and statements are moved to the\n+         --      task body procedure.\n+         --    * Blocks that will be rewritten as subprograms when unnesting\n+         --      is in effect.\n+\n+         --  Visible declarations do not need to be installed in these three\n+         --  cases since it does not make semantic sense to do so. All entities\n+         --  referenced by a finalizer are visible and already resolved, plus\n+         --  the enclosing scope may not have visible declarations at all.\n+\n+         if Ekind (E) = E_Procedure\n+           and then Is_Finalizer (E)\n+           and then\n+             (Is_Entry (E_Scope)\n+                or else (Is_Subprogram (E_Scope)\n+                          and then Is_Protected_Type (Scope (E_Scope)))\n+                or else Is_Task_Type (E_Scope)\n+                or else Ekind (E_Scope) = E_Block)\n+         then\n+            null;\n+         else\n+            Install_Visible_Declarations (E_Scope);\n+         end if;\n+\n+         if Is_Concurrent_Type (E_Scope)\n+           or else Is_Package_Or_Generic_Package (E_Scope)\n+         then\n+            Install_Private_Declarations (E_Scope);\n+         end if;\n+\n+      --  If the entity is in an outer scope, then that scope needs to\n+      --  temporarily become the current scope so that operations created\n+      --  during type freezing will be declared in the right scope and\n+      --  can properly override any corresponding inherited operations.\n+\n+      elsif In_Outer_Scope then\n+         Push_Scope (E_Scope);\n+      end if;\n+\n+      --  Remember that we are processing a freezing entity and its freezing\n+      --  nodes. This flag (non-zero = set) is used to avoid the need of\n+      --  climbing through the tree while processing the freezing actions (ie.\n+      --  to avoid generating spurious warnings or to avoid killing constant\n+      --  indications while processing the code associated with freezing\n+      --  actions). We use a counter to deal with nesting.\n+\n+      Inside_Freezing_Actions := Inside_Freezing_Actions + 1;\n+\n+      --  Currently only types require freezing in SPARK\n+\n+      SPARK_Freeze_Type (N);\n+\n+      --  Analyze actions in freeze node, if any\n+\n+      Action := First (Actions (N));\n+      while Present (Action) loop\n+         Analyze (Action);\n+         Next (Action);\n+      end loop;\n+\n+      --  Pop scope if we installed one for the analysis\n+\n+      if In_Other_Scope then\n+         if Ekind (Current_Scope) = E_Package then\n+            End_Package_Scope (E_Scope);\n+         else\n+            End_Scope;\n+         end if;\n+\n+      elsif In_Outer_Scope then\n+         Pop_Scope;\n+      end if;\n+\n+      --  Restore previous value of the nesting-level counter that records\n+      --  whether we are inside a (possibly nested) call to this procedure.\n+\n+      Inside_Freezing_Actions := Inside_Freezing_Actions - 1;\n+   end Expand_SPARK_N_Freeze_Entity;\n \n    ----------------------------------------\n    -- Expand_SPARK_N_Attribute_Reference --\n@@ -705,4 +885,83 @@ package body Exp_SPARK is\n       end if;\n    end Expand_SPARK_Potential_Renaming;\n \n+   -----------------------\n+   -- SPARK_Freeze_Type --\n+   -----------------------\n+\n+   procedure SPARK_Freeze_Type (N : Entity_Id) is\n+      Typ : constant Entity_Id := Entity (N);\n+\n+      Renamed_Eq : Node_Id;\n+      --  Defining unit name for the predefined equality function in the case\n+      --  where the type has a primitive operation that is a renaming of\n+      --  predefined equality (but only if there is also an overriding\n+      --  user-defined equality function). Used to pass this entity from\n+      --  Make_Predefined_Primitive_Specs to Predefined_Primitive_Bodies.\n+\n+      Decl        : Node_Id;\n+      Eq_Spec     : Node_Id := Empty;\n+      Predef_List : List_Id;\n+\n+      Saved_GM  : constant Ghost_Mode_Type := Ghost_Mode;\n+      Saved_IGR : constant Node_Id         := Ignored_Ghost_Region;\n+      --  Save the Ghost-related attributes to restore on exit\n+\n+   begin\n+      --  The type being frozen may be subject to pragma Ghost. Set the mode\n+      --  now to ensure that any nodes generated during freezing are properly\n+      --  marked as Ghost.\n+\n+      Set_Ghost_Mode (Typ);\n+\n+      --  When a DIC is inherited by a tagged type, it may need to be\n+      --  specialized to the descendant type, hence build a separate DIC\n+      --  procedure for it as done during regular expansion for compilation.\n+\n+      if Has_DIC (Typ) and then Is_Tagged_Type (Typ) then\n+         --  Why is this needed for DIC, but not for other aspects (such as\n+         --  Type_Invariant)???\n+\n+         Build_DIC_Procedure_Body (Typ);\n+      end if;\n+\n+      if Ekind (Typ) = E_Record_Type\n+        and then Is_Tagged_Type (Typ)\n+        and then not Is_Interface (Typ)\n+        and then not Is_Limited_Type (Typ)\n+      then\n+         if Is_CPP_Class (Root_Type (Typ))\n+           and then Convention (Typ) = Convention_CPP\n+         then\n+            null;\n+\n+         --  Do not add the spec of the predefined primitives if we are\n+         --  compiling under restriction No_Dispatching_Calls.\n+\n+         elsif not Restriction_Active (No_Dispatching_Calls) then\n+            Set_Is_Frozen (Typ, False);\n+\n+            Predef_List := New_List;\n+            Exp_Ch3.Make_Predefined_Primitive_Eq_Spec\n+              (Typ, Predef_List, Renamed_Eq);\n+            Eq_Spec := First (Predef_List);\n+            Insert_List_Before_And_Analyze (N, Predef_List);\n+\n+            Set_Is_Frozen (Typ);\n+\n+            --  Remove link from the parent list to the spec and body of\n+            --  the dispatching equality, but keep the link in the opposite\n+            --  direction, to allow up-traversal of the AST.\n+\n+            if Present (Eq_Spec) then\n+               Decl := Parent (Eq_Spec);\n+               Remove (Eq_Spec);\n+               Set_Parent (Eq_Spec, Decl);\n+            end if;\n+         end if;\n+      end if;\n+\n+      Restore_Ghost_Region (Saved_GM, Saved_IGR);\n+   end SPARK_Freeze_Type;\n+\n end Exp_SPARK;"}]}