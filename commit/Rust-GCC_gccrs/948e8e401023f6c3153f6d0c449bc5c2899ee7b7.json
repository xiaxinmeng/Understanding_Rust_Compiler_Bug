{"sha": "948e8e401023f6c3153f6d0c449bc5c2899ee7b7", "node_id": "C_kwDOANBUbNoAKDk0OGU4ZTQwMTAyM2Y2YzMxNTNmNmQwYzQ0OWJjNWMyODk5ZWU3Yjc", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-04-27T16:47:10Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-04-27T16:47:10Z"}, "message": "testsuite: Add testcase for dangling pointer equality bogus warning [PR104492]\n\nOn Wed, Apr 27, 2022 at 12:02:33PM +0200, Richard Biener wrote:\n> I did that but the reduction result did not resemble the same failure\n> mode.  I've failed to manually construct a testcase as well.  Possibly\n> a testcase using libstdc++ but less Qt internals might be possible.\n\nHere is a testcase that I've managed to reduce, FAILs with:\nFAIL: g++.dg/warn/pr104492.C  -std=gnu++14  (test for bogus messages, line 111)\nFAIL: g++.dg/warn/pr104492.C  -std=gnu++17  (test for bogus messages, line 111)\nFAIL: g++.dg/warn/pr104492.C  -std=gnu++20  (test for bogus messages, line 111)\non both x86_64-linux and i686-linux without your commit and passes with it.\n\n2022-04-27  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR middle-end/104492\n\t* g++.dg/warn/pr104492.C: New test.", "tree": {"sha": "8ad67b837576f897081ca0861ce96f4c6ba1263c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ad67b837576f897081ca0861ce96f4c6ba1263c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/948e8e401023f6c3153f6d0c449bc5c2899ee7b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/948e8e401023f6c3153f6d0c449bc5c2899ee7b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/948e8e401023f6c3153f6d0c449bc5c2899ee7b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/948e8e401023f6c3153f6d0c449bc5c2899ee7b7/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6541401407b0d09169fd716ab6d5e02c8d60642", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6541401407b0d09169fd716ab6d5e02c8d60642", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6541401407b0d09169fd716ab6d5e02c8d60642"}], "stats": {"total": 115, "additions": 115, "deletions": 0}, "files": [{"sha": "229414d6dd39a4dc1e3bc92e547ebfdc174c5ae2", "filename": "gcc/testsuite/g++.dg/warn/pr104492.C", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/948e8e401023f6c3153f6d0c449bc5c2899ee7b7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr104492.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/948e8e401023f6c3153f6d0c449bc5c2899ee7b7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr104492.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr104492.C?ref=948e8e401023f6c3153f6d0c449bc5c2899ee7b7", "patch": "@@ -0,0 +1,115 @@\n+// PR middle-end/104492\n+// { dg-do compile { target c++14 } }\n+// { dg-options \"-O3 -Wall\" }\n+\n+namespace std {\n+typedef decltype (sizeof 0) size_t;\n+template <typename _Tp, _Tp __v> struct integral_constant {\n+  static constexpr _Tp value = __v;\n+};\n+template <typename _Tp, typename _Up>\n+struct is_same : integral_constant<bool, __is_same(_Tp, _Up)> {};\n+template <bool, typename> struct enable_if;\n+template <typename _Tp> _Tp forward;\n+}\n+class QString;\n+struct random_access_iterator_tag {};\n+template <typename> struct iterator_traits {\n+  typedef random_access_iterator_tag iterator_category;\n+};\n+template <typename _Iter>\n+typename iterator_traits<_Iter>::iterator_category __iterator_category(_Iter);\n+namespace __gnu_cxx {\n+namespace __ops {\n+template <typename> struct _Iter_equals_val {\n+  template <typename _Iterator> bool operator()(_Iterator);\n+};\n+template <typename _Value> _Iter_equals_val<_Value> __iter_equals_val(_Value);\n+}\n+}\n+namespace std {\n+template <typename _RandomAccessIterator, typename _Predicate>\n+_RandomAccessIterator __find_if(_RandomAccessIterator __first,\n+\t\t\t\t_RandomAccessIterator __last, _Predicate __pred,\n+\t\t\t\trandom_access_iterator_tag) {\n+  if (__pred(__first))\n+    return __first;\n+  return __last;\n+}\n+template <typename _Iterator, typename _Predicate>\n+_Iterator __find_if(_Iterator __first, _Iterator __last, _Predicate __pred) {\n+  return __find_if(__first, __last, __pred, __iterator_category(__first));\n+}\n+template <typename _Tp, size_t _Nm> _Tp *begin(_Tp (&__arr)[_Nm]) {\n+  return __arr;\n+}\n+template <typename _Tp, size_t _Nm> _Tp *end(_Tp (&__arr)[_Nm]) {\n+  return __arr + _Nm;\n+}\n+template <typename _InputIterator, typename _Tp>\n+_InputIterator find(_InputIterator __first, _InputIterator __last, _Tp __val) {\n+  return __find_if(__first, __last, __gnu_cxx::__ops::__iter_equals_val(__val));\n+}\n+}\n+struct QStringView {\n+  template <typename T>\n+  using if_compatible_qstring_like = std::enable_if<std::is_same<T, QString>::value, bool>;\n+  template <typename String> QStringView(String);\n+};\n+template <typename Haystack, typename> struct QStringTokenizerBase {\n+  class sentinel {};\n+  struct iterator {\n+    Haystack operator*();\n+    iterator operator++(int);\n+    bool operator!=(sentinel);\n+  };\n+  iterator begin();\n+  template <bool = std::is_same<iterator, sentinel>::value> sentinel end();\n+};\n+namespace QtPrivate {\n+namespace Tok {\n+template <typename Haystack, typename Needle>\n+using TokenizerBase = QStringTokenizerBase<Haystack, Needle>;\n+}\n+}\n+template <typename Haystack, typename Needle>\n+struct QStringTokenizer\n+    : public QtPrivate::Tok::TokenizerBase<Haystack, Needle> {\n+  QStringTokenizer(Haystack, Needle);\n+};\n+namespace QtPrivate {\n+namespace Tok {\n+template <typename Haystack, typename Needle>\n+using TokenizerResult = QStringTokenizer<Haystack, Needle>;\n+}\n+}\n+template <typename Haystack, typename Needle>\n+auto qTokenize(Haystack, Needle)\n+    -> decltype(QtPrivate::Tok::TokenizerResult<Haystack, Needle>{\n+\tstd::forward<Haystack>, std::forward<Needle>});\n+struct QLatin1String {\n+  QLatin1String(const char *) {}\n+};\n+class QString {};\n+class QLibrary {\n+  bool isLibrary(const QString &);\n+};\n+\n+bool QLibrary::isLibrary(const QString &fileName)\n+{\n+    QString completeSuffix = fileName;\n+    auto isValidSuffix = [](QStringView s) {\n+\tconst QLatin1String candidates[] = {\n+\t    QLatin1String(\"so\"),\n+\t};\n+\treturn std::find(std::begin(candidates), std::end(candidates), s) != std::end(candidates);\n+    };\n+    auto suffixes = qTokenize(completeSuffix, u'.');\n+    auto it = suffixes.begin();\n+    const auto end = suffixes.end();\n+    while (it != end) {\n+\tif (isValidSuffix(*it++))\t// { dg-bogus \"dangling pointer to .candidates. may be used\" }\n+\t  return true;\n+    }\n+    return false;\n+}"}]}