{"sha": "d7840b4702a91456a16cf1d4744c4b7a9c021138", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc4NDBiNDcwMmE5MTQ1NmExNmNmMWQ0NzQ0YzRiN2E5YzAyMTEzOA==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2017-10-14T23:07:24Z"}, "committer": {"name": "Michael Collison", "email": "collison@gcc.gnu.org", "date": "2017-10-14T23:07:24Z"}, "message": "compare-elim.c: Include emit-rtl.h.\n\n2017-10-14  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n\t    Michael Collison <michael.collison@arm.com>\n\n\t* compare-elim.c: Include emit-rtl.h.\n\t(can_merge_compare_into_arith): New function.\n\t(try_validate_parallel): Likewise.\n\t(try_merge_compare): Likewise.\n\t(try_eliminate_compare): Call the above when no previous clobber\n\tis available.\n\t(execute_compare_elim_after_reload): Add DF_UD_CHAIN and DF_DU_CHAIN\n\tdataflow problems.\n\n2017-10-14  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n\t    Michael Collison <michael.collison@arm.com>\n\n\t* gcc.target/aarch64/cmpelim_mult_uses_1.c: New test.\n\n\nCo-Authored-By: Michael Collison <michael.collison@arm.com>\n\nFrom-SVN: r253764", "tree": {"sha": "2d4a9ed6932ed48cabf52eebf5a7d1859f58f57c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d4a9ed6932ed48cabf52eebf5a7d1859f58f57c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7840b4702a91456a16cf1d4744c4b7a9c021138", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7840b4702a91456a16cf1d4744c4b7a9c021138", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7840b4702a91456a16cf1d4744c4b7a9c021138", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7840b4702a91456a16cf1d4744c4b7a9c021138/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c97b789cb88ceb5b3fc2aa94506978e74503d895", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c97b789cb88ceb5b3fc2aa94506978e74503d895", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c97b789cb88ceb5b3fc2aa94506978e74503d895"}], "stats": {"total": 177, "additions": 176, "deletions": 1}, "files": [{"sha": "8509b4994853137f25f77e6582ae9fcef72d450a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7840b4702a91456a16cf1d4744c4b7a9c021138/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7840b4702a91456a16cf1d4744c4b7a9c021138/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d7840b4702a91456a16cf1d4744c4b7a9c021138", "patch": "@@ -1,3 +1,15 @@\n+2017-10-14  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\t    Michael Collison <michael.collison@arm.com>\n+\n+\t* compare-elim.c: Include emit-rtl.h.\n+\t(can_merge_compare_into_arith): New function.\n+\t(try_validate_parallel): Likewise.\n+\t(try_merge_compare): Likewise.\n+\t(try_eliminate_compare): Call the above when no previous clobber\n+\tis available.\n+\t(execute_compare_elim_after_reload): Add DF_UD_CHAIN and DF_DU_CHAIN\n+\tdataflow problems.\n+\n 2017-10-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/62263"}, {"sha": "794a452f98bc81a2fd12bb667c7ff936b22f7e0e", "filename": "gcc/compare-elim.c", "status": "modified", "additions": 142, "deletions": 1, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7840b4702a91456a16cf1d4744c4b7a9c021138/gcc%2Fcompare-elim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7840b4702a91456a16cf1d4744c4b7a9c021138/gcc%2Fcompare-elim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcompare-elim.c?ref=d7840b4702a91456a16cf1d4744c4b7a9c021138", "patch": "@@ -65,6 +65,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm_p.h\"\n #include \"insn-config.h\"\n #include \"recog.h\"\n+#include \"emit-rtl.h\"\n #include \"cfgrtl.h\"\n #include \"tree-pass.h\"\n #include \"domwalk.h\"\n@@ -579,6 +580,143 @@ equivalent_reg_at_start (rtx reg, rtx_insn *end, rtx_insn *start)\n   return reg;\n }\n \n+/* Return true if it is okay to merge the comparison CMP_INSN with\n+   the instruction ARITH_INSN.  Both instructions are assumed to be in the\n+   same basic block with ARITH_INSN appearing before CMP_INSN.  This checks\n+   that there are no uses or defs of the condition flags or control flow\n+   changes between the two instructions.  */\n+\n+static bool\n+can_merge_compare_into_arith (rtx_insn *cmp_insn, rtx_insn *arith_insn)\n+{\n+  for (rtx_insn *insn = PREV_INSN (cmp_insn);\n+       insn && insn != arith_insn;\n+       insn = PREV_INSN (insn))\n+    {\n+      if (!NONDEBUG_INSN_P (insn))\n+\tcontinue;\n+      /* Bail if there are jumps or calls in between.  */\n+      if (!NONJUMP_INSN_P (insn))\n+\treturn false;\n+\n+      /* Bail on old-style asm statements because they lack\n+\t data flow information.  */\n+      if (GET_CODE (PATTERN (insn)) == ASM_INPUT)\n+\treturn false;\n+\n+      df_ref ref;\n+      /* Find a USE of the flags register.  */\n+      FOR_EACH_INSN_USE (ref, insn)\n+\tif (DF_REF_REGNO (ref) == targetm.flags_regnum)\n+\t  return false;\n+\n+      /* Find a DEF of the flags register.  */\n+      FOR_EACH_INSN_DEF (ref, insn)\n+\tif (DF_REF_REGNO (ref) == targetm.flags_regnum)\n+\t  return false;\n+    }\n+  return true;\n+}\n+\n+/* Given two SET expressions, SET_A and SET_B determine whether they form\n+   a recognizable pattern when emitted in parallel.  Return that parallel\n+   if so.  Otherwise return NULL.  */\n+\n+static rtx\n+try_validate_parallel (rtx set_a, rtx set_b)\n+{\n+  rtx par\n+    = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, set_a, set_b));\n+\n+  rtx_insn *insn;\n+  insn = gen_rtx_INSN (VOIDmode, 0, 0, 0, par, 0, -1, 0);\n+\n+  return recog_memoized (insn) > 0 ? par : NULL_RTX;\n+}\n+\n+/* For a comparison instruction described by CMP check if it compares a\n+   register with zero i.e. it is of the form CC := CMP R1, 0.\n+   If it is, find the instruction defining R1 (say I1) and try to create a\n+   PARALLEL consisting of I1 and the comparison, representing a flag-setting\n+   arithmetic instruction.  Example:\n+   I1: R1 := R2 + R3\n+   <instructions that don't read the condition register>\n+   I2: CC := CMP R1 0\n+   I2 can be merged with I1 into:\n+   I1: { R1 := R2 + R3 ; CC := CMP (R2 + R3) 0 }\n+   This catches cases where R1 is used between I1 and I2 and therefore\n+   combine and other RTL optimisations will not try to propagate it into\n+   I2.  Return true if we succeeded in merging CMP.  */\n+\n+static bool\n+try_merge_compare (struct comparison *cmp)\n+{\n+  rtx_insn *cmp_insn = cmp->insn;\n+\n+  if (!REG_P (cmp->in_a) || cmp->in_b != const0_rtx)\n+    return false;\n+  rtx in_a = cmp->in_a;\n+  df_ref use;\n+\n+  FOR_EACH_INSN_USE (use, cmp_insn)\n+    if (DF_REF_REGNO (use) == REGNO (in_a))\n+      break;\n+  if (!use)\n+    return false;\n+\n+  /* Validate the data flow information before attempting to\n+     find the instruction that defines in_a.  */\n+\n+  struct df_link *ref_chain;\n+  ref_chain = DF_REF_CHAIN (use);\n+  if (!ref_chain || !ref_chain->ref\n+      || !DF_REF_INSN_INFO (ref_chain->ref) || ref_chain->next != NULL)\n+    return false;\n+\n+  rtx_insn *def_insn = DF_REF_INSN (ref_chain->ref);\n+  /* We found the insn that defines in_a.  Only consider the cases where\n+     it is in the same block as the comparison.  */\n+  if (BLOCK_FOR_INSN (cmp_insn) != BLOCK_FOR_INSN (def_insn))\n+    return false;\n+\n+  rtx set = single_set (def_insn);\n+  if (!set)\n+    return false;\n+\n+  if (!can_merge_compare_into_arith (cmp_insn, def_insn))\n+    return false;\n+\n+  rtx src = SET_SRC (set);\n+  rtx flags = maybe_select_cc_mode (cmp, src, CONST0_RTX (GET_MODE (src)));\n+  if (!flags)\n+    {\n+    /* We may already have a change group going through maybe_select_cc_mode.\n+       Discard it properly.  */\n+      cancel_changes (0);\n+      return false;\n+    }\n+\n+  rtx flag_set\n+    = gen_rtx_SET (flags, gen_rtx_COMPARE (GET_MODE (flags),\n+\t\t\t\t\t   copy_rtx (src),\n+\t\t\t\t\t   CONST0_RTX (GET_MODE (src))));\n+  rtx arith_set = copy_rtx (PATTERN (def_insn));\n+  rtx par = try_validate_parallel (flag_set, arith_set);\n+  if (!par)\n+    {\n+      /* We may already have a change group going through maybe_select_cc_mode.\n+\t Discard it properly.  */\n+      cancel_changes (0);\n+      return false;\n+    }\n+  if (!apply_change_group ())\n+    return false;\n+  emit_insn_after (par, def_insn);\n+  delete_insn (def_insn);\n+  delete_insn (cmp->insn);\n+  return true;\n+}\n+\n /* Attempt to replace a comparison with a prior arithmetic insn that can\n    compute the same flags value as the comparison itself.  Return true if\n    successful, having made all rtl modifications necessary.  */\n@@ -588,7 +726,9 @@ try_eliminate_compare (struct comparison *cmp)\n {\n   rtx flags, in_a, in_b, cmp_src;\n \n-  /* We must have found an interesting \"clobber\" preceding the compare.  */\n+  if (try_merge_compare (cmp))\n+    return true;\n+\n   if (cmp->prev_clobber == NULL)\n     return false;\n \n@@ -714,6 +854,7 @@ try_eliminate_compare (struct comparison *cmp)\n static unsigned int\n execute_compare_elim_after_reload (void)\n {\n+  df_chain_add_problem (DF_UD_CHAIN + DF_DU_CHAIN);\n   df_analyze ();\n \n   gcc_checking_assert (!all_compares.exists ());"}, {"sha": "d88bfb7e63be29397098f02d84c5e9b149949674", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7840b4702a91456a16cf1d4744c4b7a9c021138/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7840b4702a91456a16cf1d4744c4b7a9c021138/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d7840b4702a91456a16cf1d4744c4b7a9c021138", "patch": "@@ -1,3 +1,8 @@\n+2017-10-14  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\t    Michael Collison <michael.collison@arm.com>\n+\n+\t* gcc.target/aarch64/cmpelim_mult_uses_1.c: New test.\n+\n 2017-10-14  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/80908"}, {"sha": "953c388037f4cc4d6daa446ab40b3f8546736034", "filename": "gcc/testsuite/gcc.target/aarch64/cmpelim_mult_uses_1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7840b4702a91456a16cf1d4744c4b7a9c021138/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fcmpelim_mult_uses_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7840b4702a91456a16cf1d4744c4b7a9c021138/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fcmpelim_mult_uses_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fcmpelim_mult_uses_1.c?ref=d7840b4702a91456a16cf1d4744c4b7a9c021138", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+/* X is both compared against zero and used.  Make sure we can still\n+   generate an ADDS and avoid an explicit comparison against zero.  */\n+\n+int\n+foo (int x, int y)\n+{\n+  x += y;\n+  if (x != 0)\n+    x = x + 2;\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler-times \"adds\\\\tw\\[0-9\\]+, w\\[0-9\\]+, w\\[0-9\\]+\" 1 } } */\n+/* { dg-final { scan-assembler-not \"cmp\\\\tw\\[0-9\\]+, 0\" } } */"}]}