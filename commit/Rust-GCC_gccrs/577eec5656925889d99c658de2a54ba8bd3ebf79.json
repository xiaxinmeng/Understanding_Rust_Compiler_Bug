{"sha": "577eec5656925889d99c658de2a54ba8bd3ebf79", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc3ZWVjNTY1NjkyNTg4OWQ5OWM2NThkZTJhNTRiYThiZDNlYmY3OQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2017-08-07T08:37:07Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2017-08-07T08:37:07Z"}, "message": "Canonicalize names of attributes.\n\n2017-08-07  Martin Liska  <mliska@suse.cz>\n\n\t* attribs.h (canonicalize_attr_name): New function.\n\t(cmp_attribs): Move from c-format.c and adjusted.\n\t(is_attribute_p): Moved from tree.h.\n\t* tree-inline.c: Add new includes.\n\t* tree.c (cmp_attrib_identifiers): Use cmp_attribs.\n\t(private_is_attribute_p): Remove.\n\t(private_lookup_attribute): Likewise.\n\t(private_lookup_attribute_by_prefix): Simplify.\n\t(remove_attribute): Use is_attribute_p.\n\t* tree.h: Remove removed declarations.\n2017-08-07  Martin Liska  <mliska@suse.cz>\n\n\t* array-notation-common.c: Add new includes.\n\t* c-format.c( handle_format_attribute): Canonicalize a format\n\tfunction name.\n\t* c-lex.c (c_common_has_attribute): Canonicalize name of an\n\tattribute.\n\t* c-pretty-print.c: Add new include.\n2017-08-07  Martin Liska  <mliska@suse.cz>\n\n\t* parser.c (cp_parser_gnu_attribute_list): Canonicalize name of an\n\tattribute.\n\t(cp_parser_std_attribute): Likewise.\n\t* tree.c: Add new include.\n2017-08-07  Martin Liska  <mliska@suse.cz>\n\n\t* c-parser.c (c_parser_attributes): Canonicalize name of an\n\tattribute.\n2017-08-07  Martin Liska  <mliska@suse.cz>\n\n\t* go-gcc.cc (Gcc_backend::function): Look up for no_split_stack\n\tand not __no_split_stack__.\n2017-08-07  Martin Liska  <mliska@suse.cz>\n\n\t* g++.dg/cpp0x/pr65558.C: Update scanned pattern.\n\t* gcc.dg/parm-impl-decl-1.c: Likewise.\n\t* gcc.dg/parm-impl-decl-3.c: Likewise.\n\t* gcc.dg/Wattributes-5.c: New test.\n\nFrom-SVN: r250911", "tree": {"sha": "1d346340abd66a2756508c28e25d2334f2e0a8da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d346340abd66a2756508c28e25d2334f2e0a8da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/577eec5656925889d99c658de2a54ba8bd3ebf79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/577eec5656925889d99c658de2a54ba8bd3ebf79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/577eec5656925889d99c658de2a54ba8bd3ebf79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/577eec5656925889d99c658de2a54ba8bd3ebf79/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a5320f3ce2cfe8633a32730c3323238cbf673440", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5320f3ce2cfe8633a32730c3323238cbf673440", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5320f3ce2cfe8633a32730c3323238cbf673440"}], "stats": {"total": 278, "additions": 141, "deletions": 137}, "files": [{"sha": "880a3c89a3f4f53cc6eeb08d8aec927eff89ed5c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=577eec5656925889d99c658de2a54ba8bd3ebf79", "patch": "@@ -1,3 +1,16 @@\n+2017-08-07  Martin Liska  <mliska@suse.cz>\n+\n+\t* attribs.h (canonicalize_attr_name): New function.\n+\t(cmp_attribs): Move from c-format.c and adjusted.\n+\t(is_attribute_p): Moved from tree.h.\n+\t* tree-inline.c: Add new includes.\n+\t* tree.c (cmp_attrib_identifiers): Use cmp_attribs.\n+\t(private_is_attribute_p): Remove.\n+\t(private_lookup_attribute): Likewise.\n+\t(private_lookup_attribute_by_prefix): Simplify.\n+\t(remove_attribute): Use is_attribute_p.\n+\t* tree.h: Remove removed declarations.\n+\n 2017-08-07  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/81698"}, {"sha": "d4a790bb75346770847c27c038070151204633f1", "filename": "gcc/attribs.h", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Fattribs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Fattribs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.h?ref=577eec5656925889d99c658de2a54ba8bd3ebf79", "patch": "@@ -47,4 +47,47 @@ extern char *make_unique_name (tree, const char *, bool);\n extern tree make_dispatcher_decl (const tree);\n extern bool is_function_default_version (const tree);\n \n+/* For a given IDENTIFIER_NODE, strip leading and trailing '_' characters\n+   so that we have a canonical form of attribute names.  */\n+\n+static inline tree\n+canonicalize_attr_name (tree attr_name)\n+{\n+  const size_t l = IDENTIFIER_LENGTH (attr_name);\n+  const char *s = IDENTIFIER_POINTER (attr_name);\n+\n+  if (l > 4 && s[0] == '_' && s[1] == '_' && s[l - 1] == '_' && s[l - 2] == '_')\n+    return get_identifier_with_length (s + 2, l - 4);\n+\n+  return attr_name;\n+}\n+\n+/* Compare attribute identifiers ATTR1 and ATTR2 with length ATTR1_LEN and\n+   ATTR2_LEN.  */\n+\n+static inline bool\n+cmp_attribs (const char *attr1, size_t attr1_len,\n+\t     const char *attr2, size_t attr2_len)\n+{\n+  return attr1_len == attr2_len && strncmp (attr1, attr2, attr1_len) == 0;\n+}\n+\n+/* Compare attribute identifiers ATTR1 and ATTR2.  */\n+\n+static inline bool\n+cmp_attribs (const char *attr1, const char *attr2)\n+{\n+  return cmp_attribs (attr1, strlen (attr1), attr2, strlen (attr2));\n+}\n+\n+/* Given an identifier node IDENT and a string ATTR_NAME, return true\n+   if the identifier node is a valid attribute name for the string.  */\n+\n+static inline bool\n+is_attribute_p (const char *attr_name, const_tree ident)\n+{\n+  return cmp_attribs (attr_name, strlen (attr_name),\n+\t\t      IDENTIFIER_POINTER (ident), IDENTIFIER_LENGTH (ident));\n+}\n+\n #endif // GCC_ATTRIBS_H"}, {"sha": "ba007b9442c4ab486cafcbf838f13266e1c6e814", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=577eec5656925889d99c658de2a54ba8bd3ebf79", "patch": "@@ -1,3 +1,12 @@\n+2017-08-07  Martin Liska  <mliska@suse.cz>\n+\n+\t* array-notation-common.c: Add new includes.\n+\t* c-format.c( handle_format_attribute): Canonicalize a format\n+\tfunction name.\n+\t* c-lex.c (c_common_has_attribute): Canonicalize name of an\n+\tattribute.\n+\t* c-pretty-print.c: Add new include.\n+\n 2017-08-05  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* c-ada-spec.c (has_static_fields): Look only into variables."}, {"sha": "a4809948e20368a36c57504e11050c7ba7f9f2d6", "filename": "gcc/c-family/array-notation-common.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Fc-family%2Farray-notation-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Fc-family%2Farray-notation-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Farray-notation-common.c?ref=577eec5656925889d99c658de2a54ba8bd3ebf79", "patch": "@@ -27,6 +27,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"options.h\"\n #include \"c-family/c-common.h\"\n #include \"tree-iterator.h\"\n+#include \"stringpool.h\"\n+#include \"attribs.h\"\n \n /* Returns true if the function call in FNDECL is  __sec_implicit_index.  */\n "}, {"sha": "5e5b494383f702e02c22bded63c9ef637eb9a384", "filename": "gcc/c-family/c-format.c", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Fc-family%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Fc-family%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-format.c?ref=577eec5656925889d99c658de2a54ba8bd3ebf79", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"substring-locations.h\"\n #include \"selftest.h\"\n #include \"builtins.h\"\n+#include \"attribs.h\"\n \n /* Handle attributes associated with format checking.  */\n \n@@ -67,7 +68,6 @@ static bool check_format_string (tree argument,\n static bool get_constant (tree expr, unsigned HOST_WIDE_INT *value,\n \t\t\t  int validated_p);\n static const char *convert_format_name_to_system_name (const char *attr_name);\n-static bool cmp_attribs (const char *tattr_name, const char *attr_name);\n \n static int first_target_format_type;\n static const char *format_name (int format_num);\n@@ -3976,24 +3976,6 @@ convert_format_name_to_system_name (const char *attr_name)\n   return attr_name;\n }\n \n-/* Return true if TATTR_NAME and ATTR_NAME are the same format attribute,\n-   counting \"name\" and \"__name__\" as the same, false otherwise.  */\n-static bool\n-cmp_attribs (const char *tattr_name, const char *attr_name)\n-{\n-  int alen = strlen (attr_name);\n-  int slen = (tattr_name ? strlen (tattr_name) : 0);\n-  if (alen > 4 && attr_name[0] == '_' && attr_name[1] == '_'\n-      && attr_name[alen - 1] == '_' && attr_name[alen - 2] == '_')\n-    {\n-      attr_name += 2;\n-      alen -= 4;\n-    }\n-  if (alen != slen || strncmp (tattr_name, attr_name, alen) != 0)\n-    return false;\n-  return true;\n-}\n-\n /* Handle a \"format\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n tree\n@@ -4022,6 +4004,10 @@ handle_format_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n     }\n #endif\n \n+  /* Canonicalize name of format function.  */\n+  if (TREE_CODE (TREE_VALUE (args)) == IDENTIFIER_NODE)\n+    TREE_VALUE (args) = canonicalize_attr_name (TREE_VALUE (args));\n+\n   if (!decode_format_attr (args, &info, 0))\n     {\n       *no_add_attrs = true;"}, {"sha": "3765a800a5799209bca5018dd36c9f3c53525b8f", "filename": "gcc/c-family/c-lex.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Fc-family%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Fc-family%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-lex.c?ref=577eec5656925889d99c658de2a54ba8bd3ebf79", "patch": "@@ -316,6 +316,7 @@ c_common_has_attribute (cpp_reader *pfile)\n     {\n       attr_name = get_identifier ((const char *)\n \t\t\t\t  cpp_token_as_text (pfile, token));\n+      attr_name = canonicalize_attr_name (attr_name);\n       if (c_dialect_cxx ())\n \t{\n \t  int idx = 0;"}, {"sha": "b8b8f665ef35eebd98e4d073451c1e3dc680c3d6", "filename": "gcc/c-family/c-pretty-print.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Fc-family%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Fc-family%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pretty-print.c?ref=577eec5656925889d99c658de2a54ba8bd3ebf79", "patch": "@@ -24,6 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"c-pretty-print.h\"\n #include \"diagnostic.h\"\n #include \"stor-layout.h\"\n+#include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"intl.h\"\n #include \"tree-pretty-print.h\""}, {"sha": "06dd1b7f100fe0e7c9c097c8008660d996d61b62", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=577eec5656925889d99c658de2a54ba8bd3ebf79", "patch": "@@ -1,3 +1,8 @@\n+2017-08-07  Martin Liska  <mliska@suse.cz>\n+\n+\t* c-parser.c (c_parser_attributes): Canonicalize name of an\n+\tattribute.\n+\n 2017-08-02  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/81289"}, {"sha": "606c07c602e83549852937e27b2cb7421eb815f5", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=577eec5656925889d99c658de2a54ba8bd3ebf79", "patch": "@@ -4170,9 +4170,11 @@ c_parser_attributes (c_parser *parser)\n \t  attr_name = c_parser_attribute_any_word (parser);\n \t  if (attr_name == NULL)\n \t    break;\n+\t  attr_name = canonicalize_attr_name (attr_name);\n \t  if (is_cilkplus_vector_p (attr_name))\n \t    {\n \t      c_token *v_token = c_parser_peek_token (parser);\n+\t      v_token->value = canonicalize_attr_name (v_token->value);\n \t      c_parser_cilk_simd_fn_vector_attrs (parser, *v_token);\n \t      /* If the next token isn't a comma, we're done.  */\n \t      if (!c_parser_next_token_is (parser, CPP_COMMA))\n@@ -4236,6 +4238,7 @@ c_parser_attributes (c_parser *parser)\n \t\t  release_tree_vector (expr_list);\n \t\t}\n \t    }\n+\n \t  attr = build_tree_list (attr_name, attr_args);\n \t  if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n \t    c_parser_consume_token (parser);"}, {"sha": "2e7f77a15d5e38312b242bdf3d32cf8b114362cf", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=577eec5656925889d99c658de2a54ba8bd3ebf79", "patch": "@@ -1,3 +1,10 @@\n+2017-08-07  Martin Liska  <mliska@suse.cz>\n+\n+\t* parser.c (cp_parser_gnu_attribute_list): Canonicalize name of an\n+\tattribute.\n+\t(cp_parser_std_attribute): Likewise.\n+\t* tree.c: Add new include.\n+\n 2017-08-04  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/79790"}, {"sha": "23bd2784ea4e4e5e62732b9028951a97d24ca327", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=577eec5656925889d99c658de2a54ba8bd3ebf79", "patch": "@@ -24782,7 +24782,8 @@ cp_parser_gnu_attribute_list (cp_parser* parser)\n \t       parsed identifier.  */\n \t    ? ridpointers[(int) token->keyword]\n \t    : id_token->u.value;\n-\t  \n+\n+\t  identifier = canonicalize_attr_name (identifier);\n \t  attribute = build_tree_list (identifier, NULL_TREE);\n \n \t  /* Peek at the next token.  */\n@@ -24928,6 +24929,8 @@ cp_parser_std_attribute (cp_parser *parser, tree attr_ns)\n \t\t    \"expected an identifier for the attribute name\");\n \t  return error_mark_node;\n \t}\n+\n+      attr_id = canonicalize_attr_name (attr_id);\n       attribute = build_tree_list (build_tree_list (attr_ns, attr_id),\n \t\t\t\t   NULL_TREE);\n       token = cp_lexer_peek_token (parser->lexer);\n@@ -24937,6 +24940,7 @@ cp_parser_std_attribute (cp_parser *parser, tree attr_ns)\n \t\t\t\t NULL_TREE);\n   else\n     {\n+      attr_id = canonicalize_attr_name (attr_id);\n       attribute = build_tree_list (build_tree_list (NULL_TREE, attr_id),\n \t\t\t\t   NULL_TREE);\n       /* C++11 noreturn attribute is equivalent to GNU's.  */"}, {"sha": "8f18665da4145c8eb88acb05c8dc1844f129dd71", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=577eec5656925889d99c658de2a54ba8bd3ebf79", "patch": "@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"debug.h\"\n #include \"convert.h\"\n #include \"gimplify.h\"\n+#include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"flags.h\"\n "}, {"sha": "f62fdd77dbe3f96d67f09e9942679a9186b98f76", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=577eec5656925889d99c658de2a54ba8bd3ebf79", "patch": "@@ -1,3 +1,8 @@\n+2017-08-07  Martin Liska  <mliska@suse.cz>\n+\n+\t* go-gcc.cc (Gcc_backend::function): Look up for no_split_stack\n+\tand not __no_split_stack__.\n+\n 2017-07-27    Tony Reix  <tony.reix@atos.net>\n \n \t* go-backend.c (go_write_export_data): Use EXCLUDE section for"}, {"sha": "04912f0ed0121203f525fc8347c60a65dd12efcd", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=577eec5656925889d99c658de2a54ba8bd3ebf79", "patch": "@@ -3046,7 +3046,7 @@ Gcc_backend::function(Btype* fntype, const std::string& name,\n     DECL_UNINLINABLE(decl) = 1;\n   if (disable_split_stack)\n     {\n-      tree attr = get_identifier(\"__no_split_stack__\");\n+      tree attr = get_identifier (\"no_split_stack\");\n       DECL_ATTRIBUTES(decl) = tree_cons(attr, NULL_TREE, NULL_TREE);\n     }\n   if (in_unique_section)"}, {"sha": "1e5f70508263a39598b2ff9ba0b2baf34ffe7279", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=577eec5656925889d99c658de2a54ba8bd3ebf79", "patch": "@@ -1,3 +1,10 @@\n+2017-08-07  Martin Liska  <mliska@suse.cz>\n+\n+\t* g++.dg/cpp0x/pr65558.C: Update scanned pattern.\n+\t* gcc.dg/parm-impl-decl-1.c: Likewise.\n+\t* gcc.dg/parm-impl-decl-3.c: Likewise.\n+\t* gcc.dg/Wattributes-5.c: New test.\n+\n 2017-08-06  Andrew Pinski  <apinski@cavium.com>\n \n \t* gcc.target/aarch64/target_attr_10.c: Add -mcpu=generic."}, {"sha": "12946b35eda79e63a89dfd0b3a1786bd1db50da5", "filename": "gcc/testsuite/g++.dg/cpp0x/pr65558.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr65558.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr65558.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr65558.C?ref=577eec5656925889d99c658de2a54ba8bd3ebf79", "patch": "@@ -2,6 +2,6 @@\n // { dg-do compile { target c++11 } }\n \n inline namespace\n-__attribute__((__abi_tag__)) // { dg-warning \"ignoring .__abi_tag__. attribute on anonymous namespace\" }\n+__attribute__((__abi_tag__)) // { dg-warning \"ignoring .abi_tag. attribute on anonymous namespace\" }\n {\n }"}, {"sha": "34483391e6df23150ed002da764c7d9374651f24", "filename": "gcc/testsuite/gcc.dg/Wattributes-5.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Ftestsuite%2Fgcc.dg%2FWattributes-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Ftestsuite%2Fgcc.dg%2FWattributes-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWattributes-5.c?ref=577eec5656925889d99c658de2a54ba8bd3ebf79", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options -Wattributes } */\n+\n+void __attribute__((_foobar)) foo() { }\t\t/* { dg-warning \"attribute directive ignored\" } */\n+void __attribute__((_xformat__)) foo2() { }\t/* { dg-warning \"attribute directive ignored\" } */\n+void __attribute__((xformat__)) foo3() { }\t/* { dg-warning \"attribute directive ignored\" } */\n+void __attribute__((__xformat)) foo4() { }\t/* { dg-warning \"attribute directive ignored\" } */\n+void __attribute__((_)) foo5() { }\t/* { dg-warning \"attribute directive ignored\" } */\n+void __attribute__((_)) foo6() { }\t/* { dg-warning \"attribute directive ignored\" } */\n+void __attribute__((__)) foo7() { }\t/* { dg-warning \"attribute directive ignored\" } */\n+void __attribute__((___)) foo8() { }\t/* { dg-warning \"attribute directive ignored\" } */\n+void __attribute__((____)) foo9() { }\t/* { dg-warning \"attribute directive ignored\" } */\n+void __attribute__((_____)) foo10() { }\t/* { dg-warning \"attribute directive ignored\" } */"}, {"sha": "c1219273c7523d99aef26e1a32a4b257fdf19a30", "filename": "gcc/testsuite/gcc.dg/parm-impl-decl-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Ftestsuite%2Fgcc.dg%2Fparm-impl-decl-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Ftestsuite%2Fgcc.dg%2Fparm-impl-decl-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fparm-impl-decl-1.c?ref=577eec5656925889d99c658de2a54ba8bd3ebf79", "patch": "@@ -7,7 +7,7 @@\n /* Implicit function declaration in attribute in definition (testcase\n    from bug).  */\n int\n-foo (int __attribute__ ((__mode__ (vector_size(8)))) i) /* { dg-warning \"'__mode__' attribute ignored\" } */\n+foo (int __attribute__ ((__mode__ (vector_size(8)))) i) /* { dg-warning \"'mode' attribute ignored\" } */\n {\n   return (long long) i;\n }"}, {"sha": "20197b52402ca12d47518fee816e9ee5f199602f", "filename": "gcc/testsuite/gcc.dg/parm-impl-decl-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Ftestsuite%2Fgcc.dg%2Fparm-impl-decl-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Ftestsuite%2Fgcc.dg%2Fparm-impl-decl-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fparm-impl-decl-3.c?ref=577eec5656925889d99c658de2a54ba8bd3ebf79", "patch": "@@ -4,7 +4,7 @@\n /* { dg-options \"-g -std=gnu89\" } */\n \n int\n-foo (int __attribute__ ((__mode__ (vector_size(8)))) i) /* { dg-warning \"'__mode__' attribute ignored\" } */\n+foo (int __attribute__ ((__mode__ (vector_size(8)))) i) /* { dg-warning \"'mode' attribute ignored\" } */\n {\n   return (long long) i;\n }"}, {"sha": "affde64d2fdba719fabe7650a8b8eabf7da602ea", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=577eec5656925889d99c658de2a54ba8bd3ebf79", "patch": "@@ -57,7 +57,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"builtins.h\"\n #include \"tree-chkp.h\"\n-\n+#include \"stringpool.h\"\n+#include \"attribs.h\"\n \n /* I'm not real happy about this, but we need to handle gimple and\n    non-gimple trees.  */"}, {"sha": "2b65cb1d125cf4834460f340d940131f0ce0f6b5", "filename": "gcc/tree.c", "status": "modified", "additions": 14, "deletions": 90, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=577eec5656925889d99c658de2a54ba8bd3ebf79", "patch": "@@ -4946,9 +4946,8 @@ simple_cst_list_equal (const_tree l1, const_tree l2)\n   return l1 == l2;\n }\n \n-/* Compare two identifier nodes representing attributes.  Either one may\n-   be in wrapped __ATTR__ form.  Return true if they are the same, false\n-   otherwise.  */\n+/* Compare two identifier nodes representing attributes.\n+   Return true if they are the same, false otherwise.  */\n \n static bool\n cmp_attrib_identifiers (const_tree attr1, const_tree attr2)\n@@ -4961,34 +4960,8 @@ cmp_attrib_identifiers (const_tree attr1, const_tree attr2)\n   if (attr1 == attr2)\n     return true;\n \n-  /* If they are not equal, they may still be one in the form\n-     'text' while the other one is in the form '__text__'.  TODO:\n-     If we were storing attributes in normalized 'text' form, then\n-     this could all go away and we could take full advantage of\n-     the fact that we're comparing identifiers. :-)  */\n-  const size_t attr1_len = IDENTIFIER_LENGTH (attr1);\n-  const size_t attr2_len = IDENTIFIER_LENGTH (attr2);\n-\n-  if (attr2_len == attr1_len + 4)\n-    {\n-      const char *p = IDENTIFIER_POINTER (attr2);\n-      const char *q = IDENTIFIER_POINTER (attr1);\n-      if (p[0] == '_' && p[1] == '_'\n-\t  && p[attr2_len - 2] == '_' && p[attr2_len - 1] == '_'\n-\t  && strncmp (q, p + 2, attr1_len) == 0)\n-\treturn true;;\n-    }\n-  else if (attr2_len + 4 == attr1_len)\n-    {\n-      const char *p = IDENTIFIER_POINTER (attr2);\n-      const char *q = IDENTIFIER_POINTER (attr1);\n-      if (q[0] == '_' && q[1] == '_'\n-\t  && q[attr1_len - 2] == '_' && q[attr1_len - 1] == '_'\n-\t  && strncmp (q + 2, p, attr2_len) == 0)\n-\treturn true;\n-    }\n-\n-  return false;\n+  return cmp_attribs (IDENTIFIER_POINTER (attr1), IDENTIFIER_LENGTH (attr1),\n+\t\t      IDENTIFIER_POINTER (attr2), IDENTIFIER_LENGTH (attr2));\n }\n \n /* Compare two attributes for their value identity.  Return true if the\n@@ -6051,58 +6024,18 @@ make_pass_ipa_free_lang_data (gcc::context *ctxt)\n   return new pass_ipa_free_lang_data (ctxt);\n }\n \n-/* The backbone of is_attribute_p().  ATTR_LEN is the string length of\n-   ATTR_NAME.  Also used internally by remove_attribute().  */\n-bool\n-private_is_attribute_p (const char *attr_name, size_t attr_len, const_tree ident)\n-{\n-  size_t ident_len = IDENTIFIER_LENGTH (ident);\n-\n-  if (ident_len == attr_len)\n-    {\n-      if (id_equal (ident, attr_name))\n-\treturn true;\n-    }\n-  else if (ident_len == attr_len + 4)\n-    {\n-      /* There is the possibility that ATTR is 'text' and IDENT is\n-\t '__text__'.  */\n-      const char *p = IDENTIFIER_POINTER (ident);      \n-      if (p[0] == '_' && p[1] == '_'\n-\t  && p[ident_len - 2] == '_' && p[ident_len - 1] == '_'\n-\t  && strncmp (attr_name, p + 2, attr_len) == 0)\n-\treturn true;\n-    }\n-\n-  return false;\n-}\n-\n /* The backbone of lookup_attribute().  ATTR_LEN is the string length\n    of ATTR_NAME, and LIST is not NULL_TREE.  */\n tree\n private_lookup_attribute (const char *attr_name, size_t attr_len, tree list)\n {\n   while (list)\n     {\n-      size_t ident_len = IDENTIFIER_LENGTH (get_attribute_name (list));\n-\n-      if (ident_len == attr_len)\n-\t{\n-\t  if (!strcmp (attr_name,\n-\t\t       IDENTIFIER_POINTER (get_attribute_name (list))))\n-\t    break;\n-\t}\n-      /* TODO: If we made sure that attributes were stored in the\n-\t canonical form without '__...__' (ie, as in 'text' as opposed\n-\t to '__text__') then we could avoid the following case.  */\n-      else if (ident_len == attr_len + 4)\n-\t{\n-\t  const char *p = IDENTIFIER_POINTER (get_attribute_name (list));\n-\t  if (p[0] == '_' && p[1] == '_'\n-\t      && p[ident_len - 2] == '_' && p[ident_len - 1] == '_'\n-\t      && strncmp (attr_name, p + 2, attr_len) == 0)\n-\t    break;\n-\t}\n+      tree attr = get_attribute_name (list);\n+      size_t ident_len = IDENTIFIER_LENGTH (attr);\n+      if (cmp_attribs (attr_name, attr_len, IDENTIFIER_POINTER (attr),\n+\t\t       ident_len))\n+\tbreak;\n       list = TREE_CHAIN (list);\n     }\n \n@@ -6111,8 +6044,7 @@ private_lookup_attribute (const char *attr_name, size_t attr_len, tree list)\n \n /* Given an attribute name ATTR_NAME and a list of attributes LIST,\n    return a pointer to the attribute's list first element if the attribute\n-   starts with ATTR_NAME. ATTR_NAME must be in the form 'text' (not\n-   '__text__').  */\n+   starts with ATTR_NAME.  */\n \n tree\n private_lookup_attribute_by_prefix (const char *attr_name, size_t attr_len,\n@@ -6129,17 +6061,11 @@ private_lookup_attribute_by_prefix (const char *attr_name, size_t attr_len,\n \t}\n \n       const char *p = IDENTIFIER_POINTER (get_attribute_name (list));\n+      gcc_checking_assert (attr_len == 0 || p[0] != '_');\n \n       if (strncmp (attr_name, p, attr_len) == 0)\n \tbreak;\n \n-      /* TODO: If we made sure that attributes were stored in the\n-\t canonical form without '__...__' (ie, as in 'text' as opposed\n-\t to '__text__') then we could avoid the following case.  */\n-      if (p[0] == '_' && p[1] == '_' &&\n-\t  strncmp (attr_name, p + 2, attr_len) == 0)\n-\tbreak;\n-\n       list = TREE_CHAIN (list);\n     }\n \n@@ -6185,16 +6111,14 @@ tree\n remove_attribute (const char *attr_name, tree list)\n {\n   tree *p;\n-  size_t attr_len = strlen (attr_name);\n-\n   gcc_checking_assert (attr_name[0] != '_');\n \n   for (p = &list; *p; )\n     {\n       tree l = *p;\n-      /* TODO: If we were storing attributes in normalized form, here\n-\t we could use a simple strcmp().  */\n-      if (private_is_attribute_p (attr_name, attr_len, get_attribute_name (l)))\n+\n+      tree attr = get_attribute_name (l);\n+      if (is_attribute_p (attr_name, attr))\n \t*p = TREE_CHAIN (l);\n       else\n \tp = &TREE_CHAIN (l);"}, {"sha": "1e89809804c9c033c881f0ac5c72483307cd91e2", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/577eec5656925889d99c658de2a54ba8bd3ebf79/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=577eec5656925889d99c658de2a54ba8bd3ebf79", "patch": "@@ -4195,29 +4195,8 @@ lookup_attribute_by_prefix (const char *attr_name, tree list)\n \t\t\t\t\t       list);\n }\n \n-\n-/* This function is a private implementation detail of\n-   is_attribute_p() and you should never call it directly.  */\n-extern bool private_is_attribute_p (const char *, size_t, const_tree);\n-\n-/* Given an identifier node IDENT and a string ATTR_NAME, return true\n-   if the identifier node is a valid attribute name for the string.\n-   ATTR_NAME must be in the form 'text' (not '__text__').  IDENT could\n-   be the identifier for 'text' or for '__text__'.  */\n-\n-static inline bool\n-is_attribute_p (const char *attr_name, const_tree ident)\n-{\n-  gcc_checking_assert (attr_name[0] != '_');\n-  /* Do the strlen() before calling the out-of-line implementation.\n-     In most cases attr_name is a string constant, and the compiler\n-     will optimize the strlen() away.  */\n-  return private_is_attribute_p (attr_name, strlen (attr_name), ident);\n-}\n-\n /* Remove any instances of attribute ATTR_NAME in LIST and return the\n-   modified list.  ATTR_NAME must be in the form 'text' (not\n-   '__text__').  */\n+   modified list.  */\n \n extern tree remove_attribute (const char *, tree);\n "}]}