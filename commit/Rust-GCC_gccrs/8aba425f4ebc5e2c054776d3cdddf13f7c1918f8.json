{"sha": "8aba425f4ebc5e2c054776d3cdddf13f7c1918f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFiYTQyNWY0ZWJjNWUyYzA1NDc3NmQzY2RkZGYxM2Y3YzE5MThmOA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-02-13T09:04:11Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-02-13T09:04:11Z"}, "message": "sccvn: Handle bitfields in vn_reference_lookup_3 [PR93582]\n\nThe following patch is first step towards fixing PR93582.\nvn_reference_lookup_3 right now punts on anything that isn't byte aligned,\nso to be able to lookup a constant bitfield store, one needs to use\nthe exact same COMPONENT_REF, otherwise it isn't found.\n\nThis patch lifts up that that restriction if the bits to be loaded are\ncovered by a single store of a constant (keeps the restriction so far\nfor the multiple store case, can tweak that incrementally, but I think\nfor bisection etc. it is worth to do it one step at a time).\n\n2020-02-13  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/93582\n\t* fold-const.h (shift_bytes_in_array_left,\n\tshift_bytes_in_array_right): Declare.\n\t* fold-const.c (shift_bytes_in_array_left,\n\tshift_bytes_in_array_right): New function, moved from\n\tgimple-ssa-store-merging.c, no longer static.\n\t* gimple-ssa-store-merging.c (shift_bytes_in_array): Move\n\tto gimple-ssa-store-merging.c and rename to shift_bytes_in_array_left.\n\t(shift_bytes_in_array_right): Move to gimple-ssa-store-merging.c.\n\t(encode_tree_to_bitpos): Use shift_bytes_in_array_left instead of\n\tshift_bytes_in_array.\n\t(verify_shift_bytes_in_array): Rename to ...\n\t(verify_shift_bytes_in_array_left): ... this.  Use\n\tshift_bytes_in_array_left instead of shift_bytes_in_array.\n\t(store_merging_c_tests): Call verify_shift_bytes_in_array_left\n\tinstead of verify_shift_bytes_in_array.\n\t* tree-ssa-sccvn.c (vn_reference_lookup_3): For native_encode_expr\n\t/ native_interpret_expr where the store covers all needed bits,\n\tpunt on PDP-endian, otherwise allow all involved offsets and sizes\n\tnot to be byte-aligned.\n\n\t* gcc.dg/tree-ssa/pr93582-1.c: New test.\n\t* gcc.dg/tree-ssa/pr93582-2.c: New test.\n\t* gcc.dg/tree-ssa/pr93582-3.c: New test.", "tree": {"sha": "b99f04913cac6d23c8d1bccea47a2a03a9d44c98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b99f04913cac6d23c8d1bccea47a2a03a9d44c98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8aba425f4ebc5e2c054776d3cdddf13f7c1918f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aba425f4ebc5e2c054776d3cdddf13f7c1918f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8aba425f4ebc5e2c054776d3cdddf13f7c1918f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aba425f4ebc5e2c054776d3cdddf13f7c1918f8/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ea884b85e338d09b14e6a54043c53ae0c1b1fe9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ea884b85e338d09b14e6a54043c53ae0c1b1fe9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ea884b85e338d09b14e6a54043c53ae0c1b1fe9"}], "stats": {"total": 310, "additions": 222, "deletions": 88}, "files": [{"sha": "36a8956d8da84812fd7624e79025095ae59dfdfc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aba425f4ebc5e2c054776d3cdddf13f7c1918f8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aba425f4ebc5e2c054776d3cdddf13f7c1918f8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8aba425f4ebc5e2c054776d3cdddf13f7c1918f8", "patch": "@@ -1,5 +1,26 @@\n 2020-02-13  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR tree-optimization/93582\n+\t* fold-const.h (shift_bytes_in_array_left,\n+\tshift_bytes_in_array_right): Declare.\n+\t* fold-const.c (shift_bytes_in_array_left,\n+\tshift_bytes_in_array_right): New function, moved from\n+\tgimple-ssa-store-merging.c, no longer static.\n+\t* gimple-ssa-store-merging.c (shift_bytes_in_array): Move\n+\tto gimple-ssa-store-merging.c and rename to shift_bytes_in_array_left.\n+\t(shift_bytes_in_array_right): Move to gimple-ssa-store-merging.c.\n+\t(encode_tree_to_bitpos): Use shift_bytes_in_array_left instead of\n+\tshift_bytes_in_array.\n+\t(verify_shift_bytes_in_array): Rename to ...\n+\t(verify_shift_bytes_in_array_left): ... this.  Use\n+\tshift_bytes_in_array_left instead of shift_bytes_in_array.\n+\t(store_merging_c_tests): Call verify_shift_bytes_in_array_left\n+\tinstead of verify_shift_bytes_in_array.\n+\t* tree-ssa-sccvn.c (vn_reference_lookup_3): For native_encode_expr\n+\t/ native_interpret_expr where the store covers all needed bits,\n+\tpunt on PDP-endian, otherwise allow all involved offsets and sizes\n+\tnot to be byte-aligned.\n+\n \tPR target/93673\n \t* config/i386/sse.md (k<code><mode>): Drop mode from last operand and\n \tuse const_0_to_255_operand predicate instead of immediate_operand."}, {"sha": "71a1d3eb735e2a35ee2ba86ed82c161a2ba56ffb", "filename": "gcc/fold-const.c", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aba425f4ebc5e2c054776d3cdddf13f7c1918f8/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aba425f4ebc5e2c054776d3cdddf13f7c1918f8/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=8aba425f4ebc5e2c054776d3cdddf13f7c1918f8", "patch": "@@ -8354,6 +8354,70 @@ can_native_interpret_type_p (tree type)\n     }\n }\n \n+/* Routines for manipulation of native_encode_expr encoded data if the encoded\n+   or extracted constant positions and/or sizes aren't byte aligned.  */\n+\n+/* Shift left the bytes in PTR of SZ elements by AMNT bits, carrying over the\n+   bits between adjacent elements.  AMNT should be within\n+   [0, BITS_PER_UNIT).\n+   Example, AMNT = 2:\n+   00011111|11100000 << 2 = 01111111|10000000\n+   PTR[1]  | PTR[0]         PTR[1]  | PTR[0].  */\n+\n+void\n+shift_bytes_in_array_left (unsigned char *ptr, unsigned int sz,\n+\t\t\t   unsigned int amnt)\n+{\n+  if (amnt == 0)\n+    return;\n+\n+  unsigned char carry_over = 0U;\n+  unsigned char carry_mask = (~0U) << (unsigned char) (BITS_PER_UNIT - amnt);\n+  unsigned char clear_mask = (~0U) << amnt;\n+\n+  for (unsigned int i = 0; i < sz; i++)\n+    {\n+      unsigned prev_carry_over = carry_over;\n+      carry_over = (ptr[i] & carry_mask) >> (BITS_PER_UNIT - amnt);\n+\n+      ptr[i] <<= amnt;\n+      if (i != 0)\n+\t{\n+\t  ptr[i] &= clear_mask;\n+\t  ptr[i] |= prev_carry_over;\n+\t}\n+    }\n+}\n+\n+/* Like shift_bytes_in_array_left but for big-endian.\n+   Shift right the bytes in PTR of SZ elements by AMNT bits, carrying over the\n+   bits between adjacent elements.  AMNT should be within\n+   [0, BITS_PER_UNIT).\n+   Example, AMNT = 2:\n+   00011111|11100000 >> 2 = 00000111|11111000\n+   PTR[0]  | PTR[1]         PTR[0]  | PTR[1].  */\n+\n+void\n+shift_bytes_in_array_right (unsigned char *ptr, unsigned int sz,\n+\t\t\t    unsigned int amnt)\n+{\n+  if (amnt == 0)\n+    return;\n+\n+  unsigned char carry_over = 0U;\n+  unsigned char carry_mask = ~(~0U << amnt);\n+\n+  for (unsigned int i = 0; i < sz; i++)\n+    {\n+      unsigned prev_carry_over = carry_over;\n+      carry_over = ptr[i] & carry_mask;\n+\n+      carry_over <<= (unsigned char) BITS_PER_UNIT - amnt;\n+      ptr[i] >>= amnt;\n+      ptr[i] |= prev_carry_over;\n+    }\n+}\n+\n /* Try to view-convert VECTOR_CST EXPR to VECTOR_TYPE TYPE by operating\n    directly on the VECTOR_CST encoding, in a way that works for variable-\n    length vectors.  Return the resulting VECTOR_CST on success or null"}, {"sha": "0f788a458f21e802431fdeaaa449c20e35c0b048", "filename": "gcc/fold-const.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aba425f4ebc5e2c054776d3cdddf13f7c1918f8/gcc%2Ffold-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aba425f4ebc5e2c054776d3cdddf13f7c1918f8/gcc%2Ffold-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.h?ref=8aba425f4ebc5e2c054776d3cdddf13f7c1918f8", "patch": "@@ -30,6 +30,10 @@ extern int native_encode_initializer (tree, unsigned char *, int,\n \t\t\t\t      int off = -1);\n extern tree native_interpret_expr (tree, const unsigned char *, int);\n extern bool can_native_interpret_type_p (tree);\n+extern void shift_bytes_in_array_left (unsigned char *, unsigned int,\n+\t\t\t\t       unsigned int);\n+extern void shift_bytes_in_array_right (unsigned char *, unsigned int,\n+\t\t\t\t\tunsigned int);\n \n /* Fold constants as much as possible in an expression.\n    Returns the simplified expression."}, {"sha": "4bcafef4878988d6b0896c6e3a860ccd6b957878", "filename": "gcc/gimple-ssa-store-merging.c", "status": "modified", "additions": 6, "deletions": 66, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aba425f4ebc5e2c054776d3cdddf13f7c1918f8/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aba425f4ebc5e2c054776d3cdddf13f7c1918f8/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=8aba425f4ebc5e2c054776d3cdddf13f7c1918f8", "patch": "@@ -1475,66 +1475,6 @@ dump_char_array (FILE *fd, unsigned char *ptr, unsigned int len)\n   fprintf (fd, \"\\n\");\n }\n \n-/* Shift left the bytes in PTR of SZ elements by AMNT bits, carrying over the\n-   bits between adjacent elements.  AMNT should be within\n-   [0, BITS_PER_UNIT).\n-   Example, AMNT = 2:\n-   00011111|11100000 << 2 = 01111111|10000000\n-   PTR[1]  | PTR[0]         PTR[1]  | PTR[0].  */\n-\n-static void\n-shift_bytes_in_array (unsigned char *ptr, unsigned int sz, unsigned int amnt)\n-{\n-  if (amnt == 0)\n-    return;\n-\n-  unsigned char carry_over = 0U;\n-  unsigned char carry_mask = (~0U) << (unsigned char) (BITS_PER_UNIT - amnt);\n-  unsigned char clear_mask = (~0U) << amnt;\n-\n-  for (unsigned int i = 0; i < sz; i++)\n-    {\n-      unsigned prev_carry_over = carry_over;\n-      carry_over = (ptr[i] & carry_mask) >> (BITS_PER_UNIT - amnt);\n-\n-      ptr[i] <<= amnt;\n-      if (i != 0)\n-\t{\n-\t  ptr[i] &= clear_mask;\n-\t  ptr[i] |= prev_carry_over;\n-\t}\n-    }\n-}\n-\n-/* Like shift_bytes_in_array but for big-endian.\n-   Shift right the bytes in PTR of SZ elements by AMNT bits, carrying over the\n-   bits between adjacent elements.  AMNT should be within\n-   [0, BITS_PER_UNIT).\n-   Example, AMNT = 2:\n-   00011111|11100000 >> 2 = 00000111|11111000\n-   PTR[0]  | PTR[1]         PTR[0]  | PTR[1].  */\n-\n-static void\n-shift_bytes_in_array_right (unsigned char *ptr, unsigned int sz,\n-\t\t\t    unsigned int amnt)\n-{\n-  if (amnt == 0)\n-    return;\n-\n-  unsigned char carry_over = 0U;\n-  unsigned char carry_mask = ~(~0U << amnt);\n-\n-  for (unsigned int i = 0; i < sz; i++)\n-    {\n-      unsigned prev_carry_over = carry_over;\n-      carry_over = ptr[i] & carry_mask;\n-\n-      carry_over <<= (unsigned char) BITS_PER_UNIT - amnt;\n-      ptr[i] >>= amnt;\n-      ptr[i] |= prev_carry_over;\n-    }\n-}\n-\n /* Clear out LEN bits starting from bit START in the byte array\n    PTR.  This clears the bits to the *right* from START.\n    START must be within [0, BITS_PER_UNIT) and counts starting from\n@@ -1793,7 +1733,7 @@ encode_tree_to_bitpos (tree expr, unsigned char *ptr, int bitlen, int bitpos,\n   /* Create the shifted version of EXPR.  */\n   if (!BYTES_BIG_ENDIAN)\n     {\n-      shift_bytes_in_array (tmpbuf, byte_size, shift_amnt);\n+      shift_bytes_in_array_left (tmpbuf, byte_size, shift_amnt);\n       if (shift_amnt == 0)\n \tbyte_size--;\n     }\n@@ -5092,11 +5032,11 @@ verify_array_eq (unsigned char *x, unsigned char *y, unsigned int n)\n     }\n }\n \n-/* Test shift_bytes_in_array and that it carries bits across between\n+/* Test shift_bytes_in_array_left and that it carries bits across between\n    bytes correctly.  */\n \n static void\n-verify_shift_bytes_in_array (void)\n+verify_shift_bytes_in_array_left (void)\n {\n    /* byte 1   | byte 0\n       00011111 | 11100000.  */\n@@ -5105,13 +5045,13 @@ verify_shift_bytes_in_array (void)\n   memcpy (in, orig, sizeof orig);\n \n   unsigned char expected[2] = { 0x80, 0x7f };\n-  shift_bytes_in_array (in, sizeof (in), 2);\n+  shift_bytes_in_array_left (in, sizeof (in), 2);\n   verify_array_eq (in, expected, sizeof (in));\n \n   memcpy (in, orig, sizeof orig);\n   memcpy (expected, orig, sizeof orig);\n   /* Check that shifting by zero doesn't change anything.  */\n-  shift_bytes_in_array (in, sizeof (in), 0);\n+  shift_bytes_in_array_left (in, sizeof (in), 0);\n   verify_array_eq (in, expected, sizeof (in));\n \n }\n@@ -5196,7 +5136,7 @@ verify_clear_bit_region_be (void)\n void\n store_merging_c_tests (void)\n {\n-  verify_shift_bytes_in_array ();\n+  verify_shift_bytes_in_array_left ();\n   verify_shift_bytes_in_array_right ();\n   verify_clear_bit_region ();\n   verify_clear_bit_region_be ();"}, {"sha": "25413537503cc03d96347e21ecc23a063b68f0fc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aba425f4ebc5e2c054776d3cdddf13f7c1918f8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aba425f4ebc5e2c054776d3cdddf13f7c1918f8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8aba425f4ebc5e2c054776d3cdddf13f7c1918f8", "patch": "@@ -1,3 +1,10 @@\n+2020-02-13  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/93582\n+\t* gcc.dg/tree-ssa/pr93582-1.c: New test.\n+\t* gcc.dg/tree-ssa/pr93582-2.c: New test.\n+\t* gcc.dg/tree-ssa/pr93582-3.c: New test.\n+\n 2020-02-13  Richard Biener  <rguenther@suse.de>\n \n \tPR testsuite/93717"}, {"sha": "a9f0e34ab07878c96ceaa838cbf04aaf66d9f1d8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr93582-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aba425f4ebc5e2c054776d3cdddf13f7c1918f8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93582-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aba425f4ebc5e2c054776d3cdddf13f7c1918f8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93582-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93582-1.c?ref=8aba425f4ebc5e2c054776d3cdddf13f7c1918f8", "patch": "@@ -0,0 +1,17 @@\n+/* PR tree-optimization/93582 */\n+/* { dg-do compile { target int32 } } */\n+/* { dg-options \"-O2 -fdump-tree-fre1\" } */\n+/* { dg-final { scan-tree-dump \"return 1;\" \"fre1\" } } */\n+\n+union U {\n+  struct S { int a : 1, b : 4, c : 27; } s;\n+  struct T { int d : 2; int e : 2; int f : 28; } t;\n+};\n+\n+int\n+foo (void)\n+{\n+  union U u;\n+  u.s.b = 10;\n+  return u.t.e;\n+}"}, {"sha": "76d03ece43ca5fb97382eaee347c63cbf65b5338", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr93582-2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aba425f4ebc5e2c054776d3cdddf13f7c1918f8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93582-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aba425f4ebc5e2c054776d3cdddf13f7c1918f8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93582-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93582-2.c?ref=8aba425f4ebc5e2c054776d3cdddf13f7c1918f8", "patch": "@@ -0,0 +1,17 @@\n+/* PR tree-optimization/93582 */\n+/* { dg-do compile { target int32 } } */\n+/* { dg-options \"-O2 -fdump-tree-fre1\" } */\n+/* { dg-final { scan-tree-dump \"return 593;\" \"fre1\" } } */\n+\n+union U {\n+  struct S { int a : 1, b : 14, c : 17; } s;\n+  struct T { int d : 2; int e : 12; int f : 18; } t;\n+};\n+\n+int\n+foo (void)\n+{\n+  union U u;\n+  u.s.b = -7005;\n+  return u.t.e;\n+}"}, {"sha": "84f54fc3142c717e58742ac27121da949f40e082", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr93582-3.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aba425f4ebc5e2c054776d3cdddf13f7c1918f8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93582-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aba425f4ebc5e2c054776d3cdddf13f7c1918f8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93582-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93582-3.c?ref=8aba425f4ebc5e2c054776d3cdddf13f7c1918f8", "patch": "@@ -0,0 +1,18 @@\n+/* PR tree-optimization/93582 */\n+/* { dg-do compile { target int32 } } */\n+/* { dg-options \"-O2 -fdump-tree-fre1\" } */\n+/* { dg-final { scan-tree-dump \"return 1;\" \"fre1\" { target be } } } */\n+/* { dg-final { scan-tree-dump \"return 2;\" \"fre1\" { target le } } } */\n+\n+union U {\n+  struct S { int a : 1, b : 14, c : 17; } s;\n+  struct T { int d : 10; int e : 4; int f : 18; } t;\n+};\n+\n+int\n+foo (void)\n+{\n+  union U u;\n+  u.s.b = -7005;\n+  return u.t.e;\n+}"}, {"sha": "30518abfddd59d8f0a5d687b308b822d0c584c67", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 68, "deletions": 22, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aba425f4ebc5e2c054776d3cdddf13f7c1918f8/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aba425f4ebc5e2c054776d3cdddf13f7c1918f8/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=8aba425f4ebc5e2c054776d3cdddf13f7c1918f8", "patch": "@@ -2586,13 +2586,13 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t   && is_gimple_reg_type (vr->type)\n \t   && !contains_storage_order_barrier_p (vr->operands)\n \t   && gimple_assign_single_p (def_stmt)\n-\t   && CHAR_BIT == 8 && BITS_PER_UNIT == 8\n+\t   && CHAR_BIT == 8\n+\t   && BITS_PER_UNIT == 8\n+\t   && BYTES_BIG_ENDIAN == WORDS_BIG_ENDIAN\n \t   /* native_encode and native_decode operate on arrays of bytes\n \t      and so fundamentally need a compile-time size and offset.  */\n \t   && maxsize.is_constant (&maxsizei)\n-\t   && maxsizei % BITS_PER_UNIT == 0\n \t   && offset.is_constant (&offseti)\n-\t   && offseti % BITS_PER_UNIT == 0\n \t   && (is_gimple_min_invariant (gimple_assign_rhs1 (def_stmt))\n \t       || (TREE_CODE (gimple_assign_rhs1 (def_stmt)) == SSA_NAME\n \t\t   && is_gimple_min_invariant (SSA_VAL (gimple_assign_rhs1 (def_stmt))))))\n@@ -2617,8 +2617,6 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t  && !reverse\n \t  && !storage_order_barrier_p (lhs)\n \t  && known_eq (maxsize2, size2)\n-\t  && multiple_p (size2, BITS_PER_UNIT)\n-\t  && multiple_p (offset2, BITS_PER_UNIT)\n \t  && adjust_offsets_for_equal_base_address (base, &offset,\n \t\t\t\t\t\t    base2, &offset2)\n \t  && offset.is_constant (&offseti)\n@@ -2629,37 +2627,80 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t      && known_subrange_p (offseti, maxsizei, offset2, size2))\n \t    {\n \t      /* We support up to 512-bit values (for V8DFmode).  */\n-\t      unsigned char buffer[64];\n+\t      unsigned char buffer[65];\n \t      int len;\n \n \t      tree rhs = gimple_assign_rhs1 (def_stmt);\n \t      if (TREE_CODE (rhs) == SSA_NAME)\n \t\trhs = SSA_VAL (rhs);\n-\t      unsigned pad = 0;\n-\t      if (BYTES_BIG_ENDIAN\n-\t\t  && is_a <scalar_mode> (TYPE_MODE (TREE_TYPE (rhs))))\n-\t\t{\n-\t\t  /* On big-endian the padding is at the 'front' so\n-\t\t     just skip the initial bytes.  */\n-\t\t  fixed_size_mode mode\n-\t\t    = as_a <fixed_size_mode> (TYPE_MODE (TREE_TYPE (rhs)));\n-\t\t  pad = GET_MODE_SIZE (mode) - size2i / BITS_PER_UNIT;\n-\t\t}\n \t      len = native_encode_expr (rhs,\n-\t\t\t\t\tbuffer, sizeof (buffer),\n-\t\t\t\t\t((offseti - offset2i) / BITS_PER_UNIT\n-\t\t\t\t\t + pad));\n+\t\t\t\t\tbuffer, sizeof (buffer) - 1,\n+\t\t\t\t\t(offseti - offset2i) / BITS_PER_UNIT);\n \t      if (len > 0 && len * BITS_PER_UNIT >= maxsizei)\n \t\t{\n \t\t  tree type = vr->type;\n+\t\t  unsigned char *buf = buffer;\n+\t\t  unsigned int amnt = 0;\n \t\t  /* Make sure to interpret in a type that has a range\n \t\t     covering the whole access size.  */\n \t\t  if (INTEGRAL_TYPE_P (vr->type)\n \t\t      && maxsizei != TYPE_PRECISION (vr->type))\n \t\t    type = build_nonstandard_integer_type (maxsizei,\n \t\t\t\t\t\t\t   TYPE_UNSIGNED (type));\n-\t\t  tree val = native_interpret_expr (type, buffer,\n-\t\t\t\t\t\t    maxsizei / BITS_PER_UNIT);\n+\t\t  if (BYTES_BIG_ENDIAN)\n+\t\t    {\n+\t\t      /* For big-endian native_encode_expr stored the rhs\n+\t\t\t such that the LSB of it is the LSB of buffer[len - 1].\n+\t\t\t That bit is stored into memory at position\n+\t\t\t offset2 + size2 - 1, i.e. in byte\n+\t\t\t base + (offset2 + size2 - 1) / BITS_PER_UNIT.\n+\t\t\t E.g. for offset2 1 and size2 14, rhs -1 and memory\n+\t\t\t previously cleared that is:\n+\t\t\t 0        1\n+\t\t\t 01111111|11111110\n+\t\t\t Now, if we want to extract offset 2 and size 12 from\n+\t\t\t it using native_interpret_expr (which actually works\n+\t\t\t for integral bitfield types in terms of byte size of\n+\t\t\t the mode), the native_encode_expr stored the value\n+\t\t\t into buffer as\n+\t\t\t XX111111|11111111\n+\t\t\t and returned len 2 (the X bits are outside of\n+\t\t\t precision).\n+\t\t\t Let sz be maxsize / BITS_PER_UNIT if not extracting\n+\t\t\t a bitfield, and GET_MODE_SIZE otherwise.\n+\t\t\t We need to align the LSB of the value we want to\n+\t\t\t extract as the LSB of buf[sz - 1].\n+\t\t\t The LSB from memory we need to read is at position\n+\t\t\t offset + maxsize - 1.  */\n+\t\t      HOST_WIDE_INT sz = maxsizei / BITS_PER_UNIT;\n+\t\t      if (INTEGRAL_TYPE_P (type))\n+\t\t\tsz = GET_MODE_SIZE (SCALAR_INT_TYPE_MODE (type));\n+\t\t      amnt = ((unsigned HOST_WIDE_INT) offset2i + size2i\n+\t\t\t      - offseti - maxsizei) % BITS_PER_UNIT;\n+\t\t      if (amnt)\n+\t\t\tshift_bytes_in_array_right (buffer, len, amnt);\n+\t\t      amnt = ((unsigned HOST_WIDE_INT) offset2i + size2i\n+\t\t\t      - offseti - maxsizei - amnt) / BITS_PER_UNIT;\n+\t\t      if ((unsigned HOST_WIDE_INT) sz + amnt > (unsigned) len)\n+\t\t\tlen = 0;\n+\t\t      else\n+\t\t\t{\n+\t\t\t  buf = buffer + len - sz - amnt;\n+\t\t\t  len -= (buf - buffer);\n+\t\t\t}\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      amnt = ((unsigned HOST_WIDE_INT) offset2i\n+\t\t\t      - offseti) % BITS_PER_UNIT;\n+\t\t      if (amnt)\n+\t\t\t{\n+\t\t\t  buffer[len] = 0;\n+\t\t\t  shift_bytes_in_array_left (buffer, len + 1, amnt);\n+\t\t\t  buf = buffer + 1;\n+\t\t\t}\n+\t\t    }\n+\t\t  tree val = native_interpret_expr (type, buf, len);\n \t\t  /* If we chop off bits because the types precision doesn't\n \t\t     match the memory access size this is ok when optimizing\n \t\t     reads but not when called from the DSE code during\n@@ -2677,7 +2718,12 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t\t    return data->finish (get_alias_set (lhs), val);\n \t\t}\n \t    }\n-\t  else if (ranges_known_overlap_p (offseti, maxsizei, offset2i, size2i))\n+\t  else if (ranges_known_overlap_p (offseti, maxsizei, offset2i,\n+\t\t\t\t\t   size2i)\n+\t\t   && maxsizei % BITS_PER_UNIT == 0\n+\t\t   && offseti % BITS_PER_UNIT == 0\n+\t\t   && size2i % BITS_PER_UNIT == 0\n+\t\t   && offset2i % BITS_PER_UNIT == 0)\n \t    {\n \t      pd_data pd;\n \t      tree rhs = gimple_assign_rhs1 (def_stmt);"}]}