{"sha": "21b9e1226cfbc4137a881a71c5e6f904fc5b364e", "node_id": "C_kwDOANBUbNoAKDIxYjllMTIyNmNmYmM0MTM3YTg4MWE3MWM1ZTZmOTA0ZmM1YjM2NGU", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-05-04T10:56:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-05-04T10:56:47Z"}, "message": "Merge #1206 #1209 #1211 #1212 #1213\n\n1206: Use correct format specifiers for unisnged HOST_WIDE_INT r=philberty a=philberty\n\nThe code here was wrongly assuming the unsigned long interface which is not\r\ncorrectly for all targets.\r\n\n\n1209: Allow match on boolean expressions r=philberty a=dafaust\n\nEnables compiling `match` expressions where the scrutinee is a boolean expression. Also enable compiling match arms with Literal patterns, since `true` and `false` literals are commonly used with matches on boolean expressions.\r\n\r\nFixes: #1207 \n\n1211: Preserve inside_loop context when type checking match r=philberty a=dafaust\n\nPreviously, we would lose the context of being inside a loop when compiling a `match`.\r\nThis would lead to incorrect error messages like \"cannot 'break' outside of a loop\" when\r\ntrying to break out of a loop from within a `match` expression.\r\n\r\nFixes: #1196 \r\n\n\n1212: intrinsic: add breakpoint intrinsic r=philberty a=liushuyu\n\n- intrinsic: add breakpoint intrinsic\r\n\r\nAddresses #658 \n\n1213: intrinsic: add rotate_left and rotate_right intrinsic r=philberty a=liushuyu\n\n- intrinsic: add rotate_left and rotate_right intrinsic\r\n\r\nAddress #658\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\nCo-authored-by: David Faust <david.faust@oracle.com>\nCo-authored-by: liushuyu <liushuyu011@gmail.com>", "tree": {"sha": "c1e1b67f83c2e3ae91f32e90e388432de8d0080e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1e1b67f83c2e3ae91f32e90e388432de8d0080e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21b9e1226cfbc4137a881a71c5e6f904fc5b364e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiclvvCRBK7hj4Ov3rIwAA0g4IAHxomJenSPTJuQkbhNxz/GIN\n3F4L8TEQaCNjSHDIZQa17FPEIKGYNBVDQ0djjuwmtvzw3siHmD5VphoJnHaciyLU\n0dfZBVqnC6Z3IkJLlUhlcoe4xUmTMCe98w8zFsUM/spGwW7ARtGBREVyh5kah/1v\nZEpGEArg9p/Oe75gJQF6aeSnKa1m/i+QUw0gCZtCw6wh9MGRuh4F1zgcukwT/OhV\n8zB4sQlfz7P5//pV4fxSgXm+B2wTRBOZlG5GWvolz+1tIHEhwXf2bGT0qBVPeS0J\nEGWXsnM35SOtNGlBGXQE0bfLU63MqXe34sw8cWt61mm+/FEnfXOmOfKq+kSnHaw=\n=Le3h\n-----END PGP SIGNATURE-----\n", "payload": "tree c1e1b67f83c2e3ae91f32e90e388432de8d0080e\nparent aa5ab23081958653a9b84afb0af19c4ae13fd92c\nparent 48cad9e8aed699c396afb7592dd637f2e87723dc\nparent aa372462f481aab3593ab76782f35c816365d648\nparent 0472834ddf177038d343b193acab70b2859656f8\nparent 884b93668624018e6478ba0bb0607cca768d1f2a\nparent cb22cd9da3d2d78d50dcd745e7894997fe91e4da\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1651661807 +0000\ncommitter GitHub <noreply@github.com> 1651661807 +0000\n\nMerge #1206 #1209 #1211 #1212 #1213\n\n1206: Use correct format specifiers for unisnged HOST_WIDE_INT r=philberty a=philberty\n\nThe code here was wrongly assuming the unsigned long interface which is not\r\ncorrectly for all targets.\r\n\n\n1209: Allow match on boolean expressions r=philberty a=dafaust\n\nEnables compiling `match` expressions where the scrutinee is a boolean expression. Also enable compiling match arms with Literal patterns, since `true` and `false` literals are commonly used with matches on boolean expressions.\r\n\r\nFixes: #1207 \n\n1211: Preserve inside_loop context when type checking match r=philberty a=dafaust\n\nPreviously, we would lose the context of being inside a loop when compiling a `match`.\r\nThis would lead to incorrect error messages like \"cannot 'break' outside of a loop\" when\r\ntrying to break out of a loop from within a `match` expression.\r\n\r\nFixes: #1196 \r\n\n\n1212: intrinsic: add breakpoint intrinsic r=philberty a=liushuyu\n\n- intrinsic: add breakpoint intrinsic\r\n\r\nAddresses #658 \n\n1213: intrinsic: add rotate_left and rotate_right intrinsic r=philberty a=liushuyu\n\n- intrinsic: add rotate_left and rotate_right intrinsic\r\n\r\nAddress #658\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\nCo-authored-by: David Faust <david.faust@oracle.com>\nCo-authored-by: liushuyu <liushuyu011@gmail.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21b9e1226cfbc4137a881a71c5e6f904fc5b364e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21b9e1226cfbc4137a881a71c5e6f904fc5b364e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21b9e1226cfbc4137a881a71c5e6f904fc5b364e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa5ab23081958653a9b84afb0af19c4ae13fd92c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa5ab23081958653a9b84afb0af19c4ae13fd92c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa5ab23081958653a9b84afb0af19c4ae13fd92c"}, {"sha": "48cad9e8aed699c396afb7592dd637f2e87723dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48cad9e8aed699c396afb7592dd637f2e87723dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48cad9e8aed699c396afb7592dd637f2e87723dc"}, {"sha": "aa372462f481aab3593ab76782f35c816365d648", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa372462f481aab3593ab76782f35c816365d648", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa372462f481aab3593ab76782f35c816365d648"}, {"sha": "0472834ddf177038d343b193acab70b2859656f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0472834ddf177038d343b193acab70b2859656f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0472834ddf177038d343b193acab70b2859656f8"}, {"sha": "884b93668624018e6478ba0bb0607cca768d1f2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/884b93668624018e6478ba0bb0607cca768d1f2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/884b93668624018e6478ba0bb0607cca768d1f2a"}, {"sha": "cb22cd9da3d2d78d50dcd745e7894997fe91e4da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb22cd9da3d2d78d50dcd745e7894997fe91e4da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb22cd9da3d2d78d50dcd745e7894997fe91e4da"}], "stats": {"total": 306, "additions": 281, "deletions": 25}, "files": [{"sha": "eb7b0dfc1b223226c2f889395de54ff855584a38", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 35, "deletions": 16, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21b9e1226cfbc4137a881a71c5e6f904fc5b364e/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21b9e1226cfbc4137a881a71c5e6f904fc5b364e/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=21b9e1226cfbc4137a881a71c5e6f904fc5b364e", "patch": "@@ -211,13 +211,18 @@ CompileExpr::visit (HIR::MatchExpr &expr)\n       return;\n     }\n \n-  rust_assert (scrutinee_expr_tyty->get_kind () == TyTy::TypeKind::ADT);\n+  TyTy::TypeKind scrutinee_kind = scrutinee_expr_tyty->get_kind ();\n+  rust_assert (scrutinee_kind == TyTy::TypeKind::BOOL\n+\t       || scrutinee_kind == TyTy::TypeKind::ADT);\n \n-  // this will need to change but for now the first pass implementation, lets\n-  // assert this is the case\n-  TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (scrutinee_expr_tyty);\n-  rust_assert (adt->is_enum ());\n-  rust_assert (adt->number_of_variants () > 0);\n+  if (scrutinee_kind == TyTy::TypeKind::ADT)\n+    {\n+      // this will need to change but for now the first pass implementation,\n+      // lets assert this is the case\n+      TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (scrutinee_expr_tyty);\n+      rust_assert (adt->is_enum ());\n+      rust_assert (adt->number_of_variants () > 0);\n+    }\n \n   TyTy::BaseType *expr_tyty = nullptr;\n   if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n@@ -247,16 +252,30 @@ CompileExpr::visit (HIR::MatchExpr &expr)\n   tree match_scrutinee_expr\n     = CompileExpr::Compile (expr.get_scrutinee_expr ().get (), ctx);\n \n-  // need to access the qualifier field, if we use QUAL_UNION_TYPE this would be\n-  // DECL_QUALIFIER i think. For now this will just access the first record\n-  // field and its respective qualifier because it will always be set because\n-  // this is all a big special union\n-  tree scrutinee_first_record_expr\n-    = ctx->get_backend ()->struct_field_expression (\n-      match_scrutinee_expr, 0, expr.get_scrutinee_expr ()->get_locus ());\n-  tree match_scrutinee_expr_qualifier_expr\n-    = ctx->get_backend ()->struct_field_expression (\n-      scrutinee_first_record_expr, 0, expr.get_scrutinee_expr ()->get_locus ());\n+  tree match_scrutinee_expr_qualifier_expr;\n+  if (scrutinee_kind == TyTy::TypeKind::BOOL)\n+    {\n+      match_scrutinee_expr_qualifier_expr = match_scrutinee_expr;\n+    }\n+  else if (scrutinee_kind == TyTy::TypeKind::ADT)\n+    {\n+      // need to access qualifier the field, if we use QUAL_UNION_TYPE this\n+      // would be DECL_QUALIFIER i think. For now this will just access the\n+      // first record field and its respective qualifier because it will always\n+      // be set because this is all a big special union\n+      tree scrutinee_first_record_expr\n+\t= ctx->get_backend ()->struct_field_expression (\n+\t  match_scrutinee_expr, 0, expr.get_scrutinee_expr ()->get_locus ());\n+      match_scrutinee_expr_qualifier_expr\n+\t= ctx->get_backend ()->struct_field_expression (\n+\t  scrutinee_first_record_expr, 0,\n+\t  expr.get_scrutinee_expr ()->get_locus ());\n+    }\n+  else\n+    {\n+      // FIXME: match on other types of expressions not yet implemented.\n+      gcc_assert (0);\n+    }\n \n   // setup the end label so the cases can exit properly\n   tree fndecl = fnctx.fndecl;"}, {"sha": "a7225f2ab053a2eb55d7a164dc8da6d8fb86e2ff", "filename": "gcc/rust/backend/rust-compile-intrinsic.cc", "status": "modified", "additions": 128, "deletions": 1, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21b9e1226cfbc4137a881a71c5e6f904fc5b364e/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21b9e1226cfbc4137a881a71c5e6f904fc5b364e/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc?ref=21b9e1226cfbc4137a881a71c5e6f904fc5b364e", "patch": "@@ -15,10 +15,13 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-compile-intrinsic.h\"\n+#include \"fold-const.h\"\n #include \"langhooks.h\"\n+#include \"rust-compile-context.h\"\n #include \"rust-compile-type.h\"\n #include \"rust-compile-fnparam.h\"\n #include \"rust-tree.h\"\n+#include \"tree-core.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -117,6 +120,10 @@ class SimpleIntrinsics\n     define_builtin (\"abort\", BUILT_IN_ABORT, \"__builtin_abort\", \"abort\",\n \t\t    build_function_type (void_type_node, void_list_node),\n \t\t    builtin_const | builtin_noreturn);\n+\n+    define_builtin (\"breakpoint\", BUILT_IN_TRAP, \"__builtin_trap\", \"breakpoint\",\n+\t\t    build_function_type (void_type_node, void_list_node),\n+\t\t    builtin_const | builtin_noreturn);\n   }\n \n   // Define a builtin function.  BCODE is the builtin function code\n@@ -176,12 +183,26 @@ static tree\n sizeof_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype);\n static tree\n transmute_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype);\n+static tree\n+rotate_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype, tree_code op);\n+static inline tree\n+rotate_left_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype)\n+{\n+  return rotate_intrinsic_handler (ctx, fntype, LROTATE_EXPR);\n+}\n+static inline tree\n+rotate_right_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype)\n+{\n+  return rotate_intrinsic_handler (ctx, fntype, RROTATE_EXPR);\n+}\n \n static const std::map<std::string,\n \t\t      std::function<tree (Context *, TyTy::BaseType *)>>\n   generic_intrinsics = {{\"offset\", &offset_intrinsic_handler},\n \t\t\t{\"size_of\", &sizeof_intrinsic_handler},\n-\t\t\t{\"transmute\", &transmute_intrinsic_handler}};\n+\t\t\t{\"transmute\", &transmute_intrinsic_handler},\n+\t\t\t{\"rotate_left\", &rotate_left_intrinsic_handler},\n+\t\t\t{\"rotate_right\", &rotate_right_intrinsic_handler}};\n \n Intrinsics::Intrinsics (Context *ctx) : ctx (ctx) {}\n \n@@ -507,5 +528,111 @@ transmute_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype_tyty)\n   return fndecl;\n }\n \n+static tree\n+rotate_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype_tyty,\n+\t\t\t  tree_code op)\n+{\n+  rust_assert (fntype_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::FnType *fntype = static_cast<TyTy::FnType *> (fntype_tyty);\n+  const Resolver::CanonicalPath &canonical_path = fntype->get_ident ().path;\n+\n+  // items can be forward compiled which means we may not need to invoke this\n+  // code. We might also have already compiled this generic function as well.\n+  tree lookup = NULL_TREE;\n+  if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n+\t\t\t\t fntype->get_id (), fntype))\n+    {\n+      // has this been added to the list then it must be finished\n+      if (ctx->function_completed (lookup))\n+\t{\n+\t  tree dummy = NULL_TREE;\n+\t  if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n+\t    {\n+\t      ctx->insert_function_decl (fntype, lookup);\n+\t    }\n+\t  return lookup;\n+\t}\n+    }\n+\n+  if (fntype->has_subsititions_defined ())\n+    {\n+      // override the Hir Lookups for the substitutions in this context\n+      fntype->override_context ();\n+    }\n+\n+  // rotate intrinsic has two parameter\n+  if (fntype->get_params ().size () != 2)\n+    {\n+      rust_error_at (fntype->get_ident ().locus,\n+\t\t     \"invalid number of parameters for rotate intrinsic\");\n+      return error_mark_node;\n+    }\n+\n+  // build the intrinsic function\n+  tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n+  std::string ir_symbol_name\n+    = canonical_path.get () + fntype->subst_as_string ();\n+  std::string asm_name = ctx->mangle_item (fntype, canonical_path);\n+\n+  unsigned int flags = 0;\n+  tree fndecl\n+    = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name, asm_name,\n+\t\t\t\t     flags, fntype->get_ident ().locus);\n+  TREE_PUBLIC (fndecl) = 0;\n+  TREE_READONLY (fndecl) = 1;\n+  DECL_ARTIFICIAL (fndecl) = 1;\n+  DECL_EXTERNAL (fndecl) = 0;\n+  DECL_DECLARED_INLINE_P (fndecl) = 1;\n+\n+  // setup the params\n+  std::vector<Bvariable *> param_vars;\n+  for (auto &parm : fntype->get_params ())\n+    {\n+      auto &referenced_param = parm.first;\n+      auto &param_tyty = parm.second;\n+      auto compiled_param_type = TyTyResolveCompile::compile (ctx, param_tyty);\n+\n+      Location param_locus = referenced_param->get_locus ();\n+      Bvariable *compiled_param_var\n+\t= CompileFnParam::compile (ctx, fndecl, referenced_param,\n+\t\t\t\t   compiled_param_type, param_locus);\n+\n+      param_vars.push_back (compiled_param_var);\n+    }\n+\n+  auto &x_param = param_vars.at (0);\n+  auto &y_param = param_vars.at (1);\n+  rust_assert (param_vars.size () == 2);\n+  if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n+    return error_mark_node;\n+\n+  tree enclosing_scope = NULL_TREE;\n+  Location start_location = Location ();\n+  Location end_location = Location ();\n+\n+  tree code_block = ctx->get_backend ()->block (fndecl, enclosing_scope, {},\n+\t\t\t\t\t\tstart_location, end_location);\n+  ctx->push_block (code_block);\n+\n+  // BUILTIN rotate FN BODY BEGIN\n+  tree x = ctx->get_backend ()->var_expression (x_param, Location ());\n+  tree y = ctx->get_backend ()->var_expression (y_param, Location ());\n+  tree rotate_expr\n+    = fold_build2_loc (BUILTINS_LOCATION, op, TREE_TYPE (x), x, y);\n+  auto return_statement\n+    = ctx->get_backend ()->return_statement (fndecl, {rotate_expr},\n+\t\t\t\t\t     Location ());\n+  ctx->add_statement (return_statement);\n+  // BUILTIN rotate FN BODY END\n+\n+  tree bind_tree = ctx->pop_block ();\n+\n+  gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n+  DECL_SAVED_TREE (fndecl) = bind_tree;\n+  ctx->push_function (fndecl);\n+\n+  return fndecl;\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "e8f1c51a1d45ecbc6bdce5e422365c7c7c7614d5", "filename": "gcc/rust/backend/rust-compile-pattern.cc", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21b9e1226cfbc4137a881a71c5e6f904fc5b364e/gcc%2Frust%2Fbackend%2Frust-compile-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21b9e1226cfbc4137a881a71c5e6f904fc5b364e/gcc%2Frust%2Fbackend%2Frust-compile-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-pattern.cc?ref=21b9e1226cfbc4137a881a71c5e6f904fc5b364e", "patch": "@@ -80,6 +80,20 @@ CompilePatternCaseLabelExpr::visit (HIR::WildcardPattern &pattern)\n     = build_case_label (NULL_TREE, NULL_TREE, associated_case_label);\n }\n \n+void\n+CompilePatternCaseLabelExpr::visit (HIR::LiteralPattern &pattern)\n+{\n+  // Compile the literal\n+  HIR::LiteralExpr *litexpr\n+    = new HIR::LiteralExpr (pattern.get_pattern_mappings (),\n+\t\t\t    pattern.get_literal (), pattern.get_locus (),\n+\t\t\t    std::vector<AST::Attribute> ());\n+\n+  tree lit = CompileExpr::Compile (litexpr, ctx);\n+\n+  case_label_expr = build_case_label (lit, NULL_TREE, associated_case_label);\n+}\n+\n // setup the bindings\n \n void"}, {"sha": "1b6e80fb88db0b019db9526814c5594065be80e9", "filename": "gcc/rust/backend/rust-compile-pattern.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21b9e1226cfbc4137a881a71c5e6f904fc5b364e/gcc%2Frust%2Fbackend%2Frust-compile-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21b9e1226cfbc4137a881a71c5e6f904fc5b364e/gcc%2Frust%2Fbackend%2Frust-compile-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-pattern.h?ref=21b9e1226cfbc4137a881a71c5e6f904fc5b364e", "patch": "@@ -41,7 +41,7 @@ class CompilePatternCaseLabelExpr : public HIRCompileBase,\n   // Empty visit for unused Pattern HIR nodes.\n   void visit (HIR::GroupedPattern &) override {}\n   void visit (HIR::IdentifierPattern &) override {}\n-  void visit (HIR::LiteralPattern &) override {}\n+  void visit (HIR::LiteralPattern &) override;\n   void visit (HIR::QualifiedPathInExpression &) override {}\n   void visit (HIR::RangePattern &) override {}\n   void visit (HIR::ReferencePattern &) override {}"}, {"sha": "db22227711e0233262d914f8b453dcdf1460f869", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21b9e1226cfbc4137a881a71c5e6f904fc5b364e/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21b9e1226cfbc4137a881a71c5e6f904fc5b364e/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=21b9e1226cfbc4137a881a71c5e6f904fc5b364e", "patch": "@@ -492,7 +492,7 @@ HIRCompileBase::verify_array_capacities (tree ltype, tree rtype,\n   if (!TREE_CONSTANT (TYPE_MAX_VALUE (ltype_domain)))\n     return false;\n \n-  auto ltype_length\n+  unsigned HOST_WIDE_INT ltype_length\n     = wi::ext (wi::to_offset (TYPE_MAX_VALUE (ltype_domain))\n \t\t - wi::to_offset (TYPE_MIN_VALUE (ltype_domain)) + 1,\n \t       TYPE_PRECISION (TREE_TYPE (ltype_domain)),\n@@ -506,7 +506,7 @@ HIRCompileBase::verify_array_capacities (tree ltype, tree rtype,\n   if (!TREE_CONSTANT (TYPE_MAX_VALUE (rtype_domain)))\n     return false;\n \n-  auto rtype_length\n+  unsigned HOST_WIDE_INT rtype_length\n     = wi::ext (wi::to_offset (TYPE_MAX_VALUE (rtype_domain))\n \t\t - wi::to_offset (TYPE_MIN_VALUE (rtype_domain)) + 1,\n \t       TYPE_PRECISION (TREE_TYPE (rtype_domain)),\n@@ -515,10 +515,11 @@ HIRCompileBase::verify_array_capacities (tree ltype, tree rtype,\n \n   if (ltype_length != rtype_length)\n     {\n-      rust_error_at (rvalue_locus,\n-\t\t     \"expected an array with a fixed size of %lu \"\n-\t\t     \"elements, found one with %lu elements\",\n-\t\t     ltype_length, rtype_length);\n+      rust_error_at (\n+\trvalue_locus,\n+\t\"expected an array with a fixed size of \" HOST_WIDE_INT_PRINT_UNSIGNED\n+\t\" elements, found one with \" HOST_WIDE_INT_PRINT_UNSIGNED \" elements\",\n+\tltype_length, rtype_length);\n       return false;\n     }\n "}, {"sha": "f1dff2cb0f29455b18bc96b30056ab1562d62758", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21b9e1226cfbc4137a881a71c5e6f904fc5b364e/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21b9e1226cfbc4137a881a71c5e6f904fc5b364e/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=21b9e1226cfbc4137a881a71c5e6f904fc5b364e", "patch": "@@ -1027,7 +1027,7 @@ class TypeCheckExpr : public TypeCheckBase\n \n \t// check the kase type\n \tTyTy::BaseType *kase_block_ty\n-\t  = TypeCheckExpr::Resolve (kase.get_expr ().get (), false);\n+\t  = TypeCheckExpr::Resolve (kase.get_expr ().get (), inside_loop);\n \tkase_block_tys.push_back (kase_block_ty);\n       }\n "}, {"sha": "45900b82410d8d5376e5a816d20e382b7615dc89", "filename": "gcc/testsuite/rust/execute/torture/match_bool1.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21b9e1226cfbc4137a881a71c5e6f904fc5b364e/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmatch_bool1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21b9e1226cfbc4137a881a71c5e6f904fc5b364e/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmatch_bool1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmatch_bool1.rs?ref=21b9e1226cfbc4137a881a71c5e6f904fc5b364e", "patch": "@@ -0,0 +1,44 @@\n+// { dg-output \"182 is more than 100\\n55 is less than 100\\n\" }\n+\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+fn foo (x: bool) -> i32 {\n+    match x {\n+        true => { return 182; },\n+        false => { return 55; },\n+    }\n+}\n+\n+fn bar (y: i32) {\n+\n+    match y < 100 {\n+        true => {\n+            let a = \"%i is less than 100\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf (c, y);\n+        }\n+        _ => {\n+            let a = \"%i is more than 100\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf (c, y);\n+        }\n+    }\n+}\n+\n+\n+fn main () -> i32 {\n+\n+    let a = foo (true);\n+    let b = foo (false);\n+\n+    bar (a);\n+    bar (b);\n+\n+    0\n+}"}, {"sha": "d3aab6bc0bfd8789faba63ef3c14cb3d1fa890e1", "filename": "gcc/testsuite/rust/execute/torture/match_loop1.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21b9e1226cfbc4137a881a71c5e6f904fc5b364e/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmatch_loop1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21b9e1226cfbc4137a881a71c5e6f904fc5b364e/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmatch_loop1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmatch_loop1.rs?ref=21b9e1226cfbc4137a881a71c5e6f904fc5b364e", "patch": "@@ -0,0 +1,51 @@\n+// { dg-output \"E::One\\nE::Two\\nbreak!\\n\" }\n+\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+enum E {\n+    One,\n+    Two,\n+    Other\n+}\n+\n+fn foo () {\n+    let mut x = E::One;\n+\n+    loop {\n+        match x {\n+            E::One => {\n+                let a = \"E::One\\n\\0\";\n+                let b = a as *const str;\n+                let c = b as *const i8;\n+                printf (c);\n+\n+                x = E::Two;\n+            }\n+            E::Two => {\n+                let a = \"E::Two\\n\\0\";\n+                let b = a as *const str;\n+                let c = b as *const i8;\n+                printf (c);\n+\n+                x = E::Other;\n+            }\n+            _ => {\n+                let a = \"break!\\n\\0\";\n+                let b = a as *const str;\n+                let c = b as *const i8;\n+                printf (c);\n+\n+                break;\n+            }\n+        }\n+    }\n+}\n+\n+\n+fn main () -> i32 {\n+    foo ();\n+\n+    0\n+}"}]}