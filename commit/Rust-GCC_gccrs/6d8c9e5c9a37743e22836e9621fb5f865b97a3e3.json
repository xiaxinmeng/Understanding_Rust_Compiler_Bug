{"sha": "6d8c9e5c9a37743e22836e9621fb5f865b97a3e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ4YzllNWM5YTM3NzQzZTIyODM2ZTk2MjFmYjVmODY1Yjk3YTNlMw==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2011-10-21T22:48:39Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2011-10-21T22:48:39Z"}, "message": "re PR fortran/50821 (3 new GCC HEAD@180266 regressions)\n\n2011-10-20  Steven G. Kargl  <kargl@gcc.gnu.org>\n\n\tPR fortran/50821\n\t* check.c (gfc_check_ishftc): Check args are constant before \n\textracting the integer.\n\nFrom-SVN: r180316", "tree": {"sha": "9cb3e25e366ce27408189d086dbe4d0f4fdc9023", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9cb3e25e366ce27408189d086dbe4d0f4fdc9023"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d8c9e5c9a37743e22836e9621fb5f865b97a3e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d8c9e5c9a37743e22836e9621fb5f865b97a3e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d8c9e5c9a37743e22836e9621fb5f865b97a3e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d8c9e5c9a37743e22836e9621fb5f865b97a3e3/comments", "author": null, "committer": null, "parents": [{"sha": "74b388c3393db06df440d0774261b420639e8a97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74b388c3393db06df440d0774261b420639e8a97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74b388c3393db06df440d0774261b420639e8a97"}], "stats": {"total": 39, "additions": 26, "deletions": 13}, "files": [{"sha": "251bd45fd260a748b6874e1fbfbfa3990ed7e944", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d8c9e5c9a37743e22836e9621fb5f865b97a3e3/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d8c9e5c9a37743e22836e9621fb5f865b97a3e3/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6d8c9e5c9a37743e22836e9621fb5f865b97a3e3", "patch": "@@ -1,3 +1,9 @@\n+2011-10-20  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR fortran/50821\n+\t* check.c (gfc_check_ishftc): Check args are constant before \n+\textracting the integer.\n+\n 2011-10-20  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/50514"}, {"sha": "34b3a68057ca66fd13aaef422b1bd3cd43e39cc1", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d8c9e5c9a37743e22836e9621fb5f865b97a3e3/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d8c9e5c9a37743e22836e9621fb5f865b97a3e3/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=6d8c9e5c9a37743e22836e9621fb5f865b97a3e3", "patch": "@@ -1967,22 +1967,29 @@ gfc_check_ishftc (gfc_expr *i, gfc_expr *shift, gfc_expr *size)\n       if (less_than_bitsize1 (\"I\", i, \"SIZE\", size, true) == FAILURE)\n \treturn FAILURE;\n \n-      gfc_extract_int (size, &i3);\n-      if (i3 <= 0)\n+      if (size->expr_type == EXPR_CONSTANT)\n \t{\n-\t  gfc_error (\"SIZE at %L must be positive\", &size->where);\n-\t  return FAILURE;\n-\t}\n+\t  gfc_extract_int (size, &i3);\n+\t  if (i3 <= 0)\n+\t    {\n+\t      gfc_error (\"SIZE at %L must be positive\", &size->where);\n+\t      return FAILURE;\n+\t    }\n \n-      gfc_extract_int (shift, &i2);\n-      if (i2 < 0)\n-\ti2 = -i2;\n+\t  if (shift->expr_type == EXPR_CONSTANT)\n+\t    {\n+\t      gfc_extract_int (shift, &i2);\n+\t      if (i2 < 0)\n+\t\ti2 = -i2;\n \n-      if (i2 > i3)\n-\t{\n-\t  gfc_error (\"The absolute value of SHIFT at %L must be less than \"\n-\t\t     \"or equal to SIZE at %L\", &shift->where, &size->where);\n-\t  return FAILURE;\n+\t      if (i2 > i3)\n+\t\t{\n+\t\t  gfc_error (\"The absolute value of SHIFT at %L must be less \"\n+\t\t\t     \"than or equal to SIZE at %L\", &shift->where,\n+\t\t\t     &size->where);\n+\t\t  return FAILURE;\n+\t\t}\n+\t     }\n \t}\n     }\n   else if (less_than_bitsize1 (\"I\", i, NULL, shift, true) == FAILURE)"}]}