{"sha": "ebb109add82e17c08e24de72bf1735ebbbc5081c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJiMTA5YWRkODJlMTdjMDhlMjRkZTcyYmYxNzM1ZWJiYmM1MDgxYw==", "commit": {"author": {"name": "Ben Elliston", "email": "bje@au.ibm.com", "date": "2005-11-22T05:19:29Z"}, "committer": {"name": "Ben Elliston", "email": "bje@gcc.gnu.org", "date": "2005-11-22T05:19:29Z"}, "message": "optabs.c: Use SCALAR_FLOAT_MODE_P instead of explicitly testing GET_MODE_CLASS (x) ==...\n\n\t* optabs.c: Use SCALAR_FLOAT_MODE_P instead of explicitly testing\n\tGET_MODE_CLASS (x) == MODE_FLOAT.\n\t* config/i386/i386.c: Likewise.\n\t* config/rs6000/xcoff.h: Likewise.\n\t* config/rs6000/linux64.h: Likewise.\n\t* config/rs6000/rs6000.c: Likewise.\n\t* config/rs6000/rs6000.h: Likewise.\n\t* config/rs6000/predicates.md: Likewise.\n\t* config/rs6000/sysv4.h: Likewise.\n\nFrom-SVN: r107348", "tree": {"sha": "18e362b9e14d5d118480d4d1af3cd2b9ae13c7c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18e362b9e14d5d118480d4d1af3cd2b9ae13c7c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebb109add82e17c08e24de72bf1735ebbbc5081c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebb109add82e17c08e24de72bf1735ebbbc5081c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebb109add82e17c08e24de72bf1735ebbbc5081c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebb109add82e17c08e24de72bf1735ebbbc5081c/comments", "author": null, "committer": null, "parents": [{"sha": "3d119f8fec4569301afddf6f8e308cc0e1558091", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d119f8fec4569301afddf6f8e308cc0e1558091", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d119f8fec4569301afddf6f8e308cc0e1558091"}], "stats": {"total": 62, "additions": 37, "deletions": 25}, "files": [{"sha": "fa6a35cba6f252768da91a5710caf5e85b820373", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb109add82e17c08e24de72bf1735ebbbc5081c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb109add82e17c08e24de72bf1735ebbbc5081c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ebb109add82e17c08e24de72bf1735ebbbc5081c", "patch": "@@ -1,3 +1,15 @@\n+2005-11-22  Ben Elliston  <bje@au.ibm.com>\n+\n+\t* optabs.c: Use SCALAR_FLOAT_MODE_P instead of explicitly testing\n+\tGET_MODE_CLASS (x) == MODE_FLOAT.\n+\t* config/i386/i386.c: Likewise.\n+\t* config/rs6000/xcoff.h: Likewise.\n+\t* config/rs6000/linux64.h: Likewise.\n+\t* config/rs6000/rs6000.c: Likewise.\n+\t* config/rs6000/rs6000.h: Likewise.\n+\t* config/rs6000/predicates.md: Likewise.\n+\t* config/rs6000/sysv4.h: Likewise.\n+\n 2005-11-21  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* c-cppbuiltin.c (c_cpp_builtins): Define __pic__ and __PIC__ when"}, {"sha": "e1684c29d4eb095cd1b87b23f4f9a3520852cd23", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb109add82e17c08e24de72bf1735ebbbc5081c/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb109add82e17c08e24de72bf1735ebbbc5081c/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ebb109add82e17c08e24de72bf1735ebbbc5081c", "patch": "@@ -3615,7 +3615,7 @@ ix86_value_regno (enum machine_mode mode, tree func, tree fntype)\n     return FIRST_SSE_REG;\n \n   /* Most things go in %eax, except (unless -mno-fp-ret-in-387) fp values.  */\n-  if (GET_MODE_CLASS (mode) != MODE_FLOAT || !TARGET_FLOAT_RETURNS_IN_80387)\n+  if (!SCALAR_FLOAT_MODE_P (mode) || !TARGET_FLOAT_RETURNS_IN_80387)\n     return 0;\n \n   /* Floating point return values in %st(0), except for local functions when\n@@ -9103,7 +9103,7 @@ ix86_fp_compare_mode (enum rtx_code code ATTRIBUTE_UNUSED)\n enum machine_mode\n ix86_cc_mode (enum rtx_code code, rtx op0, rtx op1)\n {\n-  if (GET_MODE_CLASS (GET_MODE (op0)) == MODE_FLOAT)\n+  if (SCALAR_FLOAT_MODE_P (GET_MODE (op0)))\n     return ix86_fp_compare_mode (code);\n   switch (code)\n     {\n@@ -9684,7 +9684,7 @@ ix86_expand_compare (enum rtx_code code, rtx *second_test, rtx *bypass_test)\n       ret = gen_rtx_fmt_ee (code, VOIDmode, ix86_compare_emitted, const0_rtx);\n       ix86_compare_emitted = NULL_RTX;\n     }\n-  else if (GET_MODE_CLASS (GET_MODE (op0)) == MODE_FLOAT)\n+  else if (SCALAR_FLOAT_MODE_P (GET_MODE (op0)))\n     ret = ix86_expand_fp_compare (code, op0, op1, NULL_RTX,\n \t\t\t\t  second_test, bypass_test);\n   else"}, {"sha": "1555d2968a7f4ba547bfec23c1c9f0716d7f5b41", "filename": "gcc/config/rs6000/linux64.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb109add82e17c08e24de72bf1735ebbbc5081c/gcc%2Fconfig%2Frs6000%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb109add82e17c08e24de72bf1735ebbbc5081c/gcc%2Fconfig%2Frs6000%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.h?ref=ebb109add82e17c08e24de72bf1735ebbbc5081c", "patch": "@@ -457,12 +457,12 @@ extern int dot_symbols;\n \t   && ((TARGET_64BIT\t\t\t\t\t\t\\\n \t\t&& (TARGET_POWERPC64\t\t\t\t\t\\\n \t\t    || TARGET_MINIMAL_TOC\t\t\t\t\\\n-\t\t    || (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\\\n+\t\t    || (SCALAR_FLOAT_MODE_P (GET_MODE (X))\t\t\\\n \t\t\t&& ! TARGET_NO_FP_IN_TOC)))\t\t\t\\\n \t       || (!TARGET_64BIT\t\t\t\t\t\\\n \t\t   && !TARGET_NO_FP_IN_TOC\t\t\t\t\\\n \t\t   && !TARGET_RELOCATABLE\t\t\t\t\\\n-\t\t   && GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\\\n+\t\t   && SCALAR_FLOAT_MODE_P (GET_MODE (X))\t\t\\\n \t\t   && BITS_PER_WORD == HOST_BITS_PER_INT)))))\n \n /* This ABI cannot use DBX_LINES_FUNCTION_RELATIVE, nor can it use"}, {"sha": "885ac2cf39e45635e4deffb3b373dfc99a1092f1", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb109add82e17c08e24de72bf1735ebbbc5081c/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb109add82e17c08e24de72bf1735ebbbc5081c/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=ebb109add82e17c08e24de72bf1735ebbbc5081c", "patch": "@@ -187,7 +187,7 @@\n   REAL_VALUE_TYPE rv;\n \n   if (GET_MODE (op) != mode\n-      || (GET_MODE_CLASS (mode) != MODE_FLOAT && mode != DImode))\n+      || (!SCALAR_FLOAT_MODE_P (mode) && mode != DImode))\n     return 0;\n \n   /* Consider all constants with -msoft-float to be easy.  */\n@@ -330,7 +330,7 @@\n ;; or non-special register register field no cr0\n (define_predicate \"zero_fp_constant\"\n   (and (match_code \"const_double\")\n-       (match_test \"GET_MODE_CLASS (mode) == MODE_FLOAT\n+       (match_test \"SCALAR_FLOAT_MODE_P (mode)\n \t\t    && op == CONST0_RTX (mode)\")))\n \n ;; Return 1 if the operand is in volatile memory.  Note that during the\n@@ -707,7 +707,7 @@\n     return 1;\n \n   /* For floating-point, easy constants are valid.  */\n-  if (GET_MODE_CLASS (mode) == MODE_FLOAT\n+  if (SCALAR_FLOAT_MODE_P (mode)\n       && CONSTANT_P (op)\n       && easy_fp_constant (op, mode))\n     return 1;\n@@ -725,7 +725,7 @@\n \n   /* For floating-point or multi-word mode, the only remaining valid type\n      is a register.  */\n-  if (GET_MODE_CLASS (mode) == MODE_FLOAT\n+  if (SCALAR_FLOAT_MODE_P (mode)\n       || GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n     return register_operand (op, mode);\n "}, {"sha": "c3e50a314737c4ee3d95769685c7ac7747ca16fc", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb109add82e17c08e24de72bf1735ebbbc5081c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb109add82e17c08e24de72bf1735ebbbc5081c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=ebb109add82e17c08e24de72bf1735ebbbc5081c", "patch": "@@ -1028,7 +1028,7 @@ rs6000_hard_regno_mode_ok (int regno, enum machine_mode mode)\n   /* The float registers can only hold floating modes and DImode.  */\n   if (FP_REGNO_P (regno))\n     return\n-      (GET_MODE_CLASS (mode) == MODE_FLOAT\n+      (SCALAR_FLOAT_MODE_P (mode)\n        && FP_REGNO_P (regno + HARD_REGNO_NREGS (regno, mode) - 1))\n       || (GET_MODE_CLASS (mode) == MODE_INT\n \t  && GET_MODE_SIZE (mode) == UNITS_PER_FP_WORD);\n@@ -4126,7 +4126,7 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n \f\n /* Nonzero if we can use a floating-point register to pass this arg.  */\n #define USE_FP_FOR_ARG_P(CUM,MODE,TYPE)\t\t\\\n-  (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\\\n+  (SCALAR_FLOAT_MODE_P (MODE)\t\t\t\\\n    && (CUM)->fregno <= FP_ARG_MAX_REG\t\t\\\n    && TARGET_HARD_FLOAT && TARGET_FPRS)\n \n@@ -4650,7 +4650,7 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \n       cum->words = align_words + n_words;\n \n-      if (GET_MODE_CLASS (mode) == MODE_FLOAT\n+      if (SCALAR_FLOAT_MODE_P (mode)\n \t  && TARGET_HARD_FLOAT && TARGET_FPRS)\n \tcum->fregno += (GET_MODE_SIZE (mode) + 7) >> 3;\n \n@@ -11698,7 +11698,7 @@ rs6000_emit_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n       return 0;\n     }\n   else if (TARGET_E500 && TARGET_HARD_FLOAT && !TARGET_FPRS\n-\t   && GET_MODE_CLASS (compare_mode) == MODE_FLOAT)\n+\t   && SCALAR_FLOAT_MODE_P (compare_mode))\n     return 0;\n \n   is_against_zero = op1 == CONST0_RTX (compare_mode);\n@@ -11708,7 +11708,7 @@ rs6000_emit_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n      can't be generated if we care about that.  It's safe if one side\n      of the construct is zero, since then no subtract will be\n      generated.  */\n-  if (GET_MODE_CLASS (compare_mode) == MODE_FLOAT\n+  if (SCALAR_FLOAT_MODE_P (compare_mode)\n       && flag_trapping_math && ! is_against_zero)\n     return 0;\n \n@@ -15249,7 +15249,7 @@ rs6000_output_function_epilogue (FILE *file,\n \n \t      if (GET_CODE (parameter) == REG)\n \t\t{\n-\t\t  if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n+\t\t  if (SCALAR_FLOAT_MODE_P (mode))\n \t\t    {\n \t\t      int bits;\n \n@@ -18909,7 +18909,7 @@ rs6000_libcall_value (enum machine_mode mode)\n \t\t\t\t      GEN_INT (4))));\n     }\n \n-  if (GET_MODE_CLASS (mode) == MODE_FLOAT\n+  if (SCALAR_FLOAT_MODE_P (mode)\n \t   && TARGET_HARD_FLOAT && TARGET_FPRS)\n     regno = FP_ARG_RETURN;\n   else if (ALTIVEC_VECTOR_MODE (mode)"}, {"sha": "15e8296582959bab309436e5ec38509ddf4b2c3b", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb109add82e17c08e24de72bf1735ebbbc5081c/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb109add82e17c08e24de72bf1735ebbbc5081c/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=ebb109add82e17c08e24de72bf1735ebbbc5081c", "patch": "@@ -814,10 +814,10 @@ extern enum rs6000_nop_insertion rs6000_sched_insert_nops;\n    If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n    for any hard reg, then this must be 0 for correct output.  */\n #define MODES_TIEABLE_P(MODE1, MODE2) \\\n-  (GET_MODE_CLASS (MODE1) == MODE_FLOAT\t\t\\\n-   ? GET_MODE_CLASS (MODE2) == MODE_FLOAT\t\\\n-   : GET_MODE_CLASS (MODE2) == MODE_FLOAT\t\\\n-   ? GET_MODE_CLASS (MODE1) == MODE_FLOAT\t\\\n+  (SCALAR_FLOAT_MODE_P (MODE1)\t\t\t\\\n+   ? SCALAR_FLOAT_MODE_P (MODE2)\t\t\\\n+   : SCALAR_FLOAT_MODE_P (MODE2)\t\t\\\n+   ? SCALAR_FLOAT_MODE_P (MODE1)\t\t\\\n    : GET_MODE_CLASS (MODE1) == MODE_CC\t\t\\\n    ? GET_MODE_CLASS (MODE2) == MODE_CC\t\t\\\n    : GET_MODE_CLASS (MODE2) == MODE_CC\t\t\\\n@@ -1951,7 +1951,7 @@ do {\t\t\t\t\t\t\t\t\\\n    comparison.  CCmode should be used in all other cases.  */\n \n #define SELECT_CC_MODE(OP,X,Y) \\\n-  (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT ? CCFPmode\t\\\n+  (SCALAR_FLOAT_MODE_P (GET_MODE (X)) ? CCFPmode\t\\\n    : (OP) == GTU || (OP) == LTU || (OP) == GEU || (OP) == LEU ? CCUNSmode \\\n    : (((OP) == EQ || (OP) == NE) && COMPARISON_P (X)\t\t\t  \\\n       ? CCEQmode : CCmode))"}, {"sha": "238b497250fe25ce1e0485e5cfa2338f90322109", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb109add82e17c08e24de72bf1735ebbbc5081c/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb109add82e17c08e24de72bf1735ebbbc5081c/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=ebb109add82e17c08e24de72bf1735ebbbc5081c", "patch": "@@ -508,7 +508,7 @@ fini_section (void)\t\t\t\t\t\t\t\\\n        || (!TARGET_NO_FP_IN_TOC\t\t\t\t\t\t\\\n \t   && !TARGET_RELOCATABLE\t\t\t\t\t\\\n \t   && GET_CODE (X) == CONST_DOUBLE\t\t\t\t\\\n-\t   && GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\\\n+\t   && SCALAR_FLOAT_MODE_P (GET_MODE (X))\t\t\t\\\n \t   && BITS_PER_WORD == HOST_BITS_PER_INT)))\n \n /* These macros generate the special .type and .size directives which"}, {"sha": "822b5a0de5e5a23142590f0681805077581c09ce", "filename": "gcc/config/rs6000/xcoff.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb109add82e17c08e24de72bf1735ebbbc5081c/gcc%2Fconfig%2Frs6000%2Fxcoff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb109add82e17c08e24de72bf1735ebbbc5081c/gcc%2Fconfig%2Frs6000%2Fxcoff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fxcoff.h?ref=ebb109add82e17c08e24de72bf1735ebbbc5081c", "patch": "@@ -164,7 +164,7 @@ toc_section (void)\t\t\t\t\t\\\n        || (GET_CODE (X) == CONST_DOUBLE\t\t\t\t\t\\\n \t   && (TARGET_POWERPC64\t\t\t\t\t\t\\\n \t       || TARGET_MINIMAL_TOC\t\t\t\t\t\\\n-\t       || (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\\\n+\t       || (SCALAR_FLOAT_MODE_P (GET_MODE (X))\t\t\t\\\n \t\t   && ! TARGET_NO_FP_IN_TOC)))))\n \n #define TARGET_ASM_GLOBALIZE_LABEL  rs6000_xcoff_asm_globalize_label"}, {"sha": "219998bac875d45b539d7889a4f9ecbfa8cec8f1", "filename": "gcc/optabs.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb109add82e17c08e24de72bf1735ebbbc5081c/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb109add82e17c08e24de72bf1735ebbbc5081c/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=ebb109add82e17c08e24de72bf1735ebbbc5081c", "patch": "@@ -2489,7 +2489,7 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n   if (unoptab->code == NEG)\n     {\n       /* Try negating floating point values by flipping the sign bit.  */\n-      if (class == MODE_FLOAT)\n+      if (SCALAR_FLOAT_MODE_P (class))\n \t{\n \t  temp = expand_absneg_bit (NEG, mode, op0, target);\n \t  if (temp)\n@@ -3552,7 +3552,7 @@ prepare_cmp_insn (rtx *px, rtx *py, enum rtx_code *pcomparison, rtx size,\n       return;\n     }\n \n-  gcc_assert (class == MODE_FLOAT);\n+  gcc_assert (SCALAR_FLOAT_MODE_P (class));\n   prepare_float_lib_cmp (px, py, pcomparison, pmode, punsignedp);\n }\n "}]}