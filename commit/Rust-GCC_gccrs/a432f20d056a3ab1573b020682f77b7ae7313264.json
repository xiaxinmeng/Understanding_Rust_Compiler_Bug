{"sha": "a432f20d056a3ab1573b020682f77b7ae7313264", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQzMmYyMGQwNTZhM2FiMTU3M2IwMjA2ODJmNzdiN2FlNzMxMzI2NA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-12-31T11:47:13Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-12-31T11:47:13Z"}, "message": "(simplify_relational_operation): Rewrite and simplify.\n\nAdd case when we can simplify A-B for compare of A and B.\n\nFrom-SVN: r6344", "tree": {"sha": "15e57e39d1373ae701edd543bf1c1c835255ef3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15e57e39d1373ae701edd543bf1c1c835255ef3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a432f20d056a3ab1573b020682f77b7ae7313264", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a432f20d056a3ab1573b020682f77b7ae7313264", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a432f20d056a3ab1573b020682f77b7ae7313264", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a432f20d056a3ab1573b020682f77b7ae7313264/comments", "author": null, "committer": null, "parents": [{"sha": "abe6e52f2327fb3eeb45e40eeeea83033485daa1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abe6e52f2327fb3eeb45e40eeeea83033485daa1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abe6e52f2327fb3eeb45e40eeeea83033485daa1"}], "stats": {"total": 344, "additions": 143, "deletions": 201}, "files": [{"sha": "888ab0552bc5e3ec0c4464014a6d1d6decab06fb", "filename": "gcc/cse.c", "status": "modified", "additions": 143, "deletions": 201, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a432f20d056a3ab1573b020682f77b7ae7313264/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a432f20d056a3ab1573b020682f77b7ae7313264/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=a432f20d056a3ab1573b020682f77b7ae7313264", "patch": "@@ -4276,17 +4276,21 @@ cse_gen_binary (code, mode, op0, op1)\n }\n \f\n /* Like simplify_binary_operation except used for relational operators.\n-   MODE is the mode of the operands, not that of the result.  */\n+   MODE is the mode of the operands, not that of the result.  If MODE\n+   is VOIDmode, both operands must also be VOIDmode and we compare the\n+   operands in \"infinite precision\".\n+\n+   If no simplification is possible, this function returns zero.  Otherwise,\n+   it returns either const_true_rtx or const0_rtx.  */\n \n rtx\n simplify_relational_operation (code, mode, op0, op1)\n      enum rtx_code code;\n      enum machine_mode mode;\n      rtx op0, op1;\n {\n-  register HOST_WIDE_INT arg0, arg1, arg0s, arg1s;\n-  HOST_WIDE_INT val;\n-  int width = GET_MODE_BITSIZE (mode);\n+  int equal, op0lt, op0ltu, op1lt, op1ltu;\n+  rtx tem;\n \n   /* If op0 is a compare, extract the comparison arguments from it.  */\n   if (GET_CODE (op0) == COMPARE && op1 == const0_rtx)\n@@ -4297,151 +4301,148 @@ simplify_relational_operation (code, mode, op0, op1)\n   if (GET_MODE_CLASS (GET_MODE (op0)) == MODE_CC)\n     return 0;\n \n-  /* Unlike the arithmetic operations, we can do the comparison whether\n-     or not WIDTH is larger than HOST_BITS_PER_WIDE_INT because the\n-     CONST_INTs are to be understood as being infinite precision as\n-     is the comparison.  So there is no question of overflow.  */\n-\n-  if (GET_CODE (op0) != CONST_INT || GET_CODE (op1) != CONST_INT || width == 0)\n-    {\n-      /* Even if we can't compute a constant result,\n-\t there are some cases worth simplifying.  */\n-\n-      /* For non-IEEE floating-point, if the two operands are equal, we know\n-\t the result.  */\n-      if (rtx_equal_p (op0, op1)\n-\t  && (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t      || ! FLOAT_MODE_P (GET_MODE (op0)) || flag_fast_math))\n-\treturn (code == EQ || code == GE || code == LE || code == LEU\n-\t\t|| code == GEU) ? const_true_rtx : const0_rtx;\n-\n+  /* For integer comparisons of A and B maybe we can simplify A - B and can\n+     then simplify a comparison of that with zero.  If A and B are both either\n+     a register or a CONST_INT, this can't help; testing for these cases will\n+     prevent infinite recursion here and speed things up.\n+\n+     If CODE is an unsigned comparison, we can only do this if A - B is a\n+     constant integer, and then we have to compare that integer with zero as a\n+     signed comparison.  Note that this will give the incorrect result from\n+     comparisons that overflow.  Since these are undefined, this is probably\n+     OK.  If it causes a problem, we can check for A or B being an address\n+     (fp + const or SYMBOL_REF) and only do it in that case.  */\n+\n+  if (INTEGRAL_MODE_P (mode) && op1 != const0_rtx\n+      && ! ((GET_CODE (op0) == REG || GET_CODE (op0) == CONST_INT)\n+\t    && (GET_CODE (op1) == REG || GET_CODE (op1) == CONST_INT))\n+      && 0 != (tem = simplify_binary_operation (MINUS, mode, op0, op1))\n+      && (GET_CODE (tem) == CONST_INT\n+\t  || (code != GTU && code != GEU &&\n+\t      code != LTU && code != LEU)))\n+    return simplify_relational_operation (signed_condition (code),\n+\t\t\t\t\t  mode, tem, const0_rtx);\n+\n+  /* For non-IEEE floating-point, if the two operands are equal, we know the\n+     result.  */\n+  if (rtx_equal_p (op0, op1)\n+      && (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n+\t  || ! FLOAT_MODE_P (GET_MODE (op0)) || flag_fast_math))\n+    equal = 1, op0lt = 0, op0ltu = 0, op1lt = 0, op1ltu = 0;\n+\n+  /* If the operands are floating-point constants, see if we can fold\n+     the result.  */\n #if ! defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n-      else if (GET_CODE (op0) == CONST_DOUBLE\n-\t       && GET_CODE (op1) == CONST_DOUBLE\n-\t       && GET_MODE_CLASS (GET_MODE (op0)) == MODE_FLOAT)\n-\t{\n-\t  REAL_VALUE_TYPE d0, d1;\n-\t  jmp_buf handler;\n-\t  int op0lt, op1lt, equal;\n+  else if (GET_CODE (op0) == CONST_DOUBLE && GET_CODE (op1) == CONST_DOUBLE\n+\t   && GET_MODE_CLASS (GET_MODE (op0)) == MODE_FLOAT)\n+    {\n+      REAL_VALUE_TYPE d0, d1;\n+      jmp_buf handler;\n+      \n+      if (setjmp (handler))\n+\treturn 0;\n \n-\t  if (setjmp (handler))\n-\t    return 0;\n+      set_float_handler (handler);\n+      REAL_VALUE_FROM_CONST_DOUBLE (d0, op0);\n+      REAL_VALUE_FROM_CONST_DOUBLE (d1, op1);\n+      equal = REAL_VALUES_EQUAL (d0, d1);\n+      op0lt = op0ltu = REAL_VALUES_LESS (d0, d1);\n+      op1lt = op1ltu = REAL_VALUES_LESS (d1, d0);\n+      set_float_handler (NULL_PTR);\n+    }\n+#endif  /* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */\n \n-\t  set_float_handler (handler);\n-\t  REAL_VALUE_FROM_CONST_DOUBLE (d0, op0);\n-\t  REAL_VALUE_FROM_CONST_DOUBLE (d1, op1);\n-\t  equal = REAL_VALUES_EQUAL (d0, d1);\n-\t  op0lt = REAL_VALUES_LESS (d0, d1);\n-\t  op1lt = REAL_VALUES_LESS (d1, d0);\n-\t  set_float_handler (NULL_PTR);\n+  /* Otherwise, see if the operands are both integers.  */\n+  else if ((GET_MODE_CLASS (mode) == MODE_INT || mode == VOIDmode)\n+\t   && (GET_CODE (op0) == CONST_DOUBLE || GET_CODE (op0) == CONST_INT)\n+\t   && (GET_CODE (op1) == CONST_DOUBLE || GET_CODE (op1) == CONST_INT))\n+    {\n+      int width = GET_MODE_BITSIZE (mode);\n+      HOST_WIDE_INT l0u, l0s, h0u, h0s, l1u, l1s, h1u, h1s;\n \n-\t  switch (code)\n-\t    {\n-\t    case EQ:\n-\t      return equal ? const_true_rtx : const0_rtx;\n-\t    case NE:\n-\t      return !equal ? const_true_rtx : const0_rtx;\n-\t    case LE:\n-\t      return equal || op0lt ? const_true_rtx : const0_rtx;\n-\t    case LT:\n-\t      return op0lt ? const_true_rtx : const0_rtx;\n-\t    case GE:\n-\t      return equal || op1lt ? const_true_rtx : const0_rtx;\n-\t    case GT:\n-\t      return op1lt ? const_true_rtx : const0_rtx;\n-\t    }\n+      /* Get the two words comprising each integer constant.  */\n+      if (GET_CODE (op0) == CONST_DOUBLE)\n+\t{\n+\t  l0u = l0s = CONST_DOUBLE_LOW (op0);\n+\t  h0u = h0s = CONST_DOUBLE_HIGH (op0);\n \t}\n-#endif  /* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */\n-\n-      else if (GET_MODE_CLASS (mode) == MODE_INT\n-\t       && width > HOST_BITS_PER_WIDE_INT\n-\t       && (GET_CODE (op0) == CONST_DOUBLE\n-\t\t   || GET_CODE (op0) == CONST_INT)\n-\t       && (GET_CODE (op1) == CONST_DOUBLE\n-\t\t   || GET_CODE (op1) == CONST_INT))\n+      else\n \t{\n-\t  HOST_WIDE_INT h0, l0, h1, l1;\n-\t  unsigned HOST_WIDE_INT uh0, ul0, uh1, ul1;\n-\t  int op0lt, op0ltu, equal;\n-\n-\t  if (GET_CODE (op0) == CONST_DOUBLE)\n-\t    l0 = CONST_DOUBLE_LOW (op0), h0 = CONST_DOUBLE_HIGH (op0);\n-\t  else\n-\t    l0 = INTVAL (op0), h0 = l0 < 0 ? -1 : 0;\n+\t  l0u = l0s = INTVAL (op0);\n+\t  h0u = 0, h0s = l0s < 0 ? -1 : 0;\n+\t}\n \t  \n-\t  if (GET_CODE (op1) == CONST_DOUBLE)\n-\t    l1 = CONST_DOUBLE_LOW (op1), h1 = CONST_DOUBLE_HIGH (op1);\n-\t  else\n-\t    l1 = INTVAL (op1), h1 = l1 < 0 ? -1 : 0;\n+      if (GET_CODE (op1) == CONST_DOUBLE)\n+\t{\n+\t  l1u = l1s = CONST_DOUBLE_LOW (op1);\n+\t  h1u = h1s = CONST_DOUBLE_HIGH (op1);\n+\t}\n+      else\n+\t{\n+\t  l1u = l1s = INTVAL (op1);\n+\t  h1u = 0, h1s = l1s < 0 ? -1 : 0;\n+\t}\n \n-\t  uh0 = h0, ul0 = l0, uh1 = h1, ul1 = l1;\n+      /* If WIDTH is nonzero and smaller than HOST_BITS_PER_WIDE_INT,\n+\t we have to sign or zero-extend the values.  */\n+      if (width != 0 && width <= HOST_BITS_PER_WIDE_INT)\n+\th0u = h1u = 0, h0s = l0s < 0 ? -1 : 0, h1s = l1s < 0 ? -1 : 0;\n \n-\t  equal = (h0 == h1 && l0 == l1);\n-\t  op0lt = (h0 < h1 || (h0 == h1 && l0 < l1));\n-\t  op0ltu = (uh0 < uh1 || (uh0 == uh1 && ul0 < ul1));\n+      if (width != 0 && width < HOST_BITS_PER_WIDE_INT)\n+\t{\n+\t  l0u &= ((HOST_WIDE_INT) 1 << width) - 1;\n+\t  l1u &= ((HOST_WIDE_INT) 1 << width) - 1;\n \n-\t  switch (code)\n-\t    {\n-\t    case EQ:\n-\t      return equal ? const_true_rtx : const0_rtx;\n-\t    case NE:\n-\t      return !equal ? const_true_rtx : const0_rtx;\n-\t    case LE:\n-\t      return equal || op0lt ? const_true_rtx : const0_rtx;\n-\t    case LT:\n-\t      return op0lt ? const_true_rtx : const0_rtx;\n-\t    case GE:\n-\t      return !op0lt ? const_true_rtx : const0_rtx;\n-\t    case GT:\n-\t      return !equal && !op0lt ? const_true_rtx : const0_rtx;\n-\t    case LEU:\n-\t      return equal || op0ltu ? const_true_rtx : const0_rtx;\n-\t    case LTU:\n-\t      return op0ltu ? const_true_rtx : const0_rtx;\n-\t    case GEU:\n-\t      return !op0ltu ? const_true_rtx : const0_rtx;\n-\t    case GTU:\n-\t      return !equal && !op0ltu ? const_true_rtx : const0_rtx;\n-\t    }\n+\t  if (l0s & ((HOST_WIDE_INT) 1 << (width - 1)))\n+\t    l0s |= ((HOST_WIDE_INT) (-1) << width);\n+\n+\t  if (l1s & ((HOST_WIDE_INT) 1 << (width - 1)))\n+\t    l1s |= ((HOST_WIDE_INT) (-1) << width);\n \t}\n \n+      equal = (h0u == h1u && l0u == l1u);\n+      op0lt = (h0s < h1s || (h0s == h1s && l0s < l1s));\n+      op1lt = (h1s < h0s || (h1s == h0s && l1s < l0s));\n+      op0ltu = (h0u < h1u || (h0u == h1u && l0u < l1u));\n+      op1ltu = (h1u < h0u || (h1u == h0u && l1u < l0u));\n+    }\n+\n+  /* Otherwise, there are some code-specific tests we can make.  */\n+  else\n+    {\n       switch (code)\n \t{\n \tcase EQ:\n-\t  {\n-#if 0\n-\t    /* We can't make this assumption due to #pragma weak */\n-\t    if (CONSTANT_P (op0) && op1 == const0_rtx)\n-\t      return const0_rtx;\n+\t  /* References to the frame plus a constant or labels cannot\n+\t     be zero, but a SYMBOL_REF can due to #pragma weak.  */\n+\t  if (((NONZERO_BASE_PLUS_P (op0) && op1 == const0_rtx)\n+\t       || GET_CODE (op0) == LABEL_REF)\n+#if FRAME_POINTER_REGNO != ARG_POINTGER_REGNO\n+\t      /* On some machines, the ap reg can be 0 sometimes.  */\n+\t      && op0 != arg_pointer_rtx\n #endif\n-\t    if (NONZERO_BASE_PLUS_P (op0) && op1 == const0_rtx\n-\t\t/* On some machines, the ap reg can be 0 sometimes.  */\n-\t\t&& op0 != arg_pointer_rtx)\n-\t      return const0_rtx;\n-\t    break;\n-\t  }\n+\t\t)\n+\t    return const0_rtx;\n+\t  break;\n \n \tcase NE:\n-#if 0\n-\t  /* We can't make this assumption due to #pragma weak */\n-\t  if (CONSTANT_P (op0) && op1 == const0_rtx)\n-\t    return const_true_rtx;\n+\t  if (((NONZERO_BASE_PLUS_P (op0) && op1 == const0_rtx)\n+\t       || GET_CODE (op0) == LABEL_REF)\n+#if FRAME_POINTER_REGNO != ARG_POINTER_REGNO\n+\t      && op0 != arg_pointer_rtx\n #endif\n-\t  if (NONZERO_BASE_PLUS_P (op0) && op1 == const0_rtx\n-\t      /* On some machines, the ap reg can be 0 sometimes.  */\n-\t      && op0 != arg_pointer_rtx)\n+\t      )\n \t    return const_true_rtx;\n \t  break;\n \n \tcase GEU:\n-\t  /* Unsigned values are never negative, but we must be sure we are\n-\t     actually comparing a value, not a CC operand.  */\n-\t  if (op1 == const0_rtx && INTEGRAL_MODE_P (mode))\n+\t  /* Unsigned values are never negative.  */\n+\t  if (op1 == const0_rtx)\n \t    return const_true_rtx;\n \t  break;\n \n \tcase LTU:\n-\t  if (op1 == const0_rtx && INTEGRAL_MODE_P (mode))\n+\t  if (op1 == const0_rtx)\n \t    return const0_rtx;\n \t  break;\n \n@@ -4450,8 +4451,8 @@ simplify_relational_operation (code, mode, op0, op1)\n \t     unsigned value.  */\n \t  if (GET_CODE (op1) == CONST_INT\n \t      && INTVAL (op1) == GET_MODE_MASK (mode)\n-\t      && INTEGRAL_MODE_P (mode))\n-\t    return const_true_rtx;\n+\t    && INTEGRAL_MODE_P (mode))\n+\t  return const_true_rtx;\n \t  break;\n \n \tcase GTU:\n@@ -4465,92 +4466,33 @@ simplify_relational_operation (code, mode, op0, op1)\n       return 0;\n     }\n \n-  /* Get the integer argument values in two forms:\n-     zero-extended in ARG0, ARG1 and sign-extended in ARG0S, ARG1S.  */\n-\n-  arg0 = INTVAL (op0);\n-  arg1 = INTVAL (op1);\n-\n-  if (width < HOST_BITS_PER_WIDE_INT)\n-    {\n-      arg0 &= ((HOST_WIDE_INT) 1 << width) - 1;\n-      arg1 &= ((HOST_WIDE_INT) 1 << width) - 1;\n-\n-      arg0s = arg0;\n-      if (arg0s & ((HOST_WIDE_INT) 1 << (width - 1)))\n-\targ0s |= ((HOST_WIDE_INT) (-1) << width);\n-\n-      arg1s = arg1;\n-      if (arg1s & ((HOST_WIDE_INT) 1 << (width - 1)))\n-\targ1s |= ((HOST_WIDE_INT) (-1) << width);\n-    }\n-  else\n-    {\n-      arg0s = arg0;\n-      arg1s = arg1;\n-    }\n-\n-  /* Compute the value of the arithmetic.  */\n-\n+  /* If we reach here, EQUAL, OP0LT, OP0LTU, OP1LT, and OP1LTU are set\n+     as appropriate.  */\n   switch (code)\n     {\n-    case NE:\n-      val = arg0 != arg1 ? STORE_FLAG_VALUE : 0;\n-      break;\n-\n     case EQ:\n-      val = arg0 == arg1 ? STORE_FLAG_VALUE : 0;\n-      break;\n-\n-    case LE:\n-      val = arg0s <= arg1s ? STORE_FLAG_VALUE : 0;\n-      break;\n-\n+      return equal ? const_true_rtx : const0_rtx;\n+    case NE:\n+      return ! equal ? const_true_rtx : const0_rtx;\n     case LT:\n-      val = arg0s < arg1s ? STORE_FLAG_VALUE : 0;\n-      break;\n-\n-    case GE:\n-      val = arg0s >= arg1s ? STORE_FLAG_VALUE : 0;\n-      break;\n-\n+      return op0lt ? const_true_rtx : const0_rtx;\n     case GT:\n-      val = arg0s > arg1s ? STORE_FLAG_VALUE : 0;\n-      break;\n-\n-    case LEU:\n-      val = (((unsigned HOST_WIDE_INT) arg0)\n-\t     <= ((unsigned HOST_WIDE_INT) arg1) ? STORE_FLAG_VALUE : 0);\n-      break;\n-\n+      return op1lt ? const_true_rtx : const0_rtx;\n     case LTU:\n-      val = (((unsigned HOST_WIDE_INT) arg0)\n-\t     < ((unsigned HOST_WIDE_INT) arg1) ? STORE_FLAG_VALUE : 0);\n-      break;\n-\n-    case GEU:\n-      val = (((unsigned HOST_WIDE_INT) arg0)\n-\t     >= ((unsigned HOST_WIDE_INT) arg1) ? STORE_FLAG_VALUE : 0);\n-      break;\n-\n+      return op0ltu ? const_true_rtx : const0_rtx;\n     case GTU:\n-      val = (((unsigned HOST_WIDE_INT) arg0)\n-\t     > ((unsigned HOST_WIDE_INT) arg1) ? STORE_FLAG_VALUE : 0);\n-      break;\n-\n-    default:\n-      abort ();\n+      return op1ltu ? const_true_rtx : const0_rtx;\n+    case LE:\n+      return equal || op0lt ? const_true_rtx : const0_rtx;\n+    case GE:\n+      return equal || op1lt ? const_true_rtx : const0_rtx;\n+    case LEU:\n+      return equal || op0ltu ? const_true_rtx : const0_rtx;\n+    case GEU:\n+      return equal || op1ltu ? const_true_rtx : const0_rtx;\n     }\n \n-  /* Clear the bits that don't belong in our mode, unless they and our sign\n-     bit are all one.  So we get either a reasonable negative value or a\n-     reasonable unsigned value for this mode.  */\n-  if (width < HOST_BITS_PER_WIDE_INT\n-      && ((val & ((HOST_WIDE_INT) (-1) << (width - 1)))\n-\t  != ((HOST_WIDE_INT) (-1) << (width - 1))))\n-    val &= ((HOST_WIDE_INT) 1 << width) - 1;\n-  \n-  return GEN_INT (val);\n+  abort ();\n }\n \f\n /* Simplify CODE, an operation with result mode MODE and three operands,"}]}