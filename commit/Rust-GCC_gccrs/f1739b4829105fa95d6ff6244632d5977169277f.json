{"sha": "f1739b4829105fa95d6ff6244632d5977169277f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE3MzliNDgyOTEwNWZhOTVkNmZmNjI0NDYzMmQ1OTc3MTY5Mjc3Zg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-13T17:58:33Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-13T17:58:33Z"}, "message": "SLP reductions with variable-length vectors\n\nTwo things stopped us using SLP reductions with variable-length vectors:\n\n(1) We didn't have a way of constructing the initial vector.\n    This patch does it by creating a vector full of the neutral\n    identity value and then using a shift-and-insert function\n    to insert any non-identity inputs into the low-numbered elements.\n    (The non-identity values are needed for double reductions.)\n    Alternatively, for unchained MIN/MAX reductions that have no neutral\n    value, we instead use the same duplicate-and-interleave approach as\n    for SLP constant and external definitions (added by a previous\n    patch).\n\n(2) The epilogue for constant-length vectors would extract the vector\n    elements associated with each SLP statement and do scalar arithmetic\n    on these individual elements.  For variable-length vectors, the patch\n    instead creates a reduction vector for each SLP statement, replacing\n    the elements for other SLP statements with the identity value.\n    It then uses a hardware reduction instruction on each vector.\n\n2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* doc/md.texi (vec_shl_insert_@var{m}): New optab.\n\t* internal-fn.def (VEC_SHL_INSERT): New internal function.\n\t* optabs.def (vec_shl_insert_optab): New optab.\n\t* tree-vectorizer.h (can_duplicate_and_interleave_p): Declare.\n\t(duplicate_and_interleave): Likewise.\n\t* tree-vect-loop.c: Include internal-fn.h.\n\t(neutral_op_for_slp_reduction): New function, split out from\n\tget_initial_defs_for_reduction.\n\t(get_initial_def_for_reduction): Handle option 2 for variable-length\n\tvectors by loading the neutral value into a vector and then shifting\n\tthe initial value into element 0.\n\t(get_initial_defs_for_reduction): Replace the code argument with\n\tthe neutral value calculated by neutral_op_for_slp_reduction.\n\tUse gimple_build_vector for constant-length vectors.\n\tUse IFN_VEC_SHL_INSERT for variable-length vectors if all\n\tbut the first group_size elements have a neutral value.\n\tUse duplicate_and_interleave otherwise.\n\t(vect_create_epilog_for_reduction): Take a neutral_op parameter.\n\tUpdate call to get_initial_defs_for_reduction.  Handle SLP\n\treductions for variable-length vectors by creating one vector\n\tresult for each scalar result, with the elements associated\n\twith other scalar results stubbed out with the neutral value.\n\t(vectorizable_reduction): Call neutral_op_for_slp_reduction.\n\tRequire IFN_VEC_SHL_INSERT for double reductions on\n\tvariable-length vectors, or SLP reductions that have\n\ta neutral value.  Require can_duplicate_and_interleave_p\n\tsupport for variable-length unchained SLP reductions if there\n\tis no neutral value, such as for MIN/MAX reductions.  Also require\n\tthe number of vector elements to be a multiple of the number of\n\tSLP statements when doing variable-length unchained SLP reductions.\n\tUpdate call to vect_create_epilog_for_reduction.\n\t* tree-vect-slp.c (can_duplicate_and_interleave_p): Make public\n\tand remove initial values.\n\t(duplicate_and_interleave): Make public.\n\t* config/aarch64/aarch64.md (UNSPEC_INSR): New unspec.\n\t* config/aarch64/aarch64-sve.md (vec_shl_insert_<mode>): New insn.\n\ngcc/testsuite/\n\t* gcc.dg/vect/pr37027.c: Remove XFAIL for variable-length vectors.\n\t* gcc.dg/vect/pr67790.c: Likewise.\n\t* gcc.dg/vect/slp-reduc-1.c: Likewise.\n\t* gcc.dg/vect/slp-reduc-2.c: Likewise.\n\t* gcc.dg/vect/slp-reduc-3.c: Likewise.\n\t* gcc.dg/vect/slp-reduc-5.c: Likewise.\n\t* gcc.target/aarch64/sve/slp_5.c: New test.\n\t* gcc.target/aarch64/sve/slp_5_run.c: Likewise.\n\t* gcc.target/aarch64/sve/slp_6.c: Likewise.\n\t* gcc.target/aarch64/sve/slp_6_run.c: Likewise.\n\t* gcc.target/aarch64/sve/slp_7.c: Likewise.\n\t* gcc.target/aarch64/sve/slp_7_run.c: Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256623", "tree": {"sha": "6fa54454f34ebc19c98bb815526c6e51c8bca72d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6fa54454f34ebc19c98bb815526c6e51c8bca72d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1739b4829105fa95d6ff6244632d5977169277f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1739b4829105fa95d6ff6244632d5977169277f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1739b4829105fa95d6ff6244632d5977169277f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1739b4829105fa95d6ff6244632d5977169277f/comments", "author": null, "committer": null, "parents": [{"sha": "018b2744fc7a4fe6fea1a078eae69c5465585668", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/018b2744fc7a4fe6fea1a078eae69c5465585668", "html_url": "https://github.com/Rust-GCC/gccrs/commit/018b2744fc7a4fe6fea1a078eae69c5465585668"}], "stats": {"total": 718, "additions": 637, "deletions": 81}, "files": [{"sha": "77eae2dbf22eca0e22adf44ecdb22d2910c6fc23", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f1739b4829105fa95d6ff6244632d5977169277f", "patch": "@@ -1,3 +1,44 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* doc/md.texi (vec_shl_insert_@var{m}): New optab.\n+\t* internal-fn.def (VEC_SHL_INSERT): New internal function.\n+\t* optabs.def (vec_shl_insert_optab): New optab.\n+\t* tree-vectorizer.h (can_duplicate_and_interleave_p): Declare.\n+\t(duplicate_and_interleave): Likewise.\n+\t* tree-vect-loop.c: Include internal-fn.h.\n+\t(neutral_op_for_slp_reduction): New function, split out from\n+\tget_initial_defs_for_reduction.\n+\t(get_initial_def_for_reduction): Handle option 2 for variable-length\n+\tvectors by loading the neutral value into a vector and then shifting\n+\tthe initial value into element 0.\n+\t(get_initial_defs_for_reduction): Replace the code argument with\n+\tthe neutral value calculated by neutral_op_for_slp_reduction.\n+\tUse gimple_build_vector for constant-length vectors.\n+\tUse IFN_VEC_SHL_INSERT for variable-length vectors if all\n+\tbut the first group_size elements have a neutral value.\n+\tUse duplicate_and_interleave otherwise.\n+\t(vect_create_epilog_for_reduction): Take a neutral_op parameter.\n+\tUpdate call to get_initial_defs_for_reduction.  Handle SLP\n+\treductions for variable-length vectors by creating one vector\n+\tresult for each scalar result, with the elements associated\n+\twith other scalar results stubbed out with the neutral value.\n+\t(vectorizable_reduction): Call neutral_op_for_slp_reduction.\n+\tRequire IFN_VEC_SHL_INSERT for double reductions on\n+\tvariable-length vectors, or SLP reductions that have\n+\ta neutral value.  Require can_duplicate_and_interleave_p\n+\tsupport for variable-length unchained SLP reductions if there\n+\tis no neutral value, such as for MIN/MAX reductions.  Also require\n+\tthe number of vector elements to be a multiple of the number of\n+\tSLP statements when doing variable-length unchained SLP reductions.\n+\tUpdate call to vect_create_epilog_for_reduction.\n+\t* tree-vect-slp.c (can_duplicate_and_interleave_p): Make public\n+\tand remove initial values.\n+\t(duplicate_and_interleave): Make public.\n+\t* config/aarch64/aarch64.md (UNSPEC_INSR): New unspec.\n+\t* config/aarch64/aarch64-sve.md (vec_shl_insert_<mode>): New insn.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "fc3590223fa8e44df33df22d0bc459c27e08ffc6", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=f1739b4829105fa95d6ff6244632d5977169277f", "patch": "@@ -2073,3 +2073,16 @@\n     operands[5] = gen_reg_rtx (VNx4SImode);\n   }\n )\n+\n+;; Shift an SVE vector left and insert a scalar into element 0.\n+(define_insn \"vec_shl_insert_<mode>\"\n+  [(set (match_operand:SVE_ALL 0 \"register_operand\" \"=w, w\")\n+\t(unspec:SVE_ALL\n+\t  [(match_operand:SVE_ALL 1 \"register_operand\" \"0, 0\")\n+\t   (match_operand:<VEL> 2 \"register_operand\" \"rZ, w\")]\n+\t  UNSPEC_INSR))]\n+  \"TARGET_SVE\"\n+  \"@\n+   insr\\t%0.<Vetype>, %<vwcore>2\n+   insr\\t%0.<Vetype>, %<Vetype>2\"\n+)"}, {"sha": "f19150203ab7273a20f0de69f483f32e609c8621", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=f1739b4829105fa95d6ff6244632d5977169277f", "patch": "@@ -163,6 +163,7 @@\n     UNSPEC_WHILE_LO\n     UNSPEC_LDN\n     UNSPEC_STN\n+    UNSPEC_INSR\n ])\n \n (define_c_enum \"unspecv\" ["}, {"sha": "4f635b03c23eb5d0a4c5598633dc1aecc68ba909", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=f1739b4829105fa95d6ff6244632d5977169277f", "patch": "@@ -5224,6 +5224,14 @@ operand 1. Add operand 1 to operand 2 and place the widened result in\n operand 0. (This is used express accumulation of elements into an accumulator\n of a wider mode.)\n \n+@cindex @code{vec_shl_insert_@var{m}} instruction pattern\n+@item @samp{vec_shl_insert_@var{m}}\n+Shift the elements in vector input operand 1 left one element (i.e.\n+away from element 0) and fill the vacated element 0 with the scalar\n+in operand 2.  Store the result in vector output operand 0.  Operands\n+0 and 1 have mode @var{m} and operand 2 has the mode appropriate for\n+one element of @var{m}.\n+\n @cindex @code{vec_shr_@var{m}} instruction pattern\n @item @samp{vec_shr_@var{m}}\n Whole vector right shift in bits, i.e. towards element 0."}, {"sha": "925a23068b8257840b663fe4abc808bc7a9d2bc4", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=f1739b4829105fa95d6ff6244632d5977169277f", "patch": "@@ -116,6 +116,9 @@ DEF_INTERNAL_OPTAB_FN (STORE_LANES, ECF_CONST, vec_store_lanes, store_lanes)\n DEF_INTERNAL_OPTAB_FN (MASK_STORE_LANES, 0,\n \t\t       vec_mask_store_lanes, mask_store_lanes)\n \n+DEF_INTERNAL_OPTAB_FN (VEC_SHL_INSERT, ECF_CONST | ECF_NOTHROW,\n+\t\t       vec_shl_insert, binary)\n+\n DEF_INTERNAL_OPTAB_FN (RSQRT, ECF_CONST, rsqrt, unary)\n \n DEF_INTERNAL_OPTAB_FN (REDUC_PLUS, ECF_CONST | ECF_NOTHROW,"}, {"sha": "ec5f5f544eaec991f30a046ac1eda9cf3de930ed", "filename": "gcc/optabs.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=f1739b4829105fa95d6ff6244632d5977169277f", "patch": "@@ -368,3 +368,4 @@ OPTAB_D (set_thread_pointer_optab, \"set_thread_pointer$I$a\")\n \n OPTAB_DC (vec_duplicate_optab, \"vec_duplicate$a\", VEC_DUPLICATE)\n OPTAB_DC (vec_series_optab, \"vec_series$a\", VEC_SERIES)\n+OPTAB_D (vec_shl_insert_optab, \"vec_shl_insert_$a\")"}, {"sha": "d3ec83ce526beddf94ace48f1e9a24692eff95bf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f1739b4829105fa95d6ff6244632d5977169277f", "patch": "@@ -1,3 +1,20 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* gcc.dg/vect/pr37027.c: Remove XFAIL for variable-length vectors.\n+\t* gcc.dg/vect/pr67790.c: Likewise.\n+\t* gcc.dg/vect/slp-reduc-1.c: Likewise.\n+\t* gcc.dg/vect/slp-reduc-2.c: Likewise.\n+\t* gcc.dg/vect/slp-reduc-3.c: Likewise.\n+\t* gcc.dg/vect/slp-reduc-5.c: Likewise.\n+\t* gcc.target/aarch64/sve/slp_5.c: New test.\n+\t* gcc.target/aarch64/sve/slp_5_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/slp_6.c: Likewise.\n+\t* gcc.target/aarch64/sve/slp_6_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/slp_7.c: Likewise.\n+\t* gcc.target/aarch64/sve/slp_7_run.c: Likewise.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "ef6760ec9247d1b2fe8583c62a1d6ff0ff21e45b", "filename": "gcc/testsuite/gcc.dg/vect/pr37027.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr37027.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr37027.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr37027.c?ref=f1739b4829105fa95d6ff6244632d5977169277f", "patch": "@@ -32,5 +32,5 @@ foo (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_int_add } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { xfail { vect_no_int_add || vect_variable_length } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { xfail vect_no_int_add } } } */\n "}, {"sha": "5e2d506a730b3d44e5153c08b9b6dca57c0f8402", "filename": "gcc/testsuite/gcc.dg/vect/pr67790.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr67790.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr67790.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr67790.c?ref=f1739b4829105fa95d6ff6244632d5977169277f", "patch": "@@ -37,4 +37,4 @@ int main()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump \"vectorizing stmts using SLP\" \"vect\" { xfail vect_variable_length } } } */\n+/* { dg-final { scan-tree-dump \"vectorizing stmts using SLP\" \"vect\" } } */"}, {"sha": "b353dd7ccf8270624a0df5498bcf3cf6f82372c7", "filename": "gcc/testsuite/gcc.dg/vect/slp-reduc-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-reduc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-reduc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-reduc-1.c?ref=f1739b4829105fa95d6ff6244632d5977169277f", "patch": "@@ -43,5 +43,5 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_int_add } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { xfail { vect_no_int_add || vect_variable_length } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { xfail vect_no_int_add } } } */\n "}, {"sha": "07c96c00eb0e312310a5b3434e103c2962692b77", "filename": "gcc/testsuite/gcc.dg/vect/slp-reduc-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-reduc-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-reduc-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-reduc-2.c?ref=f1739b4829105fa95d6ff6244632d5977169277f", "patch": "@@ -38,5 +38,5 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_int_add } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { xfail { vect_no_int_add || vect_variable_length } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { xfail vect_no_int_add } } } */\n "}, {"sha": "9c8124c9b5f289d0a2ed49d3c8ee626d0bf05862", "filename": "gcc/testsuite/gcc.dg/vect/slp-reduc-3.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-reduc-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-reduc-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-reduc-3.c?ref=f1739b4829105fa95d6ff6244632d5977169277f", "patch": "@@ -58,7 +58,4 @@ int main (void)\n /* The initialization loop in main also gets vectorized.  */\n /* { dg-final { scan-tree-dump-times \"vect_recog_dot_prod_pattern: detected\" 1 \"vect\" { xfail *-*-* } } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { target { vect_short_mult && { vect_widen_sum_hi_to_si  && vect_unpack } } } } } */ \n-/* We can't yet create the necessary SLP constant vector for variable-length\n-   SVE and so fall back to Advanced SIMD.  This means that we repeat each\n-   analysis note.  */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { xfail { vect_widen_sum_hi_to_si_pattern || { { ! vect_unpack } || { aarch64_sve && vect_variable_length } } } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { xfail { vect_widen_sum_hi_to_si_pattern || { ! vect_unpack } } } } } */"}, {"sha": "fc689e46ba16683b1d384207c148edb9ff938742", "filename": "gcc/testsuite/gcc.dg/vect/slp-reduc-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-reduc-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-reduc-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-reduc-5.c?ref=f1739b4829105fa95d6ff6244632d5977169277f", "patch": "@@ -43,5 +43,5 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail vect_no_int_min_max } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { xfail { vect_no_int_min_max || vect_variable_length } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { xfail vect_no_int_min_max } } } */\n "}, {"sha": "4e2641929efed43ff765c9824698f0df3ed3e349", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_5.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_5.c?ref=f1739b4829105fa95d6ff6244632d5977169277f", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -msve-vector-bits=scalable -ffast-math\" } */\n+\n+#include <stdint.h>\n+\n+#define VEC_PERM(TYPE)\t\t\t\t\t\t\\\n+void __attribute__ ((noinline, noclone))\t\t\t\\\n+vec_slp_##TYPE (TYPE *restrict a, TYPE *restrict b, int n)\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  TYPE x0 = b[0];\t\t\t\t\t\t\\\n+  TYPE x1 = b[1];\t\t\t\t\t\t\\\n+  for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      x0 += a[i * 2];\t\t\t\t\t\t\\\n+      x1 += a[i * 2 + 1];\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  b[0] = x0;\t\t\t\t\t\t\t\\\n+  b[1] = x1;\t\t\t\t\t\t\t\\\n+}\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  T (int8_t)\t\t\t\t\t\\\n+  T (uint8_t)\t\t\t\t\t\\\n+  T (int16_t)\t\t\t\t\t\\\n+  T (uint16_t)\t\t\t\t\t\\\n+  T (int32_t)\t\t\t\t\t\\\n+  T (uint32_t)\t\t\t\t\t\\\n+  T (int64_t)\t\t\t\t\t\\\n+  T (uint64_t)\t\t\t\t\t\\\n+  T (_Float16)\t\t\t\t\t\\\n+  T (float)\t\t\t\t\t\\\n+  T (double)\n+\n+TEST_ALL (VEC_PERM)\n+\n+/* ??? We don't think it's worth using SLP for the 64-bit loops and fall\n+   back to the less efficient non-SLP implementation instead.  */\n+/* ??? At present we don't treat the int8_t and int16_t loops as\n+   reductions.  */\n+/* { dg-final { scan-assembler-times {\\tld1b\\t} 2 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tld1h\\t} 3 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tld1b\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld1h\\t} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\t} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\t} 3 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-not {\\tld2b\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tld2h\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tld2w\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tld2d\\t} { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tuaddv\\td[0-9]+, p[0-7], z[0-9]+\\.b} 4 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tuaddv\\td[0-9]+, p[0-7], z[0-9]+\\.h} 4 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tuaddv\\td[0-9]+, p[0-7], z[0-9]+\\.b} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tuaddv\\td[0-9]+, p[0-7], z[0-9]+\\.h} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tuaddv\\td[0-9]+, p[0-7], z[0-9]+\\.s} 4 } } */\n+/* { dg-final { scan-assembler-times {\\tuaddv\\td[0-9]+, p[0-7], z[0-9]+\\.d} 4 } } */\n+/* { dg-final { scan-assembler-times {\\tfaddv\\th[0-9]+, p[0-7], z[0-9]+\\.h} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfaddv\\ts[0-9]+, p[0-7], z[0-9]+\\.s} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfaddv\\td[0-9]+, p[0-7], z[0-9]+\\.d} 2 } } */"}, {"sha": "043c9b83edac0d01e1b8c0de4ff562acc40dcb05", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_5_run.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_5_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_5_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_5_run.c?ref=f1739b4829105fa95d6ff6244632d5977169277f", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math\" } */\n+\n+#include \"slp_5.c\"\n+\n+#define N (141 * 2)\n+\n+#define HARNESS(TYPE)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    TYPE a[N], b[2] = { 40, 22 };\t\t\t\\\n+    for (unsigned int i = 0; i < N; ++i)\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\ta[i] = i * 2 + i % 5;\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    vec_slp_##TYPE (a, b, N / 2);\t\t\t\\\n+    TYPE x0 = 40;\t\t\t\t\t\\\n+    TYPE x1 = 22;\t\t\t\t\t\\\n+    for (unsigned int i = 0; i < N; i += 2)\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tx0 += a[i];\t\t\t\t\t\\\n+\tx1 += a[i + 1];\t\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    /* _Float16 isn't precise enough for this.  */\t\\\n+    if ((TYPE) 0x1000 + 1 != (TYPE) 0x1000\t\t\\\n+\t&& (x0 != b[0] || x1 != b[1]))\t\t\t\\\n+      __builtin_abort ();\t\t\t\t\\\n+  }\n+\n+int __attribute__ ((optimize (1)))\n+main (void)\n+{\n+  TEST_ALL (HARNESS)\n+}"}, {"sha": "d551fa6fbdce42e2dbdf49f1eb84a827a7ab0e9f", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_6.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_6.c?ref=f1739b4829105fa95d6ff6244632d5977169277f", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -msve-vector-bits=scalable -ffast-math\" } */\n+\n+#include <stdint.h>\n+\n+#define VEC_PERM(TYPE)\t\t\t\t\t\t\\\n+void __attribute__ ((noinline, noclone))\t\t\t\\\n+vec_slp_##TYPE (TYPE *restrict a, TYPE *restrict b, int n)\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  TYPE x0 = b[0];\t\t\t\t\t\t\\\n+  TYPE x1 = b[1];\t\t\t\t\t\t\\\n+  TYPE x2 = b[2];\t\t\t\t\t\t\\\n+  for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      x0 += a[i * 3];\t\t\t\t\t\t\\\n+      x1 += a[i * 3 + 1];\t\t\t\t\t\\\n+      x2 += a[i * 3 + 2];\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  b[0] = x0;\t\t\t\t\t\t\t\\\n+  b[1] = x1;\t\t\t\t\t\t\t\\\n+  b[2] = x2;\t\t\t\t\t\t\t\\\n+}\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  T (int8_t)\t\t\t\t\t\\\n+  T (uint8_t)\t\t\t\t\t\\\n+  T (int16_t)\t\t\t\t\t\\\n+  T (uint16_t)\t\t\t\t\t\\\n+  T (int32_t)\t\t\t\t\t\\\n+  T (uint32_t)\t\t\t\t\t\\\n+  T (int64_t)\t\t\t\t\t\\\n+  T (uint64_t)\t\t\t\t\t\\\n+  T (_Float16)\t\t\t\t\t\\\n+  T (float)\t\t\t\t\t\\\n+  T (double)\n+\n+TEST_ALL (VEC_PERM)\n+\n+/* These loops can't use SLP.  */\n+/* { dg-final { scan-assembler-not {\\tld1b\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tld1h\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tld1w\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tld1d\\t} } } */\n+/* { dg-final { scan-assembler {\\tld3b\\t} } } */\n+/* { dg-final { scan-assembler {\\tld3h\\t} } } */\n+/* { dg-final { scan-assembler {\\tld3w\\t} } } */\n+/* { dg-final { scan-assembler {\\tld3d\\t} } } */"}, {"sha": "f1aeb5cd305b065d4b86dfe247ecae97308c194b", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_6_run.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_6_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_6_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_6_run.c?ref=f1739b4829105fa95d6ff6244632d5977169277f", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math\" } */\n+\n+#include \"slp_6.c\"\n+\n+#define N (77 * 3)\n+\n+#define HARNESS(TYPE)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    TYPE a[N], b[3] = { 40, 22, 75 };\t\t\t\\\n+    for (unsigned int i = 0; i < N; ++i)\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\ta[i] = i * 2 + i % 5;\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    vec_slp_##TYPE (a, b, N / 3);\t\t\t\\\n+    TYPE x0 = 40;\t\t\t\t\t\\\n+    TYPE x1 = 22;\t\t\t\t\t\\\n+    TYPE x2 = 75;\t\t\t\t\t\\\n+    for (unsigned int i = 0; i < N; i += 3)\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tx0 += a[i];\t\t\t\t\t\\\n+\tx1 += a[i + 1];\t\t\t\t\t\\\n+\tx2 += a[i + 2];\t\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    /* _Float16 isn't precise enough for this.  */\t\\\n+    if ((TYPE) 0x1000 + 1 != (TYPE) 0x1000\t\t\\\n+\t&& (x0 != b[0] || x1 != b[1] || x2 != b[2]))\t\\\n+      __builtin_abort ();\t\t\t\t\\\n+  }\n+\n+int __attribute__ ((optimize (1)))\n+main (void)\n+{\n+  TEST_ALL (HARNESS)\n+}"}, {"sha": "76abbdcf8aa99a7ba1916e7248ba0cc3dfa79ef3", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_7.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_7.c?ref=f1739b4829105fa95d6ff6244632d5977169277f", "patch": "@@ -0,0 +1,66 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -msve-vector-bits=scalable -ffast-math\" } */\n+\n+#include <stdint.h>\n+\n+#define VEC_PERM(TYPE)\t\t\t\t\t\t\\\n+void __attribute__ ((noinline, noclone))\t\t\t\\\n+vec_slp_##TYPE (TYPE *restrict a, TYPE *restrict b, int n)\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  TYPE x0 = b[0];\t\t\t\t\t\t\\\n+  TYPE x1 = b[1];\t\t\t\t\t\t\\\n+  TYPE x2 = b[2];\t\t\t\t\t\t\\\n+  TYPE x3 = b[3];\t\t\t\t\t\t\\\n+  for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      x0 += a[i * 4];\t\t\t\t\t\t\\\n+      x1 += a[i * 4 + 1];\t\t\t\t\t\\\n+      x2 += a[i * 4 + 2];\t\t\t\t\t\\\n+      x3 += a[i * 4 + 3];\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  b[0] = x0;\t\t\t\t\t\t\t\\\n+  b[1] = x1;\t\t\t\t\t\t\t\\\n+  b[2] = x2;\t\t\t\t\t\t\t\\\n+  b[3] = x3;\t\t\t\t\t\t\t\\\n+}\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  T (int8_t)\t\t\t\t\t\\\n+  T (uint8_t)\t\t\t\t\t\\\n+  T (int16_t)\t\t\t\t\t\\\n+  T (uint16_t)\t\t\t\t\t\\\n+  T (int32_t)\t\t\t\t\t\\\n+  T (uint32_t)\t\t\t\t\t\\\n+  T (int64_t)\t\t\t\t\t\\\n+  T (uint64_t)\t\t\t\t\t\\\n+  T (_Float16)\t\t\t\t\t\\\n+  T (float)\t\t\t\t\t\\\n+  T (double)\n+\n+TEST_ALL (VEC_PERM)\n+\n+/* We can't use SLP for the 64-bit loops, since the number of reduction\n+   results might be greater than the number of elements in the vector.\n+   Otherwise we have two loads per loop, one for the initial vector\n+   and one for the loop body.  */\n+/* ??? At present we don't treat the int8_t and int16_t loops as\n+   reductions.  */\n+/* { dg-final { scan-assembler-times {\\tld1b\\t} 2 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tld1h\\t} 3 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tld1b\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld1h\\t} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\t} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld4d\\t} 3 } } */\n+/* { dg-final { scan-assembler-not {\\tld4b\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tld4h\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tld4w\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tld1d\\t} } } */\n+/* { dg-final { scan-assembler-times {\\tuaddv\\td[0-9]+, p[0-7], z[0-9]+\\.b} 8 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tuaddv\\td[0-9]+, p[0-7], z[0-9]+\\.h} 8 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tuaddv\\td[0-9]+, p[0-7], z[0-9]+\\.b} 4 } } */\n+/* { dg-final { scan-assembler-times {\\tuaddv\\td[0-9]+, p[0-7], z[0-9]+\\.h} 4 } } */\n+/* { dg-final { scan-assembler-times {\\tuaddv\\td[0-9]+, p[0-7], z[0-9]+\\.s} 8 } } */\n+/* { dg-final { scan-assembler-times {\\tuaddv\\td[0-9]+, p[0-7], z[0-9]+\\.d} 8 } } */\n+/* { dg-final { scan-assembler-times {\\tfaddv\\th[0-9]+, p[0-7], z[0-9]+\\.h} 4 } } */\n+/* { dg-final { scan-assembler-times {\\tfaddv\\ts[0-9]+, p[0-7], z[0-9]+\\.s} 4 } } */\n+/* { dg-final { scan-assembler-times {\\tfaddv\\td[0-9]+, p[0-7], z[0-9]+\\.d} 4 } } */"}, {"sha": "3cc090d5a14b39fa1b00713000b31cd9c752538f", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_7_run.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_7_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_7_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_7_run.c?ref=f1739b4829105fa95d6ff6244632d5977169277f", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math\" } */\n+\n+#include \"slp_7.c\"\n+\n+#define N (54 * 4)\n+\n+#define HARNESS(TYPE)\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    TYPE a[N], b[4] = { 40, 22, 75, 19 };\t\t\t\t\\\n+    for (unsigned int i = 0; i < N; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\ta[i] = i * 2 + i % 5;\t\t\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    vec_slp_##TYPE (a, b, N / 4);\t\t\t\t\t\\\n+    TYPE x0 = 40;\t\t\t\t\t\t\t\\\n+    TYPE x1 = 22;\t\t\t\t\t\t\t\\\n+    TYPE x2 = 75;\t\t\t\t\t\t\t\\\n+    TYPE x3 = 19;\t\t\t\t\t\t\t\\\n+    for (unsigned int i = 0; i < N; i += 4)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tx0 += a[i];\t\t\t\t\t\t\t\\\n+\tx1 += a[i + 1];\t\t\t\t\t\t\t\\\n+\tx2 += a[i + 2];\t\t\t\t\t\t\t\\\n+\tx3 += a[i + 3];\t\t\t\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    /* _Float16 isn't precise enough for this.  */\t\t\t\\\n+    if ((TYPE) 0x1000 + 1 != (TYPE) 0x1000\t\t\t\t\\\n+\t&& (x0 != b[0] || x1 != b[1] || x2 != b[2] || x3 != b[3]))\t\\\n+      __builtin_abort ();\t\t\t\t\t\t\\\n+  }\n+\n+int __attribute__ ((optimize (1)))\n+main (void)\n+{\n+  TEST_ALL (HARNESS)\n+}"}, {"sha": "9219a0dd9f8b763209f99ec9bf0b331c145f313e", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 255, "deletions": 67, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=f1739b4829105fa95d6ff6244632d5977169277f", "patch": "@@ -2451,6 +2451,54 @@ reduction_fn_for_scalar_code (enum tree_code code, internal_fn *reduc_fn)\n     }\n }\n \n+/* If there is a neutral value X such that SLP reduction NODE would not\n+   be affected by the introduction of additional X elements, return that X,\n+   otherwise return null.  CODE is the code of the reduction.  REDUC_CHAIN\n+   is true if the SLP statements perform a single reduction, false if each\n+   statement performs an independent reduction.  */\n+\n+static tree\n+neutral_op_for_slp_reduction (slp_tree slp_node, tree_code code,\n+\t\t\t      bool reduc_chain)\n+{\n+  vec<gimple *> stmts = SLP_TREE_SCALAR_STMTS (slp_node);\n+  gimple *stmt = stmts[0];\n+  stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n+  tree vector_type = STMT_VINFO_VECTYPE (stmt_vinfo);\n+  tree scalar_type = TREE_TYPE (vector_type);\n+  struct loop *loop = gimple_bb (stmt)->loop_father;\n+  gcc_assert (loop);\n+\n+  switch (code)\n+    {\n+    case WIDEN_SUM_EXPR:\n+    case DOT_PROD_EXPR:\n+    case SAD_EXPR:\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+      return build_zero_cst (scalar_type);\n+\n+    case MULT_EXPR:\n+      return build_one_cst (scalar_type);\n+\n+    case BIT_AND_EXPR:\n+      return build_all_ones_cst (scalar_type);\n+\n+    case MAX_EXPR:\n+    case MIN_EXPR:\n+      /* For MIN/MAX the initial values are neutral.  A reduction chain\n+\t has only a single initial value, so that value is neutral for\n+\t all statements.  */\n+      if (reduc_chain)\n+\treturn PHI_ARG_DEF_FROM_EDGE (stmt, loop_preheader_edge (loop));\n+      return NULL_TREE;\n+\n+    default:\n+      return NULL_TREE;\n+    }\n+}\n \n /* Error reporting helper for vect_is_simple_reduction below.  GIMPLE statement\n    STMT is printed with a message MSG. */\n@@ -4095,6 +4143,16 @@ get_initial_def_for_reduction (gimple *stmt, tree init_val,\n \t  /* Option1: the first element is '0' or '1' as well.  */\n \t  init_def = gimple_build_vector_from_val (&stmts, vectype,\n \t\t\t\t\t\t   def_for_init);\n+\telse if (!TYPE_VECTOR_SUBPARTS (vectype).is_constant ())\n+\t  {\n+\t    /* Option2 (variable length): the first element is INIT_VAL.  */\n+\t    init_def = build_vector_from_val (vectype, def_for_init);\n+\t    gcall *call = gimple_build_call_internal (IFN_VEC_SHL_INSERT,\n+\t\t\t\t\t\t      2, init_def, init_val);\n+\t    init_def = make_ssa_name (vectype);\n+\t    gimple_call_set_lhs (call, init_def);\n+\t    gimple_seq_add_stmt (&stmts, call);\n+\t  }\n \telse\n \t  {\n \t    /* Option2: the first element is INIT_VAL.  */\n@@ -4134,80 +4192,40 @@ get_initial_def_for_reduction (gimple *stmt, tree init_val,\n }\n \n /* Get at the initial defs for the reduction PHIs in SLP_NODE.\n-   NUMBER_OF_VECTORS is the number of vector defs to create.  */\n+   NUMBER_OF_VECTORS is the number of vector defs to create.\n+   If NEUTRAL_OP is nonnull, introducing extra elements of that\n+   value will not change the result.  */\n \n static void\n get_initial_defs_for_reduction (slp_tree slp_node,\n \t\t\t\tvec<tree> *vec_oprnds,\n \t\t\t\tunsigned int number_of_vectors,\n-\t\t\t\tenum tree_code code, bool reduc_chain)\n+\t\t\t\tbool reduc_chain, tree neutral_op)\n {\n   vec<gimple *> stmts = SLP_TREE_SCALAR_STMTS (slp_node);\n   gimple *stmt = stmts[0];\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n-  unsigned nunits;\n+  unsigned HOST_WIDE_INT nunits;\n   unsigned j, number_of_places_left_in_vector;\n-  tree vector_type, scalar_type;\n+  tree vector_type;\n   tree vop;\n   int group_size = stmts.length ();\n   unsigned int vec_num, i;\n   unsigned number_of_copies = 1;\n   vec<tree> voprnds;\n   voprnds.create (number_of_vectors);\n-  tree neutral_op = NULL;\n   struct loop *loop;\n+  auto_vec<tree, 16> permute_results;\n \n   vector_type = STMT_VINFO_VECTYPE (stmt_vinfo);\n-  scalar_type = TREE_TYPE (vector_type);\n-  /* vectorizable_reduction has already rejected SLP reductions on\n-     variable-length vectors.  */\n-  nunits = TYPE_VECTOR_SUBPARTS (vector_type).to_constant ();\n \n   gcc_assert (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def);\n \n   loop = (gimple_bb (stmt))->loop_father;\n   gcc_assert (loop);\n   edge pe = loop_preheader_edge (loop);\n \n-  /* op is the reduction operand of the first stmt already.  */\n-  /* For additional copies (see the explanation of NUMBER_OF_COPIES below)\n-     we need either neutral operands or the original operands.  See\n-     get_initial_def_for_reduction() for details.  */\n-  switch (code)\n-    {\n-    case WIDEN_SUM_EXPR:\n-    case DOT_PROD_EXPR:\n-    case SAD_EXPR:\n-    case PLUS_EXPR:\n-    case MINUS_EXPR:\n-    case BIT_IOR_EXPR:\n-    case BIT_XOR_EXPR:\n-      neutral_op = build_zero_cst (scalar_type);\n-      break;\n-\n-    case MULT_EXPR:\n-      neutral_op = build_one_cst (scalar_type);\n-      break;\n-\n-    case BIT_AND_EXPR:\n-      neutral_op = build_all_ones_cst (scalar_type);\n-      break;\n-\n-    /* For MIN/MAX we don't have an easy neutral operand but\n-       the initial values can be used fine here.  Only for\n-       a reduction chain we have to force a neutral element.  */\n-    case MAX_EXPR:\n-    case MIN_EXPR:\n-      if (! reduc_chain)\n-\tneutral_op = NULL;\n-      else\n-\tneutral_op = PHI_ARG_DEF_FROM_EDGE (stmt, pe);\n-      break;\n-\n-    default:\n-      gcc_assert (! reduc_chain);\n-      neutral_op = NULL;\n-    }\n+  gcc_assert (!reduc_chain || neutral_op);\n \n   /* NUMBER_OF_COPIES is the number of times we need to use the same values in\n      created vectors. It is greater than 1 if unrolling is performed.\n@@ -4225,9 +4243,13 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n      (s1, s2, ..., s8).  We will create two vectors {s1, s2, s3, s4} and\n      {s5, s6, s7, s8}.  */\n \n+  if (!TYPE_VECTOR_SUBPARTS (vector_type).is_constant (&nunits))\n+    nunits = group_size;\n+\n   number_of_copies = nunits * number_of_vectors / group_size;\n \n   number_of_places_left_in_vector = nunits;\n+  bool constant_p = true;\n   tree_vector_builder elts (vector_type, nunits, 1);\n   elts.quick_grow (nunits);\n   for (j = 0; j < number_of_copies; j++)\n@@ -4247,18 +4269,56 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n           /* Create 'vect_ = {op0,op1,...,opn}'.  */\n           number_of_places_left_in_vector--;\n \t  elts[number_of_places_left_in_vector] = op;\n+\t  if (!CONSTANT_CLASS_P (op))\n+\t    constant_p = false;\n \n           if (number_of_places_left_in_vector == 0)\n             {\n \t      gimple_seq ctor_seq = NULL;\n-\t      tree init = gimple_build_vector (&ctor_seq, &elts);\n+\t      tree init;\n+\t      if (constant_p && !neutral_op\n+\t\t  ? multiple_p (TYPE_VECTOR_SUBPARTS (vector_type), nunits)\n+\t\t  : known_eq (TYPE_VECTOR_SUBPARTS (vector_type), nunits))\n+\t\t/* Build the vector directly from ELTS.  */\n+\t\tinit = gimple_build_vector (&ctor_seq, &elts);\n+\t      else if (neutral_op)\n+\t\t{\n+\t\t  /* Build a vector of the neutral value and shift the\n+\t\t     other elements into place.  */\n+\t\t  init = gimple_build_vector_from_val (&ctor_seq, vector_type,\n+\t\t\t\t\t\t       neutral_op);\n+\t\t  int k = nunits;\n+\t\t  while (k > 0 && elts[k - 1] == neutral_op)\n+\t\t    k -= 1;\n+\t\t  while (k > 0)\n+\t\t    {\n+\t\t      k -= 1;\n+\t\t      gcall *call = gimple_build_call_internal\n+\t\t\t(IFN_VEC_SHL_INSERT, 2, init, elts[k]);\n+\t\t      init = make_ssa_name (vector_type);\n+\t\t      gimple_call_set_lhs (call, init);\n+\t\t      gimple_seq_add_stmt (&ctor_seq, call);\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* First time round, duplicate ELTS to fill the\n+\t\t     required number of vectors, then cherry pick the\n+\t\t     appropriate result for each iteration.  */\n+\t\t  if (vec_oprnds->is_empty ())\n+\t\t    duplicate_and_interleave (&ctor_seq, vector_type, elts,\n+\t\t\t\t\t      number_of_vectors,\n+\t\t\t\t\t      permute_results);\n+\t\t  init = permute_results[number_of_vectors - j - 1];\n+\t\t}\n \t      if (ctor_seq != NULL)\n \t\tgsi_insert_seq_on_edge_immediate (pe, ctor_seq);\n \t      voprnds.quick_push (init);\n \n               number_of_places_left_in_vector = nunits;\n \t      elts.new_vector (vector_type, nunits, 1);\n \t      elts.quick_grow (nunits);\n+\t      constant_p = true;\n             }\n         }\n     }\n@@ -4328,6 +4388,8 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n      be smaller than any value of the IV in the loop, for MIN_EXPR larger than\n      any value of the IV in the loop.\n    INDUC_CODE is the code for epilog reduction if INTEGER_INDUC_COND_REDUCTION.\n+   NEUTRAL_OP is the value given by neutral_op_for_slp_reduction; it is\n+     null if this is not an SLP reduction\n \n    This function:\n    1. Creates the reduction def-use cycles: sets the arguments for \n@@ -4376,7 +4438,8 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n                                   bool double_reduc, \n \t\t\t\t  slp_tree slp_node,\n \t\t\t\t  slp_instance slp_node_instance,\n-\t\t\t\t  tree induc_val, enum tree_code induc_code)\n+\t\t\t\t  tree induc_val, enum tree_code induc_code,\n+\t\t\t\t  tree neutral_op)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   stmt_vec_info prev_phi_info;\n@@ -4412,6 +4475,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n   auto_vec<tree> vec_initial_defs;\n   auto_vec<gimple *> phis;\n   bool slp_reduc = false;\n+  bool direct_slp_reduc;\n   tree new_phi_result;\n   gimple *inner_phi = NULL;\n   tree induction_index = NULL_TREE;\n@@ -4455,8 +4519,9 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n       unsigned vec_num = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n       vec_initial_defs.reserve (vec_num);\n       get_initial_defs_for_reduction (slp_node_instance->reduc_phis,\n-\t\t\t\t      &vec_initial_defs, vec_num, code,\n-\t\t\t\t      GROUP_FIRST_ELEMENT (stmt_info));\n+\t\t\t\t      &vec_initial_defs, vec_num,\n+\t\t\t\t      GROUP_FIRST_ELEMENT (stmt_info),\n+\t\t\t\t      neutral_op);\n     }\n   else\n     {\n@@ -4763,14 +4828,20 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n      b2 = operation (b1)  */\n   slp_reduc = (slp_node && !GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)));\n \n+  /* True if we should implement SLP_REDUC using native reduction operations\n+     instead of scalar operations.  */\n+  direct_slp_reduc = (reduc_fn != IFN_LAST\n+\t\t      && slp_reduc\n+\t\t      && !TYPE_VECTOR_SUBPARTS (vectype).is_constant ());\n+\n   /* In case of reduction chain, e.g.,\n      # a1 = phi <a3, a0>\n      a2 = operation (a1)\n      a3 = operation (a2),\n \n      we may end up with more than one vector result.  Here we reduce them to\n      one vector.  */\n-  if (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n+  if (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) || direct_slp_reduc)\n     {\n       tree first_vect = PHI_RESULT (new_phis[0]);\n       gassign *new_vec_stmt = NULL;\n@@ -5061,6 +5132,83 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n \n       scalar_results.safe_push (new_temp);\n     }\n+  else if (direct_slp_reduc)\n+    {\n+      /* Here we create one vector for each of the GROUP_SIZE results,\n+\t with the elements for other SLP statements replaced with the\n+\t neutral value.  We can then do a normal reduction on each vector.  */\n+\n+      /* Enforced by vectorizable_reduction.  */\n+      gcc_assert (new_phis.length () == 1);\n+      gcc_assert (pow2p_hwi (group_size));\n+\n+      slp_tree orig_phis_slp_node = slp_node_instance->reduc_phis;\n+      vec<gimple *> orig_phis = SLP_TREE_SCALAR_STMTS (orig_phis_slp_node);\n+      gimple_seq seq = NULL;\n+\n+      /* Build a vector {0, 1, 2, ...}, with the same number of elements\n+\t and the same element size as VECTYPE.  */\n+      tree index = build_index_vector (vectype, 0, 1);\n+      tree index_type = TREE_TYPE (index);\n+      tree index_elt_type = TREE_TYPE (index_type);\n+      tree mask_type = build_same_sized_truth_vector_type (index_type);\n+\n+      /* Create a vector that, for each element, identifies which of\n+\t the GROUP_SIZE results should use it.  */\n+      tree index_mask = build_int_cst (index_elt_type, group_size - 1);\n+      index = gimple_build (&seq, BIT_AND_EXPR, index_type, index,\n+\t\t\t    build_vector_from_val (index_type, index_mask));\n+\n+      /* Get a neutral vector value.  This is simply a splat of the neutral\n+\t scalar value if we have one, otherwise the initial scalar value\n+\t is itself a neutral value.  */\n+      tree vector_identity = NULL_TREE;\n+      if (neutral_op)\n+\tvector_identity = gimple_build_vector_from_val (&seq, vectype,\n+\t\t\t\t\t\t\tneutral_op);\n+      for (unsigned int i = 0; i < group_size; ++i)\n+\t{\n+\t  /* If there's no univeral neutral value, we can use the\n+\t     initial scalar value from the original PHI.  This is used\n+\t     for MIN and MAX reduction, for example.  */\n+\t  if (!neutral_op)\n+\t    {\n+\t      tree scalar_value\n+\t\t= PHI_ARG_DEF_FROM_EDGE (orig_phis[i],\n+\t\t\t\t\t loop_preheader_edge (loop));\n+\t      vector_identity = gimple_build_vector_from_val (&seq, vectype,\n+\t\t\t\t\t\t\t      scalar_value);\n+\t    }\n+\n+\t  /* Calculate the equivalent of:\n+\n+\t     sel[j] = (index[j] == i);\n+\n+\t     which selects the elements of NEW_PHI_RESULT that should\n+\t     be included in the result.  */\n+\t  tree compare_val = build_int_cst (index_elt_type, i);\n+\t  compare_val = build_vector_from_val (index_type, compare_val);\n+\t  tree sel = gimple_build (&seq, EQ_EXPR, mask_type,\n+\t\t\t\t   index, compare_val);\n+\n+\t  /* Calculate the equivalent of:\n+\n+\t     vec = seq ? new_phi_result : vector_identity;\n+\n+\t     VEC is now suitable for a full vector reduction.  */\n+\t  tree vec = gimple_build (&seq, VEC_COND_EXPR, vectype,\n+\t\t\t\t   sel, new_phi_result, vector_identity);\n+\n+\t  /* Do the reduction and convert it to the appropriate type.  */\n+\t  gcall *call = gimple_build_call_internal (reduc_fn, 1, vec);\n+\t  tree scalar = make_ssa_name (TREE_TYPE (vectype));\n+\t  gimple_call_set_lhs (call, scalar);\n+\t  gimple_seq_add_stmt (&seq, call);\n+\t  scalar = gimple_convert (&seq, scalar_type, scalar);\n+\t  scalar_results.safe_push (scalar);\n+\t}\n+      gsi_insert_seq_before (&exit_gsi, seq, GSI_SAME_STMT);\n+    }\n   else\n     {\n       bool reduce_with_shift;\n@@ -6412,25 +6560,64 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n       return false;\n     }\n \n-  if (double_reduc && !nunits_out.is_constant ())\n+  /* For SLP reductions, see if there is a neutral value we can use.  */\n+  tree neutral_op = NULL_TREE;\n+  if (slp_node)\n+    neutral_op\n+      = neutral_op_for_slp_reduction (slp_node_instance->reduc_phis, code,\n+\t\t\t\t      GROUP_FIRST_ELEMENT (stmt_info) != NULL);\n+\n+  /* For double reductions, and for SLP reductions with a neutral value,\n+     we construct a variable-length initial vector by loading a vector\n+     full of the neutral value and then shift-and-inserting the start\n+     values into the low-numbered elements.  */\n+  if ((double_reduc || neutral_op)\n+      && !nunits_out.is_constant ()\n+      && !direct_internal_fn_supported_p (IFN_VEC_SHL_INSERT,\n+\t\t\t\t\t  vectype_out, OPTIMIZE_FOR_SPEED))\n     {\n-      /* The current double-reduction code creates the initial value\n-\t element-by-element.  */\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"double reduction not supported for variable-length\"\n-\t\t\t \" vectors.\\n\");\n+\t\t\t \"reduction on variable-length vectors requires\"\n+\t\t\t \" target support for a vector-shift-and-insert\"\n+\t\t\t \" operation.\\n\");\n       return false;\n     }\n \n-  if (slp_node && !nunits_out.is_constant ())\n-    {\n-      /* The current SLP code creates the initial value element-by-element.  */\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"SLP reduction not supported for variable-length\"\n-\t\t\t \" vectors.\\n\");\n-      return false;\n+  /* Check extra constraints for variable-length unchained SLP reductions.  */\n+  if (STMT_SLP_TYPE (stmt_info)\n+      && !GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt))\n+      && !nunits_out.is_constant ())\n+    {\n+      /* We checked above that we could build the initial vector when\n+\t there's a neutral element value.  Check here for the case in\n+\t which each SLP statement has its own initial value and in which\n+\t that value needs to be repeated for every instance of the\n+\t statement within the initial vector.  */\n+      unsigned int group_size = SLP_TREE_SCALAR_STMTS (slp_node).length ();\n+      scalar_mode elt_mode = SCALAR_TYPE_MODE (TREE_TYPE (vectype_out));\n+      if (!neutral_op\n+\t  && !can_duplicate_and_interleave_p (group_size, elt_mode))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"unsupported form of SLP reduction for\"\n+\t\t\t     \" variable-length vectors: cannot build\"\n+\t\t\t     \" initial vector.\\n\");\n+\t  return false;\n+\t}\n+      /* The epilogue code relies on the number of elements being a multiple\n+\t of the group size.  The duplicate-and-interleave approach to setting\n+\t up the the initial vector does too.  */\n+      if (!multiple_p (nunits_out, group_size))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"unsupported form of SLP reduction for\"\n+\t\t\t     \" variable-length vectors: the vector size\"\n+\t\t\t     \" is not a multiple of the number of results.\\n\");\n+\t  return false;\n+\t}\n     }\n \n   /* In case of widenning multiplication by a constant, we update the type\n@@ -6698,7 +6885,8 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   vect_create_epilog_for_reduction (vect_defs, stmt, reduc_def_stmt,\n \t\t\t\t    epilog_copies, reduc_fn, phis,\n \t\t\t\t    double_reduc, slp_node, slp_node_instance,\n-\t\t\t\t    cond_reduc_val, cond_reduc_op_code);\n+\t\t\t\t    cond_reduc_val, cond_reduc_op_code,\n+\t\t\t\t    neutral_op);\n \n   return true;\n }"}, {"sha": "7fae17b340d011827fb91b22c2a761258b595e69", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=f1739b4829105fa95d6ff6244632d5977169277f", "patch": "@@ -216,11 +216,11 @@ vect_get_place_in_interleaving_chain (gimple *stmt, gimple *first_stmt)\n    (if nonnull) and the type of each intermediate vector in *VECTOR_TYPE_OUT\n    (if nonnull).  */\n \n-static bool\n+bool\n can_duplicate_and_interleave_p (unsigned int count, machine_mode elt_mode,\n-\t\t\t\tunsigned int *nvectors_out = NULL,\n-\t\t\t\ttree *vector_type_out = NULL,\n-\t\t\t\ttree *permutes = NULL)\n+\t\t\t\tunsigned int *nvectors_out,\n+\t\t\t\ttree *vector_type_out,\n+\t\t\t\ttree *permutes)\n {\n   poly_int64 elt_bytes = count * GET_MODE_SIZE (elt_mode);\n   poly_int64 nelts;\n@@ -3309,7 +3309,7 @@ vect_mask_constant_operand_p (gimple *stmt, int opnum)\n    We try to find the largest IM for which this sequence works, in order\n    to cut down on the number of interleaves.  */\n \n-static void\n+void\n duplicate_and_interleave (gimple_seq *seq, tree vector_type, vec<tree> elts,\n \t\t\t  unsigned int nresults, vec<tree> &results)\n {"}, {"sha": "1effcadda229431f5a4ddc2aa0c436d3df806c1d", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1739b4829105fa95d6ff6244632d5977169277f/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=f1739b4829105fa95d6ff6244632d5977169277f", "patch": "@@ -1352,6 +1352,11 @@ extern void vect_get_slp_defs (vec<tree> , slp_tree, vec<vec<tree> > *);\n extern bool vect_slp_bb (basic_block);\n extern gimple *vect_find_last_scalar_stmt_in_slp (slp_tree);\n extern bool is_simple_and_all_uses_invariant (gimple *, loop_vec_info);\n+extern bool can_duplicate_and_interleave_p (unsigned int, machine_mode,\n+\t\t\t\t\t    unsigned int * = NULL,\n+\t\t\t\t\t    tree * = NULL, tree * = NULL);\n+extern void duplicate_and_interleave (gimple_seq *, tree, vec<tree>,\n+\t\t\t\t      unsigned int, vec<tree> &);\n \n /* In tree-vect-patterns.c.  */\n /* Pattern recognition functions."}]}