{"sha": "162712de00d6e234083e63c00b7a0570aa13a5e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTYyNzEyZGUwMGQ2ZTIzNDA4M2U2M2MwMGI3YTA1NzBhYTEzYTVlMw==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2013-03-25T16:42:41Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2013-03-25T16:42:41Z"}, "message": "ipa-cp.c (ipa_get_indirect_edge_target): Renamed to ipa_get_indirect_edge_target_1...\n\n2013-03-25  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-cp.c (ipa_get_indirect_edge_target): Renamed to\n\tipa_get_indirect_edge_target_1, added parameter agg_reps and ability to\n\tprocess it.\n\t(ipa_get_indirect_edge_target): New function.\n\t(devirtualization_time_bonus): New parameter known_aggs, pass it to\n\tipa_get_indirect_edge_target.  Update all callers.\n\t(ipcp_discover_new_direct_edges): New parameter aggvals.  Pass it to\n\tipa_get_indirect_edge_target_1 instead of calling\n\tipa_get_indirect_edge_target.\n\t(create_specialized_node): Pass aggvlas to\n\tipcp_discover_new_direct_edges.\n\ntestsuite/\n\t* gcc.dg/ipa/ipcp-agg-9.c: New test.\n\nFrom-SVN: r197054", "tree": {"sha": "45836f6d246d4f771b90aac808750e183ca4063b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45836f6d246d4f771b90aac808750e183ca4063b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/162712de00d6e234083e63c00b7a0570aa13a5e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/162712de00d6e234083e63c00b7a0570aa13a5e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/162712de00d6e234083e63c00b7a0570aa13a5e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/162712de00d6e234083e63c00b7a0570aa13a5e3/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cadddfdda2c4a16e7fdd5f0d8d02b465caad2ad5"}], "stats": {"total": 133, "additions": 116, "deletions": 17}, "files": [{"sha": "6a9293cbb5766272f7e5efad95a75505c3e06018", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/162712de00d6e234083e63c00b7a0570aa13a5e3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/162712de00d6e234083e63c00b7a0570aa13a5e3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=162712de00d6e234083e63c00b7a0570aa13a5e3", "patch": "@@ -1,3 +1,17 @@\n+2013-03-25  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-cp.c (ipa_get_indirect_edge_target): Renamed to\n+\tipa_get_indirect_edge_target_1, added parameter agg_reps and ability to\n+\tprocess it.\n+\t(ipa_get_indirect_edge_target): New function.\n+\t(devirtualization_time_bonus): New parameter known_aggs, pass it to\n+\tipa_get_indirect_edge_target.  Update all callers.\n+\t(ipcp_discover_new_direct_edges): New parameter aggvals.  Pass it to\n+\tipa_get_indirect_edge_target_1 instead of calling\n+\tipa_get_indirect_edge_target.\n+\t(create_specialized_node): Pass aggvlas to\n+\tipcp_discover_new_direct_edges.\n+\n 2013-03-25  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/arm/arm.md (f_sels, f_seld): New types."}, {"sha": "3545ed1b53a077da714ec27b0223040c0e470b92", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 53, "deletions": 17, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/162712de00d6e234083e63c00b7a0570aa13a5e3/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/162712de00d6e234083e63c00b7a0570aa13a5e3/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=162712de00d6e234083e63c00b7a0570aa13a5e3", "patch": "@@ -1493,14 +1493,16 @@ propagate_constants_accross_call (struct cgraph_edge *cs)\n }\n \n /* If an indirect edge IE can be turned into a direct one based on KNOWN_VALS\n-   (which can contain both constants and binfos) or KNOWN_BINFOS (which can be\n-   NULL) return the destination.  */\n+   (which can contain both constants and binfos), KNOWN_BINFOS, KNOWN_AGGS or\n+   AGG_REPS return the destination.  The latter three can be NULL.  If AGG_REPS\n+   is not NULL, KNOWN_AGGS is ignored.  */\n \n-tree\n-ipa_get_indirect_edge_target (struct cgraph_edge *ie,\n-\t\t\t      vec<tree> known_vals,\n-\t\t\t      vec<tree> known_binfos,\n-\t\t\t      vec<ipa_agg_jump_function_p> known_aggs)\n+static tree\n+ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n+\t\t\t\tvec<tree> known_vals,\n+\t\t\t\tvec<tree> known_binfos,\n+\t\t\t\tvec<ipa_agg_jump_function_p> known_aggs,\n+\t\t\t\tstruct ipa_agg_replacement_value *agg_reps)\n {\n   int param_index = ie->indirect_info->param_index;\n   HOST_WIDE_INT token, anc_offset;\n@@ -1516,8 +1518,21 @@ ipa_get_indirect_edge_target (struct cgraph_edge *ie,\n \n       if (ie->indirect_info->agg_contents)\n \t{\n-\t  if (known_aggs.length ()\n-\t      > (unsigned int) param_index)\n+\t  if (agg_reps)\n+\t    {\n+\t      t = NULL;\n+\t      while (agg_reps)\n+\t\t{\n+\t\t  if (agg_reps->index == param_index\n+\t\t      && agg_reps->offset == ie->indirect_info->offset)\n+\t\t    {\n+\t\t      t = agg_reps->value;\n+\t\t      break;\n+\t\t    }\n+\t\t  agg_reps = agg_reps->next;\n+\t\t}\n+\t    }\n+\t  else if (known_aggs.length () > (unsigned int) param_index)\n \t    {\n \t      struct ipa_agg_jump_function *agg;\n \t      agg = known_aggs[param_index];\n@@ -1572,13 +1587,29 @@ ipa_get_indirect_edge_target (struct cgraph_edge *ie,\n     }\n }\n \n+\n+/* If an indirect edge IE can be turned into a direct one based on KNOWN_VALS\n+   (which can contain both constants and binfos), KNOWN_BINFOS (which can be\n+   NULL) or KNOWN_AGGS (which also can be NULL) return the destination.  */\n+\n+tree\n+ipa_get_indirect_edge_target (struct cgraph_edge *ie,\n+\t\t\t      vec<tree> known_vals,\n+\t\t\t      vec<tree> known_binfos,\n+\t\t\t      vec<ipa_agg_jump_function_p> known_aggs)\n+{\n+  return ipa_get_indirect_edge_target_1 (ie, known_vals, known_binfos,\n+\t\t\t\t\t known_aggs, NULL);\n+}\n+\n /* Calculate devirtualization time bonus for NODE, assuming we know KNOWN_CSTS\n    and KNOWN_BINFOS.  */\n \n static int\n devirtualization_time_bonus (struct cgraph_node *node,\n \t\t\t     vec<tree> known_csts,\n-\t\t\t     vec<tree> known_binfos)\n+\t\t\t     vec<tree> known_binfos,\n+\t\t\t     vec<ipa_agg_jump_function_p> known_aggs)\n {\n   struct cgraph_edge *ie;\n   int res = 0;\n@@ -1590,7 +1621,7 @@ devirtualization_time_bonus (struct cgraph_node *node,\n       tree target;\n \n       target = ipa_get_indirect_edge_target (ie, known_csts, known_binfos,\n-\t\t\t\t\tvNULL);\n+\t\t\t\t\t     known_aggs);\n       if (!target)\n \tcontinue;\n \n@@ -1834,7 +1865,8 @@ estimate_local_effects (struct cgraph_node *node)\n       cgraph_for_node_and_aliases (node, gather_caller_stats, &stats, false);\n       estimate_ipcp_clone_size_and_time (node, known_csts, known_binfos,\n \t\t\t\t\t known_aggs_ptrs, &size, &time, &hints);\n-      time -= devirtualization_time_bonus (node, known_csts, known_binfos);\n+      time -= devirtualization_time_bonus (node, known_csts, known_binfos,\n+\t\t\t\t\t   known_aggs_ptrs);\n       time -= hint_time_bonus (hints);\n       time -= removable_params_cost;\n       size -= stats.n_calls * removable_params_cost;\n@@ -1911,7 +1943,8 @@ estimate_local_effects (struct cgraph_node *node)\n \t\t\t\t\t     known_aggs_ptrs, &size, &time,\n \t\t\t\t\t     &hints);\n \t  time_benefit = base_time - time\n-\t    + devirtualization_time_bonus (node, known_csts, known_binfos)\n+\t    + devirtualization_time_bonus (node, known_csts, known_binfos,\n+\t\t\t\t\t   known_aggs_ptrs)\n \t    + hint_time_bonus (hints)\n \t    + removable_params_cost + emc;\n \n@@ -1973,7 +2006,8 @@ estimate_local_effects (struct cgraph_node *node)\n \t\t\t\t\t\t known_aggs_ptrs, &size, &time,\n \t\t\t\t\t\t &hints);\n \t      time_benefit = base_time - time\n-\t\t+ devirtualization_time_bonus (node, known_csts, known_binfos)\n+\t\t+ devirtualization_time_bonus (node, known_csts, known_binfos,\n+\t\t\t\t\t       known_aggs_ptrs)\n \t\t+ hint_time_bonus (hints);\n \t      gcc_checking_assert (size >=0);\n \t      if (size == 0)\n@@ -2256,7 +2290,8 @@ ipcp_propagate_stage (struct topo_info *topo)\n \n static void\n ipcp_discover_new_direct_edges (struct cgraph_node *node,\n-\t\t\t\tvec<tree> known_vals)\n+\t\t\t\tvec<tree> known_vals,\n+\t\t\t\tstruct ipa_agg_replacement_value *aggvals)\n {\n   struct cgraph_edge *ie, *next_ie;\n   bool found = false;\n@@ -2266,7 +2301,8 @@ ipcp_discover_new_direct_edges (struct cgraph_node *node,\n       tree target;\n \n       next_ie = ie->next_callee;\n-      target = ipa_get_indirect_edge_target (ie, known_vals, vNULL, vNULL);\n+      target = ipa_get_indirect_edge_target_1 (ie, known_vals, vNULL, vNULL,\n+\t\t\t\t\t       aggvals);\n       if (target)\n \t{\n \t  ipa_make_edge_direct_to_target (ie, target);\n@@ -2676,7 +2712,7 @@ create_specialized_node (struct cgraph_node *node,\n   new_info->ipcp_orig_node = node;\n   new_info->known_vals = known_vals;\n \n-  ipcp_discover_new_direct_edges (new_node, known_vals);\n+  ipcp_discover_new_direct_edges (new_node, known_vals, aggvals);\n \n   callers.release ();\n   return new_node;"}, {"sha": "36552cc29c261eb1b20471f3392229ae95591855", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/162712de00d6e234083e63c00b7a0570aa13a5e3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/162712de00d6e234083e63c00b7a0570aa13a5e3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=162712de00d6e234083e63c00b7a0570aa13a5e3", "patch": "@@ -1,3 +1,7 @@\n+2013-03-25  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* gcc.dg/ipa/ipcp-agg-9.c: New test.\n+\n 2013-03-25  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/38536"}, {"sha": "e6b4b965faa719e7a060a56ef326fcef81fc8be4", "filename": "gcc/testsuite/gcc.dg/ipa/ipcp-agg-9.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/162712de00d6e234083e63c00b7a0570aa13a5e3/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/162712de00d6e234083e63c00b7a0570aa13a5e3/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-agg-9.c?ref=162712de00d6e234083e63c00b7a0570aa13a5e3", "patch": "@@ -0,0 +1,45 @@\n+/* Verify that IPA-CP can make edges direct based on aggregate contents.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fno-early-inlining -fdump-ipa-cp -fdump-ipa-inline\"  } */\n+\n+struct S\n+{\n+  int i;\n+  void (*f)(struct S *);\n+  unsigned u;\n+};\n+\n+struct U\n+{\n+  struct U *next;\n+  struct S s;\n+  short a[8];\n+};\n+\n+extern void non_existent(struct S *p, int);\n+\n+static void hooray1 (struct S *p)\n+{\n+  non_existent (p, 1);\n+}\n+\n+static __attribute__ ((noinline))\n+void hiphip1 (struct S *p)\n+{\n+  p->f (p);\n+}\n+\n+int test1 (void)\n+{\n+  struct S s;\n+  s.i = 1234;\n+  s.f = hooray1;\n+  s.u = 1001;\n+  hiphip1 (&s);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump \"ipa-prop: Discovered an indirect call to a known target\"  \"cp\"  } } */\n+/* { dg-final { scan-ipa-dump \"hooray1\\[^\\\\n\\]*inline copy in hiphip1\"  \"inline\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"cp\" } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */"}]}