{"sha": "281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjgxZTZjMWQ4ZjFiNGNhNTUyZDhjZTIyNzZkZGVjZmNkNmZmYjE1ZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2017-09-28T19:39:45Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2017-09-28T19:39:45Z"}, "message": "PR c++/56973, DR 696 - capture constant variables only as needed.\n\n\t* expr.c (mark_use): Split out from mark_rvalue_use and\n\tmark_lvalue_use.  Handle lambda capture of constant variables.\n\t(mark_lvalue_use_nonread): New.\n\t* semantics.c (process_outer_var_ref): Don't capture a constant\n\tvariable until forced.\n\t* pt.c (processing_nonlambda_template): New.\n\t* call.c (build_this): Check it.\n\t* decl2.c (grok_array_decl): Call mark_rvalue_use and\n\tmark_lvalue_use_nonread.\n\t* init.c (constant_value_1): Don't call mark_rvalue_use.\n\t* typeck.c (build_static_cast): Handle lambda capture.\n\nFrom-SVN: r253266", "tree": {"sha": "4ec4cc5dfce6282bcbc8d1adfbbb092073395b53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ec4cc5dfce6282bcbc8d1adfbbb092073395b53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5c263e84ab7e5df28a9055ae533c2d305f4b7b3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c263e84ab7e5df28a9055ae533c2d305f4b7b3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c263e84ab7e5df28a9055ae533c2d305f4b7b3d"}], "stats": {"total": 227, "additions": 196, "deletions": 31}, "files": [{"sha": "6e2e3a8539efc59aee095051ef7321b2b0fee726", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e", "patch": "@@ -1,5 +1,18 @@\n 2017-09-28  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/56973, DR 696 - capture constant variables only as needed.\n+\t* expr.c (mark_use): Split out from mark_rvalue_use and\n+\tmark_lvalue_use.  Handle lambda capture of constant variables.\n+\t(mark_lvalue_use_nonread): New.\n+\t* semantics.c (process_outer_var_ref): Don't capture a constant\n+\tvariable until forced.\n+\t* pt.c (processing_nonlambda_template): New.\n+\t* call.c (build_this): Check it.\n+\t* decl2.c (grok_array_decl): Call mark_rvalue_use and\n+\tmark_lvalue_use_nonread.\n+\t* init.c (constant_value_1): Don't call mark_rvalue_use.\n+\t* typeck.c (build_static_cast): Handle lambda capture.\n+\n \tUse local_specializations to find capture proxies.\n \t* cp-tree.h (DECL_CAPTURED_VARIABLE): New.\n \t* lambda.c (build_capture_proxy): Set it."}, {"sha": "05dc8bbdab7d42760290892d9cc57c224109632d", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e", "patch": "@@ -3362,7 +3362,7 @@ build_this (tree obj)\n {\n   /* In a template, we are only concerned about the type of the\n      expression, so we can take a shortcut.  */\n-  if (processing_template_decl)\n+  if (processing_nonlambda_template ())\n     return build_address (obj);\n \n   return cp_build_addr_expr (obj, tf_warning_or_error);"}, {"sha": "f56c9517967cfd31390e2ee75dc916ce92264a57", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e", "patch": "@@ -6249,6 +6249,7 @@ extern tree mark_rvalue_use\t\t\t(tree,\n                                                  location_t = UNKNOWN_LOCATION,\n                                                  bool = true);\n extern tree mark_lvalue_use\t\t\t(tree);\n+extern tree mark_lvalue_use_nonread\t\t(tree);\n extern tree mark_type_use\t\t\t(tree);\n extern void mark_exp_read\t\t\t(tree);\n \n@@ -6412,6 +6413,7 @@ extern tree lookup_template_variable\t\t(tree, tree);\n extern int uses_template_parms\t\t\t(tree);\n extern bool uses_template_parms_level\t\t(tree, int);\n extern bool in_template_function\t\t(void);\n+extern bool processing_nonlambda_template\t(void);\n extern tree instantiate_class_template\t\t(tree);\n extern tree instantiate_template\t\t(tree, tree, tsubst_flags_t);\n extern tree fn_type_unification\t\t\t(tree, tree, tree,\n@@ -6720,7 +6722,7 @@ extern tree finish_template_type\t\t(tree, tree, int);\n extern tree finish_base_specifier\t\t(tree, tree, bool);\n extern void finish_member_declaration\t\t(tree);\n extern bool outer_automatic_var_p\t\t(tree);\n-extern tree process_outer_var_ref\t\t(tree, tsubst_flags_t);\n+extern tree process_outer_var_ref\t\t(tree, tsubst_flags_t, bool force_use = false);\n extern cp_expr finish_id_expression\t\t(tree, tree, tree,\n \t\t\t\t\t\t cp_id_kind *,\n \t\t\t\t\t\t bool, bool, bool *,"}, {"sha": "29d6c59f549a0292ffa94f04308f065b462d132d", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e", "patch": "@@ -427,6 +427,11 @@ grok_array_decl (location_t loc, tree array_expr, tree index_exp,\n       if (array_expr == error_mark_node || index_exp == error_mark_node)\n \terror (\"ambiguous conversion for array subscript\");\n \n+      if (TREE_CODE (TREE_TYPE (array_expr)) == POINTER_TYPE)\n+\tarray_expr = mark_rvalue_use (array_expr);\n+      else\n+\tarray_expr = mark_lvalue_use_nonread (array_expr);\n+      index_exp = mark_rvalue_use (index_exp);\n       expr = build_array_ref (input_location, array_expr, index_exp);\n     }\n   if (processing_template_decl && expr != error_mark_node)"}, {"sha": "f5c8e80191887fcc8c13370de53c30721c8ca9f8", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 99, "deletions": 8, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e", "patch": "@@ -86,30 +86,121 @@ cplus_expand_constant (tree cst)\n   return cst;\n }\n \n+/* We've seen an actual use of EXPR.  Possibly replace an outer variable\n+   reference inside with its constant value or a lambda capture.  */\n+\n+static tree\n+mark_use (tree expr, bool rvalue_p, bool read_p,\n+\t  location_t loc /* = UNKNOWN_LOCATION */,\n+\t  bool reject_builtin /* = true */)\n+{\n+#define RECUR(t) mark_use ((t), rvalue_p, read_p, loc, reject_builtin)\n+\n+  if (reject_builtin && reject_gcc_builtin (expr, loc))\n+    return error_mark_node;\n+\n+  if (read_p)\n+    mark_exp_read (expr);\n+\n+  bool recurse_op[3] = { false, false, false };\n+  switch (TREE_CODE (expr))\n+    {\n+    case VAR_DECL:\n+      if (outer_automatic_var_p (expr)\n+\t  && decl_constant_var_p (expr))\n+\t{\n+\t  if (rvalue_p)\n+\t    {\n+\t      tree t = maybe_constant_value (expr);\n+\t      if (TREE_CONSTANT (t))\n+\t\t{\n+\t\t  expr = t;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  expr = process_outer_var_ref (expr, tf_warning_or_error, true);\n+\t  expr = convert_from_reference (expr);\n+\t}\n+      break;\n+    case COMPONENT_REF:\n+      recurse_op[0] = true;\n+      break;\n+    case COMPOUND_EXPR:\n+      recurse_op[1] = true;\n+      break;\n+    case COND_EXPR:\n+      recurse_op[2] = true;\n+      if (TREE_OPERAND (expr, 1))\n+\trecurse_op[1] = true;\n+      break;\n+    case INDIRECT_REF:\n+      if (REFERENCE_REF_P (expr))\n+\t{\n+\t  /* Try to look through the reference.  */\n+\t  tree ref = TREE_OPERAND (expr, 0);\n+\t  tree r = mark_rvalue_use (ref, loc, reject_builtin);\n+\t  if (r != ref)\n+\t    {\n+\t      expr = copy_node (expr);\n+\t      TREE_OPERAND (expr, 0) = r;\n+\t    }\n+\t}\n+      break;\n+    default:\n+      break;\n+    }\n+\n+  bool changed = false;\n+  tree ops[3];\n+  for (int i = 0; i < 3; ++i)\n+    if (recurse_op[i])\n+      {\n+\ttree op = TREE_OPERAND (expr, i);\n+\tops[i] = RECUR (op);\n+\tif (ops[i] != op)\n+\t  changed = true;\n+      }\n+\n+  if (changed)\n+    {\n+      expr = copy_node (expr);\n+      for (int i = 0; i < 3; ++i)\n+\tif (recurse_op[i])\n+\t  TREE_OPERAND (expr, i) = ops[i];\n+    }\n+\n+  return expr;\n+#undef RECUR\n+}\n+\n /* Called whenever the expression EXPR is used in an rvalue context.\n    When REJECT_BUILTIN is true the expression is checked to make sure\n    it doesn't make it possible to obtain the address of a GCC built-in\n    function with no library fallback (or any of its bits, such as in\n    a conversion to bool).  */\n+\n tree\n-mark_rvalue_use (tree expr,\n+mark_rvalue_use (tree e,\n \t\t location_t loc /* = UNKNOWN_LOCATION */,\n \t\t bool reject_builtin /* = true */)\n {\n-  if (reject_builtin && reject_gcc_builtin (expr, loc))\n-    return error_mark_node;\n-\n-  mark_exp_read (expr);\n-  return expr;\n+  return mark_use (e, true, true, loc, reject_builtin);\n }\n \n /* Called whenever an expression is used in an lvalue context.  */\n \n tree\n mark_lvalue_use (tree expr)\n {\n-  mark_exp_read (expr);\n-  return expr;\n+  return mark_use (expr, false, true, input_location, false);\n+}\n+\n+/* As above, but don't consider this use a read.  */\n+\n+tree\n+mark_lvalue_use_nonread (tree expr)\n+{\n+  return mark_use (expr, false, false, input_location, false);\n }\n \n /* Called whenever an expression is used in a type use context.  */"}, {"sha": "4bc0755cdcbd693da2e1dff6088c7fe550786dd1", "filename": "gcc/cp/init.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e", "patch": "@@ -2213,7 +2213,6 @@ constant_value_1 (tree decl, bool strict_p, bool return_aggregate_cst_ok_p)\n \t initializer for the static data member is not processed\n \t until needed; we need it now.  */\n       mark_used (decl, tf_none);\n-      mark_rvalue_use (decl);\n       init = DECL_INITIAL (decl);\n       if (init == error_mark_node)\n \t{"}, {"sha": "0dae10e032b9f871b653cfb2984b483253bae069", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e", "patch": "@@ -9494,6 +9494,32 @@ in_template_function (void)\n   return ret;\n }\n \n+/* Returns true iff we are currently within a template other than a generic\n+   lambda.  We test this by finding the outermost closure type and checking\n+   whether it is dependent.  */\n+\n+bool\n+processing_nonlambda_template (void)\n+{\n+  if (!processing_template_decl)\n+    return false;\n+\n+  tree outer_closure = NULL_TREE;\n+  for (tree t = current_class_type; t;\n+       t = decl_type_context (TYPE_MAIN_DECL (t)))\n+    {\n+      if (LAMBDA_TYPE_P (t))\n+\touter_closure = t;\n+      else\n+\tbreak;\n+    }\n+\n+  if (outer_closure)\n+    return dependent_type_p (outer_closure);\n+  else\n+    return true;\n+}\n+\n /* Returns true if T depends on any template parameter with level LEVEL.  */\n \n bool"}, {"sha": "d96423f23487aa533baffd2d441a058fb26a51fd", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e", "patch": "@@ -3282,7 +3282,7 @@ outer_automatic_var_p (tree decl)\n    rewrite it for lambda capture.  */\n \n tree\n-process_outer_var_ref (tree decl, tsubst_flags_t complain)\n+process_outer_var_ref (tree decl, tsubst_flags_t complain, bool force_use)\n {\n   if (cp_unevaluated_operand)\n     /* It's not a use (3.2) if we're in an unevaluated context.  */\n@@ -3303,6 +3303,12 @@ process_outer_var_ref (tree decl, tsubst_flags_t complain)\n   if (parsing_nsdmi ())\n     containing_function = NULL_TREE;\n \n+  /* Core issue 696: Only an odr-use of an outer automatic variable causes a\n+     capture (or error), and a constant variable can decay to a prvalue\n+     constant without odr-use.  So don't capture yet.  */\n+  if (decl_constant_var_p (decl) && !force_use)\n+    return decl;\n+\n   if (containing_function && LAMBDA_FUNCTION_P (containing_function))\n     {\n       /* Check whether we've already built a proxy.  */\n@@ -3314,7 +3320,7 @@ process_outer_var_ref (tree decl, tsubst_flags_t complain)\n \t    return d;\n \t  else\n \t    /* We need to capture an outer proxy.  */\n-\t    return process_outer_var_ref (d, complain);\n+\t    return process_outer_var_ref (d, complain, force_use);\n \t}\n     }\n \n@@ -3353,20 +3359,6 @@ process_outer_var_ref (tree decl, tsubst_flags_t complain)\n       && uses_template_parms (DECL_TI_ARGS (containing_function)))\n     return decl;\n \n-  /* Core issue 696: \"[At the July 2009 meeting] the CWG expressed\n-     support for an approach in which a reference to a local\n-     [constant] automatic variable in a nested class or lambda body\n-     would enter the expression as an rvalue, which would reduce\n-     the complexity of the problem\"\n-\n-     FIXME update for final resolution of core issue 696.  */\n-  if (decl_constant_var_p (decl))\n-    {\n-      tree t = maybe_constant_value (convert_from_reference (decl));\n-      if (TREE_CONSTANT (t))\n-\treturn t;\n-    }\n-\n   if (lambda_expr && VAR_P (decl)\n       && DECL_ANON_UNION_VAR_P (decl))\n     {"}, {"sha": "326721eb5e0690e781a2995ae74d2fa7189300c9", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e", "patch": "@@ -7044,16 +7044,24 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n /* Return an expression representing static_cast<TYPE>(EXPR).  */\n \n tree\n-build_static_cast (tree type, tree expr, tsubst_flags_t complain)\n+build_static_cast (tree type, tree oexpr, tsubst_flags_t complain)\n {\n+  tree expr = oexpr;\n   tree result;\n   bool valid_p;\n \n   if (type == error_mark_node || expr == error_mark_node)\n     return error_mark_node;\n \n-  if (processing_template_decl)\n+  bool dependent = (dependent_type_p (type)\n+\t\t    || type_dependent_expression_p (expr));\n+  if (dependent)\n     {\n+    tmpl:\n+      expr = oexpr;\n+      if (dependent)\n+\t/* Handle generic lambda capture.  */\n+\texpr = mark_lvalue_use (expr);\n       expr = build_min (STATIC_CAST_EXPR, type, expr);\n       /* We don't know if it will or will not have side effects.  */\n       TREE_SIDE_EFFECTS (expr) = 1;\n@@ -7076,6 +7084,8 @@ build_static_cast (tree type, tree expr, tsubst_flags_t complain)\n \t  maybe_warn_about_useless_cast (type, expr, complain);\n \t  maybe_warn_about_cast_ignoring_quals (type, complain);\n \t}\n+      if (processing_template_decl)\n+\tgoto tmpl;\n       return result;\n     }\n "}, {"sha": "8200f871057c978e48e90df4ab584e14100d484c", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-64462.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-64462.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-64462.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-64462.C?ref=281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e", "patch": "@@ -6,5 +6,5 @@ int z;\n \n int main() {\n   constexpr int& y = x;\n-  [=] { z = y; }();\n+  [] { z = y; }();\n }"}, {"sha": "4edfb70038fdd8309476876fff78dddbedb5afb2", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-const6.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-const6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-const6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-const6.C?ref=281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e", "patch": "@@ -0,0 +1,15 @@\n+// PR c++/56973\n+// { dg-do compile { target c++11 } }\n+\n+int f()\n+{\n+  const int i = 42;\n+  auto j = *[=]{ return &i; }();\n+  auto k = []{ return i; }();\n+  return j+k;\n+}\n+\n+int main()\n+{\n+  return f() != 84;\n+}"}, {"sha": "64a37b80a9ba225c55a3db8b2d3d3386c7812446", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-const7.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-const7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-const7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-const7.C?ref=281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e", "patch": "@@ -0,0 +1,12 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-options -w }\n+\n+int main()\n+{\n+  const int i = 4;\n+  [] { constexpr int x = i; };\n+  [=] { &i; constexpr int x = i; };\n+  [&] { &i; constexpr int x = i; };\n+  [i] { &i; constexpr int x = i; };\n+  [&i] { &i; constexpr int x = i; };\n+}"}, {"sha": "d56f379c680b39b78c14eaba41f7f2b2ef623d4d", "filename": "gcc/testsuite/g++.dg/cpp1y/lambda-generic-const4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-const4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-const4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-const4.C?ref=281e6c1d8f1b4ca552d8ce2276ddecfcd6ffb15e", "patch": "@@ -13,7 +13,7 @@ template <typename T>\n void bar (T) {\n   constexpr auto N = a<1>;\n   auto f = [&] (auto i) {\n-    static_assert (static_cast<int>(N) == 1, \"\");\n+    return static_cast<int>(N) == 1;\n   };\n   foo (f);\n }"}]}