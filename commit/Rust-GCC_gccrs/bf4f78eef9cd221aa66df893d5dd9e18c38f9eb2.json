{"sha": "bf4f78eef9cd221aa66df893d5dd9e18c38f9eb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY0Zjc4ZWVmOWNkMjIxYWE2NmRmODkzZDVkZDllMThjMzhmOWViMg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@cygnus.com", "date": "1999-06-14T15:47:30Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1999-06-14T15:47:30Z"}, "message": "Fix switch table and reload problems for mips16.\n\n\t* config/mips/mips.c (mips_secondary_reload_class): Check for\n\t(PLUS (SP) (REG)) and return appropriate register class.\n\t* config/mips/mips.md (reload_insi): Delete predicate for operand 1.\n\tHandle (PLUS (SP) (REG)).\n\t(tablejump): In mips16 code, use emit_insn instead of emit_jump_insn.\n\t(tablejump_mips161, tablejump_mips162): Use emit_jump_insn instead\n\tof emit_insn for tablejump.\n\nFrom-SVN: r27519", "tree": {"sha": "02f5745171c05ed941f21d790eb0db54e6897a58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02f5745171c05ed941f21d790eb0db54e6897a58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf4f78eef9cd221aa66df893d5dd9e18c38f9eb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf4f78eef9cd221aa66df893d5dd9e18c38f9eb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf4f78eef9cd221aa66df893d5dd9e18c38f9eb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf4f78eef9cd221aa66df893d5dd9e18c38f9eb2/comments", "author": null, "committer": null, "parents": [{"sha": "13f1623bc0c68fdd26c7ba17bd96c3de1d44bf9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13f1623bc0c68fdd26c7ba17bd96c3de1d44bf9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13f1623bc0c68fdd26c7ba17bd96c3de1d44bf9e"}], "stats": {"total": 86, "additions": 81, "deletions": 5}, "files": [{"sha": "4e9ddd531a6f83d5a1d67af8020a02af6f2aeea0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf4f78eef9cd221aa66df893d5dd9e18c38f9eb2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf4f78eef9cd221aa66df893d5dd9e18c38f9eb2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf4f78eef9cd221aa66df893d5dd9e18c38f9eb2", "patch": "@@ -1,3 +1,13 @@\n+Mon Jun 14 15:38:43 1999  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* config/mips/mips.c (mips_secondary_reload_class): Check for\n+\t(PLUS (SP) (REG)) and return appropriate register class.\n+\t* config/mips/mips.md (reload_insi): Delete predicate for operand 1.\n+\tHandle (PLUS (SP) (REG)).\n+\t(tablejump): In mips16 code, use emit_insn instead of emit_jump_insn.\n+\t(tablejump_mips161, tablejump_mips162): Use emit_jump_insn instead\n+\tof emit_insn for tablejump.\n+\t\n Mon Jun 14 17:26:40 1999  David Edelsohn  <edelsohn@gnu.org>\n \n \t* rs6000.c (output_prolog): RS6000_CALL_GLUE must be"}, {"sha": "5c54dba4157a3c2df853ef7dde4ef24e516e12c7", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf4f78eef9cd221aa66df893d5dd9e18c38f9eb2/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf4f78eef9cd221aa66df893d5dd9e18c38f9eb2/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=bf4f78eef9cd221aa66df893d5dd9e18c38f9eb2", "patch": "@@ -7234,6 +7234,19 @@ mips_secondary_reload_class (class, mode, x, in_p)\n \t}\n       if (! gp_reg_p)\n \t{\n+\t  /* The stack pointer isn't a valid operand to an add instruction,\n+\t     so we need to load it into M16_REGS first.  This can happen as\n+\t     a result of register elimination and form_sum converting\n+\t     (plus reg (plus SP CONST)) to (plus (plus reg SP) CONST).  We\n+\t     need an extra register if the dest is the same as the other\n+\t     register.  In that case, we can't fix the problem by loading SP\n+\t     into the dest first.  */\n+\t  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 0)) == REG\n+\t      && GET_CODE (XEXP (x, 1)) == REG\n+\t      && (XEXP (x, 0) == stack_pointer_rtx\n+\t\t  || XEXP (x, 1) == stack_pointer_rtx))\n+\t    return (class == M16_REGS ? M16_NA_REGS : M16_REGS);\n+\n \t  if (class == M16_REGS || class == M16_NA_REGS)\n \t    return NO_REGS;\n \t  return M16_REGS;"}, {"sha": "fb739b8566974244a3030c2009780b3524443d0d", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 58, "deletions": 5, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf4f78eef9cd221aa66df893d5dd9e18c38f9eb2/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf4f78eef9cd221aa66df893d5dd9e18c38f9eb2/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=bf4f78eef9cd221aa66df893d5dd9e18c38f9eb2", "patch": "@@ -5473,9 +5473,12 @@ move\\\\t%0,%z4\\\\n\\\\\n ;; so we use a mult.  ??? This is hideous, and we ought to figure out\n ;; something better.\n \n+;; We use no predicate for operand1, because it may be a PLUS, and there\n+;; is no convenient predicate for that.\n+\n (define_expand \"reload_insi\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=b\")\n-\t(match_operand:SI 1 \"register_operand\" \"b\"))\n+\t(match_operand:SI 1 \"\" \"b\"))\n    (clobber (match_operand:SI 2 \"register_operand\" \"=&d\"))]\n   \"TARGET_MIPS16\"\n   \"\n@@ -5499,6 +5502,56 @@ move\\\\t%0,%z4\\\\n\\\\\n \t\t\t\t\t      gen_rtx (REG, SImode, 66)))));\n       DONE;\n     }\n+\n+  /* If this is a plus, then this must be an add of the stack pointer against\n+     either a hard register or a pseudo.  */\n+  if (TARGET_MIPS16 && GET_CODE (operands[1]) == PLUS)\n+    {\n+      rtx plus_op;\n+\n+      if (XEXP (operands[1], 0) == stack_pointer_rtx)\n+\tplus_op = XEXP (operands[1], 1);\n+      else if (XEXP (operands[1], 1) == stack_pointer_rtx)\n+\tplus_op = XEXP (operands[1], 0);\n+      else\n+\tabort ();\n+\n+      /* We should have a register now.  */\n+      if (GET_CODE (plus_op) != REG)\n+\tabort ();\n+\n+      if (REGNO (plus_op) < FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  /* We have to have at least one temporary register which is not\n+\t     overlapping plus_op.  */\n+\t  if (! rtx_equal_p (plus_op, operands[0]))\n+\t    {\n+\t      emit_move_insn (operands[0], stack_pointer_rtx);\n+\t      emit_insn (gen_addsi3 (operands[0], operands[0], plus_op));\n+\t    }\n+\t  else if (! rtx_equal_p (plus_op, operands[2]))\n+\t    {\n+\t      emit_move_insn (operands[2], stack_pointer_rtx);\n+\t      emit_insn (gen_addsi3 (operands[0], plus_op, operands[2]));\n+\t    }\n+\t  else\n+\t    abort ();\n+\t}\n+      else\n+\t{\n+\t  /* We need two registers in this case.  */\n+\t  if (! rtx_equal_p (operands[0], operands[2]))\n+\t    {\n+\t      emit_move_insn (operands[0], stack_pointer_rtx);\n+\t      emit_move_insn (operands[2], plus_op);\n+\t      emit_insn (gen_addsi3 (operands[0], operands[0], operands[2]));\n+\t    }\n+\t  else\n+\t    abort ();\n+\t}\n+      DONE;\n+    }\n+\n   /* FIXME: I don't know how to get a value into the HI register.  */\n   emit_move_insn (operands[0], operands[1]);\n   DONE;\n@@ -9039,9 +9092,9 @@ move\\\\t%0,%z4\\\\n\\\\\n \t  if (GET_MODE (operands[0]) != HImode)\n \t    abort ();\n \t  if (!(Pmode == DImode))\n-\t    emit_jump_insn (gen_tablejump_mips161 (operands[0], operands[1]));\n+\t    emit_insn (gen_tablejump_mips161 (operands[0], operands[1]));\n \t  else\n-\t    emit_jump_insn (gen_tablejump_mips162 (operands[0], operands[1]));\n+\t    emit_insn (gen_tablejump_mips162 (operands[0], operands[1]));\n \t  DONE;\n \t}\n \n@@ -9110,7 +9163,7 @@ move\\\\t%0,%z4\\\\n\\\\\n       emit_insn (gen_extendhisi2 (t1, operands[0]));\n       emit_move_insn (t2, gen_rtx (LABEL_REF, SImode, operands[1]));\n       emit_insn (gen_addsi3 (t3, t1, t2));\n-      emit_insn (gen_tablejump_internal1 (t3, operands[1]));\n+      emit_jump_insn (gen_tablejump_internal1 (t3, operands[1]));\n       DONE;\n     }\n }\")\n@@ -9132,7 +9185,7 @@ move\\\\t%0,%z4\\\\n\\\\\n       emit_insn (gen_extendhidi2 (t1, operands[0]));\n       emit_move_insn (t2, gen_rtx (LABEL_REF, DImode, operands[1]));\n       emit_insn (gen_adddi3 (t3, t1, t2));\n-      emit_insn (gen_tablejump_internal2 (t3, operands[1]));\n+      emit_jump_insn (gen_tablejump_internal2 (t3, operands[1]));\n       DONE;\n     }\n }\")"}]}