{"sha": "8c23e0a440698666e27ee1618bb03704a3473ff9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGMyM2UwYTQ0MDY5ODY2NmUyN2VlMTYxOGJiMDM3MDRhMzQ3M2ZmOQ==", "commit": {"author": {"name": "Daniel Berlin", "email": "dan@cgsoftware.com", "date": "2001-08-20T20:06:07Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2001-08-20T20:06:07Z"}, "message": "fibheap.h: New file.\n\ninclude/\n2001-08-20  Daniel Berlin  <dan@cgsoftware.com>\n\n\t* fibheap.h: New file. Fibonacci heap.\n\nlibiberty/\n2001-08-20  Daniel Berlin  <dan@cgsoftware.com>\n\n\t* fibheap.c: New file. Fibonacci heap.\n\n\t* Makefile.in (CFILES): Add fibheap.c.\n\t(REQUIRED_OFILES): Add fibheap.o.\n\t(fibheap.o): Add dependencies for fibheap.o.\n\nFrom-SVN: r45062", "tree": {"sha": "a600512dc0e9c651033d5c0c576cece93b8dd007", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a600512dc0e9c651033d5c0c576cece93b8dd007"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c23e0a440698666e27ee1618bb03704a3473ff9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c23e0a440698666e27ee1618bb03704a3473ff9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c23e0a440698666e27ee1618bb03704a3473ff9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c23e0a440698666e27ee1618bb03704a3473ff9/comments", "author": null, "committer": null, "parents": [{"sha": "4c8d8761b008297e42ffe82902e61a10d4a8bb40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c8d8761b008297e42ffe82902e61a10d4a8bb40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c8d8761b008297e42ffe82902e61a10d4a8bb40"}], "stats": {"total": 649, "additions": 647, "deletions": 2}, "files": [{"sha": "d3fe4a571c60765090ef70852ab211e53e4c0f0f", "filename": "include/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c23e0a440698666e27ee1618bb03704a3473ff9/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c23e0a440698666e27ee1618bb03704a3473ff9/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=8c23e0a440698666e27ee1618bb03704a3473ff9", "patch": "@@ -1,3 +1,7 @@\n+2001-08-20  Daniel Berlin  <dan@cgsoftware.com>\n+\n+\t* fibheap.h: New file. Fibonacci heap.\n+\n 2001-08-18  Zack Weinberg  <zackw@panix.com>\n \n \t* ansidecl.h: Reorganize for readability, remove documentation"}, {"sha": "16db65e093d2b3b97a8b218564f30e9ddcd4cc33", "filename": "include/fibheap.h", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c23e0a440698666e27ee1618bb03704a3473ff9/include%2Ffibheap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c23e0a440698666e27ee1618bb03704a3473ff9/include%2Ffibheap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Ffibheap.h?ref=8c23e0a440698666e27ee1618bb03704a3473ff9", "patch": "@@ -0,0 +1,80 @@\n+/* A Fibonacci heap datatype.\n+   Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Contributed by Daniel Berlin (dan@cgsoftware.com).\n+\n+This file is part of GNU CC.\n+   \n+GNU CC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Fibonacci heaps are somewhat complex, but, there's an\n+   article in DDJ on them  that explains them pretty well:\n+\n+   http://www.ddj.com/articles/1997/9701/9701o/9701o.htm?topic=algoritms\n+\n+   Introduction to algorithms by Corman and Rivest also goes over\n+   them.\n+\n+   The original paper that introduced them is \"Fibonacci heaps and their\n+   uses in improved network optimization algorithms\" by Tarjan and\n+   Fredman (JACM 34(3), July 1987).\n+\n+   Amortized and real worst case time for operations:\n+\n+   ExtractMin: O(lg n) amortized. O(n) worst case.\n+   DecreaseKey: O(1) amortized.  O(lg n) worst case. \n+   Insert: O(2) amortized. O(1) actual.  \n+   Union: O(1) amortized. O(1) actual.\n+\n+  \n+*/\n+\n+#ifndef _FIBHEAP_H_\n+#define _FIBHEAP_H_\n+\n+#include <ansidecl.h>\n+\n+typedef struct fibheap\n+{\n+  size_t nodes;\n+  struct fibnode *min;\n+  struct fibnode *root;\n+} *fibheap_t;\n+typedef long fibheapkey_t;\n+typedef struct fibnode\n+{\n+  struct fibnode *parent;\n+  struct fibnode *child;\n+  struct fibnode *left;\n+  struct fibnode *right;\n+  unsigned int degree : sizeof(size_t) * CHAR_BIT - 2;\n+  unsigned int mark:1;\n+  fibheapkey_t key;\n+  void *data;\n+} *fibnode_t;\n+\n+extern fibheap_t fibheap_new PARAMS ((void));\n+extern fibnode_t fibheap_insert PARAMS ((fibheap_t, fibheapkey_t, void *));\n+extern int fibheap_empty PARAMS ((fibheap_t));\n+extern fibheapkey_t fibheap_min_key PARAMS ((fibheap_t));\n+extern fibheapkey_t fibheap_replace_key PARAMS ((fibheap_t, fibnode_t, fibheapkey_t));\n+extern void *fibheap_replace_key_data PARAMS ((fibheap_t, fibnode_t, fibheapkey_t, void *));\n+extern void *fibheap_extract_min PARAMS ((fibheap_t));\n+extern void *fibheap_min PARAMS ((fibheap_t));\n+extern void *fibheap_replace_data PARAMS ((fibheap_t, fibnode_t, void *));\n+extern void *fibheap_delete_node PARAMS ((fibheap_t, fibnode_t));\n+extern void fibheap_delete PARAMS ((fibheap_t));\n+extern fibheap_t fibheap_union PARAMS ((fibheap_t, fibheap_t));\n+#endif /* _FIBHEAP_H_ */"}, {"sha": "b788942c37786989bf3de48d23865e72ed7c5dfd", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c23e0a440698666e27ee1618bb03704a3473ff9/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c23e0a440698666e27ee1618bb03704a3473ff9/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=8c23e0a440698666e27ee1618bb03704a3473ff9", "patch": "@@ -1,3 +1,11 @@\n+2001-08-20  Daniel Berlin  <dan@cgsoftware.com>\n+\n+\t* fibheap.c: New file. Fibonacci heap.\n+\n+\t* Makefile.in (CFILES): Add fibheap.c.\n+\t(REQUIRED_OFILES): Add fibheap.o.\n+\t(fibheap.o): Add dependencies for fibheap.o.\n+\n 2001-08-17  Christopher Faylor <cgf@cygnus.com>\n \n \t* configure.in: Always set HAVE_SYS_ERRLIST when targetting cygwin."}, {"sha": "41ea9457939dd64d6a3110bb6dc9633aaf70f7a9", "filename": "libiberty/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c23e0a440698666e27ee1618bb03704a3473ff9/libiberty%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c23e0a440698666e27ee1618bb03704a3473ff9/libiberty%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FMakefile.in?ref=8c23e0a440698666e27ee1618bb03704a3473ff9", "patch": "@@ -133,7 +133,7 @@ CFILES = asprintf.c alloca.c argv.c atexit.c basename.c bcmp.c bcopy.c\t      \\\n \tstrncasecmp.c strchr.c strdup.c strerror.c strncmp.c strrchr.c        \\\n \tstrsignal.c strstr.c strtod.c strtol.c strtoul.c tmpnam.c vasprintf.c \\\n \tvfork.c vfprintf.c vprintf.c vsprintf.c waitpid.c xatexit.c xexit.c   \\\n-\txmalloc.c xmemdup.c xstrdup.c xstrerror.c ternary.c\n+\txmalloc.c xmemdup.c xstrdup.c xstrerror.c ternary.c fibheap.c\n \n # These are always included in the library.\n REQUIRED_OFILES = argv.o alloca.o choose-temp.o concat.o cplus-dem.o          \\\n@@ -142,7 +142,7 @@ REQUIRED_OFILES = argv.o alloca.o choose-temp.o concat.o cplus-dem.o          \\\n         md5.o make-temp-file.o objalloc.o\t\t\t\t      \\\n \tobstack.o partition.o pexecute.o regex.o safe-ctype.o sort.o spaces.o \\\n \tsplay-tree.o strerror.o strsignal.o xatexit.o xexit.o xmalloc.o       \\\n-\txmemdup.o xstrdup.o xstrerror.o ternary.o\n+\txmemdup.o xstrdup.o xstrerror.o ternary.o fibheap.o\n \n $(TARGETLIB): $(REQUIRED_OFILES) $(EXTRA_OFILES) $(LIBOBJS)\n \t-rm -f $(TARGETLIB)\n@@ -265,6 +265,7 @@ cplus-dem.o: config.h $(INCDIR)/demangle.h\n cp-demangle.o: config.h $(INCDIR)/dyn-string.h $(INCDIR)/demangle.h\n dyn-string.o: config.h $(INCDIR)/dyn-string.h\n fdmatch.o: $(INCDIR)/libiberty.h\n+fibheap.o: $(INCDIR)/libiberty.h $(INCDIR)/fibheap.h\n fnmatch.o: config.h $(INCDIR)/fnmatch.h\n getcwd.o: config.h\n getopt.o: config.h $(INCDIR)/getopt.h"}, {"sha": "3c8b34722f604266f8268da7ea51d091e2e10f1e", "filename": "libiberty/fibheap.c", "status": "added", "additions": 552, "deletions": 0, "changes": 552, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c23e0a440698666e27ee1618bb03704a3473ff9/libiberty%2Ffibheap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c23e0a440698666e27ee1618bb03704a3473ff9/libiberty%2Ffibheap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ffibheap.c?ref=8c23e0a440698666e27ee1618bb03704a3473ff9", "patch": "@@ -0,0 +1,552 @@\n+\n+/* A Fibonacci heap datatype.\n+   Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Contributed by Daniel Berlin (dan@cgsoftware.com).\n+   \n+This file is part of GNU CC.\n+   \n+GNU CC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Fibonacci heaps */\n+#include <limits.h>\n+#include <stdlib.h>\n+#include \"libiberty.h\"\n+#include \"fibheap.h\"\n+\n+\n+static void fibheap_init PARAMS ((fibheap_t));\n+static void fibheap_ins_root PARAMS ((fibheap_t, fibnode_t));\n+static void fibheap_rem_root PARAMS ((fibheap_t, fibnode_t));\n+static void fibheap_consolidate PARAMS ((fibheap_t));\n+static void fibheap_link PARAMS ((fibheap_t, fibnode_t, fibnode_t));\n+static void fibheap_cut PARAMS ((fibheap_t, fibnode_t, fibnode_t));\n+static void fibheap_cascading_cut PARAMS ((fibheap_t, fibnode_t));\n+static fibnode_t fibheap_extr_min_node PARAMS ((fibheap_t));\n+static int fibheap_compare PARAMS ((fibheap_t, fibnode_t, fibnode_t));\n+static int fibheap_comp_data PARAMS ((fibheap_t, fibheapkey_t, void *, fibnode_t));\n+static fibnode_t fibnode_new PARAMS ((void));\n+static void fibnode_init PARAMS ((fibnode_t));\n+static void fibnode_insert_after PARAMS ((fibnode_t, fibnode_t));\n+#define fibnode_insert_before(a, b) fibnode_insert_after (a->left, b)\n+static fibnode_t fibnode_remove PARAMS ((fibnode_t));\n+\n+/* Create a new fibonacci heap.  */\n+fibheap_t\n+fibheap_new ()\n+{\n+  fibheap_t result;\n+\n+  if ((result = xmalloc (sizeof (*result))) == NULL)\n+    return NULL;\n+\n+  fibheap_init (result);\n+\n+  return result;\n+}\n+\n+/* Initialize the passed in fibonacci heap.  */\n+static void\n+fibheap_init (heap)\n+     fibheap_t heap;\n+{\n+  heap->nodes = 0;\n+  heap->min = NULL;\n+  heap->root = NULL;\n+}\n+\n+/* Insert DATA, with priority KEY, into HEAP.  */\n+fibnode_t\n+fibheap_insert (heap, key, data)\n+     fibheap_t heap;\n+     fibheapkey_t key;\n+     void *data;\n+{\n+  fibnode_t node;\n+  /* Create the new node, if we fail, return NULL.  */\n+  if ((node = fibnode_new ()) == NULL)\n+    return NULL;\n+  /* Set the node's data.  */\n+  node->data = data;\n+  node->key = key;\n+\n+  /* Insert it into the root list.  */\n+  fibheap_ins_root (heap, node);\n+\n+  /* If their was no minimum, or this key is less than the min, it's the new\n+     min.  */\n+  if (heap->min == NULL || node->key < heap->min->key)\n+    heap->min = node;\n+\n+  heap->nodes++;\n+\n+  return node;\n+}\n+\n+/* Return the data of the minimum node (if we know it).  */\n+void *\n+fibheap_min (heap)\n+     fibheap_t heap;\n+{\n+  /* If there is no min, we can't easily return it.  */\n+  if (heap->min == NULL)\n+    return NULL;\n+  return heap->min->data;\n+}\n+\n+/* Return the key of the minimum node (if we know it).  */\n+fibheapkey_t\n+fibheap_min_key (heap)\n+     fibheap_t heap;\n+{\n+  /* If there is no min, we can't easily return it.  */\n+  if (heap->min == NULL)\n+    return 0;\n+  return heap->min->key;\n+}\n+\n+/* Union HEAPA and HEAPB into a new heap.  */\n+fibheap_t\n+fibheap_union (heapa, heapb)\n+     fibheap_t heapa;\n+     fibheap_t heapb;\n+{\n+  fibnode_t temp;\n+\n+  /* If one of the heaps is empty, the union is just the other heap.  */\n+  if (heapa->root == NULL || heapb->root == NULL)\n+    {\n+      if (heapa->root == NULL)\n+\t{\n+\t  free (heapa);\n+\t  return heapb;\n+\t}\n+      else\n+\t{\n+\t  free (heapb);\n+\t  return heapa;\n+\t}\n+    }\n+  /* Merge them to the next nodes on the opposite chain.  */\n+  heapa->root->left->right = heapb->root;\n+  heapb->root->left->right = heapa->root;\n+  temp = heapa->root->left;\n+  heapa->root->left = heapb->root->left;\n+  heapb->root->left = temp;\n+  heapa->nodes += heapb->nodes;\n+\n+  /* And set the new minimum, if it's changed.  */\n+  if (fibheap_compare (heapa, heapb->min, heapa->min) < 0)\n+    heapa->min = heapb->min;\n+\n+  free (heapb);\n+  return heapa;\n+}\n+\n+/* Extract the data of the minimum node from HEAP.  */\n+void *\n+fibheap_extract_min (heap)\n+     fibheap_t heap;\n+{\n+  fibnode_t z;\n+  void *ret;\n+\n+  ret = NULL;\n+  /* If we don't have a min set, it means we have no nodes.  */\n+  if (heap->min != NULL)\n+    {\n+      /* Otherwise, extract the min node, free the node, and return the\n+         node's data.  */\n+      z = fibheap_extr_min_node (heap);\n+      ret = z->data;\n+      free (z);\n+    }\n+\n+  return ret;\n+}\n+\n+/* Replace the DATA associated with NODE.  */\n+void *\n+fibheap_replace_data (heap, node, data)\n+     fibheap_t heap;\n+     fibnode_t node;\n+     void *data;\n+{\n+  return fibheap_replace_key_data (heap, node, node->key, data);\n+}\n+\n+/* Replace the KEY associated with NODE.  */\n+fibheapkey_t\n+fibheap_replace_key (heap, node, key)\n+     fibheap_t heap;\n+     fibnode_t node;\n+     fibheapkey_t key;\n+{\n+  int ret;\n+\n+  ret = node->key;\n+  (void) fibheap_replace_key_data (heap, node, key, node->data);\n+\n+  return ret;\n+}\n+\n+/* Replace both the KEY and the DATA associated with NODE.  */\n+void *\n+fibheap_replace_key_data (heap, node, key, data)\n+     fibheap_t heap;\n+     fibnode_t node;\n+     fibheapkey_t key;\n+     void *data;\n+{\n+  void *odata;\n+  int okey;\n+  fibnode_t y;\n+\n+  /* If we wanted to, we could actually do a real increase by redeleting and\n+     inserting. However, this would require O (log n) time. So just bail out\n+     for now.  */\n+  if (fibheap_comp_data (heap, key, data, node) > 0)\n+    return NULL;\n+\n+  odata = node->data;\n+  okey = node->key;\n+  node->data = data;\n+  node->key = key;\n+  y = node->parent;\n+\n+  if (okey == key)\n+    return odata;\n+\n+  /* These two compares are specifically <= 0 to make sure that in the case\n+     of equality, a node we replaced the data on, becomes the new min.  This\n+     is needed so that delete's call to extractmin gets the right node.  */\n+  if (y != NULL && fibheap_compare (heap, node, y) <= 0)\n+    {\n+      fibheap_cut (heap, node, y);\n+      fibheap_cascading_cut (heap, y);\n+    }\n+\n+  if (fibheap_compare (heap, node, heap->min) <= 0)\n+    heap->min = node;\n+\n+  return odata;\n+}\n+\n+/* Delete NODE from HEAP.  */\n+void *\n+fibheap_delete_node (heap, node)\n+     fibheap_t heap;\n+     fibnode_t node;\n+{\n+  void *k;\n+  /* To perform delete, we just make it the min key, and extract.  */\n+  k = node->data;\n+  fibheap_replace_key (heap, node, LONG_MIN);\n+  fibheap_extract_min (heap);\n+\n+  return k;\n+}\n+\n+/* Delete HEAP.  */\n+void\n+fibheap_delete (heap)\n+     fibheap_t heap;\n+{\n+  while (heap->min != NULL)\n+    free (fibheap_extr_min_node (heap));\n+\n+  free (heap);\n+}\n+\n+/* Determine if HEAP is empty.  */\n+int\n+fibheap_empty (heap)\n+     fibheap_t heap;\n+{\n+  return heap->nodes == 0;\n+}\n+\n+\n+/* Extract the minimum node of the heap.  */\n+static fibnode_t\n+fibheap_extr_min_node (heap)\n+     fibheap_t heap;\n+{\n+  fibnode_t ret;\n+  fibnode_t x, y, orig;\n+\n+  ret = heap->min;\n+\n+  orig = NULL;\n+  /* Attach the child list of the minimum node to the root list of the heap.\n+     If there is no child list, we don't do squat.  */\n+  for (x = ret->child; x != orig && x != NULL;)\n+    {\n+      if (orig == NULL)\n+\torig = x;\n+      y = x->right;\n+      x->parent = NULL;\n+      fibheap_ins_root (heap, x);\n+      x = y;\n+    }\n+  /* Remove the old root.  */\n+  fibheap_rem_root (heap, ret);\n+  heap->nodes--;\n+  /* If we are left with no nodes, then the min is NULL.  */\n+  if (heap->nodes == 0)\n+    heap->min = NULL;\n+  else\n+    {\n+      /* Otherwise, consolidate to find new minimum, as well as do the reorg\n+         work that needs to be done.  */\n+      heap->min = ret->right;\n+      fibheap_consolidate (heap);\n+    }\n+\n+  return ret;\n+}\n+\n+/* Insert NODE into the root list of HEAP.  */\n+static void\n+fibheap_ins_root (heap, node)\n+     fibheap_t heap;\n+     fibnode_t node;\n+{\n+  /* If the heap is currently empty, the new node becomes the singleton\n+     circular root list.  */\n+  if (heap->root == NULL)\n+    {\n+      heap->root = node;\n+      node->left = node;\n+      node->right = node;\n+      return;\n+    }\n+  /* Otherwise, insert it in the circular root list between the root and it's \n+     right node.  */\n+  fibnode_insert_after (heap->root, node);\n+}\n+\n+/* Remove NODE from the rootlist of HEAP.  */\n+static void\n+fibheap_rem_root (heap, node)\n+     fibheap_t heap;\n+     fibnode_t node;\n+{\n+  if (node->left == node)\n+    heap->root = NULL;\n+  else\n+    heap->root = fibnode_remove (node);\n+}\n+\n+/* Consolidate the heap.  */\n+static void\n+fibheap_consolidate (heap)\n+     fibheap_t heap;\n+{\n+  fibnode_t a[1 + 8 * sizeof (long)];\n+  fibnode_t w;\n+  fibnode_t y;\n+  fibnode_t x;\n+  int i;\n+  int d;\n+  int D;\n+\n+  D = 1 + 8 * sizeof (long);\n+\n+  memset (a, 0, sizeof (fibnode_t) * D);\n+\n+  while ((w = heap->root) != NULL)\n+    {\n+      x = w;\n+      fibheap_rem_root (heap, w);\n+      d = x->degree;\n+      while (a[d] != NULL)\n+\t{\n+\t  y = a[d];\n+\t  if (fibheap_compare (heap, x, y) > 0)\n+\t    {\n+\t      fibnode_t temp;\n+\t      temp = x;\n+\t      x = y;\n+\t      y = temp;\n+\t    }\n+\t  fibheap_link (heap, y, x);\n+\t  a[d] = NULL;\n+\t  d++;\n+\t}\n+      a[d] = x;\n+    }\n+  heap->min = NULL;\n+  for (i = 0; i < D; i++)\n+    if (a[i] != NULL)\n+      {\n+\tfibheap_ins_root (heap, a[i]);\n+\tif (heap->min == NULL || fibheap_compare (heap, a[i], heap->min) < 0)\n+\t  heap->min = a[i];\n+      }\n+}\n+\n+/* Make NODE a child of PARENT.  */\n+static void\n+fibheap_link (heap, node, parent)\n+     fibheap_t heap ATTRIBUTE_UNUSED;\n+     fibnode_t node;\n+     fibnode_t parent;\n+{\n+  if (parent->child == NULL)\n+    parent->child = node;\n+  else\n+    fibnode_insert_before (parent->child, node);\n+  node->parent = parent;\n+  parent->degree++;\n+  node->mark = 0;\n+}\n+\n+/* Remove NODE from PARENT's child list.  */\n+static void\n+fibheap_cut (heap, node, parent)\n+     fibheap_t heap;\n+     fibnode_t node;\n+     fibnode_t parent;\n+{\n+  fibnode_remove (node);\n+  parent->degree--;\n+  fibheap_ins_root (heap, node);\n+  node->parent = NULL;\n+  node->mark = 0;\n+}\n+\n+static void\n+fibheap_cascading_cut (heap, y)\n+     fibheap_t heap;\n+     fibnode_t y;\n+{\n+  fibnode_t z;\n+\n+  while ((z = y->parent) != NULL)\n+    {\n+      if (y->mark == 0)\n+\t{\n+\t  y->mark = 1;\n+\t  return;\n+\t}\n+      else\n+\t{\n+\t  fibheap_cut (heap, y, z);\n+\t  y = z;\n+\t}\n+    }\n+}\n+\n+\n+static fibnode_t\n+fibnode_new ()\n+{\n+  fibnode_t e;\n+\n+  if ((e = xmalloc (sizeof *e)) == NULL)\n+    return NULL;\n+\n+  fibnode_init (e);\n+\n+  return e;\n+}\n+\n+static void\n+fibnode_init (node)\n+     fibnode_t node;\n+{\n+  node->degree = 0;\n+  node->mark = 0;\n+  node->parent = NULL;\n+  node->child = NULL;\n+  node->left = node;\n+  node->right = node;\n+  node->data = NULL;\n+}\n+\n+static void\n+fibnode_insert_after (a, b)\n+     fibnode_t a;\n+     fibnode_t b;\n+{\n+  if (a == a->right)\n+    {\n+      a->right = b;\n+      a->left = b;\n+      b->right = a;\n+      b->left = a;\n+    }\n+  else\n+    {\n+      b->right = a->right;\n+      a->right->left = b;\n+      a->right = b;\n+      b->left = a;\n+    }\n+}\n+\n+\n+static fibnode_t\n+fibnode_remove (node)\n+     fibnode_t node;\n+{\n+  fibnode_t ret;\n+\n+  if (node == node->left)\n+    ret = NULL;\n+  else\n+    ret = node->left;\n+\n+  if (node->parent != NULL && node->parent->child == node)\n+    node->parent->child = ret;\n+\n+  node->right->left = node->left;\n+  node->left->right = node->right;\n+\n+  node->parent = NULL;\n+  node->left = node;\n+  node->right = node;\n+\n+  return ret;\n+}\n+\n+static int\n+fibheap_compare (heap, a, b)\n+     fibheap_t heap ATTRIBUTE_UNUSED;\n+     fibnode_t a;\n+     fibnode_t b;\n+{\n+  if (a->key < b->key)\n+    return -1;\n+  if (a->key > b->key)\n+    return 1;\n+  return 0;\n+}\n+\n+static int\n+fibheap_comp_data (heap, key, data, b)\n+     fibheap_t heap;\n+     fibheapkey_t key;\n+     void *data;\n+     fibnode_t b;\n+{\n+  struct fibnode a;\n+\n+  a.key = key;\n+  a.data = data;\n+\n+  return fibheap_compare (heap, &a, b);\n+}"}]}