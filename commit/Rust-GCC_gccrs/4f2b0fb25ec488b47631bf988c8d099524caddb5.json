{"sha": "4f2b0fb25ec488b47631bf988c8d099524caddb5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGYyYjBmYjI1ZWM0ODhiNDc2MzFiZjk4OGM4ZDA5OTUyNGNhZGRiNQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2002-02-22T11:57:52Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2002-02-22T11:57:52Z"}, "message": "PR c++/2645, DR 295\n\ncp:\n\tPR c++/2645, DR 295\n\t* cp-tree.h (tsubst_flags_t): Add tf_ignore_bad_quals,\n\ttf_keep_type_decl.\n\t(make_typename_type): Use tsubst_flags_t.\n\t* decl.c (make_typename_type): Adjust. Return non-artificial\n\tTYPE_DECLs, if required.\n\t(grokdeclarator): Simplify CVR qualification handling. Allow bad\n\tqualifiers on typedef types.\n\t* decl2.c (handle_class_head): Adjust make_typename_type call.\n\t* parse.y (nested_name_specifier): Likewise.\n\t(typename_sub0): Likewise.\n\t(typename_sub1): Likewise.\n\t* pt.c (convert_template_argument): Adjust make_typename_type\n\treturn value.\n\t(tsubst): Adjust cp_build_qualified_type_real calls.\n\t(check_cv_quals_for_unify): Cope with alowing bad qualifications\n\ton template type parms.\n\t(instantiate_decl): Recheck substitutions to give warnings on bad\n\tqualifications.\n\t* tree.c (cp_build_qualified_type_real): Use tf_allow_bad_quals.\ntestsuite:\n\t* g++.dg/template/qualttp19.C: New test.\n\t* g++.dg/template/qualttp20.C: New test.\n\t* g++.old-deja/g++.jason/report.C: Adjust expected errors\n\t* g++.old-deja/g++.other/qual1.C: Likewise.\n\nFrom-SVN: r49961", "tree": {"sha": "15da02c0132151ee69a9aaeb4e66a7b7b3df0c9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15da02c0132151ee69a9aaeb4e66a7b7b3df0c9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f2b0fb25ec488b47631bf988c8d099524caddb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f2b0fb25ec488b47631bf988c8d099524caddb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f2b0fb25ec488b47631bf988c8d099524caddb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f2b0fb25ec488b47631bf988c8d099524caddb5/comments", "author": null, "committer": null, "parents": [{"sha": "54fec3d54ad98245f71154255bd77099f39f9edb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54fec3d54ad98245f71154255bd77099f39f9edb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54fec3d54ad98245f71154255bd77099f39f9edb"}], "stats": {"total": 382, "additions": 287, "deletions": 95}, "files": [{"sha": "31fc320856eae1fc3711f1ee0984ae3cb279c079", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2b0fb25ec488b47631bf988c8d099524caddb5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2b0fb25ec488b47631bf988c8d099524caddb5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4f2b0fb25ec488b47631bf988c8d099524caddb5", "patch": "@@ -1,3 +1,26 @@\n+2002-02-22  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/2645, DR 295\n+\t* cp-tree.h (tsubst_flags_t): Add tf_ignore_bad_quals,\n+\ttf_keep_type_decl.\n+\t(make_typename_type): Use tsubst_flags_t.\n+\t* decl.c (make_typename_type): Adjust. Return non-artificial\n+\tTYPE_DECLs, if required.\n+\t(grokdeclarator): Simplify CVR qualification handling. Allow bad\n+\tqualifiers on typedef types.\n+\t* decl2.c (handle_class_head): Adjust make_typename_type call.\n+\t* parse.y (nested_name_specifier): Likewise.\n+\t(typename_sub0): Likewise.\n+\t(typename_sub1): Likewise.\n+\t* pt.c (convert_template_argument): Adjust make_typename_type\n+\treturn value.\n+\t(tsubst): Adjust cp_build_qualified_type_real calls.\n+\t(check_cv_quals_for_unify): Cope with alowing bad qualifications\n+\ton template type parms.\n+\t(instantiate_decl): Recheck substitutions to give warnings on bad\n+\tqualifications.\n+\t* tree.c (cp_build_qualified_type_real): Use tf_allow_bad_quals.\n+\n 2002-02-21  Aldy Hernandez  <aldyh@redhat.com>\n \n         * cp/decl.c (duplicate_decls): Merge always_inline attribute."}, {"sha": "ad826124a4e8a8c9b58fefac035b3c5f3cc694a1", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2b0fb25ec488b47631bf988c8d099524caddb5/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2b0fb25ec488b47631bf988c8d099524caddb5/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4f2b0fb25ec488b47631bf988c8d099524caddb5", "patch": "@@ -3070,7 +3070,10 @@ typedef enum tsubst_flags_t {\n   tf_warning = 1 << 1,       /* give warnings too  */\n   tf_no_attributes = 1 << 2, /* ignore attributes on comparisons\n \t\t\t\t(instantiate_type use) */\n-  tf_ptrmem_ok = 1 << 3      /* pointers to member ok (internal\n+  tf_ignore_bad_quals = 1 << 3, /* ignore bad cvr qualifiers */\n+  tf_keep_type_decl = 1 << 4,\t/* retain typedef type decls\n+\t\t\t\t   (make_typename_type use) */\n+  tf_ptrmem_ok = 1 << 5      /* pointers to member ok (internal\n \t\t\t\tinstantiate_type use) */\n } tsubst_flags_t;\n \n@@ -3693,7 +3696,7 @@ extern tree namespace_binding                   PARAMS ((tree, tree));\n extern void set_namespace_binding               PARAMS ((tree, tree, tree));\n extern tree lookup_namespace_name\t\tPARAMS ((tree, tree));\n extern tree build_typename_type                 PARAMS ((tree, tree, tree, tree));\n-extern tree make_typename_type\t\t\tPARAMS ((tree, tree, int));\n+extern tree make_typename_type\t\t\tPARAMS ((tree, tree, tsubst_flags_t));\n extern tree make_unbound_class_template\t\tPARAMS ((tree, tree, int));\n extern tree lookup_name_nonclass\t\tPARAMS ((tree));\n extern tree lookup_function_nonclass            PARAMS ((tree, tree));"}, {"sha": "4d912cdf897fc582feaeb722abcd99c1bdadecc8", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 50, "deletions": 49, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2b0fb25ec488b47631bf988c8d099524caddb5/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2b0fb25ec488b47631bf988c8d099524caddb5/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=4f2b0fb25ec488b47631bf988c8d099524caddb5", "patch": "@@ -5609,12 +5609,15 @@ build_typename_type (context, name, fullname, base_type)\n \n /* Resolve `typename CONTEXT::NAME'.  Returns an appropriate type,\n    unless an error occurs, in which case error_mark_node is returned.\n-   If COMPLAIN zero, don't complain about any errors that occur.  */\n+   If we locate a non-artificial TYPE_DECL and TF_KEEP_TYPE_DECL is\n+   set, we return that, rather than the _TYPE it corresponds to, in\n+   other cases we look through the type decl.  If TF_ERROR is set,\n+   complain about errors, otherwise be quiet.  */\n \n tree\n make_typename_type (context, name, complain)\n      tree context, name;\n-     int complain;\n+     tsubst_flags_t complain;\n {\n   tree fullname;\n \n@@ -5653,7 +5656,7 @@ make_typename_type (context, name, complain)\n     {\n       /* We can get here from typename_sub0 in the explicit_template_type\n \t expansion.  Just fail.  */\n-      if (complain)\n+      if (complain & tf_error)\n \terror (\"no class template named `%#T' in `%#T'\",\n \t\t  name, context);\n       return error_mark_node;\n@@ -5669,7 +5672,7 @@ make_typename_type (context, name, complain)\n \t    tmpl = lookup_field (context, name, 0, 0);\n \t  if (!tmpl || !DECL_CLASS_TEMPLATE_P (tmpl))\n \t    {\n-\t      if (complain)\n+\t      if (complain & tf_error)\n \t\terror (\"no class template named `%#T' in `%#T'\",\n \t\t\t  name, context);\n \t      return error_mark_node;\n@@ -5687,22 +5690,26 @@ make_typename_type (context, name, complain)\n \n \t  if (!IS_AGGR_TYPE (context))\n \t    {\n-\t      if (complain)\n+\t      if (complain & tf_error)\n \t\terror (\"no type named `%#T' in `%#T'\", name, context);\n \t      return error_mark_node;\n \t    }\n \n \t  t = lookup_field (context, name, 0, 1);\n \t  if (t)\n-\t    return TREE_TYPE (t);\n+\t    {\n+\t      if (DECL_ARTIFICIAL (t) || !(complain & tf_keep_type_decl))\n+\t\tt = TREE_TYPE (t);\n+\t      return t;\n+\t    }\n \t}\n     }\n \n   /* If the CONTEXT is not a template type, then either the field is\n      there now or its never going to be.  */\n   if (!uses_template_parms (context))\n     {\n-      if (complain)\n+      if (complain & tf_error)\n \terror (\"no type named `%#T' in `%#T'\", name, context);\n       return error_mark_node;\n     }\n@@ -5713,7 +5720,9 @@ make_typename_type (context, name, complain)\n \n /* Resolve `CONTEXT::template NAME'.  Returns an appropriate type,\n    unless an error occurs, in which case error_mark_node is returned.\n-   If COMPLAIN zero, don't complain about any errors that occur.  */\n+   If we locate a TYPE_DECL, we return that, rather than the _TYPE it\n+   corresponds to.  If COMPLAIN zero, don't complain about any errors\n+   that occur.  */\n \n tree\n make_unbound_class_template (context, name, complain)\n@@ -9606,9 +9615,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n   tree spec;\n   tree type = NULL_TREE;\n   int longlong = 0;\n-  int constp;\n-  int restrictp;\n-  int volatilep;\n   int type_quals;\n   int virtualp, explicitp, friendp, inlinep, staticp;\n   int explicit_int = 0;\n@@ -10314,26 +10320,24 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \ttype = build_complex_type (type);\n     }\n \n-  if (sfk == sfk_conversion\n-      && (RIDBIT_SETP (RID_CONST, specbits)\n-\t  || RIDBIT_SETP (RID_VOLATILE, specbits)\n-\t  || RIDBIT_SETP (RID_RESTRICT, specbits)))\n+  type_quals = TYPE_UNQUALIFIED;\n+  if (RIDBIT_SETP (RID_CONST, specbits))\n+    type_quals |= TYPE_QUAL_CONST;\n+  if (RIDBIT_SETP (RID_VOLATILE, specbits))\n+    type_quals |= TYPE_QUAL_VOLATILE;\n+  if (RIDBIT_SETP (RID_RESTRICT, specbits))\n+    type_quals |= TYPE_QUAL_RESTRICT;\n+  if (sfk == sfk_conversion && type_quals != TYPE_UNQUALIFIED)\n     error (\"qualifiers are not allowed on declaration of `operator %T'\",\n \t      ctor_return_type);\n \n-  /* Set CONSTP if this declaration is `const', whether by\n-     explicit specification or via a typedef.\n-     Likewise for VOLATILEP.  */\n-\n-  constp = !! RIDBIT_SETP (RID_CONST, specbits) + CP_TYPE_CONST_P (type);\n-  restrictp =\n-    !! RIDBIT_SETP (RID_RESTRICT, specbits) + CP_TYPE_RESTRICT_P (type);\n-  volatilep =\n-    !! RIDBIT_SETP (RID_VOLATILE, specbits) + CP_TYPE_VOLATILE_P (type);\n-  type_quals = ((constp ? TYPE_QUAL_CONST : 0)\n-\t\t| (restrictp ? TYPE_QUAL_RESTRICT : 0)\n-\t\t| (volatilep ? TYPE_QUAL_VOLATILE : 0));\n-  type = cp_build_qualified_type (type, type_quals);\n+  type_quals |= cp_type_quals (type);\n+  type = cp_build_qualified_type_real\n+    (type, type_quals, ((typedef_decl && !DECL_ARTIFICIAL (typedef_decl)\n+ \t\t\t ? tf_ignore_bad_quals : 0) | tf_error | tf_warning));\n+  /* We might have ignored or rejected some of the qualifiers.  */\n+  type_quals = cp_type_quals (type);\n+  \n   staticp = 0;\n   inlinep = !! RIDBIT_SETP (RID_INLINE, specbits);\n   virtualp = RIDBIT_SETP (RID_VIRTUAL, specbits);\n@@ -10826,21 +10830,30 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    {\n \t      register tree typemodlist;\n \t      int erred = 0;\n-\n-\t      constp = 0;\n-\t      volatilep = 0;\n-\t      restrictp = 0;\n+\t      int constp = 0;\n+\t      int volatilep = 0;\n+\t      int restrictp = 0;\n+\t      \n \t      for (typemodlist = TREE_TYPE (declarator); typemodlist;\n \t\t   typemodlist = TREE_CHAIN (typemodlist))\n \t\t{\n \t\t  tree qualifier = TREE_VALUE (typemodlist);\n \n \t\t  if (qualifier == ridpointers[(int) RID_CONST])\n-\t\t    constp++;\n+\t\t    {\n+\t\t      constp++;\n+\t\t      type_quals |= TYPE_QUAL_CONST;\n+\t\t    }\n \t\t  else if (qualifier == ridpointers[(int) RID_VOLATILE])\n-\t\t    volatilep++;\n+\t\t    {\n+\t\t      volatilep++;\n+\t\t      type_quals |= TYPE_QUAL_VOLATILE;\n+\t\t    }\n \t\t  else if (qualifier == ridpointers[(int) RID_RESTRICT])\n-\t\t    restrictp++;\n+\t\t    {\n+\t\t      restrictp++;\n+\t\t      type_quals |= TYPE_QUAL_RESTRICT;\n+\t\t    }\n \t\t  else if (!erred)\n \t\t    {\n \t\t      erred = 1;\n@@ -10853,20 +10866,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\tpedwarn (\"duplicate `volatile'\");\n \t      if (restrictp > 1)\n \t\tpedwarn (\"duplicate `restrict'\");\n-\n-\t      type_quals = ((constp ? TYPE_QUAL_CONST : 0)\n-\t\t\t    | (restrictp ? TYPE_QUAL_RESTRICT : 0)\n-\t\t\t    | (volatilep ? TYPE_QUAL_VOLATILE : 0));\n-\t      if (TREE_CODE (declarator) == ADDR_EXPR\n-\t\t  && (constp || volatilep))\n-\t\t{\n-\t\t  if (constp)\n-\t\t    pedwarn (\"discarding `const' applied to a reference\");\n-\t\t  if (volatilep)\n-\t\t    pedwarn (\"discarding `volatile' applied to a reference\");\n-\t\t  type_quals &= ~(TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE);\n-\t\t}\n \t      type = cp_build_qualified_type (type, type_quals);\n+\t      type_quals = cp_type_quals (type);\n \t    }\n \t  declarator = TREE_OPERAND (declarator, 0);\n \t  ctype = NULL_TREE;\n@@ -11110,7 +11111,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n       else if (type_quals & TYPE_QUAL_CONST)\n \t{\n \t  error (\"const `%s' cannot be declared `mutable'\", name);\n-\t  RIDBIT_RESET (RID_MUTABLE, specbits);\n+ \t  RIDBIT_RESET (RID_MUTABLE, specbits);\n \t}\n     }\n "}, {"sha": "ea1d2978d2bb8147395105a2e30f06f12e262751", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2b0fb25ec488b47631bf988c8d099524caddb5/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2b0fb25ec488b47631bf988c8d099524caddb5/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=4f2b0fb25ec488b47631bf988c8d099524caddb5", "patch": "@@ -5219,7 +5219,7 @@ handle_class_head (aggr, scope, id, defn_p, new_type_p)\n \t    {\n \t      /* According to the suggested resolution of core issue\n \t     \t 180, 'typename' is assumed after a class-key.  */\n-\t      decl = make_typename_type (scope, id, 1);\n+\t      decl = make_typename_type (scope, id, tf_error);\n \t      if (decl != error_mark_node)\n \t\tdecl = TYPE_MAIN_DECL (decl);\n \t      else"}, {"sha": "e6bdc9a1f2ee5501409043367c1e3f627e18d39a", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2b0fb25ec488b47631bf988c8d099524caddb5/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2b0fb25ec488b47631bf988c8d099524caddb5/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=4f2b0fb25ec488b47631bf988c8d099524caddb5", "patch": "@@ -3029,14 +3029,14 @@ nested_name_specifier:\n \t\t{ $$ = $2; }\n \t| nested_name_specifier TEMPLATE explicit_template_type SCOPE\n                 { got_scope = $$ \n-\t\t    = make_typename_type ($1, $3, /*complain=*/1); }\n+\t\t    = make_typename_type ($1, $3, tf_error); }\n \t/* Error handling per Core 125.  */\n \t| nested_name_specifier IDENTIFIER SCOPE\n                 { got_scope = $$ \n-\t\t    = make_typename_type ($1, $2, /*complain=*/1); }\n+\t\t    = make_typename_type ($1, $2, tf_error); }\n \t| nested_name_specifier PTYPENAME SCOPE\n                 { got_scope = $$ \n-\t\t    = make_typename_type ($1, $2, /*complain=*/1); }\n+\t\t    = make_typename_type ($1, $2, tf_error); }\n \t;\n \n /* Why the @#$%^& do type_name and notype_identifier need to be expanded\n@@ -3078,7 +3078,7 @@ typename_sub0:\n \t  typename_sub1 identifier %prec EMPTY\n \t\t{\n \t\t  if (TYPE_P ($1))\n-\t\t    $$ = make_typename_type ($1, $2, /*complain=*/1);\n+\t\t    $$ = make_typename_type ($1, $2, tf_error);\n \t\t  else if (TREE_CODE ($2) == IDENTIFIER_NODE)\n \t\t    error (\"`%T' is not a class or namespace\", $2);\n \t\t  else\n@@ -3091,9 +3091,9 @@ typename_sub0:\n \t| typename_sub1 template_type %prec EMPTY\n \t\t{ $$ = TREE_TYPE ($2); }\n \t| typename_sub1 explicit_template_type %prec EMPTY\n-                { $$ = make_typename_type ($1, $2, /*complain=*/1); }\n+                { $$ = make_typename_type ($1, $2, tf_error); }\n \t| typename_sub1 TEMPLATE explicit_template_type %prec EMPTY\n-                { $$ = make_typename_type ($1, $3, /*complain=*/1); }\n+                { $$ = make_typename_type ($1, $3, tf_error); }\n \t;\n \n typename_sub1:\n@@ -3107,7 +3107,7 @@ typename_sub1:\n \t| typename_sub1 typename_sub2\n \t\t{\n \t\t  if (TYPE_P ($1))\n-\t\t    $$ = make_typename_type ($1, $2, /*complain=*/1);\n+\t\t    $$ = make_typename_type ($1, $2, tf_error);\n \t\t  else if (TREE_CODE ($2) == IDENTIFIER_NODE)\n \t\t    error (\"`%T' is not a class or namespace\", $2);\n \t\t  else\n@@ -3119,10 +3119,10 @@ typename_sub1:\n \t\t}\n \t| typename_sub1 explicit_template_type SCOPE\n                 { got_scope = $$ \n-\t\t    = make_typename_type ($1, $2, /*complain=*/1); }\n+\t\t    = make_typename_type ($1, $2, tf_error); }\n \t| typename_sub1 TEMPLATE explicit_template_type SCOPE\n                 { got_scope = $$ \n-\t\t    = make_typename_type ($1, $3, /*complain=*/1); }\n+\t\t    = make_typename_type ($1, $3, tf_error); }\n \t;\n \n /* This needs to return a TYPE_DECL for simple names so that we don't"}, {"sha": "152ac0e3820289a2156392fc0529ecbd485a8f0a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 54, "deletions": 10, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2b0fb25ec488b47631bf988c8d099524caddb5/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2b0fb25ec488b47631bf988c8d099524caddb5/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4f2b0fb25ec488b47631bf988c8d099524caddb5", "patch": "@@ -3335,8 +3335,6 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n       arg = make_typename_type (TREE_OPERAND (arg, 0),\n \t\t\t\tTREE_OPERAND (arg, 1),\n \t\t\t\tcomplain & tf_error);\n-      if (TREE_CODE (arg) == TYPE_DECL)\n-\targ = TREE_TYPE (arg);\n       is_type = 1;\n     }\n   if (is_type != requires_type)\n@@ -6407,7 +6405,7 @@ tsubst (t, args, complain, in_decl)\n \t\t    my_friendly_assert (TYPE_P (arg), 0);\n \t\t    return cp_build_qualified_type_real\n \t\t      (arg, cp_type_quals (arg) | cp_type_quals (t),\n-\t\t       complain);\n+\t\t       complain | tf_ignore_bad_quals);\n \t\t  }\n \t\telse if (TREE_CODE (t) == BOUND_TEMPLATE_TEMPLATE_PARM)\n \t\t  {\n@@ -6459,8 +6457,10 @@ tsubst (t, args, complain, in_decl)\n \t    if (cp_type_quals (t))\n \t      {\n \t\tr = tsubst (TYPE_MAIN_VARIANT (t), args, complain, in_decl);\n-\t\tr = cp_build_qualified_type_real\n-\t\t  (r, cp_type_quals (t), complain);\n+ \t\tr = cp_build_qualified_type_real\n+ \t\t  (r, cp_type_quals (t),\n+\t\t   complain | (TREE_CODE (t) == TEMPLATE_TYPE_PARM\n+\t\t\t       ? tf_ignore_bad_quals : 0));\n \t      }\n \t    else\n \t      {\n@@ -6785,11 +6785,18 @@ tsubst (t, args, complain, in_decl)\n \t      }\n \t  }\n \n-\tf = make_typename_type (ctx, f, complain & tf_error);\n+\tf = make_typename_type (ctx, f,\n+\t\t\t\t(complain & tf_error) | tf_keep_type_decl);\n \tif (f == error_mark_node)\n \t  return f;\n-\treturn cp_build_qualified_type_real\n-\t  (f, cp_type_quals (f) | cp_type_quals (t), complain);\n+ \tif (TREE_CODE (f) == TYPE_DECL)\n+ \t  {\n+\t    complain |= tf_ignore_bad_quals;\n+ \t    f = TREE_TYPE (f);\n+ \t  }\n+ \t\n+ \treturn cp_build_qualified_type_real\n+ \t  (f, cp_type_quals (f) | cp_type_quals (t), complain);\n       }\n \t       \n     case UNBOUND_CLASS_TEMPLATE:\n@@ -8463,12 +8470,28 @@ check_cv_quals_for_unify (strict, arg, parm)\n      tree arg;\n      tree parm;\n {\n+  int arg_quals = cp_type_quals (arg);\n+  int parm_quals = cp_type_quals (parm);\n+\n+  if (TREE_CODE (parm) == TEMPLATE_TYPE_PARM)\n+    {\n+      /* If the cvr quals of parm will not unify with ARG, they'll be\n+\t ignored in instantiation, so we have to do the same here.  */\n+      if (TREE_CODE (arg) == REFERENCE_TYPE\n+\t  || TREE_CODE (arg) == FUNCTION_TYPE\n+\t  || TREE_CODE (arg) == METHOD_TYPE)\n+\tparm_quals &= ~(TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE);\n+      if (!POINTER_TYPE_P (arg) &&\n+\t  TREE_CODE (arg) != TEMPLATE_TYPE_PARM)\n+\tparm_quals &= ~TYPE_QUAL_RESTRICT;\n+    }\n+  \n   if (!(strict & (UNIFY_ALLOW_MORE_CV_QUAL | UNIFY_ALLOW_OUTER_MORE_CV_QUAL))\n-      && !at_least_as_qualified_p (arg, parm))\n+      && (arg_quals & parm_quals) != parm_quals)\n     return 0;\n \n   if (!(strict & (UNIFY_ALLOW_LESS_CV_QUAL | UNIFY_ALLOW_OUTER_LESS_CV_QUAL))\n-      && !at_least_as_qualified_p (parm, arg))\n+      && (parm_quals & arg_quals) != arg_quals)\n     return 0;\n \n   return 1;\n@@ -9930,6 +9953,27 @@ instantiate_decl (d, defer_ok)\n \timport_export_decl (d);\n     }\n \n+  if (!defer_ok)\n+    {\n+      /* Recheck the substitutions to obtain any warning messages\n+\t about ignoring cv qualifiers.  */\n+      tree gen = DECL_TEMPLATE_RESULT (gen_tmpl);\n+      tree type = TREE_TYPE (gen);\n+\n+      if (TREE_CODE (gen) == FUNCTION_DECL)\n+\t{\n+\t  tsubst (DECL_ARGUMENTS (gen), args, tf_error | tf_warning, d);\n+\t  tsubst (TYPE_RAISES_EXCEPTIONS (type), args,\n+\t\t  tf_error | tf_warning, d);\n+\t  /* Don't simply tsubst the function type, as that will give\n+\t     duplicate warnings about poor parameter qualifications.\n+\t     The function arguments are the same as the decl_arguments\n+\t     without the top level cv qualifiers. */\n+\t  type = TREE_TYPE (type);\n+\t}\n+      tsubst (type, args, tf_error | tf_warning, d);\n+    }\n+  \n   if (TREE_CODE (d) == VAR_DECL && DECL_INITIALIZED_IN_CLASS_P (d)\n       && DECL_INITIAL (d) == NULL_TREE)\n     /* We should have set up DECL_INITIAL in instantiate_class_template.  */"}, {"sha": "8b0a1984780cc11e9dbb7c144c750cc85b0ce45a", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 56, "deletions": 22, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2b0fb25ec488b47631bf988c8d099524caddb5/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2b0fb25ec488b47631bf988c8d099524caddb5/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=4f2b0fb25ec488b47631bf988c8d099524caddb5", "patch": "@@ -506,49 +506,83 @@ build_cplus_array_type (elt_type, index_type)\n /* Make a variant of TYPE, qualified with the TYPE_QUALS.  Handles\n    arrays correctly.  In particular, if TYPE is an array of T's, and\n    TYPE_QUALS is non-empty, returns an array of qualified T's.\n-   Errors are emitted under control of COMPLAIN. If COMPLAIN is zero,\n-   error_mark_node is returned for bad qualifiers.  */\n-\n+  \n+   FLAGS determines how to deal with illformed qualifications. If\n+   tf_ignore_bad_quals is set, then bad qualifications are dropped\n+   (this is permitted if TYPE was introduced via a typedef or template\n+   type parameter). If bad qualifications are dropped and tf_warning\n+   is set, then a warning is issued for non-const qualifications.  If\n+   tf_ignore_bad_quals is not set and tf_error is not set, we\n+   return error_mark_node. Otherwise, we issue an error, and ignore\n+   the qualifications.\n+\n+   Qualification of a reference type is valid when the reference came\n+   via a typedef or template type argument. [dcl.ref] No such\n+   dispensation is provided for qualifying a function type.  [dcl.fct]\n+   DR 295 queries this and the proposed resolution brings it into line\n+   with qualifiying a reference.  We implement the DR.  We also behave\n+   in a similar manner for restricting non-pointer types.  */\n+ \n tree\n cp_build_qualified_type_real (type, type_quals, complain)\n      tree type;\n      int type_quals;\n      tsubst_flags_t complain;\n {\n   tree result;\n+  int bad_quals = TYPE_UNQUALIFIED;\n \n   if (type == error_mark_node)\n     return type;\n \n   if (type_quals == cp_type_quals (type))\n     return type;\n \n-  /* A restrict-qualified pointer type must be a pointer (or reference)\n+  /* A reference, fucntion or method type shall not be cv qualified.\n+     [dcl.ref], [dct.fct]  */\n+  if (type_quals & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE)\n+      && (TREE_CODE (type) == REFERENCE_TYPE\n+\t  || TREE_CODE (type) == FUNCTION_TYPE\n+\t  || TREE_CODE (type) == METHOD_TYPE))\n+    {\n+      bad_quals |= type_quals & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE);\n+      type_quals &= ~(TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE);\n+    }\n+  \n+  /* A restrict-qualified type must be a pointer (or reference)\n      to object or incomplete type.  */\n   if ((type_quals & TYPE_QUAL_RESTRICT)\n       && TREE_CODE (type) != TEMPLATE_TYPE_PARM\n-      && (!POINTER_TYPE_P (type)\n-\t  || TYPE_PTRMEM_P (type)\n-\t  || TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE))\n+      && TREE_CODE (type) != TYPENAME_TYPE\n+      && !POINTER_TYPE_P (type))\n     {\n-      if (complain & tf_error)\n-\terror (\"`%T' cannot be `restrict'-qualified\", type);\n-      else\n-\treturn error_mark_node;\n-\n+      bad_quals |= TYPE_QUAL_RESTRICT;\n       type_quals &= ~TYPE_QUAL_RESTRICT;\n     }\n \n-  if (type_quals != TYPE_UNQUALIFIED\n-      && TREE_CODE (type) == FUNCTION_TYPE)\n+  if (bad_quals == TYPE_UNQUALIFIED)\n+    /*OK*/;\n+  else if (!(complain & (tf_error | tf_ignore_bad_quals)))\n+    return error_mark_node;\n+  else\n     {\n-      if (complain & tf_error)\n-\terror (\"`%T' cannot be `const'-, `volatile'-, or `restrict'-qualified\", type);\n-      else\n-\treturn error_mark_node;\n-      type_quals = TYPE_UNQUALIFIED;\n+      if (complain & tf_ignore_bad_quals)\n+ \t/* We're not going to warn about constifying things that can't\n+ \t   be constified.  */\n+ \tbad_quals &= ~TYPE_QUAL_CONST;\n+      if (bad_quals)\n+ \t{\n+ \t  tree bad_type = build_qualified_type (ptr_type_node, bad_quals);\n+ \n+ \t  if (!(complain & tf_ignore_bad_quals))\n+ \t    error (\"`%V' qualifiers cannot be applied to `%T'\",\n+\t\t   bad_type, type);\n+ \t  else if (complain & tf_warning)\n+ \t    warning (\"ignoring `%V' qualifiers on `%T'\", bad_type, type);\n+ \t}\n     }\n-  else if (TREE_CODE (type) == ARRAY_TYPE)\n+  \n+  if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       /* In C++, the qualification really applies to the array element\n \t type.  Obtain the appropriately qualified element type.  */\n@@ -590,15 +624,15 @@ cp_build_qualified_type_real (type, type_quals, complain)\n     {\n       /* For a pointer-to-member type, we can't just return a\n \t cv-qualified version of the RECORD_TYPE.  If we do, we\n-\t haven't change the field that contains the actual pointer to\n+\t haven't changed the field that contains the actual pointer to\n \t a method, and so TYPE_PTRMEMFUNC_FN_TYPE will be wrong.  */\n       tree t;\n \n       t = TYPE_PTRMEMFUNC_FN_TYPE (type);\n       t = cp_build_qualified_type_real (t, type_quals, complain);\n       return build_ptrmemfunc_type (t);\n     }\n-\n+  \n   /* Retrieve (or create) the appropriately qualified variant.  */\n   result = build_qualified_type (type, type_quals);\n "}, {"sha": "6785c5333dffa4442fa326831b06c97732187279", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2b0fb25ec488b47631bf988c8d099524caddb5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2b0fb25ec488b47631bf988c8d099524caddb5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4f2b0fb25ec488b47631bf988c8d099524caddb5", "patch": "@@ -1,3 +1,10 @@\n+2002-02-22  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* g++.dg/template/qualttp19.C: New test.\n+\t* g++.dg/template/qualttp20.C: New test.\n+\t* g++.old-deja/g++.jason/report.C: Adjust expected errors\n+\t* g++.old-deja/g++.other/qual1.C: Likewise.\n+\n 2002-02-21  Aldy Hernandez  <aldyh@redhat.com>\n \n         * gcc.dg/attr-alwaysinline.c: New."}, {"sha": "be6676cc592e2646646c55116a750313948d0a27", "filename": "gcc/testsuite/g++.dg/template/qualttp19.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2b0fb25ec488b47631bf988c8d099524caddb5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fqualttp19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2b0fb25ec488b47631bf988c8d099524caddb5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fqualttp19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fqualttp19.C?ref=4f2b0fb25ec488b47631bf988c8d099524caddb5", "patch": "@@ -0,0 +1,41 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 15 Dec 2001 <nathan@codesourcery.com>\n+\n+// PR 2645\n+\n+template <typename T>\n+struct call_traits\n+{\n+  public:\n+  typedef T type_less_spec;\n+};\n+\n+template <typename T>\n+struct call_traits<T&>\n+{\n+  typedef T type_more_spec;\n+};\n+\n+\n+int main()\n+{\n+  int num;\n+  \n+   // Two typedefs lead to the instant. of the less spec. (\"wrong\") template\n+  typedef int& r_type;\n+  typedef const r_type cr_type;\n+  call_traits<cr_type>::type_less_spec var  = num; // { dg-error \"\" \"\" }\n+  \n+   // The explicit type leads to the instantiation of the \"correct\" one\n+  call_traits<const int&>::type_more_spec var2 = num;\n+  \n+   // As happen with a single typedef!\n+  typedef const int& std_cr_type;\n+  call_traits<std_cr_type>::type_more_spec var3 = num;\n+  \n+  \n+   // As happen, indeed, without the cv-qualifier\n+  call_traits<r_type>::type_more_spec var4;\n+}"}, {"sha": "2c6c71445c98f3e3c1fadcb55c4baeafa8941e4f", "filename": "gcc/testsuite/g++.dg/template/qualttp20.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2b0fb25ec488b47631bf988c8d099524caddb5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fqualttp20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2b0fb25ec488b47631bf988c8d099524caddb5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fqualttp20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fqualttp20.C?ref=4f2b0fb25ec488b47631bf988c8d099524caddb5", "patch": "@@ -0,0 +1,33 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 15 Dec 2001 <nathan@codesourcery.com>\n+\n+// PR 2645\n+\n+struct AS\n+{\n+  typedef void (myT) ();\n+  struct L {};\n+  \n+};\n+\n+\n+template <typename T> struct B1 : T\n+{\n+  typedef typename T::L __restrict__ r;// { dg-error \"`__restrict' qualifiers cannot\" \"\" }\n+  typedef typename T::myT __restrict__ p;// { dg-warning \"ignoring `__restrict'\" \"\" }\n+  \n+  typedef typename T::myT volatile *myvolatile; // { dg-warning \"ignoring `volatile'\" \"\" }\n+  typename T::myT volatile *a;    // { dg-warning \"ignoring `volatile'\" \"\" }\n+  myvolatile b;\t\t\t // { dg-bogus \"ignoring `volatile'\" \"\" { xfail *-*-* } }\n+};\n+template <typename T> struct B2 : T\n+{\n+  typedef typename T::myT const *myconst;\n+  typename T::myT const *a;\n+  myconst b;\n+};\n+\n+B1<AS> b1;\t// { dg-error \"instantiated\" \"\" }\n+B2<AS> b2;"}, {"sha": "14bc9d84402ed00bf127891d36c90e53fe6de32d", "filename": "gcc/testsuite/g++.old-deja/g++.jason/report.C", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2b0fb25ec488b47631bf988c8d099524caddb5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Freport.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2b0fb25ec488b47631bf988c8d099524caddb5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Freport.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Freport.C?ref=4f2b0fb25ec488b47631bf988c8d099524caddb5", "patch": "@@ -2,6 +2,8 @@\n // GROUPS passed error-reporting\n // Special g++ Options: -Wreturn-type\n \n+// DR 295 allows qualification via typedef\n+\n template <char C>\n class badoo\n {\n@@ -44,7 +46,8 @@ class X{\n };\n \n typedef int const * bart ();\n-typedef bart const * const * bar2; // ERROR - qualifiers\n+typedef bart const * const * bar2; // ok - constifying qualifiers\n+typedef bart volatile * const * bar2v; // WARNING - qualifiers\n \n bar2 baz (X::Y y)\n {\t\t\t\t// ERROR - in this context"}, {"sha": "fa2d33f2ce885987712f0c35345ba1288eb7a8ca", "filename": "gcc/testsuite/g++.old-deja/g++.other/qual1.C", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2b0fb25ec488b47631bf988c8d099524caddb5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fqual1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2b0fb25ec488b47631bf988c8d099524caddb5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fqual1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fqual1.C?ref=4f2b0fb25ec488b47631bf988c8d099524caddb5", "patch": "@@ -2,13 +2,16 @@\n // Origin: Benjamin Pflugmann <philemon@spin.de>\n // Special g++ Options: -O\n \n+// DR 295 allows qualification via typedef\n+\n typedef const char *(func_type)();\n \n class\n {\n public:\n   func_type *Function;\n-  const func_type* function(void) { return Function; } // ERROR - qualifiers\n+  const func_type* function(void) { return Function; } // ok constifying\n+  volatile func_type* functionv(void); // WARNING - qualifier\n } action;\n \n void work(const char *source)"}]}