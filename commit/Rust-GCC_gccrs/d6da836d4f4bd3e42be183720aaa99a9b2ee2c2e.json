{"sha": "d6da836d4f4bd3e42be183720aaa99a9b2ee2c2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZkYTgzNmQ0ZjRiZDNlNDJiZTE4MzcyMGFhYTk5YTliMmVlMmMyZQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-10-08T06:15:14Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-10-08T06:15:14Z"}, "message": "cppmacro.c (funlike_invocation_p): Move some logic to caller in enter_macro_context.\n\n\t* cppmacro.c (funlike_invocation_p): Move some logic to caller\n\tin enter_macro_context.  Create a padding token in its own context\n\tif necessary when the search for '(' fails.\n\t(enter_macro_context): Update.\n\n\t* gcc.dg/cpp/spacing1.c: Update test.\n\nFrom-SVN: r46070", "tree": {"sha": "7d4b34e55a9e313e9c00a7b31d4e151100a9a176", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d4b34e55a9e313e9c00a7b31d4e151100a9a176"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6da836d4f4bd3e42be183720aaa99a9b2ee2c2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6da836d4f4bd3e42be183720aaa99a9b2ee2c2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6da836d4f4bd3e42be183720aaa99a9b2ee2c2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6da836d4f4bd3e42be183720aaa99a9b2ee2c2e/comments", "author": null, "committer": null, "parents": [{"sha": "7f8fa05daed1a59589d41a1edbe7db47825c57c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f8fa05daed1a59589d41a1edbe7db47825c57c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f8fa05daed1a59589d41a1edbe7db47825c57c0"}], "stats": {"total": 107, "additions": 73, "deletions": 34}, "files": [{"sha": "559df72d18ffd5f9d967f934b9eebdfcd0851abd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6da836d4f4bd3e42be183720aaa99a9b2ee2c2e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6da836d4f4bd3e42be183720aaa99a9b2ee2c2e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d6da836d4f4bd3e42be183720aaa99a9b2ee2c2e", "patch": "@@ -1,3 +1,10 @@\n+2001-10-08  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cppmacro.c (funlike_invocation_p): Move some logic to caller\n+\tin enter_macro_context.  Create a padding token in its own context\n+\tif necessary when the search for '(' fails.\n+\t(enter_macro_context): Update.\n+\n 2001-10-07  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* ChangeLog.2, c-decl.c, config/i386/i386.md, doc/gcc.texi, gcc.c,"}, {"sha": "221682e97d774841aa03fbb69b7102381699b0ef", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 51, "deletions": 32, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6da836d4f4bd3e42be183720aaa99a9b2ee2c2e/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6da836d4f4bd3e42be183720aaa99a9b2ee2c2e/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=d6da836d4f4bd3e42be183720aaa99a9b2ee2c2e", "patch": "@@ -75,8 +75,8 @@ static const cpp_token *stringify_arg PARAMS ((cpp_reader *, macro_arg *));\n static void paste_all_tokens PARAMS ((cpp_reader *, const cpp_token *));\n static bool paste_tokens PARAMS ((cpp_reader *, const cpp_token **,\n \t\t\t\t  const cpp_token *));\n-static int funlike_invocation_p PARAMS ((cpp_reader *, cpp_hashnode *));\n static void replace_args PARAMS ((cpp_reader *, cpp_hashnode *, macro_arg *));\n+static _cpp_buff *funlike_invocation_p PARAMS ((cpp_reader *, cpp_hashnode *));\n \n /* #define directive parsing and handling.  */\n \n@@ -616,46 +616,41 @@ collect_args (pfile, node)\n   return NULL;\n }\n \n-static int\n+/* Search for an opening parenthesis to the macro of NODE, in such a\n+   way that, if none is found, we don't lose the information in any\n+   intervening padding tokens.  If we find the parenthesis, collect\n+   the arguments and return the buffer containing them.  */\n+static _cpp_buff *\n funlike_invocation_p (pfile, node)\n      cpp_reader *pfile;\n      cpp_hashnode *node;\n {\n-  const cpp_token *maybe_paren;\n-  _cpp_buff *buff = NULL;\n+  const cpp_token *token, *padding = NULL;\n \n-  pfile->state.prevent_expansion++;\n-  pfile->keep_tokens++;\n-\n-  pfile->state.parsing_args = 1;\n-  do\n-    maybe_paren = cpp_get_token (pfile);\n-  while (maybe_paren->type == CPP_PADDING);\n-  pfile->state.parsing_args = 2;\n-\n-  if (maybe_paren->type == CPP_OPEN_PAREN)\n-    buff = collect_args (pfile, node);\n-  else\n+  for (;;)\n     {\n-      _cpp_backup_tokens (pfile, 1);\n-      if (CPP_WTRADITIONAL (pfile) && ! node->value.macro->syshdr)\n-\tcpp_warning (pfile,\n- \"function-like macro \\\"%s\\\" must be used with arguments in traditional C\",\n-\t\t     NODE_NAME (node));\n+      token = cpp_get_token (pfile);\n+      if (token->type != CPP_PADDING)\n+\tbreak;\n+      if (padding == NULL\n+\t  || (!(padding->flags & PREV_WHITE) && token->val.source == NULL))\n+\tpadding = token;\n     }\n \n-  pfile->state.parsing_args = 0;\n-  pfile->keep_tokens--;\n-  pfile->state.prevent_expansion--;\n-\n-  if (buff)\n+  if (token->type == CPP_OPEN_PAREN)\n     {\n-      if (node->value.macro->paramc > 0)\n-\treplace_args (pfile, node, (macro_arg *) buff->base);\n-      _cpp_release_buff (pfile, buff);\n+      pfile->state.parsing_args = 2;\n+      return collect_args (pfile, node);\n     }\n \n-  return buff != 0;\n+  /* Back up.  We may have skipped padding, in which case backing up\n+     more than one token when expanding macros is in general too\n+     difficult.  We re-insert it in its own context.  */\n+  _cpp_backup_tokens (pfile, 1);\n+  if (padding)\n+    push_token_context (pfile, NULL, padding, 1);\n+\n+  return NULL;\n }\n \n /* Push the context of a macro onto the context stack.  TOKEN is the\n@@ -675,8 +670,32 @@ enter_macro_context (pfile, node)\n     {\n       cpp_macro *macro = node->value.macro;\n \n-      if (macro->fun_like && !funlike_invocation_p (pfile, node))\n-\treturn 0;\n+      if (macro->fun_like)\n+\t{\n+\t  _cpp_buff *buff;\n+\n+\t  pfile->state.prevent_expansion++;\n+\t  pfile->keep_tokens++;\n+\t  pfile->state.parsing_args = 1;\n+\t  buff = funlike_invocation_p (pfile, node);\n+\t  pfile->state.parsing_args = 0;\n+\t  pfile->keep_tokens--;\n+\t  pfile->state.prevent_expansion--;\n+\n+\t  if (buff == NULL)\n+\t    {\n+\t      if (CPP_WTRADITIONAL (pfile) && ! node->value.macro->syshdr)\n+\t\tcpp_warning (pfile,\n+ \"function-like macro \\\"%s\\\" must be used with arguments in traditional C\",\n+\t\t\t     NODE_NAME (node));\n+\n+\t      return 0;\n+\t    }\n+\n+\t  if (node->value.macro->paramc > 0)\n+\t    replace_args (pfile, node, (macro_arg *) buff->base);\n+\t  _cpp_release_buff (pfile, buff);\n+\t}\n \n       /* Disable the macro within its expansion.  */\n       node->flags |= NODE_DISABLED;"}, {"sha": "a314286409d3fe88123eab5893e0110ae2e26bfb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6da836d4f4bd3e42be183720aaa99a9b2ee2c2e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6da836d4f4bd3e42be183720aaa99a9b2ee2c2e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d6da836d4f4bd3e42be183720aaa99a9b2ee2c2e", "patch": "@@ -1,3 +1,7 @@\n+2001-10-08  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* gcc.dg/cpp/spacing1.c: Update test.\n+\n 2001-10-07  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* gcc.c-torture/unsorted/unsorted.exp, lib/file-format.exp: Fix"}, {"sha": "ad1af4e91c71392d514c36e529f91fa0e3b0239d", "filename": "gcc/testsuite/gcc.dg/cpp/spacing1.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6da836d4f4bd3e42be183720aaa99a9b2ee2c2e/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fspacing1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6da836d4f4bd3e42be183720aaa99a9b2ee2c2e/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fspacing1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fspacing1.c?ref=d6da836d4f4bd3e42be183720aaa99a9b2ee2c2e", "patch": "@@ -14,18 +14,26 @@\n #define f(x) x\n #define glue(x, y) x ## y\n #define EMPTY\n+/* These are based on PR 4492, we mustn't lose padding tokens when\n+   scanning ahead for a '(' and failing to find it.  */\n+#define A(x) B x\n+#define B(x)\n+#define C A\n+#define D() A\n \n /* The correct output is shown here.  Note the spaces, and the way\n    everything after the invocation of f appears on the same line.\n \n  44 ;\n+B Q B Q A Q A:\n f\n bar\n g \"1 2\" bam baz\n \n */\n \n glue (EMPTY 4, 4) EMPTY;\n+A(Q) C(Q) D()Q D():\n f\n bar\n f (g) str\n@@ -37,10 +45,11 @@ f (g) str\n \n /*\n    { dg-final { if ![file exists spacing1.i] { return }                   } }\n-   { dg-final { if \\{ [grep spacing1.i \" 44 ;\"] != \"\" \\}  \\{              } }\n+   { dg-final { if \\{ [grep spacing1.i \" 44 ;\"] != \"\" \\}              \\{  } }\n+   { dg-final { if \\{ [grep spacing1.i \"B Q B Q A Q A:\"] != \"\" \\}     \\{  } }\n    { dg-final { if \\{ [grep spacing1.i \"f.*bar\"] == \"\" \\} \\{              } }\n    { dg-final { if \\{ [grep spacing1.i \"^bar\"] != \"\" \\}   \\{              } }\n    { dg-final { if \\{ [grep spacing1.i \"g \\\"1 2\\\" bam baz\"] != \"\" \\} \\{   } }\n-   { dg-final { return \\} \\} \\} \\}                                        } }\n+   { dg-final { return \\} \\} \\} \\} \\}                                     } }\n    { dg-final { fail \"spacing1.c: spacing and new-line preservation\"      } }\n */"}]}