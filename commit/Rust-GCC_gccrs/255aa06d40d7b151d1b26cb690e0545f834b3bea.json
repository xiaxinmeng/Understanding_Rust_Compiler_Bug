{"sha": "255aa06d40d7b151d1b26cb690e0545f834b3bea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjU1YWEwNmQ0MGQ3YjE1MWQxYjI2Y2I2OTBlMDU0NWY4MzRiM2JlYQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-10-05T13:36:38Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-10-05T13:39:10Z"}, "message": "c++: Make spell corrections consistent\n\nMy change to namespace-scope spell corrections ignored the issue that\ndifferent targets might have different builtins, and therefore perturb\niteration order.  This fixes it by using an intermediate array of\nidentifier, which we sort before considering.\n\n\tgcc/cp/\n\t* name-lookup.c (maybe_add_fuzzy_decl): New.\n\t(maybe_add_fuzzy_binding): New.\n\t(consider_binding_level): Use intermediate sortable vector for\n\tnamespace bindings.\n\tgcc/testsuite/\n\t* c-c++-common/spellcheck-reserved.c: Restore diagnostic.", "tree": {"sha": "4b4cea6517eef8932ca814464454c8c0a88a0813", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b4cea6517eef8932ca814464454c8c0a88a0813"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/255aa06d40d7b151d1b26cb690e0545f834b3bea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/255aa06d40d7b151d1b26cb690e0545f834b3bea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/255aa06d40d7b151d1b26cb690e0545f834b3bea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/255aa06d40d7b151d1b26cb690e0545f834b3bea/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf490f0636052040cfe1b3882475ac9a0e0337df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf490f0636052040cfe1b3882475ac9a0e0337df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf490f0636052040cfe1b3882475ac9a0e0337df"}], "stats": {"total": 118, "additions": 94, "deletions": 24}, "files": [{"sha": "774c4473390b29d35dc44438912b621dbe6abdcf", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 93, "deletions": 23, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/255aa06d40d7b151d1b26cb690e0545f834b3bea/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/255aa06d40d7b151d1b26cb690e0545f834b3bea/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=255aa06d40d7b151d1b26cb690e0545f834b3bea", "patch": "@@ -6077,6 +6077,9 @@ qualified_namespace_lookup (tree scope, name_lookup *lookup)\n   return found;\n }\n \n+/* If DECL is suitably visible to the user, consider its name for\n+   spelling correction.  */\n+\n static void\n consider_decl (tree decl,  best_match <tree, const char *> &bm,\n \t       bool consider_impl_names)\n@@ -6110,6 +6113,65 @@ consider_decl (tree decl,  best_match <tree, const char *> &bm,\n   bm.consider (suggestion_str);\n }\n \n+/* If DECL is suitably visible to the user, add its name to VEC and\n+   return true.  Otherwise return false.  */\n+\n+static bool\n+maybe_add_fuzzy_decl (auto_vec<tree> &vec, tree decl)\n+{\n+  /* Skip compiler-generated variables (e.g. __for_begin/__for_end\n+     within range for).  */\n+  if (TREE_CODE (decl) == VAR_DECL && DECL_ARTIFICIAL (decl))\n+    return false;\n+\n+  tree suggestion = DECL_NAME (decl);\n+  if (!suggestion)\n+    return false;\n+\n+  /* Don't suggest names that are for anonymous aggregate types, as\n+     they are an implementation detail generated by the compiler.  */\n+  if (IDENTIFIER_ANON_P (suggestion))\n+    return false;\n+\n+  vec.safe_push (suggestion);\n+\n+  return true;\n+}\n+\n+/* Examing the namespace binding BINDING, and add at most one instance\n+   of the name, if it contains a visible entity of interest.  */\n+\n+void\n+maybe_add_fuzzy_binding (auto_vec<tree> &vec, tree binding,\n+\t\t\t      lookup_name_fuzzy_kind kind)\n+{\n+  tree value = NULL_TREE;\n+\n+  if (STAT_HACK_P (binding))\n+    {\n+      if (!STAT_TYPE_HIDDEN_P (binding)\n+\t  && STAT_TYPE (binding))\n+\t{\n+\t  if (maybe_add_fuzzy_decl (vec, STAT_TYPE (binding)))\n+\t    return;\n+\t}\n+      else if (!STAT_DECL_HIDDEN_P (binding))\n+\tvalue = STAT_DECL (binding);\n+    }\n+  else\n+    value = binding;\n+\n+  value = ovl_skip_hidden (value);\n+  if (value)\n+    {\n+      value = OVL_FIRST (value);\n+      if (kind != FUZZY_LOOKUP_TYPENAME\n+\t  || TREE_CODE (STRIP_TEMPLATE (value)) == TYPE_DECL)\n+\tif (maybe_add_fuzzy_decl (vec, value))\n+\t  return;\n+    }\n+}\n+\n /* Helper function for lookup_name_fuzzy.\n    Traverse binding level LVL, looking for good name matches for NAME\n    (and BM).  */\n@@ -6157,38 +6219,46 @@ consider_binding_level (tree name, best_match <tree, const char *> &bm,\n       }\n   else\n     {\n-      /* Iterate over the namespace hash table, that'll have fewer\n-\t entries than the decl list.  */\n+      /* We need to iterate over the namespace hash table, in order to\n+         not mention hidden entities.  But hash table iteration is\n+         (essentially) unpredictable, our correction-distance measure\n+         is very granular, and we pick the first of equal distances.\n+         Hence, we need to call the distance-measurer in a predictable\n+         order.  So, iterate over the namespace hash, inserting\n+         visible names into a vector.  Then sort the vector.  Then\n+         determine spelling distance.  */\n+      \n       tree ns = lvl->this_entity;\n+      auto_vec<tree> vec;\n \n       hash_table<named_decl_hash>::iterator end\n \t(DECL_NAMESPACE_BINDINGS (ns)->end ());\n       for (hash_table<named_decl_hash>::iterator iter\n \t     (DECL_NAMESPACE_BINDINGS (ns)->begin ()); iter != end; ++iter)\n+\tmaybe_add_fuzzy_binding (vec, *iter, kind);\n+\n+      vec.qsort ([] (const void *a_, const void *b_)\n+\t\t {\n+\t\t   return strcmp (IDENTIFIER_POINTER (*(const tree *)a_),\n+\t\t\t\t  IDENTIFIER_POINTER (*(const tree *)b_));\n+\t\t });\n+\n+      /* Examine longest to shortest.  */\n+      for (unsigned ix = vec.length (); ix--;)\n \t{\n-\t  tree binding = *iter;\n-\t  tree value = NULL_TREE;\n+\t  const char *str = IDENTIFIER_POINTER (vec[ix]);\n \n-\t  if (STAT_HACK_P (binding))\n-\t    {\n-\t      if (!STAT_TYPE_HIDDEN_P (binding)\n-\t\t  && STAT_TYPE (binding))\n-\t\tconsider_decl (STAT_TYPE (binding), bm,\n-\t\t\t       consider_implementation_names);\n-\t      else if (!STAT_DECL_HIDDEN_P (binding))\n-\t\tvalue = STAT_DECL (binding);\n-\t    }\n-\t  else\n-\t    value = binding;\n+\t  /* Ignore internal names with spaces in them.  */\n+\t  if (strchr (str, ' '))\n+\t    continue;\n \t  \n-\t  value = ovl_skip_hidden (value);\n-\t  if (value)\n-\t    {\n-\t      value = OVL_FIRST (value);\n-\t      if (!(kind == FUZZY_LOOKUP_TYPENAME\n-\t\t    && TREE_CODE (STRIP_TEMPLATE (value)) != TYPE_DECL))\n-\t\tconsider_decl (value, bm, consider_implementation_names);\n-\t    }\n+\t  /* Don't suggest names that are reserved for use by the\n+\t     implementation, unless NAME began with an underscore.  */\n+\t  if (!consider_implementation_names\n+\t      && name_reserved_for_implementation_p (str))\n+\t    continue;\n+\n+\t  bm.consider (str);\n \t}\n     }\n }"}, {"sha": "ed292f2bae0f3ef6a9f2cd092605199a1e880907", "filename": "gcc/testsuite/c-c++-common/spellcheck-reserved.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/255aa06d40d7b151d1b26cb690e0545f834b3bea/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fspellcheck-reserved.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/255aa06d40d7b151d1b26cb690e0545f834b3bea/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fspellcheck-reserved.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fspellcheck-reserved.c?ref=255aa06d40d7b151d1b26cb690e0545f834b3bea", "patch": "@@ -30,7 +30,7 @@ void test (const char *buf, char ch)\n {\n   __builtin_strtchr (buf, ch); /* { dg-line misspelled_reserved } */\n   /* { dg-warning \"did you mean '__builtin_strchr'\" \"\" { target c } misspelled_reserved } */\n-  /* { dg-error \"'__builtin_strtchr' was not declared in this scope; did you mean '__builtin_strchr'\\\\?\" \"\" { target c++ } misspelled_reserved } */\n+  /* { dg-error \"'__builtin_strtchr' was not declared in this scope; did you mean '__builtin_strrchr'\\\\?\" \"\" { target c++ } misspelled_reserved } */\n }\n \n /* Similarly for a name that begins with a single underscore.  */"}]}