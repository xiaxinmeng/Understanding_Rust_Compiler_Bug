{"sha": "55dfce4d5cb4a366ced7e1194a1c7f04389e3087", "node_id": "C_kwDOANBUbNoAKDU1ZGZjZTRkNWNiNGEzNjZjZWQ3ZTExOTRhMWM3ZjA0Mzg5ZTMwODc", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-12-04T10:00:09Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-12-04T10:00:09Z"}, "message": "libcpp: Fix up handling of deferred pragmas [PR102432]\n\nThe https://gcc.gnu.org/pipermail/gcc-patches/2020-November/557903.html\nchange broke the following testcases.  The problem is when a pragma\nnamespace allows expansion (i.e. p->is_nspace && p->allow_expansion),\ne.g. the omp or acc namespaces do, then when parsing the second pragma\ntoken we do it with pfile->state.in_directive set,\npfile->state.prevent_expansion clear and pfile->state.in_deferred_pragma\nclear (the last one because we don't know yet if it will be a deferred\npragma or not).  If the pragma line only contains a single name\nand newline after it, and there exists a function-like macro with the\nsame name, the preprocessor needs to peek in funlike_invocation_p\nthe next token whether it isn't ( but in this case it will see a newline.\nAs pfile->state.in_directive is set, we don't read anything after the\nnewline, pfile->buffer->need_line is set and CPP_EOF is lexed, which\nfunlike_invocation_p doesn't push back.  Because name is a function-like\nmacro and on the pragma line there is no ( after the name, it isn't\nexpanded, and control flow returns to do_pragma.  If name is valid\ndeferred pragma, we set pfile->state.in_deferred_pragma (and really\nneed it set so that e.g. end_directive later on doesn't eat all the\ntokens from the pragma line).\n\nBefore Nathan's change (which unfortunately didn't contain rationale\non why it is better to do it like that), this wasn't a problem,\nnext _cpp_lex_direct called when we want next token would return\nCPP_PRAGMA_EOF when it saw buffer->need_line, which would turn off\npfile->state.in_deferred_pragma and following get token would already\nread the next line.  But Nathan's patch replaced it with an assertion\nfailure that now triggers and CPP_PRAGMA_EOL is done only when lexing\nthe '\\n'.  Except for this special case that works fine, but in\nthis case it doesn't because when peeking the token we still didn't know\nthat it will be a deferred pragma.\nI've tried to fix that up in do_pragma by detecting this and pushing\nCPP_PRAGMA_EOL as lookahead, but that doesn't work because end_directive\nstill needs to see pfile->state.in_deferred_pragma set.\n\nSo, this patch affectively reverts part of Nathan's change, CPP_PRAGMA_EOL\naddition isn't done only when parsing the '\\n', but is now done in both\nplaces, in the first one instead of the assertion failure.\n\n2021-12-04  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR preprocessor/102432\n\t* lex.c (_cpp_lex_direct): If buffer->need_line while\n\tpfile->state.in_deferred_pragma, return CPP_PRAGMA_EOL token instead\n\tof assertion failure.\n\n\t* c-c++-common/gomp/pr102432.c: New test.\n\t* c-c++-common/goacc/pr102432.c: New test.", "tree": {"sha": "c593b17ab5e599f784c2855fa4b11b91f2646e84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c593b17ab5e599f784c2855fa4b11b91f2646e84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55dfce4d5cb4a366ced7e1194a1c7f04389e3087", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55dfce4d5cb4a366ced7e1194a1c7f04389e3087", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55dfce4d5cb4a366ced7e1194a1c7f04389e3087", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55dfce4d5cb4a366ced7e1194a1c7f04389e3087/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "daca416fc2816a5e481b26c8d2010127101d77ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daca416fc2816a5e481b26c8d2010127101d77ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/daca416fc2816a5e481b26c8d2010127101d77ce"}], "stats": {"total": 62, "additions": 61, "deletions": 1}, "files": [{"sha": "97450f30cf16496638e7f85e9cd1b13f1c91a647", "filename": "gcc/testsuite/c-c++-common/goacc/pr102432.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55dfce4d5cb4a366ced7e1194a1c7f04389e3087/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fpr102432.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55dfce4d5cb4a366ced7e1194a1c7f04389e3087/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fpr102432.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fpr102432.c?ref=55dfce4d5cb4a366ced7e1194a1c7f04389e3087", "patch": "@@ -0,0 +1,23 @@\n+/* PR preprocessor/102432 */\n+\n+#define loop(x)\n+\n+void\n+foo (void)\n+{\n+  int i;\n+#pragma acc parallel\n+#pragma acc loop\n+  for (i = 0; i < 64; i++)\n+    ;\n+}\n+\n+void\n+bar (void)\n+{\n+  int i;\n+  _Pragma (\"acc parallel\")\n+  _Pragma (\"acc loop\")\n+  for (i = 0; i < 64; i++)\n+    ;\n+}"}, {"sha": "89b0f6d45b08eca799685a4630c0253fdccb5430", "filename": "gcc/testsuite/c-c++-common/gomp/pr102432.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55dfce4d5cb4a366ced7e1194a1c7f04389e3087/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr102432.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55dfce4d5cb4a366ced7e1194a1c7f04389e3087/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr102432.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr102432.c?ref=55dfce4d5cb4a366ced7e1194a1c7f04389e3087", "patch": "@@ -0,0 +1,23 @@\n+/* PR preprocessor/102432 */\n+\n+#define loop(x)\n+\n+void\n+foo (void)\n+{\n+  int i;\n+#pragma omp parallel\n+#pragma omp loop\n+  for (i = 0; i < 64; i++)\n+    ;\n+}\n+\n+void\n+bar (void)\n+{\n+  int i;\n+  _Pragma (\"omp parallel\")\n+  _Pragma (\"omp loop\")\n+  for (i = 0; i < 64; i++)\n+    ;\n+}"}, {"sha": "49071743533fbf3866e87fb59d194d8f0b0f239b", "filename": "libcpp/lex.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55dfce4d5cb4a366ced7e1194a1c7f04389e3087/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55dfce4d5cb4a366ced7e1194a1c7f04389e3087/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=55dfce4d5cb4a366ced7e1194a1c7f04389e3087", "patch": "@@ -3530,7 +3530,21 @@ _cpp_lex_direct (cpp_reader *pfile)\n   buffer = pfile->buffer;\n   if (buffer->need_line)\n     {\n-      gcc_assert (!pfile->state.in_deferred_pragma);\n+      if (pfile->state.in_deferred_pragma)\n+\t{\n+\t  /* This can happen in cases like:\n+\t     #define loop(x) whatever\n+\t     #pragma omp loop\n+\t     where when trying to expand loop we need to peek\n+\t     next token after loop, but aren't still in_deferred_pragma\n+\t     mode but are in in_directive mode, so buffer->need_line\n+\t     is set, a CPP_EOF is peeked.  */\n+\t  result->type = CPP_PRAGMA_EOL;\n+\t  pfile->state.in_deferred_pragma = false;\n+\t  if (!pfile->state.pragma_allow_expansion)\n+\t    pfile->state.prevent_expansion--;\n+\t  return result;\n+\t}\n       if (!_cpp_get_fresh_line (pfile))\n \t{\n \t  result->type = CPP_EOF;"}]}