{"sha": "e654c19ec15e3359db67bf8e3da9f9932fe7331c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY1NGMxOWVjMTVlMzM1OWRiNjdiZjhlM2RhOWY5OTMyZmU3MzMxYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2004-03-04T02:04:15Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2004-03-04T02:04:15Z"}, "message": "cselib.c (cselib_finish): Fix another miss-application of my previous patch.\n\n\t* cselib.c (cselib_finish): Fix another miss-application of my previous\n\tpatch.\n\nFrom-SVN: r78876", "tree": {"sha": "84453c86a6c6f2139b76f39fdf6c97d4c411545b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84453c86a6c6f2139b76f39fdf6c97d4c411545b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e654c19ec15e3359db67bf8e3da9f9932fe7331c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e654c19ec15e3359db67bf8e3da9f9932fe7331c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e654c19ec15e3359db67bf8e3da9f9932fe7331c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e654c19ec15e3359db67bf8e3da9f9932fe7331c/comments", "author": null, "committer": null, "parents": [{"sha": "94d1613b239ef411e8fd6e6e647d920149d1d272", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94d1613b239ef411e8fd6e6e647d920149d1d272", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94d1613b239ef411e8fd6e6e647d920149d1d272"}], "stats": {"total": 27, "additions": 22, "deletions": 5}, "files": [{"sha": "aea406efa610e870ee6b973691ff15df4fa94a7a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e654c19ec15e3359db67bf8e3da9f9932fe7331c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e654c19ec15e3359db67bf8e3da9f9932fe7331c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e654c19ec15e3359db67bf8e3da9f9932fe7331c", "patch": "@@ -1,3 +1,8 @@\n+2004-03-04  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cselib.c (cselib_finish): Fix another miss-application of my previous\n+\tpatch.\n+\n 2004-03-03  Mike Stump  <mrs@apple.com>\n \n \tAdd framework support for darwin."}, {"sha": "626ba47a84072731dec55dd8332568a93aa358a2", "filename": "gcc/cselib.c", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e654c19ec15e3359db67bf8e3da9f9932fe7331c/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e654c19ec15e3359db67bf8e3da9f9932fe7331c/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=e654c19ec15e3359db67bf8e3da9f9932fe7331c", "patch": "@@ -42,6 +42,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"params.h\"\n #include \"alloc-pool.h\"\n \n+static bool cselib_record_memory;\n static int entry_and_rtx_equal_p (const void *, const void *);\n static hashval_t get_value_hash (const void *);\n static struct elt_list *new_elt_list (struct elt_list *, cselib_val *);\n@@ -748,6 +749,7 @@ cselib_lookup_mem (rtx x, int create)\n   struct elt_list *l;\n \n   if (MEM_VOLATILE_P (x) || mode == BLKmode\n+      || !cselib_record_memory\n       || (FLOAT_MODE_P (mode) && flag_float_store))\n     return 0;\n \n@@ -1201,7 +1203,8 @@ cselib_record_set (rtx dest, cselib_val *src_elt, cselib_val *dest_addr_elt)\n \tn_useless_values--;\n       src_elt->locs = new_elt_loc_list (src_elt->locs, dest);\n     }\n-  else if (GET_CODE (dest) == MEM && dest_addr_elt != 0)\n+  else if (GET_CODE (dest) == MEM && dest_addr_elt != 0\n+\t   && cselib_record_memory)\n     {\n       if (src_elt->locs == 0)\n \tn_useless_values--;\n@@ -1275,7 +1278,8 @@ cselib_record_sets (rtx insn)\n \tsets[i].dest = dest = XEXP (dest, 0);\n \n       /* We don't know how to record anything but REG or MEM.  */\n-      if (GET_CODE (dest) == REG || GET_CODE (dest) == MEM)\n+      if (GET_CODE (dest) == REG\n+\t  || (GET_CODE (dest) == MEM && cselib_record_memory))\n         {\n \t  rtx src = sets[i].src;\n \t  if (cond)\n@@ -1320,7 +1324,8 @@ cselib_record_sets (rtx insn)\n   for (i = 0; i < n_sets; i++)\n     {\n       rtx dest = sets[i].dest;\n-      if (GET_CODE (dest) == REG || GET_CODE (dest) == MEM)\n+      if (GET_CODE (dest) == REG\n+\t  || (GET_CODE (dest) == MEM && cselib_record_memory))\n \tcselib_record_set (dest, sets[i].src_elt, sets[i].dest_addr_elt);\n     }\n }\n@@ -1394,12 +1399,16 @@ cselib_process_insn (rtx insn)\n     remove_useless_values ();\n }\n \n+static int initialized;\n /* Initialize cselib for one pass.  The caller must also call\n    init_alias_analysis.  */\n \n void\n-cselib_init (void)\n+cselib_init (bool record_memory)\n {\n+  if (initialized)\n+    abort ();\n+  initialized = 1;\n   elt_list_pool = create_alloc_pool (\"elt_list\", \n \t\t\t\t     sizeof (struct elt_list), 10);\n   elt_loc_list_pool = create_alloc_pool (\"elt_loc_list\", \n@@ -1408,6 +1417,7 @@ cselib_init (void)\n \t\t\t\t       sizeof (cselib_val), 10);\n   value_pool = create_alloc_pool (\"value\", \n \t\t\t\t  RTX_SIZE (VALUE), 100);\n+  cselib_record_memory = record_memory;\n   /* This is only created once.  */\n   if (! callmem)\n     callmem = gen_rtx_MEM (BLKmode, const0_rtx);\n@@ -1437,13 +1447,15 @@ cselib_init (void)\n void\n cselib_finish (void)\n {\n+  if (!initialized)\n+    abort ();\n+  initialized = 0;\n   free_alloc_pool (elt_list_pool);\n   free_alloc_pool (elt_loc_list_pool);\n   free_alloc_pool (cselib_val_pool);\n   free_alloc_pool (value_pool);\n   clear_table ();\n   htab_delete (hash_table);\n-  reg_values = 0;\n   free (used_regs);\n   used_regs = 0;\n   hash_table = 0;"}]}