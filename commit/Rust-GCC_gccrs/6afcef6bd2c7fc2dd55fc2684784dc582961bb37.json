{"sha": "6afcef6bd2c7fc2dd55fc2684784dc582961bb37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmFmY2VmNmJkMmM3ZmMyZGQ1NWZjMjY4NDc4NGRjNTgyOTYxYmIzNw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2002-03-18T00:09:37Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2002-03-18T00:09:37Z"}, "message": "re PR c++/4381 (Exceptions virtually inherited from a class cause segmentation fault at run time)\n\n        PR c++/4381\n        * libsupc++/eh_personality.cc (get_adjusted_ptr): New static fn.\n        (check_exception_spec): Call it.  Take the thrown pointer.\n        (__cxa_call_unexpected): Pass it.\n        (PERSONALITY_FUNCTION): Likewise.  Use get_adjusted_ptr.\n\nFrom-SVN: r50936", "tree": {"sha": "531869c61fb0a12c9731968ef268de1b009e1d6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/531869c61fb0a12c9731968ef268de1b009e1d6d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6afcef6bd2c7fc2dd55fc2684784dc582961bb37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6afcef6bd2c7fc2dd55fc2684784dc582961bb37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6afcef6bd2c7fc2dd55fc2684784dc582961bb37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6afcef6bd2c7fc2dd55fc2684784dc582961bb37/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "155038f242b4ebb90656547e852ad5b212b710ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/155038f242b4ebb90656547e852ad5b212b710ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/155038f242b4ebb90656547e852ad5b212b710ae"}], "stats": {"total": 94, "additions": 77, "deletions": 17}, "files": [{"sha": "20bcfc33ee84e004eb56ff2b13241809a121e387", "filename": "gcc/testsuite/g++.dg/eh/spec3.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6afcef6bd2c7fc2dd55fc2684784dc582961bb37/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fspec3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6afcef6bd2c7fc2dd55fc2684784dc582961bb37/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fspec3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fspec3.C?ref=6afcef6bd2c7fc2dd55fc2684784dc582961bb37", "patch": "@@ -0,0 +1,24 @@\n+// PR c++/4381\n+// Test that exception-specs work properly for classes with virtual bases.\n+\n+// { dg-do run }\n+\n+class Base {};\n+\n+struct A : virtual public Base\n+{\n+  A() {}\n+};\n+\n+struct B {};\n+\n+void func() throw (B,A)\n+{\n+  throw A();\n+}\n+\n+int main(void)\n+{\n+  try {\tfunc(); }\n+  catch (A& a) { }\n+}"}, {"sha": "718f0dc339382b840a0988fb62d44d0298199601", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6afcef6bd2c7fc2dd55fc2684784dc582961bb37/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6afcef6bd2c7fc2dd55fc2684784dc582961bb37/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=6afcef6bd2c7fc2dd55fc2684784dc582961bb37", "patch": "@@ -1,3 +1,11 @@\n+2002-03-17  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/4381\n+\t* libsupc++/eh_personality.cc (get_adjusted_ptr): New static fn.\n+\t(check_exception_spec): Call it.  Take the thrown pointer.\n+\t(__cxa_call_unexpected): Pass it.\n+\t(PERSONALITY_FUNCTION): Likewise.  Use get_adjusted_ptr.\n+\n Fri Mar 15 09:55:49 2002  Anthony Green  <green@redhat.com>\n \n \t* configure.in: Remove useless is_mingw32."}, {"sha": "802b9e2ca3062753c56c191c50ca0b2a18a969e5", "filename": "libstdc++-v3/libsupc++/eh_personality.cc", "status": "modified", "additions": 45, "deletions": 17, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6afcef6bd2c7fc2dd55fc2684784dc582961bb37/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6afcef6bd2c7fc2dd55fc2684784dc582961bb37/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc?ref=6afcef6bd2c7fc2dd55fc2684784dc582961bb37", "patch": "@@ -96,17 +96,44 @@ get_ttype_entry (lsda_header_info *info, _Unwind_Word i)\n   return reinterpret_cast<const std::type_info *>(ptr);\n }\n \n+// Given the thrown type THROW_TYPE, pointer to a variable containing a\n+// pointer to the exception object THROWN_PTR_P and a type CATCH_TYPE to\n+// compare against, return whether or not there is a match and if so,\n+// update *THROWN_PTR_P.\n+\n+static bool\n+get_adjusted_ptr (const std::type_info *catch_type,\n+\t\t  const std::type_info *throw_type,\n+\t\t  void **thrown_ptr_p)\n+{\n+  void *thrown_ptr = *thrown_ptr_p;\n+\n+  // Pointer types need to adjust the actual pointer, not\n+  // the pointer to pointer that is the exception object.\n+  // This also has the effect of passing pointer types\n+  // \"by value\" through the __cxa_begin_catch return value.\n+  if (throw_type->__is_pointer_p ())\n+    thrown_ptr = *(void **) thrown_ptr;\n+\n+  if (catch_type->__do_catch (throw_type, &thrown_ptr, 1))\n+    {\n+      *thrown_ptr_p = thrown_ptr;\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n static bool\n check_exception_spec (lsda_header_info *info, const std::type_info *throw_type,\n-\t\t      _Unwind_Sword filter_value)\n+\t\t      void *thrown_ptr, _Unwind_Sword filter_value)\n {\n   const unsigned char *e = info->TType - filter_value - 1;\n \n   while (1)\n     {\n       const std::type_info *catch_type;\n       _Unwind_Word tmp;\n-      void *dummy;\n \n       e = read_uleb128 (e, &tmp);\n \n@@ -117,7 +144,12 @@ check_exception_spec (lsda_header_info *info, const std::type_info *throw_type,\n \n       // Match a ttype entry.\n       catch_type = get_ttype_entry (info, tmp);\n-      if (catch_type->__do_catch (throw_type, &dummy, 1))\n+\n+      // ??? There is currently no way to ask the RTTI code about the\n+      // relationship between two types without reference to a specific\n+      // object.  There should be; then we wouldn't need to mess with\n+      // thrown_ptr here.\n+      if (get_adjusted_ptr (catch_type, throw_type, &thrown_ptr))\n \treturn true;\n     }\n }\n@@ -154,7 +186,7 @@ PERSONALITY_FUNCTION (int version,\n   const unsigned char *p;\n   _Unwind_Ptr landing_pad, ip;\n   int handler_switch_value;\n-  void *adjusted_ptr = xh + 1;\n+  void *thrown_ptr = xh + 1;\n \n   // Interface version check.\n   if (version != 1)\n@@ -294,7 +326,6 @@ PERSONALITY_FUNCTION (int version,\n \t    {\n \t      // Positive filter values are handlers.\n \t      catch_type = get_ttype_entry (&info, ar_filter);\n-\t      adjusted_ptr = xh + 1;\n \n \t      // Null catch type is a catch-all handler.  We can catch\n \t      // foreign exceptions with this.\n@@ -308,14 +339,7 @@ PERSONALITY_FUNCTION (int version,\n \t\t}\n \t      else if (throw_type)\n \t\t{\n-\t\t  // Pointer types need to adjust the actual pointer, not\n-\t\t  // the pointer to pointer that is the exception object.\n-\t\t  // This also has the effect of passing pointer types\n-\t\t  // \"by value\" through the __cxa_begin_catch return value.\n-\t\t  if (throw_type->__is_pointer_p ())\n-\t\t    adjusted_ptr = *(void **) adjusted_ptr;\n-\n-\t\t  if (catch_type->__do_catch (throw_type, &adjusted_ptr, 1))\n+\t\t  if (get_adjusted_ptr (catch_type, throw_type, &thrown_ptr))\n \t\t    {\n \t\t      saw_handler = true;\n \t\t      break;\n@@ -329,7 +353,8 @@ PERSONALITY_FUNCTION (int version,\n \t      // see we can't match because there's no __cxa_exception\n \t      // object to stuff bits in for __cxa_call_unexpected to use.\n \t      if (throw_type\n-\t\t  && ! check_exception_spec (&info, throw_type, ar_filter))\n+\t\t  && ! check_exception_spec (&info, throw_type, thrown_ptr,\n+\t\t\t\t\t     ar_filter))\n \t\t{\n \t\t  saw_handler = true;\n \t\t  break;\n@@ -365,7 +390,7 @@ PERSONALITY_FUNCTION (int version,\n           xh->handlerSwitchValue = handler_switch_value;\n           xh->actionRecord = action_record;\n           xh->languageSpecificData = language_specific_data;\n-          xh->adjustedPtr = adjusted_ptr;\n+          xh->adjustedPtr = thrown_ptr;\n \n           // ??? Completely unknown what this field is supposed to be for.\n           // ??? Need to cache TType encoding base for call_unexpected.\n@@ -425,6 +450,7 @@ __cxa_call_unexpected (void *exc_obj_in)\n       \n       __cxa_eh_globals *globals = __cxa_get_globals_fast ();\n       __cxa_exception *new_xh = globals->caughtExceptions;\n+      void *new_ptr = new_xh + 1;\n       \n       // We don't quite have enough stuff cached; re-parse the LSDA.\n       lsda_header_info info;\n@@ -433,13 +459,15 @@ __cxa_call_unexpected (void *exc_obj_in)\n       \n       // If this new exception meets the exception spec, allow it.\n       if (check_exception_spec (&info, new_xh->exceptionType,\n-\t\t\t\txh->handlerSwitchValue))\n+\t\t\t\tnew_ptr, xh->handlerSwitchValue))\n \t__throw_exception_again;\n       \n       // If the exception spec allows std::bad_exception, throw that.\n+      // We don't have a thrown object to compare against, but since\n+      // bad_exception doesn't have virtual bases, that's OK; just pass 0.\n #ifdef __EXCEPTIONS  \n       const std::type_info &bad_exc = typeid (std::bad_exception);\n-      if (check_exception_spec (&info, &bad_exc, xh->handlerSwitchValue))\n+      if (check_exception_spec (&info, &bad_exc, 0, xh->handlerSwitchValue))\n \tthrow std::bad_exception();\n #endif   \n       // Otherwise, die."}]}