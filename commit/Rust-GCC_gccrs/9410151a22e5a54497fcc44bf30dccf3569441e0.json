{"sha": "9410151a22e5a54497fcc44bf30dccf3569441e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQxMDE1MWEyMmU1YTU0NDk3ZmNjNDRiZjMwZGNjZjM1Njk0NDFlMA==", "commit": {"author": {"name": "Thomas Quinot", "email": "quinot@adacore.com", "date": "2007-08-14T08:45:05Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-14T08:45:05Z"}, "message": "binde.adb (Elab_All_Links): Remove unnecessary call to Generic_Separately_Compiled (if...\n\n2007-08-14  Thomas Quinot  <quinot@adacore.com>\n\t    Vincent Celier  <celier@adacore.com>\n\n\t* binde.adb (Elab_All_Links): Remove unnecessary call to\n\tGeneric_Separately_Compiled (if a unit satisfies this predicate, there\n\twon't be an associated Afile).\n\t(Elab_All_Links): Fail if a referenced unit cannot be found\n\n\t* bindgen.adb: \n\tFix comments in bindgen regarding consistency checks done in Bcheck:\n\tthe checks are made across units within a partition, not across several\n\tpartitions.\n\tFix generation of C binder file for VxWorks.\n\n\t* lib.adb (Generic_Separately_Compiled): Rename to\n\tGeneric_May_Lack_ALI, more descriptive of the current use of the\n\tpredicate, and update documentation.\n\n\t* lib-writ.ads, lib-writ.adb (Write_With_Lines): Minor code\n\treorganization and documentation update for the case of predefined\n\tlibrary generics (for which we do not reference an Afile).\n\nFrom-SVN: r127439", "tree": {"sha": "d0e7a73386d172b2419d7f2ead4f393e6d2ab8d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0e7a73386d172b2419d7f2ead4f393e6d2ab8d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9410151a22e5a54497fcc44bf30dccf3569441e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9410151a22e5a54497fcc44bf30dccf3569441e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9410151a22e5a54497fcc44bf30dccf3569441e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9410151a22e5a54497fcc44bf30dccf3569441e0/comments", "author": null, "committer": null, "parents": [{"sha": "5e1527bd5913aa38b5975022665985773747127a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e1527bd5913aa38b5975022665985773747127a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e1527bd5913aa38b5975022665985773747127a"}], "stats": {"total": 178, "additions": 106, "deletions": 72}, "files": [{"sha": "9190db033321c602300348c200526a3df421d66d", "filename": "gcc/ada/binde.adb", "status": "modified", "additions": 62, "deletions": 9, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9410151a22e5a54497fcc44bf30dccf3569441e0/gcc%2Fada%2Fbinde.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9410151a22e5a54497fcc44bf30dccf3569441e0/gcc%2Fada%2Fbinde.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbinde.adb?ref=9410151a22e5a54497fcc44bf30dccf3569441e0", "patch": "@@ -28,12 +28,14 @@ with Binderr;  use Binderr;\n with Butil;    use Butil;\n with Debug;    use Debug;\n with Fname;    use Fname;\n-with Lib;      use Lib;\n with Namet;    use Namet;\n with Opt;      use Opt;\n+with Osint;\n with Output;   use Output;\n with Targparm; use Targparm;\n \n+with System.Case_Util; use System.Case_Util;\n+\n package body Binde is\n \n    --  The following data structures are used to represent the graph that is\n@@ -864,18 +866,69 @@ package body Binde is\n         Units.Table (Before).First_With .. Units.Table (Before).Last_With\n       loop\n          --  Skip if this with is an interface to a stand-alone library.\n-         --  Skip also if no ALI file for this with, happens with certain\n-         --  specialized generic files that do not get compiled.\n+         --  Skip also if no ALI file for this WITH, happens for language\n+         --  defined generics while bootstrapping the compiler (see body of\n+         --  Lib.Writ.Write_With_Lines).\n \n          if not Withs.Table (W).SAL_Interface\n            and then Withs.Table (W).Afile /= No_File\n-           and then Generic_Separately_Compiled (Withs.Table (W).Sfile)\n          then\n-            Elab_All_Links\n-              (Unit_Id_Of (Withs.Table (W).Uname),\n-               After,\n-               Reason,\n-               Make_Elab_Entry (Withs.Table (W).Uname, Link));\n+            declare\n+               Info : constant Int :=\n+                        Get_Name_Table_Info\n+                          (Withs.Table (W).Uname);\n+\n+            begin\n+               --  If the unit is unknown, for some unknown reason, fail\n+               --  graciously explaining that the unit is unknown. Without\n+               --  this check, gnatbind will crash in Unit_Id_Of.\n+\n+               if Info = 0 or else Unit_Id (Info) = No_Unit_Id then\n+                  declare\n+                     Withed       : String :=\n+                                      Get_Name_String (Withs.Table (W).Uname);\n+                     Last_Withed  : Natural := Withed'Last;\n+                     Withing      : String :=\n+                                      Get_Name_String\n+                                        (Units.Table (Before).Uname);\n+                     Last_Withing : Natural := Withing'Last;\n+                     Spec_Body    : String  := \" (Spec)\";\n+\n+                  begin\n+                     To_Mixed (Withed);\n+                     To_Mixed (Withing);\n+\n+                     if Last_Withed > 2 and then\n+                       Withed (Last_Withed - 1) = '%'\n+                     then\n+                        Last_Withed := Last_Withed - 2;\n+                     end if;\n+\n+                     if Last_Withing > 2 and then\n+                       Withing (Last_Withing - 1) = '%'\n+                     then\n+                        Last_Withing := Last_Withing - 2;\n+                     end if;\n+\n+                     if Units.Table (Before).Utype = Is_Body or else\n+                       Units.Table (Before).Utype = Is_Body_Only\n+                     then\n+                        Spec_Body := \" (Body)\";\n+                     end if;\n+\n+                     Osint.Fail\n+                       (\"could not find unit \",\n+                        Withed (Withed'First .. Last_Withed) & \" needed by \" &\n+                        Withing (Withing'First .. Last_Withing) & Spec_Body);\n+                  end;\n+               end if;\n+\n+               Elab_All_Links\n+                 (Unit_Id_Of (Withs.Table (W).Uname),\n+                  After,\n+                  Reason,\n+                  Make_Elab_Entry (Withs.Table (W).Uname, Link));\n+            end;\n          end if;\n       end loop;\n "}, {"sha": "e515992a941d8e5453ee5fb7464bea98b8b58ece", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9410151a22e5a54497fcc44bf30dccf3569441e0/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9410151a22e5a54497fcc44bf30dccf3569441e0/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=9410151a22e5a54497fcc44bf30dccf3569441e0", "patch": "@@ -77,7 +77,7 @@ package body Bindgen is\n \n    --  This table assembles the interface state pragma information from\n    --  all the units in the partition. Note that Bcheck has already checked\n-   --  that the information is consistent across partitions. The entries\n+   --  that the information is consistent across units. The entries\n    --  in this table are n/u/r/s for not set/user/runtime/system.\n \n    package IS_Pragma_Settings is new Table.Table (\n@@ -90,7 +90,7 @@ package body Bindgen is\n \n    --  This table assembles the Priority_Specific_Dispatching pragma\n    --  information from all the units in the partition. Note that Bcheck has\n-   --  already checked that the information is consistent across partitions.\n+   --  already checked that the information is consistent across units.\n    --  The entries in this table are the upper case first character of the\n    --  policy name, e.g. 'F' for FIFO_Within_Priorities.\n \n@@ -1590,7 +1590,6 @@ package body Bindgen is\n       --  if no command line arguments on target, set dummy values\n \n       else\n-         WBI (\"   int result;\");\n          WBI (\"   gnat_argc = 0;\");\n          WBI (\"   gnat_argv = 0;\");\n          WBI (\"   gnat_envp = 0;\");"}, {"sha": "661fc321260016e9d3b98b480400ede3584c368e", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9410151a22e5a54497fcc44bf30dccf3569441e0/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9410151a22e5a54497fcc44bf30dccf3569441e0/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=9410151a22e5a54497fcc44bf30dccf3569441e0", "patch": "@@ -376,11 +376,8 @@ package body Lib.Writ is\n             Write_Info_Str (\" DE\");\n          end if;\n \n-         --  We set the Elaborate_Body indication if either an explicit pragma\n-         --  was present, or if this is an instantiation. RM 12.3(20) requires\n-         --  that the body be immediately elaborated after the spec. We would\n-         --  normally do that anyway, but the EB we generate here ensures that\n-         --  this gets done even when we use the -p gnatbind switch.\n+         --  Set the Elaborate_Body indication if either an explicit pragma\n+         --  was present, or if this is an instantiation.\n \n          if Has_Pragma_Elaborate_Body (Uent)\n            or else (Ukind = N_Package_Declaration\n@@ -391,8 +388,8 @@ package body Lib.Writ is\n          end if;\n \n          --  Now see if we should tell the binder that an elaboration entity\n-         --  is present, which must be reset to true during elaboration. We\n-         --  generate the indication if the following condition is met:\n+         --  is present, which must be set to true during elaboration.\n+         --  We generate the indication if the following condition is met:\n \n          --  If this is a spec ...\n \n@@ -630,7 +627,6 @@ package body Lib.Writ is\n          Num_Withs  : Int := 0;\n          Unum       : Unit_Number_Type;\n          Cunit      : Node_Id;\n-         Cunite     : Entity_Id;\n          Uname      : Unit_Name_Type;\n          Fname      : File_Name_Type;\n          Pname      : constant Unit_Name_Type :=\n@@ -696,7 +692,6 @@ package body Lib.Writ is\n          for J in 1 .. Num_Withs loop\n             Unum   := With_Table (J);\n             Cunit  := Units.Table (Unum).Cunit;\n-            Cunite := Units.Table (Unum).Cunit_Entity;\n             Uname  := Units.Table (Unum).Unit_Name;\n             Fname  := Units.Table (Unum).Unit_File_Name;\n \n@@ -706,12 +701,19 @@ package body Lib.Writ is\n \n             --  Now we need to figure out the names of the files that contain\n             --  the with'ed unit. These will usually be the files for the body,\n-            --  except in the case of a package that has no body.\n-\n-            if (Nkind (Unit (Cunit)) not in N_Generic_Declaration\n-                  and then\n-                Nkind (Unit (Cunit)) not in N_Generic_Renaming_Declaration)\n-              or else Generic_Separately_Compiled (Cunite)\n+            --  except in the case of a package that has no body. Note that we\n+            --  have a specific exemption here for predefined library generics\n+            --  (see comments for Generic_May_Lack_ALI). We do not generate\n+            --  dependency upon the ALI file for such units. Older compilers\n+            --  used to not support generating code (and ALI) for generics, and\n+            --  we want to avoid having different processing (namely, different\n+            --  lists of files to be compiled) for different stages of the\n+            --  bootstrap.\n+\n+            if not ((Nkind (Unit (Cunit)) in N_Generic_Declaration\n+                      or else\n+                     Nkind (Unit (Cunit)) in N_Generic_Renaming_Declaration)\n+                    and then Generic_May_Lack_ALI (Fname))\n             then\n                Write_Info_Tab (25);\n "}, {"sha": "50eb9eae3bf380d3f6064dd9490153d8e1449a6c", "filename": "gcc/ada/lib-writ.ads", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9410151a22e5a54497fcc44bf30dccf3569441e0/gcc%2Fada%2Flib-writ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9410151a22e5a54497fcc44bf30dccf3569441e0/gcc%2Fada%2Flib-writ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.ads?ref=9410151a22e5a54497fcc44bf30dccf3569441e0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -435,7 +435,13 @@ package Lib.Writ is\n    --             dynamic elaboration model, as set by either the -gnatE\n    --             switch or pragma Elaboration_Checks (Dynamic).\n    --\n-   --         EB  Unit has pragma Elaborate_Body\n+   --         EB  Unit has pragma Elaborate_Body, or is a generic instance\n+   --             that has a body. Set for instances because RM 12.3(20)\n+   --             requires that the body be immediately elaborated after the\n+   --             spec (we would normally do that anyway, because elaborate\n+   --             spec and body together whenever possible, and for an instance\n+   --             it is always possible; however setting EB ensures that this\n+   --             is done even when using the -p gnatbind switch).\n    --\n    --         EE  Elaboration entity is present which must be set true when\n    --             the unit is elaborated. The name of the elaboration entity"}, {"sha": "7c5db5df88b57bc7ba4fb4873f2b7d3bb1cb6a8d", "filename": "gcc/ada/lib.adb", "status": "modified", "additions": 17, "deletions": 43, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9410151a22e5a54497fcc44bf30dccf3569441e0/gcc%2Fada%2Flib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9410151a22e5a54497fcc44bf30dccf3569441e0/gcc%2Fada%2Flib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.adb?ref=9410151a22e5a54497fcc44bf30dccf3569441e0", "patch": "@@ -447,49 +447,23 @@ package body Lib is\n       return False;\n    end Entity_Is_In_Main_Unit;\n \n-   ---------------------------------\n-   -- Generic_Separately_Compiled --\n-   ---------------------------------\n-\n-   function Generic_Separately_Compiled (E : Entity_Id) return Boolean is\n-   begin\n-      --  We do not generate object files for internal generics, because\n-      --  the only thing they would contain is the elaboration boolean, and\n-      --  we are careful to elaborate all predefined units first anyway, so\n-      --  this boolean is not needed.\n-\n-      if Is_Internal_File_Name\n-          (Fname => Unit_File_Name (Get_Source_Unit (E)),\n-           Renamings_Included => True)\n-      then\n-         return False;\n-\n-      --  All other generic units do generate object files\n-\n-      else\n-         return True;\n-      end if;\n-   end Generic_Separately_Compiled;\n-\n-   function Generic_Separately_Compiled\n-     (Sfile : File_Name_Type) return Boolean\n-   is\n-   begin\n-      --  Exactly the same as previous function, but works directly on a file\n-      --  name.\n-\n-      if Is_Internal_File_Name\n-          (Fname              => Sfile,\n-           Renamings_Included => True)\n-      then\n-         return False;\n-\n-      --  All other generic units do generate object files\n-\n-      else\n-         return True;\n-      end if;\n-   end Generic_Separately_Compiled;\n+   --------------------------\n+   -- Generic_May_Lack_ALI --\n+   --------------------------\n+\n+   function Generic_May_Lack_ALI (Sfile : File_Name_Type) return Boolean is\n+   begin\n+      --  We allow internal generic units to be used without having a\n+      --  corresponding ALI files to help bootstrapping with older compilers\n+      --  that did not support generating ALIs for such generics. It is safe\n+      --  to do so because the only thing the generated code would contain\n+      --  is the elaboration boolean, and we are careful to elaborate all\n+      --  predefined units first anyway.\n+\n+      return Is_Internal_File_Name\n+               (Fname              => Sfile,\n+                Renamings_Included => True);\n+   end Generic_May_Lack_ALI;\n \n    -----------------------------\n    -- Get_Code_Or_Source_Unit --"}]}