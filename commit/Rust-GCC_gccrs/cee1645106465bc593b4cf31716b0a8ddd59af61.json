{"sha": "cee1645106465bc593b4cf31716b0a8ddd59af61", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VlMTY0NTEwNjQ2NWJjNTkzYjRjZjMxNzE2YjBhOGRkZDU5YWY2MQ==", "commit": {"author": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2019-11-13T12:38:09Z"}, "committer": {"name": "Andrew Stubbs", "email": "ams@gcc.gnu.org", "date": "2019-11-13T12:38:09Z"}, "message": "Optimize GCN OpenMP malloc performance\n\n2019-11-13  Andrew Stubbs  <ams@codesourcery.com>\n\n\tlibgomp/\n\t* config/gcn/team.c (gomp_gcn_enter_kernel): Set up the team arena\n\tand use team_malloc variants.\n\t(gomp_gcn_exit_kernel): Use team_free.\n\t* libgomp.h (TEAM_ARENA_SIZE): Define.\n\t(TEAM_ARENA_START): Define.\n\t(TEAM_ARENA_FREE): Define.\n\t(TEAM_ARENA_END): Define.\n\t(team_malloc): New function.\n\t(team_malloc_cleared): New function.\n\t(team_free): New function.\n\t* team.c (gomp_new_team): Initialize and use team_malloc.\n\t(free_team): Use team_free.\n\t(gomp_free_thread): Use team_free.\n\t(gomp_pause_host): Use team_free.\n\t* work.c (gomp_init_work_share): Use team_malloc.\n\t(gomp_fini_work_share): Use team_free.\n\nFrom-SVN: r278136", "tree": {"sha": "7509f5cbce6597d2c912531eb3324118262c88b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7509f5cbce6597d2c912531eb3324118262c88b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cee1645106465bc593b4cf31716b0a8ddd59af61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cee1645106465bc593b4cf31716b0a8ddd59af61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cee1645106465bc593b4cf31716b0a8ddd59af61", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cee1645106465bc593b4cf31716b0a8ddd59af61/comments", "author": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fa4999953db61cf94c0e57a9ab8b006d950e54ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa4999953db61cf94c0e57a9ab8b006d950e54ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa4999953db61cf94c0e57a9ab8b006d950e54ca"}], "stats": {"total": 118, "additions": 106, "deletions": 12}, "files": [{"sha": "59dae9c80707ca93edfe128d1814c1c2419c779b", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cee1645106465bc593b4cf31716b0a8ddd59af61/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cee1645106465bc593b4cf31716b0a8ddd59af61/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=cee1645106465bc593b4cf31716b0a8ddd59af61", "patch": "@@ -1,3 +1,22 @@\n+2019-11-13  Andrew Stubbs  <ams@codesourcery.com>\n+\n+\t* config/gcn/team.c (gomp_gcn_enter_kernel): Set up the team arena\n+\tand use team_malloc variants.\n+\t(gomp_gcn_exit_kernel): Use team_free.\n+\t* libgomp.h (TEAM_ARENA_SIZE): Define.\n+\t(TEAM_ARENA_START): Define.\n+\t(TEAM_ARENA_FREE): Define.\n+\t(TEAM_ARENA_END): Define.\n+\t(team_malloc): New function.\n+\t(team_malloc_cleared): New function.\n+\t(team_free): New function.\n+\t* team.c (gomp_new_team): Initialize and use team_malloc.\n+\t(free_team): Use team_free.\n+\t(gomp_free_thread): Use team_free.\n+\t(gomp_pause_host): Use team_free.\n+\t* work.c (gomp_init_work_share): Use team_malloc.\n+\t(gomp_fini_work_share): Use team_free.\n+\n 2019-11-13  Andrew Stubbs  <ams@codesourcery.com>\n \t    Kwok Cheung Yeung  <kcy@codesourcery.com>\n \t    Julian Brown  <julian@codesourcery.com>"}, {"sha": "20d419198e0632618172fee949aa3a9a864d0d2d", "filename": "libgomp/config/gcn/team.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cee1645106465bc593b4cf31716b0a8ddd59af61/libgomp%2Fconfig%2Fgcn%2Fteam.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cee1645106465bc593b4cf31716b0a8ddd59af61/libgomp%2Fconfig%2Fgcn%2Fteam.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fgcn%2Fteam.c?ref=cee1645106465bc593b4cf31716b0a8ddd59af61", "patch": "@@ -57,16 +57,28 @@ gomp_gcn_enter_kernel (void)\n       /* Starting additional threads is not supported.  */\n       gomp_global_icv.dyn_var = true;\n \n+      /* Initialize the team arena for optimized memory allocation.\n+         The arena has been allocated on the host side, and the address\n+         passed in via the kernargs.  Each team takes a small slice of it.  */\n+      register void **kernargs asm(\"s8\");\n+      void *team_arena = (kernargs[4] + TEAM_ARENA_SIZE*teamid);\n+      void * __lds *arena_start = (void * __lds *)TEAM_ARENA_START;\n+      void * __lds *arena_free = (void * __lds *)TEAM_ARENA_FREE;\n+      void * __lds *arena_end = (void * __lds *)TEAM_ARENA_END;\n+      *arena_start = team_arena;\n+      *arena_free = team_arena;\n+      *arena_end = team_arena + TEAM_ARENA_SIZE;\n+\n       /* Allocate and initialize the team-local-storage data.  */\n-      struct gomp_thread *thrs = gomp_malloc_cleared (sizeof (*thrs)\n+      struct gomp_thread *thrs = team_malloc_cleared (sizeof (*thrs)\n \t\t\t\t\t\t      * numthreads);\n       set_gcn_thrs (thrs);\n \n       /* Allocate and initailize a pool of threads in the team.\n          The threads are already running, of course, we just need to manage\n          the communication between them.  */\n-      struct gomp_thread_pool *pool = gomp_malloc (sizeof (*pool));\n-      pool->threads = gomp_malloc (sizeof (void *) * numthreads);\n+      struct gomp_thread_pool *pool = team_malloc (sizeof (*pool));\n+      pool->threads = team_malloc (sizeof (void *) * numthreads);\n       for (int tid = 0; tid < numthreads; tid++)\n \tpool->threads[tid] = &thrs[tid];\n       pool->threads_size = numthreads;\n@@ -91,7 +103,7 @@ void\n gomp_gcn_exit_kernel (void)\n {\n   gomp_free_thread (gcn_thrs ());\n-  free (gcn_thrs ());\n+  team_free (gcn_thrs ());\n }\n \n /* This function contains the idle loop in which a thread waits"}, {"sha": "bab733d2b2da60c48e1795422655ff8ce98c3c3e", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cee1645106465bc593b4cf31716b0a8ddd59af61/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cee1645106465bc593b4cf31716b0a8ddd59af61/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=cee1645106465bc593b4cf31716b0a8ddd59af61", "patch": "@@ -106,6 +106,69 @@ extern void gomp_aligned_free (void *);\n    GCC's builtin alloca().  */\n #define gomp_alloca(x)  __builtin_alloca(x)\n \n+/* Optimized allocators for team-specific data that will die with the team.  */\n+\n+#ifdef __AMDGCN__\n+/* The arena is initialized in config/gcn/team.c.  */\n+#define TEAM_ARENA_SIZE  64*1024  /* Must match the value in plugin-gcn.c.  */\n+#define TEAM_ARENA_START 16  /* LDS offset of free pointer.  */\n+#define TEAM_ARENA_FREE  24  /* LDS offset of free pointer.  */\n+#define TEAM_ARENA_END   32  /* LDS offset of end pointer.  */\n+\n+static inline void * __attribute__((malloc))\n+team_malloc (size_t size)\n+{\n+  /* 4-byte align the size.  */\n+  size = (size + 3) & ~3;\n+\n+  /* Allocate directly from the arena.\n+     The compiler does not support DS atomics, yet. */\n+  void *result;\n+  asm (\"ds_add_rtn_u64 %0, %1, %2\\n\\ts_waitcnt 0\"\n+       : \"=v\"(result) : \"v\"(TEAM_ARENA_FREE), \"v\"(size), \"e\"(1L) : \"memory\");\n+\n+  /* Handle OOM.  */\n+  if (result + size > *(void * __lds *)TEAM_ARENA_END)\n+    {\n+      /* While this is experimental, let's make sure we know when OOM\n+\t happens.  */\n+      const char msg[] = \"GCN team arena exhausted\\n\";\n+      write (2, msg, sizeof(msg)-1);\n+\n+      /* Fall back to using the heap (slowly).  */\n+      result = gomp_malloc (size);\n+    }\n+  return result;\n+}\n+\n+static inline void * __attribute__((malloc))\n+team_malloc_cleared (size_t size)\n+{\n+  char *result = team_malloc (size);\n+\n+  /* Clear the allocated memory.  */\n+  __builtin_memset (result, 0, size);\n+\n+  return result;\n+}\n+\n+static inline void\n+team_free (void *ptr)\n+{\n+  /* The whole arena is freed when the kernel exits.\n+     However, if we fell back to using heap then we should free it.\n+     It would be better if this function could be a no-op, but at least\n+     LDS loads are cheap.  */\n+  if (ptr < *(void * __lds *)TEAM_ARENA_START\n+      || ptr >= *(void * __lds *)TEAM_ARENA_END)\n+    free (ptr);\n+}\n+#else\n+#define team_malloc(...) gomp_malloc (__VA_ARGS__)\n+#define team_malloc_cleared(...) gomp_malloc_cleared (__VA_ARGS__)\n+#define team_free(...) free (__VA_ARGS__)\n+#endif\n+\n /* error.c */\n \n extern void gomp_vdebug (int, const char *, va_list);"}, {"sha": "cdfb9ba6c98045721c7883a4033a287c88a8581c", "filename": "libgomp/team.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cee1645106465bc593b4cf31716b0a8ddd59af61/libgomp%2Fteam.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cee1645106465bc593b4cf31716b0a8ddd59af61/libgomp%2Fteam.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fteam.c?ref=cee1645106465bc593b4cf31716b0a8ddd59af61", "patch": "@@ -171,7 +171,7 @@ gomp_new_team (unsigned nthreads)\n     {\n       size_t extra = sizeof (team->ordered_release[0])\n \t\t     + sizeof (team->implicit_task[0]);\n-      team = gomp_malloc (sizeof (*team) + nthreads * extra);\n+      team = team_malloc (sizeof (*team) + nthreads * extra);\n \n #ifndef HAVE_SYNC_BUILTINS\n       gomp_mutex_init (&team->work_share_list_free_lock);\n@@ -221,7 +221,7 @@ free_team (struct gomp_team *team)\n   gomp_barrier_destroy (&team->barrier);\n   gomp_mutex_destroy (&team->task_lock);\n   priority_queue_free (&team->task_queue);\n-  free (team);\n+  team_free (team);\n }\n \n static void\n@@ -285,8 +285,8 @@ gomp_free_thread (void *arg __attribute__((unused)))\n       if (pool->last_team)\n \tfree_team (pool->last_team);\n #ifndef __nvptx__\n-      free (pool->threads);\n-      free (pool);\n+      team_free (pool->threads);\n+      team_free (pool);\n #endif\n       thr->thread_pool = NULL;\n     }\n@@ -1082,8 +1082,8 @@ gomp_pause_host (void)\n       if (pool->last_team)\n \tfree_team (pool->last_team);\n #ifndef __nvptx__\n-      free (pool->threads);\n-      free (pool);\n+      team_free (pool->threads);\n+      team_free (pool);\n #endif\n       thr->thread_pool = NULL;\n     }"}, {"sha": "28bb0c11255bde428701f9709baf39c4c347be80", "filename": "libgomp/work.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cee1645106465bc593b4cf31716b0a8ddd59af61/libgomp%2Fwork.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cee1645106465bc593b4cf31716b0a8ddd59af61/libgomp%2Fwork.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fwork.c?ref=cee1645106465bc593b4cf31716b0a8ddd59af61", "patch": "@@ -120,7 +120,7 @@ gomp_init_work_share (struct gomp_work_share *ws, size_t ordered,\n       else\n \tordered = nthreads * sizeof (*ws->ordered_team_ids);\n       if (ordered > INLINE_ORDERED_TEAM_IDS_SIZE)\n-\tws->ordered_team_ids = gomp_malloc (ordered);\n+\tws->ordered_team_ids = team_malloc (ordered);\n       else\n \tws->ordered_team_ids = ws->inline_ordered_team_ids;\n       memset (ws->ordered_team_ids, '\\0', ordered);\n@@ -142,7 +142,7 @@ gomp_fini_work_share (struct gomp_work_share *ws)\n {\n   gomp_mutex_destroy (&ws->lock);\n   if (ws->ordered_team_ids != ws->inline_ordered_team_ids)\n-    free (ws->ordered_team_ids);\n+    team_free (ws->ordered_team_ids);\n   gomp_ptrlock_destroy (&ws->next_ws);\n }\n "}]}