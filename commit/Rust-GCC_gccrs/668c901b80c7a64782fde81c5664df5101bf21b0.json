{"sha": "668c901b80c7a64782fde81c5664df5101bf21b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjY4YzkwMWI4MGM3YTY0NzgyZmRlODFjNTY2NGRmNTEwMWJmMjFiMA==", "commit": {"author": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2016-01-12T01:35:23Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2016-01-12T01:35:23Z"}, "message": "pa.c (pa_emit_move_sequence): Handle floating point reloads for other unsupported memory operands.\n\n\t* config/pa/pa.c (pa_emit_move_sequence): Handle floating point\n\treloads for other unsupported memory operands.\n\nFrom-SVN: r232253", "tree": {"sha": "4a3bf2b9f0f01729944a96ed6b8b3a0c7456fb67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a3bf2b9f0f01729944a96ed6b8b3a0c7456fb67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/668c901b80c7a64782fde81c5664df5101bf21b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/668c901b80c7a64782fde81c5664df5101bf21b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/668c901b80c7a64782fde81c5664df5101bf21b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/668c901b80c7a64782fde81c5664df5101bf21b0/comments", "author": null, "committer": null, "parents": [{"sha": "27b1820af071afdf213223afc666c91fd231cee7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27b1820af071afdf213223afc666c91fd231cee7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27b1820af071afdf213223afc666c91fd231cee7"}], "stats": {"total": 118, "additions": 75, "deletions": 43}, "files": [{"sha": "bd84e1f36d635ad2d36d357a063bf93be698589f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668c901b80c7a64782fde81c5664df5101bf21b0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668c901b80c7a64782fde81c5664df5101bf21b0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=668c901b80c7a64782fde81c5664df5101bf21b0", "patch": "@@ -1,3 +1,8 @@\n+2016-01-11  John David Anglin  <danglin@gcc.gnu.org>\n+\n+\t* config/pa/pa.c (pa_emit_move_sequence): Handle floating point\n+\treloads for other unsupported memory operands.\n+\n 2016-01-12  Kugan Vivekanandarajah  <kuganv@linaro.org>\n \t    Jim Wilson  <jim.wilson@linaro.org>\n "}, {"sha": "8b1c8327c79733b09716344938cd243c31ed2c5c", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 70, "deletions": 43, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668c901b80c7a64782fde81c5664df5101bf21b0/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668c901b80c7a64782fde81c5664df5101bf21b0/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=668c901b80c7a64782fde81c5664df5101bf21b0", "patch": "@@ -1681,7 +1681,8 @@ pa_emit_move_sequence (rtx *operands, machine_mode mode, rtx scratch_reg)\n \n   /* Handle secondary reloads for loads/stores of FP registers from\n      REG+D addresses where D does not fit in 5 or 14 bits, including\n-     (subreg (mem (addr))) cases.  */\n+     (subreg (mem (addr))) cases, and reloads for other unsupported\n+     memory operands.  */\n   if (scratch_reg\n       && FP_REG_P (operand0)\n       && (MEM_P (operand1)\n@@ -1693,30 +1694,43 @@ pa_emit_move_sequence (rtx *operands, machine_mode mode, rtx scratch_reg)\n       if (GET_CODE (op1) == SUBREG)\n \top1 = XEXP (op1, 0);\n \n-      if (reg_plus_base_memory_operand (op1, GET_MODE (op1))\n-\t  && !(TARGET_PA_20\n-\t       && !TARGET_ELF32\n-\t       && INT_14_BITS (XEXP (XEXP (op1, 0), 1)))\n-\t  && !INT_5_BITS (XEXP (XEXP (op1, 0), 1)))\n+      if (reg_plus_base_memory_operand (op1, GET_MODE (op1)))\n \t{\n-\t  /* SCRATCH_REG will hold an address and maybe the actual data.\n-\t     We want it in WORD_MODE regardless of what mode it was\n-\t     originally given to us.  */\n-\t  scratch_reg = force_mode (word_mode, scratch_reg);\n-\n-\t  /* D might not fit in 14 bits either; for such cases load D into\n-\t     scratch reg.  */\n-\t  if (!INT_14_BITS (XEXP (XEXP (op1, 0), 1)))\n+\t  if (!(TARGET_PA_20\n+\t\t&& !TARGET_ELF32\n+\t\t&& INT_14_BITS (XEXP (XEXP (op1, 0), 1)))\n+\t      && !INT_5_BITS (XEXP (XEXP (op1, 0), 1)))\n \t    {\n-\t      emit_move_insn (scratch_reg, XEXP (XEXP (op1, 0), 1));\n-\t      emit_move_insn (scratch_reg,\n-\t\t\t      gen_rtx_fmt_ee (GET_CODE (XEXP (op1, 0)),\n-\t\t\t\t\t      Pmode,\n-\t\t\t\t\t      XEXP (XEXP (op1, 0), 0),\n-\t\t\t\t\t      scratch_reg));\n+\t      /* SCRATCH_REG will hold an address and maybe the actual data.\n+\t\t We want it in WORD_MODE regardless of what mode it was\n+\t\t originally given to us.  */\n+\t      scratch_reg = force_mode (word_mode, scratch_reg);\n+\n+\t      /* D might not fit in 14 bits either; for such cases load D\n+\t\t into scratch reg.  */\n+\t      if (!INT_14_BITS (XEXP (XEXP (op1, 0), 1)))\n+\t\t{\n+\t\t  emit_move_insn (scratch_reg, XEXP (XEXP (op1, 0), 1));\n+\t\t  emit_move_insn (scratch_reg,\n+\t\t\t\t  gen_rtx_fmt_ee (GET_CODE (XEXP (op1, 0)),\n+\t\t\t\t\t\t  Pmode,\n+\t\t\t\t\t\t  XEXP (XEXP (op1, 0), 0),\n+\t\t\t\t\t\t  scratch_reg));\n+\t\t}\n+\t      else\n+\t\temit_move_insn (scratch_reg, XEXP (op1, 0));\n+\t      emit_insn (gen_rtx_SET (operand0,\n+\t\t\t\t  replace_equiv_address (op1, scratch_reg)));\n+\t      return 1;\n \t    }\n-\t  else\n-\t    emit_move_insn (scratch_reg, XEXP (op1, 0));\n+\t}\n+      else if ((!INT14_OK_STRICT && symbolic_memory_operand (op1, VOIDmode))\n+\t       || IS_LO_SUM_DLT_ADDR_P (XEXP (op1, 0))\n+\t       || IS_INDEX_ADDR_P (XEXP (op1, 0)))\n+\t{\n+\t  /* Load memory address into SCRATCH_REG.  */\n+\t  scratch_reg = force_mode (word_mode, scratch_reg);\n+\t  emit_move_insn (scratch_reg, XEXP (op1, 0));\n \t  emit_insn (gen_rtx_SET (operand0,\n \t\t\t\t  replace_equiv_address (op1, scratch_reg)));\n \t  return 1;\n@@ -1733,30 +1747,43 @@ pa_emit_move_sequence (rtx *operands, machine_mode mode, rtx scratch_reg)\n       if (GET_CODE (op0) == SUBREG)\n \top0 = XEXP (op0, 0);\n \n-      if (reg_plus_base_memory_operand (op0, GET_MODE (op0))\n-\t  && !(TARGET_PA_20\n-\t       && !TARGET_ELF32\n-\t       && INT_14_BITS (XEXP (XEXP (op0, 0), 1)))\n-\t  && !INT_5_BITS (XEXP (XEXP (op0, 0), 1)))\n+      if (reg_plus_base_memory_operand (op0, GET_MODE (op0)))\n \t{\n-\t  /* SCRATCH_REG will hold an address and maybe the actual data.\n-\t     We want it in WORD_MODE regardless of what mode it was\n-\t     originally given to us.  */\n-\t  scratch_reg = force_mode (word_mode, scratch_reg);\n-\n-\t  /* D might not fit in 14 bits either; for such cases load D into\n-\t     scratch reg.  */\n-\t  if (!INT_14_BITS (XEXP (XEXP (op0, 0), 1)))\n+\t  if (!(TARGET_PA_20\n+\t\t&& !TARGET_ELF32\n+\t\t&& INT_14_BITS (XEXP (XEXP (op0, 0), 1)))\n+\t      && !INT_5_BITS (XEXP (XEXP (op0, 0), 1)))\n \t    {\n-\t      emit_move_insn (scratch_reg, XEXP (XEXP (op0, 0), 1));\n-\t      emit_move_insn (scratch_reg,\n-\t\t\t      gen_rtx_fmt_ee (GET_CODE (XEXP (op0, 0)),\n-\t\t\t\t\t      Pmode,\n-\t\t\t\t\t      XEXP (XEXP (op0, 0), 0),\n-\t\t\t\t\t      scratch_reg));\n+\t      /* SCRATCH_REG will hold an address and maybe the actual data.\n+\t\t We want it in WORD_MODE regardless of what mode it was\n+\t\t originally given to us.  */\n+\t      scratch_reg = force_mode (word_mode, scratch_reg);\n+\n+\t      /* D might not fit in 14 bits either; for such cases load D\n+\t\t into scratch reg.  */\n+\t      if (!INT_14_BITS (XEXP (XEXP (op0, 0), 1)))\n+\t\t{\n+\t\t  emit_move_insn (scratch_reg, XEXP (XEXP (op0, 0), 1));\n+\t\t  emit_move_insn (scratch_reg,\n+\t\t\t\t  gen_rtx_fmt_ee (GET_CODE (XEXP (op0, 0)),\n+\t\t\t\t\t\t  Pmode,\n+\t\t\t\t\t\t  XEXP (XEXP (op0, 0), 0),\n+\t\t\t\t\t\t  scratch_reg));\n+\t\t}\n+\t      else\n+\t\temit_move_insn (scratch_reg, XEXP (op0, 0));\n+\t      emit_insn (gen_rtx_SET (replace_equiv_address (op0, scratch_reg),\n+\t\t\t\t      operand1));\n+\t      return 1;\n \t    }\n-\t  else\n-\t    emit_move_insn (scratch_reg, XEXP (op0, 0));\n+\t}\n+      else if ((!INT14_OK_STRICT && symbolic_memory_operand (op0, VOIDmode))\n+\t       || IS_LO_SUM_DLT_ADDR_P (XEXP (op0, 0))\n+\t       || IS_INDEX_ADDR_P (XEXP (op0, 0)))\n+\t{\n+\t  /* Load memory address into SCRATCH_REG.  */\n+\t  scratch_reg = force_mode (word_mode, scratch_reg);\n+\t  emit_move_insn (scratch_reg, XEXP (op0, 0));\n \t  emit_insn (gen_rtx_SET (replace_equiv_address (op0, scratch_reg),\n \t\t\t\t  operand1));\n \t  return 1;"}]}