{"sha": "e15eb3aa705ff04ca1b97da59dfac6b912915c2a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE1ZWIzYWE3MDVmZjA0Y2ExYjk3ZGE1OWRmYWM2YjkxMjkxNWMyYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-06-23T23:17:47Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-06-23T23:17:47Z"}, "message": "(alloc_qty_for_scratch): Can allocate likely-spilled register classes for SCRATCH.\n\n(alloc_qty_for_scratch): Can allocate likely-spilled register classes\nfor SCRATCH.\n(block_alloc): Likewise for regs in small register classes.\n\nFrom-SVN: r4719", "tree": {"sha": "215cc0ac839224e77f77635ce77331eb3b67d5dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/215cc0ac839224e77f77635ce77331eb3b67d5dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e15eb3aa705ff04ca1b97da59dfac6b912915c2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e15eb3aa705ff04ca1b97da59dfac6b912915c2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e15eb3aa705ff04ca1b97da59dfac6b912915c2a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e15eb3aa705ff04ca1b97da59dfac6b912915c2a/comments", "author": null, "committer": null, "parents": [{"sha": "0f21219f14b95beecc707b9ee2582a1dc646f1e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f21219f14b95beecc707b9ee2582a1dc646f1e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f21219f14b95beecc707b9ee2582a1dc646f1e1"}], "stats": {"total": 22, "additions": 8, "deletions": 14}, "files": [{"sha": "5d7b0e6da9aaa799d3a28f6fe5c20edaf5a12879", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e15eb3aa705ff04ca1b97da59dfac6b912915c2a/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e15eb3aa705ff04ca1b97da59dfac6b912915c2a/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=e15eb3aa705ff04ca1b97da59dfac6b912915c2a", "patch": "@@ -1,5 +1,5 @@\n /* Allocate registers within a basic block, for GNU compiler.\n-   Copyright (C) 1987, 1988, 1991 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1991, 1993 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -345,11 +345,7 @@ alloc_qty_for_scratch (scratch, n, insn, insn_code_num, insn_number)\n \tbreak;\n       }\n \n-  /* If CLASS has only a few registers, don't allocate the SCRATCH here since\n-     it will prevent that register from being used as a spill register.\n-     reload will do the allocation.  */\n-\n-  if (class == NO_REGS || CLASS_LIKELY_SPILLED_P (class))\n+  if (class == NO_REGS)\n     return;\n \n #else /* REGISTER_CONSTRAINTS */\n@@ -400,6 +396,11 @@ local_alloc ()\n      See the declarations of these variables, above,\n      for what they mean.  */\n \n+  /* There can be up to MAX_SCRATCH * N_BASIC_BLOCKS SCRATCHes to allocate.\n+     Instead of allocating this much memory from now until the end of\n+     reload, only allocate space for MAX_QTY SCRATCHes.  If there are more\n+     reload will allocate them.  */\n+\n   scratch_list_length = max_qty;\n   scratch_list = (rtx *) xmalloc (scratch_list_length * sizeof (rtx));\n   bzero (scratch_list, scratch_list_length * sizeof (rtx));\n@@ -1335,21 +1336,14 @@ block_alloc (b)\n \t\t&& GET_CODE (XEXP (link, 0)) == REG)\n \t      wipe_dead_reg (XEXP (link, 0), 1);\n \n-#ifndef SMALL_REGISTER_CLASSES\n-\t  /* Allocate quantities for any SCRATCH operands of this insn.  We\n-\t     don't do this for machines with small register classes because\n-\t     those machines can use registers explicitly mentioned in the\n-\t     RTL as spill registers and our usage of hard registers\n-\t     explicitly for SCRATCH operands will conflict.  On those machines,\n-\t     reload will allocate the SCRATCH.  */\n+\t  /* Allocate quantities for any SCRATCH operands of this insn.  */\n \n \t  if (insn_code_number >= 0)\n \t    for (i = 0; i < insn_n_operands[insn_code_number]; i++)\n \t      if (GET_CODE (recog_operand[i]) == SCRATCH\n \t\t  && scratch_index < scratch_list_length - 1)\n \t\talloc_qty_for_scratch (recog_operand[i], i, insn,\n \t\t\t\t       insn_code_number, insn_number);\n-#endif\n \n \t  /* If this is an insn that has a REG_RETVAL note pointing at a \n \t     CLOBBER insn, we have reached the end of a REG_NO_CONFLICT"}]}