{"sha": "08281ce0fb9870da71ad27f4a06ff0091d227e43", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDgyODFjZTBmYjk4NzBkYTcxYWQyN2Y0YTA2ZmYwMDkxZDIyN2U0Mw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2014-06-22T19:32:57Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2014-06-22T19:32:57Z"}, "message": "re PR bootstrap/61565 (ICE building libjava/interpret.cc)\n\nPR target/61565\n\n* compare-elim.c (struct comparison): Add eh_note.\n(find_comparison_dom_walker::before_dom_children): Don't eliminate\na redundant comparison in a different EH region.  Purge EH edges if\nnecessary.\n\nFrom-SVN: r211881", "tree": {"sha": "367808896d5be5fd32976d88ee4cb10130d107b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/367808896d5be5fd32976d88ee4cb10130d107b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08281ce0fb9870da71ad27f4a06ff0091d227e43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08281ce0fb9870da71ad27f4a06ff0091d227e43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08281ce0fb9870da71ad27f4a06ff0091d227e43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08281ce0fb9870da71ad27f4a06ff0091d227e43/comments", "author": null, "committer": null, "parents": [{"sha": "37317a1fc012ba4208a01d337864c579c55d3a3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37317a1fc012ba4208a01d337864c579c55d3a3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37317a1fc012ba4208a01d337864c579c55d3a3d"}], "stats": {"total": 83, "additions": 58, "deletions": 25}, "files": [{"sha": "bc72a7fa7e60e6cdcf48f02c7d4cd498f6c0bdac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08281ce0fb9870da71ad27f4a06ff0091d227e43/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08281ce0fb9870da71ad27f4a06ff0091d227e43/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=08281ce0fb9870da71ad27f4a06ff0091d227e43", "patch": "@@ -1,3 +1,11 @@\n+2014-06-22  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/61565\n+\t* compare-elim.c (struct comparison): Add eh_note.\n+\t(find_comparison_dom_walker::before_dom_children): Don't eliminate\n+\ta redundant comparison in a different EH region.  Purge EH edges if\n+\tnecessary.\n+\n 2014-06-22  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* config/rs6000/rs6000.md (maybe_var_shift): New define_attr."}, {"sha": "4ecdd48ef686b241be15052bf1d2a7260afb9d08", "filename": "gcc/compare-elim.c", "status": "modified", "additions": 50, "deletions": 25, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08281ce0fb9870da71ad27f4a06ff0091d227e43/gcc%2Fcompare-elim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08281ce0fb9870da71ad27f4a06ff0091d227e43/gcc%2Fcompare-elim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcompare-elim.c?ref=08281ce0fb9870da71ad27f4a06ff0091d227e43", "patch": "@@ -100,6 +100,9 @@ struct comparison\n      constants.  */\n   rtx in_a, in_b;\n \n+  /* The REG_EH_REGION of the comparison.  */\n+  rtx eh_note;\n+\n   /* Information about how this comparison is used.  */\n   struct comparison_use uses[MAX_CMP_USE];\n \n@@ -262,6 +265,7 @@ find_comparison_dom_walker::before_dom_children (basic_block bb)\n   struct comparison *last_cmp;\n   rtx insn, next, last_clobber;\n   bool last_cmp_valid;\n+  bool need_purge = false;\n   bitmap killed;\n \n   killed = BITMAP_ALLOC (NULL);\n@@ -303,44 +307,60 @@ find_comparison_dom_walker::before_dom_children (basic_block bb)\n       if (src)\n \t{\n \t  enum machine_mode src_mode = GET_MODE (src);\n+\t  rtx eh_note = NULL;\n \n-\t  /* Eliminate a compare that's redundant with the previous.  */\n-\t  if (last_cmp_valid\n-\t      && rtx_equal_p (last_cmp->in_a, XEXP (src, 0))\n-\t      && rtx_equal_p (last_cmp->in_b, XEXP (src, 1)))\n-\t    {\n-\t      rtx flags, x;\n-\t      enum machine_mode new_mode\n-\t\t= targetm.cc_modes_compatible (last_cmp->orig_mode, src_mode);\n+\t  if (flag_non_call_exceptions)\n+\t    eh_note = find_reg_note (insn, REG_EH_REGION, NULL);\n \n-\t      /* New mode is incompatible with the previous compare mode.  */\n-\t      if (new_mode == VOIDmode)\n-\t\tcontinue;\n+\t  if (!last_cmp_valid)\n+\t    goto dont_delete;\n \n-\t      if (new_mode != last_cmp->orig_mode)\n-\t\t{\n-\t\t  flags = gen_rtx_REG (src_mode, targetm.flags_regnum);\n+\t  /* Take care that it's in the same EH region.  */\n+\t  if (flag_non_call_exceptions\n+\t      && !rtx_equal_p (eh_note, last_cmp->eh_note))\n+\t    goto dont_delete;\n \n-\t\t  /* Generate new comparison for substitution.  */\n-\t\t  x = gen_rtx_COMPARE (new_mode, XEXP (src, 0), XEXP (src, 1));\n-\t\t  x = gen_rtx_SET (VOIDmode, flags, x);\n+\t  /* Make sure the compare is redundant with the previous.  */\n+\t  if (!rtx_equal_p (last_cmp->in_a, XEXP (src, 0))\n+\t      || !rtx_equal_p (last_cmp->in_b, XEXP (src, 1)))\n+\t    goto dont_delete;\n \n-\t\t  if (!validate_change (last_cmp->insn,\n-\t\t\t\t\t&PATTERN (last_cmp->insn), x, false))\n-\t\t    continue;\n+\t  /* New mode must be compatible with the previous compare mode.  */\n+\t  {\n+\t    enum machine_mode new_mode\n+\t      = targetm.cc_modes_compatible (last_cmp->orig_mode, src_mode);\n+\t    if (new_mode == VOIDmode)\n+\t      goto dont_delete;\n \n-\t\t  last_cmp->orig_mode = new_mode;\n-\t\t}\n+\t    if (new_mode != last_cmp->orig_mode)\n+\t      {\n+\t\trtx x, flags = gen_rtx_REG (src_mode, targetm.flags_regnum);\n \n-\t      delete_insn (insn);\n-\t      continue;\n-\t    }\n+\t\t/* Generate new comparison for substitution.  */\n+\t\tx = gen_rtx_COMPARE (new_mode, XEXP (src, 0), XEXP (src, 1));\n+\t\tx = gen_rtx_SET (VOIDmode, flags, x);\n \n+\t\tif (!validate_change (last_cmp->insn,\n+\t\t\t\t      &PATTERN (last_cmp->insn), x, false))\n+\t\t  goto dont_delete;\n+\n+\t\tlast_cmp->orig_mode = new_mode;\n+\t      }\n+\t  }\n+\n+\t  /* All tests and substitutions succeeded!  */\n+\t  if (eh_note)\n+\t    need_purge = true;\n+\t  delete_insn (insn);\n+\t  continue;\n+\n+\tdont_delete:\n \t  last_cmp = XCNEW (struct comparison);\n \t  last_cmp->insn = insn;\n \t  last_cmp->prev_clobber = last_clobber;\n \t  last_cmp->in_a = XEXP (src, 0);\n \t  last_cmp->in_b = XEXP (src, 1);\n+\t  last_cmp->eh_note = eh_note;\n \t  last_cmp->orig_mode = src_mode;\n \t  all_compares.safe_push (last_cmp);\n \n@@ -404,6 +424,11 @@ find_comparison_dom_walker::before_dom_children (basic_block bb)\n \t    }\n \t}\n     }\n+\n+  /* If we deleted a compare with a REG_EH_REGION note, we may need to\n+     remove EH edges.  */\n+  if (need_purge)\n+    purge_dead_edges (bb);\n }\n \n /* Find all comparisons in the function.  */"}]}