{"sha": "e5a9d60317852a7323e46109fa366e630b8b5bae", "node_id": "C_kwDOANBUbNoAKGU1YTlkNjAzMTc4NTJhNzMyM2U0NjEwOWZhMzY2ZTYzMGI4YjViYWU", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-07-07T07:00:00Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-07-07T07:06:13Z"}, "message": "Speed up LC SSA rewrite\n\nThe following avoids collecting all loops exit blocks into bitmaps\nand computing the union of those up the loop tree possibly repeatedly.\nInstead we make sure to do this only once for each loop with a\ndefinition possibly requiring a LC phi node plus make sure to\nleverage recorded exits to avoid the intermediate bitmap allocation.\n\n\t* tree-ssa-loop-manip.cc (compute_live_loop_exits): Take\n\tthe def loop exit block bitmap as argument instead of\n\tre-computing it here.\n\t(add_exit_phis_var): Adjust.\n\t(loop_name_cmp): New function.\n\t(add_exit_phis): Sort variables to insert LC PHI nodes\n\tafter definition loop, for each definition loop compute\n\tthe exit block bitmap once.\n\t(get_loops_exit): Remove.\n\t(rewrite_into_loop_closed_ssa_1): Do not pre-record\n\tall loop exit blocks into bitmaps.  Record loop exits\n\tif required.", "tree": {"sha": "be18a160d656f860885d8e9219c8b1a357f532df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be18a160d656f860885d8e9219c8b1a357f532df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5a9d60317852a7323e46109fa366e630b8b5bae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5a9d60317852a7323e46109fa366e630b8b5bae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5a9d60317852a7323e46109fa366e630b8b5bae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5a9d60317852a7323e46109fa366e630b8b5bae/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7922f5ee649a88cd7c0b6d1a242588013d96223d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7922f5ee649a88cd7c0b6d1a242588013d96223d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7922f5ee649a88cd7c0b6d1a242588013d96223d"}], "stats": {"total": 95, "additions": 56, "deletions": 39}, "files": [{"sha": "0324ff60a0f57ed872b56e156fea4c1fb71a0f84", "filename": "gcc/tree-ssa-loop-manip.cc", "status": "modified", "additions": 56, "deletions": 39, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a9d60317852a7323e46109fa366e630b8b5bae/gcc%2Ftree-ssa-loop-manip.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a9d60317852a7323e46109fa366e630b8b5bae/gcc%2Ftree-ssa-loop-manip.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.cc?ref=e5a9d60317852a7323e46109fa366e630b8b5bae", "patch": "@@ -183,12 +183,14 @@ find_sibling_superloop (class loop *use_loop, class loop *def_loop)\n /* DEF_BB is a basic block containing a DEF that needs rewriting into\n    loop-closed SSA form.  USE_BLOCKS is the set of basic blocks containing\n    uses of DEF that \"escape\" from the loop containing DEF_BB (i.e. blocks in\n-   USE_BLOCKS are dominated by DEF_BB but not in the loop father of DEF_B).\n+   USE_BLOCKS are dominated by DEF_BB but not in the loop father of DEF_BB).\n    ALL_EXITS[I] is the set of all basic blocks that exit loop I.\n+   DEF_LOOP_EXITS is a bitmap of loop exit blocks that exit the loop\n+   containing DEF_BB or its outer loops.\n \n-   Compute the subset of LOOP_EXITS that exit the loop containing DEF_BB\n-   or one of its loop fathers, in which DEF is live.  This set is returned\n-   in the bitmap LIVE_EXITS.\n+   Compute the subset of loop exit destinations that exit the loop\n+   containing DEF_BB or one of its loop fathers, in which DEF is live.\n+   This set is returned in the bitmap LIVE_EXITS.\n \n    Instead of computing the complete livein set of the def, we use the loop\n    nesting tree as a form of poor man's structure analysis.  This greatly\n@@ -197,18 +199,17 @@ find_sibling_superloop (class loop *use_loop, class loop *def_loop)\n \n static void\n compute_live_loop_exits (bitmap live_exits, bitmap use_blocks,\n-\t\t\t bitmap *loop_exits, basic_block def_bb)\n+\t\t\t basic_block def_bb, bitmap def_loop_exits)\n {\n   unsigned i;\n   bitmap_iterator bi;\n   class loop *def_loop = def_bb->loop_father;\n   unsigned def_loop_depth = loop_depth (def_loop);\n-  bitmap def_loop_exits;\n \n   /* Normally the work list size is bounded by the number of basic\n      blocks in the largest loop.  We don't know this number, but we\n      can be fairly sure that it will be relatively small.  */\n-  auto_vec<basic_block> worklist (MAX (8, n_basic_blocks_for_fn (cfun) / 128));\n+  auto_vec<basic_block, 8> worklist (MAX (8, n_basic_blocks_for_fn (cfun) / 128));\n \n   EXECUTE_IF_SET_IN_BITMAP (use_blocks, 0, i, bi)\n     {\n@@ -272,13 +273,7 @@ compute_live_loop_exits (bitmap live_exits, bitmap use_blocks,\n \t}\n     }\n \n-  def_loop_exits = BITMAP_ALLOC (&loop_renamer_obstack);\n-  for (class loop *loop = def_loop;\n-       loop != current_loops->tree_root;\n-       loop = loop_outer (loop))\n-    bitmap_ior_into (def_loop_exits, loop_exits[loop->num]);\n   bitmap_and_into (live_exits, def_loop_exits);\n-  BITMAP_FREE (def_loop_exits);\n }\n \n /* Add a loop-closing PHI for VAR in basic block EXIT.  */\n@@ -322,55 +317,72 @@ add_exit_phi (basic_block exit, tree var)\n    Exits of the loops are stored in LOOP_EXITS.  */\n \n static void\n-add_exit_phis_var (tree var, bitmap use_blocks, bitmap *loop_exits)\n+add_exit_phis_var (tree var, bitmap use_blocks, bitmap def_loop_exits)\n {\n   unsigned index;\n   bitmap_iterator bi;\n   basic_block def_bb = gimple_bb (SSA_NAME_DEF_STMT (var));\n-  bitmap live_exits = BITMAP_ALLOC (&loop_renamer_obstack);\n \n   gcc_checking_assert (! bitmap_bit_p (use_blocks, def_bb->index));\n \n-  compute_live_loop_exits (live_exits, use_blocks, loop_exits, def_bb);\n+  auto_bitmap live_exits (&loop_renamer_obstack);\n+  compute_live_loop_exits (live_exits, use_blocks, def_bb, def_loop_exits);\n \n   EXECUTE_IF_SET_IN_BITMAP (live_exits, 0, index, bi)\n     {\n       add_exit_phi (BASIC_BLOCK_FOR_FN (cfun, index), var);\n     }\n+}\n \n-  BITMAP_FREE (live_exits);\n+static int\n+loop_name_cmp (const void *p1, const void *p2)\n+{\n+  auto l1 = (const std::pair<int, int> *)p1;\n+  auto l2 = (const std::pair<int, int> *)p2;\n+  if (l1->first < l2->first)\n+    return -1;\n+  else if (l1->first > l2->first)\n+    return 1;\n+  return 0;\n }\n \n /* Add exit phis for the names marked in NAMES_TO_RENAME.\n    Exits of the loops are stored in EXITS.  Sets of blocks where the ssa\n    names are used are stored in USE_BLOCKS.  */\n \n static void\n-add_exit_phis (bitmap names_to_rename, bitmap *use_blocks, bitmap *loop_exits)\n+add_exit_phis (bitmap names_to_rename, bitmap *use_blocks)\n {\n   unsigned i;\n   bitmap_iterator bi;\n \n+  /* Sort names_to_rename after definition loop so we can avoid re-computing\n+     def_loop_exits.  */\n+  auto_vec<std::pair<int, int> > names (bitmap_count_bits (names_to_rename));\n   EXECUTE_IF_SET_IN_BITMAP (names_to_rename, 0, i, bi)\n     {\n-      add_exit_phis_var (ssa_name (i), use_blocks[i], loop_exits);\n+      tree name = ssa_name (i);\n+      loop_p def_loop = gimple_bb (SSA_NAME_DEF_STMT (name))->loop_father;\n+      names.quick_push (std::make_pair (def_loop->num, i));\n     }\n-}\n+  names.qsort (loop_name_cmp);\n \n-/* Fill the array of bitmaps LOOP_EXITS with all loop exit edge targets.  */\n-\n-static void\n-get_loops_exits (bitmap *loop_exits)\n-{\n-  unsigned j;\n-  edge e;\n-\n-  for (auto loop : loops_list (cfun, 0))\n+  auto_bitmap def_loop_exits (&loop_renamer_obstack);\n+  loop_p last_def_loop = NULL;\n+  for (auto p : names)\n     {\n-      auto_vec<edge> exit_edges = get_loop_exit_edges (loop);\n-      loop_exits[loop->num] = BITMAP_ALLOC (&loop_renamer_obstack);\n-      FOR_EACH_VEC_ELT (exit_edges, j, e)\n-        bitmap_set_bit (loop_exits[loop->num], e->dest->index);\n+      loop_p def_loop = get_loop (cfun, p.first);\n+      if (def_loop != last_def_loop)\n+\t{\n+\t  bitmap_clear (def_loop_exits);\n+\t  last_def_loop = def_loop;\n+\t  for (class loop *loop = def_loop; loop != current_loops->tree_root;\n+\t       loop = loop_outer (loop))\n+\t    for (auto exit = loop->exits->next; exit->e; exit = exit->next)\n+\t      bitmap_set_bit (def_loop_exits, exit->e->dest->index);\n+\t}\n+      add_exit_phis_var (ssa_name (p.second), use_blocks[p.second],\n+\t\t\t def_loop_exits);\n     }\n }\n \n@@ -566,16 +578,21 @@ rewrite_into_loop_closed_ssa_1 (bitmap changed_bbs, unsigned update_flag,\n \n   if (!bitmap_empty_p (names_to_rename))\n     {\n-      /* An array of bitmaps where LOOP_EXITS[I] is the set of basic blocks\n-\t that are the destination of an edge exiting loop number I.  */\n-      bitmap *loop_exits = XNEWVEC (bitmap, number_of_loops (cfun));\n-      get_loops_exits (loop_exits);\n+      bool release_recorded_exits_p = false;\n+      if (!loops_state_satisfies_p (LOOPS_HAVE_RECORDED_EXITS))\n+\t{\n+\t  /* Doing one scan over the whole function is cheaper than\n+\t     traversing the loop tree and gathering BBs of each loop.  */\n+\t  record_loop_exits ();\n+\t  release_recorded_exits_p = true;\n+\t}\n \n       /* Add the PHI nodes on exits of the loops for the names we need to\n \t rewrite.  */\n-      add_exit_phis (names_to_rename, use_blocks, loop_exits);\n+      add_exit_phis (names_to_rename, use_blocks);\n \n-      free (loop_exits);\n+      if (release_recorded_exits_p)\n+\trelease_recorded_exits (cfun);\n \n       /* Fix up all the names found to be used outside their original\n \t loops.  */"}]}