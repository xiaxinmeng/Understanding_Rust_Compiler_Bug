{"sha": "6ff37519800c8826818929eccef30412bc530483", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZmMzc1MTk4MDBjODgyNjgxODkyOWVjY2VmMzA0MTJiYzUzMDQ4Mw==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-07-17T11:40:54Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-07-17T11:40:54Z"}, "message": "re PR tree-optimization/81369 (ICE in generate_code_for_partition)\n\n\tPR target/81369\n\t* tree-loop-distribution.c (classify_partition): Only assert on\n\tnumer of iterations.\n\t(merge_dep_scc_partitions): Delete prameter.  Update function call.\n\t(distribute_loop): Remove code handling loop with unknown niters.\n\t(pass_loop_distribution::execute): Skip loop with unknown niters.\n\nFrom-SVN: r250270", "tree": {"sha": "731570b0db7b2f7dd2ccd7d32befa62a3e732a96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/731570b0db7b2f7dd2ccd7d32befa62a3e732a96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ff37519800c8826818929eccef30412bc530483", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ff37519800c8826818929eccef30412bc530483", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ff37519800c8826818929eccef30412bc530483", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ff37519800c8826818929eccef30412bc530483/comments", "author": null, "committer": null, "parents": [{"sha": "aa1528b5c91bd9fee1a7de9c6ebc28eff5040afd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa1528b5c91bd9fee1a7de9c6ebc28eff5040afd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa1528b5c91bd9fee1a7de9c6ebc28eff5040afd"}], "stats": {"total": 34, "additions": 21, "deletions": 13}, "files": [{"sha": "ce0b6cc4ebfd36affba098d2773dab070888b78c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ff37519800c8826818929eccef30412bc530483/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ff37519800c8826818929eccef30412bc530483/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6ff37519800c8826818929eccef30412bc530483", "patch": "@@ -1,3 +1,12 @@\n+2017-07-17  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR target/81369\n+\t* tree-loop-distribution.c (classify_partition): Only assert on\n+\tnumer of iterations.\n+\t(merge_dep_scc_partitions): Delete prameter.  Update function call.\n+\t(distribute_loop): Remove code handling loop with unknown niters.\n+\t(pass_loop_distribution::execute): Skip loop with unknown niters.\n+\n 2017-07-17  Bin Cheng  <bin.cheng@arm.com>\n \n \tPR target/81369"}, {"sha": "8d80cccf38f919ad675791a2c175e1c76ff5b5f2", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ff37519800c8826818929eccef30412bc530483/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ff37519800c8826818929eccef30412bc530483/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=6ff37519800c8826818929eccef30412bc530483", "patch": "@@ -1412,8 +1412,7 @@ classify_partition (loop_p loop, struct graph *rdg, partition *partition,\n     return;\n \n   nb_iter = number_of_latch_executions (loop);\n-  if (!nb_iter || nb_iter == chrec_dont_know)\n-    return;\n+  gcc_assert (nb_iter && nb_iter != chrec_dont_know);\n   if (dominated_by_p (CDI_DOMINATORS, single_exit (loop)->src,\n \t\t      gimple_bb (DR_STMT (single_store))))\n     plus_one = true;\n@@ -1962,18 +1961,16 @@ sort_partitions_by_post_order (struct graph *pg,\n }\n \n /* Given reduced dependence graph RDG merge strong connected components\n-   of PARTITIONS.  If IGNORE_ALIAS_P is true, data dependence caused by\n-   possible alias between references is ignored, as if it doesn't exist\n-   at all; otherwise all depdendences are considered.  */\n+   of PARTITIONS.  In this function, data dependence caused by possible\n+   alias between references is ignored, as if it doesn't exist at all.  */\n \n static void\n merge_dep_scc_partitions (struct graph *rdg,\n-\t\t\t  vec<struct partition *> *partitions,\n-\t\t\t  bool ignore_alias_p)\n+\t\t\t  vec<struct partition *> *partitions)\n {\n   struct partition *partition1, *partition2;\n   struct pg_vdata *data;\n-  graph *pg = build_partition_graph (rdg, partitions, ignore_alias_p);\n+  graph *pg = build_partition_graph (rdg, partitions, true);\n   int i, j, num_sccs = graphds_scc (pg, NULL);\n \n   /* Strong connected compoenent means dependence cycle, we cannot distribute\n@@ -2420,9 +2417,6 @@ distribute_loop (struct loop *loop, vec<gimple *> stmts,\n   auto_vec<struct partition *, 3> partitions;\n   rdg_build_partitions (rdg, stmts, &partitions);\n \n-  /* Can't do runtime alias check if loop niter is unknown.  */\n-  tree niters = number_of_latch_executions (loop);\n-  bool rt_alias_check_p = (niters != NULL_TREE && niters != chrec_dont_know);\n   auto_vec<ddr_p> alias_ddrs;\n \n   auto_bitmap stmt_in_all_partitions;\n@@ -2511,9 +2505,9 @@ distribute_loop (struct loop *loop, vec<gimple *> stmts,\n   /* Build the partition dependency graph.  */\n   if (partitions.length () > 1)\n     {\n-      merge_dep_scc_partitions (rdg, &partitions, rt_alias_check_p);\n+      merge_dep_scc_partitions (rdg, &partitions);\n       alias_ddrs.truncate (0);\n-      if (rt_alias_check_p && partitions.length () > 1)\n+      if (partitions.length () > 1)\n \tbreak_alias_scc_partitions (rdg, &partitions, &alias_ddrs);\n     }\n \n@@ -2654,6 +2648,11 @@ pass_loop_distribution::execute (function *fun)\n       if (!optimize_loop_for_speed_p (loop))\n \tcontinue;\n \n+      /* Don't distribute loop if niters is unknown.  */\n+      tree niters = number_of_latch_executions (loop);\n+      if (niters == NULL_TREE || niters == chrec_dont_know)\n+\tcontinue;\n+\n       /* Initialize the worklist with stmts we seed the partitions with.  */\n       bbs = get_loop_body_in_dom_order (loop);\n       for (i = 0; i < loop->num_nodes; ++i)"}]}