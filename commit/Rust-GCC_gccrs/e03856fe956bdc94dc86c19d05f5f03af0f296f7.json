{"sha": "e03856fe956bdc94dc86c19d05f5f03af0f296f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTAzODU2ZmU5NTZiZGM5NGRjODZjMTlkMDVmNWYwM2FmMGYyOTZmNw==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@redhat.com", "date": "2002-06-12T22:57:45Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2002-06-12T22:57:45Z"}, "message": "gengtype.h (xvasprintf): New prototype.\n\n\t* gengtype.h (xvasprintf): New prototype.\n\t(xasprintf): New prototype.\n\t(struct outf): New.\n\t(get_output_file): Return an outf_p.\n\t(header_file): Is now an outf_p.\n\t(base_files): Now are outf_p.\n\t(oprintf): New.\n\t* gengtype.c: Replace all output FILE * with outf_p; use oprintf\n\trather than stdio operations.  Use xasprintf in a few places,\n\twhen appropriate.\n\t(xvasprintf): New.\n\t(xasprintf): New.\n\t(struct filemap): Delete.\n\t(files): Delete.\n\t(output_files): New.\n\t(oprintf): New.\n\t(create_file): Create an outf_p.  Add parameter to indicate output\n\tfile name, change all callers.\n\t(open_base_files): Create gtype-desc.c here.\n\t(get_output_file_with_visibility): Rewrite.\n\t(get_output_file_name): Just look at 'name' field in struct outf.\n\t(close_output_files): Rewrite.\n\nFrom-SVN: r54566", "tree": {"sha": "7625beccd9803d12ee9437b5fcd7f9c4aaa581a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7625beccd9803d12ee9437b5fcd7f9c4aaa581a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e03856fe956bdc94dc86c19d05f5f03af0f296f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e03856fe956bdc94dc86c19d05f5f03af0f296f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e03856fe956bdc94dc86c19d05f5f03af0f296f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e03856fe956bdc94dc86c19d05f5f03af0f296f7/comments", "author": null, "committer": null, "parents": [{"sha": "83144cfcfaca44bb6d0cae7d2c0fa447193cb819", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83144cfcfaca44bb6d0cae7d2c0fa447193cb819", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83144cfcfaca44bb6d0cae7d2c0fa447193cb819"}], "stats": {"total": 612, "additions": 324, "deletions": 288}, "files": [{"sha": "f97a6399f1e5cf530db80c0a2eca7a45ca0fd728", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e03856fe956bdc94dc86c19d05f5f03af0f296f7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e03856fe956bdc94dc86c19d05f5f03af0f296f7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e03856fe956bdc94dc86c19d05f5f03af0f296f7", "patch": "@@ -1,3 +1,28 @@\n+2002-06-12  Geoffrey Keating  <geoffk@redhat.com>\n+\n+\t* gengtype.h (xvasprintf): New prototype.\n+\t(xasprintf): New prototype.\n+\t(struct outf): New.\n+\t(get_output_file): Return an outf_p.\n+\t(header_file): Is now an outf_p.\n+\t(base_files): Now are outf_p.\n+\t(oprintf): New.\n+\t* gengtype.c: Replace all output FILE * with outf_p; use oprintf\n+\trather than stdio operations.  Use xasprintf in a few places,\n+\twhen appropriate.\n+\t(xvasprintf): New.\n+\t(xasprintf): New.\n+\t(struct filemap): Delete.\n+\t(files): Delete.\n+\t(output_files): New.\n+\t(oprintf): New.\n+\t(create_file): Create an outf_p.  Add parameter to indicate output\n+\tfile name, change all callers.\n+\t(open_base_files): Create gtype-desc.c here.\n+\t(get_output_file_with_visibility): Rewrite.\n+\t(get_output_file_name): Just look at 'name' field in struct outf.\n+\t(close_output_files): Rewrite.\n+\n 2002-06-12  Jason Thorpe  <thorpej@wasabisystems.com>\n \n \t* config/vax/vax.h (MASK_UNIX_ASM, MASK_VAXC_ALIGNMENT)"}, {"sha": "28abf68ed858fe611f6ef9bdc875df6b2225b6c6", "filename": "gcc/gengtype.c", "status": "modified", "additions": 272, "deletions": 283, "changes": 555, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e03856fe956bdc94dc86c19d05f5f03af0f296f7/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e03856fe956bdc94dc86c19d05f5f03af0f296f7/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=e03856fe956bdc94dc86c19d05f5f03af0f296f7", "patch": "@@ -42,6 +42,34 @@ error_at_line VPARAMS ((struct fileloc *pos, const char *msg, ...))\n   VA_CLOSE (ap);\n }\n \n+/* vasprintf, but produces fatal message on out-of-memory.  */\n+int\n+xvasprintf (result, format, args)\n+     char ** result;\n+     const char *format;\n+     va_list args;\n+{\n+  int ret = vasprintf (result, format, args);\n+  if (*result == NULL || ret < 0)\n+    {\n+      fputs (\"gengtype: out of memory\", stderr);\n+      xexit (1);\n+    }\n+  return ret;\n+}\n+\n+/* Wrapper for xvasprintf.  */\n+char *\n+xasprintf VPARAMS ((const char *format, ...))\n+{\n+  char *result;\n+  VA_OPEN (ap, format);\n+  VA_FIXEDARG (ap, const char *, format);\n+  xvasprintf (&result, format, ap);\n+  VA_CLOSE (ap);\n+  return result;\n+}\n+\n /* The one and only TYPE_STRING.  */\n \n struct type string_type = {\n@@ -479,23 +507,12 @@ set_gc_used (variables)\n    (but some output files have many input files), and there is one .h file\n    for the whole build.  */\n \n-typedef struct filemap *filemap_p;\n-\n-struct filemap {\n-  filemap_p next;\n-  const char *input_name;\n-  const char *output_name;\n-  FILE *output;\n-};\n-\n /* The list of output files.  */\n-\n-static filemap_p files;\n+static outf_p output_files;\n \n /* The output header file that is included into pretty much every\n    source file.  */\n-\n-FILE * header_file;\n+outf_p header_file;\n \n enum {\n   BASE_FILE_C,\n@@ -509,16 +526,18 @@ static const char *lang_names[] = {\n   \"c\", \"objc\", \"cp\", \"treelang\", \"cobol\", \"f\", \"ada\", \"java\"\n };\n #define NUM_BASE_FILES (sizeof (lang_names) / sizeof (lang_names[0]))\n-FILE *base_files[NUM_BASE_FILES];\n+outf_p base_files[NUM_BASE_FILES];\n \n-static FILE * create_file PARAMS ((const char *));\n+static outf_p create_file PARAMS ((const char *, const char *));\n static const char * get_file_basename PARAMS ((const char *));\n \n-/* Create and return a FILE* for a new header file to be called NAME.  */\n+/* Create and return an outf_p for a new file for NAME, to be called\n+   ONAME.  */\n \n-static FILE *\n-create_file (name)\n+static outf_p\n+create_file (name, oname)\n      const char *name;\n+     const char *oname;\n {\n   static const char *const hdr[] = {\n     \"   Copyright (C) 2002 Free Software Foundation, Inc.\\n\",\n@@ -542,44 +561,80 @@ create_file (name)\n     \"\\n\",\n     \"/* This file is machine generated.  Do not edit.  */\\n\"\n   };\n-  FILE *f;\n+  outf_p f;\n   size_t i;\n   \n-  f = tmpfile();\n-  if (f == NULL)\n-    {\n-      perror (\"couldn't create temporary file\");\n-      exit (1);\n-    }\n-  fprintf (f, \"/* Type information for %s.\\n\", name);\n+  f = xcalloc (sizeof (*f), 1);\n+  f->next = output_files;\n+  f->name = oname;\n+  output_files = f;\n+\n+  oprintf (f, \"/* Type information for %s.\\n\", name);\n   for (i = 0; i < sizeof(hdr)/sizeof(hdr[0]); i++)\n-    fputs (hdr[i], f);\n+    oprintf (f, \"%s\", hdr[i]);\n   return f;\n }\n \n+/* Print, like fprintf, to O.  */\n+void \n+oprintf VPARAMS ((outf_p o, const char *format, ...))\n+{\n+  char *s;\n+  size_t slength;\n+  \n+  VA_OPEN (ap, format);\n+  VA_FIXEDARG (ap, outf_p, o);\n+  VA_FIXEDARG (ap, const char *, format);\n+  slength = xvasprintf (&s, format, ap);\n+  VA_CLOSE (ap);\n+\n+  if (o->bufused + slength > o->buflength)\n+    {\n+      size_t new_len = o->buflength;\n+      if (new_len == 0)\n+\tnew_len = 1024;\n+      do {\n+\tnew_len *= 2;\n+      } while (o->bufused + slength >= new_len);\n+      o->buf = xrealloc (o->buf, new_len);\n+      o->buflength = new_len;\n+    }\n+  memcpy (o->buf + o->bufused, s, slength);\n+  o->bufused += slength;\n+  free (s);\n+}\n+\n /* Open the global header file and the language-specific header files.  */\n \n static void\n open_base_files (void)\n {\n   size_t i;\n   \n-  header_file = create_file (\"GCC\");\n+  header_file = create_file (\"GCC\", \"gtype-desc.h\");\n \n   for (i = 0; i < NUM_BASE_FILES; i++)\n-    {\n-      filemap_p newf;\n-      char *s;\n+    base_files[i] = create_file (lang_names[i], \n+\t\t\t\t xasprintf (\"gtype-%s.h\", lang_names[i]));\n+\n+  /* gtype-desc.c is a little special, so we create it here.  */\n+  {\n+    /* The order of files here matters very much.  */\n+    static const char *const ifiles [] = {\n+      \"config.h\", \"system.h\", \"varray.h\", \"hashtab.h\",\n+      \"bitmap.h\", \"tree.h\", \"rtl.h\", \"function.h\", \"insn-config.h\",\n+      \"expr.h\", \"hard-reg-set.h\", \"basic-block.h\", \"cselib.h\",\n+      \"insn-addr.h\", \"ssa.h\", \"optabs.h\", \"libfuncs.h\",\n+      \"debug.h\", \"ggc.h\",\n+      NULL\n+    };\n+    const char *const *ifp;\n+    outf_p gtype_desc_c;\n       \n-      base_files[i] = create_file (lang_names[i]);\n-      newf = xmalloc (sizeof (*newf));\n-      newf->next = files;\n-      files = newf;\n-      newf->input_name = NULL;\n-      newf->output = base_files[i];\n-      newf->output_name = s = xmalloc (16);\n-      sprintf (s, \"gtype-%s.h\", lang_names[i]);\n-    }\n+    gtype_desc_c = create_file (\"GCC\", \"gtype-desc.c\");\n+    for (ifp = ifiles; *ifp; ifp++)\n+      oprintf (gtype_desc_c, \"#include \\\"%s\\\"\\n\", *ifp);\n+  }\n }\n \n #define startswith(len, c, s)  \\\n@@ -664,25 +719,22 @@ get_base_file_bitmap (input_file)\n    made in INPUT_FILE and is linked into every language that uses\n    INPUT_FILE.  */\n \n-FILE *\n+outf_p\n get_output_file_with_visibility (input_file)\n      const char *input_file;\n {\n-  filemap_p fm, fmo;\n+  outf_p r;\n   size_t len;\n   const char *basename;\n+  const char *for_name;\n+  const char *output_name;\n \n-  /* Do we already know the file?  */\n-  for (fm = files; fm; fm = fm->next)\n-    if (input_file == fm->input_name)\n-      return fm->output;\n+  /* This can happen when we need a file with visibility on a\n+     structure that we've never seen.  We have to just hope that it's\n+     globally visible.  */\n+  if (input_file == NULL)\n+    input_file = \"system.h\";\n \n-  /* No, we'll be creating a new filemap.  */\n-  fm = xmalloc (sizeof (*fm));\n-  fm->next = files;\n-  files = fm;\n-  fm->input_name = input_file;\n-  \n   /* Determine the output file name.  */\n   basename = get_file_basename (input_file);\n \n@@ -693,72 +745,39 @@ get_output_file_with_visibility (input_file)\n     {\n       char *s;\n       \n-      fm->output_name = s = xmalloc (sizeof (\"gt-\") + len);\n-      sprintf (s, \"gt-%s\", basename);\n+      output_name = s = xasprintf (\"gt-%s\", basename);\n       for (; *s != '.'; s++)\n \tif (! ISALNUM (*s) && *s != '-')\n \t  *s = '-';\n       memcpy (s, \".h\", sizeof (\".h\"));\n+      for_name = basename;\n     }\n   else if (strcmp (basename, \"c-common.h\") == 0)\n-    fm->output_name = \"gt-c-common.h\";\n+    output_name = \"gt-c-common.h\", for_name = \"c-common.c\";\n   else if (strcmp (basename, \"c-tree.h\") == 0)\n-    fm->output_name = \"gt-c-decl.h\";\n+    output_name = \"gt-c-decl.h\", for_name = \"c-decl.c\";\n   else \n     {\n       size_t i;\n       \n-      fm->output_name = \"gtype-desc.c\";\n       for (i = 0; i < NUM_BASE_FILES; i++)\n \tif (memcmp (basename, lang_names[i], strlen (lang_names[i])) == 0\n \t    && basename[strlen(lang_names[i])] == '/')\n-\t  {\n-\t    char *s;\n-\t    \n-\t    s = xmalloc (16);\n-\t    sprintf (s, \"gtype-%s.h\", lang_names[i]);\n-\t    fm->output_name = s;\n-\t    break;\n-\t  }\n+\t  return base_files[i];\n+\n+      output_name = \"gtype-desc.c\";\n+      for_name = NULL;\n     }\n \n   /* Look through to see if we've ever seen this output filename before.  */\n-  for (fmo = fm->next; fmo; fmo = fmo->next)\n-    if (strcmp (fmo->output_name, fm->output_name) == 0)\n-      {\n-\tfm->output = fmo->output;\n-\tbreak;\n-      }\n+  for (r = output_files; r; r = r->next)\n+    if (strcmp (r->name, output_name) == 0)\n+      return r;\n \n   /* If not, create it.  */\n-  if (fmo == NULL)\n-    {\n-      fm->output = create_file (fm->output_name);\n-      if (strcmp (fm->output_name, \"gtype-desc.c\") == 0)\n-\t{\n-\t  fputs (\"#include \\\"config.h\\\"\\n\", fm->output);\n-\t  fputs (\"#include \\\"system.h\\\"\\n\", fm->output);\n-\t  fputs (\"#include \\\"varray.h\\\"\\n\", fm->output);\n-\t  fputs (\"#include \\\"hashtab.h\\\"\\n\", fm->output);\n-\t  fputs (\"#include \\\"bitmap.h\\\"\\n\", fm->output);\n-\t  fputs (\"#include \\\"tree.h\\\"\\n\", fm->output);\n-\t  fputs (\"#include \\\"rtl.h\\\"\\n\", fm->output);\n-\t  fputs (\"#include \\\"function.h\\\"\\n\", fm->output);\n-\t  fputs (\"#include \\\"insn-config.h\\\"\\n\", fm->output);\n-\t  fputs (\"#include \\\"expr.h\\\"\\n\", fm->output);\n-\t  fputs (\"#include \\\"hard-reg-set.h\\\"\\n\", fm->output);\n-\t  fputs (\"#include \\\"basic-block.h\\\"\\n\", fm->output);\n-\t  fputs (\"#include \\\"cselib.h\\\"\\n\", fm->output);\n-\t  fputs (\"#include \\\"insn-addr.h\\\"\\n\", fm->output);\n-\t  fputs (\"#include \\\"ssa.h\\\"\\n\", fm->output);\n-\t  fputs (\"#include \\\"optabs.h\\\"\\n\", fm->output);\n-\t  fputs (\"#include \\\"libfuncs.h\\\"\\n\", fm->output);\n-\t  fputs (\"#include \\\"debug.h\\\"\\n\", fm->output);\n-\t  fputs (\"#include \\\"ggc.h\\\"\\n\", fm->output);\n-\t}\n-    }\n+  r = create_file (for_name, output_name);\n \n-  return fm->output;\n+  return r;\n }\n \n /* The name of an output file, suitable for definitions, that can see\n@@ -769,105 +788,80 @@ const char *\n get_output_file_name (input_file)\n      const char *input_file;\n {\n-  filemap_p fm;\n-\n-  for (fm = files; fm; fm = fm->next)\n-    if (input_file == fm->input_name)\n-      return fm->output_name;\n-  (void) get_output_file_with_visibility (input_file);\n-  return get_output_file_name (input_file);\n+  return get_output_file_with_visibility (input_file)->name;\n }\n \n-/* Close all output files and copy them to their final destinations,\n+/* Copy the output to its final destination,\n    but don't unnecessarily change modification times.  */\n \n static void\n close_output_files PARAMS ((void))\n {\n-  filemap_p fm;\n-  struct filemap header;\n-  header.next = files;\n-  header.output_name = \"gtype-desc.h\";\n-  header.output = header_file;\n+  outf_p of;\n   \n-  for (fm = &header; fm; fm = fm->next)\n+  for (of = output_files; of; of = of->next)\n     {\n-      int no_write_p;\n-      filemap_p ofm;\n-      FILE *newfile;\n-      \n-      /* Handle each output file once.  */\n-      if (fm->output == NULL)\n-\tcontinue;\n-      \n-      for (ofm = fm->next; ofm; ofm = ofm->next)\n-\tif (fm->output == ofm->output)\n-\t  ofm->output = NULL;\n-      \n-      /* Compare the output file with the file to be created, avoiding\n-\t unnecessarily changing timestamps.  */\n-      newfile = fopen (fm->output_name, \"r\");\n-      if (newfile != NULL)\n+      FILE * newfile;\n+\n+      newfile = fopen (of->name, \"r\");\n+      if (newfile != NULL )\n \t{\n-\t  int ch1, ch2;\n-\t  \n-\t  rewind (fm->output);\n-\t  do {\n-\t    ch1 = fgetc (fm->output);\n-\t    ch2 = fgetc (newfile);\n-\t  } while (ch1 != EOF && ch1 == ch2);\n+\t  int no_write_p;\n+\t  size_t i;\n \n+\t  for (i = 0; i < of->bufused; i++)\n+\t    {\n+\t      int ch;\n+\t      ch = fgetc (newfile);\n+\t      if (ch == EOF || ch != (unsigned char) of->buf[i])\n+\t\tbreak;\n+\t    }\n+\t  no_write_p = i == of->bufused && fgetc (newfile) == EOF;\n \t  fclose (newfile);\n-\t  \n-\t  no_write_p = ch1 == ch2;\n-\t}\n-      else\n-\tno_write_p = 0;\n-     \n-      /* Nothing interesting to do.  Close the output file.  */\n-      if (no_write_p)\n-\t{\n-\t  fclose (fm->output);\n-\t  continue;\n+\n+\t  if (no_write_p)\n+\t    continue;\n \t}\n \n-      newfile = fopen (fm->output_name, \"w\");\n+      newfile = fopen (of->name, \"w\");\n       if (newfile == NULL)\n \t{\n \t  perror (\"opening output file\");\n \t  exit (1);\n \t}\n-      {\n-\tint ch;\n-\trewind (fm->output);\n-\twhile ((ch = fgetc (fm->output)) != EOF)\n-\t  fputc (ch, newfile);\n-      }\n-      fclose (newfile);\n-      fclose (fm->output);\n+      if (fwrite (of->buf, 1, of->bufused, newfile) != of->bufused)\n+\t{\n+\t  perror (\"writing output file\");\n+\t  exit (1);\n+\t}\n+      if (fclose (newfile) != 0)\n+\t{\n+\t  perror (\"closing output file\");\n+\t  exit (1);\n+\t}\n     }\n }\n \f\n struct flist {\n   struct flist *next;\n   int started_p;\n   const char *name;\n-  FILE *f;\n+  outf_p f;\n };\n \n-static void output_escaped_param PARAMS ((FILE *, const char *, const char *,\n+static void output_escaped_param PARAMS ((outf_p , const char *, const char *,\n \t\t\t\t\t  const char *, const char *,\n \t\t\t\t\t  struct fileloc *));\n static void write_gc_structure_fields \n-  PARAMS ((FILE *, type_p, const char *, const char *, options_p, \n+  PARAMS ((outf_p , type_p, const char *, const char *, options_p, \n \t   int, struct fileloc *, lang_bitmap, type_p));\n static void write_gc_marker_routine_for_structure PARAMS ((type_p, type_p));\n static void write_gc_types PARAMS ((type_p structures, type_p param_structs));\n-static void put_mangled_filename PARAMS ((FILE *, const char *));\n+static void put_mangled_filename PARAMS ((outf_p , const char *));\n static void finish_root_table PARAMS ((struct flist *flp, const char *pfx, \n \t\t\t\t       const char *tname, const char *lastname,\n \t\t\t\t       const char *name));\n-static void write_gc_root PARAMS ((FILE *, pair_p, type_p, const char *, int,\n+static void write_gc_root PARAMS ((outf_p , pair_p, type_p, const char *, int,\n \t\t\t\t   struct fileloc *, const char *));\n static void write_gc_roots PARAMS ((pair_p));\n \n@@ -879,7 +873,7 @@ static int gc_counter;\n \n static void\n output_escaped_param (of, param, val, prev_val, oname, line)\n-     FILE *of;\n+     outf_p of;\n      const char *param;\n      const char *val;\n      const char *prev_val;\n@@ -890,13 +884,13 @@ output_escaped_param (of, param, val, prev_val, oname, line)\n   \n   for (p = param; *p; p++)\n     if (*p != '%')\n-      fputc (*p, of);\n+      oprintf (of, \"%c\", *p);\n     else if (*++p == 'h')\n-      fprintf (of, \"(%s)\", val);\n+      oprintf (of, \"(%s)\", val);\n     else if (*p == '0')\n-      fputs (\"(*x)\", of);\n+      oprintf (of, \"(*x)\");\n     else if (*p == '1')\n-      fprintf (of, \"(%s)\", prev_val);\n+      oprintf (of, \"(%s)\", prev_val);\n     else\n       error_at_line (line, \"`%s' option contains bad escape %c%c\",\n \t\t     oname, '%', *p);\n@@ -912,7 +906,7 @@ output_escaped_param (of, param, val, prev_val, oname, line)\n static void\n write_gc_structure_fields (of, s, val, prev_val, opts, indent, line, bitmap,\n \t\t\t   param)\n-     FILE *of;\n+     outf_p of;\n      type_p s;\n      const char *val;\n      const char *prev_val;\n@@ -948,11 +942,11 @@ write_gc_structure_fields (of, s, val, prev_val, opts, indent, line, bitmap,\n \t  error_at_line (line, \"missing `desc' option\");\n \t}\n \n-      fprintf (of, \"%*s{\\n\", indent, \"\");\n+      oprintf (of, \"%*s{\\n\", indent, \"\");\n       indent += 2;\n-      fprintf (of, \"%*sunsigned int tag%d = (\", indent, \"\", tagcounter);\n+      oprintf (of, \"%*sunsigned int tag%d = (\", indent, \"\", tagcounter);\n       output_escaped_param (of, tagexpr, val, prev_val, \"desc\", line);\n-      fputs (\");\\n\", of);\n+      oprintf (of, \");\\n\");\n     }\n   \n   for (f = s->u.s.fields; f; f = f->next)\n@@ -1034,7 +1028,7 @@ write_gc_structure_fields (of, s, val, prev_val, opts, indent, line, bitmap,\n \t      error_at_line (&f->line, \"field `%s' has no tag\", f->name);\n \t      continue;\n \t    }\n-\t  fprintf (of, \"%*sif (tag%d == (%s)) {\\n\", indent, \"\", \n+\t  oprintf (of, \"%*sif (tag%d == (%s)) {\\n\", indent, \"\", \n \t\t   tagcounter, tagid);\n \t  indent += 2;\n \t}\n@@ -1067,8 +1061,7 @@ write_gc_structure_fields (of, s, val, prev_val, opts, indent, line, bitmap,\n \t  {\n \t    char *newval;\n \n-\t    newval = xmalloc (strlen (val) + sizeof (\".\") + strlen (f->name));\n-\t    sprintf (newval, \"%s.%s\", val, f->name);\n+\t    newval = xasprintf (\"%s.%s\", val, f->name);\n \t    write_gc_structure_fields (of, t, newval, val, f->opt, indent, \n \t\t\t\t       &f->line, bitmap, param);\n \t    free (newval);\n@@ -1080,13 +1073,13 @@ write_gc_structure_fields (of, s, val, prev_val, opts, indent, line, bitmap,\n \t    {\n \t      if (maybe_undef_p\n \t\t  && t->u.p->u.s.line.file == NULL)\n-\t\tfprintf (of, \"%*sif (%s.%s) abort();\\n\", indent, \"\",\n+\t\toprintf (of, \"%*sif (%s.%s) abort();\\n\", indent, \"\",\n \t\t\t val, f->name);\n \t      else if (UNION_OR_STRUCT_P (t->u.p))\n-\t\tfprintf (of, \"%*sgt_ggc_m_%s (%s.%s);\\n\", indent, \"\", \n+\t\toprintf (of, \"%*sgt_ggc_m_%s (%s.%s);\\n\", indent, \"\", \n \t\t\t t->u.p->u.s.tag, val, f->name);\n \t      else if (t->u.p->kind == TYPE_PARAM_STRUCT)\n-\t\tfprintf (of, \"%*sgt_ggc_mm_%d%s_%s (%s.%s);\\n\", indent, \"\",\n+\t\toprintf (of, \"%*sgt_ggc_mm_%d%s_%s (%s.%s);\\n\", indent, \"\",\n \t\t\t (int) strlen (t->u.p->u.param_struct.param->u.s.tag),\n \t\t\t t->u.p->u.param_struct.param->u.s.tag,\n \t\t\t t->u.p->u.param_struct.stru->u.s.tag,\n@@ -1098,22 +1091,22 @@ write_gc_structure_fields (of, s, val, prev_val, opts, indent, line, bitmap,\n \t    }\n \t  else if (t->u.p->kind == TYPE_SCALAR\n \t\t   || t->u.p->kind == TYPE_STRING)\n-\t    fprintf (of, \"%*sggc_mark (%s.%s);\\n\", indent, \"\", \n+\t    oprintf (of, \"%*sggc_mark (%s.%s);\\n\", indent, \"\", \n \t\t     val, f->name);\n \t  else\n \t    {\n \t      int loopcounter = ++gc_counter;\n \t      \n-\t      fprintf (of, \"%*sif (%s.%s != NULL) {\\n\", indent, \"\",\n+\t      oprintf (of, \"%*sif (%s.%s != NULL) {\\n\", indent, \"\",\n \t\t       val, f->name);\n \t      indent += 2;\n-\t      fprintf (of, \"%*ssize_t i%d;\\n\", indent, \"\", loopcounter);\n-\t      fprintf (of, \"%*sggc_set_mark (%s.%s);\\n\", indent, \"\", \n+\t      oprintf (of, \"%*ssize_t i%d;\\n\", indent, \"\", loopcounter);\n+\t      oprintf (of, \"%*sggc_set_mark (%s.%s);\\n\", indent, \"\", \n \t\t       val, f->name);\n-\t      fprintf (of, \"%*sfor (i%d = 0; i%d < (\", indent, \"\", \n+\t      oprintf (of, \"%*sfor (i%d = 0; i%d < (\", indent, \"\", \n \t\t       loopcounter, loopcounter);\n \t      output_escaped_param (of, length, val, prev_val, \"length\", line);\n-\t      fprintf (of, \"); i%d++) {\\n\", loopcounter);\n+\t      oprintf (of, \"); i%d++) {\\n\", loopcounter);\n \t      indent += 2;\n \t      switch (t->u.p->kind)\n \t\t{\n@@ -1122,8 +1115,8 @@ write_gc_structure_fields (of, s, val, prev_val, opts, indent, line, bitmap,\n \t\t  {\n \t\t    char *newval;\n \t\t    \n-\t\t    newval = xmalloc (strlen (val) + 8 + strlen (f->name));\n-\t\t    sprintf (newval, \"%s.%s[i%d]\", val, f->name, loopcounter);\n+\t\t    newval = xasprintf (\"%s.%s[i%d]\", val, f->name, \n+\t\t\t\t\tloopcounter);\n \t\t    write_gc_structure_fields (of, t->u.p, newval, val,\n \t\t\t\t\t       f->opt, indent, &f->line,\n \t\t\t\t\t       bitmap, param);\n@@ -1132,7 +1125,7 @@ write_gc_structure_fields (of, s, val, prev_val, opts, indent, line, bitmap,\n \t\t  }\n \t\tcase TYPE_POINTER:\n \t\t  if (UNION_OR_STRUCT_P (t->u.p->u.p))\n-\t\t    fprintf (of, \"%*sgt_ggc_m_%s (%s.%s[i%d]);\\n\", indent, \"\", \n+\t\t    oprintf (of, \"%*sgt_ggc_m_%s (%s.%s[i%d]);\\n\", indent, \"\", \n \t\t\t     t->u.p->u.p->u.s.tag, val, f->name,\n \t\t\t     loopcounter);\n \t\t  else\n@@ -1147,9 +1140,9 @@ write_gc_structure_fields (of, s, val, prev_val, opts, indent, line, bitmap,\n \t\t  break;\n \t\t}\n \t      indent -= 2;\n-\t      fprintf (of, \"%*s}\\n\", indent, \"\");\n+\t      oprintf (of, \"%*s}\\n\", indent, \"\");\n \t      indent -= 2;\n-\t      fprintf (of, \"%*s}\\n\", indent, \"\");\n+\t      oprintf (of, \"%*s}\\n\", indent, \"\");\n \t    }\n \t  break;\n \n@@ -1173,37 +1166,37 @@ write_gc_structure_fields (of, s, val, prev_val, opts, indent, line, bitmap,\n \t\t|| ta->kind == TYPE_STRING)\n \t      break;\n \n-\t    fprintf (of, \"%*s{\\n\", indent, \"\");\n+\t    oprintf (of, \"%*s{\\n\", indent, \"\");\n \t    indent += 2;\n \n \t    if (special != NULL && strcmp (special, \"tree_exp\") == 0)\n \t      {\n-\t\tfprintf (of, \"%*sconst size_t tree_exp_size = (\",\n+\t\toprintf (of, \"%*sconst size_t tree_exp_size = (\",\n                          indent, \"\");\n \t\toutput_escaped_param (of, length, val, prev_val,\n \t\t\t\t      \"length\", line);\n-\t\tfputs (\");\\n\", of);\n+\t\toprintf (of, \");\\n\");\n \n \t\tlength = \"first_rtl_op (TREE_CODE ((tree)&%h))\";\n \t      }\n \n \t    for (ta = t, i = 0; ta->kind == TYPE_ARRAY; ta = ta->u.a.p, i++)\n \t      {\n-\t\tfprintf (of, \"%*ssize_t i%d_%d;\\n\", \n+\t\toprintf (of, \"%*ssize_t i%d_%d;\\n\", \n \t\t\t indent, \"\", loopcounter, i);\n-\t\tfprintf (of, \"%*sconst size_t ilimit%d_%d = (\",\n+\t\toprintf (of, \"%*sconst size_t ilimit%d_%d = (\",\n \t\t\t indent, \"\", loopcounter, i);\n \t\tif (i == 0 && length != NULL)\n \t\t  output_escaped_param (of, length, val, prev_val, \n \t\t\t\t\t\"length\", line);\n \t\telse\n-\t\t  fputs (ta->u.a.len, of);\n-\t\tfputs (\");\\n\", of);\n+\t\t  oprintf (of, \"%s\", ta->u.a.len);\n+\t\toprintf (of, \");\\n\");\n \t      }\n \t\t\n \t    for (ta = t, i = 0; ta->kind == TYPE_ARRAY; ta = ta->u.a.p, i++)\n \t      {\n-\t\tfprintf (of, \n+\t\toprintf (of, \n \t\t \"%*sfor (i%d_%d = 0; i%d_%d < ilimit%d_%d; i%d_%d++) {\\n\",\n \t\t\t indent, \"\", loopcounter, i, loopcounter, i,\n \t\t\t loopcounter, i, loopcounter, i);\n@@ -1214,13 +1207,13 @@ write_gc_structure_fields (of, s, val, prev_val, opts, indent, line, bitmap,\n \t\t&& (ta->u.p->kind == TYPE_STRUCT\n \t\t    || ta->u.p->kind == TYPE_UNION))\n \t      {\n-\t\tfprintf (of, \"%*sgt_ggc_m_%s (%s.%s\", \n+\t\toprintf (of, \"%*sgt_ggc_m_%s (%s.%s\", \n \t\t\t indent, \"\", ta->u.p->u.s.tag, val, f->name);\n \t\tfor (ta = t, i = 0; \n \t\t     ta->kind == TYPE_ARRAY; \n \t\t     ta = ta->u.a.p, i++)\n-\t\t  fprintf (of, \"[i%d_%d]\", loopcounter, i);\n-\t\tfputs (\");\\n\", of);\n+\t\t  oprintf (of, \"[i%d_%d]\", loopcounter, i);\n+\t\toprintf (of, \");\\n\");\n \t      }\n \t    else if (ta->kind == TYPE_STRUCT || ta->kind == TYPE_UNION)\n \t      {\n@@ -1245,29 +1238,29 @@ write_gc_structure_fields (of, s, val, prev_val, opts, indent, line, bitmap,\n \t      }\n \t    else if (ta->kind == TYPE_POINTER && ta->u.p->kind == TYPE_SCALAR\n \t\t     && use_param_p && param == NULL)\n-\t      fprintf (of, \"%*sabort();\\n\", indent, \"\");\n+\t      oprintf (of, \"%*sabort();\\n\", indent, \"\");\n \t    else\n \t      error_at_line (&f->line, \n \t\t\t     \"field `%s' is array of unimplemented type\",\n \t\t\t     f->name);\n \t    for (ta = t, i = 0; ta->kind == TYPE_ARRAY; ta = ta->u.a.p, i++)\n \t      {\n \t\tindent -= 2;\n-\t\tfprintf (of, \"%*s}\\n\", indent, \"\");\n+\t\toprintf (of, \"%*s}\\n\", indent, \"\");\n \t      }\n \n \t    if (special != NULL && strcmp (special, \"tree_exp\") == 0)\n \t      {\n-\t\tfprintf (of, \n+\t\toprintf (of, \n \t\t \"%*sfor (; i%d_0 < tree_exp_size; i%d_0++)\\n\",\n \t\t\t indent, \"\", loopcounter, loopcounter);\n-\t\tfprintf (of, \"%*s  gt_ggc_m_rtx_def (%s.%s[i%d_0]);\\n\",\n+\t\toprintf (of, \"%*s  gt_ggc_m_rtx_def (%s.%s[i%d_0]);\\n\",\n \t\t\t indent, \"\", val, f->name, loopcounter);\n \t\tspecial = NULL;\n \t      }\n \n \t    indent -= 2;\n-\t    fprintf (of, \"%*s}\\n\", indent, \"\");\n+\t    oprintf (of, \"%*s}\\n\", indent, \"\");\n \t    break;\n \t  }\n \n@@ -1281,15 +1274,15 @@ write_gc_structure_fields (of, s, val, prev_val, opts, indent, line, bitmap,\n       if (s->kind == TYPE_UNION && ! always_p )\n \t{\n \t  indent -= 2;\n-\t  fprintf (of, \"%*s}\\n\", indent, \"\");\n+\t  oprintf (of, \"%*s}\\n\", indent, \"\");\n \t}\n       if (special)\n \terror_at_line (&f->line, \"unhandled special `%s'\", special);\n     }\n   if (s->kind == TYPE_UNION)\n     {\n       indent -= 2;\n-      fprintf (of, \"%*s}\\n\", indent, \"\");\n+      oprintf (of, \"%*s}\\n\", indent, \"\");\n     }\n }\n \n@@ -1301,33 +1294,33 @@ write_gc_marker_routine_for_structure (s, param)\n      type_p s;\n      type_p param;\n {\n-  FILE *f;\n+  outf_p f;\n   if (param == NULL)\n     f = get_output_file_with_visibility (s->u.s.line.file);\n   else\n     f = get_output_file_with_visibility (param->u.s.line.file);\n   \n-  fputc ('\\n', f);\n-  fputs (\"void\\n\", f);\n+  oprintf (f, \"%c\", '\\n');\n+  oprintf (f, \"void\\n\");\n   if (param == NULL)\n-    fprintf (f, \"gt_ggc_mx_%s (x_p)\\n\", s->u.s.tag);\n+    oprintf (f, \"gt_ggc_mx_%s (x_p)\\n\", s->u.s.tag);\n   else\n-    fprintf (f, \"gt_ggc_mm_%d%s_%s (x_p)\\n\", (int) strlen (param->u.s.tag),\n+    oprintf (f, \"gt_ggc_mm_%d%s_%s (x_p)\\n\", (int) strlen (param->u.s.tag),\n \t     param->u.s.tag, s->u.s.tag);\n-  fputs (\"      void *x_p;\\n\", f);\n-  fputs (\"{\\n\", f);\n-  fprintf (f, \"  %s %s * const x = (%s %s *)x_p;\\n\",\n+  oprintf (f, \"      void *x_p;\\n\");\n+  oprintf (f, \"{\\n\");\n+  oprintf (f, \"  %s %s * const x = (%s %s *)x_p;\\n\",\n \t   s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag,\n \t   s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag);\n-  fputs (\"  if (! ggc_test_and_set_mark (x))\\n\", f);\n-  fputs (\"    return;\\n\", f);\n+  oprintf (f, \"  if (! ggc_test_and_set_mark (x))\\n\");\n+  oprintf (f, \"    return;\\n\");\n   \n   gc_counter = 0;\n   write_gc_structure_fields (f, s, \"(*x)\", \"not valid postage\",\n \t\t\t     s->u.s.opt, 2, &s->u.s.line, s->u.s.bitmap,\n \t\t\t     param);\n   \n-  fputs (\"}\\n\", f);\n+  oprintf (f, \"}\\n\");\n }\n \n /* Write out marker routines for STRUCTURES and PARAM_STRUCTS.  */\n@@ -1339,7 +1332,7 @@ write_gc_types (structures, param_structs)\n {\n   type_p s;\n   \n-  fputs (\"\\n/* GC marker procedures.  */\\n\", header_file);\n+  oprintf (header_file, \"\\n/* GC marker procedures.  */\\n\");\n   for (s = structures; s; s = s->next)\n     if (s->gc_used == GC_POINTED_TO\n \t|| s->gc_used == GC_MAYBE_POINTED_TO)\n@@ -1350,11 +1343,11 @@ write_gc_types (structures, param_structs)\n \t    && s->u.s.line.file == NULL)\n \t  continue;\n \n-\tfprintf (header_file,\n+\toprintf (header_file,\n \t\t \"#define gt_ggc_m_%s(X) do { \\\\\\n\", s->u.s.tag);\n-\tfprintf (header_file,\n+\toprintf (header_file,\n \t\t \"  if (X != NULL) gt_ggc_mx_%s (X);\\\\\\n\", s->u.s.tag);\n-\tfprintf (header_file,\n+\toprintf (header_file,\n \t\t \"  } while (0)\\n\");\n \t\n \tfor (opt = s->u.s.opt; opt; opt = opt->next)\n@@ -1364,7 +1357,7 @@ write_gc_types (structures, param_structs)\n \t      if (t->kind == TYPE_STRUCT \n \t\t  || t->kind == TYPE_UNION\n \t\t  || t->kind == TYPE_LANG_STRUCT)\n-\t\tfprintf (header_file,\n+\t\toprintf (header_file,\n \t\t\t \"#define gt_ggc_mx_%s gt_ggc_mx_%s\\n\",\n \t\t\t s->u.s.tag, t->u.s.tag);\n \t      else\n@@ -1376,7 +1369,7 @@ write_gc_types (structures, param_structs)\n \t  continue;\n \n \t/* Declare the marker procedure only once.  */\n-\tfprintf (header_file, \n+\toprintf (header_file, \n \t\t \"extern void gt_ggc_mx_%s PARAMS ((void *));\\n\",\n \t\t s->u.s.tag);\n   \n@@ -1412,7 +1405,7 @@ write_gc_types (structures, param_structs)\n \t  }\n \t\n \t/* Declare the marker procedure.  */\n-\tfprintf (header_file, \n+\toprintf (header_file, \n \t\t \"extern void gt_ggc_mm_%d%s_%s PARAMS ((void *));\\n\",\n \t\t (int) strlen (param->u.s.tag), param->u.s.tag,\n \t\t stru->u.s.tag);\n@@ -1439,15 +1432,15 @@ write_gc_types (structures, param_structs)\n \n static void\n put_mangled_filename (f, fn)\n-     FILE *f;\n+     outf_p f;\n      const char *fn;\n {\n   const char *name = get_output_file_name (fn);\n   for (; *name != 0; name++)\n     if (ISALNUM (*name))\n-      fputc (*name, f);\n+      oprintf (f, \"%c\", *name);\n     else\n-      fputc ('_', f);\n+      oprintf (f, \"%c\", '_');\n }\n \n /* Finish off the currently-created root tables in FLP.  PFX, TNAME,\n@@ -1468,8 +1461,8 @@ finish_root_table (flp, pfx, lastname, tname, name)\n   for (fli2 = flp; fli2; fli2 = fli2->next)\n     if (fli2->started_p)\n       {\n-\tfprintf (fli2->f, \"  %s\\n\", lastname);\n-\tfputs (\"};\\n\\n\", fli2->f);\n+\toprintf (fli2->f, \"  %s\\n\", lastname);\n+\toprintf (fli2->f, \"};\\n\\n\");\n       }\n \n   for (fli2 = flp; fli2; fli2 = fli2->next)\n@@ -1481,11 +1474,11 @@ finish_root_table (flp, pfx, lastname, tname, name)\n \tfor (fnum = 0; bitmap != 0; fnum++, bitmap >>= 1)\n \t  if (bitmap & 1)\n \t    {\n-\t      fprintf (base_files[fnum],\n+\t      oprintf (base_files[fnum],\n \t\t       \"extern const struct %s gt_ggc_%s_\",\n \t\t       tname, pfx);\n \t      put_mangled_filename (base_files[fnum], fli2->name);\n-\t      fputs (\"[];\\n\", base_files[fnum]);\n+\t      oprintf (base_files[fnum], \"[];\\n\");\n \t    }\n       }\n \n@@ -1502,14 +1495,14 @@ finish_root_table (flp, pfx, lastname, tname, name)\n \t    {\n \t      if (! (started_bitmap & (1 << fnum)))\n \t\t{\n-\t\t  fprintf (base_files [fnum],\n+\t\t  oprintf (base_files [fnum],\n \t\t\t   \"const struct %s * const %s[] = {\\n\",\n \t\t\t   tname, name);\n \t\t  started_bitmap |= 1 << fnum;\n \t\t}\n-\t      fprintf (base_files[fnum], \"  gt_ggc_%s_\", pfx);\n+\t      oprintf (base_files[fnum], \"  gt_ggc_%s_\", pfx);\n \t      put_mangled_filename (base_files[fnum], fli2->name);\n-\t      fputs (\",\\n\", base_files[fnum]);\n+\t      oprintf (base_files[fnum], \",\\n\");\n \t    }\n       }\n \n@@ -1520,8 +1513,8 @@ finish_root_table (flp, pfx, lastname, tname, name)\n     for (bitmap = started_bitmap, fnum = 0; bitmap != 0; fnum++, bitmap >>= 1)\n       if (bitmap & 1)\n \t{\n-\t  fputs (\"  NULL\\n\", base_files[fnum]);\n-\t  fputs (\"};\\n\\n\", base_files[fnum]);\n+\t  oprintf (base_files[fnum], \"  NULL\\n\");\n+\t  oprintf (base_files[fnum], \"};\\n\\n\");\n \t}\n   }\n }\n@@ -1533,7 +1526,7 @@ finish_root_table (flp, pfx, lastname, tname, name)\n \n static void\n write_gc_root (f, v, type, name, has_length, line, if_marked)\n-     FILE *f;\n+     outf_p f;\n      pair_p v;\n      type_p type;\n      const char *name;\n@@ -1590,10 +1583,8 @@ write_gc_root (f, v, type, name, has_length, line, if_marked)\n \t\tif (validf != NULL)\n \t\t  {\n \t\t    char *newname;\n-\t\t    newname = xmalloc (strlen (name) + 3 + strlen (fld->name)\n-\t\t\t\t       + strlen (validf->name));\n-\t\t    sprintf (newname, \"%s.%s.%s\", \n-\t\t\t     name, fld->name, validf->name);\n+\t\t    newname = xasprintf (\"%s.%s.%s\", \n+\t\t\t\t\t name, fld->name, validf->name);\n \t\t    write_gc_root (f, v, validf->type, newname, 0, line,\n \t\t\t\t   if_marked);\n \t\t    free (newname);\n@@ -1606,8 +1597,7 @@ write_gc_root (f, v, type, name, has_length, line, if_marked)\n \t    else\n \t      {\n \t\tchar *newname;\n-\t\tnewname = xmalloc (strlen (name) + 2 + strlen (fld->name));\n-\t\tsprintf (newname, \"%s.%s\", name, fld->name);\n+\t\tnewname = xasprintf (\"%s.%s\", name, fld->name);\n \t\twrite_gc_root (f, v, fld->type, newname, 0, line, if_marked);\n \t\tfree (newname);\n \t      }\n@@ -1618,8 +1608,7 @@ write_gc_root (f, v, type, name, has_length, line, if_marked)\n     case TYPE_ARRAY:\n       {\n \tchar *newname;\n-\tnewname = xmalloc (strlen (name) + 4);\n-\tsprintf (newname, \"%s[0]\", name);\n+\tnewname = xasprintf (\"%s[0]\", name);\n \twrite_gc_root (f, v, type->u.a.p, newname, has_length, line, if_marked);\n \tfree (newname);\n       }\n@@ -1629,39 +1618,39 @@ write_gc_root (f, v, type, name, has_length, line, if_marked)\n       {\n \ttype_p ap, tp;\n \t\n-\tfputs (\"  {\\n\", f);\n-\tfprintf (f, \"    &%s,\\n\", name);\n-\tfputs (\"    1\", f);\n+\toprintf (f, \"  {\\n\");\n+\toprintf (f, \"    &%s,\\n\", name);\n+\toprintf (f, \"    1\");\n \t\n \tfor (ap = v->type; ap->kind == TYPE_ARRAY; ap = ap->u.a.p)\n \t  if (ap->u.a.len[0])\n-\t    fprintf (f, \" * (%s)\", ap->u.a.len);\n+\t    oprintf (f, \" * (%s)\", ap->u.a.len);\n \t  else if (ap == v->type)\n-\t    fprintf (f, \" * (sizeof (%s) / sizeof (%s[0]))\",\n+\t    oprintf (f, \" * (sizeof (%s) / sizeof (%s[0]))\",\n \t\t     v->name, v->name);\n-\tfputs (\",\\n\", f);\n-\tfprintf (f, \"    sizeof (%s\", v->name);\n+\toprintf (f, \",\\n\");\n+\toprintf (f, \"    sizeof (%s\", v->name);\n \tfor (ap = v->type; ap->kind == TYPE_ARRAY; ap = ap->u.a.p)\n-\t  fputs (\"[0]\", f);\n-\tfputs (\"),\\n\", f);\n+\t  oprintf (f, \"[0]\");\n+\toprintf (f, \"),\\n\");\n \t\n \ttp = type->u.p;\n \t\n \tif (! has_length && UNION_OR_STRUCT_P (tp))\n \t  {\n-\t    fprintf (f, \"    &gt_ggc_mx_%s\\n\", tp->u.s.tag);\n+\t    oprintf (f, \"    &gt_ggc_mx_%s\\n\", tp->u.s.tag);\n \t  }\n \telse if (! has_length && tp->kind == TYPE_PARAM_STRUCT)\n \t  {\n-\t    fprintf (f, \"    &gt_ggc_mm_%d%s_%s\",\n+\t    oprintf (f, \"    &gt_ggc_mm_%d%s_%s\",\n \t\t     (int) strlen (tp->u.param_struct.param->u.s.tag),\n \t\t     tp->u.param_struct.param->u.s.tag,\n \t\t     tp->u.param_struct.stru->u.s.tag);\n \t  }\n \telse if (has_length\n \t\t && (tp->kind == TYPE_POINTER || UNION_OR_STRUCT_P (tp)))\n \t  {\n-\t    fprintf (f, \"    &gt_ggc_ma_%s\", name);\n+\t    oprintf (f, \"    &gt_ggc_ma_%s\", name);\n \t  }\n \telse\n \t  {\n@@ -1670,8 +1659,8 @@ write_gc_root (f, v, type, name, has_length, line, if_marked)\n \t\t\t   name);\n \t  }\n \tif (if_marked)\n-\t  fprintf (f, \",\\n    &%s\", if_marked);\n-\tfputs (\"\\n  },\\n\", f);\n+\t  oprintf (f, \",\\n    &%s\", if_marked);\n+\toprintf (f, \"\\n  },\\n\");\n       }\n       break;\n \n@@ -1697,7 +1686,7 @@ write_gc_roots (variables)\n \n   for (v = variables; v; v = v->next)\n     {\n-      FILE *f = get_output_file_with_visibility (v->line.file);\n+      outf_p f = get_output_file_with_visibility (v->line.file);\n       struct flist *fli;\n       const char *length = NULL;\n       int deletable_p = 0;\n@@ -1729,7 +1718,7 @@ write_gc_roots (variables)\n \t  fli->name = v->line.file;\n \t  flp = fli;\n \n-\t  fputs (\"\\n/* GC roots.  */\\n\\n\", f);\n+\t  oprintf (f, \"\\n/* GC roots.  */\\n\\n\");\n \t}\n \n       if (! deletable_p\n@@ -1738,22 +1727,22 @@ write_gc_roots (variables)\n \t  && (v->type->u.p->kind == TYPE_POINTER\n \t      || v->type->u.p->kind == TYPE_STRUCT))\n \t{\n-\t  fprintf (f, \"static void gt_ggc_ma_%s PARAMS ((void *));\\n\",\n+\t  oprintf (f, \"static void gt_ggc_ma_%s PARAMS ((void *));\\n\",\n \t\t   v->name);\n-\t  fprintf (f, \"static void\\ngt_ggc_ma_%s (x_p)\\n      void *x_p;\\n\",\n+\t  oprintf (f, \"static void\\ngt_ggc_ma_%s (x_p)\\n      void *x_p;\\n\",\n \t\t   v->name);\n-\t  fputs (\"{\\n\", f);\n-\t  fputs (\"  size_t i;\\n\", f);\n+\t  oprintf (f, \"{\\n\");\n+\t  oprintf (f, \"  size_t i;\\n\");\n \n \t  if (v->type->u.p->kind == TYPE_POINTER)\n \t    {\n \t      type_p s = v->type->u.p->u.p;\n \n-\t      fprintf (f, \"  %s %s ** const x = (%s %s **)x_p;\\n\",\n+\t      oprintf (f, \"  %s %s ** const x = (%s %s **)x_p;\\n\",\n \t\t       s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag,\n \t\t       s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag);\n-\t      fputs (\"  if (ggc_test_and_set_mark (x))\\n\", f);\n-\t      fprintf (f, \"    for (i = 0; i < (%s); i++)\\n\", length);\n+\t      oprintf (f, \"  if (ggc_test_and_set_mark (x))\\n\");\n+\t      oprintf (f, \"    for (i = 0; i < (%s); i++)\\n\", length);\n \t      if (s->kind != TYPE_STRUCT && s->kind != TYPE_UNION)\n \t\t{\n \t\t  error_at_line (&v->line, \n@@ -1762,31 +1751,31 @@ write_gc_roots (variables)\n \t\t  continue;\n \t\t}\n \n-\t      fprintf (f, \"      gt_ggc_m_%s (x[i]);\\n\", s->u.s.tag);\n+\t      oprintf (f, \"      gt_ggc_m_%s (x[i]);\\n\", s->u.s.tag);\n \t    }\n \t  else\n \t    {\n \t      type_p s = v->type->u.p;\n \n-\t      fprintf (f, \"  %s %s * const x = (%s %s *)x_p;\\n\",\n+\t      oprintf (f, \"  %s %s * const x = (%s %s *)x_p;\\n\",\n \t\t       s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag,\n \t\t       s->kind == TYPE_UNION ? \"union\" : \"struct\", s->u.s.tag);\n-\t      fputs (\"  if (ggc_test_and_set_mark (x))\\n\", f);\n-\t      fprintf (f, \"    for (i = 0; i < (%s); i++)\\n\", length);\n-\t      fputs (\"      {\\n\", f);\n+\t      oprintf (f, \"  if (ggc_test_and_set_mark (x))\\n\");\n+\t      oprintf (f, \"    for (i = 0; i < (%s); i++)\\n\", length);\n+\t      oprintf (f, \"      {\\n\");\n \t      write_gc_structure_fields (f, s, \"x[i]\", \"x[i]\",\n \t\t\t\t\t v->opt, 8, &v->line, s->u.s.bitmap,\n \t\t\t\t\t NULL);\n-\t      fputs (\"      }\\n\", f);\n+\t      oprintf (f, \"      }\\n\");\n \t    }\n \n-\t  fputs (\"}\\n\\n\", f);\n+\t  oprintf (f, \"}\\n\\n\");\n \t}\n     }\n \n   for (v = variables; v; v = v->next)\n     {\n-      FILE *f = get_output_file_with_visibility (v->line.file);\n+      outf_p f = get_output_file_with_visibility (v->line.file);\n       struct flist *fli;\n       int skip_p = 0;\n       int length_p = 0;\n@@ -1809,9 +1798,9 @@ write_gc_roots (variables)\n \t{\n \t  fli->started_p = 1;\n \n-\t  fputs (\"const struct ggc_root_tab gt_ggc_r_\", f);\n+\t  oprintf (f, \"const struct ggc_root_tab gt_ggc_r_\");\n \t  put_mangled_filename (f, v->line.file);\n-\t  fputs (\"[] = {\\n\", f);\n+\t  oprintf (f, \"[] = {\\n\");\n \t}\n \n       write_gc_root (f, v, v->type, v->name, length_p, &v->line, NULL);\n@@ -1822,7 +1811,7 @@ write_gc_roots (variables)\n \n   for (v = variables; v; v = v->next)\n     {\n-      FILE *f = get_output_file_with_visibility (v->line.file);\n+      outf_p f = get_output_file_with_visibility (v->line.file);\n       struct flist *fli;\n       int skip_p = 1;\n       options_p o;\n@@ -1843,12 +1832,12 @@ write_gc_roots (variables)\n \t{\n \t  fli->started_p = 1;\n \n-\t  fputs (\"const struct ggc_root_tab gt_ggc_rd_\", f);\n+\t  oprintf (f, \"const struct ggc_root_tab gt_ggc_rd_\");\n \t  put_mangled_filename (f, v->line.file);\n-\t  fputs (\"[] = {\\n\", f);\n+\t  oprintf (f, \"[] = {\\n\");\n \t}\n       \n-      fprintf (f, \"  { &%s, 1, sizeof (%s), NULL },\\n\",\n+      oprintf (f, \"  { &%s, 1, sizeof (%s), NULL },\\n\",\n \t       v->name, v->name);\n     }\n   \n@@ -1857,7 +1846,7 @@ write_gc_roots (variables)\n \n   for (v = variables; v; v = v->next)\n     {\n-      FILE *f = get_output_file_with_visibility (v->line.file);\n+      outf_p f = get_output_file_with_visibility (v->line.file);\n       struct flist *fli;\n       const char *if_marked = NULL;\n       int length_p = 0;\n@@ -1887,9 +1876,9 @@ write_gc_roots (variables)\n \t{\n \t  fli->started_p = 1;\n \n-\t  fputs (\"const struct ggc_cache_tab gt_ggc_rc_\", f);\n+\t  oprintf (f, \"const struct ggc_cache_tab gt_ggc_rc_\");\n \t  put_mangled_filename (f, v->line.file);\n-\t  fputs (\"[] = {\\n\", f);\n+\t  oprintf (f, \"[] = {\\n\");\n \t}\n       \n       write_gc_root (f, v, create_pointer (v->type->u.p->u.param_struct.param),"}, {"sha": "cd158ff26bad6281885d86193714191271e7879b", "filename": "gcc/gengtype.h", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e03856fe956bdc94dc86c19d05f5f03af0f296f7/gcc%2Fgengtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e03856fe956bdc94dc86c19d05f5f03af0f296f7/gcc%2Fgengtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.h?ref=e03856fe956bdc94dc86c19d05f5f03af0f296f7", "patch": "@@ -111,6 +111,13 @@ extern struct fileloc lexer_line;\n extern void error_at_line \n   PARAMS ((struct fileloc *pos, const char *msg, ...)) ATTRIBUTE_PRINTF_2;\n \n+/* Combines xmalloc() and vasprintf().  */\n+extern int xvasprintf PARAMS ((char **, const char *, va_list))\n+     ATTRIBUTE_PRINTF (2, 0);\n+/* Like the above, but more convenient for quick coding.  */\n+extern char * xasprintf PARAMS ((const char *, ...))\n+     ATTRIBUTE_PRINTF_1;\n+\n /* Constructor routines for types.  */\n extern void do_typedef PARAMS ((const char *s, type_p t, struct fileloc *pos));\n extern type_p resolve_typedef PARAMS ((const char *s, struct fileloc *pos));\n@@ -135,23 +142,38 @@ extern void parse_file PARAMS ((char *name));\n \n /* Output file handling.  */\n \n-FILE *get_output_file PARAMS ((const char *input_file));\n-const char *get_output_file_name PARAMS ((const char *));\n+/* Structure representing an output file.  */\n+struct outf \n+{\n+  struct outf *next;\n+  const char *name;\n+  size_t buflength;\n+  size_t bufused;\n+  char *buf;\n+};\n+\n+typedef struct outf * outf_p;\n \n /* The output header file that is included into pretty much every\n    source file.  */\n-extern FILE *header_file;\n+extern outf_p header_file;\n \n /* An output file, suitable for definitions, that can see declarations\n    made in INPUT_FILE and is linked into every language that uses\n    INPUT_FILE.  */\n-extern FILE *get_output_file_with_visibility PARAMS ((const char *input_file));\n+extern outf_p get_output_file_with_visibility \n+   PARAMS ((const char *input_file));\n+const char *get_output_file_name PARAMS ((const char *));\n \n /* A list of output files suitable for definitions.  There is one\n    BASE_FILES entry for each language.  */\n-extern FILE *base_files[];\n+extern outf_p base_files[];\n \n /* A bitmap that specifies which of BASE_FILES should be used to\n    output a definition that is different for each language and must be\n    defined once in each language that uses INPUT_FILE.  */\n extern lang_bitmap get_base_file_bitmap PARAMS ((const char *input_file));\n+\n+/* Print, like fprintf, to O.  */\n+extern void oprintf PARAMS ((outf_p o, const char *S, ...))\n+     ATTRIBUTE_PRINTF_2;"}]}