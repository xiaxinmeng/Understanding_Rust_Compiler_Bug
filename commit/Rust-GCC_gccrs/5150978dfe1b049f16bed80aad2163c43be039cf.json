{"sha": "5150978dfe1b049f16bed80aad2163c43be039cf", "node_id": "C_kwDOANBUbNoAKDUxNTA5NzhkZmUxYjA0OWYxNmJlZDgwYWFkMjE2M2M0M2JlMDM5Y2Y", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2022-10-06T21:44:43Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2022-11-04T13:47:27Z"}, "message": "ada: Skip dynamic interface conversion under configurable runtime\n\ngcc/ada/\n\n\t* exp_disp.adb\n\t(Expand_Interface_Conversion): Under configurable runtime, when\n\tthe target type is an interface that is an ancestor of the operand\n\ttype, skip generating code to displace the pointer to reference\n\tthe target dispatch table.\n\t* sem_disp.adb\n\t(Propagate_Tag): Handle class-wide types when checking for the\n\taddition of an implicit interface conversion.", "tree": {"sha": "1d5e98104c6626f98049f06b039c81142bc6fdb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d5e98104c6626f98049f06b039c81142bc6fdb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5150978dfe1b049f16bed80aad2163c43be039cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5150978dfe1b049f16bed80aad2163c43be039cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5150978dfe1b049f16bed80aad2163c43be039cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5150978dfe1b049f16bed80aad2163c43be039cf/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e491cb26ecb52b56dd1f5eef284f8871f870fb5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e491cb26ecb52b56dd1f5eef284f8871f870fb5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e491cb26ecb52b56dd1f5eef284f8871f870fb5b"}], "stats": {"total": 47, "additions": 33, "deletions": 14}, "files": [{"sha": "d8a45ffb7c9407fe6b819fe39a1b23441b91978b", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5150978dfe1b049f16bed80aad2163c43be039cf/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5150978dfe1b049f16bed80aad2163c43be039cf/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=5150978dfe1b049f16bed80aad2163c43be039cf", "patch": "@@ -1304,17 +1304,24 @@ package body Exp_Disp is\n            and then Is_Ancestor (Iface_Typ, Opnd, Use_Full_View => True)\n          then\n             return;\n-         end if;\n \n-         --  When the type of the operand and the target interface type match,\n-         --  it is generally safe to skip generating code to displace the\n-         --  pointer to the object to reference the secondary dispatch table\n-         --  associated with the target interface type. The exception to this\n-         --  general rule is when the underlying object of the type conversion\n-         --  is an object built by means of a dispatching constructor (since in\n-         --  such case the expansion of the constructor call is a direct call\n-         --  to an object primitive, i.e. without thunks, and the expansion of\n-         --  the constructor call adds an explicit conversion to the target\n+         --  When the target type is an interface type that is an ancestor of\n+         --  the operand type, it is generally safe to skip generating code to\n+         --  displace the pointer to the object to reference the secondary\n+         --  dispatch table of the target interface type. Two scenaries are\n+         --  possible here:\n+         --    1) The operand type is a regular tagged type\n+         --    2) The operand type is an interface type\n+         --  In the former case the target interface and the regular tagged\n+         --  type share the primary dispatch table of the object; in the latter\n+         --  case the operand interface has all the primitives of the ancestor\n+         --  interface type (and exactly in the same dispatch table slots).\n+         --\n+         --  The exception to this general rule is when the underlying object\n+         --  is built by means of a dispatching constructor (since in such case\n+         --  the expansion of the constructor call is a direct call to an\n+         --  object primitive, i.e. without thunks, and the expansion of\n+         --  the constructor call adds this explicit conversion to the target\n          --  interface type to force the displacement of the pointer to the\n          --  object to reference the corresponding secondary dispatch table\n          --  (cf. Make_DT and Expand_Dispatching_Constructor_Call)).\n@@ -1326,7 +1333,10 @@ package body Exp_Disp is\n          --  to the object, because generic dispatching constructors are not\n          --  supported.\n \n-         if Opnd = Iface_Typ and then not RTE_Available (RE_Displace) then\n+         elsif Is_Interface (Iface_Typ)\n+           and then Is_Ancestor (Iface_Typ, Opnd, Use_Full_View => True)\n+           and then not RTE_Available (RE_Displace)\n+         then\n             return;\n          end if;\n       end;"}, {"sha": "af260136bc0a1507f35a4747bc2769480bcd5a9a", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5150978dfe1b049f16bed80aad2163c43be039cf/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5150978dfe1b049f16bed80aad2163c43be039cf/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=5150978dfe1b049f16bed80aad2163c43be039cf", "patch": "@@ -3072,18 +3072,27 @@ package body Sem_Disp is\n \n       if Tagged_Type_Expansion then\n          declare\n-            Call_Typ : constant Entity_Id := Etype (Call_Node);\n+            Call_Typ : Entity_Id := Etype (Call_Node);\n+            Ctrl_Typ : Entity_Id := Etype (Control);\n \n          begin\n             Expand_Dispatching_Call (Call_Node);\n \n+            if Is_Class_Wide_Type (Call_Typ) then\n+               Call_Typ := Root_Type (Call_Typ);\n+            end if;\n+\n+            if Is_Class_Wide_Type (Ctrl_Typ) then\n+               Ctrl_Typ := Root_Type (Ctrl_Typ);\n+            end if;\n+\n             --  If the controlling argument is an interface type and the type\n             --  of Call_Node differs then we must add an implicit conversion to\n             --  force displacement of the pointer to the object to reference\n             --  the secondary dispatch table of the interface.\n \n-            if Is_Interface (Etype (Control))\n-              and then Etype (Control) /= Call_Typ\n+            if Is_Interface (Ctrl_Typ)\n+              and then Ctrl_Typ /= Call_Typ\n             then\n                --  Cannot use Convert_To because the previous call to\n                --  Expand_Dispatching_Call leaves decorated the Call_Node"}]}