{"sha": "6e49961ce47b8c554ff6081ef95a68a0616f0a93", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU0OTk2MWNlNDdiOGM1NTRmZjYwODFlZjk1YTY4YTA2MTZmMGE5Mw==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2017-04-28T12:51:05Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2017-04-28T12:51:05Z"}, "message": "Make gcno more precise about BBs really belonging to a line (PR gcov-profile/79891).\n\n2017-04-28  Martin Liska  <mliska@suse.cz>\n\n\tPR gcov-profile/79891\n\t* gcov.c (add_line_counts): Assign BBs to lines just if the BB\n\tis marked by compiler as living on a line.\n\t(get_cycles_count): Remove usage of the union.\n\t(output_intermediate_file): Likewise.\n\t(find_source): Fix GNU coding style.\n\t(accumulate_line_counts): Remove old non-all block mode.\n\t(output_lines): Remove usage of the union.\n\t* profile.c (output_location): Include all BBs, even if\n\tbelonging to a same line (and file) as a previous BB.\n2017-04-28  Martin Liska  <mliska@suse.cz>\n\n\tPR gcov-profile/79891\n\t* gcc.misc-tests/gcov-17.c: New test.\n\t* gcc.misc-tests/gcov-18.c: New test.\n\nFrom-SVN: r247374", "tree": {"sha": "581504fe21555bdbe3723111eb739d6cdc3e53ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/581504fe21555bdbe3723111eb739d6cdc3e53ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e49961ce47b8c554ff6081ef95a68a0616f0a93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e49961ce47b8c554ff6081ef95a68a0616f0a93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e49961ce47b8c554ff6081ef95a68a0616f0a93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e49961ce47b8c554ff6081ef95a68a0616f0a93/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9b9d6370d48146a0dd8ed327ecdbfc9273abf91a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b9d6370d48146a0dd8ed327ecdbfc9273abf91a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b9d6370d48146a0dd8ed327ecdbfc9273abf91a"}], "stats": {"total": 228, "additions": 150, "deletions": 78}, "files": [{"sha": "63b6276c07d9dc8b8eec3a0120c683aa99af718c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e49961ce47b8c554ff6081ef95a68a0616f0a93/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e49961ce47b8c554ff6081ef95a68a0616f0a93/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e49961ce47b8c554ff6081ef95a68a0616f0a93", "patch": "@@ -1,3 +1,16 @@\n+2017-04-28  Martin Liska  <mliska@suse.cz>\n+\n+\tPR gcov-profile/79891\n+\t* gcov.c (add_line_counts): Assign BBs to lines just if the BB\n+\tis marked by compiler as living on a line.\n+\t(get_cycles_count): Remove usage of the union.\n+\t(output_intermediate_file): Likewise.\n+\t(find_source): Fix GNU coding style.\n+\t(accumulate_line_counts): Remove old non-all block mode.\n+\t(output_lines): Remove usage of the union.\n+\t* profile.c (output_location): Include all BBs, even if\n+\tbelonging to a same line (and file) as a previous BB.\n+\n 2017-04-28  Martin Liska  <mliska@suse.cz>\n \n \t* gcov.c (process_args): Handle new argument 'w'."}, {"sha": "b25464e730ea39bad7e82797d7738c43495884f2", "filename": "gcc/gcov.c", "status": "modified", "additions": 33, "deletions": 57, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e49961ce47b8c554ff6081ef95a68a0616f0a93/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e49961ce47b8c554ff6081ef95a68a0616f0a93/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=6e49961ce47b8c554ff6081ef95a68a0616f0a93", "patch": "@@ -238,22 +238,17 @@ typedef struct line_info\n   bool has_block (block_t *needle);\n \n   gcov_type count;\t   /* execution count */\n-  union\n-  {\n-    arc_t *branches;\t   /* branches from blocks that end on this\n-\t\t\t      line. Used for branch-counts when not\n-\t\t\t      all-blocks mode.  */\n-    block_t *blocks;       /* blocks which start on this line.  Used\n-\t\t\t      in all-blocks mode.  */\n-  } u;\n+  arc_t *branches;\t   /* branches from blocks that end on this line.  */\n+  block_t *blocks;\t   /* blocks which start on this line.\n+\t\t\t      Used in all-blocks mode.  */\n   unsigned exists : 1;\n   unsigned unexceptional : 1;\n } line_t;\n \n bool\n line_t::has_block (block_t *needle)\n {\n-  for (block_t *n = u.blocks; n; n = n->chain)\n+  for (block_t *n = blocks; n; n = n->chain)\n     if (n == needle)\n       return true;\n \n@@ -608,7 +603,7 @@ get_cycles_count (line_t &linfo, bool handle_negative_cycles = true)\n \n   loop_type result = NO_LOOP;\n   gcov_type count = 0;\n-  for (block_t *block = linfo.u.blocks; block; block = block->chain)\n+  for (block_t *block = linfo.blocks; block; block = block->chain)\n     {\n       arc_vector_t path;\n       block_vector_t blocked;\n@@ -886,7 +881,7 @@ output_intermediate_file (FILE *gcov_file, source_t *src)\n \tfprintf (gcov_file, \"lcount:%u,%s\\n\", line_num,\n \t\t format_gcov (line->count, 0, -1));\n       if (flag_branches)\n-        for (arc = line->u.branches; arc; arc = arc->line_next)\n+\tfor (arc = line->branches; arc; arc = arc->line_next)\n           {\n             if (!arc->is_unconditional && !arc->is_call_non_return)\n               {\n@@ -1279,7 +1274,7 @@ find_source (const char *file_name)\n \n   /* Resort the name map.  */\n   qsort (names, n_names, sizeof (*names), name_sort);\n-  \n+\n  check_date:\n   if (sources[idx].file_time > bbg_file_time)\n     {\n@@ -2239,13 +2234,11 @@ mangle_name (char const *base, char *ptr)\n static void\n add_line_counts (coverage_t *coverage, function_t *fn)\n {\n-  unsigned ix;\n-  line_t *line = NULL; /* This is propagated from one iteration to the\n-\t\t\t  next.  */\n-\n+  bool has_any_line = false;\n   /* Scan each basic block.  */\n-  for (ix = 0; ix != fn->blocks.size (); ix++)\n+  for (unsigned ix = 0; ix != fn->blocks.size (); ix++)\n     {\n+      line_t *line = NULL;\n       block_t *block = &fn->blocks[ix];\n       if (block->count && ix && ix + 1 != fn->blocks.size ())\n \tfn->blocks_executed++;\n@@ -2272,33 +2265,31 @@ add_line_counts (coverage_t *coverage, function_t *fn)\n \t}\n       block->cycle.arc = NULL;\n       block->cycle.ident = ~0U;\n+      has_any_line = true;\n \n       if (!ix || ix + 1 == fn->blocks.size ())\n \t/* Entry or exit block */;\n-      else if (flag_all_blocks)\n+      else if (line != NULL)\n \t{\n-\t  line_t *block_line = line;\n-\n-\t  if (!block_line)\n-\t    block_line = &sources[fn->src].lines[fn->line];\n+\t  block->chain = line->blocks;\n+\t  line->blocks = block;\n \n-\t  block->chain = block_line->u.blocks;\n-\t  block_line->u.blocks = block;\n-\t}\n-      else if (flag_branches)\n-\t{\n-\t  arc_t *arc;\n-\n-\t  for (arc = block->succ; arc; arc = arc->succ_next)\n+\t  if (flag_branches)\n \t    {\n-\t      arc->line_next = line->u.branches;\n-\t      line->u.branches = arc;\n-\t      if (coverage && !arc->is_unconditional)\n-\t\tadd_branch_counts (coverage, arc);\n+\t      arc_t *arc;\n+\n+\t      for (arc = block->succ; arc; arc = arc->succ_next)\n+\t\t{\n+\t\t  arc->line_next = line->branches;\n+\t\t  line->branches = arc;\n+\t\t  if (coverage && !arc->is_unconditional)\n+\t\t    add_branch_counts (coverage, arc);\n+\t\t}\n \t    }\n \t}\n     }\n-  if (!line)\n+\n+  if (!has_any_line)\n     fnotice (stderr, \"%s:no lines for '%s'\\n\", bbg_file_name, fn->name);\n }\n \n@@ -2321,22 +2312,7 @@ accumulate_line_counts (source_t *src)\n \n   for (ix = src->num_lines, line = src->lines; ix--; line++)\n     {\n-      if (!flag_all_blocks)\n-\t{\n-\t  arc_t *arc, *arc_p, *arc_n;\n-\n-\t  /* Total and reverse the branch information.  */\n-\t  for (arc = line->u.branches, arc_p = NULL; arc;\n-\t       arc_p = arc, arc = arc_n)\n-\t    {\n-\t      arc_n = arc->line_next;\n-\t      arc->line_next = arc_p;\n-\n-\t      add_branch_counts (&src->coverage, arc);\n-\t    }\n-\t  line->u.branches = arc_p;\n-\t}\n-      else if (line->u.blocks)\n+      if (line->blocks)\n \t{\n \t  /* The user expects the line count to be the number of times\n \t     a line has been executed. Simply summing the block count\n@@ -2348,17 +2324,17 @@ accumulate_line_counts (source_t *src)\n \t  gcov_type count = 0;\n \n \t  /* Reverse the block information.  */\n-\t  for (block = line->u.blocks, block_p = NULL; block;\n+\t  for (block = line->blocks, block_p = NULL; block;\n \t       block_p = block, block = block_n)\n \t    {\n \t      block_n = block->chain;\n \t      block->chain = block_p;\n \t      block->cycle.ident = ix;\n \t    }\n-\t  line->u.blocks = block_p;\n+\t  line->blocks = block_p;\n \n \t  /* Sum the entry arcs.  */\n-\t  for (block = line->u.blocks; block; block = block->chain)\n+\t  for (block = line->blocks; block; block = block->chain)\n \t    {\n \t      arc_t *arc;\n \n@@ -2368,7 +2344,7 @@ accumulate_line_counts (source_t *src)\n \t    }\n \n \t  /* Cycle detection.  */\n-\t  for (block = line->u.blocks; block; block = block->chain)\n+\t  for (block = line->blocks; block; block = block->chain)\n \t    {\n \t      for (arc_t *arc = block->pred; arc; arc = arc->pred_next)\n \t\tif (!line->has_block (arc->src))\n@@ -2554,7 +2530,7 @@ output_lines (FILE *gcov_file, const source_t *src)\n \t  arc_t *arc;\n \t  int ix, jx;\n \n-\t  for (ix = jx = 0, block = line->u.blocks; block;\n+\t  for (ix = jx = 0, block = line->blocks; block;\n \t       block = block->chain)\n \t    {\n \t      if (!block->is_call_return)\n@@ -2578,7 +2554,7 @@ output_lines (FILE *gcov_file, const source_t *src)\n \t  int ix;\n \t  arc_t *arc;\n \n-\t  for (ix = 0, arc = line->u.branches; arc; arc = arc->line_next)\n+\t  for (ix = 0, arc = line->branches; arc; arc = arc->line_next)\n \t    ix += output_branch_count (gcov_file, ix, arc);\n \t}\n     }"}, {"sha": "3346af4e961ac77b34805c1dcc273b4ae4d2c6a7", "filename": "gcc/profile.c", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e49961ce47b8c554ff6081ef95a68a0616f0a93/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e49961ce47b8c554ff6081ef95a68a0616f0a93/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=6e49961ce47b8c554ff6081ef95a68a0616f0a93", "patch": "@@ -941,29 +941,26 @@ output_location (char const *file_name, int line,\n   name_differs = !prev_file_name || filename_cmp (file_name, prev_file_name);\n   line_differs = prev_line != line;\n \n-  if (name_differs || line_differs)\n+  if (!*offset)\n     {\n-      if (!*offset)\n-\t{\n-\t  *offset = gcov_write_tag (GCOV_TAG_LINES);\n-\t  gcov_write_unsigned (bb->index);\n-\t  name_differs = line_differs=true;\n-\t}\n+      *offset = gcov_write_tag (GCOV_TAG_LINES);\n+      gcov_write_unsigned (bb->index);\n+      name_differs = line_differs = true;\n+    }\n \n-      /* If this is a new source file, then output the\n-\t file's name to the .bb file.  */\n-      if (name_differs)\n-\t{\n-\t  prev_file_name = file_name;\n-\t  gcov_write_unsigned (0);\n-\t  gcov_write_string (prev_file_name);\n-\t}\n-      if (line_differs)\n-\t{\n-\t  gcov_write_unsigned (line);\n-\t  prev_line = line;\n-\t}\n-     }\n+  /* If this is a new source file, then output the\n+     file's name to the .bb file.  */\n+  if (name_differs)\n+    {\n+      prev_file_name = file_name;\n+      gcov_write_unsigned (0);\n+      gcov_write_string (prev_file_name);\n+    }\n+  if (line_differs)\n+    {\n+      gcov_write_unsigned (line);\n+      prev_line = line;\n+    }\n }\n \n /* Instrument and/or analyze program behavior based on program the CFG."}, {"sha": "cf3199b8ed5c96d9f8d819ccbe7cf60bdf7c6dc2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e49961ce47b8c554ff6081ef95a68a0616f0a93/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e49961ce47b8c554ff6081ef95a68a0616f0a93/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6e49961ce47b8c554ff6081ef95a68a0616f0a93", "patch": "@@ -1,3 +1,9 @@\n+2017-04-28  Martin Liska  <mliska@suse.cz>\n+\n+\tPR gcov-profile/79891\n+\t* gcc.misc-tests/gcov-17.c: New test.\n+\t* gcc.misc-tests/gcov-18.c: New test.\n+\n 2017-04-28  Tom de Vries  <tom@codesourcery.com>\n \n \t* g++.dg/parse/error2.C: Remove superfluous '{ target *-*-* }' in"}, {"sha": "e38860808445381275c13d959e8521932884f26f", "filename": "gcc/testsuite/gcc.misc-tests/gcov-17.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e49961ce47b8c554ff6081ef95a68a0616f0a93/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e49961ce47b8c554ff6081ef95a68a0616f0a93/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov-17.c?ref=6e49961ce47b8c554ff6081ef95a68a0616f0a93", "patch": "@@ -0,0 +1,51 @@\n+/* Test gcov block mode.  Compiler generates following CFG:\n+\n+  <bb 3>:\n+  if (false_var_4 != 0)\n+    goto <bb 4>;\n+  else\n+    goto <bb 5>;\n+\n+  <bb 4>:\n+  ret_6 = 111;\n+  PROF_edge_counter_10 = __gcov0.UuT[0];\n+  PROF_edge_counter_11 = PROF_edge_counter_10 + 1;\n+  __gcov0.UuT[0] = PROF_edge_counter_11;\n+\n+  <bb 5>:\n+  # ret_1 = PHI <ret_5(3), ret_6(4)>\n+  goto <bb 7>;\n+\n+It's important not to include <bb 5> to any line as it's actually shared\n+by both branches of the condition in <bb 3>.\n+\n+*/\n+\n+/* { dg-options \"-fprofile-arcs -ftest-coverage\" } */\n+/* { dg-do run { target native } } */\n+\n+unsigned int\n+UuT (void)\n+{\n+  unsigned int true_var = 1;\n+  unsigned int false_var = 0;\n+  unsigned int ret = 0;\n+\n+  if (true_var) /* count(1) */\n+    {\n+      if (false_var) /* count(1) */\n+\tret = 111; /* count(#####) */\n+    }\n+  else\n+    ret = 999; /* count(#####) */\n+  return ret;\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  UuT ();\n+  return 0;\n+}\n+\n+/* { dg-final { run-gcov { -a gcov-17.c } } } */"}, {"sha": "ae1017866db9f906f60ae83c947a8a68ff2f056f", "filename": "gcc/testsuite/gcc.misc-tests/gcov-18.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e49961ce47b8c554ff6081ef95a68a0616f0a93/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e49961ce47b8c554ff6081ef95a68a0616f0a93/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov-18.c?ref=6e49961ce47b8c554ff6081ef95a68a0616f0a93", "patch": "@@ -0,0 +1,29 @@\n+/* Test gcov block mode. As the example does jump to a statement\n+   that is on a line with different ones, we must calculate such jump\n+   just once.  */\n+\n+/* { dg-options \"-fprofile-arcs -ftest-coverage\" } */\n+/* { dg-do run { target native } } */\n+\n+int a = 0;\n+\n+void foo() /* count(1) */\n+{\n+  a = 1;\n+}\n+\n+void bar() /* count(1) */\n+{\n+  a++;\n+}\n+\n+int main() /* count(1) */\n+{\n+  foo (); goto baz; lab: bar (); /* count(2) */\n+\n+  baz:\n+    if (a == 1) /* count(2) */\n+      goto lab; /* count(1) */\n+}\n+\n+/* { dg-final { run-gcov { gcov-18.c } } } */"}]}