{"sha": "155f6b2be421b0f84e478e34fbf72ee0bb9e36bc", "node_id": "C_kwDOANBUbNoAKDE1NWY2YjJiZTQyMWIwZjg0ZTQ3OGUzNGZiZjcyZWUwYmI5ZTM2YmM", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-11-05T09:20:10Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-11-05T09:20:10Z"}, "message": "dwarf2out: Fix up CONST_WIDE_INT handling once more [PR103046]\n\nMy last change to CONST_WIDE_INT handling in add_const_value_attribute broke\nhandling of CONST_WIDE_INT constants like ((__uint128_t) 1 << 120).\nwi::min_precision (w1, UNSIGNED) in that case 121, but wide_int::from\ncreates a wide_int that has 0 and 0xff00000000000000ULL in its elts and\nprecision 121.  When we output that, we output both elements and thus emit\n0, 0xff00000000000000 instead of the desired 0, 0x0100000000000000.\n\nIMHO we should actually pass machine_mode to add_const_value_attribute from\ncallers, so that we know exactly what precision we want.  Because\nhypothetically, if say mode is OImode and the CONST_WIDE_INT value fits into\n128 bits or 192 bits, we'd emit just those 128 or 192 bits but debug info\nusers would expect 256 bits.\n\nOn\ntypedef unsigned __int128 U;\n\nint\nmain ()\n{\n  U a = (U) 1 << 120;\n  U b = 0xffffffffffffffffULL;\n  U c = ((U) 0xffffffff00000000ULL) << 64;\n  return 0;\n}\nvanilla gcc incorrectly emits 0, 0xff00000000000000 for a,\n0xffffffffffffffff alone (DW_FORM_data8) for b and 0, 0xffffffff00000000\nfor c.  gcc with the previously posted PR103046 patch emits\n0, 0x0100000000000000 for a, 0xffffffffffffffff alone for b and\n0, 0xffffffff00000000 for c.  And with this patch we emit\n0, 0x0100000000000000 for a, 0xffffffffffffffff, 0 for b and\n0, 0xffffffff00000000 for c.\nSo, the patch below certainly causes larger debug info (well, 128-bit\nintegers are pretty rare), but in this case the question is if it isn't\nmore correct, as debug info consumers generally will not know if they\nshould sign or zero extend the value in DW_AT_const_value.\nThe previous code assumes they will always zero extend it...\n\n2021-11-05  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR debug/103046\n\t* dwarf2out.c (add_const_value_attribute): Add MODE argument, use it\n\tin CONST_WIDE_INT handling.  Adjust recursive calls.\n\t(add_location_or_const_value_attribute): Pass DECL_MODE (decl) to\n\tnew add_const_value_attribute argument.\n\t(tree_add_const_value_attribute): Pass TYPE_MODE (type) to new\n\tadd_const_value_attribute argument.", "tree": {"sha": "65ee148e488d2233ba610300a43bdf5c9c7016c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65ee148e488d2233ba610300a43bdf5c9c7016c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/155f6b2be421b0f84e478e34fbf72ee0bb9e36bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/155f6b2be421b0f84e478e34fbf72ee0bb9e36bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/155f6b2be421b0f84e478e34fbf72ee0bb9e36bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/155f6b2be421b0f84e478e34fbf72ee0bb9e36bc/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44d0243a247dd1280265c649dab26e9486ffa015", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44d0243a247dd1280265c649dab26e9486ffa015", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44d0243a247dd1280265c649dab26e9486ffa015"}], "stats": {"total": 32, "additions": 17, "deletions": 15}, "files": [{"sha": "fb0e3381e5b9d3849df78cb8d9097a1165af99d1", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/155f6b2be421b0f84e478e34fbf72ee0bb9e36bc/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/155f6b2be421b0f84e478e34fbf72ee0bb9e36bc/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=155f6b2be421b0f84e478e34fbf72ee0bb9e36bc", "patch": "@@ -3854,7 +3854,7 @@ static void add_AT_location_description\t(dw_die_ref, enum dwarf_attribute,\n \t\t\t\t\t dw_loc_list_ref);\n static void add_data_member_location_attribute (dw_die_ref, tree,\n \t\t\t\t\t\tstruct vlr_context *);\n-static bool add_const_value_attribute (dw_die_ref, rtx);\n+static bool add_const_value_attribute (dw_die_ref, machine_mode, rtx);\n static void insert_int (HOST_WIDE_INT, unsigned, unsigned char *);\n static void insert_wide_int (const wide_int &, unsigned char *, int);\n static unsigned insert_float (const_rtx, unsigned char *);\n@@ -20081,8 +20081,10 @@ insert_float (const_rtx rtl, unsigned char *array)\n    constants do not necessarily get memory \"homes\".  */\n \n static bool\n-add_const_value_attribute (dw_die_ref die, rtx rtl)\n+add_const_value_attribute (dw_die_ref die, machine_mode mode, rtx rtl)\n {\n+  scalar_mode int_mode;\n+\n   switch (GET_CODE (rtl))\n     {\n     case CONST_INT:\n@@ -20097,15 +20099,15 @@ add_const_value_attribute (dw_die_ref die, rtx rtl)\n       return true;\n \n     case CONST_WIDE_INT:\n-      {\n-\twide_int w1 = rtx_mode_t (rtl, MAX_MODE_INT);\n-\tunsigned int prec = MIN (wi::min_precision (w1, UNSIGNED),\n-\t\t\t\t (unsigned int) CONST_WIDE_INT_NUNITS (rtl)\n-\t\t\t\t * HOST_BITS_PER_WIDE_INT);\n-\twide_int w = wide_int::from (w1, prec, UNSIGNED);\n-\tadd_AT_wide (die, DW_AT_const_value, w);\n-      }\n-      return true;\n+      if (is_int_mode (mode, &int_mode)\n+\t  && (GET_MODE_PRECISION (int_mode)\n+\t      & (HOST_BITS_PER_WIDE_INT - 1)) == 0)\n+\t{\n+\t  wide_int w = rtx_mode_t (rtl, int_mode);\n+\t  add_AT_wide (die, DW_AT_const_value, w);\n+\t  return true;\n+\t}\n+      return false;\n \n     case CONST_DOUBLE:\n       /* Note that a CONST_DOUBLE rtx could represent either an integer or a\n@@ -20190,7 +20192,7 @@ add_const_value_attribute (dw_die_ref die, rtx rtl)\n \n     case CONST:\n       if (CONSTANT_P (XEXP (rtl, 0)))\n-\treturn add_const_value_attribute (die, XEXP (rtl, 0));\n+\treturn add_const_value_attribute (die, mode, XEXP (rtl, 0));\n       /* FALLTHROUGH */\n     case SYMBOL_REF:\n       if (!const_ok_for_output (rtl))\n@@ -20703,7 +20705,7 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl, bool cache_p)\n \n   rtl = rtl_for_decl_location (decl);\n   if (rtl && (CONSTANT_P (rtl) || GET_CODE (rtl) == CONST_STRING)\n-      && add_const_value_attribute (die, rtl))\n+      && add_const_value_attribute (die, DECL_MODE (decl), rtl))\n     return true;\n \n   /* See if we have single element location list that is equivalent to\n@@ -20724,7 +20726,7 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl, bool cache_p)\n       if (GET_CODE (rtl) == EXPR_LIST)\n \trtl = XEXP (rtl, 0);\n       if ((CONSTANT_P (rtl) || GET_CODE (rtl) == CONST_STRING)\n-\t  && add_const_value_attribute (die, rtl))\n+\t  && add_const_value_attribute (die, DECL_MODE (decl), rtl))\n \t return true;\n     }\n   /* If this decl is from BLOCK_NONLOCALIZED_VARS, we might need its\n@@ -20799,7 +20801,7 @@ tree_add_const_value_attribute (dw_die_ref die, tree t)\n      symbols.  */\n   rtl = rtl_for_decl_init (init, type);\n   if (rtl && !early_dwarf)\n-    return add_const_value_attribute (die, rtl);\n+    return add_const_value_attribute (die, TYPE_MODE (type), rtl);\n   /* If the host and target are sane, try harder.  */\n   if (CHAR_BIT == 8 && BITS_PER_UNIT == 8\n       && initializer_constant_valid_p (init, type))"}]}