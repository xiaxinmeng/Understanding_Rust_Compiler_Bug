{"sha": "423012407eef5b91fa84417f05d4db3bc8a2db1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDIzMDEyNDA3ZWVmNWI5MWZhODQ0MTdmMDVkNGRiM2JjOGEyZGIxYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-08-19T20:20:37Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-08-19T20:20:37Z"}, "message": "(can_combine_p): Don't reject SUBREG assignments here.\n\n(subst): Instead, do it here, but also allow it in as a nested SUBREG since\nthe inner one will be eliminated.\n(simplify_and_const_int): Convert (and (neg X) (const_int 1)) to a shift\nwhen X is known to be either 0 or 1.\n\nFrom-SVN: r5187", "tree": {"sha": "25b202b697c8a81f3a05f3c20c180d382545bbf3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25b202b697c8a81f3a05f3c20c180d382545bbf3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/423012407eef5b91fa84417f05d4db3bc8a2db1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/423012407eef5b91fa84417f05d4db3bc8a2db1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/423012407eef5b91fa84417f05d4db3bc8a2db1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/423012407eef5b91fa84417f05d4db3bc8a2db1a/comments", "author": null, "committer": null, "parents": [{"sha": "2df46b06a27b26a2b142fc28db58c57985bf0b6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2df46b06a27b26a2b142fc28db58c57985bf0b6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2df46b06a27b26a2b142fc28db58c57985bf0b6e"}], "stats": {"total": 42, "additions": 28, "deletions": 14}, "files": [{"sha": "6a39d876bf7ab243da700f03641ab1ee4afe49c9", "filename": "gcc/combine.c", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/423012407eef5b91fa84417f05d4db3bc8a2db1a/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/423012407eef5b91fa84417f05d4db3bc8a2db1a/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=423012407eef5b91fa84417f05d4db3bc8a2db1a", "patch": "@@ -843,20 +843,6 @@ can_combine_p (insn, i3, pred, succ, pdest, psrc)\n \n   /* Don't eliminate a store in the stack pointer.  */\n   if (dest == stack_pointer_rtx\n-      /* Don't install a subreg involving two modes not tieable.\n-\t It can worsen register allocation, and can even make invalid reload\n-\t insns, since the reg inside may need to be copied from in the\n-\t outside mode, and that may be invalid if it is an fp reg copied in\n-\t integer mode.  As a special exception, we can allow this if\n-\t I3 is simply copying DEST, a REG,  to CC0.  */\n-      || (GET_CODE (src) == SUBREG\n-\t  && ! MODES_TIEABLE_P (GET_MODE (src), GET_MODE (SUBREG_REG (src)))\n-#ifdef HAVE_cc0\n-\t  && ! (GET_CODE (i3) == INSN && GET_CODE (PATTERN (i3)) == SET\n-\t\t&& SET_DEST (PATTERN (i3)) == cc0_rtx\n-\t\t&& GET_CODE (dest) == REG && dest == SET_SRC (PATTERN (i3)))\n-#endif\n-\t  )\n       /* If we couldn't eliminate a field assignment, we can't combine.  */\n       || GET_CODE (dest) == ZERO_EXTRACT || GET_CODE (dest) == STRICT_LOW_PART\n       /* Don't combine with an insn that sets a register to itself if it has\n@@ -2788,6 +2774,27 @@ subst (x, from, to, in_dest, unique_copy)\n \n \t  if (COMBINE_RTX_EQUAL_P (XEXP (x, i), from))\n \t    {\n+\t      /* In general, don't install a subreg involving two modes not\n+\t\t tieable.  It can worsen register allocation, and can even\n+\t\t make invalid reload insns, since the reg inside may need to\n+\t\t be copied from in the outside mode, and that may be invalid\n+\t\t if it is an fp reg copied in integer mode.\n+\n+\t\t We allow two exceptions to this: It is valid if it is inside\n+\t\t another SUBREG and the mode of that SUBREG and the mode of\n+\t\t the inside of TO is tieable and it is valid if X is a SET\n+\t\t that copies FROM to CC0.  */\n+\t      if (GET_CODE (to) == SUBREG\n+\t\t  && ! MODES_TIEABLE_P (GET_MODE (to),\n+\t\t\t\t\tGET_MODE (SUBREG_REG (to)))\n+\t\t  && ! (code == SUBREG\n+\t\t\t&& MODES_TIEABLE_P (mode, GET_MODE (SUBREG_REG (to))))\n+#ifdef HAVE_cc0\n+\t\t  && ! (code == SET && i == 1 && XEXP (x, 0) == cc0_rtx)\n+#endif\n+\t\t  )\n+\t\treturn gen_rtx (CLOBBER, VOIDmode, const0_rtx);\n+\n \t      new = (unique_copy && n_occurrences ? copy_rtx (to) : to);\n \t      n_occurrences++;\n \t    }\n@@ -6260,6 +6267,7 @@ simplify_and_const_int (x, mode, varop, constop)\n   register enum machine_mode tmode;\n   register rtx temp;\n   unsigned HOST_WIDE_INT nonzero;\n+  int i;\n \n   /* Simplify VAROP knowing that we will be only looking at some of the\n      bits in it.  */\n@@ -6286,6 +6294,12 @@ simplify_and_const_int (x, mode, varop, constop)\n   if (constop == 0)\n     return const0_rtx;\n \n+  /* If VAROP is a NEG of something known to be zero or 1 and CONSTOP is\n+     a power of two, we can replace this with a ASHIFT.  */\n+  if (GET_CODE (varop) == NEG && nonzero_bits (XEXP (varop, 0), mode) == 1\n+      && (i = exact_log2 (constop)) >= 0)\n+    return simplify_shift_const (NULL_RTX, ASHIFT, mode, XEXP (varop, 0), i);\n+\t\t\t\t \n   /* If VAROP is an IOR or XOR, apply the AND to both branches of the IOR\n      or XOR, then try to apply the distributive law.  This may eliminate\n      operations if either branch can be simplified because of the AND."}]}