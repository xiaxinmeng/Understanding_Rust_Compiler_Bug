{"sha": "df96b059470a8ede40342b4b19c6da1a82851aaf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGY5NmIwNTk0NzBhOGVkZTQwMzQyYjRiMTljNmRhMWE4Mjg1MWFhZg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2008-10-09T08:17:08Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2008-10-09T08:17:08Z"}, "message": "re PR middle-end/37774 (Alignment information is lost for ARRAY_REFs)\n\n\tPR middle-end/37774\n\t* tree.h (get_object_alignment): Declare.\n\t* emit-rtl.c (set_mem_attributes_minus_bitpos): Call\n\tget_object_alignment if needed.\n\t* builtins.c (get_pointer_alignment): Move ADDR_EXPR operand handling\n\tto ...\n\t(get_object_alignment): ... here.  New function.  Try harder to\n\tdetermine alignment from get_inner_reference returned offset.\n\nFrom-SVN: r141003", "tree": {"sha": "4b26de45565f6554ef5ed3f5f27def80b657ef53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b26de45565f6554ef5ed3f5f27def80b657ef53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df96b059470a8ede40342b4b19c6da1a82851aaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df96b059470a8ede40342b4b19c6da1a82851aaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df96b059470a8ede40342b4b19c6da1a82851aaf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df96b059470a8ede40342b4b19c6da1a82851aaf/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cc2a64dd80513c1155fad3370bc639daa97b7404", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc2a64dd80513c1155fad3370bc639daa97b7404", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc2a64dd80513c1155fad3370bc639daa97b7404"}], "stats": {"total": 151, "additions": 98, "deletions": 53}, "files": [{"sha": "8e9648ae0616621614c0a23424e8d14e9d6db6b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df96b059470a8ede40342b4b19c6da1a82851aaf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df96b059470a8ede40342b4b19c6da1a82851aaf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=df96b059470a8ede40342b4b19c6da1a82851aaf", "patch": "@@ -7,6 +7,15 @@\n \t* tree-cfg.c (make_cond_expr_edges, make_goto_expr_edges): Only set\n \tgoto_block on edges if goto_locus is known.\n \n+\tPR middle-end/37774\n+\t* tree.h (get_object_alignment): Declare.\n+\t* emit-rtl.c (set_mem_attributes_minus_bitpos): Call\n+\tget_object_alignment if needed.\n+\t* builtins.c (get_pointer_alignment): Move ADDR_EXPR operand handling\n+\tto ...\n+\t(get_object_alignment): ... here.  New function.  Try harder to\n+\tdetermine alignment from get_inner_reference returned offset.\n+\n 2008-10-08  Jakub Jelinek  <jakub@redhat.com>\n \n \t* graphite.c (gloog): Don't call find_unreachable_blocks"}, {"sha": "5ed60bb0531f75e07dc157cb298875e9c01e8c06", "filename": "gcc/builtins.c", "status": "modified", "additions": 77, "deletions": 53, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df96b059470a8ede40342b4b19c6da1a82851aaf/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df96b059470a8ede40342b4b19c6da1a82851aaf/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=df96b059470a8ede40342b4b19c6da1a82851aaf", "patch": "@@ -253,6 +253,82 @@ static bool called_as_built_in (tree node)\n   return false;\n }\n \n+/* Return the alignment in bits of EXP, an object.\n+   Don't return more than MAX_ALIGN no matter what, ALIGN is the inital\n+   guessed alignment e.g. from type alignment.  */\n+\n+int\n+get_object_alignment (tree exp, unsigned int align, unsigned int max_align)\n+{\n+  unsigned int inner;\n+\n+  inner = max_align;\n+  if (handled_component_p (exp))\n+   {\n+      HOST_WIDE_INT bitsize, bitpos;\n+      tree offset;\n+      enum machine_mode mode; \n+      int unsignedp, volatilep;\n+\n+      exp = get_inner_reference (exp, &bitsize, &bitpos, &offset,\n+\t\t\t\t &mode, &unsignedp, &volatilep, true);\n+      if (bitpos)\n+\tinner = MIN (inner, (unsigned) (bitpos & -bitpos));\n+      while (offset)\n+\t{\n+\t  tree next_offset;\n+\n+\t  if (TREE_CODE (offset) == PLUS_EXPR)\n+\t    {\n+\t      next_offset = TREE_OPERAND (offset, 0);\n+\t      offset = TREE_OPERAND (offset, 1);\n+\t    }\n+\t  else\n+\t    next_offset = NULL;\n+\t  if (host_integerp (offset, 1))\n+\t    {\n+\t      /* Any overflow in calculating offset_bits won't change\n+\t\t the alignment.  */\n+\t      unsigned offset_bits\n+\t\t= ((unsigned) tree_low_cst (offset, 1) * BITS_PER_UNIT);\n+\n+\t      if (offset_bits)\n+\t\tinner = MIN (inner, (offset_bits & -offset_bits));\n+\t    }\n+\t  else if (TREE_CODE (offset) == MULT_EXPR\n+\t\t   && host_integerp (TREE_OPERAND (offset, 1), 1))\n+\t    {\n+\t      /* Any overflow in calculating offset_factor won't change\n+\t\t the alignment.  */\n+\t      unsigned offset_factor\n+\t\t= ((unsigned) tree_low_cst (TREE_OPERAND (offset, 1), 1)\n+\t\t   * BITS_PER_UNIT);\n+\n+\t      if (offset_factor)\n+\t\tinner = MIN (inner, (offset_factor & -offset_factor));\n+\t    }\n+\t  else\n+\t    {\n+\t      inner = MIN (inner, BITS_PER_UNIT);\n+\t      break;\n+\t    }\n+\t  offset = next_offset;\n+\t}\n+    }\n+  if (DECL_P (exp))\n+    align = MIN (inner, DECL_ALIGN (exp));\n+#ifdef CONSTANT_ALIGNMENT\n+  else if (CONSTANT_CLASS_P (exp))\n+    align = MIN (inner, (unsigned)CONSTANT_ALIGNMENT (exp, align));\n+#endif\n+  else if (TREE_CODE (exp) == VIEW_CONVERT_EXPR\n+\t   || TREE_CODE (exp) == INDIRECT_REF)\n+    align = MIN (TYPE_ALIGN (TREE_TYPE (exp)), inner);\n+  else\n+    align = MIN (align, inner);\n+  return MIN (align, max_align);\n+}\n+\n /* Return the alignment in bits of EXP, a pointer valued expression.\n    But don't return more than MAX_ALIGN no matter what.\n    The alignment returned is, by default, the alignment of the thing that\n@@ -306,59 +382,7 @@ get_pointer_alignment (tree exp, unsigned int max_align)\n \n \tcase ADDR_EXPR:\n \t  /* See what we are pointing at and look at its alignment.  */\n-\t  exp = TREE_OPERAND (exp, 0);\n-\t  inner = max_align;\n-\t  if (handled_component_p (exp))\n-\t    {\n-\t      HOST_WIDE_INT bitsize, bitpos;\n-\t      tree offset;\n-\t      enum machine_mode mode; \n-\t      int unsignedp, volatilep;\n-\n-\t      exp = get_inner_reference (exp, &bitsize, &bitpos, &offset,\n-\t\t\t\t\t &mode, &unsignedp, &volatilep, true);\n-\t      if (bitpos)\n-\t\tinner = MIN (inner, (unsigned) (bitpos & -bitpos));\n-\t      if (offset && TREE_CODE (offset) == PLUS_EXPR\n-\t\t  && host_integerp (TREE_OPERAND (offset, 1), 1))\n-\t        {\n-\t\t  /* Any overflow in calculating offset_bits won't change\n-\t\t     the alignment.  */\n-\t\t  unsigned offset_bits\n-\t\t    = ((unsigned) tree_low_cst (TREE_OPERAND (offset, 1), 1)\n-\t\t       * BITS_PER_UNIT);\n-\n-\t\t  if (offset_bits)\n-\t\t    inner = MIN (inner, (offset_bits & -offset_bits));\n-\t\t  offset = TREE_OPERAND (offset, 0);\n-\t\t}\n-\t      if (offset && TREE_CODE (offset) == MULT_EXPR\n-\t\t  && host_integerp (TREE_OPERAND (offset, 1), 1))\n-\t        {\n-\t\t  /* Any overflow in calculating offset_factor won't change\n-\t\t     the alignment.  */\n-\t\t  unsigned offset_factor\n-\t\t    = ((unsigned) tree_low_cst (TREE_OPERAND (offset, 1), 1)\n-\t\t       * BITS_PER_UNIT);\n-\n-\t\t  if (offset_factor)\n-\t\t    inner = MIN (inner, (offset_factor & -offset_factor));\n-\t\t}\n-\t      else if (offset)\n-\t\tinner = MIN (inner, BITS_PER_UNIT);\n-\t    }\n-\t  if (DECL_P (exp))\n-\t    align = MIN (inner, DECL_ALIGN (exp));\n-#ifdef CONSTANT_ALIGNMENT\n-\t  else if (CONSTANT_CLASS_P (exp))\n-\t    align = MIN (inner, (unsigned)CONSTANT_ALIGNMENT (exp, align));\n-#endif\n-\t  else if (TREE_CODE (exp) == VIEW_CONVERT_EXPR\n-\t\t   || TREE_CODE (exp) == INDIRECT_REF)\n-\t    align = MIN (TYPE_ALIGN (TREE_TYPE (exp)), inner);\n-\t  else\n-\t    align = MIN (align, inner);\n-\t  return MIN (align, max_align);\n+\t  return get_object_alignment (TREE_OPERAND (exp, 0), align, max_align);\n \n \tdefault:\n \t  return align;"}, {"sha": "4564a0b7485d6e40d355dbbff42c1c6ca0df6bcf", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df96b059470a8ede40342b4b19c6da1a82851aaf/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df96b059470a8ede40342b4b19c6da1a82851aaf/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=df96b059470a8ede40342b4b19c6da1a82851aaf", "patch": "@@ -1564,6 +1564,7 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n   if (! TYPE_P (t))\n     {\n       tree base;\n+      bool align_computed = false;\n \n       if (TREE_THIS_VOLATILE (t))\n \tMEM_VOLATILE_P (ref) = 1;\n@@ -1620,6 +1621,7 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t\t  && host_integerp (DECL_SIZE_UNIT (t), 1)\n \t\t  ? GEN_INT (tree_low_cst (DECL_SIZE_UNIT (t), 1)) : 0);\n \t  align = DECL_ALIGN (t);\n+\t  align_computed = true;\n \t}\n \n       /* If this is a constant, we know the alignment.  */\n@@ -1629,6 +1631,7 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n #ifdef CONSTANT_ALIGNMENT\n \t  align = CONSTANT_ALIGNMENT (t, align);\n #endif\n+\t  align_computed = true;\n \t}\n \n       /* If this is a field reference and not a bit-field, record it.  */\n@@ -1688,6 +1691,7 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t\t  align = DECL_ALIGN (t2);\n \t\t  if (aoff && (unsigned HOST_WIDE_INT) aoff < align)\n \t            align = aoff;\n+\t\t  align_computed = true;\n \t\t  offset = GEN_INT (ioff);\n \t\t  apply_bitpos = bitpos;\n \t\t}\n@@ -1721,6 +1725,13 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t  expr = t;\n \t  offset = NULL;\n \t}\n+\n+      if (!align_computed && !INDIRECT_REF_P (t))\n+\t{\n+\t  unsigned int obj_align\n+\t    = get_object_alignment (t, align, BIGGEST_ALIGNMENT);\n+\t  align = MAX (align, obj_align);\n+\t}\n     }\n \n   /* If we modified OFFSET based on T, then subtract the outstanding"}, {"sha": "034be6a35cbebbd3bdd02797093d78ae2df5544d", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df96b059470a8ede40342b4b19c6da1a82851aaf/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df96b059470a8ede40342b4b19c6da1a82851aaf/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=df96b059470a8ede40342b4b19c6da1a82851aaf", "patch": "@@ -4864,6 +4864,7 @@ extern tree build_string_literal (int, const char *);\n extern bool validate_arglist (const_tree, ...);\n extern rtx builtin_memset_read_str (void *, HOST_WIDE_INT, enum machine_mode);\n extern int get_pointer_alignment (tree, unsigned int);\n+extern int get_object_alignment (tree, unsigned int, unsigned int);\n extern tree fold_call_stmt (gimple, bool);\n extern tree gimple_fold_builtin_snprintf_chk (gimple, tree, enum built_in_function);\n "}]}