{"sha": "8b8ab8f473b42933b9c1e292c4b1ab02adf1863a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI4YWI4ZjQ3M2I0MjkzM2I5YzFlMjkyYzRiMWFiMDJhZGYxODYzYQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2019-10-18T19:03:43Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2019-10-18T19:03:43Z"}, "message": "[arm] early split most DImode comparison operations.\n\nThis patch does most of the work for early splitting the DImode\ncomparisons.  We now handle EQ, NE, LT, GE, LTU and GEU during early\nexpansion, in addition to EQ and NE, for which the expansion has now\nbeen reworked to use a standard conditional-compare pattern already in\nthe back-end.\n\nTo handle this we introduce two new condition flag modes that are used\nwhen comparing the upper words of decomposed DImode values: one for\nsigned, and one for unsigned comparisons.  CC_Bmode (B for Borrow) is\nessentially the inverse of CC_Cmode and is used when the carry flag is\nset by a subtraction of unsigned values.\n\n\t* config/arm/arm-modes.def (CC_NV, CC_B): New CC modes.\n\t* config/arm/arm.c (arm_select_cc_mode): Recognize constructs that\n\tneed these modes.\n\t(arm_gen_dicompare_reg): New code to early expand the sub-operations\n\tof EQ, NE, LT, GE, LTU and GEU.\n\t* config/arm/iterators.md (CC_EXTEND): New code attribute.\n\t* config/arm/predicates.md (arm_adcimm_operand): New predicate..\n\t* config/arm/arm.md (cmpsi3_carryin_<CC_EXTEND>out): New pattern.\n\t(cmpsi3_imm_carryin_<CC_EXTEND>out): Likewise.\n\t(cmpsi3_0_carryin_<CC_EXTEND>out): Likewise.\n\nFrom-SVN: r277179", "tree": {"sha": "94de7034a2c5cbea058927af8f467102b05226f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94de7034a2c5cbea058927af8f467102b05226f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b8ab8f473b42933b9c1e292c4b1ab02adf1863a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b8ab8f473b42933b9c1e292c4b1ab02adf1863a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b8ab8f473b42933b9c1e292c4b1ab02adf1863a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b8ab8f473b42933b9c1e292c4b1ab02adf1863a/comments", "author": null, "committer": null, "parents": [{"sha": "22060d0e575e7754eb1355763d22bbe37c3caa13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22060d0e575e7754eb1355763d22bbe37c3caa13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22060d0e575e7754eb1355763d22bbe37c3caa13"}], "stats": {"total": 294, "additions": 291, "deletions": 3}, "files": [{"sha": "aa489bd9c985d92cc7b32711f1fc9710e8a7af98", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b8ab8f473b42933b9c1e292c4b1ab02adf1863a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b8ab8f473b42933b9c1e292c4b1ab02adf1863a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b8ab8f473b42933b9c1e292c4b1ab02adf1863a", "patch": "@@ -1,3 +1,16 @@\n+2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* config/arm/arm-modes.def (CC_NV, CC_B): New CC modes.\n+\t* config/arm/arm.c (arm_select_cc_mode): Recognize constructs that\n+\tneed these modes.\n+\t(arm_gen_dicompare_reg): New code to early expand the sub-operations\n+\tof EQ, NE, LT, GE, LTU and GEU.\n+\t* config/arm/iterators.md (CC_EXTEND): New code attribute.\n+\t* config/arm/predicates.md (arm_adcimm_operand): New predicate..\n+\t* config/arm/arm.md (cmpsi3_carryin_<CC_EXTEND>out): New pattern.\n+\t(cmpsi3_imm_carryin_<CC_EXTEND>out): Likewise.\n+\t(cmpsi3_0_carryin_<CC_EXTEND>out): Likewise.\n+\n 2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config/arm/arm.md (cbranchdi4): Accept reg_or_int_operand for"}, {"sha": "65cddf68cdbedb4e513b97c08b5cfdd3c644a216", "filename": "gcc/config/arm/arm-modes.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b8ab8f473b42933b9c1e292c4b1ab02adf1863a/gcc%2Fconfig%2Farm%2Farm-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b8ab8f473b42933b9c1e292c4b1ab02adf1863a/gcc%2Fconfig%2Farm%2Farm-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-modes.def?ref=8b8ab8f473b42933b9c1e292c4b1ab02adf1863a", "patch": "@@ -34,19 +34,24 @@ ADJUST_FLOAT_FORMAT (HF, ((arm_fp16_format == ARM_FP16_FORMAT_ALTERNATIVE)\n    CC_Cmode should be used if only the C flag is set correctly, after an\n      addition.\n    CC_Nmode should be used if only the N (sign) flag is set correctly\n+   CC_NVmode should be used if only the N and V bits are set correctly,\n+     (used for signed comparisons when the carry is propagated in).\n    CC_CZmode should be used if only the C and Z flags are correct\n    (used for DImode unsigned comparisons).\n    CC_RSBmode should be used where the comparison is set by an RSB immediate,\n      or NEG instruction.  The form of the comparison for (const - reg) will\n      be (COMPARE (not (reg)) (~const)).\n    CC_NCVmode should be used if only the N, C, and V flags are correct\n+   CC_Bmode should be used if only the C flag is correct after a subtract\n+     (eg after an unsigned borrow with carry-in propagation).\n    (used for DImode signed comparisons).\n    CCmode should be used otherwise.  */\n \n CC_MODE (CC_NOOV);\n CC_MODE (CC_Z);\n CC_MODE (CC_CZ);\n CC_MODE (CC_NCV);\n+CC_MODE (CC_NV);\n CC_MODE (CC_SWP);\n CC_MODE (CC_RSB);\n CC_MODE (CCFP);\n@@ -62,6 +67,7 @@ CC_MODE (CC_DLTU);\n CC_MODE (CC_DGEU);\n CC_MODE (CC_DGTU);\n CC_MODE (CC_C);\n+CC_MODE (CC_B);\n CC_MODE (CC_N);\n CC_MODE (CC_V);\n "}, {"sha": "74c8eca7a646d454abc1796a498b8c7144f1fab0", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 217, "deletions": 3, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b8ab8f473b42933b9c1e292c4b1ab02adf1863a/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b8ab8f473b42933b9c1e292c4b1ab02adf1863a/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=8b8ab8f473b42933b9c1e292c4b1ab02adf1863a", "patch": "@@ -15348,6 +15348,22 @@ arm_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n       && (rtx_equal_p (XEXP (x, 0), y) || rtx_equal_p (XEXP (x, 1), y)))\n     return CC_Cmode;\n \n+  if (GET_MODE (x) == DImode\n+      && (op == GE || op == LT)\n+      && GET_CODE (x) == SIGN_EXTEND\n+      && ((GET_CODE (y) == PLUS\n+\t   && arm_borrow_operation (XEXP (y, 0), DImode))\n+\t  || arm_borrow_operation (y, DImode)))\n+    return CC_NVmode;\n+\n+  if (GET_MODE (x) == DImode\n+      && (op == GEU || op == LTU)\n+      && GET_CODE (x) == ZERO_EXTEND\n+      && ((GET_CODE (y) == PLUS\n+\t   && arm_borrow_operation (XEXP (y, 0), DImode))\n+\t  || arm_borrow_operation (y, DImode)))\n+    return CC_Bmode;\n+\n   if (GET_MODE (x) == DImode || GET_MODE (y) == DImode)\n     {\n       switch (op)\n@@ -15410,16 +15426,198 @@ arm_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n static rtx\n arm_gen_dicompare_reg (rtx_code code, rtx x, rtx y, rtx scratch)\n {\n-  /* We don't currently handle DImode in thumb1, but rely on libgcc.  */\n+  machine_mode mode;\n+  rtx cc_reg;\n+\n+    /* We don't currently handle DImode in thumb1, but rely on libgcc.  */\n   gcc_assert (TARGET_32BIT);\n \n+  rtx x_lo = simplify_gen_subreg (SImode, x, DImode,\n+\t\t\t\t  subreg_lowpart_offset (SImode, DImode));\n+  rtx x_hi = simplify_gen_subreg (SImode, x, DImode,\n+\t\t\t\t  subreg_highpart_offset (SImode, DImode));\n+  rtx y_lo = simplify_gen_subreg (SImode, y, DImode,\n+\t\t\t\t  subreg_lowpart_offset (SImode, DImode));\n+  rtx y_hi = simplify_gen_subreg (SImode, y, DImode,\n+\t\t\t\t  subreg_highpart_offset (SImode, DImode));\n+  switch (code)\n+    {\n+    case EQ:\n+    case NE:\n+      {\n+\t/* We should never have X as a const_int in this case.  */\n+\tgcc_assert (!CONST_INT_P (x));\n+\n+\tif (y_lo == const0_rtx || y_hi == const0_rtx)\n+\t  {\n+\t    if (y_lo != const0_rtx)\n+\t      {\n+\t\trtx scratch2 = scratch ? scratch : gen_reg_rtx (SImode);\n+\n+\t\tgcc_assert (y_hi == const0_rtx);\n+\t\ty_lo = gen_int_mode (-INTVAL (y_lo), SImode);\n+\t\tif (!arm_add_operand (y_lo, SImode))\n+\t\t  y_lo = force_reg (SImode, y_lo);\n+\t\temit_insn (gen_addsi3 (scratch2, x_lo, y_lo));\n+\t\tx_lo = scratch2;\n+\t      }\n+\t    else if (y_hi != const0_rtx)\n+\t      {\n+\t\trtx scratch2 = scratch ? scratch : gen_reg_rtx (SImode);\n+\n+\t\ty_hi = gen_int_mode (-INTVAL (y_hi), SImode);\n+\t\tif (!arm_add_operand (y_hi, SImode))\n+\t\t  y_hi = force_reg (SImode, y_hi);\n+\t\temit_insn (gen_addsi3 (scratch2, x_hi, y_hi));\n+\t\tx_hi = scratch2;\n+\t      }\n+\n+\t    if (!scratch)\n+\t      {\n+\t\tgcc_assert (!reload_completed);\n+\t\tscratch = gen_rtx_SCRATCH (SImode);\n+\t      }\n+\n+\t    rtx clobber = gen_rtx_CLOBBER (VOIDmode, scratch);\n+\t    cc_reg = gen_rtx_REG (CC_NOOVmode, CC_REGNUM);\n+\n+\t    rtx set\n+\t      = gen_rtx_SET (cc_reg,\n+\t\t\t     gen_rtx_COMPARE (CC_NOOVmode,\n+\t\t\t\t\t      gen_rtx_IOR (SImode, x_lo, x_hi),\n+\t\t\t\t\t      const0_rtx));\n+\t    emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, set,\n+\t\t\t\t\t\t\t      clobber)));\n+\t    return cc_reg;\n+\t  }\n+\n+\tif (!arm_add_operand (y_lo, SImode))\n+\t  y_lo = force_reg (SImode, y_lo);\n+\n+\tif (!arm_add_operand (y_hi, SImode))\n+\t  y_hi = force_reg (SImode, y_hi);\n+\n+\trtx cmp1 = gen_rtx_NE (SImode, x_lo, y_lo);\n+\trtx cmp2 = gen_rtx_NE (SImode, x_hi, y_hi);\n+\trtx conjunction = gen_rtx_IOR (SImode, cmp1, cmp2);\n+\tmode = SELECT_CC_MODE (code, conjunction, const0_rtx);\n+\tcc_reg = gen_rtx_REG (mode, CC_REGNUM);\n+\n+\temit_insn (gen_rtx_SET (cc_reg,\n+\t\t\t\tgen_rtx_COMPARE (VOIDmode, conjunction,\n+\t\t\t\t\t\t const0_rtx)));\n+\treturn cc_reg;\n+      }\n+\n+    case LT:\n+    case GE:\n+      {\n+\tif (y_lo == const0_rtx)\n+\t  {\n+\t    /* If the low word of y is 0, then this is simply a normal\n+\t       compare of the upper words.  */\n+\t    if (!arm_add_operand (y_hi, SImode))\n+\t      y_hi = force_reg (SImode, y_hi);\n+\n+\t    return arm_gen_compare_reg (code, x_hi, y_hi, NULL_RTX);\n+\t  }\n+\n+\tif (!arm_add_operand (y_lo, SImode))\n+\t  y_lo = force_reg (SImode, y_lo);\n+\n+\t/* Just for now.  */\n+\tif (!register_operand (x_lo, SImode))\n+\t  x_lo = force_reg (SImode, x_lo);\n+\n+\trtx cmp1\n+\t  = gen_rtx_LTU (DImode,\n+\t\t\t arm_gen_compare_reg (LTU, x_lo, y_lo, NULL_RTX),\n+\t\t\t const0_rtx);\n+\n+\tif (!scratch)\n+\t  scratch = gen_rtx_SCRATCH (SImode);\n+\tif (!arm_not_operand (y_hi, SImode))\n+\t  y_hi = force_reg (SImode, y_hi);\n+\n+\t/* Just for now.  */\n+\tif (!register_operand (x_hi, SImode))\n+\t  x_hi = force_reg (SImode, x_hi);\n+\n+\trtx_insn *insn;\n+\tif (y_hi == const0_rtx)\n+\t  insn = emit_insn (gen_cmpsi3_0_carryin_CC_NVout (scratch, x_hi,\n+\t\t\t\t\t\t\t   cmp1));\n+\telse if (CONST_INT_P (y_hi))\n+\t  insn = emit_insn (gen_cmpsi3_imm_carryin_CC_NVout (scratch, x_hi,\n+\t\t\t\t\t\t\t     y_hi, cmp1));\n+\telse\n+\t  insn = emit_insn (gen_cmpsi3_carryin_CC_NVout (scratch, x_hi, y_hi,\n+\t\t\t\t\t\t\t cmp1));\n+\treturn SET_DEST (single_set (insn));\n+      }\n+\n+    case LTU:\n+    case GEU:\n+      {\n+\tif (y_lo == const0_rtx)\n+\t  {\n+\t    /* If the low word of y is 0, then this is simply a normal\n+\t       compare of the upper words.  */\n+\t    if (!arm_add_operand (y_hi, SImode))\n+\t      y_hi = force_reg (SImode, y_hi);\n+\n+\t    return arm_gen_compare_reg (code, x_hi, y_hi, NULL_RTX);\n+\t  }\n+\n+\tif (!arm_add_operand (y_lo, SImode))\n+\t  y_lo = force_reg (SImode, y_lo);\n+\n+\t/* Just for now.  */\n+\tif (!register_operand (x_lo, SImode))\n+\t  x_lo = force_reg (SImode, x_lo);\n+\n+\trtx cmp1\n+\t  = gen_rtx_LTU (DImode,\n+\t\t\t arm_gen_compare_reg (LTU, x_lo, y_lo, NULL_RTX),\n+\t\t\t const0_rtx);\n+\n+\tif (!scratch)\n+\t  scratch = gen_rtx_SCRATCH (SImode);\n+\tif (!arm_not_operand (y_hi, SImode))\n+\t  y_hi = force_reg (SImode, y_hi);\n+\n+\t/* Just for now.  */\n+\tif (!register_operand (x_hi, SImode))\n+\t  x_hi = force_reg (SImode, x_hi);\n+\n+\trtx_insn *insn;\n+\tif (y_hi == const0_rtx)\n+\t  insn = emit_insn (gen_cmpsi3_0_carryin_CC_Bout (scratch, x_hi,\n+\t\t\t\t\t\t\t  cmp1));\n+\telse if (CONST_INT_P (y_hi))\n+\t  {\n+\t    /* Constant is viewed as unsigned when zero-extended.  */\n+\t    y_hi = GEN_INT (UINTVAL (y_hi) & 0xffffffffULL);\n+\t    insn = emit_insn (gen_cmpsi3_imm_carryin_CC_Bout (scratch, x_hi,\n+\t\t\t\t\t\t\t      y_hi, cmp1));\n+\t  }\n+\telse\n+\t  insn = emit_insn (gen_cmpsi3_carryin_CC_Bout (scratch, x_hi, y_hi,\n+\t\t\t\t\t\t\tcmp1));\n+\treturn SET_DEST (single_set (insn));\n+      }\n+\n+    default:\n+      break;\n+    }\n+\n   /* We might have X as a constant, Y as a register because of the predicates\n      used for cmpdi.  If so, force X to a register here.  */\n   if (!REG_P (x))\n     x = force_reg (DImode, x);\n \n-  machine_mode mode = SELECT_CC_MODE (code, x, y);\n-  rtx cc_reg = gen_rtx_REG (mode, CC_REGNUM);\n+  mode = SELECT_CC_MODE (code, x, y);\n+  cc_reg = gen_rtx_REG (mode, CC_REGNUM);\n \n   if (mode != CC_CZmode)\n     {\n@@ -23803,6 +24001,22 @@ maybe_get_arm_condition_code (rtx comparison)\n \tdefault: return ARM_NV;\n \t}\n \n+    case E_CC_NVmode:\n+      switch (comp_code)\n+\t{\n+\tcase GE: return ARM_GE;\n+\tcase LT: return ARM_LT;\n+\tdefault: return ARM_NV;\n+\t}\n+\n+    case E_CC_Bmode:\n+      switch (comp_code)\n+\t{\n+\tcase GEU: return ARM_CS;\n+\tcase LTU: return ARM_CC;\n+\tdefault: return ARM_NV;\n+\t}\n+\n     case E_CC_Vmode:\n       switch (comp_code)\n \t{"}, {"sha": "f0ff4dda39679751258df1b3ff0b3dba04ba458c", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b8ab8f473b42933b9c1e292c4b1ab02adf1863a/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b8ab8f473b42933b9c1e292c4b1ab02adf1863a/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=8b8ab8f473b42933b9c1e292c4b1ab02adf1863a", "patch": "@@ -1009,6 +1009,51 @@\n    (set_attr \"type\" \"adc_reg,adc_imm,alu_shift_imm\")]\n )\n \n+(define_insn \"cmpsi3_carryin_<CC_EXTEND>out\"\n+  [(set (reg:<CC_EXTEND> CC_REGNUM)\n+\t(compare:<CC_EXTEND>\n+\t (SE:DI (match_operand:SI 1 \"s_register_operand\" \"0,r\"))\n+\t (plus:DI (match_operand:DI 3 \"arm_borrow_operation\" \"\")\n+\t\t  (SE:DI (match_operand:SI 2 \"s_register_operand\" \"l,r\")))))\n+   (clobber (match_scratch:SI 0 \"=l,r\"))]\n+  \"TARGET_32BIT\"\n+  \"sbcs\\\\t%0, %1, %2\"\n+  [(set_attr \"conds\" \"set\")\n+   (set_attr \"arch\" \"t2,*\")\n+   (set_attr \"length\" \"2,4\")\n+   (set_attr \"type\" \"adc_reg\")]\n+)\n+\n+;; Similar to the above, but handling a constant which has a different\n+;; canonicalization.\n+(define_insn \"cmpsi3_imm_carryin_<CC_EXTEND>out\"\n+  [(set (reg:<CC_EXTEND> CC_REGNUM)\n+\t(compare:<CC_EXTEND>\n+\t (SE:DI (match_operand:SI 1 \"s_register_operand\" \"r,r\"))\n+\t (plus:DI (match_operand:DI 3 \"arm_borrow_operation\" \"\")\n+\t\t  (match_operand:DI 2 \"arm_adcimm_operand\" \"I,K\"))))\n+   (clobber (match_scratch:SI 0 \"=l,r\"))]\n+  \"TARGET_32BIT\"\n+  \"@\n+   sbcs\\\\t%0, %1, %2\n+   adcs\\\\t%0, %1, #%B2\"\n+  [(set_attr \"conds\" \"set\")\n+   (set_attr \"type\" \"adc_imm\")]\n+)\n+\n+;; Further canonicalization when the constant is zero.\n+(define_insn \"cmpsi3_0_carryin_<CC_EXTEND>out\"\n+  [(set (reg:<CC_EXTEND> CC_REGNUM)\n+\t(compare:<CC_EXTEND>\n+\t (SE:DI (match_operand:SI 1 \"s_register_operand\" \"r,r\"))\n+\t (match_operand:DI 2 \"arm_borrow_operation\" \"\")))\n+   (clobber (match_scratch:SI 0 \"=l,r\"))]\n+  \"TARGET_32BIT\"\n+  \"sbcs\\\\t%0, %1, #0\"\n+  [(set_attr \"conds\" \"set\")\n+   (set_attr \"type\" \"adc_imm\")]\n+)\n+\n (define_insn \"*subsi3_carryin_const\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n \t(minus:SI (plus:SI"}, {"sha": "5f1c833ad80ab6c85006338292f947dc141ed52f", "filename": "gcc/config/arm/iterators.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b8ab8f473b42933b9c1e292c4b1ab02adf1863a/gcc%2Fconfig%2Farm%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b8ab8f473b42933b9c1e292c4b1ab02adf1863a/gcc%2Fconfig%2Farm%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fiterators.md?ref=8b8ab8f473b42933b9c1e292c4b1ab02adf1863a", "patch": "@@ -792,6 +792,10 @@\n ;; Code attributes\n ;;----------------------------------------------------------------------------\n \n+;; Determine the mode of a 'wide compare', ie where the carry flag is\n+;; propagated into the comparison.\n+(define_code_attr CC_EXTEND [(sign_extend \"CC_NV\") (zero_extend \"CC_B\")])\n+\n ;; Assembler mnemonics for vqh_ops and vqhs_ops iterators.\n (define_code_attr VQH_mnem [(plus \"vadd\") (smin \"vmin\") (smax \"vmax\")\n                 (umin \"vmin\") (umax \"vmax\")])"}, {"sha": "d9470df80933b50490c40d2beeddb67eefdae695", "filename": "gcc/config/arm/predicates.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b8ab8f473b42933b9c1e292c4b1ab02adf1863a/gcc%2Fconfig%2Farm%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b8ab8f473b42933b9c1e292c4b1ab02adf1863a/gcc%2Fconfig%2Farm%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpredicates.md?ref=8b8ab8f473b42933b9c1e292c4b1ab02adf1863a", "patch": "@@ -229,6 +229,12 @@\n   (ior (match_operand 0 \"arm_rhs_operand\")\n        (match_operand 0 \"arm_not_immediate_operand\")))\n \n+;; A constant that can be used with ADC(SBC) or SBC(ADC) when bit-wise\n+;; inverted.  Similar to arm_not_operand, but excludes registers.\n+(define_predicate \"arm_adcimm_operand\"\n+  (ior (match_operand 0 \"arm_immediate_operand\")\n+       (match_operand 0 \"arm_not_immediate_operand\")))\n+\n (define_predicate \"arm_di_operand\"\n   (ior (match_operand 0 \"s_register_operand\")\n        (match_operand 0 \"arm_immediate_di_operand\")))"}]}