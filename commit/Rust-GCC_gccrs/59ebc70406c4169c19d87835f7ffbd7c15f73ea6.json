{"sha": "59ebc70406c4169c19d87835f7ffbd7c15f73ea6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTllYmM3MDQwNmM0MTY5YzE5ZDg3ODM1ZjdmZmJkN2MxNWY3M2VhNg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-05-14T03:25:44Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-05-14T03:25:44Z"}, "message": "tree-eh.c (leh_tf_state): Change the type of dest_array to VEC(tree,heap)*.\n\n\t* tree-eh.c (leh_tf_state): Change the type of dest_array to\n\tVEC(tree,heap)*.\n\t(maybe_record_in_goto_queue, lower_try_finally_onedest,\n\tlower_try_finally_copy, lower_try_finally_switch,\n\tlower_try_finally): Use VEC instead of VARRAY.\n\nFrom-SVN: r99693", "tree": {"sha": "ad88068a5a5d204334a5d874054eb3d567837100", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad88068a5a5d204334a5d874054eb3d567837100"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59ebc70406c4169c19d87835f7ffbd7c15f73ea6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59ebc70406c4169c19d87835f7ffbd7c15f73ea6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59ebc70406c4169c19d87835f7ffbd7c15f73ea6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59ebc70406c4169c19d87835f7ffbd7c15f73ea6/comments", "author": null, "committer": null, "parents": [{"sha": "8238307080c8eb69073ff7d4f372afd91336107c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8238307080c8eb69073ff7d4f372afd91336107c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8238307080c8eb69073ff7d4f372afd91336107c"}], "stats": {"total": 38, "additions": 19, "deletions": 19}, "files": [{"sha": "91e30783d84147900b005a4277024ccd7bedb339", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59ebc70406c4169c19d87835f7ffbd7c15f73ea6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59ebc70406c4169c19d87835f7ffbd7c15f73ea6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=59ebc70406c4169c19d87835f7ffbd7c15f73ea6", "patch": "@@ -1,3 +1,11 @@\n+2005-05-14  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* tree-eh.c (leh_tf_state): Change the type of dest_array to\n+\tVEC(tree,heap)*.\n+\t(maybe_record_in_goto_queue, lower_try_finally_onedest,\n+\tlower_try_finally_copy, lower_try_finally_switch,\n+\tlower_try_finally): Use VEC instead of VARRAY.\n+\n 2005-05-14  Hans-Peter Nilsson  <hp@axis.com>\n \n \t* config/cris/cris.h (Node: Register Classes): Remove obsoleted"}, {"sha": "4931982005473243e2f1b778ba34dd26b5530cec", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59ebc70406c4169c19d87835f7ffbd7c15f73ea6/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59ebc70406c4169c19d87835f7ffbd7c15f73ea6/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=59ebc70406c4169c19d87835f7ffbd7c15f73ea6", "patch": "@@ -320,7 +320,7 @@ struct leh_tf_state\n   size_t goto_queue_active;\n \n   /* The set of unique labels seen as entries in the goto queue.  */\n-  varray_type dest_array;\n+  VEC(tree,heap) *dest_array;\n \n   /* A label to be added at the end of the completed transformed\n      sequence.  It will be set if may_fallthru was true *at one time*,\n@@ -501,18 +501,18 @@ maybe_record_in_goto_queue (struct leh_state *state, tree stmt)\n \n \tif (! tf->dest_array)\n \t  {\n-\t    VARRAY_TREE_INIT (tf->dest_array, 10, \"dest_array\");\n-\t    VARRAY_PUSH_TREE (tf->dest_array, lab);\n+\t    tf->dest_array = VEC_alloc (tree, heap, 10);\n+\t    VEC_quick_push (tree, tf->dest_array, lab);\n \t    index = 0;\n \t  }\n \telse\n \t  {\n-\t    int n = VARRAY_ACTIVE_SIZE (tf->dest_array);\n+\t    int n = VEC_length (tree, tf->dest_array);\n \t    for (index = 0; index < n; ++index)\n-\t      if (VARRAY_TREE (tf->dest_array, index) == lab)\n+\t      if (VEC_index (tree, tf->dest_array, index) == lab)\n \t\tbreak;\n \t    if (index == n)\n-\t      VARRAY_PUSH_TREE (tf->dest_array, lab);\n+\t      VEC_safe_push (tree, heap, tf->dest_array, lab);\n \t  }\n       }\n       break;\n@@ -996,7 +996,7 @@ lower_try_finally_onedest (struct leh_state *state, struct leh_tf_state *tf)\n \tdo_goto_redirection (q, finally_label, NULL);\n       replace_goto_queue (tf);\n \n-      if (VARRAY_TREE (tf->dest_array, 0) == tf->fallthru_label)\n+      if (VEC_index (tree, tf->dest_array, 0) == tf->fallthru_label)\n \t{\n \t  /* Reachable by goto to fallthru label only.  Redirect it\n \t     to the new label (already created, sadly), and do not\n@@ -1060,10 +1060,7 @@ lower_try_finally_copy (struct leh_state *state, struct leh_tf_state *tf)\n \ttree label;\n       } *labels;\n \n-      if (tf->dest_array)\n-\treturn_index = VARRAY_ACTIVE_SIZE (tf->dest_array);\n-      else\n-\treturn_index = 0;\n+      return_index = VEC_length (tree, tf->dest_array);\n       labels = xcalloc (sizeof (*labels), return_index + 1);\n \n       q = tf->goto_queue;\n@@ -1152,10 +1149,7 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n   lower_eh_constructs_1 (state, &finally);\n \n   /* Prepare for switch statement generation.  */\n-  if (tf->dest_array)\n-    nlabels = VARRAY_ACTIVE_SIZE (tf->dest_array);\n-  else\n-    nlabels = 0;\n+  nlabels = VEC_length (tree, tf->dest_array);\n   return_index = nlabels;\n   eh_index = return_index + tf->may_return;\n   fallthru_index = eh_index + tf->may_throw;\n@@ -1389,10 +1383,7 @@ lower_try_finally (struct leh_state *state, tree *tp)\n      how many destinations are reached by the finally block.  Use this to\n      determine how we process the finally block itself.  */\n \n-  if (this_tf.dest_array)\n-    ndests = VARRAY_ACTIVE_SIZE (this_tf.dest_array);\n-  else\n-    ndests = 0;\n+  ndests = VEC_length (tree, this_tf.dest_array);\n   ndests += this_tf.may_fallthru;\n   ndests += this_tf.may_return;\n   ndests += this_tf.may_throw;\n@@ -1424,6 +1415,7 @@ lower_try_finally (struct leh_state *state, tree *tp)\n       append_to_statement_list (x, tp);\n     }\n \n+  VEC_free (tree, heap, this_tf.dest_array);\n   if (this_tf.goto_queue)\n     free (this_tf.goto_queue);\n }"}]}