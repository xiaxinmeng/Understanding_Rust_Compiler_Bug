{"sha": "04afbf1c7feeaecd4d0e85bd2566ef3e65e84b21", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDRhZmJmMWM3ZmVlYWVjZDRkMGU4NWJkMjU2NmVmM2U2NWU4NGIyMQ==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2010-02-21T18:06:39Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2010-02-21T18:06:39Z"}, "message": "re PR c++/42824 (c++ compilation complains about error: call of overloaded)\n\nFix PR c++/42824\n\ngcc/cp/ChangeLog:\n\tPR c++/42824\n\t* pt.c (lookup_template_class): Better support of specialization\n\tof member of class template implicit instantiation.\n\ngcc/testsuite/ChangeLog:\n\tPR c++/42824\n\t* g++.dg/template/memclass4.C: New test.\n\nFrom-SVN: r156939", "tree": {"sha": "5f7f5bd5b1fcd57934503d28f2e1124f13056837", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f7f5bd5b1fcd57934503d28f2e1124f13056837"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04afbf1c7feeaecd4d0e85bd2566ef3e65e84b21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04afbf1c7feeaecd4d0e85bd2566ef3e65e84b21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04afbf1c7feeaecd4d0e85bd2566ef3e65e84b21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04afbf1c7feeaecd4d0e85bd2566ef3e65e84b21/comments", "author": null, "committer": null, "parents": [{"sha": "d66489977ef89a02300f3441c1fb183236351a76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d66489977ef89a02300f3441c1fb183236351a76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d66489977ef89a02300f3441c1fb183236351a76"}], "stats": {"total": 171, "additions": 154, "deletions": 17}, "files": [{"sha": "2ce5e0201959b9657998400719abeec9cd611f5a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04afbf1c7feeaecd4d0e85bd2566ef3e65e84b21/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04afbf1c7feeaecd4d0e85bd2566ef3e65e84b21/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=04afbf1c7feeaecd4d0e85bd2566ef3e65e84b21", "patch": "@@ -1,3 +1,9 @@\n+2010-02-21  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/42824\n+\t* pt.c (lookup_template_class): Better support of specialization\n+\tof member of class template implicit instantiation.\n+\n 2010-02-20  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR c++/35669"}, {"sha": "8b19e2c4cbfe0d3475e2d912a450b1c0bcb2c18a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 73, "deletions": 17, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04afbf1c7feeaecd4d0e85bd2566ef3e65e84b21/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04afbf1c7feeaecd4d0e85bd2566ef3e65e84b21/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=04afbf1c7feeaecd4d0e85bd2566ef3e65e84b21", "patch": "@@ -6379,7 +6379,8 @@ lookup_template_class (tree d1,\n       tree found = NULL_TREE;\n       int arg_depth;\n       int parm_depth;\n-      int is_partial_instantiation;\n+      int is_dependent_type;\n+      int use_partial_inst_tmpl = false;\n \n       gen_tmpl = most_general_template (templ);\n       parmlist = DECL_TEMPLATE_PARMS (gen_tmpl);\n@@ -6495,21 +6496,17 @@ lookup_template_class (tree d1,\n       if (entry)\n \tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, entry->spec);\n \n-      /* This type is a \"partial instantiation\" if any of the template\n-\t arguments still involve template parameters.  Note that we set\n-\t IS_PARTIAL_INSTANTIATION for partial specializations as\n-\t well.  */\n-      is_partial_instantiation = uses_template_parms (arglist);\n+      is_dependent_type = uses_template_parms (arglist);\n \n       /* If the deduced arguments are invalid, then the binding\n \t failed.  */\n-      if (!is_partial_instantiation\n+      if (!is_dependent_type\n \t  && check_instantiated_args (gen_tmpl,\n \t\t\t\t      INNERMOST_TEMPLATE_ARGS (arglist),\n \t\t\t\t      complain))\n \tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n \n-      if (!is_partial_instantiation\n+      if (!is_dependent_type\n \t  && !PRIMARY_TEMPLATE_P (gen_tmpl)\n \t  && !LAMBDA_TYPE_P (TREE_TYPE (gen_tmpl))\n \t  && TREE_CODE (CP_DECL_CONTEXT (gen_tmpl)) == NAMESPACE_DECL)\n@@ -6528,7 +6525,7 @@ lookup_template_class (tree d1,\n       /* Create the type.  */\n       if (TREE_CODE (template_type) == ENUMERAL_TYPE)\n \t{\n-\t  if (!is_partial_instantiation)\n+\t  if (!is_dependent_type)\n \t    {\n \t      set_current_access_from_decl (TYPE_NAME (template_type));\n \t      t = start_enum (TYPE_IDENTIFIER (template_type),\n@@ -6594,11 +6591,71 @@ lookup_template_class (tree d1,\n \t  DECL_VISIBILITY (type_decl) = CLASSTYPE_VISIBILITY (template_type);\n \t}\n \n-      /* Set up the template information.  We have to figure out which\n-\t template is the immediate parent if this is a full\n-\t instantiation.  */\n-      if (parm_depth == 1 || is_partial_instantiation\n-\t  || !PRIMARY_TEMPLATE_P (gen_tmpl))\n+      /* Let's consider the explicit specialization of a member\n+         of a class template specialization that is implicitely instantiated,\n+\t e.g.:\n+\t     template<class T>\n+\t     struct S\n+\t     {\n+\t       template<class U> struct M {}; //#0\n+\t     };\n+\n+\t     template<>\n+\t     template<>\n+\t     struct S<int>::M<char> //#1\n+\t     {\n+\t       int i;\n+\t     };\n+\t[temp.expl.spec]/4 says this is valid.\n+\n+\tIn this case, when we write:\n+\tS<int>::M<char> m;\n+\n+\tM is instantiated from the CLASSTYPE_TI_TEMPLATE of #1, not from\n+\tthe one of #0.\n+\n+\tWhen we encounter #1, we want to store the partial instantiation\n+\tof M (template<class T> S<int>::M<T>) in it's CLASSTYPE_TI_TEMPLATE.\n+\n+\tFor all cases other than this \"explicit specialization of member of a\n+\tclass template\", we just want to store the most general template into\n+\tthe CLASSTYPE_TI_TEMPLATE of M.\n+\n+\tThis case of \"explicit specialization of member of a class template\"\n+\tonly happens when:\n+\t1/ the enclosing class is an instantiation of, and therefore not\n+\tthe same as, the context of the most general template, and\n+\t2/ we aren't looking at the partial instantiation itself, i.e.\n+\tthe innermost arguments are not the same as the innermost parms of\n+\tthe most general template.\n+\n+\tSo it's only when 1/ and 2/ happens that we want to use the partial\n+\tinstantiation of the member template in lieu of its most general\n+\ttemplate.  */\n+\n+      if (PRIMARY_TEMPLATE_P (gen_tmpl)\n+\t  && TMPL_ARGS_HAVE_MULTIPLE_LEVELS (arglist)\n+\t  /* the enclosing class must be an instantiation...  */\n+\t  && CLASS_TYPE_P (context)\n+\t  && !same_type_p (context, DECL_CONTEXT (gen_tmpl)))\n+\t{\n+\t  tree partial_inst_args;\n+\t  TREE_VEC_LENGTH (arglist)--;\n+\t  ++processing_template_decl;\n+\t  partial_inst_args =\n+\t    tsubst (INNERMOST_TEMPLATE_ARGS\n+\t\t\t(CLASSTYPE_TI_ARGS (TREE_TYPE (gen_tmpl))),\n+\t\t    arglist, complain, NULL_TREE);\n+\t  --processing_template_decl;\n+\t  TREE_VEC_LENGTH (arglist)++;\n+\t  use_partial_inst_tmpl =\n+\t    /*...and we must not be looking at the partial instantiation\n+\t     itself. */\n+\t    !comp_template_args (INNERMOST_TEMPLATE_ARGS (arglist),\n+\t\t\t\t partial_inst_args);\n+\t}\n+\n+      if (!use_partial_inst_tmpl)\n \t/* This case is easy; there are no member templates involved.  */\n \tfound = gen_tmpl;\n       else\n@@ -6628,8 +6685,7 @@ lookup_template_class (tree d1,\n \t= tree_cons (arglist, t,\n \t\t     DECL_TEMPLATE_INSTANTIATIONS (templ));\n \n-      if (TREE_CODE (t) == ENUMERAL_TYPE\n-\t  && !is_partial_instantiation)\n+      if (TREE_CODE (t) == ENUMERAL_TYPE && !is_dependent_type)\n \t/* Now that the type has been registered on the instantiations\n \t   list, we set up the enumerators.  Because the enumeration\n \t   constants may involve the enumeration type itself, we make\n@@ -6639,7 +6695,7 @@ lookup_template_class (tree d1,\n \t   the instantiation and exit above.  */\n \ttsubst_enum (template_type, t, arglist);\n \n-      if (is_partial_instantiation)\n+      if (is_dependent_type)\n \t/* If the type makes use of template parameters, the\n \t   code that generates debugging information will crash.  */\n \tDECL_IGNORED_P (TYPE_STUB_DECL (t)) = 1;"}, {"sha": "cc94d47287e9aa7b56367b9bfacd5c32f62af231", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04afbf1c7feeaecd4d0e85bd2566ef3e65e84b21/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04afbf1c7feeaecd4d0e85bd2566ef3e65e84b21/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=04afbf1c7feeaecd4d0e85bd2566ef3e65e84b21", "patch": "@@ -1,3 +1,8 @@\n+2010-02-21  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/42824\n+\t* g++.dg/template/memclass4.C: New test.\n+\n 2010-02-21  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/35259"}, {"sha": "65a42a4c2ad8fb9d071b4027d60d0dd71eda5e4d", "filename": "gcc/testsuite/g++.dg/template/memclass4.C", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04afbf1c7feeaecd4d0e85bd2566ef3e65e84b21/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemclass4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04afbf1c7feeaecd4d0e85bd2566ef3e65e84b21/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemclass4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemclass4.C?ref=04afbf1c7feeaecd4d0e85bd2566ef3e65e84b21", "patch": "@@ -0,0 +1,70 @@\n+// Origin: PR c++/42824\n+// { dg-do compile }\n+\n+template<int T>\n+class int_ {\n+};\n+\n+template<int T, int T2>\n+class Unit {\n+public:\n+    Unit(const Unit<T, T2>& other) {}\n+};\n+\n+template<int T>\n+class Quan {\n+public:\n+    Quan(void) {}\n+\n+    template<int T2>\n+    Quan(double value, Unit<T, T2> unit) {}\n+};\n+typedef Quan<0> Scalar;\n+\n+template<int T>\n+class hlp {\n+public:\n+   typedef Quan<T> type;\n+};\n+\n+class Mtrl {\n+public:\n+    template<int T>\n+    struct AssoType {\n+        typedef typename hlp<T>::type type;\n+    };\n+};\n+\n+template<class T>\n+class Eval {\n+public:\n+    Eval(const T& object){}\n+\n+    template<int V>\n+    void eval() {\n+        eval<V> (int_<0>());\n+    }\n+private:\n+    template<typename U> struct Wrap {};\n+\n+    template<int V, int V2>\n+    void value(Wrap<Quan<V2> >) {}\n+\n+    template<int V>\n+    void value(Wrap<Scalar>) {}\n+\n+    template<int V>\n+    void eval(int_<0>) {\n+        typedef typename T::template AssoType<V>::type Type;\n+        value<V>(Wrap<Type>());\n+    }\n+};\n+\n+class Foo {\n+public:\n+    static void eval(const Mtrl& mtrl) {\n+        Eval<Mtrl> h(mtrl);\n+        h.eval<0> ();\n+    }\n+};\n+"}]}