{"sha": "2c044ff123ee573b7cd63d88f544091b7aeeb8f6", "node_id": "C_kwDOANBUbNoAKDJjMDQ0ZmYxMjNlZTU3M2I3Y2Q2M2Q4OGY1NDQwOTFiN2FlZWI4ZjY", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-07-19T13:53:39Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-07-19T13:53:39Z"}, "message": "analyzer: fix taint handling of switch statements [PR106321]\n\nPR analyzer/106321 reports false positives from\n-Wanalyzer-tainted-array-index on switch statements, seen e.g.\nin the Linux kernel in drivers/vfio/pci/vfio_pci_core.c, where\nvfio_pci_core_ioctl has:\n\n    |  744 |                 switch (info.index) {\n    |      |                 ~~~~~~  ~~~~~~~~~~\n    |      |                 |           |\n    |      |                 |           (8) ...to here\n    |      |                 (9) following \u2018case 0 ... 5:\u2019 branch...\n    |......\n    |  751 |                 case VFIO_PCI_BAR0_REGION_INDEX ... VFIO_PCI_BAR5_REGION_INDEX:\n    |      |                 ~~~~\n    |      |                 |\n    |      |                 (10) ...to here\n\nand then a false complaint about \"use of attacker-controlled value\n\u2018info.index\u2019 in array lookup without upper-bounds checking\", where\ninfo.index has clearly had its bounds checked by the switch/case.\n\nIt turns out that when I rewrote switch handling for the analyzer in\nr12-3101-g8ca7fa84a3af35, I removed notifications to state machines\nabout the constraints on cases.\n\nThis patch fixes that oversight by adding a new on_bounded_ranges vfunc\nfor region_model_context, called on switch statement edges, which calls\na new state_machine vfunc.  It implements it for the \"taint\" state\nmachine, so that it updates the \"has bounds\" flags at out-edges for\nswitch statements, based on whether the bounds from the edge appear to\nactually constrain the switch index.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/106321\n\t* constraint-manager.h (bounded_ranges::get_count): New.\n\t(bounded_ranges::get_range): New.\n\t* engine.cc (impl_region_model_context::on_bounded_ranges): New.\n\t* exploded-graph.h (impl_region_model_context::on_bounded_ranges):\n\tNew decl.\n\t* region-model.cc (region_model::apply_constraints_for_gswitch):\n\tPotentially call ctxt->on_bounded_ranges.\n\t* region-model.h (region_model_context::on_bounded_ranges): New\n\tvfunc.\n\t(noop_region_model_context::on_bounded_ranges): New.\n\t(region_model_context_decorator::on_bounded_ranges): New.\n\t* sm-taint.cc: Include \"analyzer/constraint-manager.h\".\n\t(taint_state_machine::on_bounded_ranges): New.\n\t* sm.h (state_machine::on_bounded_ranges): New.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/106321\n\t* gcc.dg/analyzer/torture/taint-read-index-2.c: Add test coverage\n\tfor switch statements.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "eaad74eba8c3f7f6d16675bcb3f73df3b0122f1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eaad74eba8c3f7f6d16675bcb3f73df3b0122f1f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c044ff123ee573b7cd63d88f544091b7aeeb8f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c044ff123ee573b7cd63d88f544091b7aeeb8f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c044ff123ee573b7cd63d88f544091b7aeeb8f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c044ff123ee573b7cd63d88f544091b7aeeb8f6/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "434d521d118fc7e7759b2b42bdddfa70caec637b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/434d521d118fc7e7759b2b42bdddfa70caec637b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/434d521d118fc7e7759b2b42bdddfa70caec637b"}], "stats": {"total": 203, "additions": 203, "deletions": 0}, "files": [{"sha": "1271f18f1d1db1dc2509de48b97db29c318fae31", "filename": "gcc/analyzer/constraint-manager.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c044ff123ee573b7cd63d88f544091b7aeeb8f6/gcc%2Fanalyzer%2Fconstraint-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c044ff123ee573b7cd63d88f544091b7aeeb8f6/gcc%2Fanalyzer%2Fconstraint-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fconstraint-manager.h?ref=2c044ff123ee573b7cd63d88f544091b7aeeb8f6", "patch": "@@ -138,6 +138,9 @@ struct bounded_ranges\n \n   static int cmp (const bounded_ranges *a, const bounded_ranges *b);\n \n+  unsigned get_count () const { return m_ranges.length (); }\n+  const bounded_range &get_range (unsigned idx) const { return m_ranges[idx]; }\n+\n private:\n   void canonicalize ();\n   void validate () const;"}, {"sha": "85b7c5e122768026485921a2082bcb3a279b8e6a", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c044ff123ee573b7cd63d88f544091b7aeeb8f6/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c044ff123ee573b7cd63d88f544091b7aeeb8f6/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=2c044ff123ee573b7cd63d88f544091b7aeeb8f6", "patch": "@@ -916,6 +916,32 @@ impl_region_model_context::on_condition (const svalue *lhs,\n     }\n }\n \n+/* Implementation of region_model_context::on_bounded_ranges vfunc.\n+   Notify all state machines about the ranges, which could lead to\n+   state transitions.  */\n+\n+void\n+impl_region_model_context::on_bounded_ranges (const svalue &sval,\n+\t\t\t\t\t      const bounded_ranges &ranges)\n+{\n+  int sm_idx;\n+  sm_state_map *smap;\n+  FOR_EACH_VEC_ELT (m_new_state->m_checker_states, sm_idx, smap)\n+    {\n+      const state_machine &sm = m_ext_state.get_sm (sm_idx);\n+      impl_sm_context sm_ctxt (*m_eg, sm_idx, sm, m_enode_for_diag,\n+\t\t\t       m_old_state, m_new_state,\n+\t\t\t       m_old_state->m_checker_states[sm_idx],\n+\t\t\t       m_new_state->m_checker_states[sm_idx],\n+\t\t\t       m_path_ctxt);\n+      sm.on_bounded_ranges (&sm_ctxt,\n+\t\t\t    (m_enode_for_diag\n+\t\t\t     ? m_enode_for_diag->get_supernode ()\n+\t\t\t     : NULL),\n+\t\t\t    m_stmt, sval, ranges);\n+    }\n+}\n+\n /* Implementation of region_model_context::on_phi vfunc.\n    Notify all state machines about the phi, which could lead to\n    state transitions.  */"}, {"sha": "f9575688fdd92960f4cd60f9735ca291fc674e40", "filename": "gcc/analyzer/exploded-graph.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c044ff123ee573b7cd63d88f544091b7aeeb8f6/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c044ff123ee573b7cd63d88f544091b7aeeb8f6/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=2c044ff123ee573b7cd63d88f544091b7aeeb8f6", "patch": "@@ -65,6 +65,9 @@ class impl_region_model_context : public region_model_context\n \t\t     enum tree_code op,\n \t\t     const svalue *rhs) final override;\n \n+  void on_bounded_ranges (const svalue &sval,\n+\t\t\t  const bounded_ranges &ranges) final override;\n+\n   void on_unknown_change (const svalue *sval, bool is_mutable) final override;\n \n   void on_phi (const gphi *phi, tree rhs) final override;"}, {"sha": "5bb7112a383cddd2f320101bf7f34ba2b59d1bfa", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c044ff123ee573b7cd63d88f544091b7aeeb8f6/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c044ff123ee573b7cd63d88f544091b7aeeb8f6/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=2c044ff123ee573b7cd63d88f544091b7aeeb8f6", "patch": "@@ -4228,6 +4228,8 @@ region_model::apply_constraints_for_gswitch (const switch_cfg_superedge &edge,\n   bool sat = m_constraints->add_bounded_ranges (index_sval, all_cases_ranges);\n   if (!sat && out)\n     *out = new rejected_ranges_constraint (*this, index, all_cases_ranges);\n+  if (sat && ctxt && !all_cases_ranges->empty_p ())\n+    ctxt->on_bounded_ranges (*index_sval, *all_cases_ranges);\n   return sat;\n }\n "}, {"sha": "42f8abeb043a5f5f559502f7d3eed11a10f191c9", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c044ff123ee573b7cd63d88f544091b7aeeb8f6/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c044ff123ee573b7cd63d88f544091b7aeeb8f6/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=2c044ff123ee573b7cd63d88f544091b7aeeb8f6", "patch": "@@ -931,6 +931,13 @@ class region_model_context\n \t\t\t     enum tree_code op,\n \t\t\t     const svalue *rhs) = 0;\n \n+  /* Hook for clients to be notified when the condition that\n+     SVAL is within RANGES is added to the region model.\n+     Similar to on_condition, but for use when handling switch statements.\n+     RANGES is non-empty.  */\n+  virtual void on_bounded_ranges (const svalue &sval,\n+\t\t\t\t  const bounded_ranges &ranges) = 0;\n+\n   /* Hooks for clients to be notified when an unknown change happens\n      to SVAL (in response to a call to an unknown function).  */\n   virtual void on_unknown_change (const svalue *sval, bool is_mutable) = 0;\n@@ -991,6 +998,10 @@ class noop_region_model_context : public region_model_context\n \t\t     const svalue *rhs ATTRIBUTE_UNUSED) override\n   {\n   }\n+  void on_bounded_ranges (const svalue &,\n+\t\t\t  const bounded_ranges &) override\n+  {\n+  }\n   void on_unknown_change (const svalue *sval ATTRIBUTE_UNUSED,\n \t\t\t  bool is_mutable ATTRIBUTE_UNUSED) override\n   {\n@@ -1087,6 +1098,12 @@ class region_model_context_decorator : public region_model_context\n     m_inner->on_condition (lhs, op, rhs);\n   }\n \n+  void on_bounded_ranges (const svalue &sval,\n+\t\t\t  const bounded_ranges &ranges) override\n+  {\n+    m_inner->on_bounded_ranges (sval, ranges);\n+  }\n+\n   void on_unknown_change (const svalue *sval, bool is_mutable) override\n   {\n     m_inner->on_unknown_change (sval, is_mutable);"}, {"sha": "9cb78886c9f57c77e8d5d75aa9ddaf1b603b09a5", "filename": "gcc/analyzer/sm-taint.cc", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c044ff123ee573b7cd63d88f544091b7aeeb8f6/gcc%2Fanalyzer%2Fsm-taint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c044ff123ee573b7cd63d88f544091b7aeeb8f6/gcc%2Fanalyzer%2Fsm-taint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-taint.cc?ref=2c044ff123ee573b7cd63d88f544091b7aeeb8f6", "patch": "@@ -51,6 +51,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/sm.h\"\n #include \"analyzer/program-state.h\"\n #include \"analyzer/pending-diagnostic.h\"\n+#include \"analyzer/constraint-manager.h\"\n \n #if ENABLE_ANALYZER\n \n@@ -97,6 +98,11 @@ class taint_state_machine : public state_machine\n \t\t     const svalue *lhs,\n \t\t     enum tree_code op,\n \t\t     const svalue *rhs) const final override;\n+  void on_bounded_ranges (sm_context *sm_ctxt,\n+\t\t\t  const supernode *node,\n+\t\t\t  const gimple *stmt,\n+\t\t\t  const svalue &sval,\n+\t\t\t  const bounded_ranges &ranges) const final override;\n \n   bool can_purge_p (state_t s) const final override;\n \n@@ -901,6 +907,58 @@ taint_state_machine::on_condition (sm_context *sm_ctxt,\n     }\n }\n \n+/* Implementation of state_machine::on_bounded_ranges vfunc for\n+   taint_state_machine, for handling switch statement cases.\n+   Potentially transition state 'tainted' to 'has_ub' or 'has_lb',\n+   and states 'has_ub' and 'has_lb' to 'stop'.  */\n+\n+void\n+taint_state_machine::on_bounded_ranges (sm_context *sm_ctxt,\n+\t\t\t\t\tconst supernode *,\n+\t\t\t\t\tconst gimple *stmt,\n+\t\t\t\t\tconst svalue &sval,\n+\t\t\t\t\tconst bounded_ranges &ranges) const\n+{\n+  gcc_assert (!ranges.empty_p ());\n+  gcc_assert (ranges.get_count () > 0);\n+\n+  /* We have one or more ranges; this could be a \"default:\", or one or\n+     more single or range cases.\n+\n+     Look at the overall endpoints to see if the ranges impose any lower\n+     bounds or upper bounds beyond those of the underlying numeric type.  */\n+\n+  tree lowest_bound = ranges.get_range (0).m_lower;\n+  tree highest_bound = ranges.get_range (ranges.get_count () - 1).m_upper;\n+  gcc_assert (lowest_bound);\n+  gcc_assert (highest_bound);\n+\n+  bool ranges_have_lb\n+    = (lowest_bound != TYPE_MIN_VALUE (TREE_TYPE (lowest_bound)));\n+  bool ranges_have_ub\n+    = (highest_bound != TYPE_MAX_VALUE (TREE_TYPE (highest_bound)));\n+\n+  if (!ranges_have_lb && !ranges_have_ub)\n+    return;\n+\n+  /* We have new bounds from the ranges; combine them with any\n+     existing bounds on SVAL.  */\n+  state_t old_state = sm_ctxt->get_state (stmt, &sval);\n+  if (old_state == m_tainted)\n+    {\n+      if (ranges_have_lb && ranges_have_ub)\n+\tsm_ctxt->set_next_state (stmt, &sval, m_stop);\n+      else if (ranges_have_lb)\n+\tsm_ctxt->set_next_state (stmt, &sval, m_has_lb);\n+      else if (ranges_have_ub)\n+\tsm_ctxt->set_next_state (stmt, &sval, m_has_ub);\n+    }\n+  else if (old_state == m_has_ub && ranges_have_lb)\n+    sm_ctxt->set_next_state (stmt, &sval, m_stop);\n+  else if (old_state == m_has_lb && ranges_have_ub)\n+    sm_ctxt->set_next_state (stmt, &sval, m_stop);\n+}\n+\n bool\n taint_state_machine::can_purge_p (state_t s ATTRIBUTE_UNUSED) const\n {"}, {"sha": "87ab11cc9620629cbf343b07edf676ce261330c6", "filename": "gcc/analyzer/sm.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c044ff123ee573b7cd63d88f544091b7aeeb8f6/gcc%2Fanalyzer%2Fsm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c044ff123ee573b7cd63d88f544091b7aeeb8f6/gcc%2Fanalyzer%2Fsm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm.h?ref=2c044ff123ee573b7cd63d88f544091b7aeeb8f6", "patch": "@@ -108,6 +108,15 @@ class state_machine : public log_user\n   {\n   }\n \n+  virtual void\n+  on_bounded_ranges (sm_context *sm_ctxt ATTRIBUTE_UNUSED,\n+\t\t     const supernode *node ATTRIBUTE_UNUSED,\n+\t\t     const gimple *stmt ATTRIBUTE_UNUSED,\n+\t\t     const svalue &sval ATTRIBUTE_UNUSED,\n+\t\t     const bounded_ranges &ranges ATTRIBUTE_UNUSED) const\n+  {\n+  }\n+\n   /* Return true if it safe to discard the given state (to help\n      when simplifying state objects).\n      States that need leak detection should return false.  */"}, {"sha": "b3dc177cb14fa7140f699110181347a7031c14a3", "filename": "gcc/testsuite/gcc.dg/analyzer/torture/taint-read-index-2.c", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c044ff123ee573b7cd63d88f544091b7aeeb8f6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Ftaint-read-index-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c044ff123ee573b7cd63d88f544091b7aeeb8f6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Ftaint-read-index-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Ftaint-read-index-2.c?ref=2c044ff123ee573b7cd63d88f544091b7aeeb8f6", "patch": "@@ -54,3 +54,88 @@ test_4 (unsigned uarg)\n {\n   return called_by_test_4 (uarg);\n }\n+\n+int  __attribute__((tainted_args))\n+test_5 (int idx)\n+{\n+  switch (idx)\n+    {\n+    default:\n+      return 0;\n+    case 5 ... 20:\n+      return arr[idx]; /* { dg-bogus \"bounds checking\" } */\n+      /* 20 is still an out-of-bounds error (off-by-one)\n+\t but we don't check for that, just that bounds have been imposed.  */\n+\n+    /* Extra cases to avoid optimizing the switch away.  */\n+    case 22:\n+      return 22;\n+    case 23:\n+      return -17;\n+    }\n+}\n+\n+int  __attribute__((tainted_args))\n+test_6 (int idx)\n+{\n+  switch (idx)\n+    {\n+    default:\n+      return arr[idx]; /* { dg-warning \"without bounds checking\" } */\n+\n+    case 2:\n+      return arr[idx]; /* { dg-bogus \"bounds checking\" } */\n+\n+    case 6 ... 19:\n+      return arr[idx]; /* { dg-bogus \"bounds checking\" } */\n+\n+    case 22:\n+      return 22;\n+    case 23:\n+      return -17;\n+    }\n+}\n+\n+int  __attribute__((tainted_args))\n+test_7 (int idx)\n+{\n+  switch (idx)\n+    {\n+    default:\n+      return arr[idx]; /* { dg-warning \"without bounds checking\" } */\n+\n+    case 2 ... 4:\n+    case 7 ... 9:\n+      return arr[idx]; /* { dg-bogus \"bounds checking\" } */\n+\n+    case 12 ... 19:\n+      return arr[idx]; /* { dg-bogus \"bounds checking\" } */\n+\n+    case 22:\n+      return 22;\n+    case 23:\n+      return -17;\n+    }\n+}\n+\n+int  __attribute__((tainted_args))\n+test_8 (unsigned idx)\n+{\n+  switch (idx)\n+    {\n+    default:\n+      return arr[idx]; /* { dg-warning \"without upper-bounds checking\" } */\n+\n+    case 2 ... 4:\n+    case 7 ... 9:\n+      return arr[idx]; /* { dg-bogus \"bounds checking\" } */\n+\n+    case 12 ... 19:\n+      return arr[idx]; /* { dg-bogus \"bounds checking\" } */\n+\n+    case 22:\n+      return 22;\n+    case 23:\n+      return -17;\n+    }\n+}"}]}