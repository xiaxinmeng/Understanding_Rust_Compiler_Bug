{"sha": "0263463dd114d7ea50230ae6c53e7031615b2ec8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI2MzQ2M2RkMTE0ZDdlYTUwMjMwYWU2YzUzZTcwMzE2MTViMmVjOA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-07-26T12:02:54Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-07-26T12:02:54Z"}, "message": "bitmap.h: Add explanation of sparse set as linked-list bitmap.\n\n\t* bitmap.h: Add explanation of sparse set as linked-list bitmap.\n\t* sbitmap.h: Add explanation about non-sparse sets as simple bitmap.\n\t(TEST_BIT): Make a static inline function for stronger type checking.\n\t(SET_BIT): Don't handle sbitmaps with popcount.\n\t(RESET_BIT): Likewise.\n\t(SET_BIT_WITH_POPCOUNT): New, like SET_BIT but with popcount.\n\t(RESET_BIT_WITH_POPCOUNT): New, like RESET_BIT but with popcount.\n\t* ebitmap.c (ebitmap_clear_bit): Use SET_BIT_WITH_POPCOUNT and\n\tRESET_BIT_WITH_POPCOUNT on wordmask bitmaps.\n\t(ebitmap_set_bit, ebitmap_and_into, ebitmap_and, ebitmap_ior_into,\n\tebitmap_and_compl_into, ebitmap_and_compl): Likewise.\n\t* sparseset.h: Add explanation of sparse set representation.\n\nFrom-SVN: r189888", "tree": {"sha": "b377f47b8511c1d1b93b64e5b37aef519af1940b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b377f47b8511c1d1b93b64e5b37aef519af1940b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0263463dd114d7ea50230ae6c53e7031615b2ec8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0263463dd114d7ea50230ae6c53e7031615b2ec8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0263463dd114d7ea50230ae6c53e7031615b2ec8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0263463dd114d7ea50230ae6c53e7031615b2ec8/comments", "author": null, "committer": null, "parents": [{"sha": "6b4496dbc3afe3f18aaf3fa6792995427194d685", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b4496dbc3afe3f18aaf3fa6792995427194d685", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b4496dbc3afe3f18aaf3fa6792995427194d685"}], "stats": {"total": 368, "additions": 316, "deletions": 52}, "files": [{"sha": "5aba58ea5afd937aa210659234b6b37fd922c101", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0263463dd114d7ea50230ae6c53e7031615b2ec8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0263463dd114d7ea50230ae6c53e7031615b2ec8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0263463dd114d7ea50230ae6c53e7031615b2ec8", "patch": "@@ -1,3 +1,18 @@\n+2012-07-26  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* bitmap.h: Add explanation of sparse set as linked-list bitmap.\n+\t* sbitmap.h: Add explanation about non-sparse sets as simple bitmap.\n+\t(TEST_BIT): Make a static inline function for stronger type checking.\n+\t(SET_BIT): Don't handle sbitmaps with popcount.\n+\t(RESET_BIT): Likewise.\n+\t(SET_BIT_WITH_POPCOUNT): New, like SET_BIT but with popcount.\n+\t(RESET_BIT_WITH_POPCOUNT): New, like RESET_BIT but with popcount.\n+\t* ebitmap.c (ebitmap_clear_bit): Use SET_BIT_WITH_POPCOUNT and\n+\tRESET_BIT_WITH_POPCOUNT on wordmask bitmaps.\n+\t(ebitmap_set_bit, ebitmap_and_into, ebitmap_and, ebitmap_ior_into,\n+\tebitmap_and_compl_into, ebitmap_and_compl): Likewise.\n+\t* sparseset.h: Add explanation of sparse set representation.\n+\n 2012-07-26  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/54098"}, {"sha": "1a28788bc3e5f9a2a9e4d9895a19a445e6b003e8", "filename": "gcc/bitmap.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0263463dd114d7ea50230ae6c53e7031615b2ec8/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0263463dd114d7ea50230ae6c53e7031615b2ec8/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=0263463dd114d7ea50230ae6c53e7031615b2ec8", "patch": "@@ -1,6 +1,5 @@\n /* Functions to support general ended bitmaps.\n-   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,\n-   2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n+   Copyright (C) 1997-2012  Free Software Foundation, Inc.\n \n This file is part of GCC.\n "}, {"sha": "6ca9073750d26a17ae5224391b3ccfe01880e1aa", "filename": "gcc/bitmap.h", "status": "modified", "additions": 115, "deletions": 5, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0263463dd114d7ea50230ae6c53e7031615b2ec8/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0263463dd114d7ea50230ae6c53e7031615b2ec8/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=0263463dd114d7ea50230ae6c53e7031615b2ec8", "patch": "@@ -1,6 +1,5 @@\n /* Functions to support general ended bitmaps.\n-   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,\n-   2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n+   Copyright (C) 1997-2012  Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -20,6 +19,114 @@ along with GCC; see the file COPYING3.  If not see\n \n #ifndef GCC_BITMAP_H\n #define GCC_BITMAP_H\n+\n+/* Implementation of sparse integer sets as a linked list.\n+\n+   This sparse set representation is suitable for sparse sets with an\n+   unknown (a priori) universe.  The set is represented as a double-linked\n+   list of container nodes (struct bitmap_element_def).  Each node consists\n+   of an index for the first member that could be held in the container,\n+   a small array of integers that represent the members in the container,\n+   and pointers to the next and previous element in the linked list.  The\n+   elements in the list are sorted in ascending order, i.e. the head of\n+   the list holds the element with the smallest member of the set.\n+\n+   For a given member I in the set:\n+     - the element for I will have index is I / (bits per element)\n+     - the position for I within element is I % (bits per element)\n+\n+   This representation is very space-efficient for large sparse sets, and\n+   the size of the set can be changed dynamically without much overhead.\n+   An important parameter is the number of bits per element.  In this\n+   implementation, there are 128 bits per element.  This results in a\n+   high storage overhead *per element*, but a small overall overhead if\n+   the set is very sparse.\n+\n+   The downside is that many operations are relatively slow because the\n+   linked list has to be traversed to test membership (i.e. member_p/\n+   add_member/remove_member).  To improve the performance of this set\n+   representation, the last accessed element and its index are cached.\n+   For membership tests on members close to recently accessed members,\n+   the cached last element improves membership test to a constant-time\n+   operation.\n+\n+   The following operations can always be performed in O(1) time:\n+\n+     * clear\t\t\t: bitmap_clear\n+     * choose_one\t\t: (not implemented, but could be\n+\t\t\t\t   implemented in constant time)\n+\n+   The following operations can be performed in O(E) time worst-case (with\n+   E the number of elements in the linked list), but in O(1) time with a\n+   suitable access patterns:\n+\n+     * member_p\t\t\t: bitmap_bit_p\n+     * add_member\t\t: bitmap_set_bit\n+     * remove_member\t\t: bitmap_clear_bit\n+\n+   The following operations can be performed in O(E) time:\n+\n+     * cardinality\t\t: bitmap_count_bits\n+     * set_size\t\t\t: bitmap_last_set_bit (but this could\n+\t\t\t\t  in constant time with a pointer to\n+\t\t\t\t  the last element in the chain)\n+\n+   Additionally, the linked-list sparse set representation supports\n+   enumeration of the members in O(E) time:\n+\n+     * forall\t\t\t: EXECUTE_IF_SET_IN_BITMAP\n+     * set_copy\t\t\t: bitmap_copy\n+     * set_intersection\t\t: bitmap_intersect_p /\n+\t\t\t\t  bitmap_and / bitmap_and_into /\n+\t\t\t\t  EXECUTE_IF_AND_IN_BITMAP\n+     * set_union\t\t: bitmap_ior / bitmap_ior_into\n+     * set_difference\t\t: bitmap_intersect_compl_p /\n+\t\t\t\t  bitmap_and_comp / bitmap_and_comp_into /\n+\t\t\t\t  EXECUTE_IF_AND_COMPL_IN_BITMAP\n+     * set_disjuction\t\t: bitmap_xor_comp / bitmap_xor_comp_into\n+     * set_compare\t\t: bitmap_equal_p\n+\n+   Some operations on 3 sets that occur frequently in in data flow problems\n+   are also implemented:\n+\n+     * A | (B & C)\t\t: bitmap_ior_and_into\n+     * A | (B & ~C)\t\t: bitmap_ior_and_compl /\n+\t\t\t\t  bitmap_ior_and_compl_into\n+\n+   The storage requirements for linked-list sparse sets are O(E), with E->N\n+   in the worst case (a sparse set with large distances between the values\n+   of the set members).\n+\n+   The linked-list set representation works well for problems involving very\n+   sparse sets.  The canonical example in GCC is, of course, the \"set of\n+   sets\" for some CFG-based data flow problems (liveness analysis, dominance\n+   frontiers, etc.).\n+   \n+   This representation also works well for data flow problems where the size\n+   of the set may grow dynamically, but care must be taken that the member_p,\n+   add_member, and remove_member operations occur with a suitable access\n+   pattern.\n+   \n+   For random-access sets with a known, relatively small universe size, the\n+   SparseSet or simple bitmap representations may be more efficient than a\n+   linked-list set.  For random-access sets of unknown universe, a hash table\n+   or a balanced binary tree representation is likely to be a more suitable\n+   choice.\n+\n+   Traversing linked lists is usually cache-unfriendly, even with the last\n+   accessed element cached.\n+   \n+   Cache performance can be improved by keeping the elements in the set\n+   grouped together in memory, using a dedicated obstack for a set (or group\n+   of related sets).  Elements allocated on obstacks are released to a\n+   free-list and taken off the free list.  If multiple sets are allocated on\n+   the same obstack, elements freed from one set may be re-used for one of\n+   the other sets.  This usually helps avoid cache misses.\n+\n+   A single free-list is used for all sets allocated in GGC space.  This is\n+   bad for persistent sets, so persistent sets should be allocated on an\n+   obstack whenever possible.  */\n+\n #include \"hashtab.h\"\n #include \"statistics.h\"\n #include \"obstack.h\"\n@@ -130,9 +237,11 @@ extern void bitmap_xor_into (bitmap, const_bitmap);\n /* DST = A | (B & C).  Return true if DST changes.  */\n extern bool bitmap_ior_and_into (bitmap DST, const_bitmap B, const_bitmap C);\n /* DST = A | (B & ~C).  Return true if DST changes.  */\n-extern bool bitmap_ior_and_compl (bitmap DST, const_bitmap A, const_bitmap B, const_bitmap C);\n+extern bool bitmap_ior_and_compl (bitmap DST, const_bitmap A,\n+\t\t\t\t  const_bitmap B, const_bitmap C);\n /* A |= (B & ~C).  Return true if A changes.  */\n-extern bool bitmap_ior_and_compl_into (bitmap DST, const_bitmap B, const_bitmap C);\n+extern bool bitmap_ior_and_compl_into (bitmap A,\n+\t\t\t\t       const_bitmap B, const_bitmap C);\n \n /* Clear a single bit in a bitmap.  Return true if the bit changed.  */\n extern bool bitmap_clear_bit (bitmap, int);\n@@ -328,7 +437,8 @@ bmp_iter_and_init (bitmap_iterator *bi, const_bitmap map1, const_bitmap map2,\n    */\n \n static inline void\n-bmp_iter_and_compl_init (bitmap_iterator *bi, const_bitmap map1, const_bitmap map2,\n+bmp_iter_and_compl_init (bitmap_iterator *bi,\n+\t\t\t const_bitmap map1, const_bitmap map2,\n \t\t\t unsigned start_bit, unsigned *bit_no)\n {\n   bi->elt1 = map1->first;"}, {"sha": "977d4ef0f6d6cfa1714a44ceee6fa2f4ce12dc02", "filename": "gcc/ebitmap.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0263463dd114d7ea50230ae6c53e7031615b2ec8/gcc%2Febitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0263463dd114d7ea50230ae6c53e7031615b2ec8/gcc%2Febitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Febitmap.c?ref=0263463dd114d7ea50230ae6c53e7031615b2ec8", "patch": "@@ -1,5 +1,5 @@\n /* Sparse array-based bitmaps.\n-   Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n+   Copyright (C) 2007-2012  Free Software Foundation, Inc.\n    Contributed by Daniel Berlin <dberlin@dberlin.org>\n \n This file is part of GCC.\n@@ -258,7 +258,7 @@ ebitmap_clear_bit (ebitmap map, unsigned int bit)\n             map->cache = map->cache - 1;\n         }\n \n-      RESET_BIT (map->wordmask, wordindex);\n+      RESET_BIT_WITH_POPCOUNT (map->wordmask, wordindex);\n \n       memmove(&map->elts[eltwordindex], &map->elts[eltwordindex + 1],\n \t      sizeof (EBITMAP_ELT_TYPE) * (map->numwords - eltwordindex));\n@@ -293,7 +293,7 @@ ebitmap_set_bit (ebitmap map, unsigned int bit)\n       unsigned long count;\n       unsigned int i;\n \n-      SET_BIT (map->wordmask, wordindex);\n+      SET_BIT_WITH_POPCOUNT (map->wordmask, wordindex);\n       count = sbitmap_popcount (map->wordmask, wordindex);\n       gcc_assert (count <= map->numwords);\n \n@@ -449,7 +449,7 @@ ebitmap_and_into (ebitmap dst, ebitmap src)\n \t  *dstplace = tmpword;\n \t}\n       else\n-\tRESET_BIT (dst->wordmask, i);\n+\tRESET_BIT_WITH_POPCOUNT (dst->wordmask, i);\n     }\n #ifdef EBITMAP_DEBUGGING\n   {\n@@ -508,7 +508,7 @@ ebitmap_and (ebitmap dst, ebitmap src1, ebitmap src2)\n \t      *dstplace = tmpword;\n \t    }\n \t  else\n-\t    RESET_BIT (dst->wordmask, i);\n+\t    RESET_BIT_WITH_POPCOUNT (dst->wordmask, i);\n \t}\n       else if (src1hasword)\n \tsrc1eltindex++;\n@@ -624,7 +624,7 @@ ebitmap_ior_into (ebitmap dst, ebitmap src)\n \t{\n \t  newarray [neweltindex++] = ebitmap_array_get (src, srceltindex++);\n \t  gcc_assert (i < dst->wordmask->n_bits);\n-\t  SET_BIT (dst->wordmask, i);\n+\t  SET_BIT_WITH_POPCOUNT (dst->wordmask, i);\n \t  changed |= true;\n \t}\n     }\n@@ -825,7 +825,7 @@ ebitmap_and_compl_into (ebitmap dst, ebitmap src)\n \t      *dstplace = tmpword;\n \t    }\n \t  else\n-\t    RESET_BIT (dst->wordmask, i);\n+\t    RESET_BIT_WITH_POPCOUNT (dst->wordmask, i);\n \t}\n       else\n \t{\n@@ -904,7 +904,7 @@ ebitmap_and_compl (ebitmap dst, ebitmap src1, ebitmap src2)\n \t      newarray[neweltindex++] = tmpword;\n \t    }\n \t  else\n-\t    RESET_BIT (tempmask, i);\n+\t    RESET_BIT_WITH_POPCOUNT (tempmask, i);\n \n \t}\n       else"}, {"sha": "6aac459f8267253f0d13a3493c5ddb3e9429b352", "filename": "gcc/sbitmap.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0263463dd114d7ea50230ae6c53e7031615b2ec8/gcc%2Fsbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0263463dd114d7ea50230ae6c53e7031615b2ec8/gcc%2Fsbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.c?ref=0263463dd114d7ea50230ae6c53e7031615b2ec8", "patch": "@@ -1,6 +1,5 @@\n /* Simple bitmaps.\n-   Copyright (C) 1999, 2000, 2002, 2003, 2004, 2006, 2007, 2008, 2010\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1999-2012  Free Software Foundation, Inc.\n \n This file is part of GCC.\n "}, {"sha": "84aeb8718bc4d4a0582def3477a0428b879316ee", "filename": "gcc/sbitmap.h", "status": "modified", "additions": 112, "deletions": 31, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0263463dd114d7ea50230ae6c53e7031615b2ec8/gcc%2Fsbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0263463dd114d7ea50230ae6c53e7031615b2ec8/gcc%2Fsbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.h?ref=0263463dd114d7ea50230ae6c53e7031615b2ec8", "patch": "@@ -1,6 +1,5 @@\n /* Simple bitmaps.\n-   Copyright (C) 1999, 2000, 2002, 2003, 2004, 2006, 2007, 2008, 2010\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1999-2012  Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -21,9 +20,65 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_SBITMAP_H\n #define GCC_SBITMAP_H\n \n-/* It's not clear yet whether using bitmap.[ch] will be a win.\n-   It should be straightforward to convert so for now we keep things simple\n-   while more important issues are dealt with.  */\n+/* Implementation of sets using simple bitmap vectors.\n+\n+   This set representation is suitable for non-sparse sets with a known\n+   (a priori) universe.  The set is represented as a simple array of the\n+   host's fastest unsigned integer.  For a given member I in the set:\n+     - the element for I will be at sbitmap[I / (bits per element)]\n+     - the position for I within element is I % (bits per element)\n+\n+   This representation is very space-efficient for large non-sparse sets\n+   with random access patterns.\n+\n+   The following operations can be performed in O(1) time:\n+\n+     * set_size\t\t\t: SBITMAP_SIZE\n+     * member_p\t\t\t: TEST_BIT\n+     * add_member\t\t: SET_BIT\n+     * remove_member\t\t: RESET_BIT\n+\n+   Most other operations on this set representation are O(U) where U is\n+   the size of the set universe:\n+\n+     * clear\t\t\t: sbitmap_zero\n+     * cardinality\t\t: sbitmap_popcount\n+     * choose_one\t\t: sbitmap_first_set_bit /\n+\t\t\t\t  sbitmap_last_set_bit\n+     * forall\t\t\t: EXECUTE_IF_SET_IN_SBITMAP\n+     * set_copy\t\t\t: sbitmap_copy / sbitmap_copy_n\n+     * set_intersection\t\t: sbitmap_a_and_b\n+     * set_union\t\t: sbitmap_a_or_b\n+     * set_difference\t\t: sbitmap_difference\n+     * set_disjuction\t\t: (not implemented)\n+     * set_compare\t\t: sbitmap_equal\n+\n+   Some operations on 3 sets that occur frequently in in data flow problems\n+   are also implemented:\n+\n+      * A | (B & C)\t\t: sbitmap_a_or_b_and_c\n+      * A | (B & ~C)\t\t: sbitmap_union_of_diff\n+      * A & (B | C)\t\t: sbitmap_a_and_b_or_c\n+\n+   Most of the set functions have two variants: One that returns non-zero\n+   if members were added or removed from the target set, and one that just\n+   performs the operation without feedback.  The former operations are a\n+   bit more expensive but the result can often be used to avoid iterations\n+   on other sets.\n+\n+   Allocating a bitmap is done with sbitmap_alloc, and resizing is\n+   performed with sbitmap_resize.\n+\n+   The storage requirements for simple bitmap sets is O(U) where U is the\n+   size of the set universe (colloquially the number of bits in the bitmap).\n+\n+   This set representation works well for relatively small data flow problems\n+   (there are special routines for that, see sbitmap_vector_*).  The set\n+   operations can be vectorized and there is almost no computating overhead,\n+   so that even sparse simple bitmap sets outperform dedicated sparse set\n+   representations like linked-list bitmaps.  For larger problems, the size\n+   overhead of simple bitmap sets gets too high and other set representations\n+   have to be used.  */\n \n #define SBITMAP_ELT_BITS (HOST_BITS_PER_WIDEST_FAST_INT * 1u)\n #define SBITMAP_ELT_TYPE unsigned HOST_WIDEST_FAST_INT\n@@ -40,42 +95,62 @@ struct simple_bitmap_def\n #define SBITMAP_SET_SIZE(N) (((N) + SBITMAP_ELT_BITS - 1) / SBITMAP_ELT_BITS)\n #define SBITMAP_SIZE_BYTES(BITMAP) ((BITMAP)->size * sizeof (SBITMAP_ELT_TYPE))\n \n+/* Return the number of bits in BITMAP.  */\n+#define SBITMAP_SIZE(BITMAP) ((BITMAP)->n_bits)\n+\n /* Test if bit number bitno in the bitmap is set.  */\n-#define TEST_BIT(BITMAP, BITNO) \\\n-((BITMAP)->elms [(BITNO) / SBITMAP_ELT_BITS] >> (BITNO) % SBITMAP_ELT_BITS & 1)\n+static inline SBITMAP_ELT_TYPE\n+TEST_BIT (const_sbitmap map, unsigned int bitno)\n+{\n+  size_t i = bitno / SBITMAP_ELT_BITS;\n+  unsigned int s = bitno % SBITMAP_ELT_BITS;\n+  return (map->elms[i] >> s) & (SBITMAP_ELT_TYPE) 1;\n+}\n \n-/* Set bit number BITNO in the sbitmap MAP.  Updates population count\n-   if this bitmap has one.  */\n+/* Set bit number BITNO in the sbitmap MAP.  */\n \n static inline void\n SET_BIT (sbitmap map, unsigned int bitno)\n {\n-  if (map->popcount)\n-    {\n-      bool oldbit;\n-      oldbit = TEST_BIT (map, bitno);\n-      if (!oldbit)\n-\tmap->popcount[bitno / SBITMAP_ELT_BITS]++;\n-    }\n+  gcc_checking_assert (! map->popcount);\n   map->elms[bitno / SBITMAP_ELT_BITS]\n     |= (SBITMAP_ELT_TYPE) 1 << (bitno) % SBITMAP_ELT_BITS;\n }\n \n+/* Like SET_BIT, but updates population count.  */\n \n+static inline void\n+SET_BIT_WITH_POPCOUNT (sbitmap map, unsigned int bitno)\n+{\n+  bool oldbit;\n+  gcc_checking_assert (map->popcount);\n+  oldbit = TEST_BIT (map, bitno);\n+  if (!oldbit)\n+    map->popcount[bitno / SBITMAP_ELT_BITS]++;\n+  map->elms[bitno / SBITMAP_ELT_BITS]\n+    |= (SBITMAP_ELT_TYPE) 1 << (bitno) % SBITMAP_ELT_BITS;\n+}\n \n-/* Reset bit number BITNO in the sbitmap MAP.  Updates population\n-   count if this bitmap has one.  */\n+/* Reset bit number BITNO in the sbitmap MAP.  */\n \n static inline void\n RESET_BIT (sbitmap map,  unsigned int bitno)\n {\n-  if (map->popcount)\n-    {\n-      bool oldbit;\n-      oldbit = TEST_BIT (map, bitno);\n-      if (oldbit)\n-\tmap->popcount[bitno / SBITMAP_ELT_BITS]--;\n-    }\n+  gcc_checking_assert (! map->popcount);\n+  map->elms[bitno / SBITMAP_ELT_BITS]\n+    &= ~((SBITMAP_ELT_TYPE) 1 << (bitno) % SBITMAP_ELT_BITS);\n+}\n+\n+/* Like RESET_BIT, but updates population count.  */\n+\n+static inline void\n+RESET_BIT_WITH_POPCOUNT (sbitmap map,  unsigned int bitno)\n+{\n+  bool oldbit;\n+  gcc_checking_assert (map->popcount);\n+  oldbit = TEST_BIT (map, bitno);\n+  if (oldbit)\n+    map->popcount[bitno / SBITMAP_ELT_BITS]--;\n   map->elms[bitno / SBITMAP_ELT_BITS]\n     &= ~((SBITMAP_ELT_TYPE) 1 << (bitno) % SBITMAP_ELT_BITS);\n }\n@@ -211,14 +286,20 @@ extern void sbitmap_ones (sbitmap);\n extern void sbitmap_vector_zero (sbitmap *, unsigned int);\n extern void sbitmap_vector_ones (sbitmap *, unsigned int);\n \n-extern void sbitmap_union_of_diff (sbitmap, const_sbitmap, const_sbitmap, const_sbitmap);\n-extern bool sbitmap_union_of_diff_cg (sbitmap, const_sbitmap, const_sbitmap, const_sbitmap);\n+extern void sbitmap_union_of_diff (sbitmap, const_sbitmap,\n+\t\t\t\t   const_sbitmap, const_sbitmap);\n+extern bool sbitmap_union_of_diff_cg (sbitmap, const_sbitmap,\n+\t\t\t\t      const_sbitmap, const_sbitmap);\n extern void sbitmap_difference (sbitmap, const_sbitmap, const_sbitmap);\n extern void sbitmap_not (sbitmap, const_sbitmap);\n-extern void sbitmap_a_or_b_and_c (sbitmap, const_sbitmap, const_sbitmap, const_sbitmap);\n-extern bool sbitmap_a_or_b_and_c_cg (sbitmap, const_sbitmap, const_sbitmap, const_sbitmap);\n-extern void sbitmap_a_and_b_or_c (sbitmap, const_sbitmap, const_sbitmap, const_sbitmap);\n-extern bool sbitmap_a_and_b_or_c_cg (sbitmap, const_sbitmap, const_sbitmap, const_sbitmap);\n+extern void sbitmap_a_or_b_and_c (sbitmap, const_sbitmap,\n+\t\t\t\t  const_sbitmap, const_sbitmap);\n+extern bool sbitmap_a_or_b_and_c_cg (sbitmap, const_sbitmap,\n+\t\t\t\t     const_sbitmap, const_sbitmap);\n+extern void sbitmap_a_and_b_or_c (sbitmap, const_sbitmap,\n+\t\t\t\t  const_sbitmap, const_sbitmap);\n+extern bool sbitmap_a_and_b_or_c_cg (sbitmap, const_sbitmap,\n+\t\t\t\t     const_sbitmap, const_sbitmap);\n extern bool sbitmap_any_common_bits (const_sbitmap, const_sbitmap);\n extern void sbitmap_a_and_b (sbitmap, const_sbitmap, const_sbitmap);\n extern bool sbitmap_a_and_b_cg (sbitmap, const_sbitmap, const_sbitmap);"}, {"sha": "b215c55e9f3b4702915f3e0a96b797e79066c815", "filename": "gcc/sparseset.h", "status": "modified", "additions": 64, "deletions": 4, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0263463dd114d7ea50230ae6c53e7031615b2ec8/gcc%2Fsparseset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0263463dd114d7ea50230ae6c53e7031615b2ec8/gcc%2Fsparseset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsparseset.h?ref=0263463dd114d7ea50230ae6c53e7031615b2ec8", "patch": "@@ -1,5 +1,5 @@\n /* SparseSet implementation.\n-   Copyright (C) 2007, 2010 Free Software Foundation, Inc.\n+   Copyright (C) 2007-2012 Free Software Foundation, Inc.\n    Contributed by Peter Bergner <bergner@vnet.ibm.com>\n \n This file is part of GCC.\n@@ -21,11 +21,71 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_SPARSESET_H\n #define GCC_SPARSESET_H\n \n-#define SPARSESET_ELT_BITS ((unsigned) HOST_BITS_PER_WIDEST_FAST_INT)\n-#define SPARSESET_ELT_TYPE unsigned int\n+/* Implementation of the Briggs and Torczon sparse set representation.\n+   The sparse set representation was first published in:\n+\n+   \"An Efficient Representation for Sparse Sets\",\n+   ACM LOPLAS, Vol. 2, Nos. 1-4, March-December 1993, Pages 59-69.\n+\n+   The sparse set representation is suitable for integer sets with a\n+   fixed-size universe.  Two vectors are used to store the members of\n+   the set.  If an element I is in the set, then sparse[I] is the\n+   index of I in the dense vector, and dense[sparse[I]] == I.  The dense\n+   vector works like a stack.  The size of the stack is the cardinality\n+   of the set.\n+\n+   The following operations can be performed in O(1) time:\n+\n+     * clear\t\t\t: sparseset_clear\n+     * cardinality\t\t: sparseset_cardinality\n+     * set_size\t\t\t: sparseset_size\n+     * member_p\t\t\t: sparseset_bit_p\n+     * add_member\t\t: sparseset_set_bit\n+     * remove_member\t\t: sparseset_clear_bit\n+     * choose_one\t\t: sparseset_pop\n+\n+   Additionally, the sparse set representation supports enumeration of\n+   the members in O(N) time, where n is the number of members in the set.\n+   The members of the set are stored cache-friendly in the dense vector.\n+   This makes it a competitive choice for iterating over relatively sparse\n+   sets requiring operations:\n+\n+     * forall\t\t\t: EXECUTE_IF_SET_IN_SPARSESET\n+     * set_copy\t\t\t: sparseset_copy\n+     * set_intersection\t\t: sparseset_and\n+     * set_union\t\t: sparseset_ior\n+     * set_difference\t\t: sparseset_and_compl\n+     * set_disjuction\t\t: (not implemented)\n+     * set_compare\t\t: sparseset_equal_p\n+\n+   NB: It is OK to use remove_member during EXECUTE_IF_SET_IN_SPARSESET.\n+   The iterator is updated for it.\n+\n+   Based on the efficiency of these operations, this representation of\n+   sparse sets will often be superior to alternatives such as simple\n+   bitmaps, linked-list bitmaps, array bitmaps, balanced binary trees,\n+   hash tables, linked lists, etc., if the set is sufficiently sparse.\n+   In the LOPLAS paper the cut-off point where sparse sets became faster\n+   than simple bitmaps (see sbitmap.h) when N / U < 64 (where U is the\n+   size of the universe of the set).\n+\n+   Because the set universe is fixed, the set cannot be resized.  For\n+   sparse sets with initially unknown size, linked-list bitmaps are a\n+   better choice, see bitmap.h.\n+\n+   Sparse sets storage requirements are relatively large: O(U) with a\n+   larger constant than sbitmaps (if the storage requirement for an\n+   sbitmap with universe U is S, then the storage required for a sparse\n+   set for the same universe are 2*HOST_BITS_PER_WIDEST_FAST_INT * S).\n+   Accessing the sparse vector is not very cache-friendly, but iterating\n+   over the members in the set is cache-friendly because only the dense\n+   vector is used.  */\n \n /* Data Structure used for the SparseSet representation.  */\n \n+#define SPARSESET_ELT_BITS ((unsigned) HOST_BITS_PER_WIDEST_FAST_INT)\n+#define SPARSESET_ELT_TYPE unsigned HOST_WIDEST_FAST_INT\n+\n typedef struct sparseset_def\n {\n   SPARSESET_ELT_TYPE *dense;\t/* Dense array.  */\n@@ -107,7 +167,7 @@ sparseset_set_bit (sparseset s, SPARSESET_ELT_TYPE e)\n     sparseset_insert_bit (s, e, s->members++);\n }\n \n-/* Return and remove an arbitrary element from the set S.  */\n+/* Return and remove the last member added to the set S.  */\n \n static inline SPARSESET_ELT_TYPE\n sparseset_pop (sparseset s)"}]}