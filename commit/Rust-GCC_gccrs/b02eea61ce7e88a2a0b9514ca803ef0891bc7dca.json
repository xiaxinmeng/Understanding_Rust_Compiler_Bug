{"sha": "b02eea61ce7e88a2a0b9514ca803ef0891bc7dca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjAyZWVhNjFjZTdlODhhMmEwYjk1MTRjYTgwM2VmMDg5MWJjN2RjYQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-07-23T07:03:34Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-07-23T07:03:34Z"}, "message": "flow.c: Grammar check and clarify a lot of comments.\n\n        * flow.c: Grammar check and clarify a lot of comments.\n        (try_simplify_condjump): Rename variables to be clearer.\n        (try_forward_edges): Skip complex and fallthru edges.\n        Rearrange tests to avoid duplicate checks.\n        (flow_find_cross_jump): Likewise.\n        (outgoing_edges_match): Allow match if neither branch has\n        probability data.  Loosen probability match to 5%.\n        (try_crossjump_to_edge): Hoist repeated indirection into\n        local variables.\n        (try_crossjump_bb): Don't check complex edges.  Eliminate\n        redundant crossjump tests.\n        (try_optimize_cfg): Fix use of bool.  Reorganize cheaper\n        checks before more expensive checks.\n\nFrom-SVN: r44257", "tree": {"sha": "4977b6a5665b9f3dac2bd49cb2545277431ab1e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4977b6a5665b9f3dac2bd49cb2545277431ab1e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b02eea61ce7e88a2a0b9514ca803ef0891bc7dca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b02eea61ce7e88a2a0b9514ca803ef0891bc7dca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b02eea61ce7e88a2a0b9514ca803ef0891bc7dca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b02eea61ce7e88a2a0b9514ca803ef0891bc7dca/comments", "author": null, "committer": null, "parents": [{"sha": "18fee3ee7300568c6f19932d39e1ee9b6908860a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18fee3ee7300568c6f19932d39e1ee9b6908860a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18fee3ee7300568c6f19932d39e1ee9b6908860a"}], "stats": {"total": 712, "additions": 422, "deletions": 290}, "files": [{"sha": "e361bd5aaf70f36e025931982dd27cbbe59865ec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b02eea61ce7e88a2a0b9514ca803ef0891bc7dca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b02eea61ce7e88a2a0b9514ca803ef0891bc7dca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b02eea61ce7e88a2a0b9514ca803ef0891bc7dca", "patch": "@@ -1,3 +1,19 @@\n+2001-07-22  Richard Henderson  <rth@redhat.com>\n+\n+\t* flow.c: Grammar check and clarify a lot of comments.\n+\t(try_simplify_condjump): Rename variables to be clearer.\n+\t(try_forward_edges): Skip complex and fallthru edges.\n+\tRearrange tests to avoid duplicate checks.\n+\t(flow_find_cross_jump): Likewise.\n+\t(outgoing_edges_match): Allow match if neither branch has\n+\tprobability data.  Loosen probability match to 5%.\n+\t(try_crossjump_to_edge): Hoist repeated indirection into \n+\tlocal variables.\n+\t(try_crossjump_bb): Don't check complex edges.  Eliminate\n+\tredundant crossjump tests.\n+\t(try_optimize_cfg): Fix use of bool.  Reorganize cheaper\n+\tchecks before more expensive checks.\n+\n 2001-07-22  Richard Henderson  <rth@redhat.com>\n \n \t* fold-const.c (fold): Test vs FLOAT_TYPE_P instead of"}, {"sha": "8d795a79358e31b74d8b4ec5bde2f46755b7ef60", "filename": "gcc/flow.c", "status": "modified", "additions": 406, "deletions": 290, "changes": 696, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b02eea61ce7e88a2a0b9514ca803ef0891bc7dca/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b02eea61ce7e88a2a0b9514ca803ef0891bc7dca/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=b02eea61ce7e88a2a0b9514ca803ef0891bc7dca", "patch": "@@ -2963,27 +2963,16 @@ merge_blocks (e, b, c, mode)\n       int c_has_outgoing_fallthru;\n       int b_has_incoming_fallthru;\n \n-      /* Avoid overactive code motion, as the forwarder blocks should eb\n-         eliminated by the edge redirection instead. Only exception is the\n-\t case b is an forwarder block and c has no fallthru edge, but no\n-\t optimizers should be confused by this extra jump and we are about\n-\t to kill the jump in bb_reorder pass instead.  */\n+      /* Avoid overactive code motion, as the forwarder blocks should be\n+         eliminated by edge redirection instead.  One exception might have\n+\t been if B is a forwarder block and C has no fallthru edge, but\n+\t that should be cleaned up by bb-reorder instead.  */\n       if (forwarder_block_p (b) || forwarder_block_p (c))\n \treturn 0;\n \n-      /* We must make sure to not munge nesting of exception regions,\n-\t lexical blocks, and loop notes.\n-\n-\t The first is taken care of by requiring that the active eh\n-\t region at the end of one block always matches the active eh\n-\t region at the beginning of the next block.\n-\n-\t The later two are taken care of by squeezing out all the notes.  */\n-\n-      /* ???  A throw/catch edge (or any abnormal edge) should be rarely\n-\t executed and we may want to treat blocks which have two out\n-\t edges, one normal, one abnormal as only having one edge for\n-\t block merging purposes.  */\n+      /* We must make sure to not munge nesting of lexical blocks,\n+\t and loop notes.  This is done by squeezing out all the notes\n+\t and leaving them there to lie.  Not ideal, but functional.  */\n \n       for (tmp_edge = c->succ; tmp_edge; tmp_edge = tmp_edge->succ_next)\n \tif (tmp_edge->flags & EDGE_FALLTHRU)\n@@ -3029,8 +3018,8 @@ merge_blocks (e, b, c, mode)\n \t  redirect_edge_succ (c_fallthru_edge, ENTRY_BLOCK_PTR);\n \t  new = redirect_edge_and_branch_force (c_fallthru_edge, target);\n \n-\t  /* We've just created barrier, but other barrier is already present\n-\t     in the stream.  Avoid duplicate.  */\n+\t  /* We've just created barrier, but another barrier is\n+\t     already present in the stream.  Avoid the duplicate.  */\n \t  barrier = next_nonnote_insn (new ? new->end : b->end);\n \t  if (GET_CODE (barrier) != BARRIER)\n \t    abort ();\n@@ -3042,76 +3031,97 @@ merge_blocks (e, b, c, mode)\n   return 0;\n }\n \n-/* Simplify conditional jump around an jump.  \n-   Return nonzero in case optimization matched.  */\n+/* Simplify a conditional jump around an unconditional jump.\n+   Return true if something changed.  */\n \n static bool\n-try_simplify_condjump (src)\n-     basic_block src;\n+try_simplify_condjump (cbranch_block)\n+     basic_block cbranch_block;\n {\n-  basic_block final_block, next_block;\n-  rtx insn = src->end;\n-  edge branch, fallthru;\n+  basic_block jump_block, jump_dest_block, cbranch_dest_block;\n+  edge cbranch_jump_edge, cbranch_fallthru_edge;\n+  rtx cbranch_insn;\n \n   /* Verify that there are exactly two successors.  */\n-  if (!src->succ || !src->succ->succ_next || src->succ->succ_next->succ_next\n-      || !any_condjump_p (insn))\n+  if (!cbranch_block->succ\n+      || !cbranch_block->succ->succ_next\n+      || cbranch_block->succ->succ_next->succ_next)\n     return false;\n \n-  fallthru = FALLTHRU_EDGE (src);\n-\n-  /* Following block must be simple forwarder block with single\n-     entry and must not be last in the stream.  */\n-  next_block = fallthru->dest;\n-  if (!forwarder_block_p (next_block)\n-      || next_block->pred->pred_next\n-      || next_block->index == n_basic_blocks - 1)\n+  /* Verify that we've got a normal conditional branch at the end\n+     of the block.  */\n+  cbranch_insn = cbranch_block->end;\n+  if (!any_condjump_p (cbranch_insn))\n     return false;\n \n-  /* The branch must target to block afterwards.  */\n-  final_block = BASIC_BLOCK (next_block->index + 1);\n+  cbranch_fallthru_edge = FALLTHRU_EDGE (cbranch_block);\n+  cbranch_jump_edge = BRANCH_EDGE (cbranch_block);\n \n-  branch = BRANCH_EDGE (src);\n+  /* The next block must not have multiple predecessors, must not\n+     be the last block in the function, and must contain just the\n+     unconditional jump.  */\n+  jump_block = cbranch_fallthru_edge->dest;\n+  if (jump_block->pred->pred_next\n+      || jump_block->index == n_basic_blocks - 1\n+      || !forwarder_block_p (jump_block))\n+    return false;\n+  jump_dest_block = jump_block->succ->dest;\n \n-  if (branch->dest != final_block)\n+  /* The conditional branch must target the block after the\n+     unconditional branch.  */\n+  cbranch_dest_block = cbranch_jump_edge->dest;\n+  if (cbranch_dest_block->index != jump_block->index + 1)\n     return false;\n \n-  /* Avoid jump.c from being overactive on removin ureachable insns.  */\n-  LABEL_NUSES (JUMP_LABEL (insn))++;\n-  if (!invert_jump (insn, block_label (next_block->succ->dest), 1))\n+  /* Invert the conditional branch.  Prevent jump.c from deleting\n+     \"unreachable\" instructions.  */\n+  LABEL_NUSES (JUMP_LABEL (cbranch_insn))++;\n+  if (!invert_jump (cbranch_insn, block_label (jump_dest_block), 1))\n     {\n-      LABEL_NUSES (JUMP_LABEL (insn))--;\n+      LABEL_NUSES (JUMP_LABEL (cbranch_insn))--;\n       return false;\n     }\n+\n   if (rtl_dump_file)\n     fprintf (rtl_dump_file, \"Simplifying condjump %i around jump %i\\n\",\n-\t     INSN_UID (insn), INSN_UID (next_block->end));\n+\t     INSN_UID (cbranch_insn), INSN_UID (jump_block->end));\n \n-  redirect_edge_succ (branch, final_block);\n-  redirect_edge_succ (fallthru, next_block->succ->dest);\n-\n-  branch->flags |= EDGE_FALLTHRU;\n-  fallthru->flags &= ~EDGE_FALLTHRU;\n+  /* Success.  Update the CFG to match.  */\n+  redirect_edge_succ (cbranch_jump_edge, cbranch_dest_block);\n+  redirect_edge_succ (cbranch_fallthru_edge, jump_dest_block);\n+  cbranch_jump_edge->flags |= EDGE_FALLTHRU;\n+  cbranch_fallthru_edge->flags &= ~EDGE_FALLTHRU;\n   \n-  flow_delete_block (next_block);\n+  flow_delete_block (jump_block);\n   return true;\n }\n \n /* Attempt to forward edges leaving basic block B.\n-   Return nonzero if sucessfull.  */\n+   Return true if sucessful.  */\n \n static bool\n try_forward_edges (b)\n      basic_block b;\n {\n-  bool changed = 0;\n-  edge e;\n-  for (e = b->succ; e; e = e->succ_next)\n+  bool changed = false;\n+  edge e, next;\n+\n+  for (e = b->succ; e ; e = next)\n     {\n-      basic_block target = e->dest, first = e->dest;\n-      int counter = 0;\n+      basic_block target, first;\n+      int counter;\n+\n+      next = e->succ_next;\n+\n+      /* Skip complex edges because we don't know how to update them.\n+\t Skip fallthru edges because there's no jump to update.  */\n+      if (e->flags & (EDGE_COMPLEX | EDGE_FALLTHRU))\n+\tcontinue;\n \n-      /* Look for the real destination of jump.\n+      target = first = e->dest;\n+      counter = 0;\n+\n+      /* Look for the real destination of the jump.\n          Avoid inifinite loop in the infinite empty loop by counting\n          up to n_basic_blocks.  */\n       while (forwarder_block_p (target)\n@@ -3124,10 +3134,20 @@ try_forward_edges (b)\n \t  target = target->succ->dest, counter++;\n \t}\n \n-      if (target != first && counter < n_basic_blocks\n-\t  && redirect_edge_and_branch (e, target))\n+      if (counter >= n_basic_blocks)\n+\t{\n+\t  if (rtl_dump_file)\n+\t    fprintf (rtl_dump_file, \"Infinite loop in BB %i.\\n\",\n+\t\t     target->index);\n+\t}\n+      else if (target == first)\n+\t; /* We didn't do anything.  */\n+      else if (redirect_edge_and_branch (e, target))\n \t{\n-\t  while (first != target)\n+\t  /* We successfully forwarded the edge.  Now update profile\n+\t     data: for each edge we traversed in the chain, remove\n+\t     the original edge's execution count.  */\n+\t  do\n \t    {\n \t      first->count -= e->count;\n \t      first->succ->count -= e->count;\n@@ -3136,59 +3156,61 @@ try_forward_edges (b)\n \t\t\t\t   / REG_BR_PROB_BASE);\n \t      first = first->succ->dest;\n \t    }\n-\t  /* We've possibly removed the edge.  */\n-\t  changed = 1;\n-\t  e = b->succ;\n+\t  while (first != target);\n+\n+\t  changed = true;\n+\t}\n+      else\n+\t{\n+\t  if (rtl_dump_file)\n+\t    fprintf (rtl_dump_file, \"Forwarding edge %i->%i to %i failed.\\n\",\n+\t\t     b->index, e->dest->index, target->index);\n \t}\n-      else if (rtl_dump_file && counter == n_basic_blocks)\n-\tfprintf (rtl_dump_file, \"Infinite loop in BB %i.\\n\", target->index);\n-      else if (rtl_dump_file && first != target)\n-\tfprintf (rtl_dump_file,\n-\t\t \"Forwarding edge %i->%i to %i failed.\\n\", b->index,\n-\t\t e->dest->index, target->index);\n     }\n+\n   return changed;\n }\n \n-/* Compare the instructions before end of B1 and B2\n-   to find an opportunity for cross jumping.\n-   (This means detecting identical sequences of insns)\n-   Find the longest possible equivalent sequences\n-   and store the first insns of those sequences into *F1 and *F2\n-   and return length of that sequence.\n+/* Look through the insns at the end of BB1 and BB2 and find the longest\n+   sequence that are equivalent.  Store the first insns for that sequence\n+   in *F1 and *F2 and return the sequence length.\n \n-   To simplify callers of this function, in the\n-   all instructions were matched, allways store bb->head.  */\n+   To simplify callers of this function, if the blocks match exactly,\n+   store the head of the blocks in *F1 and *F2.  */\n \n static int\n flow_find_cross_jump (mode, bb1, bb2, f1, f2)\n-     int mode;\n+     int mode ATTRIBUTE_UNUSED;\n      basic_block bb1, bb2;\n      rtx *f1, *f2;\n {\n-  rtx i1 = onlyjump_p (bb1->end) ? PREV_INSN (bb1->end): bb1->end;\n-  rtx i2 = onlyjump_p (bb2->end) ? PREV_INSN (bb2->end): bb2->end;\n-  rtx p1, p2;\n-  int lose = 0;\n+  rtx i1, i2, p1, p2, last1, last2, afterlast1, afterlast2;\n   int ninsns = 0;\n-  rtx last1 = bb1->end, last2 = bb2->end;\n-  rtx afterlast1 = bb1->end, afterlast2 = bb2->end;\n \n-  /* In case basic block ends by nontrivial jump instruction, count it as\n-     an instruction.  Do not count an unconditional jump, as it will be\n-     removed by basic_block reordering pass in case it is on the common\n-     path.  */\n-  if (bb1->succ->succ_next && bb1->end != i1)\n-    ninsns++;\n+  /* Skip simple jumps at the end of the blocks.  Complex jumps still\n+     need to be compared for equivalence, which we'll do below.  */\n \n-  for (;i1 != bb1->head; i1 = PREV_INSN (i1))\n+  i1 = bb1->end;\n+  if (onlyjump_p (i1))\n+    i1 = PREV_INSN (i1);\n+  i2 = bb2->end;\n+  if (onlyjump_p (i2))\n+    i2 = PREV_INSN (i2);\n+\n+  last1 = afterlast1 = last2 = afterlast2 = NULL_RTX;\n+  while (true)\n     {\n       /* Ignore notes.  */\n-      if (GET_CODE (i1) == NOTE)\n-\tcontinue;\n+      while ((GET_CODE (i1) == NOTE && i1 != bb1->head))\n+\ti1 = PREV_INSN (i1);\n       while ((GET_CODE (i2) == NOTE && i2 != bb2->head))\n \ti2 = PREV_INSN (i2);\n \n+      if (i1 == bb1->head || i2 == bb2->head)\n+\tbreak;\n+\n+      /* Verify that I1 and I2 are equivalent.  */\n+\n       if (GET_CODE (i1) != GET_CODE (i2))\n \tbreak;\n \n@@ -3208,14 +3230,14 @@ flow_find_cross_jump (mode, bb1, bb2, f1, f2)\n       if (GET_CODE (i1) == CALL_INSN\n \t  && ! rtx_equal_p (CALL_INSN_FUNCTION_USAGE (i1),\n \t\t\t    CALL_INSN_FUNCTION_USAGE (i2)))\n-\tlose = 1;\n+\tbreak;\n \n #ifdef STACK_REGS\n       /* If cross_jump_death_matters is not 0, the insn's mode\n \t indicates whether or not the insn contains any stack-like\n \t regs.  */\n \n-      if (!lose && (mode & CLEANUP_POST_REGSTACK ) && stack_regs_mentioned (i1))\n+      if ((mode & CLEANUP_POST_REGSTACK) && stack_regs_mentioned (i1))\n \t{\n \t  /* If register stack conversion has already been done, then\n \t     death notes must also be compared before it is certain that\n@@ -3239,25 +3261,23 @@ flow_find_cross_jump (mode, bb1, bb2, f1, f2)\n \n \t  GO_IF_HARD_REG_EQUAL (i1_regset, i2_regset, done);\n \n-\t  lose = 1;\n+\t  break;\n \n \tdone:\n \t  ;\n \t}\n #endif\n \n-      if (lose || GET_CODE (p1) != GET_CODE (p2)\n-\t  || ! rtx_renumbered_equal_p (p1, p2))\n+      if (GET_CODE (p1) != GET_CODE (p2))\n+\tbreak;\n+\n+      if (! rtx_renumbered_equal_p (p1, p2))\n \t{\n \t  /* The following code helps take care of G++ cleanups.  */\n-\t  rtx equiv1;\n-\t  rtx equiv2;\n-\n-\t  if (!lose && GET_CODE (p1) == GET_CODE (p2)\n-\t      && ((equiv1 = find_reg_note (i1, REG_EQUAL, NULL_RTX)) != 0\n-\t\t  || (equiv1 = find_reg_note (i1, REG_EQUIV, NULL_RTX)) != 0)\n-\t      && ((equiv2 = find_reg_note (i2, REG_EQUAL, NULL_RTX)) != 0\n-\t\t  || (equiv2 = find_reg_note (i2, REG_EQUIV, NULL_RTX)) != 0)\n+\t  rtx equiv1 = find_reg_equal_equiv_note (i1);\n+\t  rtx equiv2 = find_reg_equal_equiv_note (i2);\n+\n+\t  if (equiv1 && equiv2\n \t      /* If the equivalences are not to a constant, they may\n \t\t reference pseudos that no longer exist, so we can't\n \t\t use them.  */\n@@ -3277,78 +3297,87 @@ flow_find_cross_jump (mode, bb1, bb2, f1, f2)\n \t\t    goto win;\n \t\t}\n \t    }\n-\n-\t  /* Insns fail to match; cross jumping is limited to the following\n-\t     insns.  */\n-\n-#ifdef HAVE_cc0\n-\t  /* Don't allow the insn after a compare to be shared by\n-\t     cross-jumping unless the compare is also shared.\n-\t     Here, if either of these non-matching insns is a compare,\n-\t     exclude the following insn from possible cross-jumping.  */\n-\t  if (sets_cc0_p (p1) || sets_cc0_p (p2))\n-\t    last1 = afterlast1, last2 = afterlast2, ninsns--;\n-#endif\n \t  break;\n \t}\n \n     win:\n+      /* Don't begin a cross-jump with a USE or CLOBBER insn.  */\n       if (GET_CODE (p1) != USE && GET_CODE (p1) != CLOBBER)\n \t{\n-\t  /* Ok, this insn is potentially includable in a cross-jump here.  */\n \t  afterlast1 = last1, afterlast2 = last2;\n \t  last1 = i1, last2 = i2;\n           ninsns++;\n \t}\n-\n-      if (i2 == bb2->end)\n-\tbreak;\n+      i1 = PREV_INSN (i1);\n       i2 = PREV_INSN (i2);\n     }\n \n-  /* Skip the notes to reach potential head of basic block.  */\n-  while (last1 != bb1->head && GET_CODE (PREV_INSN (last1)) == NOTE)\n-    last1 = PREV_INSN (last1);\n-  if (last1 != bb1->head && GET_CODE (PREV_INSN (last1)) == CODE_LABEL)\n-    last1 = PREV_INSN (last1);\n-  while (last2 != bb2->head && GET_CODE (PREV_INSN (last2)) == NOTE)\n-    last2 = PREV_INSN (last2);\n-  if (last2 != bb2->head && GET_CODE (PREV_INSN (last2)) == CODE_LABEL)\n-    last2 = PREV_INSN (last2);\n+#ifdef HAVE_cc0\n+  if (ninsns)\n+    {\n+      /* Don't allow the insn after a compare to be shared by\n+\t cross-jumping unless the compare is also shared.  */\n+      if (reg_mentioned_p (cc0_rtx, last1) && ! sets_cc0_p (last1))\n+\tlast1 = afterlast1, last2 = afterlast2, ninsns--;\n+    }\n+#endif\n+\n+  /* Include preceeding notes and labels in the cross-jump.  One,\n+     this may bring us to the head of the blocks as requested above.\n+     Two, it keeps line number notes as matched as may be.  */\n+  if (ninsns)\n+    {\n+      while (last1 != bb1->head && GET_CODE (PREV_INSN (last1)) == NOTE)\n+\tlast1 = PREV_INSN (last1);\n+      if (last1 != bb1->head && GET_CODE (PREV_INSN (last1)) == CODE_LABEL)\n+\tlast1 = PREV_INSN (last1);\n+      while (last2 != bb2->head && GET_CODE (PREV_INSN (last2)) == NOTE)\n+\tlast2 = PREV_INSN (last2);\n+      if (last2 != bb2->head && GET_CODE (PREV_INSN (last2)) == CODE_LABEL)\n+\tlast2 = PREV_INSN (last2);\n+\n+      *f1 = last1;\n+      *f2 = last2;\n+    }\n \n-  *f1 = last1;\n-  *f2 = last2;\n   return ninsns;\n }\n \n /* Return true iff outgoing edges of BB1 and BB2 match, together with\n    the branch instruction.  This means that if we commonize the control\n    flow before end of the basic block, the semantic remains unchanged.  \n \n-   Assume that at least one outgoing edge is forwarded to the same\n-   location.  */\n+   We may assume that there exists one edge with a common destination.  */\n+\n static bool\n outgoing_edges_match (bb1, bb2)\n      basic_block bb1;\n      basic_block bb2;\n {\n-  /* bb1 has one succesor,  so we are seeing unconditional jump.  */\n+  /* If BB1 has only one successor, we must be looking at an unconditional\n+     jump.  Which, by the assumption above, means that we only need to check\n+     that BB2 has one successor.  */\n   if (bb1->succ && !bb1->succ->succ_next)\n     return (bb2->succ && !bb2->succ->succ_next);\n \n   /* Match conditional jumps - this may get tricky when fallthru and branch\n      edges are crossed.  */\n-  if (bb1->succ && bb1->succ->succ_next && !bb1->succ->succ_next->succ_next\n+  if (bb1->succ\n+      && bb1->succ->succ_next\n+      && !bb1->succ->succ_next->succ_next\n       && any_condjump_p (bb1->end))\n     {\n       edge b1, f1, b2, f2;\n       bool reverse, match;\n       rtx set1, set2, cond1, cond2;\n       enum rtx_code code1, code2;\n \n-      if (!bb2->succ || !bb2->succ->succ_next\n-\t  || bb1->succ->succ_next->succ_next || !any_condjump_p (bb2->end))\n+      if (!bb2->succ\n+          || !bb2->succ->succ_next\n+\t  || bb1->succ->succ_next->succ_next\n+\t  || !any_condjump_p (bb2->end))\n \treturn false;\n+\n       b1 = BRANCH_EDGE (bb1);\n       b2 = BRANCH_EDGE (bb2);\n       f1 = FALLTHRU_EDGE (bb1);\n@@ -3390,11 +3419,10 @@ outgoing_edges_match (bb1, bb2)\n \tcode2 = reversed_comparison_code (cond2, bb2->end);\n       else\n \tcode2 = GET_CODE (cond2);\n-\n       if (code2 == UNKNOWN)\n \treturn false;\n \n-      /* See if we don have (cross) match in the codes and operands.  */\n+      /* Verify codes and operands match.  */\n       match = ((code1 == code2\n \t\t&& rtx_renumbered_equal_p (XEXP (cond1, 0), XEXP (cond2, 0))\n \t\t&& rtx_renumbered_equal_p (XEXP (cond1, 1), XEXP (cond2, 1)))\n@@ -3403,71 +3431,90 @@ outgoing_edges_match (bb1, bb2)\n \t\t\t\t\t      XEXP (cond2, 0))\n \t\t   && rtx_renumbered_equal_p (XEXP (cond1, 0),\n \t\t\t\t\t      XEXP (cond2, 1))));\n-      /* In case of returning true, we will commonize the flow.\n-\t This also means, that both branches will contain only single\n-\t branch prediction algorithm.  To match require resulting branch\n-\t to be still well predictable.  */\n+\n+      /* If we return true, we will join the blocks.  Which means that\n+\t we will only have one branch prediction bit to work with.  Thus\n+\t we require the existing branches to have probabilities that are\n+\t roughly similar.  */\n+      /* ??? We should use bb->frequency to allow merging in infrequently\n+\t executed blocks, but at the moment it is not available when\n+\t cleanup_cfg is run.  */\n       if (match && !optimize_size)\n \t{\n \t  rtx note1, note2;\n \t  int prob1, prob2;\n \t  note1 = find_reg_note (bb1->end, REG_BR_PROB, 0);\n \t  note2 = find_reg_note (bb2->end, REG_BR_PROB, 0);\n-\t  if (!note1 || !note2)\n-\t    return false;\n-\t  prob1 = INTVAL (XEXP (note1, 0));\n-\t  prob2 = INTVAL (XEXP (note2, 0));\n-\t  if (reverse)\n-\t    prob2 = REG_BR_PROB_BASE - prob2;\n-\n-\t  /* ??? Later we should use basic block frequency to allow merging\n-\t     in the infrequent blocks, but at the moment it is not\n-\t     available when cleanup_cfg is run.  */\n-\t  if (abs (prob1 - prob2) > REG_BR_PROB_BASE / 90)\n+\n+\t  if (note1 && note2)\n+\t    {\n+\t      prob1 = INTVAL (XEXP (note1, 0));\n+\t      prob2 = INTVAL (XEXP (note2, 0));\n+\t      if (reverse)\n+\t\tprob2 = REG_BR_PROB_BASE - prob2;\n+\n+\t      /* Fail if the difference in probabilities is\n+\t\t greater than 5%.  */\n+\t      if (abs (prob1 - prob2) > REG_BR_PROB_BASE / 20)\n+\t\treturn false;\n+\t    }\n+\t  else if (note1 || note2)\n \t    return false;\n \t}\n+\n       if (rtl_dump_file && match)\n \tfprintf (rtl_dump_file, \"Conditionals in bb %i and %i match.\\n\",\n \t\t bb1->index, bb2->index);\n+\n       return match;\n     }\n+\n   /* ??? We can handle computed jumps too.  This may be important for\n      inlined functions containing switch statements.  Also jumps w/o\n      fallthru edges can be handled by simply matching whole insn.  */\n   return false;\n }\n \n-/* Assume that e1 and e2 are the edges from the same basic block.\n-   Attempt to find common code on both paths and forward control flow\n-   from the first path to second if such exist.  */\n+/* E1 and E2 are edges with the same destination block.  Search their\n+   predecessors for common code.  If found, redirect control flow from\n+   (maybe the middle of) E1->SRC to (maybe the middle of) E2->SRC.  */\n+\n static bool\n try_crossjump_to_edge (mode, e1, e2)\n      int mode;\n      edge e1, e2;\n {\n   int nmatch;\n+  basic_block src1 = e1->src, src2 = e2->src;\n   basic_block redirect_to;\n   rtx newpos1, newpos2;\n-  rtx first, last;\n   edge s;\n+  rtx last;\n   rtx label;\n-  rtx barrier;\n-\n-  /* Skip forwarder blocks.  This is needed to avoid forced forwarders\n-     after conditional jumps from making us to miss optimization.\n \n-     We don't need to worry about multiple entry or chained forwarders, as they\n-     will be optimized out.  */\n-  if (e1->src->pred && !e1->src->pred->pred_next\n-      && forwarder_block_p (e1->src))\n-    e1 = e1->src->pred;\n-  if (e2->src->pred && !e2->src->pred->pred_next\n-      && forwarder_block_p (e2->src))\n-    e2 = e2->src->pred;\n+  /* Search backward through forwarder blocks.  We don't need to worry\n+     about multiple entry or chained forwarders, as they will be optimized\n+     away.  We do this to look past the unconditional jump following a\n+     conditional jump that is required due to the current CFG shape.  */\n+  if (src1->pred\n+      && !src1->pred->pred_next\n+      && forwarder_block_p (src1))\n+    {\n+      e1 = src1->pred;\n+      src1 = e1->src;\n+    }\n+  if (src2->pred\n+      && !src2->pred->pred_next\n+      && forwarder_block_p (src2))\n+    {\n+      e2 = src2->pred;\n+      src2 = e2->src;\n+    }\n \n-  if (e1->src == ENTRY_BLOCK_PTR || e2->src == ENTRY_BLOCK_PTR)\n+  /* Nothing to do if we reach ENTRY, or a common source block.  */\n+  if (src1 == ENTRY_BLOCK_PTR || src2 == ENTRY_BLOCK_PTR)\n     return false;\n-  if (e1->src == e2->src)\n+  if (src1 == src2)\n     return false;\n \n   /* Seeing more than 1 forwarder blocks would confuse us later...  */\n@@ -3477,55 +3524,66 @@ try_crossjump_to_edge (mode, e1, e2)\n   if (forwarder_block_p (e2->dest)\n       && forwarder_block_p (e2->dest->succ->dest))\n     return false;\n-  /* ... similary as seeing dead code...  */\n-  if (!e1->src->pred || !e2->src->pred)\n+\n+  /* Likewise with dead code.  */\n+  /* ??? Won't we have eliminated these by now?  */\n+  if (!src1->pred || !src2->pred)\n     return false;\n-  /* ...similary non-jump edges.  */\n+\n+  /* Likewise with non-jump edges.  */\n+  /* ??? Non-jump?  You mean GET_CODE (e1->src-end) != JUMP_INSN?\n+     This fails for computed-goto as well, which may in fact be joinable.  */\n   if (e1->flags & EDGE_COMPLEX)\n     return false;\n \n-  if (!outgoing_edges_match (e1->src, e2->src))\n+  /* Look for the common insn sequence, part the first ... */\n+  if (!outgoing_edges_match (src1, src2))\n     return false;\n-  nmatch = flow_find_cross_jump (mode, e1->src, e2->src, &newpos1, &newpos2);\n+\n+  /* ... and part the second.  */\n+  nmatch = flow_find_cross_jump (mode, src1, src2, &newpos1, &newpos2);\n   if (!nmatch)\n     return false;\n \n   /* Avoid splitting if possible.  */\n-  if (newpos2 == e2->src->head)\n-    redirect_to = e2->src;\n+  if (newpos2 == src2->head)\n+    redirect_to = src2;\n   else\n     {\n       if (rtl_dump_file)\n \tfprintf (rtl_dump_file, \"Splitting bb %i before %i insns\\n\",\n-\t\t e2->src->index, nmatch);\n-      redirect_to = split_block (e2->src, PREV_INSN (newpos2))->dest;\n+\t\t src2->index, nmatch);\n+      redirect_to = split_block (src2, PREV_INSN (newpos2))->dest;\n     }\n \n   if (rtl_dump_file)\n     fprintf (rtl_dump_file,\n-\t     \"Cross jumping from bb %i to bb %i. %i insn commoized\\n\",\n-\t     e1->src->index, e2->src->index, nmatch);\n+\t     \"Cross jumping from bb %i to bb %i; %i common insns\\n\",\n+\t     src1->index, src2->index, nmatch);\n \n-  redirect_to->count += e1->src->count;\n-  redirect_to->frequency += e1->src->frequency;\n+  redirect_to->count += src1->count;\n+  redirect_to->frequency += src1->frequency;\n \n   /* Recompute the frequencies and counts of outgoing edges.  */\n   for (s = redirect_to->succ; s; s = s->succ_next)\n     {\n       edge s2;\n-      basic_block d = (forwarder_block_p (s->dest) ? s->dest->succ->dest\n-\t\t       : s->dest);\n-      for (s2 = e1->src->succ;; s2 = s2->succ_next)\n+      basic_block d = s->dest;\n+\n+      if (forwarder_block_p (d))\n+\td = d->succ->dest;\n+      for (s2 = src1->succ; ; s2 = s2->succ_next)\n \t{\n-\t  basic_block d2 =\n-\t    (forwarder_block_p (s2->dest) ? s2->dest->succ->dest : s2->dest);\n+\t  basic_block d2 = s2->dest;\n+\t  if (forwarder_block_p (d2))\n+\t    d2 = d2->succ->dest;\n \t  if (d == d2)\n \t    break;\n \t}\n       s->count += s2->count;\n \n-      /* Take care to update possible forwarder blocks.  We took care\n-         that there is no more than one in chain, so we can't run\n+      /* Take care to update possible forwarder blocks.  We verified\n+         that there is no more than one in the chain, so we can't run\n          into infinite loop.  */\n       if (forwarder_block_p (s->dest))\n \t{\n@@ -3541,116 +3599,164 @@ try_crossjump_to_edge (mode, e1, e2)\n \t  s2->dest->frequency -= ((s->probability * s->src->frequency)\n \t\t\t\t  / REG_BR_PROB_BASE);\n \t}\n-      if (!redirect_to->frequency && !e1->src->frequency)\n+      if (!redirect_to->frequency && !src1->frequency)\n \ts->probability = (s->probability + s2->probability) / 2;\n       else\n \ts->probability =\n \t  ((s->probability * redirect_to->frequency +\n-\t    s2->probability * e1->src->frequency)\n-\t   / (redirect_to->frequency + e1->src->frequency));\n+\t    s2->probability * src1->frequency)\n+\t   / (redirect_to->frequency + src1->frequency));\n     }\n \n-  /* FIXME: enable once probabilities are fetched properly at\n-     CFG build.  */\n+  /* FIXME: enable once probabilities are fetched properly at CFG build.  */\n #if 0\n   note = find_reg_note (redirect_to->end, REG_BR_PROB, 0);\n   if (note)\n     XEXP (note, 0) = GEN_INT (BRANCH_EDGE (redirect_to)->probability);\n #endif\n \n-  /* Skip possible basic block header.  */\n-  first = newpos1;\n-  if (GET_CODE (first) == CODE_LABEL)\n-    first = NEXT_INSN (first);\n-  if (GET_CODE (first) == NOTE)\n-    first = NEXT_INSN (first);\n+  /* Edit SRC1 to go to REDIRECT_TO at NEWPOS1.  */\n \n-  last = e1->src->end;\n+  /* Skip possible basic block header.  */\n+  if (GET_CODE (newpos1) == CODE_LABEL)\n+    newpos1 = NEXT_INSN (newpos1);\n+  if (GET_CODE (newpos1) == NOTE)\n+    newpos1 = NEXT_INSN (newpos1);\n+  last = src1->end;\n \n-  /* Now emit the jump insn.   */\n+  /* Emit the jump insn.   */\n   label = block_label (redirect_to);\n-  e1->src->end = emit_jump_insn_after (gen_jump (label), e1->src->end);\n-  JUMP_LABEL (e1->src->end) = label;\n+  src1->end = emit_jump_insn_before (gen_jump (label), newpos1);\n+  JUMP_LABEL (src1->end) = label;\n   LABEL_NUSES (label)++;\n   if (basic_block_for_insn)\n-    set_block_for_new_insns (e1->src->end, e1->src);\n+    set_block_for_new_insns (src1->end, src1);\n \n-  flow_delete_insn_chain (first, last);\n+  /* Delete the now unreachable instructions.  */\n+  flow_delete_insn_chain (newpos1, last);\n \n-  barrier = next_nonnote_insn (e1->src->end);\n-  if (!barrier || GET_CODE (barrier) != BARRIER)\n-    emit_barrier_after (e1->src->end);\n+  /* Make sure there is a barrier after the new jump.  */\n+  last = next_nonnote_insn (src1->end);\n+  if (!last || GET_CODE (last) != BARRIER)\n+    emit_barrier_after (src1->end);\n \n   /* Update CFG.  */\n-  while (e1->src->succ->succ_next)\n-    remove_edge (e1->src->succ);\n-  e1->src->succ->flags = 0;\n-  redirect_edge_succ (e1->src->succ, redirect_to);\n+  while (src1->succ)\n+    remove_edge (src1->succ);\n+  make_edge (NULL, src1, redirect_to, 0);\n+\n   return true;\n }\n \n-/* Attempt to implement cross jumping.  This means moving one or more branches\n-   to BB earlier to BB predecesors commonizing some code.  */\n+/* Search the predecessors of BB for common insn sequences.  When found,\n+   share code between them by redirecting control flow.  Return true if\n+   any changes made.  */\n+\n static bool\n try_crossjump_bb (mode, bb)\n      int mode;\n      basic_block bb;\n {\n   edge e, e2, nexte2, nexte, fallthru;\n-  bool changed = false;\n+  bool changed;\n \n-  /* In case basic block has single predecesor, do nothing.  */\n+  /* Nothing to do if there is not at least two incomming edges.  */\n   if (!bb->pred || !bb->pred->pred_next)\n     return false;\n \n-  /* It is always cheapest to jump into fallthru edge.  */\n+  /* It is always cheapest to redirect a block that ends in a branch to\n+     a block that falls through into BB, as that adds no branches to the\n+     program.  We'll try that combination first.  */\n   for (fallthru = bb->pred; fallthru; fallthru = fallthru->pred_next)\n     if (fallthru->flags & EDGE_FALLTHRU)\n       break;\n \n+  changed = false;\n   for (e = bb->pred; e; e = nexte)\n     {\n       nexte = e->pred_next;\n-      /* First of all prioritize the fallthru edge, as the cheapest.  */\n-      if (e != fallthru && fallthru\n-\t  && try_crossjump_to_edge (mode, e, fallthru))\n-\tchanged = true, nexte = bb->pred;\n-      else\n-\t/* Try match in other incomming edges.\n \n-\t   Loop only over the earlier edges to avoid,as the later\n-\t   will be examined in the oposite direction.  */\n-\tfor (e2 = bb->pred; e2 != e; e2 = nexte2)\n-\t  {\n-\t    nexte2 = e2->pred_next;\n-\t    if (e2 != fallthru && try_crossjump_to_edge (mode, e, e2))\n-\t      {\n-\t\tchanged = true;\n-\t\tnexte = bb->pred;\n-\n-\t\t/* We may've removed the fallthru edge.  */\n-\t\tfor (fallthru = bb->pred; fallthru;\n-\t\t     fallthru = fallthru->pred_next)\n-\t\t  if (fallthru->flags & EDGE_FALLTHRU)\n-\t\t    break;\n-\t\tbreak;\n-\t      }\n-\t  }\n+      /* Elide complex edges now, as neither try_crossjump_to_edge\n+\t nor outgoing_edges_match can handle them.  */\n+      if (e->flags & EDGE_COMPLEX)\n+\tcontinue;\n+\n+      /* As noted above, first try with the fallthru predecessor.  */\n+      if (fallthru)\n+\t{\n+\t  /* Don't combine the fallthru edge into anything else.\n+\t     If there is a match, we'll do it the other way around.  */\n+\t  if (e == fallthru)\n+\t    continue;\n+\t\n+\t  if (try_crossjump_to_edge (mode, e, fallthru))\n+\t    {\n+\t      changed = true;\n+\t      nexte = bb->pred;\n+\t      continue;\n+\t    }\n+\t}\n+\n+      /* Non-obvious work limiting check: Recognize that we're going\n+\t to call try_crossjump_bb on every basic block.  So if we have\n+\t two blocks with lots of outgoing edges (a switch) and they\n+\t share lots of common destinations, then we would do the\n+\t cross-jump check once for each common destination.\n+\n+\t Now, if the blocks actually are cross-jump candidates, then\n+\t all of their destinations will be shared.  Which means that\n+\t we only need check them for cross-jump candidacy once.  We\n+\t can eliminate redundant checks of crossjump(A,B) by arbitrarily\n+\t choosing to do the check from the block for which the edge\n+\t in question is the first successor of A.  */\n+      if (e->src->succ != e)\n+\tcontinue;\n+\n+      for (e2 = bb->pred; e2; e2 = nexte2)\n+\t{\n+\t  nexte2 = e2->pred_next;\n+\n+\t  if (e2 == e)\n+\t    continue;\n+\n+\t  /* We've already checked the fallthru edge above.  */\n+\t  if (e2 == fallthru)\n+\t    continue;\n+\n+\t  /* Again, neither try_crossjump_to_edge nor outgoing_edges_match\n+\t     can handle complex edges.  */\n+\t  if (e2->flags & EDGE_COMPLEX)\n+\t    continue;\n+\n+\t  /* The \"first successor\" check above only prevents multiple\n+\t     checks of crossjump(A,B).  In order to prevent redundant\n+\t     checks of crossjump(B,A), require that A be the block \n+\t     with the lowest index.  */\n+\t  /* ??? Perhaps better is lowest execution frequency.  */\n+\t  if (e->src->index > e2->src->index)\n+\t    continue;\n+\n+\t  if (try_crossjump_to_edge (mode, e, e2))\n+\t    {\n+\t      changed = true;\n+\t      nexte = bb->pred;\n+\t      break;\n+\t    }\n+\t}\n     }\n+\n   return changed;\n }\n \n /* Do simple CFG optimizations - basic block merging, simplifying of jump\n-   instructions etc.\n-\n-   Return nonzero in case some optimizations matched.  */\n+   instructions etc.  Return nonzero if changes were made.  */\n \n static bool\n try_optimize_cfg (mode)\n      int mode;\n {\n   int i;\n-  bool changed_overall = 0;\n+  bool changed_overall = false;\n   bool changed;\n   int iterations = 0;\n \n@@ -3660,16 +3766,18 @@ try_optimize_cfg (mode)\n \n   do\n     {\n-      changed = 0;\n+      changed = false;\n       iterations++;\n+\n       if (rtl_dump_file)\n \tfprintf (rtl_dump_file, \"\\n\\ntry_optimize_cfg iteration %i\\n\\n\",\n \t\t iterations);\n+\n       for (i = 0; i < n_basic_blocks;)\n \t{\n \t  basic_block c, b = BASIC_BLOCK (i);\n \t  edge s;\n-\t  int changed_here = 0;\n+\t  bool changed_here = false;\n \n \t  /* Delete trivially dead basic blocks.  */\n \t  while (b->pred == NULL)\n@@ -3678,19 +3786,20 @@ try_optimize_cfg (mode)\n \t      if (rtl_dump_file)\n \t\tfprintf (rtl_dump_file, \"Deleting block %i.\\n\", b->index);\n \t      flow_delete_block (b);\n-\t      changed = 1;\n+\t      changed = true;\n \t      b = c;\n \t    }\n-\t  /* Remove code labels no longer used.  \n-\t     Don't do the optimization before sibling calls are discovered,\n-\t     as some branches may be hidden inside CALL_PLACEHOLDERs.  */\n+\n+\t  /* Remove code labels no longer used.  Don't do this before\n+\t     CALL_PLACEHOLDER is removed, as some branches may be hidden\n+\t     within.  */\n \t  if (b->pred->pred_next == NULL\n \t      && (b->pred->flags & EDGE_FALLTHRU)\n \t      && !(b->pred->flags & EDGE_COMPLEX)\n \t      && GET_CODE (b->head) == CODE_LABEL\n \t      && (!(mode & CLEANUP_PRE_SIBCALL)\n  \t\t  || !tail_recursion_label_p (b->head))\n-\t      /* If previous block does end with condjump jumping to next BB,\n+\t      /* If previous block ends with condjump jumping to next BB,\n \t         we can't delete the label.  */\n \t      && (b->pred->src == ENTRY_BLOCK_PTR\n \t\t  || !reg_mentioned_p (b->head, b->pred->src->end)))\n@@ -3702,75 +3811,82 @@ try_optimize_cfg (mode)\n \t\tfprintf (rtl_dump_file, \"Deleted label in block %i.\\n\",\n \t\t\t b->index);\n \t    }\n-\t  /* The fallthru forwarder block can be deleted.  */\n+\n+\t  /* If we fall through an empty block, we can remove it.  */\n \t  if (b->pred->pred_next == NULL\n-\t      && forwarder_block_p (b)\n-\t      && n_basic_blocks > 1\n \t      && (b->pred->flags & EDGE_FALLTHRU)\n+\t      && GET_CODE (b->head) != CODE_LABEL\n+\t      && forwarder_block_p (b)\n+\t      /* Note that forwarder_block_p true ensures that there\n+\t\t is a successor for this block.  */\n \t      && (b->succ->flags & EDGE_FALLTHRU)\n-\t      && GET_CODE (b->head) != CODE_LABEL)\n+\t      && n_basic_blocks > 1)\n \t    {\n \t      if (rtl_dump_file)\n \t\tfprintf (rtl_dump_file, \"Deleting fallthru block %i.\\n\",\n \t\t\t b->index);\n-\t      c = BASIC_BLOCK (i ? i - 1 : i + 1);\n+\t      c = BASIC_BLOCK (b->index ? b->index - 1 : 1);\n \t      redirect_edge_succ (b->pred, b->succ->dest);\n \t      flow_delete_block (b);\n-\t      changed = 1;\n+\t      changed = true;\n \t      b = c;\n \t    }\n \n-\n-\t  /* A loop because chains of blocks might be combineable.  */\n+\t  /* Merge blocks.  Loop because chains of blocks might be\n+\t     combineable.  */\n \t  while ((s = b->succ) != NULL\n \t\t && s->succ_next == NULL\n-\t\t && (s->flags & EDGE_EH) == 0\n-\t\t && (c = s->dest) != EXIT_BLOCK_PTR\n \t         && !(s->flags & EDGE_COMPLEX)\n+\t\t && (c = s->dest) != EXIT_BLOCK_PTR\n \t\t && c->pred->pred_next == NULL\n \t\t /* If the jump insn has side effects,\n \t\t    we can't kill the edge.  */\n \t\t && (GET_CODE (b->end) != JUMP_INSN\n-\t\t     || onlyjump_p (b->end)) && merge_blocks (s, b, c, mode))\n-\t    changed_here = 1;\n+\t\t     || onlyjump_p (b->end))\n+\t\t && merge_blocks (s, b, c, mode))\n+\t    changed_here = true;\n \n+\t  /* Simplify branch over branch.  */\n \t  if ((mode & CLEANUP_EXPENSIVE) && try_simplify_condjump (b))\n-\t    changed_here = 1;\n-\n-\t  /* In the case basic blocks has single outgoing edge, but over by the\n-\t     non-trivial jump instruction, we can replace it by unconditional\n-\t     jump, or delete the jump completely.  Use logic of\n-\t     redirect_edge_and_branch to do the dirty job for us.  \n-\n-\t     We match cases as conditional jumps jumping to the next block or\n-\t     dispatch tables.  */\n+\t    changed_here = true;\n \n+\t  /* If B has a single outgoing edge, but uses a non-trivial jump\n+\t     instruction without side-effects, we can either delete the\n+\t     jump entirely, or replace it with a simple unconditional jump.\n+\t     Use redirect_edge_and_branch to do the dirty work.  */\n \t  if (b->succ\n-\t      && b->succ->succ_next == NULL\n-\t      && GET_CODE (b->end) == JUMP_INSN\n+\t      && ! b->succ->succ_next\n \t      && b->succ->dest != EXIT_BLOCK_PTR\n+\t      && onlyjump_p (b->end)\n \t      && redirect_edge_and_branch (b->succ, b->succ->dest))\n-\t    changed_here = 1;\n+\t    changed_here = true;\n \n+\t  /* Simplify branch to branch.  */\n \t  if (try_forward_edges (b))\n-\t    changed_here = 1;\n+\t    changed_here = true;\n \n-\t  if ((mode & CLEANUP_CROSSJUMP) && try_crossjump_bb (mode, b))\n-\t    changed_here = 1;\n+\t  /* Look for shared code between blocks.  */\n+\t  if ((mode & CLEANUP_CROSSJUMP)\n+\t      && try_crossjump_bb (mode, b))\n+\t    changed_here = true;\n \n \t  /* Don't get confused by the index shift caused by deleting\n \t     blocks.  */\n \t  if (!changed_here)\n \t    i = b->index + 1;\n \t  else\n-\t    changed = 1;\n+\t    changed = true;\n \t}\n-      if ((mode & CLEANUP_CROSSJUMP) && try_crossjump_bb (mode, EXIT_BLOCK_PTR))\n-\tchanged = 1;\n+\n+      if ((mode & CLEANUP_CROSSJUMP)\n+\t  && try_crossjump_bb (mode, EXIT_BLOCK_PTR))\n+\tchanged = true;\n+\n #ifdef ENABLE_CHECKING\n       if (changed)\n \tverify_flow_info ();\n #endif\n+\n       changed_overall |= changed;\n     }\n   while (changed);"}]}