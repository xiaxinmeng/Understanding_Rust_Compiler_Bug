{"sha": "8fd737543f6ad7fe43113bde9057debfd8fc0839", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGZkNzM3NTQzZjZhZDdmZTQzMTEzYmRlOTA1N2RlYmZkOGZjMDgzOQ==", "commit": {"author": {"name": "Adam Nemet", "email": "anemet@lnxw.com", "date": "2003-02-14T07:35:44Z"}, "committer": {"name": "Adam Nemet", "email": "nemet@gcc.gnu.org", "date": "2003-02-14T07:35:44Z"}, "message": "re PR rtl-optimization/2391 (Exponential compilation time explosion in combine)\n\n        PR opt/2391\n        * combine.c: Fix spelling in comment.\n        (cached_nonzero_bits): New function.\n        (cached_num_sign_bit_copies): New function.\n\t(nonzero_bits_with_known): New macro.\n\t(num_sign_bit_copies_with_known): New macro.\n        (nonzero_bits1): Rename from nonzero_bits.  Add three new\n\targuments.  Change calls from nonzero_bits to\n\tnonzero_bits_with_known.\n        (num_sign_bit_copies1): Rename from num_sign_bit_copies.  Add\n\tthree new arguments.  Change calls from num_sign_bit_copies to\n\tnum_sign_bit_copies_with_known.\n        (nonzero_bits): New macro.\n        (num_sign_bit_copies): New macro.\n        (update_table_tick): Don't traverse identical subexpression more\n\tthan once.\n        (get_last_value_validate): Likewise.\n\nFrom-SVN: r62893", "tree": {"sha": "608799240ed95f967243b46072f7714e5b8965fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/608799240ed95f967243b46072f7714e5b8965fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8fd737543f6ad7fe43113bde9057debfd8fc0839", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fd737543f6ad7fe43113bde9057debfd8fc0839", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fd737543f6ad7fe43113bde9057debfd8fc0839", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fd737543f6ad7fe43113bde9057debfd8fc0839/comments", "author": null, "committer": null, "parents": [{"sha": "fd295cb213e665379353d4e7b32f8bdcd8df7ade", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd295cb213e665379353d4e7b32f8bdcd8df7ade", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd295cb213e665379353d4e7b32f8bdcd8df7ade"}], "stats": {"total": 338, "additions": 285, "deletions": 53}, "files": [{"sha": "9de0cb479078d8c8eb0843504299fec8acf5867a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fd737543f6ad7fe43113bde9057debfd8fc0839/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fd737543f6ad7fe43113bde9057debfd8fc0839/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8fd737543f6ad7fe43113bde9057debfd8fc0839", "patch": "@@ -1,3 +1,22 @@\n+2003-02-13  Adam Nemet  <anemet@lnxw.com>\n+        PR opt/2391 \n+        * combine.c: Fix spelling in comment.\n+        (cached_nonzero_bits): New function.\n+        (cached_num_sign_bit_copies): New function.\n+\t(nonzero_bits_with_known): New macro.\n+\t(num_sign_bit_copies_with_known): New macro.\n+        (nonzero_bits1): Rename from nonzero_bits.  Add three new\n+\targuments.  Change calls from nonzero_bits to\n+\tnonzero_bits_with_known.\n+        (num_sign_bit_copies1): Rename from num_sign_bit_copies.  Add\n+\tthree new arguments.  Change calls from num_sign_bit_copies to\n+\tnum_sign_bit_copies_with_known.\n+        (nonzero_bits): New macro.\n+        (num_sign_bit_copies): New macro.\n+        (update_table_tick): Don't traverse identical subexpression more\n+\tthan once.\n+        (get_last_value_validate): Likewise.\n+\n 2003-02-13  Zack Weinberg  <zack@codesourcery.com>\n \n \t* emit-rtl.c (init_emit): Use ggc_alloc for regno_reg_rtx."}, {"sha": "8f126568c801db46ff7500f70842fbafe0d984c0", "filename": "gcc/combine.c", "status": "modified", "additions": 266, "deletions": 53, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fd737543f6ad7fe43113bde9057debfd8fc0839/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fd737543f6ad7fe43113bde9057debfd8fc0839/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=8fd737543f6ad7fe43113bde9057debfd8fc0839", "patch": "@@ -139,6 +139,12 @@ static int max_uid_cuid;\n #define UWIDE_SHIFT_LEFT_BY_BITS_PER_WORD(val) \\\n   (((unsigned HOST_WIDE_INT) (val) << (BITS_PER_WORD - 1)) << 1)\n \n+#define nonzero_bits(X, M) \\\n+  cached_nonzero_bits (X, M, NULL_RTX, VOIDmode, 0)\n+\n+#define num_sign_bit_copies(X, M) \\\n+  cached_num_sign_bit_copies (X, M, NULL_RTX, VOIDmode, 0)\n+\n /* Maximum register number, which is the size of the tables below.  */\n \n static unsigned int combine_max_regno;\n@@ -198,7 +204,7 @@ static basic_block this_basic_block;\n static sbitmap refresh_blocks;\n \f\n /* The next group of arrays allows the recording of the last value assigned\n-   to (hard or pseudo) register n.  We use this information to see if a\n+   to (hard or pseudo) register n.  We use this information to see if an\n    operation being processed is redundant given a prior operation performed\n    on the register.  For example, an `and' with a constant is redundant if\n    all the zero bits are already known to be turned off.\n@@ -371,8 +377,20 @@ static rtx make_field_assignment  PARAMS ((rtx));\n static rtx apply_distributive_law  PARAMS ((rtx));\n static rtx simplify_and_const_int  PARAMS ((rtx, enum machine_mode, rtx,\n \t\t\t\t\t    unsigned HOST_WIDE_INT));\n-static unsigned HOST_WIDE_INT nonzero_bits  PARAMS ((rtx, enum machine_mode));\n-static unsigned int num_sign_bit_copies  PARAMS ((rtx, enum machine_mode));\n+static unsigned HOST_WIDE_INT cached_nonzero_bits\n+\t\t\t\tPARAMS ((rtx, enum machine_mode, rtx,\n+\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t unsigned HOST_WIDE_INT));\n+static unsigned HOST_WIDE_INT nonzero_bits1\n+\t\t\t\tPARAMS ((rtx, enum machine_mode, rtx,\n+\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t unsigned HOST_WIDE_INT));\n+static unsigned int cached_num_sign_bit_copies\n+\t\t\t\tPARAMS ((rtx, enum machine_mode, rtx,\n+\t\t\t\t\t enum machine_mode, unsigned int));\n+static unsigned int num_sign_bit_copies1\n+\t\t\t\tPARAMS ((rtx, enum machine_mode, rtx,\n+\t\t\t\t\t enum machine_mode, unsigned int));\n static int merge_outer_ops\tPARAMS ((enum rtx_code *, HOST_WIDE_INT *,\n \t\t\t\t\t enum rtx_code, HOST_WIDE_INT,\n \t\t\t\t\t enum machine_mode, int *));\n@@ -8161,12 +8179,62 @@ simplify_and_const_int (x, mode, varop, constop)\n   return x;\n }\n \f\n+#define nonzero_bits_with_known(X, MODE) \\\n+  cached_nonzero_bits (X, MODE, known_x, known_mode, known_ret)\n+\n+/* The function cached_nonzero_bits is a wrapper around nonzero_bits1.\n+   It avoids exponential behavior in nonzero_bits1 when X has\n+   identical subexpressions on the first or the second level.  */\n+\n+static unsigned HOST_WIDE_INT\n+cached_nonzero_bits (x, mode, known_x, known_mode, known_ret)\n+     rtx x;\n+     enum machine_mode mode;\n+     rtx known_x;\n+     enum machine_mode known_mode;\n+     unsigned HOST_WIDE_INT known_ret;\n+{\n+  if (x == known_x && mode == known_mode)\n+    return known_ret;\n+\n+  /* Try to find identical subexpressions.  If found call\n+     nonzero_bits1 on X with the subexpressions as KNOWN_X and the\n+     precomputed value for the subexpression as KNOWN_RET.  */\n+\n+  if (GET_RTX_CLASS (GET_CODE (x)) == '2'\n+      || GET_RTX_CLASS (GET_CODE (x)) == 'c')\n+    {\n+      rtx x0 = XEXP (x, 0);\n+      rtx x1 = XEXP (x, 1);\n+\n+      /* Check the first level.  */\n+      if (x0 == x1)\n+\treturn nonzero_bits1 (x, mode, x0, mode,\n+\t\t\t      nonzero_bits_with_known (x0, mode));\n+\n+      /* Check the second level.  */\n+      if ((GET_RTX_CLASS (GET_CODE (x0)) == '2'\n+\t   || GET_RTX_CLASS (GET_CODE (x0)) == 'c')\n+\t  && (x1 == XEXP (x0, 0) || x1 == XEXP (x0, 1)))\n+\treturn nonzero_bits1 (x, mode, x1, mode,\n+\t\t\t      nonzero_bits_with_known (x1, mode));\n+\n+      if ((GET_RTX_CLASS (GET_CODE (x1)) == '2'\n+\t   || GET_RTX_CLASS (GET_CODE (x1)) == 'c')\n+\t  && (x0 == XEXP (x1, 0) || x0 == XEXP (x1, 1)))\n+\treturn nonzero_bits1 (x, mode, x0, mode,\n+\t\t\t nonzero_bits_with_known (x0, mode));\n+    }\n+\n+  return nonzero_bits1 (x, mode, known_x, known_mode, known_ret);\n+}\n+\n /* We let num_sign_bit_copies recur into nonzero_bits as that is useful.\n    We don't let nonzero_bits recur into num_sign_bit_copies, because that\n    is less useful.  We can't allow both, because that results in exponential\n    run time recursion.  There is a nullstone testcase that triggered\n    this.  This macro avoids accidental uses of num_sign_bit_copies.  */\n-#define num_sign_bit_copies()\n+#define cached_num_sign_bit_copies()\n \n /* Given an expression, X, compute which bits in X can be nonzero.\n    We don't care about bits outside of those defined in MODE.\n@@ -8175,9 +8243,12 @@ simplify_and_const_int (x, mode, varop, constop)\n    a shift, AND, or zero_extract, we can do better.  */\n \n static unsigned HOST_WIDE_INT\n-nonzero_bits (x, mode)\n+nonzero_bits1 (x, mode, known_x, known_mode, known_ret)\n      rtx x;\n      enum machine_mode mode;\n+     rtx known_x;\n+     enum machine_mode known_mode;\n+     unsigned HOST_WIDE_INT known_ret;\n {\n   unsigned HOST_WIDE_INT nonzero = GET_MODE_MASK (mode);\n   unsigned HOST_WIDE_INT inner_nz;\n@@ -8215,7 +8286,7 @@ nonzero_bits (x, mode)\n       && GET_MODE_BITSIZE (GET_MODE (x)) <= HOST_BITS_PER_WIDE_INT\n       && GET_MODE_BITSIZE (mode) > GET_MODE_BITSIZE (GET_MODE (x)))\n     {\n-      nonzero &= nonzero_bits (x, GET_MODE (x));\n+      nonzero &= nonzero_bits_with_known (x, GET_MODE (x));\n       nonzero |= GET_MODE_MASK (mode) & ~GET_MODE_MASK (GET_MODE (x));\n       return nonzero;\n     }\n@@ -8297,7 +8368,7 @@ nonzero_bits (x, mode)\n \t\t\t   | ((HOST_WIDE_INT) (-1)\n \t\t\t      << GET_MODE_BITSIZE (GET_MODE (x))));\n #endif\n-\t  return nonzero_bits (tem, mode) & nonzero;\n+\t  return nonzero_bits_with_known (tem, mode) & nonzero;\n \t}\n       else if (nonzero_sign_valid && reg_nonzero_bits[REGNO (x)])\n \t{\n@@ -8372,11 +8443,12 @@ nonzero_bits (x, mode)\n       break;\n \n     case TRUNCATE:\n-      nonzero &= (nonzero_bits (XEXP (x, 0), mode) & GET_MODE_MASK (mode));\n+      nonzero &= (nonzero_bits_with_known (XEXP (x, 0), mode)\n+\t\t  & GET_MODE_MASK (mode));\n       break;\n \n     case ZERO_EXTEND:\n-      nonzero &= nonzero_bits (XEXP (x, 0), mode);\n+      nonzero &= nonzero_bits_with_known (XEXP (x, 0), mode);\n       if (GET_MODE (XEXP (x, 0)) != VOIDmode)\n \tnonzero &= GET_MODE_MASK (GET_MODE (XEXP (x, 0)));\n       break;\n@@ -8385,7 +8457,7 @@ nonzero_bits (x, mode)\n       /* If the sign bit is known clear, this is the same as ZERO_EXTEND.\n \t Otherwise, show all the bits in the outer mode but not the inner\n \t may be nonzero.  */\n-      inner_nz = nonzero_bits (XEXP (x, 0), mode);\n+      inner_nz = nonzero_bits_with_known (XEXP (x, 0), mode);\n       if (GET_MODE (XEXP (x, 0)) != VOIDmode)\n \t{\n \t  inner_nz &= GET_MODE_MASK (GET_MODE (XEXP (x, 0)));\n@@ -8400,19 +8472,21 @@ nonzero_bits (x, mode)\n       break;\n \n     case AND:\n-      nonzero &= (nonzero_bits (XEXP (x, 0), mode)\n-\t\t  & nonzero_bits (XEXP (x, 1), mode));\n+      nonzero &= (nonzero_bits_with_known (XEXP (x, 0), mode)\n+\t\t  & nonzero_bits_with_known (XEXP (x, 1), mode));\n       break;\n \n     case XOR:   case IOR:\n     case UMIN:  case UMAX:  case SMIN:  case SMAX:\n       {\n-\tunsigned HOST_WIDE_INT nonzero0 = nonzero_bits (XEXP (x, 0), mode);\n+\tunsigned HOST_WIDE_INT nonzero0 =\n+\t  nonzero_bits_with_known (XEXP (x, 0), mode);\n \n \t/* Don't call nonzero_bits for the second time if it cannot change\n \t   anything.  */\n \tif ((nonzero & nonzero0) != nonzero)\n-\t  nonzero &= (nonzero0 | nonzero_bits (XEXP (x, 1), mode));\n+\t  nonzero &= (nonzero0\n+\t\t      | nonzero_bits_with_known (XEXP (x, 1), mode));\n       }\n       break;\n \n@@ -8425,8 +8499,10 @@ nonzero_bits (x, mode)\n \t computing the width (position of the highest-order nonzero bit)\n \t and the number of low-order zero bits for each value.  */\n       {\n-\tunsigned HOST_WIDE_INT nz0 = nonzero_bits (XEXP (x, 0), mode);\n-\tunsigned HOST_WIDE_INT nz1 = nonzero_bits (XEXP (x, 1), mode);\n+\tunsigned HOST_WIDE_INT nz0 =\n+\t  nonzero_bits_with_known (XEXP (x, 0), mode);\n+\tunsigned HOST_WIDE_INT nz1 =\n+\t  nonzero_bits_with_known (XEXP (x, 1), mode);\n \tint sign_index = GET_MODE_BITSIZE (GET_MODE (x)) - 1;\n \tint width0 = floor_log2 (nz0) + 1;\n \tint width1 = floor_log2 (nz1) + 1;\n@@ -8511,7 +8587,7 @@ nonzero_bits (x, mode)\n \n       if (SUBREG_PROMOTED_VAR_P (x) && SUBREG_PROMOTED_UNSIGNED_P (x) > 0)\n \tnonzero = (GET_MODE_MASK (GET_MODE (x))\n-\t\t   & nonzero_bits (SUBREG_REG (x), GET_MODE (x)));\n+\t\t   & nonzero_bits_with_known (SUBREG_REG (x), GET_MODE (x)));\n \n       /* If the inner mode is a single word for both the host and target\n \t machines, we can compute this from which bits of the inner\n@@ -8520,7 +8596,7 @@ nonzero_bits (x, mode)\n \t  && (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x)))\n \t      <= HOST_BITS_PER_WIDE_INT))\n \t{\n-\t  nonzero &= nonzero_bits (SUBREG_REG (x), mode);\n+\t  nonzero &= nonzero_bits_with_known (SUBREG_REG (x), mode);\n \n #if defined (WORD_REGISTER_OPERATIONS) && defined (LOAD_EXTEND_OP)\n \t  /* If this is a typical RISC machine, we only have to worry\n@@ -8563,7 +8639,8 @@ nonzero_bits (x, mode)\n \t  unsigned int width = GET_MODE_BITSIZE (inner_mode);\n \t  int count = INTVAL (XEXP (x, 1));\n \t  unsigned HOST_WIDE_INT mode_mask = GET_MODE_MASK (inner_mode);\n-\t  unsigned HOST_WIDE_INT op_nonzero = nonzero_bits (XEXP (x, 0), mode);\n+\t  unsigned HOST_WIDE_INT op_nonzero =\n+\t    nonzero_bits_with_known (XEXP (x, 0), mode);\n \t  unsigned HOST_WIDE_INT inner = op_nonzero & mode_mask;\n \t  unsigned HOST_WIDE_INT outer = 0;\n \n@@ -8621,8 +8698,8 @@ nonzero_bits (x, mode)\n       break;\n \n     case IF_THEN_ELSE:\n-      nonzero &= (nonzero_bits (XEXP (x, 1), mode)\n-\t\t  | nonzero_bits (XEXP (x, 2), mode));\n+      nonzero &= (nonzero_bits_with_known (XEXP (x, 1), mode)\n+\t\t  | nonzero_bits_with_known (XEXP (x, 2), mode));\n       break;\n \n     default:\n@@ -8633,17 +8710,74 @@ nonzero_bits (x, mode)\n }\n \n /* See the macro definition above.  */\n-#undef num_sign_bit_copies\n+#undef cached_num_sign_bit_copies\n \f\n+#define num_sign_bit_copies_with_known(X, M) \\\n+  cached_num_sign_bit_copies (X, M, known_x, known_mode, known_ret)\n+\n+/* The function cached_num_sign_bit_copies is a wrapper around\n+   num_sign_bit_copies1.  It avoids exponential behavior in\n+   num_sign_bit_copies1 when X has identical subexpressions on the\n+   first or the second level.  */\n+\n+static unsigned int\n+cached_num_sign_bit_copies (x, mode, known_x, known_mode, known_ret)\n+     rtx x;\n+     enum machine_mode mode;\n+     rtx known_x;\n+     enum machine_mode known_mode;\n+     unsigned int known_ret;\n+{\n+  if (x == known_x && mode == known_mode)\n+    return known_ret;\n+\n+  /* Try to find identical subexpressions.  If found call\n+     num_sign_bit_copies1 on X with the subexpressions as KNOWN_X and\n+     the precomputed value for the subexpression as KNOWN_RET.  */\n+\n+  if (GET_RTX_CLASS (GET_CODE (x)) == '2'\n+      || GET_RTX_CLASS (GET_CODE (x)) == 'c')\n+    {\n+      rtx x0 = XEXP (x, 0);\n+      rtx x1 = XEXP (x, 1);\n+\n+      /* Check the first level.  */\n+      if (x0 == x1)\n+\treturn\n+\t  num_sign_bit_copies1 (x, mode, x0, mode,\n+\t\t\t\tnum_sign_bit_copies_with_known (x0, mode));\n+\n+      /* Check the second level.  */\n+      if ((GET_RTX_CLASS (GET_CODE (x0)) == '2'\n+\t   || GET_RTX_CLASS (GET_CODE (x0)) == 'c')\n+\t  && (x1 == XEXP (x0, 0) || x1 == XEXP (x0, 1)))\n+\treturn\n+\t  num_sign_bit_copies1 (x, mode, x1, mode,\n+\t\t\t\tnum_sign_bit_copies_with_known (x1, mode));\n+\n+      if ((GET_RTX_CLASS (GET_CODE (x1)) == '2'\n+\t   || GET_RTX_CLASS (GET_CODE (x1)) == 'c')\n+\t  && (x0 == XEXP (x1, 0) || x0 == XEXP (x1, 1)))\n+\treturn\n+\t  num_sign_bit_copies1 (x, mode, x0, mode,\n+\t\t\t\tnum_sign_bit_copies_with_known (x0, mode));\n+    }\n+\n+  return num_sign_bit_copies1 (x, mode, known_x, known_mode, known_ret);\n+}\n+\n /* Return the number of bits at the high-order end of X that are known to\n    be equal to the sign bit.  X will be used in mode MODE; if MODE is\n    VOIDmode, X will be used in its own mode.  The returned value  will always\n    be between 1 and the number of bits in MODE.  */\n \n static unsigned int\n-num_sign_bit_copies (x, mode)\n+num_sign_bit_copies1 (x, mode, known_x, known_mode, known_ret)\n      rtx x;\n      enum machine_mode mode;\n+     rtx known_x;\n+     enum machine_mode known_mode;\n+     unsigned int known_ret;\n {\n   enum rtx_code code = GET_CODE (x);\n   unsigned int bitwidth;\n@@ -8666,7 +8800,7 @@ num_sign_bit_copies (x, mode)\n   /* For a smaller object, just ignore the high bits.  */\n   if (bitwidth < GET_MODE_BITSIZE (GET_MODE (x)))\n     {\n-      num0 = num_sign_bit_copies (x, GET_MODE (x));\n+      num0 = num_sign_bit_copies_with_known (x, GET_MODE (x));\n       return MAX (1,\n \t\t  num0 - (int) (GET_MODE_BITSIZE (GET_MODE (x)) - bitwidth));\n     }\n@@ -8715,7 +8849,7 @@ num_sign_bit_copies (x, mode)\n \n       tem = get_last_value (x);\n       if (tem != 0)\n-\treturn num_sign_bit_copies (tem, mode);\n+\treturn num_sign_bit_copies_with_known (tem, mode);\n \n       if (nonzero_sign_valid && reg_sign_bit_copies[REGNO (x)] != 0\n \t  && GET_MODE_BITSIZE (GET_MODE (x)) == bitwidth)\n@@ -8748,7 +8882,7 @@ num_sign_bit_copies (x, mode)\n \n       if (SUBREG_PROMOTED_VAR_P (x) && ! SUBREG_PROMOTED_UNSIGNED_P (x))\n \t{\n-\t  num0 = num_sign_bit_copies (SUBREG_REG (x), mode);\n+\t  num0 = num_sign_bit_copies_with_known (SUBREG_REG (x), mode);\n \t  return MAX ((int) bitwidth\n \t\t      - (int) GET_MODE_BITSIZE (GET_MODE (x)) + 1,\n \t\t      num0);\n@@ -8757,7 +8891,7 @@ num_sign_bit_copies (x, mode)\n       /* For a smaller object, just ignore the high bits.  */\n       if (bitwidth <= GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x))))\n \t{\n-\t  num0 = num_sign_bit_copies (SUBREG_REG (x), VOIDmode);\n+\t  num0 = num_sign_bit_copies_with_known (SUBREG_REG (x), VOIDmode);\n \t  return MAX (1, (num0\n \t\t\t  - (int) (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x)))\n \t\t\t\t   - bitwidth)));\n@@ -8779,7 +8913,7 @@ num_sign_bit_copies (x, mode)\n \t   > GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n \t  && LOAD_EXTEND_OP (GET_MODE (SUBREG_REG (x))) == SIGN_EXTEND\n \t  && GET_CODE (SUBREG_REG (x)) == MEM)\n-\treturn num_sign_bit_copies (SUBREG_REG (x), mode);\n+\treturn num_sign_bit_copies_with_known (SUBREG_REG (x), mode);\n #endif\n #endif\n       break;\n@@ -8791,16 +8925,16 @@ num_sign_bit_copies (x, mode)\n \n     case SIGN_EXTEND:\n       return (bitwidth - GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0)))\n-\t      + num_sign_bit_copies (XEXP (x, 0), VOIDmode));\n+\t      + num_sign_bit_copies_with_known (XEXP (x, 0), VOIDmode));\n \n     case TRUNCATE:\n       /* For a smaller object, just ignore the high bits.  */\n-      num0 = num_sign_bit_copies (XEXP (x, 0), VOIDmode);\n+      num0 = num_sign_bit_copies_with_known (XEXP (x, 0), VOIDmode);\n       return MAX (1, (num0 - (int) (GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0)))\n \t\t\t\t    - bitwidth)));\n \n     case NOT:\n-      return num_sign_bit_copies (XEXP (x, 0), mode);\n+      return num_sign_bit_copies_with_known (XEXP (x, 0), mode);\n \n     case ROTATE:       case ROTATERT:\n       /* If we are rotating left by a number of bits less than the number\n@@ -8810,7 +8944,7 @@ num_sign_bit_copies (x, mode)\n \t  && INTVAL (XEXP (x, 1)) >= 0\n \t  && INTVAL (XEXP (x, 1)) < (int) bitwidth)\n \t{\n-\t  num0 = num_sign_bit_copies (XEXP (x, 0), mode);\n+\t  num0 = num_sign_bit_copies_with_known (XEXP (x, 0), mode);\n \t  return MAX (1, num0 - (code == ROTATE ? INTVAL (XEXP (x, 1))\n \t\t\t\t : (int) bitwidth - INTVAL (XEXP (x, 1))));\n \t}\n@@ -8821,7 +8955,7 @@ num_sign_bit_copies (x, mode)\n \t is known to be positive, the number of sign bit copies is the\n \t same as that of the input.  Finally, if the input has just one bit\n \t that might be nonzero, all the bits are copies of the sign bit.  */\n-      num0 = num_sign_bit_copies (XEXP (x, 0), mode);\n+      num0 = num_sign_bit_copies_with_known (XEXP (x, 0), mode);\n       if (bitwidth > HOST_BITS_PER_WIDE_INT)\n \treturn num0 > 1 ? num0 - 1 : 1;\n \n@@ -8839,8 +8973,8 @@ num_sign_bit_copies (x, mode)\n     case SMIN:  case SMAX:  case UMIN:  case UMAX:\n       /* Logical operations will preserve the number of sign-bit copies.\n \t MIN and MAX operations always return one of the operands.  */\n-      num0 = num_sign_bit_copies (XEXP (x, 0), mode);\n-      num1 = num_sign_bit_copies (XEXP (x, 1), mode);\n+      num0 = num_sign_bit_copies_with_known (XEXP (x, 0), mode);\n+      num1 = num_sign_bit_copies_with_known (XEXP (x, 1), mode);\n       return MIN (num0, num1);\n \n     case PLUS:  case MINUS:\n@@ -8858,8 +8992,8 @@ num_sign_bit_copies (x, mode)\n \t\t    : bitwidth - floor_log2 (nonzero) - 1);\n \t}\n \n-      num0 = num_sign_bit_copies (XEXP (x, 0), mode);\n-      num1 = num_sign_bit_copies (XEXP (x, 1), mode);\n+      num0 = num_sign_bit_copies_with_known (XEXP (x, 0), mode);\n+      num1 = num_sign_bit_copies_with_known (XEXP (x, 1), mode);\n       result = MAX (1, MIN (num0, num1) - 1);\n \n #ifdef POINTERS_EXTEND_UNSIGNED\n@@ -8881,8 +9015,8 @@ num_sign_bit_copies (x, mode)\n \t to be positive, we must allow for an additional bit since negating\n \t a negative number can remove one sign bit copy.  */\n \n-      num0 = num_sign_bit_copies (XEXP (x, 0), mode);\n-      num1 = num_sign_bit_copies (XEXP (x, 1), mode);\n+      num0 = num_sign_bit_copies_with_known (XEXP (x, 0), mode);\n+      num1 = num_sign_bit_copies_with_known (XEXP (x, 1), mode);\n \n       result = bitwidth - (bitwidth - num0) - (bitwidth - num1);\n       if (result > 0\n@@ -8905,17 +9039,17 @@ num_sign_bit_copies (x, mode)\n \t\t& ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n \treturn 1;\n       else\n-\treturn num_sign_bit_copies (XEXP (x, 0), mode);\n+\treturn num_sign_bit_copies_with_known (XEXP (x, 0), mode);\n \n     case UMOD:\n       /* The result must be <= the second operand.  */\n-      return num_sign_bit_copies (XEXP (x, 1), mode);\n+      return num_sign_bit_copies_with_known (XEXP (x, 1), mode);\n \n     case DIV:\n       /* Similar to unsigned division, except that we have to worry about\n \t the case where the divisor is negative, in which case we have\n \t to add 1.  */\n-      result = num_sign_bit_copies (XEXP (x, 0), mode);\n+      result = num_sign_bit_copies_with_known (XEXP (x, 0), mode);\n       if (result > 1\n \t  && (bitwidth > HOST_BITS_PER_WIDE_INT\n \t      || (nonzero_bits (XEXP (x, 1), mode)\n@@ -8925,7 +9059,7 @@ num_sign_bit_copies (x, mode)\n       return result;\n \n     case MOD:\n-      result = num_sign_bit_copies (XEXP (x, 1), mode);\n+      result = num_sign_bit_copies_with_known (XEXP (x, 1), mode);\n       if (result > 1\n \t  && (bitwidth > HOST_BITS_PER_WIDE_INT\n \t      || (nonzero_bits (XEXP (x, 1), mode)\n@@ -8937,7 +9071,7 @@ num_sign_bit_copies (x, mode)\n     case ASHIFTRT:\n       /* Shifts by a constant add to the number of bits equal to the\n \t sign bit.  */\n-      num0 = num_sign_bit_copies (XEXP (x, 0), mode);\n+      num0 = num_sign_bit_copies_with_known (XEXP (x, 0), mode);\n       if (GET_CODE (XEXP (x, 1)) == CONST_INT\n \t  && INTVAL (XEXP (x, 1)) > 0)\n \tnum0 = MIN ((int) bitwidth, num0 + INTVAL (XEXP (x, 1)));\n@@ -8951,12 +9085,12 @@ num_sign_bit_copies (x, mode)\n \t  || INTVAL (XEXP (x, 1)) >= (int) bitwidth)\n \treturn 1;\n \n-      num0 = num_sign_bit_copies (XEXP (x, 0), mode);\n+      num0 = num_sign_bit_copies_with_known (XEXP (x, 0), mode);\n       return MAX (1, num0 - INTVAL (XEXP (x, 1)));\n \n     case IF_THEN_ELSE:\n-      num0 = num_sign_bit_copies (XEXP (x, 1), mode);\n-      num1 = num_sign_bit_copies (XEXP (x, 2), mode);\n+      num0 = num_sign_bit_copies_with_known (XEXP (x, 1), mode);\n+      num1 = num_sign_bit_copies_with_known (XEXP (x, 2), mode);\n       return MIN (num0, num1);\n \n     case EQ:  case NE:  case GE:  case GT:  case LE:  case LT:\n@@ -11405,7 +11539,45 @@ update_table_tick (x)\n     /* Note that we can't have an \"E\" in values stored; see\n        get_last_value_validate.  */\n     if (fmt[i] == 'e')\n-      update_table_tick (XEXP (x, i));\n+      {\n+\t/* Check for identical subexpressions.  If x contains\n+\t   identical subexpression we only have to traverse one of\n+\t   them.  */\n+\tif (i == 0\n+\t    && (GET_RTX_CLASS (code) == '2'\n+\t\t|| GET_RTX_CLASS (code) == 'c'))\n+\t  {\n+\t    /* Note that at this point x1 has already been\n+\t       processed.  */\n+\t    rtx x0 = XEXP (x, 0);\n+\t    rtx x1 = XEXP (x, 1);\n+\n+\t    /* If x0 and x1 are identical then there is no need to\n+\t       process x0.  */\n+\t    if (x0 == x1)\n+\t      break;\n+\n+\t    /* If x0 is identical to a subexpression of x1 then while\n+\t       processing x1, x0 has already been processed.  Thus we\n+\t       are done with x.  */\n+\t    if ((GET_RTX_CLASS (GET_CODE (x1)) == '2'\n+\t\t || GET_RTX_CLASS (GET_CODE (x1)) == 'c')\n+\t\t&& (x0 == XEXP (x1, 0) || x0 == XEXP (x1, 1)))\n+\t      break;\n+\n+\t    /* If x1 is identical to a subexpression of x0 then we\n+\t       still have to process the rest of x0.  */\n+\t    if ((GET_RTX_CLASS (GET_CODE (x0)) == '2'\n+\t\t || GET_RTX_CLASS (GET_CODE (x0)) == 'c')\n+\t\t&& (x1 == XEXP (x0, 0) || x1 == XEXP (x0, 1)))\n+\t      {\n+\t\tupdate_table_tick (XEXP (x0, x1 == XEXP (x0, 0) ? 1 : 0));\n+\t\tbreak;\n+\t      }\n+\t  }\n+\t  \n+\tupdate_table_tick (XEXP (x, i));\n+      }\n }\n \n /* Record that REG is set to VALUE in insn INSN.  If VALUE is zero, we\n@@ -11758,11 +11930,52 @@ get_last_value_validate (loc, insn, tick, replace)\n     }\n \n   for (i = 0; i < len; i++)\n-    if ((fmt[i] == 'e'\n-\t && get_last_value_validate (&XEXP (x, i), insn, tick, replace) == 0)\n-\t/* Don't bother with these.  They shouldn't occur anyway.  */\n-\t|| fmt[i] == 'E')\n-      return 0;\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  /* Check for identical subexpressions.  If x contains\n+\t     identical subexpression we only have to traverse one of\n+\t     them.  */\n+\t  if (i == 1\n+\t      && (GET_RTX_CLASS (GET_CODE (x)) == '2'\n+\t\t  || GET_RTX_CLASS (GET_CODE (x)) == 'c'))\n+\t    {\n+\t      /* Note that at this point x0 has already been checked\n+\t\t and found valid.  */\n+\t      rtx x0 = XEXP (x, 0);\n+\t      rtx x1 = XEXP (x, 1);\n+\n+\t      /* If x0 and x1 are identical then x is also valid.  */\n+\t      if (x0 == x1)\n+\t\treturn 1;\n+\n+\t      /* If x1 is identical to a subexpression of x0 then\n+\t\t while checking x0, x1 has already been checked.  Thus\n+\t\t it is valid and so as x.  */\n+\t      if ((GET_RTX_CLASS (GET_CODE (x0)) == '2'\n+\t\t   || GET_RTX_CLASS (GET_CODE (x0)) == 'c')\n+\t\t  && (x1 == XEXP (x0, 0) || x1 == XEXP (x0, 1)))\n+\t\treturn 1;\n+\n+\t      /* If x0 is identical to a subexpression of x1 then x is\n+\t\t valid iff the rest of x1 is valid.  */\n+\t      if ((GET_RTX_CLASS (GET_CODE (x1)) == '2'\n+\t\t   || GET_RTX_CLASS (GET_CODE (x1)) == 'c')\n+\t\t  && (x0 == XEXP (x1, 0) || x0 == XEXP (x1, 1)))\n+\t\treturn\n+\t\t  get_last_value_validate (&XEXP (x1,\n+\t\t\t\t\t\t  x0 == XEXP (x1, 0) ? 1 : 0),\n+\t\t\t\t\t   insn, tick, replace);\n+\t    }\n+\n+\t  if (get_last_value_validate (&XEXP (x, i), insn, tick,\n+\t\t\t\t       replace) == 0)\n+\t    return 0;\n+\t}\n+      /* Don't bother with these.  They shouldn't occur anyway.  */\n+      else if (fmt[i] == 'E')\n+\treturn 0;\n+    }\n \n   /* If we haven't found a reason for it to be invalid, it is valid.  */\n   return 1;"}]}