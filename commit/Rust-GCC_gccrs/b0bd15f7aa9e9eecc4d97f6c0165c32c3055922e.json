{"sha": "b0bd15f7aa9e9eecc4d97f6c0165c32c3055922e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBiZDE1ZjdhYTllOWVlY2M0ZDk3ZjZjMDE2NWMzMmMzMDU1OTIyZQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2011-05-27T14:17:36Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2011-05-27T14:17:36Z"}, "message": "sched-int.h (struct _haifa_deps_insn_data): New members cond and reverse_cond.\n\n\t* sched-int.h (struct _haifa_deps_insn_data): New members cond\n\tand reverse_cond.\n\t(INSN_COND, INSN_REVERSE_COND): New macros.\n\t* sched-deps.c (deps_analyze_insn): Call sched_get_condition_with_rev\n\tonce.\n\t(sched_get_condition_with_rev): Cache the results, and look them up\n\tif possible.\n\t(sched_analyze_insn): Destroy INSN_COND of previous insns if they\n\tare clobbered by the current insn.\n\t* target.def (exposed_pipline): New sched data hook.\n\t* doc/tm.texi.in: TARGET_SCHED_EXPOSED_PIPELINE: Add hook.\n\t* doc/tm.texi: Regenerate.\n\nFrom-SVN: r174336", "tree": {"sha": "c11396d3bdf8e3a81e9606d61321ebfaf8526942", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c11396d3bdf8e3a81e9606d61321ebfaf8526942"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0bd15f7aa9e9eecc4d97f6c0165c32c3055922e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0bd15f7aa9e9eecc4d97f6c0165c32c3055922e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0bd15f7aa9e9eecc4d97f6c0165c32c3055922e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0bd15f7aa9e9eecc4d97f6c0165c32c3055922e/comments", "author": null, "committer": null, "parents": [{"sha": "f90aae43b8261a69582d438c98157dc1632b6685", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f90aae43b8261a69582d438c98157dc1632b6685", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f90aae43b8261a69582d438c98157dc1632b6685"}], "stats": {"total": 98, "additions": 94, "deletions": 4}, "files": [{"sha": "ecfab778f624e5329c676c696bfedcd091e2200b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0bd15f7aa9e9eecc4d97f6c0165c32c3055922e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0bd15f7aa9e9eecc4d97f6c0165c32c3055922e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b0bd15f7aa9e9eecc4d97f6c0165c32c3055922e", "patch": "@@ -1,9 +1,24 @@\n+2011-05-27  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* sched-int.h (struct _haifa_deps_insn_data): New members cond\n+\tand reverse_cond.\n+\t(INSN_COND, INSN_REVERSE_COND): New macros.\n+\t* sched-deps.c (deps_analyze_insn): Call sched_get_condition_with_rev\n+\tonce.\n+\t(sched_get_condition_with_rev): Cache the results, and look them up\n+\tif possible.\n+\t(sched_analyze_insn): Destroy INSN_COND of previous insns if they\n+\tare clobbered by the current insn.\n+\t* target.def (exposed_pipline): New sched data hook.\n+\t* doc/tm.texi.in: TARGET_SCHED_EXPOSED_PIPELINE: Add hook.\n+\t* doc/tm.texi: Regenerate.\n+\n 2011-05-27  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \tPR tree-optimization/49170\n \t* tree-ssa-math-opts.c (execute_cse_sincos):  Add checks for\n \tsincos or cexp.\n-\t\n+\n 2011-05-27  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/49189"}, {"sha": "6526898617ea37fe55b4c9e619a26b01b2aa7352", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0bd15f7aa9e9eecc4d97f6c0165c32c3055922e/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0bd15f7aa9e9eecc4d97f6c0165c32c3055922e/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=b0bd15f7aa9e9eecc4d97f6c0165c32c3055922e", "patch": "@@ -6794,6 +6794,12 @@ This hook is called by Haifa Scheduler.  It performs the operation specified\n in its second parameter.\n @end deftypefn\n \n+@deftypevr {Target Hook} bool TARGET_SCHED_EXPOSED_PIPELINE\n+True if the processor has an exposed pipeline, which means that not just\n+the order of instructions is important for correctness when scheduling, but\n+also the latencies of operations.\n+@end deftypevr\n+\n @node Sections\n @section Dividing the Output into Sections (Texts, Data, @dots{})\n @c the above section title is WAY too long.  maybe cut the part between"}, {"sha": "226e0bf0bea63abdf8d06c135c5b7494719677cd", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0bd15f7aa9e9eecc4d97f6c0165c32c3055922e/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0bd15f7aa9e9eecc4d97f6c0165c32c3055922e/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=b0bd15f7aa9e9eecc4d97f6c0165c32c3055922e", "patch": "@@ -6739,6 +6739,8 @@ This hook is called by Haifa Scheduler.  It performs the operation specified\n in its second parameter.\n @end deftypefn\n \n+@hook TARGET_SCHED_EXPOSED_PIPELINE\n+\n @node Sections\n @section Dividing the Output into Sections (Texts, Data, @dots{})\n @c the above section title is WAY too long.  maybe cut the part between"}, {"sha": "343d03ce96232b6c996f69ccb1bf2efefd2e1924", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 50, "deletions": 3, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0bd15f7aa9e9eecc4d97f6c0165c32c3055922e/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0bd15f7aa9e9eecc4d97f6c0165c32c3055922e/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=b0bd15f7aa9e9eecc4d97f6c0165c32c3055922e", "patch": "@@ -488,29 +488,49 @@ deps_may_trap_p (const_rtx mem)\n \n /* Find the condition under which INSN is executed.  If REV is not NULL,\n    it is set to TRUE when the returned comparison should be reversed\n-   to get the actual condition.  */\n+   to get the actual condition.\n+   We only do actual work the first time we come here for an insn; the\n+   results are cached in INSN_COND and INSN_REVERSE_COND.  */\n static rtx\n sched_get_condition_with_rev (const_rtx insn, bool *rev)\n {\n   rtx pat = PATTERN (insn);\n   rtx src;\n \n+  if (INSN_COND (insn) == const_true_rtx)\n+    return NULL_RTX;\n+\n+  if (INSN_COND (insn) != NULL_RTX)\n+    {\n+      if (rev)\n+\t*rev = INSN_REVERSE_COND (insn);\n+      return INSN_COND (insn);\n+    }\n+\n+  INSN_COND (insn) = const_true_rtx;\n+  INSN_REVERSE_COND (insn) = false;\n   if (pat == 0)\n     return 0;\n \n   if (rev)\n     *rev = false;\n \n   if (GET_CODE (pat) == COND_EXEC)\n-    return COND_EXEC_TEST (pat);\n+    {\n+      INSN_COND (insn) = COND_EXEC_TEST (pat);\n+      return COND_EXEC_TEST (pat);\n+    }\n \n   if (!any_condjump_p (insn) || !onlyjump_p (insn))\n     return 0;\n \n   src = SET_SRC (pc_set (insn));\n \n   if (XEXP (src, 2) == pc_rtx)\n-    return XEXP (src, 0);\n+    {\n+      INSN_COND (insn) = XEXP (src, 0);\n+      return XEXP (src, 0);\n+    }\n   else if (XEXP (src, 1) == pc_rtx)\n     {\n       rtx cond = XEXP (src, 0);\n@@ -521,6 +541,8 @@ sched_get_condition_with_rev (const_rtx insn, bool *rev)\n \n       if (rev)\n \t*rev = true;\n+      INSN_COND (insn) = cond;\n+      INSN_REVERSE_COND (insn) = true;\n       return cond;\n     }\n \n@@ -2818,6 +2840,8 @@ sched_analyze_insn (struct deps_desc *deps, rtx x, rtx insn)\n     }\n   else\n     {\n+      regset_head set_or_clobbered;\n+\n       EXECUTE_IF_SET_IN_REG_SET (reg_pending_uses, 0, i, rsi)\n \t{\n \t  struct deps_reg *reg_last = &deps->reg_last[i];\n@@ -2848,6 +2872,25 @@ sched_analyze_insn (struct deps_desc *deps, rtx x, rtx insn)\n \t      }\n \t  }\n \n+      if (targetm.sched.exposed_pipeline)\n+\t{\n+\t  INIT_REG_SET (&set_or_clobbered);\n+\t  bitmap_ior (&set_or_clobbered, reg_pending_clobbers,\n+\t\t      reg_pending_sets);\n+\t  EXECUTE_IF_SET_IN_REG_SET (&set_or_clobbered, 0, i, rsi)\n+\t    {\n+\t      struct deps_reg *reg_last = &deps->reg_last[i];\n+\t      rtx list;\n+\t      for (list = reg_last->uses; list; list = XEXP (list, 1))\n+\t\t{\n+\t\t  rtx other = XEXP (list, 0);\n+\t\t  if (INSN_COND (other) != const_true_rtx\n+\t\t      && refers_to_regno_p (i, i + 1, INSN_COND (other), NULL))\n+\t\t    INSN_COND (other) = const_true_rtx;\n+\t\t}\n+\t    }\n+\t}\n+\n       /* If the current insn is conditional, we can't free any\n \t of the lists.  */\n       if (sched_has_condition_p (insn))\n@@ -3222,6 +3265,10 @@ deps_analyze_insn (struct deps_desc *deps, rtx insn)\n   if (sched_deps_info->start_insn)\n     sched_deps_info->start_insn (insn);\n \n+  /* Record the condition for this insn.  */\n+  if (NONDEBUG_INSN_P (insn))\n+    sched_get_condition_with_rev (insn, NULL);\n+\n   if (NONJUMP_INSN_P (insn) || DEBUG_INSN_P (insn) || JUMP_P (insn))\n     {\n       /* Make each JUMP_INSN (but not a speculative check)"}, {"sha": "f310f8a0dfbfd0a3ef0b59bba0f2d0aca6a5afc7", "filename": "gcc/sched-int.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0bd15f7aa9e9eecc4d97f6c0165c32c3055922e/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0bd15f7aa9e9eecc4d97f6c0165c32c3055922e/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=b0bd15f7aa9e9eecc4d97f6c0165c32c3055922e", "patch": "@@ -679,6 +679,17 @@ struct _haifa_deps_insn_data\n      search in 'forw_deps'.  */\n   deps_list_t resolved_forw_deps;\n \n+  /* If the insn is conditional (either through COND_EXEC, or because\n+     it is a conditional branch), this records the condition.  NULL\n+     for insns that haven't been seen yet or don't have a condition;\n+     const_true_rtx to mark an insn without a condition, or with a\n+     condition that has been clobbered by a subsequent insn.  */\n+  rtx cond;\n+\n+  /* True if the condition in 'cond' should be reversed to get the actual\n+     condition.  */\n+  unsigned int reverse_cond : 1;\n+\n   /* Some insns (e.g. call) are not allowed to move across blocks.  */\n   unsigned int cant_move : 1;\n };\n@@ -838,6 +849,8 @@ extern VEC(haifa_deps_insn_data_def, heap) *h_d_i_d;\n #define INSN_RESOLVED_FORW_DEPS(INSN) (HDID (INSN)->resolved_forw_deps)\n #define INSN_HARD_BACK_DEPS(INSN) (HDID (INSN)->hard_back_deps)\n #define INSN_SPEC_BACK_DEPS(INSN) (HDID (INSN)->spec_back_deps)\n+#define INSN_COND(INSN)\t(HDID (INSN)->cond)\n+#define INSN_REVERSE_COND(INSN) (HDID (INSN)->reverse_cond)\n #define CANT_MOVE(INSN)\t(HDID (INSN)->cant_move)\n #define CANT_MOVE_BY_LUID(LUID)\t(VEC_index (haifa_deps_insn_data_def, h_d_i_d, \\\n                                             LUID)->cant_move)"}, {"sha": "ea283f374efd5be559057d8a61baee2ffa2e1e7c", "filename": "gcc/target.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0bd15f7aa9e9eecc4d97f6c0165c32c3055922e/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0bd15f7aa9e9eecc4d97f6c0165c32c3055922e/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=b0bd15f7aa9e9eecc4d97f6c0165c32c3055922e", "patch": "@@ -897,6 +897,13 @@ DEFHOOK\n bool, (rtx insn, int x),\n hook_bool_rtx_int_false)\n \n+DEFHOOKPOD\n+(exposed_pipeline,\n+\"True if the processor has an exposed pipeline, which means that not just\\n\\\n+the order of instructions is important for correctness when scheduling, but\\n\\\n+also the latencies of operations.\",\n+bool, false)\n+\n HOOK_VECTOR_END (sched)\n \n /* Functions relating to vectorization.  */"}]}