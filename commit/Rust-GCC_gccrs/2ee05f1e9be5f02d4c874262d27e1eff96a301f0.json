{"sha": "2ee05f1e9be5f02d4c874262d27e1eff96a301f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVlMDVmMWU5YmU1ZjAyZDRjODc0MjYyZDI3ZTFlZmY5NmEzMDFmMA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-07-01T13:18:49Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-07-01T13:18:49Z"}, "message": "fold-const.c (fold_comparison): Move X - Y CMP 0 -> X CMP Y...\n\n2015-07-01  Richard Biener  <rguenther@suse.de>\n\n\t* fold-const.c (fold_comparison): Move X - Y CMP 0 -> X CMP Y,\n\tX * C1 CMP 0 -> X CMP 0, X CMP X, ~X CMP ~Y -> Y CMP X and\n\t~X CMP C -> X CMP' ~C to ...\n\t* match.pd: ... patterns here.\n\nFrom-SVN: r225249", "tree": {"sha": "e048319d1f8fe53189f0de6f0710cba5e059e036", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e048319d1f8fe53189f0de6f0710cba5e059e036"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ee05f1e9be5f02d4c874262d27e1eff96a301f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ee05f1e9be5f02d4c874262d27e1eff96a301f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ee05f1e9be5f02d4c874262d27e1eff96a301f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ee05f1e9be5f02d4c874262d27e1eff96a301f0/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e09abfa408597ec644621b6318d735eb0a2d299d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e09abfa408597ec644621b6318d735eb0a2d299d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e09abfa408597ec644621b6318d735eb0a2d299d"}], "stats": {"total": 175, "additions": 70, "deletions": 105}, "files": [{"sha": "f53f3786b5742a248f6a674941d5c223730762f0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ee05f1e9be5f02d4c874262d27e1eff96a301f0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ee05f1e9be5f02d4c874262d27e1eff96a301f0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2ee05f1e9be5f02d4c874262d27e1eff96a301f0", "patch": "@@ -1,3 +1,10 @@\n+2015-07-01  Richard Biener  <rguenther@suse.de>\n+\n+\t* fold-const.c (fold_comparison): Move X - Y CMP 0 -> X CMP Y,\n+\tX * C1 CMP 0 -> X CMP 0, X CMP X, ~X CMP ~Y -> Y CMP X and\n+\t~X CMP C -> X CMP' ~C to ...\n+\t* match.pd: ... patterns here.\n+\n 2015-07-01  Nick Clifton  <nickc@redhat.com>\n \n \t* config/msp430/msp430.md (zero_extendhipsi2): Use MOVX.A to store"}, {"sha": "b5b0b71741d2e999c7f122577397d8fc163eda6b", "filename": "gcc/fold-const.c", "status": "modified", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ee05f1e9be5f02d4c874262d27e1eff96a301f0/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ee05f1e9be5f02d4c874262d27e1eff96a301f0/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=2ee05f1e9be5f02d4c874262d27e1eff96a301f0", "patch": "@@ -8783,23 +8783,6 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t}\n     }\n \n-  /* Transform comparisons of the form X - Y CMP 0 to X CMP Y.  */\n-  if (TREE_CODE (arg0) == MINUS_EXPR\n-      && equality_code\n-      && integer_zerop (arg1))\n-    {\n-      /* ??? The transformation is valid for the other operators if overflow\n-\t is undefined for the type, but performing it here badly interacts\n-\t with the transformation in fold_cond_expr_with_comparison which\n-\t attempts to synthetize ABS_EXPR.  */\n-      if (!equality_code)\n-\tfold_overflow_warning (\"assuming signed overflow does not occur \"\n-\t\t\t       \"when changing X - Y cmp 0 to X cmp Y\",\n-\t\t\t       WARN_STRICT_OVERFLOW_COMPARISON);\n-      return fold_build2_loc (loc, code, type, TREE_OPERAND (arg0, 0),\n-\t\t\t      TREE_OPERAND (arg0, 1));\n-    }\n-\n   /* For comparisons of pointers we can decompose it to a compile time\n      comparison of the base objects and the offsets into the object.\n      This requires at least one operand being an ADDR_EXPR or a\n@@ -9088,38 +9071,6 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t}\n     }\n \n-  /* Transform comparisons of the form X * C1 CMP 0 to X CMP 0 in the\n-     signed arithmetic case.  That form is created by the compiler\n-     often enough for folding it to be of value.  One example is in\n-     computing loop trip counts after Operator Strength Reduction.  */\n-  if (ANY_INTEGRAL_TYPE_P (TREE_TYPE (arg0))\n-      && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg0))\n-      && TREE_CODE (arg0) == MULT_EXPR\n-      && (TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n-          && !TREE_OVERFLOW (TREE_OPERAND (arg0, 1)))\n-      && integer_zerop (arg1))\n-    {\n-      tree const1 = TREE_OPERAND (arg0, 1);\n-      tree const2 = arg1;                       /* zero */\n-      tree variable1 = TREE_OPERAND (arg0, 0);\n-      enum tree_code cmp_code = code;\n-\n-      /* Handle unfolded multiplication by zero.  */\n-      if (integer_zerop (const1))\n-\treturn fold_build2_loc (loc, cmp_code, type, const1, const2);\n-\n-      fold_overflow_warning ((\"assuming signed overflow does not occur when \"\n-\t\t\t      \"eliminating multiplication in comparison \"\n-\t\t\t      \"with zero\"),\n-\t\t\t     WARN_STRICT_OVERFLOW_COMPARISON);\n-\n-      /* If const1 is negative we swap the sense of the comparison.  */\n-      if (tree_int_cst_sgn (const1) < 0)\n-        cmp_code = swap_tree_comparison (cmp_code);\n-\n-      return fold_build2_loc (loc, cmp_code, type, variable1, const2);\n-    }\n-\n   tem = maybe_canonicalize_comparison (loc, code, type, arg0, arg1);\n   if (tem)\n     return tem;\n@@ -9241,40 +9192,6 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \treturn tem;\n     }\n \n-  /* Simplify comparison of something with itself.  (For IEEE\n-     floating-point, we can only do some of these simplifications.)  */\n-  if (operand_equal_p (arg0, arg1, 0))\n-    {\n-      switch (code)\n-\t{\n-\tcase EQ_EXPR:\n-\t  if (! FLOAT_TYPE_P (TREE_TYPE (arg0))\n-\t      || ! HONOR_NANS (arg0))\n-\t    return constant_boolean_node (1, type);\n-\t  break;\n-\n-\tcase GE_EXPR:\n-\tcase LE_EXPR:\n-\t  if (! FLOAT_TYPE_P (TREE_TYPE (arg0))\n-\t      || ! HONOR_NANS (arg0))\n-\t    return constant_boolean_node (1, type);\n-\t  return fold_build2_loc (loc, EQ_EXPR, type, arg0, arg1);\n-\n-\tcase NE_EXPR:\n-\t  /* For NE, we can only do this simplification if integer\n-\t     or we don't honor IEEE floating point NaNs.  */\n-\t  if (FLOAT_TYPE_P (TREE_TYPE (arg0))\n-\t      && HONOR_NANS (arg0))\n-\t    break;\n-\t  /* ... fall through ...  */\n-\tcase GT_EXPR:\n-\tcase LT_EXPR:\n-\t  return constant_boolean_node (0, type);\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n-\n   /* If we are comparing an expression that just has comparisons\n      of two integer values, arithmetic expressions of those comparisons,\n      and constants, we can simplify it.  There are only three cases\n@@ -9392,28 +9309,6 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \treturn tem;\n     }\n \n-  /* Fold ~X op ~Y as Y op X.  */\n-  if (TREE_CODE (arg0) == BIT_NOT_EXPR\n-      && TREE_CODE (arg1) == BIT_NOT_EXPR)\n-    {\n-      tree cmp_type = TREE_TYPE (TREE_OPERAND (arg0, 0));\n-      return fold_build2_loc (loc, code, type,\n-\t\t\t  fold_convert_loc (loc, cmp_type,\n-\t\t\t\t\t    TREE_OPERAND (arg1, 0)),\n-\t\t\t  TREE_OPERAND (arg0, 0));\n-    }\n-\n-  /* Fold ~X op C as X op' ~C, where op' is the swapped comparison.  */\n-  if (TREE_CODE (arg0) == BIT_NOT_EXPR\n-      && (TREE_CODE (arg1) == INTEGER_CST || TREE_CODE (arg1) == VECTOR_CST))\n-    {\n-      tree cmp_type = TREE_TYPE (TREE_OPERAND (arg0, 0));\n-      return fold_build2_loc (loc, swap_tree_comparison (code), type,\n-\t\t\t  TREE_OPERAND (arg0, 0),\n-\t\t\t  fold_build1_loc (loc, BIT_NOT_EXPR, cmp_type,\n-\t\t\t\t       fold_convert_loc (loc, cmp_type, arg1)));\n-    }\n-\n   return NULL_TREE;\n }\n "}, {"sha": "6c138390acab094ab3b331bd8e290e3760aeeee2", "filename": "gcc/match.pd", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ee05f1e9be5f02d4c874262d27e1eff96a301f0/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ee05f1e9be5f02d4c874262d27e1eff96a301f0/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=2ee05f1e9be5f02d4c874262d27e1eff96a301f0", "patch": "@@ -1262,6 +1262,7 @@ along with GCC; see the file COPYING3.  If not see\n           == TYPE_MODE (TREE_TYPE (TREE_TYPE (@0)))))\n   (plus @3 (view_convert @0))))\n \n+\n /* Simplifications of comparisons.  */\n \n /* We can simplify a logical negation of a comparison to the\n@@ -1299,6 +1300,68 @@ along with GCC; see the file COPYING3.  If not see\n    (if (ic == ncmp)\n     (ncmp @0 @1)))))\n \n+/* Transform comparisons of the form X - Y CMP 0 to X CMP Y.\n+   ??? The transformation is valid for the other operators if overflow\n+   is undefined for the type, but performing it here badly interacts\n+   with the transformation in fold_cond_expr_with_comparison which\n+   attempts to synthetize ABS_EXPR.  */\n+(for cmp (eq ne)\n+ (simplify\n+  (cmp (minus @0 @1) integer_zerop)\n+  (cmp @0 @1)))\n+\n+/* Transform comparisons of the form X * C1 CMP 0 to X CMP 0 in the\n+   signed arithmetic case.  That form is created by the compiler\n+   often enough for folding it to be of value.  One example is in\n+   computing loop trip counts after Operator Strength Reduction.  */\n+(for cmp (tcc_comparison)\n+     scmp (swapped_tcc_comparison)\n+ (simplify\n+  (cmp (mult @0 INTEGER_CST@1) integer_zerop@2)\n+  /* Handle unfolded multiplication by zero.  */\n+  (if (integer_zerop (@1))\n+   (cmp @1 @2))\n+  (if (ANY_INTEGRAL_TYPE_P (TREE_TYPE (@0))\n+       && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (@0)))\n+   /* If @1 is negative we swap the sense of the comparison.  */\n+   (if (tree_int_cst_sgn (@1) < 0)\n+    (scmp @0 @2))\n+   (cmp @0 @2))))\n+ \n+/* Simplify comparison of something with itself.  For IEEE\n+   floating-point, we can only do some of these simplifications.  */\n+(simplify\n+ (eq @0 @0)\n+ (if (! FLOAT_TYPE_P (TREE_TYPE (@0))\n+      || ! HONOR_NANS (TYPE_MODE (TREE_TYPE (@0))))\n+  { constant_boolean_node (true, type); }))\n+(for cmp (ge le)\n+ (simplify\n+  (cmp @0 @0)\n+  (eq @0 @0)))\n+(for cmp (ne gt lt)\n+ (simplify\n+  (cmp @0 @0)\n+  (if (cmp != NE_EXPR\n+       || ! FLOAT_TYPE_P (TREE_TYPE (@0))\n+       || ! HONOR_NANS (TYPE_MODE (TREE_TYPE (@0))))\n+   { constant_boolean_node (false, type); })))\n+\n+/* Fold ~X op ~Y as Y op X.  */\n+(for cmp (tcc_comparison)\n+ (simplify\n+  (cmp (bit_not @0) (bit_not @1))\n+  (cmp @1 @0)))\n+\n+/* Fold ~X op C as X op' ~C, where op' is the swapped comparison.  */\n+(for cmp (tcc_comparison)\n+     scmp (swapped_tcc_comparison)\n+ (simplify\n+  (cmp (bit_not @0) CONSTANT_CLASS_P@1)\n+  (if (TREE_CODE (@1) == INTEGER_CST || TREE_CODE (@1) == VECTOR_CST)\n+   (scmp @0 (bit_not @1)))))\n+\n+\n /* Unordered tests if either argument is a NaN.  */\n (simplify\n  (bit_ior (unordered @0 @0) (unordered @1 @1))"}]}