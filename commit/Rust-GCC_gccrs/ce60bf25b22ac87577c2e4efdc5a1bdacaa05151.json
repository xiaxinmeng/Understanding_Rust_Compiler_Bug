{"sha": "ce60bf25b22ac87577c2e4efdc5a1bdacaa05151", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2U2MGJmMjViMjJhYzg3NTc3YzJlNGVmZGM1YTFiZGFjYWEwNTE1MQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@multimania.com", "date": "2002-05-30T21:33:32Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-05-30T21:33:32Z"}, "message": "expmed.c (const_mult_add_overflow_p): New.\n\n        * expmed.c (const_mult_add_overflow_p): New.\n        * expr.h: Declare it.\n        * loop.c (maybe_eliminate_biv_1) [COMPARE]: Use it.\n        Don't eliminate the biv if the giv has a constant multiplier and\n        the rhs argument of the comparison does satisfy the predicate.\n        Use expand_mult_add to compute the replacement constant.\n\nFrom-SVN: r54075", "tree": {"sha": "dd32c83a5ab688b1765c9c952a826e5e04b594de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd32c83a5ab688b1765c9c952a826e5e04b594de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce60bf25b22ac87577c2e4efdc5a1bdacaa05151", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce60bf25b22ac87577c2e4efdc5a1bdacaa05151", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce60bf25b22ac87577c2e4efdc5a1bdacaa05151", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce60bf25b22ac87577c2e4efdc5a1bdacaa05151/comments", "author": null, "committer": null, "parents": [{"sha": "d18b1ed89ece9698c8e3d0a90534bbf9fe103951", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d18b1ed89ece9698c8e3d0a90534bbf9fe103951", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d18b1ed89ece9698c8e3d0a90534bbf9fe103951"}], "stats": {"total": 75, "additions": 69, "deletions": 6}, "files": [{"sha": "07443b6363b56d6777b44f609b4fecbef5bbd8f7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce60bf25b22ac87577c2e4efdc5a1bdacaa05151/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce60bf25b22ac87577c2e4efdc5a1bdacaa05151/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ce60bf25b22ac87577c2e4efdc5a1bdacaa05151", "patch": "@@ -1,3 +1,12 @@\n+2002-05-30  Eric Botcazou  <ebotcazou@multimania.com>\n+\n+\t* expmed.c (const_mult_add_overflow_p): New.\n+\t* expr.h: Declare it.\n+\t* loop.c (maybe_eliminate_biv_1) [COMPARE]: Use it.\n+\tDon't eliminate the biv if the giv has a constant multiplier and\n+\tthe rhs argument of the comparison does satisfy the predicate.\n+\tUse expand_mult_add to compute the replacement constant.\n+\n 2002-05-30  Osku Salerma  <osku@iki.fi>\n \n \t* c-common.c (c_common_attribute_table): Add \"may_alias\" entry."}, {"sha": "9419681dcae1c735fd7f82a5553ee01fd7da4b33", "filename": "gcc/expmed.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce60bf25b22ac87577c2e4efdc5a1bdacaa05151/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce60bf25b22ac87577c2e4efdc5a1bdacaa05151/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=ce60bf25b22ac87577c2e4efdc5a1bdacaa05151", "patch": "@@ -4156,6 +4156,44 @@ make_tree (type, x)\n     }\n }\n \n+/* Check whether the multiplication X * MULT + ADD overflows.\n+   X, MULT and ADD must be CONST_*.\n+   MODE is the machine mode for the computation.\n+   X and MULT must have mode MODE.  ADD may have a different mode.\n+   So can X (defaults to same as MODE).\n+   UNSIGNEDP is non-zero to do unsigned multiplication.  */\n+\n+bool\n+const_mult_add_overflow_p (x, mult, add, mode, unsignedp)\n+     rtx x, mult, add;\n+     enum machine_mode mode;\n+     int unsignedp;\n+{\n+  tree type, mult_type, add_type, result;\n+\n+  type = (*lang_hooks.types.type_for_mode) (mode, unsignedp);\n+\n+  /* In order to get a proper overflow indication from an unsigned\n+     type, we have to pretend that it's a sizetype.  */\n+  mult_type = type;\n+  if (unsignedp)\n+    {\n+      mult_type = copy_node (type);\n+      TYPE_IS_SIZETYPE (mult_type) = 1;\n+    }\n+\n+  add_type = (GET_MODE (add) == VOIDmode ? mult_type\n+\t      : (*lang_hooks.types.type_for_mode) (GET_MODE (add), unsignedp));\n+\n+  result = fold (build (PLUS_EXPR, mult_type,\n+\t\t\tfold (build (MULT_EXPR, mult_type,\n+\t\t\t\t     make_tree (mult_type, x),\n+\t\t\t\t     make_tree (mult_type, mult))),\n+\t\t\tmake_tree (add_type, add)));\n+\n+  return TREE_CONSTANT_OVERFLOW (result);\n+}\n+\n /* Return an rtx representing the value of X * MULT + ADD.\n    TARGET is a suggestion for where to store the result (an rtx).\n    MODE is the machine mode for the computation."}, {"sha": "fa51a8a3191ec9021faed0d46cbabcf6bad75eaa", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce60bf25b22ac87577c2e4efdc5a1bdacaa05151/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce60bf25b22ac87577c2e4efdc5a1bdacaa05151/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=ce60bf25b22ac87577c2e4efdc5a1bdacaa05151", "patch": "@@ -758,6 +758,7 @@ extern rtx extract_bit_field PARAMS ((rtx, unsigned HOST_WIDE_INT,\n \t\t\t\t      enum machine_mode, enum machine_mode,\n \t\t\t\t      HOST_WIDE_INT));\n extern rtx expand_mult PARAMS ((enum machine_mode, rtx, rtx, rtx, int));\n+extern bool const_mult_add_overflow_p PARAMS ((rtx, rtx, rtx, enum machine_mode, int));\n extern rtx expand_mult_add PARAMS ((rtx, rtx, rtx, rtx,enum machine_mode, int));\n extern rtx expand_mult_highpart_adjust PARAMS ((enum machine_mode, rtx, rtx, rtx, rtx, int));\n "}, {"sha": "20c5f1dab0ab4cf47df1c06db25a91566a457a77", "filename": "gcc/loop.c", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce60bf25b22ac87577c2e4efdc5a1bdacaa05151/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce60bf25b22ac87577c2e4efdc5a1bdacaa05151/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=ce60bf25b22ac87577c2e4efdc5a1bdacaa05151", "patch": "@@ -8863,6 +8863,22 @@ maybe_eliminate_biv_1 (loop, x, insn, bl, eliminate_p, where_bb, where_insn)\n \t\tif (! biv_elimination_giv_has_0_offset (bl->biv, v, insn))\n \t\t  continue;\n \n+\t\t/* Don't eliminate if the linear combination that makes up\n+\t\t   the giv overflows when it is applied to ARG.  */\n+\t\tif (GET_CODE (arg) == CONST_INT)\n+\t\t  {\n+\t\t    rtx add_val;\n+\n+\t\t    if (GET_CODE (v->add_val) == CONST_INT)\n+\t\t      add_val = v->add_val;\n+\t\t    else\n+\t\t      add_val = const0_rtx;\n+\n+\t\t    if (const_mult_add_overflow_p (arg, v->mult_val,\n+\t\t\t\t\t\t   add_val, mode, 1))\n+\t\t      continue;\n+\t\t  }\n+\n \t\tif (! eliminate_p)\n \t\t  return 1;\n \n@@ -8873,13 +8889,10 @@ maybe_eliminate_biv_1 (loop, x, insn, bl, eliminate_p, where_bb, where_insn)\n \t\t   the derived constant can be directly placed in the COMPARE,\n \t\t   do so.  */\n \t\tif (GET_CODE (arg) == CONST_INT\n-\t\t    && GET_CODE (v->mult_val) == CONST_INT\n \t\t    && GET_CODE (v->add_val) == CONST_INT)\n \t\t  {\n-\t\t    validate_change (insn, &XEXP (x, arg_operand),\n-\t\t\t\t     GEN_INT (INTVAL (arg)\n-\t\t\t\t\t      * INTVAL (v->mult_val)\n-\t\t\t\t\t      + INTVAL (v->add_val)), 1);\n+\t\t    tem = expand_mult_add (arg, NULL_RTX, v->mult_val,\n+\t\t\t\t\t   v->add_val, mode, 1);\n \t\t  }\n \t\telse\n \t\t  {\n@@ -8888,8 +8901,10 @@ maybe_eliminate_biv_1 (loop, x, insn, bl, eliminate_p, where_bb, where_insn)\n \t\t    loop_iv_add_mult_emit_before (loop, arg,\n \t\t\t\t\t\t  v->mult_val, v->add_val,\n \t\t\t\t\t\t  tem, where_bb, where_insn);\n-\t\t    validate_change (insn, &XEXP (x, arg_operand), tem, 1);\n \t\t  }\n+\n+\t\tvalidate_change (insn, &XEXP (x, arg_operand), tem, 1);\n+\n \t\tif (apply_change_group ())\n \t\t  return 1;\n \t      }"}]}