{"sha": "dcc229e5a1a7425479e0738cb9e70e8e8a2132da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGNjMjI5ZTVhMWE3NDI1NDc5ZTA3MzhjYjllNzBlOGU4YTIxMzJkYQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2002-03-14T18:17:18Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2002-03-14T18:17:18Z"}, "message": "cpphash.h (struct lexer_state): Remove line_extension member.\n\n\t* cpphash.h (struct lexer_state): Remove line_extension member.\n\t* cpplib.c (dequote_string, do_linemarker): New functions.\n\t(linemarker_dir): New data object.\n\t(DIRECTIVE_TABLE): No longer need to interpret #line in\n\tpreprocessed source.  Delete obsolete comment about return\n\tvalues of handlers.\n\t(end_directive, directive_diagnostics, _cpp_handle_directive):\n\tDon't muck with line_extension.\n\t(directive_diagnostics): No need to issue warnings for\n\tlinemarkers here.\n\t(_cpp_handle_directive): Issue warnings for linemarkers here,\n\twhen appropriate.  Dispatch linemarkers to do_linemarker, not\n\tdo_line.\n\t(do_line): Code to handle linemarkers split out to do_linemarker.\n\tConvert escape sequences in filename argument, both places.\n\n\t* cppmacro.c (quote_string): Rename cpp_quote_string and\n\texport.  All callers changed.\n\t* cpplib.h (cpp_quote_string): Prototype.\n\t* cppmain.c (print_line): Call cpp_quote_string on to_file\n\tbefore printing it.\n\n\t* doc/cpp.texi: Document that escapes are now interpreted in\n\t#line and in linemarkers, and that non-printing characters are\n\tconverted to octal escapes when linemarkers are generated.\n\nFrom-SVN: r50779", "tree": {"sha": "226bd8664bc5db227069d75069a5198366adb680", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/226bd8664bc5db227069d75069a5198366adb680"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dcc229e5a1a7425479e0738cb9e70e8e8a2132da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcc229e5a1a7425479e0738cb9e70e8e8a2132da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcc229e5a1a7425479e0738cb9e70e8e8a2132da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcc229e5a1a7425479e0738cb9e70e8e8a2132da/comments", "author": null, "committer": null, "parents": [{"sha": "83a4940733758aa5e49b35ca6cef45f7a5958bf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83a4940733758aa5e49b35ca6cef45f7a5958bf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83a4940733758aa5e49b35ca6cef45f7a5958bf4"}], "stats": {"total": 290, "additions": 193, "deletions": 97}, "files": [{"sha": "03de93f9644e42c55d9c25712669929d611f814c", "filename": "gcc/cpphash.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcc229e5a1a7425479e0738cb9e70e8e8a2132da/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcc229e5a1a7425479e0738cb9e70e8e8a2132da/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=dcc229e5a1a7425479e0738cb9e70e8e8a2132da", "patch": "@@ -152,9 +152,6 @@ struct lexer_state\n \n   /* Nonzero when parsing arguments to a function-like macro.  */\n   unsigned char parsing_args;\n-\n-  /* Nonzero when in a # NUMBER directive.  */\n-  unsigned char line_extension;\n };\n \n /* Special nodes - identifiers with predefined significance.  */"}, {"sha": "d8e34330e281935b98a15dcea56e31cdab0bbbe0", "filename": "gcc/cpplib.c", "status": "modified", "additions": 154, "deletions": 84, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcc229e5a1a7425479e0738cb9e70e8e8a2132da/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcc229e5a1a7425479e0738cb9e70e8e8a2132da/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=dcc229e5a1a7425479e0738cb9e70e8e8a2132da", "patch": "@@ -103,6 +103,8 @@ static const cpp_token *parse_include PARAMS ((cpp_reader *));\n static void push_conditional\tPARAMS ((cpp_reader *, int, int,\n \t\t\t\t\t const cpp_hashnode *));\n static unsigned int read_flag\tPARAMS ((cpp_reader *, unsigned int));\n+static U_CHAR *dequote_string\tPARAMS ((cpp_reader *, const U_CHAR *,\n+\t\t\t\t\t unsigned int));\n static int  strtoul_for_line\tPARAMS ((const U_CHAR *, unsigned int,\n \t\t\t\t\t unsigned long *));\n static void do_diagnostic\tPARAMS ((cpp_reader *, enum error_type, int));\n@@ -117,6 +119,7 @@ static void do_pragma_once\tPARAMS ((cpp_reader *));\n static void do_pragma_poison\tPARAMS ((cpp_reader *));\n static void do_pragma_system_header\tPARAMS ((cpp_reader *));\n static void do_pragma_dependency\tPARAMS ((cpp_reader *));\n+static void do_linemarker\t\tPARAMS ((cpp_reader *));\n static const cpp_token *get_token_no_padding PARAMS ((cpp_reader *));\n static const cpp_token *get__Pragma_string PARAMS ((cpp_reader *));\n static void destringize_and_run PARAMS ((cpp_reader *, const cpp_string *));\n@@ -145,7 +148,7 @@ D(if,\t\tT_IF,\t\tKANDR,     COND | IF_COND) /*  18162 */ \\\n D(else,\t\tT_ELSE,\t\tKANDR,     COND)\t   /*   9863 */ \\\n D(ifndef,\tT_IFNDEF,\tKANDR,     COND | IF_COND) /*   9675 */ \\\n D(undef,\tT_UNDEF,\tKANDR,     IN_I)\t   /*   4837 */ \\\n-D(line,\t\tT_LINE,\t\tKANDR,     IN_I)\t   /*   2465 */ \\\n+D(line,\t\tT_LINE,\t\tKANDR,     0)\t\t   /*   2465 */ \\\n D(elif,\t\tT_ELIF,\t\tSTDC89,    COND)\t   /*    610 */ \\\n D(error,\tT_ERROR,\tSTDC89,    0)\t\t   /*    475 */ \\\n D(pragma,\tT_PRAGMA,\tSTDC89,    IN_I)\t   /*    195 */ \\\n@@ -167,10 +170,6 @@ SCCS_ENTRY\t\t\t\t\t\t   /* 0 SVR4? */\n /* Use the table to generate a series of prototypes, an enum for the\n    directive names, and an array of directive handlers.  */\n \n-/* The directive-processing functions are declared to return int\n-   instead of void, because some old compilers have trouble with\n-   pointers to functions returning void.  */\n-\n /* Don't invoke CONCAT2 with any whitespace or K&R cc will fail.  */\n #define D(name, t, o, f) static void CONCAT2(do_,name) PARAMS ((cpp_reader *));\n DIRECTIVE_TABLE\n@@ -195,6 +194,14 @@ DIRECTIVE_TABLE\n #undef D\n #undef DIRECTIVE_TABLE\n \n+/* Wrapper struct directive for linemarkers.\n+   The origin is more or less true - the original K+R cpp\n+   did use this notation in its preprocessed output.  */\n+static const directive linemarker_dir =\n+{\n+  do_linemarker, U\"#\", 1, KANDR, IN_I\n+};\n+\n #define SEEN_EOL() (pfile->cur_token[-1].type == CPP_EOF)\n \n /* Skip any remaining tokens in a directive.  */\n@@ -256,7 +263,6 @@ end_directive (pfile, skip_line)\n   pfile->state.save_comments = ! CPP_OPTION (pfile, discard_comments);\n   pfile->state.in_directive = 0;\n   pfile->state.angled_headers = 0;\n-  pfile->state.line_extension = 0;\n   pfile->directive = 0;\n }\n \n@@ -268,39 +274,30 @@ directive_diagnostics (pfile, dir, indented)\n      const directive *dir;\n      int indented;\n {\n-  if (pfile->state.line_extension)\n+  /* Issue -pedantic warnings for extensions.  */\n+  if (CPP_PEDANTIC (pfile)\n+      && ! pfile->state.skipping\n+      && dir->origin == EXTENSION)\n+    cpp_pedwarn (pfile, \"#%s is a GCC extension\", dir->name);\n+\n+  /* Traditionally, a directive is ignored unless its # is in\n+     column 1.  Therefore in code intended to work with K+R\n+     compilers, directives added by C89 must have their #\n+     indented, and directives present in traditional C must not.\n+     This is true even of directives in skipped conditional\n+     blocks.  #elif cannot be used at all.  */\n+  if (CPP_WTRADITIONAL (pfile))\n     {\n-      if (CPP_PEDANTIC (pfile)\n-\t  && ! pfile->state.skipping)\n-\tcpp_pedwarn (pfile, \"style of line directive is a GCC extension\");\n-    }\n-  else\n-    {\n-      /* Issue -pedantic warnings for extensions.  */\n-      if (CPP_PEDANTIC (pfile)\n-\t  && ! pfile->state.skipping\n-\t  && dir->origin == EXTENSION)\n-\tcpp_pedwarn (pfile, \"#%s is a GCC extension\", dir->name);\n-\n-      /* Traditionally, a directive is ignored unless its # is in\n-\t column 1.  Therefore in code intended to work with K+R\n-\t compilers, directives added by C89 must have their #\n-\t indented, and directives present in traditional C must not.\n-\t This is true even of directives in skipped conditional\n-\t blocks.  #elif cannot be used at all.  */\n-      if (CPP_WTRADITIONAL (pfile))\n-\t{\n-\t  if (dir == &dtable[T_ELIF])\n-\t    cpp_warning (pfile, \"suggest not using #elif in traditional C\");\n-\t  else if (indented && dir->origin == KANDR)\n-\t    cpp_warning (pfile,\n-\t\t\t \"traditional C ignores #%s with the # indented\",\n-\t\t\t dir->name);\n-\t  else if (!indented && dir->origin != KANDR)\n-\t    cpp_warning (pfile,\n-\t\t \"suggest hiding #%s from traditional C with an indented #\",\n-\t\t\t dir->name);\n-\t}\n+      if (dir == &dtable[T_ELIF])\n+\tcpp_warning (pfile, \"suggest not using #elif in traditional C\");\n+      else if (indented && dir->origin == KANDR)\n+\tcpp_warning (pfile,\n+\t\t     \"traditional C ignores #%s with the # indented\",\n+\t\t     dir->name);\n+      else if (!indented && dir->origin != KANDR)\n+\tcpp_warning (pfile,\n+\t\t     \"suggest hiding #%s from traditional C with an indented #\",\n+\t\t     dir->name);\n     }\n }\n \n@@ -339,8 +336,10 @@ _cpp_handle_directive (pfile, indented)\n      assembler code.  */\n   else if (dname->type == CPP_NUMBER && CPP_OPTION (pfile, lang) != CLK_ASM)\n     {\n-      dir = &dtable[T_LINE];\n-      pfile->state.line_extension = 1;\n+      dir = &linemarker_dir;\n+      if (CPP_PEDANTIC (pfile) && ! CPP_OPTION (pfile, preprocessed)\n+\t  && ! pfile->state.skipping)\n+\tcpp_pedwarn (pfile, \"style of line directive is a GCC extension\");\n     }\n \n   if (dir)\n@@ -669,9 +668,10 @@ do_include_next (pfile)\n   do_include_common (pfile, IT_INCLUDE_NEXT);\n }\n \n-/* Subroutine of do_line.  Read possible flags after file name.  LAST\n-   is the last flag seen; 0 if this is the first flag. Return the flag\n-   if it is valid, 0 at the end of the directive. Otherwise complain.  */\n+/* Subroutine of do_linemarker.  Read possible flags after file name.\n+   LAST is the last flag seen; 0 if this is the first flag. Return the\n+   flag if it is valid, 0 at the end of the directive. Otherwise\n+   complain.  */\n static unsigned int\n read_flag (pfile, last)\n      cpp_reader *pfile;\n@@ -695,9 +695,43 @@ read_flag (pfile, last)\n   return 0;\n }\n \n-/* Another subroutine of do_line.  Convert a number in STR, of length\n-   LEN, to binary; store it in NUMP, and return 0 if the number was\n-   well-formed, 1 if not.  Temporary, hopefully.  */\n+/* Subroutine of do_line and do_linemarker.  Returns a version of STR\n+   which has a NUL terminator and all escape sequences converted to\n+   their equivalents.  Temporary, hopefully.  */\n+static U_CHAR *\n+dequote_string (pfile, str, len)\n+     cpp_reader *pfile;\n+     const U_CHAR *str;\n+     unsigned int len;\n+{\n+  U_CHAR *result = _cpp_unaligned_alloc (pfile, len + 1);\n+  U_CHAR *dst = result;\n+  const U_CHAR *limit = str + len;\n+  unsigned int c;\n+  unsigned HOST_WIDE_INT mask;\n+\n+  /* We need the mask to match the host's 'unsigned char', not the\n+     target's.  */\n+  if (CHAR_BIT < HOST_BITS_PER_WIDE_INT)\n+    mask = ((unsigned HOST_WIDE_INT) 1 << CHAR_BIT) - 1;\n+  else\n+    mask = ~(unsigned HOST_WIDE_INT)0;\n+  \n+  while (str < limit)\n+    {\n+      c = *str++;\n+      if (c != '\\\\')\n+\t*dst++ = c;\n+      else\n+\t*dst++ = cpp_parse_escape (pfile, (const U_CHAR **)&str, limit, mask);\n+    }\n+  *dst++ = '\\0';\n+  return result;\n+}\n+\n+/* Subroutine of do_line and do_linemarker.  Convert a number in STR,\n+   of length LEN, to binary; store it in NUMP, and return 0 if the\n+   number was well-formed, 1 if not.  Temporary, hopefully.  */\n static int\n strtoul_for_line (str, len, nump)\n      const U_CHAR *str;\n@@ -719,25 +753,18 @@ strtoul_for_line (str, len, nump)\n }\n \n /* Interpret #line command.\n-   Note that the filename string (if any) is treated as if it were an\n-   include filename.  That means no escape handling.  */\n+   Note that the filename string (if any) is a true string constant\n+   (escapes are interpreted), unlike in #line.  */\n static void\n do_line (pfile)\n      cpp_reader *pfile;\n {\n   const cpp_token *token;\n   const char *new_file = pfile->map->to_file;\n   unsigned long new_lineno;\n-  unsigned int cap, new_sysp = pfile->map->sysp;\n-  enum lc_reason reason = LC_RENAME;\n \n   /* C99 raised the minimum limit on #line numbers.  */\n-  cap = CPP_OPTION (pfile, c99) ? 2147483647 : 32767;\n-\n-  /* Putting this in _cpp_handle_directive risks two calls to\n-     _cpp_backup_tokens in some circumstances, which can segfault.  */\n-  if (pfile->state.line_extension)\n-    _cpp_backup_tokens (pfile, 1);\n+  unsigned int cap = CPP_OPTION (pfile, c99) ? 2147483647 : 32767;\n \n   /* #line commands expand macros.  */\n   token = cpp_get_token (pfile);\n@@ -750,42 +777,85 @@ do_line (pfile)\n       return;\n     }      \n \n-  if (CPP_PEDANTIC (pfile) && ! pfile->state.line_extension\n-      && (new_lineno == 0 || new_lineno > cap))\n+  if (CPP_PEDANTIC (pfile) && (new_lineno == 0 || new_lineno > cap))\n     cpp_pedwarn (pfile, \"line number out of range\");\n \n   token = cpp_get_token (pfile);\n   if (token->type == CPP_STRING)\n     {\n-      new_file = (const char *) token->val.str.text;\n+      new_file = (const char *) dequote_string (pfile, token->val.str.text,\n+\t\t\t\t\t\ttoken->val.str.len);\n+      check_eol (pfile);\n+    }\n+  else if (token->type != CPP_EOF)\n+    {\n+      cpp_error (pfile, \"\\\"%s\\\" is not a valid filename\",\n+\t\t cpp_token_as_text (pfile, token));\n+      return;\n+    }\n \n-      /* Only accept flags for the # 55 form.  */\n-      if (pfile->state.line_extension)\n-\t{\n-\t  int flag;\n+  skip_rest_of_line (pfile);\n+  _cpp_do_file_change (pfile, LC_RENAME, new_file, new_lineno,\n+\t\t       pfile->map->sysp);\n+}\n \n-\t  new_sysp = 0;\n-\t  flag = read_flag (pfile, 0);\n-\t  if (flag == 1)\n-\t    {\n-\t      reason = LC_ENTER;\n-\t      /* Fake an include for cpp_included ().  */\n-\t      _cpp_fake_include (pfile, new_file);\n-\t      flag = read_flag (pfile, flag);\n-\t    }\n-\t  else if (flag == 2)\n-\t    {\n-\t      reason = LC_LEAVE;\n-\t      flag = read_flag (pfile, flag);\n-\t    }\n-\t  if (flag == 3)\n-\t    {\n-\t      new_sysp = 1;\n-\t      flag = read_flag (pfile, flag);\n-\t      if (flag == 4)\n-\t\tnew_sysp = 2;\n-\t    }\n+/* Interpret the # 44 \"file\" [flags] notation, which has slightly\n+   different syntax and semantics from #line:  Flags are allowed,\n+   and we never complain about the line number being too big.  */\n+static void\n+do_linemarker (pfile)\n+     cpp_reader *pfile;\n+{\n+  const cpp_token *token;\n+  const char *new_file = pfile->map->to_file;\n+  unsigned long new_lineno;\n+  unsigned int new_sysp = pfile->map->sysp;\n+  enum lc_reason reason = LC_RENAME;\n+  int flag;\n+\n+  /* Back up so we can get the number again.  Putting this in\n+     _cpp_handle_directive risks two calls to _cpp_backup_tokens in\n+     some circumstances, which can segfault.  */\n+  _cpp_backup_tokens (pfile, 1);\n+\n+  /* #line commands expand macros.  */\n+  token = cpp_get_token (pfile);\n+  if (token->type != CPP_NUMBER\n+      || strtoul_for_line (token->val.str.text, token->val.str.len,\n+\t\t\t   &new_lineno))\n+    {\n+      cpp_error (pfile, \"\\\"%s\\\" after # is not a positive integer\",\n+\t\t cpp_token_as_text (pfile, token));\n+      return;\n+    }      \n+\n+  token = cpp_get_token (pfile);\n+  if (token->type == CPP_STRING)\n+    {\n+      new_file = (const char *) dequote_string (pfile, token->val.str.text,\n+\t\t\t\t\t\ttoken->val.str.len);\n+      new_sysp = 0;\n+      flag = read_flag (pfile, 0);\n+      if (flag == 1)\n+\t{\n+\t  reason = LC_ENTER;\n+\t  /* Fake an include for cpp_included ().  */\n+\t  _cpp_fake_include (pfile, new_file);\n+\t  flag = read_flag (pfile, flag);\n \t}\n+      else if (flag == 2)\n+\t{\n+\t  reason = LC_LEAVE;\n+\t  flag = read_flag (pfile, flag);\n+\t}\n+      if (flag == 3)\n+\t{\n+\t  new_sysp = 1;\n+\t  flag = read_flag (pfile, flag);\n+\t  if (flag == 4)\n+\t    new_sysp = 2;\n+\t}\n+\n       check_eol (pfile);\n     }\n   else if (token->type != CPP_EOF)"}, {"sha": "191649ccfd651f95df1105629a3f3799aaff3432", "filename": "gcc/cpplib.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcc229e5a1a7425479e0738cb9e70e8e8a2132da/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcc229e5a1a7425479e0738cb9e70e8e8a2132da/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=dcc229e5a1a7425479e0738cb9e70e8e8a2132da", "patch": "@@ -592,6 +592,9 @@ extern void cpp_forall_identifiers\tPARAMS ((cpp_reader *,\n /* In cppmacro.c */\n extern void cpp_scan_nooutput\t\tPARAMS ((cpp_reader *));\n extern int  cpp_sys_macro_p\t\tPARAMS ((cpp_reader *));\n+extern unsigned char *cpp_quote_string\tPARAMS ((unsigned char *,\n+\t\t\t\t\t\t const unsigned char *,\n+\t\t\t\t\t\t unsigned int));\n \n /* In cppfiles.c */\n extern int cpp_included\tPARAMS ((cpp_reader *, const char *));"}, {"sha": "c5bb71e795479a0253b1218bd8f7044b06481956", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcc229e5a1a7425479e0738cb9e70e8e8a2132da/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcc229e5a1a7425479e0738cb9e70e8e8a2132da/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=dcc229e5a1a7425479e0738cb9e70e8e8a2132da", "patch": "@@ -64,9 +64,6 @@ static cpp_context *next_context PARAMS ((cpp_reader *));\n static const cpp_token *padding_token\n   PARAMS ((cpp_reader *, const cpp_token *));\n static void expand_arg PARAMS ((cpp_reader *, macro_arg *));\n-static unsigned char *quote_string PARAMS ((unsigned char *,\n-\t\t\t\t\t    const unsigned char *,\n-\t\t\t\t\t    unsigned int));\n static const cpp_token *new_string_token PARAMS ((cpp_reader *, U_CHAR *,\n \t\t\t\t\t\t  unsigned int));\n static const cpp_token *new_number_token PARAMS ((cpp_reader *, unsigned int));\n@@ -164,7 +161,7 @@ builtin_macro (pfile, node)\n \tname = map->to_file;\n \tlen = strlen (name);\n \tbuf = _cpp_unaligned_alloc (pfile, len * 4 + 1);\n-\tlen = quote_string (buf, (const unsigned char *) name, len) - buf;\n+\tlen = cpp_quote_string (buf, (const unsigned char *) name, len) - buf;\n \n \tresult = new_string_token (pfile, buf, len);\n       }\n@@ -244,9 +241,10 @@ builtin_macro (pfile, node)\n \n /* Copies SRC, of length LEN, to DEST, adding backslashes before all\n    backslashes and double quotes.  Non-printable characters are\n-   converted to octal.  DEST must be of sufficient size.  */\n-static U_CHAR *\n-quote_string (dest, src, len)\n+   converted to octal.  DEST must be of sufficient size.  Returns\n+   a pointer to the end of the string.  */\n+U_CHAR *\n+cpp_quote_string (dest, src, len)\n      U_CHAR *dest;\n      const U_CHAR *src;\n      unsigned int len;\n@@ -331,7 +329,7 @@ stringify_arg (pfile, arg)\n \t  _cpp_buff *buff = _cpp_get_buff (pfile, len);\n \t  unsigned char *buf = BUFF_FRONT (buff);\n \t  len = cpp_spell_token (pfile, token, buf) - buf;\n-\t  dest = quote_string (dest, buf, len);\n+\t  dest = cpp_quote_string (dest, buf, len);\n \t  _cpp_release_buff (pfile, buff);\n \t}\n       else"}, {"sha": "b8757c705d040032772259d96199e11db4c71de7", "filename": "gcc/cppmain.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcc229e5a1a7425479e0738cb9e70e8e8a2132da/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcc229e5a1a7425479e0738cb9e70e8e8a2132da/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=dcc229e5a1a7425479e0738cb9e70e8e8a2132da", "patch": "@@ -321,8 +321,17 @@ print_line (map, line, special_flags)\n   print.line = line;\n   if (! options->no_line_commands)\n     {\n+      size_t to_file_len = strlen (map->to_file);\n+      unsigned char *to_file_quoted = alloca (to_file_len * 4 + 1);\n+      unsigned char *p;\n+      \n+      /* cpp_quote_string does not nul-terminate, so we have to do it\n+\t ourselves.  */\n+      p = cpp_quote_string (to_file_quoted,\n+\t\t\t    (unsigned char *)map->to_file, to_file_len);\n+      *p = '\\0';\n       fprintf (print.outf, \"# %u \\\"%s\\\"%s\",\n-\t       SOURCE_LINE (map, print.line), map->to_file, special_flags);\n+\t       SOURCE_LINE (map, print.line), to_file_quoted, special_flags);\n \n       if (map->sysp == 2)\n \tfputs (\" 3 4\", print.outf);"}, {"sha": "3087e351fe315e84a4f5110ddc5b74657432fba9", "filename": "gcc/doc/cpp.texi", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcc229e5a1a7425479e0738cb9e70e8e8a2132da/gcc%2Fdoc%2Fcpp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcc229e5a1a7425479e0738cb9e70e8e8a2132da/gcc%2Fdoc%2Fcpp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcpp.texi?ref=dcc229e5a1a7425479e0738cb9e70e8e8a2132da", "patch": "@@ -3087,6 +3087,13 @@ input.  Subsequent lines are counted from @var{linenum}.\n effect.  In addition, @var{filename} is a string constant.  The\n following line and all subsequent lines are reported to come from the\n file it specifies, until something else happens to change that.\n+@var{filename} is interpreted according to the normal rules for a string\n+constant: backslash escapes are interpreted.  This is different from\n+@samp{#include}.\n+\n+Previous versions of GNU CPP did not interpret escapes in @samp{#line};\n+we have changed it because the standard requires they be interpreted,\n+and most other compilers do.\n \n @item #line @var{anything else}\n @var{anything else} is checked for macro calls, which are expanded.\n@@ -3304,7 +3311,8 @@ of the form\n These are called @dfn{linemarkers}.  They are inserted as needed into\n the output (but never within a string or character constant).  They mean\n that the following line originated in file @var{filename} at line\n-@var{linenum}.\n+@var{linenum}.  @var{filename} will never contain any non-printing\n+characters; they are replaced with octal escape sequences.\n \n After the file name comes zero or more flags, which are @samp{1},\n @samp{2}, @samp{3}, or @samp{4}.  If there are multiple flags, spaces\n@@ -3868,6 +3876,17 @@ The @samp{#line} directive used to change GCC's notion of the\n a double-quoted header file name.  In 3.0 and later, it does not.\n @xref{Line Control}, for further explanation.\n \n+@item Syntax of @samp{#line}\n+\n+In GCC 2.95 and previous, the string constant argument to @samp{#line}\n+was treated the same way as the argument to @samp{#include}: backslash\n+escapes were not honored, and the string ended at the second @samp{\"}.\n+This is not compliant with the C standard.  In GCC 3.0, an attempt was\n+made to correct the behavior, so that the string was treated as a real\n+string constant, but it turned out to be buggy.  In 3.1, the bugs have\n+been fixed.  (We are not fixing the bugs in 3.0 because they affect\n+relatively few people and the fix is quite invasive.)\n+\n @end itemize\n \n @node Invocation"}]}