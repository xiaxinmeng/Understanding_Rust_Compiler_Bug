{"sha": "25c6036a5bc49ba73bc3f5d2573cf2506b513a1f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjVjNjAzNmE1YmM0OWJhNzNiYzNmNWQyNTczY2YyNTA2YjUxM2ExZg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-08-13T08:57:20Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-08-13T08:57:20Z"}, "message": "re PR tree-optimization/15255 ([tree-ssa] a * 2 + a * 2 is not converted to a * 4)\n\n2008-08-13  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/15255\n\t* tree-ssa-reassoc.c (linearize_expr_tree): Declare.\n\t(struct oecount_s): New struct and VEC types.\n\t(cvec): New global.\n\t(oecount_hash): New function.\n\t(oecount_eq): Likewise.\n\t(oecount_cmp): Likewise.\n\t(zero_one_operation): New function.\n\t(build_and_add_sum): Likewise.\n\t(undistribute_ops_list): Perform un-distribution of multiplication\n\tand division on the chain of summands.\n\t(should_break_up_subtract): Also break up subtracts for factors.\n\t(reassociate_bb): Delete dead visited statements.\n\tCall undistribute_ops_list.  Re-sort and optimize if it did something.\n\t* passes.c (init_optimization_passes): Move DSE before\n\treassociation.\n\t* tree-ssa-loop-niter.c (stmt_dominates_stmt_p): Correctly handle\n\tPHI nodes.\n\n\t* gcc.dg/tree-ssa/reassoc-14.c: New testcase.\n\t* gcc.dg/tree-ssa/reassoc-15.c: Likewise.\n\t* gcc.dg/tree-ssa/reassoc-16.c: Likewise.\n\t* gcc.dg/torture/reassoc-1.c: Likewise.\n\t* gcc.dg/tree-ssa/recip-2.c: Adjust.\n\t* gcc.dg/tree-ssa/recip-6.c: Likewise.\n\t* gcc.dg/tree-ssa/recip-7.c: Likewise.\n\t* gfortran.dg/reassoc_4.f: Likewise.\n\nFrom-SVN: r139048", "tree": {"sha": "b8a064a0f6159ca9ca85a74e1d5e760278c524c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8a064a0f6159ca9ca85a74e1d5e760278c524c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "92464a8a7a6f5404b71b00acdd04cd2754d6b100", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92464a8a7a6f5404b71b00acdd04cd2754d6b100", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92464a8a7a6f5404b71b00acdd04cd2754d6b100"}], "stats": {"total": 671, "additions": 658, "deletions": 13}, "files": [{"sha": "805d73dd3759948af542701d1bb389ce67058a3d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=25c6036a5bc49ba73bc3f5d2573cf2506b513a1f", "patch": "@@ -1,3 +1,24 @@\n+2008-08-13  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/15255\n+\t* tree-ssa-reassoc.c (linearize_expr_tree): Declare.\n+\t(struct oecount_s): New struct and VEC types.\n+\t(cvec): New global.\n+\t(oecount_hash): New function.\n+\t(oecount_eq): Likewise.\n+\t(oecount_cmp): Likewise.\n+\t(zero_one_operation): New function.\n+\t(build_and_add_sum): Likewise.\n+\t(undistribute_ops_list): Perform un-distribution of multiplication\n+\tand division on the chain of summands.\n+\t(should_break_up_subtract): Also break up subtracts for factors.\n+\t(reassociate_bb): Delete dead visited statements.\n+\tCall undistribute_ops_list.  Re-sort and optimize if it did something.\n+\t* passes.c (init_optimization_passes): Move DSE before\n+\treassociation.\n+\t* tree-ssa-loop-niter.c (stmt_dominates_stmt_p): Correctly handle\n+\tPHI nodes.\n+\n 2008-08-12  Janis Johnson  <janis187@us.ibm.com>\n \n \t* doc/invoke.texi (-fipa-pta): Say the option is experimental."}, {"sha": "ee3826b39db36d582cf44e46b7a6491d865702e4", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=25c6036a5bc49ba73bc3f5d2573cf2506b513a1f", "patch": "@@ -633,9 +633,9 @@ init_optimization_passes (void)\n \t only examines PHIs to discover const/copy propagation\n \t opportunities.  */\n       NEXT_PASS (pass_phi_only_cprop);\n+      NEXT_PASS (pass_dse);\n       NEXT_PASS (pass_reassoc);\n       NEXT_PASS (pass_dce);\n-      NEXT_PASS (pass_dse);\n       NEXT_PASS (pass_forwprop);\n       NEXT_PASS (pass_phiopt);\n       NEXT_PASS (pass_object_sizes);"}, {"sha": "ca8c8cfe5d12a1cd771779b862a6a211ece4c130", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=25c6036a5bc49ba73bc3f5d2573cf2506b513a1f", "patch": "@@ -1,3 +1,15 @@\n+2008-08-13  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/15255\n+\t* gcc.dg/tree-ssa/reassoc-14.c: New testcase.\n+\t* gcc.dg/tree-ssa/reassoc-15.c: Likewise.\n+\t* gcc.dg/tree-ssa/reassoc-16.c: Likewise.\n+\t* gcc.dg/torture/reassoc-1.c: Likewise.\n+\t* gcc.dg/tree-ssa/recip-2.c: Adjust.\n+\t* gcc.dg/tree-ssa/recip-6.c: Likewise.\n+\t* gcc.dg/tree-ssa/recip-7.c: Likewise.\n+\t* gfortran.dg/reassoc_4.f: Likewise.\n+\n 2008-08-12  Janis Johnson  <janis187@us.ibm.com>\n \n \t* gcc.target/i386/pr32000-2.c: Use dg-skip-if for target expression."}, {"sha": "f0c9014cc6ea8b25df66c28109ec214cb74b8ab6", "filename": "gcc/testsuite/gcc.dg/torture/reassoc-1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Freassoc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Freassoc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Freassoc-1.c?ref=25c6036a5bc49ba73bc3f5d2573cf2506b513a1f", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do run } */\n+\n+int x;\n+\n+int __attribute__((noinline))\n+foo(int a, int b, int w)\n+{\n+  int tmp1 = a * w;\n+  int tmp2 = b * w;\n+  x = tmp1;\n+  return tmp1 + tmp2;\n+}\n+\n+extern void abort (void);\n+\n+int main()\n+{\n+  if (foo(1, 2, 3) != 9)\n+    abort ();\n+  if (x != 3)\n+    abort ();\n+  return 0;\n+}\n+"}, {"sha": "24141ef34e3ac52b075e8dcb3cefae49f458e04b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-14.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-14.c?ref=25c6036a5bc49ba73bc3f5d2573cf2506b513a1f", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-reassoc1\" } */\n+\n+int test1 (int x, int y, int z, int weight)\n+{\n+  int tmp1 = x * weight;\n+  int tmp2 = y * weight;\n+  int tmp3 = (x - y) * weight;\n+  return tmp1 + (tmp2 + tmp3);\n+}\n+\n+int test2 (int x, int y, int z, int weight)\n+{\n+  int tmp1 = x * weight;\n+  int tmp2 = y * weight * weight;\n+  int tmp3 = z * weight * weight * weight;\n+  return tmp1 + tmp2 + tmp3;\n+}\n+\n+/* There should be one multiplication left in test1 and three in test2.  */\n+\n+/* { dg-final { scan-tree-dump-times \"\\\\\\*\" 4 \"reassoc1\" } } */\n+/* { dg-final { cleanup-tree-dump \"reassoc1\" } } */"}, {"sha": "d9b74d2778583b9c6b345bd1f2bedb36c0e2ac0f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-15.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-15.c?ref=25c6036a5bc49ba73bc3f5d2573cf2506b513a1f", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-reassoc1\" } */\n+\n+int test3 (int x, int y, int z, int weight, int w1, int w2, int w3)\n+{\n+  int wtmp1 = w1 * weight;\n+  int wtmp2 = w2 * weight;\n+  int wtmp3 = w3 * weight;\n+  int tmp1 = x * wtmp1;\n+  int tmp2 = y * wtmp2;\n+  int tmp3 = z * wtmp3;\n+  return tmp1 + tmp2 + tmp3;\n+}\n+\n+/* The multiplication with weight should be un-distributed.\n+   ???  This pattern is not recognized currently.  */\n+\n+/* { dg-final { scan-tree-dump-times \"\\\\\\*\" 4 \"reassoc1\" } } */\n+/* { dg-final { cleanup-tree-dump \"reassoc1\" } } */"}, {"sha": "4dd54a8cba911a348bea649ede66cd5e2c1d4352", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-16.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-16.c?ref=25c6036a5bc49ba73bc3f5d2573cf2506b513a1f", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ffast-math -fdump-tree-reassoc1\" } */\n+\n+double test1 (double x, double y, double z, double weight)\n+{\n+  double tmp1 = x / weight;\n+  double tmp2 = y / weight;\n+  double tmp3 = -x / weight;\n+  return tmp1 + tmp2 + tmp3;\n+}\n+\n+/* The division should be un-distributed and all references to x should\n+   be gone.  */\n+\n+/* { dg-final { scan-tree-dump-times \"/\" 1 \"reassoc1\" } } */\n+/* { dg-final { cleanup-tree-dump \"reassoc1\" } } */"}, {"sha": "255c786d737cb9754e5d8bf22e8d20d393036636", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-17.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-17.c?ref=25c6036a5bc49ba73bc3f5d2573cf2506b513a1f", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ffast-math -fdump-tree-reassoc1\" } */\n+\n+double test2 (double x, double y, double ddj, int b)\n+{\n+  double tmp1, tmp2, sum;\n+  sum = 0.0;\n+  if (b)\n+    sum = 1.0;\n+  tmp1 = sum/ddj;\n+  tmp2 = x/ddj;\n+  return tmp1 + y + tmp2;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"/\" 1 \"reassoc1\" } } */\n+/* { dg-final { cleanup-tree-dump \"reassoc1\" } } */"}, {"sha": "ce52cd0d04e8483a5593d823b29b587e796fe81e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-18.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-18.c?ref=25c6036a5bc49ba73bc3f5d2573cf2506b513a1f", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-reassoc1\" } */\n+\n+int\n+ETree_nFactorEntriesInFront (int b, int m)\n+{\n+  int nent = b*b + 2*b*m;\n+  return nent;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"\\\\\\*\" 2 \"reassoc1\" } } */\n+/* { dg-final { cleanup-tree-dump \"reassoc1\" } } */"}, {"sha": "be754145e7dbfd1b2a9054bc5533ba25ab38e9f8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/recip-2.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-2.c?ref=25c6036a5bc49ba73bc3f5d2573cf2506b513a1f", "patch": "@@ -1,7 +1,9 @@\n /* { dg-do compile } */\n /* { dg-options \"-O1 -funsafe-math-optimizations -fdump-tree-recip\" } */\n \n-float e(float a, float b, float c, float d, float e, float f)\n+float u, v, w, x, y, z;\n+\n+void e(float a, float b, float c, float d, float e, float f)\n {\n   if (a < b)\n     {\n@@ -20,7 +22,12 @@ float e(float a, float b, float c, float d, float e, float f)\n   /* This should not be left as a multiplication.  */\n   c = 1 / c;\n \n-  return a + b + c + d + e + f;\n+  u = a;\n+  v = b;\n+  w = c;\n+  x = d;\n+  y = e;\n+  z = f;\n }\n \n /* { dg-final { scan-tree-dump-times \" / \" 2 \"recip\" } } */"}, {"sha": "b3334fb862a7c469100c2df4688cb760d752248b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/recip-6.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-6.c?ref=25c6036a5bc49ba73bc3f5d2573cf2506b513a1f", "patch": "@@ -5,7 +5,9 @@\n \n extern int f2();\n \n-double f1(double y, double z, double w)\n+double m, n, o;\n+\n+void f1(double y, double z, double w)\n {\n   double b, c, d, e, f;\n \n@@ -18,7 +20,9 @@ double f1(double y, double z, double w)\n   e = c / y;\n   f = 1 / y;\n \n-  return d + e + f;\n+  m = d;\n+  n = e;\n+  o = f;\n }\n \n /* { dg-final { scan-tree-dump-times \" / \" 1 \"recip\" } } */"}, {"sha": "98bbdca6e2cb5d3e397b78560283ba20a9dd92d8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/recip-7.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frecip-7.c?ref=25c6036a5bc49ba73bc3f5d2573cf2506b513a1f", "patch": "@@ -5,7 +5,9 @@\n \n extern double h();\n \n-double f(int x, double z, double w)\n+double m, n, o;\n+\n+void f(int x, double z, double w)\n {\n   double b, c, d, e, f;\n   double y = h ();\n@@ -19,7 +21,9 @@ double f(int x, double z, double w)\n   e = c / y;\n   f = 1 / y;\n \n-  return d + e + f;\n+  m = d;\n+  n = e;\n+  o = f;\n }\n \n /* { dg-final { scan-tree-dump-times \" / \" 1 \"recip\" } } */"}, {"sha": "70043658d2274101b71853eafde0e45f0859a6a8", "filename": "gcc/testsuite/gfortran.dg/reassoc_4.f", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_4.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_4.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_4.f?ref=25c6036a5bc49ba73bc3f5d2573cf2506b513a1f", "patch": "@@ -0,0 +1,43 @@\n+! { dg-do compile }\n+! { dg-options \"-O3 -ffast-math -fdump-tree-reassoc1\" }\n+      subroutine anisonl(w,vo,anisox,s,ii1,jj1,weight)\n+      integer ii1,jj1,i1,iii1,j1,jjj1,k1,l1,m1,n1\n+      real*8 w(3,3),vo(3,3),anisox(3,3,3,3),s(60,60),weight\n+!\n+!     This routine replaces the following lines in e_c3d.f for\n+!     an anisotropic material\n+!\n+                      do i1=1,3\n+                        iii1=ii1+i1-1\n+                        do j1=1,3\n+                          jjj1=jj1+j1-1\n+                          do k1=1,3\n+                            do l1=1,3\n+                              s(iii1,jjj1)=s(iii1,jjj1)\n+     &                          +anisox(i1,k1,j1,l1)*w(k1,l1)*weight\n+                              do m1=1,3\n+                                s(iii1,jjj1)=s(iii1,jjj1)\n+     &                              +anisox(i1,k1,m1,l1)*w(k1,l1)\n+     &                                 *vo(j1,m1)*weight\n+     &                              +anisox(m1,k1,j1,l1)*w(k1,l1)\n+     &                                 *vo(i1,m1)*weight\n+                                do n1=1,3\n+                                  s(iii1,jjj1)=s(iii1,jjj1)\n+     &                              +anisox(m1,k1,n1,l1)\n+     &                              *w(k1,l1)*vo(i1,m1)*vo(j1,n1)*weight\n+                                enddo\n+                              enddo\n+                            enddo\n+                          enddo\n+                        enddo\n+                      enddo\n+\n+      return\n+      end\n+\n+! There should be 22 multiplications left after un-distributing\n+! weigth, w(k1,l1), vo(i1,m1) and vo(j1,m1) on the innermost two\n+! unrolled loops.\n+\n+! { dg-final { scan-tree-dump-times \"\\[0-9\\] \\\\\\* \" 22 \"reassoc1\" } }\n+! { dg-final { cleanup-tree-dump \"reassoc1\" } }"}, {"sha": "1eedf7544af80fff7b2834e3db8b044c2234cc82", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=25c6036a5bc49ba73bc3f5d2573cf2506b513a1f", "patch": "@@ -2914,6 +2914,12 @@ stmt_dominates_stmt_p (gimple s1, gimple s2)\n     {\n       gimple_stmt_iterator bsi;\n \n+      if (gimple_code (s2) == GIMPLE_PHI)\n+\treturn false;\n+\n+      if (gimple_code (s1) == GIMPLE_PHI)\n+\treturn true;\n+\n       for (bsi = gsi_start_bb (bb1); gsi_stmt (bsi) != s2; gsi_next (&bsi))\n \tif (gsi_stmt (bsi) == s1)\n \t  return true;"}, {"sha": "be68331faf2e40ea5f9bfa2400e22fc2cb2026b0", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 444, "deletions": 6, "changes": 450, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25c6036a5bc49ba73bc3f5d2573cf2506b513a1f/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=25c6036a5bc49ba73bc3f5d2573cf2506b513a1f", "patch": "@@ -727,6 +727,415 @@ eliminate_using_constants (enum tree_code opcode,\n     }\n }\n \n+\n+static void linearize_expr_tree (VEC(operand_entry_t, heap) **, gimple,\n+\t\t\t\t bool, bool);\n+\n+/* Structure for tracking and counting operands.  */\n+typedef struct oecount_s {\n+  int cnt;\n+  enum tree_code oecode;\n+  tree op;\n+} oecount;\n+\n+DEF_VEC_O(oecount);\n+DEF_VEC_ALLOC_O(oecount,heap);\n+\n+/* The heap for the oecount hashtable and the sorted list of operands.  */\n+static VEC (oecount, heap) *cvec;\n+\n+/* Hash function for oecount.  */\n+\n+static hashval_t\n+oecount_hash (const void *p)\n+{\n+  const oecount *c = VEC_index (oecount, cvec, (size_t)p - 42);\n+  return htab_hash_pointer (c->op) ^ (hashval_t)c->oecode;\n+}\n+\n+/* Comparison function for oecount.  */\n+\n+static int\n+oecount_eq (const void *p1, const void *p2)\n+{\n+  const oecount *c1 = VEC_index (oecount, cvec, (size_t)p1 - 42);\n+  const oecount *c2 = VEC_index (oecount, cvec, (size_t)p2 - 42);\n+  return (c1->oecode == c2->oecode\n+\t  && c1->op == c2->op);\n+}\n+\n+/* Comparison function for qsort sorting oecount elements by count.  */\n+\n+static int\n+oecount_cmp (const void *p1, const void *p2)\n+{\n+  const oecount *c1 = (const oecount *)p1;\n+  const oecount *c2 = (const oecount *)p2;\n+  return c1->cnt - c2->cnt;\n+}\n+\n+/* Walks the linear chain with result *DEF searching for an operation\n+   with operand OP and code OPCODE removing that from the chain.  *DEF\n+   is updated if there is only one operand but no operation left.  */\n+\n+static void\n+zero_one_operation (tree *def, enum tree_code opcode, tree op)\n+{\n+  gimple stmt = SSA_NAME_DEF_STMT (*def);\n+\n+  do\n+    {\n+      tree name = gimple_assign_rhs1 (stmt);\n+\n+      /* If this is the operation we look for and one of the operands\n+         is ours simply propagate the other operand into the stmts\n+\t single use.  */\n+      if (gimple_assign_rhs_code (stmt) == opcode\n+\t  && (name == op\n+\t      || gimple_assign_rhs2 (stmt) == op))\n+\t{\n+\t  gimple use_stmt;\n+\t  use_operand_p use;\n+\t  gimple_stmt_iterator gsi;\n+\t  if (name == op)\n+\t    name = gimple_assign_rhs2 (stmt);\n+\t  gcc_assert (has_single_use (gimple_assign_lhs (stmt)));\n+\t  single_imm_use (gimple_assign_lhs (stmt), &use, &use_stmt);\n+\t  if (gimple_assign_lhs (stmt) == *def)\n+\t    *def = name;\n+\t  SET_USE (use, name);\n+\t  if (TREE_CODE (name) != SSA_NAME)\n+\t    update_stmt (use_stmt);\n+\t  gsi = gsi_for_stmt (stmt);\n+\t  gsi_remove (&gsi, true);\n+\t  release_defs (stmt);\n+\t  return;\n+\t}\n+\n+      /* Continue walking the chain.  */\n+      gcc_assert (name != op\n+\t\t  && TREE_CODE (name) == SSA_NAME);\n+      stmt = SSA_NAME_DEF_STMT (name);\n+    }\n+  while (1);\n+}\n+\n+/* Builds one statement performing OP1 OPCODE OP2 using TMPVAR for\n+   the result.  Places the statement after the definition of either\n+   OP1 or OP2.  Returns the new statement.  */\n+\n+static gimple\n+build_and_add_sum (tree tmpvar, tree op1, tree op2, enum tree_code opcode)\n+{\n+  gimple op1def = NULL, op2def = NULL;\n+  gimple_stmt_iterator gsi;\n+  tree op;\n+  gimple sum;\n+\n+  /* Create the addition statement.  */\n+  sum = gimple_build_assign_with_ops (opcode, tmpvar, op1, op2);\n+  op = make_ssa_name (tmpvar, sum);\n+  gimple_assign_set_lhs (sum, op);\n+\n+  /* Find an insertion place and insert.  */\n+  if (TREE_CODE (op1) == SSA_NAME)\n+    op1def = SSA_NAME_DEF_STMT (op1);\n+  if (TREE_CODE (op2) == SSA_NAME)\n+    op2def = SSA_NAME_DEF_STMT (op2);\n+  if ((!op1def || gimple_nop_p (op1def))\n+      && (!op2def || gimple_nop_p (op2def)))\n+    {\n+      gsi = gsi_start_bb (single_succ (ENTRY_BLOCK_PTR));\n+      gsi_insert_before (&gsi, sum, GSI_NEW_STMT);\n+    }\n+  else if ((!op1def || gimple_nop_p (op1def))\n+\t   || (op2def && !gimple_nop_p (op2def)\n+\t       && stmt_dominates_stmt_p (op1def, op2def)))\n+    {\n+      if (gimple_code (op2def) == GIMPLE_PHI)\n+\t{\n+\t  gsi = gsi_start_bb (gimple_bb (op2def));\n+\t  gsi_insert_before (&gsi, sum, GSI_NEW_STMT);\n+\t}\n+      else\n+\t{\n+\t  gsi = gsi_for_stmt (op2def);\n+\t  gsi_insert_after (&gsi, sum, GSI_NEW_STMT);\n+\t}\n+    }\n+  else\n+    {\n+      if (gimple_code (op1def) == GIMPLE_PHI)\n+\t{\n+\t  gsi = gsi_start_bb (gimple_bb (op1def));\n+\t  gsi_insert_before (&gsi, sum, GSI_NEW_STMT);\n+\t}\n+      else\n+\t{\n+\t  gsi = gsi_for_stmt (op1def);\n+\t  gsi_insert_after (&gsi, sum, GSI_NEW_STMT);\n+\t}\n+    }\n+  update_stmt (sum);\n+\n+  return sum;\n+}\n+\n+/* Perform un-distribution of divisions and multiplications.\n+   A * X + B * X is transformed into (A + B) * X and A / X + B / X\n+   to (A + B) / X for real X.\n+\n+   The algorithm is organized as follows.\n+\n+    - First we walk the addition chain *OPS looking for summands that\n+      are defined by a multiplication or a real division.  This results\n+      in the candidates bitmap with relevant indices into *OPS.\n+\n+    - Second we build the chains of multiplications or divisions for\n+      these candidates, counting the number of occurences of (operand, code)\n+      pairs in all of the candidates chains.\n+\n+    - Third we sort the (operand, code) pairs by number of occurence and\n+      process them starting with the pair with the most uses.\n+\n+      * For each such pair we walk the candidates again to build a\n+        second candidate bitmap noting all multiplication/division chains\n+\tthat have at least one occurence of (operand, code).\n+\n+      * We build an alternate addition chain only covering these\n+        candidates with one (operand, code) operation removed from their\n+\tmultiplication/division chain.\n+\n+      * The first candidate gets replaced by the alternate addition chain\n+        multiplied/divided by the operand.\n+\n+      * All candidate chains get disabled for further processing and\n+        processing of (operand, code) pairs continues.\n+\n+  The alternate addition chains built are re-processed by the main\n+  reassociation algorithm which allows optimizing a * x * y + b * y * x\n+  to (a + b ) * x * y in one invocation of the reassociation pass.  */\n+\n+static bool\n+undistribute_ops_list (enum tree_code opcode,\n+\t\t       VEC (operand_entry_t, heap) **ops, struct loop *loop)\n+{\n+  unsigned int length = VEC_length (operand_entry_t, *ops);\n+  operand_entry_t oe1;\n+  unsigned i, j;\n+  sbitmap candidates, candidates2;\n+  unsigned nr_candidates, nr_candidates2;\n+  sbitmap_iterator sbi0;\n+  VEC (operand_entry_t, heap) **subops;\n+  htab_t ctable;\n+  bool changed = false;\n+\n+  if (length <= 1\n+      || opcode != PLUS_EXPR)\n+    return false;\n+\n+  /* Build a list of candidates to process.  */\n+  candidates = sbitmap_alloc (length);\n+  sbitmap_zero (candidates);\n+  nr_candidates = 0;\n+  for (i = 0; VEC_iterate (operand_entry_t, *ops, i, oe1); ++i)\n+    {\n+      enum tree_code dcode;\n+      gimple oe1def;\n+\n+      if (TREE_CODE (oe1->op) != SSA_NAME)\n+\tcontinue;\n+      oe1def = SSA_NAME_DEF_STMT (oe1->op);\n+      if (!is_gimple_assign (oe1def))\n+\tcontinue;\n+      dcode = gimple_assign_rhs_code (oe1def);\n+      if ((dcode != MULT_EXPR\n+\t   && dcode != RDIV_EXPR)\n+\t  || !is_reassociable_op (oe1def, dcode, loop))\n+\tcontinue;\n+\n+      SET_BIT (candidates, i);\n+      nr_candidates++;\n+    }\n+\n+  if (nr_candidates < 2)\n+    {\n+      sbitmap_free (candidates);\n+      return false;\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"searching for un-distribute opportunities \");\n+      print_generic_expr (dump_file,\n+\tVEC_index (operand_entry_t, *ops,\n+\t\t   sbitmap_first_set_bit (candidates))->op, 0);\n+      fprintf (dump_file, \" %d\\n\", nr_candidates);\n+    }\n+\n+  /* Build linearized sub-operand lists and the counting table.  */\n+  cvec = NULL;\n+  ctable = htab_create (15, oecount_hash, oecount_eq, NULL);\n+  subops = XCNEWVEC (VEC (operand_entry_t, heap) *,\n+\t\t     VEC_length (operand_entry_t, *ops));\n+  EXECUTE_IF_SET_IN_SBITMAP (candidates, 0, i, sbi0)\n+    {\n+      gimple oedef;\n+      enum tree_code oecode;\n+      unsigned j;\n+\n+      oedef = SSA_NAME_DEF_STMT (VEC_index (operand_entry_t, *ops, i)->op);\n+      oecode = gimple_assign_rhs_code (oedef);\n+      linearize_expr_tree (&subops[i], oedef,\n+\t\t\t   associative_tree_code (oecode), false);\n+\n+      for (j = 0; VEC_iterate (operand_entry_t, subops[i], j, oe1); ++j)\n+\t{\n+\t  oecount c;\n+\t  void **slot;\n+\t  size_t idx;\n+\t  c.oecode = oecode;\n+\t  c.cnt = 1;\n+\t  c.op = oe1->op;\n+\t  VEC_safe_push (oecount, heap, cvec, &c);\n+\t  idx = VEC_length (oecount, cvec) + 41;\n+\t  slot = htab_find_slot (ctable, (void *)idx, INSERT);\n+\t  if (!*slot)\n+\t    {\n+\t      *slot = (void *)idx;\n+\t    }\n+\t  else\n+\t    {\n+\t      VEC_pop (oecount, cvec);\n+\t      VEC_index (oecount, cvec, (size_t)*slot - 42)->cnt++;\n+\t    }\n+\t}\n+    }\n+  htab_delete (ctable);\n+\n+  /* Sort the counting table.  */\n+  qsort (VEC_address (oecount, cvec), VEC_length (oecount, cvec),\n+\t sizeof (oecount), oecount_cmp);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      oecount *c;\n+      fprintf (dump_file, \"Candidates:\\n\");\n+      for (j = 0; VEC_iterate (oecount, cvec, j, c); ++j)\n+\t{\n+\t  fprintf (dump_file, \"  %u %s: \", c->cnt,\n+\t\t   c->oecode == MULT_EXPR\n+\t\t   ? \"*\" : c->oecode == RDIV_EXPR ? \"/\" : \"?\");\n+\t  print_generic_expr (dump_file, c->op, 0);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+    }\n+\n+  /* Process the (operand, code) pairs in order of most occurence.  */\n+  candidates2 = sbitmap_alloc (length);\n+  while (!VEC_empty (oecount, cvec))\n+    {\n+      oecount *c = VEC_last (oecount, cvec);\n+      if (c->cnt < 2)\n+\tbreak;\n+\n+      /* Now collect the operands in the outer chain that contain\n+         the common operand in their inner chain.  */\n+      sbitmap_zero (candidates2);\n+      nr_candidates2 = 0;\n+      EXECUTE_IF_SET_IN_SBITMAP (candidates, 0, i, sbi0)\n+\t{\n+\t  gimple oedef;\n+\t  enum tree_code oecode;\n+\t  unsigned j;\n+\t  tree op = VEC_index (operand_entry_t, *ops, i)->op;\n+\n+\t  /* If we undistributed in this chain already this may be\n+\t     a constant.  */\n+\t  if (TREE_CODE (op) != SSA_NAME)\n+\t    continue;\n+\n+\t  oedef = SSA_NAME_DEF_STMT (op);\n+\t  oecode = gimple_assign_rhs_code (oedef);\n+\t  if (oecode != c->oecode)\n+\t    continue;\n+\n+\t  for (j = 0; VEC_iterate (operand_entry_t, subops[i], j, oe1); ++j)\n+\t    {\n+\t      if (oe1->op == c->op)\n+\t\t{\n+\t\t  SET_BIT (candidates2, i);\n+\t\t  ++nr_candidates2;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (nr_candidates2 >= 2)\n+\t{\n+\t  operand_entry_t oe1, oe2;\n+\t  tree tmpvar;\n+\t  gimple prod;\n+\t  int first = sbitmap_first_set_bit (candidates2);\n+\n+\t  /* Build the new addition chain.  */\n+\t  oe1 = VEC_index (operand_entry_t, *ops, first);\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Building (\");\n+\t      print_generic_expr (dump_file, oe1->op, 0);\n+\t    }\n+\t  tmpvar = create_tmp_var (TREE_TYPE (oe1->op), NULL);\n+\t  add_referenced_var (tmpvar);\n+\t  zero_one_operation (&oe1->op, c->oecode, c->op);\n+\t  EXECUTE_IF_SET_IN_SBITMAP (candidates2, first+1, i, sbi0)\n+\t    {\n+\t      gimple sum;\n+\t      oe2 = VEC_index (operand_entry_t, *ops, i);\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fprintf (dump_file, \" + \");\n+\t\t  print_generic_expr (dump_file, oe2->op, 0);\n+\t\t}\n+\t      zero_one_operation (&oe2->op, c->oecode, c->op);\n+\t      sum = build_and_add_sum (tmpvar, oe1->op, oe2->op, opcode);\n+\t      oe2->op = fold_convert (TREE_TYPE (oe2->op), integer_zero_node);\n+\t      oe2->rank = 0;\n+\t      oe1->op = gimple_get_lhs (sum);\n+\t    }\n+\n+\t  /* Apply the multiplication/division.  */\n+\t  prod = build_and_add_sum (tmpvar, oe1->op, c->op, c->oecode);\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \") %s \", c->oecode == MULT_EXPR ? \"*\" : \"/\");\n+\t      print_generic_expr (dump_file, c->op, 0);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\n+\t  /* Record it in the addition chain and disable further\n+\t     undistribution with this op.  */\n+\t  oe1->op = gimple_assign_lhs (prod);\n+\t  oe1->rank = get_rank (oe1->op);\n+\t  VEC_free (operand_entry_t, heap, subops[first]);\n+\n+\t  changed = true;\n+\t}\n+\n+      VEC_pop (oecount, cvec);\n+    }\n+\n+  for (i = 0; i < VEC_length (operand_entry_t, *ops); ++i)\n+    VEC_free (operand_entry_t, heap, subops[i]);\n+  free (subops);\n+  VEC_free (oecount, heap, cvec);\n+  sbitmap_free (candidates);\n+  sbitmap_free (candidates2);\n+\n+  return changed;\n+}\n+\n+\n /* Perform various identities and other optimizations on the list of\n    operand entries, stored in OPS.  The tree code for the binary\n    operation between all the operands is OPCODE.  */\n@@ -1097,7 +1506,8 @@ should_break_up_subtract (gimple stmt)\n   if (TREE_CODE (lhs) == SSA_NAME\n       && (immusestmt = get_single_immediate_use (lhs))\n       && is_gimple_assign (immusestmt)\n-      && gimple_assign_rhs_code (immusestmt) == PLUS_EXPR)\n+      && (gimple_assign_rhs_code (immusestmt) == PLUS_EXPR\n+\t  ||  gimple_assign_rhs_code (immusestmt) == MULT_EXPR))\n     return true;\n   return false;\n }\n@@ -1125,7 +1535,8 @@ break_up_subtract (gimple stmt, gimple_stmt_iterator *gsip)\n    Place the operands of the expression tree in the vector named OPS.  */\n \n static void\n-linearize_expr_tree (VEC(operand_entry_t, heap) **ops, gimple stmt)\n+linearize_expr_tree (VEC(operand_entry_t, heap) **ops, gimple stmt,\n+\t\t     bool is_associative, bool set_visited)\n {\n   gimple_stmt_iterator gsinow, gsilhs;\n   tree binlhs = gimple_assign_rhs1 (stmt);\n@@ -1136,7 +1547,8 @@ linearize_expr_tree (VEC(operand_entry_t, heap) **ops, gimple stmt)\n   enum tree_code rhscode = gimple_assign_rhs_code (stmt);\n   struct loop *loop = loop_containing_stmt (stmt);\n \n-  gimple_set_visited (stmt, true);\n+  if (set_visited)\n+    gimple_set_visited (stmt, true);\n \n   if (TREE_CODE (binlhs) == SSA_NAME)\n     {\n@@ -1160,6 +1572,13 @@ linearize_expr_tree (VEC(operand_entry_t, heap) **ops, gimple stmt)\n     {\n       tree temp;\n \n+      /* If this is not a associative operation like division, give up.  */\n+      if (!is_associative)\n+\t{\n+\t  add_to_ops_vec (ops, binrhs);\n+\t  return;\n+\t}\n+\n       if (!binrhsisreassoc)\n \t{\n \t  add_to_ops_vec (ops, binrhs);\n@@ -1203,7 +1622,8 @@ linearize_expr_tree (VEC(operand_entry_t, heap) **ops, gimple stmt)\n   gsinow = gsi_for_stmt (stmt);\n   gsilhs = gsi_for_stmt (SSA_NAME_DEF_STMT (binlhs));\n   gsi_move_before (&gsilhs, &gsinow);\n-  linearize_expr_tree (ops, SSA_NAME_DEF_STMT (binlhs));\n+  linearize_expr_tree (ops, SSA_NAME_DEF_STMT (binlhs),\n+\t\t       is_associative, set_visited);\n   add_to_ops_vec (ops, binrhs);\n }\n \n@@ -1344,7 +1764,16 @@ reassociate_bb (basic_block bb)\n \t  /* If this was part of an already processed statement,\n \t     we don't need to touch it again. */\n \t  if (gimple_visited_p (stmt))\n-\t    continue;\n+\t    {\n+\t      /* This statement might have become dead because of previous\n+\t\t reassociations.  */\n+\t      if (has_zero_uses (gimple_get_lhs (stmt)))\n+\t\t{\n+\t\t  gsi_remove (&gsi, true);\n+\t\t  release_defs (stmt);\n+\t\t}\n+\t      continue;\n+\t    }\n \n \t  lhs = gimple_assign_lhs (stmt);\n \t  rhs1 = gimple_assign_rhs1 (stmt);\n@@ -1375,12 +1804,21 @@ reassociate_bb (basic_block bb)\n \t\tcontinue;\n \n \t      gimple_set_visited (stmt, true);\n-\t      linearize_expr_tree (&ops, stmt);\n+\t      linearize_expr_tree (&ops, stmt, true, true);\n \t      qsort (VEC_address (operand_entry_t, ops),\n \t\t     VEC_length (operand_entry_t, ops),\n \t\t     sizeof (operand_entry_t),\n \t\t     sort_by_operand_rank);\n \t      optimize_ops_list (rhs_code, &ops);\n+\t      if (undistribute_ops_list (rhs_code, &ops,\n+\t\t\t\t\t loop_containing_stmt (stmt)))\n+\t\t{\n+\t\t  qsort (VEC_address (operand_entry_t, ops),\n+\t\t\t VEC_length (operand_entry_t, ops),\n+\t\t\t sizeof (operand_entry_t),\n+\t\t\t sort_by_operand_rank);\n+\t\t  optimize_ops_list (rhs_code, &ops);\n+\t\t}\n \n \t      if (VEC_length (operand_entry_t, ops) == 1)\n \t\t{"}]}