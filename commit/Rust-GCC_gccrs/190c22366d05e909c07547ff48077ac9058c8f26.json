{"sha": "190c22366d05e909c07547ff48077ac9058c8f26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTkwYzIyMzY2ZDA1ZTkwOWMwNzU0N2ZmNDgwNzdhYzkwNThjOGYyNg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-11-08T12:09:57Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-11-08T12:09:57Z"}, "message": "tree-vect-stmts.c (vectorizable_call): Add SLP_NODE argument.\n\n\t* tree-vect-stmts.c (vectorizable_call): Add SLP_NODE argument.\n\tHandle vectorization of SLP calls.\n\t(vect_analyze_stmt): Adjust caller, add call to it for SLP too.\n\t(vect_transform_stmt): Adjust vectorizable_call caller, remove\n\tassertion.\n\t* tree-vect-slp.c (vect_get_and_check_slp_defs): For calls start\n\twith op_idx 3.\n\t(vect_build_slp_tree): Allow CALL_EXPR.\n\n\t* lib/target-supports.exp (check_effective_target_vect_call_sqrtf,\n\tcheck_effective_target_vect_call_copysignf,\n\tcheck_effective_target_vect_call_lrint): New procedures.\n\t* gcc.dg/vect/vect.exp: Run fast-math-bb-slp* tests using\n\t$VECT_SLP_CFLAGS with -ffast-math.\n\t* gcc.dg/vect/fast-math-vect-call-1.c: New test.\n\t* gcc.dg/vect/fast-math-vect-call-2.c: New test.\n\t* gcc.dg/vect/fast-math-bb-slp-call-1.c: New test.\n\t* gcc.dg/vect/fast-math-bb-slp-call-2.c: New test.\n\nFrom-SVN: r181157", "tree": {"sha": "bb564b74a958ecf273bb7159475fb0ca7741bf8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb564b74a958ecf273bb7159475fb0ca7741bf8a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/190c22366d05e909c07547ff48077ac9058c8f26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/190c22366d05e909c07547ff48077ac9058c8f26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/190c22366d05e909c07547ff48077ac9058c8f26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/190c22366d05e909c07547ff48077ac9058c8f26/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4e68a06c035b33ef371d7103839d69ccd00581bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e68a06c035b33ef371d7103839d69ccd00581bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e68a06c035b33ef371d7103839d69ccd00581bc"}], "stats": {"total": 575, "additions": 556, "deletions": 19}, "files": [{"sha": "ed0dec9c6f6021524969b01b416ed1f9841edc92", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/190c22366d05e909c07547ff48077ac9058c8f26/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/190c22366d05e909c07547ff48077ac9058c8f26/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=190c22366d05e909c07547ff48077ac9058c8f26", "patch": "@@ -1,3 +1,14 @@\n+2011-11-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* tree-vect-stmts.c (vectorizable_call): Add SLP_NODE argument.\n+\tHandle vectorization of SLP calls.\n+\t(vect_analyze_stmt): Adjust caller, add call to it for SLP too.\n+\t(vect_transform_stmt): Adjust vectorizable_call caller, remove\n+\tassertion.\n+\t* tree-vect-slp.c (vect_get_and_check_slp_defs): For calls start\n+\twith op_idx 3.\n+\t(vect_build_slp_tree): Allow CALL_EXPR.\n+\n 2011-11-08  Richard Guenther  <rguenther@suse.de>\n \n \t* gimple-fold.c (canonicalize_constructor_val): Make sure"}, {"sha": "72c6d434c608107f0d8803ddf9514409134e8845", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/190c22366d05e909c07547ff48077ac9058c8f26/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/190c22366d05e909c07547ff48077ac9058c8f26/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=190c22366d05e909c07547ff48077ac9058c8f26", "patch": "@@ -1,3 +1,15 @@\n+2011-11-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* lib/target-supports.exp (check_effective_target_vect_call_sqrtf,\n+\tcheck_effective_target_vect_call_copysignf,\n+\tcheck_effective_target_vect_call_lrint): New procedures.\n+\t* gcc.dg/vect/vect.exp: Run fast-math-bb-slp* tests using\n+\t$VECT_SLP_CFLAGS with -ffast-math.\n+\t* gcc.dg/vect/fast-math-vect-call-1.c: New test.\n+\t* gcc.dg/vect/fast-math-vect-call-2.c: New test.\n+\t* gcc.dg/vect/fast-math-bb-slp-call-1.c: New test.\n+\t* gcc.dg/vect/fast-math-bb-slp-call-2.c: New test.\n+\n 2011-11-07  Richard Henderson  <rth@redhat.com>\n \t    Aldy Hernandez  <aldyh@redhat.com>\n \t    Torvald Riegel  <triegel@redhat.com>"}, {"sha": "7b76b440e1ba5ffbd6c06943447af028b2b3f1b6", "filename": "gcc/testsuite/gcc.dg/vect/fast-math-bb-slp-call-1.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/190c22366d05e909c07547ff48077ac9058c8f26/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ffast-math-bb-slp-call-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/190c22366d05e909c07547ff48077ac9058c8f26/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ffast-math-bb-slp-call-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ffast-math-bb-slp-call-1.c?ref=190c22366d05e909c07547ff48077ac9058c8f26", "patch": "@@ -0,0 +1,49 @@\n+#include \"tree-vect.h\"\n+\n+extern float copysignf (float, float);\n+extern float sqrtf (float);\n+extern float fabsf (float);\n+extern void abort (void);\n+float a[64], b[64], c[64], d[64];\n+\n+__attribute__((noinline, noclone)) void\n+f1 (void)\n+{\n+  a[0] = copysignf (b[0], c[0]) + 1.0f + sqrtf (d[0]);\n+  a[1] = copysignf (b[1], c[1]) + 2.0f + sqrtf (d[1]);\n+  a[2] = copysignf (b[2], c[2]) + 3.0f + sqrtf (d[2]);\n+  a[3] = copysignf (b[3], c[3]) + 4.0f + sqrtf (d[3]);\n+  a[4] = copysignf (b[4], c[4]) + 5.0f + sqrtf (d[4]);\n+  a[5] = copysignf (b[5], c[5]) + 6.0f + sqrtf (d[5]);\n+  a[6] = copysignf (b[6], c[6]) + 7.0f + sqrtf (d[6]);\n+  a[7] = copysignf (b[7], c[7]) + 8.0f + sqrtf (d[7]);\n+}\n+\n+__attribute__((noinline, noclone)) int\n+main1 ()\n+{\n+  int i;\n+\n+  for (i = 0; i < 8; i++)\n+    {\n+      asm (\"\");\n+      b[i] = (i & 1) ? -4 * i : 4 * i;\n+      c[i] = (i & 2) ? -8 * i : 8 * i;\n+      d[i] = i * i;\n+    }\n+  f1 ();\n+  for (i = 0; i < 8; i++)\n+    if (fabsf (((i & 2) ? -4 * i : 4 * i) + 1 + i + i - a[i]) >= 0.0001f)\n+      abort ();\n+  return 0;\n+}\n+\n+int\n+main ()\n+{\n+  check_vect ();\n+  return main1 ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 1 \"slp\" { target { vect_call_copysignf && vect_call_sqrtf } } } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */"}, {"sha": "f555dfc9d8d4ca45766aa4d86e4b3f8ed0f6be80", "filename": "gcc/testsuite/gcc.dg/vect/fast-math-bb-slp-call-2.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/190c22366d05e909c07547ff48077ac9058c8f26/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ffast-math-bb-slp-call-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/190c22366d05e909c07547ff48077ac9058c8f26/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ffast-math-bb-slp-call-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ffast-math-bb-slp-call-2.c?ref=190c22366d05e909c07547ff48077ac9058c8f26", "patch": "@@ -0,0 +1,65 @@\n+#include \"tree-vect.h\"\n+\n+extern long int lrint (double);\n+extern void abort (void);\n+long int a[64];\n+double b[64];\n+\n+__attribute__((noinline, noclone)) void\n+f1 (void)\n+{\n+  a[0] = lrint (b[0]) + 1;\n+  a[1] = lrint (b[1]) + 2;\n+  a[2] = lrint (b[2]) + 3;\n+  a[3] = lrint (b[3]) + 4;\n+  a[4] = lrint (b[4]) + 5;\n+  a[5] = lrint (b[5]) + 6;\n+  a[6] = lrint (b[6]) + 7;\n+  a[7] = lrint (b[7]) + 8;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f2 (void)\n+{\n+  a[0] = lrint (b[0]);\n+  a[1] = lrint (b[1]);\n+  a[2] = lrint (b[2]);\n+  a[3] = lrint (b[3]);\n+  a[4] = lrint (b[4]);\n+  a[5] = lrint (b[5]);\n+  a[6] = lrint (b[6]);\n+  a[7] = lrint (b[7]);\n+}\n+\n+__attribute__((noinline, noclone)) int\n+main1 ()\n+{\n+  int i;\n+\n+  for (i = 0; i < 8; i++)\n+    {\n+      asm (\"\");\n+      b[i] = ((i & 1) ? -4 * i : 4 * i) + 0.25;\n+    }\n+  f1 ();\n+  for (i = 0; i < 8; i++)\n+    if (a[i] != ((i & 1) ? -4 * i : 4 * i) + 1 + i)\n+      abort ();\n+    else\n+      a[i] = 131.25;\n+  f2 ();\n+  for (i = 0; i < 8; i++)\n+    if (a[i] != ((i & 1) ? -4 * i : 4 * i))\n+      abort ();\n+  return 0;\n+}\n+\n+int\n+main ()\n+{\n+  check_vect ();\n+  return main1 ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 2 \"slp\" { target vect_call_lrint } } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */"}, {"sha": "835f8bc2bbe2847f6bffb6fe81b45f5f8eab9bd4", "filename": "gcc/testsuite/gcc.dg/vect/fast-math-vect-call-1.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/190c22366d05e909c07547ff48077ac9058c8f26/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ffast-math-vect-call-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/190c22366d05e909c07547ff48077ac9058c8f26/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ffast-math-vect-call-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ffast-math-vect-call-1.c?ref=190c22366d05e909c07547ff48077ac9058c8f26", "patch": "@@ -0,0 +1,81 @@\n+#include \"tree-vect.h\"\n+\n+extern float copysignf (float, float);\n+extern float sqrtf (float);\n+extern float fabsf (float);\n+extern void abort (void);\n+float a[64], b[64], c[64], d[64];\n+\n+__attribute__((noinline, noclone)) void\n+f1 (int n)\n+{\n+  int i;\n+  for (i = 0; i < n; i++)\n+    {\n+      a[4 * i + 0] = copysignf (b[4 * i + 0], c[4 * i + 0]) + 1.0f + sqrtf (d[4 * i + 0]);\n+      a[4 * i + 1] = copysignf (b[4 * i + 1], c[4 * i + 1]) + 2.0f + sqrtf (d[4 * i + 1]);\n+      a[4 * i + 2] = copysignf (b[4 * i + 2], c[4 * i + 2]) + 3.0f + sqrtf (d[4 * i + 2]);\n+      a[4 * i + 3] = copysignf (b[4 * i + 3], c[4 * i + 3]) + 4.0f + sqrtf (d[4 * i + 3]);\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f2 (int n)\n+{\n+  int i;\n+  for (i = 0; i < 2 * n; i++)\n+    {\n+      a[2 * i + 0] = copysignf (b[2 * i + 0], c[2 * i + 0]) + 1.0f + sqrtf (d[2 * i + 0]);\n+      a[2 * i + 1] = copysignf (b[2 * i + 1], c[2 * i + 1]) + 2.0f + sqrtf (d[2 * i + 1]);\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f3 (void)\n+{\n+  int i;\n+  for (i = 0; i < 64; i++)\n+    a[i] = copysignf (b[i], c[i]) + 1.0f + sqrtf (d[i]);\n+}\n+\n+__attribute__((noinline, noclone)) int\n+main1 ()\n+{\n+  int i;\n+\n+  for (i = 0; i < 64; i++)\n+    {\n+      asm (\"\");\n+      b[i] = (i & 1) ? -4 * i : 4 * i;\n+      c[i] = (i & 2) ? -8 * i : 8 * i;\n+      d[i] = i * i;\n+    }\n+  f1 (16);\n+  for (i = 0; i < 64; i++)\n+    if (fabsf (((i & 2) ? -4 * i : 4 * i) + 1 + (i & 3) + i - a[i]) >= 0.0001f)\n+      abort ();\n+    else\n+      a[i] = 131.25;\n+  f2 (16);\n+  for (i = 0; i < 64; i++)\n+    if (fabsf (((i & 2) ? -4 * i : 4 * i) + 1 + (i & 1) + i - a[i]) >= 0.0001f)\n+      abort ();\n+    else\n+      a[i] = 131.25;\n+  f3 ();\n+  for (i = 0; i < 64; i++)\n+    if (fabsf (((i & 2) ? -4 * i : 4 * i) + 1 + i - a[i]) >= 0.0001f)\n+      abort ();\n+  return 0;\n+}\n+\n+int\n+main ()\n+{\n+  check_vect ();\n+  return main1 ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 3 \"vect\" { target { vect_call_copysignf && vect_call_sqrtf } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { target { vect_call_copysignf && vect_call_sqrtf } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "edb6670b02875097d136945467caad63f35f7f6b", "filename": "gcc/testsuite/gcc.dg/vect/fast-math-vect-call-2.c", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/190c22366d05e909c07547ff48077ac9058c8f26/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ffast-math-vect-call-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/190c22366d05e909c07547ff48077ac9058c8f26/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ffast-math-vect-call-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ffast-math-vect-call-2.c?ref=190c22366d05e909c07547ff48077ac9058c8f26", "patch": "@@ -0,0 +1,128 @@\n+#include \"tree-vect.h\"\n+\n+extern long int lrint (double);\n+extern void abort (void);\n+long int a[64];\n+double b[64];\n+\n+__attribute__((noinline, noclone)) void\n+f1 (int n)\n+{\n+  int i;\n+  for (i = 0; i < n; i++)\n+    {\n+      a[4 * i + 0] = lrint (b[4 * i + 0]) + 1;\n+      a[4 * i + 1] = lrint (b[4 * i + 1]) + 2;\n+      a[4 * i + 2] = lrint (b[4 * i + 2]) + 3;\n+      a[4 * i + 3] = lrint (b[4 * i + 3]) + 4;\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f2 (int n)\n+{\n+  int i;\n+  for (i = 0; i < 2 * n; i++)\n+    {\n+      a[2 * i + 0] = lrint (b[2 * i + 0]) + 1;\n+      a[2 * i + 1] = lrint (b[2 * i + 1]) + 2;\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f3 (void)\n+{\n+  int i;\n+  for (i = 0; i < 64; i++)\n+    a[i] = lrint (b[i]) + 1;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f4 (int n)\n+{\n+  int i;\n+  for (i = 0; i < n; i++)\n+    {\n+      a[4 * i + 0] = lrint (b[4 * i + 0]);\n+      a[4 * i + 1] = lrint (b[4 * i + 1]);\n+      a[4 * i + 2] = lrint (b[4 * i + 2]);\n+      a[4 * i + 3] = lrint (b[4 * i + 3]);\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f5 (int n)\n+{\n+  int i;\n+  for (i = 0; i < 2 * n; i++)\n+    {\n+      a[2 * i + 0] = lrint (b[2 * i + 0]);\n+      a[2 * i + 1] = lrint (b[2 * i + 1]);\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f6 (void)\n+{\n+  int i;\n+  for (i = 0; i < 64; i++)\n+    a[i] = lrint (b[i]);\n+}\n+\n+__attribute__((noinline, noclone)) int\n+main1 ()\n+{\n+  int i;\n+\n+  for (i = 0; i < 64; i++)\n+    {\n+      asm (\"\");\n+      b[i] = ((i & 1) ? -4 * i : 4 * i) + 0.25;\n+    }\n+  f1 (16);\n+  for (i = 0; i < 64; i++)\n+    if (a[i] != ((i & 1) ? -4 * i : 4 * i) + 1 + (i & 3))\n+      abort ();\n+    else\n+      a[i] = 131.25;\n+  f2 (16);\n+  for (i = 0; i < 64; i++)\n+    if (a[i] != ((i & 1) ? -4 * i : 4 * i) + 1 + (i & 1))\n+      abort ();\n+    else\n+      a[i] = 131.25;\n+  f3 ();\n+  for (i = 0; i < 64; i++)\n+    if (a[i] != ((i & 1) ? -4 * i : 4 * i) + 1)\n+      abort ();\n+    else\n+      a[i] = 131.25;\n+  f4 (16);\n+  for (i = 0; i < 64; i++)\n+    if (a[i] != ((i & 1) ? -4 * i : 4 * i))\n+      abort ();\n+    else\n+      a[i] = 131.25;\n+  f5 (16);\n+  for (i = 0; i < 64; i++)\n+    if (a[i] != ((i & 1) ? -4 * i : 4 * i))\n+      abort ();\n+    else\n+      a[i] = 131.25;\n+  f6 ();\n+  for (i = 0; i < 64; i++)\n+    if (a[i] != ((i & 1) ? -4 * i : 4 * i))\n+      abort ();\n+  return 0;\n+}\n+\n+int\n+main ()\n+{\n+  check_vect ();\n+  return main1 ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 6 \"vect\" { target vect_call_lrint } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 4 \"vect\" { target vect_call_lrint } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "b6d4a331133e6607f60128c0086e72790c37ff41", "filename": "gcc/testsuite/gcc.dg/vect/vect.exp", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/190c22366d05e909c07547ff48077ac9058c8f26/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/190c22366d05e909c07547ff48077ac9058c8f26/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp?ref=190c22366d05e909c07547ff48077ac9058c8f26", "patch": "@@ -104,9 +104,15 @@ dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-vfa-*.\\[cS\\]]]  \\\n # -ffast-math tests\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-ffast-math\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/fast-math-*.\\[cS\\]]]  \\\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/fast-math-\\[ipsv\\]*.\\[cS\\]]]  \\\n \t\"\" $DEFAULT_VECTCFLAGS\n \n+# -ffast-math SLP tests\n+set VECT_SLP_CFLAGS $SAVED_VECT_SLP_CFLAGS\n+lappend VECT_SLP_CFLAGS \"-ffast-math\"\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/fast-math-bb-slp-*.\\[cS\\]]]  \\\n+        \"\" $VECT_SLP_CFLAGS\n+\n # -fno-fast-math tests\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-fno-fast-math\""}, {"sha": "437e18186c55050085012de37b73e9afdacfdd90", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/190c22366d05e909c07547ff48077ac9058c8f26/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/190c22366d05e909c07547ff48077ac9058c8f26/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=190c22366d05e909c07547ff48077ac9058c8f26", "patch": "@@ -3520,6 +3520,58 @@ proc check_effective_target_vect64 { } {\n     return $et_vect64_saved\n }\n \n+# Return 1 if the target supports vector copysignf calls.\n+\n+proc check_effective_target_vect_call_copysignf { } {\n+    global et_vect_call_copysignf_saved\n+\n+    if [info exists et_vect_call_copysignf_saved] {\n+\tverbose \"check_effective_target_vect_call_copysignf: using cached result\" 2\n+    } else {\n+\tset et_vect_call_copysignf_saved 0\n+\tif { [istarget i?86-*-*]\n+\t     || [istarget x86_64-*-*]\n+\t     || [istarget powerpc*-*-*] } {\n+\t   set et_vect_call_copysignf_saved 1\n+\t}\n+    }\n+\n+    verbose \"check_effective_target_vect_call_copysignf: returning $et_vect_call_copysignf_saved\" 2\n+    return $et_vect_call_copysignf_saved\n+}\n+\n+# Return 1 if the target supports vector sqrtf calls.\n+\n+proc check_effective_target_vect_call_sqrtf { } {\n+    global et_vect_call_sqrtf_saved\n+\n+    if [info exists et_vect_call_sqrtf_saved] {\n+\tverbose \"check_effective_target_vect_call_sqrtf: using cached result\" 2\n+    } else {\n+\tset et_vect_call_sqrtf_saved 0\n+\tif { [istarget i?86-*-*]\n+\t     || [istarget x86_64-*-*]\n+\t     || ([istarget powerpc*-*-*] && [check_vsx_hw_available]) } {\n+\t    set et_vect_call_sqrtf_saved 1\n+\t}\n+    }\n+\n+    verbose \"check_effective_target_vect_call_sqrtf: returning $et_vect_call_sqrtf_saved\" 2\n+    return $et_vect_call_sqrtf_saved\n+}\n+\n+# Return 1 if the target supports vector lrint calls.\n+\n+proc check_effective_target_vect_call_lrint { } {\n+    set et_vect_call_lrint 0\n+    if { ([istarget i?86-*-*] || [istarget x86_64-*-*]) && [check_effective_target_ilp32] } {\n+\tset et_vect_call_lrint 1\n+    }\n+\n+    verbose \"check_effective_target_vect_call_lrint: returning $et_vect_call_lrint\" 2\n+    return $et_vect_call_lrint\n+}\n+\n # Return 1 if the target supports section-anchors\n \n proc check_effective_target_section_anchors { } {"}, {"sha": "f54a8a772800e2a5b4bd0984eea8ae7cbfd56b3b", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 46, "deletions": 3, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/190c22366d05e909c07547ff48077ac9058c8f26/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/190c22366d05e909c07547ff48077ac9058c8f26/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=190c22366d05e909c07547ff48077ac9058c8f26", "patch": "@@ -202,7 +202,10 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n     loop = LOOP_VINFO_LOOP (loop_vinfo);\n \n   if (is_gimple_call (stmt))\n-    number_of_oprnds = gimple_call_num_args (stmt);\n+    {\n+      number_of_oprnds = gimple_call_num_args (stmt);\n+      op_idx = 3;\n+    }\n   else if (is_gimple_assign (stmt))\n     {\n       number_of_oprnds = gimple_num_ops (stmt) - 1;\n@@ -558,7 +561,25 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       ncopies = vectorization_factor / TYPE_VECTOR_SUBPARTS (vectype);\n \n       if (is_gimple_call (stmt))\n-\trhs_code = CALL_EXPR;\n+\t{\n+\t  rhs_code = CALL_EXPR;\n+\t  if (gimple_call_internal_p (stmt)\n+\t      || gimple_call_tail_p (stmt)\n+\t      || gimple_call_noreturn_p (stmt)\n+\t      || !gimple_call_nothrow_p (stmt)\n+\t      || gimple_call_chain (stmt))\n+\t    {\n+\t      if (vect_print_dump_info (REPORT_SLP))\n+\t\t{\n+\t\t  fprintf (vect_dump,\n+\t\t\t   \"Build SLP failed: unsupported call type \");\n+\t\t  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+\t\t}\n+\n+\t      vect_free_oprnd_info (&oprnds_info, true);\n+\t      return false;\n+\t    }\n+\t}\n       else\n \trhs_code = gimple_assign_rhs_code (stmt);\n \n@@ -653,6 +674,27 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t      vect_free_oprnd_info (&oprnds_info, true);\n \t      return false;\n \t    }\n+\n+\t  if (rhs_code == CALL_EXPR)\n+\t    {\n+\t      gimple first_stmt = VEC_index (gimple, stmts, 0);\n+\t      if (gimple_call_num_args (stmt) != nops\n+\t\t  || !operand_equal_p (gimple_call_fn (first_stmt),\n+\t\t\t\t       gimple_call_fn (stmt), 0)\n+\t\t  || gimple_call_fntype (first_stmt)\n+\t\t     != gimple_call_fntype (stmt))\n+\t\t{\n+\t\t  if (vect_print_dump_info (REPORT_SLP))\n+\t\t    {\n+\t\t      fprintf (vect_dump,\n+\t\t\t       \"Build SLP failed: different calls in \");\n+\t\t      print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+\t\t    }\n+\n+\t\t  vect_free_oprnd_info (&oprnds_info, true);\n+\t\t  return false;\n+\t\t}\n+\t    }\n \t}\n \n       /* Strided store or load.  */\n@@ -786,7 +828,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t  /* Not memory operation.  */\n \t  if (TREE_CODE_CLASS (rhs_code) != tcc_binary\n \t      && TREE_CODE_CLASS (rhs_code) != tcc_unary\n-              && rhs_code != COND_EXPR)\n+\t      && rhs_code != COND_EXPR\n+\t      && rhs_code != CALL_EXPR)\n \t    {\n \t      if (vect_print_dump_info (REPORT_SLP))\n \t\t{"}, {"sha": "705e7df531acc86e2993af842718b50dce48dc1b", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 105, "deletions": 15, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/190c22366d05e909c07547ff48077ac9058c8f26/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/190c22366d05e909c07547ff48077ac9058c8f26/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=190c22366d05e909c07547ff48077ac9058c8f26", "patch": "@@ -1521,7 +1521,8 @@ vectorizable_function (gimple call, tree vectype_out, tree vectype_in)\n    Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n \n static bool\n-vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt)\n+vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n+\t\t   slp_tree slp_node)\n {\n   tree vec_dest;\n   tree scalar_dest;\n@@ -1532,6 +1533,7 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt)\n   int nunits_in;\n   int nunits_out;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n   tree fndecl, new_temp, def, rhs_type;\n   gimple def_stmt;\n   enum vect_def_type dt[3]\n@@ -1543,19 +1545,12 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt)\n   size_t i, nargs;\n   tree lhs;\n \n-  /* FORNOW: unsupported in basic block SLP.  */\n-  gcc_assert (loop_vinfo);\n-\n-  if (!STMT_VINFO_RELEVANT_P (stmt_info))\n+  if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n     return false;\n \n   if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def)\n     return false;\n \n-  /* FORNOW: SLP not supported.  */\n-  if (STMT_SLP_TYPE (stmt_info))\n-    return false;\n-\n   /* Is STMT a vectorizable call?   */\n   if (!is_gimple_call (stmt))\n     return false;\n@@ -1596,7 +1591,7 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt)\n       if (!rhs_type)\n \trhs_type = TREE_TYPE (op);\n \n-      if (!vect_is_simple_use_1 (op, loop_vinfo, NULL,\n+      if (!vect_is_simple_use_1 (op, loop_vinfo, bb_vinfo,\n \t\t\t\t &def_stmt, &def, &dt[i], &opvectype))\n \t{\n \t  if (vect_print_dump_info (REPORT_DETAILS))\n@@ -1658,7 +1653,9 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt)\n \n   gcc_assert (!gimple_vuse (stmt));\n \n-  if (modifier == NARROW)\n+  if (slp_node || PURE_SLP_STMT (stmt_info))\n+    ncopies = 1;\n+  else if (modifier == NARROW)\n     ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_out;\n   else\n     ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_in;\n@@ -1697,6 +1694,50 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt)\n \t  else\n \t    VEC_truncate (tree, vargs, 0);\n \n+\t  if (slp_node)\n+\t    {\n+\t      VEC (slp_void_p, heap) *vec_defs\n+\t\t= VEC_alloc (slp_void_p, heap, nargs);\n+\t      VEC (tree, heap) *vec_oprnds0;\n+\n+\t      for (i = 0; i < nargs; i++)\n+\t\tVEC_quick_push (tree, vargs, gimple_call_arg (stmt, i));\n+\t      vect_get_slp_defs (vargs, slp_node, &vec_defs, -1);\n+\t      vec_oprnds0\n+\t\t= (VEC (tree, heap) *) VEC_index (slp_void_p, vec_defs, 0);\n+\n+\t      /* Arguments are ready.  Create the new vector stmt.  */\n+\t      FOR_EACH_VEC_ELT (tree, vec_oprnds0, i, vec_oprnd0)\n+\t\t{\n+\t\t  size_t k;\n+\t\t  for (k = 0; k < nargs; k++)\n+\t\t    {\n+\t\t      VEC (tree, heap) *vec_oprndsk\n+\t\t\t= (VEC (tree, heap) *)\n+\t\t\t  VEC_index (slp_void_p, vec_defs, k);\n+\t\t      VEC_replace (tree, vargs, k,\n+\t\t\t\t   VEC_index (tree, vec_oprndsk, i));\n+\t\t    }\n+\t\t  new_stmt = gimple_build_call_vec (fndecl, vargs);\n+\t\t  new_temp = make_ssa_name (vec_dest, new_stmt);\n+\t\t  gimple_call_set_lhs (new_stmt, new_temp);\n+\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t\t  mark_symbols_for_renaming (new_stmt);\n+\t\t  VEC_quick_push (gimple, SLP_TREE_VEC_STMTS (slp_node),\n+\t\t\t\t  new_stmt);\n+\t\t}\n+\n+\t      for (i = 0; i < nargs; i++)\n+\t\t{\n+\t\t  VEC (tree, heap) *vec_oprndsi\n+\t\t    = (VEC (tree, heap) *)\n+\t\t      VEC_index (slp_void_p, vec_defs, i);\n+\t\t  VEC_free (tree, heap, vec_oprndsi);\n+\t\t}\n+\t      VEC_free (slp_void_p, heap, vec_defs);\n+\t      continue;\n+\t    }\n+\n \t  for (i = 0; i < nargs; i++)\n \t    {\n \t      op = gimple_call_arg (stmt, i);\n@@ -1739,6 +1780,54 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt)\n \t  else\n \t    VEC_truncate (tree, vargs, 0);\n \n+\t  if (slp_node)\n+\t    {\n+\t      VEC (slp_void_p, heap) *vec_defs\n+\t\t= VEC_alloc (slp_void_p, heap, nargs);\n+\t      VEC (tree, heap) *vec_oprnds0;\n+\n+\t      for (i = 0; i < nargs; i++)\n+\t\tVEC_quick_push (tree, vargs, gimple_call_arg (stmt, i));\n+\t      vect_get_slp_defs (vargs, slp_node, &vec_defs, -1);\n+\t      vec_oprnds0\n+\t\t= (VEC (tree, heap) *) VEC_index (slp_void_p, vec_defs, 0);\n+\n+\t      /* Arguments are ready.  Create the new vector stmt.  */\n+\t      for (i = 0; VEC_iterate (tree, vec_oprnds0, i, vec_oprnd0);\n+\t\t   i += 2)\n+\t\t{\n+\t\t  size_t k;\n+\t\t  VEC_truncate (tree, vargs, 0);\n+\t\t  for (k = 0; k < nargs; k++)\n+\t\t    {\n+\t\t      VEC (tree, heap) *vec_oprndsk\n+\t\t\t= (VEC (tree, heap) *)\n+\t\t\t  VEC_index (slp_void_p, vec_defs, k);\n+\t\t      VEC_quick_push (tree, vargs,\n+\t\t\t\t      VEC_index (tree, vec_oprndsk, i));\n+\t\t      VEC_quick_push (tree, vargs,\n+\t\t\t\t      VEC_index (tree, vec_oprndsk, i + 1));\n+\t\t    }\n+\t\t  new_stmt = gimple_build_call_vec (fndecl, vargs);\n+\t\t  new_temp = make_ssa_name (vec_dest, new_stmt);\n+\t\t  gimple_call_set_lhs (new_stmt, new_temp);\n+\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t\t  mark_symbols_for_renaming (new_stmt);\n+\t\t  VEC_quick_push (gimple, SLP_TREE_VEC_STMTS (slp_node),\n+\t\t\t\t  new_stmt);\n+\t\t}\n+\n+\t      for (i = 0; i < nargs; i++)\n+\t\t{\n+\t\t  VEC (tree, heap) *vec_oprndsi\n+\t\t    = (VEC (tree, heap) *)\n+\t\t      VEC_index (slp_void_p, vec_defs, i);\n+\t\t  VEC_free (tree, heap, vec_oprndsi);\n+\t\t}\n+\t      VEC_free (slp_void_p, heap, vec_defs);\n+\t      continue;\n+\t    }\n+\n \t  for (i = 0; i < nargs; i++)\n \t    {\n \t      op = gimple_call_arg (stmt, i);\n@@ -1804,7 +1893,8 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt)\n     lhs = gimple_call_lhs (stmt);\n   new_stmt = gimple_build_assign (lhs, build_zero_cst (type));\n   set_vinfo_for_stmt (new_stmt, stmt_info);\n-  set_vinfo_for_stmt (stmt, NULL);\n+  if (!slp_node)\n+    set_vinfo_for_stmt (stmt, NULL);\n   STMT_VINFO_STMT (stmt_info) = new_stmt;\n   gsi_replace (gsi, new_stmt, false);\n   SSA_NAME_DEF_STMT (gimple_assign_lhs (new_stmt)) = new_stmt;\n@@ -5265,7 +5355,7 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n             || vectorizable_operation (stmt, NULL, NULL, NULL)\n             || vectorizable_assignment (stmt, NULL, NULL, NULL)\n             || vectorizable_load (stmt, NULL, NULL, NULL, NULL)\n-            || vectorizable_call (stmt, NULL, NULL)\n+\t    || vectorizable_call (stmt, NULL, NULL, NULL)\n             || vectorizable_store (stmt, NULL, NULL, NULL)\n             || vectorizable_reduction (stmt, NULL, NULL, NULL)\n             || vectorizable_condition (stmt, NULL, NULL, NULL, 0, NULL));\n@@ -5277,6 +5367,7 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n                 || vectorizable_operation (stmt, NULL, NULL, node)\n                 || vectorizable_assignment (stmt, NULL, NULL, node)\n                 || vectorizable_load (stmt, NULL, NULL, node, NULL)\n+\t\t|| vectorizable_call (stmt, NULL, NULL, node)\n                 || vectorizable_store (stmt, NULL, NULL, node)\n                 || vectorizable_condition (stmt, NULL, NULL, NULL, 0, node));\n       }\n@@ -5391,8 +5482,7 @@ vect_transform_stmt (gimple stmt, gimple_stmt_iterator *gsi,\n       break;\n \n     case call_vec_info_type:\n-      gcc_assert (!slp_node);\n-      done = vectorizable_call (stmt, gsi, &vec_stmt);\n+      done = vectorizable_call (stmt, gsi, &vec_stmt, slp_node);\n       stmt = gsi_stmt (*gsi);\n       break;\n "}]}