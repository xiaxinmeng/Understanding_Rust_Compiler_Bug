{"sha": "e12605764d9a8d00fea20119b8a34de0afb9c7e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTEyNjA1NzY0ZDlhOGQwMGZlYTIwMTE5YjhhMzRkZTBhZmI5YzdlMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-07-02T14:37:15Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-07-02T14:37:15Z"}, "message": "mips-protos.h (mips16e_save_restore_info): New struct.\n\ngcc/\n2007-07-02  Sandra Loosemore  <sandra@codesourcery.com>\n\t    Richard Sandiford  <richard@codesourcery.com>\n\t    Nigel Stephens  <nigel@mips.com>\n\n\t* config/mips/mips-protos.h (mips16e_save_restore_info): New struct.\n\t(mips16e_output_save_restore): Declare.\n\t(mips16e_save_restore_pattern_p): Likewise.\n\t* config/mips/mips.h (GENERATE_MIPS16E_SAVE_RESTORE): New macro.\n\t* config/mips/mips.c (MIPS_MAX_FIRST_STACK_STEP): Return 0x7f8\n\tfor GENERATE_MIPS16E_SAVE_RESTORE.  Return 0x400 for TARGET_MIPS16\n\t&& !GENERATE_MIPS16E_SAVE_RESTORE && !TARGET_64BIT.\n\t(BITSET_P): New global macro, extracted from...\n\t(mips_for_each_saved_reg): ...here.\n\t(mips16e_save_restore_info): New struct.\n\t(mips16e_s2_s8_regs, mips16e_a0_a3_regs): New variables.\n\t(mips16e_save_restore_regs): New variable.\n\t(mips_split_plus, mips16e_find_first_register): New functions.\n\t(mips16e_mask_registers): New function.\n\t(compute_frame_size): Expand the commentary before the function.\n\tEnforce the MIPS16e save and restore register range restrictions.\n\tPad the general register save area at the low end.\n\t(mips16e_save_restore_reg, mips16e_build_save_restore)\n\t(mips16e_save_restore_pattern_p, mips16e_add_register_range)\n\t(mips16e_output_save_restore, mips16e_collect_propagate_value)\n\t(mips16e_collect_argument_save, mips16e_collect_argument_saves):\n\tNew functions.\n\t(mips_expand_prologue, mips_expand_epilogue): Handle\n\tGENERATE_MIPS16E_SAVE_RESTORE.\n\t* config/mips/mips.md (*mips16e_save_restore): New pattern.\n\ngcc/testsuite/\n\t* gcc.target/mips/save-restore-1.c: New test.\n\t* gcc.target/mips/save-restore-2.c: Likewise.\n\t* gcc.target/mips/save-restore-3.c: Likewise.\n\t* gcc.target/mips/save-restore-4.c: Likewise.\n\nFrom-SVN: r126207", "tree": {"sha": "17ab8b62513a32d9a3ebc0baad0e18672084e65c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17ab8b62513a32d9a3ebc0baad0e18672084e65c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e12605764d9a8d00fea20119b8a34de0afb9c7e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e12605764d9a8d00fea20119b8a34de0afb9c7e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e12605764d9a8d00fea20119b8a34de0afb9c7e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e12605764d9a8d00fea20119b8a34de0afb9c7e1/comments", "author": null, "committer": null, "parents": [{"sha": "8ad02175016741bf92109e29ed27b061ca630d84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ad02175016741bf92109e29ed27b061ca630d84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ad02175016741bf92109e29ed27b061ca630d84"}], "stats": {"total": 799, "additions": 740, "deletions": 59}, "files": [{"sha": "99acea3d4b1a097a726419667b5217949d3f65b7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e12605764d9a8d00fea20119b8a34de0afb9c7e1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e12605764d9a8d00fea20119b8a34de0afb9c7e1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e12605764d9a8d00fea20119b8a34de0afb9c7e1", "patch": "@@ -1,3 +1,33 @@\n+2007-07-02  Sandra Loosemore  <sandra@codesourcery.com>\n+\t    Richard Sandiford  <richard@codesourcery.com>\n+\t    Nigel Stephens  <nigel@mips.com>\n+\n+\t* config/mips/mips-protos.h (mips16e_save_restore_info): New struct.\n+\t(mips16e_output_save_restore): Declare.\n+\t(mips16e_save_restore_pattern_p): Likewise.\n+\t* config/mips/mips.h (GENERATE_MIPS16E_SAVE_RESTORE): New macro.\n+\t* config/mips/mips.c (MIPS_MAX_FIRST_STACK_STEP): Return 0x7f8\n+\tfor GENERATE_MIPS16E_SAVE_RESTORE.  Return 0x400 for TARGET_MIPS16\n+\t&& !GENERATE_MIPS16E_SAVE_RESTORE && !TARGET_64BIT.\n+\t(BITSET_P): New global macro, extracted from...\n+\t(mips_for_each_saved_reg): ...here.\n+\t(mips16e_save_restore_info): New struct.\n+\t(mips16e_s2_s8_regs, mips16e_a0_a3_regs): New variables.\n+\t(mips16e_save_restore_regs): New variable.\n+\t(mips_split_plus, mips16e_find_first_register): New functions.\n+\t(mips16e_mask_registers): New function.\n+\t(compute_frame_size): Expand the commentary before the function.\n+\tEnforce the MIPS16e save and restore register range restrictions.\n+\tPad the general register save area at the low end.\n+\t(mips16e_save_restore_reg, mips16e_build_save_restore)\n+\t(mips16e_save_restore_pattern_p, mips16e_add_register_range)\n+\t(mips16e_output_save_restore, mips16e_collect_propagate_value)\n+\t(mips16e_collect_argument_save, mips16e_collect_argument_saves):\n+\tNew functions.\n+\t(mips_expand_prologue, mips_expand_epilogue): Handle\n+\tGENERATE_MIPS16E_SAVE_RESTORE.\n+\t* config/mips/mips.md (*mips16e_save_restore): New pattern.\n+\n 2007-07-02  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR tree-optimization/31966"}, {"sha": "86b5f03b4e192b1ae52b810e986b7ccc2ea78bbe", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e12605764d9a8d00fea20119b8a34de0afb9c7e1/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e12605764d9a8d00fea20119b8a34de0afb9c7e1/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=e12605764d9a8d00fea20119b8a34de0afb9c7e1", "patch": "@@ -136,6 +136,8 @@ enum mips_loadgp_style {\n   LOADGP_RTP\n };\n \n+struct mips16e_save_restore_info;\n+\n extern bool mips_symbolic_constant_p (rtx, enum mips_symbol_type *);\n extern int mips_regno_mode_ok_for_base_p (int, enum machine_mode, int);\n extern bool mips_stack_address_p (rtx, enum machine_mode);\n@@ -261,4 +263,8 @@ extern const char *current_section_name (void);\n extern unsigned int current_section_flags (void);\n extern bool mips_use_ins_ext_p (rtx, rtx, rtx);\n \n+extern const char *mips16e_output_save_restore (rtx, HOST_WIDE_INT);\n+extern bool mips16e_save_restore_pattern_p (rtx, HOST_WIDE_INT,\n+\t\t\t\t\t    struct mips16e_save_restore_info *);\n+\n #endif /* ! GCC_MIPS_PROTOS_H */"}, {"sha": "575b328fc8273bdde5bf9bd16ae2514b97603f84", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 612, "deletions": 58, "changes": 670, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e12605764d9a8d00fea20119b8a34de0afb9c7e1/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e12605764d9a8d00fea20119b8a34de0afb9c7e1/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=e12605764d9a8d00fea20119b8a34de0afb9c7e1", "patch": "@@ -74,15 +74,25 @@ Boston, MA 02110-1301, USA.  */\n   ((enum mips_symbol_type) (XINT (X, 1) - UNSPEC_ADDRESS_FIRST))\n \n /* The maximum distance between the top of the stack frame and the\n-   value $sp has when we save & restore registers.\n-\n-   Use a maximum gap of 0x100 in the mips16 case.  We can then use\n-   unextended instructions to save and restore registers, and to\n-   allocate and deallocate the top part of the frame.\n-\n-   The value in the !mips16 case must be a SMALL_OPERAND and must\n-   preserve the maximum stack alignment.  */\n-#define MIPS_MAX_FIRST_STACK_STEP (TARGET_MIPS16 ? 0x100 : 0x7ff0)\n+   value $sp has when we save and restore registers.\n+\n+   The value for normal-mode code must be a SMALL_OPERAND and must\n+   preserve the maximum stack alignment.  We therefore use a value\n+   of 0x7ff0 in this case.\n+\n+   MIPS16e SAVE and RESTORE instructions can adjust the stack pointer by\n+   up to 0x7f8 bytes and can usually save or restore all the registers\n+   that we need to save or restore.  (Note that we can only use these\n+   instructions for o32, for which the stack alignment is 8 bytes.)\n+\n+   We use a maximum gap of 0x100 or 0x400 for MIPS16 code when SAVE and\n+   RESTORE are not available.  We can then use unextended instructions\n+   to save and restore registers, and to allocate and deallocate the top\n+   part of the frame.  */\n+#define MIPS_MAX_FIRST_STACK_STEP\t\t\t\t\t\\\n+  (!TARGET_MIPS16 ? 0x7ff0\t\t\t\t\t\t\\\n+   : GENERATE_MIPS16E_SAVE_RESTORE ? 0x7f8\t\t\t\t\\\n+   : TARGET_64BIT ? 0x100 : 0x400)\n \n /* True if INSN is a mips.md pattern or asm statement.  */\n #define USEFUL_INSN_P(INSN)\t\t\t\t\t\t\\\n@@ -112,6 +122,9 @@ Boston, MA 02110-1301, USA.  */\n        (SUBINSN) != NEXT_INSN (SEQ_END (INSN));\t\t\t\t\\\n        (SUBINSN) = NEXT_INSN (SUBINSN))\n \n+/* True if bit BIT is set in VALUE.  */\n+#define BITSET_P(VALUE, BIT) (((VALUE) & (1 << (BIT))) != 0)\n+\n /* Classifies an address.\n \n    ADDRESS_REG\n@@ -540,6 +553,18 @@ struct mips_integer_op {\n    an extra SLL at the end.  */\n #define MIPS_MAX_INTEGER_OPS 7\n \n+/* Information about a MIPS16e SAVE or RESTORE instruction.  */\n+struct mips16e_save_restore_info {\n+  /* The number of argument registers saved by a SAVE instruction.\n+     0 for RESTORE instructions.  */\n+  unsigned int nargs;\n+\n+  /* Bit X is set if the instruction saves or restores GPR X.  */\n+  unsigned int mask;\n+\n+  /* The total number of bytes to allocate.  */\n+  HOST_WIDE_INT size;\n+};\n \n /* Global variables for machine-dependent things.  */\n \n@@ -1113,6 +1138,21 @@ static struct mips_rtx_cost_data const mips_rtx_cost_data[PROCESSOR_MAX] =\n     },\n   };\n \n+/* If a MIPS16e SAVE or RESTORE instruction saves or restores register\n+   mips16e_s2_s8_regs[X], it must also save the registers in indexes\n+   X + 1 onwards.  Likewise mips16e_a0_a3_regs.  */\n+static const unsigned char mips16e_s2_s8_regs[] = {\n+  30, 23, 22, 21, 20, 19, 18\n+};\n+static const unsigned char mips16e_a0_a3_regs[] = {\n+  4, 5, 6, 7\n+};\n+\n+/* A list of the registers that can be saved by the MIPS16e SAVE instruction,\n+   ordered from the uppermost in memory to the lowest in memory.  */\n+static const unsigned char mips16e_save_restore_regs[] = {\n+  31, 30, 23, 22, 21, 20, 19, 18, 17, 16, 7, 6, 5, 4\n+};\n \f\n /* Nonzero if -march should decide the default value of MASK_SOFT_FLOAT.  */\n #ifndef MIPS_MARCH_CONTROLS_SOFT_FLOAT\n@@ -1296,6 +1336,24 @@ mips_comp_type_attributes (tree type1, tree type2)\n   return 1;\n }\n \f\n+/* If X is a PLUS of a CONST_INT, return the two terms in *BASE_PTR\n+   and *OFFSET_PTR.  Return X in *BASE_PTR and 0 in *OFFSET_PTR otherwise.  */\n+\n+static void\n+mips_split_plus (rtx x, rtx *base_ptr, HOST_WIDE_INT *offset_ptr)\n+{\n+  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+    {\n+      *base_ptr = XEXP (x, 0);\n+      *offset_ptr = INTVAL (XEXP (x, 1));\n+    }\n+  else\n+    {\n+      *base_ptr = x;\n+      *offset_ptr = 0;\n+    }\n+}\n+\f\n /* Return true if SYMBOL_REF X is associated with a global symbol\n    (in the STB_GLOBAL sense).  */\n \n@@ -6455,17 +6513,51 @@ mips_save_reg_p (unsigned int regno)\n   return false;\n }\n \n+/* Return the index of the lowest X in the range [0, SIZE) for which\n+   bit REGS[X] is set in MASK.  Return SIZE if there is no such X.  */\n+\n+static unsigned int\n+mips16e_find_first_register (unsigned int mask, const unsigned char *regs,\n+\t\t\t     unsigned int size)\n+{\n+  unsigned int i;\n+\n+  for (i = 0; i < size; i++)\n+    if (BITSET_P (mask, regs[i]))\n+      break;\n+\n+  return i;\n+}\n+\n+/* *MASK_PTR is a mask of general purpose registers and *GP_REG_SIZE_PTR\n+   is the number of bytes that they occupy.  If *MASK_PTR contains REGS[X]\n+   for some X in [0, SIZE), adjust *MASK_PTR and *GP_REG_SIZE_PTR so that\n+   the same is true for all indexes (X, SIZE).  */\n+\n+static void\n+mips16e_mask_registers (unsigned int *mask_ptr, const unsigned char *regs,\n+\t\t\tunsigned int size, HOST_WIDE_INT *gp_reg_size_ptr)\n+{\n+  unsigned int i;\n+\n+  i = mips16e_find_first_register (*mask_ptr, regs, size);\n+  for (i++; i < size; i++)\n+    if (!BITSET_P (*mask_ptr, regs[i]))\n+      {\n+\t*gp_reg_size_ptr += GET_MODE_SIZE (gpr_mode);\n+\t*mask_ptr |= 1 << regs[i];\n+      }\n+}\n \n /* Return the bytes needed to compute the frame pointer from the current\n    stack pointer.  SIZE is the size (in bytes) of the local variables.\n \n    MIPS stack frames look like:\n \n              Before call\t\t        After call\n-        +-----------------------+\t+-----------------------+\n-   high |\t\t\t|       |      \t\t\t|\n-   mem. |\t\t        |\t|\t\t\t|\n-        |  caller's temps.    \t|       |  caller's temps.    \t|\n+   high +-----------------------+\t+-----------------------+\n+   mem. |\t\t\t|       |      \t\t\t|\n+\t|  caller's temps.    \t|       |  caller's temps.    \t|\n \t|       \t\t|       |       \t        |\n         +-----------------------+\t+-----------------------+\n  \t|       \t\t|\t|\t\t        |\n@@ -6475,37 +6567,40 @@ mips_save_reg_p (unsigned int regno)\n  \t|  4 words to save     \t|\t|  4 words to save\t|\n \t|  arguments passed\t|\t|  arguments passed\t|\n \t|  in registers, even\t|\t|  in registers, even\t|\n-    SP->|  if not passed.       |  VFP->|  if not passed.\t|\n-\t+-----------------------+       +-----------------------+\n-\t\t\t\t\t|\t\t        |\n-                                        |  fp register save     |\n-\t\t\t\t\t|\t\t\t|\n+        |  if not passed.       |       |  if not passed.\t|\n+    SP->+-----------------------+  VFP->+-----------------------+\n+\t        (VFP = SP+fp_sp_offset) |\t\t        |\\\n+\t\t\t\t\t|  fp register save     | | fp_reg_size\n+\t\t\t\t\t|\t\t\t|/\n+\t\t       SP+gp_sp_offset->+-----------------------+\n+\t\t\t\t       /|\t\t        |\\\n+\t\t\t\t      | |  gp register save     | | gp_reg_size\n+\t\t       gp_reg_rounded | |       \t\t|/\n+\t\t\t\t      |\t+-----------------------+\n+\t\t\t\t       \\|  alignment padding    |\n \t\t\t\t\t+-----------------------+\n-\t\t\t\t\t|\t\t        |\n-                                        |  gp register save     |\n-                                        |       \t\t|\n+\t\t\t\t\t|\t\t        |\\\n+\t\t\t\t\t|  local variables\t| | var_size\n+\t\t\t\t\t|\t\t\t|/\n \t\t\t\t\t+-----------------------+\n \t\t\t\t\t|\t\t\t|\n-\t\t\t\t\t|  local variables\t|\n+\t\t\t\t\t|  alloca allocations   |\n \t\t\t\t\t|\t\t\t|\n \t\t\t\t\t+-----------------------+\n-\t\t\t\t\t|\t\t\t|\n-                                        |  alloca allocations   |\n-        \t\t\t\t|\t\t\t|\n+\t\t\t\t       /|\t\t\t|\n+\t\t       cprestore_size | |  GP save for V.4 abi\t|\n+\t\t\t\t       \\|\t\t\t|\n \t\t\t\t\t+-----------------------+\n-\t\t\t\t\t|\t\t\t|\n-\t\t\t\t\t|  GP save for V.4 abi\t|\n-\t\t\t\t\t|\t\t\t|\n-\t\t\t\t\t+-----------------------+\n-\t\t\t\t\t|\t\t\t|\n-                                        |  arguments on stack   |\n-        \t\t\t\t|\t\t        |\n-\t\t\t\t\t+-----------------------+\n-                                        |  4 words to save      |\n-\t\t\t\t\t|  arguments passed     |\n-                                        |  in registers, even   |\n-   low                              SP->|  if not passed.       |\n-   memory        \t\t\t+-----------------------+\n+\t\t\t\t\t|\t\t\t|\\\n+\t\t\t\t\t|  arguments on stack   | |\n+\t\t\t\t\t|\t\t        | |\n+\t\t\t\t\t+-----------------------+ |\n+\t\t\t\t\t|  4 words to save      | | args_size\n+\t\t\t\t\t|  arguments passed     | |\n+\t\t\t\t\t|  in registers, even   | |\n+\t\t\t\t\t|  if not passed.       | |\n+   low\t\t\t\t\t|  (TARGET_OLDABI only) |/\n+   memory\t\t\t    SP->+-----------------------+\n \n */\n \n@@ -6571,6 +6666,17 @@ compute_frame_size (HOST_WIDE_INT size)\n \t}\n     }\n \n+  /* The MIPS16e SAVE and RESTORE instructions have two ranges of registers:\n+     $a3-$a0 and $s2-$s8.  If we save one register in the range, we must\n+     save all later registers too.  */\n+  if (GENERATE_MIPS16E_SAVE_RESTORE)\n+    {\n+      mips16e_mask_registers (&mask, mips16e_s2_s8_regs,\n+ \t\t\t      ARRAY_SIZE (mips16e_s2_s8_regs), &gp_reg_size);\n+      mips16e_mask_registers (&mask, mips16e_a0_a3_regs,\n+ \t\t\t      ARRAY_SIZE (mips16e_a0_a3_regs), &gp_reg_size);\n+    }\n+\n   /* This loop must iterate over the same space as its companion in\n      mips_for_each_saved_reg.  */\n   for (regno = (FP_REG_LAST - MAX_FPRS_PER_FMT + 1);\n@@ -6609,8 +6715,12 @@ compute_frame_size (HOST_WIDE_INT size)\n     {\n       HOST_WIDE_INT offset;\n \n-      offset = (args_size + cprestore_size + var_size\n-\t\t+ gp_reg_size - GET_MODE_SIZE (gpr_mode));\n+      /* MIPS16e SAVE and RESTORE instructions require the GP save area\n+\t to be aligned at the high end with any padding at the low end,\n+\t so do it that way all the time.  */\n+      offset = (total_size\n+\t\t- MIPS_STACK_ALIGN (fp_reg_size)\n+\t\t- GET_MODE_SIZE (gpr_mode));\n       cfun->machine->frame.gp_sp_offset = offset;\n       cfun->machine->frame.gp_save_offset = offset - total_size;\n     }\n@@ -6707,8 +6817,6 @@ mips_save_restore_reg (enum machine_mode mode, int regno,\n static void\n mips_for_each_saved_reg (HOST_WIDE_INT sp_offset, mips_save_restore_fn fn)\n {\n-#define BITSET_P(VALUE, BIT) (((VALUE) & (1L << (BIT))) != 0)\n-\n   enum machine_mode fpr_mode;\n   HOST_WIDE_INT offset;\n   int regno;\n@@ -6737,7 +6845,6 @@ mips_for_each_saved_reg (HOST_WIDE_INT sp_offset, mips_save_restore_fn fn)\n \tmips_save_restore_reg (fpr_mode, regno, offset, fn);\n \toffset -= GET_MODE_SIZE (fpr_mode);\n       }\n-#undef BITSET_P\n }\n \f\n /* If we're generating n32 or n64 abicalls, and the current function\n@@ -6984,13 +7091,404 @@ mips_save_reg (rtx reg, rtx mem)\n     }\n }\n \n+/* Return a move between register REGNO and memory location SP + OFFSET.\n+   Make the move a load if RESTORE_P, otherwise make it a frame-related\n+   store.  */\n+\n+static rtx\n+mips16e_save_restore_reg (bool restore_p, HOST_WIDE_INT offset,\n+\t\t\t  unsigned int regno)\n+{\n+  rtx reg, mem;\n+\n+  mem = gen_frame_mem (SImode, plus_constant (stack_pointer_rtx, offset));\n+  reg = gen_rtx_REG (SImode, regno);\n+  return (restore_p\n+\t  ? gen_rtx_SET (VOIDmode, reg, mem)\n+\t  : mips_frame_set (mem, reg));\n+}\n+\n+/* Return RTL for a MIPS16e SAVE or RESTORE instruction; RESTORE_P says which.\n+   The instruction must:\n+\n+     - Allocate or deallocate SIZE bytes in total; SIZE is known\n+       to be nonzero.\n+\n+     - Save or restore as many registers in *MASK_PTR as possible.\n+       The instruction saves the first registers at the top of the\n+       allocated area, with the other registers below it.\n+\n+     - Save NARGS argument registers above the allocated area.\n+\n+   (NARGS is always zero if RESTORE_P.)\n+\n+   The SAVE and RESTORE instructions cannot save and restore all general\n+   registers, so there may be some registers left over for the caller to\n+   handle.  Destructively modify *MASK_PTR so that it contains the registers\n+   that still need to be saved or restored.  The caller can save these\n+   registers in the memory immediately below *OFFSET_PTR, which is a\n+   byte offset from the bottom of the allocated stack area.  */\n+\n+static rtx\n+mips16e_build_save_restore (bool restore_p, unsigned int *mask_ptr,\n+\t\t\t    HOST_WIDE_INT *offset_ptr, unsigned int nargs,\n+\t\t\t    HOST_WIDE_INT size)\n+{\n+  rtx pattern, set;\n+  HOST_WIDE_INT offset, top_offset;\n+  unsigned int i, regno;\n+  int n;\n+\n+  gcc_assert (cfun->machine->frame.fp_reg_size == 0);\n+\n+  /* Calculate the number of elements in the PARALLEL.  We need one element\n+     for the stack adjustment, one for each argument register save, and one\n+     for each additional register move.  */\n+  n = 1 + nargs;\n+  for (i = 0; i < ARRAY_SIZE (mips16e_save_restore_regs); i++)\n+    if (BITSET_P (*mask_ptr, mips16e_save_restore_regs[i]))\n+      n++;\n+\n+  /* Create the final PARALLEL.  */\n+  pattern = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (n));\n+  n = 0;\n+\n+  /* Add the stack pointer adjustment.  */\n+  set = gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+\t\t     plus_constant (stack_pointer_rtx,\n+\t\t\t\t    restore_p ? size : -size));\n+  RTX_FRAME_RELATED_P (set) = 1;\n+  XVECEXP (pattern, 0, n++) = set;\n+\n+  /* Stack offsets in the PARALLEL are relative to the old stack pointer.  */\n+  top_offset = restore_p ? size : 0;\n+\n+  /* Save the arguments.  */\n+  for (i = 0; i < nargs; i++)\n+    {\n+      offset = top_offset + i * GET_MODE_SIZE (gpr_mode);\n+      set = mips16e_save_restore_reg (restore_p, offset, GP_ARG_FIRST + i);\n+      XVECEXP (pattern, 0, n++) = set;\n+    }\n+\n+  /* Then fill in the other register moves.  */\n+  offset = top_offset;\n+  for (i = 0; i < ARRAY_SIZE (mips16e_save_restore_regs); i++)\n+    {\n+      regno = mips16e_save_restore_regs[i];\n+      if (BITSET_P (*mask_ptr, regno))\n+\t{\n+\t  offset -= UNITS_PER_WORD;\n+\t  set = mips16e_save_restore_reg (restore_p, offset, regno);\n+\t  XVECEXP (pattern, 0, n++) = set;\n+\t  *mask_ptr &= ~(1 << regno);\n+\t}\n+    }\n+\n+  /* Tell the caller what offset it should use for the remaining registers.  */\n+  *offset_ptr = size + (offset - top_offset) + size;\n+\n+  gcc_assert (n == XVECLEN (pattern, 0));\n+\n+  return pattern;\n+}\n+\n+/* PATTERN is a PARALLEL whose first element adds ADJUST to the stack\n+   pointer.  Return true if PATTERN matches the kind of instruction\n+   generated by mips16e_build_save_restore.  If INFO is nonnull,\n+   initialize it when returning true.  */\n+\n+bool\n+mips16e_save_restore_pattern_p (rtx pattern, HOST_WIDE_INT adjust,\n+\t\t\t\tstruct mips16e_save_restore_info *info)\n+{\n+  unsigned int i, nargs, mask;\n+  HOST_WIDE_INT top_offset, save_offset, offset, extra;\n+  rtx set, reg, mem, base;\n+  int n;\n+\n+  if (!GENERATE_MIPS16E_SAVE_RESTORE)\n+    return false;\n+\n+  /* Stack offsets in the PARALLEL are relative to the old stack pointer.  */\n+  top_offset = adjust > 0 ? adjust : 0;\n+\n+  /* Interpret all other members of the PARALLEL.  */\n+  save_offset = top_offset - GET_MODE_SIZE (gpr_mode);\n+  mask = 0;\n+  nargs = 0;\n+  i = 0;\n+  for (n = 1; n < XVECLEN (pattern, 0); n++)\n+    {\n+      /* Check that we have a SET.  */\n+      set = XVECEXP (pattern, 0, n);\n+      if (GET_CODE (set) != SET)\n+\treturn false;\n+\n+      /* Check that the SET is a load (if restoring) or a store\n+\t (if saving).  */\n+      mem = adjust > 0 ? SET_SRC (set) : SET_DEST (set);\n+      if (!MEM_P (mem))\n+\treturn false;\n+\n+      /* Check that the address is the sum of the stack pointer and a\n+\t possibly-zero constant offset.  */\n+      mips_split_plus (XEXP (mem, 0), &base, &offset);\n+      if (base != stack_pointer_rtx)\n+\treturn false;\n+\n+      /* Check that SET's other operand is a register.  */\n+      reg = adjust > 0 ? SET_DEST (set) : SET_SRC (set);\n+      if (!REG_P (reg))\n+\treturn false;\n+\n+      /* Check for argument saves.  */\n+      if (offset == top_offset + nargs * GET_MODE_SIZE (gpr_mode)\n+\t  && REGNO (reg) == GP_ARG_FIRST + nargs)\n+\tnargs++;\n+      else if (offset == save_offset)\n+\t{\n+\t  while (mips16e_save_restore_regs[i++] != REGNO (reg))\n+\t    if (i == ARRAY_SIZE (mips16e_save_restore_regs))\n+\t      return false;\n+\n+\t  mask |= 1 << REGNO (reg);\n+\t  save_offset -= GET_MODE_SIZE (gpr_mode);\n+\t}\n+      else\n+\treturn false;\n+    }\n+\n+  /* Check that the restrictions on register ranges are met.  */\n+  extra = 0;\n+  mips16e_mask_registers (&mask, mips16e_s2_s8_regs,\n+\t\t\t  ARRAY_SIZE (mips16e_s2_s8_regs), &extra);\n+  mips16e_mask_registers (&mask, mips16e_a0_a3_regs,\n+\t\t\t  ARRAY_SIZE (mips16e_a0_a3_regs), &extra);\n+  if (extra != 0)\n+    return false;\n+\n+  /* Pass back information, if requested.  */\n+  if (info)\n+    {\n+      info->nargs = nargs;\n+      info->mask = mask;\n+      info->size = (adjust > 0 ? adjust : -adjust);\n+    }\n+\n+  return true;\n+}\n+\n+/* Add a MIPS16e SAVE or RESTORE register-range argument to string S\n+   for the register range [MIN_REG, MAX_REG].  Return a pointer to\n+   the null terminator.  */\n+\n+static char *\n+mips16e_add_register_range (char *s, unsigned int min_reg,\n+\t\t\t    unsigned int max_reg)\n+{\n+  if (min_reg != max_reg)\n+    s += sprintf (s, \",%s-%s\", reg_names[min_reg], reg_names[max_reg]);\n+  else\n+    s += sprintf (s, \",%s\", reg_names[min_reg]);\n+  return s;\n+}\n+\n+/* Return the assembly instruction for a MIPS16e SAVE or RESTORE instruction.\n+   PATTERN and ADJUST are as for mips16e_save_restore_pattern_p.  */\n+\n+const char *\n+mips16e_output_save_restore (rtx pattern, HOST_WIDE_INT adjust)\n+{\n+  static char buffer[300];\n+\n+  struct mips16e_save_restore_info info;\n+  unsigned int i, end;\n+  char *s;\n+\n+  /* Parse the pattern.  */\n+  if (!mips16e_save_restore_pattern_p (pattern, adjust, &info))\n+    gcc_unreachable ();\n+\n+  /* Add the mnemonic.  */\n+  s = strcpy (buffer, adjust > 0 ? \"restore\\t\" : \"save\\t\");\n+  s += strlen (s);\n+\n+  /* Save the arguments.  */\n+  if (info.nargs > 1)\n+    s += sprintf (s, \"%s-%s,\", reg_names[GP_ARG_FIRST],\n+\t\t  reg_names[GP_ARG_FIRST + info.nargs - 1]);\n+  else if (info.nargs == 1)\n+    s += sprintf (s, \"%s,\", reg_names[GP_ARG_FIRST]);\n+\n+  /* Emit the amount of stack space to allocate or deallocate.  */\n+  s += sprintf (s, \"%d\", (int) info.size);\n+\n+  /* Save or restore $16.  */\n+  if (BITSET_P (info.mask, 16))\n+    s += sprintf (s, \",%s\", reg_names[GP_REG_FIRST + 16]);\n+\n+  /* Save or restore $17.  */\n+  if (BITSET_P (info.mask, 17))\n+    s += sprintf (s, \",%s\", reg_names[GP_REG_FIRST + 17]);\n+\n+  /* Save or restore registers in the range $s2...$s8, which\n+     mips16e_s2_s8_regs lists in decreasing order.  Note that this\n+     is a software register range; the hardware registers are not\n+     numbered consecutively.  */\n+  end = ARRAY_SIZE (mips16e_s2_s8_regs);\n+  i = mips16e_find_first_register (info.mask, mips16e_s2_s8_regs, end);\n+  if (i < end)\n+    s = mips16e_add_register_range (s, mips16e_s2_s8_regs[end - 1],\n+\t\t\t\t    mips16e_s2_s8_regs[i]);\n+\n+  /* Save or restore registers in the range $a0...$a3.  */\n+  end = ARRAY_SIZE (mips16e_a0_a3_regs);\n+  i = mips16e_find_first_register (info.mask, mips16e_a0_a3_regs, end);\n+  if (i < end)\n+    s = mips16e_add_register_range (s, mips16e_a0_a3_regs[i],\n+\t\t\t\t    mips16e_a0_a3_regs[end - 1]);\n+\n+  /* Save or restore $31.  */\n+  if (BITSET_P (info.mask, 31))\n+    s += sprintf (s, \",%s\", reg_names[GP_REG_FIRST + 31]);\n+\n+  return buffer;\n+}\n+\n+/* Return a simplified form of X using the register values in REG_VALUES.\n+   REG_VALUES[R] is the last value assigned to hard register R, or null\n+   if R has not been modified.\n+\n+   This function is rather limited, but is good enough for our purposes.  */\n+\n+static rtx\n+mips16e_collect_propagate_value (rtx x, rtx *reg_values)\n+{\n+  rtx x0, x1;\n+\n+  x = avoid_constant_pool_reference (x);\n+\n+  if (UNARY_P (x))\n+    {\n+      x0 = mips16e_collect_propagate_value (XEXP (x, 0), reg_values);\n+      return simplify_gen_unary (GET_CODE (x), GET_MODE (x),\n+\t\t\t\t x0, GET_MODE (XEXP (x, 0)));\n+    }\n+\n+  if (ARITHMETIC_P (x))\n+    {\n+      x0 = mips16e_collect_propagate_value (XEXP (x, 0), reg_values);\n+      x1 = mips16e_collect_propagate_value (XEXP (x, 1), reg_values);\n+      return simplify_gen_binary (GET_CODE (x), GET_MODE (x), x0, x1);\n+    }\n+\n+  if (REG_P (x)\n+      && reg_values[REGNO (x)]\n+      && !rtx_unstable_p (reg_values[REGNO (x)]))\n+    return reg_values[REGNO (x)];\n+\n+  return x;\n+}\n+\n+/* Return true if (set DEST SRC) stores an argument register into its\n+   caller-allocated save slot.  If the register is not included in\n+   [GP_ARG_FIRST, GP_ARG_LAST + *NARGS_PTR), destructively modify\n+   *NARGS_PTR such that this condition holds.  REG_VALUES is as for\n+   mips16e_collect_propagate_value.  */\n+\n+static bool\n+mips16e_collect_argument_save (rtx dest, rtx src, rtx *reg_values,\n+\t\t\t       unsigned int *nargs_ptr)\n+{\n+  unsigned int argno, regno;\n+  HOST_WIDE_INT offset, required_offset;\n+  rtx addr, base;\n+\n+  /* Check that this is a word-mode store.  */\n+  if (!MEM_P (dest) || !REG_P (src) || GET_MODE (dest) != word_mode)\n+    return false;\n+\n+  /* Check that the register being saved is an unmodified argument\n+     register.  */\n+  regno = REGNO (src);\n+  if (regno < GP_ARG_FIRST || regno > GP_ARG_LAST || reg_values[regno])\n+    return false;\n+  argno = regno - GP_ARG_FIRST;\n+\n+  /* Check whether the address is an appropriate stack pointer or\n+     frame pointer access.  The frame pointer is offset from the\n+     stack pointer by the size of the outgoing arguments.  */\n+  addr = mips16e_collect_propagate_value (XEXP (dest, 0), reg_values);\n+  mips_split_plus (addr, &base, &offset);\n+  required_offset = cfun->machine->frame.total_size + argno * UNITS_PER_WORD;\n+  if (base == hard_frame_pointer_rtx)\n+    required_offset -= cfun->machine->frame.args_size;\n+  else if (base != stack_pointer_rtx)\n+    return false;\n+  if (offset != required_offset)\n+    return false;\n+\n+  /* Make sure that *NARGS_PTR is big enough.  */\n+  if (*nargs_ptr <= argno)\n+    *nargs_ptr = argno + 1;\n+\n+  return true;\n+}\n+\n+/* A subroutine of mips_expand_prologue, called only when generating\n+   MIPS16e SAVE instructions.  Search the start of the function for any\n+   instructions that save argument registers into their caller-allocated\n+   save slots.  Delete such instructions and return a value N such that\n+   saving [GP_ARG_FIRST, GP_ARG_FIRST + N) would make all the deleted\n+   instructions redundant.  */\n+\n+static unsigned int\n+mips16e_collect_argument_saves (void)\n+{\n+  rtx reg_values[FIRST_PSEUDO_REGISTER];\n+  rtx insn, next, set, dest, src;\n+  unsigned int nargs;\n+\n+  push_topmost_sequence ();\n+  nargs = 0;\n+  memset (reg_values, 0, sizeof (reg_values));\n+  for (insn = get_insns (); insn; insn = next)\n+    {\n+      next = NEXT_INSN (insn);\n+      if (NOTE_P (insn))\n+\tcontinue;\n+\n+      if (!INSN_P (insn))\n+\tbreak;\n+\n+      set = PATTERN (insn);\n+      if (GET_CODE (set) != SET)\n+\tbreak;\n+\n+      dest = SET_DEST (set);\n+      src = SET_SRC (set);\n+      if (mips16e_collect_argument_save (dest, src, reg_values, &nargs))\n+\tdelete_insn (insn);\n+      else if (REG_P (dest) && GET_MODE (dest) == word_mode)\n+\treg_values[REGNO (dest)]\n+\t  = mips16e_collect_propagate_value (src, reg_values);\n+      else\n+\tbreak;\n+    }\n+  pop_topmost_sequence ();\n+\n+  return nargs;\n+}\n \n /* Expand the prologue into a bunch of separate insns.  */\n \n void\n mips_expand_prologue (void)\n {\n   HOST_WIDE_INT size;\n+  unsigned int nargs;\n+  rtx insn;\n \n   if (cfun->machine->global_pointer > 0)\n     SET_REGNO (pic_offset_table_rtx, cfun->machine->global_pointer);\n@@ -7005,11 +7503,39 @@ mips_expand_prologue (void)\n       HOST_WIDE_INT step1;\n \n       step1 = MIN (size, MIPS_MAX_FIRST_STACK_STEP);\n-      RTX_FRAME_RELATED_P (emit_insn (gen_add3_insn (stack_pointer_rtx,\n-\t\t\t\t\t\t     stack_pointer_rtx,\n-\t\t\t\t\t\t     GEN_INT (-step1)))) = 1;\n-      size -= step1;\n-      mips_for_each_saved_reg (size, mips_save_reg);\n+\n+      if (GENERATE_MIPS16E_SAVE_RESTORE)\n+ \t{\n+ \t  HOST_WIDE_INT offset;\n+ \t  unsigned int mask, regno;\n+\n+\t  /* Try to merge argument stores into the save instruction.  */\n+\t  nargs = mips16e_collect_argument_saves ();\n+\n+\t  /* Build the save instruction.  */\n+\t  mask = cfun->machine->frame.mask;\n+\t  insn = mips16e_build_save_restore (false, &mask, &offset,\n+\t\t\t\t\t     nargs, step1);\n+\t  RTX_FRAME_RELATED_P (emit_insn (insn)) = 1;\n+ \t  size -= step1;\n+\n+ \t  /* Check if we need to save other registers.  */\n+ \t  for (regno = GP_REG_FIRST; regno < GP_REG_LAST; regno++)\n+ \t    if (BITSET_P (mask, regno - GP_REG_FIRST))\n+ \t      {\n+\t\toffset -= GET_MODE_SIZE (gpr_mode);\n+\t\tmips_save_restore_reg (gpr_mode, regno, offset, mips_save_reg);\n+ \t      }\n+ \t}\n+      else\n+ \t{\n+\t  insn = gen_add3_insn (stack_pointer_rtx,\n+\t\t\t\tstack_pointer_rtx,\n+\t\t\t\tGEN_INT (-step1));\n+\t  RTX_FRAME_RELATED_P (emit_insn (insn)) = 1;\n+\t  size -= step1;\n+\t  mips_for_each_saved_reg (size, mips_save_reg);\n+\t}\n     }\n \n   /* Allocate the rest of the frame.  */\n@@ -7249,15 +7775,40 @@ mips_expand_epilogue (int sibcall_p)\n   if (TARGET_CALL_SAVED_GP && !TARGET_EXPLICIT_RELOCS)\n     emit_insn (gen_blockage ());\n \n-  /* Restore the registers.  */\n-  mips_for_each_saved_reg (cfun->machine->frame.total_size - step2,\n-\t\t\t   mips_restore_reg);\n+  if (GENERATE_MIPS16E_SAVE_RESTORE && cfun->machine->frame.mask != 0)\n+    {\n+      unsigned int regno, mask;\n+      HOST_WIDE_INT offset;\n+      rtx restore;\n+\n+      /* Generate the restore instruction.  */\n+      mask = cfun->machine->frame.mask;\n+      restore = mips16e_build_save_restore (true, &mask, &offset, 0, step2);\n+\n+      /* Restore any other registers manually.  */\n+      for (regno = GP_REG_FIRST; regno < GP_REG_LAST; regno++)\n+ \tif (BITSET_P (mask, regno - GP_REG_FIRST))\n+ \t  {\n+ \t    offset -= GET_MODE_SIZE (gpr_mode);\n+ \t    mips_save_restore_reg (gpr_mode, regno, offset, mips_restore_reg);\n+ \t  }\n+\n+      /* Restore the remaining registers and deallocate the final bit\n+\t of the frame.  */\n+      emit_insn (restore);\n+    }\n+  else\n+    {\n+      /* Restore the registers.  */\n+      mips_for_each_saved_reg (cfun->machine->frame.total_size - step2,\n+\t\t\t       mips_restore_reg);\n \n-  /* Deallocate the final bit of the frame.  */\n-  if (step2 > 0)\n-    emit_insn (gen_add3_insn (stack_pointer_rtx,\n-\t\t\t      stack_pointer_rtx,\n-\t\t\t      GEN_INT (step2)));\n+      /* Deallocate the final bit of the frame.  */\n+      if (step2 > 0)\n+\temit_insn (gen_add3_insn (stack_pointer_rtx,\n+\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t  GEN_INT (step2)));\n+    }\n \n   /* Add in the __builtin_eh_return stack adjustment.  We need to\n      use a temporary in mips16 code.  */\n@@ -7279,8 +7830,11 @@ mips_expand_epilogue (int sibcall_p)\n \n   if (!sibcall_p)\n     {\n-      /* The mips16 loads the return address into $7, not $31.  */\n-      if (TARGET_MIPS16 && (cfun->machine->frame.mask & RA_MASK) != 0)\n+      /* When generating MIPS16 code, the normal mips_for_each_saved_reg\n+\t path will restore the return address into $7 rather than $31.  */\n+      if (TARGET_MIPS16\n+\t  && !GENERATE_MIPS16E_SAVE_RESTORE\n+\t  && (cfun->machine->frame.mask & RA_MASK) != 0)\n \temit_jump_insn (gen_return_internal (gen_rtx_REG (Pmode,\n \t\t\t\t\t\t\t  GP_REG_FIRST + 7)));\n       else"}, {"sha": "809c86c3d05ab55a53768658a076e4f9be9af779", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e12605764d9a8d00fea20119b8a34de0afb9c7e1/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e12605764d9a8d00fea20119b8a34de0afb9c7e1/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=e12605764d9a8d00fea20119b8a34de0afb9c7e1", "patch": "@@ -209,6 +209,8 @@ extern const struct mips_rtx_cost_data *mips_cost;\n #define TARGET_MIPS16\t\t((target_flags & MASK_MIPS16) != 0)\n /* Generate mips16e code. Default 16bit ASE for mips32/mips32r2/mips64 */\n #define GENERATE_MIPS16E\t(TARGET_MIPS16 && mips_isa >= 32)\n+/* Generate mips16e register save/restore sequences.  */\n+#define GENERATE_MIPS16E_SAVE_RESTORE (GENERATE_MIPS16E && mips_abi == ABI_32)\n \n /* Generic ISA defines.  */\n #define ISA_MIPS1\t\t    (mips_isa == 1)"}, {"sha": "8a72ae5e11c910f6583c98ff34d6292e978bfbaf", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e12605764d9a8d00fea20119b8a34de0afb9c7e1/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e12605764d9a8d00fea20119b8a34de0afb9c7e1/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=e12605764d9a8d00fea20119b8a34de0afb9c7e1", "patch": "@@ -5583,7 +5583,26 @@\n   \"reload_completed\"\n   [(match_dup 0)]\n   { operands[0] = mips_rewrite_small_data (operands[0]); })\n-\f\n+\n+;;\n+;;  ....................\n+;;\n+;;\tMIPS16e Save/Restore\n+;;\n+;;  ....................\n+;;\n+\n+(define_insn \"*mips16e_save_restore\"\n+  [(match_parallel 0 \"\"\n+       [(set (match_operand:SI 1 \"register_operand\")\n+\t     (plus:SI (match_dup 1)\n+\t\t      (match_operand:SI 2 \"const_int_operand\")))])]\n+  \"operands[1] == stack_pointer_rtx\n+   && mips16e_save_restore_pattern_p (operands[0], INTVAL (operands[2]), NULL)\"\n+  { return mips16e_output_save_restore (operands[0], INTVAL (operands[2])); }\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"extended_mips16\" \"yes\")])\n+\n ; Thread-Local Storage\n \n ; The TLS base pointer is accessed via \"rdhwr $v1, $29\".  No current"}, {"sha": "4eec59e89d5e22a01391d8372fbd51849e18df65", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e12605764d9a8d00fea20119b8a34de0afb9c7e1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e12605764d9a8d00fea20119b8a34de0afb9c7e1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e12605764d9a8d00fea20119b8a34de0afb9c7e1", "patch": "@@ -1,3 +1,10 @@\n+2007-07-02  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* gcc.target/mips/save-restore-1.c: New test.\n+\t* gcc.target/mips/save-restore-2.c: Likewise.\n+\t* gcc.target/mips/save-restore-3.c: Likewise.\n+\t* gcc.target/mips/save-restore-4.c: Likewise.\n+\n 2007-07-02  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR tree-optimization/31966"}, {"sha": "95689b5b618ab7dfa76ea331d9e67e7367103253", "filename": "gcc/testsuite/gcc.target/mips/save-restore-1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e12605764d9a8d00fea20119b8a34de0afb9c7e1/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsave-restore-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e12605764d9a8d00fea20119b8a34de0afb9c7e1/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsave-restore-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsave-restore-1.c?ref=e12605764d9a8d00fea20119b8a34de0afb9c7e1", "patch": "@@ -0,0 +1,19 @@\n+/* Check that we can use the save instruction to save varargs.  */\n+/* { dg-mips-options \"-mips32r2 -mgp32 -mips16 -O2\" } */\n+#include <stdarg.h>\n+\n+int bar (int, va_list ap);\n+\n+int\n+foo (int n, ...)\n+{\n+  va_list ap;\n+  int i;\n+\n+  va_start (ap, n);\n+  i = bar (n, ap);\n+  va_end (ap);\n+  return i + 1;\n+}\n+/* { dg-final { scan-assembler \"\\tsave\\t\\\\\\$4-\\\\\\$7\" } } */\n+/* { dg-final { scan-assembler \"\\trestore\\t\" } } */"}, {"sha": "9a73843fe2c4f798065d085dba75cd589fcf9644", "filename": "gcc/testsuite/gcc.target/mips/save-restore-2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e12605764d9a8d00fea20119b8a34de0afb9c7e1/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsave-restore-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e12605764d9a8d00fea20119b8a34de0afb9c7e1/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsave-restore-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsave-restore-2.c?ref=e12605764d9a8d00fea20119b8a34de0afb9c7e1", "patch": "@@ -0,0 +1,14 @@\n+/* Check that we can use the save instruction to save spilled arguments.  */\n+/* { dg-mips-options \"-mips32r2 -mgp32 -mips16 -O2\" } */\n+void\n+foo (int *a, int b, int c)\n+{\n+  asm volatile (\"\" ::: \"$2\", \"$3\", \"$4\", \"$5\", \"$6\", \"$7\", \"$8\",\n+\t\t\"$9\", \"$10\", \"$11\", \"$12\", \"$13\", \"$14\", \"$15\", \"$16\",\n+\t\t\"$17\", \"$18\", \"$19\", \"$20\", \"$21\", \"$22\", \"$23\", \"$24\",\n+\t\t\"$25\", \"$30\", \"memory\");\n+  a[b] = 1;\n+  a[c] = 1;\n+}\n+/* { dg-final { scan-assembler \"\\tsave\\t\\\\\\$4-\\\\\\$6,\" } } */\n+/* { dg-final { scan-assembler \"\\trestore\\t\" } } */"}, {"sha": "42212365a807680fc64243e7415037f3f915e30b", "filename": "gcc/testsuite/gcc.target/mips/save-restore-3.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e12605764d9a8d00fea20119b8a34de0afb9c7e1/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsave-restore-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e12605764d9a8d00fea20119b8a34de0afb9c7e1/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsave-restore-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsave-restore-3.c?ref=e12605764d9a8d00fea20119b8a34de0afb9c7e1", "patch": "@@ -0,0 +1,19 @@\n+/* Check that we can use the save instruction to save spilled arguments\n+   when the argument save area is out of range of a direct load or store.  */\n+/* { dg-mips-options \"-mips32r2 -mgp32 -mips16 -O2\" } */\n+void bar (int *);\n+\n+void\n+foo (int *a, int b, int c)\n+{\n+  int x[0x4000];\n+  asm volatile (\"\" ::: \"$2\", \"$3\", \"$4\", \"$5\", \"$6\", \"$7\", \"$8\",\n+\t\t\"$9\", \"$10\", \"$11\", \"$12\", \"$13\", \"$14\", \"$15\", \"$16\",\n+\t\t\"$17\", \"$18\", \"$19\", \"$20\", \"$21\", \"$22\", \"$23\", \"$24\",\n+\t\t\"$25\", \"$30\", \"memory\");\n+  bar (x);\n+  a[b] = 1;\n+  a[c] = 1;\n+}\n+/* { dg-final { scan-assembler \"\\tsave\\t\\\\\\$4-\\\\\\$6,\" } } */\n+/* { dg-final { scan-assembler \"\\trestore\\t\" } } */"}, {"sha": "10bf141c47f148dd866886223e8267af5fafcc9d", "filename": "gcc/testsuite/gcc.target/mips/save-restore-4.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e12605764d9a8d00fea20119b8a34de0afb9c7e1/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsave-restore-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e12605764d9a8d00fea20119b8a34de0afb9c7e1/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsave-restore-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsave-restore-4.c?ref=e12605764d9a8d00fea20119b8a34de0afb9c7e1", "patch": "@@ -0,0 +1,11 @@\n+/* Check that we can use the save instruction to save $16, $17 and $31.  */\n+/* { dg-mips-options \"-mips32r2 -mgp32 -mips16 -O2\" } */\n+void bar (void);\n+void\n+foo (void)\n+{\n+  bar ();\n+  asm volatile (\"\" ::: \"$16\", \"$17\");\n+}\n+/* { dg-final { scan-assembler \"\\tsave\\t\\[0-9\\]*,\\\\\\$16,\\\\\\$17,\\\\\\$31\" } } */\n+/* { dg-final { scan-assembler \"\\trestore\\t\\[0-9\\]*,\\\\\\$16,\\\\\\$17,\\\\\\$31\" } } */"}]}