{"sha": "d31398011e31409de9fc3fcc916fcbcd568fc40c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDMxMzk4MDExZTMxNDA5ZGU5ZmMzZmNjOTE2ZmNiY2Q1NjhmYzQwYw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-09-16T17:25:51Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-09-16T17:25:51Z"}, "message": "[PATCH] Move code out of tree-ssa-dom into tree-ssa-scopedtables\n\n\tPR tree-optimization/47679\n\t* tree-ssa-dom.c (enum expr_kind): Moved from here to\n\ttree-ssa-scopedtables.h.\n\t(struct hashable_expr, class expr_hash_elt): Likewise.\n\t(struct expr_elt_hasher, class avail_exprs_stack): Likewise.\n\tMove associated methods into tree-ssa-scopedtables.c.\n\t(avail_expr_hash, initialize_expr_from_cond): Similarly.\n\t(hashable_expr_equal_p, add_expr_commutative): Likewise.\n\t(add_hashable_expr): Likewise.\n\t(record_cond): Delete element directly.\n\t* tree-ssa-scopedtables.h (avail_expr_stack, const_and_copies): Add\n\tprivate copy ctor and assignment operator methods.\n\t(expr_elt_hasher): Inline trivial methods.\n\t(initialize_expr_from_cond): Prototype.\n\t* tree-ssa-scopedtables.c: Add necessary includes, functions and\n\tmethods that were previously in tree-ssa-dom.c.  Improve various\n\tcomments.\n\nFrom-SVN: r227831", "tree": {"sha": "97c6ebe9050734b2f4b82e181065b4e23f7f0fde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97c6ebe9050734b2f4b82e181065b4e23f7f0fde"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d31398011e31409de9fc3fcc916fcbcd568fc40c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d31398011e31409de9fc3fcc916fcbcd568fc40c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d31398011e31409de9fc3fcc916fcbcd568fc40c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d31398011e31409de9fc3fcc916fcbcd568fc40c/comments", "author": null, "committer": null, "parents": [{"sha": "1d44db181fe6bbebf3c2ed3edf523cf87d66304c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d44db181fe6bbebf3c2ed3edf523cf87d66304c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d44db181fe6bbebf3c2ed3edf523cf87d66304c"}], "stats": {"total": 1528, "additions": 770, "deletions": 758}, "files": [{"sha": "49b84380490ba7028d38bc71856a6b981e811529", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d31398011e31409de9fc3fcc916fcbcd568fc40c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d31398011e31409de9fc3fcc916fcbcd568fc40c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d31398011e31409de9fc3fcc916fcbcd568fc40c", "patch": "@@ -1,3 +1,23 @@\n+2015-09-16  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/47679\n+\t* tree-ssa-dom.c (enum expr_kind): Moved from here to\n+\ttree-ssa-scopedtables.h.\n+\t(struct hashable_expr, class expr_hash_elt): Likewise.\n+\t(struct expr_elt_hasher, class avail_exprs_stack): Likewise.\n+\tMove associated methods into tree-ssa-scopedtables.c.\n+\t(avail_expr_hash, initialize_expr_from_cond): Similarly.\n+\t(hashable_expr_equal_p, add_expr_commutative): Likewise.\n+\t(add_hashable_expr): Likewise.\n+\t(record_cond): Delete element directly.\n+\t* tree-ssa-scopedtables.h (avail_expr_stack, const_and_copies): Add\n+\tprivate copy ctor and assignment operator methods.\n+\t(expr_elt_hasher): Inline trivial methods.\n+\t(initialize_expr_from_cond): Prototype.\n+\t* tree-ssa-scopedtables.c: Add necessary includes, functions and\n+\tmethods that were previously in tree-ssa-dom.c.  Improve various\n+\tcomments.\n+\n 2015-09-16  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* doc/invoke.texi ([Wsubobject-linkage]): Extend documentation."}, {"sha": "b97125ae9a0f7c500940e293b739a0b431c58d9d", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 2, "deletions": 758, "changes": 760, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d31398011e31409de9fc3fcc916fcbcd568fc40c/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d31398011e31409de9fc3fcc916fcbcd568fc40c/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=d31398011e31409de9fc3fcc916fcbcd568fc40c", "patch": "@@ -55,33 +55,6 @@ along with GCC; see the file COPYING3.  If not see\n \n /* This file implements optimizations on the dominator tree.  */\n \n-/* Representation of a \"naked\" right-hand-side expression, to be used\n-   in recording available expressions in the expression hash table.  */\n-\n-enum expr_kind\n-{\n-  EXPR_SINGLE,\n-  EXPR_UNARY,\n-  EXPR_BINARY,\n-  EXPR_TERNARY,\n-  EXPR_CALL,\n-  EXPR_PHI\n-};\n-\n-struct hashable_expr\n-{\n-  tree type;\n-  enum expr_kind kind;\n-  union {\n-    struct { tree rhs; } single;\n-    struct { enum tree_code op;  tree opnd; } unary;\n-    struct { enum tree_code op;  tree opnd0, opnd1; } binary;\n-    struct { enum tree_code op;  tree opnd0, opnd1, opnd2; } ternary;\n-    struct { gcall *fn_from; bool pure; size_t nargs; tree *args; } call;\n-    struct { size_t nargs; tree *args; } phi;\n-  } ops;\n-};\n-\n /* Structure for recording known values of a conditional expression\n    at the exits from its block.  */\n \n@@ -91,7 +64,6 @@ struct cond_equivalence\n   tree value;\n };\n \n-\n /* Structure for recording edge equivalences.\n \n    Computing and storing the edge equivalences instead of creating\n@@ -114,137 +86,6 @@ struct edge_info\n   vec<cond_equivalence> cond_equivalences;\n };\n \n-/* Stack of available expressions in AVAIL_EXPRs.  Each block pushes any\n-   expressions it enters into the hash table along with a marker entry\n-   (null).  When we finish processing the block, we pop off entries and\n-   remove the expressions from the global hash table until we hit the\n-   marker.  */\n-typedef struct expr_hash_elt * expr_hash_elt_t;\n-\n-\n-/* Structure for entries in the expression hash table.  */\n-\n-class expr_hash_elt\n-{\n- public:\n-  expr_hash_elt (gimple, tree);\n-  expr_hash_elt (tree);\n-  expr_hash_elt (struct hashable_expr *, tree);\n-  expr_hash_elt (class expr_hash_elt &);\n-  ~expr_hash_elt ();\n-  void print (FILE *);\n-  tree vop (void) { return m_vop; }\n-  tree lhs (void) { return m_lhs; }\n-  struct hashable_expr *expr (void) { return &m_expr; }\n-  expr_hash_elt *stamp (void) { return m_stamp; }\n-  hashval_t hash (void) { return m_hash; }\n-\n- private:\n-  /* The expression (rhs) we want to record.  */\n-  struct hashable_expr m_expr;\n-\n-  /* The value (lhs) of this expression.  */\n-  tree m_lhs;\n-\n-  /* The virtual operand associated with the nearest dominating stmt\n-     loading from or storing to expr.  */\n-  tree m_vop;\n-\n-  /* The hash value for RHS.  */\n-  hashval_t m_hash;\n-\n-  /* A unique stamp, typically the address of the hash\n-     element itself, used in removing entries from the table.  */\n-  struct expr_hash_elt *m_stamp;\n-\n-  /* We should never be making assignments between objects in this class.\n-     Though it might allow us to exploit C++11 move semantics if we\n-     defined the move constructor and move assignment operator.  */\n-  expr_hash_elt& operator=(const expr_hash_elt&);\n-};\n-\n-/* Hashtable helpers.  */\n-\n-static bool hashable_expr_equal_p (const struct hashable_expr *,\n-\t\t\t\t   const struct hashable_expr *);\n-static void free_expr_hash_elt (void *);\n-\n-struct expr_elt_hasher : pointer_hash <expr_hash_elt>\n-{\n-  static inline hashval_t hash (const value_type &);\n-  static inline bool equal (const value_type &, const compare_type &);\n-  static inline void remove (value_type &);\n-};\n-\n-/* This class defines a unwindable AVAIL_EXPRs, built on top of the\n-   available expression hash table.\n-\n-   Essentially it's just a stack of available expression value pairs with\n-   a special marker (NULL, NULL) to indicate unwind points.   */\n-\n-class avail_exprs_stack\n-{\n- public:\n-  /* We need access to the AVAIL_EXPR hash table so that we can\n-     remove entries from the hash table when unwinding the stack.  */\n-  avail_exprs_stack (hash_table<expr_elt_hasher> *table)\n-    { m_stack.create (20); m_avail_exprs = table; }\n-  ~avail_exprs_stack (void) { m_stack.release (); }\n-\n-  /* Push the unwinding marker onto the stack.  */\n-  void push_marker (void) { record_expr (NULL, NULL, 'M'); }\n-\n-  /* Restore the AVAIL_EXPRs table to its state when the last marker\n-     was pushed.  */\n-  void pop_to_marker ();\n-\n-  /* Record a single available expression that can be unwound.  */\n-  void record_expr (expr_hash_elt_t, expr_hash_elt_t, char);\n-\n- private:\n-  vec<std::pair<expr_hash_elt_t, expr_hash_elt_t> > m_stack;\n-  hash_table<expr_elt_hasher> *m_avail_exprs;\n-};\n-\n-\n-inline hashval_t\n-expr_elt_hasher::hash (const value_type &p)\n-{\n-  return p->hash ();\n-}\n-\n-inline bool\n-expr_elt_hasher::equal (const value_type &p1, const compare_type &p2)\n-{\n-  const struct hashable_expr *expr1 = p1->expr ();\n-  const struct expr_hash_elt *stamp1 = p1->stamp ();\n-  const struct hashable_expr *expr2 = p2->expr ();\n-  const struct expr_hash_elt *stamp2 = p2->stamp ();\n-\n-  /* This case should apply only when removing entries from the table.  */\n-  if (stamp1 == stamp2)\n-    return true;\n-\n-  if (p1->hash () != p2->hash ())\n-    return false;\n-\n-  /* In case of a collision, both RHS have to be identical and have the\n-     same VUSE operands.  */\n-  if (hashable_expr_equal_p (expr1, expr2)\n-      && types_compatible_p (expr1->type, expr2->type))\n-    return true;\n-\n-  return false;\n-}\n-\n-/* Delete an expr_hash_elt and reclaim its storage.  */\n-\n-inline void\n-expr_elt_hasher::remove (value_type &element)\n-{\n-  free_expr_hash_elt (element);\n-}\n-\n /* Hash table with expressions made available during the renaming process.\n    When an assignment of the form X_i = EXPR is found, the statement is\n    stored in this table.  If the same expression EXPR is later found on the\n@@ -254,7 +95,7 @@ expr_elt_hasher::remove (value_type &element)\n    in this table.  */\n static hash_table<expr_elt_hasher> *avail_exprs;\n \n-/* Unwindable const/copy equivalences.  */\n+/* Unwindable equivalences, both const/copy and expression varieties.  */\n static const_and_copies *const_and_copies;\n static avail_exprs_stack *avail_exprs_stack;\n \n@@ -281,7 +122,6 @@ static struct opt_stats_d opt_stats;\n /* Local functions.  */\n static void optimize_stmt (basic_block, gimple_stmt_iterator);\n static tree lookup_avail_expr (gimple, bool);\n-static hashval_t avail_expr_hash (class expr_hash_elt *);\n static void htab_statistics (FILE *,\n \t\t\t     const hash_table<expr_elt_hasher> &);\n static void record_cond (cond_equivalence *);\n@@ -292,532 +132,6 @@ static void eliminate_redundant_computations (gimple_stmt_iterator *);\n static void record_equivalences_from_stmt (gimple, int);\n static edge single_incoming_edge_ignoring_loop_edges (basic_block);\n \n-\n-/* Given a statement STMT, initialize the hash table element pointed to\n-   by ELEMENT.  */\n-\n-expr_hash_elt::expr_hash_elt (gimple stmt, tree orig_lhs)\n-{\n-  enum gimple_code code = gimple_code (stmt);\n-  struct hashable_expr *expr = this->expr ();\n-\n-  if (code == GIMPLE_ASSIGN)\n-    {\n-      enum tree_code subcode = gimple_assign_rhs_code (stmt);\n-\n-      switch (get_gimple_rhs_class (subcode))\n-        {\n-        case GIMPLE_SINGLE_RHS:\n-\t  expr->kind = EXPR_SINGLE;\n-\t  expr->type = TREE_TYPE (gimple_assign_rhs1 (stmt));\n-\t  expr->ops.single.rhs = gimple_assign_rhs1 (stmt);\n-\t  break;\n-        case GIMPLE_UNARY_RHS:\n-\t  expr->kind = EXPR_UNARY;\n-\t  expr->type = TREE_TYPE (gimple_assign_lhs (stmt));\n-\t  if (CONVERT_EXPR_CODE_P (subcode))\n-\t    subcode = NOP_EXPR;\n-\t  expr->ops.unary.op = subcode;\n-\t  expr->ops.unary.opnd = gimple_assign_rhs1 (stmt);\n-\t  break;\n-        case GIMPLE_BINARY_RHS:\n-\t  expr->kind = EXPR_BINARY;\n-\t  expr->type = TREE_TYPE (gimple_assign_lhs (stmt));\n-\t  expr->ops.binary.op = subcode;\n-\t  expr->ops.binary.opnd0 = gimple_assign_rhs1 (stmt);\n-\t  expr->ops.binary.opnd1 = gimple_assign_rhs2 (stmt);\n-\t  break;\n-        case GIMPLE_TERNARY_RHS:\n-\t  expr->kind = EXPR_TERNARY;\n-\t  expr->type = TREE_TYPE (gimple_assign_lhs (stmt));\n-\t  expr->ops.ternary.op = subcode;\n-\t  expr->ops.ternary.opnd0 = gimple_assign_rhs1 (stmt);\n-\t  expr->ops.ternary.opnd1 = gimple_assign_rhs2 (stmt);\n-\t  expr->ops.ternary.opnd2 = gimple_assign_rhs3 (stmt);\n-\t  break;\n-        default:\n-          gcc_unreachable ();\n-        }\n-    }\n-  else if (code == GIMPLE_COND)\n-    {\n-      expr->type = boolean_type_node;\n-      expr->kind = EXPR_BINARY;\n-      expr->ops.binary.op = gimple_cond_code (stmt);\n-      expr->ops.binary.opnd0 = gimple_cond_lhs (stmt);\n-      expr->ops.binary.opnd1 = gimple_cond_rhs (stmt);\n-    }\n-  else if (gcall *call_stmt = dyn_cast <gcall *> (stmt))\n-    {\n-      size_t nargs = gimple_call_num_args (call_stmt);\n-      size_t i;\n-\n-      gcc_assert (gimple_call_lhs (call_stmt));\n-\n-      expr->type = TREE_TYPE (gimple_call_lhs (call_stmt));\n-      expr->kind = EXPR_CALL;\n-      expr->ops.call.fn_from = call_stmt;\n-\n-      if (gimple_call_flags (call_stmt) & (ECF_CONST | ECF_PURE))\n-        expr->ops.call.pure = true;\n-      else\n-        expr->ops.call.pure = false;\n-\n-      expr->ops.call.nargs = nargs;\n-      expr->ops.call.args = XCNEWVEC (tree, nargs);\n-      for (i = 0; i < nargs; i++)\n-        expr->ops.call.args[i] = gimple_call_arg (call_stmt, i);\n-    }\n-  else if (gswitch *swtch_stmt = dyn_cast <gswitch *> (stmt))\n-    {\n-      expr->type = TREE_TYPE (gimple_switch_index (swtch_stmt));\n-      expr->kind = EXPR_SINGLE;\n-      expr->ops.single.rhs = gimple_switch_index (swtch_stmt);\n-    }\n-  else if (code == GIMPLE_GOTO)\n-    {\n-      expr->type = TREE_TYPE (gimple_goto_dest (stmt));\n-      expr->kind = EXPR_SINGLE;\n-      expr->ops.single.rhs = gimple_goto_dest (stmt);\n-    }\n-  else if (code == GIMPLE_PHI)\n-    {\n-      size_t nargs = gimple_phi_num_args (stmt);\n-      size_t i;\n-\n-      expr->type = TREE_TYPE (gimple_phi_result (stmt));\n-      expr->kind = EXPR_PHI;\n-      expr->ops.phi.nargs = nargs;\n-      expr->ops.phi.args = XCNEWVEC (tree, nargs);\n-      for (i = 0; i < nargs; i++)\n-        expr->ops.phi.args[i] = gimple_phi_arg_def (stmt, i);\n-\n-    }\n-  else\n-    gcc_unreachable ();\n-\n-  m_lhs = orig_lhs;\n-  m_vop = gimple_vuse (stmt);\n-  m_hash = avail_expr_hash (this);\n-  m_stamp = this;\n-}\n-\n-/* Given a conditional expression COND as a tree, initialize\n-   a hashable_expr expression EXPR.  The conditional must be a\n-   comparison or logical negation.  A constant or a variable is\n-   not permitted.  */\n-\n-static void\n-initialize_expr_from_cond (tree cond, struct hashable_expr *expr)\n-{\n-  expr->type = boolean_type_node;\n-\n-  if (COMPARISON_CLASS_P (cond))\n-    {\n-      expr->kind = EXPR_BINARY;\n-      expr->ops.binary.op = TREE_CODE (cond);\n-      expr->ops.binary.opnd0 = TREE_OPERAND (cond, 0);\n-      expr->ops.binary.opnd1 = TREE_OPERAND (cond, 1);\n-    }\n-  else if (TREE_CODE (cond) == TRUTH_NOT_EXPR)\n-    {\n-      expr->kind = EXPR_UNARY;\n-      expr->ops.unary.op = TRUTH_NOT_EXPR;\n-      expr->ops.unary.opnd = TREE_OPERAND (cond, 0);\n-    }\n-  else\n-    gcc_unreachable ();\n-}\n-\n-/* Given a hashable_expr expression EXPR and an LHS,\n-   initialize the hash table element pointed to by ELEMENT.  */\n-\n-expr_hash_elt::expr_hash_elt (struct hashable_expr *orig, tree orig_lhs)\n-{\n-  m_expr = *orig;\n-  m_lhs = orig_lhs;\n-  m_vop = NULL_TREE;\n-  m_hash = avail_expr_hash (this);\n-  m_stamp = this;\n-}\n-\n-expr_hash_elt::expr_hash_elt (class expr_hash_elt &old_elt)\n-{\n-  m_expr = old_elt.m_expr;\n-  m_lhs = old_elt.m_lhs;\n-  m_vop = old_elt.m_vop;\n-  m_hash = old_elt.m_hash;\n-  m_stamp = this;\n-\n-  /* Now deep copy the malloc'd space for CALL and PHI args.  */\n-  if (old_elt.m_expr.kind == EXPR_CALL)\n-    {\n-      size_t nargs = old_elt.m_expr.ops.call.nargs;\n-      size_t i;\n-\n-      m_expr.ops.call.args = XCNEWVEC (tree, nargs);\n-      for (i = 0; i < nargs; i++)\n-        m_expr.ops.call.args[i] = old_elt.m_expr.ops.call.args[i];\n-    }\n-  else if (old_elt.m_expr.kind == EXPR_PHI)\n-    {\n-      size_t nargs = old_elt.m_expr.ops.phi.nargs;\n-      size_t i;\n-\n-      m_expr.ops.phi.args = XCNEWVEC (tree, nargs);\n-      for (i = 0; i < nargs; i++)\n-        m_expr.ops.phi.args[i] = old_elt.m_expr.ops.phi.args[i];\n-    }\n-}\n-\n-expr_hash_elt::~expr_hash_elt ()\n-{\n-  if (m_expr.kind == EXPR_CALL)\n-    free (m_expr.ops.call.args);\n-  else if (m_expr.kind == EXPR_PHI)\n-    free (m_expr.ops.phi.args);\n-}\n-\n-/* Compare two hashable_expr structures for equivalence.  They are\n-   considered equivalent when the expressions they denote must\n-   necessarily be equal.  The logic is intended to follow that of\n-   operand_equal_p in fold-const.c */\n-\n-static bool\n-hashable_expr_equal_p (const struct hashable_expr *expr0,\n-\t\t       const struct hashable_expr *expr1)\n-{\n-  tree type0 = expr0->type;\n-  tree type1 = expr1->type;\n-\n-  /* If either type is NULL, there is nothing to check.  */\n-  if ((type0 == NULL_TREE) ^ (type1 == NULL_TREE))\n-    return false;\n-\n-  /* If both types don't have the same signedness, precision, and mode,\n-     then we can't consider  them equal.  */\n-  if (type0 != type1\n-      && (TREE_CODE (type0) == ERROR_MARK\n-\t  || TREE_CODE (type1) == ERROR_MARK\n-\t  || TYPE_UNSIGNED (type0) != TYPE_UNSIGNED (type1)\n-\t  || TYPE_PRECISION (type0) != TYPE_PRECISION (type1)\n-\t  || TYPE_MODE (type0) != TYPE_MODE (type1)))\n-    return false;\n-\n-  if (expr0->kind != expr1->kind)\n-    return false;\n-\n-  switch (expr0->kind)\n-    {\n-    case EXPR_SINGLE:\n-      return operand_equal_p (expr0->ops.single.rhs,\n-                              expr1->ops.single.rhs, 0);\n-\n-    case EXPR_UNARY:\n-      if (expr0->ops.unary.op != expr1->ops.unary.op)\n-        return false;\n-\n-      if ((CONVERT_EXPR_CODE_P (expr0->ops.unary.op)\n-           || expr0->ops.unary.op == NON_LVALUE_EXPR)\n-          && TYPE_UNSIGNED (expr0->type) != TYPE_UNSIGNED (expr1->type))\n-        return false;\n-\n-      return operand_equal_p (expr0->ops.unary.opnd,\n-                              expr1->ops.unary.opnd, 0);\n-\n-    case EXPR_BINARY:\n-      if (expr0->ops.binary.op != expr1->ops.binary.op)\n-\treturn false;\n-\n-      if (operand_equal_p (expr0->ops.binary.opnd0,\n-\t\t\t   expr1->ops.binary.opnd0, 0)\n-\t  && operand_equal_p (expr0->ops.binary.opnd1,\n-\t\t\t      expr1->ops.binary.opnd1, 0))\n-\treturn true;\n-\n-      /* For commutative ops, allow the other order.  */\n-      return (commutative_tree_code (expr0->ops.binary.op)\n-\t      && operand_equal_p (expr0->ops.binary.opnd0,\n-\t\t\t\t  expr1->ops.binary.opnd1, 0)\n-\t      && operand_equal_p (expr0->ops.binary.opnd1,\n-\t\t\t\t  expr1->ops.binary.opnd0, 0));\n-\n-    case EXPR_TERNARY:\n-      if (expr0->ops.ternary.op != expr1->ops.ternary.op\n-\t  || !operand_equal_p (expr0->ops.ternary.opnd2,\n-\t\t\t       expr1->ops.ternary.opnd2, 0))\n-\treturn false;\n-\n-      if (operand_equal_p (expr0->ops.ternary.opnd0,\n-\t\t\t   expr1->ops.ternary.opnd0, 0)\n-\t  && operand_equal_p (expr0->ops.ternary.opnd1,\n-\t\t\t      expr1->ops.ternary.opnd1, 0))\n-\treturn true;\n-\n-      /* For commutative ops, allow the other order.  */\n-      return (commutative_ternary_tree_code (expr0->ops.ternary.op)\n-\t      && operand_equal_p (expr0->ops.ternary.opnd0,\n-\t\t\t\t  expr1->ops.ternary.opnd1, 0)\n-\t      && operand_equal_p (expr0->ops.ternary.opnd1,\n-\t\t\t\t  expr1->ops.ternary.opnd0, 0));\n-\n-    case EXPR_CALL:\n-      {\n-        size_t i;\n-\n-        /* If the calls are to different functions, then they\n-           clearly cannot be equal.  */\n-        if (!gimple_call_same_target_p (expr0->ops.call.fn_from,\n-                                        expr1->ops.call.fn_from))\n-          return false;\n-\n-        if (! expr0->ops.call.pure)\n-          return false;\n-\n-        if (expr0->ops.call.nargs !=  expr1->ops.call.nargs)\n-          return false;\n-\n-        for (i = 0; i < expr0->ops.call.nargs; i++)\n-          if (! operand_equal_p (expr0->ops.call.args[i],\n-                                 expr1->ops.call.args[i], 0))\n-            return false;\n-\n-\tif (stmt_could_throw_p (expr0->ops.call.fn_from))\n-\t  {\n-\t    int lp0 = lookup_stmt_eh_lp (expr0->ops.call.fn_from);\n-\t    int lp1 = lookup_stmt_eh_lp (expr1->ops.call.fn_from);\n-\t    if ((lp0 > 0 || lp1 > 0) && lp0 != lp1)\n-\t      return false;\n-\t  }\n-\n-        return true;\n-      }\n-\n-    case EXPR_PHI:\n-      {\n-        size_t i;\n-\n-        if (expr0->ops.phi.nargs !=  expr1->ops.phi.nargs)\n-          return false;\n-\n-        for (i = 0; i < expr0->ops.phi.nargs; i++)\n-          if (! operand_equal_p (expr0->ops.phi.args[i],\n-                                 expr1->ops.phi.args[i], 0))\n-            return false;\n-\n-        return true;\n-      }\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-/* Generate a hash value for a pair of expressions.  This can be used\n-   iteratively by passing a previous result in HSTATE.\n-\n-   The same hash value is always returned for a given pair of expressions,\n-   regardless of the order in which they are presented.  This is useful in\n-   hashing the operands of commutative functions.  */\n-\n-namespace inchash\n-{\n-\n-static void\n-add_expr_commutative (const_tree t1, const_tree t2, hash &hstate)\n-{\n-  hash one, two;\n-\n-  inchash::add_expr (t1, one);\n-  inchash::add_expr (t2, two);\n-  hstate.add_commutative (one, two);\n-}\n-\n-/* Compute a hash value for a hashable_expr value EXPR and a\n-   previously accumulated hash value VAL.  If two hashable_expr\n-   values compare equal with hashable_expr_equal_p, they must\n-   hash to the same value, given an identical value of VAL.\n-   The logic is intended to follow inchash::add_expr in tree.c.  */\n-\n-static void\n-add_hashable_expr (const struct hashable_expr *expr, hash &hstate)\n-{\n-  switch (expr->kind)\n-    {\n-    case EXPR_SINGLE:\n-      inchash::add_expr (expr->ops.single.rhs, hstate);\n-      break;\n-\n-    case EXPR_UNARY:\n-      hstate.add_object (expr->ops.unary.op);\n-\n-      /* Make sure to include signedness in the hash computation.\n-         Don't hash the type, that can lead to having nodes which\n-         compare equal according to operand_equal_p, but which\n-         have different hash codes.  */\n-      if (CONVERT_EXPR_CODE_P (expr->ops.unary.op)\n-          || expr->ops.unary.op == NON_LVALUE_EXPR)\n-        hstate.add_int (TYPE_UNSIGNED (expr->type));\n-\n-      inchash::add_expr (expr->ops.unary.opnd, hstate);\n-      break;\n-\n-    case EXPR_BINARY:\n-      hstate.add_object (expr->ops.binary.op);\n-      if (commutative_tree_code (expr->ops.binary.op))\n-\tinchash::add_expr_commutative (expr->ops.binary.opnd0,\n-\t\t\t\t\t  expr->ops.binary.opnd1, hstate);\n-      else\n-        {\n-          inchash::add_expr (expr->ops.binary.opnd0, hstate);\n-          inchash::add_expr (expr->ops.binary.opnd1, hstate);\n-        }\n-      break;\n-\n-    case EXPR_TERNARY:\n-      hstate.add_object (expr->ops.ternary.op);\n-      if (commutative_ternary_tree_code (expr->ops.ternary.op))\n-\tinchash::add_expr_commutative (expr->ops.ternary.opnd0,\n-\t\t\t\t\t  expr->ops.ternary.opnd1, hstate);\n-      else\n-        {\n-          inchash::add_expr (expr->ops.ternary.opnd0, hstate);\n-          inchash::add_expr (expr->ops.ternary.opnd1, hstate);\n-        }\n-      inchash::add_expr (expr->ops.ternary.opnd2, hstate);\n-      break;\n-\n-    case EXPR_CALL:\n-      {\n-        size_t i;\n-        enum tree_code code = CALL_EXPR;\n-        gcall *fn_from;\n-\n-        hstate.add_object (code);\n-        fn_from = expr->ops.call.fn_from;\n-        if (gimple_call_internal_p (fn_from))\n-          hstate.merge_hash ((hashval_t) gimple_call_internal_fn (fn_from));\n-        else\n-          inchash::add_expr (gimple_call_fn (fn_from), hstate);\n-        for (i = 0; i < expr->ops.call.nargs; i++)\n-          inchash::add_expr (expr->ops.call.args[i], hstate);\n-      }\n-      break;\n-\n-    case EXPR_PHI:\n-      {\n-        size_t i;\n-\n-        for (i = 0; i < expr->ops.phi.nargs; i++)\n-          inchash::add_expr (expr->ops.phi.args[i], hstate);\n-      }\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-}\n-\n-/* Print a diagnostic dump of an expression hash table entry.  */\n-\n-void\n-expr_hash_elt::print (FILE *stream)\n-{\n-  fprintf (stream, \"STMT \");\n-\n-  if (m_lhs)\n-    {\n-      print_generic_expr (stream, m_lhs, 0);\n-      fprintf (stream, \" = \");\n-    }\n-\n-  switch (m_expr.kind)\n-    {\n-      case EXPR_SINGLE:\n-        print_generic_expr (stream, m_expr.ops.single.rhs, 0);\n-        break;\n-\n-      case EXPR_UNARY:\n-\tfprintf (stream, \"%s \", get_tree_code_name (m_expr.ops.unary.op));\n-        print_generic_expr (stream, m_expr.ops.unary.opnd, 0);\n-        break;\n-\n-      case EXPR_BINARY:\n-        print_generic_expr (stream, m_expr.ops.binary.opnd0, 0);\n-\tfprintf (stream, \" %s \", get_tree_code_name (m_expr.ops.binary.op));\n-        print_generic_expr (stream, m_expr.ops.binary.opnd1, 0);\n-        break;\n-\n-      case EXPR_TERNARY:\n-\tfprintf (stream, \" %s <\", get_tree_code_name (m_expr.ops.ternary.op));\n-        print_generic_expr (stream, m_expr.ops.ternary.opnd0, 0);\n-\tfputs (\", \", stream);\n-        print_generic_expr (stream, m_expr.ops.ternary.opnd1, 0);\n-\tfputs (\", \", stream);\n-        print_generic_expr (stream, m_expr.ops.ternary.opnd2, 0);\n-\tfputs (\">\", stream);\n-        break;\n-\n-      case EXPR_CALL:\n-        {\n-          size_t i;\n-          size_t nargs = m_expr.ops.call.nargs;\n-          gcall *fn_from;\n-\n-          fn_from = m_expr.ops.call.fn_from;\n-          if (gimple_call_internal_p (fn_from))\n-            fputs (internal_fn_name (gimple_call_internal_fn (fn_from)),\n-                   stream);\n-          else\n-            print_generic_expr (stream, gimple_call_fn (fn_from), 0);\n-          fprintf (stream, \" (\");\n-          for (i = 0; i < nargs; i++)\n-            {\n-              print_generic_expr (stream, m_expr.ops.call.args[i], 0);\n-              if (i + 1 < nargs)\n-                fprintf (stream, \", \");\n-            }\n-          fprintf (stream, \")\");\n-        }\n-        break;\n-\n-      case EXPR_PHI:\n-        {\n-          size_t i;\n-          size_t nargs = m_expr.ops.phi.nargs;\n-\n-          fprintf (stream, \"PHI <\");\n-          for (i = 0; i < nargs; i++)\n-            {\n-              print_generic_expr (stream, m_expr.ops.phi.args[i], 0);\n-              if (i + 1 < nargs)\n-                fprintf (stream, \", \");\n-            }\n-          fprintf (stream, \">\");\n-        }\n-        break;\n-    }\n-\n-  if (m_vop)\n-    {\n-      fprintf (stream, \" with \");\n-      print_generic_expr (stream, m_vop, 0);\n-    }\n-\n-  fprintf (stream, \"\\n\");\n-}\n-\n-/* Delete an expr_hash_elt and reclaim its storage.  */\n-\n-static void\n-free_expr_hash_elt (void *elt)\n-{\n-  class expr_hash_elt *element = ((class expr_hash_elt *)elt);\n-  delete element;\n-}\n-\n /* Allocate an EDGE_INFO for edge E and attach it to E.\n    Return the new EDGE_INFO structure.  */\n \n@@ -1416,61 +730,6 @@ canonicalize_comparison (gcond *condstmt)\n     }\n }\n \n-/* Initialize local stacks for this optimizer and record equivalences\n-   upon entry to BB.  Equivalences can come from the edge traversed to\n-   reach BB or they may come from PHI nodes at the start of BB.  */\n-\n-/* Remove all the expressions in LOCALS from TABLE, stopping when there are\n-   LIMIT entries left in LOCALs.  */\n-\n-void\n-avail_exprs_stack::pop_to_marker ()\n-{\n-  /* Remove all the expressions made available in this block.  */\n-  while (m_stack.length () > 0)\n-    {\n-      std::pair<expr_hash_elt_t, expr_hash_elt_t> victim = m_stack.pop ();\n-      expr_hash_elt **slot;\n-\n-      if (victim.first == NULL)\n-\tbreak;\n-\n-      /* This must precede the actual removal from the hash table,\n-         as ELEMENT and the table entry may share a call argument\n-         vector which will be freed during removal.  */\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-        {\n-          fprintf (dump_file, \"<<<< \");\n-\t  victim.first->print (dump_file);\n-        }\n-\n-      slot = m_avail_exprs->find_slot (victim.first, NO_INSERT);\n-      gcc_assert (slot && *slot == victim.first);\n-      if (victim.second != NULL)\n-\t{\n-\t  free_expr_hash_elt (*slot);\n-\t  *slot = victim.second;\n-\t}\n-      else\n-\tm_avail_exprs->clear_slot (slot);\n-    }\n-}\n-\n-void\n-avail_exprs_stack::record_expr (class expr_hash_elt *elt1,\n-\t\t\t\tclass expr_hash_elt *elt2,\n-\t\t\t\tchar type)\n-{\n-  if (elt1 && dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"%c>>> \", type);\n-      elt1->print (dump_file);\n-    }\n-\n-  m_stack.safe_push (std::pair<expr_hash_elt_t, expr_hash_elt_t> (elt1, elt2));\n-}\n-\n-\n /* A trivial wrapper so that we can present the generic jump\n    threading code with a simple API for simplifying statements.  */\n static tree\n@@ -1792,7 +1051,7 @@ record_cond (cond_equivalence *p)\n       avail_exprs_stack->record_expr (element, NULL, '1');\n     }\n   else\n-    free_expr_hash_elt (element);\n+    delete element;\n }\n \n /* Return the loop depth of the basic block of the defining statement of X.\n@@ -2707,21 +1966,6 @@ lookup_avail_expr (gimple stmt, bool insert)\n   return lhs;\n }\n \n-/* Hashing and equality functions for AVAIL_EXPRS.  We compute a value number\n-   for expressions using the code of the expression and the SSA numbers of\n-   its operands.  */\n-\n-static hashval_t\n-avail_expr_hash (class expr_hash_elt *p)\n-{\n-  const struct hashable_expr *expr = p->expr ();\n-  inchash::hash hstate;\n-\n-  inchash::add_hashable_expr (expr, hstate);\n-\n-  return hstate.end ();\n-}\n-\n /* PHI-ONLY copy and constant propagation.  This pass is meant to clean\n    up degenerate PHIs created by or exposed by jump threading.  */\n "}, {"sha": "7ef085e38f8737c64a8cb9474097e7a82d14b2c5", "filename": "gcc/tree-ssa-scopedtables.c", "status": "modified", "additions": 627, "deletions": 0, "changes": 627, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d31398011e31409de9fc3fcc916fcbcd568fc40c/gcc%2Ftree-ssa-scopedtables.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d31398011e31409de9fc3fcc916fcbcd568fc40c/gcc%2Ftree-ssa-scopedtables.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-scopedtables.c?ref=d31398011e31409de9fc3fcc916fcbcd568fc40c", "patch": "@@ -27,6 +27,581 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"tree-ssa-scopedtables.h\"\n #include \"tree-ssa-threadedge.h\"\n+#include \"tree-ssa-dom.h\"\n+#include \"function.h\"\n+#include \"stor-layout.h\"\n+#include \"fold-const.h\"\n+#include \"basic-block.h\"\n+#include \"tree-eh.h\"\n+#include \"internal-fn.h\"\n+#include \"gimple.h\"\n+#include \"dumpfile.h\"\n+\n+static bool hashable_expr_equal_p (const struct hashable_expr *,\n+\t\t\t\t   const struct hashable_expr *);\n+\n+/* Initialize local stacks for this optimizer and record equivalences\n+   upon entry to BB.  Equivalences can come from the edge traversed to\n+   reach BB or they may come from PHI nodes at the start of BB.  */\n+\n+/* Pop items off the unwinding stack, removing each from the hash table\n+   until a marker is encountered.  */\n+\n+void\n+avail_exprs_stack::pop_to_marker ()\n+{\n+  /* Remove all the expressions made available in this block.  */\n+  while (m_stack.length () > 0)\n+    {\n+      std::pair<expr_hash_elt_t, expr_hash_elt_t> victim = m_stack.pop ();\n+      expr_hash_elt **slot;\n+\n+      if (victim.first == NULL)\n+\tbreak;\n+\n+      /* This must precede the actual removal from the hash table,\n+         as ELEMENT and the table entry may share a call argument\n+         vector which will be freed during removal.  */\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+        {\n+          fprintf (dump_file, \"<<<< \");\n+\t  victim.first->print (dump_file);\n+        }\n+\n+      slot = m_avail_exprs->find_slot (victim.first, NO_INSERT);\n+      gcc_assert (slot && *slot == victim.first);\n+      if (victim.second != NULL)\n+\t{\n+\t  delete *slot;\n+\t  *slot = victim.second;\n+\t}\n+      else\n+\tm_avail_exprs->clear_slot (slot);\n+    }\n+}\n+\n+/* Add <ELT1,ELT2> to the unwinding stack so they can be later removed\n+   from the hash table.  */\n+\n+void\n+avail_exprs_stack::record_expr (class expr_hash_elt *elt1,\n+\t\t\t\tclass expr_hash_elt *elt2,\n+\t\t\t\tchar type)\n+{\n+  if (elt1 && dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"%c>>> \", type);\n+      elt1->print (dump_file);\n+    }\n+\n+  m_stack.safe_push (std::pair<expr_hash_elt_t, expr_hash_elt_t> (elt1, elt2));\n+}\n+\n+/* Generate a hash value for a pair of expressions.  This can be used\n+   iteratively by passing a previous result in HSTATE.\n+\n+   The same hash value is always returned for a given pair of expressions,\n+   regardless of the order in which they are presented.  This is useful in\n+   hashing the operands of commutative functions.  */\n+\n+namespace inchash\n+{\n+\n+static void\n+add_expr_commutative (const_tree t1, const_tree t2, hash &hstate)\n+{\n+  hash one, two;\n+\n+  inchash::add_expr (t1, one);\n+  inchash::add_expr (t2, two);\n+  hstate.add_commutative (one, two);\n+}\n+\n+/* Compute a hash value for a hashable_expr value EXPR and a\n+   previously accumulated hash value VAL.  If two hashable_expr\n+   values compare equal with hashable_expr_equal_p, they must\n+   hash to the same value, given an identical value of VAL.\n+   The logic is intended to follow inchash::add_expr in tree.c.  */\n+\n+static void\n+add_hashable_expr (const struct hashable_expr *expr, hash &hstate)\n+{\n+  switch (expr->kind)\n+    {\n+    case EXPR_SINGLE:\n+      inchash::add_expr (expr->ops.single.rhs, hstate);\n+      break;\n+\n+    case EXPR_UNARY:\n+      hstate.add_object (expr->ops.unary.op);\n+\n+      /* Make sure to include signedness in the hash computation.\n+         Don't hash the type, that can lead to having nodes which\n+         compare equal according to operand_equal_p, but which\n+         have different hash codes.  */\n+      if (CONVERT_EXPR_CODE_P (expr->ops.unary.op)\n+          || expr->ops.unary.op == NON_LVALUE_EXPR)\n+        hstate.add_int (TYPE_UNSIGNED (expr->type));\n+\n+      inchash::add_expr (expr->ops.unary.opnd, hstate);\n+      break;\n+\n+    case EXPR_BINARY:\n+      hstate.add_object (expr->ops.binary.op);\n+      if (commutative_tree_code (expr->ops.binary.op))\n+\tinchash::add_expr_commutative (expr->ops.binary.opnd0,\n+\t\t\t\t\t  expr->ops.binary.opnd1, hstate);\n+      else\n+        {\n+          inchash::add_expr (expr->ops.binary.opnd0, hstate);\n+          inchash::add_expr (expr->ops.binary.opnd1, hstate);\n+        }\n+      break;\n+\n+    case EXPR_TERNARY:\n+      hstate.add_object (expr->ops.ternary.op);\n+      if (commutative_ternary_tree_code (expr->ops.ternary.op))\n+\tinchash::add_expr_commutative (expr->ops.ternary.opnd0,\n+\t\t\t\t\t  expr->ops.ternary.opnd1, hstate);\n+      else\n+        {\n+          inchash::add_expr (expr->ops.ternary.opnd0, hstate);\n+          inchash::add_expr (expr->ops.ternary.opnd1, hstate);\n+        }\n+      inchash::add_expr (expr->ops.ternary.opnd2, hstate);\n+      break;\n+\n+    case EXPR_CALL:\n+      {\n+        size_t i;\n+        enum tree_code code = CALL_EXPR;\n+        gcall *fn_from;\n+\n+        hstate.add_object (code);\n+        fn_from = expr->ops.call.fn_from;\n+        if (gimple_call_internal_p (fn_from))\n+          hstate.merge_hash ((hashval_t) gimple_call_internal_fn (fn_from));\n+        else\n+          inchash::add_expr (gimple_call_fn (fn_from), hstate);\n+        for (i = 0; i < expr->ops.call.nargs; i++)\n+          inchash::add_expr (expr->ops.call.args[i], hstate);\n+      }\n+      break;\n+\n+    case EXPR_PHI:\n+      {\n+        size_t i;\n+\n+        for (i = 0; i < expr->ops.phi.nargs; i++)\n+          inchash::add_expr (expr->ops.phi.args[i], hstate);\n+      }\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+}\n+\n+/* Hashing and equality functions.  We compute a value number for expressions\n+   using the code of the expression and the SSA numbers of its operands.  */\n+\n+static hashval_t\n+avail_expr_hash (class expr_hash_elt *p)\n+{\n+  const struct hashable_expr *expr = p->expr ();\n+  inchash::hash hstate;\n+\n+  inchash::add_hashable_expr (expr, hstate);\n+\n+  return hstate.end ();\n+}\n+\n+/* Compare two hashable_expr structures for equivalence.  They are\n+   considered equivalent when the expressions they denote must\n+   necessarily be equal.  The logic is intended to follow that of\n+   operand_equal_p in fold-const.c */\n+\n+static bool\n+hashable_expr_equal_p (const struct hashable_expr *expr0,\n+\t\t       const struct hashable_expr *expr1)\n+{\n+  tree type0 = expr0->type;\n+  tree type1 = expr1->type;\n+\n+  /* If either type is NULL, there is nothing to check.  */\n+  if ((type0 == NULL_TREE) ^ (type1 == NULL_TREE))\n+    return false;\n+\n+  /* If both types don't have the same signedness, precision, and mode,\n+     then we can't consider  them equal.  */\n+  if (type0 != type1\n+      && (TREE_CODE (type0) == ERROR_MARK\n+\t  || TREE_CODE (type1) == ERROR_MARK\n+\t  || TYPE_UNSIGNED (type0) != TYPE_UNSIGNED (type1)\n+\t  || TYPE_PRECISION (type0) != TYPE_PRECISION (type1)\n+\t  || TYPE_MODE (type0) != TYPE_MODE (type1)))\n+    return false;\n+\n+  if (expr0->kind != expr1->kind)\n+    return false;\n+\n+  switch (expr0->kind)\n+    {\n+    case EXPR_SINGLE:\n+      return operand_equal_p (expr0->ops.single.rhs,\n+                              expr1->ops.single.rhs, 0);\n+\n+    case EXPR_UNARY:\n+      if (expr0->ops.unary.op != expr1->ops.unary.op)\n+        return false;\n+\n+      if ((CONVERT_EXPR_CODE_P (expr0->ops.unary.op)\n+           || expr0->ops.unary.op == NON_LVALUE_EXPR)\n+          && TYPE_UNSIGNED (expr0->type) != TYPE_UNSIGNED (expr1->type))\n+        return false;\n+\n+      return operand_equal_p (expr0->ops.unary.opnd,\n+                              expr1->ops.unary.opnd, 0);\n+\n+    case EXPR_BINARY:\n+      if (expr0->ops.binary.op != expr1->ops.binary.op)\n+\treturn false;\n+\n+      if (operand_equal_p (expr0->ops.binary.opnd0,\n+\t\t\t   expr1->ops.binary.opnd0, 0)\n+\t  && operand_equal_p (expr0->ops.binary.opnd1,\n+\t\t\t      expr1->ops.binary.opnd1, 0))\n+\treturn true;\n+\n+      /* For commutative ops, allow the other order.  */\n+      return (commutative_tree_code (expr0->ops.binary.op)\n+\t      && operand_equal_p (expr0->ops.binary.opnd0,\n+\t\t\t\t  expr1->ops.binary.opnd1, 0)\n+\t      && operand_equal_p (expr0->ops.binary.opnd1,\n+\t\t\t\t  expr1->ops.binary.opnd0, 0));\n+\n+    case EXPR_TERNARY:\n+      if (expr0->ops.ternary.op != expr1->ops.ternary.op\n+\t  || !operand_equal_p (expr0->ops.ternary.opnd2,\n+\t\t\t       expr1->ops.ternary.opnd2, 0))\n+\treturn false;\n+\n+      if (operand_equal_p (expr0->ops.ternary.opnd0,\n+\t\t\t   expr1->ops.ternary.opnd0, 0)\n+\t  && operand_equal_p (expr0->ops.ternary.opnd1,\n+\t\t\t      expr1->ops.ternary.opnd1, 0))\n+\treturn true;\n+\n+      /* For commutative ops, allow the other order.  */\n+      return (commutative_ternary_tree_code (expr0->ops.ternary.op)\n+\t      && operand_equal_p (expr0->ops.ternary.opnd0,\n+\t\t\t\t  expr1->ops.ternary.opnd1, 0)\n+\t      && operand_equal_p (expr0->ops.ternary.opnd1,\n+\t\t\t\t  expr1->ops.ternary.opnd0, 0));\n+\n+    case EXPR_CALL:\n+      {\n+        size_t i;\n+\n+        /* If the calls are to different functions, then they\n+           clearly cannot be equal.  */\n+        if (!gimple_call_same_target_p (expr0->ops.call.fn_from,\n+                                        expr1->ops.call.fn_from))\n+          return false;\n+\n+        if (! expr0->ops.call.pure)\n+          return false;\n+\n+        if (expr0->ops.call.nargs !=  expr1->ops.call.nargs)\n+          return false;\n+\n+        for (i = 0; i < expr0->ops.call.nargs; i++)\n+          if (! operand_equal_p (expr0->ops.call.args[i],\n+                                 expr1->ops.call.args[i], 0))\n+            return false;\n+\n+\tif (stmt_could_throw_p (expr0->ops.call.fn_from))\n+\t  {\n+\t    int lp0 = lookup_stmt_eh_lp (expr0->ops.call.fn_from);\n+\t    int lp1 = lookup_stmt_eh_lp (expr1->ops.call.fn_from);\n+\t    if ((lp0 > 0 || lp1 > 0) && lp0 != lp1)\n+\t      return false;\n+\t  }\n+\n+        return true;\n+      }\n+\n+    case EXPR_PHI:\n+      {\n+        size_t i;\n+\n+        if (expr0->ops.phi.nargs !=  expr1->ops.phi.nargs)\n+          return false;\n+\n+        for (i = 0; i < expr0->ops.phi.nargs; i++)\n+          if (! operand_equal_p (expr0->ops.phi.args[i],\n+                                 expr1->ops.phi.args[i], 0))\n+            return false;\n+\n+        return true;\n+      }\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Given a statement STMT, construct a hash table element.  */\n+\n+expr_hash_elt::expr_hash_elt (gimple stmt, tree orig_lhs)\n+{\n+  enum gimple_code code = gimple_code (stmt);\n+  struct hashable_expr *expr = this->expr ();\n+\n+  if (code == GIMPLE_ASSIGN)\n+    {\n+      enum tree_code subcode = gimple_assign_rhs_code (stmt);\n+\n+      switch (get_gimple_rhs_class (subcode))\n+        {\n+        case GIMPLE_SINGLE_RHS:\n+\t  expr->kind = EXPR_SINGLE;\n+\t  expr->type = TREE_TYPE (gimple_assign_rhs1 (stmt));\n+\t  expr->ops.single.rhs = gimple_assign_rhs1 (stmt);\n+\t  break;\n+        case GIMPLE_UNARY_RHS:\n+\t  expr->kind = EXPR_UNARY;\n+\t  expr->type = TREE_TYPE (gimple_assign_lhs (stmt));\n+\t  if (CONVERT_EXPR_CODE_P (subcode))\n+\t    subcode = NOP_EXPR;\n+\t  expr->ops.unary.op = subcode;\n+\t  expr->ops.unary.opnd = gimple_assign_rhs1 (stmt);\n+\t  break;\n+        case GIMPLE_BINARY_RHS:\n+\t  expr->kind = EXPR_BINARY;\n+\t  expr->type = TREE_TYPE (gimple_assign_lhs (stmt));\n+\t  expr->ops.binary.op = subcode;\n+\t  expr->ops.binary.opnd0 = gimple_assign_rhs1 (stmt);\n+\t  expr->ops.binary.opnd1 = gimple_assign_rhs2 (stmt);\n+\t  break;\n+        case GIMPLE_TERNARY_RHS:\n+\t  expr->kind = EXPR_TERNARY;\n+\t  expr->type = TREE_TYPE (gimple_assign_lhs (stmt));\n+\t  expr->ops.ternary.op = subcode;\n+\t  expr->ops.ternary.opnd0 = gimple_assign_rhs1 (stmt);\n+\t  expr->ops.ternary.opnd1 = gimple_assign_rhs2 (stmt);\n+\t  expr->ops.ternary.opnd2 = gimple_assign_rhs3 (stmt);\n+\t  break;\n+        default:\n+          gcc_unreachable ();\n+        }\n+    }\n+  else if (code == GIMPLE_COND)\n+    {\n+      expr->type = boolean_type_node;\n+      expr->kind = EXPR_BINARY;\n+      expr->ops.binary.op = gimple_cond_code (stmt);\n+      expr->ops.binary.opnd0 = gimple_cond_lhs (stmt);\n+      expr->ops.binary.opnd1 = gimple_cond_rhs (stmt);\n+    }\n+  else if (gcall *call_stmt = dyn_cast <gcall *> (stmt))\n+    {\n+      size_t nargs = gimple_call_num_args (call_stmt);\n+      size_t i;\n+\n+      gcc_assert (gimple_call_lhs (call_stmt));\n+\n+      expr->type = TREE_TYPE (gimple_call_lhs (call_stmt));\n+      expr->kind = EXPR_CALL;\n+      expr->ops.call.fn_from = call_stmt;\n+\n+      if (gimple_call_flags (call_stmt) & (ECF_CONST | ECF_PURE))\n+        expr->ops.call.pure = true;\n+      else\n+        expr->ops.call.pure = false;\n+\n+      expr->ops.call.nargs = nargs;\n+      expr->ops.call.args = XCNEWVEC (tree, nargs);\n+      for (i = 0; i < nargs; i++)\n+        expr->ops.call.args[i] = gimple_call_arg (call_stmt, i);\n+    }\n+  else if (gswitch *swtch_stmt = dyn_cast <gswitch *> (stmt))\n+    {\n+      expr->type = TREE_TYPE (gimple_switch_index (swtch_stmt));\n+      expr->kind = EXPR_SINGLE;\n+      expr->ops.single.rhs = gimple_switch_index (swtch_stmt);\n+    }\n+  else if (code == GIMPLE_GOTO)\n+    {\n+      expr->type = TREE_TYPE (gimple_goto_dest (stmt));\n+      expr->kind = EXPR_SINGLE;\n+      expr->ops.single.rhs = gimple_goto_dest (stmt);\n+    }\n+  else if (code == GIMPLE_PHI)\n+    {\n+      size_t nargs = gimple_phi_num_args (stmt);\n+      size_t i;\n+\n+      expr->type = TREE_TYPE (gimple_phi_result (stmt));\n+      expr->kind = EXPR_PHI;\n+      expr->ops.phi.nargs = nargs;\n+      expr->ops.phi.args = XCNEWVEC (tree, nargs);\n+      for (i = 0; i < nargs; i++)\n+        expr->ops.phi.args[i] = gimple_phi_arg_def (stmt, i);\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  m_lhs = orig_lhs;\n+  m_vop = gimple_vuse (stmt);\n+  m_hash = avail_expr_hash (this);\n+  m_stamp = this;\n+}\n+\n+/* Given a hashable_expr expression ORIG and an ORIG_LHS,\n+   construct a hash table element.  */\n+\n+expr_hash_elt::expr_hash_elt (struct hashable_expr *orig, tree orig_lhs)\n+{\n+  m_expr = *orig;\n+  m_lhs = orig_lhs;\n+  m_vop = NULL_TREE;\n+  m_hash = avail_expr_hash (this);\n+  m_stamp = this;\n+}\n+\n+/* Copy constructor for a hash table element.  */\n+\n+expr_hash_elt::expr_hash_elt (class expr_hash_elt &old_elt)\n+{\n+  m_expr = old_elt.m_expr;\n+  m_lhs = old_elt.m_lhs;\n+  m_vop = old_elt.m_vop;\n+  m_hash = old_elt.m_hash;\n+  m_stamp = this;\n+\n+  /* Now deep copy the malloc'd space for CALL and PHI args.  */\n+  if (old_elt.m_expr.kind == EXPR_CALL)\n+    {\n+      size_t nargs = old_elt.m_expr.ops.call.nargs;\n+      size_t i;\n+\n+      m_expr.ops.call.args = XCNEWVEC (tree, nargs);\n+      for (i = 0; i < nargs; i++)\n+        m_expr.ops.call.args[i] = old_elt.m_expr.ops.call.args[i];\n+    }\n+  else if (old_elt.m_expr.kind == EXPR_PHI)\n+    {\n+      size_t nargs = old_elt.m_expr.ops.phi.nargs;\n+      size_t i;\n+\n+      m_expr.ops.phi.args = XCNEWVEC (tree, nargs);\n+      for (i = 0; i < nargs; i++)\n+        m_expr.ops.phi.args[i] = old_elt.m_expr.ops.phi.args[i];\n+    }\n+}\n+\n+/* Calls and PHIs have a variable number of arguments that are allocated\n+   on the heap.  Thus we have to have a special dtor to release them.  */\n+\n+expr_hash_elt::~expr_hash_elt ()\n+{\n+  if (m_expr.kind == EXPR_CALL)\n+    free (m_expr.ops.call.args);\n+  else if (m_expr.kind == EXPR_PHI)\n+    free (m_expr.ops.phi.args);\n+}\n+\n+/* Print a diagnostic dump of an expression hash table entry.  */\n+\n+void\n+expr_hash_elt::print (FILE *stream)\n+{\n+  fprintf (stream, \"STMT \");\n+\n+  if (m_lhs)\n+    {\n+      print_generic_expr (stream, m_lhs, 0);\n+      fprintf (stream, \" = \");\n+    }\n+\n+  switch (m_expr.kind)\n+    {\n+      case EXPR_SINGLE:\n+        print_generic_expr (stream, m_expr.ops.single.rhs, 0);\n+        break;\n+\n+      case EXPR_UNARY:\n+\tfprintf (stream, \"%s \", get_tree_code_name (m_expr.ops.unary.op));\n+        print_generic_expr (stream, m_expr.ops.unary.opnd, 0);\n+        break;\n+\n+      case EXPR_BINARY:\n+        print_generic_expr (stream, m_expr.ops.binary.opnd0, 0);\n+\tfprintf (stream, \" %s \", get_tree_code_name (m_expr.ops.binary.op));\n+        print_generic_expr (stream, m_expr.ops.binary.opnd1, 0);\n+        break;\n+\n+      case EXPR_TERNARY:\n+\tfprintf (stream, \" %s <\", get_tree_code_name (m_expr.ops.ternary.op));\n+        print_generic_expr (stream, m_expr.ops.ternary.opnd0, 0);\n+\tfputs (\", \", stream);\n+        print_generic_expr (stream, m_expr.ops.ternary.opnd1, 0);\n+\tfputs (\", \", stream);\n+        print_generic_expr (stream, m_expr.ops.ternary.opnd2, 0);\n+\tfputs (\">\", stream);\n+        break;\n+\n+      case EXPR_CALL:\n+        {\n+          size_t i;\n+          size_t nargs = m_expr.ops.call.nargs;\n+          gcall *fn_from;\n+\n+          fn_from = m_expr.ops.call.fn_from;\n+          if (gimple_call_internal_p (fn_from))\n+            fputs (internal_fn_name (gimple_call_internal_fn (fn_from)),\n+                   stream);\n+          else\n+            print_generic_expr (stream, gimple_call_fn (fn_from), 0);\n+          fprintf (stream, \" (\");\n+          for (i = 0; i < nargs; i++)\n+            {\n+              print_generic_expr (stream, m_expr.ops.call.args[i], 0);\n+              if (i + 1 < nargs)\n+                fprintf (stream, \", \");\n+            }\n+          fprintf (stream, \")\");\n+        }\n+        break;\n+\n+      case EXPR_PHI:\n+        {\n+          size_t i;\n+          size_t nargs = m_expr.ops.phi.nargs;\n+\n+          fprintf (stream, \"PHI <\");\n+          for (i = 0; i < nargs; i++)\n+            {\n+              print_generic_expr (stream, m_expr.ops.phi.args[i], 0);\n+              if (i + 1 < nargs)\n+                fprintf (stream, \", \");\n+            }\n+          fprintf (stream, \">\");\n+        }\n+        break;\n+    }\n+\n+  if (m_vop)\n+    {\n+      fprintf (stream, \" with \");\n+      print_generic_expr (stream, m_vop, 0);\n+    }\n+\n+  fprintf (stream, \"\\n\");\n+}\n \n /* Pop entries off the stack until we hit the NULL marker.\n    For each entry popped, use the SRC/DEST pair to restore\n@@ -133,3 +708,55 @@ const_and_copies::invalidate (tree lhs)\n   if (SSA_NAME_VALUE (lhs))\n     record_const_or_copy (lhs, NULL_TREE);\n }\n+\n+bool\n+expr_elt_hasher::equal (const value_type &p1, const compare_type &p2)\n+{\n+  const struct hashable_expr *expr1 = p1->expr ();\n+  const struct expr_hash_elt *stamp1 = p1->stamp ();\n+  const struct hashable_expr *expr2 = p2->expr ();\n+  const struct expr_hash_elt *stamp2 = p2->stamp ();\n+\n+  /* This case should apply only when removing entries from the table.  */\n+  if (stamp1 == stamp2)\n+    return true;\n+\n+  if (p1->hash () != p2->hash ())\n+    return false;\n+\n+  /* In case of a collision, both RHS have to be identical and have the\n+     same VUSE operands.  */\n+  if (hashable_expr_equal_p (expr1, expr2)\n+      && types_compatible_p (expr1->type, expr2->type))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Given a conditional expression COND as a tree, initialize\n+   a hashable_expr expression EXPR.  The conditional must be a\n+   comparison or logical negation.  A constant or a variable is\n+   not permitted.  */\n+\n+void\n+initialize_expr_from_cond (tree cond, struct hashable_expr *expr)\n+{\n+  expr->type = boolean_type_node;\n+\n+  if (COMPARISON_CLASS_P (cond))\n+    {\n+      expr->kind = EXPR_BINARY;\n+      expr->ops.binary.op = TREE_CODE (cond);\n+      expr->ops.binary.opnd0 = TREE_OPERAND (cond, 0);\n+      expr->ops.binary.opnd1 = TREE_OPERAND (cond, 1);\n+    }\n+  else if (TREE_CODE (cond) == TRUTH_NOT_EXPR)\n+    {\n+      expr->kind = EXPR_UNARY;\n+      expr->ops.unary.op = TRUTH_NOT_EXPR;\n+      expr->ops.unary.opnd = TREE_OPERAND (cond, 0);\n+    }\n+  else\n+    gcc_unreachable ();\n+}\n+"}, {"sha": "f37230e6319fc07532e482c190cd8efbb96e1f11", "filename": "gcc/tree-ssa-scopedtables.h", "status": "modified", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d31398011e31409de9fc3fcc916fcbcd568fc40c/gcc%2Ftree-ssa-scopedtables.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d31398011e31409de9fc3fcc916fcbcd568fc40c/gcc%2Ftree-ssa-scopedtables.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-scopedtables.h?ref=d31398011e31409de9fc3fcc916fcbcd568fc40c", "patch": "@@ -20,6 +20,123 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_TREE_SSA_SCOPED_TABLES_H\n #define GCC_TREE_SSA_SCOPED_TABLES_H\n \n+/* Representation of a \"naked\" right-hand-side expression, to be used\n+   in recording available expressions in the expression hash table.  */\n+\n+enum expr_kind\n+{\n+  EXPR_SINGLE,\n+  EXPR_UNARY,\n+  EXPR_BINARY,\n+  EXPR_TERNARY,\n+  EXPR_CALL,\n+  EXPR_PHI\n+};\n+\n+struct hashable_expr\n+{\n+  tree type;\n+  enum expr_kind kind;\n+  union {\n+    struct { tree rhs; } single;\n+    struct { enum tree_code op;  tree opnd; } unary;\n+    struct { enum tree_code op;  tree opnd0, opnd1; } binary;\n+    struct { enum tree_code op;  tree opnd0, opnd1, opnd2; } ternary;\n+    struct { gcall *fn_from; bool pure; size_t nargs; tree *args; } call;\n+    struct { size_t nargs; tree *args; } phi;\n+  } ops;\n+};\n+\n+/* Structure for entries in the expression hash table.  */\n+\n+typedef class expr_hash_elt * expr_hash_elt_t;\n+\n+class expr_hash_elt\n+{\n+ public:\n+  expr_hash_elt (gimple, tree);\n+  expr_hash_elt (tree);\n+  expr_hash_elt (struct hashable_expr *, tree);\n+  expr_hash_elt (class expr_hash_elt &);\n+  ~expr_hash_elt ();\n+  void print (FILE *);\n+  tree vop (void) { return m_vop; }\n+  tree lhs (void) { return m_lhs; }\n+  struct hashable_expr *expr (void) { return &m_expr; }\n+  expr_hash_elt *stamp (void) { return m_stamp; }\n+  hashval_t hash (void) { return m_hash; }\n+\n+ private:\n+  /* The expression (rhs) we want to record.  */\n+  struct hashable_expr m_expr;\n+\n+  /* The value (lhs) of this expression.  */\n+  tree m_lhs;\n+\n+  /* The virtual operand associated with the nearest dominating stmt\n+     loading from or storing to expr.  */\n+  tree m_vop;\n+\n+  /* The hash value for RHS.  */\n+  hashval_t m_hash;\n+\n+  /* A unique stamp, typically the address of the hash\n+     element itself, used in removing entries from the table.  */\n+  struct expr_hash_elt *m_stamp;\n+\n+  /* We should never be making assignments between objects in this class.\n+     Though it might allow us to exploit C++11 move semantics if we\n+     defined the move constructor and move assignment operator.  */\n+  expr_hash_elt& operator= (const expr_hash_elt&);\n+};\n+\n+/* Hashtable helpers.  */\n+\n+struct expr_elt_hasher : pointer_hash <expr_hash_elt>\n+{\n+  static inline hashval_t hash (const value_type &p)\n+    { return p->hash (); }\n+  static bool equal (const value_type &, const compare_type &);\n+  static inline void remove (value_type &element)\n+    { delete element; }\n+};\n+\n+\n+/* This class defines a unwindable expression equivalence table\n+   layered on top of the expression hash table.\n+\n+   Essentially it's just a stack of available expression value pairs with\n+   a special marker (NULL, NULL) to indicate unwind points.   */\n+\n+class avail_exprs_stack\n+{\n+ public:\n+  /* We need access to the AVAIL_EXPR hash table so that we can\n+     remove entries from the hash table when unwinding the stack.  */\n+  avail_exprs_stack (hash_table<expr_elt_hasher> *table)\n+    { m_stack.create (20); m_avail_exprs = table; }\n+  ~avail_exprs_stack (void) { m_stack.release (); }\n+\n+  /* Push the unwinding marker onto the stack.  */\n+  void push_marker (void) { record_expr (NULL, NULL, 'M'); }\n+\n+  /* Restore the AVAIL_EXPRs table to its state when the last marker\n+     was pushed.  */\n+  void pop_to_marker ();\n+\n+  /* Record a single available expression that can be unwound.  */\n+  void record_expr (expr_hash_elt_t, expr_hash_elt_t, char);\n+\n+ private:\n+  vec<std::pair<expr_hash_elt_t, expr_hash_elt_t> > m_stack;\n+  hash_table<expr_elt_hasher> *m_avail_exprs;\n+\n+  /* We do not allow copying this object or initializing one\n+     from another.  */\n+  avail_exprs_stack& operator= (const avail_exprs_stack&);\n+  avail_exprs_stack (class avail_exprs_stack &);\n+};\n+\n /* This class defines an unwindable const/copy equivalence table\n    layered on top of SSA_NAME_VALUE/set_ssa_name_value.\n \n@@ -54,6 +171,10 @@ class const_and_copies\n \n  private:\n   vec<tree> m_stack;\n+  const_and_copies& operator= (const const_and_copies&);\n+  const_and_copies (class const_and_copies &);\n };\n \n+void initialize_expr_from_cond (tree cond, struct hashable_expr *expr);\n+\n #endif /* GCC_TREE_SSA_SCOPED_TABLES_H */"}]}