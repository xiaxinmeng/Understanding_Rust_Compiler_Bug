{"sha": "29f1e2b173f1701b66410bc3624a989e98e23724", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjlmMWUyYjE3M2YxNzAxYjY2NDEwYmMzNjI0YTk4OWU5OGUyMzcyNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-07-07T13:28:35Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-07-07T13:28:35Z"}, "message": "ipa-comdats.c: Remove optimize check from gate.\n\n\n\t* ipa-comdats.c: Remove optimize check from gate.\n\t* ipa-fnsummary.c (ipa_fn_summary_generate): do not generate summary\n\tfor functions not optimized.\n\t(ipa_fn_summary_read): Skip optimize check.\n\t(ipa_fn_summary_write): Likewise.\n\t* ipa-inline-analysis.c (do_estimate_growth_1): Check that caller\n\tis optimized.\n\t* ipa-inline.c (can_inline_edge_p): Not optimized functions are\n\tuninlinable.\n\t(can_inline_edge_p): Check flag_pcc_struct_return for match.\n\t(check_callers): Give up on caller which is not optimized.\n\t(inline_small_functions): Likewise.\n\t(ipa_inline): Do not give up when not optimizing.\n\t* ipa-visbility.c (function_and_variable_visibility): Do not optimize\n\taway unoptimizes cdtors.\n\t(whole_program_function_and_variable_visibility): Do\n\tipa_discover_readonly_nonaddressable_vars in LTO mode.\n\t* ipa.c (process_references): Do not check optimize.\n\t(symbol_table::remove_unreachable_nodes): Update optimize check.\n\t(set_writeonly_bit): Update optimize check.\n\t(pass_ipa_cdtor_merge::gate): Do not check optimize.\n\t(pass_ipa_single_use::gate): Remove.\n\nFrom-SVN: r250048", "tree": {"sha": "b2b3db83fc40d137f7bde2edb4558d282d409c6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2b3db83fc40d137f7bde2edb4558d282d409c6a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29f1e2b173f1701b66410bc3624a989e98e23724", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29f1e2b173f1701b66410bc3624a989e98e23724", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29f1e2b173f1701b66410bc3624a989e98e23724", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29f1e2b173f1701b66410bc3624a989e98e23724/comments", "author": null, "committer": null, "parents": [{"sha": "8b42ccf6ddfbb350776d0c1b22bddbe9ff634b48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b42ccf6ddfbb350776d0c1b22bddbe9ff634b48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b42ccf6ddfbb350776d0c1b22bddbe9ff634b48"}], "stats": {"total": 120, "additions": 74, "deletions": 46}, "files": [{"sha": "decb508344cd48f8af453437c3a8d660b68a7413", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29f1e2b173f1701b66410bc3624a989e98e23724/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29f1e2b173f1701b66410bc3624a989e98e23724/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=29f1e2b173f1701b66410bc3624a989e98e23724", "patch": "@@ -1,3 +1,28 @@\n+2017-07-06  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-comdats.c: Remove optimize check from gate.\n+\t* ipa-fnsummary.c (ipa_fn_summary_generate): do not generate summary\n+\tfor functions not optimized.\n+\t(ipa_fn_summary_read): Skip optimize check.\n+\t(ipa_fn_summary_write): Likewise.\n+\t* ipa-inline-analysis.c (do_estimate_growth_1): Check that caller\n+\tis optimized.\n+\t* ipa-inline.c (can_inline_edge_p): Not optimized functions are\n+\tuninlinable.\n+\t(can_inline_edge_p): Check flag_pcc_struct_return for match.\n+\t(check_callers): Give up on caller which is not optimized.\n+\t(inline_small_functions): Likewise.\n+\t(ipa_inline): Do not give up when not optimizing.\n+\t* ipa-visbility.c (function_and_variable_visibility): Do not optimize\n+\taway unoptimizes cdtors.\n+\t(whole_program_function_and_variable_visibility): Do\n+\tipa_discover_readonly_nonaddressable_vars in LTO mode.\n+\t* ipa.c (process_references): Do not check optimize.\n+\t(symbol_table::remove_unreachable_nodes): Update optimize check.\n+\t(set_writeonly_bit): Update optimize check.\n+\t(pass_ipa_cdtor_merge::gate): Do not check optimize.\n+\t(pass_ipa_single_use::gate): Remove.\n+\n 2017-07-06  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>\n \n \t* config/rs6000/rs6000.c (union_defs, union_uses, insn_is_load_p,"}, {"sha": "4fa3e1464280cb76634a9201ea9a2f00379a6c3a", "filename": "gcc/ipa-comdats.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29f1e2b173f1701b66410bc3624a989e98e23724/gcc%2Fipa-comdats.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29f1e2b173f1701b66410bc3624a989e98e23724/gcc%2Fipa-comdats.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-comdats.c?ref=29f1e2b173f1701b66410bc3624a989e98e23724", "patch": "@@ -416,7 +416,7 @@ class pass_ipa_comdats : public ipa_opt_pass_d\n bool\n pass_ipa_comdats::gate (function *)\n {\n-  return HAVE_COMDAT_GROUP && optimize;\n+  return HAVE_COMDAT_GROUP;\n }\n \n } // anon namespace"}, {"sha": "52a8c9b0e81aaa9e204be3438af39c3c4a620a1e", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29f1e2b173f1701b66410bc3624a989e98e23724/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29f1e2b173f1701b66410bc3624a989e98e23724/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=29f1e2b173f1701b66410bc3624a989e98e23724", "patch": "@@ -3174,22 +3174,20 @@ ipa_fn_summary_generate (void)\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n     if (DECL_STRUCT_FUNCTION (node->decl))\n-      node->local.versionable = tree_versionable_function_p (node->decl);\n-\n-  /* When not optimizing, do not bother to analyze.  Inlining is still done\n-     because edge redirection needs to happen there.  */\n-  if (!optimize && !flag_generate_lto && !flag_generate_offload && !flag_wpa)\n-    return;\n+      node->local.versionable = \n+\t(opt_for_fn (node->decl, optimize)\n+\t&& tree_versionable_function_p (node->decl));\n \n   ipa_fn_summary_alloc ();\n \n   ipa_fn_summaries->enable_insertion_hook ();\n \n   ipa_register_cgraph_hooks ();\n-  ipa_free_fn_summary ();\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n-    if (!node->alias)\n+    if (!node->alias\n+\t&& (flag_generate_lto || flag_generate_offload|| flag_wpa\n+\t    || opt_for_fn (node->decl, optimize)))\n       inline_analyze_function (node);\n }\n \n@@ -3342,12 +3340,9 @@ ipa_fn_summary_read (void)\n \tfatal_error (input_location,\n \t\t     \"ipa inline summary is missing in input file\");\n     }\n-  if (optimize)\n-    {\n-      ipa_register_cgraph_hooks ();\n-      if (!flag_ipa_cp)\n-\tipa_prop_read_jump_functions ();\n-    }\n+  ipa_register_cgraph_hooks ();\n+  if (!flag_ipa_cp)\n+    ipa_prop_read_jump_functions ();\n \n   gcc_assert (ipa_fn_summaries);\n   ipa_fn_summaries->enable_insertion_hook ();\n@@ -3462,7 +3457,7 @@ ipa_fn_summary_write (void)\n   produce_asm (ob, NULL);\n   destroy_output_block (ob);\n \n-  if (optimize && !flag_ipa_cp)\n+  if (!flag_ipa_cp)\n     ipa_prop_write_jump_functions ();\n }\n "}, {"sha": "38f3d2e762a79f9dc078c2448234527c6e298445", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29f1e2b173f1701b66410bc3624a989e98e23724/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29f1e2b173f1701b66410bc3624a989e98e23724/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=29f1e2b173f1701b66410bc3624a989e98e23724", "patch": "@@ -326,7 +326,8 @@ do_estimate_growth_1 (struct cgraph_node *node, void *data)\n     {\n       gcc_checking_assert (e->inline_failed);\n \n-      if (cgraph_inline_failed_type (e->inline_failed) == CIF_FINAL_ERROR)\n+      if (cgraph_inline_failed_type (e->inline_failed) == CIF_FINAL_ERROR\n+\t  || !opt_for_fn (e->caller->decl, optimize))\n \t{\n \t  d->uninlinable = true;\n           continue;"}, {"sha": "608db8f8857ac556e9cc507a58f5ea19c4f8c334", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29f1e2b173f1701b66410bc3624a989e98e23724/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29f1e2b173f1701b66410bc3624a989e98e23724/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=29f1e2b173f1701b66410bc3624a989e98e23724", "patch": "@@ -322,6 +322,11 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n       e->inline_failed = CIF_BODY_NOT_AVAILABLE;\n       inlinable = false;\n     }\n+  if (!early && !opt_for_fn (callee->decl, optimize))\n+    {\n+      e->inline_failed = CIF_FUNCTION_NOT_OPTIMIZED;\n+      inlinable = false;\n+    }\n   else if (callee->calls_comdat_local)\n     {\n       e->inline_failed = CIF_USES_COMDAT_LOCAL;\n@@ -402,6 +407,7 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n \t Not even for always_inline declared functions.  */\n      else if (check_match (flag_wrapv)\n \t      || check_match (flag_trapv)\n+\t      || check_match (flag_pcc_struct_return)\n \t      /* When caller or callee does FP math, be sure FP codegen flags\n \t\t compatible.  */\n \t      || ((caller_info->fp_expressions && callee_info->fp_expressions)\n@@ -939,7 +945,8 @@ check_callers (struct cgraph_node *node, void *has_hot_call)\n   struct cgraph_edge *e;\n    for (e = node->callers; e; e = e->next_caller)\n      {\n-       if (!opt_for_fn (e->caller->decl, flag_inline_functions_called_once))\n+       if (!opt_for_fn (e->caller->decl, flag_inline_functions_called_once)\n+\t   || !opt_for_fn (e->caller->decl, optimize))\n \t return true;\n        if (!can_inline_edge_p (e, true))\n          return true;\n@@ -1746,7 +1753,8 @@ inline_small_functions (void)\n     if (!node->global.inlined_to)\n       {\n \tif (!node->alias && node->analyzed\n-\t    && (node->has_gimple_body_p () || node->thunk.thunk_p))\n+\t    && (node->has_gimple_body_p () || node->thunk.thunk_p)\n+\t    && opt_for_fn (node->decl, optimize))\n \t  {\n \t    struct ipa_fn_summary *info = ipa_fn_summaries->get (node);\n \t    struct ipa_dfs_info *dfs = (struct ipa_dfs_info *) node->aux;\n@@ -1768,12 +1776,13 @@ inline_small_functions (void)\n \t\tint id = dfs->scc_no + 1;\n \t\tfor (n2 = node; n2;\n \t\t     n2 = ((struct ipa_dfs_info *) node->aux)->next_cycle)\n-\t\t  {\n-\t\t    struct ipa_fn_summary *info2 = ipa_fn_summaries->get (n2);\n-\t\t    if (info2->scc_no)\n-\t\t      break;\n-\t\t    info2->scc_no = id;\n-\t\t  }\n+\t\t  if (opt_for_fn (n2->decl, optimize))\n+\t\t    {\n+\t\t      struct ipa_fn_summary *info2 = ipa_fn_summaries->get (n2);\n+\t\t      if (info2->scc_no)\n+\t\t\tbreak;\n+\t\t      info2->scc_no = id;\n+\t\t    }\n \t      }\n \t  }\n \n@@ -1801,6 +1810,9 @@ inline_small_functions (void)\n       struct cgraph_edge *next = NULL;\n       bool has_speculative = false;\n \n+      if (!opt_for_fn (node->decl, optimize))\n+\tcontinue;\n+\n       if (dump_file)\n \tfprintf (dump_file, \"Enqueueing calls in %s.\\n\", node->dump_name ());\n \n@@ -2369,9 +2381,6 @@ ipa_inline (void)\n   int cold;\n   bool remove_functions = false;\n \n-  if (!optimize)\n-    return 0;\n-\n   cgraph_freq_base_rec = (sreal) 1 / (sreal) CGRAPH_FREQ_BASE;\n   percent_rec = (sreal) 1 / (sreal) 100;\n \n@@ -2467,6 +2476,10 @@ ipa_inline (void)\n \t  struct cgraph_edge *edge, *next;\n \t  bool update=false;\n \n+\t  if (!opt_for_fn (node->decl, optimize)\n+\t      || !opt_for_fn (node->decl, flag_inline_functions_called_once))\n+\t    continue;\n+\n \t  for (edge = node->callees; edge; edge = next)\n \t    {\n \t      next = edge->next_callee;\n@@ -2499,8 +2512,7 @@ ipa_inline (void)\n     }\n \n   /* Free ipa-prop structures if they are no longer needed.  */\n-  if (optimize)\n-    ipa_free_all_structures_after_iinln ();\n+  ipa_free_all_structures_after_iinln ();\n \n   if (dump_file)\n     {"}, {"sha": "cfd90c62211acfda25058681a2e92eeb6ac0e55c", "filename": "gcc/ipa-visibility.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29f1e2b173f1701b66410bc3624a989e98e23724/gcc%2Fipa-visibility.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29f1e2b173f1701b66410bc3624a989e98e23724/gcc%2Fipa-visibility.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-visibility.c?ref=29f1e2b173f1701b66410bc3624a989e98e23724", "patch": "@@ -622,9 +622,12 @@ function_and_variable_visibility (bool whole_program)\n       int flags = flags_from_decl_or_type (node->decl);\n \n       /* Optimize away PURE and CONST constructors and destructors.  */\n-      if (optimize\n+      if (node->analyzed\n+\t  && (DECL_STATIC_CONSTRUCTOR (node->decl)\n+\t      || DECL_STATIC_CONSTRUCTOR (node->decl))\n \t  && (flags & (ECF_CONST | ECF_PURE))\n-\t  && !(flags & ECF_LOOPING_CONST_OR_PURE))\n+\t  && !(flags & ECF_LOOPING_CONST_OR_PURE)\n+\t  && opt_for_fn (node->decl, optimize))\n \t{\n \t  DECL_STATIC_CONSTRUCTOR (node->decl) = 0;\n \t  DECL_STATIC_DESTRUCTOR (node->decl) = 0;\n@@ -876,7 +879,7 @@ static unsigned int\n whole_program_function_and_variable_visibility (void)\n {\n   function_and_variable_visibility (flag_whole_program);\n-  if (optimize)\n+  if (optimize || in_lto_p)\n     ipa_discover_readonly_nonaddressable_vars ();\n   return 0;\n }"}, {"sha": "00cd3084f660c9ad764e9544fba369f3d371d26a", "filename": "gcc/ipa.c", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29f1e2b173f1701b66410bc3624a989e98e23724/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29f1e2b173f1701b66410bc3624a989e98e23724/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=29f1e2b173f1701b66410bc3624a989e98e23724", "patch": "@@ -118,8 +118,7 @@ process_references (symtab_node *snode,\n       if (node->definition && !node->in_other_partition\n \t  && ((!DECL_EXTERNAL (node->decl) || node->alias)\n \t      || (((before_inlining_p\n-\t\t    && ((TREE_CODE (node->decl) != FUNCTION_DECL\n-\t\t\t && optimize)\n+\t\t    && (TREE_CODE (node->decl) != FUNCTION_DECL\n \t\t\t|| (TREE_CODE (node->decl) == FUNCTION_DECL\n \t\t\t    && opt_for_fn (body->decl, optimize))\n \t\t        || (symtab->state < IPA_SSA\n@@ -312,7 +311,7 @@ symbol_table::remove_unreachable_nodes (FILE *file)\n   hash_set<symtab_node *> reachable;\n   hash_set<tree> body_needed_for_clonning;\n   hash_set<void *> reachable_call_targets;\n-  bool before_inlining_p = symtab->state < (!optimize ? IPA_SSA\n+  bool before_inlining_p = symtab->state < (!optimize && !in_lto_p ? IPA_SSA\n \t\t\t\t\t    : IPA_SSA_AFTER_INLINING);\n \n   timevar_push (TV_IPA_UNREACHABLE);\n@@ -696,7 +695,7 @@ symbol_table::remove_unreachable_nodes (FILE *file)\n   symtab_node::checking_verify_symtab_nodes ();\n \n   /* If we removed something, perhaps profile could be improved.  */\n-  if (changed && optimize && ipa_call_summaries)\n+  if (changed && (optimize || in_lto_p) && ipa_call_summaries)\n     FOR_EACH_DEFINED_FUNCTION (node)\n       ipa_propagate_frequency (node);\n \n@@ -757,7 +756,7 @@ bool\n set_writeonly_bit (varpool_node *vnode, void *data)\n {\n   vnode->writeonly = true;\n-  if (optimize)\n+  if (optimize || in_lto_p)\n     {\n       DECL_INITIAL (vnode->decl) = NULL;\n       if (!vnode->alias)\n@@ -1175,7 +1174,7 @@ pass_ipa_cdtor_merge::gate (function *)\n   /* Perform the pass when we have no ctors/dtors support\n      or at LTO time to merge multiple constructors into single\n      function.  */\n-  return !targetm.have_ctors_dtors || (optimize && in_lto_p);\n+  return !targetm.have_ctors_dtors || in_lto_p;\n }\n \n } // anon namespace\n@@ -1387,17 +1386,10 @@ class pass_ipa_single_use : public ipa_opt_pass_d\n   {}\n \n   /* opt_pass methods: */\n-  virtual bool gate (function *);\n   virtual unsigned int execute (function *) { return ipa_single_use (); }\n \n }; // class pass_ipa_single_use\n \n-bool\n-pass_ipa_single_use::gate (function *)\n-{\n-  return optimize;\n-}\n-\n } // anon namespace\n \n ipa_opt_pass_d *"}]}