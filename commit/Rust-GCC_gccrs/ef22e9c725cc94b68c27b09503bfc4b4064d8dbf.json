{"sha": "ef22e9c725cc94b68c27b09503bfc4b4064d8dbf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWYyMmU5YzcyNWNjOTRiNjhjMjdiMDk1MDNiZmM0YjQwNjRkOGRiZg==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@bitrange.com", "date": "2021-07-17T11:19:08Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@bitrange.com", "date": "2021-07-29T23:20:35Z"}, "message": "Fix MMIX breakage; ICE in df_ref_record, at df-scan.c:2598\n\nThis bug made me dive into some of the murkier waters of gcc, namely\nthe source of operand 2 to the \"call\" pattern.  It can be pretty\npoisonous, but is unused (either directly or later) by most targets.\n\nThe target function_arg (and function_incoming_arg), can unless\nspecially handled, cause a VOIDmode reg RTX to be generated, for the\nfunction arguments end-marker.  This is then passed on by expand_call\nto the target \"call\" pattern, as operand[2] (which is wrongly\ndocumented or wrongly implemented, see comment in mmix.c) but unused\nby most targets that do not handle it specially, as in operand 2 not\nmaking it into the insn generated for the \"call\" (et al) patterns.  Of\ncourse, the MMIX port stands out here: the RTX makes it into the\ngenerated RTX but is then actually unused and is just a placeholder;\nsee mmix_print_operand 'p'.\n\nAnyway, df-scan inspects the emitted call rtx and horks on the\nvoid-mode RTX (actually: that it represents a zero-sized register\nrange) from r12-1702.\n\nWhile I could replace or remove the emitted unused call insn operand,\nthat would still leave unusable rtx to future users of function_arg\nactually looking for next_arg_reg.  Better replace VOIDmode with\nDImode here; that's the \"natural\" mode of MMIX registers.\n\n(As a future improvement, I'll also remove the placeholder argument\nand replace the intended user; the print_operand output modifier 'p'\nmodifier (as in \"PUSHJ $%p2,%0\") with some punctuation, perhaps '!'\n(as in \"PUSHJ $%!,%0\").\n\nI inspected all ports, but other targets emit a special\nfunction_arg_info::end_marker cookie or just don't emit \"call\"\noperand[2] (etc) in the expanded \"call\" pattern.\n\ngcc:\n\t* config/mmix/mmix.c (mmix_function_arg_1): Avoid\n\tgenerating a VOIDmode register for e.g the\n\tfunction_arg_info::end_marker.", "tree": {"sha": "1adea09c457719acaa226d3abe5cbabd8e3e7903", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1adea09c457719acaa226d3abe5cbabd8e3e7903"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef22e9c725cc94b68c27b09503bfc4b4064d8dbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef22e9c725cc94b68c27b09503bfc4b4064d8dbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef22e9c725cc94b68c27b09503bfc4b4064d8dbf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef22e9c725cc94b68c27b09503bfc4b4064d8dbf/comments", "author": null, "committer": null, "parents": [{"sha": "591b128e93f3b3fbd4315a7cb4e7e65b9afc2c8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/591b128e93f3b3fbd4315a7cb4e7e65b9afc2c8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/591b128e93f3b3fbd4315a7cb4e7e65b9afc2c8e"}], "stats": {"total": 13, "additions": 10, "deletions": 3}, "files": [{"sha": "db7af7b75b6dd94428621e1c7e96cffd858e8e8a", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef22e9c725cc94b68c27b09503bfc4b4064d8dbf/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef22e9c725cc94b68c27b09503bfc4b4064d8dbf/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=ef22e9c725cc94b68c27b09503bfc4b4064d8dbf", "patch": "@@ -667,21 +667,28 @@ mmix_function_arg_1 (const cumulative_args_t argsp_v,\n {\n   CUMULATIVE_ARGS *argsp = get_cumulative_args (argsp_v);\n \n+  /* The mode of the argument will be VOIDmode for the \"end_marker\".  Make sure\n+     we don't ever generate a VOIDmode register; later passes will barf on that.\n+     We may want to use the register number, so return something nominally\n+     useful.  Thus, for VOIDmode, use DImode, being the natural mode for the\n+     register.  */\n+  machine_mode mode = arg.mode == VOIDmode ? DImode : arg.mode;\n+\n   /* Last-argument marker.  */\n   if (arg.end_marker_p ())\n     return (argsp->regs < MMIX_MAX_ARGS_IN_REGS)\n-      ? gen_rtx_REG (arg.mode,\n+      ? gen_rtx_REG (mode,\n \t\t     (incoming\n \t\t      ? MMIX_FIRST_INCOMING_ARG_REGNUM\n \t\t      : MMIX_FIRST_ARG_REGNUM) + argsp->regs)\n       : NULL_RTX;\n \n   return (argsp->regs < MMIX_MAX_ARGS_IN_REGS\n \t  && !targetm.calls.must_pass_in_stack (arg)\n-\t  && (GET_MODE_BITSIZE (arg.mode) <= 64\n+\t  && (GET_MODE_BITSIZE (mode) <= 64\n \t      || argsp->lib\n \t      || TARGET_LIBFUNC))\n-    ? gen_rtx_REG (arg.mode,\n+    ? gen_rtx_REG (mode,\n \t\t   (incoming\n \t\t    ? MMIX_FIRST_INCOMING_ARG_REGNUM\n \t\t    : MMIX_FIRST_ARG_REGNUM)"}]}