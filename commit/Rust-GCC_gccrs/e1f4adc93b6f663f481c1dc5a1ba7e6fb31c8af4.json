{"sha": "e1f4adc93b6f663f481c1dc5a1ba7e6fb31c8af4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFmNGFkYzkzYjZmNjYzZjQ4MWMxZGM1YTFiYTdlNmZiMzFjOGFmNA==", "commit": {"author": {"name": "Frank Ch. Eigler", "email": "fche@redhat.com", "date": "2005-06-15T16:15:40Z"}, "committer": {"name": "Frank Ch. Eigler", "email": "fche@gcc.gnu.org", "date": "2005-06-15T16:15:40Z"}, "message": "Fix for uncaching bug reported by Herman ten Brugge.\n\n2005-06-15  Frank Ch. Eigler  <fche@redhat.com>\n\n\tFix for uncaching bug reported by Herman ten Brugge.\n\t* mf-runtime.c (__mf_uncache_object): Search whole cache.\n\t* testsuite/libmudflap.c/fail40-frag.c: New test.\n\nFrom-SVN: r100985", "tree": {"sha": "50b5a1f27c89b4772df3a0f85aeb3dba758084d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50b5a1f27c89b4772df3a0f85aeb3dba758084d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1f4adc93b6f663f481c1dc5a1ba7e6fb31c8af4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1f4adc93b6f663f481c1dc5a1ba7e6fb31c8af4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1f4adc93b6f663f481c1dc5a1ba7e6fb31c8af4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1f4adc93b6f663f481c1dc5a1ba7e6fb31c8af4/comments", "author": {"login": "fche", "id": 588885, "node_id": "MDQ6VXNlcjU4ODg4NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/588885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fche", "html_url": "https://github.com/fche", "followers_url": "https://api.github.com/users/fche/followers", "following_url": "https://api.github.com/users/fche/following{/other_user}", "gists_url": "https://api.github.com/users/fche/gists{/gist_id}", "starred_url": "https://api.github.com/users/fche/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fche/subscriptions", "organizations_url": "https://api.github.com/users/fche/orgs", "repos_url": "https://api.github.com/users/fche/repos", "events_url": "https://api.github.com/users/fche/events{/privacy}", "received_events_url": "https://api.github.com/users/fche/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46bdb9cffb6b1cd45bc8032f9b1d7e9e101ba7b0"}], "stats": {"total": 72, "additions": 67, "deletions": 5}, "files": [{"sha": "1a35d91c356fc16f6f49af2e10eacacc90e8c848", "filename": "libmudflap/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1f4adc93b6f663f481c1dc5a1ba7e6fb31c8af4/libmudflap%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1f4adc93b6f663f481c1dc5a1ba7e6fb31c8af4/libmudflap%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2FChangeLog?ref=e1f4adc93b6f663f481c1dc5a1ba7e6fb31c8af4", "patch": "@@ -1,3 +1,9 @@\n+2005-06-15  Frank Ch. Eigler  <fche@redhat.com>\n+\n+\tFix for uncaching bug reported by Herman ten Brugge.\n+\t* mf-runtime.c (__mf_uncache_object): Search whole cache.\n+\t* testsuite/libmudflap.c/fail40-frag.c: New test.\n+\n 2005-05-23  Alfred M. Szmidt  <ams@gnu.org>\n \n \tPR libmudflap/21724"}, {"sha": "317aeaef52183c14e41111257a53878289e39c74", "filename": "libmudflap/mf-runtime.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1f4adc93b6f663f481c1dc5a1ba7e6fb31c8af4/libmudflap%2Fmf-runtime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1f4adc93b6f663f481c1dc5a1ba7e6fb31c8af4/libmudflap%2Fmf-runtime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fmf-runtime.c?ref=e1f4adc93b6f663f481c1dc5a1ba7e6fb31c8af4", "patch": "@@ -919,7 +919,7 @@ void __mfu_check (void *ptr, size_t sz, int type, const char *location)\n                   judgement = -1;\n               }\n \n-            /* We now know that the access spans one or more only valid objects.  */\n+            /* We now know that the access spans no invalid objects.  */\n             if (LIKELY (judgement >= 0))\n               for (i = 0; i < obj_count; i++)\n                 {\n@@ -1064,14 +1064,14 @@ __mf_uncache_object (__mf_object_t *old_obj)\n   /* Can it possibly exist in the cache?  */\n   if (LIKELY (old_obj->read_count + old_obj->write_count))\n     {\n+      /* As reported by Herman ten Brugge, we need to scan the entire\n+         cache for entries that may hit this object. */\n       uintptr_t low = old_obj->low;\n       uintptr_t high = old_obj->high;\n-      unsigned idx_low = __MF_CACHE_INDEX (low);\n-      unsigned idx_high = __MF_CACHE_INDEX (high);\n+      struct __mf_cache *entry = & __mf_lookup_cache [0];\n       unsigned i;\n-      for (i = idx_low; i <= idx_high; i++)\n+      for (i = 0; i <= __mf_lc_mask; i++, entry++)\n         {\n-          struct __mf_cache *entry = & __mf_lookup_cache [i];\n           /* NB: the \"||\" in the following test permits this code to\n              tolerate the situation introduced by __mf_check over\n              contiguous objects, where a cache entry spans several"}, {"sha": "610be20554dc8a77ddf0f0f68f4cf1dffeea2238", "filename": "libmudflap/testsuite/libmudflap.c/fail40-frag.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1f4adc93b6f663f481c1dc5a1ba7e6fb31c8af4/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail40-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1f4adc93b6f663f481c1dc5a1ba7e6fb31c8af4/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail40-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail40-frag.c?ref=e1f4adc93b6f663f481c1dc5a1ba7e6fb31c8af4", "patch": "@@ -0,0 +1,56 @@\n+/* Test proper lookup-uncaching of large objects */\n+#include \"../config.h\"\n+\n+#include <unistd.h>\n+#include <string.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#ifdef HAVE_SYS_MMAN_H\n+#include <sys/mman.h>\n+#endif\n+\n+int main ()\n+{\n+#ifndef MAP_ANONYMOUS\n+#define MAP_ANONYMOUS MAP_ANON\n+#endif\n+#ifdef HAVE_MMAP\n+  volatile unsigned char *p;\n+  unsigned num = getpagesize ();\n+  unsigned i;\n+  int rc;\n+\n+  /* Get a bit of usable address space.  We really want an 2**N+1-sized object,\n+     so the low/high addresses wrap when hashed into the lookup cache.  So we\n+     will manually unregister the entire mmap, then re-register a slice.  */\n+  p = mmap (NULL, num, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, 0, 0);\n+  if (p == NULL)\n+    return 1;\n+  /* Now unregister it, as if munmap was called.  But don't actually munmap, so\n+     we can write into the memory.  */\n+  __mf_unregister ((void *) p, num, __MF_TYPE_HEAP_I);\n+\n+  /* Now register it under a slightly inflated, 2**N+1 size.  */\n+  __mf_register ((void *) p, num+1, __MF_TYPE_HEAP_I, \"fake mmap registration\");\n+\n+  /* Traverse array to ensure that entire lookup cache is made to point at it.  */\n+  for (i=0; i<num; i++)\n+    p[i] = 0;\n+\n+  /* Unregister it.  This should clear the entire lookup cache, even though\n+     hash(low) == hash (high)  (and probably == 0) */\n+  __mf_unregister ((void *) p, num+1, __MF_TYPE_HEAP_I);\n+\n+  /* Now touch the middle portion of the ex-array.  If the lookup cache was\n+     well and truly cleaned, then this access should trap.  */\n+  p[num/2] = 1;\n+\n+  return 0;\n+#else\n+  return 1;\n+#endif\n+}\n+/* { dg-output \"mudflap violation 1.*check/write.*\" } */\n+/* { dg-output \"Nearby object 1.*\" } */\n+/* { dg-output \"mudflap dead object.*fake mmap registration.*\" } */\n+/* { dg-do run { xfail *-*-* } } */"}]}