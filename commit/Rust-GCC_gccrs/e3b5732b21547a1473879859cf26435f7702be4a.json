{"sha": "e3b5732b21547a1473879859cf26435f7702be4a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTNiNTczMmIyMTU0N2ExNDczODc5ODU5Y2YyNjQzNWY3NzAyYmU0YQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2008-04-25T23:14:40Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2008-04-25T23:14:40Z"}, "message": "re PR testsuite/35843 (-fdump-rtl-expand does not exist anymore)\n\n\n\tPR testsuite/35843\n\t* cfgexpand.c (pass_expand): Turn into RTL pass.\n\t* passes.c (execute_one_pass): Do pass typechecking after execution.\n\t* tree-pass.h (pass_expand): Turn into RTL pass.\n\n\t* function.h (struct rtl_data): Move here fields\n\taccesses_prior_frames, calls_eh_return, saves_all_registers,\n\thas_nonlocal_goto, has_asm_statement, is_thunk,\n\tall_throwers_are_sibcalls, limit_stack, profile, uses_const_pool,\n\tuses_pic_offset_table, uses_eh_lsda, tail_call_emit,\n\targ_pointer_save_area_init from struct function; turn into bool.\n\t(struct function): Move\n\tcalls_eh_return, saves_all_registers, has_nonlocal_goto,\n\thas_asm_statement, is_thunk, all_throwers_are_sibcalls, limit_stack,\n\tprofile, uses_const_pool, uses_pic_offset_table, uses_eh_lsda,\n\ttail_call_emit, arg_pointer_save_area_init\n\tinto struct rtl_data.  Remove recursive_call_emit and gimplified flags.\n\t(current_function_returns_struct, current_function_returns_pcc_struct,\n\tcurrent_function_calls_setjmp, current_function_calls_alloca,\n\tcurrent_function_accesses_prior_frames,\n\tcurrent_function_calls_eh_return, current_function_is_thunk,\n\tcurrent_function_stdarg, current_function_profile,\n\tcurrent_function_limit_stack, current_function_uses_pic_offset_table,\n\tcurrent_function_uses_const_pool, current_function_has_nonlocal_label,\n\tcurrent_function_saves_all_registers,\n\tcurrent_function_has_nonlocal_goto,\n\tcurrent_function_has_asm_statement): Remove accesor macros.\n\t* ra-conflict.c (global_conflicts): Update.\n\t* tree-tailcall.c (suitable_for_tail_opt_p): Update.\n\t(suitable_for_tail_call_opt_p): Update.\n\t* builtins.c (expand_builtin_return_addr): Update.\n\t(expand_builtin_setjmp_setup): Update.\n\t(expand_builtin_nonlocal_goto): Update.\n\t* final.c (final_start_function): Update.\n\t(profile_function): Update.\n\t(leaf_function_p): Update.\n\t(only_leaf_regs_used): Update.\n\t* df-scan.c (df_get_exit_block_use_set): Update.\n\t* dojump.c (clear_pending_stack_adjust): Update.\n\t* tree-stdarg.c (gate_optimize_stdarg): Update.\n\t* gimple-low.c (lower_function_body): Update.\n\t* global.c (compute_regsets): Update.\n\t(global_alloc): Update.\n\t* dwarf2out.c (dwarf2out_begin_prologue): Update.\n\t* expr.c (expand_assignment): Update.\n\t* dse.c (dse_step0): Update.\n\t(dse_step1): Update.\n\t* c-decl.c (store_parm_decls): Update.\n\t* local-alloc.c (combine_regs): Update.\n\t(find_free_reg): Update.\n\t* function.c (assign_parms_augmented_arg_list): Update.\n\t(assign_parm_find_data_types): Update.\n\t(assign_parms): Update.\n\t(allocate_struct_function): Update.\n\t(expand_function_start): Update.\n\t(expand_function_end): Update.\n\t(get_arg_pointer_save_area): Update.\n\t(thread_prologue_and_epilogue_insns): Update.\n\t(rest_of_match_asm_constraints): Update.\n\t* stor-layout.c (variable_size): Update.\n\t* gcse.c (gcse_main): Update.\n\t(bypass_jumps): Update.\n\t* gimplify.c (gimplify_function_tree): Update.\n\t* calls.c (emit_call_1): Update.\n\t(expand_call): Update.\n\t* bt-load.c (compute_defs_uses_and_gen): Update.\n\t* except.c (sjlj_assign_call_site_values): Update.\n\t(sjlj_emit_function_enter): Update.\n\t(can_throw_external): Update.\n\t(set_nothrow_function_flags): Update.\n\t(expand_builtin_unwind_init): Update.\n\t(expand_eh_return): Update.\n\t(convert_to_eh_region_ranges): Update.\n\t(output_function_exception_table): Update.\n\t* emit-rtl.c (gen_tmp_stack_mem): Update.\n\t* cfgexpand.c (expand_used_vars): Update.\n\t(tree_expand_cfg): Update.\n\t* cfgcleanup.c (rest_of_handle_jump): Update.\n\t* explow.c (allocate_dynamic_stack_space): Update.\n\t* varasm.c (assemble_start_function): Update.\n\t(force_const_mem): Update.\n\t(mark_constant_pool): Update.\n\t* tree-optimize.c (tree_rest_of_compilation): Update.\n\t* stack-ptr-mod.c (notice_stack_pointer_modification): Update.\n\t* tree-cfg.c (notice_special_calls): Update.\n\t(is_ctrl_altering_stmt): Update.\n\t(tree_can_make_abnormal_goto): Update.\n\t(tree_purge_dead_abnormal_call_edges): Update.\n\t* config/alpha/predicates.md: Update.\n\t* config/alpha/alpha.c (alpha_sa_mask): Update.\n\t(alpha_sa_size): Update.\n\t(alpha_does_function_need_gp): Update.\n\t(alpha_expand_prologue): Update.\n\t(alpha_start_function): Update.\n\t(alpha_output_function_end_prologue): Update.\n\t(alpha_expand_epilogue): Update.\n\t* config/frv/frv.c (frv_stack_info): Update.\n\t(frv_expand_epilogue): Update.\n\t* config/s390/s390.c (s390_regs_ever_clobbered): Update.\n\t(s390_register_info): Update.\n\t(s390_frame_info): Update.\n\t(s390_init_frame_layout): Update.\n\t(s390_can_eliminate): Update.\n\t(save_gprs): Update.\n\t* config/spu/spu.c (spu_split_immediate): Update.\n\t(need_to_save_reg): Update.\n\t(spu_expand_prologue): Update.\n\t(spu_expand_epilogue): Update.\n\t* config/sparc/sparc.md: Update.\n\t* config/sparc/sparc.c (eligible_for_return_delay): Update.\n\t(sparc_tls_got): Update.\n\t(legitimize_pic_address): Update.\n\t(sparc_emit_call_insn): Update.\n\t(sparc_expand_prologue): Update.\n\t(output_return): Update.\n\t(print_operand): Update.\n\t(sparc_function_ok_for_sibcall): Update.\n\t* config/sparc/sparc.h (EXIT_IGNORE_STACK): Update.\n\t* config/m32r/m32r.md: Update.\n\t* config/m32r/m32r.c (MUST_SAVE_RETURN_ADDR): Update.\n\t(m32r_compute_frame_size): Update.\n\t(m32r_expand_prologue): Update.\n\t(m32r_expand_epilogue): Update.\n\t(m32r_legitimize_pic_address): Update.\n\t* config/m32r/m32r.h (FRAME_POINTER_REQUIRED): Update.\n\t* config/i386/linux.h (SUBTARGET_FRAME_POINTER_REQUIRED): Update.\n\t* config/i386/i386.c (ix86_frame_pointer_required): Update.\n\t(gen_push): Update.\n\t(ix86_save_reg): Update.\n\t(ix86_compute_frame_layout): Update.\n\t(ix86_expand_prologue): Update.\n\t(ix86_expand_epilogue): Update.\n\t* config/sh/sh.c (output_stack_adjust): Update.\n\t(calc_live_regs): Update.\n\t(sh5_schedule_saves): Update.\n\t(sh_expand_prologue): Update.\n\t(sh_expand_epilogue): Update.\n\t(sh_setup_incoming_varargs): Update.\n\t(sh_allocate_initial_value): Update.\n\t(sh_get_pr_initial_val): Update.\n\t* config/sh/sh.h (SHMEDIA_REGS_STACK_ADJUST): Update.\n\t* config/sh/sh.md (label:): Update.\n\t* config/avr/avr.c (out_movhi_mr_r): Update.\n\t* config/crx/crx.h (enum): Update.\n\t* config/xtensa/xtensa.h (along): Update.\n\t* config/stormy16/stormy16.c Update.\n\t(xstormy16_compute_stack_layout): Update.\n\t* config/fr30/fr30.c (MUST_SAVE_RETURN_POINTER): Update.\n\t(fr30_expand_prologue): Update.\n\t* config/cris/cris.c (cris_conditional_register_usage): Update.\n\t(cris_reg_saved_in_regsave_area): Update.\n\t(cris_initial_frame_pointer_offset): Update.\n\t(cris_simple_epilogue): Update.\n\t(cris_expand_prologue): Update.\n\t(cris_expand_epilogue): Update.\n\t(cris_expand_pic_call_address): Update.\n\t(cris_asm_output_symbol_ref): Update.\n\t(cris_asm_output_label_ref): Update.\n\t* config/cris/cris.md Update.\n\t* config/iq2000/iq2000.c (compute_frame_size): Update.\n\t(iq2000_expand_epilogue): Update.\n\t* config/mt/mt.h (save_direction): Update.\n\t* config/mn10300/mn10300.c (mn10300_function_value): Update.\n\t* config/ia64/ia64.c (ia64_compute_frame_size): Update.\n\t(ia64_secondary_reload_class): Update.\n\t* config/m68k/m68k.c (m68k_save_reg): Update.\n\t(m68k_expand_prologue): Update.\n\t(m68k_expand_epilogue): Update.\n\t(legitimize_pic_address): Update.\n\t* config/rs6000/rs6000.c (rs6000_got_register): Update.\n\t(first_reg_to_save): Update.\n\t(first_altivec_reg_to_save): Update.\n\t(compute_vrsave_mask): Update.\n\t(compute_save_world_info): Update.\n\t(rs6000_stack_info): Update.\n\t(spe_func_has_64bit_regs_p): Update.\n\t(rs6000_ra_ever_killed): Update.\n\t(rs6000_emit_eh_reg_restore): Update.\n\t(rs6000_emit_allocate_stack): Update.\n\t(rs6000_emit_prologue): Update.\n\t(rs6000_emit_epilogue): Update.\n\t(rs6000_output_function_epilogue): Update.\n\t(output_profile_hook): Update.\n\t(rs6000_elf_declare_function_name): Update.\n\t* config/rs6000/rs6000.h (rs6000_args): Update.\n\t* config/rs6000/rs6000.md: Update.\n\t* config/mcore/mcore.c (mcore_expand_prolog): Update.\n\t* config/arc/arc.c (arc_output_function_epilogue): Update.\n\t* config/arc/arc.h (FRAME_POINTER_REQUIRED): Update.\n\t* config/darwin.c (machopic_function_base_name): Update.\n\t* config/score/score3.c (score3_compute_frame_size): Update.\n\t(rpush): Update.\n\t(rpop): Update.\n\t(score3_epilogue): Update.\n\t* config/score/score7.c (score7_compute_frame_size): Update.\n\t(score7_prologue): Update.\n\t(score7_epilogue): Update.\n\t* config/score/score.h (FRAME_POINTER_REQUIRED): Update.\n\t* config/arm/linux-elf.h (SUBTARGET_FRAME_POINTER_REQUIRED): Update.\n\t* config/arm/arm.c (use_return_insn): Update.\n\t(require_pic_register): Update.\n\t(arm_load_pic_register): Update.\n\t(arm_compute_save_reg0_reg12_mask): Update.\n\t(arm_compute_save_reg_mask): Update.\n\t(thumb1_compute_save_reg_mask): Update.\n\t(output_return_instruction): Update.\n\t(arm_output_function_prologue): Update.\n\t(arm_output_epilogue): Update.\n\t(arm_get_frame_offsets): Update.\n\t(arm_expand_prologue): Update.\n\t(thumb_pushpop): Update.\n\t(thumb_exit): Update.\n\t(thumb1_expand_prologue): Update.\n\t(thumb1_expand_epilogue): Update.\n\t(arm_unwind_emit): Update.\n\t(arm_output_fn_unwind): Update.\n\t* config/arm/arm.h (FRAME_POINTER_REQUIRED): Update.\n\t* config/arm/arm.md: Update.\n\t* config/pa/pa.md: Update.\n\t* config/pa/pa.c (legitimize_pic_address): Update.\n\t(compute_frame_size): Update.\n\t(hppa_expand_prologue): Update.\n\t(hppa_expand_epilogue): Update.\n\t(borx_reg_operand): Update.\n\t* config/pa/pa.h (FRAME_POINTER_REQUIRED): Update.\n\t(HARD_REGNO_RENAME_OK): Update.\n\t* config/mips/mips.c (mips_global_pointer): Update.\n\t(mips_save_reg_p): Update.\n\t(mips_compute_frame_info): Update.\n\t(mips_frame_pointer_required): Update.\n\t(mips_expand_prologue): Update.\n\t(mips_expand_epilogue): Update.\n\t(mips_can_use_return_insn): Update.\n\t(mips_reorg_process_insns): Update.\n\t* config/v850/v850.c (compute_register_save_size): Update.\n\t* config/mmix/mmix.h (FRAME_POINTER_REQUIRED): Update.\n\t* config/mmix/mmix.c (along): Update.\n\t(mmix_expand_epilogue): Update.\n\t* config/bfin/bfin.c (legitimize_pic_address): Update.\n\t(must_save_p): Update.\n\t(stack_frame_needed_p): Update.\n\t(add_to_reg): Update.\n\t(bfin_expand_prologue): Update.\n\t* stmt.c (expand_asm_operands): Update.\n\t* reload1.c (reload): Update.\n\t(init_elim_table): Update.\n\nFrom-SVN: r134682", "tree": {"sha": "a3271f38b9d28ba051ebf47059f216d587394c16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3271f38b9d28ba051ebf47059f216d587394c16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3b5732b21547a1473879859cf26435f7702be4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3b5732b21547a1473879859cf26435f7702be4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3b5732b21547a1473879859cf26435f7702be4a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3b5732b21547a1473879859cf26435f7702be4a/comments", "author": null, "committer": null, "parents": [{"sha": "ccc2ed871505aea3bb72601bafddd8ee207c6fe6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccc2ed871505aea3bb72601bafddd8ee207c6fe6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccc2ed871505aea3bb72601bafddd8ee207c6fe6"}], "stats": {"total": 1129, "additions": 679, "deletions": 450}, "files": [{"sha": "374615b45463609bfd52650a85b947898a2e9742", "filename": "gcc/ChangeLog", "status": "modified", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -1,3 +1,252 @@\n+2008-04-25  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR testsuite/35843\n+\t* cfgexpand.c (pass_expand): Turn into RTL pass.\n+\t* passes.c (execute_one_pass): Do pass typechecking after execution.\n+\t* tree-pass.h (pass_expand): Turn into RTL pass.\n+\n+\t* function.h (struct rtl_data): Move here fields\n+\taccesses_prior_frames, calls_eh_return, saves_all_registers,\n+\thas_nonlocal_goto, has_asm_statement, is_thunk,\n+\tall_throwers_are_sibcalls, limit_stack, profile, uses_const_pool,\n+\tuses_pic_offset_table, uses_eh_lsda, tail_call_emit,\n+\targ_pointer_save_area_init from struct function; turn into bool.\n+\t(struct function): Move\n+\tcalls_eh_return, saves_all_registers, has_nonlocal_goto,\n+\thas_asm_statement, is_thunk, all_throwers_are_sibcalls, limit_stack,\n+\tprofile, uses_const_pool, uses_pic_offset_table, uses_eh_lsda,\n+\ttail_call_emit, arg_pointer_save_area_init\n+\tinto struct rtl_data.  Remove recursive_call_emit and gimplified flags.\n+\t(current_function_returns_struct, current_function_returns_pcc_struct,\n+\tcurrent_function_calls_setjmp, current_function_calls_alloca,\n+\tcurrent_function_accesses_prior_frames,\n+\tcurrent_function_calls_eh_return, current_function_is_thunk,\n+\tcurrent_function_stdarg, current_function_profile,\n+\tcurrent_function_limit_stack, current_function_uses_pic_offset_table,\n+\tcurrent_function_uses_const_pool, current_function_has_nonlocal_label,\n+\tcurrent_function_saves_all_registers,\n+\tcurrent_function_has_nonlocal_goto,\n+\tcurrent_function_has_asm_statement): Remove accesor macros.\n+\t* ra-conflict.c (global_conflicts): Update.\n+\t* tree-tailcall.c (suitable_for_tail_opt_p): Update.\n+\t(suitable_for_tail_call_opt_p): Update.\n+\t* builtins.c (expand_builtin_return_addr): Update.\n+\t(expand_builtin_setjmp_setup): Update.\n+\t(expand_builtin_nonlocal_goto): Update.\n+\t* final.c (final_start_function): Update.\n+\t(profile_function): Update.\n+\t(leaf_function_p): Update.\n+\t(only_leaf_regs_used): Update.\n+\t* df-scan.c (df_get_exit_block_use_set): Update.\n+\t* dojump.c (clear_pending_stack_adjust): Update.\n+\t* tree-stdarg.c (gate_optimize_stdarg): Update.\n+\t* gimple-low.c (lower_function_body): Update.\n+\t* global.c (compute_regsets): Update.\n+\t(global_alloc): Update.\n+\t* dwarf2out.c (dwarf2out_begin_prologue): Update.\n+\t* expr.c (expand_assignment): Update.\n+\t* dse.c (dse_step0): Update.\n+\t(dse_step1): Update.\n+\t* c-decl.c (store_parm_decls): Update.\n+\t* local-alloc.c (combine_regs): Update.\n+\t(find_free_reg): Update.\n+\t* function.c (assign_parms_augmented_arg_list): Update.\n+\t(assign_parm_find_data_types): Update.\n+\t(assign_parms): Update.\n+\t(allocate_struct_function): Update.\n+\t(expand_function_start): Update.\n+\t(expand_function_end): Update.\n+\t(get_arg_pointer_save_area): Update.\n+\t(thread_prologue_and_epilogue_insns): Update.\n+\t(rest_of_match_asm_constraints): Update.\n+\t* stor-layout.c (variable_size): Update.\n+\t* gcse.c (gcse_main): Update.\n+\t(bypass_jumps): Update.\n+\t* gimplify.c (gimplify_function_tree): Update.\n+\t* calls.c (emit_call_1): Update.\n+\t(expand_call): Update.\n+\t* bt-load.c (compute_defs_uses_and_gen): Update.\n+\t* except.c (sjlj_assign_call_site_values): Update.\n+\t(sjlj_emit_function_enter): Update.\n+\t(can_throw_external): Update.\n+\t(set_nothrow_function_flags): Update.\n+\t(expand_builtin_unwind_init): Update.\n+\t(expand_eh_return): Update.\n+\t(convert_to_eh_region_ranges): Update.\n+\t(output_function_exception_table): Update.\n+\t* emit-rtl.c (gen_tmp_stack_mem): Update.\n+\t* cfgexpand.c (expand_used_vars): Update.\n+\t(tree_expand_cfg): Update.\n+\t* cfgcleanup.c (rest_of_handle_jump): Update.\n+\t* explow.c (allocate_dynamic_stack_space): Update.\n+\t* varasm.c (assemble_start_function): Update.\n+\t(force_const_mem): Update.\n+\t(mark_constant_pool): Update.\n+\t* tree-optimize.c (tree_rest_of_compilation): Update.\n+\t* stack-ptr-mod.c (notice_stack_pointer_modification): Update.\n+\t* tree-cfg.c (notice_special_calls): Update.\n+\t(is_ctrl_altering_stmt): Update.\n+\t(tree_can_make_abnormal_goto): Update.\n+\t(tree_purge_dead_abnormal_call_edges): Update.\n+\t* config/alpha/predicates.md: Update.\n+\t* config/alpha/alpha.c (alpha_sa_mask): Update.\n+\t(alpha_sa_size): Update.\n+\t(alpha_does_function_need_gp): Update.\n+\t(alpha_expand_prologue): Update.\n+\t(alpha_start_function): Update.\n+\t(alpha_output_function_end_prologue): Update.\n+\t(alpha_expand_epilogue): Update.\n+\t* config/frv/frv.c (frv_stack_info): Update.\n+\t(frv_expand_epilogue): Update.\n+\t* config/s390/s390.c (s390_regs_ever_clobbered): Update.\n+\t(s390_register_info): Update.\n+\t(s390_frame_info): Update.\n+\t(s390_init_frame_layout): Update.\n+\t(s390_can_eliminate): Update.\n+\t(save_gprs): Update.\n+\t* config/spu/spu.c (spu_split_immediate): Update.\n+\t(need_to_save_reg): Update.\n+\t(spu_expand_prologue): Update.\n+\t(spu_expand_epilogue): Update.\n+\t* config/sparc/sparc.md: Update.\n+\t* config/sparc/sparc.c (eligible_for_return_delay): Update.\n+\t(sparc_tls_got): Update.\n+\t(legitimize_pic_address): Update.\n+\t(sparc_emit_call_insn): Update.\n+\t(sparc_expand_prologue): Update.\n+\t(output_return): Update.\n+\t(print_operand): Update.\n+\t(sparc_function_ok_for_sibcall): Update.\n+\t* config/sparc/sparc.h (EXIT_IGNORE_STACK): Update.\n+\t* config/m32r/m32r.md: Update.\n+\t* config/m32r/m32r.c (MUST_SAVE_RETURN_ADDR): Update.\n+\t(m32r_compute_frame_size): Update.\n+\t(m32r_expand_prologue): Update.\n+\t(m32r_expand_epilogue): Update.\n+\t(m32r_legitimize_pic_address): Update.\n+\t* config/m32r/m32r.h (FRAME_POINTER_REQUIRED): Update.\n+\t* config/i386/linux.h (SUBTARGET_FRAME_POINTER_REQUIRED): Update.\n+\t* config/i386/i386.c (ix86_frame_pointer_required): Update.\n+\t(gen_push): Update.\n+\t(ix86_save_reg): Update.\n+\t(ix86_compute_frame_layout): Update.\n+\t(ix86_expand_prologue): Update.\n+\t(ix86_expand_epilogue): Update.\n+\t* config/sh/sh.c (output_stack_adjust): Update.\n+\t(calc_live_regs): Update.\n+\t(sh5_schedule_saves): Update.\n+\t(sh_expand_prologue): Update.\n+\t(sh_expand_epilogue): Update.\n+\t(sh_setup_incoming_varargs): Update.\n+\t(sh_allocate_initial_value): Update.\n+\t(sh_get_pr_initial_val): Update.\n+\t* config/sh/sh.h (SHMEDIA_REGS_STACK_ADJUST): Update.\n+\t* config/sh/sh.md (label:): Update.\n+\t* config/avr/avr.c (out_movhi_mr_r): Update.\n+\t* config/crx/crx.h (enum): Update.\n+\t* config/xtensa/xtensa.h (along): Update.\n+\t* config/stormy16/stormy16.c Update.\n+\t(xstormy16_compute_stack_layout): Update.\n+\t* config/fr30/fr30.c (MUST_SAVE_RETURN_POINTER): Update.\n+\t(fr30_expand_prologue): Update.\n+\t* config/cris/cris.c (cris_conditional_register_usage): Update.\n+\t(cris_reg_saved_in_regsave_area): Update.\n+\t(cris_initial_frame_pointer_offset): Update.\n+\t(cris_simple_epilogue): Update.\n+\t(cris_expand_prologue): Update.\n+\t(cris_expand_epilogue): Update.\n+\t(cris_expand_pic_call_address): Update.\n+\t(cris_asm_output_symbol_ref): Update.\n+\t(cris_asm_output_label_ref): Update.\n+\t* config/cris/cris.md Update.\n+\t* config/iq2000/iq2000.c (compute_frame_size): Update.\n+\t(iq2000_expand_epilogue): Update.\n+\t* config/mt/mt.h (save_direction): Update.\n+\t* config/mn10300/mn10300.c (mn10300_function_value): Update.\n+\t* config/ia64/ia64.c (ia64_compute_frame_size): Update.\n+\t(ia64_secondary_reload_class): Update.\n+\t* config/m68k/m68k.c (m68k_save_reg): Update.\n+\t(m68k_expand_prologue): Update.\n+\t(m68k_expand_epilogue): Update.\n+\t(legitimize_pic_address): Update.\n+\t* config/rs6000/rs6000.c (rs6000_got_register): Update.\n+\t(first_reg_to_save): Update.\n+\t(first_altivec_reg_to_save): Update.\n+\t(compute_vrsave_mask): Update.\n+\t(compute_save_world_info): Update.\n+\t(rs6000_stack_info): Update.\n+\t(spe_func_has_64bit_regs_p): Update.\n+\t(rs6000_ra_ever_killed): Update.\n+\t(rs6000_emit_eh_reg_restore): Update.\n+\t(rs6000_emit_allocate_stack): Update.\n+\t(rs6000_emit_prologue): Update.\n+\t(rs6000_emit_epilogue): Update.\n+\t(rs6000_output_function_epilogue): Update.\n+\t(output_profile_hook): Update.\n+\t(rs6000_elf_declare_function_name): Update.\n+\t* config/rs6000/rs6000.h (rs6000_args): Update.\n+\t* config/rs6000/rs6000.md: Update.\n+\t* config/mcore/mcore.c (mcore_expand_prolog): Update.\n+\t* config/arc/arc.c (arc_output_function_epilogue): Update.\n+\t* config/arc/arc.h (FRAME_POINTER_REQUIRED): Update.\n+\t* config/darwin.c (machopic_function_base_name): Update.\n+\t* config/score/score3.c (score3_compute_frame_size): Update.\n+\t(rpush): Update.\n+\t(rpop): Update.\n+\t(score3_epilogue): Update.\n+\t* config/score/score7.c (score7_compute_frame_size): Update.\n+\t(score7_prologue): Update.\n+\t(score7_epilogue): Update.\n+\t* config/score/score.h (FRAME_POINTER_REQUIRED): Update.\n+\t* config/arm/linux-elf.h (SUBTARGET_FRAME_POINTER_REQUIRED): Update.\n+\t* config/arm/arm.c (use_return_insn): Update.\n+\t(require_pic_register): Update.\n+\t(arm_load_pic_register): Update.\n+\t(arm_compute_save_reg0_reg12_mask): Update.\n+\t(arm_compute_save_reg_mask): Update.\n+\t(thumb1_compute_save_reg_mask): Update.\n+\t(output_return_instruction): Update.\n+\t(arm_output_function_prologue): Update.\n+\t(arm_output_epilogue): Update.\n+\t(arm_get_frame_offsets): Update.\n+\t(arm_expand_prologue): Update.\n+\t(thumb_pushpop): Update.\n+\t(thumb_exit): Update.\n+\t(thumb1_expand_prologue): Update.\n+\t(thumb1_expand_epilogue): Update.\n+\t(arm_unwind_emit): Update.\n+\t(arm_output_fn_unwind): Update.\n+\t* config/arm/arm.h (FRAME_POINTER_REQUIRED): Update.\n+\t* config/arm/arm.md: Update.\n+\t* config/pa/pa.md: Update.\n+\t* config/pa/pa.c (legitimize_pic_address): Update.\n+\t(compute_frame_size): Update.\n+\t(hppa_expand_prologue): Update.\n+\t(hppa_expand_epilogue): Update.\n+\t(borx_reg_operand): Update.\n+\t* config/pa/pa.h (FRAME_POINTER_REQUIRED): Update.\n+\t(HARD_REGNO_RENAME_OK): Update.\n+\t* config/mips/mips.c (mips_global_pointer): Update.\n+\t(mips_save_reg_p): Update.\n+\t(mips_compute_frame_info): Update.\n+\t(mips_frame_pointer_required): Update.\n+\t(mips_expand_prologue): Update.\n+\t(mips_expand_epilogue): Update.\n+\t(mips_can_use_return_insn): Update.\n+\t(mips_reorg_process_insns): Update.\n+\t* config/v850/v850.c (compute_register_save_size): Update.\n+\t* config/mmix/mmix.h (FRAME_POINTER_REQUIRED): Update.\n+\t* config/mmix/mmix.c (along): Update.\n+\t(mmix_expand_epilogue): Update.\n+\t* config/bfin/bfin.c (legitimize_pic_address): Update.\n+\t(must_save_p): Update.\n+\t(stack_frame_needed_p): Update.\n+\t(add_to_reg): Update.\n+\t(bfin_expand_prologue): Update.\n+\t* stmt.c (expand_asm_operands): Update.\n+\t* reload1.c (reload): Update.\n+\t(init_elim_table): Update.\n+\n 2008-04-25  Bob Wilson  <bob.wilson@acm.org>\n \t\n \t* optabs.c (expand_float): Fix REG_EQUAL for UNSIGNED_FLOAT libcall."}, {"sha": "6feefbbf7af1ac68b639c7485a8b70de7e77f162", "filename": "gcc/bt-load.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -508,7 +508,7 @@ compute_defs_uses_and_gen (fibheap_t all_btr_defs, btr_def *def_array,\n \t\t  note_other_use_this_block (regno, info.users_this_bb);\n \t\t}\n \t      /* Check for the blockage emitted by expand_nl_goto_receiver.  */\n-\t      else if (current_function_has_nonlocal_label\n+\t      else if (cfun->has_nonlocal_label\n \t\t       && GET_CODE (PATTERN (insn)) == UNSPEC_VOLATILE)\n \t\t{\n \t\t  btr_user user;"}, {"sha": "765294b1be3328b2d082d05c3e16d51e095ec6a5", "filename": "gcc/builtins.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -587,7 +587,7 @@ expand_builtin_return_addr (enum built_in_function fndecl_code, int count)\n       tem = hard_frame_pointer_rtx;\n \n       /* Tell reload not to eliminate the frame pointer.  */\n-      current_function_accesses_prior_frames = 1;\n+      crtl->accesses_prior_frames = 1;\n     }\n #endif\n \n@@ -690,10 +690,10 @@ expand_builtin_setjmp_setup (rtx buf_addr, rtx receiver_label)\n \n   /* Tell optimize_save_area_alloca that extra work is going to\n      need to go on during alloca.  */\n-  current_function_calls_setjmp = 1;\n+  cfun->calls_setjmp = 1;\n \n   /* We have a nonlocal label.   */\n-  current_function_has_nonlocal_label = 1;\n+  cfun->has_nonlocal_label = 1;\n }\n \n /* Construct the trailing part of a __builtin_setjmp call.  This is\n@@ -877,7 +877,7 @@ expand_builtin_nonlocal_goto (tree exp)\n   r_sp = gen_rtx_MEM (STACK_SAVEAREA_MODE (SAVE_NONLOCAL),\n \t\t      plus_constant (r_save_area, GET_MODE_SIZE (Pmode)));\n \n-  current_function_has_nonlocal_goto = 1;\n+  crtl->has_nonlocal_goto = 1;\n \n #ifdef HAVE_nonlocal_goto\n   /* ??? We no longer need to pass the static chain value, afaik.  */"}, {"sha": "979b03c36d2443ecbd3f225194877c35393ec049", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -6637,7 +6637,7 @@ store_parm_decls (void)\n      call expand_expr to calculate the size of a variable-sized array.\n      We haven't necessarily assigned RTL to all variables yet, so it's\n      not safe to try to expand expressions involving them.  */\n-  cfun->x_dont_save_pending_sizes_p = 1;\n+  cfun->dont_save_pending_sizes_p = 1;\n }\n \f\n /* Emit diagnostics that require gimple input for detection.  Operate on"}, {"sha": "126037d4a423caa8a9250d5f5cf745e8cc0f4ddb", "filename": "gcc/calls.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -399,7 +399,7 @@ emit_call_1 (rtx funexp, tree fntree, tree fndecl ATTRIBUTE_UNUSED,\n     {\n       REG_NOTES (call_insn) = gen_rtx_EXPR_LIST (REG_SETJMP, const0_rtx,\n \t\t\t\t\t\t REG_NOTES (call_insn));\n-      current_function_calls_setjmp = 1;\n+      cfun->calls_setjmp = 1;\n     }\n \n   SIBLING_CALL_P (call_insn) = ((ecf_flags & ECF_SIBCALL) != 0);\n@@ -2122,7 +2122,7 @@ expand_call (tree exp, rtx target, int ignore)\n     type_arg_types = TYPE_ARG_TYPES (funtype);\n \n   if (flags & ECF_MAY_BE_ALLOCA)\n-    current_function_calls_alloca = 1;\n+    cfun->calls_alloca = 1;\n \n   /* If struct_value_rtx is 0, it means pass the address\n      as if it were an extra parameter.  Put the argument expression\n@@ -2299,8 +2299,6 @@ expand_call (tree exp, rtx target, int ignore)\n   if (crtl->preferred_stack_boundary < preferred_stack_boundary\n       && fndecl != current_function_decl)\n     crtl->preferred_stack_boundary = preferred_stack_boundary;\n-  if (fndecl == current_function_decl)\n-    cfun->recursive_call_emit = true;\n \n   preferred_unit_stack_boundary = preferred_stack_boundary / BITS_PER_UNIT;\n \n@@ -3160,7 +3158,7 @@ expand_call (tree exp, rtx target, int ignore)\n   if (tail_call_insns)\n     {\n       emit_insn (tail_call_insns);\n-      cfun->tail_call_emit = true;\n+      crtl->tail_call_emit = true;\n     }\n   else\n     emit_insn (normal_call_insns);"}, {"sha": "aae9ca0009dd2222f2a78d5f5582ca3e953ecdaf", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -2176,7 +2176,7 @@ rest_of_handle_jump (void)\n {\n   delete_unreachable_blocks ();\n \n-  if (cfun->tail_call_emit)\n+  if (crtl->tail_call_emit)\n     fixup_tail_calls ();\n   return 0;\n }"}, {"sha": "273c6ac864aeed36ecf38dcbfc0e3e3a9bb2aea5", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -1177,7 +1177,7 @@ expand_used_vars (void)\n      stack guard: protect-all, alloca used, protected decls present.  */\n   if (flag_stack_protect == 2\n       || (flag_stack_protect\n-\t  && (current_function_calls_alloca || has_protected_decls)))\n+\t  && (cfun->calls_alloca || has_protected_decls)))\n     create_stack_guard ();\n \n   /* Assign rtl to each variable based on these partitions.  */\n@@ -1874,7 +1874,7 @@ tree_expand_cfg (void)\n   /* Honor stack protection warnings.  */\n   if (warn_stack_protect)\n     {\n-      if (current_function_calls_alloca)\n+      if (cfun->calls_alloca)\n \twarning (OPT_Wstack_protector, \n \t\t \"not protecting local variables: variable length buffer\");\n       if (has_short_buffer && !crtl->stack_protect_guard)\n@@ -1982,10 +1982,10 @@ tree_expand_cfg (void)\n   return 0;\n }\n \n-struct gimple_opt_pass pass_expand =\n+struct rtl_opt_pass pass_expand =\n {\n  {\n-  GIMPLE_PASS,\n+  RTL_PASS,\n   \"expand\",\t\t\t\t/* name */\n   NULL,                                 /* gate */\n   tree_expand_cfg,\t\t\t/* execute */"}, {"sha": "ed44a88d9ec67437a28e05020c395070bb614749", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -7072,7 +7072,7 @@ alpha_sa_mask (unsigned long *imaskP, unsigned long *fmaskP)\n   /* When outputting a thunk, we don't have valid register life info,\n      but assemble_start_function wants to output .frame and .mask\n      directives.  */\n-  if (current_function_is_thunk)\n+  if (crtl->is_thunk)\n     {\n       *imaskP = 0;\n       *fmaskP = 0;\n@@ -7095,7 +7095,7 @@ alpha_sa_mask (unsigned long *imaskP, unsigned long *fmaskP)\n       }\n \n   /* We need to restore these for the handler.  */\n-  if (current_function_calls_eh_return)\n+  if (crtl->calls_eh_return)\n     {\n       for (i = 0; ; ++i)\n \t{\n@@ -7149,7 +7149,7 @@ alpha_sa_size (void)\n       alpha_procedure_type\n \t= (sa_size || get_frame_size() != 0\n \t   || crtl->outgoing_args_size\n-\t   || current_function_stdarg || current_function_calls_alloca\n+\t   || cfun->stdarg || cfun->calls_alloca\n \t   || frame_pointer_needed)\n \t  ? PT_STACK : PT_REGISTER;\n \n@@ -7182,7 +7182,7 @@ alpha_sa_size (void)\n \n       vms_base_regno\n \t= (frame_pointer_needed\n-\t   || current_function_has_nonlocal_label\n+\t   || cfun->has_nonlocal_label\n \t   || alpha_procedure_type == PT_STACK\n \t   || crtl->outgoing_args_size)\n \t  ? REG_PV : HARD_FRAME_POINTER_REGNUM;\n@@ -7298,18 +7298,18 @@ alpha_does_function_need_gp (void)\n     return 0;\n \n   /* We need the gp to load the address of __mcount.  */\n-  if (TARGET_PROFILING_NEEDS_GP && current_function_profile)\n+  if (TARGET_PROFILING_NEEDS_GP && crtl->profile)\n     return 1;\n \n   /* The code emitted by alpha_output_mi_thunk_osf uses the gp.  */\n-  if (current_function_is_thunk)\n+  if (crtl->is_thunk)\n     return 1;\n \n   /* The nonlocal receiver pattern assumes that the gp is valid for\n      the nested function.  Reasonable because it's almost always set\n      correctly already.  For the cases where that's wrong, make sure\n      the nested function loads its gp on entry.  */\n-  if (current_function_has_nonlocal_goto)\n+  if (crtl->has_nonlocal_goto)\n     return 1;\n \n   /* If we need a GP (we have a LDSYM insn or a CALL_INSN), load it first.\n@@ -7479,7 +7479,7 @@ alpha_expand_prologue (void)\n      the call to mcount ourselves, rather than having the linker do it\n      magically in response to -pg.  Since _mcount has special linkage,\n      don't represent the call as a call.  */\n-  if (TARGET_PROFILING_NEEDS_GP && current_function_profile)\n+  if (TARGET_PROFILING_NEEDS_GP && crtl->profile)\n     emit_insn (gen_prologue_mcount ());\n \n   if (TARGET_ABI_UNICOSMK)\n@@ -7825,7 +7825,7 @@ alpha_start_function (FILE *file, const char *fnname,\n \t Otherwise, do it here.  */\n       if (TARGET_ABI_OSF\n           && ! alpha_function_needs_gp\n-\t  && ! current_function_is_thunk)\n+\t  && ! crtl->is_thunk)\n \t{\n \t  putc ('$', file);\n \t  assemble_name (file, fnname);\n@@ -7936,7 +7936,7 @@ alpha_output_function_end_prologue (FILE *file)\n     fputs (\"\\t.prologue 0\\n\", file);\n   else if (!flag_inhibit_size_directive)\n     fprintf (file, \"\\t.prologue %d\\n\",\n-\t     alpha_function_needs_gp || current_function_is_thunk);\n+\t     alpha_function_needs_gp || crtl->is_thunk);\n }\n \n /* Write function epilogue.  */\n@@ -8002,7 +8002,7 @@ alpha_expand_epilogue (void)\n   fp_offset = 0;\n   sa_reg = stack_pointer_rtx;\n \n-  if (current_function_calls_eh_return)\n+  if (crtl->calls_eh_return)\n     eh_ofs = EH_RETURN_STACKADJ_RTX;\n   else\n     eh_ofs = NULL_RTX;\n@@ -8113,7 +8113,7 @@ alpha_expand_epilogue (void)\n \t register so as not to interfere with a potential fp restore,\n \t which must be consecutive with an SP restore.  */\n       if (frame_size < 32768\n-\t  && ! (TARGET_ABI_UNICOSMK && current_function_calls_alloca))\n+\t  && ! (TARGET_ABI_UNICOSMK && cfun->calls_alloca))\n \tsp_adj2 = GEN_INT (frame_size);\n       else if (TARGET_ABI_UNICOSMK)\n \t{"}, {"sha": "bc6fc8429805487e7ac2516a06cb8cf061cfd90a", "filename": "gcc/config/alpha/predicates.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Falpha%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Falpha%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fpredicates.md?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -268,7 +268,7 @@\n   tree op_decl, cfun_sec, op_sec;\n \n   /* If profiling is implemented via linker tricks, we can't jump\n-     to the nogp alternate entry point.  Note that current_function_profile\n+     to the nogp alternate entry point.  Note that crtl->profile\n      would not be correct, since that doesn't indicate if the target\n      function uses profiling.  */\n   /* ??? TARGET_PROFILING_NEEDS_GP isn't really the right test,"}, {"sha": "b5e2cb965477bdf26cde247ca3b4531d04251946", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -1283,7 +1283,7 @@ arc_output_function_epilogue (FILE *file, HOST_WIDE_INT size)\n       unsigned int pretend_size = current_frame_info.pretend_size;\n       unsigned int frame_size = size - pretend_size;\n       int restored, fp_restored_p;\n-      int can_trust_sp_p = !current_function_calls_alloca;\n+      int can_trust_sp_p = !cfun->calls_alloca;\n       const char *sp_str = reg_names[STACK_POINTER_REGNUM];\n       const char *fp_str = reg_names[FRAME_POINTER_REGNUM];\n "}, {"sha": "ea40fb23ab777b5e373b98479efc31dee6a47bf2", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -520,7 +520,7 @@ extern enum reg_class arc_regno_reg_class[FIRST_PSEUDO_REGISTER];\n    frame pointer.  This expression is evaluated in the reload pass.\n    If its value is nonzero the function will have a frame pointer.  */\n #define FRAME_POINTER_REQUIRED \\\n-(current_function_calls_alloca)\n+(cfun->calls_alloca)\n \n /* C statement to store the difference between the frame pointer\n    and the stack pointer values immediately after the function prologue.  */"}, {"sha": "82f8352eac2613c1e1da3d6cbc7e182d31c38b8e", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -1656,9 +1656,9 @@ use_return_insn (int iscond, rtx sibling)\n   if (crtl->args.pretend_args_size\n       || cfun->machine->uses_anonymous_args\n       /* Or if the function calls __builtin_eh_return () */\n-      || current_function_calls_eh_return\n+      || crtl->calls_eh_return\n       /* Or if the function calls alloca */\n-      || current_function_calls_alloca\n+      || cfun->calls_alloca\n       /* Or if there is a stack adjustment.  However, if the stack pointer\n \t is saved on the stack, we can use a pre-incrementing stack load.  */\n       || !(stack_adjust == 0 || (TARGET_APCS_FRAME && frame_pointer_needed\n@@ -3373,7 +3373,7 @@ require_pic_register (void)\n      We don't want those calls to affect any assumptions about the real\n      function; and further, we can't call entry_of_function() until we\n      start the real expansion process.  */\n-  if (!current_function_uses_pic_offset_table)\n+  if (!crtl->uses_pic_offset_table)\n     {\n       gcc_assert (can_create_pseudo_p ());\n       if (arm_pic_register != INVALID_REGNUM)\n@@ -3384,7 +3384,7 @@ require_pic_register (void)\n \t     if we are being called as part of the cost-estimation\n \t     process.  */\n \t  if (current_ir_type () != IR_GIMPLE)\n-\t    current_function_uses_pic_offset_table = 1;\n+\t    crtl->uses_pic_offset_table = 1;\n \t}\n       else\n \t{\n@@ -3397,7 +3397,7 @@ require_pic_register (void)\n \t     process.  */\n \t  if (current_ir_type () != IR_GIMPLE)\n \t    {\n-\t      current_function_uses_pic_offset_table = 1;\n+\t      crtl->uses_pic_offset_table = 1;\n \t      start_sequence ();\n \n \t      arm_load_pic_register (0UL);\n@@ -3595,7 +3595,7 @@ arm_load_pic_register (unsigned long saved_regs ATTRIBUTE_UNUSED)\n   rtx l1, labelno, pic_tmp, pic_tmp2, pic_rtx, pic_reg;\n   rtx global_offset_table;\n \n-  if (current_function_uses_pic_offset_table == 0 || TARGET_SINGLE_PIC_BASE)\n+  if (crtl->uses_pic_offset_table == 0 || TARGET_SINGLE_PIC_BASE)\n     return;\n \n   gcc_assert (flag_pic);\n@@ -10734,7 +10734,7 @@ arm_compute_save_reg0_reg12_mask (void)\n       if (flag_pic\n \t  && !TARGET_SINGLE_PIC_BASE\n \t  && arm_pic_register != INVALID_REGNUM\n-\t  && current_function_uses_pic_offset_table)\n+\t  && crtl->uses_pic_offset_table)\n \tsave_reg_mask |= 1 << PIC_OFFSET_TABLE_REGNUM;\n     }\n   else\n@@ -10755,7 +10755,7 @@ arm_compute_save_reg0_reg12_mask (void)\n \t  && !TARGET_SINGLE_PIC_BASE\n \t  && arm_pic_register != INVALID_REGNUM\n \t  && (df_regs_ever_live_p (PIC_OFFSET_TABLE_REGNUM)\n-\t      || current_function_uses_pic_offset_table))\n+\t      || crtl->uses_pic_offset_table))\n \tsave_reg_mask |= 1 << PIC_OFFSET_TABLE_REGNUM;\n \n       /* The prologue will copy SP into R0, so save it.  */\n@@ -10764,7 +10764,7 @@ arm_compute_save_reg0_reg12_mask (void)\n     }\n \n   /* Save registers so the exception handler can modify them.  */\n-  if (current_function_calls_eh_return)\n+  if (crtl->calls_eh_return)\n     {\n       unsigned int i;\n \n@@ -10825,7 +10825,7 @@ arm_compute_save_reg_mask (void)\n       || (save_reg_mask\n \t  && optimize_size\n \t  && ARM_FUNC_TYPE (func_type) == ARM_FT_NORMAL\n-\t  && !current_function_calls_eh_return))\n+\t  && !crtl->calls_eh_return))\n     save_reg_mask |= 1 << LR_REGNUM;\n \n   if (cfun->machine->lr_save_eliminated)\n@@ -10887,7 +10887,7 @@ thumb1_compute_save_reg_mask (void)\n   if (flag_pic\n       && !TARGET_SINGLE_PIC_BASE\n       && arm_pic_register != INVALID_REGNUM\n-      && current_function_uses_pic_offset_table)\n+      && crtl->uses_pic_offset_table)\n     mask |= 1 << PIC_OFFSET_TABLE_REGNUM;\n \n   /* See if we might need r11 for calls to _interwork_r11_call_via_rN().  */\n@@ -11002,7 +11002,7 @@ output_return_instruction (rtx operand, int really_return, int reverse)\n       return \"\";\n     }\n \n-  gcc_assert (!current_function_calls_alloca || really_return);\n+  gcc_assert (!cfun->calls_alloca || really_return);\n \n   sprintf (conditional, \"%%?%%%c0\", reverse ? 'D' : 'd');\n \n@@ -11268,7 +11268,7 @@ arm_output_function_prologue (FILE *f, HOST_WIDE_INT frame_size)\n   if (cfun->machine->lr_save_eliminated)\n     asm_fprintf (f, \"\\t%@ link register save eliminated.\\n\");\n \n-  if (current_function_calls_eh_return)\n+  if (crtl->calls_eh_return)\n     asm_fprintf (f, \"\\t@ Calls __builtin_eh_return.\\n\");\n \n   return_used_this_function = 0;\n@@ -11315,7 +11315,7 @@ arm_output_epilogue (rtx sibling)\n \n   /* If we are throwing an exception, then we really must be doing a\n      return, so we can't tail-call.  */\n-  gcc_assert (!current_function_calls_eh_return || really_return);\n+  gcc_assert (!crtl->calls_eh_return || really_return);\n \n   offsets = arm_get_frame_offsets ();\n   saved_regs_mask = offsets->saved_regs_mask;\n@@ -11446,7 +11446,7 @@ arm_output_epilogue (rtx sibling)\n \t special function exit sequence, or we are not really returning.  */\n       if (really_return\n \t  && ARM_FUNC_TYPE (func_type) == ARM_FT_NORMAL\n-\t  && !current_function_calls_eh_return)\n+\t  && !crtl->calls_eh_return)\n \t/* Delete the LR from the register mask, so that the LR on\n \t   the stack is loaded into the PC in the register mask.  */\n \tsaved_regs_mask &= ~ (1 << LR_REGNUM);\n@@ -11463,7 +11463,7 @@ arm_output_epilogue (rtx sibling)\n          occur.  If the stack pointer already points at the right\n          place, then omit the subtraction.  */\n       if (offsets->outgoing_args != (1 + (int) bit_count (saved_regs_mask))\n-\t  || current_function_calls_alloca)\n+\t  || cfun->calls_alloca)\n \tasm_fprintf (f, \"\\tsub\\t%r, %r, #%d\\n\", SP_REGNUM, FP_REGNUM,\n \t\t     4 * bit_count (saved_regs_mask));\n       print_multi_reg (f, \"ldmfd\\t%r, \", SP_REGNUM, saved_regs_mask, 0);\n@@ -11523,10 +11523,10 @@ arm_output_epilogue (rtx sibling)\n \t      count = offsets->saved_regs - offsets->saved_args;\n \t      if (optimize_size\n \t\t  && count != 0\n-\t\t  && !current_function_calls_eh_return\n+\t\t  && !crtl->calls_eh_return\n \t\t  && bit_count(saved_regs_mask) * 4 == count\n \t\t  && !IS_INTERRUPT (func_type)\n-\t\t  && !cfun->tail_call_emit)\n+\t\t  && !crtl->tail_call_emit)\n \t\t{\n \t\t  unsigned long mask;\n \t\t  mask = (1 << (arm_size_return_regs() / 4)) - 1;\n@@ -11628,7 +11628,7 @@ arm_output_epilogue (rtx sibling)\n \t  && really_return\n \t  && crtl->args.pretend_args_size == 0\n \t  && saved_regs_mask & (1 << LR_REGNUM)\n-\t  && !current_function_calls_eh_return)\n+\t  && !crtl->calls_eh_return)\n \t{\n \t  saved_regs_mask &= ~ (1 << LR_REGNUM);\n \t  saved_regs_mask |=   (1 << PC_REGNUM);\n@@ -11675,7 +11675,7 @@ arm_output_epilogue (rtx sibling)\n     return \"\";\n \n   /* Stack adjustment for exception handler.  */\n-  if (current_function_calls_eh_return)\n+  if (crtl->calls_eh_return)\n     asm_fprintf (f, \"\\tadd\\t%r, %r, %r\\n\", SP_REGNUM, SP_REGNUM,\n \t\t ARM_EH_STACKADJ_REGNUM);\n \n@@ -12133,7 +12133,7 @@ arm_get_frame_offsets (void)\n \t    }\n \n \t  if (reg == -1 && arm_size_return_regs () <= 12\n-\t      && !cfun->tail_call_emit)\n+\t      && !crtl->tail_call_emit)\n \t    {\n \t      /* Push/pop an argument register (r3) if all callee saved\n \t         registers are already being pushed.  */\n@@ -12664,7 +12664,7 @@ arm_expand_prologue (void)\n      scheduling in the prolog.  Similarly if we want non-call exceptions\n      using the EABI unwinder, to prevent faulting instructions from being\n      swapped with a stack adjustment.  */\n-  if (current_function_profile || !TARGET_SCHED_PROLOG\n+  if (crtl->profile || !TARGET_SCHED_PROLOG\n       || (ARM_EABI_UNWIND_TABLES && flag_non_call_exceptions))\n     emit_insn (gen_blockage ());\n \n@@ -16180,7 +16180,7 @@ thumb_pushpop (FILE *f, unsigned long mask, int push, int *cfa_offset,\n     {\n       /* Catch popping the PC.  */\n       if (TARGET_INTERWORK || TARGET_BACKTRACE\n-\t  || current_function_calls_eh_return)\n+\t  || crtl->calls_eh_return)\n \t{\n \t  /* The PC is never poped directly, instead\n \t     it is popped into r3 and then BX is used.  */\n@@ -16255,7 +16255,7 @@ thumb_exit (FILE *f, int reg_containing_return_addr)\n      return.  */\n   if (pops_needed == 0)\n     {\n-      if (current_function_calls_eh_return)\n+      if (crtl->calls_eh_return)\n \tasm_fprintf (f, \"\\tadd\\t%r, %r\\n\", SP_REGNUM, ARM_EH_STACKADJ_REGNUM);\n \n       asm_fprintf (f, \"\\tbx\\t%r\\n\", reg_containing_return_addr);\n@@ -16267,7 +16267,7 @@ thumb_exit (FILE *f, int reg_containing_return_addr)\n   else if (!TARGET_INTERWORK\n \t   && !TARGET_BACKTRACE\n \t   && !is_called_in_ARM_mode (current_function_decl)\n-\t   && !current_function_calls_eh_return)\n+\t   && !crtl->calls_eh_return)\n     {\n       asm_fprintf (f, \"\\tpop\\t{%r}\\n\", PC_REGNUM);\n       return;\n@@ -16278,7 +16278,7 @@ thumb_exit (FILE *f, int reg_containing_return_addr)\n \n   /* If returning via __builtin_eh_return, the bottom three registers\n      all contain information needed for the return.  */\n-  if (current_function_calls_eh_return)\n+  if (crtl->calls_eh_return)\n     size = 12;\n   else\n     {\n@@ -16489,7 +16489,7 @@ thumb_exit (FILE *f, int reg_containing_return_addr)\n       asm_fprintf (f, \"\\tmov\\t%r, %r\\n\", LAST_ARG_REGNUM, IP_REGNUM);\n     }\n \n-  if (current_function_calls_eh_return)\n+  if (crtl->calls_eh_return)\n     asm_fprintf (f, \"\\tadd\\t%r, %r\\n\", SP_REGNUM, ARM_EH_STACKADJ_REGNUM);\n \n   /* Return to caller.  */\n@@ -16995,7 +16995,7 @@ thumb1_expand_prologue (void)\n      scheduling in the prolog.  Similarly if we want non-call exceptions\n      using the EABI unwinder, to prevent faulting instructions from being\n      swapped with a stack adjustment.  */\n-  if (current_function_profile || !TARGET_SCHED_PROLOG\n+  if (crtl->profile || !TARGET_SCHED_PROLOG\n       || (ARM_EABI_UNWIND_TABLES && flag_non_call_exceptions))\n     emit_insn (gen_blockage ());\n \n@@ -17045,7 +17045,7 @@ thumb1_expand_epilogue (void)\n      the stack adjustment will not be deleted.  */\n   emit_insn (gen_prologue_use (stack_pointer_rtx));\n \n-  if (current_function_profile || !TARGET_SCHED_PROLOG)\n+  if (crtl->profile || !TARGET_SCHED_PROLOG)\n     emit_insn (gen_blockage ());\n \n   /* Emit a clobber for each insn that will be restored in the epilogue,\n@@ -18633,7 +18633,7 @@ arm_unwind_emit (FILE * asm_out_file, rtx insn)\n   if (!ARM_EABI_UNWIND_TABLES)\n     return;\n \n-  if (!(flag_unwind_tables || cfun->uses_eh_lsda)\n+  if (!(flag_unwind_tables || crtl->uses_eh_lsda)\n       && (TREE_NOTHROW (current_function_decl)\n \t  || cfun->all_throwers_are_sibcalls))\n     return;\n@@ -18722,7 +18722,7 @@ arm_output_fn_unwind (FILE * f, bool prologue)\n       /* If this function will never be unwound, then mark it as such.\n          The came condition is used in arm_unwind_emit to suppress\n \t the frame annotations.  */\n-      if (!(flag_unwind_tables || cfun->uses_eh_lsda)\n+      if (!(flag_unwind_tables || crtl->uses_eh_lsda)\n \t  && (TREE_NOTHROW (current_function_decl)\n \t      || cfun->all_throwers_are_sibcalls))\n \tfputs(\"\\t.cantunwind\\n\", f);"}, {"sha": "b6e182c0d22e41bc76014b777b2bec26abca4c8a", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -999,7 +999,7 @@ extern int arm_structure_size_boundary;\n #endif\n \n #define FRAME_POINTER_REQUIRED\t\t\t\t\t\\\n-  (current_function_has_nonlocal_label\t\t\t\t\\\n+  (cfun->has_nonlocal_label\t\t\t\t\\\n    || SUBTARGET_FRAME_POINTER_REQUIRED\t\t\t\t\\\n    || (TARGET_ARM && TARGET_APCS_FRAME && ! leaf_function_p ()))\n \n@@ -2402,7 +2402,7 @@ extern int making_const_table;\n         {\t\t\t\t\t\t\\\n           if (is_called_in_ARM_mode (DECL)\t\t\\\n \t      || (TARGET_THUMB1 && !TARGET_THUMB1_ONLY\t\\\n-\t\t  && current_function_is_thunk))\t\\\n+\t\t  && crtl->is_thunk))\t\\\n             fprintf (STREAM, \"\\t.code 32\\n\") ;\t\t\\\n           else if (TARGET_THUMB1)\t\t\t\\\n            fprintf (STREAM, \"\\t.code\\t16\\n\\t.thumb_func\\n\") ;\t\\"}, {"sha": "c66ea74d2afd231796ea650dfc266437609811d0", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -10397,7 +10397,7 @@\n   [(clobber (const_int 0))]\n   \"TARGET_EITHER\"\n   \"\n-  if (current_function_calls_eh_return)\n+  if (crtl->calls_eh_return)\n     emit_insn (gen_prologue_use (gen_rtx_REG (Pmode, 2)));\n   if (TARGET_THUMB1)\n     thumb1_expand_epilogue ();"}, {"sha": "ca56f7bb66905f622ab9667ef35f91fd54816cf2", "filename": "gcc/config/arm/linux-elf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Farm%2Flinux-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Farm%2Flinux-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flinux-elf.h?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -114,7 +114,7 @@\n   emit_insn (gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (SImode, LR_REGNUM)))\n \n /* The GNU/Linux profiler needs a frame pointer.  */\n-#define SUBTARGET_FRAME_POINTER_REQUIRED current_function_profile\n+#define SUBTARGET_FRAME_POINTER_REQUIRED crtl->profile\n \n /* Add .note.GNU-stack.  */\n #undef NEED_INDICATE_EXEC_STACK"}, {"sha": "7248fd6a27cdd8496c59c620af3d13d465ea02d1", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -2735,7 +2735,7 @@ out_movhi_mr_r (rtx insn, rtx op[], int *l)\n int\n frame_pointer_required_p (void)\n {\n-  return (current_function_calls_alloca\n+  return (cfun->calls_alloca\n \t  || crtl->args.info.nregs == 0\n   \t  || get_frame_size () > 0);\n }"}, {"sha": "87a1d9360b42d525d5bf4fd0452dca5cc600985c", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -307,7 +307,7 @@ legitimize_pic_address (rtx orig, rtx reg, rtx picreg)\n \n       emit_move_insn (reg, new);\n       if (picreg == pic_offset_table_rtx)\n-\tcurrent_function_uses_pic_offset_table = 1;\n+\tcrtl->uses_pic_offset_table = 1;\n       return reg;\n     }\n \n@@ -364,7 +364,7 @@ must_save_p (bool is_inthandler, unsigned regno)\n   if (D_REGNO_P (regno))\n     {\n       bool is_eh_return_reg = false;\n-      if (current_function_calls_eh_return)\n+      if (crtl->calls_eh_return)\n \t{\n \t  unsigned j;\n \t  for (j = 0; ; j++)\n@@ -389,7 +389,7 @@ must_save_p (bool is_inthandler, unsigned regno)\n \t       && (is_inthandler || !call_used_regs[regno]))\n \t      || (!TARGET_FDPIC\n \t\t  && regno == PIC_OFFSET_TABLE_REGNUM\n-\t\t  && (current_function_uses_pic_offset_table\n+\t\t  && (crtl->uses_pic_offset_table\n \t\t      || (TARGET_ID_SHARED_LIBRARY && !current_function_is_leaf))));\n     }\n   else\n@@ -452,7 +452,7 @@ stack_frame_needed_p (void)\n {\n   /* EH return puts a new return address into the frame using an\n      address relative to the frame pointer.  */\n-  if (current_function_calls_eh_return)\n+  if (crtl->calls_eh_return)\n     return true;\n   return frame_pointer_needed;\n }\n@@ -854,7 +854,7 @@ add_to_reg (rtx reg, HOST_WIDE_INT value, int frame, int epilogue_p)\n \t    if ((df_regs_ever_live_p (i) && ! call_used_regs[i])\n \t\t|| (!TARGET_FDPIC\n \t\t    && i == PIC_OFFSET_TABLE_REGNUM\n-\t\t    && (current_function_uses_pic_offset_table\n+\t\t    && (crtl->uses_pic_offset_table\n \t\t\t|| (TARGET_ID_SHARED_LIBRARY\n \t\t\t    && ! current_function_is_leaf))))\n \t      break;\n@@ -1167,13 +1167,13 @@ bfin_expand_prologue (void)\n       return;\n     }\n \n-  if (current_function_limit_stack\n+  if (crtl->limit_stack\n       || TARGET_STACK_CHECK_L1)\n     {\n       HOST_WIDE_INT offset\n \t= bfin_initial_elimination_offset (ARG_POINTER_REGNUM,\n \t\t\t\t\t   STACK_POINTER_REGNUM);\n-      rtx lim = current_function_limit_stack ? stack_limit_rtx : NULL_RTX;\n+      rtx lim = crtl->limit_stack ? stack_limit_rtx : NULL_RTX;\n       rtx p2reg = gen_rtx_REG (Pmode, REG_P2);\n \n       if (!lim)\n@@ -1219,7 +1219,7 @@ bfin_expand_prologue (void)\n \n   if (TARGET_ID_SHARED_LIBRARY\n       && !TARGET_SEP_DATA\n-      && (current_function_uses_pic_offset_table\n+      && (crtl->uses_pic_offset_table\n \t  || !current_function_is_leaf))\n     bfin_load_pic_reg (pic_offset_table_rtx);\n }"}, {"sha": "b197956b774485806958f37f3634b57fb33db051", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -412,13 +412,13 @@ cris_conditional_register_usage (void)\n     reg_names[CRIS_CC0_REGNUM] = \"ccr\";\n }\n \n-/* Return current_function_uses_pic_offset_table.  For use in cris.md,\n+/* Return crtl->uses_pic_offset_table.  For use in cris.md,\n    since some generated files do not include function.h.  */\n \n int\n cris_cfun_uses_pic_table (void)\n {\n-  return current_function_uses_pic_offset_table;\n+  return crtl->uses_pic_offset_table;\n }\n \n /* Given an rtx, return the text string corresponding to the CODE of X.\n@@ -604,7 +604,7 @@ cris_reg_saved_in_regsave_area (unsigned int regno, bool got_really_used)\n \t\t  && !call_used_regs[regno + 1]))))\n      && (regno != FRAME_POINTER_REGNUM || !frame_pointer_needed)\n      && regno != CRIS_SRP_REGNUM)\n-    || (current_function_calls_eh_return\n+    || (crtl->calls_eh_return\n \t&& (regno == EH_RETURN_DATA_REGNO (0)\n \t    || regno == EH_RETURN_DATA_REGNO (1)\n \t    || regno == EH_RETURN_DATA_REGNO (2)\n@@ -1188,7 +1188,7 @@ cris_initial_frame_pointer_offset (void)\n   int offs = 0;\n   bool got_really_used = false;\n \n-  if (current_function_uses_pic_offset_table)\n+  if (crtl->uses_pic_offset_table)\n     {\n       push_topmost_sequence ();\n       got_really_used\n@@ -1703,7 +1703,7 @@ cris_simple_epilogue (void)\n       || crtl->args.pretend_args_size\n       || crtl->args.size\n       || crtl->outgoing_args_size\n-      || current_function_calls_eh_return\n+      || crtl->calls_eh_return\n \n       /* If we're not supposed to emit prologue and epilogue, we must\n \t not emit return-type instructions.  */\n@@ -1714,7 +1714,7 @@ cris_simple_epilogue (void)\n   if (TARGET_V32 && cris_return_address_on_stack ())\n     return false;\n \n-  if (current_function_uses_pic_offset_table)\n+  if (crtl->uses_pic_offset_table)\n     {\n       push_topmost_sequence ();\n       got_really_used\n@@ -2751,7 +2751,7 @@ cris_expand_prologue (void)\n \n   CRIS_ASSERT (size >= 0);\n \n-  if (current_function_uses_pic_offset_table)\n+  if (crtl->uses_pic_offset_table)\n     {\n       /* A reference may have been optimized out (like the abort () in\n \t fde_split in unwind-dw2-fde.c, at least 3.2.1) so check that\n@@ -3030,7 +3030,7 @@ cris_expand_epilogue (void)\n   if (!TARGET_PROLOGUE_EPILOGUE)\n     return;\n \n-  if (current_function_uses_pic_offset_table)\n+  if (crtl->uses_pic_offset_table)\n     {\n       /* A reference may have been optimized out (like the abort () in\n \t fde_split in unwind-dw2-fde.c, at least 3.2.1) so check that\n@@ -3173,7 +3173,7 @@ cris_expand_epilogue (void)\n      the return address on the stack.  */\n   if (return_address_on_stack && pretend == 0)\n     {\n-      if (TARGET_V32 || current_function_calls_eh_return)\n+      if (TARGET_V32 || crtl->calls_eh_return)\n \t{\n \t  rtx mem;\n \t  rtx insn;\n@@ -3189,7 +3189,7 @@ cris_expand_epilogue (void)\n \t  REG_NOTES (insn)\n \t    = alloc_EXPR_LIST (REG_INC, stack_pointer_rtx, REG_NOTES (insn));\n \n-\t  if (current_function_calls_eh_return)\n+\t  if (crtl->calls_eh_return)\n \t    emit_insn (gen_addsi3 (stack_pointer_rtx,\n \t\t\t\t   stack_pointer_rtx,\n \t\t\t\t   gen_rtx_raw_REG (SImode,\n@@ -3231,7 +3231,7 @@ cris_expand_epilogue (void)\n     }\n \n   /* Perform the \"physical\" unwinding that the EH machinery calculated.  */\n-  if (current_function_calls_eh_return)\n+  if (crtl->calls_eh_return)\n     emit_insn (gen_addsi3 (stack_pointer_rtx,\n \t\t\t   stack_pointer_rtx,\n \t\t\t   gen_rtx_raw_REG (SImode,\n@@ -3484,7 +3484,7 @@ cris_expand_pic_call_address (rtx *opp)\n \t\t for v32.  */\n \t      rtx tem, rm, ro;\n \t      gcc_assert (can_create_pseudo_p ());\n-\t      current_function_uses_pic_offset_table = 1;\n+\t      crtl->uses_pic_offset_table = 1;\n \t      tem = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op),\n \t\t\t\t    TARGET_V32\n \t\t\t\t    ? CRIS_UNSPEC_PLT_PCREL\n@@ -3519,7 +3519,7 @@ cris_expand_pic_call_address (rtx *opp)\n \t      rtx tem, mem, rm, ro;\n \n \t      gcc_assert (can_create_pseudo_p ());\n-\t      current_function_uses_pic_offset_table = 1;\n+\t      crtl->uses_pic_offset_table = 1;\n \t      tem = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op),\n \t\t\t\t    CRIS_UNSPEC_PLTGOTREAD);\n \t      rm = gen_reg_rtx (Pmode);\n@@ -3591,7 +3591,7 @@ cris_asm_output_symbol_ref (FILE *file, rtx x)\n      assemble_name (file, str);\n \n      /* Sanity check.  */\n-     if (!TARGET_V32 && !current_function_uses_pic_offset_table)\n+     if (!TARGET_V32 && !crtl->uses_pic_offset_table)\n        output_operand_lossage (\"PIC register isn't set up\");\n     }\n   else\n@@ -3608,7 +3608,7 @@ cris_asm_output_label_ref (FILE *file, char *buf)\n       assemble_name (file, buf);\n \n       /* Sanity check.  */\n-      if (!TARGET_V32 && !current_function_uses_pic_offset_table)\n+      if (!TARGET_V32 && !crtl->uses_pic_offset_table)\n \tinternal_error (\"emitting PIC operand, but PIC register isn't set up\");\n     }\n   else"}, {"sha": "e466204786e035b860efc396f2f4c14c877a5a80", "filename": "gcc/config/cris/cris.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fcris%2Fcris.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fcris%2Fcris.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.md?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -995,7 +995,7 @@\n \t    /* FIXME: add a REG_EQUAL (or is it REG_EQUIV) note to the\n \t       destination register for the symbol.  It might not be\n \t       worth it.  Measure.  */\n-\t    current_function_uses_pic_offset_table = 1;\n+\t    crtl->uses_pic_offset_table = 1;\n \t    if (t == cris_rel_symbol)\n \t      {\n \t\t/* Change a \"move.d sym(+offs),rN\" into (allocate register rM)\n@@ -1025,7 +1025,7 @@\n \t\t  {\n \t\t    /* We still uses GOT-relative addressing for\n \t\t       pre-v32.\t */\n-\t\t    current_function_uses_pic_offset_table = 1;\n+\t\t    crtl->uses_pic_offset_table = 1;\n \t\t    tem = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, sym),\n \t\t\t\t\t  CRIS_UNSPEC_GOTREL);\n \t\t    if (offs != 0)"}, {"sha": "c3e1e203113bff1dbd206f818221c98306882106", "filename": "gcc/config/crx/crx.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fcrx%2Fcrx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fcrx%2Fcrx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx.h?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -277,7 +277,7 @@ enum reg_class\n \n #define FIRST_PARM_OFFSET(FNDECL)  0\n \n-#define FRAME_POINTER_REQUIRED (current_function_calls_alloca)\n+#define FRAME_POINTER_REQUIRED (cfun->calls_alloca)\n \n #define ELIMINABLE_REGS \\\n   { \\"}, {"sha": "388998333411dbcc805e82efe4884131f629bff6", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -278,7 +278,7 @@ machopic_function_base_name (void)\n   if (function_base == NULL)\n     function_base = ggc_alloc_string (\"<pic base>\", sizeof (\"<pic base>\"));\n \n-  current_function_uses_pic_offset_table = 1;\n+  crtl->uses_pic_offset_table = 1;\n \n   return function_base;\n }"}, {"sha": "1dd1a523ac0ec022a4bcd0f30061a571fbb6e841", "filename": "gcc/config/fr30/fr30.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Ffr30%2Ffr30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Ffr30%2Ffr30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -140,7 +140,7 @@ static int fr30_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n    && ! call_used_regs [regno]         )\n \n #define MUST_SAVE_FRAME_POINTER\t (df_regs_ever_live_p (FRAME_POINTER_REGNUM)  || frame_pointer_needed)\n-#define MUST_SAVE_RETURN_POINTER (df_regs_ever_live_p (RETURN_POINTER_REGNUM) || current_function_profile)\n+#define MUST_SAVE_RETURN_POINTER (df_regs_ever_live_p (RETURN_POINTER_REGNUM) || crtl->profile)\n \n #if UNITS_PER_WORD == 4\n #define WORD_ALIGN(SIZE) (((SIZE) + 3) & ~3)\n@@ -349,7 +349,7 @@ fr30_expand_prologue (void)\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n-  if (current_function_profile)\n+  if (crtl->profile)\n     emit_insn (gen_blockage ());\n }\n "}, {"sha": "a89c8bb9416ae7fae25e5bb002e48ba772a0d2f0", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -1172,7 +1172,7 @@ frv_stack_info (void)\n \t  for (regno = first; regno <= last; regno++)\n \t    {\n \t      if ((df_regs_ever_live_p (regno) && !call_used_regs[regno])\n-\t\t  || (current_function_calls_eh_return\n+\t\t  || (crtl->calls_eh_return\n \t\t      && (regno >= FIRST_EH_REGNUM && regno <= LAST_EH_REGNUM))\n \t\t  || (!TARGET_FDPIC && flag_pic\n \t\t      && cfun->uses_pic_offset_table && regno == PIC_REGNO))\n@@ -1957,7 +1957,7 @@ frv_expand_epilogue (bool emit_return)\n     }\n \n   /* If this function uses eh_return, add the final stack adjustment now.  */\n-  if (current_function_calls_eh_return)\n+  if (crtl->calls_eh_return)\n     emit_insn (gen_stack_adjust (sp, sp, EH_RETURN_STACKADJ_RTX));\n \n   if (emit_return)"}, {"sha": "2df9683f457af41888eff90c44a1788dbc249f70", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -5783,7 +5783,7 @@ ix86_frame_pointer_required (void)\n \t  || ix86_current_function_calls_tls_descriptor))\n     return 1;\n \n-  if (current_function_profile)\n+  if (crtl->profile)\n     return 1;\n \n   return 0;\n@@ -5993,7 +5993,7 @@ gen_push (rtx arg)\n static unsigned int\n ix86_select_alt_pic_regnum (void)\n {\n-  if (current_function_is_leaf && !current_function_profile\n+  if (current_function_is_leaf && !crtl->profile\n       && !ix86_current_function_calls_tls_descriptor)\n     {\n       int i;\n@@ -6012,16 +6012,16 @@ ix86_save_reg (unsigned int regno, int maybe_eh_return)\n   if (pic_offset_table_rtx\n       && regno == REAL_PIC_OFFSET_TABLE_REGNUM\n       && (df_regs_ever_live_p (REAL_PIC_OFFSET_TABLE_REGNUM)\n-\t  || current_function_profile\n-\t  || current_function_calls_eh_return\n-\t  || current_function_uses_const_pool))\n+\t  || crtl->profile\n+\t  || crtl->calls_eh_return\n+\t  || crtl->uses_const_pool))\n     {\n       if (ix86_select_alt_pic_regnum () != INVALID_REGNUM)\n \treturn 0;\n       return 1;\n     }\n \n-  if (current_function_calls_eh_return && maybe_eh_return)\n+  if (crtl->calls_eh_return && maybe_eh_return)\n     {\n       unsigned i;\n       for (i = 0; ; i++)\n@@ -6185,7 +6185,7 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n      expander assumes that last crtl->outgoing_args_size\n      of stack frame are unused.  */\n   if (ACCUMULATE_OUTGOING_ARGS\n-      && (!current_function_is_leaf || current_function_calls_alloca\n+      && (!current_function_is_leaf || cfun->calls_alloca\n \t  || ix86_current_function_calls_tls_descriptor))\n     {\n       offset += crtl->outgoing_args_size;\n@@ -6196,7 +6196,7 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n \n   /* Align stack boundary.  Only needed if we're calling another function\n      or using alloca.  */\n-  if (!current_function_is_leaf || current_function_calls_alloca\n+  if (!current_function_is_leaf || cfun->calls_alloca\n       || ix86_current_function_calls_tls_descriptor)\n     frame->padding2 = ((offset + preferred_alignment - 1)\n \t\t       & -preferred_alignment) - offset;\n@@ -6246,7 +6246,7 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n \t   (long)frame->hard_frame_pointer_offset);\n   fprintf (stderr, \"stack_pointer_offset: %ld\\n\", (long)frame->stack_pointer_offset);\n   fprintf (stderr, \"current_function_is_leaf: %ld\\n\", (long)current_function_is_leaf);\n-  fprintf (stderr, \"current_function_calls_alloca: %ld\\n\", (long)current_function_calls_alloca);\n+  fprintf (stderr, \"cfun->calls_alloca: %ld\\n\", (long)cfun->calls_alloca);\n   fprintf (stderr, \"x86_current_function_calls_tls_descriptor: %ld\\n\", (long)ix86_current_function_calls_tls_descriptor);\n #endif\n }\n@@ -6531,7 +6531,7 @@ ix86_expand_prologue (void)\n   pic_reg_used = false;\n   if (pic_offset_table_rtx\n       && (df_regs_ever_live_p (REAL_PIC_OFFSET_TABLE_REGNUM)\n-\t  || current_function_profile))\n+\t  || crtl->profile))\n     {\n       unsigned int alt_pic_reg_used = ix86_select_alt_pic_regnum ();\n \n@@ -6566,7 +6566,7 @@ ix86_expand_prologue (void)\n \n   /* Prevent function calls from being scheduled before the call to mcount.\n      In the pic_reg_used case, make sure that the got load isn't deleted.  */\n-  if (current_function_profile)\n+  if (crtl->profile)\n     {\n       if (pic_reg_used)\n \temit_insn (gen_prologue_use (pic_offset_table_rtx));\n@@ -6621,7 +6621,7 @@ ix86_expand_epilogue (int style)\n      eh_return: the eax and edx registers are marked as saved, but not\n      restored along this path.  */\n   offset = frame.nregs;\n-  if (current_function_calls_eh_return && style != 2)\n+  if (crtl->calls_eh_return && style != 2)\n     offset -= 2;\n   offset *= -UNITS_PER_WORD;\n \n@@ -6643,7 +6643,7 @@ ix86_expand_epilogue (int style)\n       || (frame_pointer_needed && TARGET_USE_LEAVE\n \t  && cfun->machine->use_fast_prologue_epilogue\n \t  && frame.nregs == 1)\n-      || current_function_calls_eh_return)\n+      || crtl->calls_eh_return)\n     {\n       /* Restore registers.  We can use ebp or esp to address the memory\n \t locations.  If both are available, default to ebp, since offsets"}, {"sha": "ec5dc4e2230a9aef15003ad8582a1940c10c098a", "filename": "gcc/config/i386/linux.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fi386%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fi386%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Flinux.h?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -55,7 +55,7 @@ along with GCC; see the file COPYING3.  If not see\n    frame, so we cannot allow profiling without a frame pointer.  */\n \n #undef SUBTARGET_FRAME_POINTER_REQUIRED\n-#define SUBTARGET_FRAME_POINTER_REQUIRED current_function_profile\n+#define SUBTARGET_FRAME_POINTER_REQUIRED crtl->profile\n \n #undef SIZE_TYPE\n #define SIZE_TYPE \"unsigned int\""}, {"sha": "22d0c0a3ce1db75c9faa5fe7261f11b9eabee691", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -2379,7 +2379,7 @@ ia64_compute_frame_size (HOST_WIDE_INT size)\n      Likewise for -a profiling for the bb_init_func argument.  For -ax\n      profiling, we need two output registers for the two bb_init_trace_func\n      arguments.  */\n-  if (current_function_profile)\n+  if (crtl->profile)\n     i = MAX (i, 1);\n #endif\n   current_frame_info.n_output_regs = i;\n@@ -2460,7 +2460,7 @@ ia64_compute_frame_size (HOST_WIDE_INT size)\n       /* Similarly for gp.  Note that if we're calling setjmp, the stacked\n \t registers are clobbered, so we fall back to the stack.  */\n       current_frame_info.r[reg_save_gp]\n-\t= (current_function_calls_setjmp ? 0 : find_gr_spill (reg_save_gp, 1));\n+\t= (cfun->calls_setjmp ? 0 : find_gr_spill (reg_save_gp, 1));\n       if (current_frame_info.r[reg_save_gp] == 0)\n \t{\n \t  SET_HARD_REG_BIT (mask, GR_REG (1));\n@@ -5058,7 +5058,7 @@ ia64_secondary_reload_class (enum reg_class class,\n       /* ??? This happens if we cse/gcse a BImode value across a call,\n \t and the function has a nonlocal goto.  This is because global\n \t does not allocate call crossing pseudos to hard registers when\n-\t current_function_has_nonlocal_goto is true.  This is relatively\n+\t crtl->has_nonlocal_goto is true.  This is relatively\n \t common for C++ programs that use exceptions.  To reproduce,\n \t return NO_REGS and compile libstdc++.  */\n       if (GET_CODE (x) == MEM)"}, {"sha": "995b93bdc1d65d5da436280975eeba36622b4458", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -1619,7 +1619,7 @@ compute_frame_size (HOST_WIDE_INT size)\n \n   /* If a function dynamically allocates the stack and\n      has 0 for STACK_DYNAMIC_OFFSET then allocate some stack space.  */\n-  if (args_size == 0 && current_function_calls_alloca)\n+  if (args_size == 0 && cfun->calls_alloca)\n     args_size = 4 * UNITS_PER_WORD;\n \n   total_size = var_size + args_size + extra_size;\n@@ -1635,7 +1635,7 @@ compute_frame_size (HOST_WIDE_INT size)\n     }\n \n   /* We need to restore these for the handler.  */\n-  if (current_function_calls_eh_return)\n+  if (crtl->calls_eh_return)\n     {\n       unsigned int i;\n \n@@ -2064,7 +2064,7 @@ iq2000_expand_epilogue (void)\n \n       save_restore_insns (0);\n \n-      if (current_function_calls_eh_return)\n+      if (crtl->calls_eh_return)\n \t{\n \t  rtx eh_ofs = EH_RETURN_STACKADJ_RTX;\n \t  emit_insn (gen_addsi3 (eh_ofs, eh_ofs, tsize_rtx));\n@@ -2073,14 +2073,14 @@ iq2000_expand_epilogue (void)\n \n       emit_insn (gen_blockage ());\n \n-      if (tsize != 0 || current_function_calls_eh_return)\n+      if (tsize != 0 || crtl->calls_eh_return)\n \t{\n \t  emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n \t\t\t\t tsize_rtx));\n \t}\n     }\n \n-  if (current_function_calls_eh_return)\n+  if (crtl->calls_eh_return)\n     {\n       /* Perform the additional bump for __throw.  */\n       emit_move_insn (gen_rtx_REG (Pmode, HARD_FRAME_POINTER_REGNUM),"}, {"sha": "64b7e5f63ab4c0e771106f762f38ebe3a6193220", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -1253,7 +1253,7 @@ static struct m32r_frame_info zero_frame_info;\n    && (df_regs_ever_live_p (regno) && (!call_really_used_regs[regno] || interrupt_p)))\n \n #define MUST_SAVE_FRAME_POINTER (df_regs_ever_live_p (FRAME_POINTER_REGNUM))\n-#define MUST_SAVE_RETURN_ADDR   (df_regs_ever_live_p (RETURN_ADDR_REGNUM) || current_function_profile)\n+#define MUST_SAVE_RETURN_ADDR   (df_regs_ever_live_p (RETURN_ADDR_REGNUM) || crtl->profile)\n \n #define SHORT_INSN_SIZE 2\t/* Size of small instructions.  */\n #define LONG_INSN_SIZE 4\t/* Size of long instructions.  */\n@@ -1272,8 +1272,8 @@ m32r_compute_frame_size (int size)\t/* # of var. bytes allocated.  */\n   unsigned int gmask;\n   enum m32r_function_type fn_type;\n   int interrupt_p;\n-  int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n-                                  | current_function_profile);\n+  int pic_reg_used = flag_pic && (crtl->uses_pic_offset_table\n+                                  | crtl->profile);\n \n   var_size\t= M32R_STACK_ALIGN (size);\n   args_size\t= M32R_STACK_ALIGN (crtl->outgoing_args_size);\n@@ -1372,8 +1372,8 @@ m32r_expand_prologue (void)\n   int regno;\n   int frame_size;\n   unsigned int gmask;\n-  int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n-                                  | current_function_profile);\n+  int pic_reg_used = flag_pic && (crtl->uses_pic_offset_table\n+                                  | crtl->profile);\n \n   if (! current_frame_info.initialized)\n     m32r_compute_frame_size (get_frame_size ());\n@@ -1434,7 +1434,7 @@ m32r_expand_prologue (void)\n   if (frame_pointer_needed)\n     emit_insn (gen_movsi (frame_pointer_rtx, stack_pointer_rtx));\n \n-  if (current_function_profile)\n+  if (crtl->profile)\n     /* Push lr for mcount (form_pc, x).  */\n     emit_insn (gen_movsi_push (stack_pointer_rtx,\n                                gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM)));\n@@ -1443,10 +1443,10 @@ m32r_expand_prologue (void)\n     {\n       m32r_load_pic_register ();\n       m32r_reload_lr (stack_pointer_rtx,\n-                      (current_function_profile ? 0 : frame_size));\n+                      (crtl->profile ? 0 : frame_size));\n     }\n \n-  if (current_function_profile && !pic_reg_used)\n+  if (crtl->profile && !pic_reg_used)\n     emit_insn (gen_blockage ());\n }\n \n@@ -1519,7 +1519,7 @@ m32r_expand_epilogue (void)\n       unsigned int var_size = current_frame_info.var_size;\n       unsigned int args_size = current_frame_info.args_size;\n       unsigned int gmask = current_frame_info.gmask;\n-      int can_trust_sp_p = !current_function_calls_alloca;\n+      int can_trust_sp_p = !cfun->calls_alloca;\n \n       if (flag_exceptions)\n         emit_insn (gen_blockage ());\n@@ -1664,7 +1664,7 @@ m32r_legitimize_pic_address (rtx orig, rtx reg)\n       else\n         address = reg;\n \n-      current_function_uses_pic_offset_table = 1;\n+      crtl->uses_pic_offset_table = 1;\n \n       if (GET_CODE (orig) == LABEL_REF\n           || (GET_CODE (orig) == SYMBOL_REF && SYMBOL_REF_LOCAL_P (orig)))"}, {"sha": "0c9e31853edb567ea59cff403b5c4c3a9ac96143", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -768,7 +768,7 @@ extern enum reg_class m32r_regno_reg_class[FIRST_PSEUDO_REGISTER];\n /* A C expression which is nonzero if a function must have and use a\n    frame pointer.  This expression is evaluated in the reload pass.\n    If its value is nonzero the function will have a frame pointer.  */\n-#define FRAME_POINTER_REQUIRED current_function_calls_alloca\n+#define FRAME_POINTER_REQUIRED cfun->calls_alloca\n \n #if 0\n /* C statement to store the difference between the frame pointer"}, {"sha": "b33f624eddef8c674ff170450852236eebd4570c", "filename": "gcc/config/m32r/m32r.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fm32r%2Fm32r.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fm32r%2Fm32r.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.md?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -2354,7 +2354,7 @@\n   \"\n {\n   if (flag_pic)\n-    current_function_uses_pic_offset_table = 1;\n+    crtl->uses_pic_offset_table = 1;\n }\")\n \n (define_insn \"*call_via_reg\"\n@@ -2409,7 +2409,7 @@\n   \"\n {\n   if (flag_pic)\n-    current_function_uses_pic_offset_table = 1;\n+    crtl->uses_pic_offset_table = 1;\n }\")\n \n (define_insn \"*call_value_via_reg\"\n@@ -2433,7 +2433,7 @@\n   int call26_p = call26_operand (operands[1], FUNCTION_MODE);\n \n   if (flag_pic)\n-    current_function_uses_pic_offset_table = 1;\n+    crtl->uses_pic_offset_table = 1;\n \n   if (! call26_p)\n     {"}, {"sha": "3fdd756ada9180eefa6f4811c382f1fadefda841", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -863,20 +863,20 @@ m68k_save_reg (unsigned int regno, bool interrupt_handler)\n {\n   if (flag_pic && regno == PIC_REG)\n     {\n-      if (current_function_saves_all_registers)\n+      if (crtl->saves_all_registers)\n \treturn true;\n-      if (current_function_uses_pic_offset_table)\n+      if (crtl->uses_pic_offset_table)\n \treturn true;\n       /* Reload may introduce constant pool references into a function\n \t that thitherto didn't need a PIC register.  Note that the test\n \t above will not catch that case because we will only set\n-\t current_function_uses_pic_offset_table when emitting\n+\t crtl->uses_pic_offset_table when emitting\n \t the address reloads.  */\n-      if (current_function_uses_const_pool)\n+      if (crtl->uses_const_pool)\n \treturn true;\n     }\n \n-  if (current_function_calls_eh_return)\n+  if (crtl->calls_eh_return)\n     {\n       unsigned int i;\n       for (i = 0; ; i++)\n@@ -986,7 +986,7 @@ m68k_expand_prologue (void)\n \n   /* If the stack limit is a symbol, we can check it here,\n      before actually allocating the space.  */\n-  if (current_function_limit_stack\n+  if (crtl->limit_stack\n       && GET_CODE (stack_limit_rtx) == SYMBOL_REF)\n     {\n       limit = plus_constant (stack_limit_rtx, current_frame.size + 4);\n@@ -1073,7 +1073,7 @@ m68k_expand_prologue (void)\n \n   /* If the stack limit is not a symbol, check it here.\n      This has the disadvantage that it may be too late...  */\n-  if (current_function_limit_stack)\n+  if (crtl->limit_stack)\n     {\n       if (REG_P (stack_limit_rtx))\n \t{\n@@ -1119,7 +1119,7 @@ m68k_expand_prologue (void)\n \n   if (flag_pic\n       && !TARGET_SEP_DATA\n-      && current_function_uses_pic_offset_table)\n+      && crtl->uses_pic_offset_table)\n     insn = emit_insn (gen_load_got (pic_offset_table_rtx));\n }\n \f\n@@ -1160,7 +1160,7 @@ m68k_expand_epilogue (bool sibcall_p)\n      What we really need to know there is if there could be pending\n      stack adjustment needed at that point.  */\n   restore_from_sp = (!frame_pointer_needed\n-\t\t     || (!current_function_calls_alloca\n+\t\t     || (!cfun->calls_alloca\n \t\t\t && current_function_is_leaf));\n \n   /* fsize_with_regs is the size we need to adjust the sp when\n@@ -1298,7 +1298,7 @@ m68k_expand_epilogue (bool sibcall_p)\n \t\t\t   stack_pointer_rtx,\n \t\t\t   GEN_INT (fsize_with_regs)));\n \n-  if (current_function_calls_eh_return)\n+  if (crtl->calls_eh_return)\n     emit_insn (gen_addsi3 (stack_pointer_rtx,\n \t\t\t   stack_pointer_rtx,\n \t\t\t   EH_RETURN_STACKADJ_RTX));\n@@ -2046,7 +2046,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n       pic_ref = gen_rtx_MEM (Pmode,\n \t\t\t     gen_rtx_PLUS (Pmode,\n \t\t\t\t\t   pic_offset_table_rtx, orig));\n-      current_function_uses_pic_offset_table = 1;\n+      crtl->uses_pic_offset_table = 1;\n       MEM_READONLY_P (pic_ref) = 1;\n       emit_move_insn (reg, pic_ref);\n       return reg;"}, {"sha": "940c833dc3e7405f3563a85bea751797ef4915eb", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -1938,7 +1938,7 @@ mcore_expand_prolog (void)\n       \n       ASM_OUTPUT_CG_NODE (asm_out_file, mcore_current_function_name, space_allocated);\n \n-      if (current_function_calls_alloca)\n+      if (cfun->calls_alloca)\n \tASM_OUTPUT_CG_EDGE (asm_out_file, mcore_current_function_name, \"alloca\", 1);\n \n       /* 970425: RBE:"}, {"sha": "94a1427453317c9d961cd956b5b6b6d7e0aac596", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -7656,12 +7656,12 @@ mips_global_pointer (void)\n \n   /* FUNCTION_PROFILER includes a jal macro, so we need to give it\n      a valid gp.  */\n-  if (current_function_profile)\n+  if (crtl->profile)\n     return GLOBAL_POINTER_REGNUM;\n \n   /* If the function has a nonlocal goto, $gp must hold the correct\n      global pointer for the target function.  */\n-  if (current_function_has_nonlocal_goto)\n+  if (crtl->has_nonlocal_goto)\n     return GLOBAL_POINTER_REGNUM;\n \n   /* If the gp is never referenced, there's no need to initialize it.\n@@ -7678,7 +7678,7 @@ mips_global_pointer (void)\n      In cases like these, reload will have added the constant to the pool\n      but no instruction will yet refer to it.  */\n   if (!df_regs_ever_live_p (GLOBAL_POINTER_REGNUM)\n-      && !current_function_uses_const_pool\n+      && !crtl->uses_const_pool\n       && !mips_function_has_gp_insn ())\n     return 0;\n \n@@ -7719,7 +7719,7 @@ mips_save_reg_p (unsigned int regno)\n     return TARGET_CALL_SAVED_GP && cfun->machine->global_pointer == regno;\n \n   /* Check call-saved registers.  */\n-  if ((current_function_saves_all_registers || df_regs_ever_live_p (regno))\n+  if ((crtl->saves_all_registers || df_regs_ever_live_p (regno))\n       && !call_really_used_regs[regno])\n     return true;\n \n@@ -7737,7 +7737,7 @@ mips_save_reg_p (unsigned int regno)\n     return true;\n \n   /* Check for registers that must be saved for FUNCTION_PROFILER.  */\n-  if (current_function_profile && MIPS_SAVE_REG_FOR_PROFILING_P (regno))\n+  if (crtl->profile && MIPS_SAVE_REG_FOR_PROFILING_P (regno))\n     return true;\n \n   /* We need to save the incoming return address if it is ever clobbered\n@@ -7746,7 +7746,7 @@ mips_save_reg_p (unsigned int regno)\n      value in FPRs.  */\n   if (regno == GP_REG_FIRST + 31\n       && (df_regs_ever_live_p (regno)\n-\t  || current_function_calls_eh_return\n+\t  || crtl->calls_eh_return\n \t  || mips16_cfun_returns_in_fpr_p ()))\n     return true;\n \n@@ -7837,7 +7837,7 @@ mips_compute_frame_info (void)\n \t allocate the stack and have 0 for STACK_DYNAMIC_OFFSET, since it\n \t looks like we are trying to create a second frame pointer to the\n \t function, so allocate some stack space to make it happy.  */\n-      if (current_function_calls_alloca)\n+      if (cfun->calls_alloca)\n \tframe->args_size = REG_PARM_STACK_SPACE (cfun->decl);\n       else\n \tframe->args_size = 0;\n@@ -7864,7 +7864,7 @@ mips_compute_frame_info (void)\n \n   /* If this function calls eh_return, we must also save and restore the\n      EH data registers.  */\n-  if (current_function_calls_eh_return)\n+  if (crtl->calls_eh_return)\n     for (i = 0; EH_RETURN_DATA_REGNO (i) != INVALID_REGNUM; i++)\n       {\n \tframe->num_gp++;\n@@ -7952,7 +7952,7 @@ mips_frame_pointer_required (void)\n {\n   /* If the function contains dynamic stack allocations, we need to\n      use the frame pointer to access the static parts of the frame.  */\n-  if (current_function_calls_alloca)\n+  if (cfun->calls_alloca)\n     return true;\n \n   /* In MIPS16 mode, we need a frame pointer for a large frame; otherwise,\n@@ -8489,7 +8489,7 @@ mips_expand_prologue (void)\n \n   /* If we are profiling, make sure no instructions are scheduled before\n      the call to mcount.  */\n-  if (current_function_profile)\n+  if (crtl->profile)\n     emit_insn (gen_blockage ());\n }\n \f\n@@ -8627,7 +8627,7 @@ mips_expand_epilogue (bool sibcall_p)\n \n   /* Add in the __builtin_eh_return stack adjustment.  We need to\n      use a temporary in MIPS16 code.  */\n-  if (current_function_calls_eh_return)\n+  if (crtl->calls_eh_return)\n     {\n       if (TARGET_MIPS16)\n \t{\n@@ -8669,7 +8669,7 @@ mips_can_use_return_insn (void)\n   if (!reload_completed)\n     return false;\n \n-  if (current_function_profile)\n+  if (crtl->profile)\n     return false;\n \n   /* In MIPS16 mode, a function that returns a floating-point value\n@@ -11475,7 +11475,7 @@ mips_reorg_process_insns (void)\n \n   /* Profiled functions can't be all noreorder because the profiler\n      support uses assembler macros.  */\n-  if (current_function_profile)\n+  if (crtl->profile)\n     cfun->machine->all_noreorder_p = false;\n \n   /* Code compiled with -mfix-vr4120 can't be all noreorder because"}, {"sha": "2807d08d956b9f7bfe8dae9bb306c7ecee48648e", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -69,7 +69,7 @@ along with GCC; see the file COPYING3.  If not see\n       || !leaf_function_p ()))\n \n #define IS_MMIX_EH_RETURN_DATA_REG(REGNO)\t\\\n- (current_function_calls_eh_return\t\t\\\n+ (crtl->calls_eh_return\t\t\\\n   && (EH_RETURN_DATA_REGNO (0) == REGNO\t\t\\\n       || EH_RETURN_DATA_REGNO (1) == REGNO\t\\\n       || EH_RETURN_DATA_REGNO (2) == REGNO\t\\\n@@ -96,7 +96,7 @@ along with GCC; see the file COPYING3.  If not see\n #define MMIX_POP_ARGUMENT()\t\t\t\t\t\t\\\n  ((! TARGET_ABI_GNU\t\t\t\t\t\t\t\\\n    && crtl->return_rtx != NULL\t\t\t\t\\\n-   && ! current_function_returns_struct)\t\t\t\t\\\n+   && ! cfun->returns_struct)\t\t\t\t\\\n   ? (GET_CODE (crtl->return_rtx) == PARALLEL\t\t\t\\\n      ? GET_NUM_ELEM (XVEC (crtl->return_rtx, 0)) : 1)\t\\\n   : 0)\n@@ -2207,7 +2207,7 @@ mmix_expand_epilogue (void)\n   if (stack_space_to_deallocate != 0)\n     mmix_emit_sp_add (stack_space_to_deallocate);\n \n-  if (current_function_calls_eh_return)\n+  if (crtl->calls_eh_return)\n     /* Adjust the (normal) stack-pointer to that of the receiver.\n        FIXME: It would be nice if we could also adjust the register stack\n        here, but we need to express it through DWARF 2 too.  */"}, {"sha": "7e38eab1941ff2d0207a06a52cead2d252ea144b", "filename": "gcc/config/mmix/mmix.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fmmix%2Fmmix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fmmix%2Fmmix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.h?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -591,7 +591,7 @@ enum reg_class\n /* Node: Elimination */\n /* FIXME: Is this requirement built-in?  Anyway, we should try to get rid\n    of it; we can deduce the value.  */\n-#define FRAME_POINTER_REQUIRED  current_function_has_nonlocal_label\n+#define FRAME_POINTER_REQUIRED  cfun->has_nonlocal_label\n \n /* The frame-pointer is stored in a location that either counts to the\n    offset of incoming parameters, or that counts to the offset of the"}, {"sha": "ea7392bb0f936832deb535f5305f8794396d87d4", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -1599,7 +1599,7 @@ mn10300_function_value (const_tree valtype, const_tree func, int outgoing)\n   if (! POINTER_TYPE_P (valtype))\n     return gen_rtx_REG (mode, FIRST_DATA_REGNUM);\n   else if (! TARGET_PTR_A0D0 || ! outgoing\n-\t   || current_function_returns_struct)\n+\t   || cfun->returns_struct)\n     return gen_rtx_REG (mode, FIRST_ADDRESS_REGNUM);\n \n   rv = gen_rtx_PARALLEL (mode, rtvec_alloc (2));"}, {"sha": "de20d40eb5a9bd3b521e879297206c01166572b0", "filename": "gcc/config/mt/mt.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fmt%2Fmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fmt%2Fmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmt%2Fmt.h?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -422,7 +422,7 @@ enum save_direction\n \t  handlers.  */\t\t\t\t\t\t\\\n \t|| (interrupt_handler && call_used_regs[regno] \t\t\\\n \t   && !current_function_is_leaf)\t\t\t\\\n-\t||(current_function_calls_eh_return\t\t\t\\\n+\t||(crtl->calls_eh_return\t\t\t\\\n \t   && (regno == GPR_R7 || regno == GPR_R8))\t\t\\\n \t)\t\t\t\t\t\t\t\\\n   )"}, {"sha": "525572eb7c07e48beb590a3ecdea907e6dbb761b", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -698,7 +698,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \t\t\t\t\t\tREG_NOTES (insn));\n \t  LABEL_NUSES (orig)++;\n \t}\n-      current_function_uses_pic_offset_table = 1;\n+      crtl->uses_pic_offset_table = 1;\n       return reg;\n     }\n   if (GET_CODE (orig) == SYMBOL_REF)\n@@ -745,7 +745,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \t\t\t\t\t\t         UNSPEC_DLTIND14R)));\n \t}\n \n-      current_function_uses_pic_offset_table = 1;\n+      crtl->uses_pic_offset_table = 1;\n       mark_reg_pointer (reg, BITS_PER_UNIT);\n       insn = emit_move_insn (reg, pic_ref);\n \n@@ -3531,7 +3531,7 @@ compute_frame_size (HOST_WIDE_INT size, int *fregs_live)\n   /* If the current function calls __builtin_eh_return, then we need\n      to allocate stack space for registers that will hold data for\n      the exception handler.  */\n-  if (DO_FRAME_NOTES && current_function_calls_eh_return)\n+  if (DO_FRAME_NOTES && crtl->calls_eh_return)\n     {\n       unsigned int i;\n \n@@ -3679,7 +3679,7 @@ hppa_expand_prologue (void)\n   /* Save RP first.  The calling conventions manual states RP will\n      always be stored into the caller's frame at sp - 20 or sp - 16\n      depending on which ABI is in use.  */\n-  if (df_regs_ever_live_p (2) || current_function_calls_eh_return)\n+  if (df_regs_ever_live_p (2) || crtl->calls_eh_return)\n     {\n       store_reg (2, TARGET_64BIT ? -16 : -20, STACK_POINTER_REGNUM);\n       rp_saved = true;\n@@ -3779,7 +3779,7 @@ hppa_expand_prologue (void)\n       /* Saving the EH return data registers in the frame is the simplest\n \t way to get the frame unwind information emitted.  We put them\n \t just before the general registers.  */\n-      if (DO_FRAME_NOTES && current_function_calls_eh_return)\n+      if (DO_FRAME_NOTES && crtl->calls_eh_return)\n \t{\n \t  unsigned int i, regno;\n \n@@ -3811,7 +3811,7 @@ hppa_expand_prologue (void)\n \n       /* Saving the EH return data registers in the frame is the simplest\n          way to get the frame unwind information emitted.  */\n-      if (DO_FRAME_NOTES && current_function_calls_eh_return)\n+      if (DO_FRAME_NOTES && crtl->calls_eh_return)\n \t{\n \t  unsigned int i, regno;\n \n@@ -4113,7 +4113,7 @@ hppa_expand_epilogue (void)\n \n       /* If the current function calls __builtin_eh_return, then we need\n          to restore the saved EH data registers.  */\n-      if (DO_FRAME_NOTES && current_function_calls_eh_return)\n+      if (DO_FRAME_NOTES && crtl->calls_eh_return)\n \t{\n \t  unsigned int i, regno;\n \n@@ -4141,7 +4141,7 @@ hppa_expand_epilogue (void)\n \n       /* If the current function calls __builtin_eh_return, then we need\n          to restore the saved EH data registers.  */\n-      if (DO_FRAME_NOTES && current_function_calls_eh_return)\n+      if (DO_FRAME_NOTES && crtl->calls_eh_return)\n \t{\n \t  unsigned int i, regno;\n \n@@ -4238,7 +4238,7 @@ hppa_expand_epilogue (void)\n   if (ret_off != 0)\n     load_reg (2, ret_off, STACK_POINTER_REGNUM);\n \n-  if (DO_FRAME_NOTES && current_function_calls_eh_return)\n+  if (DO_FRAME_NOTES && crtl->calls_eh_return)\n     {\n       rtx sa = EH_RETURN_STACKADJ_RTX;\n \n@@ -8496,7 +8496,7 @@ borx_reg_operand (rtx op, enum machine_mode mode)\n      profitable to do so when the frame pointer is being eliminated.  */\n   if (!reload_completed\n       && flag_omit_frame_pointer\n-      && !current_function_calls_alloca\n+      && !cfun->calls_alloca\n       && op == frame_pointer_rtx)\n     return 0;\n "}, {"sha": "541f2e3069fcb8fd5a65ed4a1d355f606493bf1c", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -366,13 +366,13 @@ typedef struct machine_function GTY(())\n \n /* Value should be nonzero if functions must have frame pointers.  */\n #define FRAME_POINTER_REQUIRED \\\n-  (current_function_calls_alloca)\n+  (cfun->calls_alloca)\n \n /* Don't allow hard registers to be renamed into r2 unless r2\n    is already live or already being saved (due to eh).  */\n \n #define HARD_REGNO_RENAME_OK(OLD_REG, NEW_REG) \\\n-  ((NEW_REG) != 2 || df_regs_ever_live_p (2) || current_function_calls_eh_return)\n+  ((NEW_REG) != 2 || df_regs_ever_live_p (2) || crtl->calls_eh_return)\n \n /* C statement to store the difference between the frame pointer\n    and the stack pointer values immediately after the function prologue.\n@@ -791,7 +791,7 @@ extern int may_call_alloca;\n \n #define EXIT_IGNORE_STACK\t\\\n  (get_frame_size () != 0\t\\\n-  || current_function_calls_alloca || crtl->outgoing_args_size)\n+  || cfun->calls_alloca || crtl->outgoing_args_size)\n \n /* Output assembler code for a block containing the constant parts\n    of a trampoline, leaving space for the variable parts.\\"}, {"sha": "5f1d73893fda6f87c558cb36219edcd88bacddd7", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -7275,7 +7275,7 @@\n    (use (reg:SI 2))]\n   \"!TARGET_NO_SPACE_REGS\n    && !TARGET_PA_20\n-   && flag_pic && current_function_calls_eh_return\"\n+   && flag_pic && crtl->calls_eh_return\"\n   \"ldsid (%%sr0,%%r2),%%r1\\;mtsp %%r1,%%sr0\\;be%* 0(%%sr0,%%r2)\"\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"12\")])\n@@ -7317,7 +7317,7 @@\n \t using space registers.  */\n       if (!TARGET_NO_SPACE_REGS\n \t  && !TARGET_PA_20\n-\t  && flag_pic && current_function_calls_eh_return)\n+\t  && flag_pic && crtl->calls_eh_return)\n \tx = gen_return_external_pic ();\n       else\n \tx = gen_return_internal ();"}, {"sha": "ec9f83173d43934b7d354dc53c7307318a04f59a", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -11465,7 +11465,7 @@ rs6000_got_register (rtx value ATTRIBUTE_UNUSED)\n       && !df_regs_ever_live_p (RS6000_PIC_OFFSET_TABLE_REGNUM))\n     df_set_regs_ever_live (RS6000_PIC_OFFSET_TABLE_REGNUM, true);\n \n-  current_function_uses_pic_offset_table = 1;\n+  crtl->uses_pic_offset_table = 1;\n \n   return pic_offset_table_rtx;\n }\n@@ -14144,7 +14144,7 @@ first_reg_to_save (void)\n \n #if TARGET_MACHO\n   if (flag_pic\n-      && current_function_uses_pic_offset_table\n+      && crtl->uses_pic_offset_table\n       && first_reg > RS6000_PIC_OFFSET_TABLE_REGNUM)\n     return RS6000_PIC_OFFSET_TABLE_REGNUM;\n #endif\n@@ -14181,7 +14181,7 @@ first_altivec_reg_to_save (void)\n   /* On Darwin, the unwind routines are compiled without\n      TARGET_ALTIVEC, and use save_world to save/restore the\n      altivec registers when necessary.  */\n-  if (DEFAULT_ABI == ABI_DARWIN && current_function_calls_eh_return\n+  if (DEFAULT_ABI == ABI_DARWIN && crtl->calls_eh_return\n       && ! TARGET_ALTIVEC)\n     return FIRST_ALTIVEC_REGNO + 20;\n \n@@ -14205,7 +14205,7 @@ compute_vrsave_mask (void)\n   /* On Darwin, the unwind routines are compiled without\n      TARGET_ALTIVEC, and use save_world to save/restore the\n      call-saved altivec registers when necessary.  */\n-  if (DEFAULT_ABI == ABI_DARWIN && current_function_calls_eh_return\n+  if (DEFAULT_ABI == ABI_DARWIN && crtl->calls_eh_return\n       && ! TARGET_ALTIVEC)\n     mask |= 0xFFF;\n \n@@ -14247,7 +14247,7 @@ compute_save_world_info (rs6000_stack_t *info_ptr)\n   info_ptr->world_save_p\n     = (WORLD_SAVE_P (info_ptr)\n        && DEFAULT_ABI == ABI_DARWIN\n-       && ! (current_function_calls_setjmp && flag_exceptions)\n+       && ! (cfun->calls_setjmp && flag_exceptions)\n        && info_ptr->first_fp_reg_save == FIRST_SAVED_FP_REGNO\n        && info_ptr->first_gp_reg_save == FIRST_SAVED_GP_REGNO\n        && info_ptr->first_altivec_reg_save == FIRST_SAVED_ALTIVEC_REGNO\n@@ -14432,7 +14432,7 @@ rs6000_stack_info (void)\n   if (((TARGET_TOC && TARGET_MINIMAL_TOC)\n        || (flag_pic == 1 && DEFAULT_ABI == ABI_V4)\n        || (flag_pic && DEFAULT_ABI == ABI_DARWIN))\n-      && current_function_uses_const_pool\n+      && crtl->uses_const_pool\n       && info_ptr->first_gp_reg_save > RS6000_PIC_OFFSET_TABLE_REGNUM)\n     first_gp = RS6000_PIC_OFFSET_TABLE_REGNUM;\n   else\n@@ -14468,14 +14468,14 @@ rs6000_stack_info (void)\n \n   /* Determine if we need to save the link register.  */\n   if ((DEFAULT_ABI == ABI_AIX\n-       && current_function_profile\n+       && crtl->profile\n        && !TARGET_PROFILE_KERNEL)\n #ifdef TARGET_RELOCATABLE\n       || (TARGET_RELOCATABLE && (get_pool_size () != 0))\n #endif\n       || (info_ptr->first_fp_reg_save != 64\n \t  && !FP_SAVE_INLINE (info_ptr->first_fp_reg_save))\n-      || (DEFAULT_ABI == ABI_V4 && current_function_calls_alloca)\n+      || (DEFAULT_ABI == ABI_V4 && cfun->calls_alloca)\n       || info_ptr->calls_p\n       || rs6000_ra_ever_killed ())\n     {\n@@ -14496,7 +14496,7 @@ rs6000_stack_info (void)\n   /* If the current function calls __builtin_eh_return, then we need\n      to allocate stack space for registers that will hold data for\n      the exception handler.  */\n-  if (current_function_calls_eh_return)\n+  if (crtl->calls_eh_return)\n     {\n       unsigned int i;\n       for (i = 0; EH_RETURN_DATA_REGNO (i) != INVALID_REGNUM; ++i)\n@@ -14715,9 +14715,9 @@ spe_func_has_64bit_regs_p (void)\n \n   /* Functions that save and restore all the call-saved registers will\n      need to save/restore the registers in 64-bits.  */\n-  if (current_function_calls_eh_return\n-      || current_function_calls_setjmp\n-      || current_function_has_nonlocal_goto)\n+  if (crtl->calls_eh_return\n+      || cfun->calls_setjmp\n+      || crtl->has_nonlocal_goto)\n     return true;\n \n   insns = get_insns ();\n@@ -14969,7 +14969,7 @@ rs6000_ra_ever_killed (void)\n   rtx reg;\n   rtx insn;\n \n-  if (current_function_is_thunk)\n+  if (crtl->is_thunk)\n     return 0;\n \n   /* regs_ever_live has LR marked as used if any sibcalls are present,\n@@ -15125,7 +15125,7 @@ rs6000_emit_eh_reg_restore (rtx source, rtx scratch)\n       rtx tmp;\n \n       if (frame_pointer_needed\n-\t  || current_function_calls_alloca\n+\t  || cfun->calls_alloca\n \t  || info->total_size > 32767)\n \t{\n \t  tmp = gen_frame_mem (Pmode, frame_rtx);\n@@ -15264,7 +15264,7 @@ rs6000_emit_allocate_stack (HOST_WIDE_INT size, int copy_r12)\n       return;\n     }\n \n-  if (current_function_limit_stack)\n+  if (crtl->limit_stack)\n     {\n       if (REG_P (stack_limit_rtx)\n \t  && REGNO (stack_limit_rtx) > 1\n@@ -15620,14 +15620,14 @@ rs6000_emit_prologue (void)\n \t\t\t  && no_global_regs_above (info->first_gp_reg_save));\n   saving_FPRs_inline = (info->first_fp_reg_save == 64\n \t\t\t|| FP_SAVE_INLINE (info->first_fp_reg_save)\n-\t\t\t|| current_function_calls_eh_return\n+\t\t\t|| crtl->calls_eh_return\n \t\t\t|| cfun->machine->ra_need_lr);\n \n   /* For V.4, update stack before we do any saving and set back pointer.  */\n   if (! WORLD_SAVE_P (info)\n       && info->push_p\n       && (DEFAULT_ABI == ABI_V4\n-\t  || current_function_calls_eh_return))\n+\t  || crtl->calls_eh_return))\n     {\n       if (info->total_size < 32767)\n \tsp_offset = info->total_size;\n@@ -15670,7 +15670,7 @@ rs6000_emit_prologue (void)\n \t\t  && info->cr_save_offset == 4\n \t\t  && info->push_p\n \t\t  && info->lr_save_p\n-\t\t  && (!current_function_calls_eh_return\n+\t\t  && (!crtl->calls_eh_return\n \t\t       || info->ehrd_offset == -432)\n \t\t  && info->vrsave_save_offset == -224\n \t\t  && info->altivec_save_offset == -416);\n@@ -15967,7 +15967,7 @@ rs6000_emit_prologue (void)\n \n   /* ??? There's no need to emit actual instructions here, but it's the\n      easiest way to get the frame unwind information emitted.  */\n-  if (current_function_calls_eh_return)\n+  if (crtl->calls_eh_return)\n     {\n       unsigned int i, regno;\n \n@@ -16033,7 +16033,7 @@ rs6000_emit_prologue (void)\n   /* Update stack and set back pointer unless this is V.4,\n      for which it was done previously.  */\n   if (!WORLD_SAVE_P (info) && info->push_p\n-      && !(DEFAULT_ABI == ABI_V4 || current_function_calls_eh_return))\n+      && !(DEFAULT_ABI == ABI_V4 || crtl->calls_eh_return))\n     {\n       if (info->total_size < 32767)\n       sp_offset = info->total_size;\n@@ -16161,7 +16161,7 @@ rs6000_emit_prologue (void)\n \n #if TARGET_MACHO\n   if (DEFAULT_ABI == ABI_DARWIN\n-      && flag_pic && current_function_uses_pic_offset_table)\n+      && flag_pic && crtl->uses_pic_offset_table)\n     {\n       rtx lr = gen_rtx_REG (Pmode, LR_REGNO);\n       rtx src = machopic_function_base_sym ();\n@@ -16280,11 +16280,11 @@ rs6000_emit_epilogue (int sibcall)\n \t\t\t && info->first_gp_reg_save < 31\n \t\t\t && no_global_regs_above (info->first_gp_reg_save));\n   restoring_FPRs_inline = (sibcall\n-\t\t\t   || current_function_calls_eh_return\n+\t\t\t   || crtl->calls_eh_return\n \t\t\t   || info->first_fp_reg_save == 64\n \t\t\t   || FP_SAVE_INLINE (info->first_fp_reg_save));\n   use_backchain_to_restore_sp = (frame_pointer_needed\n-\t\t\t\t || current_function_calls_alloca\n+\t\t\t\t || cfun->calls_alloca\n \t\t\t\t || info->total_size > 32767);\n   using_mtcr_multiple = (rs6000_cpu == PROCESSOR_PPC601\n \t\t\t || rs6000_cpu == PROCESSOR_PPC603\n@@ -16311,7 +16311,7 @@ rs6000_emit_epilogue (int sibcall)\n \t\t       + LAST_ALTIVEC_REGNO + 1 - info->first_altivec_reg_save\n \t\t       + 63 + 1 - info->first_fp_reg_save);\n \n-      strcpy (rname, ((current_function_calls_eh_return) ?\n+      strcpy (rname, ((crtl->calls_eh_return) ?\n \t\t      \"*eh_rest_world_r10\" : \"*rest_world\"));\n       alloc_rname = ggc_strdup (rname);\n \n@@ -16473,7 +16473,7 @@ rs6000_emit_epilogue (int sibcall)\n     }\n   else if (info->push_p\n \t   && DEFAULT_ABI != ABI_V4\n-\t   && !current_function_calls_eh_return)\n+\t   && !crtl->calls_eh_return)\n     {\n       emit_insn (TARGET_32BIT\n \t\t ? gen_addsi3 (sp_reg_rtx, sp_reg_rtx,\n@@ -16553,7 +16553,7 @@ rs6000_emit_epilogue (int sibcall)\n \t\t    gen_rtx_REG (Pmode, 0));\n \n   /* Load exception handler data registers, if needed.  */\n-  if (current_function_calls_eh_return)\n+  if (crtl->calls_eh_return)\n     {\n       unsigned int i, regno;\n \n@@ -16750,7 +16750,7 @@ rs6000_emit_epilogue (int sibcall)\n \t       : gen_adddi3 (sp_reg_rtx, sp_reg_rtx,\n \t\t\t     GEN_INT (sp_offset)));\n \n-  if (current_function_calls_eh_return)\n+  if (crtl->calls_eh_return)\n     {\n       rtx sa = EH_RETURN_STACKADJ_RTX;\n       emit_insn (TARGET_32BIT\n@@ -16880,7 +16880,7 @@ rs6000_output_function_epilogue (FILE *file,\n      System V.4 Powerpc's (and the embedded ABI derived from it) use a\n      different traceback table.  */\n   if (DEFAULT_ABI == ABI_AIX && ! flag_inhibit_size_directive\n-      && rs6000_traceback != traceback_none && !current_function_is_thunk)\n+      && rs6000_traceback != traceback_none && !crtl->is_thunk)\n     {\n       const char *fname = NULL;\n       const char *language_string = lang_hooks.name;\n@@ -17864,13 +17864,13 @@ output_profile_hook (int labelno ATTRIBUTE_UNUSED)\n       int caller_addr_regno = LR_REGNO;\n \n       /* Be conservative and always set this, at least for now.  */\n-      current_function_uses_pic_offset_table = 1;\n+      crtl->uses_pic_offset_table = 1;\n \n #if TARGET_MACHO\n       /* For PIC code, set up a stub and collect the caller's address\n \t from r0, which is where the prologue puts it.  */\n       if (MACHOPIC_INDIRECT\n-\t  && current_function_uses_pic_offset_table)\n+\t  && crtl->uses_pic_offset_table)\n \tcaller_addr_regno = 0;\n #endif\n       emit_library_call (gen_rtx_SYMBOL_REF (Pmode, mcount_name),\n@@ -20646,7 +20646,7 @@ rs6000_elf_declare_function_name (FILE *file, const char *name, tree decl)\n \n   if (TARGET_RELOCATABLE\n       && !TARGET_SECURE_PLT\n-      && (get_pool_size () != 0 || current_function_profile)\n+      && (get_pool_size () != 0 || crtl->profile)\n       && uses_TOC ())\n     {\n       char buf[256];"}, {"sha": "1bde282172b4040f34f26693f9bcfa06457a0721", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -1552,7 +1552,7 @@ typedef struct rs6000_args\n #define\tEPILOGUE_USES(REGNO)\t\t\t\t\t\\\n   ((reload_completed && (REGNO) == LR_REGNO)\t\t\t\\\n    || (TARGET_ALTIVEC && (REGNO) == VRSAVE_REGNO)\t\t\\\n-   || (current_function_calls_eh_return\t\t\t\t\\\n+   || (crtl->calls_eh_return\t\t\t\t\\\n        && TARGET_AIX\t\t\t\t\t\t\\\n        && (REGNO) == 2))\n "}, {"sha": "8cd405e92751702dcc49b773aead8fbdae7f7758", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -10396,7 +10396,7 @@\n   emit_move_insn (chain, stack_bot);\n \n   /* Check stack bounds if necessary.  */\n-  if (current_function_limit_stack)\n+  if (crtl->limit_stack)\n     {\n       rtx available;\n       available = expand_binop (Pmode, sub_optab,"}, {"sha": "6dab692c2a6f3f762c60710acce551e02f54ac62", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -6438,9 +6438,9 @@ s390_regs_ever_clobbered (int *regs_ever_clobbered)\n      may use the eh registers, but the code which sets these registers is not\n      contained in that function.  Hence s390_regs_ever_clobbered is not able to\n      deal with this automatically.  */\n-  if (current_function_calls_eh_return || cfun->machine->has_landing_pad_p)\n+  if (crtl->calls_eh_return || cfun->machine->has_landing_pad_p)\n     for (i = 0; EH_RETURN_DATA_REGNO (i) != INVALID_REGNUM ; i++)\n-      if (current_function_calls_eh_return \n+      if (crtl->calls_eh_return \n \t  || (cfun->machine->has_landing_pad_p \n \t      && df_regs_ever_live_p (EH_RETURN_DATA_REGNO (i))))\n \tregs_ever_clobbered[EH_RETURN_DATA_REGNO (i)] = 1;\n@@ -6449,7 +6449,7 @@ s390_regs_ever_clobbered (int *regs_ever_clobbered)\n      This flag is also set for the unwinding code in libgcc.\n      See expand_builtin_unwind_init.  For regs_ever_live this is done by\n      reload.  */\n-  if (current_function_has_nonlocal_label)\n+  if (cfun->has_nonlocal_label)\n     for (i = 0; i < 16; i++)\n       if (!call_really_used_regs[i])\n \tregs_ever_clobbered[i] = 1;\n@@ -6554,16 +6554,16 @@ s390_register_info (int clobbered_regs[])\n \t|| TARGET_TPF_PROFILING\n \t|| cfun->machine->split_branches_pending_p\n \t|| cfun_frame_layout.save_return_addr_p\n-\t|| current_function_calls_eh_return\n-\t|| current_function_stdarg);\n+\t|| crtl->calls_eh_return\n+\t|| cfun->stdarg);\n \n   clobbered_regs[STACK_POINTER_REGNUM]\n     |= (!current_function_is_leaf\n \t|| TARGET_TPF_PROFILING\n \t|| cfun_save_high_fprs_p\n \t|| get_frame_size () > 0\n-\t|| current_function_calls_alloca\n-\t|| current_function_stdarg);\n+\t|| cfun->calls_alloca\n+\t|| cfun->stdarg);\n \n   for (i = 6; i < 16; i++)\n     if (df_regs_ever_live_p (i) || clobbered_regs[i])\n@@ -6616,7 +6616,7 @@ s390_register_info (int clobbered_regs[])\n \t}\n     }\n \n-  if (current_function_stdarg)\n+  if (cfun->stdarg)\n     {\n       /* Varargs functions need to save gprs 2 to 6.  */\n       if (cfun->va_list_gpr_size\n@@ -6738,8 +6738,8 @@ s390_frame_info (void)\n       && !TARGET_TPF_PROFILING\n       && cfun_frame_layout.frame_size == 0\n       && !cfun_save_high_fprs_p\n-      && !current_function_calls_alloca\n-      && !current_function_stdarg)\n+      && !cfun->calls_alloca\n+      && !cfun->stdarg)\n     return;\n \n   if (!TARGET_PACKED_STACK)\n@@ -6800,7 +6800,7 @@ s390_init_frame_layout (void)\n \n       /* Try to predict whether we'll need the base register.  */\n       base_used = cfun->machine->split_branches_pending_p\n-\t\t  || current_function_uses_const_pool\n+\t\t  || crtl->uses_const_pool\n \t\t  || (!DISP_IN_RANGE (frame_size)\n \t\t      && !CONST_OK_FOR_K (frame_size));\n \n@@ -6961,8 +6961,8 @@ s390_can_eliminate (int from, int to)\n \n   /* Make sure we actually saved the return address.  */\n   if (from == RETURN_ADDRESS_POINTER_REGNUM)\n-    if (!current_function_calls_eh_return\n-\t&& !current_function_stdarg\n+    if (!crtl->calls_eh_return\n+\t&& !cfun->stdarg\n \t&& !cfun_frame_layout.save_return_addr_p)\n       return false;\n \n@@ -7075,7 +7075,7 @@ save_gprs (rtx base, int offset, int first, int last)\n \t\t\t     gen_rtx_REG (Pmode, first),\n \t\t\t     GEN_INT (last - first + 1));\n \n-  if (first <= 6 && current_function_stdarg)\n+  if (first <= 6 && cfun->stdarg)\n     for (i = 0; i < XVECLEN (PATTERN (insn), 0); i++)\n       {\n \trtx mem = XEXP (XVECEXP (PATTERN (insn), 0, i), 0);"}, {"sha": "fe6e6f9b770f628edaed279d0dc3ce9a325738b1", "filename": "gcc/config/score/score.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fscore%2Fscore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fscore%2Fscore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.h?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -549,7 +549,7 @@ extern enum reg_class score_char_to_class[256];\n    Zero means the frame pointer need not be set up (and parms\n    may be accessed via the stack pointer) in functions that seem suitable.\n    This is computed in `reload', in reload1.c.  */\n-#define FRAME_POINTER_REQUIRED          current_function_calls_alloca\n+#define FRAME_POINTER_REQUIRED          cfun->calls_alloca\n \n #define ELIMINABLE_REGS                                \\\n   {{ ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},        \\"}, {"sha": "3114bcd1c55c82297c05177a94baf9bc5be6e2c6", "filename": "gcc/config/score/score3.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fscore%2Fscore3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fscore%2Fscore3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore3.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -189,7 +189,7 @@ score3_compute_frame_size (HOST_WIDE_INT size)\n   if (f->var_size == 0 && current_function_is_leaf)\n     f->args_size = f->cprestore_size = 0;\n \n-  if (f->args_size == 0 && current_function_calls_alloca)\n+  if (f->args_size == 0 && cfun->calls_alloca)\n     f->args_size = UNITS_PER_WORD;\n \n   f->total_size = f->var_size + f->args_size + f->cprestore_size;\n@@ -202,7 +202,7 @@ score3_compute_frame_size (HOST_WIDE_INT size)\n         }\n     }\n \n-  if (current_function_calls_eh_return)\n+  if (crtl->calls_eh_return)\n     {\n       unsigned int i;\n       for (i = 0;; ++i)\n@@ -1467,7 +1467,7 @@ rpush (int rd, int cnt)\n   rtx mem = gen_rtx_MEM (SImode, gen_rtx_PRE_DEC (SImode, stack_pointer_rtx));\n   rtx reg = gen_rtx_REG (SImode, rd);\n \n-  if (!current_function_calls_eh_return)\n+  if (!crtl->calls_eh_return)\n     MEM_READONLY_P (mem) = 1;\n \n   if (cnt == 1)\n@@ -1581,7 +1581,7 @@ rpop (int rd, int cnt)\n   rtx mem = gen_rtx_MEM (SImode, gen_rtx_POST_INC (SImode, stack_pointer_rtx));\n   rtx reg = gen_rtx_REG (SImode, rd);\n \n-  if (!current_function_calls_eh_return)\n+  if (!crtl->calls_eh_return)\n     MEM_READONLY_P (mem) = 1;\n \n   if (cnt == 1)\n@@ -1625,7 +1625,7 @@ score3_epilogue (int sibcall_p)\n   if (base != stack_pointer_rtx)\n     emit_move_insn (stack_pointer_rtx, base);\n \n-  if (current_function_calls_eh_return)\n+  if (crtl->calls_eh_return)\n     emit_insn (gen_add3_insn (stack_pointer_rtx,\n                               stack_pointer_rtx,\n                               EH_RETURN_STACKADJ_RTX));"}, {"sha": "74031c2c6ae878e34d803178c6b1b103ba956f0f", "filename": "gcc/config/score/score7.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fscore%2Fscore7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fscore%2Fscore7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore7.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -188,7 +188,7 @@ score7_compute_frame_size (HOST_WIDE_INT size)\n   if (f->var_size == 0 && current_function_is_leaf)\n     f->args_size = f->cprestore_size = 0;\n \n-  if (f->args_size == 0 && current_function_calls_alloca)\n+  if (f->args_size == 0 && cfun->calls_alloca)\n     f->args_size = UNITS_PER_WORD;\n \n   f->total_size = f->var_size + f->args_size + f->cprestore_size;\n@@ -201,7 +201,7 @@ score7_compute_frame_size (HOST_WIDE_INT size)\n         }\n     }\n \n-  if (current_function_calls_eh_return)\n+  if (crtl->calls_eh_return)\n     {\n       unsigned int i;\n       for (i = 0;; ++i)\n@@ -1428,7 +1428,7 @@ score7_prologue (void)\n           rtx mem = gen_rtx_MEM (SImode,\n                                  gen_rtx_PRE_DEC (SImode, stack_pointer_rtx));\n           rtx reg = gen_rtx_REG (SImode, regno);\n-          if (!current_function_calls_eh_return)\n+          if (!crtl->calls_eh_return)\n             MEM_READONLY_P (mem) = 1;\n           EMIT_PL (emit_insn (gen_pushsi_score7 (mem, reg)));\n         }\n@@ -1508,7 +1508,7 @@ score7_epilogue (int sibcall_p)\n   if (base != stack_pointer_rtx)\n     emit_move_insn (stack_pointer_rtx, base);\n \n-  if (current_function_calls_eh_return)\n+  if (crtl->calls_eh_return)\n     emit_insn (gen_add3_insn (stack_pointer_rtx,\n                               stack_pointer_rtx,\n                               EH_RETURN_STACKADJ_RTX));\n@@ -1521,7 +1521,7 @@ score7_epilogue (int sibcall_p)\n                                  gen_rtx_POST_INC (SImode, stack_pointer_rtx));\n           rtx reg = gen_rtx_REG (SImode, regno);\n \n-          if (!current_function_calls_eh_return)\n+          if (!crtl->calls_eh_return)\n             MEM_READONLY_P (mem) = 1;\n \n           emit_insn (gen_popsi_score7 (reg, mem));"}, {"sha": "cd1013dfdc6e2075ccce64303c9bdcf12c19a758", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -5646,7 +5646,7 @@ output_stack_adjust (int size, rtx reg, int epilogue_p,\n \t\t    }\n \t\t  for (i = 0; i < nreg; i++)\n \t\t    CLEAR_HARD_REG_BIT (temps, FIRST_RET_REG + i);\n-\t\t  if (current_function_calls_eh_return)\n+\t\t  if (crtl->calls_eh_return)\n \t\t    {\n \t\t      CLEAR_HARD_REG_BIT (temps, EH_RETURN_STACKADJ_REGNO);\n \t\t      for (i = 0; i <= 3; i++)\n@@ -5980,7 +5980,7 @@ calc_live_regs (HARD_REG_SET *live_regs_mask)\n   if (TARGET_SHCOMPACT\n       && ((crtl->args.info.call_cookie\n \t   & ~ CALL_COOKIE_RET_TRAMP (1))\n-\t  || current_function_saves_all_registers))\n+\t  || crtl->saves_all_registers))\n     pr_live = 1;\n   has_call = TARGET_SHMEDIA ? ! leaf_function_p () : pr_live;\n   for (count = 0, reg = FIRST_PSEUDO_REGISTER; reg-- != 0; )\n@@ -6010,7 +6010,7 @@ calc_live_regs (HARD_REG_SET *live_regs_mask)\n \t     || (df_regs_ever_live_p (reg)\n \t\t && (!call_really_used_regs[reg]\n \t\t     || (trapa_handler && reg == FPSCR_REG && TARGET_FPU_ANY)))\n-\t     || (current_function_calls_eh_return\n+\t     || (crtl->calls_eh_return\n \t\t && (reg == EH_RETURN_DATA_REGNO (0)\n \t\t     || reg == EH_RETURN_DATA_REGNO (1)\n \t\t     || reg == EH_RETURN_DATA_REGNO (2)\n@@ -6160,7 +6160,7 @@ sh5_schedule_saves (HARD_REG_SET *live_regs_mask, save_schedule *schedule,\n \t  && ! FUNCTION_ARG_REGNO_P (i)\n \t  && i != FIRST_RET_REG\n \t  && ! (cfun->static_chain_decl != NULL && i == STATIC_CHAIN_REGNUM)\n-\t  && ! (current_function_calls_eh_return\n+\t  && ! (crtl->calls_eh_return\n \t\t&& (i == EH_RETURN_STACKADJ_REGNO\n \t\t    || ((unsigned) i >= EH_RETURN_DATA_REGNO (0)\n \t\t\t&& (unsigned) i <= EH_RETURN_DATA_REGNO (3)))))\n@@ -6305,7 +6305,7 @@ sh_expand_prologue (void)\n     }\n \n   /* Emit the code for SETUP_VARARGS.  */\n-  if (current_function_stdarg)\n+  if (cfun->stdarg)\n     {\n       if (TARGET_VARARGS_PRETEND_ARGS (current_function_decl))\n \t{\n@@ -6850,7 +6850,7 @@ sh_expand_epilogue (bool sibcall_p)\n \t\t       + crtl->args.info.stack_regs * 8,\n \t\t       stack_pointer_rtx, e, NULL);\n \n-  if (current_function_calls_eh_return)\n+  if (crtl->calls_eh_return)\n     emit_insn (GEN_ADD3 (stack_pointer_rtx, stack_pointer_rtx,\n \t\t\t EH_RETURN_STACKADJ_RTX));\n \n@@ -7864,7 +7864,7 @@ sh_setup_incoming_varargs (CUMULATIVE_ARGS *ca,\n \t\t\t   int *pretend_arg_size,\n \t\t\t   int second_time ATTRIBUTE_UNUSED)\n {\n-  gcc_assert (current_function_stdarg);\n+  gcc_assert (cfun->stdarg);\n   if (TARGET_VARARGS_PRETEND_ARGS (current_function_decl))\n     {\n       int named_parm_regs, anon_parm_regs;\n@@ -9216,7 +9216,7 @@ sh_allocate_initial_value (rtx hard_reg)\n \t  && ! (TARGET_SHCOMPACT\n \t\t&& ((crtl->args.info.call_cookie\n \t\t     & ~ CALL_COOKIE_RET_TRAMP (1))\n-\t\t    || current_function_saves_all_registers)))\n+\t\t    || crtl->saves_all_registers)))\n \tx = hard_reg;\n       else\n \tx = gen_frame_mem (Pmode, return_address_pointer_rtx);\n@@ -10612,7 +10612,7 @@ sh_get_pr_initial_val (void)\n   if (TARGET_SHCOMPACT\n       && ((crtl->args.info.call_cookie\n \t   & ~ CALL_COOKIE_RET_TRAMP (1))\n-\t  || current_function_saves_all_registers))\n+\t  || crtl->saves_all_registers))\n     return gen_frame_mem (SImode, return_address_pointer_rtx);\n \n   /* If we haven't finished rtl generation, there might be a nonlocal label"}, {"sha": "67a6e3923fbd02fcc6e7458bd2eccf6c95740bad", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -1359,7 +1359,7 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n #define DEFAULT_PCC_STRUCT_RETURN 0\n \n #define SHMEDIA_REGS_STACK_ADJUST() \\\n-  (TARGET_SHCOMPACT && current_function_saves_all_registers \\\n+  (TARGET_SHCOMPACT && crtl->saves_all_registers \\\n    ? (8 * (/* r28-r35 */ 8 + /* r44-r59 */ 16 + /* tr5-tr7 */ 3) \\\n       + (TARGET_FPU_ANY ? 4 * (/* fr36 - fr63 */ 28) : 0)) \\\n    : 0)"}, {"sha": "837fd2e0484989146f71db332e4de3852efd2774", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -5067,7 +5067,7 @@ label:\n   [(set (match_dup 0) (match_dup 1))]\n   \"\n {\n-  if (TARGET_SHCOMPACT && current_function_saves_all_registers)\n+  if (TARGET_SHCOMPACT && crtl->saves_all_registers)\n     operands[1] = gen_frame_mem (SImode, return_address_pointer_rtx);\n }\")\n "}, {"sha": "2758e4d848539f7670bdd56f19f3dab54f7840d2", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -2639,7 +2639,7 @@ eligible_for_return_delay (rtx trial)\n \n   /* If the function uses __builtin_eh_return, the eh_return machinery\n      occupies the delay slot.  */\n-  if (current_function_calls_eh_return)\n+  if (crtl->calls_eh_return)\n     return 0;\n \n   /* In the case of a true leaf function, anything can go into the slot.  */\n@@ -3084,7 +3084,7 @@ sparc_tls_got (void)\n   rtx temp;\n   if (flag_pic)\n     {\n-      current_function_uses_pic_offset_table = 1;\n+      crtl->uses_pic_offset_table = 1;\n       return pic_offset_table_rtx;\n     }\n \n@@ -3300,7 +3300,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n       pic_ref = gen_const_mem (Pmode,\n \t\t\t       gen_rtx_PLUS (Pmode,\n \t\t\t\t\t     pic_offset_table_rtx, address));\n-      current_function_uses_pic_offset_table = 1;\n+      crtl->uses_pic_offset_table = 1;\n       insn = emit_move_insn (reg, pic_ref);\n       /* Put a REG_EQUAL note on this insn, so that it can be optimized\n \t by loop.  */\n@@ -3342,7 +3342,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n     /* ??? Why do we do this?  */\n     /* Now movsi_pic_label_ref uses it, but we ought to be checking that\n        the register is live instead, in case it is eliminated.  */\n-    current_function_uses_pic_offset_table = 1;\n+    crtl->uses_pic_offset_table = 1;\n \n   return orig;\n }\n@@ -3479,7 +3479,7 @@ sparc_emit_call_insn (rtx pat, rtx addr)\n \t  : !SYMBOL_REF_LOCAL_P (addr)))\n     {\n       use_reg (&CALL_INSN_FUNCTION_USAGE (insn), pic_offset_table_rtx);\n-      current_function_uses_pic_offset_table = 1;\n+      crtl->uses_pic_offset_table = 1;\n     }\n }\n \f\n@@ -4099,7 +4099,7 @@ sparc_expand_prologue (void)\n     emit_save_or_restore_regs (SORR_SAVE);\n \n   /* Load the PIC register if needed.  */\n-  if (flag_pic && current_function_uses_pic_offset_table)\n+  if (flag_pic && crtl->uses_pic_offset_table)\n     load_pic_register (false);\n }\n  \n@@ -4235,7 +4235,7 @@ output_return (rtx insn)\n \t semantics of restore/return.  We simply output the jump to the\n \t return address and the insn in the delay slot (if any).  */\n \n-      gcc_assert (! current_function_calls_eh_return);\n+      gcc_assert (! crtl->calls_eh_return);\n \n       return \"jmp\\t%%o7+%)%#\";\n     }\n@@ -4246,7 +4246,7 @@ output_return (rtx insn)\n \t combined with the 'restore' instruction or put in the delay slot of\n \t the 'return' instruction.  */\n \n-      if (current_function_calls_eh_return)\n+      if (crtl->calls_eh_return)\n \t{\n \t  /* If the function uses __builtin_eh_return, the eh_return\n \t     machinery occupies the delay slot.  */\n@@ -6780,7 +6780,7 @@ print_operand (FILE *file, rtx x, int code)\n \t The call emitted is the same when sparc_std_struct_return is \n \t present. */\n      if (! TARGET_ARCH64\n-\t && current_function_returns_struct\n+\t && cfun->returns_struct\n \t && ! sparc_std_struct_return\n \t && (TREE_CODE (DECL_SIZE (DECL_RESULT (current_function_decl)))\n \t     == INTEGER_CST)\n@@ -7863,7 +7863,7 @@ sparc_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n {\n   return (decl\n \t  && flag_delayed_branch\n-\t  && (TARGET_ARCH64 || ! current_function_returns_struct)\n+\t  && (TARGET_ARCH64 || ! cfun->returns_struct)\n \t  && !(TARGET_VXWORKS_RTP\n \t       && flag_pic\n \t       && !targetm.binds_local_p (decl)));"}, {"sha": "e9f0f2ab5c2435e47c976c6e22ce220d1e0e3cad", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -1678,11 +1678,11 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define EXIT_IGNORE_STACK\t\\\n  (get_frame_size () != 0\t\\\n-  || current_function_calls_alloca || crtl->outgoing_args_size)\n+  || cfun->calls_alloca || crtl->outgoing_args_size)\n \n /* Define registers used by the epilogue and return instruction.  */\n #define EPILOGUE_USES(REGNO) ((REGNO) == 31 \\\n-  || (current_function_calls_eh_return && (REGNO) == 1))\n+  || (crtl->calls_eh_return && (REGNO) == 1))\n \f\n /* Length in units of the trampoline for entering a nested function.  */\n \n@@ -1724,7 +1724,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* This is the offset of the return address to the true next instruction to be\n    executed for the current function.  */\n #define RETURN_ADDR_OFFSET \\\n-  (8 + 4 * (! TARGET_ARCH64 && current_function_returns_struct))\n+  (8 + 4 * (! TARGET_ARCH64 && cfun->returns_struct))\n \n /* The current return address is in %i7.  The return address of anything\n    farther back is in the register window save area at [%fp+60].  */"}, {"sha": "c02c7094df26599127134e32f1754b097ebf2c06", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -137,10 +137,10 @@\n   (symbol_ref \"flag_pic != 0\"))\n \n (define_attr \"calls_alloca\" \"false,true\"\n-  (symbol_ref \"current_function_calls_alloca != 0\"))\n+  (symbol_ref \"cfun->calls_alloca != 0\"))\n \n (define_attr \"calls_eh_return\" \"false,true\"\n-   (symbol_ref \"current_function_calls_eh_return !=0 \"))\n+   (symbol_ref \"crtl->calls_eh_return !=0 \"))\n    \n (define_attr \"leaf_function\" \"false,true\"\n   (symbol_ref \"current_function_uses_only_leaf_regs != 0\"))\n@@ -1844,7 +1844,7 @@\n \t(minus:SI (match_dup 5) (match_dup 4)))]\n   \"flag_pic\"\n {\n-  current_function_uses_pic_offset_table = 1;\n+  crtl->uses_pic_offset_table = 1;\n   operands[2] = gen_rtx_SYMBOL_REF (Pmode, \"_GLOBAL_OFFSET_TABLE_\");\n   if (!can_create_pseudo_p ())\n     {\n@@ -1993,7 +1993,7 @@\n         (minus:DI (match_dup 5) (match_dup 4)))]\n   \"TARGET_ARCH64 && flag_pic\"\n {\n-  current_function_uses_pic_offset_table = 1;\n+  crtl->uses_pic_offset_table = 1;\n   operands[2] = gen_rtx_SYMBOL_REF (Pmode, \"_GLOBAL_OFFSET_TABLE_\");\n   if (!can_create_pseudo_p ())\n     {\n@@ -7237,7 +7237,7 @@\n   [(unspec_volatile [(const_int 0)] UNSPECV_SETJMP)]\n   \"\"\n {\n-  if (! current_function_calls_alloca)\n+  if (! cfun->calls_alloca)\n     return \"\";\n   if (! TARGET_V9)\n     return \"\\tta\\t3\\n\";"}, {"sha": "ad41994d5a5ef104389795eb4f20ac15713315e3", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -1592,7 +1592,7 @@ spu_split_immediate (rtx * ops)\n \t    {\n \t      rtx pic_reg = get_pic_reg ();\n \t      emit_insn (gen_addsi3 (ops[0], ops[0], pic_reg));\n-\t      current_function_uses_pic_offset_table = 1;\n+\t      crtl->uses_pic_offset_table = 1;\n \t    }\n \t  return flag_pic || c == IC_IL2s;\n \t}\n@@ -1618,7 +1618,7 @@ need_to_save_reg (int regno, int saving)\n     return 1;\n   if (flag_pic\n       && regno == PIC_OFFSET_TABLE_REGNUM\n-      && (!saving || current_function_uses_pic_offset_table)\n+      && (!saving || crtl->uses_pic_offset_table)\n       && (!saving\n \t  || !current_function_is_leaf || df_regs_ever_live_p (LAST_ARG_REGNUM)))\n     return 1;\n@@ -1739,7 +1739,7 @@ spu_expand_prologue (void)\n   emit_note (NOTE_INSN_DELETED);\n \n   if (flag_pic && optimize == 0)\n-    current_function_uses_pic_offset_table = 1;\n+    crtl->uses_pic_offset_table = 1;\n \n   if (spu_naked_function_p (current_function_decl))\n     return;\n@@ -1753,7 +1753,7 @@ spu_expand_prologue (void)\n     + crtl->args.pretend_args_size;\n \n   if (!current_function_is_leaf\n-      || current_function_calls_alloca || total_size > 0)\n+      || cfun->calls_alloca || total_size > 0)\n     total_size += STACK_POINTER_OFFSET;\n \n   /* Save this first because code after this might use the link\n@@ -1776,7 +1776,7 @@ spu_expand_prologue (void)\n \t  }\n     }\n \n-  if (flag_pic && current_function_uses_pic_offset_table)\n+  if (flag_pic && crtl->uses_pic_offset_table)\n     {\n       rtx pic_reg = get_pic_reg ();\n       insn = emit_insn (gen_load_pic_offset (pic_reg, scratch_reg_0));\n@@ -1878,12 +1878,12 @@ spu_expand_epilogue (bool sibcall_p)\n     + crtl->args.pretend_args_size;\n \n   if (!current_function_is_leaf\n-      || current_function_calls_alloca || total_size > 0)\n+      || cfun->calls_alloca || total_size > 0)\n     total_size += STACK_POINTER_OFFSET;\n \n   if (total_size > 0)\n     {\n-      if (current_function_calls_alloca)\n+      if (cfun->calls_alloca)\n \tframe_emit_load (STACK_POINTER_REGNUM, sp_reg, 0);\n       else\n \tframe_emit_add_imm (sp_reg, sp_reg, total_size, scratch_reg_0);"}, {"sha": "6cbe52d5048de44a525e2a215f88015124f91183", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -996,7 +996,7 @@ xstormy16_compute_stack_layout (void)\n     if (REG_NEEDS_SAVE (regno, ifun))\n       layout.register_save_size += UNITS_PER_WORD;\n   \n-  if (current_function_stdarg)\n+  if (cfun->stdarg)\n     layout.stdarg_save_size = NUM_ARGUMENT_REGISTERS * UNITS_PER_WORD;\n   else\n     layout.stdarg_save_size = 0;"}, {"sha": "2a0f30936413bd4490ccb0f26f80da34356336dd", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -1386,7 +1386,7 @@ compute_register_save_size (long * p_reg_saved)\n   long reg_saved = 0;\n \n   /* Count the return pointer if we need to save it.  */\n-  if (current_function_profile && !call_p)\n+  if (crtl->profile && !call_p)\n     {\n       df_set_regs_ever_live (LINK_POINTER_REGNUM, true);\n       call_p = 1;"}, {"sha": "17fd4971fa686c78c9620bdc16ef38774628db2c", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -23,7 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"xtensa-config.h\"\n \n /* Standard GCC variables that we reference.  */\n-extern int current_function_calls_alloca;\n+extern int cfun->calls_alloca;\n extern int optimize;\n \n /* External variables defined in xtensa.c.  */"}, {"sha": "74b1b15a22395148288b7e04c006425589675547", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -1,3 +1,9 @@\n+2008-04-25  Jan Hubicka  <jh@suse.cz>\n+\n+\t* typeck.c (check_return_expr): Update.\n+\t* decl.c (start_preparsed_function): Update.\n+\t* method.c (use_thunk): Update.\n+\n 2008-04-24  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/35758"}, {"sha": "221b30040d7ae0d6516a1371863f0c2d00478f3e", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -11278,7 +11278,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n      call expand_expr to calculate the size of a variable-sized array.\n      We haven't necessarily assigned RTL to all variables yet, so it's\n      not safe to try to expand expressions involving them.  */\n-  cfun->x_dont_save_pending_sizes_p = 1;\n+  cfun->dont_save_pending_sizes_p = 1;\n \n   /* Start the statement-tree, start the tree now.  */\n   DECL_SAVED_TREE (decl1) = push_stmt_list ();"}, {"sha": "45358b2c5f4cbb2bd97648fa3b092644ef224a4a", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -437,7 +437,7 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n       BLOCK_VARS (fn_block) = a;\n       DECL_INITIAL (thunk_fndecl) = fn_block;\n       init_function_start (thunk_fndecl);\n-      current_function_is_thunk = 1;\n+      crtl->is_thunk = 1;\n       assemble_start_function (thunk_fndecl, fnname);\n \n       targetm.asm_out.output_mi_thunk (asm_out_file, thunk_fndecl,"}, {"sha": "42779562a88d2b379398462d2749af655bad55fd", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -7138,7 +7138,7 @@ check_return_expr (tree retval, bool *no_warning)\n       if (retval == error_mark_node)\n \treturn retval;\n       /* We can't initialize a register from a AGGR_INIT_EXPR.  */\n-      else if (! current_function_returns_struct\n+      else if (! cfun->returns_struct\n \t       && TREE_CODE (retval) == TARGET_EXPR\n \t       && TREE_CODE (TREE_OPERAND (retval, 1)) == AGGR_INIT_EXPR)\n \tretval = build2 (COMPOUND_EXPR, TREE_TYPE (retval), retval,"}, {"sha": "79714e92a08964cfac37e4f7e2e30fb38598763c", "filename": "gcc/df-scan.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -3871,7 +3871,7 @@ df_get_exit_block_use_set (bitmap exit_block_uses)\n   \n #ifdef EH_RETURN_DATA_REGNO\n   /* Mark the registers that will contain data for the handler.  */\n-  if (reload_completed && current_function_calls_eh_return)\n+  if (reload_completed && crtl->calls_eh_return)\n     for (i = 0; ; ++i)\n       {\n \tunsigned regno = EH_RETURN_DATA_REGNO (i);\n@@ -3883,7 +3883,7 @@ df_get_exit_block_use_set (bitmap exit_block_uses)\n \n #ifdef EH_RETURN_STACKADJ_RTX\n   if ((!HAVE_epilogue || ! epilogue_completed)\n-      && current_function_calls_eh_return)\n+      && crtl->calls_eh_return)\n     {\n       rtx tmp = EH_RETURN_STACKADJ_RTX;\n       if (tmp && REG_P (tmp))\n@@ -3893,7 +3893,7 @@ df_get_exit_block_use_set (bitmap exit_block_uses)\n \n #ifdef EH_RETURN_HANDLER_RTX\n   if ((!HAVE_epilogue || ! epilogue_completed)\n-      && current_function_calls_eh_return)\n+      && crtl->calls_eh_return)\n     {\n       rtx tmp = EH_RETURN_HANDLER_RTX;\n       if (tmp && REG_P (tmp))"}, {"sha": "e1d2fb2c5c3521459888fdb1b79175668f60bc34", "filename": "gcc/dojump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -70,7 +70,7 @@ void\n clear_pending_stack_adjust (void)\n {\n   if (optimize > 0\n-      && (! flag_omit_frame_pointer || current_function_calls_alloca)\n+      && (! flag_omit_frame_pointer || cfun->calls_alloca)\n       && EXIT_IGNORE_STACK\n       && ! (DECL_INLINE (current_function_decl) && ! flag_no_inline))\n     discard_pending_stack_adjust ();"}, {"sha": "6984e19bd9586ab0fd151ec7dfdff3c15605a26e", "filename": "gcc/dse.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -531,7 +531,7 @@ struct clear_alias_mode_holder\n \n static alloc_pool clear_alias_mode_pool;\n \n-/* This is true except if current_function_stdarg -- i.e. we cannot do\n+/* This is true except if cfun->stdarg -- i.e. we cannot do\n    this for vararg functions because they play games with the frame.  */\n static bool stores_off_frame_dead_at_return;\n \n@@ -718,7 +718,7 @@ dse_step0 (void)\n   bb_table = XCNEWVEC (bb_info_t, last_basic_block);\n   rtx_group_next_id = 0;\n \n-  stores_off_frame_dead_at_return = !current_function_stdarg;\n+  stores_off_frame_dead_at_return = !cfun->stdarg;\n \n   init_alias_analysis ();\n   \n@@ -2163,7 +2163,7 @@ dse_step1 (void)\n \t      && (EDGE_COUNT (bb->succs) == 0\n \t\t  || (single_succ_p (bb)\n \t\t      && single_succ (bb) == EXIT_BLOCK_PTR\n-\t\t      && ! current_function_calls_eh_return)))\n+\t\t      && ! crtl->calls_eh_return)))\n \t    {\n \t      insn_info_t i_ptr = active_local_stores;\n \t      while (i_ptr)"}, {"sha": "7625947049d18957d41d66cb55cc7dcb7fd060f8", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -2657,8 +2657,8 @@ dwarf2out_begin_prologue (unsigned int line ATTRIBUTE_UNUSED,\n   fde->dw_fde_cfi = NULL;\n   fde->funcdef_number = current_function_funcdef_no;\n   fde->nothrow = TREE_NOTHROW (current_function_decl);\n-  fde->uses_eh_lsda = cfun->uses_eh_lsda;\n-  fde->all_throwers_are_sibcalls = cfun->all_throwers_are_sibcalls;\n+  fde->uses_eh_lsda = crtl->uses_eh_lsda;\n+  fde->all_throwers_are_sibcalls = crtl->all_throwers_are_sibcalls;\n \n   args_size = old_args_size = 0;\n "}, {"sha": "2fc2f92126a24fbcbdee30b7e947f9bd8ca9b521", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -678,7 +678,7 @@ gen_tmp_stack_mem (enum machine_mode mode, rtx addr)\n {\n   rtx mem = gen_rtx_MEM (mode, addr);\n   MEM_NOTRAP_P (mem) = 1;\n-  if (!current_function_calls_alloca)\n+  if (!cfun->calls_alloca)\n     set_mem_alias_set (mem, get_frame_alias_set ());\n   return mem;\n }"}, {"sha": "f8bacd5902bcd36cc92ee65c13e99014268cfc62", "filename": "gcc/except.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -1691,7 +1691,7 @@ sjlj_assign_call_site_values (rtx dispatch_label, struct sjlj_lp_info *lp_info)\n \tr->landing_pad = dispatch_label;\n \tlp_info[i].action_index = collect_one_action_chain (ar_hash, r);\n \tif (lp_info[i].action_index != -1)\n-\t  cfun->uses_eh_lsda = 1;\n+\t  crtl->uses_eh_lsda = 1;\n       }\n \n   htab_delete (ar_hash);\n@@ -1817,7 +1817,7 @@ sjlj_emit_function_enter (rtx dispatch_label)\n   emit_move_insn (mem, eh_personality_libfunc);\n \n   mem = adjust_address (fc, Pmode, sjlj_fc_lsda_ofs);\n-  if (cfun->uses_eh_lsda)\n+  if (crtl->uses_eh_lsda)\n     {\n       char buf[20];\n       rtx sym;\n@@ -2746,7 +2746,7 @@ can_throw_external (const_rtx insn)\n   return can_throw_external_1 (INTVAL (XEXP (note, 0)), false);\n }\n \n-/* Set TREE_NOTHROW and cfun->all_throwers_are_sibcalls.  */\n+/* Set TREE_NOTHROW and crtl->all_throwers_are_sibcalls.  */\n \n unsigned int\n set_nothrow_function_flags (void)\n@@ -2761,13 +2761,13 @@ set_nothrow_function_flags (void)\n \n   TREE_NOTHROW (current_function_decl) = 1;\n \n-  /* Assume cfun->all_throwers_are_sibcalls until we encounter\n+  /* Assume crtl->all_throwers_are_sibcalls until we encounter\n      something that can throw an exception.  We specifically exempt\n      CALL_INSNs that are SIBLING_CALL_P, as these are really jumps,\n      and can't throw.  Most CALL_INSNs are not SIBLING_CALL_P, so this\n      is optimistic.  */\n \n-  cfun->all_throwers_are_sibcalls = 1;\n+  crtl->all_throwers_are_sibcalls = 1;\n \n   if (! flag_exceptions)\n     return 0;\n@@ -2779,7 +2779,7 @@ set_nothrow_function_flags (void)\n \n \tif (!CALL_P (insn) || !SIBLING_CALL_P (insn))\n \t  {\n-\t    cfun->all_throwers_are_sibcalls = 0;\n+\t    crtl->all_throwers_are_sibcalls = 0;\n \t    return 0;\n \t  }\n       }\n@@ -2792,7 +2792,7 @@ set_nothrow_function_flags (void)\n \n \tif (!CALL_P (insn) || !SIBLING_CALL_P (insn))\n \t  {\n-\t    cfun->all_throwers_are_sibcalls = 0;\n+\t    crtl->all_throwers_are_sibcalls = 0;\n \t    return 0;\n \t  }\n       }\n@@ -2829,7 +2829,7 @@ expand_builtin_unwind_init (void)\n {\n   /* Set this so all the registers get saved in our frame; we need to be\n      able to copy the saved values for any registers from frames we unwind.  */\n-  current_function_saves_all_registers = 1;\n+  crtl->saves_all_registers = 1;\n \n #ifdef SETUP_FRAME_ADDRESSES\n   SETUP_FRAME_ADDRESSES ();\n@@ -2952,7 +2952,7 @@ expand_eh_return (void)\n   if (! crtl->eh.ehr_label)\n     return;\n \n-  current_function_calls_eh_return = 1;\n+  crtl->calls_eh_return = 1;\n \n #ifdef EH_RETURN_STACKADJ_RTX\n   emit_move_insn (EH_RETURN_STACKADJ_RTX, const0_rtx);\n@@ -3248,7 +3248,7 @@ convert_to_eh_region_ranges (void)\n \t/* Existence of catch handlers, or must-not-throw regions\n \t   implies that an lsda is needed (even if empty).  */\n \tif (this_action != -1)\n-\t  cfun->uses_eh_lsda = 1;\n+\t  crtl->uses_eh_lsda = 1;\n \n \t/* Delay creation of region notes for no-action regions\n \t   until we're sure that an lsda will be required.  */\n@@ -3599,7 +3599,7 @@ output_function_exception_table (const char * ARG_UNUSED (fnname))\n   int tt_format_size = 0;\n \n   /* Not all functions need anything.  */\n-  if (! cfun->uses_eh_lsda)\n+  if (! crtl->uses_eh_lsda)\n     return;\n \n   if (eh_personality_libfunc)"}, {"sha": "d3cc01b9701b12223893c65883f80535e18b199d", "filename": "gcc/explow.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -1081,7 +1081,7 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align)\n     return virtual_stack_dynamic_rtx;\n \n   /* Otherwise, show we're calling alloca or equivalent.  */\n-  current_function_calls_alloca = 1;\n+  cfun->calls_alloca = 1;\n \n   /* Ensure the size is in the proper mode.  */\n   if (GET_MODE (size) != VOIDmode && GET_MODE (size) != Pmode)\n@@ -1129,7 +1129,7 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align)\n      would use reg notes to store the \"optimized\" size and fix things\n      up later.  These days we know this information before we ever\n      start building RTL so the reg notes are unnecessary.  */\n-  if (!current_function_calls_setjmp)\n+  if (!cfun->calls_setjmp)\n     {\n       int align = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;\n \n@@ -1236,7 +1236,7 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align)\n #endif\n \n       /* Check stack bounds if necessary.  */\n-      if (current_function_limit_stack)\n+      if (crtl->limit_stack)\n \t{\n \t  rtx available;\n \t  rtx space_available = gen_label_rtx ();"}, {"sha": "141904f123131e16ef90ce71dca7a7a66c50e844", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -4339,8 +4339,8 @@ expand_assignment (tree to, tree from, bool nontemporal)\n      the place the value is being stored, use a safe function when copying\n      a value through a pointer into a structure value return block.  */\n   if (TREE_CODE (to) == RESULT_DECL && TREE_CODE (from) == INDIRECT_REF\n-      && current_function_returns_struct\n-      && !current_function_returns_pcc_struct)\n+      && cfun->returns_struct\n+      && !cfun->returns_pcc_struct)\n     {\n       rtx from_rtx, size;\n "}, {"sha": "ccef70f00f1e3f1f51a944bc1154ff5da3962e93", "filename": "gcc/final.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -1505,7 +1505,7 @@ final_start_function (rtx first ATTRIBUTE_UNUSED, FILE *file,\n   /* The Sun386i and perhaps other machines don't work right\n      if the profiling code comes after the prologue.  */\n #ifdef PROFILE_BEFORE_PROLOGUE\n-  if (current_function_profile)\n+  if (crtl->profile)\n     profile_function (file);\n #endif /* PROFILE_BEFORE_PROLOGUE */\n \n@@ -1550,7 +1550,7 @@ static void\n profile_after_prologue (FILE *file ATTRIBUTE_UNUSED)\n {\n #ifndef PROFILE_BEFORE_PROLOGUE\n-  if (current_function_profile)\n+  if (crtl->profile)\n     profile_function (file);\n #endif /* not PROFILE_BEFORE_PROLOGUE */\n }\n@@ -1562,7 +1562,7 @@ profile_function (FILE *file ATTRIBUTE_UNUSED)\n # define NO_PROFILE_COUNTERS\t0\n #endif\n #if defined(ASM_OUTPUT_REG_PUSH)\n-  int sval = current_function_returns_struct;\n+  int sval = cfun->returns_struct;\n   rtx svrtx = targetm.calls.struct_value_rtx (TREE_TYPE (current_function_decl), 1);\n #if defined(STATIC_CHAIN_INCOMING_REGNUM) || defined(STATIC_CHAIN_REGNUM)\n   int cxt = cfun->static_chain_decl != NULL;\n@@ -3813,7 +3813,7 @@ leaf_function_p (void)\n   rtx insn;\n   rtx link;\n \n-  if (current_function_profile || profile_arc_flag)\n+  if (crtl->profile || profile_arc_flag)\n     return 0;\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n@@ -3888,7 +3888,7 @@ only_leaf_regs_used (void)\n \t&& ! permitted_reg_in_leaf_functions[i])\n       return 0;\n \n-  if (current_function_uses_pic_offset_table\n+  if (crtl->uses_pic_offset_table\n       && pic_offset_table_rtx != 0\n       && REG_P (pic_offset_table_rtx)\n       && ! permitted_reg_in_leaf_functions[REGNO (pic_offset_table_rtx)])"}, {"sha": "ee39ef18c3c7382566f05b10ca9d6d235a1f9977", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -1,3 +1,7 @@\n+2008-04-25  Jan Hubicka  <jh@suse.cz>\n+\n+\t* trans-decl.c (trans_function_start): Update.\n+\n 2008-04-25  Tobias Burnus  <burnus@net-b.de>\n \t    Daniel Franke <franke.daniel@gmail.com>\n "}, {"sha": "4e6dddbf5013371ad4d5d310d9cc408237ab51e6", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -1601,7 +1601,7 @@ trans_function_start (gfc_symbol * sym)\n      call expand_expr to calculate the size of a variable-sized array.\n      We haven't necessarily assigned RTL to all variables yet, so it's\n      not safe to try to expand expressions involving them.  */\n-  cfun->x_dont_save_pending_sizes_p = 1;\n+  cfun->dont_save_pending_sizes_p = 1;\n \n   /* function.c requires a push at the start of the function.  */\n   pushlevel (0);"}, {"sha": "5d70ddd3f9ff71398f7556e0f3891ca406cdb2cb", "filename": "gcc/function.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -1969,7 +1969,7 @@ assign_parms_augmented_arg_list (struct assign_parm_data_all *all)\n \n   /* If struct value address is treated as the first argument, make it so.  */\n   if (aggregate_value_p (DECL_RESULT (fndecl), fndecl)\n-      && ! current_function_returns_pcc_struct\n+      && ! cfun->returns_pcc_struct\n       && targetm.calls.struct_value_rtx (TREE_TYPE (fndecl), 1) == 0)\n     {\n       tree type = build_pointer_type (TREE_TYPE (fntype));\n@@ -2008,7 +2008,7 @@ assign_parm_find_data_types (struct assign_parm_data_all *all, tree parm,\n   memset (data, 0, sizeof (*data));\n \n   /* NAMED_ARG is a mis-nomer.  We really mean 'non-varadic'. */\n-  if (!current_function_stdarg)\n+  if (!cfun->stdarg)\n     data->named_arg = 1;  /* No varadic parms.  */\n   else if (TREE_CHAIN (parm))\n     data->named_arg = 1;  /* Not the last non-varadic parm. */\n@@ -2967,7 +2967,7 @@ assign_parms (tree fndecl)\n \t  continue;\n \t}\n \n-      if (current_function_stdarg && !TREE_CHAIN (parm))\n+      if (cfun->stdarg && !TREE_CHAIN (parm))\n \tassign_parms_setup_varargs (&all, &data, false);\n \n       /* Find out where the parameter arrives in this function.  */\n@@ -3859,12 +3859,12 @@ allocate_struct_function (tree fndecl, bool abstract_p)\n       if (!abstract_p && aggregate_value_p (result, fndecl))\n \t{\n #ifdef PCC_STATIC_STRUCT_RETURN\n-\t  current_function_returns_pcc_struct = 1;\n+\t  cfun->returns_pcc_struct = 1;\n #endif\n-\t  current_function_returns_struct = 1;\n+\t  cfun->returns_struct = 1;\n \t}\n \n-      current_function_stdarg\n+      cfun->stdarg\n \t= (fntype\n \t   && TYPE_ARG_TYPES (fntype) != 0\n \t   && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))\n@@ -4103,11 +4103,11 @@ expand_function_start (tree subr)\n      valid operands of arithmetic insns.  */\n   init_recog_no_volatile ();\n \n-  current_function_profile\n+  crtl->profile\n     = (profile_flag\n        && ! DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (subr));\n \n-  current_function_limit_stack\n+  crtl->limit_stack\n     = (stack_limit_rtx != NULL_RTX && ! DECL_NO_LIMIT_STACK (subr));\n \n   /* Make the label for return statements to jump to.  Do not special\n@@ -4126,7 +4126,7 @@ expand_function_start (tree subr)\n       rtx value_address = 0;\n \n #ifdef PCC_STATIC_STRUCT_RETURN\n-      if (current_function_returns_pcc_struct)\n+      if (cfun->returns_pcc_struct)\n \t{\n \t  int size = int_size_in_bytes (TREE_TYPE (DECL_RESULT (subr)));\n \t  value_address = assemble_static_space (size);\n@@ -4244,7 +4244,7 @@ expand_function_start (tree subr)\n \n   parm_birth_insn = get_last_insn ();\n \n-  if (current_function_profile)\n+  if (crtl->profile)\n     {\n #ifdef PROFILE_HOOK\n       PROFILE_HOOK (current_function_funcdef_no);\n@@ -4366,7 +4366,7 @@ expand_function_end (void)\n \n   /* If arg_pointer_save_area was referenced only from a nested\n      function, we will not have initialized it yet.  Do that now.  */\n-  if (arg_pointer_save_area && ! cfun->arg_pointer_save_area_init)\n+  if (arg_pointer_save_area && ! crtl->arg_pointer_save_area_init)\n     get_arg_pointer_save_area ();\n \n   /* If we are doing stack checking and this function makes calls,\n@@ -4523,9 +4523,9 @@ expand_function_end (void)\n \n      If returning a structure PCC style,\n      the caller also depends on this value.\n-     And current_function_returns_pcc_struct is not necessarily set.  */\n-  if (current_function_returns_struct\n-      || current_function_returns_pcc_struct)\n+     And cfun->returns_pcc_struct is not necessarily set.  */\n+  if (cfun->returns_struct\n+      || cfun->returns_pcc_struct)\n     {\n       rtx value_address = DECL_RTL (DECL_RESULT (current_function_decl));\n       tree type = TREE_TYPE (DECL_RESULT (current_function_decl));\n@@ -4584,7 +4584,7 @@ expand_function_end (void)\n      an accurate stack pointer to exit the function,\n      insert some code to save and restore the stack pointer.  */\n   if (! EXIT_IGNORE_STACK\n-      && current_function_calls_alloca)\n+      && cfun->calls_alloca)\n     {\n       rtx tem = 0;\n \n@@ -4610,7 +4610,7 @@ get_arg_pointer_save_area (void)\n       arg_pointer_save_area = ret;\n     }\n \n-  if (! cfun->arg_pointer_save_area_init)\n+  if (! crtl->arg_pointer_save_area_init)\n     {\n       rtx seq;\n \n@@ -4737,7 +4737,7 @@ thread_prologue_and_epilogue_insns (void)\n \n       /* Insert an explicit USE for the frame pointer \n          if the profiling is on and the frame pointer is required.  */\n-      if (current_function_profile && frame_pointer_needed)\n+      if (crtl->profile && frame_pointer_needed)\n         emit_insn (gen_rtx_USE (VOIDmode, hard_frame_pointer_rtx));\n \n       /* Retain a map of the prologue insns.  */\n@@ -4748,7 +4748,7 @@ thread_prologue_and_epilogue_insns (void)\n       /* Ensure that instructions are not moved into the prologue when\n \t profiling is on.  The call to the profiling routine can be\n \t emitted within the live range of a call-clobbered register.  */\n-      if (current_function_profile)\n+      if (crtl->profile)\n         emit_insn (gen_blockage ());\n #endif\n \n@@ -5343,7 +5343,7 @@ rest_of_match_asm_constraints (void)\n   rtx insn, pat, *p_sets;\n   int noutputs;\n \n-  if (!cfun->has_asm_statement)\n+  if (!crtl->has_asm_statement)\n     return 0;\n \n   df_set_flags (DF_DEFER_INSN_RESCAN);"}, {"sha": "2e88f97ad7f74ea8368509f2090ec457deb922fa", "filename": "gcc/function.h", "status": "modified", "additions": 54, "deletions": 81, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -334,6 +334,59 @@ struct rtl_data GTY(())\n   /* If some insns can be deferred to the delay slots of the epilogue, the\n      delay list for them is recorded here.  */\n   rtx epilogue_delay_list;\n+\n+  /* Nonzero if function being compiled called builtin_return_addr or\n+     builtin_frame_address with nonzero count.  */\n+  bool accesses_prior_frames;\n+\n+  /* Nonzero if the function calls __builtin_eh_return.  */\n+  bool calls_eh_return;\n+\n+  /* Nonzero if function saves all registers, e.g. if it has a nonlocal\n+     label that can reach the exit block via non-exceptional paths. */\n+  bool saves_all_registers;\n+\n+  /* Nonzero if function being compiled has nonlocal gotos to parent\n+     function.  */\n+  bool has_nonlocal_goto;\n+  \n+  /* Nonzero if function being compiled has an asm statement.  */\n+  bool has_asm_statement;\n+\n+  /* Nonzero if the current function is a thunk, i.e., a lightweight\n+     function implemented by the output_mi_thunk hook) that just\n+     adjusts one of its arguments and forwards to another\n+     function.  */\n+  bool is_thunk;\n+\n+  /* This bit is used by the exception handling logic.  It is set if all\n+     calls (if any) are sibling calls.  Such functions do not have to\n+     have EH tables generated, as they cannot throw.  A call to such a\n+     function, however, should be treated as throwing if any of its callees\n+     can throw.  */\n+  bool all_throwers_are_sibcalls;\n+\n+  /* Nonzero if stack limit checking should be enabled in the current\n+     function.  */\n+  bool limit_stack;\n+\n+  /* Nonzero if profiling code should be generated.  */\n+  bool profile;\n+\n+  /* Nonzero if the current function uses the constant pool.  */\n+  bool uses_const_pool;\n+\n+  /* Nonzero if the current function uses pic_offset_table_rtx.  */\n+  bool uses_pic_offset_table;\n+\n+  /* Nonzero if the current function needs an lsda for exception handling.  */\n+  bool uses_eh_lsda;\n+\n+  /* Set when the tail call has been produced.  */\n+  bool tail_call_emit;\n+\n+  /* Nonzero if code to initialize arg_pointer_save_area has been emitted.  */\n+  bool arg_pointer_save_area_init;\n };\n \n #define return_label (crtl->x_return_label)\n@@ -437,50 +490,10 @@ struct function GTY(())\n      either as a subroutine or builtin.  */\n   unsigned int calls_alloca : 1;\n \n-  /* Nonzero if function being compiled called builtin_return_addr or\n-     builtin_frame_address with nonzero count.  */\n-  unsigned int accesses_prior_frames : 1;\n-\n-  /* Nonzero if the function calls __builtin_eh_return.  */\n-  unsigned int calls_eh_return : 1;\n-\n-\n   /* Nonzero if function being compiled receives nonlocal gotos\n      from nested functions.  */\n   unsigned int has_nonlocal_label : 1;\n \n-  /* Nonzero if function saves all registers, e.g. if it has a nonlocal\n-     label that can reach the exit block via non-exceptional paths. */\n-  unsigned int saves_all_registers : 1;\n-\n-  /* Nonzero if function being compiled has nonlocal gotos to parent\n-     function.  */\n-  unsigned int has_nonlocal_goto : 1;\n-  \n-  /* Nonzero if function being compiled has an asm statement.  */\n-  unsigned int has_asm_statement : 1;\n-\n-  /* Nonzero if the current function is a thunk, i.e., a lightweight\n-     function implemented by the output_mi_thunk hook) that just\n-     adjusts one of its arguments and forwards to another\n-     function.  */\n-  unsigned int is_thunk : 1;\n-\n-  /* This bit is used by the exception handling logic.  It is set if all\n-     calls (if any) are sibling calls.  Such functions do not have to\n-     have EH tables generated, as they cannot throw.  A call to such a\n-     function, however, should be treated as throwing if any of its callees\n-     can throw.  */\n-  unsigned int all_throwers_are_sibcalls : 1;\n-\n-  /* Nonzero if profiling code should be generated.  */\n-  unsigned int profile : 1;\n-\n-  /* Nonzero if stack limit checking should be enabled in the current\n-     function.  */\n-  unsigned int limit_stack : 1;\n-\n-\n   /* Nonzero if current function uses stdarg.h or equivalent.  */\n   unsigned int stdarg : 1;\n \n@@ -491,34 +504,10 @@ struct function GTY(())\n      variable-sized type, then the size of the parameter is computed\n      when the function body is entered.  However, some front-ends do\n      not desire this behavior.  */\n-  unsigned int x_dont_save_pending_sizes_p : 1;\n-\n-  /* Nonzero if the current function uses the constant pool.  */\n-  unsigned int uses_const_pool : 1;\n-\n-  /* Nonzero if the current function uses pic_offset_table_rtx.  */\n-  unsigned int uses_pic_offset_table : 1;\n-\n-  /* Nonzero if the current function needs an lsda for exception handling.  */\n-  unsigned int uses_eh_lsda : 1;\n-\n-  /* Nonzero if code to initialize arg_pointer_save_area has been emitted.  */\n-  unsigned int arg_pointer_save_area_init : 1;\n+  unsigned int dont_save_pending_sizes_p : 1;\n \n   unsigned int after_inlining : 1;\n \n-  /* Set when the call to function itself has been emit.  */\n-  unsigned int recursive_call_emit : 1;\n-\n-\n-  /* Set when the tail call has been produced.  */\n-  unsigned int tail_call_emit : 1;\n-\n-  /* FIXME tuples: This bit is temporarily here to mark when a\n-     function has been gimplified, so we can make sure we're not\n-     creating non GIMPLE tuples after gimplification.  */\n-  unsigned int gimplified : 1;\n-\n   /* Fields below this point are not set for abstract functions; see\n      allocate_struct_function.  */\n \n@@ -563,23 +552,7 @@ extern void pop_cfun (void);\n extern void instantiate_decl_rtl (rtx x);\n \n /* For backward compatibility... eventually these should all go away.  */\n-#define current_function_returns_struct (cfun->returns_struct)\n-#define current_function_returns_pcc_struct (cfun->returns_pcc_struct)\n-#define current_function_calls_setjmp (cfun->calls_setjmp)\n-#define current_function_calls_alloca (cfun->calls_alloca)\n-#define current_function_accesses_prior_frames (cfun->accesses_prior_frames)\n-#define current_function_calls_eh_return (cfun->calls_eh_return)\n-#define current_function_is_thunk (cfun->is_thunk)\n-#define current_function_stdarg (cfun->stdarg)\n-#define current_function_profile (cfun->profile)\n #define current_function_funcdef_no (cfun->funcdef_no)\n-#define current_function_limit_stack (cfun->limit_stack)\n-#define current_function_uses_pic_offset_table (cfun->uses_pic_offset_table)\n-#define current_function_uses_const_pool (cfun->uses_const_pool)\n-#define current_function_has_nonlocal_label (cfun->has_nonlocal_label)\n-#define current_function_saves_all_registers (cfun->saves_all_registers)\n-#define current_function_has_nonlocal_goto (cfun->has_nonlocal_goto)\n-#define current_function_has_asm_statement (cfun->has_asm_statement)\n \n #define current_loops (cfun->x_current_loops)\n #define dom_computed (cfun->cfg->x_dom_computed)"}, {"sha": "477d4d3ef071f9354cc783cdbd3c4dacf1933145", "filename": "gcc/gcse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -658,7 +658,7 @@ gcse_main (rtx f ATTRIBUTE_UNUSED)\n \n   /* We do not construct an accurate cfg in functions which call\n      setjmp, so just punt to be safe.  */\n-  if (current_function_calls_setjmp)\n+  if (cfun->calls_setjmp)\n     return 0;\n \n   /* Assume that we do not need to run jump optimizations after gcse.  */\n@@ -6575,7 +6575,7 @@ bypass_jumps (void)\n \n   /* We do not construct an accurate cfg in functions which call\n      setjmp, so just punt to be safe.  */\n-  if (current_function_calls_setjmp)\n+  if (cfun->calls_setjmp)\n     return 0;\n \n   /* Identify the basic block information for this function, including"}, {"sha": "fd1a19dfd3264b64b639271488f37a475b3f8f2e", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -122,7 +122,7 @@ lower_function_body (void)\n       disp_label = create_artificial_label ();\n       /* This mark will create forward edges from every call site.  */\n       DECL_NONLOCAL (disp_label) = 1;\n-      current_function_has_nonlocal_label = 1;\n+      cfun->has_nonlocal_label = 1;\n       x = build1 (LABEL_EXPR, void_type_node, disp_label);\n       tsi_link_after (&i, x, TSI_CONTINUE_LINKING);\n "}, {"sha": "2e8ffef4430094354a2a490766bafebafde12528", "filename": "gcc/gimplify.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -6603,7 +6603,6 @@ gimplify_function_tree (tree fndecl)\n       DECL_SAVED_TREE (fndecl) = bind;\n     }\n \n-  cfun->gimplified = true;\n   current_function_decl = oldfn;\n   pop_cfun ();\n }"}, {"sha": "befdc9f367cd6504b6d050303f77fba5742c2bb5", "filename": "gcc/global.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -249,7 +249,7 @@ compute_regsets (HARD_REG_SET *elim_set,\n #endif\n   int need_fp\n     = (! flag_omit_frame_pointer\n-       || (current_function_calls_alloca && EXIT_IGNORE_STACK)\n+       || (cfun->calls_alloca && EXIT_IGNORE_STACK)\n        || FRAME_POINTER_REQUIRED);\n \n   max_regno = max_reg_num ();\n@@ -378,7 +378,7 @@ global_alloc (void)\n     if (REG_N_REFS (i) != 0 && REG_LIVE_LENGTH (i) != -1\n \t/* Don't allocate pseudos that cross calls,\n \t   if this function receives a nonlocal goto.  */\n-\t&& (! current_function_has_nonlocal_label\n+\t&& (! cfun->has_nonlocal_label\n \t    || REG_N_CALLS_CROSSED (i) == 0))\n       {\n \tint blk = regno_basic_block (i);"}, {"sha": "af97caf0173c59ba7d33a2eef5246260ff5b4140", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -2008,7 +2008,7 @@ combine_regs (rtx usedreg, rtx setreg, int may_save_copy, int insn_number,\n   if (reg_qty[sreg] >= -1\n       /* If we are not going to let any regs live across calls,\n \t don't tie a call-crossing reg to a non-call-crossing reg.  */\n-      || (current_function_has_nonlocal_label\n+      || (cfun->has_nonlocal_label\n \t  && ((REG_N_CALLS_CROSSED (ureg) > 0)\n \t      != (REG_N_CALLS_CROSSED (sreg) > 0))))\n     return 0;\n@@ -2229,7 +2229,7 @@ find_free_reg (enum reg_class class, enum machine_mode mode, int qtyno,\n \n   /* Don't let a pseudo live in a reg across a function call\n      if we might get a nonlocal goto.  */\n-  if (current_function_has_nonlocal_label\n+  if (cfun->has_nonlocal_label\n       && qty[qtyno].n_calls_crossed > 0)\n     return -1;\n "}, {"sha": "2d05171e7125053482dde1fa519eab1e166b889f", "filename": "gcc/passes.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -1074,11 +1074,7 @@ execute_one_pass (struct opt_pass *pass)\n   if (pass->type == SIMPLE_IPA_PASS)\n     gcc_assert (!cfun && !current_function_decl);\n   else\n-    {\n-      gcc_assert (cfun && current_function_decl);\n-      gcc_assert (!(cfun->curr_properties & PROP_trees)\n-\t\t  || pass->type != RTL_PASS);\n-    }\n+    gcc_assert (cfun && current_function_decl);\n \n   current_pass = pass;\n   /* See if we're supposed to run this pass.  */\n@@ -1174,6 +1170,10 @@ execute_one_pass (struct opt_pass *pass)\n       dump_file = NULL;\n     }\n \n+  if (pass->type != SIMPLE_IPA_PASS)\n+    gcc_assert (!(cfun->curr_properties & PROP_trees)\n+\t\t|| pass->type != RTL_PASS);\n+\n   current_pass = NULL;\n   /* Reset in_gimple_form to not break non-unit-at-a-time mode.  */\n   in_gimple_form = false;"}, {"sha": "f97d9a89ee231057740737b6323d5f61c9ccbc0d", "filename": "gcc/ra-conflict.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fra-conflict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fra-conflict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-conflict.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -1220,7 +1220,7 @@ global_conflicts (void)\n \t  /* No need to record conflicts for call clobbered regs if we have\n \t     nonlocal labels around, as we don't ever try to allocate such\n \t     regs in this case.  */\n-\t  if (! current_function_has_nonlocal_label)\n+\t  if (! cfun->has_nonlocal_label)\n \t    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t      if (call_used_regs [i])\n \t\trecord_one_conflict (allocnos_live, &hard_regs_live, i);"}, {"sha": "13b8e6f7ef0e3e2c9b5627b3956f4a630cce8248", "filename": "gcc/reload1.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -742,11 +742,11 @@ reload (rtx first, int global)\n   /* A function that has a nonlocal label that can reach the exit\n      block via non-exceptional paths must save all call-saved\n      registers.  */\n-  if (current_function_has_nonlocal_label\n+  if (cfun->has_nonlocal_label\n       && has_nonexceptional_receiver ())\n-    current_function_saves_all_registers = 1;\n+    crtl->saves_all_registers = 1;\n \n-  if (current_function_saves_all_registers)\n+  if (crtl->saves_all_registers)\n     for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n       if (! call_used_regs[i] && ! fixed_regs[i] && ! LOCAL_REGNO (i))\n \tdf_set_regs_ever_live (i, true);\n@@ -3721,9 +3721,9 @@ init_elim_table (void)\n \t\t\t     the frame pointer in that case.  At some point,\n \t\t\t     we should improve this by emitting the\n \t\t\t     sp-adjusting insns for this case.  */\n-\t\t\t  || (current_function_calls_alloca\n+\t\t\t  || (cfun->calls_alloca\n \t\t\t      && EXIT_IGNORE_STACK)\n-\t\t\t  || current_function_accesses_prior_frames\n+\t\t\t  || crtl->accesses_prior_frames\n \t\t\t  || FRAME_POINTER_REQUIRED);\n \n   num_eliminable = 0;"}, {"sha": "99e5f75178ffc05c7e90d55b471469c27c4e958e", "filename": "gcc/stack-ptr-mod.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fstack-ptr-mod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fstack-ptr-mod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstack-ptr-mod.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -57,7 +57,7 @@ notice_stack_pointer_modification (void)\n \n   /* Assume that the stack pointer is unchanging if alloca hasn't\n      been used.  */\n-  current_function_sp_is_unchanging = !current_function_calls_alloca;\n+  current_function_sp_is_unchanging = !cfun->calls_alloca;\n   if (current_function_sp_is_unchanging)\n     FOR_EACH_BB (bb)\n       FOR_BB_INSNS (bb, insn)"}, {"sha": "ba4c49d4d8795251da36724446d3ebb9a54904e0", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -1077,7 +1077,7 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n     if (real_output_rtx[i])\n       emit_move_insn (real_output_rtx[i], output_rtx[i]);\n \n-  cfun->has_asm_statement = 1;\n+  crtl->has_asm_statement = 1;\n   free_temp_slots ();\n }\n "}, {"sha": "41c8fefc1088d964872eac225fbe4d250579d716", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -138,7 +138,7 @@ variable_size (tree size)\n      places.  */\n   save = skip_simple_arithmetic (size);\n \n-  if (cfun && cfun->x_dont_save_pending_sizes_p)\n+  if (cfun && cfun->dont_save_pending_sizes_p)\n     /* The front-end doesn't want us to keep a list of the expressions\n        that determine sizes for variable size objects.  Trust it.  */\n     return size;"}, {"sha": "5dc9d045a90ded537440aa1bfc8175414f422459", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -1808,9 +1808,9 @@ notice_special_calls (tree t)\n   int flags = call_expr_flags (t);\n \n   if (flags & ECF_MAY_BE_ALLOCA)\n-    current_function_calls_alloca = true;\n+    cfun->calls_alloca = true;\n   if (flags & ECF_RETURNS_TWICE)\n-    current_function_calls_setjmp = true;\n+    cfun->calls_setjmp = true;\n }\n \n \n@@ -1820,8 +1820,8 @@ notice_special_calls (tree t)\n void\n clear_special_calls (void)\n {\n-  current_function_calls_alloca = false;\n-  current_function_calls_setjmp = false;\n+  cfun->calls_alloca = false;\n+  cfun->calls_setjmp = false;\n }\n \n \n@@ -2495,7 +2495,7 @@ is_ctrl_altering_stmt (const_tree t)\n     {\n       /* A non-pure/const CALL_EXPR alters flow control if the current\n \t function has nonlocal labels.  */\n-      if (TREE_SIDE_EFFECTS (call) && current_function_has_nonlocal_label)\n+      if (TREE_SIDE_EFFECTS (call) && cfun->has_nonlocal_label)\n \treturn true;\n \n       /* A CALL_EXPR also alters control flow if it does not return.  */\n@@ -2545,7 +2545,7 @@ tree_can_make_abnormal_goto (const_tree t)\n   if (TREE_CODE (t) == WITH_SIZE_EXPR)\n     t = TREE_OPERAND (t, 0);\n   if (TREE_CODE (t) == CALL_EXPR)\n-    return TREE_SIDE_EFFECTS (t) && current_function_has_nonlocal_label;\n+    return TREE_SIDE_EFFECTS (t) && cfun->has_nonlocal_label;\n   return false;\n }\n \n@@ -6580,7 +6580,7 @@ tree_purge_dead_abnormal_call_edges (basic_block bb)\n {\n   bool changed = tree_purge_dead_eh_edges (bb);\n \n-  if (current_function_has_nonlocal_label)\n+  if (cfun->has_nonlocal_label)\n     {\n       tree stmt = last_stmt (bb);\n       edge_iterator ei;"}, {"sha": "8c53e6f28b6ffb8ff70c378a9b22cec2e7922a1f", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -411,7 +411,7 @@ tree_rest_of_compilation (tree fndecl)\n      call expand_expr to calculate the size of a variable-sized array.\n      We haven't necessarily assigned RTL to all variables yet, so it's\n      not safe to try to expand expressions involving them.  */\n-  cfun->x_dont_save_pending_sizes_p = 1;\n+  cfun->dont_save_pending_sizes_p = 1;\n   \n   tree_register_cfg_hooks ();\n "}, {"sha": "b82e62024cdbe435cb903a3d0e01d4388d16319e", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -335,7 +335,6 @@ extern struct gimple_opt_pass pass_simple_dse;\n extern struct gimple_opt_pass pass_nrv;\n extern struct gimple_opt_pass pass_mark_used_blocks;\n extern struct gimple_opt_pass pass_rename_ssa_copies;\n-extern struct gimple_opt_pass pass_expand;\n extern struct gimple_opt_pass pass_rest_of_compilation;\n extern struct gimple_opt_pass pass_sink_code;\n extern struct gimple_opt_pass pass_fre;\n@@ -373,6 +372,7 @@ extern struct gimple_opt_pass pass_free_datastructures;\n extern struct gimple_opt_pass pass_init_datastructures;\n extern struct gimple_opt_pass pass_fixup_cfg;\n \n+extern struct rtl_opt_pass pass_expand;\n extern struct rtl_opt_pass pass_init_function;\n extern struct rtl_opt_pass pass_jump;\n extern struct rtl_opt_pass pass_rtl_eh;"}, {"sha": "f1595fe99bc66ce39c0e008941916d7fef348292", "filename": "gcc/tree-stdarg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -595,7 +595,7 @@ static bool\n gate_optimize_stdarg (void)\n {\n   /* This optimization is only for stdarg functions.  */\n-  return current_function_stdarg != 0;\n+  return cfun->stdarg != 0;\n }\n \n "}, {"sha": "0458c8aec60e652938db88fa2bd64b4af17fddbf", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -135,7 +135,7 @@ suitable_for_tail_opt_p (void)\n   referenced_var_iterator rvi;\n   tree var;\n \n-  if (current_function_stdarg)\n+  if (cfun->stdarg)\n     return false;\n \n   /* No local variable nor structure field should be call-clobbered.  We\n@@ -164,7 +164,7 @@ suitable_for_tail_call_opt_p (void)\n \n   /* alloca (until we have stack slot life analysis) inhibits\n      sibling call optimizations, but not tail recursion.  */\n-  if (current_function_calls_alloca)\n+  if (cfun->calls_alloca)\n     return false;\n \n   /* If we are using sjlj exceptions, we may need to add a call to\n@@ -176,7 +176,7 @@ suitable_for_tail_call_opt_p (void)\n   /* Any function that calls setjmp might have longjmp called from\n      any called function.  ??? We really should represent this\n      properly in the CFG so that this needn't be special cased.  */\n-  if (current_function_calls_setjmp)\n+  if (cfun->calls_setjmp)\n     return false;\n \n   /* ??? It is OK if the argument of a function is taken in some cases,"}, {"sha": "7c860d6830bfbe44e7bcb3352f1b5a4ba14aba22", "filename": "gcc/varasm.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b5732b21547a1473879859cf26435f7702be4a/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=e3b5732b21547a1473879859cf26435f7702be4a", "patch": "@@ -1633,7 +1633,7 @@ assemble_start_function (tree decl, const char *fnname)\n       /* When the function starts with a cold section, we need to explicitly\n \t align the hot section and write out the hot section label.\n \t But if the current function is a thunk, we do not have a CFG.  */\n-      if (!current_function_is_thunk\n+      if (!crtl->is_thunk\n \t  && BB_PARTITION (ENTRY_BLOCK_PTR->next_bb) == BB_COLD_PARTITION)\n \t{\n \t  switch_to_section (text_section);\n@@ -3486,7 +3486,7 @@ force_const_mem (enum machine_mode mode, rtx x)\n     return NULL_RTX;\n \n   /* Record that this function has used a constant pool entry.  */\n-  current_function_uses_const_pool = 1;\n+  crtl->uses_const_pool = 1;\n \n   /* Decide which pool to use.  */\n   pool = (targetm.use_blocks_for_constant_p (mode, x)\n@@ -3800,7 +3800,7 @@ mark_constant_pool (void)\n {\n   rtx insn, link;\n \n-  if (!current_function_uses_const_pool && n_deferred_constants == 0)\n+  if (!crtl->uses_const_pool && n_deferred_constants == 0)\n     return;\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))"}]}