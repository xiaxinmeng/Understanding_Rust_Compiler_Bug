{"sha": "9b9ad23f888c646982731e8c9c797885559bdb4f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI5YWQyM2Y4ODhjNjQ2OTgyNzMxZThjOWM3OTc4ODU1NTliZGI0Zg==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-04-05T18:43:45Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-04-05T18:43:45Z"}, "message": "re PR target/50751 (SH Target: Displacement addressing does not work for QImode and HImode)\n\n\tPR target/50751\n\t* config/sh/sh.c (sh_find_mov_disp_adjust): Take machine_mode as the\n\tfirst argument instead of mode size.  Move displacement calculations\n\tto ...\n\t(mov_insn_size, max_mov_insn_displacement, mov_insn_alignment_mask): \n\t... these new functions.\n\t(disp_adjust): Remove max_mov_disp field.\n\t(sh_legitimate_index_p): Use max_mov_insn_displacement and\n\tmov_insn_alignment_mask.\n\t(sh_address_cost): Use max_mov_insn_displacement.\n\nFrom-SVN: r186169", "tree": {"sha": "ee5004d6ad7de25c4591a8c0bcbc8a8e817248bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee5004d6ad7de25c4591a8c0bcbc8a8e817248bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b9ad23f888c646982731e8c9c797885559bdb4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b9ad23f888c646982731e8c9c797885559bdb4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b9ad23f888c646982731e8c9c797885559bdb4f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b9ad23f888c646982731e8c9c797885559bdb4f/comments", "author": null, "committer": null, "parents": [{"sha": "14f986ed7a69f4f21b7312328fbef1747b12b6db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14f986ed7a69f4f21b7312328fbef1747b12b6db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14f986ed7a69f4f21b7312328fbef1747b12b6db"}], "stats": {"total": 234, "additions": 150, "deletions": 84}, "files": [{"sha": "e24e0d2ac595a7e3e7486ed49559fc09705bc58f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b9ad23f888c646982731e8c9c797885559bdb4f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b9ad23f888c646982731e8c9c797885559bdb4f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9b9ad23f888c646982731e8c9c797885559bdb4f", "patch": "@@ -1,3 +1,16 @@\n+2012-04-05  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/50751\n+\t* config/sh/sh.c (sh_find_mov_disp_adjust): Take machine_mode as the\n+\tfirst argument instead of mode size.  Move displacement calculations\n+\tto ...\n+\t(mov_insn_size, max_mov_insn_displacement, mov_insn_alignment_mask): \n+\t... these new functions.\n+\t(disp_adjust): Remove max_mov_disp field.\n+\t(sh_legitimate_index_p): Use max_mov_insn_displacement and\n+\tmov_insn_alignment_mask.\n+\t(sh_address_cost): Use max_mov_insn_displacement.\n+\n 2012-04-05  Andrew Stubbs  <ams@codesourcery.com>\n \n \t* config/arm/arm.md (arch): Add neon_onlya8 and neon_nota8."}, {"sha": "d81bcebf1e04d2c1afc2fbc0e6f2a7218a28cb8e", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 137, "deletions": 84, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b9ad23f888c646982731e8c9c797885559bdb4f/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b9ad23f888c646982731e8c9c797885559bdb4f/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=9b9ad23f888c646982731e8c9c797885559bdb4f", "patch": "@@ -302,6 +302,9 @@ static void sh_trampoline_init (rtx, tree, rtx);\n static rtx sh_trampoline_adjust_address (rtx);\n static void sh_conditional_register_usage (void);\n static bool sh_legitimate_constant_p (enum machine_mode, rtx);\n+static int mov_insn_size (enum machine_mode, bool);\n+static int max_mov_insn_displacement (enum machine_mode, bool);\n+static int mov_insn_alignment_mask (enum machine_mode, bool);\n \n static void sh_init_sync_libfuncs (void) ATTRIBUTE_UNUSED;\n \f\n@@ -3129,22 +3132,103 @@ sh_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n     }\n }\n \n-/* Compute the cost of an address.  For the SH, all valid addresses are\n-   the same cost.  Use a slightly higher cost for reg + reg addressing,\n-   since it increases pressure on r0.  */\n+/* Determine the size of the fundamental move insn that will be used\n+   for the specified mode.  */\n+\n+static inline int\n+mov_insn_size (enum machine_mode mode, bool consider_sh2a)\n+{\n+  const int mode_sz = GET_MODE_SIZE (mode);\n+\n+  if ((consider_sh2a && TARGET_SH2A_DOUBLE && mode == DFmode)\n+      || (TARGET_FMOVD && mode == DFmode))\n+    return mode_sz;\n+  else\n+    {\n+      /* The max. available mode for actual move insns is SImode.\n+\t Larger accesses will be split into multiple loads/stores.  */\n+      const int max_mov_sz = GET_MODE_SIZE (SImode);\n+      return mode_sz >= max_mov_sz ? max_mov_sz : mode_sz;\n+    }\n+}\n+\n+/* Determine the maximum possible displacement for a move insn for the\n+   specified mode.  */\n+\n+static int\n+max_mov_insn_displacement (enum machine_mode mode, bool consider_sh2a)\n+{\n+  /* The 4 byte displacement move insns are the same as the 2 byte\n+     versions but take a 12 bit displacement.  All we need to do is to\n+     scale the max. displacement value accordingly.  */\n+  const int disp_scale = consider_sh2a ? (4095 / 15) : 1;\n+\n+  /* FIXME: HImode with displacement addressing is not supported yet.\n+     Make it purposefully fail for now.  */\n+  if (mode == HImode)\n+    return 0;\n+\n+  /* SH2A supports FPU move insns with 12 bit displacements.\n+     Other variants to do not support any kind of displacements for\n+     FPU move insns.  */\n+  if (! consider_sh2a && TARGET_FPU_ANY && GET_MODE_CLASS (mode) == MODE_FLOAT)\n+    return 0;\n+  else\n+    {\n+      const int mov_insn_sz = mov_insn_size (mode, consider_sh2a);\n+      const int mode_sz = GET_MODE_SIZE (mode);\n+      int r = 15 * mov_insn_sz * disp_scale;\n+    \n+      /* If the mov insn will be split into multiple loads/stores, the\n+\t maximum possible displacement is a bit smaller.  */\n+      if (mode_sz > mov_insn_sz)\n+\tr -= mode_sz - mov_insn_sz;\n+      return r;\n+    }\n+}\n+\n+/* Determine the alignment mask for a move insn of the\n+   specified mode.  */\n+\n+static inline int\n+mov_insn_alignment_mask (enum machine_mode mode, bool consider_sh2a)\n+{\n+  const int mov_insn_sz = mov_insn_size (mode, consider_sh2a);\n+  return mov_insn_sz > 0 ? (mov_insn_sz - 1) : 0;\n+}\n+\n+/* Compute the cost of an address.  */\n \n static int\n-sh_address_cost (rtx X,\n-\t         bool speed ATTRIBUTE_UNUSED)\n+sh_address_cost (rtx x, bool speed ATTRIBUTE_UNUSED)\n {\n-  /*  SH2A supports 4 byte displacement mov insns with higher offsets.\n-      Consider those as more expensive than 2 byte insns.  */\n-  if (DISP_ADDR_P (X) && GET_MODE (X) == QImode)\n-    return DISP_ADDR_OFFSET (X) < 16 ? 0 : 1;\n+  /* 'reg + disp' addressing.  */\n+  if (DISP_ADDR_P (x))\n+    {\n+      const HOST_WIDE_INT offset = DISP_ADDR_OFFSET (x);\n+      const enum machine_mode mode = GET_MODE (x);\n+\n+      /* The displacement would fit into a 2 byte move insn.  */\n+      if (offset > 0 && offset <= max_mov_insn_displacement (mode, false))\n+\treturn 0;\n+\n+      /* The displacement would fit into a 4 byte move insn (SH2A).  */\n+      if (TARGET_SH2A\n+\t  && offset > 0 && offset <= max_mov_insn_displacement (mode, true))\n+\treturn 1;\n \n-  return (GET_CODE (X) == PLUS\n-\t  && ! CONSTANT_P (XEXP (X, 1))\n-\t  && ! TARGET_SHMEDIA ? 1 : 0);\n+      /* The displacement is probably out of range and will require extra\n+\t calculations.  */\n+      return 2;\n+    }\n+\n+  /* 'reg + reg' addressing.  Account a slightly higher cost because of \n+     increased pressure on R0.  */\n+  if (GET_CODE (x) == PLUS && ! CONSTANT_P (XEXP (x, 1))\n+      && ! TARGET_SHMEDIA)\n+    return 1;\n+\n+  return 0;\n }\n \n /* Code to expand a shift.  */\n@@ -9593,67 +9677,41 @@ sh_insn_length_adjustment (rtx insn)\n /* Return TRUE for a valid displacement for the REG+disp addressing\n    with MODE.  */\n \n-/* ??? The SH2e does not have the REG+disp addressing mode when loading values\n-   into the FRx registers.  We implement this by setting the maximum offset\n-   to zero when the value is SFmode.  This also restricts loading of SFmode\n-   values into the integer registers, but that can't be helped.  */\n-\n-/* The SH allows a displacement in a QI or HI amode, but only when the\n-   other operand is R0. GCC doesn't handle this very well, so we forgot\n-   all of that.\n-\n-   A legitimate index for a QI or HI is 0, SI can be any number 0..63,\n-   DI can be any number 0..60.  */\n-\n bool\n sh_legitimate_index_p (enum machine_mode mode, rtx op)\n {\n-  if (CONST_INT_P (op))\n-    {\n-      if (TARGET_SHMEDIA)\n-\t{\n-\t  int size;\n-\n-\t  /* Check if this is the address of an unaligned load / store.  */\n-\t  if (mode == VOIDmode)\n-\t    return CONST_OK_FOR_I06 (INTVAL (op));\n+  if (! CONST_INT_P (op))\n+    return false;\n \n-\t  size = GET_MODE_SIZE (mode);\n-\t  return (!(INTVAL (op) & (size - 1))\n-\t\t  && INTVAL (op) >= -512 * size\n-\t\t  && INTVAL (op) < 512 * size);\n-\t}\n+  if (TARGET_SHMEDIA)\n+    {\n+      int size;\n \n-      if (TARGET_SH2A)\n-\t{\n-\t  if (mode == QImode && (unsigned) INTVAL (op) < 4096)\n-\t    return true;\n-\t}\n+      /* Check if this is the address of an unaligned load / store.  */\n+      if (mode == VOIDmode)\n+\treturn CONST_OK_FOR_I06 (INTVAL (op));\n \n-      if (mode == QImode && (unsigned) INTVAL (op) < 16)\n-\treturn true;\n+      size = GET_MODE_SIZE (mode);\n+      return (!(INTVAL (op) & (size - 1))\n+\t      && INTVAL (op) >= -512 * size\n+\t      && INTVAL (op) < 512 * size);\n+    }\n+  else\n+    {\n+      const HOST_WIDE_INT offset = INTVAL (op);\n+      const int max_disp = max_mov_insn_displacement (mode, TARGET_SH2A);\n+      const int align_mask = mov_insn_alignment_mask (mode, TARGET_SH2A);\n \n-      if ((GET_MODE_SIZE (mode) == 4\n-\t   && (unsigned) INTVAL (op) < 64\n-\t   && !(INTVAL (op) & 3)\n-\t   && !(TARGET_SH2E && mode == SFmode))\n-\t  || (GET_MODE_SIZE (mode) == 4\n-\t      && (unsigned) INTVAL (op) < 16383\n-\t      && !(INTVAL (op) & 3) && TARGET_SH2A))\n-\treturn true;\n+      /* If the mode does not support any displacement always return false.\n+\t Even though an index of '0' is actually always valid, it will cause\n+\t troubles when e.g. a DFmode move is split into two SFmode moves,\n+\t where one SFmode move will have index '0' and the other move will\n+\t have index '4'.  */\n+       if (max_disp < 1)\n+\treturn false;\n \n-      if ((GET_MODE_SIZE (mode) == 8\n-\t   && (unsigned) INTVAL (op) < 60\n-\t   && !(INTVAL (op) & 3)\n-\t   && !((TARGET_SH4 || TARGET_SH2A) && mode == DFmode))\n-\t  || ((GET_MODE_SIZE (mode)==8)\n-\t      && (unsigned) INTVAL (op) < 8192\n-\t      && !(INTVAL (op) & (TARGET_SH2A_DOUBLE ? 7 : 3))\n-\t      && (TARGET_SH2A && mode == DFmode)))\n-\treturn true;\n+      return offset >= 0 && offset <= max_disp && (offset & align_mask) == 0;\n     }\n-\n-  return false;\n }\n \n /* Recognize an RTL expression that is a valid memory address for\n@@ -9811,45 +9869,41 @@ struct disp_adjust\n {\n   rtx offset_adjust;\n   rtx mov_disp;\n-  int max_mov_disp;\n };\n \n static struct disp_adjust\n-sh_find_mov_disp_adjust (int mode_sz, HOST_WIDE_INT offset)\n+sh_find_mov_disp_adjust (enum machine_mode mode, HOST_WIDE_INT offset)\n {\n-  struct disp_adjust res = { NULL_RTX, NULL_RTX, 0 };\n-\n-  /* The max. available mode for actual move insns is SImode.\n-     Larger accesses will be split into multiple loads/stores.  */\n-  const int max_mov_sz = GET_MODE_SIZE (SImode);\n-\n-  const int mov_insn_size = mode_sz >= max_mov_sz ? max_mov_sz : mode_sz;\n-  const HOST_WIDE_INT max_disp = 15 * mov_insn_size;\n-  HOST_WIDE_INT align_modifier = offset > 127 ? mov_insn_size : 0;\n+  struct disp_adjust res = { NULL_RTX, NULL_RTX };\n \n+  /* Do not try to use SH2A's large displacements here, because this would\n+     effectively disable the small displacement insns.  */\n+  const int mode_sz = GET_MODE_SIZE (mode);\n+  const int mov_insn_sz = mov_insn_size (mode, false);\n+  const int max_disp = max_mov_insn_displacement (mode, false);\n+  const int max_disp_next = max_disp + mov_insn_sz;\n+  HOST_WIDE_INT align_modifier = offset > 127 ? mov_insn_sz : 0;\n   HOST_WIDE_INT offset_adjust;\n \n   /* In some cases this actually does happen and we must check for it.  */\n-  if (mode_sz < 1 || mode_sz > 8)\n+  if (mode_sz < 1 || mode_sz > 8 || max_disp < 1)\n     return res;\n \n   /* FIXME: HImode with displacement addressing is not supported yet.\n      Make it purposefully fail for now.  */\n-  if (mov_insn_size == 2)\n+  if (mov_insn_sz == 2)\n     return res;\n \n   /* Keeps the previous behavior for QImode displacement addressing.\n      This just decides how the offset is re-based.  Removing this special\n      case will result in slightly bigger code on average, but it's not that\n      bad actually.  */\n-  if (mov_insn_size == 1)\n+  if (mov_insn_sz == 1)\n     align_modifier = 0;\n \n-  res.max_mov_disp = max_disp + mov_insn_size;\n-\n   offset_adjust = ((offset + align_modifier) & ~max_disp) - align_modifier;\n \n-  if (mode_sz + offset - offset_adjust <= res.max_mov_disp)\n+  if (mode_sz + offset - offset_adjust <= max_disp_next)\n     {\n       res.offset_adjust = GEN_INT (offset_adjust);\n       res.mov_disp = GEN_INT (offset - offset_adjust);\n@@ -9878,8 +9932,7 @@ sh_legitimize_address (rtx x, rtx oldx, enum machine_mode mode)\n   if (GET_CODE (x) == PLUS && CONST_INT_P (XEXP (x, 1))\n       && BASE_REGISTER_RTX_P (XEXP (x, 0)))\n     {\n-      const int mode_sz = GET_MODE_SIZE (mode);\n-      struct disp_adjust adj = sh_find_mov_disp_adjust (mode_sz,\n+      struct disp_adjust adj = sh_find_mov_disp_adjust (mode,\n \t\t\t\t\t\t\tINTVAL (XEXP (x, 1)));\n \n       if (adj.offset_adjust != NULL_RTX && adj.mov_disp != NULL_RTX)\n@@ -9917,7 +9970,7 @@ sh_legitimize_reload_address (rtx *p, enum machine_mode mode, int opnum,\n \t  || XEXP (*p, 0) == hard_frame_pointer_rtx))\n     {\n       const HOST_WIDE_INT offset = INTVAL (XEXP (*p, 1));\n-      struct disp_adjust adj = sh_find_mov_disp_adjust (mode_sz, offset);\n+      struct disp_adjust adj = sh_find_mov_disp_adjust (mode, offset);\n \n       if (TARGET_SH2A && mode == DFmode && (offset & 0x7))\n \t{"}]}