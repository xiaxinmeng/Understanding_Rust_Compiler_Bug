{"sha": "0f0c2cc3a17efaeeb15598e3f014ccd7b7277cdc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGYwYzJjYzNhMTdlZmFlZWIxNTU5OGUzZjAxNGNjZDdiNzI3N2NkYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-02-02T20:22:13Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-02-02T20:22:13Z"}, "message": "re PR tree-optimization/77445 (Performance drop after r239219 on coremark test)\n\n\n\tPR middle-end/77445\n\t* gcc.dg/tree-ssa/pr77445-2.c: Update testcase to check that all\n\tthreading is done.\n\t* tree-ssa-threadbackward.c (profitable_jump_thread_path): Dump\n\tstatistics of the analyzed path; allow threading for speed when\n\tany of BBs along the path are optimized for speed.\n\nFrom-SVN: r245135", "tree": {"sha": "3f4f98b251b20cf3a0e65a9a07a8fa6b8c7c5117", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f4f98b251b20cf3a0e65a9a07a8fa6b8c7c5117"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f0c2cc3a17efaeeb15598e3f014ccd7b7277cdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f0c2cc3a17efaeeb15598e3f014ccd7b7277cdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f0c2cc3a17efaeeb15598e3f014ccd7b7277cdc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f0c2cc3a17efaeeb15598e3f014ccd7b7277cdc/comments", "author": null, "committer": null, "parents": [{"sha": "b47507fe9927c6fe9750520cc1c036ca28b8b0b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b47507fe9927c6fe9750520cc1c036ca28b8b0b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b47507fe9927c6fe9750520cc1c036ca28b8b0b2"}], "stats": {"total": 46, "additions": 42, "deletions": 4}, "files": [{"sha": "07da434e16673c61c28be5cfac30bc870f1e2fd6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f0c2cc3a17efaeeb15598e3f014ccd7b7277cdc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f0c2cc3a17efaeeb15598e3f014ccd7b7277cdc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0f0c2cc3a17efaeeb15598e3f014ccd7b7277cdc", "patch": "@@ -1,3 +1,10 @@\n+2017-02-02  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR middle-end/77445\n+\t* tree-ssa-threadbackward.c (profitable_jump_thread_path): Dump\n+\tstatistics of the analyzed path; allow threading for speed when\n+\tany of BBs along the path are optimized for speed.\n+\n 2017-02-02  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR middle-end/78468"}, {"sha": "dcc69feae347193622b47f5a439a4fdddc2a7d14", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f0c2cc3a17efaeeb15598e3f014ccd7b7277cdc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f0c2cc3a17efaeeb15598e3f014ccd7b7277cdc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0f0c2cc3a17efaeeb15598e3f014ccd7b7277cdc", "patch": "@@ -1,3 +1,9 @@\n+2017-02-02  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR middle-end/77445\n+\t* gcc.dg/tree-ssa/pr77445-2.c: Update testcase to check that all\n+\tthreading is done.\n+\n 2017-02-02  Tamar Christina  <tamar.christina@arm.com>\n \n \tPR middle-end/78142"}, {"sha": "88e3b946fe4e4bf8852c34483935ba0059300446", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr77445-2.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f0c2cc3a17efaeeb15598e3f014ccd7b7277cdc/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr77445-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f0c2cc3a17efaeeb15598e3f014ccd7b7277cdc/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr77445-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr77445-2.c?ref=0f0c2cc3a17efaeeb15598e3f014ccd7b7277cdc", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-thread1-details-blocks-stats\" } */\n+/* { dg-options \"-O2 -fdump-tree-thread-details-blocks-stats\" } */\n typedef enum STATES {\n \tSTART=0,\n \tINVALID,\n@@ -121,3 +121,7 @@ enum STATES FMS( u8 **in , u32 *transitions) {\n    increase much.  */\n /* { dg-final { scan-tree-dump \"Jumps threaded: 1\\[1-9\\]\" \"thread1\" } } */\n /* { dg-final { scan-tree-dump-times \"Invalid sum\" 2 \"thread1\" } } */\n+/* { dg-final { scan-tree-dump-not \"not considered\" \"thread1\" } } */\n+/* { dg-final { scan-tree-dump-not \"not considered\" \"thread2\" } } */\n+/* { dg-final { scan-tree-dump-not \"not considered\" \"thread3\" } } */\n+/* { dg-final { scan-tree-dump-not \"not considered\" \"thread4\" } } */"}, {"sha": "24def1deed90a873b0b31cc71bc248730bb9c2d3", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f0c2cc3a17efaeeb15598e3f014ccd7b7277cdc/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f0c2cc3a17efaeeb15598e3f014ccd7b7277cdc/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=0f0c2cc3a17efaeeb15598e3f014ccd7b7277cdc", "patch": "@@ -159,6 +159,10 @@ profitable_jump_thread_path (vec<basic_block, va_gc> *&path,\n   bool threaded_through_latch = false;\n   bool multiway_branch_in_path = false;\n   bool threaded_multiway_branch = false;\n+  bool contains_hot_bb = false;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Checking profitability of path (backwards): \");\n \n   /* Count the number of instructions on the path: as these instructions\n      will have to be duplicated, we will not record the path if there\n@@ -168,6 +172,8 @@ profitable_jump_thread_path (vec<basic_block, va_gc> *&path,\n     {\n       basic_block bb = (*path)[j];\n \n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \" bb:%i\", bb->index);\n       /* Remember, blocks in the path are stored in opposite order\n \t in the PATH array.  The last entry in the array represents\n \t the block with an outgoing edge that we will redirect to the\n@@ -177,6 +183,7 @@ profitable_jump_thread_path (vec<basic_block, va_gc> *&path,\n \t branch.  */\n       if (j < path_length - 1)\n \t{\n+\t  int orig_n_insns = n_insns;\n \t  if (bb->loop_father != loop)\n \t    {\n \t      path_crosses_loops = true;\n@@ -219,6 +226,8 @@ profitable_jump_thread_path (vec<basic_block, va_gc> *&path,\n \t\t}\n \t    }\n \n+\t  if (!contains_hot_bb && speed_p)\n+\t    contains_hot_bb |= optimize_bb_for_speed_p (bb);\n \t  for (gsi = gsi_after_labels (bb);\n \t       !gsi_end_p (gsi);\n \t       gsi_next_nondebug (&gsi))\n@@ -229,8 +238,10 @@ profitable_jump_thread_path (vec<basic_block, va_gc> *&path,\n \t\t  && !(gimple_code (stmt) == GIMPLE_ASSIGN\n \t\t       && gimple_assign_rhs_code (stmt) == ASSERT_EXPR)\n \t\t  && !is_gimple_debug (stmt))\n-\t        n_insns += estimate_num_insns (stmt, &eni_size_weights);\n+\t\tn_insns += estimate_num_insns (stmt, &eni_size_weights);\n \t    }\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \" (%i insns)\", n_insns-orig_n_insns);\n \n \t  /* We do not look at the block with the threaded branch\n \t     in this loop.  So if any block with a last statement that\n@@ -264,7 +275,13 @@ profitable_jump_thread_path (vec<basic_block, va_gc> *&path,\n      last block in the threading path.  So don't count it against our\n      statement count.  */\n \n-  n_insns-= estimate_num_insns (stmt, &eni_size_weights);\n+  int stmt_insns = estimate_num_insns (stmt, &eni_size_weights);\n+  n_insns-= stmt_insns;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"\\n  Control statement insns: %i\\n\"\n+\t     \"  Overall: %i insns\\n\",\n+\t     stmt_insns, n_insns);\n \n   /* We have found a constant value for ARG.  For GIMPLE_SWITCH\n      and GIMPLE_GOTO, we use it as-is.  However, for a GIMPLE_COND\n@@ -311,7 +328,11 @@ profitable_jump_thread_path (vec<basic_block, va_gc> *&path,\n       return NULL;\n     }\n \n-  if (speed_p && optimize_edge_for_speed_p (taken_edge))\n+  /* Threading is profitable if the path duplicated is hot but also\n+     in a case we separate cold path from hot path and permit optimization\n+     of the hot path later.  Be on the agressive side here. In some testcases,\n+     as in PR 78407 this leads to noticeable improvements.  */\n+  if (speed_p && (optimize_edge_for_speed_p (taken_edge) || contains_hot_bb))\n     {\n       if (n_insns >= PARAM_VALUE (PARAM_MAX_FSM_THREAD_PATH_INSNS))\n \t{"}]}