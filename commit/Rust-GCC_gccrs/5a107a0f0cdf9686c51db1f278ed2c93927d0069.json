{"sha": "5a107a0f0cdf9686c51db1f278ed2c93927d0069", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWExMDdhMGYwY2RmOTY4NmM1MWRiMWYyNzhlZDJjOTM5MjdkMDA2OQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2013-05-07T19:29:05Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2013-05-07T19:29:05Z"}, "message": "ira.c (update_equiv_regs): Add insn having equiv memory even if it is not lhs of the insn.\n\n2013-05-07  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* ira.c (update_equiv_regs): Add insn having equiv memory even if\n\tit is not lhs of the insn.\n\t(setup_reg_equiv): Remove insn having equiv memory which it is not\n\tlhs of the insn.\n\t* lra-constraints.c (process_address): Try to improve generation\n\tcode for address base + disp.\n\t(lra_constraints): Make correct the code for checking insn setting\n\tup backward equivalence.  Remove insn only if it is in the init\n\tinsn list.\n\t* lra-eliminations.c (update_reg_eliminate): Change return value.\n\t(lra_eliminate): Use the result.\n\nFrom-SVN: r198695", "tree": {"sha": "28fa1b57a153d5c79ac7a0f108dad081b3a9ddf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28fa1b57a153d5c79ac7a0f108dad081b3a9ddf8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a107a0f0cdf9686c51db1f278ed2c93927d0069", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a107a0f0cdf9686c51db1f278ed2c93927d0069", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a107a0f0cdf9686c51db1f278ed2c93927d0069", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a107a0f0cdf9686c51db1f278ed2c93927d0069/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3f5783ea1b0ca56bc18fa90f602a7a0f825b379a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f5783ea1b0ca56bc18fa90f602a7a0f825b379a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f5783ea1b0ca56bc18fa90f602a7a0f825b379a"}], "stats": {"total": 155, "additions": 116, "deletions": 39}, "files": [{"sha": "6cc509d2569ff2a370d9632133b3f475402a8811", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a107a0f0cdf9686c51db1f278ed2c93927d0069/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a107a0f0cdf9686c51db1f278ed2c93927d0069/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5a107a0f0cdf9686c51db1f278ed2c93927d0069", "patch": "@@ -1,3 +1,17 @@\n+2013-05-07  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* ira.c (update_equiv_regs): Add insn having equiv memory even if\n+\tit is not lhs of the insn.\n+\t(setup_reg_equiv): Remove insn having equiv memory which it is not\n+\tlhs of the insn.\n+\t* lra-constraints.c (process_address): Try to improve generation\n+\tcode for address base + disp.\n+\t(lra_constraints): Make correct the code for checking insn setting\n+\tup backward equivalence.  Remove insn only if it is in the init\n+\tinsn list.\n+\t* lra-eliminations.c (update_reg_eliminate): Change return value.\n+\t(lra_eliminate): Use the result.\n+\n 2013-05-07  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/sse.md (ssescalarnummask): New mode attribute."}, {"sha": "a8631c96b4f04aaeaf37dc3e2bbd4f0aac285827", "filename": "gcc/ira.c", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a107a0f0cdf9686c51db1f278ed2c93927d0069/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a107a0f0cdf9686c51db1f278ed2c93927d0069/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=5a107a0f0cdf9686c51db1f278ed2c93927d0069", "patch": "@@ -2188,7 +2188,7 @@ ira_update_equiv_info_by_shuffle_insn (int to_regno, int from_regno, rtx insns)\n       && (! ira_reg_equiv[to_regno].defined_p\n \t  || ((x = ira_reg_equiv[to_regno].memory) != NULL_RTX\n \t      && ! MEM_READONLY_P (x))))\n-      return;\n+    return;\n   insn = insns;\n   if (NEXT_INSN (insn) != NULL_RTX)\n     {\n@@ -2971,8 +2971,12 @@ update_equiv_regs (void)\n \t\t register.  */\n \t      reg_equiv[regno].is_arg_equivalence = 1;\n \n-\t      /* Record for reload that this is an equivalencing insn.  */\n-\t      if (rtx_equal_p (src, XEXP (note, 0)))\n+\t      /* The insn result can have equivalence memory although\n+\t\t the equivalence is not set up by the insn.  We add\n+\t\t this insn to init insns as it is a flag for now that\n+\t\t regno has an equivalence.  We will remove the insn\n+\t\t from init insn list later.  */\n+\t      if (rtx_equal_p (src, XEXP (note, 0)) || MEM_P (XEXP (note, 0)))\n \t\tira_reg_equiv[regno].init_insns\n \t\t  = gen_rtx_INSN_LIST (VOIDmode, insn,\n \t\t\t\t       ira_reg_equiv[regno].init_insns);\n@@ -3368,11 +3372,14 @@ static void\n setup_reg_equiv (void)\n {\n   int i;\n-  rtx elem, insn, set, x;\n+  rtx elem, prev_elem, next_elem, insn, set, x;\n \n   for (i = FIRST_PSEUDO_REGISTER; i < ira_reg_equiv_len; i++)\n-    for (elem = ira_reg_equiv[i].init_insns; elem; elem = XEXP (elem, 1))\n+    for (prev_elem = NULL, elem = ira_reg_equiv[i].init_insns;\n+\t elem;\n+\t prev_elem = elem, elem = next_elem)\n       {\n+\tnext_elem = XEXP (elem, 1);\n \tinsn = XEXP (elem, 0);\n \tset = single_set (insn);\n \t\n@@ -3381,7 +3388,22 @@ setup_reg_equiv (void)\n \tif (set != 0 && (REG_P (SET_DEST (set)) || REG_P (SET_SRC (set))))\n \t  {\n \t    if ((x = find_reg_note (insn, REG_EQUIV, NULL_RTX)) != NULL)\n-\t      x = XEXP (x, 0);\n+\t      {\n+\t\tx = XEXP (x, 0);\n+\t\tif (REG_P (SET_DEST (set))\n+\t\t    && REGNO (SET_DEST (set)) == (unsigned int) i\n+\t\t    && ! rtx_equal_p (SET_SRC (set), x) && MEM_P (x))\n+\t\t  {\n+\t\t    /* This insn reporting the equivalence but\n+\t\t       actually not setting it.  Remove it from the\n+\t\t       list.  */\n+\t\t    if (prev_elem == NULL)\n+\t\t      ira_reg_equiv[i].init_insns = next_elem;\n+\t\t    else\n+\t\t      XEXP (prev_elem, 1) = next_elem;\n+\t\t    elem = prev_elem;\n+\t\t  }\n+\t      }\n \t    else if (REG_P (SET_DEST (set))\n \t\t     && REGNO (SET_DEST (set)) == (unsigned int) i)\n \t      x = SET_SRC (set);"}, {"sha": "038acd72148c70959f05c44447e0c4ade610bd54", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 65, "deletions": 24, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a107a0f0cdf9686c51db1f278ed2c93927d0069/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a107a0f0cdf9686c51db1f278ed2c93927d0069/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=5a107a0f0cdf9686c51db1f278ed2c93927d0069", "patch": "@@ -1680,14 +1680,13 @@ process_alt_operands (int only_alternative)\n \n \t\tcase 'G':\n \t\tcase 'H':\n-\t\t  if (GET_CODE (op) == CONST_DOUBLE\n+\t\t  if (CONST_DOUBLE_AS_FLOAT_P (op)\n \t\t      && CONST_DOUBLE_OK_FOR_CONSTRAINT_P (op, c, p))\n \t\t    win = true;\n \t\t  break;\n \n \t\tcase 's':\n-\t\t  if (CONST_INT_P (op)\n-\t\t      || (GET_CODE (op) == CONST_DOUBLE && mode == VOIDmode))\n+\t\t  if (CONST_SCALAR_INT_P (op))\n \t\t    break;\n \n \t\tcase 'i':\n@@ -1696,8 +1695,7 @@ process_alt_operands (int only_alternative)\n \t\t  break;\n \n \t\tcase 'n':\n-\t\t  if (CONST_INT_P (op)\n-\t\t      || (GET_CODE (op) == CONST_DOUBLE && mode == VOIDmode))\n+\t\t  if (CONST_SCALAR_INT_P (op))\n \t\t    win = true;\n \t\t  break;\n \n@@ -2411,18 +2409,18 @@ equiv_address_substitution (struct address_info *ad)\n /* Major function to make reloads for an address in operand NOP.\n    The supported cases are:\n \n-   1) an address that existed before LRA started, at which point it must\n-      have been valid.  These addresses are subject to elimination and\n-      may have become invalid due to the elimination offset being out\n-      of range.\n+   1) an address that existed before LRA started, at which point it\n+   must have been valid.  These addresses are subject to elimination\n+   and may have become invalid due to the elimination offset being out\n+   of range.\n \n-   2) an address created by forcing a constant to memory (force_const_to_mem).\n-      The initial form of these addresses might not be valid, and it is this\n-      function's job to make them valid.\n+   2) an address created by forcing a constant to memory\n+   (force_const_to_mem).  The initial form of these addresses might\n+   not be valid, and it is this function's job to make them valid.\n \n    3) a frame address formed from a register and a (possibly zero)\n-      constant offset.  As above, these addresses might not be valid\n-      and this function must make them so.\n+   constant offset.  As above, these addresses might not be valid and\n+   this function must make them so.\n \n    Add reloads to the lists *BEFORE and *AFTER.  We might need to add\n    reloads to *AFTER because of inc/dec, {pre, post} modify in the\n@@ -2478,11 +2476,11 @@ process_address (int nop, rtx *before, rtx *after)\n   /* There are three cases where the shape of *AD.INNER may now be invalid:\n \n      1) the original address was valid, but either elimination or\n-\tequiv_address_substitution was applied and that made\n-\tthe address invalid.\n+     equiv_address_substitution was applied and that made\n+     the address invalid.\n \n      2) the address is an invalid symbolic address created by\n-\tforce_const_to_mem.\n+     force_const_to_mem.\n \n      3) the address is a frame address with an invalid offset.\n \n@@ -2564,13 +2562,43 @@ process_address (int nop, rtx *before, rtx *after)\n     }\n   else if (ad.index == NULL)\n     {\n+      int regno;\n+      enum reg_class cl;\n+      rtx set, insns, last_insn;\n       /* base + disp => new base, cases (1) and (3) above.  */\n       /* Another option would be to reload the displacement into an\n \t index register.  However, postreload has code to optimize\n \t address reloads that have the same base and different\n \t displacements, so reloading into an index register would\n \t not necessarily be a win.  */\n+      start_sequence ();\n       new_reg = base_plus_disp_to_reg (&ad);\n+      insns = get_insns ();\n+      last_insn = get_last_insn ();\n+      /* If we generated at least two insns, try last insn source as\n+\t an address.  If we succeed, we generate one less insn.  */\n+      if (last_insn != insns && (set = single_set (last_insn)) != NULL_RTX\n+\t  && GET_CODE (SET_SRC (set)) == PLUS\n+\t  && REG_P (XEXP (SET_SRC (set), 0))\n+\t  && CONSTANT_P (XEXP (SET_SRC (set), 1)))\n+\t{\n+\t  *ad.inner = SET_SRC (set);\n+\t  if (valid_address_p (ad.mode, *ad.outer, ad.as))\n+\t    {\n+\t      *ad.base_term = XEXP (SET_SRC (set), 0);\n+\t      *ad.disp_term = XEXP (SET_SRC (set), 1);\n+\t      cl = base_reg_class (ad.mode, ad.as, ad.base_outer_code,\n+\t\t\t\t   get_index_code (&ad));\n+\t      regno = REGNO (*ad.base_term);\n+\t      if (regno >= FIRST_PSEUDO_REGISTER\n+\t\t  && cl != lra_get_allocno_class (regno))\n+\t\tchange_class (regno, cl, \"      Change\", true);\n+\t      new_reg = SET_SRC (set);\n+\t      delete_insns_since (PREV_INSN (last_insn));\n+\t    }\n+\t}\n+      end_sequence ();\n+      emit_insn (insns);\n       *ad.inner = new_reg;\n     }\n   else\n@@ -3560,7 +3588,7 @@ lra_constraints (bool first_p)\n \telse if ((x = get_equiv_substitution (reg)) != reg)\n \t  {\n \t    bool pseudo_p = contains_reg_p (x, false, false);\n-\t    rtx set, insn;\n+\t    rtx set, insns;\n \n \t    /* After RTL transformation, we can not guarantee that\n \t       pseudo in the substitution was not reloaded which might\n@@ -3592,11 +3620,12 @@ lra_constraints (bool first_p)\n \t\t   removed the insn.  When the equiv can be a\n \t\t   constant, the right hand side of the init insn can\n \t\t   be a pseudo.  */\n-\t\t|| (! ((insn = ira_reg_equiv[i].init_insns) != NULL_RTX\n-\t\t       && INSN_P (insn)\n-\t\t       && (set = single_set (insn)) != NULL_RTX\n-\t\t       && REG_P (SET_DEST (set))\n-\t\t       && (int) REGNO (SET_DEST (set)) == i)\n+\t\t|| (! ((insns = ira_reg_equiv[i].init_insns) != NULL_RTX\n+\t\t       && INSN_P (XEXP (insns, 0))\n+\t\t       && XEXP (insns, 1) == NULL_RTX\n+\t\t       && (set = single_set (XEXP (insns, 0))) != NULL_RTX\n+\t\t       && REG_P (SET_SRC (set))\n+\t\t       && (int) REGNO (SET_SRC (set)) == i)\n \t\t    && init_insn_rhs_dead_pseudo_p (i))\n \t\t/* Prevent access beyond equivalent memory for\n \t\t   paradoxical subregs.  */\n@@ -3669,11 +3698,23 @@ lra_constraints (bool first_p)\n \t\tdest_reg = SUBREG_REG (dest_reg);\n \t      if ((REG_P (dest_reg)\n \t\t   && (x = get_equiv_substitution (dest_reg)) != dest_reg\n+\t\t   /* Check that this is actually an insn setting up\n+\t\t      the equivalence.  */\n+\t\t   && (in_list_p (curr_insn,\n+\t\t\t\t  ira_reg_equiv\n+\t\t\t\t  [REGNO (dest_reg)].init_insns)\n+\t\t       /* Init insns may contain not all insns setting\n+\t\t\t  up equivalence as we have live range\n+\t\t\t  splitting.  So here we use another condition\n+\t\t\t  to check insn setting up the equivalence\n+\t\t\t  which should be removed, e.g. in case when\n+\t\t\t  the equivalence is a constant.  */\n+\t\t       || ! MEM_P (x))\n \t\t   /* Remove insns which set up a pseudo whose value\n \t\t      can not be changed.  Such insns might be not in\n \t\t      init_insns because we don't update equiv data\n \t\t      during insn transformations.\n-\n+\t\t      \n \t\t      As an example, let suppose that a pseudo got\n \t\t      hard register and on the 1st pass was not\n \t\t      changed to equivalent constant.  We generate an"}, {"sha": "a59ab6eaccaa4c8730391dba3a0d8d55e1ea7391", "filename": "gcc/lra-eliminations.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a107a0f0cdf9686c51db1f278ed2c93927d0069/gcc%2Flra-eliminations.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a107a0f0cdf9686c51db1f278ed2c93927d0069/gcc%2Flra-eliminations.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-eliminations.c?ref=5a107a0f0cdf9686c51db1f278ed2c93927d0069", "patch": "@@ -1042,11 +1042,12 @@ spill_pseudos (HARD_REG_SET set)\n    registers.  Spill pseudos assigned to registers which became\n    uneliminable, update LRA_NO_ALLOC_REGS and ELIMINABLE_REG_SET.  Add\n    insns to INSNS_WITH_CHANGED_OFFSETS containing eliminable hard\n-   registers whose offsets should be changed.  */\n-static void\n+   registers whose offsets should be changed.  Return true if any\n+   elimination offset changed.  */\n+static bool\n update_reg_eliminate (bitmap insns_with_changed_offsets)\n {\n-  bool prev;\n+  bool prev, result;\n   struct elim_table *ep, *ep1;\n   HARD_REG_SET temp_hard_reg_set;\n \n@@ -1122,6 +1123,7 @@ update_reg_eliminate (bitmap insns_with_changed_offsets)\n   AND_COMPL_HARD_REG_SET (eliminable_regset, temp_hard_reg_set);\n   spill_pseudos (temp_hard_reg_set);\n   setup_elimination_map ();\n+  result = false;\n   for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n     if (elimination_map[ep->from] == ep && ep->previous_offset != ep->offset)\n       {\n@@ -1132,7 +1134,9 @@ update_reg_eliminate (bitmap insns_with_changed_offsets)\n \t   changed.  */\n \tlra_update_reg_val_offset (lra_reg_info[ep->from].val,\n \t\t\t\t   ep->offset - ep->previous_offset);\n+\tresult = true;\n       }\n+  return result;\n }\n \n /* Initialize the table of hard registers to eliminate.\n@@ -1273,12 +1277,8 @@ lra_eliminate (bool final_p)\n \t  bitmap_ior_into (&insns_with_changed_offsets,\n \t\t\t   &lra_reg_info[ep->from].insn_bitmap);\n     }\n-  else\n-    {\n-      update_reg_eliminate (&insns_with_changed_offsets);\n-      if (bitmap_empty_p (&insns_with_changed_offsets))\n-\tgoto lra_eliminate_done;\n-    }\n+  else if (! update_reg_eliminate (&insns_with_changed_offsets))\n+    goto lra_eliminate_done;\n   if (lra_dump_file != NULL)\n     {\n       fprintf (lra_dump_file, \"New elimination table:\\n\");"}]}