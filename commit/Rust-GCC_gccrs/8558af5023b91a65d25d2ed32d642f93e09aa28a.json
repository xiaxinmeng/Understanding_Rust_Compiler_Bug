{"sha": "8558af5023b91a65d25d2ed32d642f93e09aa28a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODU1OGFmNTAyM2I5MWE2NWQyNWQyZWQzMmQ2NDJmOTNlMDlhYTI4YQ==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2019-01-19T20:06:41Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2019-01-19T20:06:41Z"}, "message": "re PR fortran/56789 (Handling of contiguous dummy arguments)\n\n2018-01-19  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\tPaul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/56789\n\t* trans-expr.c (gfc_conv_procedure_call): Call\n\tgfc_conv_subref_array_arg if the formal arg is contiguous\n\tand the actual arg may not be.\n\n2018-01-19  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\tPaul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/56789\n\t* gfortran.dg/contiguous_3.f90: Make code compilant.  Remove\n\tscan-tree tests that fail with patch.\n\t* gfortran.dg/contiguous_8.f90: New test.\n\n\nCo-Authored-By: Paul Thomas <pault@gcc.gnu.org>\n\nFrom-SVN: r268096", "tree": {"sha": "1bc72cd5e13ecbb36eac61524de60cda8d456236", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1bc72cd5e13ecbb36eac61524de60cda8d456236"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8558af5023b91a65d25d2ed32d642f93e09aa28a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8558af5023b91a65d25d2ed32d642f93e09aa28a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8558af5023b91a65d25d2ed32d642f93e09aa28a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8558af5023b91a65d25d2ed32d642f93e09aa28a/comments", "author": null, "committer": null, "parents": [{"sha": "e76c8e5612bc29569d90b3926eb761934251d97d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e76c8e5612bc29569d90b3926eb761934251d97d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e76c8e5612bc29569d90b3926eb761934251d97d"}], "stats": {"total": 96, "additions": 90, "deletions": 6}, "files": [{"sha": "c55cd7515f3015dcd4f170f3a6f7b917d326cdbb", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8558af5023b91a65d25d2ed32d642f93e09aa28a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8558af5023b91a65d25d2ed32d642f93e09aa28a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8558af5023b91a65d25d2ed32d642f93e09aa28a", "patch": "@@ -1,3 +1,11 @@\n+2018-01-19  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\tPaul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/56789\n+\t* trans-expr.c (gfc_conv_procedure_call): Call\n+\tgfc_conv_subref_array_arg if the formal arg is contiguous\n+\tand the actual arg may not be.\n+\n 2019-01-17  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/88871"}, {"sha": "3238e7cb582fa55d5749b887c3bd1a13fb6e78ab", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8558af5023b91a65d25d2ed32d642f93e09aa28a/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8558af5023b91a65d25d2ed32d642f93e09aa28a/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=8558af5023b91a65d25d2ed32d642f93e09aa28a", "patch": "@@ -5828,6 +5828,13 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t\t\t     INTENT_IN,\n \t\t\t\t\t     fsym && fsym->attr.pointer);\n \t\t}\n+\t      else if (fsym && fsym->attr.contiguous\n+\t\t       && !gfc_is_simply_contiguous (e, false, true))\n+\t\t{\n+\t\t  gfc_conv_subref_array_arg (&parmse, e, nodesc_arg,\n+\t\t\t\tfsym ? fsym->attr.intent : INTENT_INOUT,\n+\t\t\t\tfsym && fsym->attr.pointer);\n+\t\t}\n \t      else\n \t\tgfc_conv_array_parameter (&parmse, e, nodesc_arg, fsym,\n \t\t\t\t\t  sym->name, NULL);"}, {"sha": "286614dff12b913b6d061b32339203ea3673791b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8558af5023b91a65d25d2ed32d642f93e09aa28a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8558af5023b91a65d25d2ed32d642f93e09aa28a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8558af5023b91a65d25d2ed32d642f93e09aa28a", "patch": "@@ -1,3 +1,11 @@\n+2018-01-19  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\tPaul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/56789\n+\t* gfortran.dg/contiguous_3.f90: Make code compilant.  Remove\n+\tscan-tree tests that fail with patch.\n+\t* gfortran.dg/contiguous_8.f90: New test.\n+\n 2019-01-19  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* gfortran.dg/loop_versioning_1.f90: Bump the number of identified"}, {"sha": "724ec83ed1089f909480347af9252e5e28b407a6", "filename": "gcc/testsuite/gfortran.dg/contiguous_3.f90", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8558af5023b91a65d25d2ed32d642f93e09aa28a/gcc%2Ftestsuite%2Fgfortran.dg%2Fcontiguous_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8558af5023b91a65d25d2ed32d642f93e09aa28a/gcc%2Ftestsuite%2Fgfortran.dg%2Fcontiguous_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcontiguous_3.f90?ref=8558af5023b91a65d25d2ed32d642f93e09aa28a", "patch": "@@ -8,6 +8,8 @@\n \n subroutine test1(a,b)\n   integer, pointer, contiguous :: test1_a(:)\n+  integer, target, dimension(3) :: aa\n+  test1_a => aa\n   call foo(test1_a)\n   call foo(test1_a(::1))\n   call foo(test1_a(::2))\n@@ -56,9 +58,3 @@ subroutine bar(x)\n   end subroutine bar\n end subroutine test3\n \n-! Once for test1 (third call), once for test3 (second call)\n-! { dg-final { scan-tree-dump-times \"data = origptr\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"_gfortran_internal_pack .&parm\" 2 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"_gfortran_internal_unpack .&parm\" 2 \"original\" } }\n-\n-"}, {"sha": "d362f1e381d2aa6e3bcdf4edb0f62243fb967351", "filename": "gcc/testsuite/gfortran.dg/contiguous_8.f90", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8558af5023b91a65d25d2ed32d642f93e09aa28a/gcc%2Ftestsuite%2Fgfortran.dg%2Fcontiguous_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8558af5023b91a65d25d2ed32d642f93e09aa28a/gcc%2Ftestsuite%2Fgfortran.dg%2Fcontiguous_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcontiguous_8.f90?ref=8558af5023b91a65d25d2ed32d642f93e09aa28a", "patch": "@@ -0,0 +1,65 @@\n+! { dg-do  run }\n+! PR 56789 - packing / unpacking of contiguous arguments\n+! did not happen.\n+\n+module my_module\n+  implicit none\n+contains\n+  subroutine cont_arg(a)\n+    real, contiguous :: a(:,:)\n+    integer :: i,j\n+    do j=1,size(a,2)\n+       do i=1,size(a,1)\n+          a(i,j) = i+10*j\n+       end do\n+    end do\n+  end subroutine cont_arg\n+  subroutine cont_pointer_arg (a)\n+    integer, pointer, contiguous :: a(:)\n+    call assumed_size(a)\n+    call assumed_size(a(::1))\n+    call assumed_size_2(a(::2))\n+  end subroutine cont_pointer_arg\n+\n+  subroutine assumed_size(y)\n+    integer, dimension(*) :: y\n+    if (y(2) /= 2 .or. y(3) /= 3 .or. y(4) /= 4 .or. y(5) /= 5 .or. y(6) /= 6) &\n+            stop 2\n+  end subroutine assumed_size\n+\n+  subroutine assumed_size_2(y)\n+    integer, dimension(*) :: y\n+    if (y(1) /= 1 .or. y(2) /= 3 .or. y(3) /= 5) stop 3\n+  end subroutine assumed_size_2\n+\n+  subroutine cont_assumed_shape(x)\n+    integer, dimension(:), contiguous :: x\n+    if (size(x,1) == 8) then\n+       if (any(x /= [1,2,3,4,5,6,7,8])) stop 4\n+    else\n+       if (any(x /= [1,3,5,7])) stop 5\n+    end if\n+  end subroutine cont_assumed_shape\n+end module my_module\n+\n+program main\n+  use my_module\n+  implicit none\n+  real, dimension(5,5) :: a\n+  real, dimension(5,5) :: res\n+  integer, dimension(8), target :: t\n+  integer, dimension(:), pointer, contiguous :: p\n+  res = reshape([11., 1.,12., 1.,13.,&\n+                  1., 1., 1., 1., 1.,&\n+                 21., 1.,22., 1.,23.,&\n+                  1., 1., 1., 1., 1.,&\n+                 31., 1.,32., 1., 33.], shape(res))\n+  a = 1.\n+  call cont_arg(a(1:5:2,1:5:2))\n+  if (any(a /= res)) stop 1\n+  t = [1,2,3,4,5,6,7,8]\n+  p => t\n+  call cont_pointer_arg(p)\n+  call cont_assumed_shape (t)\n+  call cont_assumed_shape (t(::2))\n+end program main"}]}