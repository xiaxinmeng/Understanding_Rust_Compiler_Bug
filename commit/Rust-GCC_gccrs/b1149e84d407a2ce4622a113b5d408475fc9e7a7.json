{"sha": "b1149e84d407a2ce4622a113b5d408475fc9e7a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjExNDllODRkNDA3YTJjZTQ2MjJhMTEzYjVkNDA4NDc1ZmM5ZTdhNw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2013-10-23T13:54:48Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-10-23T13:54:48Z"}, "message": "tree-ssa-threadedge.c (thread_across_edge): Do not allow threading through joiner blocks with abnormal outgoing edges.\n\n\t* tree-ssa-threadedge.c (thread_across_edge): Do not allow threading\n\tthrough joiner blocks with abnormal outgoing edges.\n\n\t* tree-ssa-threadupdate.c (thread_block_1): Renamed from thread_block.\n\tAdd parameter JOINERS, to allow/disallow threading through joiner\n\tblocks.\n\t(thread_block): New.  Call thread_block_1.\n\t(mark_threaded_blocks): Remove code to filter out certain cases\n\tof threading through joiner blocks.\n\t(thread_through_all_blocks): Document how we can have a dangling\n\tedge AUX field and clear it.\n\nFrom-SVN: r203975", "tree": {"sha": "f3147baa998ae0dfcc8896df58168d9473d4f4c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3147baa998ae0dfcc8896df58168d9473d4f4c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1149e84d407a2ce4622a113b5d408475fc9e7a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1149e84d407a2ce4622a113b5d408475fc9e7a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1149e84d407a2ce4622a113b5d408475fc9e7a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1149e84d407a2ce4622a113b5d408475fc9e7a7/comments", "author": null, "committer": null, "parents": [{"sha": "c9edbc5fa1c3812f834a625afae0b09c652dc1fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9edbc5fa1c3812f834a625afae0b09c652dc1fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9edbc5fa1c3812f834a625afae0b09c652dc1fa"}], "stats": {"total": 143, "additions": 92, "deletions": 51}, "files": [{"sha": "acd6620a048c0a31c645425666590f954afec850", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1149e84d407a2ce4622a113b5d408475fc9e7a7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1149e84d407a2ce4622a113b5d408475fc9e7a7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b1149e84d407a2ce4622a113b5d408475fc9e7a7", "patch": "@@ -1,3 +1,17 @@\n+2013-10-23  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-threadedge.c (thread_across_edge): Do not allow threading\n+\tthrough joiner blocks with abnormal outgoing edges.\n+\n+\t* tree-ssa-threadupdate.c (thread_block_1): Renamed from thread_block.\n+\tAdd parameter JOINERS, to allow/disallow threading through joiner\n+\tblocks.\n+\t(thread_block): New.  Call thread_block_1.\n+\t(mark_threaded_blocks): Remove code to filter out certain cases\n+\tof threading through joiner blocks.\n+\t(thread_through_all_blocks): Document how we can have a dangling\n+\tedge AUX field and clear it.\n+\n 2013-10-23  Ian Lance Taylor  <iant@google.com>\n \n \t* doc/invoke.texi (Option Summary): Remove -fno-default-inline."}, {"sha": "810908b40dd1d40bf070c5d4eecf8863ae841d75", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1149e84d407a2ce4622a113b5d408475fc9e7a7/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1149e84d407a2ce4622a113b5d408475fc9e7a7/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=b1149e84d407a2ce4622a113b5d408475fc9e7a7", "patch": "@@ -1040,6 +1040,16 @@ thread_across_edge (gimple dummy_cond,\n     edge_iterator ei;\n     bool found;\n \n+    /* If E->dest has abnormal outgoing edges, then there's no guarantee\n+       we can safely redirect any of the edges.  Just punt those cases.  */\n+    FOR_EACH_EDGE (taken_edge, ei, e->dest->succs)\n+      if (taken_edge->flags & EDGE_ABNORMAL)\n+\t{\n+\t  remove_temporary_equivalences (stack);\n+\t  BITMAP_FREE (visited);\n+\t  return;\n+\t}\n+\n     /* Look at each successor of E->dest to see if we can thread through it.  */\n     FOR_EACH_EDGE (taken_edge, ei, e->dest->succs)\n       {"}, {"sha": "10271919786b5f444a4a9f97f8ef021718746acb", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 68, "deletions": 51, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1149e84d407a2ce4622a113b5d408475fc9e7a7/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1149e84d407a2ce4622a113b5d408475fc9e7a7/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=b1149e84d407a2ce4622a113b5d408475fc9e7a7", "patch": "@@ -616,10 +616,12 @@ redirection_block_p (basic_block bb)\n    the appropriate duplicate of BB.\n \n    If NOLOOP_ONLY is true, we only perform the threading as long as it\n-   does not affect the structure of the loops in a nontrivial way.  */\n+   does not affect the structure of the loops in a nontrivial way. \n+\n+   If JOINERS is true, then thread through joiner blocks as well.  */\n \n static bool\n-thread_block (basic_block bb, bool noloop_only)\n+thread_block_1 (basic_block bb, bool noloop_only, bool joiners)\n {\n   /* E is an incoming edge into BB that we may or may not want to\n      redirect to a duplicate of BB.  */\n@@ -642,7 +644,9 @@ thread_block (basic_block bb, bool noloop_only)\n       e = loop_latch_edge (loop);\n       vec<jump_thread_edge *> *path = THREAD_PATH (e);\n \n-      if (path)\n+      if (path\n+\t  && (((*path)[1]->type == EDGE_COPY_SRC_JOINER_BLOCK && joiners)\n+\t      || ((*path)[1]->type == EDGE_COPY_SRC_BLOCK && !joiners)))\n \t{\n \t  for (unsigned int i = 1; i < path->length (); i++)\n \t    {\n@@ -666,6 +670,11 @@ thread_block (basic_block bb, bool noloop_only)\n \tcontinue;\n \n       vec<jump_thread_edge *> *path = THREAD_PATH (e);\n+\n+      if (((*path)[1]->type == EDGE_COPY_SRC_JOINER_BLOCK && !joiners)\n+\t  || ((*path)[1]->type == EDGE_COPY_SRC_BLOCK && joiners))\n+\tcontinue;\n+\n       e2 = path->last ()->e;\n       if (!e2 || noloop_only)\n \t{\n@@ -762,6 +771,24 @@ thread_block (basic_block bb, bool noloop_only)\n   return local_info.jumps_threaded;\n }\n \n+/* Wrapper for thread_block_1 so that we can first handle jump\n+   thread paths which do not involve copying joiner blocks, then\n+   handle jump thread paths which have joiner blocks.\n+\n+   By doing things this way we can be as aggressive as possible and\n+   not worry that copying a joiner block will create a jump threading\n+   opportunity.  */\n+  \n+static bool\n+thread_block (basic_block bb, bool noloop_only)\n+{\n+  bool retval;\n+  retval = thread_block_1 (bb, noloop_only, false);\n+  retval |= thread_block_1 (bb, noloop_only, true);\n+  return retval;\n+}\n+\n+\n /* Threads edge E through E->dest to the edge THREAD_TARGET (E).  Returns the\n    copy of E->dest created during threading, or E->dest if it was not necessary\n    to copy it (E is its single predecessor).  */\n@@ -1240,57 +1267,14 @@ mark_threaded_blocks (bitmap threaded_blocks)\n   edge e;\n   edge_iterator ei;\n \n-  /* It is possible to have jump threads in which one is a subpath\n-     of the other.  ie, (A, B), (B, C), (C, D) where B is a joiner\n-     block and (B, C), (C, D) where no joiner block exists.\n-\n-     When this occurs ignore the jump thread request with the joiner\n-     block.  It's totally subsumed by the simpler jump thread request.\n-\n-     This results in less block copying, simpler CFGs.  More importantly,\n-     when we duplicate the joiner block, B, in this case we will create\n-     a new threading opportunity that we wouldn't be able to optimize\n-     until the next jump threading iteration.\n-\n-     So first convert the jump thread requests which do not require a\n-     joiner block.  */\n+  /* Move the jump threading requests from PATHS to each edge\n+     which starts a jump thread path.  */\n   for (i = 0; i < paths.length (); i++)\n     {\n       vec<jump_thread_edge *> *path = paths[i];\n-\n-      if ((*path)[1]->type != EDGE_COPY_SRC_JOINER_BLOCK)\n-\t{\n-\t  edge e = (*path)[0]->e;\n-\t  e->aux = (void *)path;\n-\t  bitmap_set_bit (tmp, e->dest->index);\n-\t}\n-    }\n-\n-  /* Now iterate again, converting cases where we want to thread\n-     through a joiner block, but only if no other edge on the path\n-     already has a jump thread attached to it.  */\n-  for (i = 0; i < paths.length (); i++)\n-    {\n-      vec<jump_thread_edge *> *path = paths[i];\n-\n-      \n-      if ((*path)[1]->type == EDGE_COPY_SRC_JOINER_BLOCK)\n-\t{\n-\t  unsigned int j;\n-\n-\t  for (j = 0; j < path->length (); j++)\n-\t    if ((*path)[j]->e->aux != NULL)\n-\t      break;\n-\n-\t  /* If we iterated through the entire path without exiting the loop,\n-\t     then we are good to go, attach the path to the starting edge.  */\n-\t  if (j == path->length ())\n-\t    {\n-\t      edge e = (*path)[0]->e;\n-\t      e->aux = path;\n-\t      bitmap_set_bit (tmp, e->dest->index);\n-\t    }\n-\t}\n+      edge e = (*path)[0]->e;\n+      e->aux = (void *)path;\n+      bitmap_set_bit (tmp, e->dest->index);\n     }\n \n   /* If we have a joiner block (J) which has two successors S1 and S2 and\n@@ -1488,6 +1472,39 @@ thread_through_all_blocks (bool may_peel_loop_headers)\n       retval |= thread_through_loop_header (loop, may_peel_loop_headers);\n     }\n \n+  /* Assume we had a jump thread path which went from the latch to the exit\n+     and a path which goes from outside to inside the same loop.  \n+\n+     If the latch to exit was handled first, we will thread it and clear\n+     loop->header.\n+\n+     The second path will be ignored by thread_block because we're going\n+     through a loop header.  It will also be ignored by the loop above\n+     because loop->header is NULL.\n+\n+     This results in the second path never being threaded.  The failure\n+     mode is a dangling AUX field.\n+\n+     This is inherently a bit of a pain to fix, so we just walk all the\n+     blocks and all the incoming edges to those blocks and clear their\n+     AUX fields.  */\n+  basic_block bb;\n+  edge_iterator ei;\n+  edge e;\n+  FOR_EACH_BB (bb)\n+    {\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\tif (e->aux)\n+\t  {\n+\t    vec<jump_thread_edge *> *path = THREAD_PATH (e);\n+\n+\t    for (unsigned int i = 0; i < path->length (); i++)\n+\t      delete (*path)[i];\n+\t    path->release ();\n+\t    e->aux = NULL;\n+ \t  }\n+    }\n+\n   statistics_counter_event (cfun, \"Jumps threaded\",\n \t\t\t    thread_stats.num_threaded_edges);\n "}]}