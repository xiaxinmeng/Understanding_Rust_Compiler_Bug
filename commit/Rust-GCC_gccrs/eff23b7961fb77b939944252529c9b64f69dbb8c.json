{"sha": "eff23b7961fb77b939944252529c9b64f69dbb8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWZmMjNiNzk2MWZiNzdiOTM5OTQ0MjUyNTI5YzliNjRmNjlkYmI4Yw==", "commit": {"author": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2020-06-26T16:10:55Z"}, "committer": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2020-06-29T10:58:54Z"}, "message": "amdgcn: Support basic DWARF\n\nThis is enough DWARF support for \"-O0 -g\" to work OK, within a single frame,\nusing the new rocgdb debugger from AMD.  Debugging with optimization enabled\nalso works when the values are located in SGPRs or memory.\n\nScalars in VGPRs are problematic, EXEC_HI and VCC_HI are unmappable, and\nCFI remains unimplemented.\n\ngcc/ChangeLog:\n\n\t* config/gcn/gcn-hsa.h (DBX_REGISTER_NUMBER): New macro.\n\t* config/gcn/gcn-protos.h (gcn_dwarf_register_number): New prototype.\n\t* config/gcn/gcn.c (gcn_expand_prologue): Add RTX_FRAME_RELATED_P\n\tand REG_FRAME_RELATED_EXPR to stack and frame pointer adjustments.\n\t(gcn_dwarf_register_number): New function.\n\t(gcn_dwarf_register_span): New function.\n\t(TARGET_DWARF_REGISTER_SPAN): New hook macro.", "tree": {"sha": "c4a1719de19553fe62a7af9259a2e53427e05601", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4a1719de19553fe62a7af9259a2e53427e05601"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eff23b7961fb77b939944252529c9b64f69dbb8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eff23b7961fb77b939944252529c9b64f69dbb8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eff23b7961fb77b939944252529c9b64f69dbb8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eff23b7961fb77b939944252529c9b64f69dbb8c/comments", "author": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35cf3c55165efe8226cb9e5397ab0620130396ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35cf3c55165efe8226cb9e5397ab0620130396ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35cf3c55165efe8226cb9e5397ab0620130396ea"}], "stats": {"total": 128, "additions": 120, "deletions": 8}, "files": [{"sha": "cb291726e192d64a5d136bc8a9fd87a77c598956", "filename": "gcc/config/gcn/gcn-hsa.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff23b7961fb77b939944252529c9b64f69dbb8c/gcc%2Fconfig%2Fgcn%2Fgcn-hsa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff23b7961fb77b939944252529c9b64f69dbb8c/gcc%2Fconfig%2Fgcn%2Fgcn-hsa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn-hsa.h?ref=eff23b7961fb77b939944252529c9b64f69dbb8c", "patch": "@@ -103,3 +103,4 @@ extern const char *last_arg_spec_function (int argc, const char **argv);\n #define DWARF2_DEBUGGING_INFO      1\n #define DWARF2_ASM_LINE_DEBUG_INFO 1\n #define EH_FRAME_THROUGH_COLLECT2  1\n+#define DBX_REGISTER_NUMBER(REGNO) gcn_dwarf_register_number (REGNO)"}, {"sha": "92b1a60261097099f3b2ef9807e3031a354b3b05", "filename": "gcc/config/gcn/gcn-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff23b7961fb77b939944252529c9b64f69dbb8c/gcc%2Fconfig%2Fgcn%2Fgcn-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff23b7961fb77b939944252529c9b64f69dbb8c/gcc%2Fconfig%2Fgcn%2Fgcn-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn-protos.h?ref=eff23b7961fb77b939944252529c9b64f69dbb8c", "patch": "@@ -23,6 +23,7 @@ extern bool gcn_can_split_p (machine_mode, rtx);\n extern bool gcn_constant64_p (rtx);\n extern bool gcn_constant_p (rtx);\n extern rtx gcn_convert_mask_mode (rtx reg);\n+extern unsigned int gcn_dwarf_register_number (unsigned int regno);\n extern char * gcn_expand_dpp_shr_insn (machine_mode, const char *, int, int);\n extern void gcn_expand_epilogue ();\n extern rtx gcn_expand_scaled_offsets (addr_space_t as, rtx base, rtx offsets,"}, {"sha": "babecef7888561faeb15f01aa670d8c7b3596552", "filename": "gcc/config/gcn/gcn.c", "status": "modified", "additions": 118, "deletions": 8, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff23b7961fb77b939944252529c9b64f69dbb8c/gcc%2Fconfig%2Fgcn%2Fgcn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff23b7961fb77b939944252529c9b64f69dbb8c/gcc%2Fconfig%2Fgcn%2Fgcn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.c?ref=eff23b7961fb77b939944252529c9b64f69dbb8c", "patch": "@@ -2795,7 +2795,11 @@ gcn_expand_prologue ()\n   if (!cfun || !cfun->machine || cfun->machine->normal_function)\n     {\n       rtx sp = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n+      rtx sp_hi = gcn_operand_part (Pmode, sp, 1);\n+      rtx sp_lo = gcn_operand_part (Pmode, sp, 0);\n       rtx fp = gen_rtx_REG (Pmode, HARD_FRAME_POINTER_REGNUM);\n+      rtx fp_hi = gcn_operand_part (Pmode, fp, 1);\n+      rtx fp_lo = gcn_operand_part (Pmode, fp, 0);\n \n       start_sequence ();\n \n@@ -2812,14 +2816,40 @@ gcn_expand_prologue ()\n \t+ offsets->callee_saves\n \t+ offsets->local_vars + offsets->outgoing_args_size;\n       if (sp_adjust > 0)\n-\temit_insn (gen_adddi3_scc (sp, sp, gen_int_mode (sp_adjust, DImode)));\n+\t{\n+\t  /* Adding RTX_FRAME_RELATED_P effectively disables spliting, so\n+\t     we use split add explictly, and specify the DImode add in\n+\t     the note.  */\n+\t  rtx scc = gen_rtx_REG (BImode, SCC_REG);\n+\t  rtx adjustment = gen_int_mode (sp_adjust, SImode);\n+\t  rtx insn = emit_insn (gen_addsi3_scalar_carry (sp_lo, sp_lo,\n+\t\t\t\t\t\t\t adjustment, scc));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n+\t\t\tgen_rtx_SET (sp,\n+\t\t\t\t     gen_rtx_PLUS (DImode, sp, adjustment)));\n+\t  emit_insn (gen_addcsi3_scalar_zero (sp_hi, sp_hi, scc));\n+\t}\n \n       if (offsets->need_frame_pointer)\n-\temit_insn (gen_adddi3_scc (fp, sp,\n-\t\t\t\t   gen_int_mode\n-\t\t\t\t   (-(offsets->local_vars +\n-\t\t\t\t      offsets->outgoing_args_size),\n-\t\t\t\t    DImode)));\n+\t{\n+\t  /* Adding RTX_FRAME_RELATED_P effectively disables spliting, so\n+\t     we use split add explictly, and specify the DImode add in\n+\t     the note.  */\n+\t  rtx scc = gen_rtx_REG (BImode, SCC_REG);\n+\t  int fp_adjust = -(offsets->local_vars + offsets->outgoing_args_size);\n+\t  rtx adjustment = gen_int_mode (fp_adjust, SImode);\n+\t  rtx insn = emit_insn (gen_addsi3_scalar_carry(fp_lo, sp_lo,\n+\t\t\t\t\t\t\tadjustment, scc));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n+\t\t\tgen_rtx_SET (fp,\n+\t\t\t\t     gen_rtx_PLUS (DImode, sp, adjustment)));\n+\t  emit_insn (gen_addcsi3_scalar (fp_hi, sp_hi,\n+\t\t\t\t\t (fp_adjust < 0 ? GEN_INT (-1)\n+\t\t\t\t\t  : const0_rtx),\n+\t\t\t\t\t scc, scc));\n+\t}\n \n       rtx_insn *seq = get_insns ();\n       end_sequence ();\n@@ -2865,6 +2895,8 @@ gcn_expand_prologue ()\n \n       /* Set up frame pointer and stack pointer.  */\n       rtx sp = gen_rtx_REG (DImode, STACK_POINTER_REGNUM);\n+      rtx sp_hi = simplify_gen_subreg (SImode, sp, DImode, 4);\n+      rtx sp_lo = simplify_gen_subreg (SImode, sp, DImode, 0);\n       rtx fp = gen_rtx_REG (DImode, HARD_FRAME_POINTER_REGNUM);\n       rtx fp_hi = simplify_gen_subreg (SImode, fp, DImode, 4);\n       rtx fp_lo = simplify_gen_subreg (SImode, fp, DImode, 0);\n@@ -2880,10 +2912,28 @@ gcn_expand_prologue ()\n       emit_insn (gen_addsi3_scalar_carry (fp_lo, fp_lo, wave_offset, scc));\n       emit_insn (gen_addcsi3_scalar_zero (fp_hi, fp_hi, scc));\n \n+      /* Adding RTX_FRAME_RELATED_P effectively disables spliting, so we use\n+\t split add explictly, and specify the DImode add in the note.\n+         The DWARF info expects that the callee-save data is in the frame,\n+         even though it isn't (because this is the entry point), so we\n+         make a notional adjustment to the DWARF frame offset here.  */\n+      rtx dbg_adjustment = gen_int_mode (sp_adjust + offsets->callee_saves,\n+\t\t\t\t\t DImode);\n+      rtx insn;\n       if (sp_adjust > 0)\n-\temit_insn (gen_adddi3_scc (sp, fp, gen_int_mode (sp_adjust, DImode)));\n+\t{\n+\t  rtx scc = gen_rtx_REG (BImode, SCC_REG);\n+\t  rtx adjustment = gen_int_mode (sp_adjust, DImode);\n+\t  insn = emit_insn (gen_addsi3_scalar_carry(sp_lo, fp_lo, adjustment,\n+\t\t\t\t\t\t    scc));\n+\t  emit_insn (gen_addcsi3_scalar_zero (sp_hi, fp_hi, scc));\n+\t}\n       else\n-\temit_move_insn (sp, fp);\n+\tinsn = emit_move_insn (sp, fp);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n+\t\t    gen_rtx_SET (sp, gen_rtx_PLUS (DImode, sp,\n+\t\t\t\t\t\t   dbg_adjustment)));\n \n       /* Make sure the flat scratch reg doesn't get optimised away.  */\n       emit_insn (gen_prologue_use (gen_rtx_REG (DImode, FLAT_SCRATCH_REG)));\n@@ -6108,6 +6158,64 @@ print_operand (FILE *file, rtx x, int code)\n   gcc_unreachable ();\n }\n \n+/* Implement DBX_REGISTER_NUMBER macro.\n+ \n+   Return the DWARF register number that corresponds to the GCC internal\n+   REGNO.  */\n+\n+unsigned int\n+gcn_dwarf_register_number (unsigned int regno)\n+{\n+  /* Registers defined in DWARF.  */\n+  if (regno == EXEC_LO_REG)\n+    return 17;\n+  /* We need to use a more complex DWARF expression for this\n+  else if (regno == EXEC_HI_REG)\n+    return 17; */\n+  else if (regno == VCC_LO_REG)\n+    return 768;\n+  /* We need to use a more complex DWARF expression for this\n+  else if (regno == VCC_HI_REG)\n+    return 768;  */\n+  else if (regno == SCC_REG)\n+    return 128;\n+  else if (SGPR_REGNO_P (regno))\n+    {\n+      if (regno - FIRST_SGPR_REG < 64)\n+\treturn (regno - FIRST_SGPR_REG + 32);\n+      else\n+\treturn (regno - FIRST_SGPR_REG + 1024);\n+    }\n+  else if (VGPR_REGNO_P (regno))\n+    return (regno - FIRST_VGPR_REG + 2560);\n+\n+  /* Otherwise, there's nothing sensible to do.  */\n+  return regno + 100000;\n+}\n+\n+/* Implement TARGET_DWARF_REGISTER_SPAN.\n+ \n+   DImode and Vector DImode require additional registers.  */\n+\n+static rtx\n+gcn_dwarf_register_span (rtx rtl)\n+{\n+  machine_mode mode = GET_MODE (rtl);\n+\n+  if (VECTOR_MODE_P (mode))\n+    mode = GET_MODE_INNER (mode);\n+\n+  if (GET_MODE_SIZE (mode) != 8)\n+    return NULL_RTX;\n+\n+  rtx p = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (2));\n+  unsigned regno = REGNO (rtl);\n+  XVECEXP (p, 0, 0) = gen_rtx_REG (SImode, regno);\n+  XVECEXP (p, 0, 1) = gen_rtx_REG (SImode, regno + 1);\n+\n+  return p;\n+}\n+\n /* }}}  */\n /* {{{ TARGET hook overrides.  */\n \n@@ -6156,6 +6264,8 @@ print_operand (FILE *file, rtx x, int code)\n #define TARGET_CONSTANT_ALIGNMENT gcn_constant_alignment\n #undef  TARGET_DEBUG_UNWIND_INFO\n #define TARGET_DEBUG_UNWIND_INFO gcn_debug_unwind_info\n+#undef  TARGET_DWARF_REGISTER_SPAN\n+#define TARGET_DWARF_REGISTER_SPAN gcn_dwarf_register_span\n #undef  TARGET_EMUTLS_VAR_INIT\n #define TARGET_EMUTLS_VAR_INIT gcn_emutls_var_init\n #undef  TARGET_EXPAND_BUILTIN"}]}