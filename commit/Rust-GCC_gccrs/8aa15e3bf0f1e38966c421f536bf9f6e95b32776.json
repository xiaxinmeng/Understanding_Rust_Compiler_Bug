{"sha": "8aa15e3bf0f1e38966c421f536bf9f6e95b32776", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFhMTVlM2JmMGYxZTM4OTY2YzQyMWY1MzZiZjlmNmU5NWIzMjc3Ng==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2008-05-28T15:34:05Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-05-28T15:34:05Z"}, "message": "sem_util.ads (Find_Overridden_Synchronized_Primitive): Removed.\n\n2008-05-28  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_util.ads (Find_Overridden_Synchronized_Primitive): Removed.\n\t* sem_util.adb (Find_Overridden_Synchronized_Primitive): Removed.\n\t* sem_ch6.adb (Check_Synchronized_Overriding): Remove one formal.\n\tAdd code that was previously located in\n\tFind_Overridden_Synchronized_Primitive because it is only used here.\n\nFrom-SVN: r136105", "tree": {"sha": "af05cd7d74103d2d9a22544ec77a8f7f862f0ec2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af05cd7d74103d2d9a22544ec77a8f7f862f0ec2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8aa15e3bf0f1e38966c421f536bf9f6e95b32776", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aa15e3bf0f1e38966c421f536bf9f6e95b32776", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8aa15e3bf0f1e38966c421f536bf9f6e95b32776", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aa15e3bf0f1e38966c421f536bf9f6e95b32776/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9800ef594c9e73b5bd04ba27924384cf4d73a127", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9800ef594c9e73b5bd04ba27924384cf4d73a127", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9800ef594c9e73b5bd04ba27924384cf4d73a127"}], "stats": {"total": 699, "additions": 332, "deletions": 367}, "files": [{"sha": "f376e955b37c738cc9947b842f4dd13d76d79e6b", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 332, "deletions": 36, "changes": 368, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aa15e3bf0f1e38966c421f536bf9f6e95b32776/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aa15e3bf0f1e38966c421f536bf9f6e95b32776/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=8aa15e3bf0f1e38966c421f536bf9f6e95b32776", "patch": "@@ -6203,7 +6203,6 @@ package body Sem_Ch6 is\n \n       procedure Check_Synchronized_Overriding\n         (Def_Id          : Entity_Id;\n-         First_Hom       : Entity_Id;\n          Overridden_Subp : out Entity_Id);\n       --  First determine if Def_Id is an entry or a subprogram either defined\n       --  in the scope of a task or protected type, or is a primitive of such\n@@ -6398,22 +6397,198 @@ package body Sem_Ch6 is\n \n       procedure Check_Synchronized_Overriding\n         (Def_Id          : Entity_Id;\n-         First_Hom       : Entity_Id;\n          Overridden_Subp : out Entity_Id)\n       is\n-         Formal_Typ  : Entity_Id;\n          Ifaces_List : Elist_Id;\n          In_Scope    : Boolean;\n          Typ         : Entity_Id;\n \n+         function Has_Correct_Formal_Mode\n+           (Tag_Typ : Entity_Id;\n+            Subp    : Entity_Id) return Boolean;\n+         --  For an overridden subprogram Subp, check whether the mode of its\n+         --  first parameter is correct depending on the kind of Tag_Typ.\n+\n+         function Matches_Prefixed_View_Profile\n+           (Prim_Params  : List_Id;\n+            Iface_Params : List_Id) return Boolean;\n+         --  Determine whether a subprogram's parameter profile Prim_Params\n+         --  matches that of a potentially overridden interface subprogram\n+         --  Iface_Params. Also determine if the type of first parameter of\n+         --  Iface_Params is an implemented interface.\n+\n+         -----------------------------\n+         -- Has_Correct_Formal_Mode --\n+         -----------------------------\n+\n+         function Has_Correct_Formal_Mode\n+           (Tag_Typ : Entity_Id;\n+            Subp    : Entity_Id) return Boolean\n+         is\n+            Formal : constant Node_Id := First_Formal (Subp);\n+\n+         begin\n+            --  In order for an entry or a protected procedure to override, the\n+            --  first parameter of the overridden routine must be of mode\n+            --  \"out\", \"in out\" or access-to-variable.\n+\n+            if (Ekind (Subp) = E_Entry\n+                  or else Ekind (Subp) = E_Procedure)\n+              and then Is_Protected_Type (Tag_Typ)\n+              and then Ekind (Formal) /= E_In_Out_Parameter\n+              and then Ekind (Formal) /= E_Out_Parameter\n+              and then Nkind (Parameter_Type (Parent (Formal))) /=\n+                         N_Access_Definition\n+            then\n+               return False;\n+            end if;\n+\n+            --  All other cases are OK since a task entry or routine does not\n+            --  have a restriction on the mode of the first parameter of the\n+            --  overridden interface routine.\n+\n+            return True;\n+         end Has_Correct_Formal_Mode;\n+\n+         -----------------------------------\n+         -- Matches_Prefixed_View_Profile --\n+         -----------------------------------\n+\n+         function Matches_Prefixed_View_Profile\n+           (Prim_Params  : List_Id;\n+            Iface_Params : List_Id) return Boolean\n+         is\n+            Iface_Id     : Entity_Id;\n+            Iface_Param  : Node_Id;\n+            Iface_Typ    : Entity_Id;\n+            Prim_Id      : Entity_Id;\n+            Prim_Param   : Node_Id;\n+            Prim_Typ     : Entity_Id;\n+\n+            function Is_Implemented\n+              (Ifaces_List : Elist_Id;\n+               Iface       : Entity_Id) return Boolean;\n+            --  Determine if Iface is implemented by the current task or\n+            --  protected type.\n+\n+            --------------------\n+            -- Is_Implemented --\n+            --------------------\n+\n+            function Is_Implemented\n+              (Ifaces_List : Elist_Id;\n+               Iface       : Entity_Id) return Boolean\n+            is\n+               Iface_Elmt : Elmt_Id;\n+\n+            begin\n+               Iface_Elmt := First_Elmt (Ifaces_List);\n+               while Present (Iface_Elmt) loop\n+                  if Node (Iface_Elmt) = Iface then\n+                     return True;\n+                  end if;\n+\n+                  Next_Elmt (Iface_Elmt);\n+               end loop;\n+\n+               return False;\n+            end Is_Implemented;\n+\n+         --  Start of processing for Matches_Prefixed_View_Profile\n+\n+         begin\n+            Iface_Param := First (Iface_Params);\n+            Iface_Typ   := Etype (Defining_Identifier (Iface_Param));\n+\n+            if Is_Access_Type (Iface_Typ) then\n+               Iface_Typ := Designated_Type (Iface_Typ);\n+            end if;\n+\n+            Prim_Param := First (Prim_Params);\n+\n+            --  The first parameter of the potentially overridden subprogram\n+            --  must be an interface implemented by Prim.\n+\n+            if not Is_Interface (Iface_Typ)\n+              or else not Is_Implemented (Ifaces_List, Iface_Typ)\n+            then\n+               return False;\n+            end if;\n+\n+            --  The checks on the object parameters are done, move onto the\n+            --  rest of the parameters.\n+\n+            if not In_Scope then\n+               Prim_Param := Next (Prim_Param);\n+            end if;\n+\n+            Iface_Param := Next (Iface_Param);\n+            while Present (Iface_Param) and then Present (Prim_Param) loop\n+               Iface_Id  := Defining_Identifier (Iface_Param);\n+               Iface_Typ := Find_Parameter_Type (Iface_Param);\n+\n+               if Is_Access_Type (Iface_Typ) then\n+                  Iface_Typ := Directly_Designated_Type (Iface_Typ);\n+               end if;\n+\n+               Prim_Id  := Defining_Identifier (Prim_Param);\n+               Prim_Typ := Find_Parameter_Type (Prim_Param);\n+\n+               if Is_Access_Type (Prim_Typ) then\n+                  Prim_Typ := Directly_Designated_Type (Prim_Typ);\n+               end if;\n+\n+               --  Case of multiple interface types inside a parameter profile\n+\n+               --     (Obj_Param : in out Iface; ...; Param : Iface)\n+\n+               --  If the interface type is implemented, then the matching type\n+               --  in the primitive should be the implementing record type.\n+\n+               if Ekind (Iface_Typ) = E_Record_Type\n+                 and then Is_Interface (Iface_Typ)\n+                 and then Is_Implemented (Ifaces_List, Iface_Typ)\n+               then\n+                  if Prim_Typ /= Typ then\n+                     return False;\n+                  end if;\n+\n+               --  The two parameters must be both mode and subtype conformant\n+\n+               elsif Ekind (Iface_Id) /= Ekind (Prim_Id)\n+                 or else not\n+                   Conforming_Types (Iface_Typ, Prim_Typ, Subtype_Conformant)\n+               then\n+                  return False;\n+               end if;\n+\n+               Next (Iface_Param);\n+               Next (Prim_Param);\n+            end loop;\n+\n+            --  One of the two lists contains more parameters than the other\n+\n+            if Present (Iface_Param) or else Present (Prim_Param) then\n+               return False;\n+            end if;\n+\n+            return True;\n+         end Matches_Prefixed_View_Profile;\n+\n+      --  Start of processing for Check_Synchronized_Overriding\n+\n       begin\n          Overridden_Subp := Empty;\n \n-         --  Def_Id must be an entry or a subprogram\n+         --  Def_Id must be an entry or a subprogram. We should skip predefined\n+         --  primitives internally generated by the frontend; however at this\n+         --  stage predefined primitives are still not fully decorated. As a\n+         --  minor optimization we skip here internally generated subprograms.\n \n-         if Ekind (Def_Id) /= E_Entry\n-           and then Ekind (Def_Id) /= E_Function\n-           and then Ekind (Def_Id) /= E_Procedure\n+         if (Ekind (Def_Id) /= E_Entry\n+              and then Ekind (Def_Id) /= E_Function\n+              and then Ekind (Def_Id) /= E_Procedure)\n+           or else not Comes_From_Source (Def_Id)\n          then\n             return;\n          end if;\n@@ -6429,57 +6604,178 @@ package body Sem_Ch6 is\n             Typ := Scope (Def_Id);\n             In_Scope := True;\n \n-         --  The subprogram may be a primitive of a concurrent type\n+         --  The enclosing scope is not a synchronized type and the subprogram\n+         --  has no formals\n \n-         elsif Present (First_Formal (Def_Id)) then\n-            Formal_Typ := Etype (First_Formal (Def_Id));\n+         elsif No (First_Formal (Def_Id)) then\n+            return;\n+\n+         --  The subprogram has formals and hence it may be a primitive of a\n+         --  concurrent type\n+\n+         else\n+            Typ := Etype (First_Formal (Def_Id));\n \n-            if Is_Access_Type (Formal_Typ) then\n-               Formal_Typ := Directly_Designated_Type (Formal_Typ);\n+            if Is_Access_Type (Typ) then\n+               Typ := Directly_Designated_Type (Typ);\n             end if;\n \n-            if Is_Concurrent_Type (Formal_Typ)\n-              and then not Is_Generic_Actual_Type (Formal_Typ)\n+            if Is_Concurrent_Type (Typ)\n+              and then not Is_Generic_Actual_Type (Typ)\n             then\n-               Typ := Formal_Typ;\n                In_Scope := False;\n \n             --  This case occurs when the concurrent type is declared within\n             --  a generic unit. As a result the corresponding record has been\n             --  built and used as the type of the first formal, we just have\n             --  to retrieve the corresponding concurrent type.\n \n-            elsif Is_Concurrent_Record_Type (Formal_Typ)\n-              and then Present (Corresponding_Concurrent_Type (Formal_Typ))\n+            elsif Is_Concurrent_Record_Type (Typ)\n+              and then Present (Corresponding_Concurrent_Type (Typ))\n             then\n-               Typ := Corresponding_Concurrent_Type (Formal_Typ);\n+               Typ := Corresponding_Concurrent_Type (Typ);\n                In_Scope := False;\n \n             else\n                return;\n             end if;\n-         else\n+         end if;\n+\n+         --  There is no overriding to check if is an inherited operation in a\n+         --  type derivation on for a generic actual.\n+\n+         Collect_Interfaces (Typ, Ifaces_List);\n+\n+         if Is_Empty_Elmt_List (Ifaces_List) then\n             return;\n          end if;\n \n-         --  Gather all limited, protected and task interfaces that Typ\n-         --  implements. There is no overriding to check if is an inherited\n-         --  operation in a type derivation on for a generic actual.\n+         --  Determine whether entry or subprogram Def_Id overrides a primitive\n+         --  operation that belongs to one of the interfaces in Ifaces_List.\n \n-         if Nkind (Parent (Typ)) /= N_Full_Type_Declaration\n-           and then\n-             not Nkind_In (Parent (Def_Id), N_Subtype_Declaration,\n-                                            N_Task_Type_Declaration,\n-                                            N_Protected_Type_Declaration)\n-         then\n-            Collect_Interfaces (Typ, Ifaces_List);\n+         declare\n+            Candidate : Entity_Id := Empty;\n+            Hom       : Entity_Id := Empty;\n+            Iface_Typ : Entity_Id;\n+            Subp      : Entity_Id := Empty;\n+\n+         begin\n+            --  Traverse the homonym chain, looking at a potentially\n+            --  overridden subprogram that belongs to an implemented\n+            --  interface.\n+\n+            Hom := Current_Entity_In_Scope (Def_Id);\n+            while Present (Hom) loop\n+               Subp := Hom;\n+\n+               --  Entries can override abstract or null interface\n+               --  procedures\n+\n+               if Ekind (Def_Id) = E_Entry\n+                 and then Ekind (Subp) = E_Procedure\n+                 and then Nkind (Parent (Subp)) = N_Procedure_Specification\n+                 and then (Is_Abstract_Subprogram (Subp)\n+                             or else Null_Present (Parent (Subp)))\n+               then\n+                  while Present (Alias (Subp)) loop\n+                     Subp := Alias (Subp);\n+                  end loop;\n+\n+                  if Matches_Prefixed_View_Profile\n+                       (Parameter_Specifications (Parent (Def_Id)),\n+                        Parameter_Specifications (Parent (Subp)))\n+                  then\n+                     Candidate := Subp;\n \n-            if not Is_Empty_Elmt_List (Ifaces_List) then\n-               Overridden_Subp :=\n-                 Find_Overridden_Synchronized_Primitive\n-                   (Def_Id, First_Hom, Ifaces_List, In_Scope);\n+                     --  Absolute match\n+\n+                     if Has_Correct_Formal_Mode (Typ, Candidate) then\n+                        Overridden_Subp := Candidate;\n+                        return;\n+                     end if;\n+                  end if;\n+\n+               --  Procedures can override abstract or null interface\n+               --  procedures\n+\n+               elsif Ekind (Def_Id) = E_Procedure\n+                 and then Ekind (Subp) = E_Procedure\n+                 and then Nkind (Parent (Subp)) = N_Procedure_Specification\n+                 and then (Is_Abstract_Subprogram (Subp)\n+                             or else Null_Present (Parent (Subp)))\n+                 and then Matches_Prefixed_View_Profile\n+                            (Parameter_Specifications (Parent (Def_Id)),\n+                             Parameter_Specifications (Parent (Subp)))\n+               then\n+                  Candidate := Subp;\n+\n+                  --  Absolute match\n+\n+                  if Has_Correct_Formal_Mode (Typ, Candidate) then\n+                     Overridden_Subp := Candidate;\n+                     return;\n+                  end if;\n+\n+               --  Functions can override abstract interface functions\n+\n+               elsif Ekind (Def_Id) = E_Function\n+                 and then Ekind (Subp) = E_Function\n+                 and then Nkind (Parent (Subp)) = N_Function_Specification\n+                 and then Is_Abstract_Subprogram (Subp)\n+                 and then Matches_Prefixed_View_Profile\n+                            (Parameter_Specifications (Parent (Def_Id)),\n+                             Parameter_Specifications (Parent (Subp)))\n+                 and then Etype (Result_Definition (Parent (Def_Id))) =\n+                          Etype (Result_Definition (Parent (Subp)))\n+               then\n+                  Overridden_Subp := Subp;\n+                  return;\n+               end if;\n+\n+               Hom := Homonym (Hom);\n+            end loop;\n+\n+            --  After examining all candidates for overriding, we are\n+            --  left with the best match which is a mode incompatible\n+            --  interface routine. Do not emit an error if the Expander\n+            --  is active since this error will be detected later on\n+            --  after all concurrent types are expanded and all wrappers\n+            --  are built. This check is meant for spec-only\n+            --  compilations.\n+\n+            if Present (Candidate)\n+              and then not Expander_Active\n+            then\n+               Iface_Typ :=\n+                 Find_Parameter_Type (Parent (First_Formal (Candidate)));\n+\n+               --  Def_Id is primitive of a protected type, declared\n+               --  inside the type, and the candidate is primitive of a\n+               --  limited or synchronized interface.\n+\n+               if In_Scope\n+                 and then Is_Protected_Type (Typ)\n+                 and then\n+                   (Is_Limited_Interface (Iface_Typ)\n+                      or else Is_Protected_Interface (Iface_Typ)\n+                      or else Is_Synchronized_Interface (Iface_Typ)\n+                      or else Is_Task_Interface (Iface_Typ))\n+               then\n+                  --  Must reword this message, comma before to in -gnatj\n+                  --  mode ???\n+\n+                  Error_Msg_NE\n+                    (\"first formal of & must be of mode `OUT`, `IN OUT`\"\n+                      & \" or access-to-variable\", Typ, Candidate);\n+                  Error_Msg_N\n+                    (\"\\to be overridden by protected procedure or entry \"\n+                      & \"(RM 9.4(11.9/2))\", Typ);\n+               end if;\n             end if;\n-         end if;\n+\n+            Overridden_Subp := Candidate;\n+            return;\n+         end;\n       end Check_Synchronized_Overriding;\n \n       ----------------------------\n@@ -6532,7 +6828,7 @@ package body Sem_Ch6 is\n          --  has an overriding indicator.\n \n          if Comes_From_Source (S) then\n-            Check_Synchronized_Overriding (S, Homonym (S), Overridden_Subp);\n+            Check_Synchronized_Overriding (S, Overridden_Subp);\n             Check_Overriding_Indicator\n               (S, Overridden_Subp, Is_Primitive => Is_Primitive_Subp);\n          end if;\n@@ -6609,7 +6905,7 @@ package body Sem_Ch6 is\n             goto Add_New_Entity;\n          end if;\n \n-         Check_Synchronized_Overriding (S, E, Overridden_Subp);\n+         Check_Synchronized_Overriding (S, Overridden_Subp);\n \n          --  Loop through E and its homonyms to determine if any of them is\n          --  the candidate for overriding by S."}, {"sha": "ddcc386b06b856c4bc4c2df3e8972c5fa9a39949", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 0, "deletions": 319, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aa15e3bf0f1e38966c421f536bf9f6e95b32776/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aa15e3bf0f1e38966c421f536bf9f6e95b32776/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=8aa15e3bf0f1e38966c421f536bf9f6e95b32776", "patch": "@@ -44,7 +44,6 @@ with Scans;    use Scans;\n with Scn;      use Scn;\n with Sem;      use Sem;\n with Sem_Attr; use Sem_Attr;\n-with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n@@ -2901,324 +2900,6 @@ package body Sem_Util is\n       return Empty;\n    end Find_Overlaid_Object;\n \n-   --------------------------------------------\n-   -- Find_Overridden_Synchronized_Primitive --\n-   --------------------------------------------\n-\n-   function Find_Overridden_Synchronized_Primitive\n-     (Def_Id      : Entity_Id;\n-      First_Hom   : Entity_Id;\n-      Ifaces_List : Elist_Id;\n-      In_Scope    : Boolean) return Entity_Id\n-   is\n-      Candidate : Entity_Id := Empty;\n-      Hom       : Entity_Id := Empty;\n-      Iface_Typ : Entity_Id;\n-      Subp      : Entity_Id := Empty;\n-      Tag_Typ   : Entity_Id;\n-\n-      function Has_Correct_Formal_Mode (Subp : Entity_Id) return Boolean;\n-      --  For an overridden subprogram Subp, check whether the mode of its\n-      --  first parameter is correct depending on the kind of Tag_Typ.\n-\n-      function Matches_Prefixed_View_Profile\n-        (Prim_Params  : List_Id;\n-         Iface_Params : List_Id) return Boolean;\n-      --  Determine whether a subprogram's parameter profile Prim_Params\n-      --  matches that of a potentially overridden interface subprogram\n-      --  Iface_Params. Also determine if the type of first parameter of\n-      --  Iface_Params is an implemented interface.\n-\n-      -----------------------------\n-      -- Has_Correct_Formal_Mode --\n-      -----------------------------\n-\n-      function Has_Correct_Formal_Mode (Subp : Entity_Id) return Boolean is\n-         Param : Node_Id;\n-\n-      begin\n-         Param := First_Formal (Subp);\n-\n-         --  In order for an entry or a protected procedure to override, the\n-         --  first parameter of the overridden routine must be of mode \"out\",\n-         --  \"in out\" or access-to-variable.\n-\n-         if (Ekind (Subp) = E_Entry\n-               or else Ekind (Subp) = E_Procedure)\n-           and then Is_Protected_Type (Tag_Typ)\n-           and then Ekind (Param) /= E_In_Out_Parameter\n-           and then Ekind (Param) /= E_Out_Parameter\n-           and then Nkind (Parameter_Type (Parent (Param))) /=\n-                      N_Access_Definition\n-         then\n-            return False;\n-         end if;\n-\n-         --  All other cases are OK since a task entry or routine does not\n-         --  have a restriction on the mode of the first parameter of the\n-         --  overridden interface routine.\n-\n-         return True;\n-      end Has_Correct_Formal_Mode;\n-\n-      -----------------------------------\n-      -- Matches_Prefixed_View_Profile --\n-      -----------------------------------\n-\n-      function Matches_Prefixed_View_Profile\n-        (Prim_Params  : List_Id;\n-         Iface_Params : List_Id) return Boolean\n-      is\n-         Iface_Id     : Entity_Id;\n-         Iface_Param  : Node_Id;\n-         Iface_Typ    : Entity_Id;\n-         Prim_Id      : Entity_Id;\n-         Prim_Param   : Node_Id;\n-         Prim_Typ     : Entity_Id;\n-\n-         function Is_Implemented (Iface : Entity_Id) return Boolean;\n-         --  Determine if Iface is implemented by the current task or\n-         --  protected type.\n-\n-         --------------------\n-         -- Is_Implemented --\n-         --------------------\n-\n-         function Is_Implemented (Iface : Entity_Id) return Boolean is\n-            Iface_Elmt : Elmt_Id;\n-\n-         begin\n-            Iface_Elmt := First_Elmt (Ifaces_List);\n-            while Present (Iface_Elmt) loop\n-               if Node (Iface_Elmt) = Iface then\n-                  return True;\n-               end if;\n-\n-               Next_Elmt (Iface_Elmt);\n-            end loop;\n-\n-            return False;\n-         end Is_Implemented;\n-\n-      --  Start of processing for Matches_Prefixed_View_Profile\n-\n-      begin\n-         Iface_Param := First (Iface_Params);\n-\n-         if Nkind (Parameter_Type (Iface_Param)) = N_Access_Definition then\n-            Iface_Typ :=\n-               Designated_Type (Etype (Defining_Identifier (Iface_Param)));\n-         else\n-            Iface_Typ := Etype (Defining_Identifier (Iface_Param));\n-         end if;\n-\n-         Prim_Param  := First (Prim_Params);\n-\n-         --  The first parameter of the potentially overridden subprogram\n-         --  must be an interface implemented by Prim.\n-\n-         if not Is_Interface (Iface_Typ)\n-           or else not Is_Implemented (Iface_Typ)\n-         then\n-            return False;\n-         end if;\n-\n-         --  The checks on the object parameters are done, move onto the rest\n-         --  of the parameters.\n-\n-         if not In_Scope then\n-            Prim_Param := Next (Prim_Param);\n-         end if;\n-\n-         Iface_Param := Next (Iface_Param);\n-         while Present (Iface_Param) and then Present (Prim_Param) loop\n-            Iface_Id  := Defining_Identifier (Iface_Param);\n-            Iface_Typ := Find_Parameter_Type (Iface_Param);\n-\n-            if Is_Access_Type (Iface_Typ) then\n-               Iface_Typ := Directly_Designated_Type (Iface_Typ);\n-            end if;\n-\n-            Prim_Id   := Defining_Identifier (Prim_Param);\n-            Prim_Typ  := Find_Parameter_Type (Prim_Param);\n-\n-            if Is_Access_Type (Prim_Typ) then\n-               Prim_Typ := Directly_Designated_Type (Prim_Typ);\n-            end if;\n-\n-            --  Case of multiple interface types inside a parameter profile\n-\n-            --     (Obj_Param : in out Iface; ...; Param : Iface)\n-\n-            --  If the interface type is implemented, then the matching type\n-            --  in the primitive should be the implementing record type.\n-\n-            if Ekind (Iface_Typ) = E_Record_Type\n-              and then Is_Interface (Iface_Typ)\n-              and then Is_Implemented (Iface_Typ)\n-            then\n-               if Prim_Typ /= Tag_Typ then\n-                  return False;\n-               end if;\n-\n-            --  The two parameters must be both mode and subtype conformant\n-\n-            elsif Ekind (Iface_Id) /= Ekind (Prim_Id)\n-              or else\n-                not Conforming_Types (Iface_Typ, Prim_Typ, Subtype_Conformant)\n-            then\n-               return False;\n-            end if;\n-\n-            Next (Iface_Param);\n-            Next (Prim_Param);\n-         end loop;\n-\n-         --  One of the two lists contains more parameters than the other\n-\n-         if Present (Iface_Param) or else Present (Prim_Param) then\n-            return False;\n-         end if;\n-\n-         return True;\n-      end Matches_Prefixed_View_Profile;\n-\n-   --  Start of processing for Find_Overridden_Synchronized_Primitive\n-\n-   begin\n-      --  At this point the caller should have collected the interfaces\n-      --  implemented by the synchronized type.\n-\n-      pragma Assert (Present (Ifaces_List));\n-\n-      --  Find the tagged type to which subprogram Def_Id is primitive. If the\n-      --  subprogram was declared within a protected or a task type, the type\n-      --  is the scope itself, otherwise it is the type of the first parameter.\n-\n-      if In_Scope then\n-         Tag_Typ := Scope (Def_Id);\n-\n-      elsif Present (First_Formal (Def_Id)) then\n-         Tag_Typ := Find_Parameter_Type (Parent (First_Formal (Def_Id)));\n-\n-      --  A parameterless subprogram which is declared outside a synchronized\n-      --  type cannot act as a primitive, thus it cannot override anything.\n-\n-      else\n-         return Empty;\n-      end if;\n-\n-      if Is_Access_Type (Tag_Typ) then\n-         Tag_Typ := Directly_Designated_Type (Tag_Typ);\n-      end if;\n-\n-      --  Traverse the homonym chain, looking at a potentially overridden\n-      --  subprogram that belongs to an implemented interface.\n-\n-      Hom := First_Hom;\n-      while Present (Hom) loop\n-         Subp := Hom;\n-\n-         --  Entries can override abstract or null interface procedures\n-\n-         if Ekind (Def_Id) = E_Entry\n-           and then Ekind (Subp) = E_Procedure\n-           and then Nkind (Parent (Subp)) = N_Procedure_Specification\n-           and then (Is_Abstract_Subprogram (Subp)\n-                       or else Null_Present (Parent (Subp)))\n-         then\n-            while Present (Alias (Subp)) loop\n-               Subp := Alias (Subp);\n-            end loop;\n-\n-            if Matches_Prefixed_View_Profile\n-                 (Parameter_Specifications (Parent (Def_Id)),\n-                  Parameter_Specifications (Parent (Subp)))\n-            then\n-               Candidate := Subp;\n-\n-               --  Absolute match\n-\n-               if Has_Correct_Formal_Mode (Candidate) then\n-                  return Candidate;\n-               end if;\n-            end if;\n-\n-         --  Procedures can override abstract or null interface procedures\n-\n-         elsif Ekind (Def_Id) = E_Procedure\n-           and then Ekind (Subp) = E_Procedure\n-           and then Nkind (Parent (Subp)) = N_Procedure_Specification\n-           and then (Is_Abstract_Subprogram (Subp)\n-                       or else Null_Present (Parent (Subp)))\n-           and then Matches_Prefixed_View_Profile\n-                      (Parameter_Specifications (Parent (Def_Id)),\n-                       Parameter_Specifications (Parent (Subp)))\n-         then\n-            Candidate := Subp;\n-\n-            --  Absolute match\n-\n-            if Has_Correct_Formal_Mode (Candidate) then\n-               return Candidate;\n-            end if;\n-\n-         --  Functions can override abstract interface functions\n-\n-         elsif Ekind (Def_Id) = E_Function\n-           and then Ekind (Subp) = E_Function\n-           and then Nkind (Parent (Subp)) = N_Function_Specification\n-           and then Is_Abstract_Subprogram (Subp)\n-           and then Matches_Prefixed_View_Profile\n-                      (Parameter_Specifications (Parent (Def_Id)),\n-                       Parameter_Specifications (Parent (Subp)))\n-           and then Etype (Result_Definition (Parent (Def_Id))) =\n-                    Etype (Result_Definition (Parent (Subp)))\n-         then\n-            return Subp;\n-         end if;\n-\n-         Hom := Homonym (Hom);\n-      end loop;\n-\n-      --  After examining all candidates for overriding, we are left with\n-      --  the best match which is a mode incompatible interface routine.\n-      --  Do not emit an error if the Expander is active since this error\n-      --  will be detected later on after all concurrent types are expanded\n-      --  and all wrappers are built. This check is meant for spec-only\n-      --  compilations.\n-\n-      if Present (Candidate)\n-        and then not Expander_Active\n-      then\n-         Iface_Typ := Find_Parameter_Type (Parent (First_Formal (Candidate)));\n-\n-         --  Def_Id is primitive of a protected type, declared inside the type,\n-         --  and the candidate is primitive of a limited or synchronized\n-         --  interface.\n-\n-         if In_Scope\n-           and then Is_Protected_Type (Tag_Typ)\n-           and then\n-             (Is_Limited_Interface (Iface_Typ)\n-                or else Is_Protected_Interface (Iface_Typ)\n-                or else Is_Synchronized_Interface (Iface_Typ)\n-                or else Is_Task_Interface (Iface_Typ))\n-         then\n-            --  Must reword this message, comma before to in -gnatj mode ???\n-\n-            Error_Msg_NE\n-              (\"first formal of & must be of mode `OUT`, `IN OUT` or \" &\n-               \"access-to-variable\", Tag_Typ, Candidate);\n-            Error_Msg_N\n-              (\"\\to be overridden by protected procedure or entry \" &\n-               \"(RM 9.4(11.9/2))\", Tag_Typ);\n-         end if;\n-      end if;\n-\n-      return Candidate;\n-   end Find_Overridden_Synchronized_Primitive;\n-\n    -------------------------\n    -- Find_Parameter_Type --\n    -------------------------"}, {"sha": "bbd4c864a3e505f278f025238030188a042a5cc5", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aa15e3bf0f1e38966c421f536bf9f6e95b32776/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aa15e3bf0f1e38966c421f536bf9f6e95b32776/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=8aa15e3bf0f1e38966c421f536bf9f6e95b32776", "patch": "@@ -327,18 +327,6 @@ package Sem_Util is\n    --  not an address representation clause, or if it is not possible to\n    --  determine that the address is of this form, then Empty is returned.\n \n-   function Find_Overridden_Synchronized_Primitive\n-     (Def_Id      : Entity_Id;\n-      First_Hom   : Entity_Id;\n-      Ifaces_List : Elist_Id;\n-      In_Scope    : Boolean) return Entity_Id;\n-   --  Determine whether entry or subprogram Def_Id overrides a primitive\n-   --  operation that belongs to one of the interfaces in Ifaces_List. A\n-   --  specific homonym chain can be specified by setting First_Hom. Flag\n-   --  In_Scope is used to designate whether the entry or subprogram was\n-   --  declared inside the scope of the synchronized type or after. Return\n-   --  the overridden entity or Empty.\n-\n    function Find_Parameter_Type (Param : Node_Id) return Entity_Id;\n    --  Return the type of formal parameter Param as determined by its\n    --  specification."}]}