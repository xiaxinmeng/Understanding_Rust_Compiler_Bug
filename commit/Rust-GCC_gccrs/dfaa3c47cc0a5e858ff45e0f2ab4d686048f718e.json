{"sha": "dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZhYTNjNDdjYzBhNWU4NThmZjQ1ZTBmMmFiNGQ2ODYwNDhmNzE4ZQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2018-07-24T21:09:55Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2018-07-24T21:09:55Z"}, "message": "Add initial version of C++17 <memory_resource> header\n\nThis is missing the synchronized_pool_resource and\nunsynchronized_pool_resource classes but is otherwise complete.\n\nThis is a new implementation, not based on the existing code in\n<experimental/memory_resource>, but memory_resource and\npolymorphic_allocator ended up looking almost the same anyway.\n\nThe constant_init kluge in src/c++17/memory_resource.cc is apparently\ndue to Richard Smith and ensures that the objects are constructed during\nconstant initialiation phase and not destroyed (because the\nconstant_init destructor doesn't destroy the union member and the\nstorage is not reused).\n\n\t* config/abi/pre/gnu.ver: Export new symbols.\n\t* configure: Regenerate.\n\t* include/Makefile.am: Add new <memory_resource> header.\n\t* include/Makefile.in: Regenerate.\n\t* include/precompiled/stdc++.h: Include <memory_resource> for C++17.\n\t* include/std/memory_resource: New header.\n\t(memory_resource, polymorphic_allocator, new_delete_resource)\n\t(null_memory_resource, set_default_resource, get_default_resource)\n\t(pool_options, monotonic_buffer_resource): Define.\n\t* src/Makefile.am: Add c++17 directory.\n\t* src/Makefile.in: Regenerate.\n\t* src/c++11/Makefile.am: Fix comment.\n\t* src/c++17/Makefile.am: Add makefile for new sub-directory.\n\t* src/c++17/Makefile.in: Generate.\n\t* src/c++17/memory_resource.cc: New.\n\t(newdel_res_t, null_res_t, constant_init, newdel_res, null_res)\n\t(default_res, new_delete_resource, null_memory_resource)\n\t(set_default_resource, get_default_resource): Define.\n\t* testsuite/20_util/memory_resource/1.cc: New test.\n\t* testsuite/20_util/memory_resource/2.cc: New test.\n\t* testsuite/20_util/monotonic_buffer_resource/1.cc: New test.\n\t* testsuite/20_util/monotonic_buffer_resource/allocate.cc: New test.\n\t* testsuite/20_util/monotonic_buffer_resource/deallocate.cc: New test.\n\t* testsuite/20_util/monotonic_buffer_resource/release.cc: New test.\n\t* testsuite/20_util/monotonic_buffer_resource/upstream_resource.cc:\n\tNew test.\n\t* testsuite/20_util/polymorphic_allocator/1.cc: New test.\n\t* testsuite/20_util/polymorphic_allocator/resource.cc: New test.\n\t* testsuite/20_util/polymorphic_allocator/select.cc: New test.\n\t* testsuite/util/testsuite_allocator.h (__gnu_test::memory_resource):\n\tDefine concrete memory resource for testing.\n\t(__gnu_test::default_resource_mgr): Define RAII helper for changing\n\tdefault resource.\n\nFrom-SVN: r262953", "tree": {"sha": "2fa7f48a9def9b3dad9d767bd6a1148ed6d72af4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2fa7f48a9def9b3dad9d767bd6a1148ed6d72af4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e874029dd994ce1dd098a143aa06a0894da7b7de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e874029dd994ce1dd098a143aa06a0894da7b7de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e874029dd994ce1dd098a143aa06a0894da7b7de"}], "stats": {"total": 2600, "additions": 2584, "deletions": 16}, "files": [{"sha": "bef5a97cd6ebbab6e07b6ac5a490a007abbc68bc", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e", "patch": "@@ -1,5 +1,39 @@\n 2018-07-24  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* config/abi/pre/gnu.ver: Export new symbols.\n+\t* configure: Regenerate.\n+\t* include/Makefile.am: Add new <memory_resource> header.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/precompiled/stdc++.h: Include <memory_resource> for C++17.\n+\t* include/std/memory_resource: New header.\n+\t(memory_resource, polymorphic_allocator, new_delete_resource)\n+\t(null_memory_resource, set_default_resource, get_default_resource)\n+\t(pool_options, monotonic_buffer_resource): Define.\n+\t* src/Makefile.am: Add c++17 directory.\n+\t* src/Makefile.in: Regenerate.\n+\t* src/c++11/Makefile.am: Fix comment.\n+\t* src/c++17/Makefile.am: Add makefile for new sub-directory.\n+\t* src/c++17/Makefile.in: Generate.\n+\t* src/c++17/memory_resource.cc: New.\n+\t(newdel_res_t, null_res_t, constant_init, newdel_res, null_res)\n+\t(default_res, new_delete_resource, null_memory_resource)\n+\t(set_default_resource, get_default_resource): Define.\n+\t* testsuite/20_util/memory_resource/1.cc: New test.\n+\t* testsuite/20_util/memory_resource/2.cc: New test.\n+\t* testsuite/20_util/monotonic_buffer_resource/1.cc: New test.\n+\t* testsuite/20_util/monotonic_buffer_resource/allocate.cc: New test.\n+\t* testsuite/20_util/monotonic_buffer_resource/deallocate.cc: New test.\n+\t* testsuite/20_util/monotonic_buffer_resource/release.cc: New test.\n+\t* testsuite/20_util/monotonic_buffer_resource/upstream_resource.cc:\n+\tNew test.\n+\t* testsuite/20_util/polymorphic_allocator/1.cc: New test.\n+\t* testsuite/20_util/polymorphic_allocator/resource.cc: New test.\n+\t* testsuite/20_util/polymorphic_allocator/select.cc: New test.\n+\t* testsuite/util/testsuite_allocator.h (__gnu_test::memory_resource):\n+\tDefine concrete memory resource for testing.\n+\t(__gnu_test::default_resource_mgr): Define RAII helper for changing\n+\tdefault resource.\n+\n \tPR libstdc++/86658\n \t* include/bits/stl_algobase.h (__niter_wrap<_Iterator>): Pass unused\n \tparameter by reference, to avoid copying invalid iterators."}, {"sha": "36459e88b6a46ac5b6b6dfa63adc32d96378b7d0", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e", "patch": "@@ -2039,6 +2039,11 @@ GLIBCXX_3.4.26 {\n     _ZNSt7__cxx1118basic_stringstreamI[cw]St11char_traitsI[cw]ESaI[cw]EEC[12]Ev;\n     _ZNSt7__cxx1119basic_[io]stringstreamI[cw]St11char_traitsI[cw]ESaI[cw]EEC[12]Ev;\n \n+    _ZNSt3pmr19new_delete_resourceEv;\n+    _ZNSt3pmr20null_memory_resourceEv;\n+    _ZNSt3pmr20get_default_resourceEv;\n+    _ZNSt3pmr20set_default_resourceEPNS_15memory_resourceE;\n+\n } GLIBCXX_3.4.25;\n \n # Symbols in the support library (libsupc++) have their own tag."}, {"sha": "54a2e8a380e14ee82e4cb65e45022831976b50c7", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e", "patch": "@@ -4965,7 +4965,7 @@ $as_echo \"$ac_cv_path_EGREP\" >&6; }\n   # expandable list at autoconf time; the second provides an expandable list\n   # (i.e., shell variable) at configure time.\n \n-  SUBDIRS='include libsupc++ src src/c++98 src/c++11 src/filesystem doc po testsuite python'\n+  SUBDIRS='include libsupc++ src src/c++98 src/c++11 src/c++17 src/filesystem doc po testsuite python'\n \n   # These need to be absolute paths, yet at the same time need to\n   # canonicalize only relative paths, because then amd will not unmount\n@@ -81841,7 +81841,7 @@ ac_config_files=\"$ac_config_files doc/xsl/customization.xsl\"\n # append it here.  Only modify Makefiles that have just been created.\n #\n # Also, get rid of this simulated-VPATH thing that automake does.\n-ac_config_files=\"$ac_config_files include/Makefile libsupc++/Makefile src/Makefile src/c++98/Makefile src/c++11/Makefile src/filesystem/Makefile doc/Makefile po/Makefile testsuite/Makefile python/Makefile\"\n+ac_config_files=\"$ac_config_files include/Makefile libsupc++/Makefile src/Makefile src/c++98/Makefile src/c++11/Makefile src/c++17/Makefile src/filesystem/Makefile doc/Makefile po/Makefile testsuite/Makefile python/Makefile\"\n \n \n ac_config_commands=\"$ac_config_commands generate-headers\"\n@@ -83076,6 +83076,7 @@ do\n     \"src/Makefile\") CONFIG_FILES=\"$CONFIG_FILES src/Makefile\" ;;\n     \"src/c++98/Makefile\") CONFIG_FILES=\"$CONFIG_FILES src/c++98/Makefile\" ;;\n     \"src/c++11/Makefile\") CONFIG_FILES=\"$CONFIG_FILES src/c++11/Makefile\" ;;\n+    \"src/c++17/Makefile\") CONFIG_FILES=\"$CONFIG_FILES src/c++17/Makefile\" ;;\n     \"src/filesystem/Makefile\") CONFIG_FILES=\"$CONFIG_FILES src/filesystem/Makefile\" ;;\n     \"doc/Makefile\") CONFIG_FILES=\"$CONFIG_FILES doc/Makefile\" ;;\n     \"po/Makefile\") CONFIG_FILES=\"$CONFIG_FILES po/Makefile\" ;;\n@@ -84904,6 +84905,17 @@ _EOF\n  ;;\n     \"src/c++11/Makefile\":F) cat > vpsed$$ << \\_EOF\n s!`test -f '$<' || echo '$(srcdir)/'`!!\n+_EOF\n+   sed -f vpsed$$ $ac_file > tmp$$\n+   mv tmp$$ $ac_file\n+   rm vpsed$$\n+   echo 'MULTISUBDIR =' >> $ac_file\n+   ml_norecursion=yes\n+   . ${multi_basedir}/config-ml.in\n+   { ml_norecursion=; unset ml_norecursion;}\n+ ;;\n+    \"src/c++17/Makefile\":F) cat > vpsed$$ << \\_EOF\n+s!`test -f '$<' || echo '$(srcdir)/'`!!\n _EOF\n    sed -f vpsed$$ $ac_file > tmp$$\n    mv tmp$$ $ac_file"}, {"sha": "9daa8856e708f5b3c532808519206235dc3c6ab1", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e", "patch": "@@ -54,6 +54,7 @@ std_headers = \\\n \t${std_srcdir}/locale \\\n \t${std_srcdir}/map \\\n \t${std_srcdir}/memory \\\n+\t${std_srcdir}/memory_resource \\\n \t${std_srcdir}/mutex \\\n \t${std_srcdir}/numeric \\\n \t${std_srcdir}/optional \\"}, {"sha": "a122c9cfe2cf1c5fa56fa1bdd3d0c82e5b0c2100", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e", "patch": "@@ -347,6 +347,7 @@ std_headers = \\\n \t${std_srcdir}/locale \\\n \t${std_srcdir}/map \\\n \t${std_srcdir}/memory \\\n+\t${std_srcdir}/memory_resource \\\n \t${std_srcdir}/mutex \\\n \t${std_srcdir}/numeric \\\n \t${std_srcdir}/optional \\"}, {"sha": "1f5373540522ebfc6297c54890f4459832fb678f", "filename": "libstdc++-v3/include/precompiled/stdc++.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Finclude%2Fprecompiled%2Fstdc%2B%2B.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Finclude%2Fprecompiled%2Fstdc%2B%2B.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprecompiled%2Fstdc%2B%2B.h?ref=dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e", "patch": "@@ -128,7 +128,7 @@\n // #include <execution>\n #include <filesystem>\n #include <optional>\n-// #include <memory_resource>\n+#include <memory_resource>\n #include <string_view>\n #include <variant>\n #endif"}, {"sha": "b3f8f7d94774a983e583bee97877ddb78acbf173", "filename": "libstdc++-v3/include/std/memory_resource", "status": "added", "additions": 510, "deletions": 0, "changes": 510, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory_resource", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory_resource", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory_resource?ref=dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e", "patch": "@@ -0,0 +1,510 @@\n+// <memory_resource> -*- C++ -*-\n+\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file include/memory_resource\n+ *  This is a Standard C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_MEMORY_RESOURCE\n+#define _GLIBCXX_MEMORY_RESOURCE 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus >= 201703L\n+\n+#include <bit>\t\t\t\t// __ceil2, __log2p1\n+#include <memory>\t\t\t// align, allocator_arg_t, __uses_alloc\n+#include <utility>\t\t\t// pair, index_sequence\n+#include <cstddef>\t\t\t// size_t, max_align_t\n+#include <debug/assertions.h>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+namespace pmr\n+{\n+// #define __cpp_lib_memory_resource 201603\n+\n+  class memory_resource;\n+\n+  template<typename _Tp>\n+    class polymorphic_allocator;\n+\n+  // Global memory resources\n+  memory_resource* new_delete_resource() noexcept;\n+  memory_resource* null_memory_resource() noexcept;\n+  memory_resource* set_default_resource(memory_resource* __r) noexcept;\n+  memory_resource* get_default_resource() noexcept\n+    __attribute__((__returns_nonnull__));\n+\n+  // Pool resource classes\n+  struct pool_options;\n+  class synchronized_pool_resource;\n+  class unsynchronized_pool_resource;\n+  class monotonic_buffer_resource;\n+\n+  /// Class memory_resource\n+  class memory_resource\n+  {\n+    static constexpr size_t _S_max_align = alignof(max_align_t);\n+\n+  public:\n+    memory_resource() = default;\n+    memory_resource(const memory_resource&) = default;\n+    virtual ~memory_resource() = default;\n+\n+    memory_resource& operator=(const memory_resource&) = default;\n+\n+    [[nodiscard]]\n+    void*\n+    allocate(size_t __bytes, size_t __alignment = _S_max_align)\n+    __attribute__((__returns_nonnull__,__alloc_size__(2),__alloc_align__(3)))\n+    { return do_allocate(__bytes, __alignment); }\n+\n+    void\n+    deallocate(void* __p, size_t __bytes, size_t __alignment = _S_max_align)\n+    __attribute__((__nonnull__))\n+    { return do_deallocate(__p, __bytes, __alignment); }\n+\n+    bool\n+    is_equal(const memory_resource& __other) const noexcept\n+    { return do_is_equal(__other); }\n+\n+  private:\n+    virtual void*\n+    do_allocate(size_t __bytes, size_t __alignment) = 0;\n+\n+    virtual void\n+    do_deallocate(void* __p, size_t __bytes, size_t __alignment) = 0;\n+\n+    virtual bool\n+    do_is_equal(const memory_resource& __other) const noexcept = 0;\n+  };\n+\n+  inline bool\n+  operator==(const memory_resource& __a, const memory_resource& __b) noexcept\n+  { return &__a == &__b || __a.is_equal(__b); }\n+\n+  inline bool\n+  operator!=(const memory_resource& __a, const memory_resource& __b) noexcept\n+  { return !(__a == __b); }\n+\n+\n+  // C++17 23.12.3 Class template polymorphic_allocator\n+  template<typename _Tp>\n+    class polymorphic_allocator\n+    {\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 2975. Missing case for pair construction in polymorphic allocators\n+      template<typename _Up>\n+\tstruct __not_pair { using type = void; };\n+\n+      template<typename _Up1, typename _Up2>\n+\tstruct __not_pair<pair<_Up1, _Up2>> { };\n+\n+    public:\n+      using value_type = _Tp;\n+\n+      polymorphic_allocator() noexcept\n+      : _M_resource(get_default_resource())\n+      { }\n+\n+      polymorphic_allocator(memory_resource* __r) noexcept\n+      __attribute__((__nonnull__))\n+      : _M_resource(__r)\n+      { _GLIBCXX_DEBUG_ASSERT(__r); }\n+\n+      polymorphic_allocator(const polymorphic_allocator& __other) = default;\n+\n+      template<typename _Up>\n+\tpolymorphic_allocator(const polymorphic_allocator<_Up>& __x) noexcept\n+\t: _M_resource(__x.resource())\n+\t{ }\n+\n+      polymorphic_allocator&\n+      operator=(const polymorphic_allocator&) = delete;\n+\n+      [[nodiscard]]\n+      _Tp*\n+      allocate(size_t __n)\n+      __attribute__((__returns_nonnull__))\n+      {\n+\tif (__n > (numeric_limits<size_t>::max() / sizeof(_Tp)))\n+\t  std::__throw_bad_alloc();\n+\treturn static_cast<_Tp*>(_M_resource->allocate(__n * sizeof(_Tp),\n+\t\t\t\t\t\t       alignof(_Tp)));\n+      }\n+\n+      void\n+      deallocate(_Tp* __p, size_t __n) noexcept\n+      __attribute__((__nonnull__))\n+      { _M_resource->deallocate(__p, __n * sizeof(_Tp), alignof(_Tp)); }\n+\n+      template<typename _Tp1, typename... _Args>\n+\t__attribute__((__nonnull__))\n+\ttypename __not_pair<_Tp>::type\n+\tconstruct(_Tp1* __p, _Args&&... __args)\n+\t{\n+\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t  // 2969. polymorphic_allocator::construct() shouldn't pass resource()\n+\t  auto __use_tag\n+\t    = __use_alloc<_Tp1, polymorphic_allocator, _Args...>(*this);\n+\t  _S_construct(__use_tag, __p, std::forward<_Args>(__args)...);\n+\t}\n+\n+      template<typename _Tp1, typename _Tp2,\n+\t       typename... _Args1, typename... _Args2>\n+\t__attribute__((__nonnull__))\n+\tvoid\n+\tconstruct(pair<_Tp1, _Tp2>* __p, piecewise_construct_t,\n+\t\t  tuple<_Args1...> __x, tuple<_Args2...> __y)\n+\t{\n+\t  auto __x_tag =\n+\t    __use_alloc<_Tp1, polymorphic_allocator, _Args1...>(*this);\n+\t  auto __y_tag =\n+\t    __use_alloc<_Tp2, polymorphic_allocator, _Args2...>(*this);\n+\t  index_sequence_for<_Args1...> __x_i;\n+\t  index_sequence_for<_Args2...> __y_i;\n+\n+\t  ::new(__p) pair<_Tp1, _Tp2>(piecewise_construct,\n+\t\t\t\t      _S_construct_p(__x_tag, __x, __x_i),\n+\t\t\t\t      _S_construct_p(__y_tag, __y, __y_i));\n+\t}\n+\n+      template<typename _Tp1, typename _Tp2>\n+\t__attribute__((__nonnull__))\n+\tvoid\n+\tconstruct(pair<_Tp1, _Tp2>* __p)\n+\t{ this->construct(__p, piecewise_construct, tuple<>(), tuple<>()); }\n+\n+      template<typename _Tp1, typename _Tp2, typename _Up, typename _Vp>\n+\t__attribute__((__nonnull__))\n+\tvoid\n+\tconstruct(pair<_Tp1, _Tp2>* __p, _Up&& __x, _Vp&& __y)\n+\t{\n+\t  this->construct(__p, piecewise_construct,\n+\t\t\t  forward_as_tuple(std::forward<_Up>(__x)),\n+\t\t\t  forward_as_tuple(std::forward<_Vp>(__y)));\n+\t}\n+\n+      template <typename _Tp1, typename _Tp2, typename _Up, typename _Vp>\n+\t__attribute__((__nonnull__))\n+\tvoid\n+\tconstruct(pair<_Tp1, _Tp2>* __p, const std::pair<_Up, _Vp>& __pr)\n+\t{\n+\t  this->construct(__p, piecewise_construct,\n+\t\t\t  forward_as_tuple(__pr.first),\n+\t\t\t  forward_as_tuple(__pr.second));\n+\t}\n+\n+      template<typename _Tp1, typename _Tp2, typename _Up, typename _Vp>\n+\t__attribute__((__nonnull__))\n+\tvoid\n+\tconstruct(pair<_Tp1, _Tp2>* __p, pair<_Up, _Vp>&& __pr)\n+\t{\n+\t  this->construct(__p, piecewise_construct,\n+\t\t\t  forward_as_tuple(std::forward<_Up>(__pr.first)),\n+\t\t\t  forward_as_tuple(std::forward<_Vp>(__pr.second)));\n+\t}\n+\n+      template<typename _Up>\n+\t__attribute__((__nonnull__))\n+\tvoid\n+\tdestroy(_Up* __p)\n+\t{ __p->~_Up(); }\n+\n+      polymorphic_allocator\n+      select_on_container_copy_construction() const noexcept\n+      { return polymorphic_allocator(); }\n+\n+      memory_resource*\n+      resource() const noexcept\n+      __attribute__((__returns_nonnull__))\n+      { return _M_resource; }\n+\n+    private:\n+      using __uses_alloc1_ = __uses_alloc1<polymorphic_allocator>;\n+      using __uses_alloc2_ = __uses_alloc2<polymorphic_allocator>;\n+\n+      template<typename _Tp1, typename... _Args>\n+\tstatic void\n+\t_S_construct(__uses_alloc0, _Tp1* __p, _Args&&... __args)\n+\t{ ::new(__p) _Tp1(std::forward<_Args>(__args)...); }\n+\n+      template<typename _Tp1, typename... _Args>\n+\tstatic void\n+\t_S_construct(__uses_alloc1_ __ua, _Tp1* __p, _Args&&... __args)\n+\t{\n+\t  ::new(__p) _Tp1(allocator_arg, *__ua._M_a,\n+\t\t\t  std::forward<_Args>(__args)...);\n+\t}\n+\n+      template<typename _Tp1, typename... _Args>\n+\tstatic void\n+\t_S_construct(__uses_alloc2_ __ua, _Tp1* __p, _Args&&... __args)\n+\t{ ::new(__p) _Tp1(std::forward<_Args>(__args)..., *__ua._M_a); }\n+\n+      template<typename _Ind, typename... _Args>\n+\tstatic tuple<_Args&&...>\n+\t_S_construct_p(__uses_alloc0, _Ind, tuple<_Args...>& __t)\n+\t{ return std::move(__t); }\n+\n+      template<size_t... _Ind, typename... _Args>\n+\tstatic tuple<allocator_arg_t, polymorphic_allocator&, _Args&&...>\n+\t_S_construct_p(__uses_alloc1_ __ua, index_sequence<_Ind...>,\n+\t\t       tuple<_Args...>& __t)\n+\t{\n+\t  return {\n+\t      allocator_arg, *__ua._M_a, std::get<_Ind>(std::move(__t))...\n+\t  };\n+\t}\n+\n+      template<size_t... _Ind, typename... _Args>\n+\tstatic tuple<_Args&&..., polymorphic_allocator&>\n+\t_S_construct_p(__uses_alloc2_ __ua, index_sequence<_Ind...>,\n+\t\t       tuple<_Args...>& __t)\n+\t{ return { std::get<_Ind>(std::move(__t))..., *__ua._M_a }; }\n+\n+      memory_resource* _M_resource;\n+    };\n+\n+  template<typename _Tp1, typename _Tp2>\n+    inline bool\n+    operator==(const polymorphic_allocator<_Tp1>& __a,\n+\t       const polymorphic_allocator<_Tp2>& __b) noexcept\n+    { return *__a.resource() == *__b.resource(); }\n+\n+  template<typename _Tp1, typename _Tp2>\n+    inline bool\n+    operator!=(const polymorphic_allocator<_Tp1>& __a,\n+\t       const polymorphic_allocator<_Tp2>& __b) noexcept\n+    { return !(__a == __b); }\n+\n+\n+  struct pool_options\n+  {\n+    size_t max_blocks_per_chunk = 0;\n+    size_t largest_required_pool_block = 0;\n+  };\n+\n+  // TODO class synchronized_pool_resource;\n+  // TODO class unsynchronized_pool_resource;\n+\n+  class monotonic_buffer_resource : public memory_resource\n+  {\n+  public:\n+    explicit\n+    monotonic_buffer_resource(memory_resource* __upstream) noexcept\n+    __attribute__((__nonnull__))\n+    : _M_upstream(__upstream)\n+    { _GLIBCXX_DEBUG_ASSERT(__upstream != nullptr); }\n+\n+    monotonic_buffer_resource(size_t __initial_size,\n+\t\t\t      memory_resource* __upstream) noexcept\n+    __attribute__((__nonnull__))\n+    : _M_next_bufsiz(__initial_size),\n+      _M_upstream(__upstream)\n+    {\n+      _GLIBCXX_DEBUG_ASSERT(__upstream != nullptr);\n+      _GLIBCXX_DEBUG_ASSERT(__initial_size > 0);\n+    }\n+\n+    monotonic_buffer_resource(void* __buffer, size_t __buffer_size,\n+\t\t\t      memory_resource* __upstream) noexcept\n+    __attribute__((__nonnull__(4)))\n+    : _M_current_buf(__buffer), _M_avail(__buffer_size),\n+      _M_next_bufsiz(_S_next_bufsize(__buffer_size)),\n+      _M_upstream(__upstream),\n+      _M_orig_buf(__buffer), _M_orig_size(__buffer_size)\n+    {\n+      _GLIBCXX_DEBUG_ASSERT(__upstream != nullptr);\n+      _GLIBCXX_DEBUG_ASSERT(__buffer != nullptr || __buffer_size == 0);\n+    }\n+\n+    monotonic_buffer_resource() noexcept\n+    : monotonic_buffer_resource(get_default_resource())\n+    { }\n+\n+    explicit\n+    monotonic_buffer_resource(size_t __initial_size) noexcept\n+    : monotonic_buffer_resource(__initial_size, get_default_resource())\n+    { }\n+\n+    monotonic_buffer_resource(void* __buffer, size_t __buffer_size) noexcept\n+    : monotonic_buffer_resource(__buffer, __buffer_size, get_default_resource())\n+    { }\n+\n+    monotonic_buffer_resource(const monotonic_buffer_resource&) = delete;\n+\n+    virtual ~monotonic_buffer_resource() { release(); }\n+\n+    monotonic_buffer_resource&\n+    operator=(const monotonic_buffer_resource&) = delete;\n+\n+    void\n+    release() noexcept\n+    {\n+      _Chunk::release(_M_head, _M_upstream);\n+\n+      // reset to initial state at contruction:\n+      if ((_M_current_buf = _M_orig_buf))\n+\t{\n+\t  _M_avail = _M_orig_size;\n+\t  _M_next_bufsiz = _S_next_bufsize(_M_orig_size);\n+\t}\n+      else\n+\t{\n+\t  _M_avail = 0;\n+\t  _M_next_bufsiz = _M_orig_size;\n+\t}\n+    }\n+\n+    memory_resource*\n+    upstream_resource() const noexcept\n+    __attribute__((__returns_nonnull__))\n+    { return _M_upstream; }\n+\n+  protected:\n+    void*\n+    do_allocate(size_t __bytes, size_t __alignment) override\n+    {\n+      if (__bytes == 0)\n+\t__bytes = 1; // Ensures we don't return the same pointer twice.\n+\n+      if (auto __p = std::align(__alignment, __bytes, _M_current_buf, _M_avail))\n+\t{\n+\t  _M_current_buf = (char*)_M_current_buf + __bytes;\n+\t  _M_avail -= __bytes;\n+\t  return __p;\n+\t}\n+\n+      const size_t __n = std::max(__bytes, _M_next_bufsiz);\n+      const size_t __m = std::max(__alignment, alignof(std::max_align_t));\n+      auto [__p, __size] = _Chunk::allocate(_M_upstream, __n, __m, _M_head);\n+      _M_current_buf = (char*)__p + __bytes;\n+      _M_avail = __size - __bytes;\n+      _M_next_bufsiz *= _S_growth_factor;\n+      return __p;\n+    }\n+\n+    void\n+    do_deallocate(void*, size_t, size_t) override\n+    { }\n+\n+    bool\n+    do_is_equal(const memory_resource& __other) const noexcept override\n+    { return this == &__other; }\n+\n+  private:\n+    static size_t\n+    _S_next_bufsize(size_t __buffer_size) noexcept\n+    {\n+      if (__buffer_size == 0)\n+\t__buffer_size = 1;\n+      return __buffer_size * _S_growth_factor;\n+    }\n+\n+    static constexpr size_t _S_init_bufsize = 128 * sizeof(void*);\n+    static constexpr float _S_growth_factor = 1.5;\n+\n+    void*\t_M_current_buf = nullptr;\n+    size_t\t_M_avail = 0;\n+    size_t\t_M_next_bufsiz = _S_init_bufsize;\n+\n+    // Initial values set at construction and reused by release():\n+    memory_resource* const\t_M_upstream;\n+    void* const\t\t\t_M_orig_buf = nullptr;\n+    size_t const\t\t_M_orig_size = _M_next_bufsiz;\n+\n+    // Memory allocated by the upstream resource is managed in a linked list\n+    // of _Chunk objects. A _Chunk object recording the size and alignment of\n+    // the allocated block and a pointer to the previous chunk is placed\n+    // at end of the block.\n+    class _Chunk\n+    {\n+    public:\n+      // Return the address and size of a block of memory allocated from __r,\n+      // of at least __size bytes and aligned to __align.\n+      // Add a new _Chunk to the front of the linked list at __head.\n+      static pair<void*, size_t>\n+      allocate(memory_resource* __r, size_t __size, size_t __align,\n+\t       _Chunk*& __head)\n+      {\n+\t__size = std::__ceil2(__size + sizeof(_Chunk));\n+\tvoid* __p = __r->allocate(__size, __align);\n+\t// Add a chunk defined by (__p, __size, __align) to linked list __head.\n+\tvoid* const __back = (char*)__p + __size - sizeof(_Chunk);\n+\t__head = ::new(__back) _Chunk(__size, __align, __head);\n+\treturn { __p, __size - sizeof(_Chunk) };\n+      }\n+\n+      // Return every chunk in linked list __head to resource __r.\n+      static void\n+      release(_Chunk*& __head, memory_resource* __r) noexcept\n+      {\n+\t_Chunk* __next = __head;\n+\t__head = nullptr;\n+\twhile (__next)\n+\t  {\n+\t    _Chunk* __ch = __next;\n+\t    __builtin_memcpy(&__next, __ch->_M_next, sizeof(_Chunk*));\n+\n+\t    __glibcxx_assert(__ch->_M_canary != 0);\n+\t    __glibcxx_assert(__ch->_M_canary == (__ch->_M_size|__ch->_M_align));\n+\n+\t    if (__ch->_M_canary != (__ch->_M_size | __ch->_M_align))\n+\t      return; // buffer overflow detected!\n+\n+\t    size_t __size = (1u << __ch->_M_size);\n+\t    size_t __align = (1u << __ch->_M_align);\n+\t    void* __start = (char*)(__ch + 1) - __size;\n+\t    __r->deallocate(__start, __size, __align);\n+\t  }\n+      }\n+\n+    private:\n+      _Chunk(size_t __size, size_t __align, _Chunk* __next) noexcept\n+      : _M_size(std::__log2p1(__size) - 1),\n+\t_M_align(std::__log2p1(__align) - 1)\n+      {\n+\t__builtin_memcpy(_M_next, &__next, sizeof(__next));\n+\t_M_canary = _M_size | _M_align;\n+      }\n+\n+      unsigned char _M_canary;\n+      unsigned char _M_size;\n+      unsigned char _M_align;\n+      unsigned char _M_next[sizeof(_Chunk*)];\n+    };\n+    static_assert(alignof(_Chunk) == 1);\n+\n+    _Chunk* _M_head = nullptr;\n+  };\n+\n+} // namespace pmr\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+\n+#endif // C++17\n+#endif // _GLIBCXX_MEMORY_RESOURCE"}, {"sha": "09edcdbc471d9fedabe4a2b20b110c79955c8c52", "filename": "libstdc++-v3/src/Makefile.am", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am?ref=dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e", "patch": "@@ -28,7 +28,7 @@ else\n filesystem_dir =\n endif\n \n-SUBDIRS = c++98 c++11 $(filesystem_dir)\n+SUBDIRS = c++98 c++11 c++17 $(filesystem_dir)\n \n # Cross compiler support.\n if VTV_CYGMIN\n@@ -58,6 +58,7 @@ endif\n \n vpath % $(top_srcdir)/src/c++98\n vpath % $(top_srcdir)/src/c++11\n+vpath % $(top_srcdir)/src/c++17\n if ENABLE_FILESYSTEM_TS\n vpath % $(top_srcdir)/src/filesystem\n endif\n@@ -92,13 +93,15 @@ libstdc___la_LIBADD = \\\n \t$(GLIBCXX_LIBS) \\\n \t$(top_builddir)/libsupc++/libsupc++convenience.la \\\n \t$(top_builddir)/src/c++98/libc++98convenience.la \\\n-\t$(top_builddir)/src/c++11/libc++11convenience.la\n+\t$(top_builddir)/src/c++11/libc++11convenience.la \\\n+\t$(top_builddir)/src/c++17/libc++17convenience.la\n \n libstdc___la_DEPENDENCIES = \\\n \t${version_dep} \\\n \t$(top_builddir)/libsupc++/libsupc++convenience.la \\\n \t$(top_builddir)/src/c++98/libc++98convenience.la \\\n-\t$(top_builddir)/src/c++11/libc++11convenience.la\n+\t$(top_builddir)/src/c++11/libc++11convenience.la \\\n+\t$(top_builddir)/src/c++17/libc++17convenience.la\n \n libstdc___la_LDFLAGS = \\\n \t-version-info $(libtool_VERSION) ${version_arg} -lm\n@@ -148,8 +151,8 @@ compatibility-condvar.o: compatibility-condvar.cc\n # Thus, the shared libs have more compat symbols, which can be found\n # segregated in the sources with -D_GLIBCXX_SHARED.\n #\n-# In the sub-directories of libsupc++, src/c++98, src/c++11, only\n-# -prefer-pic objects are generated for the convenience libraries.\n+# In the sub-directories of libsupc++, src/c++98, src/c++11, src/c++17,\n+# only -prefer-pic objects are generated for the convenience libraries.\n #\n # In the main src directory, make shared and static objects just for\n # the compat libraries. Shared objects are compiled with -prefer-pic"}, {"sha": "901533e528b9267b9705b20e0016486f60c0d042", "filename": "libstdc++-v3/src/Makefile.in", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in?ref=dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e", "patch": "@@ -152,7 +152,7 @@ AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \\\n \t$(RECURSIVE_CLEAN_TARGETS:-recursive=) tags TAGS ctags CTAGS\n ETAGS = etags\n CTAGS = ctags\n-DIST_SUBDIRS = c++98 c++11 filesystem\n+DIST_SUBDIRS = c++98 c++11 c++17 filesystem\n ABI_TWEAKS_SRCDIR = @ABI_TWEAKS_SRCDIR@\n ACLOCAL = @ACLOCAL@\n ALLOCATOR_H = @ALLOCATOR_H@\n@@ -379,7 +379,7 @@ WARN_CXXFLAGS = \\\n AM_CPPFLAGS = $(GLIBCXX_INCLUDES) $(CPPFLAGS)\n @ENABLE_FILESYSTEM_TS_FALSE@filesystem_dir = \n @ENABLE_FILESYSTEM_TS_TRUE@filesystem_dir = filesystem\n-SUBDIRS = c++98 c++11 $(filesystem_dir)\n+SUBDIRS = c++98 c++11 c++17 $(filesystem_dir)\n @VTV_CYGMIN_FALSE@toolexeclib_LTLIBRARIES = libstdc++.la\n \n # Cross compiler support.\n@@ -419,13 +419,15 @@ libstdc___la_LIBADD = \\\n \t$(GLIBCXX_LIBS) \\\n \t$(top_builddir)/libsupc++/libsupc++convenience.la \\\n \t$(top_builddir)/src/c++98/libc++98convenience.la \\\n-\t$(top_builddir)/src/c++11/libc++11convenience.la\n+\t$(top_builddir)/src/c++11/libc++11convenience.la \\\n+\t$(top_builddir)/src/c++17/libc++17convenience.la\n \n libstdc___la_DEPENDENCIES = \\\n \t${version_dep} \\\n \t$(top_builddir)/libsupc++/libsupc++convenience.la \\\n \t$(top_builddir)/src/c++98/libc++98convenience.la \\\n-\t$(top_builddir)/src/c++11/libc++11convenience.la\n+\t$(top_builddir)/src/c++11/libc++11convenience.la \\\n+\t$(top_builddir)/src/c++17/libc++17convenience.la\n \n libstdc___la_LDFLAGS = \\\n \t-version-info $(libtool_VERSION) ${version_arg} -lm\n@@ -440,8 +442,8 @@ libstdc___la_LINK = $(CXXLINK) $(libstdc___la_LDFLAGS)\n # Thus, the shared libs have more compat symbols, which can be found\n # segregated in the sources with -D_GLIBCXX_SHARED.\n #\n-# In the sub-directories of libsupc++, src/c++98, src/c++11, only\n-# -prefer-pic objects are generated for the convenience libraries.\n+# In the sub-directories of libsupc++, src/c++98, src/c++11, src/c++17,\n+# only -prefer-pic objects are generated for the convenience libraries.\n #\n # In the main src directory, make shared and static objects just for\n # the compat libraries. Shared objects are compiled with -prefer-pic\n@@ -900,6 +902,7 @@ uninstall-am: uninstall-toolexeclibLTLIBRARIES\n \n vpath % $(top_srcdir)/src/c++98\n vpath % $(top_srcdir)/src/c++11\n+vpath % $(top_srcdir)/src/c++17\n @ENABLE_FILESYSTEM_TS_TRUE@vpath % $(top_srcdir)/src/filesystem\n \n # Use special rules for compatibility-ldbl.cc compilation, as we need to"}, {"sha": "a22258782cb0483bc074ea469690e5d69c5e6f7e", "filename": "libstdc++-v3/src/c++11/Makefile.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2FMakefile.am?ref=dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e", "patch": "@@ -1,4 +1,4 @@\n-## Makefile for the C++03 sources of the GNU C++ Standard library.\n+## Makefile for the C++11 sources of the GNU C++ Standard library.\n ##\n ## Copyright (C) 1997-2018 Free Software Foundation, Inc.\n ##"}, {"sha": "21b64b52dc272e32595888c88ec5512d0092e413", "filename": "libstdc++-v3/src/c++17/Makefile.am", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2FMakefile.am?ref=dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e", "patch": "@@ -0,0 +1,111 @@\n+## Makefile for the C++17 sources of the GNU C++ Standard library.\n+##\n+## Copyright (C) 1997-2018 Free Software Foundation, Inc.\n+##\n+## This file is part of the libstdc++ version 3 distribution.\n+## Process this file with automake to produce Makefile.in.\n+\n+## This file is part of the GNU ISO C++ Library.  This library is free\n+## software; you can redistribute it and/or modify it under the\n+## terms of the GNU General Public License as published by the\n+## Free Software Foundation; either version 3, or (at your option)\n+## any later version.\n+\n+## This library is distributed in the hope that it will be useful,\n+## but WITHOUT ANY WARRANTY; without even the implied warranty of\n+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+## GNU General Public License for more details.\n+\n+## You should have received a copy of the GNU General Public License along\n+## with this library; see the file COPYING3.  If not see\n+## <http://www.gnu.org/licenses/>.\n+\n+include $(top_srcdir)/fragment.am\n+\n+# Convenience library for C++17 runtime.\n+noinst_LTLIBRARIES = libc++17convenience.la\n+\n+headers =\n+\n+sources = \\\n+\tmemory_resource.cc\n+\n+if ENABLE_DUAL_ABI\n+extra_string_inst_sources =\n+else\n+extra_string_inst_sources =\n+endif\n+\n+if ENABLE_EXTERN_TEMPLATE\n+# XTEMPLATE_FLAGS = -fno-implicit-templates\n+inst_sources = \\\n+\t$(extra_string_inst_sources)\n+else\n+# XTEMPLATE_FLAGS =\n+inst_sources =\n+endif\n+\n+vpath % $(top_srcdir)/src/c++17\n+\n+libc__17convenience_la_SOURCES = $(sources)  $(inst_sources)\n+\n+# AM_CXXFLAGS needs to be in each subdirectory so that it can be\n+# modified in a per-library or per-sub-library way.  Need to manually\n+# set this option because CONFIG_CXXFLAGS has to be after\n+# OPTIMIZE_CXXFLAGS on the compile line so that -O2 can be overridden\n+# as the occasion calls for it.\n+AM_CXXFLAGS = \\\n+\t-std=gnu++17 \\\n+\t$(glibcxx_lt_pic_flag) $(glibcxx_compiler_shared_flag) \\\n+\t$(XTEMPLATE_FLAGS) $(VTV_CXXFLAGS) \\\n+\t$(WARN_CXXFLAGS) $(OPTIMIZE_CXXFLAGS) $(CONFIG_CXXFLAGS)\n+\n+AM_MAKEFLAGS = \\\n+\t\"gxx_include_dir=$(gxx_include_dir)\"\n+\n+# Libtool notes\n+\n+# 1) In general, libtool expects an argument such as `--tag=CXX' when\n+# using the C++ compiler, because that will enable the settings\n+# detected when C++ support was being configured.  However, when no\n+# such flag is given in the command line, libtool attempts to figure\n+# it out by matching the compiler name in each configuration section\n+# against a prefix of the command line.  The problem is that, if the\n+# compiler name and its initial flags stored in the libtool\n+# configuration file don't match those in the command line, libtool\n+# can't decide which configuration to use, and it gives up.  The\n+# correct solution is to add `--tag CXX' to LTCXXCOMPILE and maybe\n+# CXXLINK, just after $(LIBTOOL), so that libtool doesn't have to\n+# attempt to infer which configuration to use.\n+#\n+# The second tag argument, `--tag disable-shared` means that libtool\n+# only compiles each source once, for static objects. In actuality,\n+# glibcxx_lt_pic_flag and glibcxx_compiler_shared_flag are added to\n+# the libtool command that is used create the object, which is\n+# suitable for shared libraries.  The `--tag disable-shared` must be\n+# placed after --tag CXX lest things CXX undo the affect of\n+# disable-shared.\n+\n+# 2) Need to explicitly set LTCXXCOMPILE so that EXTRA_CXX_FLAGS is\n+# last. (That way, things like -O2 passed down from the toplevel can\n+# be overridden by --enable-debug.)\n+LTCXXCOMPILE = \\\n+\t$(LIBTOOL) --tag CXX --tag disable-shared \\\n+\t$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=compile $(CXX) $(TOPLEVEL_INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) $(EXTRA_CXX_FLAGS)\n+\n+LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS))\n+\n+# 3) We'd have a problem when building the shared libstdc++ object if\n+# the rules automake generates would be used.  We cannot allow g++ to\n+# be used since this would add -lstdc++ to the link line which of\n+# course is problematic at this point.  So, we get the top-level\n+# directory to configure libstdc++-v3 to use gcc as the C++\n+# compilation driver.\n+CXXLINK = \\\n+\t$(LIBTOOL) --tag CXX --tag disable-shared \\\n+\t$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CXX) \\\n+\t$(VTV_CXXLINKFLAGS) \\\n+\t$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LTLDFLAGS) -o $@"}, {"sha": "40b186e0a775ada75a839174378e750e8f9fe078", "filename": "libstdc++-v3/src/c++17/Makefile.in", "status": "added", "additions": 654, "deletions": 0, "changes": 654, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2FMakefile.in?ref=dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e", "patch": "@@ -0,0 +1,654 @@\n+# Makefile.in generated by automake 1.11.6 from Makefile.am.\n+# @configure_input@\n+\n+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n+# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software\n+# Foundation, Inc.\n+# This Makefile.in is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+@SET_MAKE@\n+\n+VPATH = @srcdir@\n+am__make_dryrun = \\\n+  { \\\n+    am__dry=no; \\\n+    case $$MAKEFLAGS in \\\n+      *\\\\[\\ \\\t]*) \\\n+        echo 'am--echo: ; @echo \"AM\"  OK' | $(MAKE) -f - 2>/dev/null \\\n+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \\\n+      *) \\\n+        for am__flg in $$MAKEFLAGS; do \\\n+          case $$am__flg in \\\n+            *=*|--*) ;; \\\n+            *n*) am__dry=yes; break;; \\\n+          esac; \\\n+        done;; \\\n+    esac; \\\n+    test $$am__dry = yes; \\\n+  }\n+pkgdatadir = $(datadir)/@PACKAGE@\n+pkgincludedir = $(includedir)/@PACKAGE@\n+pkglibdir = $(libdir)/@PACKAGE@\n+pkglibexecdir = $(libexecdir)/@PACKAGE@\n+am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n+install_sh_DATA = $(install_sh) -c -m 644\n+install_sh_PROGRAM = $(install_sh) -c\n+install_sh_SCRIPT = $(install_sh) -c\n+INSTALL_HEADER = $(INSTALL_DATA)\n+transform = $(program_transform_name)\n+NORMAL_INSTALL = :\n+PRE_INSTALL = :\n+POST_INSTALL = :\n+NORMAL_UNINSTALL = :\n+PRE_UNINSTALL = :\n+POST_UNINSTALL = :\n+build_triplet = @build@\n+host_triplet = @host@\n+target_triplet = @target@\n+DIST_COMMON = $(top_srcdir)/fragment.am $(srcdir)/Makefile.in \\\n+\t$(srcdir)/Makefile.am\n+subdir = src/c++17\n+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n+am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \\\n+\t$(top_srcdir)/../config/enable.m4 \\\n+\t$(top_srcdir)/../config/futex.m4 \\\n+\t$(top_srcdir)/../config/hwcaps.m4 \\\n+\t$(top_srcdir)/../config/iconv.m4 \\\n+\t$(top_srcdir)/../config/lead-dot.m4 \\\n+\t$(top_srcdir)/../config/lib-ld.m4 \\\n+\t$(top_srcdir)/../config/lib-link.m4 \\\n+\t$(top_srcdir)/../config/lib-prefix.m4 \\\n+\t$(top_srcdir)/../config/lthostflags.m4 \\\n+\t$(top_srcdir)/../config/multi.m4 \\\n+\t$(top_srcdir)/../config/no-executables.m4 \\\n+\t$(top_srcdir)/../config/override.m4 \\\n+\t$(top_srcdir)/../config/stdint.m4 \\\n+\t$(top_srcdir)/../config/unwind_ipinfo.m4 \\\n+\t$(top_srcdir)/../libtool.m4 $(top_srcdir)/../ltoptions.m4 \\\n+\t$(top_srcdir)/../ltsugar.m4 $(top_srcdir)/../ltversion.m4 \\\n+\t$(top_srcdir)/../lt~obsolete.m4 $(top_srcdir)/crossconfig.m4 \\\n+\t$(top_srcdir)/linkage.m4 $(top_srcdir)/acinclude.m4 \\\n+\t$(top_srcdir)/../config/gc++filt.m4 \\\n+\t$(top_srcdir)/../config/tls.m4 $(top_srcdir)/../config/gthr.m4 \\\n+\t$(top_srcdir)/../config/cet.m4 $(top_srcdir)/configure.ac\n+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n+\t$(ACLOCAL_M4)\n+CONFIG_HEADER = $(top_builddir)/config.h\n+CONFIG_CLEAN_FILES =\n+CONFIG_CLEAN_VPATH_FILES =\n+LTLIBRARIES = $(noinst_LTLIBRARIES)\n+libc__17convenience_la_LIBADD =\n+am__objects_1 = memory_resource.lo\n+am__objects_2 =\n+@ENABLE_EXTERN_TEMPLATE_TRUE@am__objects_3 = $(am__objects_2)\n+am_libc__17convenience_la_OBJECTS = $(am__objects_1) $(am__objects_3)\n+libc__17convenience_la_OBJECTS = $(am_libc__17convenience_la_OBJECTS)\n+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)\n+depcomp =\n+am__depfiles_maybe =\n+CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n+CXXLD = $(CXX)\n+SOURCES = $(libc__17convenience_la_SOURCES)\n+am__can_run_installinfo = \\\n+  case $$AM_UPDATE_INFO_DIR in \\\n+    n|no|NO) false;; \\\n+    *) (install-info --version) >/dev/null 2>&1;; \\\n+  esac\n+ETAGS = etags\n+CTAGS = ctags\n+ABI_TWEAKS_SRCDIR = @ABI_TWEAKS_SRCDIR@\n+ACLOCAL = @ACLOCAL@\n+ALLOCATOR_H = @ALLOCATOR_H@\n+ALLOCATOR_NAME = @ALLOCATOR_NAME@\n+AMTAR = @AMTAR@\n+AR = @AR@\n+AS = @AS@\n+ATOMICITY_SRCDIR = @ATOMICITY_SRCDIR@\n+ATOMIC_FLAGS = @ATOMIC_FLAGS@\n+ATOMIC_WORD_SRCDIR = @ATOMIC_WORD_SRCDIR@\n+AUTOCONF = @AUTOCONF@\n+AUTOHEADER = @AUTOHEADER@\n+AUTOMAKE = @AUTOMAKE@\n+AWK = @AWK@\n+BASIC_FILE_CC = @BASIC_FILE_CC@\n+BASIC_FILE_H = @BASIC_FILE_H@\n+CC = @CC@\n+CCODECVT_CC = @CCODECVT_CC@\n+CCOLLATE_CC = @CCOLLATE_CC@\n+CCTYPE_CC = @CCTYPE_CC@\n+CFLAGS = @CFLAGS@\n+CLOCALE_CC = @CLOCALE_CC@\n+CLOCALE_H = @CLOCALE_H@\n+CLOCALE_INTERNAL_H = @CLOCALE_INTERNAL_H@\n+CMESSAGES_CC = @CMESSAGES_CC@\n+CMESSAGES_H = @CMESSAGES_H@\n+CMONEY_CC = @CMONEY_CC@\n+CNUMERIC_CC = @CNUMERIC_CC@\n+CPP = @CPP@\n+CPPFLAGS = @CPPFLAGS@\n+CPU_DEFINES_SRCDIR = @CPU_DEFINES_SRCDIR@\n+CPU_OPT_BITS_RANDOM = @CPU_OPT_BITS_RANDOM@\n+CPU_OPT_EXT_RANDOM = @CPU_OPT_EXT_RANDOM@\n+CSTDIO_H = @CSTDIO_H@\n+CTIME_CC = @CTIME_CC@\n+CTIME_H = @CTIME_H@\n+CXX = @CXX@\n+CXXCPP = @CXXCPP@\n+CXXFILT = @CXXFILT@\n+CXXFLAGS = @CXXFLAGS@\n+CYGPATH_W = @CYGPATH_W@\n+C_INCLUDE_DIR = @C_INCLUDE_DIR@\n+DBLATEX = @DBLATEX@\n+DEBUG_FLAGS = @DEBUG_FLAGS@\n+DEFS = @DEFS@\n+DOT = @DOT@\n+DOXYGEN = @DOXYGEN@\n+DSYMUTIL = @DSYMUTIL@\n+DUMPBIN = @DUMPBIN@\n+ECHO_C = @ECHO_C@\n+ECHO_N = @ECHO_N@\n+ECHO_T = @ECHO_T@\n+EGREP = @EGREP@\n+ERROR_CONSTANTS_SRCDIR = @ERROR_CONSTANTS_SRCDIR@\n+EXEEXT = @EXEEXT@\n+EXTRA_CFLAGS = @EXTRA_CFLAGS@\n+EXTRA_CXX_FLAGS = @EXTRA_CXX_FLAGS@\n+FGREP = @FGREP@\n+GLIBCXX_INCLUDES = @GLIBCXX_INCLUDES@\n+GLIBCXX_LIBS = @GLIBCXX_LIBS@\n+GREP = @GREP@\n+HWCAP_CFLAGS = @HWCAP_CFLAGS@\n+INSTALL = @INSTALL@\n+INSTALL_DATA = @INSTALL_DATA@\n+INSTALL_PROGRAM = @INSTALL_PROGRAM@\n+INSTALL_SCRIPT = @INSTALL_SCRIPT@\n+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n+LD = @LD@\n+LDFLAGS = @LDFLAGS@\n+LIBICONV = @LIBICONV@\n+LIBOBJS = @LIBOBJS@\n+LIBS = @LIBS@\n+LIBTOOL = @LIBTOOL@\n+LIPO = @LIPO@\n+LN_S = @LN_S@\n+LONG_DOUBLE_COMPAT_FLAGS = @LONG_DOUBLE_COMPAT_FLAGS@\n+LTLIBICONV = @LTLIBICONV@\n+LTLIBOBJS = @LTLIBOBJS@\n+MAINT = @MAINT@\n+MAKEINFO = @MAKEINFO@\n+MKDIR_P = @MKDIR_P@\n+NM = @NM@\n+NMEDIT = @NMEDIT@\n+OBJDUMP = @OBJDUMP@\n+OBJEXT = @OBJEXT@\n+OPTIMIZE_CXXFLAGS = @OPTIMIZE_CXXFLAGS@\n+OPT_LDFLAGS = @OPT_LDFLAGS@\n+OS_INC_SRCDIR = @OS_INC_SRCDIR@\n+OTOOL = @OTOOL@\n+OTOOL64 = @OTOOL64@\n+PACKAGE = @PACKAGE@\n+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n+PACKAGE_NAME = @PACKAGE_NAME@\n+PACKAGE_STRING = @PACKAGE_STRING@\n+PACKAGE_TARNAME = @PACKAGE_TARNAME@\n+PACKAGE_URL = @PACKAGE_URL@\n+PACKAGE_VERSION = @PACKAGE_VERSION@\n+PATH_SEPARATOR = @PATH_SEPARATOR@\n+PDFLATEX = @PDFLATEX@\n+RANLIB = @RANLIB@\n+SECTION_FLAGS = @SECTION_FLAGS@\n+SECTION_LDFLAGS = @SECTION_LDFLAGS@\n+SED = @SED@\n+SET_MAKE = @SET_MAKE@\n+SHELL = @SHELL@\n+STRIP = @STRIP@\n+SYMVER_FILE = @SYMVER_FILE@\n+TOPLEVEL_INCLUDES = @TOPLEVEL_INCLUDES@\n+USE_NLS = @USE_NLS@\n+VERSION = @VERSION@\n+VTV_CXXFLAGS = @VTV_CXXFLAGS@\n+VTV_CXXLINKFLAGS = @VTV_CXXLINKFLAGS@\n+VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@\n+WARN_FLAGS = @WARN_FLAGS@\n+WERROR = @WERROR@\n+XMLLINT = @XMLLINT@\n+XSLTPROC = @XSLTPROC@\n+XSL_STYLE_DIR = @XSL_STYLE_DIR@\n+abs_builddir = @abs_builddir@\n+abs_srcdir = @abs_srcdir@\n+abs_top_builddir = @abs_top_builddir@\n+abs_top_srcdir = @abs_top_srcdir@\n+ac_ct_CC = @ac_ct_CC@\n+ac_ct_CXX = @ac_ct_CXX@\n+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n+am__leading_dot = @am__leading_dot@\n+am__tar = @am__tar@\n+am__untar = @am__untar@\n+baseline_dir = @baseline_dir@\n+baseline_subdir_switch = @baseline_subdir_switch@\n+bindir = @bindir@\n+build = @build@\n+build_alias = @build_alias@\n+build_cpu = @build_cpu@\n+build_os = @build_os@\n+build_vendor = @build_vendor@\n+builddir = @builddir@\n+check_msgfmt = @check_msgfmt@\n+datadir = @datadir@\n+datarootdir = @datarootdir@\n+docdir = @docdir@\n+dvidir = @dvidir@\n+enable_shared = @enable_shared@\n+enable_static = @enable_static@\n+exec_prefix = @exec_prefix@\n+get_gcc_base_ver = @get_gcc_base_ver@\n+glibcxx_MOFILES = @glibcxx_MOFILES@\n+glibcxx_PCHFLAGS = @glibcxx_PCHFLAGS@\n+glibcxx_POFILES = @glibcxx_POFILES@\n+glibcxx_builddir = @glibcxx_builddir@\n+glibcxx_compiler_pic_flag = @glibcxx_compiler_pic_flag@\n+glibcxx_compiler_shared_flag = @glibcxx_compiler_shared_flag@\n+glibcxx_cxx98_abi = @glibcxx_cxx98_abi@\n+glibcxx_localedir = @glibcxx_localedir@\n+glibcxx_lt_pic_flag = @glibcxx_lt_pic_flag@\n+glibcxx_prefixdir = @glibcxx_prefixdir@\n+glibcxx_srcdir = @glibcxx_srcdir@\n+glibcxx_toolexecdir = @glibcxx_toolexecdir@\n+glibcxx_toolexeclibdir = @glibcxx_toolexeclibdir@\n+gxx_include_dir = @gxx_include_dir@\n+host = @host@\n+host_alias = @host_alias@\n+host_cpu = @host_cpu@\n+host_os = @host_os@\n+host_vendor = @host_vendor@\n+htmldir = @htmldir@\n+includedir = @includedir@\n+infodir = @infodir@\n+install_sh = @install_sh@\n+libdir = @libdir@\n+libexecdir = @libexecdir@\n+libtool_VERSION = @libtool_VERSION@\n+localedir = @localedir@\n+localstatedir = @localstatedir@\n+lt_host_flags = @lt_host_flags@\n+mandir = @mandir@\n+mkdir_p = @mkdir_p@\n+multi_basedir = @multi_basedir@\n+oldincludedir = @oldincludedir@\n+pdfdir = @pdfdir@\n+port_specific_symbol_files = @port_specific_symbol_files@\n+prefix = @prefix@\n+program_transform_name = @program_transform_name@\n+psdir = @psdir@\n+python_mod_dir = @python_mod_dir@\n+sbindir = @sbindir@\n+sharedstatedir = @sharedstatedir@\n+srcdir = @srcdir@\n+sysconfdir = @sysconfdir@\n+target = @target@\n+target_alias = @target_alias@\n+target_cpu = @target_cpu@\n+target_os = @target_os@\n+target_vendor = @target_vendor@\n+thread_header = @thread_header@\n+top_build_prefix = @top_build_prefix@\n+top_builddir = @top_builddir@\n+top_srcdir = @top_srcdir@\n+toplevel_builddir = @toplevel_builddir@\n+toplevel_srcdir = @toplevel_srcdir@\n+\n+# May be used by various substitution variables.\n+gcc_version := $(shell @get_gcc_base_ver@ $(top_srcdir)/../gcc/BASE-VER)\n+MAINT_CHARSET = latin1\n+mkinstalldirs = $(SHELL) $(toplevel_srcdir)/mkinstalldirs\n+PWD_COMMAND = $${PWDCMD-pwd}\n+STAMP = echo timestamp >\n+toolexecdir = $(glibcxx_toolexecdir)\n+toolexeclibdir = $(glibcxx_toolexeclibdir)\n+@ENABLE_WERROR_FALSE@WERROR_FLAG = \n+@ENABLE_WERROR_TRUE@WERROR_FLAG = $(WERROR)\n+@ENABLE_EXTERN_TEMPLATE_FALSE@XTEMPLATE_FLAGS = \n+@ENABLE_EXTERN_TEMPLATE_TRUE@XTEMPLATE_FLAGS = -fno-implicit-templates\n+\n+# These bits are all figured out from configure.  Look in acinclude.m4\n+# or configure.ac to see how they are set.  See GLIBCXX_EXPORT_FLAGS.\n+CONFIG_CXXFLAGS = \\\n+\t$(SECTION_FLAGS) $(HWCAP_CFLAGS) -frandom-seed=$@\n+\n+WARN_CXXFLAGS = \\\n+\t$(WARN_FLAGS) $(WERROR_FLAG) -fdiagnostics-show-location=once \n+\n+\n+# -I/-D flags to pass when compiling.\n+AM_CPPFLAGS = $(GLIBCXX_INCLUDES) $(CPPFLAGS)\n+\n+# Convenience library for C++17 runtime.\n+noinst_LTLIBRARIES = libc++17convenience.la\n+headers = \n+sources = \\\n+\tmemory_resource.cc\n+\n+@ENABLE_DUAL_ABI_FALSE@extra_string_inst_sources = \n+@ENABLE_DUAL_ABI_TRUE@extra_string_inst_sources = \n+# XTEMPLATE_FLAGS =\n+@ENABLE_EXTERN_TEMPLATE_FALSE@inst_sources = \n+\n+# XTEMPLATE_FLAGS = -fno-implicit-templates\n+@ENABLE_EXTERN_TEMPLATE_TRUE@inst_sources = \\\n+@ENABLE_EXTERN_TEMPLATE_TRUE@\t$(extra_string_inst_sources)\n+\n+libc__17convenience_la_SOURCES = $(sources)  $(inst_sources)\n+\n+# AM_CXXFLAGS needs to be in each subdirectory so that it can be\n+# modified in a per-library or per-sub-library way.  Need to manually\n+# set this option because CONFIG_CXXFLAGS has to be after\n+# OPTIMIZE_CXXFLAGS on the compile line so that -O2 can be overridden\n+# as the occasion calls for it.\n+AM_CXXFLAGS = \\\n+\t-std=gnu++17 \\\n+\t$(glibcxx_lt_pic_flag) $(glibcxx_compiler_shared_flag) \\\n+\t$(XTEMPLATE_FLAGS) $(VTV_CXXFLAGS) \\\n+\t$(WARN_CXXFLAGS) $(OPTIMIZE_CXXFLAGS) $(CONFIG_CXXFLAGS)\n+\n+AM_MAKEFLAGS = \\\n+\t\"gxx_include_dir=$(gxx_include_dir)\"\n+\n+\n+# Libtool notes\n+\n+# 1) In general, libtool expects an argument such as `--tag=CXX' when\n+# using the C++ compiler, because that will enable the settings\n+# detected when C++ support was being configured.  However, when no\n+# such flag is given in the command line, libtool attempts to figure\n+# it out by matching the compiler name in each configuration section\n+# against a prefix of the command line.  The problem is that, if the\n+# compiler name and its initial flags stored in the libtool\n+# configuration file don't match those in the command line, libtool\n+# can't decide which configuration to use, and it gives up.  The\n+# correct solution is to add `--tag CXX' to LTCXXCOMPILE and maybe\n+# CXXLINK, just after $(LIBTOOL), so that libtool doesn't have to\n+# attempt to infer which configuration to use.\n+#\n+# The second tag argument, `--tag disable-shared` means that libtool\n+# only compiles each source once, for static objects. In actuality,\n+# glibcxx_lt_pic_flag and glibcxx_compiler_shared_flag are added to\n+# the libtool command that is used create the object, which is\n+# suitable for shared libraries.  The `--tag disable-shared` must be\n+# placed after --tag CXX lest things CXX undo the affect of\n+# disable-shared.\n+\n+# 2) Need to explicitly set LTCXXCOMPILE so that EXTRA_CXX_FLAGS is\n+# last. (That way, things like -O2 passed down from the toplevel can\n+# be overridden by --enable-debug.)\n+LTCXXCOMPILE = \\\n+\t$(LIBTOOL) --tag CXX --tag disable-shared \\\n+\t$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=compile $(CXX) $(TOPLEVEL_INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) $(EXTRA_CXX_FLAGS)\n+\n+LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS))\n+\n+# 3) We'd have a problem when building the shared libstdc++ object if\n+# the rules automake generates would be used.  We cannot allow g++ to\n+# be used since this would add -lstdc++ to the link line which of\n+# course is problematic at this point.  So, we get the top-level\n+# directory to configure libstdc++-v3 to use gcc as the C++\n+# compilation driver.\n+CXXLINK = \\\n+\t$(LIBTOOL) --tag CXX --tag disable-shared \\\n+\t$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CXX) \\\n+\t$(VTV_CXXLINKFLAGS) \\\n+\t$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LTLDFLAGS) -o $@\n+\n+all: all-am\n+\n+.SUFFIXES:\n+.SUFFIXES: .cc .lo .o .obj\n+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/fragment.am $(am__configure_deps)\n+\t@for dep in $?; do \\\n+\t  case '$(am__configure_deps)' in \\\n+\t    *$$dep*) \\\n+\t      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \\\n+\t        && { if test -f $@; then exit 0; else break; fi; }; \\\n+\t      exit 1;; \\\n+\t  esac; \\\n+\tdone; \\\n+\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign --ignore-deps src/c++17/Makefile'; \\\n+\t$(am__cd) $(top_srcdir) && \\\n+\t  $(AUTOMAKE) --foreign --ignore-deps src/c++17/Makefile\n+.PRECIOUS: Makefile\n+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n+\t@case '$?' in \\\n+\t  *config.status*) \\\n+\t    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \\\n+\t  *) \\\n+\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \\\n+\t    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \\\n+\tesac;\n+$(top_srcdir)/fragment.am:\n+\n+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n+\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n+\n+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n+\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)\n+\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n+$(am__aclocal_m4_deps):\n+\n+clean-noinstLTLIBRARIES:\n+\t-test -z \"$(noinst_LTLIBRARIES)\" || rm -f $(noinst_LTLIBRARIES)\n+\t@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \\\n+\t  dir=\"`echo $$p | sed -e 's|/[^/]*$$||'`\"; \\\n+\t  test \"$$dir\" != \"$$p\" || dir=.; \\\n+\t  echo \"rm -f \\\"$${dir}/so_locations\\\"\"; \\\n+\t  rm -f \"$${dir}/so_locations\"; \\\n+\tdone\n+libc++17convenience.la: $(libc__17convenience_la_OBJECTS) $(libc__17convenience_la_DEPENDENCIES) $(EXTRA_libc__17convenience_la_DEPENDENCIES) \n+\t$(CXXLINK)  $(libc__17convenience_la_OBJECTS) $(libc__17convenience_la_LIBADD) $(LIBS)\n+\n+mostlyclean-compile:\n+\t-rm -f *.$(OBJEXT)\n+\n+distclean-compile:\n+\t-rm -f *.tab.c\n+\n+.cc.o:\n+\t$(CXXCOMPILE) -c -o $@ $<\n+\n+.cc.obj:\n+\t$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n+\n+.cc.lo:\n+\t$(LTCXXCOMPILE) -c -o $@ $<\n+\n+mostlyclean-libtool:\n+\t-rm -f *.lo\n+\n+clean-libtool:\n+\t-rm -rf .libs _libs\n+\n+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)\n+\tlist='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tmkid -fID $$unique\n+tags: TAGS\n+\n+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tset x; \\\n+\there=`pwd`; \\\n+\tlist='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tshift; \\\n+\tif test -z \"$(ETAGS_ARGS)$$*$$unique\"; then :; else \\\n+\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n+\t  if test $$# -gt 0; then \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      \"$$@\" $$unique; \\\n+\t  else \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      $$unique; \\\n+\t  fi; \\\n+\tfi\n+ctags: CTAGS\n+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tlist='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\ttest -z \"$(CTAGS_ARGS)$$unique\" \\\n+\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n+\t     $$unique\n+\n+GTAGS:\n+\there=`$(am__cd) $(top_builddir) && pwd` \\\n+\t  && $(am__cd) $(top_srcdir) \\\n+\t  && gtags -i $(GTAGS_ARGS) \"$$here\"\n+\n+distclean-tags:\n+\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n+check-am: all-am\n+check: check-am\n+all-am: Makefile $(LTLIBRARIES)\n+installdirs:\n+install: install-am\n+install-exec: install-exec-am\n+install-data: install-data-am\n+uninstall: uninstall-am\n+\n+install-am: all-am\n+\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n+\n+installcheck: installcheck-am\n+install-strip:\n+\tif test -z '$(STRIP)'; then \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t      install; \\\n+\telse \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t    \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\" install; \\\n+\tfi\n+mostlyclean-generic:\n+\n+clean-generic:\n+\n+distclean-generic:\n+\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n+\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n+\n+maintainer-clean-generic:\n+\t@echo \"This command is intended for maintainers to use\"\n+\t@echo \"it deletes files that may require special tools to rebuild.\"\n+clean: clean-am\n+\n+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \\\n+\tmostlyclean-am\n+\n+distclean: distclean-am\n+\t-rm -f Makefile\n+distclean-am: clean-am distclean-compile distclean-generic \\\n+\tdistclean-tags\n+\n+dvi: dvi-am\n+\n+dvi-am:\n+\n+html: html-am\n+\n+html-am:\n+\n+info: info-am\n+\n+info-am:\n+\n+install-data-am:\n+\n+install-dvi: install-dvi-am\n+\n+install-dvi-am:\n+\n+install-exec-am:\n+\n+install-html: install-html-am\n+\n+install-html-am:\n+\n+install-info: install-info-am\n+\n+install-info-am:\n+\n+install-man:\n+\n+install-pdf: install-pdf-am\n+\n+install-pdf-am:\n+\n+install-ps: install-ps-am\n+\n+install-ps-am:\n+\n+installcheck-am:\n+\n+maintainer-clean: maintainer-clean-am\n+\t-rm -f Makefile\n+maintainer-clean-am: distclean-am maintainer-clean-generic\n+\n+mostlyclean: mostlyclean-am\n+\n+mostlyclean-am: mostlyclean-compile mostlyclean-generic \\\n+\tmostlyclean-libtool\n+\n+pdf: pdf-am\n+\n+pdf-am:\n+\n+ps: ps-am\n+\n+ps-am:\n+\n+uninstall-am:\n+\n+.MAKE: install-am install-strip\n+\n+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \\\n+\tclean-libtool clean-noinstLTLIBRARIES ctags distclean \\\n+\tdistclean-compile distclean-generic distclean-libtool \\\n+\tdistclean-tags dvi dvi-am html html-am info info-am install \\\n+\tinstall-am install-data install-data-am install-dvi \\\n+\tinstall-dvi-am install-exec install-exec-am install-html \\\n+\tinstall-html-am install-info install-info-am install-man \\\n+\tinstall-pdf install-pdf-am install-ps install-ps-am \\\n+\tinstall-strip installcheck installcheck-am installdirs \\\n+\tmaintainer-clean maintainer-clean-generic mostlyclean \\\n+\tmostlyclean-compile mostlyclean-generic mostlyclean-libtool \\\n+\tpdf pdf-am ps ps-am tags uninstall uninstall-am\n+\n+\n+vpath % $(top_srcdir)/src/c++17\n+\n+# Tell versions [3.59,3.63) of GNU make to not export all variables.\n+# Otherwise a system limit (for SysV at least) may be exceeded.\n+.NOEXPORT:"}, {"sha": "dd418c1b1aa5ff59522e34a40366783dcdffac25", "filename": "libstdc++-v3/src/c++17/memory_resource.cc", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc?ref=dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e", "patch": "@@ -0,0 +1,111 @@\n+// <memory_resource> implementation -*- C++ -*-\n+\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <memory_resource>\n+#include <atomic>\n+#include <new>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+namespace pmr\n+{\n+  namespace\n+  {\n+    class newdel_res_t final : public memory_resource\n+    {\n+      void*\n+      do_allocate(size_t __bytes, size_t __alignment) override\n+      { return ::operator new(__bytes, std::align_val_t(__alignment)); }\n+\n+      void\n+      do_deallocate(void* __p, size_t __bytes, size_t __alignment) noexcept\n+      override\n+      { ::operator delete(__p, __bytes, std::align_val_t(__alignment)); }\n+\n+      bool\n+      do_is_equal(const memory_resource& __other) const noexcept override\n+      { return &__other == this; }\n+    };\n+\n+    class null_res_t final : public memory_resource\n+    {\n+      void*\n+      do_allocate(size_t, size_t) override\n+      { std::__throw_bad_alloc(); }\n+\n+      void\n+      do_deallocate(void*, size_t, size_t) noexcept override\n+      { }\n+\n+      bool\n+      do_is_equal(const memory_resource& __other) const noexcept override\n+      { return &__other == this; }\n+    };\n+\n+    template<typename T>\n+      struct constant_init\n+      {\n+\tunion {\n+\t  unsigned char unused;\n+\t  T obj;\n+\t};\n+\tconstexpr constant_init() : obj() { }\n+\n+\ttemplate<typename U>\n+\t  explicit constexpr constant_init(U arg) : obj(arg) { }\n+\n+\t~constant_init() { /* do nothing, union member is not destroyed */ }\n+      };\n+\n+    constant_init<newdel_res_t> newdel_res{};\n+    constant_init<null_res_t> null_res{};\n+    constant_init<atomic<memory_resource*>> default_res{&newdel_res.obj};\n+  } // namespace\n+\n+  memory_resource*\n+  new_delete_resource() noexcept\n+  { return &newdel_res.obj; }\n+\n+  memory_resource*\n+  null_memory_resource() noexcept\n+  { return &null_res.obj; }\n+\n+  memory_resource*\n+  set_default_resource(memory_resource* r) noexcept\n+  {\n+    if (r == nullptr)\n+      r = new_delete_resource();\n+    return default_res.obj.exchange(r);\n+  }\n+\n+  memory_resource*\n+  get_default_resource() noexcept\n+  { return default_res.obj.load(); }\n+\n+} // namespace pmr\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+\n+"}, {"sha": "d848374e71aea2f014f5f7f25b36833d263d244d", "filename": "libstdc++-v3/testsuite/20_util/memory_resource/1.cc", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmemory_resource%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmemory_resource%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmemory_resource%2F1.cc?ref=dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e", "patch": "@@ -0,0 +1,47 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile { target c++17 } }\n+\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <memory_resource>\n+\n+static_assert(std::is_abstract_v<std::pmr::memory_resource>);\n+static_assert(std::is_polymorphic_v<std::pmr::memory_resource>);\n+static_assert(!std::is_final_v<std::pmr::memory_resource>);\n+\n+struct R0 : std::pmr::memory_resource { };\n+static_assert(std::is_abstract_v<R0>);\n+\n+struct R1 : R0 {\n+  void* do_allocate(std::size_t, std::size_t) override;\n+};\n+static_assert(std::is_abstract_v<R1>);\n+\n+struct R2 : R1 {\n+  void do_deallocate(void*, std::size_t, std::size_t) override;\n+};\n+static_assert(std::is_abstract_v<R2>);\n+\n+struct R3 : R2 {\n+  bool do_is_equal(const std::pmr::memory_resource&) const noexcept override;\n+};\n+static_assert(!std::is_abstract_v<R3>);\n+static_assert(std::is_default_constructible_v<R3>);\n+static_assert(std::is_copy_constructible_v<R3>);\n+static_assert(std::is_copy_assignable_v<R3>);\n+static_assert(std::is_destructible_v<R3>);"}, {"sha": "b99aa49fce164d5961979bc6d9035b9329aa4a06", "filename": "libstdc++-v3/testsuite/20_util/memory_resource/2.cc", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmemory_resource%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmemory_resource%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmemory_resource%2F2.cc?ref=dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e", "patch": "@@ -0,0 +1,112 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n+// { dg-skip-if \"\" { *-*-* } { -fno-aligned-new } }\n+\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <memory_resource>\n+#include <testsuite_allocator.h>\n+\n+struct R : std::pmr::memory_resource {\n+  void* do_allocate(std::size_t, std::size_t) override;\n+  void do_deallocate(void*, std::size_t, std::size_t) override;\n+  bool do_is_equal(const std::pmr::memory_resource&) const noexcept override;\n+};\n+\n+bool called = false;\n+\n+void* R::do_allocate(std::size_t bytes, std::size_t a)\n+{\n+  called = true;\n+  return ::operator new(bytes, std::align_val_t(a));\n+}\n+\n+void R::do_deallocate(void* p, std::size_t bytes, std::size_t a)\n+{\n+  called = true;\n+  ::operator delete(p, bytes, std::align_val_t(a));\n+}\n+\n+bool R::do_is_equal(const std::pmr::memory_resource& r) const noexcept\n+{\n+  called = true;\n+  return this == &r;\n+}\n+\n+void\n+test01()\n+{\n+  R res;\n+  called = false;\n+  auto p = res.allocate(1, 1);\n+  VERIFY( called );\n+  called = false;\n+  res.deallocate(p, 1, 1);\n+  VERIFY( called );\n+  called = false;\n+  VERIFY( res == res );\n+  VERIFY( !called );\n+  VERIFY( ! (res != res) );\n+  VERIFY( !called );\n+\n+  struct X { int i = 0; };\n+  struct MultipleInheritance : X, R { };\n+  MultipleInheritance m;\n+  VERIFY( m == m );\n+  VERIFY( !called );\n+  VERIFY( ! (m != m) );\n+  VERIFY( !called );\n+  VERIFY( m.is_equal(m) );\n+  VERIFY( called );\n+  called = false;\n+  VERIFY( ! (m == res) );\n+  VERIFY( called );\n+  called = false;\n+  VERIFY( m != res );\n+  VERIFY( called );\n+  called = false;\n+  VERIFY( ! (res == m) );\n+  VERIFY( called );\n+  called = false;\n+  VERIFY( res != m );\n+  VERIFY( called );\n+  called = false;\n+}\n+\n+void\n+test02()\n+{\n+  __gnu_test::memory_resource r1, r2;\n+  VERIFY( r1 == r1 );\n+  VERIFY( ! (r1 != r1) );\n+  VERIFY( r1.is_equal(r1) );\n+  VERIFY( r2 == r2 );\n+  VERIFY( r2.is_equal(r2) );\n+  VERIFY( ! (r1 == r2) );\n+  VERIFY( r1 != r2 );\n+  VERIFY( ! r1.is_equal(r2) );\n+  VERIFY( ! (r2 == r1) );\n+  VERIFY( r2 != r1 );\n+  VERIFY( ! r2.is_equal(r1) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "77fa38edbd8461893ec9a99178dfd7e05b9c0c41", "filename": "libstdc++-v3/testsuite/20_util/monotonic_buffer_resource/1.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmonotonic_buffer_resource%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmonotonic_buffer_resource%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmonotonic_buffer_resource%2F1.cc?ref=dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e", "patch": "@@ -0,0 +1,53 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile { target c++17 } }\n+\n+#include <memory_resource>\n+\n+using std::pmr::monotonic_buffer_resource;\n+using std::pmr::memory_resource;\n+using std::size_t;\n+\n+static_assert(std::is_base_of_v<memory_resource, monotonic_buffer_resource>);\n+static_assert(!std::is_abstract_v<monotonic_buffer_resource>);\n+\n+static_assert(std::is_default_constructible_v<monotonic_buffer_resource>);\n+static_assert(std::is_destructible_v<monotonic_buffer_resource>);\n+static_assert(!std::is_copy_constructible_v<monotonic_buffer_resource>);\n+static_assert(!std::is_copy_assignable_v<monotonic_buffer_resource>);\n+static_assert(!std::is_move_constructible_v<monotonic_buffer_resource>);\n+static_assert(!std::is_move_assignable_v<monotonic_buffer_resource>);\n+\n+static_assert(std::is_constructible_v<monotonic_buffer_resource,\n+\t\t\t\t      memory_resource*>);\n+static_assert(std::is_constructible_v<monotonic_buffer_resource,\n+\t\t\t\t      size_t, memory_resource*>);\n+static_assert(std::is_constructible_v<monotonic_buffer_resource,\n+\t\t\t\t      void*, size_t, memory_resource*>);\n+\n+static_assert(std::is_constructible_v<monotonic_buffer_resource,\n+\t\t\t\t      size_t>);\n+static_assert(std::is_constructible_v<monotonic_buffer_resource,\n+\t\t\t\t      void*, size_t>);\n+\n+// Unary constructors are explicit.\n+static_assert(!std::is_convertible_v<memory_resource*,\n+\t\t\t\t     monotonic_buffer_resource>);\n+static_assert(!std::is_convertible_v<size_t,\n+\t\t\t\t     monotonic_buffer_resource>);"}, {"sha": "d1c2715ef8dfdf021387a615f45aebc0e7d308b8", "filename": "libstdc++-v3/testsuite/20_util/monotonic_buffer_resource/allocate.cc", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmonotonic_buffer_resource%2Fallocate.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmonotonic_buffer_resource%2Fallocate.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmonotonic_buffer_resource%2Fallocate.cc?ref=dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e", "patch": "@@ -0,0 +1,221 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n+\n+#include <memory_resource>\n+#include <testsuite_allocator.h>\n+\n+void\n+test01()\n+{\n+  __gnu_test::memory_resource r;\n+\n+  // test that it's possible to allocate after each of the constructors\n+  {\n+    std::pmr::monotonic_buffer_resource mr(&r);\n+    auto p = mr.allocate(1024);\n+    VERIFY( p != nullptr );\n+    auto q = mr.allocate(1024);\n+    VERIFY( q != nullptr );\n+    VERIFY( p != q );\n+  }\n+  VERIFY( r.number_of_active_allocations() == 0 );\n+  {\n+    std::pmr::monotonic_buffer_resource mr(128, &r);\n+    auto p = mr.allocate(1024);\n+    VERIFY( p != nullptr );\n+    auto q = mr.allocate(1024);\n+    VERIFY( q != nullptr );\n+    VERIFY( p != q );\n+  }\n+  VERIFY( r.number_of_active_allocations() == 0 );\n+  {\n+    unsigned char buf[64];\n+    std::pmr::monotonic_buffer_resource mr((void*)buf, sizeof(buf), &r);\n+    auto p = mr.allocate(1024);\n+    VERIFY( p != nullptr );\n+    auto q = mr.allocate(1024);\n+    VERIFY( q != nullptr );\n+    VERIFY( p != q );\n+  }\n+  VERIFY( r.number_of_active_allocations() == 0 );\n+  {\n+    std::pmr::monotonic_buffer_resource mr;\n+    auto p = mr.allocate(1024);\n+    VERIFY( p != nullptr );\n+    auto q = mr.allocate(1024);\n+    VERIFY( q != nullptr );\n+    VERIFY( p != q );\n+  }\n+  {\n+    std::pmr::monotonic_buffer_resource mr(64);\n+    auto p = mr.allocate(1024);\n+    VERIFY( p != nullptr );\n+    auto q = mr.allocate(1024);\n+    VERIFY( q != nullptr );\n+    VERIFY( p != q );\n+  }\n+  {\n+    unsigned char buf[64];\n+    std::pmr::monotonic_buffer_resource mr((void*)buf, sizeof(buf));\n+    auto p = mr.allocate(1024);\n+    VERIFY( p != nullptr );\n+    auto q = mr.allocate(1024);\n+    VERIFY( q != nullptr );\n+    VERIFY( p != q );\n+  }\n+}\n+\n+void\n+test02()\n+{\n+  unsigned char buf[64];\n+  std::pmr::monotonic_buffer_resource mr(buf, sizeof(buf));\n+\n+  auto p = mr.allocate(0);\n+  VERIFY( p != nullptr );\n+  auto q = mr.allocate(0);\n+  VERIFY( q != nullptr );\n+  VERIFY( p != q );\n+\n+  p = mr.allocate(0, 1);\n+  VERIFY( p != nullptr );\n+  q = mr.allocate(0, 1);\n+  VERIFY( q != nullptr );\n+  VERIFY( p != q );\n+}\n+\n+void\n+test03()\n+{\n+#if __cpp_exceptions\n+  {\n+    std::pmr::monotonic_buffer_resource mr(std::pmr::null_memory_resource());\n+    bool caught = false;\n+    try\n+    {\n+      (void) mr.allocate(1, 1);\n+    }\n+    catch (const std::bad_alloc&)\n+    {\n+      caught = true;\n+    }\n+    VERIFY( caught );\n+  }\n+  {\n+    unsigned char buf[16];\n+    std::pmr::monotonic_buffer_resource mr(buf, sizeof(buf),\n+\t\t\t\t\t   std::pmr::null_memory_resource());\n+    (void) mr.allocate(16, 1);\n+    bool caught = false;\n+    try\n+    {\n+      (void) mr.allocate(1, 1);\n+    }\n+    catch (const std::bad_alloc&)\n+    {\n+      caught = true;\n+    }\n+    VERIFY( caught );\n+  }\n+#endif\n+}\n+\n+void\n+test04()\n+{\n+  auto buf = new unsigned char[512];\n+  std::pmr::monotonic_buffer_resource mr(buf, 512,\n+\t\t\t\t\t std::pmr::null_memory_resource());\n+  std::size_t prev_size = 1;\n+  void* prev_ptr = mr.allocate(prev_size, 1);\n+  for (int i = 0; i < 9; ++i)\n+  {\n+    std::size_t size = 1 << i;\n+    void* ptr = mr.allocate(size, 1);\n+    VERIFY( ((char*)ptr - (char*)prev_ptr) == prev_size );\n+    prev_ptr = ptr;\n+    prev_size = size;\n+  }\n+}\n+\n+void\n+test05()\n+{\n+  // test that returned pointer is correctly aligned\n+  auto is_aligned = [](void* p, size_t alignment) -> bool {\n+    return (reinterpret_cast<std::uintptr_t>(p) % alignment) == 0;\n+  };\n+\n+  auto buf = new unsigned char[2048];\n+  std::pmr::monotonic_buffer_resource mr(buf+1, 2047);\n+  for (int i = 0; i < 9; ++i)\n+  {\n+    auto p = mr.allocate(1, 1 << i);\n+    VERIFY( is_aligned(p, 1 << i) );\n+    // Make next available byte misaligned:\n+    (void) mr.allocate(1 << i, 1);\n+  }\n+}\n+\n+void\n+test06()\n+{\n+  // check for geometric progression in buffer sizes from upstream\n+\n+  struct resource : __gnu_test::memory_resource\n+  {\n+    bool allocated = false;\n+    std::size_t last_size = 0;\n+\n+    void*\n+    do_allocate(size_t bytes, size_t align) override\n+    {\n+      allocated = true;\n+      last_size = bytes;\n+      return __gnu_test::memory_resource::do_allocate(bytes, align);\n+    }\n+  };\n+\n+  resource r;\n+  std::pmr::monotonic_buffer_resource mr(32, &r);\n+  std::size_t last_size = 0;\n+\n+  for (int i = 0; i < 100; ++i)\n+  {\n+    (void) mr.allocate(16);\n+    if (r.allocated)\n+    {\n+      VERIFY(r.last_size >= last_size);\n+      last_size = r.last_size;\n+      r.allocated = false;\n+    }\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+  test06();\n+}"}, {"sha": "427256d672af0f60558b59776fcc3a5d56eb5127", "filename": "libstdc++-v3/testsuite/20_util/monotonic_buffer_resource/deallocate.cc", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmonotonic_buffer_resource%2Fdeallocate.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmonotonic_buffer_resource%2Fdeallocate.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmonotonic_buffer_resource%2Fdeallocate.cc?ref=dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e", "patch": "@@ -0,0 +1,103 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n+\n+#include <memory_resource>\n+#include <testsuite_allocator.h>\n+\n+struct resource : __gnu_test::memory_resource\n+{\n+  int allocate_calls = 0;\n+  int deallocate_calls = 0;\n+\n+  void*\n+  do_allocate(std::size_t bytes, std::size_t align) override\n+  {\n+    ++allocate_calls;\n+    return __gnu_test::memory_resource::do_allocate(bytes, align);\n+  }\n+\n+  void\n+  do_deallocate(void* p, std::size_t bytes, std::size_t align) override\n+  {\n+    ++deallocate_calls;\n+    __gnu_test::memory_resource::do_deallocate(p, bytes, align);\n+  }\n+};\n+\n+void\n+test01()\n+{\n+  resource r;\n+\n+  // test that it's possible to deallocate after each of the constructors\n+  {\n+    std::pmr::monotonic_buffer_resource mr(&r);\n+    auto p = mr.allocate(1024);\n+    VERIFY( p != nullptr );\n+    const std::uintptr_t pi = reinterpret_cast<std::uintptr_t>(p);\n+    mr.deallocate(p, 1024);\n+    VERIFY( r.deallocate_calls == 0 );\n+    auto q = mr.allocate(1024);\n+    VERIFY( q != nullptr );\n+    VERIFY( pi != reinterpret_cast<std::uintptr_t>(q) );\n+    mr.deallocate(q, 1024);\n+    VERIFY( r.deallocate_calls == 0 );\n+  }\n+  VERIFY( r.deallocate_calls == r.allocate_calls );\n+  VERIFY( r.number_of_active_allocations() == 0 );\n+  {\n+    r.deallocate_calls = r.allocate_calls = 0;\n+    std::pmr::monotonic_buffer_resource mr(128, &r);\n+    auto p = mr.allocate(64);\n+    VERIFY( p != nullptr );\n+    const std::uintptr_t pi = reinterpret_cast<std::uintptr_t>(p);\n+    mr.deallocate(p, 64);\n+    auto q = mr.allocate(1024);\n+    VERIFY( q != nullptr );\n+    VERIFY( p != q );\n+    VERIFY( pi != reinterpret_cast<std::uintptr_t>(q) );\n+    mr.deallocate(q, 1024);\n+    VERIFY( r.deallocate_calls == 0 );\n+  }\n+  VERIFY( r.number_of_active_allocations() == 0 );\n+  {\n+    r.deallocate_calls = r.allocate_calls = 0;\n+    unsigned char buf[64];\n+    std::pmr::monotonic_buffer_resource mr((void*)buf, sizeof(buf), &r);\n+    auto p = mr.allocate(64);\n+    VERIFY( p != nullptr );\n+    const std::uintptr_t pi = reinterpret_cast<std::uintptr_t>(p);\n+    mr.deallocate(p, 64);\n+    auto q = mr.allocate(1024);\n+    VERIFY( q != nullptr );\n+    VERIFY( p != q );\n+    VERIFY( pi != reinterpret_cast<std::uintptr_t>(q) );\n+    mr.deallocate(q, 1024);\n+    VERIFY( r.deallocate_calls == 0 );\n+  }\n+  VERIFY( r.deallocate_calls == r.allocate_calls );\n+  VERIFY( r.number_of_active_allocations() == 0 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "0c7f31789e62e90a5345ed52035fa77adec2fe4f", "filename": "libstdc++-v3/testsuite/20_util/monotonic_buffer_resource/release.cc", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmonotonic_buffer_resource%2Frelease.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmonotonic_buffer_resource%2Frelease.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmonotonic_buffer_resource%2Frelease.cc?ref=dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e", "patch": "@@ -0,0 +1,172 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n+\n+#include <memory_resource>\n+#include <testsuite_allocator.h>\n+\n+struct resource : __gnu_test::memory_resource\n+{\n+  int allocate_calls = 0;\n+  int deallocate_calls = 0;\n+\n+  void*\n+  do_allocate(std::size_t bytes, std::size_t align) override\n+  {\n+    ++allocate_calls;\n+    return __gnu_test::memory_resource::do_allocate(bytes, align);\n+  }\n+\n+  void\n+  do_deallocate(void* p, std::size_t bytes, std::size_t align) override\n+  {\n+    ++deallocate_calls;\n+    __gnu_test::memory_resource::do_deallocate(p, bytes, align);\n+  }\n+};\n+\n+void\n+test01()\n+{\n+  resource r;\n+  std::pmr::monotonic_buffer_resource mbr(&r);\n+  auto p = mbr.allocate(10, 16);\n+  mbr.deallocate(p, 1, 2);\n+  VERIFY( r.deallocate_calls == 0 );\n+  p = mbr.allocate(10, 16);\n+  p = mbr.allocate(10, 16);\n+  p = mbr.allocate(10, 16);\n+  p = mbr.allocate(1024, 64);\n+  p = mbr.allocate(1024, 64);\n+  p = mbr.allocate(128, 8);\n+  p = mbr.allocate(128, 8);\n+  p = mbr.allocate(128, 8);\n+  p = mbr.allocate(128, 8);\n+  p = mbr.allocate(128, 8);\n+  p = mbr.allocate(128, 8);\n+  p = mbr.allocate(128, 8);\n+  mbr.deallocate(p, 1, 2);\n+  p = mbr.allocate(1024, 16);\n+  p = mbr.allocate(1024, 16);\n+  mbr.deallocate(p, 1, 2);\n+  VERIFY( r.deallocate_calls == 0 );\n+  mbr.release();\n+  VERIFY( r.deallocate_calls != 0 );\n+  VERIFY( r.deallocate_calls == r.allocate_calls );\n+  VERIFY( mbr.upstream_resource() == &r );\n+  VERIFY( r.number_of_active_allocations() == 0 );\n+}\n+\n+void\n+test02()\n+{\n+  std::pmr::monotonic_buffer_resource mbr; // uses get_default_resource()\n+  auto* const upstream = mbr.upstream_resource();\n+  resource r;\n+  __gnu_test::default_resource_mgr _(&r); // calls set_default_resource(&r)\n+  mbr.release();\n+  // release() doesn't change upstream resource:\n+  VERIFY( mbr.upstream_resource() == upstream );\n+}\n+\n+void\n+test03()\n+{\n+  resource r;\n+  __gnu_test::default_resource_mgr _(&r);\n+  std::pmr::monotonic_buffer_resource mbr(16);\n+  for (int i = 0; i < 100; ++i)\n+    (void) mbr.allocate(4, 1);\n+  const int allocations = r.allocate_calls;\n+  VERIFY( allocations != 0 );\n+  mbr.release();\n+  VERIFY( r.allocate_calls == r.deallocate_calls );\n+  VERIFY( r.number_of_active_allocations() == 0 );\n+\n+  // next_buffer_size should have been reset to the initial value,\n+  // so the allocations from upstream should be the same as before.\n+  r.allocate_calls = 0;\n+  r.deallocate_calls = 0;\n+  for (int i = 0; i < 100; ++i)\n+    (void) mbr.allocate(4,1);\n+  VERIFY( allocations == r.allocate_calls );\n+}\n+\n+void\n+test04()\n+{\n+  resource r;\n+  unsigned char buffer[1024];\n+  std::pmr::monotonic_buffer_resource mbr(buffer, sizeof(buffer), &r);\n+  void* p = mbr.allocate(800, 16);\n+  VERIFY( p == buffer );\n+  VERIFY( r.allocate_calls == 0 );\n+  p = mbr.allocate(300, 1);\n+  VERIFY( p != buffer );\n+  VERIFY( r.allocate_calls == 1 );\n+  mbr.release();\n+  VERIFY( r.deallocate_calls == 1 );\n+  VERIFY( mbr.upstream_resource() == &r );\n+  VERIFY( r.number_of_active_allocations() == 0 );\n+  // initial buffer should be used again now:\n+  p = mbr.allocate(1000);\n+  VERIFY( p == buffer );\n+  VERIFY( r.allocate_calls == 1 );\n+}\n+\n+void\n+test05() // LWG 3120\n+{\n+  char buffer[100];\n+  {\n+    std::pmr::monotonic_buffer_resource mr(buffer, sizeof(buffer),\n+\t\t\t\t\t    std::pmr::null_memory_resource());\n+    mr.release();\n+    (void) mr.allocate(60);\n+  }\n+\n+  {\n+    std::pmr::monotonic_buffer_resource mr(buffer, sizeof(buffer),\n+\t\t\t\t\t    std::pmr::null_memory_resource());\n+    (void) mr.allocate(60);\n+    mr.release();\n+    (void) mr.allocate(60);\n+  }\n+\n+  {\n+    resource r;\n+    std::pmr::monotonic_buffer_resource mr(&r);\n+    for (int i = 0; i < 100; ++i)\n+    {\n+      (void) mr.allocate(1);\n+      mr.release();\n+    }\n+    VERIFY( r.number_of_active_allocations() == 0 );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+}"}, {"sha": "c09294f4272170d8dea389ec1a0728e045d27db0", "filename": "libstdc++-v3/testsuite/20_util/monotonic_buffer_resource/upstream_resource.cc", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmonotonic_buffer_resource%2Fupstream_resource.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmonotonic_buffer_resource%2Fupstream_resource.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmonotonic_buffer_resource%2Fupstream_resource.cc?ref=dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e", "patch": "@@ -0,0 +1,76 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n+\n+#include <memory_resource>\n+#include <testsuite_allocator.h>\n+\n+void\n+test01()\n+{\n+  __gnu_test::memory_resource r;\n+  const auto null = std::pmr::null_memory_resource();\n+  const auto newdel = std::pmr::new_delete_resource();\n+  std::pmr::set_default_resource(null);\n+\n+  {\n+    std::pmr::monotonic_buffer_resource mr(&r);\n+    VERIFY( mr.upstream_resource() == &r );\n+    __gnu_test::default_resource_mgr _(newdel);\n+    VERIFY( mr.upstream_resource() == &r );\n+  }\n+  {\n+    std::pmr::monotonic_buffer_resource mr(128, &r);\n+    VERIFY( mr.upstream_resource() == &r );\n+    __gnu_test::default_resource_mgr _(newdel);\n+    VERIFY( mr.upstream_resource() == &r );\n+  }\n+  {\n+    unsigned char buf[64];\n+    std::pmr::monotonic_buffer_resource mr((void*)buf, sizeof(buf), &r);\n+    VERIFY( mr.upstream_resource() == &r );\n+    __gnu_test::default_resource_mgr _(newdel);\n+    VERIFY( mr.upstream_resource() == &r );\n+  }\n+  {\n+    std::pmr::monotonic_buffer_resource mr;\n+    VERIFY( mr.upstream_resource() == null );\n+    __gnu_test::default_resource_mgr _(newdel);\n+    VERIFY( mr.upstream_resource() == null );\n+  }\n+  {\n+    std::pmr::monotonic_buffer_resource mr(64);\n+    VERIFY( mr.upstream_resource() == null );\n+    __gnu_test::default_resource_mgr _(newdel);\n+    VERIFY( mr.upstream_resource() == null );\n+  }\n+  {\n+    unsigned char buf[64];\n+    std::pmr::monotonic_buffer_resource mr((void*)buf, sizeof(buf));\n+    VERIFY( mr.upstream_resource() == null );\n+    __gnu_test::default_resource_mgr _(newdel);\n+    VERIFY( mr.upstream_resource() == null );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "4bc7f79e2b64f1da5d3332eafacbaca80072df12", "filename": "libstdc++-v3/testsuite/20_util/polymorphic_allocator/1.cc", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpolymorphic_allocator%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpolymorphic_allocator%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpolymorphic_allocator%2F1.cc?ref=dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e", "patch": "@@ -0,0 +1,36 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile { target c++17 } }\n+\n+#include <memory_resource>\n+\n+struct X { int i = 0; };\n+\n+using test_type = std::pmr::polymorphic_allocator<X>;\n+\n+static_assert(std::is_default_constructible_v<test_type>);\n+static_assert(std::is_destructible_v<test_type>);\n+static_assert(std::is_copy_constructible_v<test_type>);\n+static_assert(!std::is_copy_assignable_v<test_type>);\n+static_assert(std::is_constructible_v<test_type, std::pmr::memory_resource*>);\n+\n+static_assert(std::is_same_v<test_type::value_type, X>);\n+\n+static_assert(!std::is_polymorphic_v<test_type>);\n+static_assert(!std::is_final_v<test_type>);"}, {"sha": "01f6ace2d8016ddd2be61b4c2164dde5f2c7b199", "filename": "libstdc++-v3/testsuite/20_util/polymorphic_allocator/resource.cc", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpolymorphic_allocator%2Fresource.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpolymorphic_allocator%2Fresource.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpolymorphic_allocator%2Fresource.cc?ref=dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e", "patch": "@@ -0,0 +1,87 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n+// { dg-skip-if \"\" { *-*-* } { -fno-aligned-new } }\n+\n+#include <memory_resource>\n+#include <testsuite_allocator.h>\n+\n+struct X { int i = 0; };\n+\n+using test_type = std::pmr::polymorphic_allocator<X>;\n+\n+void\n+test01()\n+{\n+  __gnu_test::memory_resource r;\n+  test_type a(&r), b(&r);\n+  VERIFY( a == a );\n+  VERIFY( ! (a != a) );\n+  VERIFY( a == b );\n+  VERIFY( ! (a != b) );\n+  VERIFY( a.resource() == &r );\n+  VERIFY( a.resource() == b.resource() );\n+\n+  __gnu_test::memory_resource r2(r);\n+  test_type c(&r2);\n+  VERIFY( c.resource() == &r2 );\n+  VERIFY( c.resource() != a.resource() );\n+  VERIFY( c == a );\n+}\n+\n+void\n+test02()\n+{\n+  __gnu_test::memory_resource r1, r2;\n+  test_type a(&r1), b(&r2);\n+  VERIFY( a == a );\n+  VERIFY( b == b );\n+  VERIFY( ! (a == b) );\n+  VERIFY( ! (b == a) );\n+  VERIFY( a != b );\n+  VERIFY( b != a );\n+  VERIFY( a.resource() == &r1 );\n+  VERIFY( a.resource() != b.resource() );\n+\n+  test_type c;\n+  VERIFY( c == c );\n+  VERIFY( ! (a == c) );\n+  VERIFY( ! (c == a) );\n+  VERIFY( ! (b == c) );\n+  VERIFY( ! (c == b) );\n+  VERIFY( a.resource() != c.resource() );\n+  VERIFY( c.resource() == std::pmr::get_default_resource() );\n+\n+  std::pmr::set_default_resource(&r1);\n+  VERIFY( c.resource() != &r1 );\n+\n+  test_type d;\n+  VERIFY( d.resource() == &r1 );\n+  VERIFY( d != c );\n+  VERIFY( d == a );\n+\n+  std::pmr::set_default_resource(nullptr);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "e5790c032235345a2cca4a39ce22bf1ee8f253b8", "filename": "libstdc++-v3/testsuite/20_util/polymorphic_allocator/select.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpolymorphic_allocator%2Fselect.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpolymorphic_allocator%2Fselect.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpolymorphic_allocator%2Fselect.cc?ref=dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e", "patch": "@@ -0,0 +1,58 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n+// { dg-skip-if \"\" { *-*-* } { -fno-aligned-new } }\n+\n+#include <memory_resource>\n+#include <testsuite_allocator.h>\n+\n+struct X { int i = 0; };\n+\n+using test_type = std::pmr::polymorphic_allocator<X>;\n+\n+void\n+test01()\n+{\n+  test_type a, b;\n+  VERIFY( a.select_on_container_copy_construction() == a );\n+  VERIFY( a.select_on_container_copy_construction() == b );\n+\n+  __gnu_test::memory_resource r;\n+  test_type c(&r);\n+  VERIFY( c.select_on_container_copy_construction() != c );\n+  VERIFY( c.select_on_container_copy_construction() == a );\n+}\n+\n+void\n+test02()\n+{\n+  __gnu_test::memory_resource r;\n+  test_type a(&r);\n+  VERIFY( a.select_on_container_copy_construction() != a );\n+  std::pmr::set_default_resource(&r);\n+  VERIFY( a.select_on_container_copy_construction() == a );\n+  std::pmr::set_default_resource(nullptr);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "03679aad8dcd496e514a60fcbc971c3501c1af29", "filename": "libstdc++-v3/testsuite/util/testsuite_allocator.h", "status": "modified", "additions": 159, "deletions": 1, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_allocator.h?ref=dfaa3c47cc0a5e858ff45e0f2ab4d686048f718e", "patch": "@@ -31,6 +31,10 @@\n #include <ext/pointer.h>\n #include <ext/alloc_traits.h>\n #include <testsuite_hooks.h>\n+#if __cplusplus >= 201703L\n+# include <memory_resource>\n+# include <new>\n+#endif\n \n namespace __gnu_test\n {\n@@ -691,7 +695,161 @@ namespace __gnu_test\n       using PointerBase_void::PointerBase_void;\n       typedef Derived pointer;\n     };\n-#endif\n+#endif // C++11\n+\n+#if __cplusplus >= 201703L && __cpp_aligned_new\n+    // A concrete memory_resource, with error checking.\n+    class memory_resource : public std::pmr::memory_resource\n+    {\n+    public:\n+      memory_resource()\n+      : lists(new allocation_lists)\n+      { }\n+\n+      memory_resource(const memory_resource& r) noexcept\n+      : lists(r.lists)\n+      { lists->refcount++; }\n+\n+      memory_resource& operator=(const memory_resource&) = delete;\n+\n+      ~memory_resource()\n+      {\n+\tif (lists->refcount-- == 1)\n+\t  delete lists;  // last one out turns out the lights\n+      }\n+\n+      struct bad_size { };\n+      struct bad_alignment { };\n+      struct bad_address { };\n+\n+      // Deallocate everything (moving the tracking info to the freed list)\n+      void\n+      deallocate_everything()\n+      {\n+\twhile (lists->active)\n+\t  {\n+\t    auto a = lists->active;\n+\t    // Intentionally virtual dispatch, to inform derived classes:\n+\t    this->do_deallocate(a->p, a->bytes, a->alignment);\n+\t  }\n+      }\n+\n+      // Clear the freed list\n+      void\n+      forget_freed_allocations()\n+      { lists->forget_allocations(lists->freed); }\n+\n+      // Count how many allocations have been done and not freed.\n+      std::size_t\n+      number_of_active_allocations() const noexcept\n+      {\n+\tstd::size_t n = 0;\n+\tfor (auto a = lists->active; a != nullptr; a = a->next)\n+\t  ++n;\n+\treturn n;\n+      }\n+\n+    protected:\n+      void*\n+      do_allocate(std::size_t bytes, std::size_t alignment) override\n+      {\n+\t// TODO perform a single allocation and put the allocation struct\n+\t// in the buffer using placement new? It means deallocation won't\n+\t// actually return memory to the OS, as it will stay in lists->freed.\n+\t//\n+\t// TODO adjust the returned pointer to be minimally aligned?\n+\t// e.g. if alignment==1 don't return something aligned to 2 bytes.\n+\t// Maybe not worth it, at least monotonic_buffer_resource will\n+\t// never ask upstream for anything with small alignment.\n+\tvoid* p = ::operator new(bytes, std::align_val_t(alignment));\n+\tlists->active = new allocation{p, bytes, alignment, lists->active};\n+\treturn p;\n+      }\n+\n+      void\n+      do_deallocate(void* p, std::size_t bytes, std::size_t alignment) override\n+      {\n+\tallocation** aptr = &lists->active;\n+\twhile (*aptr)\n+\t  {\n+\t    allocation* a = *aptr;\n+\t    if (p == a->p)\n+\t      {\n+\t\tif (bytes != a->bytes)\n+\t\t  throw bad_size();\n+\t\tif (alignment != a->alignment)\n+\t\t  throw bad_alignment();\n+\t\t::operator delete(p, bytes, std::align_val_t(alignment));\n+\t\t*aptr = a->next;\n+\t\ta->next = lists->freed;\n+\t\tlists->freed = a;\n+\t\treturn;\n+\t      }\n+\t    aptr = &a->next;\n+\t  }\n+\tthrow bad_address();\n+      }\n+\n+      bool\n+      do_is_equal(const std::pmr::memory_resource& r) const noexcept override\n+      {\n+\t// Equality is determined by sharing the same allocation_lists object.\n+\tif (auto p = dynamic_cast<const memory_resource*>(&r))\n+\t  return p->lists == lists;\n+\treturn false;\n+      }\n+\n+    private:\n+      struct allocation\n+      {\n+\tvoid* p;\n+\tstd::size_t bytes;\n+\tstd::size_t alignment;\n+\tallocation* next;\n+      };\n+\n+      // Maintain list of allocated blocks and list of freed blocks.\n+      // Copies of this memory_resource share the same ref-counted lists.\n+      struct allocation_lists\n+      {\n+\tunsigned refcount = 1;\n+\tallocation* active = nullptr;\n+\tallocation* freed = nullptr;\n+\n+\tvoid forget_allocations(allocation*& list)\n+\t{\n+\t  while (list)\n+\t    {\n+\t      auto p = list;\n+\t      list = list->next;\n+\t      delete p;\n+\t    }\n+\t}\n+\n+\t~allocation_lists()\n+\t{\n+\t  forget_allocations(active); // Anything in this list is a leak!\n+\t  forget_allocations(freed);\n+\t}\n+      };\n+\n+      allocation_lists* lists;\n+    };\n+\n+    // Set the default resource, and restore the previous one on destruction.\n+    struct default_resource_mgr\n+    {\n+      explicit default_resource_mgr(std::pmr::memory_resource* r)\n+      : prev(std::pmr::set_default_resource(r))\n+      { }\n+\n+      ~default_resource_mgr()\n+      { std::pmr::set_default_resource(prev); }\n+\n+      std::pmr::memory_resource* prev;\n+    };\n+\n+#endif // C++17 && aligned-new\n \n } // namespace __gnu_test\n "}]}