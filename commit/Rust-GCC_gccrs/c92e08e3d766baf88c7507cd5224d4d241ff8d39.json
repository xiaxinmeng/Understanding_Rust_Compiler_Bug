{"sha": "c92e08e3d766baf88c7507cd5224d4d241ff8d39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzkyZTA4ZTNkNzY2YmFmODhjNzUwN2NkNTIyNGQ0ZDI0MWZmOGQzOQ==", "commit": {"author": {"name": "Andre Vieira", "email": "andre.simoesdiasvieira@arm.com", "date": "2016-12-02T15:33:26Z"}, "committer": {"name": "Andre Vieira", "email": "avieira@gcc.gnu.org", "date": "2016-12-02T15:33:26Z"}, "message": "ARMv8-M Security Extension's cmse_nonsecure_call: use __gnu_cmse_nonsecure_call\n\n    gcc/ChangeLog:\n    2016-12-02  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n\t\tThomas Preud'homme  <thomas.preudhomme@arm.com>\n\n\t* config/arm/arm.c (detect_cmse_nonsecure_call): New.\n\t(cmse_nonsecure_call_clear_caller_saved): New.\n\t(arm_reorg): Use cmse_nonsecure_call_clear_caller_saved.\n\t(arm_function_ok_for_sibcall): Disable sibcalls for\n\tcmse_nonsecure_call.\n\t* config/arm/arm-protos.h (detect_cmse_nonsecure_call): New.\n\t* config/arm/arm.md (call): Handle cmse_nonsecure_entry.\n\t(call_value): Likewise.\n\t(nonsecure_call_internal): New.\n\t(nonsecure_call_value_internal): New.\n\t* config/arm/thumb1.md (*nonsecure_call_reg_thumb1_v5): New.\n\t(*nonsecure_call_value_reg_thumb1_v5): New.\n\t* config/arm/thumb2.md (*nonsecure_call_reg_thumb2): New.\n\t(*nonsecure_call_value_reg_thumb2): New.\n\t* config/arm/unspecs.md (UNSPEC_NONSECURE_MEM): New.\n\n    libgcc/ChangeLog:\n    2016-12-02  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n\t       Thomas Preud'homme  <thomas.preudhomme@arm.com>\n\n\t* config/arm/cmse_nonsecure_call.S: New.\n\t* config/arm/t-arm: Compile cmse_nonsecure_call.S\n\n    gcc/testsuite/ChangeLog:\n    2016-12-02  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n\t\tThomas Preud'homme  <thomas.preudhomme@arm.com>\n\n\t* gcc.target/arm/cmse/cmse.exp: Run tests in mainline dir.\n\t* gcc.target/arm/cmse/cmse-9.c: Added some extra tests.\n\t* gcc.target/arm/cmse/cmse-14.c: New.\n\t* gcc.target/arm/cmse/baseline/bitfield-4.c: New.\n\t* gcc.target/arm/cmse/baseline/bitfield-5.c: New.\n\t* gcc.target/arm/cmse/baseline/bitfield-6.c: New.\n\t* gcc.target/arm/cmse/baseline/bitfield-7.c: New.\n\t* gcc.target/arm/cmse/baseline/bitfield-8.c: New.\n\t* gcc.target/arm/cmse/baseline/bitfield-9.c: New.\n\t* gcc.target/arm/cmse/baseline/bitfield-and-union-1.c: New.\n\t* gcc.target/arm/cmse/baseline/cmse-11.c: New.\n\t* gcc.target/arm/cmse/baseline/cmse-13.c: New.\n\t* gcc.target/arm/cmse/baseline/cmse-6.c: New.\n\t* gcc.target/arm/cmse/baseline/union-1.c: New.\n\t* gcc.target/arm/cmse/baseline/union-2.c: New.\n\t* gcc.target/arm/cmse/mainline/bitfield-4.c: New.\n\t* gcc.target/arm/cmse/mainline/bitfield-5.c: New.\n\t* gcc.target/arm/cmse/mainline/bitfield-6.c: New.\n\t* gcc.target/arm/cmse/mainline/bitfield-7.c: New.\n\t* gcc.target/arm/cmse/mainline/bitfield-8.c: New.\n\t* gcc.target/arm/cmse/mainline/bitfield-9.c: New.\n\t* gcc.target/arm/cmse/mainline/bitfield-and-union-1.c: New.\n\t* gcc.target/arm/cmse/mainline/union-1.c: New.\n\t* gcc.target/arm/cmse/mainline/union-2.c: New.\n\t* gcc.target/arm/cmse/mainline/hard-sp/cmse-13.c: New.\n\t* gcc.target/arm/cmse/mainline/hard-sp/cmse-7.c: New.\n\t* gcc.target/arm/cmse/mainline/hard-sp/cmse-8.c: New.\n\t* gcc.target/arm/cmse/mainline/hard/cmse-13.c: New.\n\t* gcc.target/arm/cmse/mainline/hard/cmse-7.c: New.\n\t* gcc.target/arm/cmse/mainline/hard/cmse-8.c: New.\n\t* gcc.target/arm/cmse/mainline/soft/cmse-13.c: New.\n\t* gcc.target/arm/cmse/mainline/soft/cmse-7.c: New.\n\t* gcc.target/arm/cmse/mainline/soft/cmse-8.c: New.\n\t* gcc.target/arm/cmse/mainline/softfp-sp/cmse-7.c: New.\n\t* gcc.target/arm/cmse/mainline/softfp-sp/cmse-8.c: New.\n\t* gcc.target/arm/cmse/mainline/softfp/cmse-13.c: New.\n\t* gcc.target/arm/cmse/mainline/softfp/cmse-7.c: New.\n\t* gcc.target/arm/cmse/mainline/softfp/cmse-8.c: New.\n\n\nCo-Authored-By: Thomas Preud'homme <thomas.preudhomme@arm.com>\n\nFrom-SVN: r243192", "tree": {"sha": "dcc8522e2fa876b1abe93f1316abf955b7c1e022", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcc8522e2fa876b1abe93f1316abf955b7c1e022"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c92e08e3d766baf88c7507cd5224d4d241ff8d39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c92e08e3d766baf88c7507cd5224d4d241ff8d39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c92e08e3d766baf88c7507cd5224d4d241ff8d39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c92e08e3d766baf88c7507cd5224d4d241ff8d39/comments", "author": {"login": "avieira-arm", "id": 68072104, "node_id": "MDQ6VXNlcjY4MDcyMTA0", "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4", "gravatar_id": "", "url": "https://api.github.com/users/avieira-arm", "html_url": "https://github.com/avieira-arm", "followers_url": "https://api.github.com/users/avieira-arm/followers", "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}", "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions", "organizations_url": "https://api.github.com/users/avieira-arm/orgs", "repos_url": "https://api.github.com/users/avieira-arm/repos", "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/avieira-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "32ce1e4f244830404328e5a45d062c2f5bee662d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32ce1e4f244830404328e5a45d062c2f5bee662d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32ce1e4f244830404328e5a45d062c2f5bee662d"}], "stats": {"total": 2244, "additions": 2238, "deletions": 6}, "files": [{"sha": "807d40686499c8101c1e032ac5fb473a254c40df", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -1,3 +1,22 @@\n+2016-12-02  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n+\t    Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\t* config/arm/arm.c (detect_cmse_nonsecure_call): New.\n+\t(cmse_nonsecure_call_clear_caller_saved): New.\n+\t(arm_reorg): Use cmse_nonsecure_call_clear_caller_saved.\n+\t(arm_function_ok_for_sibcall): Disable sibcalls for\n+\tcmse_nonsecure_call.\n+\t* config/arm/arm-protos.h (detect_cmse_nonsecure_call): New.\n+\t* config/arm/arm.md (call): Handle cmse_nonsecure_entry.\n+\t(call_value): Likewise.\n+\t(nonsecure_call_internal): New.\n+\t(nonsecure_call_value_internal): New.\n+\t* config/arm/thumb1.md (*nonsecure_call_reg_thumb1_v5): New.\n+\t(*nonsecure_call_value_reg_thumb1_v5): New.\n+\t* config/arm/thumb2.md (*nonsecure_call_reg_thumb2): New.\n+\t(*nonsecure_call_value_reg_thumb2): New.\n+\t* config/arm/unspecs.md (UNSPEC_NONSECURE_MEM): New.\n+\n 2016-12-02  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n \t    Thomas Preud'homme  <thomas.preudhomme@arm.com>\n "}, {"sha": "05d73ab2271d28ce8d6d49199341d4365f0a2bcb", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -137,6 +137,7 @@ extern int arm_const_double_inline_cost (rtx);\n extern bool arm_const_double_by_parts (rtx);\n extern bool arm_const_double_by_immediates (rtx);\n extern void arm_emit_call_insn (rtx, rtx, bool);\n+bool detect_cmse_nonsecure_call (tree);\n extern const char *output_call (rtx *);\n void arm_emit_movpair (rtx, rtx);\n extern const char *output_mov_long_double_arm_from_arm (rtx *);"}, {"sha": "f1df3a0971010375c116041e38153f96b24e7aae", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -7000,6 +7000,15 @@ arm_function_ok_for_sibcall (tree decl, tree exp)\n   if (IS_CMSE_ENTRY (arm_current_func_type ()))\n     return false;\n \n+  /* We do not allow ARMv8-M non-secure calls to be turned into sibling calls,\n+     this would complicate matters for later code generation.  */\n+  if (TREE_CODE (exp) == CALL_EXPR)\n+    {\n+      tree fntype = TREE_TYPE (TREE_TYPE (CALL_EXPR_FN (exp)));\n+      if (lookup_attribute (\"cmse_nonsecure_call\", TYPE_ATTRIBUTES (fntype)))\n+\treturn false;\n+    }\n+\n   if (!VOID_TYPE_P (TREE_TYPE (DECL_RESULT (cfun->decl))))\n     {\n       /* Check that the return value locations are the same.  For\n@@ -16654,6 +16663,197 @@ compute_not_to_clear_mask (tree arg_type, rtx arg_rtx, int regno,\n   return not_to_clear_mask;\n }\n \n+/* Saves callee saved registers, clears callee saved registers and caller saved\n+   registers not used to pass arguments before a cmse_nonsecure_call.  And\n+   restores the callee saved registers after.  */\n+\n+static void\n+cmse_nonsecure_call_clear_caller_saved (void)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      rtx_insn *insn;\n+\n+      FOR_BB_INSNS (bb, insn)\n+\t{\n+\t  uint64_t to_clear_mask, float_mask;\n+\t  rtx_insn *seq;\n+\t  rtx pat, call, unspec, reg, cleared_reg, tmp;\n+\t  unsigned int regno, maxregno;\n+\t  rtx address;\n+\t  CUMULATIVE_ARGS args_so_far_v;\n+\t  cumulative_args_t args_so_far;\n+\t  tree arg_type, fntype;\n+\t  bool using_r4, first_param = true;\n+\t  function_args_iterator args_iter;\n+\t  uint32_t padding_bits_to_clear[4] = {0U, 0U, 0U, 0U};\n+\t  uint32_t * padding_bits_to_clear_ptr = &padding_bits_to_clear[0];\n+\n+\t  if (!NONDEBUG_INSN_P (insn))\n+\t    continue;\n+\n+\t  if (!CALL_P (insn))\n+\t    continue;\n+\n+\t  pat = PATTERN (insn);\n+\t  gcc_assert (GET_CODE (pat) == PARALLEL && XVECLEN (pat, 0) > 0);\n+\t  call = XVECEXP (pat, 0, 0);\n+\n+\t  /* Get the real call RTX if the insn sets a value, ie. returns.  */\n+\t  if (GET_CODE (call) == SET)\n+\t      call = SET_SRC (call);\n+\n+\t  /* Check if it is a cmse_nonsecure_call.  */\n+\t  unspec = XEXP (call, 0);\n+\t  if (GET_CODE (unspec) != UNSPEC\n+\t      || XINT (unspec, 1) != UNSPEC_NONSECURE_MEM)\n+\t    continue;\n+\n+\t  /* Determine the caller-saved registers we need to clear.  */\n+\t  to_clear_mask = (1LL << (NUM_ARG_REGS)) - 1;\n+\t  maxregno = NUM_ARG_REGS - 1;\n+\t  /* Only look at the caller-saved floating point registers in case of\n+\t     -mfloat-abi=hard.  For -mfloat-abi=softfp we will be using the\n+\t     lazy store and loads which clear both caller- and callee-saved\n+\t     registers.  */\n+\t  if (TARGET_HARD_FLOAT_ABI)\n+\t    {\n+\t      float_mask = (1LL << (D7_VFP_REGNUM + 1)) - 1;\n+\t      float_mask &= ~((1LL << FIRST_VFP_REGNUM) - 1);\n+\t      to_clear_mask |= float_mask;\n+\t      maxregno = D7_VFP_REGNUM;\n+\t    }\n+\n+\t  /* Make sure the register used to hold the function address is not\n+\t     cleared.  */\n+\t  address = RTVEC_ELT (XVEC (unspec, 0), 0);\n+\t  gcc_assert (MEM_P (address));\n+\t  gcc_assert (REG_P (XEXP (address, 0)));\n+\t  to_clear_mask &= ~(1LL << REGNO (XEXP (address, 0)));\n+\n+\t  /* Set basic block of call insn so that df rescan is performed on\n+\t     insns inserted here.  */\n+\t  set_block_for_insn (insn, bb);\n+\t  df_set_flags (DF_DEFER_INSN_RESCAN);\n+\t  start_sequence ();\n+\n+\t  /* Make sure the scheduler doesn't schedule other insns beyond\n+\t     here.  */\n+\t  emit_insn (gen_blockage ());\n+\n+\t  /* Walk through all arguments and clear registers appropriately.\n+\t  */\n+\t  fntype = TREE_TYPE (MEM_EXPR (address));\n+\t  arm_init_cumulative_args (&args_so_far_v, fntype, NULL_RTX,\n+\t\t\t\t    NULL_TREE);\n+\t  args_so_far = pack_cumulative_args (&args_so_far_v);\n+\t  FOREACH_FUNCTION_ARGS (fntype, arg_type, args_iter)\n+\t    {\n+\t      rtx arg_rtx;\n+\t      machine_mode arg_mode = TYPE_MODE (arg_type);\n+\n+\t      if (VOID_TYPE_P (arg_type))\n+\t\tcontinue;\n+\n+\t      if (!first_param)\n+\t\tarm_function_arg_advance (args_so_far, arg_mode, arg_type,\n+\t\t\t\t\t  true);\n+\n+\t      arg_rtx = arm_function_arg (args_so_far, arg_mode, arg_type,\n+\t\t\t\t\t  true);\n+\t      gcc_assert (REG_P (arg_rtx));\n+\t      to_clear_mask\n+\t\t&= ~compute_not_to_clear_mask (arg_type, arg_rtx,\n+\t\t\t\t\t       REGNO (arg_rtx),\n+\t\t\t\t\t       padding_bits_to_clear_ptr);\n+\n+\t      first_param = false;\n+\t    }\n+\n+\t  /* Clear padding bits where needed.  */\n+\t  cleared_reg = XEXP (address, 0);\n+\t  reg = gen_rtx_REG (SImode, IP_REGNUM);\n+\t  using_r4 = false;\n+\t  for (regno = R0_REGNUM; regno < NUM_ARG_REGS; regno++)\n+\t    {\n+\t      if (padding_bits_to_clear[regno] == 0)\n+\t\tcontinue;\n+\n+\t      /* If this is a Thumb-1 target copy the address of the function\n+\t\t we are calling from 'r4' into 'ip' such that we can use r4 to\n+\t\t clear the unused bits in the arguments.  */\n+\t      if (TARGET_THUMB1 && !using_r4)\n+\t\t{\n+\t\t  using_r4 =  true;\n+\t\t  reg = cleared_reg;\n+\t\t  emit_move_insn (gen_rtx_REG (SImode, IP_REGNUM),\n+\t\t\t\t\t  reg);\n+\t\t}\n+\n+\t      tmp = GEN_INT ((((~padding_bits_to_clear[regno]) << 16u) >> 16u));\n+\t      emit_move_insn (reg, tmp);\n+\t      /* Also fill the top half of the negated\n+\t\t padding_bits_to_clear.  */\n+\t      if (((~padding_bits_to_clear[regno]) >> 16) > 0)\n+\t\t{\n+\t\t  tmp = GEN_INT ((~padding_bits_to_clear[regno]) >> 16);\n+\t\t  emit_insn (gen_rtx_SET (gen_rtx_ZERO_EXTRACT (SImode, reg,\n+\t\t\t\t\t\t\t\tGEN_INT (16),\n+\t\t\t\t\t\t\t\tGEN_INT (16)),\n+\t\t\t\t\t  tmp));\n+\t\t}\n+\n+\t      emit_insn (gen_andsi3 (gen_rtx_REG (SImode, regno),\n+\t\t\t\t     gen_rtx_REG (SImode, regno),\n+\t\t\t\t     reg));\n+\n+\t    }\n+\t  if (using_r4)\n+\t    emit_move_insn (cleared_reg,\n+\t\t\t    gen_rtx_REG (SImode, IP_REGNUM));\n+\n+\t  /* We use right shift and left shift to clear the LSB of the address\n+\t     we jump to instead of using bic, to avoid having to use an extra\n+\t     register on Thumb-1.  */\n+\t  tmp = gen_rtx_LSHIFTRT (SImode, cleared_reg, const1_rtx);\n+\t  emit_insn (gen_rtx_SET (cleared_reg, tmp));\n+\t  tmp = gen_rtx_ASHIFT (SImode, cleared_reg, const1_rtx);\n+\t  emit_insn (gen_rtx_SET (cleared_reg, tmp));\n+\n+\t  /* Clearing all registers that leak before doing a non-secure\n+\t     call.  */\n+\t  for (regno = R0_REGNUM; regno <= maxregno; regno++)\n+\t    {\n+\t      if (!(to_clear_mask & (1LL << regno)))\n+\t\tcontinue;\n+\n+\t      /* If regno is an even vfp register and its successor is also to\n+\t\t be cleared, use vmov.  */\n+\t      if (IS_VFP_REGNUM (regno))\n+\t\t{\n+\t\t  if (TARGET_VFP_DOUBLE\n+\t\t      && VFP_REGNO_OK_FOR_DOUBLE (regno)\n+\t\t      && to_clear_mask & (1LL << (regno + 1)))\n+\t\t    emit_move_insn (gen_rtx_REG (DFmode, regno++),\n+\t\t\t\t    CONST0_RTX (DFmode));\n+\t\t  else\n+\t\t    emit_move_insn (gen_rtx_REG (SFmode, regno),\n+\t\t\t\t    CONST0_RTX (SFmode));\n+\t\t}\n+\t      else\n+\t\temit_move_insn (gen_rtx_REG (SImode, regno), cleared_reg);\n+\t    }\n+\n+\t  seq = get_insns ();\n+\t  end_sequence ();\n+\t  emit_insn_before (seq, insn);\n+\n+\t}\n+    }\n+}\n+\n /* Rewrite move insn into subtract of 0 if the condition codes will\n    be useful in next conditional jump insn.  */\n \n@@ -16954,6 +17154,8 @@ arm_reorg (void)\n   HOST_WIDE_INT address = 0;\n   Mfix * fix;\n \n+  if (use_cmse)\n+    cmse_nonsecure_call_clear_caller_saved ();\n   if (TARGET_THUMB1)\n     thumb1_reorg ();\n   else if (TARGET_THUMB2)\n@@ -17326,6 +17528,23 @@ vfp_emit_fstmd (int base_reg, int count)\n   return count * 8;\n }\n \n+/* Returns true if -mcmse has been passed and the function pointed to by 'addr'\n+   has the cmse_nonsecure_call attribute and returns false otherwise.  */\n+\n+bool\n+detect_cmse_nonsecure_call (tree addr)\n+{\n+  if (!addr)\n+    return FALSE;\n+\n+  tree fntype = TREE_TYPE (addr);\n+  if (use_cmse && lookup_attribute (\"cmse_nonsecure_call\",\n+\t\t\t\t    TYPE_ATTRIBUTES (fntype)))\n+    return TRUE;\n+  return FALSE;\n+}\n+\n+\n /* Emit a call instruction with pattern PAT.  ADDR is the address of\n    the call target.  */\n "}, {"sha": "d561a4b5d1be9a7bd159f51b50ec736bd89f8fd1", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 62, "deletions": 5, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -8052,6 +8052,7 @@\n   \"\n   {\n     rtx callee, pat;\n+    tree addr = MEM_EXPR (operands[0]);\n     \n     /* In an untyped call, we can get NULL for operand 2.  */\n     if (operands[2] == NULL_RTX)\n@@ -8066,8 +8067,17 @@\n \t: !REG_P (callee))\n       XEXP (operands[0], 0) = force_reg (Pmode, callee);\n \n-    pat = gen_call_internal (operands[0], operands[1], operands[2]);\n-    arm_emit_call_insn (pat, XEXP (operands[0], 0), false);\n+    if (detect_cmse_nonsecure_call (addr))\n+      {\n+\tpat = gen_nonsecure_call_internal (operands[0], operands[1],\n+\t\t\t\t\t   operands[2]);\n+\temit_call_insn (pat);\n+      }\n+    else\n+      {\n+\tpat = gen_call_internal (operands[0], operands[1], operands[2]);\n+\tarm_emit_call_insn (pat, XEXP (operands[0], 0), false);\n+      }\n     DONE;\n   }\"\n )\n@@ -8078,6 +8088,24 @@\n \t      (use (match_operand 2 \"\" \"\"))\n \t      (clobber (reg:SI LR_REGNUM))])])\n \n+(define_expand \"nonsecure_call_internal\"\n+  [(parallel [(call (unspec:SI [(match_operand 0 \"memory_operand\" \"\")]\n+\t\t\t       UNSPEC_NONSECURE_MEM)\n+\t\t    (match_operand 1 \"general_operand\" \"\"))\n+\t      (use (match_operand 2 \"\" \"\"))\n+\t      (clobber (reg:SI LR_REGNUM))\n+\t      (clobber (reg:SI 4))])]\n+  \"use_cmse\"\n+  \"\n+  {\n+    rtx tmp;\n+    tmp = copy_to_suggested_reg (XEXP (operands[0], 0),\n+\t\t\t\t gen_rtx_REG (SImode, 4),\n+\t\t\t\t SImode);\n+\n+    operands[0] = replace_equiv_address (operands[0], tmp);\n+  }\")\n+\n (define_insn \"*call_reg_armv5\"\n   [(call (mem:SI (match_operand:SI 0 \"s_register_operand\" \"r\"))\n          (match_operand 1 \"\" \"\"))\n@@ -8113,6 +8141,7 @@\n   \"\n   {\n     rtx pat, callee;\n+    tree addr = MEM_EXPR (operands[1]);\n     \n     /* In an untyped call, we can get NULL for operand 2.  */\n     if (operands[3] == 0)\n@@ -8127,9 +8156,18 @@\n \t: !REG_P (callee))\n       XEXP (operands[1], 0) = force_reg (Pmode, callee);\n \n-    pat = gen_call_value_internal (operands[0], operands[1],\n-\t\t\t\t   operands[2], operands[3]);\n-    arm_emit_call_insn (pat, XEXP (operands[1], 0), false);\n+    if (detect_cmse_nonsecure_call (addr))\n+      {\n+\tpat = gen_nonsecure_call_value_internal (operands[0], operands[1],\n+\t\t\t\t\t\t operands[2], operands[3]);\n+\temit_call_insn (pat);\n+      }\n+    else\n+      {\n+\tpat = gen_call_value_internal (operands[0], operands[1],\n+\t\t\t\t       operands[2], operands[3]);\n+\tarm_emit_call_insn (pat, XEXP (operands[1], 0), false);\n+      }\n     DONE;\n   }\"\n )\n@@ -8141,6 +8179,25 @@\n \t      (use (match_operand 3 \"\" \"\"))\n \t      (clobber (reg:SI LR_REGNUM))])])\n \n+(define_expand \"nonsecure_call_value_internal\"\n+  [(parallel [(set (match_operand       0 \"\" \"\")\n+\t\t   (call (unspec:SI [(match_operand 1 \"memory_operand\" \"\")]\n+\t\t\t\t    UNSPEC_NONSECURE_MEM)\n+\t\t\t (match_operand 2 \"general_operand\" \"\")))\n+\t      (use (match_operand 3 \"\" \"\"))\n+\t      (clobber (reg:SI LR_REGNUM))\n+\t      (clobber (reg:SI 4))])]\n+  \"use_cmse\"\n+  \"\n+  {\n+    rtx tmp;\n+    tmp = copy_to_suggested_reg (XEXP (operands[1], 0),\n+\t\t\t\t gen_rtx_REG (SImode, 4),\n+\t\t\t\t SImode);\n+\n+    operands[1] = replace_equiv_address (operands[1], tmp);\n+  }\")\n+\n (define_insn \"*call_value_reg_armv5\"\n   [(set (match_operand 0 \"\" \"\")\n         (call (mem:SI (match_operand:SI 1 \"s_register_operand\" \"r\"))"}, {"sha": "f9e934fab015c5b8bda344a5a2ca0341912080a8", "filename": "gcc/config/arm/thumb1.md", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Fconfig%2Farm%2Fthumb1.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Fconfig%2Farm%2Fthumb1.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb1.md?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -1731,6 +1731,19 @@\n    (set_attr \"type\" \"call\")]\n )\n \n+(define_insn \"*nonsecure_call_reg_thumb1_v5\"\n+  [(call (unspec:SI [(mem:SI (match_operand:SI 0 \"register_operand\" \"l*r\"))]\n+\t\t    UNSPEC_NONSECURE_MEM)\n+\t (match_operand 1 \"\" \"\"))\n+   (use (match_operand 2 \"\" \"\"))\n+   (clobber (reg:SI LR_REGNUM))\n+   (clobber (match_dup 0))]\n+  \"TARGET_THUMB1 && use_cmse && !SIBLING_CALL_P (insn)\"\n+  \"bl\\\\t__gnu_cmse_nonsecure_call\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"call\")]\n+)\n+\n (define_insn \"*call_reg_thumb1\"\n   [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"l*r\"))\n \t (match_operand 1 \"\" \"\"))\n@@ -1763,6 +1776,21 @@\n    (set_attr \"type\" \"call\")]\n )\n \n+(define_insn \"*nonsecure_call_value_reg_thumb1_v5\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (unspec:SI\n+\t       [(mem:SI (match_operand:SI 1 \"register_operand\" \"l*r\"))]\n+\t       UNSPEC_NONSECURE_MEM)\n+\t      (match_operand 2 \"\" \"\")))\n+   (use (match_operand 3 \"\" \"\"))\n+   (clobber (reg:SI LR_REGNUM))\n+   (clobber (match_dup 1))]\n+  \"TARGET_THUMB1 && use_cmse\"\n+  \"bl\\\\t__gnu_cmse_nonsecure_call\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"call\")]\n+)\n+\n (define_insn \"*call_value_reg_thumb1\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"l*r\"))"}, {"sha": "9b078a5c6a7ebd2ea7d1c39d9b6a80ce7b69a7dc", "filename": "gcc/config/arm/thumb2.md", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Fconfig%2Farm%2Fthumb2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Fconfig%2Farm%2Fthumb2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb2.md?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -580,6 +580,19 @@\n   [(set_attr \"type\" \"call\")]\n )\n \n+(define_insn \"*nonsecure_call_reg_thumb2\"\n+  [(call (unspec:SI [(mem:SI (match_operand:SI 0 \"s_register_operand\" \"r\"))]\n+\t\t    UNSPEC_NONSECURE_MEM)\n+\t (match_operand 1 \"\" \"\"))\n+   (use (match_operand 2 \"\" \"\"))\n+   (clobber (reg:SI LR_REGNUM))\n+   (clobber (match_dup 0))]\n+  \"TARGET_THUMB2 && use_cmse\"\n+  \"bl\\\\t__gnu_cmse_nonsecure_call\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"call\")]\n+)\n+\n (define_insn \"*call_value_reg_thumb2\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"l*r\"))\n@@ -591,6 +604,21 @@\n   [(set_attr \"type\" \"call\")]\n )\n \n+(define_insn \"*nonsecure_call_value_reg_thumb2\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call\n+\t (unspec:SI [(mem:SI (match_operand:SI 1 \"register_operand\" \"l*r\"))]\n+\t\t    UNSPEC_NONSECURE_MEM)\n+\t (match_operand 2 \"\" \"\")))\n+   (use (match_operand 3 \"\" \"\"))\n+   (clobber (reg:SI LR_REGNUM))\n+   (clobber (match_dup 1))]\n+  \"TARGET_THUMB2 && use_cmse\"\n+  \"bl\\t__gnu_cmse_nonsecure_call\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"call\")]\n+)\n+\n (define_insn \"*thumb2_indirect_jump\"\n   [(set (pc)\n \t(match_operand:SI 0 \"register_operand\" \"l*r\"))]"}, {"sha": "1aa39e8e0b9ddf17bb535c4d82959e569d3c9fd5", "filename": "gcc/config/arm/unspecs.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Fconfig%2Farm%2Funspecs.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Fconfig%2Farm%2Funspecs.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Funspecs.md?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -84,6 +84,8 @@\n   UNSPEC_VRINTA         ; Represent a float to integral float rounding\n                         ; towards nearest, ties away from zero.\n   UNSPEC_PROBE_STACK    ; Probe stack memory reference\n+  UNSPEC_NONSECURE_MEM\t; Represent non-secure memory in ARMv8-M with\n+\t\t\t; security extension\n ])\n \n (define_c_enum \"unspec\" ["}, {"sha": "e9786b70e1b4be9fd38253c9415b68f2339bc991", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -1,3 +1,45 @@\n+2016-12-02  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n+\t    Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\t* gcc.target/arm/cmse/cmse.exp: Run tests in mainline dir.\n+\t* gcc.target/arm/cmse/cmse-9.c: Added some extra tests.\n+\t* gcc.target/arm/cmse/cmse-14.c: New.\n+\t* gcc.target/arm/cmse/baseline/bitfield-4.c: New.\n+\t* gcc.target/arm/cmse/baseline/bitfield-5.c: New.\n+\t* gcc.target/arm/cmse/baseline/bitfield-6.c: New.\n+\t* gcc.target/arm/cmse/baseline/bitfield-7.c: New.\n+\t* gcc.target/arm/cmse/baseline/bitfield-8.c: New.\n+\t* gcc.target/arm/cmse/baseline/bitfield-9.c: New.\n+\t* gcc.target/arm/cmse/baseline/bitfield-and-union-1.c: New.\n+\t* gcc.target/arm/cmse/baseline/cmse-11.c: New.\n+\t* gcc.target/arm/cmse/baseline/cmse-13.c: New.\n+\t* gcc.target/arm/cmse/baseline/cmse-6.c: New.\n+\t* gcc.target/arm/cmse/baseline/union-1.c: New.\n+\t* gcc.target/arm/cmse/baseline/union-2.c: New.\n+\t* gcc.target/arm/cmse/mainline/bitfield-4.c: New.\n+\t* gcc.target/arm/cmse/mainline/bitfield-5.c: New.\n+\t* gcc.target/arm/cmse/mainline/bitfield-6.c: New.\n+\t* gcc.target/arm/cmse/mainline/bitfield-7.c: New.\n+\t* gcc.target/arm/cmse/mainline/bitfield-8.c: New.\n+\t* gcc.target/arm/cmse/mainline/bitfield-9.c: New.\n+\t* gcc.target/arm/cmse/mainline/bitfield-and-union-1.c: New.\n+\t* gcc.target/arm/cmse/mainline/union-1.c: New.\n+\t* gcc.target/arm/cmse/mainline/union-2.c: New.\n+\t* gcc.target/arm/cmse/mainline/hard-sp/cmse-13.c: New.\n+\t* gcc.target/arm/cmse/mainline/hard-sp/cmse-7.c: New.\n+\t* gcc.target/arm/cmse/mainline/hard-sp/cmse-8.c: New.\n+\t* gcc.target/arm/cmse/mainline/hard/cmse-13.c: New.\n+\t* gcc.target/arm/cmse/mainline/hard/cmse-7.c: New.\n+\t* gcc.target/arm/cmse/mainline/hard/cmse-8.c: New.\n+\t* gcc.target/arm/cmse/mainline/soft/cmse-13.c: New.\n+\t* gcc.target/arm/cmse/mainline/soft/cmse-7.c: New.\n+\t* gcc.target/arm/cmse/mainline/soft/cmse-8.c: New.\n+\t* gcc.target/arm/cmse/mainline/softfp-sp/cmse-7.c: New.\n+\t* gcc.target/arm/cmse/mainline/softfp-sp/cmse-8.c: New.\n+\t* gcc.target/arm/cmse/mainline/softfp/cmse-13.c: New.\n+\t* gcc.target/arm/cmse/mainline/softfp/cmse-7.c: New.\n+\t* gcc.target/arm/cmse/mainline/softfp/cmse-8.c: New.\n+\n 2016-12-02  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n \t    Thomas Preud'homme  <thomas.preudhomme@arm.com>\n "}, {"sha": "a6c1386c06edbdb58e76fa5e612c918010c507f6", "filename": "gcc/testsuite/gcc.target/arm/cmse/baseline/bitfield-4.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fbitfield-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fbitfield-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fbitfield-4.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,57 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcmse\" } */\n+\n+typedef struct\n+{\n+  unsigned char a;\n+  unsigned int b:5;\n+  unsigned int c:11, :0, d:8;\n+  struct { unsigned int ee:2; } e;\n+} test_st;\n+\n+typedef union\n+{\n+  test_st st;\n+  struct\n+    {\n+      unsigned int v1;\n+      unsigned int v2;\n+      unsigned int v3;\n+      unsigned int v4;\n+    }values;\n+} read_st;\n+\n+\n+typedef void __attribute__ ((cmse_nonsecure_call)) (*foo_ns) (test_st);\n+\n+extern void foo (test_st st);\n+\n+int\n+main (void)\n+{\n+  read_st r;\n+  foo_ns f;\n+\n+  f = (foo_ns) 0x200000;\n+  r.values.v1 = 0xFFFFFFFF;\n+  r.values.v2 = 0xFFFFFFFF;\n+  r.values.v3 = 0xFFFFFFFF;\n+  r.values.v4 = 0xFFFFFFFF;\n+\n+  f (r.st);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"mov\\tip, r4\" } } */\n+/* { dg-final { scan-assembler \"movw\\tr4, #65535\" } } */\n+/* { dg-final { scan-assembler \"movt\\tr4, 255\" } } */\n+/* { dg-final { scan-assembler \"ands\\tr0, r4\" } } */\n+/* { dg-final { scan-assembler \"movs\\tr4, #255\" } } */\n+/* { dg-final { scan-assembler \"ands\\tr1, r4\" } } */\n+/* { dg-final { scan-assembler \"movs\\tr4, #3\" } } */\n+/* { dg-final { scan-assembler \"ands\\tr2, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr4, ip\" } } */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"movs\\tr3, r4\" } } */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}, {"sha": "d51ce2d42c051aeda8b06ad97086f2563a5fc47d", "filename": "gcc/testsuite/gcc.target/arm/cmse/baseline/bitfield-5.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fbitfield-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fbitfield-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fbitfield-5.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcmse\" } */\n+\n+typedef struct\n+{\n+  unsigned char\t  a;\n+  unsigned short  b :5;\n+  unsigned char\t  c;\n+  unsigned short  d :11;\n+} test_st;\n+\n+typedef union\n+{\n+  test_st st;\n+  struct\n+    {\n+      unsigned int v1;\n+      unsigned int v2;\n+      unsigned int v3;\n+      unsigned int v4;\n+    }values;\n+} read_st;\n+\n+\n+typedef void __attribute__ ((cmse_nonsecure_call)) (*foo_ns) (test_st);\n+\n+int\n+main (void)\n+{\n+  read_st r;\n+  foo_ns f;\n+\n+  f = (foo_ns) 0x200000;\n+  r.values.v1 = 0xFFFFFFFF;\n+  r.values.v2 = 0xFFFFFFFF;\n+\n+  f (r.st);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"mov\\tip, r4\" } } */\n+/* { dg-final { scan-assembler \"movw\\tr4, #8191\" } } */\n+/* { dg-final { scan-assembler \"movt\\tr4, 255\" } } */\n+/* { dg-final { scan-assembler \"ands\\tr0, r4\" } } */\n+/* { dg-final { scan-assembler \"movw\\tr4, #2047\" } } */\n+/* { dg-final { scan-assembler \"ands\\tr1, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr4, ip\" } } */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"movs\\tr2, r4\" } } */\n+/* { dg-final { scan-assembler \"movs\\tr3, r4\" } } */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+"}, {"sha": "77e9104b546a7693fcb2399622e828b1197eac1b", "filename": "gcc/testsuite/gcc.target/arm/cmse/baseline/bitfield-6.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fbitfield-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fbitfield-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fbitfield-6.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcmse\" } */\n+\n+typedef struct\n+{\n+  unsigned char a;\n+  unsigned int\tb : 3;\n+  unsigned int\tc : 14;\n+  unsigned int\td : 1;\n+  struct {\n+      unsigned int    ee  : 2;\n+      unsigned short  ff  : 15;\n+  } e;\n+  unsigned char\tg : 1;\n+  unsigned char\t  : 4;\n+  unsigned char\th : 3;\n+} test_st;\n+\n+typedef union\n+{\n+  test_st st;\n+  struct\n+    {\n+      unsigned int v1;\n+      unsigned int v2;\n+      unsigned int v3;\n+      unsigned int v4;\n+    }values;\n+} read_st;\n+\n+\n+typedef void __attribute__ ((cmse_nonsecure_call)) (*foo_ns) (test_st);\n+\n+int\n+main (void)\n+{\n+  read_st r;\n+  foo_ns f;\n+\n+  f = (foo_ns) 0x200000;\n+  r.values.v1 = 0xFFFFFFFF;\n+  r.values.v2 = 0xFFFFFFFF;\n+  r.values.v3 = 0xFFFFFFFF;\n+  r.values.v4 = 0xFFFFFFFF;\n+\n+  f (r.st);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"mov\\tip, r4\" } } */\n+/* { dg-final { scan-assembler \"movw\\tr4, #65535\" } } */\n+/* { dg-final { scan-assembler \"movt\\tr4, 1023\" } } */\n+/* { dg-final { scan-assembler \"ands\\tr0, r4\" } } */\n+/* { dg-final { scan-assembler \"movs\\tr4, #3\" } } */\n+/* { dg-final { scan-assembler \"movt\\tr4, 32767\" } } */\n+/* { dg-final { scan-assembler \"ands\\tr1, r4\" } } */\n+/* { dg-final { scan-assembler \"movs\\tr4, #255\" } } */\n+/* { dg-final { scan-assembler \"ands\\tr2, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr4, ip\" } } */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"movs\\tr3, r4\" } } */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}, {"sha": "3d8941bbfeebd59744c43f10c842816b36ec9915", "filename": "gcc/testsuite/gcc.target/arm/cmse/baseline/bitfield-7.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fbitfield-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fbitfield-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fbitfield-7.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcmse\" } */\n+\n+typedef struct\n+{\n+  unsigned char\t  a;\n+  unsigned short  b :5;\n+  unsigned char\t  c;\n+  unsigned short  d :11;\n+} test_st;\n+\n+typedef union\n+{\n+  test_st st;\n+  struct\n+    {\n+      unsigned int v1;\n+      unsigned int v2;\n+      unsigned int v3;\n+      unsigned int v4;\n+    }values;\n+} read_st;\n+\n+\n+typedef void __attribute__ ((cmse_nonsecure_call)) (*foo_ns) (test_st);\n+\n+int\n+main (void)\n+{\n+  read_st r;\n+  foo_ns f;\n+\n+  f = (foo_ns) 0x200000;\n+  r.values.v1 = 0xFFFFFFFF;\n+  r.values.v2 = 0xFFFFFFFF;\n+\n+  f (r.st);\n+  return 0;\n+}\n+\n+\n+/* { dg-final { scan-assembler \"mov\\tip, r4\" } } */\n+/* { dg-final { scan-assembler \"movw\\tr4, #8191\" } } */\n+/* { dg-final { scan-assembler \"movt\\tr4, 255\" } } */\n+/* { dg-final { scan-assembler \"ands\\tr0, r4\" } } */\n+/* { dg-final { scan-assembler \"movw\\tr4, #2047\" } } */\n+/* { dg-final { scan-assembler \"ands\\tr1, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr4, ip\" } } */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"movs\\tr2, r4\" } } */\n+/* { dg-final { scan-assembler \"movs\\tr3, r4\" } } */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+"}, {"sha": "9ffbb718d34d5bb8f10e1f3c0505c7dc393c670c", "filename": "gcc/testsuite/gcc.target/arm/cmse/baseline/bitfield-8.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fbitfield-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fbitfield-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fbitfield-8.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,57 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcmse\" } */\n+\n+typedef struct\n+{\n+  unsigned char\t  a;\n+  unsigned int\t    :0;\n+  unsigned int\t  b :1;\n+  unsigned short    :0;\n+  unsigned short  c;\n+  unsigned int\t    :0;\n+  unsigned int\t  d :21;\n+} test_st;\n+\n+typedef union\n+{\n+  test_st st;\n+  struct\n+    {\n+      unsigned int v1;\n+      unsigned int v2;\n+      unsigned int v3;\n+      unsigned int v4;\n+    }values;\n+} read_st;\n+\n+typedef void __attribute__ ((cmse_nonsecure_call)) (*foo_ns) (test_st);\n+\n+int\n+main (void)\n+{\n+  read_st r;\n+  foo_ns f;\n+\n+  f = (foo_ns) 0x200000;\n+  r.values.v1 = 0xFFFFFFFF;\n+  r.values.v2 = 0xFFFFFFFF;\n+  r.values.v3 = 0xFFFFFFFF;\n+\n+  f (r.st);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"mov\\tip, r4\" } } */\n+/* { dg-final { scan-assembler \"movs\\tr4, #255\" } } */\n+/* { dg-final { scan-assembler \"ands\\tr0, r4\" } } */\n+/* { dg-final { scan-assembler \"movs\\tr4, #1\" } } */\n+/* { dg-final { scan-assembler \"movt\\tr4, 65535\" } } */\n+/* { dg-final { scan-assembler \"ands\\tr1, r4\" } } */\n+/* { dg-final { scan-assembler \"movw\\tr4, #65535\" } } */\n+/* { dg-final { scan-assembler \"movt\\tr4, 31\" } } */\n+/* { dg-final { scan-assembler \"ands\\tr2, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr4, ip\" } } */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"movs\\tr3, r4\" } } */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}, {"sha": "8a6141829237823b8734de045a590a1917fa60b8", "filename": "gcc/testsuite/gcc.target/arm/cmse/baseline/bitfield-9.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fbitfield-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fbitfield-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fbitfield-9.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcmse\" } */\n+\n+typedef struct\n+{\n+  char a:3;\n+} test_st3;\n+\n+typedef struct\n+{\n+  char a:3;\n+} test_st2;\n+\n+typedef struct\n+{\n+  test_st2 st2;\n+  test_st3 st3;\n+} test_st;\n+\n+typedef union\n+{\n+  test_st st;\n+  struct\n+    {\n+      unsigned int v1;\n+      unsigned int v2;\n+      unsigned int v3;\n+      unsigned int v4;\n+    }values;\n+} read_st;\n+\n+typedef void __attribute__ ((cmse_nonsecure_call)) (*foo_ns) (test_st);\n+\n+int\n+main (void)\n+{\n+  read_st r;\n+  foo_ns f;\n+\n+  f = (foo_ns) 0x200000;\n+  r.values.v1 = 0xFFFFFFFF;\n+\n+  f (r.st);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"mov\\tip, r4\" } } */\n+/* { dg-final { scan-assembler \"movw\\tr4, #1799\" } } */\n+/* { dg-final { scan-assembler \"ands\\tr0, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr4, ip\" } } */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"movs\\tr1, r4\" } } */\n+/* { dg-final { scan-assembler \"movs\\tr2, r4\" } } */\n+/* { dg-final { scan-assembler \"movs\\tr3, r4\" } } */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}, {"sha": "642f4e0346b5186c78645780b45fe9c838848d45", "filename": "gcc/testsuite/gcc.target/arm/cmse/baseline/bitfield-and-union-1.c", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fbitfield-and-union-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fbitfield-and-union-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fbitfield-and-union-1.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,96 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcmse\" } */\n+\n+typedef struct\n+{\n+  unsigned short a :11;\n+} test_st_4;\n+\n+typedef union\n+{\n+  char\t      a;\n+  test_st_4 st4;\n+}test_un_2;\n+\n+typedef struct\n+{\n+  unsigned char\t  a;\n+  unsigned int\t    :0;\n+  unsigned int\t  b :1;\n+  unsigned short    :0;\n+  unsigned short  c;\n+  unsigned int\t    :0;\n+  unsigned int\t  d :21;\n+} test_st_3;\n+\n+typedef struct\n+{\n+  unsigned char\t  a :3;\n+  unsigned int\t  b :13;\n+  test_un_2\t  un2;\n+} test_st_2;\n+\n+typedef union\n+{\n+  test_st_2 st2;\n+  test_st_3 st3;\n+}test_un_1;\n+\n+typedef struct\n+{\n+  unsigned char\t  a :2;\n+  unsigned char\t    :0;\n+  unsigned short  b :5;\n+  unsigned char\t    :0;\n+  unsigned char\t  c :4;\n+  test_un_1\t  un1;\n+} test_st_1;\n+\n+typedef union\n+{\n+  test_st_1 st1;\n+  struct\n+    {\n+      unsigned int v1;\n+      unsigned int v2;\n+      unsigned int v3;\n+      unsigned int v4;\n+    }values;\n+} read_st_1;\n+\n+\n+typedef void __attribute__ ((cmse_nonsecure_call)) (*foo_ns) (test_st_1);\n+\n+int\n+main (void)\n+{\n+  read_st_1 r;\n+  foo_ns f;\n+\n+  f = (foo_ns) 0x200000;\n+  r.values.v1 = 0xFFFFFFFF;\n+  r.values.v2 = 0xFFFFFFFF;\n+  r.values.v3 = 0xFFFFFFFF;\n+  r.values.v4 = 0xFFFFFFFF;\n+\n+  f (r.st1);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"mov\\tip, r4\" } } */\n+/* { dg-final { scan-assembler \"movw\\tr4, #7939\" } } */\n+/* { dg-final { scan-assembler \"movt\\tr4, 15\" } } */\n+/* { dg-final { scan-assembler \"ands\\tr0, r4\" } } */\n+/* { dg-final { scan-assembler \"movw\\tr4, #65535\" } } */\n+/* { dg-final { scan-assembler \"movt\\tr4, 2047\" } } */\n+/* { dg-final { scan-assembler \"ands\\tr1, r4\" } } */\n+/* { dg-final { scan-assembler \"movs\\tr4, #1\" } } */\n+/* { dg-final { scan-assembler \"movt\\tr4, 65535\" } } */\n+/* { dg-final { scan-assembler \"ands\\tr2, r4\" } } */\n+/* { dg-final { scan-assembler \"movw\\tr4, #65535\" } } */\n+/* { dg-final { scan-assembler \"movt\\tr4, 31\" } } */\n+/* { dg-final { scan-assembler \"ands\\tr3, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr4, ip\" } } */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}, {"sha": "3007409ad88b9d2312ece4d55f3695787a1aa566", "filename": "gcc/testsuite/gcc.target/arm/cmse/baseline/cmse-11.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fcmse-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fcmse-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fcmse-11.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_arch_v8m_base_ok } */\n+/* { dg-add-options arm_arch_v8m_base } */\n+/* { dg-options \"-mcmse\" }  */\n+\n+int __attribute__ ((cmse_nonsecure_call)) (*bar) (int);\n+\n+int\n+foo (int a)\n+{\n+  return bar (bar (a + 1));\n+}\n+\n+/* Checks for saving and clearing prior to function call.  */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"movs\\tr1, r4\" } } */\n+/* { dg-final { scan-assembler \"movs\\tr2, r4\" } } */\n+/* { dg-final { scan-assembler \"movs\\tr3, r4\" } } */\n+\n+/* Now we check that we use the correct intrinsic to call.  */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}, {"sha": "f2b931be5912b421f8427535ded3298883bec639", "filename": "gcc/testsuite/gcc.target/arm/cmse/baseline/cmse-13.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fcmse-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fcmse-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fcmse-13.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_arch_v8m_base_ok } */\n+/* { dg-add-options arm_arch_v8m_base } */\n+/* { dg-options \"-mcmse\" } */\n+\n+int __attribute__ ((cmse_nonsecure_call)) (*bar) (float, double);\n+\n+int\n+foo (int a)\n+{\n+  return bar (1.0f, 2.0) + a + 1;\n+}\n+\n+/* Checks for saving and clearing prior to function call.  */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler-not \"movs\\tr0, r4\" } } */\n+/* { dg-final { scan-assembler \"\\n\\tmovs\\tr1, r4\" } } */\n+/* { dg-final { scan-assembler-not \"\\n\\tmovs\\tr2, r4\\n\\tmovs\\tr3, r4\" } } */\n+/* { dg-final { scan-assembler-not \"vmov\" } } */\n+/* { dg-final { scan-assembler-not \"vmsr\" } } */\n+\n+/* Now we check that we use the correct intrinsic to call.  */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+"}, {"sha": "95da045690ae170a101949134482e821f27fe3aa", "filename": "gcc/testsuite/gcc.target/arm/cmse/baseline/cmse-6.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fcmse-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fcmse-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fcmse-6.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_arch_v8m_base_ok } */\n+/* { dg-add-options arm_arch_v8m_base } */\n+/* { dg-options \"-mcmse\" }  */\n+\n+int __attribute__ ((cmse_nonsecure_call)) (*bar) (double);\n+\n+int\n+foo (int a)\n+{\n+  return bar (2.0) + a + 1;\n+}\n+\n+/* Remember dont clear r0 and r1, because we are passing the double parameter\n+ * for bar in them.  */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"movs\\tr2, r4\" } } */\n+\n+/* Now we check that we use the correct intrinsic to call.  */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}, {"sha": "ff18e839b02c19c2c77769b18ef5ee1cfacf0c71", "filename": "gcc/testsuite/gcc.target/arm/cmse/baseline/union-1.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Funion-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Funion-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Funion-1.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,71 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcmse\" } */\n+\n+typedef struct\n+{\n+  unsigned char\t  a :2;\n+  unsigned char\t    :0;\n+  unsigned short  b :5;\n+  unsigned char\t    :0;\n+  unsigned short  c :3;\n+  unsigned char\t    :0;\n+  unsigned int\t  d :9;\n+} test_st_1;\n+\n+typedef struct\n+{\n+  unsigned short  a :7;\n+  unsigned char\t    :0;\n+  unsigned char\t  b :1;\n+  unsigned char\t    :0;\n+  unsigned short  c :6;\n+} test_st_2;\n+\n+typedef union\n+{\n+  test_st_1 st_1;\n+  test_st_2 st_2;\n+}test_un;\n+\n+typedef union\n+{\n+  test_un un;\n+  struct\n+    {\n+      unsigned int v1;\n+      unsigned int v2;\n+      unsigned int v3;\n+      unsigned int v4;\n+    }values;\n+} read_un;\n+\n+\n+typedef void __attribute__ ((cmse_nonsecure_call)) (*foo_ns) (test_un);\n+\n+int\n+main (void)\n+{\n+  read_un r;\n+  foo_ns f;\n+\n+  f = (foo_ns) 0x200000;\n+  r.values.v1 = 0xFFFFFFFF;\n+  r.values.v2 = 0xFFFFFFFF;\n+\n+  f (r.un);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"mov\\tip, r4\" } } */\n+/* { dg-final { scan-assembler \"movw\\tr4, #8063\" } } */\n+/* { dg-final { scan-assembler \"movt\\tr4, 63\" } } */\n+/* { dg-final { scan-assembler \"ands\\tr0, r4\" } } */\n+/* { dg-final { scan-assembler \"movw\\tr4, #511\" } } */\n+/* { dg-final { scan-assembler \"ands\\tr1, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr4, ip\" } } */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"movs\\tr2, r4\" } } */\n+/* { dg-final { scan-assembler \"movs\\tr3, r4\" } } */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+"}, {"sha": "b2e024b7f0776381f511077af91bd1ee5632ff12", "filename": "gcc/testsuite/gcc.target/arm/cmse/baseline/union-2.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Funion-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Funion-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Funion-2.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,86 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcmse\" } */\n+\n+typedef struct\n+{\n+  unsigned char\t  a :2;\n+  unsigned char\t    :0;\n+  unsigned short  b :5;\n+  unsigned char\t    :0;\n+  unsigned short  c :3;\n+  unsigned char\t    :0;\n+  unsigned int\t  d :9;\n+} test_st_1;\n+\n+typedef struct\n+{\n+  unsigned short  a :7;\n+  unsigned char\t    :0;\n+  unsigned char\t  b :1;\n+  unsigned char\t    :0;\n+  unsigned short  c :6;\n+} test_st_2;\n+\n+typedef struct\n+{\n+  unsigned char\t  a;\n+  unsigned int\t    :0;\n+  unsigned int\t  b :1;\n+  unsigned short    :0;\n+  unsigned short  c;\n+  unsigned int\t    :0;\n+  unsigned int\t  d :21;\n+} test_st_3;\n+\n+typedef union\n+{\n+  test_st_1 st_1;\n+  test_st_2 st_2;\n+  test_st_3 st_3;\n+}test_un;\n+\n+typedef union\n+{\n+  test_un un;\n+  struct\n+    {\n+      unsigned int v1;\n+      unsigned int v2;\n+      unsigned int v3;\n+      unsigned int v4;\n+    }values;\n+} read_un;\n+\n+\n+typedef void __attribute__ ((cmse_nonsecure_call)) (*foo_ns) (test_un);\n+\n+int\n+main (void)\n+{\n+  read_un r;\n+  foo_ns f;\n+\n+  f = (foo_ns) 0x200000;\n+  r.values.v1 = 0xFFFFFFFF;\n+  r.values.v2 = 0xFFFFFFFF;\n+  r.values.v3 = 0xFFFFFFFF;\n+\n+  f (r.un);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"mov\\tip, r4\" } } */\n+/* { dg-final { scan-assembler \"movw\\tr4, #8191\" } } */\n+/* { dg-final { scan-assembler \"movt\\tr4, 63\" } } */\n+/* { dg-final { scan-assembler \"ands\\tr0, r4\" } } */\n+/* { dg-final { scan-assembler \"movw\\tr4, #511\" } } */\n+/* { dg-final { scan-assembler \"movt\\tr4, 65535\" } } */\n+/* { dg-final { scan-assembler \"ands\\tr1, r4\" } } */\n+/* { dg-final { scan-assembler \"movw\\tr4, #65535\" } } */\n+/* { dg-final { scan-assembler \"movt\\tr4, 31\" } } */\n+/* { dg-final { scan-assembler \"ands\\tr2, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr4, ip\" } } */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"movs\\tr3, r4\" } } */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}, {"sha": "701e9ee7e318a07278099548f9b7042a1fde1204", "filename": "gcc/testsuite/gcc.target/arm/cmse/cmse-14.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fcmse-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fcmse-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fcmse-14.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcmse\" } */\n+\n+\n+int __attribute__ ((cmse_nonsecure_call)) (*bar) (void);\n+\n+int foo (void)\n+{\n+  return bar ();\n+}\n+\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+/* { dg-final { scan-assembler-not \"b\\[^ y\\n\\]*\\\\s+bar\" } } */"}, {"sha": "9e81e30c891bbc1f9d2d1d68d03bacad9ce65fe1", "filename": "gcc/testsuite/gcc.target/arm/cmse/cmse-9.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fcmse-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fcmse-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fcmse-9.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -2,11 +2,19 @@\n /* { dg-skip-if \"Testing exclusion of -mcmse\" { arm-*-* } { \"-mcmse\" } { \"\" } }  */\n \n \n+void __attribute__ ((cmse_nonsecure_call)) (*bar) (int); /* { dg-warning \"attribute ignored without -mcmse option\" } */\n+typedef void __attribute__ ((cmse_nonsecure_call)) baz (int); /* { dg-warning \"attribute ignored without -mcmse option\" } */\n+\n int __attribute__ ((cmse_nonsecure_entry))\n-foo (int a)\n+foo (int a, baz b)\n { /* { dg-warning \"attribute ignored without -mcmse option\" } */\n+  bar (a);\n+  b (a);\n   return a + 1;\n }\n \n+/* { dg-final { scan-assembler-not \"bxns\" } } */\n+/* { dg-final { scan-assembler-not \"blxns\" } } */\n+/* { dg-final { scan-assembler-not \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n /* { dg-final { scan-assembler \"foo:\" } } */\n /* { dg-final { scan-assembler-not \"__acle_se_foo:\" } } */"}, {"sha": "66a8b7da005f7dfeffbded61b02fd6a7473a1dcf", "filename": "gcc/testsuite/gcc.target/arm/cmse/cmse.exp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fcmse.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fcmse.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fcmse.exp?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -50,6 +50,8 @@ if {[check_effective_target_arm_arch_v8m_base_ok]} then {\n }\n \n if {[check_effective_target_arm_arch_v8m_main_ok]} then {\n+    gcc-dg-runtest [lsort [glob $srcdir/$subdir/mainline/*.c]] \\\n+\t    \"\" $DEFAULT_CFLAGS\n     # Mainline -mfloat-abi=soft\n     gcc-dg-runtest [lsort [glob $srcdir/$subdir/mainline/soft/*.c]] \\\n \t    \"-mfloat-abi=soft\" $DEFAULT_CFLAGS"}, {"sha": "c3b1396d52e742a1710ed5ad33fbeb559d866f6f", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/bitfield-4.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fbitfield-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fbitfield-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fbitfield-4.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,55 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcmse\" } */\n+\n+typedef struct\n+{\n+  unsigned char a;\n+  unsigned int b:5;\n+  unsigned int c:11, :0, d:8;\n+  struct { unsigned int ee:2; } e;\n+} test_st;\n+\n+typedef union\n+{\n+  test_st st;\n+  struct\n+    {\n+      unsigned int v1;\n+      unsigned int v2;\n+      unsigned int v3;\n+      unsigned int v4;\n+    }values;\n+} read_st;\n+\n+\n+typedef void __attribute__ ((cmse_nonsecure_call)) (*foo_ns) (test_st);\n+\n+extern void foo (test_st st);\n+\n+int\n+main (void)\n+{\n+  read_st r;\n+  foo_ns f;\n+\n+  f = (foo_ns) 0x200000;\n+  r.values.v1 = 0xFFFFFFFF;\n+  r.values.v2 = 0xFFFFFFFF;\n+  r.values.v3 = 0xFFFFFFFF;\n+  r.values.v4 = 0xFFFFFFFF;\n+\n+  f (r.st);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"movw\\tip, #65535\" } } */\n+/* { dg-final { scan-assembler \"movt\\tip, 255\" } } */\n+/* { dg-final { scan-assembler \"and\\tr0, r0, ip\" } } */\n+/* { dg-final { scan-assembler \"mov\\tip, #255\" } } */\n+/* { dg-final { scan-assembler \"and\\tr1, r1, ip\" } } */\n+/* { dg-final { scan-assembler \"mov\\tip, #3\" } } */\n+/* { dg-final { scan-assembler \"and\\tr2, r2, ip\" } } */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr3, r4\" } } */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}, {"sha": "0d029044aa9aa1d412c28ee5d18a8e3d0be36546", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/bitfield-5.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fbitfield-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fbitfield-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fbitfield-5.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcmse\" } */\n+\n+typedef struct\n+{\n+  unsigned char\t  a;\n+  unsigned short  b :5;\n+  unsigned char\t  c;\n+  unsigned short  d :11;\n+} test_st;\n+\n+typedef union\n+{\n+  test_st st;\n+  struct\n+    {\n+      unsigned int v1;\n+      unsigned int v2;\n+      unsigned int v3;\n+      unsigned int v4;\n+    }values;\n+} read_st;\n+\n+\n+typedef void __attribute__ ((cmse_nonsecure_call)) (*foo_ns) (test_st);\n+\n+int\n+main (void)\n+{\n+  read_st r;\n+  foo_ns f;\n+\n+  f = (foo_ns) 0x200000;\n+  r.values.v1 = 0xFFFFFFFF;\n+  r.values.v2 = 0xFFFFFFFF;\n+\n+  f (r.st);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"movw\\tip, #8191\" } } */\n+/* { dg-final { scan-assembler \"movt\\tip, 255\" } } */\n+/* { dg-final { scan-assembler \"and\\tr0, r0, ip\" } } */\n+/* { dg-final { scan-assembler \"movw\\tip, #2047\" } } */\n+/* { dg-final { scan-assembler \"and\\tr1, r1, ip\" } } */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr2, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr3, r4\" } } */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+"}, {"sha": "005515ab9cb85c201a2a8b2f6417d73ceeacbc60", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/bitfield-6.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fbitfield-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fbitfield-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fbitfield-6.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,61 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcmse\" } */\n+\n+typedef struct\n+{\n+  unsigned char a;\n+  unsigned int\tb : 3;\n+  unsigned int\tc : 14;\n+  unsigned int\td : 1;\n+  struct {\n+      unsigned int    ee  : 2;\n+      unsigned short  ff  : 15;\n+  } e;\n+  unsigned char\tg : 1;\n+  unsigned char\t  : 4;\n+  unsigned char\th : 3;\n+} test_st;\n+\n+typedef union\n+{\n+  test_st st;\n+  struct\n+    {\n+      unsigned int v1;\n+      unsigned int v2;\n+      unsigned int v3;\n+      unsigned int v4;\n+    }values;\n+} read_st;\n+\n+\n+typedef void __attribute__ ((cmse_nonsecure_call)) (*foo_ns) (test_st);\n+\n+int\n+main (void)\n+{\n+  read_st r;\n+  foo_ns f;\n+\n+  f = (foo_ns) 0x200000;\n+  r.values.v1 = 0xFFFFFFFF;\n+  r.values.v2 = 0xFFFFFFFF;\n+  r.values.v3 = 0xFFFFFFFF;\n+  r.values.v4 = 0xFFFFFFFF;\n+\n+  f (r.st);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"movw\\tip, #65535\" } } */\n+/* { dg-final { scan-assembler \"movt\\tip, 1023\" } } */\n+/* { dg-final { scan-assembler \"and\\tr0, r0, ip\" } } */\n+/* { dg-final { scan-assembler \"mov\\tip, #3\" } } */\n+/* { dg-final { scan-assembler \"movt\\tip, 32767\" } } */\n+/* { dg-final { scan-assembler \"and\\tr1, r1, ip\" } } */\n+/* { dg-final { scan-assembler \"mov\\tip, #255\" } } */\n+/* { dg-final { scan-assembler \"and\\tr2, r2, ip\" } } */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr3, r4\" } } */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}, {"sha": "6dd218e62fdee2a6af819079ba1ea1909185d076", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/bitfield-7.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fbitfield-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fbitfield-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fbitfield-7.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcmse\" } */\n+\n+typedef struct\n+{\n+  unsigned char\t  a;\n+  unsigned short  b :5;\n+  unsigned char\t  c;\n+  unsigned short  d :11;\n+} test_st;\n+\n+typedef union\n+{\n+  test_st st;\n+  struct\n+    {\n+      unsigned int v1;\n+      unsigned int v2;\n+      unsigned int v3;\n+      unsigned int v4;\n+    }values;\n+} read_st;\n+\n+\n+typedef void __attribute__ ((cmse_nonsecure_call)) (*foo_ns) (test_st);\n+\n+int\n+main (void)\n+{\n+  read_st r;\n+  foo_ns f;\n+\n+  f = (foo_ns) 0x200000;\n+  r.values.v1 = 0xFFFFFFFF;\n+  r.values.v2 = 0xFFFFFFFF;\n+\n+  f (r.st);\n+  return 0;\n+}\n+\n+\n+/* { dg-final { scan-assembler \"movw\\tip, #8191\" } } */\n+/* { dg-final { scan-assembler \"movt\\tip, 255\" } } */\n+/* { dg-final { scan-assembler \"and\\tr0, r0, ip\" } } */\n+/* { dg-final { scan-assembler \"movw\\tip, #2047\" } } */\n+/* { dg-final { scan-assembler \"and\\tr1, r1, ip\" } } */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr2, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr3, r4\" } } */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+"}, {"sha": "c833bcb0ae978572fad46780bc180f61ccb14345", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/bitfield-8.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fbitfield-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fbitfield-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fbitfield-8.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,55 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcmse\" } */\n+\n+typedef struct\n+{\n+  unsigned char\t  a;\n+  unsigned int\t    :0;\n+  unsigned int\t  b :1;\n+  unsigned short    :0;\n+  unsigned short  c;\n+  unsigned int\t    :0;\n+  unsigned int\t  d :21;\n+} test_st;\n+\n+typedef union\n+{\n+  test_st st;\n+  struct\n+    {\n+      unsigned int v1;\n+      unsigned int v2;\n+      unsigned int v3;\n+      unsigned int v4;\n+    }values;\n+} read_st;\n+\n+typedef void __attribute__ ((cmse_nonsecure_call)) (*foo_ns) (test_st);\n+\n+int\n+main (void)\n+{\n+  read_st r;\n+  foo_ns f;\n+\n+  f = (foo_ns) 0x200000;\n+  r.values.v1 = 0xFFFFFFFF;\n+  r.values.v2 = 0xFFFFFFFF;\n+  r.values.v3 = 0xFFFFFFFF;\n+\n+  f (r.st);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"mov\\tip, #255\" } } */\n+/* { dg-final { scan-assembler \"and\\tr0, r0, ip\" } } */\n+/* { dg-final { scan-assembler \"mov\\tip, #1\" } } */\n+/* { dg-final { scan-assembler \"movt\\tip, 65535\" } } */\n+/* { dg-final { scan-assembler \"and\\tr1, r1, ip\" } } */\n+/* { dg-final { scan-assembler \"movw\\tip, #65535\" } } */\n+/* { dg-final { scan-assembler \"movt\\tip, 31\" } } */\n+/* { dg-final { scan-assembler \"and\\tr2, r2, ip\" } } */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr3, r4\" } } */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}, {"sha": "d6e4cdb8c44b19c811f3a7b4fbce102a6c768f2b", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/bitfield-9.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fbitfield-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fbitfield-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fbitfield-9.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcmse\" } */\n+\n+typedef struct\n+{\n+  char a:3;\n+} test_st3;\n+\n+typedef struct\n+{\n+  char a:3;\n+} test_st2;\n+\n+typedef struct\n+{\n+  test_st2 st2;\n+  test_st3 st3;\n+} test_st;\n+\n+typedef union\n+{\n+  test_st st;\n+  struct\n+    {\n+      unsigned int v1;\n+      unsigned int v2;\n+      unsigned int v3;\n+      unsigned int v4;\n+    }values;\n+} read_st;\n+\n+typedef void __attribute__ ((cmse_nonsecure_call)) (*foo_ns) (test_st);\n+\n+int\n+main (void)\n+{\n+  read_st r;\n+  foo_ns f;\n+\n+  f = (foo_ns) 0x200000;\n+  r.values.v1 = 0xFFFFFFFF;\n+\n+  f (r.st);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"movw\\tip, #1799\" } } */\n+/* { dg-final { scan-assembler \"and\\tr0, r0, ip\" } } */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr1, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr2, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr3, r4\" } } */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}, {"sha": "e139ba61af57f06cff5a9d121c97bbf41e170bb9", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/bitfield-and-union-1.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fbitfield-and-union-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fbitfield-and-union-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fbitfield-and-union-1.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,94 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcmse\" } */\n+\n+typedef struct\n+{\n+  unsigned short a :11;\n+} test_st_4;\n+\n+typedef union\n+{\n+  char\t      a;\n+  test_st_4 st4;\n+}test_un_2;\n+\n+typedef struct\n+{\n+  unsigned char\t  a;\n+  unsigned int\t    :0;\n+  unsigned int\t  b :1;\n+  unsigned short    :0;\n+  unsigned short  c;\n+  unsigned int\t    :0;\n+  unsigned int\t  d :21;\n+} test_st_3;\n+\n+typedef struct\n+{\n+  unsigned char\t  a :3;\n+  unsigned int\t  b :13;\n+  test_un_2\t  un2;\n+} test_st_2;\n+\n+typedef union\n+{\n+  test_st_2 st2;\n+  test_st_3 st3;\n+}test_un_1;\n+\n+typedef struct\n+{\n+  unsigned char\t  a :2;\n+  unsigned char\t    :0;\n+  unsigned short  b :5;\n+  unsigned char\t    :0;\n+  unsigned char\t  c :4;\n+  test_un_1\t  un1;\n+} test_st_1;\n+\n+typedef union\n+{\n+  test_st_1 st1;\n+  struct\n+    {\n+      unsigned int v1;\n+      unsigned int v2;\n+      unsigned int v3;\n+      unsigned int v4;\n+    }values;\n+} read_st_1;\n+\n+\n+typedef void __attribute__ ((cmse_nonsecure_call)) (*foo_ns) (test_st_1);\n+\n+int\n+main (void)\n+{\n+  read_st_1 r;\n+  foo_ns f;\n+\n+  f = (foo_ns) 0x200000;\n+  r.values.v1 = 0xFFFFFFFF;\n+  r.values.v2 = 0xFFFFFFFF;\n+  r.values.v3 = 0xFFFFFFFF;\n+  r.values.v4 = 0xFFFFFFFF;\n+\n+  f (r.st1);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"movw\\tip, #7939\" } } */\n+/* { dg-final { scan-assembler \"movt\\tip, 15\" } } */\n+/* { dg-final { scan-assembler \"and\\tr0, r0, ip\" } } */\n+/* { dg-final { scan-assembler \"movw\\tip, #65535\" } } */\n+/* { dg-final { scan-assembler \"movt\\tip, 2047\" } } */\n+/* { dg-final { scan-assembler \"and\\tr1, r1, ip\" } } */\n+/* { dg-final { scan-assembler \"mov\\tip, #1\" } } */\n+/* { dg-final { scan-assembler \"movt\\tip, 65535\" } } */\n+/* { dg-final { scan-assembler \"and\\tr2, r2, ip\" } } */\n+/* { dg-final { scan-assembler \"movw\\tip, #65535\" } } */\n+/* { dg-final { scan-assembler \"movt\\tip, 31\" } } */\n+/* { dg-final { scan-assembler \"and\\tr3, r3, ip\" } } */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}, {"sha": "d90ad811fc13c9b5cde1c9bf394e490255429ff2", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/hard-sp/cmse-13.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard-sp%2Fcmse-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard-sp%2Fcmse-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard-sp%2Fcmse-13.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_arch_v8m_main_ok } */\n+/* { dg-add-options arm_arch_v8m_main } */\n+/* { dg-skip-if \"Do not combine float-abi= hard | soft | softfp\" {*-*-*} {\"-mfloat-abi=soft\" -mfloat-abi=softfp } {\"\"} } */\n+/* { dg-skip-if \"Skip these if testing double precision\" {*-*-*} {\"-mfpu=fpv[4-5]-d16\"} {\"\"} } */\n+/* { dg-options \"-mcmse -mfloat-abi=hard -mfpu=fpv5-sp-d16\" }  */\n+\n+\n+int __attribute__ ((cmse_nonsecure_call)) (*bar) (float, double);\n+\n+int\n+foo (int a)\n+{\n+  return bar (3.0f, 2.0) + a + 1;\n+}\n+\n+/* Checks for saving and clearing prior to function call.  */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr0, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr1, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr2, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr3, r4\" } } */\n+/* { dg-final { scan-assembler-not \"vldr\\.32\\ts0, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts1, .L\" } } */\n+/* { dg-final { scan-assembler-not \"vldr\\.32\\ts2, .L\" } } */\n+/* { dg-final { scan-assembler-not \"vldr\\.32\\ts3, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts4, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts5, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts6, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts7, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts8, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts9, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts10, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts11, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts12, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts13, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts14, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts15, .L\" } } */\n+\n+/* Now we check that we use the correct intrinsic to call.  */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+"}, {"sha": "c047cd51c9480fc30e411bf7814769d32ccfe79e", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/hard-sp/cmse-7.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard-sp%2Fcmse-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard-sp%2Fcmse-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard-sp%2Fcmse-7.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_arch_v8m_main_ok } */\n+/* { dg-add-options arm_arch_v8m_main } */\n+/* { dg-skip-if \"Do not combine float-abi= hard | soft | softfp\" {*-*-*} {\"-mfloat-abi=soft\" -mfloat-abi=softfp } {\"\"} } */\n+/* { dg-skip-if \"Skip these if testing double precision\" {*-*-*} {\"-mfpu=fpv[4-5]-d16\"} {\"\"} } */\n+/* { dg-options \"-mcmse -mfloat-abi=hard -mfpu=fpv5-sp-d16\" }  */\n+\n+int __attribute__ ((cmse_nonsecure_call)) (*bar) (void);\n+\n+int\n+foo (int a)\n+{\n+  return bar () + a + 1;\n+}\n+\n+/* Checks for saving and clearing prior to function call.  */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr0, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr1, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr2, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr3, r4\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts0, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts1, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts2, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts3, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts4, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts5, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts6, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts7, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts8, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts9, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts10, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts11, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts12, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts13, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts14, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts15, .L\" } } */\n+\n+/* Now we check that we use the correct intrinsic to call.  */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+"}, {"sha": "20d2d4a8fb13f89103a5d97b9b533caa37520b76", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/hard-sp/cmse-8.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard-sp%2Fcmse-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard-sp%2Fcmse-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard-sp%2Fcmse-8.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_arch_v8m_main_ok } */\n+/* { dg-add-options arm_arch_v8m_main } */\n+/* { dg-skip-if \"Do not combine float-abi= hard | soft | softfp\" {*-*-*} {\"-mfloat-abi=soft\" -mfloat-abi=softfp } {\"\"} } */\n+/* { dg-skip-if \"Skip these if testing double precision\" {*-*-*} {\"-mfpu=fpv[4-5]-d16\"} {\"\"} } */\n+/* { dg-options \"-mcmse -mfloat-abi=hard -mfpu=fpv5-sp-d16\" }  */\n+\n+int __attribute__ ((cmse_nonsecure_call)) (*bar) (double);\n+\n+int\n+foo (int a)\n+{\n+  return bar (2.0) + a + 1;\n+}\n+\n+/* Checks for saving and clearing prior to function call.  */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr0, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr1, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr2, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr3, r4\" } } */\n+/* { dg-final { scan-assembler-not \"vldr\\.32\\ts0, .L\" } } */\n+/* { dg-final { scan-assembler-not \"vldr\\.32\\ts1, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts2, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts3, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts4, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts5, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts6, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts7, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts8, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts9, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts10, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts11, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts12, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts13, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts14, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts15, .L\" } } */\n+\n+/* Now we check that we use the correct intrinsic to call.  */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}, {"sha": "0af586a7fd18de879301c5bba9eccbe1ab0c4e33", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/hard/cmse-13.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard%2Fcmse-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard%2Fcmse-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard%2Fcmse-13.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_arch_v8m_main_ok } */\n+/* { dg-add-options arm_arch_v8m_main } */\n+/* { dg-skip-if \"Do not combine float-abi= hard | soft | softfp\" {*-*-*} {\"-mfloat-abi=soft\" -mfloat-abi=softfp } {\"\"} } */\n+/* { dg-skip-if \"Skip these if testing single precision\" {*-*-*} {\"-mfpu=*-sp-*\"} {\"\"} } */\n+/* { dg-options \"-mcmse -mfloat-abi=hard -mfpu=fpv5-d16\" }  */\n+\n+\n+int __attribute__ ((cmse_nonsecure_call)) (*bar) (float, double);\n+\n+int\n+foo (int a)\n+{\n+  return bar (3.0f, 2.0) + a + 1;\n+}\n+\n+/* Checks for saving and clearing prior to function call.  */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr0, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr1, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr2, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr3, r4\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.32\\ts1, .L\" } } */\n+/* { dg-final { scan-assembler-not \"vldr\\.64\\td0, .L\" } } */\n+/* { dg-final { scan-assembler-not \"vldr\\.32\\ts0, .L\" } } */\n+/* { dg-final { scan-assembler-not \"vldr\\.64\\td1, .L\" } } */\n+/* { dg-final { scan-assembler-not \"vldr\\.32\\ts2, .L\" } } */\n+/* { dg-final { scan-assembler-not \"vldr\\.32\\ts3, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.64\\td2, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.64\\td3, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.64\\td4, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.64\\td5, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.64\\td6, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.64\\td7, .L\" } } */\n+\n+/* Now we check that we use the correct intrinsic to call.  */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}, {"sha": "a5c64fb06edd6927e0eb3b1f4e6d314274668a7a", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/hard/cmse-7.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard%2Fcmse-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard%2Fcmse-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard%2Fcmse-7.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_arch_v8m_main_ok } */\n+/* { dg-add-options arm_arch_v8m_main } */\n+/* { dg-skip-if \"Do not combine float-abi= hard | soft | softfp\" {*-*-*} {\"-mfloat-abi=soft\" -mfloat-abi=softfp } {\"\"} } */\n+/* { dg-skip-if \"Skip these if testing single precision\" {*-*-*} {\"-mfpu=*-sp-*\"} {\"\"} } */\n+/* { dg-options \"-mcmse -mfloat-abi=hard -mfpu=fpv5-d16\" }  */\n+\n+int __attribute__ ((cmse_nonsecure_call)) (*bar) (void);\n+\n+int\n+foo (int a)\n+{\n+  return bar () + a + 1;\n+}\n+\n+/* Checks for saving and clearing prior to function call.  */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr0, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr1, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr2, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr3, r4\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.64\\td0, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.64\\td1, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.64\\td2, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.64\\td3, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.64\\td4, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.64\\td5, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.64\\td6, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.64\\td7, .L\" } } */\n+\n+/* Now we check that we use the correct intrinsic to call.  */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+"}, {"sha": "5e041b17b0e4bad779b147c204cf8178c8798b80", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/hard/cmse-8.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard%2Fcmse-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard%2Fcmse-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard%2Fcmse-8.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_arch_v8m_main_ok } */\n+/* { dg-add-options arm_arch_v8m_main } */\n+/* { dg-skip-if \"Do not combine float-abi= hard | soft | softfp\" {*-*-*} {\"-mfloat-abi=soft\" -mfloat-abi=softfp } {\"\"} } */\n+/* { dg-skip-if \"Skip these if testing single precision\" {*-*-*} {\"-mfpu=*-sp-*\"} {\"\"} } */\n+/* { dg-options \"-mcmse -mfloat-abi=hard -mfpu=fpv5-d16\" }  */\n+\n+int __attribute__ ((cmse_nonsecure_call)) (*bar) (double);\n+\n+int\n+foo (int a)\n+{\n+  return bar (2.0) + a + 1;\n+}\n+\n+/* Checks for saving and clearing prior to function call.  */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr0, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr1, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr2, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr3, r4\" } } */\n+/* { dg-final { scan-assembler-not \"vldr\\.64\\td0, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.64\\td1, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.64\\td2, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.64\\td3, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.64\\td4, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.64\\td5, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.64\\td6, .L\" } } */\n+/* { dg-final { scan-assembler \"vldr\\.64\\td7, .L\" } } */\n+\n+/* Now we check that we use the correct intrinsic to call.  */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}, {"sha": "dbbd262c89085eb0dc8737ad7955c3a12531492b", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/soft/cmse-13.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoft%2Fcmse-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoft%2Fcmse-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoft%2Fcmse-13.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_arch_v8m_main_ok } */\n+/* { dg-add-options arm_arch_v8m_main } */\n+/* { dg-skip-if \"Do not combine float-abi= hard | soft | softfp\" {*-*-*} {\"-mfloat-abi=hard\" -mfloat-abi=softfp } {\"\"} } */\n+/* { dg-options \"-mcmse -mfloat-abi=soft\" }  */\n+\n+int __attribute__ ((cmse_nonsecure_call)) (*bar) (float, double);\n+\n+int\n+foo (int a)\n+{\n+  return bar (1.0f, 2.0) + a + 1;\n+}\n+\n+/* Checks for saving and clearing prior to function call.  */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler-not \"mov\\tr0, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr1, r4\" } } */\n+/* { dg-final { scan-assembler-not \"mov\\tr2, r4\" } } */\n+/* { dg-final { scan-assembler-not \"mov\\tr3, r4\" } } */\n+/* { dg-final { scan-assembler-not \"vmov\" } } */\n+/* { dg-final { scan-assembler-not \"vmsr\" } } */\n+\n+/* Now we check that we use the correct intrinsic to call.  */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+"}, {"sha": "e33568400ef830abaa019b5c2727a9f3b5d5704b", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/soft/cmse-7.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoft%2Fcmse-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoft%2Fcmse-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoft%2Fcmse-7.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_arch_v8m_main_ok } */\n+/* { dg-add-options arm_arch_v8m_main } */\n+/* { dg-skip-if \"Do not combine float-abi= hard | soft | softfp\" {*-*-*} {\"-mfloat-abi=hard\" -mfloat-abi=softfp } {\"\"} } */\n+/* { dg-options \"-mcmse -mfloat-abi=soft\" }  */\n+\n+int __attribute__ ((cmse_nonsecure_call)) (*bar) (void);\n+\n+int\n+foo (int a)\n+{\n+  return bar () + a + 1;\n+}\n+\n+/* Checks for saving and clearing prior to function call.  */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr0, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr1, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr2, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr3, r4\" } } */\n+/* { dg-final { scan-assembler-not \"vmov\" } } */\n+/* { dg-final { scan-assembler-not \"vmsr\" } } */\n+\n+/* Now we check that we use the correct intrinsic to call.  */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+"}, {"sha": "024a12e0a414730eb1cbebfca8574d548238ab28", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/soft/cmse-8.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoft%2Fcmse-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoft%2Fcmse-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoft%2Fcmse-8.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_arch_v8m_main_ok } */\n+/* { dg-add-options arm_arch_v8m_main } */\n+/* { dg-skip-if \"Do not combine float-abi= hard | soft | softfp\" {*-*-*} {\"-mfloat-abi=hard\" -mfloat-abi=softfp } {\"\"} } */\n+/* { dg-options \"-mcmse -mfloat-abi=soft\" }  */\n+\n+int __attribute__ ((cmse_nonsecure_call)) (*bar) (double);\n+\n+int\n+foo (int a)\n+{\n+  return bar (2.0) + a + 1;\n+}\n+\n+/* Checks for saving and clearing prior to function call.  */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler-not \"mov\\tr0, r4\" } } */\n+/* { dg-final { scan-assembler-not \"mov\\tr1, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr2, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr3, r4\" } } */\n+/* { dg-final { scan-assembler-not \"vmov\" } } */\n+/* { dg-final { scan-assembler-not \"vmsr\" } } */\n+\n+/* Now we check that we use the correct intrinsic to call.  */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}, {"sha": "fb195eb58d59fe9ea5ed74af79646199c61bcdae", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/softfp-sp/cmse-7.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoftfp-sp%2Fcmse-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoftfp-sp%2Fcmse-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoftfp-sp%2Fcmse-7.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_arch_v8m_main_ok } */\n+/* { dg-add-options arm_arch_v8m_main } */\n+/* { dg-skip-if \"Do not combine float-abi= hard | soft | softfp\" {*-*-*} {\"-mfloat-abi=soft\" -mfloat-abi=hard } {\"\"} } */\n+/* { dg-skip-if \"Skip these if testing double precision\" {*-*-*} {\"-mfpu=fpv[4-5]-d16\"} {\"\"} } */\n+/* { dg-options \"-mcmse -mfloat-abi=softfp -mfpu=fpv5-sp-d16\" }  */\n+\n+int __attribute__ ((cmse_nonsecure_call)) (*bar) (void);\n+\n+int\n+foo (int a)\n+{\n+  return bar () + a + 1;\n+}\n+\n+/* Checks for saving and clearing prior to function call.  */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr0, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr1, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr2, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr3, r4\" } } */\n+\n+/* Now we check that we use the correct intrinsic to call.  */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+"}, {"sha": "22ed3f8af882f96da49919c60fc6f4cd74dfc54b", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/softfp-sp/cmse-8.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoftfp-sp%2Fcmse-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoftfp-sp%2Fcmse-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoftfp-sp%2Fcmse-8.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_arch_v8m_main_ok } */\n+/* { dg-add-options arm_arch_v8m_main } */\n+/* { dg-skip-if \"Do not combine float-abi= hard | soft | softfp\" {*-*-*} {\"-mfloat-abi=soft\" -mfloat-abi=hard } {\"\"} } */\n+/* { dg-skip-if \"Skip these if testing double precision\" {*-*-*} {\"-mfpu=fpv[4-5]-d16\"} {\"\"} } */\n+/* { dg-options \"-mcmse -mfloat-abi=softfp -mfpu=fpv5-sp-d16\" }  */\n+\n+int __attribute__ ((cmse_nonsecure_call)) (*bar) (double);\n+\n+int\n+foo (int a)\n+{\n+  return bar (2.0) + a + 1;\n+}\n+\n+/* Checks for saving and clearing prior to function call.  */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler-not \"mov\\tr0, r4\" } } */\n+/* { dg-final { scan-assembler-not \"mov\\tr1, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr2, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr3, r4\" } } */\n+\n+/* Now we check that we use the correct intrinsic to call.  */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}, {"sha": "9634065e7cb64a5069cbb3c9be4b8cf9177f5e29", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/softfp/cmse-13.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoftfp%2Fcmse-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoftfp%2Fcmse-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoftfp%2Fcmse-13.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_arch_v8m_main_ok } */\n+/* { dg-add-options arm_arch_v8m_main } */\n+/* { dg-skip-if \"Do not combine float-abi= hard | soft | softfp\" {*-*-*} {\"-mfloat-abi=soft\" -mfloat-abi=hard } {\"\"} } */\n+/* { dg-skip-if \"Skip these if testing single precision\" {*-*-*} {\"-mfpu=*-sp-*\"} {\"\"} } */\n+/* { dg-options \"-mcmse -mfloat-abi=softfp -mfpu=fpv5-d16\" }  */\n+\n+int __attribute__ ((cmse_nonsecure_call)) (*bar) (float, double);\n+\n+int\n+foo (int a)\n+{\n+  return bar (1.0f, 2.0) + a + 1;\n+}\n+\n+/* Checks for saving and clearing prior to function call.  */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler-not \"mov\\tr0, r4\" } } */\n+/* { dg-final { scan-assembler \"\\n\\tmov\\tr1, r4\" } } */\n+/* { dg-final { scan-assembler-not \"\\n\\tmov\\tr2, r4\\n\\tmov\\tr3, r4\" } } */\n+\n+/* Now we check that we use the correct intrinsic to call.  */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+"}, {"sha": "04f8466cc112c03ee5a05e6e5223d2c66a033bbe", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/softfp/cmse-7.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoftfp%2Fcmse-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoftfp%2Fcmse-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoftfp%2Fcmse-7.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_arch_v8m_main_ok } */\n+/* { dg-add-options arm_arch_v8m_main } */\n+/* { dg-skip-if \"Do not combine float-abi= hard | soft | softfp\" {*-*-*} {\"-mfloat-abi=soft\" -mfloat-abi=hard } {\"\"} } */\n+/* { dg-skip-if \"Skip these if testing single precision\" {*-*-*} {\"-mfpu=*-sp-*\"} {\"\"} } */\n+/* { dg-options \"-mcmse -mfloat-abi=softfp -mfpu=fpv5-d16\" }  */\n+\n+int __attribute__ ((cmse_nonsecure_call)) (*bar) (void);\n+\n+int\n+foo (int a)\n+{\n+  return bar () + a + 1;\n+}\n+\n+/* Checks for saving and clearing prior to function call.  */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr0, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr1, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr2, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr3, r4\" } } */\n+\n+/* Now we check that we use the correct intrinsic to call.  */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+"}, {"sha": "ffe94de85417b81f9dcb366eb1b40dc1661c91b7", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/softfp/cmse-8.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoftfp%2Fcmse-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoftfp%2Fcmse-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoftfp%2Fcmse-8.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_arch_v8m_main_ok } */\n+/* { dg-add-options arm_arch_v8m_main } */\n+/* { dg-skip-if \"Do not combine float-abi= hard | soft | softfp\" {*-*-*} {\"-mfloat-abi=soft\" -mfloat-abi=hard } {\"\"} } */\n+/* { dg-skip-if \"Skip these if testing single precision\" {*-*-*} {\"-mfpu=*-sp-*\"} {\"\"} } */\n+/* { dg-options \"-mcmse -mfloat-abi=softfp -mfpu=fpv5-d16\" }  */\n+\n+int __attribute__ ((cmse_nonsecure_call)) (*bar) (double);\n+\n+int\n+foo (int a)\n+{\n+  return bar (2.0) + a + 1;\n+}\n+\n+/* Checks for saving and clearing prior to function call.  */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler-not \"mov\\tr0, r4\" } } */\n+/* { dg-final { scan-assembler-not \"mov\\tr1, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr2, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr3, r4\" } } */\n+\n+/* Now we check that we use the correct intrinsic to call.  */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}, {"sha": "1fc846cd7a51303ec00f8f512a54cd697fbd0682", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/union-1.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Funion-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Funion-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Funion-1.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,69 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcmse\" } */\n+\n+typedef struct\n+{\n+  unsigned char\t  a :2;\n+  unsigned char\t    :0;\n+  unsigned short  b :5;\n+  unsigned char\t    :0;\n+  unsigned short  c :3;\n+  unsigned char\t    :0;\n+  unsigned int\t  d :9;\n+} test_st_1;\n+\n+typedef struct\n+{\n+  unsigned short  a :7;\n+  unsigned char\t    :0;\n+  unsigned char\t  b :1;\n+  unsigned char\t    :0;\n+  unsigned short  c :6;\n+} test_st_2;\n+\n+typedef union\n+{\n+  test_st_1 st_1;\n+  test_st_2 st_2;\n+}test_un;\n+\n+typedef union\n+{\n+  test_un un;\n+  struct\n+    {\n+      unsigned int v1;\n+      unsigned int v2;\n+      unsigned int v3;\n+      unsigned int v4;\n+    }values;\n+} read_un;\n+\n+\n+typedef void __attribute__ ((cmse_nonsecure_call)) (*foo_ns) (test_un);\n+\n+int\n+main (void)\n+{\n+  read_un r;\n+  foo_ns f;\n+\n+  f = (foo_ns) 0x200000;\n+  r.values.v1 = 0xFFFFFFFF;\n+  r.values.v2 = 0xFFFFFFFF;\n+\n+  f (r.un);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"movw\\tip, #8063\" } } */\n+/* { dg-final { scan-assembler \"movt\\tip, 63\" } } */\n+/* { dg-final { scan-assembler \"and\\tr0, r0, ip\" } } */\n+/* { dg-final { scan-assembler \"movw\\tip, #511\" } } */\n+/* { dg-final { scan-assembler \"and\\tr1, r1, ip\" } } */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr2, r4\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr3, r4\" } } */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+"}, {"sha": "420d0f136ef171111c1cca6cd24c4f46b9fcb7fc", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/union-2.c", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Funion-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Funion-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Funion-2.c?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,84 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcmse\" } */\n+\n+typedef struct\n+{\n+  unsigned char\t  a :2;\n+  unsigned char\t    :0;\n+  unsigned short  b :5;\n+  unsigned char\t    :0;\n+  unsigned short  c :3;\n+  unsigned char\t    :0;\n+  unsigned int\t  d :9;\n+} test_st_1;\n+\n+typedef struct\n+{\n+  unsigned short  a :7;\n+  unsigned char\t    :0;\n+  unsigned char\t  b :1;\n+  unsigned char\t    :0;\n+  unsigned short  c :6;\n+} test_st_2;\n+\n+typedef struct\n+{\n+  unsigned char\t  a;\n+  unsigned int\t    :0;\n+  unsigned int\t  b :1;\n+  unsigned short    :0;\n+  unsigned short  c;\n+  unsigned int\t    :0;\n+  unsigned int\t  d :21;\n+} test_st_3;\n+\n+typedef union\n+{\n+  test_st_1 st_1;\n+  test_st_2 st_2;\n+  test_st_3 st_3;\n+}test_un;\n+\n+typedef union\n+{\n+  test_un un;\n+  struct\n+    {\n+      unsigned int v1;\n+      unsigned int v2;\n+      unsigned int v3;\n+      unsigned int v4;\n+    }values;\n+} read_un;\n+\n+\n+typedef void __attribute__ ((cmse_nonsecure_call)) (*foo_ns) (test_un);\n+\n+int\n+main (void)\n+{\n+  read_un r;\n+  foo_ns f;\n+\n+  f = (foo_ns) 0x200000;\n+  r.values.v1 = 0xFFFFFFFF;\n+  r.values.v2 = 0xFFFFFFFF;\n+  r.values.v3 = 0xFFFFFFFF;\n+\n+  f (r.un);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"movw\\tip, #8191\" } } */\n+/* { dg-final { scan-assembler \"movt\\tip, 63\" } } */\n+/* { dg-final { scan-assembler \"and\\tr0, r0, ip\" } } */\n+/* { dg-final { scan-assembler \"movw\\tip, #511\" } } */\n+/* { dg-final { scan-assembler \"movt\\tip, 65535\" } } */\n+/* { dg-final { scan-assembler \"and\\tr1, r1, ip\" } } */\n+/* { dg-final { scan-assembler \"movw\\tip, #65535\" } } */\n+/* { dg-final { scan-assembler \"movt\\tip, 31\" } } */\n+/* { dg-final { scan-assembler \"and\\tr2, r2, ip\" } } */\n+/* { dg-final { scan-assembler \"lsrs\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\tr4, r4, #1\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr3, r4\" } } */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}, {"sha": "6627d266e23809a4edebced3e9c571cf051e670f", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -1,3 +1,9 @@\n+2016-12-02  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n+\t    Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\t* config/arm/cmse_nonsecure_call.S: New.\n+\t* config/arm/t-arm: Compile cmse_nonsecure_call.S\n+\n 2016-12-02  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n \t    Thomas Preud'homme  <thomas.preudhomme@arm.com>\n "}, {"sha": "68b6a1cb5005d9ebb284a062443bc310d7e7db53", "filename": "libgcc/config/arm/cmse_nonsecure_call.S", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/libgcc%2Fconfig%2Farm%2Fcmse_nonsecure_call.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/libgcc%2Fconfig%2Farm%2Fcmse_nonsecure_call.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Farm%2Fcmse_nonsecure_call.S?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -0,0 +1,131 @@\n+/* CMSE wrapper function used to save, clear and restore callee saved registers\n+   for cmse_nonsecure_call's.\n+\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by ARM Ltd.\n+\n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 3, or (at your option) any\n+   later version.\n+\n+   This file is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+.syntax unified\n+.thumb\n+.global __gnu_cmse_nonsecure_call\n+__gnu_cmse_nonsecure_call:\n+#if defined(__ARM_ARCH_8M_MAIN__)\n+push\t    {r5-r11,lr}\n+mov\t    r7, r4\n+mov\t    r8, r4\n+mov\t    r9, r4\n+mov\t    r10, r4\n+mov\t    r11, r4\n+mov\t    ip, r4\n+\n+/* Save and clear callee-saved registers only if we are dealing with hard float\n+   ABI.  The unused caller-saved registers have already been cleared by GCC\n+   generated code.  */\n+#ifdef __ARM_PCS_VFP\n+vpush.f64   {d8-d15}\n+mov\t    r5, #0\n+vmov\t    d8, r5, r5\n+#if __ARM_FP & 0x04\n+vmov\t    s18, s19, r5, r5\n+vmov\t    s20, s21, r5, r5\n+vmov\t    s22, s23, r5, r5\n+vmov\t    s24, s25, r5, r5\n+vmov\t    s26, s27, r5, r5\n+vmov\t    s28, s29, r5, r5\n+vmov\t    s30, s31, r5, r5\n+#elif __ARM_FP & 0x08\n+vmov.f64    d9, d8\n+vmov.f64    d10, d8\n+vmov.f64    d11, d8\n+vmov.f64    d12, d8\n+vmov.f64    d13, d8\n+vmov.f64    d14, d8\n+vmov.f64    d15, d8\n+#else\n+#error \"Half precision implementation not supported.\"\n+#endif\n+/* Clear the cumulative exception-status bits (0-4,7) and the\n+   condition code bits (28-31) of the FPSCR.  */\n+vmrs\t    r5, fpscr\n+movw\t    r6, #65376\n+movt\t    r6, #4095\n+ands\t    r5, r6\n+vmsr\t    fpscr, r5\n+\n+/* We are not dealing with hard float ABI, so we can safely use the vlstm and\n+   vlldm instructions without needing to preserve the registers used for\n+   argument passing.  */\n+#else\n+sub\t    sp, sp, #0x88 /* Reserve stack space to save all floating point\n+\t\t\t     registers, including FPSCR.  */\n+vlstm\t    sp\t\t  /* Lazy store and clearance of d0-d16 and FPSCR.  */\n+#endif /* __ARM_PCS_VFP */\n+\n+/* Make sure to clear the 'GE' bits of the APSR register if 32-bit SIMD\n+   instructions are available.  */\n+#if defined(__ARM_FEATURE_SIMD32)\n+msr\t    APSR_nzcvqg, r4\n+#else\n+msr\t    APSR_nzcvq, r4\n+#endif\n+\n+mov\t    r5, r4\n+mov\t    r6, r4\n+blxns\t    r4\n+\n+#ifdef __ARM_PCS_VFP\n+vpop.f64    {d8-d15}\n+#else\n+vlldm\t    sp\t\t  /* Lazy restore of d0-d16 and FPSCR.  */\n+add\t    sp, sp, #0x88 /* Free space used to save floating point registers.  */\n+#endif /* __ARM_PCS_VFP */\n+\n+pop\t    {r5-r11, pc}\n+\n+#elif defined (__ARM_ARCH_8M_BASE__)\n+push\t    {r5-r7, lr}\n+mov\t    r5, r8\n+mov\t    r6, r9\n+mov\t    r7, r10\n+push\t    {r5-r7}\n+mov\t    r5, r11\n+push\t    {r5}\n+mov\t    r5, r4\n+mov\t    r6, r4\n+mov\t    r7, r4\n+mov\t    r8, r4\n+mov\t    r9, r4\n+mov\t    r10, r4\n+mov\t    r11, r4\n+mov\t    ip, r4\n+msr\t    APSR_nzcvq, r4\n+blxns\t    r4\n+pop\t    {r5}\n+mov\t    r11, r5\n+pop\t    {r5-r7}\n+mov\t    r10, r7\n+mov\t    r9, r6\n+mov\t    r8, r5\n+pop\t    {r5-r7, pc}\n+\n+#else\n+#error \"This should only be used for armv8-m base- and mainline.\"\n+#endif"}, {"sha": "9e85ac06b146feaa14ab83374a0156737b870310", "filename": "libgcc/config/arm/t-arm", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92e08e3d766baf88c7507cd5224d4d241ff8d39/libgcc%2Fconfig%2Farm%2Ft-arm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92e08e3d766baf88c7507cd5224d4d241ff8d39/libgcc%2Fconfig%2Farm%2Ft-arm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Farm%2Ft-arm?ref=c92e08e3d766baf88c7507cd5224d4d241ff8d39", "patch": "@@ -12,4 +12,6 @@ libgcc-objects += cmse.o cmse_nonsecure_call.o\n \n cmse.o: $(srcdir)/config/arm/cmse.c\n \t$(gcc_compile) -c $(CMSE_OPTS) $<\n+cmse_nonsecure_call.o: $(srcdir)/config/arm/cmse_nonsecure_call.S\n+\t\t       $(gcc_compile) -c $<\n endif"}]}