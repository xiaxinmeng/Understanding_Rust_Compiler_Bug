{"sha": "0c99ec5c426117d4cd53e64e9ad4b22f3a903f36", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGM5OWVjNWM0MjYxMTdkNGNkNTNlNjRlOWFkNGIyMmYzYTkwM2YzNg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-04-07T09:24:45Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-04-07T09:24:45Z"}, "message": "rtl.def (COND_EXEC): New.\n\n        * rtl.def (COND_EXEC): New.\n        * rtl.h (COND_EXEC_TEST, COND_EXEC_CODE): New.\n        * tm.texi (MAX_CONDITIONAL_EXECUTE): Document.\n\n        * genconfig.c (have_cond_arith_flag): Remove.\n        (have_cond_exec_flag): New.\n        (walk_insn_part): Detect COND_EXEC, not arithmetic in IF_THEN_ELSE.\n        (main): Print HAVE_conditional_execution.\n\n        * haifa-sched.c (haifa_classify_insn): Recognize COND_EXEC.\n        (sched_analyze_insn, print_pattern): Likewise.\n        * reload.c (find_equiv_reg): Likewise.\n        * rtlanal.c (reg_referenced_p): Likewise.\n        (note_stores, dead_or_set_regno_p): Likewise.\n        (reg_overlap_mentioned_p): Rewrite to use a switch.\n\nFrom-SVN: r32997", "tree": {"sha": "a36fbb677db9b9d77dd79d4991fb6f4bd8349ebc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a36fbb677db9b9d77dd79d4991fb6f4bd8349ebc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c99ec5c426117d4cd53e64e9ad4b22f3a903f36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c99ec5c426117d4cd53e64e9ad4b22f3a903f36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c99ec5c426117d4cd53e64e9ad4b22f3a903f36", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c99ec5c426117d4cd53e64e9ad4b22f3a903f36/comments", "author": null, "committer": null, "parents": [{"sha": "4c85a96d6e0a24baeeb64a13e1d522b5ee04d76f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c85a96d6e0a24baeeb64a13e1d522b5ee04d76f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c85a96d6e0a24baeeb64a13e1d522b5ee04d76f"}], "stats": {"total": 207, "additions": 146, "deletions": 61}, "files": [{"sha": "75360a097dc7121e7f24343fd28084d3c0f702c5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c99ec5c426117d4cd53e64e9ad4b22f3a903f36/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c99ec5c426117d4cd53e64e9ad4b22f3a903f36/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0c99ec5c426117d4cd53e64e9ad4b22f3a903f36", "patch": "@@ -1,5 +1,21 @@\n 2000-04-07  Richard Henderson  <rth@cygnus.com>\n \n+\t* rtl.def (COND_EXEC): New.\n+\t* rtl.h (COND_EXEC_TEST, COND_EXEC_CODE): New.\n+\t* tm.texi (MAX_CONDITIONAL_EXECUTE): Document.\n+\n+\t* genconfig.c (have_cond_arith_flag): Remove.\n+\t(have_cond_exec_flag): New.\n+\t(walk_insn_part): Detect COND_EXEC, not arithmetic in IF_THEN_ELSE.\n+\t(main): Print HAVE_conditional_execution.\n+\n+\t* haifa-sched.c (haifa_classify_insn): Recognize COND_EXEC.\n+\t(sched_analyze_insn, print_pattern): Likewise.\n+\t* reload.c (find_equiv_reg): Likewise.\n+\t* rtlanal.c (reg_referenced_p): Likewise.\n+\t(note_stores, dead_or_set_regno_p): Likewise.\n+\t(reg_overlap_mentioned_p): Rewrite to use a switch.\n+\n \t* ggc.h (struct rtx_def): Forward declare.\n \n \t* print-rtl.c (debug_rtx_range): New."}, {"sha": "65c8701ab227942be4d8f6f84f412c803f4f4487", "filename": "gcc/genconfig.c", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c99ec5c426117d4cd53e64e9ad4b22f3a903f36/gcc%2Fgenconfig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c99ec5c426117d4cd53e64e9ad4b22f3a903f36/gcc%2Fgenconfig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconfig.c?ref=0c99ec5c426117d4cd53e64e9ad4b22f3a903f36", "patch": "@@ -39,7 +39,7 @@ static int max_dup_operands;    /* Largest number of match_dup in any insn.  */\n static int max_clobbers_per_insn;\n static int have_cc0_flag;\n static int have_cmove_flag;\n-static int have_cond_arith_flag;\n+static int have_cond_exec_flag;\n static int have_lo_sum_flag;\n static int have_peephole_flag;\n static int have_peephole2_flag;\n@@ -131,21 +131,17 @@ walk_insn_part (part, recog_p, non_pc_set_src)\n \t two arms of the IF_THEN_ELSE are both MATCH_OPERAND.  Otherwise,\n \t we have some specific IF_THEN_ELSE construct (like the doz\n \t instruction on the RS/6000) that can't be used in the general\n-\t context we want it for.  If the first operand is an arithmetic\n-\t operation and the second is a MATCH_OPERNAND, show we have\n-\t conditional arithmetic.  */\n+\t context we want it for.  */\n \n       if (recog_p && non_pc_set_src\n \t  && GET_CODE (XEXP (part, 1)) == MATCH_OPERAND\n \t  && GET_CODE (XEXP (part, 2)) == MATCH_OPERAND)\n \thave_cmove_flag = 1;\n-      else if (recog_p && non_pc_set_src\n-\t       && (GET_RTX_CLASS (GET_CODE (XEXP (part, 1))) == '1'\n-\t\t   || GET_RTX_CLASS (GET_CODE (XEXP (part, 1))) == '2'\n-\t\t   || GET_RTX_CLASS (GET_CODE (XEXP (part, 1))) == 'c')\n-\t       && GET_CODE (XEXP (XEXP (part, 1), 0)) == MATCH_OPERAND\n-\t       && GET_CODE (XEXP (part, 2)) == MATCH_OPERAND)\n-\thave_cond_arith_flag = 1;\n+      break;\n+\n+    case COND_EXEC:\n+      if (recog_p)\n+\thave_cond_exec_flag = 1;\n       break;\n \n     case REG: case CONST_INT: case SYMBOL_REF:\n@@ -341,20 +337,18 @@ from the machine description file `md'.  */\\n\\n\");\n \n   /* This is conditionally defined, in case the user writes code which emits\n      more splits than we can readily see (and knows s/he does it).  */\n-  printf (\"#ifndef MAX_INSNS_PER_SPLIT\\n#define MAX_INSNS_PER_SPLIT %d\\n#endif\\n\",\n-\t  max_insns_per_split);\n+  printf (\"#ifndef MAX_INSNS_PER_SPLIT\\n\");\n+  printf (\"#define MAX_INSNS_PER_SPLIT %d\\n\", max_insns_per_split);\n+  printf (\"#endif\\n\");\n \n   if (have_cc0_flag)\n     printf (\"#define HAVE_cc0\\n\");\n \n   if (have_cmove_flag)\n     printf (\"#define HAVE_conditional_move\\n\");\n \n-#if 0\n-  /* Disabled.  See the discussion in jump.c.  */\n-  if (have_cond_arith_flag)\n-    printf (\"#define HAVE_conditional_arithmetic\\n\");\n-#endif\n+  if (have_cond_exec_flag)\n+    printf (\"#define HAVE_conditional_execution\\n\");\n \n   if (have_lo_sum_flag)\n     printf (\"#define HAVE_lo_sum\\n\");"}, {"sha": "36a4cc805229e0998371c4b6959e2ecbf58eb2b4", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c99ec5c426117d4cd53e64e9ad4b22f3a903f36/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c99ec5c426117d4cd53e64e9ad4b22f3a903f36/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=0c99ec5c426117d4cd53e64e9ad4b22f3a903f36", "patch": "@@ -2588,6 +2588,7 @@ haifa_classify_insn (insn)\n \t\tWORST_CLASS (tmp_class,\n \t\t\t   may_trap_exp (SET_SRC (XVECEXP (pat, 0, i)), 0));\n \t      break;\n+\t    case COND_EXEC:\n \t    case TRAP_IF:\n \t      tmp_class = TRAP_RISKY;\n \t      break;\n@@ -2617,6 +2618,7 @@ haifa_classify_insn (insn)\n \t    WORST_CLASS (tmp_class,\n \t\t\t may_trap_exp (SET_SRC (pat), 0));\n \t  break;\n+\tcase COND_EXEC:\n \tcase TRAP_IF:\n \t  tmp_class = TRAP_RISKY;\n \t  break;\n@@ -3649,18 +3651,35 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n   int maxreg = max_reg_num ();\n   int i;\n \n+  if (code == COND_EXEC)\n+    {\n+      sched_analyze_2 (deps, COND_EXEC_TEST (x), insn);\n+\n+      /* ??? Should be recording conditions so we reduce the number of\n+\t false dependancies.  */\n+      x = COND_EXEC_CODE (x);\n+      code = GET_CODE (x);\n+    }\n   if (code == SET || code == CLOBBER)\n     sched_analyze_1 (deps, x, insn);\n   else if (code == PARALLEL)\n     {\n       register int i;\n       for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n \t{\n-\t  code = GET_CODE (XVECEXP (x, 0, i));\n+\t  rtx sub = XVECEXP (x, 0, i);\n+\t  code = GET_CODE (sub);\n+\n+\t  if (code == COND_EXEC)\n+\t    {\n+\t      sched_analyze_2 (deps, COND_EXEC_TEST (sub), insn);\n+\t      sub = COND_EXEC_CODE (sub);\n+\t      code = GET_CODE (sub);\n+\t    }\n \t  if (code == SET || code == CLOBBER)\n-\t    sched_analyze_1 (deps, XVECEXP (x, 0, i), insn);\n+\t    sched_analyze_1 (deps, sub, insn);\n \t  else\n-\t    sched_analyze_2 (deps, XVECEXP (x, 0, i), insn);\n+\t    sched_analyze_2 (deps, sub, insn);\n \t}\n     }\n   else\n@@ -5313,6 +5332,11 @@ print_pattern (buf, x, verbose)\n       print_value (t1, XEXP (x, 0), verbose);\n       sprintf (buf, \"use %s\", t1);\n       break;\n+    case COND_EXEC:\n+      print_value (t1, COND_EXEC_CODE (x), verbose);\n+      print_value (t2, COND_EXEC_TEST (x), verbose);\n+      sprintf (buf, \"cond_exec %s %s\", t1, t2);\n+      break;\n     case PARALLEL:\n       {\n \tint i;"}, {"sha": "128af4897569552fab616766b87c19362b15f231", "filename": "gcc/reload.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c99ec5c426117d4cd53e64e9ad4b22f3a903f36/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c99ec5c426117d4cd53e64e9ad4b22f3a903f36/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=0c99ec5c426117d4cd53e64e9ad4b22f3a903f36", "patch": "@@ -6190,6 +6190,8 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n \t     If GOAL is a memory ref and its address is not constant,\n \t     and this insn P changes a register used in GOAL, return 0.  */\n \n+\t  if (GET_CODE (pat) == COND_EXEC)\n+\t    pat = COND_EXEC_CODE (pat);\n \t  if (GET_CODE (pat) == SET || GET_CODE (pat) == CLOBBER)\n \t    {\n \t      register rtx dest = SET_DEST (pat);\n@@ -6232,6 +6234,8 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n \t      for (i = XVECLEN (pat, 0) - 1; i >= 0; i--)\n \t\t{\n \t\t  register rtx v1 = XVECEXP (pat, 0, i);\n+\t\t  if (GET_CODE (v1) == COND_EXEC)\n+\t\t    v1 = COND_EXEC_CODE (v1);\n \t\t  if (GET_CODE (v1) == SET || GET_CODE (v1) == CLOBBER)\n \t\t    {\n \t\t      register rtx dest = SET_DEST (v1);"}, {"sha": "69c14e0c1b79630641d852008891a53eefc32148", "filename": "gcc/rtl.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c99ec5c426117d4cd53e64e9ad4b22f3a903f36/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c99ec5c426117d4cd53e64e9ad4b22f3a903f36/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=0c99ec5c426117d4cd53e64e9ad4b22f3a903f36", "patch": "@@ -900,6 +900,13 @@ DEF_RTL_EXPR(CALL_PLACEHOLDER, \"call_placeholder\", \"uuuu\", 'x')\n    of canonical RTL.  It is, however, easier to manipulate this way.  */\n DEF_RTL_EXPR(PHI, \"phi\", \"E\", 'x')\n \n+/* Conditionally execute code.\n+   Operand 0 is the condition that if true, the code is executed.\n+   Operand 1 is the code to be executed (typically a SET). \n+\n+   Semantics are that there are no side effects if the condition\n+   is false.  */\n+DEF_RTL_EXPR(COND_EXEC, \"cond_exec\", \"ee\", 'x')\n \n /*\n Local variables:"}, {"sha": "124c6bf3d9276f8e3406ae5e3aab49246cd32e71", "filename": "gcc/rtl.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c99ec5c426117d4cd53e64e9ad4b22f3a903f36/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c99ec5c426117d4cd53e64e9ad4b22f3a903f36/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=0c99ec5c426117d4cd53e64e9ad4b22f3a903f36", "patch": "@@ -807,6 +807,12 @@ extern const char * const note_insn_name[];\n #define TRAP_CONDITION(RTX) XCEXP(RTX, 0, TRAP_IF)\n #define TRAP_CODE(RTX) XCEXP(RTX, 1, TRAP_IF)\n \n+/* For a COND_EXEC rtx, COND_EXEC_TEST is the condition to base\n+   conditionally executing the code on, COND_EXEC_CODE is the code\n+   to execute if the condition is true.  */\n+#define COND_EXEC_TEST(RTX) XCEXP(RTX, 0, COND_EXEC)\n+#define COND_EXEC_CODE(RTX) XCEXP(RTX, 1, COND_EXEC)\n+\n /* 1 in a SYMBOL_REF if it addresses this function's constants pool.  */\n #define CONSTANT_POOL_ADDRESS_P(RTX) ((RTX)->unchanging)\n "}, {"sha": "d9087cd51f9bd82be964b067911298781e8a118f", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 66, "deletions": 40, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c99ec5c426117d4cd53e64e9ad4b22f3a903f36/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c99ec5c426117d4cd53e64e9ad4b22f3a903f36/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=0c99ec5c426117d4cd53e64e9ad4b22f3a903f36", "patch": "@@ -429,6 +429,11 @@ reg_referenced_p (x, body)\n \t  return 1;\n       return 0;\n \n+    case COND_EXEC:\n+      if (reg_overlap_mentioned_p (x, COND_EXEC_TEST (body)))\n+\treturn 1;\n+      return reg_referenced_p (x, COND_EXEC_CODE (body));\n+\n     default:\n       return 0;\n     }\n@@ -949,52 +954,61 @@ reg_overlap_mentioned_p (x, in)\n   /* If either argument is a constant, then modifying X can not affect IN.  */\n   if (CONSTANT_P (x) || CONSTANT_P (in))\n     return 0;\n-  else if (GET_CODE (x) == SUBREG)\n+\n+  switch (GET_CODE (x))\n     {\n+    case SUBREG:\n       regno = REGNO (SUBREG_REG (x));\n       if (regno < FIRST_PSEUDO_REGISTER)\n \tregno += SUBREG_WORD (x);\n-    }\n-  else if (GET_CODE (x) == REG)\n-    regno = REGNO (x);\n-  else if (GET_CODE (x) == MEM)\n-    {\n-      const char *fmt;\n-      int i;\n+      goto do_reg;\n \n-      if (GET_CODE (in) == MEM)\n-\treturn 1;\n+    case REG:\n+      regno = REGNO (x);\n+    do_reg:\n+      endregno = regno + (regno < FIRST_PSEUDO_REGISTER\n+\t\t\t  ? HARD_REGNO_NREGS (regno, GET_MODE (x)) : 1);\n+      return refers_to_regno_p (regno, endregno, in, NULL_PTR);\n \n-      fmt = GET_RTX_FORMAT (GET_CODE (in));\n+    case MEM:\n+      {\n+\tconst char *fmt;\n+\tint i;\n \n-      for (i = GET_RTX_LENGTH (GET_CODE (in)) - 1; i >= 0; i--)\n-\tif (fmt[i] == 'e' && reg_overlap_mentioned_p (x, XEXP (in, i)))\n+\tif (GET_CODE (in) == MEM)\n \t  return 1;\n \n-      return 0;\n-    }\n-  else if (GET_CODE (x) == SCRATCH || GET_CODE (x) == PC\n-\t   || GET_CODE (x) == CC0)\n-    return reg_mentioned_p (x, in);\n-  else if (GET_CODE (x) == PARALLEL\n-\t   && GET_MODE (x) == BLKmode)\n-    {\n-      register int i;\n+\tfmt = GET_RTX_FORMAT (GET_CODE (in));\n+\tfor (i = GET_RTX_LENGTH (GET_CODE (in)) - 1; i >= 0; i--)\n+\t  if (fmt[i] == 'e' && reg_overlap_mentioned_p (x, XEXP (in, i)))\n+\t    return 1;\n \n-      /* If any register in here refers to it\n-\t we return true.  */\n-      for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n-\tif (reg_overlap_mentioned_p (SET_DEST (XVECEXP (x, 0, i)), in))\n-\t  return 1;\n-      return 0;\n-    }\n-  else\n-    abort ();\n+\treturn 0;\n+      }\n+\n+    case SCRATCH:\n+    case PC:\n+    case CC0:\n+      return reg_mentioned_p (x, in);\n \n-  endregno = regno + (regno < FIRST_PSEUDO_REGISTER\n-\t\t      ? HARD_REGNO_NREGS (regno, GET_MODE (x)) : 1);\n+    case PARALLEL:\n+      if (GET_MODE (x) == BLKmode)\n+\t{\n+\t  register int i;\n \n-  return refers_to_regno_p (regno, endregno, in, NULL_PTR);\n+\t  /* If any register in here refers to it we return true.  */\n+\t  for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n+\t    if (reg_overlap_mentioned_p (SET_DEST (XVECEXP (x, 0, i)), in))\n+\t      return 1;\n+\t  return 0;\n+\t}\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  abort ();\n }\n \f\n /* Used for communications between the next few functions.  */\n@@ -1108,7 +1122,9 @@ note_stores (x, fun, data)\n      void (*fun) PARAMS ((rtx, rtx, void *));\n      void *data;\n {\n-  if ((GET_CODE (x) == SET || GET_CODE (x) == CLOBBER))\n+  if (GET_CODE (x) == COND_EXEC)\n+    x = COND_EXEC_CODE (x);\n+  if (GET_CODE (x) == SET || GET_CODE (x) == CLOBBER)\n     {\n       register rtx dest = SET_DEST (x);\n       while ((GET_CODE (dest) == SUBREG\n@@ -1135,6 +1151,8 @@ note_stores (x, fun, data)\n       for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n \t{\n \t  register rtx y = XVECEXP (x, 0, i);\n+\t  if (GET_CODE (y) == COND_EXEC)\n+\t    y = COND_EXEC_CODE (y);\n \t  if (GET_CODE (y) == SET || GET_CODE (y) == CLOBBER)\n \t    {\n \t      register rtx dest = SET_DEST (y);\n@@ -1213,7 +1231,7 @@ dead_or_set_regno_p (insn, test_regno)\n      unsigned int test_regno;\n {\n   unsigned int regno, endregno;\n-  rtx link;\n+  rtx link, pattern;\n \n   /* See if there is a death note for something that includes\n      TEST_REGNO.  */\n@@ -1236,7 +1254,12 @@ dead_or_set_regno_p (insn, test_regno)\n       && find_regno_fusage (insn, CLOBBER, test_regno))\n     return 1;\n \n-  if (GET_CODE (PATTERN (insn)) == SET)\n+  pattern = PATTERN (insn);\n+\n+  if (GET_CODE (pattern) == COND_EXEC)\n+    pattern = COND_EXEC_CODE (pattern);\n+\n+  if (GET_CODE (pattern) == SET)\n     {\n       rtx dest = SET_DEST (PATTERN (insn));\n  \n@@ -1259,13 +1282,16 @@ dead_or_set_regno_p (insn, test_regno)\n \n       return (test_regno >= regno && test_regno < endregno);\n     }\n-  else if (GET_CODE (PATTERN (insn)) == PARALLEL)\n+  else if (GET_CODE (pattern) == PARALLEL)\n     {\n       register int i;\n \n-      for (i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n+      for (i = XVECLEN (pattern, 0) - 1; i >= 0; i--)\n \t{\n-\t  rtx body = XVECEXP (PATTERN (insn), 0, i);\n+\t  rtx body = XVECEXP (pattern, 0, i);\n+\n+\t  if (GET_CODE (body) == COND_EXEC)\n+\t    body = COND_EXEC_CODE (body);\n \n \t  if (GET_CODE (body) == SET || GET_CODE (body) == CLOBBER)\n \t    {"}, {"sha": "7d9610c6245d7b4ee19fe2b2267991686c1edd36", "filename": "gcc/tm.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c99ec5c426117d4cd53e64e9ad4b22f3a903f36/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c99ec5c426117d4cd53e64e9ad4b22f3a903f36/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=0c99ec5c426117d4cd53e64e9ad4b22f3a903f36", "patch": "@@ -7942,4 +7942,12 @@ Note that this functionality is part of POSIX.\n Defining @code{TARGET_HAS_F_SETLKW} will enable the test coverage code\n to use file locking when exiting a program, which avoids race conditions\n if the program has forked.\n+\n+@findex MAX_CONDITIONAL_EXECUTE\n+@item MAX_CONDITIONAL_EXECUTE\n+\n+A C expression for the maximum number of instructions to execute via\n+conditional execution instructions instead of a branch.  A value of\n+@code{BRANCH_COST}+1 is the default if the machine does not use cc0, and\n+1 if it does use cc0.\n @end table"}]}