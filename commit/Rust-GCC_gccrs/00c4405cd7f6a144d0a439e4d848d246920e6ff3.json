{"sha": "00c4405cd7f6a144d0a439e4d848d246920e6ff3", "node_id": "C_kwDOANBUbNoAKDAwYzQ0MDVjZDdmNmExNDRkMGE0MzllNGQ4NDhkMjQ2OTIwZTZmZjM", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-04-28T17:49:59Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-04-28T17:49:59Z"}, "message": "analyzer: handle repeated accesses after init of unknown size [PR105285]\n\nPR analyzer/105285 reports a false positive from\n-Wanalyzer-null-dereference on git.git's reftable/reader.c.\n\nA reduced version of the problem can be seen in test_1a of\ngcc.dg/analyzer/symbolic-12.c in the following:\n\nvoid test_1a (void *p, unsigned next_off)\n{\n  struct st_1 *r = p;\n\n  external_fn();\n\n  if (next_off >= r->size)\n    return;\n\n  if (next_off >= r->size)\n    /* We should have already returned if this is the case.  */\n    __analyzer_dump_path (); /* { dg-bogus \"path\" } */\n}\n\nwhere the analyzer erroneously considers this path, where\n(next_off >= r->size) is both false and then true:\n\nsymbolic-12.c: In function \u2018test_1a\u2019:\nsymbolic-12.c:22:5: note: path\n   22 |     __analyzer_dump_path (); /* { dg-bogus \"path\" } */\n      |     ^~~~~~~~~~~~~~~~~~~~~~~\n  \u2018test_1a\u2019: events 1-5\n    |\n    |   17 |   if (next_off >= r->size)\n    |      |      ^\n    |      |      |\n    |      |      (1) following \u2018false\u2019 branch...\n    |......\n    |   20 |   if (next_off >= r->size)\n    |      |      ~            ~~~~~~~\n    |      |      |             |\n    |      |      |             (2) ...to here\n    |      |      (3) following \u2018true\u2019 branch...\n    |   21 |     /* We should have already returned if this is the case.  */\n    |   22 |     __analyzer_dump_path (); /* { dg-bogus \"path\" } */\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (4) ...to here\n    |      |     (5) here\n    |\n\nThe root cause is that, at the call to the external function, the\nanalyzer considers the cluster for *p to have been touched, binding it\nto a conjured_svalue, but because p is void * no particular size is\nknown for the write, and so the cluster is bound using a symbolic key\ncovering the base region.  Later, the accesses to r->size are handled by\nbinding_cluster::get_any_binding, but binding_cluster::get_binding fails\nto find a match for the concrete field lookup, due to the key for the\nbinding being symbolic, and reaching this code:\n\n1522  /* If this cluster has been touched by a symbolic write, then the content\n1523     of any subregion not currently specifically bound is \"UNKNOWN\".  */\n1524  if (m_touched)\n1525    {\n1526      region_model_manager *rmm_mgr = mgr->get_svalue_manager ();\n1527      return rmm_mgr->get_or_create_unknown_svalue (reg->get_type ());\n1528    }\n\nHence each access to r->size is an unknown svalue, and thus the\ncondition (next_off >= r->size) isn't tracked, leading to the path with\ncontradictory conditions being treated as satisfiable.\n\nIn the original reproducer in git's reftable/reader.c, the call to the\nexternal fn is:\n  reftable_record_type(rec)\nwhich is considered to possibly write to *rec, which is *tab, where tab\nis the void * argument to reftable_reader_seek_void, and thus after the\ncall to reftable_record_type some arbitrary amount of *rec could have\nbeen written to.\n\nThis patch fixes things by detecting the \"this cluster has been 'filled'\nwith a conjured value of unknown size\" case, and handling\nget_any_binding on it by returning a sub_svalue of the conjured_svalue,\nso that repeated accesses to r->size give the same symbolic value, so\nthat the constraint manager rejects the bogus execution path, fixing the\nfalse positive.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/105285\n\t* store.cc (binding_cluster::get_any_binding): Handle accessing\n\tsub_svalues of clusters where the base region has a symbolic\n\tbinding.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/105285\n\t* gcc.dg/analyzer/symbolic-12.c: New test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "2a9fbab798b0e7111bb798bce7d6cc7cc23c9caa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a9fbab798b0e7111bb798bce7d6cc7cc23c9caa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00c4405cd7f6a144d0a439e4d848d246920e6ff3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00c4405cd7f6a144d0a439e4d848d246920e6ff3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00c4405cd7f6a144d0a439e4d848d246920e6ff3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00c4405cd7f6a144d0a439e4d848d246920e6ff3/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8586b00dd00a1783862da5f0c8811a740400074", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8586b00dd00a1783862da5f0c8811a740400074", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8586b00dd00a1783862da5f0c8811a740400074"}], "stats": {"total": 118, "additions": 118, "deletions": 0}, "files": [{"sha": "f5f8fe061f5704967c309c066c6193d9712832d4", "filename": "gcc/analyzer/store.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00c4405cd7f6a144d0a439e4d848d246920e6ff3/gcc%2Fanalyzer%2Fstore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00c4405cd7f6a144d0a439e4d848d246920e6ff3/gcc%2Fanalyzer%2Fstore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.cc?ref=00c4405cd7f6a144d0a439e4d848d246920e6ff3", "patch": "@@ -1519,6 +1519,18 @@ binding_cluster::get_any_binding (store_manager *mgr,\n       = get_binding_recursive (mgr, reg))\n     return direct_sval;\n \n+  /* If we had a write to a cluster of unknown size, we might\n+     have a self-binding of the whole base region with an svalue,\n+     where the base region is symbolic.\n+     Handle such cases by returning sub_svalue instances.  */\n+  if (const svalue *cluster_sval = maybe_get_simple_value (mgr))\n+    {\n+      /* Extract child svalue from parent svalue.  */\n+      region_model_manager *rmm_mgr = mgr->get_svalue_manager ();\n+      return rmm_mgr->get_or_create_sub_svalue (reg->get_type (),\n+\t\t\t\t\t\tcluster_sval, reg);\n+    }\n+\n   /* If this cluster has been touched by a symbolic write, then the content\n      of any subregion not currently specifically bound is \"UNKNOWN\".  */\n   if (m_touched)"}, {"sha": "d7c50de9f2706ce3569d81781be72fa43b19148a", "filename": "gcc/testsuite/gcc.dg/analyzer/symbolic-12.c", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00c4405cd7f6a144d0a439e4d848d246920e6ff3/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00c4405cd7f6a144d0a439e4d848d246920e6ff3/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-12.c?ref=00c4405cd7f6a144d0a439e4d848d246920e6ff3", "patch": "@@ -0,0 +1,106 @@\n+#include \"analyzer-decls.h\"\n+\n+void external_fn(void);\n+\n+struct st_1\n+{\n+  char *name;\n+  unsigned size;\n+};\n+\n+void test_1a (void *p, unsigned next_off)\n+{\n+  struct st_1 *r = p;\n+\n+  external_fn();\n+\n+  if (next_off >= r->size)\n+    return;\n+\n+  if (next_off >= r->size)\n+    /* We should have already returned if this is the case.  */\n+    __analyzer_dump_path (); /* { dg-bogus \"path\" } */\n+}\n+\n+void test_1b (void *p, unsigned next_off)\n+{\n+  struct st_1 *r = p;\n+\n+  if (next_off >= r->size)\n+    return;\n+\n+  if (next_off >= r->size)\n+    /* We should have already returned if this is the case.  */\n+    __analyzer_dump_path (); /* { dg-bogus \"path\" } */\n+}\n+\n+void test_1c (struct st_1 *r, unsigned next_off)\n+{\n+  if (next_off >= r->size)\n+    return;\n+\n+  if (next_off >= r->size)\n+    /* We should have already returned if this is the case.  */\n+    __analyzer_dump_path (); /* { dg-bogus \"path\" } */\n+}\n+\n+void test_1d (struct st_1 *r, unsigned next_off)\n+{\n+  external_fn();\n+\n+  if (next_off >= r->size)\n+    return;\n+\n+  if (next_off >= r->size)\n+    /* We should have already returned if this is the case.  */\n+    __analyzer_dump_path (); /* { dg-bogus \"path\" } */\n+}\n+\n+void test_1e (void *p, unsigned next_off)\n+{\n+  struct st_1 *r = p;\n+\n+  while (1)\n+    {\n+      external_fn();\n+\n+      if (next_off >= r->size)\n+\treturn;\n+\n+      __analyzer_dump_path (); /* { dg-message \"path\" } */\n+    }\n+}\n+\n+struct st_2\n+{\n+  char *name;\n+  unsigned arr[10];\n+};\n+\n+void test_2a (void *p, unsigned next_off)\n+{\n+  struct st_2 *r = p;\n+\n+  external_fn();\n+\n+  if (next_off >= r->arr[5])\n+    return;\n+\n+  if (next_off >= r->arr[5])\n+    /* We should have already returned if this is the case.  */\n+    __analyzer_dump_path (); /* { dg-bogus \"path\" } */\n+}\n+\n+void test_2b (void *p, unsigned next_off, int idx)\n+{\n+  struct st_2 *r = p;\n+\n+  external_fn();\n+\n+  if (next_off >= r->arr[idx])\n+    return;\n+\n+  if (next_off >= r->arr[idx])\n+    /* We should have already returned if this is the case.  */\n+    __analyzer_dump_path (); /* { dg-bogus \"path\" } */\n+}"}]}