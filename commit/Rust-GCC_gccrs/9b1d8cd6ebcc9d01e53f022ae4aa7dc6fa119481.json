{"sha": "9b1d8cd6ebcc9d01e53f022ae4aa7dc6fa119481", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWIxZDhjZDZlYmNjOWQwMWU1M2YwMjJhZTRhYTdkYzZmYTExOTQ4MQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-04-21T19:24:23Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-04-21T19:24:23Z"}, "message": "Add missing declarations of functions in final.c.\n\n(STDIO_PROTO): Don't define here.\n\nFrom-SVN: r7109", "tree": {"sha": "f18f2f47c0bf61f6c6751356858c6a5c8d4c63f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f18f2f47c0bf61f6c6751356858c6a5c8d4c63f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b1d8cd6ebcc9d01e53f022ae4aa7dc6fa119481", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b1d8cd6ebcc9d01e53f022ae4aa7dc6fa119481", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b1d8cd6ebcc9d01e53f022ae4aa7dc6fa119481", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b1d8cd6ebcc9d01e53f022ae4aa7dc6fa119481/comments", "author": null, "committer": null, "parents": [{"sha": "fca04441218b5e306e0480170550ff6ac6a00b36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fca04441218b5e306e0480170550ff6ac6a00b36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fca04441218b5e306e0480170550ff6ac6a00b36"}], "stats": {"total": 100, "additions": 85, "deletions": 15}, "files": [{"sha": "ebd0a2f13fc85db9029cc328ff27a43a66e3ab7a", "filename": "gcc/output.h", "status": "modified", "additions": 85, "deletions": 15, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1d8cd6ebcc9d01e53f022ae4aa7dc6fa119481/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1d8cd6ebcc9d01e53f022ae4aa7dc6fa119481/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=9b1d8cd6ebcc9d01e53f022ae4aa7dc6fa119481", "patch": "@@ -18,34 +18,104 @@ You should have received a copy of the GNU General Public License\n along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n-#ifndef STDIO_PROTO\n-#ifdef BUFSIZ\n-#define STDIO_PROTO(ARGS) PROTO(ARGS)\n-#else\n-#define STDIO_PROTO(ARGS) ()\n-#endif\n-#endif\n+/* Initialize data in final at the beginning of a compilation.  */\n+extern void init_final\t\tPROTO((char *));\n+\n+/* Called at end of source file,\n+   to output the block-profiling table for this entire compilation.  */\n+extern void end_final\t\tPROTO((char *));\n+\n+/* Enable APP processing of subsequent output.\n+   Used before the output from an `asm' statement.  */\n+extern void app_enable\t\tPROTO((void));\n+\n+/* Disable APP processing of subsequent output.\n+   Called from varasm.c before most kinds of output.  */\n+extern void app_disable\t\tPROTO((void));\n+\n+/* Return the number of slots filled in the current \n+   delayed branch sequence (we don't count the insn needing the\n+   delay slot).   Zero if not in a delayed branch sequence.  */\n+extern int dbr_sequence_length\tPROTO((void));\n+\n+/* Indicate that branch shortening hasn't yet been done.  */\n+extern void init_insn_lengths\tPROTO((void));\n+\n+/* Obtain the current length of an insn.  If branch shortening has been done,\n+   get its actual length.  Otherwise, get its maximum length.  */\n+extern int get_attr_length\tPROTO((rtx));\n+\n+/* Make a pass over all insns and compute their actual lengths by shortening\n+   any branches of variable length if possible.  */\n+extern void shorten_branches\tPROTO((rtx));\n+\n+/* Output assembler code for the start of a function,\n+   and initialize some of the variables in this file\n+   for the new function.  The label for the function and associated\n+   assembler pseudo-ops have already been output in\n+   `assemble_start_function'.  */\n+extern void final_start_function  STDIO_PROTO((rtx, FILE *, int));\n+\n+/* Output assembler code for the end of a function.\n+   For clarity, args are same as those of `final_start_function'\n+   even though not all of them are needed.  */\n+extern void final_end_function  STDIO_PROTO((rtx, FILE *, int));\n+\n+/* Output assembler code for some insns: all or part of a function.  */\n+extern void final\t\tSTDIO_PROTO((rtx, FILE *, int, int));\n+\n+/* The final scan for one insn, INSN.  Args are same as in `final', except\n+   that INSN is the insn being scanned.  Value returned is the next insn to\n+   be scanned.  */\n+extern rtx final_scan_insn\tSTDIO_PROTO((rtx, FILE *, int, int, int));\n+\n+/* Replace a SUBREG with a REG or a MEM, based on the thing it is a\n+   subreg of.  */\n+extern rtx alter_subreg PROTO((rtx));\n+\n+/* Report inconsistency between the assembler template and the operands.\n+   In an `asm', it's the user's fault; otherwise, the compiler's fault.  */\n+extern void output_operand_lossage  PROTO((char *));\n \n /* Output a string of assembler code, substituting insn operands.\n    Defined in final.c.  */\n-extern void output_asm_insn PROTO((char *, rtx *));\n+extern void output_asm_insn\tPROTO((char *, rtx *));\n \n-/* Output a string of assembler code, substituting numbers, strings\n-   and fixed syntactic prefixes.  */\n-extern void asm_fprintf STDIO_PROTO(PVPROTO((FILE *file, char *p, ...)));\n+/* Output a LABEL_REF, or a bare CODE_LABEL, as an assembler symbol.  */\n+extern void output_asm_label\tPROTO((rtx));\n+\n+/* Print a memory reference operand for address X\n+   using machine-dependent assembler syntax.  */\n+extern void output_address\tPROTO((rtx));\n \n /* Print an integer constant expression in assembler syntax.\n    Addition and subtraction are the only arithmetic\n    that may appear in these expressions.  */\n extern void output_addr_const STDIO_PROTO((FILE *, rtx));\n \n+/* Output a string of assembler code, substituting numbers, strings\n+   and fixed syntactic prefixes.  */\n+extern void asm_fprintf\t\tSTDIO_PROTO(PVPROTO((FILE *file,\n+\t\t\t\t\t\t     char *p, ...)));\n+\n+/* Split up a CONST_DOUBLE or integer constant rtx into two rtx's for single\n+   words.  */\n+extern void split_double\tPROTO((rtx, rtx *, rtx *));\n+\n+/* Return nonzero if this function has no function calls.  */\n+extern int leaf_function_p\tPROTO((void));\n+\n+/* Return 1 if this function uses only the registers that can be\n+   safely renumbered.  */\n+extern int only_leaf_regs_used\tPROTO((void));\n+\n+/* Scan IN_RTX and its subexpressions, and renumber all regs into those\n+   available in leaf functions.  */\n+extern void leaf_renumber_regs_insn PROTO((rtx));\n+\n /* Output a name (as found inside a symbol_ref) in assembler syntax.  */\n extern void assemble_name STDIO_PROTO((FILE *, char *));\n \n-/* Replace a SUBREG with a REG or a MEM, based on the thing it is a\n-   subreg of.  */\n-extern rtx alter_subreg PROTO((rtx));\n-\n /* When outputting assembler code, indicates which alternative\n    of the constraints was actually satisfied.  */\n extern int which_alternative;"}]}