{"sha": "56bb34e3d2c800a7f13e65755bccfb6b2dc5e898", "node_id": "C_kwDOANBUbNoAKDU2YmIzNGUzZDJjODAwYTdmMTNlNjU3NTViY2NmYjZiMmRjNWU4OTg", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-09-01T14:58:34Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-09-01T19:31:00Z"}, "message": "libstdc++: Remove __is_referenceable helper\n\nWe only use the __is_referenceable helper in three places now:\nadd_pointer, add_lvalue_reference, and add_rvalue_reference. But lots of\nother traits depend on add_[lr]value_reference, and decay depends on\nadd_pointer, so removing the instantiation of __is_referenceable helps\ncompile all those other traits slightly faster.\n\nWe can just use void_t<T&> to check for a referenceable type in the\nadd_[lr]value_reference traits.\n\nThen we can specialize add_pointer for reference types, so that we don't\nneed to use remove_reference, and then use void_t<T*> for all\nnon-reference types to detect when we can form a pointer to the type.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/type_traits (__is_referenceable): Remove.\n\t(__add_lvalue_reference_helper, __add_rvalue_reference_helper):\n\tUse __void_t instead of __is_referenceable.\n\t(__add_pointer_helper): Likewise.\n\t(add_pointer): Add partial specializations for reference types.", "tree": {"sha": "00788776279deed5796e608402d5aecae9b814be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00788776279deed5796e608402d5aecae9b814be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56bb34e3d2c800a7f13e65755bccfb6b2dc5e898", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56bb34e3d2c800a7f13e65755bccfb6b2dc5e898", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56bb34e3d2c800a7f13e65755bccfb6b2dc5e898", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56bb34e3d2c800a7f13e65755bccfb6b2dc5e898/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bcedbbfc510e79cd299001dd79756ee4173b411", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bcedbbfc510e79cd299001dd79756ee4173b411", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bcedbbfc510e79cd299001dd79756ee4173b411"}], "stats": {"total": 37, "additions": 16, "deletions": 21}, "files": [{"sha": "8b11f31741b7fe9925ef67af8fe2931ae8dc5579", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56bb34e3d2c800a7f13e65755bccfb6b2dc5e898/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56bb34e3d2c800a7f13e65755bccfb6b2dc5e898/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=56bb34e3d2c800a7f13e65755bccfb6b2dc5e898", "patch": "@@ -712,18 +712,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // __void_t (std::void_t for C++11)\n   template<typename...> using __void_t = void;\n-\n-  // Utility to detect referenceable types ([defns.referenceable]).\n-\n-  template<typename _Tp, typename = void>\n-    struct __is_referenceable\n-    : public false_type\n-    { };\n-\n-  template<typename _Tp>\n-    struct __is_referenceable<_Tp, __void_t<_Tp&>>\n-    : public true_type\n-    { };\n   /// @endcond\n \n   // Type properties.\n@@ -1024,12 +1012,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     };\n \n   /// @cond undocumented\n-  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n+  template<typename _Tp, typename = void>\n     struct __add_lvalue_reference_helper\n     { using type = _Tp; };\n \n   template<typename _Tp>\n-    struct __add_lvalue_reference_helper<_Tp, true>\n+    struct __add_lvalue_reference_helper<_Tp, __void_t<_Tp&>>\n     { using type = _Tp&; };\n \n   template<typename _Tp>\n@@ -1046,12 +1034,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     };\n \n   /// @cond undocumented\n-  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n+  template<typename _Tp, typename = void>\n     struct __add_rvalue_reference_helper\n     { using type = _Tp; };\n \n   template<typename _Tp>\n-    struct __add_rvalue_reference_helper<_Tp, true>\n+    struct __add_rvalue_reference_helper<_Tp, __void_t<_Tp&&>>\n     { using type = _Tp&&; };\n \n   template<typename _Tp>\n@@ -1971,21 +1959,28 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : public __remove_pointer_helper<_Tp, __remove_cv_t<_Tp>>\n     { };\n \n-  template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,\n-\t\t\t\t      is_void<_Tp>>::value>\n+  template<typename _Tp, typename = void>\n     struct __add_pointer_helper\n-    { typedef _Tp     type; };\n+    { using type = _Tp; };\n \n   template<typename _Tp>\n-    struct __add_pointer_helper<_Tp, true>\n-    { typedef typename remove_reference<_Tp>::type*     type; };\n+    struct __add_pointer_helper<_Tp, __void_t<_Tp*>>\n+    { using type = _Tp*; };\n \n   /// add_pointer\n   template<typename _Tp>\n     struct add_pointer\n     : public __add_pointer_helper<_Tp>\n     { };\n \n+  template<typename _Tp>\n+    struct add_pointer<_Tp&>\n+    { using type = _Tp*; };\n+\n+  template<typename _Tp>\n+    struct add_pointer<_Tp&&>\n+    { using type = _Tp*; };\n+\n #if __cplusplus > 201103L\n   /// Alias template for remove_pointer\n   template<typename _Tp>"}]}