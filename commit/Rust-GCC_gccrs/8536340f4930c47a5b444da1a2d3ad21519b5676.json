{"sha": "8536340f4930c47a5b444da1a2d3ad21519b5676", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODUzNjM0MGY0OTMwYzQ3YTViNDQ0ZGExYTJkM2FkMjE1MTliNTY3Ng==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-11-01T13:51:28Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-11-01T13:51:28Z"}, "message": "Factor out the mode handling in lower-subreg.c\n\nThis patch adds a helper routine (interesting_mode_p) to lower-subreg.c,\nto make the decision about whether a mode can be split and, if so,\ncalculate the number of bytes and words in the mode.  At present this\nfunction always returns true; a later patch will add cases in which it\ncan return false.\n\n2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* lower-subreg.c (interesting_mode_p): New function.\n\t(compute_costs, find_decomposable_subregs, decompose_register)\n\t(simplify_subreg_concatn, can_decompose_p, resolve_simple_move)\n\t(resolve_clobber, dump_choices): Use it.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r254308", "tree": {"sha": "58a84b77e189c3dc96c5081b85d2ba0efad24d45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58a84b77e189c3dc96c5081b85d2ba0efad24d45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8536340f4930c47a5b444da1a2d3ad21519b5676", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8536340f4930c47a5b444da1a2d3ad21519b5676", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8536340f4930c47a5b444da1a2d3ad21519b5676", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8536340f4930c47a5b444da1a2d3ad21519b5676/comments", "author": null, "committer": null, "parents": [{"sha": "8c4dcf35d54e111156d78801111633feb11de87a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c4dcf35d54e111156d78801111633feb11de87a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c4dcf35d54e111156d78801111633feb11de87a"}], "stats": {"total": 87, "additions": 58, "deletions": 29}, "files": [{"sha": "d997cac3b20db9da1b8b606be37a686829bd8ef9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8536340f4930c47a5b444da1a2d3ad21519b5676/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8536340f4930c47a5b444da1a2d3ad21519b5676/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8536340f4930c47a5b444da1a2d3ad21519b5676", "patch": "@@ -1,3 +1,12 @@\n+2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* lower-subreg.c (interesting_mode_p): New function.\n+\t(compute_costs, find_decomposable_subregs, decompose_register)\n+\t(simplify_subreg_concatn, can_decompose_p, resolve_simple_move)\n+\t(resolve_clobber, dump_choices): Use it.\n+\n 2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "466b4bfd93d5a6fe293a6412b4f355542bdb7432", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 49, "deletions": 29, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8536340f4930c47a5b444da1a2d3ad21519b5676/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8536340f4930c47a5b444da1a2d3ad21519b5676/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=8536340f4930c47a5b444da1a2d3ad21519b5676", "patch": "@@ -103,6 +103,18 @@ struct target_lower_subreg *this_target_lower_subreg\n #define choices \\\n   this_target_lower_subreg->x_choices\n \n+/* Return true if MODE is a mode we know how to lower.  When returning true,\n+   store its byte size in *BYTES and its word size in *WORDS.  */\n+\n+static inline bool\n+interesting_mode_p (machine_mode mode, unsigned int *bytes,\n+\t\t    unsigned int *words)\n+{\n+  *bytes = GET_MODE_SIZE (mode);\n+  *words = CEIL (*bytes, UNITS_PER_WORD);\n+  return true;\n+}\n+\n /* RTXes used while computing costs.  */\n struct cost_rtxes {\n   /* Source and target registers.  */\n@@ -199,10 +211,10 @@ compute_costs (bool speed_p, struct cost_rtxes *rtxes)\n   for (i = 0; i < MAX_MACHINE_MODE; i++)\n     {\n       machine_mode mode = (machine_mode) i;\n-      int factor = GET_MODE_SIZE (mode) / UNITS_PER_WORD;\n-      if (factor > 1)\n+      unsigned int size, factor;\n+      if (interesting_mode_p (mode, &size, &factor) && factor > 1)\n \t{\n-\t  int mode_move_cost;\n+\t  unsigned int mode_move_cost;\n \n \t  PUT_MODE (rtxes->target, mode);\n \t  PUT_MODE (rtxes->source, mode);\n@@ -469,10 +481,10 @@ find_decomposable_subregs (rtx *loc, enum classify_move_insn *pcmi)\n \t      continue;\n \t    }\n \n-\t  outer_size = GET_MODE_SIZE (GET_MODE (x));\n-\t  inner_size = GET_MODE_SIZE (GET_MODE (inner));\n-\t  outer_words = (outer_size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n-\t  inner_words = (inner_size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+\t  if (!interesting_mode_p (GET_MODE (x), &outer_size, &outer_words)\n+\t      || !interesting_mode_p (GET_MODE (inner), &inner_size,\n+\t\t\t\t      &inner_words))\n+\t    continue;\n \n \t  /* We only try to decompose single word subregs of multi-word\n \t     registers.  When we find one, we return -1 to avoid iterating\n@@ -507,7 +519,7 @@ find_decomposable_subregs (rtx *loc, enum classify_move_insn *pcmi)\n \t}\n       else if (REG_P (x))\n \t{\n-\t  unsigned int regno;\n+\t  unsigned int regno, size, words;\n \n \t  /* We will see an outer SUBREG before we see the inner REG, so\n \t     when we see a plain REG here it means a direct reference to\n@@ -527,7 +539,8 @@ find_decomposable_subregs (rtx *loc, enum classify_move_insn *pcmi)\n \n \t  regno = REGNO (x);\n \t  if (!HARD_REGISTER_NUM_P (regno)\n-\t      && GET_MODE_SIZE (GET_MODE (x)) > UNITS_PER_WORD)\n+\t      && interesting_mode_p (GET_MODE (x), &size, &words)\n+\t      && words > 1)\n \t    {\n \t      switch (*pcmi)\n \t\t{\n@@ -567,15 +580,15 @@ static void\n decompose_register (unsigned int regno)\n {\n   rtx reg;\n-  unsigned int words, i;\n+  unsigned int size, words, i;\n   rtvec v;\n \n   reg = regno_reg_rtx[regno];\n \n   regno_reg_rtx[regno] = NULL_RTX;\n \n-  words = GET_MODE_SIZE (GET_MODE (reg));\n-  words = (words + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+  if (!interesting_mode_p (GET_MODE (reg), &size, &words))\n+    gcc_unreachable ();\n \n   v = rtvec_alloc (words);\n   for (i = 0; i < words; ++i)\n@@ -599,25 +612,29 @@ static rtx\n simplify_subreg_concatn (machine_mode outermode, rtx op,\n \t\t\t unsigned int byte)\n {\n-  unsigned int inner_size;\n+  unsigned int outer_size, outer_words, inner_size, inner_words;\n   machine_mode innermode, partmode;\n   rtx part;\n   unsigned int final_offset;\n \n+  innermode = GET_MODE (op);\n+  if (!interesting_mode_p (outermode, &outer_size, &outer_words)\n+      || !interesting_mode_p (innermode, &inner_size, &inner_words))\n+    gcc_unreachable ();\n+\n   gcc_assert (GET_CODE (op) == CONCATN);\n-  gcc_assert (byte % GET_MODE_SIZE (outermode) == 0);\n+  gcc_assert (byte % outer_size == 0);\n \n-  innermode = GET_MODE (op);\n-  gcc_assert (byte < GET_MODE_SIZE (innermode));\n-  if (GET_MODE_SIZE (outermode) > GET_MODE_SIZE (innermode))\n+  gcc_assert (byte < inner_size);\n+  if (outer_size > inner_size)\n     return NULL_RTX;\n \n-  inner_size = GET_MODE_SIZE (innermode) / XVECLEN (op, 0);\n+  inner_size /= XVECLEN (op, 0);\n   part = XVECEXP (op, 0, byte / inner_size);\n   partmode = GET_MODE (part);\n \n   final_offset = byte % inner_size;\n-  if (final_offset + GET_MODE_SIZE (outermode) > inner_size)\n+  if (final_offset + outer_size > inner_size)\n     return NULL_RTX;\n \n   /* VECTOR_CSTs in debug expressions are expanded into CONCATN instead of\n@@ -801,9 +818,10 @@ can_decompose_p (rtx x)\n \n       if (HARD_REGISTER_NUM_P (regno))\n \t{\n-\t  unsigned int byte, num_bytes;\n+\t  unsigned int byte, num_bytes, num_words;\n \n-\t  num_bytes = GET_MODE_SIZE (GET_MODE (x));\n+\t  if (!interesting_mode_p (GET_MODE (x), &num_bytes, &num_words))\n+\t    return false;\n \t  for (byte = 0; byte < num_bytes; byte += UNITS_PER_WORD)\n \t    if (simplify_subreg_regno (regno, GET_MODE (x), byte, word_mode) < 0)\n \t      return false;\n@@ -826,14 +844,15 @@ resolve_simple_move (rtx set, rtx_insn *insn)\n   rtx src, dest, real_dest;\n   rtx_insn *insns;\n   machine_mode orig_mode, dest_mode;\n-  unsigned int words;\n+  unsigned int orig_size, words;\n   bool pushing;\n \n   src = SET_SRC (set);\n   dest = SET_DEST (set);\n   orig_mode = GET_MODE (dest);\n \n-  words = (GET_MODE_SIZE (orig_mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+  if (!interesting_mode_p (orig_mode, &orig_size, &words))\n+    gcc_unreachable ();\n   gcc_assert (words > 1);\n \n   start_sequence ();\n@@ -964,7 +983,7 @@ resolve_simple_move (rtx set, rtx_insn *insn)\n     {\n       unsigned int i, j, jinc;\n \n-      gcc_assert (GET_MODE_SIZE (orig_mode) % UNITS_PER_WORD == 0);\n+      gcc_assert (orig_size % UNITS_PER_WORD == 0);\n       gcc_assert (GET_CODE (XEXP (dest, 0)) != PRE_MODIFY);\n       gcc_assert (GET_CODE (XEXP (dest, 0)) != POST_MODIFY);\n \n@@ -1059,16 +1078,16 @@ resolve_clobber (rtx pat, rtx_insn *insn)\n {\n   rtx reg;\n   machine_mode orig_mode;\n-  unsigned int words, i;\n+  unsigned int orig_size, words, i;\n   int ret;\n \n   reg = XEXP (pat, 0);\n   if (!resolve_reg_p (reg) && !resolve_subreg_p (reg))\n     return false;\n \n   orig_mode = GET_MODE (reg);\n-  words = GET_MODE_SIZE (orig_mode);\n-  words = (words + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+  if (!interesting_mode_p (orig_mode, &orig_size, &words))\n+    gcc_unreachable ();\n \n   ret = validate_change (NULL_RTX, &XEXP (pat, 0),\n \t\t\t simplify_gen_subreg_concatn (word_mode, reg,\n@@ -1332,12 +1351,13 @@ dump_shift_choices (enum rtx_code code, bool *splitting)\n static void\n dump_choices (bool speed_p, const char *description)\n {\n-  unsigned int i;\n+  unsigned int size, factor, i;\n \n   fprintf (dump_file, \"Choices when optimizing for %s:\\n\", description);\n \n   for (i = 0; i < MAX_MACHINE_MODE; i++)\n-    if (GET_MODE_SIZE ((machine_mode) i) > UNITS_PER_WORD)\n+    if (interesting_mode_p ((machine_mode) i, &size, &factor)\n+\t&& factor > 1)\n       fprintf (dump_file, \"  %s mode %s for copy lowering.\\n\",\n \t       choices[speed_p].move_modes_to_split[i]\n \t       ? \"Splitting\""}]}