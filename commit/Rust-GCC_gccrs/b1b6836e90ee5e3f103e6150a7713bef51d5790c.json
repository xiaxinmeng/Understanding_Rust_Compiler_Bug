{"sha": "b1b6836e90ee5e3f103e6150a7713bef51d5790c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjFiNjgzNmU5MGVlNWUzZjEwM2U2MTUwYTc3MTNiZWY1MWQ1NzkwYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-12-01T21:01:35Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-12-01T21:01:35Z"}, "message": "PR68577: Handle narrowing for vector popcount, etc.\n\nThis patch adds support for simple cases where a vector\ninternal function returns wider results than the scalar\nequivalent.  It punts on other cases.\n\nTested on powerpc64-linux-gnu and x86_64-linux-gnu.\n\ngcc/\n\tPR tree-optimization/68577\n\t* tree-vect-stmts.c (simple_integer_narrowing): New function.\n\t(vectorizable_call): Restrict internal function handling\n\tto NONE and NARROW cases, using simple_integer_narrowing\n\tto test for the latter.  Add cost of narrowing operation\n\tand insert it where necessary.\n\ngcc/testsuite/\n\tPR tree-optimization/68577\n\t* gcc.dg/vect/pr68577.c: New test.\n\nFrom-SVN: r231131", "tree": {"sha": "fab5425f914edd1fec50aa1a372f277f20dc7ab8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fab5425f914edd1fec50aa1a372f277f20dc7ab8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1b6836e90ee5e3f103e6150a7713bef51d5790c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1b6836e90ee5e3f103e6150a7713bef51d5790c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1b6836e90ee5e3f103e6150a7713bef51d5790c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1b6836e90ee5e3f103e6150a7713bef51d5790c/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e5f310313531456890c23279d248afb7e5cecf71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5f310313531456890c23279d248afb7e5cecf71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5f310313531456890c23279d248afb7e5cecf71"}], "stats": {"total": 147, "additions": 123, "deletions": 24}, "files": [{"sha": "1162f19893a40b578a74dce90932b99f621fd2b0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1b6836e90ee5e3f103e6150a7713bef51d5790c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1b6836e90ee5e3f103e6150a7713bef51d5790c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b1b6836e90ee5e3f103e6150a7713bef51d5790c", "patch": "@@ -1,3 +1,12 @@\n+2015-12-01  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR tree-optimization/68577\n+\t* tree-vect-stmts.c (simple_integer_narrowing): New function.\n+\t(vectorizable_call): Restrict internal function handling\n+\tto NONE and NARROW cases, using simple_integer_narrowing\n+\tto test for the latter.  Add cost of narrowing operation\n+\tand insert it where necessary.\n+\n 2015-12-01  Andreas Tobler  <andreast@gcc.gnu.org>\n \n \t* config/rs6000/freebsd64.h (ELFv2_ABI_CHECK): Add new macro."}, {"sha": "3363c9506b447fb0481fa93b8adb26235cfcc4b7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1b6836e90ee5e3f103e6150a7713bef51d5790c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1b6836e90ee5e3f103e6150a7713bef51d5790c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b1b6836e90ee5e3f103e6150a7713bef51d5790c", "patch": "@@ -1,3 +1,8 @@\n+2015-12-01  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR tree-optimization/68577\n+\t* gcc.dg/vect/pr68577.c: New test.\n+\n 2015-12-01  Nathan Sidwell  <nathan@acm.org>\n \n \t* gcc.target/nvptx/uninit-decl.c: New."}, {"sha": "999c1c8502e1b99e073dc665af5e3884c1bad641", "filename": "gcc/testsuite/gcc.dg/vect/pr68577.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1b6836e90ee5e3f103e6150a7713bef51d5790c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr68577.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1b6836e90ee5e3f103e6150a7713bef51d5790c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr68577.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr68577.c?ref=b1b6836e90ee5e3f103e6150a7713bef51d5790c", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+\n+int a, b;\n+\n+void\n+__sched_cpucount (void)\n+{\n+  while (b)\n+    {\n+      long l = b++;\n+      a += __builtin_popcountl(l);\n+    }\n+}\n+\n+void\n+slp_test (int *x, long *y)\n+{\n+  for (int i = 0; i < 512; i += 4)\n+    {\n+      x[i] = __builtin_popcountl(y[i]);\n+      x[i + 1] = __builtin_popcountl(y[i + 1]);\n+      x[i + 2] = __builtin_popcountl(y[i + 2]);\n+      x[i + 3] = __builtin_popcountl(y[i + 3]);\n+    }\n+}"}, {"sha": "0b0c4685f7decf669cb7dc47173ee883ad1cc646", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 84, "deletions": 24, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1b6836e90ee5e3f103e6150a7713bef51d5790c/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1b6836e90ee5e3f103e6150a7713bef51d5790c/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=b1b6836e90ee5e3f103e6150a7713bef51d5790c", "patch": "@@ -2140,6 +2140,31 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n   return true;\n }\n \n+/* Return true if vector types VECTYPE_IN and VECTYPE_OUT have\n+   integer elements and if we can narrow VECTYPE_IN to VECTYPE_OUT\n+   in a single step.  On success, store the binary pack code in\n+   *CONVERT_CODE.  */\n+\n+static bool\n+simple_integer_narrowing (tree vectype_out, tree vectype_in,\n+\t\t\t  tree_code *convert_code)\n+{\n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (vectype_out))\n+      || !INTEGRAL_TYPE_P (TREE_TYPE (vectype_in)))\n+    return false;\n+\n+  tree_code code;\n+  int multi_step_cvt = 0;\n+  auto_vec <tree, 8> interm_types;\n+  if (!supportable_narrowing_operation (NOP_EXPR, vectype_out, vectype_in,\n+\t\t\t\t\t&code, &multi_step_cvt,\n+\t\t\t\t\t&interm_types)\n+      || multi_step_cvt)\n+    return false;\n+\n+  *convert_code = code;\n+  return true;\n+}\n \n /* Function vectorizable_call.\n \n@@ -2306,7 +2331,12 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   tree callee = gimple_call_fndecl (stmt);\n \n   /* First try using an internal function.  */\n-  if (cfn != CFN_LAST)\n+  tree_code convert_code = ERROR_MARK;\n+  if (cfn != CFN_LAST\n+      && (modifier == NONE\n+\t  || (modifier == NARROW\n+\t      && simple_integer_narrowing (vectype_out, vectype_in,\n+\t\t\t\t\t   &convert_code))))\n     ifn = vectorizable_internal_function (cfn, callee, vectype_out,\n \t\t\t\t\t  vectype_in);\n \n@@ -2346,7 +2376,7 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n   if (slp_node || PURE_SLP_STMT (stmt_info))\n     ncopies = 1;\n-  else if (modifier == NARROW)\n+  else if (modifier == NARROW && ifn == IFN_LAST)\n     ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_out;\n   else\n     ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_in;\n@@ -2362,6 +2392,10 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n         dump_printf_loc (MSG_NOTE, vect_location, \"=== vectorizable_call ===\"\n                          \"\\n\");\n       vect_model_simple_cost (stmt_info, ncopies, dt, NULL, NULL);\n+      if (ifn != IFN_LAST && modifier == NARROW && !slp_node)\n+\tadd_stmt_cost (stmt_info->vinfo->target_cost_data, ncopies / 2,\n+\t\t       vec_promote_demote, stmt_info, 0, vect_body);\n+\n       return true;\n     }\n \n@@ -2375,9 +2409,9 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   vec_dest = vect_create_destination_var (scalar_dest, vectype_out);\n \n   prev_stmt_info = NULL;\n-  switch (modifier)\n+  if (modifier == NONE || ifn != IFN_LAST)\n     {\n-    case NONE:\n+      tree prev_res = NULL_TREE;\n       for (j = 0; j < ncopies; ++j)\n \t{\n \t  /* Build argument list for the vectorized call.  */\n@@ -2405,12 +2439,30 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t      vec<tree> vec_oprndsk = vec_defs[k];\n \t\t      vargs[k] = vec_oprndsk[i];\n \t\t    }\n-\t\t  if (ifn != IFN_LAST)\n-\t\t    new_stmt = gimple_build_call_internal_vec (ifn, vargs);\n+\t\t  if (modifier == NARROW)\n+\t\t    {\n+\t\t      tree half_res = make_ssa_name (vectype_in);\n+\t\t      new_stmt = gimple_build_call_internal_vec (ifn, vargs);\n+\t\t      gimple_call_set_lhs (new_stmt, half_res);\n+\t\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t\t      if ((i & 1) == 0)\n+\t\t\t{\n+\t\t\t  prev_res = half_res;\n+\t\t\t  continue;\n+\t\t\t}\n+\t\t      new_temp = make_ssa_name (vec_dest);\n+\t\t      new_stmt = gimple_build_assign (new_temp, convert_code,\n+\t\t\t\t\t\t      prev_res, half_res);\n+\t\t    }\n \t\t  else\n-\t\t    new_stmt = gimple_build_call_vec (fndecl, vargs);\n-\t\t  new_temp = make_ssa_name (vec_dest, new_stmt);\n-\t\t  gimple_call_set_lhs (new_stmt, new_temp);\n+\t\t    {\n+\t\t      if (ifn != IFN_LAST)\n+\t\t\tnew_stmt = gimple_build_call_internal_vec (ifn, vargs);\n+\t\t      else\n+\t\t\tnew_stmt = gimple_build_call_vec (fndecl, vargs);\n+\t\t      new_temp = make_ssa_name (vec_dest, new_stmt);\n+\t\t      gimple_call_set_lhs (new_stmt, new_temp);\n+\t\t    }\n \t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t\t  SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n \t\t}\n@@ -2454,6 +2506,21 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t      new_temp = make_ssa_name (vec_dest);\n \t      new_stmt = gimple_build_assign (new_temp, new_var);\n \t    }\n+\t  else if (modifier == NARROW)\n+\t    {\n+\t      tree half_res = make_ssa_name (vectype_in);\n+\t      new_stmt = gimple_build_call_internal_vec (ifn, vargs);\n+\t      gimple_call_set_lhs (new_stmt, half_res);\n+\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t      if ((j & 1) == 0)\n+\t\t{\n+\t\t  prev_res = half_res;\n+\t\t  continue;\n+\t\t}\n+\t      new_temp = make_ssa_name (vec_dest);\n+\t      new_stmt = gimple_build_assign (new_temp, convert_code,\n+\t\t\t\t\t      prev_res, half_res);\n+\t    }\n \t  else\n \t    {\n \t      if (ifn != IFN_LAST)\n@@ -2465,17 +2532,16 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t    }\n \t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \n-\t  if (j == 0)\n+\t  if (j == (modifier == NARROW ? 1 : 0))\n \t    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n \t  else\n \t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n \n \t  prev_stmt_info = vinfo_for_stmt (new_stmt);\n \t}\n-\n-      break;\n-\n-    case NARROW:\n+    }\n+  else if (modifier == NARROW)\n+    {\n       for (j = 0; j < ncopies; ++j)\n \t{\n \t  /* Build argument list for the vectorized call.  */\n@@ -2546,10 +2612,7 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t      vargs.quick_push (vec_oprnd1);\n \t    }\n \n-\t  if (ifn != IFN_LAST)\n-\t    new_stmt = gimple_build_call_internal_vec (ifn, vargs);\n-\t  else\n-\t    new_stmt = gimple_build_call_vec (fndecl, vargs);\n+\t  new_stmt = gimple_build_call_vec (fndecl, vargs);\n \t  new_temp = make_ssa_name (vec_dest, new_stmt);\n \t  gimple_call_set_lhs (new_stmt, new_temp);\n \t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n@@ -2563,13 +2626,10 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t}\n \n       *vec_stmt = STMT_VINFO_VEC_STMT (stmt_info);\n-\n-      break;\n-\n-    case WIDEN:\n-      /* No current target implements this case.  */\n-      return false;\n     }\n+  else\n+    /* No current target implements this case.  */\n+    return false;\n \n   vargs.release ();\n "}]}