{"sha": "884f77b4222289510e1df9db2889b60c5df6fcda", "node_id": "C_kwDOANBUbNoAKDg4NGY3N2I0MjIyMjg5NTEwZTFkZjlkYjI4ODliNjBjNWRmNmZjZGE", "commit": {"author": {"name": "Christophe Lyon", "email": "christophe.lyon@arm.com", "date": "2021-10-13T09:16:22Z"}, "committer": {"name": "Christophe Lyon", "email": "christophe.lyon@foss.st.com", "date": "2022-02-22T15:55:07Z"}, "message": "arm: Implement MVE predicates as vectors of booleans\n\nThis patch implements support for vectors of booleans to support MVE\npredicates, instead of HImode.  Since the ABI mandates pred16_t (aka\nuint16_t) to represent predicates in intrinsics prototypes, we\nintroduce a new \"predicate\" type qualifier so that we can map relevant\nbuiltins HImode arguments and return value to the appropriate vector\nof booleans (VxBI).\n\nWe have to update test_vector_ops_duplicate, because it iterates using\nan offset in bytes, where we would need to iterate in bits: we stop\niterating when we reach the end of the vector of booleans.\n\nIn addition, we have to fix the underlying definition of vectors of\nbooleans because ARM/MVE needs a different representation than\nAArch64/SVE. With ARM/MVE the 'true' bit is duplicated over the\nelement size, so that a true element of V4BI is represented by\n'0b1111'.  This patch updates the aarch64 definition of VNx*BI as\nneeded.\n\nMost of the work of this patch series was carried out while I was\nworking at STMicroelectronics as a Linaro assignee.\n\n2022-02-22  Christophe Lyon  <christophe.lyon@arm.com>\n\t    Richard Sandiford  <richard.sandiford@arm.com>\n\n\tgcc/\n\tPR target/100757\n\tPR target/101325\n\t* config/aarch64/aarch64-modes.def (VNx16BI, VNx8BI, VNx4BI,\n\tVNx2BI): Update definition.\n\t* config/arm/arm-builtins.cc (arm_init_simd_builtin_types): Add new\n\tsimd types.\n\t(arm_init_builtin): Map predicate vectors arguments to HImode.\n\t(arm_expand_builtin_args): Move HImode predicate arguments to VxBI\n\trtx. Move return value to HImode rtx.\n\t* config/arm/arm-builtins.h (arm_type_qualifiers): Add qualifier_predicate.\n\t* config/arm/arm-modes.def (B2I, B4I, V16BI, V8BI, V4BI): New modes.\n\t* config/arm/arm-simd-builtin-types.def (Pred1x16_t,\n\tPred2x8_t,Pred4x4_t): New.\n\t* emit-rtl.cc (init_emit_once): Handle all boolean modes.\n\t* genmodes.cc (mode_data): Add boolean field.\n\t(blank_mode): Initialize it.\n\t(make_complex_modes): Fix handling of boolean modes.\n\t(make_vector_modes): Likewise.\n\t(VECTOR_BOOL_MODE): Use new COMPONENT parameter.\n\t(make_vector_bool_mode): Likewise.\n\t(BOOL_MODE): New.\n\t(make_bool_mode): New.\n\t(emit_insn_modes_h): Fix generation of boolean modes.\n\t(emit_class_narrowest_mode): Likewise.\n\t* machmode.def: (VECTOR_BOOL_MODE): Document new COMPONENT\n\tparameter.  Use new BOOL_MODE instead of FRACTIONAL_INT_MODE to\n\tdefine BImode.\n\t* rtx-vector-builder.cc (rtx_vector_builder::find_cached_value):\n\tFix handling of constm1_rtx for VECTOR_BOOL.\n\t* simplify-rtx.cc (native_encode_rtx): Fix support for VECTOR_BOOL.\n\t(native_decode_vector_rtx): Likewise.\n\t(test_vector_ops_duplicate): Skip vec_merge test\n\twith vectors of booleans.\n\t* varasm.cc (output_constant_pool_2): Likewise.", "tree": {"sha": "0eb87f48af7d3493bea416f34dbad130a491bf2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0eb87f48af7d3493bea416f34dbad130a491bf2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/884f77b4222289510e1df9db2889b60c5df6fcda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/884f77b4222289510e1df9db2889b60c5df6fcda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/884f77b4222289510e1df9db2889b60c5df6fcda", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/884f77b4222289510e1df9db2889b60c5df6fcda/comments", "author": null, "committer": null, "parents": [{"sha": "0d0aaea105f6b5ddd9b4763e4cbd16ef65a74cb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d0aaea105f6b5ddd9b4763e4cbd16ef65a74cb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d0aaea105f6b5ddd9b4763e4cbd16ef65a74cb9"}], "stats": {"total": 218, "additions": 162, "deletions": 56}, "files": [{"sha": "8f399225a8048d93108e33e9d49c736aeb5612ce", "filename": "gcc/config/aarch64/aarch64-modes.def", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/884f77b4222289510e1df9db2889b60c5df6fcda/gcc%2Fconfig%2Faarch64%2Faarch64-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/884f77b4222289510e1df9db2889b60c5df6fcda/gcc%2Fconfig%2Faarch64%2Faarch64-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-modes.def?ref=884f77b4222289510e1df9db2889b60c5df6fcda", "patch": "@@ -47,10 +47,10 @@ ADJUST_FLOAT_FORMAT (HF, &ieee_half_format);\n \n /* Vector modes.  */\n \n-VECTOR_BOOL_MODE (VNx16BI, 16, 2);\n-VECTOR_BOOL_MODE (VNx8BI, 8, 2);\n-VECTOR_BOOL_MODE (VNx4BI, 4, 2);\n-VECTOR_BOOL_MODE (VNx2BI, 2, 2);\n+VECTOR_BOOL_MODE (VNx16BI, 16, BI, 2);\n+VECTOR_BOOL_MODE (VNx8BI, 8, BI, 2);\n+VECTOR_BOOL_MODE (VNx4BI, 4, BI, 2);\n+VECTOR_BOOL_MODE (VNx2BI, 2, BI, 2);\n \n ADJUST_NUNITS (VNx16BI, aarch64_sve_vg * 8);\n ADJUST_NUNITS (VNx8BI, aarch64_sve_vg * 4);"}, {"sha": "993a2f7b08295fefbec9a9292d45e16d0f4764a1", "filename": "gcc/config/arm/arm-builtins.cc", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/884f77b4222289510e1df9db2889b60c5df6fcda/gcc%2Fconfig%2Farm%2Farm-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/884f77b4222289510e1df9db2889b60c5df6fcda/gcc%2Fconfig%2Farm%2Farm-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-builtins.cc?ref=884f77b4222289510e1df9db2889b60c5df6fcda", "patch": "@@ -1553,11 +1553,28 @@ arm_init_simd_builtin_types (void)\n       tree eltype = arm_simd_types[i].eltype;\n       machine_mode mode = arm_simd_types[i].mode;\n \n-      if (eltype == NULL)\n+      if (eltype == NULL\n+\t  /* VECTOR_BOOL is not supported unless MVE is activated,\n+\t     this would make build_truth_vector_type_for_mode\n+\t     crash.  */\n+\t  && ((GET_MODE_CLASS (mode) != MODE_VECTOR_BOOL)\n+\t      || !TARGET_HAVE_MVE))\n \tcontinue;\n       if (arm_simd_types[i].itype == NULL)\n \t{\n-\t  tree type = build_vector_type (eltype, GET_MODE_NUNITS (mode));\n+\t  tree type;\n+\t  if (GET_MODE_CLASS (mode) == MODE_VECTOR_BOOL)\n+\t    {\n+\t      /* Handle MVE predicates: they are internally stored as\n+\t\t 16 bits, but are used as vectors of 1, 2 or 4-bit\n+\t\t elements.  */\n+\t      type = build_truth_vector_type_for_mode (GET_MODE_NUNITS (mode),\n+\t\t\t\t\t\t       mode);\n+\t      eltype = TREE_TYPE (type);\n+\t    }\n+\t  else\n+\t    type = build_vector_type (eltype, GET_MODE_NUNITS (mode));\n+\n \t  type = build_distinct_type_copy (type);\n \t  SET_TYPE_STRUCTURAL_EQUALITY (type);\n \n@@ -1695,6 +1712,11 @@ arm_init_builtin (unsigned int fcode, arm_builtin_datum *d,\n       if (qualifiers & qualifier_map_mode)\n \top_mode = d->mode;\n \n+      /* MVE Predicates use HImode as mandated by the ABI: pred16_t is\n+\t unsigned short.  */\n+      if (qualifiers & qualifier_predicate)\n+\top_mode = HImode;\n+\n       /* For pointers, we want a pointer to the basic type\n \t of the vector.  */\n       if (qualifiers & qualifier_pointer && VECTOR_MODE_P (op_mode))\n@@ -2939,6 +2961,12 @@ arm_expand_builtin_args (rtx target, machine_mode map_mode, int fcode,\n \t    case ARG_BUILTIN_COPY_TO_REG:\n \t      if (POINTER_TYPE_P (TREE_TYPE (arg[argc])))\n \t\top[argc] = convert_memory_address (Pmode, op[argc]);\n+\n+\t      /* MVE uses mve_pred16_t (aka HImode) for vectors of\n+\t\t predicates.  */\n+\t      if (GET_MODE_CLASS (mode[argc]) == MODE_VECTOR_BOOL)\n+\t\top[argc] = gen_lowpart (mode[argc], op[argc]);\n+\n \t      /*gcc_assert (GET_MODE (op[argc]) == mode[argc]); */\n \t      if (!(*insn_data[icode].operand[opno].predicate)\n \t\t  (op[argc], mode[argc]))\n@@ -3144,6 +3172,13 @@ arm_expand_builtin_args (rtx target, machine_mode map_mode, int fcode,\n   else\n     emit_insn (insn);\n \n+  if (GET_MODE_CLASS (tmode) == MODE_VECTOR_BOOL)\n+    {\n+      rtx HItarget = gen_reg_rtx (HImode);\n+      emit_move_insn (HItarget, gen_lowpart (HImode, target));\n+      return HItarget;\n+    }\n+\n   return target;\n }\n "}, {"sha": "a8ef8aef82d6319889ce5e9ea2645106bbfc3e3b", "filename": "gcc/config/arm/arm-builtins.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/884f77b4222289510e1df9db2889b60c5df6fcda/gcc%2Fconfig%2Farm%2Farm-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/884f77b4222289510e1df9db2889b60c5df6fcda/gcc%2Fconfig%2Farm%2Farm-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-builtins.h?ref=884f77b4222289510e1df9db2889b60c5df6fcda", "patch": "@@ -84,7 +84,9 @@ enum arm_type_qualifiers\n   qualifier_lane_pair_index = 0x1000,\n   /* Lane indices selected in quadtuplets - must be within range of previous\n      argument = a vector.  */\n-  qualifier_lane_quadtup_index = 0x2000\n+  qualifier_lane_quadtup_index = 0x2000,\n+  /* MVE vector predicates.  */\n+  qualifier_predicate = 0x4000\n };\n \n struct arm_simd_type_info"}, {"sha": "9ed0cd042c54655c25ed7cd3c403a45fe264063b", "filename": "gcc/config/arm/arm-modes.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/884f77b4222289510e1df9db2889b60c5df6fcda/gcc%2Fconfig%2Farm%2Farm-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/884f77b4222289510e1df9db2889b60c5df6fcda/gcc%2Fconfig%2Farm%2Farm-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-modes.def?ref=884f77b4222289510e1df9db2889b60c5df6fcda", "patch": "@@ -84,6 +84,14 @@ VECTOR_MODE (FLOAT, BF, 2);   /*                 V2BF.  */\n VECTOR_MODE (FLOAT, BF, 4);   /*\t\t V4BF.  */\n VECTOR_MODE (FLOAT, BF, 8);   /*\t\t V8BF.  */\n \n+/* Predicates for MVE.  */\n+BOOL_MODE (B2I, 2, 1);\n+BOOL_MODE (B4I, 4, 1);\n+\n+VECTOR_BOOL_MODE (V16BI, 16, BI, 2);\n+VECTOR_BOOL_MODE (V8BI, 8, B2I, 2);\n+VECTOR_BOOL_MODE (V4BI, 4, B4I, 2);\n+\n /* Fraction and accumulator vector modes.  */\n VECTOR_MODES (FRACT, 4);      /* V4QQ  V2HQ */\n VECTOR_MODES (UFRACT, 4);     /* V4UQQ V2UHQ */"}, {"sha": "d1d6416dad15fbc7aaa6459c8fc6e7bc839b56f1", "filename": "gcc/config/arm/arm-simd-builtin-types.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/884f77b4222289510e1df9db2889b60c5df6fcda/gcc%2Fconfig%2Farm%2Farm-simd-builtin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/884f77b4222289510e1df9db2889b60c5df6fcda/gcc%2Fconfig%2Farm%2Farm-simd-builtin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-simd-builtin-types.def?ref=884f77b4222289510e1df9db2889b60c5df6fcda", "patch": "@@ -51,3 +51,7 @@\n   ENTRY (Bfloat16x2_t, V2BF, none, 32, bfloat16, 20)\n   ENTRY (Bfloat16x4_t, V4BF, none, 64, bfloat16, 20)\n   ENTRY (Bfloat16x8_t, V8BF, none, 128, bfloat16, 20)\n+\n+  ENTRY (Pred1x16_t, V16BI, predicate, 16, pred1, 16)\n+  ENTRY (Pred2x8_t, V8BI, predicate, 8, pred1, 15)\n+  ENTRY (Pred4x4_t, V4BI, predicate, 4, pred1, 15)"}, {"sha": "f4404d7abe33b565358b7f609a91114c75ecf4e7", "filename": "gcc/emit-rtl.cc", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/884f77b4222289510e1df9db2889b60c5df6fcda/gcc%2Femit-rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/884f77b4222289510e1df9db2889b60c5df6fcda/gcc%2Femit-rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.cc?ref=884f77b4222289510e1df9db2889b60c5df6fcda", "patch": "@@ -6239,9 +6239,22 @@ init_emit_once (void)\n \n   /* For BImode, 1 and -1 are unsigned and signed interpretations\n      of the same value.  */\n-  const_tiny_rtx[0][(int) BImode] = const0_rtx;\n-  const_tiny_rtx[1][(int) BImode] = const_true_rtx;\n-  const_tiny_rtx[3][(int) BImode] = const_true_rtx;\n+  for (mode = MIN_MODE_BOOL;\n+       mode <= MAX_MODE_BOOL;\n+       mode = (machine_mode)((int)(mode) + 1))\n+    {\n+      const_tiny_rtx[0][(int) mode] = const0_rtx;\n+      if (mode == BImode)\n+\t{\n+\t  const_tiny_rtx[1][(int) mode] = const_true_rtx;\n+\t  const_tiny_rtx[3][(int) mode] = const_true_rtx;\n+\t}\n+      else\n+\t{\n+\t  const_tiny_rtx[1][(int) mode] = const1_rtx;\n+\t  const_tiny_rtx[3][(int) mode] = constm1_rtx;\n+\t}\n+    }\n \n   for (mode = MIN_MODE_PARTIAL_INT;\n        mode <= MAX_MODE_PARTIAL_INT;\n@@ -6260,13 +6273,16 @@ init_emit_once (void)\n       const_tiny_rtx[0][(int) mode] = gen_rtx_CONCAT (mode, inner, inner);\n     }\n \n-  /* As for BImode, \"all 1\" and \"all -1\" are unsigned and signed\n-     interpretations of the same value.  */\n   FOR_EACH_MODE_IN_CLASS (mode, MODE_VECTOR_BOOL)\n     {\n       const_tiny_rtx[0][(int) mode] = gen_const_vector (mode, 0);\n       const_tiny_rtx[3][(int) mode] = gen_const_vector (mode, 3);\n-      const_tiny_rtx[1][(int) mode] = const_tiny_rtx[3][(int) mode];\n+      if (GET_MODE_INNER (mode) == BImode)\n+\t/* As for BImode, \"all 1\" and \"all -1\" are unsigned and signed\n+\t   interpretations of the same value.  */\n+\tconst_tiny_rtx[1][(int) mode] = const_tiny_rtx[3][(int) mode];\n+      else\n+\tconst_tiny_rtx[1][(int) mode] = gen_const_vector (mode, 1);\n     }\n \n   FOR_EACH_MODE_IN_CLASS (mode, MODE_VECTOR_INT)"}, {"sha": "59850bb070a30c6f4462046a21a89a935577c33e", "filename": "gcc/genmodes.cc", "status": "modified", "additions": 50, "deletions": 21, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/884f77b4222289510e1df9db2889b60c5df6fcda/gcc%2Fgenmodes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/884f77b4222289510e1df9db2889b60c5df6fcda/gcc%2Fgenmodes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.cc?ref=884f77b4222289510e1df9db2889b60c5df6fcda", "patch": "@@ -78,6 +78,7 @@ struct mode_data\n   bool need_bytesize_adj;\t/* true if this mode needs dynamic size\n \t\t\t\t   adjustment */\n   unsigned int int_n;\t\t/* If nonzero, then __int<INT_N> will be defined */\n+  bool boolean;\n };\n \n static struct mode_data *modes[MAX_MODE_CLASS];\n@@ -88,7 +89,8 @@ static const struct mode_data blank_mode = {\n   0, \"<unknown>\", MAX_MODE_CLASS,\n   0, -1U, -1U, -1U, -1U,\n   0, 0, 0, 0, 0, 0,\n-  \"<unknown>\", 0, 0, 0, 0, false, false, 0\n+  \"<unknown>\", 0, 0, 0, 0, false, false, 0,\n+  false\n };\n \n static htab_t modes_by_name;\n@@ -456,7 +458,7 @@ make_complex_modes (enum mode_class cl,\n       size_t m_len;\n \n       /* Skip BImode.  FIXME: BImode probably shouldn't be MODE_INT.  */\n-      if (m->precision == 1)\n+      if (m->boolean)\n \tcontinue;\n \n       m_len = strlen (m->name);\n@@ -528,7 +530,7 @@ make_vector_modes (enum mode_class cl, const char *prefix, unsigned int width,\n \t not be necessary.  */\n       if (cl == MODE_FLOAT && m->bytesize == 1)\n \tcontinue;\n-      if (cl == MODE_INT && m->precision == 1)\n+      if (m->boolean)\n \tcontinue;\n \n       if ((size_t) snprintf (buf, sizeof buf, \"%s%u%s\", prefix,\n@@ -548,17 +550,18 @@ make_vector_modes (enum mode_class cl, const char *prefix, unsigned int width,\n \n /* Create a vector of booleans called NAME with COUNT elements and\n    BYTESIZE bytes in total.  */\n-#define VECTOR_BOOL_MODE(NAME, COUNT, BYTESIZE) \\\n-  make_vector_bool_mode (#NAME, COUNT, BYTESIZE, __FILE__, __LINE__)\n+#define VECTOR_BOOL_MODE(NAME, COUNT, COMPONENT, BYTESIZE)\t\t\\\n+  make_vector_bool_mode (#NAME, COUNT, #COMPONENT, BYTESIZE,\t\t\\\n+\t\t\t __FILE__, __LINE__)\n static void ATTRIBUTE_UNUSED\n make_vector_bool_mode (const char *name, unsigned int count,\n-\t\t       unsigned int bytesize, const char *file,\n-\t\t       unsigned int line)\n+\t\t       const char *component, unsigned int bytesize,\n+\t\t       const char *file, unsigned int line)\n {\n-  struct mode_data *m = find_mode (\"BI\");\n+  struct mode_data *m = find_mode (component);\n   if (!m)\n     {\n-      error (\"%s:%d: no mode \\\"BI\\\"\", file, line);\n+      error (\"%s:%d: no mode \\\"%s\\\"\", file, line, component);\n       return;\n     }\n \n@@ -596,6 +599,20 @@ make_int_mode (const char *name,\n   m->precision = precision;\n }\n \n+#define BOOL_MODE(N, B, Y) \\\n+  make_bool_mode (#N, B, Y, __FILE__, __LINE__)\n+\n+static void\n+make_bool_mode (const char *name,\n+\t\tunsigned int precision, unsigned int bytesize,\n+\t\tconst char *file, unsigned int line)\n+{\n+  struct mode_data *m = new_mode (MODE_INT, name, file, line);\n+  m->bytesize = bytesize;\n+  m->precision = precision;\n+  m->boolean = true;\n+}\n+\n #define OPAQUE_MODE(N, B)\t\t\t\\\n   make_opaque_mode (#N, -1U, B, __FILE__, __LINE__)\n \n@@ -1298,9 +1315,21 @@ enum machine_mode\\n{\");\n       /* Don't use BImode for MIN_MODE_INT, since otherwise the middle\n \t end will try to use it for bitfields in structures and the\n \t like, which we do not want.  Only the target md file should\n-\t generate BImode widgets.  */\n-      if (first && first->precision == 1 && c == MODE_INT)\n-\tfirst = first->next;\n+\t generate BImode widgets.  Since some targets such as ARM/MVE\n+\t define boolean modes with multiple bits, handle those too.  */\n+      if (first && first->boolean)\n+\t{\n+\t  struct mode_data *last_bool = first;\n+\t  printf (\"  MIN_MODE_BOOL = E_%smode,\\n\", first->name);\n+\n+\t  while (first && first->boolean)\n+\t    {\n+\t      last_bool = first;\n+\t      first = first->next;\n+\t    }\n+\n+\t  printf (\"  MAX_MODE_BOOL = E_%smode,\\n\\n\", last_bool->name);\n+\t}\n \n       if (first && last)\n \tprintf (\"  MIN_%s = E_%smode,\\n  MAX_%s = E_%smode,\\n\\n\",\n@@ -1679,15 +1708,15 @@ emit_class_narrowest_mode (void)\n   print_decl (\"unsigned char\", \"class_narrowest_mode\", \"MAX_MODE_CLASS\");\n \n   for (c = 0; c < MAX_MODE_CLASS; c++)\n-    /* Bleah, all this to get the comment right for MIN_MODE_INT.  */\n-    tagged_printf (\"MIN_%s\", mode_class_names[c],\n-\t\t   modes[c]\n-\t\t   ? ((c != MODE_INT || modes[c]->precision != 1)\n-\t\t      ? modes[c]->name\n-\t\t      : (modes[c]->next\n-\t\t\t ? modes[c]->next->name\n-\t\t\t : void_mode->name))\n-\t\t   : void_mode->name);\n+    {\n+      /* Bleah, all this to get the comment right for MIN_MODE_INT.  */\n+      struct mode_data *m = modes[c];\n+      while (m && m->boolean)\n+\tm = m->next;\n+      const char *comment_name = (m ? m : void_mode)->name;\n+\n+      tagged_printf (\"MIN_%s\", mode_class_names[c], comment_name);\n+    }\n \n   print_closer ();\n }"}, {"sha": "b62a5fbc683791eed3932b02c3bab3bb7460a1c0", "filename": "gcc/machmode.def", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/884f77b4222289510e1df9db2889b60c5df6fcda/gcc%2Fmachmode.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/884f77b4222289510e1df9db2889b60c5df6fcda/gcc%2Fmachmode.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.def?ref=884f77b4222289510e1df9db2889b60c5df6fcda", "patch": "@@ -146,12 +146,13 @@ along with GCC; see the file COPYING3.  If not see\n \tLike VECTOR_MODES, but start the mode names with PREFIX instead\n \tof the usual \"V\".\n \n-     VECTOR_BOOL_MODE (NAME, COUNT, BYTESIZE)\n+     VECTOR_BOOL_MODE (NAME, COUNT, COMPONENT, BYTESIZE)\n         Create a vector mode called NAME that contains COUNT boolean\n         elements and occupies BYTESIZE bytes in total.  Each boolean\n-        element occupies (COUNT * BITS_PER_UNIT) / BYTESIZE bits, with\n-        the element at index 0 occupying the lsb of the first byte in\n-        memory.  Only the lowest bit of each element is significant.\n+        element is of COMPONENT type and occupies (COUNT * BITS_PER_UNIT) /\n+        BYTESIZE bits, with the element at index 0 occupying the lsb of the\n+        first byte in memory.  Only the lowest bit of each element is\n+        significant.\n \n      OPAQUE_MODE (NAME, BYTESIZE)\n         Create an opaque mode called NAME that is BYTESIZE bytes wide.\n@@ -196,7 +197,7 @@ RANDOM_MODE (VOID);\n RANDOM_MODE (BLK);\n \n /* Single bit mode used for booleans.  */\n-FRACTIONAL_INT_MODE (BI, 1, 1);\n+BOOL_MODE (BI, 1, 1);\n \n /* Basic integer modes.  We go up to TI in generic code (128 bits).\n    TImode is needed here because the some front ends now genericly"}, {"sha": "55ffe0d5a7679bb31b59e9d2df8ff45e3946824f", "filename": "gcc/rtx-vector-builder.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/884f77b4222289510e1df9db2889b60c5df6fcda/gcc%2Frtx-vector-builder.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/884f77b4222289510e1df9db2889b60c5df6fcda/gcc%2Frtx-vector-builder.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtx-vector-builder.cc?ref=884f77b4222289510e1df9db2889b60c5df6fcda", "patch": "@@ -90,8 +90,10 @@ rtx_vector_builder::find_cached_value ()\n \n   if (GET_MODE_CLASS (m_mode) == MODE_VECTOR_BOOL)\n     {\n-      if (elt == const1_rtx || elt == constm1_rtx)\n+      if (elt == const1_rtx)\n \treturn CONST1_RTX (m_mode);\n+      else if (elt == constm1_rtx)\n+\treturn CONSTM1_RTX (m_mode);\n       else if (elt == const0_rtx)\n \treturn CONST0_RTX (m_mode);\n       else"}, {"sha": "3355b1a07e320cb31d62c42afe0512f75ea3447d", "filename": "gcc/simplify-rtx.cc", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/884f77b4222289510e1df9db2889b60c5df6fcda/gcc%2Fsimplify-rtx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/884f77b4222289510e1df9db2889b60c5df6fcda/gcc%2Fsimplify-rtx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.cc?ref=884f77b4222289510e1df9db2889b60c5df6fcda", "patch": "@@ -6876,12 +6876,13 @@ native_encode_rtx (machine_mode mode, rtx x, vec<target_unit> &bytes,\n \t  /* This is the only case in which elements can be smaller than\n \t     a byte.  */\n \t  gcc_assert (GET_MODE_CLASS (mode) == MODE_VECTOR_BOOL);\n+\t  auto mask = GET_MODE_MASK (GET_MODE_INNER (mode));\n \t  for (unsigned int i = 0; i < num_bytes; ++i)\n \t    {\n \t      target_unit value = 0;\n \t      for (unsigned int j = 0; j < BITS_PER_UNIT; j += elt_bits)\n \t\t{\n-\t\t  value |= (INTVAL (CONST_VECTOR_ELT (x, elt)) & 1) << j;\n+\t\t  value |= (INTVAL (CONST_VECTOR_ELT (x, elt)) & mask) << j;\n \t\t  elt += 1;\n \t\t}\n \t      bytes.quick_push (value);\n@@ -7025,9 +7026,8 @@ native_decode_vector_rtx (machine_mode mode, const vec<target_unit> &bytes,\n \t  unsigned int bit_index = first_byte * BITS_PER_UNIT + i * elt_bits;\n \t  unsigned int byte_index = bit_index / BITS_PER_UNIT;\n \t  unsigned int lsb = bit_index % BITS_PER_UNIT;\n-\t  builder.quick_push (bytes[byte_index] & (1 << lsb)\n-\t\t\t      ? CONST1_RTX (BImode)\n-\t\t\t      : CONST0_RTX (BImode));\n+\t  unsigned int value = bytes[byte_index] >> lsb;\n+\t  builder.quick_push (gen_int_mode (value, GET_MODE_INNER (mode)));\n \t}\n     }\n   else\n@@ -7994,17 +7994,23 @@ test_vector_ops_duplicate (machine_mode mode, rtx scalar_reg)\n \t\t\t\t\t\t    duplicate, last_par));\n \n       /* Test a scalar subreg of a VEC_MERGE of a VEC_DUPLICATE.  */\n-      rtx vector_reg = make_test_reg (mode);\n-      for (unsigned HOST_WIDE_INT i = 0; i < const_nunits; i++)\n+      /* Skip this test for vectors of booleans, because offset is in bytes,\n+\t while vec_merge indices are in elements (usually bits).  */\n+      if (GET_MODE_CLASS (mode) != MODE_VECTOR_BOOL)\n \t{\n-\t  if (i >= HOST_BITS_PER_WIDE_INT)\n-\t    break;\n-\t  rtx mask = GEN_INT ((HOST_WIDE_INT_1U << i) | (i + 1));\n-\t  rtx vm = gen_rtx_VEC_MERGE (mode, duplicate, vector_reg, mask);\n-\t  poly_uint64 offset = i * GET_MODE_SIZE (inner_mode);\n-\t  ASSERT_RTX_EQ (scalar_reg,\n-\t\t\t simplify_gen_subreg (inner_mode, vm,\n-\t\t\t\t\t      mode, offset));\n+\t  rtx vector_reg = make_test_reg (mode);\n+\t  for (unsigned HOST_WIDE_INT i = 0; i < const_nunits; i++)\n+\t    {\n+\t      if (i >= HOST_BITS_PER_WIDE_INT)\n+\t\tbreak;\n+\t      rtx mask = GEN_INT ((HOST_WIDE_INT_1U << i) | (i + 1));\n+\t      rtx vm = gen_rtx_VEC_MERGE (mode, duplicate, vector_reg, mask);\n+\t      poly_uint64 offset = i * GET_MODE_SIZE (inner_mode);\n+\n+\t      ASSERT_RTX_EQ (scalar_reg,\n+\t\t\t     simplify_gen_subreg (inner_mode, vm,\n+\t\t\t\t\t\t  mode, offset));\n+\t    }\n \t}\n     }\n "}, {"sha": "d3d9daffb5d9b14dcd0cd2379a01f65a86ab8e79", "filename": "gcc/varasm.cc", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/884f77b4222289510e1df9db2889b60c5df6fcda/gcc%2Fvarasm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/884f77b4222289510e1df9db2889b60c5df6fcda/gcc%2Fvarasm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.cc?ref=884f77b4222289510e1df9db2889b60c5df6fcda", "patch": "@@ -4085,6 +4085,7 @@ output_constant_pool_2 (fixed_size_mode mode, rtx x, unsigned int align)\n \tunsigned int elt_bits = GET_MODE_BITSIZE (mode) / nelts;\n \tunsigned int int_bits = MAX (elt_bits, BITS_PER_UNIT);\n \tscalar_int_mode int_mode = int_mode_for_size (int_bits, 0).require ();\n+\tunsigned int mask = GET_MODE_MASK (GET_MODE_INNER (mode));\n \n \t/* Build the constant up one integer at a time.  */\n \tunsigned int elts_per_int = int_bits / elt_bits;\n@@ -4093,8 +4094,10 @@ output_constant_pool_2 (fixed_size_mode mode, rtx x, unsigned int align)\n \t    unsigned HOST_WIDE_INT value = 0;\n \t    unsigned int limit = MIN (nelts - i, elts_per_int);\n \t    for (unsigned int j = 0; j < limit; ++j)\n-\t      if (INTVAL (CONST_VECTOR_ELT (x, i + j)) != 0)\n-\t\tvalue |= 1 << (j * elt_bits);\n+\t    {\n+\t      auto elt = INTVAL (CONST_VECTOR_ELT (x, i + j));\n+\t      value |= (elt & mask) << (j * elt_bits);\n+\t    }\n \t    output_constant_pool_2 (int_mode, gen_int_mode (value, int_mode),\n \t\t\t\t    i != 0 ? MIN (align, int_bits) : align);\n \t  }"}]}