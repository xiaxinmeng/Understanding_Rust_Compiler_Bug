{"sha": "2414e0e2839a136fb9d20114cae95dcd19746532", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQxNGUwZTI4MzlhMTM2ZmI5ZDIwMTE0Y2FlOTVkY2QxOTc0NjUzMg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-07-24T17:04:34Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-07-24T17:04:34Z"}, "message": "pa.c (move_operand): Relax \"mode\" test.\n\nWed Jul 24 10:53:38 1996  Jeffrey A Law  (law@cygnus.com)\n\n        * pa/pa.c (move_operand): Relax \"mode\" test.  Allow scaled\n        indexed addressing modes.\n        (output_fp_move_double): Tweak output strings to work with updated\n        'F' and 'M' output modifiers.\n        (print_operand): Collapse 'F' and 'M' into a single hunk of code.\n        For auto-increment modes output \"s,ma\" and \"s,mb\".\n        For scaled indexing modes output \"x,s\"\n        For other addresses, output nothing for 'M' and \"s\" for 'F'.\n        * pa.h (EXTRA_CONSTRAINT): Don't accept scaled indexed addresses\n        for 'Q' and 'T'.  Do accept scaled indexed addresses for 'R'.\n        (GO_IF_LEGITIMATE_ADDRESS): Accept scaled indexed addresses\n        for SFmode and DFmode.\n        * pa.md: Remove all scaled indexed load patterns.\n        (movsi patterns): Accept scaled indexed addresses in some\n        cases.  Update output strings for updated 'M' and 'F' output modifiers.\n        (movhi, movqi, movsf, movdf, movdi patterns): Likewise.\n\nFrom-SVN: r12558", "tree": {"sha": "f81d4e7d4523460d0d953e38ee803be1b5b2ef39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f81d4e7d4523460d0d953e38ee803be1b5b2ef39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2414e0e2839a136fb9d20114cae95dcd19746532", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2414e0e2839a136fb9d20114cae95dcd19746532", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2414e0e2839a136fb9d20114cae95dcd19746532", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2414e0e2839a136fb9d20114cae95dcd19746532/comments", "author": null, "committer": null, "parents": [{"sha": "2cf55b555477592869c388a1404e98dd28fe81dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cf55b555477592869c388a1404e98dd28fe81dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cf55b555477592869c388a1404e98dd28fe81dc"}], "stats": {"total": 381, "additions": 79, "deletions": 302}, "files": [{"sha": "cc0dd71a67984572a4faa219d22b0f503d20d085", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 39, "deletions": 19, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2414e0e2839a136fb9d20114cae95dcd19746532/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2414e0e2839a136fb9d20114cae95dcd19746532/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=2414e0e2839a136fb9d20114cae95dcd19746532", "patch": "@@ -270,8 +270,6 @@ move_operand (op, mode)\n   if (GET_CODE (op) == CONST_INT)\n     return cint_ok_for_move (INTVAL (op));\n \n-  if (GET_MODE (op) != mode)\n-    return 0;\n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n   if (GET_CODE (op) != MEM)\n@@ -281,6 +279,22 @@ move_operand (op, mode)\n   if (GET_CODE (op) == LO_SUM)\n     return (register_operand (XEXP (op, 0), Pmode)\n \t    && CONSTANT_P (XEXP (op, 1)));\n+\n+  /* Since move_operand is only used for source operands, we can always\n+     allow scaled indexing!  */\n+  if (GET_CODE (op) == PLUS\n+      && ((GET_CODE (XEXP (op, 0)) == MULT\n+\t   && GET_CODE (XEXP (XEXP (op, 0), 0)) == REG\n+\t   && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT\n+\t   && INTVAL (XEXP (XEXP (op, 0), 1)) == GET_MODE_SIZE (mode)\n+\t   && GET_CODE (XEXP (op, 1)) == REG)\n+\t  || (GET_CODE (XEXP (op, 1)) == MULT\n+\t      &&GET_CODE (XEXP (XEXP (op, 1), 0)) == REG\n+\t      && GET_CODE (XEXP (XEXP (op, 1), 1)) == CONST_INT\n+\t      && INTVAL (XEXP (XEXP (op, 1), 1)) == GET_MODE_SIZE (mode)\n+\t      && GET_CODE (XEXP (op, 0)) == REG)))\n+    return 1;\n+\n   return memory_address_p (mode, op);\n }\n \n@@ -1610,11 +1624,11 @@ output_fp_move_double (operands)\n \t  || operands[1] == CONST0_RTX (GET_MODE (operands[0])))\n \toutput_asm_insn (\"fcpy,dbl %r1,%0\", operands);\n       else\n-\toutput_asm_insn (\"fldds%F1 %1,%0\", operands);\n+\toutput_asm_insn (\"fldd%F1 %1,%0\", operands);\n     }\n   else if (FP_REG_P (operands[1]))\n     {\n-      output_asm_insn (\"fstds%F0 %1,%0\", operands);\n+      output_asm_insn (\"fstd%F0 %1,%0\", operands);\n     }\n   else if (operands[1] == CONST0_RTX (GET_MODE (operands[0])))\n     {\n@@ -3324,6 +3338,7 @@ print_operand (file, x, code)\n \tfputs (\"i\", file);\n       return;\n     case 'M':\n+    case 'F':\n       switch (GET_CODE (XEXP (x, 0)))\n \t{\n \tcase PRE_DEC:\n@@ -3334,22 +3349,16 @@ print_operand (file, x, code)\n \tcase POST_INC:\n \t  fputs (\"s,ma\", file);\n \t  break;\n-\tdefault:\n-\t  break;\n-\t}\n-      return;\n-    case 'F':\n-      switch (GET_CODE (XEXP (x, 0)))\n-\t{\n-\tcase PRE_DEC:\n-\tcase PRE_INC:\n-\t  fputs (\",mb\", file);\n-\t  break;\n-\tcase POST_DEC:\n-\tcase POST_INC:\n-\t  fputs (\",ma\", file);\n+\tcase PLUS:\n+\t  if (GET_CODE (XEXP (XEXP (x, 0), 0)) == MULT\n+\t      || GET_CODE (XEXP (XEXP (x, 0), 1)) == MULT)\n+\t    fputs (\"x,s\", file);\n+\t  else if (code == 'F')\n+\t    fputs (\"s\", file);\n \t  break;\n \tdefault:\n+\t  if (code == 'F')\n+\t    fputs (\"s\", file);\n \t  break;\n \t}\n       return;\n@@ -3392,7 +3401,18 @@ print_operand (file, x, code)\n \t  fprintf (file, \"%d(0,%s)\", size, reg_names [REGNO (base)]);\n \t  break;\n \tdefault:\n-\t  output_address (XEXP (x, 0));\n+\t  if (GET_CODE (XEXP (x, 0)) == PLUS\n+\t      && GET_CODE (XEXP (XEXP (x, 0), 0)) == MULT)\n+\t    fprintf (file, \"%s(0,%s)\",\n+\t\t     reg_names [REGNO (XEXP (XEXP (XEXP (x, 0), 0), 0))],\n+\t\t     reg_names [REGNO (XEXP (XEXP (x, 0), 1))]);\n+\t  else if (GET_CODE (XEXP (x, 0)) == PLUS\n+\t\t   && GET_CODE (XEXP (XEXP (x, 0), 1)) == MULT)\n+\t    fprintf (file, \"%s(0,%s)\",\n+\t\t     reg_names [REGNO (XEXP (XEXP (XEXP (x, 0), 1), 0))],\n+\t\t     reg_names [REGNO (XEXP (XEXP (x, 0), 0))]);\n+\t  else\n+\t    output_address (XEXP (x, 0));\n \t  break;\n \t}\n     }"}, {"sha": "ac03586b7c1e7944e2bb452513c6563627d140ee", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2414e0e2839a136fb9d20114cae95dcd19746532/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2414e0e2839a136fb9d20114cae95dcd19746532/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=2414e0e2839a136fb9d20114cae95dcd19746532", "patch": "@@ -1362,12 +1362,25 @@ extern struct rtx_def *hppa_builtin_saveregs ();\n    (IS_RELOADING_PSEUDO_P (OP)\t\t\t\t\\\n     || (GET_CODE (OP) == MEM\t\t\t\t\\\n \t&& memory_address_p (GET_MODE (OP), XEXP (OP, 0))\\\n-\t&& ! symbolic_memory_operand (OP, VOIDmode)))\t\\\n+\t&& ! symbolic_memory_operand (OP, VOIDmode)\t\\\n+        && !(GET_CODE (XEXP (OP, 0)) == PLUS\t\t\\\n+\t     && (GET_CODE (XEXP (XEXP (OP, 0), 0)) == MULT\\\n+\t\t || GET_CODE (XEXP (XEXP (OP, 0), 1)) == MULT))))\\\n+   : ((C) == 'R' ?\t\t\t\t\t\\\n+     (GET_CODE (OP) == MEM\t\t\t\t\\\n+      && GET_CODE (XEXP (OP, 0)) == PLUS\t\t\\\n+      && (GET_CODE (XEXP (XEXP (OP, 0), 0)) == MULT\t\\\n+\t  || GET_CODE (XEXP (XEXP (OP, 0), 1)) == MULT)\t\\\n+      && (move_operand (OP, GET_MODE (OP))\t\t\\\n+\t  || memory_address_p (GET_MODE (OP), XEXP (OP, 0))))\\\n    : ((C) == 'T' ? \t\t\t\t\t\\\n       (GET_CODE (OP) == MEM\t\t\t\t\\\n        /* Using DFmode forces only short displacements\t\\\n \t  to be recognized as valid in reg+d addresses.  */\\\n-       && memory_address_p (DFmode, XEXP (OP, 0))) : 0))\n+       && memory_address_p (DFmode, XEXP (OP, 0))\t\\\n+       && !(GET_CODE (XEXP (OP, 0)) == PLUS\t\t\\\n+\t    && (GET_CODE (XEXP (XEXP (OP, 0), 0)) == MULT\\\n+\t\t|| GET_CODE (XEXP (XEXP (OP, 0), 1)) == MULT))) : 0)))\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n@@ -1462,6 +1475,15 @@ extern struct rtx_def *hppa_builtin_saveregs ();\n \t\t     || ((MODE) != SFmode && (MODE) != DFmode))) \\\n \t\t|| INT_5_BITS (index)))\t\t\t\\\n \t  goto ADDR;\t\t\t\t\t\\\n+      if (base\t\t\t\t\t\t\\\n+\t  && (mode == SFmode || mode == DFmode)\t\t\\\n+\t  && GET_CODE (index) == MULT\t\t\t\\\n+\t  && GET_CODE (XEXP (index, 0)) == REG\t\t\\\n+\t  && REG_OK_FOR_BASE_P (XEXP (index, 0))\t\\\n+\t  && GET_CODE (XEXP (index, 1)) == CONST_INT\t\\\n+\t  && INTVAL (XEXP (index, 1)) == (mode == SFmode ? 4 : 8)\\\n+\t  && shadd_operand (XEXP (index, 1), VOIDmode)) \\\n+\tgoto ADDR;\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\\\n   else if (GET_CODE (X) == LO_SUM\t\t\t\\\n \t   && GET_CODE (XEXP (X, 0)) == REG\t\t\\"}, {"sha": "2890be1ece410ac07ef4486a1fdf6c97fce65d6d", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 16, "deletions": 281, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2414e0e2839a136fb9d20114cae95dcd19746532/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2414e0e2839a136fb9d20114cae95dcd19746532/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=2414e0e2839a136fb9d20114cae95dcd19746532", "patch": "@@ -1449,7 +1449,7 @@\n   [(set (match_operand:SI 0 \"reg_or_nonsymb_mem_operand\"\n \t\t\t\t\"=r,r,r,r,r,Q,*q,!f,f,*T\")\n \t(match_operand:SI 1 \"move_operand\"\n-\t\t\t\t\"r,J,N,K,Q,rM,rM,!fM,*T,f\"))]\n+\t\t\t\t\"r,J,N,K,RQ,rM,rM,!fM,*RT,f\"))]\n   \"(register_operand (operands[0], SImode)\n     || reg_or_0_operand (operands[1], SImode))\n    && ! TARGET_SOFT_FLOAT\"\n@@ -1462,16 +1462,16 @@\n    stw%M0 %r1,%0\n    mtsar %r1\n    fcpy,sgl %r1,%0\n-   fldws%F1 %1,%0\n-   fstws%F0 %1,%0\"\n+   fldw%F1 %1,%0\n+   fstw%F0 %1,%0\"\n   [(set_attr \"type\" \"move,move,move,shift,load,store,move,fpalu,fpload,fpstore\")\n    (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,4\")])\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"reg_or_nonsymb_mem_operand\"\n \t\t\t\t\"=r,r,r,r,r,Q,*q\")\n \t(match_operand:SI 1 \"move_operand\"\n-\t\t\t\t\"r,J,N,K,Q,rM,rM\"))]\n+\t\t\t\t\"r,J,N,K,RQ,rM,rM\"))]\n   \"(register_operand (operands[0], SImode)\n     || reg_or_0_operand (operands[1], SImode))\n    && TARGET_SOFT_FLOAT\"\n@@ -1486,47 +1486,6 @@\n   [(set_attr \"type\" \"move,move,move,move,load,store,move\")\n    (set_attr \"length\" \"4,4,4,4,4,4,4\")])\n \n-;; Load indexed.  We don't use unscaled modes since they can't be used\n-;; unless we can tell which of the registers is the base and which is\n-;; the index, due to PA's idea of segment selection using the top bits\n-;; of the base register.\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(mem:SI (plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t\t  (const_int 4))\n-\t\t\t (match_operand:SI 2 \"register_operand\" \"r\"))))]\n-  \"! TARGET_DISABLE_INDEXING\"\n-  \"ldwx,s %1(0,%2),%0\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"length\" \"4\")])\n-\n-;; This variant of the above insn can occur if the second operand\n-;; is the frame pointer.  This is a kludge, but there doesn't\n-;; seem to be a way around it.  Only recognize it while reloading.\n-;; Note how operand 3 uses a predicate of \"const_int_operand\", but \n-;; has constraints allowing a register.  I don't know how this works,\n-;; but it somehow makes sure that out-of-range constants are placed\n-;; in a register which somehow magically is a \"const_int_operand\".\n-;; (this was stolen from alpha.md, I'm not going to try and change it.)\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"&=r\")\n-\t(mem:SI (plus:SI (plus:SI\n-\t\t\t    (mult:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t\t     (const_int 4))\n-\t\t\t    (match_operand:SI 2 \"register_operand\" \"r\"))\n-\t\t\t (match_operand:SI 3 \"const_int_operand\" \"rI\"))))]\n-  \"! TARGET_DISABLE_INDEXING && reload_in_progress\"\n-  \"*\n-{\n-  if (GET_CODE (operands[3]) == CONST_INT)\n-    return \\\"sh2addl %1,%2,%0\\;ldw %3(0,%0),%0\\\";\n-  else\n-    return \\\"sh2addl %1,%2,%0\\;ldwx %3(0,%0),%0\\\";\n-}\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"length\" \"8\")])\n-\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(mem:SI (plus:SI (match_operand:SI 1 \"basereg_operand\" \"r\")\n@@ -1845,7 +1804,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,r,r,r,Q,*q,!f\")\n-\t(match_operand:HI 1 \"move_operand\" \"r,J,N,K,Q,rM,rM,!fM\"))]\n+\t(match_operand:HI 1 \"move_operand\" \"r,J,N,K,RQ,rM,rM,!fM\"))]\n   \"register_operand (operands[0], HImode)\n    || reg_or_0_operand (operands[1], HImode)\"\n   \"@\n@@ -1860,74 +1819,6 @@\n   [(set_attr \"type\" \"move,move,move,shift,load,store,move,fpalu\")\n    (set_attr \"length\" \"4,4,4,4,4,4,4,4\")])\n \n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(mem:HI (plus:SI (mult:SI (match_operand:SI 2 \"register_operand\" \"r\")\n-\t\t\t\t  (const_int 2))\n-\t\t\t (match_operand:SI 1 \"register_operand\" \"r\"))))]\n-  \"! TARGET_DISABLE_INDEXING\"\n-  \"ldhx,s %2(0,%1),%0\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"length\" \"4\")])\n-\n-; Same thing with zero extension.\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:SI (mem:HI\n-\t\t\t  (plus:SI\n-\t\t\t    (mult:SI (match_operand:SI 2 \"register_operand\" \"r\")\n-\t\t\t\t     (const_int 2))\n-\t\t\t (match_operand:SI 1 \"register_operand\" \"r\")))))]\n-  \"! TARGET_DISABLE_INDEXING\"\n-  \"ldhx,s %2(0,%1),%0\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"length\" \"4\")])\n-\n-;; These variants of the above insns can occur if the second operand\n-;; is the frame pointer.  This is a kludge, but there doesn't\n-;; seem to be a way around it.  Only recognize it while reloading.\n-;; Note how operand 3 uses a predicate of \"const_int_operand\", but \n-;; has constraints allowing a register.  I don't know how this works,\n-;; but it somehow makes sure that out-of-range constants are placed\n-;; in a register which somehow magically is a \"const_int_operand\".\n-;; (this was stolen from alpha.md, I'm not going to try and change it.\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=&r\")\n-\t(mem:HI (plus:SI (plus:SI\n-\t\t\t    (mult:SI (match_operand:SI 2 \"register_operand\" \"r\")\n-\t\t\t\t     (const_int 2))\n-\t\t\t    (match_operand:SI 1 \"register_operand\" \"r\"))\n-\t\t\t (match_operand:SI 3 \"const_int_operand\" \"rI\"))))]\n-  \"! TARGET_DISABLE_INDEXING && reload_in_progress\"\n-  \"*\n-{\n-  if (GET_CODE (operands[3]) == CONST_INT)\n-    return \\\"sh1addl %2,%1,%0\\;ldh %3(0,%0),%0\\\";\n-  else\n-    return \\\"sh1addl %2,%1,%0\\;ldhx %3(0,%0),%0\\\";\n-}\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"length\" \"8\")])\n-\n-; Now the zero extended variant.\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n-\t(zero_extend:SI (mem:HI (plus:SI (plus:SI\n-\t\t\t    (mult:SI (match_operand:SI 2 \"register_operand\" \"r\")\n-\t\t\t\t     (const_int 2))\n-\t\t\t    (match_operand:SI 1 \"register_operand\" \"r\"))\n-\t\t\t (match_operand:SI 3 \"const_int_operand\" \"rI\")))))]\n-  \"! TARGET_DISABLE_INDEXING && reload_in_progress\"\n-  \"*\n-{\n-  if (GET_CODE (operands[3]) == CONST_INT)\n-    return \\\"sh1addl %2,%1,%0\\;ldh %3(0,%0),%0\\\";\n-  else\n-    return \\\"sh1addl %2,%1,%0\\;ldhx %3(0,%0),%0\\\";\n-}\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"length\" \"8\")])\n-\n (define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(mem:HI (plus:SI (match_operand:SI 1 \"basereg_operand\" \"r\")\n@@ -2074,7 +1965,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:QI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,r,r,r,Q,*q,!f\")\n-\t(match_operand:QI 1 \"move_operand\" \"r,J,N,K,Q,rM,rM,!fM\"))]\n+\t(match_operand:QI 1 \"move_operand\" \"r,J,N,K,RQ,rM,rM,!fM\"))]\n   \"register_operand (operands[0], QImode)\n    || reg_or_0_operand (operands[1], QImode)\"\n   \"@\n@@ -2360,7 +2251,7 @@\n    && operands[1] != CONST0_RTX (DFmode)\n    && ! TARGET_SOFT_FLOAT\"\n   \"* return (which_alternative == 0 ? output_move_double (operands)\n-\t\t\t\t    : \\\"fldds%F1 %1,%0\\\");\"\n+\t\t\t\t    : \\\"fldd%F1 %1,%0\\\");\"\n   [(set_attr \"type\" \"move,fpload\")\n    (set_attr \"length\" \"16,4\")])\n \n@@ -2409,9 +2300,9 @@\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"reg_or_nonsymb_mem_operand\"\n-\t\t\t  \"=f,*r,Q,?o,?Q,f,*r,*r\")\n+\t\t\t  \"=f,*r,RQ,?o,?Q,f,*r,*r\")\n \t(match_operand:DF 1 \"reg_or_0_or_nonsymb_mem_operand\"\n-\t\t\t  \"fG,*rG,f,*r,*r,Q,o,Q\"))]\n+\t\t\t  \"fG,*rG,f,*r,*r,RQ,o,Q\"))]\n   \"(register_operand (operands[0], DFmode)\n     || reg_or_0_operand (operands[1], DFmode))\n    && ! TARGET_SOFT_FLOAT\"\n@@ -2440,45 +2331,6 @@\n   [(set_attr \"type\" \"move,store,store,load,load\")\n    (set_attr \"length\" \"8,8,16,8,16\")])\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(mem:DF (plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t\t  (const_int 8))\n-\t\t\t (match_operand:SI 2 \"register_operand\" \"r\"))))]\n-  \"! TARGET_DISABLE_INDEXING && ! TARGET_SOFT_FLOAT\"\n-  \"flddx,s %1(0,%2),%0\"\n-  [(set_attr \"type\" \"fpload\")\n-   (set_attr \"length\" \"4\")])\n-\n-;; This variant of the above insn can occur if the second operand\n-;; is the frame pointer.  This is a kludge, but there doesn't\n-;; seem to be a way around it.  Only recognize it while reloading.\n-;; Note how operand 3 uses a predicate of \"const_int_operand\", but \n-;; has constraints allowing a register.  I don't know how this works,\n-;; but it somehow makes sure that out-of-range constants are placed\n-;; in a register which somehow magically is a \"const_int_operand\".\n-;; (this was stolen from alpha.md, I'm not going to try and change it.\n-;; Ugh. Output is a FP register; so we need to earlyclobber something\n-;; else as a temporary.\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(mem:DF (plus:SI\n-\t\t  (plus:SI\n-\t\t    (mult:SI (match_operand:SI 1 \"register_operand\" \"+&r\")\n-\t\t\t     (const_int 8))\n-\t\t    (match_operand:SI 2 \"register_operand\" \"r\"))\n-\t\t  (match_operand:SI 3 \"const_int_operand\" \"rL\"))))]\n-  \"! TARGET_DISABLE_INDEXING && ! TARGET_SOFT_FLOAT && reload_in_progress\"\n-  \"*\n-{\n-  if (GET_CODE (operands[3]) == CONST_INT)\n-    return \\\"sh3addl %1,%2,%1\\;fldds %3(0,%1),%0\\\";\n-  else\n-    return \\\"sh3addl %1,%2,%1\\;flddx %3(0,%1),%0\\\";\n-}\"\n-  [(set_attr \"type\" \"fpload\")\n-   (set_attr \"length\" \"8\")])\n-\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=fx\")\n \t(mem:DF (plus:SI (match_operand:SI 1 \"basereg_operand\" \"r\")\n@@ -2517,45 +2369,6 @@\n   [(set_attr \"type\" \"fpload\")\n    (set_attr \"length\" \"4\")])\n \n-(define_insn \"\"\n-  [(set (mem:DF (plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t\t  (const_int 8))\n-\t\t\t (match_operand:SI 2 \"register_operand\" \"r\")))\n-\t(match_operand:DF 0 \"register_operand\" \"f\"))]\n-  \"! TARGET_DISABLE_INDEXING && ! TARGET_SOFT_FLOAT\"\n-  \"fstdx,s %0,%1(0,%2)\"\n-  [(set_attr \"type\" \"fpstore\")\n-   (set_attr \"length\" \"4\")])\n-\n-;; This variant of the above insn can occur if the second operand\n-;; is the frame pointer.  This is a kludge, but there doesn't\n-;; seem to be a way around it.  Only recognize it while reloading.\n-;; Note how operand 3 uses a predicate of \"const_int_operand\", but \n-;; has constraints allowing a register.  I don't know how this works,\n-;; but it somehow makes sure that out-of-range constants are placed\n-;; in a register which somehow magically is a \"const_int_operand\".\n-;; (this was stolen from alpha.md, I'm not going to try and change it.\n-;; Ugh. Output is a FP register; so we need to earlyclobber something\n-;; else as a temporary.\n-(define_insn \"\"\n-  [(set (mem:DF (plus:SI\n-\t\t  (plus:SI\n-\t\t     (mult:SI (match_operand:SI 1 \"register_operand\" \"+&r\")\n-\t\t\t      (const_int 8))\n-\t\t     (match_operand:SI 2 \"register_operand\" \"r\"))\n-\t\t  (match_operand:SI 3 \"const_int_operand\" \"rL\")))\n-\t(match_operand:DF 0 \"register_operand\" \"f\"))]\n-  \"! TARGET_DISABLE_INDEXING && ! TARGET_SOFT_FLOAT && reload_in_progress\"\n-  \"*\n-{\n-  if (GET_CODE (operands[3]) == CONST_INT)\n-    return \\\"sh3addl %1,%2,%1\\;fstds %0,%3(0,%1)\\\";\n-  else\n-    return \\\"sh3addl %1,%2,%1\\;fstdx %0,%3(0,%1)\\\";\n-}\"\n-  [(set_attr \"type\" \"fpstore\")\n-   (set_attr \"length\" \"8\")])\n-\n (define_insn \"\"\n   [(set (mem:DF (plus:SI (match_operand:SI 1 \"basereg_operand\" \"r\")\n \t\t\t (match_operand:SI 2 \"register_operand\" \"r\")))\n@@ -2741,7 +2554,7 @@\n    && operands[1] != CONST0_RTX (SFmode)\n    && ! TARGET_SOFT_FLOAT\"\n   \"* return (which_alternative == 0 ? singlemove_string (operands)\n-\t\t\t\t    : \\\" fldws%F1 %1,%0\\\");\"\n+\t\t\t\t    : \\\" fldw%F1 %1,%0\\\");\"\n   [(set_attr \"type\" \"move,fpload\")\n    (set_attr \"length\" \"8,4\")])\n \n@@ -2790,18 +2603,18 @@\n \n (define_insn \"\"\n   [(set (match_operand:SF 0 \"reg_or_nonsymb_mem_operand\"\n-\t\t\t  \"=f,r,f,r,Q,Q\")\n+\t\t\t  \"=f,r,f,r,RQ,Q\")\n \t(match_operand:SF 1 \"reg_or_0_or_nonsymb_mem_operand\"\n-\t\t\t  \"fG,rG,Q,Q,f,rG\"))]\n+\t\t\t  \"fG,rG,RQ,Q,f,rG\"))]\n   \"(register_operand (operands[0], SFmode)\n     || reg_or_0_operand (operands[1], SFmode))\n    && ! TARGET_SOFT_FLOAT\"\n   \"@\n    fcpy,sgl %r1,%0\n    copy %r1,%0\n-   fldws%F1 %1,%0\n+   fldw%F1 %1,%0\n    ldw%M1 %1,%0\n-   fstws%F0 %r1,%0\n+   fstw%F0 %r1,%0\n    stw%M0 %r1,%0\"\n   [(set_attr \"type\" \"fpalu,move,fpload,load,fpstore,store\")\n    (set_attr \"length\" \"4,4,4,4,4,4\")])\n@@ -2821,45 +2634,6 @@\n   [(set_attr \"type\" \"move,load,store\")\n    (set_attr \"length\" \"4,4,4\")])\n \n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(mem:SF (plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t\t  (const_int 4))\n-\t\t\t (match_operand:SI 2 \"register_operand\" \"r\"))))]\n-  \"! TARGET_DISABLE_INDEXING && ! TARGET_SOFT_FLOAT\"\n-  \"fldwx,s %1(0,%2),%0\"\n-  [(set_attr \"type\" \"fpload\")\n-   (set_attr \"length\" \"4\")])\n-\n-;; This variant of the above insn can occur if the second operand\n-;; is the frame pointer.  This is a kludge, but there doesn't\n-;; seem to be a way around it.  Only recognize it while reloading.\n-;; Note how operand 3 uses a predicate of \"const_int_operand\", but \n-;; has constraints allowing a register.  I don't know how this works,\n-;; but it somehow makes sure that out-of-range constants are placed\n-;; in a register which somehow magically is a \"const_int_operand\".\n-;; (this was stolen from alpha.md, I'm not going to try and change it.\n-;; Ugh. Output is a FP register; so we need to earlyclobber something\n-;; else as a temporary.\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(mem:SF (plus:SI\n-\t\t  (plus:SI\n-\t\t    (mult:SI (match_operand:SI 1 \"register_operand\" \"+&r\")\n-\t\t\t     (const_int 4))\n-\t\t    (match_operand:SI 2 \"register_operand\" \"r\"))\n-\t\t  (match_operand:SI 3 \"const_int_operand\" \"rL\"))))]\n-  \"! TARGET_DISABLE_INDEXING && ! TARGET_SOFT_FLOAT && reload_in_progress\"\n-  \"*\n-{\n-  if (GET_CODE (operands[3]) == CONST_INT)\n-    return \\\"sh2addl %1,%2,%1\\;fldws %3(0,%1),%0\\\";\n-  else\n-    return \\\"sh2addl %1,%2,%1\\;fldwx %3(0,%1),%0\\\";\n-}\"\n-  [(set_attr \"type\" \"fpload\")\n-   (set_attr \"length\" \"8\")])\n-\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=fx\")\n \t(mem:SF (plus:SI (match_operand:SI 1 \"basereg_operand\" \"r\")\n@@ -2898,45 +2672,6 @@\n   [(set_attr \"type\" \"fpload\")\n    (set_attr \"length\" \"4\")])\n \n-(define_insn \"\"\n-  [(set (mem:SF (plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t\t  (const_int 4))\n-\t\t\t (match_operand:SI 2 \"register_operand\" \"r\")))\n-\t(match_operand:SF 0 \"register_operand\" \"f\"))]\n-  \"! TARGET_DISABLE_INDEXING && ! TARGET_SOFT_FLOAT\"\n-  \"fstwx,s %0,%1(0,%2)\"\n-  [(set_attr \"type\" \"fpstore\")\n-   (set_attr \"length\" \"4\")])\n-\n-;; This variant of the above insn can occur if the second operand\n-;; is the frame pointer.  This is a kludge, but there doesn't\n-;; seem to be a way around it.  Only recognize it while reloading.\n-;; Note how operand 3 uses a predicate of \"const_int_operand\", but \n-;; has constraints allowing a register.  I don't know how this works,\n-;; but it somehow makes sure that out-of-range constants are placed\n-;; in a register which somehow magically is a \"const_int_operand\".\n-;; (this was stolen from alpha.md, I'm not going to try and change it.\n-;; Ugh. Output is a FP register; so we need to earlyclobber something\n-;; else as a temporary.\n-(define_insn \"\"\n-  [(set (mem:SF (plus:SI\n-\t\t  (plus:SI\n-\t\t     (mult:SI (match_operand:SI 1 \"register_operand\" \"+&r\")\n-\t\t\t      (const_int 4))\n-\t\t     (match_operand:SI 2 \"register_operand\" \"r\"))\n-\t\t  (match_operand:SI 3 \"const_int_operand\" \"rL\")))\n-\t(match_operand:SF 0 \"register_operand\" \"f\"))]\n-  \"! TARGET_DISABLE_INDEXING && ! TARGET_SOFT_FLOAT && reload_in_progress\"\n-  \"*\n-{\n-  if (GET_CODE (operands[3]) == CONST_INT)\n-    return \\\"sh2addl %1,%2,%1\\;fstws %0,%3(0,%1)\\\";\n-  else\n-    return \\\"sh2addl %1,%2,%1\\;fstwx %0,%3(0,%1)\\\";\n-}\"\n-  [(set_attr \"type\" \"fpstore\")\n-   (set_attr \"length\" \"8\")])\n-\n (define_insn \"\"\n   [(set (mem:SF (plus:SI (match_operand:SI 1 \"basereg_operand\" \"r\")\n \t\t\t (match_operand:SI 2 \"register_operand\" \"r\")))\n@@ -3072,7 +2807,7 @@\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(float:SF (match_operand:SI 1 \"const_int_operand\" \"m\")))]\n   \"! TARGET_SOFT_FLOAT\"\n-  \"fldws %1,%0\\;fcnvxf,sgl,sgl %0,%0\"\n+  \"fldw%F1 %1,%0\\;fcnvxf,sgl,sgl %0,%0\"\n   [(set_attr \"type\" \"fpalu\")\n    (set_attr \"length\" \"8\")])\n \n@@ -3091,7 +2826,7 @@\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(float:DF (match_operand:SI 1 \"const_int_operand\" \"m\")))]\n   \"! TARGET_SOFT_FLOAT\"\n-  \"fldws %1,%0\\;fcnvxf,sgl,dbl %0,%0\"\n+  \"fldw%F1 %1,%0\\;fcnvxf,sgl,dbl %0,%0\"\n   [(set_attr \"type\" \"fpalu\")\n    (set_attr \"length\" \"8\")])\n "}]}