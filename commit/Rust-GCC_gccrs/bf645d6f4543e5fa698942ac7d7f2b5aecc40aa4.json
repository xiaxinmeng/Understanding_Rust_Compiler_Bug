{"sha": "bf645d6f4543e5fa698942ac7d7f2b5aecc40aa4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY2NDVkNmY0NTQzZTVmYTY5ODk0MmFjN2Q3ZjJiNWFlY2M0MGFhNA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-05-10T01:39:22Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-05-10T01:39:22Z"}, "message": "tree-outof-ssa.c (_elim_graph): Change the type of nodes and const_copies to VEC(tree,heap)*.\n\n\t* tree-outof-ssa.c (_elim_graph): Change the type of nodes and\n\tconst_copies to VEC(tree,heap)*.\n\t(new_elim_graph, delete_elim_graph, elim_graph_size,\n\telim_graph_add_node, eliminate_build, eliminate_phi): Use VEC\n\tinstead of VARRAY.\n\nFrom-SVN: r99497", "tree": {"sha": "29682bf6b02ca3e68944918a9b71dfc385337925", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29682bf6b02ca3e68944918a9b71dfc385337925"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf645d6f4543e5fa698942ac7d7f2b5aecc40aa4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf645d6f4543e5fa698942ac7d7f2b5aecc40aa4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf645d6f4543e5fa698942ac7d7f2b5aecc40aa4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf645d6f4543e5fa698942ac7d7f2b5aecc40aa4/comments", "author": null, "committer": null, "parents": [{"sha": "3f69daa89ac6ae8d9e991ca48fa7a35d4b341b8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f69daa89ac6ae8d9e991ca48fa7a35d4b341b8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f69daa89ac6ae8d9e991ca48fa7a35d4b341b8d"}], "stats": {"total": 49, "additions": 30, "deletions": 19}, "files": [{"sha": "562498fffeae1bab30a79394f8681597476d728b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf645d6f4543e5fa698942ac7d7f2b5aecc40aa4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf645d6f4543e5fa698942ac7d7f2b5aecc40aa4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf645d6f4543e5fa698942ac7d7f2b5aecc40aa4", "patch": "@@ -1,3 +1,11 @@\n+2005-05-10  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* tree-outof-ssa.c (_elim_graph): Change the type of nodes and\n+\tconst_copies to VEC(tree,heap)*.\n+\t(new_elim_graph, delete_elim_graph, elim_graph_size,\n+\telim_graph_add_node, eliminate_build, eliminate_phi): Use VEC\n+\tinstead of VARRAY.\n+\n 2005-05-10  Joseph S. Myers  <joseph@codesourcery.com>\n \n \tPR other/21052"}, {"sha": "ae24275547d1558d8bfaea692eb17c4141e57e7a", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf645d6f4543e5fa698942ac7d7f2b5aecc40aa4/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf645d6f4543e5fa698942ac7d7f2b5aecc40aa4/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=bf645d6f4543e5fa698942ac7d7f2b5aecc40aa4", "patch": "@@ -79,7 +79,7 @@ typedef struct _elim_graph {\n   int size;\n \n   /* List of nodes in the elimination graph.  */\n-  varray_type nodes;\n+  VEC(tree,heap) *nodes;\n \n   /*  The predecessor and successor edge list.  */\n   varray_type edge_list;\n@@ -97,7 +97,7 @@ typedef struct _elim_graph {\n   edge e;\n \n   /* List of constant copies to emit.  These are pushed on in pairs.  */\n-  varray_type  const_copies;\n+  VEC(tree,heap) *const_copies;\n } *elim_graph;\n \n \n@@ -218,8 +218,8 @@ new_elim_graph (int size)\n {\n   elim_graph g = (elim_graph) xmalloc (sizeof (struct _elim_graph));\n \n-  VARRAY_TREE_INIT (g->nodes, 30, \"Elimination Node List\");\n-  VARRAY_TREE_INIT (g->const_copies, 20, \"Elimination Constant Copies\");\n+  g->nodes = VEC_alloc (tree, heap, 30);\n+  g->const_copies = VEC_alloc (tree, heap, 20);\n   VARRAY_INT_INIT (g->edge_list, 20, \"Elimination Edge List\");\n   VARRAY_INT_INIT (g->stack, 30, \" Elimination Stack\");\n   \n@@ -234,7 +234,7 @@ new_elim_graph (int size)\n static inline void\n clear_elim_graph (elim_graph g)\n {\n-  VARRAY_POP_ALL (g->nodes);\n+  VEC_truncate (tree, g->nodes, 0);\n   VARRAY_POP_ALL (g->edge_list);\n }\n \n@@ -245,6 +245,8 @@ static inline void\n delete_elim_graph (elim_graph g)\n {\n   sbitmap_free (g->visited);\n+  VEC_free (tree, heap, g->const_copies);\n+  VEC_free (tree, heap, g->nodes);\n   free (g);\n }\n \n@@ -254,7 +256,7 @@ delete_elim_graph (elim_graph g)\n static inline int\n elim_graph_size (elim_graph g)\n {\n-  return VARRAY_ACTIVE_SIZE (g->nodes);\n+  return VEC_length (tree, g->nodes);\n }\n \n \n@@ -264,10 +266,12 @@ static inline void\n elim_graph_add_node (elim_graph g, tree node)\n {\n   int x;\n-  for (x = 0; x < elim_graph_size (g); x++)\n-    if (VARRAY_TREE (g->nodes, x) == node)\n+  tree t;\n+\n+  for (x = 0; VEC_iterate (tree, g->nodes, x, t); x++)\n+    if (t == node)\n       return;\n-  VARRAY_PUSH_TREE (g->nodes, node);\n+  VEC_safe_push (tree, heap, g->nodes, node);\n }\n \n \n@@ -379,8 +383,8 @@ eliminate_build (elim_graph g, basic_block B)\n         {\n \t  /* Save constant copies until all other copies have been emitted\n \t     on this edge.  */\n-\t  VARRAY_PUSH_TREE (g->const_copies, T0);\n-\t  VARRAY_PUSH_TREE (g->const_copies, Ti);\n+\t  VEC_safe_push (tree, heap, g->const_copies, T0);\n+\t  VEC_safe_push (tree, heap, g->const_copies, Ti);\n \t}\n       else\n         {\n@@ -491,7 +495,7 @@ eliminate_phi (edge e, elim_graph g)\n   int x;\n   basic_block B = e->dest;\n \n-  gcc_assert (VARRAY_ACTIVE_SIZE (g->const_copies) == 0);\n+  gcc_assert (VEC_length (tree, g->const_copies) == 0);\n \n   /* Abnormal edges already have everything coalesced.  */\n   if (e->flags & EDGE_ABNORMAL)\n@@ -503,12 +507,13 @@ eliminate_phi (edge e, elim_graph g)\n \n   if (elim_graph_size (g) != 0)\n     {\n+      tree var;\n+\n       sbitmap_zero (g->visited);\n       VARRAY_POP_ALL (g->stack);\n \n-      for (x = 0; x < elim_graph_size (g); x++)\n+      for (x = 0; VEC_iterate (tree, g->nodes, x, var); x++)\n         {\n-\t  tree var = VARRAY_TREE (g->nodes, x);\n \t  int p = var_to_partition (g->map, var);\n \t  if (!TEST_BIT (g->visited, p))\n \t    elim_forward (g, p);\n@@ -525,13 +530,11 @@ eliminate_phi (edge e, elim_graph g)\n     }\n \n   /* If there are any pending constant copies, issue them now.  */\n-  while (VARRAY_ACTIVE_SIZE (g->const_copies) > 0)\n+  while (VEC_length (tree, g->const_copies) > 0)\n     {\n       tree src, dest;\n-      src = VARRAY_TOP_TREE (g->const_copies);\n-      VARRAY_POP (g->const_copies);\n-      dest = VARRAY_TOP_TREE (g->const_copies);\n-      VARRAY_POP (g->const_copies);\n+      src = VEC_pop (tree, g->const_copies);\n+      dest = VEC_pop (tree, g->const_copies);\n       insert_copy_on_edge (e, dest, src);\n     }\n }"}]}