{"sha": "dbb5486265f91e02a8bbe5f45ea87f56c1f2a529", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGJiNTQ4NjI2NWY5MWUwMmE4YmJlNWY0NWVhODdmNTZjMWYyYTUyOQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-06-28T19:33:23Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-06-28T19:33:23Z"}, "message": "(cpu_type, sparc_cpu_type): Rename to arch_type and sparc_arch_type.\n\n(cpu_type, sparc_cpu_type): Rename to arch_type and\nsparc_arch_type.  Fix all users.\n(supersparc_adjust_cost): New function.\n\nFrom-SVN: r7588", "tree": {"sha": "1580edbd1df7dc0aefe08abff21c954d3bf22b29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1580edbd1df7dc0aefe08abff21c954d3bf22b29"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dbb5486265f91e02a8bbe5f45ea87f56c1f2a529", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbb5486265f91e02a8bbe5f45ea87f56c1f2a529", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbb5486265f91e02a8bbe5f45ea87f56c1f2a529", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbb5486265f91e02a8bbe5f45ea87f56c1f2a529/comments", "author": null, "committer": null, "parents": [{"sha": "bef8d8c781b86b91ff52d5f99e5d6bfa8ea19fdf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bef8d8c781b86b91ff52d5f99e5d6bfa8ea19fdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bef8d8c781b86b91ff52d5f99e5d6bfa8ea19fdf"}], "stats": {"total": 74, "additions": 71, "deletions": 3}, "files": [{"sha": "33cfdb92ab5aa58d8db43756c558dd61812f73f4", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 71, "deletions": 3, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbb5486265f91e02a8bbe5f45ea87f56c1f2a529/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbb5486265f91e02a8bbe5f45ea87f56c1f2a529/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=dbb5486265f91e02a8bbe5f45ea87f56c1f2a529", "patch": "@@ -44,8 +44,8 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n /* Global variables for machine-dependent things.  */\n \n-/* Says what cpu we're compiling for.  */\n-enum cpu_type sparc_cpu_type;\n+/* Says what architecture we're compiling for.  */\n+enum arch_type sparc_arch_type;\n \n /* Size of frame.  Need to know this to emit return insns from leaf procedures.\n    ACTUAL_FSIZE is set by compute_frame_size() which is called during the\n@@ -2620,7 +2620,7 @@ sparc_init_modes ()\n {\n   int i;\n \n-  sparc_cpu_type = TARGET_V9 ? CPU_64BIT : CPU_32BIT;\n+  sparc_arch_type = TARGET_V9 ? ARCH_64BIT : ARCH_32BIT;\n \n   for (i = 0; i < NUM_MACHINE_MODES; i++)\n     {\n@@ -4625,3 +4625,71 @@ sparc_flat_eligible_for_epilogue_delay (trial, slot)\n     return 1;\n   return 0;\n }\n+\f\n+/* Adjust the cost of a scheduling dependency.  Return the new cost of\n+   a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */\n+\n+int\n+supersparc_adjust_cost (insn, link, dep_insn, cost)\n+     rtx insn;\n+     rtx link;\n+     rtx dep_insn;\n+     int cost;\n+{\n+  enum attr_type insn_type;\n+\n+  if (! recog_memoized (insn))\n+    return 0;\n+\n+  insn_type = get_attr_type (insn);\n+\n+  if (REG_NOTE_KIND (link) == 0)\n+    {\n+      /* Data dependency; DEP_INSN writes a register that INSN reads some\n+\t cycles later.  */\n+\n+      /* if a load, then the dependence must be on the memory address;\n+\t add an extra 'cycle'.  Note that the cost could be two cycles\n+\t if the reg was written late in an instruction group; we can't tell\n+\t here.  */\n+      if (insn_type == TYPE_LOAD || insn_type == TYPE_FPLOAD)\n+\treturn cost + 3;\n+\n+      /* Get the delay only if the address of the store is the dependence.  */\n+      if (insn_type == TYPE_STORE || insn_type == TYPE_FPSTORE)\n+\t{\n+\t  rtx pat = PATTERN(insn);\n+\t  rtx dep_pat = PATTERN (dep_insn);\n+\n+\t  if (GET_CODE (pat) != SET || GET_CODE (dep_pat) != SET)\n+\t    return cost;  /* This shouldn't happen!  */\n+\n+\t  /* The dependency between the two instructions was on the data that\n+\t     is being stored.  Assume that this implies that the address of the\n+\t     store is not dependent.  */\n+\t  if (rtx_equal_p (SET_DEST (dep_pat), SET_SRC (pat)))\n+\t    return cost;\n+\n+\t  return cost + 3;  /* An approximation.  */\n+\t}\n+\n+      /* A shift instruction cannot receive its data from an instruction\n+\t in the same cycle; add a one cycle penalty.  */\n+      if (insn_type == TYPE_SHIFT)\n+\treturn cost + 3;   /* Split before cascade into shift.  */\n+    }\n+  else\n+    {\n+      /* Anti- or output- dependency; DEP_INSN reads/writes a register that\n+\t INSN writes some cycles later.  */\n+\n+      /* These are only significant for the fpu unit; writing a fp reg before\n+         the fpu has finished with it stalls the processor.  */\n+\n+      /* Reusing an integer register causes no problems.  */\n+      if (insn_type == TYPE_IALU || insn_type == TYPE_SHIFT)\n+\treturn 0;\n+    }\n+\t\n+  return cost;\n+}"}]}