{"sha": "2b110bfcc074f222a49d875c5f0f5ea370294b9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmIxMTBiZmNjMDc0ZjIyMmE0OWQ4NzVjNWYwZjVlYTM3MDI5NGI5Zg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2009-07-02T17:28:07Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2009-07-02T17:28:07Z"}, "message": "Use hash tables for template specialization lookup.\n\n\t* pt.c (struct spec_entry): New type.\n\t(decl_specializations, type_specializations): New hash tables.\n\t(register_specialization, retrieve_specialization): Use them.\n\t(reregister_specialization, lookup_template_class): Use them.\n\t(eq_specializations, hash_tmpl_and_args, hash_specialization): New.\n\t(iterative_hash_template_arg): New.\n\t(init_template_processing): New\n\t(process_partial_specialization): Don't look to see if we already\n\thave this partial specialization.\n\t(maybe_process_partial_specialization): Handle reassigning\n\tfull specializations when we get an explicit specialization\n\tof the partial instantiation.\n\t(tsubst_friend_function): Adjust specialization reassignment code.\n\t(instantiate_template): Only do one lookup.\n\t(instantiate_decl): Don't do any lookup.\n\t* cp-tree.h: Declare init_template_processing.\n\t* decl.c (duplicate_decls): Pass args to reregister_specialization.\n\nFrom-SVN: r149188", "tree": {"sha": "3c2c0297ab16c23ff492721390073d22d425b37a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c2c0297ab16c23ff492721390073d22d425b37a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b110bfcc074f222a49d875c5f0f5ea370294b9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b110bfcc074f222a49d875c5f0f5ea370294b9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b110bfcc074f222a49d875c5f0f5ea370294b9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b110bfcc074f222a49d875c5f0f5ea370294b9f/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "74c9e8526b70f57ed371aa96e414b453c28544d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74c9e8526b70f57ed371aa96e414b453c28544d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74c9e8526b70f57ed371aa96e414b453c28544d9"}], "stats": {"total": 724, "additions": 485, "deletions": 239}, "files": [{"sha": "930487145a8e1bc77785301b8b11783eb455401e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b110bfcc074f222a49d875c5f0f5ea370294b9f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b110bfcc074f222a49d875c5f0f5ea370294b9f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2b110bfcc074f222a49d875c5f0f5ea370294b9f", "patch": "@@ -1,3 +1,24 @@\n+2009-07-02  Jason Merrill  <jason@redhat.com>\n+\n+\tUse hash tables for template specialization lookup.\n+\t* pt.c (struct spec_entry): New type.\n+\t(decl_specializations, type_specializations): New hash tables.\n+\t(register_specialization, retrieve_specialization): Use them.\n+\t(reregister_specialization, lookup_template_class): Use them.\n+\t(eq_specializations, hash_tmpl_and_args, hash_specialization): New.\n+\t(iterative_hash_template_arg): New.\n+\t(init_template_processing): New\n+\t(process_partial_specialization): Don't look to see if we already\n+\thave this partial specialization.\n+\t(maybe_process_partial_specialization): Handle reassigning\n+\tfull specializations when we get an explicit specialization\n+\tof the partial instantiation.\n+\t(tsubst_friend_function): Adjust specialization reassignment code.\n+\t(instantiate_template): Only do one lookup.\n+\t(instantiate_decl): Don't do any lookup.\n+\t* cp-tree.h: Declare init_template_processing.\n+\t* decl.c (duplicate_decls): Pass args to reregister_specialization.\n+\n 2009-07-01  Jason Merrill  <jason@redhat.com>\n \n \t* cp-tree.h (DECL_CLASS_TEMPLATE_P): Use DECL_IMPLICIT_TYPEDEF_P."}, {"sha": "03dad6665d65d7bce0a6ceb8acc4e4495f9b23dc", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 13, "deletions": 29, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b110bfcc074f222a49d875c5f0f5ea370294b9f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b110bfcc074f222a49d875c5f0f5ea370294b9f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2b110bfcc074f222a49d875c5f0f5ea370294b9f", "patch": "@@ -3072,15 +3072,18 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    TREE_VEC_LENGTH (DECL_INNERMOST_TEMPLATE_PARMS (NODE))\n /* For function, method, class-data templates.  */\n #define DECL_TEMPLATE_RESULT(NODE)      DECL_RESULT_FLD (NODE)\n-/* For a static member variable template, the\n-   DECL_TEMPLATE_INSTANTIATIONS list contains the explicitly and\n-   implicitly generated instantiations of the variable.  There are no\n-   partial instantiations of static member variables, so all of these\n-   will be full instantiations.\n+/* For a function template at namespace scope, DECL_TEMPLATE_INSTANTIATIONS\n+   lists all instantiations and specializations of the function so that\n+   tsubst_friend_function can reassign them to another template if we find\n+   that the namespace-scope template is really a partial instantiation of a\n+   friend template.\n \n    For a class template the DECL_TEMPLATE_INSTANTIATIONS lists holds\n    all instantiations and specializations of the class type, including\n-   partial instantiations and partial specializations.\n+   partial instantiations and partial specializations, so that if we\n+   explicitly specialize a partial instantiation we can walk the list\n+   in maybe_process_partial_specialization and reassign them or complain\n+   as appropriate.\n \n    In both cases, the TREE_PURPOSE of each node contains the arguments\n    used; the TREE_VALUE contains the generated variable.  The template\n@@ -3096,29 +3099,9 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    DECL_TEMPLATE_INSTANTIATIONS list for `template <class T> template\n    <class U> struct S1<T>::S2'.\n \n-   This list is not used for function templates.  */\n+   This list is not used for other templates.  */\n #define DECL_TEMPLATE_INSTANTIATIONS(NODE) DECL_VINDEX (NODE)\n-/* For a function template, the DECL_TEMPLATE_SPECIALIZATIONS lists\n-   contains all instantiations and specializations of the function,\n-   including partial instantiations.  For a partial instantiation\n-   which is a specialization, this list holds only full\n-   specializations of the template that are instantiations of the\n-   partial instantiation.  For example, given:\n-\n-      template <class T> struct S {\n-\ttemplate <class U> void f(U);\n-\ttemplate <> void f(T);\n-      };\n-\n-   the `S<int>::f<int>(int)' function will appear on the\n-   DECL_TEMPLATE_SPECIALIZATIONS list for both `template <class T>\n-   template <class U> void S<T>::f(U)' and `template <class T> void\n-   S<int>::f(T)'.  In the latter case, however, it will have only the\n-   innermost set of arguments (T, in this case).  The DECL_TI_TEMPLATE\n-   for the function declaration will point at the specialization, not\n-   the fully general template.\n-\n-   For a class template, this list contains the partial\n+/* For a class template, this list contains the partial\n    specializations of this template.  (Full specializations are not\n    recorded on this list.)  The TREE_PURPOSE holds the arguments used\n    in the partial specialization (e.g., for `template <class T> struct\n@@ -3128,7 +3111,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    example above.)  The TREE_TYPE is the _TYPE node for the partial\n    specialization.\n \n-   This list is not used for static variable templates.  */\n+   This list is not used for other templates.  */\n #define DECL_TEMPLATE_SPECIALIZATIONS(NODE)     DECL_SIZE (NODE)\n \n /* Nonzero for a DECL which is actually a template parameter.  Keep\n@@ -4619,6 +4602,7 @@ extern tree fold_non_dependent_expr\t\t(tree);\n extern bool explicit_class_specialization_p     (tree);\n extern struct tinst_level *outermost_tinst_level(void);\n extern bool parameter_of_template_p\t\t(tree, tree);\n+extern void init_template_processing\t\t(void);\n \n /* in repo.c */\n extern void init_repo\t\t\t\t(void);"}, {"sha": "73c756f2e1a6c63d1cc5d5a5f273e1f7a5ad2e59", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b110bfcc074f222a49d875c5f0f5ea370294b9f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b110bfcc074f222a49d875c5f0f5ea370294b9f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=2b110bfcc074f222a49d875c5f0f5ea370294b9f", "patch": "@@ -1109,7 +1109,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n   unsigned olddecl_uid = DECL_UID (olddecl);\n   int olddecl_friend = 0, types_match = 0, hidden_friend = 0;\n   int new_defines_function = 0;\n-  tree new_template;\n+  tree new_template_info;\n \n   if (newdecl == olddecl)\n     return olddecl;\n@@ -1855,7 +1855,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n   if (! DECL_EXTERNAL (olddecl))\n     DECL_EXTERNAL (newdecl) = 0;\n \n-  new_template = NULL_TREE;\n+  new_template_info = NULL_TREE;\n   if (DECL_LANG_SPECIFIC (newdecl) && DECL_LANG_SPECIFIC (olddecl))\n     {\n       bool new_redefines_gnu_inline = false;\n@@ -1899,7 +1899,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n       DECL_NONCONVERTING_P (newdecl) = DECL_NONCONVERTING_P (olddecl);\n       DECL_REPO_AVAILABLE_P (newdecl) = DECL_REPO_AVAILABLE_P (olddecl);\n       if (DECL_TEMPLATE_INFO (newdecl))\n-\tnew_template = DECL_TI_TEMPLATE (newdecl);\n+\tnew_template_info = DECL_TEMPLATE_INFO (newdecl);\n       DECL_TEMPLATE_INFO (newdecl) = DECL_TEMPLATE_INFO (olddecl);\n       DECL_INITIALIZED_IN_CLASS_P (newdecl)\n \t|= DECL_INITIALIZED_IN_CLASS_P (olddecl);\n@@ -2097,7 +2097,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n       memcpy ((char *) olddecl + sizeof (struct tree_decl_common),\n \t      (char *) newdecl + sizeof (struct tree_decl_common),\n \t      sizeof (struct tree_function_decl) - sizeof (struct tree_decl_common));\n-      if (new_template)\n+      if (new_template_info)\n \t/* If newdecl is a template instantiation, it is possible that\n \t   the following sequence of events has occurred:\n \n@@ -2120,7 +2120,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t   instantiations so that if we try to do the instantiation\n \t   again we won't get the clobbered declaration.  */\n \treregister_specialization (newdecl,\n-\t\t\t\t   new_template,\n+\t\t\t\t   new_template_info,\n \t\t\t\t   olddecl);\n     }\n   else\n@@ -3459,6 +3459,7 @@ cxx_init_decl_processing (void)\n   /* Perform other language dependent initializations.  */\n   init_class_processing ();\n   init_rtti_processing ();\n+  init_template_processing ();\n \n   if (flag_exceptions)\n     init_exception_processing ();"}, {"sha": "c65ffcd2f4132e8357246667ab3c2622a898e75e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 434, "deletions": 203, "changes": 637, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b110bfcc074f222a49d875c5f0f5ea370294b9f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b110bfcc074f222a49d875c5f0f5ea370294b9f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=2b110bfcc074f222a49d875c5f0f5ea370294b9f", "patch": "@@ -82,6 +82,19 @@ static tree cur_stmt_expr;\n    local variables.  */\n static htab_t local_specializations;\n \n+typedef struct GTY(()) spec_entry\n+{\n+  tree tmpl;\n+  tree args;\n+  tree spec;\n+} spec_entry;\n+\n+static GTY ((param_is (spec_entry)))\n+  htab_t decl_specializations;\n+\n+static GTY ((param_is (spec_entry)))\n+  htab_t type_specializations;\n+\n /* Contains canonical template parameter types. The vector is indexed by\n    the TEMPLATE_TYPE_IDX of the template parameter. Each element is a\n    TREE_LIST, whose TREE_VALUEs contain the canonical template\n@@ -133,6 +146,7 @@ static bool inline_needs_template_parms (tree);\n static void push_inline_template_parms_recursive (tree, int);\n static tree retrieve_local_specialization (tree);\n static void register_local_specialization (tree, tree);\n+static hashval_t hash_specialization (const void *p);\n static tree reduce_template_parm_level (tree, tree, int, tree, tsubst_flags_t);\n static int mark_template_parm (tree, void *);\n static int template_parm_this_level_p (tree, void *);\n@@ -176,6 +190,7 @@ static tree tsubst_pack_expansion (tree, tree, tsubst_flags_t, tree);\n static tree tsubst_decl (tree, tree, tsubst_flags_t);\n static void perform_typedefs_access_check (tree tmpl, tree targs);\n static void append_type_to_template_for_access_check_1 (tree, tree, tree);\n+static hashval_t iterative_hash_template_arg (tree arg, hashval_t val);\n \n /* Make the current scope suitable for access checking when we are\n    processing T.  T can be FUNCTION_DECL for instantiated function\n@@ -811,27 +826,52 @@ maybe_process_partial_specialization (tree type)\n \t  && !COMPLETE_TYPE_P (type))\n \t{\n \t  tree t;\n+\t  tree tmpl = CLASSTYPE_TI_TEMPLATE (type);\n \n \t  if (current_namespace\n-\t      != decl_namespace_context (CLASSTYPE_TI_TEMPLATE (type)))\n+\t      != decl_namespace_context (tmpl))\n \t    {\n \t      permerror (input_location, \"specializing %q#T in different namespace\", type);\n-\t      permerror (input_location, \"  from definition of %q+#D\",\n-\t\t         CLASSTYPE_TI_TEMPLATE (type));\n+\t      permerror (input_location, \"  from definition of %q+#D\", tmpl);\n \t    }\n \n \t  /* Check for invalid specialization after instantiation:\n \n \t       template <> template <> class C<int>::D<int>;\n \t       template <> template <class U> class C<int>::D;  */\n \n-\t  for (t = DECL_TEMPLATE_INSTANTIATIONS\n-\t\t (most_general_template (CLASSTYPE_TI_TEMPLATE (type)));\n+\t  for (t = DECL_TEMPLATE_INSTANTIATIONS (tmpl);\n \t       t; t = TREE_CHAIN (t))\n-\t    if (TREE_VALUE (t) != type\n-\t\t&& TYPE_CONTEXT (TREE_VALUE (t)) == context)\n-\t      error (\"specialization %qT after instantiation %qT\",\n-\t\t     type, TREE_VALUE (t));\n+\t    {\n+\t      tree inst = TREE_VALUE (t);\n+\t      if (CLASSTYPE_TEMPLATE_SPECIALIZATION (inst))\n+\t\t{\n+\t\t  /* We already have a full specialization of this partial\n+\t\t     instantiation.  Reassign it to the new member\n+\t\t     specialization template.  */\n+\t\t  spec_entry elt;\n+\t\t  spec_entry **slot;\n+\n+\t\t  elt.tmpl = most_general_template (tmpl);\n+\t\t  elt.args = CLASSTYPE_TI_ARGS (inst);\n+\t\t  elt.spec = inst;\n+\n+\t\t  htab_remove_elt (type_specializations, &elt);\n+\n+\t\t  elt.tmpl = tmpl;\n+\t\t  elt.args = INNERMOST_TEMPLATE_ARGS (elt.args);\n+\n+\t\t  slot = (spec_entry **)\n+\t\t    htab_find_slot (type_specializations, &elt, INSERT);\n+\t\t  *slot = GGC_NEW (spec_entry);\n+\t\t  **slot = elt;\n+\t\t}\n+\t      else if (COMPLETE_TYPE_P (inst) || TYPE_BEING_DEFINED (inst))\n+\t\t/* But if we've had an implicit instantiation, that's a\n+\t\t   problem ([temp.expl.spec]/6).  */\n+\t\terror (\"specialization %qT after instantiation %qT\",\n+\t\t       type, inst);\n+\t    }\n \n \t  /* Mark TYPE as a specialization.  And as a result, we only\n \t     have one level of template argument for the innermost\n@@ -895,8 +935,7 @@ optimize_specialization_lookup_p (tree tmpl)\n    parameter is ignored if TMPL is not a class template.  */\n \n static tree\n-retrieve_specialization (tree tmpl, tree args,\n-\t\t\t bool class_specializations_p)\n+retrieve_specialization (tree tmpl, tree args, hashval_t hash)\n {\n   if (args == error_mark_node)\n     return NULL_TREE;\n@@ -921,8 +960,7 @@ retrieve_specialization (tree tmpl, tree args,\n \t arguments.  */\n       class_template = CLASSTYPE_TI_TEMPLATE (DECL_CONTEXT (tmpl));\n       class_specialization\n-\t= retrieve_specialization (class_template, args,\n-\t\t\t\t   /*class_specializations_p=*/false);\n+\t= retrieve_specialization (class_template, args, 0);\n       if (!class_specialization)\n \treturn NULL_TREE;\n       /* Now, find the appropriate entry in the CLASSTYPE_METHOD_VEC\n@@ -943,39 +981,24 @@ retrieve_specialization (tree tmpl, tree args,\n     }\n   else\n     {\n-      tree *sp;\n-      tree *head;\n-\n-      /* Class templates store their instantiations on the\n-\t DECL_TEMPLATE_INSTANTIATIONS list; other templates use the\n-\t DECL_TEMPLATE_SPECIALIZATIONS list.  */\n-      if (!class_specializations_p\n-\t  && TREE_CODE (DECL_TEMPLATE_RESULT (tmpl)) == TYPE_DECL\n-\t  && !is_typedef_decl (DECL_TEMPLATE_RESULT (tmpl))\n-\t  && TAGGED_TYPE_P (TREE_TYPE (tmpl)))\n-\tsp = &DECL_TEMPLATE_INSTANTIATIONS (tmpl);\n+      spec_entry *found;\n+      spec_entry elt;\n+      htab_t specializations;\n+\n+      elt.tmpl = tmpl;\n+      elt.args = args;\n+      elt.spec = NULL_TREE;\n+\n+      if (DECL_CLASS_TEMPLATE_P (tmpl))\n+\tspecializations = type_specializations;\n       else\n-\tsp = &DECL_TEMPLATE_SPECIALIZATIONS (tmpl);\n-      head = sp;\n-      /* Iterate through the list until we find a matching template.  */\n-      while (*sp != NULL_TREE)\n-\t{\n-\t  tree spec = *sp;\n+\tspecializations = decl_specializations;\n \n-\t  if (comp_template_args (TREE_PURPOSE (spec), args))\n-\t    {\n-\t      /* Use the move-to-front heuristic to speed up future\n-\t\t searches.  */\n-\t      if (spec != *head)\n-\t\t{\n-\t\t  *sp = TREE_CHAIN (*sp);\n-\t\t  TREE_CHAIN (spec) = *head;\n-\t\t  *head = spec;\n-\t\t}\n-\t      return TREE_VALUE (spec);\n-\t    }\n-\t  sp = &TREE_CHAIN (spec);\n-\t}\n+      if (hash == 0)\n+\thash = hash_specialization (&elt);\n+      found = (spec_entry *) htab_find_with_hash (specializations, &elt, hash);\n+      if (found)\n+\treturn found->spec;\n     }\n \n   return NULL_TREE;\n@@ -1214,11 +1237,14 @@ is_specialization_of_friend (tree decl, tree friend_decl)\n    equivalent prior declaration, if available.  */\n \n static tree\n-register_specialization (tree spec, tree tmpl, tree args, bool is_friend)\n+register_specialization (tree spec, tree tmpl, tree args, bool is_friend,\n+\t\t\t hashval_t hash)\n {\n   tree fn;\n+  spec_entry **slot = NULL;\n+  spec_entry elt;\n \n-  gcc_assert (TREE_CODE (tmpl) == TEMPLATE_DECL);\n+  gcc_assert (TREE_CODE (tmpl) == TEMPLATE_DECL && DECL_P (spec));\n \n   if (TREE_CODE (spec) == FUNCTION_DECL\n       && uses_template_parms (DECL_TI_ARGS (spec)))\n@@ -1235,8 +1261,27 @@ register_specialization (tree spec, tree tmpl, tree args, bool is_friend)\n        instantiation unless and until it is actually needed.  */\n     return spec;\n \n-  fn = retrieve_specialization (tmpl, args,\n-\t\t\t\t/*class_specializations_p=*/false);\n+  if (optimize_specialization_lookup_p (tmpl))\n+    /* We don't put these specializations in the hash table, but we might\n+       want to give an error about a mismatch.  */\n+    fn = retrieve_specialization (tmpl, args, 0);\n+  else\n+    {\n+      elt.tmpl = tmpl;\n+      elt.args = args;\n+      elt.spec = spec;\n+\n+      if (hash == 0)\n+\thash = hash_specialization (&elt);\n+\n+      slot = (spec_entry **)\n+\thtab_find_slot_with_hash (decl_specializations, &elt, hash, INSERT);\n+      if (*slot)\n+\tfn = (*slot)->spec;\n+      else\n+\tfn = NULL_TREE;\n+    }\n+\n   /* We can sometimes try to re-register a specialization that we've\n      already got.  In particular, regenerate_decl_from_template calls\n      duplicate_decls which will update the specialization list.  But,\n@@ -1322,32 +1367,216 @@ register_specialization (tree spec, tree tmpl, tree args, bool is_friend)\n     DECL_CONTEXT (spec) = DECL_CONTEXT (tmpl);\n \n   if (!optimize_specialization_lookup_p (tmpl))\n-    DECL_TEMPLATE_SPECIALIZATIONS (tmpl)\n-      = tree_cons (args, spec, DECL_TEMPLATE_SPECIALIZATIONS (tmpl));\n+    {\n+      gcc_assert (tmpl && args && spec);\n+      *slot = GGC_NEW (spec_entry);\n+      **slot = elt;\n+      if (TREE_CODE (spec) == FUNCTION_DECL && DECL_NAMESPACE_SCOPE_P (spec)\n+\t  && PRIMARY_TEMPLATE_P (tmpl)\n+\t  && DECL_SAVED_TREE (DECL_TEMPLATE_RESULT (tmpl)) == NULL_TREE)\n+\t/* TMPL is a forward declaration of a template function; keep a list\n+\t   of all specializations in case we need to reassign them to a friend\n+\t   template later in tsubst_friend_function.  */\n+\tDECL_TEMPLATE_INSTANTIATIONS (tmpl)\n+\t  = tree_cons (args, spec, DECL_TEMPLATE_INSTANTIATIONS (tmpl));\n+    }\n \n   return spec;\n }\n \n+/* Returns true iff two spec_entry nodes are equivalent.  Only compares the\n+   TMPL and ARGS members, ignores SPEC.  */\n+\n+static int\n+eq_specializations (const void *p1, const void *p2)\n+{\n+  const spec_entry *e1 = (const spec_entry *)p1;\n+  const spec_entry *e2 = (const spec_entry *)p2;\n+\n+  return (e1->tmpl == e2->tmpl\n+\t  && comp_template_args (e1->args, e2->args));\n+}\n+\n+/* Returns a hash for a template TMPL and template arguments ARGS.  */\n+\n+static hashval_t\n+hash_tmpl_and_args (tree tmpl, tree args)\n+{\n+  hashval_t val = DECL_UID (tmpl);\n+  return iterative_hash_template_arg (args, val);\n+}\n+\n+/* Returns a hash for a spec_entry node based on the TMPL and ARGS members,\n+   ignoring SPEC.  */\n+\n+static hashval_t\n+hash_specialization (const void *p)\n+{\n+  const spec_entry *e = (const spec_entry *)p;\n+  return hash_tmpl_and_args (e->tmpl, e->args);\n+}\n+\n+/* Recursively calculate a hash value for a template argument ARG, for use\n+   in the hash tables of template specializations.  */\n+\n+static hashval_t\n+iterative_hash_template_arg (tree arg, hashval_t val)\n+{\n+  unsigned HOST_WIDE_INT i;\n+  enum tree_code code;\n+  char tclass;\n+\n+  if (arg == NULL_TREE)\n+    return iterative_hash_object (arg, val);\n+\n+  if (!TYPE_P (arg))\n+    STRIP_NOPS (arg);\n+\n+  code = TREE_CODE (arg);\n+  tclass = TREE_CODE_CLASS (code);\n+\n+  val = iterative_hash_object (code, val);\n+\n+  switch (code)\n+    {\n+    case ERROR_MARK:\n+      return val;\n+\n+    case IDENTIFIER_NODE:\n+      return iterative_hash_object (IDENTIFIER_HASH_VALUE (arg), val);\n+\n+    case TREE_VEC:\n+      {\n+\tint i, len = TREE_VEC_LENGTH (arg);\n+\tfor (i = 0; i < len; ++i)\n+\t  val = iterative_hash_template_arg (TREE_VEC_ELT (arg, i), val);\n+\treturn val;\n+      }\n+\n+    case TYPE_PACK_EXPANSION:\n+    case EXPR_PACK_EXPANSION:\n+      return iterative_hash_template_arg (PACK_EXPANSION_PATTERN (arg), val);\n+\n+    case ARGUMENT_PACK_SELECT:\n+      /* We can get one of these when re-hashing a previous entry in the middle\n+         of substituting into a pack expansion.  Just look through it...  */\n+      arg = ARGUMENT_PACK_SELECT_FROM_PACK (arg);\n+      /* ...and fall through.  */\n+    case TYPE_ARGUMENT_PACK:\n+    case NONTYPE_ARGUMENT_PACK:\n+      return iterative_hash_template_arg (ARGUMENT_PACK_ARGS (arg), val);\n+\n+    case TREE_LIST:\n+      for (; arg; arg = TREE_CHAIN (arg))\n+\tval = iterative_hash_template_arg (TREE_VALUE (arg), val);\n+      return val;\n+\n+    case OVERLOAD:\n+      for (; arg; arg = OVL_CHAIN (arg))\n+\tval = iterative_hash_template_arg (OVL_FUNCTION (arg), val);\n+      return val;\n+\n+    case CONSTRUCTOR:\n+      {\n+\ttree field, value;\n+\tFOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (arg), i, field, value)\n+\t  {\n+\t    val = iterative_hash_template_arg (field, val);\n+\t    val = iterative_hash_template_arg (value, val);\n+\t  }\n+\treturn val;\n+      }\n+\n+    case PARM_DECL:\n+      /* I tried hashing parm_index as well, but in some cases we get\n+\t called too soon for that to work, so just hash the type and let\n+\t lookup check that the index matches.  */\n+      return iterative_hash_template_arg (TREE_TYPE (arg), val);\n+\n+    case TARGET_EXPR:\n+      return iterative_hash_template_arg (TARGET_EXPR_INITIAL (arg), val);\n+\n+    case PTRMEM_CST:\n+      val = iterative_hash_template_arg (PTRMEM_CST_CLASS (arg), val);\n+      return iterative_hash_template_arg (PTRMEM_CST_MEMBER (arg), val);\n+\n+    case TEMPLATE_PARM_INDEX:\n+      val = iterative_hash_template_arg\n+\t(TREE_TYPE (TEMPLATE_PARM_DECL (arg)), val);\n+      val = iterative_hash_object (TEMPLATE_PARM_LEVEL (arg), val);\n+      return iterative_hash_object (TEMPLATE_PARM_IDX (arg), val);\n+\n+    case TRAIT_EXPR:\n+      val = iterative_hash_object (TRAIT_EXPR_KIND (arg), val);\n+      val = iterative_hash_template_arg (TRAIT_EXPR_TYPE1 (arg), val);\n+      return iterative_hash_template_arg (TRAIT_EXPR_TYPE2 (arg), val);\n+\n+    case BASELINK:\n+      val = iterative_hash_template_arg (BINFO_TYPE (BASELINK_BINFO (arg)),\n+\t\t\t\t\t val);\n+      return iterative_hash_template_arg (DECL_NAME (get_first_fn (arg)),\n+\t\t\t\t\t  val);\n+\n+    case MODOP_EXPR:\n+      val = iterative_hash_template_arg (TREE_OPERAND (arg, 0), val);\n+      code = TREE_CODE (TREE_OPERAND (arg, 1));\n+      val = iterative_hash_object (code, val);\n+      return iterative_hash_template_arg (TREE_OPERAND (arg, 2), val);\n+\n+    default:\n+      switch (tclass)\n+\t{\n+\tcase tcc_type:\n+\t  if (TYPE_CANONICAL (arg))\n+\t    return iterative_hash_object (TYPE_HASH (TYPE_CANONICAL (arg)),\n+\t\t\t\t\t  val);\n+\t  else if (TREE_CODE (arg) == DECLTYPE_TYPE)\n+\t    return iterative_hash_template_arg (DECLTYPE_TYPE_EXPR (arg), val);\n+\t  /* Otherwise just compare the types during lookup.  */\n+\t  return val;\n+\n+\tcase tcc_declaration:\n+\tcase tcc_constant:\n+\t  return iterative_hash_expr (arg, val);\n+\n+\tdefault:\n+\t  gcc_assert (IS_EXPR_CODE_CLASS (tclass));\n+\t  {\n+\t    unsigned n = TREE_OPERAND_LENGTH (arg);\n+\t    for (i = 0; i < n; ++i)\n+\t      val = iterative_hash_template_arg (TREE_OPERAND (arg, i), val);\n+\t    return val;\n+\t  }\n+\t}\n+    }\n+  gcc_unreachable ();\n+  return 0;\n+}\n+\n /* Unregister the specialization SPEC as a specialization of TMPL.\n    Replace it with NEW_SPEC, if NEW_SPEC is non-NULL.  Returns true\n-   if the SPEC was listed as a specialization of TMPL.  */\n+   if the SPEC was listed as a specialization of TMPL.\n+\n+   Note that SPEC has been ggc_freed, so we can't look inside it.  */\n \n bool\n-reregister_specialization (tree spec, tree tmpl, tree new_spec)\n+reregister_specialization (tree spec, tree tinfo, tree new_spec)\n {\n-  tree* s;\n+  spec_entry **slot;\n+  spec_entry elt;\n \n-  for (s = &DECL_TEMPLATE_SPECIALIZATIONS (tmpl);\n-       *s != NULL_TREE;\n-       s = &TREE_CHAIN (*s))\n-    if (TREE_VALUE (*s) == spec)\n-      {\n-\tif (!new_spec)\n-\t  *s = TREE_CHAIN (*s);\n-\telse\n-\t  TREE_VALUE (*s) = new_spec;\n-\treturn 1;\n-      }\n+  elt.tmpl = most_general_template (TI_TEMPLATE (tinfo));\n+  elt.args = TI_ARGS (tinfo);\n+  elt.spec = NULL_TREE;\n+\n+  slot = (spec_entry **) htab_find_slot (decl_specializations, &elt, INSERT);\n+  if (*slot)\n+    {\n+      gcc_assert ((*slot)->spec == spec || (*slot)->spec == new_spec);\n+      gcc_assert (new_spec != NULL_TREE);\n+      (*slot)->spec = new_spec;\n+      return 1;\n+    }\n \n   return 0;\n }\n@@ -2241,7 +2470,7 @@ check_explicit_specialization (tree declarator,\n \t\t    DECL_CONTEXT (parm) = result;\n \t\t}\n \t      return register_specialization (tmpl, gen_tmpl, targs,\n-\t\t\t\t\t      is_friend);\n+\t\t\t\t\t      is_friend, 0);\n \t    }\n \n \t  /* Set up the DECL_TEMPLATE_INFO for DECL.  */\n@@ -2319,7 +2548,7 @@ check_explicit_specialization (tree declarator,\n \n \t  /* Register this specialization so that we can find it\n \t     again.  */\n-\t  decl = register_specialization (decl, gen_tmpl, targs, is_friend);\n+\t  decl = register_specialization (decl, gen_tmpl, targs, is_friend, 0);\n \t}\n     }\n \n@@ -3514,10 +3743,8 @@ process_partial_specialization (tree decl)\n         }\n     }\n \n-  if (retrieve_specialization (maintmpl, specargs,\n-\t\t\t       /*class_specializations_p=*/true))\n-    /* We've already got this specialization.  */\n-    return decl;\n+  /* We should only get here once.  */\n+  gcc_assert (!COMPLETE_TYPE_P (type));\n \n   DECL_TEMPLATE_SPECIALIZATIONS (maintmpl)\n     = tree_cons (specargs, inner_parms,\n@@ -3997,7 +4224,7 @@ push_template_decl_real (tree decl, bool is_friend)\n \t  register_specialization (new_tmpl,\n \t\t\t\t   most_general_template (tmpl),\n \t\t\t\t   args,\n-\t\t\t\t   is_friend);\n+\t\t\t\t   is_friend, 0);\n \t  return decl;\n \t}\n \n@@ -5617,6 +5844,10 @@ lookup_template_class (tree d1,\n {\n   tree templ = NULL_TREE, parmlist;\n   tree t;\n+  spec_entry **slot;\n+  spec_entry *entry;\n+  spec_entry elt;\n+  hashval_t hash;\n \n   timevar_push (TV_NAME_LOOKUP);\n \n@@ -5782,7 +6013,6 @@ lookup_template_class (tree d1,\n \n       /* From here on, we're only interested in the most general\n \t template.  */\n-      templ = gen_tmpl;\n \n       /* Calculate the BOUND_ARGS.  These will be the args that are\n \t actually tsubst'd into the definition to create the\n@@ -5796,12 +6026,12 @@ lookup_template_class (tree d1,\n \t  tree bound_args = make_tree_vec (parm_depth);\n \n \t  for (i = saved_depth,\n-\t\t t = DECL_TEMPLATE_PARMS (templ);\n+\t\t t = DECL_TEMPLATE_PARMS (gen_tmpl);\n \t       i > 0 && t != NULL_TREE;\n \t       --i, t = TREE_CHAIN (t))\n \t    {\n \t      tree a = coerce_template_parms (TREE_VALUE (t),\n-\t\t\t\t\t      arglist, templ,\n+\t\t\t\t\t      arglist, gen_tmpl,\n \t\t\t\t\t      complain,\n \t\t\t\t\t      /*require_all_args=*/true,\n \t\t\t\t\t      /*use_default_args=*/true);\n@@ -5832,7 +6062,7 @@ lookup_template_class (tree d1,\n \targlist\n \t  = coerce_template_parms (INNERMOST_TEMPLATE_PARMS (parmlist),\n \t\t\t\t   INNERMOST_TEMPLATE_ARGS (arglist),\n-\t\t\t\t   templ,\n+\t\t\t\t   gen_tmpl,\n \t\t\t\t   complain,\n \t\t\t\t   /*require_all_args=*/true,\n \t\t\t\t   /*use_default_args=*/true);\n@@ -5850,18 +6080,22 @@ lookup_template_class (tree d1,\n \t the `C<T>' is just the same as `C'.  Outside of the\n \t class, however, such a reference is an instantiation.  */\n       if ((entering_scope\n-\t   || !PRIMARY_TEMPLATE_P (templ)\n+\t   || !PRIMARY_TEMPLATE_P (gen_tmpl)\n \t   || currently_open_class (template_type))\n \t  /* comp_template_args is expensive, check it last.  */\n \t  && comp_template_args (TYPE_TI_ARGS (template_type),\n \t\t\t\t arglist))\n \tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, template_type);\n \n       /* If we already have this specialization, return it.  */\n-      found = retrieve_specialization (templ, arglist,\n-\t\t\t\t       /*class_specializations_p=*/false);\n-      if (found)\n-\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, found);\n+      elt.tmpl = gen_tmpl;\n+      elt.args = arglist;\n+      hash = hash_specialization (&elt);\n+      entry = (spec_entry *) htab_find_with_hash (type_specializations,\n+\t\t\t\t\t\t  &elt, hash);\n+\n+      if (entry)\n+\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, entry->spec);\n \n       /* This type is a \"partial instantiation\" if any of the template\n \t arguments still involve template parameters.  Note that we set\n@@ -5872,22 +6106,22 @@ lookup_template_class (tree d1,\n       /* If the deduced arguments are invalid, then the binding\n \t failed.  */\n       if (!is_partial_instantiation\n-\t  && check_instantiated_args (templ,\n+\t  && check_instantiated_args (gen_tmpl,\n \t\t\t\t      INNERMOST_TEMPLATE_ARGS (arglist),\n \t\t\t\t      complain))\n \tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n \n       if (!is_partial_instantiation\n-\t  && !PRIMARY_TEMPLATE_P (templ)\n-\t  && TREE_CODE (CP_DECL_CONTEXT (templ)) == NAMESPACE_DECL)\n+\t  && !PRIMARY_TEMPLATE_P (gen_tmpl)\n+\t  && TREE_CODE (CP_DECL_CONTEXT (gen_tmpl)) == NAMESPACE_DECL)\n \t{\n-\t  found = xref_tag_from_type (TREE_TYPE (templ),\n-\t\t\t\t      DECL_NAME (templ),\n+\t  found = xref_tag_from_type (TREE_TYPE (gen_tmpl),\n+\t\t\t\t      DECL_NAME (gen_tmpl),\n \t\t\t\t      /*tag_scope=*/ts_global);\n \t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, found);\n \t}\n \n-      context = tsubst (DECL_CONTEXT (templ), arglist,\n+      context = tsubst (DECL_CONTEXT (gen_tmpl), arglist,\n \t\t\tcomplain, in_decl);\n       if (!context)\n \tcontext = global_namespace;\n@@ -5923,7 +6157,7 @@ lookup_template_class (tree d1,\n \n \t  /* A local class.  Make sure the decl gets registered properly.  */\n \t  if (context == current_function_decl)\n-\t    pushtag (DECL_NAME (templ), t, /*tag_scope=*/ts_current);\n+\t    pushtag (DECL_NAME (gen_tmpl), t, /*tag_scope=*/ts_current);\n \n \t  if (comp_template_args (CLASSTYPE_TI_ARGS (template_type), arglist))\n \t    /* This instantiation is another name for the primary\n@@ -5943,7 +6177,7 @@ lookup_template_class (tree d1,\n \t{\n \t  TYPE_CONTEXT (t) = FROB_CONTEXT (context);\n \n-\t  type_decl = create_implicit_typedef (DECL_NAME (templ), t);\n+\t  type_decl = create_implicit_typedef (DECL_NAME (gen_tmpl), t);\n \t  DECL_CONTEXT (type_decl) = TYPE_CONTEXT (t);\n \t  TYPE_STUB_DECL (t) = type_decl;\n \t  DECL_SOURCE_LOCATION (type_decl)\n@@ -5966,65 +6200,32 @@ lookup_template_class (tree d1,\n \t template is the immediate parent if this is a full\n \t instantiation.  */\n       if (parm_depth == 1 || is_partial_instantiation\n-\t  || !PRIMARY_TEMPLATE_P (templ))\n+\t  || !PRIMARY_TEMPLATE_P (gen_tmpl))\n \t/* This case is easy; there are no member templates involved.  */\n-\tfound = templ;\n+\tfound = gen_tmpl;\n       else\n \t{\n-\t  /* This is a full instantiation of a member template.  Look\n-\t     for a partial instantiation of which this is an instance.  */\n-\n-\t  for (found = DECL_TEMPLATE_INSTANTIATIONS (templ);\n-\t       found; found = TREE_CHAIN (found))\n-\t    {\n-\t      int success;\n-\t      tree tmpl = CLASSTYPE_TI_TEMPLATE (TREE_VALUE (found));\n-\n-\t      /* We only want partial instantiations, here, not\n-\t\t specializations or full instantiations.  */\n-\t      if (CLASSTYPE_TEMPLATE_SPECIALIZATION (TREE_VALUE (found))\n-\t\t  || !uses_template_parms (TREE_VALUE (found)))\n-\t\tcontinue;\n-\n-\t      /* Temporarily reduce by one the number of levels in the\n-\t\t ARGLIST and in FOUND so as to avoid comparing the\n-\t\t last set of arguments.  */\n-\t      TREE_VEC_LENGTH (arglist)--;\n-\t      TREE_VEC_LENGTH (TREE_PURPOSE (found)) --;\n-\n-\t      /* See if the arguments match.  If they do, then TMPL is\n-\t\t the partial instantiation we want.  */\n-\t      success = comp_template_args (TREE_PURPOSE (found), arglist);\n-\n-\t      /* Restore the argument vectors to their full size.  */\n-\t      TREE_VEC_LENGTH (arglist)++;\n-\t      TREE_VEC_LENGTH (TREE_PURPOSE (found))++;\n-\n-\t      if (success)\n-\t\t{\n-\t\t  found = tmpl;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\n-\t  if (!found)\n-\t    {\n-\t      /* There was no partial instantiation. This happens\n-\t\t where C<T> is a member template of A<T> and it's used\n-\t\t in something like\n-\n-\t\t  template <typename T> struct B { A<T>::C<int> m; };\n-\t\t  B<float>;\n-\n-\t\t Create the partial instantiation.\n-\t       */\n-\t      TREE_VEC_LENGTH (arglist)--;\n-\t      found = tsubst (templ, arglist, complain, NULL_TREE);\n-\t      TREE_VEC_LENGTH (arglist)++;\n-\t    }\n+\t  /* This is a full instantiation of a member template.  Find\n+\t     the partial instantiation of which this is an instance.  */\n+\n+\t  /* Temporarily reduce by one the number of levels in the ARGLIST\n+\t     so as to avoid comparing the last set of arguments.  */\n+\t  TREE_VEC_LENGTH (arglist)--;\n+\t  found = tsubst (gen_tmpl, arglist, complain, NULL_TREE);\n+\t  TREE_VEC_LENGTH (arglist)++;\n+\t  found = CLASSTYPE_TI_TEMPLATE (found);\n \t}\n \n       SET_TYPE_TEMPLATE_INFO (t, tree_cons (found, arglist, NULL_TREE));\n+\n+      elt.spec = t;\n+      slot = (spec_entry **) htab_find_slot_with_hash (type_specializations,\n+\t\t\t\t\t\t       &elt, hash, INSERT);\n+      *slot = GGC_NEW (spec_entry);\n+      **slot = elt;\n+\n+      /* Note this use of the partial instantiation so we can check it\n+\t later in maybe_process_partial_specialization.  */\n       DECL_TEMPLATE_INSTANTIATIONS (templ)\n \t= tree_cons (arglist, t,\n \t\t     DECL_TEMPLATE_INSTANTIATIONS (templ));\n@@ -6632,46 +6833,58 @@ tsubst_friend_function (tree decl, tree args)\n \t    ;\n \t  else\n \t    {\n+\t      tree new_template = TI_TEMPLATE (new_friend_template_info);\n+\t      tree new_args = TI_ARGS (new_friend_template_info);\n+\n \t      /* Overwrite whatever template info was there before, if\n \t\t any, with the new template information pertaining to\n \t\t the declaration.  */\n \t      DECL_TEMPLATE_INFO (old_decl) = new_friend_template_info;\n \n \t      if (TREE_CODE (old_decl) != TEMPLATE_DECL)\n-\t\treregister_specialization (new_friend,\n-\t\t\t\t\t   most_general_template (old_decl),\n-\t\t\t\t\t   old_decl);\n+\t\t/* We should have called reregister_specialization in\n+\t\t   duplicate_decls.  */\n+\t\tgcc_assert (retrieve_specialization (new_template,\n+\t\t\t\t\t\t     new_args, 0)\n+\t\t\t    == old_decl);\n \t      else\n \t\t{\n \t\t  tree t;\n-\t\t  tree new_friend_args;\n \n+\t\t  /* Indicate that the old function template is a partial\n+\t\t     instantiation.  */\n \t\t  DECL_TEMPLATE_INFO (DECL_TEMPLATE_RESULT (old_decl))\n \t\t    = new_friend_result_template_info;\n \n-\t\t  new_friend_args = TI_ARGS (new_friend_template_info);\n-\t\t  for (t = DECL_TEMPLATE_SPECIALIZATIONS (old_decl);\n+\t\t  gcc_assert (new_template\n+\t\t\t      == most_general_template (new_template));\n+\t\t  gcc_assert (new_template != old_decl);\n+\n+\t\t  /* Reassign any specializations already in the hash table\n+\t\t     to the new more general template, and add the\n+\t\t     additional template args.  */\n+\t\t  for (t = DECL_TEMPLATE_INSTANTIATIONS (old_decl);\n \t\t       t != NULL_TREE;\n \t\t       t = TREE_CHAIN (t))\n \t\t    {\n \t\t      tree spec = TREE_VALUE (t);\n+\t\t      spec_entry elt;\n+\n+\t\t      elt.tmpl = old_decl;\n+\t\t      elt.args = DECL_TI_ARGS (spec);\n+\t\t      elt.spec = NULL_TREE;\n+\n+\t\t      htab_remove_elt (decl_specializations, &elt);\n \n \t\t      DECL_TI_ARGS (spec)\n-\t\t\t= add_outermost_template_args (new_friend_args,\n+\t\t\t= add_outermost_template_args (new_args,\n \t\t\t\t\t\t       DECL_TI_ARGS (spec));\n-\t\t    }\n \n-\t\t  /* Now, since specializations are always supposed to\n-\t\t     hang off of the most general template, we must move\n-\t\t     them.  */\n-\t\t  t = most_general_template (old_decl);\n-\t\t  if (t != old_decl)\n-\t\t    {\n-\t\t      DECL_TEMPLATE_SPECIALIZATIONS (t)\n-\t\t\t= chainon (DECL_TEMPLATE_SPECIALIZATIONS (t),\n-\t\t\t\t   DECL_TEMPLATE_SPECIALIZATIONS (old_decl));\n-\t\t      DECL_TEMPLATE_SPECIALIZATIONS (old_decl) = NULL_TREE;\n+\t\t      register_specialization\n+\t\t\t(spec, new_template, DECL_TI_ARGS (spec), true, 0);\n+\n \t\t    }\n+\t\t  DECL_TEMPLATE_INSTANTIATIONS (old_decl) = NULL_TREE;\n \t\t}\n \t    }\n \n@@ -8090,6 +8303,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n   location_t saved_loc;\n   tree r = NULL_TREE;\n   tree in_decl = t;\n+  hashval_t hash = 0;\n \n   /* Set the filename and linenumber to improve error-reporting.  */\n   saved_loc = input_location;\n@@ -8150,8 +8364,8 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t   changed.  */\n \tgcc_assert (full_args != tmpl_args);\n \n-\tspec = retrieve_specialization (t, full_args,\n-\t\t\t\t\t/*class_specializations_p=*/true);\n+\thash = hash_tmpl_and_args (t, full_args);\n+\tspec = retrieve_specialization (t, full_args, hash);\n \tif (spec != NULL_TREE)\n \t  {\n \t    r = spec;\n@@ -8218,7 +8432,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t  /* Record this non-type partial instantiation.  */\n \t  register_specialization (r, t,\n \t\t\t\t   DECL_TI_ARGS (DECL_TEMPLATE_RESULT (r)),\n-\t\t\t\t   false);\n+\t\t\t\t   false, hash);\n       }\n       break;\n \n@@ -8260,8 +8474,8 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t\t\t\t\t   args, complain, in_decl);\n \n \t    /* Check to see if we already have this specialization.  */\n-\t    spec = retrieve_specialization (gen_tmpl, argvec,\n-\t\t\t\t\t    /*class_specializations_p=*/false);\n+\t    hash = hash_tmpl_and_args (gen_tmpl, argvec);\n+\t    spec = retrieve_specialization (gen_tmpl, argvec, hash);\n \n \t    if (spec)\n \t      {\n@@ -8396,7 +8610,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t    DECL_TEMPLATE_INFO (r)\n \t      = tree_cons (gen_tmpl, argvec, NULL_TREE);\n \t    SET_DECL_IMPLICIT_INSTANTIATION (r);\n-\t    register_specialization (r, gen_tmpl, argvec, false);\n+\t    register_specialization (r, gen_tmpl, argvec, false, hash);\n \n \t    /* We're not supposed to instantiate default arguments\n \t       until they are called, for a template.  But, for a\n@@ -8686,9 +8900,8 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t\ttmpl = DECL_TI_TEMPLATE (t);\n \t\tgen_tmpl = most_general_template (tmpl);\n \t\targvec = tsubst (DECL_TI_ARGS (t), args, complain, in_decl);\n-\t\tspec = (retrieve_specialization \n-\t\t\t(gen_tmpl, argvec,\n-\t\t\t /*class_specializations_p=*/false));\n+\t\thash = hash_tmpl_and_args (gen_tmpl, argvec);\n+\t\tspec = retrieve_specialization (gen_tmpl, argvec, hash);\n \t      }\n \t  }\n \telse\n@@ -8800,7 +9013,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t       processing here.  */\n \t    DECL_EXTERNAL (r) = 1;\n \n-\t    register_specialization (r, gen_tmpl, argvec, false);\n+\t    register_specialization (r, gen_tmpl, argvec, false, hash);\n \t    DECL_TEMPLATE_INFO (r) = tree_cons (tmpl, argvec, NULL_TREE);\n \t    SET_DECL_IMPLICIT_INSTANTIATION (r);\n \t  }\n@@ -9130,7 +9343,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t{\n \t  tree tmpl = most_general_template (DECL_TI_TEMPLATE (decl));\n \t  tree gen_args = tsubst (DECL_TI_ARGS (decl), args, complain, in_decl);\n-\t  r = retrieve_specialization (tmpl, gen_args, false);\n+\t  r = retrieve_specialization (tmpl, gen_args, 0);\n \t}\n       else if (DECL_FUNCTION_SCOPE_P (decl)\n \t       && DECL_TEMPLATE_INFO (DECL_CONTEXT (decl))\n@@ -12098,8 +12311,9 @@ check_instantiated_args (tree tmpl, tree args, tsubst_flags_t complain)\n    the template arguments in TARG_PTR.  */\n \n tree\n-instantiate_template (tree tmpl, tree targ_ptr, tsubst_flags_t complain)\n+instantiate_template (tree tmpl, tree orig_args, tsubst_flags_t complain)\n {\n+  tree targ_ptr = orig_args;\n   tree fndecl;\n   tree gen_tmpl;\n   tree spec;\n@@ -12131,26 +12345,25 @@ instantiate_template (tree tmpl, tree targ_ptr, tsubst_flags_t complain)\n     }\n \n   /* Check to see if we already have this specialization.  */\n-  spec = retrieve_specialization (tmpl, targ_ptr,\n-\t\t\t\t  /*class_specializations_p=*/false);\n-  if (spec != NULL_TREE)\n-    return spec;\n-\n   gen_tmpl = most_general_template (tmpl);\n   if (tmpl != gen_tmpl)\n-    {\n-      /* The TMPL is a partial instantiation.  To get a full set of\n-\t arguments we must add the arguments used to perform the\n-\t partial instantiation.  */\n-      targ_ptr = add_outermost_template_args (DECL_TI_ARGS (tmpl),\n-\t\t\t\t\t      targ_ptr);\n+    /* The TMPL is a partial instantiation.  To get a full set of\n+       arguments we must add the arguments used to perform the\n+       partial instantiation.  */\n+    targ_ptr = add_outermost_template_args (DECL_TI_ARGS (tmpl),\n+\t\t\t\t\t    targ_ptr);\n \n-      /* Check to see if we already have this specialization.  */\n-      spec = retrieve_specialization (gen_tmpl, targ_ptr,\n-\t\t\t\t      /*class_specializations_p=*/false);\n-      if (spec != NULL_TREE)\n-\treturn spec;\n-    }\n+  /* It would be nice to avoid hashing here and then again in tsubst_decl,\n+     but it doesn't seem to be on the hot path.  */\n+  spec = retrieve_specialization (gen_tmpl, targ_ptr, 0);\n+\n+  gcc_assert (tmpl == gen_tmpl\n+\t      || ((fndecl = retrieve_specialization (tmpl, orig_args, 0))\n+\t\t  == spec)\n+\t      || fndecl == NULL_TREE);\n+\n+  if (spec != NULL_TREE)\n+    return spec;\n \n   if (check_instantiated_args (gen_tmpl, INNERMOST_TEMPLATE_ARGS (targ_ptr),\n \t\t\t       complain))\n@@ -15495,25 +15708,28 @@ instantiate_decl (tree d, int defer_ok,\n   if (TREE_CODE (d) == FUNCTION_DECL && DECL_CLONED_FUNCTION_P (d))\n     d = DECL_CLONED_FUNCTION (d);\n \n-  if (DECL_TEMPLATE_INSTANTIATED (d))\n-    /* D has already been instantiated.  It might seem reasonable to\n-       check whether or not D is an explicit instantiation, and, if so,\n-       stop here.  But when an explicit instantiation is deferred\n-       until the end of the compilation, DECL_EXPLICIT_INSTANTIATION\n-       is set, even though we still need to do the instantiation.  */\n+  if (DECL_TEMPLATE_INSTANTIATED (d)\n+      || DECL_TEMPLATE_SPECIALIZATION (d))\n+    /* D has already been instantiated or explicitly specialized, so\n+       there's nothing for us to do here.\n+\n+       It might seem reasonable to check whether or not D is an explicit\n+       instantiation, and, if so, stop here.  But when an explicit\n+       instantiation is deferred until the end of the compilation,\n+       DECL_EXPLICIT_INSTANTIATION is set, even though we still need to do\n+       the instantiation.  */\n     return d;\n \n-  /* If we already have a specialization of this declaration, then\n-     there's no reason to instantiate it.  Note that\n-     retrieve_specialization gives us both instantiations and\n-     specializations, so we must explicitly check\n-     DECL_TEMPLATE_SPECIALIZATION.  */\n   gen_tmpl = most_general_template (tmpl);\n   gen_args = DECL_TI_ARGS (d);\n-  spec = retrieve_specialization (gen_tmpl, gen_args,\n-\t\t\t\t  /*class_specializations_p=*/false);\n-  if (spec != NULL_TREE && DECL_TEMPLATE_SPECIALIZATION (spec))\n-    return spec;\n+\n+  if (tmpl != gen_tmpl)\n+    /* We should already have the extra args.  */\n+    gcc_assert (TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (gen_tmpl))\n+\t\t== TMPL_ARGS_DEPTH (gen_args));\n+  /* And what's in the hash table should match D.  */\n+  gcc_assert ((spec = retrieve_specialization (gen_tmpl, gen_args, 0)) == d\n+\t      || spec == NULL_TREE);\n \n   /* This needs to happen before any tsubsting.  */\n   if (! push_tinst_level (d))\n@@ -17406,4 +17622,19 @@ append_type_to_template_for_access_check (tree templ,\n   append_type_to_template_for_access_check_1 (templ, type_decl, scope);\n }\n \n+/* Set up the hash tables for template instantiations.  */\n+\n+void\n+init_template_processing (void)\n+{\n+  decl_specializations = htab_create_ggc (37,\n+\t\t\t\t\t  hash_specialization,\n+\t\t\t\t\t  eq_specializations,\n+\t\t\t\t\t  ggc_free);\n+  type_specializations = htab_create_ggc (37,\n+\t\t\t\t\t  hash_specialization,\n+\t\t\t\t\t  eq_specializations,\n+\t\t\t\t\t  ggc_free);\n+}\n+\n #include \"gt-cp-pt.h\""}, {"sha": "278c7874bec1415f98dae63e2327f3ac91790cac", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b110bfcc074f222a49d875c5f0f5ea370294b9f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b110bfcc074f222a49d875c5f0f5ea370294b9f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2b110bfcc074f222a49d875c5f0f5ea370294b9f", "patch": "@@ -1,3 +1,7 @@\n+2009-07-02  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/template/spec8.C: Fix.\n+\n 2009-07-02  Michael Matz  <matz@suse.de>\n \n \tPR fortran/32131"}, {"sha": "ccbf17c2f769731f29b0d37f05cbf0415571d8c6", "filename": "gcc/testsuite/g++.dg/template/spec8.C", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b110bfcc074f222a49d875c5f0f5ea370294b9f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fspec8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b110bfcc074f222a49d875c5f0f5ea370294b9f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fspec8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fspec8.C?ref=2b110bfcc074f222a49d875c5f0f5ea370294b9f", "patch": "@@ -5,7 +5,12 @@\n template<class T1> struct A\n {\n   template<class T2> struct B {};\n+  template<class T2> struct C {};\n }; \n \n-template <> template <> struct A<int>::B<int> {};\n-template <> template <class U> struct A<int>::B {}; // { dg-error \"specialization\" }\n+template <> template <> struct A<int>::B<int>;\n+template <> template <class U> struct A<int>::B {};\n+A<int>::B<int> ab;\t\t// { dg-error \"incomplete\" }\n+\n+A<int>::C<char> ac;\n+template <> template <class U> struct A<int>::C {}; // { dg-error \"specialization\" }"}]}