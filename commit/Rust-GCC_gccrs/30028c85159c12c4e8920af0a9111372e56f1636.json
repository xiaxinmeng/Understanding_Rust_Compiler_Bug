{"sha": "30028c85159c12c4e8920af0a9111372e56f1636", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzAwMjhjODUxNTljMTJjNGU4OTIwYWYwYTkxMTEzNzJlNTZmMTYzNg==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2003-01-09T23:15:34Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2003-01-09T23:15:34Z"}, "message": "2003-01-09  Vladimir Makarov  <vmakarov@redhat.com>\n\tMerging changes from itanium-sched-branch:\n\nFrom-SVN: r61132", "tree": {"sha": "4c2dc43818bfc1ad93057e3973541f95b57fd3cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c2dc43818bfc1ad93057e3973541f95b57fd3cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30028c85159c12c4e8920af0a9111372e56f1636", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30028c85159c12c4e8920af0a9111372e56f1636", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30028c85159c12c4e8920af0a9111372e56f1636", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30028c85159c12c4e8920af0a9111372e56f1636/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6ff2fe39337fb23db6ae2011efd6473a88a58132", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ff2fe39337fb23db6ae2011efd6473a88a58132", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ff2fe39337fb23db6ae2011efd6473a88a58132"}], "stats": {"total": 9023, "additions": 6772, "deletions": 2251}, "files": [{"sha": "edae8315f570d84b64fe2a861a5127bd50b60b19", "filename": "gcc/ChangeLog", "status": "modified", "additions": 441, "deletions": 0, "changes": 441, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=30028c85159c12c4e8920af0a9111372e56f1636", "patch": "@@ -1,3 +1,444 @@\n+2003-01-09  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tThe following changes are merged from itanium-sched-branch:\n+\n+\t2003-01-08  David Edelsohn  <edelsohn@gnu.org>\n+\n+\t* doc/md.texi: Clarify assignment of units to automata description.\n+\n+\t2003-01-08  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* genautomata.c (unit_decl): Remove members\n+\t`the_same_automaton_unit' and\n+\t`the_same_automaton_message_reported_p'.\n+\t(process_unit_to_form_the_same_automaton_unit_lists,\n+\tform_the_same_automaton_unit_lists_from_regexp,\n+\tform_the_same_automaton_unit_lists, the_same_automaton_lists):\n+\tRemove them.\n+\t(annotation_message_reported_p): New global variable.\n+\t(check_unit_distribution_in_reserv,\n+\tcheck_regexp_units_distribution): New functions.\n+\t(check_unit_distributions_to_automata): Rewrite it.\n+\n+\t2003-01-04  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* genautomata.c (form_the_same_automaton_unit_lists_from_regexp):\n+\tUse continue instead of break if cycle is too big.\n+\n+\t2002-12-20  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* genautomata.c (check_unit_distributions_to_automata): Output at\n+\tmost one message for a unit.\n+\t(process_unit_to_form_the_same_automaton_unit_lists): Check\n+\tautomaton of units instead of units themself.\n+\n+\t* doc/md.texi: Describe the constraint about assigning unit to\n+\tautomata.\n+\n+\t2002-12-20  Jan Hubicka  <jH@suse.cz>\n+\t\t    Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* genautomata.c (unit_decl): Add new members `min_occ_cycle_num'\n+\tand `in_set_p'.\n+\t(gen_cpu_unit): Initialize the new members.\n+\t(process_regexp_cycles): Calculate minimal finish cycle too.  Set\n+\tup `min_occ_cycle_num'.\n+\t(evaluate_max_reserv_cycles): Change the function call.\n+\t(CLEAR_BIT): New macro.\n+\t(states_union, state_shift): Use the mask.\n+\t(initiate_excl_sets, form_reserv_sets_list): Set up `in_set_p'.\n+\t(form_reservs_matter): New function.\n+\t(make_automaton): Call the function and use the mask.\n+\t(estimate_one_automaton_bound): Take `min_occ_cycle_num' into\n+\taccount.\n+\t\n+\t2002-12-17  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* config/ia64/itanium2.md (lfetch): Change the insn reservation.\n+\n+\t2002-12-17  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* config/ia64/ia64.c (bundling): Try to insert 2 nops for M insn\n+\tfor Itanium.\n+\n+\t2002-12-17  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* config/ia64/ia64.c (ia64_override_options): Make itanium2 as\n+\tdefault cpu.\n+\n+\t2002-12-17  Vladimir Makarov  <vmakarov@redhat.com>\n+\t\t2002-10-31  Dale Johannesen <dalej@apple.com>\n+\n+\t* haifa-sched.c (find_set_reg_weight): New function.\n+\t(find_insn_reg_weight): Use the new function.\n+\t(schedule_block): Do sorting ready queue always\n+\tafter insn issue.\n+\n+\t2002-11-27  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* config/ia64/ia64.c (bundling): Use MFI template instead of MLX.\n+\n+\t2002-11-19  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* haifa-sched.c (choice_entry): New structure.\n+\t(choice_stack, cycle_issued_insns): New variables.\n+\t(max_issue): Rewrite it.\n+\t(choose_ready): Set up ready_try for unknown insns too.\n+\t(schedule_block): Allocate and free choice_stack.  Set up\n+\tand modify cycle_issued_insns.\n+\n+\t* config/ia64/ia64.c (issue_nops_and_insn): Combine insn issue\n+\twith and without filling the bundle.\n+\t(bundling): Combine calls of issue_nops_and_insn.\n+\t\n+\t2002-10-17  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* config/ia64/itanium1.md: New file.\n+\n+\t* config/ia64/itanium2.md: New file.\n+\n+\t* config/ia64/ia64.md: Move DFA descriptions into the new files.\n+\tRemove the old pipeline description.\n+\t\n+\t* config/ia64/ia64.c (ia64_override_options): Add aliases of\n+\titanium processor names.\n+\t\n+\t2002-10-16  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* config/ia64/ia64.c (bundling): Print states for Itanium2 too.\n+\t(ia64_reorg):  Set up queried unit codes for Itanium2 too.\n+\n+\t* config/ia64/ia64.md: Add descriptions for Itanium2.\n+\n+\t2002-10-08  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* config/ia64/ia64.h (processor_type): New enumeration.\n+\t(ia64_tune, ia64_tune_string): New external declarations.\n+\t(TARGET_OPTIONS): Add option `tune='.\n+\n+\t* config/ia64/ia64.c (ia64_tune, ia64_tune_string): New global\n+\tvariables.\n+\t(ia64_override_options): Set up `ia64_tune'.\n+\t(ia64_sched_reorder2): Set up `clocks' only for Itanium.\n+\t(ia64_dfa_new_cycle): Set up `add_cycles' only for Itanium.\n+\t(bundling): Add nops for MM-insns only for Itanium.\n+\t(ia64_reorg): Allocate and free `clocks' and `add_cycles' only for\n+\tItanium.\n+\n+\t* config/ia64/ia64.md (cpu): New attribute.\n+\t(DFA description): Enable it only for Itanium.\n+\t\n+\t2002-10-08  Vladimir Makarov  <vmakarov@redhat.com>\n+\t\t    Richard Henderson  <rth@redhat.com>\n+\n+\t* config/ia64/ia64.h (MASK_TUNE_STOP_BITS): Rename it to\n+\tMASK_EARLY_STOP_BITS.\n+\t(TARGET_TUNE_STOP_BITS): Rename it to TARGET_EARLY_STOP_BITS.\n+\t(TARGET_SWITCHES): Rename option `tune-stop-bits' to\n+\t`early-stop-bits'.\n+\t\n+\t* config/ia64/ia64.c (ia64_dfa_new_cycle,\n+\tfinal_emit_insn_group_barriers): Use TARGET_EARLY_STOP_BITS\n+\tinstead of TARGET_TUNE_STOP_BITS.\n+\t\n+\t* doc/invoke.texi: Rename option `-mtune-stop-bits' to\n+\t`-mearly-stop-bits'.\n+\n+\t* config/ia64/ia64.c (automata_option \"v\"): Comment it.\n+\t\n+\t2002-10-07  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+        * config/ia64/ia64.h (MASK_TUNE_STOP_BITS, TARGET_TUNE_STOP_BITS):\n+\tNew macros.\n+\t(TARGET_SWITCHES): Add entries for the new option.\n+\t\n+\t* config/ia64/ia64.c (dfa_stop_insn, last_scheduled_insn, rtx\n+\tdfa_pre_cycle_insn, ia64_nop): Don't make them as roots for GC.\n+\t(stops_p, stop_before_p, clocks_length, clocks, add_cycles): New\n+\tglobal variables.\n+\t(ia64_sched_reorder2): Set up `clocks'.\n+\t(ia64_variable_issue): Set up `stops_p' and reset `stop_before_p'.\n+\t(ia64_dfa_new_cycle): Set up add_cycle.  Permit sorting ready\n+\tqueue when TARGET_TUNE_STOP_BITS.\n+\t(bundling): Insert additional nops for MM-insns.\n+\t(final_emit_insn_group_barriers): Add insertion of stop bits\n+\taccording `stops_p'.\n+\t(ia64_reorg): Initiate the new varibales.\n+\n+\t* doc/invoke.texi: Add description of option `-mtune-stop-bits'.\n+\t\n+\t2002-10-02  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* haifa-sched.c (schedule_block): Modify INSN_TICK of depended\n+\tinsns at the end of block insn scheduling.\n+\n+\t2002-09-30  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* sched-deps.c (remove_dependence, group_leader): Remove it.\n+\t(add_dependence): Add dependence to group leader to.\n+\t(set_sched_group_p): Add dependence to the first insn of the\n+\tschedule group too.\n+\t(sched_analyze_insn): Make dependence to jump as anti-dependence.\n+\tChange true dependence by anti-dependence when\n+\t`reg_pending_barrier'.\n+\n+\t* sched-rgn.c (init_ready_list, can_schedule_ready_p,\n+\tadd_branch_dependences): Ignore schedule groups.\n+\n+\t* sched-ebb.c (init_ready_list): Ditto.\n+\n+\t* (move_insn, set_priorities): Ditto.\n+\n+\t* config/ia64/ia64.c (ia64_sched_init): Check that schedule group\n+\tflag is clear after reload.\n+\t(adjust_cost): Change cost only for output dependencies.\n+\t\n+\t* config/ia64/ia64.md: Add more insns into bypass for MM-insns.\n+\t\n+\t2002-09-26  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* Makefile.in (sched-ebb.o): Add `$(TARGET_H)' to the entry.\n+\n+\t* target.h (gcc_target): Add member\n+\t`dependencies_evaluation_hook'.\n+\n+\t* target-def.h (TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK): New\n+\tmacro.\n+\t(TARGET_SCHED): Add initiatialization of the new member.\n+\n+\t* sched-ebb.c: Include `target.h'.\n+\t(schedule_ebb): Call `dependencies_evaluation_hook'.\n+\n+\t* sched-rgn.c (schedule_region): Call\n+\t`dependencies_evaluation_hook'.\n+\n+\t* config/ia64/ia64.c (TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK):\n+\tNew macro.\n+\t(ia64_dependencies_evaluation_hook): New function.\n+\n+\t* doc/tm.texi (TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK):\n+\tDescribe the new hook.\n+\t\n+\t2002-09-25  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* target.h (gcc_target): Add members\n+\t`first_cycle_multipass_dfa_lookahead_guard' and `dfa_new_cycle'.\n+\n+\t* target-def.h (TARGET_SCHED_DFA_NEW_CYCLE,\n+\tTARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD): New\n+\tmacros.\n+\t(TARGET_SCHED): Add initiatialization of the new members.\n+\n+\t* haifa-sched.c (schedule_insn): Update last_clock_var for the 1st\n+\tinsn scheduling too.\n+\t(choose_ready): Use `first_cycle_multipass_dfa_lookahead_guard' to\n+\tinitialize `ready_try'.\n+\t(schedule_block): Use `dfa_new_cycle'.  Sort `ready' only unless\n+\t`dfa_new_cycle' says not to do it.\n+\t\n+\t* config/ia64/ia64.md: Add DFA Itanium 1 description for insn\n+\tbundling.\n+\n+\t* config/ia64/ia64.h (CPU_UNITS_QUERY): New macro.\n+\n+\t* config/ia64/ia64.c: Include `hashtab.h'.\n+\t(ia64_first_cycle_multipass_dfa_lookahead_guard,\n+\tia64_dfa_new_cycle, final_emit_insn_group_barriers,\n+\tia64_dfa_sched_reorder, get_free_bundle_state, free_bundle_state,\n+\tinitiate_bundle_states, finish_bundle_states, bundle_state_hash,\n+\tbundle_state_eq_p, insert_bundle_state,\n+\tinitiate_bundle_state_table, finish_bundle_state_table,\n+\ttry_issue_nops, try_issue_insn, issue_nops_and_insn, get_max_pos,\n+\tget_template, get_next_important_insn, bundling): New functions.\n+\t(ia64_internal_sched_reorder): Remove it.\n+\t(TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD,\n+\tTARGET_SCHED_DFA_NEW_CYCLE): New macros.\n+\t(ia64_safe_itanium_requires_unit0): Remove it.\n+\t(group_barrier_needed_p): Place group barrier right before a real\n+\tinsn.\n+\t(bundle, ia64_packet, NR_PACKETS, type_names, packets, packets):\n+\tRemove them.\n+\t(bundle_name): New variable.\n+\t(_0mii_, _0mmi_, _0mfi_, _0mmf_, _0bbb_, _0mbb_, _0mib_, _0mmb_,\n+\t_0mfb_, _0mlx_, _1mii_, _1mmi_, _1mfi_, _1mmf_, _1bbb_, _1mbb_,\n+\t_1mib_, _1mmb_, _1mfb_, _1mlx_, pos_1, pos_2, pos_3, pos_4, pos_5,\n+\tpos_6, dfa_stop_insn, last_scheduled_insn, dfa_state_size,\n+\ttemp_dfa_state, prev_cycle_state): New global variables.\n+\t(insn_matches_slot, maybe_rotate, finish_last_head,\n+\trotate_one_bundle, rotate_one_bundles, nop_cycles_until,\n+\tcycle_end_fill_slots, packet_matches_p, get_split, find_best_insn,\n+\tfind_best_packet, itanium_reorder, dump_current_packet,\n+\tschedule_stop, gen_nop_type, ia64_emit_nops): Remove them.\n+\t(sched_data, sched_ready, sched_types): Remove them.\n+\t(ia64_sched_init): Initiate only `last_scheduled_insn' and call\n+\t`init_insn_group_barriers'.\n+\t(ia64_sched_reorder, ia64_sched_reorder2): Call\n+\tia64_dfa_sched_reorder.\n+\t(ia64_variable_issue): Rewrite it.\n+\t(bundle_state): New structure.\n+\t(index_to_bundle_states, bundle_states_num,\n+\tallocated_bundle_states_chain, free_bundle_state_chain): New\n+\tglobal variables.\n+\t(ia64_sched_finish): Add stop bits and call `bundling' after the\n+\t2nd insn scheduling.\n+\t(ia64_use_dfa_pipeline_interface): Return zero always.\n+\t(ia64_first_cycle_multipass_dfa_lookahead): Return 6 for the 2nd\n+\tinsn scheduling.\n+\t(ia64_init_dfa_pre_cycle_insn): Initialize `dfa_state_size',\n+\t`temp_dfa_state', `prev_cycle_state', and `dfa_stop_insn'.\n+\t(ia64_reorg): Add bundling insns.\n+\n+\t* doc/tm.texi\n+\t(TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD,\n+\tTARGET_SCHED_DFA_NEW_CYCLE): Describe the new hooks.\n+\t\n+\t2002-09-23  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* config/ia64/ia64.md: Add Itanium1 DFA description.\n+\t(itanium_class): Add `nop' and `pre_cycle'.  Add\n+\tdefine_function_unit for `nop'.\n+\t(nop): Change attribute `itanium_class'.\n+\t(pre_cycle): New define_insn.\n+\n+\t* config/ia64/ia64-protos.h (bundling_p): New external variable.\n+\t(ia64_st_address_bypass_p, ia64_ld_address_bypass_p,\n+\tia64_produce_address_p): New function prototypes.\n+\n+\t* config/ia64/ia64.c (bundling_p): New global variable.\n+\t(ia64_use_dfa_pipeline_interface,\n+\tia64_first_cycle_multipass_dfa_lookahead,\n+\tia64_init_dfa_pre_cycle_insn, ia64_dfa_pre_cycle_insn): New\n+\tfunctions.\n+\t(TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE,\n+\tTARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD,\n+\tTARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN,\n+\tTARGET_SCHED_DFA_PRE_CYCLE_INSN): New macros.\n+\t(ia64_sched_init, ia64_sched_reorder, ia64_sched_reorder2,\n+\tia64_variable_issue, ia64_sched_finish): Do nothing before reload.\n+\t(dfa_pre_cycle_insn): New variable.\n+\t\n+\t2002-09-20  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* rtl.def (FINAL_PRESENCE_SET, FINAL_ABSENCE_SET): New\n+\tconstructions.\n+\n+\t* genattrtab.h (gen_final_presence_set, gen_final_absence_set):\n+\tNew function prototypes.\n+\n+\t* genattrtab.c (main): Process the new constructions.\n+\n+\t* genautomata.c (gen_presence_absence_set,\n+\tprocess_presence_absence_names, process_presence_absence_patterns,\n+\tadd_presence_absence, check_absence_pattern_sets): Add parameter\n+\t`final_p'.\n+\t(unit_decl): Add new members `final_presence_list' and\n+\t`final_absence_list'.\n+\t(unit_pattern_rel_decl): Add new member `final_p'.\n+\t(gen_final_presence_set, gen_final_absence_set): New functions.\n+\t(process_decls): Use member `final_p'.\n+\t(temp_reserv): New global variable.\n+\t(reserv_sets_are_intersected): Add processing `final_presence_set'\n+\tand `final_absence_set'.\n+\t(initiate_states): Allocate `temp_reserv'.\n+\t(unit_final_presence_set_table, unit_final_absence_set_table): New\n+\tgloabal variables.\n+\t(initiate_presence_absence_pattern_sets): Initiate them.\n+\t(NDFA_to_DFA): Fix typo.\n+\t(output_description): Output `final_presence_set' and\n+\t`final_absence_set'.\n+\n+\t* doc/md.texi (final_presence_set, final_absence_set): Describe\n+\tthem.\n+\t\n+\t2002-09-20  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* genautomata.c (transform_3): Process a missing case (nothing on\n+\tunit place).\n+\n+\t2002-09-20  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* rtl.def (DEFINE_QUERY_CPU_UNIT, AUTOMATA_OPTION): Change\n+\tcomments about queried units and the minimization.\n+\t\n+\t* doc/md.texi: Ditto.\n+\t\n+\t* genautomata.c (create_composed_state): Return nonzero if the new\n+\tstate has been created.\n+\t(first_cycle_unit_presence): New function.\n+\t(state_is_differed): Add new parameter.  Use the new function.\n+\tTake queried units into account.\n+\t(partition_equiv_class): Pass additional parameter to\n+\t`state_is_differed'.\n+\t(merge_states): Process composed states too.\n+\t(build_automaton, create_automata, output_min_issue_delay_table,\n+\toutput_tables, output_statistics): Output more information.\n+\t(output_reserved_units_table): Use function\n+\t`first_cycle_unit_presence'.\n+\t(output_tables): Output table of queried units even if the\n+\tminimization is switched on.\n+\t(write_automata): Output code for querying units even if the\n+\tminimization is switched on.\n+\t\n+\t2002-09-19  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* rtl.def (PRESENCE_SET, ABSENCE_SET): Add comments about extended\n+\tsyntax of the constructions.\n+\t\n+\t* doc/md.texi (PRESENCE_SET, ABSENCE_SET): Add description of\n+\textended syntax of the constructions.\n+\t\n+\t* genautomata.c (unit_rel_decl): Rename it to\n+\t`unit_pattern_rel_decl'.\n+\t(pattern_set_el, pattern_reserv): New structures.\n+\t(pattern_set_el_t, pattern_reserv_t): New types.\n+\t(gen_presence_absence_set): New function.\n+\t(process_presence_absence): Remove it.\n+\t(process_presence_absence_names,\n+\tprocess_presence_absence_patterns): New functions.\n+\t(get_presence_absence_set): Remove it.\n+\t(initiate_presence_absence_sets): Rename it on\n+\t`initiate_presence_absence_pattern_sets'.  Use new function\n+\t`form_reserv_sets_list'.\n+\t(form_reserv_sets_list, check_presence_pattern_sets,\n+\tcheck_absence_pattern_sets, output_pattern_set_el_list): New\n+\tfunctions.\n+\t(unit_decl): Change types of members `presence_list' and\n+\t`absence_list'.\n+\t(unit_rel_decl): Rename member `names_num' to `all_names_num'.\n+\t(decl): Change types of members `excl', `presence', and `absence'.\n+\t(get_str_vect): Rename `par_flag' to `paren_p'.  Add null element\n+\tat the end of the vector.\n+\t(gen_cpu_unit, gen_query_cpu_unit, gen_bypass, gen_excl_set,\n+\tgen_automaton, gen_regexp_repeat, gen_regexp_allof,\n+\tgen_regexp_oneof, gen_regexp_sequence): Use boolean values.\n+\t(gen_presence_set, gen_absence_set): Use new function\n+\t`gen_presence_absence_set'.\n+\t(add_presence_absence): Process `pattern_list' instead of\n+\t`source_list'.\n+\t(process_decls): USe new functions\n+\t`process_presence_absence_names' and\n+\t`process_presence_absence_patterns'.\n+\t(reserv_sets_are_intersected): Use new function\n+\t`check_presence_pattern_sets'.\n+\t(presence_set, absence_set): Remove them.\n+\t(unit_presence_set_table, unit_absence_set_table): New global\n+\tvariables.\n+\t(output_description): Use new function\n+\t`output_pattern_set_el_list'.\n+\t(generate): Use `initiate_presence_absence_pattern_sets'.\n+\t\n+\t2002-09-18  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* genattr.c (main): Add output of prototype of new interface\n+\tfunction `dfa_clean_insn_cache'.\n+\n+\t* genautomata.c (output_dfa_clean_insn_cache_func): New function.\n+\t(DFA_CLEAN_INSN_CACHE_FUNC_NAME): New macro.\n+\t(output_dfa_start_func): Use function `dfa_clean_insn_cache' in\n+\tthe generated code.\n+\t(write_automata): Call the new function.\n+\t\n+\n Thu Jan  9 22:47:38 CET 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.md (unit, prefix_0f, memory attributes): Hanlde sseicvt correctly."}, {"sha": "63b8572067e92dfe9264ea00791e6879edab11b7", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=30028c85159c12c4e8920af0a9111372e56f1636", "patch": "@@ -27,7 +27,11 @@ extern GTY(()) rtx ia64_compare_op1;\n \n /* Functions defined in ia64.c */\n \n+extern int bundling_p;\n #ifdef RTX_CODE\n+extern int ia64_st_address_bypass_p PARAMS((rtx, rtx));\n+extern int ia64_ld_address_bypass_p PARAMS((rtx, rtx));\n+extern int ia64_produce_address_p PARAMS((rtx));\n extern int call_operand PARAMS((rtx, enum machine_mode));\n extern int sdata_symbolic_operand PARAMS((rtx, enum machine_mode));\n extern int got_symbolic_operand PARAMS((rtx, enum machine_mode));"}, {"sha": "039d11aaac79e91af9e35a5898e7e16e3369f9a3", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 1380, "deletions": 1289, "changes": 2669, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=30028c85159c12c4e8920af0a9111372e56f1636"}, {"sha": "970827bbf4d9445e1e04136fd9448e92302a789c", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=30028c85159c12c4e8920af0a9111372e56f1636", "patch": "@@ -95,6 +95,8 @@ extern int target_flags;\n \n #define MASK_DWARF2_ASM 0x40000000\t/* test dwarf2 line info via gas.  */\n \n+#define MASK_EARLY_STOP_BITS 0x00002000 /* tune stop bits for the model.  */\n+\n #define TARGET_BIG_ENDIAN\t(target_flags & MASK_BIG_ENDIAN)\n \n #define TARGET_GNU_AS\t\t(target_flags & MASK_GNU_AS)\n@@ -137,6 +139,7 @@ extern int ia64_tls_size;\n #define TARGET_TLS14\t\t(ia64_tls_size == 14)\n #define TARGET_TLS22\t\t(ia64_tls_size == 22)\n #define TARGET_TLS64\t\t(ia64_tls_size == 64)\n+#define TARGET_EARLY_STOP_BITS\t(target_flags & MASK_EARLY_STOP_BITS)\n \n #define TARGET_HPUX_LD\t\t0\n \n@@ -188,6 +191,10 @@ extern int ia64_tls_size;\n       N_(\"Enable Dwarf 2 line debug info via GNU as\")},\t\t\t\\\n   { \"no-dwarf2-asm\", \t-MASK_DWARF2_ASM,\t\t\t\t\\\n       N_(\"Disable Dwarf 2 line debug info via GNU as\")},\t\t\\\n+  { \"early-stop-bits\", MASK_EARLY_STOP_BITS,\t\t\t\t\\\n+      N_(\"Enable earlier placing stop bits for better scheduling\")},\t\\\n+  { \"no-early-stop-bits\", -MASK_EARLY_STOP_BITS,\t\t\t\\\n+      N_(\"Disable earlier placing stop bits\")},\t\t\t\t\\\n   SUBTARGET_SWITCHES\t\t\t\t\t\t\t\\\n   { \"\",\t\t\tTARGET_DEFAULT | TARGET_CPU_DEFAULT,\t\t\\\n       NULL }\t\t\t\t\t\t\t\t\\\n@@ -213,12 +220,30 @@ extern int ia64_tls_size;\n \n extern const char *ia64_fixed_range_string;\n extern const char *ia64_tls_size_string;\n+\n+/* Which processor to schedule for. The cpu attribute defines a list\n+   that mirrors this list, so changes to i64.md must be made at the\n+   same time.  */\n+\n+enum processor_type\n+{\n+  PROCESSOR_ITANIUM,\t\t\t/* Original Itanium. */\n+  PROCESSOR_ITANIUM2,\n+  PROCESSOR_max\n+};\n+\n+extern enum processor_type ia64_tune;\n+\n+extern const char *ia64_tune_string;\n+\n #define TARGET_OPTIONS \\\n {\t\t\t\t\t\t\t\t\t\\\n   { \"fixed-range=\", \t&ia64_fixed_range_string,\t\t\t\\\n       N_(\"Specify range of registers to make fixed\")},\t\t\t\\\n   { \"tls-size=\",\t&ia64_tls_size_string,\t\t\t\t\\\n       N_(\"Specify bit size of immediate TLS offsets\")},\t\t\t\\\n+  { \"tune=\",\t\t&ia64_tune_string,\t\t\t\t\\\n+      N_(\"Schedule code for given CPU\")},\t\t\t\t\\\n }\n \n /* Sometimes certain combinations of command options do not make sense on a\n@@ -2485,4 +2510,9 @@ enum fetchop_code {\n #undef  PROFILE_BEFORE_PROLOGUE\n #define PROFILE_BEFORE_PROLOGUE 1\n \n+\f\n+\n+/* Switch on code for querying unit reservations.  */\n+#define CPU_UNITS_QUERY 1\n+\n /* End of ia64.h */"}, {"sha": "a96e92fc900f05e40981d800d0b97eceea7a3f60", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 31, "deletions": 72, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=30028c85159c12c4e8920af0a9111372e56f1636", "patch": "@@ -91,6 +91,10 @@\n ;; ::\n ;; ::::::::::::::::::::\n \n+;; Processor type.  This attribute must exactly match the processor_type\n+;; enumeration in ia64.h.\n+(define_attr \"cpu\" \"itanium,itanium2\" (const (symbol_ref \"ia64_tune\")))\n+\n ;; Instruction type.  This primarily determines how instructions can be\n ;; packed in bundles, and secondarily affects scheduling to function units.\n \n@@ -110,8 +114,8 @@\n (define_attr \"itanium_class\" \"unknown,ignore,stop_bit,br,fcmp,fcvtfx,fld,\n \tfmac,fmisc,frar_i,frar_m,frbr,frfr,frpr,ialu,icmp,ilog,ishf,ld,\n \tchk_s,long_i,mmmul,mmshf,mmshfi,rse_m,scall,sem,stf,st,syst_m0,\n-\tsyst_m,tbit,toar_i,toar_m,tobr,tofr,topr,xmpy,xtd,nop_b,nop_f,\n-\tnop_i,nop_m,nop_x,lfetch\"\n+\tsyst_m,tbit,toar_i,toar_m,tobr,tofr,topr,xmpy,xtd,nop,nop_b,nop_f,\n+\tnop_i,nop_m,nop_x,lfetch,pre_cycle\"\n   (const_string \"unknown\"))\n \n ;; chk_s has an I and an M form; use type A for convenience.\n@@ -146,76 +150,23 @@\n (define_attr \"predicable\" \"no,yes\" (const_string \"yes\"))\n \n \f\n-;; ::::::::::::::::::::\n-;; ::\n-;; :: Function Units\n-;; ::\n-;; ::::::::::::::::::::\n \n-;; We define 6 \"dummy\" functional units.  All the real work to decide which\n-;; insn uses which unit is done by our MD_SCHED_REORDER hooks.  We only\n-;; have to ensure here that there are enough copies of the dummy unit so\n-;; that the scheduler doesn't get confused by MD_SCHED_REORDER.\n-;; Other than the 6 dummies for normal insns, we also add a single dummy unit\n-;; for stop bits.\n-\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"br\")     0 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"scall\")  0 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"fcmp\")   2 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"fcvtfx\") 7 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"fld\")    9 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"fmac\")   5 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"fmisc\")  5 0)\n-\n-;; There is only one insn `mov = ar.bsp' for frar_i:\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"frar_i\") 13 0)\n-;; There is only ony insn `mov = ar.unat' for frar_m:\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"frar_m\") 6 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"frbr\")   2 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"frfr\")   2 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"frpr\")   2 0)\n-\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"ialu\")   1 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"icmp\")   1 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"ilog\")   1 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"ishf\")   1 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"ld\")     2 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"long_i\") 1 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"mmmul\")  2 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"mmshf\")  2 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"mmshfi\")  2 0)\n-\n-;; Now we have only one insn (flushrs) of such class.  We assume that flushrs\n-;; is the 1st syllable of the bundle after stop bit.\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"rse_m\")  0 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"sem\")   11 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"stf\")    1 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"st\")     1 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"syst_m0\") 1 0)\n-;; Now we use only one insn `mf'.  Therfore latency time is set up to 0.\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"syst_m\") 0 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"tbit\")   1 0)\n-\n-;; There is only one insn `mov ar.pfs =' for toar_i therefore we use\n-;; latency time equal to 0:\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"toar_i\") 0 0)\n-;; There are only ony 2 insns `mov ar.ccv =' and `mov ar.unat =' for toar_m:\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"toar_m\") 5 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"tobr\")   1 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"tofr\")   9 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"topr\")   1 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"xmpy\")   7 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"xtd\")    1 0)\n-\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"nop_m\")  0 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"nop_i\")  0 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"nop_f\")  0 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"nop_b\")  0 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"nop_x\")  0 0)\n-\n-(define_function_unit \"stop_bit\" 1 1 (eq_attr \"itanium_class\" \"stop_bit\") 0 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"ignore\") 0 0)\n-(define_function_unit \"dummy\" 6 1 (eq_attr \"itanium_class\" \"unknown\") 0 0)\n+;; DFA descriptions of ia64 processors used for insn scheduling and\n+;; bundling.\n+\n+(automata_option \"ndfa\")\n+\n+;; Uncomment the following line to output automata for debugging.\n+;; (automata_option \"v\")\n+\n+(automata_option \"w\")\n+\n+;;(automata_option \"no-minimization\")\n+\n+\n+(include \"itanium1.md\")\n+(include \"itanium2.md\")\n+\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -5089,7 +5040,7 @@\n   [(const_int 0)]\n   \"\"\n   \"nop 0\"\n-  [(set_attr \"itanium_class\" \"unknown\")])\n+  [(set_attr \"itanium_class\" \"nop\")])\n \n (define_insn \"nop_m\"\n   [(const_int 1)]\n@@ -5121,6 +5072,14 @@\n   \"\"\n   [(set_attr \"itanium_class\" \"nop_x\")])\n \n+;; The following insn will be never generated.  It is used only by\n+;; insn scheduler to change state before advancing cycle.\n+(define_insn \"pre_cycle\"\n+  [(const_int 6)]\n+  \"\"\n+  \"\"\n+  [(set_attr \"itanium_class\" \"pre_cycle\")])\n+\n (define_insn \"bundle_selector\"\n   [(unspec [(match_operand 0 \"const_int_operand\" \"\")] UNSPEC_BUNDLE_SELECTOR)]\n   \"\""}, {"sha": "2728ed3de2591ac4db906d47ea5d02b6b04bd677", "filename": "gcc/config/ia64/itanium1.md", "status": "added", "additions": 1616, "deletions": 0, "changes": 1616, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fconfig%2Fia64%2Fitanium1.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fconfig%2Fia64%2Fitanium1.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fitanium1.md?ref=30028c85159c12c4e8920af0a9111372e56f1636", "patch": "@@ -0,0 +1,1616 @@\n+;; Itanium1 (original Itanium) DFA descriptions for insn scheduling\n+;; and bundling.\n+;; Copyright (C) 2002 Free Software Foundation, Inc.\n+;; Contributed by Vladimir Makarov <vmakarov@redhat.com>.\n+;;\n+;; This file is part of GNU CC.\n+;;\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.  */\n+;;\n+\n+\n+/* This is description of pipeline hazards based on DFA.  The\n+   following constructions can be used for this:\n+   \n+   o define_cpu_unit string [string]) describes a cpu functional unit\n+     (separated by comma).\n+\n+     1st operand: Names of cpu function units.\n+     2nd operand: Name of automaton (see comments for\n+     DEFINE_AUTOMATON).\n+\n+     All define_reservations and define_cpu_units should have unique\n+     names which can not be \"nothing\".\n+\n+   o (exclusion_set string string) means that each CPU function unit\n+     in the first string can not be reserved simultaneously with each\n+     unit whose name is in the second string and vise versa.  CPU\n+     units in the string are separated by commas. For example, it is\n+     useful for description CPU with fully pipelined floating point\n+     functional unit which can execute simultaneously only single\n+     floating point insns or only double floating point insns.\n+\n+   o (presence_set string string) means that each CPU function unit in\n+     the first string can not be reserved unless at least one of\n+     pattern of units whose names are in the second string is\n+     reserved.  This is an asymmetric relation.  CPU units or unit\n+     patterns in the strings are separated by commas.  Pattern is one\n+     unit name or unit names separated by white-spaces.\n+ \n+     For example, it is useful for description that slot1 is reserved\n+     after slot0 reservation for a VLIW processor.  We could describe\n+     it by the following construction\n+\n+         (presence_set \"slot1\" \"slot0\")\n+\n+     Or slot1 is reserved only after slot0 and unit b0 reservation.\n+     In this case we could write\n+\n+         (presence_set \"slot1\" \"slot0 b0\")\n+\n+     All CPU functional units in a set should belong to the same\n+     automaton.\n+\n+   o (final_presence_set string string) is analogous to\n+     `presence_set'.  The difference between them is when checking is\n+     done.  When an instruction is issued in given automaton state\n+     reflecting all current and planned unit reservations, the\n+     automaton state is changed.  The first state is a source state,\n+     the second one is a result state.  Checking for `presence_set' is\n+     done on the source state reservation, checking for\n+     `final_presence_set' is done on the result reservation.  This\n+     construction is useful to describe a reservation which is\n+     actually two subsequent reservations.  For example, if we use\n+\n+         (presence_set \"slot1\" \"slot0\")\n+\n+     the following insn will be never issued (because slot1 requires\n+     slot0 which is absent in the source state).\n+\n+         (define_reservation \"insn_and_nop\" \"slot0 + slot1\")\n+\n+     but it can be issued if we use analogous `final_presence_set'.\n+\n+   o (absence_set string string) means that each CPU function unit in\n+     the first string can be reserved only if each pattern of units\n+     whose names are in the second string is not reserved.  This is an\n+     asymmetric relation (actually exclusion set is analogous to this\n+     one but it is symmetric).  CPU units or unit patterns in the\n+     string are separated by commas.  Pattern is one unit name or unit\n+     names separated by white-spaces.\n+\n+     For example, it is useful for description that slot0 can not be\n+     reserved after slot1 or slot2 reservation for a VLIW processor.\n+     We could describe it by the following construction\n+\n+        (absence_set \"slot2\" \"slot0, slot1\")\n+\n+     Or slot2 can not be reserved if slot0 and unit b0 are reserved or\n+     slot1 and unit b1 are reserved .  In this case we could write\n+\n+        (absence_set \"slot2\" \"slot0 b0, slot1 b1\")\n+\n+     All CPU functional units in a set should to belong the same\n+     automaton.\n+\n+   o (final_absence_set string string) is analogous to `absence_set' but\n+     checking is done on the result (state) reservation.  See comments\n+     for final_presence_set.\n+\n+   o (define_bypass number out_insn_names in_insn_names) names bypass with\n+     given latency (the first number) from insns given by the first\n+     string (see define_insn_reservation) into insns given by the\n+     second string.  Insn names in the strings are separated by\n+     commas.\n+\n+   o (define_automaton string) describes names of an automaton\n+     generated and used for pipeline hazards recognition.  The names\n+     are separated by comma.  Actually it is possibly to generate the\n+     single automaton but unfortunately it can be very large.  If we\n+     use more one automata, the summary size of the automata usually\n+     is less than the single one.  The automaton name is used in\n+     define_cpu_unit.  All automata should have unique names.\n+\n+   o (automata_option string) describes option for generation of\n+     automata.  Currently there are the following options:\n+\n+     o \"no-minimization\" which makes no minimization of automata.\n+       This is only worth to do when we are debugging the description\n+       and need to look more accurately at reservations of states.\n+\n+     o \"ndfa\" which makes automata with nondetermenistic reservation\n+        by insns.\n+\n+   o (define_reservation string string) names reservation (the first\n+     string) of cpu functional units (the 2nd string).  Sometimes unit\n+     reservations for different insns contain common parts.  In such\n+     case, you describe common part and use one its name (the 1st\n+     parameter) in regular expression in define_insn_reservation.  All\n+     define_reservations, define results and define_cpu_units should\n+     have unique names which can not be \"nothing\".\n+\n+   o (define_insn_reservation name default_latency condition regexpr)\n+     describes reservation of cpu functional units (the 3nd operand)\n+     for instruction which is selected by the condition (the 2nd\n+     parameter).  The first parameter is used for output of debugging\n+     information.  The reservations are described by a regular\n+     expression according the following syntax:\n+\n+       regexp = regexp \",\" oneof\n+              | oneof\n+\n+       oneof = oneof \"|\" allof\n+             | allof\n+\n+       allof = allof \"+\" repeat\n+             | repeat\n+ \n+       repeat = element \"*\" number\n+              | element\n+\n+       element = cpu_function_name\n+               | reservation_name\n+               | result_name\n+               | \"nothing\"\n+               | \"(\" regexp \")\"\n+\n+       1. \",\" is used for describing start of the next cycle in\n+          reservation.\n+\n+       2. \"|\" is used for describing the reservation described by the\n+          first regular expression *or* the reservation described by\n+          the second regular expression *or* etc.\n+\n+       3. \"+\" is used for describing the reservation described by the\n+          first regular expression *and* the reservation described by\n+          the second regular expression *and* etc.\n+\n+       4. \"*\" is used for convinience and simply means sequence in\n+          which the regular expression are repeated NUMBER times with\n+          cycle advancing (see \",\").\n+\n+       5. cpu function unit name which means reservation.\n+\n+       6. reservation name -- see define_reservation.\n+\n+       7. string \"nothing\" means no units reservation.\n+\n+*/\n+\n+(define_automaton \"one\")\n+\n+;;   All possible combinations of bundles/syllables\n+(define_cpu_unit \"1_0m.ii, 1_0m.mi, 1_0m.fi, 1_0m.mf, 1_0b.bb, 1_0m.bb,\\\n+                  1_0m.ib, 1_0m.mb, 1_0m.fb, 1_0m.lx\" \"one\")\n+(define_cpu_unit \"1_0mi.i, 1_0mm.i, 1_0mf.i, 1_0mm.f, 1_0bb.b, 1_0mb.b,\\\n+                  1_0mi.b, 1_0mm.b, 1_0mf.b, 1_0mlx.\" \"one\")\n+(define_cpu_unit \"1_0mii., 1_0mmi., 1_0mfi., 1_0mmf., 1_0bbb., 1_0mbb.,\\\n+                  1_0mib., 1_0mmb., 1_0mfb.\" \"one\")\n+\n+(define_cpu_unit \"1_1m.ii, 1_1m.mi, 1_1m.fi, 1_1b.bb, 1_1m.bb,\\\n+                  1_1m.ib, 1_1m.mb, 1_1m.fb, 1_1m.lx\" \"one\")\n+(define_cpu_unit \"1_1mi.i, 1_1mm.i, 1_1mf.i, 1_1bb.b, 1_1mb.b,\\\n+                  1_1mi.b, 1_1mm.b, 1_1mf.b, 1_1mlx.\" \"one\")\n+(define_cpu_unit \"1_1mii., 1_1mmi., 1_1mfi., 1_1bbb., 1_1mbb.,\\\n+                  1_1mib., 1_1mmb., 1_1mfb.\" \"one\")\n+\n+;; Slot 1\n+(exclusion_set \"1_0m.ii\"\n+   \"1_0m.mi, 1_0m.fi, 1_0m.mf, 1_0b.bb, 1_0m.bb, 1_0m.ib, 1_0m.mb, 1_0m.fb,\\\n+    1_0m.lx\")\n+(exclusion_set \"1_0m.mi\"\n+   \"1_0m.fi, 1_0m.mf, 1_0b.bb, 1_0m.bb, 1_0m.ib, 1_0m.mb, 1_0m.fb, 1_0m.lx\")\n+(exclusion_set \"1_0m.fi\"\n+   \"1_0m.mf, 1_0b.bb, 1_0m.bb, 1_0m.ib, 1_0m.mb, 1_0m.fb, 1_0m.lx\")\n+(exclusion_set \"1_0m.mf\"\n+   \"1_0b.bb, 1_0m.bb, 1_0m.ib, 1_0m.mb, 1_0m.fb, 1_0m.lx\")\n+(exclusion_set \"1_0b.bb\" \"1_0m.bb, 1_0m.ib, 1_0m.mb, 1_0m.fb, 1_0m.lx\")\n+(exclusion_set \"1_0m.bb\" \"1_0m.ib, 1_0m.mb, 1_0m.fb, 1_0m.lx\")\n+(exclusion_set \"1_0m.ib\" \"1_0m.mb, 1_0m.fb, 1_0m.lx\")\n+(exclusion_set \"1_0m.mb\" \"1_0m.fb, 1_0m.lx\")\n+(exclusion_set \"1_0m.fb\" \"1_0m.lx\")\n+\n+;; Slot 2\n+(exclusion_set \"1_0mi.i\"\n+   \"1_0mm.i, 1_0mf.i, 1_0mm.f, 1_0bb.b, 1_0mb.b, 1_0mi.b, 1_0mm.b, 1_0mf.b,\\\n+    1_0mlx.\")\n+(exclusion_set \"1_0mm.i\"\n+   \"1_0mf.i, 1_0mm.f, 1_0bb.b, 1_0mb.b, 1_0mi.b, 1_0mm.b, 1_0mf.b, 1_0mlx.\")\n+(exclusion_set \"1_0mf.i\"\n+   \"1_0mm.f, 1_0bb.b, 1_0mb.b, 1_0mi.b, 1_0mm.b, 1_0mf.b, 1_0mlx.\")\n+(exclusion_set \"1_0mm.f\"\n+   \"1_0bb.b, 1_0mb.b, 1_0mi.b, 1_0mm.b, 1_0mf.b, 1_0mlx.\")\n+(exclusion_set \"1_0bb.b\" \"1_0mb.b, 1_0mi.b, 1_0mm.b, 1_0mf.b, 1_0mlx.\")\n+(exclusion_set \"1_0mb.b\" \"1_0mi.b, 1_0mm.b, 1_0mf.b, 1_0mlx.\")\n+(exclusion_set \"1_0mi.b\" \"1_0mm.b, 1_0mf.b, 1_0mlx.\")\n+(exclusion_set \"1_0mm.b\" \"1_0mf.b, 1_0mlx.\")\n+(exclusion_set \"1_0mf.b\" \"1_0mlx.\")\n+\n+;; Slot 3\n+(exclusion_set \"1_0mii.\"\n+   \"1_0mmi., 1_0mfi., 1_0mmf., 1_0bbb., 1_0mbb., 1_0mib., 1_0mmb., 1_0mfb.,\\\n+    1_0mlx.\")\n+(exclusion_set \"1_0mmi.\"\n+   \"1_0mfi., 1_0mmf., 1_0bbb., 1_0mbb., 1_0mib., 1_0mmb., 1_0mfb., 1_0mlx.\")\n+(exclusion_set \"1_0mfi.\"\n+   \"1_0mmf., 1_0bbb., 1_0mbb., 1_0mib., 1_0mmb., 1_0mfb., 1_0mlx.\")\n+(exclusion_set \"1_0mmf.\"\n+   \"1_0bbb., 1_0mbb., 1_0mib., 1_0mmb., 1_0mfb., 1_0mlx.\")\n+(exclusion_set \"1_0bbb.\" \"1_0mbb., 1_0mib., 1_0mmb., 1_0mfb., 1_0mlx.\")\n+(exclusion_set \"1_0mbb.\" \"1_0mib., 1_0mmb., 1_0mfb., 1_0mlx.\")\n+(exclusion_set \"1_0mib.\" \"1_0mmb., 1_0mfb., 1_0mlx.\")\n+(exclusion_set \"1_0mmb.\" \"1_0mfb., 1_0mlx.\")\n+(exclusion_set \"1_0mfb.\" \"1_0mlx.\")\n+\n+;; Slot 4\n+(exclusion_set \"1_1m.ii\"\n+   \"1_1m.mi, 1_1m.fi, 1_1b.bb, 1_1m.bb, 1_1m.ib, 1_1m.mb, 1_1m.fb, 1_1m.lx\")\n+(exclusion_set \"1_1m.mi\"\n+   \"1_1m.fi, 1_1b.bb, 1_1m.bb, 1_1m.ib, 1_1m.mb, 1_1m.fb, 1_1m.lx\")\n+(exclusion_set \"1_1m.fi\"\n+   \"1_1b.bb, 1_1m.bb, 1_1m.ib, 1_1m.mb, 1_1m.fb, 1_1m.lx\")\n+(exclusion_set \"1_1b.bb\" \"1_1m.bb, 1_1m.ib, 1_1m.mb, 1_1m.fb, 1_1m.lx\")\n+(exclusion_set \"1_1m.bb\" \"1_1m.ib, 1_1m.mb, 1_1m.fb, 1_1m.lx\")\n+(exclusion_set \"1_1m.ib\" \"1_1m.mb, 1_1m.fb, 1_1m.lx\")\n+(exclusion_set \"1_1m.mb\" \"1_1m.fb, 1_1m.lx\")\n+(exclusion_set \"1_1m.fb\" \"1_1m.lx\")\n+\n+;; Slot 5\n+(exclusion_set \"1_1mi.i\"\n+   \"1_1mm.i, 1_1mf.i, 1_1bb.b, 1_1mb.b, 1_1mi.b, 1_1mm.b, 1_1mf.b, 1_1mlx.\")\n+(exclusion_set \"1_1mm.i\"\n+   \"1_1mf.i, 1_1bb.b, 1_1mb.b, 1_1mi.b, 1_1mm.b, 1_1mf.b, 1_1mlx.\")\n+(exclusion_set \"1_1mf.i\"\n+   \"1_1bb.b, 1_1mb.b, 1_1mi.b, 1_1mm.b, 1_1mf.b, 1_1mlx.\")\n+(exclusion_set \"1_1bb.b\" \"1_1mb.b, 1_1mi.b, 1_1mm.b, 1_1mf.b, 1_1mlx.\")\n+(exclusion_set \"1_1mb.b\" \"1_1mi.b, 1_1mm.b, 1_1mf.b, 1_1mlx.\")\n+(exclusion_set \"1_1mi.b\" \"1_1mm.b, 1_1mf.b, 1_1mlx.\")\n+(exclusion_set \"1_1mm.b\" \"1_1mf.b, 1_1mlx.\")\n+(exclusion_set \"1_1mf.b\" \"1_1mlx.\")\n+\n+;; Slot 6\n+(exclusion_set \"1_1mii.\"\n+   \"1_1mmi., 1_1mfi., 1_1bbb., 1_1mbb., 1_1mib., 1_1mmb., 1_1mfb., 1_1mlx.\")\n+(exclusion_set \"1_1mmi.\"\n+   \"1_1mfi., 1_1bbb., 1_1mbb., 1_1mib., 1_1mmb., 1_1mfb., 1_1mlx.\")\n+(exclusion_set \"1_1mfi.\"\n+   \"1_1bbb., 1_1mbb., 1_1mib., 1_1mmb., 1_1mfb., 1_1mlx.\")\n+(exclusion_set \"1_1bbb.\" \"1_1mbb., 1_1mib., 1_1mmb., 1_1mfb., 1_1mlx.\")\n+(exclusion_set \"1_1mbb.\" \"1_1mib., 1_1mmb., 1_1mfb., 1_1mlx.\")\n+(exclusion_set \"1_1mib.\" \"1_1mmb., 1_1mfb., 1_1mlx.\")\n+(exclusion_set \"1_1mmb.\" \"1_1mfb., 1_1mlx.\")\n+(exclusion_set \"1_1mfb.\" \"1_1mlx.\")\n+\n+(final_presence_set \"1_0mi.i\" \"1_0m.ii\")\n+(final_presence_set \"1_0mii.\" \"1_0mi.i\")\n+(final_presence_set \"1_1mi.i\" \"1_1m.ii\")\n+(final_presence_set \"1_1mii.\" \"1_1mi.i\")\n+\n+(final_presence_set \"1_0mm.i\" \"1_0m.mi\")\n+(final_presence_set \"1_0mmi.\" \"1_0mm.i\")\n+(final_presence_set \"1_1mm.i\" \"1_1m.mi\")\n+(final_presence_set \"1_1mmi.\" \"1_1mm.i\")\n+\n+(final_presence_set \"1_0mf.i\" \"1_0m.fi\")\n+(final_presence_set \"1_0mfi.\" \"1_0mf.i\")\n+(final_presence_set \"1_1mf.i\" \"1_1m.fi\")\n+(final_presence_set \"1_1mfi.\" \"1_1mf.i\")\n+\n+(final_presence_set \"1_0mm.f\" \"1_0m.mf\")\n+(final_presence_set \"1_0mmf.\" \"1_0mm.f\")\n+\n+(final_presence_set \"1_0bb.b\" \"1_0b.bb\")\n+(final_presence_set \"1_0bbb.\" \"1_0bb.b\")\n+(final_presence_set \"1_1bb.b\" \"1_1b.bb\")\n+(final_presence_set \"1_1bbb.\" \"1_1bb.b\")\n+\n+(final_presence_set \"1_0mb.b\" \"1_0m.bb\")\n+(final_presence_set \"1_0mbb.\" \"1_0mb.b\")\n+(final_presence_set \"1_1mb.b\" \"1_1m.bb\")\n+(final_presence_set \"1_1mbb.\" \"1_1mb.b\")\n+\n+(final_presence_set \"1_0mi.b\" \"1_0m.ib\")\n+(final_presence_set \"1_0mib.\" \"1_0mi.b\")\n+(final_presence_set \"1_1mi.b\" \"1_1m.ib\")\n+(final_presence_set \"1_1mib.\" \"1_1mi.b\")\n+\n+(final_presence_set \"1_0mm.b\" \"1_0m.mb\")\n+(final_presence_set \"1_0mmb.\" \"1_0mm.b\")\n+(final_presence_set \"1_1mm.b\" \"1_1m.mb\")\n+(final_presence_set \"1_1mmb.\" \"1_1mm.b\")\n+\n+(final_presence_set \"1_0mf.b\" \"1_0m.fb\")\n+(final_presence_set \"1_0mfb.\" \"1_0mf.b\")\n+(final_presence_set \"1_1mf.b\" \"1_1m.fb\")\n+(final_presence_set \"1_1mfb.\" \"1_1mf.b\")\n+\n+(final_presence_set \"1_0mlx.\" \"1_0m.lx\")\n+(final_presence_set \"1_1mlx.\" \"1_1m.lx\")\n+\n+(final_presence_set\n+   \"1_1m.ii,1_1m.mi,1_1m.fi,1_1b.bb,1_1m.bb,1_1m.ib,1_1m.mb,1_1m.fb,1_1m.lx\"\n+   \"1_0mii.,1_0mmi.,1_0mfi.,1_0mmf.,1_0bbb.,1_0mbb.,1_0mib.,1_0mmb.,1_0mfb.,\\\n+    1_0mlx.\")\n+\n+;;  Microarchitecture units:\n+(define_cpu_unit\n+   \"1_um0, 1_um1, 1_ui0, 1_ui1, 1_uf0, 1_uf1, 1_ub0, 1_ub1, 1_ub2,\\\n+    1_unb0, 1_unb1, 1_unb2\" \"one\")\n+\n+(exclusion_set \"1_ub0\" \"1_unb0\")\n+(exclusion_set \"1_ub1\" \"1_unb1\")\n+(exclusion_set \"1_ub2\" \"1_unb2\")\n+\n+;; The following rules are used to decrease number of alternatives.\n+;; They are consequences of Itanium microarchitecture.  They also\n+;; describe the following rules mentioned in Itanium\n+;; microarchitecture: rules mentioned in Itanium microarchitecture:\n+;; o \"MMF: Always splits issue before the first M and after F regardless\n+;;   of surrounding bundles and stops\".\n+;; o \"BBB/MBB: Always splits issue after either of these bundles\".\n+;; o \"MIB BBB: Split issue after the first bundle in this pair\".\n+\n+(exclusion_set \"1_0m.mf,1_0mm.f,1_0mmf.\"\n+   \"1_1m.ii,1_1m.mi,1_1m.fi,1_1b.bb,1_1m.bb,1_1m.ib,1_1m.mb,1_1m.fb,1_1m.lx\")\n+(exclusion_set \"1_0b.bb,1_0bb.b,1_0bbb.,1_0m.bb,1_0mb.b,1_0mbb.\"\n+   \"1_1m.ii,1_1m.mi,1_1m.fi,1_1b.bb,1_1m.bb,1_1m.ib,1_1m.mb,1_1m.fb,1_1m.lx\")\n+(exclusion_set \"1_0m.ib,1_0mi.b,1_0mib.\" \"1_1b.bb\")\n+\n+;;  For exceptions of M, I, B, F insns:\n+(define_cpu_unit \"1_not_um1, 1_not_ui1, 1_not_uf1\" \"one\")\n+\n+(final_absence_set \"1_not_um1\"  \"1_um1\")\n+(final_absence_set \"1_not_ui1\"  \"1_ui1\")\n+(final_absence_set \"1_not_uf1\"  \"1_uf1\")\n+\n+;;; \"MIB/MFB/MMB: Splits issue after any of these bundles unless the\n+;;; B-slot contains a nop.b or a brp instruction\".\n+;;;   \"The B in an MIB/MFB/MMB bundle disperses to B0 if it is a brp or\n+;;; nop.b, otherwise it disperses to B2\".\n+(final_absence_set\n+   \"1_1m.ii, 1_1m.mi, 1_1m.fi, 1_1b.bb, 1_1m.bb, 1_1m.ib, 1_1m.mb, 1_1m.fb,\\\n+    1_1m.lx\"\n+   \"1_0mib. 1_ub2, 1_0mfb. 1_ub2, 1_0mmb. 1_ub2\")\n+\n+;; This is necessary to start new processor cycle when we meet stop bit.\n+(define_cpu_unit \"1_stop\" \"one\")\n+(final_absence_set\n+   \"1_0m.ii,1_0mi.i,1_0mii.,1_0m.mi,1_0mm.i,1_0mmi.,1_0m.fi,1_0mf.i,1_0mfi.,\\\n+    1_0m.mf,1_0mm.f,1_0mmf.,1_0b.bb,1_0bb.b,1_0bbb.,1_0m.bb,1_0mb.b,1_0mbb.,\\\n+    1_0m.ib,1_0mi.b,1_0mib.,1_0m.mb,1_0mm.b,1_0mmb.,1_0m.fb,1_0mf.b,1_0mfb.,\\\n+    1_0m.lx,1_0mlx., \\\n+    1_1m.ii,1_1mi.i,1_1mii.,1_1m.mi,1_1mm.i,1_1mmi.,1_1m.fi,1_1mf.i,1_1mfi.,\\\n+    1_1b.bb,1_1bb.b,1_1bbb.,1_1m.bb,1_1mb.b,1_1mbb.,1_1m.ib,1_1mi.b,1_1mib.,\\\n+    1_1m.mb,1_1mm.b,1_1mmb.,1_1m.fb,1_1mf.b,1_1mfb.,1_1m.lx,1_1mlx.\"\n+   \"1_stop\")\n+\n+;; M and I instruction is dispersed to the lowest numbered M or I unit\n+;; not already in use.  An I slot in the 3rd position of 2nd bundle is\n+;; always dispersed to I1\n+(final_presence_set \"1_um1\" \"1_um0\")\n+(final_presence_set \"1_ui1\" \"1_ui0, 1_1mii., 1_1mmi., 1_1mfi.\")\n+\n+;; Insns\n+\n+;; M and I instruction is dispersed to the lowest numbered M or I unit\n+;; not already in use.  An I slot in the 3rd position of 2nd bundle is\n+;; always dispersed to I1\n+(define_reservation \"1_M0\"\n+  \"1_0m.ii+1_um0|1_0m.mi+1_um0|1_0mm.i+(1_um0|1_um1)\\\n+   |1_0m.fi+1_um0|1_0m.mf+1_um0|1_0mm.f+1_um1\\\n+   |1_0m.bb+1_um0|1_0m.ib+1_um0|1_0m.mb+1_um0\\\n+   |1_0mm.b+1_um1|1_0m.fb+1_um0|1_0m.lx+1_um0\\\n+   |1_1mm.i+1_um1|1_1mm.b+1_um1\\\n+   |(1_1m.ii|1_1m.mi|1_1m.fi|1_1m.bb|1_1m.ib|1_1m.mb|1_1m.fb|1_1m.lx)\\\n+    +(1_um0|1_um1)\")\n+\n+(define_reservation \"1_M1\"\n+  \"(1_0mii.+(1_ui0|1_ui1)|1_0mmi.+1_ui0|1_0mfi.+1_ui0\\\n+    |1_0mib.+1_unb0|1_0mfb.+1_unb0|1_0mmb.+1_unb0)\\\n+     +(1_1m.ii|1_1m.mi|1_1m.fi|1_1m.bb|1_1m.ib|1_1m.mb|1_1m.fb|1_1m.lx)\\\n+     +(1_um0|1_um1)\")\n+\n+(define_reservation \"1_M\" \"1_M0|1_M1\")\n+\n+;;  Exceptions for dispersal rules.\n+;; \"An I slot in the 3rd position of 2nd bundle is always dispersed to I1\".\n+(define_reservation \"1_I0\"\n+  \"1_0mi.i+1_ui0|1_0mii.+(1_ui0|1_ui1)|1_0mmi.+1_ui0|1_0mfi.+1_ui0\\\n+   |1_0mi.b+1_ui0|(1_1mi.i|1_1mi.b)+(1_ui0|1_ui1)\\\n+   |1_1mii.+1_ui1|1_1mmi.+1_ui1|1_1mfi.+1_ui1\")\n+\n+(define_reservation \"1_I1\"\n+  \"1_0m.ii+1_um0+1_0mi.i+1_ui0|1_0mm.i+(1_um0|1_um1)+1_0mmi.+1_ui0\\\n+   |1_0mf.i+1_uf0+1_0mfi.+1_ui0|1_0m.ib+1_um0+1_0mi.b+1_ui0\\\n+   |(1_1m.ii+(1_um0|1_um1)+1_1mi.i\\\n+   |1_1m.ib+(1_um0|1_um1)+1_1mi.b)+(1_ui0|1_ui1)\\\n+   |1_1mm.i+1_um1+1_1mmi.+1_ui1|1_1mf.i+1_uf1+1_1mfi.+1_ui1\")\n+\n+(define_reservation \"1_I\" \"1_I0|1_I1\")\n+\n+;; \"An F slot in the 1st bundle disperses to F0\".\n+;; \"An F slot in the 2st bundle disperses to F1\".\n+(define_reservation \"1_F0\"\n+   \"1_0mf.i+1_uf0|1_0mmf.+1_uf0|1_0mf.b+1_uf0|1_1mf.i+1_uf1|1_1mf.b+1_uf1\")\n+\n+(define_reservation \"1_F1\"\n+   \"1_0m.fi+1_um0+1_0mf.i+1_uf0|1_0mm.f+(1_um0|1_um1)+1_0mmf.+1_uf0\\\n+    |1_0m.fb+1_um0+1_0mf.b+1_uf0|1_1m.fi+(1_um0|1_um1)+1_1mf.i+1_uf1\\\n+    |1_1m.fb+(1_um0|1_um1)+1_1mf.b+1_uf1\")\n+\n+(define_reservation \"1_F2\"\n+   \"1_0m.mf+1_um0+1_0mm.f+1_um1+1_0mmf.+1_uf0\\\n+    |(1_0mii.+(1_ui0|1_ui1)|1_0mmi.+1_ui0|1_0mfi.+1_ui0\\\n+      |1_0mib.+1_unb0|1_0mmb.+1_unb0|1_0mfb.+1_unb0)\\\n+     +(1_1m.fi+(1_um0|1_um1)+1_1mf.i+1_uf1\\\n+       |1_1m.fb+(1_um0|1_um1)+1_1mf.b+1_uf1)\")\n+\n+(define_reservation \"1_F\" \"1_F0|1_F1|1_F2\")\n+\n+;;; \"Each B slot in MBB or BBB bundle disperses to the corresponding B\n+;;; unit. That is, a B slot in 1st position is despersed to B0.  In the\n+;;; 2nd position it is dispersed to B2\".\n+(define_reservation \"1_NB\"\n+    \"1_0b.bb+1_unb0|1_0bb.b+1_unb1|1_0bbb.+1_unb2\\\n+     |1_0mb.b+1_unb1|1_0mbb.+1_unb2\\\n+     |1_0mib.+1_unb0|1_0mmb.+1_unb0|1_0mfb.+1_unb0\\\n+     |1_1b.bb+1_unb0|1_1bb.b+1_unb1\\\n+     |1_1bbb.+1_unb2|1_1mb.b+1_unb1|1_1mbb.+1_unb2|1_1mib.+1_unb0\\\n+     |1_1mmb.+1_unb0|1_1mfb.+1_unb0\")\n+\n+(define_reservation \"1_B0\"\n+   \"1_0b.bb+1_ub0|1_0bb.b+1_ub1|1_0bbb.+1_ub2\\\n+    |1_0mb.b+1_ub1|1_0mbb.+1_ub2|1_0mib.+1_ub2\\\n+    |1_0mfb.+1_ub2|1_1b.bb+1_ub0|1_1bb.b+1_ub1\\\n+    |1_1bbb.+1_ub2|1_1mb.b+1_ub1\\\n+    |1_1mib.+1_ub2|1_1mmb.+1_ub2|1_1mfb.+1_ub2\")\n+\n+(define_reservation \"1_B1\"\n+   \"1_0m.bb+1_um0+1_0mb.b+1_ub1|1_0mi.b+1_ui0+1_0mib.+1_ub2\\\n+    |1_0mf.b+1_uf0+1_0mfb.+1_ub2\\\n+    |(1_0mii.+(1_ui0|1_ui1)|1_0mmi.+1_ui0|1_0mfi.+1_ui0)+1_1b.bb+1_ub0\\\n+    |1_1m.bb+(1_um0|1_um1)+1_1mb.b+1_ub1\\\n+    |1_1mi.b+(1_ui0|1_ui1)+1_1mib.+1_ub2\\\n+    |1_1mm.b+1_um1+1_1mmb.+1_ub2\\\n+    |1_1mf.b+1_uf1+1_1mfb.+1_ub2\")\n+\n+(define_reservation \"1_B\" \"1_B0|1_B1\")\n+\n+;; MLX bunlde uses ports equivalent to MFI bundles.\n+(define_reservation \"1_L0\" \"1_0mlx.+1_ui0+1_uf0|1_1mlx.+(1_ui0|1_ui1)+1_uf1\")\n+(define_reservation \"1_L1\"\n+   \"1_0m.lx+1_um0+1_0mlx.+1_ui0+1_uf0\\\n+   |1_1m.lx+(1_um0|1_um1)+1_1mlx.+(1_ui0|1_ui1)+1_uf1\")\n+(define_reservation \"1_L2\"\n+   \"(1_0mii.+(1_ui0|1_ui1)|1_0mmi.+1_ui0|1_0mfi.+1_ui0\\\n+     |1_0mib.+1_unb0|1_0mmb.+1_unb0|1_0mfb.+1_unb0)\n+    +1_1m.lx+(1_um0|1_um1)+1_1mlx.+1_ui1+1_uf1\")\n+(define_reservation \"1_L\" \"1_L0|1_L1|1_L2\")\n+\n+(define_reservation \"1_A\" \"1_M|1_I\")\n+\n+(define_insn_reservation \"1_stop_bit\" 0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"stop_bit\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1_stop|1_m0_stop|1_m1_stop|1_mi0_stop|1_mi1_stop\")\n+\n+(define_insn_reservation \"1_br\"      0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"br\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_B\")\n+(define_insn_reservation \"1_scall\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"scall\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_B\")\n+(define_insn_reservation \"1_fcmp\"    2\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"fcmp\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1_F+1_not_uf1\")\n+(define_insn_reservation \"1_fcvtfx\"  7\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"fcvtfx\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_F\")\n+(define_insn_reservation \"1_fld\"     9\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"fld\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_M\")\n+(define_insn_reservation \"1_fmac\"    5\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"fmac\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_F\")\n+(define_insn_reservation \"1_fmisc\"   5\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"fmisc\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1_F+1_not_uf1\")\n+\n+;; There is only one insn `mov = ar.bsp' for frar_i:\n+(define_insn_reservation \"1_frar_i\" 13\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"frar_i\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1_I+1_not_ui1\")\n+;; There is only two insns `mov = ar.unat' or `mov = ar.ccv' for frar_m:\n+(define_insn_reservation \"1_frar_m\"  6\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"frar_m\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1_M+1_not_um1\")\n+(define_insn_reservation \"1_frbr\"    2\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"frbr\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1_I+1_not_ui1\")\n+(define_insn_reservation \"1_frfr\"    2\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"frfr\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1_M+1_not_um1\")\n+(define_insn_reservation \"1_frpr\"    2\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"frpr\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1_I+1_not_ui1\")\n+\n+(define_insn_reservation \"1_ialu\"      1\n+    (and (and (eq_attr \"cpu\" \"itanium\")\n+              (eq_attr \"itanium_class\" \"ialu\"))\n+         (eq (symbol_ref\n+              \"bundling_p || ia64_produce_address_p (insn)\")\n+              (const_int 0)))\n+    \"1_A\")\n+(define_insn_reservation \"1_ialu_addr\" 1\n+    (and (and (eq_attr \"cpu\" \"itanium\")\n+              (eq_attr \"itanium_class\" \"ialu\"))\n+         (eq (symbol_ref\n+              \"!bundling_p && ia64_produce_address_p (insn)\")\n+             (const_int 1)))\n+    \"1_M\")\n+(define_insn_reservation \"1_icmp\"    1\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"icmp\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_A\")\n+(define_insn_reservation \"1_ilog\"    1\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"ilog\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_A\")\n+(define_insn_reservation \"1_ishf\"    1\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"ishf\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+    \"1_I+1_not_ui1\")\n+(define_insn_reservation \"1_ld\"      2\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"ld\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_M\")\n+(define_insn_reservation \"1_long_i\"  1\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"long_i\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_L\")\n+(define_insn_reservation \"1_mmmul\"   2\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"mmmul\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1_I+1_not_ui1\")\n+(define_insn_reservation \"1_mmshf\"   2\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"mmshf\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_I\")\n+(define_insn_reservation \"1_mmshfi\"  1\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"mmshfi\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_I\")\n+\n+;; Now we have only one insn (flushrs) of such class.  We assume that flushrs\n+;; is the 1st syllable of the bundle after stop bit.\n+(define_insn_reservation \"1_rse_m\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"rse_m\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"(1_0m.ii|1_0m.mi|1_0m.fi|1_0m.mf|1_0b.bb|1_0m.bb\\\n+    |1_0m.ib|1_0m.mb|1_0m.fb|1_0m.lx)+1_um0\")\n+(define_insn_reservation \"1_sem\"     0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"sem\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1_M+1_not_um1\")\n+(define_insn_reservation \"1_stf\"     1\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"stf\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_M\")\n+(define_insn_reservation \"1_st\"      1\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"st\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_M\")\n+(define_insn_reservation \"1_syst_m0\" 0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"syst_m0\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1_M+1_not_um1\")\n+(define_insn_reservation \"1_syst_m\"  0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"syst_m\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_M\")\n+(define_insn_reservation \"1_tbit\"    1\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"tbit\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1_I+1_not_ui1\")\n+\n+;; There is only ony insn `mov ar.pfs =' for toar_i:\n+(define_insn_reservation \"1_toar_i\"  0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"toar_i\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1_I+1_not_ui1\")\n+;; There are only ony 2 insns `mov ar.ccv =' and `mov ar.unat =' for toar_m:\n+(define_insn_reservation \"1_toar_m\"  5\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"toar_m\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1_M+1_not_um1\")\n+(define_insn_reservation \"1_tobr\"    1\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"tobr\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1_I+1_not_ui1\")\n+(define_insn_reservation \"1_tofr\"    9\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"tofr\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_M\")\n+(define_insn_reservation \"1_topr\"    1\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"topr\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1_I+1_not_ui1\")\n+(define_insn_reservation \"1_xmpy\"    7\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"xmpy\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_F\")\n+(define_insn_reservation \"1_xtd\"     1\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"xtd\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_I\")\n+\n+(define_insn_reservation \"1_chk_s\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"chk_s\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_A\")\n+(define_insn_reservation \"1_lfetch\"  0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"lfetch\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_M\")\n+\n+(define_insn_reservation \"1_nop_m\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"nop_m\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_M0\")\n+(define_insn_reservation \"1_nop_b\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"nop_b\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_NB\")\n+(define_insn_reservation \"1_nop_i\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"nop_i\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_I0\")\n+(define_insn_reservation \"1_nop_f\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"nop_f\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_F0\")\n+(define_insn_reservation \"1_nop_x\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"nop_x\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_L0\")\n+\n+;; We assume that there is no insn issued on the same cycle as unknown insn.\n+(define_cpu_unit \"1_empty\" \"one\")\n+(exclusion_set \"1_empty\"\n+    \"1_0m.ii,1_0m.mi,1_0m.fi,1_0m.mf,1_0b.bb,1_0m.bb,1_0m.ib,1_0m.mb,1_0m.fb,\\\n+     1_0m.lx\")\n+\n+(define_insn_reservation \"1_unknown\" 1\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"unknown\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_empty\")\n+\n+(define_insn_reservation \"1_nop\" 1\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"nop\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1_M0|1_NB|1_I0|1_F0\")\n+\n+(define_insn_reservation \"1_ignore\" 0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"ignore\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"nothing\")\n+\n+\n+(define_cpu_unit\n+   \"1_0m_bs, 1_0mi_bs, 1_0mm_bs, 1_0mf_bs, 1_0b_bs, 1_0bb_bs, 1_0mb_bs\"\n+   \"one\")\n+(define_cpu_unit\n+   \"1_1m_bs, 1_1mi_bs, 1_1mm_bs, 1_1mf_bs, 1_1b_bs, 1_1bb_bs, 1_1mb_bs\"\n+   \"one\")\n+\n+(define_cpu_unit \"1_m_cont, 1_mi_cont, 1_mm_cont, 1_mf_cont, 1_mb_cont,\\\n+\t          1_b_cont, 1_bb_cont\" \"one\")\n+\n+;; For stop in the middle of the bundles.\n+(define_cpu_unit \"1_m_stop, 1_m0_stop, 1_m1_stop, 1_0mmi_cont\" \"one\")\n+(define_cpu_unit \"1_mi_stop, 1_mi0_stop, 1_mi1_stop, 1_0mii_cont\" \"one\")\n+\n+(final_presence_set \"1_0m_bs\"\n+   \"1_0m.ii, 1_0m.mi, 1_0m.mf, 1_0m.fi, 1_0m.bb,\\\n+    1_0m.ib, 1_0m.fb, 1_0m.mb, 1_0m.lx\")\n+(final_presence_set \"1_1m_bs\"\n+   \"1_1m.ii, 1_1m.mi, 1_1m.fi, 1_1m.bb, 1_1m.ib, 1_1m.fb, 1_1m.mb,\\\n+    1_1m.lx\")\n+(final_presence_set \"1_0mi_bs\"  \"1_0mi.i, 1_0mi.i\")\n+(final_presence_set \"1_1mi_bs\"  \"1_1mi.i, 1_1mi.i\")\n+(final_presence_set \"1_0mm_bs\"  \"1_0mm.i, 1_0mm.f, 1_0mm.b\")\n+(final_presence_set \"1_1mm_bs\"  \"1_1mm.i, 1_1mm.b\")\n+(final_presence_set \"1_0mf_bs\"  \"1_0mf.i, 1_0mf.b\")\n+(final_presence_set \"1_1mf_bs\"  \"1_1mf.i, 1_1mf.b\")\n+(final_presence_set \"1_0b_bs\"  \"1_0b.bb\")\n+(final_presence_set \"1_1b_bs\"  \"1_1b.bb\")\n+(final_presence_set \"1_0bb_bs\"  \"1_0bb.b\")\n+(final_presence_set \"1_1bb_bs\"  \"1_1bb.b\")\n+(final_presence_set \"1_0mb_bs\"  \"1_0mb.b\")\n+(final_presence_set \"1_1mb_bs\"  \"1_1mb.b\")\n+\n+(exclusion_set \"1_0m_bs\"\n+   \"1_0mi.i, 1_0mm.i, 1_0mm.f, 1_0mf.i, 1_0mb.b,\\\n+    1_0mi.b, 1_0mf.b, 1_0mm.b, 1_0mlx., 1_m0_stop\")\n+(exclusion_set \"1_1m_bs\"\n+   \"1_1mi.i, 1_1mm.i, 1_1mf.i, 1_1mb.b, 1_1mi.b, 1_1mf.b, 1_1mm.b,\\\n+    1_1mlx., 1_m1_stop\")\n+(exclusion_set \"1_0mi_bs\"  \"1_0mii., 1_0mib., 1_mi0_stop\")\n+(exclusion_set \"1_1mi_bs\"  \"1_1mii., 1_1mib., 1_mi1_stop\")\n+(exclusion_set \"1_0mm_bs\"  \"1_0mmi., 1_0mmf., 1_0mmb.\")\n+(exclusion_set \"1_1mm_bs\"  \"1_1mmi., 1_1mmb.\")\n+(exclusion_set \"1_0mf_bs\"  \"1_0mfi., 1_0mfb.\")\n+(exclusion_set \"1_1mf_bs\"  \"1_1mfi., 1_1mfb.\")\n+(exclusion_set \"1_0b_bs\"  \"1_0bb.b\")\n+(exclusion_set \"1_1b_bs\"  \"1_1bb.b\")\n+(exclusion_set \"1_0bb_bs\"  \"1_0bbb.\")\n+(exclusion_set \"1_1bb_bs\"  \"1_1bbb.\")\n+(exclusion_set \"1_0mb_bs\"  \"1_0mbb.\")\n+(exclusion_set \"1_1mb_bs\"  \"1_1mbb.\")\n+\n+(exclusion_set\n+   \"1_0m_bs, 1_0mi_bs, 1_0mm_bs, 1_0mf_bs, 1_0b_bs, 1_0bb_bs, 1_0mb_bs,\n+    1_1m_bs, 1_1mi_bs, 1_1mm_bs, 1_1mf_bs, 1_1b_bs, 1_1bb_bs, 1_1mb_bs\"\n+   \"1_stop\")\n+\n+(final_presence_set\n+   \"1_0mi.i, 1_0mm.i, 1_0mf.i, 1_0mm.f, 1_0mb.b,\\\n+    1_0mi.b, 1_0mm.b, 1_0mf.b, 1_0mlx.\"\n+   \"1_m_cont\")\n+(final_presence_set \"1_0mii., 1_0mib.\" \"1_mi_cont\")\n+(final_presence_set \"1_0mmi., 1_0mmf., 1_0mmb.\" \"1_mm_cont\")\n+(final_presence_set \"1_0mfi., 1_0mfb.\" \"1_mf_cont\")\n+(final_presence_set \"1_0bb.b\" \"1_b_cont\")\n+(final_presence_set \"1_0bbb.\" \"1_bb_cont\")\n+(final_presence_set \"1_0mbb.\" \"1_mb_cont\")\n+\n+(exclusion_set\n+   \"1_0m.ii, 1_0m.mi, 1_0m.fi, 1_0m.mf, 1_0b.bb, 1_0m.bb,\\\n+    1_0m.ib, 1_0m.mb, 1_0m.fb, 1_0m.lx\"\n+   \"1_m_cont, 1_mi_cont, 1_mm_cont, 1_mf_cont,\\\n+    1_mb_cont, 1_b_cont, 1_bb_cont\")\n+\n+(exclusion_set \"1_empty\"\n+               \"1_m_cont,1_mi_cont,1_mm_cont,1_mf_cont,\\\n+                1_mb_cont,1_b_cont,1_bb_cont\")\n+\n+;; For m;mi bundle\n+(final_presence_set \"1_m0_stop\" \"1_0m.mi\")\n+(final_presence_set \"1_0mm.i\" \"1_0mmi_cont\")\n+(exclusion_set \"1_0mmi_cont\"\n+   \"1_0m.ii, 1_0m.mi, 1_0m.fi, 1_0m.mf, 1_0b.bb, 1_0m.bb,\\\n+    1_0m.ib, 1_0m.mb, 1_0m.fb, 1_0m.lx\")\n+(exclusion_set \"1_m0_stop\" \"1_0mm.i\")\n+(final_presence_set \"1_m1_stop\" \"1_1m.mi\")\n+(exclusion_set \"1_m1_stop\" \"1_1mm.i\")\n+(final_presence_set \"1_m_stop\" \"1_m0_stop, 1_m1_stop\")\n+\n+;; For mi;i bundle\n+(final_presence_set \"1_mi0_stop\" \"1_0mi.i\")\n+(final_presence_set \"1_0mii.\" \"1_0mii_cont\")\n+(exclusion_set \"1_0mii_cont\"\n+   \"1_0m.ii, 1_0m.mi, 1_0m.fi, 1_0m.mf, 1_0b.bb, 1_0m.bb,\\\n+    1_0m.ib, 1_0m.mb, 1_0m.fb, 1_0m.lx\")\n+(exclusion_set \"1_mi0_stop\" \"1_0mii.\")\n+(final_presence_set \"1_mi1_stop\" \"1_1mi.i\")\n+(exclusion_set \"1_mi1_stop\" \"1_1mii.\")\n+(final_presence_set \"1_mi_stop\" \"1_mi0_stop, 1_mi1_stop\")\n+\n+(final_absence_set\n+   \"1_0m.ii,1_0mi.i,1_0mii.,1_0m.mi,1_0mm.i,1_0mmi.,1_0m.fi,1_0mf.i,1_0mfi.,\\\n+    1_0m.mf,1_0mm.f,1_0mmf.,1_0b.bb,1_0bb.b,1_0bbb.,1_0m.bb,1_0mb.b,1_0mbb.,\\\n+    1_0m.ib,1_0mi.b,1_0mib.,1_0m.mb,1_0mm.b,1_0mmb.,1_0m.fb,1_0mf.b,1_0mfb.,\\\n+    1_0m.lx,1_0mlx., \\\n+    1_1m.ii,1_1mi.i,1_1mii.,1_1m.mi,1_1mm.i,1_1mmi.,1_1m.fi,1_1mf.i,1_1mfi.,\\\n+    1_1b.bb,1_1bb.b,1_1bbb.,1_1m.bb,1_1mb.b,1_1mbb.,\\\n+    1_1m.ib,1_1mi.b,1_1mib.,1_1m.mb,1_1mm.b,1_1mmb.,1_1m.fb,1_1mf.b,1_1mfb.,\\\n+    1_1m.lx,1_1mlx.\"\n+   \"1_m0_stop,1_m1_stop,1_mi0_stop,1_mi1_stop\")\n+\n+(define_cpu_unit \"1_m_cont_only, 1_b_cont_only\" \"one\")\n+(define_cpu_unit \"1_mi_cont_only, 1_mm_cont_only, 1_mf_cont_only\" \"one\")\n+(define_cpu_unit \"1_mb_cont_only, 1_bb_cont_only\" \"one\")\n+\n+(final_presence_set \"1_m_cont_only\" \"1_m_cont\")\n+(exclusion_set \"1_m_cont_only\"\n+  \"1_0mi.i, 1_0mm.i, 1_0mf.i, 1_0mm.f, 1_0mb.b,\\\n+   1_0mi.b, 1_0mm.b, 1_0mf.b, 1_0mlx.\")\n+\n+(final_presence_set \"1_b_cont_only\" \"1_b_cont\")\n+(exclusion_set \"1_b_cont_only\"  \"1_0bb.b\")\n+\n+(final_presence_set \"1_mi_cont_only\" \"1_mi_cont\")\n+(exclusion_set \"1_mi_cont_only\" \"1_0mii., 1_0mib.\")\n+\n+(final_presence_set \"1_mm_cont_only\" \"1_mm_cont\")\n+(exclusion_set \"1_mm_cont_only\" \"1_0mmi., 1_0mmf., 1_0mmb.\")\n+\n+(final_presence_set \"1_mf_cont_only\" \"1_mf_cont\")\n+(exclusion_set \"1_mf_cont_only\" \"1_0mfi., 1_0mfb.\")\n+\n+(final_presence_set \"1_mb_cont_only\" \"1_mb_cont\")\n+(exclusion_set \"1_mb_cont_only\" \"1_0mbb.\")\n+\n+(final_presence_set \"1_bb_cont_only\" \"1_bb_cont\")\n+(exclusion_set \"1_bb_cont_only\" \"1_0bbb.\")\n+\n+(define_insn_reservation \"1_pre_cycle\" 0\n+   (and (and (eq_attr \"cpu\" \"itanium\")\n+             (eq_attr \"itanium_class\" \"pre_cycle\"))\n+        (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+                         \"(1_0m_bs, 1_m_cont)                     \\\n+                          | (1_0mi_bs, (1_mi_cont|nothing))       \\\n+                          | (1_0mm_bs, 1_mm_cont)                 \\\n+                          | (1_0mf_bs, (1_mf_cont|nothing))       \\\n+                          | (1_0b_bs, (1_b_cont|nothing))         \\\n+                          | (1_0bb_bs, (1_bb_cont|nothing))       \\\n+                          | (1_0mb_bs, (1_mb_cont|nothing))       \\\n+                          | (1_1m_bs, 1_m_cont)                   \\\n+                          | (1_1mi_bs, (1_mi_cont|nothing))       \\\n+                          | (1_1mm_bs, 1_mm_cont)                 \\\n+                          | (1_1mf_bs, (1_mf_cont|nothing))       \\\n+                          | (1_1b_bs, (1_b_cont|nothing))         \\\n+                          | (1_1bb_bs, (1_bb_cont|nothing))       \\\n+                          | (1_1mb_bs, (1_mb_cont|nothing))       \\\n+                          | (1_m_cont_only, (1_m_cont|nothing))   \\\n+                          | (1_b_cont_only,  (1_b_cont|nothing))  \\\n+                          | (1_mi_cont_only, (1_mi_cont|nothing)) \\\n+                          | (1_mm_cont_only, (1_mm_cont|nothing)) \\\n+                          | (1_mf_cont_only, (1_mf_cont|nothing)) \\\n+                          | (1_mb_cont_only, (1_mb_cont|nothing)) \\\n+                          | (1_bb_cont_only, (1_bb_cont|nothing)) \\\n+                          | (1_m_stop, (1_0mmi_cont|nothing))     \\\n+                          | (1_mi_stop, (1_0mii_cont|nothing))\")\n+\n+;; Bypasses:\n+(define_bypass  1 \"1_fcmp\" \"1_br,1_scall\")\n+;; ??? I found 7 cycle dealy for 1_fmac -> 1_fcmp for Itanium1\n+(define_bypass  7 \"1_fmac\" \"1_fmisc,1_fcvtfx,1_xmpy,1_fcmp\")\n+\n+;; ???\n+(define_bypass  3 \"1_frbr\" \"1_mmmul,1_mmshf\")\n+(define_bypass 14 \"1_frar_i\" \"1_mmmul,1_mmshf\")\n+(define_bypass  7 \"1_frar_m\" \"1_mmmul,1_mmshf\")\n+\n+;; ????\n+;; There is only one insn `mov ar.pfs =' for toar_i.\n+(define_bypass  0 \"1_tobr,1_topr,1_toar_i\" \"1_br,1_scall\")\n+\n+(define_bypass  3 \"1_ialu,1_ialu_addr\" \"1_mmmul,1_mmshf\")\n+;; ??? howto describe ialu for I slot only.  We use ialu_addr for that\n+;;(define_bypass  2 \"1_ialu\" \"1_ld\"  \"ia64_ld_address_bypass_p\")\n+;; ??? howto describe ialu st/address for I slot only.  We use ialu_addr\n+;;   for that.\n+;;(define_bypass  2 \"1_ialu\" \"1_st\"  \"ia64_st_address_bypass_p\")\n+\n+(define_bypass  0 \"1_icmp\" \"1_br,1_scall\")\n+\n+(define_bypass  3 \"1_ilog\" \"1_mmmul,1_mmshf\")\n+\n+(define_bypass  2 \"1_ilog,1_xtd\" \"1_ld\"  \"ia64_ld_address_bypass_p\")\n+(define_bypass  2 \"1_ilog,1_xtd\" \"1_st\"  \"ia64_st_address_bypass_p\")\n+\n+(define_bypass  3 \"1_ld\" \"1_mmmul,1_mmshf\")\n+(define_bypass  3 \"1_ld\" \"1_ld\"  \"ia64_ld_address_bypass_p\")\n+(define_bypass  3 \"1_ld\" \"1_st\"  \"ia64_st_address_bypass_p\")\n+\n+;; Intel docs say only LD, ST, IALU, ILOG, ISHF consumers have latency 4,\n+;;      but HP engineers say any non-MM operation.\n+(define_bypass  4 \"1_mmmul,1_mmshf\"\n+     \"1_br,1_fcmp,1_fcvtfx,1_fld,1_fmac,1_fmisc,1_frar_i,1_frar_m,\\\n+      1_frbr,1_frfr,1_frpr,1_ialu,1_icmp,1_ilog,1_ishf,1_ld,1_chk_s,\\\n+      1_long_i,1_rse_m,1_sem,1_stf,1_st,1_syst_m0,1_syst_m,\\\n+      1_tbit,1_toar_i,1_toar_m,1_tobr,1_tofr,1_topr,1_xmpy,1_xtd\")\n+\n+;; ??? how to describe that if scheduled < 4 cycle then latency is 10 cycles.\n+;; (define_bypass  10 \"1_mmmul,1_mmshf\" \"1_ialu,1_ilog,1_ishf,1_st,1_ld\")\n+\n+(define_bypass  0 \"1_tbit\" \"1_br,1_scall\")\n+\n+(define_bypass  8 \"1_tofr\"  \"1_frfr,1_stf\")\n+(define_bypass  7 \"1_fmisc,1_fcvtfx,1_fmac,1_xmpy\"  \"1_frfr\")\n+(define_bypass  8 \"1_fmisc,1_fcvtfx,1_fmac,1_xmpy\"  \"1_stf\")\n+\n+;; We don't use here fcmp because scall may be predicated.\n+(define_bypass  0 \"1_fcvtfx,1_fld,1_fmac,1_fmisc,1_frar_i,1_frar_m,\\\n+                   1_frbr,1_frfr,1_frpr,1_ialu,1_ialu_addr,1_ilog,1_ishf,\\\n+\t           1_ld,1_long_i,1_mmmul,1_mmshf,1_mmshfi,1_toar_m,1_tofr,\\\n+                   1_xmpy,1_xtd\" \"1_scall\")\n+\n+(define_bypass  0 \"1_unknown,1_ignore,1_stop_bit,1_br,1_fcmp,1_fcvtfx,\\\n+                   1_fld,1_fmac,1_fmisc,1_frar_i,1_frar_m,1_frbr,1_frfr,\\\n+                   1_frpr,1_ialu,1_ialu_addr,1_icmp,1_ilog,1_ishf,1_ld,\\\n+                   1_chk_s,1_long_i,1_mmmul,1_mmshf,1_mmshfi,1_nop,\\\n+                   1_nop_b,1_nop_f,1_nop_i,1_nop_m,1_nop_x,1_rse_m,1_scall,\\\n+                   1_sem,1_stf,1_st,1_syst_m0,1_syst_m,1_tbit,1_toar_i,\\\n+                   1_toar_m,1_tobr,1_tofr,1_topr,1_xmpy,1_xtd,1_lfetch\"\n+                  \"1_ignore\")\n+\n+\f\n+;; Bundling\n+\n+(define_automaton \"oneb\")\n+\n+;; Pseudo units for quicker searching for position in two packet window.  */\n+(define_query_cpu_unit \"1_1,1_2,1_3,1_4,1_5,1_6\" \"oneb\")\n+\n+;;   All possible combinations of bundles/syllables\n+(define_cpu_unit\n+   \"1b_0m.ii, 1b_0m.mi, 1b_0m.fi, 1b_0m.mf, 1b_0b.bb, 1b_0m.bb,\\\n+    1b_0m.ib, 1b_0m.mb, 1b_0m.fb, 1b_0m.lx\" \"oneb\")\n+(define_cpu_unit\n+   \"1b_0mi.i, 1b_0mm.i, 1b_0mf.i, 1b_0mm.f, 1b_0bb.b, 1b_0mb.b,\\\n+    1b_0mi.b, 1b_0mm.b, 1b_0mf.b\" \"oneb\")\n+(define_query_cpu_unit\n+   \"1b_0mii., 1b_0mmi., 1b_0mfi., 1b_0mmf., 1b_0bbb., 1b_0mbb.,\\\n+    1b_0mib., 1b_0mmb., 1b_0mfb., 1b_0mlx.\" \"oneb\")\n+\n+(define_cpu_unit \"1b_1m.ii, 1b_1m.mi, 1b_1m.fi, 1b_1b.bb, 1b_1m.bb,\\\n+                  1b_1m.ib, 1b_1m.mb, 1b_1m.fb, 1b_1m.lx\" \"oneb\")\n+(define_cpu_unit \"1b_1mi.i, 1b_1mm.i, 1b_1mf.i, 1b_1bb.b, 1b_1mb.b,\\\n+                  1b_1mi.b, 1b_1mm.b, 1b_1mf.b\" \"oneb\")\n+(define_query_cpu_unit \"1b_1mii., 1b_1mmi., 1b_1mfi., 1b_1bbb., 1b_1mbb.,\\\n+                        1b_1mib., 1b_1mmb., 1b_1mfb., 1b_1mlx.\" \"oneb\")\n+\n+;; Slot 1\n+(exclusion_set \"1b_0m.ii\"\n+   \"1b_0m.mi, 1b_0m.fi, 1b_0m.mf, 1b_0b.bb, 1b_0m.bb,\\\n+    1b_0m.ib, 1b_0m.mb, 1b_0m.fb, 1b_0m.lx\")\n+(exclusion_set \"1b_0m.mi\"\n+   \"1b_0m.fi, 1b_0m.mf, 1b_0b.bb, 1b_0m.bb, 1b_0m.ib,\\\n+    1b_0m.mb, 1b_0m.fb, 1b_0m.lx\")\n+(exclusion_set \"1b_0m.fi\"\n+   \"1b_0m.mf, 1b_0b.bb, 1b_0m.bb, 1b_0m.ib, 1b_0m.mb, 1b_0m.fb, 1b_0m.lx\")\n+(exclusion_set \"1b_0m.mf\"\n+   \"1b_0b.bb, 1b_0m.bb, 1b_0m.ib, 1b_0m.mb, 1b_0m.fb, 1b_0m.lx\")\n+(exclusion_set \"1b_0b.bb\" \"1b_0m.bb, 1b_0m.ib, 1b_0m.mb, 1b_0m.fb, 1b_0m.lx\")\n+(exclusion_set \"1b_0m.bb\" \"1b_0m.ib, 1b_0m.mb, 1b_0m.fb, 1b_0m.lx\")\n+(exclusion_set \"1b_0m.ib\" \"1b_0m.mb, 1b_0m.fb, 1b_0m.lx\")\n+(exclusion_set \"1b_0m.mb\" \"1b_0m.fb, 1b_0m.lx\")\n+(exclusion_set \"1b_0m.fb\" \"1b_0m.lx\")\n+\n+;; Slot 2\n+(exclusion_set \"1b_0mi.i\"\n+   \"1b_0mm.i, 1b_0mf.i, 1b_0mm.f, 1b_0bb.b, 1b_0mb.b,\\\n+    1b_0mi.b, 1b_0mm.b, 1b_0mf.b, 1b_0mlx.\")\n+(exclusion_set \"1b_0mm.i\"\n+   \"1b_0mf.i, 1b_0mm.f, 1b_0bb.b, 1b_0mb.b,\\\n+    1b_0mi.b, 1b_0mm.b, 1b_0mf.b, 1b_0mlx.\")\n+(exclusion_set \"1b_0mf.i\"\n+   \"1b_0mm.f, 1b_0bb.b, 1b_0mb.b, 1b_0mi.b, 1b_0mm.b, 1b_0mf.b, 1b_0mlx.\")\n+(exclusion_set \"1b_0mm.f\"\n+   \"1b_0bb.b, 1b_0mb.b, 1b_0mi.b, 1b_0mm.b, 1b_0mf.b, 1b_0mlx.\")\n+(exclusion_set \"1b_0bb.b\" \"1b_0mb.b, 1b_0mi.b, 1b_0mm.b, 1b_0mf.b, 1b_0mlx.\")\n+(exclusion_set \"1b_0mb.b\" \"1b_0mi.b, 1b_0mm.b, 1b_0mf.b, 1b_0mlx.\")\n+(exclusion_set \"1b_0mi.b\" \"1b_0mm.b, 1b_0mf.b, 1b_0mlx.\")\n+(exclusion_set \"1b_0mm.b\" \"1b_0mf.b, 1b_0mlx.\")\n+(exclusion_set \"1b_0mf.b\" \"1b_0mlx.\")\n+\n+;; Slot 3\n+(exclusion_set \"1b_0mii.\"\n+   \"1b_0mmi., 1b_0mfi., 1b_0mmf., 1b_0bbb., 1b_0mbb.,\\\n+    1b_0mib., 1b_0mmb., 1b_0mfb., 1b_0mlx.\")\n+(exclusion_set \"1b_0mmi.\"\n+   \"1b_0mfi., 1b_0mmf., 1b_0bbb., 1b_0mbb.,\\\n+    1b_0mib., 1b_0mmb., 1b_0mfb., 1b_0mlx.\")\n+(exclusion_set \"1b_0mfi.\"\n+   \"1b_0mmf., 1b_0bbb., 1b_0mbb., 1b_0mib., 1b_0mmb., 1b_0mfb., 1b_0mlx.\")\n+(exclusion_set \"1b_0mmf.\"\n+   \"1b_0bbb., 1b_0mbb., 1b_0mib., 1b_0mmb., 1b_0mfb., 1b_0mlx.\")\n+(exclusion_set \"1b_0bbb.\" \"1b_0mbb., 1b_0mib., 1b_0mmb., 1b_0mfb., 1b_0mlx.\")\n+(exclusion_set \"1b_0mbb.\" \"1b_0mib., 1b_0mmb., 1b_0mfb., 1b_0mlx.\")\n+(exclusion_set \"1b_0mib.\" \"1b_0mmb., 1b_0mfb., 1b_0mlx.\")\n+(exclusion_set \"1b_0mmb.\" \"1b_0mfb., 1b_0mlx.\")\n+(exclusion_set \"1b_0mfb.\" \"1b_0mlx.\")\n+\n+;; Slot 4\n+(exclusion_set \"1b_1m.ii\"\n+   \"1b_1m.mi, 1b_1m.fi, 1b_1b.bb, 1b_1m.bb,\\\n+    1b_1m.ib, 1b_1m.mb, 1b_1m.fb, 1b_1m.lx\")\n+(exclusion_set \"1b_1m.mi\"\n+   \"1b_1m.fi, 1b_1b.bb, 1b_1m.bb, 1b_1m.ib, 1b_1m.mb, 1b_1m.fb, 1b_1m.lx\")\n+(exclusion_set \"1b_1m.fi\"\n+   \"1b_1b.bb, 1b_1m.bb, 1b_1m.ib, 1b_1m.mb, 1b_1m.fb, 1b_1m.lx\")\n+(exclusion_set \"1b_1b.bb\" \"1b_1m.bb, 1b_1m.ib, 1b_1m.mb, 1b_1m.fb, 1b_1m.lx\")\n+(exclusion_set \"1b_1m.bb\" \"1b_1m.ib, 1b_1m.mb, 1b_1m.fb, 1b_1m.lx\")\n+(exclusion_set \"1b_1m.ib\" \"1b_1m.mb, 1b_1m.fb, 1b_1m.lx\")\n+(exclusion_set \"1b_1m.mb\" \"1b_1m.fb, 1b_1m.lx\")\n+(exclusion_set \"1b_1m.fb\" \"1b_1m.lx\")\n+\n+;; Slot 5\n+(exclusion_set \"1b_1mi.i\"\n+   \"1b_1mm.i, 1b_1mf.i, 1b_1bb.b, 1b_1mb.b,\\\n+    1b_1mi.b, 1b_1mm.b, 1b_1mf.b, 1b_1mlx.\")\n+(exclusion_set \"1b_1mm.i\"\n+   \"1b_1mf.i, 1b_1bb.b, 1b_1mb.b, 1b_1mi.b, 1b_1mm.b, 1b_1mf.b, 1b_1mlx.\")\n+(exclusion_set \"1b_1mf.i\"\n+   \"1b_1bb.b, 1b_1mb.b, 1b_1mi.b, 1b_1mm.b, 1b_1mf.b, 1b_1mlx.\")\n+(exclusion_set \"1b_1bb.b\" \"1b_1mb.b, 1b_1mi.b, 1b_1mm.b, 1b_1mf.b, 1b_1mlx.\")\n+(exclusion_set \"1b_1mb.b\" \"1b_1mi.b, 1b_1mm.b, 1b_1mf.b, 1b_1mlx.\")\n+(exclusion_set \"1b_1mi.b\" \"1b_1mm.b, 1b_1mf.b, 1b_1mlx.\")\n+(exclusion_set \"1b_1mm.b\" \"1b_1mf.b, 1b_1mlx.\")\n+(exclusion_set \"1b_1mf.b\" \"1b_1mlx.\")\n+\n+;; Slot 6\n+(exclusion_set \"1b_1mii.\"\n+   \"1b_1mmi., 1b_1mfi., 1b_1bbb., 1b_1mbb.,\\\n+    1b_1mib., 1b_1mmb., 1b_1mfb., 1b_1mlx.\")\n+(exclusion_set \"1b_1mmi.\"\n+   \"1b_1mfi., 1b_1bbb., 1b_1mbb., 1b_1mib., 1b_1mmb., 1b_1mfb., 1b_1mlx.\")\n+(exclusion_set \"1b_1mfi.\"\n+   \"1b_1bbb., 1b_1mbb., 1b_1mib., 1b_1mmb., 1b_1mfb., 1b_1mlx.\")\n+(exclusion_set \"1b_1bbb.\" \"1b_1mbb., 1b_1mib., 1b_1mmb., 1b_1mfb., 1b_1mlx.\")\n+(exclusion_set \"1b_1mbb.\" \"1b_1mib., 1b_1mmb., 1b_1mfb., 1b_1mlx.\")\n+(exclusion_set \"1b_1mib.\" \"1b_1mmb., 1b_1mfb., 1b_1mlx.\")\n+(exclusion_set \"1b_1mmb.\" \"1b_1mfb., 1b_1mlx.\")\n+(exclusion_set \"1b_1mfb.\" \"1b_1mlx.\")\n+\n+(final_presence_set \"1b_0mi.i\" \"1b_0m.ii\")\n+(final_presence_set \"1b_0mii.\" \"1b_0mi.i\")\n+(final_presence_set \"1b_1mi.i\" \"1b_1m.ii\")\n+(final_presence_set \"1b_1mii.\" \"1b_1mi.i\")\n+\n+(final_presence_set \"1b_0mm.i\" \"1b_0m.mi\")\n+(final_presence_set \"1b_0mmi.\" \"1b_0mm.i\")\n+(final_presence_set \"1b_1mm.i\" \"1b_1m.mi\")\n+(final_presence_set \"1b_1mmi.\" \"1b_1mm.i\")\n+\n+(final_presence_set \"1b_0mf.i\" \"1b_0m.fi\")\n+(final_presence_set \"1b_0mfi.\" \"1b_0mf.i\")\n+(final_presence_set \"1b_1mf.i\" \"1b_1m.fi\")\n+(final_presence_set \"1b_1mfi.\" \"1b_1mf.i\")\n+\n+(final_presence_set \"1b_0mm.f\" \"1b_0m.mf\")\n+(final_presence_set \"1b_0mmf.\" \"1b_0mm.f\")\n+\n+(final_presence_set \"1b_0bb.b\" \"1b_0b.bb\")\n+(final_presence_set \"1b_0bbb.\" \"1b_0bb.b\")\n+(final_presence_set \"1b_1bb.b\" \"1b_1b.bb\")\n+(final_presence_set \"1b_1bbb.\" \"1b_1bb.b\")\n+\n+(final_presence_set \"1b_0mb.b\" \"1b_0m.bb\")\n+(final_presence_set \"1b_0mbb.\" \"1b_0mb.b\")\n+(final_presence_set \"1b_1mb.b\" \"1b_1m.bb\")\n+(final_presence_set \"1b_1mbb.\" \"1b_1mb.b\")\n+\n+(final_presence_set \"1b_0mi.b\" \"1b_0m.ib\")\n+(final_presence_set \"1b_0mib.\" \"1b_0mi.b\")\n+(final_presence_set \"1b_1mi.b\" \"1b_1m.ib\")\n+(final_presence_set \"1b_1mib.\" \"1b_1mi.b\")\n+\n+(final_presence_set \"1b_0mm.b\" \"1b_0m.mb\")\n+(final_presence_set \"1b_0mmb.\" \"1b_0mm.b\")\n+(final_presence_set \"1b_1mm.b\" \"1b_1m.mb\")\n+(final_presence_set \"1b_1mmb.\" \"1b_1mm.b\")\n+\n+(final_presence_set \"1b_0mf.b\" \"1b_0m.fb\")\n+(final_presence_set \"1b_0mfb.\" \"1b_0mf.b\")\n+(final_presence_set \"1b_1mf.b\" \"1b_1m.fb\")\n+(final_presence_set \"1b_1mfb.\" \"1b_1mf.b\")\n+\n+(final_presence_set \"1b_0mlx.\" \"1b_0m.lx\")\n+(final_presence_set \"1b_1mlx.\" \"1b_1m.lx\")\n+\n+(final_presence_set\n+   \"1b_1m.ii,1b_1m.mi,1b_1m.fi,1b_1b.bb,1b_1m.bb,\\\n+    1b_1m.ib,1b_1m.mb,1b_1m.fb,1b_1m.lx\"\n+   \"1b_0mii.,1b_0mmi.,1b_0mfi.,1b_0mmf.,1b_0bbb.,1b_0mbb.,\\\n+    1b_0mib.,1b_0mmb.,1b_0mfb.,1b_0mlx.\")\n+\n+;;  Microarchitecture units:\n+(define_cpu_unit\n+   \"1b_um0, 1b_um1, 1b_ui0, 1b_ui1, 1b_uf0, 1b_uf1, 1b_ub0, 1b_ub1, 1b_ub2,\\\n+    1b_unb0, 1b_unb1, 1b_unb2\" \"oneb\")\n+\n+(exclusion_set \"1b_ub0\" \"1b_unb0\")\n+(exclusion_set \"1b_ub1\" \"1b_unb1\")\n+(exclusion_set \"1b_ub2\" \"1b_unb2\")\n+\n+;; The following rules are used to decrease number of alternatives.\n+;; They are consequences of Itanium microarchitecture.  They also\n+;; describe the following rules mentioned in Itanium\n+;; microarchitecture: rules mentioned in Itanium microarchitecture:\n+;; o \"MMF: Always splits issue before the first M and after F regardless\n+;;   of surrounding bundles and stops\".\n+;; o \"BBB/MBB: Always splits issue after either of these bundles\".\n+;; o \"MIB BBB: Split issue after the first bundle in this pair\".\n+\n+(exclusion_set \"1b_0m.mf,1b_0mm.f,1b_0mmf.\"\n+   \"1b_1m.ii,1b_1m.mi,1b_1m.fi,1b_1b.bb,1b_1m.bb,\\\n+    1b_1m.ib,1b_1m.mb,1b_1m.fb,1b_1m.lx\")\n+(exclusion_set \"1b_0b.bb,1b_0bb.b,1b_0bbb.,1b_0m.bb,1b_0mb.b,1b_0mbb.\"\n+   \"1b_1m.ii,1b_1m.mi,1b_1m.fi,1b_1b.bb,1b_1m.bb,\\\n+    1b_1m.ib,1b_1m.mb,1b_1m.fb,1b_1m.lx\")\n+(exclusion_set \"1b_0m.ib,1b_0mi.b,1b_0mib.\" \"1b_1b.bb\")\n+\n+;;  For exceptions of M, I, B, F insns:\n+(define_cpu_unit \"1b_not_um1, 1b_not_ui1, 1b_not_uf1\" \"oneb\")\n+\n+(final_absence_set \"1b_not_um1\"  \"1b_um1\")\n+(final_absence_set \"1b_not_ui1\"  \"1b_ui1\")\n+(final_absence_set \"1b_not_uf1\"  \"1b_uf1\")\n+\n+;;; \"MIB/MFB/MMB: Splits issue after any of these bundles unless the\n+;;; B-slot contains a nop.b or a brp instruction\".\n+;;;   \"The B in an MIB/MFB/MMB bundle disperses to B0 if it is a brp or\n+;;; nop.b, otherwise it disperses to B2\".\n+(final_absence_set\n+   \"1b_1m.ii, 1b_1m.mi, 1b_1m.fi, 1b_1b.bb, 1b_1m.bb,\\\n+    1b_1m.ib, 1b_1m.mb, 1b_1m.fb, 1b_1m.lx\"\n+   \"1b_0mib. 1b_ub2, 1b_0mfb. 1b_ub2, 1b_0mmb. 1b_ub2\")\n+\n+;; This is necessary to start new processor cycle when we meet stop bit.\n+(define_cpu_unit \"1b_stop\" \"oneb\")\n+(final_absence_set\n+   \"1b_0m.ii,1b_0mi.i,1b_0mii.,1b_0m.mi,1b_0mm.i,1b_0mmi.,\\\n+    1b_0m.fi,1b_0mf.i,1b_0mfi.,\\\n+    1b_0m.mf,1b_0mm.f,1b_0mmf.,1b_0b.bb,1b_0bb.b,1b_0bbb.,\\\n+    1b_0m.bb,1b_0mb.b,1b_0mbb.,\\\n+    1b_0m.ib,1b_0mi.b,1b_0mib.,1b_0m.mb,1b_0mm.b,1b_0mmb.,\\\n+    1b_0m.fb,1b_0mf.b,1b_0mfb.,1b_0m.lx,1b_0mlx., \\\n+    1b_1m.ii,1b_1mi.i,1b_1mii.,1b_1m.mi,1b_1mm.i,1b_1mmi.,\\\n+    1b_1m.fi,1b_1mf.i,1b_1mfi.,\\\n+    1b_1b.bb,1b_1bb.b,1b_1bbb.,1b_1m.bb,1b_1mb.b,1b_1mbb.,\\\n+    1b_1m.ib,1b_1mi.b,1b_1mib.,\\\n+    1b_1m.mb,1b_1mm.b,1b_1mmb.,1b_1m.fb,1b_1mf.b,1b_1mfb.,1b_1m.lx,1b_1mlx.\"\n+   \"1b_stop\")\n+\n+;; M and I instruction is dispersed to the lowest numbered M or I unit\n+;; not already in use.  An I slot in the 3rd position of 2nd bundle is\n+;; always dispersed to I1\n+(final_presence_set \"1b_um1\" \"1b_um0\")\n+(final_presence_set \"1b_ui1\" \"1b_ui0, 1b_1mii., 1b_1mmi., 1b_1mfi.\")\n+\n+;; Insns\n+\n+;; M and I instruction is dispersed to the lowest numbered M or I unit\n+;; not already in use.  An I slot in the 3rd position of 2nd bundle is\n+;; always dispersed to I1\n+(define_reservation \"1b_M\"\n+  \"1b_0m.ii+1_1+1b_um0|1b_0m.mi+1_1+1b_um0|1b_0mm.i+1_2+(1b_um0|1b_um1)\\\n+   |1b_0m.fi+1_1+1b_um0|1b_0m.mf+1_1+1b_um0|1b_0mm.f+1_2+1b_um1\\\n+   |1b_0m.bb+1_1+1b_um0|1b_0m.ib+1_1+1b_um0|1b_0m.mb+1_1+1b_um0\\\n+   |1b_0mm.b+1_2+1b_um1|1b_0m.fb+1_1+1b_um0|1b_0m.lx+1_1+1b_um0\\\n+   |1b_1mm.i+1_5+1b_um1|1b_1mm.b+1_5+1b_um1\\\n+   |(1b_1m.ii+1_4|1b_1m.mi+1_4|1b_1m.fi+1_4|1b_1m.bb+1_4|1b_1m.ib+1_4\\\n+     |1b_1m.mb+1_4|1b_1m.fb+1_4|1b_1m.lx+1_4)\\\n+    +(1b_um0|1b_um1)\")\n+\n+;;  Exceptions for dispersal rules.\n+;; \"An I slot in the 3rd position of 2nd bundle is always dispersed to I1\".\n+(define_reservation \"1b_I\"\n+  \"1b_0mi.i+1_2+1b_ui0|1b_0mii.+1_3+(1b_ui0|1b_ui1)|1b_0mmi.+1_3+1b_ui0\\\n+   |1b_0mfi.+1_3+1b_ui0|1b_0mi.b+1_2+1b_ui0\\\n+   |(1b_1mi.i+1_5|1b_1mi.b+1_5)+(1b_ui0|1b_ui1)\\\n+   |1b_1mii.+1_6+1b_ui1|1b_1mmi.+1_6+1b_ui1|1b_1mfi.+1_6+1b_ui1\")\n+\n+;; \"An F slot in the 1st bundle disperses to F0\".\n+;; \"An F slot in the 2st bundle disperses to F1\".\n+(define_reservation \"1b_F\"\n+   \"1b_0mf.i+1_2+1b_uf0|1b_0mmf.+1_3+1b_uf0|1b_0mf.b+1_2+1b_uf0\\\n+    |1b_1mf.i+1_5+1b_uf1|1b_1mf.b+1_5+1b_uf1\")\n+\n+;;; \"Each B slot in MBB or BBB bundle disperses to the corresponding B\n+;;; unit. That is, a B slot in 1st position is despersed to B0.  In the\n+;;; 2nd position it is dispersed to B2\".\n+(define_reservation \"1b_NB\"\n+    \"1b_0b.bb+1_1+1b_unb0|1b_0bb.b+1_2+1b_unb1|1b_0bbb.+1_3+1b_unb2\\\n+     |1b_0mb.b+1_2+1b_unb1|1b_0mbb.+1_3+1b_unb2\\\n+     |1b_0mib.+1_3+1b_unb0|1b_0mmb.+1_3+1b_unb0|1b_0mfb.+1_3+1b_unb0\\\n+     |1b_1b.bb+1_4+1b_unb0|1b_1bb.b+1_5+1b_unb1\\\n+     |1b_1bbb.+1_6+1b_unb2|1b_1mb.b+1_5+1b_unb1|1b_1mbb.+1_6+1b_unb2\\\n+     |1b_1mib.+1_6+1b_unb0|1b_1mmb.+1_6+1b_unb0|1b_1mfb.+1_6+1b_unb0\")\n+\n+(define_reservation \"1b_B\"\n+   \"1b_0b.bb+1_1+1b_ub0|1b_0bb.b+1_2+1b_ub1|1b_0bbb.+1_3+1b_ub2\\\n+    |1b_0mb.b+1_2+1b_ub1|1b_0mbb.+1_3+1b_ub2|1b_0mib.+1_3+1b_ub2\\\n+    |1b_0mfb.+1_3+1b_ub2|1b_1b.bb+1_4+1b_ub0|1b_1bb.b+1_5+1b_ub1\\\n+    |1b_1bbb.+1_6+1b_ub2|1b_1mb.b+1_5+1b_ub1\\\n+    |1b_1mib.+1_6+1b_ub2|1b_1mmb.+1_6+1b_ub2|1b_1mfb.+1_6+1b_ub2\")\n+\n+(define_reservation \"1b_L\" \"1b_0mlx.+1_3+1b_ui0+1b_uf0\\\n+                           |1b_1mlx.+1_6+(1b_ui0|1b_ui1)+1b_uf1\")\n+\n+;; We assume that there is no insn issued on the same cycle as unknown insn.\n+(define_cpu_unit \"1b_empty\" \"oneb\")\n+(exclusion_set \"1b_empty\"\n+    \"1b_0m.ii,1b_0m.mi,1b_0m.fi,1b_0m.mf,1b_0b.bb,1b_0m.bb,\\\n+     1b_0m.ib,1b_0m.mb,1b_0m.fb,1b_0m.lx\")\n+\n+(define_cpu_unit\n+   \"1b_0m_bs, 1b_0mi_bs, 1b_0mm_bs, 1b_0mf_bs, 1b_0b_bs, 1b_0bb_bs, 1b_0mb_bs\"\n+   \"oneb\")\n+(define_cpu_unit\n+   \"1b_1m_bs, 1b_1mi_bs, 1b_1mm_bs, 1b_1mf_bs, 1b_1b_bs, 1b_1bb_bs, 1b_1mb_bs\"\n+   \"oneb\")\n+\n+(define_cpu_unit \"1b_m_cont, 1b_mi_cont, 1b_mm_cont, 1b_mf_cont, 1b_mb_cont,\\\n+\t          1b_b_cont, 1b_bb_cont\" \"oneb\")\n+\n+;; For stop in the middle of the bundles.\n+(define_cpu_unit \"1b_m_stop, 1b_m0_stop, 1b_m1_stop, 1b_0mmi_cont\" \"oneb\")\n+(define_cpu_unit \"1b_mi_stop, 1b_mi0_stop, 1b_mi1_stop, 1b_0mii_cont\" \"oneb\")\n+\n+(final_presence_set \"1b_0m_bs\"\n+   \"1b_0m.ii, 1b_0m.mi, 1b_0m.mf, 1b_0m.fi, 1b_0m.bb,\\\n+    1b_0m.ib, 1b_0m.fb, 1b_0m.mb, 1b_0m.lx\")\n+(final_presence_set \"1b_1m_bs\"\n+   \"1b_1m.ii, 1b_1m.mi, 1b_1m.fi, 1b_1m.bb, 1b_1m.ib, 1b_1m.fb, 1b_1m.mb,\\\n+    1b_1m.lx\")\n+(final_presence_set \"1b_0mi_bs\"  \"1b_0mi.i, 1b_0mi.i\")\n+(final_presence_set \"1b_1mi_bs\"  \"1b_1mi.i, 1b_1mi.i\")\n+(final_presence_set \"1b_0mm_bs\"  \"1b_0mm.i, 1b_0mm.f, 1b_0mm.b\")\n+(final_presence_set \"1b_1mm_bs\"  \"1b_1mm.i, 1b_1mm.b\")\n+(final_presence_set \"1b_0mf_bs\"  \"1b_0mf.i, 1b_0mf.b\")\n+(final_presence_set \"1b_1mf_bs\"  \"1b_1mf.i, 1b_1mf.b\")\n+(final_presence_set \"1b_0b_bs\"  \"1b_0b.bb\")\n+(final_presence_set \"1b_1b_bs\"  \"1b_1b.bb\")\n+(final_presence_set \"1b_0bb_bs\"  \"1b_0bb.b\")\n+(final_presence_set \"1b_1bb_bs\"  \"1b_1bb.b\")\n+(final_presence_set \"1b_0mb_bs\"  \"1b_0mb.b\")\n+(final_presence_set \"1b_1mb_bs\"  \"1b_1mb.b\")\n+\n+(exclusion_set \"1b_0m_bs\"\n+   \"1b_0mi.i, 1b_0mm.i, 1b_0mm.f, 1b_0mf.i, 1b_0mb.b,\\\n+    1b_0mi.b, 1b_0mf.b, 1b_0mm.b, 1b_0mlx., 1b_m0_stop\")\n+(exclusion_set \"1b_1m_bs\"\n+   \"1b_1mi.i, 1b_1mm.i, 1b_1mf.i, 1b_1mb.b, 1b_1mi.b, 1b_1mf.b, 1b_1mm.b,\\\n+    1b_1mlx., 1b_m1_stop\")\n+(exclusion_set \"1b_0mi_bs\"  \"1b_0mii., 1b_0mib., 1b_mi0_stop\")\n+(exclusion_set \"1b_1mi_bs\"  \"1b_1mii., 1b_1mib., 1b_mi1_stop\")\n+(exclusion_set \"1b_0mm_bs\"  \"1b_0mmi., 1b_0mmf., 1b_0mmb.\")\n+(exclusion_set \"1b_1mm_bs\"  \"1b_1mmi., 1b_1mmb.\")\n+(exclusion_set \"1b_0mf_bs\"  \"1b_0mfi., 1b_0mfb.\")\n+(exclusion_set \"1b_1mf_bs\"  \"1b_1mfi., 1b_1mfb.\")\n+(exclusion_set \"1b_0b_bs\"  \"1b_0bb.b\")\n+(exclusion_set \"1b_1b_bs\"  \"1b_1bb.b\")\n+(exclusion_set \"1b_0bb_bs\"  \"1b_0bbb.\")\n+(exclusion_set \"1b_1bb_bs\"  \"1b_1bbb.\")\n+(exclusion_set \"1b_0mb_bs\"  \"1b_0mbb.\")\n+(exclusion_set \"1b_1mb_bs\"  \"1b_1mbb.\")\n+\n+(exclusion_set\n+   \"1b_0m_bs, 1b_0mi_bs, 1b_0mm_bs, 1b_0mf_bs, 1b_0b_bs, 1b_0bb_bs, 1b_0mb_bs,\n+    1b_1m_bs, 1b_1mi_bs, 1b_1mm_bs, 1b_1mf_bs, 1b_1b_bs, 1b_1bb_bs, 1b_1mb_bs\"\n+   \"1b_stop\")\n+\n+(final_presence_set\n+   \"1b_0mi.i, 1b_0mm.i, 1b_0mf.i, 1b_0mm.f, 1b_0mb.b,\\\n+    1b_0mi.b, 1b_0mm.b, 1b_0mf.b, 1b_0mlx.\"\n+   \"1b_m_cont\")\n+(final_presence_set \"1b_0mii., 1b_0mib.\" \"1b_mi_cont\")\n+(final_presence_set \"1b_0mmi., 1b_0mmf., 1b_0mmb.\" \"1b_mm_cont\")\n+(final_presence_set \"1b_0mfi., 1b_0mfb.\" \"1b_mf_cont\")\n+(final_presence_set \"1b_0bb.b\" \"1b_b_cont\")\n+(final_presence_set \"1b_0bbb.\" \"1b_bb_cont\")\n+(final_presence_set \"1b_0mbb.\" \"1b_mb_cont\")\n+\n+(exclusion_set\n+   \"1b_0m.ii, 1b_0m.mi, 1b_0m.fi, 1b_0m.mf, 1b_0b.bb, 1b_0m.bb,\\\n+    1b_0m.ib, 1b_0m.mb, 1b_0m.fb, 1b_0m.lx\"\n+   \"1b_m_cont, 1b_mi_cont, 1b_mm_cont, 1b_mf_cont,\\\n+    1b_mb_cont, 1b_b_cont, 1b_bb_cont\")\n+\n+(exclusion_set \"1b_empty\"\n+               \"1b_m_cont,1b_mi_cont,1b_mm_cont,1b_mf_cont,\\\n+                1b_mb_cont,1b_b_cont,1b_bb_cont\")\n+\n+;; For m;mi bundle\n+(final_presence_set \"1b_m0_stop\" \"1b_0m.mi\")\n+(final_presence_set \"1b_0mm.i\" \"1b_0mmi_cont\")\n+(exclusion_set \"1b_0mmi_cont\"\n+   \"1b_0m.ii, 1b_0m.mi, 1b_0m.fi, 1b_0m.mf, 1b_0b.bb, 1b_0m.bb,\\\n+    1b_0m.ib, 1b_0m.mb, 1b_0m.fb, 1b_0m.lx\")\n+(exclusion_set \"1b_m0_stop\" \"1b_0mm.i\")\n+(final_presence_set \"1b_m1_stop\" \"1b_1m.mi\")\n+(exclusion_set \"1b_m1_stop\" \"1b_1mm.i\")\n+(final_presence_set \"1b_m_stop\" \"1b_m0_stop, 1b_m1_stop\")\n+\n+;; For mi;i bundle\n+(final_presence_set \"1b_mi0_stop\" \"1b_0mi.i\")\n+(final_presence_set \"1b_0mii.\" \"1b_0mii_cont\")\n+(exclusion_set \"1b_0mii_cont\"\n+   \"1b_0m.ii, 1b_0m.mi, 1b_0m.fi, 1b_0m.mf, 1b_0b.bb, 1b_0m.bb,\\\n+    1b_0m.ib, 1b_0m.mb, 1b_0m.fb, 1b_0m.lx\")\n+(exclusion_set \"1b_mi0_stop\" \"1b_0mii.\")\n+(final_presence_set \"1b_mi1_stop\" \"1b_1mi.i\")\n+(exclusion_set \"1b_mi1_stop\" \"1b_1mii.\")\n+(final_presence_set \"1b_mi_stop\" \"1b_mi0_stop, 1b_mi1_stop\")\n+\n+(final_absence_set\n+   \"1b_0m.ii,1b_0mi.i,1b_0mii.,1b_0m.mi,1b_0mm.i,1b_0mmi.,\\\n+    1b_0m.fi,1b_0mf.i,1b_0mfi.,1b_0m.mf,1b_0mm.f,1b_0mmf.,\\\n+    1b_0b.bb,1b_0bb.b,1b_0bbb.,1b_0m.bb,1b_0mb.b,1b_0mbb.,\\\n+    1b_0m.ib,1b_0mi.b,1b_0mib.,1b_0m.mb,1b_0mm.b,1b_0mmb.,\\\n+    1b_0m.fb,1b_0mf.b,1b_0mfb.,1b_0m.lx,1b_0mlx., \\\n+    1b_1m.ii,1b_1mi.i,1b_1mii.,1b_1m.mi,1b_1mm.i,1b_1mmi.,\\\n+    1b_1m.fi,1b_1mf.i,1b_1mfi.,\\\n+    1b_1b.bb,1b_1bb.b,1b_1bbb.,1b_1m.bb,1b_1mb.b,1b_1mbb.,\\\n+    1b_1m.ib,1b_1mi.b,1b_1mib.,1b_1m.mb,1b_1mm.b,1b_1mmb.,\\\n+    1b_1m.fb,1b_1mf.b,1b_1mfb.,1b_1m.lx,1b_1mlx.\"\n+   \"1b_m0_stop,1b_m1_stop,1b_mi0_stop,1b_mi1_stop\")\n+\n+(define_reservation \"1b_A\" \"1b_M|1b_I\")\n+\n+(define_insn_reservation \"1b_stop_bit\" 0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"stop_bit\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1b_stop|1b_m0_stop|1b_m1_stop|1b_mi0_stop|1b_mi1_stop\")\n+(define_insn_reservation \"1b_br\"      0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"br\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_B\")\n+(define_insn_reservation \"1b_scall\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"scall\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_B\")\n+(define_insn_reservation \"1b_fcmp\"    2\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"fcmp\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1b_F+1b_not_uf1\")\n+(define_insn_reservation \"1b_fcvtfx\"  7\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"fcvtfx\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_F\")\n+(define_insn_reservation \"1b_fld\"     9\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"fld\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_M\")\n+(define_insn_reservation \"1b_fmac\"    5\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"fmac\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_F\")\n+(define_insn_reservation \"1b_fmisc\"   5\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"fmisc\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1b_F+1b_not_uf1\")\n+(define_insn_reservation \"1b_frar_i\" 13\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"frar_i\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1b_I+1b_not_ui1\")\n+(define_insn_reservation \"1b_frar_m\"  6\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"frar_m\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1b_M+1b_not_um1\")\n+(define_insn_reservation \"1b_frbr\"    2\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"frbr\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1b_I+1b_not_ui1\")\n+(define_insn_reservation \"1b_frfr\"    2\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"frfr\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1b_M+1b_not_um1\")\n+(define_insn_reservation \"1b_frpr\"    2\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"frpr\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1b_I+1b_not_ui1\")\n+(define_insn_reservation \"1b_ialu\"      1\n+    (and (and (eq_attr \"cpu\" \"itanium\")\n+              (eq_attr \"itanium_class\" \"ialu\"))\n+         (ne (symbol_ref\n+\t      \"bundling_p && !ia64_produce_address_p (insn)\")\n+             (const_int 0)))\n+    \"1b_A\")\n+(define_insn_reservation \"1b_ialu_addr\" 1\n+    (and (and (eq_attr \"cpu\" \"itanium\")\n+              (eq_attr \"itanium_class\" \"ialu\"))\n+         (eq (symbol_ref\n+              \"bundling_p && ia64_produce_address_p (insn)\")\n+             (const_int 1)))\n+    \"1b_M\")\n+(define_insn_reservation \"1b_icmp\"    1\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"icmp\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_A\")\n+(define_insn_reservation \"1b_ilog\"    1\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"ilog\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_A\")\n+(define_insn_reservation \"1b_ishf\"    1\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"ishf\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1b_I+1b_not_ui1\")\n+(define_insn_reservation \"1b_ld\"      2\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"ld\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_M\")\n+(define_insn_reservation \"1b_long_i\"  1\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"long_i\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_L\")\n+(define_insn_reservation \"1b_mmmul\"   2\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"mmmul\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1b_I+1b_not_ui1\")\n+(define_insn_reservation \"1b_mmshf\"   2\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"mmshf\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_I\")\n+(define_insn_reservation \"1b_mmshfi\"  2\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"mmshfi\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_I\")\n+(define_insn_reservation \"1b_rse_m\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"rse_m\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+   \"(1b_0m.ii|1b_0m.mi|1b_0m.fi|1b_0m.mf|1b_0b.bb|1b_0m.bb\\\n+     |1b_0m.ib|1b_0m.mb|1b_0m.fb|1b_0m.lx)+1_1+1b_um0\")\n+(define_insn_reservation \"1b_sem\"     0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"sem\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1b_M+1b_not_um1\")\n+(define_insn_reservation \"1b_stf\"     1\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"stf\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_M\")\n+(define_insn_reservation \"1b_st\"      1\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"st\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_M\")\n+(define_insn_reservation \"1b_syst_m0\" 0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"syst_m0\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1b_M+1b_not_um1\")\n+(define_insn_reservation \"1b_syst_m\"  0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"syst_m\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_M\")\n+(define_insn_reservation \"1b_tbit\"    1\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"tbit\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1b_I+1b_not_ui1\")\n+(define_insn_reservation \"1b_toar_i\"  0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"toar_i\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1b_I+1b_not_ui1\")\n+(define_insn_reservation \"1b_toar_m\"  5\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"toar_m\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1b_M+1b_not_um1\")\n+(define_insn_reservation \"1b_tobr\"    1\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"tobr\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1b_I+1b_not_ui1\")\n+(define_insn_reservation \"1b_tofr\"    9\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"tofr\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_M\")\n+(define_insn_reservation \"1b_topr\"    1\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"topr\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1b_I+1b_not_ui1\")\n+(define_insn_reservation \"1b_xmpy\"    7\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"xmpy\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_F\")\n+(define_insn_reservation \"1b_xtd\"     1\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"xtd\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_I\")\n+(define_insn_reservation \"1b_chk_s\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"chk_s\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_A\")\n+(define_insn_reservation \"1b_lfetch\"  0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"lfetch\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_M\")\n+(define_insn_reservation \"1b_nop_m\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"nop_m\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_M\")\n+(define_insn_reservation \"1b_nop_b\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"nop_b\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_NB\")\n+(define_insn_reservation \"1b_nop_i\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"nop_i\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_I\")\n+(define_insn_reservation \"1b_nop_f\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"nop_f\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_F\")\n+(define_insn_reservation \"1b_nop_x\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"nop_x\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_L\")\n+(define_insn_reservation \"1b_unknown\" 1\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"unknown\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1b_empty\")\n+(define_insn_reservation \"1b_nop\" 1\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"nop\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"1b_M|1b_NB|1b_I|1b_F\")\n+(define_insn_reservation \"1b_ignore\" 0\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"ignore\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"nothing\")\n+\n+(define_insn_reservation \"1b_pre_cycle\" 0\n+   (and (and (eq_attr \"cpu\" \"itanium\")\n+             (eq_attr \"itanium_class\" \"pre_cycle\"))\n+        (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+                         \"(1b_0m_bs, 1b_m_cont)     \\\n+                          | (1b_0mi_bs, 1b_mi_cont) \\\n+                          | (1b_0mm_bs, 1b_mm_cont) \\\n+                          | (1b_0mf_bs, 1b_mf_cont) \\\n+                          | (1b_0b_bs, 1b_b_cont)   \\\n+                          | (1b_0bb_bs, 1b_bb_cont) \\\n+                          | (1b_0mb_bs, 1b_mb_cont) \\\n+                          | (1b_1m_bs, 1b_m_cont)   \\\n+                          | (1b_1mi_bs, 1b_mi_cont) \\\n+                          | (1b_1mm_bs, 1b_mm_cont) \\\n+                          | (1b_1mf_bs, 1b_mf_cont) \\\n+                          | (1b_1b_bs, 1b_b_cont)   \\\n+                          | (1b_1bb_bs, 1b_bb_cont) \\\n+                          | (1b_1mb_bs, 1b_mb_cont) \\\n+                          | (1b_m_stop, 1b_0mmi_cont)   \\\n+                          | (1b_mi_stop, 1b_0mii_cont)\")\n+"}, {"sha": "73b533ea70c6861e9a261d2368b7d30c5b40576f", "filename": "gcc/config/ia64/itanium2.md", "status": "added", "additions": 1762, "deletions": 0, "changes": 1762, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fconfig%2Fia64%2Fitanium2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fconfig%2Fia64%2Fitanium2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fitanium2.md?ref=30028c85159c12c4e8920af0a9111372e56f1636", "patch": "@@ -0,0 +1,1762 @@\n+;; Itanium2 DFA descriptions for insn scheduling and bundling.\n+;; Copyright (C) 2002 Free Software Foundation, Inc.\n+;; Contributed by Vladimir Makarov <vmakarov@redhat.com>.\n+;;\n+;; This file is part of GNU CC.\n+;;\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.  */\n+;;\n+\n+/* This is description of pipeline hazards based on DFA.  The\n+   following constructions can be used for this:\n+   \n+   o define_cpu_unit string [string]) describes a cpu functional unit\n+     (separated by comma).\n+\n+     1st operand: Names of cpu function units.\n+     2nd operand: Name of automaton (see comments for\n+     DEFINE_AUTOMATON).\n+\n+     All define_reservations and define_cpu_units should have unique\n+     names which can not be \"nothing\".\n+\n+   o (exclusion_set string string) means that each CPU function unit\n+     in the first string can not be reserved simultaneously with each\n+     unit whose name is in the second string and vise versa.  CPU\n+     units in the string are separated by commas. For example, it is\n+     useful for description CPU with fully pipelined floating point\n+     functional unit which can execute simultaneously only single\n+     floating point insns or only double floating point insns.\n+\n+   o (presence_set string string) means that each CPU function unit in\n+     the first string can not be reserved unless at least one of\n+     pattern of units whose names are in the second string is\n+     reserved.  This is an asymmetric relation.  CPU units or unit\n+     patterns in the strings are separated by commas.  Pattern is one\n+     unit name or unit names separated by white-spaces.\n+ \n+     For example, it is useful for description that slot1 is reserved\n+     after slot0 reservation for a VLIW processor.  We could describe\n+     it by the following construction\n+\n+         (presence_set \"slot1\" \"slot0\")\n+\n+     Or slot1 is reserved only after slot0 and unit b0 reservation.\n+     In this case we could write\n+\n+         (presence_set \"slot1\" \"slot0 b0\")\n+\n+     All CPU functional units in a set should belong to the same\n+     automaton.\n+\n+   o (final_presence_set string string) is analogous to\n+     `presence_set'.  The difference between them is when checking is\n+     done.  When an instruction is issued in given automaton state\n+     reflecting all current and planned unit reservations, the\n+     automaton state is changed.  The first state is a source state,\n+     the second one is a result state.  Checking for `presence_set' is\n+     done on the source state reservation, checking for\n+     `final_presence_set' is done on the result reservation.  This\n+     construction is useful to describe a reservation which is\n+     actually two subsequent reservations.  For example, if we use\n+\n+         (presence_set \"slot1\" \"slot0\")\n+\n+     the following insn will be never issued (because slot1 requires\n+     slot0 which is absent in the source state).\n+\n+         (define_reservation \"insn_and_nop\" \"slot0 + slot1\")\n+\n+     but it can be issued if we use analogous `final_presence_set'.\n+\n+   o (absence_set string string) means that each CPU function unit in\n+     the first string can be reserved only if each pattern of units\n+     whose names are in the second string is not reserved.  This is an\n+     asymmetric relation (actually exclusion set is analogous to this\n+     one but it is symmetric).  CPU units or unit patterns in the\n+     string are separated by commas.  Pattern is one unit name or unit\n+     names separated by white-spaces.\n+\n+     For example, it is useful for description that slot0 can not be\n+     reserved after slot1 or slot2 reservation for a VLIW processor.\n+     We could describe it by the following construction\n+\n+        (absence_set \"slot2\" \"slot0, slot1\")\n+\n+     Or slot2 can not be reserved if slot0 and unit b0 are reserved or\n+     slot1 and unit b1 are reserved .  In this case we could write\n+\n+        (absence_set \"slot2\" \"slot0 b0, slot1 b1\")\n+\n+     All CPU functional units in a set should to belong the same\n+     automaton.\n+\n+   o (final_absence_set string string) is analogous to `absence_set' but\n+     checking is done on the result (state) reservation.  See comments\n+     for final_presence_set.\n+\n+   o (define_bypass number out_insn_names in_insn_names) names bypass with\n+     given latency (the first number) from insns given by the first\n+     string (see define_insn_reservation) into insns given by the\n+     second string.  Insn names in the strings are separated by\n+     commas.\n+\n+   o (define_automaton string) describes names of an automaton\n+     generated and used for pipeline hazards recognition.  The names\n+     are separated by comma.  Actually it is possibly to generate the\n+     single automaton but unfortunately it can be very large.  If we\n+     use more one automata, the summary size of the automata usually\n+     is less than the single one.  The automaton name is used in\n+     define_cpu_unit.  All automata should have unique names.\n+\n+   o (automata_option string) describes option for generation of\n+     automata.  Currently there are the following options:\n+\n+     o \"no-minimization\" which makes no minimization of automata.\n+       This is only worth to do when we are debugging the description\n+       and need to look more accurately at reservations of states.\n+\n+     o \"ndfa\" which makes automata with nondetermenistic reservation\n+        by insns.\n+\n+   o (define_reservation string string) names reservation (the first\n+     string) of cpu functional units (the 2nd string).  Sometimes unit\n+     reservations for different insns contain common parts.  In such\n+     case, you describe common part and use one its name (the 1st\n+     parameter) in regular expression in define_insn_reservation.  All\n+     define_reservations, define results and define_cpu_units should\n+     have unique names which can not be \"nothing\".\n+\n+   o (define_insn_reservation name default_latency condition regexpr)\n+     describes reservation of cpu functional units (the 3nd operand)\n+     for instruction which is selected by the condition (the 2nd\n+     parameter).  The first parameter is used for output of debugging\n+     information.  The reservations are described by a regular\n+     expression according the following syntax:\n+\n+       regexp = regexp \",\" oneof\n+              | oneof\n+\n+       oneof = oneof \"|\" allof\n+             | allof\n+\n+       allof = allof \"+\" repeat\n+             | repeat\n+ \n+       repeat = element \"*\" number\n+              | element\n+\n+       element = cpu_function_name\n+               | reservation_name\n+               | result_name\n+               | \"nothing\"\n+               | \"(\" regexp \")\"\n+\n+       1. \",\" is used for describing start of the next cycle in\n+          reservation.\n+\n+       2. \"|\" is used for describing the reservation described by the\n+          first regular expression *or* the reservation described by\n+          the second regular expression *or* etc.\n+\n+       3. \"+\" is used for describing the reservation described by the\n+          first regular expression *and* the reservation described by\n+          the second regular expression *and* etc.\n+\n+       4. \"*\" is used for convinience and simply means sequence in\n+          which the regular expression are repeated NUMBER times with\n+          cycle advancing (see \",\").\n+\n+       5. cpu function unit name which means reservation.\n+\n+       6. reservation name -- see define_reservation.\n+\n+       7. string \"nothing\" means no units reservation.\n+\n+*/\n+\n+(define_automaton \"two\")\n+\n+;;   All possible combinations of bundles/syllables\n+(define_cpu_unit \"2_0m.ii, 2_0m.mi, 2_0m.fi, 2_0m.mf, 2_0b.bb, 2_0m.bb,\\\n+                  2_0m.ib, 2_0m.mb, 2_0m.fb, 2_0m.lx\" \"two\")\n+(define_cpu_unit \"2_0mi.i, 2_0mm.i, 2_0mf.i, 2_0mm.f, 2_0bb.b, 2_0mb.b,\\\n+                  2_0mi.b, 2_0mm.b, 2_0mf.b, 2_0mlx.\" \"two\")\n+(define_cpu_unit \"2_0mii., 2_0mmi., 2_0mfi., 2_0mmf., 2_0bbb., 2_0mbb.,\\\n+                  2_0mib., 2_0mmb., 2_0mfb.\" \"two\")\n+\n+(define_cpu_unit \"2_1m.ii, 2_1m.mi, 2_1m.fi, 2_1m.mf, 2_1b.bb, 2_1m.bb,\\\n+                  2_1m.ib, 2_1m.mb, 2_1m.fb, 2_1m.lx\" \"two\")\n+(define_cpu_unit \"2_1mi.i, 2_1mm.i, 2_1mf.i, 2_1mm.f, 2_1bb.b, 2_1mb.b,\\\n+                  2_1mi.b, 2_1mm.b, 2_1mf.b, 2_1mlx.\" \"two\")\n+(define_cpu_unit \"2_1mii., 2_1mmi., 2_1mfi., 2_1mmf., 2_1bbb., 2_1mbb.,\\\n+                  2_1mib., 2_1mmb., 2_1mfb.\" \"two\")\n+\n+;; Slot 1\n+(exclusion_set \"2_0m.ii\" \"2_0m.mi, 2_0m.fi, 2_0m.mf, 2_0b.bb, 2_0m.bb,\\\n+                          2_0m.ib, 2_0m.mb, 2_0m.fb, 2_0m.lx\")\n+(exclusion_set \"2_0m.mi\" \"2_0m.fi, 2_0m.mf, 2_0b.bb, 2_0m.bb, 2_0m.ib,\\\n+                          2_0m.mb, 2_0m.fb, 2_0m.lx\")\n+(exclusion_set \"2_0m.fi\" \"2_0m.mf, 2_0b.bb, 2_0m.bb, 2_0m.ib, 2_0m.mb,\\\n+                          2_0m.fb, 2_0m.lx\")\n+(exclusion_set \"2_0m.mf\" \"2_0b.bb, 2_0m.bb, 2_0m.ib, 2_0m.mb, 2_0m.fb,\\\n+\t                  2_0m.lx\")\n+(exclusion_set \"2_0b.bb\" \"2_0m.bb, 2_0m.ib, 2_0m.mb, 2_0m.fb, 2_0m.lx\")\n+(exclusion_set \"2_0m.bb\" \"2_0m.ib, 2_0m.mb, 2_0m.fb, 2_0m.lx\")\n+(exclusion_set \"2_0m.ib\" \"2_0m.mb, 2_0m.fb, 2_0m.lx\")\n+(exclusion_set \"2_0m.mb\" \"2_0m.fb, 2_0m.lx\")\n+(exclusion_set \"2_0m.fb\" \"2_0m.lx\")\n+\n+;; Slot 2\n+(exclusion_set \"2_0mi.i\" \"2_0mm.i, 2_0mf.i, 2_0mm.f, 2_0bb.b, 2_0mb.b,\\\n+                          2_0mi.b, 2_0mm.b, 2_0mf.b, 2_0mlx.\")\n+(exclusion_set \"2_0mm.i\" \"2_0mf.i, 2_0mm.f, 2_0bb.b, 2_0mb.b,\\\n+                          2_0mi.b, 2_0mm.b, 2_0mf.b, 2_0mlx.\")\n+(exclusion_set \"2_0mf.i\" \"2_0mm.f, 2_0bb.b, 2_0mb.b, 2_0mi.b, 2_0mm.b,\\\n+                          2_0mf.b, 2_0mlx.\")\n+(exclusion_set \"2_0mm.f\" \"2_0bb.b, 2_0mb.b, 2_0mi.b, 2_0mm.b, 2_0mf.b,\\\n+                          2_0mlx.\")\n+(exclusion_set \"2_0bb.b\" \"2_0mb.b, 2_0mi.b, 2_0mm.b, 2_0mf.b, 2_0mlx.\")\n+(exclusion_set \"2_0mb.b\" \"2_0mi.b, 2_0mm.b, 2_0mf.b, 2_0mlx.\")\n+(exclusion_set \"2_0mi.b\" \"2_0mm.b, 2_0mf.b, 2_0mlx.\")\n+(exclusion_set \"2_0mm.b\" \"2_0mf.b, 2_0mlx.\")\n+(exclusion_set \"2_0mf.b\" \"2_0mlx.\")\n+\n+;; Slot 3\n+(exclusion_set \"2_0mii.\" \"2_0mmi., 2_0mfi., 2_0mmf., 2_0bbb., 2_0mbb.,\\\n+                          2_0mib., 2_0mmb., 2_0mfb., 2_0mlx.\")\n+(exclusion_set \"2_0mmi.\" \"2_0mfi., 2_0mmf., 2_0bbb., 2_0mbb.,\\\n+                          2_0mib., 2_0mmb., 2_0mfb., 2_0mlx.\")\n+(exclusion_set \"2_0mfi.\" \"2_0mmf., 2_0bbb., 2_0mbb., 2_0mib., 2_0mmb.,\\\n+                          2_0mfb., 2_0mlx.\")\n+(exclusion_set \"2_0mmf.\" \"2_0bbb., 2_0mbb., 2_0mib., 2_0mmb., 2_0mfb.,\\\n+                          2_0mlx.\")\n+(exclusion_set \"2_0bbb.\" \"2_0mbb., 2_0mib., 2_0mmb., 2_0mfb., 2_0mlx.\")\n+(exclusion_set \"2_0mbb.\" \"2_0mib., 2_0mmb., 2_0mfb., 2_0mlx.\")\n+(exclusion_set \"2_0mib.\" \"2_0mmb., 2_0mfb., 2_0mlx.\")\n+(exclusion_set \"2_0mmb.\" \"2_0mfb., 2_0mlx.\")\n+(exclusion_set \"2_0mfb.\" \"2_0mlx.\")\n+\n+;; Slot 4\n+(exclusion_set \"2_1m.ii\" \"2_1m.mi, 2_1m.fi, 2_1m.mf, 2_1b.bb, 2_1m.bb,\\\n+                          2_1m.ib, 2_1m.mb, 2_1m.fb, 2_1m.lx\")\n+(exclusion_set \"2_1m.mi\" \"2_1m.fi, 2_1m.mf, 2_1b.bb, 2_1m.bb, 2_1m.ib,\\\n+                          2_1m.mb, 2_1m.fb, 2_1m.lx\")\n+(exclusion_set \"2_1m.fi\" \"2_1m.mf, 2_1b.bb, 2_1m.bb, 2_1m.ib, 2_1m.mb,\\\n+                          2_1m.fb, 2_1m.lx\")\n+(exclusion_set \"2_1m.mf\" \"2_1b.bb, 2_1m.bb, 2_1m.ib, 2_1m.mb, 2_1m.fb,\\\n+                          2_1m.lx\")\n+(exclusion_set \"2_1b.bb\" \"2_1m.bb, 2_1m.ib, 2_1m.mb, 2_1m.fb, 2_1m.lx\")\n+(exclusion_set \"2_1m.bb\" \"2_1m.ib, 2_1m.mb, 2_1m.fb, 2_1m.lx\")\n+(exclusion_set \"2_1m.ib\" \"2_1m.mb, 2_1m.fb, 2_1m.lx\")\n+(exclusion_set \"2_1m.mb\" \"2_1m.fb, 2_1m.lx\")\n+(exclusion_set \"2_1m.fb\" \"2_1m.lx\")\n+\n+;; Slot 5\n+(exclusion_set \"2_1mi.i\" \"2_1mm.i, 2_1mf.i, 2_1mm.f, 2_1bb.b, 2_1mb.b,\\\n+                          2_1mi.b, 2_1mm.b, 2_1mf.b, 2_1mlx.\")\n+(exclusion_set \"2_1mm.i\" \"2_1mf.i, 2_1mm.f, 2_1bb.b, 2_1mb.b,\\\n+                          2_1mi.b, 2_1mm.b, 2_1mf.b, 2_1mlx.\")\n+(exclusion_set \"2_1mf.i\" \"2_1mm.f, 2_1bb.b, 2_1mb.b, 2_1mi.b, 2_1mm.b,\\\n+                          2_1mf.b, 2_1mlx.\")\n+(exclusion_set \"2_1mm.f\" \"2_1bb.b, 2_1mb.b, 2_1mi.b, 2_1mm.b, 2_1mf.b,\\\n+                          2_1mlx.\")\n+(exclusion_set \"2_1bb.b\" \"2_1mb.b, 2_1mi.b, 2_1mm.b, 2_1mf.b, 2_1mlx.\")\n+(exclusion_set \"2_1mb.b\" \"2_1mi.b, 2_1mm.b, 2_1mf.b, 2_1mlx.\")\n+(exclusion_set \"2_1mi.b\" \"2_1mm.b, 2_1mf.b, 2_1mlx.\")\n+(exclusion_set \"2_1mm.b\" \"2_1mf.b, 2_1mlx.\")\n+(exclusion_set \"2_1mf.b\" \"2_1mlx.\")\n+\n+;; Slot 6\n+(exclusion_set \"2_1mii.\" \"2_1mmi., 2_1mfi., 2_1mmf., 2_1bbb., 2_1mbb.,\\\n+                          2_1mib., 2_1mmb., 2_1mfb., 2_1mlx.\")\n+(exclusion_set \"2_1mmi.\" \"2_1mfi., 2_1mmf., 2_1bbb., 2_1mbb.,\\\n+                          2_1mib., 2_1mmb., 2_1mfb., 2_1mlx.\")\n+(exclusion_set \"2_1mfi.\" \"2_1mmf., 2_1bbb., 2_1mbb., 2_1mib., 2_1mmb.,\\\n+                          2_1mfb., 2_1mlx.\")\n+(exclusion_set \"2_1mmf.\" \"2_1bbb., 2_1mbb., 2_1mib., 2_1mmb., 2_1mfb.,\\\n+                          2_1mlx.\")\n+(exclusion_set \"2_1bbb.\" \"2_1mbb., 2_1mib., 2_1mmb., 2_1mfb., 2_1mlx.\")\n+(exclusion_set \"2_1mbb.\" \"2_1mib., 2_1mmb., 2_1mfb., 2_1mlx.\")\n+(exclusion_set \"2_1mib.\" \"2_1mmb., 2_1mfb., 2_1mlx.\")\n+(exclusion_set \"2_1mmb.\" \"2_1mfb., 2_1mlx.\")\n+(exclusion_set \"2_1mfb.\" \"2_1mlx.\")\n+\n+(final_presence_set \"2_0mi.i\" \"2_0m.ii\")\n+(final_presence_set \"2_0mii.\" \"2_0mi.i\")\n+(final_presence_set \"2_1mi.i\" \"2_1m.ii\")\n+(final_presence_set \"2_1mii.\" \"2_1mi.i\")\n+\n+(final_presence_set \"2_0mm.i\" \"2_0m.mi\")\n+(final_presence_set \"2_0mmi.\" \"2_0mm.i\")\n+(final_presence_set \"2_1mm.i\" \"2_1m.mi\")\n+(final_presence_set \"2_1mmi.\" \"2_1mm.i\")\n+\n+(final_presence_set \"2_0mf.i\" \"2_0m.fi\")\n+(final_presence_set \"2_0mfi.\" \"2_0mf.i\")\n+(final_presence_set \"2_1mf.i\" \"2_1m.fi\")\n+(final_presence_set \"2_1mfi.\" \"2_1mf.i\")\n+\n+(final_presence_set \"2_0mm.f\" \"2_0m.mf\")\n+(final_presence_set \"2_0mmf.\" \"2_0mm.f\")\n+(final_presence_set \"2_1mm.f\" \"2_1m.mf\")\n+(final_presence_set \"2_1mmf.\" \"2_1mm.f\")\n+\n+(final_presence_set \"2_0bb.b\" \"2_0b.bb\")\n+(final_presence_set \"2_0bbb.\" \"2_0bb.b\")\n+(final_presence_set \"2_1bb.b\" \"2_1b.bb\")\n+(final_presence_set \"2_1bbb.\" \"2_1bb.b\")\n+\n+(final_presence_set \"2_0mb.b\" \"2_0m.bb\")\n+(final_presence_set \"2_0mbb.\" \"2_0mb.b\")\n+(final_presence_set \"2_1mb.b\" \"2_1m.bb\")\n+(final_presence_set \"2_1mbb.\" \"2_1mb.b\")\n+\n+(final_presence_set \"2_0mi.b\" \"2_0m.ib\")\n+(final_presence_set \"2_0mib.\" \"2_0mi.b\")\n+(final_presence_set \"2_1mi.b\" \"2_1m.ib\")\n+(final_presence_set \"2_1mib.\" \"2_1mi.b\")\n+\n+(final_presence_set \"2_0mm.b\" \"2_0m.mb\")\n+(final_presence_set \"2_0mmb.\" \"2_0mm.b\")\n+(final_presence_set \"2_1mm.b\" \"2_1m.mb\")\n+(final_presence_set \"2_1mmb.\" \"2_1mm.b\")\n+\n+(final_presence_set \"2_0mf.b\" \"2_0m.fb\")\n+(final_presence_set \"2_0mfb.\" \"2_0mf.b\")\n+(final_presence_set \"2_1mf.b\" \"2_1m.fb\")\n+(final_presence_set \"2_1mfb.\" \"2_1mf.b\")\n+\n+(final_presence_set \"2_0mlx.\" \"2_0m.lx\")\n+(final_presence_set \"2_1mlx.\" \"2_1m.lx\")\n+\n+;;   The following reflects the dual issue bundle types table.\n+;;   We could place all possible combinations here because impossible\n+;; combinations would go away by the subsequent constrains.\n+(final_presence_set\n+   \"2_1m.lx\"\n+   \"2_0mmi.,2_0mfi.,2_0mmf.,2_0mib.,2_0mmb.,2_0mfb.,2_0mlx.\")\n+(final_presence_set \"2_1b.bb\" \"2_0mii.,2_0mmi.,2_0mfi.,2_0mmf.,2_0mlx.\")\n+(final_presence_set\n+   \"2_1m.ii,2_1m.mi,2_1m.fi,2_1m.mf,2_1m.bb,2_1m.ib,2_1m.mb,2_1m.fb\"\n+   \"2_0mii.,2_0mmi.,2_0mfi.,2_0mmf.,2_0mib.,2_0mmb.,2_0mfb.,2_0mlx.\")\n+\n+;;  Ports/units (nb means nop.b insn issued into given port):\n+(define_cpu_unit\n+   \"2_um0, 2_um1, 2_um2, 2_um3, 2_ui0, 2_ui1, 2_uf0, 2_uf1,\\\n+    2_ub0, 2_ub1, 2_ub2, 2_unb0, 2_unb1, 2_unb2\" \"two\")\n+\n+(exclusion_set \"2_ub0\" \"2_unb0\")\n+(exclusion_set \"2_ub1\" \"2_unb1\")\n+(exclusion_set \"2_ub2\" \"2_unb2\")\n+\n+;; The following rules are used to decrease number of alternatives.\n+;; They are consequences of Itanium2 microarchitecture.  They also\n+;; describe the following rules mentioned in Itanium2\n+;; microarchitecture: rules mentioned in Itanium2 microarchitecture:\n+;; o \"BBB/MBB: Always splits issue after either of these bundles\".\n+;; o \"MIB BBB: Split issue after the first bundle in this pair\".\n+(exclusion_set\n+   \"2_0b.bb,2_0bb.b,2_0bbb.,2_0m.bb,2_0mb.b,2_0mbb.\"\n+   \"2_1m.ii,2_1m.mi,2_1m.fi,2_1m.mf,2_1b.bb,2_1m.bb,\\\n+    2_1m.ib,2_1m.mb,2_1m.fb,2_1m.lx\")\n+(exclusion_set \"2_0m.ib,2_0mi.b,2_0mib.\" \"2_1b.bb\")\n+\n+;;; \"MIB/MFB/MMB: Splits issue after any of these bundles unless the\n+;;; B-slot contains a nop.b or a brp instruction\".\n+;;;   \"The B in an MIB/MFB/MMB bundle disperses to B0 if it is a brp or\n+;;; nop.b, otherwise it disperses to B2\".\n+(final_absence_set\n+   \"2_1m.ii, 2_1m.mi, 2_1m.fi, 2_1m.mf, 2_1b.bb, 2_1m.bb,\\\n+    2_1m.ib, 2_1m.mb, 2_1m.fb, 2_1m.lx\"\n+   \"2_0mib. 2_ub2, 2_0mfb. 2_ub2, 2_0mmb. 2_ub2\")\n+\n+;; This is necessary to start new processor cycle when we meet stop bit.\n+(define_cpu_unit \"2_stop\" \"two\")\n+(final_absence_set\n+   \"2_0m.ii,2_0mi.i,2_0mii.,2_0m.mi,2_0mm.i,2_0mmi.,2_0m.fi,2_0mf.i,2_0mfi.,\\\n+    2_0m.mf,2_0mm.f,2_0mmf.,2_0b.bb,2_0bb.b,2_0bbb.,2_0m.bb,2_0mb.b,2_0mbb.,\\\n+    2_0m.ib,2_0mi.b,2_0mib.,2_0m.mb,2_0mm.b,2_0mmb.,2_0m.fb,2_0mf.b,2_0mfb.,\\\n+    2_0m.lx,2_0mlx., \\\n+    2_1m.ii,2_1mi.i,2_1mii.,2_1m.mi,2_1mm.i,2_1mmi.,2_1m.fi,2_1mf.i,2_1mfi.,\\\n+    2_1m.mf,2_1mm.f,2_1mmf.,2_1b.bb,2_1bb.b,2_1bbb.,2_1m.bb,2_1mb.b,2_1mbb.,\\\n+    2_1m.ib,2_1mi.b,2_1mib.,2_1m.mb,2_1mm.b,2_1mmb.,2_1m.fb,2_1mf.b,2_1mfb.,\\\n+    2_1m.lx,2_1mlx.\"\n+   \"2_stop\")\n+\n+;;   The issue logic can reorder M slot insns between different subtypes\n+;; but can not reorder insn within the same subtypes.  The following\n+;; constraint is enough to describe this.\n+(final_presence_set \"2_um1\" \"2_um0\")\n+(final_presence_set \"2_um3\" \"2_um2\")\n+\n+;;   The insn in the 1st I slot of the two bundle issue group will issue\n+;; to I0.  The second I slot insn will issue to I1.\n+(final_presence_set \"2_ui1\" \"2_ui0\")\n+\n+;;  For exceptions of I insns:\n+(define_cpu_unit \"2_only_ui0\" \"two\")\n+(final_absence_set \"2_only_ui0\"  \"2_ui1\")\n+\n+;; Insns\n+\n+(define_reservation \"2_M0\"\n+  \"(2_0m.ii|2_0m.mi|2_0m.fi|2_0m.mf|2_0m.bb|2_0m.ib|2_0m.mb|2_0m.fb|2_0m.lx\\\n+    |2_1m.ii|2_1m.mi|2_1m.fi|2_1m.mf|2_1m.bb|2_1m.ib|2_1m.mb|2_1m.fb|2_1m.lx\\\n+    |2_0mm.i|2_0mm.f|2_0mm.b|2_1mm.i|2_1mm.f|2_1mm.b)\\\n+   +(2_um0|2_um1|2_um2|2_um3)\")\n+\n+(define_reservation \"2_M1\"\n+  \"(2_0mii.+(2_ui0|2_ui1)|2_0mmi.+2_ui0|2_0mfi.+2_ui0|2_0mmf.+2_uf0\\\n+    |2_0mib.+2_unb0|2_0mfb.+2_unb0|2_0mmb.+2_unb0)\\\n+   +(2_1m.ii|2_1m.mi|2_1m.fi|2_1m.mf|2_1m.bb|2_1m.ib|2_1m.mb|2_1m.fb|2_1m.lx)\\\n+   +(2_um0|2_um1|2_um2|2_um3)\")\n+\n+(define_reservation \"2_M\" \"2_M0|2_M1\")\n+\n+(define_reservation \"2_M0_only_um0\"\n+  \"(2_0m.ii|2_0m.mi|2_0m.fi|2_0m.mf|2_0m.bb|2_0m.ib|2_0m.mb|2_0m.fb|2_0m.lx\\\n+    |2_1m.ii|2_1m.mi|2_1m.fi|2_1m.mf|2_1m.bb|2_1m.ib|2_1m.mb|2_1m.fb|2_1m.lx\\\n+    |2_0mm.i|2_0mm.f|2_0mm.b|2_1mm.i|2_1mm.f|2_1mm.b)\\\n+   +2_um0\")\n+\n+(define_reservation \"2_M1_only_um0\"\n+  \"(2_0mii.+(2_ui0|2_ui1)|2_0mmi.+2_ui0|2_0mfi.+2_ui0|2_0mmf.+2_uf0\\\n+    |2_0mib.+2_unb0|2_0mfb.+2_unb0|2_0mmb.+2_unb0)\\\n+   +(2_1m.ii|2_1m.mi|2_1m.fi|2_1m.mf|2_1m.bb|2_1m.ib|2_1m.mb|2_1m.fb|2_1m.lx)\\\n+   +2_um0\")\n+\n+(define_reservation \"2_M_only_um0\" \"2_M0_only_um0|2_M1_only_um0\")\n+\n+(define_reservation \"2_M0_only_um2\"\n+  \"(2_0m.ii|2_0m.mi|2_0m.fi|2_0m.mf|2_0m.bb|2_0m.ib|2_0m.mb|2_0m.fb|2_0m.lx\\\n+    |2_1m.ii|2_1m.mi|2_1m.fi|2_1m.mf|2_1m.bb|2_1m.ib|2_1m.mb|2_1m.fb|2_1m.lx\\\n+    |2_0mm.i|2_0mm.f|2_0mm.b|2_1mm.i|2_1mm.f|2_1mm.b)\\\n+   +2_um2\")\n+\n+(define_reservation \"2_M1_only_um2\"\n+  \"(2_0mii.+(2_ui0|2_ui1)|2_0mmi.+2_ui0|2_0mfi.+2_ui0|2_0mmf.+2_uf0\\\n+    |2_0mib.+2_unb0|2_0mfb.+2_unb0|2_0mmb.+2_unb0)\\\n+   +(2_1m.ii|2_1m.mi|2_1m.fi|2_1m.mf|2_1m.bb|2_1m.ib|2_1m.mb|2_1m.fb|2_1m.lx)\\\n+   +2_um2\")\n+\n+(define_reservation \"2_M_only_um2\" \"2_M0_only_um2|2_M1_only_um2\")\n+\n+(define_reservation \"2_M0_only_um23\"\n+  \"(2_0m.ii|2_0m.mi|2_0m.fi|2_0m.mf|2_0m.bb|2_0m.ib|2_0m.mb|2_0m.fb|2_0m.lx\\\n+    |2_1m.ii|2_1m.mi|2_1m.fi|2_1m.mf|2_1m.bb|2_1m.ib|2_1m.mb|2_1m.fb|2_1m.lx\\\n+    |2_0mm.i|2_0mm.f|2_0mm.b|2_1mm.i|2_1mm.f|2_1mm.b)\\\n+   +(2_um2|2_um3)\")\n+\n+(define_reservation \"2_M1_only_um23\"\n+  \"(2_0mii.+(2_ui0|2_ui1)|2_0mmi.+2_ui0|2_0mfi.+2_ui0|2_0mmf.+2_uf0\\\n+    |2_0mib.+2_unb0|2_0mfb.+2_unb0|2_0mmb.+2_unb0)\\\n+   +(2_1m.ii|2_1m.mi|2_1m.fi|2_1m.mf|2_1m.bb|2_1m.ib|2_1m.mb|2_1m.fb|2_1m.lx)\\\n+   +(2_um2|2_um3)\")\n+\n+(define_reservation \"2_M_only_um23\" \"2_M0_only_um23|2_M1_only_um23\")\n+\n+(define_reservation \"2_M0_only_um01\"\n+  \"(2_0m.ii|2_0m.mi|2_0m.fi|2_0m.mf|2_0m.bb|2_0m.ib|2_0m.mb|2_0m.fb|2_0m.lx\\\n+    |2_1m.ii|2_1m.mi|2_1m.fi|2_1m.mf|2_1m.bb|2_1m.ib|2_1m.mb|2_1m.fb|2_1m.lx\\\n+    |2_0mm.i|2_0mm.f|2_0mm.b|2_1mm.i|2_1mm.f|2_1mm.b)\\\n+   +(2_um0|2_um1)\")\n+\n+(define_reservation \"2_M1_only_um01\"\n+  \"(2_0mii.+(2_ui0|2_ui1)|2_0mmi.+2_ui0|2_0mfi.+2_ui0|2_0mmf.+2_uf0\\\n+    |2_0mib.+2_unb0|2_0mfb.+2_unb0|2_0mmb.+2_unb0)\\\n+   +(2_1m.ii|2_1m.mi|2_1m.fi|2_1m.mf|2_1m.bb|2_1m.ib|2_1m.mb|2_1m.fb|2_1m.lx)\\\n+   +(2_um0|2_um1)\")\n+\n+(define_reservation \"2_M_only_um01\" \"2_M0_only_um01|2_M1_only_um01\")\n+\n+;; I instruction is dispersed to the lowest numbered I unit\n+;; not already in use.  Remeber about possible spliting.\n+(define_reservation \"2_I0\"\n+  \"2_0mi.i+2_ui0|2_0mii.+(2_ui0|2_ui1)|2_0mmi.+2_ui0\\\n+   |2_0mfi.+2_ui0|2_0mi.b+2_ui0|(2_1mi.i|2_1mi.b)+(2_ui0|2_ui1)\\\n+   |(2_1mii.|2_1mmi.|2_1mfi.)+(2_ui0|2_ui1)\")\n+\n+(define_reservation \"2_I1\"\n+  \"2_0m.ii+(2_um0|2_um1|2_um2|2_um3)+2_0mi.i+2_ui0\\\n+   |2_0mm.i+(2_um0|2_um1|2_um2|2_um3)+2_0mmi.+2_ui0\\\n+   |2_0mf.i+2_uf0+2_0mfi.+2_ui0\\\n+   |2_0m.ib+(2_um0|2_um1|2_um2|2_um3)+2_0mi.b+2_ui0\\\n+   |(2_1m.ii+2_1mi.i|2_1m.ib+2_1mi.b)+(2_um0|2_um1|2_um2|2_um3)+(2_ui0|2_ui1)\\\n+   |2_1mm.i+(2_um0|2_um1|2_um2|2_um3)+2_1mmi.+(2_ui0|2_ui1)\\\n+   |2_1mf.i+2_uf1+2_1mfi.+(2_ui0|2_ui1)\")\n+\n+(define_reservation \"2_I\" \"2_I0|2_I1\")\n+\n+;; \"An F slot in the 1st bundle disperses to F0\".\n+;; \"An F slot in the 2st bundle disperses to F1\".\n+(define_reservation \"2_F0\"\n+   \"2_0mf.i+2_uf0|2_0mmf.+2_uf0|2_0mf.b+2_uf0\\\n+    |2_1mf.i+2_uf1|2_1mmf.+2_uf1|2_1mf.b+2_uf1\")\n+\n+(define_reservation \"2_F1\"\n+   \"(2_0m.fi+2_0mf.i|2_0mm.f+2_0mmf.|2_0m.fb+2_0mf.b)\\\n+    +(2_um0|2_um1|2_um2|2_um3)+2_uf0\\\n+    |(2_1m.fi+2_1mf.i|2_1mm.f+2_1mmf.|2_1m.fb+2_1mf.b)\\\n+     +(2_um0|2_um1|2_um2|2_um3)+2_uf1\")\n+\n+(define_reservation \"2_F2\"\n+   \"(2_0m.mf+2_0mm.f+2_0mmf.+2_uf0|2_1m.mf+2_1mm.f+2_1mmf.+2_uf1)\\\n+    +(2_um0|2_um1|2_um2|2_um3)+(2_um0|2_um1|2_um2|2_um3)\\\n+    |(2_0mii.+(2_ui0|2_ui1)|2_0mmi.+2_ui0|2_0mfi.+2_ui0\\\n+      |2_0mmf.+(2_um0|2_um1|2_um2|2_um3)\\\n+      |2_0mib.+2_unb0|2_0mmb.+2_unb0|2_0mfb.+2_unb0)\\\n+     +(2_1m.fi+2_1mf.i|2_1m.fb+2_1mf.b)+(2_um0|2_um1|2_um2|2_um3)+2_uf1\")\n+\n+(define_reservation \"2_F\" \"2_F0|2_F1|2_F2\")\n+\n+;;; \"Each B slot in MBB or BBB bundle disperses to the corresponding B\n+;;; unit. That is, a B slot in 1st position is despersed to B0.  In the\n+;;; 2nd position it is dispersed to B2\".\n+(define_reservation \"2_NB\"\n+    \"2_0b.bb+2_unb0|2_0bb.b+2_unb1|2_0bbb.+2_unb2\\\n+     |2_0mb.b+2_unb1|2_0mbb.+2_unb2|2_0mib.+2_unb0\\\n+     |2_0mmb.+2_unb0|2_0mfb.+2_unb0\\\n+     |2_1b.bb+2_unb0|2_1bb.b+2_unb1\n+     |2_1bbb.+2_unb2|2_1mb.b+2_unb1|2_1mbb.+2_unb2\\\n+     |2_1mib.+2_unb0|2_1mmb.+2_unb0|2_1mfb.+2_unb0\")\n+\n+(define_reservation \"2_B0\"\n+   \"2_0b.bb+2_ub0|2_0bb.b+2_ub1|2_0bbb.+2_ub2\\\n+    |2_0mb.b+2_ub1|2_0mbb.+2_ub2|2_0mib.+2_ub2\\\n+    |2_0mfb.+2_ub2|2_1b.bb+2_ub0|2_1bb.b+2_ub1\\\n+    |2_1bbb.+2_ub2|2_1mb.b+2_ub1\\\n+    |2_1mib.+2_ub2|2_1mmb.+2_ub2|2_1mfb.+2_ub2\")\n+\n+(define_reservation \"2_B1\"\n+   \"2_0m.bb+(2_um0|2_um1|2_um2|2_um3)+2_0mb.b+2_ub1\\\n+    |2_0mi.b+2_ui0+2_0mib.+2_ub2\\\n+    |2_0mm.b+(2_um0|2_um1|2_um2|2_um3)+2_0mmb.+2_ub2\\\n+    |2_0mf.b+2_uf0+2_0mfb.+2_ub2\\\n+    |(2_0mii.+(2_ui0|2_ui1)|2_0mmi.+2_ui0|2_0mfi.+2_ui0|2_0mmf.+2_uf0)\\\n+     +2_1b.bb+2_ub0\\\n+    |2_1m.bb+(2_um0|2_um1|2_um2|2_um3)+2_1mb.b+2_ub1\\\n+    |2_1mi.b+(2_ui0|2_ui1)+2_1mib.+2_ub2\\\n+    |2_1mm.b+(2_um0|2_um1|2_um2|2_um3)+2_1mmb.+2_ub2\\\n+    |2_1mf.b+2_uf1+2_1mfb.+2_ub2\")\n+\n+(define_reservation \"2_B\" \"2_B0|2_B1\")\n+\n+;; MLX bunlde uses ports equivalent to MFI bundles.\n+\n+;;   For the MLI template, the I slot insn is always assigned to port I0\n+;; if it is in the first bundle or it is assigned to port I1 if it is in\n+;; the second bundle.\n+(define_reservation \"2_L0\" \"2_0mlx.+2_ui0+2_uf0|2_1mlx.+2_ui1+2_uf1\")\n+\n+(define_reservation \"2_L1\"\n+   \"2_0m.lx+(2_um0|2_um1|2_um2|2_um3)+2_0mlx.+2_ui0+2_uf0\\\n+   |2_1m.lx+(2_um0|2_um1|2_um2|2_um3)+2_1mlx.+2_ui1+2_uf1\")\n+\n+(define_reservation \"2_L2\"\n+   \"(2_0mii.+(2_ui0|2_ui1)|2_0mmi.+2_ui0|2_0mfi.+2_ui0|2_0mmf.+2_uf0\\\n+     |2_0mib.+2_unb0|2_0mmb.+2_unb0|2_0mfb.+2_unb0)\n+    +2_1m.lx+(2_um0|2_um1|2_um2|2_um3)+2_1mlx.+2_ui1+2_uf1\")\n+\n+(define_reservation \"2_L\" \"2_L0|2_L1|2_L2\")\n+\n+;;   Should we describe that A insn in I slot can be issued into M\n+;; ports?  I think it is not necessary because of multipass\n+;; scheduling.  For example, the multipass scheduling could use\n+;; MMI-MMI instead of MII-MII where the two last I slots contain A\n+;; insns (even if the case is complicated by use-def conflicts).\n+;;\n+;; In any case we could describe it as\n+;;    (define_cpu_unit \"2_ui1_0pres,2_ui1_1pres,2_ui1_2pres,2_ui1_3pres\" \"two\")\n+;;    (final_presence_set \"2_ui1_0pres,2_ui1_1pres,2_ui1_2pres,2_ui1_3pres\"\n+;;                        \"2_ui1\")\n+;;    (define_reservation \"b_A\"\n+;;       \"b_M|b_I\\\n+;;        |(2_1mi.i|2_1mii.|2_1mmi.|2_1mfi.|2_1mi.b)+(2_um0|2_um1|2_um2|2_um3)\\\n+;;         +(2_ui1_0pres|2_ui1_1pres|2_ui1_2pres|2_ui1_3pres)\")\n+\n+(define_reservation \"2_A\" \"2_M|2_I\")\n+\n+;; We assume that there is no insn issued on the same cycle as the\n+;; unknown insn.\n+(define_cpu_unit \"2_empty\" \"two\")\n+(exclusion_set \"2_empty\"\n+    \"2_0m.ii,2_0m.mi,2_0m.fi,2_0m.mf,2_0b.bb,2_0m.bb,2_0m.ib,2_0m.mb,2_0m.fb,\\\n+     2_0m.lx\")\n+\n+(define_cpu_unit\n+   \"2_0m_bs, 2_0mi_bs, 2_0mm_bs, 2_0mf_bs, 2_0b_bs, 2_0bb_bs, 2_0mb_bs\"\n+   \"two\")\n+(define_cpu_unit\n+   \"2_1m_bs, 2_1mi_bs, 2_1mm_bs, 2_1mf_bs, 2_1b_bs, 2_1bb_bs, 2_1mb_bs\"\n+   \"two\")\n+\n+(define_cpu_unit \"2_m_cont, 2_mi_cont, 2_mm_cont, 2_mf_cont, 2_mb_cont,\\\n+\t          2_b_cont, 2_bb_cont\" \"two\")\n+\n+;; For stop in the middle of the bundles.\n+(define_cpu_unit \"2_m_stop, 2_m0_stop, 2_m1_stop, 2_0mmi_cont\" \"two\")\n+(define_cpu_unit \"2_mi_stop, 2_mi0_stop, 2_mi1_stop, 2_0mii_cont\" \"two\")\n+\n+(final_presence_set \"2_0m_bs\"\n+   \"2_0m.ii, 2_0m.mi, 2_0m.mf, 2_0m.fi, 2_0m.bb,\\\n+    2_0m.ib, 2_0m.fb, 2_0m.mb, 2_0m.lx\")\n+(final_presence_set \"2_1m_bs\"\n+   \"2_1m.ii, 2_1m.mi, 2_1m.mf, 2_1m.fi, 2_1m.bb,\\\n+    2_1m.ib, 2_1m.fb, 2_1m.mb, 2_1m.lx\")\n+(final_presence_set \"2_0mi_bs\"  \"2_0mi.i, 2_0mi.i\")\n+(final_presence_set \"2_1mi_bs\"  \"2_1mi.i, 2_1mi.i\")\n+(final_presence_set \"2_0mm_bs\"  \"2_0mm.i, 2_0mm.f, 2_0mm.b\")\n+(final_presence_set \"2_1mm_bs\"  \"2_1mm.i, 2_1mm.f, 2_1mm.b\")\n+(final_presence_set \"2_0mf_bs\"  \"2_0mf.i, 2_0mf.b\")\n+(final_presence_set \"2_1mf_bs\"  \"2_1mf.i, 2_1mf.b\")\n+(final_presence_set \"2_0b_bs\"  \"2_0b.bb\")\n+(final_presence_set \"2_1b_bs\"  \"2_1b.bb\")\n+(final_presence_set \"2_0bb_bs\"  \"2_0bb.b\")\n+(final_presence_set \"2_1bb_bs\"  \"2_1bb.b\")\n+(final_presence_set \"2_0mb_bs\"  \"2_0mb.b\")\n+(final_presence_set \"2_1mb_bs\"  \"2_1mb.b\")\n+\n+(exclusion_set \"2_0m_bs\"\n+   \"2_0mi.i, 2_0mm.i, 2_0mm.f, 2_0mf.i, 2_0mb.b,\\\n+    2_0mi.b, 2_0mf.b, 2_0mm.b, 2_0mlx., 2_m0_stop\")\n+(exclusion_set \"2_1m_bs\"\n+   \"2_1mi.i, 2_1mm.i, 2_1mm.f, 2_1mf.i, 2_1mb.b,\\\n+    2_1mi.b, 2_1mf.b, 2_1mm.b, 2_1mlx., 2_m1_stop\")\n+(exclusion_set \"2_0mi_bs\"  \"2_0mii., 2_0mib., 2_mi0_stop\")\n+(exclusion_set \"2_1mi_bs\"  \"2_1mii., 2_1mib., 2_mi1_stop\")\n+(exclusion_set \"2_0mm_bs\"  \"2_0mmi., 2_0mmf., 2_0mmb.\")\n+(exclusion_set \"2_1mm_bs\"  \"2_1mmi., 2_1mmf., 2_1mmb.\")\n+(exclusion_set \"2_0mf_bs\"  \"2_0mfi., 2_0mfb.\")\n+(exclusion_set \"2_1mf_bs\"  \"2_1mfi., 2_1mfb.\")\n+(exclusion_set \"2_0b_bs\"  \"2_0bb.b\")\n+(exclusion_set \"2_1b_bs\"  \"2_1bb.b\")\n+(exclusion_set \"2_0bb_bs\"  \"2_0bbb.\")\n+(exclusion_set \"2_1bb_bs\"  \"2_1bbb.\")\n+(exclusion_set \"2_0mb_bs\"  \"2_0mbb.\")\n+(exclusion_set \"2_1mb_bs\"  \"2_1mbb.\")\n+\n+(exclusion_set\n+   \"2_0m_bs, 2_0mi_bs, 2_0mm_bs, 2_0mf_bs, 2_0b_bs, 2_0bb_bs, 2_0mb_bs,\n+    2_1m_bs, 2_1mi_bs, 2_1mm_bs, 2_1mf_bs, 2_1b_bs, 2_1bb_bs, 2_1mb_bs\"\n+   \"2_stop\")\n+\n+(final_presence_set\n+   \"2_0mi.i, 2_0mm.i, 2_0mf.i, 2_0mm.f, 2_0mb.b,\\\n+    2_0mi.b, 2_0mm.b, 2_0mf.b, 2_0mlx.\"\n+   \"2_m_cont\")\n+(final_presence_set \"2_0mii., 2_0mib.\" \"2_mi_cont\")\n+(final_presence_set \"2_0mmi., 2_0mmf., 2_0mmb.\" \"2_mm_cont\")\n+(final_presence_set \"2_0mfi., 2_0mfb.\" \"2_mf_cont\")\n+(final_presence_set \"2_0bb.b\" \"2_b_cont\")\n+(final_presence_set \"2_0bbb.\" \"2_bb_cont\")\n+(final_presence_set \"2_0mbb.\" \"2_mb_cont\")\n+\n+(exclusion_set\n+   \"2_0m.ii, 2_0m.mi, 2_0m.fi, 2_0m.mf, 2_0b.bb, 2_0m.bb,\\\n+    2_0m.ib, 2_0m.mb, 2_0m.fb, 2_0m.lx\"\n+   \"2_m_cont, 2_mi_cont, 2_mm_cont, 2_mf_cont,\\\n+    2_mb_cont, 2_b_cont, 2_bb_cont\")\n+\n+(exclusion_set \"2_empty\"\n+               \"2_m_cont,2_mi_cont,2_mm_cont,2_mf_cont,\\\n+                2_mb_cont,2_b_cont,2_bb_cont\")\n+\n+;; For m;mi bundle\n+(final_presence_set \"2_m0_stop\" \"2_0m.mi\")\n+(final_presence_set \"2_0mm.i\" \"2_0mmi_cont\")\n+(exclusion_set \"2_0mmi_cont\"\n+   \"2_0m.ii, 2_0m.mi, 2_0m.fi, 2_0m.mf, 2_0b.bb, 2_0m.bb,\\\n+    2_0m.ib, 2_0m.mb, 2_0m.fb, 2_0m.lx\")\n+(exclusion_set \"2_m0_stop\" \"2_0mm.i\")\n+(final_presence_set \"2_m1_stop\" \"2_1m.mi\")\n+(exclusion_set \"2_m1_stop\" \"2_1mm.i\")\n+(final_presence_set \"2_m_stop\" \"2_m0_stop, 2_m1_stop\")\n+\n+;; For mi;i bundle\n+(final_presence_set \"2_mi0_stop\" \"2_0mi.i\")\n+(final_presence_set \"2_0mii.\" \"2_0mii_cont\")\n+(exclusion_set \"2_0mii_cont\"\n+   \"2_0m.ii, 2_0m.mi, 2_0m.fi, 2_0m.mf, 2_0b.bb, 2_0m.bb,\\\n+    2_0m.ib, 2_0m.mb, 2_0m.fb, 2_0m.lx\")\n+(exclusion_set \"2_mi0_stop\" \"2_0mii.\")\n+(final_presence_set \"2_mi1_stop\" \"2_1mi.i\")\n+(exclusion_set \"2_mi1_stop\" \"2_1mii.\")\n+(final_presence_set \"2_mi_stop\" \"2_mi0_stop, 2_mi1_stop\")\n+\n+(final_absence_set\n+   \"2_0m.ii,2_0mi.i,2_0mii.,2_0m.mi,2_0mm.i,2_0mmi.,2_0m.fi,2_0mf.i,2_0mfi.,\\\n+    2_0m.mf,2_0mm.f,2_0mmf.,2_0b.bb,2_0bb.b,2_0bbb.,2_0m.bb,2_0mb.b,2_0mbb.,\\\n+    2_0m.ib,2_0mi.b,2_0mib.,2_0m.mb,2_0mm.b,2_0mmb.,2_0m.fb,2_0mf.b,2_0mfb.,\\\n+    2_0m.lx,2_0mlx., \\\n+    2_1m.ii,2_1mi.i,2_1mii.,2_1m.mi,2_1mm.i,2_1mmi.,2_1m.fi,2_1mf.i,2_1mfi.,\\\n+    2_1m.mf,2_1mm.f,2_1mmf.,2_1b.bb,2_1bb.b,2_1bbb.,2_1m.bb,2_1mb.b,2_1mbb.,\\\n+    2_1m.ib,2_1mi.b,2_1mib.,2_1m.mb,2_1mm.b,2_1mmb.,2_1m.fb,2_1mf.b,2_1mfb.,\\\n+    2_1m.lx,2_1mlx.\"\n+   \"2_m0_stop,2_m1_stop,2_mi0_stop,2_mi1_stop\")\n+\n+(define_insn_reservation \"2_stop_bit\" 0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"stop_bit\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2_stop|2_m0_stop|2_m1_stop|2_mi0_stop|2_mi1_stop\")\n+\n+(define_insn_reservation \"2_br\"      0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"br\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"2_B\")\n+(define_insn_reservation \"2_scall\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"scall\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"2_B\")\n+(define_insn_reservation \"2_fcmp\"    2\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"fcmp\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"2_F\")\n+(define_insn_reservation \"2_fcvtfx\"  4\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"fcvtfx\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"2_F\")\n+(define_insn_reservation \"2_fld\"     6\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"fld\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"2_M\")\n+(define_insn_reservation \"2_fmac\"    4\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"fmac\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"2_F\")\n+(define_insn_reservation \"2_fmisc\"   4\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"fmisc\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"2_F\")\n+\n+;; There is only one insn `mov = ar.bsp' for frar_i:\n+;; Latency time ???\n+(define_insn_reservation \"2_frar_i\" 13\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"frar_i\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2_I+2_only_ui0\")\n+;; There is only two insns `mov = ar.unat' or `mov = ar.ccv' for frar_m:\n+;; Latency time ???\n+(define_insn_reservation \"2_frar_m\"  6\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"frar_m\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2_M_only_um2\")\n+(define_insn_reservation \"2_frbr\"    2\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"frbr\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2_I+2_only_ui0\")\n+(define_insn_reservation \"2_frfr\"    5\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"frfr\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2_M_only_um2\")\n+(define_insn_reservation \"2_frpr\"    2\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"frpr\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2_I+2_only_ui0\")\n+\n+(define_insn_reservation \"2_ialu\"      1\n+    (and (and (eq_attr \"cpu\" \"itanium2\")\n+              (eq_attr \"itanium_class\" \"ialu\"))\n+         (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+    \"2_A\")\n+(define_insn_reservation \"2_icmp\"    1\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"icmp\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"2_A\")\n+(define_insn_reservation \"2_ilog\"    1\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"ilog\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"2_A\")\n+;; Latency time ???\n+(define_insn_reservation \"2_ishf\"    1\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"ishf\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2_I+2_only_ui0\")\n+(define_insn_reservation \"2_ld\"      1\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"ld\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2_M_only_um01\")\n+(define_insn_reservation \"2_long_i\"  1\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"long_i\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"2_L\")\n+\n+(define_insn_reservation \"2_mmmul\"   2\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"mmmul\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2_I+2_only_ui0\")\n+;; Latency time ???\n+(define_insn_reservation \"2_mmshf\"   2\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"mmshf\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"2_I\")\n+;; Latency time ???\n+(define_insn_reservation \"2_mmshfi\"  1\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"mmshfi\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"2_I\")\n+\n+;; Now we have only one insn (flushrs) of such class.  We assume that flushrs\n+;; is the 1st syllable of the bundle after stop bit.\n+(define_insn_reservation \"2_rse_m\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"rse_m\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"(2_0m.ii|2_0m.mi|2_0m.fi|2_0m.mf|2_0m.bb\\\n+    |2_0m.ib|2_0m.mb|2_0m.fb|2_0m.lx)+2_um0\")\n+(define_insn_reservation \"2_sem\"     0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"sem\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2_M_only_um23\")\n+\n+(define_insn_reservation \"2_stf\"     1\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"stf\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2_M_only_um23\")\n+(define_insn_reservation \"2_st\"      1\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"st\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2_M_only_um23\")\n+(define_insn_reservation \"2_syst_m0\" 0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"syst_m0\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2_M_only_um2\")\n+(define_insn_reservation \"2_syst_m\"  0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"syst_m\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2_M_only_um0\")\n+;; Reservation???\n+(define_insn_reservation \"2_tbit\"    1\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"tbit\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2_I+2_only_ui0\")\n+\n+;; There is only ony insn `mov ar.pfs =' for toar_i:\n+(define_insn_reservation \"2_toar_i\"  0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"toar_i\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2_I+2_only_ui0\")\n+;; There are only ony 2 insns `mov ar.ccv =' and `mov ar.unat =' for toar_m:\n+;; Latency time ???\n+(define_insn_reservation \"2_toar_m\"  5\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"toar_m\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2_M_only_um2\")\n+;; Latency time ???\n+(define_insn_reservation \"2_tobr\"    1\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"tobr\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2_I+2_only_ui0\")\n+(define_insn_reservation \"2_tofr\"    5\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"tofr\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2_M_only_um23\")\n+;; Latency time ???\n+(define_insn_reservation \"2_topr\"    1\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"topr\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2_I+2_only_ui0\")\n+\n+(define_insn_reservation \"2_xmpy\"    4\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"xmpy\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"2_F\")\n+;; Latency time ???\n+(define_insn_reservation \"2_xtd\"     1\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"xtd\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"2_I\")\n+\n+(define_insn_reservation \"2_chk_s\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"chk_s\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2_I|2_M_only_um23\")\n+(define_insn_reservation \"2_lfetch\"  0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"lfetch\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2_M_only_um01\")\n+\n+(define_insn_reservation \"2_nop_m\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"nop_m\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"2_M0\")\n+(define_insn_reservation \"2_nop_b\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"nop_b\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"2_NB\")\n+(define_insn_reservation \"2_nop_i\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"nop_i\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"2_I0\")\n+(define_insn_reservation \"2_nop_f\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"nop_f\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"2_F0\")\n+(define_insn_reservation \"2_nop_x\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"nop_x\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"2_L0\")\n+\n+(define_insn_reservation \"2_unknown\" 1\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"unknown\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"2_empty\")\n+\n+(define_insn_reservation \"2_nop\" 0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"nop\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2_M0|2_NB|2_I0|2_F0\")\n+\n+(define_insn_reservation \"2_ignore\" 0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"ignore\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"nothing\")\n+\n+(define_cpu_unit \"2_m_cont_only, 2_b_cont_only\" \"two\")\n+(define_cpu_unit \"2_mi_cont_only, 2_mm_cont_only, 2_mf_cont_only\" \"two\")\n+(define_cpu_unit \"2_mb_cont_only, 2_bb_cont_only\" \"two\")\n+\n+(final_presence_set \"2_m_cont_only\" \"2_m_cont\")\n+(exclusion_set \"2_m_cont_only\"\n+  \"2_0mi.i, 2_0mm.i, 2_0mf.i, 2_0mm.f, 2_0mb.b,\\\n+   2_0mi.b, 2_0mm.b, 2_0mf.b, 2_0mlx.\")\n+\n+(final_presence_set \"2_b_cont_only\" \"2_b_cont\")\n+(exclusion_set \"2_b_cont_only\"  \"2_0bb.b\")\n+\n+(final_presence_set \"2_mi_cont_only\" \"2_mi_cont\")\n+(exclusion_set \"2_mi_cont_only\" \"2_0mii., 2_0mib.\")\n+\n+(final_presence_set \"2_mm_cont_only\" \"2_mm_cont\")\n+(exclusion_set \"2_mm_cont_only\" \"2_0mmi., 2_0mmf., 2_0mmb.\")\n+\n+(final_presence_set \"2_mf_cont_only\" \"2_mf_cont\")\n+(exclusion_set \"2_mf_cont_only\" \"2_0mfi., 2_0mfb.\")\n+\n+(final_presence_set \"2_mb_cont_only\" \"2_mb_cont\")\n+(exclusion_set \"2_mb_cont_only\" \"2_0mbb.\")\n+\n+(final_presence_set \"2_bb_cont_only\" \"2_bb_cont\")\n+(exclusion_set \"2_bb_cont_only\" \"2_0bbb.\")\n+\n+(define_insn_reservation \"2_pre_cycle\" 0\n+   (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"pre_cycle\"))\n+        (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+                         \"nothing\")\n+\n+;;(define_insn_reservation \"2_pre_cycle\" 0\n+;;   (and (and (eq_attr \"cpu\" \"itanium2\")\n+;;             (eq_attr \"itanium_class\" \"pre_cycle\"))\n+;;        (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+;;                         \"(2_0m_bs, 2_m_cont)                     \\\n+;;                          | (2_0mi_bs, (2_mi_cont|nothing))       \\\n+;;                          | (2_0mm_bs, 2_mm_cont)                 \\\n+;;                          | (2_0mf_bs, (2_mf_cont|nothing))       \\\n+;;                          | (2_0b_bs, (2_b_cont|nothing))         \\\n+;;                          | (2_0bb_bs, (2_bb_cont|nothing))       \\\n+;;                          | (2_0mb_bs, (2_mb_cont|nothing))       \\\n+;;                          | (2_1m_bs, 2_m_cont)                   \\\n+;;                          | (2_1mi_bs, (2_mi_cont|nothing))       \\\n+;;                          | (2_1mm_bs, 2_mm_cont)                 \\\n+;;                          | (2_1mf_bs, (2_mf_cont|nothing))       \\\n+;;                          | (2_1b_bs, (2_b_cont|nothing))         \\\n+;;                          | (2_1bb_bs, (2_bb_cont|nothing))       \\\n+;;                          | (2_1mb_bs, (2_mb_cont|nothing))       \\\n+;;                          | (2_m_cont_only, (2_m_cont|nothing))   \\\n+;;                          | (2_b_cont_only,  (2_b_cont|nothing))  \\\n+;;                          | (2_mi_cont_only, (2_mi_cont|nothing)) \\\n+;;                          | (2_mm_cont_only, (2_mm_cont|nothing)) \\\n+;;                          | (2_mf_cont_only, (2_mf_cont|nothing)) \\\n+;;                          | (2_mb_cont_only, (2_mb_cont|nothing)) \\\n+;;                          | (2_bb_cont_only, (2_bb_cont|nothing)) \\\n+;;                          | (2_m_stop, (2_0mmi_cont|nothing))     \\\n+;;                          | (2_mi_stop, (2_0mii_cont|nothing))\")\n+\n+;; Bypasses:\n+\n+(define_bypass  1 \"2_fcmp\" \"2_br,2_scall\")\n+(define_bypass  0 \"2_icmp\" \"2_br,2_scall\")\n+(define_bypass  0 \"2_tbit\" \"2_br,2_scall\")\n+(define_bypass  2 \"2_ld\" \"2_ld\"  \"ia64_ld_address_bypass_p\")\n+(define_bypass  2 \"2_ld\" \"2_st\"  \"ia64_st_address_bypass_p\")\n+(define_bypass  2 \"2_ld\" \"2_mmmul,2_mmshf\")\n+(define_bypass  3 \"2_ilog\" \"2_mmmul,2_mmshf\")\n+(define_bypass  3 \"2_ialu\" \"2_mmmul,2_mmshf\")\n+(define_bypass  3 \"2_mmmul,2_mmshf\" \"2_ialu,2_ilog,2_ishf,2_st,2_ld\")\n+(define_bypass  6 \"2_tofr\"  \"2_frfr,2_stf\")\n+(define_bypass  7 \"2_fmac\"  \"2_frfr,2_stf\")\n+\n+;; We don't use here fcmp because scall may be predicated.\n+(define_bypass  0 \"2_fcvtfx,2_fld,2_fmac,2_fmisc,2_frar_i,2_frar_m,\\\n+                   2_frbr,2_frfr,2_frpr,2_ialu,2_ilog,2_ishf,2_ld,2_long_i,\\\n+                   2_mmmul,2_mmshf,2_mmshfi,2_toar_m,2_tofr,2_xmpy,2_xtd\"\n+                  \"2_scall\")\n+\n+(define_bypass  0 \"2_unknown,2_ignore,2_stop_bit,2_br,2_fcmp,2_fcvtfx,2_fld,\\\n+                   2_fmac,2_fmisc,2_frar_i,2_frar_m,2_frbr,2_frfr,2_frpr,\\\n+                   2_ialu,2_icmp,2_ilog,2_ishf,2_ld,2_chk_s,\\\n+                   2_long_i,2_mmmul,2_mmshf,2_mmshfi,2_nop,2_nop_b,2_nop_f,\\\n+                   2_nop_i,2_nop_m,2_nop_x,2_rse_m,2_scall,2_sem,2_stf,2_st,\\\n+                   2_syst_m0,2_syst_m,2_tbit,2_toar_i,2_toar_m,2_tobr,2_tofr,\\\n+                   2_topr,2_xmpy,2_xtd,2_lfetch\" \"2_ignore\")\n+\n+\n+\f\n+;; Bundling\n+\n+(define_automaton \"twob\")\n+\n+;; Pseudo units for quicker searching for position in two packet window.  */\n+(define_query_cpu_unit \"2_1,2_2,2_3,2_4,2_5,2_6\" \"twob\")\n+\n+;;   All possible combinations of bundles/syllables\n+(define_cpu_unit\n+   \"2b_0m.ii, 2b_0m.mi, 2b_0m.fi, 2b_0m.mf, 2b_0b.bb, 2b_0m.bb,\\\n+    2b_0m.ib, 2b_0m.mb, 2b_0m.fb, 2b_0m.lx\" \"twob\")\n+(define_cpu_unit\n+   \"2b_0mi.i, 2b_0mm.i, 2b_0mf.i, 2b_0mm.f, 2b_0bb.b, 2b_0mb.b,\\\n+    2b_0mi.b, 2b_0mm.b, 2b_0mf.b\" \"twob\")\n+(define_query_cpu_unit\n+   \"2b_0mii., 2b_0mmi., 2b_0mfi., 2b_0mmf., 2b_0bbb., 2b_0mbb.,\\\n+    2b_0mib., 2b_0mmb., 2b_0mfb., 2b_0mlx.\" \"twob\")\n+\n+(define_cpu_unit\n+   \"2b_1m.ii, 2b_1m.mi, 2b_1m.fi, 2b_1m.mf, 2b_1b.bb, 2b_1m.bb,\\\n+    2b_1m.ib, 2b_1m.mb, 2b_1m.fb, 2b_1m.lx\" \"twob\")\n+(define_cpu_unit\n+   \"2b_1mi.i, 2b_1mm.i, 2b_1mf.i, 2b_1mm.f, 2b_1bb.b, 2b_1mb.b,\\\n+    2b_1mi.b, 2b_1mm.b, 2b_1mf.b\" \"twob\")\n+(define_query_cpu_unit\n+   \"2b_1mii., 2b_1mmi., 2b_1mfi., 2b_1mmf., 2b_1bbb., 2b_1mbb.,\\\n+    2b_1mib., 2b_1mmb., 2b_1mfb., 2b_1mlx.\" \"twob\")\n+\n+;; Slot 1\n+(exclusion_set \"2b_0m.ii\"\n+   \"2b_0m.mi, 2b_0m.fi, 2b_0m.mf, 2b_0b.bb, 2b_0m.bb,\\\n+    2b_0m.ib, 2b_0m.mb, 2b_0m.fb, 2b_0m.lx\")\n+(exclusion_set \"2b_0m.mi\"\n+   \"2b_0m.fi, 2b_0m.mf, 2b_0b.bb, 2b_0m.bb, 2b_0m.ib,\\\n+    2b_0m.mb, 2b_0m.fb, 2b_0m.lx\")\n+(exclusion_set \"2b_0m.fi\"\n+   \"2b_0m.mf, 2b_0b.bb, 2b_0m.bb, 2b_0m.ib, 2b_0m.mb, 2b_0m.fb, 2b_0m.lx\")\n+(exclusion_set \"2b_0m.mf\"\n+   \"2b_0b.bb, 2b_0m.bb, 2b_0m.ib, 2b_0m.mb, 2b_0m.fb, 2b_0m.lx\")\n+(exclusion_set \"2b_0b.bb\" \"2b_0m.bb, 2b_0m.ib, 2b_0m.mb, 2b_0m.fb, 2b_0m.lx\")\n+(exclusion_set \"2b_0m.bb\" \"2b_0m.ib, 2b_0m.mb, 2b_0m.fb, 2b_0m.lx\")\n+(exclusion_set \"2b_0m.ib\" \"2b_0m.mb, 2b_0m.fb, 2b_0m.lx\")\n+(exclusion_set \"2b_0m.mb\" \"2b_0m.fb, 2b_0m.lx\")\n+(exclusion_set \"2b_0m.fb\" \"2b_0m.lx\")\n+\n+;; Slot 2\n+(exclusion_set \"2b_0mi.i\"\n+   \"2b_0mm.i, 2b_0mf.i, 2b_0mm.f, 2b_0bb.b, 2b_0mb.b,\\\n+    2b_0mi.b, 2b_0mm.b, 2b_0mf.b, 2b_0mlx.\")\n+(exclusion_set \"2b_0mm.i\"\n+   \"2b_0mf.i, 2b_0mm.f, 2b_0bb.b, 2b_0mb.b,\\\n+    2b_0mi.b, 2b_0mm.b, 2b_0mf.b, 2b_0mlx.\")\n+(exclusion_set \"2b_0mf.i\"\n+   \"2b_0mm.f, 2b_0bb.b, 2b_0mb.b, 2b_0mi.b, 2b_0mm.b, 2b_0mf.b, 2b_0mlx.\")\n+(exclusion_set \"2b_0mm.f\"\n+   \"2b_0bb.b, 2b_0mb.b, 2b_0mi.b, 2b_0mm.b, 2b_0mf.b, 2b_0mlx.\")\n+(exclusion_set \"2b_0bb.b\" \"2b_0mb.b, 2b_0mi.b, 2b_0mm.b, 2b_0mf.b, 2b_0mlx.\")\n+(exclusion_set \"2b_0mb.b\" \"2b_0mi.b, 2b_0mm.b, 2b_0mf.b, 2b_0mlx.\")\n+(exclusion_set \"2b_0mi.b\" \"2b_0mm.b, 2b_0mf.b, 2b_0mlx.\")\n+(exclusion_set \"2b_0mm.b\" \"2b_0mf.b, 2b_0mlx.\")\n+(exclusion_set \"2b_0mf.b\" \"2b_0mlx.\")\n+\n+;; Slot 3\n+(exclusion_set \"2b_0mii.\"\n+   \"2b_0mmi., 2b_0mfi., 2b_0mmf., 2b_0bbb., 2b_0mbb.,\\\n+    2b_0mib., 2b_0mmb., 2b_0mfb., 2b_0mlx.\")\n+(exclusion_set \"2b_0mmi.\"\n+   \"2b_0mfi., 2b_0mmf., 2b_0bbb., 2b_0mbb.,\\\n+    2b_0mib., 2b_0mmb., 2b_0mfb., 2b_0mlx.\")\n+(exclusion_set \"2b_0mfi.\"\n+   \"2b_0mmf., 2b_0bbb., 2b_0mbb., 2b_0mib., 2b_0mmb., 2b_0mfb., 2b_0mlx.\")\n+(exclusion_set \"2b_0mmf.\"\n+   \"2b_0bbb., 2b_0mbb., 2b_0mib., 2b_0mmb., 2b_0mfb., 2b_0mlx.\")\n+(exclusion_set \"2b_0bbb.\" \"2b_0mbb., 2b_0mib., 2b_0mmb., 2b_0mfb., 2b_0mlx.\")\n+(exclusion_set \"2b_0mbb.\" \"2b_0mib., 2b_0mmb., 2b_0mfb., 2b_0mlx.\")\n+(exclusion_set \"2b_0mib.\" \"2b_0mmb., 2b_0mfb., 2b_0mlx.\")\n+(exclusion_set \"2b_0mmb.\" \"2b_0mfb., 2b_0mlx.\")\n+(exclusion_set \"2b_0mfb.\" \"2b_0mlx.\")\n+\n+;; Slot 4\n+(exclusion_set \"2b_1m.ii\"\n+   \"2b_1m.mi, 2b_1m.fi, 2b_1m.mf, 2b_1b.bb, 2b_1m.bb,\\\n+    2b_1m.ib, 2b_1m.mb, 2b_1m.fb, 2b_1m.lx\")\n+(exclusion_set \"2b_1m.mi\"\n+   \"2b_1m.fi, 2b_1m.mf, 2b_1b.bb, 2b_1m.bb, 2b_1m.ib,\\\n+    2b_1m.mb, 2b_1m.fb, 2b_1m.lx\")\n+(exclusion_set \"2b_1m.fi\"\n+   \"2b_1m.mf, 2b_1b.bb, 2b_1m.bb, 2b_1m.ib, 2b_1m.mb, 2b_1m.fb, 2b_1m.lx\")\n+(exclusion_set \"2b_1m.mf\"\n+   \"2b_1b.bb, 2b_1m.bb, 2b_1m.ib, 2b_1m.mb, 2b_1m.fb, 2b_1m.lx\")\n+(exclusion_set \"2b_1b.bb\" \"2b_1m.bb, 2b_1m.ib, 2b_1m.mb, 2b_1m.fb, 2b_1m.lx\")\n+(exclusion_set \"2b_1m.bb\" \"2b_1m.ib, 2b_1m.mb, 2b_1m.fb, 2b_1m.lx\")\n+(exclusion_set \"2b_1m.ib\" \"2b_1m.mb, 2b_1m.fb, 2b_1m.lx\")\n+(exclusion_set \"2b_1m.mb\" \"2b_1m.fb, 2b_1m.lx\")\n+(exclusion_set \"2b_1m.fb\" \"2b_1m.lx\")\n+\n+;; Slot 5\n+(exclusion_set \"2b_1mi.i\"\n+   \"2b_1mm.i, 2b_1mf.i, 2b_1mm.f, 2b_1bb.b, 2b_1mb.b,\\\n+    2b_1mi.b, 2b_1mm.b, 2b_1mf.b, 2b_1mlx.\")\n+(exclusion_set \"2b_1mm.i\"\n+   \"2b_1mf.i, 2b_1mm.f, 2b_1bb.b, 2b_1mb.b,\\\n+    2b_1mi.b, 2b_1mm.b, 2b_1mf.b, 2b_1mlx.\")\n+(exclusion_set \"2b_1mf.i\"\n+   \"2b_1mm.f, 2b_1bb.b, 2b_1mb.b, 2b_1mi.b, 2b_1mm.b, 2b_1mf.b, 2b_1mlx.\")\n+(exclusion_set \"2b_1mm.f\"\n+   \"2b_1bb.b, 2b_1mb.b, 2b_1mi.b, 2b_1mm.b, 2b_1mf.b, 2b_1mlx.\")\n+(exclusion_set \"2b_1bb.b\" \"2b_1mb.b, 2b_1mi.b, 2b_1mm.b, 2b_1mf.b, 2b_1mlx.\")\n+(exclusion_set \"2b_1mb.b\" \"2b_1mi.b, 2b_1mm.b, 2b_1mf.b, 2b_1mlx.\")\n+(exclusion_set \"2b_1mi.b\" \"2b_1mm.b, 2b_1mf.b, 2b_1mlx.\")\n+(exclusion_set \"2b_1mm.b\" \"2b_1mf.b, 2b_1mlx.\")\n+(exclusion_set \"2b_1mf.b\" \"2b_1mlx.\")\n+\n+;; Slot 6\n+(exclusion_set \"2b_1mii.\"\n+   \"2b_1mmi., 2b_1mfi., 2b_1mmf., 2b_1bbb., 2b_1mbb.,\\\n+    2b_1mib., 2b_1mmb., 2b_1mfb., 2b_1mlx.\")\n+(exclusion_set \"2b_1mmi.\"\n+   \"2b_1mfi., 2b_1mmf., 2b_1bbb., 2b_1mbb.,\\\n+    2b_1mib., 2b_1mmb., 2b_1mfb., 2b_1mlx.\")\n+(exclusion_set \"2b_1mfi.\"\n+   \"2b_1mmf., 2b_1bbb., 2b_1mbb., 2b_1mib., 2b_1mmb., 2b_1mfb., 2b_1mlx.\")\n+(exclusion_set \"2b_1mmf.\"\n+   \"2b_1bbb., 2b_1mbb., 2b_1mib., 2b_1mmb., 2b_1mfb., 2b_1mlx.\")\n+(exclusion_set \"2b_1bbb.\" \"2b_1mbb., 2b_1mib., 2b_1mmb., 2b_1mfb., 2b_1mlx.\")\n+(exclusion_set \"2b_1mbb.\" \"2b_1mib., 2b_1mmb., 2b_1mfb., 2b_1mlx.\")\n+(exclusion_set \"2b_1mib.\" \"2b_1mmb., 2b_1mfb., 2b_1mlx.\")\n+(exclusion_set \"2b_1mmb.\" \"2b_1mfb., 2b_1mlx.\")\n+(exclusion_set \"2b_1mfb.\" \"2b_1mlx.\")\n+\n+(final_presence_set \"2b_0mi.i\" \"2b_0m.ii\")\n+(final_presence_set \"2b_0mii.\" \"2b_0mi.i\")\n+(final_presence_set \"2b_1mi.i\" \"2b_1m.ii\")\n+(final_presence_set \"2b_1mii.\" \"2b_1mi.i\")\n+\n+(final_presence_set \"2b_0mm.i\" \"2b_0m.mi\")\n+(final_presence_set \"2b_0mmi.\" \"2b_0mm.i\")\n+(final_presence_set \"2b_1mm.i\" \"2b_1m.mi\")\n+(final_presence_set \"2b_1mmi.\" \"2b_1mm.i\")\n+\n+(final_presence_set \"2b_0mf.i\" \"2b_0m.fi\")\n+(final_presence_set \"2b_0mfi.\" \"2b_0mf.i\")\n+(final_presence_set \"2b_1mf.i\" \"2b_1m.fi\")\n+(final_presence_set \"2b_1mfi.\" \"2b_1mf.i\")\n+\n+(final_presence_set \"2b_0mm.f\" \"2b_0m.mf\")\n+(final_presence_set \"2b_0mmf.\" \"2b_0mm.f\")\n+(final_presence_set \"2b_1mm.f\" \"2b_1m.mf\")\n+(final_presence_set \"2b_1mmf.\" \"2b_1mm.f\")\n+\n+(final_presence_set \"2b_0bb.b\" \"2b_0b.bb\")\n+(final_presence_set \"2b_0bbb.\" \"2b_0bb.b\")\n+(final_presence_set \"2b_1bb.b\" \"2b_1b.bb\")\n+(final_presence_set \"2b_1bbb.\" \"2b_1bb.b\")\n+\n+(final_presence_set \"2b_0mb.b\" \"2b_0m.bb\")\n+(final_presence_set \"2b_0mbb.\" \"2b_0mb.b\")\n+(final_presence_set \"2b_1mb.b\" \"2b_1m.bb\")\n+(final_presence_set \"2b_1mbb.\" \"2b_1mb.b\")\n+\n+(final_presence_set \"2b_0mi.b\" \"2b_0m.ib\")\n+(final_presence_set \"2b_0mib.\" \"2b_0mi.b\")\n+(final_presence_set \"2b_1mi.b\" \"2b_1m.ib\")\n+(final_presence_set \"2b_1mib.\" \"2b_1mi.b\")\n+\n+(final_presence_set \"2b_0mm.b\" \"2b_0m.mb\")\n+(final_presence_set \"2b_0mmb.\" \"2b_0mm.b\")\n+(final_presence_set \"2b_1mm.b\" \"2b_1m.mb\")\n+(final_presence_set \"2b_1mmb.\" \"2b_1mm.b\")\n+\n+(final_presence_set \"2b_0mf.b\" \"2b_0m.fb\")\n+(final_presence_set \"2b_0mfb.\" \"2b_0mf.b\")\n+(final_presence_set \"2b_1mf.b\" \"2b_1m.fb\")\n+(final_presence_set \"2b_1mfb.\" \"2b_1mf.b\")\n+\n+(final_presence_set \"2b_0mlx.\" \"2b_0m.lx\")\n+(final_presence_set \"2b_1mlx.\" \"2b_1m.lx\")\n+\n+;;  See the corresponding comment in non-bundling section above.\n+(final_presence_set\n+   \"2b_1m.lx\"\n+   \"2b_0mmi.,2b_0mfi.,2b_0mmf.,2b_0mib.,2b_0mmb.,2b_0mfb.,2b_0mlx.\")\n+(final_presence_set \"2b_1b.bb\" \"2b_0mii.,2b_0mmi.,2b_0mfi.,2b_0mmf.,2b_0mlx.\")\n+(final_presence_set\n+   \"2b_1m.ii,2b_1m.mi,2b_1m.fi,2b_1m.mf,2b_1m.bb,2b_1m.ib,2b_1m.mb,2b_1m.fb\"\n+   \"2b_0mii.,2b_0mmi.,2b_0mfi.,2b_0mmf.,2b_0mib.,2b_0mmb.,2b_0mfb.,2b_0mlx.\")\n+\n+;;  Ports/units (nb means nop.b insn issued into given port):\n+(define_cpu_unit\n+   \"2b_um0, 2b_um1, 2b_um2, 2b_um3, 2b_ui0, 2b_ui1, 2b_uf0, 2b_uf1,\\\n+    2b_ub0, 2b_ub1, 2b_ub2, 2b_unb0, 2b_unb1, 2b_unb2\" \"twob\")\n+\n+(exclusion_set \"2b_ub0\" \"2b_unb0\")\n+(exclusion_set \"2b_ub1\" \"2b_unb1\")\n+(exclusion_set \"2b_ub2\" \"2b_unb2\")\n+\n+;; The following rules are used to decrease number of alternatives.\n+;; They are consequences of Itanium2 microarchitecture.  They also\n+;; describe the following rules mentioned in Itanium2\n+;; microarchitecture: rules mentioned in Itanium2 microarchitecture:\n+;; o \"BBB/MBB: Always splits issue after either of these bundles\".\n+;; o \"MIB BBB: Split issue after the first bundle in this pair\".\n+(exclusion_set\n+   \"2b_0b.bb,2b_0bb.b,2b_0bbb.,2b_0m.bb,2b_0mb.b,2b_0mbb.\"\n+   \"2b_1m.ii,2b_1m.mi,2b_1m.fi,2b_1m.mf,2b_1b.bb,2b_1m.bb,\\\n+    2b_1m.ib,2b_1m.mb,2b_1m.fb,2b_1m.lx\")\n+(exclusion_set \"2b_0m.ib,2b_0mi.b,2b_0mib.\" \"2b_1b.bb\")\n+\n+;;; \"MIB/MFB/MMB: Splits issue after any of these bundles unless the\n+;;; B-slot contains a nop.b or a brp instruction\".\n+;;;   \"The B in an MIB/MFB/MMB bundle disperses to B0 if it is a brp or\n+;;; nop.b, otherwise it disperses to B2\".\n+(final_absence_set\n+   \"2b_1m.ii, 2b_1m.mi, 2b_1m.fi, 2b_1m.mf, 2b_1b.bb, 2b_1m.bb,\\\n+    2b_1m.ib, 2b_1m.mb, 2b_1m.fb, 2b_1m.lx\"\n+   \"2b_0mib. 2b_ub2, 2b_0mfb. 2b_ub2, 2b_0mmb. 2b_ub2\")\n+\n+;; This is necessary to start new processor cycle when we meet stop bit.\n+(define_cpu_unit \"2b_stop\" \"twob\")\n+(final_absence_set\n+   \"2b_0m.ii,2b_0mi.i,2b_0mii.,2b_0m.mi,2b_0mm.i,2b_0mmi.,\\\n+    2b_0m.fi,2b_0mf.i,2b_0mfi.,\\\n+    2b_0m.mf,2b_0mm.f,2b_0mmf.,2b_0b.bb,2b_0bb.b,2b_0bbb.,\\\n+    2b_0m.bb,2b_0mb.b,2b_0mbb.,\\\n+    2b_0m.ib,2b_0mi.b,2b_0mib.,2b_0m.mb,2b_0mm.b,2b_0mmb.,\\\n+    2b_0m.fb,2b_0mf.b,2b_0mfb.,2b_0m.lx,2b_0mlx., \\\n+    2b_1m.ii,2b_1mi.i,2b_1mii.,2b_1m.mi,2b_1mm.i,2b_1mmi.,\\\n+    2b_1m.fi,2b_1mf.i,2b_1mfi.,\\\n+    2b_1m.mf,2b_1mm.f,2b_1mmf.,2b_1b.bb,2b_1bb.b,2b_1bbb.,\\\n+    2b_1m.bb,2b_1mb.b,2b_1mbb.,\\\n+    2b_1m.ib,2b_1mi.b,2b_1mib.,2b_1m.mb,2b_1mm.b,2b_1mmb.,\\\n+    2b_1m.fb,2b_1mf.b,2b_1mfb.,2b_1m.lx,2b_1mlx.\"\n+   \"2b_stop\")\n+\n+;;   The issue logic can reorder M slot insns between different subtypes\n+;; but can not reorder insn within the same subtypes.  The following\n+;; constraint is enough to describe this.\n+(final_presence_set \"2b_um1\" \"2b_um0\")\n+(final_presence_set \"2b_um3\" \"2b_um2\")\n+\n+;;   The insn in the 1st I slot of the two bundle issue group will issue\n+;; to I0.  The second I slot insn will issue to I1.\n+(final_presence_set \"2b_ui1\" \"2b_ui0\")\n+\n+;;  For exceptions of I insns:\n+(define_cpu_unit \"2b_only_ui0\" \"twob\")\n+(final_absence_set \"2b_only_ui0\"  \"2b_ui1\")\n+\n+;; Insns\n+\n+(define_reservation \"2b_M\"\n+  \"((2b_0m.ii|2b_0m.mi|2b_0m.fi|2b_0m.mf|2b_0m.bb\\\n+     |2b_0m.ib|2b_0m.mb|2b_0m.fb|2b_0m.lx)+2_1\\\n+    |(2b_1m.ii|2b_1m.mi|2b_1m.fi|2b_1m.mf|2b_1m.bb\\\n+      |2b_1m.ib|2b_1m.mb|2b_1m.fb|2b_1m.lx)+2_4\\\n+    |(2b_0mm.i|2b_0mm.f|2b_0mm.b)+2_2\\\n+    |(2b_1mm.i|2b_1mm.f|2b_1mm.b)+2_5)\\\n+   +(2b_um0|2b_um1|2b_um2|2b_um3)\")\n+\n+(define_reservation \"2b_M_only_um0\"\n+  \"((2b_0m.ii|2b_0m.mi|2b_0m.fi|2b_0m.mf|2b_0m.bb\\\n+     |2b_0m.ib|2b_0m.mb|2b_0m.fb|2b_0m.lx)+2_1\\\n+    |(2b_1m.ii|2b_1m.mi|2b_1m.fi|2b_1m.mf|2b_1m.bb\\\n+      |2b_1m.ib|2b_1m.mb|2b_1m.fb|2b_1m.lx)+2_4\\\n+    |(2b_0mm.i|2b_0mm.f|2b_0mm.b)+2_2\\\n+    |(2b_1mm.i|2b_1mm.f|2b_1mm.b)+2_5)\\\n+   +2b_um0\")\n+\n+(define_reservation \"2b_M_only_um2\"\n+  \"((2b_0m.ii|2b_0m.mi|2b_0m.fi|2b_0m.mf|2b_0m.bb\\\n+     |2b_0m.ib|2b_0m.mb|2b_0m.fb|2b_0m.lx)+2_1\\\n+    |(2b_1m.ii|2b_1m.mi|2b_1m.fi|2b_1m.mf|2b_1m.bb\\\n+      |2b_1m.ib|2b_1m.mb|2b_1m.fb|2b_1m.lx)+2_4\\\n+    |(2b_0mm.i|2b_0mm.f|2b_0mm.b)+2_2\\\n+    |(2b_1mm.i|2b_1mm.f|2b_1mm.b)+2_5)\\\n+   +2b_um2\")\n+\n+(define_reservation \"2b_M_only_um01\"\n+  \"((2b_0m.ii|2b_0m.mi|2b_0m.fi|2b_0m.mf|2b_0m.bb\\\n+     |2b_0m.ib|2b_0m.mb|2b_0m.fb|2b_0m.lx)+2_1\\\n+    |(2b_1m.ii|2b_1m.mi|2b_1m.fi|2b_1m.mf|2b_1m.bb\\\n+      |2b_1m.ib|2b_1m.mb|2b_1m.fb|2b_1m.lx)+2_4\\\n+    |(2b_0mm.i|2b_0mm.f|2b_0mm.b)+2_2\\\n+    |(2b_1mm.i|2b_1mm.f|2b_1mm.b)+2_5)\\\n+   +(2b_um0|2b_um1)\")\n+\n+(define_reservation \"2b_M_only_um23\"\n+  \"((2b_0m.ii|2b_0m.mi|2b_0m.fi|2b_0m.mf|2b_0m.bb\\\n+     |2b_0m.ib|2b_0m.mb|2b_0m.fb|2b_0m.lx)+2_1\\\n+    |(2b_1m.ii|2b_1m.mi|2b_1m.fi|2b_1m.mf|2b_1m.bb\\\n+      |2b_1m.ib|2b_1m.mb|2b_1m.fb|2b_1m.lx)+2_4\\\n+    |(2b_0mm.i|2b_0mm.f|2b_0mm.b)+2_2\\\n+    |(2b_1mm.i|2b_1mm.f|2b_1mm.b)+2_5)\\\n+   +(2b_um2|2b_um3)\")\n+\n+;; I instruction is dispersed to the lowest numbered I unit\n+;; not already in use.  Remeber about possible spliting.\n+(define_reservation \"2b_I\"\n+  \"2b_0mi.i+2_2+2b_ui0|2b_0mii.+2_3+(2b_ui0|2b_ui1)|2b_0mmi.+2_3+2b_ui0\\\n+   |2b_0mfi.+2_3+2b_ui0|2b_0mi.b+2_2+2b_ui0\\\n+   |(2b_1mi.i+2_5|2b_1mi.b+2_5)+(2b_ui0|2b_ui1)\\\n+   |(2b_1mii.|2b_1mmi.|2b_1mfi.)+2_6+(2b_ui0|2b_ui1)\")\n+\n+;; \"An F slot in the 1st bundle disperses to F0\".\n+;; \"An F slot in the 2st bundle disperses to F1\".\n+(define_reservation \"2b_F\"\n+   \"2b_0mf.i+2_2+2b_uf0|2b_0mmf.+2_3+2b_uf0|2b_0mf.b+2_2+2b_uf0\\\n+    |2b_1mf.i+2_5+2b_uf1|2b_1mmf.+2_6+2b_uf1|2b_1mf.b+2_5+2b_uf1\")\n+\n+;;; \"Each B slot in MBB or BBB bundle disperses to the corresponding B\n+;;; unit. That is, a B slot in 1st position is despersed to B0.  In the\n+;;; 2nd position it is dispersed to B2\".\n+(define_reservation \"2b_NB\"\n+    \"2b_0b.bb+2_1+2b_unb0|2b_0bb.b+2_2+2b_unb1|2b_0bbb.+2_3+2b_unb2\\\n+     |2b_0mb.b+2_2+2b_unb1|2b_0mbb.+2_3+2b_unb2\\\n+     |2b_0mib.+2_3+2b_unb0|2b_0mmb.+2_3+2b_unb0|2b_0mfb.+2_3+2b_unb0\\\n+     |2b_1b.bb+2_4+2b_unb0|2b_1bb.b+2_5+2b_unb1\\\n+     |2b_1bbb.+2_6+2b_unb2|2b_1mb.b+2_5+2b_unb1|2b_1mbb.+2_6+2b_unb2\\\n+     |2b_1mib.+2_6+2b_unb0|2b_1mmb.+2_6+2b_unb0|2b_1mfb.+2_6+2b_unb0\")\n+\n+(define_reservation \"2b_B\"\n+   \"2b_0b.bb+2_1+2b_ub0|2b_0bb.b+2_2+2b_ub1|2b_0bbb.+2_3+2b_ub2\\\n+    |2b_0mb.b+2_2+2b_ub1|2b_0mbb.+2_3+2b_ub2|2b_0mib.+2_3+2b_ub2\\\n+    |2b_0mfb.+2_3+2b_ub2|2b_1b.bb+2_4+2b_ub0|2b_1bb.b+2_5+2b_ub1\\\n+    |2b_1bbb.+2_6+2b_ub2|2b_1mb.b+2_5+2b_ub1\\\n+    |2b_1mib.+2_6+2b_ub2|2b_1mmb.+2_6+2b_ub2|2b_1mfb.+2_6+2b_ub2\")\n+\n+;;   For the MLI template, the I slot insn is always assigned to port I0\n+;; if it is in the first bundle or it is assigned to port I1 if it is in\n+;; the second bundle.\n+(define_reservation \"2b_L\"\n+                    \"2b_0mlx.+2_3+2b_ui0+2b_uf0|2b_1mlx.+2_6+2b_ui1+2b_uf1\")\n+\n+;;   Should we describe that A insn in I slot can be issued into M\n+;; ports?  I think it is not necessary because of multipass\n+;; scheduling.  For example, the multipass scheduling could use\n+;; MMI-MMI instead of MII-MII where the two last I slots contain A\n+;; insns (even if the case is complicated by use-def conflicts).\n+;;\n+;; In any case we could describe it as\n+;;    (define_cpu_unit \"2b_ui1_0pres,2b_ui1_1pres,2b_ui1_2pres,2b_ui1_3pres\"\n+;;                     \"twob\")\n+;;    (final_presence_set \"2b_ui1_0pres,2b_ui1_1pres,2b_ui1_2pres,2b_ui1_3pres\"\n+;;                        \"2b_ui1\")\n+;;    (define_reservation \"b_A\"\n+;;       \"b_M|b_I\\\n+;;        |(2b_1mi.i+2_5|2b_1mii.+2_6|2b_1mmi.+2_6|2b_1mfi.+2_6|2b_1mi.b+2_5)\\\n+;;         +(2b_um0|2b_um1|2b_um2|2b_um3)\\\n+;;         +(2b_ui1_0pres|2b_ui1_1pres|2b_ui1_2pres|2b_ui1_3pres)\")\n+\n+(define_reservation \"2b_A\" \"2b_M|2b_I\")\n+\n+;; We assume that there is no insn issued on the same cycle as the\n+;; unknown insn.\n+(define_cpu_unit \"2b_empty\" \"twob\")\n+(exclusion_set \"2b_empty\"\n+    \"2b_0m.ii,2b_0m.mi,2b_0m.fi,2b_0m.mf,2b_0b.bb,2b_0m.bb,\\\n+     2b_0m.ib,2b_0m.mb,2b_0m.fb,2b_0m.lx,2b_0mm.i\")\n+\n+(define_cpu_unit\n+   \"2b_0m_bs, 2b_0mi_bs, 2b_0mm_bs, 2b_0mf_bs, 2b_0b_bs, 2b_0bb_bs, 2b_0mb_bs\"\n+   \"twob\")\n+(define_cpu_unit\n+   \"2b_1m_bs, 2b_1mi_bs, 2b_1mm_bs, 2b_1mf_bs, 2b_1b_bs, 2b_1bb_bs, 2b_1mb_bs\"\n+   \"twob\")\n+\n+(define_cpu_unit \"2b_m_cont, 2b_mi_cont, 2b_mm_cont, 2b_mf_cont, 2b_mb_cont,\\\n+\t          2b_b_cont, 2b_bb_cont\" \"twob\")\n+\n+;; For stop in the middle of the bundles.\n+(define_cpu_unit \"2b_m_stop, 2b_m0_stop, 2b_m1_stop, 2b_0mmi_cont\" \"twob\")\n+(define_cpu_unit \"2b_mi_stop, 2b_mi0_stop, 2b_mi1_stop, 2b_0mii_cont\" \"twob\")\n+\n+(final_presence_set \"2b_0m_bs\"\n+   \"2b_0m.ii, 2b_0m.mi, 2b_0m.mf, 2b_0m.fi, 2b_0m.bb,\\\n+    2b_0m.ib, 2b_0m.fb, 2b_0m.mb, 2b_0m.lx\")\n+(final_presence_set \"2b_1m_bs\"\n+   \"2b_1m.ii, 2b_1m.mi, 2b_1m.mf, 2b_1m.fi, 2b_1m.bb,\\\n+    2b_1m.ib, 2b_1m.fb, 2b_1m.mb, 2b_1m.lx\")\n+(final_presence_set \"2b_0mi_bs\"  \"2b_0mi.i, 2b_0mi.i\")\n+(final_presence_set \"2b_1mi_bs\"  \"2b_1mi.i, 2b_1mi.i\")\n+(final_presence_set \"2b_0mm_bs\"  \"2b_0mm.i, 2b_0mm.f, 2b_0mm.b\")\n+(final_presence_set \"2b_1mm_bs\"  \"2b_1mm.i, 2b_1mm.f, 2b_1mm.b\")\n+(final_presence_set \"2b_0mf_bs\"  \"2b_0mf.i, 2b_0mf.b\")\n+(final_presence_set \"2b_1mf_bs\"  \"2b_1mf.i, 2b_1mf.b\")\n+(final_presence_set \"2b_0b_bs\"  \"2b_0b.bb\")\n+(final_presence_set \"2b_1b_bs\"  \"2b_1b.bb\")\n+(final_presence_set \"2b_0bb_bs\"  \"2b_0bb.b\")\n+(final_presence_set \"2b_1bb_bs\"  \"2b_1bb.b\")\n+(final_presence_set \"2b_0mb_bs\"  \"2b_0mb.b\")\n+(final_presence_set \"2b_1mb_bs\"  \"2b_1mb.b\")\n+\n+(exclusion_set \"2b_0m_bs\"\n+   \"2b_0mi.i, 2b_0mm.i, 2b_0mm.f, 2b_0mf.i, 2b_0mb.b,\\\n+    2b_0mi.b, 2b_0mf.b, 2b_0mm.b, 2b_0mlx., 2b_m0_stop\")\n+(exclusion_set \"2b_1m_bs\"\n+   \"2b_1mi.i, 2b_1mm.i, 2b_1mm.f, 2b_1mf.i, 2b_1mb.b,\\\n+    2b_1mi.b, 2b_1mf.b, 2b_1mm.b, 2b_1mlx., 2b_m1_stop\")\n+(exclusion_set \"2b_0mi_bs\"  \"2b_0mii., 2b_0mib., 2b_mi0_stop\")\n+(exclusion_set \"2b_1mi_bs\"  \"2b_1mii., 2b_1mib., 2b_mi1_stop\")\n+(exclusion_set \"2b_0mm_bs\"  \"2b_0mmi., 2b_0mmf., 2b_0mmb.\")\n+(exclusion_set \"2b_1mm_bs\"  \"2b_1mmi., 2b_1mmf., 2b_1mmb.\")\n+(exclusion_set \"2b_0mf_bs\"  \"2b_0mfi., 2b_0mfb.\")\n+(exclusion_set \"2b_1mf_bs\"  \"2b_1mfi., 2b_1mfb.\")\n+(exclusion_set \"2b_0b_bs\"  \"2b_0bb.b\")\n+(exclusion_set \"2b_1b_bs\"  \"2b_1bb.b\")\n+(exclusion_set \"2b_0bb_bs\"  \"2b_0bbb.\")\n+(exclusion_set \"2b_1bb_bs\"  \"2b_1bbb.\")\n+(exclusion_set \"2b_0mb_bs\"  \"2b_0mbb.\")\n+(exclusion_set \"2b_1mb_bs\"  \"2b_1mbb.\")\n+\n+(exclusion_set\n+   \"2b_0m_bs, 2b_0mi_bs, 2b_0mm_bs, 2b_0mf_bs, 2b_0b_bs, 2b_0bb_bs, 2b_0mb_bs,\n+    2b_1m_bs, 2b_1mi_bs, 2b_1mm_bs, 2b_1mf_bs, 2b_1b_bs, 2b_1bb_bs, 2b_1mb_bs\"\n+   \"2b_stop\")\n+\n+(final_presence_set\n+   \"2b_0mi.i, 2b_0mm.i, 2b_0mf.i, 2b_0mm.f, 2b_0mb.b,\\\n+    2b_0mi.b, 2b_0mm.b, 2b_0mf.b, 2b_0mlx.\"\n+   \"2b_m_cont\")\n+(final_presence_set \"2b_0mii., 2b_0mib.\" \"2b_mi_cont\")\n+(final_presence_set \"2b_0mmi., 2b_0mmf., 2b_0mmb.\" \"2b_mm_cont\")\n+(final_presence_set \"2b_0mfi., 2b_0mfb.\" \"2b_mf_cont\")\n+(final_presence_set \"2b_0bb.b\" \"2b_b_cont\")\n+(final_presence_set \"2b_0bbb.\" \"2b_bb_cont\")\n+(final_presence_set \"2b_0mbb.\" \"2b_mb_cont\")\n+\n+(exclusion_set\n+   \"2b_0m.ii, 2b_0m.mi, 2b_0m.fi, 2b_0m.mf, 2b_0b.bb, 2b_0m.bb,\\\n+    2b_0m.ib, 2b_0m.mb, 2b_0m.fb, 2b_0m.lx\"\n+   \"2b_m_cont, 2b_mi_cont, 2b_mm_cont, 2b_mf_cont,\\\n+    2b_mb_cont, 2b_b_cont, 2b_bb_cont\")\n+\n+(exclusion_set \"2b_empty\"\n+               \"2b_m_cont,2b_mi_cont,2b_mm_cont,2b_mf_cont,\\\n+                2b_mb_cont,2b_b_cont,2b_bb_cont\")\n+\n+;; For m;mi bundle\n+(final_presence_set \"2b_m0_stop\" \"2b_0m.mi\")\n+(final_presence_set \"2b_0mm.i\" \"2b_0mmi_cont\")\n+(exclusion_set \"2b_0mmi_cont\"\n+   \"2b_0m.ii, 2b_0m.mi, 2b_0m.fi, 2b_0m.mf, 2b_0b.bb, 2b_0m.bb,\\\n+    2b_0m.ib, 2b_0m.mb, 2b_0m.fb, 2b_0m.lx\")\n+(exclusion_set \"2b_m0_stop\" \"2b_0mm.i\")\n+(final_presence_set \"2b_m1_stop\" \"2b_1m.mi\")\n+(exclusion_set \"2b_m1_stop\" \"2b_1mm.i\")\n+(final_presence_set \"2b_m_stop\" \"2b_m0_stop, 2b_m1_stop\")\n+\n+;; For mi;i bundle\n+(final_presence_set \"2b_mi0_stop\" \"2b_0mi.i\")\n+(final_presence_set \"2b_0mii.\" \"2b_0mii_cont\")\n+(exclusion_set \"2b_0mii_cont\"\n+   \"2b_0m.ii, 2b_0m.mi, 2b_0m.fi, 2b_0m.mf, 2b_0b.bb, 2b_0m.bb,\\\n+    2b_0m.ib, 2b_0m.mb, 2b_0m.fb, 2b_0m.lx\")\n+(exclusion_set \"2b_mi0_stop\" \"2b_0mii.\")\n+(final_presence_set \"2b_mi1_stop\" \"2b_1mi.i\")\n+(exclusion_set \"2b_mi1_stop\" \"2b_1mii.\")\n+(final_presence_set \"2b_mi_stop\" \"2b_mi0_stop, 2b_mi1_stop\")\n+\n+(final_absence_set\n+   \"2b_0m.ii,2b_0mi.i,2b_0mii.,2b_0m.mi,2b_0mm.i,2b_0mmi.,\\\n+    2b_0m.fi,2b_0mf.i,2b_0mfi.,2b_0m.mf,2b_0mm.f,2b_0mmf.,\\\n+    2b_0b.bb,2b_0bb.b,2b_0bbb.,2b_0m.bb,2b_0mb.b,2b_0mbb.,\\\n+    2b_0m.ib,2b_0mi.b,2b_0mib.,2b_0m.mb,2b_0mm.b,2b_0mmb.,\\\n+    2b_0m.fb,2b_0mf.b,2b_0mfb.,2b_0m.lx,2b_0mlx., \\\n+    2b_1m.ii,2b_1mi.i,2b_1mii.,2b_1m.mi,2b_1mm.i,2b_1mmi.,\\\n+    2b_1m.fi,2b_1mf.i,2b_1mfi.,2b_1m.mf,2b_1mm.f,2b_1mmf.,\\\n+    2b_1b.bb,2b_1bb.b,2b_1bbb.,2b_1m.bb,2b_1mb.b,2b_1mbb.,\\\n+    2b_1m.ib,2b_1mi.b,2b_1mib.,2b_1m.mb,2b_1mm.b,2b_1mmb.,\\\n+    2b_1m.fb,2b_1mf.b,2b_1mfb.,2b_1m.lx,2b_1mlx.\"\n+   \"2b_m0_stop,2b_m1_stop,2b_mi0_stop,2b_mi1_stop\")\n+\n+(define_insn_reservation \"2b_stop_bit\" 0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"stop_bit\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2b_stop|2b_m0_stop|2b_m1_stop|2b_mi0_stop|2b_mi1_stop\")\n+(define_insn_reservation \"2b_br\"      0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"br\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"2b_B\")\n+(define_insn_reservation \"2b_scall\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"scall\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"2b_B\")\n+(define_insn_reservation \"2b_fcmp\"    2\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"fcmp\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"2b_F\")\n+(define_insn_reservation \"2b_fcvtfx\"  4\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"fcvtfx\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"2b_F\")\n+(define_insn_reservation \"2b_fld\"     6\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"fld\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"2b_M\")\n+(define_insn_reservation \"2b_fmac\"    4\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"fmac\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"2b_F\")\n+(define_insn_reservation \"2b_fmisc\"   4\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"fmisc\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"2b_F\")\n+\n+;; Latency time ???\n+(define_insn_reservation \"2b_frar_i\" 13\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"frar_i\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2b_I+2b_only_ui0\")\n+;; Latency time ???\n+(define_insn_reservation \"2b_frar_m\"  6\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"frar_m\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2b_M_only_um2\")\n+(define_insn_reservation \"2b_frbr\"    2\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"frbr\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2b_I+2b_only_ui0\")\n+(define_insn_reservation \"2b_frfr\"    5\t\t\t\t  \n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"frfr\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2b_M_only_um2\")\n+(define_insn_reservation \"2b_frpr\"    2\t\t\t\t  \n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"frpr\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2b_I+2b_only_ui0\")\n+\n+(define_insn_reservation \"2b_ialu\"      1\n+    (and (and (eq_attr \"cpu\" \"itanium2\")\n+              (eq_attr \"itanium_class\" \"ialu\"))\n+         (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+    \"2b_A\")\n+(define_insn_reservation \"2b_icmp\"    1\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"icmp\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"2b_A\")\n+(define_insn_reservation \"2b_ilog\"    1\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"ilog\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"2b_A\")\n+;; Latency time ???\n+(define_insn_reservation \"2b_ishf\"    1\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"ishf\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2b_I+2b_only_ui0\")\n+(define_insn_reservation \"2b_ld\"      1\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"ld\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2b_M_only_um01\")\n+(define_insn_reservation \"2b_long_i\"  1\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"long_i\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"2b_L\")\n+\n+;; Latency time ???\n+(define_insn_reservation \"2b_mmmul\"   2\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"mmmul\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2b_I+2b_only_ui0\")\n+;; Latency time ???\n+(define_insn_reservation \"2b_mmshf\"   2\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"mmshf\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"2b_I\")\n+;; Latency time ???\n+(define_insn_reservation \"2b_mmshfi\"  1\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"mmshfi\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"2b_I\")\n+\n+(define_insn_reservation \"2b_rse_m\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"rse_m\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+   \"(2b_0m.ii|2b_0m.mi|2b_0m.fi|2b_0m.mf|2b_0m.bb\\\n+     |2b_0m.ib|2b_0m.mb|2b_0m.fb|2b_0m.lx)+2_1+2b_um0\")\n+(define_insn_reservation \"2b_sem\"     0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"sem\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2b_M_only_um23\")\n+\n+(define_insn_reservation \"2b_stf\"     1\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"stf\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2b_M_only_um23\")\n+(define_insn_reservation \"2b_st\"      1\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"st\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2b_M_only_um23\")\n+(define_insn_reservation \"2b_syst_m0\" 0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"syst_m0\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2b_M_only_um2\")\n+(define_insn_reservation \"2b_syst_m\"  0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"syst_m\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2b_M_only_um0\")\n+;; Reservation???\n+(define_insn_reservation \"2b_tbit\"    1\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"tbit\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2b_I+2b_only_ui0\")\n+(define_insn_reservation \"2b_toar_i\"  0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"toar_i\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2b_I+2b_only_ui0\")\n+;; Latency time ???\n+(define_insn_reservation \"2b_toar_m\"  5\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"toar_m\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2b_M_only_um2\")\n+;; Latency time ???\n+(define_insn_reservation \"2b_tobr\"    1\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"tobr\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2b_I+2b_only_ui0\")\n+(define_insn_reservation \"2b_tofr\"    5\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"tofr\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2b_M_only_um23\")\n+;; Latency time ???\n+(define_insn_reservation \"2b_topr\"    1\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"topr\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2b_I+2b_only_ui0\")\n+\n+(define_insn_reservation \"2b_xmpy\"    4\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"xmpy\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"2b_F\")\n+;; Latency time ???\n+(define_insn_reservation \"2b_xtd\"     1\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"xtd\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"2b_I\")\n+(define_insn_reservation \"2b_chk_s\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"chk_s\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2b_I|2b_M_only_um23\")\n+(define_insn_reservation \"2b_lfetch\"  0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"lfetch\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2b_M_only_um01\")\n+(define_insn_reservation \"2b_nop_m\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"nop_m\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"2b_M\")\n+(define_insn_reservation \"2b_nop_b\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"nop_b\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"2b_NB\")\n+(define_insn_reservation \"2b_nop_i\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"nop_i\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"2b_I\")\n+(define_insn_reservation \"2b_nop_f\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"nop_f\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"2b_F\")\n+(define_insn_reservation \"2b_nop_x\"   0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"nop_x\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"2b_L\")\n+(define_insn_reservation \"2b_unknown\" 1\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"unknown\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"2b_empty\")\n+(define_insn_reservation \"2b_nop\" 0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"nop\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2b_M|2b_NB|2b_I|2b_F\")\n+(define_insn_reservation \"2b_ignore\" 0\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"ignore\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"nothing\")\n+\n+(define_insn_reservation \"2b_pre_cycle\" 0\n+   (and (and (eq_attr \"cpu\" \"itanium2\")\n+             (eq_attr \"itanium_class\" \"pre_cycle\"))\n+        (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+                         \"(2b_0m_bs, 2b_m_cont)     \\\n+                          | (2b_0mi_bs, 2b_mi_cont) \\\n+                          | (2b_0mm_bs, 2b_mm_cont) \\\n+                          | (2b_0mf_bs, 2b_mf_cont) \\\n+                          | (2b_0b_bs, 2b_b_cont)   \\\n+                          | (2b_0bb_bs, 2b_bb_cont) \\\n+                          | (2b_0mb_bs, 2b_mb_cont) \\\n+                          | (2b_1m_bs, 2b_m_cont)   \\\n+                          | (2b_1mi_bs, 2b_mi_cont) \\\n+                          | (2b_1mm_bs, 2b_mm_cont) \\\n+                          | (2b_1mf_bs, 2b_mf_cont) \\\n+                          | (2b_1b_bs, 2b_b_cont)   \\\n+                          | (2b_1bb_bs, 2b_bb_cont) \\\n+                          | (2b_1mb_bs, 2b_mb_cont) \\\n+                          | (2b_m_stop, 2b_0mmi_cont)   \\\n+                          | (2b_mi_stop, 2b_0mii_cont)\")\n+"}, {"sha": "8b3e365a55091800cc6277844f1bdaefd032d763", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=30028c85159c12c4e8920af0a9111372e56f1636", "patch": "@@ -9519,6 +9519,14 @@ A fixed register is one that the register allocator can not use.  This is\n useful when compiling kernel code.  A register range is specified as\n two registers separated by a dash.  Multiple register ranges can be\n specified separated by a comma.\n+\n+@item -mearly-stop-bits\n+@itemx -mno-early-stop-bits\n+@opindex mearly-stop-bits\n+@opindex mno-early-stop-bits\n+Allow stop bits to be placed earlier than immediately preceding the\n+instruction that triggered the stop bit.  This can improve instruction\n+scheduling, but does not always do so.\n @end table\n \n @node D30V Options"}, {"sha": "5b91c08268084cb57d0e4534ce2b0ef9457de76a", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 91, "deletions": 23, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=30028c85159c12c4e8920af0a9111372e56f1636", "patch": "@@ -5586,16 +5586,23 @@ which the unit is bound.  The automaton should be described in\n construction @code{define_automaton}.  You should give\n @dfn{automaton-name}, if there is a defined automaton.\n \n+The assignment of units to automata are constrained by the uses of the\n+units in insn reservations.  The most important constraint is: if a\n+unit reservation is present on a particular cycle of an alternative\n+for an insn reservation, then some unit from the same automaton must\n+be present on the same cycle for the other alternatives of the insn\n+reservation.  The rest of the constraints are mentioned in the\n+description of the subsequent constructions.\n+\n @findex define_query_cpu_unit\n @cindex querying function unit reservations\n The following construction describes CPU functional units analogously\n-to @code{define_cpu_unit}.  If we use automata without their\n-minimization, the reservation of such units can be queried for an\n-automaton state.  The instruction scheduler never queries reservation\n-of functional units for given automaton state.  So as a rule, you\n-don't need this construction.  This construction could be used for\n-future code generation goals (e.g. to generate @acronym{VLIW} insn\n-templates).\n+to @code{define_cpu_unit}.  The reservation of such units can be\n+queried for an automaton state.  The instruction scheduler never\n+queries reservation of functional units for given automaton state.  So\n+as a rule, you don't need this construction.  This construction could\n+be used for future code generation goals (e.g. to generate\n+@acronym{VLIW} insn templates).\n \n @smallexample\n (define_query_cpu_unit @var{unit-names} [@var{automaton-name}])\n@@ -5744,7 +5751,9 @@ of insn @samp{store} (not a stored value).\n \n @findex exclusion_set\n @findex presence_set\n+@findex final_presence_set\n @findex absence_set\n+@findex final_absence_set\n @cindex VLIW\n @cindex RISC\n Usually the following three constructions are used to describe\n@@ -5754,13 +5763,19 @@ used for @acronym{RISC} processors too.\n \n @smallexample\n (exclusion_set @var{unit-names} @var{unit-names})\n-(presence_set @var{unit-names} @var{unit-names})\n-(absence_set @var{unit-names} @var{unit-names})\n+(presence_set @var{unit-names} @var{patterns})\n+(final_presence_set @var{unit-names} @var{patterns})\n+(absence_set @var{unit-names} @var{patterns})\n+(final_absence_set @var{unit-names} @var{patterns})\n @end smallexample\n \n @var{unit-names} is a string giving names of functional units\n separated by commas.\n \n+@var{patterns} is a string giving patterns of functional units\n+separated by comma.  Currently pattern is is one unit or units\n+separated by white-spaces.\n+\n The first construction (@samp{exclusion_set}) means that each\n functional unit in the first string can not be reserved simultaneously\n with a unit whose name is in the second string and vice versa.  For\n@@ -5771,22 +5786,75 @@ point insns or only double floating point insns.\n \n The second construction (@samp{presence_set}) means that each\n functional unit in the first string can not be reserved unless at\n-least one of units whose names are in the second string is reserved.\n-This is an asymmetric relation.  For example, it is useful for\n-description that @acronym{VLIW} @samp{slot1} is reserved after\n-@samp{slot0} reservation.\n-\n-The third construction (@samp{absence_set}) means that each functional\n-unit in the first string can be reserved only if each unit whose name\n-is in the second string is not reserved.  This is an asymmetric\n-relation (actually @samp{exclusion_set} is analogous to this one but\n-it is symmetric).  For example, it is useful for description that\n-@acronym{VLIW} @samp{slot0} can not be reserved after @samp{slot1} or\n-@samp{slot2} reservation.\n+least one of pattern of units whose names are in the second string is\n+reserved.  This is an asymmetric relation.  For example, it is useful\n+for description that @acronym{VLIW} @samp{slot1} is reserved after\n+@samp{slot0} reservation.  We could describe it by the following\n+construction\n+\n+@smallexample\n+(presence_set \"slot1\" \"slot0\")\n+@end smallexample\n+\n+Or @samp{slot1} is reserved only after @samp{slot0} and unit @samp{b0}\n+reservation.  In this case we could write\n+\n+@smallexample\n+(presence_set \"slot1\" \"slot0 b0\")\n+@end smallexample\n+\n+The third construction (@samp{final_presence_set}) is analogous to\n+@samp{presence_set}.  The difference between them is when checking is\n+done.  When an instruction is issued in given automaton state\n+reflecting all current and planned unit reservations, the automaton\n+state is changed.  The first state is a source state, the second one\n+is a result state.  Checking for @samp{presence_set} is done on the\n+source state reservation, checking for @samp{final_presence_set} is\n+done on the result reservation.  This construction is useful to\n+describe a reservation which is actually two subsequent reservations.\n+For example, if we use\n+\n+@smallexample\n+(presence_set \"slot1\" \"slot0\")\n+@end smallexample\n+\n+the following insn will be never issued (because @samp{slot1} requires\n+@samp{slot0} which is absent in the source state).\n+\n+@smallexample\n+(define_reservation \"insn_and_nop\" \"slot0 + slot1\")\n+@end smallexample\n+\n+but it can be issued if we use analogous @samp{final_presence_set}.\n+\n+The forth construction (@samp{absence_set}) means that each functional\n+unit in the first string can be reserved only if each pattern of units\n+whose names are in the second string is not reserved.  This is an\n+asymmetric relation (actually @samp{exclusion_set} is analogous to\n+this one but it is symmetric).  For example, it is useful for\n+description that @acronym{VLIW} @samp{slot0} can not be reserved after\n+@samp{slot1} or @samp{slot2} reservation.  We could describe it by the\n+following construction\n+\n+@smallexample\n+(absence_set \"slot2\" \"slot0, slot1\")\n+@end smallexample\n+\n+Or @samp{slot2} can not be reserved if @samp{slot0} and unit @samp{b0}\n+are reserved or @samp{slot1} and unit @samp{b1} are reserved.  In\n+this case we could write\n+\n+@smallexample\n+(absence_set \"slot2\" \"slot0 b0, slot1 b1\")\n+@end smallexample\n \n All functional units mentioned in a set should belong to the same\n automaton.\n \n+The last construction (@samp{final_absence_set}) is analogous to\n+@samp{absence_set} but checking is done on the result (state)\n+reservation.  See comments for @samp{final_presence_set}.\n+\n @findex automata_option\n @cindex deterministic finite state automaton\n @cindex nondeterministic finite state automaton\n@@ -5804,8 +5872,8 @@ code.  Currently there are the following options:\n @itemize @bullet\n @item\n @dfn{no-minimization} makes no minimization of the automaton.  This is\n-only worth to do when we are going to query CPU functional unit\n-reservations in an automaton state.\n+only worth to do when we are debugging the description and need to\n+look more accurately at reservations of states.\n \n @item\n @dfn{time} means printing additional time statistics about"}, {"sha": "45f38f0f921ad6c8bba464fea4580ce043e77c32", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=30028c85159c12c4e8920af0a9111372e56f1636", "patch": "@@ -5629,6 +5629,16 @@ scheduling one insn causes other insns to become ready in the same\n cycle.  These other insns can then be taken into account properly.\n @end deftypefn\n \n+@deftypefn {Target Hook} void TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK (rtx @var{head}, rtx @var{tail})\n+This hook is called after evaluation forward dependencies of insns in\n+chain given by two parameter values (@var{head} and @var{tail}\n+correspondingly) but before insns scheduling of the insn chain.  For\n+example, it can be used for better insn classification if it requires\n+analysis of dependencies.  This hook can use backward and forward\n+dependencies of the insn scheduler because they are already\n+calculated.\n+@end deftypefn\n+\n @deftypefn {Target Hook} void TARGET_SCHED_INIT (FILE *@var{file}, int @var{verbose}, int @var{max_ready})\n This hook is executed by the scheduler at the beginning of each block of\n instructions that are to be scheduled.  @var{file} is either a null\n@@ -5715,6 +5725,30 @@ schedules to choose the best one.\n The default is no multipass scheduling.\n @end deftypefn\n \n+@deftypefn {Target Hook} int TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD (rtx)\n+\n+This hook controls what insns from the ready insn queue will be\n+considered for the multipass insn scheduling.  If the hook returns\n+zero for insn passed as the parameter, the insn will be not chosen to\n+be issued.\n+\n+The default is that any ready insns can be choosen to be issued.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} int TARGET_SCHED_DFA_NEW_CYCLE (FILE *, int, rtx, int, int, int *)\n+\n+This hook is called by the insn scheduler before issuing insn passed\n+as the third parameter on given cycle.  If the hook returns nonzero,\n+the insn is not issued on given processors cycle.  Instead of that,\n+the processor cycle is advanced.  If the value passed through the last\n+parameter is zero, the insn ready queue is not sorted on the new cycle\n+start as usually.  The first parameter passes file for debugging\n+output.  The second one passes the scheduler verbose level of the\n+debugging output.  The forth and the fifth parameter values are\n+correspondingly processor cycle on which the previous insn has been\n+issued and the current processor cycle.\n+@end deftypefn\n+\n @deftypefn {Target Hook} void TARGET_SCHED_INIT_DFA_BUBBLES (void)\n The @acronym{DFA}-based scheduler could take the insertion of nop\n operations for better insn scheduling into account.  It can be done"}, {"sha": "1e910edb3538a5aff54a6427dbe55338f72203af", "filename": "gcc/genattr.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fgenattr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fgenattr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattr.c?ref=30028c85159c12c4e8920af0a9111372e56f1636", "patch": "@@ -441,6 +441,11 @@ main (argc, argv)\n       printf (\"   unit with given code is currently reserved in given\\n\");\n       printf (\"   DFA state.  */\\n\");\n       printf (\"extern int cpu_unit_reservation_p PARAMS ((state_t, int));\\n\");\n+      printf (\"/* Clean insn code cache.  It should be called if there\\n\");\n+      printf (\"   is a chance that condition value in a\\n\");\n+      printf (\"   define_insn_reservation will be changed after\\n\");\n+      printf (\"   last call of dfa_start.  */\\n\");\n+      printf (\"extern void dfa_clean_insn_cache PARAMS ((void));\\n\\n\");\n       printf (\"#endif\\n\\n\");\n       printf (\"/* Initiate and finish work with DFA.  They should be\\n\");\n       printf (\"   called as the first and the last interface\\n\");"}, {"sha": "53ebbefd3ae85e36020d46a73614c489d30ad3a9", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=30028c85159c12c4e8920af0a9111372e56f1636", "patch": "@@ -6115,10 +6115,18 @@ from the machine description file `md'.  */\\n\\n\");\n \t  gen_presence_set (desc);\n \t  break;\n \t  \n+\tcase FINAL_PRESENCE_SET:\n+\t  gen_final_presence_set (desc);\n+\t  break;\n+\t  \n \tcase ABSENCE_SET:\n \t  gen_absence_set (desc);\n \t  break;\n \t  \n+\tcase FINAL_ABSENCE_SET:\n+\t  gen_final_absence_set (desc);\n+\t  break;\n+\t  \n \tcase DEFINE_AUTOMATON:\n \t  gen_automaton (desc);\n \t  break;"}, {"sha": "8d0d35ecf8d6b257314375b8d6899d401f02eede", "filename": "gcc/genattrtab.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fgenattrtab.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fgenattrtab.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.h?ref=30028c85159c12c4e8920af0a9111372e56f1636", "patch": "@@ -33,7 +33,9 @@ extern void gen_query_cpu_unit\t\tPARAMS ((rtx));\n extern void gen_bypass\t\t\tPARAMS ((rtx));\n extern void gen_excl_set\t\tPARAMS ((rtx));\n extern void gen_presence_set\t\tPARAMS ((rtx));\n+extern void gen_final_presence_set\tPARAMS ((rtx));\n extern void gen_absence_set\t\tPARAMS ((rtx));\n+extern void gen_final_absence_set\tPARAMS ((rtx));\n extern void gen_automaton\t\tPARAMS ((rtx));\n extern void gen_automata_option\t\tPARAMS ((rtx));\n extern void gen_reserv   \t\tPARAMS ((rtx));"}, {"sha": "308c189dfbe5c8b219319e85afc931dc3c7f428e", "filename": "gcc/genautomata.c", "status": "modified", "additions": 987, "deletions": 568, "changes": 1555, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=30028c85159c12c4e8920af0a9111372e56f1636", "patch": "@@ -48,7 +48,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n       automaton state.\n \n    4. Several constructions to describe impossible reservations\n-      (`exclusion_set', `presence_set', and `absence_set').\n+      (`exclusion_set', `presence_set', `final_presence_set',\n+      `absence_set', and `final_absence_set').\n \n    5. No reverse automata are generated.  Trace instruction scheduling\n       requires this.  It can be easily added in the future if we\n@@ -57,8 +58,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    6. Union of automaton states are not generated yet.  It is planned\n       to be implemented.  Such feature is needed to make more accurate\n       interlock insn scheduling to get state describing functional\n-      unit reservation in a joint CFG point.\n-*/\n+      unit reservation in a joint CFG point.  */\n \n /* This file code processes constructions of machine description file\n    which describes automaton used for recognition of processor pipeline\n@@ -67,7 +67,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n    The translator functions `gen_cpu_unit', `gen_query_cpu_unit',\n    `gen_bypass', `gen_excl_set', `gen_presence_set',\n-   `gen_absence_set', `gen_automaton', `gen_automata_option',\n+   `gen_final_presence_set', `gen_absence_set',\n+   `gen_final_absence_set', `gen_automaton', `gen_automata_option',\n    `gen_reserv', `gen_insn_reserv' are called from file\n    `genattrtab.c'.  They transform RTL constructions describing\n    automata in .md file into internal representation convenient for\n@@ -166,7 +167,7 @@ struct unit_decl;\n struct bypass_decl;\n struct result_decl;\n struct automaton_decl;\n-struct unit_rel_decl;\n+struct unit_pattern_rel_decl;\n struct reserv_decl;\n struct insn_reserv_decl;\n struct decl;\n@@ -181,6 +182,8 @@ struct oneof_regexp;\n struct regexp;\n struct description;\n struct unit_set_el;\n+struct pattern_set_el;\n+struct pattern_reserv;\n struct state;\n struct alt_state;\n struct arc;\n@@ -193,6 +196,8 @@ typedef struct unit_decl *unit_decl_t;\n typedef struct decl *decl_t;\n typedef struct regexp *regexp_t;\n typedef struct unit_set_el *unit_set_el_t;\n+typedef struct pattern_set_el *pattern_set_el_t;\n+typedef struct pattern_reserv *pattern_reserv_t;\n typedef struct alt_state *alt_state_t;\n typedef struct state *state_t;\n typedef struct arc *arc_t;\n@@ -203,28 +208,30 @@ typedef struct state_ainsn_table *state_ainsn_table_t;\n \n \n /* Prototypes of functions gen_cpu_unit, gen_query_cpu_unit,\n-   gen_bypass, gen_excl_set, gen_presence_set, gen_absence_set,\n-   gen_automaton, gen_automata_option, gen_reserv, gen_insn_reserv,\n+   gen_bypass, gen_excl_set, gen_presence_set, gen_final_presence_set,\n+   gen_absence_set, gen_final_absence_set, gen_automaton,\n+   gen_automata_option, gen_reserv, gen_insn_reserv,\n    initiate_automaton_gen, expand_automata, write_automata are\n    described on the file top because the functions are called from\n    function `main'.  */\n \n-static void *create_node            PARAMS ((size_t));\n-static void *copy_node              PARAMS ((const void *, size_t));\n-static char *check_name             PARAMS ((char *, pos_t));\n-static char *next_sep_el            PARAMS ((char **, int, int));\n-static int n_sep_els                PARAMS ((char *, int, int));\n-static char **get_str_vect          PARAMS ((char *, int *, int, int));\n-static regexp_t gen_regexp_el       PARAMS ((char *));\n-static regexp_t gen_regexp_repeat   PARAMS ((char *));\n-static regexp_t gen_regexp_allof    PARAMS ((char *));\n-static regexp_t gen_regexp_oneof    PARAMS ((char *));\n-static regexp_t gen_regexp_sequence PARAMS ((char *));\n-static regexp_t gen_regexp          PARAMS ((char *));\n-\n-static unsigned string_hash         PARAMS ((const char *));\n-static hashval_t automaton_decl_hash PARAMS ((const void *));\n-static int automaton_decl_eq_p      PARAMS ((const void *,\n+static void *create_node             PARAMS ((size_t));\n+static void *copy_node               PARAMS ((const void *, size_t));\n+static char *check_name              PARAMS ((char *, pos_t));\n+static char *next_sep_el             PARAMS ((char **, int, int));\n+static int n_sep_els                 PARAMS ((char *, int, int));\n+static char **get_str_vect           PARAMS ((char *, int *, int, int));\n+static void gen_presence_absence_set PARAMS ((rtx, int, int));\n+static regexp_t gen_regexp_el        PARAMS ((char *));\n+static regexp_t gen_regexp_repeat    PARAMS ((char *));\n+static regexp_t gen_regexp_allof     PARAMS ((char *));\n+static regexp_t gen_regexp_oneof     PARAMS ((char *));\n+static regexp_t gen_regexp_sequence  PARAMS ((char *));\n+static regexp_t gen_regexp           PARAMS ((char *));\n+\n+static unsigned string_hash          PARAMS ((const char *));\n+static unsigned automaton_decl_hash  PARAMS ((const void *));\n+static int automaton_decl_eq_p       PARAMS ((const void *,\n \t\t\t\t\t\t   const void *));\n static decl_t insert_automaton_decl       PARAMS ((decl_t));\n static decl_t find_automaton_decl         PARAMS ((char *));\n@@ -250,10 +257,15 @@ static void finish_decl_table             PARAMS ((void));\n static unit_set_el_t process_excls       PARAMS ((char **, int, pos_t));\n static void add_excls                    PARAMS ((unit_set_el_t, unit_set_el_t,\n \t\t\t\t\t\t  pos_t));\n-static unit_set_el_t process_presence_absence\n-\t\t\t\t\t PARAMS ((char **, int, pos_t, int));\n-static void add_presence_absence\t PARAMS ((unit_set_el_t, unit_set_el_t,\n-\t\t\t\t\t\t  pos_t, int));\n+static unit_set_el_t process_presence_absence_names\n+\t\t\t\t\t PARAMS ((char **, int, pos_t,\n+\t\t\t\t\t\t  int, int));\n+static pattern_set_el_t process_presence_absence_patterns\n+\t\t\t\t\t PARAMS ((char ***, int, pos_t,\n+\t\t\t\t\t\t  int, int));\n+static void add_presence_absence\t PARAMS ((unit_set_el_t,\n+\t\t\t\t\t\t  pattern_set_el_t,\n+\t\t\t\t\t\t  pos_t, int, int));\n static void process_decls                PARAMS ((void));\n static struct bypass_decl *find_bypass   PARAMS ((struct bypass_decl *,\n \t\t\t\t\t\t  struct insn_reserv_decl *));\n@@ -263,7 +275,8 @@ static void process_regexp_decls         PARAMS ((void));\n static void check_usage                  PARAMS ((void));\n static int loop_in_regexp                PARAMS ((regexp_t, decl_t));\n static void check_loops_in_regexps       PARAMS ((void));\n-static int process_regexp_cycles         PARAMS ((regexp_t, int));\n+static void process_regexp_cycles        PARAMS ((regexp_t, int, int,\n+\t\t\t\t\t\t  int *, int *));\n static void evaluate_max_reserv_cycles   PARAMS ((void));\n static void check_all_description        PARAMS ((void));\n \n@@ -310,8 +323,8 @@ static int state_eq_p                  PARAMS ((const void *, const void *));\n static state_t insert_state            PARAMS ((state_t));\n static void set_state_reserv           PARAMS ((state_t, int, int));\n static int intersected_state_reservs_p PARAMS ((state_t, state_t));\n-static state_t states_union            PARAMS ((state_t, state_t));\n-static state_t state_shift             PARAMS ((state_t));\n+static state_t states_union            PARAMS ((state_t, state_t, reserv_sets_t));\n+static state_t state_shift             PARAMS ((state_t, reserv_sets_t));\n static void initiate_states            PARAMS ((void));\n static void finish_states              PARAMS ((void));\n \n@@ -338,8 +351,12 @@ static void finish_automata_lists PARAMS ((void));\n static void initiate_excl_sets             PARAMS ((void));\n static reserv_sets_t get_excl_set          PARAMS ((reserv_sets_t));\n \n-static void initiate_presence_absence_sets     PARAMS ((void));\n-static reserv_sets_t get_presence_absence_set  PARAMS ((reserv_sets_t, int));\n+static pattern_reserv_t form_reserv_sets_list PARAMS ((pattern_set_el_t));\n+static void initiate_presence_absence_pattern_sets     PARAMS ((void));\n+static int check_presence_pattern_sets     PARAMS ((reserv_sets_t,\n+\t\t\t\t\t\t    reserv_sets_t, int));\n+static int check_absence_pattern_sets  PARAMS ((reserv_sets_t, reserv_sets_t,\n+\t\t\t\t\t\tint));\n \n static regexp_t copy_insn_regexp     PARAMS ((regexp_t));\n static regexp_t transform_1          PARAMS ((regexp_t));\n@@ -350,10 +367,9 @@ static regexp_t regexp_transform_func\n static regexp_t transform_regexp            PARAMS ((regexp_t));\n static void transform_insn_regexps          PARAMS ((void));\n \n-static void process_unit_to_form_the_same_automaton_unit_lists\n-                                            PARAMS ((regexp_t, regexp_t, int));\n-static void form_the_same_automaton_unit_lists_from_regexp PARAMS ((regexp_t));\n-static void form_the_same_automaton_unit_lists PARAMS ((void));\n+static void check_unit_distribution_in_reserv PARAMS ((const char *, regexp_t,\n+\t\t\t\t\t\t       regexp_t, int));\n+static void check_regexp_units_distribution   PARAMS ((const char *, regexp_t));\n static void check_unit_distributions_to_automata PARAMS ((void));\n \n static int process_seq_for_forming_states   PARAMS ((regexp_t, automaton_t,\n@@ -366,9 +382,10 @@ static void create_alt_states               PARAMS ((automaton_t));\n \n static void form_ainsn_with_same_reservs    PARAMS ((automaton_t));\n \n+static reserv_sets_t form_reservs_matter PARAMS ((automaton_t));\n static void make_automaton           PARAMS ((automaton_t));\n static void form_arcs_marked_by_insn PARAMS ((state_t));\n-static void create_composed_state    PARAMS ((state_t, arc_t, vla_ptr_t *));\n+static int create_composed_state     PARAMS ((state_t, arc_t, vla_ptr_t *));\n static void NDFA_to_DFA              PARAMS ((automaton_t));\n static void pass_state_graph         PARAMS ((state_t, void (*) (state_t)));\n static void pass_states              PARAMS ((automaton_t,\n@@ -379,7 +396,8 @@ static int set_out_arc_insns_equiv_num PARAMS ((state_t, int));\n static void clear_arc_insns_equiv_num  PARAMS ((state_t));\n static void copy_equiv_class           PARAMS ((vla_ptr_t *to,\n \t\t\t\t\t\tconst vla_ptr_t *from));\n-static int state_is_differed           PARAMS ((state_t, int, int));\n+static int first_cycle_unit_presence   PARAMS ((state_t, int));\n+static int state_is_differed           PARAMS ((state_t, state_t, int, int));\n static state_t init_equiv_class        PARAMS ((state_t *states, int));\n static int partition_equiv_class       PARAMS ((state_t *, int,\n \t\t\t\t\t\tvla_ptr_t *, int *));\n@@ -449,7 +467,7 @@ static void add_vect_el \t         PARAMS ((vla_hwint_t *,\n static void add_states_vect_el           PARAMS ((state_t));\n static void output_trans_table           PARAMS ((automaton_t));\n static void output_state_alts_table      PARAMS ((automaton_t));\n-static int min_issue_delay_pass_states  PARAMS ((state_t, ainsn_t));\n+static int min_issue_delay_pass_states   PARAMS ((state_t, ainsn_t));\n static int min_issue_delay               PARAMS ((state_t, ainsn_t));\n static void initiate_min_issue_delay_pass_states PARAMS ((void));\n static void output_min_issue_delay_table PARAMS ((automaton_t));\n@@ -483,11 +501,13 @@ static int units_cmp\t\t\t        PARAMS ((const void *,\n \t\t\t\t\t\t\t const void *));\n static void output_get_cpu_unit_code_func       PARAMS ((void));\n static void output_cpu_unit_reservation_p       PARAMS ((void));\n+static void output_dfa_clean_insn_cache_func    PARAMS ((void));\n static void output_dfa_start_func\t        PARAMS ((void));\n static void output_dfa_finish_func\t        PARAMS ((void));\n \n static void output_regexp                  PARAMS ((regexp_t ));\n static void output_unit_set_el_list\t   PARAMS ((unit_set_el_t));\n+static void output_pattern_set_el_list\t   PARAMS ((pattern_set_el_t));\n static void output_description             PARAMS ((void));\n static void output_automaton_name          PARAMS ((FILE *, automaton_t));\n static void output_automaton_units         PARAMS ((automaton_t));\n@@ -714,14 +734,6 @@ struct unit_decl\n      regexp.  */\n   char unit_is_used;\n \n-  /* The following field value is used to form cyclic lists of units\n-     which should be in the same automaton because the unit is\n-     reserved not on all alternatives of a regexp on a cycle.  */\n-  unit_decl_t the_same_automaton_unit;\n-  /* The following field is TRUE if we already reported that the unit\n-     is not in the same automaton.  */\n-  int the_same_automaton_message_reported_p;\n-\n   /* The following field value is order number (0, 1, ...) of given\n      unit.  */\n   int unit_num;\n@@ -733,15 +745,21 @@ struct unit_decl\n      which given unit occurs in insns.  Zero value means that given\n      unit is not used in insns.  */\n   int max_occ_cycle_num;\n+  /* The following field value is minimal cycle number (0, ...) on\n+     which given unit occurs in insns.  -1 value means that given\n+     unit is not used in insns.  */\n+  int min_occ_cycle_num;\n   /* The following list contains units which conflict with given\n      unit.  */\n   unit_set_el_t excl_list;\n-  /* The following list contains units which are required to\n+  /* The following list contains patterns which are required to\n      reservation of given unit.  */\n-  unit_set_el_t presence_list;\n-  /* The following list contains units which should be not present in\n-     reservation for given unit.  */\n-  unit_set_el_t absence_list;\n+  pattern_set_el_t presence_list;\n+  pattern_set_el_t final_presence_list;\n+  /* The following list contains patterns which should be not present\n+     in reservation for given unit.  */\n+  pattern_set_el_t absence_list;\n+  pattern_set_el_t final_absence_list;\n   /* The following is used only when `query_p' has nonzero value.\n      This is query number for the unit.  */\n   int query_num;\n@@ -751,6 +769,11 @@ struct unit_decl\n   /* The following field value is number of the automaton to which\n      given unit belongs.  */\n   int corresponding_automaton_num;\n+  /* If the following value is not zero, the cpu unit is present in a\n+     `exclusion_set' or in right part of a `presence_set',\n+     `final_presence_set', `absence_set', and\n+     `final_absence_set'define_query_cpu_unit.  */\n+  char in_set_p;\n };\n \n /* This describes define_bypass (see file rtl.def).  */\n@@ -790,15 +813,26 @@ struct automaton_decl\n   automaton_t corresponding_automaton;\n };\n \n-/* This describes unit relations: exclusion_set, presence_set, or\n-   absence_set (see file rtl.def).  */\n-struct unit_rel_decl\n+/* This describes exclusion relations: exclusion_set (see file\n+   rtl.def).  */\n+struct excl_rel_decl\n {\n-  int names_num;\n+  int all_names_num;\n   int first_list_length;\n   char *names [1];\n };\n \n+/* This describes unit relations: [final_]presence_set or\n+   [final_]absence_set (see file rtl.def).  */\n+struct unit_pattern_rel_decl\n+{\n+  int final_p;\n+  int names_num;\n+  int patterns_num;\n+  char **names;\n+  char ***patterns;\n+};\n+\n /* This describes define_reservation (see file rtl.def).  */\n struct reserv_decl\n {\n@@ -872,9 +906,9 @@ struct decl\n     struct unit_decl unit;\n     struct bypass_decl bypass;\n     struct automaton_decl automaton;\n-    struct unit_rel_decl excl;\n-    struct unit_rel_decl presence;\n-    struct unit_rel_decl absence;\n+    struct excl_rel_decl excl;\n+    struct unit_pattern_rel_decl presence;\n+    struct unit_pattern_rel_decl absence;\n     struct reserv_decl reserv;\n     struct insn_reserv_decl insn_reserv;\n   } decl;\n@@ -993,22 +1027,41 @@ struct description\n };\n \n \n-\n /* The following nodes are created in automaton checker.  */\n \n-/* The following nodes represent exclusion, presence, absence set for\n-   cpu units.  Each element are accessed through only one excl_list,\n-   presence_list, absence_list.  */\n+/* The following nodes represent exclusion set for cpu units.  Each\n+   element is accessed through only one excl_list.  */\n struct unit_set_el\n {\n   unit_decl_t unit_decl;\n   unit_set_el_t next_unit_set_el;\n };\n \n+/* The following nodes represent presence or absence pattern for cpu\n+   units.  Each element is accessed through only one presence_list or\n+   absence_list.  */\n+struct pattern_set_el\n+{\n+  /* The number of units in unit_decls.  */\n+  int units_num;\n+  /* The units forming the pattern.  */\n+  struct unit_decl **unit_decls;\n+  pattern_set_el_t next_pattern_set_el;\n+};\n \n \n /* The following nodes are created in automaton generator.  */\n \n+\n+/* The following nodes represent presence or absence pattern for cpu\n+   units.  Each element is accessed through only one element of\n+   unit_presence_set_table or unit_absence_set_table.  */\n+struct pattern_reserv\n+{\n+  reserv_sets_t reserv;\n+  pattern_reserv_t next_pattern_reserv;\n+};\n+\n /* The following node type describes state automaton.  The state may\n    be deterministic or non-deterministic.  Non-deterministic state has\n    several component states which represent alternative cpu units\n@@ -1035,11 +1088,12 @@ struct state\n   char it_was_placed_in_stack_for_NDFA_forming;\n   /* The following field is used to form DFA.  */\n   char it_was_placed_in_stack_for_DFA_forming;\n-  /* The following field is used to transform NDFA to DFA.  The field\n-     value is not NULL if the state is a compound state.  In this case\n-     the value of field `unit_sets_list' is NULL.  All states in the\n-     list are in the hash table.  The list is formed through field\n-     `next_sorted_alt_state'.  */\n+  /* The following field is used to transform NDFA to DFA and DFA\n+     minimization.  The field value is not NULL if the state is a\n+     compound state.  In this case the value of field `unit_sets_list'\n+     is NULL.  All states in the list are in the hash table.  The list\n+     is formed through field `next_sorted_alt_state'.  We should\n+     support only one level of nesting state.  */\n   alt_state_t component_states;\n   /* The following field is used for passing graph of states.  */\n   int pass_num;\n@@ -1578,30 +1632,32 @@ n_sep_els (s, sep, par_flag)\n \n /* Given a string and a separator, return vector of strings which are\n    elements in the string and number of elements through els_num.\n-   Take parentheses into account if PAR_FLAG has nonzero value.\n+   Take parentheses into account if PAREN_P has nonzero value.  The\n+   function also inserts the end marker NULL at the end of vector.\n    Return 0 for the null string, -1 if parantheses are not balanced.  */\n static char **\n-get_str_vect (str, els_num, sep, par_flag)\n+get_str_vect (str, els_num, sep, paren_p)\n      char *str;\n      int *els_num;\n      int sep;\n-     int par_flag;\n+     int paren_p;\n {\n   int i;\n   char **vect;\n   char **pstr;\n \n-  *els_num = n_sep_els (str, sep, par_flag);\n+  *els_num = n_sep_els (str, sep, paren_p);\n   if (*els_num <= 0)\n     return NULL;\n-  obstack_blank (&irp, sizeof (char *) * (*els_num));\n+  obstack_blank (&irp, sizeof (char *) * (*els_num + 1));\n   vect = (char **) obstack_base (&irp);\n   obstack_finish (&irp);\n   pstr = &str;\n   for (i = 0; i < *els_num; i++)\n-    vect [i] = next_sep_el (pstr, sep, par_flag);\n-  if (next_sep_el (pstr, sep, par_flag) != NULL)\n+    vect [i] = next_sep_el (pstr, sep, paren_p);\n+  if (next_sep_el (pstr, sep, paren_p) != NULL)\n     abort ();\n+  vect [i] = NULL;\n   return vect;\n }\n \n@@ -1618,7 +1674,8 @@ gen_cpu_unit (def)\n   int vect_length;\n   int i;\n \n-  str_cpu_units = get_str_vect ((char *) XSTR (def, 0), &vect_length, ',', 0);\n+  str_cpu_units = get_str_vect ((char *) XSTR (def, 0), &vect_length, ',',\n+\t\t\t\tFALSE);\n   if (str_cpu_units == NULL)\n     fatal (\"invalid string `%s' in define_cpu_unit\", XSTR (def, 0));\n   for (i = 0; i < vect_length; i++)\n@@ -1629,6 +1686,8 @@ gen_cpu_unit (def)\n       DECL_UNIT (decl)->name = check_name (str_cpu_units [i], decl->pos);\n       DECL_UNIT (decl)->automaton_name = (char *) XSTR (def, 1);\n       DECL_UNIT (decl)->query_p = 0;\n+      DECL_UNIT (decl)->min_occ_cycle_num = -1;\n+      DECL_UNIT (decl)->in_set_p = 0;\n       VLA_PTR_ADD (decls, decl);\n       num_dfa_decls++;\n     }\n@@ -1647,7 +1706,8 @@ gen_query_cpu_unit (def)\n   int vect_length;\n   int i;\n \n-  str_cpu_units = get_str_vect ((char *) XSTR (def, 0), &vect_length, ',', 0);\n+  str_cpu_units = get_str_vect ((char *) XSTR (def, 0), &vect_length, ',',\n+\t\t\t\tFALSE);\n   if (str_cpu_units == NULL)\n     fatal (\"invalid string `%s' in define_query_cpu_unit\", XSTR (def, 0));\n   for (i = 0; i < vect_length; i++)\n@@ -1679,10 +1739,10 @@ gen_bypass (def)\n   int in_length;\n   int i, j;\n \n-  out_insns = get_str_vect ((char *) XSTR (def, 1), &out_length, ',', 0);\n+  out_insns = get_str_vect ((char *) XSTR (def, 1), &out_length, ',', FALSE);\n   if (out_insns == NULL)\n     fatal (\"invalid string `%s' in define_bypass\", XSTR (def, 1));\n-  in_insns = get_str_vect ((char *) XSTR (def, 2), &in_length, ',', 0);\n+  in_insns = get_str_vect ((char *) XSTR (def, 2), &in_length, ',', FALSE);\n   if (in_insns == NULL)\n     fatal (\"invalid string `%s' in define_bypass\", XSTR (def, 2));\n   for (i = 0; i < out_length; i++)\n@@ -1703,7 +1763,7 @@ gen_bypass (def)\n /* Process an EXCLUSION_SET.  \n \n    This gives information about a cpu unit conflicts.  We fill a\n-   struct unit_rel_decl (excl) with information used later by\n+   struct excl_rel_decl (excl) with information used later by\n    `expand_automata'.  */\n void\n gen_excl_set (def)\n@@ -1717,18 +1777,18 @@ gen_excl_set (def)\n   int i;\n \n   first_str_cpu_units\n-    = get_str_vect ((char *) XSTR (def, 0), &first_vect_length, ',', 0);\n+    = get_str_vect ((char *) XSTR (def, 0), &first_vect_length, ',', FALSE);\n   if (first_str_cpu_units == NULL)\n     fatal (\"invalid first string `%s' in exclusion_set\", XSTR (def, 0));\n   second_str_cpu_units = get_str_vect ((char *) XSTR (def, 1), &length, ',',\n-\t\t\t\t       0);\n+\t\t\t\t       FALSE);\n   if (second_str_cpu_units == NULL)\n     fatal (\"invalid second string `%s' in exclusion_set\", XSTR (def, 1));\n   length += first_vect_length;\n   decl = create_node (sizeof (struct decl) + (length - 1) * sizeof (char *));\n   decl->mode = dm_excl;\n   decl->pos = 0;\n-  DECL_EXCL (decl)->names_num = length;\n+  DECL_EXCL (decl)->all_names_num = length;\n   DECL_EXCL (decl)->first_list_length = first_vect_length;\n   for (i = 0; i < length; i++)\n     if (i < first_vect_length)\n@@ -1740,86 +1800,126 @@ gen_excl_set (def)\n   num_dfa_decls++;\n }\n \n-/* Process a PRESENCE_SET.  \n+/* Process a PRESENCE_SET, a FINAL_PRESENCE_SET, an ABSENCE_SET,\n+   FINAL_ABSENCE_SET (it is depended on PRESENCE_P and FINAL_P).\n \n    This gives information about a cpu unit reservation requirements.\n-   We fill a struct unit_rel_decl (presence) with information used\n-   later by `expand_automata'.  */\n-void\n-gen_presence_set (def)\n+   We fill a struct unit_pattern_rel_decl with information used later\n+   by `expand_automata'.  */\n+static void\n+gen_presence_absence_set (def, presence_p, final_p)\n      rtx def;\n+     int presence_p;\n+     int final_p;\n {\n   decl_t decl;\n-  char **first_str_cpu_units;\n-  char **second_str_cpu_units;\n-  int first_vect_length;\n+  char **str_cpu_units;\n+  char ***str_patterns;\n+  int cpu_units_length;\n   int length;\n+  int patterns_length;\n   int i;\n \n-  first_str_cpu_units\n-    = get_str_vect ((char *) XSTR (def, 0), &first_vect_length, ',', 0);\n-  if (first_str_cpu_units == NULL)\n-    fatal (\"invalid first string `%s' in presence_set\", XSTR (def, 0));\n-  second_str_cpu_units = get_str_vect ((char *) XSTR (def, 1), &length, ',',\n-\t\t\t\t       0);\n-  if (second_str_cpu_units == NULL)\n-    fatal (\"invalid second string `%s' in presence_set\", XSTR (def, 1));\n-  length += first_vect_length;\n-  decl = create_node (sizeof (struct decl) + (length - 1) * sizeof (char *));\n-  decl->mode = dm_presence;\n+  str_cpu_units = get_str_vect ((char *) XSTR (def, 0), &cpu_units_length, ',',\n+\t\t\t\tFALSE);\n+  if (str_cpu_units == NULL)\n+    fatal ((presence_p\n+\t    ? (final_p\n+\t       ? \"invalid first string `%s' in final_presence_set\"\n+\t       : \"invalid first string `%s' in presence_set\")\n+\t    : (final_p\n+\t       ? \"invalid first string `%s' in final_absence_set\"\n+\t       : \"invalid first string `%s' in absence_set\")),\n+\t   XSTR (def, 0));\n+  str_patterns = (char ***) get_str_vect ((char *) XSTR (def, 1),\n+\t\t\t\t\t  &patterns_length, ',', FALSE);\n+  if (str_patterns == NULL)\n+    fatal ((presence_p\n+\t    ? (final_p\n+\t       ? \"invalid second string `%s' in final_presence_set\"\n+\t       : \"invalid second string `%s' in presence_set\")\n+\t    : (final_p\n+\t       ? \"invalid second string `%s' in final_absence_set\"\n+\t       : \"invalid second string `%s' in absence_set\")), XSTR (def, 1));\n+  for (i = 0; i < patterns_length; i++)\n+    {\n+      str_patterns [i] = get_str_vect ((char *) str_patterns [i], &length, ' ',\n+\t\t\t\t       FALSE);\n+      if (str_patterns [i] == NULL)\n+\tabort ();\n+    }\n+  decl = create_node (sizeof (struct decl));\n   decl->pos = 0;\n-  DECL_PRESENCE (decl)->names_num = length;\n-  DECL_PRESENCE (decl)->first_list_length = first_vect_length;\n-  for (i = 0; i < length; i++)\n-    if (i < first_vect_length)\n-      DECL_PRESENCE (decl)->names [i] = first_str_cpu_units [i];\n-    else\n-      DECL_PRESENCE (decl)->names [i]\n-\t= second_str_cpu_units [i - first_vect_length];\n+  if (presence_p)\n+    {\n+      decl->mode = dm_presence;\n+      DECL_PRESENCE (decl)->names_num = cpu_units_length;\n+      DECL_PRESENCE (decl)->names = str_cpu_units;\n+      DECL_PRESENCE (decl)->patterns = str_patterns;\n+      DECL_PRESENCE (decl)->patterns_num = patterns_length;\n+      DECL_PRESENCE (decl)->final_p = final_p;\n+    }\n+  else\n+    {\n+      decl->mode = dm_absence;\n+      DECL_ABSENCE (decl)->names_num = cpu_units_length;\n+      DECL_ABSENCE (decl)->names = str_cpu_units;\n+      DECL_ABSENCE (decl)->patterns = str_patterns;\n+      DECL_ABSENCE (decl)->patterns_num = patterns_length;\n+      DECL_ABSENCE (decl)->final_p = final_p;\n+    }\n   VLA_PTR_ADD (decls, decl);\n   num_dfa_decls++;\n }\n \n-/* Process an ABSENCE_SET.  \n+/* Process a PRESENCE_SET.  \n+ \n+    This gives information about a cpu unit reservation requirements.\n+   We fill a struct unit_pattern_rel_decl (presence) with information\n+   used later by `expand_automata'.  */\n+ void\n+gen_presence_set (def)\n+      rtx def;\n+{\n+  gen_presence_absence_set (def, TRUE, FALSE);\n+}\n+ \n+/* Process a FINAL_PRESENCE_SET.  \n+\n+   This gives information about a cpu unit reservation requirements.\n+   We fill a struct unit_pattern_rel_decl (presence) with information\n+   used later by `expand_automata'.  */\n+void\n+gen_final_presence_set (def)\n+     rtx def;\n+{\n+  gen_presence_absence_set (def, TRUE, TRUE);\n+}\n+ \n+/* Process an ABSENCE_SET.\n \n    This gives information about a cpu unit reservation requirements.\n-   We fill a struct unit_rel_decl (absence) with information used\n-   later by `expand_automata'.  */\n+   We fill a struct unit_pattern_rel_decl (absence) with information\n+   used later by `expand_automata'.  */\n void\n gen_absence_set (def)\n      rtx def;\n {\n-  decl_t decl;\n-  char **first_str_cpu_units;\n-  char **second_str_cpu_units;\n-  int first_vect_length;\n-  int length;\n-  int i;\n-\n-  first_str_cpu_units\n-    = get_str_vect ((char *) XSTR (def, 0), &first_vect_length, ',', 0);\n-  if (first_str_cpu_units == NULL)\n-    fatal (\"invalid first string `%s' in absence_set\", XSTR (def, 0));\n-  second_str_cpu_units = get_str_vect ((char *) XSTR (def, 1), &length, ',',\n-\t\t\t\t       0);\n-  if (second_str_cpu_units == NULL)\n-    fatal (\"invalid second string `%s' in absence_set\", XSTR (def, 1));\n-  length += first_vect_length;\n-  decl = create_node (sizeof (struct decl) + (length - 1) * sizeof (char *));\n-  decl->mode = dm_absence;\n-  decl->pos = 0;\n-  DECL_ABSENCE (decl)->names_num = length;\n-  DECL_ABSENCE (decl)->first_list_length = first_vect_length;\n-  for (i = 0; i < length; i++)\n-    if (i < first_vect_length)\n-      DECL_ABSENCE (decl)->names [i] = first_str_cpu_units [i];\n-    else\n-      DECL_ABSENCE (decl)->names [i]\n-\t= second_str_cpu_units [i - first_vect_length];\n-  VLA_PTR_ADD (decls, decl);\n-  num_dfa_decls++;\n+  gen_presence_absence_set (def, FALSE, FALSE);\n }\n+  \n+/* Process a FINAL_ABSENCE_SET.\n \n+   This gives information about a cpu unit reservation requirements.\n+   We fill a struct unit_pattern_rel_decl (absence) with information\n+   used later by `expand_automata'.  */\n+void\n+gen_final_absence_set (def)\n+     rtx def;\n+{\n+  gen_presence_absence_set (def, FALSE, TRUE);\n+}\n+  \n /* Process a DEFINE_AUTOMATON.  \n \n    This gives information about a finite state automaton used for\n@@ -1834,7 +1934,8 @@ gen_automaton (def)\n   int vect_length;\n   int i;\n \n-  str_automata = get_str_vect ((char *) XSTR (def, 0), &vect_length, ',', 0);\n+  str_automata = get_str_vect ((char *) XSTR (def, 0), &vect_length, ',',\n+\t\t\t       FALSE);\n   if (str_automata == NULL)\n     fatal (\"invalid string `%s' in define_automaton\", XSTR (def, 0));\n   for (i = 0; i < vect_length; i++)\n@@ -1918,7 +2019,7 @@ gen_regexp_repeat (str)\n   int els_num;\n   int i;\n \n-  repeat_vect = get_str_vect (str, &els_num, '*', 1);\n+  repeat_vect = get_str_vect (str, &els_num, '*', TRUE);\n   if (repeat_vect == NULL)\n     fatal (\"invalid `%s' in reservation `%s'\", str, reserv_str);\n   if (els_num > 1)\n@@ -1951,7 +2052,7 @@ gen_regexp_allof (str)\n   int els_num;\n   int i;\n \n-  allof_vect = get_str_vect (str, &els_num, '+', 1);\n+  allof_vect = get_str_vect (str, &els_num, '+', TRUE);\n   if (allof_vect == NULL)\n     fatal (\"invalid `%s' in reservation `%s'\", str, reserv_str);\n   if (els_num > 1)\n@@ -1978,7 +2079,7 @@ gen_regexp_oneof (str)\n   int els_num;\n   int i;\n \n-  oneof_vect = get_str_vect (str, &els_num, '|', 1);\n+  oneof_vect = get_str_vect (str, &els_num, '|', TRUE);\n   if (oneof_vect == NULL)\n     fatal (\"invalid `%s' in reservation `%s'\", str, reserv_str);\n   if (els_num > 1)\n@@ -2005,7 +2106,7 @@ gen_regexp_sequence (str)\n   int els_num;\n   int i;\n \n-  sequence_vect = get_str_vect (str, &els_num, ',', 1);\n+  sequence_vect = get_str_vect (str, &els_num, ',', TRUE);\n   if (els_num > 1)\n     {\n       sequence = create_node (sizeof (struct regexp)\n@@ -2494,15 +2595,16 @@ add_excls (dest_list, source_list, excl_pos)\n     }\n }\n \n-/* Checking NAMES in a presence clause vector and returning formed\n-   unit_set_el_list.  The function is called only after processing all\n-   exclusion sets.  */\n+/* Checking NAMES in presence/absence clause and returning the\n+   formed unit_set_el_list.  The function is called only after\n+   processing all exclusion sets.  */\n static unit_set_el_t\n-process_presence_absence (names, num, req_pos, presence_p)\n+process_presence_absence_names (names, num, req_pos, presence_p, final_p)\n      char **names;\n      int num;\n      pos_t req_pos ATTRIBUTE_UNUSED;\n      int presence_p;\n+     int final_p;\n {\n   unit_set_el_t el_list;\n   unit_set_el_t last_el;\n@@ -2517,12 +2619,20 @@ process_presence_absence (names, num, req_pos, presence_p)\n       decl_in_table = find_decl (names [i]);\n       if (decl_in_table == NULL)\n \terror ((presence_p\n-\t\t? \"unit `%s' in presence set is not declared\"\n-\t\t: \"unit `%s' in absence set is not declared\"), names [i]);\n+\t\t? (final_p\n+\t\t   ? \"unit `%s' in final presence set is not declared\"\n+\t\t   : \"unit `%s' in presence set is not declared\")\n+\t\t: (final_p\n+\t\t   ? \"unit `%s' in final absence set is not declared\"\n+\t\t   : \"unit `%s' in absence set is not declared\")), names [i]);\n       else if (decl_in_table->mode != dm_unit)\n \terror ((presence_p\n-\t\t? \"`%s' in presence set is not unit\"\n-\t\t: \"`%s' in absence set is not unit\"), names [i]);\n+\t\t? (final_p\n+\t\t   ? \"`%s' in final presence set is not unit\"\n+\t\t   : \"`%s' in presence set is not unit\")\n+\t\t: (final_p\n+\t\t   ? \"`%s' in final absence set is not unit\"\n+\t\t   : \"`%s' in absence set is not unit\")), names [i]);\n       else\n \t{\n \t  new_el = create_node (sizeof (struct unit_set_el));\n@@ -2540,116 +2650,202 @@ process_presence_absence (names, num, req_pos, presence_p)\n   return el_list;\n }\n \n-/* The function adds each element from SOURCE_LIST to presence (if\n+/* Checking NAMES in patterns of a presence/absence clause and\n+   returning the formed pattern_set_el_list.  The function is called\n+   only after processing all exclusion sets.  */\n+static pattern_set_el_t\n+process_presence_absence_patterns (patterns, num, req_pos, presence_p, final_p)\n+     char ***patterns;\n+     int num;\n+     pos_t req_pos ATTRIBUTE_UNUSED;\n+     int presence_p;\n+     int final_p;\n+{\n+  pattern_set_el_t el_list;\n+  pattern_set_el_t last_el;\n+  pattern_set_el_t new_el;\n+  decl_t decl_in_table;\n+  int i, j;\n+\n+  el_list = NULL;\n+  last_el = NULL;\n+  for (i = 0; i < num; i++)\n+    {\n+      for (j = 0; patterns [i] [j] != NULL; j++)\n+\t;\n+      new_el = create_node (sizeof (struct pattern_set_el)\n+\t\t\t    + sizeof (struct unit_decl *) * j);\n+      new_el->unit_decls\n+\t= (struct unit_decl **) ((char *) new_el\n+\t\t\t\t + sizeof (struct pattern_set_el));\n+      new_el->next_pattern_set_el = NULL;\n+      if (last_el == NULL)\n+\tel_list = last_el = new_el;\n+      else\n+\t{\n+\t  last_el->next_pattern_set_el = new_el;\n+\t  last_el = last_el->next_pattern_set_el;\n+\t}\n+      new_el->units_num = 0;\n+      for (j = 0; patterns [i] [j] != NULL; j++)\n+\t{\n+\t  decl_in_table = find_decl (patterns [i] [j]);\n+\t  if (decl_in_table == NULL)\n+\t    error ((presence_p\n+\t\t    ? (final_p\n+\t\t       ? \"unit `%s' in final presence set is not declared\"\n+\t\t       : \"unit `%s' in presence set is not declared\")\n+\t\t    : (final_p\n+\t\t       ? \"unit `%s' in final absence set is not declared\"\n+\t\t       : \"unit `%s' in absence set is not declared\")),\n+\t\t   patterns [i] [j]);\n+\t  else if (decl_in_table->mode != dm_unit)\n+\t    error ((presence_p\n+\t\t    ? (final_p\n+\t\t       ? \"`%s' in final presence set is not unit\"\n+\t\t       : \"`%s' in presence set is not unit\")\n+\t\t    : (final_p\n+\t\t       ? \"`%s' in final absence set is not unit\"\n+\t\t       : \"`%s' in absence set is not unit\")),\n+\t\t   patterns [i] [j]);\n+\t  else\n+\t    {\n+\t      new_el->unit_decls [new_el->units_num]\n+\t\t= DECL_UNIT (decl_in_table);\n+\t      new_el->units_num++;\n+\t    }\n+\t}\n+    }\n+  return el_list;\n+}\n+\n+/* The function adds each element from PATTERN_LIST to presence (if\n    PRESENCE_P) or absence list of the each element from DEST_LIST.\n-   Checking situations \"unit requires own presence\", \"unit requires\n-   own absence\", and \"unit excludes and requires presence of ...\".\n-   Remember that we process absence sets only after all presence\n-   sets.  */\n-static void\n-add_presence_absence (dest_list, source_list, req_pos, presence_p)\n+   Checking situations \"unit requires own absence\", and \"unit excludes\n+   and requires presence of ...\", \"unit requires absence and presence\n+   of ...\", \"units in (final) presence set belong to different\n+   automata\", and \"units in (final) absence set belong to different\n+   automata\".  Remember that we process absence sets only after all\n+   presence sets.  */\n+static void\n+add_presence_absence (dest_list, pattern_list, req_pos, presence_p, final_p)\n      unit_set_el_t dest_list;\n-     unit_set_el_t source_list;\n+     pattern_set_el_t pattern_list;\n      pos_t req_pos ATTRIBUTE_UNUSED;\n      int presence_p;\n+     int final_p;\n {\n   unit_set_el_t dst;\n-  unit_set_el_t src;\n-  unit_set_el_t curr_el;\n-  unit_set_el_t prev_el;\n-  unit_set_el_t copy;\n+  pattern_set_el_t pat;\n+  struct unit_decl *unit;\n+  unit_set_el_t curr_excl_el;\n+  pattern_set_el_t curr_pat_el;\n+  pattern_set_el_t prev_el;\n+  pattern_set_el_t copy;\n+  int i;\n+  int no_error_flag;\n \n   for (dst = dest_list; dst != NULL; dst = dst->next_unit_set_el)\n-    for (src = source_list; src != NULL; src = src->next_unit_set_el)\n+    for (pat = pattern_list; pat != NULL; pat = pat->next_pattern_set_el)\n       {\n-\tif (dst->unit_decl == src->unit_decl)\n-\t  {\n-\t    error ((presence_p\n-\t\t    ? \"unit `%s' requires own presence\"\n-\t\t    : \"unit `%s' requires own absence\"), src->unit_decl->name);\n-\t    continue;\n-\t  }\n-\tif (dst->unit_decl->automaton_name != NULL\n-\t    && src->unit_decl->automaton_name != NULL\n-\t    && strcmp (dst->unit_decl->automaton_name,\n-\t\t       src->unit_decl->automaton_name) != 0)\n-\t  {\n-\t    error ((presence_p\n-\t\t    ? \"units `%s' and `%s' in presence set belong to different automata\"\n-\t\t    : \"units `%s' and `%s' in absence set belong to different automata\"),\n-\t\t   src->unit_decl->name, dst->unit_decl->name);\n-\t    continue;\n-\t  }\n-\tfor (curr_el = (presence_p\n-\t\t\t? dst->unit_decl->presence_list\n-\t\t\t: dst->unit_decl->absence_list), prev_el = NULL;\n-\t     curr_el != NULL;\n-\t     prev_el = curr_el, curr_el = curr_el->next_unit_set_el)\n-\t  if (curr_el->unit_decl == src->unit_decl)\n-\t    break;\n-\tif (curr_el == NULL)\n+\tfor (i = 0; i < pat->units_num; i++)\n \t  {\n-\t    /* Element not found - insert if there is no error.  */\n-\t    int no_error_flag = 1;\n-\n+\t    unit = pat->unit_decls [i];\n+\t    if (dst->unit_decl == unit && pat->units_num == 1 && !presence_p)\n+\t      {\n+\t\terror (\"unit `%s' requires own absence\", unit->name);\n+\t\tcontinue;\n+\t      }\n+\t    if (dst->unit_decl->automaton_name != NULL\n+\t\t&& unit->automaton_name != NULL\n+\t\t&& strcmp (dst->unit_decl->automaton_name,\n+\t\t\t   unit->automaton_name) != 0)\n+\t      {\n+\t\terror ((presence_p\n+\t\t\t? (final_p\n+\t\t\t   ? \"units `%s' and `%s' in final presence set belong to different automata\"\n+\t\t\t   : \"units `%s' and `%s' in presence set belong to different automata\")\n+\t\t\t: (final_p\n+\t\t\t   ? \"units `%s' and `%s' in final absence set belong to different automata\"\n+\t\t\t   : \"units `%s' and `%s' in absence set belong to different automata\")),\n+\t\t       unit->name, dst->unit_decl->name);\n+\t\tcontinue;\n+\t      }\n+\t    no_error_flag = 1;\n \t    if (presence_p)\n-\t      for (curr_el = dst->unit_decl->excl_list;\n-\t\t   curr_el != NULL;\n-\t\t   curr_el = curr_el->next_unit_set_el)\n+\t      for (curr_excl_el = dst->unit_decl->excl_list;\n+\t\t   curr_excl_el != NULL;\n+\t\t   curr_excl_el = curr_excl_el->next_unit_set_el)\n \t\t{\n-\t\t  if (src->unit_decl == curr_el->unit_decl)\n+\t\t  if (unit == curr_excl_el->unit_decl && pat->units_num == 1)\n \t\t    {\n \t\t      if (!w_flag)\n \t\t\t{\n-\t\t\t  error\n-\t\t\t    (\"unit `%s' excludes and requires presence of `%s'\",\n-\t\t\t     dst->unit_decl->name, src->unit_decl->name);\n+\t\t\t  error (\"unit `%s' excludes and requires presence of `%s'\",\n+\t\t\t\t dst->unit_decl->name, unit->name);\n \t\t\t  no_error_flag = 0;\n \t\t\t}\n \t\t      else\n \t\t\twarning\n \t\t\t  (\"unit `%s' excludes and requires presence of `%s'\",\n-\t\t\t   dst->unit_decl->name, src->unit_decl->name);\n+\t\t\t   dst->unit_decl->name, unit->name);\n \t\t    }\n \t\t}\n-\t    else\n-\t      for (curr_el = dst->unit_decl->presence_list;\n-\t\t   curr_el != NULL;\n-\t\t   curr_el = curr_el->next_unit_set_el)\n-\t\t{\n-\t\t  if (src->unit_decl == curr_el->unit_decl)\n-\t\t    {\n-\t\t      if (!w_flag)\n-\t\t\t{\n-\t\t\t  error\n-\t\t\t    (\"unit `%s' requires absence and presence of `%s'\",\n-\t\t\t     dst->unit_decl->name, src->unit_decl->name);\n-\t\t\t  no_error_flag = 0;\n-\t\t\t}\n-\t\t      else\n-\t\t\twarning\n+\t    else if (pat->units_num == 1)\n+\t      for (curr_pat_el = dst->unit_decl->presence_list;\n+\t\t   curr_pat_el != NULL;\n+\t\t   curr_pat_el = curr_pat_el->next_pattern_set_el)\n+\t\tif (curr_pat_el->units_num == 1\n+\t\t    && unit == curr_pat_el->unit_decls [0])\n+\t\t  {\n+\t\t    if (!w_flag)\n+\t\t      {\n+\t\t\terror\n \t\t\t  (\"unit `%s' requires absence and presence of `%s'\",\n-\t\t\t   dst->unit_decl->name, src->unit_decl->name);\n-\t\t    }\n-\t\t}\n+\t\t\t   dst->unit_decl->name, unit->name);\n+\t\t\tno_error_flag = 0;\n+\t\t      }\n+\t\t    else\n+\t\t      warning\n+\t\t\t(\"unit `%s' requires absence and presence of `%s'\",\n+\t\t\t dst->unit_decl->name, unit->name);\n+\t\t  }\n \t    if (no_error_flag)\n \t      {\n-\t\tcopy = copy_node (src, sizeof (*src));\n-\t\tcopy->next_unit_set_el = NULL;\n+\t\tfor (prev_el = (presence_p\n+\t\t\t\t? (final_p\n+\t\t\t\t   ? dst->unit_decl->final_presence_list\n+\t\t\t\t   : dst->unit_decl->final_presence_list)\n+\t\t\t\t: (final_p\n+\t\t\t\t   ? dst->unit_decl->final_absence_list\n+\t\t\t\t   : dst->unit_decl->absence_list));\n+\t\t     prev_el != NULL && prev_el->next_pattern_set_el != NULL;\n+\t\t     prev_el = prev_el->next_pattern_set_el)\n+\t\t  ;\n+\t\tcopy = copy_node (pat, sizeof (*pat));\n+\t\tcopy->next_pattern_set_el = NULL;\n \t\tif (prev_el == NULL)\n \t\t  {\n \t\t    if (presence_p)\n-\t\t      dst->unit_decl->presence_list = copy;\n+\t\t      {\n+\t\t\tif (final_p)\n+\t\t\t  dst->unit_decl->final_presence_list = copy;\n+\t\t\telse\n+\t\t\t  dst->unit_decl->presence_list = copy;\n+\t\t      }\n+\t\t    else if (final_p)\n+\t\t      dst->unit_decl->final_absence_list = copy;\n \t\t    else\n \t\t      dst->unit_decl->absence_list = copy;\n \t\t  }\n \t\telse\n-\t\t  prev_el->next_unit_set_el = copy;\n+\t\t  prev_el->next_pattern_set_el = copy;\n \t      }\n-\t}\n-    }\n+\t  }\n+      }\n }\n \n+\n /* The function searches for bypass with given IN_INSN_RESERV in given\n    BYPASS_LIST.  */\n static struct bypass_decl *\n@@ -2849,7 +3045,7 @@ process_decls ()\n \t  unit_set_el_list_2\n \t    = process_excls (&DECL_EXCL (decl)->names\n \t\t\t     [DECL_EXCL (decl)->first_list_length],\n-                             DECL_EXCL (decl)->names_num\n+                             DECL_EXCL (decl)->all_names_num\n                              - DECL_EXCL (decl)->first_list_length,\n                              decl->pos);\n \t  add_excls (unit_set_el_list, unit_set_el_list_2, decl->pos);\n@@ -2864,21 +3060,20 @@ process_decls ()\n       if (decl->mode == dm_presence)\n \t{\n \t  unit_set_el_t unit_set_el_list;\n-\t  unit_set_el_t unit_set_el_list_2;\n+\t  pattern_set_el_t pattern_set_el_list;\n \t  \n \t  unit_set_el_list\n-            = process_presence_absence\n-\t      (DECL_PRESENCE (decl)->names,\n-\t       DECL_PRESENCE (decl)->first_list_length, decl->pos, 1);\n-\t  unit_set_el_list_2\n-\t    = process_presence_absence\n-\t      (&DECL_PRESENCE (decl)->names\n-\t       [DECL_PRESENCE (decl)->first_list_length],\n-\t       DECL_PRESENCE (decl)->names_num\n-\t       - DECL_PRESENCE (decl)->first_list_length,\n-\t       decl->pos, 1);\n-\t  add_presence_absence (unit_set_el_list, unit_set_el_list_2,\n-\t\t\t\tdecl->pos, 1);\n+            = process_presence_absence_names\n+\t      (DECL_PRESENCE (decl)->names, DECL_PRESENCE (decl)->names_num,\n+\t       decl->pos, TRUE, DECL_PRESENCE (decl)->final_p);\n+\t  pattern_set_el_list\n+\t    = process_presence_absence_patterns\n+\t      (DECL_PRESENCE (decl)->patterns,\n+\t       DECL_PRESENCE (decl)->patterns_num,\n+\t       decl->pos, TRUE, DECL_PRESENCE (decl)->final_p);\n+\t  add_presence_absence (unit_set_el_list, pattern_set_el_list,\n+\t\t\t\tdecl->pos, TRUE,\n+\t\t\t\tDECL_PRESENCE (decl)->final_p);\n \t}\n     }\n \n@@ -2889,21 +3084,20 @@ process_decls ()\n       if (decl->mode == dm_absence)\n \t{\n \t  unit_set_el_t unit_set_el_list;\n-\t  unit_set_el_t unit_set_el_list_2;\n+\t  pattern_set_el_t pattern_set_el_list;\n \t  \n \t  unit_set_el_list\n-            = process_presence_absence\n-\t      (DECL_ABSENCE (decl)->names,\n-\t       DECL_ABSENCE (decl)->first_list_length, decl->pos, 0);\n-\t  unit_set_el_list_2\n-\t    = process_presence_absence\n-\t      (&DECL_ABSENCE (decl)->names\n-\t       [DECL_ABSENCE (decl)->first_list_length],\n-\t       DECL_ABSENCE (decl)->names_num\n-\t       - DECL_ABSENCE (decl)->first_list_length,\n-\t       decl->pos, 0);\n-\t  add_presence_absence (unit_set_el_list, unit_set_el_list_2,\n-\t\t\t\tdecl->pos, 0);\n+            = process_presence_absence_names\n+\t      (DECL_ABSENCE (decl)->names, DECL_ABSENCE (decl)->names_num,\n+\t       decl->pos, FALSE, DECL_ABSENCE (decl)->final_p);\n+\t  pattern_set_el_list\n+\t    = process_presence_absence_patterns\n+\t      (DECL_ABSENCE (decl)->patterns,\n+\t       DECL_ABSENCE (decl)->patterns_num,\n+\t       decl->pos, FALSE, DECL_ABSENCE (decl)->final_p);\n+\t  add_presence_absence (unit_set_el_list, pattern_set_el_list,\n+\t\t\t\tdecl->pos, FALSE,\n+\t\t\t\tDECL_ABSENCE (decl)->final_p);\n \t}\n     }\n }\n@@ -3141,72 +3335,94 @@ check_loops_in_regexps ()\n }\n \n /* The function recursively processes IR of reservation and defines\n-   max and min cycle for reservation of unit and for result in the\n-   reservation.  */\n-static int\n-process_regexp_cycles (regexp, start_cycle)\n+   max and min cycle for reservation of unit.  */\n+static void\n+process_regexp_cycles (regexp, max_start_cycle, min_start_cycle,\n+\t\t       max_finish_cycle, min_finish_cycle)\n      regexp_t regexp;\n-     int start_cycle;\n+     int max_start_cycle, min_start_cycle;\n+     int *max_finish_cycle, *min_finish_cycle;\n {\n   int i;\n \n   if (regexp->mode == rm_unit)\n     {\n-      if (REGEXP_UNIT (regexp)->unit_decl->max_occ_cycle_num < start_cycle)\n-\tREGEXP_UNIT (regexp)->unit_decl->max_occ_cycle_num = start_cycle;\n-      return start_cycle;\n+      if (REGEXP_UNIT (regexp)->unit_decl->max_occ_cycle_num < max_start_cycle)\n+\tREGEXP_UNIT (regexp)->unit_decl->max_occ_cycle_num = max_start_cycle;\n+      if (REGEXP_UNIT (regexp)->unit_decl->min_occ_cycle_num > min_start_cycle\n+\t  || REGEXP_UNIT (regexp)->unit_decl->min_occ_cycle_num == -1)\n+\tREGEXP_UNIT (regexp)->unit_decl->min_occ_cycle_num = min_start_cycle;\n+      *max_finish_cycle = max_start_cycle;\n+      *min_finish_cycle = min_start_cycle;\n     }\n   else if (regexp->mode == rm_reserv)\n-    return process_regexp_cycles (REGEXP_RESERV (regexp)->reserv_decl->regexp,\n-                                  start_cycle);\n+   process_regexp_cycles (REGEXP_RESERV (regexp)->reserv_decl->regexp,\n+\t\t\t  max_start_cycle, min_start_cycle,\n+\t\t\t  max_finish_cycle, min_finish_cycle);\n   else if (regexp->mode == rm_repeat)\n     {\n       for (i = 0; i < REGEXP_REPEAT (regexp)->repeat_num; i++)\n-        start_cycle = process_regexp_cycles (REGEXP_REPEAT (regexp)->regexp,\n-\t\t\t\t\t     start_cycle) + 1;\n-      return start_cycle;\n+\t{\n+\t  process_regexp_cycles (REGEXP_REPEAT (regexp)->regexp,\n+\t\t\t\t max_start_cycle, min_start_cycle,\n+\t\t\t\t max_finish_cycle, min_finish_cycle);\n+\t  max_start_cycle = *max_finish_cycle + 1;\n+\t  min_start_cycle = *min_finish_cycle + 1;\n+\t}\n     }\n   else if (regexp->mode == rm_sequence)\n     {\n       for (i = 0; i <REGEXP_SEQUENCE (regexp)->regexps_num; i++)\n-\tstart_cycle\n-          = process_regexp_cycles (REGEXP_SEQUENCE (regexp)->regexps [i],\n-\t\t\t\t   start_cycle) + 1;\n-      return start_cycle;\n+\t{\n+\t  process_regexp_cycles (REGEXP_SEQUENCE (regexp)->regexps [i],\n+\t\t\t\t max_start_cycle, min_start_cycle,\n+\t\t\t\t max_finish_cycle, min_finish_cycle);\n+\t  max_start_cycle = *max_finish_cycle + 1;\n+\t  min_start_cycle = *min_finish_cycle + 1;\n+\t}\n     }\n   else if (regexp->mode == rm_allof)\n     {\n-      int finish_cycle = 0;\n-      int cycle;\n+      int max_cycle = 0;\n+      int min_cycle = 0;\n \n       for (i = 0; i < REGEXP_ALLOF (regexp)->regexps_num; i++)\n \t{\n-\t  cycle = process_regexp_cycles (REGEXP_ALLOF (regexp)->regexps [i],\n-\t\t\t\t\t start_cycle);\n-\t  if (finish_cycle < cycle)\n-\t    finish_cycle = cycle;\n+\t  process_regexp_cycles (REGEXP_ALLOF (regexp)->regexps [i],\n+\t\t\t\t max_start_cycle, min_start_cycle,\n+\t\t\t\t max_finish_cycle, min_finish_cycle);\n+\t  if (max_cycle < *max_finish_cycle)\n+\t    max_cycle = *max_finish_cycle;\n+\t  if (i == 0 || min_cycle > *min_finish_cycle)\n+\t    min_cycle = *min_finish_cycle;\n \t}\n-      return finish_cycle;\n+      *max_finish_cycle = max_cycle;\n+      *min_finish_cycle = min_cycle;\n     }\n   else if (regexp->mode == rm_oneof)\n     {\n-      int finish_cycle = 0;\n-      int cycle;\n+      int max_cycle = 0;\n+      int min_cycle = 0;\n \n       for (i = 0; i < REGEXP_ONEOF (regexp)->regexps_num; i++)\n \t{\n-\t  cycle = process_regexp_cycles (REGEXP_ONEOF (regexp)->regexps [i],\n-\t\t\t\t\t start_cycle);\n-\t  if (finish_cycle < cycle)\n-\t    finish_cycle = cycle;\n+\t  process_regexp_cycles (REGEXP_ONEOF (regexp)->regexps [i],\n+\t\t\t\t max_start_cycle, min_start_cycle,\n+\t\t\t\t max_finish_cycle, min_finish_cycle);\n+\t  if (max_cycle < *max_finish_cycle)\n+\t    max_cycle = *max_finish_cycle;\n+\t  if (i == 0 || min_cycle > *min_finish_cycle)\n+\t    min_cycle = *min_finish_cycle;\n \t}\n-      return finish_cycle;\n+      *max_finish_cycle = max_cycle;\n+      *min_finish_cycle = min_cycle;\n     }\n   else\n     {\n       if (regexp->mode != rm_nothing)\n \tabort ();\n-      return start_cycle;\n+      *max_finish_cycle = max_start_cycle;\n+      *min_finish_cycle = min_start_cycle;\n     }\n }\n \n@@ -3216,6 +3432,7 @@ static void\n evaluate_max_reserv_cycles ()\n {\n   int max_insn_cycles_num;\n+  int min_insn_cycles_num;\n   decl_t decl;\n   int i;\n \n@@ -3225,8 +3442,8 @@ evaluate_max_reserv_cycles ()\n       decl = description->decls [i];\n       if (decl->mode == dm_insn_reserv)\n       {\n-        max_insn_cycles_num\n-          = process_regexp_cycles (DECL_INSN_RESERV (decl)->regexp, 0);\n+        process_regexp_cycles (DECL_INSN_RESERV (decl)->regexp, 0, 0,\n+\t\t\t       &max_insn_cycles_num, &min_insn_cycles_num);\n         if (description->max_insn_reserv_cycles < max_insn_cycles_num)\n \t  description->max_insn_reserv_cycles = max_insn_cycles_num;\n       }\n@@ -3553,6 +3770,9 @@ finish_alt_states ()\n #define SET_BIT(bitstring, bitno)\t\t\t\t\t  \\\n   (((char *) (bitstring)) [(bitno) / CHAR_BIT] |= 1 << (bitno) % CHAR_BIT)\n \n+#define CLEAR_BIT(bitstring, bitno)\t\t\t\t\t  \\\n+  (((char *) (bitstring)) [(bitno) / CHAR_BIT] &= ~(1 << (bitno) % CHAR_BIT))\n+\n /* Test if bit number bitno in the bitstring is set.  The macro is not\n    side effect proof.  */\n #define TEST_BIT(bitstring, bitno)                                        \\\n@@ -3583,6 +3803,9 @@ static vla_ptr_t units_container;\n /* The start address of the array.  */\n static unit_decl_t *units_array;\n \n+/* Temporary reservation of maximal length.  */\n+static reserv_sets_t temp_reserv;\n+\n /* The state table itself is represented by the following variable.  */\n static htab_t state_table;\n \n@@ -3743,7 +3966,6 @@ reserv_sets_are_intersected (operand_1, operand_2)\n   set_el_t *el_ptr_2;\n   set_el_t *cycle_ptr_1;\n   set_el_t *cycle_ptr_2;\n-  int nonzero_p;\n \n   if (operand_1 == NULL || operand_2 == NULL)\n     abort ();\n@@ -3752,6 +3974,7 @@ reserv_sets_are_intersected (operand_1, operand_2)\n        el_ptr_1++, el_ptr_2++)\n     if (*el_ptr_1 & *el_ptr_2)\n       return 1;\n+  reserv_sets_or (temp_reserv, operand_1, operand_2);\n   for (cycle_ptr_1 = operand_1, cycle_ptr_2 = operand_2;\n        cycle_ptr_1 < operand_1 + els_in_reservs;\n        cycle_ptr_1 += els_in_cycle_reserv, cycle_ptr_2 += els_in_cycle_reserv)\n@@ -3761,25 +3984,17 @@ reserv_sets_are_intersected (operand_1, operand_2)\n \t   el_ptr_1++, el_ptr_2++)\n \tif (*el_ptr_1 & *el_ptr_2)\n \t  return 1;\n-      nonzero_p = 0;\n-      for (el_ptr_1 = cycle_ptr_1,\n-\t     el_ptr_2 = get_presence_absence_set (cycle_ptr_2, 1);\n-\t   el_ptr_1 < cycle_ptr_1 + els_in_cycle_reserv;\n-\t   el_ptr_1++, el_ptr_2++)\n-\tif (*el_ptr_1 & *el_ptr_2)\n-\t  break;\n-\telse if (*el_ptr_2 != 0)\n-\t  nonzero_p = 1;\n-      if (nonzero_p && el_ptr_1 >= cycle_ptr_1 + els_in_cycle_reserv)\n+      if (!check_presence_pattern_sets (cycle_ptr_1, cycle_ptr_2, FALSE))\n+\treturn 1;\n+      if (!check_presence_pattern_sets (temp_reserv + (cycle_ptr_2\n+\t\t\t\t\t\t       - operand_2),\n+\t\t\t\t\tcycle_ptr_2, TRUE))\n+\treturn 1;\n+      if (!check_absence_pattern_sets (cycle_ptr_1, cycle_ptr_2, FALSE))\n+\treturn 1;\n+      if (!check_absence_pattern_sets (temp_reserv + (cycle_ptr_2 - operand_2),\n+\t\t\t\t       cycle_ptr_2, TRUE))\n \treturn 1;\n-      for (el_ptr_1 = cycle_ptr_1,\n-\t     el_ptr_2 = get_presence_absence_set (cycle_ptr_2, 0);\n-\t   el_ptr_1 < cycle_ptr_1 + els_in_cycle_reserv;\n-\t   el_ptr_1++, el_ptr_2++)\n-\t/* It looks like code for exclusion but exclusion set is\n-           made as symmetric relation preliminary.  */\n-\tif (*el_ptr_1 & *el_ptr_2)\n-\t  return 1;\n     }\n   return 0;\n }\n@@ -3876,7 +4091,7 @@ output_cycle_reservs (f, reservs, start_cycle, repetition_num)\n     fprintf (f, NOTHING_NAME);\n   if (repetition_num <= 0)\n     abort ();\n-  if (reserved_units_num > 1)\n+  if (repetition_num != 1 && reserved_units_num > 1)\n     fprintf (f, \")\");\n   if (repetition_num != 1)\n     fprintf (f, \"*%d\", repetition_num);\n@@ -4076,12 +4291,13 @@ intersected_state_reservs_p (state1, state2)\n }\n \n /* Return deterministic state (inserted into the table) which\n-   representing the automaton state whic is union of reservations of\n-   deterministic states.  */\n+   representing the automaton state which is union of reservations of\n+   the deterministic states masked by RESERVS.  */\n static state_t\n-states_union (state1, state2)\n+states_union (state1, state2, reservs)\n      state_t state1;\n      state_t state2;\n+     reserv_sets_t reservs;\n {\n   state_t result;\n   state_t state_in_table;\n@@ -4090,6 +4306,7 @@ states_union (state1, state2)\n     abort ();\n   result = get_free_state (1, state1->automaton);\n   reserv_sets_or (result->reservs, state1->reservs, state2->reservs);\n+  reserv_sets_and (result->reservs, result->reservs, reservs);\n   state_in_table = insert_state (result);\n   if (result != state_in_table)\n     {\n@@ -4101,16 +4318,18 @@ states_union (state1, state2)\n \n /* Return deterministic state (inserted into the table) which\n    represent the automaton state is obtained from deterministic STATE\n-   by advancing cpu cycle.  */\n+   by advancing cpu cycle and masking by RESERVS.  */\n static state_t\n-state_shift (state)\n+state_shift (state, reservs)\n      state_t state;\n+     reserv_sets_t reservs;\n {\n   state_t result;\n   state_t state_in_table;\n \n   result = get_free_state (1, state->automaton);\n   reserv_sets_shift (result->reservs, state->reservs);\n+  reserv_sets_and (result->reservs, result->reservs, reservs);\n   state_in_table = insert_state (result);\n   if (result != state_in_table)\n     {\n@@ -4146,7 +4365,7 @@ initiate_states ()\n   initiate_alt_states ();\n   VLA_PTR_CREATE (free_states, 1500, \"free states\");\n   state_table = htab_create (1500, state_hash, state_eq_p, (htab_del) 0);\n-  alloc_empty_reserv_sets ();\n+  temp_reserv = alloc_empty_reserv_sets ();\n }\n \n /* Finishing work with the abstract data.  */\n@@ -4488,7 +4707,10 @@ initiate_excl_sets ()\n \t  for (el = DECL_UNIT (decl)->excl_list;\n \t       el != NULL;\n \t       el = el->next_unit_set_el)\n-            SET_BIT (unit_excl_set, el->unit_decl->unit_num);\n+\t    {\n+\t      SET_BIT (unit_excl_set, el->unit_decl->unit_num);\n+\t      el->unit_decl->in_set_p = TRUE;\n+\t    }\n           unit_excl_set_table [DECL_UNIT (decl)->unit_num] = unit_excl_set;\n         }\n     }\n@@ -4527,105 +4749,173 @@ get_excl_set (in_set)\n \n \f\n \n-/* The page contains abstract data for work with presence/absence sets\n-   (see presence_set/absence_set in file rtl.def).  */\n+/* The page contains abstract data for work with presence/absence\n+   pattern sets (see presence_set/absence_set in file rtl.def).  */\n \n-/* The following variables refer to correspondingly a presence and an\n-   absence set returned by get_presence_absence_set.  This is bit\n-   string of length equal to cpu units number.  */\n-static reserv_sets_t presence_set, absence_set;\n+/* The following arrays contain correspondingly presence, final\n+   presence, absence, and final absence patterns for each unit.  */\n+static pattern_reserv_t *unit_presence_set_table;\n+static pattern_reserv_t *unit_final_presence_set_table;\n+static pattern_reserv_t *unit_absence_set_table;\n+static pattern_reserv_t *unit_final_absence_set_table;\n+\n+/* The following function forms list of reservation sets for given\n+   PATTERN_LIST.  */\n+static pattern_reserv_t\n+form_reserv_sets_list (pattern_list)\n+     pattern_set_el_t pattern_list;\n+{\n+  pattern_set_el_t el;\n+  pattern_reserv_t first, curr, prev;\n+  int i;\n \n-/* The following arrays contain correspondingly presence and absence\n-   sets for each unit.  */\n-static reserv_sets_t *unit_presence_set_table, *unit_absence_set_table;\n+  prev = first = NULL;\n+  for (el = pattern_list; el != NULL; el = el->next_pattern_set_el)\n+    {\n+      curr = create_node (sizeof (struct pattern_reserv));\n+      curr->reserv = alloc_empty_reserv_sets ();\n+      curr->next_pattern_reserv = NULL;\n+      for (i = 0; i < el->units_num; i++)\n+\t{\n+\t  SET_BIT (curr->reserv, el->unit_decls [i]->unit_num);\n+\t  el->unit_decls [i]->in_set_p = TRUE;\n+\t}\n+      if (prev != NULL)\n+\tprev->next_pattern_reserv = curr;\n+      else\n+\tfirst = curr;\n+      prev = curr;\n+    }\n+  return first;\n+}\n \n-/* The following function forms the array containing presence and\n-   absence sets for each unit */\n+ /* The following function forms the array containing presence and\n+   absence pattern sets for each unit.  */\n static void\n-initiate_presence_absence_sets ()\n+initiate_presence_absence_pattern_sets ()\n {\n   decl_t decl;\n-  reserv_sets_t unit_set;\n-  unit_set_el_t el;\n   int i;\n \n-  obstack_blank (&irp, els_in_cycle_reserv * sizeof (set_el_t));\n-  presence_set = (reserv_sets_t) obstack_base (&irp);\n+  obstack_blank (&irp, description->units_num * sizeof (pattern_reserv_t));\n+  unit_presence_set_table = (pattern_reserv_t *) obstack_base (&irp);\n   obstack_finish (&irp);\n-  obstack_blank (&irp, description->units_num * sizeof (reserv_sets_t));\n-  unit_presence_set_table = (reserv_sets_t *) obstack_base (&irp);\n+  obstack_blank (&irp, description->units_num * sizeof (pattern_reserv_t));\n+  unit_final_presence_set_table = (pattern_reserv_t *) obstack_base (&irp);\n   obstack_finish (&irp);\n-  obstack_blank (&irp, els_in_cycle_reserv * sizeof (set_el_t));\n-  absence_set = (reserv_sets_t) obstack_base (&irp);\n+  obstack_blank (&irp, description->units_num * sizeof (pattern_reserv_t));\n+  unit_absence_set_table = (pattern_reserv_t *) obstack_base (&irp);\n   obstack_finish (&irp);\n-  obstack_blank (&irp, description->units_num * sizeof (reserv_sets_t));\n-  unit_absence_set_table = (reserv_sets_t *) obstack_base (&irp);\n+  obstack_blank (&irp, description->units_num * sizeof (pattern_reserv_t));\n+  unit_final_absence_set_table = (pattern_reserv_t *) obstack_base (&irp);\n   obstack_finish (&irp);\n   /* Evaluate unit presence/absence sets.  */\n   for (i = 0; i < description->decls_num; i++)\n     {\n       decl = description->decls [i];\n       if (decl->mode == dm_unit)\n \t{\n-\t  obstack_blank (&irp, els_in_cycle_reserv * sizeof (set_el_t));\n-\t  unit_set = (reserv_sets_t) obstack_base (&irp);\n-\t  obstack_finish (&irp);\n-\t  memset (unit_set, 0, els_in_cycle_reserv * sizeof (set_el_t));\n-\t  for (el = DECL_UNIT (decl)->presence_list;\n-\t       el != NULL;\n-\t       el = el->next_unit_set_el)\n-            SET_BIT (unit_set, el->unit_decl->unit_num);\n-          unit_presence_set_table [DECL_UNIT (decl)->unit_num] = unit_set;\n-\n-\t  obstack_blank (&irp, els_in_cycle_reserv * sizeof (set_el_t));\n-\t  unit_set = (reserv_sets_t) obstack_base (&irp);\n-\t  obstack_finish (&irp);\n-\t  memset (unit_set, 0, els_in_cycle_reserv * sizeof (set_el_t));\n-\t  for (el = DECL_UNIT (decl)->absence_list;\n-\t       el != NULL;\n-\t       el = el->next_unit_set_el)\n-            SET_BIT (unit_set, el->unit_decl->unit_num);\n-          unit_absence_set_table [DECL_UNIT (decl)->unit_num] = unit_set;\n+          unit_presence_set_table [DECL_UNIT (decl)->unit_num]\n+\t    = form_reserv_sets_list (DECL_UNIT (decl)->presence_list);\n+          unit_final_presence_set_table [DECL_UNIT (decl)->unit_num]\n+\t    = form_reserv_sets_list (DECL_UNIT (decl)->final_presence_list);\n+          unit_absence_set_table [DECL_UNIT (decl)->unit_num]\n+\t    = form_reserv_sets_list (DECL_UNIT (decl)->absence_list);\n+          unit_final_absence_set_table [DECL_UNIT (decl)->unit_num]\n+\t    = form_reserv_sets_list (DECL_UNIT (decl)->final_absence_list);\n         }\n     }\n }\n \n-/* The function sets up and return PRESENCE_SET (if PRESENCE_P) or\n-   ABSENCE_SET which is union of corresponding sets for each unit in\n-   IN_SET.  */\n-static reserv_sets_t\n-get_presence_absence_set (in_set, presence_p)\n-     reserv_sets_t in_set;\n-     int presence_p;\n+/* The function checks that CHECKED_SET satisfies all presence pattern\n+   sets for units in ORIGIONAL_SET.  The function returns TRUE if it\n+   is ok.  */\n+static int\n+check_presence_pattern_sets (checked_set, origional_set, final_p)\n+     reserv_sets_t checked_set, origional_set;\n+     int final_p;\n {\n   int char_num;\n   int chars_num;\n   int i;\n   int start_unit_num;\n   int unit_num;\n+  int presence_p;\n+  pattern_reserv_t pat_reserv;\n+  \n+  chars_num = els_in_cycle_reserv * sizeof (set_el_t);\n+  for (char_num = 0; char_num < chars_num; char_num++)\n+    if (((unsigned char *) origional_set) [char_num])\n+      for (i = CHAR_BIT - 1; i >= 0; i--)\n+\tif ((((unsigned char *) origional_set) [char_num] >> i) & 1)\n+\t  {\n+\t    start_unit_num = char_num * CHAR_BIT + i;\n+\t    if (start_unit_num >= description->units_num)\n+\t      break;\n+\t    if ((final_p\n+\t\t && unit_final_presence_set_table [start_unit_num] == NULL)\n+\t\t|| (!final_p\n+\t\t    && unit_presence_set_table [start_unit_num] == NULL))\n+\t      continue;\n+\t    presence_p = FALSE;\n+\t    for (pat_reserv = (final_p\n+\t\t\t       ? unit_final_presence_set_table [start_unit_num]\n+\t\t\t       : unit_presence_set_table [start_unit_num]);\n+\t\t pat_reserv != NULL;\n+\t\t pat_reserv = pat_reserv->next_pattern_reserv)\n+\t      {\n+\t\tfor (unit_num = 0; unit_num < els_in_cycle_reserv; unit_num++)\n+\t\t  if ((checked_set [unit_num] & pat_reserv->reserv [unit_num])\n+\t\t      != pat_reserv->reserv [unit_num])\n+\t\t    break;\n+\t\tpresence_p = presence_p || unit_num >= els_in_cycle_reserv;\n+\t      }\n+\t    if (!presence_p)\n+\t      return FALSE;\n+\t  }\n+  return TRUE;\n+}\n \n+/* The function checks that CHECKED_SET satisfies all absence pattern\n+   sets for units in ORIGIONAL_SET.  The function returns TRUE if it\n+   is ok.  */\n+static int\n+check_absence_pattern_sets (checked_set, origional_set, final_p)\n+     reserv_sets_t checked_set, origional_set;\n+     int final_p;\n+{\n+  int char_num;\n+  int chars_num;\n+  int i;\n+  int start_unit_num;\n+  int unit_num;\n+  pattern_reserv_t pat_reserv;\n+  \n   chars_num = els_in_cycle_reserv * sizeof (set_el_t);\n-  if (presence_p)\n-    memset (presence_set, 0, chars_num);\n-  else\n-    memset (absence_set, 0, chars_num);\n   for (char_num = 0; char_num < chars_num; char_num++)\n-    if (((unsigned char *) in_set) [char_num])\n+    if (((unsigned char *) origional_set) [char_num])\n       for (i = CHAR_BIT - 1; i >= 0; i--)\n-\tif ((((unsigned char *) in_set) [char_num] >> i) & 1)\n+\tif ((((unsigned char *) origional_set) [char_num] >> i) & 1)\n \t  {\n \t    start_unit_num = char_num * CHAR_BIT + i;\n \t    if (start_unit_num >= description->units_num)\n-\t      return (presence_p ? presence_set : absence_set);\n-\t    for (unit_num = 0; unit_num < els_in_cycle_reserv; unit_num++)\n-\t      if (presence_p)\n-\t\tpresence_set [unit_num]\n-\t\t  |= unit_presence_set_table [start_unit_num] [unit_num];\n-\t      else\n-\t\tabsence_set [unit_num]\n-\t\t  |= unit_absence_set_table [start_unit_num] [unit_num];\n+\t      break;\n+\t    for (pat_reserv = (final_p\n+\t\t\t       ? unit_final_absence_set_table [start_unit_num]\n+\t\t\t       : unit_absence_set_table [start_unit_num]);\n+\t\t pat_reserv != NULL;\n+\t\t pat_reserv = pat_reserv->next_pattern_reserv)\n+\t      {\n+\t\tfor (unit_num = 0; unit_num < els_in_cycle_reserv; unit_num++)\n+\t\t  if ((checked_set [unit_num] & pat_reserv->reserv [unit_num])\n+\t\t      != pat_reserv->reserv [unit_num]\n+\t\t      && pat_reserv->reserv [unit_num])\n+\t\t    break;\n+\t\tif (unit_num >= els_in_cycle_reserv)\n+\t\t  return FALSE;\n+\t      }\n \t  }\n-  return (presence_p ? presence_set : absence_set);\n+  return TRUE;\n }\n \n \f\n@@ -4932,10 +5222,13 @@ transform_3 (regexp)\n     }\n   else if (regexp->mode == rm_allof)\n     {\n-      regexp_t oneof = NULL, seq;\n-      int oneof_index = 0, max_seq_length, allof_length;\n+      regexp_t oneof = NULL;\n+      regexp_t seq;\n+      int oneof_index = 0;\n+      int max_seq_length, allof_length;\n       regexp_t result;\n-      regexp_t allof = NULL, allof_op = NULL;\n+      regexp_t allof = NULL;\n+      regexp_t allof_op = NULL;\n       int i, j;\n \n       for (i = 0; i < REGEXP_ALLOF (regexp)->regexps_num; i++)\n@@ -4982,19 +5275,18 @@ transform_3 (regexp)\n       max_seq_length = 0;\n       if (regexp->mode == rm_allof)\n \tfor (i = 0; i < REGEXP_ALLOF (regexp)->regexps_num; i++)\n-\t  {\n-\t    if (REGEXP_ALLOF (regexp)->regexps [i]->mode == rm_sequence)\n-\t      {\n-\t\tseq = REGEXP_ALLOF (regexp)->regexps [i];\n-\t\tif (max_seq_length < REGEXP_SEQUENCE (seq)->regexps_num)\n-\t\t  max_seq_length = REGEXP_SEQUENCE (seq)->regexps_num;\n-\t      }\n-\t    else if (REGEXP_ALLOF (regexp)->regexps [i]->mode != rm_unit)\n-\t      {\n-\t\tmax_seq_length = 0;\n-\t\tbreak;\n-\t      }\n-\t  }\n+\t  if (REGEXP_ALLOF (regexp)->regexps [i]->mode == rm_sequence)\n+\t    {\n+\t      seq = REGEXP_ALLOF (regexp)->regexps [i];\n+\t      if (max_seq_length < REGEXP_SEQUENCE (seq)->regexps_num)\n+\t\tmax_seq_length = REGEXP_SEQUENCE (seq)->regexps_num;\n+\t    }\n+\t  else if (REGEXP_ALLOF (regexp)->regexps [i]->mode != rm_unit\n+\t\t   && REGEXP_ALLOF (regexp)->regexps [i]->mode != rm_nothing)\n+\t    {\n+\t      max_seq_length = 0;\n+\t      break;\n+\t    }\n       if (max_seq_length != 0)\n \t{\n \t  if (max_seq_length == 1 || REGEXP_ALLOF (regexp)->regexps_num <= 1)\n@@ -5019,7 +5311,9 @@ transform_3 (regexp)\n \t\t  }\n \t\telse if (i == 0\n \t\t\t && (REGEXP_ALLOF (regexp)->regexps [j]->mode\n-\t\t\t     == rm_unit))\n+\t\t\t     == rm_unit\n+\t\t\t     || (REGEXP_ALLOF (regexp)->regexps [j]->mode\n+\t\t\t\t == rm_nothing)))\n \t\t  {\n \t\t    allof_op = REGEXP_ALLOF (regexp)->regexps [j];\n \t\t    allof_length++;\n@@ -5051,7 +5345,9 @@ transform_3 (regexp)\n \t\t      }\n \t\t    else if (i == 0\n \t\t\t     && (REGEXP_ALLOF (regexp)->regexps [j]->mode\n-\t\t\t\t == rm_unit))\n+\t\t\t\t == rm_unit\n+\t\t\t\t || (REGEXP_ALLOF (regexp)->regexps [j]->mode\n+\t\t\t\t     == rm_nothing)))\n \t\t      {\n \t\t\tallof_op = REGEXP_ALLOF (regexp)->regexps [j];\n \t\t\tREGEXP_ALLOF (allof)->regexps [allof_length]\n@@ -5140,24 +5436,25 @@ transform_insn_regexps ()\n \n \f\n \n-/* The following variable is an array indexed by cycle.  Each element\n-   contains cyclic list of units which should be in the same cycle.  */\n-static unit_decl_t *the_same_automaton_lists;\n+/* The following variable value is TRUE if the first annotated message\n+   about units to automata distribution has been output.  */\n+static int annotation_message_reported_p;\n \n /* The function processes all alternative reservations on CYCLE in\n-   given REGEXP to check the UNIT is not reserved on the all\n-   alternatives.  If it is true, the unit should be in the same\n-   automaton with other analogous units reserved on CYCLE in given\n-   REGEXP.  */\n+   given REGEXP of insn reservation with INSN_RESERV_NAME to check the\n+   UNIT (or another unit from the same automaton) is not reserved on\n+   the all alternatives.  If it is true, the function outputs message\n+   about the rule violation.  */\n static void\n-process_unit_to_form_the_same_automaton_unit_lists (unit, regexp, cycle)\n+check_unit_distribution_in_reserv (insn_reserv_name, unit, regexp, cycle)\n+     const char *insn_reserv_name;\n      regexp_t unit;\n      regexp_t regexp;\n      int cycle;\n {\n   int i, k;\n   regexp_t seq, allof;\n-  unit_decl_t unit_decl, last;\n+  unit_decl_t unit_decl;\n \n   if (regexp == NULL || regexp->mode != rm_oneof)\n     abort ();\n@@ -5168,73 +5465,67 @@ process_unit_to_form_the_same_automaton_unit_lists (unit, regexp, cycle)\n       if (seq->mode == rm_sequence)\n \t{\n \t  if (cycle >= REGEXP_SEQUENCE (seq)->regexps_num)\n-\t    break;\n+\t    continue;\n \t  allof = REGEXP_SEQUENCE (seq)->regexps [cycle];\n \t  if (allof->mode == rm_allof)\n \t    {\n \t      for (k = 0; k < REGEXP_ALLOF (allof)->regexps_num; k++)\n \t\tif (REGEXP_ALLOF (allof)->regexps [k]->mode == rm_unit\n \t\t    && (REGEXP_UNIT (REGEXP_ALLOF (allof)->regexps [k])\n-\t\t\t->unit_decl == unit_decl))\n+\t\t\t->unit_decl->automaton_decl\n+\t\t\t== unit_decl->automaton_decl))\n \t\t  break;\n \t      if (k >= REGEXP_ALLOF (allof)->regexps_num)\n \t\tbreak;\n \t    }\n \t  else if (allof->mode == rm_unit\n-\t\t   && REGEXP_UNIT (allof)->unit_decl != unit_decl)\n+\t\t   && (REGEXP_UNIT (allof)->unit_decl->automaton_decl\n+\t\t       != unit_decl->automaton_decl))\n \t    break;\n \t}\n       else if (cycle != 0)\n-\tbreak;\n+\tcontinue;\n       else if (seq->mode == rm_allof)\n \t{\n \t  for (k = 0; k < REGEXP_ALLOF (seq)->regexps_num; k++)\n \t    if (REGEXP_ALLOF (seq)->regexps [k]->mode == rm_unit\n-\t\t&& (REGEXP_UNIT (REGEXP_ALLOF (seq)->regexps [k])->unit_decl\n-\t\t    == unit_decl))\n+\t\t&& (REGEXP_UNIT (REGEXP_ALLOF (seq)->regexps [k])\n+\t\t    ->unit_decl->automaton_decl == unit_decl->automaton_decl))\n \t      break;\n \t  if (k >= REGEXP_ALLOF (seq)->regexps_num)\n \t    break;\n \t}\n       else if (seq->mode == rm_unit\n-\t       && REGEXP_UNIT (seq)->unit_decl != unit_decl)\n+\t       && (REGEXP_UNIT (seq)->unit_decl->automaton_decl\n+\t\t   != unit_decl->automaton_decl))\n \tbreak;\n     }\n   if (i >= 0)\n     {\n-      if (the_same_automaton_lists [cycle] == NULL)\n-\tthe_same_automaton_lists [cycle] = unit_decl;\n-      else\n+      if (!annotation_message_reported_p)\n \t{\n-\t  for (last = the_same_automaton_lists [cycle];;)\n-\t    {\n-\t      if (last == unit_decl)\n-\t\treturn;\n-\t      if (last->the_same_automaton_unit\n-\t\t  == the_same_automaton_lists [cycle])\n-\t\tbreak;\n-\t      last = last->the_same_automaton_unit;\n-\t    }\n-\t  last->the_same_automaton_unit = unit_decl->the_same_automaton_unit;\n-\t  unit_decl->the_same_automaton_unit\n-\t    = the_same_automaton_lists [cycle];\n+\t  fprintf (stderr, \"\\n\");\n+\t  error (\"The following units do not satisfy units-automata distribution rule\");\n+\t  error (\"  (A unit of given unit automaton should be on each reserv. altern.)\");\n+\t  annotation_message_reported_p = TRUE;\n \t}\n+      error (\"Unit %s, reserv. %s, cycle %d\",\n+\t     unit_decl->name, insn_reserv_name, cycle);\n     }\n }\n \n-/* The function processes given REGEXP to find units which should be\n-   in the same automaton.  */\n+/* The function processes given REGEXP to find units with the wrong\n+   distribution.  */\n static void\n-form_the_same_automaton_unit_lists_from_regexp (regexp)\n+check_regexp_units_distribution (insn_reserv_name, regexp)\n+     const char *insn_reserv_name;\n      regexp_t regexp;\n {\n   int i, j, k;\n   regexp_t seq, allof, unit;\n \n   if (regexp == NULL || regexp->mode != rm_oneof)\n     return;\n-  for (i = 0; i < description->max_insn_reserv_cycles; i++)\n-    the_same_automaton_lists [i] = NULL;\n   for (i = REGEXP_ONEOF (regexp)->regexps_num - 1; i >= 0; i--)\n     {\n       seq = REGEXP_ONEOF (regexp)->regexps [i];\n@@ -5247,14 +5538,14 @@ form_the_same_automaton_unit_lists_from_regexp (regexp)\n \t\t{\n \t\t  unit = REGEXP_ALLOF (allof)->regexps [k];\n \t\t  if (unit->mode == rm_unit)\n-\t\t    process_unit_to_form_the_same_automaton_unit_lists\n-\t\t      (unit, regexp, j);\n+\t\t    check_unit_distribution_in_reserv (insn_reserv_name, unit,\n+\t\t\t\t\t\t       regexp, j);\n \t\t  else if (unit->mode != rm_nothing)\n \t\t    abort ();\n \t\t}\n \t    else if (allof->mode == rm_unit)\n-\t      process_unit_to_form_the_same_automaton_unit_lists\n-\t\t(allof, regexp, j);\n+\t      check_unit_distribution_in_reserv (insn_reserv_name, allof,\n+\t\t\t\t\t\t regexp, j);\n \t    else if (allof->mode != rm_nothing)\n \t      abort ();\n \t  }\n@@ -5263,78 +5554,37 @@ form_the_same_automaton_unit_lists_from_regexp (regexp)\n \t  {\n \t    unit = REGEXP_ALLOF (seq)->regexps [k];\n \t    if (unit->mode == rm_unit)\n-\t      process_unit_to_form_the_same_automaton_unit_lists\n-\t\t(unit, regexp, 0);\n+\t      check_unit_distribution_in_reserv (insn_reserv_name, unit,\n+\t\t\t\t\t\t regexp, 0);\n \t    else if (unit->mode != rm_nothing)\n \t      abort ();\n \t  }\n       else if (seq->mode == rm_unit)\n-\tprocess_unit_to_form_the_same_automaton_unit_lists (seq, regexp, 0);\n+\tcheck_unit_distribution_in_reserv (insn_reserv_name, seq, regexp, 0);\n       else if (seq->mode != rm_nothing)\n \tabort ();\n     }\n }\n \n-/* The function initializes data to search for units which should be\n-   in the same automaton and call function\n-   `form_the_same_automaton_unit_lists_from_regexp' for each insn\n-   reservation regexp.  */\n-static void\n-form_the_same_automaton_unit_lists ()\n-{\n-  decl_t decl;\n-  int i;\n-\n-  the_same_automaton_lists\n-    = (unit_decl_t *) xmalloc (description->max_insn_reserv_cycles\n-\t\t\t       * sizeof (unit_decl_t));\n-  for (i = 0; i < description->decls_num; i++)\n-    {\n-      decl = description->decls [i];\n-      if (decl->mode == dm_unit)\n-\t{\n-\t  DECL_UNIT (decl)->the_same_automaton_message_reported_p = FALSE;\n-\t  DECL_UNIT (decl)->the_same_automaton_unit = DECL_UNIT (decl);\n-\t}\n-    }\n-  for (i = 0; i < description->decls_num; i++)\n-    {\n-      decl = description->decls [i];\n-      if (decl->mode == dm_insn_reserv)\n-\tform_the_same_automaton_unit_lists_from_regexp\n-\t  (DECL_INSN_RESERV (decl)->transformed_regexp);\n-    }\n-  free (the_same_automaton_lists);\n-}\n-\n-/* The function finds units which should be in the same automaton and,\n-   if they are not, reports about it.  */\n+/* The function finds units which violates units to automata\n+   distribution rule.  If the units exist, report about them.  */\n static void\n check_unit_distributions_to_automata ()\n {\n   decl_t decl;\n-  unit_decl_t start_unit_decl, unit_decl;\n   int i;\n \n-  form_the_same_automaton_unit_lists ();\n+  fprintf (stderr, \"Check unit distributions to automata...\");\n+  annotation_message_reported_p = FALSE;\n   for (i = 0; i < description->decls_num; i++)\n     {\n       decl = description->decls [i];\n-      if (decl->mode == dm_unit)\n-\t{\n-\t  start_unit_decl = DECL_UNIT (decl);\n-\t  if (!start_unit_decl->the_same_automaton_message_reported_p)\n-\t    for (unit_decl = start_unit_decl->the_same_automaton_unit;\n-\t\t unit_decl != start_unit_decl;\n-\t\t unit_decl = unit_decl->the_same_automaton_unit)\n-\t      if (start_unit_decl->automaton_decl != unit_decl->automaton_decl)\n-\t\t{\n-\t\t  error (\"Units `%s' and `%s' should be in the same automaton\",\n-\t\t\t start_unit_decl->name, unit_decl->name);\n-\t\t  unit_decl->the_same_automaton_message_reported_p = TRUE;\n-\t\t}\n-\t}\n+      if (decl->mode == dm_insn_reserv)\n+\tcheck_regexp_units_distribution\n+\t  (DECL_INSN_RESERV (decl)->name,\n+\t   DECL_INSN_RESERV (decl)->transformed_regexp);\n     }\n+  fprintf (stderr, \"done\\n\");\n }\n \n \f\n@@ -5537,6 +5787,36 @@ form_ainsn_with_same_reservs (automaton)\n   VLA_PTR_DELETE (last_insns);\n }\n \n+/* Forming unit reservations which can affect creating the automaton\n+   states achieved from a given state.  It permits to build smaller\n+   automata in many cases.  We would have the same automata after\n+   the minimization without such optimization, but the automaton\n+   right after the building could be huge.  So in other words, usage\n+   of reservs_matter means some minimization during building the\n+   automaton.  */\n+static reserv_sets_t\n+form_reservs_matter (automaton)\n+     automaton_t automaton;\n+{\n+  int cycle, unit;\n+  reserv_sets_t reservs_matter = alloc_empty_reserv_sets();\n+\n+  for (cycle = 0; cycle < max_cycles_num; cycle++)\n+    for (unit = 0; unit < description->units_num; unit++)\n+      if (units_array [unit]->automaton_decl\n+\t  == automaton->corresponding_automaton_decl\n+\t  && (cycle >= units_array [unit]->min_occ_cycle_num\n+\t      /* We can not remove queried unit from reservations.  */\n+\t      || units_array [unit]->query_p\n+\t      /* We can not remove units which are used\n+\t\t `exclusion_set', `presence_set',\n+\t\t `final_presence_set', `absence_set', and\n+\t\t `final_absence_set'.  */\n+\t      || units_array [unit]->in_set_p))\n+\tset_unit_reserv (reservs_matter, cycle, unit);\n+  return reservs_matter;\n+}\n+\n /* The following function creates all states of nondeterministic (if\n    NDFA_FLAG has nonzero value) or deterministic AUTOMATON.  */\n static void\n@@ -5552,13 +5832,16 @@ make_automaton (automaton)\n   ainsn_t advance_cycle_ainsn;\n   arc_t added_arc;\n   vla_ptr_t state_stack;\n+  int states_n;\n+  reserv_sets_t reservs_matter = form_reservs_matter (automaton);\n \n   VLA_PTR_CREATE (state_stack, 150, \"state stack\");\n   /* Create the start state (empty state).  */\n   start_state = insert_state (get_free_state (1, automaton));\n   automaton->start_state = start_state;\n   start_state->it_was_placed_in_stack_for_NDFA_forming = 1;\n   VLA_PTR_ADD (state_stack, start_state);\n+  states_n = 1;\n   while (VLA_PTR_LENGTH (state_stack) != 0)\n     {\n       state = VLA_PTR (state_stack, VLA_PTR_LENGTH (state_stack) - 1);\n@@ -5582,12 +5865,15 @@ make_automaton (automaton)\n                     state2 = alt_state->state;\n                     if (!intersected_state_reservs_p (state, state2))\n                       {\n-                        state2 = states_union (state, state2);\n+                        state2 = states_union (state, state2, reservs_matter);\n                         if (!state2->it_was_placed_in_stack_for_NDFA_forming)\n                           {\n                             state2->it_was_placed_in_stack_for_NDFA_forming\n \t\t\t      = 1;\n                             VLA_PTR_ADD (state_stack, state2);\n+\t\t\t    states_n++;\n+\t\t\t    if (states_n % 100 == 0)\n+\t\t\t      fprintf (stderr, \"*\");\n                           }\n \t\t\tadded_arc = add_arc (state, state2, ainsn, 1);\n \t\t\tif (!ndfa_flag)\n@@ -5611,11 +5897,14 @@ make_automaton (automaton)\n               advance_cycle_ainsn = ainsn;\n           }\n       /* Add transition to advance cycle.  */\n-      state2 = state_shift (state);\n+      state2 = state_shift (state, reservs_matter);\n       if (!state2->it_was_placed_in_stack_for_NDFA_forming)\n         {\n           state2->it_was_placed_in_stack_for_NDFA_forming = 1;\n           VLA_PTR_ADD (state_stack, state2);\n+\t  states_n++;\n+\t  if (states_n % 100 == 0)\n+\t    fprintf (stderr, \"*\");\n         }\n       if (advance_cycle_ainsn == NULL)\n \tabort ();\n@@ -5652,25 +5941,26 @@ form_arcs_marked_by_insn (state)\n /* The function creates composed state (see comments for IR) from\n    ORIGINAL_STATE and list of arcs ARCS_MARKED_BY_INSN marked by the\n    same insn.  If the composed state is not in STATE_STACK yet, it is\n-   popped to STATE_STACK.  */\n-static void\n+   pushed into STATE_STACK.  */\n+static int\n create_composed_state (original_state, arcs_marked_by_insn, state_stack)\n      state_t original_state;\n      arc_t arcs_marked_by_insn;\n      vla_ptr_t *state_stack;\n {\n   state_t state;\n-  alt_state_t curr_alt_state;\n+  alt_state_t alt_state, curr_alt_state;\n   alt_state_t new_alt_state;\n   arc_t curr_arc;\n   arc_t next_arc;\n   state_t state_in_table;\n   state_t temp_state;\n   alt_state_t canonical_alt_states_list;\n   int alts_number;\n+  int new_state_p = 0;\n \n   if (arcs_marked_by_insn == NULL)\n-    return;\n+    return new_state_p;\n   if (arcs_marked_by_insn->next_arc_marked_by_insn == NULL)\n     state = arcs_marked_by_insn->to_state;\n   else\n@@ -5683,14 +5973,25 @@ create_composed_state (original_state, arcs_marked_by_insn, state_stack)\n       for (curr_arc = arcs_marked_by_insn;\n            curr_arc != NULL;\n            curr_arc = curr_arc->next_arc_marked_by_insn)\n-        {\n-          new_alt_state = get_free_alt_state ();\n-          new_alt_state->next_alt_state = curr_alt_state;\n-          new_alt_state->state = curr_arc->to_state;\n-\t  if (curr_arc->to_state->component_states != NULL)\n-\t    abort ();\n-          curr_alt_state = new_alt_state;\n-        }\n+\tif (curr_arc->to_state->component_states == NULL)\n+\t  {\n+\t    new_alt_state = get_free_alt_state ();\n+\t    new_alt_state->next_alt_state = curr_alt_state;\n+\t    new_alt_state->state = curr_arc->to_state;\n+\t    curr_alt_state = new_alt_state;\n+\t  }\n+\telse\n+\t  for (alt_state = curr_arc->to_state->component_states;\n+\t       alt_state != NULL;\n+\t       alt_state = alt_state->next_sorted_alt_state)\n+\t    {\n+\t      new_alt_state = get_free_alt_state ();\n+\t      new_alt_state->next_alt_state = curr_alt_state;\n+\t      new_alt_state->state = alt_state->state;\n+\t      if (alt_state->state->component_states != NULL)\n+\t\tabort ();\n+\t      curr_alt_state = new_alt_state;\n+\t    }\n       /* There are not identical sets in the alt state list.  */\n       canonical_alt_states_list = uniq_sort_alt_states (curr_alt_state);\n       if (canonical_alt_states_list->next_sorted_alt_state == NULL)\n@@ -5714,6 +6015,7 @@ create_composed_state (original_state, arcs_marked_by_insn, state_stack)\n             {\n               if (state->it_was_placed_in_stack_for_DFA_forming)\n \t\tabort ();\n+\t      new_state_p = 1;\n               for (curr_alt_state = state->component_states;\n                    curr_alt_state != NULL;\n                    curr_alt_state = curr_alt_state->next_sorted_alt_state)\n@@ -5740,6 +6042,7 @@ create_composed_state (original_state, arcs_marked_by_insn, state_stack)\n       state->it_was_placed_in_stack_for_DFA_forming = 1;\n       VLA_PTR_ADD (*state_stack, state);\n     }\n+  return new_state_p;\n }\n \n /* The function transforms nondeterministic AUTOMATON into\n@@ -5753,12 +6056,14 @@ NDFA_to_DFA (automaton)\n   decl_t decl;\n   vla_ptr_t state_stack;\n   int i;\n+  int states_n;\n \n   VLA_PTR_CREATE (state_stack, 150, \"state stack\");\n   /* Create the start state (empty state).  */\n   start_state = automaton->start_state;\n   start_state->it_was_placed_in_stack_for_DFA_forming = 1;\n   VLA_PTR_ADD (state_stack, start_state);\n+  states_n = 1;\n   while (VLA_PTR_LENGTH (state_stack) != 0)\n     {\n       state = VLA_PTR (state_stack, VLA_PTR_LENGTH (state_stack) - 1);\n@@ -5767,10 +6072,15 @@ NDFA_to_DFA (automaton)\n       for (i = 0; i < description->decls_num; i++)\n \t{\n \t  decl = description->decls [i];\n-\t  if (decl->mode == dm_insn_reserv)\n-\t    create_composed_state\n-              (state, DECL_INSN_RESERV (decl)->arcs_marked_by_insn,\n-\t       &state_stack);\n+\t  if (decl->mode == dm_insn_reserv\n+\t      && create_composed_state\n+\t         (state, DECL_INSN_RESERV (decl)->arcs_marked_by_insn,\n+\t\t  &state_stack))\n+\t    {\n+\t      states_n++;\n+\t      if (states_n % 100 == 0)\n+\t\tfprintf (stderr, \"*\");\n+\t    }\n \t}\n     }\n   VLA_PTR_DELETE (state_stack);\n@@ -5892,19 +6202,39 @@ copy_equiv_class (to, from)\n     VLA_PTR_ADD (*to, *class_ptr);\n }\n \n+/* The following function returns TRUE if STATE reserves the unit with\n+   UNIT_NUM on the first cycle.  */\n+static int\n+first_cycle_unit_presence (state, unit_num)\n+     state_t state;\n+     int unit_num;\n+{\n+  int presence_p;\n+\n+  if (state->component_states == NULL)\n+    presence_p = test_unit_reserv (state->reservs, 0, unit_num);\n+  else\n+    presence_p\n+      = test_unit_reserv (state->component_states->state->reservs,\n+\t\t\t  0, unit_num);\n+  return presence_p;\n+}\n+\n /* The function returns nonzero value if STATE is not equivalent to\n-   another state from the same current partition on equivalence\n-   classes Another state has ORIGINAL_STATE_OUT_ARCS_NUM number of\n+   ANOTHER_STATE from the same current partition on equivalence\n+   classes.  Another state has ANOTHER_STATE_OUT_ARCS_NUM number of\n    output arcs.  Iteration of making equivalence partition is defined\n    by ODD_ITERATION_FLAG.  */\n static int\n-state_is_differed (state, original_state_out_arcs_num, odd_iteration_flag)\n-     state_t state;\n-     int original_state_out_arcs_num;\n+state_is_differed (state, another_state, another_state_out_arcs_num,\n+\t\t   odd_iteration_flag)\n+     state_t state, another_state;\n+     int another_state_out_arcs_num;\n      int odd_iteration_flag;\n {\n   arc_t arc;\n   int state_out_arcs_num;\n+  int i, presence1_p, presence2_p;\n \n   state_out_arcs_num = 0;\n   for (arc = first_out_arc (state); arc != NULL; arc = next_out_arc (arc))\n@@ -5917,7 +6247,19 @@ state_is_differed (state, original_state_out_arcs_num, odd_iteration_flag)\n \t  || (arc->insn->insn_reserv_decl->state_alts != arc->state_alts))\n         return 1;\n     }\n-  return state_out_arcs_num != original_state_out_arcs_num;\n+  if (state_out_arcs_num != another_state_out_arcs_num)\n+    return 1;\n+  /* Now we are looking at the states with the point of view of query\n+     units.  */\n+  for (i = 0; i < description->units_num; i++)\n+    if (units_array [i]->query_p)\n+      {\n+\tpresence1_p = first_cycle_unit_presence (state, i);\n+\tpresence2_p = first_cycle_unit_presence (another_state, i);\n+\tif ((presence1_p && !presence2_p) || (!presence1_p && presence2_p))\n+\t  return 1;\n+      }\n+  return 0;\n }\n \n /* The function makes initial partition of STATES on equivalent\n@@ -5982,7 +6324,7 @@ partition_equiv_class (equiv_class_ptr, odd_iteration_flag,\n \t       curr_state = next_state)\n \t    {\n \t      next_state = curr_state->next_equiv_class_state;\n-\t      if (state_is_differed (curr_state, out_arcs_num,\n+\t      if (state_is_differed (curr_state, first_state, out_arcs_num,\n \t\t\t\t     odd_iteration_flag))\n \t\t{\n \t\t  /* Remove curr state from the class equivalence.  */\n@@ -6068,7 +6410,7 @@ merge_states (automaton, equiv_classes)\n   state_t new_state;\n   state_t first_class_state;\n   alt_state_t alt_states;\n-  alt_state_t new_alt_state;\n+  alt_state_t alt_state, new_alt_state;\n   arc_t curr_arc;\n   arc_t next_arc;\n \n@@ -6089,12 +6431,27 @@ merge_states (automaton, equiv_classes)\n              curr_state = curr_state->next_equiv_class_state)\n           {\n             curr_state->equiv_class_state = new_state;\n-            new_alt_state = get_free_alt_state ();\n-            new_alt_state->state = curr_state;\n-            new_alt_state->next_sorted_alt_state = alt_states;\n-            alt_states = new_alt_state;\n+\t    if (curr_state->component_states == NULL)\n+\t      {\n+\t\tnew_alt_state = get_free_alt_state ();\n+\t\tnew_alt_state->state = curr_state;\n+\t\tnew_alt_state->next_alt_state = alt_states;\n+\t\talt_states = new_alt_state;\n+\t      }\n+\t    else\n+\t      for (alt_state = curr_state->component_states;\n+\t\t   alt_state != NULL;\n+\t\t   alt_state = alt_state->next_sorted_alt_state)\n+\t\t{\n+\t\t  new_alt_state = get_free_alt_state ();\n+\t\t  new_alt_state->state = alt_state->state;\n+\t\t  new_alt_state->next_alt_state = alt_states;\n+\t\t  alt_states = new_alt_state;\n+\t\t}\n           }\n-        new_state->component_states = alt_states;\n+\t/* Its is important that alt states were sorted before and\n+           after merging to have the same quering results.  */\n+        new_state->component_states = uniq_sort_alt_states (alt_states);\n       }\n     else\n       (*equiv_class_ptr)->equiv_class_state = *equiv_class_ptr;\n@@ -6212,21 +6569,39 @@ build_automaton (automaton)\n   int arcs_num;\n \n   ticker_on (&NDFA_time);\n+  if (automaton->corresponding_automaton_decl == NULL)\n+    fprintf (stderr, \"Create anonymous automaton (1 star is 100 new states):\");\n+  else\n+    fprintf (stderr, \"Create automaton `%s' (1 star is 100 new states):\",\n+\t     automaton->corresponding_automaton_decl->name);\n   make_automaton (automaton);\n+  fprintf (stderr, \" done\\n\");\n   ticker_off (&NDFA_time);\n   count_states_and_arcs (automaton, &states_num, &arcs_num);\n   automaton->NDFA_states_num = states_num;\n   automaton->NDFA_arcs_num = arcs_num;\n   ticker_on (&NDFA_to_DFA_time);\n+  if (automaton->corresponding_automaton_decl == NULL)\n+    fprintf (stderr, \"Make anonymous DFA (1 star is 100 new states):\");\n+  else\n+    fprintf (stderr, \"Make DFA `%s' (1 star is 100 new states):\",\n+\t     automaton->corresponding_automaton_decl->name);\n   NDFA_to_DFA (automaton);\n+  fprintf (stderr, \" done\\n\");\n   ticker_off (&NDFA_to_DFA_time);\n   count_states_and_arcs (automaton, &states_num, &arcs_num);\n   automaton->DFA_states_num = states_num;\n   automaton->DFA_arcs_num = arcs_num;\n   if (!no_minimization_flag)\n     {\n       ticker_on (&minimize_time);\n+      if (automaton->corresponding_automaton_decl == NULL)\n+\tfprintf (stderr, \"Minimize anonymous DFA...\");\n+      else\n+\tfprintf (stderr, \"Minimize DFA `%s'...\",\n+\t\t automaton->corresponding_automaton_decl->name);\n       minimize_DFA (automaton);\n+      fprintf (stderr, \"done\\n\");\n       ticker_off (&minimize_time);\n       count_states_and_arcs (automaton, &states_num, &arcs_num);\n       automaton->minimal_DFA_states_num = states_num;\n@@ -6440,7 +6815,8 @@ estimate_one_automaton_bound ()\n       decl = description->decls [i];\n       if (decl->mode == dm_unit)\n \t{\n-\t  root_value = exp (log (DECL_UNIT (decl)->max_occ_cycle_num + 1.0)\n+\t  root_value = exp (log (DECL_UNIT (decl)->max_occ_cycle_num\n+\t\t\t\t - DECL_UNIT (decl)->min_occ_cycle_num + 1.0)\n                             / automata_num);\n \t  if (MAX_FLOATING_POINT_VALUE_FOR_AUTOMATON_BOUND / root_value\n \t      > one_automaton_estimation_bound)\n@@ -6659,18 +7035,18 @@ create_automata ()\n        curr_automaton = curr_automaton->next_automaton)\n     {\n       if (curr_automaton->corresponding_automaton_decl == NULL)\n-\tfprintf (stderr, \"Create anonymous automaton ...\");\n+\tfprintf (stderr, \"Prepare anonymous automaton creation ... \");\n       else\n-\tfprintf (stderr, \"Create automaton `%s'...\",\n+\tfprintf (stderr, \"Prepare automaton `%s' creation...\",\n \t\t curr_automaton->corresponding_automaton_decl->name);\n       create_alt_states (curr_automaton);\n       form_ainsn_with_same_reservs (curr_automaton);\n+      fprintf (stderr, \"done\\n\");\n       build_automaton (curr_automaton);\n       enumerate_states (curr_automaton);\n       ticker_on (&equiv_time);\n       set_insn_equiv_classes (curr_automaton);\n       ticker_off (&equiv_time);\n-      fprintf (stderr, \"done\\n\");\n     }\n }\n \n@@ -7164,6 +7540,8 @@ output_reserved_units_table_name (f, automaton)\n \n #define CPU_UNIT_RESERVATION_P_FUNC_NAME \"cpu_unit_reservation_p\"\n \n+#define DFA_CLEAN_INSN_CACHE_FUNC_NAME  \"dfa_clean_insn_cache\"\n+\n #define DFA_START_FUNC_NAME  \"dfa_start\"\n \n #define DFA_FINISH_FUNC_NAME \"dfa_finish\"\n@@ -7658,7 +8036,6 @@ output_state_alts_table (automaton)\n    value for an ainsn and state.  */\n static int curr_state_pass_num;\n \n-\n /* This recursive function passes states to find minimal issue delay\n    value for AINSN.  The state being visited is STATE.  The function\n    returns minimal issue delay value for AINSN in STATE or -1 if we\n@@ -7773,7 +8150,7 @@ output_min_issue_delay_table (automaton)\n \t\t       + ainsn->insn_equiv_class_num) = min_delay;\n \t  }\n       }\n-  fprintf (output_file, \"/* Vector of min issue delay of insns.*/\\n\");\n+  fprintf (output_file, \"/* Vector of min issue delay of insns.  */\\n\");\n   fprintf (output_file, \"static const \");\n   output_range_type (output_file, 0, automaton->max_min_delay);\n   fprintf (output_file, \" \");\n@@ -7894,14 +8271,12 @@ output_reserved_units_table (automaton)\n        curr_state_ptr++)\n     {\n       for (i = 0; i < description->units_num; i++)\n-\tif (units_array [i]->query_p)\n-\t  {\n-\t    if (test_unit_reserv ((*curr_state_ptr)->reservs, 0, i))\n-\t      VLA_HWINT (reserved_units_table,\n-\t\t\t (*curr_state_ptr)->order_state_num * state_byte_size\n-\t\t\t + units_array [i]->query_num / 8)\n-\t\t+= (1 << (units_array [i]->query_num % 8));\n-\t  }\n+\tif (units_array [i]->query_p\n+\t    && first_cycle_unit_presence (*curr_state_ptr, i))\n+\t  VLA_HWINT (reserved_units_table,\n+\t\t     (*curr_state_ptr)->order_state_num * state_byte_size\n+\t\t     + units_array [i]->query_num / 8)\n+\t    += (1 << (units_array [i]->query_num % 8));\n     }\n   fprintf (output_file, \"/* Vector for reserved units of states.  */\\n\");\n   fprintf (output_file, \"static const \");\n@@ -7939,13 +8314,10 @@ output_tables ()\n \t       AUTOMATON_STATE_ALTS_MACRO_NAME);\n       output_min_issue_delay_table (automaton);\n       output_dead_lock_vect (automaton);\n-      if (no_minimization_flag)\n-\t{\n-\t  fprintf (output_file, \"\\n#if %s\\n\\n\", CPU_UNITS_QUERY_MACRO_NAME);\n-\t  output_reserved_units_table (automaton);\n-\t  fprintf (output_file, \"\\n#endif /* #if %s */\\n\\n\",\n-\t\t   CPU_UNITS_QUERY_MACRO_NAME);\n-\t}\n+      fprintf (output_file, \"\\n#if %s\\n\\n\", CPU_UNITS_QUERY_MACRO_NAME);\n+      output_reserved_units_table (automaton);\n+      fprintf (output_file, \"\\n#endif /* #if %s */\\n\\n\",\n+\t       CPU_UNITS_QUERY_MACRO_NAME);\n     }\n   fprintf (output_file, \"\\n#define %s %d\\n\\n\", ADVANCE_CYCLE_VALUE_NAME,\n            DECL_INSN_RESERV (advance_cycle_insn_decl)->insn_num);\n@@ -8743,23 +9115,32 @@ output_cpu_unit_reservation_p ()\n   fprintf (output_file, \"  return 0;\\n}\\n\\n\");\n }\n \n-/* The function outputs PHR interface function `dfa_start'.  */\n+/* The function outputs PHR interface function `dfa_clean_insn_cache'.  */\n static void\n-output_dfa_start_func ()\n+output_dfa_clean_insn_cache_func ()\n {\n   fprintf (output_file,\n-\t   \"void\\n%s ()\\n{\\n  int %s;\\n\\n  %s = get_max_uid ();\\n\",\n-\t   DFA_START_FUNC_NAME, I_VARIABLE_NAME,\n-\t   DFA_INSN_CODES_LENGTH_VARIABLE_NAME);\n-  fprintf (output_file, \"  %s = (int *) xmalloc (%s * sizeof (int));\\n\",\n-\t   DFA_INSN_CODES_VARIABLE_NAME, DFA_INSN_CODES_LENGTH_VARIABLE_NAME);\n+\t   \"void\\n%s ()\\n{\\n  int %s;\\n\\n\",\n+\t   DFA_CLEAN_INSN_CACHE_FUNC_NAME, I_VARIABLE_NAME);\n   fprintf (output_file,\n \t   \"  for (%s = 0; %s < %s; %s++)\\n    %s [%s] = -1;\\n}\\n\\n\",\n \t   I_VARIABLE_NAME, I_VARIABLE_NAME,\n \t   DFA_INSN_CODES_LENGTH_VARIABLE_NAME, I_VARIABLE_NAME,\n \t   DFA_INSN_CODES_VARIABLE_NAME, I_VARIABLE_NAME);\n }\n \n+/* The function outputs PHR interface function `dfa_start'.  */\n+static void\n+output_dfa_start_func ()\n+{\n+  fprintf (output_file,\n+\t   \"void\\n%s ()\\n{\\n  %s = get_max_uid ();\\n\",\n+\t   DFA_START_FUNC_NAME, DFA_INSN_CODES_LENGTH_VARIABLE_NAME);\n+  fprintf (output_file, \"  %s = (int *) xmalloc (%s * sizeof (int));\\n\",\n+\t   DFA_INSN_CODES_VARIABLE_NAME, DFA_INSN_CODES_LENGTH_VARIABLE_NAME);\n+  fprintf (output_file, \"  %s ();\\n}\\n\\n\", DFA_CLEAN_INSN_CACHE_FUNC_NAME);\n+}\n+\n /* The function outputs PHR interface function `dfa_finish'.  */\n static void\n output_dfa_finish_func ()\n@@ -8792,11 +9173,29 @@ output_unit_set_el_list (list)\n   for (el = list; el != NULL; el = el->next_unit_set_el)\n     {\n       if (el != list)\n-\tfprintf (output_description_file, \",\");\n+\tfprintf (output_description_file, \", \");\n       fprintf (output_description_file, \"%s\", el->unit_decl->name);\n     }\n }\n \n+/* Output patterns in LIST separated by comma.  */\n+static void\n+output_pattern_set_el_list (list)\n+     pattern_set_el_t list;\n+{\n+  pattern_set_el_t el;\n+  int i;\n+\n+  for (el = list; el != NULL; el = el->next_pattern_set_el)\n+    {\n+      if (el != list)\n+\tfprintf (output_description_file, \", \");\n+      for (i = 0; i < el->units_num; i++)\n+\tfprintf (output_description_file, (i == 0 ? \"%s\" : \" %s\"),\n+\t\t el->unit_decls [i]->name);\n+    }\n+}\n+\n /* The function outputs string representation of IR define_reservation\n    and define_insn_reservation.  */\n static void\n@@ -8821,16 +9220,32 @@ output_description ()\n \t    {\n \t      fprintf (output_description_file, \"unit %s presence_set: \",\n \t\t       DECL_UNIT (decl)->name);\n-\t      output_unit_set_el_list (DECL_UNIT (decl)->presence_list);\n+\t      output_pattern_set_el_list (DECL_UNIT (decl)->presence_list);\n \t      fprintf (output_description_file, \"\\n\");\n \t    }\n+\t  if (DECL_UNIT (decl)->final_presence_list != NULL)\n+\t    {\n+\t      fprintf (output_description_file, \"unit %s final_presence_set: \",\n+\t\t       DECL_UNIT (decl)->name);\n+\t      output_pattern_set_el_list\n+\t\t(DECL_UNIT (decl)->final_presence_list);\n+ \t      fprintf (output_description_file, \"\\n\");\n+ \t    }\n \t  if (DECL_UNIT (decl)->absence_list != NULL)\n \t    {\n \t      fprintf (output_description_file, \"unit %s absence_set: \",\n \t\t       DECL_UNIT (decl)->name);\n-\t      output_unit_set_el_list (DECL_UNIT (decl)->absence_list);\n+\t      output_pattern_set_el_list (DECL_UNIT (decl)->absence_list);\n \t      fprintf (output_description_file, \"\\n\");\n \t    }\n+\t  if (DECL_UNIT (decl)->final_absence_list != NULL)\n+\t    {\n+\t      fprintf (output_description_file, \"unit %s final_absence_set: \",\n+\t\t       DECL_UNIT (decl)->name);\n+\t      output_pattern_set_el_list\n+\t\t(DECL_UNIT (decl)->final_absence_list);\n+ \t      fprintf (output_description_file, \"\\n\");\n+ \t    }\n \t}\n     }\n   fprintf (output_description_file, \"\\n\");\n@@ -9092,6 +9507,7 @@ output_statistics (f)\n      FILE *f;\n {\n   automaton_t automaton;\n+  int states_num;\n #ifndef NDEBUG\n   int transition_comb_vect_els = 0;\n   int transition_full_vect_els = 0;\n@@ -9110,10 +9526,14 @@ output_statistics (f)\n \t       automaton->NDFA_states_num, automaton->NDFA_arcs_num);\n       fprintf (f, \"    %5d DFA states,           %5d DFA arcs\\n\",\n \t       automaton->DFA_states_num, automaton->DFA_arcs_num);\n+      states_num = automaton->DFA_states_num;\n       if (!no_minimization_flag)\n-\tfprintf (f, \"    %5d minimal DFA states,   %5d minimal DFA arcs\\n\",\n-\t\t automaton->minimal_DFA_states_num,\n-\t\t automaton->minimal_DFA_arcs_num);\n+\t{\n+\t  fprintf (f, \"    %5d minimal DFA states,   %5d minimal DFA arcs\\n\",\n+\t\t   automaton->minimal_DFA_states_num,\n+\t\t   automaton->minimal_DFA_arcs_num);\n+\t  states_num = automaton->minimal_DFA_states_num;\n+\t}\n       fprintf (f, \"    %5d all insns      %5d insn equivalence classes\\n\",\n \t       description->insns_num, automaton->insn_equiv_classes_num);\n #ifndef NDEBUG\n@@ -9131,7 +9551,7 @@ output_statistics (f)\n           ? \"use comb vect\" : \"use simple vect\"));\n       fprintf\n         (f, \"%5ld min delay table els, compression factor %d\\n\",\n-         (long) automaton->DFA_states_num * automaton->insn_equiv_classes_num,\n+         (long) states_num * automaton->insn_equiv_classes_num,\n \t automaton->min_issue_delay_table_compression_factor);\n       transition_comb_vect_els\n \t+= VLA_HWINT_LENGTH (automaton->trans_table->comb_vect);\n@@ -9142,7 +9562,7 @@ output_statistics (f)\n       state_alts_full_vect_els\n         += VLA_HWINT_LENGTH (automaton->state_alts_table->full_vect);\n       min_issue_delay_vect_els\n-        += automaton->DFA_states_num * automaton->insn_equiv_classes_num;\n+\t+= states_num * automaton->insn_equiv_classes_num;\n #endif\n     }\n #ifndef NDEBUG\n@@ -9200,7 +9620,7 @@ generate ()\n   initiate_automata_lists ();\n   initiate_pass_states ();\n   initiate_excl_sets ();\n-  initiate_presence_absence_sets ();\n+  initiate_presence_absence_pattern_sets ();\n   automaton_generation_time = create_ticker ();\n   create_automata ();\n   ticker_off (&automaton_generation_time);\n@@ -9680,14 +10100,13 @@ write_automata ()\n   output_internal_insn_latency_func ();\n   output_insn_latency_func ();\n   output_print_reservation_func ();\n-  if (no_minimization_flag)\n-    {\n-      fprintf (output_file, \"\\n#if %s\\n\\n\", CPU_UNITS_QUERY_MACRO_NAME);\n-      output_get_cpu_unit_code_func ();\n-      output_cpu_unit_reservation_p ();\n-      fprintf (output_file, \"\\n#endif /* #if %s */\\n\\n\",\n-\t       CPU_UNITS_QUERY_MACRO_NAME);\n-    }\n+  /* Output function get_cpu_unit_code.  */\n+  fprintf (output_file, \"\\n#if %s\\n\\n\", CPU_UNITS_QUERY_MACRO_NAME);\n+  output_get_cpu_unit_code_func ();\n+  output_cpu_unit_reservation_p ();\n+  fprintf (output_file, \"\\n#endif /* #if %s */\\n\\n\",\n+\t   CPU_UNITS_QUERY_MACRO_NAME);\n+  output_dfa_clean_insn_cache_func ();\n   output_dfa_start_func ();\n   output_dfa_finish_func ();\n   fprintf (stderr, \"done\\n\");"}, {"sha": "046abc344239c73e30d7ee5dd408031767c38efb", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 220, "deletions": 120, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=30028c85159c12c4e8920af0a9111372e56f1636", "patch": "@@ -320,6 +320,7 @@ static int rank_for_schedule PARAMS ((const PTR, const PTR));\n static void swap_sort PARAMS ((rtx *, int));\n static void queue_insn PARAMS ((rtx, int));\n static void schedule_insn PARAMS ((rtx, struct ready_list *, int));\n+static int find_set_reg_weight PARAMS ((rtx));\n static void find_insn_reg_weight PARAMS ((int));\n static void adjust_priority PARAMS ((rtx));\n static void advance_one_cycle PARAMS ((void));\n@@ -366,7 +367,7 @@ static rtx move_insn PARAMS ((rtx, rtx));\n    on the first cycle.  It is used only for DFA based scheduler.  */\n static rtx ready_element PARAMS ((struct ready_list *, int));\n static rtx ready_remove PARAMS ((struct ready_list *, int));\n-static int max_issue PARAMS ((struct ready_list *, state_t, int *));\n+static int max_issue PARAMS ((struct ready_list *, int *));\n \n static rtx choose_ready PARAMS ((struct ready_list *));\n \n@@ -853,6 +854,7 @@ rank_for_schedule (x, y)\n \n   /* Prefer insn with higher priority.  */\n   priority_val = INSN_PRIORITY (tmp2) - INSN_PRIORITY (tmp);\n+\n   if (priority_val)\n     return priority_val;\n \n@@ -1017,8 +1019,10 @@ ready_element (ready, index)\n      struct ready_list *ready;\n      int index;\n {\n+#ifdef ENABLE_CHECKING\n   if (ready->n_ready == 0 || index >= ready->n_ready)\n     abort ();\n+#endif\n   return ready->vec[ready->first - index];\n }\n \n@@ -1195,11 +1199,12 @@ schedule_insn (insn, ready, clock)\n      to issue on the same cycle as the previous insn.  A machine\n      may use this information to decide how the instruction should\n      be aligned.  */\n-  if (reload_completed && issue_rate > 1\n+  if (issue_rate > 1\n       && GET_CODE (PATTERN (insn)) != USE\n       && GET_CODE (PATTERN (insn)) != CLOBBER)\n     {\n-      PUT_MODE (insn, clock > last_clock_var ? TImode : VOIDmode);\n+      if (reload_completed)\n+\tPUT_MODE (insn, clock > last_clock_var ? TImode : VOIDmode);\n       last_clock_var = clock;\n     }\n }\n@@ -1536,6 +1541,32 @@ rm_other_notes (head, tail)\n \n /* Functions for computation of registers live/usage info.  */\n \n+/* This function looks for a new register being defined.\n+   If the destination register is already used by the source,\n+   a new register is not needed. */\n+\n+static int\n+find_set_reg_weight (x)\n+    rtx x;\n+{\n+  if (GET_CODE (x) == CLOBBER\n+      && register_operand (SET_DEST (x), VOIDmode))\n+    return 1;\n+  if (GET_CODE (x) == SET\n+      && register_operand (SET_DEST (x), VOIDmode))\n+    {\n+      if (GET_CODE (SET_DEST (x)) == REG)\n+\t{\n+\t  if (!reg_mentioned_p (SET_DEST (x), SET_SRC (x)))\n+\t    return 1;\n+\t  else\n+\t    return 0;\n+\t}\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n /* Calculate INSN_REG_WEIGHT for all insns of a block.  */\n \n static void\n@@ -1558,21 +1589,16 @@ find_insn_reg_weight (b)\n \n       /* Increment weight for each register born here.  */\n       x = PATTERN (insn);\n-      if ((GET_CODE (x) == SET || GET_CODE (x) == CLOBBER)\n-\t  && register_operand (SET_DEST (x), VOIDmode))\n-\treg_weight++;\n-      else if (GET_CODE (x) == PARALLEL)\n-\t{\n-\t  int j;\n-\t  for (j = XVECLEN (x, 0) - 1; j >= 0; j--)\n-\t    {\n-\t      x = XVECEXP (PATTERN (insn), 0, j);\n-\t      if ((GET_CODE (x) == SET || GET_CODE (x) == CLOBBER)\n-\t\t  && register_operand (SET_DEST (x), VOIDmode))\n-\t\treg_weight++;\n-\t    }\n-\t}\n-\n+      reg_weight += find_set_reg_weight (x);\n+      if (GET_CODE (x) == PARALLEL)\n+ \t{\n+ \t  int j;\n+ \t  for (j = XVECLEN (x, 0) - 1; j >= 0; j--)\n+ \t    {\n+ \t      x = XVECEXP (PATTERN (insn), 0, j);\n+\t      reg_weight += find_set_reg_weight (x);\n+ \t    }\n+ \t}\n       /* Decrement weight for each register that dies here.  */\n       for (x = REG_NOTES (insn); x; x = XEXP (x, 1))\n \t{\n@@ -1743,25 +1769,6 @@ move_insn (insn, last)\n {\n   rtx retval = NULL;\n \n-  /* If INSN has SCHED_GROUP_P set, then issue it and any other\n-     insns with SCHED_GROUP_P set first.  */\n-  while (SCHED_GROUP_P (insn))\n-    {\n-      rtx prev = PREV_INSN (insn);\n-\n-      /* Move a SCHED_GROUP_P insn.  */\n-      move_insn1 (insn, last);\n-      /* If this is the first call to reemit_notes, then record\n-\t its return value.  */\n-      if (retval == NULL_RTX)\n-\tretval = reemit_notes (insn, insn);\n-      else\n-\treemit_notes (insn, insn);\n-      /* Consume SCHED_GROUP_P flag.  */\n-      SCHED_GROUP_P (insn) = 0;\n-      insn = prev;\n-    }\n-\n   /* Now move the first non SCHED_GROUP_P insn.  */\n   move_insn1 (insn, last);\n \n@@ -1772,90 +1779,109 @@ move_insn (insn, last)\n   else\n     reemit_notes (insn, insn);\n \n+  SCHED_GROUP_P (insn) = 0;\n+\n   return retval;\n }\n \n+/* The following structure describe an entry of the stack of choices.  */\n+struct choice_entry\n+{\n+  /* Ordinal number of the issued insn in the ready queue.  */\n+  int index;\n+  /* The number of the rest insns whose issues we should try.  */\n+  int rest;\n+  /* The number of issued essential insns.  */\n+  int n;\n+  /* State after issuing the insn.  */\n+  state_t state;\n+};\n+\n+/* The following array is used to implement a stack of choices used in\n+   function max_issue.  */\n+static struct choice_entry *choice_stack;\n+\n+/* The following variable value is number of essential insns issued on\n+   the current cycle.  An insn is essential one if it changes the\n+   processors state.  */\n+static int cycle_issued_insns;\n+\n /* The following function returns maximal (or close to maximal) number\n    of insns which can be issued on the same cycle and one of which\n-   insns is insns with the best rank (the last insn in READY).  To\n+   insns is insns with the best rank (the first insn in READY).  To\n    make this function tries different samples of ready insns.  READY\n    is current queue `ready'.  Global array READY_TRY reflects what\n-   insns are already issued in this try.  STATE is current processor\n-   state.  If the function returns nonzero, INDEX will contain index\n+   insns are already issued in this try.  INDEX will contain index\n    of the best insn in READY.  The following function is used only for\n    first cycle multipass scheduling.  */\n-\n static int\n-max_issue (ready, state, index)\n-     struct ready_list *ready;\n-     state_t state;\n-     int *index;\n+max_issue (ready, index)\n+  struct ready_list *ready;\n+  int *index;\n {\n-  int i, best, n, temp_index, delay;\n-  state_t temp_state;\n+  int n, i, all, n_ready, lookahead, best, delay;\n+  struct choice_entry *top;\n   rtx insn;\n-  int max_lookahead = (*targetm.sched.first_cycle_multipass_dfa_lookahead) ();\n \n-  if (state_dead_lock_p (state))\n-    return 0;\n-\n-  temp_state = alloca (dfa_state_size);\n+  lookahead = (*targetm.sched.first_cycle_multipass_dfa_lookahead) ();\n   best = 0;\n-  \n-  for (i = 0; i < ready->n_ready; i++)\n+  memcpy (choice_stack->state, curr_state, dfa_state_size);\n+  top = choice_stack;\n+  top->rest = lookahead;\n+  top->n = 0;\n+  n_ready = ready->n_ready;\n+  for (all = i = 0; i < n_ready; i++)\n     if (!ready_try [i])\n-      {\n-\tinsn = ready_element (ready, i);\n-\t\n-\tif (INSN_CODE (insn) < 0)\n-\t  continue;\n-\t\n-\tmemcpy (temp_state, state, dfa_state_size);\n-\t\n-\tdelay = state_transition (temp_state, insn);\n-\t\n-\tif (delay == 0)\n-\t  {\n-\t    if (!targetm.sched.dfa_bubble)\n-\t      continue;\n-\t    else\n-\t      {\n-\t\tint j;\n-\t\trtx bubble;\n-\t\t\n-\t\tfor (j = 0;\n-\t\t     (bubble = (*targetm.sched.dfa_bubble) (j)) != NULL_RTX;\n-\t\t     j++)\n-\t\t  if (state_transition (temp_state, bubble) < 0\n-\t\t      && state_transition (temp_state, insn) < 0)\n-\t\t    break;\n-\t\t\n-\t\tif (bubble == NULL_RTX)\n-\t\t  continue;\n-\t      }\n-\t  }\n-\telse if (delay > 0)\n-\t  continue;\n-\t\n-\t--max_lookahead;\n-\t\n-\tif (max_lookahead < 0)\n-\t  break;\n-\t\n-\tready_try [i] = 1;\n-\n-\tn = max_issue (ready, temp_state, &temp_index);\n-\tif (n > 0 || ready_try[0])\n-\t  n += 1;\n-\n-\tif (best < n)\n-\t  {\n-\t    best = n;\n-\t    *index = i;\n-\t  }\n-\tready_try [i] = 0;\n-      }\n-  \n+      all++;\n+  i = 0;\n+  for (;;)\n+    {\n+      if (top->rest == 0 || i >= n_ready)\n+\t{\n+\t  if (top == choice_stack)\n+\t    break;\n+\t  if (best < top - choice_stack && ready_try [0])\n+\t    {\n+\t      best = top - choice_stack;\n+\t      *index = choice_stack [1].index;\n+\t      if (top->n == issue_rate - cycle_issued_insns || best == all)\n+\t\tbreak;\n+\t    }\n+\t  i = top->index;\n+\t  ready_try [i] = 0;\n+\t  top--;\n+\t  memcpy (curr_state, top->state, dfa_state_size);\n+\t}\n+      else if (!ready_try [i])\n+\t{\n+\t  insn = ready_element (ready, i);\n+\t  delay = state_transition (curr_state, insn);\n+\t  if (delay < 0)\n+\t    {\n+\t      if (state_dead_lock_p (curr_state))\n+\t\ttop->rest = 0;\n+\t      else\n+\t\ttop->rest--;\n+\t      n = top->n;\n+\t      if (memcmp (top->state, curr_state, dfa_state_size) != 0)\n+\t\tn++;\n+\t      top++;\n+\t      top->rest = lookahead;\n+\t      top->index = i;\n+\t      top->n = n;\n+\t      memcpy (top->state, curr_state, dfa_state_size);\n+\t      ready_try [i] = 1;\n+\t      i = -1;\n+\t    }\n+\t}\n+      i++;\n+    }\n+  while (top != choice_stack)\n+    {\n+      ready_try [top->index] = 0;\n+      top--;\n+    }\n+  memcpy (curr_state, choice_stack->state, dfa_state_size);\n   return best;\n }\n \n@@ -1873,9 +1899,21 @@ choose_ready (ready)\n   else\n     {\n       /* Try to choose the better insn.  */\n-      int index;\n+      int index, i;\n+      rtx insn;\n \n-      if (max_issue (ready, curr_state, &index) == 0)\n+      insn = ready_element (ready, 0);\n+      if (INSN_CODE (insn) < 0)\n+\treturn ready_remove_first (ready);\n+      for (i = 1; i < ready->n_ready; i++)\n+\t{\n+\t  insn = ready_element (ready, i);\n+\t  ready_try [i]\n+\t    = (INSN_CODE (insn) < 0\n+\t       || (targetm.sched.first_cycle_multipass_dfa_lookahead_guard\n+\t\t   && !(*targetm.sched.first_cycle_multipass_dfa_lookahead_guard) (insn)));\n+\t}\n+      if (max_issue (ready, &index) == 0)\n \treturn ready_remove_first (ready);\n       else\n \treturn ready_remove (ready, index);\n@@ -1903,9 +1941,10 @@ schedule_block (b, rgn_n_insns)\n      int rgn_n_insns;\n {\n   struct ready_list ready;\n-  int first_cycle_insn_p;\n+  int i, first_cycle_insn_p;\n   int can_issue_more;\n   state_t temp_state = NULL;  /* It is used for multipass scheduling.  */\n+  int sort_p;\n \n   /* Head/tail info for this block.  */\n   rtx prev_head = current_sched_info->prev_head;\n@@ -1957,6 +1996,11 @@ schedule_block (b, rgn_n_insns)\n       temp_state = alloca (dfa_state_size);\n       ready_try = (char *) xmalloc ((rgn_n_insns + 1) * sizeof (char));\n       memset (ready_try, 0, (rgn_n_insns + 1) * sizeof (char));\n+      choice_stack\n+\t= (struct choice_entry *) xmalloc ((rgn_n_insns + 1)\n+\t\t\t\t\t   * sizeof (struct choice_entry));\n+      for (i = 0; i <= rgn_n_insns; i++)\n+\tchoice_stack[i].state = (state_t) xmalloc (dfa_state_size);\n     }\n \n   (*current_sched_info->init_ready_list) (&ready);\n@@ -1985,6 +2029,7 @@ schedule_block (b, rgn_n_insns)\n   /* Start just before the beginning of time.  */\n   clock_var = -1;\n \n+  sort_p = TRUE;\n   /* Loop until all the insns in BB are scheduled.  */\n   while ((*current_sched_info->schedule_more_p) ())\n     {\n@@ -2007,8 +2052,17 @@ schedule_block (b, rgn_n_insns)\n \t  debug_ready_list (&ready);\n \t}\n \n-      /* Sort the ready list based on priority.  */\n-      ready_sort (&ready);\n+      if (sort_p)\n+\t{\n+\t  /* Sort the ready list based on priority.  */\n+\t  ready_sort (&ready);\n+\t  \n+\t  if (sched_verbose >= 2)\n+\t    {\n+\t      fprintf (sched_dump, \";;\\t\\tReady list after ready_sort:  \");\n+\t      debug_ready_list (&ready);\n+\t    }\n+\t}\n \n       /* Allow the target to reorder the list, typically for\n \t better instruction bundling.  */\n@@ -2021,6 +2075,7 @@ schedule_block (b, rgn_n_insns)\n \tcan_issue_more = issue_rate;\n \n       first_cycle_insn_p = 1;\n+      cycle_issued_insns = 0;\n       for (;;)\n \t{\n \t  rtx insn;\n@@ -2050,8 +2105,21 @@ schedule_block (b, rgn_n_insns)\n \t\tbreak;\n \t      \n \t      /* Select and remove the insn from the ready list.  */\n-\t      insn = choose_ready (&ready);\n+\t      if (sort_p)\n+\t\tinsn = choose_ready (&ready);\n+\t      else\n+\t\tinsn = ready_remove_first (&ready);\n \t      \n+\t      if (targetm.sched.dfa_new_cycle\n+\t\t  && (*targetm.sched.dfa_new_cycle) (sched_dump, sched_verbose,\n+\t\t\t\t\t\t     insn, last_clock_var,\n+\t\t\t\t\t\t     clock_var, &sort_p))\n+\t\t{\n+\t\t  ready_add (&ready, insn);\n+\t\t  break;\n+\t\t}\n+\t    \n+\t      sort_p = TRUE;\n \t      memcpy (temp_state, curr_state, dfa_state_size);\n \t      if (recog_memoized (insn) < 0)\n \t\t{\n@@ -2155,7 +2223,11 @@ schedule_block (b, rgn_n_insns)\n \n \t  if (targetm.sched.use_dfa_pipeline_interface\n \t      && (*targetm.sched.use_dfa_pipeline_interface) ())\n-\t    memcpy (curr_state, temp_state, dfa_state_size);\n+\t    {\n+\t      if (memcmp (curr_state, temp_state, dfa_state_size) != 0)\n+\t\tcycle_issued_insns++;\n+\t      memcpy (curr_state, temp_state, dfa_state_size);\n+\t    }\n \t    \n \t  if (targetm.sched.variable_issue)\n \t    can_issue_more =\n@@ -2172,13 +2244,16 @@ schedule_block (b, rgn_n_insns)\n \tnext:\n \t  first_cycle_insn_p = 0;\n \n+\t  /* Sort the ready list based on priority.  This must be\n+\t     redone here, as schedule_insn may have readied additional\n+\t     insns that will not be sorted correctly. */\n+\t  if (ready.n_ready > 0)\n+\t    ready_sort (&ready);\n+\n \t  if (targetm.sched.reorder2)\n \t    {\n-\t      /* Sort the ready list based on priority.  */\n-\t      if (ready.n_ready > 0)\n-\t\tready_sort (&ready);\n \t      can_issue_more =\n-\t\t(*targetm.sched.reorder2) (sched_dump,sched_verbose,\n+\t\t(*targetm.sched.reorder2) (sched_dump, sched_verbose,\n \t\t\t\t\t   ready.n_ready\n \t\t\t\t\t   ? ready_lastpos (&ready) : NULL,\n \t\t\t\t\t   &ready.n_ready, clock_var);\n@@ -2214,6 +2289,27 @@ schedule_block (b, rgn_n_insns)\n   head = NEXT_INSN (prev_head);\n   tail = last_scheduled_insn;\n \n+  if (!reload_completed)\n+    {\n+      rtx insn, link, next;\n+      \n+      /* INSN_TICK (minimum clock tick at which the insn becomes\n+         ready) may be not correct for the insn in the subsequent\n+         blocks of the region.  We should use a correct value of\n+         `clock_var' or modify INSN_TICK.  It is better to keep\n+         clock_var value equal to 0 at the start of a basic block.\n+         Therefore we modify INSN_TICK here.  */\n+      for (insn = head; insn != tail; insn = NEXT_INSN (insn))\n+\tif (INSN_P (insn))\n+\t  {\n+\t    for (link = INSN_DEPEND (insn); link != 0; link = XEXP (link, 1))\n+\t      {\n+\t\tnext = XEXP (link, 0);\n+\t\tINSN_TICK (next) -= clock_var;\n+\t      }\n+\t  }\n+    }\n+\n   /* Restore-other-notes: NOTE_LIST is the end of a chain of notes\n      previously found among the insns.  Insert them at the beginning\n      of the insns.  */\n@@ -2250,7 +2346,12 @@ schedule_block (b, rgn_n_insns)\n \n   if (targetm.sched.use_dfa_pipeline_interface\n       && (*targetm.sched.use_dfa_pipeline_interface) ())\n-    free (ready_try);\n+    {\n+      free (ready_try);\n+      for (i = 0; i <= rgn_n_insns; i++)\n+\tfree (choice_stack [i].state);\n+      free (choice_stack);\n+    }\n }\n \f\n /* Set_priorities: compute priority of each insn in the block.  */\n@@ -2275,8 +2376,7 @@ set_priorities (head, tail)\n       if (GET_CODE (insn) == NOTE)\n \tcontinue;\n \n-      if (!(SCHED_GROUP_P (insn)))\n-\tn_insn++;\n+      n_insn++;\n       (void) priority (insn);\n     }\n "}, {"sha": "c1f812bc0715e4b40c42071556d8f030ce6471b2", "filename": "gcc/rtl.def", "status": "modified", "additions": 70, "deletions": 19, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=30028c85159c12c4e8920af0a9111372e56f1636", "patch": "@@ -358,9 +358,8 @@ DEF_RTL_EXPR(ADDRESS, \"address\", \"e\", 'm')\n DEF_RTL_EXPR(DEFINE_CPU_UNIT, \"define_cpu_unit\", \"sS\", 'x')\n \n /* (define_query_cpu_unit string [string]) describes cpu functional\n-   units analogously to define_cpu_unit.  If we use automaton without\n-   minimization, the reservation of such units can be queried for\n-   automaton state.  */\n+   units analogously to define_cpu_unit.  The reservation of such\n+   units can be queried for automaton state.  */\n DEF_RTL_EXPR(DEFINE_QUERY_CPU_UNIT, \"define_query_cpu_unit\", \"sS\", 'x')\n \n /* (exclusion_set string string) means that each CPU functional unit\n@@ -370,28 +369,80 @@ DEF_RTL_EXPR(DEFINE_QUERY_CPU_UNIT, \"define_query_cpu_unit\", \"sS\", 'x')\n    for description CPU with fully pipelined floating point functional\n    unit which can execute simultaneously only single floating point\n    insns or only double floating point insns.  All CPU functional\n-   units in a set should belong the same automaton.  */\n+   units in a set should belong to the same automaton.  */\n DEF_RTL_EXPR(EXCLUSION_SET, \"exclusion_set\", \"ss\", 'x')\n \n /* (presence_set string string) means that each CPU functional unit in\n-   the first string can not be reserved unless at least one of units\n-   whose names are in the second string is reserved.  This is an\n-   asymmetric relation.  CPU units in the string are separated by\n-   commas.  For example, it is useful for description that slot1 is\n-   reserved after slot0 reservation for VLIW processor.  All CPU\n-   functional units in a set should belong the same automaton.  */\n+   the first string can not be reserved unless at least one of pattern\n+   of units whose names are in the second string is reserved.  This is\n+   an asymmetric relation.  CPU units or unit patterns in the strings\n+   are separated by commas.  Pattern is one unit name or unit names\n+   separated by white-spaces.\n+ \n+   For example, it is useful for description that slot1 is reserved\n+   after slot0 reservation for a VLIW processor.  We could describe it\n+   by the following construction\n+\n+      (presence_set \"slot1\" \"slot0\")\n+\n+   Or slot1 is reserved only after slot0 and unit b0 reservation.  In\n+   this case we could write\n+\n+      (presence_set \"slot1\" \"slot0 b0\")\n+\n+   All CPU functional units in a set should belong to the same\n+   automaton.  */\n DEF_RTL_EXPR(PRESENCE_SET, \"presence_set\", \"ss\", 'x')\n \n+/* (final_presence_set string string) is analogous to `presence_set'.\n+   The difference between them is when checking is done.  When an\n+   instruction is issued in given automaton state reflecting all\n+   current and planned unit reservations, the automaton state is\n+   changed.  The first state is a source state, the second one is a\n+   result state.  Checking for `presence_set' is done on the source\n+   state reservation, checking for `final_presence_set' is done on the\n+   result reservation.  This construction is useful to describe a\n+   reservation which is actually two subsequent reservations.  For\n+   example, if we use \n+\n+      (presence_set \"slot1\" \"slot0\")\n+\n+   the following insn will be never issued (because slot1 requires\n+   slot0 which is absent in the source state).\n+\n+      (define_reservation \"insn_and_nop\" \"slot0 + slot1\")\n+\n+   but it can be issued if we use analogous `final_presence_set'.  */\n+DEF_RTL_EXPR(FINAL_PRESENCE_SET, \"final_presence_set\", \"ss\", 'x')\n+\n /* (absence_set string string) means that each CPU functional unit in\n-   the first string can not be reserved only if each unit whose name\n-   is in the second string is not reserved.  This is an asymmetric\n-   relation (actually exclusion set is analogous to this one but it is\n-   symmetric).  CPU units in the string are separated by commas.  For\n-   example, it is useful for description that slot0 can not be\n-   reserved after slot1 or slot2 reservation for VLIW processor.  All\n-   CPU functional units in a set should belong the same automaton.  */\n+   the first string can be reserved only if each pattern of units\n+   whose names are in the second string is not reserved.  This is an\n+   asymmetric relation (actually exclusion set is analogous to this\n+   one but it is symmetric).  CPU units or unit patterns in the string\n+   are separated by commas.  Pattern is one unit name or unit names\n+   separated by white-spaces.\n+\n+   For example, it is useful for description that slot0 can not be\n+   reserved after slot1 or slot2 reservation for a VLIW processor.  We\n+   could describe it by the following construction\n+\n+      (absence_set \"slot2\" \"slot0, slot1\")\n+\n+   Or slot2 can not be reserved if slot0 and unit b0 are reserved or\n+   slot1 and unit b1 are reserved .  In this case we could write\n+\n+      (absence_set \"slot2\" \"slot0 b0, slot1 b1\")\n+\n+   All CPU functional units in a set should to belong the same\n+   automaton.  */\n DEF_RTL_EXPR(ABSENCE_SET, \"absence_set\", \"ss\", 'x')\n \n+/* (final_absence_set string string) is analogous to `absence_set' but\n+   checking is done on the result (state) reservation.  See comments\n+   for `final_presence_set'.  */\n+DEF_RTL_EXPR(FINAL_ABSENCE_SET, \"final_absence_set\", \"ss\", 'x')\n+\n /* (define_bypass number out_insn_names in_insn_names) names bypass\n    with given latency (the first number) from insns given by the first\n    string (see define_insn_reservation) into insns given by the second\n@@ -416,8 +467,8 @@ DEF_RTL_EXPR(DEFINE_AUTOMATON, \"define_automaton\", \"s\", 'x')\n    automata.  Currently there are the following options:\n \n    o \"no-minimization\" which makes no minimization of automata.  This\n-     is only worth to do when we are going to query CPU functional\n-     unit reservations in an automaton state.\n+     is only worth to do when we are debugging the description and\n+     need to look more accurately at reservations of states.\n \n    o \"time\" which means printing additional time statistics about\n       generation of automata."}, {"sha": "a735125495c35bc0fd1f54327f1eea8af1f9a09b", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 36, "deletions": 100, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=30028c85159c12c4e8920af0a9111372e56f1636", "patch": "@@ -83,14 +83,12 @@ static sbitmap *forward_dependency_cache;\n static int deps_may_trap_p PARAMS ((rtx));\n static void add_dependence_list PARAMS ((rtx, rtx, enum reg_note));\n static void add_dependence_list_and_free PARAMS ((rtx, rtx *, enum reg_note));\n-static void remove_dependence PARAMS ((rtx, rtx));\n static void set_sched_group_p PARAMS ((rtx));\n \n static void flush_pending_lists PARAMS ((struct deps *, rtx, int, int));\n static void sched_analyze_1 PARAMS ((struct deps *, rtx, rtx));\n static void sched_analyze_2 PARAMS ((struct deps *, rtx, rtx));\n static void sched_analyze_insn PARAMS ((struct deps *, rtx, rtx, rtx));\n-static rtx group_leader PARAMS ((rtx));\n \n static rtx get_condition PARAMS ((rtx));\n static int conditions_mutex_p PARAMS ((rtx, rtx));\n@@ -237,18 +235,16 @@ add_dependence (insn, elem, dep_type)\n       rtx nnext;\n       while ((nnext = next_nonnote_insn (next)) != NULL\n \t     && INSN_P (nnext)\n+\t     && next != insn\n \t     && SCHED_GROUP_P (nnext))\n \tnext = nnext;\n \n-      /* Again, don't depend an insn on itself.  */\n-      if (insn == next)\n-\treturn;\n+      if (insn != next)\n+\tadd_dependence (insn, next, REG_DEP_ANTI);\n \n-      /* Make the dependence to NEXT, the last insn of the group, instead\n-         of the original ELEM.  */\n-      elem = next;\n     }\n \n+\n   present_p = 1;\n #ifdef INSN_SCHEDULING\n   /* ??? No good way to tell from here whether we're doing interblock\n@@ -384,76 +380,6 @@ add_dependence_list_and_free (insn, listp, dep_type)\n     }\n }\n \n-/* Remove ELEM wrapped in an INSN_LIST from the LOG_LINKS\n-   of INSN.  Abort if not found.  */\n-\n-static void\n-remove_dependence (insn, elem)\n-     rtx insn;\n-     rtx elem;\n-{\n-  rtx prev, link, next;\n-  int found = 0;\n-\n-  for (prev = 0, link = LOG_LINKS (insn); link; link = next)\n-    {\n-      next = XEXP (link, 1);\n-      if (XEXP (link, 0) == elem)\n-\t{\n-\t  if (prev)\n-\t    XEXP (prev, 1) = next;\n-\t  else\n-\t    LOG_LINKS (insn) = next;\n-\n-#ifdef INSN_SCHEDULING\n-\t  /* If we are removing a dependency from the LOG_LINKS list,\n-\t     make sure to remove it from the cache too.  */\n-\t  if (true_dependency_cache != NULL)\n-\t    {\n-\t      if (REG_NOTE_KIND (link) == 0)\n-\t\tRESET_BIT (true_dependency_cache[INSN_LUID (insn)],\n-\t\t\t   INSN_LUID (elem));\n-\t      else if (REG_NOTE_KIND (link) == REG_DEP_ANTI)\n-\t\tRESET_BIT (anti_dependency_cache[INSN_LUID (insn)],\n-\t\t\t   INSN_LUID (elem));\n-\t      else if (REG_NOTE_KIND (link) == REG_DEP_OUTPUT)\n-\t\tRESET_BIT (output_dependency_cache[INSN_LUID (insn)],\n-\t\t\t   INSN_LUID (elem));\n-\t    }\n-#endif\n-\n-\t  free_INSN_LIST_node (link);\n-\n-\t  found = 1;\n-\t}\n-      else\n-\tprev = link;\n-    }\n-\n-  if (!found)\n-    abort ();\n-  return;\n-}\n-\n-/* Return an insn which represents a SCHED_GROUP, which is\n-   the last insn in the group.  */\n-\n-static rtx\n-group_leader (insn)\n-     rtx insn;\n-{\n-  rtx prev;\n-\n-  do\n-    {\n-      prev = insn;\n-      insn = next_nonnote_insn (insn);\n-    }\n-  while (insn && INSN_P (insn) && SCHED_GROUP_P (insn));\n-\n-  return prev;\n-}\n-\n /* Set SCHED_GROUP_P and care for the rest of the bookkeeping that\n    goes along with that.  */\n \n@@ -465,21 +391,21 @@ set_sched_group_p (insn)\n \n   SCHED_GROUP_P (insn) = 1;\n \n-  /* There may be a note before this insn now, but all notes will\n-     be removed before we actually try to schedule the insns, so\n-     it won't cause a problem later.  We must avoid it here though.  */\n+  for (link = LOG_LINKS (insn); link; link = XEXP (link, 1))\n+    {\n+      prev = insn;\n+      do\n+\t{\n+\t  prev = prev_nonnote_insn (prev);\n+\t  if (XEXP (link, 0) == prev)\n+\t    break;\n+\t}\n+      while (SCHED_GROUP_P (prev));\n+      if (XEXP (link, 0) != prev)\n+\tadd_dependence (prev, XEXP (link, 0), REG_DEP_ANTI);\n+    }\n   prev = prev_nonnote_insn (insn);\n-\n-  /* Make a copy of all dependencies on the immediately previous insn,\n-     and add to this insn.  This is so that all the dependencies will\n-     apply to the group.  Remove an explicit dependence on this insn\n-     as SCHED_GROUP_P now represents it.  */\n-\n-  if (find_insn_list (prev, LOG_LINKS (insn)))\n-    remove_dependence (insn, prev);\n-\n-  for (link = LOG_LINKS (prev); link; link = XEXP (link, 1))\n-    add_dependence (insn, XEXP (link, 0), REG_NOTE_KIND (link));\n+  add_dependence (insn, prev, REG_DEP_ANTI);\n }\n \f\n /* Process an insn's memory dependencies.  There are four kinds of\n@@ -983,7 +909,15 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n \t  INIT_REG_SET (&tmp);\n \n \t  (*current_sched_info->compute_jump_reg_dependencies) (insn, &tmp);\n-\t  IOR_REG_SET (reg_pending_uses, &tmp);\n+\t  /* Make latency of jump equal to 0 by using anti-dependence.  */\n+\t  EXECUTE_IF_SET_IN_REG_SET (&tmp, 0, i,\n+\t    {\n+\t      struct deps_reg *reg_last = &deps->reg_last[i];\n+\t      add_dependence_list (insn, reg_last->sets, REG_DEP_ANTI);\n+\t      add_dependence_list (insn, reg_last->clobbers, REG_DEP_ANTI);\n+\t      reg_last->uses_length++;\n+\t      reg_last->uses = alloc_INSN_LIST (insn, reg_last->uses);\n+\t    });\n \t  CLEAR_REG_SET (&tmp);\n \n \t  /* All memory writes and volatile reads must happen before the\n@@ -1049,14 +983,16 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n   /* Add dependencies if a scheduling barrier was found.  */\n   if (reg_pending_barrier)\n     {\n+      /* In the case of barrier the most added dependencies are not\n+         real, so we use anti-dependence here.  */\n       if (GET_CODE (PATTERN (insn)) == COND_EXEC)\n \t{\n \t  EXECUTE_IF_SET_IN_REG_SET (&deps->reg_last_in_use, 0, i,\n \t    {\n \t      struct deps_reg *reg_last = &deps->reg_last[i];\n \t      add_dependence_list (insn, reg_last->uses, REG_DEP_ANTI);\n-\t      add_dependence_list (insn, reg_last->sets, 0);\n-\t      add_dependence_list (insn, reg_last->clobbers, 0);\n+\t      add_dependence_list (insn, reg_last->sets, REG_DEP_ANTI);\n+\t      add_dependence_list (insn, reg_last->clobbers, REG_DEP_ANTI);\n \t    });\n \t}\n       else\n@@ -1066,8 +1002,10 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n \t      struct deps_reg *reg_last = &deps->reg_last[i];\n \t      add_dependence_list_and_free (insn, &reg_last->uses,\n \t\t\t\t\t    REG_DEP_ANTI);\n-\t      add_dependence_list_and_free (insn, &reg_last->sets, 0);\n-\t      add_dependence_list_and_free (insn, &reg_last->clobbers, 0);\n+\t      add_dependence_list_and_free (insn, &reg_last->sets,\n+\t\t\t\t\t    REG_DEP_ANTI);\n+\t      add_dependence_list_and_free (insn, &reg_last->clobbers,\n+\t\t\t\t\t    REG_DEP_ANTI);\n \t      reg_last->uses_length = 0;\n \t      reg_last->clobbers_length = 0;\n \t    });\n@@ -1432,11 +1370,9 @@ compute_forward_dependences (head, tail)\n       if (! INSN_P (insn))\n \tcontinue;\n \n-      insn = group_leader (insn);\n-\n       for (link = LOG_LINKS (insn); link; link = XEXP (link, 1))\n \t{\n-\t  rtx x = group_leader (XEXP (link, 0));\n+\t  rtx x = XEXP (link, 0);\n \t  rtx new_link;\n \n \t  if (x != XEXP (link, 0))"}, {"sha": "29189a68d0c6f4441cbf717f52d7a8aa01461a73", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=30028c85159c12c4e8920af0a9111372e56f1636", "patch": "@@ -40,6 +40,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"recog.h\"\n #include \"cfglayout.h\"\n #include \"sched-int.h\"\n+#include \"target.h\"\n \f\n /* The number of insns to be scheduled in total.  */\n static int target_n_insns;\n@@ -89,14 +90,7 @@ init_ready_list (ready)\n      Count number of insns in the target block being scheduled.  */\n   for (insn = NEXT_INSN (prev_head); insn != next_tail; insn = NEXT_INSN (insn))\n     {\n-      rtx next;\n-\n-      if (! INSN_P (insn))\n-\tcontinue;\n-      next = NEXT_INSN (insn);\n-\n-      if (INSN_DEP_COUNT (insn) == 0\n-\t  && (! INSN_P (next) || SCHED_GROUP_P (next) == 0))\n+      if (INSN_DEP_COUNT (insn) == 0)\n \tready_add (ready, insn);\n       if (!(SCHED_GROUP_P (insn)))\n \ttarget_n_insns++;\n@@ -222,6 +216,9 @@ schedule_ebb (head, tail)\n   /* Compute INSN_DEPEND.  */\n   compute_forward_dependences (head, tail);\n \n+  if (targetm.sched.dependencies_evaluation_hook)\n+    targetm.sched.dependencies_evaluation_hook (head, tail);\n+\n   /* Set priorities.  */\n   n_insns = set_priorities (head, tail);\n "}, {"sha": "36a53f73c26162bc35f7f299dcfb5395b59791ba", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 12, "deletions": 52, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=30028c85159c12c4e8920af0a9111372e56f1636", "patch": "@@ -2023,17 +2023,9 @@ init_ready_list (ready)\n      Count number of insns in the target block being scheduled.  */\n   for (insn = NEXT_INSN (prev_head); insn != next_tail; insn = NEXT_INSN (insn))\n     {\n-      rtx next;\n-\n-      if (! INSN_P (insn))\n-\tcontinue;\n-      next = NEXT_INSN (insn);\n-\n-      if (INSN_DEP_COUNT (insn) == 0\n-\t  && (! INSN_P (next) || SCHED_GROUP_P (next) == 0))\n+      if (INSN_DEP_COUNT (insn) == 0)\n \tready_add (ready, insn);\n-      if (!(SCHED_GROUP_P (insn)))\n-\ttarget_n_insns++;\n+      target_n_insns++;\n     }\n \n   /* Add to ready list all 'ready' insns in valid source blocks.\n@@ -2067,19 +2059,8 @@ init_ready_list (ready)\n \t\t\t\t\t\t\t     insn, insn) <= 3)))\n \t\t\t&& check_live (insn, bb_src)\n \t\t\t&& is_exception_free (insn, bb_src, target_bb))))\n-\t      {\n-\t\trtx next;\n-\n-\t\t/* Note that we haven't squirreled away the notes for\n-\t\t   blocks other than the current.  So if this is a\n-\t\t   speculative insn, NEXT might otherwise be a note.  */\n-\t\tnext = next_nonnote_insn (insn);\n-\t\tif (INSN_DEP_COUNT (insn) == 0\n-\t\t    && (! next\n-\t\t\t|| ! INSN_P (next)\n-\t\t\t|| SCHED_GROUP_P (next) == 0))\n-\t\t  ready_add (ready, insn);\n-\t      }\n+\t      if (INSN_DEP_COUNT (insn) == 0)\n+\t\tready_add (ready, insn);\n \t  }\n       }\n }\n@@ -2097,7 +2078,6 @@ can_schedule_ready_p (insn)\n   /* An interblock motion?  */\n   if (INSN_BB (insn) != target_bb)\n     {\n-      rtx temp;\n       basic_block b1;\n \n       if (IS_SPECULATIVE_INSN (insn))\n@@ -2114,18 +2094,9 @@ can_schedule_ready_p (insn)\n \t}\n       nr_inter++;\n \n-      /* Find the beginning of the scheduling group.  */\n-      /* ??? Ought to update basic block here, but later bits of\n-\t schedule_block assumes the original insn block is\n-\t still intact.  */\n-\n-      temp = insn;\n-      while (SCHED_GROUP_P (temp))\n-\ttemp = PREV_INSN (temp);\n-\n       /* Update source block boundaries.  */\n-      b1 = BLOCK_FOR_INSN (temp);\n-      if (temp == b1->head && insn == b1->end)\n+      b1 = BLOCK_FOR_INSN (insn);\n+      if (insn == b1->head && insn == b1->end)\n \t{\n \t  /* We moved all the insns in the basic block.\n \t     Emit a note after the last insn and update the\n@@ -2139,9 +2110,9 @@ can_schedule_ready_p (insn)\n \t  /* We took insns from the end of the basic block,\n \t     so update the end of block boundary so that it\n \t     points to the first insn we did not move.  */\n-\t  b1->end = PREV_INSN (temp);\n+\t  b1->end = PREV_INSN (insn);\n \t}\n-      else if (temp == b1->head)\n+      else if (insn == b1->head)\n \t{\n \t  /* We took insns from the start of the basic block,\n \t     so update the start of block boundary so that\n@@ -2361,17 +2332,6 @@ add_branch_dependences (head, tail)\n \t  CANT_MOVE (insn) = 1;\n \n \t  last = insn;\n-\t  /* Skip over insns that are part of a group.\n-\t     Make each insn explicitly depend on the previous insn.\n-\t     This ensures that only the group header will ever enter\n-\t     the ready queue (and, when scheduled, will automatically\n-\t     schedule the SCHED_GROUP_P block).  */\n-\t  while (SCHED_GROUP_P (insn))\n-\t    {\n-\t      rtx temp = prev_nonnote_insn (insn);\n-\t      add_dependence (insn, temp, REG_DEP_ANTI);\n-\t      insn = temp;\n-\t    }\n \t}\n \n       /* Don't overrun the bounds of the basic block.  */\n@@ -2393,10 +2353,6 @@ add_branch_dependences (head, tail)\n \n \tadd_dependence (last, insn, REG_DEP_ANTI);\n \tINSN_REF_COUNT (insn) = 1;\n-\n-\t/* Skip over insns that are part of a group.  */\n-\twhile (SCHED_GROUP_P (insn))\n-\t  insn = prev_nonnote_insn (insn);\n       }\n }\n \n@@ -2728,6 +2684,10 @@ schedule_region (rgn)\n       get_block_head_tail (BB_TO_BLOCK (bb), &head, &tail);\n \n       compute_forward_dependences (head, tail);\n+\n+      if (targetm.sched.dependencies_evaluation_hook)\n+\ttargetm.sched.dependencies_evaluation_hook (head, tail);\n+\n     }\n \n   /* Set priorities.  */"}, {"sha": "0cf463b9ce54be7afb3087a62b11f18f7c28b647", "filename": "gcc/target-def.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=30028c85159c12c4e8920af0a9111372e56f1636", "patch": "@@ -194,12 +194,15 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #define TARGET_SCHED_FINISH 0\n #define TARGET_SCHED_REORDER 0\n #define TARGET_SCHED_REORDER2 0\n+#define TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK 0\n #define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE 0\n #define TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN 0\n #define TARGET_SCHED_DFA_PRE_CYCLE_INSN 0\n #define TARGET_SCHED_INIT_DFA_POST_CYCLE_INSN 0\n #define TARGET_SCHED_DFA_POST_CYCLE_INSN 0\n #define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD 0\n+#define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD 0\n+#define TARGET_SCHED_DFA_NEW_CYCLE 0\n #define TARGET_SCHED_INIT_DFA_BUBBLES 0\n #define TARGET_SCHED_DFA_BUBBLE 0\n \n@@ -212,12 +215,15 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n    TARGET_SCHED_FINISH,\t\t\t\t\t\t\\\n    TARGET_SCHED_REORDER,\t\t\t\t\t\\\n    TARGET_SCHED_REORDER2,\t\t\t\t\t\\\n+   TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK,\t\t\t\\\n    TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE,\t\t\t\\\n    TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN,\t\t\t\\\n    TARGET_SCHED_DFA_PRE_CYCLE_INSN,\t\t\t\t\\\n    TARGET_SCHED_INIT_DFA_POST_CYCLE_INSN,\t\t\t\\\n    TARGET_SCHED_DFA_POST_CYCLE_INSN,\t\t\t\t\\\n    TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD,\t\t\\\n+   TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD,\t\\\n+   TARGET_SCHED_DFA_NEW_CYCLE,\t\t\t\t\t\\\n    TARGET_SCHED_INIT_DFA_BUBBLES,\t\t\t\t\\\n    TARGET_SCHED_DFA_BUBBLE}\n "}, {"sha": "770830079c1e34f8f10659bca47ff377bb1dde95", "filename": "gcc/target.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30028c85159c12c4e8920af0a9111372e56f1636/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=30028c85159c12c4e8920af0a9111372e56f1636", "patch": "@@ -177,6 +177,11 @@ struct gcc_target\n     int (* reorder)  PARAMS ((FILE *, int, rtx *, int *, int));\n     int (* reorder2) PARAMS ((FILE *, int, rtx *, int *, int));\n \n+    /* The following member value is a pointer to a function called\n+       after evaluation forward dependencies of insns in chain given\n+       by two parameter values (head and tail correspondingly).  */\n+    void (* dependencies_evaluation_hook) PARAMS ((rtx, rtx));\n+\n     /* The following member value is a pointer to a function returning\n        nonzero if we should use DFA based scheduling.  The default is\n        to use the old pipeline scheduler.  */\n@@ -206,6 +211,25 @@ struct gcc_target\n        try to choose ready insn which permits to start maximum number of\n        insns on the same cycle.  */\n     int (* first_cycle_multipass_dfa_lookahead) PARAMS ((void));\n+    /* The following member value is pointer to a function controlling\n+       what insns from the ready insn queue will be considered for the\n+       multipass insn scheduling.  If the hook returns zero for insn\n+       passed as the parameter, the insn will be not chosen to be\n+       issued.  */\n+    int (* first_cycle_multipass_dfa_lookahead_guard) PARAMS ((rtx));\n+    /* The following member value is pointer to a function called by\n+       the insn scheduler before issuing insn passed as the third\n+       parameter on given cycle.  If the hook returns nonzero, the\n+       insn is not issued on given processors cycle.  Instead of that,\n+       the processor cycle is advanced.  If the value passed through\n+       the last parameter is zero, the insn ready queue is not sorted\n+       on the new cycle start as usually.  The first parameter passes\n+       file for debugging output.  The second one passes the scheduler\n+       verbose level of the debugging output.  The forth and the fifth\n+       parameter values are correspondingly processor cycle on which\n+       the previous insn has been issued and the current processor\n+       cycle.  */\n+    int (* dfa_new_cycle) PARAMS ((FILE *, int, rtx, int, int, int *));\n     /* The values of the following members are pointers to functions\n        used to improve the first cycle multipass scheduling by\n        inserting nop insns.  dfa_scheduler_bubble gives a function"}]}