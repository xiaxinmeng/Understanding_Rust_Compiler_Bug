{"sha": "9923cc566f10f6f44612351d3e4e73c3cee0e38f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTkyM2NjNTY2ZjEwZjZmNDQ2MTIzNTFkM2U0ZTczYzNjZWUwZTM4Zg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-07-13T10:54:01Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-07-13T10:54:01Z"}, "message": "cplus-dem.c: Incorporate changes from GCC version not present in the libiberty version.\n\n\t* cplus-dem.c: Incorporate changes from GCC version not present in\n\tthe libiberty version.\n\nFrom-SVN: r21101", "tree": {"sha": "46efcb7a189c30cfd1760ca97a6db3bea02e1dca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46efcb7a189c30cfd1760ca97a6db3bea02e1dca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9923cc566f10f6f44612351d3e4e73c3cee0e38f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9923cc566f10f6f44612351d3e4e73c3cee0e38f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9923cc566f10f6f44612351d3e4e73c3cee0e38f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9923cc566f10f6f44612351d3e4e73c3cee0e38f/comments", "author": null, "committer": null, "parents": [{"sha": "c78ea26788708f5ed39e269f256862a679995f39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c78ea26788708f5ed39e269f256862a679995f39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c78ea26788708f5ed39e269f256862a679995f39"}], "stats": {"total": 382, "additions": 258, "deletions": 124}, "files": [{"sha": "3695690f3f75869815580281aa8efcab7b54e581", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9923cc566f10f6f44612351d3e4e73c3cee0e38f/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9923cc566f10f6f44612351d3e4e73c3cee0e38f/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=9923cc566f10f6f44612351d3e4e73c3cee0e38f", "patch": "@@ -1,3 +1,8 @@\n+1998-07-13  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* cplus-dem.c: Incorporate changes from GCC version not present in\n+\tthe libiberty version.\n+\n Sat May 30 22:17:13 1998  Mumit Khan  <khan@xraylith.wisc.edu>\n \n \t* configure.in (checkfuncs): Add missing \"'\"."}, {"sha": "c754734f0776c6df02e86684620a3c642823388f", "filename": "libiberty/cplus-dem.c", "status": "modified", "additions": 253, "deletions": 124, "changes": 377, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9923cc566f10f6f44612351d3e4e73c3cee0e38f/libiberty%2Fcplus-dem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9923cc566f10f6f44612351d3e4e73c3cee0e38f/libiberty%2Fcplus-dem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcplus-dem.c?ref=9923cc566f10f6f44612351d3e4e73c3cee0e38f", "patch": "@@ -1,5 +1,5 @@\n /* Demangler for GNU C++ \n-   Copyright 1989, 1991, 1994, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   Copyright 1989, 1991, 1994, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.\n    Written by James Clark (jjc@jclark.uucp)\n    Rewritten by Fred Fish (fnf@cygnus.com) for ARM and Lucid demangling\n    \n@@ -94,6 +94,13 @@ set_cplus_marker_for_demangling (ch)\n   cplus_markers[0] = ch;\n }\n \n+typedef struct string\t\t/* Beware: these aren't required to be */\n+{\t\t\t\t/*  '\\0' terminated.  */\n+  char *b;\t\t\t/* pointer to start of string */\n+  char *p;\t\t\t/* pointer after last character */\n+  char *e;\t\t\t/* pointer after end of allocated space */\n+} string;\n+\n /* Stuff that is shared between sub-routines.\n    Using a shared structure allows cplus_demangle to be reentrant.  */\n \n@@ -113,8 +120,14 @@ struct work_stuff\n   int destructor;\n   int static_type;\t/* A static member function */\n   int const_type;\t/* A const member function */\n+  int volatile_type;    /* A volatile member function */\n   char **tmpl_argvec;   /* Template function arguments. */\n   int ntmpl_args;       /* The number of template function arguments. */\n+  int forgetting_types; /* Nonzero if we are not remembering the types\n+\t\t\t   we see.  */\n+  string* previous_argument; /* The last function argument demangled.  */\n+  int nrepeats;         /* The number of times to repeat the previous\n+\t\t\t   argument.  */\n };\n \n #define PRINT_ANSI_QUALIFIERS (work -> options & DMGL_ANSI)\n@@ -208,20 +221,16 @@ static const struct optable\n };\n \n \n-typedef struct string\t\t/* Beware: these aren't required to be */\n-{\t\t\t\t/*  '\\0' terminated.  */\n-  char *b;\t\t\t/* pointer to start of string */\n-  char *p;\t\t\t/* pointer after last character */\n-  char *e;\t\t\t/* pointer after end of allocated space */\n-} string;\n-\n #define STRING_EMPTY(str)\t((str) -> b == (str) -> p)\n #define PREPEND_BLANK(str)\t{if (!STRING_EMPTY(str)) \\\n     string_prepend(str, \" \");}\n #define APPEND_BLANK(str)\t{if (!STRING_EMPTY(str)) \\\n     string_append(str, \" \");}\n #define LEN_STRING(str)         ( (STRING_EMPTY(str))?0:((str)->p - (str)->b))\n \n+/* The scope separator appropriate for the language being demangled.  */\n+#define SCOPE_STRING(work) \"::\"\n+\n #define ARM_VTABLE_STRING \"__vtbl__\"\t/* Lucid/ARM virtual table prefix */\n #define ARM_VTABLE_STRLEN 8\t\t/* strlen (ARM_VTABLE_STRING) */\n \n@@ -247,7 +256,7 @@ demangle_template_template_parm PARAMS ((struct work_stuff *work,\n \n static int\n demangle_template PARAMS ((struct work_stuff *work, const char **, string *,\n-\t\t\t   string *, int));\n+\t\t\t   string *, int, int));\n \n static int\n arm_pt PARAMS ((struct work_stuff *, const char *, int, const char **,\n@@ -325,6 +334,9 @@ consume_count_with_underscores PARAMS ((const char**));\n static int\n demangle_args PARAMS ((struct work_stuff *, const char **, string *));\n \n+static int\n+demangle_nested_args PARAMS ((struct work_stuff*, const char**, string*));\n+\n static int\n do_type PARAMS ((struct work_stuff *, const char **, string *));\n \n@@ -632,12 +644,15 @@ internal_cplus_demangle (work, mangled)\n   int success = 0;\n   char *demangled = NULL;\n   int s1,s2,s3,s4;\n+  int saved_volatile_type;\n   s1 = work->constructor;\n   s2 = work->destructor;\n   s3 = work->static_type;\n   s4 = work->const_type;\n+  saved_volatile_type = work->volatile_type;\n   work->constructor = work->destructor = 0;\n   work->static_type = work->const_type = 0;\n+  work->volatile_type = 0;\n \n   if ((mangled != NULL) && (*mangled != '\\0'))\n     {\n@@ -678,6 +693,7 @@ internal_cplus_demangle (work, mangled)\n   work->destructor = s2;\n   work->static_type = s3;\n   work->const_type = s4;\n+  work->volatile_type = saved_volatile_type;\n   return (demangled);\n }\n \n@@ -728,6 +744,11 @@ mop_up (work, declp, success)\n       free ((char*) work->tmpl_argvec);\n       work->tmpl_argvec = NULL;\n     }\n+  if (work->previous_argument)\n+    {\n+      string_delete (work->previous_argument);\n+      free ((char*) work->previous_argument);\n+    }\n \n   /* If demangling was successful, ensure that the demangled string is null\n      terminated and return it.  Otherwise, free the demangling decl.  */\n@@ -796,13 +817,9 @@ demangle_signature (work, mangled, declp)\n \t  oldmangled = *mangled;\n \t  success = demangle_qualified (work, mangled, declp, 1, 0);\n \t  if (success)\n-\t    {\n-\t      remember_type (work, oldmangled, *mangled - oldmangled);\n-\t    }\n+\t    remember_type (work, oldmangled, *mangled - oldmangled);\n \t  if (AUTO_DEMANGLING || GNU_DEMANGLING)\n-\t    {\n-\t      expect_func = 1;\n-\t    }\n+\t    expect_func = 1;\n \t  oldmangled = NULL;\n \t  break;\n \n@@ -827,13 +844,16 @@ demangle_signature (work, mangled, declp)\n \t  break;\n \n \tcase 'C':\n-\t  /* a const member function */\n+\tcase 'V':\n+\t  if (**mangled == 'C')\n+\t    work -> const_type = 1;\n+\t  else\n+\t    work->volatile_type = 1;\n+\n+\t  /* a qualified member function */\n \t  if (oldmangled == NULL)\n-\t    {\n-\t      oldmangled = *mangled;\n-\t    }\n+\t    oldmangled = *mangled;\n \t  (*mangled)++;\n-\t  work -> const_type = 1;\n \t  break;\n \t  \n \tcase '0': case '1': case '2': case '3': case '4':\n@@ -853,7 +873,21 @@ demangle_signature (work, mangled, declp)\n \t    }\n \t  oldmangled = NULL;\n \t  break;\n-\t  \n+\n+\tcase 'B':\n+\t  {\n+\t    string s;\n+\t    success = do_type (work, mangled, &s);\n+\t    if (success)\n+\t      {\n+\t\tstring_append (&s, SCOPE_STRING (work));\n+\t\tstring_prepends (declp, &s);\n+\t      }\n+\t    oldmangled = NULL;\n+\t    expect_func = 1;\n+\t  }\n+\t  break;\n+\n \tcase 'F':\n \t  /* Function */\n \t  /* ARM style demangling includes a specific 'F' character after\n@@ -885,13 +919,13 @@ demangle_signature (work, mangled, declp)\n \t    {\n \t      oldmangled = *mangled;\n \t    }\n-\t  success = demangle_template (work, mangled, &tname, &trawname, 1);\n+\t  success = demangle_template (work, mangled, &tname,\n+\t\t\t\t       &trawname, 1, 1);\n \t  if (success)\n \t    {\n \t      remember_type (work, oldmangled, *mangled - oldmangled);\n \t    }\n-\t    string_append (&tname, \"::\");\n-\n+\t  string_append(&tname, SCOPE_STRING (work));\n \t  string_prepends(declp, &tname);\n \t  if (work -> destructor & 1)\n \t    {\n@@ -938,7 +972,8 @@ demangle_signature (work, mangled, declp)\n \t  if (GNU_DEMANGLING) \n \t    {\n \t      /* A G++ template function.  Read the template arguments. */\n-\t      success = demangle_template (work, mangled, declp, 0, 0);\n+\t      success = demangle_template (work, mangled, declp, 0, 0,\n+\t\t\t\t\t   0);\n \t      if (!(work->constructor & 1))\n \t\texpect_return_type = 1;\n \t      (*mangled)++;\n@@ -995,13 +1030,12 @@ demangle_signature (work, mangled, declp)\n \t}\n     }\n   if (success && work -> static_type && PRINT_ARG_TYPES)\n-    {\n-      string_append (declp, \" static\");\n-    }\n+    string_append (declp, \" static\");\n   if (success && work -> const_type && PRINT_ARG_TYPES)\n-    {\n-      string_append (declp, \" const\");\n-    }\n+    string_append (declp, \" const\");\n+  else if (success && work->volatile_type && PRINT_ARG_TYPES)\n+    string_append (declp, \" volatile\");\n+\n   return (success);\n }\n \n@@ -1213,12 +1247,10 @@ demangle_template_value_parm (work, mangled, s)\n \t  continue;\n \tcase 'E':       /* expression */\n \tcase 'Q':\t/* qualified name */\n-\tcase 'K':\t/* qualified name */\n-\t  done = is_integral = 1;\n-\t  break;\n-\tcase 'B':\t/* squangled name */\n+\tcase 'K':       /* qualified name */\n \t  done = is_integral = 1;\n \t  break;\n+\tcase 'B':\t/* remembered type */\n \tcase 'T':\t/* remembered type */\n \t  abort ();\n \t  break;\n@@ -1362,24 +1394,36 @@ demangle_template_value_parm (work, mangled, s)\n   return success;\n }\n \n+/* Demangle the template name in MANGLED.  The full name of the\n+   template (e.g., S<int>) is placed in TNAME.  The name without the\n+   template parameters (e.g. S) is placed in TRAWNAME if TRAWNAME is\n+   non-NULL.  If IS_TYPE is nonzero, this template is a type template,\n+   not a function template.  If both IS_TYPE and REMEMBER are nonzero,\n+   the tmeplate is remembered in the list of back-referenceable\n+   types.  */\n+\n static int\n-demangle_template (work, mangled, tname, trawname, is_type)\n+demangle_template (work, mangled, tname, trawname, is_type, remember)\n      struct work_stuff *work;\n      const char **mangled;\n      string *tname;\n      string *trawname;\n      int is_type;\n+     int remember;\n {\n   int i;\n   int r;\n   int need_comma = 0;\n   int success = 0;\n   const char *start;\n   string temp;\n+  int bindex;\n \n   (*mangled)++;\n   if (is_type)\n     {\n+      if (remember)\n+\tbindex = register_Btype (work);\n       start = *mangled;\n       /* get template name */\n       if (**mangled == 'z')\n@@ -1392,9 +1436,8 @@ demangle_template (work, mangled, tname, trawname, is_type)\n \t  if (idx == -1 \n \t      || (work->tmpl_argvec && idx >= work->ntmpl_args)\n \t      || consume_count_with_underscores (mangled) == -1)\n-\t    {\n-\t      return (0);\n-\t    }\n+\t    return (0);\n+\n \t  if (work->tmpl_argvec)\n \t    {\n \t      string_append (tname, work->tmpl_argvec[idx]);\n@@ -1407,7 +1450,7 @@ demangle_template (work, mangled, tname, trawname, is_type)\n \t      sprintf(buf, \"T%d\", idx);\n \t      string_append (tname, buf);\n \t      if (trawname)\n-\t\tstring_append (trawname, work->tmpl_argvec[idx]);\n+\t\tstring_append (trawname, buf);\n \t    }\n \t}\n       else\n@@ -1416,13 +1459,13 @@ demangle_template (work, mangled, tname, trawname, is_type)\n \t    {\n \t      return (0);\n \t    }\n+\t  string_appendn (tname, *mangled, r);\n \t  if (trawname)\n \t    string_appendn (trawname, *mangled, r);\n-\t      string_appendn (tname, *mangled, r);\n \t  *mangled += r;\n \t}\n     }\n-    string_append (tname, \"<\");\n+  string_append (tname, \"<\");\n   /* get size of template parameter list */\n   if (!get_count (mangled, &r))\n     {\n@@ -1549,12 +1592,13 @@ demangle_template (work, mangled, tname, trawname, is_type)\n \t}\n       need_comma = 1;\n     }\n-    {\n-      if (tname->p[-1] == '>')\n-\tstring_append (tname, \" \");\n-      string_append (tname, \">\");\n-    }\n+  if (tname->p[-1] == '>')\n+    string_append (tname, \" \");\n+  string_append (tname, \">\");\n   \n+  if (is_type && remember)\n+    remember_Btype (work, tname->b, LEN_STRING (tname), bindex);\n+\n   /*\n     if (work -> static_type)\n     {\n@@ -1712,7 +1756,7 @@ demangle_class (work, mangled, declp)\n \t}\n       remember_Ktype (work, class_name.b, LEN_STRING(&class_name));\n       remember_Btype (work, class_name.b, LEN_STRING(&class_name), btype);\n-\tstring_prepend (declp, \"::\");\n+      string_prepend (declp, SCOPE_STRING (work));\n       string_prepends (declp, &class_name);\n       success = 1;\n     }\n@@ -1986,7 +2030,8 @@ gnu_special (work, mangled, declp)\n \t      success = demangle_qualified (work, mangled, declp, 0, 1);\n \t      break;\n \t    case 't':\n-\t      success = demangle_template (work, mangled, declp, 0, 1);\n+\t      success = demangle_template (work, mangled, declp, 0, 1,\n+\t\t\t\t\t   1);\n \t      break;\n \t    default:\n \t      if (isdigit(*mangled[0]))\n@@ -2014,7 +2059,7 @@ gnu_special (work, mangled, declp)\n \t    {\n \t      if (p != NULL)\n \t\t{\n-\t\t    string_append (declp, \"::\");\n+\t\t  string_append (declp, SCOPE_STRING (work));\n \t\t  (*mangled)++;\n \t\t}\n \t    }\n@@ -2040,7 +2085,7 @@ gnu_special (work, mangled, declp)\n \t  success = demangle_qualified (work, mangled, declp, 0, 1);\n \t  break;\n \tcase 't':\n-\t  success = demangle_template (work, mangled, declp, 0, 1);\n+\t  success = demangle_template (work, mangled, declp, 0, 1, 1);\n \t  break;\n \tdefault:\n \t  n = consume_count (mangled);\n@@ -2052,7 +2097,7 @@ gnu_special (work, mangled, declp)\n \t  /* Consumed everything up to the cplus_marker, append the\n \t     variable name.  */\n \t  (*mangled)++;\n-\t    string_append (declp, \"::\");\n+\t  string_append (declp, SCOPE_STRING (work));\n \t  n = strlen (*mangled);\n \t  string_appendn (declp, *mangled, n);\n \t  (*mangled) += n;\n@@ -2093,7 +2138,7 @@ gnu_special (work, mangled, declp)\n \t  success = demangle_qualified (work, mangled, declp, 0, 1);\n \t  break;\n \tcase 't':\n-\t  success = demangle_template (work, mangled, declp, 0, 1);\n+\t  success = demangle_template (work, mangled, declp, 0, 1, 1);\n \t  break;\n \tdefault:\n \t  success = demangle_fund_type (work, mangled, declp);\n@@ -2225,13 +2270,20 @@ demangle_qualified (work, mangled, result, isfuncname, append)\n      int append;\n {\n   int qualifiers = 0;\n-  int namelength;\n   int success = 1;\n   const char *p;\n   char num[2];\n   string temp;\n+  string last_name;\n+  int bindex = register_Btype (work);\n+\n+  /* We only make use of ISFUNCNAME if the entity is a constructor or\n+     destructor.  */\n+  isfuncname = (isfuncname \n+\t\t&& ((work->constructor & 1) || (work->destructor & 1)));\n \n   string_init (&temp);\n+  string_init (&last_name);\n \n   if ((*mangled)[0] == 'K')\n     {\n@@ -2304,18 +2356,24 @@ demangle_qualified (work, mangled, result, isfuncname, append)\n   while (qualifiers-- > 0)\n     {\n       int remember_K = 1;\n+      string_clear (&last_name);\n+\n       if (*mangled[0] == '_') \n-\t*mangled = *mangled + 1;\n+\t(*mangled)++;\n+\n       if (*mangled[0] == 't')\n \t{\n-\t  success = demangle_template(work, mangled, &temp, 0, 1);\n-\t  if (!success) break;\n-\t}\n-      else if (*mangled[0] == 'X')\n-\t{\n-\t  success = do_type (work, mangled, &temp);\n-\t  if (!success) break;\n-\t}\n+\t  /* Here we always append to TEMP since we will want to use\n+\t     the template name without the template parameters as a\n+\t     constructor or destructor name.  The appropriate\n+\t     (parameter-less) value is returned by demangle_template\n+\t     in LAST_NAME.  We do not remember the template type here,\n+\t     in order to match the G++ mangling algorithm.  */\n+\t  success = demangle_template(work, mangled, &temp, \n+\t\t\t\t      &last_name, 1, 0);\n+\t  if (!success) \n+\t    break;\n+\t} \n       else if (*mangled[0] == 'K')\n \t{\n           int idx;\n@@ -2330,60 +2388,48 @@ demangle_qualified (work, mangled, result, isfuncname, append)\n \t  if (!success) break;\n \t}\n       else\n-        {\t\n-\t  namelength = consume_count (mangled);\n-      \t  if (strlen (*mangled) < namelength)\n-\t    {\n-\t      /* Simple sanity check failed */\n-\t      success = 0;\n-\t      break;\n-\t    }\n-      \t  string_appendn (&temp, *mangled, namelength);\n-      \t  *mangled += namelength;\n+\t{\n+\t  success = do_type (work, mangled, &last_name);\n+\t  if (!success)\n+\t    break;\n+\t  string_appends (&temp, &last_name);\n \t}\n \n       if (remember_K)\n-        {\n-        remember_Ktype (work, temp.b, LEN_STRING (&temp));\n-        }\n+\tremember_Ktype (work, temp.b, LEN_STRING (&temp));\n \n       if (qualifiers > 0)\n-        {\n-\t    string_append (&temp, \"::\");\n-        }\n+\tstring_append (&temp, SCOPE_STRING (work));\n     }\n \n+  remember_Btype (work, temp.b, LEN_STRING (&temp), bindex);\n+\n   /* If we are using the result as a function name, we need to append\n      the appropriate '::' separated constructor or destructor name.\n      We do this here because this is the most convenient place, where\n      we already have a pointer to the name and the length of the name.  */\n \n-  if (isfuncname && (work->constructor & 1 || work->destructor & 1))\n+  if (isfuncname) \n     {\n-\tstring_append (&temp, \"::\");\n+      string_append (&temp, SCOPE_STRING (work));\n       if (work -> destructor & 1)\n-\t{\n-\t  string_append (&temp, \"~\");\n-\t}\n-      string_appendn (&temp, (*mangled) - namelength, namelength);\n+\tstring_append (&temp, \"~\");\n+      string_appends (&temp, &last_name);\n     }\n \n   /* Now either prepend the temp buffer to the result, or append it, \n      depending upon the state of the append flag.  */\n \n   if (append)\n-    {\n-      string_appends (result, &temp);\n-    }\n+    string_appends (result, &temp);\n   else\n     {\n       if (!STRING_EMPTY (result))\n-\t{\n-\t    string_append (&temp, \"::\");\n-\t}\n+\tstring_append (&temp, SCOPE_STRING (work));\n       string_prepends (result, &temp);\n     }\n \n+  string_delete (&last_name);\n   string_delete (&temp);\n   return (success);\n }\n@@ -2474,7 +2520,7 @@ do_type (work, mangled, result)\n \tcase 'P':\n \tcase 'p':\n \t  (*mangled)++;\n-\t    string_prepend (&decl, \"*\");\n+\t  string_prepend (&decl, \"*\");\n \t  break;\n \n \t  /* A reference type */\n@@ -2530,15 +2576,14 @@ do_type (work, mangled, result)\n \t  /* After picking off the function args, we expect to either find the\n \t     function return type (preceded by an '_') or the end of the\n \t     string.  */\n-\t  if (!demangle_args (work, mangled, &decl)\n+\t  if (!demangle_nested_args (work, mangled, &decl)\n \t      || (**mangled != '_' && **mangled != '\\0'))\n \t    {\n \t      success = 0;\n+\t      break;\n \t    }\n \t  if (success && (**mangled == '_'))\n-\t    {\n-\t      (*mangled)++;\n-\t    }\n+\t    (*mangled)++;\n \t  break;\n \n \tcase 'M':\n@@ -2556,7 +2601,7 @@ do_type (work, mangled, result)\n \t      }\n \n \t    string_append (&decl, \")\");\n-\t      string_prepend (&decl, \"::\");\n+\t    string_prepend (&decl, SCOPE_STRING (work));\n \t    if (isdigit (**mangled)) \n \t      {\n \t\tn = consume_count (mangled);\n@@ -2572,7 +2617,8 @@ do_type (work, mangled, result)\n \t      {\n \t\tstring temp;\n \t\tstring_init (&temp);\n-\t\tsuccess = demangle_template (work, mangled, &temp, NULL, 1);\n+\t\tsuccess = demangle_template (work, mangled, &temp,\n+\t\t\t\t\t     NULL, 1, 1);\n \t\tif (success)\n \t\t  {\n \t\t    string_prependn (&decl, temp.b, temp.p - temp.b);\n@@ -2600,7 +2646,7 @@ do_type (work, mangled, result)\n \t\t    break;\n \t\t  }\n \t      }\n-\t    if ((member && !demangle_args (work, mangled, &decl))\n+\t    if ((member && !demangle_nested_args (work, mangled, &decl))\n \t\t|| **mangled != '_')\n \t      {\n \t\tsuccess = 0;\n@@ -2661,10 +2707,7 @@ do_type (work, mangled, result)\n     case 'Q':\n     case 'K':\n       {\n-        int btype = register_Btype (work);\n         success = demangle_qualified (work, mangled, result, 0, 1);\n-        remember_Btype (work, result->b, LEN_STRING (result), btype);\n-\n         break;\n       }\n \n@@ -2894,9 +2937,7 @@ demangle_fund_type (work, mangled, result)\n       }\n     case 't':\n       {\n-        int bindex= register_Btype (work);\n-        success = demangle_template (work, mangled, &btype, 0, 1);\n-        remember_Btype (work, btype.b, LEN_STRING (&btype), bindex);\n+        success = demangle_template (work, mangled, &btype, 0, 1, 1);\n         string_appends (result, &btype);\n         break;\n       }\n@@ -2908,25 +2949,77 @@ demangle_fund_type (work, mangled, result)\n   return (success);\n }\n \n-/* `result' will be initialized in do_type; it will be freed on failure */\n+/* Demangle the next argument, given by MANGLED into RESULT, which\n+   *should be an uninitialized* string.  It will be initialized here,\n+   and free'd should anything go wrong.  */\n \n static int\n do_arg (work, mangled, result)\n      struct work_stuff *work;\n      const char **mangled;\n      string *result;\n {\n+  /* Remember where we started so that we can record the type, for\n+     non-squangling type remembering.  */\n   const char *start = *mangled;\n \n-  if (!do_type (work, mangled, result))\n+  string_init (result);\n+\n+  if (work->nrepeats > 0)\n     {\n-      return (0);\n+      --work->nrepeats;\n+\n+      if (work->previous_argument == 0)\n+\treturn 0;\n+\n+      /* We want to reissue the previous type in this argument list.  */ \n+      string_appends (result, work->previous_argument);\n+      return 1;\n+    }\n+\n+  if (**mangled == 'n')\n+    {\n+      /* A squangling-style repeat.  */\n+      (*mangled)++;\n+      work->nrepeats = consume_count(mangled);\n+\n+      if (work->nrepeats == 0)\n+\t/* This was not a repeat count after all.  */\n+\treturn 0;\n+\n+      if (work->nrepeats > 9)\n+\t{\n+\t  if (**mangled != '_')\n+\t    /* The repeat count should be followed by an '_' in this\n+\t       case.  */\n+\t    return 0;\n+\t  else\n+\t    (*mangled)++;\n+\t}\n+      \n+      /* Now, the repeat is all set up.  */\n+      return do_arg (work, mangled, result);\n     }\n+\n+  /* Save the result in WORK->previous_argument so that we can find it\n+     if it's repeated.  Note that saving START is not good enough: we\n+     do not want to add additional types to the back-referenceable\n+     type vector when processing a repeated type.  */\n+  if (work->previous_argument)\n+    string_clear (work->previous_argument);\n   else\n     {\n-      remember_type (work, start, *mangled - start);\n-      return (1);\n+      work->previous_argument = (string*) xmalloc (sizeof (string));\n+      string_init (work->previous_argument);\n     }\n+\n+  if (!do_type (work, mangled, work->previous_argument))\n+    return 0;\n+\n+  string_appends (result, work->previous_argument);\n+\n+  remember_type (work, start, *mangled - start);\n+  return 1;\n }\n \n static void\n@@ -2937,6 +3030,9 @@ remember_type (work, start, len)\n {\n   char *tem;\n \n+  if (work->forgetting_types)\n+    return;\n+\n   if (work -> ntypes >= work -> typevec_size)\n     {\n       if (work -> typevec_size == 0)\n@@ -3116,8 +3212,8 @@ forget_types (work)\n      foo__FiR3fooT1T2T1T2\n      __ct__3fooFiR3fooT1T2T1T2\n \n-   Note that g++ bases it's type numbers starting at zero and counts all\n-   previously seen types, while lucid/ARM bases it's type numbers starting\n+   Note that g++ bases its type numbers starting at zero and counts all\n+   previously seen types, while lucid/ARM bases its type numbers starting\n    at one and only considers types after it has seen the 'F' character\n    indicating the start of the function args.  For lucid/ARM style, we\n    account for this difference by discarding any previously seen types when\n@@ -3148,7 +3244,8 @@ demangle_args (work, mangled, declp)\n \t}\n     }\n \n-  while (**mangled != '_' && **mangled != '\\0' && **mangled != 'e')\n+  while ((**mangled != '_' && **mangled != '\\0' && **mangled != 'e')\n+\t || work->nrepeats > 0)\n     {\n       if ((**mangled == 'N') || (**mangled == 'T'))\n \t{\n@@ -3195,7 +3292,7 @@ demangle_args (work, mangled, declp)\n \t    {\n \t      return (0);\n \t    }\n-\t  while (--r >= 0)\n+\t  while (work->nrepeats > 0 || --r >= 0)\n \t    {\n \t      tem = work -> typevec[t];\n \t      if (need_comma && PRINT_ARG_TYPES)\n@@ -3216,18 +3313,12 @@ demangle_args (work, mangled, declp)\n \t}\n       else\n \t{\n-\t  if (need_comma & PRINT_ARG_TYPES)\n-\t    {\n-\t      string_append (declp, \", \");\n-\t    }\n+\t  if (need_comma && PRINT_ARG_TYPES)\n+\t    string_append (declp, \", \");\n \t  if (!do_arg (work, mangled, &arg))\n-\t    {\n-\t      return (0);\n-\t    }\n+\t    return (0);\n \t  if (PRINT_ARG_TYPES)\n-\t    {\n-\t      string_appends (declp, &arg);\n-\t    }\n+\t    string_appends (declp, &arg);\n \t  string_delete (&arg);\n \t  need_comma = 1;\n \t}\n@@ -3253,6 +3344,44 @@ demangle_args (work, mangled, declp)\n   return (1);\n }\n \n+/* Like demangle_args, but for demangling the argument lists of function\n+   and method pointers or references, not top-level declarations.  */\n+\n+int\n+demangle_nested_args (work, mangled, declp)\n+     struct work_stuff *work;\n+     const char **mangled;\n+     string *declp;\n+{\n+  string* saved_previous_argument;\n+  int result;\n+  int saved_nrepeats;\n+\n+  /* The G++ name-mangling algorithm does not remember types on nested\n+     argument lists, unless -fsquangling is used, and in that case the\n+     type vector updated by remember_type is not used.  So, we turn\n+     off remembering of types here.  */\n+  ++work->forgetting_types;\n+\n+  /* For the repeat codes used with -fsquangling, we must keep track of\n+     the last argument.  */\n+  saved_previous_argument = work->previous_argument;\n+  saved_nrepeats = work->nrepeats;\n+  work->previous_argument = 0;\n+  work->nrepeats = 0;\n+\n+  /* Actually demangle the arguments.  */\n+  result = demangle_args (work, mangled, declp);\n+  \n+  /* Restore the previous_argument field.  */\n+  if (work->previous_argument)\n+    string_delete (work->previous_argument);\n+  work->previous_argument = saved_previous_argument;\n+  work->nrepeats = saved_nrepeats;\n+\n+  return result;\n+}\n+\n static void\n demangle_function_name (work, mangled, declp, scan)\n      struct work_stuff *work;"}]}