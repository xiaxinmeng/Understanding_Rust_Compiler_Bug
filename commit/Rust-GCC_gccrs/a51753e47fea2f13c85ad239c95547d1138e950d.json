{"sha": "a51753e47fea2f13c85ad239c95547d1138e950d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTUxNzUzZTQ3ZmVhMmYxM2M4NWFkMjM5Yzk1NTQ3ZDExMzhlOTUwZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@wasabisystems.com", "date": "2003-12-04T19:48:44Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2003-12-04T19:48:44Z"}, "message": "re PR other/13304 (demangler bad output, \"operator<<\" insteads of \"operator< <\")\n\n\t* cp-demangle.c (IS_UPPER, IS_LOWER): Define.\n\t(d_last_char): Define new macro.\n\t(d_make_name): Reject an empty name.\n\t(d_prefix, d_unqualified_name, d_type): Use new IS_* macros.\n\t(d_substitution, d_print_identifier): Likewise.\n\t(d_print_comp) [D_COMP_OPERATOR]: Likewise.\n\t(d_print_comp) [D_COMP_TEMPLATE]: Use new d_last_char macro.\n\t(d_print_mod) Use new d_last_char macro.\n\t(d_print_cast): Use new d_last_char macro.\n\t(is_ctor_or_dtor): Don't leak memory.\n\n\tFix handling of member function modifiers:\n\t* cp-demangle.c (enum d_comp_type): Add D_COMP_RESTRICT_THIS,\n\tD_COMP_VOLATILE_THIS, and D_COMP_CONST_THIS.\n\t(d_dump): Dump new d_comp_type values.\n\t(d_make_comp): Accept new d_comp_type values.\n\t(has_return_type): Only accept _THIS variants of qualifiers.\n\t(d_encoding): Without DMGL_PARAMS, only remove _THIS variants of\n\tqualifiers.\n\t(d_cv_qualifiers): Add member_fn parameter.  Change all callers.\n\t(d_print_comp) [D_COMP_TYPED_NAME]: Rather than removing\n\tqualifiers and printing them at the end, add _THIS qualifiers to\n\tthe modifier list.\n\t(d_print_comp) [D_COMP_*_THIS]: New cases.\n\t(d_print_comp) [D_COMP_PTRMEM_TYPE]: Remove special handling of\n\tqualifiers.\n\t(d_print_mod_list): Add suffix parameter.  Change all callers.\n\tKeep walking the list even if the current modifier has been\n\tprinted.\n\t(d_print_mod): Handle new _THIS qualifiers.\n\t(d_print_function_type): Handle new _THIS qualifiers when deciding\n\twhether to print a parenthesis.  Put a space before the\n\tparenthesis in some cases.  Call d_print_mod_list again at the\n\tend, passing suffix as 1.\n\t(is_ctor_or_dtor): Look for new _THIS qualifiers.\n\t* testsuite/demangle-expected: Add test case.\n\n\tFix for PR gcc/13304:\n\t* cp-demangle.c (d_print_comp) [D_COMP_TEMPLATE]: If the character\n\tbefore the '<' is itself a '<', insert a space.\n\t(d_print_cast): Likewise.\n\t* testsuite/demangle-expected: Add test case.\n\n\tFix for PR gcc/13244:\n\t* cp-demangle.c (d_print_comp) [D_COMP_BINARY]: Wrap an expression\n\twhich uses the '>' operator in an extra layer of parens.\n\t* testsuite/demangle-expected: Add test case.\n\nFrom-SVN: r74290", "tree": {"sha": "aaac86f4eea92ded40e8b835a6329a27c511f128", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aaac86f4eea92ded40e8b835a6329a27c511f128"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a51753e47fea2f13c85ad239c95547d1138e950d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a51753e47fea2f13c85ad239c95547d1138e950d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a51753e47fea2f13c85ad239c95547d1138e950d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a51753e47fea2f13c85ad239c95547d1138e950d/comments", "author": null, "committer": null, "parents": [{"sha": "82fa4538b5437476dabcb695c381eda2a3742a7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82fa4538b5437476dabcb695c381eda2a3742a7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82fa4538b5437476dabcb695c381eda2a3742a7c"}], "stats": {"total": 423, "additions": 298, "deletions": 125}, "files": [{"sha": "ef659822ae39a87fb1483d44ab08382c5ba94120", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51753e47fea2f13c85ad239c95547d1138e950d/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51753e47fea2f13c85ad239c95547d1138e950d/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=a51753e47fea2f13c85ad239c95547d1138e950d", "patch": "@@ -1,3 +1,53 @@\n+2003-12-04  Ian Lance Taylor  <ian@wasabisystems.com>\n+\n+\t* cp-demangle.c (IS_UPPER, IS_LOWER): Define.\n+\t(d_last_char): Define new macro.\n+\t(d_make_name): Reject an empty name.\n+\t(d_prefix, d_unqualified_name, d_type): Use new IS_* macros.\n+\t(d_substitution, d_print_identifier): Likewise.\n+\t(d_print_comp) [D_COMP_OPERATOR]: Likewise.\n+\t(d_print_comp) [D_COMP_TEMPLATE]: Use new d_last_char macro.\n+\t(d_print_mod) Use new d_last_char macro.\n+\t(d_print_cast): Use new d_last_char macro.\n+\t(is_ctor_or_dtor): Don't leak memory.\n+\n+\tFix handling of member function modifiers:\n+\t* cp-demangle.c (enum d_comp_type): Add D_COMP_RESTRICT_THIS,\n+\tD_COMP_VOLATILE_THIS, and D_COMP_CONST_THIS.\n+\t(d_dump): Dump new d_comp_type values.\n+\t(d_make_comp): Accept new d_comp_type values.\n+\t(has_return_type): Only accept _THIS variants of qualifiers.\n+\t(d_encoding): Without DMGL_PARAMS, only remove _THIS variants of\n+\tqualifiers.\n+\t(d_cv_qualifiers): Add member_fn parameter.  Change all callers.\n+\t(d_print_comp) [D_COMP_TYPED_NAME]: Rather than removing\n+\tqualifiers and printing them at the end, add _THIS qualifiers to\n+\tthe modifier list.\n+\t(d_print_comp) [D_COMP_*_THIS]: New cases.\n+\t(d_print_comp) [D_COMP_PTRMEM_TYPE]: Remove special handling of\n+\tqualifiers.\n+\t(d_print_mod_list): Add suffix parameter.  Change all callers.\n+\tKeep walking the list even if the current modifier has been\n+\tprinted.\n+\t(d_print_mod): Handle new _THIS qualifiers.\n+\t(d_print_function_type): Handle new _THIS qualifiers when deciding\n+\twhether to print a parenthesis.  Put a space before the\n+\tparenthesis in some cases.  Call d_print_mod_list again at the\n+\tend, passing suffix as 1.\n+\t(is_ctor_or_dtor): Look for new _THIS qualifiers.\n+\t* testsuite/demangle-expected: Add test case.\n+\n+\tFix for PR gcc/13304:\n+\t* cp-demangle.c (d_print_comp) [D_COMP_TEMPLATE]: If the character\n+\tbefore the '<' is itself a '<', insert a space.\n+\t(d_print_cast): Likewise.\n+\t* testsuite/demangle-expected: Add test case.\n+\n+\tFix for PR gcc/13244:\n+\t* cp-demangle.c (d_print_comp) [D_COMP_BINARY]: Wrap an expression\n+\twhich uses the '>' operator in an extra layer of parens.\n+\t* testsuite/demangle-expected: Add test case.\n+\n 2003-12-03  Ian Lance Taylor  <ian@wasabisystems.com>\n \n \t* floatformat.c: Include \"config.h\" and <string.h> if available."}, {"sha": "a5835df549b4c01179b88178cc3d7fb4cba90f53", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 230, "deletions": 125, "changes": 355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51753e47fea2f13c85ad239c95547d1138e950d/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51753e47fea2f13c85ad239c95547d1138e950d/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=a51753e47fea2f13c85ad239c95547d1138e950d", "patch": "@@ -28,6 +28,43 @@\n    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. \n */\n \n+/* This code implements a demangler for the g++ V3 ABI.  The ABI is\n+   described on this web page:\n+       http://www.codesourcery.com/cxx-abi/abi.html#mangling\n+\n+   This code was written while looking at the demangler written by\n+   Alex Samuel <samuel@codesourcery.com>.\n+\n+   This code first pulls the mangled name apart into a list of\n+   components, and then walks the list generating the demangled\n+   name.\n+\n+   This file will normally define the following functions, q.v.:\n+      char *cplus_demangle_v3(const char *mangled, int options)\n+      char *java_demangle_v3(const char *mangled)\n+      enum gnu_v3_ctor_kinds is_gnu_v3_mangled_ctor (const char *name)\n+      enum gnu_v3_dtor_kinds is_gnu_v3_mangled_dtor (const char *name)\n+\n+   Preprocessor macros you can define while compiling this file:\n+\n+   IN_LIBGCC2\n+      If defined, this file defines the following function, q.v.:\n+         char *__cxa_demangle (const char *mangled, char *buf, size_t *len,\n+                               int *status)\n+      instead of cplus_demangle_v3() and java_demangle_v3().\n+\n+   IN_GLIBCPP_V3\n+      If defined, this file defines only __cxa_demangle().\n+\n+   STANDALONE_DEMANGLER\n+      If defined, this file defines a main() function which demangles\n+      any arguments, or, if none, demangles stdin.\n+\n+   CP_DEMANGLE_DEBUG\n+      If defined, turns on debugging mode, which prints information on\n+      stdout about the mangled string.  This is not generally useful.\n+*/\n+\n #ifdef HAVE_CONFIG_H\n #include \"config.h\"\n #endif\n@@ -45,19 +82,18 @@\n #include \"libiberty.h\"\n #include \"demangle.h\"\n \n-/* This code implements a demangler for the g++ V3 ABI.  The ABI is\n-   described on this web page:\n-       http://www.codesourcery.com/cxx-abi/abi.html#mangling\n-\n-   This code was written while looking at the demangler written by\n-   Alex Samuel <samuel@codesourcery.com>.\n+/* We avoid pulling in the ctype tables, to prevent pulling in\n+   additional unresolved symbols when this code is used in a library.\n+   FIXME: Is this really a valid reason?  This comes from the original\n+   V3 demangler code.\n \n-   This code first pulls the mangled name apart into a list of\n-   components, and then walks the list generating the demangled\n-   name.  */\n+   As of this writing this file has the following undefined references\n+   when compiled with -DIN_GLIBCPP_V3: malloc, realloc, free, memcpy,\n+   strcpy, strcat, strlen.  */\n \n-/* Avoid pulling in the ctype tables for this simple usage.  */\n #define IS_DIGIT(c) ((c) >= '0' && (c) <= '9')\n+#define IS_UPPER(c) ((c) >= 'A' && (c) <= 'Z')\n+#define IS_LOWER(c) ((c) >= 'a' && (c) <= 'z')\n \n /* The prefix prepended by GCC to an identifier represnting the\n    anonymous namespace.  */\n@@ -155,6 +191,12 @@ enum d_comp_type\n   D_COMP_VOLATILE,\n   /* The const qualifier.  */\n   D_COMP_CONST,\n+  /* The restrict qualifier modifying a member function.  */\n+  D_COMP_RESTRICT_THIS,\n+  /* The volatile qualifier modifying a member function.  */\n+  D_COMP_VOLATILE_THIS,\n+  /* The const qualifier modifying a member function.  */\n+  D_COMP_CONST_THIS,\n   /* A vendor qualifier.  */\n   D_COMP_VENDOR_TYPE_QUAL,\n   /* A pointer.  */\n@@ -389,6 +431,9 @@ struct d_print_info\n     } \\\n   while (0)\n \n+#define d_last_char(dpi) \\\n+  ((dpi)->buf == NULL || (dpi)->len == 0 ? '\\0' : (dpi)->buf[(dpi)->len - 1])\n+\n #ifdef CP_DEMANGLE_DEBUG\n static void d_dump PARAMS ((struct d_comp *, int));\n #endif\n@@ -430,7 +475,7 @@ static int d_call_offset PARAMS ((struct d_info *, int));\n static struct d_comp *d_ctor_dtor_name PARAMS ((struct d_info *));\n static struct d_comp *d_type PARAMS ((struct d_info *));\n static struct d_comp **d_cv_qualifiers PARAMS ((struct d_info *,\n-\t\t\t\t\t\tstruct d_comp **));\n+\t\t\t\t\t\tstruct d_comp **, int));\n static struct d_comp *d_function_type PARAMS ((struct d_info *));\n static struct d_comp *d_bare_function_type PARAMS ((struct d_info *, int));\n static struct d_comp *d_class_enum_type PARAMS ((struct d_info *));\n@@ -456,7 +501,7 @@ static void d_print_comp PARAMS ((struct d_print_info *,\n static void d_print_identifier PARAMS ((struct d_print_info *, const char *,\n \t\t\t\t\tint));\n static void d_print_mod_list PARAMS ((struct d_print_info *,\n-\t\t\t\t      struct d_print_mod *));\n+\t\t\t\t      struct d_print_mod *, int));\n static void d_print_mod PARAMS ((struct d_print_info *,\n \t\t\t\t const struct d_comp *));\n static void d_print_function_type PARAMS ((struct d_print_info *,\n@@ -572,6 +617,15 @@ d_dump (dc, indent)\n     case D_COMP_CONST:\n       printf (\"const\\n\");\n       break;\n+    case D_COMP_RESTRICT_THIS:\n+      printf (\"restrict this\\n\");\n+      break;\n+    case D_COMP_VOLATILE_THIS:\n+      printf (\"volatile this\\n\");\n+      break;\n+    case D_COMP_CONST_THIS:\n+      printf (\"const this\\n\");\n+      break;\n     case D_COMP_VENDOR_TYPE_QUAL:\n       printf (\"vendor type qualifier\\n\");\n       break;\n@@ -725,6 +779,9 @@ d_make_comp (di, type, left, right)\n     case D_COMP_RESTRICT:\n     case D_COMP_VOLATILE:\n     case D_COMP_CONST:\n+    case D_COMP_RESTRICT_THIS:\n+    case D_COMP_VOLATILE_THIS:\n+    case D_COMP_CONST_THIS:\n       break;\n \n       /* Other types should not be seen here.  */\n@@ -751,6 +808,8 @@ d_make_name (di, s, len)\n {\n   struct d_comp *p;\n \n+  if (s == NULL || len == 0)\n+    return NULL;\n   p = d_make_empty (di, D_COMP_NAME);\n   if (p != NULL)\n     {\n@@ -922,10 +981,9 @@ has_return_type (dc)\n       return 0;\n     case D_COMP_TEMPLATE:\n       return ! is_ctor_dtor_or_conversion (d_left (dc));\n-    case D_COMP_RESTRICT:\n-    case D_COMP_VOLATILE:\n-    case D_COMP_CONST:\n-    case D_COMP_VENDOR_TYPE_QUAL:\n+    case D_COMP_RESTRICT_THIS:\n+    case D_COMP_VOLATILE_THIS:\n+    case D_COMP_CONST_THIS:\n       return has_return_type (d_left (dc));\n     }\n }\n@@ -981,9 +1039,9 @@ d_encoding (di, top_level)\n \t  /* Strip off any initial CV-qualifiers, as they really apply\n \t     to the `this' parameter, and they were not output by the\n \t     v2 demangler without DMGL_PARAMS.  */\n-\t  while (dc->type == D_COMP_RESTRICT\n-\t\t || dc->type == D_COMP_VOLATILE\n-\t\t || dc->type == D_COMP_CONST)\n+\t  while (dc->type == D_COMP_RESTRICT_THIS\n+\t\t || dc->type == D_COMP_VOLATILE_THIS\n+\t\t || dc->type == D_COMP_CONST_THIS)\n \t    dc = d_left (dc);\n \t  return dc;\n \t}\n@@ -1092,7 +1150,7 @@ d_nested_name (di)\n   if (d_next_char (di) != 'N')\n     return NULL;\n \n-  pret = d_cv_qualifiers (di, &ret);\n+  pret = d_cv_qualifiers (di, &ret, 1);\n   if (pret == NULL)\n     return NULL;\n \n@@ -1139,7 +1197,7 @@ d_prefix (di)\n \n       comb_type = D_COMP_QUAL_NAME;\n       if (IS_DIGIT (peek)\n-\t  || (peek >= 'a' && peek <= 'z')\n+\t  || IS_LOWER (peek)\n \t  || peek == 'C'\n \t  || peek == 'D')\n \tdc = d_unqualified_name (di);\n@@ -1186,7 +1244,7 @@ d_unqualified_name (di)\n   peek = d_peek_char (di);\n   if (IS_DIGIT (peek))\n     return d_source_name (di);\n-  else if (peek >= 'a' && peek <= 'z')\n+  else if (IS_LOWER (peek))\n     return d_operator_name (di);\n   else if (peek == 'C' || peek == 'D')\n     return d_ctor_dtor_name (di);\n@@ -1648,7 +1706,7 @@ d_type (di)\n     {\n       struct d_comp **pret;\n \n-      pret = d_cv_qualifiers (di, &ret);\n+      pret = d_cv_qualifiers (di, &ret, 0);\n       if (pret == NULL)\n \treturn NULL;\n       *pret = d_type (di);\n@@ -1716,7 +1774,7 @@ d_type (di)\n \tpeek_next = d_peek_next_char (di);\n \tif (IS_DIGIT (peek_next)\n \t    || peek_next == '_'\n-\t    || (peek_next >= 'A' && peek_next <= 'Z'))\n+\t    || IS_UPPER (peek_next))\n \t  {\n \t    ret = d_substitution (di);\n \t    /* The substituted name may have been a template name and\n@@ -1782,9 +1840,10 @@ d_type (di)\n /* <CV-qualifiers> ::= [r] [V] [K]  */\n \n static struct d_comp **\n-d_cv_qualifiers (di, pret)\n+d_cv_qualifiers (di, pret, member_fn)\n      struct d_info *di;\n      struct d_comp **pret;\n+     int member_fn;\n {\n   char peek;\n \n@@ -1795,11 +1854,11 @@ d_cv_qualifiers (di, pret)\n \n       d_advance (di, 1);\n       if (peek == 'r')\n-\tt = D_COMP_RESTRICT;\n+\tt = member_fn ? D_COMP_RESTRICT_THIS: D_COMP_RESTRICT;\n       else if (peek == 'V')\n-\tt = D_COMP_VOLATILE;\n+\tt = member_fn ? D_COMP_VOLATILE_THIS : D_COMP_VOLATILE;\n       else\n-\tt = D_COMP_CONST;\n+\tt = member_fn ? D_COMP_CONST_THIS: D_COMP_CONST;\n \n       *pret = d_make_comp (di, t, NULL, NULL);\n       if (*pret == NULL)\n@@ -1970,7 +2029,7 @@ d_pointer_to_member_type (di)\n      with g++, we need to pull off the CV-qualifiers here, in order to\n      avoid calling add_substitution() in d_type().  */\n \n-  pmem = d_cv_qualifiers (di, &mem);\n+  pmem = d_cv_qualifiers (di, &mem, 1);\n   if (pmem == NULL)\n     return NULL;\n   *pmem = d_type (di);\n@@ -2316,7 +2375,7 @@ d_substitution (di)\n     return NULL;\n \n   c = d_next_char (di);\n-  if (c == '_' || IS_DIGIT (c) || (c >= 'A' && c <= 'Z'))\n+  if (c == '_' || IS_DIGIT (c) || IS_UPPER (c))\n     {\n       int id;\n \n@@ -2327,7 +2386,7 @@ d_substitution (di)\n \t    {\n \t      if (IS_DIGIT (c))\n \t\tid = id * 36 + c - '0';\n-\t      else if (c >= 'A' && c <= 'Z')\n+\t      else if (IS_UPPER (c))\n \t\tid = id * 36 + c - 'A' + 10;\n \t      else\n \t\treturn NULL;\n@@ -2527,28 +2586,40 @@ d_print_comp (dpi, dc)\n \n     case D_COMP_TYPED_NAME:\n       {\n-\tconst struct d_comp *typed_name;\n-\tstruct d_print_mod dpm;\n+\tstruct d_print_mod *hold_modifiers;\n+\tstruct d_comp *typed_name;\n+\tstruct d_print_mod adpm[4];\n+\tunsigned int i;\n \tstruct d_print_template dpt;\n \n \t/* Pass the name down to the type so that it can be printed in\n-\t   the right place for the type.  If the name has\n-\t   CV-qualifiers, they are really method qualifiers; pull them\n-\t   off now and print them after everything else.  Note that we\n-\t   don't handle D_COMP_VENDOR_TYPE_QUAL here; it's not\n-\t   accepted by d_cv_qualifiers() either.  */\n+\t   the right place for the type.  We also have to pass down\n+\t   any CV-qualifiers, which apply to the this parameter.  */\n+\thold_modifiers = dpi->modifiers;\n+\ti = 0;\n \ttyped_name = d_left (dc);\n-\twhile (typed_name != NULL\n-\t       && (typed_name->type == D_COMP_RESTRICT\n-\t\t   || typed_name->type == D_COMP_VOLATILE\n-\t\t   || typed_name->type == D_COMP_CONST))\n-\t  typed_name = d_left (typed_name);\n+\twhile (typed_name != NULL)\n+\t  {\n+\t    if (i >= sizeof adpm / sizeof adpm[0])\n+\t      {\n+\t\td_print_error (dpi);\n+\t\treturn;\n+\t      }\n \n-\tdpm.next = dpi->modifiers;\n-\tdpi->modifiers = &dpm;\n-\tdpm.mod = typed_name;\n-\tdpm.printed = 0;\n-\tdpm.templates = dpi->templates;\n+\t    adpm[i].next = dpi->modifiers;\n+\t    dpi->modifiers = &adpm[i];\n+\t    adpm[i].mod = typed_name;\n+\t    adpm[i].printed = 0;\n+\t    adpm[i].templates = dpi->templates;\n+\t    ++i;\n+\n+\t    if (typed_name->type != D_COMP_RESTRICT_THIS\n+\t\t&& typed_name->type != D_COMP_VOLATILE_THIS\n+\t\t&& typed_name->type != D_COMP_CONST_THIS)\n+\t      break;\n+\n+\t    typed_name = d_left (typed_name);\n+\t  }\n \n \t/* If typed_name is a template, then it applies to the\n \t   function type as well.  */\n@@ -2564,26 +2635,19 @@ d_print_comp (dpi, dc)\n \tif (typed_name->type == D_COMP_TEMPLATE)\n \t  dpi->templates = dpt.next;\n \n-\t/* If the modifier didn't get printed by the type, print it\n+\t/* If the modifiers didn't get printed by the type, print them\n \t   now.  */\n-\tif (! dpm.printed)\n+\twhile (i > 0)\n \t  {\n-\t    d_append_char (dpi, ' ');\n-\t    d_print_comp (dpi, typed_name);\n+\t    --i;\n+\t    if (! adpm[i].printed)\n+\t      {\n+\t\td_append_char (dpi, ' ');\n+\t\td_print_mod (dpi, adpm[i].mod);\n+\t      }\n \t  }\n \n-\tdpi->modifiers = dpm.next;\n-\n-\t/* Now print any CV-qualifiers on the type.  */\n-\ttyped_name = d_left (dc);\n-\twhile (typed_name != NULL\n-\t       && (typed_name->type == D_COMP_RESTRICT\n-\t\t   || typed_name->type == D_COMP_VOLATILE\n-\t\t   || typed_name->type == D_COMP_CONST))\n-\t  {\n-\t    d_print_mod (dpi, typed_name);\n-\t    typed_name = d_left (typed_name);\n-\t  }\n+\tdpi->modifiers = hold_modifiers;\n \n \treturn;\n       }\n@@ -2600,11 +2664,13 @@ d_print_comp (dpi, dc)\n \tdpi->modifiers = NULL;\n \n \td_print_comp (dpi, d_left (dc));\n+\tif (d_last_char (dpi) == '<')\n+\t  d_append_char (dpi, ' ');\n \td_append_char (dpi, '<');\n \td_print_comp (dpi, d_right (dc));\n \t/* Avoid generating two consecutive '>' characters, to avoid\n \t   the C++ syntactic ambiguity.  */\n-\tif (dpi->buf != NULL && dpi->buf[dpi->len - 1] == '>')\n+\tif (d_last_char (dpi) == '>')\n \t  d_append_char (dpi, ' ');\n \td_append_char (dpi, '>');\n \n@@ -2737,6 +2803,9 @@ d_print_comp (dpi, dc)\n     case D_COMP_RESTRICT:\n     case D_COMP_VOLATILE:\n     case D_COMP_CONST:\n+    case D_COMP_RESTRICT_THIS:\n+    case D_COMP_VOLATILE_THIS:\n+    case D_COMP_CONST_THIS:\n     case D_COMP_VENDOR_TYPE_QUAL:\n     case D_COMP_POINTER:\n     case D_COMP_REFERENCE:\n@@ -2832,27 +2901,15 @@ d_print_comp (dpi, dc)\n \n     case D_COMP_PTRMEM_TYPE:\n       {\n-\tconst struct d_comp *target_type;\n \tstruct d_print_mod dpm;\n \n-\t/* Pass the name down to the type so that it can be printed in\n-\t   the right place for the type.  If the type has\n-\t   CV-qualifiers, they are really method qualifiers; pull them\n-\t   off now and print them after everything else.  */\n-\ttarget_type = d_right (dc);\n-\twhile (target_type != NULL\n-\t       && (target_type->type == D_COMP_RESTRICT\n-\t\t   || target_type->type == D_COMP_VOLATILE\n-\t\t   || target_type->type == D_COMP_CONST))\n-\t  target_type = d_left (target_type);\n-\n \tdpm.next = dpi->modifiers;\n \tdpi->modifiers = &dpm;\n \tdpm.mod = dc;\n \tdpm.printed = 0;\n \tdpm.templates = dpi->templates;\n \n-\td_print_comp (dpi, target_type);\n+\td_print_comp (dpi, d_right (dc));\n \n \t/* If the modifier didn't get printed by the type, print it\n \t   now.  */\n@@ -2865,17 +2922,6 @@ d_print_comp (dpi, dc)\n \n \tdpi->modifiers = dpm.next;\n \n-\t/* Now print any CV-qualifiers on the type.  */\n-\ttarget_type = d_right (dc);\n-\twhile (target_type != NULL\n-\t       && (target_type->type == D_COMP_RESTRICT\n-\t\t   || target_type->type == D_COMP_VOLATILE\n-\t\t   || target_type->type == D_COMP_CONST))\n-\t  {\n-\t    d_print_mod (dpi, target_type);\n-\t    target_type = d_left (target_type);\n-\t  }\n-\n \treturn;\n       }\n \n@@ -2895,7 +2941,7 @@ d_print_comp (dpi, dc)\n \n \td_append_string (dpi, \"operator\");\n \tc = dc->u.s_operator.op->name[0];\n-\tif (c >= 'a' && c <= 'z')\n+\tif (IS_LOWER (c))\n \t  d_append_char (dpi, ' ');\n \td_append_string (dpi, dc->u.s_operator.op->name);\n \treturn;\n@@ -2933,13 +2979,26 @@ d_print_comp (dpi, dc)\n \t  d_print_error (dpi);\n \t  return;\n \t}\n+\n+      /* We wrap an expression which uses the greater-than operator in\n+\t an extra layer of parens so that it does not get confused\n+\t with the '>' which ends the template parameters.  */\n+      if (d_left (dc)->type == D_COMP_OPERATOR\n+\t  && strcmp (d_left (dc)->u.s_operator.op->name, \">\") == 0)\n+\td_append_char (dpi, '(');\n+\n       d_append_char (dpi, '(');\n       d_print_comp (dpi, d_left (d_right (dc)));\n       d_append_string (dpi, \") \");\n       d_print_expr_op (dpi, d_left (dc));\n       d_append_string (dpi, \" (\");\n       d_print_comp (dpi, d_right (d_right (dc)));\n       d_append_char (dpi, ')');\n+\n+      if (d_left (dc)->type == D_COMP_OPERATOR\n+\t  && strcmp (d_left (dc)->u.s_operator.op->name, \">\") == 0)\n+\td_append_char (dpi, ')');\n+\n       return;\n \n     case D_COMP_BINARY_ARGS:\n@@ -3064,7 +3123,7 @@ d_print_identifier (dpi, name, len)\n \t\t{\n \t\t  int dig;\n \n-\t\t  if (*q >= '0' && *q <= '9')\n+\t\t  if (IS_DIGIT (*q))\n \t\t    dig = *q - '0';\n \t\t  else if (*q >= 'A' && *q <= 'F')\n \t\t    dig = *q - 'A' + 10;\n@@ -3090,18 +3149,30 @@ d_print_identifier (dpi, name, len)\n     }\n }\n \n-/* Print a list of modifiers.  */\n+/* Print a list of modifiers.  SUFFIX is 1 if we are printing\n+   qualifiers on this after printing a function.  */\n \n static void\n-d_print_mod_list (dpi, mods)\n+d_print_mod_list (dpi, mods, suffix)\n      struct d_print_info *dpi;\n      struct d_print_mod *mods;\n+     int suffix;\n {\n   struct d_print_template *hold_dpt;\n \n-  if (mods == NULL || mods->printed || d_print_saw_error (dpi))\n+  if (mods == NULL || d_print_saw_error (dpi))\n     return;\n \n+  if (mods->printed\n+      || (! suffix\n+\t  && (mods->mod->type == D_COMP_RESTRICT_THIS\n+\t      || mods->mod->type == D_COMP_VOLATILE_THIS\n+\t      || mods->mod->type == D_COMP_CONST_THIS)))\n+    {\n+      d_print_mod_list (dpi, mods->next, suffix);\n+      return;\n+    }\n+\n   mods->printed = 1;\n \n   hold_dpt = dpi->templates;\n@@ -3124,7 +3195,7 @@ d_print_mod_list (dpi, mods)\n \n   dpi->templates = hold_dpt;\n \n-  d_print_mod_list (dpi, mods->next);\n+  d_print_mod_list (dpi, mods->next, suffix);\n }\n \n /* Print a modifier.  */\n@@ -3137,12 +3208,15 @@ d_print_mod (dpi, mod)\n   switch (mod->type)\n     {\n     case D_COMP_RESTRICT:\n+    case D_COMP_RESTRICT_THIS:\n       d_append_string (dpi, \" restrict\");\n       return;\n     case D_COMP_VOLATILE:\n+    case D_COMP_VOLATILE_THIS:\n       d_append_string (dpi, \" volatile\");\n       return;\n     case D_COMP_CONST:\n+    case D_COMP_CONST_THIS:\n       d_append_string (dpi, \" const\");\n       return;\n     case D_COMP_VENDOR_TYPE_QUAL:\n@@ -3164,7 +3238,7 @@ d_print_mod (dpi, mod)\n       d_append_string (dpi, \"imaginary \");\n       return;\n     case D_COMP_PTRMEM_TYPE:\n-      if (dpi->buf != NULL && dpi->buf[dpi->len - 1] != '(')\n+      if (d_last_char (dpi) != '(')\n \td_append_char (dpi, ' ');\n       d_print_comp (dpi, d_left (mod));\n       d_append_string (dpi, \"::*\");\n@@ -3213,6 +3287,10 @@ d_print_function_type (dpi, dc, mods)\n \tcase D_COMP_PTRMEM_TYPE:\n \t  need_paren = 1;\n \t  break;\n+\tcase D_COMP_RESTRICT_THIS:\n+\tcase D_COMP_VOLATILE_THIS:\n+\tcase D_COMP_CONST_THIS:\n+\t  break;\n \tdefault:\n \t  break;\n \t}\n@@ -3224,9 +3302,23 @@ d_print_function_type (dpi, dc, mods)\n     need_paren = 1;\n \n   if (need_paren)\n-    d_append_char (dpi, '(');\n+    {\n+      switch (d_last_char (dpi))\n+\t{\n+\tcase ' ':\n+\tcase '(':\n+\tcase '*':\n+\t  break;\n \n-  d_print_mod_list (dpi, mods);\n+\tdefault:\n+\t  d_append_char (dpi, ' ');\n+\t  break;\n+\t}\n+\n+      d_append_char (dpi, '(');\n+    }\n+\n+  d_print_mod_list (dpi, mods, 0);\n \n   if (need_paren)\n     d_append_char (dpi, ')');\n@@ -3237,6 +3329,8 @@ d_print_function_type (dpi, dc, mods)\n     d_print_comp (dpi, d_right (dc));\n \n   d_append_char (dpi, ')');\n+\n+  d_print_mod_list (dpi, mods, 1);\n }\n \n /* Print an array type, except for the element type.  */\n@@ -3277,7 +3371,7 @@ d_print_array_type (dpi, dc, mods)\n       if (need_paren)\n \td_append_string (dpi, \" (\");\n \n-      d_print_mod_list (dpi, mods);\n+      d_print_mod_list (dpi, mods, 0);\n \n       if (need_paren)\n \td_append_char (dpi, ')');\n@@ -3337,11 +3431,13 @@ d_print_cast (dpi, dc)\n \n       dpi->templates = dpt.next;\n \n+      if (d_last_char (dpi) == '<')\n+\td_append_char (dpi, ' ');\n       d_append_char (dpi, '<');\n       d_print_comp (dpi, d_right (d_left (dc)));\n       /* Avoid generating two consecutive '>' characters, to avoid\n \t the C++ syntactic ambiguity.  */\n-      if (dpi->buf != NULL && dpi->buf[dpi->len - 1] == '>')\n+      if (d_last_char (dpi) == '>')\n \td_append_char (dpi, ' ');\n       d_append_char (dpi, '>');\n \n@@ -3653,6 +3749,7 @@ is_ctor_or_dtor (mangled, ctor_kind, dtor_kind)\n {\n   struct d_info di;\n   struct d_comp *dc;\n+  int ret;\n \n   *ctor_kind = (enum gnu_v3_ctor_kinds) 0;\n   *dtor_kind = (enum gnu_v3_dtor_kinds) 0;\n@@ -3662,36 +3759,44 @@ is_ctor_or_dtor (mangled, ctor_kind, dtor_kind)\n \n   dc = d_mangled_name (&di, 1);\n \n-  if (dc == NULL || d_peek_char (&di) != '\\0')\n-    return 0;\n-\n-  while (dc != NULL)\n+  ret = 0;\n+  if (d_peek_char (&di) == '\\0')\n     {\n-      switch (dc->type)\n+      while (dc != NULL)\n \t{\n-\tdefault:\n-\t  return 0;\n-\tcase D_COMP_TYPED_NAME:\n-\tcase D_COMP_TEMPLATE:\n-\tcase D_COMP_RESTRICT:\n-\tcase D_COMP_VOLATILE:\n-\tcase D_COMP_CONST:\n-\tcase D_COMP_VENDOR_TYPE_QUAL:\n-\t  dc = d_left (dc);\n-\t  break;\n-\tcase D_COMP_QUAL_NAME:\n-\t  dc = d_right (dc);\n-\t  break;\n-\tcase D_COMP_CTOR:\n-\t  *ctor_kind = dc->u.s_ctor.kind;\n-\t  return 1;\n-\tcase D_COMP_DTOR:\n-\t  *dtor_kind = dc->u.s_dtor.kind;\n-\t  return 1;\n+\t  switch (dc->type)\n+\t    {\n+\t    default:\n+\t      dc = NULL;\n+\t      break;\n+\t    case D_COMP_TYPED_NAME:\n+\t    case D_COMP_TEMPLATE:\n+\t    case D_COMP_RESTRICT_THIS:\n+\t    case D_COMP_VOLATILE_THIS:\n+\t    case D_COMP_CONST_THIS:\n+\t      dc = d_left (dc);\n+\t      break;\n+\t    case D_COMP_QUAL_NAME:\n+\t      dc = d_right (dc);\n+\t      break;\n+\t    case D_COMP_CTOR:\n+\t      *ctor_kind = dc->u.s_ctor.kind;\n+\t      ret = 1;\n+\t      dc = NULL;\n+\t      break;\n+\t    case D_COMP_DTOR:\n+\t      *dtor_kind = dc->u.s_dtor.kind;\n+\t      ret = 1;\n+\t      dc = NULL;\n+\t      break;\n+\t    }\n \t}\n     }\n \n-  return 0;\n+  free (di.subs);\n+  free (di.comps);\n+\n+  return ret;\n }\n \n /* Return whether NAME is the mangled form of a g++ V3 ABI constructor"}, {"sha": "c47c6aea5fa55c8ec4e60779de8fa8729e65472e", "filename": "libiberty/testsuite/demangle-expected", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51753e47fea2f13c85ad239c95547d1138e950d/libiberty%2Ftestsuite%2Fdemangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51753e47fea2f13c85ad239c95547d1138e950d/libiberty%2Ftestsuite%2Fdemangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Fdemangle-expected?ref=a51753e47fea2f13c85ad239c95547d1138e950d", "patch": "@@ -2883,10 +2883,28 @@ void __gnu_debug::_Error_formatter::_M_format_word<unsigned long>(char*, int, ch\n --format=gnu-v3\n _ZSt18uninitialized_copyIN9__gnu_cxx17__normal_iteratorIPSt4pairISsPFbP6sqlitePPcEESt6vectorIS9_SaIS9_EEEESE_ET0_T_SG_SF_\n __gnu_cxx::__normal_iterator<std::pair<std::string, bool (*)(sqlite*, char**)>*, std::vector<std::pair<std::string, bool (*)(sqlite*, char**)>, std::allocator<std::pair<std::string, bool (*)(sqlite*, char**)> > > > std::uninitialized_copy<__gnu_cxx::__normal_iterator<std::pair<std::string, bool (*)(sqlite*, char**)>*, std::vector<std::pair<std::string, bool (*)(sqlite*, char**)>, std::allocator<std::pair<std::string, bool (*)(sqlite*, char**)> > > >, __gnu_cxx::__normal_iterator<std::pair<std::string, bool (*)(sqlite*, char**)>*, std::vector<std::pair<std::string, bool (*)(sqlite*, char**)>, std::allocator<std::pair<std::string, bool (*)(sqlite*, char**)> > > > >(__gnu_cxx::__normal_iterator<std::pair<std::string, bool (*)(sqlite*, char**)>*, std::vector<std::pair<std::string, bool (*)(sqlite*, char**)>, std::allocator<std::pair<std::string, bool (*)(sqlite*, char**)> > > >, __gnu_cxx::__normal_iterator<std::pair<std::string, bool (*)(sqlite*, char**)>*, std::vector<std::pair<std::string, bool (*)(sqlite*, char**)>, std::allocator<std::pair<std::string, bool (*)(sqlite*, char**)> > > >, __gnu_cxx::__normal_iterator<std::pair<std::string, bool (*)(sqlite*, char**)>*, std::vector<std::pair<std::string, bool (*)(sqlite*, char**)>, std::allocator<std::pair<std::string, bool (*)(sqlite*, char**)> > > >)\n+#\n # The new demangler used to fail on this.\n --format=gnu-v3\n _Z1fP1cIPFiiEE\n f(c<int (*)(int)>*)\n+#\n+# Wrap expressions using '>' in an extra layer of parens to avoid\n+# confusion with the '>' which ends the template parameters.\n+--format=gnu-v3\n+_Z4dep9ILi3EEvP3fooIXgtT_Li2EEE\n+void dep9<3>(foo<((3) > (2))>*)\n+#\n+# Watch out for templated version of `operator<'--it needs an extra\n+# space.\n+--format=gnu-v3\n+_ZStltI9file_pathSsEbRKSt4pairIT_T0_ES6_\n+bool std::operator< <file_path, std::string>(std::pair<file_path, std::string> const&, std::pair<file_path, std::string> const&)\n+#\n+# More hairy qualifier handling.\n+--format=gnu-v3\n+_Z9hairyfuncM1YKFPVPFrPA2_PM1XKFKPA3_ilEPcEiE\n+hairyfunc(int (* const (X::** (* restrict (* volatile*(Y::*)(int) const)(char*)) [2])(long) const) [3])\n # \n # This caused an infinite loop.\n #"}]}