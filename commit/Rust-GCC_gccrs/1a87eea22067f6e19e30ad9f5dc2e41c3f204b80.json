{"sha": "1a87eea22067f6e19e30ad9f5dc2e41c3f204b80", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE4N2VlYTIyMDY3ZjZlMTllMzBhZDlmNWRjMmU0MWMzZjIwNGI4MA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "1999-03-14T14:02:10Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "1999-03-14T14:02:10Z"}, "message": "cse.c (check_fold_consts): New static function.\n\n        * cse.c (check_fold_consts): New static function.\n        (cfc_args): New struct.\n        (simplify_relational_operation): Use them in call to\n        `do_float_handler'.\n        * toplev.c (do_float_handler): New function to wrap calls to\n        setjmp/set_float_handler.\n        * toplev.h (do_float_handler): Add extern prototype.\n        * tree.c (build_real_from_int_cst_1): New static function.\n        (brfic_args): New struct.\n        (build_real_from_int_cst): Use them in call to\n        `do_float_handler'.\n\nFrom-SVN: r25768", "tree": {"sha": "72dc4ff5c660048c298d80243ea16ff9e4568de0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72dc4ff5c660048c298d80243ea16ff9e4568de0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a87eea22067f6e19e30ad9f5dc2e41c3f204b80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a87eea22067f6e19e30ad9f5dc2e41c3f204b80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a87eea22067f6e19e30ad9f5dc2e41c3f204b80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a87eea22067f6e19e30ad9f5dc2e41c3f204b80/comments", "author": null, "committer": null, "parents": [{"sha": "c2b2e000045ac8a9291c05dafc5f6aec7da47dc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2b2e000045ac8a9291c05dafc5f6aec7da47dc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2b2e000045ac8a9291c05dafc5f6aec7da47dc2"}], "stats": {"total": 143, "additions": 116, "deletions": 27}, "files": [{"sha": "a3084bf44c800cba40b1b996a1c6520eaee374e7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a87eea22067f6e19e30ad9f5dc2e41c3f204b80/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a87eea22067f6e19e30ad9f5dc2e41c3f204b80/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a87eea22067f6e19e30ad9f5dc2e41c3f204b80", "patch": "@@ -1,3 +1,20 @@\n+Sun Mar 14 16:22:10 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* cse.c (check_fold_consts): New static function.\n+\t(cfc_args): New struct.\n+\t(simplify_relational_operation): Use them in call to\n+\t`do_float_handler'.\n+\t\n+\t* toplev.c (do_float_handler): New function to wrap calls to\n+\tsetjmp/set_float_handler.\n+\n+\t* toplev.h (do_float_handler): Add extern prototype.\n+\n+\t* tree.c (build_real_from_int_cst_1): New static function.\n+\t(brfic_args): New struct.\n+\t(build_real_from_int_cst): Use them in call to\n+\t`do_float_handler'.\n+\n Sun Mar 14 01:15:06 PST 1999 Jeff Law  (law@cygnus.com)\n \n \t* version.c: Bump for snapshot."}, {"sha": "bc22df9e2c8a9ba5e2a1aec25015553facbaf9f1", "filename": "gcc/cse.c", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a87eea22067f6e19e30ad9f5dc2e41c3f204b80/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a87eea22067f6e19e30ad9f5dc2e41c3f204b80/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=1a87eea22067f6e19e30ad9f5dc2e41c3f204b80", "patch": "@@ -664,6 +664,7 @@ static void cse_set_around_loop\tPROTO((rtx, rtx, rtx));\n static rtx cse_basic_block\tPROTO((rtx, rtx, struct branch_path *, int));\n static void count_reg_usage\tPROTO((rtx, int *, rtx, int));\n extern void dump_class          PROTO((struct table_elt*));\n+static void check_fold_consts\tPROTO((PTR));\n \n extern int rtx_equal_function_value_matters;\n \f\n@@ -4594,6 +4595,28 @@ cse_gen_binary (code, mode, op0, op1)\n     return gen_rtx_fmt_ee (code, mode, op0, op1);\n }\n \f\n+struct cfc_args\n+{\n+  /* Input */\n+  rtx op0, op1;\n+  /* Output */\n+  int equal, op0lt, op1lt;\n+};\n+\n+static void\n+check_fold_consts (data)\n+  PTR data;\n+{\n+  struct cfc_args * args = (struct cfc_args *) data;\n+  REAL_VALUE_TYPE d0, d1;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (d0, args->op0);\n+  REAL_VALUE_FROM_CONST_DOUBLE (d1, args->op1);\n+  args->equal = REAL_VALUES_EQUAL (d0, d1);\n+  args->op0lt = REAL_VALUES_LESS (d0, d1);\n+  args->op1lt = REAL_VALUES_LESS (d1, d0);\n+}\n+\n /* Like simplify_binary_operation except used for relational operators.\n    MODE is the mode of the operands, not that of the result.  If MODE\n    is VOIDmode, both operands must also be VOIDmode and we compare the\n@@ -4655,19 +4678,20 @@ simplify_relational_operation (code, mode, op0, op1)\n   else if (GET_CODE (op0) == CONST_DOUBLE && GET_CODE (op1) == CONST_DOUBLE\n \t   && GET_MODE_CLASS (GET_MODE (op0)) == MODE_FLOAT)\n     {\n-      REAL_VALUE_TYPE d0, d1;\n-      jmp_buf handler;\n+      struct cfc_args args;\n+\n+      /* Setup input for check_fold_consts() */\n+      args.op0 = op0;\n+      args.op1 = op1;\n       \n-      if (setjmp (handler))\n+      if (do_float_handler(check_fold_consts, (PTR) &args) == 0)\n+\t/* We got an exception from check_fold_consts() */\n \treturn 0;\n \n-      set_float_handler (handler);\n-      REAL_VALUE_FROM_CONST_DOUBLE (d0, op0);\n-      REAL_VALUE_FROM_CONST_DOUBLE (d1, op1);\n-      equal = REAL_VALUES_EQUAL (d0, d1);\n-      op0lt = op0ltu = REAL_VALUES_LESS (d0, d1);\n-      op1lt = op1ltu = REAL_VALUES_LESS (d1, d0);\n-      set_float_handler (NULL_PTR);\n+      /* Receive output from check_fold_consts() */\n+      equal = args.equal;\n+      op0lt = op0ltu = args.op0lt;\n+      op1lt = op1ltu = args.op1lt;\n     }\n #endif  /* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */\n "}, {"sha": "bceb6cfd6c5559a96ed88f64a1e6e10526c5b136", "filename": "gcc/toplev.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a87eea22067f6e19e30ad9f5dc2e41c3f204b80/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a87eea22067f6e19e30ad9f5dc2e41c3f204b80/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=1a87eea22067f6e19e30ad9f5dc2e41c3f204b80", "patch": "@@ -2389,6 +2389,33 @@ set_float_handler (handler)\n     }\n }\n \n+/* This is a wrapper function for code which might elicit an\n+   arithmetic exception.  That code should be passed in as a function\n+   pointer FN, and one argument DATA.  DATA is usually a struct which\n+   contains the real input and output for function FN.  This function\n+   returns 0 (failure) if longjmp was called (i.e. an exception\n+   occured.)  It returns 1 (success) otherwise. */\n+\n+int\n+do_float_handler (fn, data)\n+  void (*fn) PROTO ((PTR));\n+  PTR data;\n+{\n+  jmp_buf buf;\n+\n+  if (setjmp (buf))\n+    {\n+      /* We got here via longjmp() caused by an exception in function fn() */\n+      set_float_handler (NULL);\n+      return 0;\n+    }\n+\n+  set_float_handler (buf);\n+  (*fn)(data);\n+  set_float_handler (NULL);\n+  return 1;\n+}\n+\n /* Specify, in HANDLER, where to longjmp to when a floating arithmetic\n    error happens, pushing the previous specification into OLD_HANDLER.\n    Return an indication of whether there was a previous handler in effect.  */"}, {"sha": "d8acd0d068bf1b540f0d77d5a00792d03556d854", "filename": "gcc/toplev.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a87eea22067f6e19e30ad9f5dc2e41c3f204b80/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a87eea22067f6e19e30ad9f5dc2e41c3f204b80/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=1a87eea22067f6e19e30ad9f5dc2e41c3f204b80", "patch": "@@ -92,6 +92,7 @@ extern void set_float_handler PROTO((jmp_buf));\n extern int push_float_handler PROTO((jmp_buf, jmp_buf));\n extern void pop_float_handler PROTO((int, jmp_buf));\n #endif\n+extern int do_float_handler PROTO((void (*) (PTR), PTR));\n \n #ifdef BUFSIZ\n extern void output_quoted_string\tPROTO ((FILE *, const char *));"}, {"sha": "bfbc8c285ab12ccefa1329de71c3d9070e09c99e", "filename": "gcc/tree.c", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a87eea22067f6e19e30ad9f5dc2e41c3f204b80/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a87eea22067f6e19e30ad9f5dc2e41c3f204b80/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=1a87eea22067f6e19e30ad9f5dc2e41c3f204b80", "patch": "@@ -35,7 +35,6 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include \"system.h\"\n-#include <setjmp.h>\n #include \"flags.h\"\n #include \"tree.h\"\n #include \"except.h\"\n@@ -266,6 +265,7 @@ int (*lang_get_alias_set) PROTO((tree));\n \n static void set_type_quals PROTO((tree, int));\n static void append_random_chars PROTO((char *));\n+static void build_real_from_int_cst_1 PROTO((PTR));\n \n extern char *mode_name[];\n \n@@ -1450,6 +1450,29 @@ real_value_from_int_cst (type, i)\n   return d;\n }\n \n+struct brfic_args\n+{\n+  /* Input */\n+  tree type, i;\n+  /* Output */\n+  REAL_VALUE_TYPE d;\n+};\n+\n+static void\n+build_real_from_int_cst_1 (data)\n+  PTR data;\n+{\n+  struct brfic_args * args = (struct brfic_args *) data;\n+  \n+#ifdef REAL_ARITHMETIC\n+  args->d = real_value_from_int_cst (args->type, args->i);\n+#else\n+  args->d =\n+    REAL_VALUE_TRUNCATE (TYPE_MODE (args->type),\n+\t\t\t real_value_from_int_cst (args->type, args->i));\n+#endif\n+}\n+\n /* This function can't be implemented if we can't do arithmetic\n    on the float representation.  */\n \n@@ -1461,32 +1484,29 @@ build_real_from_int_cst (type, i)\n   tree v;\n   int overflow = TREE_OVERFLOW (i);\n   REAL_VALUE_TYPE d;\n-  jmp_buf float_error;\n+  struct brfic_args args;\n \n   v = make_node (REAL_CST);\n   TREE_TYPE (v) = type;\n \n-  if (setjmp (float_error))\n+  /* Setup input for build_real_from_int_cst_1() */\n+  args.type = type;\n+  args.i = i;\n+\n+  if (do_float_handler (build_real_from_int_cst_1, (PTR) &args))\n+    {\n+      /* Receive output from build_real_from_int_cst_1() */\n+      d = args.d;\n+    }\n+  else\n     {\n+      /* We got an exception from build_real_from_int_cst_1() */\n       d = dconst0;\n       overflow = 1;\n-      goto got_it;\n     }\n-\n-  set_float_handler (float_error);\n-\n-#ifdef REAL_ARITHMETIC\n-  d = real_value_from_int_cst (type, i);\n-#else\n-  d = REAL_VALUE_TRUNCATE (TYPE_MODE (type),\n-\t\t\t   real_value_from_int_cst (type, i));\n-#endif\n-\n+  \n   /* Check for valid float value for this type on this target machine.  */\n \n- got_it:\n-  set_float_handler (NULL_PTR);\n-\n #ifdef CHECK_FLOAT_VALUE\n   CHECK_FLOAT_VALUE (TYPE_MODE (type), d, overflow);\n #endif"}]}